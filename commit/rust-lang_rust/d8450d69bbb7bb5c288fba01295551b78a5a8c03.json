{"sha": "d8450d69bbb7bb5c288fba01295551b78a5a8c03", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ4NDUwZDY5YmJiN2JiNWMyODhmYmEwMTI5NTU1MWI3OGE1YThjMDM=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-02-17T23:19:18Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-02-18T01:27:44Z"}, "message": "rollup merge of #22435: aturon/final-stab-thread\n\nConflicts:\n\tsrc/test/bench/rt-messaging-ping-pong.rs\n\tsrc/test/bench/rt-parfib.rs\n\tsrc/test/bench/task-perf-spawnalot.rs", "tree": {"sha": "180b2e9d64e822c78f8ad38c3eb7f1501c17862d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/180b2e9d64e822c78f8ad38c3eb7f1501c17862d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d8450d69bbb7bb5c288fba01295551b78a5a8c03", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d8450d69bbb7bb5c288fba01295551b78a5a8c03", "html_url": "https://github.com/rust-lang/rust/commit/d8450d69bbb7bb5c288fba01295551b78a5a8c03", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d8450d69bbb7bb5c288fba01295551b78a5a8c03/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c14cf4dc868a9468dcf0a106a84dcafd859707fc", "url": "https://api.github.com/repos/rust-lang/rust/commits/c14cf4dc868a9468dcf0a106a84dcafd859707fc", "html_url": "https://github.com/rust-lang/rust/commit/c14cf4dc868a9468dcf0a106a84dcafd859707fc"}, {"sha": "d0de2b46e9bcca93971ef64d6ecdef872633f246", "url": "https://api.github.com/repos/rust-lang/rust/commits/d0de2b46e9bcca93971ef64d6ecdef872633f246", "html_url": "https://github.com/rust-lang/rust/commit/d0de2b46e9bcca93971ef64d6ecdef872633f246"}], "stats": {"total": 1516, "additions": 848, "deletions": 668}, "files": [{"sha": "a5aa480ab50a097a0e7e297a5f39fb0a8b9dada7", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=d8450d69bbb7bb5c288fba01295551b78a5a8c03", "patch": "@@ -35,7 +35,7 @@ use std::env;\n use std::iter::repeat;\n use std::str;\n use std::string::String;\n-use std::thread::Thread;\n+use std::thread;\n use std::time::Duration;\n use test::MetricMap;\n \n@@ -447,7 +447,7 @@ fn run_debuginfo_gdb_test(config: &Config, props: &TestProps, testfile: &Path) {\n             loop {\n                 //waiting 1 second for gdbserver start\n                 timer::sleep(Duration::milliseconds(1000));\n-                let result = Thread::scoped(move || {\n+                let result = thread::spawn(move || {\n                     tcp::TcpStream::connect(\"127.0.0.1:5039\").unwrap();\n                 }).join();\n                 if result.is_err() {"}, {"sha": "3830d7fe29532c228a9521286bfa250ae040b06b", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=d8450d69bbb7bb5c288fba01295551b78a5a8c03", "patch": "@@ -35,14 +35,14 @@\n //!\n //! ```\n //! use std::sync::Arc;\n-//! use std::thread::Thread;\n+//! use std::thread;\n //!\n //! let five = Arc::new(5);\n //!\n //! for _ in 0..10 {\n //!     let five = five.clone();\n //!\n-//!     Thread::spawn(move || {\n+//!     thread::spawn(move || {\n //!         println!(\"{:?}\", five);\n //!     });\n //! }\n@@ -52,14 +52,14 @@\n //!\n //! ```\n //! use std::sync::{Arc, Mutex};\n-//! use std::thread::Thread;\n+//! use std::thread;\n //!\n //! let five = Arc::new(Mutex::new(5));\n //!\n //! for _ in 0..10 {\n //!     let five = five.clone();\n //!\n-//!     Thread::spawn(move || {\n+//!     thread::spawn(move || {\n //!         let mut number = five.lock().unwrap();\n //!\n //!         *number += 1;\n@@ -95,7 +95,7 @@ use heap::deallocate;\n ///\n /// ```rust\n /// use std::sync::Arc;\n-/// use std::thread::Thread;\n+/// use std::thread;\n ///\n /// fn main() {\n ///     let numbers: Vec<_> = (0..100u32).map(|i| i as f32).collect();\n@@ -104,7 +104,7 @@ use heap::deallocate;\n ///     for _ in 0..10 {\n ///         let child_numbers = shared_numbers.clone();\n ///\n-///         Thread::spawn(move || {\n+///         thread::spawn(move || {\n ///             let local_numbers = child_numbers.as_slice();\n ///\n ///             // Work with the local numbers\n@@ -621,7 +621,7 @@ mod tests {\n     use std::option::Option::{Some, None};\n     use std::sync::atomic;\n     use std::sync::atomic::Ordering::{Acquire, SeqCst};\n-    use std::thread::Thread;\n+    use std::thread;\n     use std::vec::Vec;\n     use super::{Arc, Weak, weak_count, strong_count};\n     use std::sync::Mutex;\n@@ -648,7 +648,7 @@ mod tests {\n \n         let (tx, rx) = channel();\n \n-        let _t = Thread::spawn(move || {\n+        let _t = thread::spawn(move || {\n             let arc_v: Arc<Vec<i32>> = rx.recv().unwrap();\n             assert_eq!((*arc_v)[3], 4);\n         });"}, {"sha": "c2ffccc88a2e4c11e5a86433b529f8c50b5c648f", "filename": "src/libcollections/dlist.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Flibcollections%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Flibcollections%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fdlist.rs?ref=d8450d69bbb7bb5c288fba01295551b78a5a8c03", "patch": "@@ -973,7 +973,7 @@ mod tests {\n     use prelude::*;\n     use std::rand;\n     use std::hash::{self, SipHasher};\n-    use std::thread::Thread;\n+    use std::thread;\n     use test::Bencher;\n     use test;\n \n@@ -1322,7 +1322,7 @@ mod tests {\n     #[test]\n     fn test_send() {\n         let n = list_from(&[1,2,3]);\n-        Thread::scoped(move || {\n+        thread::spawn(move || {\n             check_links(&n);\n             let a: &[_] = &[&1,&2,&3];\n             assert_eq!(a, n.iter().collect::<Vec<_>>());"}, {"sha": "05d864accc130050edb18322e7866b4fed50bc7f", "filename": "src/libcore/atomic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Flibcore%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Flibcore%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fatomic.rs?ref=d8450d69bbb7bb5c288fba01295551b78a5a8c03", "patch": "@@ -42,13 +42,13 @@\n //! ```\n //! use std::sync::Arc;\n //! use std::sync::atomic::{AtomicUsize, Ordering};\n-//! use std::thread::Thread;\n+//! use std::thread;\n //!\n //! fn main() {\n //!     let spinlock = Arc::new(AtomicUsize::new(1));\n //!\n //!     let spinlock_clone = spinlock.clone();\n-//!     Thread::spawn(move|| {\n+//!     thread::spawn(move|| {\n //!         spinlock_clone.store(0, Ordering::SeqCst);\n //!     });\n //!"}, {"sha": "c13e8e7821008f0cccfdfb3015bf3cf1fd697f03", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=d8450d69bbb7bb5c288fba01295551b78a5a8c03", "patch": "@@ -375,9 +375,9 @@ impl<T> RefCell<T> {\n     ///\n     /// ```\n     /// use std::cell::RefCell;\n-    /// use std::thread::Thread;\n+    /// use std::thread;\n     ///\n-    /// let result = Thread::scoped(move || {\n+    /// let result = thread::spawn(move || {\n     ///    let c = RefCell::new(5);\n     ///    let m = c.borrow_mut();\n     ///\n@@ -436,9 +436,9 @@ impl<T> RefCell<T> {\n     ///\n     /// ```\n     /// use std::cell::RefCell;\n-    /// use std::thread::Thread;\n+    /// use std::thread;\n     ///\n-    /// let result = Thread::scoped(move || {\n+    /// let result = thread::spawn(move || {\n     ///    let c = RefCell::new(5);\n     ///    let m = c.borrow_mut();\n     ///"}, {"sha": "55fcb8498513c5a804cff7d0cbf3976e0b639171", "filename": "src/libcoretest/finally.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Flibcoretest%2Ffinally.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Flibcoretest%2Ffinally.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Ffinally.rs?ref=d8450d69bbb7bb5c288fba01295551b78a5a8c03", "patch": "@@ -11,7 +11,7 @@\n #![allow(deprecated)]\n \n use core::finally::{try_finally, Finally};\n-use std::thread::Thread;\n+use std::thread;\n \n #[test]\n fn test_success() {\n@@ -22,7 +22,7 @@ fn test_success() {\n             *i = 10;\n         },\n         |i| {\n-            assert!(!Thread::panicking());\n+            assert!(!thread::panicking());\n             assert_eq!(*i, 10);\n             *i = 20;\n         });\n@@ -40,7 +40,7 @@ fn test_fail() {\n             panic!();\n         },\n         |i| {\n-            assert!(Thread::panicking());\n+            assert!(thread::panicking());\n             assert_eq!(*i, 10);\n         })\n }"}, {"sha": "e2799eec90a1cfe3638e92a324b2fbc4085f78b9", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=d8450d69bbb7bb5c288fba01295551b78a5a8c03", "patch": "@@ -365,7 +365,7 @@ fn rust_input(cratefile: &str, externs: core::Externs, matches: &getopts::Matche\n     let cr = Path::new(cratefile);\n     info!(\"starting to run rustc\");\n \n-    let (mut krate, analysis) = std::thread::Thread::scoped(move || {\n+    let (mut krate, analysis) = std::thread::spawn(move || {\n         use rustc::session::config::Input;\n \n         let cr = cr;"}, {"sha": "bf14b86ebd1e39e21189cd0097dff9072a15fcd7", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=d8450d69bbb7bb5c288fba01295551b78a5a8c03", "patch": "@@ -15,7 +15,7 @@ use std::old_io::{Command, TempDir};\n use std::old_io;\n use std::env;\n use std::str;\n-use std::thread::Thread;\n+use std::thread;\n use std::thunk::Thunk;\n \n use std::collections::{HashSet, HashMap};\n@@ -142,7 +142,7 @@ fn runtest(test: &str, cratename: &str, libs: SearchPaths,\n     let w1 = old_io::ChanWriter::new(tx);\n     let w2 = w1.clone();\n     let old = old_io::stdio::set_stderr(box w1);\n-    Thread::spawn(move || {\n+    thread::spawn(move || {\n         let mut p = old_io::ChanReader::new(rx);\n         let mut err = match old {\n             Some(old) => {"}, {"sha": "1b9b13d4bd401c2cf3db11a8c9cd5bedb2fcce61", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=d8450d69bbb7bb5c288fba01295551b78a5a8c03", "patch": "@@ -126,7 +126,7 @@ macro_rules! try {\n /// # Examples\n ///\n /// ```\n-/// use std::thread::Thread;\n+/// use std::thread;\n /// use std::sync::mpsc;\n ///\n /// // two placeholder functions for now\n@@ -136,8 +136,8 @@ macro_rules! try {\n /// let (tx1, rx1) = mpsc::channel();\n /// let (tx2, rx2) = mpsc::channel();\n ///\n-/// Thread::spawn(move|| { long_running_task(); tx1.send(()).unwrap(); });\n-/// Thread::spawn(move|| { tx2.send(calculate_the_answer()).unwrap(); });\n+/// thread::spawn(move|| { long_running_task(); tx1.send(()).unwrap(); });\n+/// thread::spawn(move|| { tx2.send(calculate_the_answer()).unwrap(); });\n ///\n /// select! (\n ///     _ = rx1.recv() => println!(\"the long running task finished first\"),"}, {"sha": "b861b74947eeb20961995bc8a48450ccc3efe25c", "filename": "src/libstd/net/tcp.rs", "status": "modified", "additions": 38, "deletions": 38, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Flibstd%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Flibstd%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Ftcp.rs?ref=d8450d69bbb7bb5c288fba01295551b78a5a8c03", "patch": "@@ -43,7 +43,7 @@ pub struct TcpStream(net_imp::TcpStream);\n ///\n /// ```no_run\n /// use std::net::{TcpListener, TcpStream};\n-/// use std::thread::Thread;\n+/// use std::thread;\n ///\n /// let listener = TcpListener::bind(\"127.0.0.1:80\").unwrap();\n ///\n@@ -55,7 +55,7 @@ pub struct TcpStream(net_imp::TcpStream);\n /// for stream in listener.incoming() {\n ///     match stream {\n ///         Ok(stream) => {\n-///             Thread::spawn(move|| {\n+///             thread::spawn(move|| {\n ///                 // connection succeeded\n ///                 handle_client(stream)\n ///             });\n@@ -217,7 +217,7 @@ mod tests {\n     use net::*;\n     use net::test::{next_test_ip4, next_test_ip6};\n     use sync::mpsc::channel;\n-    use thread::Thread;\n+    use thread;\n \n     fn each_ip(f: &mut FnMut(SocketAddr)) {\n         f(next_test_ip4());\n@@ -257,7 +257,7 @@ mod tests {\n         let socket_addr = next_test_ip4();\n         let listener = t!(TcpListener::bind(&socket_addr));\n \n-        let _t = Thread::scoped(move || {\n+        let _t = thread::spawn(move || {\n             let mut stream = t!(TcpStream::connect(&(\"localhost\",\n                                                      socket_addr.port())));\n             t!(stream.write(&[144]));\n@@ -274,7 +274,7 @@ mod tests {\n         let addr = next_test_ip4();\n         let acceptor = t!(TcpListener::bind(&addr));\n \n-        let _t = Thread::scoped(move|| {\n+        let _t = thread::spawn(move|| {\n             let mut stream = t!(TcpStream::connect(&(\"127.0.0.1\", addr.port())));\n             t!(stream.write(&[44]));\n         });\n@@ -290,7 +290,7 @@ mod tests {\n         let addr = next_test_ip6();\n         let acceptor = t!(TcpListener::bind(&addr));\n \n-        let _t = Thread::scoped(move|| {\n+        let _t = thread::spawn(move|| {\n             let mut stream = t!(TcpStream::connect(&(\"::1\", addr.port())));\n             t!(stream.write(&[66]));\n         });\n@@ -307,7 +307,7 @@ mod tests {\n             let acceptor = t!(TcpListener::bind(&addr));\n \n             let (tx, rx) = channel();\n-            let _t = Thread::scoped(move|| {\n+            let _t = thread::spawn(move|| {\n                 let mut stream = t!(TcpStream::connect(&addr));\n                 t!(stream.write(&[99]));\n                 tx.send(t!(stream.socket_addr())).unwrap();\n@@ -326,7 +326,7 @@ mod tests {\n         each_ip(&mut |addr| {\n             let acceptor = t!(TcpListener::bind(&addr));\n \n-            let _t = Thread::scoped(move|| {\n+            let _t = thread::spawn(move|| {\n                 let _stream = t!(TcpStream::connect(&addr));\n                 // Close\n             });\n@@ -346,7 +346,7 @@ mod tests {\n             let acceptor = t!(TcpListener::bind(&addr));\n \n             let (tx, rx) = channel();\n-            let _t = Thread::scoped(move|| {\n+            let _t = thread::spawn(move|| {\n                 drop(t!(TcpStream::connect(&addr)));\n                 tx.send(()).unwrap();\n             });\n@@ -372,7 +372,7 @@ mod tests {\n             let max = 10;\n             let acceptor = t!(TcpListener::bind(&addr));\n \n-            let _t = Thread::scoped(move|| {\n+            let _t = thread::spawn(move|| {\n                 for _ in 0..max {\n                     let mut stream = t!(TcpStream::connect(&addr));\n                     t!(stream.write(&[99]));\n@@ -394,11 +394,11 @@ mod tests {\n         each_ip(&mut |addr| {\n             let acceptor = t!(TcpListener::bind(&addr));\n \n-            let _t = Thread::scoped(move|| {\n+            let _t = thread::spawn(move|| {\n                 let acceptor = acceptor;\n                 for (i, stream) in acceptor.incoming().enumerate().take(MAX) {\n                     // Start another task to handle the connection\n-                    let _t = Thread::scoped(move|| {\n+                    let _t = thread::spawn(move|| {\n                         let mut stream = t!(stream);\n                         let mut buf = [0];\n                         t!(stream.read(&mut buf));\n@@ -413,7 +413,7 @@ mod tests {\n         fn connect(i: usize, addr: SocketAddr) {\n             if i == MAX { return }\n \n-            let t = Thread::scoped(move|| {\n+            let t = thread::spawn(move|| {\n                 let mut stream = t!(TcpStream::connect(&addr));\n                 // Connect again before writing\n                 connect(i + 1, addr);\n@@ -429,10 +429,10 @@ mod tests {\n         each_ip(&mut |addr| {\n             let acceptor = t!(TcpListener::bind(&addr));\n \n-            let _t = Thread::scoped(move|| {\n+            let _t = thread::spawn(move|| {\n                 for stream in acceptor.incoming().take(MAX) {\n                     // Start another task to handle the connection\n-                    let _t = Thread::scoped(move|| {\n+                    let _t = thread::spawn(move|| {\n                         let mut stream = t!(stream);\n                         let mut buf = [0];\n                         t!(stream.read(&mut buf));\n@@ -447,7 +447,7 @@ mod tests {\n         fn connect(i: usize, addr: SocketAddr) {\n             if i == MAX { return }\n \n-            let t = Thread::scoped(move|| {\n+            let t = thread::spawn(move|| {\n                 let mut stream = t!(TcpStream::connect(&addr));\n                 connect(i + 1, addr);\n                 t!(stream.write(&[99]));\n@@ -468,7 +468,7 @@ mod tests {\n             let listener = t!(TcpListener::bind(&addr));\n             let so_name = t!(listener.socket_addr());\n             assert_eq!(addr, so_name);\n-            let _t = Thread::scoped(move|| {\n+            let _t = thread::spawn(move|| {\n                 t!(listener.accept());\n             });\n \n@@ -482,7 +482,7 @@ mod tests {\n         each_ip(&mut |addr| {\n             let (tx, rx) = channel();\n             let srv = t!(TcpListener::bind(&addr));\n-            let _t = Thread::scoped(move|| {\n+            let _t = thread::spawn(move|| {\n                 let mut cl = t!(srv.accept()).0;\n                 cl.write(&[10]).unwrap();\n                 let mut b = [0];\n@@ -518,7 +518,7 @@ mod tests {\n         each_ip(&mut |addr| {\n             let acceptor = t!(TcpListener::bind(&addr));\n \n-            let _t = Thread::scoped(move|| {\n+            let _t = thread::spawn(move|| {\n                 t!(TcpStream::connect(&addr));\n             });\n \n@@ -533,7 +533,7 @@ mod tests {\n         each_ip(&mut |addr| {\n             let acceptor = t!(TcpListener::bind(&addr));\n \n-            let _t = Thread::scoped(move|| {\n+            let _t = thread::spawn(move|| {\n                 let mut s = t!(TcpStream::connect(&addr));\n                 let mut buf = [0, 0];\n                 assert_eq!(s.read(&mut buf), Ok(1));\n@@ -546,7 +546,7 @@ mod tests {\n \n             let (tx1, rx1) = channel();\n             let (tx2, rx2) = channel();\n-            let _t = Thread::scoped(move|| {\n+            let _t = thread::spawn(move|| {\n                 let mut s2 = s2;\n                 rx1.recv().unwrap();\n                 t!(s2.write(&[1]));\n@@ -566,7 +566,7 @@ mod tests {\n             let (tx1, rx) = channel();\n             let tx2 = tx1.clone();\n \n-            let _t = Thread::scoped(move|| {\n+            let _t = thread::spawn(move|| {\n                 let mut s = t!(TcpStream::connect(&addr));\n                 t!(s.write(&[1]));\n                 rx.recv().unwrap();\n@@ -578,7 +578,7 @@ mod tests {\n             let s2 = t!(s1.try_clone());\n \n             let (done, rx) = channel();\n-            let _t = Thread::scoped(move|| {\n+            let _t = thread::spawn(move|| {\n                 let mut s2 = s2;\n                 let mut buf = [0, 0];\n                 t!(s2.read(&mut buf));\n@@ -598,7 +598,7 @@ mod tests {\n         each_ip(&mut |addr| {\n             let acceptor = t!(TcpListener::bind(&addr));\n \n-            let _t = Thread::scoped(move|| {\n+            let _t = thread::spawn(move|| {\n                 let mut s = t!(TcpStream::connect(&addr));\n                 let mut buf = [0, 1];\n                 t!(s.read(&mut buf));\n@@ -609,7 +609,7 @@ mod tests {\n             let s2 = t!(s1.try_clone());\n \n             let (done, rx) = channel();\n-            let _t = Thread::scoped(move|| {\n+            let _t = thread::spawn(move|| {\n                 let mut s2 = s2;\n                 t!(s2.write(&[1]));\n                 done.send(()).unwrap();\n@@ -624,7 +624,7 @@ mod tests {\n     fn shutdown_smoke() {\n         each_ip(&mut |addr| {\n             let a = t!(TcpListener::bind(&addr));\n-            let _t = Thread::scoped(move|| {\n+            let _t = thread::spawn(move|| {\n                 let mut c = t!(a.accept()).0;\n                 let mut b = [0];\n                 assert_eq!(c.read(&mut b), Ok(0));\n@@ -645,7 +645,7 @@ mod tests {\n         each_ip(&mut |addr| {\n             let a = t!(TcpListener::bind(&addr));\n             let (tx, rx) = channel::<()>();\n-            let _t = Thread::scoped(move|| {\n+            let _t = thread::spawn(move|| {\n                 let _s = t!(a.accept());\n                 let _ = rx.recv();\n             });\n@@ -683,15 +683,15 @@ mod tests {\n         each_ip(&mut |addr| {\n             let a = t!(TcpListener::bind(&addr));\n             let (tx1, rx) = channel::<()>();\n-            let _t = Thread::scoped(move|| {\n+            let _t = thread::spawn(move|| {\n                 let _s = t!(a.accept());\n                 let _ = rx.recv();\n             });\n \n             let s = t!(TcpStream::connect(&addr));\n             let s2 = t!(s.try_clone());\n             let (tx, rx) = channel();\n-            let _t = Thread::scoped(move|| {\n+            let _t = thread::spawn(move|| {\n                 let mut s2 = s2;\n                 assert_eq!(t!(s2.read(&mut [0])), 0);\n                 tx.send(()).unwrap();\n@@ -714,7 +714,7 @@ mod tests {\n             let (tx, rx) = channel();\n             let (txdone, rxdone) = channel();\n             let txdone2 = txdone.clone();\n-            let _t = Thread::scoped(move|| {\n+            let _t = thread::spawn(move|| {\n                 let mut tcp = t!(TcpStream::connect(&addr));\n                 rx.recv().unwrap();\n                 t!(tcp.write(&[0]));\n@@ -725,15 +725,15 @@ mod tests {\n             let tcp = t!(accept.accept()).0;\n             let tcp2 = t!(tcp.try_clone());\n             let txdone3 = txdone.clone();\n-            let _t = Thread::scoped(move|| {\n+            let _t = thread::spawn(move|| {\n                 let mut tcp2 = tcp2;\n                 t!(tcp2.read(&mut [0]));\n                 txdone3.send(()).unwrap();\n             });\n \n             // Try to ensure that the reading clone is indeed reading\n             for _ in 0..50 {\n-                Thread::yield_now();\n+                thread::yield_now();\n             }\n \n             // clone the handle again while it's reading, then let it finish the\n@@ -751,10 +751,10 @@ mod tests {\n             let a = t!(TcpListener::bind(&addr));\n             let a2 = t!(a.try_clone());\n \n-            let _t = Thread::scoped(move|| {\n+            let _t = thread::spawn(move|| {\n                 let _ = TcpStream::connect(&addr);\n             });\n-            let _t = Thread::scoped(move|| {\n+            let _t = thread::spawn(move|| {\n                 let _ = TcpStream::connect(&addr);\n             });\n \n@@ -772,17 +772,17 @@ mod tests {\n             let (tx, rx) = channel();\n             let tx2 = tx.clone();\n \n-            let _t = Thread::scoped(move|| {\n+            let _t = thread::spawn(move|| {\n                 tx.send(t!(a.accept())).unwrap();\n             });\n-            let _t = Thread::scoped(move|| {\n+            let _t = thread::spawn(move|| {\n                 tx2.send(t!(a2.accept())).unwrap();\n             });\n \n-            let _t = Thread::scoped(move|| {\n+            let _t = thread::spawn(move|| {\n                 let _ = TcpStream::connect(&addr);\n             });\n-            let _t = Thread::scoped(move|| {\n+            let _t = thread::spawn(move|| {\n                 let _ = TcpStream::connect(&addr);\n             });\n "}, {"sha": "92f00599826dd14d1e603cae5a68988a6ee55d9d", "filename": "src/libstd/net/udp.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Flibstd%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Flibstd%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fudp.rs?ref=d8450d69bbb7bb5c288fba01295551b78a5a8c03", "patch": "@@ -131,7 +131,7 @@ mod tests {\n     use net::*;\n     use net::test::{next_test_ip4, next_test_ip6};\n     use sync::mpsc::channel;\n-    use thread::Thread;\n+    use thread;\n \n     fn each_ip(f: &mut FnMut(SocketAddr, SocketAddr)) {\n         f(next_test_ip4(), next_test_ip4());\n@@ -164,7 +164,7 @@ mod tests {\n             let (tx1, rx1) = channel();\n             let (tx2, rx2) = channel();\n \n-            let _t = Thread::spawn(move|| {\n+            let _t = thread::spawn(move|| {\n                 let client = t!(UdpSocket::bind(&client_ip));\n                 rx1.recv().unwrap();\n                 t!(client.send_to(&[99], &server_ip));\n@@ -196,7 +196,7 @@ mod tests {\n             let sock1 = t!(UdpSocket::bind(&addr1));\n             let sock2 = t!(UdpSocket::bind(&addr2));\n \n-            let _t = Thread::spawn(move|| {\n+            let _t = thread::spawn(move|| {\n                 let mut buf = [0, 0];\n                 assert_eq!(sock2.recv_from(&mut buf), Ok((1, addr1)));\n                 assert_eq!(buf[0], 1);\n@@ -207,7 +207,7 @@ mod tests {\n \n             let (tx1, rx1) = channel();\n             let (tx2, rx2) = channel();\n-            let _t = Thread::spawn(move|| {\n+            let _t = thread::spawn(move|| {\n                 rx1.recv().unwrap();\n                 t!(sock3.send_to(&[1], &addr2));\n                 tx2.send(()).unwrap();\n@@ -227,7 +227,7 @@ mod tests {\n             let (tx1, rx) = channel();\n             let tx2 = tx1.clone();\n \n-            let _t = Thread::spawn(move|| {\n+            let _t = thread::spawn(move|| {\n                 t!(sock2.send_to(&[1], &addr1));\n                 rx.recv().unwrap();\n                 t!(sock2.send_to(&[2], &addr1));\n@@ -237,7 +237,7 @@ mod tests {\n             let sock3 = t!(sock1.try_clone());\n \n             let (done, rx) = channel();\n-            let _t = Thread::spawn(move|| {\n+            let _t = thread::spawn(move|| {\n                 let mut buf = [0, 0];\n                 t!(sock3.recv_from(&mut buf));\n                 tx2.send(()).unwrap();\n@@ -260,7 +260,7 @@ mod tests {\n             let (tx, rx) = channel();\n             let (serv_tx, serv_rx) = channel();\n \n-            let _t = Thread::spawn(move|| {\n+            let _t = thread::spawn(move|| {\n                 let mut buf = [0, 1];\n                 rx.recv().unwrap();\n                 t!(sock2.recv_from(&mut buf));\n@@ -271,7 +271,7 @@ mod tests {\n \n             let (done, rx) = channel();\n             let tx2 = tx.clone();\n-            let _t = Thread::spawn(move|| {\n+            let _t = thread::spawn(move|| {\n                 match sock3.send_to(&[1], &addr2) {\n                     Ok(..) => { let _ = tx2.send(()); }\n                     Err(..) => {}"}, {"sha": "a75686369ad3a1982c6d8afffb3fe0d4afc2d7a3", "filename": "src/libstd/old_io/comm_adapters.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Flibstd%2Fold_io%2Fcomm_adapters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Flibstd%2Fold_io%2Fcomm_adapters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fcomm_adapters.rs?ref=d8450d69bbb7bb5c288fba01295551b78a5a8c03", "patch": "@@ -161,12 +161,12 @@ mod test {\n     use sync::mpsc::channel;\n     use super::*;\n     use old_io;\n-    use thread::Thread;\n+    use thread;\n \n     #[test]\n     fn test_rx_reader() {\n         let (tx, rx) = channel();\n-        Thread::spawn(move|| {\n+        thread::spawn(move|| {\n           tx.send(vec![1u8, 2u8]).unwrap();\n           tx.send(vec![]).unwrap();\n           tx.send(vec![3u8, 4u8]).unwrap();\n@@ -208,7 +208,7 @@ mod test {\n     #[test]\n     fn test_rx_buffer() {\n         let (tx, rx) = channel();\n-        Thread::spawn(move|| {\n+        thread::spawn(move|| {\n           tx.send(b\"he\".to_vec()).unwrap();\n           tx.send(b\"llo wo\".to_vec()).unwrap();\n           tx.send(b\"\".to_vec()).unwrap();\n@@ -234,7 +234,7 @@ mod test {\n         writer.write_be_u32(42).unwrap();\n \n         let wanted = vec![0u8, 0u8, 0u8, 42u8];\n-        let got = match Thread::scoped(move|| { rx.recv().unwrap() }).join() {\n+        let got = match thread::spawn(move|| { rx.recv().unwrap() }).join() {\n             Ok(got) => got,\n             Err(_) => panic!(),\n         };"}, {"sha": "4bd0662232fecccacb64e69bcdb78395225daff8", "filename": "src/libstd/old_io/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Flibstd%2Fold_io%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Flibstd%2Fold_io%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fmod.rs?ref=d8450d69bbb7bb5c288fba01295551b78a5a8c03", "patch": "@@ -124,7 +124,7 @@\n //!     # #![allow(dead_code)]\n //!     use std::old_io::{TcpListener, TcpStream};\n //!     use std::old_io::{Acceptor, Listener};\n-//!     use std::thread::Thread;\n+//!     use std::thread;\n //!\n //!     let listener = TcpListener::bind(\"127.0.0.1:80\");\n //!\n@@ -140,7 +140,7 @@\n //!         match stream {\n //!             Err(e) => { /* connection failed */ }\n //!             Ok(stream) => {\n-//!                 Thread::spawn(move|| {\n+//!                 thread::spawn(move|| {\n //!                     // connection succeeded\n //!                     handle_client(stream)\n //!                 });"}, {"sha": "8e0126d5ec8e1bfeaefac4147a3e2bc827ef88ca", "filename": "src/libstd/old_io/net/pipe.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Flibstd%2Fold_io%2Fnet%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Flibstd%2Fold_io%2Fnet%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fnet%2Fpipe.rs?ref=d8450d69bbb7bb5c288fba01295551b78a5a8c03", "patch": "@@ -282,7 +282,7 @@ mod tests {\n     use old_io::test::*;\n     use super::*;\n     use sync::mpsc::channel;\n-    use thread::Thread;\n+    use thread;\n     use time::Duration;\n \n     pub fn smalltest<F,G>(server: F, client: G)\n@@ -294,7 +294,7 @@ mod tests {\n \n         let mut acceptor = UnixListener::bind(&path1).listen();\n \n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             match UnixStream::connect(&path2) {\n                 Ok(c) => client(c),\n                 Err(e) => panic!(\"failed connect: {}\", e),\n@@ -389,7 +389,7 @@ mod tests {\n             Err(e) => panic!(\"failed listen: {}\", e),\n         };\n \n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             for _ in 0u..times {\n                 let mut stream = UnixStream::connect(&path2);\n                 match stream.write(&[100]) {\n@@ -423,7 +423,7 @@ mod tests {\n         let addr = next_test_unix();\n         let mut acceptor = UnixListener::bind(&addr).listen();\n \n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let mut s = UnixStream::connect(&addr);\n             let mut buf = [0, 0];\n             debug!(\"client reading\");\n@@ -439,7 +439,7 @@ mod tests {\n \n         let (tx1, rx1) = channel();\n         let (tx2, rx2) = channel();\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let mut s2 = s2;\n             rx1.recv().unwrap();\n             debug!(\"writer writing\");\n@@ -462,7 +462,7 @@ mod tests {\n         let (tx1, rx) = channel();\n         let tx2 = tx1.clone();\n \n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let mut s = UnixStream::connect(&addr);\n             s.write(&[1]).unwrap();\n             rx.recv().unwrap();\n@@ -474,7 +474,7 @@ mod tests {\n         let s2 = s1.clone();\n \n         let (done, rx) = channel();\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let mut s2 = s2;\n             let mut buf = [0, 0];\n             s2.read(&mut buf).unwrap();\n@@ -493,7 +493,7 @@ mod tests {\n         let addr = next_test_unix();\n         let mut acceptor = UnixListener::bind(&addr).listen();\n \n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let mut s = UnixStream::connect(&addr);\n             let buf = &mut [0, 1];\n             s.read(buf).unwrap();\n@@ -504,7 +504,7 @@ mod tests {\n         let s2 = s1.clone();\n \n         let (tx, rx) = channel();\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let mut s2 = s2;\n             s2.write(&[1]).unwrap();\n             tx.send(()).unwrap();\n@@ -551,7 +551,7 @@ mod tests {\n         // continue to receive any pending connections.\n         let (tx, rx) = channel();\n         let addr2 = addr.clone();\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             tx.send(UnixStream::connect(&addr2).unwrap()).unwrap();\n         });\n         let l = rx.recv().unwrap();\n@@ -561,15 +561,15 @@ mod tests {\n                 Err(ref e) if e.kind == TimedOut => {}\n                 Err(e) => panic!(\"error: {}\", e),\n             }\n-            ::thread::Thread::yield_now();\n+            ::thread::yield_now();\n             if i == 1000 { panic!(\"should have a pending connection\") }\n         }\n         drop(l);\n \n         // Unset the timeout and make sure that this always blocks.\n         a.set_timeout(None);\n         let addr2 = addr.clone();\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             drop(UnixStream::connect(&addr2).unwrap());\n         });\n         a.accept().unwrap();\n@@ -607,7 +607,7 @@ mod tests {\n         let addr = next_test_unix();\n         let a = UnixListener::bind(&addr).listen().unwrap();\n         let (_tx, rx) = channel::<()>();\n-        Thread::spawn(move|| {\n+        thread::spawn(move|| {\n             let mut a = a;\n             let _s = a.accept().unwrap();\n             let _ = rx.recv();\n@@ -644,7 +644,7 @@ mod tests {\n         let addr = next_test_unix();\n         let a = UnixListener::bind(&addr).listen().unwrap();\n         let (_tx, rx) = channel::<()>();\n-        Thread::spawn(move|| {\n+        thread::spawn(move|| {\n             let mut a = a;\n             let _s = a.accept().unwrap();\n             let _ = rx.recv();\n@@ -653,7 +653,7 @@ mod tests {\n         let mut s = UnixStream::connect(&addr).unwrap();\n         let s2 = s.clone();\n         let (tx, rx) = channel();\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let mut s2 = s2;\n             assert!(s2.read(&mut [0]).is_err());\n             tx.send(()).unwrap();\n@@ -670,7 +670,7 @@ mod tests {\n         let addr = next_test_unix();\n         let mut a = UnixListener::bind(&addr).listen().unwrap();\n         let (tx, rx) = channel::<()>();\n-        Thread::spawn(move|| {\n+        thread::spawn(move|| {\n             let mut s = UnixStream::connect(&addr).unwrap();\n             rx.recv().unwrap();\n             assert!(s.write(&[0]).is_ok());\n@@ -708,7 +708,7 @@ mod tests {\n         let addr = next_test_unix();\n         let mut a = UnixListener::bind(&addr).listen().unwrap();\n         let (tx, rx) = channel::<()>();\n-        Thread::spawn(move|| {\n+        thread::spawn(move|| {\n             let mut s = UnixStream::connect(&addr).unwrap();\n             rx.recv().unwrap();\n             let mut amt = 0;\n@@ -737,7 +737,7 @@ mod tests {\n         let addr = next_test_unix();\n         let mut a = UnixListener::bind(&addr).listen().unwrap();\n         let (tx, rx) = channel::<()>();\n-        Thread::spawn(move|| {\n+        thread::spawn(move|| {\n             let mut s = UnixStream::connect(&addr).unwrap();\n             rx.recv().unwrap();\n             assert!(s.write(&[0]).is_ok());\n@@ -764,7 +764,7 @@ mod tests {\n         let addr = next_test_unix();\n         let mut a = UnixListener::bind(&addr).listen().unwrap();\n         let (tx, rx) = channel::<()>();\n-        Thread::spawn(move|| {\n+        thread::spawn(move|| {\n             let mut s = UnixStream::connect(&addr).unwrap();\n             rx.recv().unwrap();\n             assert!(s.write(&[0]).is_ok());\n@@ -774,7 +774,7 @@ mod tests {\n         let mut s = a.accept().unwrap();\n         let s2 = s.clone();\n         let (tx2, rx2) = channel();\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let mut s2 = s2;\n             assert!(s2.read(&mut [0]).is_ok());\n             tx2.send(()).unwrap();\n@@ -796,10 +796,10 @@ mod tests {\n         let mut a2 = a.clone();\n \n         let addr2 = addr.clone();\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let _ = UnixStream::connect(&addr2);\n         });\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let _ = UnixStream::connect(&addr);\n         });\n \n@@ -819,20 +819,20 @@ mod tests {\n         let (tx, rx) = channel();\n         let tx2 = tx.clone();\n \n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let mut a = a;\n             tx.send(a.accept()).unwrap()\n         });\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let mut a = a2;\n             tx2.send(a.accept()).unwrap()\n         });\n \n         let addr2 = addr.clone();\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let _ = UnixStream::connect(&addr2);\n         });\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let _ = UnixStream::connect(&addr);\n         });\n \n@@ -858,7 +858,7 @@ mod tests {\n         let mut a2 = a.clone();\n \n         let (tx, rx) = channel();\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let mut a = a;\n             tx.send(a.accept()).unwrap();\n         });"}, {"sha": "2afff9fc1c9b9c2a831bbc28a027d800a255e125", "filename": "src/libstd/old_io/net/tcp.rs", "status": "modified", "additions": 64, "deletions": 64, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Flibstd%2Fold_io%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Flibstd%2Fold_io%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fnet%2Ftcp.rs?ref=d8450d69bbb7bb5c288fba01295551b78a5a8c03", "patch": "@@ -137,12 +137,12 @@ impl TcpStream {\n     /// use std::old_io::timer;\n     /// use std::old_io::TcpStream;\n     /// use std::time::Duration;\n-    /// use std::thread::Thread;\n+    /// use std::thread;\n     ///\n     /// let mut stream = TcpStream::connect(\"127.0.0.1:34254\").unwrap();\n     /// let stream2 = stream.clone();\n     ///\n-    /// let _t = Thread::spawn(move|| {\n+    /// let _t = thread::spawn(move|| {\n     ///     // close this stream after one second\n     ///     timer::sleep(Duration::seconds(1));\n     ///     let mut stream = stream2;\n@@ -282,7 +282,7 @@ impl sys_common::AsInner<TcpStreamImp> for TcpStream {\n /// # fn foo() {\n /// use std::old_io::{TcpListener, TcpStream};\n /// use std::old_io::{Acceptor, Listener};\n-/// use std::thread::Thread;\n+/// use std::thread;\n ///\n /// let listener = TcpListener::bind(\"127.0.0.1:80\").unwrap();\n ///\n@@ -298,7 +298,7 @@ impl sys_common::AsInner<TcpStreamImp> for TcpStream {\n ///     match stream {\n ///         Err(e) => { /* connection failed */ }\n ///         Ok(stream) => {\n-///             Thread::spawn(move|| {\n+///             thread::spawn(move|| {\n ///                 // connection succeeded\n ///                 handle_client(stream)\n ///             });\n@@ -421,12 +421,12 @@ impl TcpAcceptor {\n     ///\n     /// ```\n     /// use std::old_io::{TcpListener, Listener, Acceptor, EndOfFile};\n-    /// use std::thread::Thread;\n+    /// use std::thread;\n     ///\n     /// let mut a = TcpListener::bind(\"127.0.0.1:8482\").listen().unwrap();\n     /// let a2 = a.clone();\n     ///\n-    /// let _t = Thread::spawn(move|| {\n+    /// let _t = thread::spawn(move|| {\n     ///     let mut a2 = a2;\n     ///     for socket in a2.incoming() {\n     ///         match socket {\n@@ -487,7 +487,7 @@ mod test {\n     use prelude::v1::*;\n \n     use sync::mpsc::channel;\n-    use thread::Thread;\n+    use thread;\n     use old_io::net::tcp::*;\n     use old_io::net::ip::*;\n     use old_io::test::*;\n@@ -522,7 +522,7 @@ mod test {\n         let listener = TcpListener::bind(socket_addr);\n         let mut acceptor = listener.listen();\n \n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let mut stream = TcpStream::connect((\"localhost\", socket_addr.port));\n             stream.write(&[144]).unwrap();\n         });\n@@ -538,7 +538,7 @@ mod test {\n         let addr = next_test_ip4();\n         let mut acceptor = TcpListener::bind(addr).listen();\n \n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let mut stream = TcpStream::connect((\"localhost\", addr.port));\n             stream.write(&[64]).unwrap();\n         });\n@@ -554,7 +554,7 @@ mod test {\n         let addr = next_test_ip4();\n         let mut acceptor = TcpListener::bind(addr).listen();\n \n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let mut stream = TcpStream::connect((\"127.0.0.1\", addr.port));\n             stream.write(&[44]).unwrap();\n         });\n@@ -570,7 +570,7 @@ mod test {\n         let addr = next_test_ip6();\n         let mut acceptor = TcpListener::bind(addr).listen();\n \n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let mut stream = TcpStream::connect((\"::1\", addr.port));\n             stream.write(&[66]).unwrap();\n         });\n@@ -586,7 +586,7 @@ mod test {\n         let addr = next_test_ip4();\n         let mut acceptor = TcpListener::bind(addr).listen();\n \n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let mut stream = TcpStream::connect(addr);\n             stream.write(&[99]).unwrap();\n         });\n@@ -602,7 +602,7 @@ mod test {\n         let addr = next_test_ip6();\n         let mut acceptor = TcpListener::bind(addr).listen();\n \n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let mut stream = TcpStream::connect(addr);\n             stream.write(&[99]).unwrap();\n         });\n@@ -618,7 +618,7 @@ mod test {\n         let addr = next_test_ip4();\n         let mut acceptor = TcpListener::bind(addr).listen();\n \n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let _stream = TcpStream::connect(addr);\n             // Close\n         });\n@@ -634,7 +634,7 @@ mod test {\n         let addr = next_test_ip6();\n         let mut acceptor = TcpListener::bind(addr).listen();\n \n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let _stream = TcpStream::connect(addr);\n             // Close\n         });\n@@ -650,7 +650,7 @@ mod test {\n         let addr = next_test_ip4();\n         let mut acceptor = TcpListener::bind(addr).listen();\n \n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let _stream = TcpStream::connect(addr);\n             // Close\n         });\n@@ -674,7 +674,7 @@ mod test {\n         let addr = next_test_ip6();\n         let mut acceptor = TcpListener::bind(addr).listen();\n \n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let _stream = TcpStream::connect(addr);\n             // Close\n         });\n@@ -699,7 +699,7 @@ mod test {\n         let mut acceptor = TcpListener::bind(addr).listen();\n \n         let (tx, rx) = channel();\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             drop(TcpStream::connect(addr));\n             tx.send(()).unwrap();\n         });\n@@ -724,7 +724,7 @@ mod test {\n         let mut acceptor = TcpListener::bind(addr).listen();\n \n         let (tx, rx) = channel();\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             drop(TcpStream::connect(addr));\n             tx.send(()).unwrap();\n         });\n@@ -749,7 +749,7 @@ mod test {\n         let max = 10u;\n         let mut acceptor = TcpListener::bind(addr).listen();\n \n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             for _ in 0..max {\n                 let mut stream = TcpStream::connect(addr);\n                 stream.write(&[99]).unwrap();\n@@ -769,7 +769,7 @@ mod test {\n         let max = 10u;\n         let mut acceptor = TcpListener::bind(addr).listen();\n \n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             for _ in 0..max {\n                 let mut stream = TcpStream::connect(addr);\n                 stream.write(&[99]).unwrap();\n@@ -789,11 +789,11 @@ mod test {\n         static MAX: int = 10;\n         let acceptor = TcpListener::bind(addr).listen();\n \n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let mut acceptor = acceptor;\n             for (i, stream) in acceptor.incoming().enumerate().take(MAX as uint) {\n                 // Start another task to handle the connection\n-                let _t = Thread::spawn(move|| {\n+                let _t = thread::spawn(move|| {\n                     let mut stream = stream;\n                     let mut buf = [0];\n                     stream.read(&mut buf).unwrap();\n@@ -808,7 +808,7 @@ mod test {\n         fn connect(i: int, addr: SocketAddr) {\n             if i == MAX { return }\n \n-            let _t = Thread::spawn(move|| {\n+            let _t = thread::spawn(move|| {\n                 debug!(\"connecting\");\n                 let mut stream = TcpStream::connect(addr);\n                 // Connect again before writing\n@@ -825,11 +825,11 @@ mod test {\n         static MAX: int = 10;\n         let acceptor = TcpListener::bind(addr).listen();\n \n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let mut acceptor = acceptor;\n             for (i, stream) in acceptor.incoming().enumerate().take(MAX as uint) {\n                 // Start another task to handle the connection\n-                let _t = Thread::spawn(move|| {\n+                let _t = thread::spawn(move|| {\n                     let mut stream = stream;\n                     let mut buf = [0];\n                     stream.read(&mut buf).unwrap();\n@@ -844,7 +844,7 @@ mod test {\n         fn connect(i: int, addr: SocketAddr) {\n             if i == MAX { return }\n \n-            let _t = Thread::spawn(move|| {\n+            let _t = thread::spawn(move|| {\n                 debug!(\"connecting\");\n                 let mut stream = TcpStream::connect(addr);\n                 // Connect again before writing\n@@ -861,11 +861,11 @@ mod test {\n         let addr = next_test_ip4();\n         let acceptor = TcpListener::bind(addr).listen();\n \n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let mut acceptor = acceptor;\n             for stream in acceptor.incoming().take(MAX as uint) {\n                 // Start another task to handle the connection\n-                let _t = Thread::spawn(move|| {\n+                let _t = thread::spawn(move|| {\n                     let mut stream = stream;\n                     let mut buf = [0];\n                     stream.read(&mut buf).unwrap();\n@@ -880,7 +880,7 @@ mod test {\n         fn connect(i: int, addr: SocketAddr) {\n             if i == MAX { return }\n \n-            let _t = Thread::spawn(move|| {\n+            let _t = thread::spawn(move|| {\n                 debug!(\"connecting\");\n                 let mut stream = TcpStream::connect(addr);\n                 // Connect again before writing\n@@ -897,11 +897,11 @@ mod test {\n         let addr = next_test_ip6();\n         let acceptor = TcpListener::bind(addr).listen();\n \n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let mut acceptor = acceptor;\n             for stream in acceptor.incoming().take(MAX as uint) {\n                 // Start another task to handle the connection\n-                let _t = Thread::spawn(move|| {\n+                let _t = thread::spawn(move|| {\n                     let mut stream = stream;\n                     let mut buf = [0];\n                     stream.read(&mut buf).unwrap();\n@@ -916,7 +916,7 @@ mod test {\n         fn connect(i: int, addr: SocketAddr) {\n             if i == MAX { return }\n \n-            let _t = Thread::spawn(move|| {\n+            let _t = thread::spawn(move|| {\n                 debug!(\"connecting\");\n                 let mut stream = TcpStream::connect(addr);\n                 // Connect again before writing\n@@ -939,7 +939,7 @@ mod test {\n \n     pub fn peer_name(addr: SocketAddr) {\n         let acceptor = TcpListener::bind(addr).listen();\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let mut acceptor = acceptor;\n             acceptor.accept().unwrap();\n         });\n@@ -974,7 +974,7 @@ mod test {\n     fn partial_read() {\n         let addr = next_test_ip4();\n         let (tx, rx) = channel();\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let mut srv = TcpListener::bind(addr).listen().unwrap();\n             tx.send(()).unwrap();\n             let mut cl = srv.accept().unwrap();\n@@ -1011,7 +1011,7 @@ mod test {\n         let addr = next_test_ip4();\n         let (tx, rx) = channel();\n \n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             rx.recv().unwrap();\n             let _stream = TcpStream::connect(addr).unwrap();\n             // Close\n@@ -1036,7 +1036,7 @@ mod test {\n         let addr = next_test_ip4();\n         let mut acceptor = TcpListener::bind(addr).listen();\n \n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let mut s = TcpStream::connect(addr);\n             let mut buf = [0, 0];\n             assert_eq!(s.read(&mut buf), Ok(1));\n@@ -1049,7 +1049,7 @@ mod test {\n \n         let (tx1, rx1) = channel();\n         let (tx2, rx2) = channel();\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let mut s2 = s2;\n             rx1.recv().unwrap();\n             s2.write(&[1]).unwrap();\n@@ -1068,7 +1068,7 @@ mod test {\n         let (tx1, rx) = channel();\n         let tx2 = tx1.clone();\n \n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let mut s = TcpStream::connect(addr);\n             s.write(&[1]).unwrap();\n             rx.recv().unwrap();\n@@ -1080,7 +1080,7 @@ mod test {\n         let s2 = s1.clone();\n \n         let (done, rx) = channel();\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let mut s2 = s2;\n             let mut buf = [0, 0];\n             s2.read(&mut buf).unwrap();\n@@ -1099,7 +1099,7 @@ mod test {\n         let addr = next_test_ip4();\n         let mut acceptor = TcpListener::bind(addr).listen();\n \n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let mut s = TcpStream::connect(addr);\n             let mut buf = [0, 1];\n             s.read(&mut buf).unwrap();\n@@ -1110,7 +1110,7 @@ mod test {\n         let s2 = s1.clone();\n \n         let (done, rx) = channel();\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let mut s2 = s2;\n             s2.write(&[1]).unwrap();\n             done.send(()).unwrap();\n@@ -1124,7 +1124,7 @@ mod test {\n     fn shutdown_smoke() {\n         let addr = next_test_ip4();\n         let a = TcpListener::bind(addr).unwrap().listen();\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let mut a = a;\n             let mut c = a.accept().unwrap();\n             assert_eq!(c.read_to_end(), Ok(vec!()));\n@@ -1158,7 +1158,7 @@ mod test {\n         //        flakiness.\n         if !cfg!(target_os = \"freebsd\") {\n             let (tx, rx) = channel();\n-            let _t = Thread::spawn(move|| {\n+            let _t = thread::spawn(move|| {\n                 tx.send(TcpStream::connect(addr).unwrap()).unwrap();\n             });\n             let _l = rx.recv().unwrap();\n@@ -1168,14 +1168,14 @@ mod test {\n                     Err(ref e) if e.kind == TimedOut => {}\n                     Err(e) => panic!(\"error: {}\", e),\n                 }\n-                ::thread::Thread::yield_now();\n+                ::thread::yield_now();\n                 if i == 1000 { panic!(\"should have a pending connection\") }\n             }\n         }\n \n         // Unset the timeout and make sure that this always blocks.\n         a.set_timeout(None);\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             drop(TcpStream::connect(addr).unwrap());\n         });\n         a.accept().unwrap();\n@@ -1186,7 +1186,7 @@ mod test {\n         let addr = next_test_ip4();\n         let a = TcpListener::bind(addr).listen().unwrap();\n         let (_tx, rx) = channel::<()>();\n-        Thread::spawn(move|| {\n+        thread::spawn(move|| {\n             let mut a = a;\n             let _s = a.accept().unwrap();\n             let _ = rx.recv().unwrap();\n@@ -1223,7 +1223,7 @@ mod test {\n         let addr = next_test_ip4();\n         let a = TcpListener::bind(addr).listen().unwrap();\n         let (_tx, rx) = channel::<()>();\n-        Thread::spawn(move|| {\n+        thread::spawn(move|| {\n             let mut a = a;\n             let _s = a.accept().unwrap();\n             let _ = rx.recv().unwrap();\n@@ -1232,7 +1232,7 @@ mod test {\n         let mut s = TcpStream::connect(addr).unwrap();\n         let s2 = s.clone();\n         let (tx, rx) = channel();\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let mut s2 = s2;\n             assert!(s2.read(&mut [0]).is_err());\n             tx.send(()).unwrap();\n@@ -1249,7 +1249,7 @@ mod test {\n         let addr = next_test_ip6();\n         let mut a = TcpListener::bind(addr).listen().unwrap();\n         let (tx, rx) = channel::<()>();\n-        Thread::spawn(move|| {\n+        thread::spawn(move|| {\n             let mut s = TcpStream::connect(addr).unwrap();\n             rx.recv().unwrap();\n             assert!(s.write(&[0]).is_ok());\n@@ -1282,7 +1282,7 @@ mod test {\n         let addr = next_test_ip6();\n         let mut a = TcpListener::bind(addr).listen().unwrap();\n         let (tx, rx) = channel::<()>();\n-        Thread::spawn(move|| {\n+        thread::spawn(move|| {\n             let mut s = TcpStream::connect(addr).unwrap();\n             rx.recv().unwrap();\n             let mut amt = 0;\n@@ -1311,7 +1311,7 @@ mod test {\n         let addr = next_test_ip6();\n         let mut a = TcpListener::bind(addr).listen().unwrap();\n         let (tx, rx) = channel::<()>();\n-        Thread::spawn(move|| {\n+        thread::spawn(move|| {\n             let mut s = TcpStream::connect(addr).unwrap();\n             rx.recv().unwrap();\n             assert!(s.write(&[0]).is_ok());\n@@ -1339,7 +1339,7 @@ mod test {\n         let addr = next_test_ip6();\n         let mut a = TcpListener::bind(addr).listen().unwrap();\n         let (tx, rx) = channel::<()>();\n-        Thread::spawn(move|| {\n+        thread::spawn(move|| {\n             let mut s = TcpStream::connect(addr).unwrap();\n             rx.recv().unwrap();\n             assert_eq!(s.write(&[0]), Ok(()));\n@@ -1349,7 +1349,7 @@ mod test {\n         let mut s = a.accept().unwrap();\n         let s2 = s.clone();\n         let (tx2, rx2) = channel();\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let mut s2 = s2;\n             assert_eq!(s2.read(&mut [0]), Ok(1));\n             tx2.send(()).unwrap();\n@@ -1372,7 +1372,7 @@ mod test {\n         let (tx, rx) = channel();\n         let (txdone, rxdone) = channel();\n         let txdone2 = txdone.clone();\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let mut tcp = TcpStream::connect(addr).unwrap();\n             rx.recv().unwrap();\n             tcp.write_u8(0).unwrap();\n@@ -1383,15 +1383,15 @@ mod test {\n         let tcp = accept.accept().unwrap();\n         let tcp2 = tcp.clone();\n         let txdone3 = txdone.clone();\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let mut tcp2 = tcp2;\n             tcp2.read_u8().unwrap();\n             txdone3.send(()).unwrap();\n         });\n \n         // Try to ensure that the reading clone is indeed reading\n         for _ in 0..50 {\n-            ::thread::Thread::yield_now();\n+            ::thread::yield_now();\n         }\n \n         // clone the handle again while it's reading, then let it finish the\n@@ -1409,10 +1409,10 @@ mod test {\n         let mut a = l.listen().unwrap();\n         let mut a2 = a.clone();\n \n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let _ = TcpStream::connect(addr);\n         });\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let _ = TcpStream::connect(addr);\n         });\n \n@@ -1430,19 +1430,19 @@ mod test {\n         let (tx, rx) = channel();\n         let tx2 = tx.clone();\n \n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let mut a = a;\n             tx.send(a.accept()).unwrap();\n         });\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let mut a = a2;\n             tx2.send(a.accept()).unwrap();\n         });\n \n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let _ = TcpStream::connect(addr);\n         });\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let _ = TcpStream::connect(addr);\n         });\n \n@@ -1468,7 +1468,7 @@ mod test {\n         let mut a2 = a.clone();\n \n         let (tx, rx) = channel();\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let mut a = a;\n             tx.send(a.accept()).unwrap();\n         });"}, {"sha": "7171198e7a4aaed7d847c240ffdbbeb1ac9fe5ec", "filename": "src/libstd/old_io/net/udp.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Flibstd%2Fold_io%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Flibstd%2Fold_io%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fnet%2Fudp.rs?ref=d8450d69bbb7bb5c288fba01295551b78a5a8c03", "patch": "@@ -186,7 +186,7 @@ mod test {\n     use old_io::test::*;\n     use old_io::{IoError, TimedOut, PermissionDenied, ShortWrite};\n     use super::*;\n-    use thread::Thread;\n+    use thread;\n \n     // FIXME #11530 this fails on android because tests are run as root\n     #[cfg_attr(any(windows, target_os = \"android\"), ignore)]\n@@ -206,7 +206,7 @@ mod test {\n         let (tx1, rx1) = channel();\n         let (tx2, rx2) = channel();\n \n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             match UdpSocket::bind(client_ip) {\n                 Ok(ref mut client) => {\n                     rx1.recv().unwrap();\n@@ -241,7 +241,7 @@ mod test {\n         let client_ip = next_test_ip6();\n         let (tx, rx) = channel::<()>();\n \n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             match UdpSocket::bind(client_ip) {\n                 Ok(ref mut client) => {\n                     rx.recv().unwrap();\n@@ -298,7 +298,7 @@ mod test {\n         let mut sock1 = UdpSocket::bind(addr1).unwrap();\n         let sock2 = UdpSocket::bind(addr2).unwrap();\n \n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let mut sock2 = sock2;\n             let mut buf = [0, 0];\n             assert_eq!(sock2.recv_from(&mut buf), Ok((1, addr1)));\n@@ -310,7 +310,7 @@ mod test {\n \n         let (tx1, rx1) = channel();\n         let (tx2, rx2) = channel();\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let mut sock3 = sock3;\n             rx1.recv().unwrap();\n             sock3.send_to(&[1], addr2).unwrap();\n@@ -331,7 +331,7 @@ mod test {\n         let (tx1, rx) = channel();\n         let tx2 = tx1.clone();\n \n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let mut sock2 = sock2;\n             sock2.send_to(&[1], addr1).unwrap();\n             rx.recv().unwrap();\n@@ -342,7 +342,7 @@ mod test {\n         let sock3 = sock1.clone();\n \n         let (done, rx) = channel();\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let mut sock3 = sock3;\n             let mut buf = [0, 0];\n             sock3.recv_from(&mut buf).unwrap();\n@@ -366,7 +366,7 @@ mod test {\n         let (tx, rx) = channel();\n         let (serv_tx, serv_rx) = channel();\n \n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let mut sock2 = sock2;\n             let mut buf = [0, 1];\n \n@@ -382,7 +382,7 @@ mod test {\n \n         let (done, rx) = channel();\n         let tx2 = tx.clone();\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let mut sock3 = sock3;\n             match sock3.send_to(&[1], addr2) {\n                 Ok(..) => { let _ = tx2.send(()); }\n@@ -410,7 +410,7 @@ mod test {\n \n         let (tx, rx) = channel();\n         let (tx2, rx2) = channel();\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let mut a = a2;\n             assert_eq!(a.recv_from(&mut [0]), Ok((1, addr1)));\n             assert_eq!(a.send_to(&[0], addr1), Ok(()));"}, {"sha": "b7b626db034e1648076fc250b22ff4284ce30afe", "filename": "src/libstd/old_io/pipe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Flibstd%2Fold_io%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Flibstd%2Fold_io%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fpipe.rs?ref=d8450d69bbb7bb5c288fba01295551b78a5a8c03", "patch": "@@ -115,7 +115,7 @@ mod test {\n     use prelude::v1::*;\n \n     use sync::mpsc::channel;\n-    use thread::Thread;\n+    use thread;\n \n     #[test]\n     fn partial_read() {\n@@ -126,7 +126,7 @@ mod test {\n         let out = PipeStream::open(writer);\n         let mut input = PipeStream::open(reader);\n         let (tx, rx) = channel();\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let mut out = out;\n             out.write(&[10]).unwrap();\n             rx.recv().unwrap(); // don't close the pipe until the other read has finished"}, {"sha": "ea6510c61b76be626372d567d9c4818d43228f0c", "filename": "src/libstd/old_io/process.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Flibstd%2Fold_io%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Flibstd%2Fold_io%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fprocess.rs?ref=d8450d69bbb7bb5c288fba01295551b78a5a8c03", "patch": "@@ -30,7 +30,7 @@ use sync::mpsc::{channel, Receiver};\n use sys::fs::FileDesc;\n use sys::process::Process as ProcessImp;\n use sys;\n-use thread::Thread;\n+use thread;\n \n #[cfg(windows)] use hash;\n #[cfg(windows)] use str;\n@@ -703,7 +703,7 @@ impl Process {\n             let (tx, rx) = channel();\n             match stream {\n                 Some(stream) => {\n-                    Thread::spawn(move || {\n+                    thread::spawn(move || {\n                         let mut stream = stream;\n                         tx.send(stream.read_to_end()).unwrap();\n                     });\n@@ -764,7 +764,7 @@ mod tests {\n     use super::{CreatePipe};\n     use super::{InheritFd, Process, PleaseExitSignal, Command, ProcessOutput};\n     use sync::mpsc::channel;\n-    use thread::Thread;\n+    use thread;\n     use time::Duration;\n \n     // FIXME(#10380) these tests should not all be ignored on android.\n@@ -1169,14 +1169,14 @@ mod tests {\n     fn wait_timeout2() {\n         let (tx, rx) = channel();\n         let tx2 = tx.clone();\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let mut p = sleeper();\n             p.set_timeout(Some(10));\n             assert_eq!(p.wait().err().unwrap().kind, TimedOut);\n             p.signal_kill().unwrap();\n             tx.send(()).unwrap();\n         });\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let mut p = sleeper();\n             p.set_timeout(Some(10));\n             assert_eq!(p.wait().err().unwrap().kind, TimedOut);"}, {"sha": "e3d0232684fcc3a9b57c25735973550c8a00b607", "filename": "src/libstd/old_io/stdio.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Flibstd%2Fold_io%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Flibstd%2Fold_io%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fstdio.rs?ref=d8450d69bbb7bb5c288fba01295551b78a5a8c03", "patch": "@@ -530,7 +530,7 @@ mod tests {\n \n     use super::*;\n     use sync::mpsc::channel;\n-    use thread::Thread;\n+    use thread;\n \n     #[test]\n     fn smoke() {\n@@ -546,7 +546,7 @@ mod tests {\n \n         let (tx, rx) = channel();\n         let (mut r, w) = (ChanReader::new(rx), ChanWriter::new(tx));\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             set_stdout(box w);\n             println!(\"hello!\");\n         });\n@@ -559,7 +559,7 @@ mod tests {\n \n         let (tx, rx) = channel();\n         let (mut r, w) = (ChanReader::new(rx), ChanWriter::new(tx));\n-        let _t = Thread::spawn(move || -> () {\n+        let _t = thread::spawn(move || -> () {\n             set_stderr(box w);\n             panic!(\"my special message\");\n         });"}, {"sha": "8b84e27eae1ba83f1ed90712bf0f7403d64980cb", "filename": "src/libstd/old_io/timer.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Flibstd%2Fold_io%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Flibstd%2Fold_io%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Ftimer.rs?ref=d8450d69bbb7bb5c288fba01295551b78a5a8c03", "patch": "@@ -224,13 +224,13 @@ fn in_ms_u64(d: Duration) -> u64 {\n #[cfg(test)]\n mod test {\n     use super::Timer;\n-    use thread::Thread;\n+    use thread;\n     use time::Duration;\n \n     #[test]\n     fn test_timer_send() {\n         let mut timer = Timer::new().unwrap();\n-        Thread::spawn(move || timer.sleep(Duration::milliseconds(1)));\n+        thread::spawn(move || timer.sleep(Duration::milliseconds(1)));\n     }\n \n     #[test]\n@@ -360,7 +360,7 @@ mod test {\n         let mut timer = Timer::new().unwrap();\n         let timer_rx = timer.periodic(Duration::milliseconds(1000));\n \n-        Thread::spawn(move|| {\n+        thread::spawn(move|| {\n             let _ = timer_rx.recv();\n         });\n \n@@ -374,7 +374,7 @@ mod test {\n         let mut timer = Timer::new().unwrap();\n         let timer_rx = timer.periodic(Duration::milliseconds(1000));\n \n-        Thread::spawn(move|| {\n+        thread::spawn(move|| {\n             let _ = timer_rx.recv();\n         });\n \n@@ -387,7 +387,7 @@ mod test {\n         let mut timer = Timer::new().unwrap();\n         let timer_rx = timer.periodic(Duration::milliseconds(1000));\n \n-        Thread::spawn(move|| {\n+        thread::spawn(move|| {\n             let _ = timer_rx.recv();\n         });\n "}, {"sha": "9bbce1934b08c6f0c85127207c5cd06b840a7f71", "filename": "src/libstd/old_path/posix.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Flibstd%2Fold_path%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Flibstd%2Fold_path%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_path%2Fposix.rs?ref=d8450d69bbb7bb5c288fba01295551b78a5a8c03", "patch": "@@ -518,18 +518,18 @@ mod tests {\n \n     #[test]\n     fn test_null_byte() {\n-        use thread::Thread;\n-        let result = Thread::scoped(move|| {\n+        use thread;\n+        let result = thread::spawn(move|| {\n             Path::new(b\"foo/bar\\0\")\n         }).join();\n         assert!(result.is_err());\n \n-        let result = Thread::scoped(move|| {\n+        let result = thread::spawn(move|| {\n             Path::new(\"test\").set_filename(b\"f\\0o\")\n         }).join();\n         assert!(result.is_err());\n \n-        let result = Thread::scoped(move|| {\n+        let result = thread::spawn(move|| {\n             Path::new(\"test\").push(b\"f\\0o\");\n         }).join();\n         assert!(result.is_err());"}, {"sha": "8362e9a9530b935520d41d5024a3704f10a673ab", "filename": "src/libstd/old_path/windows.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Flibstd%2Fold_path%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Flibstd%2Fold_path%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_path%2Fwindows.rs?ref=d8450d69bbb7bb5c288fba01295551b78a5a8c03", "patch": "@@ -1305,18 +1305,18 @@ mod tests {\n \n     #[test]\n     fn test_null_byte() {\n-        use thread::Thread;\n-        let result = Thread::scoped(move|| {\n+        use thread;\n+        let result = thread::spawn(move|| {\n             Path::new(b\"foo/bar\\0\")\n         }).join();\n         assert!(result.is_err());\n \n-        let result = Thread::scoped(move|| {\n+        let result = thread::spawn(move|| {\n             Path::new(\"test\").set_filename(b\"f\\0o\")\n         }).join();\n         assert!(result.is_err());\n \n-        let result = Thread::scoped(move || {\n+        let result = thread::spawn(move || {\n             Path::new(\"test\").push(b\"f\\0o\");\n         }).join();\n         assert!(result.is_err());"}, {"sha": "35221a7e647cc728fd5896b284669567533ceb2e", "filename": "src/libstd/panicking.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Flibstd%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Flibstd%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpanicking.rs?ref=d8450d69bbb7bb5c288fba01295551b78a5a8c03", "patch": "@@ -17,7 +17,7 @@ use cell::RefCell;\n use old_io::IoResult;\n use rt::{backtrace, unwind};\n use rt::util::{Stderr, Stdio};\n-use thread::Thread;\n+use thread;\n \n // Defined in this module instead of old_io::stdio so that the unwinding\n thread_local! {\n@@ -42,7 +42,7 @@ pub fn on_panic(obj: &(Any+Send), file: &'static str, line: uint) {\n         }\n     };\n     let mut err = Stderr;\n-    let thread = Thread::current();\n+    let thread = thread::current();\n     let name = thread.name().unwrap_or(\"<unnamed>\");\n     let prev = LOCAL_STDERR.with(|s| s.borrow_mut().take());\n     match prev {"}, {"sha": "0152bc1148b44676999b149c1dc5751fa08da628", "filename": "src/libstd/process.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Flibstd%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Flibstd%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprocess.rs?ref=d8450d69bbb7bb5c288fba01295551b78a5a8c03", "patch": "@@ -27,7 +27,7 @@ use sys::process2::Process as ProcessImp;\n use sys::process2::Command as CommandImp;\n use sys::process2::ExitStatus as ExitStatusImp;\n use sys_common::{AsInner, AsInnerMut};\n-use thread::Thread;\n+use thread;\n \n /// Representation of a running or exited child process.\n ///\n@@ -462,7 +462,7 @@ impl Child {\n             let (tx, rx) = channel();\n             match stream {\n                 Some(stream) => {\n-                    Thread::spawn(move || {\n+                    thread::spawn(move || {\n                         let mut stream = stream;\n                         let mut ret = Vec::new();\n                         let res = stream.read_to_end(&mut ret);\n@@ -499,7 +499,7 @@ mod tests {\n     use str;\n     use super::{Child, Command, Output, ExitStatus, Stdio};\n     use sync::mpsc::channel;\n-    use thread::Thread;\n+    use thread;\n     use time::Duration;\n \n     // FIXME(#10380) these tests should not all be ignored on android."}, {"sha": "0feacf5581c97414d6726b7d3ecebf598e69930b", "filename": "src/libstd/rand/os.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Flibstd%2Frand%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Flibstd%2Frand%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fos.rs?ref=d8450d69bbb7bb5c288fba01295551b78a5a8c03", "patch": "@@ -360,7 +360,7 @@ mod test {\n     use sync::mpsc::channel;\n     use rand::Rng;\n     use super::OsRng;\n-    use thread::Thread;\n+    use thread;\n \n     #[test]\n     fn test_os_rng() {\n@@ -381,23 +381,23 @@ mod test {\n             let (tx, rx) = channel();\n             txs.push(tx);\n \n-            Thread::spawn(move|| {\n+            thread::spawn(move|| {\n                 // wait until all the tasks are ready to go.\n                 rx.recv().unwrap();\n \n                 // deschedule to attempt to interleave things as much\n                 // as possible (XXX: is this a good test?)\n                 let mut r = OsRng::new().unwrap();\n-                Thread::yield_now();\n+                thread::yield_now();\n                 let mut v = [0u8; 1000];\n \n                 for _ in 0u..100 {\n                     r.next_u32();\n-                    Thread::yield_now();\n+                    thread::yield_now();\n                     r.next_u64();\n-                    Thread::yield_now();\n+                    thread::yield_now();\n                     r.fill_bytes(&mut v);\n-                    Thread::yield_now();\n+                    thread::yield_now();\n                 }\n             });\n         }"}, {"sha": "a304f1f844d748f8f263fc73db78d984ec38bbe9", "filename": "src/libstd/rt/util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Flibstd%2Frt%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Flibstd%2Frt%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Futil.rs?ref=d8450d69bbb7bb5c288fba01295551b78a5a8c03", "patch": "@@ -149,7 +149,7 @@ pub fn abort(args: fmt::Arguments) -> ! {\n }\n \n pub unsafe fn report_overflow() {\n-    use thread::Thread;\n+    use thread;\n \n     // See the message below for why this is not emitted to the\n     // ^ Where did the message below go?\n@@ -159,5 +159,5 @@ pub unsafe fn report_overflow() {\n     // and the FFI call needs 2MB of stack when we just ran out.\n \n     rterrln!(\"\\nthread '{}' has overflowed its stack\",\n-             Thread::current().name().unwrap_or(\"<unknown>\"));\n+             thread::current().name().unwrap_or(\"<unknown>\"));\n }"}, {"sha": "fc781eb4bece4efa0f16b943b05875db5b7acecc", "filename": "src/libstd/sync/barrier.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Flibstd%2Fsync%2Fbarrier.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Flibstd%2Fsync%2Fbarrier.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fbarrier.rs?ref=d8450d69bbb7bb5c288fba01295551b78a5a8c03", "patch": "@@ -15,14 +15,14 @@ use sync::{Mutex, Condvar};\n ///\n /// ```rust\n /// use std::sync::{Arc, Barrier};\n-/// use std::thread::Thread;\n+/// use std::thread;\n ///\n /// let barrier = Arc::new(Barrier::new(10));\n /// for _ in 0u..10 {\n ///     let c = barrier.clone();\n ///     // The same messages will be printed together.\n ///     // You will NOT see any interleaving.\n-///     Thread::spawn(move|| {\n+///     thread::spawn(move|| {\n ///         println!(\"before wait\");\n ///         c.wait();\n ///         println!(\"after wait\");\n@@ -111,7 +111,7 @@ mod tests {\n \n     use sync::{Arc, Barrier};\n     use sync::mpsc::{channel, TryRecvError};\n-    use thread::Thread;\n+    use thread;\n \n     #[test]\n     fn test_barrier() {\n@@ -123,7 +123,7 @@ mod tests {\n         for _ in 0u..N - 1 {\n             let c = barrier.clone();\n             let tx = tx.clone();\n-            Thread::spawn(move|| {\n+            thread::spawn(move|| {\n                 tx.send(c.wait().is_leader()).unwrap();\n             });\n         }"}, {"sha": "52561d482c39dcc4b5acf9a05de030865870b91d", "filename": "src/libstd/sync/condvar.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Flibstd%2Fsync%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Flibstd%2Fsync%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fcondvar.rs?ref=d8450d69bbb7bb5c288fba01295551b78a5a8c03", "patch": "@@ -38,13 +38,13 @@ use sync::{mutex, MutexGuard, PoisonError};\n ///\n /// ```\n /// use std::sync::{Arc, Mutex, Condvar};\n-/// use std::thread::Thread;\n+/// use std::thread;\n ///\n /// let pair = Arc::new((Mutex::new(false), Condvar::new()));\n /// let pair2 = pair.clone();\n ///\n /// // Inside of our lock, spawn a new thread, and then wait for it to start\n-/// Thread::spawn(move|| {\n+/// thread::spawn(move|| {\n ///     let &(ref lock, ref cvar) = &*pair2;\n ///     let mut started = lock.lock().unwrap();\n ///     *started = true;\n@@ -353,7 +353,7 @@ mod tests {\n     use sync::mpsc::channel;\n     use sync::{StaticMutex, MUTEX_INIT, Condvar, Mutex, Arc};\n     use sync::atomic::{AtomicUsize, ATOMIC_USIZE_INIT, Ordering};\n-    use thread::Thread;\n+    use thread;\n     use time::Duration;\n \n     #[test]\n@@ -377,7 +377,7 @@ mod tests {\n         static M: StaticMutex = MUTEX_INIT;\n \n         let g = M.lock().unwrap();\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let _g = M.lock().unwrap();\n             C.notify_one();\n         });\n@@ -395,7 +395,7 @@ mod tests {\n         for _ in 0..N {\n             let data = data.clone();\n             let tx = tx.clone();\n-            Thread::spawn(move|| {\n+            thread::spawn(move|| {\n                 let &(ref lock, ref cond) = &*data;\n                 let mut cnt = lock.lock().unwrap();\n                 *cnt += 1;\n@@ -431,7 +431,7 @@ mod tests {\n         let (g, _no_timeout) = C.wait_timeout(g, Duration::nanoseconds(1000)).unwrap();\n         // spurious wakeups mean this isn't necessarily true\n         // assert!(!no_timeout);\n-        let _t = Thread::spawn(move || {\n+        let _t = thread::spawn(move || {\n             let _g = M.lock().unwrap();\n             C.notify_one();\n         });\n@@ -452,7 +452,7 @@ mod tests {\n         assert!(!success);\n \n         let (tx, rx) = channel();\n-        let _t = Thread::scoped(move || {\n+        let _t = thread::spawn(move || {\n             rx.recv().unwrap();\n             let g = M.lock().unwrap();\n             S.store(1, Ordering::SeqCst);\n@@ -492,7 +492,7 @@ mod tests {\n         static C: StaticCondvar = CONDVAR_INIT;\n \n         let mut g = M1.lock().unwrap();\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let _g = M1.lock().unwrap();\n             C.notify_one();\n         });"}, {"sha": "ae5c1e1b4a56cc2ca345d4ee6a6467cd7538f58b", "filename": "src/libstd/sync/future.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Flibstd%2Fsync%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Flibstd%2Fsync%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Ffuture.rs?ref=d8450d69bbb7bb5c288fba01295551b78a5a8c03", "patch": "@@ -38,7 +38,7 @@ use core::mem::replace;\n use self::FutureState::*;\n use sync::mpsc::{Receiver, channel};\n use thunk::{Thunk};\n-use thread::Thread;\n+use thread;\n \n /// A type encapsulating the result of a computation which may not be complete\n pub struct Future<A> {\n@@ -143,7 +143,7 @@ impl<A:Send> Future<A> {\n \n         let (tx, rx) = channel();\n \n-        Thread::spawn(move || {\n+        thread::spawn(move || {\n             // Don't panic if the other end has hung up\n             let _ = tx.send(blk());\n         });\n@@ -157,7 +157,7 @@ mod test {\n     use prelude::v1::*;\n     use sync::mpsc::channel;\n     use sync::Future;\n-    use thread::Thread;\n+    use thread;\n \n     #[test]\n     fn test_from_value() {\n@@ -215,7 +215,7 @@ mod test {\n         let expected = \"schlorf\";\n         let (tx, rx) = channel();\n         let f = Future::spawn(move|| { expected });\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let mut f = f;\n             tx.send(f.get()).unwrap();\n         });"}, {"sha": "69b1e242b154d472857c032aab0ff00cdec3366c", "filename": "src/libstd/sync/mpsc/blocking.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Flibstd%2Fsync%2Fmpsc%2Fblocking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Flibstd%2Fsync%2Fmpsc%2Fblocking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fblocking.rs?ref=d8450d69bbb7bb5c288fba01295551b78a5a8c03", "patch": "@@ -10,7 +10,7 @@\n \n //! Generic support for building blocking abstractions.\n \n-use thread::Thread;\n+use thread::{self, Thread};\n use sync::atomic::{AtomicBool, ATOMIC_BOOL_INIT, Ordering};\n use sync::Arc;\n use marker::{Sync, Send};\n@@ -40,7 +40,7 @@ impl !Sync for WaitToken {}\n \n pub fn tokens() -> (WaitToken, SignalToken) {\n     let inner = Arc::new(Inner {\n-        thread: Thread::current(),\n+        thread: thread::current(),\n         woken: ATOMIC_BOOL_INIT,\n     });\n     let wait_token = WaitToken {\n@@ -80,7 +80,7 @@ impl SignalToken {\n impl WaitToken {\n     pub fn wait(self) {\n         while !self.inner.woken.load(Ordering::SeqCst) {\n-            Thread::park()\n+            thread::park()\n         }\n     }\n }"}, {"sha": "862745a05eb8eedead65dd21fd8fb3a904aeb74c", "filename": "src/libstd/sync/mpsc/mod.rs", "status": "modified", "additions": 77, "deletions": 77, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs?ref=d8450d69bbb7bb5c288fba01295551b78a5a8c03", "patch": "@@ -53,12 +53,12 @@\n //! Simple usage:\n //!\n //! ```\n-//! use std::thread::Thread;\n+//! use std::thread;\n //! use std::sync::mpsc::channel;\n //!\n //! // Create a simple streaming channel\n //! let (tx, rx) = channel();\n-//! Thread::spawn(move|| {\n+//! thread::spawn(move|| {\n //!     tx.send(10).unwrap();\n //! });\n //! assert_eq!(rx.recv().unwrap(), 10);\n@@ -67,7 +67,7 @@\n //! Shared usage:\n //!\n //! ```\n-//! use std::thread::Thread;\n+//! use std::thread;\n //! use std::sync::mpsc::channel;\n //!\n //! // Create a shared channel that can be sent along from many threads\n@@ -76,7 +76,7 @@\n //! let (tx, rx) = channel();\n //! for i in 0..10 {\n //!     let tx = tx.clone();\n-//!     Thread::spawn(move|| {\n+//!     thread::spawn(move|| {\n //!         tx.send(i).unwrap();\n //!     });\n //! }\n@@ -102,11 +102,11 @@\n //! Synchronous channels:\n //!\n //! ```\n-//! use std::thread::Thread;\n+//! use std::thread;\n //! use std::sync::mpsc::sync_channel;\n //!\n //! let (tx, rx) = sync_channel::<int>(0);\n-//! Thread::spawn(move|| {\n+//! thread::spawn(move|| {\n //!     // This will wait for the parent task to start receiving\n //!     tx.send(53).unwrap();\n //! });\n@@ -467,14 +467,14 @@ impl<T> UnsafeFlavor<T> for Receiver<T> {\n ///\n /// ```\n /// use std::sync::mpsc::channel;\n-/// use std::thread::Thread;\n+/// use std::thread;\n ///\n /// // tx is is the sending half (tx for transmission), and rx is the receiving\n /// // half (rx for receiving).\n /// let (tx, rx) = channel();\n ///\n /// // Spawn off an expensive computation\n-/// Thread::spawn(move|| {\n+/// thread::spawn(move|| {\n /// #   fn expensive_computation() {}\n ///     tx.send(expensive_computation()).unwrap();\n /// });\n@@ -509,14 +509,14 @@ pub fn channel<T: Send>() -> (Sender<T>, Receiver<T>) {\n ///\n /// ```\n /// use std::sync::mpsc::sync_channel;\n-/// use std::thread::Thread;\n+/// use std::thread;\n ///\n /// let (tx, rx) = sync_channel(1);\n ///\n /// // this returns immediately\n /// tx.send(1).unwrap();\n ///\n-/// Thread::spawn(move|| {\n+/// thread::spawn(move|| {\n ///     // this will block until the previous message has been received\n ///     tx.send(2).unwrap();\n /// });\n@@ -1026,7 +1026,7 @@ mod test {\n \n     use std::env;\n     use super::*;\n-    use thread::Thread;\n+    use thread;\n \n     pub fn stress_factor() -> uint {\n         match env::var(\"RUST_TEST_STRESS\") {\n@@ -1069,7 +1069,7 @@ mod test {\n     #[test]\n     fn smoke_threads() {\n         let (tx, rx) = channel::<int>();\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             tx.send(1).unwrap();\n         });\n         assert_eq!(rx.recv().unwrap(), 1);\n@@ -1101,7 +1101,7 @@ mod test {\n     #[test]\n     fn port_gone_concurrent() {\n         let (tx, rx) = channel::<int>();\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             rx.recv().unwrap();\n         });\n         while tx.send(1).is_ok() {}\n@@ -1111,7 +1111,7 @@ mod test {\n     fn port_gone_concurrent_shared() {\n         let (tx, rx) = channel::<int>();\n         let tx2 = tx.clone();\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             rx.recv().unwrap();\n         });\n         while tx.send(1).is_ok() && tx2.send(1).is_ok() {}\n@@ -1136,7 +1136,7 @@ mod test {\n     #[test]\n     fn chan_gone_concurrent() {\n         let (tx, rx) = channel::<int>();\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             tx.send(1).unwrap();\n             tx.send(1).unwrap();\n         });\n@@ -1146,7 +1146,7 @@ mod test {\n     #[test]\n     fn stress() {\n         let (tx, rx) = channel::<int>();\n-        let t = Thread::scoped(move|| {\n+        let t = thread::spawn(move|| {\n             for _ in 0u..10000 { tx.send(1).unwrap(); }\n         });\n         for _ in 0u..10000 {\n@@ -1161,7 +1161,7 @@ mod test {\n         static NTHREADS: uint = 8;\n         let (tx, rx) = channel::<int>();\n \n-        let t = Thread::scoped(move|| {\n+        let t = thread::spawn(move|| {\n             for _ in 0..AMT * NTHREADS {\n                 assert_eq!(rx.recv().unwrap(), 1);\n             }\n@@ -1173,7 +1173,7 @@ mod test {\n \n         for _ in 0..NTHREADS {\n             let tx = tx.clone();\n-            Thread::spawn(move|| {\n+            thread::spawn(move|| {\n                 for _ in 0..AMT { tx.send(1).unwrap(); }\n             });\n         }\n@@ -1185,14 +1185,14 @@ mod test {\n     fn send_from_outside_runtime() {\n         let (tx1, rx1) = channel::<()>();\n         let (tx2, rx2) = channel::<int>();\n-        let t1 = Thread::scoped(move|| {\n+        let t1 = thread::spawn(move|| {\n             tx1.send(()).unwrap();\n             for _ in 0..40 {\n                 assert_eq!(rx2.recv().unwrap(), 1);\n             }\n         });\n         rx1.recv().unwrap();\n-        let t2 = Thread::scoped(move|| {\n+        let t2 = thread::spawn(move|| {\n             for _ in 0..40 {\n                 tx2.send(1).unwrap();\n             }\n@@ -1204,7 +1204,7 @@ mod test {\n     #[test]\n     fn recv_from_outside_runtime() {\n         let (tx, rx) = channel::<int>();\n-        let t = Thread::scoped(move|| {\n+        let t = thread::spawn(move|| {\n             for _ in 0..40 {\n                 assert_eq!(rx.recv().unwrap(), 1);\n             }\n@@ -1219,11 +1219,11 @@ mod test {\n     fn no_runtime() {\n         let (tx1, rx1) = channel::<int>();\n         let (tx2, rx2) = channel::<int>();\n-        let t1 = Thread::scoped(move|| {\n+        let t1 = thread::spawn(move|| {\n             assert_eq!(rx1.recv().unwrap(), 1);\n             tx2.send(2).unwrap();\n         });\n-        let t2 = Thread::scoped(move|| {\n+        let t2 = thread::spawn(move|| {\n             tx1.send(1).unwrap();\n             assert_eq!(rx2.recv().unwrap(), 2);\n         });\n@@ -1256,7 +1256,7 @@ mod test {\n     #[test]\n     fn oneshot_single_thread_recv_chan_close() {\n         // Receiving on a closed chan will panic\n-        let res = Thread::scoped(move|| {\n+        let res = thread::spawn(move|| {\n             let (tx, rx) = channel::<int>();\n             drop(tx);\n             rx.recv().unwrap();\n@@ -1325,7 +1325,7 @@ mod test {\n     #[test]\n     fn oneshot_multi_task_recv_then_send() {\n         let (tx, rx) = channel::<Box<int>>();\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             assert!(rx.recv().unwrap() == box 10);\n         });\n \n@@ -1335,10 +1335,10 @@ mod test {\n     #[test]\n     fn oneshot_multi_task_recv_then_close() {\n         let (tx, rx) = channel::<Box<int>>();\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             drop(tx);\n         });\n-        let res = Thread::scoped(move|| {\n+        let res = thread::spawn(move|| {\n             assert!(rx.recv().unwrap() == box 10);\n         }).join();\n         assert!(res.is_err());\n@@ -1348,7 +1348,7 @@ mod test {\n     fn oneshot_multi_thread_close_stress() {\n         for _ in 0..stress_factor() {\n             let (tx, rx) = channel::<int>();\n-            let _t = Thread::spawn(move|| {\n+            let _t = thread::spawn(move|| {\n                 drop(rx);\n             });\n             drop(tx);\n@@ -1359,10 +1359,10 @@ mod test {\n     fn oneshot_multi_thread_send_close_stress() {\n         for _ in 0..stress_factor() {\n             let (tx, rx) = channel::<int>();\n-            let _t = Thread::spawn(move|| {\n+            let _t = thread::spawn(move|| {\n                 drop(rx);\n             });\n-            let _ = Thread::scoped(move|| {\n+            let _ = thread::spawn(move|| {\n                 tx.send(1).unwrap();\n             }).join();\n         }\n@@ -1372,14 +1372,14 @@ mod test {\n     fn oneshot_multi_thread_recv_close_stress() {\n         for _ in 0..stress_factor() {\n             let (tx, rx) = channel::<int>();\n-            Thread::spawn(move|| {\n-                let res = Thread::scoped(move|| {\n+            thread::spawn(move|| {\n+                let res = thread::spawn(move|| {\n                     rx.recv().unwrap();\n                 }).join();\n                 assert!(res.is_err());\n             });\n-            let _t = Thread::spawn(move|| {\n-                Thread::spawn(move|| {\n+            let _t = thread::spawn(move|| {\n+                thread::spawn(move|| {\n                     drop(tx);\n                 });\n             });\n@@ -1390,7 +1390,7 @@ mod test {\n     fn oneshot_multi_thread_send_recv_stress() {\n         for _ in 0..stress_factor() {\n             let (tx, rx) = channel();\n-            let _t = Thread::spawn(move|| {\n+            let _t = thread::spawn(move|| {\n                 tx.send(box 10).unwrap();\n             });\n             assert!(rx.recv().unwrap() == box 10);\n@@ -1408,7 +1408,7 @@ mod test {\n             fn send(tx: Sender<Box<int>>, i: int) {\n                 if i == 10 { return }\n \n-                Thread::spawn(move|| {\n+                thread::spawn(move|| {\n                     tx.send(box i).unwrap();\n                     send(tx, i + 1);\n                 });\n@@ -1417,7 +1417,7 @@ mod test {\n             fn recv(rx: Receiver<Box<int>>, i: int) {\n                 if i == 10 { return }\n \n-                Thread::spawn(move|| {\n+                thread::spawn(move|| {\n                     assert!(rx.recv().unwrap() == box i);\n                     recv(rx, i + 1);\n                 });\n@@ -1439,7 +1439,7 @@ mod test {\n         let total = stress_factor() + 100;\n         for _ in 0..total {\n             let tx = tx.clone();\n-            Thread::spawn(move|| {\n+            thread::spawn(move|| {\n                 tx.send(()).unwrap();\n             });\n         }\n@@ -1454,7 +1454,7 @@ mod test {\n         let (tx, rx) = channel::<int>();\n         let (total_tx, total_rx) = channel::<int>();\n \n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let mut acc = 0;\n             for x in rx.iter() {\n                 acc += x;\n@@ -1474,7 +1474,7 @@ mod test {\n         let (tx, rx) = channel::<int>();\n         let (count_tx, count_rx) = channel();\n \n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let mut count = 0;\n             for x in rx.iter() {\n                 if count >= 3 {\n@@ -1499,7 +1499,7 @@ mod test {\n         let (tx1, rx1) = channel::<int>();\n         let (tx2, rx2) = channel::<()>();\n         let (tx3, rx3) = channel::<()>();\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             rx2.recv().unwrap();\n             tx1.send(1).unwrap();\n             tx3.send(()).unwrap();\n@@ -1524,13 +1524,13 @@ mod test {\n     fn destroy_upgraded_shared_port_when_sender_still_active() {\n         let (tx, rx) = channel();\n         let (tx2, rx2) = channel();\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             rx.recv().unwrap(); // wait on a oneshot\n             drop(rx);  // destroy a shared\n             tx2.send(()).unwrap();\n         });\n         // make sure the other task has gone to sleep\n-        for _ in 0u..5000 { Thread::yield_now(); }\n+        for _ in 0u..5000 { thread::yield_now(); }\n \n         // upgrade to a shared chan and send a message\n         let t = tx.clone();\n@@ -1547,7 +1547,7 @@ mod sync_tests {\n     use prelude::v1::*;\n \n     use std::env;\n-    use thread::Thread;\n+    use thread;\n     use super::*;\n \n     pub fn stress_factor() -> uint {\n@@ -1583,7 +1583,7 @@ mod sync_tests {\n     #[test]\n     fn smoke_threads() {\n         let (tx, rx) = sync_channel::<int>(0);\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             tx.send(1).unwrap();\n         });\n         assert_eq!(rx.recv().unwrap(), 1);\n@@ -1608,7 +1608,7 @@ mod sync_tests {\n     #[test]\n     fn port_gone_concurrent() {\n         let (tx, rx) = sync_channel::<int>(0);\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             rx.recv().unwrap();\n         });\n         while tx.send(1).is_ok() {}\n@@ -1618,7 +1618,7 @@ mod sync_tests {\n     fn port_gone_concurrent_shared() {\n         let (tx, rx) = sync_channel::<int>(0);\n         let tx2 = tx.clone();\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             rx.recv().unwrap();\n         });\n         while tx.send(1).is_ok() && tx2.send(1).is_ok() {}\n@@ -1643,7 +1643,7 @@ mod sync_tests {\n     #[test]\n     fn chan_gone_concurrent() {\n         let (tx, rx) = sync_channel::<int>(0);\n-        Thread::spawn(move|| {\n+        thread::spawn(move|| {\n             tx.send(1).unwrap();\n             tx.send(1).unwrap();\n         });\n@@ -1653,7 +1653,7 @@ mod sync_tests {\n     #[test]\n     fn stress() {\n         let (tx, rx) = sync_channel::<int>(0);\n-        Thread::spawn(move|| {\n+        thread::spawn(move|| {\n             for _ in 0u..10000 { tx.send(1).unwrap(); }\n         });\n         for _ in 0u..10000 {\n@@ -1668,7 +1668,7 @@ mod sync_tests {\n         let (tx, rx) = sync_channel::<int>(0);\n         let (dtx, drx) = sync_channel::<()>(0);\n \n-        Thread::spawn(move|| {\n+        thread::spawn(move|| {\n             for _ in 0..AMT * NTHREADS {\n                 assert_eq!(rx.recv().unwrap(), 1);\n             }\n@@ -1681,7 +1681,7 @@ mod sync_tests {\n \n         for _ in 0..NTHREADS {\n             let tx = tx.clone();\n-            Thread::spawn(move|| {\n+            thread::spawn(move|| {\n                 for _ in 0..AMT { tx.send(1).unwrap(); }\n             });\n         }\n@@ -1714,7 +1714,7 @@ mod sync_tests {\n     #[test]\n     fn oneshot_single_thread_recv_chan_close() {\n         // Receiving on a closed chan will panic\n-        let res = Thread::scoped(move|| {\n+        let res = thread::spawn(move|| {\n             let (tx, rx) = sync_channel::<int>(0);\n             drop(tx);\n             rx.recv().unwrap();\n@@ -1789,7 +1789,7 @@ mod sync_tests {\n     #[test]\n     fn oneshot_multi_task_recv_then_send() {\n         let (tx, rx) = sync_channel::<Box<int>>(0);\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             assert!(rx.recv().unwrap() == box 10);\n         });\n \n@@ -1799,10 +1799,10 @@ mod sync_tests {\n     #[test]\n     fn oneshot_multi_task_recv_then_close() {\n         let (tx, rx) = sync_channel::<Box<int>>(0);\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             drop(tx);\n         });\n-        let res = Thread::scoped(move|| {\n+        let res = thread::spawn(move|| {\n             assert!(rx.recv().unwrap() == box 10);\n         }).join();\n         assert!(res.is_err());\n@@ -1812,7 +1812,7 @@ mod sync_tests {\n     fn oneshot_multi_thread_close_stress() {\n         for _ in 0..stress_factor() {\n             let (tx, rx) = sync_channel::<int>(0);\n-            let _t = Thread::spawn(move|| {\n+            let _t = thread::spawn(move|| {\n                 drop(rx);\n             });\n             drop(tx);\n@@ -1823,10 +1823,10 @@ mod sync_tests {\n     fn oneshot_multi_thread_send_close_stress() {\n         for _ in 0..stress_factor() {\n             let (tx, rx) = sync_channel::<int>(0);\n-            let _t = Thread::spawn(move|| {\n+            let _t = thread::spawn(move|| {\n                 drop(rx);\n             });\n-            let _ = Thread::scoped(move || {\n+            let _ = thread::spawn(move || {\n                 tx.send(1).unwrap();\n             }).join();\n         }\n@@ -1836,14 +1836,14 @@ mod sync_tests {\n     fn oneshot_multi_thread_recv_close_stress() {\n         for _ in 0..stress_factor() {\n             let (tx, rx) = sync_channel::<int>(0);\n-            let _t = Thread::spawn(move|| {\n-                let res = Thread::scoped(move|| {\n+            let _t = thread::spawn(move|| {\n+                let res = thread::spawn(move|| {\n                     rx.recv().unwrap();\n                 }).join();\n                 assert!(res.is_err());\n             });\n-            let _t = Thread::spawn(move|| {\n-                Thread::spawn(move|| {\n+            let _t = thread::spawn(move|| {\n+                thread::spawn(move|| {\n                     drop(tx);\n                 });\n             });\n@@ -1854,7 +1854,7 @@ mod sync_tests {\n     fn oneshot_multi_thread_send_recv_stress() {\n         for _ in 0..stress_factor() {\n             let (tx, rx) = sync_channel::<Box<int>>(0);\n-            let _t = Thread::spawn(move|| {\n+            let _t = thread::spawn(move|| {\n                 tx.send(box 10).unwrap();\n             });\n             assert!(rx.recv().unwrap() == box 10);\n@@ -1872,7 +1872,7 @@ mod sync_tests {\n             fn send(tx: SyncSender<Box<int>>, i: int) {\n                 if i == 10 { return }\n \n-                Thread::spawn(move|| {\n+                thread::spawn(move|| {\n                     tx.send(box i).unwrap();\n                     send(tx, i + 1);\n                 });\n@@ -1881,7 +1881,7 @@ mod sync_tests {\n             fn recv(rx: Receiver<Box<int>>, i: int) {\n                 if i == 10 { return }\n \n-                Thread::spawn(move|| {\n+                thread::spawn(move|| {\n                     assert!(rx.recv().unwrap() == box i);\n                     recv(rx, i + 1);\n                 });\n@@ -1903,7 +1903,7 @@ mod sync_tests {\n         let total = stress_factor() + 100;\n         for _ in 0..total {\n             let tx = tx.clone();\n-            Thread::spawn(move|| {\n+            thread::spawn(move|| {\n                 tx.send(()).unwrap();\n             });\n         }\n@@ -1918,7 +1918,7 @@ mod sync_tests {\n         let (tx, rx) = sync_channel::<int>(0);\n         let (total_tx, total_rx) = sync_channel::<int>(0);\n \n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let mut acc = 0;\n             for x in rx.iter() {\n                 acc += x;\n@@ -1938,7 +1938,7 @@ mod sync_tests {\n         let (tx, rx) = sync_channel::<int>(0);\n         let (count_tx, count_rx) = sync_channel(0);\n \n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let mut count = 0;\n             for x in rx.iter() {\n                 if count >= 3 {\n@@ -1963,7 +1963,7 @@ mod sync_tests {\n         let (tx1, rx1) = sync_channel::<int>(1);\n         let (tx2, rx2) = sync_channel::<()>(1);\n         let (tx3, rx3) = sync_channel::<()>(1);\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             rx2.recv().unwrap();\n             tx1.send(1).unwrap();\n             tx3.send(()).unwrap();\n@@ -1988,13 +1988,13 @@ mod sync_tests {\n     fn destroy_upgraded_shared_port_when_sender_still_active() {\n         let (tx, rx) = sync_channel::<()>(0);\n         let (tx2, rx2) = sync_channel::<()>(0);\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             rx.recv().unwrap(); // wait on a oneshot\n             drop(rx);  // destroy a shared\n             tx2.send(()).unwrap();\n         });\n         // make sure the other task has gone to sleep\n-        for _ in 0u..5000 { Thread::yield_now(); }\n+        for _ in 0u..5000 { thread::yield_now(); }\n \n         // upgrade to a shared chan and send a message\n         let t = tx.clone();\n@@ -2008,22 +2008,22 @@ mod sync_tests {\n     #[test]\n     fn send1() {\n         let (tx, rx) = sync_channel::<int>(0);\n-        let _t = Thread::spawn(move|| { rx.recv().unwrap(); });\n+        let _t = thread::spawn(move|| { rx.recv().unwrap(); });\n         assert_eq!(tx.send(1), Ok(()));\n     }\n \n     #[test]\n     fn send2() {\n         let (tx, rx) = sync_channel::<int>(0);\n-        let _t = Thread::spawn(move|| { drop(rx); });\n+        let _t = thread::spawn(move|| { drop(rx); });\n         assert!(tx.send(1).is_err());\n     }\n \n     #[test]\n     fn send3() {\n         let (tx, rx) = sync_channel::<int>(1);\n         assert_eq!(tx.send(1), Ok(()));\n-        let _t =Thread::spawn(move|| { drop(rx); });\n+        let _t =thread::spawn(move|| { drop(rx); });\n         assert!(tx.send(1).is_err());\n     }\n \n@@ -2033,11 +2033,11 @@ mod sync_tests {\n         let tx2 = tx.clone();\n         let (done, donerx) = channel();\n         let done2 = done.clone();\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             assert!(tx.send(1).is_err());\n             done.send(()).unwrap();\n         });\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             assert!(tx2.send(2).is_err());\n             done2.send(()).unwrap();\n         });\n@@ -2073,7 +2073,7 @@ mod sync_tests {\n             let (tx1, rx1) = sync_channel::<()>(3);\n             let (tx2, rx2) = sync_channel::<()>(3);\n \n-            let _t = Thread::spawn(move|| {\n+            let _t = thread::spawn(move|| {\n                 rx1.recv().unwrap();\n                 tx2.try_send(()).unwrap();\n             });"}, {"sha": "c374f8bbcee5174f1b0197d49f32888fec4ae19b", "filename": "src/libstd/sync/mpsc/mpsc_queue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Flibstd%2Fsync%2Fmpsc%2Fmpsc_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Flibstd%2Fsync%2Fmpsc%2Fmpsc_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fmpsc_queue.rs?ref=d8450d69bbb7bb5c288fba01295551b78a5a8c03", "patch": "@@ -160,7 +160,7 @@ mod tests {\n     use sync::mpsc::channel;\n     use super::{Queue, Data, Empty, Inconsistent};\n     use sync::Arc;\n-    use thread::Thread;\n+    use thread;\n \n     #[test]\n     fn test_full() {\n@@ -184,7 +184,7 @@ mod tests {\n         for _ in 0..nthreads {\n             let tx = tx.clone();\n             let q = q.clone();\n-            Thread::spawn(move|| {\n+            thread::spawn(move|| {\n                 for i in 0..nmsgs {\n                     q.push(i);\n                 }"}, {"sha": "652a9ebb020e99c5d4fc5698b9f5f98b04c3ab33", "filename": "src/libstd/sync/mpsc/select.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs?ref=d8450d69bbb7bb5c288fba01295551b78a5a8c03", "patch": "@@ -347,7 +347,7 @@ impl Iterator for Packets {\n mod test {\n     use prelude::v1::*;\n \n-    use thread::Thread;\n+    use thread;\n     use sync::mpsc::*;\n \n     // Don't use the libstd version so we can pull in the right Select structure\n@@ -427,11 +427,11 @@ mod test {\n         let (_tx2, rx2) = channel::<int>();\n         let (tx3, rx3) = channel::<int>();\n \n-        let _t = Thread::spawn(move|| {\n-            for _ in 0u..20 { Thread::yield_now(); }\n+        let _t = thread::spawn(move|| {\n+            for _ in 0u..20 { thread::yield_now(); }\n             tx1.send(1).unwrap();\n             rx3.recv().unwrap();\n-            for _ in 0u..20 { Thread::yield_now(); }\n+            for _ in 0u..20 { thread::yield_now(); }\n         });\n \n         select! {\n@@ -451,8 +451,8 @@ mod test {\n         let (tx2, rx2) = channel::<int>();\n         let (tx3, rx3) = channel::<()>();\n \n-        let _t = Thread::spawn(move|| {\n-            for _ in 0u..20 { Thread::yield_now(); }\n+        let _t = thread::spawn(move|| {\n+            for _ in 0u..20 { thread::yield_now(); }\n             tx1.send(1).unwrap();\n             tx2.send(2).unwrap();\n             rx3.recv().unwrap();\n@@ -478,7 +478,7 @@ mod test {\n         let (tx2, rx2) = channel::<int>();\n         let (tx3, rx3) = channel::<()>();\n \n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             for i in 0..AMT {\n                 if i % 2 == 0 {\n                     tx1.send(i).unwrap();\n@@ -504,7 +504,7 @@ mod test {\n         let (_tx2, rx2) = channel::<int>();\n         let (tx3, rx3) = channel::<()>();\n \n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             rx3.recv().unwrap();\n             tx1.clone();\n             assert_eq!(rx3.try_recv(), Err(TryRecvError::Empty));\n@@ -526,7 +526,7 @@ mod test {\n         let (_tx2, rx2) = channel::<int>();\n         let (tx3, rx3) = channel::<()>();\n \n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             rx3.recv().unwrap();\n             tx1.clone();\n             assert_eq!(rx3.try_recv(), Err(TryRecvError::Empty));\n@@ -547,7 +547,7 @@ mod test {\n         let (tx1, rx1) = channel::<()>();\n         let (tx2, rx2) = channel::<()>();\n         let (tx3, rx3) = channel::<()>();\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let s = Select::new();\n             let mut h1 = s.handle(&rx1);\n             let mut h2 = s.handle(&rx2);\n@@ -557,7 +557,7 @@ mod test {\n             tx3.send(()).unwrap();\n         });\n \n-        for _ in 0u..1000 { Thread::yield_now(); }\n+        for _ in 0u..1000 { thread::yield_now(); }\n         drop(tx1.clone());\n         tx2.send(()).unwrap();\n         rx3.recv().unwrap();\n@@ -663,14 +663,14 @@ mod test {\n     fn oneshot_data_waiting() {\n         let (tx1, rx1) = channel();\n         let (tx2, rx2) = channel();\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             select! {\n                 _n = rx1.recv() => {}\n             }\n             tx2.send(()).unwrap();\n         });\n \n-        for _ in 0u..100 { Thread::yield_now() }\n+        for _ in 0u..100 { thread::yield_now() }\n         tx1.send(()).unwrap();\n         rx2.recv().unwrap();\n     }\n@@ -683,14 +683,14 @@ mod test {\n         tx1.send(()).unwrap();\n         rx1.recv().unwrap();\n         rx1.recv().unwrap();\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             select! {\n                 _n = rx1.recv() => {}\n             }\n             tx2.send(()).unwrap();\n         });\n \n-        for _ in 0u..100 { Thread::yield_now() }\n+        for _ in 0u..100 { thread::yield_now() }\n         tx1.send(()).unwrap();\n         rx2.recv().unwrap();\n     }\n@@ -702,14 +702,14 @@ mod test {\n         drop(tx1.clone());\n         tx1.send(()).unwrap();\n         rx1.recv().unwrap();\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             select! {\n                 _n = rx1.recv() => {}\n             }\n             tx2.send(()).unwrap();\n         });\n \n-        for _ in 0u..100 { Thread::yield_now() }\n+        for _ in 0u..100 { thread::yield_now() }\n         tx1.send(()).unwrap();\n         rx2.recv().unwrap();\n     }\n@@ -726,8 +726,8 @@ mod test {\n     #[test]\n     fn sync2() {\n         let (tx, rx) = sync_channel::<int>(0);\n-        let _t = Thread::spawn(move|| {\n-            for _ in 0u..100 { Thread::yield_now() }\n+        let _t = thread::spawn(move|| {\n+            for _ in 0u..100 { thread::yield_now() }\n             tx.send(1).unwrap();\n         });\n         select! {\n@@ -739,8 +739,8 @@ mod test {\n     fn sync3() {\n         let (tx1, rx1) = sync_channel::<int>(0);\n         let (tx2, rx2): (Sender<int>, Receiver<int>) = channel();\n-        let _t = Thread::spawn(move|| { tx1.send(1).unwrap(); });\n-        let _t = Thread::spawn(move|| { tx2.send(2).unwrap(); });\n+        let _t = thread::spawn(move|| { tx1.send(1).unwrap(); });\n+        let _t = thread::spawn(move|| { tx2.send(2).unwrap(); });\n         select! {\n             n = rx1.recv() => {\n                 let n = n.unwrap();"}, {"sha": "729e7991f97cfb2cb03c97c2854c253ee8dd0f7d", "filename": "src/libstd/sync/mpsc/shared.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Flibstd%2Fsync%2Fmpsc%2Fshared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Flibstd%2Fsync%2Fmpsc%2Fshared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fshared.rs?ref=d8450d69bbb7bb5c288fba01295551b78a5a8c03", "patch": "@@ -31,7 +31,7 @@ use sync::mpsc::mpsc_queue as mpsc;\n use sync::mpsc::select::StartResult::*;\n use sync::mpsc::select::StartResult;\n use sync::{Mutex, MutexGuard};\n-use thread::Thread;\n+use thread;\n \n const DISCONNECTED: isize = isize::MIN;\n const FUDGE: isize = 1024;\n@@ -194,7 +194,7 @@ impl<T: Send> Packet<T> {\n                             match self.queue.pop() {\n                                 mpsc::Data(..) => {}\n                                 mpsc::Empty => break,\n-                                mpsc::Inconsistent => Thread::yield_now(),\n+                                mpsc::Inconsistent => thread::yield_now(),\n                             }\n                         }\n                         // maybe we're done, if we're not the last ones\n@@ -283,7 +283,7 @@ impl<T: Send> Packet<T> {\n             mpsc::Inconsistent => {\n                 let data;\n                 loop {\n-                    Thread::yield_now();\n+                    thread::yield_now();\n                     match self.queue.pop() {\n                         mpsc::Data(t) => { data = t; break }\n                         mpsc::Empty => panic!(\"inconsistent => empty\"),\n@@ -460,7 +460,7 @@ impl<T: Send> Packet<T> {\n                 drop(self.take_to_wake());\n             } else {\n                 while self.to_wake.load(Ordering::SeqCst) != 0 {\n-                    Thread::yield_now();\n+                    thread::yield_now();\n                 }\n             }\n             // if the number of steals is -1, it was the pre-emptive -1 steal"}, {"sha": "c03bf024818559453a96b00496aa69d6ec517ce9", "filename": "src/libstd/sync/mpsc/spsc_queue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Flibstd%2Fsync%2Fmpsc%2Fspsc_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Flibstd%2Fsync%2Fmpsc%2Fspsc_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fspsc_queue.rs?ref=d8450d69bbb7bb5c288fba01295551b78a5a8c03", "patch": "@@ -246,7 +246,7 @@ mod test {\n \n     use sync::Arc;\n     use super::Queue;\n-    use thread::Thread;\n+    use thread;\n     use sync::mpsc::channel;\n \n     #[test]\n@@ -324,7 +324,7 @@ mod test {\n \n             let (tx, rx) = channel();\n             let q2 = q.clone();\n-            let _t = Thread::spawn(move|| {\n+            let _t = thread::spawn(move|| {\n                 for _ in 0u..100000 {\n                     loop {\n                         match q2.pop() {"}, {"sha": "2d528662f64fc9dd3fa2f725cb7934bcaf3303c2", "filename": "src/libstd/sync/mpsc/stream.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Flibstd%2Fsync%2Fmpsc%2Fstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Flibstd%2Fsync%2Fmpsc%2Fstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fstream.rs?ref=d8450d69bbb7bb5c288fba01295551b78a5a8c03", "patch": "@@ -26,7 +26,7 @@ use core::prelude::*;\n \n use core::cmp;\n use core::isize;\n-use thread::Thread;\n+use thread;\n \n use sync::atomic::{AtomicIsize, AtomicUsize, Ordering, AtomicBool};\n use sync::mpsc::Receiver;\n@@ -440,7 +440,7 @@ impl<T: Send> Packet<T> {\n                 drop(self.take_to_wake());\n             } else {\n                 while self.to_wake.load(Ordering::SeqCst) != 0 {\n-                    Thread::yield_now();\n+                    thread::yield_now();\n                 }\n             }\n             assert_eq!(self.steals, 0);"}, {"sha": "d7e8419f19f657cd5a75792ff29fa6c4f812d382", "filename": "src/libstd/sync/mutex.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Flibstd%2Fsync%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Flibstd%2Fsync%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmutex.rs?ref=d8450d69bbb7bb5c288fba01295551b78a5a8c03", "patch": "@@ -47,7 +47,7 @@ use sys_common::mutex as sys;\n ///\n /// ```rust\n /// use std::sync::{Arc, Mutex};\n-/// use std::thread::Thread;\n+/// use std::thread;\n /// use std::sync::mpsc::channel;\n ///\n /// const N: uint = 10;\n@@ -62,7 +62,7 @@ use sys_common::mutex as sys;\n /// let (tx, rx) = channel();\n /// for _ in 0u..10 {\n ///     let (data, tx) = (data.clone(), tx.clone());\n-///     Thread::spawn(move || {\n+///     thread::spawn(move || {\n ///         // The shared static can only be accessed once the lock is held.\n ///         // Our non-atomic increment is safe because we're the only thread\n ///         // which can access the shared state when the lock is held.\n@@ -85,12 +85,12 @@ use sys_common::mutex as sys;\n ///\n /// ```rust\n /// use std::sync::{Arc, Mutex};\n-/// use std::thread::Thread;\n+/// use std::thread;\n ///\n /// let lock = Arc::new(Mutex::new(0u));\n /// let lock2 = lock.clone();\n ///\n-/// let _ = Thread::scoped(move || -> () {\n+/// let _ = thread::spawn(move || -> () {\n ///     // This thread will acquire the mutex first, unwrapping the result of\n ///     // `lock` because the lock has not been poisoned.\n ///     let _lock = lock2.lock().unwrap();\n@@ -350,7 +350,7 @@ mod test {\n \n     use sync::mpsc::channel;\n     use sync::{Arc, Mutex, StaticMutex, MUTEX_INIT, Condvar};\n-    use thread::Thread;\n+    use thread;\n \n     struct Packet<T>(Arc<(Mutex<T>, Condvar)>);\n \n@@ -393,9 +393,9 @@ mod test {\n         let (tx, rx) = channel();\n         for _ in 0..K {\n             let tx2 = tx.clone();\n-            Thread::spawn(move|| { inc(); tx2.send(()).unwrap(); });\n+            thread::spawn(move|| { inc(); tx2.send(()).unwrap(); });\n             let tx2 = tx.clone();\n-            Thread::spawn(move|| { inc(); tx2.send(()).unwrap(); });\n+            thread::spawn(move|| { inc(); tx2.send(()).unwrap(); });\n         }\n \n         drop(tx);\n@@ -419,7 +419,7 @@ mod test {\n         let packet = Packet(Arc::new((Mutex::new(false), Condvar::new())));\n         let packet2 = Packet(packet.0.clone());\n         let (tx, rx) = channel();\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             // wait until parent gets in\n             rx.recv().unwrap();\n             let &(ref lock, ref cvar) = &*packet2.0;\n@@ -443,7 +443,7 @@ mod test {\n         let packet2 = Packet(packet.0.clone());\n         let (tx, rx) = channel();\n \n-        let _t = Thread::spawn(move || -> () {\n+        let _t = thread::spawn(move || -> () {\n             rx.recv().unwrap();\n             let &(ref lock, ref cvar) = &*packet2.0;\n             let _g = lock.lock().unwrap();\n@@ -471,7 +471,7 @@ mod test {\n         let arc = Arc::new(Mutex::new(1));\n         assert!(!arc.is_poisoned());\n         let arc2 = arc.clone();\n-        let _ = Thread::scoped(move|| {\n+        let _ = thread::spawn(move|| {\n             let lock = arc2.lock().unwrap();\n             assert_eq!(*lock, 2);\n         }).join();\n@@ -486,7 +486,7 @@ mod test {\n         let arc = Arc::new(Mutex::new(1));\n         let arc2 = Arc::new(Mutex::new(arc));\n         let (tx, rx) = channel();\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let lock = arc2.lock().unwrap();\n             let lock2 = lock.lock().unwrap();\n             assert_eq!(*lock2, 1);\n@@ -499,7 +499,7 @@ mod test {\n     fn test_mutex_arc_access_in_unwind() {\n         let arc = Arc::new(Mutex::new(1));\n         let arc2 = arc.clone();\n-        let _ = Thread::scoped(move|| -> () {\n+        let _ = thread::spawn(move|| -> () {\n             struct Unwinder {\n                 i: Arc<Mutex<int>>,\n             }"}, {"sha": "1e87c0d612bdcc5561eb8cf79cdf8709662be3c7", "filename": "src/libstd/sync/once.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Flibstd%2Fsync%2Fonce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Flibstd%2Fsync%2Fonce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fonce.rs?ref=d8450d69bbb7bb5c288fba01295551b78a5a8c03", "patch": "@@ -127,7 +127,7 @@ impl Once {\n mod test {\n     use prelude::v1::*;\n \n-    use thread::Thread;\n+    use thread;\n     use super::{ONCE_INIT, Once};\n     use sync::mpsc::channel;\n \n@@ -149,8 +149,8 @@ mod test {\n         let (tx, rx) = channel();\n         for _ in 0u..10 {\n             let tx = tx.clone();\n-            Thread::spawn(move|| {\n-                for _ in 0u..4 { Thread::yield_now() }\n+            thread::spawn(move|| {\n+                for _ in 0u..4 { thread::yield_now() }\n                 unsafe {\n                     O.call_once(|| {\n                         assert!(!run);"}, {"sha": "32c8150ba4070172473cfe7d7602dca56a8c09de", "filename": "src/libstd/sync/poison.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Flibstd%2Fsync%2Fpoison.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Flibstd%2Fsync%2Fpoison.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fpoison.rs?ref=d8450d69bbb7bb5c288fba01295551b78a5a8c03", "patch": "@@ -13,15 +13,15 @@ use prelude::v1::*;\n use cell::UnsafeCell;\n use error::{Error, FromError};\n use fmt;\n-use thread::Thread;\n+use thread;\n \n pub struct Flag { failed: UnsafeCell<bool> }\n pub const FLAG_INIT: Flag = Flag { failed: UnsafeCell { value: false } };\n \n impl Flag {\n     #[inline]\n     pub fn borrow(&self) -> LockResult<Guard> {\n-        let ret = Guard { panicking: Thread::panicking() };\n+        let ret = Guard { panicking: thread::panicking() };\n         if unsafe { *self.failed.get() } {\n             Err(PoisonError::new(ret))\n         } else {\n@@ -31,7 +31,7 @@ impl Flag {\n \n     #[inline]\n     pub fn done(&self, guard: &Guard) {\n-        if !guard.panicking && Thread::panicking() {\n+        if !guard.panicking && thread::panicking() {\n             unsafe { *self.failed.get() = true; }\n         }\n     }"}, {"sha": "402542b8bdc3208e5c57e3b4e87d09bea0f98115", "filename": "src/libstd/sync/rwlock.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Flibstd%2Fsync%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Flibstd%2Fsync%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Frwlock.rs?ref=d8450d69bbb7bb5c288fba01295551b78a5a8c03", "patch": "@@ -400,7 +400,7 @@ mod tests {\n \n     use rand::{self, Rng};\n     use sync::mpsc::channel;\n-    use thread::Thread;\n+    use thread;\n     use sync::{Arc, RwLock, StaticRwLock, RW_LOCK_INIT};\n \n     #[test]\n@@ -431,7 +431,7 @@ mod tests {\n         let (tx, rx) = channel::<()>();\n         for _ in 0..N {\n             let tx = tx.clone();\n-            Thread::spawn(move|| {\n+            thread::spawn(move|| {\n                 let mut rng = rand::thread_rng();\n                 for _ in 0..M {\n                     if rng.gen_weighted_bool(N) {\n@@ -452,7 +452,7 @@ mod tests {\n     fn test_rw_arc_poison_wr() {\n         let arc = Arc::new(RwLock::new(1));\n         let arc2 = arc.clone();\n-        let _: Result<uint, _> = Thread::scoped(move|| {\n+        let _: Result<uint, _> = thread::spawn(move|| {\n             let _lock = arc2.write().unwrap();\n             panic!();\n         }).join();\n@@ -464,7 +464,7 @@ mod tests {\n         let arc = Arc::new(RwLock::new(1));\n         assert!(!arc.is_poisoned());\n         let arc2 = arc.clone();\n-        let _: Result<uint, _> = Thread::scoped(move|| {\n+        let _: Result<uint, _> = thread::spawn(move|| {\n             let _lock = arc2.write().unwrap();\n             panic!();\n         }).join();\n@@ -476,7 +476,7 @@ mod tests {\n     fn test_rw_arc_no_poison_rr() {\n         let arc = Arc::new(RwLock::new(1));\n         let arc2 = arc.clone();\n-        let _: Result<uint, _> = Thread::scoped(move|| {\n+        let _: Result<uint, _> = thread::spawn(move|| {\n             let _lock = arc2.read().unwrap();\n             panic!();\n         }).join();\n@@ -487,7 +487,7 @@ mod tests {\n     fn test_rw_arc_no_poison_rw() {\n         let arc = Arc::new(RwLock::new(1));\n         let arc2 = arc.clone();\n-        let _: Result<uint, _> = Thread::scoped(move|| {\n+        let _: Result<uint, _> = thread::spawn(move|| {\n             let _lock = arc2.read().unwrap();\n             panic!()\n         }).join();\n@@ -501,12 +501,12 @@ mod tests {\n         let arc2 = arc.clone();\n         let (tx, rx) = channel();\n \n-        Thread::spawn(move|| {\n+        thread::spawn(move|| {\n             let mut lock = arc2.write().unwrap();\n             for _ in 0u..10 {\n                 let tmp = *lock;\n                 *lock = -1;\n-                Thread::yield_now();\n+                thread::yield_now();\n                 *lock = tmp + 1;\n             }\n             tx.send(()).unwrap();\n@@ -516,7 +516,7 @@ mod tests {\n         let mut children = Vec::new();\n         for _ in 0u..5 {\n             let arc3 = arc.clone();\n-            children.push(Thread::scoped(move|| {\n+            children.push(thread::spawn(move|| {\n                 let lock = arc3.read().unwrap();\n                 assert!(*lock >= 0);\n             }));\n@@ -537,7 +537,7 @@ mod tests {\n     fn test_rw_arc_access_in_unwind() {\n         let arc = Arc::new(RwLock::new(1));\n         let arc2 = arc.clone();\n-        let _ = Thread::scoped(move|| -> () {\n+        let _ = thread::spawn(move|| -> () {\n             struct Unwinder {\n                 i: Arc<RwLock<int>>,\n             }"}, {"sha": "410e1c11bb9a992387af0b8fa0562b7eb6e65e56", "filename": "src/libstd/sync/semaphore.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Flibstd%2Fsync%2Fsemaphore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Flibstd%2Fsync%2Fsemaphore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fsemaphore.rs?ref=d8450d69bbb7bb5c288fba01295551b78a5a8c03", "patch": "@@ -114,7 +114,7 @@ mod tests {\n     use sync::Arc;\n     use super::Semaphore;\n     use sync::mpsc::channel;\n-    use thread::Thread;\n+    use thread;\n \n     #[test]\n     fn test_sem_acquire_release() {\n@@ -134,7 +134,7 @@ mod tests {\n     fn test_sem_as_mutex() {\n         let s = Arc::new(Semaphore::new(1));\n         let s2 = s.clone();\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let _g = s2.access();\n         });\n         let _g = s.access();\n@@ -146,7 +146,7 @@ mod tests {\n         let (tx, rx) = channel();\n         let s = Arc::new(Semaphore::new(0));\n         let s2 = s.clone();\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             s2.acquire();\n             tx.send(()).unwrap();\n         });\n@@ -157,7 +157,7 @@ mod tests {\n         let (tx, rx) = channel();\n         let s = Arc::new(Semaphore::new(0));\n         let s2 = s.clone();\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             s2.release();\n             let _ = rx.recv();\n         });\n@@ -173,7 +173,7 @@ mod tests {\n         let s2 = s.clone();\n         let (tx1, rx1) = channel();\n         let (tx2, rx2) = channel();\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             let _g = s2.access();\n             let _ = rx2.recv();\n             tx1.send(()).unwrap();\n@@ -190,7 +190,7 @@ mod tests {\n         let (tx, rx) = channel();\n         {\n             let _g = s.access();\n-            Thread::spawn(move|| {\n+            thread::spawn(move|| {\n                 tx.send(()).unwrap();\n                 drop(s2.access());\n                 tx.send(()).unwrap();"}, {"sha": "06c0c84c418040cc9c196d47d546d422f17bb513", "filename": "src/libstd/sync/task_pool.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Flibstd%2Fsync%2Ftask_pool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Flibstd%2Fsync%2Ftask_pool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Ftask_pool.rs?ref=d8450d69bbb7bb5c288fba01295551b78a5a8c03", "patch": "@@ -20,7 +20,7 @@ use core::prelude::*;\n \n use sync::{Arc, Mutex};\n use sync::mpsc::{channel, Sender, Receiver};\n-use thread::Thread;\n+use thread;\n use thunk::Thunk;\n \n struct Sentinel<'a> {\n@@ -112,7 +112,7 @@ impl TaskPool {\n }\n \n fn spawn_in_pool(jobs: Arc<Mutex<Receiver<Thunk>>>) {\n-    Thread::spawn(move || {\n+    thread::spawn(move || {\n         // Will spawn a new thread on panic unless it is cancelled.\n         let sentinel = Sentinel::new(&jobs);\n "}, {"sha": "d3273646b3f4c2cb11d06bd8ab66c286576e0c9f", "filename": "src/libstd/sys/common/helper_thread.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Flibstd%2Fsys%2Fcommon%2Fhelper_thread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Flibstd%2Fsys%2Fcommon%2Fhelper_thread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fhelper_thread.rs?ref=d8450d69bbb7bb5c288fba01295551b78a5a8c03", "patch": "@@ -30,7 +30,7 @@ use sync::{StaticMutex, StaticCondvar};\n use sync::mpsc::{channel, Sender, Receiver};\n use sys::helper_signal;\n \n-use thread::Thread;\n+use thread;\n \n /// A structure for management of a helper thread.\n ///\n@@ -95,7 +95,7 @@ impl<M: Send> Helper<M> {\n                 let receive = RaceBox(receive);\n \n                 let t = f();\n-                Thread::spawn(move || {\n+                thread::spawn(move || {\n                     helper(receive.0, rx, t);\n                     let _g = self.lock.lock().unwrap();\n                     *self.shutdown.get() = true;"}, {"sha": "65c706033f213034c2923f4a78b1c8ce859fe16e", "filename": "src/libstd/sys/common/thread_info.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Flibstd%2Fsys%2Fcommon%2Fthread_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Flibstd%2Fsys%2Fcommon%2Fthread_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fthread_info.rs?ref=d8450d69bbb7bb5c288fba01295551b78a5a8c03", "patch": "@@ -29,7 +29,7 @@ thread_local! { static THREAD_INFO: RefCell<Option<ThreadInfo>> = RefCell::new(N\n impl ThreadInfo {\n     fn with<R, F>(f: F) -> R where F: FnOnce(&mut ThreadInfo) -> R {\n         if THREAD_INFO.state() == State::Destroyed {\n-            panic!(\"Use of std::thread::Thread::current() is not possible after \\\n+            panic!(\"Use of std::thread::current() is not possible after \\\n                     the thread's local data has been destroyed\");\n         }\n \n@@ -63,7 +63,7 @@ pub fn set(stack_bounds: (uint, uint), stack_guard: uint, thread: Thread) {\n     }));\n }\n \n-// a hack to get around privacy restrictions; implemented by `std::thread::Thread`\n+// a hack to get around privacy restrictions; implemented by `std::thread`\n pub trait NewThread {\n     fn new(name: Option<String>) -> Self;\n }"}, {"sha": "27b8784e3943a6a46320fbddc45c6ee8066d88da", "filename": "src/libstd/sys/common/thread_local.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Flibstd%2Fsys%2Fcommon%2Fthread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Flibstd%2Fsys%2Fcommon%2Fthread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fthread_local.rs?ref=d8450d69bbb7bb5c288fba01295551b78a5a8c03", "patch": "@@ -24,7 +24,7 @@\n //! # Usage\n //!\n //! This module should likely not be used directly unless other primitives are\n-//! being built on. types such as `thread_local::scoped::Key` are likely much\n+//! being built on. types such as `thread_local::spawn::Key` are likely much\n //! more useful in practice than this OS-based version which likely requires\n //! unsafe code to interoperate with.\n //!"}, {"sha": "82c52471d109719ef99d0e5aab5a6fa4103a434f", "filename": "src/libstd/sys/unix/thread.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Flibstd%2Fsys%2Funix%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Flibstd%2Fsys%2Funix%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fthread.rs?ref=d8450d69bbb7bb5c288fba01295551b78a5a8c03", "patch": "@@ -10,6 +10,7 @@\n \n use core::prelude::*;\n \n+use io;\n use boxed::Box;\n use cmp;\n use mem;\n@@ -191,7 +192,7 @@ pub mod guard {\n     }\n }\n \n-pub unsafe fn create(stack: uint, p: Thunk) -> rust_thread {\n+pub unsafe fn create(stack: uint, p: Thunk) -> io::Result<rust_thread> {\n     let mut native: libc::pthread_t = mem::zeroed();\n     let mut attr: libc::pthread_attr_t = mem::zeroed();\n     assert_eq!(pthread_attr_init(&mut attr), 0);\n@@ -226,9 +227,10 @@ pub unsafe fn create(stack: uint, p: Thunk) -> rust_thread {\n     if ret != 0 {\n         // be sure to not leak the closure\n         let _p: Box<Box<FnOnce()+Send>> = mem::transmute(arg);\n-        panic!(\"failed to spawn native thread: {}\", ret);\n+        Err(io::Error::from_os_error(ret))\n+    } else {\n+        Ok(native)\n     }\n-    native\n }\n \n #[cfg(any(target_os = \"linux\", target_os = \"android\"))]"}, {"sha": "d7f86e1842eea67fed89a1408847e0a3c9421d96", "filename": "src/libstd/sys/windows/thread.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Flibstd%2Fsys%2Fwindows%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Flibstd%2Fsys%2Fwindows%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fthread.rs?ref=d8450d69bbb7bb5c288fba01295551b78a5a8c03", "patch": "@@ -10,6 +10,7 @@\n \n use boxed::Box;\n use cmp;\n+use io;\n use mem;\n use ptr;\n use libc;\n@@ -42,7 +43,7 @@ pub mod guard {\n     }\n }\n \n-pub unsafe fn create(stack: uint, p: Thunk) -> rust_thread {\n+pub unsafe fn create(stack: uint, p: Thunk) -> io::Result<rust_thread> {\n     let arg: *mut libc::c_void = mem::transmute(box p);\n     // FIXME On UNIX, we guard against stack sizes that are too small but\n     // that's because pthreads enforces that stacks are at least\n@@ -60,9 +61,10 @@ pub unsafe fn create(stack: uint, p: Thunk) -> rust_thread {\n     if ret as uint == 0 {\n         // be sure to not leak the closure\n         let _p: Box<Thunk> = mem::transmute(arg);\n-        panic!(\"failed to spawn native thread: {:?}\", ret);\n+        Err(io::Error::last_os_error())\n+    } else {\n+        Ok(ret)\n     }\n-    return ret;\n }\n \n pub unsafe fn set_name(_name: &str) {"}, {"sha": "d0fde8344b2b310bad10064add038cfe918210c3", "filename": "src/libstd/thread.rs", "status": "modified", "additions": 321, "deletions": 145, "changes": 466, "blob_url": "https://github.com/rust-lang/rust/blob/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Flibstd%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Flibstd%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread.rs?ref=d8450d69bbb7bb5c288fba01295551b78a5a8c03", "patch": "@@ -42,32 +42,32 @@\n //! Already-running threads are represented via the `Thread` type, which you can\n //! get in one of two ways:\n //!\n-//! * By spawning a new thread, e.g. using the `Thread::spawn` constructor;\n-//! * By requesting the current thread, using the `Thread::current` function.\n+//! * By spawning a new thread, e.g. using the `thread::spawn` constructor;\n+//! * By requesting the current thread, using the `thread::current` function.\n //!\n //! Threads can be named, and provide some built-in support for low-level\n //! synchronization described below.\n //!\n-//! The `Thread::current()` function is available even for threads not spawned\n+//! The `thread::current()` function is available even for threads not spawned\n //! by the APIs of this module.\n //!\n //! ## Spawning a thread\n //!\n-//! A new thread can be spawned using the `Thread::spawn` function:\n+//! A new thread can be spawned using the `thread::spawn` function:\n //!\n //! ```rust\n-//! use std::thread::Thread;\n+//! use std::thread;\n //!\n-//! let thread = Thread::spawn(move || {\n+//! thread::spawn(move || {\n //!     println!(\"Hello, World!\");\n //!     // some computation here\n //! });\n //! ```\n //!\n-//! The spawned thread is \"detached\" from the current thread, meaning that it\n-//! can outlive the thread that spawned it. (Note, however, that when the main\n-//! thread terminates all detached threads are terminated as well.) The returned\n-//! `Thread` handle can be used for low-level synchronization as described below.\n+//! In this example, the spawned thread is \"detached\" from the current\n+//! thread, meaning that it can outlive the thread that spawned\n+//! it. (Note, however, that when the main thread terminates all\n+//! detached threads are terminated as well.)\n //!\n //! ## Scoped threads\n //!\n@@ -76,23 +76,23 @@\n //! For this scenario, use the `scoped` constructor:\n //!\n //! ```rust\n-//! use std::thread::Thread;\n+//! use std::thread;\n //!\n-//! let guard = Thread::scoped(move || {\n+//! let guard = thread::scoped(move || {\n //!     println!(\"Hello, World!\");\n //!     // some computation here\n //! });\n //! // do some other work in the meantime\n-//! let result = guard.join();\n+//! let output = guard.join();\n //! ```\n //!\n-//! The `scoped` function doesn't return a `Thread` directly; instead, it\n-//! returns a *join guard* from which a `Thread` can be extracted. The join\n-//! guard is an RAII-style guard that will automatically join the child thread\n-//! (block until it terminates) when it is dropped. You can join the child\n-//! thread in advance by calling the `join` method on the guard, which will also\n-//! return the result produced by the thread.  A handle to the thread itself is\n-//! available via the `thread` method on the join guard.\n+//! The `scoped` function doesn't return a `Thread` directly; instead,\n+//! it returns a *join guard*. The join guard is an RAII-style guard\n+//! that will automatically join the child thread (block until it\n+//! terminates) when it is dropped. You can join the child thread in\n+//! advance by calling the `join` method on the guard, which will also\n+//! return the result produced by the thread.  A handle to the thread\n+//! itself is available via the `thread` method on the join guard.\n //!\n //! (Note: eventually, the `scoped` constructor will allow the parent and child\n //! threads to data that lives on the parent thread's stack, but some language\n@@ -120,10 +120,10 @@\n //! Conceptually, each `Thread` handle has an associated token, which is\n //! initially not present:\n //!\n-//! * The `Thread::park()` function blocks the current thread unless or until\n+//! * The `thread::park()` function blocks the current thread unless or until\n //!   the token is available for its thread handle, at which point It atomically\n //!   consumes the token. It may also return *spuriously*, without consuming the\n-//!   token. `Thread::park_timeout()` does the same, but allows specifying a\n+//!   token. `thread::park_timeout()` does the same, but allows specifying a\n //!   maximum time to block the thread for.\n //!\n //! * The `unpark()` method on a `Thread` atomically makes the token available\n@@ -151,6 +151,8 @@ use any::Any;\n use boxed::Box;\n use cell::UnsafeCell;\n use clone::Clone;\n+use fmt;\n+use io;\n use marker::{Send, Sync};\n use ops::{Drop, FnOnce};\n use option::Option::{self, Some, None};\n@@ -224,49 +226,58 @@ impl Builder {\n         self\n     }\n \n-    /// Spawn a new detached thread, and return a handle to it.\n+    /// Spawn a new thread, and return a join handle for it.\n     ///\n-    /// See `Thead::spawn` and the module doc for more details.\n-    #[unstable(feature = \"std_misc\",\n-               reason = \"may change with specifics of new Send semantics\")]\n-    pub fn spawn<F>(self, f: F) -> Thread where F: FnOnce(), F: Send + 'static {\n-        let (native, thread) = self.spawn_inner(Thunk::new(f), Thunk::with_arg(|_| {}));\n-        unsafe { imp::detach(native) };\n-        thread\n+    /// The child thread may outlive the parent (unless the parent thread\n+    /// is the main thread; the whole process is terminated when the main\n+    /// thread finishes.) The join handle can be used to block on\n+    /// termination of the child thread, including recovering its panics.\n+    ///\n+    /// # Errors\n+    ///\n+    /// Unlike the `spawn` free function, this method yields an\n+    /// `io::Result` to capture any failure to create the thread at\n+    /// the OS level.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn spawn<F>(self, f: F) -> io::Result<JoinHandle> where\n+        F: FnOnce(), F: Send + 'static\n+    {\n+        self.spawn_inner(Thunk::new(f)).map(|i| JoinHandle(i))\n     }\n \n     /// Spawn a new child thread that must be joined within a given\n     /// scope, and return a `JoinGuard`.\n     ///\n-    /// See `Thead::scoped` and the module doc for more details.\n-    #[unstable(feature = \"std_misc\",\n-               reason = \"may change with specifics of new Send semantics\")]\n-    pub fn scoped<'a, T, F>(self, f: F) -> JoinGuard<'a, T> where\n+    /// The join guard can be used to explicitly join the child thread (via\n+    /// `join`), returning `Result<T>`, or it will implicitly join the child\n+    /// upon being dropped. Because the child thread may refer to data on the\n+    /// current thread's stack (hence the \"scoped\" name), it cannot be detached;\n+    /// it *must* be joined before the relevant stack frame is popped. See the\n+    /// module documentation for additional details.\n+    ///\n+    /// # Errors\n+    ///\n+    /// Unlike the `scoped` free function, this method yields an\n+    /// `io::Result` to capture any failure to create the thread at\n+    /// the OS level.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn scoped<'a, T, F>(self, f: F) -> io::Result<JoinGuard<'a, T>> where\n         T: Send + 'a, F: FnOnce() -> T, F: Send + 'a\n     {\n-        let my_packet = Packet(Arc::new(UnsafeCell::new(None)));\n-        let their_packet = Packet(my_packet.0.clone());\n-        let (native, thread) = self.spawn_inner(Thunk::new(f), Thunk::with_arg(move |ret| unsafe {\n-            *their_packet.0.get() = Some(ret);\n-        }));\n-\n-        JoinGuard {\n-            native: native,\n-            joined: false,\n-            packet: my_packet,\n-            thread: thread,\n-        }\n+        self.spawn_inner(Thunk::new(f)).map(JoinGuard)\n     }\n \n-    fn spawn_inner<T: Send>(self, f: Thunk<(), T>, finish: Thunk<Result<T>, ()>)\n-                      -> (imp::rust_thread, Thread)\n-    {\n+    fn spawn_inner<T: Send>(self, f: Thunk<(), T>) -> io::Result<JoinInner<T>> {\n         let Builder { name, stack_size, stdout, stderr } = self;\n \n         let stack_size = stack_size.unwrap_or(rt::min_stack());\n+\n         let my_thread = Thread::new(name);\n         let their_thread = my_thread.clone();\n \n+        let my_packet = Packet(Arc::new(UnsafeCell::new(None)));\n+        let their_packet = Packet(my_packet.0.clone());\n+\n         // Spawning a new OS thread guarantees that __morestack will never get\n         // triggered, but we must manually set up the actual stack bounds once\n         // this function starts executing. This raises the lower limit by a bit\n@@ -316,17 +327,120 @@ impl Builder {\n                     unwind::try(move || *ptr = Some(f.invoke(())))\n                 }\n             };\n-            finish.invoke(match (output, try_result) {\n-                (Some(data), Ok(_)) => Ok(data),\n-                (None, Err(cause)) => Err(cause),\n-                _ => unreachable!()\n-            });\n+            unsafe {\n+                *their_packet.0.get() = Some(match (output, try_result) {\n+                    (Some(data), Ok(_)) => Ok(data),\n+                    (None, Err(cause)) => Err(cause),\n+                    _ => unreachable!()\n+                });\n+            }\n         };\n \n-        (unsafe { imp::create(stack_size, Thunk::new(main)) }, my_thread)\n+        Ok(JoinInner {\n+            native: try!(unsafe { imp::create(stack_size, Thunk::new(main)) }),\n+            thread: my_thread,\n+            packet: my_packet,\n+            joined: false,\n+        })\n+    }\n+}\n+\n+/// Spawn a new, returning a join handle for it.\n+///\n+/// The child thread may outlive the parent (unless the parent thread\n+/// is the main thread; the whole process is terminated when the main\n+/// thread finishes.) The join handle can be used to block on\n+/// termination of the child thread, including recovering its panics.\n+///\n+/// # Panics\n+///\n+/// Panicks if the OS fails to create a thread; use `Builder::spawn`\n+/// to recover from such errors.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub fn spawn<F>(f: F) -> JoinHandle where F: FnOnce(), F: Send + 'static {\n+    Builder::new().spawn(f).unwrap()\n+}\n+\n+/// Spawn a new *scoped* thread, returning a `JoinGuard` for it.\n+///\n+/// The join guard can be used to explicitly join the child thread (via\n+/// `join`), returning `Result<T>`, or it will implicitly join the child\n+/// upon being dropped. Because the child thread may refer to data on the\n+/// current thread's stack (hence the \"scoped\" name), it cannot be detached;\n+/// it *must* be joined before the relevant stack frame is popped. See the\n+/// module documentation for additional details.\n+///\n+/// # Panics\n+///\n+/// Panicks if the OS fails to create a thread; use `Builder::scoped`\n+/// to recover from such errors.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub fn scoped<'a, T, F>(f: F) -> JoinGuard<'a, T> where\n+    T: Send + 'a, F: FnOnce() -> T, F: Send + 'a\n+{\n+    Builder::new().scoped(f).unwrap()\n+}\n+\n+/// Gets a handle to the thread that invokes it.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub fn current() -> Thread {\n+    thread_info::current_thread()\n+}\n+\n+/// Cooperatively give up a timeslice to the OS scheduler.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub fn yield_now() {\n+    unsafe { imp::yield_now() }\n+}\n+\n+/// Determines whether the current thread is unwinding because of panic.\n+#[inline]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub fn panicking() -> bool {\n+    unwind::panicking()\n+}\n+\n+/// Block unless or until the current thread's token is made available (may wake spuriously).\n+///\n+/// See the module doc for more detail.\n+//\n+// The implementation currently uses the trivial strategy of a Mutex+Condvar\n+// with wakeup flag, which does not actually allow spurious wakeups. In the\n+// future, this will be implemented in a more efficient way, perhaps along the lines of\n+//   http://cr.openjdk.java.net/~stefank/6989984.1/raw_files/new/src/os/linux/vm/os_linux.cpp\n+// or futuxes, and in either case may allow spurious wakeups.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub fn park() {\n+    let thread = current();\n+    let mut guard = thread.inner.lock.lock().unwrap();\n+    while !*guard {\n+        guard = thread.inner.cvar.wait(guard).unwrap();\n     }\n+    *guard = false;\n }\n \n+/// Block unless or until the current thread's token is made available or\n+/// the specified duration has been reached (may wake spuriously).\n+///\n+/// The semantics of this function are equivalent to `park()` except that the\n+/// thread will be blocked for roughly no longer than dur. This method\n+/// should not be used for precise timing due to anomalies such as\n+/// preemption or platform differences that may not cause the maximum\n+/// amount of time waited to be precisely dur\n+///\n+/// See the module doc for more detail.\n+#[unstable(feature = \"std_misc\", reason = \"recently introduced, depends on Duration\")]\n+pub fn park_timeout(dur: Duration) {\n+    let thread = current();\n+    let mut guard = thread.inner.lock.lock().unwrap();\n+    if !*guard {\n+        let (g, _) = thread.inner.cvar.wait_timeout(guard, dur).unwrap();\n+        guard = g;\n+    }\n+    *guard = false;\n+}\n+\n+/// The internal representation of a `Thread` handle\n struct Inner {\n     name: Option<String>,\n     lock: Mutex<bool>,          // true when there is a buffered unpark\n@@ -354,85 +468,63 @@ impl Thread {\n         }\n     }\n \n-    /// Spawn a new detached thread, returning a handle to it.\n-    ///\n-    /// The child thread may outlive the parent (unless the parent thread is the\n-    /// main thread; the whole process is terminated when the main thread\n-    /// finishes.) The thread handle can be used for low-level\n-    /// synchronization. See the module documentation for additional details.\n+    /// Deprecated: use module-level free fucntion.\n+    #[deprecated(since = \"1.0.0\", reason = \"use module-level free fucntion\")]\n     #[unstable(feature = \"std_misc\",\n                reason = \"may change with specifics of new Send semantics\")]\n     pub fn spawn<F>(f: F) -> Thread where F: FnOnce(), F: Send + 'static {\n-        Builder::new().spawn(f)\n+        Builder::new().spawn(f).unwrap().thread().clone()\n     }\n \n-    /// Spawn a new *scoped* thread, returning a `JoinGuard` for it.\n-    ///\n-    /// The join guard can be used to explicitly join the child thread (via\n-    /// `join`), returning `Result<T>`, or it will implicitly join the child\n-    /// upon being dropped. Because the child thread may refer to data on the\n-    /// current thread's stack (hence the \"scoped\" name), it cannot be detached;\n-    /// it *must* be joined before the relevant stack frame is popped. See the\n-    /// module documentation for additional details.\n+    /// Deprecated: use module-level free fucntion.\n+    #[deprecated(since = \"1.0.0\", reason = \"use module-level free fucntion\")]\n     #[unstable(feature = \"std_misc\",\n                reason = \"may change with specifics of new Send semantics\")]\n     pub fn scoped<'a, T, F>(f: F) -> JoinGuard<'a, T> where\n         T: Send + 'a, F: FnOnce() -> T, F: Send + 'a\n     {\n-        Builder::new().scoped(f)\n+        Builder::new().scoped(f).unwrap()\n     }\n \n-    /// Gets a handle to the thread that invokes it.\n+    /// Deprecated: use module-level free fucntion.\n+    #[deprecated(since = \"1.0.0\", reason = \"use module-level free fucntion\")]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn current() -> Thread {\n         thread_info::current_thread()\n     }\n \n-    /// Cooperatively give up a timeslice to the OS scheduler.\n+    /// Deprecated: use module-level free fucntion.\n+    #[deprecated(since = \"1.0.0\", reason = \"use module-level free fucntion\")]\n     #[unstable(feature = \"std_misc\", reason = \"name may change\")]\n     pub fn yield_now() {\n         unsafe { imp::yield_now() }\n     }\n \n-    /// Determines whether the current thread is unwinding because of panic.\n+    /// Deprecated: use module-level free fucntion.\n+    #[deprecated(since = \"1.0.0\", reason = \"use module-level free fucntion\")]\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn panicking() -> bool {\n         unwind::panicking()\n     }\n \n-    /// Block unless or until the current thread's token is made available (may wake spuriously).\n-    ///\n-    /// See the module doc for more detail.\n-    //\n-    // The implementation currently uses the trivial strategy of a Mutex+Condvar\n-    // with wakeup flag, which does not actually allow spurious wakeups. In the\n-    // future, this will be implemented in a more efficient way, perhaps along the lines of\n-    //   http://cr.openjdk.java.net/~stefank/6989984.1/raw_files/new/src/os/linux/vm/os_linux.cpp\n-    // or futuxes, and in either case may allow spurious wakeups.\n+    /// Deprecated: use module-level free fucntion.\n+    #[deprecated(since = \"1.0.0\", reason = \"use module-level free fucntion\")]\n     #[unstable(feature = \"std_misc\", reason = \"recently introduced\")]\n     pub fn park() {\n-        let thread = Thread::current();\n+        let thread = current();\n         let mut guard = thread.inner.lock.lock().unwrap();\n         while !*guard {\n             guard = thread.inner.cvar.wait(guard).unwrap();\n         }\n         *guard = false;\n     }\n \n-    /// Block unless or until the current thread's token is made available or\n-    /// the specified duration has been reached (may wake spuriously).\n-    ///\n-    /// The semantics of this function are equivalent to `park()` except that the\n-    /// thread will be blocked for roughly no longer than dur. This method\n-    /// should not be used for precise timing due to anomalies such as\n-    /// preemption or platform differences that may not cause the maximum\n-    /// amount of time waited to be precisely dur\n-    ///\n-    /// See the module doc for more detail.\n+    /// Deprecated: use module-level free fucntion.\n+    #[deprecated(since = \"1.0.0\", reason = \"use module-level free fucntion\")]\n     #[unstable(feature = \"std_misc\", reason = \"recently introduced\")]\n     pub fn park_timeout(dur: Duration) {\n-        let thread = Thread::current();\n+        let thread = current();\n         let mut guard = thread.inner.lock.lock().unwrap();\n         if !*guard {\n             let (g, _) = thread.inner.cvar.wait_timeout(guard, dur).unwrap();\n@@ -444,7 +536,7 @@ impl Thread {\n     /// Atomically makes the handle's token available if it is not already.\n     ///\n     /// See the module doc for more detail.\n-    #[unstable(feature = \"std_misc\", reason = \"recently introduced\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn unpark(&self) {\n         let mut guard = self.inner.lock.lock().unwrap();\n         if !*guard {\n@@ -460,6 +552,13 @@ impl Thread {\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl fmt::Debug for Thread {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Debug::fmt(&self.name(), f)\n+    }\n+}\n+\n // a hack to get around privacy restrictions\n impl thread_info::NewThread for Thread {\n     fn new(name: Option<String>) -> Thread { Thread::new(name) }\n@@ -476,61 +575,118 @@ struct Packet<T>(Arc<UnsafeCell<Option<Result<T>>>>);\n unsafe impl<T:'static+Send> Send for Packet<T> {}\n unsafe impl<T> Sync for Packet<T> {}\n \n-/// An RAII-style guard that will block until thread termination when dropped.\n-///\n-/// The type `T` is the return type for the thread's main function.\n-#[must_use]\n-#[unstable(feature = \"std_misc\",\n-           reason = \"may change with specifics of new Send semantics\")]\n-pub struct JoinGuard<'a, T: 'a> {\n+/// Inner representation for JoinHandle and JoinGuard\n+struct JoinInner<T> {\n     native: imp::rust_thread,\n     thread: Thread,\n-    joined: bool,\n     packet: Packet<T>,\n+    joined: bool,\n+}\n+\n+impl<T> JoinInner<T> {\n+    fn join(&mut self) -> Result<T> {\n+        assert!(!self.joined);\n+        unsafe { imp::join(self.native) };\n+        self.joined = true;\n+        unsafe {\n+            (*self.packet.0.get()).take().unwrap()\n+        }\n+    }\n+}\n+\n+/// An owned permission to join on a thread (block on its termination).\n+///\n+/// Unlike a `JoinGuard`, a `JoinHandle` *detaches* the child thread\n+/// when it is dropped, rather than automatically joining on drop.\n+///\n+/// Due to platform restrictions, it is not possible to `Clone` this\n+/// handle: the ability to join a child thread is a uniquely-owned\n+/// permission.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct JoinHandle(JoinInner<()>);\n+\n+impl JoinHandle {\n+    /// Extract a handle to the underlying thread\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn thread(&self) -> &Thread {\n+        &self.0.thread\n+    }\n+\n+    /// Wait for the associated thread to finish.\n+    ///\n+    /// If the child thread panics, `Err` is returned with the parameter given\n+    /// to `panic`.\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn join(mut self) -> Result<()> {\n+        self.0.join()\n+    }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl Drop for JoinHandle {\n+    fn drop(&mut self) {\n+        if !self.0.joined {\n+            unsafe { imp::detach(self.0.native) }\n+        }\n+    }\n+}\n+\n+/// An RAII-style guard that will block until thread termination when dropped.\n+///\n+/// The type `T` is the return type for the thread's main function.\n+///\n+/// Joining on drop is necessary to ensure memory safety when stack\n+/// data is shared between a parent and child thread.\n+///\n+/// Due to platform restrictions, it is not possible to `Clone` this\n+/// handle: the ability to join a child thread is a uniquely-owned\n+/// permission.\n+#[must_use]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct JoinGuard<'a, T: 'a>(JoinInner<T>);\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n unsafe impl<'a, T: Send + 'a> Sync for JoinGuard<'a, T> {}\n \n impl<'a, T: Send + 'a> JoinGuard<'a, T> {\n     /// Extract a handle to the thread this guard will join on.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn thread(&self) -> &Thread {\n-        &self.thread\n+        &self.0.thread\n     }\n \n     /// Wait for the associated thread to finish, returning the result of the thread's\n     /// calculation.\n     ///\n-    /// If the child thread panics, `Err` is returned with the parameter given\n-    /// to `panic`.\n+    /// # Panics\n+    ///\n+    /// Panics on the child thread are propagated by panicking the parent.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn join(mut self) -> Result<T> {\n-        assert!(!self.joined);\n-        unsafe { imp::join(self.native) };\n-        self.joined = true;\n-        unsafe {\n-            (*self.packet.0.get()).take().unwrap()\n+    pub fn join(mut self) -> T {\n+        match self.0.join() {\n+            Ok(res) => res,\n+            Err(_) => panic!(\"child thread {:?} panicked\", self.thread()),\n         }\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Send> JoinGuard<'static, T> {\n     /// Detaches the child thread, allowing it to outlive its parent.\n-    #[unstable(feature = \"std_misc\",\n-               reason = \"unsure whether this API imposes limitations elsewhere\")]\n+    #[deprecated(since = \"1.0.0\", reason = \"use spawn instead\")]\n+    #[unstable(feature = \"std_misc\")]\n     pub fn detach(mut self) {\n-        unsafe { imp::detach(self.native) };\n-        self.joined = true; // avoid joining in the destructor\n+        unsafe { imp::detach(self.0.native) };\n+        self.0.joined = true; // avoid joining in the destructor\n     }\n }\n \n #[unsafe_destructor]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T: Send + 'a> Drop for JoinGuard<'a, T> {\n     fn drop(&mut self) {\n-        if !self.joined {\n-            unsafe { imp::join(self.native) };\n+        if !self.0.joined {\n+            unsafe { imp::join(self.0.native) };\n         }\n     }\n }\n@@ -544,7 +700,7 @@ mod test {\n     use boxed::BoxAny;\n     use result;\n     use std::old_io::{ChanReader, ChanWriter};\n-    use super::{Thread, Builder};\n+    use super::{self, Thread, Builder};\n     use thunk::Thunk;\n     use time::Duration;\n \n@@ -553,30 +709,30 @@ mod test {\n \n     #[test]\n     fn test_unnamed_thread() {\n-        Thread::scoped(move|| {\n-            assert!(Thread::current().name().is_none());\n+        thread::spawn(move|| {\n+            assert!(thread::current().name().is_none());\n         }).join().ok().unwrap();\n     }\n \n     #[test]\n     fn test_named_thread() {\n         Builder::new().name(\"ada lovelace\".to_string()).scoped(move|| {\n-            assert!(Thread::current().name().unwrap() == \"ada lovelace\".to_string());\n+            assert!(thread::current().name().unwrap() == \"ada lovelace\".to_string());\n         }).join().ok().unwrap();\n     }\n \n     #[test]\n     fn test_run_basic() {\n         let (tx, rx) = channel();\n-        Thread::spawn(move|| {\n+        thread::spawn(move|| {\n             tx.send(()).unwrap();\n         });\n         rx.recv().unwrap();\n     }\n \n     #[test]\n     fn test_join_success() {\n-        match Thread::scoped(move|| -> String {\n+        match thread::spawn(move|| -> String {\n             \"Success!\".to_string()\n         }).join().as_ref().map(|s| &**s) {\n             result::Result::Ok(\"Success!\") => (),\n@@ -586,14 +742,34 @@ mod test {\n \n     #[test]\n     fn test_join_panic() {\n-        match Thread::scoped(move|| {\n+        match thread::spawn(move|| {\n             panic!()\n         }).join() {\n             result::Result::Err(_) => (),\n             result::Result::Ok(()) => panic!()\n         }\n     }\n \n+    #[test]\n+    fn test_scoped_success() {\n+        let res = thread::scoped(move|| -> String {\n+            \"Success!\".to_string()\n+        }).join();\n+        assert!(res == \"Success!\");\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    fn test_scoped_panic() {\n+        thread::scoped(|| panic!()).join();\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    fn test_scoped_implicit_panic() {\n+        thread::scoped(|| panic!());\n+    }\n+\n     #[test]\n     fn test_spawn_sched() {\n         use clone::Clone;\n@@ -602,7 +778,7 @@ mod test {\n \n         fn f(i: int, tx: Sender<()>) {\n             let tx = tx.clone();\n-            Thread::spawn(move|| {\n+            thread::spawn(move|| {\n                 if i == 0 {\n                     tx.send(()).unwrap();\n                 } else {\n@@ -619,8 +795,8 @@ mod test {\n     fn test_spawn_sched_childs_on_default_sched() {\n         let (tx, rx) = channel();\n \n-        Thread::spawn(move|| {\n-            Thread::spawn(move|| {\n+        thread::spawn(move|| {\n+            thread::spawn(move|| {\n                 tx.send(()).unwrap();\n             });\n         });\n@@ -646,14 +822,14 @@ mod test {\n     #[test]\n     fn test_avoid_copying_the_body_spawn() {\n         avoid_copying_the_body(|v| {\n-            Thread::spawn(move || v.invoke(()));\n+            thread::spawn(move || v.invoke(()));\n         });\n     }\n \n     #[test]\n     fn test_avoid_copying_the_body_thread_spawn() {\n         avoid_copying_the_body(|f| {\n-            Thread::spawn(move|| {\n+            thread::spawn(move|| {\n                 f.invoke(());\n             });\n         })\n@@ -662,7 +838,7 @@ mod test {\n     #[test]\n     fn test_avoid_copying_the_body_join() {\n         avoid_copying_the_body(|f| {\n-            let _ = Thread::scoped(move|| {\n+            let _ = thread::spawn(move|| {\n                 f.invoke(())\n             }).join();\n         })\n@@ -678,21 +854,21 @@ mod test {\n         fn child_no(x: uint) -> Thunk {\n             return Thunk::new(move|| {\n                 if x < GENERATIONS {\n-                    Thread::spawn(move|| child_no(x+1).invoke(()));\n+                    thread::spawn(move|| child_no(x+1).invoke(()));\n                 }\n             });\n         }\n-        Thread::spawn(|| child_no(0).invoke(()));\n+        thread::spawn(|| child_no(0).invoke(()));\n     }\n \n     #[test]\n     fn test_simple_newsched_spawn() {\n-        Thread::spawn(move || {});\n+        thread::spawn(move || {});\n     }\n \n     #[test]\n     fn test_try_panic_message_static_str() {\n-        match Thread::scoped(move|| {\n+        match thread::spawn(move|| {\n             panic!(\"static string\");\n         }).join() {\n             Err(e) => {\n@@ -706,7 +882,7 @@ mod test {\n \n     #[test]\n     fn test_try_panic_message_owned_str() {\n-        match Thread::scoped(move|| {\n+        match thread::spawn(move|| {\n             panic!(\"owned string\".to_string());\n         }).join() {\n             Err(e) => {\n@@ -720,7 +896,7 @@ mod test {\n \n     #[test]\n     fn test_try_panic_message_any() {\n-        match Thread::scoped(move|| {\n+        match thread::spawn(move|| {\n             panic!(box 413u16 as Box<Any + Send>);\n         }).join() {\n             Err(e) => {\n@@ -738,7 +914,7 @@ mod test {\n     fn test_try_panic_message_unit_struct() {\n         struct Juju;\n \n-        match Thread::scoped(move|| {\n+        match thread::spawn(move|| {\n             panic!(Juju)\n         }).join() {\n             Err(ref e) if e.is::<Juju>() => {}\n@@ -764,15 +940,15 @@ mod test {\n     #[test]\n     fn test_park_timeout_unpark_before() {\n         for _ in 0..10 {\n-            Thread::current().unpark();\n-            Thread::park_timeout(Duration::seconds(10_000_000));\n+            thread::current().unpark();\n+            thread::park_timeout(Duration::seconds(10_000_000));\n         }\n     }\n \n     #[test]\n     fn test_park_timeout_unpark_not_called() {\n         for _ in 0..10 {\n-            Thread::park_timeout(Duration::milliseconds(10));\n+            thread::park_timeout(Duration::milliseconds(10));\n         }\n     }\n \n@@ -781,14 +957,14 @@ mod test {\n         use std::old_io;\n \n         for _ in 0..10 {\n-            let th = Thread::current();\n+            let th = thread::current();\n \n-            let _guard = Thread::scoped(move || {\n+            let _guard = thread::spawn(move || {\n                 old_io::timer::sleep(Duration::milliseconds(50));\n                 th.unpark();\n             });\n \n-            Thread::park_timeout(Duration::seconds(10_000_000));\n+            thread::park_timeout(Duration::seconds(10_000_000));\n         }\n     }\n "}, {"sha": "2ed296e081c90f3b4a5988fbaf4332633d43bba6", "filename": "src/libstd/thread_local/mod.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Flibstd%2Fthread_local%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Flibstd%2Fthread_local%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread_local%2Fmod.rs?ref=d8450d69bbb7bb5c288fba01295551b78a5a8c03", "patch": "@@ -72,7 +72,7 @@ pub mod __impl {\n ///\n /// ```\n /// use std::cell::RefCell;\n-/// use std::thread::Thread;\n+/// use std::thread;\n ///\n /// thread_local!(static FOO: RefCell<uint> = RefCell::new(1));\n ///\n@@ -82,7 +82,7 @@ pub mod __impl {\n /// });\n ///\n /// // each thread starts out with the initial value of 1\n-/// Thread::spawn(move|| {\n+/// thread::spawn(move|| {\n ///     FOO.with(|f| {\n ///         assert_eq!(*f.borrow(), 1);\n ///         *f.borrow_mut() = 3;\n@@ -548,7 +548,7 @@ mod tests {\n     use sync::mpsc::{channel, Sender};\n     use cell::UnsafeCell;\n     use super::State;\n-    use thread::Thread;\n+    use thread;\n \n     struct Foo(Sender<()>);\n \n@@ -568,7 +568,7 @@ mod tests {\n             *f.get() = 2;\n         });\n         let (tx, rx) = channel();\n-        let _t = Thread::spawn(move|| {\n+        let _t = thread::spawn(move|| {\n             FOO.with(|f| unsafe {\n                 assert_eq!(*f.get(), 1);\n             });\n@@ -595,7 +595,7 @@ mod tests {\n         }\n         thread_local!(static FOO: Foo = foo());\n \n-        Thread::scoped(|| {\n+        thread::spawn(|| {\n             assert!(FOO.state() == State::Uninitialized);\n             FOO.with(|_| {\n                 assert!(FOO.state() == State::Valid);\n@@ -611,7 +611,7 @@ mod tests {\n         });\n \n         let (tx, rx) = channel();\n-        let _t = Thread::spawn(move|| unsafe {\n+        let _t = thread::spawn(move|| unsafe {\n             let mut tx = Some(tx);\n             FOO.with(|f| {\n                 *f.get() = Some(Foo(tx.take().unwrap()));\n@@ -659,7 +659,7 @@ mod tests {\n             }\n         }\n \n-        Thread::scoped(move|| {\n+        thread::spawn(move|| {\n             drop(S1);\n         }).join().ok().unwrap();\n     }\n@@ -677,7 +677,7 @@ mod tests {\n             }\n         }\n \n-        Thread::scoped(move|| unsafe {\n+        thread::spawn(move|| unsafe {\n             K1.with(|s| *s.get() = Some(S1));\n         }).join().ok().unwrap();\n     }\n@@ -704,7 +704,7 @@ mod tests {\n         }\n \n         let (tx, rx) = channel();\n-        let _t = Thread::spawn(move|| unsafe {\n+        let _t = thread::spawn(move|| unsafe {\n             let mut tx = Some(tx);\n             K1.with(|s| *s.get() = Some(S1(tx.take().unwrap())));\n         });"}, {"sha": "e4633ea0f76f0639b178b0e27f2ad7dd55da8493", "filename": "src/libstd/thread_local/scoped.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Flibstd%2Fthread_local%2Fscoped.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Flibstd%2Fthread_local%2Fscoped.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread_local%2Fscoped.rs?ref=d8450d69bbb7bb5c288fba01295551b78a5a8c03", "patch": "@@ -84,7 +84,7 @@ macro_rules! __scoped_thread_local_inner {\n                            target_os = \"openbsd\",\n                            target_arch = \"aarch64\")),\n                    thread_local)]\n-        static $name: ::std::thread_local::scoped::Key<$t> =\n+        static $name: ::std::thread_local::spawn::Key<$t> =\n             __scoped_thread_local_inner!($t);\n     );\n     (pub static $name:ident: $t:ty) => (\n@@ -94,19 +94,19 @@ macro_rules! __scoped_thread_local_inner {\n                            target_os = \"openbsd\",\n                            target_arch = \"aarch64\")),\n                    thread_local)]\n-        pub static $name: ::std::thread_local::scoped::Key<$t> =\n+        pub static $name: ::std::thread_local::spawn::Key<$t> =\n             __scoped_thread_local_inner!($t);\n     );\n     ($t:ty) => ({\n-        use std::thread_local::scoped::Key as __Key;\n+        use std::thread_local::spawn::Key as __Key;\n \n         #[cfg(not(any(windows,\n                       target_os = \"android\",\n                       target_os = \"ios\",\n                       target_os = \"openbsd\",\n                       target_arch = \"aarch64\")))]\n         const _INIT: __Key<$t> = __Key {\n-            inner: ::std::thread_local::scoped::__impl::KeyInner {\n+            inner: ::std::thread_local::spawn::__impl::KeyInner {\n                 inner: ::std::cell::UnsafeCell { value: 0 as *mut _ },\n             }\n         };\n@@ -117,8 +117,8 @@ macro_rules! __scoped_thread_local_inner {\n                   target_os = \"openbsd\",\n                   target_arch = \"aarch64\"))]\n         const _INIT: __Key<$t> = __Key {\n-            inner: ::std::thread_local::scoped::__impl::KeyInner {\n-                inner: ::std::thread_local::scoped::__impl::OS_INIT,\n+            inner: ::std::thread_local::spawn::__impl::KeyInner {\n+                inner: ::std::thread_local::spawn::__impl::OS_INIT,\n                 marker: ::std::marker::InvariantType,\n             }\n         };"}, {"sha": "32ba410224e4e172534b177d77462ff0987adcfe", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=d8450d69bbb7bb5c288fba01295551b78a5a8c03", "patch": "@@ -879,7 +879,7 @@ pub fn run_test(opts: &TestOpts,\n                       monitor_ch: Sender<MonitorMsg>,\n                       nocapture: bool,\n                       testfn: Thunk) {\n-        Thread::spawn(move || {\n+        thread::spawn(move || {\n             let (tx, rx) = channel();\n             let mut reader = ChanReader::new(rx);\n             let stdout = ChanWriter::new(tx.clone());"}, {"sha": "29a6ce5965811bed0d1b4b1949dd61b543389808", "filename": "src/test/auxiliary/cci_capture_clause.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Ftest%2Fauxiliary%2Fcci_capture_clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Ftest%2Fauxiliary%2Fcci_capture_clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_capture_clause.rs?ref=d8450d69bbb7bb5c288fba01295551b78a5a8c03", "patch": "@@ -8,12 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::thread::Thread;\n+use std::thread;\n use std::sync::mpsc::{Receiver, channel};\n \n pub fn foo<T:Send + Clone>(x: T) -> Receiver<T> {\n     let (tx, rx) = channel();\n-    Thread::spawn(move|| {\n+    thread::spawn(move|| {\n         tx.send(x.clone());\n     });\n     rx"}, {"sha": "208f088442b9b401c4f13c13c0188f71f3d13663", "filename": "src/test/bench/msgsend-pipes-shared.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs?ref=d8450d69bbb7bb5c288fba01295551b78a5a8c03", "patch": "@@ -20,7 +20,7 @@\n \n use std::sync::mpsc::{channel, Sender, Receiver};\n use std::env;\n-use std::thread::Thread;\n+use std::thread;\n use std::time::Duration;\n \n fn move_out<T>(_x: T) {}\n@@ -63,15 +63,15 @@ fn run(args: &[String]) {\n         let mut worker_results = Vec::new();\n         for _ in 0u..workers {\n             let to_child = to_child.clone();\n-            worker_results.push(Thread::scoped(move|| {\n+            worker_results.push(thread::spawn(move|| {\n                 for _ in 0u..size / workers {\n                     //println!(\"worker {}: sending {} bytes\", i, num_bytes);\n                     to_child.send(request::bytes(num_bytes)).unwrap();\n                 }\n                 //println!(\"worker {} exiting\", i);\n             }));\n         }\n-        Thread::spawn(move|| {\n+        thread::spawn(move|| {\n             server(&from_parent, &to_parent);\n         });\n "}, {"sha": "76b91f0295bb56abbad11b5c2fa6d86d863519ba", "filename": "src/test/bench/msgsend-pipes.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs?ref=d8450d69bbb7bb5c288fba01295551b78a5a8c03", "patch": "@@ -16,7 +16,7 @@\n \n use std::sync::mpsc::{channel, Sender, Receiver};\n use std::env;\n-use std::thread::Thread;\n+use std::thread;\n use std::time::Duration;\n \n enum request {\n@@ -56,7 +56,7 @@ fn run(args: &[String]) {\n         let mut worker_results = Vec::new();\n         let from_parent = if workers == 1 {\n             let (to_child, from_parent) = channel();\n-            worker_results.push(Thread::scoped(move|| {\n+            worker_results.push(thread::spawn(move|| {\n                 for _ in 0u..size / workers {\n                     //println!(\"worker {}: sending {} bytes\", i, num_bytes);\n                     to_child.send(request::bytes(num_bytes));\n@@ -68,7 +68,7 @@ fn run(args: &[String]) {\n             let (to_child, from_parent) = channel();\n             for _ in 0u..workers {\n                 let to_child = to_child.clone();\n-                worker_results.push(Thread::scoped(move|| {\n+                worker_results.push(thread::spawn(move|| {\n                     for _ in 0u..size / workers {\n                         //println!(\"worker {}: sending {} bytes\", i, num_bytes);\n                         to_child.send(request::bytes(num_bytes));\n@@ -78,7 +78,7 @@ fn run(args: &[String]) {\n             }\n             from_parent\n         };\n-        Thread::spawn(move|| {\n+        thread::spawn(move|| {\n             server(&from_parent, &to_parent);\n         });\n "}, {"sha": "b9512324e42d6426a5c92908c4a4825eb91fb7a4", "filename": "src/test/bench/rt-messaging-ping-pong.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Ftest%2Fbench%2Frt-messaging-ping-pong.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Ftest%2Fbench%2Frt-messaging-ping-pong.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Frt-messaging-ping-pong.rs?ref=d8450d69bbb7bb5c288fba01295551b78a5a8c03", "patch": "@@ -19,7 +19,7 @@\n \n use std::sync::mpsc::channel;\n use std::env;\n-use std::thread::Thread;\n+use std::thread;\n \n // This is a simple bench that creates M pairs of tasks. These\n // tasks ping-pong back and forth over a pair of streams. This is a\n@@ -35,15 +35,15 @@ fn ping_pong_bench(n: usize, m: usize) {\n         // Create a channel: B->A\n         let (btx, brx) = channel();\n \n-        let guard_a = Thread::scoped(move|| {\n+        let guard_a = thread::spawn(move|| {\n             let (tx, rx) = (atx, brx);\n             for _ in 0..n {\n                 tx.send(()).unwrap();\n                 rx.recv().unwrap();\n             }\n         });\n \n-        let guard_b = Thread::scoped(move|| {\n+        let guard_b = thread::spawn(move|| {\n             let (tx, rx) = (btx, arx);\n             for _ in 0..n {\n                 rx.recv().unwrap();"}, {"sha": "d420023cf0059eacb92a27f458d0b8dfde1ef4b5", "filename": "src/test/bench/rt-parfib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Ftest%2Fbench%2Frt-parfib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Ftest%2Fbench%2Frt-parfib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Frt-parfib.rs?ref=d8450d69bbb7bb5c288fba01295551b78a5a8c03", "patch": "@@ -10,7 +10,7 @@\n \n use std::sync::mpsc::channel;\n use std::env;\n-use std::thread::Thread;\n+use std::thread;\n \n // A simple implementation of parfib. One subtree is found in a new\n // task and communicated over a oneshot pipe, the other is found\n@@ -22,7 +22,7 @@ fn parfib(n: u64) -> u64 {\n     }\n \n     let (tx, rx) = channel();\n-    Thread::spawn(move|| {\n+    thread::spawn(move|| {\n         tx.send(parfib(n-1)).unwrap();\n     });\n     let m2 = parfib(n-2);"}, {"sha": "dc0a2a6459f7b5e6689c2ff8405bc985622da160", "filename": "src/test/bench/shootout-binarytrees.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs?ref=d8450d69bbb7bb5c288fba01295551b78a5a8c03", "patch": "@@ -110,7 +110,7 @@ fn main() {\n     let messages = range_step(min_depth, max_depth + 1, 2).map(|depth| {\n         use std::num::Int;\n         let iterations = 2.pow((max_depth - depth + min_depth) as usize);\n-        Thread::scoped(move || inner(depth, iterations))\n+        thread::spawn(move || inner(depth, iterations))\n     }).collect::<Vec<_>>();\n \n     for message in messages {"}, {"sha": "5bd1e91ae14e432776ec859418e4e7dd3fb2e825", "filename": "src/test/bench/shootout-chameneos-redux.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs?ref=d8450d69bbb7bb5c288fba01295551b78a5a8c03", "patch": "@@ -43,7 +43,7 @@\n use self::Color::{Red, Yellow, Blue};\n use std::sync::mpsc::{channel, Sender, Receiver};\n use std::fmt;\n-use std::thread::Thread;\n+use std::thread;\n \n fn print_complements() {\n     let all = [Blue, Red, Yellow];\n@@ -187,7 +187,7 @@ fn rendezvous(nn: uint, set: Vec<Color>) {\n             let to_rendezvous = to_rendezvous.clone();\n             let to_rendezvous_log = to_rendezvous_log.clone();\n             let (to_creature, from_rendezvous) = channel();\n-            Thread::spawn(move|| {\n+            thread::spawn(move|| {\n                 creature(ii,\n                          col,\n                          from_rendezvous,"}, {"sha": "8b840b163525fd089eadcf9417032a900758f151", "filename": "src/test/bench/shootout-fannkuch-redux.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fannkuch-redux.rs?ref=d8450d69bbb7bb5c288fba01295551b78a5a8c03", "patch": "@@ -39,7 +39,7 @@\n // OF THE POSSIBILITY OF SUCH DAMAGE.\n \n use std::{cmp, iter, mem};\n-use std::thread::Thread;\n+use std::thread;\n \n fn rotate(x: &mut [i32]) {\n     let mut prev = x[0];\n@@ -164,7 +164,7 @@ fn fannkuch(n: i32) -> (i32, i32) {\n     for (_, j) in (0..N).zip(iter::count(0, k)) {\n         let max = cmp::min(j+k, perm.max());\n \n-        futures.push(Thread::scoped(move|| {\n+        futures.push(thread::spawn(move|| {\n             work(perm, j as uint, max as uint)\n         }))\n     }"}, {"sha": "4d6ef3d533e3f96e3cd9c784d27bfe21e37cf10d", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=d8450d69bbb7bb5c288fba01295551b78a5a8c03", "patch": "@@ -24,7 +24,7 @@ use std::option;\n use std::os;\n use std::env;\n use std::sync::mpsc::{channel, Sender, Receiver};\n-use std::thread::Thread;\n+use std::thread;\n \n fn f64_cmp(x: f64, y: f64) -> Ordering {\n     // arbitrarily decide that NaNs are larger than everything.\n@@ -172,7 +172,7 @@ fn main() {\n \n         let (to_child, from_parent) = channel();\n \n-        Thread::spawn(move|| {\n+        thread::spawn(move|| {\n             make_sequence_processor(sz, &from_parent, &to_parent_);\n         });\n "}, {"sha": "e6beb952603bd2867712b24b9aa8c5f86d8f863e", "filename": "src/test/bench/shootout-k-nucleotide.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs?ref=d8450d69bbb7bb5c288fba01295551b78a5a8c03", "patch": "@@ -45,7 +45,7 @@\n use std::ascii::OwnedAsciiExt;\n use std::slice;\n use std::sync::Arc;\n-use std::thread::Thread;\n+use std::thread;\n \n static TABLE: [u8;4] = [ 'A' as u8, 'C' as u8, 'G' as u8, 'T' as u8 ];\n static TABLE_SIZE: uint = 2 << 16;\n@@ -303,11 +303,11 @@ fn main() {\n \n     let nb_freqs: Vec<_> = (1u..3).map(|i| {\n         let input = input.clone();\n-        (i, Thread::scoped(move|| generate_frequencies(&input, i)))\n+        (i, thread::spawn(move|| generate_frequencies(&input, i)))\n     }).collect();\n     let occ_freqs: Vec<_> = OCCURRENCES.iter().map(|&occ| {\n         let input = input.clone();\n-        Thread::scoped(move|| generate_frequencies(&input, occ.len()))\n+        thread::spawn(move|| generate_frequencies(&input, occ.len()))\n     }).collect();\n \n     for (i, freq) in nb_freqs {"}, {"sha": "8ab3b14a1f51d735847cad9ea3457ee35313ea2d", "filename": "src/test/bench/shootout-mandelbrot.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs?ref=d8450d69bbb7bb5c288fba01295551b78a5a8c03", "patch": "@@ -46,7 +46,7 @@ use std::old_io;\n use std::env;\n use std::simd::f64x2;\n use std::sync::Arc;\n-use std::thread::Thread;\n+use std::thread;\n \n const ITER: usize = 50;\n const LIMIT: f64 = 2.0;\n@@ -81,7 +81,7 @@ fn mandelbrot<W: old_io::Writer>(w: usize, mut out: W) -> old_io::IoResult<()> {\n     let mut precalc_i = Vec::with_capacity(h);\n \n     let precalc_futures = (0..WORKERS).map(|i| {\n-        Thread::scoped(move|| {\n+        thread::spawn(move|| {\n             let mut rs = Vec::with_capacity(w / WORKERS);\n             let mut is = Vec::with_capacity(w / WORKERS);\n \n@@ -122,7 +122,7 @@ fn mandelbrot<W: old_io::Writer>(w: usize, mut out: W) -> old_io::IoResult<()> {\n         let vec_init_r = arc_init_r.clone();\n         let vec_init_i = arc_init_i.clone();\n \n-        Thread::scoped(move|| {\n+        thread::spawn(move|| {\n             let mut res: Vec<u8> = Vec::with_capacity((chunk_size * w) / 8);\n             let init_r_slice = vec_init_r;\n "}, {"sha": "a9c4bb99a0ed15f5b13363cba37a2b5f3382b797", "filename": "src/test/bench/shootout-meteor.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Ftest%2Fbench%2Fshootout-meteor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Ftest%2Fbench%2Fshootout-meteor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-meteor.rs?ref=d8450d69bbb7bb5c288fba01295551b78a5a8c03", "patch": "@@ -43,7 +43,7 @@\n use std::iter::repeat;\n use std::sync::Arc;\n use std::sync::mpsc::channel;\n-use std::thread::Thread;\n+use std::thread;\n \n //\n // Utilities.\n@@ -317,7 +317,7 @@ fn par_search(masks: Vec<Vec<Vec<u64>>>) -> Data {\n         let masks = masks.clone();\n         let tx = tx.clone();\n         let m = *m;\n-        Thread::spawn(move|| {\n+        thread::spawn(move|| {\n             let mut data = Data::new();\n             search(&*masks, m, 1, List::Cons(m, &List::Nil), &mut data);\n             tx.send(data).unwrap();"}, {"sha": "a542c81f2394ea2523717305de5956469606a2a9", "filename": "src/test/bench/shootout-pfib.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-pfib.rs?ref=d8450d69bbb7bb5c288fba01295551b78a5a8c03", "patch": "@@ -23,7 +23,7 @@ extern crate getopts;\n use std::sync::mpsc::{channel, Sender};\n use std::env;\n use std::result::Result::{Ok, Err};\n-use std::thread::Thread;\n+use std::thread;\n use std::time::Duration;\n \n fn fib(n: isize) -> isize {\n@@ -35,15 +35,15 @@ fn fib(n: isize) -> isize {\n         } else {\n             let (tx1, rx) = channel();\n             let tx2 = tx1.clone();\n-            Thread::spawn(move|| pfib(&tx2, n - 1));\n+            thread::spawn(move|| pfib(&tx2, n - 1));\n             let tx2 = tx1.clone();\n-            Thread::spawn(move|| pfib(&tx2, n - 2));\n+            thread::spawn(move|| pfib(&tx2, n - 2));\n             tx.send(rx.recv().unwrap() + rx.recv().unwrap());\n         }\n     }\n \n     let (tx, rx) = channel();\n-    Thread::spawn(move|| pfib(&tx, n) );\n+    thread::spawn(move|| pfib(&tx, n) );\n     rx.recv().unwrap()\n }\n \n@@ -78,7 +78,7 @@ fn stress_task(id: isize) {\n fn stress(num_tasks: int) {\n     let mut results = Vec::new();\n     for i in 0..num_tasks {\n-        results.push(Thread::scoped(move|| {\n+        results.push(thread::spawn(move|| {\n             stress_task(i);\n         }));\n     }"}, {"sha": "3d8b6e82848b9854e56d0dc5b033d62aa9e422d6", "filename": "src/test/bench/shootout-reverse-complement.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs?ref=d8450d69bbb7bb5c288fba01295551b78a5a8c03", "patch": "@@ -47,7 +47,7 @@ extern crate libc;\n use std::old_io::stdio::{stdin_raw, stdout_raw};\n use std::old_io::{IoResult, EndOfFile};\n use std::ptr::{copy_memory, Unique};\n-use std::thread::Thread;\n+use std::thread;\n \n struct Tables {\n     table8: [u8;1 << 8],\n@@ -241,7 +241,7 @@ fn parallel<'a, I, T, F>(iter: I, f: F)\n         // boundary.\n         let f = Racy(&f as *const F as *const uint);\n         let raw = Racy(chunk.repr());\n-        Thread::scoped(move|| {\n+        thread::spawn(move|| {\n             let f = f.0 as *const F;\n             unsafe { (*f)(mem::transmute(raw.0)) }\n         })"}, {"sha": "4b59015f8aa29c575329a5b05e35c7e935345766", "filename": "src/test/bench/shootout-spectralnorm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs?ref=d8450d69bbb7bb5c288fba01295551b78a5a8c03", "patch": "@@ -44,7 +44,7 @@\n #![feature(unboxed_closures)]\n \n use std::iter::{repeat, AdditiveIterator};\n-use std::thread::Thread;\n+use std::thread;\n use std::mem;\n use std::num::Float;\n use std::os;\n@@ -129,7 +129,7 @@ fn parallel<T, F>(v: &mut [T], f: F)\n         // boundary.\n         let f = Racy(&f as *const _ as *const uint);\n         let raw = Racy(chunk.repr());\n-        Thread::scoped(move|| {\n+        thread::spawn(move|| {\n             let f = f.0 as *const F;\n             unsafe { (*f)(i * size, mem::transmute(raw.0)) }\n         })"}, {"sha": "2653e758a487d256666700f2f7993bc63136902b", "filename": "src/test/bench/shootout-threadring.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Ftest%2Fbench%2Fshootout-threadring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Ftest%2Fbench%2Fshootout-threadring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-threadring.rs?ref=d8450d69bbb7bb5c288fba01295551b78a5a8c03", "patch": "@@ -39,7 +39,7 @@\n // OF THE POSSIBILITY OF SUCH DAMAGE.\n \n use std::sync::mpsc::{channel, Sender, Receiver};\n-use std::thread::Thread;\n+use std::thread;\n \n fn start(n_tasks: i32, token: i32) {\n     let (tx, mut rx) = channel();\n@@ -48,9 +48,9 @@ fn start(n_tasks: i32, token: i32) {\n     for i in 2 .. n_tasks + 1 {\n         let (tx, next_rx) = channel();\n         let cur_rx = std::mem::replace(&mut rx, next_rx);\n-        guards.push(Thread::scoped(move|| roundtrip(i, tx, cur_rx)));\n+        guards.push(thread::spawn(move|| roundtrip(i, tx, cur_rx)));\n     }\n-    let guard = Thread::scoped(move|| roundtrip(1, tx, rx));\n+    let guard = thread::spawn(move|| roundtrip(1, tx, rx));\n }\n \n fn roundtrip(id: i32, tx: Sender<i32>, rx: Receiver<i32>) {"}, {"sha": "6b412c47cd7f81bdf9d0713f8818dbd84aaa1471", "filename": "src/test/bench/task-perf-alloc-unwind.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs?ref=d8450d69bbb7bb5c288fba01295551b78a5a8c03", "patch": "@@ -11,7 +11,7 @@\n #![feature(unsafe_destructor, box_syntax)]\n \n use std::env;\n-use std::thread::Thread;\n+use std::thread;\n use std::time::Duration;\n \n #[derive(Clone)]\n@@ -32,7 +32,7 @@ fn main() {\n fn run(repeat: int, depth: int) {\n     for _ in 0..repeat {\n         let dur = Duration::span(|| {\n-            let _ = Thread::scoped(move|| {\n+            let _ = thread::spawn(move|| {\n                 recurse_or_panic(depth, None)\n             }).join();\n         });"}, {"sha": "e36d685d7c6ea9b73f85d29b147510ec1fc69030", "filename": "src/test/bench/task-perf-jargon-metal-smoke.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Ftest%2Fbench%2Ftask-perf-jargon-metal-smoke.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Ftest%2Fbench%2Ftask-perf-jargon-metal-smoke.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-jargon-metal-smoke.rs?ref=d8450d69bbb7bb5c288fba01295551b78a5a8c03", "patch": "@@ -19,15 +19,15 @@\n \n use std::sync::mpsc::{channel, Sender};\n use std::env;\n-use std::thread::Thread;\n+use std::thread;\n \n fn child_generation(gens_left: uint, tx: Sender<()>) {\n     // This used to be O(n^2) in the number of generations that ever existed.\n     // With this code, only as many generations are alive at a time as tasks\n     // alive at a time,\n-    Thread::spawn(move|| {\n+    thread::spawn(move|| {\n         if gens_left & 1 == 1 {\n-            Thread::yield_now(); // shake things up a bit\n+            thread::yield_now(); // shake things up a bit\n         }\n         if gens_left > 0 {\n             child_generation(gens_left - 1, tx); // recurse"}, {"sha": "69b9e89dbc5228c42f3d7f9363ce60397ee499dc", "filename": "src/test/bench/task-perf-spawnalot.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Ftest%2Fbench%2Ftask-perf-spawnalot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Ftest%2Fbench%2Ftask-perf-spawnalot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-spawnalot.rs?ref=d8450d69bbb7bb5c288fba01295551b78a5a8c03", "patch": "@@ -9,12 +9,12 @@\n // except according to those terms.\n \n use std::env;\n-use std::thread::Thread;\n+use std::thread;\n \n fn f(n: usize) {\n     let mut i = 0u;\n     while i < n {\n-        let _ = Thread::scoped(move|| g()).join();\n+        let _ = thread::spawn(move|| g()).join();\n         i += 1u;\n     }\n }\n@@ -32,5 +32,5 @@ fn main() {\n     };\n     let n = args[1].parse().unwrap();\n     let mut i = 0;\n-    while i < n { Thread::spawn(move|| f(n) ); i += 1u; }\n+    while i < n { thread::spawn(move|| f(n) ); i += 1; }\n }"}, {"sha": "7f676f5166f7f77fb77129553870257313bc66ac", "filename": "src/test/compile-fail/borrowck-loan-blocks-move-cc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-move-cc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-move-cc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-blocks-move-cc.rs?ref=d8450d69bbb7bb5c288fba01295551b78a5a8c03", "patch": "@@ -10,7 +10,7 @@\n \n #![feature(box_syntax)]\n \n-use std::thread::Thread;\n+use std::thread;\n \n fn borrow<F>(v: &isize, f: F) where F: FnOnce(&isize) {\n     f(v);\n@@ -19,7 +19,7 @@ fn borrow<F>(v: &isize, f: F) where F: FnOnce(&isize) {\n fn box_imm() {\n     let v = box 3;\n     let _w = &v;\n-    Thread::spawn(move|| {\n+    thread::spawn(move|| {\n         println!(\"v={}\", *v);\n         //~^ ERROR cannot move `v` into closure\n     });\n@@ -28,7 +28,7 @@ fn box_imm() {\n fn box_imm_explicit() {\n     let v = box 3;\n     let _w = &v;\n-    Thread::spawn(move|| {\n+    thread::spawn(move|| {\n         println!(\"v={}\", *v);\n         //~^ ERROR cannot move\n     });"}, {"sha": "9db05d76284e8d23cdc1660fb9e834e3310a9f2f", "filename": "src/test/compile-fail/borrowck-multiple-captures.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Ftest%2Fcompile-fail%2Fborrowck-multiple-captures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Ftest%2Fcompile-fail%2Fborrowck-multiple-captures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-multiple-captures.rs?ref=d8450d69bbb7bb5c288fba01295551b78a5a8c03", "patch": "@@ -10,7 +10,7 @@\n \n #![feature(box_syntax)]\n \n-use std::thread::Thread;\n+use std::thread;\n \n fn borrow<T>(_: &T) { }\n \n@@ -19,7 +19,7 @@ fn different_vars_after_borrows() {\n     let p1 = &x1;\n     let x2 = box 2;\n     let p2 = &x2;\n-    Thread::spawn(move|| {\n+    thread::spawn(move|| {\n         drop(x1); //~ ERROR cannot move `x1` into closure because it is borrowed\n         drop(x2); //~ ERROR cannot move `x2` into closure because it is borrowed\n     });\n@@ -32,7 +32,7 @@ fn different_vars_after_moves() {\n     drop(x1);\n     let x2 = box 2;\n     drop(x2);\n-    Thread::spawn(move|| {\n+    thread::spawn(move|| {\n         drop(x1); //~ ERROR capture of moved value: `x1`\n         drop(x2); //~ ERROR capture of moved value: `x2`\n     });\n@@ -41,7 +41,7 @@ fn different_vars_after_moves() {\n fn same_var_after_borrow() {\n     let x = box 1;\n     let p = &x;\n-    Thread::spawn(move|| {\n+    thread::spawn(move|| {\n         drop(x); //~ ERROR cannot move `x` into closure because it is borrowed\n         drop(x); //~ ERROR use of moved value: `x`\n     });\n@@ -51,7 +51,7 @@ fn same_var_after_borrow() {\n fn same_var_after_move() {\n     let x = box 1;\n     drop(x);\n-    Thread::spawn(move|| {\n+    thread::spawn(move|| {\n         drop(x); //~ ERROR capture of moved value: `x`\n         drop(x); //~ ERROR use of moved value: `x`\n     });"}, {"sha": "735f529277c360be6c7291d432c54373e65d0446", "filename": "src/test/compile-fail/issue-12041.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Ftest%2Fcompile-fail%2Fissue-12041.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Ftest%2Fcompile-fail%2Fissue-12041.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-12041.rs?ref=d8450d69bbb7bb5c288fba01295551b78a5a8c03", "patch": "@@ -9,11 +9,11 @@\n // except according to those terms.\n \n use std::sync::mpsc::channel;\n-use std::thread::Thread;\n+use std::thread;\n \n fn main() {\n     let (tx, rx) = channel();\n-    let _t = Thread::spawn(move|| -> () {\n+    let _t = thread::spawn(move|| -> () {\n         loop {\n             let tx = tx;\n             //~^ ERROR: use of moved value: `tx`"}, {"sha": "4e44b4dcdce3e474a73e238696115442670c0f25", "filename": "src/test/compile-fail/issue-8460-const.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Ftest%2Fcompile-fail%2Fissue-8460-const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Ftest%2Fcompile-fail%2Fissue-8460-const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-8460-const.rs?ref=d8450d69bbb7bb5c288fba01295551b78a5a8c03", "patch": "@@ -9,47 +9,47 @@\n // except according to those terms.\n \n use std::{int, i8, i16, i32, i64};\n-use std::thread::Thread;\n+use std::thread;\n \n fn main() {\n-    assert!(Thread::scoped(move|| int::MIN / -1).join().is_err());\n+    assert!(thread::spawn(move|| int::MIN / -1).join().is_err());\n     //~^ ERROR attempted to divide with overflow in a constant expression\n-    assert!(Thread::scoped(move|| i8::MIN / -1).join().is_err());\n+    assert!(thread::spawn(move|| i8::MIN / -1).join().is_err());\n     //~^ ERROR attempted to divide with overflow in a constant expression\n-    assert!(Thread::scoped(move|| i16::MIN / -1).join().is_err());\n+    assert!(thread::spawn(move|| i16::MIN / -1).join().is_err());\n     //~^ ERROR attempted to divide with overflow in a constant expression\n-    assert!(Thread::scoped(move|| i32::MIN / -1).join().is_err());\n+    assert!(thread::spawn(move|| i32::MIN / -1).join().is_err());\n     //~^ ERROR attempted to divide with overflow in a constant expression\n-    assert!(Thread::scoped(move|| i64::MIN / -1).join().is_err());\n+    assert!(thread::spawn(move|| i64::MIN / -1).join().is_err());\n     //~^ ERROR attempted to divide with overflow in a constant expression\n-    assert!(Thread::scoped(move|| 1is / 0).join().is_err());\n+    assert!(thread::spawn(move|| 1is / 0).join().is_err());\n     //~^ ERROR attempted to divide by zero in a constant expression\n-    assert!(Thread::scoped(move|| 1i8 / 0).join().is_err());\n+    assert!(thread::spawn(move|| 1i8 / 0).join().is_err());\n     //~^ ERROR attempted to divide by zero in a constant expression\n-    assert!(Thread::scoped(move|| 1i16 / 0).join().is_err());\n+    assert!(thread::spawn(move|| 1i16 / 0).join().is_err());\n     //~^ ERROR attempted to divide by zero in a constant expression\n-    assert!(Thread::scoped(move|| 1i32 / 0).join().is_err());\n+    assert!(thread::spawn(move|| 1i32 / 0).join().is_err());\n     //~^ ERROR attempted to divide by zero in a constant expression\n-    assert!(Thread::scoped(move|| 1i64 / 0).join().is_err());\n+    assert!(thread::spawn(move|| 1i64 / 0).join().is_err());\n     //~^ ERROR attempted to divide by zero in a constant expression\n-    assert!(Thread::scoped(move|| int::MIN % -1).join().is_err());\n+    assert!(thread::spawn(move|| int::MIN % -1).join().is_err());\n     //~^ ERROR attempted remainder with overflow in a constant expression\n-    assert!(Thread::scoped(move|| i8::MIN % -1).join().is_err());\n+    assert!(thread::spawn(move|| i8::MIN % -1).join().is_err());\n     //~^ ERROR attempted remainder with overflow in a constant expression\n-    assert!(Thread::scoped(move|| i16::MIN % -1).join().is_err());\n+    assert!(thread::spawn(move|| i16::MIN % -1).join().is_err());\n     //~^ ERROR attempted remainder with overflow in a constant expression\n-    assert!(Thread::scoped(move|| i32::MIN % -1).join().is_err());\n+    assert!(thread::spawn(move|| i32::MIN % -1).join().is_err());\n     //~^ ERROR attempted remainder with overflow in a constant expression\n-    assert!(Thread::scoped(move|| i64::MIN % -1).join().is_err());\n+    assert!(thread::spawn(move|| i64::MIN % -1).join().is_err());\n     //~^ ERROR attempted remainder with overflow in a constant expression\n-    assert!(Thread::scoped(move|| 1is % 0).join().is_err());\n+    assert!(thread::spawn(move|| 1is % 0).join().is_err());\n     //~^ ERROR attempted remainder with a divisor of zero in a constant expression\n-    assert!(Thread::scoped(move|| 1i8 % 0).join().is_err());\n+    assert!(thread::spawn(move|| 1i8 % 0).join().is_err());\n     //~^ ERROR attempted remainder with a divisor of zero in a constant expression\n-    assert!(Thread::scoped(move|| 1i16 % 0).join().is_err());\n+    assert!(thread::spawn(move|| 1i16 % 0).join().is_err());\n     //~^ ERROR attempted remainder with a divisor of zero in a constant expression\n-    assert!(Thread::scoped(move|| 1i32 % 0).join().is_err());\n+    assert!(thread::spawn(move|| 1i32 % 0).join().is_err());\n     //~^ ERROR attempted remainder with a divisor of zero in a constant expression\n-    assert!(Thread::scoped(move|| 1i64 % 0).join().is_err());\n+    assert!(thread::spawn(move|| 1i64 % 0).join().is_err());\n     //~^ ERROR attempted remainder with a divisor of zero in a constant expression\n }"}, {"sha": "cf7a8378b9a9a120391cf88b7298532623c0ae44", "filename": "src/test/compile-fail/missing-stability.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Ftest%2Fcompile-fail%2Fmissing-stability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Ftest%2Fcompile-fail%2Fmissing-stability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmissing-stability.rs?ref=d8450d69bbb7bb5c288fba01295551b78a5a8c03", "patch": "@@ -30,4 +30,4 @@ pub mod bar {\n     // #[stable] is not inherited\n     pub fn unmarked() {}\n     //~^ ERROR This node does not have a stability attribute\n-}\n\\ No newline at end of file\n+}"}, {"sha": "32fa773ec807947f892e274386644f2c748a939a", "filename": "src/test/compile-fail/moves-based-on-type-capture-clause-bad.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-capture-clause-bad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-capture-clause-bad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-capture-clause-bad.rs?ref=d8450d69bbb7bb5c288fba01295551b78a5a8c03", "patch": "@@ -8,11 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::thread::Thread;\n+use std::thread;\n \n fn main() {\n     let x = \"Hello world!\".to_string();\n-    Thread::spawn(move|| {\n+    thread::spawn(move|| {\n         println!(\"{}\", x);\n     });\n     println!(\"{}\", x); //~ ERROR use of moved value"}, {"sha": "7b7b3c414dded597ff769400ee605153b7fa192e", "filename": "src/test/compile-fail/no-capture-arc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Ftest%2Fcompile-fail%2Fno-capture-arc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Ftest%2Fcompile-fail%2Fno-capture-arc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno-capture-arc.rs?ref=d8450d69bbb7bb5c288fba01295551b78a5a8c03", "patch": "@@ -11,13 +11,13 @@\n // error-pattern: use of moved value\n \n use std::sync::Arc;\n-use std::thread::Thread;\n+use std::thread;\n \n fn main() {\n     let v = vec!(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);\n     let arc_v = Arc::new(v);\n \n-    Thread::spawn(move|| {\n+    thread::spawn(move|| {\n         assert_eq!((*arc_v)[3], 4);\n     });\n "}, {"sha": "1720b40c83bbd749256e04179b06e3ae7446f92b", "filename": "src/test/compile-fail/no-reuse-move-arc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Ftest%2Fcompile-fail%2Fno-reuse-move-arc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Ftest%2Fcompile-fail%2Fno-reuse-move-arc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno-reuse-move-arc.rs?ref=d8450d69bbb7bb5c288fba01295551b78a5a8c03", "patch": "@@ -9,13 +9,13 @@\n // except according to those terms.\n \n use std::sync::Arc;\n-use std::thread::Thread;\n+use std::thread;\n \n fn main() {\n     let v = vec!(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);\n     let arc_v = Arc::new(v);\n \n-    Thread::spawn(move|| {\n+    thread::spawn(move|| {\n         assert_eq!((*arc_v)[3], 4);\n     });\n "}, {"sha": "5ebc386109a8bcdf3ce589bf37e840dc0b8757eb", "filename": "src/test/compile-fail/no-send-res-ports.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Ftest%2Fcompile-fail%2Fno-send-res-ports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Ftest%2Fcompile-fail%2Fno-send-res-ports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno-send-res-ports.rs?ref=d8450d69bbb7bb5c288fba01295551b78a5a8c03", "patch": "@@ -10,7 +10,7 @@\n \n #![feature(unsafe_destructor)]\n \n-use std::thread::Thread;\n+use std::thread;\n use std::rc::Rc;\n \n #[derive(Debug)]\n@@ -35,7 +35,7 @@ fn main() {\n \n     let x = foo(Port(Rc::new(())));\n \n-    Thread::spawn(move|| {\n+    thread::spawn(move|| {\n         //~^ ERROR `core::marker::Send` is not implemented\n         let y = x;\n         println!(\"{:?}\", y);"}, {"sha": "40a881852f5fc5b279108804a43a5a46fcae5eb8", "filename": "src/test/run-fail/panic-task-name-none.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Ftest%2Frun-fail%2Fpanic-task-name-none.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Ftest%2Frun-fail%2Fpanic-task-name-none.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fpanic-task-name-none.rs?ref=d8450d69bbb7bb5c288fba01295551b78a5a8c03", "patch": "@@ -10,10 +10,10 @@\n \n // error-pattern:thread '<unnamed>' panicked at 'test'\n \n-use std::thread::Thread;\n+use std::thread;\n \n fn main() {\n-    let r: Result<int,_> = Thread::scoped(move|| {\n+    let r: Result<int,_> = thread::spawn(move|| {\n         panic!(\"test\");\n         1\n     }).join();"}, {"sha": "775d38c8b3044ca917d8729799552664e21e90d2", "filename": "src/test/run-fail/rt-set-exit-status-panic2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Ftest%2Frun-fail%2Frt-set-exit-status-panic2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Ftest%2Frun-fail%2Frt-set-exit-status-panic2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Frt-set-exit-status-panic2.rs?ref=d8450d69bbb7bb5c288fba01295551b78a5a8c03", "patch": "@@ -12,7 +12,7 @@\n \n #[macro_use] extern crate log;\n use std::os;\n-use std::thread::Thread;\n+use std::thread;\n \n struct r {\n   x:int,\n@@ -35,7 +35,7 @@ fn r(x:int) -> r {\n \n fn main() {\n     error!(\"whatever\");\n-    let _t = Thread::spawn(move|| {\n+    let _t = thread::spawn(move|| {\n       let _i = r(5);\n     });\n     panic!();"}, {"sha": "406f7dbcb67fec9d95711e32b5e8b5fd68985813", "filename": "src/test/run-fail/task-spawn-barefn.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Ftest%2Frun-fail%2Ftask-spawn-barefn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Ftest%2Frun-fail%2Ftask-spawn-barefn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Ftask-spawn-barefn.rs?ref=d8450d69bbb7bb5c288fba01295551b78a5a8c03", "patch": "@@ -10,12 +10,12 @@\n \n // error-pattern:Ensure that the child task runs by panicking\n \n-use std::thread::Thread;\n+use std::thread;\n \n fn main() {\n     // the purpose of this test is to make sure that task::spawn()\n     // works when provided with a bare function:\n-    let r = Thread::scoped(startfn).join();\n+    let r = thread::spawn(startfn).join();\n     if r.is_err() {\n         panic!()\n     }"}, {"sha": "08ffe4036962675e5ee10a838fc25770ae176796", "filename": "src/test/run-pass/unique-send-2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Ftest%2Frun-pass%2Funique-send-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Ftest%2Frun-pass%2Funique-send-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funique-send-2.rs?ref=d8450d69bbb7bb5c288fba01295551b78a5a8c03", "patch": "@@ -12,7 +12,7 @@\n #![feature(box_syntax)]\n \n use std::sync::mpsc::{channel, Sender};\n-use std::thread::Thread;\n+use std::thread;\n \n fn child(tx: &Sender<Box<uint>>, i: uint) {\n     tx.send(box i).unwrap();\n@@ -25,7 +25,7 @@ pub fn main() {\n     let _t = (0u..n).map(|i| {\n         expected += i;\n         let tx = tx.clone();\n-        Thread::scoped(move|| {\n+        thread::spawn(move|| {\n             child(&tx, i)\n         })\n     }).collect::<Vec<_>>();"}, {"sha": "ac46187f03a71d90f09c3859a529b235779a52e7", "filename": "src/test/run-pass/unit-like-struct-drop-run.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Ftest%2Frun-pass%2Funit-like-struct-drop-run.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Ftest%2Frun-pass%2Funit-like-struct-drop-run.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funit-like-struct-drop-run.rs?ref=d8450d69bbb7bb5c288fba01295551b78a5a8c03", "patch": "@@ -11,7 +11,7 @@\n // Make sure the destructor is run for unit-like structs.\n \n use std::boxed::BoxAny;\n-use std::thread::Thread;\n+use std::thread;\n \n struct Foo;\n \n@@ -22,7 +22,7 @@ impl Drop for Foo {\n }\n \n pub fn main() {\n-    let x = Thread::scoped(move|| {\n+    let x = thread::spawn(move|| {\n         let _b = Foo;\n     }).join();\n "}, {"sha": "52c09aadfbd7b17a34afa25a7472359f27d0677d", "filename": "src/test/run-pass/unwind-resource.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Ftest%2Frun-pass%2Funwind-resource.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Ftest%2Frun-pass%2Funwind-resource.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funwind-resource.rs?ref=d8450d69bbb7bb5c288fba01295551b78a5a8c03", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use std::sync::mpsc::{channel, Sender};\n-use std::thread::Thread;\n+use std::thread;\n \n struct complainer {\n     tx: Sender<bool>,\n@@ -37,7 +37,7 @@ fn f(tx: Sender<bool>) {\n \n pub fn main() {\n     let (tx, rx) = channel();\n-    let _t = Thread::scoped(move|| f(tx.clone()));\n+    let _t = thread::spawn(move|| f(tx.clone()));\n     println!(\"hiiiiiiiii\");\n     assert!(rx.recv().unwrap());\n }"}, {"sha": "d38b6e79eba66bccffd5632e441f5c9c345e31d4", "filename": "src/test/run-pass/unwind-unique.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Ftest%2Frun-pass%2Funwind-unique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Ftest%2Frun-pass%2Funwind-unique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funwind-unique.rs?ref=d8450d69bbb7bb5c288fba01295551b78a5a8c03", "patch": "@@ -11,13 +11,13 @@\n #![allow(unknown_features)]\n #![feature(box_syntax)]\n \n-use std::thread::Thread;\n+use std::thread;\n \n fn f() {\n     let _a = box 0;\n     panic!();\n }\n \n pub fn main() {\n-    let _t = Thread::scoped(f);\n+    let _t = thread::spawn(f);\n }"}, {"sha": "da9cf35813b5bd36a3aa0aaddaa02b772b1236d3", "filename": "src/test/run-pass/vector-sort-panic-safe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Ftest%2Frun-pass%2Fvector-sort-panic-safe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Ftest%2Frun-pass%2Fvector-sort-panic-safe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvector-sort-panic-safe.rs?ref=d8450d69bbb7bb5c288fba01295551b78a5a8c03", "patch": "@@ -10,7 +10,7 @@\n \n use std::sync::atomic::{AtomicUsize, ATOMIC_USIZE_INIT, Ordering};\n use std::rand::{thread_rng, Rng, Rand};\n-use std::thread::Thread;\n+use std::thread;\n \n const REPEATS: usize = 5;\n const MAX_LEN: usize = 32;\n@@ -79,7 +79,7 @@ pub fn main() {\n \n                 let v = main.clone();\n \n-                let _ = Thread::scoped(move|| {\n+                let _ = thread::spawn(move|| {\n                     let mut v = v;\n                     let mut panic_countdown = panic_countdown;\n                     v.sort_by(|a, b| {"}, {"sha": "741e8be02f72c4250d9bfad06ba6d8ac3c797bd7", "filename": "src/test/run-pass/weak-lang-item.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Ftest%2Frun-pass%2Fweak-lang-item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Ftest%2Frun-pass%2Fweak-lang-item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fweak-lang-item.rs?ref=d8450d69bbb7bb5c288fba01295551b78a5a8c03", "patch": "@@ -12,10 +12,10 @@\n \n extern crate \"weak-lang-items\" as other;\n \n-use std::thread::Thread;\n+use std::thread;\n \n fn main() {\n-    let _ = Thread::scoped(move|| {\n+    let _ = thread::spawn(move|| {\n         other::foo()\n     });\n }"}, {"sha": "45a747509589d85572d18cd8ec40ddd09d502efd", "filename": "src/test/run-pass/yield.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Ftest%2Frun-pass%2Fyield.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Ftest%2Frun-pass%2Fyield.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fyield.rs?ref=d8450d69bbb7bb5c288fba01295551b78a5a8c03", "patch": "@@ -8,18 +8,18 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::thread::Thread;\n+use std::thread;\n \n pub fn main() {\n-    let mut result = Thread::scoped(child);\n+    let mut result = thread::spawn(child);\n     println!(\"1\");\n-    Thread::yield_now();\n+    thread::yield_now();\n     println!(\"2\");\n-    Thread::yield_now();\n+    thread::yield_now();\n     println!(\"3\");\n     result.join();\n }\n \n fn child() {\n-    println!(\"4\"); Thread::yield_now(); println!(\"5\"); Thread::yield_now(); println!(\"6\");\n+    println!(\"4\"); thread::yield_now(); println!(\"5\"); thread::yield_now(); println!(\"6\");\n }"}, {"sha": "69d8431082c2f42995c1479b2dbee192e4d1da29", "filename": "src/test/run-pass/yield1.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Ftest%2Frun-pass%2Fyield1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Ftest%2Frun-pass%2Fyield1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fyield1.rs?ref=d8450d69bbb7bb5c288fba01295551b78a5a8c03", "patch": "@@ -8,12 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::thread::Thread;\n+use std::thread;\n \n pub fn main() {\n-    let mut result = Thread::scoped(child);\n+    let mut result = thread::spawn(child);\n     println!(\"1\");\n-    Thread::yield_now();\n+    thread::yield_now();\n     result.join();\n }\n "}, {"sha": "56dc02c6d2e673beab5235236d77d3aa08bf3fc4", "filename": "src/test/run-pass/yield2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Ftest%2Frun-pass%2Fyield2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8450d69bbb7bb5c288fba01295551b78a5a8c03/src%2Ftest%2Frun-pass%2Fyield2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fyield2.rs?ref=d8450d69bbb7bb5c288fba01295551b78a5a8c03", "patch": "@@ -8,9 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::thread::Thread;\n+use std::thread;\n \n pub fn main() {\n     let mut i: int = 0;\n-    while i < 100 { i = i + 1; println!(\"{}\", i); Thread::yield_now(); }\n+    while i < 100 { i = i + 1; println!(\"{}\", i); thread::yield_now(); }\n }"}]}