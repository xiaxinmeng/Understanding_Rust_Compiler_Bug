{"sha": "c339b2eb4aaa69499dc79b17575c671d3605723c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMzMzliMmViNGFhYTY5NDk5ZGM3OWIxNzU3NWM2NzFkMzYwNTcyM2M=", "commit": {"author": {"name": "Bastian Kauschke", "email": "bastian_kauschke@hotmail.de", "date": "2020-03-27T15:44:40Z"}, "committer": {"name": "Bastian Kauschke", "email": "bastian_kauschke@hotmail.de", "date": "2020-03-27T15:44:40Z"}, "message": "refactor type_of for consts", "tree": {"sha": "f86f035acdd05706ad9deadf8d64516f42920715", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f86f035acdd05706ad9deadf8d64516f42920715"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c339b2eb4aaa69499dc79b17575c671d3605723c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c339b2eb4aaa69499dc79b17575c671d3605723c", "html_url": "https://github.com/rust-lang/rust/commit/c339b2eb4aaa69499dc79b17575c671d3605723c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c339b2eb4aaa69499dc79b17575c671d3605723c/comments", "author": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2fbb07525e2f07a815e780a4268b11916248b5a9", "url": "https://api.github.com/repos/rust-lang/rust/commits/2fbb07525e2f07a815e780a4268b11916248b5a9", "html_url": "https://github.com/rust-lang/rust/commit/2fbb07525e2f07a815e780a4268b11916248b5a9"}], "stats": {"total": 148, "additions": 71, "deletions": 77}, "files": [{"sha": "23613caa99322121b10b18d98e7f9a9550463599", "filename": "src/librustc_typeck/collect/type_of.rs", "status": "modified", "additions": 71, "deletions": 77, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/c339b2eb4aaa69499dc79b17575c671d3605723c/src%2Flibrustc_typeck%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c339b2eb4aaa69499dc79b17575c671d3605723c/src%2Flibrustc_typeck%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect%2Ftype_of.rs?ref=c339b2eb4aaa69499dc79b17575c671d3605723c", "patch": "@@ -216,93 +216,87 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n                 | Node::Expr(&Expr { kind: ExprKind::Path(_), .. })\n                 | Node::TraitRef(..) => {\n                     let path = match parent_node {\n-                        Node::Ty(&Ty {\n-                            kind: TyKind::Path(QPath::Resolved(_, ref path)), ..\n-                        })\n+                        Node::Ty(&Ty { kind: TyKind::Path(QPath::Resolved(_, path)), .. })\n                         | Node::Expr(&Expr {\n-                            kind: ExprKind::Path(QPath::Resolved(_, ref path)),\n+                            kind:\n+                                ExprKind::Path(QPath::Resolved(_, path))\n+                                | ExprKind::Struct(&QPath::Resolved(_, path), ..),\n                             ..\n-                        }) => Some(&**path),\n-                        Node::Expr(&Expr { kind: ExprKind::Struct(ref path, ..), .. }) => {\n-                            if let QPath::Resolved(_, ref path) = **path {\n-                                Some(&**path)\n-                            } else {\n-                                None\n-                            }\n+                        })\n+                        | Node::TraitRef(&TraitRef { path, .. }) => &*path,\n+                        _ => {\n+                            tcx.sess.delay_span_bug(\n+                                DUMMY_SP,\n+                                &format!(\"unexpected const parent path {:?}\", parent_node),\n+                            );\n+                            return tcx.types.err;\n                         }\n-                        Node::TraitRef(&TraitRef { ref path, .. }) => Some(&**path),\n-                        _ => None,\n                     };\n \n-                    if let Some(path) = path {\n-                        // We've encountered an `AnonConst` in some path, so we need to\n-                        // figure out which generic parameter it corresponds to and return\n-                        // the relevant type.\n-\n-                        let (arg_index, segment) = path\n-                            .segments\n-                            .iter()\n-                            .filter_map(|seg| seg.args.as_ref().map(|args| (args.args, seg)))\n-                            .find_map(|(args, seg)| {\n-                                args.iter()\n-                                    .filter(|arg| arg.is_const())\n-                                    .enumerate()\n-                                    .filter(|(_, arg)| arg.id() == hir_id)\n-                                    .map(|(index, _)| (index, seg))\n-                                    .next()\n-                            })\n-                            .unwrap_or_else(|| {\n-                                bug!(\"no arg matching AnonConst in path\");\n-                            });\n-\n-                        // Try to use the segment resolution if it is valid, otherwise we\n-                        // default to the path resolution.\n-                        let res = segment.res.filter(|&r| r != Res::Err).unwrap_or(path.res);\n-                        let generics = match res {\n-                            Res::Def(DefKind::Ctor(..), def_id) => {\n-                                tcx.generics_of(tcx.parent(def_id).unwrap())\n-                            }\n-                            Res::Def(_, def_id) => tcx.generics_of(def_id),\n-                            res => {\n-                                tcx.sess.delay_span_bug(\n-                                    DUMMY_SP,\n-                                    &format!(\n-                                        \"unexpected anon const res {:?} in path: {:?}\",\n-                                        res, path,\n-                                    ),\n-                                );\n-                                return tcx.types.err;\n+                    // We've encountered an `AnonConst` in some path, so we need to\n+                    // figure out which generic parameter it corresponds to and return\n+                    // the relevant type.\n+\n+                    let (arg_index, segment) = path\n+                        .segments\n+                        .iter()\n+                        .filter_map(|seg| seg.args.as_ref().map(|args| (args.args, seg)))\n+                        .find_map(|(args, seg)| {\n+                            args.iter()\n+                                .filter(|arg| arg.is_const())\n+                                .enumerate()\n+                                .filter(|(_, arg)| arg.id() == hir_id)\n+                                .map(|(index, _)| (index, seg))\n+                                .next()\n+                        })\n+                        .unwrap_or_else(|| {\n+                            bug!(\"no arg matching AnonConst in path\");\n+                        });\n+\n+                    // Try to use the segment resolution if it is valid, otherwise we\n+                    // default to the path resolution.\n+                    let res = segment.res.filter(|&r| r != Res::Err).unwrap_or(path.res);\n+                    let generics = match res {\n+                        Res::Def(DefKind::Ctor(..), def_id) => {\n+                            tcx.generics_of(tcx.parent(def_id).unwrap())\n+                        }\n+                        Res::Def(_, def_id) => tcx.generics_of(def_id),\n+                        res => {\n+                            tcx.sess.delay_span_bug(\n+                                DUMMY_SP,\n+                                &format!(\n+                                    \"unexpected anon const res {:?} in path: {:?}\",\n+                                    res, path,\n+                                ),\n+                            );\n+                            return tcx.types.err;\n+                        }\n+                    };\n+\n+                    let ty = generics\n+                        .params\n+                        .iter()\n+                        .filter(|param| {\n+                            if let ty::GenericParamDefKind::Const = param.kind {\n+                                true\n+                            } else {\n+                                false\n                             }\n-                        };\n+                        })\n+                        .nth(arg_index)\n+                        .map(|param| tcx.type_of(param.def_id));\n \n-                        generics\n-                            .params\n-                            .iter()\n-                            .filter(|param| {\n-                                if let ty::GenericParamDefKind::Const = param.kind {\n-                                    true\n-                                } else {\n-                                    false\n-                                }\n-                            })\n-                            .nth(arg_index)\n-                            .map(|param| tcx.type_of(param.def_id))\n-                            // This is no generic parameter associated with the arg. This is\n-                            // probably from an extra arg where one is not needed.\n-                            .unwrap_or_else(|| {\n-                                tcx.sess.delay_span_bug(\n-                                    DUMMY_SP,\n-                                    &format!(\n-                                        \"missing generic parameter for `AnonConst`, parent: {:?}, res: {:?}\",\n-                                        parent_node, res\n-                                    ),\n-                                );\n-                                tcx.types.err\n-                            })\n+                    if let Some(ty) = ty {\n+                        ty\n                     } else {\n+                        // This is no generic parameter associated with the arg. This is\n+                        // probably from an extra arg where one is not needed.\n                         tcx.sess.delay_span_bug(\n                             DUMMY_SP,\n-                            &format!(\"unexpected const parent path {:?}\", parent_node,),\n+                            &format!(\n+                                \"missing generic parameter for `AnonConst`, parent: {:?}, res: {:?}\",\n+                                parent_node, res\n+                            ),\n                         );\n                         tcx.types.err\n                     }"}]}