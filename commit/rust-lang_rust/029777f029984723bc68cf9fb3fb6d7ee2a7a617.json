{"sha": "029777f029984723bc68cf9fb3fb6d7ee2a7a617", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAyOTc3N2YwMjk5ODQ3MjNiYzY4Y2Y5ZmIzZmI2ZDdlZTJhN2E2MTc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-03-22T19:36:22Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-03-22T19:36:22Z"}, "message": "Auto merge of #6896 - TaKO8Ki:refactor-lints-in-methods-module, r=phansch\n\nRefactor lints in methods module\n\nThis PR refactors methods lints other than the lints I refactored in https://github.com/rust-lang/rust-clippy/pull/6826 and moves some functions to methods/utils.rs.\nBasically, I follow the instruction described in #6680.\n\n**For ease of review, I refactored step by step, keeping each commit small.**\n\ncloses https://github.com/rust-lang/rust-clippy/issues/6886\ncc: `@phansch,` `@flip1995,` `@Y-Nak`\n\nchangelog: Move lints in methods module to their own modules and some function to methods/utils.rs.", "tree": {"sha": "a6ba9aa43c013b92a5961c3899b40f2c4ec4d5f1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a6ba9aa43c013b92a5961c3899b40f2c4ec4d5f1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/029777f029984723bc68cf9fb3fb6d7ee2a7a617", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/029777f029984723bc68cf9fb3fb6d7ee2a7a617", "html_url": "https://github.com/rust-lang/rust/commit/029777f029984723bc68cf9fb3fb6d7ee2a7a617", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/029777f029984723bc68cf9fb3fb6d7ee2a7a617/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aca95aac7b070bc8730178bfea8464f52277e616", "url": "https://api.github.com/repos/rust-lang/rust/commits/aca95aac7b070bc8730178bfea8464f52277e616", "html_url": "https://github.com/rust-lang/rust/commit/aca95aac7b070bc8730178bfea8464f52277e616"}, {"sha": "b6a2757561167f831939f874735e259e655031a1", "url": "https://api.github.com/repos/rust-lang/rust/commits/b6a2757561167f831939f874735e259e655031a1", "html_url": "https://github.com/rust-lang/rust/commit/b6a2757561167f831939f874735e259e655031a1"}], "stats": {"total": 721, "additions": 388, "deletions": 333}, "files": [{"sha": "c668fe52781dc32a5c0e0dcac0f1e59818ab7bcf", "filename": "clippy_lints/src/methods/chars_cmp.rs", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/029777f029984723bc68cf9fb3fb6d7ee2a7a617/clippy_lints%2Fsrc%2Fmethods%2Fchars_cmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/029777f029984723bc68cf9fb3fb6d7ee2a7a617/clippy_lints%2Fsrc%2Fmethods%2Fchars_cmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fchars_cmp.rs?ref=029777f029984723bc68cf9fb3fb6d7ee2a7a617", "patch": "@@ -0,0 +1,54 @@\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::source::snippet_with_applicability;\n+use clippy_utils::{method_chain_args, single_segment_path};\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_lint::LateContext;\n+use rustc_lint::Lint;\n+use rustc_middle::ty;\n+use rustc_span::sym;\n+\n+/// Wrapper fn for `CHARS_NEXT_CMP` and `CHARS_LAST_CMP` lints.\n+pub(super) fn check(\n+    cx: &LateContext<'_>,\n+    info: &crate::methods::BinaryExprInfo<'_>,\n+    chain_methods: &[&str],\n+    lint: &'static Lint,\n+    suggest: &str,\n+) -> bool {\n+    if_chain! {\n+        if let Some(args) = method_chain_args(info.chain, chain_methods);\n+        if let hir::ExprKind::Call(ref fun, ref arg_char) = info.other.kind;\n+        if arg_char.len() == 1;\n+        if let hir::ExprKind::Path(ref qpath) = fun.kind;\n+        if let Some(segment) = single_segment_path(qpath);\n+        if segment.ident.name == sym::Some;\n+        then {\n+            let mut applicability = Applicability::MachineApplicable;\n+            let self_ty = cx.typeck_results().expr_ty_adjusted(&args[0][0]).peel_refs();\n+\n+            if *self_ty.kind() != ty::Str {\n+                return false;\n+            }\n+\n+            span_lint_and_sugg(\n+                cx,\n+                lint,\n+                info.expr.span,\n+                &format!(\"you should use the `{}` method\", suggest),\n+                \"like this\",\n+                format!(\"{}{}.{}({})\",\n+                        if info.eq { \"\" } else { \"!\" },\n+                        snippet_with_applicability(cx, args[0][0].span, \"..\", &mut applicability),\n+                        suggest,\n+                        snippet_with_applicability(cx, arg_char[0].span, \"..\", &mut applicability)),\n+                applicability,\n+            );\n+\n+            return true;\n+        }\n+    }\n+\n+    false\n+}"}, {"sha": "4275857757fee4552ee56536a9622261a78a86e5", "filename": "clippy_lints/src/methods/chars_cmp_with_unwrap.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/029777f029984723bc68cf9fb3fb6d7ee2a7a617/clippy_lints%2Fsrc%2Fmethods%2Fchars_cmp_with_unwrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/029777f029984723bc68cf9fb3fb6d7ee2a7a617/clippy_lints%2Fsrc%2Fmethods%2Fchars_cmp_with_unwrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fchars_cmp_with_unwrap.rs?ref=029777f029984723bc68cf9fb3fb6d7ee2a7a617", "patch": "@@ -0,0 +1,44 @@\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::method_chain_args;\n+use clippy_utils::source::snippet_with_applicability;\n+use if_chain::if_chain;\n+use rustc_ast::ast;\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_lint::LateContext;\n+use rustc_lint::Lint;\n+\n+/// Wrapper fn for `CHARS_NEXT_CMP` and `CHARS_LAST_CMP` lints with `unwrap()`.\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    info: &crate::methods::BinaryExprInfo<'_>,\n+    chain_methods: &[&str],\n+    lint: &'static Lint,\n+    suggest: &str,\n+) -> bool {\n+    if_chain! {\n+        if let Some(args) = method_chain_args(info.chain, chain_methods);\n+        if let hir::ExprKind::Lit(ref lit) = info.other.kind;\n+        if let ast::LitKind::Char(c) = lit.node;\n+        then {\n+            let mut applicability = Applicability::MachineApplicable;\n+            span_lint_and_sugg(\n+                cx,\n+                lint,\n+                info.expr.span,\n+                &format!(\"you should use the `{}` method\", suggest),\n+                \"like this\",\n+                format!(\"{}{}.{}('{}')\",\n+                        if info.eq { \"\" } else { \"!\" },\n+                        snippet_with_applicability(cx, args[0][0].span, \"..\", &mut applicability),\n+                        suggest,\n+                        c),\n+                applicability,\n+            );\n+\n+            true\n+        } else {\n+            false\n+        }\n+    }\n+}"}, {"sha": "07bbc5ca1bf46cdf843966ea89ce87b3378164e9", "filename": "clippy_lints/src/methods/chars_last_cmp.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/029777f029984723bc68cf9fb3fb6d7ee2a7a617/clippy_lints%2Fsrc%2Fmethods%2Fchars_last_cmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/029777f029984723bc68cf9fb3fb6d7ee2a7a617/clippy_lints%2Fsrc%2Fmethods%2Fchars_last_cmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fchars_last_cmp.rs?ref=029777f029984723bc68cf9fb3fb6d7ee2a7a617", "patch": "@@ -0,0 +1,13 @@\n+use crate::methods::chars_cmp;\n+use rustc_lint::LateContext;\n+\n+use super::CHARS_LAST_CMP;\n+\n+/// Checks for the `CHARS_LAST_CMP` lint.\n+pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, info: &crate::methods::BinaryExprInfo<'_>) -> bool {\n+    if chars_cmp::check(cx, info, &[\"chars\", \"last\"], CHARS_LAST_CMP, \"ends_with\") {\n+        true\n+    } else {\n+        chars_cmp::check(cx, info, &[\"chars\", \"next_back\"], CHARS_LAST_CMP, \"ends_with\")\n+    }\n+}"}, {"sha": "c29ee0ec8c8ca5720430947f701cdc6ed6c2e7e9", "filename": "clippy_lints/src/methods/chars_last_cmp_with_unwrap.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/029777f029984723bc68cf9fb3fb6d7ee2a7a617/clippy_lints%2Fsrc%2Fmethods%2Fchars_last_cmp_with_unwrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/029777f029984723bc68cf9fb3fb6d7ee2a7a617/clippy_lints%2Fsrc%2Fmethods%2Fchars_last_cmp_with_unwrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fchars_last_cmp_with_unwrap.rs?ref=029777f029984723bc68cf9fb3fb6d7ee2a7a617", "patch": "@@ -0,0 +1,13 @@\n+use crate::methods::chars_cmp_with_unwrap;\n+use rustc_lint::LateContext;\n+\n+use super::CHARS_LAST_CMP;\n+\n+/// Checks for the `CHARS_LAST_CMP` lint with `unwrap()`.\n+pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, info: &crate::methods::BinaryExprInfo<'_>) -> bool {\n+    if chars_cmp_with_unwrap::check(cx, info, &[\"chars\", \"last\", \"unwrap\"], CHARS_LAST_CMP, \"ends_with\") {\n+        true\n+    } else {\n+        chars_cmp_with_unwrap::check(cx, info, &[\"chars\", \"next_back\", \"unwrap\"], CHARS_LAST_CMP, \"ends_with\")\n+    }\n+}"}, {"sha": "a6701d8830e77d099f17bcc7192f6f6cac566190", "filename": "clippy_lints/src/methods/chars_next_cmp.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/029777f029984723bc68cf9fb3fb6d7ee2a7a617/clippy_lints%2Fsrc%2Fmethods%2Fchars_next_cmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/029777f029984723bc68cf9fb3fb6d7ee2a7a617/clippy_lints%2Fsrc%2Fmethods%2Fchars_next_cmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fchars_next_cmp.rs?ref=029777f029984723bc68cf9fb3fb6d7ee2a7a617", "patch": "@@ -0,0 +1,8 @@\n+use rustc_lint::LateContext;\n+\n+use super::CHARS_NEXT_CMP;\n+\n+/// Checks for the `CHARS_NEXT_CMP` lint.\n+pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, info: &crate::methods::BinaryExprInfo<'_>) -> bool {\n+    crate::methods::chars_cmp::check(cx, info, &[\"chars\", \"next\"], CHARS_NEXT_CMP, \"starts_with\")\n+}"}, {"sha": "28ede28e9358bee56a41817d121950bf3e0cd2d6", "filename": "clippy_lints/src/methods/chars_next_cmp_with_unwrap.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/029777f029984723bc68cf9fb3fb6d7ee2a7a617/clippy_lints%2Fsrc%2Fmethods%2Fchars_next_cmp_with_unwrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/029777f029984723bc68cf9fb3fb6d7ee2a7a617/clippy_lints%2Fsrc%2Fmethods%2Fchars_next_cmp_with_unwrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fchars_next_cmp_with_unwrap.rs?ref=029777f029984723bc68cf9fb3fb6d7ee2a7a617", "patch": "@@ -0,0 +1,8 @@\n+use rustc_lint::LateContext;\n+\n+use super::CHARS_NEXT_CMP;\n+\n+/// Checks for the `CHARS_NEXT_CMP` lint with `unwrap()`.\n+pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, info: &crate::methods::BinaryExprInfo<'_>) -> bool {\n+    crate::methods::chars_cmp_with_unwrap::check(cx, info, &[\"chars\", \"next\", \"unwrap\"], CHARS_NEXT_CMP, \"starts_with\")\n+}"}, {"sha": "edb6649b87b4da3dec83356492fa497947784304", "filename": "clippy_lints/src/methods/clone_on_copy.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/029777f029984723bc68cf9fb3fb6d7ee2a7a617/clippy_lints%2Fsrc%2Fmethods%2Fclone_on_copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/029777f029984723bc68cf9fb3fb6d7ee2a7a617/clippy_lints%2Fsrc%2Fmethods%2Fclone_on_copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fclone_on_copy.rs?ref=029777f029984723bc68cf9fb3fb6d7ee2a7a617", "patch": "@@ -4,14 +4,20 @@ use clippy_utils::ty::is_copy;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_lint::LateContext;\n-use rustc_middle::ty::{self, Ty};\n+use rustc_middle::ty;\n+use rustc_span::symbol::{sym, Symbol};\n use std::iter;\n \n use super::CLONE_DOUBLE_REF;\n use super::CLONE_ON_COPY;\n \n /// Checks for the `CLONE_ON_COPY` lint.\n-pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, arg: &hir::Expr<'_>, arg_ty: Ty<'_>) {\n+pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, method_name: Symbol, args: &[hir::Expr<'_>]) {\n+    if !(args.len() == 1 && method_name == sym::clone) {\n+        return;\n+    }\n+    let arg = &args[0];\n+    let arg_ty = cx.typeck_results().expr_ty_adjusted(&args[0]);\n     let ty = cx.typeck_results().expr_ty(expr);\n     if let ty::Ref(_, inner, _) = arg_ty.kind() {\n         if let ty::Ref(_, innermost, _) = inner.kind() {"}, {"sha": "6417bc81304739e9c72ac75a9fb1c9d4045e097f", "filename": "clippy_lints/src/methods/clone_on_ref_ptr.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/029777f029984723bc68cf9fb3fb6d7ee2a7a617/clippy_lints%2Fsrc%2Fmethods%2Fclone_on_ref_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/029777f029984723bc68cf9fb3fb6d7ee2a7a617/clippy_lints%2Fsrc%2Fmethods%2Fclone_on_ref_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fclone_on_ref_ptr.rs?ref=029777f029984723bc68cf9fb3fb6d7ee2a7a617", "patch": "@@ -6,11 +6,15 @@ use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_lint::LateContext;\n use rustc_middle::ty;\n-use rustc_span::symbol::sym;\n+use rustc_span::symbol::{sym, Symbol};\n \n use super::CLONE_ON_REF_PTR;\n \n-pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, arg: &hir::Expr<'_>) {\n+pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, method_name: Symbol, args: &[hir::Expr<'_>]) {\n+    if !(args.len() == 1 && method_name == sym::clone) {\n+        return;\n+    }\n+    let arg = &args[0];\n     let obj_ty = cx.typeck_results().expr_ty(arg).peel_refs();\n \n     if let ty::Adt(_, subst) = obj_ty.kind() {"}, {"sha": "1588eec88824bfdfc97ebee00565fe846a81f179", "filename": "clippy_lints/src/methods/filter_flat_map.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/029777f029984723bc68cf9fb3fb6d7ee2a7a617/clippy_lints%2Fsrc%2Fmethods%2Ffilter_flat_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/029777f029984723bc68cf9fb3fb6d7ee2a7a617/clippy_lints%2Fsrc%2Fmethods%2Ffilter_flat_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Ffilter_flat_map.rs?ref=029777f029984723bc68cf9fb3fb6d7ee2a7a617", "patch": "@@ -7,12 +7,7 @@ use rustc_span::sym;\n use super::FILTER_MAP;\n \n /// lint use of `filter().flat_map()` for `Iterators`\n-pub(super) fn check<'tcx>(\n-    cx: &LateContext<'tcx>,\n-    expr: &'tcx hir::Expr<'_>,\n-    _filter_args: &'tcx [hir::Expr<'_>],\n-    _map_args: &'tcx [hir::Expr<'_>],\n-) {\n+pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n     // lint if caller of `.filter().flat_map()` is an Iterator\n     if is_trait_method(cx, expr, sym::Iterator) {\n         let msg = \"called `filter(..).flat_map(..)` on an `Iterator`\";"}, {"sha": "741b1e7e361255c09560bbdadd26ca46e32963b7", "filename": "clippy_lints/src/methods/filter_map_flat_map.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/029777f029984723bc68cf9fb3fb6d7ee2a7a617/clippy_lints%2Fsrc%2Fmethods%2Ffilter_map_flat_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/029777f029984723bc68cf9fb3fb6d7ee2a7a617/clippy_lints%2Fsrc%2Fmethods%2Ffilter_map_flat_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Ffilter_map_flat_map.rs?ref=029777f029984723bc68cf9fb3fb6d7ee2a7a617", "patch": "@@ -7,12 +7,7 @@ use rustc_span::sym;\n use super::FILTER_MAP;\n \n /// lint use of `filter_map().flat_map()` for `Iterators`\n-pub(super) fn check<'tcx>(\n-    cx: &LateContext<'tcx>,\n-    expr: &'tcx hir::Expr<'_>,\n-    _filter_args: &'tcx [hir::Expr<'_>],\n-    _map_args: &'tcx [hir::Expr<'_>],\n-) {\n+pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n     // lint if caller of `.filter_map().flat_map()` is an Iterator\n     if is_trait_method(cx, expr, sym::Iterator) {\n         let msg = \"called `filter_map(..).flat_map(..)` on an `Iterator`\";"}, {"sha": "713bbf258370d9ac08b1cf67d288e173abe4dd14", "filename": "clippy_lints/src/methods/filter_map_map.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/029777f029984723bc68cf9fb3fb6d7ee2a7a617/clippy_lints%2Fsrc%2Fmethods%2Ffilter_map_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/029777f029984723bc68cf9fb3fb6d7ee2a7a617/clippy_lints%2Fsrc%2Fmethods%2Ffilter_map_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Ffilter_map_map.rs?ref=029777f029984723bc68cf9fb3fb6d7ee2a7a617", "patch": "@@ -7,12 +7,7 @@ use rustc_span::sym;\n use super::FILTER_MAP;\n \n /// lint use of `filter_map().map()` for `Iterators`\n-pub(super) fn check<'tcx>(\n-    cx: &LateContext<'tcx>,\n-    expr: &'tcx hir::Expr<'_>,\n-    _filter_args: &'tcx [hir::Expr<'_>],\n-    _map_args: &'tcx [hir::Expr<'_>],\n-) {\n+pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n     // lint if caller of `.filter_map().map()` is an Iterator\n     if is_trait_method(cx, expr, sym::Iterator) {\n         let msg = \"called `filter_map(..).map(..)` on an `Iterator`\";"}, {"sha": "15cf567431387c3e0c57aefb9fac3679a174cd64", "filename": "clippy_lints/src/methods/from_iter_instead_of_collect.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/029777f029984723bc68cf9fb3fb6d7ee2a7a617/clippy_lints%2Fsrc%2Fmethods%2Ffrom_iter_instead_of_collect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/029777f029984723bc68cf9fb3fb6d7ee2a7a617/clippy_lints%2Fsrc%2Fmethods%2Ffrom_iter_instead_of_collect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Ffrom_iter_instead_of_collect.rs?ref=029777f029984723bc68cf9fb3fb6d7ee2a7a617", "patch": "@@ -1,20 +1,22 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::ty::implements_trait;\n-use clippy_utils::{get_trait_def_id, paths, sugg};\n+use clippy_utils::{get_trait_def_id, match_qpath, paths, sugg};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n+use rustc_hir::ExprKind;\n use rustc_lint::{LateContext, LintContext};\n use rustc_middle::ty::Ty;\n use rustc_span::sym;\n \n use super::FROM_ITER_INSTEAD_OF_COLLECT;\n \n-pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, args: &[hir::Expr<'_>]) {\n-    let ty = cx.typeck_results().expr_ty(expr);\n-    let arg_ty = cx.typeck_results().expr_ty(&args[0]);\n-\n+pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, args: &[hir::Expr<'_>], func_kind: &ExprKind<'_>) {\n     if_chain! {\n+        if let hir::ExprKind::Path(path) = func_kind;\n+        if match_qpath(path, &[\"from_iter\"]);\n+        let ty = cx.typeck_results().expr_ty(expr);\n+        let arg_ty = cx.typeck_results().expr_ty(&args[0]);\n         if let Some(from_iter_id) = get_trait_def_id(cx, &paths::FROM_ITERATOR);\n         if let Some(iter_id) = cx.tcx.get_diagnostic_item(sym::Iterator);\n "}, {"sha": "b3a9743c61475d6ddba26d563bfae6dbbcffa291", "filename": "clippy_lints/src/methods/get_unwrap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/029777f029984723bc68cf9fb3fb6d7ee2a7a617/clippy_lints%2Fsrc%2Fmethods%2Fget_unwrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/029777f029984723bc68cf9fb3fb6d7ee2a7a617/clippy_lints%2Fsrc%2Fmethods%2Fget_unwrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fget_unwrap.rs?ref=029777f029984723bc68cf9fb3fb6d7ee2a7a617", "patch": "@@ -1,4 +1,4 @@\n-use crate::methods::derefs_to_slice;\n+use super::utils::derefs_to_slice;\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::snippet_with_applicability;\n use clippy_utils::ty::{is_type_diagnostic_item, match_type};"}, {"sha": "950ec62c9fe4f107199ae675cde17a98f7dfaa63", "filename": "clippy_lints/src/methods/inefficient_to_string.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/029777f029984723bc68cf9fb3fb6d7ee2a7a617/clippy_lints%2Fsrc%2Fmethods%2Finefficient_to_string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/029777f029984723bc68cf9fb3fb6d7ee2a7a617/clippy_lints%2Fsrc%2Fmethods%2Finefficient_to_string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Finefficient_to_string.rs?ref=029777f029984723bc68cf9fb3fb6d7ee2a7a617", "patch": "@@ -1,4 +1,3 @@\n-use super::INEFFICIENT_TO_STRING;\n use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::source::snippet_with_applicability;\n use clippy_utils::ty::{is_type_diagnostic_item, walk_ptrs_ty_depth};\n@@ -8,14 +7,18 @@ use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_lint::LateContext;\n use rustc_middle::ty::{self, Ty};\n-use rustc_span::sym;\n+use rustc_span::symbol::{sym, Symbol};\n+\n+use super::INEFFICIENT_TO_STRING;\n \n /// Checks for the `INEFFICIENT_TO_STRING` lint\n-pub fn check<'tcx>(cx: &LateContext<'tcx>, expr: &hir::Expr<'_>, arg: &hir::Expr<'_>, arg_ty: Ty<'tcx>) {\n+pub fn check<'tcx>(cx: &LateContext<'tcx>, expr: &hir::Expr<'_>, method_name: Symbol, args: &[hir::Expr<'_>]) {\n     if_chain! {\n+        if args.len() == 1 && method_name == sym!(to_string);\n         if let Some(to_string_meth_did) = cx.typeck_results().type_dependent_def_id(expr.hir_id);\n         if match_def_path(cx, to_string_meth_did, &paths::TO_STRING_METHOD);\n         if let Some(substs) = cx.typeck_results().node_substs_opt(expr.hir_id);\n+        let arg_ty = cx.typeck_results().expr_ty_adjusted(&args[0]);\n         let self_ty = substs.type_at(0);\n         let (deref_self_ty, deref_count) = walk_ptrs_ty_depth(self_ty);\n         if deref_count >= 1;\n@@ -32,7 +35,7 @@ pub fn check<'tcx>(cx: &LateContext<'tcx>, expr: &hir::Expr<'_>, arg: &hir::Expr\n                         self_ty, deref_self_ty\n                     ));\n                     let mut applicability = Applicability::MachineApplicable;\n-                    let arg_snippet = snippet_with_applicability(cx, arg.span, \"..\", &mut applicability);\n+                    let arg_snippet = snippet_with_applicability(cx, args[0].span, \"..\", &mut applicability);\n                     diag.span_suggestion(\n                         expr.span,\n                         \"try dereferencing the receiver\","}, {"sha": "da13b4ba37a562f6c06d2e39714cb3a90a8e0278", "filename": "clippy_lints/src/methods/into_iter_on_ref.rs", "status": "modified", "additions": 30, "deletions": 19, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/029777f029984723bc68cf9fb3fb6d7ee2a7a617/clippy_lints%2Fsrc%2Fmethods%2Finto_iter_on_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/029777f029984723bc68cf9fb3fb6d7ee2a7a617/clippy_lints%2Fsrc%2Fmethods%2Finto_iter_on_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Finto_iter_on_ref.rs?ref=029777f029984723bc68cf9fb3fb6d7ee2a7a617", "patch": "@@ -1,32 +1,43 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::is_trait_method;\n use clippy_utils::ty::has_iter_method;\n-use clippy_utils::{match_trait_method, paths};\n+use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_lint::LateContext;\n use rustc_middle::ty::{self, Ty};\n use rustc_span::source_map::Span;\n-use rustc_span::symbol::Symbol;\n+use rustc_span::symbol::{sym, Symbol};\n \n use super::INTO_ITER_ON_REF;\n \n-pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, self_ref_ty: Ty<'_>, method_span: Span) {\n-    if !match_trait_method(cx, expr, &paths::INTO_ITERATOR) {\n-        return;\n-    }\n-    if let Some((kind, method_name)) = ty_has_iter_method(cx, self_ref_ty) {\n-        span_lint_and_sugg(\n-            cx,\n-            INTO_ITER_ON_REF,\n-            method_span,\n-            &format!(\n-                \"this `.into_iter()` call is equivalent to `.{}()` and will not consume the `{}`\",\n-                method_name, kind,\n-            ),\n-            \"call directly\",\n-            method_name.to_string(),\n-            Applicability::MachineApplicable,\n-        );\n+pub(super) fn check(\n+    cx: &LateContext<'_>,\n+    expr: &hir::Expr<'_>,\n+    method_span: Span,\n+    method_name: Symbol,\n+    args: &[hir::Expr<'_>],\n+) {\n+    let self_ty = cx.typeck_results().expr_ty_adjusted(&args[0]);\n+    if_chain! {\n+        if let ty::Ref(..) = self_ty.kind();\n+        if method_name == sym::into_iter;\n+        if is_trait_method(cx, expr, sym::IntoIterator);\n+        if let Some((kind, method_name)) = ty_has_iter_method(cx, self_ty);\n+        then {\n+            span_lint_and_sugg(\n+                cx,\n+                INTO_ITER_ON_REF,\n+                method_span,\n+                &format!(\n+                    \"this `.into_iter()` call is equivalent to `.{}()` and will not consume the `{}`\",\n+                    method_name, kind,\n+                ),\n+                \"call directly\",\n+                method_name.to_string(),\n+                Applicability::MachineApplicable,\n+            );\n+        }\n     }\n }\n "}, {"sha": "848f47e39f6b48e1ae8e4eda297506f21f98aa96", "filename": "clippy_lints/src/methods/iter_cloned_collect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/029777f029984723bc68cf9fb3fb6d7ee2a7a617/clippy_lints%2Fsrc%2Fmethods%2Fiter_cloned_collect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/029777f029984723bc68cf9fb3fb6d7ee2a7a617/clippy_lints%2Fsrc%2Fmethods%2Fiter_cloned_collect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fiter_cloned_collect.rs?ref=029777f029984723bc68cf9fb3fb6d7ee2a7a617", "patch": "@@ -1,4 +1,4 @@\n-use crate::methods::derefs_to_slice;\n+use crate::methods::utils::derefs_to_slice;\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::ty::is_type_diagnostic_item;\n use if_chain::if_chain;"}, {"sha": "e394a8fe8195e6da741e818843ac79ae3653de09", "filename": "clippy_lints/src/methods/iter_count.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/029777f029984723bc68cf9fb3fb6d7ee2a7a617/clippy_lints%2Fsrc%2Fmethods%2Fiter_count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/029777f029984723bc68cf9fb3fb6d7ee2a7a617/clippy_lints%2Fsrc%2Fmethods%2Fiter_count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fiter_count.rs?ref=029777f029984723bc68cf9fb3fb6d7ee2a7a617", "patch": "@@ -1,4 +1,4 @@\n-use crate::methods::derefs_to_slice;\n+use super::utils::derefs_to_slice;\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::paths;\n use clippy_utils::source::snippet_with_applicability;"}, {"sha": "e9b37b6f2bd9360f715a0d5b8a7a4215546a8286", "filename": "clippy_lints/src/methods/iter_next_slice.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/029777f029984723bc68cf9fb3fb6d7ee2a7a617/clippy_lints%2Fsrc%2Fmethods%2Fiter_next_slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/029777f029984723bc68cf9fb3fb6d7ee2a7a617/clippy_lints%2Fsrc%2Fmethods%2Fiter_next_slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fiter_next_slice.rs?ref=029777f029984723bc68cf9fb3fb6d7ee2a7a617", "patch": "@@ -1,4 +1,4 @@\n-use crate::methods::derefs_to_slice;\n+use super::utils::derefs_to_slice;\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::snippet_with_applicability;\n use clippy_utils::ty::is_type_diagnostic_item;\n@@ -47,12 +47,7 @@ pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>, ite\n                 );\n             }\n         }\n-    } else if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(caller_expr), sym::vec_type)\n-        || matches!(\n-            &cx.typeck_results().expr_ty(caller_expr).peel_refs().kind(),\n-            ty::Array(_, _)\n-        )\n-    {\n+    } else if is_vec_or_array(cx, caller_expr) {\n         // caller is a Vec or an Array\n         let mut applicability = Applicability::MachineApplicable;\n         span_lint_and_sugg(\n@@ -69,3 +64,8 @@ pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>, ite\n         );\n     }\n }\n+\n+fn is_vec_or_array<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) -> bool {\n+    is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(expr), sym::vec_type)\n+        || matches!(&cx.typeck_results().expr_ty(expr).peel_refs().kind(), ty::Array(_, _))\n+}"}, {"sha": "c46af427b3c67e1a3aed4245eddce33a010b8749", "filename": "clippy_lints/src/methods/iter_nth.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/029777f029984723bc68cf9fb3fb6d7ee2a7a617/clippy_lints%2Fsrc%2Fmethods%2Fiter_nth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/029777f029984723bc68cf9fb3fb6d7ee2a7a617/clippy_lints%2Fsrc%2Fmethods%2Fiter_nth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fiter_nth.rs?ref=029777f029984723bc68cf9fb3fb6d7ee2a7a617", "patch": "@@ -1,4 +1,4 @@\n-use crate::methods::derefs_to_slice;\n+use super::utils::derefs_to_slice;\n use crate::methods::iter_nth_zero;\n use clippy_utils::diagnostics::span_lint_and_help;\n use clippy_utils::ty::is_type_diagnostic_item;"}, {"sha": "b1d398876d3a5ebda1c57599363bf5b048a0d4f9", "filename": "clippy_lints/src/methods/iter_skip_next.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/029777f029984723bc68cf9fb3fb6d7ee2a7a617/clippy_lints%2Fsrc%2Fmethods%2Fiter_skip_next.rs", "raw_url": "https://github.com/rust-lang/rust/raw/029777f029984723bc68cf9fb3fb6d7ee2a7a617/clippy_lints%2Fsrc%2Fmethods%2Fiter_skip_next.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fiter_skip_next.rs?ref=029777f029984723bc68cf9fb3fb6d7ee2a7a617", "patch": "@@ -12,14 +12,13 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, skip_args: &[hir\n     // lint if caller of skip is an Iterator\n     if is_trait_method(cx, expr, sym::Iterator) {\n         if let [caller, n] = skip_args {\n-            let hint = format!(\".nth({})\", snippet(cx, n.span, \"..\"));\n             span_lint_and_sugg(\n                 cx,\n                 ITER_SKIP_NEXT,\n                 expr.span.trim_start(caller.span).unwrap(),\n                 \"called `skip(..).next()` on an iterator\",\n                 \"use `nth` instead\",\n-                hint,\n+                format!(\".nth({})\", snippet(cx, n.span, \"..\")),\n                 Applicability::MachineApplicable,\n             );\n         }"}, {"sha": "b37d744269e7314d503d9c55079b556300553fc3", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 27, "deletions": 227, "changes": 254, "blob_url": "https://github.com/rust-lang/rust/blob/029777f029984723bc68cf9fb3fb6d7ee2a7a617/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/029777f029984723bc68cf9fb3fb6d7ee2a7a617/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=029777f029984723bc68cf9fb3fb6d7ee2a7a617", "patch": "@@ -1,5 +1,11 @@\n mod bind_instead_of_map;\n mod bytes_nth;\n+mod chars_cmp;\n+mod chars_cmp_with_unwrap;\n+mod chars_last_cmp;\n+mod chars_last_cmp_with_unwrap;\n+mod chars_next_cmp;\n+mod chars_next_cmp_with_unwrap;\n mod clone_on_copy;\n mod clone_on_ref_ptr;\n mod expect_fun_call;\n@@ -36,6 +42,7 @@ mod option_map_or_none;\n mod option_map_unwrap_or;\n mod or_fun_call;\n mod search_is_some;\n+mod single_char_add_str;\n mod single_char_insert_string;\n mod single_char_pattern;\n mod single_char_push_string;\n@@ -48,23 +55,21 @@ mod unnecessary_fold;\n mod unnecessary_lazy_eval;\n mod unwrap_used;\n mod useless_asref;\n+mod utils;\n mod wrong_self_convention;\n mod zst_offset;\n \n use bind_instead_of_map::BindInsteadOfMap;\n-use clippy_utils::diagnostics::{span_lint, span_lint_and_help, span_lint_and_sugg};\n-use clippy_utils::source::snippet_with_applicability;\n+use clippy_utils::diagnostics::{span_lint, span_lint_and_help};\n use clippy_utils::ty::{contains_ty, implements_trait, is_copy, is_type_diagnostic_item};\n use clippy_utils::{\n-    contains_return, get_trait_def_id, in_macro, iter_input_pats, match_def_path, match_qpath, method_calls,\n-    method_chain_args, paths, return_ty, single_segment_path, SpanlessEq,\n+    contains_return, get_trait_def_id, in_macro, iter_input_pats, match_qpath, method_calls, paths, return_ty,\n+    SpanlessEq,\n };\n use if_chain::if_chain;\n-use rustc_ast::ast;\n-use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_hir::{TraitItem, TraitItemKind};\n-use rustc_lint::{LateContext, LateLintPass, Lint, LintContext};\n+use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::lint::in_external_macro;\n use rustc_middle::ty::{self, TraitRef, Ty, TyS};\n use rustc_semver::RustcVersion;\n@@ -1718,11 +1723,11 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n             [\"next\", \"skip_while\"] => skip_while_next::check(cx, expr, arg_lists[1]),\n             [\"next\", \"iter\"] => iter_next_slice::check(cx, expr, arg_lists[1]),\n             [\"map\", \"filter\"] => filter_map::check(cx, expr, false),\n-            [\"map\", \"filter_map\"] => filter_map_map::check(cx, expr, arg_lists[1], arg_lists[0]),\n+            [\"map\", \"filter_map\"] => filter_map_map::check(cx, expr),\n             [\"next\", \"filter_map\"] => filter_map_next::check(cx, expr, arg_lists[1], self.msrv.as_ref()),\n             [\"map\", \"find\"] => filter_map::check(cx, expr, true),\n-            [\"flat_map\", \"filter\"] => filter_flat_map::check(cx, expr, arg_lists[1], arg_lists[0]),\n-            [\"flat_map\", \"filter_map\"] => filter_map_flat_map::check(cx, expr, arg_lists[1], arg_lists[0]),\n+            [\"flat_map\", \"filter\"] => filter_flat_map::check(cx, expr),\n+            [\"flat_map\", \"filter_map\"] => filter_map_flat_map::check(cx, expr),\n             [\"flat_map\", ..] => flat_map_identity::check(cx, expr, arg_lists[0], method_spans[0]),\n             [\"flatten\", \"map\"] => map_flatten::check(cx, expr, arg_lists[1]),\n             [option_check_method, \"find\"] if \"is_some\" == *option_check_method || \"is_none\" == *option_check_method => {\n@@ -1809,46 +1814,17 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n \n         match expr.kind {\n             hir::ExprKind::Call(ref func, ref args) => {\n-                if let hir::ExprKind::Path(path) = &func.kind {\n-                    if match_qpath(path, &[\"from_iter\"]) {\n-                        from_iter_instead_of_collect::check(cx, expr, args);\n-                    }\n-                }\n+                from_iter_instead_of_collect::check(cx, expr, args, &func.kind);\n             },\n             hir::ExprKind::MethodCall(ref method_call, ref method_span, ref args, _) => {\n                 or_fun_call::check(cx, expr, *method_span, &method_call.ident.as_str(), args);\n                 expect_fun_call::check(cx, expr, *method_span, &method_call.ident.as_str(), args);\n-\n-                let self_ty = cx.typeck_results().expr_ty_adjusted(&args[0]);\n-                if args.len() == 1 && method_call.ident.name == sym::clone {\n-                    clone_on_copy::check(cx, expr, &args[0], self_ty);\n-                    clone_on_ref_ptr::check(cx, expr, &args[0]);\n-                }\n-                if args.len() == 1 && method_call.ident.name == sym!(to_string) {\n-                    inefficient_to_string::check(cx, expr, &args[0], self_ty);\n-                }\n-\n-                if let Some(fn_def_id) = cx.typeck_results().type_dependent_def_id(expr.hir_id) {\n-                    if match_def_path(cx, fn_def_id, &paths::PUSH_STR) {\n-                        single_char_push_string::check(cx, expr, args);\n-                    } else if match_def_path(cx, fn_def_id, &paths::INSERT_STR) {\n-                        single_char_insert_string::check(cx, expr, args);\n-                    }\n-                }\n-\n-                match self_ty.kind() {\n-                    ty::Ref(_, ty, _) if *ty.kind() == ty::Str => {\n-                        for &(method, pos) in &PATTERN_METHODS {\n-                            if method_call.ident.name.as_str() == method && args.len() > pos {\n-                                single_char_pattern::check(cx, expr, &args[pos]);\n-                            }\n-                        }\n-                    },\n-                    ty::Ref(..) if method_call.ident.name == sym::into_iter => {\n-                        into_iter_on_ref::check(cx, expr, self_ty, *method_span);\n-                    },\n-                    _ => (),\n-                }\n+                clone_on_copy::check(cx, expr, method_call.ident.name, args);\n+                clone_on_ref_ptr::check(cx, expr, method_call.ident.name, args);\n+                inefficient_to_string::check(cx, expr, method_call.ident.name, args);\n+                single_char_add_str::check(cx, expr, args);\n+                into_iter_on_ref::check(cx, expr, *method_span, method_call.ident.name, args);\n+                single_char_pattern::check(cx, expr, method_call.ident.name, args);\n             },\n             hir::ExprKind::Binary(op, ref lhs, ref rhs)\n                 if op.node == hir::BinOpKind::Eq || op.node == hir::BinOpKind::Ne =>\n@@ -2015,47 +1991,6 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n \n     extract_msrv_attr!(LateContext);\n }\n-\n-fn derefs_to_slice<'tcx>(\n-    cx: &LateContext<'tcx>,\n-    expr: &'tcx hir::Expr<'tcx>,\n-    ty: Ty<'tcx>,\n-) -> Option<&'tcx hir::Expr<'tcx>> {\n-    fn may_slice<'a>(cx: &LateContext<'a>, ty: Ty<'a>) -> bool {\n-        match ty.kind() {\n-            ty::Slice(_) => true,\n-            ty::Adt(def, _) if def.is_box() => may_slice(cx, ty.boxed_ty()),\n-            ty::Adt(..) => is_type_diagnostic_item(cx, ty, sym::vec_type),\n-            ty::Array(_, size) => size\n-                .try_eval_usize(cx.tcx, cx.param_env)\n-                .map_or(false, |size| size < 32),\n-            ty::Ref(_, inner, _) => may_slice(cx, inner),\n-            _ => false,\n-        }\n-    }\n-\n-    if let hir::ExprKind::MethodCall(ref path, _, ref args, _) = expr.kind {\n-        if path.ident.name == sym::iter && may_slice(cx, cx.typeck_results().expr_ty(&args[0])) {\n-            Some(&args[0])\n-        } else {\n-            None\n-        }\n-    } else {\n-        match ty.kind() {\n-            ty::Slice(_) => Some(expr),\n-            ty::Adt(def, _) if def.is_box() && may_slice(cx, ty.boxed_ty()) => Some(expr),\n-            ty::Ref(_, inner, _) => {\n-                if may_slice(cx, inner) {\n-                    Some(expr)\n-                } else {\n-                    None\n-                }\n-            },\n-            _ => None,\n-        }\n-    }\n-}\n-\n /// Used for `lint_binary_expr_with_method_call`.\n #[derive(Copy, Clone)]\n struct BinaryExprInfo<'a> {\n@@ -2068,7 +2003,7 @@ struct BinaryExprInfo<'a> {\n /// Checks for the `CHARS_NEXT_CMP` and `CHARS_LAST_CMP` lints.\n fn lint_binary_expr_with_method_call(cx: &LateContext<'_>, info: &mut BinaryExprInfo<'_>) {\n     macro_rules! lint_with_both_lhs_and_rhs {\n-        ($func:ident, $cx:expr, $info:ident) => {\n+        ($func:expr, $cx:expr, $info:ident) => {\n             if !$func($cx, $info) {\n                 ::std::mem::swap(&mut $info.chain, &mut $info.other);\n                 if $func($cx, $info) {\n@@ -2078,145 +2013,10 @@ fn lint_binary_expr_with_method_call(cx: &LateContext<'_>, info: &mut BinaryExpr\n         };\n     }\n \n-    lint_with_both_lhs_and_rhs!(lint_chars_next_cmp, cx, info);\n-    lint_with_both_lhs_and_rhs!(lint_chars_last_cmp, cx, info);\n-    lint_with_both_lhs_and_rhs!(lint_chars_next_cmp_with_unwrap, cx, info);\n-    lint_with_both_lhs_and_rhs!(lint_chars_last_cmp_with_unwrap, cx, info);\n-}\n-\n-/// Wrapper fn for `CHARS_NEXT_CMP` and `CHARS_LAST_CMP` lints.\n-fn lint_chars_cmp(\n-    cx: &LateContext<'_>,\n-    info: &BinaryExprInfo<'_>,\n-    chain_methods: &[&str],\n-    lint: &'static Lint,\n-    suggest: &str,\n-) -> bool {\n-    if_chain! {\n-        if let Some(args) = method_chain_args(info.chain, chain_methods);\n-        if let hir::ExprKind::Call(ref fun, ref arg_char) = info.other.kind;\n-        if arg_char.len() == 1;\n-        if let hir::ExprKind::Path(ref qpath) = fun.kind;\n-        if let Some(segment) = single_segment_path(qpath);\n-        if segment.ident.name == sym::Some;\n-        then {\n-            let mut applicability = Applicability::MachineApplicable;\n-            let self_ty = cx.typeck_results().expr_ty_adjusted(&args[0][0]).peel_refs();\n-\n-            if *self_ty.kind() != ty::Str {\n-                return false;\n-            }\n-\n-            span_lint_and_sugg(\n-                cx,\n-                lint,\n-                info.expr.span,\n-                &format!(\"you should use the `{}` method\", suggest),\n-                \"like this\",\n-                format!(\"{}{}.{}({})\",\n-                        if info.eq { \"\" } else { \"!\" },\n-                        snippet_with_applicability(cx, args[0][0].span, \"..\", &mut applicability),\n-                        suggest,\n-                        snippet_with_applicability(cx, arg_char[0].span, \"..\", &mut applicability)),\n-                applicability,\n-            );\n-\n-            return true;\n-        }\n-    }\n-\n-    false\n-}\n-\n-/// Checks for the `CHARS_NEXT_CMP` lint.\n-fn lint_chars_next_cmp<'tcx>(cx: &LateContext<'tcx>, info: &BinaryExprInfo<'_>) -> bool {\n-    lint_chars_cmp(cx, info, &[\"chars\", \"next\"], CHARS_NEXT_CMP, \"starts_with\")\n-}\n-\n-/// Checks for the `CHARS_LAST_CMP` lint.\n-fn lint_chars_last_cmp<'tcx>(cx: &LateContext<'tcx>, info: &BinaryExprInfo<'_>) -> bool {\n-    if lint_chars_cmp(cx, info, &[\"chars\", \"last\"], CHARS_LAST_CMP, \"ends_with\") {\n-        true\n-    } else {\n-        lint_chars_cmp(cx, info, &[\"chars\", \"next_back\"], CHARS_LAST_CMP, \"ends_with\")\n-    }\n-}\n-\n-/// Wrapper fn for `CHARS_NEXT_CMP` and `CHARS_LAST_CMP` lints with `unwrap()`.\n-fn lint_chars_cmp_with_unwrap<'tcx>(\n-    cx: &LateContext<'tcx>,\n-    info: &BinaryExprInfo<'_>,\n-    chain_methods: &[&str],\n-    lint: &'static Lint,\n-    suggest: &str,\n-) -> bool {\n-    if_chain! {\n-        if let Some(args) = method_chain_args(info.chain, chain_methods);\n-        if let hir::ExprKind::Lit(ref lit) = info.other.kind;\n-        if let ast::LitKind::Char(c) = lit.node;\n-        then {\n-            let mut applicability = Applicability::MachineApplicable;\n-            span_lint_and_sugg(\n-                cx,\n-                lint,\n-                info.expr.span,\n-                &format!(\"you should use the `{}` method\", suggest),\n-                \"like this\",\n-                format!(\"{}{}.{}('{}')\",\n-                        if info.eq { \"\" } else { \"!\" },\n-                        snippet_with_applicability(cx, args[0][0].span, \"..\", &mut applicability),\n-                        suggest,\n-                        c),\n-                applicability,\n-            );\n-\n-            true\n-        } else {\n-            false\n-        }\n-    }\n-}\n-\n-/// Checks for the `CHARS_NEXT_CMP` lint with `unwrap()`.\n-fn lint_chars_next_cmp_with_unwrap<'tcx>(cx: &LateContext<'tcx>, info: &BinaryExprInfo<'_>) -> bool {\n-    lint_chars_cmp_with_unwrap(cx, info, &[\"chars\", \"next\", \"unwrap\"], CHARS_NEXT_CMP, \"starts_with\")\n-}\n-\n-/// Checks for the `CHARS_LAST_CMP` lint with `unwrap()`.\n-fn lint_chars_last_cmp_with_unwrap<'tcx>(cx: &LateContext<'tcx>, info: &BinaryExprInfo<'_>) -> bool {\n-    if lint_chars_cmp_with_unwrap(cx, info, &[\"chars\", \"last\", \"unwrap\"], CHARS_LAST_CMP, \"ends_with\") {\n-        true\n-    } else {\n-        lint_chars_cmp_with_unwrap(cx, info, &[\"chars\", \"next_back\", \"unwrap\"], CHARS_LAST_CMP, \"ends_with\")\n-    }\n-}\n-\n-fn get_hint_if_single_char_arg(\n-    cx: &LateContext<'_>,\n-    arg: &hir::Expr<'_>,\n-    applicability: &mut Applicability,\n-) -> Option<String> {\n-    if_chain! {\n-        if let hir::ExprKind::Lit(lit) = &arg.kind;\n-        if let ast::LitKind::Str(r, style) = lit.node;\n-        let string = r.as_str();\n-        if string.chars().count() == 1;\n-        then {\n-            let snip = snippet_with_applicability(cx, arg.span, &string, applicability);\n-            let ch = if let ast::StrStyle::Raw(nhash) = style {\n-                let nhash = nhash as usize;\n-                // for raw string: r##\"a\"##\n-                &snip[(nhash + 2)..(snip.len() - 1 - nhash)]\n-            } else {\n-                // for regular string: \"a\"\n-                &snip[1..(snip.len() - 1)]\n-            };\n-            let hint = format!(\"'{}'\", if ch == \"'\" { \"\\\\'\" } else { ch });\n-            Some(hint)\n-        } else {\n-            None\n-        }\n-    }\n+    lint_with_both_lhs_and_rhs!(chars_next_cmp::check, cx, info);\n+    lint_with_both_lhs_and_rhs!(chars_last_cmp::check, cx, info);\n+    lint_with_both_lhs_and_rhs!(chars_next_cmp_with_unwrap::check, cx, info);\n+    lint_with_both_lhs_and_rhs!(chars_last_cmp_with_unwrap::check, cx, info);\n }\n \n const FN_HEADER: hir::FnHeader = hir::FnHeader {"}, {"sha": "9a5fabcf7cd5064e9ef86af014f83882ae6e5d09", "filename": "clippy_lints/src/methods/single_char_add_str.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/029777f029984723bc68cf9fb3fb6d7ee2a7a617/clippy_lints%2Fsrc%2Fmethods%2Fsingle_char_add_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/029777f029984723bc68cf9fb3fb6d7ee2a7a617/clippy_lints%2Fsrc%2Fmethods%2Fsingle_char_add_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fsingle_char_add_str.rs?ref=029777f029984723bc68cf9fb3fb6d7ee2a7a617", "patch": "@@ -0,0 +1,14 @@\n+use crate::methods::{single_char_insert_string, single_char_push_string};\n+use clippy_utils::{match_def_path, paths};\n+use rustc_hir as hir;\n+use rustc_lint::LateContext;\n+\n+pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, args: &[hir::Expr<'_>]) {\n+    if let Some(fn_def_id) = cx.typeck_results().type_dependent_def_id(expr.hir_id) {\n+        if match_def_path(cx, fn_def_id, &paths::PUSH_STR) {\n+            single_char_push_string::check(cx, expr, args);\n+        } else if match_def_path(cx, fn_def_id, &paths::INSERT_STR) {\n+            single_char_insert_string::check(cx, expr, args);\n+        }\n+    }\n+}"}, {"sha": "6cdc954c03be15ea38f0f15e587104e09ea61a78", "filename": "clippy_lints/src/methods/single_char_insert_string.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/029777f029984723bc68cf9fb3fb6d7ee2a7a617/clippy_lints%2Fsrc%2Fmethods%2Fsingle_char_insert_string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/029777f029984723bc68cf9fb3fb6d7ee2a7a617/clippy_lints%2Fsrc%2Fmethods%2Fsingle_char_insert_string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fsingle_char_insert_string.rs?ref=029777f029984723bc68cf9fb3fb6d7ee2a7a617", "patch": "@@ -1,4 +1,4 @@\n-use crate::methods::get_hint_if_single_char_arg;\n+use super::utils::get_hint_if_single_char_arg;\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::snippet_with_applicability;\n use rustc_errors::Applicability;"}, {"sha": "f4090c7c617d4499c07cc79b6c3bcd5030f43ef4", "filename": "clippy_lints/src/methods/single_char_pattern.rs", "status": "modified", "additions": 25, "deletions": 13, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/029777f029984723bc68cf9fb3fb6d7ee2a7a617/clippy_lints%2Fsrc%2Fmethods%2Fsingle_char_pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/029777f029984723bc68cf9fb3fb6d7ee2a7a617/clippy_lints%2Fsrc%2Fmethods%2Fsingle_char_pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fsingle_char_pattern.rs?ref=029777f029984723bc68cf9fb3fb6d7ee2a7a617", "patch": "@@ -1,23 +1,35 @@\n-use crate::methods::get_hint_if_single_char_arg;\n+use super::utils::get_hint_if_single_char_arg;\n use clippy_utils::diagnostics::span_lint_and_sugg;\n+use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_lint::LateContext;\n+use rustc_middle::ty;\n+use rustc_span::symbol::Symbol;\n \n use super::SINGLE_CHAR_PATTERN;\n \n /// lint for length-1 `str`s for methods in `PATTERN_METHODS`\n-pub(super) fn check(cx: &LateContext<'_>, _expr: &hir::Expr<'_>, arg: &hir::Expr<'_>) {\n-    let mut applicability = Applicability::MachineApplicable;\n-    if let Some(hint) = get_hint_if_single_char_arg(cx, arg, &mut applicability) {\n-        span_lint_and_sugg(\n-            cx,\n-            SINGLE_CHAR_PATTERN,\n-            arg.span,\n-            \"single-character string constant used as pattern\",\n-            \"try using a `char` instead\",\n-            hint,\n-            applicability,\n-        );\n+pub(super) fn check(cx: &LateContext<'_>, _expr: &hir::Expr<'_>, method_name: Symbol, args: &[hir::Expr<'_>]) {\n+    for &(method, pos) in &crate::methods::PATTERN_METHODS {\n+        if_chain! {\n+            if let ty::Ref(_, ty, _) = cx.typeck_results().expr_ty_adjusted(&args[0]).kind();\n+            if *ty.kind() == ty::Str;\n+            if method_name.as_str() == method && args.len() > pos;\n+            let arg = &args[pos];\n+            let mut applicability = Applicability::MachineApplicable;\n+            if let Some(hint) = get_hint_if_single_char_arg(cx, arg, &mut applicability);\n+            then {\n+                span_lint_and_sugg(\n+                    cx,\n+                    SINGLE_CHAR_PATTERN,\n+                    arg.span,\n+                    \"single-character string constant used as pattern\",\n+                    \"try using a `char` instead\",\n+                    hint,\n+                    applicability,\n+                );\n+            }\n+        }\n     }\n }"}, {"sha": "0237d39cbdb4e767eecba43e99d478dfffd021bb", "filename": "clippy_lints/src/methods/single_char_push_string.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/029777f029984723bc68cf9fb3fb6d7ee2a7a617/clippy_lints%2Fsrc%2Fmethods%2Fsingle_char_push_string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/029777f029984723bc68cf9fb3fb6d7ee2a7a617/clippy_lints%2Fsrc%2Fmethods%2Fsingle_char_push_string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fsingle_char_push_string.rs?ref=029777f029984723bc68cf9fb3fb6d7ee2a7a617", "patch": "@@ -1,4 +1,4 @@\n-use crate::methods::get_hint_if_single_char_arg;\n+use super::utils::get_hint_if_single_char_arg;\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::snippet_with_applicability;\n use rustc_errors::Applicability;"}, {"sha": "5c688ac56211ea45d380206e8f62d7d3adf62272", "filename": "clippy_lints/src/methods/string_extend_chars.rs", "status": "modified", "additions": 29, "deletions": 28, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/029777f029984723bc68cf9fb3fb6d7ee2a7a617/clippy_lints%2Fsrc%2Fmethods%2Fstring_extend_chars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/029777f029984723bc68cf9fb3fb6d7ee2a7a617/clippy_lints%2Fsrc%2Fmethods%2Fstring_extend_chars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fstring_extend_chars.rs?ref=029777f029984723bc68cf9fb3fb6d7ee2a7a617", "patch": "@@ -12,34 +12,35 @@ use super::STRING_EXTEND_CHARS;\n \n pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, args: &[hir::Expr<'_>]) {\n     let obj_ty = cx.typeck_results().expr_ty(&args[0]).peel_refs();\n-    if is_type_diagnostic_item(cx, obj_ty, sym::string_type) {\n-        let arg = &args[1];\n-        if let Some(arglists) = method_chain_args(arg, &[\"chars\"]) {\n-            let target = &arglists[0][0];\n-            let self_ty = cx.typeck_results().expr_ty(target).peel_refs();\n-            let ref_str = if *self_ty.kind() == ty::Str {\n-                \"\"\n-            } else if is_type_diagnostic_item(cx, self_ty, sym::string_type) {\n-                \"&\"\n-            } else {\n-                return;\n-            };\n+    if !is_type_diagnostic_item(cx, obj_ty, sym::string_type) {\n+        return;\n+    }\n+    let arg = &args[1];\n+    if let Some(arglists) = method_chain_args(arg, &[\"chars\"]) {\n+        let target = &arglists[0][0];\n+        let self_ty = cx.typeck_results().expr_ty(target).peel_refs();\n+        let ref_str = if *self_ty.kind() == ty::Str {\n+            \"\"\n+        } else if is_type_diagnostic_item(cx, self_ty, sym::string_type) {\n+            \"&\"\n+        } else {\n+            return;\n+        };\n \n-            let mut applicability = Applicability::MachineApplicable;\n-            span_lint_and_sugg(\n-                cx,\n-                STRING_EXTEND_CHARS,\n-                expr.span,\n-                \"calling `.extend(_.chars())`\",\n-                \"try this\",\n-                format!(\n-                    \"{}.push_str({}{})\",\n-                    snippet_with_applicability(cx, args[0].span, \"..\", &mut applicability),\n-                    ref_str,\n-                    snippet_with_applicability(cx, target.span, \"..\", &mut applicability)\n-                ),\n-                applicability,\n-            );\n-        }\n+        let mut applicability = Applicability::MachineApplicable;\n+        span_lint_and_sugg(\n+            cx,\n+            STRING_EXTEND_CHARS,\n+            expr.span,\n+            \"calling `.extend(_.chars())`\",\n+            \"try this\",\n+            format!(\n+                \"{}.push_str({}{})\",\n+                snippet_with_applicability(cx, args[0].span, \"..\", &mut applicability),\n+                ref_str,\n+                snippet_with_applicability(cx, target.span, \"..\", &mut applicability)\n+            ),\n+            applicability,\n+        );\n     }\n }"}, {"sha": "8de23e1bc6e902d459077f19c29f334e5df99f3d", "filename": "clippy_lints/src/methods/utils.rs", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/029777f029984723bc68cf9fb3fb6d7ee2a7a617/clippy_lints%2Fsrc%2Fmethods%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/029777f029984723bc68cf9fb3fb6d7ee2a7a617/clippy_lints%2Fsrc%2Fmethods%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Futils.rs?ref=029777f029984723bc68cf9fb3fb6d7ee2a7a617", "patch": "@@ -0,0 +1,78 @@\n+use clippy_utils::source::snippet_with_applicability;\n+use clippy_utils::ty::is_type_diagnostic_item;\n+use if_chain::if_chain;\n+use rustc_ast::ast;\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_lint::LateContext;\n+use rustc_middle::ty;\n+use rustc_middle::ty::Ty;\n+use rustc_span::symbol::sym;\n+\n+pub(super) fn derefs_to_slice<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx hir::Expr<'tcx>,\n+    ty: Ty<'tcx>,\n+) -> Option<&'tcx hir::Expr<'tcx>> {\n+    fn may_slice<'a>(cx: &LateContext<'a>, ty: Ty<'a>) -> bool {\n+        match ty.kind() {\n+            ty::Slice(_) => true,\n+            ty::Adt(def, _) if def.is_box() => may_slice(cx, ty.boxed_ty()),\n+            ty::Adt(..) => is_type_diagnostic_item(cx, ty, sym::vec_type),\n+            ty::Array(_, size) => size\n+                .try_eval_usize(cx.tcx, cx.param_env)\n+                .map_or(false, |size| size < 32),\n+            ty::Ref(_, inner, _) => may_slice(cx, inner),\n+            _ => false,\n+        }\n+    }\n+\n+    if let hir::ExprKind::MethodCall(ref path, _, ref args, _) = expr.kind {\n+        if path.ident.name == sym::iter && may_slice(cx, cx.typeck_results().expr_ty(&args[0])) {\n+            Some(&args[0])\n+        } else {\n+            None\n+        }\n+    } else {\n+        match ty.kind() {\n+            ty::Slice(_) => Some(expr),\n+            ty::Adt(def, _) if def.is_box() && may_slice(cx, ty.boxed_ty()) => Some(expr),\n+            ty::Ref(_, inner, _) => {\n+                if may_slice(cx, inner) {\n+                    Some(expr)\n+                } else {\n+                    None\n+                }\n+            },\n+            _ => None,\n+        }\n+    }\n+}\n+\n+pub(super) fn get_hint_if_single_char_arg(\n+    cx: &LateContext<'_>,\n+    arg: &hir::Expr<'_>,\n+    applicability: &mut Applicability,\n+) -> Option<String> {\n+    if_chain! {\n+        if let hir::ExprKind::Lit(lit) = &arg.kind;\n+        if let ast::LitKind::Str(r, style) = lit.node;\n+        let string = r.as_str();\n+        if string.chars().count() == 1;\n+        then {\n+            let snip = snippet_with_applicability(cx, arg.span, &string, applicability);\n+            let ch = if let ast::StrStyle::Raw(nhash) = style {\n+                let nhash = nhash as usize;\n+                // for raw string: r##\"a\"##\n+                &snip[(nhash + 2)..(snip.len() - 1 - nhash)]\n+            } else {\n+                // for regular string: \"a\"\n+                &snip[1..(snip.len() - 1)]\n+            };\n+            let hint = format!(\"'{}'\", if ch == \"'\" { \"\\\\'\" } else { ch });\n+            Some(hint)\n+        } else {\n+            None\n+        }\n+    }\n+}"}]}