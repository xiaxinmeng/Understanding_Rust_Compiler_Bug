{"sha": "f9fe251777e9f1cc557a6d5b82b45403935d0a10", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY5ZmUyNTE3NzdlOWYxY2M1NTdhNmQ1YjgyYjQ1NDAzOTM1ZDBhMTA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-07-10T12:46:30Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-07-10T12:46:30Z"}, "message": "auto merge of #15569 : pcwalton/rust/reexport-intrinsics, r=cmr\n\ncode bloat.\r\n\r\nThis didn't make a difference in any compile times that I saw, but it\r\nfits what we're doing with `transmute` and seems prudent.\r\n\r\nr? @alexcrichton", "tree": {"sha": "d0cecb7fa107443ec40e2ffa784c266fb427014a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d0cecb7fa107443ec40e2ffa784c266fb427014a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f9fe251777e9f1cc557a6d5b82b45403935d0a10", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f9fe251777e9f1cc557a6d5b82b45403935d0a10", "html_url": "https://github.com/rust-lang/rust/commit/f9fe251777e9f1cc557a6d5b82b45403935d0a10", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f9fe251777e9f1cc557a6d5b82b45403935d0a10/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a1bd5d359b8e4ebc1b952f96e4f1d4658bc29b26", "url": "https://api.github.com/repos/rust-lang/rust/commits/a1bd5d359b8e4ebc1b952f96e4f1d4658bc29b26", "html_url": "https://github.com/rust-lang/rust/commit/a1bd5d359b8e4ebc1b952f96e4f1d4658bc29b26"}, {"sha": "6f96abf7389c6a031c549a9df0b672b7989fbe8b", "url": "https://api.github.com/repos/rust-lang/rust/commits/6f96abf7389c6a031c549a9df0b672b7989fbe8b", "html_url": "https://github.com/rust-lang/rust/commit/6f96abf7389c6a031c549a9df0b672b7989fbe8b"}], "stats": {"total": 156, "additions": 67, "deletions": 89}, "files": [{"sha": "002babf7df976dd174a3cb84cc4a1973eb1075b3", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 63, "deletions": 9, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/f9fe251777e9f1cc557a6d5b82b45403935d0a10/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fe251777e9f1cc557a6d5b82b45403935d0a10/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=f9fe251777e9f1cc557a6d5b82b45403935d0a10", "patch": "@@ -326,19 +326,73 @@ extern \"rust-intrinsic\" {\n     /// integer, since the conversion would throw away aliasing information.\n     pub fn offset<T>(dst: *const T, offset: int) -> *const T;\n \n-    /// Equivalent to the appropriate `llvm.memcpy.p0i8.0i8.*` intrinsic, with\n-    /// a size of `count` * `size_of::<T>()` and an alignment of\n-    /// `min_align_of::<T>()`\n+    /// Copies data from one location to another.\n+    ///\n+    /// Copies `count` elements (not bytes) from `src` to `dst`. The source\n+    /// and destination may *not* overlap.\n+    ///\n+    /// `copy_nonoverlapping_memory` is semantically equivalent to C's `memcpy`.\n+    ///\n+    /// # Example\n+    ///\n+    /// A safe swap function:\n+    ///\n+    /// ```\n+    /// use std::mem;\n+    /// use std::ptr;\n+    ///\n+    /// fn swap<T>(x: &mut T, y: &mut T) {\n+    ///     unsafe {\n+    ///         // Give ourselves some scratch space to work with\n+    ///         let mut t: T = mem::uninitialized();\n+    ///\n+    ///         // Perform the swap, `&mut` pointers never alias\n+    ///         ptr::copy_nonoverlapping_memory(&mut t, &*x, 1);\n+    ///         ptr::copy_nonoverlapping_memory(x, &*y, 1);\n+    ///         ptr::copy_nonoverlapping_memory(y, &t, 1);\n+    ///\n+    ///         // y and t now point to the same thing, but we need to completely forget `tmp`\n+    ///         // because it's no longer relevant.\n+    ///         mem::forget(t);\n+    ///     }\n+    /// }\n+    /// ```\n+    ///\n+    /// # Safety Note\n+    ///\n+    /// If the source and destination overlap then the behavior of this\n+    /// function is undefined.\n+    #[unstable]\n     pub fn copy_nonoverlapping_memory<T>(dst: *mut T, src: *const T, count: uint);\n \n-    /// Equivalent to the appropriate `llvm.memmove.p0i8.0i8.*` intrinsic, with\n-    /// a size of `count` * `size_of::<T>()` and an alignment of\n-    /// `min_align_of::<T>()`\n+    /// Copies data from one location to another.\n+    ///\n+    /// Copies `count` elements (not bytes) from `src` to `dst`. The source\n+    /// and destination may overlap.\n+    ///\n+    /// `copy_memory` is semantically equivalent to C's `memmove`.\n+    ///\n+    /// # Example\n+    ///\n+    /// Efficiently create a Rust vector from an unsafe buffer:\n+    ///\n+    /// ```\n+    /// use std::ptr;\n+    ///\n+    /// unsafe fn from_buf_raw<T>(ptr: *const T, elts: uint) -> Vec<T> {\n+    ///     let mut dst = Vec::with_capacity(elts);\n+    ///     dst.set_len(elts);\n+    ///     ptr::copy_memory(dst.as_mut_ptr(), ptr, elts);\n+    ///     dst\n+    /// }\n+    /// ```\n+    ///\n+    #[unstable]\n     pub fn copy_memory<T>(dst: *mut T, src: *const T, count: uint);\n \n-    /// Equivalent to the appropriate `llvm.memset.p0i8.*` intrinsic, with a\n-    /// size of `count` * `size_of::<T>()` and an alignment of\n-    /// `min_align_of::<T>()`\n+    /// Invokes memset on the specified pointer, setting `count * size_of::<T>()`\n+    /// bytes of memory starting at `dst` to `c`.\n+    #[experimental = \"uncertain about naming and semantics\"]\n     pub fn set_memory<T>(dst: *mut T, val: u8, count: uint);\n \n     /// Equivalent to the appropriate `llvm.memcpy.p0i8.0i8.*` intrinsic, with"}, {"sha": "ed1d4d481100b920952b68a3c5ba12a8b16dbe7c", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 4, "deletions": 80, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/f9fe251777e9f1cc557a6d5b82b45403935d0a10/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9fe251777e9f1cc557a6d5b82b45403935d0a10/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=f9fe251777e9f1cc557a6d5b82b45403935d0a10", "patch": "@@ -95,6 +95,10 @@ use option::{Some, None, Option};\n \n use cmp::{PartialEq, Eq, PartialOrd, Equiv, Ordering, Less, Equal, Greater};\n \n+pub use intrinsics::copy_memory;\n+pub use intrinsics::copy_nonoverlapping_memory;\n+pub use intrinsics::set_memory;\n+\n /// Create a null pointer.\n ///\n /// # Example\n@@ -123,86 +127,6 @@ pub fn null<T>() -> *const T { 0 as *const T }\n #[unstable = \"may need a different name after pending changes to pointer types\"]\n pub fn mut_null<T>() -> *mut T { 0 as *mut T }\n \n-/// Copies data from one location to another.\n-///\n-/// Copies `count` elements (not bytes) from `src` to `dst`. The source\n-/// and destination may overlap.\n-///\n-/// `copy_memory` is semantically equivalent to C's `memmove`.\n-///\n-/// # Example\n-///\n-/// Efficiently create a Rust vector from an unsafe buffer:\n-///\n-/// ```\n-/// use std::ptr;\n-///\n-/// unsafe fn from_buf_raw<T>(ptr: *const T, elts: uint) -> Vec<T> {\n-///     let mut dst = Vec::with_capacity(elts);\n-///     dst.set_len(elts);\n-///     ptr::copy_memory(dst.as_mut_ptr(), ptr, elts);\n-///     dst\n-/// }\n-/// ```\n-///\n-#[inline]\n-#[unstable]\n-pub unsafe fn copy_memory<T>(dst: *mut T, src: *const T, count: uint) {\n-    intrinsics::copy_memory(dst, src, count)\n-}\n-\n-/// Copies data from one location to another.\n-///\n-/// Copies `count` elements (not bytes) from `src` to `dst`. The source\n-/// and destination may *not* overlap.\n-///\n-/// `copy_nonoverlapping_memory` is semantically equivalent to C's `memcpy`.\n-///\n-/// # Example\n-///\n-/// A safe swap function:\n-///\n-/// ```\n-/// use std::mem;\n-/// use std::ptr;\n-///\n-/// fn swap<T>(x: &mut T, y: &mut T) {\n-///     unsafe {\n-///         // Give ourselves some scratch space to work with\n-///         let mut t: T = mem::uninitialized();\n-///\n-///         // Perform the swap, `&mut` pointers never alias\n-///         ptr::copy_nonoverlapping_memory(&mut t, &*x, 1);\n-///         ptr::copy_nonoverlapping_memory(x, &*y, 1);\n-///         ptr::copy_nonoverlapping_memory(y, &t, 1);\n-///\n-///         // y and t now point to the same thing, but we need to completely forget `tmp`\n-///         // because it's no longer relevant.\n-///         mem::forget(t);\n-///     }\n-/// }\n-/// ```\n-///\n-/// # Safety Note\n-///\n-/// If the source and destination overlap then the behavior of this\n-/// function is undefined.\n-#[inline]\n-#[unstable]\n-pub unsafe fn copy_nonoverlapping_memory<T>(dst: *mut T,\n-                                            src: *const T,\n-                                            count: uint) {\n-    intrinsics::copy_nonoverlapping_memory(dst, src, count)\n-}\n-\n-/// Invokes memset on the specified pointer, setting `count * size_of::<T>()`\n-/// bytes of memory starting at `dst` to `c`.\n-#[inline]\n-#[experimental = \"uncertain about naming and semantics\"]\n-pub unsafe fn set_memory<T>(dst: *mut T, c: u8, count: uint) {\n-    intrinsics::set_memory(dst, c, count)\n-}\n-\n /// Zeroes out `count * size_of::<T>` bytes of memory at `dst`\n #[inline]\n #[experimental = \"uncertain about naming and semantics\"]"}]}