{"sha": "f5a367c7bb50f74d82c3909d5c961baac879242e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY1YTM2N2M3YmI1MGY3NGQ4MmMzOTA5ZDVjOTYxYmFhYzg3OTI0MmU=", "commit": {"author": {"name": "Steven Malis", "email": "smmalis37@gmail.com", "date": "2018-04-07T22:47:18Z"}, "committer": {"name": "Steven Malis", "email": "smmalis37@gmail.com", "date": "2018-04-07T22:47:18Z"}, "message": "Update based on RangeBounds trait being moved to libcore.", "tree": {"sha": "164bfe56168cb68d817b2155404ba65eabc55e4d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/164bfe56168cb68d817b2155404ba65eabc55e4d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f5a367c7bb50f74d82c3909d5c961baac879242e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f5a367c7bb50f74d82c3909d5c961baac879242e", "html_url": "https://github.com/rust-lang/rust/commit/f5a367c7bb50f74d82c3909d5c961baac879242e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f5a367c7bb50f74d82c3909d5c961baac879242e/comments", "author": {"login": "smmalis37", "id": 4054472, "node_id": "MDQ6VXNlcjQwNTQ0NzI=", "avatar_url": "https://avatars.githubusercontent.com/u/4054472?v=4", "gravatar_id": "", "url": "https://api.github.com/users/smmalis37", "html_url": "https://github.com/smmalis37", "followers_url": "https://api.github.com/users/smmalis37/followers", "following_url": "https://api.github.com/users/smmalis37/following{/other_user}", "gists_url": "https://api.github.com/users/smmalis37/gists{/gist_id}", "starred_url": "https://api.github.com/users/smmalis37/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/smmalis37/subscriptions", "organizations_url": "https://api.github.com/users/smmalis37/orgs", "repos_url": "https://api.github.com/users/smmalis37/repos", "events_url": "https://api.github.com/users/smmalis37/events{/privacy}", "received_events_url": "https://api.github.com/users/smmalis37/received_events", "type": "User", "site_admin": false}, "committer": {"login": "smmalis37", "id": 4054472, "node_id": "MDQ6VXNlcjQwNTQ0NzI=", "avatar_url": "https://avatars.githubusercontent.com/u/4054472?v=4", "gravatar_id": "", "url": "https://api.github.com/users/smmalis37", "html_url": "https://github.com/smmalis37", "followers_url": "https://api.github.com/users/smmalis37/followers", "following_url": "https://api.github.com/users/smmalis37/following{/other_user}", "gists_url": "https://api.github.com/users/smmalis37/gists{/gist_id}", "starred_url": "https://api.github.com/users/smmalis37/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/smmalis37/subscriptions", "organizations_url": "https://api.github.com/users/smmalis37/orgs", "repos_url": "https://api.github.com/users/smmalis37/repos", "events_url": "https://api.github.com/users/smmalis37/events{/privacy}", "received_events_url": "https://api.github.com/users/smmalis37/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "74abffeabb63b17094d1958bf42d6fe1b24907d7", "url": "https://api.github.com/repos/rust-lang/rust/commits/74abffeabb63b17094d1958bf42d6fe1b24907d7", "html_url": "https://github.com/rust-lang/rust/commit/74abffeabb63b17094d1958bf42d6fe1b24907d7"}], "stats": {"total": 87, "additions": 69, "deletions": 18}, "files": [{"sha": "210a0e118d5b3db22d220f1ccb86922ece3cdef6", "filename": "src/libcore/ops/range.rs", "status": "modified", "additions": 63, "deletions": 12, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/f5a367c7bb50f74d82c3909d5c961baac879242e/src%2Flibcore%2Fops%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5a367c7bb50f74d82c3909d5c961baac879242e/src%2Flibcore%2Fops%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Frange.rs?ref=f5a367c7bb50f74d82c3909d5c961baac879242e", "patch": "@@ -109,8 +109,12 @@ impl<Idx: PartialOrd<Idx>> Range<Idx> {\n     /// assert!(!(3..2).contains(3));\n     /// ```\n     #[unstable(feature = \"range_contains\", reason = \"recently added as per RFC\", issue = \"32311\")]\n-    pub fn contains(&self, item: Idx) -> bool {\n-        (self.start <= item) && (item < self.end)\n+    pub fn contains<U>(&self, item: &U) -> bool\n+    where\n+        Idx: PartialOrd<U>,\n+        U: ?Sized,\n+    {\n+        <Self as RangeBounds<Idx>>::contains(self, item)\n     }\n \n     /// Returns `true` if the range contains no items.\n@@ -179,7 +183,6 @@ impl<Idx: fmt::Debug> fmt::Debug for RangeFrom<Idx> {\n     }\n }\n \n-#[unstable(feature = \"range_contains\", reason = \"recently added as per RFC\", issue = \"32311\")]\n impl<Idx: PartialOrd<Idx>> RangeFrom<Idx> {\n     /// Returns `true` if `item` is contained in the range.\n     ///\n@@ -192,8 +195,13 @@ impl<Idx: PartialOrd<Idx>> RangeFrom<Idx> {\n     /// assert!( (3..).contains(3));\n     /// assert!( (3..).contains(1_000_000_000));\n     /// ```\n-    pub fn contains(&self, item: Idx) -> bool {\n-        (self.start <= item)\n+    #[unstable(feature = \"range_contains\", reason = \"recently added as per RFC\", issue = \"32311\")]\n+    pub fn contains<U>(&self, item: &U) -> bool\n+    where\n+        Idx: PartialOrd<U>,\n+        U: ?Sized,\n+    {\n+        <Self as RangeBounds<Idx>>::contains(self, item)\n     }\n }\n \n@@ -250,7 +258,6 @@ impl<Idx: fmt::Debug> fmt::Debug for RangeTo<Idx> {\n     }\n }\n \n-#[unstable(feature = \"range_contains\", reason = \"recently added as per RFC\", issue = \"32311\")]\n impl<Idx: PartialOrd<Idx>> RangeTo<Idx> {\n     /// Returns `true` if `item` is contained in the range.\n     ///\n@@ -263,8 +270,13 @@ impl<Idx: PartialOrd<Idx>> RangeTo<Idx> {\n     /// assert!( (..5).contains(4));\n     /// assert!(!(..5).contains(5));\n     /// ```\n-    pub fn contains(&self, item: Idx) -> bool {\n-        (item < self.end)\n+    #[unstable(feature = \"range_contains\", reason = \"recently added as per RFC\", issue = \"32311\")]\n+    pub fn contains<U>(&self, item: &U) -> bool\n+    where\n+        Idx: PartialOrd<U>,\n+        U: ?Sized,\n+    {\n+        <Self as RangeBounds<Idx>>::contains(self, item)\n     }\n }\n \n@@ -328,8 +340,12 @@ impl<Idx: PartialOrd<Idx>> RangeInclusive<Idx> {\n     /// assert!(!(3..=2).contains(3));\n     /// ```\n     #[unstable(feature = \"range_contains\", reason = \"recently added as per RFC\", issue = \"32311\")]\n-    pub fn contains(&self, item: Idx) -> bool {\n-        self.start <= item && item <= self.end\n+    pub fn contains<U>(&self, item: &U) -> bool\n+    where\n+        Idx: PartialOrd<U>,\n+        U: ?Sized,\n+    {\n+        <Self as RangeBounds<Idx>>::contains(self, item)\n     }\n \n     /// Returns `true` if the range contains no items.\n@@ -435,8 +451,13 @@ impl<Idx: PartialOrd<Idx>> RangeToInclusive<Idx> {\n     /// assert!( (..=5).contains(5));\n     /// assert!(!(..=5).contains(6));\n     /// ```\n-    pub fn contains(&self, item: Idx) -> bool {\n-        (item <= self.end)\n+    #[unstable(feature = \"range_contains\", reason = \"recently added as per RFC\", issue = \"32311\")]\n+    pub fn contains<U>(&self, item: &U) -> bool\n+    where\n+        Idx: PartialOrd<U>,\n+        U: ?Sized,\n+    {\n+        <Self as RangeBounds<Idx>>::contains(self, item)\n     }\n }\n \n@@ -537,6 +558,36 @@ pub trait RangeBounds<T: ?Sized> {\n     /// # }\n     /// ```\n     fn end(&self) -> Bound<&T>;\n+\n+    /// Returns `true` if `item` is contained in the range.\n+    #[unstable(feature = \"range_contains\", reason = \"recently added as per RFC\", issue = \"32311\")]\n+    fn contains<U>(&self, item: &U) -> bool\n+    where\n+        T: PartialOrd<U>,\n+        U: ?Sized,\n+    {\n+        match self.start() {\n+            Included(ref start) => if *start > item {\n+                return false;\n+            },\n+            Excluded(ref start) => if *start >= item {\n+                return false;\n+            },\n+            Unbounded => (),\n+        };\n+\n+        match self.end() {\n+            Included(ref end) => if *end < item  {\n+                return false;\n+            },\n+            Excluded(ref end) => if *end <= item {\n+                return false;\n+            },\n+            Unbounded => (),\n+        }\n+\n+        true\n+    }\n }\n \n use self::Bound::{Excluded, Included, Unbounded};"}, {"sha": "91075ddcfa422ab40d532178204b806371749145", "filename": "src/librustc_errors/emitter.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f5a367c7bb50f74d82c3909d5c961baac879242e/src%2Flibrustc_errors%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5a367c7bb50f74d82c3909d5c961baac879242e/src%2Flibrustc_errors%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Femitter.rs?ref=f5a367c7bb50f74d82c3909d5c961baac879242e", "patch": "@@ -1389,8 +1389,8 @@ fn num_overlap(a_start: usize, a_end: usize, b_start: usize, b_end:usize, inclus\n     } else {\n         0\n     };\n-    (b_start..b_end + extra).contains(a_start) ||\n-    (a_start..a_end + extra).contains(b_start)\n+    (b_start..b_end + extra).contains(&a_start) ||\n+    (a_start..a_end + extra).contains(&b_start)\n }\n fn overlaps(a1: &Annotation, a2: &Annotation, padding: usize) -> bool {\n     num_overlap(a1.start_col, a1.end_col + padding, a2.start_col, a2.end_col, false)"}, {"sha": "0fe6265345de1ecfa7fd6f988dae5fb9acfa42f4", "filename": "src/librustc_mir/borrow_check/nll/universal_regions.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f5a367c7bb50f74d82c3909d5c961baac879242e/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5a367c7bb50f74d82c3909d5c961baac879242e/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs?ref=f5a367c7bb50f74d82c3909d5c961baac879242e", "patch": "@@ -259,18 +259,18 @@ impl<'tcx> UniversalRegions<'tcx> {\n \n     /// True if `r` is a member of this set of universal regions.\n     pub fn is_universal_region(&self, r: RegionVid) -> bool {\n-        (FIRST_GLOBAL_INDEX..self.num_universals).contains(r.index())\n+        (FIRST_GLOBAL_INDEX..self.num_universals).contains(&r.index())\n     }\n \n     /// Classifies `r` as a universal region, returning `None` if this\n     /// is not a member of this set of universal regions.\n     pub fn region_classification(&self, r: RegionVid) -> Option<RegionClassification> {\n         let index = r.index();\n-        if (FIRST_GLOBAL_INDEX..self.first_extern_index).contains(index) {\n+        if (FIRST_GLOBAL_INDEX..self.first_extern_index).contains(&index) {\n             Some(RegionClassification::Global)\n-        } else if (self.first_extern_index..self.first_local_index).contains(index) {\n+        } else if (self.first_extern_index..self.first_local_index).contains(&index) {\n             Some(RegionClassification::External)\n-        } else if (self.first_local_index..self.num_universals).contains(index) {\n+        } else if (self.first_local_index..self.num_universals).contains(&index) {\n             Some(RegionClassification::Local)\n         } else {\n             None"}]}