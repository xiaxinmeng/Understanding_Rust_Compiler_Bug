{"sha": "a919efad2e410eafe72d067b8a8d4cbe02ecb0df", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE5MTllZmFkMmU0MTBlYWZlNzJkMDY3YjhhOGQ0Y2JlMDJlY2IwZGY=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2018-02-27T18:33:02Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2018-03-07T15:30:33Z"}, "message": "rustc: Migrate to `termcolor` crate from `term`\n\nThis crate moves the compiler's error reporting to using the `termcolor` crate\nfrom crates.io. Previously rustc used a super-old version of the `term` crate\nin-tree which is basically unmaintained at this point, but Cargo has been using\n`termcolor` for some time now and tools like `rg` are using `termcolor` as well,\nso it seems like a good strategy to take!\n\nNote that the `term` crate remains in-tree for libtest. Changing libtest will be\na bit tricky due to how the build works, but we can always tackle that later.\n\ncc #45728", "tree": {"sha": "1d596297ca342ae1e3810691165b9ae1797211d6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1d596297ca342ae1e3810691165b9ae1797211d6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a919efad2e410eafe72d067b8a8d4cbe02ecb0df", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a919efad2e410eafe72d067b8a8d4cbe02ecb0df", "html_url": "https://github.com/rust-lang/rust/commit/a919efad2e410eafe72d067b8a8d4cbe02ecb0df", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a919efad2e410eafe72d067b8a8d4cbe02ecb0df/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4cdbac639af2074b8a07b4391b4e3e28b4118487", "url": "https://api.github.com/repos/rust-lang/rust/commits/4cdbac639af2074b8a07b4391b4e3e28b4118487", "html_url": "https://github.com/rust-lang/rust/commit/4cdbac639af2074b8a07b4391b4e3e28b4118487"}], "stats": {"total": 302, "additions": 136, "deletions": 166}, "files": [{"sha": "76bf201a94011fcaa4742ca9f37cf00c7eb83d4b", "filename": "src/Cargo.lock", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a919efad2e410eafe72d067b8a8d4cbe02ecb0df/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/a919efad2e410eafe72d067b8a8d4cbe02ecb0df/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=a919efad2e410eafe72d067b8a8d4cbe02ecb0df", "patch": "@@ -78,7 +78,7 @@ dependencies = [\n \n [[package]]\n name = \"atty\"\n-version = \"0.2.6\"\n+version = \"0.2.8\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"libc 0.2.36 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -179,7 +179,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n name = \"cargo\"\n version = \"0.26.0\"\n dependencies = [\n- \"atty 0.2.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"atty 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"bufstream 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"cargotest 0.1.0\",\n  \"core-foundation 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -289,7 +289,7 @@ version = \"2.29.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"ansi_term 0.10.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"atty 0.2.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"atty 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"bitflags 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"strsim 0.6.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"textwrap 0.9.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -643,7 +643,7 @@ name = \"env_logger\"\n version = \"0.5.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n- \"atty 0.2.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"atty 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"humantime 1.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"regex 0.2.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1937,9 +1937,11 @@ dependencies = [\n name = \"rustc_errors\"\n version = \"0.0.0\"\n dependencies = [\n+ \"atty 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc_data_structures 0.0.0\",\n  \"serialize 0.0.0\",\n  \"syntax_pos 0.0.0\",\n+ \"termcolor 0.3.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"unicode-width 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n@@ -2876,7 +2878,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum ansi_term 0.10.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"6b3568b48b7cefa6b8ce125f9bb4989e52fbcc29ebea88df04cc7c5f12f70455\"\n \"checksum ar 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"35c7a5669cb64f085739387e1308b74e6d44022464b7f1b63bbd4ceb6379ec31\"\n \"checksum arrayvec 0.4.7 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a1e964f9e24d588183fcb43503abda40d288c8657dfc27311516ce2f05675aef\"\n-\"checksum atty 0.2.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8352656fd42c30a0c3c89d26dea01e3b77c0ab2af18230835c15e2e13cd51859\"\n+\"checksum atty 0.2.8 (registry+https://github.com/rust-lang/crates.io-index)\" = \"af80143d6f7608d746df1520709e5d141c96f240b0e62b0aa41bdfb53374d9d4\"\n \"checksum backtrace 0.3.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ebbbf59b1c43eefa8c3ede390fcc36820b4999f7914104015be25025e0d62af2\"\n \"checksum backtrace-sys 0.1.16 (registry+https://github.com/rust-lang/crates.io-index)\" = \"44585761d6161b0f57afc49482ab6bd067e4edef48c12a152c237eb0203f7661\"\n \"checksum bitflags 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"aad18937a628ec6abcd26d1489012cc0e18c21798210f491af69ded9b881106d\""}, {"sha": "e412d1749d1b2608c880d317c920c9caf23bd177", "filename": "src/librustc_errors/Cargo.toml", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a919efad2e410eafe72d067b8a8d4cbe02ecb0df/src%2Flibrustc_errors%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a919efad2e410eafe72d067b8a8d4cbe02ecb0df/src%2Flibrustc_errors%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2FCargo.toml?ref=a919efad2e410eafe72d067b8a8d4cbe02ecb0df", "patch": "@@ -13,3 +13,5 @@ serialize = { path = \"../libserialize\" }\n syntax_pos = { path = \"../libsyntax_pos\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n unicode-width = \"0.1.4\"\n+atty = \"0.2\"\n+termcolor = \"0.3\""}, {"sha": "f481b36daa346436fbfc9f4f3dcedf08e2c39d10", "filename": "src/librustc_errors/emitter.rs", "status": "modified", "additions": 106, "deletions": 151, "changes": 257, "blob_url": "https://github.com/rust-lang/rust/blob/a919efad2e410eafe72d067b8a8d4cbe02ecb0df/src%2Flibrustc_errors%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a919efad2e410eafe72d067b8a8d4cbe02ecb0df/src%2Flibrustc_errors%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Femitter.rs?ref=a919efad2e410eafe72d067b8a8d4cbe02ecb0df", "patch": "@@ -17,12 +17,14 @@ use snippet::{Annotation, AnnotationType, Line, MultilineAnnotation, StyledStrin\n use styled_buffer::StyledBuffer;\n \n use rustc_data_structures::sync::Lrc;\n+use atty;\n use std::borrow::Cow;\n use std::io::prelude::*;\n use std::io;\n-use term;\n use std::collections::{HashMap, HashSet};\n use std::cmp::min;\n+use termcolor::{StandardStream, ColorChoice, ColorSpec, BufferWriter};\n+use termcolor::{WriteColor, Color, Buffer};\n use unicode_width;\n \n const ANONYMIZED_LINE_NUM: &str = \"LL\";\n@@ -95,11 +97,14 @@ pub enum ColorConfig {\n }\n \n impl ColorConfig {\n-    fn use_color(&self) -> bool {\n+    fn to_color_choice(&self) -> ColorChoice {\n         match *self {\n-            ColorConfig::Always => true,\n-            ColorConfig::Never => false,\n-            ColorConfig::Auto => stderr_isatty(),\n+            ColorConfig::Always => ColorChoice::Always,\n+            ColorConfig::Never => ColorChoice::Never,\n+            ColorConfig::Auto if atty::is(atty::Stream::Stderr) => {\n+                ColorChoice::Auto\n+            }\n+            ColorConfig::Auto => ColorChoice::Never,\n         }\n     }\n }\n@@ -123,25 +128,26 @@ impl Drop for EmitterWriter {\n     fn drop(&mut self) {\n         if !self.short_message && !self.error_codes.is_empty() {\n             let mut error_codes = self.error_codes.clone().into_iter().collect::<Vec<_>>();\n+            let mut dst = self.dst.writable();\n             error_codes.sort();\n             if error_codes.len() > 1 {\n                 let limit = if error_codes.len() > 9 { 9 } else { error_codes.len() };\n-                writeln!(self.dst,\n+                writeln!(dst,\n                          \"You've got a few errors: {}{}\",\n                          error_codes[..limit].join(\", \"),\n                          if error_codes.len() > 9 { \"...\" } else { \"\" }\n                         ).expect(\"failed to give tips...\");\n-                writeln!(self.dst,\n+                writeln!(dst,\n                          \"If you want more information on an error, try using \\\n                           \\\"rustc --explain {}\\\"\",\n                          &error_codes[0]).expect(\"failed to give tips...\");\n             } else {\n-                writeln!(self.dst,\n+                writeln!(dst,\n                          \"If you want more information on this error, try using \\\n                           \\\"rustc --explain {}\\\"\",\n                          &error_codes[0]).expect(\"failed to give tips...\");\n             }\n-            self.dst.flush().expect(\"failed to emit errors\");\n+            dst.flush().expect(\"failed to emit errors\");\n         }\n     }\n }\n@@ -152,25 +158,14 @@ impl EmitterWriter {\n                   short_message: bool,\n                   teach: bool)\n                   -> EmitterWriter {\n-        if color_config.use_color() {\n-            let dst = Destination::from_stderr();\n-            EmitterWriter {\n-                dst,\n-                cm: code_map,\n-                short_message,\n-                teach,\n-                error_codes: HashSet::new(),\n-                ui_testing: false,\n-            }\n-        } else {\n-            EmitterWriter {\n-                dst: Raw(Box::new(io::stderr())),\n-                cm: code_map,\n-                short_message,\n-                teach,\n-                error_codes: HashSet::new(),\n-                ui_testing: false,\n-            }\n+        let dst = Destination::from_stderr(color_config);\n+        EmitterWriter {\n+            dst,\n+            cm: code_map,\n+            short_message,\n+            teach,\n+            error_codes: HashSet::new(),\n+            ui_testing: false,\n         }\n     }\n \n@@ -1356,10 +1351,12 @@ impl EmitterWriter {\n             }\n             Err(e) => panic!(\"failed to emit error: {}\", e),\n         }\n-        match write!(&mut self.dst, \"\\n\") {\n+\n+        let mut dst = self.dst.writable();\n+        match write!(dst, \"\\n\") {\n             Err(e) => panic!(\"failed to emit error: {}\", e),\n             _ => {\n-                match self.dst.flush() {\n+                match dst.flush() {\n                     Err(e) => panic!(\"failed to emit error: {}\", e),\n                     _ => (),\n                 }\n@@ -1424,6 +1421,8 @@ fn emit_to_destination(rendered_buffer: &Vec<Vec<StyledString>>,\n                        -> io::Result<()> {\n     use lock;\n \n+    let mut dst = dst.writable();\n+\n     // In order to prevent error message interleaving, where multiple error lines get intermixed\n     // when multiple compiler processes error simultaneously, we emit errors with additional\n     // steps.\n@@ -1444,7 +1443,7 @@ fn emit_to_destination(rendered_buffer: &Vec<Vec<StyledString>>,\n             if !short_message && part.text.len() == 12 && part.text.starts_with(\"error[E\") {\n                 error_codes.insert(part.text[6..11].to_owned());\n             }\n-            dst.reset_attrs()?;\n+            dst.reset()?;\n         }\n         if !short_message {\n             write!(dst, \"\\n\")?;\n@@ -1454,180 +1453,136 @@ fn emit_to_destination(rendered_buffer: &Vec<Vec<StyledString>>,\n     Ok(())\n }\n \n-#[cfg(unix)]\n-fn stderr_isatty() -> bool {\n-    use libc;\n-    unsafe { libc::isatty(libc::STDERR_FILENO) != 0 }\n-}\n-#[cfg(windows)]\n-fn stderr_isatty() -> bool {\n-    type DWORD = u32;\n-    type BOOL = i32;\n-    type HANDLE = *mut u8;\n-    const STD_ERROR_HANDLE: DWORD = -12i32 as DWORD;\n-    extern \"system\" {\n-        fn GetStdHandle(which: DWORD) -> HANDLE;\n-        fn GetConsoleMode(hConsoleHandle: HANDLE, lpMode: *mut DWORD) -> BOOL;\n-    }\n-    unsafe {\n-        let handle = GetStdHandle(STD_ERROR_HANDLE);\n-        let mut out = 0;\n-        GetConsoleMode(handle, &mut out) != 0\n-    }\n-}\n-\n-pub type BufferedStderr = term::Terminal<Output = BufferedWriter> + Send;\n-\n pub enum Destination {\n-    Terminal(Box<term::StderrTerminal>),\n-    BufferedTerminal(Box<BufferedStderr>),\n+    Terminal(StandardStream),\n+    Buffered(BufferWriter),\n     Raw(Box<Write + Send>),\n }\n \n-/// Buffered writer gives us a way on Unix to buffer up an entire error message before we output\n-/// it.  This helps to prevent interleaving of multiple error messages when multiple compiler\n-/// processes error simultaneously\n-pub struct BufferedWriter {\n-    buffer: Vec<u8>,\n-}\n-\n-impl BufferedWriter {\n-    // note: we use _new because the conditional compilation at its use site may make this\n-    // this function unused on some platforms\n-    fn _new() -> BufferedWriter {\n-        BufferedWriter { buffer: vec![] }\n-    }\n-}\n-\n-impl Write for BufferedWriter {\n-    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n-        for b in buf {\n-            self.buffer.push(*b);\n-        }\n-        Ok(buf.len())\n-    }\n-    fn flush(&mut self) -> io::Result<()> {\n-        let mut stderr = io::stderr();\n-        let result = stderr.write_all(&self.buffer)\n-                           .and_then(|_| stderr.flush());\n-        self.buffer.clear();\n-        result\n-    }\n+pub enum WritableDst<'a> {\n+    Terminal(&'a mut StandardStream),\n+    Buffered(&'a mut BufferWriter, Buffer),\n+    Raw(&'a mut Box<Write + Send>),\n }\n \n impl Destination {\n-    #[cfg(not(windows))]\n-    /// When not on Windows, prefer the buffered terminal so that we can buffer an entire error\n-    /// to be emitted at one time.\n-    fn from_stderr() -> Destination {\n-        let stderr: Option<Box<BufferedStderr>> =\n-            term::TerminfoTerminal::new(BufferedWriter::_new())\n-                .map(|t| Box::new(t) as Box<BufferedStderr>);\n-\n-        match stderr {\n-            Some(t) => BufferedTerminal(t),\n-            None => Raw(Box::new(io::stderr())),\n+    fn from_stderr(color: ColorConfig) -> Destination {\n+        let choice = color.to_color_choice();\n+        // On Windows we'll be performing global synchronization on the entire\n+        // system for emitting rustc errors, so there's no need to buffer\n+        // anything.\n+        //\n+        // On non-Windows we rely on the atomicity of `write` to ensure errors\n+        // don't get all jumbled up.\n+        if cfg!(windows) {\n+            Terminal(StandardStream::stderr(choice))\n+        } else {\n+            Buffered(BufferWriter::stderr(choice))\n         }\n     }\n \n-    #[cfg(windows)]\n-    /// Return a normal, unbuffered terminal when on Windows.\n-    fn from_stderr() -> Destination {\n-        let stderr: Option<Box<term::StderrTerminal>> = term::TerminfoTerminal::new(io::stderr())\n-            .map(|t| Box::new(t) as Box<term::StderrTerminal>)\n-            .or_else(|| {\n-                term::WinConsole::new(io::stderr())\n-                    .ok()\n-                    .map(|t| Box::new(t) as Box<term::StderrTerminal>)\n-            });\n-\n-        match stderr {\n-            Some(t) => Terminal(t),\n-            None => Raw(Box::new(io::stderr())),\n+    fn writable<'a>(&'a mut self) -> WritableDst<'a> {\n+        match *self {\n+            Destination::Terminal(ref mut t) => WritableDst::Terminal(t),\n+            Destination::Buffered(ref mut t) => {\n+                let buf = t.buffer();\n+                WritableDst::Buffered(t, buf)\n+            }\n+            Destination::Raw(ref mut t) => WritableDst::Raw(t),\n         }\n     }\n+}\n \n+impl<'a> WritableDst<'a> {\n     fn apply_style(&mut self, lvl: Level, style: Style) -> io::Result<()> {\n+        let mut spec = ColorSpec::new();\n         match style {\n             Style::LineAndColumn => {}\n             Style::LineNumber => {\n-                self.start_attr(term::Attr::Bold)?;\n+                spec.set_bold(true);\n+                spec.set_intense(true);\n                 if cfg!(windows) {\n-                    self.start_attr(term::Attr::ForegroundColor(term::color::BRIGHT_CYAN))?;\n+                    spec.set_fg(Some(Color::Cyan));\n                 } else {\n-                    self.start_attr(term::Attr::ForegroundColor(term::color::BRIGHT_BLUE))?;\n+                    spec.set_fg(Some(Color::Blue));\n                 }\n             }\n             Style::Quotation => {}\n             Style::OldSchoolNoteText | Style::HeaderMsg => {\n-                self.start_attr(term::Attr::Bold)?;\n+                spec.set_bold(true);\n                 if cfg!(windows) {\n-                    self.start_attr(term::Attr::ForegroundColor(term::color::BRIGHT_WHITE))?;\n+                    spec.set_intense(true)\n+                        .set_fg(Some(Color::White));\n                 }\n             }\n             Style::UnderlinePrimary | Style::LabelPrimary => {\n-                self.start_attr(term::Attr::Bold)?;\n-                self.start_attr(term::Attr::ForegroundColor(lvl.color()))?;\n+                spec = lvl.color();\n+                spec.set_bold(true);\n             }\n             Style::UnderlineSecondary |\n             Style::LabelSecondary => {\n-                self.start_attr(term::Attr::Bold)?;\n+                spec.set_bold(true)\n+                    .set_intense(true);\n                 if cfg!(windows) {\n-                    self.start_attr(term::Attr::ForegroundColor(term::color::BRIGHT_CYAN))?;\n+                    spec.set_fg(Some(Color::Cyan));\n                 } else {\n-                    self.start_attr(term::Attr::ForegroundColor(term::color::BRIGHT_BLUE))?;\n+                    spec.set_fg(Some(Color::Blue));\n                 }\n             }\n             Style::NoStyle => {}\n-            Style::Level(l) => {\n-                self.start_attr(term::Attr::Bold)?;\n-                self.start_attr(term::Attr::ForegroundColor(l.color()))?;\n+            Style::Level(lvl) => {\n+                spec = lvl.color();\n+                spec.set_bold(true);\n+            }\n+            Style::Highlight => {\n+                spec.set_bold(true);\n             }\n-            Style::Highlight => self.start_attr(term::Attr::Bold)?,\n         }\n-        Ok(())\n+        self.set_color(&spec)\n     }\n \n-    fn start_attr(&mut self, attr: term::Attr) -> io::Result<()> {\n+    fn set_color(&mut self, color: &ColorSpec) -> io::Result<()> {\n         match *self {\n-            Terminal(ref mut t) => {\n-                t.attr(attr)?;\n-            }\n-            BufferedTerminal(ref mut t) => {\n-                t.attr(attr)?;\n-            }\n-            Raw(_) => {}\n+            WritableDst::Terminal(ref mut t) => t.set_color(color),\n+            WritableDst::Buffered(_, ref mut t) => t.set_color(color),\n+            WritableDst::Raw(_) => Ok(())\n         }\n-        Ok(())\n     }\n \n-    fn reset_attrs(&mut self) -> io::Result<()> {\n+    fn reset(&mut self) -> io::Result<()> {\n         match *self {\n-            Terminal(ref mut t) => {\n-                t.reset()?;\n-            }\n-            BufferedTerminal(ref mut t) => {\n-                t.reset()?;\n-            }\n-            Raw(_) => {}\n+            WritableDst::Terminal(ref mut t) => t.reset(),\n+            WritableDst::Buffered(_, ref mut t) => t.reset(),\n+            WritableDst::Raw(_) => Ok(()),\n         }\n-        Ok(())\n     }\n }\n \n-impl Write for Destination {\n+impl<'a> Write for WritableDst<'a> {\n     fn write(&mut self, bytes: &[u8]) -> io::Result<usize> {\n         match *self {\n-            Terminal(ref mut t) => t.write(bytes),\n-            BufferedTerminal(ref mut t) => t.write(bytes),\n-            Raw(ref mut w) => w.write(bytes),\n+            WritableDst::Terminal(ref mut t) => t.write(bytes),\n+            WritableDst::Buffered(_, ref mut buf) => buf.write(bytes),\n+            WritableDst::Raw(ref mut w) => w.write(bytes),\n         }\n     }\n+\n     fn flush(&mut self) -> io::Result<()> {\n         match *self {\n-            Terminal(ref mut t) => t.flush(),\n-            BufferedTerminal(ref mut t) => t.flush(),\n-            Raw(ref mut w) => w.flush(),\n+            WritableDst::Terminal(ref mut t) => t.flush(),\n+            WritableDst::Buffered(_, ref mut buf) => buf.flush(),\n+            WritableDst::Raw(ref mut w) => w.flush(),\n+        }\n+    }\n+}\n+\n+impl<'a> Drop for WritableDst<'a> {\n+    fn drop(&mut self) {\n+        match *self {\n+            WritableDst::Buffered(ref mut dst, ref mut buf) => {\n+                drop(dst.print(buf));\n+            }\n+            _ => {}\n         }\n     }\n }"}, {"sha": "924ed71ef0d653eb6c9e1d2c78216042b645b227", "filename": "src/librustc_errors/lib.rs", "status": "modified", "additions": 21, "deletions": 10, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/a919efad2e410eafe72d067b8a8d4cbe02ecb0df/src%2Flibrustc_errors%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a919efad2e410eafe72d067b8a8d4cbe02ecb0df/src%2Flibrustc_errors%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Flib.rs?ref=a919efad2e410eafe72d067b8a8d4cbe02ecb0df", "patch": "@@ -21,7 +21,8 @@\n #![feature(i128_type)]\n #![feature(optin_builtin_traits)]\n \n-extern crate term;\n+extern crate atty;\n+extern crate termcolor;\n #[cfg(unix)]\n extern crate libc;\n extern crate rustc_data_structures;\n@@ -47,6 +48,8 @@ use std::sync::atomic::AtomicUsize;\n use std::sync::atomic::Ordering::SeqCst;\n use std::panic;\n \n+use termcolor::{ColorSpec, Color};\n+\n mod diagnostic;\n mod diagnostic_builder;\n pub mod emitter;\n@@ -660,20 +663,28 @@ impl fmt::Display for Level {\n }\n \n impl Level {\n-    fn color(self) -> term::color::Color {\n+    fn color(self) -> ColorSpec {\n+        let mut spec = ColorSpec::new();\n         match self {\n-            Bug | Fatal | PhaseFatal | Error => term::color::BRIGHT_RED,\n+            Bug | Fatal | PhaseFatal | Error => {\n+                spec.set_fg(Some(Color::Red))\n+                    .set_intense(true);\n+            }\n             Warning => {\n-                if cfg!(windows) {\n-                    term::color::BRIGHT_YELLOW\n-                } else {\n-                    term::color::YELLOW\n-                }\n+                spec.set_fg(Some(Color::Yellow))\n+                    .set_intense(cfg!(windows));\n+            }\n+            Note => {\n+                spec.set_fg(Some(Color::Green))\n+                    .set_intense(true);\n+            }\n+            Help => {\n+                spec.set_fg(Some(Color::Cyan))\n+                    .set_intense(true);\n             }\n-            Note => term::color::BRIGHT_GREEN,\n-            Help => term::color::BRIGHT_CYAN,\n             Cancelled => unreachable!(),\n         }\n+        return spec\n     }\n \n     pub fn to_str(self) -> &'static str {"}]}