{"sha": "cebc018e2ab1779ab68bfe8f4d0bb38986c52596", "node_id": "C_kwDOAAsO6NoAKGNlYmMwMThlMmFiMTc3OWFiNjhiZmU4ZjRkMGJiMzg5ODZjNTI1OTY", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2023-04-22T12:29:28Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2023-04-22T12:29:28Z"}, "message": "Remove unnecessary is_derive field from MacroCallKind::Attr", "tree": {"sha": "3fe67fa978ee04aab8ad8cde543877674e4ad046", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3fe67fa978ee04aab8ad8cde543877674e4ad046"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cebc018e2ab1779ab68bfe8f4d0bb38986c52596", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cebc018e2ab1779ab68bfe8f4d0bb38986c52596", "html_url": "https://github.com/rust-lang/rust/commit/cebc018e2ab1779ab68bfe8f4d0bb38986c52596", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cebc018e2ab1779ab68bfe8f4d0bb38986c52596/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5750d81e3032cf925aa9422a8ac128a2b3a1950c", "url": "https://api.github.com/repos/rust-lang/rust/commits/5750d81e3032cf925aa9422a8ac128a2b3a1950c", "html_url": "https://github.com/rust-lang/rust/commit/5750d81e3032cf925aa9422a8ac128a2b3a1950c"}], "stats": {"total": 152, "additions": 74, "deletions": 78}, "files": [{"sha": "7c6c089d65bad58ae849aedde059735a99e69eb1", "filename": "crates/hir-def/src/data.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cebc018e2ab1779ab68bfe8f4d0bb38986c52596/crates%2Fhir-def%2Fsrc%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebc018e2ab1779ab68bfe8f4d0bb38986c52596/crates%2Fhir-def%2Fsrc%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fdata.rs?ref=cebc018e2ab1779ab68bfe8f4d0bb38986c52596", "patch": "@@ -623,7 +623,6 @@ impl<'a> AssocItemCollector<'a> {\n                                 ast_id,\n                                 attr_args: Arc::new((tt::Subtree::empty(), Default::default())),\n                                 invoc_attr_index: attr.id,\n-                                is_derive: false,\n                             },\n                             attr.path().clone(),\n                         ));"}, {"sha": "8e69a64e7e9c1ecfe75331faf94cdcd53858b587", "filename": "crates/hir-def/src/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cebc018e2ab1779ab68bfe8f4d0bb38986c52596/crates%2Fhir-def%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebc018e2ab1779ab68bfe8f4d0bb38986c52596/crates%2Fhir-def%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Flib.rs?ref=cebc018e2ab1779ab68bfe8f4d0bb38986c52596", "patch": "@@ -984,7 +984,6 @@ fn attr_macro_as_call_id(\n     macro_attr: &Attr,\n     krate: CrateId,\n     def: MacroDefId,\n-    is_derive: bool,\n ) -> MacroCallId {\n     let arg = match macro_attr.input.as_deref() {\n         Some(AttrInput::TokenTree(tt, map)) => (\n@@ -1005,7 +1004,6 @@ fn attr_macro_as_call_id(\n             ast_id: item_attr.ast_id,\n             attr_args: Arc::new(arg),\n             invoc_attr_index: macro_attr.id,\n-            is_derive,\n         },\n     )\n }"}, {"sha": "84271ef51d8ea40aa75388c4eec6ecd28ade3c44", "filename": "crates/hir-def/src/nameres/attr_resolution.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cebc018e2ab1779ab68bfe8f4d0bb38986c52596/crates%2Fhir-def%2Fsrc%2Fnameres%2Fattr_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebc018e2ab1779ab68bfe8f4d0bb38986c52596/crates%2Fhir-def%2Fsrc%2Fnameres%2Fattr_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fnameres%2Fattr_resolution.rs?ref=cebc018e2ab1779ab68bfe8f4d0bb38986c52596", "patch": "@@ -61,7 +61,6 @@ impl DefMap {\n             attr,\n             self.krate,\n             macro_id_to_def_id(db, def),\n-            false,\n         )))\n     }\n "}, {"sha": "51879dd5553f7acc26bd4b6335572bb8ce1be92d", "filename": "crates/hir-def/src/nameres/collector.rs", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cebc018e2ab1779ab68bfe8f4d0bb38986c52596/crates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebc018e2ab1779ab68bfe8f4d0bb38986c52596/crates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs?ref=cebc018e2ab1779ab68bfe8f4d0bb38986c52596", "patch": "@@ -481,7 +481,6 @@ impl DefCollector<'_> {\n                                 Default::default(),\n                             )),\n                             invoc_attr_index: attr.id,\n-                            is_derive: false,\n                         },\n                         attr.path().clone(),\n                     ));\n@@ -1273,7 +1272,6 @@ impl DefCollector<'_> {\n                                     attr,\n                                     self.def_map.krate,\n                                     def,\n-                                    true,\n                                 );\n                                 self.def_map.modules[directive.module_id]\n                                     .scope\n@@ -1293,14 +1291,8 @@ impl DefCollector<'_> {\n                     }\n \n                     // Not resolved to a derive helper or the derive attribute, so try to treat as a normal attribute.\n-                    let call_id = attr_macro_as_call_id(\n-                        self.db,\n-                        file_ast_id,\n-                        attr,\n-                        self.def_map.krate,\n-                        def,\n-                        false,\n-                    );\n+                    let call_id =\n+                        attr_macro_as_call_id(self.db, file_ast_id, attr, self.def_map.krate, def);\n                     let loc: MacroCallLoc = self.db.lookup_intern_macro_call(call_id);\n \n                     // If proc attribute macro expansion is disabled, skip expanding it here"}, {"sha": "80695bc065621e54c1b6b23e395b38a67c250e04", "filename": "crates/hir-expand/src/builtin_attr_macro.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cebc018e2ab1779ab68bfe8f4d0bb38986c52596/crates%2Fhir-expand%2Fsrc%2Fbuiltin_attr_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebc018e2ab1779ab68bfe8f4d0bb38986c52596/crates%2Fhir-expand%2Fsrc%2Fbuiltin_attr_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-expand%2Fsrc%2Fbuiltin_attr_macro.rs?ref=cebc018e2ab1779ab68bfe8f4d0bb38986c52596", "patch": "@@ -96,7 +96,7 @@ fn derive_attr_expand(\n ) -> ExpandResult<tt::Subtree> {\n     let loc = db.lookup_intern_macro_call(id);\n     let derives = match &loc.kind {\n-        MacroCallKind::Attr { attr_args, is_derive: true, .. } => &attr_args.0,\n+        MacroCallKind::Attr { attr_args, .. } if loc.def.is_attribute_derive() => &attr_args.0,\n         _ => return ExpandResult::ok(tt::Subtree::empty()),\n     };\n     pseudo_derive_attr_expansion(tt, derives)"}, {"sha": "c8de6954ee7fc27a15b4c9f19ee32b394dd2f474", "filename": "crates/hir-expand/src/db.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/cebc018e2ab1779ab68bfe8f4d0bb38986c52596/crates%2Fhir-expand%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebc018e2ab1779ab68bfe8f4d0bb38986c52596/crates%2Fhir-expand%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-expand%2Fsrc%2Fdb.rs?ref=cebc018e2ab1779ab68bfe8f4d0bb38986c52596", "patch": "@@ -172,8 +172,8 @@ pub fn expand_speculative(\n     );\n \n     let (attr_arg, token_id) = match loc.kind {\n-        MacroCallKind::Attr { invoc_attr_index, is_derive, .. } => {\n-            let attr = if is_derive {\n+        MacroCallKind::Attr { invoc_attr_index, .. } => {\n+            let attr = if loc.def.is_attribute_derive() {\n                 // for pseudo-derive expansion we actually pass the attribute itself only\n                 ast::Attr::cast(speculative_args.clone())\n             } else {\n@@ -285,8 +285,8 @@ fn parse_macro_expansion(\n             // Note:\n             // The final goal we would like to make all parse_macro success,\n             // such that the following log will not call anyway.\n-            let loc: MacroCallLoc = db.lookup_intern_macro_call(macro_file.macro_call_id);\n-            let node = loc.kind.to_node(db);\n+            let loc = db.lookup_intern_macro_call(macro_file.macro_call_id);\n+            let node = loc.to_node(db);\n \n             // collect parent information for warning log\n             let parents = std::iter::successors(loc.kind.file_id().call_node(db), |it| {\n@@ -360,7 +360,7 @@ fn censor_for_macro_input(loc: &MacroCallLoc, node: &SyntaxNode) -> FxHashSet<Sy\n                     .map(|it| it.syntax().clone())\n                     .collect()\n             }\n-            MacroCallKind::Attr { is_derive: true, .. } => return None,\n+            MacroCallKind::Attr { .. } if loc.def.is_attribute_derive() => return None,\n             MacroCallKind::Attr { invoc_attr_index, .. } => {\n                 cov_mark::hit!(attribute_macro_attr_censoring);\n                 ast::Item::cast(node.clone())?\n@@ -442,7 +442,7 @@ fn macro_def(\n \n fn macro_expand(db: &dyn ExpandDatabase, id: MacroCallId) -> ExpandResult<Arc<tt::Subtree>> {\n     let _p = profile::span(\"macro_expand\");\n-    let loc: MacroCallLoc = db.lookup_intern_macro_call(id);\n+    let loc = db.lookup_intern_macro_call(id);\n     if let Some(eager) = &loc.eager {\n         return ExpandResult { value: eager.arg_or_expansion.clone(), err: eager.error.clone() };\n     }\n@@ -511,7 +511,7 @@ fn parse_macro_expansion_error(\n }\n \n fn expand_proc_macro(db: &dyn ExpandDatabase, id: MacroCallId) -> ExpandResult<tt::Subtree> {\n-    let loc: MacroCallLoc = db.lookup_intern_macro_call(id);\n+    let loc = db.lookup_intern_macro_call(id);\n     let Some(macro_arg) = db.macro_arg(id) else {\n         return ExpandResult {\n             value: tt::Subtree {\n@@ -547,8 +547,7 @@ fn hygiene_frame(db: &dyn ExpandDatabase, file_id: HirFileId) -> Arc<HygieneFram\n }\n \n fn macro_expand_to(db: &dyn ExpandDatabase, id: MacroCallId) -> ExpandTo {\n-    let loc: MacroCallLoc = db.lookup_intern_macro_call(id);\n-    loc.kind.expand_to()\n+    db.lookup_intern_macro_call(id).expand_to()\n }\n \n fn token_tree_to_syntax_node("}, {"sha": "ce0006d84229e8803ce26f31b12b8a0ffcddb5c9", "filename": "crates/hir-expand/src/lib.rs", "status": "modified", "additions": 63, "deletions": 54, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/cebc018e2ab1779ab68bfe8f4d0bb38986c52596/crates%2Fhir-expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cebc018e2ab1779ab68bfe8f4d0bb38986c52596/crates%2Fhir-expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-expand%2Fsrc%2Flib.rs?ref=cebc018e2ab1779ab68bfe8f4d0bb38986c52596", "patch": "@@ -168,8 +168,6 @@ pub enum MacroCallKind {\n         /// Outer attributes are counted first, then inner attributes. This does not support\n         /// out-of-line modules, which may have attributes spread across 2 files!\n         invoc_attr_index: AttrId,\n-        /// Whether this attribute is the `#[derive]` attribute.\n-        is_derive: bool,\n     },\n }\n \n@@ -232,18 +230,17 @@ impl HirFileId {\n     pub fn call_node(self, db: &dyn db::ExpandDatabase) -> Option<InFile<SyntaxNode>> {\n         let macro_file = self.macro_file()?;\n         let loc: MacroCallLoc = db.lookup_intern_macro_call(macro_file.macro_call_id);\n-        Some(loc.kind.to_node(db))\n+        Some(loc.to_node(db))\n     }\n \n     /// If this is a macro call, returns the syntax node of the very first macro call this file resides in.\n     pub fn original_call_node(self, db: &dyn db::ExpandDatabase) -> Option<(FileId, SyntaxNode)> {\n-        let mut call =\n-            db.lookup_intern_macro_call(self.macro_file()?.macro_call_id).kind.to_node(db);\n+        let mut call = db.lookup_intern_macro_call(self.macro_file()?.macro_call_id).to_node(db);\n         loop {\n             match call.file_id.repr() {\n                 HirFileIdRepr::FileId(file_id) => break Some((file_id, call.value)),\n                 HirFileIdRepr::MacroFile(MacroFile { macro_call_id }) => {\n-                    call = db.lookup_intern_macro_call(macro_call_id).kind.to_node(db);\n+                    call = db.lookup_intern_macro_call(macro_call_id).to_node(db);\n                 }\n             }\n         }\n@@ -306,7 +303,7 @@ impl HirFileId {\n         let macro_file = self.macro_file()?;\n         let loc: MacroCallLoc = db.lookup_intern_macro_call(macro_file.macro_call_id);\n         let attr = match loc.def.kind {\n-            MacroDefKind::BuiltInDerive(..) => loc.kind.to_node(db),\n+            MacroDefKind::BuiltInDerive(..) => loc.to_node(db),\n             _ => return None,\n         };\n         Some(attr.with_value(ast::Attr::cast(attr.value.clone())?))\n@@ -350,7 +347,7 @@ impl HirFileId {\n         match self.macro_file() {\n             Some(macro_file) => {\n                 let loc: MacroCallLoc = db.lookup_intern_macro_call(macro_file.macro_call_id);\n-                matches!(loc.kind, MacroCallKind::Attr { is_derive: true, .. })\n+                loc.def.is_attribute_derive()\n             }\n             None => false,\n         }\n@@ -421,22 +418,15 @@ impl MacroDefId {\n             MacroDefKind::BuiltInAttr(..) | MacroDefKind::ProcMacro(_, ProcMacroKind::Attr, _)\n         )\n     }\n-}\n-\n-// FIXME: attribute indices do not account for nested `cfg_attr`\n \n-impl MacroCallKind {\n-    /// Returns the file containing the macro invocation.\n-    fn file_id(&self) -> HirFileId {\n-        match *self {\n-            MacroCallKind::FnLike { ast_id: InFile { file_id, .. }, .. }\n-            | MacroCallKind::Derive { ast_id: InFile { file_id, .. }, .. }\n-            | MacroCallKind::Attr { ast_id: InFile { file_id, .. }, .. } => file_id,\n-        }\n+    pub fn is_attribute_derive(&self) -> bool {\n+        matches!(self.kind, MacroDefKind::BuiltInAttr(expander, ..) if expander.is_derive())\n     }\n+}\n \n+impl MacroCallLoc {\n     pub fn to_node(&self, db: &dyn db::ExpandDatabase) -> InFile<SyntaxNode> {\n-        match self {\n+        match self.kind {\n             MacroCallKind::FnLike { ast_id, .. } => {\n                 ast_id.with_value(ast_id.to_node(db).syntax().clone())\n             }\n@@ -452,23 +442,49 @@ impl MacroCallKind {\n                         .unwrap_or_else(|| it.syntax().clone())\n                 })\n             }\n-            MacroCallKind::Attr { ast_id, is_derive: true, invoc_attr_index, .. } => {\n-                // FIXME: handle `cfg_attr`\n-                ast_id.with_value(ast_id.to_node(db)).map(|it| {\n-                    it.doc_comments_and_attrs()\n-                        .nth(invoc_attr_index.ast_index())\n-                        .and_then(|it| match it {\n-                            Either::Left(attr) => Some(attr.syntax().clone()),\n-                            Either::Right(_) => None,\n-                        })\n-                        .unwrap_or_else(|| it.syntax().clone())\n-                })\n+            MacroCallKind::Attr { ast_id, invoc_attr_index, .. } => {\n+                if self.def.is_attribute_derive() {\n+                    // FIXME: handle `cfg_attr`\n+                    ast_id.with_value(ast_id.to_node(db)).map(|it| {\n+                        it.doc_comments_and_attrs()\n+                            .nth(invoc_attr_index.ast_index())\n+                            .and_then(|it| match it {\n+                                Either::Left(attr) => Some(attr.syntax().clone()),\n+                                Either::Right(_) => None,\n+                            })\n+                            .unwrap_or_else(|| it.syntax().clone())\n+                    })\n+                } else {\n+                    ast_id.with_value(ast_id.to_node(db).syntax().clone())\n+                }\n             }\n-            MacroCallKind::Attr { ast_id, .. } => {\n-                ast_id.with_value(ast_id.to_node(db).syntax().clone())\n+        }\n+    }\n+\n+    fn expand_to(&self) -> ExpandTo {\n+        match self.kind {\n+            MacroCallKind::FnLike { expand_to, .. } => expand_to,\n+            MacroCallKind::Derive { .. } => ExpandTo::Items,\n+            MacroCallKind::Attr { .. } if self.def.is_attribute_derive() => ExpandTo::Statements,\n+            MacroCallKind::Attr { .. } => {\n+                // is this always correct?\n+                ExpandTo::Items\n             }\n         }\n     }\n+}\n+\n+// FIXME: attribute indices do not account for nested `cfg_attr`\n+\n+impl MacroCallKind {\n+    /// Returns the file containing the macro invocation.\n+    fn file_id(&self) -> HirFileId {\n+        match *self {\n+            MacroCallKind::FnLike { ast_id: InFile { file_id, .. }, .. }\n+            | MacroCallKind::Derive { ast_id: InFile { file_id, .. }, .. }\n+            | MacroCallKind::Attr { ast_id: InFile { file_id, .. }, .. } => file_id,\n+        }\n+    }\n \n     /// Returns the original file range that best describes the location of this macro call.\n     ///\n@@ -546,15 +562,6 @@ impl MacroCallKind {\n             MacroCallKind::Attr { ast_id, .. } => Some(ast_id.to_node(db).syntax().clone()),\n         }\n     }\n-\n-    fn expand_to(&self) -> ExpandTo {\n-        match self {\n-            MacroCallKind::FnLike { expand_to, .. } => *expand_to,\n-            MacroCallKind::Derive { .. } => ExpandTo::Items,\n-            MacroCallKind::Attr { is_derive: true, .. } => ExpandTo::Statements,\n-            MacroCallKind::Attr { .. } => ExpandTo::Items, // is this always correct?\n-        }\n-    }\n }\n \n impl MacroCallId {\n@@ -618,7 +625,7 @@ impl ExpansionInfo {\n \n             let token_range = token.value.text_range();\n             match &loc.kind {\n-                MacroCallKind::Attr { attr_args, invoc_attr_index, is_derive, .. } => {\n+                MacroCallKind::Attr { attr_args, invoc_attr_index, .. } => {\n                     // FIXME: handle `cfg_attr`\n                     let attr = item\n                         .doc_comments_and_attrs()\n@@ -634,7 +641,8 @@ impl ExpansionInfo {\n                                 token.value.text_range().checked_sub(attr_input_start)?;\n                             // shift by the item's tree's max id\n                             let token_id = attr_args.1.token_by_range(relative_range)?;\n-                            let token_id = if *is_derive {\n+\n+                            let token_id = if loc.def.is_attribute_derive() {\n                                 // we do not shift for `#[derive]`, as we only need to downmap the derive attribute tokens\n                                 token_id\n                             } else {\n@@ -697,18 +705,19 @@ impl ExpansionInfo {\n \n         // Attributes are a bit special for us, they have two inputs, the input tokentree and the annotated item.\n         let (token_map, tt) = match &loc.kind {\n-            MacroCallKind::Attr { attr_args, is_derive: true, .. } => {\n-                (&attr_args.1, self.attr_input_or_mac_def.clone()?.syntax().cloned())\n-            }\n             MacroCallKind::Attr { attr_args, .. } => {\n-                // try unshifting the token id, if unshifting fails, the token resides in the non-item attribute input\n-                // note that the `TokenExpander::map_id_up` earlier only unshifts for declarative macros, so we don't double unshift with this\n-                match self.macro_arg_shift.unshift(token_id) {\n-                    Some(unshifted) => {\n-                        token_id = unshifted;\n-                        (&attr_args.1, self.attr_input_or_mac_def.clone()?.syntax().cloned())\n+                if loc.def.is_attribute_derive() {\n+                    (&attr_args.1, self.attr_input_or_mac_def.clone()?.syntax().cloned())\n+                } else {\n+                    // try unshifting the token id, if unshifting fails, the token resides in the non-item attribute input\n+                    // note that the `TokenExpander::map_id_up` earlier only unshifts for declarative macros, so we don't double unshift with this\n+                    match self.macro_arg_shift.unshift(token_id) {\n+                        Some(unshifted) => {\n+                            token_id = unshifted;\n+                            (&attr_args.1, self.attr_input_or_mac_def.clone()?.syntax().cloned())\n+                        }\n+                        None => (&self.macro_arg.1, self.arg.clone()),\n                     }\n-                    None => (&self.macro_arg.1, self.arg.clone()),\n                 }\n             }\n             _ => match origin {"}]}