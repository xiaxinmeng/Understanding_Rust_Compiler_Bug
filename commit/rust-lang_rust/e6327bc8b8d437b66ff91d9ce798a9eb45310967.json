{"sha": "e6327bc8b8d437b66ff91d9ce798a9eb45310967", "node_id": "C_kwDOAAsO6NoAKGU2MzI3YmM4YjhkNDM3YjY2ZmY5MWQ5Y2U3OThhOWViNDUzMTA5Njc", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-19T01:41:07Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-05-19T01:41:07Z"}, "message": "Auto merge of #97159 - JohnTitor:rollup-ibl51vw, r=JohnTitor\n\nRollup of 6 pull requests\n\nSuccessful merges:\n\n - #96866 (Switch CI bucket uploads to intelligent tiering)\n - #97062 (Couple of refactorings to cg_ssa::base::codegen_crate)\n - #97127 (Revert \"Auto merge of #96441 - ChrisDenton:sync-pipes, r=m-ou-se\")\n - #97131 (Improve println! documentation)\n - #97139 (Move some settings DOM generation out of JS)\n - #97152 (Update cargo)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "4c913afbc55e2f83b2d8c656366bd0259af8a868", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4c913afbc55e2f83b2d8c656366bd0259af8a868"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e6327bc8b8d437b66ff91d9ce798a9eb45310967", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e6327bc8b8d437b66ff91d9ce798a9eb45310967", "html_url": "https://github.com/rust-lang/rust/commit/e6327bc8b8d437b66ff91d9ce798a9eb45310967", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e6327bc8b8d437b66ff91d9ce798a9eb45310967/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d8a3fc4d71bae720cc2534ff5b97164f47622e12", "url": "https://api.github.com/repos/rust-lang/rust/commits/d8a3fc4d71bae720cc2534ff5b97164f47622e12", "html_url": "https://github.com/rust-lang/rust/commit/d8a3fc4d71bae720cc2534ff5b97164f47622e12"}, {"sha": "9babb1c0daf4c91513e4c1372426da04ed80a1d4", "url": "https://api.github.com/repos/rust-lang/rust/commits/9babb1c0daf4c91513e4c1372426da04ed80a1d4", "html_url": "https://github.com/rust-lang/rust/commit/9babb1c0daf4c91513e4c1372426da04ed80a1d4"}], "stats": {"total": 263, "additions": 75, "deletions": 188}, "files": [{"sha": "d11f1534153ad49761e7e07e5f63c72254139993", "filename": "compiler/rustc_codegen_ssa/src/base.rs", "status": "modified", "additions": 24, "deletions": 33, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/e6327bc8b8d437b66ff91d9ce798a9eb45310967/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6327bc8b8d437b66ff91d9ce798a9eb45310967/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs?ref=e6327bc8b8d437b66ff91d9ce798a9eb45310967", "patch": "@@ -15,8 +15,9 @@ use rustc_attr as attr;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::profiling::{get_resident_set_size, print_time_passes_entry};\n \n+use rustc_data_structures::sync::par_iter;\n #[cfg(parallel_compiler)]\n-use rustc_data_structures::sync::{par_iter, ParallelIterator};\n+use rustc_data_structures::sync::ParallelIterator;\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n use rustc_hir::lang_items::LangItem;\n@@ -607,6 +608,14 @@ pub fn codegen_crate<B: ExtraBackendMethods>(\n         second_half.iter().rev().interleave(first_half).copied().collect()\n     };\n \n+    // Calculate the CGU reuse\n+    let cgu_reuse = tcx.sess.time(\"find_cgu_reuse\", || {\n+        codegen_units.iter().map(|cgu| determine_cgu_reuse(tcx, &cgu)).collect::<Vec<_>>()\n+    });\n+\n+    let mut total_codegen_time = Duration::new(0, 0);\n+    let start_rss = tcx.sess.time_passes().then(|| get_resident_set_size());\n+\n     // The non-parallel compiler can only translate codegen units to LLVM IR\n     // on a single thread, leading to a staircase effect where the N LLVM\n     // threads have to wait on the single codegen threads to generate work\n@@ -617,8 +626,7 @@ pub fn codegen_crate<B: ExtraBackendMethods>(\n     // This likely is a temporary measure. Once we don't have to support the\n     // non-parallel compiler anymore, we can compile CGUs end-to-end in\n     // parallel and get rid of the complicated scheduling logic.\n-    #[cfg(parallel_compiler)]\n-    let pre_compile_cgus = |cgu_reuse: &[CguReuse]| {\n+    let mut pre_compiled_cgus = if cfg!(parallel_compiler) {\n         tcx.sess.time(\"compile_first_CGU_batch\", || {\n             // Try to find one CGU to compile per thread.\n             let cgus: Vec<_> = cgu_reuse\n@@ -638,48 +646,31 @@ pub fn codegen_crate<B: ExtraBackendMethods>(\n                 })\n                 .collect();\n \n-            (pre_compiled_cgus, start_time.elapsed())\n+            total_codegen_time += start_time.elapsed();\n+\n+            pre_compiled_cgus\n         })\n+    } else {\n+        FxHashMap::default()\n     };\n \n-    #[cfg(not(parallel_compiler))]\n-    let pre_compile_cgus = |_: &[CguReuse]| (FxHashMap::default(), Duration::new(0, 0));\n-\n-    let mut cgu_reuse = Vec::new();\n-    let mut pre_compiled_cgus: Option<FxHashMap<usize, _>> = None;\n-    let mut total_codegen_time = Duration::new(0, 0);\n-    let start_rss = tcx.sess.time_passes().then(|| get_resident_set_size());\n-\n     for (i, cgu) in codegen_units.iter().enumerate() {\n         ongoing_codegen.wait_for_signal_to_codegen_item();\n         ongoing_codegen.check_for_errors(tcx.sess);\n \n-        // Do some setup work in the first iteration\n-        if pre_compiled_cgus.is_none() {\n-            // Calculate the CGU reuse\n-            cgu_reuse = tcx.sess.time(\"find_cgu_reuse\", || {\n-                codegen_units.iter().map(|cgu| determine_cgu_reuse(tcx, &cgu)).collect()\n-            });\n-            // Pre compile some CGUs\n-            let (compiled_cgus, codegen_time) = pre_compile_cgus(&cgu_reuse);\n-            pre_compiled_cgus = Some(compiled_cgus);\n-            total_codegen_time += codegen_time;\n-        }\n-\n         let cgu_reuse = cgu_reuse[i];\n         tcx.sess.cgu_reuse_tracker.set_actual_reuse(cgu.name().as_str(), cgu_reuse);\n \n         match cgu_reuse {\n             CguReuse::No => {\n-                let (module, cost) =\n-                    if let Some(cgu) = pre_compiled_cgus.as_mut().unwrap().remove(&i) {\n-                        cgu\n-                    } else {\n-                        let start_time = Instant::now();\n-                        let module = backend.compile_codegen_unit(tcx, cgu.name());\n-                        total_codegen_time += start_time.elapsed();\n-                        module\n-                    };\n+                let (module, cost) = if let Some(cgu) = pre_compiled_cgus.remove(&i) {\n+                    cgu\n+                } else {\n+                    let start_time = Instant::now();\n+                    let module = backend.compile_codegen_unit(tcx, cgu.name());\n+                    total_codegen_time += start_time.elapsed();\n+                    module\n+                };\n                 // This will unwind if there are errors, which triggers our `AbortCodegenOnDrop`\n                 // guard. Unfortunately, just skipping the `submit_codegened_module_to_llvm` makes\n                 // compilation hang on post-monomorphization errors."}, {"sha": "c7348951511c49a7344fc5bbd9991cbbf41b74c5", "filename": "library/std/src/macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e6327bc8b8d437b66ff91d9ce798a9eb45310967/library%2Fstd%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6327bc8b8d437b66ff91d9ce798a9eb45310967/library%2Fstd%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fmacros.rs?ref=e6327bc8b8d437b66ff91d9ce798a9eb45310967", "patch": "@@ -72,7 +72,7 @@ macro_rules! print {\n /// On all platforms, the newline is the LINE FEED character (`\\n`/`U+000A`) alone\n /// (no additional CARRIAGE RETURN (`\\r`/`U+000D`)).\n ///\n-/// Use the [`format!`] syntax to write data to the standard output.\n+/// This macro uses the same syntax as [`format!`], but writes to the standard output instead.\n /// See [`std::fmt`] for more information.\n ///\n /// Use `println!` only for the primary output of your program. Use"}, {"sha": "90a5b7466fec49956a327fb089ac2656c413489c", "filename": "library/std/src/os/windows/io/handle.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e6327bc8b8d437b66ff91d9ce798a9eb45310967/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fhandle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6327bc8b8d437b66ff91d9ce798a9eb45310967/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fhandle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fhandle.rs?ref=e6327bc8b8d437b66ff91d9ce798a9eb45310967", "patch": "@@ -204,19 +204,6 @@ impl OwnedHandle {\n         })?;\n         unsafe { Ok(Self::from_raw_handle(ret)) }\n     }\n-\n-    /// Allow child processes to inherit the handle.\n-    #[cfg(not(target_vendor = \"uwp\"))]\n-    pub(crate) fn set_inheritable(&self) -> io::Result<()> {\n-        cvt(unsafe {\n-            c::SetHandleInformation(\n-                self.as_raw_handle(),\n-                c::HANDLE_FLAG_INHERIT,\n-                c::HANDLE_FLAG_INHERIT,\n-            )\n-        })?;\n-        Ok(())\n-    }\n }\n \n impl TryFrom<HandleOrInvalid> for OwnedHandle {"}, {"sha": "27776fdf533ee41f1ea60d07dcc11151ba1c90fe", "filename": "library/std/src/sys/windows/c.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e6327bc8b8d437b66ff91d9ce798a9eb45310967/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6327bc8b8d437b66ff91d9ce798a9eb45310967/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs?ref=e6327bc8b8d437b66ff91d9ce798a9eb45310967", "patch": "@@ -1026,12 +1026,6 @@ extern \"system\" {\n         bWaitAll: BOOL,\n         dwMilliseconds: DWORD,\n     ) -> DWORD;\n-    pub fn CreatePipe(\n-        hReadPipe: *mut HANDLE,\n-        hWritePipe: *mut HANDLE,\n-        lpPipeAttributes: *const SECURITY_ATTRIBUTES,\n-        nSize: DWORD,\n-    ) -> BOOL;\n     pub fn CreateNamedPipeW(\n         lpName: LPCWSTR,\n         dwOpenMode: DWORD,"}, {"sha": "ef9a8bd690031c0fbf5dda54da5d87fc6b39c858", "filename": "library/std/src/sys/windows/handle.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e6327bc8b8d437b66ff91d9ce798a9eb45310967/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fhandle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6327bc8b8d437b66ff91d9ce798a9eb45310967/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fhandle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fhandle.rs?ref=e6327bc8b8d437b66ff91d9ce798a9eb45310967", "patch": "@@ -221,11 +221,6 @@ impl Handle {\n         Ok(Self(self.0.duplicate(access, inherit, options)?))\n     }\n \n-    #[cfg(not(target_vendor = \"uwp\"))]\n-    pub(crate) fn set_inheritable(&self) -> io::Result<()> {\n-        self.0.set_inheritable()\n-    }\n-\n     /// Performs a synchronous read.\n     ///\n     /// If the handle is opened for asynchronous I/O then this abort the process."}, {"sha": "013c776c476c361dce272d3e28a205534cae4656", "filename": "library/std/src/sys/windows/pipe.rs", "status": "modified", "additions": 25, "deletions": 76, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/e6327bc8b8d437b66ff91d9ce798a9eb45310967/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6327bc8b8d437b66ff91d9ce798a9eb45310967/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fpipe.rs?ref=e6327bc8b8d437b66ff91d9ce798a9eb45310967", "patch": "@@ -18,67 +18,20 @@ use crate::sys_common::IntoInner;\n // Anonymous pipes\n ////////////////////////////////////////////////////////////////////////////////\n \n-// A 64kb pipe capacity is the same as a typical Linux default.\n-const PIPE_BUFFER_CAPACITY: u32 = 64 * 1024;\n-\n-pub enum AnonPipe {\n-    Sync(Handle),\n-    Async(Handle),\n+pub struct AnonPipe {\n+    inner: Handle,\n }\n \n impl IntoInner<Handle> for AnonPipe {\n     fn into_inner(self) -> Handle {\n-        match self {\n-            Self::Sync(handle) => handle,\n-            Self::Async(handle) => handle,\n-        }\n+        self.inner\n     }\n }\n \n pub struct Pipes {\n     pub ours: AnonPipe,\n     pub theirs: AnonPipe,\n }\n-impl Pipes {\n-    /// Create a new pair of pipes where both pipes are synchronous.\n-    ///\n-    /// These must not be used asynchronously.\n-    pub fn new_synchronous(\n-        ours_readable: bool,\n-        their_handle_inheritable: bool,\n-    ) -> io::Result<Self> {\n-        unsafe {\n-            // If `CreatePipe` succeeds, these will be our pipes.\n-            let mut read = ptr::null_mut();\n-            let mut write = ptr::null_mut();\n-\n-            if c::CreatePipe(&mut read, &mut write, ptr::null(), PIPE_BUFFER_CAPACITY) == 0 {\n-                Err(io::Error::last_os_error())\n-            } else {\n-                let (ours, theirs) = if ours_readable { (read, write) } else { (write, read) };\n-                let ours = Handle::from_raw_handle(ours);\n-                #[cfg(not(target_vendor = \"uwp\"))]\n-                let theirs = Handle::from_raw_handle(theirs);\n-                #[cfg(target_vendor = \"uwp\")]\n-                let mut theirs = Handle::from_raw_handle(theirs);\n-\n-                if their_handle_inheritable {\n-                    #[cfg(not(target_vendor = \"uwp\"))]\n-                    {\n-                        theirs.set_inheritable()?;\n-                    }\n-\n-                    #[cfg(target_vendor = \"uwp\")]\n-                    {\n-                        theirs = theirs.duplicate(0, true, c::DUPLICATE_SAME_ACCESS)?;\n-                    }\n-                }\n-\n-                Ok(Pipes { ours: AnonPipe::Sync(ours), theirs: AnonPipe::Sync(theirs) })\n-            }\n-        }\n-    }\n-}\n \n /// Although this looks similar to `anon_pipe` in the Unix module it's actually\n /// subtly different. Here we'll return two pipes in the `Pipes` return value,\n@@ -100,6 +53,9 @@ impl Pipes {\n /// with `OVERLAPPED` instances, but also works out ok if it's only ever used\n /// once at a time (which we do indeed guarantee).\n pub fn anon_pipe(ours_readable: bool, their_handle_inheritable: bool) -> io::Result<Pipes> {\n+    // A 64kb pipe capacity is the same as a typical Linux default.\n+    const PIPE_BUFFER_CAPACITY: u32 = 64 * 1024;\n+\n     // Note that we specifically do *not* use `CreatePipe` here because\n     // unfortunately the anonymous pipes returned do not support overlapped\n     // operations. Instead, we create a \"hopefully unique\" name and create a\n@@ -200,9 +156,12 @@ pub fn anon_pipe(ours_readable: bool, their_handle_inheritable: bool) -> io::Res\n         };\n         opts.security_attributes(&mut sa);\n         let theirs = File::open(Path::new(&name), &opts)?;\n-        let theirs = AnonPipe::Sync(theirs.into_inner());\n+        let theirs = AnonPipe { inner: theirs.into_inner() };\n \n-        Ok(Pipes { ours: AnonPipe::Async(ours), theirs })\n+        Ok(Pipes {\n+            ours: AnonPipe { inner: ours },\n+            theirs: AnonPipe { inner: theirs.into_inner() },\n+        })\n     }\n }\n \n@@ -212,12 +171,12 @@ pub fn anon_pipe(ours_readable: bool, their_handle_inheritable: bool) -> io::Res\n /// This is achieved by creating a new set of pipes and spawning a thread that\n /// relays messages between the source and the synchronous pipe.\n pub fn spawn_pipe_relay(\n-    source: &Handle,\n+    source: &AnonPipe,\n     ours_readable: bool,\n     their_handle_inheritable: bool,\n ) -> io::Result<AnonPipe> {\n     // We need this handle to live for the lifetime of the thread spawned below.\n-    let source = AnonPipe::Async(source.duplicate(0, true, c::DUPLICATE_SAME_ACCESS)?);\n+    let source = source.duplicate()?;\n \n     // create a new pair of anon pipes.\n     let Pipes { theirs, ours } = anon_pipe(ours_readable, their_handle_inheritable)?;\n@@ -268,24 +227,19 @@ type AlertableIoFn = unsafe extern \"system\" fn(\n \n impl AnonPipe {\n     pub fn handle(&self) -> &Handle {\n-        match self {\n-            Self::Async(ref handle) => handle,\n-            Self::Sync(ref handle) => handle,\n-        }\n+        &self.inner\n     }\n     pub fn into_handle(self) -> Handle {\n-        self.into_inner()\n+        self.inner\n+    }\n+    fn duplicate(&self) -> io::Result<Self> {\n+        self.inner.duplicate(0, false, c::DUPLICATE_SAME_ACCESS).map(|inner| AnonPipe { inner })\n     }\n \n     pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n         let result = unsafe {\n             let len = crate::cmp::min(buf.len(), c::DWORD::MAX as usize) as c::DWORD;\n-            match self {\n-                Self::Sync(ref handle) => handle.read(buf),\n-                Self::Async(_) => {\n-                    self.alertable_io_internal(c::ReadFileEx, buf.as_mut_ptr() as _, len)\n-                }\n-            }\n+            self.alertable_io_internal(c::ReadFileEx, buf.as_mut_ptr() as _, len)\n         };\n \n         match result {\n@@ -299,33 +253,28 @@ impl AnonPipe {\n     }\n \n     pub fn read_vectored(&self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n-        io::default_read_vectored(|buf| self.read(buf), bufs)\n+        self.inner.read_vectored(bufs)\n     }\n \n     #[inline]\n     pub fn is_read_vectored(&self) -> bool {\n-        false\n+        self.inner.is_read_vectored()\n     }\n \n     pub fn write(&self, buf: &[u8]) -> io::Result<usize> {\n         unsafe {\n             let len = crate::cmp::min(buf.len(), c::DWORD::MAX as usize) as c::DWORD;\n-            match self {\n-                Self::Sync(ref handle) => handle.write(buf),\n-                Self::Async(_) => {\n-                    self.alertable_io_internal(c::WriteFileEx, buf.as_ptr() as _, len)\n-                }\n-            }\n+            self.alertable_io_internal(c::WriteFileEx, buf.as_ptr() as _, len)\n         }\n     }\n \n     pub fn write_vectored(&self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n-        io::default_write_vectored(|buf| self.write(buf), bufs)\n+        self.inner.write_vectored(bufs)\n     }\n \n     #[inline]\n     pub fn is_write_vectored(&self) -> bool {\n-        false\n+        self.inner.is_write_vectored()\n     }\n \n     /// Synchronizes asynchronous reads or writes using our anonymous pipe.\n@@ -397,7 +346,7 @@ impl AnonPipe {\n \n         // Asynchronous read of the pipe.\n         // If successful, `callback` will be called once it completes.\n-        let result = io(self.handle().as_handle(), buf, len, &mut overlapped, callback);\n+        let result = io(self.inner.as_handle(), buf, len, &mut overlapped, callback);\n         if result == c::FALSE {\n             // We can return here because the call failed.\n             // After this we must not return until the I/O completes."}, {"sha": "9fd399f4ba1d3193061af53e8e13dcb1484a76ef", "filename": "library/std/src/sys/windows/process.rs", "status": "modified", "additions": 6, "deletions": 32, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/e6327bc8b8d437b66ff91d9ce798a9eb45310967/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6327bc8b8d437b66ff91d9ce798a9eb45310967/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fprocess.rs?ref=e6327bc8b8d437b66ff91d9ce798a9eb45310967", "patch": "@@ -23,7 +23,7 @@ use crate::sys::cvt;\n use crate::sys::fs::{File, OpenOptions};\n use crate::sys::handle::Handle;\n use crate::sys::path;\n-use crate::sys::pipe::{self, AnonPipe, Pipes};\n+use crate::sys::pipe::{self, AnonPipe};\n use crate::sys::stdio;\n use crate::sys_common::mutex::StaticMutex;\n use crate::sys_common::process::{CommandEnv, CommandEnvs};\n@@ -172,7 +172,7 @@ pub enum Stdio {\n     Inherit,\n     Null,\n     MakePipe,\n-    AsyncPipe(Handle),\n+    Pipe(AnonPipe),\n     Handle(Handle),\n }\n \n@@ -527,33 +527,13 @@ impl Stdio {\n             },\n \n             Stdio::MakePipe => {\n-                // Handles that are passed to a child process must be synchronous\n-                // because they will be read synchronously (see #95759).\n-                // Therefore we prefer to make both ends of a pipe synchronous\n-                // just in case our end of the pipe is passed to another process.\n-                //\n-                // However, we may need to read from both the child's stdout and\n-                // stderr simultaneously when waiting for output. This requires\n-                // async reads so as to avoid blocking either pipe.\n-                //\n-                // The solution used here is to make handles synchronous\n-                // except for our side of the stdout and sterr pipes.\n-                // If our side of those pipes do end up being given to another\n-                // process then we use a \"pipe relay\" to synchronize access\n-                // (see `Stdio::AsyncPipe` below).\n-                let pipes = if stdio_id == c::STD_INPUT_HANDLE {\n-                    // For stdin both sides of the pipe are synchronous.\n-                    Pipes::new_synchronous(false, true)?\n-                } else {\n-                    // For stdout/stderr our side of the pipe is async and their side is synchronous.\n-                    pipe::anon_pipe(true, true)?\n-                };\n+                let ours_readable = stdio_id != c::STD_INPUT_HANDLE;\n+                let pipes = pipe::anon_pipe(ours_readable, true)?;\n                 *pipe = Some(pipes.ours);\n                 Ok(pipes.theirs.into_handle())\n             }\n \n-            Stdio::AsyncPipe(ref source) => {\n-                // We need to synchronize asynchronous pipes by using a pipe relay.\n+            Stdio::Pipe(ref source) => {\n                 let ours_readable = stdio_id != c::STD_INPUT_HANDLE;\n                 pipe::spawn_pipe_relay(source, ours_readable, true).map(AnonPipe::into_handle)\n             }\n@@ -582,13 +562,7 @@ impl Stdio {\n \n impl From<AnonPipe> for Stdio {\n     fn from(pipe: AnonPipe) -> Stdio {\n-        // Note that it's very important we don't give async handles to child processes.\n-        // Therefore if the pipe is asynchronous we must have a way to turn it synchronous.\n-        // See #95759.\n-        match pipe {\n-            AnonPipe::Sync(handle) => Stdio::Handle(handle),\n-            AnonPipe::Async(handle) => Stdio::AsyncPipe(handle),\n-        }\n+        Stdio::Pipe(pipe)\n     }\n }\n "}, {"sha": "b3ec1638fda741e3680a70960377c66e3b41c4c7", "filename": "src/ci/docker/host-x86_64/x86_64-gnu-tools/browser-ui-test.version", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e6327bc8b8d437b66ff91d9ce798a9eb45310967/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-tools%2Fbrowser-ui-test.version", "raw_url": "https://github.com/rust-lang/rust/raw/e6327bc8b8d437b66ff91d9ce798a9eb45310967/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-tools%2Fbrowser-ui-test.version", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fx86_64-gnu-tools%2Fbrowser-ui-test.version?ref=e6327bc8b8d437b66ff91d9ce798a9eb45310967", "patch": "@@ -1 +1 @@\n-0.9.2\n\\ No newline at end of file\n+0.9.3\n\\ No newline at end of file"}, {"sha": "cea9b770f2a20a8b4e66b53c5256ff11eeddf026", "filename": "src/ci/scripts/upload-artifacts.sh", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e6327bc8b8d437b66ff91d9ce798a9eb45310967/src%2Fci%2Fscripts%2Fupload-artifacts.sh", "raw_url": "https://github.com/rust-lang/rust/raw/e6327bc8b8d437b66ff91d9ce798a9eb45310967/src%2Fci%2Fscripts%2Fupload-artifacts.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fscripts%2Fupload-artifacts.sh?ref=e6327bc8b8d437b66ff91d9ce798a9eb45310967", "patch": "@@ -38,4 +38,5 @@ if [[ \"${DEPLOY_ALT-0}\" -eq \"1\" ]]; then\n fi\n deploy_url=\"s3://${DEPLOY_BUCKET}/${deploy_dir}/$(ciCommit)\"\n \n-retry aws s3 cp --no-progress --recursive --acl public-read \"${upload_dir}\" \"${deploy_url}\"\n+retry aws s3 cp --storage-class INTELLIGENT_TIERING \\\n+    --no-progress --recursive --acl public-read \"${upload_dir}\" \"${deploy_url}\""}, {"sha": "81f961992b6f15a97bb15fc56d9f425ed3bc2a07", "filename": "src/librustdoc/html/render/context.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e6327bc8b8d437b66ff91d9ce798a9eb45310967/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6327bc8b8d437b66ff91d9ce798a9eb45310967/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs?ref=e6327bc8b8d437b66ff91d9ce798a9eb45310967", "patch": "@@ -596,9 +596,19 @@ impl<'tcx> FormatRenderer<'tcx> for Context<'tcx> {\n             |buf: &mut Buffer| {\n                 write!(\n                     buf,\n-                    \"<link rel=\\\"stylesheet\\\" type=\\\"text/css\\\" \\\n-                        href=\\\"{root_path}settings{suffix}.css\\\">\\\n-                    <script defer src=\\\"{root_path}settings{suffix}.js\\\"></script>\",\n+                    \"<div class=\\\"main-heading\\\">\\\n+                     <h1 class=\\\"fqn\\\">\\\n+                         <span class=\\\"in-band\\\">Rustdoc settings</span>\\\n+                     </h1>\\\n+                     <span class=\\\"out-of-band\\\">\\\n+                         <a id=\\\"back\\\" href=\\\"javascript:void(0)\\\" onclick=\\\"history.back();\\\">\\\n+                            Back\\\n+                        </a>\\\n+                     </span>\\\n+                     </div>\\\n+                     <link rel=\\\"stylesheet\\\" type=\\\"text/css\\\" \\\n+                         href=\\\"{root_path}settings{suffix}.css\\\">\\\n+                     <script defer src=\\\"{root_path}settings{suffix}.js\\\"></script>\",\n                     root_path = page.static_root_path.unwrap_or(\"\"),\n                     suffix = page.resource_suffix,\n                 )"}, {"sha": "8770cc3f3b1490b422d0a94d4fbc055b034ebc49", "filename": "src/librustdoc/html/static/js/settings.js", "status": "modified", "additions": 2, "deletions": 16, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e6327bc8b8d437b66ff91d9ce798a9eb45310967/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsettings.js", "raw_url": "https://github.com/rust-lang/rust/raw/e6327bc8b8d437b66ff91d9ce798a9eb45310967/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsettings.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsettings.js?ref=e6327bc8b8d437b66ff91d9ce798a9eb45310967", "patch": "@@ -206,22 +206,8 @@\n         ];\n \n         // Then we build the DOM.\n-        let innerHTML = \"\";\n-        let elementKind = \"div\";\n-\n-        if (isSettingsPage) {\n-            elementKind = \"section\";\n-            innerHTML = `<div class=\"main-heading\">\n-                <h1 class=\"fqn\">\n-                    <span class=\"in-band\">Rustdoc settings</span>\n-                </h1>\n-                <span class=\"out-of-band\">\n-                    <a id=\"back\" href=\"javascript:void(0)\" onclick=\"history.back();\">Back</a>\n-                </span>\n-                </div>`;\n-        }\n-        innerHTML += `<div class=\"settings\">${buildSettingsPageSections(settings)}</div>`;\n-\n+        const elementKind = isSettingsPage ? \"section\" : \"div\";\n+        const innerHTML = `<div class=\"settings\">${buildSettingsPageSections(settings)}</div>`;\n         const el = document.createElement(elementKind);\n         el.id = \"settings\";\n         el.innerHTML = innerHTML;"}, {"sha": "a4c1cd0eb6b18082a7e693f5a665548fe1534be4", "filename": "src/tools/cargo", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcargo?ref=e6327bc8b8d437b66ff91d9ce798a9eb45310967", "patch": "@@ -1 +1 @@\n-Subproject commit 3f052d8eed98c6a24f8b332fb2e6e6249d12d8c1\n+Subproject commit a4c1cd0eb6b18082a7e693f5a665548fe1534be4"}]}