{"sha": "2ca6eaedae9ec4bff2a63f81f473aba653e46ac5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJjYTZlYWVkYWU5ZWM0YmZmMmE2M2Y4MWY0NzNhYmE2NTNlNDZhYzU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-03-02T20:26:39Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-03-02T20:26:39Z"}, "message": "Auto merge of #22963 - Manishearth:rollup, r=Manishearth", "tree": {"sha": "c0f79ec53e9f9ca46755b5ddccc42e67ebbb69a7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c0f79ec53e9f9ca46755b5ddccc42e67ebbb69a7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2ca6eaedae9ec4bff2a63f81f473aba653e46ac5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2ca6eaedae9ec4bff2a63f81f473aba653e46ac5", "html_url": "https://github.com/rust-lang/rust/commit/2ca6eaedae9ec4bff2a63f81f473aba653e46ac5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2ca6eaedae9ec4bff2a63f81f473aba653e46ac5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1cc8b6ec664f30b43f75551e95299d943c8a4e6a", "url": "https://api.github.com/repos/rust-lang/rust/commits/1cc8b6ec664f30b43f75551e95299d943c8a4e6a", "html_url": "https://github.com/rust-lang/rust/commit/1cc8b6ec664f30b43f75551e95299d943c8a4e6a"}, {"sha": "c4b1500fec44c4ed967542fda3cd9c104addbb80", "url": "https://api.github.com/repos/rust-lang/rust/commits/c4b1500fec44c4ed967542fda3cd9c104addbb80", "html_url": "https://github.com/rust-lang/rust/commit/c4b1500fec44c4ed967542fda3cd9c104addbb80"}], "stats": {"total": 393, "additions": 125, "deletions": 268}, "files": [{"sha": "d145eaada2b0e0f1f81c87bfaf2f3a6ba82d3ea3", "filename": "src/doc/intro.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2ca6eaedae9ec4bff2a63f81f473aba653e46ac5/src%2Fdoc%2Fintro.md", "raw_url": "https://github.com/rust-lang/rust/raw/2ca6eaedae9ec4bff2a63f81f473aba653e46ac5/src%2Fdoc%2Fintro.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fintro.md?ref=2ca6eaedae9ec4bff2a63f81f473aba653e46ac5", "patch": "@@ -510,10 +510,10 @@ numbers[1] is 3\n numbers[0] is 2\n ```\n \n-Each time, we can get a slithtly different output because the threads\n-are not quaranteed to run in any set order. If you get the same order\n-every time it is because each of these threads are very small and\n-complete too fast for their indeterminate behavior to surface.\n+Each time, we can get a slightly different output because the threads are not\n+guaranteed to run in any set order. If you get the same order every time it is\n+because each of these threads are very small and complete too fast for their\n+indeterminate behavior to surface.\n \n The important part here is that the Rust compiler was able to use ownership to\n give us assurance _at compile time_ that we weren't doing something incorrect"}, {"sha": "4e7222269a8ff1954f4fcffccd2271e0762816c0", "filename": "src/doc/trpl/guessing-game.md", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2ca6eaedae9ec4bff2a63f81f473aba653e46ac5/src%2Fdoc%2Ftrpl%2Fguessing-game.md", "raw_url": "https://github.com/rust-lang/rust/raw/2ca6eaedae9ec4bff2a63f81f473aba653e46ac5/src%2Fdoc%2Ftrpl%2Fguessing-game.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fguessing-game.md?ref=2ca6eaedae9ec4bff2a63f81f473aba653e46ac5", "patch": "@@ -422,11 +422,11 @@ In this case, we say `x` is a `u32` explicitly, so Rust is able to properly\n tell `random()` what to generate. In a similar fashion, both of these work:\n \n ```{rust,ignore}\n-let input_num = \"5\".parse::<u32>(); // input_num: Option<u32>\n-let input_num: Result<u32, _> = \"5\".parse(); // input_num: Result<u32, <u32 as FromStr>::Err>\n+let input_num_option = \"5\".parse::<u32>().ok(); // input_num: Option<u32>\n+let input_num_result: Result<u32, _> = \"5\".parse(); // input_num: Result<u32, <u32 as FromStr>::Err>\n ```\n \n-Here we're converting the `Result` returned by `parse` to an `Option` by using\n+Above, we're converting the `Result` returned by `parse` to an `Option` by using\n the `ok` method as well.  Anyway, with us now converting our input to a number,\n our code looks like this:\n \n@@ -470,14 +470,14 @@ Let's try it out!\n ```bash\n $ cargo build\n    Compiling guessing_game v0.0.1 (file:///home/you/projects/guessing_game)\n-src/main.rs:22:15: 22:24 error: mismatched types: expected `u32` but found `core::option::Option<u32>` (expected u32 but found enum core::option::Option)\n-src/main.rs:22     match cmp(input_num, secret_number) {\n+src/main.rs:21:15: 21:24 error: mismatched types: expected `u32`, found `core::result::Result<u32, core::num::ParseIntError>` (expected u32, found enum `core::result::Result`) [E0308]\n+src/main.rs:21     match cmp(input_num, secret_number) {\n                              ^~~~~~~~~\n error: aborting due to previous error\n ```\n \n-Oh yeah! Our `input_num` has the type `Option<u32>`, rather than `u32`. We\n-need to unwrap the Option. If you remember from before, `match` is a great way\n+Oh yeah! Our `input_num` has the type `Result<u32, <some error>>`, rather than `u32`. We\n+need to unwrap the Result. If you remember from before, `match` is a great way\n to do that. Try this code:\n \n ```{rust,no_run}\n@@ -500,7 +500,7 @@ fn main() {\n     let input_num: Result<u32, _> = input.parse();\n \n     let num = match input_num {\n-        Ok(num) => num,\n+        Ok(n) => n,\n         Err(_) => {\n             println!(\"Please input a number!\");\n             return;\n@@ -524,7 +524,7 @@ fn cmp(a: u32, b: u32) -> Ordering {\n }\n ```\n \n-We use a `match` to either give us the `u32` inside of the `Option`, or else\n+We use a `match` to either give us the `u32` inside of the `Result`, or else\n print an error message and return. Let's give this a shot:\n \n ```bash"}, {"sha": "5a20ba4b49f0f2bd15d683e32f4fd20fe970a5b7", "filename": "src/libcollections/fmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ca6eaedae9ec4bff2a63f81f473aba653e46ac5/src%2Flibcollections%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ca6eaedae9ec4bff2a63f81f473aba653e46ac5/src%2Flibcollections%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ffmt.rs?ref=2ca6eaedae9ec4bff2a63f81f473aba653e46ac5", "patch": "@@ -364,7 +364,7 @@\n //!     * `o` - precedes the argument with a \"0o\"\n //! * '0' - This is used to indicate for integer formats that the padding should\n //!         both be done with a `0` character as well as be sign-aware. A format\n-//!         like `{:08d}` would yield `00000001` for the integer `1`, while the\n+//!         like `{:08}` would yield `00000001` for the integer `1`, while the\n //!         same format would yield `-0000001` for the integer `-1`. Notice that\n //!         the negative version has one fewer zero than the positive version.\n //!"}, {"sha": "b33839f33e8203d7a08a8ea0be86294b9f47ec33", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2ca6eaedae9ec4bff2a63f81f473aba653e46ac5/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ca6eaedae9ec4bff2a63f81f473aba653e46ac5/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=2ca6eaedae9ec4bff2a63f81f473aba653e46ac5", "patch": "@@ -555,11 +555,9 @@ fn parse_ty_<'a, 'tcx, F>(st: &mut PState<'a, 'tcx>, conv: &mut F) -> Ty<'tcx> w\n       'k' => {\n           assert_eq!(next(st), '[');\n           let did = parse_def_(st, ClosureSource, conv);\n-          let region = parse_region_(st, conv);\n           let substs = parse_substs_(st, conv);\n           assert_eq!(next(st), ']');\n-          return ty::mk_closure(st.tcx, did,\n-                  st.tcx.mk_region(region), st.tcx.mk_substs(substs));\n+          return ty::mk_closure(st.tcx, did, st.tcx.mk_substs(substs));\n       }\n       'P' => {\n           assert_eq!(next(st), '[');"}, {"sha": "ebb4153e32bce9e90e1432e73e1643a97a479a95", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2ca6eaedae9ec4bff2a63f81f473aba653e46ac5/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ca6eaedae9ec4bff2a63f81f473aba653e46ac5/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=2ca6eaedae9ec4bff2a63f81f473aba653e46ac5", "patch": "@@ -139,9 +139,8 @@ pub fn enc_ty<'a, 'tcx>(w: &mut SeekableMemWriter, cx: &ctxt<'a, 'tcx>, t: Ty<'t\n             enc_substs(w, cx, substs);\n             mywrite!(w, \"]\");\n         }\n-        ty::ty_closure(def, region, substs) => {\n+        ty::ty_closure(def, substs) => {\n             mywrite!(w, \"k[{}|\", (cx.ds)(def));\n-            enc_region(w, cx, *region);\n             enc_substs(w, cx, substs);\n             mywrite!(w, \"]\");\n         }"}, {"sha": "063845c6c34255df36dcf0dad2fc04c8bb2c39d3", "filename": "src/librustc/middle/fast_reject.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ca6eaedae9ec4bff2a63f81f473aba653e46ac5/src%2Flibrustc%2Fmiddle%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ca6eaedae9ec4bff2a63f81f473aba653e46ac5/src%2Flibrustc%2Fmiddle%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffast_reject.rs?ref=2ca6eaedae9ec4bff2a63f81f473aba653e46ac5", "patch": "@@ -74,7 +74,7 @@ pub fn simplify_type(tcx: &ty::ctxt,\n             let def_id = tcx.lang_items.owned_box().unwrap();\n             Some(StructSimplifiedType(def_id))\n         }\n-        ty::ty_closure(def_id, _, _) => {\n+        ty::ty_closure(def_id, _) => {\n             Some(ClosureSimplifiedType(def_id))\n         }\n         ty::ty_tup(ref tys) => {"}, {"sha": "be94a73df37ba82d7b4c02c4427b8a58588ef67b", "filename": "src/librustc/middle/infer/combine.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2ca6eaedae9ec4bff2a63f81f473aba653e46ac5/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ca6eaedae9ec4bff2a63f81f473aba653e46ac5/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs?ref=2ca6eaedae9ec4bff2a63f81f473aba653e46ac5", "patch": "@@ -503,15 +503,14 @@ pub fn super_tys<'tcx, C>(this: &C,\n             Ok(ty::mk_struct(tcx, a_id, tcx.mk_substs(substs)))\n         }\n \n-        (&ty::ty_closure(a_id, a_region, a_substs),\n-         &ty::ty_closure(b_id, b_region, b_substs))\n+        (&ty::ty_closure(a_id, a_substs),\n+         &ty::ty_closure(b_id, b_substs))\n           if a_id == b_id => {\n             // All ty_closure types with the same id represent\n             // the (anonymous) type of the same closure expression. So\n             // all of their regions should be equated.\n-            let region = try!(this.equate().regions(*a_region, *b_region));\n             let substs = try!(this.substs_variances(None, a_substs, b_substs));\n-            Ok(ty::mk_closure(tcx, a_id, tcx.mk_region(region), tcx.mk_substs(substs)))\n+            Ok(ty::mk_closure(tcx, a_id, tcx.mk_substs(substs)))\n         }\n \n         (&ty::ty_uniq(a_inner), &ty::ty_uniq(b_inner)) => {"}, {"sha": "224a568c77f02277985a03af03ee9fe1a7dc9a54", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ca6eaedae9ec4bff2a63f81f473aba653e46ac5/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ca6eaedae9ec4bff2a63f81f473aba653e46ac5/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=2ca6eaedae9ec4bff2a63f81f473aba653e46ac5", "patch": "@@ -1496,7 +1496,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     fn fn_ret(&self, id: NodeId) -> ty::PolyFnOutput<'tcx> {\n         let fn_ty = ty::node_id_to_type(self.ir.tcx, id);\n         match fn_ty.sty {\n-            ty::ty_closure(closure_def_id, _, substs) =>\n+            ty::ty_closure(closure_def_id, substs) =>\n                 self.ir.tcx.closure_type(closure_def_id, substs).sig.output(),\n             _ =>\n                 ty::ty_fn_ret(fn_ty),"}, {"sha": "1f02f13a4a17823312e934e27c912d5e8a7e45e0", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ca6eaedae9ec4bff2a63f81f473aba653e46ac5/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ca6eaedae9ec4bff2a63f81f473aba653e46ac5/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=2ca6eaedae9ec4bff2a63f81f473aba653e46ac5", "patch": "@@ -607,7 +607,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n           def::DefUpvar(var_id, fn_node_id) => {\n               let ty = try!(self.node_ty(fn_node_id));\n               match ty.sty {\n-                  ty::ty_closure(closure_id, _, _) => {\n+                  ty::ty_closure(closure_id, _) => {\n                       match self.typer.closure_kind(closure_id) {\n                           Some(kind) => {\n                               self.cat_upvar(id, span, var_id, fn_node_id, kind)"}, {"sha": "b4db3aba7867dc72cbaec8a3519dd07c5725a32f", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ca6eaedae9ec4bff2a63f81f473aba653e46ac5/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ca6eaedae9ec4bff2a63f81f473aba653e46ac5/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=2ca6eaedae9ec4bff2a63f81f473aba653e46ac5", "patch": "@@ -320,8 +320,10 @@ impl InnermostEnclosingExpr {\n \n #[derive(Debug, Copy)]\n pub struct Context {\n+    /// the scope that contains any new variables declared\n     var_parent: InnermostDeclaringBlock,\n \n+    /// region parent of expressions etc\n     parent: InnermostEnclosingExpr,\n }\n "}, {"sha": "b9a863f4fe46f51738edc029115ad6dca2304fe6", "filename": "src/librustc/middle/traits/project.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ca6eaedae9ec4bff2a63f81f473aba653e46ac5/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ca6eaedae9ec4bff2a63f81f473aba653e46ac5/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs?ref=2ca6eaedae9ec4bff2a63f81f473aba653e46ac5", "patch": "@@ -154,7 +154,7 @@ fn consider_unification_despite_ambiguity<'cx,'tcx>(selcx: &mut SelectionContext\n     debug!(\"consider_unification_despite_ambiguity: self_ty.sty={:?}\",\n            self_ty.sty);\n     match self_ty.sty {\n-        ty::ty_closure(closure_def_id, _, substs) => {\n+        ty::ty_closure(closure_def_id, substs) => {\n             let closure_typer = selcx.closure_typer();\n             let closure_type = closure_typer.closure_type(closure_def_id, substs);\n             let ty::Binder((_, ret_type)) ="}, {"sha": "470315c78f81d8d15ac1908c4b1988be543155df", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2ca6eaedae9ec4bff2a63f81f473aba653e46ac5/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ca6eaedae9ec4bff2a63f81f473aba653e46ac5/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=2ca6eaedae9ec4bff2a63f81f473aba653e46ac5", "patch": "@@ -293,7 +293,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // lifetimes can appear inside the self-type.\n         let self_ty = self.infcx.shallow_resolve(obligation.self_ty());\n         let (closure_def_id, substs) = match self_ty.sty {\n-            ty::ty_closure(id, _, ref substs) => (id, substs.clone()),\n+            ty::ty_closure(id, ref substs) => (id, substs.clone()),\n             _ => { return; }\n         };\n         assert!(!substs.has_escaping_regions());\n@@ -1054,7 +1054,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         let self_ty = self.infcx.shallow_resolve(obligation.self_ty());\n         let (closure_def_id, substs) = match self_ty.sty {\n-            ty::ty_closure(id, _, ref substs) => (id, substs.clone()),\n+            ty::ty_closure(id, ref substs) => (id, substs.clone()),\n             ty::ty_infer(ty::TyVar(_)) => {\n                 debug!(\"assemble_unboxed_closure_candidates: ambiguous self-type\");\n                 candidates.ambiguous = true;\n@@ -1533,7 +1533,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             // (T1, ..., Tn) -- meets any bound that all of T1...Tn meet\n             ty::ty_tup(ref tys) => Ok(If(tys.clone())),\n \n-            ty::ty_closure(def_id, _, substs) => {\n+            ty::ty_closure(def_id, substs) => {\n                 // FIXME -- This case is tricky. In the case of by-ref\n                 // closures particularly, we need the results of\n                 // inference to decide how to reflect the type of each\n@@ -1687,7 +1687,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 Some(tys.clone())\n             }\n \n-            ty::ty_closure(def_id, _, substs) => {\n+            ty::ty_closure(def_id, substs) => {\n                 assert_eq!(def_id.krate, ast::LOCAL_CRATE);\n \n                 match self.closure_typer.closure_upvars(def_id, substs) {"}, {"sha": "aaba840825e69ea23248efe10c6c47d9f96f88a4", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 9, "deletions": 15, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/2ca6eaedae9ec4bff2a63f81f473aba653e46ac5/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ca6eaedae9ec4bff2a63f81f473aba653e46ac5/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=2ca6eaedae9ec4bff2a63f81f473aba653e46ac5", "patch": "@@ -1367,7 +1367,7 @@ pub enum sty<'tcx> {\n     ty_trait(Box<TyTrait<'tcx>>),\n     ty_struct(DefId, &'tcx Substs<'tcx>),\n \n-    ty_closure(DefId, &'tcx Region, &'tcx Substs<'tcx>),\n+    ty_closure(DefId, &'tcx Substs<'tcx>),\n \n     ty_tup(Vec<Ty<'tcx>>),\n \n@@ -2658,8 +2658,7 @@ impl FlagComputation {\n                 }\n             }\n \n-            &ty_closure(_, region, substs) => {\n-                self.add_region(*region);\n+            &ty_closure(_, substs) => {\n                 self.add_substs(substs);\n             }\n \n@@ -2927,10 +2926,9 @@ pub fn mk_struct<'tcx>(cx: &ctxt<'tcx>, struct_id: ast::DefId,\n     mk_t(cx, ty_struct(struct_id, substs))\n }\n \n-pub fn mk_closure<'tcx>(cx: &ctxt<'tcx>, closure_id: ast::DefId,\n-                        region: &'tcx Region, substs: &'tcx Substs<'tcx>)\n+pub fn mk_closure<'tcx>(cx: &ctxt<'tcx>, closure_id: ast::DefId, substs: &'tcx Substs<'tcx>)\n                         -> Ty<'tcx> {\n-    mk_t(cx, ty_closure(closure_id, region, substs))\n+    mk_t(cx, ty_closure(closure_id, substs))\n }\n \n pub fn mk_var<'tcx>(cx: &ctxt<'tcx>, v: TyVid) -> Ty<'tcx> {\n@@ -3513,13 +3511,11 @@ pub fn type_contents<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> TypeContents {\n                 apply_lang_items(cx, did, res)\n             }\n \n-            ty_closure(did, r, substs) => {\n+            ty_closure(did, substs) => {\n                 // FIXME(#14449): `borrowed_contents` below assumes `&mut` closure.\n                 let param_env = ty::empty_parameter_environment(cx);\n                 let upvars = closure_upvars(&param_env, did, substs).unwrap();\n-                TypeContents::union(&upvars,\n-                                    |f| tc_ty(cx, &f.ty, cache))\n-                    | borrowed_contents(*r, MutMutable)\n+                TypeContents::union(&upvars, |f| tc_ty(cx, &f.ty, cache))\n             }\n \n             ty_tup(ref tys) => {\n@@ -5175,7 +5171,7 @@ pub fn ty_to_def_id(ty: Ty) -> Option<ast::DefId> {\n             Some(tt.principal_def_id()),\n         ty_struct(id, _) |\n         ty_enum(id, _) |\n-        ty_closure(id, _, _) =>\n+        ty_closure(id, _) =>\n             Some(id),\n         _ =>\n             None\n@@ -6301,10 +6297,9 @@ pub fn hash_crate_independent<'tcx>(tcx: &ctxt<'tcx>, ty: Ty<'tcx>, svh: &Svh) -\n                 }\n                 ty_infer(_) => unreachable!(),\n                 ty_err => byte!(21),\n-                ty_closure(d, r, _) => {\n+                ty_closure(d, _) => {\n                     byte!(22);\n                     did(state, d);\n-                    region(state, *r);\n                 }\n                 ty_projection(ref data) => {\n                     byte!(23);\n@@ -6618,8 +6613,7 @@ pub fn accumulate_lifetimes_in_type(accumulator: &mut Vec<ty::Region>,\n             ty_struct(_, substs) => {\n                 accum_substs(accumulator, substs);\n             }\n-            ty_closure(_, region, substs) => {\n-                accumulator.push(*region);\n+            ty_closure(_, substs) => {\n                 accum_substs(accumulator, substs);\n             }\n             ty_bool |"}, {"sha": "1b904aacc301210558fabc24baedcab941a0643d", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2ca6eaedae9ec4bff2a63f81f473aba653e46ac5/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ca6eaedae9ec4bff2a63f81f473aba653e46ac5/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=2ca6eaedae9ec4bff2a63f81f473aba653e46ac5", "patch": "@@ -650,10 +650,9 @@ pub fn super_fold_ty<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n             let substs = substs.fold_with(this);\n             ty::ty_struct(did, this.tcx().mk_substs(substs))\n         }\n-        ty::ty_closure(did, ref region, ref substs) => {\n-            let r = region.fold_with(this);\n+        ty::ty_closure(did, ref substs) => {\n             let s = substs.fold_with(this);\n-            ty::ty_closure(did, this.tcx().mk_region(r), this.tcx().mk_substs(s))\n+            ty::ty_closure(did, this.tcx().mk_substs(s))\n         }\n         ty::ty_projection(ref data) => {\n             ty::ty_projection(data.fold_with(this))"}, {"sha": "5b5eac451783a8502edb0844d53bd9c221dde5bf", "filename": "src/librustc/middle/ty_walk.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ca6eaedae9ec4bff2a63f81f473aba653e46ac5/src%2Flibrustc%2Fmiddle%2Fty_walk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ca6eaedae9ec4bff2a63f81f473aba653e46ac5/src%2Flibrustc%2Fmiddle%2Fty_walk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_walk.rs?ref=2ca6eaedae9ec4bff2a63f81f473aba653e46ac5", "patch": "@@ -45,7 +45,7 @@ impl<'tcx> TypeWalker<'tcx> {\n             }\n             ty::ty_enum(_, ref substs) |\n             ty::ty_struct(_, ref substs) |\n-            ty::ty_closure(_, _, ref substs) => {\n+            ty::ty_closure(_, ref substs) => {\n                 self.push_reversed(substs.types.as_slice());\n             }\n             ty::ty_tup(ref ts) => {"}, {"sha": "0eeb746022c0d74e1a9ad29cc34fdd96ef3c1d54", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ca6eaedae9ec4bff2a63f81f473aba653e46ac5/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ca6eaedae9ec4bff2a63f81f473aba653e46ac5/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=2ca6eaedae9ec4bff2a63f81f473aba653e46ac5", "patch": "@@ -406,7 +406,7 @@ pub fn ty_to_string<'tcx>(cx: &ctxt<'tcx>, typ: &ty::TyS<'tcx>) -> String {\n                     data.item_name.user_string(cx))\n         }\n         ty_str => \"str\".to_string(),\n-        ty_closure(ref did, _, substs) => {\n+        ty_closure(ref did, substs) => {\n             let closure_tys = cx.closure_tys.borrow();\n             closure_tys.get(did).map(|closure_type| {\n                 closure_to_string(cx, &closure_type.subst(cx, substs))"}, {"sha": "2fb0488cd704e04b8912da4d3a89523117d4eb7a", "filename": "src/librustc_trans/trans/adt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ca6eaedae9ec4bff2a63f81f473aba653e46ac5/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ca6eaedae9ec4bff2a63f81f473aba653e46ac5/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fadt.rs?ref=2ca6eaedae9ec4bff2a63f81f473aba653e46ac5", "patch": "@@ -169,7 +169,7 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n             Univariant(mk_struct(cx, &ftys[..], packed, t), dtor)\n         }\n-        ty::ty_closure(def_id, _, substs) => {\n+        ty::ty_closure(def_id, substs) => {\n             let typer = NormalizingClosureTyper::new(cx.tcx());\n             let upvars = typer.closure_upvars(def_id, substs).unwrap();\n             let upvar_types = upvars.iter().map(|u| u.ty).collect::<Vec<_>>();"}, {"sha": "7a6960d379026cf612680423dfb79987a0a76962", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2ca6eaedae9ec4bff2a63f81f473aba653e46ac5/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ca6eaedae9ec4bff2a63f81f473aba653e46ac5/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=2ca6eaedae9ec4bff2a63f81f473aba653e46ac5", "patch": "@@ -291,7 +291,7 @@ pub fn decl_rust_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         ty::ty_bare_fn(_, ref f) => {\n             (&f.sig, f.abi, None)\n         }\n-        ty::ty_closure(closure_did, _, substs) => {\n+        ty::ty_closure(closure_did, substs) => {\n             let typer = common::NormalizingClosureTyper::new(ccx.tcx());\n             function_type = typer.closure_type(closure_did, substs);\n             let self_type = self_type_for_closure(ccx, closure_did, fn_ty);\n@@ -685,7 +685,7 @@ pub fn iter_structural_ty<'blk, 'tcx, F>(cx: Block<'blk, 'tcx>,\n               }\n           })\n       }\n-      ty::ty_closure(def_id, _, substs) => {\n+      ty::ty_closure(def_id, substs) => {\n           let repr = adt::represent_type(cx.ccx(), t);\n           let typer = common::NormalizingClosureTyper::new(cx.tcx());\n           let upvars = typer.closure_upvars(def_id, substs).unwrap();\n@@ -2437,7 +2437,7 @@ pub fn get_fn_llvm_attributes<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_ty: Ty<\n     let function_type;\n     let (fn_sig, abi, env_ty) = match fn_ty.sty {\n         ty::ty_bare_fn(_, ref f) => (&f.sig, f.abi, None),\n-        ty::ty_closure(closure_did, _, substs) => {\n+        ty::ty_closure(closure_did, substs) => {\n             let typer = common::NormalizingClosureTyper::new(ccx.tcx());\n             function_type = typer.closure_type(closure_did, substs);\n             let self_type = self_type_for_closure(ccx, closure_did, fn_ty);\n@@ -2454,7 +2454,7 @@ pub fn get_fn_llvm_attributes<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_ty: Ty<\n     // These have an odd calling convention, so we need to manually\n     // unpack the input ty's\n     let input_tys = match fn_ty.sty {\n-        ty::ty_closure(_, _, _) => {\n+        ty::ty_closure(..) => {\n             assert!(abi == RustCall);\n \n             match fn_sig.inputs[0].sty {"}, {"sha": "7fa26a7c1284196292c92c22ffe6bf4d5f30c3c3", "filename": "src/librustc_trans/trans/closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ca6eaedae9ec4bff2a63f81f473aba653e46ac5/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ca6eaedae9ec4bff2a63f81f473aba653e46ac5/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs?ref=2ca6eaedae9ec4bff2a63f81f473aba653e46ac5", "patch": "@@ -138,7 +138,7 @@ pub fn get_or_create_declaration_if_closure<'a, 'tcx>(ccx: &CrateContext<'a, 'tc\n     // duplicate declarations\n     let function_type = erase_regions(ccx.tcx(), &function_type);\n     let params = match function_type.sty {\n-        ty::ty_closure(_, _, substs) => &substs.types,\n+        ty::ty_closure(_, substs) => &substs.types,\n         _ => unreachable!()\n     };\n     let mono_id = MonoId {"}, {"sha": "f3b7058336b2fc350bf0a0257606a5a508976314", "filename": "src/librustc_trans/trans/debuginfo.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2ca6eaedae9ec4bff2a63f81f473aba653e46ac5/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ca6eaedae9ec4bff2a63f81f473aba653e46ac5/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs?ref=2ca6eaedae9ec4bff2a63f81f473aba653e46ac5", "patch": "@@ -472,7 +472,7 @@ impl<'tcx> TypeMap<'tcx> {\n                     }\n                 }\n             },\n-            ty::ty_closure(def_id, _, substs) => {\n+            ty::ty_closure(def_id, substs) => {\n                 let typer = NormalizingClosureTyper::new(cx.tcx());\n                 let closure_ty = typer.closure_type(def_id, substs);\n                 self.get_unique_type_id_of_closure_type(cx,\n@@ -2983,7 +2983,7 @@ fn type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         ty::ty_bare_fn(_, ref barefnty) => {\n             subroutine_type_metadata(cx, unique_type_id, &barefnty.sig, usage_site_span)\n         }\n-        ty::ty_closure(def_id, _, substs) => {\n+        ty::ty_closure(def_id, substs) => {\n             let typer = NormalizingClosureTyper::new(cx.tcx());\n             let sig = typer.closure_type(def_id, substs).sig;\n             subroutine_type_metadata(cx, unique_type_id, &sig, usage_site_span)"}, {"sha": "1151b11d21f35ce4faebacb7c8b606b7c0062c25", "filename": "src/librustc_trans/trans/glue.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2ca6eaedae9ec4bff2a63f81f473aba653e46ac5/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ca6eaedae9ec4bff2a63f81f473aba653e46ac5/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fglue.rs?ref=2ca6eaedae9ec4bff2a63f81f473aba653e46ac5", "patch": "@@ -313,8 +313,7 @@ fn trans_struct_drop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                      ty::mk_nil(bcx.tcx()));\n         let (_, variant_cx) = invoke(variant_cx, dtor_addr, &args[..], dtor_ty, DebugLoc::None);\n \n-        variant_cx.fcx.pop_and_trans_custom_cleanup_scope(variant_cx, field_scope);\n-        variant_cx\n+        variant_cx.fcx.pop_and_trans_custom_cleanup_scope(variant_cx, field_scope)\n     })\n }\n "}, {"sha": "f9495af79c5b0c5969a5bba8a2d157ee272eb39d", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ca6eaedae9ec4bff2a63f81f473aba653e46ac5/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ca6eaedae9ec4bff2a63f81f473aba653e46ac5/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=2ca6eaedae9ec4bff2a63f81f473aba653e46ac5", "patch": "@@ -137,7 +137,7 @@ fn try_overloaded_call_step<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             return Some(CallStep::Builtin);\n         }\n \n-        ty::ty_closure(def_id, _, substs) => {\n+        ty::ty_closure(def_id, substs) => {\n             assert_eq!(def_id.krate, ast::LOCAL_CRATE);\n \n             // Check whether this is a call to a closure where we"}, {"sha": "0d4edc01a4c1d73ae16c821e52de1a940b8d6f09", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2ca6eaedae9ec4bff2a63f81f473aba653e46ac5/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ca6eaedae9ec4bff2a63f81f473aba653e46ac5/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=2ca6eaedae9ec4bff2a63f81f473aba653e46ac5", "patch": "@@ -16,7 +16,6 @@ use astconv;\n use middle::region;\n use middle::subst;\n use middle::ty::{self, ToPolyTraitRef, Ty};\n-use rscope::RegionScope;\n use syntax::abi;\n use syntax::ast;\n use syntax::ast_util;\n@@ -61,17 +60,8 @@ fn check_closure<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n         abi::RustCall,\n         expected_sig);\n \n-    let region = match fcx.anon_regions(expr.span, 1) {\n-        Err(_) => {\n-            fcx.ccx.tcx.sess.span_bug(expr.span,\n-                                      \"can't make anon regions here?!\")\n-        }\n-        Ok(regions) => regions[0],\n-    };\n-\n     let closure_type = ty::mk_closure(fcx.ccx.tcx,\n                                       expr_def_id,\n-                                      fcx.ccx.tcx.mk_region(region),\n                                       fcx.ccx.tcx.mk_substs(\n                                         fcx.inh.param_env.free_substs.clone()));\n "}, {"sha": "f99ba8940297dbc6c2a9a7e747bd3d5e72cbc9d7", "filename": "src/librustc_typeck/check/implicator.rs", "status": "modified", "additions": 11, "deletions": 23, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/2ca6eaedae9ec4bff2a63f81f473aba653e46ac5/src%2Flibrustc_typeck%2Fcheck%2Fimplicator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ca6eaedae9ec4bff2a63f81f473aba653e46ac5/src%2Flibrustc_typeck%2Fcheck%2Fimplicator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fimplicator.rs?ref=2ca6eaedae9ec4bff2a63f81f473aba653e46ac5", "patch": "@@ -29,6 +29,7 @@ use util::ppaux::Repr;\n pub enum Implication<'tcx> {\n     RegionSubRegion(Option<Ty<'tcx>>, ty::Region, ty::Region),\n     RegionSubGeneric(Option<Ty<'tcx>>, ty::Region, GenericKind<'tcx>),\n+    RegionSubClosure(Option<Ty<'tcx>>, ty::Region, ast::DefId, &'tcx Substs<'tcx>),\n     Predicate(ast::DefId, ty::Predicate<'tcx>),\n }\n \n@@ -91,29 +92,9 @@ impl<'a, 'tcx> Implicator<'a, 'tcx> {\n                 // No borrowed content reachable here.\n             }\n \n-            ty::ty_closure(_, region, _) => {\n-                // An \"closure type\" is basically\n-                // modeled here as equivalent to a struct like\n-                //\n-                //     struct TheClosure<'b> {\n-                //         ...\n-                //     }\n-                //\n-                // where the `'b` is the lifetime bound of the\n-                // contents (i.e., all contents must outlive 'b).\n-                //\n-                // Even though closures are glorified structs\n-                // of upvars, we do not need to consider them as they\n-                // can't generate any new constraints.  The\n-                // substitutions on the closure are equal to the free\n-                // substitutions of the enclosing parameter\n-                // environment.  An upvar captured by value has the\n-                // same type as the original local variable which is\n-                // already checked for consistency.  If the upvar is\n-                // captured by reference it must also outlive the\n-                // region bound on the closure, but this is explicitly\n-                // handled by logic in regionck.\n-                self.push_region_constraint_from_top(*region);\n+            ty::ty_closure(def_id, substs) => {\n+                let &(r_a, opt_ty) = self.stack.last().unwrap();\n+                self.out.push(Implication::RegionSubClosure(opt_ty, r_a, def_id, substs));\n             }\n \n             ty::ty_trait(ref t) => {\n@@ -448,6 +429,13 @@ impl<'tcx> Repr<'tcx> for Implication<'tcx> {\n                         p.repr(tcx))\n             }\n \n+            Implication::RegionSubClosure(_, ref a, ref b, ref c) => {\n+                format!(\"RegionSubClosure({}, {}, {})\",\n+                        a.repr(tcx),\n+                        b.repr(tcx),\n+                        c.repr(tcx))\n+            }\n+\n             Implication::Predicate(ref def_id, ref p) => {\n                 format!(\"Predicate({}, {})\",\n                         def_id.repr(tcx),"}, {"sha": "fbf002b709ee54e7cc2514eadf75d73b70ed3cc9", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2ca6eaedae9ec4bff2a63f81f473aba653e46ac5/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ca6eaedae9ec4bff2a63f81f473aba653e46ac5/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=2ca6eaedae9ec4bff2a63f81f473aba653e46ac5", "patch": "@@ -278,7 +278,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n             }\n             ty::ty_enum(did, _) |\n             ty::ty_struct(did, _) |\n-            ty::ty_closure(did, _, _) => {\n+            ty::ty_closure(did, _) => {\n                 self.assemble_inherent_impl_candidates_for_type(did);\n             }\n             ty::ty_uniq(_) => {\n@@ -641,8 +641,8 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         // If so, add \"synthetic impls\".\n         let steps = self.steps.clone();\n         for step in &*steps {\n-            let (closure_def_id, _, _) = match step.self_ty.sty {\n-                ty::ty_closure(a, b, ref c) => (a, b, c),\n+            let closure_def_id = match step.self_ty.sty {\n+                ty::ty_closure(a, _) => a,\n                 _ => continue,\n             };\n "}, {"sha": "a3e98b0c4c6582b9df464e50e649906c148b1069", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 31, "deletions": 140, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/2ca6eaedae9ec4bff2a63f81f473aba653e46ac5/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ca6eaedae9ec4bff2a63f81f473aba653e46ac5/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=2ca6eaedae9ec4bff2a63f81f473aba653e46ac5", "patch": "@@ -87,12 +87,11 @@ use check::dropck;\n use check::FnCtxt;\n use check::implicator;\n use check::vtable;\n-use middle::def;\n use middle::mem_categorization as mc;\n use middle::region::CodeExtent;\n+use middle::subst::Substs;\n use middle::traits;\n-use middle::ty::{ReScope};\n-use middle::ty::{self, Ty, MethodCall};\n+use middle::ty::{self, ClosureTyper, ReScope, Ty, MethodCall};\n use middle::infer::{self, GenericKind};\n use middle::pat_util;\n use util::ppaux::{ty_to_string, Repr};\n@@ -179,20 +178,6 @@ pub struct Rcx<'a, 'tcx: 'a> {\n \n }\n \n-/// Returns the validity region of `def` -- that is, how long is `def` valid?\n-fn region_of_def(fcx: &FnCtxt, def: def::Def) -> ty::Region {\n-    let tcx = fcx.tcx();\n-    match def {\n-        def::DefLocal(node_id) | def::DefUpvar(node_id, _) => {\n-            tcx.region_maps.var_region(node_id)\n-        }\n-        _ => {\n-            tcx.sess.bug(&format!(\"unexpected def in region_of_def: {:?}\",\n-                                 def))\n-        }\n-    }\n-}\n-\n struct RepeatingScope(ast::NodeId);\n pub enum SubjectNode { Subject(ast::NodeId), None }\n \n@@ -368,7 +353,15 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n                                                              ty::ReInfer(ty::ReVar(vid_b))) => {\n                         self.fcx.inh.infcx.add_given(free_a, vid_b);\n                     }\n-                    implicator::Implication::RegionSubRegion(..) => {\n+                    implicator::Implication::RegionSubGeneric(_, r_a, ref generic_b) => {\n+                        debug!(\"RegionSubGeneric: {} <= {}\",\n+                               r_a.repr(tcx), generic_b.repr(tcx));\n+\n+                        self.region_bound_pairs.push((r_a, generic_b.clone()));\n+                    }\n+                    implicator::Implication::RegionSubRegion(..) |\n+                    implicator::Implication::RegionSubClosure(..) |\n+                    implicator::Implication::Predicate(..) => {\n                         // In principle, we could record (and take\n                         // advantage of) every relationship here, but\n                         // we are also free not to -- it simply means\n@@ -379,13 +372,6 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n                         // relationship that arises here, but\n                         // presently we do not.)\n                     }\n-                    implicator::Implication::RegionSubGeneric(_, r_a, ref generic_b) => {\n-                        debug!(\"RegionSubGeneric: {} <= {}\",\n-                               r_a.repr(tcx), generic_b.repr(tcx));\n-\n-                        self.region_bound_pairs.push((r_a, generic_b.clone()));\n-                    }\n-                    implicator::Implication::Predicate(..) => { }\n                 }\n             }\n         }\n@@ -792,124 +778,9 @@ fn constrain_cast(rcx: &mut Rcx,\n fn check_expr_fn_block(rcx: &mut Rcx,\n                        expr: &ast::Expr,\n                        body: &ast::Block) {\n-    let tcx = rcx.fcx.tcx();\n-    let function_type = rcx.resolve_node_type(expr.id);\n-\n-    match function_type.sty {\n-        ty::ty_closure(_, region, _) => {\n-            ty::with_freevars(tcx, expr.id, |freevars| {\n-                constrain_captured_variables(rcx, *region, expr, freevars);\n-            })\n-        }\n-        _ => { }\n-    }\n-\n     let repeating_scope = rcx.set_repeating_scope(body.id);\n     visit::walk_expr(rcx, expr);\n     rcx.set_repeating_scope(repeating_scope);\n-\n-    match function_type.sty {\n-        ty::ty_closure(_, region, _) => {\n-            ty::with_freevars(tcx, expr.id, |freevars| {\n-                let bounds = ty::region_existential_bound(*region);\n-                ensure_free_variable_types_outlive_closure_bound(rcx, &bounds, expr, freevars);\n-            })\n-        }\n-        _ => {}\n-    }\n-\n-    /// Make sure that the type of all free variables referenced inside a closure/proc outlive the\n-    /// closure/proc's lifetime bound. This is just a special case of the usual rules about closed\n-    /// over values outliving the object's lifetime bound.\n-    fn ensure_free_variable_types_outlive_closure_bound(\n-        rcx: &mut Rcx,\n-        bounds: &ty::ExistentialBounds,\n-        expr: &ast::Expr,\n-        freevars: &[ty::Freevar])\n-    {\n-        let tcx = rcx.fcx.ccx.tcx;\n-\n-        debug!(\"ensure_free_variable_types_outlive_closure_bound({}, {})\",\n-               bounds.region_bound.repr(tcx), expr.repr(tcx));\n-\n-        for freevar in freevars {\n-            let var_node_id = {\n-                let def_id = freevar.def.def_id();\n-                assert!(def_id.krate == ast::LOCAL_CRATE);\n-                def_id.node\n-            };\n-\n-            // Compute the type of the field in the environment that\n-            // represents `var_node_id`.  For a by-value closure, this\n-            // will be the same as the type of the variable.  For a\n-            // by-reference closure, this will be `&T` where `T` is\n-            // the type of the variable.\n-            let raw_var_ty = rcx.resolve_node_type(var_node_id);\n-            let upvar_id = ty::UpvarId { var_id: var_node_id,\n-                                         closure_expr_id: expr.id };\n-            let var_ty = match rcx.fcx.inh.upvar_capture_map.borrow()[upvar_id] {\n-                ty::UpvarCapture::ByRef(ref upvar_borrow) => {\n-                    ty::mk_rptr(rcx.tcx(),\n-                                rcx.tcx().mk_region(upvar_borrow.region),\n-                                ty::mt { mutbl: upvar_borrow.kind.to_mutbl_lossy(),\n-                                         ty: raw_var_ty })\n-                }\n-                ty::UpvarCapture::ByValue => raw_var_ty,\n-            };\n-\n-            // Check that the type meets the criteria of the existential bounds:\n-            for builtin_bound in &bounds.builtin_bounds {\n-                let code = traits::ClosureCapture(var_node_id, expr.span, builtin_bound);\n-                let cause = traits::ObligationCause::new(freevar.span, rcx.fcx.body_id, code);\n-                rcx.fcx.register_builtin_bound(var_ty, builtin_bound, cause);\n-            }\n-\n-            type_must_outlive(\n-                rcx, infer::FreeVariable(expr.span, var_node_id),\n-                var_ty, bounds.region_bound);\n-        }\n-    }\n-\n-    /// Make sure that all free variables referenced inside the closure outlive the closure's\n-    /// lifetime bound. Also, create an entry in the upvar_borrows map with a region.\n-    fn constrain_captured_variables(\n-        rcx: &mut Rcx,\n-        region_bound: ty::Region,\n-        expr: &ast::Expr,\n-        freevars: &[ty::Freevar])\n-    {\n-        let tcx = rcx.fcx.ccx.tcx;\n-        debug!(\"constrain_captured_variables({}, {})\",\n-               region_bound.repr(tcx), expr.repr(tcx));\n-        for freevar in freevars {\n-            debug!(\"constrain_captured_variables: freevar.def={:?}\", freevar.def);\n-\n-            // Identify the variable being closed over and its node-id.\n-            let def = freevar.def;\n-            let var_node_id = {\n-                let def_id = def.def_id();\n-                assert!(def_id.krate == ast::LOCAL_CRATE);\n-                def_id.node\n-            };\n-            let upvar_id = ty::UpvarId { var_id: var_node_id,\n-                                         closure_expr_id: expr.id };\n-\n-            match rcx.fcx.inh.upvar_capture_map.borrow()[upvar_id] {\n-                ty::UpvarCapture::ByValue => { }\n-                ty::UpvarCapture::ByRef(upvar_borrow) => {\n-                    rcx.fcx.mk_subr(infer::FreeVariable(freevar.span, var_node_id),\n-                                    region_bound, upvar_borrow.region);\n-\n-                    // Guarantee that the closure does not outlive the variable itself.\n-                    let enclosing_region = region_of_def(rcx.fcx, def);\n-                    debug!(\"constrain_captured_variables: enclosing_region = {}\",\n-                           enclosing_region.repr(tcx));\n-                    rcx.fcx.mk_subr(infer::FreeVariable(freevar.span, var_node_id),\n-                                    region_bound, enclosing_region);\n-                }\n-            }\n-        }\n-    }\n }\n \n fn constrain_callee(rcx: &mut Rcx,\n@@ -1538,6 +1409,9 @@ pub fn type_must_outlive<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n                 let o1 = infer::ReferenceOutlivesReferent(ty, origin.span());\n                 generic_must_outlive(rcx, o1, r_a, generic_b);\n             }\n+            implicator::Implication::RegionSubClosure(_, r_a, def_id, substs) => {\n+                closure_must_outlive(rcx, origin.clone(), r_a, def_id, substs);\n+            }\n             implicator::Implication::Predicate(def_id, predicate) => {\n                 let cause = traits::ObligationCause::new(origin.span(),\n                                                          rcx.body_id,\n@@ -1549,6 +1423,23 @@ pub fn type_must_outlive<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n     }\n }\n \n+fn closure_must_outlive<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n+                                  origin: infer::SubregionOrigin<'tcx>,\n+                                  region: ty::Region,\n+                                  def_id: ast::DefId,\n+                                  substs: &'tcx Substs<'tcx>) {\n+    debug!(\"closure_must_outlive(region={}, def_id={}, substs={})\",\n+           region.repr(rcx.tcx()), def_id.repr(rcx.tcx()), substs.repr(rcx.tcx()));\n+\n+    let upvars = rcx.fcx.closure_upvars(def_id, substs).unwrap();\n+    for upvar in upvars {\n+        let var_id = upvar.def.def_id().local_id();\n+        type_must_outlive(\n+            rcx, infer::FreeVariable(origin.span(), var_id),\n+            upvar.ty, region);\n+    }\n+}\n+\n fn generic_must_outlive<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n                                   origin: infer::SubregionOrigin<'tcx>,\n                                   region: ty::Region,"}, {"sha": "58b67d31ab5803458fa02b9b6be6f4ce41451368", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ca6eaedae9ec4bff2a63f81f473aba653e46ac5/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ca6eaedae9ec4bff2a63f81f473aba653e46ac5/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=2ca6eaedae9ec4bff2a63f81f473aba653e46ac5", "patch": "@@ -397,7 +397,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n             match self_type.ty.sty {\n                 ty::ty_enum(type_def_id, _) |\n                 ty::ty_struct(type_def_id, _) |\n-                ty::ty_closure(type_def_id, _, _) => {\n+                ty::ty_closure(type_def_id, _) => {\n                     tcx.destructor_for_type\n                        .borrow_mut()\n                        .insert(type_def_id, method_def_id.def_id());"}, {"sha": "883c1bbbbe5853e4d31ef903e387488dc129b719", "filename": "src/libstd/thread.rs", "status": "modified", "additions": 16, "deletions": 22, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/2ca6eaedae9ec4bff2a63f81f473aba653e46ac5/src%2Flibstd%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ca6eaedae9ec4bff2a63f81f473aba653e46ac5/src%2Flibstd%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread.rs?ref=2ca6eaedae9ec4bff2a63f81f473aba653e46ac5", "patch": "@@ -28,25 +28,25 @@\n //! a thread will unwind the stack, running destructors and freeing\n //! owned resources. Thread panic is unrecoverable from within\n //! the panicking thread (i.e. there is no 'try/catch' in Rust), but\n-//! panic may optionally be detected from a different thread. If\n-//! the main thread panics the application will exit with a non-zero\n+//! the panic may optionally be detected from a different thread. If\n+//! the main thread panics, the application will exit with a non-zero\n //! exit code.\n //!\n //! When the main thread of a Rust program terminates, the entire program shuts\n //! down, even if other threads are still running. However, this module provides\n //! convenient facilities for automatically waiting for the termination of a\n-//! child thread (i.e., join), described below.\n+//! child thread (i.e., join).\n //!\n //! ## The `Thread` type\n //!\n-//! Already-running threads are represented via the `Thread` type, which you can\n+//! Threads are represented via the `Thread` type, which you can\n //! get in one of two ways:\n //!\n-//! * By spawning a new thread, e.g. using the `thread::spawn` constructor;\n+//! * By spawning a new thread, e.g. using the `thread::spawn` function.\n //! * By requesting the current thread, using the `thread::current` function.\n //!\n //! Threads can be named, and provide some built-in support for low-level\n-//! synchronization described below.\n+//! synchronization (described below).\n //!\n //! The `thread::current()` function is available even for threads not spawned\n //! by the APIs of this module.\n@@ -59,29 +59,27 @@\n //! use std::thread;\n //!\n //! thread::spawn(move || {\n-//!     println!(\"Hello, World!\");\n-//!     // some computation here\n+//!     // some work here\n //! });\n //! ```\n //!\n //! In this example, the spawned thread is \"detached\" from the current\n-//! thread, meaning that it can outlive the thread that spawned\n-//! it. (Note, however, that when the main thread terminates all\n-//! detached threads are terminated as well.)\n+//! thread. This means that it can outlive its parent (the thread that spawned\n+//! it), unless this parent is the main thread.\n //!\n //! ## Scoped threads\n //!\n //! Often a parent thread uses a child thread to perform some particular task,\n //! and at some point must wait for the child to complete before continuing.\n-//! For this scenario, use the `scoped` constructor:\n+//! For this scenario, use the `thread::scoped` function:\n //!\n //! ```rust\n //! use std::thread;\n //!\n //! let guard = thread::scoped(move || {\n-//!     println!(\"Hello, World!\");\n-//!     // some computation here\n+//!     // some work here\n //! });\n+//!\n //! // do some other work in the meantime\n //! let output = guard.join();\n //! ```\n@@ -92,11 +90,7 @@\n //! terminates) when it is dropped. You can join the child thread in\n //! advance by calling the `join` method on the guard, which will also\n //! return the result produced by the thread.  A handle to the thread\n-//! itself is available via the `thread` method on the join guard.\n-//!\n-//! (Note: eventually, the `scoped` constructor will allow the parent and child\n-//! threads to data that lives on the parent thread's stack, but some language\n-//! changes are needed before this is possible.)\n+//! itself is available via the `thread` method of the join guard.\n //!\n //! ## Configuring threads\n //!\n@@ -108,7 +102,7 @@\n //! use std::thread;\n //!\n //! thread::Builder::new().name(\"child1\".to_string()).spawn(move || {\n-//!     println!(\"Hello, world!\")\n+//!     println!(\"Hello, world!\");\n //! });\n //! ```\n //!\n@@ -121,7 +115,7 @@\n //! initially not present:\n //!\n //! * The `thread::park()` function blocks the current thread unless or until\n-//!   the token is available for its thread handle, at which point It atomically\n+//!   the token is available for its thread handle, at which point it atomically\n //!   consumes the token. It may also return *spuriously*, without consuming the\n //!   token. `thread::park_timeout()` does the same, but allows specifying a\n //!   maximum time to block the thread for.\n@@ -143,7 +137,7 @@\n //! * It avoids the need to allocate mutexes and condvars when building new\n //!   synchronization primitives; the threads already provide basic blocking/signaling.\n //!\n-//! * It can be implemented highly efficiently on many platforms.\n+//! * It can be implemented very efficiently on many platforms.\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n "}, {"sha": "8043bd9bd706daaba52b33d6fb053c147bcad3bb", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2ca6eaedae9ec4bff2a63f81f473aba653e46ac5/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ca6eaedae9ec4bff2a63f81f473aba653e46ac5/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=2ca6eaedae9ec4bff2a63f81f473aba653e46ac5", "patch": "@@ -173,6 +173,7 @@ pub static KNOWN_ATTRIBUTES: &'static [(&'static str, AttributeType)] = &[\n     (\"plugin_registrar\", Normal),\n \n     (\"cfg\", Normal),\n+    (\"cfg_attr\", Normal),\n     (\"main\", Normal),\n     (\"start\", Normal),\n     (\"test\", Normal),"}, {"sha": "85298e4c6e096e3a4e19c576a9ff448fb3685aed", "filename": "src/test/compile-fail/issue-4335.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2ca6eaedae9ec4bff2a63f81f473aba653e46ac5/src%2Ftest%2Fcompile-fail%2Fissue-4335.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ca6eaedae9ec4bff2a63f81f473aba653e46ac5/src%2Ftest%2Fcompile-fail%2Fissue-4335.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-4335.rs?ref=2ca6eaedae9ec4bff2a63f81f473aba653e46ac5", "patch": "@@ -14,7 +14,9 @@\n fn id<T>(t: T) -> T { t }\n \n fn f<'r, T>(v: &'r T) -> Box<FnMut() -> T + 'r> {\n-    id(box || *v) //~ ERROR cannot infer\n+    id(box || *v)\n+        //~^ ERROR `v` does not live long enough\n+        //~| ERROR cannot move out of borrowed content\n }\n \n fn main() {"}, {"sha": "cc33d11241757923acc065286c5de077204ca6e9", "filename": "src/test/compile-fail/regions-proc-bound-capture.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ca6eaedae9ec4bff2a63f81f473aba653e46ac5/src%2Ftest%2Fcompile-fail%2Fregions-proc-bound-capture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ca6eaedae9ec4bff2a63f81f473aba653e46ac5/src%2Ftest%2Fcompile-fail%2Fregions-proc-bound-capture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-proc-bound-capture.rs?ref=2ca6eaedae9ec4bff2a63f81f473aba653e46ac5", "patch": "@@ -18,7 +18,7 @@ fn borrowed_proc<'a>(x: &'a isize) -> Box<FnMut()->(isize) + 'a> {\n \n fn static_proc(x: &isize) -> Box<FnMut()->(isize) + 'static> {\n     // This is illegal, because the region bound on `proc` is 'static.\n-    box move|| { *x } //~ ERROR cannot infer\n+    box move|| { *x } //~ ERROR captured variable `x` does not outlive the enclosing closure\n }\n \n fn main() { }"}, {"sha": "c9b378d1df26d433eaaffb4dbfed0f8a381d768c", "filename": "src/test/compile-fail/regions-steal-closure.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2ca6eaedae9ec4bff2a63f81f473aba653e46ac5/src%2Ftest%2Fcompile-fail%2Fregions-steal-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ca6eaedae9ec4bff2a63f81f473aba653e46ac5/src%2Ftest%2Fcompile-fail%2Fregions-steal-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-steal-closure.rs?ref=2ca6eaedae9ec4bff2a63f81f473aba653e46ac5", "patch": "@@ -20,9 +20,9 @@ fn box_it<'r>(x: Box<FnMut() + 'r>) -> closure_box<'r> {\n }\n \n fn main() {\n-    let cl_box = {\n+    let mut cl_box = {\n         let mut i = 3;\n-        box_it(box || i += 1) //~ ERROR cannot infer\n+        box_it(box || i += 1) //~ ERROR `i` does not live long enough\n     };\n     cl_box.cl.call_mut(());\n }"}, {"sha": "fe03ca8353d293d80ad34a538945db97b6e4bbc5", "filename": "src/test/compile-fail/send-is-not-static-ensures-scoping.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2ca6eaedae9ec4bff2a63f81f473aba653e46ac5/src%2Ftest%2Fcompile-fail%2Fsend-is-not-static-ensures-scoping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ca6eaedae9ec4bff2a63f81f473aba653e46ac5/src%2Ftest%2Fcompile-fail%2Fsend-is-not-static-ensures-scoping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsend-is-not-static-ensures-scoping.rs?ref=2ca6eaedae9ec4bff2a63f81f473aba653e46ac5", "patch": "@@ -13,9 +13,10 @@ use std::thread;\n fn main() {\n     let bad = {\n         let x = 1;\n-        let y = &x;\n+        let y = &x; //~ ERROR `x` does not live long enough\n \n-        thread::scoped(|| { //~ ERROR cannot infer an appropriate lifetime\n+        thread::scoped(|| {\n+            //~^ ERROR `y` does not live long enough\n             let _z = y;\n         })\n     };"}, {"sha": "5f4bf0d33be67c0ccbbeaa2bc6c8ab8adf2237eb", "filename": "src/test/compile-fail/unboxed-closure-region.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ca6eaedae9ec4bff2a63f81f473aba653e46ac5/src%2Ftest%2Fcompile-fail%2Funboxed-closure-region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ca6eaedae9ec4bff2a63f81f473aba653e46ac5/src%2Ftest%2Fcompile-fail%2Funboxed-closure-region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closure-region.rs?ref=2ca6eaedae9ec4bff2a63f81f473aba653e46ac5", "patch": "@@ -15,6 +15,6 @@\n fn main() {\n     let _f = {\n         let x = 0_usize;\n-        || x //~ ERROR cannot infer an appropriate lifetime due to conflicting requirements\n+        || x //~ ERROR `x` does not live long enough\n     };\n }"}]}