{"sha": "9f4bc3ead43a57783d8abea2fa6931a6736f3490", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlmNGJjM2VhZDQzYTU3NzgzZDhhYmVhMmZhNjkzMWE2NzM2ZjM0OTA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-03-19T15:38:57Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-03-19T15:38:57Z"}, "message": "Auto merge of #83301 - Dylan-DPC:rollup-x1yzvhm, r=Dylan-DPC\n\nRollup of 11 pull requests\n\nSuccessful merges:\n\n - #82500 (Reuse `std::sys::unsupported::pipe` on `hermit`)\n - #82759 (Remove unwrap_none/expect_none from compiler/.)\n - #82846 (rustdoc: allow list syntax for #[doc(alias)] attributes)\n - #82892 (Clarify docs for Read::read's return value)\n - #83179 (Extend `proc_macro_back_compat` lint to `actix-web`)\n - #83197 (Move some test-only code to test files)\n - #83208 (Fix gitattibutes for old git versions)\n - #83215 (Deprecate std::os::haiku::raw, which accidentally wasn't deprecated)\n - #83230 (Remove unnecessary `forward_inner_docs` hack)\n - #83236 (Upgrade memmap to memmap2)\n - #83270 (Fix typo/inaccuracy in the documentation of Iterator::skip_while)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "ea7f9020ead403b250e25b49007cbc9043c9ec21", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ea7f9020ead403b250e25b49007cbc9043c9ec21"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9f4bc3ead43a57783d8abea2fa6931a6736f3490", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9f4bc3ead43a57783d8abea2fa6931a6736f3490", "html_url": "https://github.com/rust-lang/rust/commit/9f4bc3ead43a57783d8abea2fa6931a6736f3490", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9f4bc3ead43a57783d8abea2fa6931a6736f3490/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b97fd3e5a1545ab02e18c52e7f3d2e78a5c960bf", "url": "https://api.github.com/repos/rust-lang/rust/commits/b97fd3e5a1545ab02e18c52e7f3d2e78a5c960bf", "html_url": "https://github.com/rust-lang/rust/commit/b97fd3e5a1545ab02e18c52e7f3d2e78a5c960bf"}, {"sha": "99f411d4385f654cfffb5126725414da8b99e211", "url": "https://api.github.com/repos/rust-lang/rust/commits/99f411d4385f654cfffb5126725414da8b99e211", "html_url": "https://github.com/rust-lang/rust/commit/99f411d4385f654cfffb5126725414da8b99e211"}], "stats": {"total": 782, "additions": 530, "deletions": 252}, "files": [{"sha": "d29c15fe712f301a375385e3ad9d624937721371", "filename": ".gitattributes", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9f4bc3ead43a57783d8abea2fa6931a6736f3490/.gitattributes", "raw_url": "https://github.com/rust-lang/rust/raw/9f4bc3ead43a57783d8abea2fa6931a6736f3490/.gitattributes", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitattributes?ref=9f4bc3ead43a57783d8abea2fa6931a6736f3490", "patch": "@@ -7,11 +7,11 @@\n *.fixed linguist-language=Rust\n *.mir linguist-language=Rust\n src/etc/installer/gfx/* binary\n-*.woff binary\n-*.woff2 binary\n src/vendor/** -text\n Cargo.lock linguist-generated=false\n \n-# Older git versions try to fix line endings on images, this prevents it.\n+# Older git versions try to fix line endings on images and fonts, this prevents it.\n *.png binary\n *.ico binary\n+*.woff binary\n+*.woff2 binary"}, {"sha": "e5a7b7d9b6056c02851755c25641d38846d720cb", "filename": "Cargo.lock", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9f4bc3ead43a57783d8abea2fa6931a6736f3490/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/9f4bc3ead43a57783d8abea2fa6931a6736f3490/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=9f4bc3ead43a57783d8abea2fa6931a6736f3490", "patch": "@@ -2164,6 +2164,15 @@ dependencies = [\n  \"winapi 0.3.9\",\n ]\n \n+[[package]]\n+name = \"memmap2\"\n+version = \"0.2.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"04e3e85b970d650e2ae6d70592474087051c11c54da7f7b4949725c5735fbcc6\"\n+dependencies = [\n+ \"libc\",\n+]\n+\n [[package]]\n name = \"memoffset\"\n version = \"0.5.5\"\n@@ -3782,7 +3791,7 @@ dependencies = [\n  \"itertools 0.9.0\",\n  \"jobserver\",\n  \"libc\",\n- \"memmap\",\n+ \"memmap2\",\n  \"pathdiff\",\n  \"rustc_apfloat\",\n  \"rustc_ast\",\n@@ -4116,7 +4125,7 @@ name = \"rustc_metadata\"\n version = \"0.0.0\"\n dependencies = [\n  \"libc\",\n- \"memmap\",\n+ \"memmap2\",\n  \"rustc_ast\",\n  \"rustc_attr\",\n  \"rustc_data_structures\","}, {"sha": "c3198fb10431cd81fd74f8da6e2bcf6ac3dc1f50", "filename": "compiler/rustc_arena/src/lib.rs", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9f4bc3ead43a57783d8abea2fa6931a6736f3490/compiler%2Frustc_arena%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f4bc3ead43a57783d8abea2fa6931a6736f3490/compiler%2Frustc_arena%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_arena%2Fsrc%2Flib.rs?ref=9f4bc3ead43a57783d8abea2fa6931a6736f3490", "patch": "@@ -298,22 +298,6 @@ impl<T> TypedArena<T> {\n         }\n     }\n \n-    /// Clears the arena. Deallocates all but the longest chunk which may be reused.\n-    pub fn clear(&mut self) {\n-        unsafe {\n-            // Clear the last chunk, which is partially filled.\n-            let mut chunks_borrow = self.chunks.borrow_mut();\n-            if let Some(mut last_chunk) = chunks_borrow.last_mut() {\n-                self.clear_last_chunk(&mut last_chunk);\n-                let len = chunks_borrow.len();\n-                // If `T` is ZST, code below has no effect.\n-                for mut chunk in chunks_borrow.drain(..len - 1) {\n-                    chunk.destroy(chunk.entries);\n-                }\n-            }\n-        }\n-    }\n-\n     // Drops the contents of the last chunk. The last chunk is partially empty, unlike all other\n     // chunks.\n     fn clear_last_chunk(&self, last_chunk: &mut TypedArenaChunk<T>) {"}, {"sha": "911e577c1edc7b5b29bea226cd68fbc7c8a80029", "filename": "compiler/rustc_arena/src/tests.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9f4bc3ead43a57783d8abea2fa6931a6736f3490/compiler%2Frustc_arena%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f4bc3ead43a57783d8abea2fa6931a6736f3490/compiler%2Frustc_arena%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_arena%2Fsrc%2Ftests.rs?ref=9f4bc3ead43a57783d8abea2fa6931a6736f3490", "patch": "@@ -11,6 +11,24 @@ struct Point {\n     z: i32,\n }\n \n+impl<T> TypedArena<T> {\n+    /// Clears the arena. Deallocates all but the longest chunk which may be reused.\n+    fn clear(&mut self) {\n+        unsafe {\n+            // Clear the last chunk, which is partially filled.\n+            let mut chunks_borrow = self.chunks.borrow_mut();\n+            if let Some(mut last_chunk) = chunks_borrow.last_mut() {\n+                self.clear_last_chunk(&mut last_chunk);\n+                let len = chunks_borrow.len();\n+                // If `T` is ZST, code below has no effect.\n+                for mut chunk in chunks_borrow.drain(..len - 1) {\n+                    chunk.destroy(chunk.entries);\n+                }\n+            }\n+        }\n+    }\n+}\n+\n #[test]\n pub fn test_unused() {\n     let arena: TypedArena<Point> = TypedArena::default();"}, {"sha": "15dbbbd49aa563f3bd62662837a12c9d83f2ac14", "filename": "compiler/rustc_codegen_ssa/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f4bc3ead43a57783d8abea2fa6931a6736f3490/compiler%2Frustc_codegen_ssa%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/9f4bc3ead43a57783d8abea2fa6931a6736f3490/compiler%2Frustc_codegen_ssa%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2FCargo.toml?ref=9f4bc3ead43a57783d8abea2fa6931a6736f3490", "patch": "@@ -11,7 +11,7 @@ test = false\n bitflags = \"1.2.1\"\n cc = \"1.0.1\"\n itertools = \"0.9\"\n-memmap = \"0.7\"\n+memmap2 = \"0.2.1\"\n tracing = \"0.1\"\n libc = \"0.2.50\"\n jobserver = \"0.1.11\""}, {"sha": "c6aea22a63eb7cd0ecf17796e129c8f531ea6c14", "filename": "compiler/rustc_codegen_ssa/src/back/lto.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f4bc3ead43a57783d8abea2fa6931a6736f3490/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f4bc3ead43a57783d8abea2fa6931a6736f3490/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flto.rs?ref=9f4bc3ead43a57783d8abea2fa6931a6736f3490", "patch": "@@ -93,7 +93,7 @@ impl<B: WriteBackendMethods> LtoModuleCodegen<B> {\n pub enum SerializedModule<M: ModuleBufferMethods> {\n     Local(M),\n     FromRlib(Vec<u8>),\n-    FromUncompressedFile(memmap::Mmap),\n+    FromUncompressedFile(memmap2::Mmap),\n }\n \n impl<M: ModuleBufferMethods> SerializedModule<M> {"}, {"sha": "490b3d33112840aba9f70e96a588d61cb4122866", "filename": "compiler/rustc_codegen_ssa/src/back/write.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f4bc3ead43a57783d8abea2fa6931a6736f3490/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f4bc3ead43a57783d8abea2fa6931a6736f3490/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs?ref=9f4bc3ead43a57783d8abea2fa6931a6736f3490", "patch": "@@ -1958,7 +1958,7 @@ pub fn submit_pre_lto_module_to_llvm<B: ExtraBackendMethods>(\n         .unwrap_or_else(|e| panic!(\"failed to open bitcode file `{}`: {}\", bc_path.display(), e));\n \n     let mmap = unsafe {\n-        memmap::Mmap::map(&file).unwrap_or_else(|e| {\n+        memmap2::Mmap::map(&file).unwrap_or_else(|e| {\n             panic!(\"failed to mmap bitcode file `{}`: {}\", bc_path.display(), e)\n         })\n     };"}, {"sha": "dd04d3e548f8ccaf9858e06a2b7d4a3170b62f6a", "filename": "compiler/rustc_codegen_ssa/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f4bc3ead43a57783d8abea2fa6931a6736f3490/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f4bc3ead43a57783d8abea2fa6931a6736f3490/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs?ref=9f4bc3ead43a57783d8abea2fa6931a6736f3490", "patch": "@@ -1,6 +1,6 @@\n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n+#![feature(assert_matches)]\n #![feature(bool_to_option)]\n-#![feature(option_expect_none)]\n #![feature(box_patterns)]\n #![feature(drain_filter)]\n #![feature(try_blocks)]"}, {"sha": "f88bcc294815041be52c0c166e6c9fe9be85421a", "filename": "compiler/rustc_data_structures/src/tiny_list.rs", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9f4bc3ead43a57783d8abea2fa6931a6736f3490/compiler%2Frustc_data_structures%2Fsrc%2Ftiny_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f4bc3ead43a57783d8abea2fa6931a6736f3490/compiler%2Frustc_data_structures%2Fsrc%2Ftiny_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Ftiny_list.rs?ref=9f4bc3ead43a57783d8abea2fa6931a6736f3490", "patch": "@@ -15,7 +15,7 @@\n mod tests;\n \n #[derive(Clone)]\n-pub struct TinyList<T: PartialEq> {\n+pub struct TinyList<T> {\n     head: Option<Element<T>>,\n }\n \n@@ -56,20 +56,10 @@ impl<T: PartialEq> TinyList<T> {\n         }\n         false\n     }\n-\n-    #[inline]\n-    pub fn len(&self) -> usize {\n-        let (mut elem, mut count) = (self.head.as_ref(), 0);\n-        while let Some(ref e) = elem {\n-            count += 1;\n-            elem = e.next.as_deref();\n-        }\n-        count\n-    }\n }\n \n #[derive(Clone)]\n-struct Element<T: PartialEq> {\n+struct Element<T> {\n     data: T,\n     next: Option<Box<Element<T>>>,\n }"}, {"sha": "c0334d2e23e5544d62f6790733c6d95b91c1853d", "filename": "compiler/rustc_data_structures/src/tiny_list/tests.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9f4bc3ead43a57783d8abea2fa6931a6736f3490/compiler%2Frustc_data_structures%2Fsrc%2Ftiny_list%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f4bc3ead43a57783d8abea2fa6931a6736f3490/compiler%2Frustc_data_structures%2Fsrc%2Ftiny_list%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Ftiny_list%2Ftests.rs?ref=9f4bc3ead43a57783d8abea2fa6931a6736f3490", "patch": "@@ -3,6 +3,17 @@ use super::*;\n extern crate test;\n use test::{black_box, Bencher};\n \n+impl<T> TinyList<T> {\n+    fn len(&self) -> usize {\n+        let (mut elem, mut count) = (self.head.as_ref(), 0);\n+        while let Some(ref e) = elem {\n+            count += 1;\n+            elem = e.next.as_deref();\n+        }\n+        count\n+    }\n+}\n+\n #[test]\n fn test_contains_and_insert() {\n     fn do_insert(i: u32) -> bool {"}, {"sha": "ccf8bd69ebd0664af6787c93dc2dc91af1df3ca7", "filename": "compiler/rustc_data_structures/src/transitive_relation.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9f4bc3ead43a57783d8abea2fa6931a6736f3490/compiler%2Frustc_data_structures%2Fsrc%2Ftransitive_relation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f4bc3ead43a57783d8abea2fa6931a6736f3490/compiler%2Frustc_data_structures%2Fsrc%2Ftransitive_relation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Ftransitive_relation.rs?ref=9f4bc3ead43a57783d8abea2fa6931a6736f3490", "patch": "@@ -9,7 +9,7 @@ use std::mem;\n mod tests;\n \n #[derive(Clone, Debug)]\n-pub struct TransitiveRelation<T: Eq + Hash> {\n+pub struct TransitiveRelation<T> {\n     // List of elements. This is used to map from a T to a usize.\n     elements: FxIndexSet<T>,\n \n@@ -49,7 +49,7 @@ struct Edge {\n     target: Index,\n }\n \n-impl<T: Clone + Debug + Eq + Hash> TransitiveRelation<T> {\n+impl<T: Eq + Hash> TransitiveRelation<T> {\n     pub fn is_empty(&self) -> bool {\n         self.edges.is_empty()\n     }\n@@ -322,12 +322,6 @@ impl<T: Clone + Debug + Eq + Hash> TransitiveRelation<T> {\n             .collect()\n     }\n \n-    /// A \"best\" parent in some sense. See `parents` and\n-    /// `postdom_upper_bound` for more details.\n-    pub fn postdom_parent(&self, a: &T) -> Option<&T> {\n-        self.mutual_immediate_postdominator(self.parents(a))\n-    }\n-\n     fn with_closure<OP, R>(&self, op: OP) -> R\n     where\n         OP: FnOnce(&BitMatrix<usize, usize>) -> R,"}, {"sha": "9fa7224376c1c35fc2f260ca6aaf7aadd2efe1e7", "filename": "compiler/rustc_data_structures/src/transitive_relation/tests.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9f4bc3ead43a57783d8abea2fa6931a6736f3490/compiler%2Frustc_data_structures%2Fsrc%2Ftransitive_relation%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f4bc3ead43a57783d8abea2fa6931a6736f3490/compiler%2Frustc_data_structures%2Fsrc%2Ftransitive_relation%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Ftransitive_relation%2Ftests.rs?ref=9f4bc3ead43a57783d8abea2fa6931a6736f3490", "patch": "@@ -1,5 +1,13 @@\n use super::*;\n \n+impl<T: Eq + Hash> TransitiveRelation<T> {\n+    /// A \"best\" parent in some sense. See `parents` and\n+    /// `postdom_upper_bound` for more details.\n+    fn postdom_parent(&self, a: &T) -> Option<&T> {\n+        self.mutual_immediate_postdominator(self.parents(a))\n+    }\n+}\n+\n #[test]\n fn test_one_step() {\n     let mut relation = TransitiveRelation::default();"}, {"sha": "79507e61522190cbd37cca1481765b524bac64e6", "filename": "compiler/rustc_errors/src/diagnostic_builder.rs", "status": "modified", "additions": 6, "deletions": 15, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/9f4bc3ead43a57783d8abea2fa6931a6736f3490/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f4bc3ead43a57783d8abea2fa6931a6736f3490/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs?ref=9f4bc3ead43a57783d8abea2fa6931a6736f3490", "patch": "@@ -30,15 +30,6 @@ struct DiagnosticBuilderInner<'a> {\n     allow_suggestions: bool,\n }\n \n-/// This is a helper macro for [`forward!`] that allows automatically adding documentation\n-/// that uses tokens from [`forward!`]'s input.\n-macro_rules! forward_inner_docs {\n-    ($e:expr => $i:item) => {\n-        #[doc = $e]\n-        $i\n-    };\n-}\n-\n /// In general, the `DiagnosticBuilder` uses deref to allow access to\n /// the fields and methods of the embedded `diagnostic` in a\n /// transparent way. *However,* many of the methods are intended to\n@@ -54,11 +45,11 @@ macro_rules! forward {\n         pub fn $n:ident(&self, $($name:ident: $ty:ty),* $(,)?) -> &Self\n     ) => {\n         $(#[$attrs])*\n-        forward_inner_docs!(concat!(\"See [`Diagnostic::\", stringify!($n), \"()`].\") =>\n+        #[doc = concat!(\"See [`Diagnostic::\", stringify!($n), \"()`].\")]\n         pub fn $n(&self, $($name: $ty),*) -> &Self {\n             self.diagnostic.$n($($name),*);\n             self\n-        });\n+        }\n     };\n \n     // Forward pattern for &mut self -> &mut Self\n@@ -67,11 +58,11 @@ macro_rules! forward {\n         pub fn $n:ident(&mut self, $($name:ident: $ty:ty),* $(,)?) -> &mut Self\n     ) => {\n         $(#[$attrs])*\n-        forward_inner_docs!(concat!(\"See [`Diagnostic::\", stringify!($n), \"()`].\") =>\n+        #[doc = concat!(\"See [`Diagnostic::\", stringify!($n), \"()`].\")]\n         pub fn $n(&mut self, $($name: $ty),*) -> &mut Self {\n             self.0.diagnostic.$n($($name),*);\n             self\n-        });\n+        }\n     };\n \n     // Forward pattern for &mut self -> &mut Self, with generic parameters.\n@@ -84,11 +75,11 @@ macro_rules! forward {\n         ) -> &mut Self\n     ) => {\n         $(#[$attrs])*\n-        forward_inner_docs!(concat!(\"See [`Diagnostic::\", stringify!($n), \"()`].\") =>\n+        #[doc = concat!(\"See [`Diagnostic::\", stringify!($n), \"()`].\")]\n         pub fn $n<$($generic: $bound),*>(&mut self, $($name: $ty),*) -> &mut Self {\n             self.0.diagnostic.$n($($name),*);\n             self\n-        });\n+        }\n     };\n }\n "}, {"sha": "fa855f544e81920a9920aefe8cae78f4569497f0", "filename": "compiler/rustc_errors/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9f4bc3ead43a57783d8abea2fa6931a6736f3490/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f4bc3ead43a57783d8abea2fa6931a6736f3490/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Flib.rs?ref=9f4bc3ead43a57783d8abea2fa6931a6736f3490", "patch": "@@ -5,6 +5,7 @@\n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n #![feature(crate_visibility_modifier)]\n #![feature(backtrace)]\n+#![feature(extended_key_value_attributes)]\n #![feature(nll)]\n \n #[macro_use]"}, {"sha": "cb41bc81225ec23bcbd83fe31027114a40e02924", "filename": "compiler/rustc_expand/src/proc_macro_server.rs", "status": "modified", "additions": 29, "deletions": 17, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/9f4bc3ead43a57783d8abea2fa6931a6736f3490/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f4bc3ead43a57783d8abea2fa6931a6736f3490/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs?ref=9f4bc3ead43a57783d8abea2fa6931a6736f3490", "patch": "@@ -53,11 +53,11 @@ impl ToInternal<token::DelimToken> for Delimiter {\n     }\n }\n \n-impl FromInternal<(TreeAndSpacing, &'_ ParseSess, &'_ mut Vec<Self>)>\n+impl FromInternal<(TreeAndSpacing, &'_ mut Vec<Self>, &mut Rustc<'_>)>\n     for TokenTree<Group, Punct, Ident, Literal>\n {\n     fn from_internal(\n-        ((tree, spacing), sess, stack): (TreeAndSpacing, &ParseSess, &mut Vec<Self>),\n+        ((tree, spacing), stack, rustc): (TreeAndSpacing, &mut Vec<Self>, &mut Rustc<'_>),\n     ) -> Self {\n         use rustc_ast::token::*;\n \n@@ -146,10 +146,10 @@ impl FromInternal<(TreeAndSpacing, &'_ ParseSess, &'_ mut Vec<Self>)>\n             SingleQuote => op!('\\''),\n \n             Ident(name, false) if name == kw::DollarCrate => tt!(Ident::dollar_crate()),\n-            Ident(name, is_raw) => tt!(Ident::new(sess, name, is_raw)),\n+            Ident(name, is_raw) => tt!(Ident::new(rustc.sess, name, is_raw)),\n             Lifetime(name) => {\n                 let ident = symbol::Ident::new(name, span).without_first_quote();\n-                stack.push(tt!(Ident::new(sess, ident.name, false)));\n+                stack.push(tt!(Ident::new(rustc.sess, ident.name, false)));\n                 tt!(Punct::new('\\'', true))\n             }\n             Literal(lit) => tt!(Literal { lit }),\n@@ -179,15 +179,15 @@ impl FromInternal<(TreeAndSpacing, &'_ ParseSess, &'_ mut Vec<Self>)>\n             }\n \n             Interpolated(nt) => {\n-                if let Some((name, is_raw)) = ident_name_compatibility_hack(&nt, span, sess) {\n-                    TokenTree::Ident(Ident::new(sess, name.name, is_raw, name.span))\n+                if let Some((name, is_raw)) = ident_name_compatibility_hack(&nt, span, rustc) {\n+                    TokenTree::Ident(Ident::new(rustc.sess, name.name, is_raw, name.span))\n                 } else {\n-                    let stream = nt_to_tokenstream(&nt, sess, CanSynthesizeMissingTokens::No);\n+                    let stream = nt_to_tokenstream(&nt, rustc.sess, CanSynthesizeMissingTokens::No);\n                     TokenTree::Group(Group {\n                         delimiter: Delimiter::None,\n                         stream,\n                         span: DelimSpan::from_single(span),\n-                        flatten: crate::base::pretty_printing_compatibility_hack(&nt, sess),\n+                        flatten: crate::base::pretty_printing_compatibility_hack(&nt, rustc.sess),\n                     })\n                 }\n             }\n@@ -449,7 +449,7 @@ impl server::TokenStreamIter for Rustc<'_> {\n         loop {\n             let tree = iter.stack.pop().or_else(|| {\n                 let next = iter.cursor.next_with_spacing()?;\n-                Some(TokenTree::from_internal((next, self.sess, &mut iter.stack)))\n+                Some(TokenTree::from_internal((next, &mut iter.stack, self)))\n             })?;\n             // A hack used to pass AST fragments to attribute and derive macros\n             // as a single nonterminal token instead of a token stream.\n@@ -719,11 +719,11 @@ impl server::Span for Rustc<'_> {\n fn ident_name_compatibility_hack(\n     nt: &Nonterminal,\n     orig_span: Span,\n-    sess: &ParseSess,\n+    rustc: &mut Rustc<'_>,\n ) -> Option<(rustc_span::symbol::Ident, bool)> {\n     if let NtIdent(ident, is_raw) = nt {\n         if let ExpnKind::Macro(_, macro_name) = orig_span.ctxt().outer_expn_data().kind {\n-            let source_map = sess.source_map();\n+            let source_map = rustc.sess.source_map();\n             let filename = source_map.span_to_filename(orig_span);\n             if let FileName::Real(RealFileName::Named(path)) = filename {\n                 let matches_prefix = |prefix, filename| {\n@@ -745,7 +745,7 @@ fn ident_name_compatibility_hack(\n                     let snippet = source_map.span_to_snippet(orig_span);\n                     if snippet.as_deref() == Ok(\"$name\") {\n                         if time_macros_impl {\n-                            sess.buffer_lint_with_diagnostic(\n+                            rustc.sess.buffer_lint_with_diagnostic(\n                                 &PROC_MACRO_BACK_COMPAT,\n                                 orig_span,\n                                 ast::CRATE_NODE_ID,\n@@ -759,13 +759,25 @@ fn ident_name_compatibility_hack(\n                     }\n                 }\n \n-                if macro_name == sym::tuple_from_req\n-                    && (matches_prefix(\"actix-web\", \"extract.rs\")\n-                        || matches_prefix(\"actori-web\", \"extract.rs\"))\n-                {\n+                if macro_name == sym::tuple_from_req && matches_prefix(\"actix-web\", \"extract.rs\") {\n                     let snippet = source_map.span_to_snippet(orig_span);\n                     if snippet.as_deref() == Ok(\"$T\") {\n-                        return Some((*ident, *is_raw));\n+                        if let FileName::Real(RealFileName::Named(macro_path)) =\n+                            source_map.span_to_filename(rustc.def_site)\n+                        {\n+                            if macro_path.to_string_lossy().contains(\"pin-project-internal-0.\") {\n+                                rustc.sess.buffer_lint_with_diagnostic(\n+                                    &PROC_MACRO_BACK_COMPAT,\n+                                    orig_span,\n+                                    ast::CRATE_NODE_ID,\n+                                    \"using an old version of `actix-web`\",\n+                                    BuiltinLintDiagnostics::ProcMacroBackCompat(\n+                                    \"the version of `actix-web` you are using might stop compiling in future versions of Rust; \\\n+                                    please update to the latest version of the `actix-web` crate to avoid breakage\".to_string())\n+                                );\n+                                return Some((*ident, *is_raw));\n+                            }\n+                        }\n                     }\n                 }\n             }"}, {"sha": "48effed927493c873772ab2a000987adaacdc61d", "filename": "compiler/rustc_metadata/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f4bc3ead43a57783d8abea2fa6931a6736f3490/compiler%2Frustc_metadata%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/9f4bc3ead43a57783d8abea2fa6931a6736f3490/compiler%2Frustc_metadata%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2FCargo.toml?ref=9f4bc3ead43a57783d8abea2fa6931a6736f3490", "patch": "@@ -11,7 +11,7 @@ doctest = false\n libc = \"0.2\"\n snap = \"1\"\n tracing = \"0.1\"\n-memmap = \"0.7\"\n+memmap2 = \"0.2.1\"\n smallvec = { version = \"1.6.1\", features = [\"union\", \"may_dangle\"] }\n rustc_middle = { path = \"../rustc_middle\" }\n rustc_attr = { path = \"../rustc_attr\" }"}, {"sha": "39a39917f578caea0d55d2017a2e7df036967bca", "filename": "compiler/rustc_metadata/src/locator.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9f4bc3ead43a57783d8abea2fa6931a6736f3490/compiler%2Frustc_metadata%2Fsrc%2Flocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f4bc3ead43a57783d8abea2fa6931a6736f3490/compiler%2Frustc_metadata%2Fsrc%2Flocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Flocator.rs?ref=9f4bc3ead43a57783d8abea2fa6931a6736f3490", "patch": "@@ -728,7 +728,7 @@ impl<'a> CrateLocator<'a> {\n }\n \n /// A trivial wrapper for `Mmap` that implements `StableDeref`.\n-struct StableDerefMmap(memmap::Mmap);\n+struct StableDerefMmap(memmap2::Mmap);\n \n impl Deref for StableDerefMmap {\n     type Target = [u8];\n@@ -779,7 +779,7 @@ fn get_metadata_section(\n             // mmap the file, because only a small fraction of it is read.\n             let file = std::fs::File::open(filename)\n                 .map_err(|_| format!(\"failed to open rmeta metadata: '{}'\", filename.display()))?;\n-            let mmap = unsafe { memmap::Mmap::map(&file) };\n+            let mmap = unsafe { memmap2::Mmap::map(&file) };\n             let mmap = mmap\n                 .map_err(|_| format!(\"failed to mmap rmeta metadata: '{}'\", filename.display()))?;\n "}, {"sha": "31374429940cafaf14beae40478d35f7a96bf49e", "filename": "compiler/rustc_middle/src/ich/impls_syntax.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9f4bc3ead43a57783d8abea2fa6931a6736f3490/compiler%2Frustc_middle%2Fsrc%2Fich%2Fimpls_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f4bc3ead43a57783d8abea2fa6931a6736f3490/compiler%2Frustc_middle%2Fsrc%2Fich%2Fimpls_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fich%2Fimpls_syntax.rs?ref=9f4bc3ead43a57783d8abea2fa6931a6736f3490", "patch": "@@ -45,7 +45,11 @@ impl<'ctx> rustc_ast::HashStableContext for StableHashingContext<'ctx> {\n             item.hash_stable(self, hasher);\n             style.hash_stable(self, hasher);\n             span.hash_stable(self, hasher);\n-            tokens.as_ref().expect_none(\"Tokens should have been removed during lowering!\");\n+            assert_matches!(\n+                tokens.as_ref(),\n+                None,\n+                \"Tokens should have been removed during lowering!\"\n+            );\n         } else {\n             unreachable!();\n         }"}, {"sha": "2d807591bfdd2a361778777ac6bb5672d505fbc4", "filename": "compiler/rustc_middle/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f4bc3ead43a57783d8abea2fa6931a6736f3490/compiler%2Frustc_middle%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f4bc3ead43a57783d8abea2fa6931a6736f3490/compiler%2Frustc_middle%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Flib.rs?ref=9f4bc3ead43a57783d8abea2fa6931a6736f3490", "patch": "@@ -24,6 +24,7 @@\n \n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n #![feature(array_windows)]\n+#![feature(assert_matches)]\n #![feature(assoc_char_funcs)]\n #![feature(backtrace)]\n #![feature(bool_to_option)]\n@@ -38,7 +39,6 @@\n #![feature(extern_types)]\n #![feature(nll)]\n #![feature(once_cell)]\n-#![feature(option_expect_none)]\n #![feature(or_patterns)]\n #![feature(min_specialization)]\n #![feature(trusted_len)]"}, {"sha": "766d6a06f7e59815c987d642729e853ba0b7ef9e", "filename": "compiler/rustc_middle/src/mir/interpret/allocation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f4bc3ead43a57783d8abea2fa6931a6736f3490/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f4bc3ead43a57783d8abea2fa6931a6736f3490/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs?ref=9f4bc3ead43a57783d8abea2fa6931a6736f3490", "patch": "@@ -339,7 +339,7 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n         for dest in bytes {\n             *dest = src.next().expect(\"iterator was shorter than it said it would be\");\n         }\n-        src.next().expect_none(\"iterator was longer than it said it would be\");\n+        assert_matches!(src.next(), None, \"iterator was longer than it said it would be\");\n         Ok(())\n     }\n "}, {"sha": "fe5ebf0b6fe972c5cf70114aba0b5e7ef55a4c4d", "filename": "compiler/rustc_mir/src/interpret/memory.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9f4bc3ead43a57783d8abea2fa6931a6736f3490/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f4bc3ead43a57783d8abea2fa6931a6736f3490/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fmemory.rs?ref=9f4bc3ead43a57783d8abea2fa6931a6736f3490", "patch": "@@ -854,7 +854,11 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n             Some(ptr) => ptr,\n             None => {\n                 // zero-sized access\n-                src.next().expect_none(\"iterator said it was empty but returned an element\");\n+                assert_matches!(\n+                    src.next(),\n+                    None,\n+                    \"iterator said it was empty but returned an element\"\n+                );\n                 return Ok(());\n             }\n         };\n@@ -880,7 +884,11 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n             Some(ptr) => ptr,\n             None => {\n                 // zero-sized access\n-                src.next().expect_none(\"iterator said it was empty but returned an element\");\n+                assert_matches!(\n+                    src.next(),\n+                    None,\n+                    \"iterator said it was empty but returned an element\"\n+                );\n                 return Ok(());\n             }\n         };\n@@ -894,7 +902,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n             let offset_ptr = ptr.offset(Size::from_bytes(idx) * 2, &tcx)?; // `Size` multiplication\n             allocation.write_scalar(&tcx, offset_ptr, val.into(), Size::from_bytes(2))?;\n         }\n-        src.next().expect_none(\"iterator was longer than it said it would be\");\n+        assert_matches!(src.next(), None, \"iterator was longer than it said it would be\");\n         Ok(())\n     }\n "}, {"sha": "f73d5dc0c116d8b1f0e06203d9152f360b267e01", "filename": "compiler/rustc_mir/src/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9f4bc3ead43a57783d8abea2fa6931a6736f3490/compiler%2Frustc_mir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f4bc3ead43a57783d8abea2fa6931a6736f3490/compiler%2Frustc_mir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Flib.rs?ref=9f4bc3ead43a57783d8abea2fa6931a6736f3490", "patch": "@@ -7,6 +7,7 @@ Rust MIR: a lowered representation of Rust.\n #![feature(nll)]\n #![feature(in_band_lifetimes)]\n #![feature(array_windows)]\n+#![feature(assert_matches)]\n #![feature(bindings_after_at)]\n #![feature(bool_to_option)]\n #![feature(box_patterns)]\n@@ -18,13 +19,13 @@ Rust MIR: a lowered representation of Rust.\n #![feature(exact_size_is_empty)]\n #![feature(exhaustive_patterns)]\n #![feature(never_type)]\n+#![feature(map_try_insert)]\n #![feature(min_specialization)]\n #![feature(trusted_len)]\n #![feature(try_blocks)]\n #![feature(associated_type_defaults)]\n #![feature(stmt_expr_attributes)]\n #![feature(trait_alias)]\n-#![feature(option_expect_none)]\n #![feature(option_get_or_insert_default)]\n #![feature(or_patterns)]\n #![feature(once_cell)]"}, {"sha": "aabfee53acb29d160b9f4561463d9fd9ec4d9112", "filename": "compiler/rustc_mir/src/transform/coverage/debug.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9f4bc3ead43a57783d8abea2fa6931a6736f3490/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f4bc3ead43a57783d8abea2fa6931a6736f3490/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fdebug.rs?ref=9f4bc3ead43a57783d8abea2fa6931a6736f3490", "patch": "@@ -285,10 +285,8 @@ impl DebugCounters {\n                 ),\n             };\n             counters\n-                .insert(id, DebugCounter::new(counter_kind.clone(), some_block_label))\n-                .expect_none(\n-                    \"attempt to add the same counter_kind to DebugCounters more than once\",\n-                );\n+                .try_insert(id, DebugCounter::new(counter_kind.clone(), some_block_label))\n+                .expect(\"attempt to add the same counter_kind to DebugCounters more than once\");\n         }\n     }\n \n@@ -479,9 +477,9 @@ impl GraphvizData {\n         counter_kind: &CoverageKind,\n     ) {\n         if let Some(edge_to_counter) = self.some_edge_to_counter.as_mut() {\n-            edge_to_counter.insert((from_bcb, to_bb), counter_kind.clone()).expect_none(\n-                \"invalid attempt to insert more than one edge counter for the same edge\",\n-            );\n+            edge_to_counter\n+                .try_insert((from_bcb, to_bb), counter_kind.clone())\n+                .expect(\"invalid attempt to insert more than one edge counter for the same edge\");\n         }\n     }\n "}, {"sha": "e102512e1f37f4593784997bd16d22cc627d2ba8", "filename": "compiler/rustc_mir/src/transform/deduplicate_blocks.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f4bc3ead43a57783d8abea2fa6931a6736f3490/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fdeduplicate_blocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f4bc3ead43a57783d8abea2fa6931a6736f3490/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fdeduplicate_blocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fdeduplicate_blocks.rs?ref=9f4bc3ead43a57783d8abea2fa6931a6736f3490", "patch": "@@ -86,7 +86,7 @@ fn find_duplicates<'a, 'tcx>(body: &'a Body<'tcx>) -> FxHashMap<BasicBlock, Basi\n                 // The basic block was already in the hashmap, which means we have a duplicate\n                 let value = *occupied.get();\n                 debug!(\"Inserting {:?} -> {:?}\", bb, value);\n-                duplicates.insert(bb, value).expect_none(\"key was already inserted\");\n+                duplicates.try_insert(bb, value).expect(\"key was already inserted\");\n             }\n             Entry::Vacant(vacant) => {\n                 vacant.insert(bb);"}, {"sha": "d91d0e1765bbf8486bb7618519a5fdc42b65c2d2", "filename": "compiler/rustc_passes/src/check_attr.rs", "status": "modified", "additions": 83, "deletions": 30, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/9f4bc3ead43a57783d8abea2fa6931a6736f3490/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f4bc3ead43a57783d8abea2fa6931a6736f3490/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs?ref=9f4bc3ead43a57783d8abea2fa6931a6736f3490", "patch": "@@ -394,33 +394,50 @@ impl CheckAttrVisitor<'tcx> {\n             .emit();\n     }\n \n-    fn check_doc_alias(&self, meta: &NestedMetaItem, hir_id: HirId, target: Target) -> bool {\n-        let doc_alias = meta.value_str().map(|s| s.to_string()).unwrap_or_else(String::new);\n+    fn check_doc_alias_value(\n+        &self,\n+        meta: &NestedMetaItem,\n+        doc_alias: &str,\n+        hir_id: HirId,\n+        target: Target,\n+        is_list: bool,\n+    ) -> bool {\n+        let tcx = self.tcx;\n+        let err_fn = move |span: Span, msg: &str| {\n+            tcx.sess.span_err(\n+                span,\n+                &format!(\n+                    \"`#[doc(alias{})]` {}\",\n+                    if is_list { \"(\\\"...\\\")\" } else { \" = \\\"...\\\"\" },\n+                    msg,\n+                ),\n+            );\n+            false\n+        };\n         if doc_alias.is_empty() {\n-            self.doc_attr_str_error(meta, \"alias\");\n-            return false;\n+            return err_fn(\n+                meta.name_value_literal_span().unwrap_or_else(|| meta.span()),\n+                \"attribute cannot have empty value\",\n+            );\n         }\n         if let Some(c) =\n             doc_alias.chars().find(|&c| c == '\"' || c == '\\'' || (c.is_whitespace() && c != ' '))\n         {\n-            self.tcx\n-                .sess\n-                .struct_span_err(\n-                    meta.name_value_literal_span().unwrap_or_else(|| meta.span()),\n-                    &format!(\"{:?} character isn't allowed in `#[doc(alias = \\\"...\\\")]`\", c),\n-                )\n-                .emit();\n+            self.tcx.sess.span_err(\n+                meta.name_value_literal_span().unwrap_or_else(|| meta.span()),\n+                &format!(\n+                    \"{:?} character isn't allowed in `#[doc(alias{})]`\",\n+                    c,\n+                    if is_list { \"(\\\"...\\\")\" } else { \" = \\\"...\\\"\" },\n+                ),\n+            );\n             return false;\n         }\n         if doc_alias.starts_with(' ') || doc_alias.ends_with(' ') {\n-            self.tcx\n-                .sess\n-                .struct_span_err(\n-                    meta.name_value_literal_span().unwrap_or_else(|| meta.span()),\n-                    \"`#[doc(alias = \\\"...\\\")]` cannot start or end with ' '\",\n-                )\n-                .emit();\n-            return false;\n+            return err_fn(\n+                meta.name_value_literal_span().unwrap_or_else(|| meta.span()),\n+                \"cannot start or end with ' '\",\n+            );\n         }\n         if let Some(err) = match target {\n             Target::Impl => Some(\"implementation block\"),\n@@ -446,27 +463,63 @@ impl CheckAttrVisitor<'tcx> {\n             }\n             _ => None,\n         } {\n-            self.tcx\n-                .sess\n-                .struct_span_err(\n-                    meta.span(),\n-                    &format!(\"`#[doc(alias = \\\"...\\\")]` isn't allowed on {}\", err),\n-                )\n-                .emit();\n-            return false;\n+            return err_fn(meta.span(), &format!(\"isn't allowed on {}\", err));\n         }\n         let item_name = self.tcx.hir().name(hir_id);\n         if &*item_name.as_str() == doc_alias {\n+            return err_fn(meta.span(), \"is the same as the item's name\");\n+        }\n+        true\n+    }\n+\n+    fn check_doc_alias(&self, meta: &NestedMetaItem, hir_id: HirId, target: Target) -> bool {\n+        if let Some(values) = meta.meta_item_list() {\n+            let mut errors = 0;\n+            for v in values {\n+                match v.literal() {\n+                    Some(l) => match l.kind {\n+                        LitKind::Str(s, _) => {\n+                            if !self.check_doc_alias_value(v, &s.as_str(), hir_id, target, true) {\n+                                errors += 1;\n+                            }\n+                        }\n+                        _ => {\n+                            self.tcx\n+                                .sess\n+                                .struct_span_err(\n+                                    v.span(),\n+                                    \"`#[doc(alias(\\\"a\\\"))]` expects string literals\",\n+                                )\n+                                .emit();\n+                            errors += 1;\n+                        }\n+                    },\n+                    None => {\n+                        self.tcx\n+                            .sess\n+                            .struct_span_err(\n+                                v.span(),\n+                                \"`#[doc(alias(\\\"a\\\"))]` expects string literals\",\n+                            )\n+                            .emit();\n+                        errors += 1;\n+                    }\n+                }\n+            }\n+            errors == 0\n+        } else if let Some(doc_alias) = meta.value_str().map(|s| s.to_string()) {\n+            self.check_doc_alias_value(meta, &doc_alias, hir_id, target, false)\n+        } else {\n             self.tcx\n                 .sess\n                 .struct_span_err(\n                     meta.span(),\n-                    &format!(\"`#[doc(alias = \\\"...\\\")]` is the same as the item's name\"),\n+                    \"doc alias attribute expects a string `#[doc(alias = \\\"a\\\")]` or a list of \\\n+                     strings `#[doc(alias(\\\"a\\\", \\\"b\\\"))]`\",\n                 )\n                 .emit();\n-            return false;\n+            false\n         }\n-        true\n     }\n \n     fn check_doc_keyword(&self, meta: &NestedMetaItem, hir_id: HirId) -> bool {"}, {"sha": "eb5b7c4a74a1da1e06a9002ae327a79a6e1815ea", "filename": "compiler/rustc_span/src/hygiene.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9f4bc3ead43a57783d8abea2fa6931a6736f3490/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f4bc3ead43a57783d8abea2fa6931a6736f3490/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs?ref=9f4bc3ead43a57783d8abea2fa6931a6736f3490", "patch": "@@ -118,7 +118,8 @@ impl ExpnId {\n         HygieneData::with(|data| {\n             let old_expn_data = &mut data.expn_data[self.0 as usize];\n             assert!(old_expn_data.is_none(), \"expansion data is reset for an expansion ID\");\n-            expn_data.orig_id.replace(self.as_u32()).expect_none(\"orig_id should be None\");\n+            assert_eq!(expn_data.orig_id, None);\n+            expn_data.orig_id = Some(self.as_u32());\n             *old_expn_data = Some(expn_data);\n         });\n         update_disambiguator(self)\n@@ -202,7 +203,8 @@ impl HygieneData {\n     fn fresh_expn(&mut self, mut expn_data: Option<ExpnData>) -> ExpnId {\n         let raw_id = self.expn_data.len() as u32;\n         if let Some(data) = expn_data.as_mut() {\n-            data.orig_id.replace(raw_id).expect_none(\"orig_id should be None\");\n+            assert_eq!(data.orig_id, None);\n+            data.orig_id = Some(raw_id);\n         }\n         self.expn_data.push(expn_data);\n         ExpnId(raw_id)\n@@ -1410,9 +1412,11 @@ fn update_disambiguator(expn_id: ExpnId) {\n             let new_hash: Fingerprint = hasher.finish();\n \n             HygieneData::with(|data| {\n-                data.expn_data_disambiguators\n-                    .get(&new_hash)\n-                    .expect_none(\"Hash collision after disambiguator update!\");\n+                assert_eq!(\n+                    data.expn_data_disambiguators.get(&new_hash),\n+                    None,\n+                    \"Hash collision after disambiguator update!\",\n+                );\n             });\n         };\n     }"}, {"sha": "d2790335b5abc6f42186bc43b6ee21f3650a9929", "filename": "compiler/rustc_span/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9f4bc3ead43a57783d8abea2fa6931a6736f3490/compiler%2Frustc_span%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f4bc3ead43a57783d8abea2fa6931a6736f3490/compiler%2Frustc_span%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Flib.rs?ref=9f4bc3ead43a57783d8abea2fa6931a6736f3490", "patch": "@@ -21,7 +21,6 @@\n #![feature(negative_impls)]\n #![feature(nll)]\n #![feature(min_specialization)]\n-#![feature(option_expect_none)]\n \n #[macro_use]\n extern crate rustc_macros;\n@@ -1996,7 +1995,8 @@ impl<CTX: HashStableContext> HashStable<CTX> for ExpnId {\n                 if cache.len() < new_len {\n                     cache.resize(new_len, None);\n                 }\n-                cache[index].replace(sub_hash).expect_none(\"Cache slot was filled\");\n+                let prev = cache[index].replace(sub_hash);\n+                assert_eq!(prev, None, \"Cache slot was filled\");\n             });\n             sub_hash.hash_stable(ctx, hasher);\n         }"}, {"sha": "f612d1425b932b9e7b0f925750ba8621b8568672", "filename": "compiler/rustc_span/src/source_map.rs", "status": "modified", "additions": 0, "deletions": 42, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/9f4bc3ead43a57783d8abea2fa6931a6736f3490/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f4bc3ead43a57783d8abea2fa6931a6736f3490/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsource_map.rs?ref=9f4bc3ead43a57783d8abea2fa6931a6736f3490", "patch": "@@ -453,41 +453,6 @@ impl SourceMap {\n         }\n     }\n \n-    /// Returns `Some(span)`, a union of the LHS and RHS span. The LHS must precede the RHS. If\n-    /// there are gaps between LHS and RHS, the resulting union will cross these gaps.\n-    /// For this to work,\n-    ///\n-    ///    * the syntax contexts of both spans much match,\n-    ///    * the LHS span needs to end on the same line the RHS span begins,\n-    ///    * the LHS span must start at or before the RHS span.\n-    pub fn merge_spans(&self, sp_lhs: Span, sp_rhs: Span) -> Option<Span> {\n-        // Ensure we're at the same expansion ID.\n-        if sp_lhs.ctxt() != sp_rhs.ctxt() {\n-            return None;\n-        }\n-\n-        let lhs_end = match self.lookup_line(sp_lhs.hi()) {\n-            Ok(x) => x,\n-            Err(_) => return None,\n-        };\n-        let rhs_begin = match self.lookup_line(sp_rhs.lo()) {\n-            Ok(x) => x,\n-            Err(_) => return None,\n-        };\n-\n-        // If we must cross lines to merge, don't merge.\n-        if lhs_end.line != rhs_begin.line {\n-            return None;\n-        }\n-\n-        // Ensure these follow the expected order and that we don't overlap.\n-        if (sp_lhs.lo() <= sp_rhs.lo()) && (sp_lhs.hi() <= sp_rhs.lo()) {\n-            Some(sp_lhs.to(sp_rhs))\n-        } else {\n-            None\n-        }\n-    }\n-\n     pub fn span_to_string(&self, sp: Span) -> String {\n         if self.files.borrow().source_files.is_empty() && sp.is_dummy() {\n             return \"no-location\".to_string();\n@@ -931,13 +896,6 @@ impl SourceMap {\n         SourceFileAndBytePos { sf, pos: offset }\n     }\n \n-    /// Converts an absolute `BytePos` to a `CharPos` relative to the `SourceFile`.\n-    pub fn bytepos_to_file_charpos(&self, bpos: BytePos) -> CharPos {\n-        let idx = self.lookup_source_file_idx(bpos);\n-        let sf = &(*self.files.borrow().source_files)[idx];\n-        sf.bytepos_to_file_charpos(bpos)\n-    }\n-\n     // Returns the index of the `SourceFile` (in `self.files`) that contains `pos`.\n     // This index is guaranteed to be valid for the lifetime of this `SourceMap`,\n     // since `source_files` is a `MonotonicVec`"}, {"sha": "7d814f1d82c11404e840161733f0cf2f29615447", "filename": "compiler/rustc_span/src/source_map/tests.rs", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/9f4bc3ead43a57783d8abea2fa6931a6736f3490/compiler%2Frustc_span%2Fsrc%2Fsource_map%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f4bc3ead43a57783d8abea2fa6931a6736f3490/compiler%2Frustc_span%2Fsrc%2Fsource_map%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsource_map%2Ftests.rs?ref=9f4bc3ead43a57783d8abea2fa6931a6736f3490", "patch": "@@ -10,6 +10,50 @@ fn init_source_map() -> SourceMap {\n     sm\n }\n \n+impl SourceMap {\n+    /// Returns `Some(span)`, a union of the LHS and RHS span. The LHS must precede the RHS. If\n+    /// there are gaps between LHS and RHS, the resulting union will cross these gaps.\n+    /// For this to work,\n+    ///\n+    ///    * the syntax contexts of both spans much match,\n+    ///    * the LHS span needs to end on the same line the RHS span begins,\n+    ///    * the LHS span must start at or before the RHS span.\n+    fn merge_spans(&self, sp_lhs: Span, sp_rhs: Span) -> Option<Span> {\n+        // Ensure we're at the same expansion ID.\n+        if sp_lhs.ctxt() != sp_rhs.ctxt() {\n+            return None;\n+        }\n+\n+        let lhs_end = match self.lookup_line(sp_lhs.hi()) {\n+            Ok(x) => x,\n+            Err(_) => return None,\n+        };\n+        let rhs_begin = match self.lookup_line(sp_rhs.lo()) {\n+            Ok(x) => x,\n+            Err(_) => return None,\n+        };\n+\n+        // If we must cross lines to merge, don't merge.\n+        if lhs_end.line != rhs_begin.line {\n+            return None;\n+        }\n+\n+        // Ensure these follow the expected order and that we don't overlap.\n+        if (sp_lhs.lo() <= sp_rhs.lo()) && (sp_lhs.hi() <= sp_rhs.lo()) {\n+            Some(sp_lhs.to(sp_rhs))\n+        } else {\n+            None\n+        }\n+    }\n+\n+    /// Converts an absolute `BytePos` to a `CharPos` relative to the `SourceFile`.\n+    fn bytepos_to_file_charpos(&self, bpos: BytePos) -> CharPos {\n+        let idx = self.lookup_source_file_idx(bpos);\n+        let sf = &(*self.files.borrow().source_files)[idx];\n+        sf.bytepos_to_file_charpos(bpos)\n+    }\n+}\n+\n /// Tests `lookup_byte_offset`.\n #[test]\n fn t3() {"}, {"sha": "a07750f4ad1febcba63a15bab2359eb67edae650", "filename": "library/core/src/iter/traits/iterator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f4bc3ead43a57783d8abea2fa6931a6736f3490/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f4bc3ead43a57783d8abea2fa6931a6736f3490/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs?ref=9f4bc3ead43a57783d8abea2fa6931a6736f3490", "patch": "@@ -1012,7 +1012,7 @@ pub trait Iterator {\n     ///\n     /// Because the closure passed to `skip_while()` takes a reference, and many\n     /// iterators iterate over references, this leads to a possibly confusing\n-    /// situation, where the type of the closure is a double reference:\n+    /// situation, where the type of the closure argument is a double reference:\n     ///\n     /// ```\n     /// let a = [-1, 0, 1];"}, {"sha": "6abb300054af8c22516eb93200324a46941f606c", "filename": "library/std/src/io/mod.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9f4bc3ead43a57783d8abea2fa6931a6736f3490/library%2Fstd%2Fsrc%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f4bc3ead43a57783d8abea2fa6931a6736f3490/library%2Fstd%2Fsrc%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fmod.rs?ref=9f4bc3ead43a57783d8abea2fa6931a6736f3490", "patch": "@@ -514,8 +514,8 @@ pub trait Read {\n     /// waiting for data, but if an object needs to block for a read and cannot,\n     /// it will typically signal this via an [`Err`] return value.\n     ///\n-    /// If the return value of this method is [`Ok(n)`], then it must be\n-    /// guaranteed that `0 <= n <= buf.len()`. A nonzero `n` value indicates\n+    /// If the return value of this method is [`Ok(n)`], then implementations must\n+    /// guarantee that `0 <= n <= buf.len()`. A nonzero `n` value indicates\n     /// that the buffer `buf` has been filled in with `n` bytes of data from this\n     /// source. If `n` is `0`, then it can indicate one of two scenarios:\n     ///\n@@ -529,6 +529,11 @@ pub trait Read {\n     /// This may happen for example because fewer bytes are actually available right now\n     /// (e. g. being close to end-of-file) or because read() was interrupted by a signal.\n     ///\n+    /// As this trait is safe to implement, callers cannot rely on `n <= buf.len()` for safety.\n+    /// Extra care needs to be taken when `unsafe` functions are used to access the read bytes.\n+    /// Callers have to ensure that no unchecked out-of-bounds accesses are possible even if\n+    /// `n > buf.len()`.\n+    ///\n     /// No guarantees are provided about the contents of `buf` when this\n     /// function is called, implementations cannot rely on any property of the\n     /// contents of `buf` being true. It is recommended that *implementations*"}, {"sha": "48117d288ae4799258abe2d88096d2163c922ff5", "filename": "library/std/src/os/haiku/raw.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9f4bc3ead43a57783d8abea2fa6931a6736f3490/library%2Fstd%2Fsrc%2Fos%2Fhaiku%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f4bc3ead43a57783d8abea2fa6931a6736f3490/library%2Fstd%2Fsrc%2Fos%2Fhaiku%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fhaiku%2Fraw.rs?ref=9f4bc3ead43a57783d8abea2fa6931a6736f3490", "patch": "@@ -1,6 +1,13 @@\n //! Haiku-specific raw type definitions\n \n #![stable(feature = \"raw_ext\", since = \"1.1.0\")]\n+#![rustc_deprecated(\n+    since = \"1.53.0\",\n+    reason = \"these type aliases are no longer supported by \\\n+              the standard library, the `libc` crate on \\\n+              crates.io should be used instead for the correct \\\n+              definitions\"\n+)]\n #![allow(deprecated)]\n \n use crate::os::raw::c_long;"}, {"sha": "17a51abeb0ef67d6c5e21f21d45499704febdc13", "filename": "library/std/src/sys/hermit/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9f4bc3ead43a57783d8abea2fa6931a6736f3490/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f4bc3ead43a57783d8abea2fa6931a6736f3490/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fmod.rs?ref=9f4bc3ead43a57783d8abea2fa6931a6736f3490", "patch": "@@ -32,6 +32,7 @@ pub mod mutex;\n pub mod net;\n pub mod os;\n pub mod path;\n+#[path = \"../unsupported/pipe.rs\"]\n pub mod pipe;\n #[path = \"../unsupported/process.rs\"]\n pub mod process;"}, {"sha": "10d0925823eb94660278ce2390c892c093d7e3c6", "filename": "library/std/src/sys/hermit/pipe.rs", "status": "removed", "additions": 0, "deletions": 38, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/b97fd3e5a1545ab02e18c52e7f3d2e78a5c960bf/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b97fd3e5a1545ab02e18c52e7f3d2e78a5c960bf/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fpipe.rs?ref=b97fd3e5a1545ab02e18c52e7f3d2e78a5c960bf", "patch": "@@ -1,38 +0,0 @@\n-use crate::io::{self, IoSlice, IoSliceMut};\n-use crate::sys::Void;\n-\n-pub struct AnonPipe(Void);\n-\n-impl AnonPipe {\n-    pub fn read(&self, _buf: &mut [u8]) -> io::Result<usize> {\n-        match self.0 {}\n-    }\n-\n-    pub fn read_vectored(&self, _bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n-        match self.0 {}\n-    }\n-\n-    pub fn is_read_vectored(&self) -> bool {\n-        match self.0 {}\n-    }\n-\n-    pub fn write(&self, _buf: &[u8]) -> io::Result<usize> {\n-        match self.0 {}\n-    }\n-\n-    pub fn write_vectored(&self, _bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n-        match self.0 {}\n-    }\n-\n-    pub fn is_write_vectored(&self) -> bool {\n-        match self.0 {}\n-    }\n-\n-    pub fn diverge(&self) -> ! {\n-        match self.0 {}\n-    }\n-}\n-\n-pub fn read2(p1: AnonPipe, _v1: &mut Vec<u8>, _p2: AnonPipe, _v2: &mut Vec<u8>) -> io::Result<()> {\n-    match p1.0 {}\n-}"}, {"sha": "6147bd0a97a968e7234517d271405a290243ee60", "filename": "src/doc/rustdoc/src/advanced-features.md", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9f4bc3ead43a57783d8abea2fa6931a6736f3490/src%2Fdoc%2Frustdoc%2Fsrc%2Fadvanced-features.md", "raw_url": "https://github.com/rust-lang/rust/raw/9f4bc3ead43a57783d8abea2fa6931a6736f3490/src%2Fdoc%2Frustdoc%2Fsrc%2Fadvanced-features.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc%2Fsrc%2Fadvanced-features.md?ref=9f4bc3ead43a57783d8abea2fa6931a6736f3490", "patch": "@@ -81,3 +81,10 @@ Then, when looking for it through the `rustdoc` search, if you enter \"x\" or\n \"big\", search will show the `BigX` struct first.\n \n There are some limitations on the doc alias names though: you can't use `\"` or whitespace.\n+\n+You can add multiple aliases at the same time by using a list:\n+\n+```rust,no_run\n+#[doc(alias(\"x\", \"big\"))]\n+pub struct BigX;\n+```"}, {"sha": "840a42c2b8aab1f874a32471913d4d7cd5fac7ee", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/9f4bc3ead43a57783d8abea2fa6931a6736f3490/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f4bc3ead43a57783d8abea2fa6931a6736f3490/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=9f4bc3ead43a57783d8abea2fa6931a6736f3490", "patch": "@@ -910,12 +910,23 @@ impl Attributes {\n     }\n \n     crate fn get_doc_aliases(&self) -> FxHashSet<String> {\n-        self.other_attrs\n-            .lists(sym::doc)\n-            .filter(|a| a.has_name(sym::alias))\n-            .filter_map(|a| a.value_str().map(|s| s.to_string()))\n-            .filter(|v| !v.is_empty())\n-            .collect::<FxHashSet<_>>()\n+        let mut aliases = FxHashSet::default();\n+\n+        for attr in self.other_attrs.lists(sym::doc).filter(|a| a.has_name(sym::alias)) {\n+            if let Some(values) = attr.meta_item_list() {\n+                for l in values {\n+                    match l.literal().unwrap().kind {\n+                        ast::LitKind::Str(s, _) => {\n+                            aliases.insert(s.as_str().to_string());\n+                        }\n+                        _ => unreachable!(),\n+                    }\n+                }\n+            } else {\n+                aliases.insert(attr.value_str().map(|s| s.to_string()).unwrap());\n+            }\n+        }\n+        aliases\n     }\n }\n "}, {"sha": "719b98604c4978953562946341538c9d3a7f53df", "filename": "src/test/rustdoc-ui/check-doc-alias-attr.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9f4bc3ead43a57783d8abea2fa6931a6736f3490/src%2Ftest%2Frustdoc-ui%2Fcheck-doc-alias-attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f4bc3ead43a57783d8abea2fa6931a6736f3490/src%2Ftest%2Frustdoc-ui%2Fcheck-doc-alias-attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fcheck-doc-alias-attr.rs?ref=9f4bc3ead43a57783d8abea2fa6931a6736f3490", "patch": "@@ -1,16 +1,28 @@\n #![crate_type = \"lib\"]\n \n #[doc(alias = \"foo\")] // ok!\n+#[doc(alias(\"bar\", \"baz\"))] // ok!\n pub struct Bar;\n \n #[doc(alias)] //~ ERROR\n #[doc(alias = 0)] //~ ERROR\n-#[doc(alias(\"bar\"))] //~ ERROR\n #[doc(alias = \"\\\"\")] //~ ERROR\n #[doc(alias = \"\\n\")] //~ ERROR\n #[doc(alias = \"\n \")] //~^ ERROR\n #[doc(alias = \"\\t\")] //~ ERROR\n #[doc(alias = \" hello\")] //~ ERROR\n #[doc(alias = \"hello \")] //~ ERROR\n+#[doc(alias = \"\")] //~ ERROR\n pub struct Foo;\n+\n+#[doc(alias(0))] //~ ERROR\n+#[doc(alias(\"\\\"\"))] //~ ERROR\n+#[doc(alias(\"\\n\"))] //~ ERROR\n+#[doc(alias(\"\n+\"))] //~^ ERROR\n+#[doc(alias(\"\\t\"))] //~ ERROR\n+#[doc(alias(\" hello\"))] //~ ERROR\n+#[doc(alias(\"hello \"))] //~ ERROR\n+#[doc(alias(\"\"))] //~ ERROR\n+pub struct Foo2;"}, {"sha": "f99d69dc101b68e1c164d0dcd1f24f7e00d96745", "filename": "src/test/rustdoc-ui/check-doc-alias-attr.stderr", "status": "modified", "additions": 61, "deletions": 11, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/9f4bc3ead43a57783d8abea2fa6931a6736f3490/src%2Ftest%2Frustdoc-ui%2Fcheck-doc-alias-attr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9f4bc3ead43a57783d8abea2fa6931a6736f3490/src%2Ftest%2Frustdoc-ui%2Fcheck-doc-alias-attr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fcheck-doc-alias-attr.stderr?ref=9f4bc3ead43a57783d8abea2fa6931a6736f3490", "patch": "@@ -1,21 +1,15 @@\n-error: doc alias attribute expects a string: #[doc(alias = \"a\")]\n-  --> $DIR/check-doc-alias-attr.rs:6:7\n+error: doc alias attribute expects a string `#[doc(alias = \"a\")]` or a list of strings `#[doc(alias(\"a\", \"b\"))]`\n+  --> $DIR/check-doc-alias-attr.rs:7:7\n    |\n LL | #[doc(alias)]\n    |       ^^^^^\n \n-error: doc alias attribute expects a string: #[doc(alias = \"a\")]\n-  --> $DIR/check-doc-alias-attr.rs:7:7\n+error: doc alias attribute expects a string `#[doc(alias = \"a\")]` or a list of strings `#[doc(alias(\"a\", \"b\"))]`\n+  --> $DIR/check-doc-alias-attr.rs:8:7\n    |\n LL | #[doc(alias = 0)]\n    |       ^^^^^^^^^\n \n-error: doc alias attribute expects a string: #[doc(alias = \"a\")]\n-  --> $DIR/check-doc-alias-attr.rs:8:7\n-   |\n-LL | #[doc(alias(\"bar\"))]\n-   |       ^^^^^^^^^^^^\n-\n error: '\\\"' character isn't allowed in `#[doc(alias = \"...\")]`\n   --> $DIR/check-doc-alias-attr.rs:9:15\n    |\n@@ -54,5 +48,61 @@ error: `#[doc(alias = \"...\")]` cannot start or end with ' '\n LL | #[doc(alias = \"hello \")]\n    |               ^^^^^^^^\n \n-error: aborting due to 9 previous errors\n+error: `#[doc(alias = \"...\")]` attribute cannot have empty value\n+  --> $DIR/check-doc-alias-attr.rs:16:15\n+   |\n+LL | #[doc(alias = \"\")]\n+   |               ^^\n+\n+error: `#[doc(alias(\"a\"))]` expects string literals\n+  --> $DIR/check-doc-alias-attr.rs:19:13\n+   |\n+LL | #[doc(alias(0))]\n+   |             ^\n+\n+error: '\\\"' character isn't allowed in `#[doc(alias(\"...\"))]`\n+  --> $DIR/check-doc-alias-attr.rs:20:13\n+   |\n+LL | #[doc(alias(\"\\\"\"))]\n+   |             ^^^^\n+\n+error: '\\n' character isn't allowed in `#[doc(alias(\"...\"))]`\n+  --> $DIR/check-doc-alias-attr.rs:21:13\n+   |\n+LL | #[doc(alias(\"\\n\"))]\n+   |             ^^^^\n+\n+error: '\\n' character isn't allowed in `#[doc(alias(\"...\"))]`\n+  --> $DIR/check-doc-alias-attr.rs:22:13\n+   |\n+LL |   #[doc(alias(\"\n+   |  _____________^\n+LL | | \"))]\n+   | |_^\n+\n+error: '\\t' character isn't allowed in `#[doc(alias(\"...\"))]`\n+  --> $DIR/check-doc-alias-attr.rs:24:13\n+   |\n+LL | #[doc(alias(\"\\t\"))]\n+   |             ^^^^\n+\n+error: `#[doc(alias(\"...\"))]` cannot start or end with ' '\n+  --> $DIR/check-doc-alias-attr.rs:25:13\n+   |\n+LL | #[doc(alias(\" hello\"))]\n+   |             ^^^^^^^^\n+\n+error: `#[doc(alias(\"...\"))]` cannot start or end with ' '\n+  --> $DIR/check-doc-alias-attr.rs:26:13\n+   |\n+LL | #[doc(alias(\"hello \"))]\n+   |             ^^^^^^^^\n+\n+error: `#[doc(alias(\"...\"))]` attribute cannot have empty value\n+  --> $DIR/check-doc-alias-attr.rs:27:13\n+   |\n+LL | #[doc(alias(\"\"))]\n+   |             ^^\n+\n+error: aborting due to 17 previous errors\n "}, {"sha": "baa4fd3a10559d77043812621240db10de9fe587", "filename": "src/test/ui/proc-macro/group-compat-hack/auxiliary/pin-project-internal-0.4.0.rs", "status": "renamed", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9f4bc3ead43a57783d8abea2fa6931a6736f3490/src%2Ftest%2Fui%2Fproc-macro%2Fgroup-compat-hack%2Fauxiliary%2Fpin-project-internal-0.4.0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f4bc3ead43a57783d8abea2fa6931a6736f3490/src%2Ftest%2Fui%2Fproc-macro%2Fgroup-compat-hack%2Fauxiliary%2Fpin-project-internal-0.4.0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fgroup-compat-hack%2Fauxiliary%2Fpin-project-internal-0.4.0.rs?ref=9f4bc3ead43a57783d8abea2fa6931a6736f3490", "patch": "@@ -2,6 +2,10 @@\n // no-prefer-dynamic\n \n #![crate_type = \"proc-macro\"]\n+#![crate_name = \"group_compat_hack\"]\n+\n+// This file has an unusual name in order to trigger the back-compat\n+// code in the compiler\n \n extern crate proc_macro;\n use proc_macro::TokenStream;", "previous_filename": "src/test/ui/proc-macro/group-compat-hack/auxiliary/group-compat-hack.rs"}, {"sha": "d9687490cad7598e8465efc149edef40c7819e09", "filename": "src/test/ui/proc-macro/group-compat-hack/group-compat-hack.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9f4bc3ead43a57783d8abea2fa6931a6736f3490/src%2Ftest%2Fui%2Fproc-macro%2Fgroup-compat-hack%2Fgroup-compat-hack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f4bc3ead43a57783d8abea2fa6931a6736f3490/src%2Ftest%2Fui%2Fproc-macro%2Fgroup-compat-hack%2Fgroup-compat-hack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fgroup-compat-hack%2Fgroup-compat-hack.rs?ref=9f4bc3ead43a57783d8abea2fa6931a6736f3490", "patch": "@@ -1,5 +1,5 @@\n // check-pass\n-// aux-build:group-compat-hack.rs\n+// aux-build:pin-project-internal-0.4.0.rs\n // compile-flags: -Z span-debug\n \n #![no_std] // Don't load unnecessary hygiene information from std\n@@ -51,14 +51,16 @@ mod actix_web_test {\n     include!(\"actix-web/src/extract.rs\");\n \n     struct Foo;\n-    tuple_from_req!(Foo);\n+    tuple_from_req!(Foo); //~ WARN using an old version\n+    //~| WARN this was previously\n }\n \n mod actix_web_version_test {\n     include!(\"actix-web-2.0.0/src/extract.rs\");\n \n     struct Foo;\n-    tuple_from_req!(Foo);\n+    tuple_from_req!(Foo); //~ WARN using an old version\n+    //~| WARN this was previously\n }\n \n mod actori_web_test {"}, {"sha": "e2b680f8d27600e9d3b1ee992a51d6d7f171b9b1", "filename": "src/test/ui/proc-macro/group-compat-hack/group-compat-hack.stderr", "status": "modified", "additions": 67, "deletions": 1, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/9f4bc3ead43a57783d8abea2fa6931a6736f3490/src%2Ftest%2Fui%2Fproc-macro%2Fgroup-compat-hack%2Fgroup-compat-hack.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9f4bc3ead43a57783d8abea2fa6931a6736f3490/src%2Ftest%2Fui%2Fproc-macro%2Fgroup-compat-hack%2Fgroup-compat-hack.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fgroup-compat-hack%2Fgroup-compat-hack.stderr?ref=9f4bc3ead43a57783d8abea2fa6931a6736f3490", "patch": "@@ -31,7 +31,39 @@ LL |     impl_macros!(Foo);\n    = note: the `time-macros-impl` crate will stop compiling in futures version of Rust. Please update to the latest version of the `time` crate to avoid breakage\n    = note: this warning originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-warning: 2 warnings emitted\n+warning: using an old version of `actix-web`\n+  --> $DIR/actix-web/src/extract.rs:5:34\n+   |\n+LL |         #[my_macro] struct Three($T);\n+   |                                  ^^\n+   | \n+  ::: $DIR/group-compat-hack.rs:54:5\n+   |\n+LL |     tuple_from_req!(Foo);\n+   |     --------------------- in this macro invocation\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #83125 <https://github.com/rust-lang/rust/issues/83125>\n+   = note: the version of `actix-web` you are using might stop compiling in future versions of Rust; please update to the latest version of the `actix-web` crate to avoid breakage\n+   = note: this warning originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+warning: using an old version of `actix-web`\n+  --> $DIR/actix-web-2.0.0/src/extract.rs:5:34\n+   |\n+LL |         #[my_macro] struct Three($T);\n+   |                                  ^^\n+   | \n+  ::: $DIR/group-compat-hack.rs:62:5\n+   |\n+LL |     tuple_from_req!(Foo);\n+   |     --------------------- in this macro invocation\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #83125 <https://github.com/rust-lang/rust/issues/83125>\n+   = note: the version of `actix-web` you are using might stop compiling in future versions of Rust; please update to the latest version of the `actix-web` crate to avoid breakage\n+   = note: this warning originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+warning: 4 warnings emitted\n \n Future incompatibility report: Future breakage date: None, diagnostic:\n warning: using an old version of `time-macros-impl`\n@@ -68,3 +100,37 @@ LL |     impl_macros!(Foo);\n    = note: the `time-macros-impl` crate will stop compiling in futures version of Rust. Please update to the latest version of the `time` crate to avoid breakage\n    = note: this warning originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n+Future breakage date: None, diagnostic:\n+warning: using an old version of `actix-web`\n+  --> $DIR/actix-web/src/extract.rs:5:34\n+   |\n+LL |         #[my_macro] struct Three($T);\n+   |                                  ^^\n+   | \n+  ::: $DIR/group-compat-hack.rs:54:5\n+   |\n+LL |     tuple_from_req!(Foo);\n+   |     --------------------- in this macro invocation\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #83125 <https://github.com/rust-lang/rust/issues/83125>\n+   = note: the version of `actix-web` you are using might stop compiling in future versions of Rust; please update to the latest version of the `actix-web` crate to avoid breakage\n+   = note: this warning originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+Future breakage date: None, diagnostic:\n+warning: using an old version of `actix-web`\n+  --> $DIR/actix-web-2.0.0/src/extract.rs:5:34\n+   |\n+LL |         #[my_macro] struct Three($T);\n+   |                                  ^^\n+   | \n+  ::: $DIR/group-compat-hack.rs:62:5\n+   |\n+LL |     tuple_from_req!(Foo);\n+   |     --------------------- in this macro invocation\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #83125 <https://github.com/rust-lang/rust/issues/83125>\n+   = note: the version of `actix-web` you are using might stop compiling in future versions of Rust; please update to the latest version of the `actix-web` crate to avoid breakage\n+   = note: this warning originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+"}, {"sha": "3fe744e12ff0459a2df04c4e60913abb5508f3dd", "filename": "src/test/ui/proc-macro/group-compat-hack/group-compat-hack.stdout", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9f4bc3ead43a57783d8abea2fa6931a6736f3490/src%2Ftest%2Fui%2Fproc-macro%2Fgroup-compat-hack%2Fgroup-compat-hack.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/9f4bc3ead43a57783d8abea2fa6931a6736f3490/src%2Ftest%2Fui%2Fproc-macro%2Fgroup-compat-hack%2Fgroup-compat-hack.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fgroup-compat-hack%2Fgroup-compat-hack.stdout?ref=9f4bc3ead43a57783d8abea2fa6931a6736f3490", "patch": "@@ -5,6 +5,6 @@ Called proc_macro_hack with TokenStream [Ident { ident: \"struct\", span: $DIR/tim\n Called proc_macro_hack with TokenStream [Ident { ident: \"struct\", span: $DIR/js-sys-0.3.17/src/lib.rs:5:21: 5:27 (#24) }, Ident { ident: \"Two\", span: $DIR/js-sys-0.3.17/src/lib.rs:5:28: 5:31 (#24) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { ident: \"Foo\", span: $DIR/group-compat-hack.rs:46:13: 46:16 (#0) }], span: $DIR/js-sys-0.3.17/src/lib.rs:5:31: 5:38 (#24) }, Punct { ch: ';', spacing: Alone, span: $DIR/js-sys-0.3.17/src/lib.rs:5:38: 5:39 (#24) }]\n Called proc_macro_hack with TokenStream [Ident { ident: \"struct\", span: $DIR/group-compat-hack.rs:39:25: 39:31 (#28) }, Ident { ident: \"Three\", span: $DIR/group-compat-hack.rs:39:32: 39:37 (#28) }, Group { delimiter: Parenthesis, stream: TokenStream [Group { delimiter: None, stream: TokenStream [Ident { ident: \"Foo\", span: $DIR/group-compat-hack.rs:47:12: 47:15 (#0) }], span: $DIR/group-compat-hack.rs:39:38: 39:43 (#28) }], span: $DIR/group-compat-hack.rs:39:37: 39:44 (#28) }, Punct { ch: ';', spacing: Alone, span: $DIR/group-compat-hack.rs:39:44: 39:45 (#28) }]\n Called proc_macro_hack with TokenStream [Ident { ident: \"struct\", span: $DIR/actix-web/src/extract.rs:5:21: 5:27 (#33) }, Ident { ident: \"Three\", span: $DIR/actix-web/src/extract.rs:5:28: 5:33 (#33) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { ident: \"Foo\", span: $DIR/group-compat-hack.rs:54:21: 54:24 (#0) }], span: $DIR/actix-web/src/extract.rs:5:33: 5:37 (#33) }, Punct { ch: ';', spacing: Alone, span: $DIR/actix-web/src/extract.rs:5:37: 5:38 (#33) }]\n-Called proc_macro_hack with TokenStream [Ident { ident: \"struct\", span: $DIR/actix-web-2.0.0/src/extract.rs:5:21: 5:27 (#38) }, Ident { ident: \"Three\", span: $DIR/actix-web-2.0.0/src/extract.rs:5:28: 5:33 (#38) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { ident: \"Foo\", span: $DIR/group-compat-hack.rs:61:21: 61:24 (#0) }], span: $DIR/actix-web-2.0.0/src/extract.rs:5:33: 5:37 (#38) }, Punct { ch: ';', spacing: Alone, span: $DIR/actix-web-2.0.0/src/extract.rs:5:37: 5:38 (#38) }]\n-Called proc_macro_hack with TokenStream [Ident { ident: \"struct\", span: $DIR/actori-web/src/extract.rs:5:21: 5:27 (#43) }, Ident { ident: \"Four\", span: $DIR/actori-web/src/extract.rs:5:28: 5:32 (#43) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { ident: \"Foo\", span: $DIR/group-compat-hack.rs:68:21: 68:24 (#0) }], span: $DIR/actori-web/src/extract.rs:5:32: 5:36 (#43) }, Punct { ch: ';', spacing: Alone, span: $DIR/actori-web/src/extract.rs:5:36: 5:37 (#43) }]\n-Called proc_macro_hack with TokenStream [Ident { ident: \"struct\", span: $DIR/actori-web-2.0.0/src/extract.rs:5:21: 5:27 (#48) }, Ident { ident: \"Four\", span: $DIR/actori-web-2.0.0/src/extract.rs:5:28: 5:32 (#48) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { ident: \"Foo\", span: $DIR/group-compat-hack.rs:75:21: 75:24 (#0) }], span: $DIR/actori-web-2.0.0/src/extract.rs:5:32: 5:36 (#48) }, Punct { ch: ';', spacing: Alone, span: $DIR/actori-web-2.0.0/src/extract.rs:5:36: 5:37 (#48) }]\n+Called proc_macro_hack with TokenStream [Ident { ident: \"struct\", span: $DIR/actix-web-2.0.0/src/extract.rs:5:21: 5:27 (#38) }, Ident { ident: \"Three\", span: $DIR/actix-web-2.0.0/src/extract.rs:5:28: 5:33 (#38) }, Group { delimiter: Parenthesis, stream: TokenStream [Ident { ident: \"Foo\", span: $DIR/group-compat-hack.rs:62:21: 62:24 (#0) }], span: $DIR/actix-web-2.0.0/src/extract.rs:5:33: 5:37 (#38) }, Punct { ch: ';', spacing: Alone, span: $DIR/actix-web-2.0.0/src/extract.rs:5:37: 5:38 (#38) }]\n+Called proc_macro_hack with TokenStream [Ident { ident: \"struct\", span: $DIR/actori-web/src/extract.rs:5:21: 5:27 (#43) }, Ident { ident: \"Four\", span: $DIR/actori-web/src/extract.rs:5:28: 5:32 (#43) }, Group { delimiter: Parenthesis, stream: TokenStream [Group { delimiter: None, stream: TokenStream [Ident { ident: \"Foo\", span: $DIR/group-compat-hack.rs:70:21: 70:24 (#0) }], span: $DIR/actori-web/src/extract.rs:5:33: 5:35 (#43) }], span: $DIR/actori-web/src/extract.rs:5:32: 5:36 (#43) }, Punct { ch: ';', spacing: Alone, span: $DIR/actori-web/src/extract.rs:5:36: 5:37 (#43) }]\n+Called proc_macro_hack with TokenStream [Ident { ident: \"struct\", span: $DIR/actori-web-2.0.0/src/extract.rs:5:21: 5:27 (#48) }, Ident { ident: \"Four\", span: $DIR/actori-web-2.0.0/src/extract.rs:5:28: 5:32 (#48) }, Group { delimiter: Parenthesis, stream: TokenStream [Group { delimiter: None, stream: TokenStream [Ident { ident: \"Foo\", span: $DIR/group-compat-hack.rs:77:21: 77:24 (#0) }], span: $DIR/actori-web-2.0.0/src/extract.rs:5:33: 5:35 (#48) }], span: $DIR/actori-web-2.0.0/src/extract.rs:5:32: 5:36 (#48) }, Punct { ch: ';', spacing: Alone, span: $DIR/actori-web-2.0.0/src/extract.rs:5:36: 5:37 (#48) }]"}, {"sha": "719b98604c4978953562946341538c9d3a7f53df", "filename": "src/test/ui/rustdoc/check-doc-alias-attr.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9f4bc3ead43a57783d8abea2fa6931a6736f3490/src%2Ftest%2Fui%2Frustdoc%2Fcheck-doc-alias-attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f4bc3ead43a57783d8abea2fa6931a6736f3490/src%2Ftest%2Fui%2Frustdoc%2Fcheck-doc-alias-attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frustdoc%2Fcheck-doc-alias-attr.rs?ref=9f4bc3ead43a57783d8abea2fa6931a6736f3490", "patch": "@@ -1,16 +1,28 @@\n #![crate_type = \"lib\"]\n \n #[doc(alias = \"foo\")] // ok!\n+#[doc(alias(\"bar\", \"baz\"))] // ok!\n pub struct Bar;\n \n #[doc(alias)] //~ ERROR\n #[doc(alias = 0)] //~ ERROR\n-#[doc(alias(\"bar\"))] //~ ERROR\n #[doc(alias = \"\\\"\")] //~ ERROR\n #[doc(alias = \"\\n\")] //~ ERROR\n #[doc(alias = \"\n \")] //~^ ERROR\n #[doc(alias = \"\\t\")] //~ ERROR\n #[doc(alias = \" hello\")] //~ ERROR\n #[doc(alias = \"hello \")] //~ ERROR\n+#[doc(alias = \"\")] //~ ERROR\n pub struct Foo;\n+\n+#[doc(alias(0))] //~ ERROR\n+#[doc(alias(\"\\\"\"))] //~ ERROR\n+#[doc(alias(\"\\n\"))] //~ ERROR\n+#[doc(alias(\"\n+\"))] //~^ ERROR\n+#[doc(alias(\"\\t\"))] //~ ERROR\n+#[doc(alias(\" hello\"))] //~ ERROR\n+#[doc(alias(\"hello \"))] //~ ERROR\n+#[doc(alias(\"\"))] //~ ERROR\n+pub struct Foo2;"}, {"sha": "f99d69dc101b68e1c164d0dcd1f24f7e00d96745", "filename": "src/test/ui/rustdoc/check-doc-alias-attr.stderr", "status": "modified", "additions": 61, "deletions": 11, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/9f4bc3ead43a57783d8abea2fa6931a6736f3490/src%2Ftest%2Fui%2Frustdoc%2Fcheck-doc-alias-attr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9f4bc3ead43a57783d8abea2fa6931a6736f3490/src%2Ftest%2Fui%2Frustdoc%2Fcheck-doc-alias-attr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frustdoc%2Fcheck-doc-alias-attr.stderr?ref=9f4bc3ead43a57783d8abea2fa6931a6736f3490", "patch": "@@ -1,21 +1,15 @@\n-error: doc alias attribute expects a string: #[doc(alias = \"a\")]\n-  --> $DIR/check-doc-alias-attr.rs:6:7\n+error: doc alias attribute expects a string `#[doc(alias = \"a\")]` or a list of strings `#[doc(alias(\"a\", \"b\"))]`\n+  --> $DIR/check-doc-alias-attr.rs:7:7\n    |\n LL | #[doc(alias)]\n    |       ^^^^^\n \n-error: doc alias attribute expects a string: #[doc(alias = \"a\")]\n-  --> $DIR/check-doc-alias-attr.rs:7:7\n+error: doc alias attribute expects a string `#[doc(alias = \"a\")]` or a list of strings `#[doc(alias(\"a\", \"b\"))]`\n+  --> $DIR/check-doc-alias-attr.rs:8:7\n    |\n LL | #[doc(alias = 0)]\n    |       ^^^^^^^^^\n \n-error: doc alias attribute expects a string: #[doc(alias = \"a\")]\n-  --> $DIR/check-doc-alias-attr.rs:8:7\n-   |\n-LL | #[doc(alias(\"bar\"))]\n-   |       ^^^^^^^^^^^^\n-\n error: '\\\"' character isn't allowed in `#[doc(alias = \"...\")]`\n   --> $DIR/check-doc-alias-attr.rs:9:15\n    |\n@@ -54,5 +48,61 @@ error: `#[doc(alias = \"...\")]` cannot start or end with ' '\n LL | #[doc(alias = \"hello \")]\n    |               ^^^^^^^^\n \n-error: aborting due to 9 previous errors\n+error: `#[doc(alias = \"...\")]` attribute cannot have empty value\n+  --> $DIR/check-doc-alias-attr.rs:16:15\n+   |\n+LL | #[doc(alias = \"\")]\n+   |               ^^\n+\n+error: `#[doc(alias(\"a\"))]` expects string literals\n+  --> $DIR/check-doc-alias-attr.rs:19:13\n+   |\n+LL | #[doc(alias(0))]\n+   |             ^\n+\n+error: '\\\"' character isn't allowed in `#[doc(alias(\"...\"))]`\n+  --> $DIR/check-doc-alias-attr.rs:20:13\n+   |\n+LL | #[doc(alias(\"\\\"\"))]\n+   |             ^^^^\n+\n+error: '\\n' character isn't allowed in `#[doc(alias(\"...\"))]`\n+  --> $DIR/check-doc-alias-attr.rs:21:13\n+   |\n+LL | #[doc(alias(\"\\n\"))]\n+   |             ^^^^\n+\n+error: '\\n' character isn't allowed in `#[doc(alias(\"...\"))]`\n+  --> $DIR/check-doc-alias-attr.rs:22:13\n+   |\n+LL |   #[doc(alias(\"\n+   |  _____________^\n+LL | | \"))]\n+   | |_^\n+\n+error: '\\t' character isn't allowed in `#[doc(alias(\"...\"))]`\n+  --> $DIR/check-doc-alias-attr.rs:24:13\n+   |\n+LL | #[doc(alias(\"\\t\"))]\n+   |             ^^^^\n+\n+error: `#[doc(alias(\"...\"))]` cannot start or end with ' '\n+  --> $DIR/check-doc-alias-attr.rs:25:13\n+   |\n+LL | #[doc(alias(\" hello\"))]\n+   |             ^^^^^^^^\n+\n+error: `#[doc(alias(\"...\"))]` cannot start or end with ' '\n+  --> $DIR/check-doc-alias-attr.rs:26:13\n+   |\n+LL | #[doc(alias(\"hello \"))]\n+   |             ^^^^^^^^\n+\n+error: `#[doc(alias(\"...\"))]` attribute cannot have empty value\n+  --> $DIR/check-doc-alias-attr.rs:27:13\n+   |\n+LL | #[doc(alias(\"\"))]\n+   |             ^^\n+\n+error: aborting due to 17 previous errors\n "}, {"sha": "96a02038638af8dd3096b51a5a8e782a45925e5c", "filename": "src/tools/tidy/src/deps.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9f4bc3ead43a57783d8abea2fa6931a6736f3490/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f4bc3ead43a57783d8abea2fa6931a6736f3490/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs?ref=9f4bc3ead43a57783d8abea2fa6931a6736f3490", "patch": "@@ -123,6 +123,7 @@ const PERMITTED_DEPENDENCIES: &[&str] = &[\n     \"measureme\",\n     \"memchr\",\n     \"memmap\",\n+    \"memmap2\",\n     \"memoffset\",\n     \"miniz_oxide\",\n     \"num_cpus\","}]}