{"sha": "ddb2466f6a1bb66f22824334022a4cee61c73bdc", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRkYjI0NjZmNmExYmI2NmYyMjgyNDMzNDAyMmE0Y2VlNjFjNzNiZGM=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2014-11-14T17:18:10Z"}, "committer": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2014-12-18T17:09:07Z"}, "message": "librustc: Always parse `macro!()`/`macro![]` as expressions if not\nfollowed by a semicolon.\n\nThis allows code like `vec![1i, 2, 3].len();` to work.\n\nThis breaks code that uses macros as statements without putting\nsemicolons after them, such as:\n\n    fn main() {\n        ...\n        assert!(a == b)\n        assert!(c == d)\n        println(...);\n    }\n\nIt also breaks code that uses macros as items without semicolons:\n\n    local_data_key!(foo)\n\n    fn main() {\n        println(\"hello world\")\n    }\n\nAdd semicolons to fix this code. Those two examples can be fixed as\nfollows:\n\n    fn main() {\n        ...\n        assert!(a == b);\n        assert!(c == d);\n        println(...);\n    }\n\n    local_data_key!(foo);\n\n    fn main() {\n        println(\"hello world\")\n    }\n\nRFC #378.\n\nCloses #18635.\n\n[breaking-change]", "tree": {"sha": "9cb97d3e4c4521b56d0776e5f7bda81e62135be4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9cb97d3e4c4521b56d0776e5f7bda81e62135be4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ddb2466f6a1bb66f22824334022a4cee61c73bdc", "comment_count": 7, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ddb2466f6a1bb66f22824334022a4cee61c73bdc", "html_url": "https://github.com/rust-lang/rust/commit/ddb2466f6a1bb66f22824334022a4cee61c73bdc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ddb2466f6a1bb66f22824334022a4cee61c73bdc/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c0b2885ee12b79c99ac8245edb6eebaaa8e7fef1", "url": "https://api.github.com/repos/rust-lang/rust/commits/c0b2885ee12b79c99ac8245edb6eebaaa8e7fef1", "html_url": "https://github.com/rust-lang/rust/commit/c0b2885ee12b79c99ac8245edb6eebaaa8e7fef1"}], "stats": {"total": 4385, "additions": 2338, "deletions": 2047}, "files": [{"sha": "58af591740709de8d5174a4ad8e55e2f234d2fea", "filename": "src/doc/guide-macros.md", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Fdoc%2Fguide-macros.md", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Fdoc%2Fguide-macros.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-macros.md?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -58,7 +58,7 @@ macro_rules! early_return(\n             _ => {}\n         }\n     );\n-)\n+);\n // ...\n early_return!(input_1 T::SpecialA);\n // ...\n@@ -179,8 +179,8 @@ macro_rules! early_return(\n             )+\n             _ => {}\n         }\n-    );\n-)\n+    )\n+);\n // ...\n early_return!(input_1, [T::SpecialA|T::SpecialC|T::SpecialD]);\n // ...\n@@ -275,17 +275,17 @@ macro_rules! biased_match (\n             _ => { $err }\n         };\n     )\n-)\n+);\n \n # enum T1 { Good1(T2, uint), Bad1}\n # struct T2 { body: T3 }\n # enum T3 { Good2(uint), Bad2}\n # fn f(x: T1) -> uint {\n biased_match!((x)       ~ (T1::Good1(g1, val)) else { return 0 };\n-              binds g1, val )\n+              binds g1, val );\n biased_match!((g1.body) ~ (T3::Good2(result) )\n                   else { panic!(\"Didn't get good_2\") };\n-              binds result )\n+              binds result );\n // complicated stuff goes here\n return result + val;\n # }\n@@ -303,7 +303,7 @@ pattern we want is clear:\n     ( $( ($e:expr) ~ ($p:pat) else $err:stmt ; )*\n       binds $( $bind_res:ident ),*\n     )\n-# => (0))\n+# => (0));\n ~~~~\n \n However, it's not possible to directly expand to nested match statements. But\n@@ -323,7 +323,7 @@ input patterns:\n # #![feature(macro_rules)]\n # macro_rules! b(\n     ( binds $( $bind_res:ident ),* )\n-# => (0))\n+# => (0));\n # fn main() {}\n ~~~~\n \n@@ -337,7 +337,7 @@ input patterns:\n       $( ($e_rest:expr) ~ ($p_rest:pat) else $err_rest:stmt ; )*\n       binds  $( $bind_res:ident ),*\n     )\n-# => (0))\n+# => (0));\n ~~~~\n \n The resulting macro looks like this. Note that the separation into\n@@ -366,7 +366,7 @@ macro_rules! biased_match_rec (\n     );\n     // Produce the requested values\n     ( binds $( $bind_res:ident ),* ) => ( ($( $bind_res ),*) )\n-)\n+);\n \n // Wrap the whole thing in a `let`.\n macro_rules! biased_match (\n@@ -388,7 +388,7 @@ macro_rules! biased_match (\n             binds $( $bind_res ),*\n         );\n     )\n-)\n+);\n \n \n # enum T1 { Good1(T2, uint), Bad1}\n@@ -398,7 +398,7 @@ macro_rules! biased_match (\n biased_match!(\n     (x)       ~ (T1::Good1(g1, val)) else { return 0 };\n     (g1.body) ~ (T3::Good2(result) ) else { panic!(\"Didn't get Good2\") };\n-    binds val, result )\n+    binds val, result );\n // complicated stuff goes here\n return result + val;\n # }\n@@ -444,7 +444,7 @@ macro_rules! loop_x (\n             $e\n         }\n     );\n-)\n+);\n \n fn main() {\n     'x: loop {\n@@ -482,30 +482,30 @@ An example:\n \n ```rust\n # #![feature(macro_rules)]\n-macro_rules! m1 (() => (()))\n+macro_rules! m1 (() => (()));\n \n // visible here: m1\n \n mod foo {\n     // visible here: m1\n \n     #[macro_export]\n-    macro_rules! m2 (() => (()))\n+    macro_rules! m2 (() => (()));\n \n     // visible here: m1, m2\n }\n \n // visible here: m1\n \n-macro_rules! m3 (() => (()))\n+macro_rules! m3 (() => (()));\n \n // visible here: m1, m3\n \n #[macro_escape]\n mod bar {\n     // visible here: m1, m3\n \n-    macro_rules! m4 (() => (()))\n+    macro_rules! m4 (() => (()));\n \n     // visible here: m1, m3, m4\n }"}, {"sha": "ea7f51c86f81754141e47940abe12ae2445863e2", "filename": "src/etc/regex-match-tests.py", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Fetc%2Fregex-match-tests.py", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Fetc%2Fregex-match-tests.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fregex-match-tests.py?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -63,7 +63,7 @@ def read_tests(f):\n def test_tostr(t):\n     lineno, pat, text, groups = t\n     options = map(group_tostr, groups)\n-    return 'mat!(match_%s, r\"%s\", r\"%s\", %s)' \\\n+    return 'mat!{match_%s, r\"%s\", r\"%s\", %s}' \\\n            % (lineno, pat, '' if text == \"NULL\" else text, ', '.join(options))\n \n "}, {"sha": "7f78d56607e7ae9503983fe9e515e37f458d0859", "filename": "src/libcollections/bit.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibcollections%2Fbit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibcollections%2Fbit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbit.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -2083,7 +2083,7 @@ mod tests {\n         let bools = vec![true, false, true, true];\n         let bitv: Bitv = bools.iter().map(|n| *n).collect();\n \n-        assert_eq!(bitv.iter().collect::<Vec<bool>>(), bools)\n+        assert_eq!(bitv.iter().collect::<Vec<bool>>(), bools);\n \n         let long = Vec::from_fn(10000, |i| i % 2 == 0);\n         let bitv: Bitv = long.iter().map(|n| *n).collect();\n@@ -2112,8 +2112,8 @@ mod tests {\n         for &b in bools.iter() {\n             for &l in lengths.iter() {\n                 let bitset = BitvSet::from_bitv(Bitv::with_capacity(l, b));\n-                assert_eq!(bitset.contains(&1u), b)\n-                assert_eq!(bitset.contains(&(l-1u)), b)\n+                assert_eq!(bitset.contains(&1u), b);\n+                assert_eq!(bitset.contains(&(l-1u)), b);\n                 assert!(!bitset.contains(&l))\n             }\n         }\n@@ -2321,12 +2321,12 @@ mod tests {\n         assert!(!a.is_disjoint(&d));\n         assert!(!d.is_disjoint(&a));\n \n-        assert!(a.is_disjoint(&b))\n-        assert!(a.is_disjoint(&c))\n-        assert!(b.is_disjoint(&a))\n-        assert!(b.is_disjoint(&c))\n-        assert!(c.is_disjoint(&a))\n-        assert!(c.is_disjoint(&b))\n+        assert!(a.is_disjoint(&b));\n+        assert!(a.is_disjoint(&c));\n+        assert!(b.is_disjoint(&a));\n+        assert!(b.is_disjoint(&c));\n+        assert!(c.is_disjoint(&a));\n+        assert!(c.is_disjoint(&b));\n     }\n \n     #[test]"}, {"sha": "49b66ce25f572f46d71c862b02817e62928b3a8f", "filename": "src/libcollections/enum_set.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibcollections%2Fenum_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibcollections%2Fenum_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fenum_set.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -411,7 +411,7 @@ mod test {\n \n         assert!(e1.is_subset(&e2));\n         assert!(e2.is_superset(&e1));\n-        assert!(!e3.is_superset(&e2))\n+        assert!(!e3.is_superset(&e2));\n         assert!(!e2.is_superset(&e3))\n     }\n \n@@ -438,23 +438,23 @@ mod test {\n         let mut e1: EnumSet<Foo> = EnumSet::new();\n \n         let elems: ::vec::Vec<Foo> = e1.iter().collect();\n-        assert!(elems.is_empty())\n+        assert!(elems.is_empty());\n \n         e1.insert(A);\n         let elems: ::vec::Vec<_> = e1.iter().collect();\n-        assert_eq!(vec![A], elems)\n+        assert_eq!(vec![A], elems);\n \n         e1.insert(C);\n         let elems: ::vec::Vec<_> = e1.iter().collect();\n-        assert_eq!(vec![A,C], elems)\n+        assert_eq!(vec![A,C], elems);\n \n         e1.insert(C);\n         let elems: ::vec::Vec<_> = e1.iter().collect();\n-        assert_eq!(vec![A,C], elems)\n+        assert_eq!(vec![A,C], elems);\n \n         e1.insert(B);\n         let elems: ::vec::Vec<_> = e1.iter().collect();\n-        assert_eq!(vec![A,B,C], elems)\n+        assert_eq!(vec![A,B,C], elems);\n     }\n \n     ///////////////////////////////////////////////////////////////////////////\n@@ -472,35 +472,35 @@ mod test {\n \n         let e_union = e1 | e2;\n         let elems: ::vec::Vec<_> = e_union.iter().collect();\n-        assert_eq!(vec![A,B,C], elems)\n+        assert_eq!(vec![A,B,C], elems);\n \n         let e_intersection = e1 & e2;\n         let elems: ::vec::Vec<_> = e_intersection.iter().collect();\n-        assert_eq!(vec![C], elems)\n+        assert_eq!(vec![C], elems);\n \n         // Another way to express intersection\n         let e_intersection = e1 - (e1 - e2);\n         let elems: ::vec::Vec<_> = e_intersection.iter().collect();\n-        assert_eq!(vec![C], elems)\n+        assert_eq!(vec![C], elems);\n \n         let e_subtract = e1 - e2;\n         let elems: ::vec::Vec<_> = e_subtract.iter().collect();\n-        assert_eq!(vec![A], elems)\n+        assert_eq!(vec![A], elems);\n \n         // Bitwise XOR of two sets, aka symmetric difference\n         let e_symmetric_diff = e1 ^ e2;\n         let elems: ::vec::Vec<_> = e_symmetric_diff.iter().collect();\n-        assert_eq!(vec![A,B], elems)\n+        assert_eq!(vec![A,B], elems);\n \n         // Another way to express symmetric difference\n         let e_symmetric_diff = (e1 - e2) | (e2 - e1);\n         let elems: ::vec::Vec<_> = e_symmetric_diff.iter().collect();\n-        assert_eq!(vec![A,B], elems)\n+        assert_eq!(vec![A,B], elems);\n \n         // Yet another way to express symmetric difference\n         let e_symmetric_diff = (e1 | e2) - (e1 & e2);\n         let elems: ::vec::Vec<_> = e_symmetric_diff.iter().collect();\n-        assert_eq!(vec![A,B], elems)\n+        assert_eq!(vec![A,B], elems);\n     }\n \n     #[test]"}, {"sha": "ce4b1e467739e05498036d7b5c070e03a729dadf", "filename": "src/libcollections/macros.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibcollections%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibcollections%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fmacros.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -11,12 +11,13 @@\n #![macro_escape]\n \n /// Creates a `std::vec::Vec` containing the arguments.\n-macro_rules! vec(\n+macro_rules! vec {\n     ($($e:expr),*) => ({\n         // leading _ to allow empty construction without a warning.\n         let mut _temp = ::vec::Vec::new();\n         $(_temp.push($e);)*\n         _temp\n     });\n     ($($e:expr),+,) => (vec!($($e),+))\n-)\n+}\n+"}, {"sha": "bba00a80f6854498f3c22b03c3aaeb3b28094e4a", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -2515,7 +2515,7 @@ mod tests {\n                 assert_eq!(format!(\"{}\", x), x_str);\n                 assert_eq!(format!(\"{}\", x.as_slice()), x_str);\n             })\n-        )\n+        );\n         let empty: Vec<int> = vec![];\n         test_show_vec!(empty, \"[]\");\n         test_show_vec!(vec![1i], \"[1]\");"}, {"sha": "9ac5f04efe5f28759e9e1a905f56dfb30ecaa823", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -415,14 +415,14 @@ Section: Misc\n // Return the initial codepoint accumulator for the first byte.\n // The first byte is special, only want bottom 5 bits for width 2, 4 bits\n // for width 3, and 3 bits for width 4\n-macro_rules! utf8_first_byte(\n+macro_rules! utf8_first_byte {\n     ($byte:expr, $width:expr) => (($byte & (0x7F >> $width)) as u32)\n-)\n+}\n \n // return the value of $ch updated with continuation byte $byte\n-macro_rules! utf8_acc_cont_byte(\n+macro_rules! utf8_acc_cont_byte {\n     ($ch:expr, $byte:expr) => (($ch << 6) | ($byte & 63u8) as u32)\n-)\n+}\n \n /*\n Section: MaybeOwned"}, {"sha": "38ebd686ddbdd3ee579fd96aa27db22d3e36a90b", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -167,7 +167,7 @@ impl String {\n                     subseqidx = i;\n                     res.as_mut_vec().push_all(REPLACEMENT);\n                 }\n-            }))\n+            }));\n \n             if byte < 128u8 {\n                 // subseqidx handles this\n@@ -788,8 +788,8 @@ macro_rules! impl_eq {\n     }\n }\n \n-impl_eq!(String, &'a str)\n-impl_eq!(CowString<'a>, String)\n+impl_eq! { String, &'a str }\n+impl_eq! { CowString<'a>, String }\n \n impl<'a, 'b> PartialEq<&'b str> for CowString<'a> {\n     #[inline]"}, {"sha": "cc667285d29f37e6efbbe3f10681af3bed1b61fc", "filename": "src/libcollections/tree/map.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibcollections%2Ftree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibcollections%2Ftree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftree%2Fmap.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -900,7 +900,7 @@ macro_rules! define_iterator {\n      ) => {\n         // private methods on the forward iterator (item!() for the\n         // addr_mut in the next_ return value)\n-        item!(impl<'a, K, V> $name<'a, K, V> {\n+        item! { impl<'a, K, V> $name<'a, K, V> {\n             #[inline(always)]\n             fn next_(&mut self, forward: bool) -> Option<(&'a K, &'a $($addr_mut)* V)> {\n                 while !self.stack.is_empty() || !self.node.is_null() {\n@@ -968,10 +968,10 @@ macro_rules! define_iterator {\n                     self.node = ptr::RawPtr::null();\n                 }\n             }\n-        })\n+        } }\n \n         // the forward Iterator impl.\n-        item!(impl<'a, K, V> Iterator<(&'a K, &'a $($addr_mut)* V)> for $name<'a, K, V> {\n+        item! { impl<'a, K, V> Iterator<(&'a K, &'a $($addr_mut)* V)> for $name<'a, K, V> {\n             /// Advances the iterator to the next node (in order) and return a\n             /// tuple with a reference to the key and value. If there are no\n             /// more nodes, return `None`.\n@@ -983,10 +983,10 @@ macro_rules! define_iterator {\n             fn size_hint(&self) -> (uint, Option<uint>) {\n                 (self.remaining_min, Some(self.remaining_max))\n             }\n-        })\n+        } }\n \n         // the reverse Iterator impl.\n-        item!(impl<'a, K, V> Iterator<(&'a K, &'a $($addr_mut)* V)> for $rev_name<'a, K, V> {\n+        item! { impl<'a, K, V> Iterator<(&'a K, &'a $($addr_mut)* V)> for $rev_name<'a, K, V> {\n             fn next(&mut self) -> Option<(&'a K, &'a $($addr_mut)* V)> {\n                 self.iter.next_(false)\n             }\n@@ -995,7 +995,7 @@ macro_rules! define_iterator {\n             fn size_hint(&self) -> (uint, Option<uint>) {\n                 self.iter.size_hint()\n             }\n-        })\n+        } }\n     }\n } // end of define_iterator\n "}, {"sha": "9a9ac6a3c582996560e4efc028c7b2a7c0211d80", "filename": "src/libcollections/trie/map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibcollections%2Ftrie%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibcollections%2Ftrie%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftrie%2Fmap.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -1141,7 +1141,7 @@ macro_rules! iterator_impl {\n             }\n         }\n \n-        item!(impl<'a, T> Iterator<(uint, &'a $($mut_)* T)> for $name<'a, T> {\n+        item! { impl<'a, T> Iterator<(uint, &'a $($mut_)* T)> for $name<'a, T> {\n                 // you might wonder why we're not even trying to act within the\n                 // rules, and are just manipulating raw pointers like there's no\n                 // such thing as invalid pointers and memory unsafety. The\n@@ -1213,7 +1213,7 @@ macro_rules! iterator_impl {\n                 fn size_hint(&self) -> (uint, Option<uint>) {\n                     (self.remaining_min, Some(self.remaining_max))\n                 }\n-            })\n+            } }\n     }\n }\n "}, {"sha": "94e6103f05f980c5c3cdd9b73f6a3a2e56e3f1b3", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -582,8 +582,8 @@ macro_rules! impl_eq {\n     }\n }\n \n-impl_eq!(Vec<A>, &'b [B])\n-impl_eq!(Vec<A>, &'b mut [B])\n+impl_eq! { Vec<A>, &'b [B] }\n+impl_eq! { Vec<A>, &'b mut [B] }\n \n impl<'a, A, B> PartialEq<Vec<B>> for CowVec<'a, A> where A: PartialEq<B> + Clone {\n     #[inline]\n@@ -617,8 +617,8 @@ macro_rules! impl_eq_for_cowvec {\n     }\n }\n \n-impl_eq_for_cowvec!(&'b [B])\n-impl_eq_for_cowvec!(&'b mut [B])\n+impl_eq_for_cowvec! { &'b [B] }\n+impl_eq_for_cowvec! { &'b mut [B] }\n \n #[unstable = \"waiting on PartialOrd stability\"]\n impl<T: PartialOrd> PartialOrd for Vec<T> {\n@@ -2065,7 +2065,7 @@ mod tests {\n \n     #[test]\n     fn test_partitioned() {\n-        assert_eq!(vec![].partitioned(|x: &int| *x < 3), (vec![], vec![]))\n+        assert_eq!(vec![].partitioned(|x: &int| *x < 3), (vec![], vec![]));\n         assert_eq!(vec![1i, 2, 3].partitioned(|x: &int| *x < 4), (vec![1, 2, 3], vec![]));\n         assert_eq!(vec![1i, 2, 3].partitioned(|x: &int| *x < 2), (vec![1], vec![2, 3]));\n         assert_eq!(vec![1i, 2, 3].partitioned(|x: &int| *x < 0), (vec![], vec![1, 2, 3]));"}, {"sha": "8faa9c1c522db18f1f9fc1a68a906afe99e2f16c", "filename": "src/libcollections/vec_map.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibcollections%2Fvec_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibcollections%2Fvec_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_map.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -612,8 +612,8 @@ pub struct Entries<'a, V:'a> {\n     iter: slice::Items<'a, Option<V>>\n }\n \n-iterator!(impl Entries -> (uint, &'a V), as_ref)\n-double_ended_iterator!(impl Entries -> (uint, &'a V), as_ref)\n+iterator! { impl Entries -> (uint, &'a V), as_ref }\n+double_ended_iterator! { impl Entries -> (uint, &'a V), as_ref }\n \n /// An iterator over the key-value pairs of a map, with the\n /// values being mutable.\n@@ -623,8 +623,8 @@ pub struct MutEntries<'a, V:'a> {\n     iter: slice::MutItems<'a, Option<V>>\n }\n \n-iterator!(impl MutEntries -> (uint, &'a mut V), as_mut)\n-double_ended_iterator!(impl MutEntries -> (uint, &'a mut V), as_mut)\n+iterator! { impl MutEntries -> (uint, &'a mut V), as_mut }\n+double_ended_iterator! { impl MutEntries -> (uint, &'a mut V), as_mut }\n \n /// An iterator over the keys of a map.\n pub struct Keys<'a, V: 'a> {"}, {"sha": "f6be422813ac592ba0e5be56939a8beac7cf8c79", "filename": "src/libcore/clone.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibcore%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibcore%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fclone.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -46,36 +46,36 @@ impl<'a, Sized? T> Clone for &'a T {\n     fn clone(&self) -> &'a T { *self }\n }\n \n-macro_rules! clone_impl(\n+macro_rules! clone_impl {\n     ($t:ty) => {\n         impl Clone for $t {\n             /// Return a deep copy of the value.\n             #[inline]\n             fn clone(&self) -> $t { *self }\n         }\n     }\n-)\n+}\n \n-clone_impl!(int)\n-clone_impl!(i8)\n-clone_impl!(i16)\n-clone_impl!(i32)\n-clone_impl!(i64)\n+clone_impl! { int }\n+clone_impl! { i8 }\n+clone_impl! { i16 }\n+clone_impl! { i32 }\n+clone_impl! { i64 }\n \n-clone_impl!(uint)\n-clone_impl!(u8)\n-clone_impl!(u16)\n-clone_impl!(u32)\n-clone_impl!(u64)\n+clone_impl! { uint }\n+clone_impl! { u8 }\n+clone_impl! { u16 }\n+clone_impl! { u32 }\n+clone_impl! { u64 }\n \n-clone_impl!(f32)\n-clone_impl!(f64)\n+clone_impl! { f32 }\n+clone_impl! { f64 }\n \n-clone_impl!(())\n-clone_impl!(bool)\n-clone_impl!(char)\n+clone_impl! { () }\n+clone_impl! { bool }\n+clone_impl! { char }\n \n-macro_rules! extern_fn_clone(\n+macro_rules! extern_fn_clone {\n     ($($A:ident),*) => (\n         #[experimental = \"this may not be sufficient for fns with region parameters\"]\n         impl<$($A,)* ReturnType> Clone for extern \"Rust\" fn($($A),*) -> ReturnType {\n@@ -84,15 +84,15 @@ macro_rules! extern_fn_clone(\n             fn clone(&self) -> extern \"Rust\" fn($($A),*) -> ReturnType { *self }\n         }\n     )\n-)\n+}\n \n-extern_fn_clone!()\n-extern_fn_clone!(A)\n-extern_fn_clone!(A, B)\n-extern_fn_clone!(A, B, C)\n-extern_fn_clone!(A, B, C, D)\n-extern_fn_clone!(A, B, C, D, E)\n-extern_fn_clone!(A, B, C, D, E, F)\n-extern_fn_clone!(A, B, C, D, E, F, G)\n-extern_fn_clone!(A, B, C, D, E, F, G, H)\n+extern_fn_clone! {}\n+extern_fn_clone! { A }\n+extern_fn_clone! { A, B }\n+extern_fn_clone! { A, B, C }\n+extern_fn_clone! { A, B, C, D }\n+extern_fn_clone! { A, B, C, D, E }\n+extern_fn_clone! { A, B, C, D, E, F }\n+extern_fn_clone! { A, B, C, D, E, F, G }\n+extern_fn_clone! { A, B, C, D, E, F, G, H }\n "}, {"sha": "af82e6a00f39b4f9dfc702ec5ca4f2ef3f3a0b31", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -296,7 +296,7 @@ mod impls {\n     use option::Option;\n     use option::Option::{Some, None};\n \n-    macro_rules! partial_eq_impl(\n+    macro_rules! partial_eq_impl {\n         ($($t:ty)*) => ($(\n             #[unstable = \"Trait is unstable.\"]\n             impl PartialEq for $t {\n@@ -306,7 +306,7 @@ mod impls {\n                 fn ne(&self, other: &$t) -> bool { (*self) != (*other) }\n             }\n         )*)\n-    )\n+    }\n \n     #[unstable = \"Trait is unstable.\"]\n     impl PartialEq for () {\n@@ -316,18 +316,20 @@ mod impls {\n         fn ne(&self, _other: &()) -> bool { false }\n     }\n \n-    partial_eq_impl!(bool char uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64)\n+    partial_eq_impl! {\n+        bool char uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64\n+    }\n \n-    macro_rules! eq_impl(\n+    macro_rules! eq_impl {\n         ($($t:ty)*) => ($(\n             #[unstable = \"Trait is unstable.\"]\n             impl Eq for $t {}\n         )*)\n-    )\n+    }\n \n-    eq_impl!(() bool char uint u8 u16 u32 u64 int i8 i16 i32 i64)\n+    eq_impl! { () bool char uint u8 u16 u32 u64 int i8 i16 i32 i64 }\n \n-    macro_rules! partial_ord_impl(\n+    macro_rules! partial_ord_impl {\n         ($($t:ty)*) => ($(\n             #[unstable = \"Trait is unstable.\"]\n             impl PartialOrd for $t {\n@@ -350,7 +352,7 @@ mod impls {\n                 fn gt(&self, other: &$t) -> bool { (*self) > (*other) }\n             }\n         )*)\n-    )\n+    }\n \n     #[unstable = \"Trait is unstable.\"]\n     impl PartialOrd for () {\n@@ -368,9 +370,9 @@ mod impls {\n         }\n     }\n \n-    partial_ord_impl!(char uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64)\n+    partial_ord_impl! { char uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64 }\n \n-    macro_rules! ord_impl(\n+    macro_rules! ord_impl {\n         ($($t:ty)*) => ($(\n             #[unstable = \"Trait is unstable.\"]\n             impl Ord for $t {\n@@ -382,7 +384,7 @@ mod impls {\n                 }\n             }\n         )*)\n-    )\n+    }\n \n     #[unstable = \"Trait is unstable.\"]\n     impl Ord for () {\n@@ -398,7 +400,7 @@ mod impls {\n         }\n     }\n \n-    ord_impl!(char uint u8 u16 u32 u64 int i8 i16 i32 i64)\n+    ord_impl! { char uint u8 u16 u32 u64 int i8 i16 i32 i64 }\n \n     // & pointers\n "}, {"sha": "0632ffd9c698cc6ca9357dad52231941d5041d25", "filename": "src/libcore/default.rs", "status": "modified", "additions": 18, "deletions": 17, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibcore%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibcore%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdefault.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -135,7 +135,7 @@ pub trait Default {\n     fn default() -> Self;\n }\n \n-macro_rules! default_impl(\n+macro_rules! default_impl {\n     ($t:ty, $v:expr) => {\n         #[stable]\n         impl Default for $t {\n@@ -144,23 +144,24 @@ macro_rules! default_impl(\n             fn default() -> $t { $v }\n         }\n     }\n-)\n+}\n+\n+default_impl! { (), () }\n+default_impl! { bool, false }\n+default_impl! { char, '\\x00' }\n \n-default_impl!((), ())\n-default_impl!(bool, false)\n-default_impl!(char, '\\x00')\n+default_impl! { uint, 0u }\n+default_impl! { u8,  0u8 }\n+default_impl! { u16, 0u16 }\n+default_impl! { u32, 0u32 }\n+default_impl! { u64, 0u64 }\n \n-default_impl!(uint, 0u)\n-default_impl!(u8,  0u8)\n-default_impl!(u16, 0u16)\n-default_impl!(u32, 0u32)\n-default_impl!(u64, 0u64)\n+default_impl! { int, 0i }\n+default_impl! { i8,  0i8 }\n+default_impl! { i16, 0i16 }\n+default_impl! { i32, 0i32 }\n+default_impl! { i64, 0i64 }\n \n-default_impl!(int, 0i)\n-default_impl!(i8,  0i8)\n-default_impl!(i16, 0i16)\n-default_impl!(i32, 0i32)\n-default_impl!(i64, 0i64)\n+default_impl! { f32, 0.0f32 }\n+default_impl! { f64, 0.0f64 }\n \n-default_impl!(f32, 0.0f32)\n-default_impl!(f64, 0.0f64)"}, {"sha": "cc940cd9e20a5c06e1d7977cd8cd5d2347fe2363", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -639,7 +639,7 @@ impl<'a, T> Pointer for &'a mut T {\n     }\n }\n \n-macro_rules! floating(($ty:ident) => {\n+macro_rules! floating { ($ty:ident) => {\n     impl Show for $ty {\n         fn fmt(&self, fmt: &mut Formatter) -> Result {\n             use num::Float;\n@@ -702,9 +702,9 @@ macro_rules! floating(($ty:ident) => {\n             })\n         }\n     }\n-})\n-floating!(f32)\n-floating!(f64)\n+} }\n+floating! { f32 }\n+floating! { f64 }\n \n // Implementation of Show for various core types\n \n@@ -716,9 +716,11 @@ impl<T> Show for *mut T {\n     fn fmt(&self, f: &mut Formatter) -> Result { Pointer::fmt(self, f) }\n }\n \n-macro_rules! peel(($name:ident, $($other:ident,)*) => (tuple!($($other,)*)))\n+macro_rules! peel {\n+    ($name:ident, $($other:ident,)*) => (tuple! { $($other,)* })\n+}\n \n-macro_rules! tuple (\n+macro_rules! tuple {\n     () => ();\n     ( $($name:ident,)+ ) => (\n         impl<$($name:Show),*> Show for ($($name,)*) {\n@@ -740,9 +742,9 @@ macro_rules! tuple (\n                 write!(f, \")\")\n             }\n         }\n-        peel!($($name,)*)\n+        peel! { $($name,)* }\n     )\n-)\n+}\n \n tuple! { T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, }\n "}, {"sha": "13cfcacf8dab9ec94af56b3c37048724c10b8f9e", "filename": "src/libcore/fmt/num.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibcore%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibcore%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fnum.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -100,13 +100,13 @@ macro_rules! radix {\n     }\n }\n \n-radix!(Binary,    2, \"0b\", x @  0 ...  2 => b'0' + x)\n-radix!(Octal,     8, \"0o\", x @  0 ...  7 => b'0' + x)\n-radix!(Decimal,  10, \"\",   x @  0 ...  9 => b'0' + x)\n-radix!(LowerHex, 16, \"0x\", x @  0 ...  9 => b'0' + x,\n-                           x @ 10 ... 15 => b'a' + (x - 10))\n-radix!(UpperHex, 16, \"0x\", x @  0 ...  9 => b'0' + x,\n-                           x @ 10 ... 15 => b'A' + (x - 10))\n+radix! { Binary,    2, \"0b\", x @  0 ...  2 => b'0' + x }\n+radix! { Octal,     8, \"0o\", x @  0 ...  7 => b'0' + x }\n+radix! { Decimal,  10, \"\",   x @  0 ...  9 => b'0' + x }\n+radix! { LowerHex, 16, \"0x\", x @  0 ...  9 => b'0' + x,\n+                             x @ 10 ... 15 => b'a' + (x - 10) }\n+radix! { UpperHex, 16, \"0x\", x @  0 ...  9 => b'0' + x,\n+                             x @ 10 ... 15 => b'A' + (x - 10) }\n \n /// A radix with in the range of `2..36`.\n #[deriving(Clone, PartialEq)]\n@@ -174,23 +174,23 @@ macro_rules! int_base {\n }\n macro_rules! integer {\n     ($Int:ident, $Uint:ident) => {\n-        int_base!(Show     for $Int as $Int   -> Decimal)\n-        int_base!(Binary   for $Int as $Uint  -> Binary)\n-        int_base!(Octal    for $Int as $Uint  -> Octal)\n-        int_base!(LowerHex for $Int as $Uint  -> LowerHex)\n-        int_base!(UpperHex for $Int as $Uint  -> UpperHex)\n-        radix_fmt!($Int as $Int, fmt_int)\n-\n-        int_base!(Show     for $Uint as $Uint -> Decimal)\n-        int_base!(Binary   for $Uint as $Uint -> Binary)\n-        int_base!(Octal    for $Uint as $Uint -> Octal)\n-        int_base!(LowerHex for $Uint as $Uint -> LowerHex)\n-        int_base!(UpperHex for $Uint as $Uint -> UpperHex)\n-        radix_fmt!($Uint as $Uint, fmt_int)\n+        int_base! { Show     for $Int as $Int   -> Decimal }\n+        int_base! { Binary   for $Int as $Uint  -> Binary }\n+        int_base! { Octal    for $Int as $Uint  -> Octal }\n+        int_base! { LowerHex for $Int as $Uint  -> LowerHex }\n+        int_base! { UpperHex for $Int as $Uint  -> UpperHex }\n+        radix_fmt! { $Int as $Int, fmt_int }\n+\n+        int_base! { Show     for $Uint as $Uint -> Decimal }\n+        int_base! { Binary   for $Uint as $Uint -> Binary }\n+        int_base! { Octal    for $Uint as $Uint -> Octal }\n+        int_base! { LowerHex for $Uint as $Uint -> LowerHex }\n+        int_base! { UpperHex for $Uint as $Uint -> UpperHex }\n+        radix_fmt! { $Uint as $Uint, fmt_int }\n     }\n }\n-integer!(int, uint)\n-integer!(i8, u8)\n-integer!(i16, u16)\n-integer!(i32, u32)\n-integer!(i64, u64)\n+integer! { int, uint }\n+integer! { i8, u8 }\n+integer! { i16, u16 }\n+integer! { i32, u32 }\n+integer! { i64, u64 }"}, {"sha": "c1aa605a4558b05e15fe0b244703c4d6b38011b0", "filename": "src/libcore/hash/mod.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibcore%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibcore%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fmod.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -109,16 +109,16 @@ macro_rules! impl_hash {\n     }\n }\n \n-impl_hash!(u8, u8)\n-impl_hash!(u16, u16)\n-impl_hash!(u32, u32)\n-impl_hash!(u64, u64)\n-impl_hash!(uint, uint)\n-impl_hash!(i8, u8)\n-impl_hash!(i16, u16)\n-impl_hash!(i32, u32)\n-impl_hash!(i64, u64)\n-impl_hash!(int, uint)\n+impl_hash! { u8, u8 }\n+impl_hash! { u16, u16 }\n+impl_hash! { u32, u32 }\n+impl_hash! { u64, u64 }\n+impl_hash! { uint, uint }\n+impl_hash! { i8, u8 }\n+impl_hash! { i16, u16 }\n+impl_hash! { i32, u32 }\n+impl_hash! { i64, u64 }\n+impl_hash! { int, uint }\n \n impl<S: Writer> Hash<S> for bool {\n     #[inline]\n@@ -142,7 +142,7 @@ impl<S: Writer> Hash<S> for str {\n     }\n }\n \n-macro_rules! impl_hash_tuple(\n+macro_rules! impl_hash_tuple {\n     () => (\n         impl<S: Writer> Hash<S> for () {\n             #[inline]\n@@ -167,21 +167,21 @@ macro_rules! impl_hash_tuple(\n             }\n         }\n     );\n-)\n-\n-impl_hash_tuple!()\n-impl_hash_tuple!(A)\n-impl_hash_tuple!(A B)\n-impl_hash_tuple!(A B C)\n-impl_hash_tuple!(A B C D)\n-impl_hash_tuple!(A B C D E)\n-impl_hash_tuple!(A B C D E F)\n-impl_hash_tuple!(A B C D E F G)\n-impl_hash_tuple!(A B C D E F G H)\n-impl_hash_tuple!(A B C D E F G H I)\n-impl_hash_tuple!(A B C D E F G H I J)\n-impl_hash_tuple!(A B C D E F G H I J K)\n-impl_hash_tuple!(A B C D E F G H I J K L)\n+}\n+\n+impl_hash_tuple! {}\n+impl_hash_tuple! { A }\n+impl_hash_tuple! { A B }\n+impl_hash_tuple! { A B C }\n+impl_hash_tuple! { A B C D }\n+impl_hash_tuple! { A B C D E }\n+impl_hash_tuple! { A B C D E F }\n+impl_hash_tuple! { A B C D E F G }\n+impl_hash_tuple! { A B C D E F G H }\n+impl_hash_tuple! { A B C D E F G H I }\n+impl_hash_tuple! { A B C D E F G H I J }\n+impl_hash_tuple! { A B C D E F G H I J K }\n+impl_hash_tuple! { A B C D E F G H I J K L }\n \n impl<S: Writer, T: Hash<S>> Hash<S> for [T] {\n     #[inline]"}, {"sha": "15f6768edce5bd78da3b0982a0b41925b716c546", "filename": "src/libcore/hash/sip.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibcore%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibcore%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fsip.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -48,7 +48,7 @@ impl Copy for SipState {}\n // because they're needed in the following defs;\n // this design could be improved.\n \n-macro_rules! u8to64_le (\n+macro_rules! u8to64_le {\n     ($buf:expr, $i:expr) =>\n     ($buf[0+$i] as u64 |\n      $buf[1+$i] as u64 << 8 |\n@@ -68,14 +68,14 @@ macro_rules! u8to64_le (\n         }\n         out\n     });\n-)\n+}\n \n-macro_rules! rotl (\n+macro_rules! rotl {\n     ($x:expr, $b:expr) =>\n     (($x << $b) | ($x >> (64 - $b)))\n-)\n+}\n \n-macro_rules! compress (\n+macro_rules! compress {\n     ($v0:expr, $v1:expr, $v2:expr, $v3:expr) =>\n     ({\n         $v0 += $v1; $v1 = rotl!($v1, 13); $v1 ^= $v0;\n@@ -85,7 +85,7 @@ macro_rules! compress (\n         $v2 += $v1; $v1 = rotl!($v1, 17); $v1 ^= $v2;\n         $v2 = rotl!($v2, 32);\n     })\n-)\n+}\n \n impl SipState {\n     /// Creates a `SipState` that is keyed off the provided keys."}, {"sha": "de5c0defb1ac2b76413b164602355bdfb75d6973", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -875,18 +875,18 @@ macro_rules! impl_additive {\n         }\n     };\n }\n-impl_additive!(i8,   0)\n-impl_additive!(i16,  0)\n-impl_additive!(i32,  0)\n-impl_additive!(i64,  0)\n-impl_additive!(int,  0)\n-impl_additive!(u8,   0)\n-impl_additive!(u16,  0)\n-impl_additive!(u32,  0)\n-impl_additive!(u64,  0)\n-impl_additive!(uint, 0)\n-impl_additive!(f32,  0.0)\n-impl_additive!(f64,  0.0)\n+impl_additive! { i8,   0 }\n+impl_additive! { i16,  0 }\n+impl_additive! { i32,  0 }\n+impl_additive! { i64,  0 }\n+impl_additive! { int,  0 }\n+impl_additive! { u8,   0 }\n+impl_additive! { u16,  0 }\n+impl_additive! { u32,  0 }\n+impl_additive! { u64,  0 }\n+impl_additive! { uint, 0 }\n+impl_additive! { f32,  0.0 }\n+impl_additive! { f64,  0.0 }\n \n /// A trait for iterators over elements which can be multiplied together.\n #[experimental = \"needs to be re-evaluated as part of numerics reform\"]\n@@ -919,18 +919,18 @@ macro_rules! impl_multiplicative {\n         }\n     };\n }\n-impl_multiplicative!(i8,   1)\n-impl_multiplicative!(i16,  1)\n-impl_multiplicative!(i32,  1)\n-impl_multiplicative!(i64,  1)\n-impl_multiplicative!(int,  1)\n-impl_multiplicative!(u8,   1)\n-impl_multiplicative!(u16,  1)\n-impl_multiplicative!(u32,  1)\n-impl_multiplicative!(u64,  1)\n-impl_multiplicative!(uint, 1)\n-impl_multiplicative!(f32,  1.0)\n-impl_multiplicative!(f64,  1.0)\n+impl_multiplicative! { i8,   1 }\n+impl_multiplicative! { i16,  1 }\n+impl_multiplicative! { i32,  1 }\n+impl_multiplicative! { i64,  1 }\n+impl_multiplicative! { int,  1 }\n+impl_multiplicative! { u8,   1 }\n+impl_multiplicative! { u16,  1 }\n+impl_multiplicative! { u32,  1 }\n+impl_multiplicative! { u64,  1 }\n+impl_multiplicative! { uint, 1 }\n+impl_multiplicative! { f32,  1.0 }\n+impl_multiplicative! { f64,  1.0 }\n \n /// A trait for iterators over elements which can be compared to one another.\n #[unstable = \"recently renamed for new extension trait conventions\"]\n@@ -1084,7 +1084,7 @@ impl<T: Clone> MinMaxResult<T> {\n     /// use std::iter::{NoElements, OneElement, MinMax, MinMaxResult};\n     ///\n     /// let r: MinMaxResult<int> = NoElements;\n-    /// assert_eq!(r.into_option(), None)\n+    /// assert_eq!(r.into_option(), None);\n     ///\n     /// let r = OneElement(1i);\n     /// assert_eq!(r.into_option(), Some((1,1)));"}, {"sha": "7ce1da7d2d0f27aefdadade836ae38e5f506d28c", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 20, "deletions": 19, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -12,7 +12,7 @@\n \n /// Entry point of task panic, for details, see std::macros\n #[macro_export]\n-macro_rules! panic(\n+macro_rules! panic {\n     () => (\n         panic!(\"{}\", \"explicit panic\")\n     );\n@@ -44,11 +44,11 @@ macro_rules! panic(\n         }\n         format_args!(_run_fmt, $fmt, $($arg)*)\n     });\n-)\n+}\n \n /// Runtime assertion, for details see std::macros\n #[macro_export]\n-macro_rules! assert(\n+macro_rules! assert {\n     ($cond:expr) => (\n         if !$cond {\n             panic!(concat!(\"assertion failed: \", stringify!($cond)))\n@@ -59,68 +59,69 @@ macro_rules! assert(\n             panic!($($arg)*)\n         }\n     );\n-)\n+}\n \n /// Runtime assertion, only without `--cfg ndebug`\n #[macro_export]\n-macro_rules! debug_assert(\n+macro_rules! debug_assert {\n     ($(a:tt)*) => ({\n         if cfg!(not(ndebug)) {\n             assert!($($a)*);\n         }\n     })\n-)\n+}\n \n /// Runtime assertion for equality, for details see std::macros\n #[macro_export]\n-macro_rules! assert_eq(\n+macro_rules! assert_eq {\n     ($cond1:expr, $cond2:expr) => ({\n         let c1 = $cond1;\n         let c2 = $cond2;\n         if c1 != c2 || c2 != c1 {\n             panic!(\"expressions not equal, left: {}, right: {}\", c1, c2);\n         }\n     })\n-)\n+}\n \n /// Runtime assertion for equality, only without `--cfg ndebug`\n #[macro_export]\n-macro_rules! debug_assert_eq(\n+macro_rules! debug_assert_eq {\n     ($($a:tt)*) => ({\n         if cfg!(not(ndebug)) {\n             assert_eq!($($a)*);\n         }\n     })\n-)\n+}\n \n /// Runtime assertion, disableable at compile time\n #[macro_export]\n-macro_rules! debug_assert(\n+macro_rules! debug_assert {\n     ($($arg:tt)*) => (if cfg!(not(ndebug)) { assert!($($arg)*); })\n-)\n+}\n \n /// Short circuiting evaluation on Err\n #[macro_export]\n-macro_rules! try(\n+macro_rules! try {\n     ($e:expr) => (match $e { Ok(e) => e, Err(e) => return Err(e) })\n-)\n+}\n \n /// Writing a formatted string into a writer\n #[macro_export]\n-macro_rules! write(\n+macro_rules! write {\n     ($dst:expr, $($arg:tt)*) => ({\n         let dst = &mut *$dst;\n         format_args!(|args| { dst.write_fmt(args) }, $($arg)*)\n     })\n-)\n+}\n \n /// Writing a formatted string plus a newline into a writer\n #[macro_export]\n-macro_rules! writeln(\n+macro_rules! writeln {\n     ($dst:expr, $fmt:expr $($arg:tt)*) => (\n         write!($dst, concat!($fmt, \"\\n\") $($arg)*)\n     )\n-)\n+}\n \n #[macro_export]\n-macro_rules! unreachable( () => (panic!(\"unreachable code\")) )\n+macro_rules! unreachable { () => (panic!(\"unreachable code\")) }\n+"}, {"sha": "97de61d7e272eebb0becea999c7f39770bda8a96", "filename": "src/libcore/num/float_macros.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibcore%2Fnum%2Ffloat_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibcore%2Fnum%2Ffloat_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ffloat_macros.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -11,11 +11,12 @@\n #![macro_escape]\n #![doc(hidden)]\n \n-macro_rules! assert_approx_eq(\n+macro_rules! assert_approx_eq {\n     ($a:expr, $b:expr) => ({\n         use num::Float;\n         let (a, b) = (&$a, &$b);\n         assert!((*a - *b).abs() < 1.0e-6,\n                 \"{} is not approximately equal to {}\", *a, *b);\n     })\n-)\n+}\n+"}, {"sha": "eb2a4c3835d5a2c7c259b88d6f13ce893f922ee3", "filename": "src/libcore/num/i16.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibcore%2Fnum%2Fi16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibcore%2Fnum%2Fi16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fi16.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -13,4 +13,4 @@\n #![stable]\n #![doc(primitive = \"i16\")]\n \n-int_module!(i16, 16)\n+int_module! { i16, 16 }"}, {"sha": "849fa205756bb048ae65622a1ad349601690586c", "filename": "src/libcore/num/i32.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibcore%2Fnum%2Fi32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibcore%2Fnum%2Fi32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fi32.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -13,4 +13,4 @@\n #![stable]\n #![doc(primitive = \"i32\")]\n \n-int_module!(i32, 32)\n+int_module! { i32, 32 }"}, {"sha": "b6cba728e447f635de7626fb1b722983d3fb54ad", "filename": "src/libcore/num/i64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibcore%2Fnum%2Fi64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibcore%2Fnum%2Fi64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fi64.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -13,4 +13,4 @@\n #![stable]\n #![doc(primitive = \"i64\")]\n \n-int_module!(i64, 64)\n+int_module! { i64, 64 }"}, {"sha": "fd0759898ea2d0c74bfee6f3c9c4d2073bdc2c7f", "filename": "src/libcore/num/i8.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibcore%2Fnum%2Fi8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibcore%2Fnum%2Fi8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fi8.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -13,4 +13,4 @@\n #![stable]\n #![doc(primitive = \"i8\")]\n \n-int_module!(i8, 8)\n+int_module! { i8, 8 }"}, {"sha": "a0659d383076486fd2986cdc54b0c432efd8c266", "filename": "src/libcore/num/int.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibcore%2Fnum%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibcore%2Fnum%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -13,6 +13,6 @@\n #![unstable]\n #![doc(primitive = \"int\")]\n \n-#[cfg(target_word_size = \"32\")] int_module!(int, 32)\n-#[cfg(target_word_size = \"64\")] int_module!(int, 64)\n+#[cfg(target_word_size = \"32\")] int_module! { int, 32 }\n+#[cfg(target_word_size = \"64\")] int_module! { int, 64 }\n "}, {"sha": "00b9d88abe194d0746a730e9b1e4738a0843c578", "filename": "src/libcore/num/int_macros.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibcore%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibcore%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint_macros.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -11,7 +11,7 @@\n #![macro_escape]\n #![doc(hidden)]\n \n-macro_rules! int_module (($T:ty, $bits:expr) => (\n+macro_rules! int_module { ($T:ty, $bits:expr) => (\n \n // FIXME(#11621): Should be deprecated once CTFE is implemented in favour of\n // calling the `mem::size_of` function.\n@@ -32,4 +32,5 @@ pub const MIN: $T = (-1 as $T) << (BITS - 1);\n #[unstable]\n pub const MAX: $T = !MIN;\n \n-))\n+) }\n+"}, {"sha": "fcb2ca93054ce356ae579ea059ebbc41295ebc56", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 138, "deletions": 138, "changes": 276, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -458,61 +458,61 @@ macro_rules! uint_impl {\n /// consistency with the other `bswap` intrinsics.\n unsafe fn bswap8(x: u8) -> u8 { x }\n \n-uint_impl!(u8 = u8, 8,\n+uint_impl! { u8 = u8, 8,\n     intrinsics::ctpop8,\n     intrinsics::ctlz8,\n     intrinsics::cttz8,\n     bswap8,\n     intrinsics::u8_add_with_overflow,\n     intrinsics::u8_sub_with_overflow,\n-    intrinsics::u8_mul_with_overflow)\n+    intrinsics::u8_mul_with_overflow }\n \n-uint_impl!(u16 = u16, 16,\n+uint_impl! { u16 = u16, 16,\n     intrinsics::ctpop16,\n     intrinsics::ctlz16,\n     intrinsics::cttz16,\n     intrinsics::bswap16,\n     intrinsics::u16_add_with_overflow,\n     intrinsics::u16_sub_with_overflow,\n-    intrinsics::u16_mul_with_overflow)\n+    intrinsics::u16_mul_with_overflow }\n \n-uint_impl!(u32 = u32, 32,\n+uint_impl! { u32 = u32, 32,\n     intrinsics::ctpop32,\n     intrinsics::ctlz32,\n     intrinsics::cttz32,\n     intrinsics::bswap32,\n     intrinsics::u32_add_with_overflow,\n     intrinsics::u32_sub_with_overflow,\n-    intrinsics::u32_mul_with_overflow)\n+    intrinsics::u32_mul_with_overflow }\n \n-uint_impl!(u64 = u64, 64,\n+uint_impl! { u64 = u64, 64,\n     intrinsics::ctpop64,\n     intrinsics::ctlz64,\n     intrinsics::cttz64,\n     intrinsics::bswap64,\n     intrinsics::u64_add_with_overflow,\n     intrinsics::u64_sub_with_overflow,\n-    intrinsics::u64_mul_with_overflow)\n+    intrinsics::u64_mul_with_overflow }\n \n #[cfg(target_word_size = \"32\")]\n-uint_impl!(uint = u32, 32,\n+uint_impl! { uint = u32, 32,\n     intrinsics::ctpop32,\n     intrinsics::ctlz32,\n     intrinsics::cttz32,\n     intrinsics::bswap32,\n     intrinsics::u32_add_with_overflow,\n     intrinsics::u32_sub_with_overflow,\n-    intrinsics::u32_mul_with_overflow)\n+    intrinsics::u32_mul_with_overflow }\n \n #[cfg(target_word_size = \"64\")]\n-uint_impl!(uint = u64, 64,\n+uint_impl! { uint = u64, 64,\n     intrinsics::ctpop64,\n     intrinsics::ctlz64,\n     intrinsics::cttz64,\n     intrinsics::bswap64,\n     intrinsics::u64_add_with_overflow,\n     intrinsics::u64_sub_with_overflow,\n-    intrinsics::u64_mul_with_overflow)\n+    intrinsics::u64_mul_with_overflow }\n \n macro_rules! int_impl {\n     ($T:ty = $ActualT:ty, $UnsignedT:ty, $BITS:expr,\n@@ -579,37 +579,37 @@ macro_rules! int_impl {\n     }\n }\n \n-int_impl!(i8 = i8, u8, 8,\n+int_impl! { i8 = i8, u8, 8,\n     intrinsics::i8_add_with_overflow,\n     intrinsics::i8_sub_with_overflow,\n-    intrinsics::i8_mul_with_overflow)\n+    intrinsics::i8_mul_with_overflow }\n \n-int_impl!(i16 = i16, u16, 16,\n+int_impl! { i16 = i16, u16, 16,\n     intrinsics::i16_add_with_overflow,\n     intrinsics::i16_sub_with_overflow,\n-    intrinsics::i16_mul_with_overflow)\n+    intrinsics::i16_mul_with_overflow }\n \n-int_impl!(i32 = i32, u32, 32,\n+int_impl! { i32 = i32, u32, 32,\n     intrinsics::i32_add_with_overflow,\n     intrinsics::i32_sub_with_overflow,\n-    intrinsics::i32_mul_with_overflow)\n+    intrinsics::i32_mul_with_overflow }\n \n-int_impl!(i64 = i64, u64, 64,\n+int_impl! { i64 = i64, u64, 64,\n     intrinsics::i64_add_with_overflow,\n     intrinsics::i64_sub_with_overflow,\n-    intrinsics::i64_mul_with_overflow)\n+    intrinsics::i64_mul_with_overflow }\n \n #[cfg(target_word_size = \"32\")]\n-int_impl!(int = i32, u32, 32,\n+int_impl! { int = i32, u32, 32,\n     intrinsics::i32_add_with_overflow,\n     intrinsics::i32_sub_with_overflow,\n-    intrinsics::i32_mul_with_overflow)\n+    intrinsics::i32_mul_with_overflow }\n \n #[cfg(target_word_size = \"64\")]\n-int_impl!(int = i64, u64, 64,\n+int_impl! { int = i64, u64, 64,\n     intrinsics::i64_add_with_overflow,\n     intrinsics::i64_sub_with_overflow,\n-    intrinsics::i64_mul_with_overflow)\n+    intrinsics::i64_mul_with_overflow }\n \n /// A built-in two's complement integer.\n #[unstable = \"recently settled as part of numerics reform\"]\n@@ -663,11 +663,11 @@ macro_rules! signed_int_impl {\n     }\n }\n \n-signed_int_impl!(i8)\n-signed_int_impl!(i16)\n-signed_int_impl!(i32)\n-signed_int_impl!(i64)\n-signed_int_impl!(int)\n+signed_int_impl! { i8 }\n+signed_int_impl! { i16 }\n+signed_int_impl! { i32 }\n+signed_int_impl! { i64 }\n+signed_int_impl! { int }\n \n /// A built-in unsigned integer.\n #[unstable = \"recently settled as part of numerics reform\"]\n@@ -791,7 +791,7 @@ pub trait ToPrimitive {\n     }\n }\n \n-macro_rules! impl_to_primitive_int_to_int(\n+macro_rules! impl_to_primitive_int_to_int {\n     ($SrcT:ty, $DstT:ty, $slf:expr) => (\n         {\n             if size_of::<$SrcT>() <= size_of::<$DstT>() {\n@@ -808,9 +808,9 @@ macro_rules! impl_to_primitive_int_to_int(\n             }\n         }\n     )\n-)\n+}\n \n-macro_rules! impl_to_primitive_int_to_uint(\n+macro_rules! impl_to_primitive_int_to_uint {\n     ($SrcT:ty, $DstT:ty, $slf:expr) => (\n         {\n             let zero: $SrcT = Int::zero();\n@@ -822,9 +822,9 @@ macro_rules! impl_to_primitive_int_to_uint(\n             }\n         }\n     )\n-)\n+}\n \n-macro_rules! impl_to_primitive_int(\n+macro_rules! impl_to_primitive_int {\n     ($T:ty) => (\n         impl ToPrimitive for $T {\n             #[inline]\n@@ -855,15 +855,15 @@ macro_rules! impl_to_primitive_int(\n             fn to_f64(&self) -> Option<f64> { Some(*self as f64) }\n         }\n     )\n-)\n+}\n \n-impl_to_primitive_int!(int)\n-impl_to_primitive_int!(i8)\n-impl_to_primitive_int!(i16)\n-impl_to_primitive_int!(i32)\n-impl_to_primitive_int!(i64)\n+impl_to_primitive_int! { int }\n+impl_to_primitive_int! { i8 }\n+impl_to_primitive_int! { i16 }\n+impl_to_primitive_int! { i32 }\n+impl_to_primitive_int! { i64 }\n \n-macro_rules! impl_to_primitive_uint_to_int(\n+macro_rules! impl_to_primitive_uint_to_int {\n     ($DstT:ty, $slf:expr) => (\n         {\n             let max_value: $DstT = Int::max_value();\n@@ -874,9 +874,9 @@ macro_rules! impl_to_primitive_uint_to_int(\n             }\n         }\n     )\n-)\n+}\n \n-macro_rules! impl_to_primitive_uint_to_uint(\n+macro_rules! impl_to_primitive_uint_to_uint {\n     ($SrcT:ty, $DstT:ty, $slf:expr) => (\n         {\n             if size_of::<$SrcT>() <= size_of::<$DstT>() {\n@@ -892,9 +892,9 @@ macro_rules! impl_to_primitive_uint_to_uint(\n             }\n         }\n     )\n-)\n+}\n \n-macro_rules! impl_to_primitive_uint(\n+macro_rules! impl_to_primitive_uint {\n     ($T:ty) => (\n         impl ToPrimitive for $T {\n             #[inline]\n@@ -925,15 +925,15 @@ macro_rules! impl_to_primitive_uint(\n             fn to_f64(&self) -> Option<f64> { Some(*self as f64) }\n         }\n     )\n-)\n+}\n \n-impl_to_primitive_uint!(uint)\n-impl_to_primitive_uint!(u8)\n-impl_to_primitive_uint!(u16)\n-impl_to_primitive_uint!(u32)\n-impl_to_primitive_uint!(u64)\n+impl_to_primitive_uint! { uint }\n+impl_to_primitive_uint! { u8 }\n+impl_to_primitive_uint! { u16 }\n+impl_to_primitive_uint! { u32 }\n+impl_to_primitive_uint! { u64 }\n \n-macro_rules! impl_to_primitive_float_to_float(\n+macro_rules! impl_to_primitive_float_to_float {\n     ($SrcT:ty, $DstT:ty, $slf:expr) => (\n         if size_of::<$SrcT>() <= size_of::<$DstT>() {\n             Some($slf as $DstT)\n@@ -947,9 +947,9 @@ macro_rules! impl_to_primitive_float_to_float(\n             }\n         }\n     )\n-)\n+}\n \n-macro_rules! impl_to_primitive_float(\n+macro_rules! impl_to_primitive_float {\n     ($T:ty) => (\n         impl ToPrimitive for $T {\n             #[inline]\n@@ -980,10 +980,10 @@ macro_rules! impl_to_primitive_float(\n             fn to_f64(&self) -> Option<f64> { impl_to_primitive_float_to_float!($T, f64, *self) }\n         }\n     )\n-)\n+}\n \n-impl_to_primitive_float!(f32)\n-impl_to_primitive_float!(f64)\n+impl_to_primitive_float! { f32 }\n+impl_to_primitive_float! { f64 }\n \n /// A generic trait for converting a number to a value.\n #[experimental = \"trait is likely to be removed\"]\n@@ -1139,7 +1139,7 @@ pub fn from_f64<A: FromPrimitive>(n: f64) -> Option<A> {\n     FromPrimitive::from_f64(n)\n }\n \n-macro_rules! impl_from_primitive(\n+macro_rules! impl_from_primitive {\n     ($T:ty, $to_ty:ident) => (\n         impl FromPrimitive for $T {\n             #[inline] fn from_int(n: int) -> Option<$T> { n.$to_ty() }\n@@ -1158,20 +1158,20 @@ macro_rules! impl_from_primitive(\n             #[inline] fn from_f64(n: f64) -> Option<$T> { n.$to_ty() }\n         }\n     )\n-)\n-\n-impl_from_primitive!(int, to_int)\n-impl_from_primitive!(i8, to_i8)\n-impl_from_primitive!(i16, to_i16)\n-impl_from_primitive!(i32, to_i32)\n-impl_from_primitive!(i64, to_i64)\n-impl_from_primitive!(uint, to_uint)\n-impl_from_primitive!(u8, to_u8)\n-impl_from_primitive!(u16, to_u16)\n-impl_from_primitive!(u32, to_u32)\n-impl_from_primitive!(u64, to_u64)\n-impl_from_primitive!(f32, to_f32)\n-impl_from_primitive!(f64, to_f64)\n+}\n+\n+impl_from_primitive! { int, to_int }\n+impl_from_primitive! { i8, to_i8 }\n+impl_from_primitive! { i16, to_i16 }\n+impl_from_primitive! { i32, to_i32 }\n+impl_from_primitive! { i64, to_i64 }\n+impl_from_primitive! { uint, to_uint }\n+impl_from_primitive! { u8, to_u8 }\n+impl_from_primitive! { u16, to_u16 }\n+impl_from_primitive! { u32, to_u32 }\n+impl_from_primitive! { u64, to_u64 }\n+impl_from_primitive! { f32, to_f32 }\n+impl_from_primitive! { f64, to_f64 }\n \n /// Cast from one machine scalar to another.\n ///\n@@ -1198,7 +1198,7 @@ pub trait NumCast: ToPrimitive {\n     fn from<T: ToPrimitive>(n: T) -> Option<Self>;\n }\n \n-macro_rules! impl_num_cast(\n+macro_rules! impl_num_cast {\n     ($T:ty, $conv:ident) => (\n         impl NumCast for $T {\n             #[inline]\n@@ -1209,20 +1209,20 @@ macro_rules! impl_num_cast(\n             }\n         }\n     )\n-)\n-\n-impl_num_cast!(u8,    to_u8)\n-impl_num_cast!(u16,   to_u16)\n-impl_num_cast!(u32,   to_u32)\n-impl_num_cast!(u64,   to_u64)\n-impl_num_cast!(uint,  to_uint)\n-impl_num_cast!(i8,    to_i8)\n-impl_num_cast!(i16,   to_i16)\n-impl_num_cast!(i32,   to_i32)\n-impl_num_cast!(i64,   to_i64)\n-impl_num_cast!(int,   to_int)\n-impl_num_cast!(f32,   to_f32)\n-impl_num_cast!(f64,   to_f64)\n+}\n+\n+impl_num_cast! { u8,    to_u8 }\n+impl_num_cast! { u16,   to_u16 }\n+impl_num_cast! { u32,   to_u32 }\n+impl_num_cast! { u64,   to_u64 }\n+impl_num_cast! { uint,  to_uint }\n+impl_num_cast! { i8,    to_i8 }\n+impl_num_cast! { i16,   to_i16 }\n+impl_num_cast! { i32,   to_i32 }\n+impl_num_cast! { i64,   to_i64 }\n+impl_num_cast! { int,   to_int }\n+impl_num_cast! { f32,   to_f32 }\n+impl_num_cast! { f64,   to_f64 }\n \n /// Used for representing the classification of floating point numbers\n #[deriving(PartialEq, Show)]\n@@ -1638,8 +1638,8 @@ macro_rules! from_str_radix_float_impl {\n         }\n     }\n }\n-from_str_radix_float_impl!(f32)\n-from_str_radix_float_impl!(f64)\n+from_str_radix_float_impl! { f32 }\n+from_str_radix_float_impl! { f64 }\n \n macro_rules! from_str_radix_int_impl {\n     ($T:ty) => {\n@@ -1705,16 +1705,16 @@ macro_rules! from_str_radix_int_impl {\n         }\n     }\n }\n-from_str_radix_int_impl!(int)\n-from_str_radix_int_impl!(i8)\n-from_str_radix_int_impl!(i16)\n-from_str_radix_int_impl!(i32)\n-from_str_radix_int_impl!(i64)\n-from_str_radix_int_impl!(uint)\n-from_str_radix_int_impl!(u8)\n-from_str_radix_int_impl!(u16)\n-from_str_radix_int_impl!(u32)\n-from_str_radix_int_impl!(u64)\n+from_str_radix_int_impl! { int }\n+from_str_radix_int_impl! { i8 }\n+from_str_radix_int_impl! { i16 }\n+from_str_radix_int_impl! { i32 }\n+from_str_radix_int_impl! { i64 }\n+from_str_radix_int_impl! { uint }\n+from_str_radix_int_impl! { u8 }\n+from_str_radix_int_impl! { u16 }\n+from_str_radix_int_impl! { u32 }\n+from_str_radix_int_impl! { u64 }\n \n // DEPRECATED\n \n@@ -1733,17 +1733,17 @@ pub trait Num: PartialEq + Zero + One\n              + Mul<Self,Self>\n              + Div<Self,Self>\n              + Rem<Self,Self> {}\n-trait_impl!(Num for uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64)\n+trait_impl! { Num for uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64 }\n \n #[deprecated = \"Generalised unsigned numbers are no longer supported\"]\n #[allow(deprecated)]\n pub trait Unsigned: Num {}\n-trait_impl!(Unsigned for uint u8 u16 u32 u64)\n+trait_impl! { Unsigned for uint u8 u16 u32 u64 }\n \n #[deprecated = \"Use `Float` or `Int`\"]\n #[allow(deprecated)]\n pub trait Primitive: Copy + Clone + Num + NumCast + PartialOrd {}\n-trait_impl!(Primitive for uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64)\n+trait_impl! { Primitive for uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64 }\n \n #[deprecated = \"The generic `Zero` trait will be removed soon.\"]\n pub trait Zero: Add<Self, Self> {\n@@ -1763,18 +1763,18 @@ macro_rules! zero_impl {\n         }\n     }\n }\n-zero_impl!(uint, 0u)\n-zero_impl!(u8,   0u8)\n-zero_impl!(u16,  0u16)\n-zero_impl!(u32,  0u32)\n-zero_impl!(u64,  0u64)\n-zero_impl!(int, 0i)\n-zero_impl!(i8,  0i8)\n-zero_impl!(i16, 0i16)\n-zero_impl!(i32, 0i32)\n-zero_impl!(i64, 0i64)\n-zero_impl!(f32, 0.0f32)\n-zero_impl!(f64, 0.0f64)\n+zero_impl! { uint, 0u }\n+zero_impl! { u8,   0u8 }\n+zero_impl! { u16,  0u16 }\n+zero_impl! { u32,  0u32 }\n+zero_impl! { u64,  0u64 }\n+zero_impl! { int, 0i }\n+zero_impl! { i8,  0i8 }\n+zero_impl! { i16, 0i16 }\n+zero_impl! { i32, 0i32 }\n+zero_impl! { i64, 0i64 }\n+zero_impl! { f32, 0.0f32 }\n+zero_impl! { f64, 0.0f64 }\n \n #[deprecated = \"The generic `One` trait will be removed soon.\"]\n pub trait One: Mul<Self, Self> {\n@@ -1791,18 +1791,18 @@ macro_rules! one_impl {\n         }\n     }\n }\n-one_impl!(uint, 1u)\n-one_impl!(u8,  1u8)\n-one_impl!(u16, 1u16)\n-one_impl!(u32, 1u32)\n-one_impl!(u64, 1u64)\n-one_impl!(int, 1i)\n-one_impl!(i8,  1i8)\n-one_impl!(i16, 1i16)\n-one_impl!(i32, 1i32)\n-one_impl!(i64, 1i64)\n-one_impl!(f32, 1.0f32)\n-one_impl!(f64, 1.0f64)\n+one_impl! { uint, 1u }\n+one_impl! { u8,  1u8 }\n+one_impl! { u16, 1u16 }\n+one_impl! { u32, 1u32 }\n+one_impl! { u64, 1u64 }\n+one_impl! { int, 1i }\n+one_impl! { i8,  1i8 }\n+one_impl! { i16, 1i16 }\n+one_impl! { i32, 1i32 }\n+one_impl! { i64, 1i64 }\n+one_impl! { f32, 1.0f32 }\n+one_impl! { f64, 1.0f64 }\n \n #[deprecated = \"Use `UnsignedInt::next_power_of_two`\"]\n pub fn next_power_of_two<T: UnsignedInt>(n: T) -> T {\n@@ -1835,15 +1835,15 @@ macro_rules! bounded_impl {\n         }\n     };\n }\n-bounded_impl!(uint, uint::MIN, uint::MAX)\n-bounded_impl!(u8, u8::MIN, u8::MAX)\n-bounded_impl!(u16, u16::MIN, u16::MAX)\n-bounded_impl!(u32, u32::MIN, u32::MAX)\n-bounded_impl!(u64, u64::MIN, u64::MAX)\n-bounded_impl!(int, int::MIN, int::MAX)\n-bounded_impl!(i8, i8::MIN, i8::MAX)\n-bounded_impl!(i16, i16::MIN, i16::MAX)\n-bounded_impl!(i32, i32::MIN, i32::MAX)\n-bounded_impl!(i64, i64::MIN, i64::MAX)\n-bounded_impl!(f32, f32::MIN_VALUE, f32::MAX_VALUE)\n-bounded_impl!(f64, f64::MIN_VALUE, f64::MAX_VALUE)\n+bounded_impl! { uint, uint::MIN, uint::MAX }\n+bounded_impl! { u8, u8::MIN, u8::MAX }\n+bounded_impl! { u16, u16::MIN, u16::MAX }\n+bounded_impl! { u32, u32::MIN, u32::MAX }\n+bounded_impl! { u64, u64::MIN, u64::MAX }\n+bounded_impl! { int, int::MIN, int::MAX }\n+bounded_impl! { i8, i8::MIN, i8::MAX }\n+bounded_impl! { i16, i16::MIN, i16::MAX }\n+bounded_impl! { i32, i32::MIN, i32::MAX }\n+bounded_impl! { i64, i64::MIN, i64::MAX }\n+bounded_impl! { f32, f32::MIN_VALUE, f32::MAX_VALUE }\n+bounded_impl! { f64, f64::MIN_VALUE, f64::MAX_VALUE }"}, {"sha": "730a24a963a561f4ad6d8a92eea36c7939ead959", "filename": "src/libcore/num/u16.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibcore%2Fnum%2Fu16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibcore%2Fnum%2Fu16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fu16.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -13,4 +13,4 @@\n #![stable]\n #![doc(primitive = \"u16\")]\n \n-uint_module!(u16, i16, 16)\n+uint_module! { u16, i16, 16 }"}, {"sha": "f308122af438dfc74a5727b3872daee8dc108786", "filename": "src/libcore/num/u32.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibcore%2Fnum%2Fu32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibcore%2Fnum%2Fu32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fu32.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -13,4 +13,4 @@\n #![stable]\n #![doc(primitive = \"u32\")]\n \n-uint_module!(u32, i32, 32)\n+uint_module! { u32, i32, 32 }"}, {"sha": "a55868eb7468fa6c60a55f4347f9f2e6cc5b7096", "filename": "src/libcore/num/u64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibcore%2Fnum%2Fu64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibcore%2Fnum%2Fu64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fu64.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -13,4 +13,4 @@\n #![stable]\n #![doc(primitive = \"u64\")]\n \n-uint_module!(u64, i64, 64)\n+uint_module! { u64, i64, 64 }"}, {"sha": "8643f8ad6502865d480f1871d57fd22afd7b0692", "filename": "src/libcore/num/u8.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibcore%2Fnum%2Fu8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibcore%2Fnum%2Fu8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fu8.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -13,4 +13,4 @@\n #![stable]\n #![doc(primitive = \"u8\")]\n \n-uint_module!(u8, i8, 8)\n+uint_module! { u8, i8, 8 }"}, {"sha": "80d7b0b4ef374697696d148a9c945e1b3593cd50", "filename": "src/libcore/num/uint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibcore%2Fnum%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibcore%2Fnum%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -13,5 +13,5 @@\n #![unstable]\n #![doc(primitive = \"uint\")]\n \n-uint_module!(uint, int, ::int::BITS)\n+uint_module! { uint, int, ::int::BITS }\n "}, {"sha": "d79cf20fdfa6fe9967e6aab2118175d2485f83f9", "filename": "src/libcore/num/uint_macros.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibcore%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibcore%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint_macros.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -11,7 +11,7 @@\n #![macro_escape]\n #![doc(hidden)]\n \n-macro_rules! uint_module (($T:ty, $T_SIGNED:ty, $bits:expr) => (\n+macro_rules! uint_module { ($T:ty, $T_SIGNED:ty, $bits:expr) => (\n \n #[unstable]\n pub const BITS : uint = $bits;\n@@ -23,4 +23,5 @@ pub const MIN: $T = 0 as $T;\n #[unstable]\n pub const MAX: $T = 0 as $T - 1 as $T;\n \n-))\n+) }\n+"}, {"sha": "bc29a2b4a58cdc7a201d09c9e7c7ae394857fa18", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 69, "deletions": 69, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -113,14 +113,14 @@ pub trait Add<Sized? RHS,Result> for Sized? {\n \n // NOTE(stage0): Remove macro after a snapshot\n #[cfg(stage0)]\n-macro_rules! add_impl(\n+macro_rules! add_impl {\n     ($($t:ty)*) => ($(\n         impl Add<$t, $t> for $t {\n             #[inline]\n             fn add(&self, other: &$t) -> $t { (*self) + (*other) }\n         }\n     )*)\n-)\n+}\n \n /// The `Add` trait is used to specify the functionality of `+`.\n ///\n@@ -151,16 +151,16 @@ pub trait Add<RHS, Result> {\n }\n \n #[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n-macro_rules! add_impl(\n+macro_rules! add_impl {\n     ($($t:ty)*) => ($(\n         impl Add<$t, $t> for $t {\n             #[inline]\n             fn add(self, other: $t) -> $t { self + other }\n         }\n     )*)\n-)\n+}\n \n-add_impl!(uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64)\n+add_impl! { uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64 }\n \n /// The `Sub` trait is used to specify the functionality of `-`.\n ///\n@@ -195,14 +195,14 @@ pub trait Sub<Sized? RHS, Result> for Sized? {\n \n // NOTE(stage0): Remove macro after a snapshot\n #[cfg(stage0)]\n-macro_rules! sub_impl(\n+macro_rules! sub_impl {\n     ($($t:ty)*) => ($(\n         impl Sub<$t, $t> for $t {\n             #[inline]\n             fn sub(&self, other: &$t) -> $t { (*self) - (*other) }\n         }\n     )*)\n-)\n+}\n \n /// The `Sub` trait is used to specify the functionality of `-`.\n ///\n@@ -233,16 +233,16 @@ pub trait Sub<RHS, Result> {\n }\n \n #[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n-macro_rules! sub_impl(\n+macro_rules! sub_impl {\n     ($($t:ty)*) => ($(\n         impl Sub<$t, $t> for $t {\n             #[inline]\n             fn sub(self, other: $t) -> $t { self - other }\n         }\n     )*)\n-)\n+}\n \n-sub_impl!(uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64)\n+sub_impl! { uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64 }\n \n /// The `Mul` trait is used to specify the functionality of `*`.\n ///\n@@ -277,14 +277,14 @@ pub trait Mul<Sized? RHS, Result>  for Sized? {\n \n // NOTE(stage0): Remove macro after a snapshot\n #[cfg(stage0)]\n-macro_rules! mul_impl(\n+macro_rules! mul_impl {\n     ($($t:ty)*) => ($(\n         impl Mul<$t, $t> for $t {\n             #[inline]\n             fn mul(&self, other: &$t) -> $t { (*self) * (*other) }\n         }\n     )*)\n-)\n+}\n \n /// The `Mul` trait is used to specify the functionality of `*`.\n ///\n@@ -315,16 +315,16 @@ pub trait Mul<RHS, Result> {\n }\n \n #[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n-macro_rules! mul_impl(\n+macro_rules! mul_impl {\n     ($($t:ty)*) => ($(\n         impl Mul<$t, $t> for $t {\n             #[inline]\n             fn mul(self, other: $t) -> $t { self * other }\n         }\n     )*)\n-)\n+}\n \n-mul_impl!(uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64)\n+mul_impl! { uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64 }\n \n /// The `Div` trait is used to specify the functionality of `/`.\n ///\n@@ -359,14 +359,14 @@ pub trait Div<Sized? RHS, Result> for Sized? {\n \n // NOTE(stage0): Remove macro after a snapshot\n #[cfg(stage0)]\n-macro_rules! div_impl(\n+macro_rules! div_impl {\n     ($($t:ty)*) => ($(\n         impl Div<$t, $t> for $t {\n             #[inline]\n             fn div(&self, other: &$t) -> $t { (*self) / (*other) }\n         }\n     )*)\n-)\n+}\n \n /// The `Div` trait is used to specify the functionality of `/`.\n ///\n@@ -397,16 +397,16 @@ pub trait Div<RHS, Result> {\n }\n \n #[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n-macro_rules! div_impl(\n+macro_rules! div_impl {\n     ($($t:ty)*) => ($(\n         impl Div<$t, $t> for $t {\n             #[inline]\n             fn div(self, other: $t) -> $t { self / other }\n         }\n     )*)\n-)\n+}\n \n-div_impl!(uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64)\n+div_impl! { uint u8 u16 u32 u64 int i8 i16 i32 i64 f32 f64 }\n \n /// The `Rem` trait is used to specify the functionality of `%`.\n ///\n@@ -441,18 +441,18 @@ pub trait Rem<Sized? RHS, Result>  for Sized? {\n \n // NOTE(stage0): Remove macro after a snapshot\n #[cfg(stage0)]\n-macro_rules! rem_impl(\n+macro_rules! rem_impl {\n     ($($t:ty)*) => ($(\n         impl Rem<$t, $t> for $t {\n             #[inline]\n             fn rem(&self, other: &$t) -> $t { (*self) % (*other) }\n         }\n     )*)\n-)\n+}\n \n // NOTE(stage0): Remove macro after a snapshot\n #[cfg(stage0)]\n-macro_rules! rem_float_impl(\n+macro_rules! rem_float_impl {\n     ($t:ty, $fmod:ident) => {\n         impl Rem<$t, $t> for $t {\n             #[inline]\n@@ -462,7 +462,7 @@ macro_rules! rem_float_impl(\n             }\n         }\n     }\n-)\n+}\n \n /// The `Rem` trait is used to specify the functionality of `%`.\n ///\n@@ -493,17 +493,17 @@ pub trait Rem<RHS, Result> {\n }\n \n #[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n-macro_rules! rem_impl(\n+macro_rules! rem_impl {\n     ($($t:ty)*) => ($(\n         impl Rem<$t, $t> for $t {\n             #[inline]\n             fn rem(self, other: $t) -> $t { self % other }\n         }\n     )*)\n-)\n+}\n \n #[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n-macro_rules! rem_float_impl(\n+macro_rules! rem_float_impl {\n     ($t:ty, $fmod:ident) => {\n         impl Rem<$t, $t> for $t {\n             #[inline]\n@@ -513,11 +513,11 @@ macro_rules! rem_float_impl(\n             }\n         }\n     }\n-)\n+}\n \n-rem_impl!(uint u8 u16 u32 u64 int i8 i16 i32 i64)\n-rem_float_impl!(f32, fmodf)\n-rem_float_impl!(f64, fmod)\n+rem_impl! { uint u8 u16 u32 u64 int i8 i16 i32 i64 }\n+rem_float_impl! { f32, fmodf }\n+rem_float_impl! { f64, fmod }\n \n /// The `Neg` trait is used to specify the functionality of unary `-`.\n ///\n@@ -548,31 +548,31 @@ pub trait Neg<Result> for Sized? {\n     fn neg(&self) -> Result;\n }\n \n-macro_rules! neg_impl(\n+macro_rules! neg_impl {\n     ($($t:ty)*) => ($(\n         impl Neg<$t> for $t {\n             #[inline]\n             fn neg(&self) -> $t { -*self }\n         }\n     )*)\n-)\n+}\n \n-macro_rules! neg_uint_impl(\n+macro_rules! neg_uint_impl {\n     ($t:ty, $t_signed:ty) => {\n         impl Neg<$t> for $t {\n             #[inline]\n             fn neg(&self) -> $t { -(*self as $t_signed) as $t }\n         }\n     }\n-)\n+}\n \n-neg_impl!(int i8 i16 i32 i64 f32 f64)\n+neg_impl! { int i8 i16 i32 i64 f32 f64 }\n \n-neg_uint_impl!(uint, int)\n-neg_uint_impl!(u8, i8)\n-neg_uint_impl!(u16, i16)\n-neg_uint_impl!(u32, i32)\n-neg_uint_impl!(u64, i64)\n+neg_uint_impl! { uint, int }\n+neg_uint_impl! { u8, i8 }\n+neg_uint_impl! { u16, i16 }\n+neg_uint_impl! { u32, i32 }\n+neg_uint_impl! { u64, i64 }\n \n \n /// The `Not` trait is used to specify the functionality of unary `!`.\n@@ -605,16 +605,16 @@ pub trait Not<Result> for Sized? {\n }\n \n \n-macro_rules! not_impl(\n+macro_rules! not_impl {\n     ($($t:ty)*) => ($(\n         impl Not<$t> for $t {\n             #[inline]\n             fn not(&self) -> $t { !*self }\n         }\n     )*)\n-)\n+}\n \n-not_impl!(bool uint u8 u16 u32 u64 int i8 i16 i32 i64)\n+not_impl! { bool uint u8 u16 u32 u64 int i8 i16 i32 i64 }\n \n /// The `BitAnd` trait is used to specify the functionality of `&`.\n ///\n@@ -649,14 +649,14 @@ pub trait BitAnd<Sized? RHS, Result> for Sized? {\n \n // NOTE(stage0): Remove macro after a snapshot\n #[cfg(stage0)]\n-macro_rules! bitand_impl(\n+macro_rules! bitand_impl {\n     ($($t:ty)*) => ($(\n         impl BitAnd<$t, $t> for $t {\n             #[inline]\n             fn bitand(&self, rhs: &$t) -> $t { (*self) & (*rhs) }\n         }\n     )*)\n-)\n+}\n \n /// The `BitAnd` trait is used to specify the functionality of `&`.\n ///\n@@ -687,16 +687,16 @@ pub trait BitAnd<RHS, Result> {\n }\n \n #[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n-macro_rules! bitand_impl(\n+macro_rules! bitand_impl {\n     ($($t:ty)*) => ($(\n         impl BitAnd<$t, $t> for $t {\n             #[inline]\n             fn bitand(self, rhs: $t) -> $t { self & rhs }\n         }\n     )*)\n-)\n+}\n \n-bitand_impl!(bool uint u8 u16 u32 u64 int i8 i16 i32 i64)\n+bitand_impl! { bool uint u8 u16 u32 u64 int i8 i16 i32 i64 }\n \n /// The `BitOr` trait is used to specify the functionality of `|`.\n ///\n@@ -731,14 +731,14 @@ pub trait BitOr<Sized? RHS, Result> for Sized? {\n \n // NOTE(stage0): Remove macro after a snapshot\n #[cfg(stage0)]\n-macro_rules! bitor_impl(\n+macro_rules! bitor_impl {\n     ($($t:ty)*) => ($(\n         impl BitOr<$t,$t> for $t {\n             #[inline]\n             fn bitor(&self, rhs: &$t) -> $t { (*self) | (*rhs) }\n         }\n     )*)\n-)\n+}\n \n /// The `BitOr` trait is used to specify the functionality of `|`.\n ///\n@@ -769,16 +769,16 @@ pub trait BitOr<RHS, Result> {\n }\n \n #[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n-macro_rules! bitor_impl(\n+macro_rules! bitor_impl {\n     ($($t:ty)*) => ($(\n         impl BitOr<$t,$t> for $t {\n             #[inline]\n             fn bitor(self, rhs: $t) -> $t { self | rhs }\n         }\n     )*)\n-)\n+}\n \n-bitor_impl!(bool uint u8 u16 u32 u64 int i8 i16 i32 i64)\n+bitor_impl! { bool uint u8 u16 u32 u64 int i8 i16 i32 i64 }\n \n /// The `BitXor` trait is used to specify the functionality of `^`.\n ///\n@@ -813,14 +813,14 @@ pub trait BitXor<Sized? RHS, Result> for Sized? {\n \n // NOTE(stage0): Remove macro after a snapshot\n #[cfg(stage0)]\n-macro_rules! bitxor_impl(\n+macro_rules! bitxor_impl {\n     ($($t:ty)*) => ($(\n         impl BitXor<$t, $t> for $t {\n             #[inline]\n             fn bitxor(&self, other: &$t) -> $t { (*self) ^ (*other) }\n         }\n     )*)\n-)\n+}\n \n /// The `BitXor` trait is used to specify the functionality of `^`.\n ///\n@@ -851,16 +851,16 @@ pub trait BitXor<RHS, Result> {\n }\n \n #[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n-macro_rules! bitxor_impl(\n+macro_rules! bitxor_impl {\n     ($($t:ty)*) => ($(\n         impl BitXor<$t, $t> for $t {\n             #[inline]\n             fn bitxor(self, other: $t) -> $t { self ^ other }\n         }\n     )*)\n-)\n+}\n \n-bitxor_impl!(bool uint u8 u16 u32 u64 int i8 i16 i32 i64)\n+bitxor_impl! { bool uint u8 u16 u32 u64 int i8 i16 i32 i64 }\n \n /// The `Shl` trait is used to specify the functionality of `<<`.\n ///\n@@ -895,7 +895,7 @@ pub trait Shl<Sized? RHS, Result> for Sized? {\n \n // NOTE(stage0): Remove macro after a snapshot\n #[cfg(stage0)]\n-macro_rules! shl_impl(\n+macro_rules! shl_impl {\n     ($($t:ty)*) => ($(\n         impl Shl<uint, $t> for $t {\n             #[inline]\n@@ -904,7 +904,7 @@ macro_rules! shl_impl(\n             }\n         }\n     )*)\n-)\n+}\n \n /// The `Shl` trait is used to specify the functionality of `<<`.\n ///\n@@ -935,7 +935,7 @@ pub trait Shl<RHS, Result> {\n }\n \n #[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n-macro_rules! shl_impl(\n+macro_rules! shl_impl {\n     ($($t:ty)*) => ($(\n         impl Shl<uint, $t> for $t {\n             #[inline]\n@@ -944,9 +944,9 @@ macro_rules! shl_impl(\n             }\n         }\n     )*)\n-)\n+}\n \n-shl_impl!(uint u8 u16 u32 u64 int i8 i16 i32 i64)\n+shl_impl! { uint u8 u16 u32 u64 int i8 i16 i32 i64 }\n \n /// The `Shr` trait is used to specify the functionality of `>>`.\n ///\n@@ -981,14 +981,14 @@ pub trait Shr<Sized? RHS, Result> for Sized? {\n \n // NOTE(stage0): Remove macro after a snapshot\n #[cfg(stage0)]\n-macro_rules! shr_impl(\n+macro_rules! shr_impl {\n     ($($t:ty)*) => ($(\n         impl Shr<uint, $t> for $t {\n             #[inline]\n             fn shr(&self, other: &uint) -> $t { (*self) >> (*other) }\n         }\n     )*)\n-)\n+}\n \n /// The `Shr` trait is used to specify the functionality of `>>`.\n ///\n@@ -1019,16 +1019,16 @@ pub trait Shr<RHS, Result> {\n }\n \n #[cfg(not(stage0))]  // NOTE(stage0): Remove cfg after a snapshot\n-macro_rules! shr_impl(\n+macro_rules! shr_impl {\n     ($($t:ty)*) => ($(\n         impl Shr<uint, $t> for $t {\n             #[inline]\n             fn shr(self, other: uint) -> $t { self >> other }\n         }\n     )*)\n-)\n+}\n \n-shr_impl!(uint u8 u16 u32 u64 int i8 i16 i32 i64)\n+shr_impl! { uint u8 u16 u32 u64 int i8 i16 i32 i64 }\n \n /// The `Index` trait is used to specify the functionality of indexing operations\n /// like `arr[idx]` when used in an immutable context."}, {"sha": "36c6b9572ea7011558a9f6c2e1aba5ecf4b1eafe", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -367,7 +367,7 @@ mod externfnpointers {\n             self_ == other_\n         }\n     }\n-    macro_rules! fnptreq(\n+    macro_rules! fnptreq {\n         ($($p:ident),*) => {\n             impl<_R,$($p),*> PartialEq for extern \"C\" fn($($p),*) -> _R {\n                 #[inline]\n@@ -379,12 +379,12 @@ mod externfnpointers {\n                 }\n             }\n         }\n-    )\n-    fnptreq!(A)\n-    fnptreq!(A,B)\n-    fnptreq!(A,B,C)\n-    fnptreq!(A,B,C,D)\n-    fnptreq!(A,B,C,D,E)\n+    }\n+    fnptreq! { A }\n+    fnptreq! { A,B }\n+    fnptreq! { A,B,C }\n+    fnptreq! { A,B,C,D }\n+    fnptreq! { A,B,C,D,E }\n }\n \n // Comparison for pointers"}, {"sha": "e12666a2adff31c85ec556bc73363e1f6649f3e4", "filename": "src/libcore/result.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -222,7 +222,7 @@\n //! # #![feature(macro_rules)]\n //! macro_rules! try(\n //!     ($e:expr) => (match $e { Ok(e) => e, Err(e) => return Err(e) })\n-//! )\n+//! );\n //! # fn main() { }\n //! ```\n //!"}, {"sha": "2ee609552454a7e4e82375a75277d5c42f115365", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -1540,16 +1540,16 @@ macro_rules! impl_mut_int_slice {\n \n macro_rules! impl_int_slice {\n     ($u:ty, $s:ty) => {\n-        impl_immut_int_slice!($u, $s, $u)\n-        impl_immut_int_slice!($u, $s, $s)\n-        impl_mut_int_slice!($u, $s, $u)\n-        impl_mut_int_slice!($u, $s, $s)\n+        impl_immut_int_slice! { $u, $s, $u }\n+        impl_immut_int_slice! { $u, $s, $s }\n+        impl_mut_int_slice! { $u, $s, $u }\n+        impl_mut_int_slice! { $u, $s, $s }\n     }\n }\n \n-impl_int_slice!(u8,   i8)\n-impl_int_slice!(u16,  i16)\n-impl_int_slice!(u32,  i32)\n-impl_int_slice!(u64,  i64)\n-impl_int_slice!(uint, int)\n+impl_int_slice! { u8,   i8 }\n+impl_int_slice! { u16,  i16 }\n+impl_int_slice! { u32,  i32 }\n+impl_int_slice! { u64,  i64 }\n+impl_int_slice! { uint, int }\n "}, {"sha": "28110cf7b1a374fc390fcb898f920d3e3941dae8", "filename": "src/libcore/str.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -174,18 +174,18 @@ impl<'a> Copy for Chars<'a> {}\n // Return the initial codepoint accumulator for the first byte.\n // The first byte is special, only want bottom 5 bits for width 2, 4 bits\n // for width 3, and 3 bits for width 4\n-macro_rules! utf8_first_byte(\n+macro_rules! utf8_first_byte {\n     ($byte:expr, $width:expr) => (($byte & (0x7F >> $width)) as u32)\n-)\n+}\n \n // return the value of $ch updated with continuation byte $byte\n-macro_rules! utf8_acc_cont_byte(\n+macro_rules! utf8_acc_cont_byte {\n     ($ch:expr, $byte:expr) => (($ch << 6) | ($byte & CONT_MASK) as u32)\n-)\n+}\n \n-macro_rules! utf8_is_cont_byte(\n+macro_rules! utf8_is_cont_byte {\n     ($byte:expr) => (($byte & !CONT_MASK) == TAG_CONT_U8)\n-)\n+}\n \n #[inline]\n fn unwrap_or_0(opt: Option<&u8>) -> u8 {\n@@ -959,7 +959,7 @@ pub fn is_utf16(v: &[u16]) -> bool {\n     macro_rules! next ( ($ret:expr) => {\n             match it.next() { Some(u) => *u, None => return $ret }\n         }\n-    )\n+    );\n     loop {\n         let u = next!(true);\n \n@@ -1660,10 +1660,10 @@ pub trait StrPrelude for Sized? {\n     /// # #![feature(unboxed_closures)]\n     ///\n     /// # fn main() {\n-    /// assert_eq!(\"11foo1bar11\".trim_chars('1'), \"foo1bar\")\n+    /// assert_eq!(\"11foo1bar11\".trim_chars('1'), \"foo1bar\");\n     /// let x: &[_] = &['1', '2'];\n-    /// assert_eq!(\"12foo1bar12\".trim_chars(x), \"foo1bar\")\n-    /// assert_eq!(\"123foo1bar123\".trim_chars(|&: c: char| c.is_numeric()), \"foo1bar\")\n+    /// assert_eq!(\"12foo1bar12\".trim_chars(x), \"foo1bar\");\n+    /// assert_eq!(\"123foo1bar123\".trim_chars(|&: c: char| c.is_numeric()), \"foo1bar\");\n     /// # }\n     /// ```\n     fn trim_chars<'a, C: CharEq>(&'a self, to_trim: C) -> &'a str;\n@@ -1680,10 +1680,10 @@ pub trait StrPrelude for Sized? {\n     /// # #![feature(unboxed_closures)]\n     ///\n     /// # fn main() {\n-    /// assert_eq!(\"11foo1bar11\".trim_left_chars('1'), \"foo1bar11\")\n+    /// assert_eq!(\"11foo1bar11\".trim_left_chars('1'), \"foo1bar11\");\n     /// let x: &[_] = &['1', '2'];\n-    /// assert_eq!(\"12foo1bar12\".trim_left_chars(x), \"foo1bar12\")\n-    /// assert_eq!(\"123foo1bar123\".trim_left_chars(|&: c: char| c.is_numeric()), \"foo1bar123\")\n+    /// assert_eq!(\"12foo1bar12\".trim_left_chars(x), \"foo1bar12\");\n+    /// assert_eq!(\"123foo1bar123\".trim_left_chars(|&: c: char| c.is_numeric()), \"foo1bar123\");\n     /// # }\n     /// ```\n     fn trim_left_chars<'a, C: CharEq>(&'a self, to_trim: C) -> &'a str;\n@@ -1700,10 +1700,10 @@ pub trait StrPrelude for Sized? {\n     /// # #![feature(unboxed_closures)]\n     ///\n     /// # fn main() {\n-    /// assert_eq!(\"11foo1bar11\".trim_right_chars('1'), \"11foo1bar\")\n+    /// assert_eq!(\"11foo1bar11\".trim_right_chars('1'), \"11foo1bar\");\n     /// let x: &[_] = &['1', '2'];\n-    /// assert_eq!(\"12foo1bar12\".trim_right_chars(x), \"12foo1bar\")\n-    /// assert_eq!(\"123foo1bar123\".trim_right_chars(|&: c: char| c.is_numeric()), \"123foo1bar\")\n+    /// assert_eq!(\"12foo1bar12\".trim_right_chars(x), \"12foo1bar\");\n+    /// assert_eq!(\"123foo1bar123\".trim_right_chars(|&: c: char| c.is_numeric()), \"123foo1bar\");\n     /// # }\n     /// ```\n     fn trim_right_chars<'a, C: CharEq>(&'a self, to_trim: C) -> &'a str;\n@@ -2059,7 +2059,7 @@ impl StrPrelude for str {\n \n     #[inline]\n     fn match_indices<'a>(&'a self, sep: &'a str) -> MatchIndices<'a> {\n-        assert!(!sep.is_empty())\n+        assert!(!sep.is_empty());\n         MatchIndices {\n             haystack: self,\n             needle: sep,"}, {"sha": "dbbbaa5892cc4bd77b101479162d84235c703539", "filename": "src/libcoretest/iter.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibcoretest%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibcoretest%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fiter.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -522,15 +522,15 @@ fn test_double_ended_chain() {\n     let xs = [1i, 2, 3, 4, 5];\n     let ys = [7i, 9, 11];\n     let mut it = xs.iter().chain(ys.iter()).rev();\n-    assert_eq!(it.next().unwrap(), &11)\n-    assert_eq!(it.next().unwrap(), &9)\n-    assert_eq!(it.next_back().unwrap(), &1)\n-    assert_eq!(it.next_back().unwrap(), &2)\n-    assert_eq!(it.next_back().unwrap(), &3)\n-    assert_eq!(it.next_back().unwrap(), &4)\n-    assert_eq!(it.next_back().unwrap(), &5)\n-    assert_eq!(it.next_back().unwrap(), &7)\n-    assert_eq!(it.next_back(), None)\n+    assert_eq!(it.next().unwrap(), &11);\n+    assert_eq!(it.next().unwrap(), &9);\n+    assert_eq!(it.next_back().unwrap(), &1);\n+    assert_eq!(it.next_back().unwrap(), &2);\n+    assert_eq!(it.next_back().unwrap(), &3);\n+    assert_eq!(it.next_back().unwrap(), &4);\n+    assert_eq!(it.next_back().unwrap(), &5);\n+    assert_eq!(it.next_back().unwrap(), &7);\n+    assert_eq!(it.next_back(), None);\n }\n \n #[test]\n@@ -800,7 +800,7 @@ fn test_min_max() {\n #[test]\n fn test_min_max_result() {\n     let r: MinMaxResult<int> = NoElements;\n-    assert_eq!(r.into_option(), None)\n+    assert_eq!(r.into_option(), None);\n \n     let r = OneElement(1i);\n     assert_eq!(r.into_option(), Some((1,1)));"}, {"sha": "7435831ac6dba26fa851d9ae98f962e467a47437", "filename": "src/libcoretest/num/i16.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibcoretest%2Fnum%2Fi16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibcoretest%2Fnum%2Fi16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fi16.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -8,4 +8,4 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-int_module!(i16, i16)\n+int_module!(i16, i16);"}, {"sha": "3b3407e1ada520a373f5163bebc829742fbfa944", "filename": "src/libcoretest/num/i32.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibcoretest%2Fnum%2Fi32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibcoretest%2Fnum%2Fi32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fi32.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -8,4 +8,4 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-int_module!(i32, i32)\n+int_module!(i32, i32);"}, {"sha": "9e1aec256eed0ad4afe35b811a99385f465c002a", "filename": "src/libcoretest/num/i64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibcoretest%2Fnum%2Fi64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibcoretest%2Fnum%2Fi64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fi64.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -8,4 +8,4 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-int_module!(i64, i64)\n+int_module!(i64, i64);"}, {"sha": "f72244239b2606fee16fecd4bfae67ff637cef47", "filename": "src/libcoretest/num/i8.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibcoretest%2Fnum%2Fi8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibcoretest%2Fnum%2Fi8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fi8.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -8,4 +8,4 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-int_module!(i8, i8)\n+int_module!(i8, i8);"}, {"sha": "be8dfd02ee196bf25ea73f4603e49fc1e0b4ad01", "filename": "src/libcoretest/num/int.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibcoretest%2Fnum%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibcoretest%2Fnum%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fint.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -8,4 +8,4 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-int_module!(int, int)\n+int_module!(int, int);"}, {"sha": "55e0f10c8655c4f873a02479aebf65a824dd99a8", "filename": "src/libcoretest/num/int_macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibcoretest%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibcoretest%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fint_macros.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -202,4 +202,4 @@ mod tests {\n     }\n }\n \n-))\n+));"}, {"sha": "acc593d7be9c0d8d2ee6261aaa051d362956e5e5", "filename": "src/libcoretest/num/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibcoretest%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibcoretest%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fmod.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -62,9 +62,9 @@ mod test {\n         let s : Option<i16> = from_str_radix(\"80000\", 10);\n         assert_eq!(s, None);\n         let f : Option<f32> = from_str_radix(\"10000000000000000000000000000000000000000\", 10);\n-        assert_eq!(f, Some(Float::infinity()))\n+        assert_eq!(f, Some(Float::infinity()));\n         let fe : Option<f32> = from_str_radix(\"1e40\", 10);\n-        assert_eq!(fe, Some(Float::infinity()))\n+        assert_eq!(fe, Some(Float::infinity()));\n     }\n \n     #[test]"}, {"sha": "8455207583cc182d162cdbccbaa53b8eb6029280", "filename": "src/libcoretest/num/u16.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibcoretest%2Fnum%2Fu16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibcoretest%2Fnum%2Fu16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fu16.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -8,4 +8,4 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-uint_module!(u16, u16)\n+uint_module!(u16, u16);"}, {"sha": "b44e60f6529791036b5e02483e9d0c0eb9ecf4ee", "filename": "src/libcoretest/num/u32.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibcoretest%2Fnum%2Fu32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibcoretest%2Fnum%2Fu32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fu32.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -8,4 +8,4 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-uint_module!(u32, u32)\n+uint_module!(u32, u32);"}, {"sha": "ffcd1015d58d63f10049f2a234869eed26375095", "filename": "src/libcoretest/num/u64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibcoretest%2Fnum%2Fu64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibcoretest%2Fnum%2Fu64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fu64.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -8,4 +8,4 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-uint_module!(u64, u64)\n+uint_module!(u64, u64);"}, {"sha": "4ee14e22f2d576fbe0cf31b9857d8e07cfafe6c5", "filename": "src/libcoretest/num/u8.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibcoretest%2Fnum%2Fu8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibcoretest%2Fnum%2Fu8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fu8.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -8,4 +8,4 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-uint_module!(u8, u8)\n+uint_module!(u8, u8);"}, {"sha": "395e55cf255d248bce8a47b2f69ee2a132d94657", "filename": "src/libcoretest/num/uint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibcoretest%2Fnum%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibcoretest%2Fnum%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fuint.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -8,4 +8,4 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-uint_module!(uint, uint)\n+uint_module!(uint, uint);"}, {"sha": "b21ac11e6a0b5832908252a91b34c770ca0fb8b4", "filename": "src/libcoretest/num/uint_macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibcoretest%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibcoretest%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fuint_macros.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -124,4 +124,4 @@ mod tests {\n         assert!(5u.checked_div(0) == None);\n     }\n }\n-))\n+));"}, {"sha": "257ce79b5889065bbc68374ae4c78165a17d08aa", "filename": "src/liblog/lib.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Fliblog%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Fliblog%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Flib.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -213,9 +213,11 @@ pub const WARN: u32 = 2;\n /// Error log level\n pub const ERROR: u32 = 1;\n \n-thread_local!(static LOCAL_LOGGER: RefCell<Option<Box<Logger + Send>>> = {\n-    RefCell::new(None)\n-})\n+thread_local! {\n+    static LOCAL_LOGGER: RefCell<Option<Box<Logger + Send>>> = {\n+        RefCell::new(None)\n+    }\n+}\n \n /// A trait used to represent an interface to a task-local logger. Each task\n /// can have its own custom logger which can respond to logging messages"}, {"sha": "8b2cfcd420ac1011c610dd17237b3ef62389ff9e", "filename": "src/liblog/macros.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Fliblog%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Fliblog%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Fmacros.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -51,7 +51,7 @@\n /// 6:main: this is a custom logging level: 6\n /// ```\n #[macro_export]\n-macro_rules! log(\n+macro_rules! log {\n     ($lvl:expr, $($arg:tt)+) => ({\n         static LOC: ::log::LogLocation = ::log::LogLocation {\n             line: line!(),\n@@ -63,7 +63,7 @@ macro_rules! log(\n             format_args!(|args| { ::log::log(lvl, &LOC, args) }, $($arg)+)\n         }\n     })\n-)\n+}\n \n /// A convenience macro for logging at the error log level.\n ///\n@@ -87,9 +87,9 @@ macro_rules! log(\n /// ```\n ///\n #[macro_export]\n-macro_rules! error(\n+macro_rules! error {\n     ($($arg:tt)*) => (log!(::log::ERROR, $($arg)*))\n-)\n+}\n \n /// A convenience macro for logging at the warning log level.\n ///\n@@ -112,9 +112,9 @@ macro_rules! error(\n /// WARN:main: you may like to know that a process exited with: 3\n /// ```\n #[macro_export]\n-macro_rules! warn(\n+macro_rules! warn {\n     ($($arg:tt)*) => (log!(::log::WARN, $($arg)*))\n-)\n+}\n \n /// A convenience macro for logging at the info log level.\n ///\n@@ -137,9 +137,9 @@ macro_rules! warn(\n /// INFO:main: this function is about to return: 3\n /// ```\n #[macro_export]\n-macro_rules! info(\n+macro_rules! info {\n     ($($arg:tt)*) => (log!(::log::INFO, $($arg)*))\n-)\n+}\n \n /// A convenience macro for logging at the debug log level. This macro can also\n /// be omitted at compile time by passing `--cfg ndebug` to the compiler. If\n@@ -163,9 +163,9 @@ macro_rules! info(\n /// DEBUG:main: x = 10, y = 20\n /// ```\n #[macro_export]\n-macro_rules! debug(\n+macro_rules! debug {\n     ($($arg:tt)*) => (if cfg!(not(ndebug)) { log!(::log::DEBUG, $($arg)*) })\n-)\n+}\n \n /// A macro to test whether a log level is enabled for the current module.\n ///\n@@ -197,11 +197,12 @@ macro_rules! debug(\n /// DEBUG:main: x.x = 1, x.y = 2\n /// ```\n #[macro_export]\n-macro_rules! log_enabled(\n+macro_rules! log_enabled {\n     ($lvl:expr) => ({\n         let lvl = $lvl;\n         (lvl != ::log::DEBUG || cfg!(not(ndebug))) &&\n         lvl <= ::log::log_level() &&\n         ::log::mod_enabled(lvl, module_path!())\n     })\n-)\n+}\n+"}, {"sha": "2499d7f529fd5183a76130e09da6c15919f87468", "filename": "src/librand/isaac.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibrand%2Fisaac.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibrand%2Fisaac.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fisaac.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -434,7 +434,7 @@ impl Rng for Isaac64Rng {\n \n         // See corresponding location in IsaacRng.next_u32 for\n         // explanation.\n-        debug_assert!(self.cnt < RAND_SIZE_64)\n+        debug_assert!(self.cnt < RAND_SIZE_64);\n         self.rsl[(self.cnt % RAND_SIZE_64) as uint]\n     }\n }"}, {"sha": "3b38fde3884f1996a199d0bc603d76fe6e2e68bb", "filename": "src/librand/rand_impls.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibrand%2Frand_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibrand%2Frand_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Frand_impls.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -232,8 +232,8 @@ mod tests {\n     #[test]\n     fn floating_point_edge_cases() {\n         // the test for exact equality is correct here.\n-        assert!(ConstantRng(0xffff_ffff).gen::<f32>() != 1.0)\n-        assert!(ConstantRng(0xffff_ffff_ffff_ffff).gen::<f64>() != 1.0)\n+        assert!(ConstantRng(0xffff_ffff).gen::<f32>() != 1.0);\n+        assert!(ConstantRng(0xffff_ffff_ffff_ffff).gen::<f64>() != 1.0);\n     }\n \n     #[test]"}, {"sha": "bb7af92eb54522a220b65fddb64ad5199ae65b30", "filename": "src/librbml/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibrbml%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibrbml%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrbml%2Flib.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -139,7 +139,7 @@ pub mod reader {\n     pub type DecodeResult<T> = Result<T, Error>;\n     // rbml reading\n \n-    macro_rules! try_or(\n+    macro_rules! try_or {\n         ($e:expr, $r:expr) => (\n             match $e {\n                 Ok(e) => e,\n@@ -149,7 +149,7 @@ pub mod reader {\n                 }\n             }\n         )\n-    )\n+    }\n \n     pub struct Res {\n         pub val: uint,"}, {"sha": "60cf45aeddc178e178f775d5b99a988017f8bd37", "filename": "src/libregex/parse.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibregex%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibregex%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fparse.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -224,7 +224,7 @@ impl<'a> Parser<'a> {\n                 },\n                 '(' => {\n                     if self.peek_is(1, '?') {\n-                        try!(self.expect('?'))\n+                        try!(self.expect('?'));\n                         try!(self.parse_group_opts())\n                     } else {\n                         self.caps += 1;\n@@ -373,7 +373,7 @@ impl<'a> Parser<'a> {\n     fn parse_class(&mut self) -> Result<(), Error> {\n         let negated =\n             if self.peek_is(1, '^') {\n-                try!(self.expect('^'))\n+                try!(self.expect('^'));\n                 FLAG_NEGATED\n             } else {\n                 FLAG_EMPTY\n@@ -597,7 +597,7 @@ impl<'a> Parser<'a> {\n     // Parses all escape sequences.\n     // Assumes that '\\' is the current character.\n     fn parse_escape(&mut self) -> Result<Ast, Error> {\n-        try!(self.noteof(\"an escape sequence following a '\\\\'\"))\n+        try!(self.noteof(\"an escape sequence following a '\\\\'\"));\n \n         let c = self.cur();\n         if is_punct(c) {\n@@ -639,7 +639,7 @@ impl<'a> Parser<'a> {\n         let negated = if self.cur() == 'P' { FLAG_NEGATED } else { FLAG_EMPTY };\n         let mut name: String;\n         if self.peek_is(1, '{') {\n-            try!(self.expect('{'))\n+            try!(self.expect('{'));\n             let closer =\n                 match self.pos('}') {\n                     Some(i) => i,\n@@ -677,10 +677,10 @@ impl<'a> Parser<'a> {\n         let mut end = start + 1;\n         let (d2, d3) = (self.peek(1), self.peek(2));\n         if d2 >= Some('0') && d2 <= Some('7') {\n-            try!(self.noteof(\"expected octal character in [0-7]\"))\n+            try!(self.noteof(\"expected octal character in [0-7]\"));\n             end += 1;\n             if d3 >= Some('0') && d3 <= Some('7') {\n-                try!(self.noteof(\"expected octal character in [0-7]\"))\n+                try!(self.noteof(\"expected octal character in [0-7]\"));\n                 end += 1;\n             }\n         }\n@@ -698,7 +698,7 @@ impl<'a> Parser<'a> {\n     // Assumes that \\x has been read.\n     fn parse_hex(&mut self) -> Result<Ast, Error> {\n         if !self.peek_is(1, '{') {\n-            try!(self.expect('{'))\n+            try!(self.expect('{'));\n             return self.parse_hex_two()\n         }\n         let start = self.chari + 2;\n@@ -723,7 +723,7 @@ impl<'a> Parser<'a> {\n         let (start, end) = (self.chari, self.chari + 2);\n         let bad = self.slice(start - 2, self.chars.len());\n         try!(self.noteof(format!(\"Invalid hex escape sequence '{}'\",\n-                                 bad).as_slice()))\n+                                 bad).as_slice()));\n         self.parse_hex_digits(self.slice(start, end).as_slice())\n     }\n \n@@ -743,7 +743,7 @@ impl<'a> Parser<'a> {\n     // is '<'.\n     // When done, parser will be at the closing '>' character.\n     fn parse_named_capture(&mut self) -> Result<(), Error> {\n-        try!(self.noteof(\"a capture name\"))\n+        try!(self.noteof(\"a capture name\"));\n         let closer =\n             match self.pos('>') {\n                 Some(i) => i,\n@@ -773,15 +773,17 @@ impl<'a> Parser<'a> {\n     // character.\n     fn parse_group_opts(&mut self) -> Result<(), Error> {\n         if self.peek_is(1, 'P') && self.peek_is(2, '<') {\n-            try!(self.expect('P')) try!(self.expect('<'))\n+            try!(self.expect('P'));\n+            try!(self.expect('<'));\n             return self.parse_named_capture()\n         }\n         let start = self.chari;\n         let mut flags = self.flags;\n         let mut sign = 1i;\n         let mut saw_flag = false;\n         loop {\n-            try!(self.noteof(\"expected non-empty set of flags or closing ')'\"))\n+            try!(self.noteof(\n+                    \"expected non-empty set of flags or closing ')'\"));\n             match self.cur() {\n                 'i' => { flags = flags | FLAG_NOCASE;     saw_flag = true},\n                 'm' => { flags = flags | FLAG_MULTI;      saw_flag = true},\n@@ -823,7 +825,7 @@ impl<'a> Parser<'a> {\n     // If it is, then the next character is consumed.\n     fn get_next_greedy(&mut self) -> Result<Greed, Error> {\n         Ok(if self.peek_is(1, '?') {\n-            try!(self.expect('?'))\n+            try!(self.expect('?'));\n             Ungreedy\n         } else {\n             Greedy"}, {"sha": "0c204f759e6adb7b99f0951ac03db70c8c51359a", "filename": "src/libregex/test/bench.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibregex%2Ftest%2Fbench.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibregex%2Ftest%2Fbench.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Ftest%2Fbench.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -137,7 +137,7 @@ fn one_pass_long_prefix_not(b: &mut Bencher) {\n     b.iter(|| re.is_match(text));\n }\n \n-macro_rules! throughput(\n+macro_rules! throughput {\n     ($name:ident, $regex:expr, $size:expr) => (\n         #[bench]\n         fn $name(b: &mut Bencher) {\n@@ -146,7 +146,7 @@ macro_rules! throughput(\n             b.iter(|| if $regex.is_match(text.as_slice()) { panic!(\"match\") });\n         }\n     );\n-)\n+}\n \n fn easy0() -> Regex { regex!(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ$\") }\n fn easy1() -> Regex { regex!(\"A[AB]B[BC]C[CD]D[DE]E[EF]F[FG]G[GH]H[HI]I[IJ]J$\") }\n@@ -165,18 +165,18 @@ fn gen_text(n: uint) -> String {\n     String::from_utf8(bytes).unwrap()\n }\n \n-throughput!(easy0_32, easy0(), 32)\n-throughput!(easy0_1K, easy0(), 1<<10)\n-throughput!(easy0_32K, easy0(), 32<<10)\n+throughput!{easy0_32, easy0(), 32}\n+throughput!{easy0_1K, easy0(), 1<<10}\n+throughput!{easy0_32K, easy0(), 32<<10}\n \n-throughput!(easy1_32, easy1(), 32)\n-throughput!(easy1_1K, easy1(), 1<<10)\n-throughput!(easy1_32K, easy1(), 32<<10)\n+throughput!{easy1_32, easy1(), 32}\n+throughput!{easy1_1K, easy1(), 1<<10}\n+throughput!{easy1_32K, easy1(), 32<<10}\n \n-throughput!(medium_32, medium(), 32)\n-throughput!(medium_1K, medium(), 1<<10)\n-throughput!(medium_32K,medium(), 32<<10)\n+throughput!{medium_32, medium(), 32}\n+throughput!{medium_1K, medium(), 1<<10}\n+throughput!{medium_32K,medium(), 32<<10}\n \n-throughput!(hard_32, hard(), 32)\n-throughput!(hard_1K, hard(), 1<<10)\n-throughput!(hard_32K,hard(), 32<<10)\n+throughput!{hard_32, hard(), 32}\n+throughput!{hard_1K, hard(), 1<<10}\n+throughput!{hard_32K,hard(), 32<<10}"}, {"sha": "7508f4c50a2c313ff373fee34e22901c9565e005", "filename": "src/libregex/test/matches.rs", "status": "modified", "additions": 349, "deletions": 349, "changes": 698, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibregex%2Ftest%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibregex%2Ftest%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Ftest%2Fmatches.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -14,360 +14,360 @@\n // on 2014-04-23 01:33:36.539280.\n \n // Tests from basic.dat\n-mat!(match_basic_3, r\"abracadabra$\", r\"abracadabracadabra\", Some((7, 18)))\n-mat!(match_basic_4, r\"a...b\", r\"abababbb\", Some((2, 7)))\n-mat!(match_basic_5, r\"XXXXXX\", r\"..XXXXXX\", Some((2, 8)))\n-mat!(match_basic_6, r\"\\)\", r\"()\", Some((1, 2)))\n-mat!(match_basic_7, r\"a]\", r\"a]a\", Some((0, 2)))\n-mat!(match_basic_9, r\"\\}\", r\"}\", Some((0, 1)))\n-mat!(match_basic_10, r\"\\]\", r\"]\", Some((0, 1)))\n-mat!(match_basic_12, r\"]\", r\"]\", Some((0, 1)))\n-mat!(match_basic_15, r\"^a\", r\"ax\", Some((0, 1)))\n-mat!(match_basic_16, r\"\\^a\", r\"a^a\", Some((1, 3)))\n-mat!(match_basic_17, r\"a\\^\", r\"a^\", Some((0, 2)))\n-mat!(match_basic_18, r\"a$\", r\"aa\", Some((1, 2)))\n-mat!(match_basic_19, r\"a\\$\", r\"a$\", Some((0, 2)))\n-mat!(match_basic_20, r\"^$\", r\"\", Some((0, 0)))\n-mat!(match_basic_21, r\"$^\", r\"\", Some((0, 0)))\n-mat!(match_basic_22, r\"a($)\", r\"aa\", Some((1, 2)), Some((2, 2)))\n-mat!(match_basic_23, r\"a*(^a)\", r\"aa\", Some((0, 1)), Some((0, 1)))\n-mat!(match_basic_24, r\"(..)*(...)*\", r\"a\", Some((0, 0)))\n-mat!(match_basic_25, r\"(..)*(...)*\", r\"abcd\", Some((0, 4)), Some((2, 4)))\n-mat!(match_basic_26, r\"(ab|a)(bc|c)\", r\"abc\", Some((0, 3)), Some((0, 2)), Some((2, 3)))\n-mat!(match_basic_27, r\"(ab)c|abc\", r\"abc\", Some((0, 3)), Some((0, 2)))\n-mat!(match_basic_28, r\"a{0}b\", r\"ab\", Some((1, 2)))\n-mat!(match_basic_29, r\"(a*)(b?)(b+)b{3}\", r\"aaabbbbbbb\", Some((0, 10)), Some((0, 3)), Some((3, 4)), Some((4, 7)))\n-mat!(match_basic_30, r\"(a*)(b{0,1})(b{1,})b{3}\", r\"aaabbbbbbb\", Some((0, 10)), Some((0, 3)), Some((3, 4)), Some((4, 7)))\n-mat!(match_basic_32, r\"((a|a)|a)\", r\"a\", Some((0, 1)), Some((0, 1)), Some((0, 1)))\n-mat!(match_basic_33, r\"(a*)(a|aa)\", r\"aaaa\", Some((0, 4)), Some((0, 3)), Some((3, 4)))\n-mat!(match_basic_34, r\"a*(a.|aa)\", r\"aaaa\", Some((0, 4)), Some((2, 4)))\n-mat!(match_basic_35, r\"a(b)|c(d)|a(e)f\", r\"aef\", Some((0, 3)), None, None, Some((1, 2)))\n-mat!(match_basic_36, r\"(a|b)?.*\", r\"b\", Some((0, 1)), Some((0, 1)))\n-mat!(match_basic_37, r\"(a|b)c|a(b|c)\", r\"ac\", Some((0, 2)), Some((0, 1)))\n-mat!(match_basic_38, r\"(a|b)c|a(b|c)\", r\"ab\", Some((0, 2)), None, Some((1, 2)))\n-mat!(match_basic_39, r\"(a|b)*c|(a|ab)*c\", r\"abc\", Some((0, 3)), Some((1, 2)))\n-mat!(match_basic_40, r\"(a|b)*c|(a|ab)*c\", r\"xc\", Some((1, 2)))\n-mat!(match_basic_41, r\"(.a|.b).*|.*(.a|.b)\", r\"xa\", Some((0, 2)), Some((0, 2)))\n-mat!(match_basic_42, r\"a?(ab|ba)ab\", r\"abab\", Some((0, 4)), Some((0, 2)))\n-mat!(match_basic_43, r\"a?(ac{0}b|ba)ab\", r\"abab\", Some((0, 4)), Some((0, 2)))\n-mat!(match_basic_44, r\"ab|abab\", r\"abbabab\", Some((0, 2)))\n-mat!(match_basic_45, r\"aba|bab|bba\", r\"baaabbbaba\", Some((5, 8)))\n-mat!(match_basic_46, r\"aba|bab\", r\"baaabbbaba\", Some((6, 9)))\n-mat!(match_basic_47, r\"(aa|aaa)*|(a|aaaaa)\", r\"aa\", Some((0, 2)), Some((0, 2)))\n-mat!(match_basic_48, r\"(a.|.a.)*|(a|.a...)\", r\"aa\", Some((0, 2)), Some((0, 2)))\n-mat!(match_basic_49, r\"ab|a\", r\"xabc\", Some((1, 3)))\n-mat!(match_basic_50, r\"ab|a\", r\"xxabc\", Some((2, 4)))\n-mat!(match_basic_51, r\"(?i)(Ab|cD)*\", r\"aBcD\", Some((0, 4)), Some((2, 4)))\n-mat!(match_basic_52, r\"[^-]\", r\"--a\", Some((2, 3)))\n-mat!(match_basic_53, r\"[a-]*\", r\"--a\", Some((0, 3)))\n-mat!(match_basic_54, r\"[a-m-]*\", r\"--amoma--\", Some((0, 4)))\n-mat!(match_basic_55, r\":::1:::0:|:::1:1:0:\", r\":::0:::1:::1:::0:\", Some((8, 17)))\n-mat!(match_basic_56, r\":::1:::0:|:::1:1:1:\", r\":::0:::1:::1:::0:\", Some((8, 17)))\n-mat!(match_basic_57, r\"[[:upper:]]\", r\"A\", Some((0, 1)))\n-mat!(match_basic_58, r\"[[:lower:]]+\", r\"`az{\", Some((1, 3)))\n-mat!(match_basic_59, r\"[[:upper:]]+\", r\"@AZ[\", Some((1, 3)))\n-mat!(match_basic_65, r\"\n+mat!{match_basic_3, r\"abracadabra$\", r\"abracadabracadabra\", Some((7, 18))}\n+mat!{match_basic_4, r\"a...b\", r\"abababbb\", Some((2, 7))}\n+mat!{match_basic_5, r\"XXXXXX\", r\"..XXXXXX\", Some((2, 8))}\n+mat!{match_basic_6, r\"\\)\", r\"()\", Some((1, 2))}\n+mat!{match_basic_7, r\"a]\", r\"a]a\", Some((0, 2))}\n+mat!{match_basic_9, r\"\\}\", r\"}\", Some((0, 1))}\n+mat!{match_basic_10, r\"\\]\", r\"]\", Some((0, 1))}\n+mat!{match_basic_12, r\"]\", r\"]\", Some((0, 1))}\n+mat!{match_basic_15, r\"^a\", r\"ax\", Some((0, 1))}\n+mat!{match_basic_16, r\"\\^a\", r\"a^a\", Some((1, 3))}\n+mat!{match_basic_17, r\"a\\^\", r\"a^\", Some((0, 2))}\n+mat!{match_basic_18, r\"a$\", r\"aa\", Some((1, 2))}\n+mat!{match_basic_19, r\"a\\$\", r\"a$\", Some((0, 2))}\n+mat!{match_basic_20, r\"^$\", r\"\", Some((0, 0))}\n+mat!{match_basic_21, r\"$^\", r\"\", Some((0, 0))}\n+mat!{match_basic_22, r\"a($)\", r\"aa\", Some((1, 2)), Some((2, 2))}\n+mat!{match_basic_23, r\"a*(^a)\", r\"aa\", Some((0, 1)), Some((0, 1))}\n+mat!{match_basic_24, r\"(..)*(...)*\", r\"a\", Some((0, 0))}\n+mat!{match_basic_25, r\"(..)*(...)*\", r\"abcd\", Some((0, 4)), Some((2, 4))}\n+mat!{match_basic_26, r\"(ab|a)(bc|c)\", r\"abc\", Some((0, 3)), Some((0, 2)), Some((2, 3))}\n+mat!{match_basic_27, r\"(ab)c|abc\", r\"abc\", Some((0, 3)), Some((0, 2))}\n+mat!{match_basic_28, r\"a{0}b\", r\"ab\", Some((1, 2))}\n+mat!{match_basic_29, r\"(a*)(b?)(b+)b{3}\", r\"aaabbbbbbb\", Some((0, 10)), Some((0, 3)), Some((3, 4)), Some((4, 7))}\n+mat!{match_basic_30, r\"(a*)(b{0,1})(b{1,})b{3}\", r\"aaabbbbbbb\", Some((0, 10)), Some((0, 3)), Some((3, 4)), Some((4, 7))}\n+mat!{match_basic_32, r\"((a|a)|a)\", r\"a\", Some((0, 1)), Some((0, 1)), Some((0, 1))}\n+mat!{match_basic_33, r\"(a*)(a|aa)\", r\"aaaa\", Some((0, 4)), Some((0, 3)), Some((3, 4))}\n+mat!{match_basic_34, r\"a*(a.|aa)\", r\"aaaa\", Some((0, 4)), Some((2, 4))}\n+mat!{match_basic_35, r\"a(b)|c(d)|a(e)f\", r\"aef\", Some((0, 3)), None, None, Some((1, 2))}\n+mat!{match_basic_36, r\"(a|b)?.*\", r\"b\", Some((0, 1)), Some((0, 1))}\n+mat!{match_basic_37, r\"(a|b)c|a(b|c)\", r\"ac\", Some((0, 2)), Some((0, 1))}\n+mat!{match_basic_38, r\"(a|b)c|a(b|c)\", r\"ab\", Some((0, 2)), None, Some((1, 2))}\n+mat!{match_basic_39, r\"(a|b)*c|(a|ab)*c\", r\"abc\", Some((0, 3)), Some((1, 2))}\n+mat!{match_basic_40, r\"(a|b)*c|(a|ab)*c\", r\"xc\", Some((1, 2))}\n+mat!{match_basic_41, r\"(.a|.b).*|.*(.a|.b)\", r\"xa\", Some((0, 2)), Some((0, 2))}\n+mat!{match_basic_42, r\"a?(ab|ba)ab\", r\"abab\", Some((0, 4)), Some((0, 2))}\n+mat!{match_basic_43, r\"a?(ac{0}b|ba)ab\", r\"abab\", Some((0, 4)), Some((0, 2))}\n+mat!{match_basic_44, r\"ab|abab\", r\"abbabab\", Some((0, 2))}\n+mat!{match_basic_45, r\"aba|bab|bba\", r\"baaabbbaba\", Some((5, 8))}\n+mat!{match_basic_46, r\"aba|bab\", r\"baaabbbaba\", Some((6, 9))}\n+mat!{match_basic_47, r\"(aa|aaa)*|(a|aaaaa)\", r\"aa\", Some((0, 2)), Some((0, 2))}\n+mat!{match_basic_48, r\"(a.|.a.)*|(a|.a...)\", r\"aa\", Some((0, 2)), Some((0, 2))}\n+mat!{match_basic_49, r\"ab|a\", r\"xabc\", Some((1, 3))}\n+mat!{match_basic_50, r\"ab|a\", r\"xxabc\", Some((2, 4))}\n+mat!{match_basic_51, r\"(?i)(Ab|cD)*\", r\"aBcD\", Some((0, 4)), Some((2, 4))}\n+mat!{match_basic_52, r\"[^-]\", r\"--a\", Some((2, 3))}\n+mat!{match_basic_53, r\"[a-]*\", r\"--a\", Some((0, 3))}\n+mat!{match_basic_54, r\"[a-m-]*\", r\"--amoma--\", Some((0, 4))}\n+mat!{match_basic_55, r\":::1:::0:|:::1:1:0:\", r\":::0:::1:::1:::0:\", Some((8, 17))}\n+mat!{match_basic_56, r\":::1:::0:|:::1:1:1:\", r\":::0:::1:::1:::0:\", Some((8, 17))}\n+mat!{match_basic_57, r\"[[:upper:]]\", r\"A\", Some((0, 1))}\n+mat!{match_basic_58, r\"[[:lower:]]+\", r\"`az{\", Some((1, 3))}\n+mat!{match_basic_59, r\"[[:upper:]]+\", r\"@AZ[\", Some((1, 3))}\n+mat!{match_basic_65, r\"\n \", r\"\n-\", Some((0, 1)))\n-mat!(match_basic_66, r\"\n+\", Some((0, 1))}\n+mat!{match_basic_66, r\"\n \", r\"\n-\", Some((0, 1)))\n-mat!(match_basic_67, r\"[^a]\", r\"\n-\", Some((0, 1)))\n-mat!(match_basic_68, r\"\n+\", Some((0, 1))}\n+mat!{match_basic_67, r\"[^a]\", r\"\n+\", Some((0, 1))}\n+mat!{match_basic_68, r\"\n a\", r\"\n-a\", Some((0, 2)))\n-mat!(match_basic_69, r\"(a)(b)(c)\", r\"abc\", Some((0, 3)), Some((0, 1)), Some((1, 2)), Some((2, 3)))\n-mat!(match_basic_70, r\"xxx\", r\"xxx\", Some((0, 3)))\n-mat!(match_basic_71, r\"(^|[ (,;])((([Ff]eb[^ ]* *|0*2/|\\* */?)0*[6-7]))([^0-9]|$)\", r\"feb 6,\", Some((0, 6)))\n-mat!(match_basic_72, r\"(^|[ (,;])((([Ff]eb[^ ]* *|0*2/|\\* */?)0*[6-7]))([^0-9]|$)\", r\"2/7\", Some((0, 3)))\n-mat!(match_basic_73, r\"(^|[ (,;])((([Ff]eb[^ ]* *|0*2/|\\* */?)0*[6-7]))([^0-9]|$)\", r\"feb 1,Feb 6\", Some((5, 11)))\n-mat!(match_basic_74, r\"((((((((((((((((((((((((((((((x))))))))))))))))))))))))))))))\", r\"x\", Some((0, 1)), Some((0, 1)), Some((0, 1)))\n-mat!(match_basic_75, r\"((((((((((((((((((((((((((((((x))))))))))))))))))))))))))))))*\", r\"xx\", Some((0, 2)), Some((1, 2)), Some((1, 2)))\n-mat!(match_basic_76, r\"a?(ab|ba)*\", r\"ababababababababababababababababababababababababababababababababababababababababa\", Some((0, 81)), Some((79, 81)))\n-mat!(match_basic_77, r\"abaa|abbaa|abbbaa|abbbbaa\", r\"ababbabbbabbbabbbbabbbbaa\", Some((18, 25)))\n-mat!(match_basic_78, r\"abaa|abbaa|abbbaa|abbbbaa\", r\"ababbabbbabbbabbbbabaa\", Some((18, 22)))\n-mat!(match_basic_79, r\"aaac|aabc|abac|abbc|baac|babc|bbac|bbbc\", r\"baaabbbabac\", Some((7, 11)))\n-mat!(match_basic_80, r\".*\", r\"\u0001\u007f\", Some((0, 2)))\n-mat!(match_basic_81, r\"aaaa|bbbb|cccc|ddddd|eeeeee|fffffff|gggg|hhhh|iiiii|jjjjj|kkkkk|llll\", r\"XaaaXbbbXcccXdddXeeeXfffXgggXhhhXiiiXjjjXkkkXlllXcbaXaaaa\", Some((53, 57)))\n-mat!(match_basic_83, r\"a*a*a*a*a*b\", r\"aaaaaaaaab\", Some((0, 10)))\n-mat!(match_basic_84, r\"^\", r\"\", Some((0, 0)))\n-mat!(match_basic_85, r\"$\", r\"\", Some((0, 0)))\n-mat!(match_basic_86, r\"^$\", r\"\", Some((0, 0)))\n-mat!(match_basic_87, r\"^a$\", r\"a\", Some((0, 1)))\n-mat!(match_basic_88, r\"abc\", r\"abc\", Some((0, 3)))\n-mat!(match_basic_89, r\"abc\", r\"xabcy\", Some((1, 4)))\n-mat!(match_basic_90, r\"abc\", r\"ababc\", Some((2, 5)))\n-mat!(match_basic_91, r\"ab*c\", r\"abc\", Some((0, 3)))\n-mat!(match_basic_92, r\"ab*bc\", r\"abc\", Some((0, 3)))\n-mat!(match_basic_93, r\"ab*bc\", r\"abbc\", Some((0, 4)))\n-mat!(match_basic_94, r\"ab*bc\", r\"abbbbc\", Some((0, 6)))\n-mat!(match_basic_95, r\"ab+bc\", r\"abbc\", Some((0, 4)))\n-mat!(match_basic_96, r\"ab+bc\", r\"abbbbc\", Some((0, 6)))\n-mat!(match_basic_97, r\"ab?bc\", r\"abbc\", Some((0, 4)))\n-mat!(match_basic_98, r\"ab?bc\", r\"abc\", Some((0, 3)))\n-mat!(match_basic_99, r\"ab?c\", r\"abc\", Some((0, 3)))\n-mat!(match_basic_100, r\"^abc$\", r\"abc\", Some((0, 3)))\n-mat!(match_basic_101, r\"^abc\", r\"abcc\", Some((0, 3)))\n-mat!(match_basic_102, r\"abc$\", r\"aabc\", Some((1, 4)))\n-mat!(match_basic_103, r\"^\", r\"abc\", Some((0, 0)))\n-mat!(match_basic_104, r\"$\", r\"abc\", Some((3, 3)))\n-mat!(match_basic_105, r\"a.c\", r\"abc\", Some((0, 3)))\n-mat!(match_basic_106, r\"a.c\", r\"axc\", Some((0, 3)))\n-mat!(match_basic_107, r\"a.*c\", r\"axyzc\", Some((0, 5)))\n-mat!(match_basic_108, r\"a[bc]d\", r\"abd\", Some((0, 3)))\n-mat!(match_basic_109, r\"a[b-d]e\", r\"ace\", Some((0, 3)))\n-mat!(match_basic_110, r\"a[b-d]\", r\"aac\", Some((1, 3)))\n-mat!(match_basic_111, r\"a[-b]\", r\"a-\", Some((0, 2)))\n-mat!(match_basic_112, r\"a[b-]\", r\"a-\", Some((0, 2)))\n-mat!(match_basic_113, r\"a]\", r\"a]\", Some((0, 2)))\n-mat!(match_basic_114, r\"a[]]b\", r\"a]b\", Some((0, 3)))\n-mat!(match_basic_115, r\"a[^bc]d\", r\"aed\", Some((0, 3)))\n-mat!(match_basic_116, r\"a[^-b]c\", r\"adc\", Some((0, 3)))\n-mat!(match_basic_117, r\"a[^]b]c\", r\"adc\", Some((0, 3)))\n-mat!(match_basic_118, r\"ab|cd\", r\"abc\", Some((0, 2)))\n-mat!(match_basic_119, r\"ab|cd\", r\"abcd\", Some((0, 2)))\n-mat!(match_basic_120, r\"a\\(b\", r\"a(b\", Some((0, 3)))\n-mat!(match_basic_121, r\"a\\(*b\", r\"ab\", Some((0, 2)))\n-mat!(match_basic_122, r\"a\\(*b\", r\"a((b\", Some((0, 4)))\n-mat!(match_basic_123, r\"((a))\", r\"abc\", Some((0, 1)), Some((0, 1)), Some((0, 1)))\n-mat!(match_basic_124, r\"(a)b(c)\", r\"abc\", Some((0, 3)), Some((0, 1)), Some((2, 3)))\n-mat!(match_basic_125, r\"a+b+c\", r\"aabbabc\", Some((4, 7)))\n-mat!(match_basic_126, r\"a*\", r\"aaa\", Some((0, 3)))\n-mat!(match_basic_128, r\"(a*)*\", r\"-\", Some((0, 0)), None)\n-mat!(match_basic_129, r\"(a*)+\", r\"-\", Some((0, 0)), Some((0, 0)))\n-mat!(match_basic_131, r\"(a*|b)*\", r\"-\", Some((0, 0)), None)\n-mat!(match_basic_132, r\"(a+|b)*\", r\"ab\", Some((0, 2)), Some((1, 2)))\n-mat!(match_basic_133, r\"(a+|b)+\", r\"ab\", Some((0, 2)), Some((1, 2)))\n-mat!(match_basic_134, r\"(a+|b)?\", r\"ab\", Some((0, 1)), Some((0, 1)))\n-mat!(match_basic_135, r\"[^ab]*\", r\"cde\", Some((0, 3)))\n-mat!(match_basic_137, r\"(^)*\", r\"-\", Some((0, 0)), None)\n-mat!(match_basic_138, r\"a*\", r\"\", Some((0, 0)))\n-mat!(match_basic_139, r\"([abc])*d\", r\"abbbcd\", Some((0, 6)), Some((4, 5)))\n-mat!(match_basic_140, r\"([abc])*bcd\", r\"abcd\", Some((0, 4)), Some((0, 1)))\n-mat!(match_basic_141, r\"a|b|c|d|e\", r\"e\", Some((0, 1)))\n-mat!(match_basic_142, r\"(a|b|c|d|e)f\", r\"ef\", Some((0, 2)), Some((0, 1)))\n-mat!(match_basic_144, r\"((a*|b))*\", r\"-\", Some((0, 0)), None, None)\n-mat!(match_basic_145, r\"abcd*efg\", r\"abcdefg\", Some((0, 7)))\n-mat!(match_basic_146, r\"ab*\", r\"xabyabbbz\", Some((1, 3)))\n-mat!(match_basic_147, r\"ab*\", r\"xayabbbz\", Some((1, 2)))\n-mat!(match_basic_148, r\"(ab|cd)e\", r\"abcde\", Some((2, 5)), Some((2, 4)))\n-mat!(match_basic_149, r\"[abhgefdc]ij\", r\"hij\", Some((0, 3)))\n-mat!(match_basic_150, r\"(a|b)c*d\", r\"abcd\", Some((1, 4)), Some((1, 2)))\n-mat!(match_basic_151, r\"(ab|ab*)bc\", r\"abc\", Some((0, 3)), Some((0, 1)))\n-mat!(match_basic_152, r\"a([bc]*)c*\", r\"abc\", Some((0, 3)), Some((1, 3)))\n-mat!(match_basic_153, r\"a([bc]*)(c*d)\", r\"abcd\", Some((0, 4)), Some((1, 3)), Some((3, 4)))\n-mat!(match_basic_154, r\"a([bc]+)(c*d)\", r\"abcd\", Some((0, 4)), Some((1, 3)), Some((3, 4)))\n-mat!(match_basic_155, r\"a([bc]*)(c+d)\", r\"abcd\", Some((0, 4)), Some((1, 2)), Some((2, 4)))\n-mat!(match_basic_156, r\"a[bcd]*dcdcde\", r\"adcdcde\", Some((0, 7)))\n-mat!(match_basic_157, r\"(ab|a)b*c\", r\"abc\", Some((0, 3)), Some((0, 2)))\n-mat!(match_basic_158, r\"((a)(b)c)(d)\", r\"abcd\", Some((0, 4)), Some((0, 3)), Some((0, 1)), Some((1, 2)), Some((3, 4)))\n-mat!(match_basic_159, r\"[A-Za-z_][A-Za-z0-9_]*\", r\"alpha\", Some((0, 5)))\n-mat!(match_basic_160, r\"^a(bc+|b[eh])g|.h$\", r\"abh\", Some((1, 3)))\n-mat!(match_basic_161, r\"(bc+d$|ef*g.|h?i(j|k))\", r\"effgz\", Some((0, 5)), Some((0, 5)))\n-mat!(match_basic_162, r\"(bc+d$|ef*g.|h?i(j|k))\", r\"ij\", Some((0, 2)), Some((0, 2)), Some((1, 2)))\n-mat!(match_basic_163, r\"(bc+d$|ef*g.|h?i(j|k))\", r\"reffgz\", Some((1, 6)), Some((1, 6)))\n-mat!(match_basic_164, r\"(((((((((a)))))))))\", r\"a\", Some((0, 1)), Some((0, 1)), Some((0, 1)), Some((0, 1)), Some((0, 1)), Some((0, 1)), Some((0, 1)), Some((0, 1)), Some((0, 1)), Some((0, 1)))\n-mat!(match_basic_165, r\"multiple words\", r\"multiple words yeah\", Some((0, 14)))\n-mat!(match_basic_166, r\"(.*)c(.*)\", r\"abcde\", Some((0, 5)), Some((0, 2)), Some((3, 5)))\n-mat!(match_basic_167, r\"abcd\", r\"abcd\", Some((0, 4)))\n-mat!(match_basic_168, r\"a(bc)d\", r\"abcd\", Some((0, 4)), Some((1, 3)))\n-mat!(match_basic_169, r\"a[\u0001-\u0003]?c\", r\"a\u0002c\", Some((0, 3)))\n-mat!(match_basic_170, r\"M[ou]'?am+[ae]r .*([AEae]l[- ])?[GKQ]h?[aeu]+([dtz][dhz]?)+af[iy]\", r\"Muammar Qaddafi\", Some((0, 15)), None, Some((10, 12)))\n-mat!(match_basic_171, r\"M[ou]'?am+[ae]r .*([AEae]l[- ])?[GKQ]h?[aeu]+([dtz][dhz]?)+af[iy]\", r\"Mo'ammar Gadhafi\", Some((0, 16)), None, Some((11, 13)))\n-mat!(match_basic_172, r\"M[ou]'?am+[ae]r .*([AEae]l[- ])?[GKQ]h?[aeu]+([dtz][dhz]?)+af[iy]\", r\"Muammar Kaddafi\", Some((0, 15)), None, Some((10, 12)))\n-mat!(match_basic_173, r\"M[ou]'?am+[ae]r .*([AEae]l[- ])?[GKQ]h?[aeu]+([dtz][dhz]?)+af[iy]\", r\"Muammar Qadhafi\", Some((0, 15)), None, Some((10, 12)))\n-mat!(match_basic_174, r\"M[ou]'?am+[ae]r .*([AEae]l[- ])?[GKQ]h?[aeu]+([dtz][dhz]?)+af[iy]\", r\"Muammar Gadafi\", Some((0, 14)), None, Some((10, 11)))\n-mat!(match_basic_175, r\"M[ou]'?am+[ae]r .*([AEae]l[- ])?[GKQ]h?[aeu]+([dtz][dhz]?)+af[iy]\", r\"Mu'ammar Qadafi\", Some((0, 15)), None, Some((11, 12)))\n-mat!(match_basic_176, r\"M[ou]'?am+[ae]r .*([AEae]l[- ])?[GKQ]h?[aeu]+([dtz][dhz]?)+af[iy]\", r\"Moamar Gaddafi\", Some((0, 14)), None, Some((9, 11)))\n-mat!(match_basic_177, r\"M[ou]'?am+[ae]r .*([AEae]l[- ])?[GKQ]h?[aeu]+([dtz][dhz]?)+af[iy]\", r\"Mu'ammar Qadhdhafi\", Some((0, 18)), None, Some((13, 15)))\n-mat!(match_basic_178, r\"M[ou]'?am+[ae]r .*([AEae]l[- ])?[GKQ]h?[aeu]+([dtz][dhz]?)+af[iy]\", r\"Muammar Khaddafi\", Some((0, 16)), None, Some((11, 13)))\n-mat!(match_basic_179, r\"M[ou]'?am+[ae]r .*([AEae]l[- ])?[GKQ]h?[aeu]+([dtz][dhz]?)+af[iy]\", r\"Muammar Ghaddafy\", Some((0, 16)), None, Some((11, 13)))\n-mat!(match_basic_180, r\"M[ou]'?am+[ae]r .*([AEae]l[- ])?[GKQ]h?[aeu]+([dtz][dhz]?)+af[iy]\", r\"Muammar Ghadafi\", Some((0, 15)), None, Some((11, 12)))\n-mat!(match_basic_181, r\"M[ou]'?am+[ae]r .*([AEae]l[- ])?[GKQ]h?[aeu]+([dtz][dhz]?)+af[iy]\", r\"Muammar Ghaddafi\", Some((0, 16)), None, Some((11, 13)))\n-mat!(match_basic_182, r\"M[ou]'?am+[ae]r .*([AEae]l[- ])?[GKQ]h?[aeu]+([dtz][dhz]?)+af[iy]\", r\"Muamar Kaddafi\", Some((0, 14)), None, Some((9, 11)))\n-mat!(match_basic_183, r\"M[ou]'?am+[ae]r .*([AEae]l[- ])?[GKQ]h?[aeu]+([dtz][dhz]?)+af[iy]\", r\"Muammar Quathafi\", Some((0, 16)), None, Some((11, 13)))\n-mat!(match_basic_184, r\"M[ou]'?am+[ae]r .*([AEae]l[- ])?[GKQ]h?[aeu]+([dtz][dhz]?)+af[iy]\", r\"Muammar Gheddafi\", Some((0, 16)), None, Some((11, 13)))\n-mat!(match_basic_185, r\"M[ou]'?am+[ae]r .*([AEae]l[- ])?[GKQ]h?[aeu]+([dtz][dhz]?)+af[iy]\", r\"Moammar Khadafy\", Some((0, 15)), None, Some((11, 12)))\n-mat!(match_basic_186, r\"M[ou]'?am+[ae]r .*([AEae]l[- ])?[GKQ]h?[aeu]+([dtz][dhz]?)+af[iy]\", r\"Moammar Qudhafi\", Some((0, 15)), None, Some((10, 12)))\n-mat!(match_basic_187, r\"a+(b|c)*d+\", r\"aabcdd\", Some((0, 6)), Some((3, 4)))\n-mat!(match_basic_188, r\"^.+$\", r\"vivi\", Some((0, 4)))\n-mat!(match_basic_189, r\"^(.+)$\", r\"vivi\", Some((0, 4)), Some((0, 4)))\n-mat!(match_basic_190, r\"^([^!.]+).att.com!(.+)$\", r\"gryphon.att.com!eby\", Some((0, 19)), Some((0, 7)), Some((16, 19)))\n-mat!(match_basic_191, r\"^([^!]+!)?([^!]+)$\", r\"bas\", Some((0, 3)), None, Some((0, 3)))\n-mat!(match_basic_192, r\"^([^!]+!)?([^!]+)$\", r\"bar!bas\", Some((0, 7)), Some((0, 4)), Some((4, 7)))\n-mat!(match_basic_193, r\"^([^!]+!)?([^!]+)$\", r\"foo!bas\", Some((0, 7)), Some((0, 4)), Some((4, 7)))\n-mat!(match_basic_194, r\"^.+!([^!]+!)([^!]+)$\", r\"foo!bar!bas\", Some((0, 11)), Some((4, 8)), Some((8, 11)))\n-mat!(match_basic_195, r\"((foo)|(bar))!bas\", r\"bar!bas\", Some((0, 7)), Some((0, 3)), None, Some((0, 3)))\n-mat!(match_basic_196, r\"((foo)|(bar))!bas\", r\"foo!bar!bas\", Some((4, 11)), Some((4, 7)), None, Some((4, 7)))\n-mat!(match_basic_197, r\"((foo)|(bar))!bas\", r\"foo!bas\", Some((0, 7)), Some((0, 3)), Some((0, 3)))\n-mat!(match_basic_198, r\"((foo)|bar)!bas\", r\"bar!bas\", Some((0, 7)), Some((0, 3)))\n-mat!(match_basic_199, r\"((foo)|bar)!bas\", r\"foo!bar!bas\", Some((4, 11)), Some((4, 7)))\n-mat!(match_basic_200, r\"((foo)|bar)!bas\", r\"foo!bas\", Some((0, 7)), Some((0, 3)), Some((0, 3)))\n-mat!(match_basic_201, r\"(foo|(bar))!bas\", r\"bar!bas\", Some((0, 7)), Some((0, 3)), Some((0, 3)))\n-mat!(match_basic_202, r\"(foo|(bar))!bas\", r\"foo!bar!bas\", Some((4, 11)), Some((4, 7)), Some((4, 7)))\n-mat!(match_basic_203, r\"(foo|(bar))!bas\", r\"foo!bas\", Some((0, 7)), Some((0, 3)))\n-mat!(match_basic_204, r\"(foo|bar)!bas\", r\"bar!bas\", Some((0, 7)), Some((0, 3)))\n-mat!(match_basic_205, r\"(foo|bar)!bas\", r\"foo!bar!bas\", Some((4, 11)), Some((4, 7)))\n-mat!(match_basic_206, r\"(foo|bar)!bas\", r\"foo!bas\", Some((0, 7)), Some((0, 3)))\n-mat!(match_basic_207, r\"^(([^!]+!)?([^!]+)|.+!([^!]+!)([^!]+))$\", r\"foo!bar!bas\", Some((0, 11)), Some((0, 11)), None, None, Some((4, 8)), Some((8, 11)))\n-mat!(match_basic_208, r\"^([^!]+!)?([^!]+)$|^.+!([^!]+!)([^!]+)$\", r\"bas\", Some((0, 3)), None, Some((0, 3)))\n-mat!(match_basic_209, r\"^([^!]+!)?([^!]+)$|^.+!([^!]+!)([^!]+)$\", r\"bar!bas\", Some((0, 7)), Some((0, 4)), Some((4, 7)))\n-mat!(match_basic_210, r\"^([^!]+!)?([^!]+)$|^.+!([^!]+!)([^!]+)$\", r\"foo!bar!bas\", Some((0, 11)), None, None, Some((4, 8)), Some((8, 11)))\n-mat!(match_basic_211, r\"^([^!]+!)?([^!]+)$|^.+!([^!]+!)([^!]+)$\", r\"foo!bas\", Some((0, 7)), Some((0, 4)), Some((4, 7)))\n-mat!(match_basic_212, r\"^(([^!]+!)?([^!]+)|.+!([^!]+!)([^!]+))$\", r\"bas\", Some((0, 3)), Some((0, 3)), None, Some((0, 3)))\n-mat!(match_basic_213, r\"^(([^!]+!)?([^!]+)|.+!([^!]+!)([^!]+))$\", r\"bar!bas\", Some((0, 7)), Some((0, 7)), Some((0, 4)), Some((4, 7)))\n-mat!(match_basic_214, r\"^(([^!]+!)?([^!]+)|.+!([^!]+!)([^!]+))$\", r\"foo!bar!bas\", Some((0, 11)), Some((0, 11)), None, None, Some((4, 8)), Some((8, 11)))\n-mat!(match_basic_215, r\"^(([^!]+!)?([^!]+)|.+!([^!]+!)([^!]+))$\", r\"foo!bas\", Some((0, 7)), Some((0, 7)), Some((0, 4)), Some((4, 7)))\n-mat!(match_basic_216, r\".*(/XXX).*\", r\"/XXX\", Some((0, 4)), Some((0, 4)))\n-mat!(match_basic_217, r\".*(\\\\XXX).*\", r\"\\XXX\", Some((0, 4)), Some((0, 4)))\n-mat!(match_basic_218, r\"\\\\XXX\", r\"\\XXX\", Some((0, 4)))\n-mat!(match_basic_219, r\".*(/000).*\", r\"/000\", Some((0, 4)), Some((0, 4)))\n-mat!(match_basic_220, r\".*(\\\\000).*\", r\"\\000\", Some((0, 4)), Some((0, 4)))\n-mat!(match_basic_221, r\"\\\\000\", r\"\\000\", Some((0, 4)))\n+a\", Some((0, 2))}\n+mat!{match_basic_69, r\"(a)(b)(c)\", r\"abc\", Some((0, 3)), Some((0, 1)), Some((1, 2)), Some((2, 3))}\n+mat!{match_basic_70, r\"xxx\", r\"xxx\", Some((0, 3))}\n+mat!{match_basic_71, r\"(^|[ (,;])((([Ff]eb[^ ]* *|0*2/|\\* */?)0*[6-7]))([^0-9]|$)\", r\"feb 6,\", Some((0, 6))}\n+mat!{match_basic_72, r\"(^|[ (,;])((([Ff]eb[^ ]* *|0*2/|\\* */?)0*[6-7]))([^0-9]|$)\", r\"2/7\", Some((0, 3))}\n+mat!{match_basic_73, r\"(^|[ (,;])((([Ff]eb[^ ]* *|0*2/|\\* */?)0*[6-7]))([^0-9]|$)\", r\"feb 1,Feb 6\", Some((5, 11))}\n+mat!{match_basic_74, r\"((((((((((((((((((((((((((((((x))))))))))))))))))))))))))))))\", r\"x\", Some((0, 1)), Some((0, 1)), Some((0, 1))}\n+mat!{match_basic_75, r\"((((((((((((((((((((((((((((((x))))))))))))))))))))))))))))))*\", r\"xx\", Some((0, 2)), Some((1, 2)), Some((1, 2))}\n+mat!{match_basic_76, r\"a?(ab|ba)*\", r\"ababababababababababababababababababababababababababababababababababababababababa\", Some((0, 81)), Some((79, 81))}\n+mat!{match_basic_77, r\"abaa|abbaa|abbbaa|abbbbaa\", r\"ababbabbbabbbabbbbabbbbaa\", Some((18, 25))}\n+mat!{match_basic_78, r\"abaa|abbaa|abbbaa|abbbbaa\", r\"ababbabbbabbbabbbbabaa\", Some((18, 22))}\n+mat!{match_basic_79, r\"aaac|aabc|abac|abbc|baac|babc|bbac|bbbc\", r\"baaabbbabac\", Some((7, 11))}\n+mat!{match_basic_80, r\".*\", r\"\u0001\u007f\", Some((0, 2))}\n+mat!{match_basic_81, r\"aaaa|bbbb|cccc|ddddd|eeeeee|fffffff|gggg|hhhh|iiiii|jjjjj|kkkkk|llll\", r\"XaaaXbbbXcccXdddXeeeXfffXgggXhhhXiiiXjjjXkkkXlllXcbaXaaaa\", Some((53, 57))}\n+mat!{match_basic_83, r\"a*a*a*a*a*b\", r\"aaaaaaaaab\", Some((0, 10))}\n+mat!{match_basic_84, r\"^\", r\"\", Some((0, 0))}\n+mat!{match_basic_85, r\"$\", r\"\", Some((0, 0))}\n+mat!{match_basic_86, r\"^$\", r\"\", Some((0, 0))}\n+mat!{match_basic_87, r\"^a$\", r\"a\", Some((0, 1))}\n+mat!{match_basic_88, r\"abc\", r\"abc\", Some((0, 3))}\n+mat!{match_basic_89, r\"abc\", r\"xabcy\", Some((1, 4))}\n+mat!{match_basic_90, r\"abc\", r\"ababc\", Some((2, 5))}\n+mat!{match_basic_91, r\"ab*c\", r\"abc\", Some((0, 3))}\n+mat!{match_basic_92, r\"ab*bc\", r\"abc\", Some((0, 3))}\n+mat!{match_basic_93, r\"ab*bc\", r\"abbc\", Some((0, 4))}\n+mat!{match_basic_94, r\"ab*bc\", r\"abbbbc\", Some((0, 6))}\n+mat!{match_basic_95, r\"ab+bc\", r\"abbc\", Some((0, 4))}\n+mat!{match_basic_96, r\"ab+bc\", r\"abbbbc\", Some((0, 6))}\n+mat!{match_basic_97, r\"ab?bc\", r\"abbc\", Some((0, 4))}\n+mat!{match_basic_98, r\"ab?bc\", r\"abc\", Some((0, 3))}\n+mat!{match_basic_99, r\"ab?c\", r\"abc\", Some((0, 3))}\n+mat!{match_basic_100, r\"^abc$\", r\"abc\", Some((0, 3))}\n+mat!{match_basic_101, r\"^abc\", r\"abcc\", Some((0, 3))}\n+mat!{match_basic_102, r\"abc$\", r\"aabc\", Some((1, 4))}\n+mat!{match_basic_103, r\"^\", r\"abc\", Some((0, 0))}\n+mat!{match_basic_104, r\"$\", r\"abc\", Some((3, 3))}\n+mat!{match_basic_105, r\"a.c\", r\"abc\", Some((0, 3))}\n+mat!{match_basic_106, r\"a.c\", r\"axc\", Some((0, 3))}\n+mat!{match_basic_107, r\"a.*c\", r\"axyzc\", Some((0, 5))}\n+mat!{match_basic_108, r\"a[bc]d\", r\"abd\", Some((0, 3))}\n+mat!{match_basic_109, r\"a[b-d]e\", r\"ace\", Some((0, 3))}\n+mat!{match_basic_110, r\"a[b-d]\", r\"aac\", Some((1, 3))}\n+mat!{match_basic_111, r\"a[-b]\", r\"a-\", Some((0, 2))}\n+mat!{match_basic_112, r\"a[b-]\", r\"a-\", Some((0, 2))}\n+mat!{match_basic_113, r\"a]\", r\"a]\", Some((0, 2))}\n+mat!{match_basic_114, r\"a[]]b\", r\"a]b\", Some((0, 3))}\n+mat!{match_basic_115, r\"a[^bc]d\", r\"aed\", Some((0, 3))}\n+mat!{match_basic_116, r\"a[^-b]c\", r\"adc\", Some((0, 3))}\n+mat!{match_basic_117, r\"a[^]b]c\", r\"adc\", Some((0, 3))}\n+mat!{match_basic_118, r\"ab|cd\", r\"abc\", Some((0, 2))}\n+mat!{match_basic_119, r\"ab|cd\", r\"abcd\", Some((0, 2))}\n+mat!{match_basic_120, r\"a\\(b\", r\"a(b\", Some((0, 3))}\n+mat!{match_basic_121, r\"a\\(*b\", r\"ab\", Some((0, 2))}\n+mat!{match_basic_122, r\"a\\(*b\", r\"a((b\", Some((0, 4))}\n+mat!{match_basic_123, r\"((a))\", r\"abc\", Some((0, 1)), Some((0, 1)), Some((0, 1))}\n+mat!{match_basic_124, r\"(a)b(c)\", r\"abc\", Some((0, 3)), Some((0, 1)), Some((2, 3))}\n+mat!{match_basic_125, r\"a+b+c\", r\"aabbabc\", Some((4, 7))}\n+mat!{match_basic_126, r\"a*\", r\"aaa\", Some((0, 3))}\n+mat!{match_basic_128, r\"(a*)*\", r\"-\", Some((0, 0)), None}\n+mat!{match_basic_129, r\"(a*)+\", r\"-\", Some((0, 0)), Some((0, 0))}\n+mat!{match_basic_131, r\"(a*|b)*\", r\"-\", Some((0, 0)), None}\n+mat!{match_basic_132, r\"(a+|b)*\", r\"ab\", Some((0, 2)), Some((1, 2))}\n+mat!{match_basic_133, r\"(a+|b)+\", r\"ab\", Some((0, 2)), Some((1, 2))}\n+mat!{match_basic_134, r\"(a+|b)?\", r\"ab\", Some((0, 1)), Some((0, 1))}\n+mat!{match_basic_135, r\"[^ab]*\", r\"cde\", Some((0, 3))}\n+mat!{match_basic_137, r\"(^)*\", r\"-\", Some((0, 0)), None}\n+mat!{match_basic_138, r\"a*\", r\"\", Some((0, 0))}\n+mat!{match_basic_139, r\"([abc])*d\", r\"abbbcd\", Some((0, 6)), Some((4, 5))}\n+mat!{match_basic_140, r\"([abc])*bcd\", r\"abcd\", Some((0, 4)), Some((0, 1))}\n+mat!{match_basic_141, r\"a|b|c|d|e\", r\"e\", Some((0, 1))}\n+mat!{match_basic_142, r\"(a|b|c|d|e)f\", r\"ef\", Some((0, 2)), Some((0, 1))}\n+mat!{match_basic_144, r\"((a*|b))*\", r\"-\", Some((0, 0)), None, None}\n+mat!{match_basic_145, r\"abcd*efg\", r\"abcdefg\", Some((0, 7))}\n+mat!{match_basic_146, r\"ab*\", r\"xabyabbbz\", Some((1, 3))}\n+mat!{match_basic_147, r\"ab*\", r\"xayabbbz\", Some((1, 2))}\n+mat!{match_basic_148, r\"(ab|cd)e\", r\"abcde\", Some((2, 5)), Some((2, 4))}\n+mat!{match_basic_149, r\"[abhgefdc]ij\", r\"hij\", Some((0, 3))}\n+mat!{match_basic_150, r\"(a|b)c*d\", r\"abcd\", Some((1, 4)), Some((1, 2))}\n+mat!{match_basic_151, r\"(ab|ab*)bc\", r\"abc\", Some((0, 3)), Some((0, 1))}\n+mat!{match_basic_152, r\"a([bc]*)c*\", r\"abc\", Some((0, 3)), Some((1, 3))}\n+mat!{match_basic_153, r\"a([bc]*)(c*d)\", r\"abcd\", Some((0, 4)), Some((1, 3)), Some((3, 4))}\n+mat!{match_basic_154, r\"a([bc]+)(c*d)\", r\"abcd\", Some((0, 4)), Some((1, 3)), Some((3, 4))}\n+mat!{match_basic_155, r\"a([bc]*)(c+d)\", r\"abcd\", Some((0, 4)), Some((1, 2)), Some((2, 4))}\n+mat!{match_basic_156, r\"a[bcd]*dcdcde\", r\"adcdcde\", Some((0, 7))}\n+mat!{match_basic_157, r\"(ab|a)b*c\", r\"abc\", Some((0, 3)), Some((0, 2))}\n+mat!{match_basic_158, r\"((a)(b)c)(d)\", r\"abcd\", Some((0, 4)), Some((0, 3)), Some((0, 1)), Some((1, 2)), Some((3, 4))}\n+mat!{match_basic_159, r\"[A-Za-z_][A-Za-z0-9_]*\", r\"alpha\", Some((0, 5))}\n+mat!{match_basic_160, r\"^a(bc+|b[eh])g|.h$\", r\"abh\", Some((1, 3))}\n+mat!{match_basic_161, r\"(bc+d$|ef*g.|h?i(j|k))\", r\"effgz\", Some((0, 5)), Some((0, 5))}\n+mat!{match_basic_162, r\"(bc+d$|ef*g.|h?i(j|k))\", r\"ij\", Some((0, 2)), Some((0, 2)), Some((1, 2))}\n+mat!{match_basic_163, r\"(bc+d$|ef*g.|h?i(j|k))\", r\"reffgz\", Some((1, 6)), Some((1, 6))}\n+mat!{match_basic_164, r\"(((((((((a)))))))))\", r\"a\", Some((0, 1)), Some((0, 1)), Some((0, 1)), Some((0, 1)), Some((0, 1)), Some((0, 1)), Some((0, 1)), Some((0, 1)), Some((0, 1)), Some((0, 1))}\n+mat!{match_basic_165, r\"multiple words\", r\"multiple words yeah\", Some((0, 14))}\n+mat!{match_basic_166, r\"(.*)c(.*)\", r\"abcde\", Some((0, 5)), Some((0, 2)), Some((3, 5))}\n+mat!{match_basic_167, r\"abcd\", r\"abcd\", Some((0, 4))}\n+mat!{match_basic_168, r\"a(bc)d\", r\"abcd\", Some((0, 4)), Some((1, 3))}\n+mat!{match_basic_169, r\"a[\u0001-\u0003]?c\", r\"a\u0002c\", Some((0, 3))}\n+mat!{match_basic_170, r\"M[ou]'?am+[ae]r .*([AEae]l[- ])?[GKQ]h?[aeu]+([dtz][dhz]?)+af[iy]\", r\"Muammar Qaddafi\", Some((0, 15)), None, Some((10, 12))}\n+mat!{match_basic_171, r\"M[ou]'?am+[ae]r .*([AEae]l[- ])?[GKQ]h?[aeu]+([dtz][dhz]?)+af[iy]\", r\"Mo'ammar Gadhafi\", Some((0, 16)), None, Some((11, 13))}\n+mat!{match_basic_172, r\"M[ou]'?am+[ae]r .*([AEae]l[- ])?[GKQ]h?[aeu]+([dtz][dhz]?)+af[iy]\", r\"Muammar Kaddafi\", Some((0, 15)), None, Some((10, 12))}\n+mat!{match_basic_173, r\"M[ou]'?am+[ae]r .*([AEae]l[- ])?[GKQ]h?[aeu]+([dtz][dhz]?)+af[iy]\", r\"Muammar Qadhafi\", Some((0, 15)), None, Some((10, 12))}\n+mat!{match_basic_174, r\"M[ou]'?am+[ae]r .*([AEae]l[- ])?[GKQ]h?[aeu]+([dtz][dhz]?)+af[iy]\", r\"Muammar Gadafi\", Some((0, 14)), None, Some((10, 11))}\n+mat!{match_basic_175, r\"M[ou]'?am+[ae]r .*([AEae]l[- ])?[GKQ]h?[aeu]+([dtz][dhz]?)+af[iy]\", r\"Mu'ammar Qadafi\", Some((0, 15)), None, Some((11, 12))}\n+mat!{match_basic_176, r\"M[ou]'?am+[ae]r .*([AEae]l[- ])?[GKQ]h?[aeu]+([dtz][dhz]?)+af[iy]\", r\"Moamar Gaddafi\", Some((0, 14)), None, Some((9, 11))}\n+mat!{match_basic_177, r\"M[ou]'?am+[ae]r .*([AEae]l[- ])?[GKQ]h?[aeu]+([dtz][dhz]?)+af[iy]\", r\"Mu'ammar Qadhdhafi\", Some((0, 18)), None, Some((13, 15))}\n+mat!{match_basic_178, r\"M[ou]'?am+[ae]r .*([AEae]l[- ])?[GKQ]h?[aeu]+([dtz][dhz]?)+af[iy]\", r\"Muammar Khaddafi\", Some((0, 16)), None, Some((11, 13))}\n+mat!{match_basic_179, r\"M[ou]'?am+[ae]r .*([AEae]l[- ])?[GKQ]h?[aeu]+([dtz][dhz]?)+af[iy]\", r\"Muammar Ghaddafy\", Some((0, 16)), None, Some((11, 13))}\n+mat!{match_basic_180, r\"M[ou]'?am+[ae]r .*([AEae]l[- ])?[GKQ]h?[aeu]+([dtz][dhz]?)+af[iy]\", r\"Muammar Ghadafi\", Some((0, 15)), None, Some((11, 12))}\n+mat!{match_basic_181, r\"M[ou]'?am+[ae]r .*([AEae]l[- ])?[GKQ]h?[aeu]+([dtz][dhz]?)+af[iy]\", r\"Muammar Ghaddafi\", Some((0, 16)), None, Some((11, 13))}\n+mat!{match_basic_182, r\"M[ou]'?am+[ae]r .*([AEae]l[- ])?[GKQ]h?[aeu]+([dtz][dhz]?)+af[iy]\", r\"Muamar Kaddafi\", Some((0, 14)), None, Some((9, 11))}\n+mat!{match_basic_183, r\"M[ou]'?am+[ae]r .*([AEae]l[- ])?[GKQ]h?[aeu]+([dtz][dhz]?)+af[iy]\", r\"Muammar Quathafi\", Some((0, 16)), None, Some((11, 13))}\n+mat!{match_basic_184, r\"M[ou]'?am+[ae]r .*([AEae]l[- ])?[GKQ]h?[aeu]+([dtz][dhz]?)+af[iy]\", r\"Muammar Gheddafi\", Some((0, 16)), None, Some((11, 13))}\n+mat!{match_basic_185, r\"M[ou]'?am+[ae]r .*([AEae]l[- ])?[GKQ]h?[aeu]+([dtz][dhz]?)+af[iy]\", r\"Moammar Khadafy\", Some((0, 15)), None, Some((11, 12))}\n+mat!{match_basic_186, r\"M[ou]'?am+[ae]r .*([AEae]l[- ])?[GKQ]h?[aeu]+([dtz][dhz]?)+af[iy]\", r\"Moammar Qudhafi\", Some((0, 15)), None, Some((10, 12))}\n+mat!{match_basic_187, r\"a+(b|c)*d+\", r\"aabcdd\", Some((0, 6)), Some((3, 4))}\n+mat!{match_basic_188, r\"^.+$\", r\"vivi\", Some((0, 4))}\n+mat!{match_basic_189, r\"^(.+)$\", r\"vivi\", Some((0, 4)), Some((0, 4))}\n+mat!{match_basic_190, r\"^([^!.]+).att.com!(.+)$\", r\"gryphon.att.com!eby\", Some((0, 19)), Some((0, 7)), Some((16, 19))}\n+mat!{match_basic_191, r\"^([^!]+!)?([^!]+)$\", r\"bas\", Some((0, 3)), None, Some((0, 3))}\n+mat!{match_basic_192, r\"^([^!]+!)?([^!]+)$\", r\"bar!bas\", Some((0, 7)), Some((0, 4)), Some((4, 7))}\n+mat!{match_basic_193, r\"^([^!]+!)?([^!]+)$\", r\"foo!bas\", Some((0, 7)), Some((0, 4)), Some((4, 7))}\n+mat!{match_basic_194, r\"^.+!([^!]+!)([^!]+)$\", r\"foo!bar!bas\", Some((0, 11)), Some((4, 8)), Some((8, 11))}\n+mat!{match_basic_195, r\"((foo)|(bar))!bas\", r\"bar!bas\", Some((0, 7)), Some((0, 3)), None, Some((0, 3))}\n+mat!{match_basic_196, r\"((foo)|(bar))!bas\", r\"foo!bar!bas\", Some((4, 11)), Some((4, 7)), None, Some((4, 7))}\n+mat!{match_basic_197, r\"((foo)|(bar))!bas\", r\"foo!bas\", Some((0, 7)), Some((0, 3)), Some((0, 3))}\n+mat!{match_basic_198, r\"((foo)|bar)!bas\", r\"bar!bas\", Some((0, 7)), Some((0, 3))}\n+mat!{match_basic_199, r\"((foo)|bar)!bas\", r\"foo!bar!bas\", Some((4, 11)), Some((4, 7))}\n+mat!{match_basic_200, r\"((foo)|bar)!bas\", r\"foo!bas\", Some((0, 7)), Some((0, 3)), Some((0, 3))}\n+mat!{match_basic_201, r\"(foo|(bar))!bas\", r\"bar!bas\", Some((0, 7)), Some((0, 3)), Some((0, 3))}\n+mat!{match_basic_202, r\"(foo|(bar))!bas\", r\"foo!bar!bas\", Some((4, 11)), Some((4, 7)), Some((4, 7))}\n+mat!{match_basic_203, r\"(foo|(bar))!bas\", r\"foo!bas\", Some((0, 7)), Some((0, 3))}\n+mat!{match_basic_204, r\"(foo|bar)!bas\", r\"bar!bas\", Some((0, 7)), Some((0, 3))}\n+mat!{match_basic_205, r\"(foo|bar)!bas\", r\"foo!bar!bas\", Some((4, 11)), Some((4, 7))}\n+mat!{match_basic_206, r\"(foo|bar)!bas\", r\"foo!bas\", Some((0, 7)), Some((0, 3))}\n+mat!{match_basic_207, r\"^(([^!]+!)?([^!]+)|.+!([^!]+!)([^!]+))$\", r\"foo!bar!bas\", Some((0, 11)), Some((0, 11)), None, None, Some((4, 8)), Some((8, 11))}\n+mat!{match_basic_208, r\"^([^!]+!)?([^!]+)$|^.+!([^!]+!)([^!]+)$\", r\"bas\", Some((0, 3)), None, Some((0, 3))}\n+mat!{match_basic_209, r\"^([^!]+!)?([^!]+)$|^.+!([^!]+!)([^!]+)$\", r\"bar!bas\", Some((0, 7)), Some((0, 4)), Some((4, 7))}\n+mat!{match_basic_210, r\"^([^!]+!)?([^!]+)$|^.+!([^!]+!)([^!]+)$\", r\"foo!bar!bas\", Some((0, 11)), None, None, Some((4, 8)), Some((8, 11))}\n+mat!{match_basic_211, r\"^([^!]+!)?([^!]+)$|^.+!([^!]+!)([^!]+)$\", r\"foo!bas\", Some((0, 7)), Some((0, 4)), Some((4, 7))}\n+mat!{match_basic_212, r\"^(([^!]+!)?([^!]+)|.+!([^!]+!)([^!]+))$\", r\"bas\", Some((0, 3)), Some((0, 3)), None, Some((0, 3))}\n+mat!{match_basic_213, r\"^(([^!]+!)?([^!]+)|.+!([^!]+!)([^!]+))$\", r\"bar!bas\", Some((0, 7)), Some((0, 7)), Some((0, 4)), Some((4, 7))}\n+mat!{match_basic_214, r\"^(([^!]+!)?([^!]+)|.+!([^!]+!)([^!]+))$\", r\"foo!bar!bas\", Some((0, 11)), Some((0, 11)), None, None, Some((4, 8)), Some((8, 11))}\n+mat!{match_basic_215, r\"^(([^!]+!)?([^!]+)|.+!([^!]+!)([^!]+))$\", r\"foo!bas\", Some((0, 7)), Some((0, 7)), Some((0, 4)), Some((4, 7))}\n+mat!{match_basic_216, r\".*(/XXX).*\", r\"/XXX\", Some((0, 4)), Some((0, 4))}\n+mat!{match_basic_217, r\".*(\\\\XXX).*\", r\"\\XXX\", Some((0, 4)), Some((0, 4))}\n+mat!{match_basic_218, r\"\\\\XXX\", r\"\\XXX\", Some((0, 4))}\n+mat!{match_basic_219, r\".*(/000).*\", r\"/000\", Some((0, 4)), Some((0, 4))}\n+mat!{match_basic_220, r\".*(\\\\000).*\", r\"\\000\", Some((0, 4)), Some((0, 4))}\n+mat!{match_basic_221, r\"\\\\000\", r\"\\000\", Some((0, 4))}\n \n // Tests from nullsubexpr.dat\n-mat!(match_nullsubexpr_3, r\"(a*)*\", r\"a\", Some((0, 1)), Some((0, 1)))\n-mat!(match_nullsubexpr_5, r\"(a*)*\", r\"x\", Some((0, 0)), None)\n-mat!(match_nullsubexpr_6, r\"(a*)*\", r\"aaaaaa\", Some((0, 6)), Some((0, 6)))\n-mat!(match_nullsubexpr_7, r\"(a*)*\", r\"aaaaaax\", Some((0, 6)), Some((0, 6)))\n-mat!(match_nullsubexpr_8, r\"(a*)+\", r\"a\", Some((0, 1)), Some((0, 1)))\n-mat!(match_nullsubexpr_9, r\"(a*)+\", r\"x\", Some((0, 0)), Some((0, 0)))\n-mat!(match_nullsubexpr_10, r\"(a*)+\", r\"aaaaaa\", Some((0, 6)), Some((0, 6)))\n-mat!(match_nullsubexpr_11, r\"(a*)+\", r\"aaaaaax\", Some((0, 6)), Some((0, 6)))\n-mat!(match_nullsubexpr_12, r\"(a+)*\", r\"a\", Some((0, 1)), Some((0, 1)))\n-mat!(match_nullsubexpr_13, r\"(a+)*\", r\"x\", Some((0, 0)))\n-mat!(match_nullsubexpr_14, r\"(a+)*\", r\"aaaaaa\", Some((0, 6)), Some((0, 6)))\n-mat!(match_nullsubexpr_15, r\"(a+)*\", r\"aaaaaax\", Some((0, 6)), Some((0, 6)))\n-mat!(match_nullsubexpr_16, r\"(a+)+\", r\"a\", Some((0, 1)), Some((0, 1)))\n-mat!(match_nullsubexpr_17, r\"(a+)+\", r\"x\", None)\n-mat!(match_nullsubexpr_18, r\"(a+)+\", r\"aaaaaa\", Some((0, 6)), Some((0, 6)))\n-mat!(match_nullsubexpr_19, r\"(a+)+\", r\"aaaaaax\", Some((0, 6)), Some((0, 6)))\n-mat!(match_nullsubexpr_21, r\"([a]*)*\", r\"a\", Some((0, 1)), Some((0, 1)))\n-mat!(match_nullsubexpr_23, r\"([a]*)*\", r\"x\", Some((0, 0)), None)\n-mat!(match_nullsubexpr_24, r\"([a]*)*\", r\"aaaaaa\", Some((0, 6)), Some((0, 6)))\n-mat!(match_nullsubexpr_25, r\"([a]*)*\", r\"aaaaaax\", Some((0, 6)), Some((0, 6)))\n-mat!(match_nullsubexpr_26, r\"([a]*)+\", r\"a\", Some((0, 1)), Some((0, 1)))\n-mat!(match_nullsubexpr_27, r\"([a]*)+\", r\"x\", Some((0, 0)), Some((0, 0)))\n-mat!(match_nullsubexpr_28, r\"([a]*)+\", r\"aaaaaa\", Some((0, 6)), Some((0, 6)))\n-mat!(match_nullsubexpr_29, r\"([a]*)+\", r\"aaaaaax\", Some((0, 6)), Some((0, 6)))\n-mat!(match_nullsubexpr_30, r\"([^b]*)*\", r\"a\", Some((0, 1)), Some((0, 1)))\n-mat!(match_nullsubexpr_32, r\"([^b]*)*\", r\"b\", Some((0, 0)), None)\n-mat!(match_nullsubexpr_33, r\"([^b]*)*\", r\"aaaaaa\", Some((0, 6)), Some((0, 6)))\n-mat!(match_nullsubexpr_34, r\"([^b]*)*\", r\"aaaaaab\", Some((0, 6)), Some((0, 6)))\n-mat!(match_nullsubexpr_35, r\"([ab]*)*\", r\"a\", Some((0, 1)), Some((0, 1)))\n-mat!(match_nullsubexpr_36, r\"([ab]*)*\", r\"aaaaaa\", Some((0, 6)), Some((0, 6)))\n-mat!(match_nullsubexpr_37, r\"([ab]*)*\", r\"ababab\", Some((0, 6)), Some((0, 6)))\n-mat!(match_nullsubexpr_38, r\"([ab]*)*\", r\"bababa\", Some((0, 6)), Some((0, 6)))\n-mat!(match_nullsubexpr_39, r\"([ab]*)*\", r\"b\", Some((0, 1)), Some((0, 1)))\n-mat!(match_nullsubexpr_40, r\"([ab]*)*\", r\"bbbbbb\", Some((0, 6)), Some((0, 6)))\n-mat!(match_nullsubexpr_41, r\"([ab]*)*\", r\"aaaabcde\", Some((0, 5)), Some((0, 5)))\n-mat!(match_nullsubexpr_42, r\"([^a]*)*\", r\"b\", Some((0, 1)), Some((0, 1)))\n-mat!(match_nullsubexpr_43, r\"([^a]*)*\", r\"bbbbbb\", Some((0, 6)), Some((0, 6)))\n-mat!(match_nullsubexpr_45, r\"([^a]*)*\", r\"aaaaaa\", Some((0, 0)), None)\n-mat!(match_nullsubexpr_46, r\"([^ab]*)*\", r\"ccccxx\", Some((0, 6)), Some((0, 6)))\n-mat!(match_nullsubexpr_48, r\"([^ab]*)*\", r\"ababab\", Some((0, 0)), None)\n-mat!(match_nullsubexpr_50, r\"((z)+|a)*\", r\"zabcde\", Some((0, 2)), Some((1, 2)))\n-mat!(match_nullsubexpr_69, r\"(a*)*(x)\", r\"x\", Some((0, 1)), None, Some((0, 1)))\n-mat!(match_nullsubexpr_70, r\"(a*)*(x)\", r\"ax\", Some((0, 2)), Some((0, 1)), Some((1, 2)))\n-mat!(match_nullsubexpr_71, r\"(a*)*(x)\", r\"axa\", Some((0, 2)), Some((0, 1)), Some((1, 2)))\n-mat!(match_nullsubexpr_73, r\"(a*)+(x)\", r\"x\", Some((0, 1)), Some((0, 0)), Some((0, 1)))\n-mat!(match_nullsubexpr_74, r\"(a*)+(x)\", r\"ax\", Some((0, 2)), Some((0, 1)), Some((1, 2)))\n-mat!(match_nullsubexpr_75, r\"(a*)+(x)\", r\"axa\", Some((0, 2)), Some((0, 1)), Some((1, 2)))\n-mat!(match_nullsubexpr_77, r\"(a*){2}(x)\", r\"x\", Some((0, 1)), Some((0, 0)), Some((0, 1)))\n-mat!(match_nullsubexpr_78, r\"(a*){2}(x)\", r\"ax\", Some((0, 2)), Some((1, 1)), Some((1, 2)))\n-mat!(match_nullsubexpr_79, r\"(a*){2}(x)\", r\"axa\", Some((0, 2)), Some((1, 1)), Some((1, 2)))\n+mat!{match_nullsubexpr_3, r\"(a*)*\", r\"a\", Some((0, 1)), Some((0, 1))}\n+mat!{match_nullsubexpr_5, r\"(a*)*\", r\"x\", Some((0, 0)), None}\n+mat!{match_nullsubexpr_6, r\"(a*)*\", r\"aaaaaa\", Some((0, 6)), Some((0, 6))}\n+mat!{match_nullsubexpr_7, r\"(a*)*\", r\"aaaaaax\", Some((0, 6)), Some((0, 6))}\n+mat!{match_nullsubexpr_8, r\"(a*)+\", r\"a\", Some((0, 1)), Some((0, 1))}\n+mat!{match_nullsubexpr_9, r\"(a*)+\", r\"x\", Some((0, 0)), Some((0, 0))}\n+mat!{match_nullsubexpr_10, r\"(a*)+\", r\"aaaaaa\", Some((0, 6)), Some((0, 6))}\n+mat!{match_nullsubexpr_11, r\"(a*)+\", r\"aaaaaax\", Some((0, 6)), Some((0, 6))}\n+mat!{match_nullsubexpr_12, r\"(a+)*\", r\"a\", Some((0, 1)), Some((0, 1))}\n+mat!{match_nullsubexpr_13, r\"(a+)*\", r\"x\", Some((0, 0))}\n+mat!{match_nullsubexpr_14, r\"(a+)*\", r\"aaaaaa\", Some((0, 6)), Some((0, 6))}\n+mat!{match_nullsubexpr_15, r\"(a+)*\", r\"aaaaaax\", Some((0, 6)), Some((0, 6))}\n+mat!{match_nullsubexpr_16, r\"(a+)+\", r\"a\", Some((0, 1)), Some((0, 1))}\n+mat!{match_nullsubexpr_17, r\"(a+)+\", r\"x\", None}\n+mat!{match_nullsubexpr_18, r\"(a+)+\", r\"aaaaaa\", Some((0, 6)), Some((0, 6))}\n+mat!{match_nullsubexpr_19, r\"(a+)+\", r\"aaaaaax\", Some((0, 6)), Some((0, 6))}\n+mat!{match_nullsubexpr_21, r\"([a]*)*\", r\"a\", Some((0, 1)), Some((0, 1))}\n+mat!{match_nullsubexpr_23, r\"([a]*)*\", r\"x\", Some((0, 0)), None}\n+mat!{match_nullsubexpr_24, r\"([a]*)*\", r\"aaaaaa\", Some((0, 6)), Some((0, 6))}\n+mat!{match_nullsubexpr_25, r\"([a]*)*\", r\"aaaaaax\", Some((0, 6)), Some((0, 6))}\n+mat!{match_nullsubexpr_26, r\"([a]*)+\", r\"a\", Some((0, 1)), Some((0, 1))}\n+mat!{match_nullsubexpr_27, r\"([a]*)+\", r\"x\", Some((0, 0)), Some((0, 0))}\n+mat!{match_nullsubexpr_28, r\"([a]*)+\", r\"aaaaaa\", Some((0, 6)), Some((0, 6))}\n+mat!{match_nullsubexpr_29, r\"([a]*)+\", r\"aaaaaax\", Some((0, 6)), Some((0, 6))}\n+mat!{match_nullsubexpr_30, r\"([^b]*)*\", r\"a\", Some((0, 1)), Some((0, 1))}\n+mat!{match_nullsubexpr_32, r\"([^b]*)*\", r\"b\", Some((0, 0)), None}\n+mat!{match_nullsubexpr_33, r\"([^b]*)*\", r\"aaaaaa\", Some((0, 6)), Some((0, 6))}\n+mat!{match_nullsubexpr_34, r\"([^b]*)*\", r\"aaaaaab\", Some((0, 6)), Some((0, 6))}\n+mat!{match_nullsubexpr_35, r\"([ab]*)*\", r\"a\", Some((0, 1)), Some((0, 1))}\n+mat!{match_nullsubexpr_36, r\"([ab]*)*\", r\"aaaaaa\", Some((0, 6)), Some((0, 6))}\n+mat!{match_nullsubexpr_37, r\"([ab]*)*\", r\"ababab\", Some((0, 6)), Some((0, 6))}\n+mat!{match_nullsubexpr_38, r\"([ab]*)*\", r\"bababa\", Some((0, 6)), Some((0, 6))}\n+mat!{match_nullsubexpr_39, r\"([ab]*)*\", r\"b\", Some((0, 1)), Some((0, 1))}\n+mat!{match_nullsubexpr_40, r\"([ab]*)*\", r\"bbbbbb\", Some((0, 6)), Some((0, 6))}\n+mat!{match_nullsubexpr_41, r\"([ab]*)*\", r\"aaaabcde\", Some((0, 5)), Some((0, 5))}\n+mat!{match_nullsubexpr_42, r\"([^a]*)*\", r\"b\", Some((0, 1)), Some((0, 1))}\n+mat!{match_nullsubexpr_43, r\"([^a]*)*\", r\"bbbbbb\", Some((0, 6)), Some((0, 6))}\n+mat!{match_nullsubexpr_45, r\"([^a]*)*\", r\"aaaaaa\", Some((0, 0)), None}\n+mat!{match_nullsubexpr_46, r\"([^ab]*)*\", r\"ccccxx\", Some((0, 6)), Some((0, 6))}\n+mat!{match_nullsubexpr_48, r\"([^ab]*)*\", r\"ababab\", Some((0, 0)), None}\n+mat!{match_nullsubexpr_50, r\"((z)+|a)*\", r\"zabcde\", Some((0, 2)), Some((1, 2))}\n+mat!{match_nullsubexpr_69, r\"(a*)*(x)\", r\"x\", Some((0, 1)), None, Some((0, 1))}\n+mat!{match_nullsubexpr_70, r\"(a*)*(x)\", r\"ax\", Some((0, 2)), Some((0, 1)), Some((1, 2))}\n+mat!{match_nullsubexpr_71, r\"(a*)*(x)\", r\"axa\", Some((0, 2)), Some((0, 1)), Some((1, 2))}\n+mat!{match_nullsubexpr_73, r\"(a*)+(x)\", r\"x\", Some((0, 1)), Some((0, 0)), Some((0, 1))}\n+mat!{match_nullsubexpr_74, r\"(a*)+(x)\", r\"ax\", Some((0, 2)), Some((0, 1)), Some((1, 2))}\n+mat!{match_nullsubexpr_75, r\"(a*)+(x)\", r\"axa\", Some((0, 2)), Some((0, 1)), Some((1, 2))}\n+mat!{match_nullsubexpr_77, r\"(a*){2}(x)\", r\"x\", Some((0, 1)), Some((0, 0)), Some((0, 1))}\n+mat!{match_nullsubexpr_78, r\"(a*){2}(x)\", r\"ax\", Some((0, 2)), Some((1, 1)), Some((1, 2))}\n+mat!{match_nullsubexpr_79, r\"(a*){2}(x)\", r\"axa\", Some((0, 2)), Some((1, 1)), Some((1, 2))}\n \n // Tests from repetition.dat\n-mat!(match_repetition_10, r\"((..)|(.))\", r\"\", None)\n-mat!(match_repetition_11, r\"((..)|(.))((..)|(.))\", r\"\", None)\n-mat!(match_repetition_12, r\"((..)|(.))((..)|(.))((..)|(.))\", r\"\", None)\n-mat!(match_repetition_14, r\"((..)|(.)){1}\", r\"\", None)\n-mat!(match_repetition_15, r\"((..)|(.)){2}\", r\"\", None)\n-mat!(match_repetition_16, r\"((..)|(.)){3}\", r\"\", None)\n-mat!(match_repetition_18, r\"((..)|(.))*\", r\"\", Some((0, 0)))\n-mat!(match_repetition_20, r\"((..)|(.))\", r\"a\", Some((0, 1)), Some((0, 1)), None, Some((0, 1)))\n-mat!(match_repetition_21, r\"((..)|(.))((..)|(.))\", r\"a\", None)\n-mat!(match_repetition_22, r\"((..)|(.))((..)|(.))((..)|(.))\", r\"a\", None)\n-mat!(match_repetition_24, r\"((..)|(.)){1}\", r\"a\", Some((0, 1)), Some((0, 1)), None, Some((0, 1)))\n-mat!(match_repetition_25, r\"((..)|(.)){2}\", r\"a\", None)\n-mat!(match_repetition_26, r\"((..)|(.)){3}\", r\"a\", None)\n-mat!(match_repetition_28, r\"((..)|(.))*\", r\"a\", Some((0, 1)), Some((0, 1)), None, Some((0, 1)))\n-mat!(match_repetition_30, r\"((..)|(.))\", r\"aa\", Some((0, 2)), Some((0, 2)), Some((0, 2)), None)\n-mat!(match_repetition_31, r\"((..)|(.))((..)|(.))\", r\"aa\", Some((0, 2)), Some((0, 1)), None, Some((0, 1)), Some((1, 2)), None, Some((1, 2)))\n-mat!(match_repetition_32, r\"((..)|(.))((..)|(.))((..)|(.))\", r\"aa\", None)\n-mat!(match_repetition_34, r\"((..)|(.)){1}\", r\"aa\", Some((0, 2)), Some((0, 2)), Some((0, 2)), None)\n-mat!(match_repetition_35, r\"((..)|(.)){2}\", r\"aa\", Some((0, 2)), Some((1, 2)), None, Some((1, 2)))\n-mat!(match_repetition_36, r\"((..)|(.)){3}\", r\"aa\", None)\n-mat!(match_repetition_38, r\"((..)|(.))*\", r\"aa\", Some((0, 2)), Some((0, 2)), Some((0, 2)), None)\n-mat!(match_repetition_40, r\"((..)|(.))\", r\"aaa\", Some((0, 2)), Some((0, 2)), Some((0, 2)), None)\n-mat!(match_repetition_41, r\"((..)|(.))((..)|(.))\", r\"aaa\", Some((0, 3)), Some((0, 2)), Some((0, 2)), None, Some((2, 3)), None, Some((2, 3)))\n-mat!(match_repetition_42, r\"((..)|(.))((..)|(.))((..)|(.))\", r\"aaa\", Some((0, 3)), Some((0, 1)), None, Some((0, 1)), Some((1, 2)), None, Some((1, 2)), Some((2, 3)), None, Some((2, 3)))\n-mat!(match_repetition_44, r\"((..)|(.)){1}\", r\"aaa\", Some((0, 2)), Some((0, 2)), Some((0, 2)), None)\n-mat!(match_repetition_46, r\"((..)|(.)){2}\", r\"aaa\", Some((0, 3)), Some((2, 3)), Some((0, 2)), Some((2, 3)))\n-mat!(match_repetition_47, r\"((..)|(.)){3}\", r\"aaa\", Some((0, 3)), Some((2, 3)), None, Some((2, 3)))\n-mat!(match_repetition_50, r\"((..)|(.))*\", r\"aaa\", Some((0, 3)), Some((2, 3)), Some((0, 2)), Some((2, 3)))\n-mat!(match_repetition_52, r\"((..)|(.))\", r\"aaaa\", Some((0, 2)), Some((0, 2)), Some((0, 2)), None)\n-mat!(match_repetition_53, r\"((..)|(.))((..)|(.))\", r\"aaaa\", Some((0, 4)), Some((0, 2)), Some((0, 2)), None, Some((2, 4)), Some((2, 4)), None)\n-mat!(match_repetition_54, r\"((..)|(.))((..)|(.))((..)|(.))\", r\"aaaa\", Some((0, 4)), Some((0, 2)), Some((0, 2)), None, Some((2, 3)), None, Some((2, 3)), Some((3, 4)), None, Some((3, 4)))\n-mat!(match_repetition_56, r\"((..)|(.)){1}\", r\"aaaa\", Some((0, 2)), Some((0, 2)), Some((0, 2)), None)\n-mat!(match_repetition_57, r\"((..)|(.)){2}\", r\"aaaa\", Some((0, 4)), Some((2, 4)), Some((2, 4)), None)\n-mat!(match_repetition_59, r\"((..)|(.)){3}\", r\"aaaa\", Some((0, 4)), Some((3, 4)), Some((0, 2)), Some((3, 4)))\n-mat!(match_repetition_61, r\"((..)|(.))*\", r\"aaaa\", Some((0, 4)), Some((2, 4)), Some((2, 4)), None)\n-mat!(match_repetition_63, r\"((..)|(.))\", r\"aaaaa\", Some((0, 2)), Some((0, 2)), Some((0, 2)), None)\n-mat!(match_repetition_64, r\"((..)|(.))((..)|(.))\", r\"aaaaa\", Some((0, 4)), Some((0, 2)), Some((0, 2)), None, Some((2, 4)), Some((2, 4)), None)\n-mat!(match_repetition_65, r\"((..)|(.))((..)|(.))((..)|(.))\", r\"aaaaa\", Some((0, 5)), Some((0, 2)), Some((0, 2)), None, Some((2, 4)), Some((2, 4)), None, Some((4, 5)), None, Some((4, 5)))\n-mat!(match_repetition_67, r\"((..)|(.)){1}\", r\"aaaaa\", Some((0, 2)), Some((0, 2)), Some((0, 2)), None)\n-mat!(match_repetition_68, r\"((..)|(.)){2}\", r\"aaaaa\", Some((0, 4)), Some((2, 4)), Some((2, 4)), None)\n-mat!(match_repetition_70, r\"((..)|(.)){3}\", r\"aaaaa\", Some((0, 5)), Some((4, 5)), Some((2, 4)), Some((4, 5)))\n-mat!(match_repetition_73, r\"((..)|(.))*\", r\"aaaaa\", Some((0, 5)), Some((4, 5)), Some((2, 4)), Some((4, 5)))\n-mat!(match_repetition_75, r\"((..)|(.))\", r\"aaaaaa\", Some((0, 2)), Some((0, 2)), Some((0, 2)), None)\n-mat!(match_repetition_76, r\"((..)|(.))((..)|(.))\", r\"aaaaaa\", Some((0, 4)), Some((0, 2)), Some((0, 2)), None, Some((2, 4)), Some((2, 4)), None)\n-mat!(match_repetition_77, r\"((..)|(.))((..)|(.))((..)|(.))\", r\"aaaaaa\", Some((0, 6)), Some((0, 2)), Some((0, 2)), None, Some((2, 4)), Some((2, 4)), None, Some((4, 6)), Some((4, 6)), None)\n-mat!(match_repetition_79, r\"((..)|(.)){1}\", r\"aaaaaa\", Some((0, 2)), Some((0, 2)), Some((0, 2)), None)\n-mat!(match_repetition_80, r\"((..)|(.)){2}\", r\"aaaaaa\", Some((0, 4)), Some((2, 4)), Some((2, 4)), None)\n-mat!(match_repetition_81, r\"((..)|(.)){3}\", r\"aaaaaa\", Some((0, 6)), Some((4, 6)), Some((4, 6)), None)\n-mat!(match_repetition_83, r\"((..)|(.))*\", r\"aaaaaa\", Some((0, 6)), Some((4, 6)), Some((4, 6)), None)\n-mat!(match_repetition_90, r\"X(.?){0,}Y\", r\"X1234567Y\", Some((0, 9)), Some((7, 8)))\n-mat!(match_repetition_91, r\"X(.?){1,}Y\", r\"X1234567Y\", Some((0, 9)), Some((7, 8)))\n-mat!(match_repetition_92, r\"X(.?){2,}Y\", r\"X1234567Y\", Some((0, 9)), Some((7, 8)))\n-mat!(match_repetition_93, r\"X(.?){3,}Y\", r\"X1234567Y\", Some((0, 9)), Some((7, 8)))\n-mat!(match_repetition_94, r\"X(.?){4,}Y\", r\"X1234567Y\", Some((0, 9)), Some((7, 8)))\n-mat!(match_repetition_95, r\"X(.?){5,}Y\", r\"X1234567Y\", Some((0, 9)), Some((7, 8)))\n-mat!(match_repetition_96, r\"X(.?){6,}Y\", r\"X1234567Y\", Some((0, 9)), Some((7, 8)))\n-mat!(match_repetition_97, r\"X(.?){7,}Y\", r\"X1234567Y\", Some((0, 9)), Some((7, 8)))\n-mat!(match_repetition_98, r\"X(.?){8,}Y\", r\"X1234567Y\", Some((0, 9)), Some((8, 8)))\n-mat!(match_repetition_100, r\"X(.?){0,8}Y\", r\"X1234567Y\", Some((0, 9)), Some((8, 8)))\n-mat!(match_repetition_102, r\"X(.?){1,8}Y\", r\"X1234567Y\", Some((0, 9)), Some((8, 8)))\n-mat!(match_repetition_104, r\"X(.?){2,8}Y\", r\"X1234567Y\", Some((0, 9)), Some((8, 8)))\n-mat!(match_repetition_106, r\"X(.?){3,8}Y\", r\"X1234567Y\", Some((0, 9)), Some((8, 8)))\n-mat!(match_repetition_108, r\"X(.?){4,8}Y\", r\"X1234567Y\", Some((0, 9)), Some((8, 8)))\n-mat!(match_repetition_110, r\"X(.?){5,8}Y\", r\"X1234567Y\", Some((0, 9)), Some((8, 8)))\n-mat!(match_repetition_112, r\"X(.?){6,8}Y\", r\"X1234567Y\", Some((0, 9)), Some((8, 8)))\n-mat!(match_repetition_114, r\"X(.?){7,8}Y\", r\"X1234567Y\", Some((0, 9)), Some((8, 8)))\n-mat!(match_repetition_115, r\"X(.?){8,8}Y\", r\"X1234567Y\", Some((0, 9)), Some((8, 8)))\n-mat!(match_repetition_126, r\"(a|ab|c|bcd){0,}(d*)\", r\"ababcd\", Some((0, 1)), Some((0, 1)), Some((1, 1)))\n-mat!(match_repetition_127, r\"(a|ab|c|bcd){1,}(d*)\", r\"ababcd\", Some((0, 1)), Some((0, 1)), Some((1, 1)))\n-mat!(match_repetition_128, r\"(a|ab|c|bcd){2,}(d*)\", r\"ababcd\", Some((0, 6)), Some((3, 6)), Some((6, 6)))\n-mat!(match_repetition_129, r\"(a|ab|c|bcd){3,}(d*)\", r\"ababcd\", Some((0, 6)), Some((3, 6)), Some((6, 6)))\n-mat!(match_repetition_130, r\"(a|ab|c|bcd){4,}(d*)\", r\"ababcd\", None)\n-mat!(match_repetition_131, r\"(a|ab|c|bcd){0,10}(d*)\", r\"ababcd\", Some((0, 1)), Some((0, 1)), Some((1, 1)))\n-mat!(match_repetition_132, r\"(a|ab|c|bcd){1,10}(d*)\", r\"ababcd\", Some((0, 1)), Some((0, 1)), Some((1, 1)))\n-mat!(match_repetition_133, r\"(a|ab|c|bcd){2,10}(d*)\", r\"ababcd\", Some((0, 6)), Some((3, 6)), Some((6, 6)))\n-mat!(match_repetition_134, r\"(a|ab|c|bcd){3,10}(d*)\", r\"ababcd\", Some((0, 6)), Some((3, 6)), Some((6, 6)))\n-mat!(match_repetition_135, r\"(a|ab|c|bcd){4,10}(d*)\", r\"ababcd\", None)\n-mat!(match_repetition_136, r\"(a|ab|c|bcd)*(d*)\", r\"ababcd\", Some((0, 1)), Some((0, 1)), Some((1, 1)))\n-mat!(match_repetition_137, r\"(a|ab|c|bcd)+(d*)\", r\"ababcd\", Some((0, 1)), Some((0, 1)), Some((1, 1)))\n-mat!(match_repetition_143, r\"(ab|a|c|bcd){0,}(d*)\", r\"ababcd\", Some((0, 6)), Some((4, 5)), Some((5, 6)))\n-mat!(match_repetition_145, r\"(ab|a|c|bcd){1,}(d*)\", r\"ababcd\", Some((0, 6)), Some((4, 5)), Some((5, 6)))\n-mat!(match_repetition_147, r\"(ab|a|c|bcd){2,}(d*)\", r\"ababcd\", Some((0, 6)), Some((4, 5)), Some((5, 6)))\n-mat!(match_repetition_149, r\"(ab|a|c|bcd){3,}(d*)\", r\"ababcd\", Some((0, 6)), Some((4, 5)), Some((5, 6)))\n-mat!(match_repetition_150, r\"(ab|a|c|bcd){4,}(d*)\", r\"ababcd\", None)\n-mat!(match_repetition_152, r\"(ab|a|c|bcd){0,10}(d*)\", r\"ababcd\", Some((0, 6)), Some((4, 5)), Some((5, 6)))\n-mat!(match_repetition_154, r\"(ab|a|c|bcd){1,10}(d*)\", r\"ababcd\", Some((0, 6)), Some((4, 5)), Some((5, 6)))\n-mat!(match_repetition_156, r\"(ab|a|c|bcd){2,10}(d*)\", r\"ababcd\", Some((0, 6)), Some((4, 5)), Some((5, 6)))\n-mat!(match_repetition_158, r\"(ab|a|c|bcd){3,10}(d*)\", r\"ababcd\", Some((0, 6)), Some((4, 5)), Some((5, 6)))\n-mat!(match_repetition_159, r\"(ab|a|c|bcd){4,10}(d*)\", r\"ababcd\", None)\n-mat!(match_repetition_161, r\"(ab|a|c|bcd)*(d*)\", r\"ababcd\", Some((0, 6)), Some((4, 5)), Some((5, 6)))\n-mat!(match_repetition_163, r\"(ab|a|c|bcd)+(d*)\", r\"ababcd\", Some((0, 6)), Some((4, 5)), Some((5, 6)))\n+mat!{match_repetition_10, r\"((..)|(.))\", r\"\", None}\n+mat!{match_repetition_11, r\"((..)|(.))((..)|(.))\", r\"\", None}\n+mat!{match_repetition_12, r\"((..)|(.))((..)|(.))((..)|(.))\", r\"\", None}\n+mat!{match_repetition_14, r\"((..)|(.)){1}\", r\"\", None}\n+mat!{match_repetition_15, r\"((..)|(.)){2}\", r\"\", None}\n+mat!{match_repetition_16, r\"((..)|(.)){3}\", r\"\", None}\n+mat!{match_repetition_18, r\"((..)|(.))*\", r\"\", Some((0, 0))}\n+mat!{match_repetition_20, r\"((..)|(.))\", r\"a\", Some((0, 1)), Some((0, 1)), None, Some((0, 1))}\n+mat!{match_repetition_21, r\"((..)|(.))((..)|(.))\", r\"a\", None}\n+mat!{match_repetition_22, r\"((..)|(.))((..)|(.))((..)|(.))\", r\"a\", None}\n+mat!{match_repetition_24, r\"((..)|(.)){1}\", r\"a\", Some((0, 1)), Some((0, 1)), None, Some((0, 1))}\n+mat!{match_repetition_25, r\"((..)|(.)){2}\", r\"a\", None}\n+mat!{match_repetition_26, r\"((..)|(.)){3}\", r\"a\", None}\n+mat!{match_repetition_28, r\"((..)|(.))*\", r\"a\", Some((0, 1)), Some((0, 1)), None, Some((0, 1))}\n+mat!{match_repetition_30, r\"((..)|(.))\", r\"aa\", Some((0, 2)), Some((0, 2)), Some((0, 2)), None}\n+mat!{match_repetition_31, r\"((..)|(.))((..)|(.))\", r\"aa\", Some((0, 2)), Some((0, 1)), None, Some((0, 1)), Some((1, 2)), None, Some((1, 2))}\n+mat!{match_repetition_32, r\"((..)|(.))((..)|(.))((..)|(.))\", r\"aa\", None}\n+mat!{match_repetition_34, r\"((..)|(.)){1}\", r\"aa\", Some((0, 2)), Some((0, 2)), Some((0, 2)), None}\n+mat!{match_repetition_35, r\"((..)|(.)){2}\", r\"aa\", Some((0, 2)), Some((1, 2)), None, Some((1, 2))}\n+mat!{match_repetition_36, r\"((..)|(.)){3}\", r\"aa\", None}\n+mat!{match_repetition_38, r\"((..)|(.))*\", r\"aa\", Some((0, 2)), Some((0, 2)), Some((0, 2)), None}\n+mat!{match_repetition_40, r\"((..)|(.))\", r\"aaa\", Some((0, 2)), Some((0, 2)), Some((0, 2)), None}\n+mat!{match_repetition_41, r\"((..)|(.))((..)|(.))\", r\"aaa\", Some((0, 3)), Some((0, 2)), Some((0, 2)), None, Some((2, 3)), None, Some((2, 3))}\n+mat!{match_repetition_42, r\"((..)|(.))((..)|(.))((..)|(.))\", r\"aaa\", Some((0, 3)), Some((0, 1)), None, Some((0, 1)), Some((1, 2)), None, Some((1, 2)), Some((2, 3)), None, Some((2, 3))}\n+mat!{match_repetition_44, r\"((..)|(.)){1}\", r\"aaa\", Some((0, 2)), Some((0, 2)), Some((0, 2)), None}\n+mat!{match_repetition_46, r\"((..)|(.)){2}\", r\"aaa\", Some((0, 3)), Some((2, 3)), Some((0, 2)), Some((2, 3))}\n+mat!{match_repetition_47, r\"((..)|(.)){3}\", r\"aaa\", Some((0, 3)), Some((2, 3)), None, Some((2, 3))}\n+mat!{match_repetition_50, r\"((..)|(.))*\", r\"aaa\", Some((0, 3)), Some((2, 3)), Some((0, 2)), Some((2, 3))}\n+mat!{match_repetition_52, r\"((..)|(.))\", r\"aaaa\", Some((0, 2)), Some((0, 2)), Some((0, 2)), None}\n+mat!{match_repetition_53, r\"((..)|(.))((..)|(.))\", r\"aaaa\", Some((0, 4)), Some((0, 2)), Some((0, 2)), None, Some((2, 4)), Some((2, 4)), None}\n+mat!{match_repetition_54, r\"((..)|(.))((..)|(.))((..)|(.))\", r\"aaaa\", Some((0, 4)), Some((0, 2)), Some((0, 2)), None, Some((2, 3)), None, Some((2, 3)), Some((3, 4)), None, Some((3, 4))}\n+mat!{match_repetition_56, r\"((..)|(.)){1}\", r\"aaaa\", Some((0, 2)), Some((0, 2)), Some((0, 2)), None}\n+mat!{match_repetition_57, r\"((..)|(.)){2}\", r\"aaaa\", Some((0, 4)), Some((2, 4)), Some((2, 4)), None}\n+mat!{match_repetition_59, r\"((..)|(.)){3}\", r\"aaaa\", Some((0, 4)), Some((3, 4)), Some((0, 2)), Some((3, 4))}\n+mat!{match_repetition_61, r\"((..)|(.))*\", r\"aaaa\", Some((0, 4)), Some((2, 4)), Some((2, 4)), None}\n+mat!{match_repetition_63, r\"((..)|(.))\", r\"aaaaa\", Some((0, 2)), Some((0, 2)), Some((0, 2)), None}\n+mat!{match_repetition_64, r\"((..)|(.))((..)|(.))\", r\"aaaaa\", Some((0, 4)), Some((0, 2)), Some((0, 2)), None, Some((2, 4)), Some((2, 4)), None}\n+mat!{match_repetition_65, r\"((..)|(.))((..)|(.))((..)|(.))\", r\"aaaaa\", Some((0, 5)), Some((0, 2)), Some((0, 2)), None, Some((2, 4)), Some((2, 4)), None, Some((4, 5)), None, Some((4, 5))}\n+mat!{match_repetition_67, r\"((..)|(.)){1}\", r\"aaaaa\", Some((0, 2)), Some((0, 2)), Some((0, 2)), None}\n+mat!{match_repetition_68, r\"((..)|(.)){2}\", r\"aaaaa\", Some((0, 4)), Some((2, 4)), Some((2, 4)), None}\n+mat!{match_repetition_70, r\"((..)|(.)){3}\", r\"aaaaa\", Some((0, 5)), Some((4, 5)), Some((2, 4)), Some((4, 5))}\n+mat!{match_repetition_73, r\"((..)|(.))*\", r\"aaaaa\", Some((0, 5)), Some((4, 5)), Some((2, 4)), Some((4, 5))}\n+mat!{match_repetition_75, r\"((..)|(.))\", r\"aaaaaa\", Some((0, 2)), Some((0, 2)), Some((0, 2)), None}\n+mat!{match_repetition_76, r\"((..)|(.))((..)|(.))\", r\"aaaaaa\", Some((0, 4)), Some((0, 2)), Some((0, 2)), None, Some((2, 4)), Some((2, 4)), None}\n+mat!{match_repetition_77, r\"((..)|(.))((..)|(.))((..)|(.))\", r\"aaaaaa\", Some((0, 6)), Some((0, 2)), Some((0, 2)), None, Some((2, 4)), Some((2, 4)), None, Some((4, 6)), Some((4, 6)), None}\n+mat!{match_repetition_79, r\"((..)|(.)){1}\", r\"aaaaaa\", Some((0, 2)), Some((0, 2)), Some((0, 2)), None}\n+mat!{match_repetition_80, r\"((..)|(.)){2}\", r\"aaaaaa\", Some((0, 4)), Some((2, 4)), Some((2, 4)), None}\n+mat!{match_repetition_81, r\"((..)|(.)){3}\", r\"aaaaaa\", Some((0, 6)), Some((4, 6)), Some((4, 6)), None}\n+mat!{match_repetition_83, r\"((..)|(.))*\", r\"aaaaaa\", Some((0, 6)), Some((4, 6)), Some((4, 6)), None}\n+mat!{match_repetition_90, r\"X(.?){0,}Y\", r\"X1234567Y\", Some((0, 9)), Some((7, 8))}\n+mat!{match_repetition_91, r\"X(.?){1,}Y\", r\"X1234567Y\", Some((0, 9)), Some((7, 8))}\n+mat!{match_repetition_92, r\"X(.?){2,}Y\", r\"X1234567Y\", Some((0, 9)), Some((7, 8))}\n+mat!{match_repetition_93, r\"X(.?){3,}Y\", r\"X1234567Y\", Some((0, 9)), Some((7, 8))}\n+mat!{match_repetition_94, r\"X(.?){4,}Y\", r\"X1234567Y\", Some((0, 9)), Some((7, 8))}\n+mat!{match_repetition_95, r\"X(.?){5,}Y\", r\"X1234567Y\", Some((0, 9)), Some((7, 8))}\n+mat!{match_repetition_96, r\"X(.?){6,}Y\", r\"X1234567Y\", Some((0, 9)), Some((7, 8))}\n+mat!{match_repetition_97, r\"X(.?){7,}Y\", r\"X1234567Y\", Some((0, 9)), Some((7, 8))}\n+mat!{match_repetition_98, r\"X(.?){8,}Y\", r\"X1234567Y\", Some((0, 9)), Some((8, 8))}\n+mat!{match_repetition_100, r\"X(.?){0,8}Y\", r\"X1234567Y\", Some((0, 9)), Some((8, 8))}\n+mat!{match_repetition_102, r\"X(.?){1,8}Y\", r\"X1234567Y\", Some((0, 9)), Some((8, 8))}\n+mat!{match_repetition_104, r\"X(.?){2,8}Y\", r\"X1234567Y\", Some((0, 9)), Some((8, 8))}\n+mat!{match_repetition_106, r\"X(.?){3,8}Y\", r\"X1234567Y\", Some((0, 9)), Some((8, 8))}\n+mat!{match_repetition_108, r\"X(.?){4,8}Y\", r\"X1234567Y\", Some((0, 9)), Some((8, 8))}\n+mat!{match_repetition_110, r\"X(.?){5,8}Y\", r\"X1234567Y\", Some((0, 9)), Some((8, 8))}\n+mat!{match_repetition_112, r\"X(.?){6,8}Y\", r\"X1234567Y\", Some((0, 9)), Some((8, 8))}\n+mat!{match_repetition_114, r\"X(.?){7,8}Y\", r\"X1234567Y\", Some((0, 9)), Some((8, 8))}\n+mat!{match_repetition_115, r\"X(.?){8,8}Y\", r\"X1234567Y\", Some((0, 9)), Some((8, 8))}\n+mat!{match_repetition_126, r\"(a|ab|c|bcd){0,}(d*)\", r\"ababcd\", Some((0, 1)), Some((0, 1)), Some((1, 1))}\n+mat!{match_repetition_127, r\"(a|ab|c|bcd){1,}(d*)\", r\"ababcd\", Some((0, 1)), Some((0, 1)), Some((1, 1))}\n+mat!{match_repetition_128, r\"(a|ab|c|bcd){2,}(d*)\", r\"ababcd\", Some((0, 6)), Some((3, 6)), Some((6, 6))}\n+mat!{match_repetition_129, r\"(a|ab|c|bcd){3,}(d*)\", r\"ababcd\", Some((0, 6)), Some((3, 6)), Some((6, 6))}\n+mat!{match_repetition_130, r\"(a|ab|c|bcd){4,}(d*)\", r\"ababcd\", None}\n+mat!{match_repetition_131, r\"(a|ab|c|bcd){0,10}(d*)\", r\"ababcd\", Some((0, 1)), Some((0, 1)), Some((1, 1))}\n+mat!{match_repetition_132, r\"(a|ab|c|bcd){1,10}(d*)\", r\"ababcd\", Some((0, 1)), Some((0, 1)), Some((1, 1))}\n+mat!{match_repetition_133, r\"(a|ab|c|bcd){2,10}(d*)\", r\"ababcd\", Some((0, 6)), Some((3, 6)), Some((6, 6))}\n+mat!{match_repetition_134, r\"(a|ab|c|bcd){3,10}(d*)\", r\"ababcd\", Some((0, 6)), Some((3, 6)), Some((6, 6))}\n+mat!{match_repetition_135, r\"(a|ab|c|bcd){4,10}(d*)\", r\"ababcd\", None}\n+mat!{match_repetition_136, r\"(a|ab|c|bcd)*(d*)\", r\"ababcd\", Some((0, 1)), Some((0, 1)), Some((1, 1))}\n+mat!{match_repetition_137, r\"(a|ab|c|bcd)+(d*)\", r\"ababcd\", Some((0, 1)), Some((0, 1)), Some((1, 1))}\n+mat!{match_repetition_143, r\"(ab|a|c|bcd){0,}(d*)\", r\"ababcd\", Some((0, 6)), Some((4, 5)), Some((5, 6))}\n+mat!{match_repetition_145, r\"(ab|a|c|bcd){1,}(d*)\", r\"ababcd\", Some((0, 6)), Some((4, 5)), Some((5, 6))}\n+mat!{match_repetition_147, r\"(ab|a|c|bcd){2,}(d*)\", r\"ababcd\", Some((0, 6)), Some((4, 5)), Some((5, 6))}\n+mat!{match_repetition_149, r\"(ab|a|c|bcd){3,}(d*)\", r\"ababcd\", Some((0, 6)), Some((4, 5)), Some((5, 6))}\n+mat!{match_repetition_150, r\"(ab|a|c|bcd){4,}(d*)\", r\"ababcd\", None}\n+mat!{match_repetition_152, r\"(ab|a|c|bcd){0,10}(d*)\", r\"ababcd\", Some((0, 6)), Some((4, 5)), Some((5, 6))}\n+mat!{match_repetition_154, r\"(ab|a|c|bcd){1,10}(d*)\", r\"ababcd\", Some((0, 6)), Some((4, 5)), Some((5, 6))}\n+mat!{match_repetition_156, r\"(ab|a|c|bcd){2,10}(d*)\", r\"ababcd\", Some((0, 6)), Some((4, 5)), Some((5, 6))}\n+mat!{match_repetition_158, r\"(ab|a|c|bcd){3,10}(d*)\", r\"ababcd\", Some((0, 6)), Some((4, 5)), Some((5, 6))}\n+mat!{match_repetition_159, r\"(ab|a|c|bcd){4,10}(d*)\", r\"ababcd\", None}\n+mat!{match_repetition_161, r\"(ab|a|c|bcd)*(d*)\", r\"ababcd\", Some((0, 6)), Some((4, 5)), Some((5, 6))}\n+mat!{match_repetition_163, r\"(ab|a|c|bcd)+(d*)\", r\"ababcd\", Some((0, 6)), Some((4, 5)), Some((5, 6))}\n "}, {"sha": "14156647191248e2102840eb8a57131c971be0df", "filename": "src/libregex/test/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibregex%2Ftest%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibregex%2Ftest%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Ftest%2Fmod.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -26,14 +26,14 @@ mod native_static;\n // Due to macro scoping rules, this definition only applies for the modules\n // defined below. Effectively, it allows us to use the same tests for both\n // native and dynamic regexes.\n-macro_rules! regex(\n+macro_rules! regex {\n     ($re:expr) => (\n         match ::regex::Regex::new($re) {\n             Ok(re) => re,\n             Err(err) => panic!(\"{}\", err),\n         }\n     );\n-)\n+}\n \n #[path = \"bench.rs\"]\n mod dynamic_bench;"}, {"sha": "2f66d483d80009a903829a891770ba0a2865a8b1", "filename": "src/libregex/test/tests.rs", "status": "modified", "additions": 112, "deletions": 112, "changes": 224, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibregex%2Ftest%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibregex%2Ftest%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Ftest%2Ftests.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -67,7 +67,7 @@ fn range_ends_with_escape() {\n     assert_eq!(ms, vec![(0, 1), (1, 2)]);\n }\n \n-macro_rules! replace(\n+macro_rules! replace {\n     ($name:ident, $which:ident, $re:expr,\n      $search:expr, $replace:expr, $result:expr) => (\n         #[test]\n@@ -76,23 +76,23 @@ macro_rules! replace(\n             assert_eq!(re.$which($search, $replace), String::from_str($result));\n         }\n     );\n-)\n-\n-replace!(rep_first, replace, r\"\\d\", \"age: 26\", \"Z\", \"age: Z6\")\n-replace!(rep_plus, replace, r\"\\d+\", \"age: 26\", \"Z\", \"age: Z\")\n-replace!(rep_all, replace_all, r\"\\d\", \"age: 26\", \"Z\", \"age: ZZ\")\n-replace!(rep_groups, replace, r\"(\\S+)\\s+(\\S+)\", \"w1 w2\", \"$2 $1\", \"w2 w1\")\n-replace!(rep_double_dollar, replace,\n-         r\"(\\S+)\\s+(\\S+)\", \"w1 w2\", \"$2 $$1\", \"w2 $1\")\n-replace!(rep_no_expand, replace,\n-         r\"(\\S+)\\s+(\\S+)\", \"w1 w2\", NoExpand(\"$2 $1\"), \"$2 $1\")\n-replace!(rep_named, replace_all,\n+}\n+\n+replace!{rep_first, replace, r\"\\d\", \"age: 26\", \"Z\", \"age: Z6\"}\n+replace!{rep_plus, replace, r\"\\d+\", \"age: 26\", \"Z\", \"age: Z\"}\n+replace!{rep_all, replace_all, r\"\\d\", \"age: 26\", \"Z\", \"age: ZZ\"}\n+replace!{rep_groups, replace, r\"(\\S+)\\s+(\\S+)\", \"w1 w2\", \"$2 $1\", \"w2 w1\"}\n+replace!{rep_double_dollar, replace,\n+         r\"(\\S+)\\s+(\\S+)\", \"w1 w2\", \"$2 $$1\", \"w2 $1\"}\n+replace!{rep_no_expand, replace,\n+         r\"(\\S+)\\s+(\\S+)\", \"w1 w2\", NoExpand(\"$2 $1\"), \"$2 $1\"}\n+replace!{rep_named, replace_all,\n          r\"(?P<first>\\S+)\\s+(?P<last>\\S+)(?P<space>\\s*)\",\n-         \"w1 w2 w3 w4\", \"$last $first$space\", \"w2 w1 w4 w3\")\n-replace!(rep_trim, replace_all, \"^[ \\t]+|[ \\t]+$\", \" \\t  trim me\\t   \\t\",\n-         \"\", \"trim me\")\n+         \"w1 w2 w3 w4\", \"$last $first$space\", \"w2 w1 w4 w3\"}\n+replace!{rep_trim, replace_all, \"^[ \\t]+|[ \\t]+$\", \" \\t  trim me\\t   \\t\",\n+         \"\", \"trim me\"}\n \n-macro_rules! noparse(\n+macro_rules! noparse {\n     ($name:ident, $re:expr) => (\n         #[test]\n         fn $name() {\n@@ -103,47 +103,47 @@ macro_rules! noparse(\n             }\n         }\n     );\n-)\n-\n-noparse!(fail_double_repeat, \"a**\")\n-noparse!(fail_no_repeat_arg, \"*\")\n-noparse!(fail_no_repeat_arg_begin, \"^*\")\n-noparse!(fail_incomplete_escape, \"\\\\\")\n-noparse!(fail_class_incomplete, \"[A-\")\n-noparse!(fail_class_not_closed, \"[A\")\n-noparse!(fail_class_no_begin, r\"[\\A]\")\n-noparse!(fail_class_no_end, r\"[\\z]\")\n-noparse!(fail_class_no_boundary, r\"[\\b]\")\n-noparse!(fail_open_paren, \"(\")\n-noparse!(fail_close_paren, \")\")\n-noparse!(fail_invalid_range, \"[a-Z]\")\n-noparse!(fail_empty_capture_name, \"(?P<>a)\")\n-noparse!(fail_empty_capture_exp, \"(?P<name>)\")\n-noparse!(fail_bad_capture_name, \"(?P<na-me>)\")\n-noparse!(fail_bad_flag, \"(?a)a\")\n-noparse!(fail_empty_alt_before, \"|a\")\n-noparse!(fail_empty_alt_after, \"a|\")\n-noparse!(fail_counted_big_exact, \"a{1001}\")\n-noparse!(fail_counted_big_min, \"a{1001,}\")\n-noparse!(fail_counted_no_close, \"a{1001\")\n-noparse!(fail_unfinished_cap, \"(?\")\n-noparse!(fail_unfinished_escape, \"\\\\\")\n-noparse!(fail_octal_digit, r\"\\8\")\n-noparse!(fail_hex_digit, r\"\\xG0\")\n-noparse!(fail_hex_short, r\"\\xF\")\n-noparse!(fail_hex_long_digits, r\"\\x{fffg}\")\n-noparse!(fail_flag_bad, \"(?a)\")\n-noparse!(fail_flag_empty, \"(?)\")\n-noparse!(fail_double_neg, \"(?-i-i)\")\n-noparse!(fail_neg_empty, \"(?i-)\")\n-noparse!(fail_empty_group, \"()\")\n-noparse!(fail_dupe_named, \"(?P<a>.)(?P<a>.)\")\n-noparse!(fail_range_end_no_class, \"[a-[:lower:]]\")\n-noparse!(fail_range_end_no_begin, r\"[a-\\A]\")\n-noparse!(fail_range_end_no_end, r\"[a-\\z]\")\n-noparse!(fail_range_end_no_boundary, r\"[a-\\b]\")\n-\n-macro_rules! mat(\n+}\n+\n+noparse!{fail_double_repeat, \"a**\"}\n+noparse!{fail_no_repeat_arg, \"*\"}\n+noparse!{fail_no_repeat_arg_begin, \"^*\"}\n+noparse!{fail_incomplete_escape, \"\\\\\"}\n+noparse!{fail_class_incomplete, \"[A-\"}\n+noparse!{fail_class_not_closed, \"[A\"}\n+noparse!{fail_class_no_begin, r\"[\\A]\"}\n+noparse!{fail_class_no_end, r\"[\\z]\"}\n+noparse!{fail_class_no_boundary, r\"[\\b]\"}\n+noparse!{fail_open_paren, \"(\"}\n+noparse!{fail_close_paren, \")\"}\n+noparse!{fail_invalid_range, \"[a-Z]\"}\n+noparse!{fail_empty_capture_name, \"(?P<>a)\"}\n+noparse!{fail_empty_capture_exp, \"(?P<name>)\"}\n+noparse!{fail_bad_capture_name, \"(?P<na-me>)\"}\n+noparse!{fail_bad_flag, \"(?a)a\"}\n+noparse!{fail_empty_alt_before, \"|a\"}\n+noparse!{fail_empty_alt_after, \"a|\"}\n+noparse!{fail_counted_big_exact, \"a{1001}\"}\n+noparse!{fail_counted_big_min, \"a{1001,}\"}\n+noparse!{fail_counted_no_close, \"a{1001\"}\n+noparse!{fail_unfinished_cap, \"(?\"}\n+noparse!{fail_unfinished_escape, \"\\\\\"}\n+noparse!{fail_octal_digit, r\"\\8\"}\n+noparse!{fail_hex_digit, r\"\\xG0\"}\n+noparse!{fail_hex_short, r\"\\xF\"}\n+noparse!{fail_hex_long_digits, r\"\\x{fffg}\"}\n+noparse!{fail_flag_bad, \"(?a)\"}\n+noparse!{fail_flag_empty, \"(?)\"}\n+noparse!{fail_double_neg, \"(?-i-i)\"}\n+noparse!{fail_neg_empty, \"(?i-)\"}\n+noparse!{fail_empty_group, \"()\"}\n+noparse!{fail_dupe_named, \"(?P<a>.)(?P<a>.)\"}\n+noparse!{fail_range_end_no_class, \"[a-[:lower:]]\"}\n+noparse!{fail_range_end_no_begin, r\"[a-\\A]\"}\n+noparse!{fail_range_end_no_end, r\"[a-\\z]\"}\n+noparse!{fail_range_end_no_boundary, r\"[a-\\b]\"}\n+\n+macro_rules! mat {\n     ($name:ident, $re:expr, $text:expr, $($loc:tt)+) => (\n         #[test]\n         fn $name() {\n@@ -166,78 +166,78 @@ macro_rules! mat(\n             }\n         }\n     );\n-)\n+}\n \n // Some crazy expressions from regular-expressions.info.\n-mat!(match_ranges,\n+mat!{match_ranges,\n      r\"\\b(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\b\",\n-     \"num: 255\", Some((5, 8)))\n-mat!(match_ranges_not,\n+     \"num: 255\", Some((5, 8))}\n+mat!{match_ranges_not,\n      r\"\\b(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\b\",\n-     \"num: 256\", None)\n-mat!(match_float1, r\"[-+]?[0-9]*\\.?[0-9]+\", \"0.1\", Some((0, 3)))\n-mat!(match_float2, r\"[-+]?[0-9]*\\.?[0-9]+\", \"0.1.2\", Some((0, 3)))\n-mat!(match_float3, r\"[-+]?[0-9]*\\.?[0-9]+\", \"a1.2\", Some((1, 4)))\n-mat!(match_float4, r\"^[-+]?[0-9]*\\.?[0-9]+$\", \"1.a\", None)\n-mat!(match_email, r\"(?i)\\b[A-Z0-9._%+-]+@[A-Z0-9.-]+\\.[A-Z]{2,4}\\b\",\n-     \"mine is jam.slam@gmail.com \", Some((8, 26)))\n-mat!(match_email_not, r\"(?i)\\b[A-Z0-9._%+-]+@[A-Z0-9.-]+\\.[A-Z]{2,4}\\b\",\n-     \"mine is jam.slam@gmail \", None)\n-mat!(match_email_big, r\"[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\",\n-     \"mine is jam.slam@gmail.com \", Some((8, 26)))\n-mat!(match_date1,\n+     \"num: 256\", None}\n+mat!{match_float1, r\"[-+]?[0-9]*\\.?[0-9]+\", \"0.1\", Some((0, 3))}\n+mat!{match_float2, r\"[-+]?[0-9]*\\.?[0-9]+\", \"0.1.2\", Some((0, 3))}\n+mat!{match_float3, r\"[-+]?[0-9]*\\.?[0-9]+\", \"a1.2\", Some((1, 4))}\n+mat!{match_float4, r\"^[-+]?[0-9]*\\.?[0-9]+$\", \"1.a\", None}\n+mat!{match_email, r\"(?i)\\b[A-Z0-9._%+-]+@[A-Z0-9.-]+\\.[A-Z]{2,4}\\b\",\n+     \"mine is jam.slam@gmail.com \", Some((8, 26))}\n+mat!{match_email_not, r\"(?i)\\b[A-Z0-9._%+-]+@[A-Z0-9.-]+\\.[A-Z]{2,4}\\b\",\n+     \"mine is jam.slam@gmail \", None}\n+mat!{match_email_big, r\"[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\",\n+     \"mine is jam.slam@gmail.com \", Some((8, 26))}\n+mat!{match_date1,\n      r\"^(19|20)\\d\\d[- /.](0[1-9]|1[012])[- /.](0[1-9]|[12][0-9]|3[01])$\",\n-     \"1900-01-01\", Some((0, 10)))\n-mat!(match_date2,\n+     \"1900-01-01\", Some((0, 10))}\n+mat!{match_date2,\n      r\"^(19|20)\\d\\d[- /.](0[1-9]|1[012])[- /.](0[1-9]|[12][0-9]|3[01])$\",\n-     \"1900-00-01\", None)\n-mat!(match_date3,\n+     \"1900-00-01\", None}\n+mat!{match_date3,\n      r\"^(19|20)\\d\\d[- /.](0[1-9]|1[012])[- /.](0[1-9]|[12][0-9]|3[01])$\",\n-     \"1900-13-01\", None)\n+     \"1900-13-01\", None}\n \n // Exercise the flags.\n-mat!(match_flag_case, \"(?i)abc\", \"ABC\", Some((0, 3)))\n-mat!(match_flag_weird_case, \"(?i)a(?-i)bc\", \"Abc\", Some((0, 3)))\n-mat!(match_flag_weird_case_not, \"(?i)a(?-i)bc\", \"ABC\", None)\n-mat!(match_flag_case_dotnl, \"(?is)a.\", \"A\\n\", Some((0, 2)))\n-mat!(match_flag_case_dotnl_toggle, \"(?is)a.(?-is)a.\", \"A\\nab\", Some((0, 4)))\n-mat!(match_flag_case_dotnl_toggle_not, \"(?is)a.(?-is)a.\", \"A\\na\\n\", None)\n-mat!(match_flag_case_dotnl_toggle_ok, \"(?is)a.(?-is:a.)?\", \"A\\na\\n\", Some((0, 2)))\n-mat!(match_flag_multi, \"(?m)(?:^\\\\d+$\\n?)+\", \"123\\n456\\n789\", Some((0, 11)))\n-mat!(match_flag_ungreedy, \"(?U)a+\", \"aa\", Some((0, 1)))\n-mat!(match_flag_ungreedy_greedy, \"(?U)a+?\", \"aa\", Some((0, 2)))\n-mat!(match_flag_ungreedy_noop, \"(?U)(?-U)a+\", \"aa\", Some((0, 2)))\n+mat!{match_flag_case, \"(?i)abc\", \"ABC\", Some((0, 3))}\n+mat!{match_flag_weird_case, \"(?i)a(?-i)bc\", \"Abc\", Some((0, 3))}\n+mat!{match_flag_weird_case_not, \"(?i)a(?-i)bc\", \"ABC\", None}\n+mat!{match_flag_case_dotnl, \"(?is)a.\", \"A\\n\", Some((0, 2))}\n+mat!{match_flag_case_dotnl_toggle, \"(?is)a.(?-is)a.\", \"A\\nab\", Some((0, 4))}\n+mat!{match_flag_case_dotnl_toggle_not, \"(?is)a.(?-is)a.\", \"A\\na\\n\", None}\n+mat!{match_flag_case_dotnl_toggle_ok, \"(?is)a.(?-is:a.)?\", \"A\\na\\n\", Some((0, 2))}\n+mat!{match_flag_multi, \"(?m)(?:^\\\\d+$\\n?)+\", \"123\\n456\\n789\", Some((0, 11))}\n+mat!{match_flag_ungreedy, \"(?U)a+\", \"aa\", Some((0, 1))}\n+mat!{match_flag_ungreedy_greedy, \"(?U)a+?\", \"aa\", Some((0, 2))}\n+mat!{match_flag_ungreedy_noop, \"(?U)(?-U)a+\", \"aa\", Some((0, 2))}\n \n // Some Unicode tests.\n // A couple of these are commented out because something in the guts of macro expansion is creating\n // invalid byte strings.\n-//mat!(uni_literal, r\"\u2160\", \"\u2160\", Some((0, 3)))\n-mat!(uni_one, r\"\\pN\", \"\u2160\", Some((0, 3)))\n-mat!(uni_mixed, r\"\\pN+\", \"\u21601\u21612\", Some((0, 8)))\n-mat!(uni_not, r\"\\PN+\", \"ab\u2160\", Some((0, 2)))\n-mat!(uni_not_class, r\"[\\PN]+\", \"ab\u2160\", Some((0, 2)))\n-mat!(uni_not_class_neg, r\"[^\\PN]+\", \"ab\u2160\", Some((2, 5)))\n-mat!(uni_case, r\"(?i)\u0394\", \"\u03b4\", Some((0, 2)))\n-//mat!(uni_case_not, r\"\u0394\", \"\u03b4\", None)\n-mat!(uni_case_upper, r\"\\p{Lu}+\", \"\u039b\u0398\u0393\u0394\u03b1\", Some((0, 8)))\n-mat!(uni_case_upper_nocase_flag, r\"(?i)\\p{Lu}+\", \"\u039b\u0398\u0393\u0394\u03b1\", Some((0, 10)))\n-mat!(uni_case_upper_nocase, r\"\\p{L}+\", \"\u039b\u0398\u0393\u0394\u03b1\", Some((0, 10)))\n-mat!(uni_case_lower, r\"\\p{Ll}+\", \"\u039b\u0398\u0393\u0394\u03b1\", Some((8, 10)))\n+//mat!{uni_literal, r\"\u2160\", \"\u2160\", Some((0, 3))}\n+mat!{uni_one, r\"\\pN\", \"\u2160\", Some((0, 3))}\n+mat!{uni_mixed, r\"\\pN+\", \"\u21601\u21612\", Some((0, 8))}\n+mat!{uni_not, r\"\\PN+\", \"ab\u2160\", Some((0, 2))}\n+mat!{uni_not_class, r\"[\\PN]+\", \"ab\u2160\", Some((0, 2))}\n+mat!{uni_not_class_neg, r\"[^\\PN]+\", \"ab\u2160\", Some((2, 5))}\n+mat!{uni_case, r\"(?i)\u0394\", \"\u03b4\", Some((0, 2))}\n+//mat!{uni_case_not, r\"\u0394\", \"\u03b4\", None}\n+mat!{uni_case_upper, r\"\\p{Lu}+\", \"\u039b\u0398\u0393\u0394\u03b1\", Some((0, 8))}\n+mat!{uni_case_upper_nocase_flag, r\"(?i)\\p{Lu}+\", \"\u039b\u0398\u0393\u0394\u03b1\", Some((0, 10))}\n+mat!{uni_case_upper_nocase, r\"\\p{L}+\", \"\u039b\u0398\u0393\u0394\u03b1\", Some((0, 10))}\n+mat!{uni_case_lower, r\"\\p{Ll}+\", \"\u039b\u0398\u0393\u0394\u03b1\", Some((8, 10))}\n \n // Test the Unicode friendliness of Perl character classes.\n-mat!(uni_perl_w, r\"\\w+\", \"d\u03b4d\", Some((0, 4)))\n-mat!(uni_perl_w_not, r\"\\w+\", \"\u2961\", None)\n-mat!(uni_perl_w_neg, r\"\\W+\", \"\u2961\", Some((0, 3)))\n-mat!(uni_perl_d, r\"\\d+\", \"1\u0968\u09699\", Some((0, 8)))\n-mat!(uni_perl_d_not, r\"\\d+\", \"\u2161\", None)\n-mat!(uni_perl_d_neg, r\"\\D+\", \"\u2161\", Some((0, 3)))\n-mat!(uni_perl_s, r\"\\s+\", \"\u1680\", Some((0, 3)))\n-mat!(uni_perl_s_not, r\"\\s+\", \"\u2603\", None)\n-mat!(uni_perl_s_neg, r\"\\S+\", \"\u2603\", Some((0, 3)))\n+mat!{uni_perl_w, r\"\\w+\", \"d\u03b4d\", Some((0, 4))}\n+mat!{uni_perl_w_not, r\"\\w+\", \"\u2961\", None}\n+mat!{uni_perl_w_neg, r\"\\W+\", \"\u2961\", Some((0, 3))}\n+mat!{uni_perl_d, r\"\\d+\", \"1\u0968\u09699\", Some((0, 8))}\n+mat!{uni_perl_d_not, r\"\\d+\", \"\u2161\", None}\n+mat!{uni_perl_d_neg, r\"\\D+\", \"\u2161\", Some((0, 3))}\n+mat!{uni_perl_s, r\"\\s+\", \"\u1680\", Some((0, 3))}\n+mat!{uni_perl_s_not, r\"\\s+\", \"\u2603\", None}\n+mat!{uni_perl_s_neg, r\"\\S+\", \"\u2603\", Some((0, 3))}\n \n // And do the same for word boundaries.\n-mat!(uni_boundary_none, r\"\\d\\b\", \"6\u03b4\", None)\n-mat!(uni_boundary_ogham, r\"\\d\\b\", \"6\u1680\", Some((0, 1)))\n+mat!{uni_boundary_none, r\"\\d\\b\", \"6\u03b4\", None}\n+mat!{uni_boundary_ogham, r\"\\d\\b\", \"6\u1680\", Some((0, 1))}\n \n // A whole mess of tests from Glenn Fowler's regex test suite.\n // Generated by the 'src/etc/regex-match-tests' program."}, {"sha": "4c3cb99f64d06dcfd7f97f95dcf0aaa5187989a5", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -10,16 +10,16 @@\n \n #![allow(non_snake_case)]\n \n-register_diagnostic!(E0001, r##\"\n+register_diagnostic! { E0001, r##\"\n     This error suggests that the expression arm corresponding to the noted pattern\n     will never be reached as for all possible values of the expression being matched,\n     one of the preceeding patterns will match.\n \n     This means that perhaps some of the preceeding patterns are too general, this\n     one is too specific or the ordering is incorrect.\n-\"##)\n+\"## }\n \n-register_diagnostics!(\n+register_diagnostics! {\n     E0002,\n     E0003,\n     E0004,\n@@ -68,4 +68,4 @@ register_diagnostics!(\n     E0174,\n     E0177,\n     E0178\n-)\n+}"}, {"sha": "d87fbb016208a5cf8734ddcdd33d5bed8baf565b", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -121,7 +121,7 @@ pub mod lib {\n     pub use llvm;\n }\n \n-__build_diagnostic_array!(DIAGNOSTICS)\n+__build_diagnostic_array! { DIAGNOSTICS }\n \n // A private module so that macro-expanded idents like\n // `::rustc::lint::Lint` will also work in `rustc` itself."}, {"sha": "8c25bc702b3365edabfccd87574a310c274e2c34", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 205, "deletions": 82, "changes": 287, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -50,8 +50,11 @@ use syntax::ast_util;\n use syntax::ptr::P;\n use syntax::visit::{mod, Visitor};\n \n-declare_lint!(WHILE_TRUE, Warn,\n-              \"suggest using `loop { }` instead of `while true { }`\")\n+declare_lint! {\n+    WHILE_TRUE,\n+    Warn,\n+    \"suggest using `loop { }` instead of `while true { }`\"\n+}\n \n pub struct WhileTrue;\n \n@@ -74,8 +77,11 @@ impl LintPass for WhileTrue {\n     }\n }\n \n-declare_lint!(UNUSED_TYPECASTS, Allow,\n-              \"detects unnecessary type casts, that can be removed\")\n+declare_lint! {\n+    UNUSED_TYPECASTS,\n+    Allow,\n+    \"detects unnecessary type casts that can be removed\"\n+}\n \n pub struct UnusedCasts;\n \n@@ -96,17 +102,29 @@ impl LintPass for UnusedCasts {\n     }\n }\n \n-declare_lint!(UNSIGNED_NEGATION, Warn,\n-              \"using an unary minus operator on unsigned type\")\n+declare_lint! {\n+    UNSIGNED_NEGATION,\n+    Warn,\n+    \"using an unary minus operator on unsigned type\"\n+}\n \n-declare_lint!(UNUSED_COMPARISONS, Warn,\n-              \"comparisons made useless by limits of the types involved\")\n+declare_lint! {\n+    UNUSED_COMPARISONS,\n+    Warn,\n+    \"comparisons made useless by limits of the types involved\"\n+}\n \n-declare_lint!(OVERFLOWING_LITERALS, Warn,\n-              \"literal out of range for its type\")\n+declare_lint! {\n+    OVERFLOWING_LITERALS,\n+    Warn,\n+    \"literal out of range for its type\"\n+}\n \n-declare_lint!(EXCEEDING_BITSHIFTS, Deny,\n-              \"shift exceeds the type's number of bits\")\n+declare_lint! {\n+    EXCEEDING_BITSHIFTS,\n+    Deny,\n+    \"shift exceeds the type's number of bits\"\n+}\n \n pub struct TypeLimits {\n     /// Id of the last visited negated expression\n@@ -373,8 +391,11 @@ impl LintPass for TypeLimits {\n     }\n }\n \n-declare_lint!(IMPROPER_CTYPES, Warn,\n-              \"proper use of libc types in foreign modules\")\n+declare_lint! {\n+    IMPROPER_CTYPES,\n+    Warn,\n+    \"proper use of libc types in foreign modules\"\n+}\n \n struct ImproperCTypesVisitor<'a, 'tcx: 'a> {\n     cx: &'a Context<'a, 'tcx>\n@@ -459,8 +480,11 @@ impl LintPass for ImproperCTypes {\n     }\n }\n \n-declare_lint!(BOX_POINTERS, Allow,\n-              \"use of owned (Box type) heap memory\")\n+declare_lint! {\n+    BOX_POINTERS,\n+    Allow,\n+    \"use of owned (Box type) heap memory\"\n+}\n \n pub struct BoxPointers;\n \n@@ -527,8 +551,11 @@ impl LintPass for BoxPointers {\n     }\n }\n \n-declare_lint!(RAW_POINTER_DERIVING, Warn,\n-              \"uses of #[deriving] with raw pointers are rarely correct\")\n+declare_lint! {\n+    RAW_POINTER_DERIVING,\n+    Warn,\n+    \"uses of #[deriving] with raw pointers are rarely correct\"\n+}\n \n struct RawPtrDerivingVisitor<'a, 'tcx: 'a> {\n     cx: &'a Context<'a, 'tcx>\n@@ -594,8 +621,11 @@ impl LintPass for RawPointerDeriving {\n     }\n }\n \n-declare_lint!(UNUSED_ATTRIBUTES, Warn,\n-              \"detects attributes that were not used by the compiler\")\n+declare_lint! {\n+    UNUSED_ATTRIBUTES,\n+    Warn,\n+    \"detects attributes that were not used by the compiler\"\n+}\n \n pub struct UnusedAttributes;\n \n@@ -675,8 +705,11 @@ impl LintPass for UnusedAttributes {\n     }\n }\n \n-declare_lint!(pub PATH_STATEMENTS, Warn,\n-              \"path statements with no effect\")\n+declare_lint! {\n+    pub PATH_STATEMENTS,\n+    Warn,\n+    \"path statements with no effect\"\n+}\n \n pub struct PathStatements;\n \n@@ -701,11 +734,17 @@ impl LintPass for PathStatements {\n     }\n }\n \n-declare_lint!(pub UNUSED_MUST_USE, Warn,\n-              \"unused result of a type flagged as #[must_use]\")\n+declare_lint! {\n+    pub UNUSED_MUST_USE,\n+    Warn,\n+    \"unused result of a type flagged as #[must_use]\"\n+}\n \n-declare_lint!(pub UNUSED_RESULTS, Allow,\n-              \"unused result of an expression in a statement\")\n+declare_lint! {\n+    pub UNUSED_RESULTS,\n+    Allow,\n+    \"unused result of an expression in a statement\"\n+}\n \n pub struct UnusedResults;\n \n@@ -770,8 +809,11 @@ impl LintPass for UnusedResults {\n     }\n }\n \n-declare_lint!(pub NON_CAMEL_CASE_TYPES, Warn,\n-              \"types, variants, traits and type parameters should have camel case names\")\n+declare_lint! {\n+    pub NON_CAMEL_CASE_TYPES,\n+    Warn,\n+    \"types, variants, traits and type parameters should have camel case names\"\n+}\n \n pub struct NonCamelCaseTypes;\n \n@@ -891,8 +933,11 @@ fn method_context(cx: &Context, m: &ast::Method) -> MethodContext {\n     }\n }\n \n-declare_lint!(pub NON_SNAKE_CASE, Warn,\n-              \"methods, functions, lifetime parameters and modules should have snake case names\")\n+declare_lint! {\n+    pub NON_SNAKE_CASE,\n+    Warn,\n+    \"methods, functions, lifetime parameters and modules should have snake case names\"\n+}\n \n pub struct NonSnakeCase;\n \n@@ -1002,8 +1047,11 @@ impl LintPass for NonSnakeCase {\n     }\n }\n \n-declare_lint!(pub NON_UPPER_CASE_GLOBALS, Warn,\n-              \"static constants should have uppercase identifiers\")\n+declare_lint! {\n+    pub NON_UPPER_CASE_GLOBALS,\n+    Warn,\n+    \"static constants should have uppercase identifiers\"\n+}\n \n pub struct NonUpperCaseGlobals;\n \n@@ -1053,8 +1101,11 @@ impl LintPass for NonUpperCaseGlobals {\n     }\n }\n \n-declare_lint!(UNUSED_PARENS, Warn,\n-              \"`if`, `match`, `while` and `return` do not need parentheses\")\n+declare_lint! {\n+    UNUSED_PARENS,\n+    Warn,\n+    \"`if`, `match`, `while` and `return` do not need parentheses\"\n+}\n \n pub struct UnusedParens;\n \n@@ -1145,8 +1196,11 @@ impl LintPass for UnusedParens {\n     }\n }\n \n-declare_lint!(UNUSED_IMPORT_BRACES, Allow,\n-              \"unnecessary braces around an imported item\")\n+declare_lint! {\n+    UNUSED_IMPORT_BRACES,\n+    Allow,\n+    \"unnecessary braces around an imported item\"\n+}\n \n pub struct UnusedImportBraces;\n \n@@ -1182,8 +1236,11 @@ impl LintPass for UnusedImportBraces {\n     }\n }\n \n-declare_lint!(NON_SHORTHAND_FIELD_PATTERNS, Warn,\n-              \"using `Struct { x: x }` instead of `Struct { x }`\")\n+declare_lint! {\n+    NON_SHORTHAND_FIELD_PATTERNS,\n+    Warn,\n+    \"using `Struct { x: x }` instead of `Struct { x }`\"\n+}\n \n pub struct NonShorthandFieldPatterns;\n \n@@ -1213,8 +1270,11 @@ impl LintPass for NonShorthandFieldPatterns {\n     }\n }\n \n-declare_lint!(pub UNUSED_UNSAFE, Warn,\n-              \"unnecessary use of an `unsafe` block\")\n+declare_lint! {\n+    pub UNUSED_UNSAFE,\n+    Warn,\n+    \"unnecessary use of an `unsafe` block\"\n+}\n \n pub struct UnusedUnsafe;\n \n@@ -1236,8 +1296,11 @@ impl LintPass for UnusedUnsafe {\n     }\n }\n \n-declare_lint!(UNSAFE_BLOCKS, Allow,\n-              \"usage of an `unsafe` block\")\n+declare_lint! {\n+    UNSAFE_BLOCKS,\n+    Allow,\n+    \"usage of an `unsafe` block\"\n+}\n \n pub struct UnsafeBlocks;\n \n@@ -1258,8 +1321,11 @@ impl LintPass for UnsafeBlocks {\n     }\n }\n \n-declare_lint!(pub UNUSED_MUT, Warn,\n-              \"detect mut variables which don't need to be mutable\")\n+declare_lint! {\n+    pub UNUSED_MUT,\n+    Warn,\n+    \"detect mut variables which don't need to be mutable\"\n+}\n \n pub struct UnusedMut;\n \n@@ -1325,8 +1391,11 @@ impl LintPass for UnusedMut {\n     }\n }\n \n-declare_lint!(UNUSED_ALLOCATION, Warn,\n-              \"detects unnecessary allocations that can be eliminated\")\n+declare_lint! {\n+    UNUSED_ALLOCATION,\n+    Warn,\n+    \"detects unnecessary allocations that can be eliminated\"\n+}\n \n pub struct UnusedAllocation;\n \n@@ -1361,8 +1430,11 @@ impl LintPass for UnusedAllocation {\n     }\n }\n \n-declare_lint!(MISSING_DOCS, Allow,\n-              \"detects missing documentation for public members\")\n+declare_lint! {\n+    MISSING_DOCS,\n+    Allow,\n+    \"detects missing documentation for public members\"\n+}\n \n pub struct MissingDoc {\n     /// Stack of IDs of struct definitions.\n@@ -1572,15 +1644,24 @@ impl LintPass for MissingCopyImplementations {\n     }\n }\n \n-declare_lint!(DEPRECATED, Warn,\n-              \"detects use of #[deprecated] items\")\n+declare_lint! {\n+    DEPRECATED,\n+    Warn,\n+    \"detects use of #[deprecated] items\"\n+}\n \n // FIXME #6875: Change to Warn after std library stabilization is complete\n-declare_lint!(EXPERIMENTAL, Allow,\n-              \"detects use of #[experimental] items\")\n+declare_lint! {\n+    EXPERIMENTAL,\n+    Allow,\n+    \"detects use of #[experimental] items\"\n+}\n \n-declare_lint!(UNSTABLE, Allow,\n-              \"detects use of #[unstable] items (incl. items with no stability attribute)\")\n+declare_lint! {\n+    UNSTABLE,\n+    Allow,\n+    \"detects use of #[unstable] items (incl. items with no stability attribute)\"\n+}\n \n /// Checks for use of items with `#[deprecated]`, `#[experimental]` and\n /// `#[unstable]` attributes, or no stability attribute.\n@@ -1738,47 +1819,89 @@ impl LintPass for Stability {\n     }\n }\n \n-declare_lint!(pub UNUSED_IMPORTS, Warn,\n-              \"imports that are never used\")\n+declare_lint! {\n+    pub UNUSED_IMPORTS,\n+    Warn,\n+    \"imports that are never used\"\n+}\n \n-declare_lint!(pub UNUSED_EXTERN_CRATES, Allow,\n-              \"extern crates that are never used\")\n+declare_lint! {\n+    pub UNUSED_EXTERN_CRATES,\n+    Allow,\n+    \"extern crates that are never used\"\n+}\n \n-declare_lint!(pub UNUSED_QUALIFICATIONS, Allow,\n-              \"detects unnecessarily qualified names\")\n+declare_lint! {\n+    pub UNUSED_QUALIFICATIONS,\n+    Allow,\n+    \"detects unnecessarily qualified names\"\n+}\n \n-declare_lint!(pub UNKNOWN_LINTS, Warn,\n-              \"unrecognized lint attribute\")\n+declare_lint! {\n+    pub UNKNOWN_LINTS,\n+    Warn,\n+    \"unrecognized lint attribute\"\n+}\n \n-declare_lint!(pub UNUSED_VARIABLES, Warn,\n-              \"detect variables which are not used in any way\")\n+declare_lint! {\n+    pub UNUSED_VARIABLES,\n+    Warn,\n+    \"detect variables which are not used in any way\"\n+}\n \n-declare_lint!(pub UNUSED_ASSIGNMENTS, Warn,\n-              \"detect assignments that will never be read\")\n+declare_lint! {\n+    pub UNUSED_ASSIGNMENTS,\n+    Warn,\n+    \"detect assignments that will never be read\"\n+}\n \n-declare_lint!(pub DEAD_CODE, Warn,\n-              \"detect unused, unexported items\")\n+declare_lint! {\n+    pub DEAD_CODE,\n+    Warn,\n+    \"detect unused, unexported items\"\n+}\n \n-declare_lint!(pub UNREACHABLE_CODE, Warn,\n-              \"detects unreachable code paths\")\n+declare_lint! {\n+    pub UNREACHABLE_CODE,\n+    Warn,\n+    \"detects unreachable code paths\"\n+}\n \n-declare_lint!(pub WARNINGS, Warn,\n-              \"mass-change the level for lints which produce warnings\")\n+declare_lint! {\n+    pub WARNINGS,\n+    Warn,\n+    \"mass-change the level for lints which produce warnings\"\n+}\n \n-declare_lint!(pub UNKNOWN_FEATURES, Deny,\n-              \"unknown features found in crate-level #[feature] directives\")\n+declare_lint! {\n+    pub UNKNOWN_FEATURES,\n+    Deny,\n+    \"unknown features found in crate-level #[feature] directives\"\n+}\n \n-declare_lint!(pub UNKNOWN_CRATE_TYPES, Deny,\n-              \"unknown crate type found in #[crate_type] directive\")\n+declare_lint! {\n+    pub UNKNOWN_CRATE_TYPES,\n+    Deny,\n+    \"unknown crate type found in #[crate_type] directive\"\n+}\n \n-declare_lint!(pub VARIANT_SIZE_DIFFERENCES, Allow,\n-              \"detects enums with widely varying variant sizes\")\n+declare_lint! {\n+    pub VARIANT_SIZE_DIFFERENCES,\n+    Allow,\n+    \"detects enums with widely varying variant sizes\"\n+}\n \n-declare_lint!(pub FAT_PTR_TRANSMUTES, Allow,\n-              \"detects transmutes of fat pointers\")\n+declare_lint! {\n+    pub FAT_PTR_TRANSMUTES,\n+    Allow,\n+    \"detects transmutes of fat pointers\"\n+}\n \n-declare_lint!(pub MISSING_COPY_IMPLEMENTATIONS, Warn,\n-              \"detects potentially-forgotten implementations of `Copy`\")\n+declare_lint!{\n+    pub MISSING_COPY_IMPLEMENTATIONS,\n+    Warn,\n+    \"detects potentially-forgotten implementations of `Copy`\"\n+}\n \n /// Does nothing as a lint pass, but registers some `Lint`s\n /// which are used by other parts of the compiler."}, {"sha": "d8d9d653e62f78b811ad10737aa8e70d5faa7407", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -171,17 +171,17 @@ impl LintStore {\n             {$(\n                 self.register_pass($sess, false, box builtin::$name as LintPassObject);\n             )*}\n-        ))\n+        ));\n \n         macro_rules! add_builtin_with_new ( ( $sess:ident, $($name:ident),*, ) => (\n             {$(\n                 self.register_pass($sess, false, box builtin::$name::new() as LintPassObject);\n             )*}\n-        ))\n+        ));\n \n         macro_rules! add_lint_group ( ( $sess:ident, $name:expr, $($lint:ident),* ) => (\n             self.register_group($sess, false, $name, vec![$(LintId::of(builtin::$lint)),*]);\n-        ))\n+        ));\n \n         add_builtin!(sess,\n                      HardwiredLints,\n@@ -204,21 +204,21 @@ impl LintStore {\n                      UnusedAllocation,\n                      Stability,\n                      MissingCopyImplementations,\n-        )\n+        );\n \n         add_builtin_with_new!(sess,\n                               TypeLimits,\n                               RawPointerDeriving,\n                               MissingDoc,\n-        )\n+        );\n \n         add_lint_group!(sess, \"bad_style\",\n-                        NON_CAMEL_CASE_TYPES, NON_SNAKE_CASE, NON_UPPER_CASE_GLOBALS)\n+                        NON_CAMEL_CASE_TYPES, NON_SNAKE_CASE, NON_UPPER_CASE_GLOBALS);\n \n         add_lint_group!(sess, \"unused\",\n                         UNUSED_IMPORTS, UNUSED_VARIABLES, UNUSED_ASSIGNMENTS, DEAD_CODE,\n                         UNUSED_MUT, UNREACHABLE_CODE, UNUSED_MUST_USE,\n-                        UNUSED_UNSAFE, PATH_STATEMENTS)\n+                        UNUSED_UNSAFE, PATH_STATEMENTS);\n \n         // We have one lint pass defined in this module.\n         self.register_pass(sess, false, box GatherNodeLevels as LintPassObject);\n@@ -318,15 +318,15 @@ pub struct Context<'a, 'tcx: 'a> {\n }\n \n /// Convenience macro for calling a `LintPass` method on every pass in the context.\n-macro_rules! run_lints ( ($cx:expr, $f:ident, $($args:expr),*) => ({\n+macro_rules! run_lints { ($cx:expr, $f:ident, $($args:expr),*) => ({\n     // Move the vector of passes out of `$cx` so that we can\n     // iterate over it mutably while passing `$cx` to the methods.\n     let mut passes = $cx.lints.passes.take().unwrap();\n     for obj in passes.iter_mut() {\n         obj.$f($cx, $($args),*);\n     }\n     $cx.lints.passes = Some(passes);\n-}))\n+}) }\n \n /// Parse the lint attributes into a vector, with `Err`s for malformed lint\n /// attributes. Writing this as an iterator is an enormous mess."}, {"sha": "79d57305f964205871e48be554b5f22f69ac5c7c", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -75,19 +75,19 @@ impl Lint {\n \n /// Build a `Lint` initializer.\n #[macro_export]\n-macro_rules! lint_initializer (\n+macro_rules! lint_initializer {\n     ($name:ident, $level:ident, $desc:expr) => (\n         ::rustc::lint::Lint {\n             name: stringify!($name),\n             default_level: ::rustc::lint::$level,\n             desc: $desc,\n         }\n     )\n-)\n+}\n \n /// Declare a static item of type `&'static Lint`.\n #[macro_export]\n-macro_rules! declare_lint (\n+macro_rules! declare_lint {\n     // FIXME(#14660): deduplicate\n     (pub $name:ident, $level:ident, $desc:expr) => (\n         pub static $name: &'static ::rustc::lint::Lint\n@@ -97,17 +97,17 @@ macro_rules! declare_lint (\n         static $name: &'static ::rustc::lint::Lint\n             = &lint_initializer!($name, $level, $desc);\n     );\n-)\n+}\n \n /// Declare a static `LintArray` and return it as an expression.\n #[macro_export]\n-macro_rules! lint_array ( ($( $lint:expr ),*) => (\n+macro_rules! lint_array { ($( $lint:expr ),*) => (\n     {\n         #[allow(non_upper_case_globals)]\n         static array: LintArray = &[ $( &$lint ),* ];\n         array\n     }\n-))\n+) }\n \n pub type LintArray = &'static [&'static &'static Lint];\n "}, {"sha": "2a057da7db3681a828b3c0986f53c4adb997a5e2", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -29,7 +29,7 @@ use syntax::parse::token;\n \n use rbml::io::SeekableMemWriter;\n \n-macro_rules! mywrite( ($($arg:tt)*) => ({ write!($($arg)*); }) )\n+macro_rules! mywrite { ($($arg:tt)*) => ({ write!($($arg)*); }) }\n \n pub struct ctxt<'a, 'tcx: 'a> {\n     pub diag: &'a SpanHandler,"}, {"sha": "f0d52d1ac23d07ada285937c04fba05016b413b7", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -525,7 +525,7 @@ pub fn eval_const_expr_partial(tcx: &ty::ctxt, e: &Expr) -> Result<const_val, St\n                 },)*\n                 _ => Err(\"can't cast this type\".to_string())\n             })\n-        )\n+        );\n \n         eval_const_expr_partial(tcx, &**base)\n             .and_then(|val| define_casts!(val, {"}, {"sha": "aacb994e5a49be40346c81996a72ed0495c81b03", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -320,14 +320,14 @@ pub struct ExprUseVisitor<'d,'t,'tcx,TYPER:'t> {\n //\n // Note that this macro appears similar to try!(), but, unlike try!(),\n // it does not propagate the error.\n-macro_rules! return_if_err(\n+macro_rules! return_if_err {\n     ($inp: expr) => (\n         match $inp {\n             Ok(v) => v,\n             Err(()) => return\n         }\n     )\n-)\n+}\n \n /// Whether the elements of an overloaded operation are passed by value or by reference\n enum PassArgs {"}, {"sha": "ab685dd5dbc13a2f9ba53eb758d1558d34035148", "filename": "src/librustc/middle/infer/error_reporting.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -224,7 +224,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n         for error in errors.iter() {\n             match error.clone() {\n                 ConcreteFailure(origin, sub, sup) => {\n-                    debug!(\"processing ConcreteFailure\")\n+                    debug!(\"processing ConcreteFailure\");\n                     let trace = match origin {\n                         infer::Subtype(trace) => Some(trace),\n                         _ => None,\n@@ -241,7 +241,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     }\n                 }\n                 SubSupConflict(var_origin, _, sub_r, _, sup_r) => {\n-                    debug!(\"processing SubSupConflict\")\n+                    debug!(\"processing SubSupConflict\");\n                     match free_regions_from_same_fn(self.tcx, sub_r, sup_r) {\n                         Some(ref same_frs) => {\n                             var_origins.push(var_origin);\n@@ -324,7 +324,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     _ => None\n                 },\n                 None => {\n-                    debug!(\"no parent node of scope_id {}\", scope_id)\n+                    debug!(\"no parent node of scope_id {}\", scope_id);\n                     None\n                 }\n             }"}, {"sha": "0e05eb4dcdd9a68d484890c7a2a786d1cd508c22", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -389,14 +389,14 @@ impl MutabilityCategory {\n     }\n }\n \n-macro_rules! if_ok(\n+macro_rules! if_ok {\n     ($inp: expr) => (\n         match $inp {\n             Ok(v) => { v }\n             Err(e) => { return Err(e); }\n         }\n     )\n-)\n+}\n \n impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n     pub fn new(typer: &'t TYPER) -> MemCategorizationContext<'t,TYPER> {"}, {"sha": "b349b5ca0bf239ee8f2eb46a9f7a1104e17e778e", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -1223,7 +1223,7 @@ pub fn mk_prim_t<'tcx>(primitive: &'tcx TyS<'static>) -> Ty<'tcx> {\n \n // Do not change these from static to const, interning types requires\n // the primitives to have a significant address.\n-macro_rules! def_prim_tys(\n+macro_rules! def_prim_tys {\n     ($($name:ident -> $sty:expr;)*) => (\n         $(#[inline] pub fn $name<'tcx>() -> Ty<'tcx> {\n             static PRIM_TY: TyS<'static> = TyS {\n@@ -1234,7 +1234,7 @@ macro_rules! def_prim_tys(\n             mk_prim_t(&PRIM_TY)\n         })*\n     )\n-)\n+}\n \n def_prim_tys!{\n     mk_bool ->  ty_bool;\n@@ -2739,7 +2739,7 @@ pub struct TypeContents {\n \n impl Copy for TypeContents {}\n \n-macro_rules! def_type_content_sets(\n+macro_rules! def_type_content_sets {\n     (mod $mname:ident { $($name:ident = $bits:expr),+ }) => {\n         #[allow(non_snake_case)]\n         mod $mname {\n@@ -2750,9 +2750,9 @@ macro_rules! def_type_content_sets(\n              )+\n         }\n     }\n-)\n+}\n \n-def_type_content_sets!(\n+def_type_content_sets! {\n     mod TC {\n         None                                = 0b0000_0000__0000_0000__0000,\n \n@@ -2790,7 +2790,7 @@ def_type_content_sets!(\n         // All bits\n         All                                 = 0b1111_1111__1111_1111__1111\n     }\n-)\n+}\n \n impl TypeContents {\n     pub fn when(&self, cond: bool) -> TypeContents {\n@@ -3113,7 +3113,7 @@ pub fn type_contents<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> TypeContents {\n \n             ty_open(ty) => {\n                 let result = tc_ty(cx, ty, cache);\n-                assert!(!result.is_sized(cx))\n+                assert!(!result.is_sized(cx));\n                 result.unsafe_pointer() | TC::Nonsized\n             }\n \n@@ -3644,7 +3644,7 @@ pub fn unsized_part_of_type<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> {\n             let unsized_fields: Vec<_> = struct_fields(cx, def_id, substs).iter()\n                 .map(|f| f.mt.ty).filter(|ty| !type_is_sized(cx, *ty)).collect();\n             // Exactly one of the fields must be unsized.\n-            assert!(unsized_fields.len() == 1)\n+            assert!(unsized_fields.len() == 1);\n \n             unsized_part_of_type(cx, unsized_fields[0])\n         }"}, {"sha": "892a8004fec1c99ecd4efae1b9d22fc7f6125de0", "filename": "src/librustc/middle/weak_lang_items.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -23,7 +23,8 @@ use syntax::visit;\n \n use std::collections::HashSet;\n \n-macro_rules! weak_lang_items( ($($name:ident, $item:ident, $sym:ident;)*) => (\n+macro_rules! weak_lang_items {\n+    ($($name:ident, $item:ident, $sym:ident;)*) => (\n \n struct Context<'a> {\n     sess: &'a Session,\n@@ -115,10 +116,10 @@ impl<'a, 'v> Visitor<'v> for Context<'a> {\n     }\n }\n \n-) )\n+) }\n \n-weak_lang_items!(\n+weak_lang_items! {\n     panic_fmt,          PanicFmtLangItem,            rust_begin_unwind;\n     stack_exhausted,    StackExhaustedLangItem,     rust_stack_exhausted;\n     eh_personality,     EhPersonalityLangItem,      rust_eh_personality;\n-)\n+}"}, {"sha": "59da0af417cfb33cfa27f7b505b50482c20a3975", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -239,17 +239,17 @@ pub enum CrateType {\n \n impl Copy for CrateType {}\n \n-macro_rules! debugging_opts(\n+macro_rules! debugging_opts {\n     ([ $opt:ident ] $cnt:expr ) => (\n         pub const $opt: u64 = 1 << $cnt;\n     );\n     ([ $opt:ident, $($rest:ident),* ] $cnt:expr ) => (\n         pub const $opt: u64 = 1 << $cnt;\n-        debugging_opts!([ $($rest),* ] $cnt + 1)\n+        debugging_opts! { [ $($rest),* ] $cnt + 1 }\n     )\n-)\n+}\n \n-debugging_opts!(\n+debugging_opts! {\n     [\n         VERBOSE,\n         TIME_PASSES,\n@@ -280,7 +280,7 @@ debugging_opts!(\n         PRINT_REGION_GRAPH\n     ]\n     0\n-)\n+}\n \n pub fn debugging_opts_map() -> Vec<(&'static str, &'static str, u64)> {\n     vec![(\"verbose\", \"in general, enable more debug printouts\", VERBOSE),\n@@ -354,7 +354,7 @@ impl Passes {\n /// cgsetters module which is a bunch of generated code to parse an option into\n /// its respective field in the struct. There are a few hand-written parsers for\n /// parsing specific types of values in this module.\n-macro_rules! cgoptions(\n+macro_rules! cgoptions {\n     ($($opt:ident : $t:ty = ($init:expr, $parse:ident, $desc:expr)),* ,) =>\n (\n     #[deriving(Clone)]\n@@ -469,9 +469,9 @@ macro_rules! cgoptions(\n             }\n         }\n     }\n-) )\n+) }\n \n-cgoptions!(\n+cgoptions! {\n     ar: Option<String> = (None, parse_opt_string,\n         \"tool to assemble archives with\"),\n     linker: Option<String> = (None, parse_opt_string,\n@@ -520,7 +520,7 @@ cgoptions!(\n         \"print remarks for these optimization passes (space separated, or \\\"all\\\")\"),\n     no_stack_check: bool = (false, parse_bool,\n         \"disable checks for stack exhaustion (a memory-safety hazard!)\"),\n-)\n+}\n \n pub fn build_codegen_options(matches: &getopts::Matches) -> CodegenOptions\n {"}, {"sha": "074341ccff49db6fbb6ce235df1461ca63e8cf23", "filename": "src/librustc_back/sha2.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibrustc_back%2Fsha2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibrustc_back%2Fsha2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fsha2.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -349,7 +349,7 @@ impl Engine256State {\n         macro_rules! schedule_round( ($t:expr) => (\n                 w[$t] = sigma1(w[$t - 2]) + w[$t - 7] + sigma0(w[$t - 15]) + w[$t - 16];\n                 )\n-        )\n+        );\n \n         macro_rules! sha2_round(\n             ($A:ident, $B:ident, $C:ident, $D:ident,\n@@ -360,7 +360,7 @@ impl Engine256State {\n                     $H += sum0($A) + maj($A, $B, $C);\n                 }\n              )\n-        )\n+        );\n \n         read_u32v_be(w[mut 0..16], data);\n \n@@ -454,7 +454,7 @@ impl Engine256 {\n     }\n \n     fn input(&mut self, input: &[u8]) {\n-        assert!(!self.finished)\n+        assert!(!self.finished);\n         // Assumes that input.len() can be converted to u64 without overflow\n         self.length_bits = add_bytes_to_bits(self.length_bits, input.len() as u64);\n         let self_state = &mut self.state;"}, {"sha": "98fa659ba55ea24f8cc720c7620a11c8923f77ed", "filename": "src/librustc_back/svh.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibrustc_back%2Fsvh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibrustc_back%2Fsvh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fsvh.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -340,14 +340,17 @@ mod svh_visitor {\n                 // expensive; a direct content-based hash on token\n                 // trees might be faster. Implementing this is far\n                 // easier in short term.\n-                let macro_defn_as_string =\n-                    pprust::to_string(|pp_state| pp_state.print_mac(macro));\n+                let macro_defn_as_string = pprust::to_string(|pp_state| {\n+                    pp_state.print_mac(macro, token::Paren)\n+                });\n                 macro_defn_as_string.hash(self.st);\n             } else {\n                 // It is not possible to observe any kind of macro\n                 // invocation at this stage except `macro_rules!`.\n                 panic!(\"reached macro somehow: {}\",\n-                      pprust::to_string(|pp_state| pp_state.print_mac(macro)));\n+                      pprust::to_string(|pp_state| {\n+                          pp_state.print_mac(macro, token::Paren)\n+                      }));\n             }\n \n             visit::walk_mac(self, macro);"}, {"sha": "d12cb356e3faad1b62cc01968f75d9a841926c14", "filename": "src/librustc_back/target/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmod.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -256,7 +256,7 @@ impl Target {\n                         )\n                     );\n             } );\n-        )\n+        );\n \n         key!(cpu);\n         key!(linker);\n@@ -325,7 +325,7 @@ impl Target {\n                     }\n                 }\n             )\n-        )\n+        );\n \n         load_specific!(\n             x86_64_unknown_linux_gnu,\n@@ -348,7 +348,7 @@ impl Target {\n \n             x86_64_pc_windows_gnu,\n             i686_pc_windows_gnu\n-        )\n+        );\n \n \n         let path = Path::new(target);"}, {"sha": "7f469db318611f9c69d1e0015221f416cf20de6b", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -39,14 +39,14 @@ use syntax::visit;\n use syntax::visit::{Visitor, FnKind};\n use syntax::ast::{FnDecl, Block, NodeId};\n \n-macro_rules! if_ok(\n+macro_rules! if_ok {\n     ($inp: expr) => (\n         match $inp {\n             Ok(v) => { v }\n             Err(e) => { return Err(e); }\n         }\n     )\n-)\n+}\n \n pub mod doc;\n "}, {"sha": "8b036b2501578052ca0cf74fc54a22bf37f07fa3", "filename": "src/librustc_llvm/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -2290,5 +2290,5 @@ pub unsafe fn static_link_hack_this_sucks() {\n // Works to the above fix for #15460 to ensure LLVM dependencies that\n // are only used by rustllvm don't get stripped by the linker.\n mod llvmdeps {\n-    include!(env!(\"CFG_LLVM_LINKAGE_FILE\"))\n+    include! { env!(\"CFG_LLVM_LINKAGE_FILE\") }\n }"}, {"sha": "bf17043f0e4eeaccde6cfd950b580a63a44f86b8", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -676,7 +676,7 @@ fn extract_vec_elems<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n // pattern.  Note that, because the macro is well-typed, either ALL of the\n // matches should fit that sort of pattern or NONE (however, some of the\n // matches may be wildcards like _ or identifiers).\n-macro_rules! any_pat (\n+macro_rules! any_pat {\n     ($m:expr, $col:expr, $pattern:pat) => (\n         ($m).iter().any(|br| {\n             match br.pats[$col].node {\n@@ -685,7 +685,7 @@ macro_rules! any_pat (\n             }\n         })\n     )\n-)\n+}\n \n fn any_uniq_pat(m: &[Match], col: uint) -> bool {\n     any_pat!(m, col, ast::PatBox(_))"}, {"sha": "0c2c86fc32dd43bde446218b70d7eac57d606dee", "filename": "src/librustc_trans/trans/adt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fadt.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -147,7 +147,7 @@ pub fn represent_type<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     }\n \n     let repr = Rc::new(represent_type_uncached(cx, t));\n-    debug!(\"Represented as: {}\", repr)\n+    debug!(\"Represented as: {}\", repr);\n     cx.adt_reprs().borrow_mut().insert(t, repr.clone());\n     repr\n }"}, {"sha": "f1d839e916d564011c99ae8d0beb2d86a5585bcb", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -103,9 +103,11 @@ use syntax::visit::Visitor;\n use syntax::visit;\n use syntax::{ast, ast_util, ast_map};\n \n-thread_local!(static TASK_LOCAL_INSN_KEY: RefCell<Option<Vec<&'static str>>> = {\n-    RefCell::new(None)\n-})\n+thread_local! {\n+    static TASK_LOCAL_INSN_KEY: RefCell<Option<Vec<&'static str>>> = {\n+        RefCell::new(None)\n+    }\n+}\n \n pub fn with_insn_ctxt<F>(blk: F) where\n     F: FnOnce(&[&'static str]),"}, {"sha": "89fa6a72e883d610da2fd1550a20c7c2545bb9e3", "filename": "src/librustc_trans/trans/context.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -749,10 +749,10 @@ fn declare_intrinsic(ccx: &CrateContext, key: & &'static str) -> Option<ValueRef\n                 return Some(f);\n             }\n         )\n-    )\n+    );\n     macro_rules! mk_struct (\n         ($($field_ty:expr),*) => (Type::struct_(ccx, &[$($field_ty),*], false))\n-    )\n+    );\n \n     let i8p = Type::i8p(ccx);\n     let void = Type::void(ccx);\n@@ -886,7 +886,7 @@ fn declare_intrinsic(ccx: &CrateContext, key: & &'static str) -> Option<ValueRef\n                 return Some(f);\n             }\n         )\n-    )\n+    );\n \n     compatible_ifn!(\"llvm.copysign.f32\", copysignf(t_f32, t_f32) -> t_f32);\n     compatible_ifn!(\"llvm.copysign.f64\", copysign(t_f64, t_f64) -> t_f64);"}, {"sha": "e32b5792e5da49e14239d34cde2b33175b19e8f2", "filename": "src/librustc_trans/trans/datum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -583,7 +583,7 @@ impl<'tcx, K: KindOps + fmt::Show> Datum<'tcx, K> {\n     }\n \n     pub fn to_llbool<'blk>(self, bcx: Block<'blk, 'tcx>) -> ValueRef {\n-        assert!(ty::type_is_bool(self.ty))\n+        assert!(ty::type_is_bool(self.ty));\n         self.to_llscalarish(bcx)\n     }\n }"}, {"sha": "e9730f7af0ec170ae82293296a60f3dca77277a6", "filename": "src/librustc_trans/trans/debuginfo.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -634,7 +634,7 @@ impl<'tcx> TypeMap<'tcx> {\n \n // Returns from the enclosing function if the type metadata with the given\n // unique id can be found in the type map\n-macro_rules! return_if_metadata_created_in_meantime(\n+macro_rules! return_if_metadata_created_in_meantime {\n     ($cx: expr, $unique_type_id: expr) => (\n         match debug_context($cx).type_map\n                                 .borrow()\n@@ -643,7 +643,7 @@ macro_rules! return_if_metadata_created_in_meantime(\n             None => { /* proceed normally */ }\n         };\n     )\n-)\n+}\n \n \n /// A context object for maintaining all state needed by the debuginfo module."}, {"sha": "ab202975bfc152d8b9b424dffbfd51541d85a7db", "filename": "src/librustc_trans/trans/macros.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibrustc_trans%2Ftrans%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibrustc_trans%2Ftrans%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmacros.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -10,22 +10,22 @@\n \n #![macro_escape]\n \n-macro_rules! unpack_datum(\n+macro_rules! unpack_datum {\n     ($bcx: ident, $inp: expr) => (\n         {\n             let db = $inp;\n             $bcx = db.bcx;\n             db.datum\n         }\n     )\n-)\n+}\n \n-macro_rules! unpack_result(\n+macro_rules! unpack_result {\n     ($bcx: ident, $inp: expr) => (\n         {\n             let db = $inp;\n             $bcx = db.bcx;\n             db.val\n         }\n     )\n-)\n+}"}, {"sha": "70b1e99ce8e28e6c23c93c2e17d345615bb84f07", "filename": "src/librustc_trans/trans/type_.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibrustc_trans%2Ftrans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibrustc_trans%2Ftrans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftype_.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -33,9 +33,9 @@ pub struct Type {\n \n impl Copy for Type {}\n \n-macro_rules! ty (\n+macro_rules! ty {\n     ($e:expr) => ( Type::from_ref(unsafe { $e }))\n-)\n+}\n \n /// Wrapper for LLVM TypeRef\n impl Type {"}, {"sha": "c7cf86fb1843a009e36d962c1165e4540566a923", "filename": "src/librustc_trans/trans/value.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibrustc_trans%2Ftrans%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibrustc_trans%2Ftrans%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fvalue.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -18,14 +18,14 @@ pub struct Value(pub ValueRef);\n \n impl Copy for Value {}\n \n-macro_rules! opt_val ( ($e:expr) => (\n+macro_rules! opt_val { ($e:expr) => (\n     unsafe {\n         match $e {\n             p if p.is_not_null() => Some(Value(p)),\n             _ => None\n         }\n     }\n-))\n+) }\n \n /// Wrapper for LLVM ValueRef\n impl Value {"}, {"sha": "2ec7e2c38836d049545dcdf2bdc25106974a0587", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -199,14 +199,14 @@ pub fn regionck_ensure_component_tys_wf<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n // check failed (or will fail, when the error is uncovered and\n // reported during writeback). In this case, we just ignore this part\n // of the code and don't try to add any more region constraints.\n-macro_rules! ignore_err(\n+macro_rules! ignore_err {\n     ($inp: expr) => (\n         match $inp {\n             Ok(v) => v,\n             Err(()) => return\n         }\n     )\n-)\n+}\n \n // Stores parameters for a potential call to link_region()\n // to perform if an upvar reference is marked unique/mutable after"}, {"sha": "9657bf82a8b8106c69728938695f1bd143ac3359", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -10,16 +10,18 @@\n \n #![allow(non_snake_case)]\n \n-register_diagnostic!(E0001, r##\"\n+register_diagnostic! {\n+    E0001,\n+r##\"\n     This error suggests that the expression arm corresponding to the noted pattern\n     will never be reached as for all possible values of the expression being matched,\n     one of the preceeding patterns will match.\n \n     This means that perhaps some of the preceeding patterns are too general, this\n     one is too specific or the ordering is incorrect.\n-\"##)\n+\"## }\n \n-register_diagnostics!(\n+register_diagnostics! {\n     E0002,\n     E0003,\n     E0004,\n@@ -156,4 +158,4 @@ register_diagnostics!(\n     E0181,\n     E0182,\n     E0183\n-)\n+}"}, {"sha": "1e243906b2341edd2c0470992ea950a30e50767b", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -779,7 +779,7 @@ The counts do not include methods or trait\n implementations that are visible only through a re-exported type.\",\n stable, unstable, experimental, deprecated, unmarked,\n name=self.name));\n-        try!(write!(f, \"<table>\"))\n+        try!(write!(f, \"<table>\"));\n         try!(fmt_inner(f, &mut context, self));\n         write!(f, \"</table>\")\n     }"}, {"sha": "8b2f644dfe33bd2a57b2647336bf86289a265fbc", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -149,12 +149,12 @@ fn stripped_filtered_line<'a>(s: &'a str) -> Option<&'a str> {\n \n thread_local!(static USED_HEADER_MAP: RefCell<HashMap<String, uint>> = {\n     RefCell::new(HashMap::new())\n-})\n-thread_local!(static TEST_IDX: Cell<uint> = Cell::new(0))\n+});\n+thread_local!(static TEST_IDX: Cell<uint> = Cell::new(0));\n \n thread_local!(pub static PLAYGROUND_KRATE: RefCell<Option<Option<String>>> = {\n     RefCell::new(None)\n-})\n+});\n \n pub fn render(w: &mut fmt::Formatter, s: &str, print_toc: bool) -> fmt::Result {\n     extern fn block(ob: *mut hoedown_buffer, orig_text: *const hoedown_buffer,"}, {"sha": "3e6cffa1304cec77b25de375f39792a1c7935ba4", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -246,9 +246,9 @@ struct IndexItem {\n \n // TLS keys used to carry information around during rendering.\n \n-thread_local!(static CACHE_KEY: RefCell<Arc<Cache>> = Default::default())\n+thread_local!(static CACHE_KEY: RefCell<Arc<Cache>> = Default::default());\n thread_local!(pub static CURRENT_LOCATION_KEY: RefCell<Vec<String>> =\n-                    RefCell::new(Vec::new()))\n+                    RefCell::new(Vec::new()));\n \n /// Generates the documentation for `crate` into the directory `dst`\n pub fn run(mut krate: clean::Crate,"}, {"sha": "5a91298acdf255e5efd60b5c8a395066afc86cb7", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -93,7 +93,7 @@ static DEFAULT_PASSES: &'static [&'static str] = &[\n \n thread_local!(pub static ANALYSISKEY: Rc<RefCell<Option<core::CrateAnalysis>>> = {\n     Rc::new(RefCell::new(None))\n-})\n+});\n \n struct Output {\n     krate: clean::Crate,"}, {"sha": "45144308535722b059e05cff84ab979e8c927838", "filename": "src/librustrt/macros.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibrustrt%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibrustrt%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fmacros.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -15,32 +15,32 @@\n \n #![macro_escape]\n \n-macro_rules! rterrln (\n+macro_rules! rterrln {\n     ($fmt:expr $($arg:tt)*) => ( {\n         format_args!(::util::dumb_print, concat!($fmt, \"\\n\") $($arg)*)\n     } )\n-)\n+}\n \n // Some basic logging. Enabled by passing `--cfg rtdebug` to the libstd build.\n-macro_rules! rtdebug (\n+macro_rules! rtdebug {\n     ($($arg:tt)*) => ( {\n         if cfg!(rtdebug) {\n             rterrln!($($arg)*)\n         }\n     })\n-)\n+}\n \n-macro_rules! rtassert (\n+macro_rules! rtassert {\n     ( $arg:expr ) => ( {\n         if ::util::ENFORCE_SANITY {\n             if !$arg {\n                 rtabort!(\" assertion failed: {}\", stringify!($arg));\n             }\n         }\n     } )\n-)\n+}\n \n \n-macro_rules! rtabort (\n+macro_rules! rtabort {\n     ($($arg:tt)*) => (format_args!(::util::abort, $($arg)*))\n-)\n+}"}, {"sha": "8ded963b9284a46447a758b0e99d695c5d549dd5", "filename": "src/libserialize/base64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibserialize%2Fbase64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibserialize%2Fbase64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fbase64.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -385,7 +385,7 @@ mod tests {\n \n     #[test]\n     fn test_from_base64_invalid_char() {\n-        assert!(\"Zm$=\".from_base64().is_err())\n+        assert!(\"Zm$=\".from_base64().is_err());\n         assert!(\"Zg==$\".from_base64().is_err());\n     }\n "}, {"sha": "e7b2d0c8eba0e8276a1e28a3e3931daadbec102a", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -1970,7 +1970,7 @@ impl Decoder {\n     }\n }\n \n-macro_rules! expect(\n+macro_rules! expect {\n     ($e:expr, Null) => ({\n         match $e {\n             Json::Null => Ok(()),\n@@ -1987,7 +1987,7 @@ macro_rules! expect(\n             }\n         }\n     })\n-)\n+}\n \n macro_rules! read_primitive {\n     ($name:ident, $ty:ty) => {\n@@ -2020,16 +2020,16 @@ impl ::Decoder<DecoderError> for Decoder {\n         expect!(self.pop(), Null)\n     }\n \n-    read_primitive!(read_uint, uint)\n-    read_primitive!(read_u8, u8)\n-    read_primitive!(read_u16, u16)\n-    read_primitive!(read_u32, u32)\n-    read_primitive!(read_u64, u64)\n-    read_primitive!(read_int, int)\n-    read_primitive!(read_i8, i8)\n-    read_primitive!(read_i16, i16)\n-    read_primitive!(read_i32, i32)\n-    read_primitive!(read_i64, i64)\n+    read_primitive! { read_uint, uint }\n+    read_primitive! { read_u8, u8 }\n+    read_primitive! { read_u16, u16 }\n+    read_primitive! { read_u32, u32 }\n+    read_primitive! { read_u64, u64 }\n+    read_primitive! { read_int, int }\n+    read_primitive! { read_i8, i8 }\n+    read_primitive! { read_i16, i16 }\n+    read_primitive! { read_i32, i32 }\n+    read_primitive! { read_i64, i64 }\n \n     fn read_f32(&mut self) -> DecodeResult<f32> { self.read_f64().map(|x| x as f32) }\n \n@@ -2298,25 +2298,25 @@ pub trait ToJson for Sized? {\n     fn to_json(&self) -> Json;\n }\n \n-macro_rules! to_json_impl_i64(\n+macro_rules! to_json_impl_i64 {\n     ($($t:ty), +) => (\n         $(impl ToJson for $t {\n             fn to_json(&self) -> Json { Json::I64(*self as i64) }\n         })+\n     )\n-)\n+}\n \n-to_json_impl_i64!(int, i8, i16, i32, i64)\n+to_json_impl_i64! { int, i8, i16, i32, i64 }\n \n-macro_rules! to_json_impl_u64(\n+macro_rules! to_json_impl_u64 {\n     ($($t:ty), +) => (\n         $(impl ToJson for $t {\n             fn to_json(&self) -> Json { Json::U64(*self as u64) }\n         })+\n     )\n-)\n+}\n \n-to_json_impl_u64!(uint, u8, u16, u32, u64)\n+to_json_impl_u64! { uint, u8, u16, u32, u64 }\n \n impl ToJson for Json {\n     fn to_json(&self) -> Json { self.clone() }\n@@ -2730,7 +2730,7 @@ mod tests {\n         );\n     }\n \n-    macro_rules! check_encoder_for_simple(\n+    macro_rules! check_encoder_for_simple {\n         ($value:expr, $expected:expr) => ({\n             let s = with_str_writer(|writer| {\n                 let mut encoder = Encoder::new(writer);\n@@ -2744,7 +2744,7 @@ mod tests {\n             });\n             assert_eq!(s, $expected);\n         })\n-    )\n+    }\n \n     #[test]\n     fn test_write_some() {\n@@ -2948,7 +2948,7 @@ mod tests {\n     #[test]\n     fn test_decode_tuple() {\n         let t: (uint, uint, uint) = super::decode(\"[1, 2, 3]\").unwrap();\n-        assert_eq!(t, (1u, 2, 3))\n+        assert_eq!(t, (1u, 2, 3));\n \n         let t: (uint, string::String) = super::decode(\"[1, \\\"two\\\"]\").unwrap();\n         assert_eq!(t, (1u, \"two\".into_string()));"}, {"sha": "00c5158309e98bbef8f8ed99a3e7c9c4eb38ffe9", "filename": "src/libserialize/serialize.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibserialize%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibserialize%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fserialize.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -474,15 +474,17 @@ impl<E, D:Decoder<E>,T:Decodable<D, E>> Decodable<D, E> for Option<T> {\n     }\n }\n \n-macro_rules! peel(($name:ident, $($other:ident,)*) => (tuple!($($other,)*)))\n+macro_rules! peel {\n+    ($name:ident, $($other:ident,)*) => (tuple! { $($other,)* })\n+}\n \n /// Evaluates to the number of identifiers passed to it, for example: `count_idents!(a, b, c) == 3\n macro_rules! count_idents {\n     () => { 0u };\n     ($_i:ident $(, $rest:ident)*) => { 1 + count_idents!($($rest),*) }\n }\n \n-macro_rules! tuple (\n+macro_rules! tuple {\n     () => ();\n     ( $($name:ident,)+ ) => (\n         impl<E, D:Decoder<E>,$($name:Decodable<D, E>),*> Decodable<D,E> for ($($name,)*) {\n@@ -511,9 +513,9 @@ macro_rules! tuple (\n                 })\n             }\n         }\n-        peel!($($name,)*)\n+        peel! { $($name,)* }\n     )\n-)\n+}\n \n tuple! { T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, }\n "}, {"sha": "c436de0d193b8b38930edba18e01737821060786", "filename": "src/libstd/ascii.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibstd%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibstd%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fascii.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -638,14 +638,14 @@ mod tests {\n     use char::from_u32;\n     use str::StrPrelude;\n \n-    macro_rules! v2ascii (\n+    macro_rules! v2ascii {\n         ( [$($e:expr),*]) => (&[$(Ascii{chr:$e}),*]);\n         (&[$($e:expr),*]) => (&[$(Ascii{chr:$e}),*]);\n-    )\n+    }\n \n-    macro_rules! vec2ascii (\n+    macro_rules! vec2ascii {\n         ($($e:expr),*) => ([$(Ascii{chr:$e}),*].to_vec());\n-    )\n+    }\n \n     #[test]\n     fn test_ascii() {\n@@ -788,7 +788,7 @@ mod tests {\n             let upper = if 'a' as u32 <= i && i <= 'z' as u32 { i + 'A' as u32 - 'a' as u32 }\n                         else { i };\n             assert_eq!((from_u32(i).unwrap()).to_string().to_ascii_upper(),\n-                       (from_u32(upper).unwrap()).to_string())\n+                       (from_u32(upper).unwrap()).to_string());\n             i += 1;\n         }\n     }\n@@ -804,7 +804,7 @@ mod tests {\n             let lower = if 'A' as u32 <= i && i <= 'Z' as u32 { i + 'a' as u32 - 'A' as u32 }\n                         else { i };\n             assert_eq!((from_u32(i).unwrap()).to_string().to_ascii_lower(),\n-                       (from_u32(lower).unwrap()).to_string())\n+                       (from_u32(lower).unwrap()).to_string());\n             i += 1;\n         }\n     }\n@@ -820,7 +820,7 @@ mod tests {\n             let upper = if 'a' as u32 <= i && i <= 'z' as u32 { i + 'A' as u32 - 'a' as u32 }\n                         else { i };\n             assert_eq!((from_u32(i).unwrap()).to_string().into_ascii_upper(),\n-                       (from_u32(upper).unwrap()).to_string())\n+                       (from_u32(upper).unwrap()).to_string());\n             i += 1;\n         }\n     }\n@@ -837,7 +837,7 @@ mod tests {\n             let lower = if 'A' as u32 <= i && i <= 'Z' as u32 { i + 'a' as u32 - 'A' as u32 }\n                         else { i };\n             assert_eq!((from_u32(i).unwrap()).to_string().into_ascii_lower(),\n-                       (from_u32(lower).unwrap()).to_string())\n+                       (from_u32(lower).unwrap()).to_string());\n             i += 1;\n         }\n     }"}, {"sha": "04dd5afdfa2ac3438f70e1f5d867d96f2769a458", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -1471,7 +1471,7 @@ mod test_map {\n         assert_eq!(*m.get(&2).unwrap(), 4);\n     }\n \n-    thread_local!(static DROP_VECTOR: RefCell<Vec<int>> = RefCell::new(Vec::new()))\n+    thread_local! { static DROP_VECTOR: RefCell<Vec<int>> = RefCell::new(Vec::new()) }\n \n     #[deriving(Hash, PartialEq, Eq)]\n     struct Dropable {"}, {"sha": "29a7b0dd0cc54f4fdd89b9dd563d9a4fe9a8f95e", "filename": "src/libstd/comm/mod.rs", "status": "modified", "additions": 188, "deletions": 188, "changes": 376, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibstd%2Fcomm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibstd%2Fcomm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fmod.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -136,7 +136,7 @@\n //!     select! {\n //!         val = rx.recv() => println!(\"Received {}\", val),\n //!         () = timeout.recv() => {\n-//!             println!(\"timed out, total time was more than 10 seconds\")\n+//!             println!(\"timed out, total time was more than 10 seconds\");\n //!             break;\n //!         }\n //!     }\n@@ -160,7 +160,7 @@\n //!     select! {\n //!         val = rx.recv() => println!(\"Received {}\", val),\n //!         () = timeout.recv() => {\n-//!             println!(\"timed out, no message received in 5 seconds\")\n+//!             println!(\"timed out, no message received in 5 seconds\");\n //!             break;\n //!         }\n //!     }\n@@ -331,7 +331,7 @@ use rustrt::task::BlockedTask;\n \n pub use comm::select::{Select, Handle};\n \n-macro_rules! test (\n+macro_rules! test {\n     { fn $name:ident() $b:block $(#[$a:meta])*} => (\n         mod $name {\n             #![allow(unused_imports)]\n@@ -347,7 +347,7 @@ macro_rules! test (\n             $(#[$a])* #[test] fn f() { $b }\n         }\n     )\n-)\n+}\n \n mod oneshot;\n mod select;\n@@ -1036,70 +1036,70 @@ mod test {\n         }\n     }\n \n-    test!(fn smoke() {\n+    test! { fn smoke() {\n         let (tx, rx) = channel::<int>();\n         tx.send(1);\n         assert_eq!(rx.recv(), 1);\n-    })\n+    } }\n \n-    test!(fn drop_full() {\n+    test! { fn drop_full() {\n         let (tx, _rx) = channel();\n         tx.send(box 1i);\n-    })\n+    } }\n \n-    test!(fn drop_full_shared() {\n+    test! { fn drop_full_shared() {\n         let (tx, _rx) = channel();\n         drop(tx.clone());\n         drop(tx.clone());\n         tx.send(box 1i);\n-    })\n+    } }\n \n-    test!(fn smoke_shared() {\n+    test! { fn smoke_shared() {\n         let (tx, rx) = channel::<int>();\n         tx.send(1);\n         assert_eq!(rx.recv(), 1);\n         let tx = tx.clone();\n         tx.send(1);\n         assert_eq!(rx.recv(), 1);\n-    })\n+    } }\n \n-    test!(fn smoke_threads() {\n+    test! { fn smoke_threads() {\n         let (tx, rx) = channel::<int>();\n         spawn(move|| {\n             tx.send(1);\n         });\n         assert_eq!(rx.recv(), 1);\n-    })\n+    } }\n \n-    test!(fn smoke_port_gone() {\n+    test! { fn smoke_port_gone() {\n         let (tx, rx) = channel::<int>();\n         drop(rx);\n         tx.send(1);\n-    } #[should_fail])\n+    } #[should_fail] }\n \n-    test!(fn smoke_shared_port_gone() {\n+    test! { fn smoke_shared_port_gone() {\n         let (tx, rx) = channel::<int>();\n         drop(rx);\n         tx.send(1);\n-    } #[should_fail])\n+    } #[should_fail] }\n \n-    test!(fn smoke_shared_port_gone2() {\n+    test! { fn smoke_shared_port_gone2() {\n         let (tx, rx) = channel::<int>();\n         drop(rx);\n         let tx2 = tx.clone();\n         drop(tx);\n         tx2.send(1);\n-    } #[should_fail])\n+    } #[should_fail] }\n \n-    test!(fn port_gone_concurrent() {\n+    test! { fn port_gone_concurrent() {\n         let (tx, rx) = channel::<int>();\n         spawn(move|| {\n             rx.recv();\n         });\n         loop { tx.send(1) }\n-    } #[should_fail])\n+    } #[should_fail] }\n \n-    test!(fn port_gone_concurrent_shared() {\n+    test! { fn port_gone_concurrent_shared() {\n         let (tx, rx) = channel::<int>();\n         let tx2 = tx.clone();\n         spawn(move|| {\n@@ -1109,42 +1109,42 @@ mod test {\n             tx.send(1);\n             tx2.send(1);\n         }\n-    } #[should_fail])\n+    } #[should_fail] }\n \n-    test!(fn smoke_chan_gone() {\n+    test! { fn smoke_chan_gone() {\n         let (tx, rx) = channel::<int>();\n         drop(tx);\n         rx.recv();\n-    } #[should_fail])\n+    } #[should_fail] }\n \n-    test!(fn smoke_chan_gone_shared() {\n+    test! { fn smoke_chan_gone_shared() {\n         let (tx, rx) = channel::<()>();\n         let tx2 = tx.clone();\n         drop(tx);\n         drop(tx2);\n         rx.recv();\n-    } #[should_fail])\n+    } #[should_fail] }\n \n-    test!(fn chan_gone_concurrent() {\n+    test! { fn chan_gone_concurrent() {\n         let (tx, rx) = channel::<int>();\n         spawn(move|| {\n             tx.send(1);\n             tx.send(1);\n         });\n         loop { rx.recv(); }\n-    } #[should_fail])\n+    } #[should_fail] }\n \n-    test!(fn stress() {\n+    test! { fn stress() {\n         let (tx, rx) = channel::<int>();\n         spawn(move|| {\n             for _ in range(0u, 10000) { tx.send(1i); }\n         });\n         for _ in range(0u, 10000) {\n             assert_eq!(rx.recv(), 1);\n         }\n-    })\n+    } }\n \n-    test!(fn stress_shared() {\n+    test! { fn stress_shared() {\n         static AMT: uint = 10000;\n         static NTHREADS: uint = 8;\n         let (tx, rx) = channel::<int>();\n@@ -1169,7 +1169,7 @@ mod test {\n         }\n         drop(tx);\n         drx.recv();\n-    })\n+    } }\n \n     #[test]\n     fn send_from_outside_runtime() {\n@@ -1231,26 +1231,26 @@ mod test {\n         rx3.recv();\n     }\n \n-    test!(fn oneshot_single_thread_close_port_first() {\n+    test! { fn oneshot_single_thread_close_port_first() {\n         // Simple test of closing without sending\n         let (_tx, rx) = channel::<int>();\n         drop(rx);\n-    })\n+    } }\n \n-    test!(fn oneshot_single_thread_close_chan_first() {\n+    test! { fn oneshot_single_thread_close_chan_first() {\n         // Simple test of closing without sending\n         let (tx, _rx) = channel::<int>();\n         drop(tx);\n-    })\n+    } }\n \n-    test!(fn oneshot_single_thread_send_port_close() {\n+    test! { fn oneshot_single_thread_send_port_close() {\n         // Testing that the sender cleans up the payload if receiver is closed\n         let (tx, rx) = channel::<Box<int>>();\n         drop(rx);\n         tx.send(box 0);\n-    } #[should_fail])\n+    } #[should_fail] }\n \n-    test!(fn oneshot_single_thread_recv_chan_close() {\n+    test! { fn oneshot_single_thread_recv_chan_close() {\n         // Receiving on a closed chan will panic\n         let res = task::try(move|| {\n             let (tx, rx) = channel::<int>();\n@@ -1259,67 +1259,67 @@ mod test {\n         });\n         // What is our res?\n         assert!(res.is_err());\n-    })\n+    } }\n \n-    test!(fn oneshot_single_thread_send_then_recv() {\n+    test! { fn oneshot_single_thread_send_then_recv() {\n         let (tx, rx) = channel::<Box<int>>();\n         tx.send(box 10);\n         assert!(rx.recv() == box 10);\n-    })\n+    } }\n \n-    test!(fn oneshot_single_thread_try_send_open() {\n+    test! { fn oneshot_single_thread_try_send_open() {\n         let (tx, rx) = channel::<int>();\n         assert!(tx.send_opt(10).is_ok());\n         assert!(rx.recv() == 10);\n-    })\n+    } }\n \n-    test!(fn oneshot_single_thread_try_send_closed() {\n+    test! { fn oneshot_single_thread_try_send_closed() {\n         let (tx, rx) = channel::<int>();\n         drop(rx);\n         assert!(tx.send_opt(10).is_err());\n-    })\n+    } }\n \n-    test!(fn oneshot_single_thread_try_recv_open() {\n+    test! { fn oneshot_single_thread_try_recv_open() {\n         let (tx, rx) = channel::<int>();\n         tx.send(10);\n         assert!(rx.recv_opt() == Ok(10));\n-    })\n+    } }\n \n-    test!(fn oneshot_single_thread_try_recv_closed() {\n+    test! { fn oneshot_single_thread_try_recv_closed() {\n         let (tx, rx) = channel::<int>();\n         drop(tx);\n         assert!(rx.recv_opt() == Err(()));\n-    })\n+    } }\n \n-    test!(fn oneshot_single_thread_peek_data() {\n+    test! { fn oneshot_single_thread_peek_data() {\n         let (tx, rx) = channel::<int>();\n-        assert_eq!(rx.try_recv(), Err(Empty))\n+        assert_eq!(rx.try_recv(), Err(Empty));\n         tx.send(10);\n         assert_eq!(rx.try_recv(), Ok(10));\n-    })\n+    } }\n \n-    test!(fn oneshot_single_thread_peek_close() {\n+    test! { fn oneshot_single_thread_peek_close() {\n         let (tx, rx) = channel::<int>();\n         drop(tx);\n         assert_eq!(rx.try_recv(), Err(Disconnected));\n         assert_eq!(rx.try_recv(), Err(Disconnected));\n-    })\n+    } }\n \n-    test!(fn oneshot_single_thread_peek_open() {\n+    test! { fn oneshot_single_thread_peek_open() {\n         let (_tx, rx) = channel::<int>();\n         assert_eq!(rx.try_recv(), Err(Empty));\n-    })\n+    } }\n \n-    test!(fn oneshot_multi_task_recv_then_send() {\n+    test! { fn oneshot_multi_task_recv_then_send() {\n         let (tx, rx) = channel::<Box<int>>();\n         spawn(move|| {\n             assert!(rx.recv() == box 10);\n         });\n \n         tx.send(box 10);\n-    })\n+    } }\n \n-    test!(fn oneshot_multi_task_recv_then_close() {\n+    test! { fn oneshot_multi_task_recv_then_close() {\n         let (tx, rx) = channel::<Box<int>>();\n         spawn(move|| {\n             drop(tx);\n@@ -1328,19 +1328,19 @@ mod test {\n             assert!(rx.recv() == box 10);\n         });\n         assert!(res.is_err());\n-    })\n+    } }\n \n-    test!(fn oneshot_multi_thread_close_stress() {\n+    test! { fn oneshot_multi_thread_close_stress() {\n         for _ in range(0, stress_factor()) {\n             let (tx, rx) = channel::<int>();\n             spawn(move|| {\n                 drop(rx);\n             });\n             drop(tx);\n         }\n-    })\n+    } }\n \n-    test!(fn oneshot_multi_thread_send_close_stress() {\n+    test! { fn oneshot_multi_thread_send_close_stress() {\n         for _ in range(0, stress_factor()) {\n             let (tx, rx) = channel::<int>();\n             spawn(move|| {\n@@ -1350,9 +1350,9 @@ mod test {\n                 tx.send(1);\n             });\n         }\n-    })\n+    } }\n \n-    test!(fn oneshot_multi_thread_recv_close_stress() {\n+    test! { fn oneshot_multi_thread_recv_close_stress() {\n         for _ in range(0, stress_factor()) {\n             let (tx, rx) = channel::<int>();\n             spawn(move|| {\n@@ -1367,9 +1367,9 @@ mod test {\n                 });\n             });\n         }\n-    })\n+    } }\n \n-    test!(fn oneshot_multi_thread_send_recv_stress() {\n+    test! { fn oneshot_multi_thread_send_recv_stress() {\n         for _ in range(0, stress_factor()) {\n             let (tx, rx) = channel();\n             spawn(move|| {\n@@ -1379,9 +1379,9 @@ mod test {\n                 assert!(rx.recv() == box 10i);\n             });\n         }\n-    })\n+    } }\n \n-    test!(fn stream_send_recv_stress() {\n+    test! { fn stream_send_recv_stress() {\n         for _ in range(0, stress_factor()) {\n             let (tx, rx) = channel();\n \n@@ -1406,16 +1406,16 @@ mod test {\n                 });\n             }\n         }\n-    })\n+    } }\n \n-    test!(fn recv_a_lot() {\n+    test! { fn recv_a_lot() {\n         // Regression test that we don't run out of stack in scheduler context\n         let (tx, rx) = channel();\n         for _ in range(0i, 10000) { tx.send(()); }\n         for _ in range(0i, 10000) { rx.recv(); }\n-    })\n+    } }\n \n-    test!(fn shared_chan_stress() {\n+    test! { fn shared_chan_stress() {\n         let (tx, rx) = channel();\n         let total = stress_factor() + 100;\n         for _ in range(0, total) {\n@@ -1428,9 +1428,9 @@ mod test {\n         for _ in range(0, total) {\n             rx.recv();\n         }\n-    })\n+    } }\n \n-    test!(fn test_nested_recv_iter() {\n+    test! { fn test_nested_recv_iter() {\n         let (tx, rx) = channel::<int>();\n         let (total_tx, total_rx) = channel::<int>();\n \n@@ -1447,9 +1447,9 @@ mod test {\n         tx.send(2);\n         drop(tx);\n         assert_eq!(total_rx.recv(), 6);\n-    })\n+    } }\n \n-    test!(fn test_recv_iter_break() {\n+    test! { fn test_recv_iter_break() {\n         let (tx, rx) = channel::<int>();\n         let (count_tx, count_rx) = channel();\n \n@@ -1471,9 +1471,9 @@ mod test {\n         let _ = tx.send_opt(2);\n         drop(tx);\n         assert_eq!(count_rx.recv(), 4);\n-    })\n+    } }\n \n-    test!(fn try_recv_states() {\n+    test! { fn try_recv_states() {\n         let (tx1, rx1) = channel::<int>();\n         let (tx2, rx2) = channel::<()>();\n         let (tx3, rx3) = channel::<()>();\n@@ -1494,11 +1494,11 @@ mod test {\n         tx2.send(());\n         rx3.recv();\n         assert_eq!(rx1.try_recv(), Err(Disconnected));\n-    })\n+    } }\n \n     // This bug used to end up in a livelock inside of the Receiver destructor\n     // because the internal state of the Shared packet was corrupted\n-    test!(fn destroy_upgraded_shared_port_when_sender_still_active() {\n+    test! { fn destroy_upgraded_shared_port_when_sender_still_active() {\n         let (tx, rx) = channel();\n         let (tx2, rx2) = channel();\n         spawn(move|| {\n@@ -1516,9 +1516,9 @@ mod test {\n \n         // wait for the child task to exit before we exit\n         rx2.recv();\n-    })\n+    } }\n \n-    test!(fn sends_off_the_runtime() {\n+    test! { fn sends_off_the_runtime() {\n         use rustrt::thread::Thread;\n \n         let (tx, rx) = channel();\n@@ -1531,9 +1531,9 @@ mod test {\n             rx.recv();\n         }\n         t.join();\n-    })\n+    } }\n \n-    test!(fn try_recvs_off_the_runtime() {\n+    test! { fn try_recvs_off_the_runtime() {\n         use rustrt::thread::Thread;\n \n         let (tx, rx) = channel();\n@@ -1554,7 +1554,7 @@ mod test {\n         }\n         t.join();\n         pdone.recv();\n-    })\n+    } }\n }\n \n #[cfg(test)]\n@@ -1569,57 +1569,57 @@ mod sync_tests {\n         }\n     }\n \n-    test!(fn smoke() {\n+    test! { fn smoke() {\n         let (tx, rx) = sync_channel::<int>(1);\n         tx.send(1);\n         assert_eq!(rx.recv(), 1);\n-    })\n+    } }\n \n-    test!(fn drop_full() {\n+    test! { fn drop_full() {\n         let (tx, _rx) = sync_channel(1);\n         tx.send(box 1i);\n-    })\n+    } }\n \n-    test!(fn smoke_shared() {\n+    test! { fn smoke_shared() {\n         let (tx, rx) = sync_channel::<int>(1);\n         tx.send(1);\n         assert_eq!(rx.recv(), 1);\n         let tx = tx.clone();\n         tx.send(1);\n         assert_eq!(rx.recv(), 1);\n-    })\n+    } }\n \n-    test!(fn smoke_threads() {\n+    test! { fn smoke_threads() {\n         let (tx, rx) = sync_channel::<int>(0);\n         spawn(move|| {\n             tx.send(1);\n         });\n         assert_eq!(rx.recv(), 1);\n-    })\n+    } }\n \n-    test!(fn smoke_port_gone() {\n+    test! { fn smoke_port_gone() {\n         let (tx, rx) = sync_channel::<int>(0);\n         drop(rx);\n         tx.send(1);\n-    } #[should_fail])\n+    } #[should_fail] }\n \n-    test!(fn smoke_shared_port_gone2() {\n+    test! { fn smoke_shared_port_gone2() {\n         let (tx, rx) = sync_channel::<int>(0);\n         drop(rx);\n         let tx2 = tx.clone();\n         drop(tx);\n         tx2.send(1);\n-    } #[should_fail])\n+    } #[should_fail] }\n \n-    test!(fn port_gone_concurrent() {\n+    test! { fn port_gone_concurrent() {\n         let (tx, rx) = sync_channel::<int>(0);\n         spawn(move|| {\n             rx.recv();\n         });\n         loop { tx.send(1) }\n-    } #[should_fail])\n+    } #[should_fail] }\n \n-    test!(fn port_gone_concurrent_shared() {\n+    test! { fn port_gone_concurrent_shared() {\n         let (tx, rx) = sync_channel::<int>(0);\n         let tx2 = tx.clone();\n         spawn(move|| {\n@@ -1629,42 +1629,42 @@ mod sync_tests {\n             tx.send(1);\n             tx2.send(1);\n         }\n-    } #[should_fail])\n+    } #[should_fail] }\n \n-    test!(fn smoke_chan_gone() {\n+    test! { fn smoke_chan_gone() {\n         let (tx, rx) = sync_channel::<int>(0);\n         drop(tx);\n         rx.recv();\n-    } #[should_fail])\n+    } #[should_fail] }\n \n-    test!(fn smoke_chan_gone_shared() {\n+    test! { fn smoke_chan_gone_shared() {\n         let (tx, rx) = sync_channel::<()>(0);\n         let tx2 = tx.clone();\n         drop(tx);\n         drop(tx2);\n         rx.recv();\n-    } #[should_fail])\n+    } #[should_fail] }\n \n-    test!(fn chan_gone_concurrent() {\n+    test! { fn chan_gone_concurrent() {\n         let (tx, rx) = sync_channel::<int>(0);\n         spawn(move|| {\n             tx.send(1);\n             tx.send(1);\n         });\n         loop { rx.recv(); }\n-    } #[should_fail])\n+    } #[should_fail] }\n \n-    test!(fn stress() {\n+    test! { fn stress() {\n         let (tx, rx) = sync_channel::<int>(0);\n         spawn(move|| {\n             for _ in range(0u, 10000) { tx.send(1); }\n         });\n         for _ in range(0u, 10000) {\n             assert_eq!(rx.recv(), 1);\n         }\n-    })\n+    } }\n \n-    test!(fn stress_shared() {\n+    test! { fn stress_shared() {\n         static AMT: uint = 1000;\n         static NTHREADS: uint = 8;\n         let (tx, rx) = sync_channel::<int>(0);\n@@ -1689,28 +1689,28 @@ mod sync_tests {\n         }\n         drop(tx);\n         drx.recv();\n-    })\n+    } }\n \n-    test!(fn oneshot_single_thread_close_port_first() {\n+    test! { fn oneshot_single_thread_close_port_first() {\n         // Simple test of closing without sending\n         let (_tx, rx) = sync_channel::<int>(0);\n         drop(rx);\n-    })\n+    } }\n \n-    test!(fn oneshot_single_thread_close_chan_first() {\n+    test! { fn oneshot_single_thread_close_chan_first() {\n         // Simple test of closing without sending\n         let (tx, _rx) = sync_channel::<int>(0);\n         drop(tx);\n-    })\n+    } }\n \n-    test!(fn oneshot_single_thread_send_port_close() {\n+    test! { fn oneshot_single_thread_send_port_close() {\n         // Testing that the sender cleans up the payload if receiver is closed\n         let (tx, rx) = sync_channel::<Box<int>>(0);\n         drop(rx);\n         tx.send(box 0);\n-    } #[should_fail])\n+    } #[should_fail] }\n \n-    test!(fn oneshot_single_thread_recv_chan_close() {\n+    test! { fn oneshot_single_thread_recv_chan_close() {\n         // Receiving on a closed chan will panic\n         let res = task::try(move|| {\n             let (tx, rx) = sync_channel::<int>(0);\n@@ -1719,72 +1719,72 @@ mod sync_tests {\n         });\n         // What is our res?\n         assert!(res.is_err());\n-    })\n+    } }\n \n-    test!(fn oneshot_single_thread_send_then_recv() {\n+    test! { fn oneshot_single_thread_send_then_recv() {\n         let (tx, rx) = sync_channel::<Box<int>>(1);\n         tx.send(box 10);\n         assert!(rx.recv() == box 10);\n-    })\n+    } }\n \n-    test!(fn oneshot_single_thread_try_send_open() {\n+    test! { fn oneshot_single_thread_try_send_open() {\n         let (tx, rx) = sync_channel::<int>(1);\n         assert_eq!(tx.try_send(10), Ok(()));\n         assert!(rx.recv() == 10);\n-    })\n+    } }\n \n-    test!(fn oneshot_single_thread_try_send_closed() {\n+    test! { fn oneshot_single_thread_try_send_closed() {\n         let (tx, rx) = sync_channel::<int>(0);\n         drop(rx);\n         assert_eq!(tx.try_send(10), Err(RecvDisconnected(10)));\n-    })\n+    } }\n \n-    test!(fn oneshot_single_thread_try_send_closed2() {\n+    test! { fn oneshot_single_thread_try_send_closed2() {\n         let (tx, _rx) = sync_channel::<int>(0);\n         assert_eq!(tx.try_send(10), Err(Full(10)));\n-    })\n+    } }\n \n-    test!(fn oneshot_single_thread_try_recv_open() {\n+    test! { fn oneshot_single_thread_try_recv_open() {\n         let (tx, rx) = sync_channel::<int>(1);\n         tx.send(10);\n         assert!(rx.recv_opt() == Ok(10));\n-    })\n+    } }\n \n-    test!(fn oneshot_single_thread_try_recv_closed() {\n+    test! { fn oneshot_single_thread_try_recv_closed() {\n         let (tx, rx) = sync_channel::<int>(0);\n         drop(tx);\n         assert!(rx.recv_opt() == Err(()));\n-    })\n+    } }\n \n-    test!(fn oneshot_single_thread_peek_data() {\n+    test! { fn oneshot_single_thread_peek_data() {\n         let (tx, rx) = sync_channel::<int>(1);\n-        assert_eq!(rx.try_recv(), Err(Empty))\n+        assert_eq!(rx.try_recv(), Err(Empty));\n         tx.send(10);\n         assert_eq!(rx.try_recv(), Ok(10));\n-    })\n+    } }\n \n-    test!(fn oneshot_single_thread_peek_close() {\n+    test! { fn oneshot_single_thread_peek_close() {\n         let (tx, rx) = sync_channel::<int>(0);\n         drop(tx);\n         assert_eq!(rx.try_recv(), Err(Disconnected));\n         assert_eq!(rx.try_recv(), Err(Disconnected));\n-    })\n+    } }\n \n-    test!(fn oneshot_single_thread_peek_open() {\n+    test! { fn oneshot_single_thread_peek_open() {\n         let (_tx, rx) = sync_channel::<int>(0);\n         assert_eq!(rx.try_recv(), Err(Empty));\n-    })\n+    } }\n \n-    test!(fn oneshot_multi_task_recv_then_send() {\n+    test! { fn oneshot_multi_task_recv_then_send() {\n         let (tx, rx) = sync_channel::<Box<int>>(0);\n         spawn(move|| {\n             assert!(rx.recv() == box 10);\n         });\n \n         tx.send(box 10);\n-    })\n+    } }\n \n-    test!(fn oneshot_multi_task_recv_then_close() {\n+    test! { fn oneshot_multi_task_recv_then_close() {\n         let (tx, rx) = sync_channel::<Box<int>>(0);\n         spawn(move|| {\n             drop(tx);\n@@ -1793,19 +1793,19 @@ mod sync_tests {\n             assert!(rx.recv() == box 10);\n         });\n         assert!(res.is_err());\n-    })\n+    } }\n \n-    test!(fn oneshot_multi_thread_close_stress() {\n+    test! { fn oneshot_multi_thread_close_stress() {\n         for _ in range(0, stress_factor()) {\n             let (tx, rx) = sync_channel::<int>(0);\n             spawn(move|| {\n                 drop(rx);\n             });\n             drop(tx);\n         }\n-    })\n+    } }\n \n-    test!(fn oneshot_multi_thread_send_close_stress() {\n+    test! { fn oneshot_multi_thread_send_close_stress() {\n         for _ in range(0, stress_factor()) {\n             let (tx, rx) = sync_channel::<int>(0);\n             spawn(move|| {\n@@ -1815,9 +1815,9 @@ mod sync_tests {\n                 tx.send(1);\n             });\n         }\n-    })\n+    } }\n \n-    test!(fn oneshot_multi_thread_recv_close_stress() {\n+    test! { fn oneshot_multi_thread_recv_close_stress() {\n         for _ in range(0, stress_factor()) {\n             let (tx, rx) = sync_channel::<int>(0);\n             spawn(move|| {\n@@ -1832,9 +1832,9 @@ mod sync_tests {\n                 });\n             });\n         }\n-    })\n+    } }\n \n-    test!(fn oneshot_multi_thread_send_recv_stress() {\n+    test! { fn oneshot_multi_thread_send_recv_stress() {\n         for _ in range(0, stress_factor()) {\n             let (tx, rx) = sync_channel::<Box<int>>(0);\n             spawn(move|| {\n@@ -1844,9 +1844,9 @@ mod sync_tests {\n                 assert!(rx.recv() == box 10i);\n             });\n         }\n-    })\n+    } }\n \n-    test!(fn stream_send_recv_stress() {\n+    test! { fn stream_send_recv_stress() {\n         for _ in range(0, stress_factor()) {\n             let (tx, rx) = sync_channel::<Box<int>>(0);\n \n@@ -1871,16 +1871,16 @@ mod sync_tests {\n                 });\n             }\n         }\n-    })\n+    } }\n \n-    test!(fn recv_a_lot() {\n+    test! { fn recv_a_lot() {\n         // Regression test that we don't run out of stack in scheduler context\n         let (tx, rx) = sync_channel(10000);\n         for _ in range(0u, 10000) { tx.send(()); }\n         for _ in range(0u, 10000) { rx.recv(); }\n-    })\n+    } }\n \n-    test!(fn shared_chan_stress() {\n+    test! { fn shared_chan_stress() {\n         let (tx, rx) = sync_channel(0);\n         let total = stress_factor() + 100;\n         for _ in range(0, total) {\n@@ -1893,9 +1893,9 @@ mod sync_tests {\n         for _ in range(0, total) {\n             rx.recv();\n         }\n-    })\n+    } }\n \n-    test!(fn test_nested_recv_iter() {\n+    test! { fn test_nested_recv_iter() {\n         let (tx, rx) = sync_channel::<int>(0);\n         let (total_tx, total_rx) = sync_channel::<int>(0);\n \n@@ -1912,9 +1912,9 @@ mod sync_tests {\n         tx.send(2);\n         drop(tx);\n         assert_eq!(total_rx.recv(), 6);\n-    })\n+    } }\n \n-    test!(fn test_recv_iter_break() {\n+    test! { fn test_recv_iter_break() {\n         let (tx, rx) = sync_channel::<int>(0);\n         let (count_tx, count_rx) = sync_channel(0);\n \n@@ -1936,9 +1936,9 @@ mod sync_tests {\n         let _ = tx.try_send(2);\n         drop(tx);\n         assert_eq!(count_rx.recv(), 4);\n-    })\n+    } }\n \n-    test!(fn try_recv_states() {\n+    test! { fn try_recv_states() {\n         let (tx1, rx1) = sync_channel::<int>(1);\n         let (tx2, rx2) = sync_channel::<()>(1);\n         let (tx3, rx3) = sync_channel::<()>(1);\n@@ -1959,11 +1959,11 @@ mod sync_tests {\n         tx2.send(());\n         rx3.recv();\n         assert_eq!(rx1.try_recv(), Err(Disconnected));\n-    })\n+    } }\n \n     // This bug used to end up in a livelock inside of the Receiver destructor\n     // because the internal state of the Shared packet was corrupted\n-    test!(fn destroy_upgraded_shared_port_when_sender_still_active() {\n+    test! { fn destroy_upgraded_shared_port_when_sender_still_active() {\n         let (tx, rx) = sync_channel::<()>(0);\n         let (tx2, rx2) = sync_channel::<()>(0);\n         spawn(move|| {\n@@ -1981,9 +1981,9 @@ mod sync_tests {\n \n         // wait for the child task to exit before we exit\n         rx2.recv();\n-    })\n+    } }\n \n-    test!(fn try_recvs_off_the_runtime() {\n+    test! { fn try_recvs_off_the_runtime() {\n         use rustrt::thread::Thread;\n \n         let (tx, rx) = sync_channel::<()>(0);\n@@ -2004,28 +2004,28 @@ mod sync_tests {\n         }\n         t.join();\n         pdone.recv();\n-    })\n+    } }\n \n-    test!(fn send_opt1() {\n+    test! { fn send_opt1() {\n         let (tx, rx) = sync_channel::<int>(0);\n         spawn(move|| { rx.recv(); });\n         assert_eq!(tx.send_opt(1), Ok(()));\n-    })\n+    } }\n \n-    test!(fn send_opt2() {\n+    test! { fn send_opt2() {\n         let (tx, rx) = sync_channel::<int>(0);\n         spawn(move|| { drop(rx); });\n         assert_eq!(tx.send_opt(1), Err(1));\n-    })\n+    } }\n \n-    test!(fn send_opt3() {\n+    test! { fn send_opt3() {\n         let (tx, rx) = sync_channel::<int>(1);\n         assert_eq!(tx.send_opt(1), Ok(()));\n         spawn(move|| { drop(rx); });\n         assert_eq!(tx.send_opt(1), Err(1));\n-    })\n+    } }\n \n-    test!(fn send_opt4() {\n+    test! { fn send_opt4() {\n         let (tx, rx) = sync_channel::<int>(0);\n         let tx2 = tx.clone();\n         let (done, donerx) = channel();\n@@ -2041,36 +2041,36 @@ mod sync_tests {\n         drop(rx);\n         donerx.recv();\n         donerx.recv();\n-    })\n+    } }\n \n-    test!(fn try_send1() {\n+    test! { fn try_send1() {\n         let (tx, _rx) = sync_channel::<int>(0);\n         assert_eq!(tx.try_send(1), Err(Full(1)));\n-    })\n+    } }\n \n-    test!(fn try_send2() {\n+    test! { fn try_send2() {\n         let (tx, _rx) = sync_channel::<int>(1);\n         assert_eq!(tx.try_send(1), Ok(()));\n         assert_eq!(tx.try_send(1), Err(Full(1)));\n-    })\n+    } }\n \n-    test!(fn try_send3() {\n+    test! { fn try_send3() {\n         let (tx, rx) = sync_channel::<int>(1);\n         assert_eq!(tx.try_send(1), Ok(()));\n         drop(rx);\n         assert_eq!(tx.try_send(1), Err(RecvDisconnected(1)));\n-    })\n+    } }\n \n-    test!(fn try_send4() {\n+    test! { fn try_send4() {\n         let (tx, rx) = sync_channel::<int>(0);\n         spawn(move|| {\n             for _ in range(0u, 1000) { task::deschedule(); }\n             assert_eq!(tx.try_send(1), Ok(()));\n         });\n         assert_eq!(rx.recv(), 1);\n-    } #[ignore(reason = \"flaky on libnative\")])\n+    } #[ignore(reason = \"flaky on libnative\")] }\n \n-    test!(fn issue_15761() {\n+    test! { fn issue_15761() {\n         fn repro() {\n             let (tx1, rx1) = sync_channel::<()>(3);\n             let (tx2, rx2) = sync_channel::<()>(3);\n@@ -2087,5 +2087,5 @@ mod sync_tests {\n         for _ in range(0u, 100) {\n             repro()\n         }\n-    })\n+    } }\n }"}, {"sha": "de2b84b083c2329266edd0157480a434f136d734", "filename": "src/libstd/comm/select.rs", "status": "modified", "additions": 80, "deletions": 80, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibstd%2Fcomm%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibstd%2Fcomm%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fselect.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -347,58 +347,58 @@ mod test {\n         })\n     }\n \n-    test!(fn smoke() {\n+    test! { fn smoke() {\n         let (tx1, rx1) = channel::<int>();\n         let (tx2, rx2) = channel::<int>();\n         tx1.send(1);\n-        select! (\n+        select! {\n             foo = rx1.recv() => { assert_eq!(foo, 1); },\n             _bar = rx2.recv() => { panic!() }\n-        )\n+        }\n         tx2.send(2);\n-        select! (\n+        select! {\n             _foo = rx1.recv() => { panic!() },\n             bar = rx2.recv() => { assert_eq!(bar, 2) }\n-        )\n+        }\n         drop(tx1);\n-        select! (\n+        select! {\n             foo = rx1.recv_opt() => { assert_eq!(foo, Err(())); },\n             _bar = rx2.recv() => { panic!() }\n-        )\n+        }\n         drop(tx2);\n-        select! (\n+        select! {\n             bar = rx2.recv_opt() => { assert_eq!(bar, Err(())); }\n-        )\n-    })\n+        }\n+    } }\n \n-    test!(fn smoke2() {\n+    test! { fn smoke2() {\n         let (_tx1, rx1) = channel::<int>();\n         let (_tx2, rx2) = channel::<int>();\n         let (_tx3, rx3) = channel::<int>();\n         let (_tx4, rx4) = channel::<int>();\n         let (tx5, rx5) = channel::<int>();\n         tx5.send(4);\n-        select! (\n+        select! {\n             _foo = rx1.recv() => { panic!(\"1\") },\n             _foo = rx2.recv() => { panic!(\"2\") },\n             _foo = rx3.recv() => { panic!(\"3\") },\n             _foo = rx4.recv() => { panic!(\"4\") },\n             foo = rx5.recv() => { assert_eq!(foo, 4); }\n-        )\n-    })\n+        }\n+    } }\n \n-    test!(fn closed() {\n+    test! { fn closed() {\n         let (_tx1, rx1) = channel::<int>();\n         let (tx2, rx2) = channel::<int>();\n         drop(tx2);\n \n-        select! (\n+        select! {\n             _a1 = rx1.recv_opt() => { panic!() },\n             a2 = rx2.recv_opt() => { assert_eq!(a2, Err(())); }\n-        )\n-    })\n+        }\n+    } }\n \n-    test!(fn unblocks() {\n+    test! { fn unblocks() {\n         let (tx1, rx1) = channel::<int>();\n         let (_tx2, rx2) = channel::<int>();\n         let (tx3, rx3) = channel::<int>();\n@@ -410,18 +410,18 @@ mod test {\n             for _ in range(0u, 20) { task::deschedule(); }\n         });\n \n-        select! (\n+        select! {\n             a = rx1.recv() => { assert_eq!(a, 1); },\n             _b = rx2.recv() => { panic!() }\n-        )\n+        }\n         tx3.send(1);\n-        select! (\n+        select! {\n             a = rx1.recv_opt() => { assert_eq!(a, Err(())); },\n             _b = rx2.recv() => { panic!() }\n-        )\n-    })\n+        }\n+    } }\n \n-    test!(fn both_ready() {\n+    test! { fn both_ready() {\n         let (tx1, rx1) = channel::<int>();\n         let (tx2, rx2) = channel::<int>();\n         let (tx3, rx3) = channel::<()>();\n@@ -433,20 +433,20 @@ mod test {\n             rx3.recv();\n         });\n \n-        select! (\n+        select! {\n             a = rx1.recv() => { assert_eq!(a, 1); },\n             a = rx2.recv() => { assert_eq!(a, 2); }\n-        )\n-        select! (\n+        }\n+        select! {\n             a = rx1.recv() => { assert_eq!(a, 1); },\n             a = rx2.recv() => { assert_eq!(a, 2); }\n-        )\n+        }\n         assert_eq!(rx1.try_recv(), Err(Empty));\n         assert_eq!(rx2.try_recv(), Err(Empty));\n         tx3.send(());\n-    })\n+    } }\n \n-    test!(fn stress() {\n+    test! { fn stress() {\n         static AMT: int = 10000;\n         let (tx1, rx1) = channel::<int>();\n         let (tx2, rx2) = channel::<int>();\n@@ -464,15 +464,15 @@ mod test {\n         });\n \n         for i in range(0, AMT) {\n-            select! (\n+            select! {\n                 i1 = rx1.recv() => { assert!(i % 2 == 0 && i == i1); },\n                 i2 = rx2.recv() => { assert!(i % 2 == 1 && i == i2); }\n-            )\n+            }\n             tx3.send(());\n         }\n-    })\n+    } }\n \n-    test!(fn cloning() {\n+    test! { fn cloning() {\n         let (tx1, rx1) = channel::<int>();\n         let (_tx2, rx2) = channel::<int>();\n         let (tx3, rx3) = channel::<()>();\n@@ -486,14 +486,14 @@ mod test {\n         });\n \n         tx3.send(());\n-        select!(\n+        select! {\n             _i1 = rx1.recv() => {},\n             _i2 = rx2.recv() => panic!()\n-        )\n+        }\n         tx3.send(());\n-    })\n+    } }\n \n-    test!(fn cloning2() {\n+    test! { fn cloning2() {\n         let (tx1, rx1) = channel::<int>();\n         let (_tx2, rx2) = channel::<int>();\n         let (tx3, rx3) = channel::<()>();\n@@ -507,14 +507,14 @@ mod test {\n         });\n \n         tx3.send(());\n-        select!(\n+        select! {\n             _i1 = rx1.recv() => {},\n             _i2 = rx2.recv() => panic!()\n-        )\n+        }\n         tx3.send(());\n-    })\n+    } }\n \n-    test!(fn cloning3() {\n+    test! { fn cloning3() {\n         let (tx1, rx1) = channel::<()>();\n         let (tx2, rx2) = channel::<()>();\n         let (tx3, rx3) = channel::<()>();\n@@ -532,73 +532,73 @@ mod test {\n         drop(tx1.clone());\n         tx2.send(());\n         rx3.recv();\n-    })\n+    } }\n \n-    test!(fn preflight1() {\n+    test! { fn preflight1() {\n         let (tx, rx) = channel();\n         tx.send(());\n-        select!(\n+        select! {\n             () = rx.recv() => {}\n-        )\n-    })\n+        }\n+    } }\n \n-    test!(fn preflight2() {\n+    test! { fn preflight2() {\n         let (tx, rx) = channel();\n         tx.send(());\n         tx.send(());\n-        select!(\n+        select! {\n             () = rx.recv() => {}\n-        )\n-    })\n+        }\n+    } }\n \n-    test!(fn preflight3() {\n+    test! { fn preflight3() {\n         let (tx, rx) = channel();\n         drop(tx.clone());\n         tx.send(());\n-        select!(\n+        select! {\n             () = rx.recv() => {}\n-        )\n-    })\n+        }\n+    } }\n \n-    test!(fn preflight4() {\n+    test! { fn preflight4() {\n         let (tx, rx) = channel();\n         tx.send(());\n         let s = Select::new();\n         let mut h = s.handle(&rx);\n         unsafe { h.add(); }\n         assert_eq!(s.wait2(false), h.id);\n-    })\n+    } }\n \n-    test!(fn preflight5() {\n+    test! { fn preflight5() {\n         let (tx, rx) = channel();\n         tx.send(());\n         tx.send(());\n         let s = Select::new();\n         let mut h = s.handle(&rx);\n         unsafe { h.add(); }\n         assert_eq!(s.wait2(false), h.id);\n-    })\n+    } }\n \n-    test!(fn preflight6() {\n+    test! { fn preflight6() {\n         let (tx, rx) = channel();\n         drop(tx.clone());\n         tx.send(());\n         let s = Select::new();\n         let mut h = s.handle(&rx);\n         unsafe { h.add(); }\n         assert_eq!(s.wait2(false), h.id);\n-    })\n+    } }\n \n-    test!(fn preflight7() {\n+    test! { fn preflight7() {\n         let (tx, rx) = channel::<()>();\n         drop(tx);\n         let s = Select::new();\n         let mut h = s.handle(&rx);\n         unsafe { h.add(); }\n         assert_eq!(s.wait2(false), h.id);\n-    })\n+    } }\n \n-    test!(fn preflight8() {\n+    test! { fn preflight8() {\n         let (tx, rx) = channel();\n         tx.send(());\n         drop(tx);\n@@ -607,9 +607,9 @@ mod test {\n         let mut h = s.handle(&rx);\n         unsafe { h.add(); }\n         assert_eq!(s.wait2(false), h.id);\n-    })\n+    } }\n \n-    test!(fn preflight9() {\n+    test! { fn preflight9() {\n         let (tx, rx) = channel();\n         drop(tx.clone());\n         tx.send(());\n@@ -619,9 +619,9 @@ mod test {\n         let mut h = s.handle(&rx);\n         unsafe { h.add(); }\n         assert_eq!(s.wait2(false), h.id);\n-    })\n+    } }\n \n-    test!(fn oneshot_data_waiting() {\n+    test! { fn oneshot_data_waiting() {\n         let (tx1, rx1) = channel();\n         let (tx2, rx2) = channel();\n         spawn(move|| {\n@@ -634,9 +634,9 @@ mod test {\n         for _ in range(0u, 100) { task::deschedule() }\n         tx1.send(());\n         rx2.recv();\n-    })\n+    } }\n \n-    test!(fn stream_data_waiting() {\n+    test! { fn stream_data_waiting() {\n         let (tx1, rx1) = channel();\n         let (tx2, rx2) = channel();\n         tx1.send(());\n@@ -653,9 +653,9 @@ mod test {\n         for _ in range(0u, 100) { task::deschedule() }\n         tx1.send(());\n         rx2.recv();\n-    })\n+    } }\n \n-    test!(fn shared_data_waiting() {\n+    test! { fn shared_data_waiting() {\n         let (tx1, rx1) = channel();\n         let (tx2, rx2) = channel();\n         drop(tx1.clone());\n@@ -671,17 +671,17 @@ mod test {\n         for _ in range(0u, 100) { task::deschedule() }\n         tx1.send(());\n         rx2.recv();\n-    })\n+    } }\n \n-    test!(fn sync1() {\n+    test! { fn sync1() {\n         let (tx, rx) = sync_channel::<int>(1);\n         tx.send(1);\n         select! {\n             n = rx.recv() => { assert_eq!(n, 1); }\n         }\n-    })\n+    } }\n \n-    test!(fn sync2() {\n+    test! { fn sync2() {\n         let (tx, rx) = sync_channel::<int>(0);\n         spawn(move|| {\n             for _ in range(0u, 100) { task::deschedule() }\n@@ -690,9 +690,9 @@ mod test {\n         select! {\n             n = rx.recv() => { assert_eq!(n, 1); }\n         }\n-    })\n+    } }\n \n-    test!(fn sync3() {\n+    test! { fn sync3() {\n         let (tx1, rx1) = sync_channel::<int>(0);\n         let (tx2, rx2): (Sender<int>, Receiver<int>) = channel();\n         spawn(move|| { tx1.send(1); });\n@@ -707,5 +707,5 @@ mod test {\n                 assert_eq!(rx1.recv(), 1);\n             }\n         }\n-    })\n+    } }\n }"}, {"sha": "89bccb8b99fe80cde23bee88ae17b26d9e431f88", "filename": "src/libstd/failure.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibstd%2Ffailure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibstd%2Ffailure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffailure.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -27,9 +27,11 @@ use str::Str;\n use string::String;\n \n // Defined in this module instead of io::stdio so that the unwinding\n-thread_local!(pub static LOCAL_STDERR: RefCell<Option<Box<Writer + Send>>> = {\n-    RefCell::new(None)\n-})\n+thread_local! {\n+    pub static LOCAL_STDERR: RefCell<Option<Box<Writer + Send>>> = {\n+        RefCell::new(None)\n+    }\n+}\n \n impl Writer for Stdio {\n     fn write(&mut self, bytes: &[u8]) -> IoResult<()> {"}, {"sha": "c1f1a5b786985d96dd936701e89b473f1bd7eea5", "filename": "src/libstd/io/extensions.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibstd%2Fio%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibstd%2Fio%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fextensions.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -511,7 +511,7 @@ mod bench {\n     use self::test::Bencher;\n \n     // why is this a macro? wouldn't an inlined function work just as well?\n-    macro_rules! u64_from_be_bytes_bench_impl(\n+    macro_rules! u64_from_be_bytes_bench_impl {\n         ($b:expr, $size:expr, $stride:expr, $start_index:expr) =>\n         ({\n             use super::u64_from_be_bytes;\n@@ -526,7 +526,7 @@ mod bench {\n                 }\n             });\n         })\n-    )\n+    }\n \n     #[bench]\n     fn u64_from_be_bytes_4_aligned(b: &mut Bencher) {"}, {"sha": "fd3bae73cd3676d293f02e91d8d374eaa0a53224", "filename": "src/libstd/io/fs.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibstd%2Fio%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibstd%2Fio%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ffs.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -828,20 +828,20 @@ mod test {\n     use ops::Drop;\n     use str::StrPrelude;\n \n-    macro_rules! check( ($e:expr) => (\n+    macro_rules! check { ($e:expr) => (\n         match $e {\n             Ok(t) => t,\n             Err(e) => panic!(\"{} failed with: {}\", stringify!($e), e),\n         }\n-    ) )\n+    ) }\n \n-    macro_rules! error( ($e:expr, $s:expr) => (\n+    macro_rules! error { ($e:expr, $s:expr) => (\n         match $e {\n             Ok(_) => panic!(\"Unexpected success. Should've been: {}\", $s),\n             Err(ref err) => assert!(err.to_string().contains($s.as_slice()),\n                                     format!(\"`{}` did not contain `{}`\", err, $s))\n         }\n-    ) )\n+    ) }\n \n     pub struct TempDir(Path);\n "}, {"sha": "5a3f5bd466884a1279a5478d64d7048610cbd28b", "filename": "src/libstd/io/net/ip.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibstd%2Fio%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibstd%2Fio%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fip.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -478,7 +478,7 @@ fn resolve_socket_addr(s: &str, p: u16) -> IoResult<Vec<SocketAddr>> {\n }\n \n fn parse_and_resolve_socket_addr(s: &str) -> IoResult<Vec<SocketAddr>> {\n-    macro_rules! try_opt(\n+    macro_rules! try_opt {\n         ($e:expr, $msg:expr) => (\n             match $e {\n                 Some(r) => r,\n@@ -489,7 +489,7 @@ fn parse_and_resolve_socket_addr(s: &str) -> IoResult<Vec<SocketAddr>> {\n                 })\n             }\n         )\n-    )\n+    }\n \n     // split the string by ':' and convert the second part to u16\n     let mut parts_iter = s.rsplitn(2, ':');"}, {"sha": "73be389bb914e9d66b2f359eb727f7c02556d4da", "filename": "src/libstd/io/stdio.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibstd%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibstd%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fstdio.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -95,9 +95,11 @@ fn src<T, F>(fd: libc::c_int, _readable: bool, f: F) -> T where\n     }\n }\n \n-thread_local!(static LOCAL_STDOUT: RefCell<Option<Box<Writer + Send>>> = {\n-    RefCell::new(None)\n-})\n+thread_local! {\n+    static LOCAL_STDOUT: RefCell<Option<Box<Writer + Send>>> = {\n+        RefCell::new(None)\n+    }\n+}\n \n /// A synchronized wrapper around a buffered reader from stdin\n #[deriving(Clone)]"}, {"sha": "798dac1a72f9c0056dc27f51e7f91126f44d94b0", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 47, "deletions": 45, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -37,7 +37,7 @@\n /// panic!(\"this is a {} {message}\", \"fancy\", message = \"message\");\n /// ```\n #[macro_export]\n-macro_rules! panic(\n+macro_rules! panic {\n     () => ({\n         panic!(\"explicit panic\")\n     });\n@@ -70,7 +70,7 @@ macro_rules! panic(\n         }\n         format_args!(_run_fmt, $fmt, $($arg)*)\n     });\n-)\n+}\n \n /// Ensure that a boolean expression is `true` at runtime.\n ///\n@@ -93,7 +93,7 @@ macro_rules! panic(\n /// assert!(a + b == 30, \"a = {}, b = {}\", a, b);\n /// ```\n #[macro_export]\n-macro_rules! assert(\n+macro_rules! assert {\n     ($cond:expr) => (\n         if !$cond {\n             panic!(concat!(\"assertion failed: \", stringify!($cond)))\n@@ -104,7 +104,7 @@ macro_rules! assert(\n             panic!($($arg),+)\n         }\n     );\n-)\n+}\n \n /// Asserts that two expressions are equal to each other, testing equality in\n /// both directions.\n@@ -119,7 +119,7 @@ macro_rules! assert(\n /// assert_eq!(a, b);\n /// ```\n #[macro_export]\n-macro_rules! assert_eq(\n+macro_rules! assert_eq {\n     ($left:expr , $right:expr) => ({\n         match (&($left), &($right)) {\n             (left_val, right_val) => {\n@@ -132,7 +132,7 @@ macro_rules! assert_eq(\n             }\n         }\n     })\n-)\n+}\n \n /// Ensure that a boolean expression is `true` at runtime.\n ///\n@@ -160,9 +160,9 @@ macro_rules! assert_eq(\n /// debug_assert!(a + b == 30, \"a = {}, b = {}\", a, b);\n /// ```\n #[macro_export]\n-macro_rules! debug_assert(\n+macro_rules! debug_assert {\n     ($($arg:tt)*) => (if cfg!(not(ndebug)) { assert!($($arg)*); })\n-)\n+}\n \n /// Asserts that two expressions are equal to each other, testing equality in\n /// both directions.\n@@ -182,9 +182,9 @@ macro_rules! debug_assert(\n /// debug_assert_eq!(a, b);\n /// ```\n #[macro_export]\n-macro_rules! debug_assert_eq(\n+macro_rules! debug_assert_eq {\n     ($($arg:tt)*) => (if cfg!(not(ndebug)) { assert_eq!($($arg)*); })\n-)\n+}\n \n /// A utility macro for indicating unreachable code.\n ///\n@@ -226,7 +226,7 @@ macro_rules! debug_assert_eq(\n /// }\n /// ```\n #[macro_export]\n-macro_rules! unreachable(\n+macro_rules! unreachable {\n     () => ({\n         panic!(\"internal error: entered unreachable code\")\n     });\n@@ -236,14 +236,14 @@ macro_rules! unreachable(\n     ($fmt:expr, $($arg:tt)*) => ({\n         panic!(concat!(\"internal error: entered unreachable code: \", $fmt), $($arg)*)\n     });\n-)\n+}\n \n /// A standardised placeholder for marking unfinished code. It panics with the\n /// message `\"not yet implemented\"` when executed.\n #[macro_export]\n-macro_rules! unimplemented(\n+macro_rules! unimplemented {\n     () => (panic!(\"not yet implemented\"))\n-)\n+}\n \n /// Use the syntax described in `std::fmt` to create a value of type `String`.\n /// See `std::fmt` for more information.\n@@ -257,11 +257,11 @@ macro_rules! unimplemented(\n /// ```\n #[macro_export]\n #[stable]\n-macro_rules! format(\n+macro_rules! format {\n     ($($arg:tt)*) => (\n         format_args!(::std::fmt::format, $($arg)*)\n     )\n-)\n+}\n \n /// Use the `format!` syntax to write data into a buffer of type `&mut Writer`.\n /// See `std::fmt` for more information.\n@@ -277,30 +277,30 @@ macro_rules! format(\n /// ```\n #[macro_export]\n #[stable]\n-macro_rules! write(\n+macro_rules! write {\n     ($dst:expr, $($arg:tt)*) => ({\n         let dst = &mut *$dst;\n         format_args!(|args| { dst.write_fmt(args) }, $($arg)*)\n     })\n-)\n+}\n \n /// Equivalent to the `write!` macro, except that a newline is appended after\n /// the message is written.\n #[macro_export]\n #[stable]\n-macro_rules! writeln(\n+macro_rules! writeln {\n     ($dst:expr, $fmt:expr $($arg:tt)*) => (\n         write!($dst, concat!($fmt, \"\\n\") $($arg)*)\n     )\n-)\n+}\n \n /// Equivalent to the `println!` macro except that a newline is not printed at\n /// the end of the message.\n #[macro_export]\n #[stable]\n-macro_rules! print(\n+macro_rules! print {\n     ($($arg:tt)*) => (format_args!(::std::io::stdio::print_args, $($arg)*))\n-)\n+}\n \n /// Macro for printing to a task's stdout handle.\n ///\n@@ -316,33 +316,33 @@ macro_rules! print(\n /// ```\n #[macro_export]\n #[stable]\n-macro_rules! println(\n+macro_rules! println {\n     ($($arg:tt)*) => (format_args!(::std::io::stdio::println_args, $($arg)*))\n-)\n+}\n \n /// Helper macro for unwrapping `Result` values while returning early with an\n /// error if the value of the expression is `Err`. For more information, see\n /// `std::io`.\n #[macro_export]\n-macro_rules! try (\n+macro_rules! try {\n     ($expr:expr) => ({\n         match $expr {\n             Ok(val) => val,\n             Err(err) => return Err(::std::error::FromError::from_error(err))\n         }\n     })\n-)\n+}\n \n /// Create a `std::vec::Vec` containing the arguments.\n #[macro_export]\n-macro_rules! vec[\n+macro_rules! vec {\n     ($($x:expr),*) => ({\n         use std::slice::BoxedSliceExt;\n         let xs: ::std::boxed::Box<[_]> = box [$($x),*];\n         xs.into_vec()\n     });\n     ($($x:expr,)*) => (vec![$($x),*])\n-]\n+}\n \n /// A macro to select an event from a number of receivers.\n ///\n@@ -394,11 +394,11 @@ macro_rules! select {\n // uses. To get around this difference, we redefine the log!() macro here to be\n // just a dumb version of what it should be.\n #[cfg(test)]\n-macro_rules! log (\n+macro_rules! log {\n     ($lvl:expr, $($args:tt)*) => (\n         if log_enabled!($lvl) { println!($($args)*) }\n     )\n-)\n+}\n \n /// Built-in macros to the compiler itself.\n ///\n@@ -430,9 +430,9 @@ pub mod builtin {\n     /// }, \"hello {}\", \"world\");\n     /// ```\n     #[macro_export]\n-    macro_rules! format_args( ($closure:expr, $fmt:expr $($args:tt)*) => ({\n+    macro_rules! format_args { ($closure:expr, $fmt:expr $($args:tt)*) => ({\n         /* compiler built-in */\n-    }) )\n+    }) }\n \n     /// Inspect an environment variable at compile time.\n     ///\n@@ -450,7 +450,7 @@ pub mod builtin {\n     /// println!(\"the $PATH variable at the time of compiling was: {}\", path);\n     /// ```\n     #[macro_export]\n-    macro_rules! env( ($name:expr) => ({ /* compiler built-in */ }) )\n+    macro_rules! env { ($name:expr) => ({ /* compiler built-in */ }) }\n \n     /// Optionally inspect an environment variable at compile time.\n     ///\n@@ -469,7 +469,7 @@ pub mod builtin {\n     /// println!(\"the secret key might be: {}\", key);\n     /// ```\n     #[macro_export]\n-    macro_rules! option_env( ($name:expr) => ({ /* compiler built-in */ }) )\n+    macro_rules! option_env { ($name:expr) => ({ /* compiler built-in */ }) }\n \n     /// Concatenate literals into a static byte slice.\n     ///\n@@ -489,7 +489,7 @@ pub mod builtin {\n     /// assert_eq!(rust[4], 255);\n     /// ```\n     #[macro_export]\n-    macro_rules! bytes( ($($e:expr),*) => ({ /* compiler built-in */ }) )\n+    macro_rules! bytes { ($($e:expr),*) => ({ /* compiler built-in */ }) }\n \n     /// Concatenate identifiers into one identifier.\n     ///\n@@ -513,7 +513,9 @@ pub mod builtin {\n     /// # }\n     /// ```\n     #[macro_export]\n-    macro_rules! concat_idents( ($($e:ident),*) => ({ /* compiler built-in */ }) )\n+    macro_rules! concat_idents {\n+        ($($e:ident),*) => ({ /* compiler built-in */ })\n+    }\n \n     /// Concatenates literals into a static string slice.\n     ///\n@@ -531,7 +533,7 @@ pub mod builtin {\n     /// assert_eq!(s, \"test10btrue\");\n     /// ```\n     #[macro_export]\n-    macro_rules! concat( ($($e:expr),*) => ({ /* compiler built-in */ }) )\n+    macro_rules! concat { ($($e:expr),*) => ({ /* compiler built-in */ }) }\n \n     /// A macro which expands to the line number on which it was invoked.\n     ///\n@@ -546,7 +548,7 @@ pub mod builtin {\n     /// println!(\"defined on line: {}\", current_line);\n     /// ```\n     #[macro_export]\n-    macro_rules! line( () => ({ /* compiler built-in */ }) )\n+    macro_rules! line { () => ({ /* compiler built-in */ }) }\n \n     /// A macro which expands to the column number on which it was invoked.\n     ///\n@@ -561,7 +563,7 @@ pub mod builtin {\n     /// println!(\"defined on column: {}\", current_col);\n     /// ```\n     #[macro_export]\n-    macro_rules! column( () => ({ /* compiler built-in */ }) )\n+    macro_rules! column { () => ({ /* compiler built-in */ }) }\n \n     /// A macro which expands to the file name from which it was invoked.\n     ///\n@@ -577,7 +579,7 @@ pub mod builtin {\n     /// println!(\"defined in file: {}\", this_file);\n     /// ```\n     #[macro_export]\n-    macro_rules! file( () => ({ /* compiler built-in */ }) )\n+    macro_rules! file { () => ({ /* compiler built-in */ }) }\n \n     /// A macro which stringifies its argument.\n     ///\n@@ -592,7 +594,7 @@ pub mod builtin {\n     /// assert_eq!(one_plus_one, \"1 + 1\");\n     /// ```\n     #[macro_export]\n-    macro_rules! stringify( ($t:tt) => ({ /* compiler built-in */ }) )\n+    macro_rules! stringify { ($t:tt) => ({ /* compiler built-in */ }) }\n \n     /// Includes a utf8-encoded file as a string.\n     ///\n@@ -606,7 +608,7 @@ pub mod builtin {\n     /// let secret_key = include_str!(\"secret-key.ascii\");\n     /// ```\n     #[macro_export]\n-    macro_rules! include_str( ($file:expr) => ({ /* compiler built-in */ }) )\n+    macro_rules! include_str { ($file:expr) => ({ /* compiler built-in */ }) }\n \n     /// Includes a file as a byte slice.\n     ///\n@@ -620,7 +622,7 @@ pub mod builtin {\n     /// let secret_key = include_bin!(\"secret-key.bin\");\n     /// ```\n     #[macro_export]\n-    macro_rules! include_bin( ($file:expr) => ({ /* compiler built-in */ }) )\n+    macro_rules! include_bin { ($file:expr) => ({ /* compiler built-in */ }) }\n \n     /// Expands to a string that represents the current module path.\n     ///\n@@ -640,7 +642,7 @@ pub mod builtin {\n     /// test::foo();\n     /// ```\n     #[macro_export]\n-    macro_rules! module_path( () => ({ /* compiler built-in */ }) )\n+    macro_rules! module_path { () => ({ /* compiler built-in */ }) }\n \n     /// Boolean evaluation of configuration flags.\n     ///\n@@ -661,5 +663,5 @@ pub mod builtin {\n     /// };\n     /// ```\n     #[macro_export]\n-    macro_rules! cfg( ($cfg:tt) => ({ /* compiler built-in */ }) )\n+    macro_rules! cfg { ($cfg:tt) => ({ /* compiler built-in */ }) }\n }"}, {"sha": "60b17de1718759dc5d97d8008ffda7bc24b6fe61", "filename": "src/libstd/num/f32.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibstd%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibstd%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff32.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -671,8 +671,8 @@ mod tests {\n         let inf: f32 = Float::infinity();\n         let neg_inf: f32 = Float::neg_infinity();\n         let nan: f32 = Float::nan();\n-        assert_eq!(match inf.frexp() { (x, _) => x }, inf)\n-        assert_eq!(match neg_inf.frexp() { (x, _) => x }, neg_inf)\n+        assert_eq!(match inf.frexp() { (x, _) => x }, inf);\n+        assert_eq!(match neg_inf.frexp() { (x, _) => x }, neg_inf);\n         assert!(match nan.frexp() { (x, _) => x.is_nan() })\n     }\n "}, {"sha": "4b31e33236d44305224eb3c2946e211d5c11582d", "filename": "src/libstd/num/f64.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibstd%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibstd%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff64.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -673,8 +673,8 @@ mod tests {\n         let inf: f64 = Float::infinity();\n         let neg_inf: f64 = Float::neg_infinity();\n         let nan: f64 = Float::nan();\n-        assert_eq!(match inf.frexp() { (x, _) => x }, inf)\n-        assert_eq!(match neg_inf.frexp() { (x, _) => x }, neg_inf)\n+        assert_eq!(match inf.frexp() { (x, _) => x }, inf);\n+        assert_eq!(match neg_inf.frexp() { (x, _) => x }, neg_inf);\n         assert!(match nan.frexp() { (x, _) => x.is_nan() })\n     }\n "}, {"sha": "fd00f15662a72eae099aca9854e2b718597f7cd4", "filename": "src/libstd/num/float_macros.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibstd%2Fnum%2Ffloat_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibstd%2Fnum%2Ffloat_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ffloat_macros.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -12,11 +12,11 @@\n #![macro_escape]\n #![doc(hidden)]\n \n-macro_rules! assert_approx_eq(\n+macro_rules! assert_approx_eq {\n     ($a:expr, $b:expr) => ({\n         use num::Float;\n         let (a, b) = (&$a, &$b);\n         assert!((*a - *b).abs() < 1.0e-6,\n                 \"{} is not approximately equal to {}\", *a, *b);\n     })\n-)\n+}"}, {"sha": "367147b84bed421b5b13f4e17466fb27b5acb312", "filename": "src/libstd/num/i16.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibstd%2Fnum%2Fi16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibstd%2Fnum%2Fi16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fi16.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -15,4 +15,4 @@\n \n pub use core::i16::{BITS, BYTES, MIN, MAX};\n \n-int_module!(i16)\n+int_module! { i16 }"}, {"sha": "19fb40c9644f65314ae700375d070695d6c495dd", "filename": "src/libstd/num/i32.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibstd%2Fnum%2Fi32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibstd%2Fnum%2Fi32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fi32.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -15,4 +15,4 @@\n \n pub use core::i32::{BITS, BYTES, MIN, MAX};\n \n-int_module!(i32)\n+int_module! { i32 }"}, {"sha": "2379b03c64fe2e31fd8f14619d4316e708ba3901", "filename": "src/libstd/num/i64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibstd%2Fnum%2Fi64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibstd%2Fnum%2Fi64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fi64.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -15,4 +15,4 @@\n \n pub use core::i64::{BITS, BYTES, MIN, MAX};\n \n-int_module!(i64)\n+int_module! { i64 }"}, {"sha": "a09ceefc6a0b41a41c1a8e146d55d1e3818cb7a6", "filename": "src/libstd/num/i8.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibstd%2Fnum%2Fi8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibstd%2Fnum%2Fi8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fi8.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -15,4 +15,4 @@\n \n pub use core::i8::{BITS, BYTES, MIN, MAX};\n \n-int_module!(i8)\n+int_module! { i8 }"}, {"sha": "f59dab4b20bde4c35419f59d43f258e1720a8e72", "filename": "src/libstd/num/int.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibstd%2Fnum%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibstd%2Fnum%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fint.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -15,4 +15,4 @@\n \n pub use core::int::{BITS, BYTES, MIN, MAX};\n \n-int_module!(int)\n+int_module! { int }"}, {"sha": "fce150c4ad1e3676b79509d223c958387e21a486", "filename": "src/libstd/num/int_macros.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibstd%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibstd%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fint_macros.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -12,6 +12,6 @@\n #![macro_escape]\n #![doc(hidden)]\n \n-macro_rules! int_module (($T:ty) => (\n+macro_rules! int_module { ($T:ty) => (\n \n-))\n+) }"}, {"sha": "a568aafe1edc7bfc6d874a2d9045d1ae1daac98c", "filename": "src/libstd/num/mod.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibstd%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibstd%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fmod.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -161,7 +161,7 @@ mod tests {\n     use u64;\n     use uint;\n \n-    macro_rules! test_cast_20(\n+    macro_rules! test_cast_20 {\n         ($_20:expr) => ({\n             let _20 = $_20;\n \n@@ -204,7 +204,7 @@ mod tests {\n             assert_eq!(_20, cast(20f32).unwrap());\n             assert_eq!(_20, cast(20f64).unwrap());\n         })\n-    )\n+    }\n \n     #[test] fn test_u8_cast()    { test_cast_20!(20u8)  }\n     #[test] fn test_u16_cast()   { test_cast_20!(20u16) }\n@@ -664,7 +664,7 @@ mod tests {\n         assert_eq!(third.checked_mul(4), None);\n     }\n \n-    macro_rules! test_next_power_of_two(\n+    macro_rules! test_next_power_of_two {\n         ($test_name:ident, $T:ident) => (\n             fn $test_name() {\n                 #![test]\n@@ -676,15 +676,15 @@ mod tests {\n                 }\n             }\n         )\n-    )\n+    }\n \n-    test_next_power_of_two!(test_next_power_of_two_u8, u8)\n-    test_next_power_of_two!(test_next_power_of_two_u16, u16)\n-    test_next_power_of_two!(test_next_power_of_two_u32, u32)\n-    test_next_power_of_two!(test_next_power_of_two_u64, u64)\n-    test_next_power_of_two!(test_next_power_of_two_uint, uint)\n+    test_next_power_of_two! { test_next_power_of_two_u8, u8 }\n+    test_next_power_of_two! { test_next_power_of_two_u16, u16 }\n+    test_next_power_of_two! { test_next_power_of_two_u32, u32 }\n+    test_next_power_of_two! { test_next_power_of_two_u64, u64 }\n+    test_next_power_of_two! { test_next_power_of_two_uint, uint }\n \n-    macro_rules! test_checked_next_power_of_two(\n+    macro_rules! test_checked_next_power_of_two {\n         ($test_name:ident, $T:ident) => (\n             fn $test_name() {\n                 #![test]\n@@ -699,13 +699,13 @@ mod tests {\n                 assert_eq!($T::MAX.checked_next_power_of_two(), None);\n             }\n         )\n-    )\n+    }\n \n-    test_checked_next_power_of_two!(test_checked_next_power_of_two_u8, u8)\n-    test_checked_next_power_of_two!(test_checked_next_power_of_two_u16, u16)\n-    test_checked_next_power_of_two!(test_checked_next_power_of_two_u32, u32)\n-    test_checked_next_power_of_two!(test_checked_next_power_of_two_u64, u64)\n-    test_checked_next_power_of_two!(test_checked_next_power_of_two_uint, uint)\n+    test_checked_next_power_of_two! { test_checked_next_power_of_two_u8, u8 }\n+    test_checked_next_power_of_two! { test_checked_next_power_of_two_u16, u16 }\n+    test_checked_next_power_of_two! { test_checked_next_power_of_two_u32, u32 }\n+    test_checked_next_power_of_two! { test_checked_next_power_of_two_u64, u64 }\n+    test_checked_next_power_of_two! { test_checked_next_power_of_two_uint, uint }\n \n     #[deriving(PartialEq, Show)]\n     struct Value { x: int }\n@@ -759,13 +759,13 @@ mod tests {\n             let one: T = Int::one();\n             range(0, exp).fold(one, |acc, _| acc * base)\n         }\n-        macro_rules! assert_pow(\n+        macro_rules! assert_pow {\n             (($num:expr, $exp:expr) => $expected:expr) => {{\n                 let result = $num.pow($exp);\n                 assert_eq!(result, $expected);\n                 assert_eq!(result, naive_pow($num, $exp));\n             }}\n-        )\n+        }\n         assert_pow!((3i,     0 ) => 1);\n         assert_pow!((5i,     1 ) => 5);\n         assert_pow!((-4i,    2 ) => 16);"}, {"sha": "46699b78599b71d18264ed6a627f94a0e8dc1f44", "filename": "src/libstd/num/u16.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibstd%2Fnum%2Fu16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibstd%2Fnum%2Fu16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fu16.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -17,4 +17,4 @@ pub use core::u16::{BITS, BYTES, MIN, MAX};\n \n use ops::FnOnce;\n \n-uint_module!(u16)\n+uint_module! { u16 }"}, {"sha": "45ee9251d2f4fe4f791dbf7740d8896ea3001d57", "filename": "src/libstd/num/u32.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibstd%2Fnum%2Fu32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibstd%2Fnum%2Fu32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fu32.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -17,4 +17,4 @@ pub use core::u32::{BITS, BYTES, MIN, MAX};\n \n use ops::FnOnce;\n \n-uint_module!(u32)\n+uint_module! { u32 }"}, {"sha": "1d8ff77dac8a25b16bd18d59c6cb4383dae8ab17", "filename": "src/libstd/num/u64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibstd%2Fnum%2Fu64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibstd%2Fnum%2Fu64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fu64.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -17,4 +17,4 @@ pub use core::u64::{BITS, BYTES, MIN, MAX};\n \n use ops::FnOnce;\n \n-uint_module!(u64)\n+uint_module! { u64 }"}, {"sha": "0663ace2e5ba62308d9b560afab1e286a5b5aa75", "filename": "src/libstd/num/u8.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibstd%2Fnum%2Fu8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibstd%2Fnum%2Fu8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fu8.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -17,4 +17,4 @@ pub use core::u8::{BITS, BYTES, MIN, MAX};\n \n use ops::FnOnce;\n \n-uint_module!(u8)\n+uint_module! { u8 }"}, {"sha": "7f8edee571fb8eafce0ef057c8a72320b6081759", "filename": "src/libstd/num/uint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibstd%2Fnum%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibstd%2Fnum%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fuint.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -17,4 +17,4 @@ pub use core::uint::{BITS, BYTES, MIN, MAX};\n \n use ops::FnOnce;\n \n-uint_module!(uint)\n+uint_module! { uint }"}, {"sha": "c42b7eebfdd1c59f9f0d64022c00dd0984f4e864", "filename": "src/libstd/num/uint_macros.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibstd%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibstd%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fuint_macros.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -13,7 +13,7 @@\n #![doc(hidden)]\n #![allow(unsigned_negation)]\n \n-macro_rules! uint_module (($T:ty) => (\n+macro_rules! uint_module { ($T:ty) => (\n \n // String conversion functions and impl num -> str\n \n@@ -141,4 +141,4 @@ mod tests {\n     }\n }\n \n-))\n+) }"}, {"sha": "f872aa8e9a4891927ae6d95ffee0227ef1f4aaa0", "filename": "src/libstd/path/posix.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibstd%2Fpath%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibstd%2Fpath%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fposix.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -447,7 +447,7 @@ mod tests {\n     use str;\n     use str::StrPrelude;\n \n-    macro_rules! t(\n+    macro_rules! t {\n         (s: $path:expr, $exp:expr) => (\n             {\n                 let path = $path;\n@@ -460,7 +460,7 @@ mod tests {\n                 assert!(path.as_vec() == $exp);\n             }\n         )\n-    )\n+    }\n \n     #[test]\n     fn test_paths() {\n@@ -533,14 +533,14 @@ mod tests {\n \n     #[test]\n     fn test_display_str() {\n-        macro_rules! t(\n+        macro_rules! t {\n             ($path:expr, $disp:ident, $exp:expr) => (\n                 {\n                     let path = Path::new($path);\n                     assert!(path.$disp().to_string() == $exp);\n                 }\n             )\n-        )\n+        }\n         t!(\"foo\", display, \"foo\");\n         t!(b\"foo\\x80\", display, \"foo\\u{FFFD}\");\n         t!(b\"foo\\xFFbar\", display, \"foo\\u{FFFD}bar\");\n@@ -563,7 +563,7 @@ mod tests {\n                     assert!(mo.as_slice() == $exp);\n                 }\n             )\n-        )\n+        );\n \n         t!(\"foo\", \"foo\");\n         t!(b\"foo\\x80\", \"foo\\u{FFFD}\");\n@@ -585,7 +585,7 @@ mod tests {\n                     assert!(f == $expf);\n                 }\n             )\n-        )\n+        );\n \n         t!(b\"foo\", \"foo\", \"foo\");\n         t!(b\"foo/bar\", \"foo/bar\", \"bar\");\n@@ -619,7 +619,7 @@ mod tests {\n                     assert!(path.$op() == $exp);\n                 }\n             );\n-        )\n+        );\n \n         t!(v: b\"a/b/c\", filename, Some(b\"c\"));\n         t!(v: b\"a/b/c\\xFF\", filename, Some(b\"c\\xFF\"));\n@@ -693,7 +693,7 @@ mod tests {\n                     assert!(p1 == p2.join(join));\n                 }\n             )\n-        )\n+        );\n \n         t!(s: \"a/b/c\", \"..\");\n         t!(s: \"/a/b/c\", \"d\");\n@@ -712,7 +712,7 @@ mod tests {\n                     assert!(p.as_str() == Some($exp));\n                 }\n             )\n-        )\n+        );\n \n         t!(s: \"a/b/c\", \"d\", \"a/b/c/d\");\n         t!(s: \"/a/b/c\", \"d\", \"/a/b/c/d\");\n@@ -739,7 +739,7 @@ mod tests {\n                     assert!(p.as_vec() == $exp);\n                 }\n             )\n-        )\n+        );\n \n         t!(s: \"a/b/c\", [\"d\", \"e\"], \"a/b/c/d/e\");\n         t!(s: \"a/b/c\", [\"d\", \"/e\"], \"/e\");\n@@ -769,7 +769,7 @@ mod tests {\n                     assert!(result == $right);\n                 }\n             )\n-        )\n+        );\n \n         t!(b: b\"a/b/c\", b\"a/b\", true);\n         t!(b: b\"a\", b\".\", true);\n@@ -817,7 +817,7 @@ mod tests {\n                     assert!(res.as_str() == Some($exp));\n                 }\n             )\n-        )\n+        );\n \n         t!(s: \"a/b/c\", \"..\", \"a/b\");\n         t!(s: \"/a/b/c\", \"d\", \"/a/b/c/d\");\n@@ -844,7 +844,7 @@ mod tests {\n                     assert!(res.as_vec() == $exp);\n                 }\n             )\n-        )\n+        );\n \n         t!(s: \"a/b/c\", [\"d\", \"e\"], \"a/b/c/d/e\");\n         t!(s: \"a/b/c\", [\"..\", \"d\"], \"a/b/d\");\n@@ -928,7 +928,7 @@ mod tests {\n                     assert!(p1 == p2.$with(arg));\n                 }\n             )\n-        )\n+        );\n \n         t!(v: b\"a/b/c\", set_filename, with_filename, b\"d\");\n         t!(v: b\"/\", set_filename, with_filename, b\"foo\");\n@@ -982,7 +982,7 @@ mod tests {\n                     assert!(path.extension() == $ext);\n                 }\n             )\n-        )\n+        );\n \n         t!(v: Path::new(b\"a/b/c\"), Some(b\"c\"), b\"a/b\", Some(b\"c\"), None);\n         t!(v: Path::new(b\"a/b/\\xFF\"), Some(b\"\\xFF\"), b\"a/b\", Some(b\"\\xFF\"), None);\n@@ -1029,7 +1029,7 @@ mod tests {\n                     assert_eq!(path.is_relative(), $rel);\n                 }\n             )\n-        )\n+        );\n         t!(s: \"a/b/c\", false, true);\n         t!(s: \"/a/b/c\", true, false);\n         t!(s: \"a\", false, true);\n@@ -1050,7 +1050,7 @@ mod tests {\n                     assert_eq!(path.is_ancestor_of(&dest), $exp);\n                 }\n             )\n-        )\n+        );\n \n         t!(s: \"a/b/c\", \"a/b/c/d\", true);\n         t!(s: \"a/b/c\", \"a/b/c\", true);\n@@ -1091,7 +1091,7 @@ mod tests {\n                     assert_eq!(path.ends_with_path(&child), $exp);\n                 }\n             )\n-        )\n+        );\n \n         t!(s: \"a/b/c\", \"c\", true);\n         t!(s: \"a/b/c\", \"d\", false);\n@@ -1124,7 +1124,7 @@ mod tests {\n                     assert_eq!(res.as_ref().and_then(|x| x.as_str()), $exp);\n                 }\n             )\n-        )\n+        );\n \n         t!(s: \"a/b/c\", \"a/b\", Some(\"c\"));\n         t!(s: \"a/b/c\", \"a/b/d\", Some(\"../c\"));\n@@ -1186,7 +1186,7 @@ mod tests {\n                     assert_eq!(comps, exp)\n                 }\n             )\n-        )\n+        );\n \n         t!(b: b\"a/b/c\", [b\"a\", b\"b\", b\"c\"]);\n         t!(b: b\"/\\xFF/a/\\x80\", [b\"\\xFF\", b\"a\", b\"\\x80\"]);\n@@ -1218,7 +1218,7 @@ mod tests {\n                     assert_eq!(comps, exp);\n                 }\n             )\n-        )\n+        );\n \n         t!(b: b\"a/b/c\", [Some(\"a\"), Some(\"b\"), Some(\"c\")]);\n         t!(b: b\"/\\xFF/a/\\x80\", [None, Some(\"a\"), None]);"}, {"sha": "b376f6d0d5b073107c33bebe0a5b3e934ce2c716", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -1122,7 +1122,7 @@ mod tests {\n     use super::*;\n     use super::parse_prefix;\n \n-    macro_rules! t(\n+    macro_rules! t {\n         (s: $path:expr, $exp:expr) => (\n             {\n                 let path = $path;\n@@ -1135,7 +1135,7 @@ mod tests {\n                 assert!(path.as_vec() == $exp);\n             }\n         )\n-    )\n+    }\n \n     #[test]\n     fn test_parse_prefix() {\n@@ -1149,7 +1149,7 @@ mod tests {\n                             \"parse_prefix(\\\"{}\\\"): expected {}, found {}\", path, exp, res);\n                 }\n             )\n-        )\n+        );\n \n         t!(\"\\\\\\\\SERVER\\\\share\\\\foo\", Some(UNCPrefix(6,5)));\n         t!(\"\\\\\\\\\", None);\n@@ -1348,7 +1348,7 @@ mod tests {\n                     assert_eq!(f, $expf);\n                 }\n             )\n-        )\n+        );\n \n         t!(\"foo\", \"foo\", \"foo\");\n         t!(\"foo\\\\bar\", \"foo\\\\bar\", \"bar\");\n@@ -1380,7 +1380,7 @@ mod tests {\n                     assert!(path.$op() == $exp);\n                 }\n             )\n-        )\n+        );\n \n         t!(v: b\"a\\\\b\\\\c\", filename, Some(b\"c\"));\n         t!(s: \"a\\\\b\\\\c\", filename_str, \"c\");\n@@ -1491,7 +1491,7 @@ mod tests {\n                     assert!(p1 == p2.join(join));\n                 }\n             )\n-        )\n+        );\n \n         t!(s: \"a\\\\b\\\\c\", \"..\");\n         t!(s: \"\\\\a\\\\b\\\\c\", \"d\");\n@@ -1524,7 +1524,7 @@ mod tests {\n                     assert_eq!(p.as_str(), Some($exp));\n                 }\n             )\n-        )\n+        );\n \n         t!(s: \"a\\\\b\\\\c\", \"d\", \"a\\\\b\\\\c\\\\d\");\n         t!(s: \"\\\\a\\\\b\\\\c\", \"d\", \"\\\\a\\\\b\\\\c\\\\d\");\n@@ -1582,7 +1582,7 @@ mod tests {\n                     assert_eq!(p.as_vec(), $exp);\n                 }\n             )\n-        )\n+        );\n \n         t!(s: \"a\\\\b\\\\c\", [\"d\", \"e\"], \"a\\\\b\\\\c\\\\d\\\\e\");\n         t!(s: \"a\\\\b\\\\c\", [\"d\", \"\\\\e\"], \"\\\\e\");\n@@ -1617,7 +1617,7 @@ mod tests {\n                     assert!(result == $right);\n                 }\n             )\n-        )\n+        );\n \n         t!(s: \"a\\\\b\\\\c\", \"a\\\\b\", true);\n         t!(s: \"a\", \".\", true);\n@@ -1694,7 +1694,7 @@ mod tests {\n                     assert_eq!(res.as_str(), Some($exp));\n                 }\n             )\n-        )\n+        );\n \n         t!(s: \"a\\\\b\\\\c\", \"..\", \"a\\\\b\");\n         t!(s: \"\\\\a\\\\b\\\\c\", \"d\", \"\\\\a\\\\b\\\\c\\\\d\");\n@@ -1723,7 +1723,7 @@ mod tests {\n                     assert_eq!(res.as_vec(), $exp);\n                 }\n             )\n-        )\n+        );\n \n         t!(s: \"a\\\\b\\\\c\", [\"d\", \"e\"], \"a\\\\b\\\\c\\\\d\\\\e\");\n         t!(s: \"a\\\\b\\\\c\", [\"..\", \"d\"], \"a\\\\b\\\\d\");\n@@ -1749,7 +1749,7 @@ mod tests {\n                             pstr, stringify!($op), arg, exp, res.as_str().unwrap());\n                 }\n             )\n-        )\n+        );\n \n         t!(s: \"a\\\\b\\\\c\", with_filename, \"d\", \"a\\\\b\\\\d\");\n         t!(s: \".\", with_filename, \"foo\", \"foo\");\n@@ -1842,7 +1842,7 @@ mod tests {\n                     assert!(p1 == p2.$with(arg));\n                 }\n             )\n-        )\n+        );\n \n         t!(v: b\"a\\\\b\\\\c\", set_filename, with_filename, b\"d\");\n         t!(v: b\"\\\\\", set_filename, with_filename, b\"foo\");\n@@ -1897,7 +1897,7 @@ mod tests {\n                     assert!(path.extension() == $ext);\n                 }\n             )\n-        )\n+        );\n \n         t!(v: Path::new(b\"a\\\\b\\\\c\"), Some(b\"c\"), b\"a\\\\b\", Some(b\"c\"), None);\n         t!(s: Path::new(\"a\\\\b\\\\c\"), Some(\"c\"), Some(\"a\\\\b\"), Some(\"c\"), None);\n@@ -1951,7 +1951,7 @@ mod tests {\n                             path.as_str().unwrap(), rel, b);\n                 }\n             )\n-        )\n+        );\n         t!(\"a\\\\b\\\\c\", false, false, false, true);\n         t!(\"\\\\a\\\\b\\\\c\", false, true, false, false);\n         t!(\"a\", false, false, false, true);\n@@ -1984,7 +1984,7 @@ mod tests {\n                             path.as_str().unwrap(), dest.as_str().unwrap(), exp, res);\n                 }\n             )\n-        )\n+        );\n \n         t!(s: \"a\\\\b\\\\c\", \"a\\\\b\\\\c\\\\d\", true);\n         t!(s: \"a\\\\b\\\\c\", \"a\\\\b\\\\c\", true);\n@@ -2083,7 +2083,7 @@ mod tests {\n                     assert_eq!(path.ends_with_path(&child), $exp);\n                 }\n             );\n-        )\n+        );\n \n         t!(s: \"a\\\\b\\\\c\", \"c\", true);\n         t!(s: \"a\\\\b\\\\c\", \"d\", false);\n@@ -2120,7 +2120,7 @@ mod tests {\n                             res.as_ref().and_then(|x| x.as_str()));\n                 }\n             )\n-        )\n+        );\n \n         t!(s: \"a\\\\b\\\\c\", \"a\\\\b\", Some(\"c\"));\n         t!(s: \"a\\\\b\\\\c\", \"a\\\\b\\\\d\", Some(\"..\\\\c\"));\n@@ -2255,7 +2255,7 @@ mod tests {\n                     assert_eq!(comps, exp);\n                 }\n             );\n-        )\n+        );\n \n         t!(s: b\"a\\\\b\\\\c\", [\"a\", \"b\", \"c\"]);\n         t!(s: \"a\\\\b\\\\c\", [\"a\", \"b\", \"c\"]);\n@@ -2311,7 +2311,7 @@ mod tests {\n                     assert_eq!(comps, exp);\n                 }\n             )\n-        )\n+        );\n \n         t!(s: \"a\\\\b\\\\c\", [b\"a\", b\"b\", b\"c\"]);\n         t!(s: \".\", [b\".\"]);\n@@ -2329,7 +2329,7 @@ mod tests {\n                     assert!(make_non_verbatim(&path) == exp);\n                 }\n             )\n-        )\n+        );\n \n         t!(r\"\\a\\b\\c\", Some(r\"\\a\\b\\c\"));\n         t!(r\"a\\b\\c\", Some(r\"a\\b\\c\"));"}, {"sha": "d8e1fc2565469c72968068b24f814dbac51ef072", "filename": "src/libstd/rand/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibstd%2Frand%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibstd%2Frand%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fmod.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -350,7 +350,7 @@ pub fn task_rng() -> TaskRng {\n                                                TASK_RNG_RESEED_THRESHOLD,\n                                                TaskRngReseeder);\n         Rc::new(RefCell::new(rng))\n-    })\n+    });\n \n     TaskRng { rng: TASK_RNG_KEY.with(|t| t.clone()) }\n }"}, {"sha": "c2fc7653b093d923ada5b76ec785fb3cee261efd", "filename": "src/libstd/rt/backtrace.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibstd%2Frt%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibstd%2Frt%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fbacktrace.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -109,7 +109,7 @@ fn demangle(writer: &mut Writer, s: &str) -> IoResult<()> {\n             rest = rest.slice_to(i);\n             while rest.len() > 0 {\n                 if rest.starts_with(\"$\") {\n-                    macro_rules! demangle(\n+                    macro_rules! demangle {\n                         ($($pat:expr => $demangled:expr),*) => ({\n                             $(if rest.starts_with($pat) {\n                                 try!(writer.write_str($demangled));\n@@ -121,7 +121,8 @@ fn demangle(writer: &mut Writer, s: &str) -> IoResult<()> {\n                             }\n \n                         })\n-                    )\n+                    }\n+\n                     // see src/librustc/back/link.rs for these mappings\n                     demangle! (\n                         \"$SP$\" => \"@\",\n@@ -933,12 +934,12 @@ mod imp {\n             Err(..) => return Ok(()),\n         };\n \n-        macro_rules! sym( ($e:expr, $t:ident) => (unsafe {\n+        macro_rules! sym { ($e:expr, $t:ident) => (unsafe {\n             match lib.symbol($e) {\n                 Ok(f) => mem::transmute::<*mut u8, $t>(f),\n                 Err(..) => return Ok(())\n             }\n-        }) )\n+        }) }\n \n         // Fetch the symbols necessary from dbghelp.dll\n         let SymFromAddr = sym!(\"SymFromAddr\", SymFromAddrFn);\n@@ -1003,11 +1004,13 @@ mod imp {\n #[cfg(test)]\n mod test {\n     use prelude::*;\n-    macro_rules! t( ($a:expr, $b:expr) => ({\n+    use io::MemWriter;\n+\n+    macro_rules! t { ($a:expr, $b:expr) => ({\n         let mut m = Vec::new();\n         super::demangle(&mut m, $a).unwrap();\n         assert_eq!(String::from_utf8(m).unwrap(), $b);\n-    }) )\n+    }) }\n \n     #[test]\n     fn demangle() {"}, {"sha": "acbf209632630e0edfffbec26af31d1497c1abb2", "filename": "src/libstd/sys/unix/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fmod.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -23,7 +23,7 @@ use prelude::*;\n use io::{mod, IoResult, IoError};\n use sys_common::mkerr_libc;\n \n-macro_rules! helper_init( (static $name:ident: Helper<$m:ty>) => (\n+macro_rules! helper_init { (static $name:ident: Helper<$m:ty>) => (\n     static $name: Helper<$m> = Helper {\n         lock: ::sync::MUTEX_INIT,\n         cond: ::sync::CONDVAR_INIT,\n@@ -32,7 +32,7 @@ macro_rules! helper_init( (static $name:ident: Helper<$m:ty>) => (\n         initialized: ::cell::UnsafeCell { value: false },\n         shutdown: ::cell::UnsafeCell { value: false },\n     };\n-) )\n+) }\n \n pub mod c;\n pub mod ext;"}, {"sha": "835f4279d9bc69d3055eaf7431edc130e7c08f20", "filename": "src/libstd/sys/unix/process.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -28,7 +28,7 @@ use sys_common::{AsInner, mkerr_libc, timeout};\n \n pub use sys_common::ProcessConfig;\n \n-helper_init!(static HELPER: Helper<Req>)\n+helper_init! { static HELPER: Helper<Req> }\n \n /// The unique id of the process (this should never be negative).\n pub struct Process {"}, {"sha": "79a6a871f8dd41796779be5f66115b55c7fc8032", "filename": "src/libstd/sys/unix/timer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibstd%2Fsys%2Funix%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibstd%2Fsys%2Funix%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ftimer.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -60,7 +60,7 @@ use sys_common::helper_thread::Helper;\n use prelude::*;\n use io::IoResult;\n \n-helper_init!(static HELPER: Helper<Req>)\n+helper_init! { static HELPER: Helper<Req> }\n \n pub trait Callback {\n     fn call(&mut self);"}, {"sha": "d1cb91bcdb377918d881db4076610a4ab03584b2", "filename": "src/libstd/sys/windows/c.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -169,7 +169,7 @@ pub mod compat {\n     ///\n     /// Note that arguments unused by the fallback implementation should not be called `_` as\n     /// they are used to be passed to the real function if available.\n-    macro_rules! compat_fn(\n+    macro_rules! compat_fn {\n         ($module:ident::$symbol:ident($($argname:ident: $argtype:ty),*)\n                                       -> $rettype:ty $fallback:block) => (\n             #[inline(always)]\n@@ -195,7 +195,7 @@ pub mod compat {\n         ($module:ident::$symbol:ident($($argname:ident: $argtype:ty),*) $fallback:block) => (\n             compat_fn!($module::$symbol($($argname: $argtype),*) -> () $fallback)\n         )\n-    )\n+    }\n \n     /// Compatibility layer for functions in `kernel32.dll`\n     ///\n@@ -211,20 +211,20 @@ pub mod compat {\n             fn SetLastError(dwErrCode: DWORD);\n         }\n \n-        compat_fn!(kernel32::CreateSymbolicLinkW(_lpSymlinkFileName: LPCWSTR,\n+        compat_fn! { kernel32::CreateSymbolicLinkW(_lpSymlinkFileName: LPCWSTR,\n                                                  _lpTargetFileName: LPCWSTR,\n                                                  _dwFlags: DWORD) -> BOOLEAN {\n             unsafe { SetLastError(ERROR_CALL_NOT_IMPLEMENTED as DWORD); }\n             0\n-        })\n+        } }\n \n-        compat_fn!(kernel32::GetFinalPathNameByHandleW(_hFile: HANDLE,\n+        compat_fn! { kernel32::GetFinalPathNameByHandleW(_hFile: HANDLE,\n                                                        _lpszFilePath: LPCWSTR,\n                                                        _cchFilePath: DWORD,\n                                                        _dwFlags: DWORD) -> DWORD {\n             unsafe { SetLastError(ERROR_CALL_NOT_IMPLEMENTED as DWORD); }\n             0\n-        })\n+        } }\n     }\n }\n "}, {"sha": "d22d4e0f534db1e6d53ee6c5dd3aa40961fb9ebc", "filename": "src/libstd/sys/windows/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -24,7 +24,7 @@ use prelude::*;\n use io::{mod, IoResult, IoError};\n use sync::{Once, ONCE_INIT};\n \n-macro_rules! helper_init( (static $name:ident: Helper<$m:ty>) => (\n+macro_rules! helper_init { (static $name:ident: Helper<$m:ty>) => (\n     static $name: Helper<$m> = Helper {\n         lock: ::sync::MUTEX_INIT,\n         cond: ::sync::CONDVAR_INIT,\n@@ -33,7 +33,7 @@ macro_rules! helper_init( (static $name:ident: Helper<$m:ty>) => (\n         initialized: ::cell::UnsafeCell { value: false },\n         shutdown: ::cell::UnsafeCell { value: false },\n     };\n-) )\n+) }\n \n pub mod c;\n pub mod ext;"}, {"sha": "e2f9e2a9201c3c260e7f55b4d3a19e2d5cff3098", "filename": "src/libstd/sys/windows/timer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibstd%2Fsys%2Fwindows%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibstd%2Fsys%2Fwindows%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ftimer.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -32,7 +32,7 @@ use sys_common::helper_thread::Helper;\n use prelude::*;\n use io::IoResult;\n \n-helper_init!(static HELPER: Helper<Req>)\n+helper_init! { static HELPER: Helper<Req> }\n \n pub trait Callback {\n     fn call(&mut self);"}, {"sha": "1268ab8e0cfa6d1a4703b12c5b7c41c50076ed3d", "filename": "src/libstd/thread_local/mod.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibstd%2Fthread_local%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibstd%2Fthread_local%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread_local%2Fmod.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -109,7 +109,7 @@ pub struct Key<T> {\n /// Declare a new thread local storage key of type `std::thread_local::Key`.\n #[macro_export]\n #[doc(hidden)]\n-macro_rules! thread_local(\n+macro_rules! thread_local {\n     (static $name:ident: $t:ty = $init:expr) => (\n         static $name: ::std::thread_local::Key<$t> = {\n             use std::cell::UnsafeCell as __UnsafeCell;\n@@ -119,7 +119,7 @@ macro_rules! thread_local(\n \n             __thread_local_inner!(static __KEY: __UnsafeCell<__Option<$t>> = {\n                 __UnsafeCell { value: __None }\n-            })\n+            });\n             fn __init() -> $t { $init }\n             fn __getit() -> &'static __KeyInner<__UnsafeCell<__Option<$t>>> {\n                 &__KEY\n@@ -136,15 +136,15 @@ macro_rules! thread_local(\n \n             __thread_local_inner!(static __KEY: __UnsafeCell<__Option<$t>> = {\n                 __UnsafeCell { value: __None }\n-            })\n+            });\n             fn __init() -> $t { $init }\n             fn __getit() -> &'static __KeyInner<__UnsafeCell<__Option<$t>>> {\n                 &__KEY\n             }\n             ::std::thread_local::Key { inner: __getit, init: __init }\n         };\n     );\n-)\n+}\n \n // Macro pain #4586:\n //\n@@ -167,7 +167,7 @@ macro_rules! thread_local(\n // itself. Woohoo.\n \n #[macro_export]\n-macro_rules! __thread_local_inner(\n+macro_rules! __thread_local_inner {\n     (static $name:ident: $t:ty = $init:expr) => (\n         #[cfg_attr(any(target_os = \"macos\", target_os = \"linux\"), thread_local)]\n         static $name: ::std::thread_local::KeyInner<$t> =\n@@ -204,7 +204,7 @@ macro_rules! __thread_local_inner(\n \n         INIT\n     });\n-)\n+}\n \n impl<T: 'static> Key<T> {\n     /// Acquire a reference to the value in this TLS key.\n@@ -459,7 +459,7 @@ mod tests {\n \n     #[test]\n     fn smoke_no_dtor() {\n-        thread_local!(static FOO: UnsafeCell<int> = UnsafeCell { value: 1 })\n+        thread_local!(static FOO: UnsafeCell<int> = UnsafeCell { value: 1 });\n \n         FOO.with(|f| unsafe {\n             assert_eq!(*f.get(), 1);\n@@ -483,7 +483,7 @@ mod tests {\n     fn smoke_dtor() {\n         thread_local!(static FOO: UnsafeCell<Option<Foo>> = UnsafeCell {\n             value: None\n-        })\n+        });\n \n         let (tx, rx) = channel();\n         spawn(move|| unsafe {\n@@ -501,10 +501,10 @@ mod tests {\n         struct S2;\n         thread_local!(static K1: UnsafeCell<Option<S1>> = UnsafeCell {\n             value: None\n-        })\n+        });\n         thread_local!(static K2: UnsafeCell<Option<S2>> = UnsafeCell {\n             value: None\n-        })\n+        });\n         static mut HITS: uint = 0;\n \n         impl Drop for S1 {\n@@ -544,7 +544,7 @@ mod tests {\n         struct S1;\n         thread_local!(static K1: UnsafeCell<Option<S1>> = UnsafeCell {\n             value: None\n-        })\n+        });\n \n         impl Drop for S1 {\n             fn drop(&mut self) {\n@@ -562,10 +562,10 @@ mod tests {\n         struct S1(Sender<()>);\n         thread_local!(static K1: UnsafeCell<Option<S1>> = UnsafeCell {\n             value: None\n-        })\n+        });\n         thread_local!(static K2: UnsafeCell<Option<Foo>> = UnsafeCell {\n             value: None\n-        })\n+        });\n \n         impl Drop for S1 {\n             fn drop(&mut self) {\n@@ -597,7 +597,7 @@ mod dynamic_tests {\n     #[test]\n     fn smoke() {\n         fn square(i: int) -> int { i * i }\n-        thread_local!(static FOO: int = square(3))\n+        thread_local!(static FOO: int = square(3));\n \n         FOO.with(|f| {\n             assert_eq!(*f, 9);\n@@ -611,7 +611,7 @@ mod dynamic_tests {\n             m.insert(1, 2);\n             RefCell::new(m)\n         }\n-        thread_local!(static FOO: RefCell<HashMap<int, int>> = map())\n+        thread_local!(static FOO: RefCell<HashMap<int, int>> = map());\n \n         FOO.with(|map| {\n             assert_eq!(map.borrow()[1], 2);\n@@ -620,7 +620,7 @@ mod dynamic_tests {\n \n     #[test]\n     fn refcell_vec() {\n-        thread_local!(static FOO: RefCell<Vec<uint>> = RefCell::new(vec![1, 2, 3]))\n+        thread_local!(static FOO: RefCell<Vec<uint>> = RefCell::new(vec![1, 2, 3]));\n \n         FOO.with(|vec| {\n             assert_eq!(vec.borrow().len(), 3);"}, {"sha": "7762d225b9a046cb3ad2e9f3075eda11082963f2", "filename": "src/libstd/thread_local/scoped.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibstd%2Fthread_local%2Fscoped.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibstd%2Fthread_local%2Fscoped.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread_local%2Fscoped.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -24,7 +24,7 @@\n //! # Example\n //!\n //! ```\n-//! scoped_thread_local!(static FOO: uint)\n+//! scoped_thread_local!(static FOO: uint);\n //!\n //! // Initially each scoped slot is empty.\n //! assert!(!FOO.is_set());\n@@ -60,18 +60,18 @@ pub struct Key<T> { #[doc(hidden)] pub inner: KeyInner<T> }\n /// This macro declares a `static` item on which methods are used to get and\n /// set the value stored within.\n #[macro_export]\n-macro_rules! scoped_thread_local(\n+macro_rules! scoped_thread_local {\n     (static $name:ident: $t:ty) => (\n         __scoped_thread_local_inner!(static $name: $t)\n     );\n     (pub static $name:ident: $t:ty) => (\n         __scoped_thread_local_inner!(pub static $name: $t)\n     );\n-)\n+}\n \n #[macro_export]\n #[doc(hidden)]\n-macro_rules! __scoped_thread_local_inner(\n+macro_rules! __scoped_thread_local_inner {\n     (static $name:ident: $t:ty) => (\n         #[cfg_attr(not(any(windows, target_os = \"android\", target_os = \"ios\")),\n                    thread_local)]\n@@ -104,7 +104,7 @@ macro_rules! __scoped_thread_local_inner(\n \n         INIT\n     })\n-)\n+}\n \n impl<T> Key<T> {\n     /// Insert a value into this scoped thread local storage slot for a\n@@ -119,7 +119,7 @@ impl<T> Key<T> {\n     /// # Example\n     ///\n     /// ```\n-    /// scoped_thread_local!(static FOO: uint)\n+    /// scoped_thread_local!(static FOO: uint);\n     ///\n     /// FOO.set(&100, || {\n     ///     let val = FOO.with(|v| *v);\n@@ -171,7 +171,7 @@ impl<T> Key<T> {\n     /// # Example\n     ///\n     /// ```no_run\n-    /// scoped_thread_local!(static FOO: uint)\n+    /// scoped_thread_local!(static FOO: uint);\n     ///\n     /// FOO.with(|slot| {\n     ///     // work with `slot`\n@@ -239,7 +239,7 @@ mod tests {\n \n     #[test]\n     fn smoke() {\n-        scoped_thread_local!(static BAR: uint)\n+        scoped_thread_local!(static BAR: uint);\n \n         assert!(!BAR.is_set());\n         BAR.set(&1, || {\n@@ -253,7 +253,7 @@ mod tests {\n \n     #[test]\n     fn cell_allowed() {\n-        scoped_thread_local!(static BAR: Cell<uint>)\n+        scoped_thread_local!(static BAR: Cell<uint>);\n \n         BAR.set(&Cell::new(1), || {\n             BAR.with(|slot| {"}, {"sha": "8c4a5a6b8c7fdbbf742a9eef21dfda9e5a80a608", "filename": "src/libstd/time/duration.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibstd%2Ftime%2Fduration.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibstd%2Ftime%2Fduration.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime%2Fduration.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -40,9 +40,9 @@ const SECS_PER_DAY: i64 = 86400;\n /// The number of (non-leap) seconds in a week.\n const SECS_PER_WEEK: i64 = 604800;\n \n-macro_rules! try_opt(\n+macro_rules! try_opt {\n     ($e:expr) => (match $e { Some(v) => v, None => return None })\n-)\n+}\n \n \n /// ISO 8601 time duration with nanosecond precision."}, {"sha": "d4860766d47442435774c726111c5d2e51bbb9f0", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -31,6 +31,7 @@ pub use self::Lit_::*;\n pub use self::LitIntType::*;\n pub use self::LocalSource::*;\n pub use self::Mac_::*;\n+pub use self::MacStmtStyle::*;\n pub use self::MatchSource::*;\n pub use self::MetaItem_::*;\n pub use self::Method_::*;\n@@ -615,8 +616,20 @@ pub enum Stmt_ {\n     /// Expr with trailing semi-colon (may have any type):\n     StmtSemi(P<Expr>, NodeId),\n \n-    /// bool: is there a trailing semi-colon?\n-    StmtMac(Mac, bool),\n+    StmtMac(Mac, MacStmtStyle),\n+}\n+\n+#[deriving(Clone, Copy, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n+pub enum MacStmtStyle {\n+    /// The macro statement had a trailing semicolon, e.g. `foo! { ... };`\n+    /// `foo!(...);`, `foo![...];`\n+    MacStmtWithSemicolon,\n+    /// The macro statement had braces; e.g. foo! { ... }\n+    MacStmtWithBraces,\n+    /// The macro statement had parentheses or brackets and no semicolon; e.g.\n+    /// `foo!(...)`. All of these will end up being converted into macro\n+    /// expressions.\n+    MacStmtWithoutBraces,\n }\n \n /// Where a local declaration came from: either a true `let ... ="}, {"sha": "aaa172633be2123c860bf6beb2f8ab9fd01589e9", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -753,16 +753,20 @@ macro_rules! mf_method{\n \n \n impl PostExpansionMethod for Method {\n-    mf_method!(pe_ident,ast::Ident,MethDecl(ident,_,_,_,_,_,_,_),ident)\n-    mf_method!(pe_generics,&'a ast::Generics,\n-               MethDecl(_,ref generics,_,_,_,_,_,_),generics)\n-    mf_method!(pe_abi,Abi,MethDecl(_,_,abi,_,_,_,_,_),abi)\n-    mf_method!(pe_explicit_self,&'a ast::ExplicitSelf,\n-               MethDecl(_,_,_,ref explicit_self,_,_,_,_),explicit_self)\n-    mf_method!(pe_unsafety,ast::Unsafety,MethDecl(_,_,_,_,unsafety,_,_,_),unsafety)\n-    mf_method!(pe_fn_decl,&'a ast::FnDecl,MethDecl(_,_,_,_,_,ref decl,_,_),&**decl)\n-    mf_method!(pe_body,&'a ast::Block,MethDecl(_,_,_,_,_,_,ref body,_),&**body)\n-    mf_method!(pe_vis,ast::Visibility,MethDecl(_,_,_,_,_,_,_,vis),vis)\n+    mf_method! { pe_ident,ast::Ident,MethDecl(ident,_,_,_,_,_,_,_),ident }\n+    mf_method! {\n+        pe_generics,&'a ast::Generics,\n+        MethDecl(_,ref generics,_,_,_,_,_,_),generics\n+    }\n+    mf_method! { pe_abi,Abi,MethDecl(_,_,abi,_,_,_,_,_),abi }\n+    mf_method! {\n+        pe_explicit_self,&'a ast::ExplicitSelf,\n+        MethDecl(_,_,_,ref explicit_self,_,_,_,_),explicit_self\n+    }\n+    mf_method! { pe_unsafety,ast::Unsafety,MethDecl(_,_,_,_,unsafety,_,_,_),unsafety }\n+    mf_method! { pe_fn_decl,&'a ast::FnDecl,MethDecl(_,_,_,_,_,ref decl,_,_),&**decl }\n+    mf_method! { pe_body,&'a ast::Block,MethDecl(_,_,_,_,_,_,ref body,_),&**body }\n+    mf_method! { pe_vis,ast::Visibility,MethDecl(_,_,_,_,_,_,_,vis),vis }\n }\n \n #[cfg(test)]"}, {"sha": "598da6a5df0cbf76ce6606c19626d4fba0783981", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -29,7 +29,7 @@ use std::cell::{RefCell, Cell};\n use std::collections::BitvSet;\n use std::collections::HashSet;\n \n-thread_local!(static USED_ATTRS: RefCell<BitvSet> = RefCell::new(BitvSet::new()))\n+thread_local! { static USED_ATTRS: RefCell<BitvSet> = RefCell::new(BitvSet::new()) }\n \n pub fn mark_used(attr: &Attribute) {\n     let AttrId(id) = attr.node.id;\n@@ -169,7 +169,7 @@ pub fn mk_word_item(name: InternedString) -> P<MetaItem> {\n     P(dummy_spanned(MetaWord(name)))\n }\n \n-thread_local!(static NEXT_ATTR_ID: Cell<uint> = Cell::new(0))\n+thread_local! { static NEXT_ATTR_ID: Cell<uint> = Cell::new(0) }\n \n pub fn mk_attr_id() -> AttrId {\n     let id = NEXT_ATTR_ID.with(|slot| {"}, {"sha": "17cafc2441f9dbd3556db6766a9cf6b28760d19b", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -329,7 +329,7 @@ impl FileMap {\n         // the new charpos must be > the last one (or it's the first one).\n         let mut lines = self.lines.borrow_mut();\n         let line_len = lines.len();\n-        assert!(line_len == 0 || ((*lines)[line_len - 1] < pos))\n+        assert!(line_len == 0 || ((*lines)[line_len - 1] < pos));\n         lines.push(pos);\n     }\n "}, {"sha": "3107508a96a5cda2ed6bc0aa400b195579f71344", "filename": "src/libsyntax/diagnostics/macros.rs", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibsyntax%2Fdiagnostics%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibsyntax%2Fdiagnostics%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostics%2Fmacros.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -11,44 +11,45 @@\n #![macro_escape]\n \n #[macro_export]\n-macro_rules! register_diagnostic(\n-    ($code:tt, $description:tt) => (__register_diagnostic!($code, $description));\n-    ($code:tt) => (__register_diagnostic!($code))\n-)\n+macro_rules! register_diagnostic {\n+    ($code:tt, $description:tt) => (__register_diagnostic! { $code, $description });\n+    ($code:tt) => (__register_diagnostic! { $code })\n+}\n \n #[macro_export]\n-macro_rules! span_err(\n+macro_rules! span_err {\n     ($session:expr, $span:expr, $code:ident, $($message:tt)*) => ({\n         __diagnostic_used!($code);\n         $session.span_err_with_code($span, format!($($message)*).as_slice(), stringify!($code))\n     })\n-)\n+}\n \n #[macro_export]\n-macro_rules! span_warn(\n+macro_rules! span_warn {\n     ($session:expr, $span:expr, $code:ident, $($message:tt)*) => ({\n         __diagnostic_used!($code);\n         $session.span_warn_with_code($span, format!($($message)*).as_slice(), stringify!($code))\n     })\n-)\n+}\n \n #[macro_export]\n-macro_rules! span_note(\n+macro_rules! span_note {\n     ($session:expr, $span:expr, $($message:tt)*) => ({\n         ($session).span_note($span, format!($($message)*).as_slice())\n     })\n-)\n+}\n \n #[macro_export]\n-macro_rules! span_help(\n+macro_rules! span_help {\n     ($session:expr, $span:expr, $($message:tt)*) => ({\n         ($session).span_help($span, format!($($message)*).as_slice())\n     })\n-)\n+}\n \n #[macro_export]\n-macro_rules! register_diagnostics(\n+macro_rules! register_diagnostics {\n     ($($code:tt),*) => (\n-        $(register_diagnostic!($code))*\n+        $(register_diagnostic! { $code })*\n     )\n-)\n+}\n+"}, {"sha": "bcce5538314b7ac019a05b9d3d8e5bcaf01b2f2c", "filename": "src/libsyntax/diagnostics/plugin.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -18,12 +18,16 @@ use ext::build::AstBuilder;\n use parse::token;\n use ptr::P;\n \n-thread_local!(static REGISTERED_DIAGNOSTICS: RefCell<HashMap<Name, Option<Name>>> = {\n-    RefCell::new(HashMap::new())\n-})\n-thread_local!(static USED_DIAGNOSTICS: RefCell<HashMap<Name, Span>> = {\n-    RefCell::new(HashMap::new())\n-})\n+thread_local! {\n+    static REGISTERED_DIAGNOSTICS: RefCell<HashMap<Name, Option<Name>>> = {\n+        RefCell::new(HashMap::new())\n+    }\n+}\n+thread_local! {\n+    static USED_DIAGNOSTICS: RefCell<HashMap<Name, Span>> = {\n+        RefCell::new(HashMap::new())\n+    }\n+}\n \n fn with_registered_diagnostics<T, F>(f: F) -> T where\n     F: FnOnce(&mut HashMap<Name, Option<Name>>) -> T,"}, {"sha": "20c8ff20b713b88bd3b62a690d8a27e242aa251e", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 32, "deletions": 31, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -11,7 +11,8 @@ use self::Either::*;\n \n use ast::{Block, Crate, DeclLocal, ExprMac, PatMac};\n use ast::{Local, Ident, MacInvocTT};\n-use ast::{ItemMac, Mrk, Stmt, StmtDecl, StmtMac, StmtExpr, StmtSemi};\n+use ast::{ItemMac, MacStmtWithSemicolon, Mrk, Stmt, StmtDecl, StmtMac};\n+use ast::{StmtExpr, StmtSemi};\n use ast::TokenTree;\n use ast;\n use ext::mtwt;\n@@ -354,15 +355,15 @@ fn expand_loop_block(loop_block: P<Block>,\n \n // eval $e with a new exts frame.\n // must be a macro so that $e isn't evaluated too early.\n-macro_rules! with_exts_frame (\n+macro_rules! with_exts_frame {\n     ($extsboxexpr:expr,$macros_escape:expr,$e:expr) =>\n     ({$extsboxexpr.push_frame();\n       $extsboxexpr.info().macros_escape = $macros_escape;\n       let result = $e;\n       $extsboxexpr.pop_frame();\n       result\n      })\n-)\n+}\n \n // When we enter a module, record it, for the sake of `module!`\n pub fn expand_item(it: P<ast::Item>, fld: &mut MacroExpander)\n@@ -636,8 +637,8 @@ pub fn expand_item_mac(it: P<ast::Item>, fld: &mut MacroExpander)\n // I don't understand why this returns a vector... it looks like we're\n // half done adding machinery to allow macros to expand into multiple statements.\n fn expand_stmt(s: Stmt, fld: &mut MacroExpander) -> SmallVector<P<Stmt>> {\n-    let (mac, semi) = match s.node {\n-        StmtMac(mac, semi) => (mac, semi),\n+    let (mac, style) = match s.node {\n+        StmtMac(mac, style) => (mac, style),\n         _ => return expand_non_macro_stmt(s, fld)\n     };\n     let expanded_stmt = match expand_mac_invoc(mac, s.span,\n@@ -653,7 +654,7 @@ fn expand_stmt(s: Stmt, fld: &mut MacroExpander) -> SmallVector<P<Stmt>> {\n     let fully_expanded = fld.fold_stmt(expanded_stmt);\n     fld.cx.bt_pop();\n \n-    if semi {\n+    if style == MacStmtWithSemicolon {\n         fully_expanded.into_iter().map(|s| s.map(|Spanned {node, span}| {\n             Spanned {\n                 node: match node {\n@@ -1324,7 +1325,7 @@ mod test {\n     // make sure that macros can't escape fns\n     #[should_fail]\n     #[test] fn macros_cant_escape_fns_test () {\n-        let src = \"fn bogus() {macro_rules! z (() => (3+4))}\\\n+        let src = \"fn bogus() {macro_rules! z (() => (3+4));}\\\n                    fn inty() -> int { z!() }\".to_string();\n         let sess = parse::new_parse_sess();\n         let crate_ast = parse::parse_crate_from_source_str(\n@@ -1338,7 +1339,7 @@ mod test {\n     // make sure that macros can't escape modules\n     #[should_fail]\n     #[test] fn macros_cant_escape_mods_test () {\n-        let src = \"mod foo {macro_rules! z (() => (3+4))}\\\n+        let src = \"mod foo {macro_rules! z (() => (3+4));}\\\n                    fn inty() -> int { z!() }\".to_string();\n         let sess = parse::new_parse_sess();\n         let crate_ast = parse::parse_crate_from_source_str(\n@@ -1350,7 +1351,7 @@ mod test {\n \n     // macro_escape modules should allow macros to escape\n     #[test] fn macros_can_escape_flattened_mods_test () {\n-        let src = \"#[macro_escape] mod foo {macro_rules! z (() => (3+4))}\\\n+        let src = \"#[macro_escape] mod foo {macro_rules! z (() => (3+4));}\\\n                    fn inty() -> int { z!() }\".to_string();\n         let sess = parse::new_parse_sess();\n         let crate_ast = parse::parse_crate_from_source_str(\n@@ -1402,13 +1403,13 @@ mod test {\n \n     #[test] fn macro_tokens_should_match(){\n         expand_crate_str(\n-            \"macro_rules! m((a)=>(13)) fn main(){m!(a);}\".to_string());\n+            \"macro_rules! m((a)=>(13)) ;fn main(){m!(a);}\".to_string());\n     }\n \n     // should be able to use a bound identifier as a literal in a macro definition:\n     #[test] fn self_macro_parsing(){\n         expand_crate_str(\n-            \"macro_rules! foo ((zz) => (287u;))\n+            \"macro_rules! foo ((zz) => (287u;));\n             fn f(zz : int) {foo!(zz);}\".to_string()\n             );\n     }\n@@ -1451,16 +1452,16 @@ mod test {\n                 (\"fn main () {let x: int = 13;x;}\",\n                  vec!(vec!(0)), false),\n                 // the use of b after the + should be renamed, the other one not:\n-                (\"macro_rules! f (($x:ident) => (b + $x)) fn a() -> int { let b = 13; f!(b)}\",\n+                (\"macro_rules! f (($x:ident) => (b + $x)); fn a() -> int { let b = 13; f!(b)}\",\n                  vec!(vec!(1)), false),\n                 // the b before the plus should not be renamed (requires marks)\n-                (\"macro_rules! f (($x:ident) => ({let b=9; ($x + b)})) fn a() -> int { f!(b)}\",\n+                (\"macro_rules! f (($x:ident) => ({let b=9; ($x + b)})); fn a() -> int { f!(b)}\",\n                  vec!(vec!(1)), false),\n                 // the marks going in and out of letty should cancel, allowing that $x to\n                 // capture the one following the semicolon.\n                 // this was an awesome test case, and caught a *lot* of bugs.\n-                (\"macro_rules! letty(($x:ident) => (let $x = 15;))\n-                  macro_rules! user(($x:ident) => ({letty!($x); $x}))\n+                (\"macro_rules! letty(($x:ident) => (let $x = 15;));\n+                  macro_rules! user(($x:ident) => ({letty!($x); $x}));\n                   fn main() -> int {user!(z)}\",\n                  vec!(vec!(0)), false)\n                 );\n@@ -1488,7 +1489,7 @@ mod test {\n     #[test] fn issue_6994(){\n         run_renaming_test(\n             &(\"macro_rules! g (($x:ident) =>\n-              ({macro_rules! f(($y:ident)=>({let $y=3;$x}));f!($x)}))\n+              ({macro_rules! f(($y:ident)=>({let $y=3;$x}));f!($x)}));\n               fn a(){g!(z)}\",\n               vec!(vec!(0)),false),\n             0)\n@@ -1498,7 +1499,7 @@ mod test {\n     // fn z() {match 8 {x_1 => {match 9 {x_2 | x_2 if x_2 == x_1 => x_2 + x_1}}}}\n     #[test] fn issue_9384(){\n         run_renaming_test(\n-            &(\"macro_rules! bad_macro (($ex:expr) => ({match 9 {x | x if x == $ex => x + $ex}}))\n+            &(\"macro_rules! bad_macro (($ex:expr) => ({match 9 {x | x if x == $ex => x + $ex}}));\n               fn z() {match 8 {x => bad_macro!(x)}}\",\n               // NB: the third \"binding\" is the repeat of the second one.\n               vec!(vec!(1,3),vec!(0,2),vec!(0,2)),\n@@ -1511,8 +1512,8 @@ mod test {\n     // fn main(){let g1_1 = 13; g1_1}}\n     #[test] fn pat_expand_issue_15221(){\n         run_renaming_test(\n-            &(\"macro_rules! inner ( ($e:pat ) => ($e))\n-              macro_rules! outer ( ($e:pat ) => (inner!($e)))\n+            &(\"macro_rules! inner ( ($e:pat ) => ($e));\n+              macro_rules! outer ( ($e:pat ) => (inner!($e)));\n               fn main() { let outer!(g) = 13; g;}\",\n               vec!(vec!(0)),\n               true),\n@@ -1527,8 +1528,8 @@ mod test {\n     // method expands to fn get_x(&self_0, x_1:int) {self_0 + self_2 + x_3 + x_1}\n     #[test] fn method_arg_hygiene(){\n         run_renaming_test(\n-            &(\"macro_rules! inject_x (()=>(x))\n-              macro_rules! inject_self (()=>(self))\n+            &(\"macro_rules! inject_x (()=>(x));\n+              macro_rules! inject_self (()=>(self));\n               struct A;\n               impl A{fn get_x(&self, x: int) {self + inject_self!() + inject_x!() + x;} }\",\n               vec!(vec!(0),vec!(3)),\n@@ -1542,8 +1543,8 @@ mod test {\n         run_renaming_test(\n             &(\"struct A;\n               macro_rules! add_method (($T:ty) =>\n-              (impl $T {  fn thingy(&self) {self;} }))\n-              add_method!(A)\",\n+              (impl $T {  fn thingy(&self) {self;} }));\n+              add_method!(A);\",\n               vec!(vec!(0)),\n               true),\n             0)\n@@ -1553,7 +1554,7 @@ mod test {\n     // expands to fn q(x_1:int){fn g(x_2:int){x_2 + x_1};}\n     #[test] fn issue_9383(){\n         run_renaming_test(\n-            &(\"macro_rules! bad_macro (($ex:expr) => (fn g(x:int){ x + $ex }))\n+            &(\"macro_rules! bad_macro (($ex:expr) => (fn g(x:int){ x + $ex }));\n               fn q(x:int) { bad_macro!(x); }\",\n               vec!(vec!(1),vec!(0)),true),\n             0)\n@@ -1563,7 +1564,7 @@ mod test {\n     // expands to fn f(){(|x_1 : int| {(x_2 + x_1)})(3);}\n     #[test] fn closure_arg_hygiene(){\n         run_renaming_test(\n-            &(\"macro_rules! inject_x (()=>(x))\n+            &(\"macro_rules! inject_x (()=>(x));\n             fn f(){(|x : int| {(inject_x!() + x)})(3);}\",\n               vec!(vec!(1)),\n               true),\n@@ -1573,9 +1574,9 @@ mod test {\n     // macro_rules in method position. Sadly, unimplemented.\n     #[test] fn macro_in_method_posn(){\n         expand_crate_str(\n-            \"macro_rules! my_method (() => (fn thirteen(&self) -> int {13}))\n+            \"macro_rules! my_method (() => (fn thirteen(&self) -> int {13}));\n             struct A;\n-            impl A{ my_method!()}\n+            impl A{ my_method!(); }\n             fn f(){A.thirteen;}\".to_string());\n     }\n \n@@ -1586,7 +1587,7 @@ mod test {\n             &(\"macro_rules! item { ($i:item) => {$i}}\n               struct Entries;\n               macro_rules! iterator_impl {\n-              () => { item!( impl Entries { fn size_hint(&self) { self;}})}}\n+              () => { item!( impl Entries { fn size_hint(&self) { self;}});}}\n               iterator_impl! { }\",\n               vec!(vec!(0)), true),\n             0)\n@@ -1666,9 +1667,9 @@ mod test {\n     }\n \n     #[test] fn fmt_in_macro_used_inside_module_macro() {\n-        let crate_str = \"macro_rules! fmt_wrap(($b:expr)=>($b.to_string()))\n-macro_rules! foo_module (() => (mod generated { fn a() { let xx = 147; fmt_wrap!(xx);}}))\n-foo_module!()\n+        let crate_str = \"macro_rules! fmt_wrap(($b:expr)=>($b.to_string()));\n+macro_rules! foo_module (() => (mod generated { fn a() { let xx = 147; fmt_wrap!(xx);}}));\n+foo_module!();\n \".to_string();\n         let cr = expand_crate_str(crate_str);\n         // find the xx binding"}, {"sha": "33936e6213f4570953886af57e84adb1ad43aec5", "filename": "src/libsyntax/ext/mtwt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibsyntax%2Fext%2Fmtwt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibsyntax%2Fext%2Fmtwt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fmtwt.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -108,7 +108,7 @@ pub fn apply_renames(renames: &RenameList, ctxt: SyntaxContext) -> SyntaxContext\n pub fn with_sctable<T, F>(op: F) -> T where\n     F: FnOnce(&SCTable) -> T,\n {\n-    thread_local!(static SCTABLE_KEY: SCTable = new_sctable_internal())\n+    thread_local!(static SCTABLE_KEY: SCTable = new_sctable_internal());\n     SCTABLE_KEY.with(move |slot| op(slot))\n }\n \n@@ -174,7 +174,7 @@ fn with_resolve_table_mut<T, F>(op: F) -> T where\n {\n     thread_local!(static RESOLVE_TABLE_KEY: RefCell<ResolveTable> = {\n         RefCell::new(HashMap::new())\n-    })\n+    });\n \n     RESOLVE_TABLE_KEY.with(move |slot| op(&mut *slot.borrow_mut()))\n }"}, {"sha": "14e13feac9850d5bb27742038282f702633889b0", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 61, "deletions": 61, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -100,7 +100,7 @@ pub mod rt {\n         fn to_source_with_hygiene(&self) -> String;\n     }\n \n-    macro_rules! impl_to_source(\n+    macro_rules! impl_to_source {\n         (P<$t:ty>, $pp:ident) => (\n             impl ToSource for P<$t> {\n                 fn to_source(&self) -> String {\n@@ -125,7 +125,7 @@ pub mod rt {\n                 }\n             }\n         );\n-    )\n+    }\n \n     fn slice_to_source<'a, T: ToSource>(sep: &'static str, xs: &'a [T]) -> String {\n         xs.iter()\n@@ -144,7 +144,7 @@ pub mod rt {\n             .to_string()\n     }\n \n-    macro_rules! impl_to_source_slice(\n+    macro_rules! impl_to_source_slice {\n         ($t:ty, $sep:expr) => (\n             impl ToSource for [$t] {\n                 fn to_source(&self) -> String {\n@@ -158,7 +158,7 @@ pub mod rt {\n                 }\n             }\n         )\n-    )\n+    }\n \n     impl ToSource for ast::Ident {\n         fn to_source(&self) -> String {\n@@ -172,18 +172,18 @@ pub mod rt {\n         }\n     }\n \n-    impl_to_source!(ast::Ty, ty_to_string)\n-    impl_to_source!(ast::Block, block_to_string)\n-    impl_to_source!(ast::Arg, arg_to_string)\n-    impl_to_source!(Generics, generics_to_string)\n-    impl_to_source!(P<ast::Item>, item_to_string)\n-    impl_to_source!(P<ast::Method>, method_to_string)\n-    impl_to_source!(P<ast::Stmt>, stmt_to_string)\n-    impl_to_source!(P<ast::Expr>, expr_to_string)\n-    impl_to_source!(P<ast::Pat>, pat_to_string)\n-    impl_to_source!(ast::Arm, arm_to_string)\n-    impl_to_source_slice!(ast::Ty, \", \")\n-    impl_to_source_slice!(P<ast::Item>, \"\\n\\n\")\n+    impl_to_source! { ast::Ty, ty_to_string }\n+    impl_to_source! { ast::Block, block_to_string }\n+    impl_to_source! { ast::Arg, arg_to_string }\n+    impl_to_source! { Generics, generics_to_string }\n+    impl_to_source! { P<ast::Item>, item_to_string }\n+    impl_to_source! { P<ast::Method>, method_to_string }\n+    impl_to_source! { P<ast::Stmt>, stmt_to_string }\n+    impl_to_source! { P<ast::Expr>, expr_to_string }\n+    impl_to_source! { P<ast::Pat>, pat_to_string }\n+    impl_to_source! { ast::Arm, arm_to_string }\n+    impl_to_source_slice! { ast::Ty, \", \" }\n+    impl_to_source_slice! { P<ast::Item>, \"\\n\\n\" }\n \n     impl ToSource for ast::Attribute_ {\n         fn to_source(&self) -> String {\n@@ -244,7 +244,7 @@ pub mod rt {\n         }\n     }\n \n-    macro_rules! impl_to_source_int(\n+    macro_rules! impl_to_source_int {\n         (signed, $t:ty, $tag:ident) => (\n             impl ToSource for $t {\n                 fn to_source(&self) -> String {\n@@ -272,70 +272,70 @@ pub mod rt {\n                 }\n             }\n         );\n-    )\n+    }\n \n-    impl_to_source_int!(signed, int, TyI)\n-    impl_to_source_int!(signed, i8,  TyI8)\n-    impl_to_source_int!(signed, i16, TyI16)\n-    impl_to_source_int!(signed, i32, TyI32)\n-    impl_to_source_int!(signed, i64, TyI64)\n+    impl_to_source_int! { signed, int, TyI }\n+    impl_to_source_int! { signed, i8,  TyI8 }\n+    impl_to_source_int! { signed, i16, TyI16 }\n+    impl_to_source_int! { signed, i32, TyI32 }\n+    impl_to_source_int! { signed, i64, TyI64 }\n \n-    impl_to_source_int!(unsigned, uint, TyU)\n-    impl_to_source_int!(unsigned, u8,   TyU8)\n-    impl_to_source_int!(unsigned, u16,  TyU16)\n-    impl_to_source_int!(unsigned, u32,  TyU32)\n-    impl_to_source_int!(unsigned, u64,  TyU64)\n+    impl_to_source_int! { unsigned, uint, TyU }\n+    impl_to_source_int! { unsigned, u8,   TyU8 }\n+    impl_to_source_int! { unsigned, u16,  TyU16 }\n+    impl_to_source_int! { unsigned, u32,  TyU32 }\n+    impl_to_source_int! { unsigned, u64,  TyU64 }\n \n     // Alas ... we write these out instead. All redundant.\n \n-    macro_rules! impl_to_tokens(\n+    macro_rules! impl_to_tokens {\n         ($t:ty) => (\n             impl ToTokens for $t {\n                 fn to_tokens(&self, cx: &ExtCtxt) -> Vec<TokenTree> {\n                     cx.parse_tts_with_hygiene(self.to_source_with_hygiene())\n                 }\n             }\n         )\n-    )\n+    }\n \n-    macro_rules! impl_to_tokens_lifetime(\n+    macro_rules! impl_to_tokens_lifetime {\n         ($t:ty) => (\n             impl<'a> ToTokens for $t {\n                 fn to_tokens(&self, cx: &ExtCtxt) -> Vec<TokenTree> {\n                     cx.parse_tts_with_hygiene(self.to_source_with_hygiene())\n                 }\n             }\n         )\n-    )\n-\n-    impl_to_tokens!(ast::Ident)\n-    impl_to_tokens!(P<ast::Item>)\n-    impl_to_tokens!(P<ast::Pat>)\n-    impl_to_tokens!(ast::Arm)\n-    impl_to_tokens!(P<ast::Method>)\n-    impl_to_tokens_lifetime!(&'a [P<ast::Item>])\n-    impl_to_tokens!(ast::Ty)\n-    impl_to_tokens_lifetime!(&'a [ast::Ty])\n-    impl_to_tokens!(Generics)\n-    impl_to_tokens!(P<ast::Stmt>)\n-    impl_to_tokens!(P<ast::Expr>)\n-    impl_to_tokens!(ast::Block)\n-    impl_to_tokens!(ast::Arg)\n-    impl_to_tokens!(ast::Attribute_)\n-    impl_to_tokens_lifetime!(&'a str)\n-    impl_to_tokens!(())\n-    impl_to_tokens!(char)\n-    impl_to_tokens!(bool)\n-    impl_to_tokens!(int)\n-    impl_to_tokens!(i8)\n-    impl_to_tokens!(i16)\n-    impl_to_tokens!(i32)\n-    impl_to_tokens!(i64)\n-    impl_to_tokens!(uint)\n-    impl_to_tokens!(u8)\n-    impl_to_tokens!(u16)\n-    impl_to_tokens!(u32)\n-    impl_to_tokens!(u64)\n+    }\n+\n+    impl_to_tokens! { ast::Ident }\n+    impl_to_tokens! { P<ast::Item> }\n+    impl_to_tokens! { P<ast::Pat> }\n+    impl_to_tokens! { ast::Arm }\n+    impl_to_tokens! { P<ast::Method> }\n+    impl_to_tokens_lifetime! { &'a [P<ast::Item>] }\n+    impl_to_tokens! { ast::Ty }\n+    impl_to_tokens_lifetime! { &'a [ast::Ty] }\n+    impl_to_tokens! { Generics }\n+    impl_to_tokens! { P<ast::Stmt> }\n+    impl_to_tokens! { P<ast::Expr> }\n+    impl_to_tokens! { ast::Block }\n+    impl_to_tokens! { ast::Arg }\n+    impl_to_tokens! { ast::Attribute_ }\n+    impl_to_tokens_lifetime! { &'a str }\n+    impl_to_tokens! { () }\n+    impl_to_tokens! { char }\n+    impl_to_tokens! { bool }\n+    impl_to_tokens! { int }\n+    impl_to_tokens! { i8 }\n+    impl_to_tokens! { i16 }\n+    impl_to_tokens! { i32 }\n+    impl_to_tokens! { i64 }\n+    impl_to_tokens! { uint }\n+    impl_to_tokens! { u8 }\n+    impl_to_tokens! { u16 }\n+    impl_to_tokens! { u32 }\n+    impl_to_tokens! { u64 }\n \n     pub trait ExtParseUtils {\n         fn parse_item(&self, s: String) -> P<ast::Item>;"}, {"sha": "10860ee5e01de99706a71f8e0d871af35440a41f", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -1485,7 +1485,7 @@ mod test {\n     }\n \n     // maybe add to expand.rs...\n-    macro_rules! assert_pred (\n+    macro_rules! assert_pred {\n         ($pred:expr, $predname:expr, $a:expr , $b:expr) => (\n             {\n                 let pred_val = $pred;\n@@ -1497,7 +1497,7 @@ mod test {\n                 }\n             }\n         )\n-    )\n+    }\n \n     // make sure idents get transformed everywhere\n     #[test] fn ident_transformation () {\n@@ -1523,6 +1523,6 @@ mod test {\n             matches_codepattern,\n             \"matches_codepattern\",\n             pprust::to_string(|s| fake_print_crate(s, &folded_crate)),\n-            \"zz!zz((zz$zz:zz$(zz $zz:zz)zz+=>(zz$(zz$zz$zz)+)))\".to_string());\n+            \"zz!zz((zz$zz:zz$(zz $zz:zz)zz+=>(zz$(zz$zz$zz)+)));\".to_string());\n     }\n }"}, {"sha": "c234c172fd8a62828d0ad0527960fdff6220c932", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 108, "deletions": 43, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -40,9 +40,10 @@ use ast::{ItemMac, ItemMod, ItemStruct, ItemTrait, ItemTy};\n use ast::{LifetimeDef, Lit, Lit_};\n use ast::{LitBool, LitChar, LitByte, LitBinary};\n use ast::{LitStr, LitInt, Local, LocalLet};\n+use ast::{MacStmtWithBraces, MacStmtWithSemicolon, MacStmtWithoutBraces};\n use ast::{MutImmutable, MutMutable, Mac_, MacInvocTT, MatchNormal};\n use ast::{Method, MutTy, BiMul, Mutability};\n-use ast::{MethodImplItem, NamedField, UnNeg, NoReturn, UnNot};\n+use ast::{MethodImplItem, NamedField, UnNeg, NoReturn, NodeId, UnNot};\n use ast::{Pat, PatEnum, PatIdent, PatLit, PatRange, PatRegion, PatStruct};\n use ast::{PatTup, PatBox, PatWild, PatWildMulti, PatWildSingle};\n use ast::{PolyTraitRef};\n@@ -132,7 +133,7 @@ enum ItemOrViewItem {\n /// macro expansion). Placement of these is not as complex as I feared it would\n /// be. The important thing is to make sure that lookahead doesn't balk at\n /// `token::Interpolated` tokens.\n-macro_rules! maybe_whole_expr (\n+macro_rules! maybe_whole_expr {\n     ($p:expr) => (\n         {\n             let found = match $p.token {\n@@ -170,10 +171,10 @@ macro_rules! maybe_whole_expr (\n             }\n         }\n     )\n-)\n+}\n \n /// As maybe_whole_expr, but for things other than expressions\n-macro_rules! maybe_whole (\n+macro_rules! maybe_whole {\n     ($p:expr, $constructor:ident) => (\n         {\n             let found = match ($p).token {\n@@ -252,7 +253,7 @@ macro_rules! maybe_whole (\n             }\n         }\n     )\n-)\n+}\n \n \n fn maybe_append(mut lhs: Vec<Attribute>, rhs: Option<Vec<Attribute>>)\n@@ -3708,21 +3709,32 @@ impl<'a> Parser<'a> {\n             );\n             let hi = self.span.hi;\n \n+            let style = if delim == token::Brace {\n+                MacStmtWithBraces\n+            } else {\n+                MacStmtWithoutBraces\n+            };\n+\n             if id.name == token::special_idents::invalid.name {\n-                if self.check(&token::Dot) {\n-                    let span = self.span;\n-                    let token_string = self.this_token_to_string();\n-                    self.span_err(span,\n-                                  format!(\"expected statement, found `{}`\",\n-                                          token_string).as_slice());\n-                    let mac_span = mk_sp(lo, hi);\n-                    self.span_help(mac_span, \"try parenthesizing this macro invocation\");\n-                    self.abort_if_errors();\n-                }\n-                P(spanned(lo, hi, StmtMac(\n-                    spanned(lo, hi, MacInvocTT(pth, tts, EMPTY_CTXT)), false)))\n+                P(spanned(lo,\n+                          hi,\n+                          StmtMac(spanned(lo,\n+                                          hi,\n+                                          MacInvocTT(pth, tts, EMPTY_CTXT)),\n+                                  style)))\n             } else {\n                 // if it has a special ident, it's definitely an item\n+                //\n+                // Require a semicolon or braces.\n+                if style != MacStmtWithBraces {\n+                    if !self.eat(&token::Semi) {\n+                        let last_span = self.last_span;\n+                        self.span_err(last_span,\n+                                      \"macros that expand to items must \\\n+                                       either be surrounded with braces or \\\n+                                       followed by a semicolon\");\n+                    }\n+                }\n                 P(spanned(lo, hi, StmtDecl(\n                     P(spanned(lo, hi, DeclItem(\n                         self.mk_item(\n@@ -3731,7 +3743,6 @@ impl<'a> Parser<'a> {\n                             Inherited, Vec::new(/*no attrs*/))))),\n                     ast::DUMMY_NODE_ID)))\n             }\n-\n         } else {\n             let found_attrs = !item_attrs.is_empty();\n             let item_err = Parser::expected_item_err(item_attrs.as_slice());\n@@ -3851,43 +3862,46 @@ impl<'a> Parser<'a> {\n                     attributes_box = Vec::new();\n                     stmt.and_then(|Spanned {node, span}| match node {\n                         StmtExpr(e, stmt_id) => {\n-                            // expression without semicolon\n-                            if classify::expr_requires_semi_to_be_stmt(&*e) {\n-                                // Just check for errors and recover; do not eat semicolon yet.\n-                                self.commit_stmt(&[], &[token::Semi,\n-                                    token::CloseDelim(token::Brace)]);\n-                            }\n-\n+                            self.handle_expression_like_statement(e,\n+                                                                  stmt_id,\n+                                                                  span,\n+                                                                  &mut stmts,\n+                                                                  &mut expr);\n+                        }\n+                        StmtMac(macro, MacStmtWithoutBraces) => {\n+                            // statement macro without braces; might be an\n+                            // expr depending on whether a semicolon follows\n                             match self.token {\n                                 token::Semi => {\n-                                    self.bump();\n-                                    let span_with_semi = Span {\n-                                        lo: span.lo,\n-                                        hi: self.last_span.hi,\n-                                        expn_id: span.expn_id,\n-                                    };\n                                     stmts.push(P(Spanned {\n-                                        node: StmtSemi(e, stmt_id),\n-                                        span: span_with_semi,\n+                                        node: StmtMac(macro,\n+                                                      MacStmtWithSemicolon),\n+                                        span: span,\n                                     }));\n-                                }\n-                                token::CloseDelim(token::Brace) => {\n-                                    expr = Some(e);\n+                                    self.bump();\n                                 }\n                                 _ => {\n-                                    stmts.push(P(Spanned {\n-                                        node: StmtExpr(e, stmt_id),\n-                                        span: span\n-                                    }));\n+                                    let e = self.mk_mac_expr(span.lo,\n+                                                             span.hi,\n+                                                             macro.node);\n+                                    let e =\n+                                        self.parse_dot_or_call_expr_with(e);\n+                                    self.handle_expression_like_statement(\n+                                        e,\n+                                        ast::DUMMY_NODE_ID,\n+                                        span,\n+                                        &mut stmts,\n+                                        &mut expr);\n                                 }\n                             }\n                         }\n-                        StmtMac(m, semi) => {\n+                        StmtMac(m, style) => {\n                             // statement macro; might be an expr\n                             match self.token {\n                                 token::Semi => {\n                                     stmts.push(P(Spanned {\n-                                        node: StmtMac(m, true),\n+                                        node: StmtMac(m,\n+                                                      MacStmtWithSemicolon),\n                                         span: span,\n                                     }));\n                                     self.bump();\n@@ -3902,7 +3916,7 @@ impl<'a> Parser<'a> {\n                                 }\n                                 _ => {\n                                     stmts.push(P(Spanned {\n-                                        node: StmtMac(m, semi),\n+                                        node: StmtMac(m, style),\n                                         span: span\n                                     }));\n                                 }\n@@ -3941,6 +3955,43 @@ impl<'a> Parser<'a> {\n         })\n     }\n \n+    fn handle_expression_like_statement(\n+            &mut self,\n+            e: P<Expr>,\n+            stmt_id: NodeId,\n+            span: Span,\n+            stmts: &mut Vec<P<Stmt>>,\n+            last_block_expr: &mut Option<P<Expr>>) {\n+        // expression without semicolon\n+        if classify::expr_requires_semi_to_be_stmt(&*e) {\n+            // Just check for errors and recover; do not eat semicolon yet.\n+            self.commit_stmt(&[],\n+                             &[token::Semi, token::CloseDelim(token::Brace)]);\n+        }\n+\n+        match self.token {\n+            token::Semi => {\n+                self.bump();\n+                let span_with_semi = Span {\n+                    lo: span.lo,\n+                    hi: self.last_span.hi,\n+                    expn_id: span.expn_id,\n+                };\n+                stmts.push(P(Spanned {\n+                    node: StmtSemi(e, stmt_id),\n+                    span: span_with_semi,\n+                }));\n+            }\n+            token::CloseDelim(token::Brace) => *last_block_expr = Some(e),\n+            _ => {\n+                stmts.push(P(Spanned {\n+                    node: StmtExpr(e, stmt_id),\n+                    span: span\n+                }));\n+            }\n+        }\n+    }\n+\n     // Parses a sequence of bounds if a `:` is found,\n     // otherwise returns empty list.\n     fn parse_colon_then_ty_param_bounds(&mut self)\n@@ -4591,6 +4642,9 @@ impl<'a> Parser<'a> {\n                 let m: ast::Mac = codemap::Spanned { node: m_,\n                                                  span: mk_sp(self.span.lo,\n                                                              self.span.hi) };\n+                if delim != token::Brace {\n+                    self.expect(&token::Semi)\n+                }\n                 (ast::MethMac(m), self.span.hi, attrs)\n             } else {\n                 let unsafety = self.parse_unsafety();\n@@ -5747,6 +5801,17 @@ impl<'a> Parser<'a> {\n             let m: ast::Mac = codemap::Spanned { node: m,\n                                              span: mk_sp(self.span.lo,\n                                                          self.span.hi) };\n+\n+            if delim != token::Brace {\n+                if !self.eat(&token::Semi) {\n+                    let last_span = self.last_span;\n+                    self.span_err(last_span,\n+                                  \"macros that expand to items must either \\\n+                                   be surrounded with braces or followed by \\\n+                                   a semicolon\");\n+                }\n+            }\n+\n             let item_ = ItemMac(m);\n             let last_span = self.last_span;\n             let item = self.mk_item(lo,"}, {"sha": "641239f1f8b8df6ee2703fd29f9dff4f0a5aad3b", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -570,7 +570,7 @@ pub type IdentInterner = StrInterner;\n pub fn get_ident_interner() -> Rc<IdentInterner> {\n     thread_local!(static KEY: Rc<::parse::token::IdentInterner> = {\n         Rc::new(mk_fresh_ident_interner())\n-    })\n+    });\n     KEY.with(|k| k.clone())\n }\n "}, {"sha": "1dd61a5ce1943ad938bea18db47e6390609e4e63", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 29, "deletions": 13, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -409,12 +409,12 @@ pub fn arg_to_string(arg: &ast::Arg) -> String {\n }\n \n pub fn mac_to_string(arg: &ast::Mac) -> String {\n-    $to_string(|s| s.print_mac(arg))\n+    $to_string(|s| s.print_mac(arg, ::parse::token::Paren))\n }\n \n } }\n \n-thing_to_string_impls!(to_string)\n+thing_to_string_impls! { to_string }\n \n // FIXME (Issue #16472): the whole `with_hygiene` mod should go away\n // after we revise the syntax::ext::quote::ToToken impls to go directly\n@@ -437,7 +437,7 @@ pub mod with_hygiene {\n         })\n     }\n \n-    thing_to_string_impls!(to_string_hyg)\n+    thing_to_string_impls! { to_string_hyg }\n }\n \n pub fn visibility_qualified(vis: ast::Visibility, s: &str) -> String {\n@@ -992,6 +992,7 @@ impl<'a> State<'a> {\n                 try!(self.popen());\n                 try!(self.print_tts(tts.as_slice()));\n                 try!(self.pclose());\n+                try!(word(&mut self.s, \";\"));\n                 try!(self.end());\n             }\n         }\n@@ -1258,6 +1259,7 @@ impl<'a> State<'a> {\n                 try!(self.popen());\n                 try!(self.print_tts(tts.as_slice()));\n                 try!(self.pclose());\n+                try!(word(&mut self.s, \";\"));\n                 self.end()\n             }\n         }\n@@ -1330,11 +1332,16 @@ impl<'a> State<'a> {\n                 try!(self.print_expr(&**expr));\n                 try!(word(&mut self.s, \";\"));\n             }\n-            ast::StmtMac(ref mac, semi) => {\n+            ast::StmtMac(ref mac, style) => {\n                 try!(self.space_if_not_bol());\n-                try!(self.print_mac(mac));\n-                if semi {\n-                    try!(word(&mut self.s, \";\"));\n+                let delim = match style {\n+                    ast::MacStmtWithBraces => token::Brace,\n+                    _ => token::Paren\n+                };\n+                try!(self.print_mac(mac, delim));\n+                match style {\n+                    ast::MacStmtWithBraces => {}\n+                    _ => try!(word(&mut self.s, \";\")),\n                 }\n             }\n         }\n@@ -1461,15 +1468,24 @@ impl<'a> State<'a> {\n         self.print_else(elseopt)\n     }\n \n-    pub fn print_mac(&mut self, m: &ast::Mac) -> IoResult<()> {\n+    pub fn print_mac(&mut self, m: &ast::Mac, delim: token::DelimToken)\n+                     -> IoResult<()> {\n         match m.node {\n             // I think it's reasonable to hide the ctxt here:\n             ast::MacInvocTT(ref pth, ref tts, _) => {\n                 try!(self.print_path(pth, false));\n                 try!(word(&mut self.s, \"!\"));\n-                try!(self.popen());\n+                match delim {\n+                    token::Paren => try!(self.popen()),\n+                    token::Bracket => try!(word(&mut self.s, \"[\")),\n+                    token::Brace => try!(self.bopen()),\n+                }\n                 try!(self.print_tts(tts.as_slice()));\n-                self.pclose()\n+                match delim {\n+                    token::Paren => self.pclose(),\n+                    token::Bracket => word(&mut self.s, \"]\"),\n+                    token::Brace => self.bclose(m.span),\n+                }\n             }\n         }\n     }\n@@ -1817,7 +1833,7 @@ impl<'a> State<'a> {\n                 }));\n                 try!(self.pclose());\n             }\n-            ast::ExprMac(ref m) => try!(self.print_mac(m)),\n+            ast::ExprMac(ref m) => try!(self.print_mac(m, token::Paren)),\n             ast::ExprParen(ref e) => {\n                 try!(self.popen());\n                 try!(self.print_expr(&**e));\n@@ -2098,7 +2114,7 @@ impl<'a> State<'a> {\n                                    |s, p| s.print_pat(&**p)));\n                 try!(word(&mut self.s, \"]\"));\n             }\n-            ast::PatMac(ref m) => try!(self.print_mac(m)),\n+            ast::PatMac(ref m) => try!(self.print_mac(m, token::Paren)),\n         }\n         self.ann.post(self, NodePat(pat))\n     }\n@@ -2187,7 +2203,7 @@ impl<'a> State<'a> {\n         try!(self.nbsp());\n         try!(self.print_ident(name));\n         try!(self.print_generics(generics));\n-        try!(self.print_fn_args_and_ret(decl, opt_explicit_self))\n+        try!(self.print_fn_args_and_ret(decl, opt_explicit_self));\n         self.print_where_clause(generics)\n     }\n "}, {"sha": "fe96d7b8b7d013c240f81e9d71f04e598b42ea6d", "filename": "src/libterm/terminfo/parser/compiled.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -165,7 +165,7 @@ pub fn parse(file: &mut io::Reader, longnames: bool)\n             Ok(e) => e,\n             Err(e) => return Err(format!(\"{}\", e))\n         }\n-    ) )\n+    ) );\n \n     let bnames;\n     let snames;"}, {"sha": "7441b39f35b23f5bdb70125af55ae2a21161c7e7", "filename": "src/libtest/stats.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibtest%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Flibtest%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fstats.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -459,14 +459,14 @@ mod tests {\n     use std::io;\n     use std::f64;\n \n-    macro_rules! assert_approx_eq(\n+    macro_rules! assert_approx_eq {\n         ($a:expr, $b:expr) => ({\n             use std::num::Float;\n             let (a, b) = (&$a, &$b);\n             assert!((*a - *b).abs() < 1.0e-6,\n                     \"{} is not approximately equal to {}\", *a, *b);\n         })\n-    )\n+    }\n \n     fn check(samples: &[f64], summ: &Summary<f64>) {\n "}, {"sha": "add54ed01e00e618c416c751b68fa6703d8f2ef4", "filename": "src/test/auxiliary/lint_group_plugin_test.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Fauxiliary%2Flint_group_plugin_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Fauxiliary%2Flint_group_plugin_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Flint_group_plugin_test.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -23,11 +23,9 @@ use syntax::parse::token;\n use rustc::lint::{Context, LintPass, LintPassObject, LintArray};\n use rustc::plugin::Registry;\n \n-declare_lint!(TEST_LINT, Warn,\n-              \"Warn about items named 'lintme'\")\n+declare_lint!(TEST_LINT, Warn, \"Warn about items named 'lintme'\");\n \n-declare_lint!(PLEASE_LINT, Warn,\n-              \"Warn about items named 'pleaselintme'\")\n+declare_lint!(PLEASE_LINT, Warn, \"Warn about items named 'pleaselintme'\");\n \n struct Pass;\n "}, {"sha": "6c78cdce28ac4b12d75b3cf1610a00cf0cf2cab7", "filename": "src/test/auxiliary/lint_plugin_test.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Fauxiliary%2Flint_plugin_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Fauxiliary%2Flint_plugin_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Flint_plugin_test.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -23,8 +23,7 @@ use syntax::parse::token;\n use rustc::lint::{Context, LintPass, LintPassObject, LintArray};\n use rustc::plugin::Registry;\n \n-declare_lint!(TEST_LINT, Warn,\n-              \"Warn about items named 'lintme'\")\n+declare_lint!(TEST_LINT, Warn, \"Warn about items named 'lintme'\");\n \n struct Pass;\n "}, {"sha": "82af18b189b68f12f0284aed0e60c53c56cba2b9", "filename": "src/test/auxiliary/lint_stability.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Fauxiliary%2Flint_stability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Fauxiliary%2Flint_stability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Flint_stability.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -183,14 +183,14 @@ pub struct LockedTupleStruct(pub int);\n #[macro_export]\n macro_rules! macro_test(\n     () => (deprecated());\n-)\n+);\n \n #[macro_export]\n macro_rules! macro_test_arg(\n     ($func:expr) => ($func);\n-)\n+);\n \n #[macro_export]\n macro_rules! macro_test_arg_nested(\n     ($func:ident) => (macro_test_arg!($func()));\n-)\n+);"}, {"sha": "ad3e72f5fa2219cca0706ff5ee853cf29d2b49a5", "filename": "src/test/auxiliary/macro_crate_def_only.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Fauxiliary%2Fmacro_crate_def_only.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Fauxiliary%2Fmacro_crate_def_only.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fmacro_crate_def_only.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -13,4 +13,4 @@\n #[macro_export]\n macro_rules! make_a_5(\n     () => (5)\n-)\n+);"}, {"sha": "b82cfcbc8fcb297685a3e5b9e73de1a646b957d6", "filename": "src/test/auxiliary/macro_crate_test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Fauxiliary%2Fmacro_crate_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Fauxiliary%2Fmacro_crate_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fmacro_crate_test.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -24,9 +24,9 @@ use syntax::ptr::P;\n use rustc::plugin::Registry;\n \n #[macro_export]\n-macro_rules! exported_macro (() => (2i))\n+macro_rules! exported_macro (() => (2i));\n \n-macro_rules! unexported_macro (() => (3i))\n+macro_rules! unexported_macro (() => (3i));\n \n #[plugin_registrar]\n pub fn plugin_registrar(reg: &mut Registry) {"}, {"sha": "9b4b1ceb5c1e7b072ad0d7c9cfeed48f14169365", "filename": "src/test/auxiliary/macro_export_inner_module.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Fauxiliary%2Fmacro_export_inner_module.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Fauxiliary%2Fmacro_export_inner_module.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fmacro_export_inner_module.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -14,5 +14,5 @@ pub mod inner {\n     #[macro_export]\n     macro_rules! foo(\n         () => (1)\n-    )\n+    );\n }"}, {"sha": "16129593485b85f49be57c5ce963a109dc4af314", "filename": "src/test/bench/core-std.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Fbench%2Fcore-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Fbench%2Fcore-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-std.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -31,7 +31,7 @@ fn main() {\n         ($id:ident) =>\n             (maybe_run_test(argv.as_slice(),\n                             stringify!($id).to_string(),\n-                            $id)))\n+                            $id)));\n \n     bench!(shift_push);\n     bench!(read_line);"}, {"sha": "0a004c101ee4f2f7d374c87b8d65f79a3fb1a58c", "filename": "src/test/compile-fail/const-block-non-item-statement.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Fcompile-fail%2Fconst-block-non-item-statement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Fcompile-fail%2Fconst-block-non-item-statement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-block-non-item-statement.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -19,7 +19,7 @@ static B: uint = { { } 2 };\n macro_rules! foo {\n     () => (()) //~ ERROR: blocks in constants are limited to items and tail expressions\n }\n-static C: uint = { foo!() 2 };\n+static C: uint = { foo!(); 2 };\n \n static D: uint = { let x = 4u; 2 };\n //~^ ERROR: blocks in constants are limited to items and tail expressions"}, {"sha": "ae2f03fd5f79872266da783203f1869313762e0e", "filename": "src/test/compile-fail/gated-macro-rules.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Fcompile-fail%2Fgated-macro-rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Fcompile-fail%2Fgated-macro-rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fgated-macro-rules.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-macro_rules! foo(() => ())\n+macro_rules! foo(() => ());\n //~^ ERROR: macro definitions are not stable enough for use\n \n fn main() {}"}, {"sha": "22ac2eb1f7d5d9ac7af48c99ce32360bcaf3cf72", "filename": "src/test/compile-fail/infinite-macro-expansion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Fcompile-fail%2Finfinite-macro-expansion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Fcompile-fail%2Finfinite-macro-expansion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Finfinite-macro-expansion.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -14,7 +14,7 @@ macro_rules! recursive(\n       () => (\n                 recursive!() //~ ERROR recursion limit reached while expanding the macro `recursive`\n               )\n-      )\n+      );\n \n fn main() {\n     recursive!()"}, {"sha": "ab88b580ba108a4c2072fddc19be175cbafc60db", "filename": "src/test/compile-fail/issue-19734.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Fcompile-fail%2Fissue-19734.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Fcompile-fail%2Fissue-19734.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-19734.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -11,5 +11,5 @@\n fn main() {}\n \n impl Type {\n-    undef!() //~ ERROR macro undefined: 'undef!'\n+    undef!(); //~ ERROR macro undefined: 'undef!'\n }"}, {"sha": "3222b2cd53719a60f4c667f63745ad76aaeee9fd", "filename": "src/test/compile-fail/issue-6596.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Fcompile-fail%2Fissue-6596.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Fcompile-fail%2Fissue-6596.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-6596.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -16,7 +16,7 @@ macro_rules! e(\n     ($inp:ident) => (\n         $nonexistent\n     );\n-)\n+);\n \n fn main() {\n     e!(foo);"}, {"sha": "e92faa6bdaf6e902ca6b189dc86e12ed17c0ec8d", "filename": "src/test/compile-fail/liveness-return-last-stmt-semi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Fcompile-fail%2Fliveness-return-last-stmt-semi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Fcompile-fail%2Fliveness-return-last-stmt-semi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-return-last-stmt-semi.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -12,7 +12,7 @@\n \n #![feature(macro_rules)]\n \n-macro_rules! test ( () => { fn foo() -> int { 1i; } } )\n+macro_rules! test ( () => { fn foo() -> int { 1i; } } );\n                                              //~^ ERROR not all control paths return a value\n                                              //~^^ HELP consider removing this semicolon\n "}, {"sha": "71b656d0bbb57bb7796a42a8288e40a6cf27e0b1", "filename": "src/test/compile-fail/macro-incomplete-parse.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Fcompile-fail%2Fmacro-incomplete-parse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Fcompile-fail%2Fmacro-incomplete-parse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-incomplete-parse.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -26,10 +26,10 @@ macro_rules! ignored_pat {\n     () => ( 1, 2 ) //~ ERROR macro expansion ignores token `,`\n }\n \n-ignored_item!()\n+ignored_item!();\n \n fn main() {\n-    ignored_expr!()\n+    ignored_expr!();\n     match 1 {\n         ignored_pat!() => (),\n         _ => (),"}, {"sha": "f64b7be50e30781e55c76ed2fb6fe5878d40a9ca", "filename": "src/test/compile-fail/macro-inner-attributes.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Fcompile-fail%2Fmacro-inner-attributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Fcompile-fail%2Fmacro-inner-attributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-inner-attributes.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -12,15 +12,15 @@\n \n macro_rules! test ( ($nm:ident,\n                      #[$a:meta],\n-                     $i:item) => (mod $nm { #![$a] $i }); )\n+                     $i:item) => (mod $nm { #![$a] $i }); );\n \n test!(a,\n       #[cfg(qux)],\n-      pub fn bar() { })\n+      pub fn bar() { });\n \n test!(b,\n       #[cfg(not(qux))],\n-      pub fn bar() { })\n+      pub fn bar() { });\n \n #[qux]\n fn main() {"}, {"sha": "3818c8f7754a6aa44d34f783461b565bd2f889a5", "filename": "src/test/compile-fail/macro-local-data-key-priv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Fcompile-fail%2Fmacro-local-data-key-priv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Fcompile-fail%2Fmacro-local-data-key-priv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-local-data-key-priv.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -11,7 +11,7 @@\n // check that the local data keys are private by default.\n \n mod bar {\n-    thread_local!(static baz: f64 = 0.0)\n+    thread_local!(static baz: f64 = 0.0);\n }\n \n fn main() {"}, {"sha": "150187aa07d3c375820996f318fdd886d934063b", "filename": "src/test/compile-fail/macro-match-nonterminal.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Fcompile-fail%2Fmacro-match-nonterminal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Fcompile-fail%2Fmacro-match-nonterminal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-match-nonterminal.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -10,7 +10,7 @@\n \n #![feature(macro_rules)]\n \n-macro_rules! test ( ($a, $b) => (()); ) //~ ERROR Cannot transcribe\n+macro_rules! test ( ($a, $b) => (()); ); //~ ERROR Cannot transcribe\n \n fn main() {\n     test!()"}, {"sha": "6d59c203d14bd34bcba66fa703766ee319175457", "filename": "src/test/compile-fail/macro-outer-attributes.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Fcompile-fail%2Fmacro-outer-attributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Fcompile-fail%2Fmacro-outer-attributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-outer-attributes.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -12,15 +12,15 @@\n \n macro_rules! test ( ($nm:ident,\n                      #[$a:meta],\n-                     $i:item) => (mod $nm { #[$a] $i }); )\n+                     $i:item) => (mod $nm { #[$a] $i }); );\n \n test!(a,\n       #[cfg(qux)],\n-      pub fn bar() { })\n+      pub fn bar() { });\n \n test!(b,\n       #[cfg(not(qux))],\n-      pub fn bar() { })\n+      pub fn bar() { });\n \n // test1!(#[bar])\n #[qux]"}, {"sha": "f1f31a99e970af3e7954e4390b0d7a0419e7b3f9", "filename": "src/test/compile-fail/macros-no-semicolon-items.rs", "status": "renamed", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Fcompile-fail%2Fmacros-no-semicolon-items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Fcompile-fail%2Fmacros-no-semicolon-items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacros-no-semicolon-items.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -8,7 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+macro_rules! foo()  //~ ERROR semicolon\n+\n fn main() {\n-    foo!() //~ HELP try parenthesizing this macro invocation\n-    .bar //~ ERROR expected statement\n }\n+", "previous_filename": "src/test/compile-fail/macro-invocation-dot-help.rs"}, {"sha": "fd5f5866f094085fe0cebc8d4691484ebbbd9d47", "filename": "src/test/compile-fail/macros-no-semicolon.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Fcompile-fail%2Fmacros-no-semicolon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Fcompile-fail%2Fmacros-no-semicolon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacros-no-semicolon.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    assert!(1 == 2)\n+    assert!(3 == 4) //~ ERROR expected one of `.`, `;`, or `}`, found `assert`\n+    println!(\"hello\");\n+}\n+"}, {"sha": "747b4815ac2ae2b8d5fcc4a0b11e785d6b8c5170", "filename": "src/test/compile-fail/method-macro-backtrace.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Fcompile-fail%2Fmethod-macro-backtrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Fcompile-fail%2Fmethod-macro-backtrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmethod-macro-backtrace.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -14,20 +14,20 @@\n \n macro_rules! make_method ( ($name:ident) => (\n     fn $name(&self) { }\n-))\n+));\n \n struct S;\n \n impl S {\n     // We had a bug where these wouldn't clean up macro backtrace frames.\n-    make_method!(foo1)\n-    make_method!(foo2)\n-    make_method!(foo3)\n-    make_method!(foo4)\n-    make_method!(foo5)\n-    make_method!(foo6)\n-    make_method!(foo7)\n-    make_method!(foo8)\n+    make_method!(foo1);\n+    make_method!(foo2);\n+    make_method!(foo3);\n+    make_method!(foo4);\n+    make_method!(foo5);\n+    make_method!(foo6);\n+    make_method!(foo7);\n+    make_method!(foo8);\n \n     // Cause an error. It shouldn't have any macro backtrace frames.\n     fn bar(&self) { }"}, {"sha": "3322fecf950c1437c9648f5c4d88fba9293793eb", "filename": "src/test/compile-fail/pattern-macro-hygiene.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Fcompile-fail%2Fpattern-macro-hygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Fcompile-fail%2Fpattern-macro-hygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpattern-macro-hygiene.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -10,7 +10,7 @@\n \n #![feature(macro_rules)]\n \n-macro_rules! foo ( () => ( x ) )\n+macro_rules! foo ( () => ( x ) );\n \n fn main() {\n     let foo!() = 2;", "previous_filename": "src/test/compile-fail/pattern-macro-hygeine.rs"}, {"sha": "de0d5c90fdd4b9ab4d547c42ad83f295e58a9f91", "filename": "src/test/compile-fail/recursion_limit.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Fcompile-fail%2Frecursion_limit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Fcompile-fail%2Frecursion_limit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frecursion_limit.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -22,19 +22,19 @@ macro_rules! link {\n     }\n }\n \n-link!(A,B)\n-link!(B,C)\n-link!(C,D)\n-link!(D,E)\n-link!(E,F)\n-link!(F,G)\n-link!(G,H)\n-link!(H,I)\n-link!(I,J)\n-link!(J,K)\n-link!(K,L)\n-link!(L,M)\n-link!(M,N)\n+link! { A, B }\n+link! { B, C }\n+link! { C, D }\n+link! { D, E }\n+link! { E, F }\n+link! { F, G }\n+link! { G, H }\n+link! { H, I }\n+link! { I, J }\n+link! { J, K }\n+link! { K, L }\n+link! { L, M }\n+link! { M, N }\n \n enum N { N(uint) }\n "}, {"sha": "2c76f2ca7dfa87385843104ab479f02dc5660cbb", "filename": "src/test/debuginfo/lexical-scope-with-macro.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Fdebuginfo%2Flexical-scope-with-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Fdebuginfo%2Flexical-scope-with-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Flexical-scope-with-macro.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -113,23 +113,23 @@\n \n #![feature(macro_rules)]\n \n-macro_rules! trivial(\n+macro_rules! trivial {\n     ($e1:expr) => ($e1)\n-)\n+}\n \n-macro_rules! no_new_scope(\n+macro_rules! no_new_scope {\n     ($e1:expr) => (($e1 + 2) - 1)\n-)\n+}\n \n-macro_rules! new_scope(\n+macro_rules! new_scope {\n     () => ({\n         let a = 890242i;\n         zzz(); // #break\n         sentinel();\n     })\n-)\n+}\n \n-macro_rules! shadow_within_macro(\n+macro_rules! shadow_within_macro {\n     ($e1:expr) => ({\n         let a = $e1 + 2;\n \n@@ -141,12 +141,12 @@ macro_rules! shadow_within_macro(\n         zzz(); // #break\n         sentinel();\n     })\n-)\n+}\n \n \n-macro_rules! dup_expr(\n+macro_rules! dup_expr {\n     ($e1:expr) => (($e1) + ($e1))\n-)\n+}\n \n \n fn main() {"}, {"sha": "08c9f8b4aa7d52c9cf5e5cfb31d9ef11de6f2bb2", "filename": "src/test/run-pass-fulldeps/issue_16723_multiple_items_syntax_ext.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Frun-pass-fulldeps%2Fissue_16723_multiple_items_syntax_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Frun-pass-fulldeps%2Fissue_16723_multiple_items_syntax_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fissue_16723_multiple_items_syntax_ext.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -15,7 +15,7 @@\n \n #[phase(plugin)] extern crate issue_16723_multiple_items_syntax_ext;\n \n-multiple_items!()\n+multiple_items!();\n \n impl Struct1 {\n     fn foo() {}"}, {"sha": "42f6914e081a300df8154689b8dcebd916d6bf2b", "filename": "src/test/run-pass/cleanup-rvalue-scopes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Frun-pass%2Fcleanup-rvalue-scopes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Frun-pass%2Fcleanup-rvalue-scopes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcleanup-rvalue-scopes.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -74,7 +74,7 @@ macro_rules! end_of_block(\n             check_flags(1);\n         }\n     )\n-)\n+);\n \n macro_rules! end_of_stmt(\n     ($pat:pat, $expr:expr) => (\n@@ -91,7 +91,7 @@ macro_rules! end_of_stmt(\n             check_flags(0);\n         }\n     )\n-)\n+);\n \n pub fn main() {\n "}, {"sha": "cac805189b82e796e9c58271545d036050f8fee3", "filename": "src/test/run-pass/const-binops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Frun-pass%2Fconst-binops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Frun-pass%2Fconst-binops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-binops.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -17,7 +17,7 @@ macro_rules! assert_approx_eq(\n         assert!((*a - *b).abs() < 1.0e-6,\n                 \"{} is not approximately equal to {}\", *a, *b);\n     })\n-)\n+);\n \n static A: int = -4 + 3;\n static A2: uint = 3 + 3;"}, {"sha": "a0fa2d178b949641bbb26d0390f2710629bf20ef", "filename": "src/test/run-pass/core-run-destroy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Frun-pass%2Fcore-run-destroy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Frun-pass%2Fcore-run-destroy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcore-run-destroy.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -26,7 +26,7 @@ use std::str;\n \n macro_rules! succeed( ($e:expr) => (\n     match $e { Ok(..) => {}, Err(e) => panic!(\"panic: {}\", e) }\n-) )\n+) );\n \n fn test_destroy_once() {\n     let mut p = sleeper();"}, {"sha": "52b5c040d86cdb1e6912d7f554c4229a93d41d44", "filename": "src/test/run-pass/deriving-in-macro.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Frun-pass%2Fderiving-in-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Frun-pass%2Fderiving-in-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-in-macro.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -17,8 +17,8 @@ macro_rules! define_vec (\n             pub struct bar;\n         }\n     )\n-)\n+);\n \n-define_vec!()\n+define_vec!();\n \n pub fn main() {}"}, {"sha": "f63ab7fb7c9a5ca5e6b1bc155ebf8b5a76d17cba", "filename": "src/test/run-pass/exponential-notation.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Frun-pass%2Fexponential-notation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Frun-pass%2Fexponential-notation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexponential-notation.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -13,22 +13,22 @@\n use std::num::strconv as s;\n use std::num::strconv::float_to_str_common as to_string;\n \n-macro_rules! t(($a:expr, $b:expr) => { { let (r, _) = $a; assert_eq!(r, $b.to_string()) } })\n+macro_rules! t(($a:expr, $b:expr) => { { let (r, _) = $a; assert_eq!(r, $b.to_string()); } });\n \n pub fn main() {\n     // Basic usage\n     t!(to_string(1.2345678e-5f64, 10u, true, s::SignNeg, s::DigMax(6), s::ExpDec, false),\n-             \"1.234568e-5\")\n+             \"1.234568e-5\");\n \n     // Hexadecimal output\n     t!(to_string(7.281738281250e+01f64, 16u, true, s::SignAll, s::DigMax(6), s::ExpBin, false),\n-              \"+1.2345p+6\")\n+              \"+1.2345p+6\");\n     t!(to_string(-1.777768135071e-02f64, 16u, true, s::SignAll, s::DigMax(6), s::ExpBin, false),\n-             \"-1.2345p-6\")\n+             \"-1.2345p-6\");\n \n     // Some denormals\n     t!(to_string(4.9406564584124654e-324f64, 10u, true, s::SignNeg, s::DigMax(6), s::ExpBin, false),\n-             \"1p-1074\")\n+             \"1p-1074\");\n     t!(to_string(2.2250738585072009e-308f64, 10u, true, s::SignNeg, s::DigMax(6), s::ExpBin, false),\n-             \"1p-1022\")\n+             \"1p-1022\");\n }"}, {"sha": "0d56f28e8fae7afc639625a4f3ab6fc9fea4cc7c", "filename": "src/test/run-pass/html-literals.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Frun-pass%2Fhtml-literals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Frun-pass%2Fhtml-literals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhtml-literals.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -31,7 +31,7 @@ macro_rules! html (\n     ( $($body:tt)* ) => (\n         parse_node!( []; []; $($body)* )\n     )\n-)\n+);\n \n macro_rules! parse_node (\n     (\n@@ -85,7 +85,7 @@ macro_rules! parse_node (\n     );\n \n     ( []; [:$e:expr]; ) => ( $e );\n-)\n+);\n \n pub fn main() {\n     let _page = html! ("}, {"sha": "9eac9c30dc8f7ee27d2a9a4061e73c05b03dd425", "filename": "src/test/run-pass/ifmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Frun-pass%2Fifmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Frun-pass%2Fifmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fifmt.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -38,7 +38,7 @@ impl fmt::Show for C {\n     }\n }\n \n-macro_rules! t(($a:expr, $b:expr) => { assert_eq!($a.as_slice(), $b) })\n+macro_rules! t(($a:expr, $b:expr) => { assert_eq!($a.as_slice(), $b) });\n \n pub fn main() {\n     // Various edge cases without formats"}, {"sha": "9f2fe155cdf9597f1f48069cb3aaf78ea3c1102c", "filename": "src/test/run-pass/intrinsics-math.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Frun-pass%2Fintrinsics-math.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Frun-pass%2Fintrinsics-math.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fintrinsics-math.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -18,7 +18,7 @@ macro_rules! assert_approx_eq(\n         assert!((*a - *b).abs() < 1.0e-6,\n                 \"{} is not approximately equal to {}\", *a, *b);\n     })\n-)\n+);\n \n mod rusti {\n     extern \"rust-intrinsic\" {"}, {"sha": "01c96b7563a752acdc333d145f36f01b515ca5b0", "filename": "src/test/run-pass/issue-15189.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Frun-pass%2Fissue-15189.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Frun-pass%2Fissue-15189.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-15189.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -12,7 +12,7 @@\n \n #![feature(macro_rules)]\n \n-macro_rules! third(($e:expr)=>({let x = 2; $e[x]}))\n+macro_rules! third(($e:expr)=>({let x = 2; $e[x]}));\n \n fn main() {\n     let x = vec!(10u,11u,12u,13u);"}, {"sha": "a11b34e4762759053d456564f6b2975581a71303", "filename": "src/test/run-pass/issue-15221.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Frun-pass%2Fissue-15221.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Frun-pass%2Fissue-15221.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-15221.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -11,10 +11,10 @@\n #![feature(macro_rules)]\n \n macro_rules! inner (\n-    ($e:pat ) => ($e))\n+    ($e:pat ) => ($e));\n \n macro_rules! outer (\n-    ($e:pat ) => (inner!($e)))\n+    ($e:pat ) => (inner!($e)));\n \n fn main() {\n     let outer!(g1) = 13i;"}, {"sha": "0cd25bc2c719b200cd4b9c591af41279231b5215", "filename": "src/test/run-pass/issue-5060.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Frun-pass%2Fissue-5060.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Frun-pass%2Fissue-5060.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-5060.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -21,7 +21,7 @@ macro_rules! print_hd_tl (\n         // FIXME: #9970\n         print!(\"{}\", \"]\\n\");\n     })\n-)\n+);\n \n pub fn main() {\n     print_hd_tl!(x, y, z, w)"}, {"sha": "c69b66f4dbd76fe408102184898587a94df22530", "filename": "src/test/run-pass/issue-7911.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Frun-pass%2Fissue-7911.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Frun-pass%2Fissue-7911.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-7911.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -37,9 +37,9 @@ macro_rules! generate_test(($type_:path, $slf:ident, $field:expr) => (\n             &mut $field as &mut FooBar\n         }\n     }\n-))\n+));\n \n-generate_test!(Foo, self, self.bar)\n+generate_test!(Foo, self, self.bar);\n \n pub fn main() {\n     let mut foo: Foo = Foo { bar: Bar(42) };"}, {"sha": "d4ea05004a064b99858ce7535f7bb6a83a28679b", "filename": "src/test/run-pass/issue-8709.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Frun-pass%2Fissue-8709.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Frun-pass%2Fissue-8709.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-8709.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -12,13 +12,13 @@\n \n macro_rules! sty(\n     ($t:ty) => (stringify!($t))\n-)\n+);\n \n macro_rules! spath(\n     ($t:path) => (stringify!($t))\n-)\n+);\n \n fn main() {\n-    assert_eq!(sty!(int), \"int\")\n-    assert_eq!(spath!(std::option), \"std::option\")\n+    assert_eq!(sty!(int), \"int\");\n+    assert_eq!(spath!(std::option), \"std::option\");\n }"}, {"sha": "5826a5f9919f4a89542923ea15ba992e670161f9", "filename": "src/test/run-pass/issue-8851.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Frun-pass%2Fissue-8851.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Frun-pass%2Fissue-8851.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-8851.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -29,9 +29,9 @@ macro_rules! test(\n             }\n         }\n     )\n-)\n+);\n \n-test!(y, 10 + (y as int))\n+test!(y, 10 + (y as int));\n \n pub fn main() {\n     foo(T::A(20));"}, {"sha": "60011281d425e48c2405f943596476258873d424", "filename": "src/test/run-pass/issue-9110.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Frun-pass%2Fissue-9110.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Frun-pass%2Fissue-9110.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-9110.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -17,8 +17,8 @@ macro_rules! silly_macro(\n             pub fn bar(_foo : Foo) {}\n         }\n     );\n-)\n+);\n \n-silly_macro!()\n+silly_macro!();\n \n pub fn main() {}"}, {"sha": "a6746f452065d9fd93944c1a7afdaca410b19a57", "filename": "src/test/run-pass/issue-9129.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Frun-pass%2Fissue-9129.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Frun-pass%2Fissue-9129.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-9129.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -20,7 +20,7 @@ impl bomb for S { fn boom(&self, _: Ident) { } }\n pub struct Ident { name: uint }\n \n // macro_rules! int3( () => ( unsafe { asm!( \"int3\" ); } ) )\n-macro_rules! int3( () => ( { } ) )\n+macro_rules! int3( () => ( { } ) );\n \n fn Ident_new() -> Ident {\n     int3!();"}, {"sha": "5eed791e0582ddd5acfde08fc019b8d2baf29319", "filename": "src/test/run-pass/let-var-hygiene.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Frun-pass%2Flet-var-hygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Frun-pass%2Flet-var-hygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flet-var-hygiene.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -11,7 +11,7 @@\n #![feature(macro_rules)]\n \n // shouldn't affect evaluation of $ex:\n-macro_rules! bad_macro (($ex:expr) => ({let _x = 9i; $ex}))\n+macro_rules! bad_macro (($ex:expr) => ({let _x = 9i; $ex}));\n pub fn main() {\n     let _x = 8i;\n     assert_eq!(bad_macro!(_x),8i)"}, {"sha": "95a5f1003b6e356f8b39dd57e08bd7aac77513af", "filename": "src/test/run-pass/log_syntax-trace_macros-macro-locations.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Frun-pass%2Flog_syntax-trace_macros-macro-locations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Frun-pass%2Flog_syntax-trace_macros-macro-locations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flog_syntax-trace_macros-macro-locations.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -14,8 +14,8 @@\n // macros can occur.\n \n // items\n-trace_macros!(false)\n-log_syntax!()\n+trace_macros!(false);\n+log_syntax!();\n \n fn main() {\n "}, {"sha": "7b4d376993aa93e5b1692000e7949bfedf251cff", "filename": "src/test/run-pass/macro-2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Frun-pass%2Fmacro-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Frun-pass%2Fmacro-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-2.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -19,7 +19,7 @@ pub fn main() {\n             fn f($x: int) -> int { return $body; };\n             f\n         })\n-    )\n+    );\n \n-    assert!(mylambda_tt!(y, y * 2)(8) == 16)\n+    assert!(mylambda_tt!(y, y * 2)(8) == 16);\n }"}, {"sha": "3c170634c2231eeabf7065494ceeb67a7d0a3434", "filename": "src/test/run-pass/macro-attribute-expansion.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Frun-pass%2Fmacro-attribute-expansion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Frun-pass%2Fmacro-attribute-expansion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-attribute-expansion.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -22,8 +22,8 @@ macro_rules! descriptions {\n }\n \n // item\n-descriptions!(DOG is \"an animal\")\n-descriptions!(RUST is \"a language\")\n+descriptions! { DOG is \"an animal\" }\n+descriptions! { RUST is \"a language\" }\n \n pub fn main() {\n }"}, {"sha": "4df3b94c1c9d1339917531a81a6d5ec8cc09a0f5", "filename": "src/test/run-pass/macro-attributes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Frun-pass%2Fmacro-attributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Frun-pass%2Fmacro-attributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-attributes.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -27,7 +27,7 @@ macro_rules! compiles_fine {\n }\n \n // item\n-compiles_fine!(#[foo])\n+compiles_fine!(#[foo]);\n \n pub fn main() {\n     // statement"}, {"sha": "fcf2dff66a5f7d71f5639fc629d7c6b3b355bb53", "filename": "src/test/run-pass/macro-delimiter-significance.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Frun-pass%2Fmacro-delimiter-significance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Frun-pass%2Fmacro-delimiter-significance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-delimiter-significance.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    vec![1u, 2, 3].len();\n+}\n+"}, {"sha": "5c95f67257cd5629c13190887825dff76d73e07d", "filename": "src/test/run-pass/macro-include-items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Frun-pass%2Fmacro-include-items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Frun-pass%2Fmacro-include-items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-include-items.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -12,7 +12,7 @@\n \n fn bar() {}\n \n-include!(concat!(\"\", \"\", \"../auxiliary/\", \"macro-include-items-item.rs\"))\n+include!(concat!(\"\", \"\", \"../auxiliary/\", \"macro-include-items-item.rs\"));\n \n fn main() {\n     foo();"}, {"sha": "45712f5c62a6e5efe94cce6a688ff4a376d833ca", "filename": "src/test/run-pass/macro-interpolation.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Frun-pass%2Fmacro-interpolation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Frun-pass%2Fmacro-interpolation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-interpolation.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -22,7 +22,8 @@ macro_rules! overly_complicated (\n         }\n     })\n \n-)\n+);\n+\n pub fn main() {\n     assert!(overly_complicated!(f, x, Option<uint>, { return Some(x); },\n                                Some(8u), Some(y), y) == 8u)"}, {"sha": "4c124d85eee3acbc84c3acbb6023bdfecb494776", "filename": "src/test/run-pass/macro-invocation-in-count-expr-fixed-array-type.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Frun-pass%2Fmacro-invocation-in-count-expr-fixed-array-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Frun-pass%2Fmacro-invocation-in-count-expr-fixed-array-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-invocation-in-count-expr-fixed-array-type.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -12,7 +12,8 @@\n \n macro_rules! four (\n     () => (4)\n-)\n+);\n+\n fn main() {\n     let _x: [u16, ..four!()];\n }"}, {"sha": "4b01fdf816216b35af8d264b6639208e832dc21d", "filename": "src/test/run-pass/macro-meta-items.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Frun-pass%2Fmacro-meta-items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Frun-pass%2Fmacro-meta-items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-meta-items.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -27,8 +27,8 @@ macro_rules! emit {\n }\n \n // item\n-compiles_fine!(bar)\n-emit!(foo)\n+compiles_fine!(bar);\n+emit!(foo);\n \n fn foo() {\n     println!(\"{}\", MISTYPED);"}, {"sha": "aa6de9acf6b88eac4493ae981f807d5815051456", "filename": "src/test/run-pass/macro-method-issue-4621.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Frun-pass%2Fmacro-method-issue-4621.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Frun-pass%2Fmacro-method-issue-4621.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-method-issue-4621.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -13,7 +13,7 @@\n struct A;\n \n macro_rules! make_thirteen_method {() => (fn thirteen(&self)->int {13})}\n-impl A { make_thirteen_method!() }\n+impl A { make_thirteen_method!(); }\n \n fn main() {\n     assert_eq!(A.thirteen(),13);"}, {"sha": "4fb130f0e1314584ed8d02702be0e1228ccd40a8", "filename": "src/test/run-pass/macro-multiple-items.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Frun-pass%2Fmacro-multiple-items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Frun-pass%2Fmacro-multiple-items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-multiple-items.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -20,9 +20,9 @@ macro_rules! make_foo(\n             fn bar(&self) {}\n         }\n     )\n-)\n+);\n \n-make_foo!()\n+make_foo!();\n \n pub fn main() {\n     Foo.bar()"}, {"sha": "9367a231d4f65d15f1fbe06927e25424eaefa118", "filename": "src/test/run-pass/macro-nt-list.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Frun-pass%2Fmacro-nt-list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Frun-pass%2Fmacro-nt-list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-nt-list.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -14,11 +14,11 @@ macro_rules! list (\n     ( ($($id:ident),*) ) => (());\n     ( [$($id:ident),*] ) => (());\n     ( {$($id:ident),*} ) => (());\n-)\n+);\n \n macro_rules! tt_list (\n     ( ($($tt:tt),*) ) => (());\n-)\n+);\n \n pub fn main() {\n     list!( () );"}, {"sha": "c47b5e1108901aab41c7dfe66ed4697c4aca1288", "filename": "src/test/run-pass/macro-of-higher-order.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Frun-pass%2Fmacro-of-higher-order.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Frun-pass%2Fmacro-of-higher-order.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-of-higher-order.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -12,10 +12,10 @@\n \n macro_rules! higher_order (\n     (subst $lhs:tt => $rhs:tt) => ({\n-            macro_rules! anon ( $lhs => $rhs )\n+            macro_rules! anon ( $lhs => $rhs );\n             anon!(1u, 2u, \"foo\")\n     });\n-)\n+);\n \n fn main() {\n     let val = higher_order!(subst ($x:expr, $y:expr, $foo:expr) => (($x + $y, $foo)));"}, {"sha": "496cef9d644e27aa501be360155298f23bc06e9f", "filename": "src/test/run-pass/macro-pat.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Frun-pass%2Fmacro-pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Frun-pass%2Fmacro-pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-pat.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -14,31 +14,31 @@ macro_rules! mypat(\n     () => (\n         Some('y')\n     )\n-)\n+);\n \n macro_rules! char_x(\n     () => (\n         'x'\n     )\n-)\n+);\n \n macro_rules! some(\n     ($x:pat) => (\n         Some($x)\n     )\n-)\n+);\n \n macro_rules! indirect(\n     () => (\n         some!(char_x!())\n     )\n-)\n+);\n \n macro_rules! ident_pat(\n     ($x:ident) => (\n         $x\n     )\n-)\n+);\n \n fn f(c: Option<char>) -> uint {\n     match c {"}, {"sha": "7be49e1acd844db43843174b439a7a16f19ca751", "filename": "src/test/run-pass/macro-stmt.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Frun-pass%2Fmacro-stmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Frun-pass%2Fmacro-stmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-stmt.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -16,9 +16,9 @@ macro_rules! myfn(\n     ( $f:ident, ( $( $x:ident ),* ), $body:block ) => (\n         fn $f( $( $x : int),* ) -> int $body\n     )\n-)\n+);\n \n-myfn!(add, (a,b), { return a+b; } )\n+myfn!(add, (a,b), { return a+b; } );\n \n pub fn main() {\n \n@@ -37,7 +37,7 @@ pub fn main() {\n \n     macro_rules! actually_an_expr_macro (\n         () => ( 16i )\n-    )\n+    );\n \n     assert_eq!({ actually_an_expr_macro!() }, 16i);\n "}, {"sha": "631fc8666713df8ea36403600d8b56698c8c86f0", "filename": "src/test/run-pass/macro-with-attrs1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Frun-pass%2Fmacro-with-attrs1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Frun-pass%2Fmacro-with-attrs1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-with-attrs1.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -13,10 +13,10 @@\n #![feature(macro_rules)]\n \n #[cfg(foo)]\n-macro_rules! foo( () => (1i) )\n+macro_rules! foo( () => (1i) );\n \n #[cfg(not(foo))]\n-macro_rules! foo( () => (2i) )\n+macro_rules! foo( () => (2i) );\n \n pub fn main() {\n     assert_eq!(foo!(), 1i);"}, {"sha": "3ac0d47e61a63665b8a8e339f16e205d55bd8e0d", "filename": "src/test/run-pass/macro-with-attrs2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Frun-pass%2Fmacro-with-attrs2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Frun-pass%2Fmacro-with-attrs2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-with-attrs2.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -11,10 +11,10 @@\n #![feature(macro_rules)]\n \n #[cfg(foo)]\n-macro_rules! foo( () => (1i) )\n+macro_rules! foo( () => (1i) );\n \n #[cfg(not(foo))]\n-macro_rules! foo( () => (2i) )\n+macro_rules! foo( () => (2i) );\n \n pub fn main() {\n     assert_eq!(foo!(), 2i);"}, {"sha": "024dc4c03e1b706bbdf29accdfb8fdf95a725c5a", "filename": "src/test/run-pass/macro-with-braces-in-expr-position.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Frun-pass%2Fmacro-with-braces-in-expr-position.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Frun-pass%2Fmacro-with-braces-in-expr-position.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-with-braces-in-expr-position.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -10,7 +10,7 @@\n \n #![feature(macro_rules)]\n \n-macro_rules! expr (($e: expr) => { $e })\n+macro_rules! expr (($e: expr) => { $e });\n \n macro_rules! spawn {\n     ($($code: tt)*) => {"}, {"sha": "a776999ec8a0010483076ec3283202eae7d579d5", "filename": "src/test/run-pass/match-in-macro.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Frun-pass%2Fmatch-in-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Frun-pass%2Fmatch-in-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmatch-in-macro.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -20,7 +20,7 @@ macro_rules! match_inside_expansion(\n             Foo::B { b1:b2 , bb1:bb2 } => b2+bb2\n         }\n     )\n-)\n+);\n \n pub fn main() {\n     assert_eq!(match_inside_expansion!(),129);"}, {"sha": "9151564b3407be7afa65f964562ccf51d1b57080", "filename": "src/test/run-pass/non-built-in-quote.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Frun-pass%2Fnon-built-in-quote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Frun-pass%2Fnon-built-in-quote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnon-built-in-quote.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -10,7 +10,7 @@\n \n #![feature(macro_rules)]\n \n-macro_rules! quote_tokens ( () => (()) )\n+macro_rules! quote_tokens ( () => (()) );\n \n pub fn main() {\n     quote_tokens!();"}, {"sha": "c0359a3418698d8f9954d71d240a4490798d622d", "filename": "src/test/run-pass/overloaded-index-assoc-list.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Frun-pass%2Foverloaded-index-assoc-list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Frun-pass%2Foverloaded-index-assoc-list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foverloaded-index-assoc-list.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -47,9 +47,9 @@ pub fn main() {\n     list.push(foo.clone(), 22i);\n     list.push(bar.clone(), 44i);\n \n-    assert!(list[foo] == 22)\n-    assert!(list[bar] == 44)\n+    assert!(list[foo] == 22);\n+    assert!(list[bar] == 44);\n \n-    assert!(list[foo] == 22)\n-    assert!(list[bar] == 44)\n+    assert!(list[foo] == 22);\n+    assert!(list[bar] == 44);\n }"}, {"sha": "f03b4609637a9998424060b9f9a8992bdc44bdcc", "filename": "src/test/run-pass/slice-2.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Frun-pass%2Fslice-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Frun-pass%2Fslice-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fslice-2.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -15,57 +15,57 @@\n fn main() {\n     let x: &[int] = &[1, 2, 3, 4, 5];\n     let cmp: &[int] = &[1, 2, 3, 4, 5];\n-    assert!(x[] == cmp)\n+    assert!(x[] == cmp);\n     let cmp: &[int] = &[3, 4, 5];\n-    assert!(x[2..] == cmp)\n+    assert!(x[2..] == cmp);\n     let cmp: &[int] = &[1, 2, 3];\n-    assert!(x[..3] == cmp)\n+    assert!(x[..3] == cmp);\n     let cmp: &[int] = &[2, 3, 4];\n-    assert!(x[1..4] == cmp)\n+    assert!(x[1..4] == cmp);\n \n     let x: Vec<int> = vec![1, 2, 3, 4, 5];\n     let cmp: &[int] = &[1, 2, 3, 4, 5];\n-    assert!(x[] == cmp)\n+    assert!(x[] == cmp);\n     let cmp: &[int] = &[3, 4, 5];\n-    assert!(x[2..] == cmp)\n+    assert!(x[2..] == cmp);\n     let cmp: &[int] = &[1, 2, 3];\n-    assert!(x[..3] == cmp)\n+    assert!(x[..3] == cmp);\n     let cmp: &[int] = &[2, 3, 4];\n-    assert!(x[1..4] == cmp)\n+    assert!(x[1..4] == cmp);\n \n     let x: &mut [int] = &mut [1, 2, 3, 4, 5];\n     {\n         let cmp: &mut [int] = &mut [1, 2, 3, 4, 5];\n-        assert!(x[mut] == cmp)\n+        assert!(x[mut] == cmp);\n     }\n     {\n         let cmp: &mut [int] = &mut [3, 4, 5];\n-        assert!(x[mut 2..] == cmp)\n+        assert!(x[mut 2..] == cmp);\n     }\n     {\n         let cmp: &mut [int] = &mut [1, 2, 3];\n-        assert!(x[mut ..3] == cmp)\n+        assert!(x[mut ..3] == cmp);\n     }\n     {\n         let cmp: &mut [int] = &mut [2, 3, 4];\n-        assert!(x[mut 1..4] == cmp)\n+        assert!(x[mut 1..4] == cmp);\n     }\n \n     let mut x: Vec<int> = vec![1, 2, 3, 4, 5];\n     {\n         let cmp: &mut [int] = &mut [1, 2, 3, 4, 5];\n-        assert!(x[mut] == cmp)\n+        assert!(x[mut] == cmp);\n     }\n     {\n         let cmp: &mut [int] = &mut [3, 4, 5];\n-        assert!(x[mut 2..] == cmp)\n+        assert!(x[mut 2..] == cmp);\n     }\n     {\n         let cmp: &mut [int] = &mut [1, 2, 3];\n-        assert!(x[mut ..3] == cmp)\n+        assert!(x[mut ..3] == cmp);\n     }\n     {\n         let cmp: &mut [int] = &mut [2, 3, 4];\n-        assert!(x[mut 1..4] == cmp)\n+        assert!(x[mut 1..4] == cmp);\n     }\n }"}, {"sha": "104a47e1afe17634986386b49bb1eb38b5eef62d", "filename": "src/test/run-pass/syntax-extension-source-utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Frun-pass%2Fsyntax-extension-source-utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Frun-pass%2Fsyntax-extension-source-utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsyntax-extension-source-utils.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -21,7 +21,7 @@ pub mod m1 {\n     }\n }\n \n-macro_rules! indirect_line( () => ( line!() ) )\n+macro_rules! indirect_line( () => ( line!() ) );\n \n pub fn main() {\n     assert_eq!(line!(), 27);"}, {"sha": "4dec227d52020aa44bdaa6150bb1a2d157947c3e", "filename": "src/test/run-pass/typeck-macro-interaction-issue-8852.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Frun-pass%2Ftypeck-macro-interaction-issue-8852.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Frun-pass%2Ftypeck-macro-interaction-issue-8852.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftypeck-macro-interaction-issue-8852.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -30,9 +30,9 @@ macro_rules! test(\n             }\n         }\n     )\n-)\n+);\n \n-test!(x,y,x + y)\n+test!(x,y,x + y);\n \n pub fn main() {\n     foo(T::A(1), T::A(2));"}, {"sha": "2c784dade571121a0049e2afee5dbab80c541d96", "filename": "src/test/run-pass/vec-macro-with-brackets.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Frun-pass%2Fvec-macro-with-brackets.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddb2466f6a1bb66f22824334022a4cee61c73bdc/src%2Ftest%2Frun-pass%2Fvec-macro-with-brackets.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-macro-with-brackets.rs?ref=ddb2466f6a1bb66f22824334022a4cee61c73bdc", "patch": "@@ -16,7 +16,7 @@ macro_rules! vec [\n         $(_temp.push($e);)*\n         _temp\n     })\n-]\n+];\n \n pub fn main() {\n     let my_vec = vec![1i, 2, 3, 4, 5];"}]}