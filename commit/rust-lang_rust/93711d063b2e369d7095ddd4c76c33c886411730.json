{"sha": "93711d063b2e369d7095ddd4c76c33c886411730", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkzNzExZDA2M2IyZTM2OWQ3MDk1ZGRkNGM3NmMzM2M4ODY0MTE3MzA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-02-20T12:06:12Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-02-20T12:06:12Z"}, "message": "Auto merge of #69309 - Dylan-DPC:rollup-gjdqx7l, r=Dylan-DPC\n\nRollup of 5 pull requests\n\nSuccessful merges:\n\n - #68705 (Add LinkedList::remove())\n - #68945 (Stabilize Once::is_completed)\n - #68978 (Make integer exponentiation methods unstably const)\n - #69266 (Fix race condition when allocating source files in SourceMap)\n - #69287 (Clean up E0317 explanation)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "c4a2877b4ed7089b964f12dd16d2ffb618502706", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c4a2877b4ed7089b964f12dd16d2ffb618502706"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/93711d063b2e369d7095ddd4c76c33c886411730", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/93711d063b2e369d7095ddd4c76c33c886411730", "html_url": "https://github.com/rust-lang/rust/commit/93711d063b2e369d7095ddd4c76c33c886411730", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/93711d063b2e369d7095ddd4c76c33c886411730/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6af388b25050bca26710be7e4030e17bf6d8d2f7", "url": "https://api.github.com/repos/rust-lang/rust/commits/6af388b25050bca26710be7e4030e17bf6d8d2f7", "html_url": "https://github.com/rust-lang/rust/commit/6af388b25050bca26710be7e4030e17bf6d8d2f7"}, {"sha": "941ce1a557639e23ccb8cf2610aa8341190dbdfa", "url": "https://api.github.com/repos/rust-lang/rust/commits/941ce1a557639e23ccb8cf2610aa8341190dbdfa", "html_url": "https://github.com/rust-lang/rust/commit/941ce1a557639e23ccb8cf2610aa8341190dbdfa"}], "stats": {"total": 262, "additions": 207, "deletions": 55}, "files": [{"sha": "f8f987efeb891b434f4e72629d86ebfd0430628a", "filename": "src/liballoc/collections/linked_list.rs", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/93711d063b2e369d7095ddd4c76c33c886411730/src%2Fliballoc%2Fcollections%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93711d063b2e369d7095ddd4c76c33c886411730/src%2Fliballoc%2Fcollections%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Flinked_list.rs?ref=93711d063b2e369d7095ddd4c76c33c886411730", "patch": "@@ -878,6 +878,52 @@ impl<T> LinkedList<T> {\n         unsafe { self.split_off_after_node(split_node, at) }\n     }\n \n+    /// Removes the element at the given index and returns it.\n+    ///\n+    /// This operation should compute in O(n) time.\n+    ///\n+    /// # Panics\n+    /// Panics if at >= len\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(linked_list_remove)]\n+    /// use std::collections::LinkedList;\n+    ///\n+    /// let mut d = LinkedList::new();\n+    ///\n+    /// d.push_front(1);\n+    /// d.push_front(2);\n+    /// d.push_front(3);\n+    ///\n+    /// assert_eq!(d.remove(1), 2);\n+    /// assert_eq!(d.remove(0), 3);\n+    /// assert_eq!(d.remove(0), 1);\n+    /// ```\n+    #[unstable(feature = \"linked_list_remove\", issue = \"69210\")]\n+    pub fn remove(&mut self, at: usize) -> T {\n+        let len = self.len();\n+        assert!(at < len, \"Cannot remove at an index outside of the list bounds\");\n+\n+        // Below, we iterate towards the node at the given index, either from\n+        // the start or the end, depending on which would be faster.\n+        let offset_from_end = len - at - 1;\n+        if at <= offset_from_end {\n+            let mut cursor = self.cursor_front_mut();\n+            for _ in 0..at {\n+                cursor.move_next();\n+            }\n+            cursor.remove_current().unwrap()\n+        } else {\n+            let mut cursor = self.cursor_back_mut();\n+            for _ in 0..offset_from_end {\n+                cursor.move_prev();\n+            }\n+            cursor.remove_current().unwrap()\n+        }\n+    }\n+\n     /// Creates an iterator which uses a closure to determine if an element should be removed.\n     ///\n     /// If the closure returns true, then the element is removed and yielded."}, {"sha": "bca96b77812c8444f9edce511a8946252736df4f", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/93711d063b2e369d7095ddd4c76c33c886411730/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93711d063b2e369d7095ddd4c76c33c886411730/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=93711d063b2e369d7095ddd4c76c33c886411730", "patch": "@@ -73,11 +73,14 @@\n #![feature(const_ascii_ctype_on_intrinsics)]\n #![feature(const_alloc_layout)]\n #![feature(const_if_match)]\n+#![feature(const_loop)]\n #![feature(const_checked_int_methods)]\n #![feature(const_euclidean_int_methods)]\n #![feature(const_overflowing_int_methods)]\n #![feature(const_saturating_int_methods)]\n #![feature(const_int_unchecked_arith)]\n+#![feature(const_int_pow)]\n+#![feature(constctlz)]\n #![feature(const_panic)]\n #![feature(const_fn_union)]\n #![feature(const_generics)]"}, {"sha": "6f55e7c8be8ca539a3a100dbb396319f39efcf5b", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 46, "deletions": 23, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/93711d063b2e369d7095ddd4c76c33c886411730/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93711d063b2e369d7095ddd4c76c33c886411730/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=93711d063b2e369d7095ddd4c76c33c886411730", "patch": "@@ -8,9 +8,18 @@ use crate::convert::Infallible;\n use crate::fmt;\n use crate::intrinsics;\n use crate::mem;\n-use crate::ops;\n use crate::str::FromStr;\n \n+// Used because the `?` operator is not allowed in a const context.\n+macro_rules! try_opt {\n+    ($e:expr) => {\n+        match $e {\n+            Some(x) => x,\n+            None => return None,\n+        }\n+    };\n+}\n+\n macro_rules! impl_nonzero_fmt {\n     ( #[$stability: meta] ( $( $Trait: ident ),+ ) for $Ty: ident ) => {\n         $(\n@@ -993,26 +1002,27 @@ $EndFeature, \"\n ```\"),\n \n             #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n+            #[rustc_const_unstable(feature = \"const_int_pow\", issue = \"53718\")]\n             #[must_use = \"this returns the result of the operation, \\\n                           without modifying the original\"]\n             #[inline]\n-            pub fn checked_pow(self, mut exp: u32) -> Option<Self> {\n+            pub const fn checked_pow(self, mut exp: u32) -> Option<Self> {\n                 let mut base = self;\n                 let mut acc: Self = 1;\n \n                 while exp > 1 {\n                     if (exp & 1) == 1 {\n-                        acc = acc.checked_mul(base)?;\n+                        acc = try_opt!(acc.checked_mul(base));\n                     }\n                     exp /= 2;\n-                    base = base.checked_mul(base)?;\n+                    base = try_opt!(base.checked_mul(base));\n                 }\n \n                 // Deal with the final bit of the exponent separately, since\n                 // squaring the base afterwards is not necessary and may cause a\n                 // needless overflow.\n                 if exp == 1 {\n-                    acc = acc.checked_mul(base)?;\n+                    acc = try_opt!(acc.checked_mul(base));\n                 }\n \n                 Some(acc)\n@@ -1180,10 +1190,11 @@ assert_eq!(\", stringify!($SelfT), \"::MIN.saturating_pow(3), \", stringify!($SelfT\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n+            #[rustc_const_unstable(feature = \"const_int_pow\", issue = \"53718\")]\n             #[must_use = \"this returns the result of the operation, \\\n                           without modifying the original\"]\n             #[inline]\n-            pub fn saturating_pow(self, exp: u32) -> Self {\n+            pub const fn saturating_pow(self, exp: u32) -> Self {\n                 match self.checked_pow(exp) {\n                     Some(x) => x,\n                     None if self < 0 && exp % 2 == 1 => Self::min_value(),\n@@ -1523,10 +1534,11 @@ assert_eq!(3i8.wrapping_pow(6), -39);\",\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n+            #[rustc_const_unstable(feature = \"const_int_pow\", issue = \"53718\")]\n             #[must_use = \"this returns the result of the operation, \\\n                           without modifying the original\"]\n             #[inline]\n-            pub fn wrapping_pow(self, mut exp: u32) -> Self {\n+            pub const fn wrapping_pow(self, mut exp: u32) -> Self {\n                 let mut base = self;\n                 let mut acc: Self = 1;\n \n@@ -1900,10 +1912,11 @@ assert_eq!(3i8.overflowing_pow(5), (-13, true));\",\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n+            #[rustc_const_unstable(feature = \"const_int_pow\", issue = \"53718\")]\n             #[must_use = \"this returns the result of the operation, \\\n                           without modifying the original\"]\n             #[inline]\n-            pub fn overflowing_pow(self, mut exp: u32) -> (Self, bool) {\n+            pub const fn overflowing_pow(self, mut exp: u32) -> (Self, bool) {\n                 let mut base = self;\n                 let mut acc: Self = 1;\n                 let mut overflown = false;\n@@ -1949,11 +1962,12 @@ assert_eq!(x.pow(5), 32);\",\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[rustc_const_unstable(feature = \"const_int_pow\", issue = \"53718\")]\n             #[must_use = \"this returns the result of the operation, \\\n                           without modifying the original\"]\n             #[inline]\n             #[rustc_inherit_overflow_checks]\n-            pub fn pow(self, mut exp: u32) -> Self {\n+            pub const fn pow(self, mut exp: u32) -> Self {\n                 let mut base = self;\n                 let mut acc = 1;\n \n@@ -3119,26 +3133,27 @@ Basic usage:\n assert_eq!(\", stringify!($SelfT), \"::max_value().checked_pow(2), None);\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n+            #[rustc_const_unstable(feature = \"const_int_pow\", issue = \"53718\")]\n             #[must_use = \"this returns the result of the operation, \\\n                           without modifying the original\"]\n             #[inline]\n-            pub fn checked_pow(self, mut exp: u32) -> Option<Self> {\n+            pub const fn checked_pow(self, mut exp: u32) -> Option<Self> {\n                 let mut base = self;\n                 let mut acc: Self = 1;\n \n                 while exp > 1 {\n                     if (exp & 1) == 1 {\n-                        acc = acc.checked_mul(base)?;\n+                        acc = try_opt!(acc.checked_mul(base));\n                     }\n                     exp /= 2;\n-                    base = base.checked_mul(base)?;\n+                    base = try_opt!(base.checked_mul(base));\n                 }\n \n                 // Deal with the final bit of the exponent separately, since\n                 // squaring the base afterwards is not necessary and may cause a\n                 // needless overflow.\n                 if exp == 1 {\n-                    acc = acc.checked_mul(base)?;\n+                    acc = try_opt!(acc.checked_mul(base));\n                 }\n \n                 Some(acc)\n@@ -3234,10 +3249,11 @@ assert_eq!(\", stringify!($SelfT), \"::MAX.saturating_pow(2), \", stringify!($SelfT\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n+            #[rustc_const_unstable(feature = \"const_int_pow\", issue = \"53718\")]\n             #[must_use = \"this returns the result of the operation, \\\n                           without modifying the original\"]\n             #[inline]\n-            pub fn saturating_pow(self, exp: u32) -> Self {\n+            pub const fn saturating_pow(self, exp: u32) -> Self {\n                 match self.checked_pow(exp) {\n                     Some(x) => x,\n                     None => Self::max_value(),\n@@ -3527,10 +3543,11 @@ Basic usage:\n assert_eq!(3u8.wrapping_pow(6), 217);\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n+            #[rustc_const_unstable(feature = \"const_int_pow\", issue = \"53718\")]\n             #[must_use = \"this returns the result of the operation, \\\n                           without modifying the original\"]\n             #[inline]\n-            pub fn wrapping_pow(self, mut exp: u32) -> Self {\n+            pub const fn wrapping_pow(self, mut exp: u32) -> Self {\n                 let mut base = self;\n                 let mut acc: Self = 1;\n \n@@ -3853,10 +3870,11 @@ Basic usage:\n assert_eq!(3u8.overflowing_pow(6), (217, true));\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n+            #[rustc_const_unstable(feature = \"const_int_pow\", issue = \"53718\")]\n             #[must_use = \"this returns the result of the operation, \\\n                           without modifying the original\"]\n             #[inline]\n-            pub fn overflowing_pow(self, mut exp: u32) -> (Self, bool) {\n+            pub const fn overflowing_pow(self, mut exp: u32) -> (Self, bool) {\n                 let mut base = self;\n                 let mut acc: Self = 1;\n                 let mut overflown = false;\n@@ -3899,11 +3917,12 @@ Basic usage:\n \", $Feature, \"assert_eq!(2\", stringify!($SelfT), \".pow(5), 32);\", $EndFeature, \"\n ```\"),\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        #[rustc_const_unstable(feature = \"const_int_pow\", issue = \"53718\")]\n         #[must_use = \"this returns the result of the operation, \\\n                           without modifying the original\"]\n         #[inline]\n         #[rustc_inherit_overflow_checks]\n-        pub fn pow(self, mut exp: u32) -> Self {\n+        pub const fn pow(self, mut exp: u32) -> Self {\n             let mut base = self;\n             let mut acc = 1;\n \n@@ -4014,7 +4033,8 @@ assert!(!10\", stringify!($SelfT), \".is_power_of_two());\", $EndFeature, \"\n         // overflow cases it instead ends up returning the maximum value\n         // of the type, and can return 0 for 0.\n         #[inline]\n-        fn one_less_than_next_power_of_two(self) -> Self {\n+        #[rustc_const_unstable(feature = \"const_int_pow\", issue = \"53718\")]\n+        const fn one_less_than_next_power_of_two(self) -> Self {\n             if self <= 1 { return 0; }\n \n             let p = self - 1;\n@@ -4042,10 +4062,11 @@ Basic usage:\n assert_eq!(3\", stringify!($SelfT), \".next_power_of_two(), 4);\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[rustc_const_unstable(feature = \"const_int_pow\", issue = \"53718\")]\n             #[inline]\n-            pub fn next_power_of_two(self) -> Self {\n-                // Call the trait to get overflow checks\n-                ops::Add::add(self.one_less_than_next_power_of_two(), 1)\n+            #[rustc_inherit_overflow_checks]\n+            pub const fn next_power_of_two(self) -> Self {\n+                self.one_less_than_next_power_of_two() + 1\n             }\n         }\n \n@@ -4067,7 +4088,8 @@ $EndFeature, \"\n ```\"),\n             #[inline]\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-            pub fn checked_next_power_of_two(self) -> Option<Self> {\n+            #[rustc_const_unstable(feature = \"const_int_pow\", issue = \"53718\")]\n+            pub const fn checked_next_power_of_two(self) -> Option<Self> {\n                 self.one_less_than_next_power_of_two().checked_add(1)\n             }\n         }\n@@ -4091,7 +4113,8 @@ $EndFeature, \"\n ```\"),\n             #[unstable(feature = \"wrapping_next_power_of_two\", issue = \"32463\",\n                        reason = \"needs decision on wrapping behaviour\")]\n-            pub fn wrapping_next_power_of_two(self) -> Self {\n+            #[rustc_const_unstable(feature = \"const_int_pow\", issue = \"53718\")]\n+            pub const fn wrapping_next_power_of_two(self) -> Self {\n                 self.one_less_than_next_power_of_two().wrapping_add(1)\n             }\n         }"}, {"sha": "230911c208628fcd79616a094481721f61d54aee", "filename": "src/librustc_error_codes/error_codes/E0317.md", "status": "modified", "additions": 23, "deletions": 7, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/93711d063b2e369d7095ddd4c76c33c886411730/src%2Flibrustc_error_codes%2Ferror_codes%2FE0317.md", "raw_url": "https://github.com/rust-lang/rust/raw/93711d063b2e369d7095ddd4c76c33c886411730/src%2Flibrustc_error_codes%2Ferror_codes%2FE0317.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0317.md?ref=93711d063b2e369d7095ddd4c76c33c886411730", "patch": "@@ -1,14 +1,30 @@\n-This error occurs when an `if` expression without an `else` block is used in a\n-context where a type other than `()` is expected, for example a `let`\n-expression:\n+An `if` expression is missing an `else` block.\n+\n+Erroneous code example:\n \n ```compile_fail,E0317\n-fn main() {\n-    let x = 5;\n-    let a = if x == 5 { 1 };\n-}\n+let x = 5;\n+let a = if x == 5 {\n+    1\n+};\n ```\n \n+This error occurs when an `if` expression without an `else` block is used in a\n+context where a type other than `()` is expected. In the previous code example,\n+the `let` expression was expecting a value but since there was no `else`, no\n+value was returned.\n+\n An `if` expression without an `else` block has the type `()`, so this is a type\n error. To resolve it, add an `else` block having the same type as the `if`\n block.\n+\n+So to fix the previous code example:\n+\n+```\n+let x = 5;\n+let a = if x == 5 {\n+    1\n+} else {\n+    2\n+};\n+```"}, {"sha": "f9f3a9003117ff6113994ee2cb64e8ceac32270d", "filename": "src/librustc_span/lib.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/93711d063b2e369d7095ddd4c76c33c886411730/src%2Flibrustc_span%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93711d063b2e369d7095ddd4c76c33c886411730/src%2Flibrustc_span%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Flib.rs?ref=93711d063b2e369d7095ddd4c76c33c886411730", "patch": "@@ -1075,7 +1075,7 @@ impl SourceFile {\n         unmapped_path: FileName,\n         mut src: String,\n         start_pos: BytePos,\n-    ) -> Result<SourceFile, OffsetOverflowError> {\n+    ) -> Self {\n         let normalized_pos = normalize_src(&mut src, start_pos);\n \n         let src_hash = {\n@@ -1089,14 +1089,12 @@ impl SourceFile {\n             hasher.finish::<u128>()\n         };\n         let end_pos = start_pos.to_usize() + src.len();\n-        if end_pos > u32::max_value() as usize {\n-            return Err(OffsetOverflowError);\n-        }\n+        assert!(end_pos <= u32::max_value() as usize);\n \n         let (lines, multibyte_chars, non_narrow_chars) =\n             analyze_source_file::analyze_source_file(&src[..], start_pos);\n \n-        Ok(SourceFile {\n+        SourceFile {\n             name,\n             name_was_remapped,\n             unmapped_path: Some(unmapped_path),\n@@ -1111,7 +1109,7 @@ impl SourceFile {\n             non_narrow_chars,\n             normalized_pos,\n             name_hash,\n-        })\n+        }\n     }\n \n     /// Returns the `BytePos` of the beginning of the current line."}, {"sha": "31d397f040cb0cd6fc94635cc55a7bf585d68677", "filename": "src/librustc_span/source_map.rs", "status": "modified", "additions": 43, "deletions": 13, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/93711d063b2e369d7095ddd4c76c33c886411730/src%2Flibrustc_span%2Fsource_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93711d063b2e369d7095ddd4c76c33c886411730/src%2Flibrustc_span%2Fsource_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Fsource_map.rs?ref=93711d063b2e369d7095ddd4c76c33c886411730", "patch": "@@ -12,10 +12,12 @@ pub use crate::*;\n \n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::stable_hasher::StableHasher;\n-use rustc_data_structures::sync::{Lock, LockGuard, Lrc, MappedLockGuard};\n+use rustc_data_structures::sync::{AtomicU32, Lock, LockGuard, Lrc, MappedLockGuard};\n use std::cmp;\n+use std::convert::TryFrom;\n use std::hash::Hash;\n use std::path::{Path, PathBuf};\n+use std::sync::atomic::Ordering;\n \n use log::debug;\n use std::env;\n@@ -131,6 +133,9 @@ pub(super) struct SourceMapFiles {\n }\n \n pub struct SourceMap {\n+    /// The address space below this value is currently used by the files in the source map.\n+    used_address_space: AtomicU32,\n+\n     files: Lock<SourceMapFiles>,\n     file_loader: Box<dyn FileLoader + Sync + Send>,\n     // This is used to apply the file path remapping as specified via\n@@ -140,14 +145,24 @@ pub struct SourceMap {\n \n impl SourceMap {\n     pub fn new(path_mapping: FilePathMapping) -> SourceMap {\n-        SourceMap { files: Default::default(), file_loader: Box::new(RealFileLoader), path_mapping }\n+        SourceMap {\n+            used_address_space: AtomicU32::new(0),\n+            files: Default::default(),\n+            file_loader: Box::new(RealFileLoader),\n+            path_mapping,\n+        }\n     }\n \n     pub fn with_file_loader(\n         file_loader: Box<dyn FileLoader + Sync + Send>,\n         path_mapping: FilePathMapping,\n     ) -> SourceMap {\n-        SourceMap { files: Default::default(), file_loader, path_mapping }\n+        SourceMap {\n+            used_address_space: AtomicU32::new(0),\n+            files: Default::default(),\n+            file_loader,\n+            path_mapping,\n+        }\n     }\n \n     pub fn path_mapping(&self) -> &FilePathMapping {\n@@ -194,12 +209,25 @@ impl SourceMap {\n         self.files.borrow().stable_id_to_source_file.get(&stable_id).map(|sf| sf.clone())\n     }\n \n-    fn next_start_pos(&self) -> usize {\n-        match self.files.borrow().source_files.last() {\n-            None => 0,\n-            // Add one so there is some space between files. This lets us distinguish\n-            // positions in the `SourceMap`, even in the presence of zero-length files.\n-            Some(last) => last.end_pos.to_usize() + 1,\n+    fn allocate_address_space(&self, size: usize) -> Result<usize, OffsetOverflowError> {\n+        let size = u32::try_from(size).map_err(|_| OffsetOverflowError)?;\n+\n+        loop {\n+            let current = self.used_address_space.load(Ordering::Relaxed);\n+            let next = current\n+                .checked_add(size)\n+                // Add one so there is some space between files. This lets us distinguish\n+                // positions in the `SourceMap`, even in the presence of zero-length files.\n+                .and_then(|next| next.checked_add(1))\n+                .ok_or(OffsetOverflowError)?;\n+\n+            if self\n+                .used_address_space\n+                .compare_exchange(current, next, Ordering::Relaxed, Ordering::Relaxed)\n+                .is_ok()\n+            {\n+                return Ok(usize::try_from(current).unwrap());\n+            }\n         }\n     }\n \n@@ -218,8 +246,6 @@ impl SourceMap {\n         filename: FileName,\n         src: String,\n     ) -> Result<Lrc<SourceFile>, OffsetOverflowError> {\n-        let start_pos = self.next_start_pos();\n-\n         // The path is used to determine the directory for loading submodules and\n         // include files, so it must be before remapping.\n         // Note that filename may not be a valid path, eg it may be `<anon>` etc,\n@@ -241,13 +267,15 @@ impl SourceMap {\n         let lrc_sf = match self.source_file_by_stable_id(file_id) {\n             Some(lrc_sf) => lrc_sf,\n             None => {\n+                let start_pos = self.allocate_address_space(src.len())?;\n+\n                 let source_file = Lrc::new(SourceFile::new(\n                     filename,\n                     was_remapped,\n                     unmapped_path,\n                     src,\n                     Pos::from_usize(start_pos),\n-                )?);\n+                ));\n \n                 let mut files = self.files.borrow_mut();\n \n@@ -277,7 +305,9 @@ impl SourceMap {\n         mut file_local_non_narrow_chars: Vec<NonNarrowChar>,\n         mut file_local_normalized_pos: Vec<NormalizedPos>,\n     ) -> Lrc<SourceFile> {\n-        let start_pos = self.next_start_pos();\n+        let start_pos = self\n+            .allocate_address_space(source_len)\n+            .expect(\"not enough address space for imported source file\");\n \n         let end_pos = Pos::from_usize(start_pos + source_len);\n         let start_pos = Pos::from_usize(start_pos);"}, {"sha": "b99b4d8d9fdf012bb15caa6138e836176113a543", "filename": "src/libstd/sync/once.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/93711d063b2e369d7095ddd4c76c33c886411730/src%2Flibstd%2Fsync%2Fonce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93711d063b2e369d7095ddd4c76c33c886411730/src%2Flibstd%2Fsync%2Fonce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fonce.rs?ref=93711d063b2e369d7095ddd4c76c33c886411730", "patch": "@@ -331,14 +331,14 @@ impl Once {\n     ///   * `call_once` was called, but has not yet completed,\n     ///   * the `Once` instance is poisoned\n     ///\n-    /// It is also possible that immediately after `is_completed`\n-    /// returns false, some other thread finishes executing\n-    /// `call_once`.\n+    /// This function returning `false` does not mean that `Once` has not been\n+    /// executed. For example, it may have been executed in the time between\n+    /// when `is_completed` starts executing and when it returns, in which case\n+    /// the `false` return value would be stale (but still permissible).\n     ///\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(once_is_completed)]\n     /// use std::sync::Once;\n     ///\n     /// static INIT: Once = Once::new();\n@@ -351,7 +351,6 @@ impl Once {\n     /// ```\n     ///\n     /// ```\n-    /// #![feature(once_is_completed)]\n     /// use std::sync::Once;\n     /// use std::thread;\n     ///\n@@ -364,7 +363,7 @@ impl Once {\n     /// assert!(handle.join().is_err());\n     /// assert_eq!(INIT.is_completed(), false);\n     /// ```\n-    #[unstable(feature = \"once_is_completed\", issue = \"54890\")]\n+    #[stable(feature = \"once_is_completed\", since = \"1.44.0\")]\n     #[inline]\n     pub fn is_completed(&self) -> bool {\n         // An `Acquire` load is enough because that makes all the initialization"}, {"sha": "b0fba19455ba87ed231b0dbb70b677a6b9fff944", "filename": "src/test/ui/consts/const-int-pow-rpass.rs", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/93711d063b2e369d7095ddd4c76c33c886411730/src%2Ftest%2Fui%2Fconsts%2Fconst-int-pow-rpass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93711d063b2e369d7095ddd4c76c33c886411730/src%2Ftest%2Fui%2Fconsts%2Fconst-int-pow-rpass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-int-pow-rpass.rs?ref=93711d063b2e369d7095ddd4c76c33c886411730", "patch": "@@ -1,11 +1,48 @@\n // run-pass\n \n+#![feature(const_int_pow)]\n+#![feature(wrapping_next_power_of_two)]\n+\n const IS_POWER_OF_TWO_A: bool = 0u32.is_power_of_two();\n const IS_POWER_OF_TWO_B: bool = 32u32.is_power_of_two();\n const IS_POWER_OF_TWO_C: bool = 33u32.is_power_of_two();\n \n+const POW: u8 = 3u8.pow(5);\n+\n+const CHECKED_POW_OK: Option<u8> = 3u8.checked_pow(5);\n+const CHECKED_POW_OVERFLOW: Option<u8> = 3u8.checked_pow(6);\n+\n+const WRAPPING_POW: u8 = 3u8.wrapping_pow(6);\n+const OVERFLOWING_POW: (u8, bool) = 3u8.overflowing_pow(6);\n+const SATURATING_POW: u8 = 3u8.saturating_pow(6);\n+\n+const NEXT_POWER_OF_TWO: u32 = 3u32.next_power_of_two();\n+\n+const CHECKED_NEXT_POWER_OF_TWO_OK: Option<u32> = 3u32.checked_next_power_of_two();\n+const CHECKED_NEXT_POWER_OF_TWO_OVERFLOW: Option<u32> =\n+    u32::max_value().checked_next_power_of_two();\n+\n+const WRAPPING_NEXT_POWER_OF_TWO: u32 =\n+    u32::max_value().wrapping_next_power_of_two();\n+\n fn main() {\n     assert!(!IS_POWER_OF_TWO_A);\n     assert!(IS_POWER_OF_TWO_B);\n     assert!(!IS_POWER_OF_TWO_C);\n+\n+    assert_eq!(POW, 243);\n+\n+    assert_eq!(CHECKED_POW_OK, Some(243));\n+    assert_eq!(CHECKED_POW_OVERFLOW, None);\n+\n+    assert_eq!(WRAPPING_POW, 217);\n+    assert_eq!(OVERFLOWING_POW, (217, true));\n+    assert_eq!(SATURATING_POW, u8::max_value());\n+\n+    assert_eq!(NEXT_POWER_OF_TWO, 4);\n+\n+    assert_eq!(CHECKED_NEXT_POWER_OF_TWO_OK, Some(4));\n+    assert_eq!(CHECKED_NEXT_POWER_OF_TWO_OVERFLOW, None);\n+\n+    assert_eq!(WRAPPING_NEXT_POWER_OF_TWO, 0);\n }"}]}