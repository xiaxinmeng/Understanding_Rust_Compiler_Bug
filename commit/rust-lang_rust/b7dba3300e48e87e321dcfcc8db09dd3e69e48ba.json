{"sha": "b7dba3300e48e87e321dcfcc8db09dd3e69e48ba", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI3ZGJhMzMwMGU0OGU4N2UzMjFkY2ZjYzhkYjA5ZGQzZTY5ZTQ4YmE=", "commit": {"author": {"name": "Adrien T\u00e9tar", "email": "adri-from-59@hotmail.fr", "date": "2014-04-27T02:56:29Z"}, "committer": {"name": "Adrien T\u00e9tar", "email": "adri-from-59@hotmail.fr", "date": "2014-04-27T02:56:29Z"}, "message": "doc: perform some 80-chars wrappings", "tree": {"sha": "60c3de4af260f73e9dd762977949896d6648e314", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/60c3de4af260f73e9dd762977949896d6648e314"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b7dba3300e48e87e321dcfcc8db09dd3e69e48ba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b7dba3300e48e87e321dcfcc8db09dd3e69e48ba", "html_url": "https://github.com/rust-lang/rust/commit/b7dba3300e48e87e321dcfcc8db09dd3e69e48ba", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b7dba3300e48e87e321dcfcc8db09dd3e69e48ba/comments", "author": {"login": "adrientetar", "id": 1250894, "node_id": "MDQ6VXNlcjEyNTA4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1250894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/adrientetar", "html_url": "https://github.com/adrientetar", "followers_url": "https://api.github.com/users/adrientetar/followers", "following_url": "https://api.github.com/users/adrientetar/following{/other_user}", "gists_url": "https://api.github.com/users/adrientetar/gists{/gist_id}", "starred_url": "https://api.github.com/users/adrientetar/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/adrientetar/subscriptions", "organizations_url": "https://api.github.com/users/adrientetar/orgs", "repos_url": "https://api.github.com/users/adrientetar/repos", "events_url": "https://api.github.com/users/adrientetar/events{/privacy}", "received_events_url": "https://api.github.com/users/adrientetar/received_events", "type": "User", "site_admin": false}, "committer": {"login": "adrientetar", "id": 1250894, "node_id": "MDQ6VXNlcjEyNTA4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1250894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/adrientetar", "html_url": "https://github.com/adrientetar", "followers_url": "https://api.github.com/users/adrientetar/followers", "following_url": "https://api.github.com/users/adrientetar/following{/other_user}", "gists_url": "https://api.github.com/users/adrientetar/gists{/gist_id}", "starred_url": "https://api.github.com/users/adrientetar/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/adrientetar/subscriptions", "organizations_url": "https://api.github.com/users/adrientetar/orgs", "repos_url": "https://api.github.com/users/adrientetar/repos", "events_url": "https://api.github.com/users/adrientetar/events{/privacy}", "received_events_url": "https://api.github.com/users/adrientetar/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "53711461070ec8ad0d71c4bcdb35de3120e07ec5", "url": "https://api.github.com/repos/rust-lang/rust/commits/53711461070ec8ad0d71c4bcdb35de3120e07ec5", "html_url": "https://github.com/rust-lang/rust/commit/53711461070ec8ad0d71c4bcdb35de3120e07ec5"}], "stats": {"total": 24, "additions": 14, "deletions": 10}, "files": [{"sha": "d5fd3d15ba53ae543e639a79eafe1cc804ec29d1", "filename": "src/doc/rust.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7dba3300e48e87e321dcfcc8db09dd3e69e48ba/src%2Fdoc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/b7dba3300e48e87e321dcfcc8db09dd3e69e48ba/src%2Fdoc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frust.md?ref=b7dba3300e48e87e321dcfcc8db09dd3e69e48ba", "patch": "@@ -471,7 +471,7 @@ Two examples of paths with type arguments:\n # fn f() {\n # fn id<T>(t: T) -> T { t }\n type T = HashMap<int,~str>;  // Type arguments used in a type expression\n-let x = id::<int>(10);         // Type arguments used in a call expression\n+let x = id::<int>(10);       // Type arguments used in a call expression\n # }\n ~~~~\n "}, {"sha": "ca636c82521e8721d0269cff34c1697457641c46", "filename": "src/doc/tutorial.md", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b7dba3300e48e87e321dcfcc8db09dd3e69e48ba/src%2Fdoc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/b7dba3300e48e87e321dcfcc8db09dd3e69e48ba/src%2Fdoc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftutorial.md?ref=b7dba3300e48e87e321dcfcc8db09dd3e69e48ba", "patch": "@@ -982,7 +982,8 @@ The obvious approach is to define `Cons` as containing an element in the list\n along with the next `List` node. However, this will generate a compiler error.\n \n ~~~ {.ignore}\n-// error: illegal recursive enum type; wrap the inner value in a box to make it representable\n+// error: illegal recursive enum type; wrap the inner value in a box to make it\n+// representable\n enum List {\n     Cons(u32, List), // an element (`u32`) and the next node in the list\n     Nil\n@@ -1054,10 +1055,10 @@ immutable, the whole list is immutable. The memory allocation itself is the\n box, while the owner holds onto a pointer to it:\n \n ~~~ {.notrust}\n-          List box             List box           List box            List box\n-        +--------------+    +--------------+    +--------------+    +--------------+\n-list -> | Cons | 1 | ~ | -> | Cons | 2 | ~ | -> | Cons | 3 | ~ | -> | Nil          |\n-        +--------------+    +--------------+    +--------------+    +--------------+\n+            List box            List box            List box          List box\n+        +--------------+    +--------------+    +--------------+    +----------+\n+list -> | Cons | 1 | ~ | -> | Cons | 2 | ~ | -> | Cons | 3 | ~ | -> | Nil      |\n+        +--------------+    +--------------+    +--------------+    +----------+\n ~~~\n \n > *Note:* the above diagram shows the logical contents of the enum. The actual\n@@ -1197,7 +1198,8 @@ fn eq(xs: &List, ys: &List) -> bool {\n         // If we have reached the end of both lists, they are equal.\n         (&Nil, &Nil) => true,\n         // If the current element in both lists is equal, keep going.\n-        (&Cons(x, ~ref next_xs), &Cons(y, ~ref next_ys)) if x == y => eq(next_xs, next_ys),\n+        (&Cons(x, ~ref next_xs), &Cons(y, ~ref next_ys))\n+                if x == y => eq(next_xs, next_ys),\n         // If the current elements are not equal, the lists are not equal.\n         _ => false\n     }\n@@ -1256,7 +1258,7 @@ Using the generic `List<T>` works much like before, thanks to type inference:\n #     Cons(value, ~xs)\n # }\n let mut xs = Nil; // Unknown type! This is a `List<T>`, but `T` can be anything.\n-xs = prepend(xs, 10); // The compiler infers the type of `xs` as `List<int>` from this.\n+xs = prepend(xs, 10); // Here the compiler infers `xs`'s type as `List<int>`.\n xs = prepend(xs, 15);\n xs = prepend(xs, 20);\n ~~~\n@@ -1303,7 +1305,8 @@ fn eq<T: Eq>(xs: &List<T>, ys: &List<T>) -> bool {\n         // If we have reached the end of both lists, they are equal.\n         (&Nil, &Nil) => true,\n         // If the current element in both lists is equal, keep going.\n-        (&Cons(ref x, ~ref next_xs), &Cons(ref y, ~ref next_ys)) if x == y => eq(next_xs, next_ys),\n+        (&Cons(ref x, ~ref next_xs), &Cons(ref y, ~ref next_ys))\n+                if x == y => eq(next_xs, next_ys),\n         // If the current elements are not equal, the lists are not equal.\n         _ => false\n     }\n@@ -1331,7 +1334,8 @@ impl<T: Eq> Eq for List<T> {\n             // If we have reached the end of both lists, they are equal.\n             (&Nil, &Nil) => true,\n             // If the current element in both lists is equal, keep going.\n-            (&Cons(ref x, ~ref next_xs), &Cons(ref y, ~ref next_ys)) if x == y => next_xs == next_ys,\n+            (&Cons(ref x, ~ref next_xs), &Cons(ref y, ~ref next_ys))\n+                    if x == y => next_xs == next_ys,\n             // If the current elements are not equal, the lists are not equal.\n             _ => false\n         }"}]}