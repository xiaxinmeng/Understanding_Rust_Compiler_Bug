{"sha": "6b54c9237789c275a82eeb483052b302f490b57c", "node_id": "C_kwDOAAsO6NoAKDZiNTRjOTIzNzc4OWMyNzVhODJlZWI0ODMwNTJiMzAyZjQ5MGI1N2M", "commit": {"author": {"name": "Andy Wang", "email": "cbeuw.andy@gmail.com", "date": "2022-05-16T19:00:11Z"}, "committer": {"name": "Andy Wang", "email": "cbeuw.andy@gmail.com", "date": "2022-06-06T18:15:54Z"}, "message": "Throw UB on imperfectly overlapping access", "tree": {"sha": "dd9947cc2ce68d41b111613cb000f57243d24c82", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dd9947cc2ce68d41b111613cb000f57243d24c82"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6b54c9237789c275a82eeb483052b302f490b57c", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGzBAABCgAdFiEE7dcbcBMl24/h63ldGBtJ+fOPM3QFAmKeRFoACgkQGBtJ+fOP\nM3RJ8wv/VHDiX68k06Bmzd37AY2Sl5QSnT8wTpeccklF5+tHRiu6SSJZF/okLqjC\n5w6EID7isWmvBh+cznHufHtuUc3hSBLNoo1jATPCKitDbKTicPiecpIKpJSyWng2\nnYEsLC+WvpoFry7GMgyRBa5OtSwS8Gr+Xt9Q9/LxRpx5iIXsavS5t7hhDPp4iD8G\nCTLQl0bHJkn0LqEiI4k0iQkijbGbNuUWaget4y/ITSb1FxwnkrggSF2kwaMMgwbN\nPiEQWZAKfcQlAGnZLC0dTD8H332arNLgFPD1RqWCXDxXx2olGSOLGBTtZHKVojFW\nE89P9ekQaPaXwSnfvnv9CdKgfEX4BQ2dwdvQs+iEXRxqP9LTfPluROELzwVoscJY\n3Tso03iXPmLmAhrcspj2LYcycJ+b1Zxzp46GNJbrTLRACFfjWhpHrIr/Ivmpa+Yy\nerRNILGwBKY/kUAvInjjENO0mCbJuOGod8VvAAhD2R2fg4AIJi/HU8LFC6n8n9cA\n8nKt45QZ\n=gEhS\n-----END PGP SIGNATURE-----", "payload": "tree dd9947cc2ce68d41b111613cb000f57243d24c82\nparent 5a4a1bfccc50e0e6c6df98e4b95837de79e01023\nauthor Andy Wang <cbeuw.andy@gmail.com> 1652727611 +0100\ncommitter Andy Wang <cbeuw.andy@gmail.com> 1654539354 +0100\n\nThrow UB on imperfectly overlapping access\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6b54c9237789c275a82eeb483052b302f490b57c", "html_url": "https://github.com/rust-lang/rust/commit/6b54c9237789c275a82eeb483052b302f490b57c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6b54c9237789c275a82eeb483052b302f490b57c/comments", "author": {"login": "cbeuw", "id": 7034308, "node_id": "MDQ6VXNlcjcwMzQzMDg=", "avatar_url": "https://avatars.githubusercontent.com/u/7034308?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cbeuw", "html_url": "https://github.com/cbeuw", "followers_url": "https://api.github.com/users/cbeuw/followers", "following_url": "https://api.github.com/users/cbeuw/following{/other_user}", "gists_url": "https://api.github.com/users/cbeuw/gists{/gist_id}", "starred_url": "https://api.github.com/users/cbeuw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cbeuw/subscriptions", "organizations_url": "https://api.github.com/users/cbeuw/orgs", "repos_url": "https://api.github.com/users/cbeuw/repos", "events_url": "https://api.github.com/users/cbeuw/events{/privacy}", "received_events_url": "https://api.github.com/users/cbeuw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cbeuw", "id": 7034308, "node_id": "MDQ6VXNlcjcwMzQzMDg=", "avatar_url": "https://avatars.githubusercontent.com/u/7034308?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cbeuw", "html_url": "https://github.com/cbeuw", "followers_url": "https://api.github.com/users/cbeuw/followers", "following_url": "https://api.github.com/users/cbeuw/following{/other_user}", "gists_url": "https://api.github.com/users/cbeuw/gists{/gist_id}", "starred_url": "https://api.github.com/users/cbeuw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cbeuw/subscriptions", "organizations_url": "https://api.github.com/users/cbeuw/orgs", "repos_url": "https://api.github.com/users/cbeuw/repos", "events_url": "https://api.github.com/users/cbeuw/events{/privacy}", "received_events_url": "https://api.github.com/users/cbeuw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5a4a1bfccc50e0e6c6df98e4b95837de79e01023", "url": "https://api.github.com/repos/rust-lang/rust/commits/5a4a1bfccc50e0e6c6df98e4b95837de79e01023", "html_url": "https://github.com/rust-lang/rust/commit/5a4a1bfccc50e0e6c6df98e4b95837de79e01023"}], "stats": {"total": 73, "additions": 36, "deletions": 37}, "files": [{"sha": "5b6c06d59ec27b55990ae94a85756669d7303824", "filename": "src/concurrency/allocation_map.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6b54c9237789c275a82eeb483052b302f490b57c/src%2Fconcurrency%2Fallocation_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b54c9237789c275a82eeb483052b302f490b57c/src%2Fconcurrency%2Fallocation_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconcurrency%2Fallocation_map.rs?ref=6b54c9237789c275a82eeb483052b302f490b57c", "patch": "@@ -122,11 +122,6 @@ impl<T> AllocationMap<T> {\n             debug_assert!(range.end() <= self.v[index + 1].range.start);\n         }\n     }\n-\n-    /// Removes an object at given position\n-    pub fn remove(&mut self, index: Position) -> T {\n-        self.v.remove(index).data\n-    }\n }\n \n impl<T> Index<Position> for AllocationMap<T> {"}, {"sha": "a796b56e2c0a7f7ed545bd23647602ee796fca8b", "filename": "src/concurrency/weak_memory.rs", "status": "modified", "additions": 28, "deletions": 25, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/6b54c9237789c275a82eeb483052b302f490b57c/src%2Fconcurrency%2Fweak_memory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b54c9237789c275a82eeb483052b302f490b57c/src%2Fconcurrency%2Fweak_memory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconcurrency%2Fweak_memory.rs?ref=6b54c9237789c275a82eeb483052b302f490b57c", "patch": "@@ -85,7 +85,7 @@ pub struct StoreBufferAlloc {\n }\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n-pub(super) struct StoreBuffer {\n+struct StoreBuffer {\n     // Stores to this location in modification order\n     buffer: VecDeque<StoreElement>,\n }\n@@ -115,7 +115,10 @@ impl StoreBufferAlloc {\n     }\n \n     /// Gets a store buffer associated with an atomic object in this allocation\n-    fn get_store_buffer(&self, range: AllocRange) -> Ref<'_, StoreBuffer> {\n+    fn get_store_buffer<'tcx>(\n+        &self,\n+        range: AllocRange,\n+    ) -> InterpResult<'tcx, Ref<'_, StoreBuffer>> {\n         let access_type = self.store_buffer.borrow().access_type(range);\n         let index = match access_type {\n             AccessType::PerfectlyOverlapping(index) => index,\n@@ -128,23 +131,23 @@ impl StoreBufferAlloc {\n             AccessType::ImperfectlyOverlapping(index_range) => {\n                 // Accesses that imperfectly overlaps with existing atomic objects\n                 // do not have well-defined behaviours.\n-                // The behaviour here is that we delete all the existing objects this\n-                // access touches, and allocate a new and empty one for the exact range.\n-                // A read on an empty buffer returns None, which means the program will\n-                // observe the latest value in modification order at every byte.\n-                let mut buffer = self.store_buffer.borrow_mut();\n-                for index in index_range.clone() {\n-                    buffer.remove(index);\n+                // FIXME: if this access happens before all previous accesses on every object it overlaps\n+                // with, then we would like to tolerate it. However this is not easy to check.\n+                if index_range.start + 1 == index_range.end {\n+                    throw_ub_format!(\"mixed-size access on an existing atomic object\");\n+                } else {\n+                    throw_ub_format!(\"access overlaps with multiple existing atomic objects\");\n                 }\n-                buffer.insert(index_range.start, range, StoreBuffer::default());\n-                index_range.start\n             }\n         };\n-        Ref::map(self.store_buffer.borrow(), |buffer| &buffer[index])\n+        Ok(Ref::map(self.store_buffer.borrow(), |buffer| &buffer[index]))\n     }\n \n     /// Gets a mutable store buffer associated with an atomic object in this allocation\n-    fn get_store_buffer_mut(&mut self, range: AllocRange) -> &mut StoreBuffer {\n+    fn get_store_buffer_mut<'tcx>(\n+        &mut self,\n+        range: AllocRange,\n+    ) -> InterpResult<'tcx, &mut StoreBuffer> {\n         let buffer = self.store_buffer.get_mut();\n         let access_type = buffer.access_type(range);\n         let index = match access_type {\n@@ -154,14 +157,14 @@ impl StoreBufferAlloc {\n                 index\n             }\n             AccessType::ImperfectlyOverlapping(index_range) => {\n-                for index in index_range.clone() {\n-                    buffer.remove(index);\n+                if index_range.start + 1 == index_range.end {\n+                    throw_ub_format!(\"mixed-size access on an existing atomic object\");\n+                } else {\n+                    throw_ub_format!(\"access overlaps with multiple existing atomic objects\");\n                 }\n-                buffer.insert(index_range.start, range, StoreBuffer::default());\n-                index_range.start\n             }\n         };\n-        &mut buffer[index]\n+        Ok(&mut buffer[index])\n     }\n }\n \n@@ -175,15 +178,15 @@ impl Default for StoreBuffer {\n \n impl<'mir, 'tcx: 'mir> StoreBuffer {\n     /// Reads from the last store in modification order\n-    pub(super) fn read_from_last_store(&self, global: &GlobalState) {\n+    fn read_from_last_store(&self, global: &GlobalState) {\n         let store_elem = self.buffer.back();\n         if let Some(store_elem) = store_elem {\n             let (index, clocks) = global.current_thread_state();\n             store_elem.load_impl(index, &clocks);\n         }\n     }\n \n-    pub(super) fn buffered_read(\n+    fn buffered_read(\n         &self,\n         global: &GlobalState,\n         is_seqcst: bool,\n@@ -214,7 +217,7 @@ impl<'mir, 'tcx: 'mir> StoreBuffer {\n         Ok(loaded)\n     }\n \n-    pub(super) fn buffered_write(\n+    fn buffered_write(\n         &mut self,\n         val: ScalarMaybeUninit<Tag>,\n         global: &GlobalState,\n@@ -376,7 +379,7 @@ pub(super) trait EvalContextExt<'mir, 'tcx: 'mir>:\n                 global.sc_write();\n             }\n             let range = alloc_range(base_offset, place.layout.size);\n-            let buffer = alloc_buffers.get_store_buffer_mut(range);\n+            let buffer = alloc_buffers.get_store_buffer_mut(range)?;\n             buffer.read_from_last_store(global);\n             buffer.buffered_write(new_val, global, atomic == AtomicRwOp::SeqCst)?;\n         }\n@@ -399,7 +402,7 @@ pub(super) trait EvalContextExt<'mir, 'tcx: 'mir>:\n                 }\n                 let mut rng = this.machine.rng.borrow_mut();\n                 let buffer =\n-                    alloc_buffers.get_store_buffer(alloc_range(base_offset, place.layout.size));\n+                    alloc_buffers.get_store_buffer(alloc_range(base_offset, place.layout.size))?;\n                 let loaded = buffer.buffered_read(\n                     global,\n                     atomic == AtomicReadOp::SeqCst,\n@@ -433,7 +436,7 @@ pub(super) trait EvalContextExt<'mir, 'tcx: 'mir>:\n                 global.sc_write();\n             }\n             let buffer =\n-                alloc_buffers.get_store_buffer_mut(alloc_range(base_offset, dest.layout.size));\n+                alloc_buffers.get_store_buffer_mut(alloc_range(base_offset, dest.layout.size))?;\n             buffer.buffered_write(val, global, atomic == AtomicWriteOp::SeqCst)?;\n         }\n \n@@ -458,7 +461,7 @@ pub(super) trait EvalContextExt<'mir, 'tcx: 'mir>:\n             let size = place.layout.size;\n             let (alloc_id, base_offset, ..) = this.ptr_get_alloc_id(place.ptr)?;\n             if let Some(alloc_buffers) = this.get_alloc_extra(alloc_id)?.weak_memory.as_ref() {\n-                let buffer = alloc_buffers.get_store_buffer(alloc_range(base_offset, size));\n+                let buffer = alloc_buffers.get_store_buffer(alloc_range(base_offset, size))?;\n                 buffer.read_from_last_store(global);\n             }\n         }"}, {"sha": "e3f89b5b684f8ca5a4faf616c7dfc79599c7b0b6", "filename": "tests/compile-fail/weak_memory/imperfectly_overlapping.rs", "status": "renamed", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/6b54c9237789c275a82eeb483052b302f490b57c/tests%2Fcompile-fail%2Fweak_memory%2Fimperfectly_overlapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b54c9237789c275a82eeb483052b302f490b57c/tests%2Fcompile-fail%2Fweak_memory%2Fimperfectly_overlapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fweak_memory%2Fimperfectly_overlapping.rs?ref=6b54c9237789c275a82eeb483052b302f490b57c", "patch": "@@ -1,27 +1,28 @@\n // ignore-windows: Concurrency on Windows is not supported yet.\n #![feature(atomic_from_mut)]\n+#![feature(core_intrinsics)]\n \n+use std::intrinsics::atomic_load;\n use std::sync::atomic::Ordering::*;\n use std::sync::atomic::{AtomicU16, AtomicU32};\n \n-// Strictly speaking, atomic accesses that imperfectly overlap with existing\n-// atomic objects are UB. Nonetheless we'd like to provide a sane value when\n-// the access is not racy.\n fn test_same_thread() {\n     let mut qword = AtomicU32::new(42);\n     assert_eq!(qword.load(Relaxed), 42);\n-    qword.store(u32::to_be(0xabbafafa), Relaxed);\n+    qword.store(0xabbafafa, Relaxed);\n \n     let qword_mut = qword.get_mut();\n \n     let dwords_mut = unsafe { std::mem::transmute::<&mut u32, &mut [u16; 2]>(qword_mut) };\n \n     let (hi_mut, lo_mut) = dwords_mut.split_at_mut(1);\n \n-    let (hi, lo) = (AtomicU16::from_mut(&mut hi_mut[0]), AtomicU16::from_mut(&mut lo_mut[0]));\n+    let (hi, _) = (AtomicU16::from_mut(&mut hi_mut[0]), AtomicU16::from_mut(&mut lo_mut[0]));\n \n-    assert_eq!(u16::from_be(hi.load(Relaxed)), 0xabba);\n-    assert_eq!(u16::from_be(lo.load(Relaxed)), 0xfafa);\n+    unsafe {\n+        //Equivalent to: hi.load(Ordering::SeqCst)\n+        atomic_load(hi.get_mut() as *mut u16); //~ ERROR: mixed-size access on an existing atomic object\n+    }\n }\n \n pub fn main() {", "previous_filename": "tests/run-pass/weak_memory/imperfectly_overlapping.rs"}]}