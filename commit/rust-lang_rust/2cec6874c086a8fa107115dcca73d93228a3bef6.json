{"sha": "2cec6874c086a8fa107115dcca73d93228a3bef6", "node_id": "C_kwDOAAsO6NoAKDJjZWM2ODc0YzA4NmE4ZmExMDcxMTVkY2NhNzNkOTMyMjhhM2JlZjY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-18T12:54:01Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-18T12:54:01Z"}, "message": "Auto merge of #98004 - paolobarbolini:vecdeque-extend-trustedlen, r=the8472\n\nAdd VecDeque::extend from TrustedLen specialization\n\nContinuation of #95904\n\nInspired by how [`VecDeque::copy_slice` works](https://github.com/rust-lang/rust/blob/c08b235a5ce10167632bb0fddcd0c5d67f2d42e3/library/alloc/src/collections/vec_deque/mod.rs#L437-L454).\n\n## Benchmarks\n\nBefore\n\n```\ntest vec_deque::bench_extend_chained_bytes      ... bench:       1,026 ns/iter (+/- 17)\ntest vec_deque::bench_extend_chained_trustedlen ... bench:       1,024 ns/iter (+/- 40)\ntest vec_deque::bench_extend_trustedlen         ... bench:         637 ns/iter (+/- 693)\n```\n\nAfter\n\n```\ntest vec_deque::bench_extend_chained_bytes      ... bench:         828 ns/iter (+/- 24)\ntest vec_deque::bench_extend_chained_trustedlen ... bench:          25 ns/iter (+/- 1)\ntest vec_deque::bench_extend_trustedlen         ... bench:          21 ns/iter (+/- 0)\n```\n\n## Why do it this way\n\nhttps://rust.godbolt.org/z/15qY1fMYh\n\nThe Compiler Explorer example shows how \"just\" removing the capacity check, like the [`Vec` `TrustedLen` specialization](https://github.com/rust-lang/rust/blob/c08b235a5ce10167632bb0fddcd0c5d67f2d42e3/library/alloc/src/vec/spec_extend.rs#L22-L58) does, wouldn't have been enough for `VecDeque`. `wrap_add` would still have greatly limited what LLVM could do while optimizing.\n\n---\n\nr? `@the8472`", "tree": {"sha": "23718b308fa21d0bab0b7bc0406cf207ba0e1a71", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/23718b308fa21d0bab0b7bc0406cf207ba0e1a71"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2cec6874c086a8fa107115dcca73d93228a3bef6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2cec6874c086a8fa107115dcca73d93228a3bef6", "html_url": "https://github.com/rust-lang/rust/commit/2cec6874c086a8fa107115dcca73d93228a3bef6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2cec6874c086a8fa107115dcca73d93228a3bef6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cdcc53b7dc002ea4a7a28105010c5a1126ee31b7", "url": "https://api.github.com/repos/rust-lang/rust/commits/cdcc53b7dc002ea4a7a28105010c5a1126ee31b7", "html_url": "https://github.com/rust-lang/rust/commit/cdcc53b7dc002ea4a7a28105010c5a1126ee31b7"}, {"sha": "ce3b6f505ed8c0a285461f4f9b729b62e7703354", "url": "https://api.github.com/repos/rust-lang/rust/commits/ce3b6f505ed8c0a285461f4f9b729b62e7703354", "html_url": "https://github.com/rust-lang/rust/commit/ce3b6f505ed8c0a285461f4f9b729b62e7703354"}], "stats": {"total": 221, "additions": 218, "deletions": 3}, "files": [{"sha": "7c78561ebf10946064861d753a9268188afde5ce", "filename": "library/alloc/benches/vec_deque.rs", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/2cec6874c086a8fa107115dcca73d93228a3bef6/library%2Falloc%2Fbenches%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cec6874c086a8fa107115dcca73d93228a3bef6/library%2Falloc%2Fbenches%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fbenches%2Fvec_deque.rs?ref=2cec6874c086a8fa107115dcca73d93228a3bef6", "patch": "@@ -91,3 +91,35 @@ fn bench_extend_vec(b: &mut Bencher) {\n         ring.extend(black_box(input));\n     });\n }\n+\n+#[bench]\n+fn bench_extend_trustedlen(b: &mut Bencher) {\n+    let mut ring: VecDeque<u16> = VecDeque::with_capacity(1000);\n+\n+    b.iter(|| {\n+        ring.clear();\n+        ring.extend(black_box(0..512));\n+    });\n+}\n+\n+#[bench]\n+fn bench_extend_chained_trustedlen(b: &mut Bencher) {\n+    let mut ring: VecDeque<u16> = VecDeque::with_capacity(1000);\n+\n+    b.iter(|| {\n+        ring.clear();\n+        ring.extend(black_box((0..256).chain(768..1024)));\n+    });\n+}\n+\n+#[bench]\n+fn bench_extend_chained_bytes(b: &mut Bencher) {\n+    let mut ring: VecDeque<u16> = VecDeque::with_capacity(1000);\n+    let input1: &[u16] = &[128; 256];\n+    let input2: &[u16] = &[255; 256];\n+\n+    b.iter(|| {\n+        ring.clear();\n+        ring.extend(black_box(input1.iter().chain(input2.iter())));\n+    });\n+}"}, {"sha": "f92e5759b6f9efa6fcfadd1637b05a0cc8d45b5b", "filename": "library/alloc/src/collections/vec_deque/mod.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/2cec6874c086a8fa107115dcca73d93228a3bef6/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cec6874c086a8fa107115dcca73d93228a3bef6/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fmod.rs?ref=2cec6874c086a8fa107115dcca73d93228a3bef6", "patch": "@@ -453,6 +453,25 @@ impl<T, A: Allocator> VecDeque<T, A> {\n         }\n     }\n \n+    /// Writes all values from `iter` to `dst`.\n+    ///\n+    /// # Safety\n+    ///\n+    /// Assumes no wrapping around happens.\n+    /// Assumes capacity is sufficient.\n+    #[inline]\n+    unsafe fn write_iter(\n+        &mut self,\n+        dst: usize,\n+        iter: impl Iterator<Item = T>,\n+        written: &mut usize,\n+    ) {\n+        iter.enumerate().for_each(|(i, element)| unsafe {\n+            self.buffer_write(dst + i, element);\n+            *written += 1;\n+        });\n+    }\n+\n     /// Frobs the head and tail sections around to handle the fact that we\n     /// just reallocated. Unsafe because it trusts old_capacity.\n     #[inline]"}, {"sha": "97ff8b76524035e5356fc2e75545a99b927d20db", "filename": "library/alloc/src/collections/vec_deque/spec_extend.rs", "status": "modified", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/2cec6874c086a8fa107115dcca73d93228a3bef6/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fspec_extend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cec6874c086a8fa107115dcca73d93228a3bef6/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fspec_extend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Fspec_extend.rs?ref=2cec6874c086a8fa107115dcca73d93228a3bef6", "patch": "@@ -1,5 +1,6 @@\n use crate::alloc::Allocator;\n use crate::vec;\n+use core::iter::{ByRefSized, TrustedLen};\n use core::slice;\n \n use super::VecDeque;\n@@ -34,6 +35,64 @@ where\n     }\n }\n \n+impl<T, I, A: Allocator> SpecExtend<T, I> for VecDeque<T, A>\n+where\n+    I: TrustedLen<Item = T>,\n+{\n+    default fn spec_extend(&mut self, mut iter: I) {\n+        // This is the case for a TrustedLen iterator.\n+        let (low, high) = iter.size_hint();\n+        if let Some(additional) = high {\n+            debug_assert_eq!(\n+                low,\n+                additional,\n+                \"TrustedLen iterator's size hint is not exact: {:?}\",\n+                (low, high)\n+            );\n+            self.reserve(additional);\n+\n+            struct WrapAddOnDrop<'a, T, A: Allocator> {\n+                vec_deque: &'a mut VecDeque<T, A>,\n+                written: usize,\n+            }\n+\n+            impl<'a, T, A: Allocator> Drop for WrapAddOnDrop<'a, T, A> {\n+                fn drop(&mut self) {\n+                    self.vec_deque.head =\n+                        self.vec_deque.wrap_add(self.vec_deque.head, self.written);\n+                }\n+            }\n+\n+            let mut wrapper = WrapAddOnDrop { vec_deque: self, written: 0 };\n+\n+            let head_room = wrapper.vec_deque.cap() - wrapper.vec_deque.head;\n+            unsafe {\n+                wrapper.vec_deque.write_iter(\n+                    wrapper.vec_deque.head,\n+                    ByRefSized(&mut iter).take(head_room),\n+                    &mut wrapper.written,\n+                );\n+\n+                if additional > head_room {\n+                    wrapper.vec_deque.write_iter(0, iter, &mut wrapper.written);\n+                }\n+            }\n+\n+            debug_assert_eq!(\n+                additional, wrapper.written,\n+                \"The number of items written to VecDeque doesn't match the TrustedLen size hint\"\n+            );\n+        } else {\n+            // Per TrustedLen contract a `None` upper bound means that the iterator length\n+            // truly exceeds usize::MAX, which would eventually lead to a capacity overflow anyway.\n+            // Since the other branch already panics eagerly (via `reserve()`) we do the same here.\n+            // This avoids additional codegen for a fallback code path which would eventually\n+            // panic anyway.\n+            panic!(\"capacity overflow\");\n+        }\n+    }\n+}\n+\n impl<T, A: Allocator> SpecExtend<T, vec::IntoIter<T>> for VecDeque<T, A> {\n     fn spec_extend(&mut self, mut iterator: vec::IntoIter<T>) {\n         let slice = iterator.as_slice();"}, {"sha": "1f2daef213c3b78a2cf2fb02d56f05a9f446b947", "filename": "library/alloc/src/collections/vec_deque/tests.rs", "status": "modified", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/2cec6874c086a8fa107115dcca73d93228a3bef6/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cec6874c086a8fa107115dcca73d93228a3bef6/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque%2Ftests.rs?ref=2cec6874c086a8fa107115dcca73d93228a3bef6", "patch": "@@ -1,3 +1,5 @@\n+use core::iter::TrustedLen;\n+\n use super::*;\n \n #[bench]\n@@ -791,6 +793,101 @@ fn test_from_vec() {\n     assert_eq!(vd.len(), vec.len());\n }\n \n+#[test]\n+fn test_extend_basic() {\n+    test_extend_impl(false);\n+}\n+\n+#[test]\n+fn test_extend_trusted_len() {\n+    test_extend_impl(true);\n+}\n+\n+fn test_extend_impl(trusted_len: bool) {\n+    struct VecDequeTester {\n+        test: VecDeque<usize>,\n+        expected: VecDeque<usize>,\n+        trusted_len: bool,\n+    }\n+\n+    impl VecDequeTester {\n+        fn new(trusted_len: bool) -> Self {\n+            Self { test: VecDeque::new(), expected: VecDeque::new(), trusted_len }\n+        }\n+\n+        fn test_extend<I>(&mut self, iter: I)\n+        where\n+            I: Iterator<Item = usize> + TrustedLen + Clone,\n+        {\n+            struct BasicIterator<I>(I);\n+            impl<I> Iterator for BasicIterator<I>\n+            where\n+                I: Iterator<Item = usize>,\n+            {\n+                type Item = usize;\n+\n+                fn next(&mut self) -> Option<Self::Item> {\n+                    self.0.next()\n+                }\n+            }\n+\n+            if self.trusted_len {\n+                self.test.extend(iter.clone());\n+            } else {\n+                self.test.extend(BasicIterator(iter.clone()));\n+            }\n+\n+            for item in iter {\n+                self.expected.push_back(item)\n+            }\n+\n+            assert_eq!(self.test, self.expected);\n+            let (a1, b1) = self.test.as_slices();\n+            let (a2, b2) = self.expected.as_slices();\n+            assert_eq!(a1, a2);\n+            assert_eq!(b1, b2);\n+        }\n+\n+        fn drain<R: RangeBounds<usize> + Clone>(&mut self, range: R) {\n+            self.test.drain(range.clone());\n+            self.expected.drain(range);\n+\n+            assert_eq!(self.test, self.expected);\n+        }\n+\n+        fn clear(&mut self) {\n+            self.test.clear();\n+            self.expected.clear();\n+        }\n+\n+        fn remaining_capacity(&self) -> usize {\n+            self.test.capacity() - self.test.len()\n+        }\n+    }\n+\n+    let mut tester = VecDequeTester::new(trusted_len);\n+\n+    // Initial capacity\n+    tester.test_extend(0..tester.remaining_capacity() - 1);\n+\n+    // Grow\n+    tester.test_extend(1024..2048);\n+\n+    // Wrap around\n+    tester.drain(..128);\n+\n+    tester.test_extend(0..tester.remaining_capacity() - 1);\n+\n+    // Continue\n+    tester.drain(256..);\n+    tester.test_extend(4096..8196);\n+\n+    tester.clear();\n+\n+    // Start again\n+    tester.test_extend(0..32);\n+}\n+\n #[test]\n #[should_panic = \"capacity overflow\"]\n fn test_from_vec_zst_overflow() {"}, {"sha": "c08caa7b93ed2c445d5f5a3ed2006846525d6020", "filename": "library/alloc/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2cec6874c086a8fa107115dcca73d93228a3bef6/library%2Falloc%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cec6874c086a8fa107115dcca73d93228a3bef6/library%2Falloc%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Flib.rs?ref=2cec6874c086a8fa107115dcca73d93228a3bef6", "patch": "@@ -143,6 +143,7 @@\n #![feature(unchecked_math)]\n #![feature(unicode_internals)]\n #![feature(unsize)]\n+#![feature(std_internals)]\n //\n // Language features:\n #![feature(allocator_internals)]"}, {"sha": "cc1e8e8a27fa6bd4f2f8db7a23d56c4fb91df107", "filename": "library/core/src/iter/adapters/by_ref_sized.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2cec6874c086a8fa107115dcca73d93228a3bef6/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fby_ref_sized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cec6874c086a8fa107115dcca73d93228a3bef6/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fby_ref_sized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fby_ref_sized.rs?ref=2cec6874c086a8fa107115dcca73d93228a3bef6", "patch": "@@ -4,8 +4,11 @@ use crate::ops::Try;\n ///\n /// Ideally this will no longer be required, eventually, but as can be seen in\n /// the benchmarks (as of Feb 2022 at least) `by_ref` can have performance cost.\n-pub(crate) struct ByRefSized<'a, I>(pub &'a mut I);\n+#[unstable(feature = \"std_internals\", issue = \"none\")]\n+#[derive(Debug)]\n+pub struct ByRefSized<'a, I>(pub &'a mut I);\n \n+#[unstable(feature = \"std_internals\", issue = \"none\")]\n impl<I: Iterator> Iterator for ByRefSized<'_, I> {\n     type Item = I::Item;\n \n@@ -47,6 +50,7 @@ impl<I: Iterator> Iterator for ByRefSized<'_, I> {\n     }\n }\n \n+#[unstable(feature = \"std_internals\", issue = \"none\")]\n impl<I: DoubleEndedIterator> DoubleEndedIterator for ByRefSized<'_, I> {\n     #[inline]\n     fn next_back(&mut self) -> Option<Self::Item> {"}, {"sha": "916a26e242466ee5675b2e8591781c3a23ee327e", "filename": "library/core/src/iter/adapters/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2cec6874c086a8fa107115dcca73d93228a3bef6/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cec6874c086a8fa107115dcca73d93228a3bef6/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fmod.rs?ref=2cec6874c086a8fa107115dcca73d93228a3bef6", "patch": "@@ -32,7 +32,8 @@ pub use self::{\n     scan::Scan, skip::Skip, skip_while::SkipWhile, take::Take, take_while::TakeWhile, zip::Zip,\n };\n \n-pub(crate) use self::by_ref_sized::ByRefSized;\n+#[unstable(feature = \"std_internals\", issue = \"none\")]\n+pub use self::by_ref_sized::ByRefSized;\n \n #[stable(feature = \"iter_cloned\", since = \"1.1.0\")]\n pub use self::cloned::Cloned;"}, {"sha": "d5c6aed5b6c8ab48ee5368a2da0acefa79e3e035", "filename": "library/core/src/iter/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2cec6874c086a8fa107115dcca73d93228a3bef6/library%2Fcore%2Fsrc%2Fiter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2cec6874c086a8fa107115dcca73d93228a3bef6/library%2Fcore%2Fsrc%2Fiter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fmod.rs?ref=2cec6874c086a8fa107115dcca73d93228a3bef6", "patch": "@@ -398,6 +398,8 @@ pub use self::traits::{\n \n #[stable(feature = \"iter_zip\", since = \"1.59.0\")]\n pub use self::adapters::zip;\n+#[unstable(feature = \"std_internals\", issue = \"none\")]\n+pub use self::adapters::ByRefSized;\n #[stable(feature = \"iter_cloned\", since = \"1.1.0\")]\n pub use self::adapters::Cloned;\n #[stable(feature = \"iter_copied\", since = \"1.36.0\")]\n@@ -422,7 +424,7 @@ pub use self::adapters::{\n #[unstable(feature = \"iter_intersperse\", reason = \"recently added\", issue = \"79524\")]\n pub use self::adapters::{Intersperse, IntersperseWith};\n \n-pub(crate) use self::adapters::{try_process, ByRefSized};\n+pub(crate) use self::adapters::try_process;\n \n mod adapters;\n mod range;"}]}