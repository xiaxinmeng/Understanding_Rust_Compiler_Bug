{"sha": "7cd86aa1be18d608d828239c11e887a762efc92a", "node_id": "C_kwDOAAsO6NoAKDdjZDg2YWExYmUxOGQ2MDhkODI4MjM5YzExZTg4N2E3NjJlZmM5MmE", "commit": {"author": {"name": "flip1995", "email": "philipp.krones@embecosm.com", "date": "2022-05-05T14:12:52Z"}, "committer": {"name": "flip1995", "email": "philipp.krones@embecosm.com", "date": "2022-05-05T14:12:52Z"}, "message": "Merge commit '7c21f91b15b7604f818565646b686d90f99d1baf' into clippyup", "tree": {"sha": "f2f098e889406b343beba0dbbf58e492c4e5dff6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f2f098e889406b343beba0dbbf58e492c4e5dff6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7cd86aa1be18d608d828239c11e887a762efc92a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7cd86aa1be18d608d828239c11e887a762efc92a", "html_url": "https://github.com/rust-lang/rust/commit/7cd86aa1be18d608d828239c11e887a762efc92a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7cd86aa1be18d608d828239c11e887a762efc92a/comments", "author": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "82f469f81b6daafb448e36c0e811cf2d40836edb", "url": "https://api.github.com/repos/rust-lang/rust/commits/82f469f81b6daafb448e36c0e811cf2d40836edb", "html_url": "https://github.com/rust-lang/rust/commit/82f469f81b6daafb448e36c0e811cf2d40836edb"}], "stats": {"total": 8843, "additions": 6204, "deletions": 2639}, "files": [{"sha": "89884bfc85902ee4cf825d2d5130a6d5b9935d69", "filename": ".github/ISSUE_TEMPLATE/blank_issue.yml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/.github%2FISSUE_TEMPLATE%2Fblank_issue.yml", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/.github%2FISSUE_TEMPLATE%2Fblank_issue.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2FISSUE_TEMPLATE%2Fblank_issue.yml?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -9,7 +9,7 @@ body:\n     attributes:\n       label: Description\n       description: >\n-        Please provide a discription of the issue, along with any information\n+        Please provide a description of the issue, along with any information\n         you feel relevant to replicate it.\n     validations:\n       required: true"}, {"sha": "25e436d30b97dc42dacee379ad90f9d069c462d5", "filename": ".github/ISSUE_TEMPLATE/false_negative.yml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/.github%2FISSUE_TEMPLATE%2Ffalse_negative.yml", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/.github%2FISSUE_TEMPLATE%2Ffalse_negative.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2FISSUE_TEMPLATE%2Ffalse_negative.yml?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -23,7 +23,7 @@ body:\n     id: reproducer\n     attributes:\n       label: Reproducer\n-      description: Please provide the code and steps to repoduce the bug\n+      description: Please provide the code and steps to reproduce the bug\n       value: |\n         I tried this code:\n "}, {"sha": "561b65c93a7f9329799d2be796c2590b1ae215dd", "filename": ".github/ISSUE_TEMPLATE/false_positive.yml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/.github%2FISSUE_TEMPLATE%2Ffalse_positive.yml", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/.github%2FISSUE_TEMPLATE%2Ffalse_positive.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2FISSUE_TEMPLATE%2Ffalse_positive.yml?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -24,7 +24,7 @@ body:\n     attributes:\n       label: Reproducer\n       description: >\n-        Please provide the code and steps to repoduce the bug together with the\n+        Please provide the code and steps to reproduce the bug together with the\n         output from Clippy.\n       value: |\n         I tried this code:"}, {"sha": "0e27cc927acea4c010f810cd350f047eebece429", "filename": ".github/workflows/clippy.yml", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/.github%2Fworkflows%2Fclippy.yml", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/.github%2Fworkflows%2Fclippy.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Fclippy.yml?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -6,14 +6,14 @@ on:\n     branches-ignore:\n       - auto\n       - try\n-    # Don't run Clippy tests, when only textfiles were modified\n+    # Don't run Clippy tests, when only text files were modified\n     paths-ignore:\n     - 'COPYRIGHT'\n     - 'LICENSE-*'\n     - '**.md'\n     - '**.txt'\n   pull_request:\n-    # Don't run Clippy tests, when only textfiles were modified\n+    # Don't run Clippy tests, when only text files were modified\n     paths-ignore:\n     - 'COPYRIGHT'\n     - 'LICENSE-*'\n@@ -37,7 +37,7 @@ jobs:\n         github_token: \"${{ secrets.github_token }}\"\n \n     - name: Checkout\n-      uses: actions/checkout@v2.3.3\n+      uses: actions/checkout@v3.0.2\n \n     - name: Install toolchain\n       run: rustup show active-toolchain"}, {"sha": "9b3fd3ddfeb38cc357c20e0c818b2fcad5cd9977", "filename": ".github/workflows/clippy_bors.yml", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/.github%2Fworkflows%2Fclippy_bors.yml", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/.github%2Fworkflows%2Fclippy_bors.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Fclippy_bors.yml?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -25,7 +25,7 @@ jobs:\n         github_token: \"${{ secrets.github_token }}\"\n \n     - name: Checkout\n-      uses: actions/checkout@v2.3.3\n+      uses: actions/checkout@v3.0.2\n       with:\n         ref: ${{ github.ref }}\n \n@@ -88,7 +88,7 @@ jobs:\n       if: matrix.host == 'i686-unknown-linux-gnu'\n \n     - name: Checkout\n-      uses: actions/checkout@v2.3.3\n+      uses: actions/checkout@v3.0.2\n \n     - name: Install toolchain\n       run: rustup show active-toolchain\n@@ -154,7 +154,7 @@ jobs:\n         github_token: \"${{ secrets.github_token }}\"\n \n     - name: Checkout\n-      uses: actions/checkout@v2.3.3\n+      uses: actions/checkout@v3.0.2\n \n     - name: Install toolchain\n       run: rustup show active-toolchain\n@@ -212,7 +212,7 @@ jobs:\n         github_token: \"${{ secrets.github_token }}\"\n \n     - name: Checkout\n-      uses: actions/checkout@v2.3.3\n+      uses: actions/checkout@v3.0.2\n \n     - name: Install toolchain\n       run: rustup show active-toolchain"}, {"sha": "22051093c9cf960992c3a80923e71f72ef4414f1", "filename": ".github/workflows/clippy_dev.yml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/.github%2Fworkflows%2Fclippy_dev.yml", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/.github%2Fworkflows%2Fclippy_dev.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Fclippy_dev.yml?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -23,7 +23,7 @@ jobs:\n     steps:\n     # Setup\n     - name: Checkout\n-      uses: actions/checkout@v2.3.3\n+      uses: actions/checkout@v3.0.2\n \n     # Run\n     - name: Build"}, {"sha": "71d71d10359e7e76b4f2cbc1b8843247d266659c", "filename": ".github/workflows/deploy.yml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/.github%2Fworkflows%2Fdeploy.yml", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/.github%2Fworkflows%2Fdeploy.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Fdeploy.yml?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -21,10 +21,10 @@ jobs:\n     steps:\n     # Setup\n     - name: Checkout\n-      uses: actions/checkout@v2.3.3\n+      uses: actions/checkout@v3.0.2\n \n     - name: Checkout\n-      uses: actions/checkout@v2.3.3\n+      uses: actions/checkout@v3.0.2\n       with:\n         ref: ${{ env.TARGET_BRANCH }}\n         path: 'out'"}, {"sha": "a179bfa72617213735d50473ae66a73dc2355ecc", "filename": ".github/workflows/remark.yml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/.github%2Fworkflows%2Fremark.yml", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/.github%2Fworkflows%2Fremark.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Fremark.yml?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -16,7 +16,7 @@ jobs:\n     steps:\n     # Setup\n     - name: Checkout\n-      uses: actions/checkout@v2.3.3\n+      uses: actions/checkout@v3.0.2\n \n     - name: Setup Node.js\n       uses: actions/setup-node@v1.4.4"}, {"sha": "751f9fccd88d4389866d835eb08ebd0a3d3547a7", "filename": "CHANGELOG.md", "status": "modified", "additions": 112, "deletions": 1, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -6,7 +6,108 @@ document.\n \n ## Unreleased / In Rust Nightly\n \n-[57b3c4b...master](https://github.com/rust-lang/rust-clippy/compare/57b3c4b...master)\n+[d0cf3481...master](https://github.com/rust-lang/rust-clippy/compare/d0cf3481...master)\n+\n+## Rust 1.61 (beta)\n+\n+Current beta, released 2022-05-19\n+\n+[57b3c4b...d0cf3481](https://github.com/rust-lang/rust-clippy/compare/57b3c4b...d0cf3481)\n+\n+### New Lints\n+\n+* [`only_used_in_recursion`]\n+  [#8422](https://github.com/rust-lang/rust-clippy/pull/8422)\n+* [`cast_enum_truncation`]\n+  [#8381](https://github.com/rust-lang/rust-clippy/pull/8381)\n+* [`missing_spin_loop`]\n+  [#8174](https://github.com/rust-lang/rust-clippy/pull/8174)\n+* [`deref_by_slicing`]\n+  [#8218](https://github.com/rust-lang/rust-clippy/pull/8218)\n+* [`needless_match`]\n+  [#8471](https://github.com/rust-lang/rust-clippy/pull/8471)\n+* [`allow_attributes_without_reason`] (Requires `#![feature(lint_reasons)]`)\n+  [#8504](https://github.com/rust-lang/rust-clippy/pull/8504)\n+* [`print_in_format_impl`]\n+  [#8253](https://github.com/rust-lang/rust-clippy/pull/8253)\n+* [`unnecessary_find_map`]\n+  [#8489](https://github.com/rust-lang/rust-clippy/pull/8489)\n+* [`or_then_unwrap`]\n+  [#8561](https://github.com/rust-lang/rust-clippy/pull/8561)\n+* [`unnecessary_join`]\n+  [#8579](https://github.com/rust-lang/rust-clippy/pull/8579)\n+* [`iter_with_drain`]\n+  [#8483](https://github.com/rust-lang/rust-clippy/pull/8483)\n+* [`cast_enum_constructor`]\n+  [#8562](https://github.com/rust-lang/rust-clippy/pull/8562)\n+* [`cast_slice_different_sizes`]\n+  [#8445](https://github.com/rust-lang/rust-clippy/pull/8445)\n+\n+### Moves and Deprecations\n+\n+* Moved [`transmute_undefined_repr`] to `nursery` (now allow-by-default)\n+  [#8432](https://github.com/rust-lang/rust-clippy/pull/8432)\n+* Moved [`try_err`] to `restriction`\n+  [#8544](https://github.com/rust-lang/rust-clippy/pull/8544)\n+* Move [`iter_with_drain`] to `nursery`\n+  [#8541](https://github.com/rust-lang/rust-clippy/pull/8541)\n+* Renamed `to_string_in_display` to [`recursive_format_impl`]\n+  [#8188](https://github.com/rust-lang/rust-clippy/pull/8188)\n+\n+### Enhancements\n+\n+* [`dbg_macro`]: The lint level can now be set with crate attributes and works inside macros\n+  [#8411](https://github.com/rust-lang/rust-clippy/pull/8411)\n+* [`ptr_as_ptr`]: Now works inside macros\n+  [#8442](https://github.com/rust-lang/rust-clippy/pull/8442)\n+* [`use_self`]: Now works for variants in match expressions\n+  [#8456](https://github.com/rust-lang/rust-clippy/pull/8456)\n+* [`await_holding_lock`]: Now lints for `parking_lot::{Mutex, RwLock}`\n+  [#8419](https://github.com/rust-lang/rust-clippy/pull/8419)\n+* [`recursive_format_impl`]: Now checks for format calls on `self`\n+  [#8188](https://github.com/rust-lang/rust-clippy/pull/8188)\n+\n+### False Positive Fixes\n+\n+* [`new_without_default`]: No longer lints for `new()` methods with `#[doc(hidden)]`\n+  [#8472](https://github.com/rust-lang/rust-clippy/pull/8472)\n+* [`transmute_undefined_repr`]: No longer lints for single field structs with `#[repr(C)]`,\n+  generic parameters, wide pointers, unions, tuples and allow several forms of type erasure\n+  [#8425](https://github.com/rust-lang/rust-clippy/pull/8425)\n+  [#8553](https://github.com/rust-lang/rust-clippy/pull/8553)\n+  [#8440](https://github.com/rust-lang/rust-clippy/pull/8440)\n+  [#8547](https://github.com/rust-lang/rust-clippy/pull/8547)\n+* [`match_single_binding`], [`match_same_arms`], [`match_as_ref`], [`match_bool`]: No longer\n+  lint `match` expressions with `cfg`ed arms\n+  [#8443](https://github.com/rust-lang/rust-clippy/pull/8443)\n+* [`single_component_path_imports`]: No longer lint on macros\n+  [#8537](https://github.com/rust-lang/rust-clippy/pull/8537)\n+* [`ptr_arg`]: Allow `&mut` arguments for `Cow<_>`\n+  [#8552](https://github.com/rust-lang/rust-clippy/pull/8552)\n+* [`needless_borrow`]: No longer lints for method calls\n+  [#8441](https://github.com/rust-lang/rust-clippy/pull/8441)\n+* [`match_same_arms`]: Now ensures that interposing arm patterns don't overlap\n+  [#8232](https://github.com/rust-lang/rust-clippy/pull/8232)\n+* [`default_trait_access`]: Now allows `Default::default` in update expressions\n+  [#8433](https://github.com/rust-lang/rust-clippy/pull/8433)\n+\n+### Suggestion Fixes/Improvements\n+\n+* [`redundant_slicing`]: Fixed suggestion for a method calls\n+  [#8218](https://github.com/rust-lang/rust-clippy/pull/8218)\n+* [`map_flatten`]: Long suggestions will now be split up into two help messages\n+  [#8520](https://github.com/rust-lang/rust-clippy/pull/8520)\n+* [`unnecessary_lazy_evaluations`]: Now shows suggestions for longer code snippets\n+  [#8543](https://github.com/rust-lang/rust-clippy/pull/8543)\n+* [`unnecessary_sort_by`]: Now suggests `Reverse` including the path\n+  [#8462](https://github.com/rust-lang/rust-clippy/pull/8462)\n+* [`search_is_some`]: More suggestions are now `MachineApplicable`\n+  [#8536](https://github.com/rust-lang/rust-clippy/pull/8536)\n+\n+### Documentation Improvements\n+\n+* [`new_without_default`]: Document `pub` requirement for the struct and fields\n+  [#8429](https://github.com/rust-lang/rust-clippy/pull/8429)\n \n ## Rust 1.60\n \n@@ -3182,6 +3283,7 @@ Released 2018-09-13\n [`assign_op_pattern`]: https://rust-lang.github.io/rust-clippy/master/index.html#assign_op_pattern\n [`assign_ops`]: https://rust-lang.github.io/rust-clippy/master/index.html#assign_ops\n [`async_yields_async`]: https://rust-lang.github.io/rust-clippy/master/index.html#async_yields_async\n+[`await_holding_invalid_type`]: https://rust-lang.github.io/rust-clippy/master/index.html#await_holding_invalid_type\n [`await_holding_lock`]: https://rust-lang.github.io/rust-clippy/master/index.html#await_holding_lock\n [`await_holding_refcell_ref`]: https://rust-lang.github.io/rust-clippy/master/index.html#await_holding_refcell_ref\n [`bad_bit_mask`]: https://rust-lang.github.io/rust-clippy/master/index.html#bad_bit_mask\n@@ -3198,6 +3300,7 @@ Released 2018-09-13\n [`boxed_local`]: https://rust-lang.github.io/rust-clippy/master/index.html#boxed_local\n [`branches_sharing_code`]: https://rust-lang.github.io/rust-clippy/master/index.html#branches_sharing_code\n [`builtin_type_shadow`]: https://rust-lang.github.io/rust-clippy/master/index.html#builtin_type_shadow\n+[`bytes_count_to_len`]: https://rust-lang.github.io/rust-clippy/master/index.html#bytes_count_to_len\n [`bytes_nth`]: https://rust-lang.github.io/rust-clippy/master/index.html#bytes_nth\n [`cargo_common_metadata`]: https://rust-lang.github.io/rust-clippy/master/index.html#cargo_common_metadata\n [`case_sensitive_file_extension_comparisons`]: https://rust-lang.github.io/rust-clippy/master/index.html#case_sensitive_file_extension_comparisons\n@@ -3262,6 +3365,7 @@ Released 2018-09-13\n [`duplicate_underscore_argument`]: https://rust-lang.github.io/rust-clippy/master/index.html#duplicate_underscore_argument\n [`duration_subsec`]: https://rust-lang.github.io/rust-clippy/master/index.html#duration_subsec\n [`else_if_without_else`]: https://rust-lang.github.io/rust-clippy/master/index.html#else_if_without_else\n+[`empty_drop`]: https://rust-lang.github.io/rust-clippy/master/index.html#empty_drop\n [`empty_enum`]: https://rust-lang.github.io/rust-clippy/master/index.html#empty_enum\n [`empty_line_after_outer_attr`]: https://rust-lang.github.io/rust-clippy/master/index.html#empty_line_after_outer_attr\n [`empty_loop`]: https://rust-lang.github.io/rust-clippy/master/index.html#empty_loop\n@@ -3314,6 +3418,7 @@ Released 2018-09-13\n [`forget_non_drop`]: https://rust-lang.github.io/rust-clippy/master/index.html#forget_non_drop\n [`forget_ref`]: https://rust-lang.github.io/rust-clippy/master/index.html#forget_ref\n [`format_in_format_args`]: https://rust-lang.github.io/rust-clippy/master/index.html#format_in_format_args\n+[`format_push_string`]: https://rust-lang.github.io/rust-clippy/master/index.html#format_push_string\n [`from_iter_instead_of_collect`]: https://rust-lang.github.io/rust-clippy/master/index.html#from_iter_instead_of_collect\n [`from_over_into`]: https://rust-lang.github.io/rust-clippy/master/index.html#from_over_into\n [`from_str_radix_10`]: https://rust-lang.github.io/rust-clippy/master/index.html#from_str_radix_10\n@@ -3356,6 +3461,7 @@ Released 2018-09-13\n [`invalid_regex`]: https://rust-lang.github.io/rust-clippy/master/index.html#invalid_regex\n [`invalid_upcast_comparisons`]: https://rust-lang.github.io/rust-clippy/master/index.html#invalid_upcast_comparisons\n [`invisible_characters`]: https://rust-lang.github.io/rust-clippy/master/index.html#invisible_characters\n+[`is_digit_ascii_radix`]: https://rust-lang.github.io/rust-clippy/master/index.html#is_digit_ascii_radix\n [`items_after_statements`]: https://rust-lang.github.io/rust-clippy/master/index.html#items_after_statements\n [`iter_cloned_collect`]: https://rust-lang.github.io/rust-clippy/master/index.html#iter_cloned_collect\n [`iter_count`]: https://rust-lang.github.io/rust-clippy/master/index.html#iter_count\n@@ -3372,6 +3478,7 @@ Released 2018-09-13\n [`large_const_arrays`]: https://rust-lang.github.io/rust-clippy/master/index.html#large_const_arrays\n [`large_digit_groups`]: https://rust-lang.github.io/rust-clippy/master/index.html#large_digit_groups\n [`large_enum_variant`]: https://rust-lang.github.io/rust-clippy/master/index.html#large_enum_variant\n+[`large_include_file`]: https://rust-lang.github.io/rust-clippy/master/index.html#large_include_file\n [`large_stack_arrays`]: https://rust-lang.github.io/rust-clippy/master/index.html#large_stack_arrays\n [`large_types_passed_by_value`]: https://rust-lang.github.io/rust-clippy/master/index.html#large_types_passed_by_value\n [`len_without_is_empty`]: https://rust-lang.github.io/rust-clippy/master/index.html#len_without_is_empty\n@@ -3472,6 +3579,7 @@ Released 2018-09-13\n [`needless_lifetimes`]: https://rust-lang.github.io/rust-clippy/master/index.html#needless_lifetimes\n [`needless_match`]: https://rust-lang.github.io/rust-clippy/master/index.html#needless_match\n [`needless_option_as_deref`]: https://rust-lang.github.io/rust-clippy/master/index.html#needless_option_as_deref\n+[`needless_option_take`]: https://rust-lang.github.io/rust-clippy/master/index.html#needless_option_take\n [`needless_pass_by_value`]: https://rust-lang.github.io/rust-clippy/master/index.html#needless_pass_by_value\n [`needless_question_mark`]: https://rust-lang.github.io/rust-clippy/master/index.html#needless_question_mark\n [`needless_range_loop`]: https://rust-lang.github.io/rust-clippy/master/index.html#needless_range_loop\n@@ -3527,6 +3635,7 @@ Released 2018-09-13\n [`ptr_eq`]: https://rust-lang.github.io/rust-clippy/master/index.html#ptr_eq\n [`ptr_offset_with_cast`]: https://rust-lang.github.io/rust-clippy/master/index.html#ptr_offset_with_cast\n [`pub_enum_variant_names`]: https://rust-lang.github.io/rust-clippy/master/index.html#pub_enum_variant_names\n+[`pub_use`]: https://rust-lang.github.io/rust-clippy/master/index.html#pub_use\n [`question_mark`]: https://rust-lang.github.io/rust-clippy/master/index.html#question_mark\n [`range_minus_one`]: https://rust-lang.github.io/rust-clippy/master/index.html#range_minus_one\n [`range_plus_one`]: https://rust-lang.github.io/rust-clippy/master/index.html#range_plus_one\n@@ -3627,6 +3736,7 @@ Released 2018-09-13\n [`transmute_undefined_repr`]: https://rust-lang.github.io/rust-clippy/master/index.html#transmute_undefined_repr\n [`transmutes_expressible_as_ptr_casts`]: https://rust-lang.github.io/rust-clippy/master/index.html#transmutes_expressible_as_ptr_casts\n [`transmuting_null`]: https://rust-lang.github.io/rust-clippy/master/index.html#transmuting_null\n+[`trim_split_whitespace`]: https://rust-lang.github.io/rust-clippy/master/index.html#trim_split_whitespace\n [`trivial_regex`]: https://rust-lang.github.io/rust-clippy/master/index.html#trivial_regex\n [`trivially_copy_pass_by_ref`]: https://rust-lang.github.io/rust-clippy/master/index.html#trivially_copy_pass_by_ref\n [`try_err`]: https://rust-lang.github.io/rust-clippy/master/index.html#try_err\n@@ -3650,6 +3760,7 @@ Released 2018-09-13\n [`unnecessary_lazy_evaluations`]: https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_lazy_evaluations\n [`unnecessary_mut_passed`]: https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_mut_passed\n [`unnecessary_operation`]: https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_operation\n+[`unnecessary_owned_empty_strings`]: https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_owned_empty_strings\n [`unnecessary_self_imports`]: https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_self_imports\n [`unnecessary_sort_by`]: https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_sort_by\n [`unnecessary_to_owned`]: https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_to_owned"}, {"sha": "2cfbcea5034e653beb818b1be5dc89b94b856d2c", "filename": "clippy_dev/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_dev%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_dev%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_dev%2FCargo.toml?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -4,6 +4,7 @@ version = \"0.0.1\"\n edition = \"2021\"\n \n [dependencies]\n+aho-corasick = \"0.7\"\n clap = \"2.33\"\n indoc = \"1.0\"\n itertools = \"0.10.1\""}, {"sha": "81e807cf10c7c3a489e3a601b569714b160fbf66", "filename": "clippy_dev/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_dev%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_dev%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_dev%2Fsrc%2Flib.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -1,3 +1,4 @@\n+#![feature(let_chains)]\n #![feature(let_else)]\n #![feature(once_cell)]\n #![feature(rustc_private)]"}, {"sha": "ebf8f38d4906eae4d15eaf1c3ef6179295216553", "filename": "clippy_dev/src/main.rs", "status": "modified", "additions": 74, "deletions": 10, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_dev%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_dev%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_dev%2Fsrc%2Fmain.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -19,9 +19,9 @@ fn main() {\n             if matches.is_present(\"print-only\") {\n                 update_lints::print_lints();\n             } else if matches.is_present(\"check\") {\n-                update_lints::run(update_lints::UpdateMode::Check);\n+                update_lints::update(update_lints::UpdateMode::Check);\n             } else {\n-                update_lints::run(update_lints::UpdateMode::Change);\n+                update_lints::update(update_lints::UpdateMode::Change);\n             }\n         },\n         (\"new_lint\", Some(matches)) => {\n@@ -31,18 +31,36 @@ fn main() {\n                 matches.value_of(\"category\"),\n                 matches.is_present(\"msrv\"),\n             ) {\n-                Ok(_) => update_lints::run(update_lints::UpdateMode::Change),\n+                Ok(_) => update_lints::update(update_lints::UpdateMode::Change),\n                 Err(e) => eprintln!(\"Unable to create lint: {}\", e),\n             }\n         },\n         (\"setup\", Some(sub_command)) => match sub_command.subcommand() {\n-            (\"intellij\", Some(matches)) => setup::intellij::setup_rustc_src(\n-                matches\n-                    .value_of(\"rustc-repo-path\")\n-                    .expect(\"this field is mandatory and therefore always valid\"),\n-            ),\n-            (\"git-hook\", Some(matches)) => setup::git_hook::install_hook(matches.is_present(\"force-override\")),\n-            (\"vscode-tasks\", Some(matches)) => setup::vscode::install_tasks(matches.is_present(\"force-override\")),\n+            (\"intellij\", Some(matches)) => {\n+                if matches.is_present(\"remove\") {\n+                    setup::intellij::remove_rustc_src();\n+                } else {\n+                    setup::intellij::setup_rustc_src(\n+                        matches\n+                            .value_of(\"rustc-repo-path\")\n+                            .expect(\"this field is mandatory and therefore always valid\"),\n+                    );\n+                }\n+            },\n+            (\"git-hook\", Some(matches)) => {\n+                if matches.is_present(\"remove\") {\n+                    setup::git_hook::remove_hook();\n+                } else {\n+                    setup::git_hook::install_hook(matches.is_present(\"force-override\"));\n+                }\n+            },\n+            (\"vscode-tasks\", Some(matches)) => {\n+                if matches.is_present(\"remove\") {\n+                    setup::vscode::remove_tasks();\n+                } else {\n+                    setup::vscode::install_tasks(matches.is_present(\"force-override\"));\n+                }\n+            },\n             _ => {},\n         },\n         (\"remove\", Some(sub_command)) => match sub_command.subcommand() {\n@@ -60,6 +78,12 @@ fn main() {\n             let path = matches.value_of(\"path\").unwrap();\n             lint::run(path);\n         },\n+        (\"rename_lint\", Some(matches)) => {\n+            let old_name = matches.value_of(\"old_name\").unwrap();\n+            let new_name = matches.value_of(\"new_name\").unwrap_or(old_name);\n+            let uplift = matches.is_present(\"uplift\");\n+            update_lints::rename(old_name, new_name, uplift);\n+        },\n         _ => {},\n     }\n }\n@@ -167,19 +191,32 @@ fn get_clap_config<'a>() -> ArgMatches<'a> {\n                 .subcommand(\n                     SubCommand::with_name(\"intellij\")\n                         .about(\"Alter dependencies so Intellij Rust can find rustc internals\")\n+                        .arg(\n+                            Arg::with_name(\"remove\")\n+                                .long(\"remove\")\n+                                .help(\"Remove the dependencies added with 'cargo dev setup intellij'\")\n+                                .required(false),\n+                        )\n                         .arg(\n                             Arg::with_name(\"rustc-repo-path\")\n                                 .long(\"repo-path\")\n                                 .short(\"r\")\n                                 .help(\"The path to a rustc repo that will be used for setting the dependencies\")\n                                 .takes_value(true)\n                                 .value_name(\"path\")\n+                                .conflicts_with(\"remove\")\n                                 .required(true),\n                         ),\n                 )\n                 .subcommand(\n                     SubCommand::with_name(\"git-hook\")\n                         .about(\"Add a pre-commit git hook that formats your code to make it look pretty\")\n+                        .arg(\n+                            Arg::with_name(\"remove\")\n+                                .long(\"remove\")\n+                                .help(\"Remove the pre-commit hook added with 'cargo dev setup git-hook'\")\n+                                .required(false),\n+                        )\n                         .arg(\n                             Arg::with_name(\"force-override\")\n                                 .long(\"force-override\")\n@@ -191,6 +228,12 @@ fn get_clap_config<'a>() -> ArgMatches<'a> {\n                 .subcommand(\n                     SubCommand::with_name(\"vscode-tasks\")\n                         .about(\"Add several tasks to vscode for formatting, validation and testing\")\n+                        .arg(\n+                            Arg::with_name(\"remove\")\n+                                .long(\"remove\")\n+                                .help(\"Remove the tasks added with 'cargo dev setup vscode-tasks'\")\n+                                .required(false),\n+                        )\n                         .arg(\n                             Arg::with_name(\"force-override\")\n                                 .long(\"force-override\")\n@@ -242,5 +285,26 @@ fn get_clap_config<'a>() -> ArgMatches<'a> {\n                         .help(\"The path to a file or package directory to lint\"),\n                 ),\n         )\n+        .subcommand(\n+            SubCommand::with_name(\"rename_lint\")\n+                .about(\"Renames the given lint\")\n+                .arg(\n+                    Arg::with_name(\"old_name\")\n+                        .index(1)\n+                        .required(true)\n+                        .help(\"The name of the lint to rename\"),\n+                )\n+                .arg(\n+                    Arg::with_name(\"new_name\")\n+                        .index(2)\n+                        .required_unless(\"uplift\")\n+                        .help(\"The new name of the lint\"),\n+                )\n+                .arg(\n+                    Arg::with_name(\"uplift\")\n+                        .long(\"uplift\")\n+                        .help(\"This lint will be uplifted into rustc\"),\n+                ),\n+        )\n         .get_matches()\n }"}, {"sha": "10f67d301f887d5893974cdf2e8292da2f230007", "filename": "clippy_dev/src/new_lint.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_dev%2Fsrc%2Fnew_lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_dev%2Fsrc%2Fnew_lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_dev%2Fsrc%2Fnew_lint.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -1,5 +1,6 @@\n use crate::clippy_project_root;\n use indoc::indoc;\n+use std::fmt::Write as _;\n use std::fs::{self, OpenOptions};\n use std::io::prelude::*;\n use std::io::{self, ErrorKind};\n@@ -232,7 +233,8 @@ fn get_lint_file_contents(lint: &LintData<'_>, enable_msrv: bool) -> String {\n         )\n     });\n \n-    result.push_str(&format!(\n+    let _ = write!(\n+        result,\n         indoc! {r#\"\n             declare_clippy_lint! {{\n                 /// ### What it does\n@@ -256,7 +258,7 @@ fn get_lint_file_contents(lint: &LintData<'_>, enable_msrv: bool) -> String {\n         version = version,\n         name_upper = name_upper,\n         category = category,\n-    ));\n+    );\n \n     result.push_str(&if enable_msrv {\n         format!("}, {"sha": "f691ae4fa45da22e67d8700894b2365db3d4fad2", "filename": "clippy_dev/src/setup/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_dev%2Fsrc%2Fsetup%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_dev%2Fsrc%2Fsetup%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_dev%2Fsrc%2Fsetup%2Fmod.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -7,7 +7,7 @@ use std::path::Path;\n const CLIPPY_DEV_DIR: &str = \"clippy_dev\";\n \n /// This function verifies that the tool is being executed in the clippy directory.\n-/// This is useful to ensure that setups only modify Clippys resources. The verification\n+/// This is useful to ensure that setups only modify Clippy's resources. The verification\n /// is done by checking that `clippy_dev` is a sub directory of the current directory.\n ///\n /// It will print an error message and return `false` if the directory could not be\n@@ -17,7 +17,7 @@ fn verify_inside_clippy_dir() -> bool {\n     if path.exists() && path.is_dir() {\n         true\n     } else {\n-        eprintln!(\"error: unable to verify that the working directory is clippys directory\");\n+        eprintln!(\"error: unable to verify that the working directory is clippy's directory\");\n         false\n     }\n }"}, {"sha": "1a6a4336da27e2c2955fcf48a828e7138cd9a95b", "filename": "clippy_dev/src/update_lints.rs", "status": "modified", "additions": 374, "deletions": 31, "changes": 405, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_dev%2Fsrc%2Fupdate_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_dev%2Fsrc%2Fupdate_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_dev%2Fsrc%2Fupdate_lints.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -1,11 +1,13 @@\n-use core::fmt::Write;\n+use aho_corasick::AhoCorasickBuilder;\n+use core::fmt::Write as _;\n use itertools::Itertools;\n use rustc_lexer::{tokenize, unescape, LiteralKind, TokenKind};\n-use std::collections::HashMap;\n+use std::collections::{HashMap, HashSet};\n use std::ffi::OsStr;\n use std::fs;\n-use std::path::Path;\n-use walkdir::WalkDir;\n+use std::io::{self, Read as _, Seek as _, Write as _};\n+use std::path::{Path, PathBuf};\n+use walkdir::{DirEntry, WalkDir};\n \n use crate::clippy_project_root;\n \n@@ -30,12 +32,19 @@ pub enum UpdateMode {\n /// # Panics\n ///\n /// Panics if a file path could not read from or then written to\n-#[allow(clippy::too_many_lines)]\n-pub fn run(update_mode: UpdateMode) {\n-    let (lints, deprecated_lints) = gather_all();\n+pub fn update(update_mode: UpdateMode) {\n+    let (lints, deprecated_lints, renamed_lints) = gather_all();\n+    generate_lint_files(update_mode, &lints, &deprecated_lints, &renamed_lints);\n+}\n \n-    let internal_lints = Lint::internal_lints(&lints);\n-    let usable_lints = Lint::usable_lints(&lints);\n+fn generate_lint_files(\n+    update_mode: UpdateMode,\n+    lints: &[Lint],\n+    deprecated_lints: &[DeprecatedLint],\n+    renamed_lints: &[RenamedLint],\n+) {\n+    let internal_lints = Lint::internal_lints(lints);\n+    let usable_lints = Lint::usable_lints(lints);\n     let mut sorted_usable_lints = usable_lints.clone();\n     sorted_usable_lints.sort_by_key(|lint| lint.name.clone());\n \n@@ -87,7 +96,7 @@ pub fn run(update_mode: UpdateMode) {\n     process_file(\n         \"clippy_lints/src/lib.deprecated.rs\",\n         update_mode,\n-        &gen_deprecated(&deprecated_lints),\n+        &gen_deprecated(deprecated_lints),\n     );\n \n     let all_group_lints = usable_lints.iter().filter(|l| {\n@@ -107,10 +116,16 @@ pub fn run(update_mode: UpdateMode) {\n             &content,\n         );\n     }\n+\n+    let content = gen_deprecated_lints_test(deprecated_lints);\n+    process_file(\"tests/ui/deprecated.rs\", update_mode, &content);\n+\n+    let content = gen_renamed_lints_test(renamed_lints);\n+    process_file(\"tests/ui/rename.rs\", update_mode, &content);\n }\n \n pub fn print_lints() {\n-    let (lint_list, _) = gather_all();\n+    let (lint_list, _, _) = gather_all();\n     let usable_lints = Lint::usable_lints(&lint_list);\n     let usable_lint_count = usable_lints.len();\n     let grouped_by_lint_group = Lint::by_lint_group(usable_lints.into_iter());\n@@ -128,6 +143,209 @@ pub fn print_lints() {\n     println!(\"there are {} lints\", usable_lint_count);\n }\n \n+/// Runs the `rename_lint` command.\n+///\n+/// This does the following:\n+/// * Adds an entry to `renamed_lints.rs`.\n+/// * Renames all lint attributes to the new name (e.g. `#[allow(clippy::lint_name)]`).\n+/// * Renames the lint struct to the new name.\n+/// * Renames the module containing the lint struct to the new name if it shares a name with the\n+///   lint.\n+///\n+/// # Panics\n+/// Panics for the following conditions:\n+/// * If a file path could not read from or then written to\n+/// * If either lint name has a prefix\n+/// * If `old_name` doesn't name an existing lint.\n+/// * If `old_name` names a deprecated or renamed lint.\n+#[allow(clippy::too_many_lines)]\n+pub fn rename(old_name: &str, new_name: &str, uplift: bool) {\n+    if let Some((prefix, _)) = old_name.split_once(\"::\") {\n+        panic!(\"`{}` should not contain the `{}` prefix\", old_name, prefix);\n+    }\n+    if let Some((prefix, _)) = new_name.split_once(\"::\") {\n+        panic!(\"`{}` should not contain the `{}` prefix\", new_name, prefix);\n+    }\n+\n+    let (mut lints, deprecated_lints, mut renamed_lints) = gather_all();\n+    let mut old_lint_index = None;\n+    let mut found_new_name = false;\n+    for (i, lint) in lints.iter().enumerate() {\n+        if lint.name == old_name {\n+            old_lint_index = Some(i);\n+        } else if lint.name == new_name {\n+            found_new_name = true;\n+        }\n+    }\n+    let old_lint_index = old_lint_index.unwrap_or_else(|| panic!(\"could not find lint `{}`\", old_name));\n+\n+    let lint = RenamedLint {\n+        old_name: format!(\"clippy::{}\", old_name),\n+        new_name: if uplift {\n+            new_name.into()\n+        } else {\n+            format!(\"clippy::{}\", new_name)\n+        },\n+    };\n+\n+    // Renamed lints and deprecated lints shouldn't have been found in the lint list, but check just in\n+    // case.\n+    assert!(\n+        !renamed_lints.iter().any(|l| lint.old_name == l.old_name),\n+        \"`{}` has already been renamed\",\n+        old_name\n+    );\n+    assert!(\n+        !deprecated_lints.iter().any(|l| lint.old_name == l.name),\n+        \"`{}` has already been deprecated\",\n+        old_name\n+    );\n+\n+    // Update all lint level attributes. (`clippy::lint_name`)\n+    for file in WalkDir::new(clippy_project_root())\n+        .into_iter()\n+        .map(Result::unwrap)\n+        .filter(|f| {\n+            let name = f.path().file_name();\n+            let ext = f.path().extension();\n+            (ext == Some(OsStr::new(\"rs\")) || ext == Some(OsStr::new(\"fixed\")))\n+                && name != Some(OsStr::new(\"rename.rs\"))\n+                && name != Some(OsStr::new(\"renamed_lints.rs\"))\n+        })\n+    {\n+        rewrite_file(file.path(), |s| {\n+            replace_ident_like(s, &[(&lint.old_name, &lint.new_name)])\n+        });\n+    }\n+\n+    renamed_lints.push(lint);\n+    renamed_lints.sort_by(|lhs, rhs| {\n+        lhs.new_name\n+            .starts_with(\"clippy::\")\n+            .cmp(&rhs.new_name.starts_with(\"clippy::\"))\n+            .reverse()\n+            .then_with(|| lhs.old_name.cmp(&rhs.old_name))\n+    });\n+\n+    write_file(\n+        Path::new(\"clippy_lints/src/renamed_lints.rs\"),\n+        &gen_renamed_lints_list(&renamed_lints),\n+    );\n+\n+    if uplift {\n+        write_file(Path::new(\"tests/ui/rename.rs\"), &gen_renamed_lints_test(&renamed_lints));\n+        println!(\n+            \"`{}` has be uplifted. All the code inside `clippy_lints` related to it needs to be removed manually.\",\n+            old_name\n+        );\n+    } else if found_new_name {\n+        write_file(Path::new(\"tests/ui/rename.rs\"), &gen_renamed_lints_test(&renamed_lints));\n+        println!(\n+            \"`{}` is already defined. The old linting code inside `clippy_lints` needs to be updated/removed manually.\",\n+            new_name\n+        );\n+    } else {\n+        // Rename the lint struct and source files sharing a name with the lint.\n+        let lint = &mut lints[old_lint_index];\n+        let old_name_upper = old_name.to_uppercase();\n+        let new_name_upper = new_name.to_uppercase();\n+        lint.name = new_name.into();\n+\n+        // Rename test files. only rename `.stderr` and `.fixed` files if the new test name doesn't exist.\n+        if try_rename_file(\n+            Path::new(&format!(\"tests/ui/{}.rs\", old_name)),\n+            Path::new(&format!(\"tests/ui/{}.rs\", new_name)),\n+        ) {\n+            try_rename_file(\n+                Path::new(&format!(\"tests/ui/{}.stderr\", old_name)),\n+                Path::new(&format!(\"tests/ui/{}.stderr\", new_name)),\n+            );\n+            try_rename_file(\n+                Path::new(&format!(\"tests/ui/{}.fixed\", old_name)),\n+                Path::new(&format!(\"tests/ui/{}.fixed\", new_name)),\n+            );\n+        }\n+\n+        // Try to rename the file containing the lint if the file name matches the lint's name.\n+        let replacements;\n+        let replacements = if lint.module == old_name\n+            && try_rename_file(\n+                Path::new(&format!(\"clippy_lints/src/{}.rs\", old_name)),\n+                Path::new(&format!(\"clippy_lints/src/{}.rs\", new_name)),\n+            ) {\n+            // Edit the module name in the lint list. Note there could be multiple lints.\n+            for lint in lints.iter_mut().filter(|l| l.module == old_name) {\n+                lint.module = new_name.into();\n+            }\n+            replacements = [(&*old_name_upper, &*new_name_upper), (old_name, new_name)];\n+            replacements.as_slice()\n+        } else if !lint.module.contains(\"::\")\n+            // Catch cases like `methods/lint_name.rs` where the lint is stored in `methods/mod.rs`\n+            && try_rename_file(\n+                Path::new(&format!(\"clippy_lints/src/{}/{}.rs\", lint.module, old_name)),\n+                Path::new(&format!(\"clippy_lints/src/{}/{}.rs\", lint.module, new_name)),\n+            )\n+        {\n+            // Edit the module name in the lint list. Note there could be multiple lints, or none.\n+            let renamed_mod = format!(\"{}::{}\", lint.module, old_name);\n+            for lint in lints.iter_mut().filter(|l| l.module == renamed_mod) {\n+                lint.module = format!(\"{}::{}\", lint.module, new_name);\n+            }\n+            replacements = [(&*old_name_upper, &*new_name_upper), (old_name, new_name)];\n+            replacements.as_slice()\n+        } else {\n+            replacements = [(&*old_name_upper, &*new_name_upper), (\"\", \"\")];\n+            &replacements[0..1]\n+        };\n+\n+        // Don't change `clippy_utils/src/renamed_lints.rs` here as it would try to edit the lint being\n+        // renamed.\n+        for (_, file) in clippy_lints_src_files().filter(|(rel_path, _)| rel_path != OsStr::new(\"renamed_lints.rs\")) {\n+            rewrite_file(file.path(), |s| replace_ident_like(s, replacements));\n+        }\n+\n+        generate_lint_files(UpdateMode::Change, &lints, &deprecated_lints, &renamed_lints);\n+        println!(\"{} has been successfully renamed\", old_name);\n+    }\n+\n+    println!(\"note: `cargo uitest` still needs to be run to update the test results\");\n+}\n+\n+/// Replace substrings if they aren't bordered by identifier characters. Returns `None` if there\n+/// were no replacements.\n+fn replace_ident_like(contents: &str, replacements: &[(&str, &str)]) -> Option<String> {\n+    fn is_ident_char(c: u8) -> bool {\n+        matches!(c, b'a'..=b'z' | b'A'..=b'Z' | b'0'..=b'9' | b'_')\n+    }\n+\n+    let searcher = AhoCorasickBuilder::new()\n+        .dfa(true)\n+        .match_kind(aho_corasick::MatchKind::LeftmostLongest)\n+        .build_with_size::<u16, _, _>(replacements.iter().map(|&(x, _)| x.as_bytes()))\n+        .unwrap();\n+\n+    let mut result = String::with_capacity(contents.len() + 1024);\n+    let mut pos = 0;\n+    let mut edited = false;\n+    for m in searcher.find_iter(contents) {\n+        let (old, new) = replacements[m.pattern()];\n+        result.push_str(&contents[pos..m.start()]);\n+        result.push_str(\n+            if !is_ident_char(contents.as_bytes().get(m.start().wrapping_sub(1)).copied().unwrap_or(0))\n+                && !is_ident_char(contents.as_bytes().get(m.end()).copied().unwrap_or(0))\n+            {\n+                edited = true;\n+                new\n+            } else {\n+                old\n+            },\n+        );\n+        pos = m.end();\n+    }\n+    result.push_str(&contents[pos..]);\n+    edited.then(|| result)\n+}\n+\n fn round_to_fifty(count: usize) -> usize {\n     count / 50 * 50\n }\n@@ -210,19 +428,33 @@ impl DeprecatedLint {\n     }\n }\n \n+struct RenamedLint {\n+    old_name: String,\n+    new_name: String,\n+}\n+impl RenamedLint {\n+    fn new(old_name: &str, new_name: &str) -> Self {\n+        Self {\n+            old_name: remove_line_splices(old_name),\n+            new_name: remove_line_splices(new_name),\n+        }\n+    }\n+}\n+\n /// Generates the code for registering a group\n fn gen_lint_group_list<'a>(group_name: &str, lints: impl Iterator<Item = &'a Lint>) -> String {\n     let mut details: Vec<_> = lints.map(|l| (&l.module, l.name.to_uppercase())).collect();\n     details.sort_unstable();\n \n     let mut output = GENERATED_FILE_COMMENT.to_string();\n \n-    output.push_str(&format!(\n-        \"store.register_group(true, \\\"clippy::{0}\\\", Some(\\\"clippy_{0}\\\"), vec![\\n\",\n+    let _ = writeln!(\n+        output,\n+        \"store.register_group(true, \\\"clippy::{0}\\\", Some(\\\"clippy_{0}\\\"), vec![\",\n         group_name\n-    ));\n+    );\n     for (module, name) in details {\n-        output.push_str(&format!(\"    LintId::of({}::{}),\\n\", module, name));\n+        let _ = writeln!(output, \"    LintId::of({}::{}),\", module, name);\n     }\n     output.push_str(\"])\\n\");\n \n@@ -235,15 +467,16 @@ fn gen_deprecated(lints: &[DeprecatedLint]) -> String {\n     let mut output = GENERATED_FILE_COMMENT.to_string();\n     output.push_str(\"{\\n\");\n     for lint in lints {\n-        output.push_str(&format!(\n+        let _ = write!(\n+            output,\n             concat!(\n                 \"    store.register_removed(\\n\",\n                 \"        \\\"clippy::{}\\\",\\n\",\n                 \"        \\\"{}\\\",\\n\",\n                 \"    );\\n\"\n             ),\n             lint.name, lint.reason,\n-        ));\n+        );\n     }\n     output.push_str(\"}\\n\");\n \n@@ -269,25 +502,62 @@ fn gen_register_lint_list<'a>(\n         if !is_public {\n             output.push_str(\"    #[cfg(feature = \\\"internal\\\")]\\n\");\n         }\n-        output.push_str(&format!(\"    {}::{},\\n\", module_name, lint_name));\n+        let _ = writeln!(output, \"    {}::{},\", module_name, lint_name);\n     }\n     output.push_str(\"])\\n\");\n \n     output\n }\n \n+fn gen_deprecated_lints_test(lints: &[DeprecatedLint]) -> String {\n+    let mut res: String = GENERATED_FILE_COMMENT.into();\n+    for lint in lints {\n+        writeln!(res, \"#![warn(clippy::{})]\", lint.name).unwrap();\n+    }\n+    res.push_str(\"\\nfn main() {}\\n\");\n+    res\n+}\n+\n+fn gen_renamed_lints_test(lints: &[RenamedLint]) -> String {\n+    let mut seen_lints = HashSet::new();\n+    let mut res: String = GENERATED_FILE_COMMENT.into();\n+    res.push_str(\"// run-rustfix\\n\\n\");\n+    for lint in lints {\n+        if seen_lints.insert(&lint.new_name) {\n+            writeln!(res, \"#![allow({})]\", lint.new_name).unwrap();\n+        }\n+    }\n+    seen_lints.clear();\n+    for lint in lints {\n+        if seen_lints.insert(&lint.old_name) {\n+            writeln!(res, \"#![warn({})]\", lint.old_name).unwrap();\n+        }\n+    }\n+    res.push_str(\"\\nfn main() {}\\n\");\n+    res\n+}\n+\n+fn gen_renamed_lints_list(lints: &[RenamedLint]) -> String {\n+    const HEADER: &str = \"\\\n+        // This file is managed by `cargo dev rename_lint`. Prefer using that when possible.\\n\\n\\\n+        #[rustfmt::skip]\\n\\\n+        pub static RENAMED_LINTS: &[(&str, &str)] = &[\\n\";\n+\n+    let mut res = String::from(HEADER);\n+    for lint in lints {\n+        writeln!(res, \"    (\\\"{}\\\", \\\"{}\\\"),\", lint.old_name, lint.new_name).unwrap();\n+    }\n+    res.push_str(\"];\\n\");\n+    res\n+}\n+\n /// Gathers all lints defined in `clippy_lints/src`\n-fn gather_all() -> (Vec<Lint>, Vec<DeprecatedLint>) {\n+fn gather_all() -> (Vec<Lint>, Vec<DeprecatedLint>, Vec<RenamedLint>) {\n     let mut lints = Vec::with_capacity(1000);\n     let mut deprecated_lints = Vec::with_capacity(50);\n-    let root_path = clippy_project_root().join(\"clippy_lints/src\");\n+    let mut renamed_lints = Vec::with_capacity(50);\n \n-    for (rel_path, file) in WalkDir::new(&root_path)\n-        .into_iter()\n-        .map(Result::unwrap)\n-        .filter(|f| f.path().extension() == Some(OsStr::new(\"rs\")))\n-        .map(|f| (f.path().strip_prefix(&root_path).unwrap().to_path_buf(), f))\n-    {\n+    for (rel_path, file) in clippy_lints_src_files() {\n         let path = file.path();\n         let contents =\n             fs::read_to_string(path).unwrap_or_else(|e| panic!(\"Cannot read from `{}`: {}\", path.display(), e));\n@@ -305,13 +575,21 @@ fn gather_all() -> (Vec<Lint>, Vec<DeprecatedLint>) {\n             module.strip_suffix(\".rs\").unwrap_or(&module)\n         };\n \n-        if module == \"deprecated_lints\" {\n-            parse_deprecated_contents(&contents, &mut deprecated_lints);\n-        } else {\n-            parse_contents(&contents, module, &mut lints);\n+        match module {\n+            \"deprecated_lints\" => parse_deprecated_contents(&contents, &mut deprecated_lints),\n+            \"renamed_lints\" => parse_renamed_contents(&contents, &mut renamed_lints),\n+            _ => parse_contents(&contents, module, &mut lints),\n         }\n     }\n-    (lints, deprecated_lints)\n+    (lints, deprecated_lints, renamed_lints)\n+}\n+\n+fn clippy_lints_src_files() -> impl Iterator<Item = (PathBuf, DirEntry)> {\n+    let root_path = clippy_project_root().join(\"clippy_lints/src\");\n+    let iter = WalkDir::new(&root_path).into_iter();\n+    iter.map(Result::unwrap)\n+        .filter(|f| f.path().extension() == Some(OsStr::new(\"rs\")))\n+        .map(move |f| (f.path().strip_prefix(&root_path).unwrap().to_path_buf(), f))\n }\n \n macro_rules! match_tokens {\n@@ -394,6 +672,25 @@ fn parse_deprecated_contents(contents: &str, lints: &mut Vec<DeprecatedLint>) {\n     }\n }\n \n+fn parse_renamed_contents(contents: &str, lints: &mut Vec<RenamedLint>) {\n+    for line in contents.lines() {\n+        let mut offset = 0usize;\n+        let mut iter = tokenize(line).map(|t| {\n+            let range = offset..offset + t.len;\n+            offset = range.end;\n+            (t.kind, &line[range])\n+        });\n+        let (old_name, new_name) = match_tokens!(\n+            iter,\n+            // (\"old_name\",\n+            Whitespace OpenParen Literal{kind: LiteralKind::Str{..},..}(old_name) Comma\n+            // \"new_name\"),\n+            Whitespace Literal{kind: LiteralKind::Str{..},..}(new_name) CloseParen Comma\n+        );\n+        lints.push(RenamedLint::new(old_name, new_name));\n+    }\n+}\n+\n /// Removes the line splices and surrounding quotes from a string literal\n fn remove_line_splices(s: &str) -> String {\n     let s = s\n@@ -462,6 +759,52 @@ fn replace_region_in_text<'a>(\n     Ok(res)\n }\n \n+fn try_rename_file(old_name: &Path, new_name: &Path) -> bool {\n+    match fs::OpenOptions::new().create_new(true).write(true).open(new_name) {\n+        Ok(file) => drop(file),\n+        Err(e) if matches!(e.kind(), io::ErrorKind::AlreadyExists | io::ErrorKind::NotFound) => return false,\n+        Err(e) => panic_file(e, new_name, \"create\"),\n+    };\n+    match fs::rename(old_name, new_name) {\n+        Ok(()) => true,\n+        Err(e) => {\n+            drop(fs::remove_file(new_name));\n+            if e.kind() == io::ErrorKind::NotFound {\n+                false\n+            } else {\n+                panic_file(e, old_name, \"rename\");\n+            }\n+        },\n+    }\n+}\n+\n+#[allow(clippy::needless_pass_by_value)]\n+fn panic_file(error: io::Error, name: &Path, action: &str) -> ! {\n+    panic!(\"failed to {} file `{}`: {}\", action, name.display(), error)\n+}\n+\n+fn rewrite_file(path: &Path, f: impl FnOnce(&str) -> Option<String>) {\n+    let mut file = fs::OpenOptions::new()\n+        .write(true)\n+        .read(true)\n+        .open(path)\n+        .unwrap_or_else(|e| panic_file(e, path, \"open\"));\n+    let mut buf = String::new();\n+    file.read_to_string(&mut buf)\n+        .unwrap_or_else(|e| panic_file(e, path, \"read\"));\n+    if let Some(new_contents) = f(&buf) {\n+        file.rewind().unwrap_or_else(|e| panic_file(e, path, \"write\"));\n+        file.write_all(new_contents.as_bytes())\n+            .unwrap_or_else(|e| panic_file(e, path, \"write\"));\n+        file.set_len(new_contents.len() as u64)\n+            .unwrap_or_else(|e| panic_file(e, path, \"write\"));\n+    }\n+}\n+\n+fn write_file(path: &Path, contents: &str) {\n+    fs::write(path, contents).unwrap_or_else(|e| panic_file(e, path, \"write\"));\n+}\n+\n #[cfg(test)]\n mod tests {\n     use super::*;"}, {"sha": "8b0e11cb802eeae0996551e3c588f45688d096bc", "filename": "clippy_lints/src/attrs.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fattrs.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -6,7 +6,7 @@ use clippy_utils::msrvs;\n use clippy_utils::source::{first_line_of_span, is_present_in_source, snippet_opt, without_block_comments};\n use clippy_utils::{extract_msrv_attr, meets_msrv};\n use if_chain::if_chain;\n-use rustc_ast::{AttrKind, AttrStyle, Attribute, Lit, LitKind, MetaItemKind, NestedMetaItem};\n+use rustc_ast::{AttrKind, AttrStyle, Attribute, Lit, LitKind, MacArgs, MacArgsEq, MetaItemKind, NestedMetaItem};\n use rustc_errors::Applicability;\n use rustc_hir::{\n     Block, Expr, ExprKind, ImplItem, ImplItemKind, Item, ItemKind, StmtKind, TraitFn, TraitItem, TraitItemKind,\n@@ -335,20 +335,19 @@ impl<'tcx> LateLintPass<'tcx> for Attributes {\n                     }\n                     if let Some(lint_list) = &attr.meta_item_list() {\n                         if attr.ident().map_or(false, |ident| is_lint_level(ident.name)) {\n-                            // permit `unused_imports`, `deprecated`, `unreachable_pub`,\n-                            // `clippy::wildcard_imports`, and `clippy::enum_glob_use` for `use` items\n-                            // and `unused_imports` for `extern crate` items with `macro_use`\n                             for lint in lint_list {\n                                 match item.kind {\n                                     ItemKind::Use(..) => {\n                                         if is_word(lint, sym!(unused_imports))\n                                             || is_word(lint, sym::deprecated)\n                                             || is_word(lint, sym!(unreachable_pub))\n                                             || is_word(lint, sym!(unused))\n-                                            || extract_clippy_lint(lint)\n-                                                .map_or(false, |s| s.as_str() == \"wildcard_imports\")\n-                                            || extract_clippy_lint(lint)\n-                                                .map_or(false, |s| s.as_str() == \"enum_glob_use\")\n+                                            || extract_clippy_lint(lint).map_or(false, |s| {\n+                                                matches!(\n+                                                    s.as_str(),\n+                                                    \"wildcard_imports\" | \"enum_glob_use\" | \"redundant_pub_crate\",\n+                                                )\n+                                            })\n                                         {\n                                             return;\n                                         }\n@@ -594,6 +593,10 @@ fn check_empty_line_after_outer_attr(cx: &EarlyContext<'_>, item: &rustc_ast::It\n         };\n \n         if attr.style == AttrStyle::Outer {\n+            if let MacArgs::Eq(_, MacArgsEq::Ast(expr)) = &attr_item.args\n+                && !matches!(expr.kind, rustc_ast::ExprKind::Lit(..)) {\n+                return;\n+            }\n             if attr_item.args.inner_tokens().is_empty() || !is_present_in_source(cx, attr.span) {\n                 return;\n             }"}, {"sha": "5b7c4591504e1cbaa3710a1cad5b684b4f13efbe", "filename": "clippy_lints/src/await_holding_invalid.rs", "status": "modified", "additions": 129, "deletions": 38, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Fawait_holding_invalid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Fawait_holding_invalid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fawait_holding_invalid.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -1,12 +1,15 @@\n use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::{match_def_path, paths};\n+use rustc_data_structures::fx::FxHashMap;\n use rustc_hir::def_id::DefId;\n-use rustc_hir::{AsyncGeneratorKind, Body, BodyId, GeneratorKind};\n+use rustc_hir::{def::Res, AsyncGeneratorKind, Body, BodyId, GeneratorKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty::GeneratorInteriorTypeCause;\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::Span;\n \n+use crate::utils::conf::DisallowedType;\n+\n declare_clippy_lint! {\n     /// ### What it does\n     /// Checks for calls to await while holding a non-async-aware MutexGuard.\n@@ -127,17 +130,83 @@ declare_clippy_lint! {\n     \"inside an async function, holding a `RefCell` ref while calling `await`\"\n }\n \n-declare_lint_pass!(AwaitHolding => [AWAIT_HOLDING_LOCK, AWAIT_HOLDING_REFCELL_REF]);\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Allows users to configure types which should not be held across `await`\n+    /// suspension points.\n+    ///\n+    /// ### Why is this bad?\n+    /// There are some types which are perfectly \"safe\" to be used concurrently\n+    /// from a memory access perspective but will cause bugs at runtime if they\n+    /// are held in such a way.\n+    ///\n+    /// ### Known problems\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```toml\n+    /// await-holding-invalid-types = [\n+    ///   # You can specify a type name\n+    ///   \"CustomLockType\",\n+    ///   # You can (optionally) specify a reason\n+    ///   { path = \"OtherCustomLockType\", reason = \"Relies on a thread local\" }\n+    /// ]\n+    /// ```\n+    ///\n+    /// ```rust\n+    /// # async fn baz() {}\n+    /// struct CustomLockType;\n+    /// struct OtherCustomLockType;\n+    /// async fn foo() {\n+    ///   let _x = CustomLockType;\n+    ///   let _y = OtherCustomLockType;\n+    ///   baz().await; // Lint violation\n+    /// }\n+    /// ```\n+    #[clippy::version = \"1.49.0\"]\n+    pub AWAIT_HOLDING_INVALID_TYPE,\n+    suspicious,\n+    \"holding a type across an await point which is not allowed to be held as per the configuration\"\n+}\n+\n+impl_lint_pass!(AwaitHolding => [AWAIT_HOLDING_LOCK, AWAIT_HOLDING_REFCELL_REF, AWAIT_HOLDING_INVALID_TYPE]);\n+\n+#[derive(Debug)]\n+pub struct AwaitHolding {\n+    conf_invalid_types: Vec<DisallowedType>,\n+    def_ids: FxHashMap<DefId, DisallowedType>,\n+}\n+\n+impl AwaitHolding {\n+    pub(crate) fn new(conf_invalid_types: Vec<DisallowedType>) -> Self {\n+        Self {\n+            conf_invalid_types,\n+            def_ids: FxHashMap::default(),\n+        }\n+    }\n+}\n \n impl LateLintPass<'_> for AwaitHolding {\n+    fn check_crate(&mut self, cx: &LateContext<'_>) {\n+        for conf in &self.conf_invalid_types {\n+            let path = match conf {\n+                DisallowedType::Simple(path) | DisallowedType::WithReason { path, .. } => path,\n+            };\n+            let segs: Vec<_> = path.split(\"::\").collect();\n+            if let Res::Def(_, id) = clippy_utils::def_path_res(cx, &segs) {\n+                self.def_ids.insert(id, conf.clone());\n+            }\n+        }\n+    }\n+\n     fn check_body(&mut self, cx: &LateContext<'_>, body: &'_ Body<'_>) {\n         use AsyncGeneratorKind::{Block, Closure, Fn};\n         if let Some(GeneratorKind::Async(Block | Closure | Fn)) = body.generator_kind {\n             let body_id = BodyId {\n                 hir_id: body.value.hir_id,\n             };\n             let typeck_results = cx.tcx.typeck_body(body_id);\n-            check_interior_types(\n+            self.check_interior_types(\n                 cx,\n                 typeck_results.generator_interior_types.as_ref().skip_binder(),\n                 body.value.span,\n@@ -146,46 +215,68 @@ impl LateLintPass<'_> for AwaitHolding {\n     }\n }\n \n-fn check_interior_types(cx: &LateContext<'_>, ty_causes: &[GeneratorInteriorTypeCause<'_>], span: Span) {\n-    for ty_cause in ty_causes {\n-        if let rustc_middle::ty::Adt(adt, _) = ty_cause.ty.kind() {\n-            if is_mutex_guard(cx, adt.did()) {\n-                span_lint_and_then(\n-                    cx,\n-                    AWAIT_HOLDING_LOCK,\n-                    ty_cause.span,\n-                    \"this `MutexGuard` is held across an `await` point\",\n-                    |diag| {\n-                        diag.help(\n-                            \"consider using an async-aware `Mutex` type or ensuring the \\\n+impl AwaitHolding {\n+    fn check_interior_types(&self, cx: &LateContext<'_>, ty_causes: &[GeneratorInteriorTypeCause<'_>], span: Span) {\n+        for ty_cause in ty_causes {\n+            if let rustc_middle::ty::Adt(adt, _) = ty_cause.ty.kind() {\n+                if is_mutex_guard(cx, adt.did()) {\n+                    span_lint_and_then(\n+                        cx,\n+                        AWAIT_HOLDING_LOCK,\n+                        ty_cause.span,\n+                        \"this `MutexGuard` is held across an `await` point\",\n+                        |diag| {\n+                            diag.help(\n+                                \"consider using an async-aware `Mutex` type or ensuring the \\\n                                 `MutexGuard` is dropped before calling await\",\n-                        );\n-                        diag.span_note(\n-                            ty_cause.scope_span.unwrap_or(span),\n-                            \"these are all the `await` points this lock is held through\",\n-                        );\n-                    },\n-                );\n-            }\n-            if is_refcell_ref(cx, adt.did()) {\n-                span_lint_and_then(\n-                    cx,\n-                    AWAIT_HOLDING_REFCELL_REF,\n-                    ty_cause.span,\n-                    \"this `RefCell` reference is held across an `await` point\",\n-                    |diag| {\n-                        diag.help(\"ensure the reference is dropped before calling `await`\");\n-                        diag.span_note(\n-                            ty_cause.scope_span.unwrap_or(span),\n-                            \"these are all the `await` points this reference is held through\",\n-                        );\n-                    },\n-                );\n+                            );\n+                            diag.span_note(\n+                                ty_cause.scope_span.unwrap_or(span),\n+                                \"these are all the `await` points this lock is held through\",\n+                            );\n+                        },\n+                    );\n+                } else if is_refcell_ref(cx, adt.did()) {\n+                    span_lint_and_then(\n+                        cx,\n+                        AWAIT_HOLDING_REFCELL_REF,\n+                        ty_cause.span,\n+                        \"this `RefCell` reference is held across an `await` point\",\n+                        |diag| {\n+                            diag.help(\"ensure the reference is dropped before calling `await`\");\n+                            diag.span_note(\n+                                ty_cause.scope_span.unwrap_or(span),\n+                                \"these are all the `await` points this reference is held through\",\n+                            );\n+                        },\n+                    );\n+                } else if let Some(disallowed) = self.def_ids.get(&adt.did()) {\n+                    emit_invalid_type(cx, ty_cause.span, disallowed);\n+                }\n             }\n         }\n     }\n }\n \n+fn emit_invalid_type(cx: &LateContext<'_>, span: Span, disallowed: &DisallowedType) {\n+    let (type_name, reason) = match disallowed {\n+        DisallowedType::Simple(path) => (path, &None),\n+        DisallowedType::WithReason { path, reason } => (path, reason),\n+    };\n+\n+    span_lint_and_then(\n+        cx,\n+        AWAIT_HOLDING_INVALID_TYPE,\n+        span,\n+        &format!(\"`{type_name}` may not be held across an `await` point per `clippy.toml`\",),\n+        |diag| {\n+            if let Some(reason) = reason {\n+                diag.note(reason.clone());\n+            }\n+        },\n+    );\n+}\n+\n fn is_mutex_guard(cx: &LateContext<'_>, def_id: DefId) -> bool {\n     match_def_path(cx, def_id, &paths::MUTEX_GUARD)\n         || match_def_path(cx, def_id, &paths::RWLOCK_READ_GUARD)"}, {"sha": "d70dbf5b23904aa282d7be16b3c025add46f1781", "filename": "clippy_lints/src/bytes_count_to_len.rs", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Fbytes_count_to_len.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Fbytes_count_to_len.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbytes_count_to_len.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -0,0 +1,70 @@\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::source::snippet_with_applicability;\n+use clippy_utils::ty::is_type_diagnostic_item;\n+use clippy_utils::{match_def_path, paths};\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::ty;\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::sym;\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// It checks for `str::bytes().count()` and suggests replacing it with\n+    /// `str::len()`.\n+    ///\n+    /// ### Why is this bad?\n+    /// `str::bytes().count()` is longer and may not be as performant as using\n+    /// `str::len()`.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// \"hello\".bytes().count();\n+    /// String::from(\"hello\").bytes().count();\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// \"hello\".len();\n+    /// String::from(\"hello\").len();\n+    /// ```\n+    #[clippy::version = \"1.62.0\"]\n+    pub BYTES_COUNT_TO_LEN,\n+    complexity,\n+    \"Using `bytes().count()` when `len()` performs the same functionality\"\n+}\n+\n+declare_lint_pass!(BytesCountToLen => [BYTES_COUNT_TO_LEN]);\n+\n+impl<'tcx> LateLintPass<'tcx> for BytesCountToLen {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n+        if_chain! {\n+            if let hir::ExprKind::MethodCall(_, expr_args, _) = &expr.kind;\n+            if let Some(expr_def_id) = cx.typeck_results().type_dependent_def_id(expr.hir_id);\n+            if match_def_path(cx, expr_def_id, &paths::ITER_COUNT);\n+\n+            if let [bytes_expr] = &**expr_args;\n+            if let hir::ExprKind::MethodCall(_, bytes_args, _) = &bytes_expr.kind;\n+            if let Some(bytes_def_id) = cx.typeck_results().type_dependent_def_id(bytes_expr.hir_id);\n+            if match_def_path(cx, bytes_def_id, &paths::STR_BYTES);\n+\n+            if let [str_expr] = &**bytes_args;\n+            let ty = cx.typeck_results().expr_ty(str_expr).peel_refs();\n+\n+            if is_type_diagnostic_item(cx, ty, sym::String) || ty.kind() == &ty::Str;\n+            then {\n+                let mut applicability = Applicability::MachineApplicable;\n+                span_lint_and_sugg(\n+                    cx,\n+                    BYTES_COUNT_TO_LEN,\n+                    expr.span,\n+                    \"using long and hard to read `.bytes().count()`\",\n+                    \"consider calling `.len()` instead\",\n+                    format!(\"{}.len()\", snippet_with_applicability(cx, str_expr.span, \"..\", &mut applicability)),\n+                    applicability\n+                );\n+            }\n+        };\n+    }\n+}"}, {"sha": "7af200708ff0326533b354b5d9801515261e6d0c", "filename": "clippy_lints/src/case_sensitive_file_extension_comparisons.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Fcase_sensitive_file_extension_comparisons.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Fcase_sensitive_file_extension_comparisons.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcase_sensitive_file_extension_comparisons.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -42,8 +42,8 @@ fn check_case_sensitive_file_extension_comparison(ctx: &LateContext<'_>, expr: &\n         if let ExprKind::Lit(Spanned { node: LitKind::Str(ext_literal, ..), ..}) = extension.kind;\n         if (2..=6).contains(&ext_literal.as_str().len());\n         if ext_literal.as_str().starts_with('.');\n-        if ext_literal.as_str().chars().skip(1).all(|c| c.is_uppercase() || c.is_digit(10))\n-            || ext_literal.as_str().chars().skip(1).all(|c| c.is_lowercase() || c.is_digit(10));\n+        if ext_literal.as_str().chars().skip(1).all(|c| c.is_uppercase() || c.is_ascii_digit())\n+            || ext_literal.as_str().chars().skip(1).all(|c| c.is_lowercase() || c.is_ascii_digit());\n         then {\n             let mut ty = ctx.typeck_results().expr_ty(obj);\n             ty = match ty.kind() {"}, {"sha": "64f87c80f8d147a5e3e21aed776582434d465fee", "filename": "clippy_lints/src/casts/cast_possible_truncation.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Fcasts%2Fcast_possible_truncation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Fcasts%2Fcast_possible_truncation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcasts%2Fcast_possible_truncation.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -29,21 +29,19 @@ fn apply_reductions(cx: &LateContext<'_>, nbits: u64, expr: &Expr<'_>, signed: b\n         ExprKind::Block(block, _) => block.expr.map_or(nbits, |e| apply_reductions(cx, nbits, e, signed)),\n         ExprKind::Binary(op, left, right) => match op.node {\n             BinOpKind::Div => {\n-                apply_reductions(cx, nbits, left, signed)\n-                    - (if signed {\n-                        0 // let's be conservative here\n-                    } else {\n-                        // by dividing by 1, we remove 0 bits, etc.\n-                        get_constant_bits(cx, right).map_or(0, |b| b.saturating_sub(1))\n-                    })\n+                apply_reductions(cx, nbits, left, signed).saturating_sub(if signed {\n+                    // let's be conservative here\n+                    0\n+                } else {\n+                    // by dividing by 1, we remove 0 bits, etc.\n+                    get_constant_bits(cx, right).map_or(0, |b| b.saturating_sub(1))\n+                })\n             },\n             BinOpKind::Rem | BinOpKind::BitAnd => get_constant_bits(cx, right)\n                 .unwrap_or(u64::max_value())\n                 .min(apply_reductions(cx, nbits, left, signed)),\n-            BinOpKind::Shr => {\n-                apply_reductions(cx, nbits, left, signed)\n-                    - constant_int(cx, right).map_or(0, |s| u64::try_from(s).expect(\"shift too high\"))\n-            },\n+            BinOpKind::Shr => apply_reductions(cx, nbits, left, signed)\n+                .saturating_sub(constant_int(cx, right).map_or(0, |s| u64::try_from(s).expect(\"shift too high\"))),\n             _ => nbits,\n         },\n         ExprKind::MethodCall(method, [left, right], _) => {"}, {"sha": "2238668abca71d464e9f8f0be73600d1b95140a2", "filename": "clippy_lints/src/casts/cast_slice_different_sizes.rs", "status": "modified", "additions": 68, "deletions": 42, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Fcasts%2Fcast_slice_different_sizes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Fcasts%2Fcast_slice_different_sizes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcasts%2Fcast_slice_different_sizes.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -1,4 +1,4 @@\n-use clippy_utils::{diagnostics::span_lint_and_then, meets_msrv, msrvs, source::snippet_opt};\n+use clippy_utils::{diagnostics::span_lint_and_then, meets_msrv, msrvs, source};\n use if_chain::if_chain;\n use rustc_ast::Mutability;\n use rustc_hir::{Expr, ExprKind, Node};\n@@ -8,32 +8,7 @@ use rustc_semver::RustcVersion;\n \n use super::CAST_SLICE_DIFFERENT_SIZES;\n \n-fn is_child_of_cast(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n-    let map = cx.tcx.hir();\n-    if_chain! {\n-        if let Some(parent_id) = map.find_parent_node(expr.hir_id);\n-        if let Some(parent) = map.find(parent_id);\n-        then {\n-            let expr = match parent {\n-                Node::Block(block) => {\n-                    if let Some(parent_expr) = block.expr {\n-                        parent_expr\n-                    } else {\n-                        return false;\n-                    }\n-                },\n-                Node::Expr(expr) => expr,\n-                _ => return false,\n-            };\n-\n-            matches!(expr.kind, ExprKind::Cast(..))\n-        } else {\n-            false\n-        }\n-    }\n-}\n-\n-pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>, msrv: &Option<RustcVersion>) {\n+pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'tcx>, msrv: &Option<RustcVersion>) {\n     // suggestion is invalid if `ptr::slice_from_raw_parts` does not exist\n     if !meets_msrv(msrv.as_ref(), &msrvs::PTR_SLICE_RAW_PARTS) {\n         return;\n@@ -45,8 +20,13 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>, msrv: &Option<RustcVe\n         return;\n     }\n \n-    if let Some((from_slice_ty, to_slice_ty)) = expr_cast_chain_tys(cx, expr) {\n-        if let (Ok(from_layout), Ok(to_layout)) = (cx.layout_of(from_slice_ty.ty), cx.layout_of(to_slice_ty.ty)) {\n+    if let Some(CastChainInfo {\n+        left_cast,\n+        start_ty,\n+        end_ty,\n+    }) = expr_cast_chain_tys(cx, expr)\n+    {\n+        if let (Ok(from_layout), Ok(to_layout)) = (cx.layout_of(start_ty.ty), cx.layout_of(end_ty.ty)) {\n             let from_size = from_layout.size.bytes();\n             let to_size = to_layout.size.bytes();\n             if from_size != to_size && from_size != 0 && to_size != 0 {\n@@ -56,21 +36,20 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>, msrv: &Option<RustcVe\n                     expr.span,\n                     &format!(\n                         \"casting between raw pointers to `[{}]` (element size {}) and `[{}]` (element size {}) does not adjust the count\",\n-                        from_slice_ty, from_size, to_slice_ty, to_size,\n+                        start_ty.ty, from_size, end_ty.ty, to_size,\n                     ),\n                     |diag| {\n-                        let cast_expr = match expr.kind {\n-                            ExprKind::Cast(cast_expr, ..) => cast_expr,\n-                            _ => unreachable!(\"expr should be a cast as checked by expr_cast_chain_tys\"),\n-                        };\n-                        let ptr_snippet = snippet_opt(cx, cast_expr.span).unwrap();\n+                        let ptr_snippet = source::snippet(cx, left_cast.span, \"..\");\n \n-                        let (mutbl_fn_str, mutbl_ptr_str) = match to_slice_ty.mutbl {\n+                        let (mutbl_fn_str, mutbl_ptr_str) = match end_ty.mutbl {\n                             Mutability::Mut => (\"_mut\", \"mut\"),\n                             Mutability::Not => (\"\", \"const\"),\n                         };\n                         let sugg = format!(\n-                            \"core::ptr::slice_from_raw_parts{mutbl_fn_str}({ptr_snippet} as *{mutbl_ptr_str} {to_slice_ty}, ..)\"\n+                            \"core::ptr::slice_from_raw_parts{mutbl_fn_str}({ptr_snippet} as *{mutbl_ptr_str} {}, ..)\",\n+                            // get just the ty from the TypeAndMut so that the printed type isn't something like `mut\n+                            // T`, extract just the `T`\n+                            end_ty.ty\n                         );\n \n                         diag.span_suggestion(\n@@ -86,6 +65,31 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>, msrv: &Option<RustcVe\n     }\n }\n \n+fn is_child_of_cast(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n+    let map = cx.tcx.hir();\n+    if_chain! {\n+        if let Some(parent_id) = map.find_parent_node(expr.hir_id);\n+        if let Some(parent) = map.find(parent_id);\n+        then {\n+            let expr = match parent {\n+                Node::Block(block) => {\n+                    if let Some(parent_expr) = block.expr {\n+                        parent_expr\n+                    } else {\n+                        return false;\n+                    }\n+                },\n+                Node::Expr(expr) => expr,\n+                _ => return false,\n+            };\n+\n+            matches!(expr.kind, ExprKind::Cast(..))\n+        } else {\n+            false\n+        }\n+    }\n+}\n+\n /// Returns the type T of the pointed to *const [T] or *mut [T] and the mutability of the slice if\n /// the type is one of those slices\n fn get_raw_slice_ty_mut(ty: Ty<'_>) -> Option<TypeAndMut<'_>> {\n@@ -98,18 +102,40 @@ fn get_raw_slice_ty_mut(ty: Ty<'_>) -> Option<TypeAndMut<'_>> {\n     }\n }\n \n-/// Returns the pair (original ptr T, final ptr U) if the expression is composed of casts\n+struct CastChainInfo<'tcx> {\n+    /// The left most part of the cast chain, or in other words, the first cast in the chain\n+    /// Used for diagnostics\n+    left_cast: &'tcx Expr<'tcx>,\n+    /// The starting type of the cast chain\n+    start_ty: TypeAndMut<'tcx>,\n+    /// The final type of the cast chain\n+    end_ty: TypeAndMut<'tcx>,\n+}\n+\n+/// Returns a `CastChainInfo` with the left-most cast in the chain and the original ptr T and final\n+/// ptr U if the expression is composed of casts.\n /// Returns None if the expr is not a Cast\n-fn expr_cast_chain_tys<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'_>) -> Option<(TypeAndMut<'tcx>, TypeAndMut<'tcx>)> {\n+fn expr_cast_chain_tys<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'tcx>) -> Option<CastChainInfo<'tcx>> {\n     if let ExprKind::Cast(cast_expr, _cast_to_hir_ty) = expr.peel_blocks().kind {\n         let cast_to = cx.typeck_results().expr_ty(expr);\n         let to_slice_ty = get_raw_slice_ty_mut(cast_to)?;\n-        if let Some((inner_from_ty, _inner_to_ty)) = expr_cast_chain_tys(cx, cast_expr) {\n-            Some((inner_from_ty, to_slice_ty))\n+\n+        // If the expression that makes up the source of this cast is itself a cast, recursively\n+        // call `expr_cast_chain_tys` and update the end type with the final tartet type.\n+        // Otherwise, this cast is not immediately nested, just construct the info for this cast\n+        if let Some(prev_info) = expr_cast_chain_tys(cx, cast_expr) {\n+            Some(CastChainInfo {\n+                end_ty: to_slice_ty,\n+                ..prev_info\n+            })\n         } else {\n             let cast_from = cx.typeck_results().expr_ty(cast_expr);\n             let from_slice_ty = get_raw_slice_ty_mut(cast_from)?;\n-            Some((from_slice_ty, to_slice_ty))\n+            Some(CastChainInfo {\n+                left_cast: cast_expr,\n+                start_ty: from_slice_ty,\n+                end_ty: to_slice_ty,\n+            })\n         }\n     } else {\n         None"}, {"sha": "b58252dcb9424b90339fc2cb86f5159f8991a181", "filename": "clippy_lints/src/casts/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Fcasts%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Fcasts%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcasts%2Fmod.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -270,7 +270,7 @@ declare_clippy_lint! {\n     ///\n     /// ### Why is this bad?\n     /// Casting a function pointer to an integer can have surprising results and can occur\n-    /// accidentally if parantheses are omitted from a function call. If you aren't doing anything\n+    /// accidentally if parentheses are omitted from a function call. If you aren't doing anything\n     /// low-level with function pointers then you can opt-out of casting functions to integers in\n     /// order to avoid mistakes. Alternatively, you can use this lint to audit all uses of function\n     /// pointer casts in your code.\n@@ -487,6 +487,7 @@ declare_clippy_lint! {\n     /// let y: u32 = x.abs() as u32;\n     /// ```\n     /// Use instead:\n+    /// ```rust\n     /// let x: i32 = -42;\n     /// let y: u32 = x.unsigned_abs();\n     /// ```"}, {"sha": "3227e6e86af4e3021c3b97c28655437536f12f2c", "filename": "clippy_lints/src/collapsible_if.rs", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Fcollapsible_if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Fcollapsible_if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcollapsible_if.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -13,13 +13,14 @@\n //! This lint is **warn** by default\n \n use clippy_utils::diagnostics::{span_lint_and_sugg, span_lint_and_then};\n-use clippy_utils::source::{snippet_block, snippet_block_with_applicability};\n+use clippy_utils::source::{snippet, snippet_block, snippet_block_with_applicability};\n use clippy_utils::sugg::Sugg;\n use if_chain::if_chain;\n use rustc_ast::ast;\n use rustc_errors::Applicability;\n use rustc_lint::{EarlyContext, EarlyLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::Span;\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -102,7 +103,7 @@ impl EarlyLintPass for CollapsibleIf {\n fn check_if(cx: &EarlyContext<'_>, expr: &ast::Expr) {\n     if let ast::ExprKind::If(check, then, else_) = &expr.kind {\n         if let Some(else_) = else_ {\n-            check_collapsible_maybe_if_let(cx, else_);\n+            check_collapsible_maybe_if_let(cx, then.span, else_);\n         } else if let ast::ExprKind::Let(..) = check.kind {\n             // Prevent triggering on `if let a = b { if c { .. } }`.\n         } else {\n@@ -119,7 +120,7 @@ fn block_starts_with_comment(cx: &EarlyContext<'_>, expr: &ast::Block) -> bool {\n     trimmed_block_text.starts_with(\"//\") || trimmed_block_text.starts_with(\"/*\")\n }\n \n-fn check_collapsible_maybe_if_let(cx: &EarlyContext<'_>, else_: &ast::Expr) {\n+fn check_collapsible_maybe_if_let(cx: &EarlyContext<'_>, then_span: Span, else_: &ast::Expr) {\n     if_chain! {\n         if let ast::ExprKind::Block(ref block, _) = else_.kind;\n         if !block_starts_with_comment(cx, block);\n@@ -128,14 +129,23 @@ fn check_collapsible_maybe_if_let(cx: &EarlyContext<'_>, else_: &ast::Expr) {\n         if !else_.span.from_expansion();\n         if let ast::ExprKind::If(..) = else_.kind;\n         then {\n+            // Prevent \"elseif\"\n+            // Check that the \"else\" is followed by whitespace\n+            let up_to_else = then_span.between(block.span);\n+            let requires_space = if let Some(c) = snippet(cx, up_to_else, \"..\").chars().last() { !c.is_whitespace() } else { false };\n+\n             let mut applicability = Applicability::MachineApplicable;\n             span_lint_and_sugg(\n                 cx,\n                 COLLAPSIBLE_ELSE_IF,\n                 block.span,\n                 \"this `else { if .. }` block can be collapsed\",\n                 \"collapse nested if block\",\n-                snippet_block_with_applicability(cx, else_.span, \"..\", Some(block.span), &mut applicability).into_owned(),\n+                format!(\n+                    \"{}{}\",\n+                    if requires_space { \" \" } else { \"\" },\n+                    snippet_block_with_applicability(cx, else_.span, \"..\", Some(block.span), &mut applicability)\n+                ),\n                 applicability,\n             );\n         }"}, {"sha": "b3fd8af4730dc16d6ee1e6102e040d2e9da38217", "filename": "clippy_lints/src/doc.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdoc.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -240,7 +240,7 @@ impl<'tcx> LateLintPass<'tcx> for DocMarkdown {\n                     lint_for_missing_headers(cx, item.def_id, item.span, sig, headers, Some(body_id), fpu.panic_span);\n                 }\n             },\n-            hir::ItemKind::Impl(ref impl_) => {\n+            hir::ItemKind::Impl(impl_) => {\n                 self.in_trait_impl = impl_.of_trait.is_some();\n             },\n             hir::ItemKind::Trait(_, unsafety, ..) => {\n@@ -621,10 +621,8 @@ fn check_code(cx: &LateContext<'_>, text: &str, edition: Edition, span: Span) {\n                 let filename = FileName::anon_source_code(&code);\n \n                 let sm = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n-                let fallback_bundle = rustc_errors::fallback_fluent_bundle(\n-                    rustc_errors::DEFAULT_LOCALE_RESOURCES,\n-                    false\n-                );\n+                let fallback_bundle =\n+                    rustc_errors::fallback_fluent_bundle(rustc_errors::DEFAULT_LOCALE_RESOURCES, false);\n                 let emitter = EmitterWriter::new(\n                     Box::new(io::sink()),\n                     None,\n@@ -741,7 +739,7 @@ fn check_word(cx: &LateContext<'_>, word: &str, span: Span) {\n     /// letters (`Clippy` is ok) and one lower-case letter (`NASA` is ok).\n     /// Plurals are also excluded (`IDs` is ok).\n     fn is_camel_case(s: &str) -> bool {\n-        if s.starts_with(|c: char| c.is_digit(10)) {\n+        if s.starts_with(|c: char| c.is_ascii_digit()) {\n             return false;\n         }\n "}, {"sha": "25014bfa1a5b12595b41415a2010317ac7952143", "filename": "clippy_lints/src/drop_forget_ref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Fdrop_forget_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Fdrop_forget_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdrop_forget_ref.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -180,7 +180,7 @@ const DROP_COPY_SUMMARY: &str = \"calls to `std::mem::drop` with a value that imp\n const FORGET_COPY_SUMMARY: &str = \"calls to `std::mem::forget` with a value that implements `Copy`. \\\n                                    Forgetting a copy leaves the original intact\";\n const DROP_NON_DROP_SUMMARY: &str = \"call to `std::mem::drop` with a value that does not implement `Drop`. \\\n-                                 Dropping such a type only extends it's contained lifetimes\";\n+                                 Dropping such a type only extends its contained lifetimes\";\n const FORGET_NON_DROP_SUMMARY: &str = \"call to `std::mem::forget` with a value that does not implement `Drop`. \\\n                                    Forgetting such a type is the same as dropping it\";\n "}, {"sha": "325ae2356c14cb255531b3df3950d3208feaa39e", "filename": "clippy_lints/src/empty_drop.rs", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Fempty_drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Fempty_drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fempty_drop.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -0,0 +1,65 @@\n+use clippy_utils::{diagnostics::span_lint_and_sugg, peel_blocks};\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir::{Body, ExprKind, Impl, ImplItemKind, Item, ItemKind, Node};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for empty `Drop` implementations.\n+    ///\n+    /// ### Why is this bad?\n+    /// Empty `Drop` implementations have no effect when dropping an instance of the type. They are\n+    /// most likely useless. However, an empty `Drop` implementation prevents a type from being\n+    /// destructured, which might be the intention behind adding the implementation as a marker.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// struct S;\n+    ///\n+    /// impl Drop for S {\n+    ///     fn drop(&mut self) {}\n+    /// }\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// struct S;\n+    /// ```\n+    #[clippy::version = \"1.61.0\"]\n+    pub EMPTY_DROP,\n+    restriction,\n+    \"empty `Drop` implementations\"\n+}\n+declare_lint_pass!(EmptyDrop => [EMPTY_DROP]);\n+\n+impl LateLintPass<'_> for EmptyDrop {\n+    fn check_item(&mut self, cx: &LateContext<'_>, item: &Item<'_>) {\n+        if_chain! {\n+            if let ItemKind::Impl(Impl {\n+                of_trait: Some(ref trait_ref),\n+                items: [child],\n+                ..\n+            }) = item.kind;\n+            if trait_ref.trait_def_id() == cx.tcx.lang_items().drop_trait();\n+            if let impl_item_hir = child.id.hir_id();\n+            if let Some(Node::ImplItem(impl_item)) = cx.tcx.hir().find(impl_item_hir);\n+            if let ImplItemKind::Fn(_, b) = &impl_item.kind;\n+            if let Body { value: func_expr, .. } = cx.tcx.hir().body(*b);\n+            let func_expr = peel_blocks(func_expr);\n+            if let ExprKind::Block(block, _) = func_expr.kind;\n+            if block.stmts.is_empty() && block.expr.is_none();\n+            then {\n+                span_lint_and_sugg(\n+                    cx,\n+                    EMPTY_DROP,\n+                    item.span,\n+                    \"empty drop implementation\",\n+                    \"try removing this impl\",\n+                    String::new(),\n+                    Applicability::MaybeIncorrect\n+                );\n+            }\n+        }\n+    }\n+}"}, {"sha": "8430e7b4c82713554b0107be84ef57d269c1a483", "filename": "clippy_lints/src/empty_structs_with_brackets.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Fempty_structs_with_brackets.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Fempty_structs_with_brackets.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fempty_structs_with_brackets.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -66,7 +66,7 @@ fn has_no_fields(cx: &EarlyContext<'_>, var_data: &VariantData, braces_span: Spa\n     }\n \n     // there might still be field declarations hidden from the AST\n-    // (conditionaly compiled code using #[cfg(..)])\n+    // (conditionally compiled code using #[cfg(..)])\n \n     let Some(braces_span_str) = snippet_opt(cx, braces_span) else {\n         return false;"}, {"sha": "1b19868e4c70faf2d33f6a5911528f971b25672b", "filename": "clippy_lints/src/eta_reduction.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Feta_reduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Feta_reduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feta_reduction.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -3,7 +3,7 @@ use clippy_utils::higher::VecArgs;\n use clippy_utils::source::snippet_opt;\n use clippy_utils::ty::is_type_diagnostic_item;\n use clippy_utils::usage::local_used_after_expr;\n-use clippy_utils::{get_enclosing_loop_or_closure, higher, path_to_local, path_to_local_id};\n+use clippy_utils::{higher, is_adjusted, path_to_local, path_to_local_id};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::def_id::DefId;\n@@ -103,6 +103,7 @@ impl<'tcx> LateLintPass<'tcx> for EtaReduction {\n         let closure_ty = cx.typeck_results().expr_ty(expr);\n \n         if_chain!(\n+            if !is_adjusted(cx, &body.value);\n             if let ExprKind::Call(callee, args) = body.value.kind;\n             if let ExprKind::Path(_) = callee.kind;\n             if check_inputs(cx, body.params, args);\n@@ -125,8 +126,7 @@ impl<'tcx> LateLintPass<'tcx> for EtaReduction {\n                         if_chain! {\n                             if let ty::Closure(_, substs) = callee_ty.peel_refs().kind();\n                             if substs.as_closure().kind() == ClosureKind::FnMut;\n-                            if get_enclosing_loop_or_closure(cx.tcx, expr).is_some()\n-                                || path_to_local(callee).map_or(false, |l| local_used_after_expr(cx, l, callee));\n+                            if path_to_local(callee).map_or(false, |l| local_used_after_expr(cx, l, expr));\n \n                             then {\n                                 // Mutable closure is used after current expr; we cannot consume it.\n@@ -145,6 +145,7 @@ impl<'tcx> LateLintPass<'tcx> for EtaReduction {\n         );\n \n         if_chain!(\n+            if !is_adjusted(cx, &body.value);\n             if let ExprKind::MethodCall(path, args, _) = body.value.kind;\n             if check_inputs(cx, body.params, args);\n             let method_def_id = cx.typeck_results().type_dependent_def_id(body.value.hir_id).unwrap();"}, {"sha": "ee15ae9f59aca8eb96429d52464b3c53ae689a5b", "filename": "clippy_lints/src/format_push_string.rs", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Fformat_push_string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Fformat_push_string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fformat_push_string.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -0,0 +1,77 @@\n+use clippy_utils::diagnostics::span_lint_and_help;\n+use clippy_utils::ty::is_type_diagnostic_item;\n+use clippy_utils::{match_def_path, paths, peel_hir_expr_refs};\n+use rustc_hir::{BinOpKind, Expr, ExprKind};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::sym;\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Detects cases where the result of a `format!` call is\n+    /// appended to an existing `String`.\n+    ///\n+    /// ### Why is this bad?\n+    /// Introduces an extra, avoidable heap allocation.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// let mut s = String::new();\n+    /// s += &format!(\"0x{:X}\", 1024);\n+    /// s.push_str(&format!(\"0x{:X}\", 1024));\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// use std::fmt::Write as _; // import without risk of name clashing\n+    ///\n+    /// let mut s = String::new();\n+    /// let _ = write!(s, \"0x{:X}\", 1024);\n+    /// ```\n+    #[clippy::version = \"1.61.0\"]\n+    pub FORMAT_PUSH_STRING,\n+    perf,\n+    \"`format!(..)` appended to existing `String`\"\n+}\n+declare_lint_pass!(FormatPushString => [FORMAT_PUSH_STRING]);\n+\n+fn is_string(cx: &LateContext<'_>, e: &Expr<'_>) -> bool {\n+    is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(e).peel_refs(), sym::String)\n+}\n+fn is_format(cx: &LateContext<'_>, e: &Expr<'_>) -> bool {\n+    if let Some(macro_def_id) = e.span.ctxt().outer_expn_data().macro_def_id {\n+        cx.tcx.get_diagnostic_name(macro_def_id) == Some(sym::format_macro)\n+    } else {\n+        false\n+    }\n+}\n+\n+impl<'tcx> LateLintPass<'tcx> for FormatPushString {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n+        let arg = match expr.kind {\n+            ExprKind::MethodCall(_, [_, arg], _) => {\n+                if let Some(fn_def_id) = cx.typeck_results().type_dependent_def_id(expr.hir_id) &&\n+                match_def_path(cx, fn_def_id, &paths::PUSH_STR) {\n+                    arg\n+                } else {\n+                    return;\n+                }\n+            }\n+            ExprKind::AssignOp(op, left, arg)\n+            if op.node == BinOpKind::Add && is_string(cx, left) => {\n+                arg\n+            },\n+            _ => return,\n+        };\n+        let (arg, _) = peel_hir_expr_refs(arg);\n+        if is_format(cx, arg) {\n+            span_lint_and_help(\n+                cx,\n+                FORMAT_PUSH_STRING,\n+                expr.span,\n+                \"`format!(..)` appended to existing `String`\",\n+                None,\n+                \"consider using `write!` to avoid the extra allocation\",\n+            );\n+        }\n+    }\n+}"}, {"sha": "38e943d2eb8720cd98a0039e5dc3ac188c40d6b8", "filename": "clippy_lints/src/functions/must_use.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Ffunctions%2Fmust_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Ffunctions%2Fmust_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffunctions%2Fmust_use.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -20,7 +20,7 @@ use super::{DOUBLE_MUST_USE, MUST_USE_CANDIDATE, MUST_USE_UNIT};\n pub(super) fn check_item<'tcx>(cx: &LateContext<'tcx>, item: &'tcx hir::Item<'_>) {\n     let attrs = cx.tcx.hir().attrs(item.hir_id());\n     let attr = must_use_attr(attrs);\n-    if let hir::ItemKind::Fn(ref sig, ref _generics, ref body_id) = item.kind {\n+    if let hir::ItemKind::Fn(ref sig, _generics, ref body_id) = item.kind {\n         let is_public = cx.access_levels.is_exported(item.def_id);\n         let fn_header_span = item.span.with_hi(sig.decl.output.span().hi());\n         if let Some(attr) = attr {\n@@ -105,12 +105,7 @@ fn check_needless_must_use(\n             fn_header_span,\n             \"this unit-returning function has a `#[must_use]` attribute\",\n             |diag| {\n-                diag.span_suggestion(\n-                    attr.span,\n-                    \"remove the attribute\",\n-                    \"\",\n-                    Applicability::MachineApplicable,\n-                );\n+                diag.span_suggestion(attr.span, \"remove the attribute\", \"\", Applicability::MachineApplicable);\n             },\n         );\n     } else if attr.value_str().is_none() && is_must_use_ty(cx, return_ty(cx, item_id)) {"}, {"sha": "2e63a1f920d64b39a69ad214ecd4cb6e03ada3a2", "filename": "clippy_lints/src/functions/result_unit_err.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Ffunctions%2Fresult_unit_err.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Ffunctions%2Fresult_unit_err.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffunctions%2Fresult_unit_err.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -14,7 +14,7 @@ use clippy_utils::ty::is_type_diagnostic_item;\n use super::RESULT_UNIT_ERR;\n \n pub(super) fn check_item(cx: &LateContext<'_>, item: &hir::Item<'_>) {\n-    if let hir::ItemKind::Fn(ref sig, ref _generics, _) = item.kind {\n+    if let hir::ItemKind::Fn(ref sig, _generics, _) = item.kind {\n         let is_public = cx.access_levels.is_exported(item.def_id);\n         let fn_header_span = item.span.with_hi(sig.decl.output.span().hi());\n         if is_public {"}, {"sha": "40cc5cd4bcf9df4111d202591fde32e8fb4339e6", "filename": "clippy_lints/src/identity_op.rs", "status": "modified", "additions": 59, "deletions": 23, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Fidentity_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Fidentity_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fidentity_op.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -1,3 +1,4 @@\n+use clippy_utils::get_parent_expr;\n use clippy_utils::source::snippet;\n use rustc_hir::{BinOp, BinOpKind, Expr, ExprKind};\n use rustc_lint::{LateContext, LateLintPass};\n@@ -22,6 +23,11 @@ declare_clippy_lint! {\n     /// # let x = 1;\n     /// x / 1 + 0 * 1 - 0 | 0;\n     /// ```\n+    ///\n+    /// ### Known problems\n+    /// False negatives: `f(0 + if b { 1 } else { 2 } + 3);` is reducible to\n+    /// `f(if b { 1 } else { 2 } + 3);`. But the lint doesn't trigger for the code.\n+    /// See [#8724](https://github.com/rust-lang/rust-clippy/issues/8724)\n     #[clippy::version = \"pre 1.29.0\"]\n     pub IDENTITY_OP,\n     complexity,\n@@ -31,36 +37,66 @@ declare_clippy_lint! {\n declare_lint_pass!(IdentityOp => [IDENTITY_OP]);\n \n impl<'tcx> LateLintPass<'tcx> for IdentityOp {\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) {\n-        if e.span.from_expansion() {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n+        if expr.span.from_expansion() {\n             return;\n         }\n-        if let ExprKind::Binary(cmp, left, right) = e.kind {\n-            if is_allowed(cx, cmp, left, right) {\n-                return;\n-            }\n-            match cmp.node {\n-                BinOpKind::Add | BinOpKind::BitOr | BinOpKind::BitXor => {\n-                    check(cx, left, 0, e.span, right.span);\n-                    check(cx, right, 0, e.span, left.span);\n-                },\n-                BinOpKind::Shl | BinOpKind::Shr | BinOpKind::Sub => check(cx, right, 0, e.span, left.span),\n-                BinOpKind::Mul => {\n-                    check(cx, left, 1, e.span, right.span);\n-                    check(cx, right, 1, e.span, left.span);\n-                },\n-                BinOpKind::Div => check(cx, right, 1, e.span, left.span),\n-                BinOpKind::BitAnd => {\n-                    check(cx, left, -1, e.span, right.span);\n-                    check(cx, right, -1, e.span, left.span);\n-                },\n-                BinOpKind::Rem => check_remainder(cx, left, right, e.span, left.span),\n-                _ => (),\n+        if let ExprKind::Binary(cmp, left, right) = &expr.kind {\n+            if !is_allowed(cx, *cmp, left, right) {\n+                match cmp.node {\n+                    BinOpKind::Add | BinOpKind::BitOr | BinOpKind::BitXor => {\n+                        if reducible_to_right(cx, expr, right) {\n+                            check(cx, left, 0, expr.span, right.span);\n+                        }\n+                        check(cx, right, 0, expr.span, left.span);\n+                    },\n+                    BinOpKind::Shl | BinOpKind::Shr | BinOpKind::Sub => {\n+                        check(cx, right, 0, expr.span, left.span);\n+                    },\n+                    BinOpKind::Mul => {\n+                        if reducible_to_right(cx, expr, right) {\n+                            check(cx, left, 1, expr.span, right.span);\n+                        }\n+                        check(cx, right, 1, expr.span, left.span);\n+                    },\n+                    BinOpKind::Div => check(cx, right, 1, expr.span, left.span),\n+                    BinOpKind::BitAnd => {\n+                        if reducible_to_right(cx, expr, right) {\n+                            check(cx, left, -1, expr.span, right.span);\n+                        }\n+                        check(cx, right, -1, expr.span, left.span);\n+                    },\n+                    BinOpKind::Rem => {\n+                        // Don't call reducible_to_right because N % N is always reducible to 1\n+                        check_remainder(cx, left, right, expr.span, left.span);\n+                    },\n+                    _ => (),\n+                }\n             }\n         }\n     }\n }\n \n+/// Checks if `left op ..right` can be actually reduced to `right`\n+/// e.g. `0 + if b { 1 } else { 2 } + if b { 3 } else { 4 }`\n+/// cannot be reduced to `if b { 1 } else { 2 } +  if b { 3 } else { 4 }`\n+/// See #8724\n+fn reducible_to_right(cx: &LateContext<'_>, binary: &Expr<'_>, right: &Expr<'_>) -> bool {\n+    if let ExprKind::If(..) | ExprKind::Match(..) | ExprKind::Block(..) | ExprKind::Loop(..) = right.kind {\n+        is_toplevel_binary(cx, binary)\n+    } else {\n+        true\n+    }\n+}\n+\n+fn is_toplevel_binary(cx: &LateContext<'_>, must_be_binary: &Expr<'_>) -> bool {\n+    if let Some(parent) = get_parent_expr(cx, must_be_binary) && let ExprKind::Binary(..) = &parent.kind {\n+        false\n+    } else {\n+        true\n+    }\n+}\n+\n fn is_allowed(cx: &LateContext<'_>, cmp: BinOp, left: &Expr<'_>, right: &Expr<'_>) -> bool {\n     // This lint applies to integers\n     !cx.typeck_results().expr_ty(left).peel_refs().is_integral()"}, {"sha": "feb1b1014b180838b74b771c0a852f6cf671497c", "filename": "clippy_lints/src/implicit_hasher.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Fimplicit_hasher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Fimplicit_hasher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fimplicit_hasher.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -117,7 +117,7 @@ impl<'tcx> LateLintPass<'tcx> for ImplicitHasher {\n         }\n \n         match item.kind {\n-            ItemKind::Impl(ref impl_) => {\n+            ItemKind::Impl(impl_) => {\n                 let mut vis = ImplicitHasherTypeVisitor::new(cx);\n                 vis.visit_ty(impl_.self_ty);\n \n@@ -155,7 +155,7 @@ impl<'tcx> LateLintPass<'tcx> for ImplicitHasher {\n                     );\n                 }\n             },\n-            ItemKind::Fn(ref sig, ref generics, body_id) => {\n+            ItemKind::Fn(ref sig, generics, body_id) => {\n                 let body = cx.tcx.hir().body(body_id);\n \n                 for ty in sig.decl.inputs {"}, {"sha": "14b22d2b50d054fdec8e0061666bf02d381bd518", "filename": "clippy_lints/src/inconsistent_struct_constructor.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Finconsistent_struct_constructor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Finconsistent_struct_constructor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Finconsistent_struct_constructor.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -7,6 +7,7 @@ use rustc_hir::{self as hir, ExprKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::symbol::Symbol;\n+use std::fmt::Write as _;\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -89,7 +90,7 @@ impl<'tcx> LateLintPass<'tcx> for InconsistentStructConstructor {\n                 let mut fields_snippet = String::new();\n                 let (last_ident, idents) = ordered_fields.split_last().unwrap();\n                 for ident in idents {\n-                    fields_snippet.push_str(&format!(\"{}, \", ident));\n+                    let _ = write!(fields_snippet, \"{}, \", ident);\n                 }\n                 fields_snippet.push_str(&last_ident.to_string());\n "}, {"sha": "8a84513b7792fdbf0f97db326feac7cc8f2c274b", "filename": "clippy_lints/src/index_refutable_slice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Findex_refutable_slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Findex_refutable_slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Findex_refutable_slice.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -116,7 +116,7 @@ fn find_slice_values(cx: &LateContext<'_>, pat: &hir::Pat<'_>) -> FxIndexMap<hir\n             let bound_ty = cx.typeck_results().node_type(pat.hir_id);\n             if let ty::Slice(inner_ty) | ty::Array(inner_ty, _) = bound_ty.peel_refs().kind() {\n                 // The values need to use the `ref` keyword if they can't be copied.\n-                // This will need to be adjusted if the lint want to support multable access in the future\n+                // This will need to be adjusted if the lint want to support mutable access in the future\n                 let src_is_ref = bound_ty.is_ref() && binding != hir::BindingAnnotation::Ref;\n                 let needs_ref = !(src_is_ref || is_copy(cx, *inner_ty));\n "}, {"sha": "6a031a627df946669e206ae77fb2255d21bf71e4", "filename": "clippy_lints/src/inherent_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Finherent_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Finherent_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Finherent_impl.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -119,7 +119,7 @@ impl<'tcx> LateLintPass<'tcx> for MultipleInherentImpl {\n fn get_impl_span(cx: &LateContext<'_>, id: LocalDefId) -> Option<Span> {\n     let id = cx.tcx.hir().local_def_id_to_hir_id(id);\n     if let Node::Item(&Item {\n-        kind: ItemKind::Impl(ref impl_item),\n+        kind: ItemKind::Impl(impl_item),\n         span,\n         ..\n     }) = cx.tcx.hir().get(id)"}, {"sha": "7e1548531f10cc9301c558d013dcd133c30dc330", "filename": "clippy_lints/src/init_numbered_fields.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Finit_numbered_fields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Finit_numbered_fields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Finit_numbered_fields.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -1,6 +1,7 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::snippet_with_applicability;\n use rustc_errors::Applicability;\n+use rustc_hir::def::{DefKind, Res};\n use rustc_hir::{Expr, ExprKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n@@ -49,6 +50,7 @@ impl<'tcx> LateLintPass<'tcx> for NumberedFields {\n                 && fields\n                     .iter()\n                     .all(|f| f.ident.as_str().as_bytes().iter().all(u8::is_ascii_digit))\n+                && !matches!(cx.qpath_res(path, e.hir_id), Res::Def(DefKind::TyAlias, ..))\n             {\n                 let expr_spans = fields\n                     .iter()"}, {"sha": "8bef13c682dbfe86c92da5ba743fcc1af6efa975", "filename": "clippy_lints/src/large_include_file.rs", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Flarge_include_file.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Flarge_include_file.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flarge_include_file.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -0,0 +1,86 @@\n+use clippy_utils::diagnostics::span_lint_and_note;\n+use clippy_utils::is_lint_allowed;\n+use clippy_utils::macros::root_macro_call_first_node;\n+use rustc_ast::LitKind;\n+use rustc_hir::Expr;\n+use rustc_hir::ExprKind;\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n+use rustc_span::sym;\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for the inclusion of large files via `include_bytes!()`\n+    /// and `include_str!()`\n+    ///\n+    /// ### Why is this bad?\n+    /// Including large files can increase the size of the binary\n+    ///\n+    /// ### Example\n+    /// ```rust,ignore\n+    /// let included_str = include_str!(\"very_large_file.txt\");\n+    /// let included_bytes = include_bytes!(\"very_large_file.txt\");\n+    /// ```\n+    ///\n+    /// Instead, you can load the file at runtime:\n+    /// ```rust,ignore\n+    /// use std::fs;\n+    ///\n+    /// let string = fs::read_to_string(\"very_large_file.txt\")?;\n+    /// let bytes = fs::read(\"very_large_file.txt\")?;\n+    /// ```\n+    #[clippy::version = \"1.62.0\"]\n+    pub LARGE_INCLUDE_FILE,\n+    restriction,\n+    \"including a large file\"\n+}\n+\n+pub struct LargeIncludeFile {\n+    max_file_size: u64,\n+}\n+\n+impl LargeIncludeFile {\n+    #[must_use]\n+    pub fn new(max_file_size: u64) -> Self {\n+        Self { max_file_size }\n+    }\n+}\n+\n+impl_lint_pass!(LargeIncludeFile => [LARGE_INCLUDE_FILE]);\n+\n+impl LateLintPass<'_> for LargeIncludeFile {\n+    fn check_expr(&mut self, cx: &LateContext<'_>, expr: &'_ Expr<'_>) {\n+        if_chain! {\n+            if let Some(macro_call) = root_macro_call_first_node(cx, expr);\n+            if !is_lint_allowed(cx, LARGE_INCLUDE_FILE, expr.hir_id);\n+            if cx.tcx.is_diagnostic_item(sym::include_bytes_macro, macro_call.def_id)\n+            || cx.tcx.is_diagnostic_item(sym::include_str_macro, macro_call.def_id);\n+            if let ExprKind::Lit(lit) = &expr.kind;\n+            then {\n+                let len = match &lit.node {\n+                    // include_bytes\n+                    LitKind::ByteStr(bstr) => bstr.len(),\n+                    // include_str\n+                    LitKind::Str(sym, _) => sym.as_str().len(),\n+                    _ => return,\n+                };\n+\n+                if len as u64 <= self.max_file_size {\n+                    return;\n+                }\n+\n+                span_lint_and_note(\n+                    cx,\n+                    LARGE_INCLUDE_FILE,\n+                    expr.span,\n+                    \"attempted to include a large file\",\n+                    None,\n+                    &format!(\n+                        \"the configuration allows a maximum size of {} bytes\",\n+                        self.max_file_size\n+                    ),\n+                );\n+            }\n+        }\n+    }\n+}"}, {"sha": "e68718f9fdf99165efdb6682b8e0ea4d5a2efe18", "filename": "clippy_lints/src/lib.register_all.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Flib.register_all.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Flib.register_all.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_all.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -14,6 +14,7 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(attrs::DEPRECATED_SEMVER),\n     LintId::of(attrs::MISMATCHED_TARGET_OS),\n     LintId::of(attrs::USELESS_ATTRIBUTE),\n+    LintId::of(await_holding_invalid::AWAIT_HOLDING_INVALID_TYPE),\n     LintId::of(await_holding_invalid::AWAIT_HOLDING_LOCK),\n     LintId::of(await_holding_invalid::AWAIT_HOLDING_REFCELL_REF),\n     LintId::of(bit_mask::BAD_BIT_MASK),\n@@ -23,6 +24,7 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(bool_assert_comparison::BOOL_ASSERT_COMPARISON),\n     LintId::of(booleans::LOGIC_BUG),\n     LintId::of(booleans::NONMINIMAL_BOOL),\n+    LintId::of(bytes_count_to_len::BYTES_COUNT_TO_LEN),\n     LintId::of(casts::CAST_ABS_TO_UNSIGNED),\n     LintId::of(casts::CAST_ENUM_CONSTRUCTOR),\n     LintId::of(casts::CAST_ENUM_TRUNCATION),\n@@ -77,6 +79,7 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(format_args::TO_STRING_IN_FORMAT_ARGS),\n     LintId::of(format_impl::PRINT_IN_FORMAT_IMPL),\n     LintId::of(format_impl::RECURSIVE_FORMAT_IMPL),\n+    LintId::of(format_push_string::FORMAT_PUSH_STRING),\n     LintId::of(formatting::POSSIBLE_MISSING_COMMA),\n     LintId::of(formatting::SUSPICIOUS_ASSIGNMENT_FORMATTING),\n     LintId::of(formatting::SUSPICIOUS_ELSE_FORMATTING),\n@@ -165,6 +168,7 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(methods::FLAT_MAP_IDENTITY),\n     LintId::of(methods::INSPECT_FOR_EACH),\n     LintId::of(methods::INTO_ITER_ON_REF),\n+    LintId::of(methods::IS_DIGIT_ASCII_RADIX),\n     LintId::of(methods::ITERATOR_STEP_BY_ZERO),\n     LintId::of(methods::ITER_CLONED_COLLECT),\n     LintId::of(methods::ITER_COUNT),\n@@ -182,6 +186,7 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(methods::MAP_FLATTEN),\n     LintId::of(methods::MAP_IDENTITY),\n     LintId::of(methods::NEEDLESS_OPTION_AS_DEREF),\n+    LintId::of(methods::NEEDLESS_OPTION_TAKE),\n     LintId::of(methods::NEEDLESS_SPLITN),\n     LintId::of(methods::NEW_RET_NO_SELF),\n     LintId::of(methods::OK_EXPECT),\n@@ -243,7 +248,6 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(non_expressive_names::JUST_UNDERSCORES_AND_DIGITS),\n     LintId::of(non_octal_unix_permissions::NON_OCTAL_UNIX_PERMISSIONS),\n     LintId::of(octal_escapes::OCTAL_ESCAPES),\n-    LintId::of(only_used_in_recursion::ONLY_USED_IN_RECURSION),\n     LintId::of(open_options::NONSENSICAL_OPEN_OPTIONS),\n     LintId::of(option_env_unwrap::OPTION_ENV_UNWRAP),\n     LintId::of(overflow_check_conditional::OVERFLOW_CHECK_CONDITIONAL),\n@@ -275,8 +279,8 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(single_component_path_imports::SINGLE_COMPONENT_PATH_IMPORTS),\n     LintId::of(size_of_in_element_count::SIZE_OF_IN_ELEMENT_COUNT),\n     LintId::of(slow_vector_initialization::SLOW_VECTOR_INITIALIZATION),\n-    LintId::of(stable_sort_primitive::STABLE_SORT_PRIMITIVE),\n     LintId::of(strings::STRING_FROM_UTF8_AS_BYTES),\n+    LintId::of(strings::TRIM_SPLIT_WHITESPACE),\n     LintId::of(strlen_on_c_strings::STRLEN_ON_C_STRINGS),\n     LintId::of(suspicious_trait_impl::SUSPICIOUS_ARITHMETIC_IMPL),\n     LintId::of(suspicious_trait_impl::SUSPICIOUS_OP_ASSIGN_IMPL),\n@@ -306,10 +310,12 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(uninit_vec::UNINIT_VEC),\n     LintId::of(unit_hash::UNIT_HASH),\n     LintId::of(unit_return_expecting_ord::UNIT_RETURN_EXPECTING_ORD),\n+    LintId::of(unit_types::LET_UNIT_VALUE),\n     LintId::of(unit_types::UNIT_ARG),\n     LintId::of(unit_types::UNIT_CMP),\n     LintId::of(unnamed_address::FN_ADDRESS_COMPARISONS),\n     LintId::of(unnamed_address::VTABLE_ADDRESS_COMPARISONS),\n+    LintId::of(unnecessary_owned_empty_strings::UNNECESSARY_OWNED_EMPTY_STRINGS),\n     LintId::of(unnecessary_sort_by::UNNECESSARY_SORT_BY),\n     LintId::of(unsafe_removed_from_name::UNSAFE_REMOVED_FROM_NAME),\n     LintId::of(unused_io_amount::UNUSED_IO_AMOUNT),"}, {"sha": "6f3c433af31a6287b9fce5dee51ad0daaf5f8fcf", "filename": "clippy_lints/src/lib.register_complexity.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Flib.register_complexity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Flib.register_complexity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_complexity.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -5,6 +5,7 @@\n store.register_group(true, \"clippy::complexity\", Some(\"clippy_complexity\"), vec![\n     LintId::of(attrs::DEPRECATED_CFG_ATTR),\n     LintId::of(booleans::NONMINIMAL_BOOL),\n+    LintId::of(bytes_count_to_len::BYTES_COUNT_TO_LEN),\n     LintId::of(casts::CHAR_LIT_AS_U8),\n     LintId::of(casts::UNNECESSARY_CAST),\n     LintId::of(derivable_impls::DERIVABLE_IMPLS),\n@@ -45,6 +46,7 @@ store.register_group(true, \"clippy::complexity\", Some(\"clippy_complexity\"), vec!\n     LintId::of(methods::MAP_FLATTEN),\n     LintId::of(methods::MAP_IDENTITY),\n     LintId::of(methods::NEEDLESS_OPTION_AS_DEREF),\n+    LintId::of(methods::NEEDLESS_OPTION_TAKE),\n     LintId::of(methods::NEEDLESS_SPLITN),\n     LintId::of(methods::OPTION_AS_REF_DEREF),\n     LintId::of(methods::OPTION_FILTER_MAP),\n@@ -66,7 +68,6 @@ store.register_group(true, \"clippy::complexity\", Some(\"clippy_complexity\"), vec!\n     LintId::of(neg_cmp_op_on_partial_ord::NEG_CMP_OP_ON_PARTIAL_ORD),\n     LintId::of(no_effect::NO_EFFECT),\n     LintId::of(no_effect::UNNECESSARY_OPERATION),\n-    LintId::of(only_used_in_recursion::ONLY_USED_IN_RECURSION),\n     LintId::of(overflow_check_conditional::OVERFLOW_CHECK_CONDITIONAL),\n     LintId::of(partialeq_ne_impl::PARTIALEQ_NE_IMPL),\n     LintId::of(precedence::PRECEDENCE),"}, {"sha": "5768edc501884feee3e529445ff01f79188cf533", "filename": "clippy_lints/src/lib.register_lints.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Flib.register_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Flib.register_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_lints.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -52,6 +52,7 @@ store.register_lints(&[\n     attrs::INLINE_ALWAYS,\n     attrs::MISMATCHED_TARGET_OS,\n     attrs::USELESS_ATTRIBUTE,\n+    await_holding_invalid::AWAIT_HOLDING_INVALID_TYPE,\n     await_holding_invalid::AWAIT_HOLDING_LOCK,\n     await_holding_invalid::AWAIT_HOLDING_REFCELL_REF,\n     bit_mask::BAD_BIT_MASK,\n@@ -64,6 +65,7 @@ store.register_lints(&[\n     booleans::NONMINIMAL_BOOL,\n     borrow_as_ptr::BORROW_AS_PTR,\n     bytecount::NAIVE_BYTECOUNT,\n+    bytes_count_to_len::BYTES_COUNT_TO_LEN,\n     cargo::CARGO_COMMON_METADATA,\n     cargo::MULTIPLE_CRATE_VERSIONS,\n     cargo::NEGATIVE_FEATURE_NAMES,\n@@ -132,6 +134,7 @@ store.register_lints(&[\n     drop_forget_ref::UNDROPPED_MANUALLY_DROPS,\n     duration_subsec::DURATION_SUBSEC,\n     else_if_without_else::ELSE_IF_WITHOUT_ELSE,\n+    empty_drop::EMPTY_DROP,\n     empty_enum::EMPTY_ENUM,\n     empty_structs_with_brackets::EMPTY_STRUCTS_WITH_BRACKETS,\n     entry::MAP_ENTRY,\n@@ -165,6 +168,7 @@ store.register_lints(&[\n     format_args::TO_STRING_IN_FORMAT_ARGS,\n     format_impl::PRINT_IN_FORMAT_IMPL,\n     format_impl::RECURSIVE_FORMAT_IMPL,\n+    format_push_string::FORMAT_PUSH_STRING,\n     formatting::POSSIBLE_MISSING_COMMA,\n     formatting::SUSPICIOUS_ASSIGNMENT_FORMATTING,\n     formatting::SUSPICIOUS_ELSE_FORMATTING,\n@@ -205,6 +209,7 @@ store.register_lints(&[\n     iter_not_returning_iterator::ITER_NOT_RETURNING_ITERATOR,\n     large_const_arrays::LARGE_CONST_ARRAYS,\n     large_enum_variant::LARGE_ENUM_VARIANT,\n+    large_include_file::LARGE_INCLUDE_FILE,\n     large_stack_arrays::LARGE_STACK_ARRAYS,\n     len_zero::COMPARISON_TO_EMPTY,\n     len_zero::LEN_WITHOUT_IS_EMPTY,\n@@ -302,6 +307,7 @@ store.register_lints(&[\n     methods::INEFFICIENT_TO_STRING,\n     methods::INSPECT_FOR_EACH,\n     methods::INTO_ITER_ON_REF,\n+    methods::IS_DIGIT_ASCII_RADIX,\n     methods::ITERATOR_STEP_BY_ZERO,\n     methods::ITER_CLONED_COLLECT,\n     methods::ITER_COUNT,\n@@ -321,6 +327,7 @@ store.register_lints(&[\n     methods::MAP_IDENTITY,\n     methods::MAP_UNWRAP_OR,\n     methods::NEEDLESS_OPTION_AS_DEREF,\n+    methods::NEEDLESS_OPTION_TAKE,\n     methods::NEEDLESS_SPLITN,\n     methods::NEW_RET_NO_SELF,\n     methods::OK_EXPECT,\n@@ -432,6 +439,7 @@ store.register_lints(&[\n     ptr::PTR_ARG,\n     ptr_eq::PTR_EQ,\n     ptr_offset_with_cast::PTR_OFFSET_WITH_CAST,\n+    pub_use::PUB_USE,\n     question_mark::QUESTION_MARK,\n     ranges::MANUAL_RANGE_CONTAINS,\n     ranges::RANGE_MINUS_ONE,\n@@ -474,6 +482,7 @@ store.register_lints(&[\n     strings::STRING_SLICE,\n     strings::STRING_TO_STRING,\n     strings::STR_TO_STRING,\n+    strings::TRIM_SPLIT_WHITESPACE,\n     strlen_on_c_strings::STRLEN_ON_C_STRINGS,\n     suspicious_operation_groupings::SUSPICIOUS_OPERATION_GROUPINGS,\n     suspicious_trait_impl::SUSPICIOUS_ARITHMETIC_IMPL,\n@@ -523,6 +532,7 @@ store.register_lints(&[\n     unit_types::UNIT_CMP,\n     unnamed_address::FN_ADDRESS_COMPARISONS,\n     unnamed_address::VTABLE_ADDRESS_COMPARISONS,\n+    unnecessary_owned_empty_strings::UNNECESSARY_OWNED_EMPTY_STRINGS,\n     unnecessary_self_imports::UNNECESSARY_SELF_IMPORTS,\n     unnecessary_sort_by::UNNECESSARY_SORT_BY,\n     unnecessary_wraps::UNNECESSARY_WRAPS,"}, {"sha": "ec187563b3f645a1c3c50d774cc8f2e26bf0d2ab", "filename": "clippy_lints/src/lib.register_nursery.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Flib.register_nursery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Flib.register_nursery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_nursery.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -20,13 +20,16 @@ store.register_group(true, \"clippy::nursery\", Some(\"clippy_nursery\"), vec![\n     LintId::of(mutex_atomic::MUTEX_INTEGER),\n     LintId::of(non_send_fields_in_send_ty::NON_SEND_FIELDS_IN_SEND_TY),\n     LintId::of(nonstandard_macro_braces::NONSTANDARD_MACRO_BRACES),\n+    LintId::of(only_used_in_recursion::ONLY_USED_IN_RECURSION),\n     LintId::of(option_if_let_else::OPTION_IF_LET_ELSE),\n     LintId::of(path_buf_push_overwrite::PATH_BUF_PUSH_OVERWRITE),\n     LintId::of(redundant_pub_crate::REDUNDANT_PUB_CRATE),\n     LintId::of(regex::TRIVIAL_REGEX),\n     LintId::of(strings::STRING_LIT_AS_BYTES),\n     LintId::of(suspicious_operation_groupings::SUSPICIOUS_OPERATION_GROUPINGS),\n     LintId::of(trailing_empty_array::TRAILING_EMPTY_ARRAY),\n+    LintId::of(trait_bounds::TRAIT_DUPLICATION_IN_BOUNDS),\n+    LintId::of(trait_bounds::TYPE_REPETITION_IN_BOUNDS),\n     LintId::of(transmute::TRANSMUTE_UNDEFINED_REPR),\n     LintId::of(transmute::USELESS_TRANSMUTE),\n     LintId::of(use_self::USE_SELF),"}, {"sha": "2ee2c6e3358cd030ffd32a1b8287fc379932e348", "filename": "clippy_lints/src/lib.register_pedantic.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Flib.register_pedantic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Flib.register_pedantic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_pedantic.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -82,14 +82,12 @@ store.register_group(true, \"clippy::pedantic\", Some(\"clippy_pedantic\"), vec![\n     LintId::of(ref_option_ref::REF_OPTION_REF),\n     LintId::of(return_self_not_must_use::RETURN_SELF_NOT_MUST_USE),\n     LintId::of(semicolon_if_nothing_returned::SEMICOLON_IF_NOTHING_RETURNED),\n+    LintId::of(stable_sort_primitive::STABLE_SORT_PRIMITIVE),\n     LintId::of(strings::STRING_ADD_ASSIGN),\n-    LintId::of(trait_bounds::TRAIT_DUPLICATION_IN_BOUNDS),\n-    LintId::of(trait_bounds::TYPE_REPETITION_IN_BOUNDS),\n     LintId::of(transmute::TRANSMUTE_PTR_TO_PTR),\n     LintId::of(types::LINKEDLIST),\n     LintId::of(types::OPTION_OPTION),\n     LintId::of(unicode::UNICODE_NOT_NFC),\n-    LintId::of(unit_types::LET_UNIT_VALUE),\n     LintId::of(unnecessary_wraps::UNNECESSARY_WRAPS),\n     LintId::of(unnested_or_patterns::UNNESTED_OR_PATTERNS),\n     LintId::of(unused_async::UNUSED_ASYNC),"}, {"sha": "82431863e6cfd56cf3482b2f9f03c6d3ebbd003c", "filename": "clippy_lints/src/lib.register_perf.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Flib.register_perf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Flib.register_perf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_perf.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -7,6 +7,7 @@ store.register_group(true, \"clippy::perf\", Some(\"clippy_perf\"), vec![\n     LintId::of(escape::BOXED_LOCAL),\n     LintId::of(format_args::FORMAT_IN_FORMAT_ARGS),\n     LintId::of(format_args::TO_STRING_IN_FORMAT_ARGS),\n+    LintId::of(format_push_string::FORMAT_PUSH_STRING),\n     LintId::of(large_const_arrays::LARGE_CONST_ARRAYS),\n     LintId::of(large_enum_variant::LARGE_ENUM_VARIANT),\n     LintId::of(loops::MANUAL_MEMCPY),\n@@ -23,7 +24,6 @@ store.register_group(true, \"clippy::perf\", Some(\"clippy_perf\"), vec![\n     LintId::of(misc::CMP_OWNED),\n     LintId::of(redundant_clone::REDUNDANT_CLONE),\n     LintId::of(slow_vector_initialization::SLOW_VECTOR_INITIALIZATION),\n-    LintId::of(stable_sort_primitive::STABLE_SORT_PRIMITIVE),\n     LintId::of(types::BOX_COLLECTION),\n     LintId::of(types::REDUNDANT_ALLOCATION),\n     LintId::of(vec::USELESS_VEC),"}, {"sha": "77ec6c83ba4b4d8b5d6691fb0391382582e14686", "filename": "clippy_lints/src/lib.register_restriction.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Flib.register_restriction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Flib.register_restriction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_restriction.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -16,6 +16,7 @@ store.register_group(true, \"clippy::restriction\", Some(\"clippy_restriction\"), ve\n     LintId::of(default_union_representation::DEFAULT_UNION_REPRESENTATION),\n     LintId::of(disallowed_script_idents::DISALLOWED_SCRIPT_IDENTS),\n     LintId::of(else_if_without_else::ELSE_IF_WITHOUT_ELSE),\n+    LintId::of(empty_drop::EMPTY_DROP),\n     LintId::of(empty_structs_with_brackets::EMPTY_STRUCTS_WITH_BRACKETS),\n     LintId::of(exhaustive_items::EXHAUSTIVE_ENUMS),\n     LintId::of(exhaustive_items::EXHAUSTIVE_STRUCTS),\n@@ -26,6 +27,7 @@ store.register_group(true, \"clippy::restriction\", Some(\"clippy_restriction\"), ve\n     LintId::of(indexing_slicing::INDEXING_SLICING),\n     LintId::of(inherent_impl::MULTIPLE_INHERENT_IMPL),\n     LintId::of(integer_division::INTEGER_DIVISION),\n+    LintId::of(large_include_file::LARGE_INCLUDE_FILE),\n     LintId::of(let_underscore::LET_UNDERSCORE_MUST_USE),\n     LintId::of(literal_representation::DECIMAL_LITERAL_REPRESENTATION),\n     LintId::of(map_err_ignore::MAP_ERR_IGNORE),\n@@ -53,6 +55,7 @@ store.register_group(true, \"clippy::restriction\", Some(\"clippy_restriction\"), ve\n     LintId::of(panic_unimplemented::UNIMPLEMENTED),\n     LintId::of(panic_unimplemented::UNREACHABLE),\n     LintId::of(pattern_type_mismatch::PATTERN_TYPE_MISMATCH),\n+    LintId::of(pub_use::PUB_USE),\n     LintId::of(redundant_slicing::DEREF_BY_SLICING),\n     LintId::of(same_name_method::SAME_NAME_METHOD),\n     LintId::of(shadow::SHADOW_REUSE),"}, {"sha": "d183c0449cd5fd6fb7059de9c8076c5bdcb52f70", "filename": "clippy_lints/src/lib.register_style.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Flib.register_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Flib.register_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_style.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -61,6 +61,7 @@ store.register_group(true, \"clippy::style\", Some(\"clippy_style\"), vec![\n     LintId::of(methods::CHARS_NEXT_CMP),\n     LintId::of(methods::ERR_EXPECT),\n     LintId::of(methods::INTO_ITER_ON_REF),\n+    LintId::of(methods::IS_DIGIT_ASCII_RADIX),\n     LintId::of(methods::ITER_CLONED_COLLECT),\n     LintId::of(methods::ITER_NEXT_SLICE),\n     LintId::of(methods::ITER_NTH_ZERO),\n@@ -104,8 +105,11 @@ store.register_group(true, \"clippy::style\", Some(\"clippy_style\"), vec![\n     LintId::of(returns::NEEDLESS_RETURN),\n     LintId::of(self_named_constructors::SELF_NAMED_CONSTRUCTORS),\n     LintId::of(single_component_path_imports::SINGLE_COMPONENT_PATH_IMPORTS),\n+    LintId::of(strings::TRIM_SPLIT_WHITESPACE),\n     LintId::of(tabs_in_doc_comments::TABS_IN_DOC_COMMENTS),\n     LintId::of(to_digit_is_some::TO_DIGIT_IS_SOME),\n+    LintId::of(unit_types::LET_UNIT_VALUE),\n+    LintId::of(unnecessary_owned_empty_strings::UNNECESSARY_OWNED_EMPTY_STRINGS),\n     LintId::of(unsafe_removed_from_name::UNSAFE_REMOVED_FROM_NAME),\n     LintId::of(unused_unit::UNUSED_UNIT),\n     LintId::of(upper_case_acronyms::UPPER_CASE_ACRONYMS),"}, {"sha": "7a881bfe3991265ea34c021512e42a783e1783a3", "filename": "clippy_lints/src/lib.register_suspicious.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Flib.register_suspicious.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Flib.register_suspicious.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_suspicious.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -5,6 +5,7 @@\n store.register_group(true, \"clippy::suspicious\", Some(\"clippy_suspicious\"), vec![\n     LintId::of(assign_ops::MISREFACTORED_ASSIGN_OP),\n     LintId::of(attrs::BLANKET_CLIPPY_RESTRICTION_LINTS),\n+    LintId::of(await_holding_invalid::AWAIT_HOLDING_INVALID_TYPE),\n     LintId::of(await_holding_invalid::AWAIT_HOLDING_LOCK),\n     LintId::of(await_holding_invalid::AWAIT_HOLDING_REFCELL_REF),\n     LintId::of(casts::CAST_ABS_TO_UNSIGNED),"}, {"sha": "3bb821a14829535e924d08c81fadab601d68ce53", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 28, "deletions": 40, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -163,6 +163,8 @@ mod deprecated_lints;\n #[cfg_attr(feature = \"internal\", allow(clippy::missing_clippy_version_attribute))]\n mod utils;\n \n+mod renamed_lints;\n+\n // begin lints modules, do not remove this comment, it\u2019s used in `update_lints`\n mod absurd_extreme_comparisons;\n mod approx_const;\n@@ -181,6 +183,7 @@ mod bool_assert_comparison;\n mod booleans;\n mod borrow_as_ptr;\n mod bytecount;\n+mod bytes_count_to_len;\n mod cargo;\n mod case_sensitive_file_extension_comparisons;\n mod casts;\n@@ -209,6 +212,7 @@ mod double_parens;\n mod drop_forget_ref;\n mod duration_subsec;\n mod else_if_without_else;\n+mod empty_drop;\n mod empty_enum;\n mod empty_structs_with_brackets;\n mod entry;\n@@ -231,6 +235,7 @@ mod floating_point_arithmetic;\n mod format;\n mod format_args;\n mod format_impl;\n+mod format_push_string;\n mod formatting;\n mod from_over_into;\n mod from_str_radix_10;\n@@ -259,6 +264,7 @@ mod items_after_statements;\n mod iter_not_returning_iterator;\n mod large_const_arrays;\n mod large_enum_variant;\n+mod large_include_file;\n mod large_stack_arrays;\n mod len_zero;\n mod let_if_seq;\n@@ -336,6 +342,7 @@ mod precedence;\n mod ptr;\n mod ptr_eq;\n mod ptr_offset_with_cast;\n+mod pub_use;\n mod question_mark;\n mod ranges;\n mod redundant_clone;\n@@ -383,6 +390,7 @@ mod unit_hash;\n mod unit_return_expecting_ord;\n mod unit_types;\n mod unnamed_address;\n+mod unnecessary_owned_empty_strings;\n mod unnecessary_self_imports;\n mod unnecessary_sort_by;\n mod unnecessary_wraps;\n@@ -499,7 +507,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     {\n         store.register_early_pass(|| Box::new(utils::internal_lints::ClippyLintsInternal));\n         store.register_early_pass(|| Box::new(utils::internal_lints::ProduceIce));\n-        store.register_late_pass(|| Box::new(utils::inspector::DeepCodeInspector));\n         store.register_late_pass(|| Box::new(utils::internal_lints::CollapsibleCalls));\n         store.register_late_pass(|| Box::new(utils::internal_lints::CompilerLintFunctions::new()));\n         store.register_late_pass(|| Box::new(utils::internal_lints::IfChainStyle));\n@@ -511,8 +518,14 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         store.register_late_pass(|| Box::new(utils::internal_lints::MsrvAttrImpl));\n     }\n \n+    store.register_late_pass(|| Box::new(utils::dump_hir::DumpHir));\n     store.register_late_pass(|| Box::new(utils::author::Author));\n-    store.register_late_pass(|| Box::new(await_holding_invalid::AwaitHolding));\n+    let await_holding_invalid_types = conf.await_holding_invalid_types.clone();\n+    store.register_late_pass(move || {\n+        Box::new(await_holding_invalid::AwaitHolding::new(\n+            await_holding_invalid_types.clone(),\n+        ))\n+    });\n     store.register_late_pass(|| Box::new(serde_api::SerdeApi));\n     let vec_box_size_threshold = conf.vec_box_size_threshold;\n     let type_complexity_threshold = conf.type_complexity_threshold;\n@@ -572,7 +585,8 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(move || Box::new(approx_const::ApproxConstant::new(msrv)));\n     store.register_late_pass(move || Box::new(methods::Methods::new(avoid_breaking_exported_api, msrv)));\n     store.register_late_pass(move || Box::new(matches::Matches::new(msrv)));\n-    store.register_early_pass(move || Box::new(manual_non_exhaustive::ManualNonExhaustive::new(msrv)));\n+    store.register_early_pass(move || Box::new(manual_non_exhaustive::ManualNonExhaustiveStruct::new(msrv)));\n+    store.register_late_pass(move || Box::new(manual_non_exhaustive::ManualNonExhaustiveEnum::new(msrv)));\n     store.register_late_pass(move || Box::new(manual_strip::ManualStrip::new(msrv)));\n     store.register_early_pass(move || Box::new(redundant_static_lifetimes::RedundantStaticLifetimes::new(msrv)));\n     store.register_early_pass(move || Box::new(redundant_field_names::RedundantFieldNames::new(msrv)));\n@@ -812,6 +826,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(move || Box::new(disallowed_methods::DisallowedMethods::new(disallowed_methods.clone())));\n     store.register_early_pass(|| Box::new(asm_syntax::InlineAsmX86AttSyntax));\n     store.register_early_pass(|| Box::new(asm_syntax::InlineAsmX86IntelSyntax));\n+    store.register_late_pass(|| Box::new(empty_drop::EmptyDrop));\n     store.register_late_pass(|| Box::new(strings::StrToString));\n     store.register_late_pass(|| Box::new(strings::StringToString));\n     store.register_late_pass(|| Box::new(zero_sized_map_values::ZeroSizedMapValues));\n@@ -868,6 +883,13 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     });\n     store.register_early_pass(|| Box::new(crate_in_macro_def::CrateInMacroDef));\n     store.register_early_pass(|| Box::new(empty_structs_with_brackets::EmptyStructsWithBrackets));\n+    store.register_late_pass(|| Box::new(unnecessary_owned_empty_strings::UnnecessaryOwnedEmptyStrings));\n+    store.register_early_pass(|| Box::new(pub_use::PubUse));\n+    store.register_late_pass(|| Box::new(format_push_string::FormatPushString));\n+    store.register_late_pass(|| Box::new(bytes_count_to_len::BytesCountToLen));\n+    let max_include_file_size = conf.max_include_file_size;\n+    store.register_late_pass(move || Box::new(large_include_file::LargeIncludeFile::new(max_include_file_size)));\n+    store.register_late_pass(|| Box::new(strings::TrimSplitWhitespace));\n     // add lints here, do not remove this comment, it's used in `new_lint`\n }\n \n@@ -919,43 +941,9 @@ fn register_removed_non_tool_lints(store: &mut rustc_lint::LintStore) {\n ///\n /// Used in `./src/driver.rs`.\n pub fn register_renamed(ls: &mut rustc_lint::LintStore) {\n-    // NOTE: when renaming a lint, add a corresponding test to tests/ui/rename.rs\n-    ls.register_renamed(\"clippy::stutter\", \"clippy::module_name_repetitions\");\n-    ls.register_renamed(\"clippy::new_without_default_derive\", \"clippy::new_without_default\");\n-    ls.register_renamed(\"clippy::cyclomatic_complexity\", \"clippy::cognitive_complexity\");\n-    ls.register_renamed(\"clippy::const_static_lifetime\", \"clippy::redundant_static_lifetimes\");\n-    ls.register_renamed(\"clippy::option_and_then_some\", \"clippy::bind_instead_of_map\");\n-    ls.register_renamed(\"clippy::box_vec\", \"clippy::box_collection\");\n-    ls.register_renamed(\"clippy::block_in_if_condition_expr\", \"clippy::blocks_in_if_conditions\");\n-    ls.register_renamed(\"clippy::block_in_if_condition_stmt\", \"clippy::blocks_in_if_conditions\");\n-    ls.register_renamed(\"clippy::option_map_unwrap_or\", \"clippy::map_unwrap_or\");\n-    ls.register_renamed(\"clippy::option_map_unwrap_or_else\", \"clippy::map_unwrap_or\");\n-    ls.register_renamed(\"clippy::result_map_unwrap_or_else\", \"clippy::map_unwrap_or\");\n-    ls.register_renamed(\"clippy::option_unwrap_used\", \"clippy::unwrap_used\");\n-    ls.register_renamed(\"clippy::result_unwrap_used\", \"clippy::unwrap_used\");\n-    ls.register_renamed(\"clippy::option_expect_used\", \"clippy::expect_used\");\n-    ls.register_renamed(\"clippy::result_expect_used\", \"clippy::expect_used\");\n-    ls.register_renamed(\"clippy::for_loop_over_option\", \"clippy::for_loops_over_fallibles\");\n-    ls.register_renamed(\"clippy::for_loop_over_result\", \"clippy::for_loops_over_fallibles\");\n-    ls.register_renamed(\"clippy::identity_conversion\", \"clippy::useless_conversion\");\n-    ls.register_renamed(\"clippy::zero_width_space\", \"clippy::invisible_characters\");\n-    ls.register_renamed(\"clippy::single_char_push_str\", \"clippy::single_char_add_str\");\n-    ls.register_renamed(\"clippy::if_let_some_result\", \"clippy::match_result_ok\");\n-    ls.register_renamed(\"clippy::disallowed_type\", \"clippy::disallowed_types\");\n-    ls.register_renamed(\"clippy::disallowed_method\", \"clippy::disallowed_methods\");\n-    ls.register_renamed(\"clippy::ref_in_deref\", \"clippy::needless_borrow\");\n-    ls.register_renamed(\"clippy::to_string_in_display\", \"clippy::recursive_format_impl\");\n-\n-    // uplifted lints\n-    ls.register_renamed(\"clippy::invalid_ref\", \"invalid_value\");\n-    ls.register_renamed(\"clippy::into_iter_on_array\", \"array_into_iter\");\n-    ls.register_renamed(\"clippy::unused_label\", \"unused_labels\");\n-    ls.register_renamed(\"clippy::drop_bounds\", \"drop_bounds\");\n-    ls.register_renamed(\"clippy::temporary_cstring_as_ptr\", \"temporary_cstring_as_ptr\");\n-    ls.register_renamed(\"clippy::panic_params\", \"non_fmt_panics\");\n-    ls.register_renamed(\"clippy::unknown_clippy_lints\", \"unknown_lints\");\n-    ls.register_renamed(\"clippy::invalid_atomic_ordering\", \"invalid_atomic_ordering\");\n-    ls.register_renamed(\"clippy::mem_discriminant_non_enum\", \"enum_intrinsics_non_enums\");\n+    for (old_name, new_name) in renamed_lints::RENAMED_LINTS {\n+        ls.register_renamed(old_name, new_name);\n+    }\n }\n \n // only exists to let the dogfood integration test works."}, {"sha": "ab5d3fa7b6d9c98b55a5c82c0a192e75f68dde13", "filename": "clippy_lints/src/lifetimes.rs", "status": "modified", "additions": 62, "deletions": 10, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flifetimes.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -1,16 +1,19 @@\n use clippy_utils::diagnostics::span_lint;\n use clippy_utils::trait_ref_of_method;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_hir::intravisit::nested_filter::{self as hir_nested_filter, NestedFilter};\n use rustc_hir::intravisit::{\n-    walk_fn_decl, walk_generic_param, walk_generics, walk_item, walk_param_bound, walk_poly_trait_ref, walk_ty, Visitor,\n+    walk_fn_decl, walk_generic_param, walk_generics, walk_impl_item_ref, walk_item, walk_param_bound,\n+    walk_poly_trait_ref, walk_trait_ref, walk_ty, Visitor,\n };\n use rustc_hir::FnRetTy::Return;\n use rustc_hir::{\n-    BareFnTy, BodyId, FnDecl, GenericArg, GenericBound, GenericParam, GenericParamKind, Generics, ImplItem,\n+    BareFnTy, BodyId, FnDecl, GenericArg, GenericBound, GenericParam, GenericParamKind, Generics, Impl, ImplItem,\n     ImplItemKind, Item, ItemKind, LangItem, Lifetime, LifetimeName, ParamName, PolyTraitRef, TraitBoundModifier,\n     TraitFn, TraitItem, TraitItemKind, Ty, TyKind, WherePredicate,\n };\n use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::hir::nested_filter as middle_nested_filter;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::Span;\n use rustc_span::symbol::{kw, Ident, Symbol};\n@@ -82,8 +85,10 @@ declare_lint_pass!(Lifetimes => [NEEDLESS_LIFETIMES, EXTRA_UNUSED_LIFETIMES]);\n \n impl<'tcx> LateLintPass<'tcx> for Lifetimes {\n     fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx Item<'_>) {\n-        if let ItemKind::Fn(ref sig, ref generics, id) = item.kind {\n+        if let ItemKind::Fn(ref sig, generics, id) = item.kind {\n             check_fn_inner(cx, sig.decl, Some(id), None, generics, item.span, true);\n+        } else if let ItemKind::Impl(impl_) = item.kind {\n+            report_extra_impl_lifetimes(cx, impl_);\n         }\n     }\n \n@@ -95,7 +100,7 @@ impl<'tcx> LateLintPass<'tcx> for Lifetimes {\n                 sig.decl,\n                 Some(id),\n                 None,\n-                &item.generics,\n+                item.generics,\n                 item.span,\n                 report_extra_lifetimes,\n             );\n@@ -108,7 +113,7 @@ impl<'tcx> LateLintPass<'tcx> for Lifetimes {\n                 TraitFn::Required(sig) => (None, Some(sig)),\n                 TraitFn::Provided(id) => (Some(id), None),\n             };\n-            check_fn_inner(cx, sig.decl, body, trait_sig, &item.generics, item.span, true);\n+            check_fn_inner(cx, sig.decl, body, trait_sig, item.generics, item.span, true);\n         }\n     }\n }\n@@ -201,8 +206,7 @@ fn explicit_self_type<'tcx>(cx: &LateContext<'tcx>, func: &FnDecl<'tcx>, ident:\n             visitor.visit_ty(self_ty);\n \n             !visitor.all_lts().is_empty()\n-        }\n-        else {\n+        } else {\n             false\n         }\n     }\n@@ -486,11 +490,29 @@ fn has_where_lifetimes<'tcx>(cx: &LateContext<'tcx>, generics: &'tcx Generics<'_\n     false\n }\n \n-struct LifetimeChecker {\n+struct LifetimeChecker<'cx, 'tcx, F> {\n+    cx: &'cx LateContext<'tcx>,\n     map: FxHashMap<Symbol, Span>,\n+    phantom: std::marker::PhantomData<F>,\n }\n \n-impl<'tcx> Visitor<'tcx> for LifetimeChecker {\n+impl<'cx, 'tcx, F> LifetimeChecker<'cx, 'tcx, F> {\n+    fn new(cx: &'cx LateContext<'tcx>, map: FxHashMap<Symbol, Span>) -> LifetimeChecker<'cx, 'tcx, F> {\n+        Self {\n+            cx,\n+            map,\n+            phantom: std::marker::PhantomData,\n+        }\n+    }\n+}\n+\n+impl<'cx, 'tcx, F> Visitor<'tcx> for LifetimeChecker<'cx, 'tcx, F>\n+where\n+    F: NestedFilter<'tcx>,\n+{\n+    type Map = rustc_middle::hir::map::Map<'tcx>;\n+    type NestedFilter = F;\n+\n     // for lifetimes as parameters of generics\n     fn visit_lifetime(&mut self, lifetime: &'tcx Lifetime) {\n         self.map.remove(&lifetime.name.ident().name);\n@@ -506,6 +528,10 @@ impl<'tcx> Visitor<'tcx> for LifetimeChecker {\n             walk_generic_param(self, param);\n         }\n     }\n+\n+    fn nested_visit_map(&mut self) -> Self::Map {\n+        self.cx.tcx.hir()\n+    }\n }\n \n fn report_extra_lifetimes<'tcx>(cx: &LateContext<'tcx>, func: &'tcx FnDecl<'_>, generics: &'tcx Generics<'_>) {\n@@ -517,7 +543,7 @@ fn report_extra_lifetimes<'tcx>(cx: &LateContext<'tcx>, func: &'tcx FnDecl<'_>,\n             _ => None,\n         })\n         .collect();\n-    let mut checker = LifetimeChecker { map: hs };\n+    let mut checker = LifetimeChecker::<hir_nested_filter::None>::new(cx, hs);\n \n     walk_generics(&mut checker, generics);\n     walk_fn_decl(&mut checker, func);\n@@ -532,6 +558,32 @@ fn report_extra_lifetimes<'tcx>(cx: &LateContext<'tcx>, func: &'tcx FnDecl<'_>,\n     }\n }\n \n+fn report_extra_impl_lifetimes<'tcx>(cx: &LateContext<'tcx>, impl_: &'tcx Impl<'_>) {\n+    let hs = impl_\n+        .generics\n+        .params\n+        .iter()\n+        .filter_map(|par| match par.kind {\n+            GenericParamKind::Lifetime { .. } => Some((par.name.ident().name, par.span)),\n+            _ => None,\n+        })\n+        .collect();\n+    let mut checker = LifetimeChecker::<middle_nested_filter::All>::new(cx, hs);\n+\n+    walk_generics(&mut checker, impl_.generics);\n+    if let Some(ref trait_ref) = impl_.of_trait {\n+        walk_trait_ref(&mut checker, trait_ref);\n+    }\n+    walk_ty(&mut checker, impl_.self_ty);\n+    for item in impl_.items {\n+        walk_impl_item_ref(&mut checker, item);\n+    }\n+\n+    for &v in checker.map.values() {\n+        span_lint(cx, EXTRA_UNUSED_LIFETIMES, v, \"this lifetime isn't used in the impl\");\n+    }\n+}\n+\n struct BodyLifetimeChecker {\n     lifetimes_used_in_body: bool,\n }"}, {"sha": "269d3c62eafcd5d0e9692f80bfb27a250cbbc0d3", "filename": "clippy_lints/src/literal_representation.rs", "status": "modified", "additions": 37, "deletions": 13, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Fliteral_representation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Fliteral_representation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fliteral_representation.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -42,17 +42,12 @@ declare_clippy_lint! {\n     /// This is most probably a typo\n     ///\n     /// ### Known problems\n-    /// - Recommends a signed suffix, even though the number might be too big and an unsigned\n-    ///   suffix is required\n+    /// - Does not match on integers too large to fit in the corresponding unsigned type\n     /// - Does not match on `_127` since that is a valid grouping for decimal and octal numbers\n     ///\n     /// ### Example\n-    /// ```rust\n-    /// // Probably mistyped\n-    /// 2_32;\n-    ///\n-    /// // Good\n-    /// 2_i32;\n+    /// `2_32` => `2_i32`\n+    /// `250_8 => `250_u8`\n     /// ```\n     #[clippy::version = \"1.30.0\"]\n     pub MISTYPED_LITERAL_SUFFIXES,\n@@ -310,18 +305,47 @@ impl LiteralDigitGrouping {\n             return true;\n         }\n \n-        let (part, mistyped_suffixes, missing_char) = if let Some((_, exponent)) = &mut num_lit.exponent {\n-            (exponent, &[\"32\", \"64\"][..], 'f')\n+        let (part, mistyped_suffixes, is_float) = if let Some((_, exponent)) = &mut num_lit.exponent {\n+            (exponent, &[\"32\", \"64\"][..], true)\n         } else if num_lit.fraction.is_some() {\n-            (&mut num_lit.integer, &[\"32\", \"64\"][..], 'f')\n+            return true;\n         } else {\n-            (&mut num_lit.integer, &[\"8\", \"16\", \"32\", \"64\"][..], 'i')\n+            (&mut num_lit.integer, &[\"8\", \"16\", \"32\", \"64\"][..], false)\n         };\n \n         let mut split = part.rsplit('_');\n         let last_group = split.next().expect(\"At least one group\");\n         if split.next().is_some() && mistyped_suffixes.contains(&last_group) {\n-            *part = &part[..part.len() - last_group.len()];\n+            let main_part = &part[..part.len() - last_group.len()];\n+            let missing_char;\n+            if is_float {\n+                missing_char = 'f';\n+            } else {\n+                let radix = match num_lit.radix {\n+                    Radix::Binary => 2,\n+                    Radix::Octal => 8,\n+                    Radix::Decimal => 10,\n+                    Radix::Hexadecimal => 16,\n+                };\n+                if let Ok(int) = u64::from_str_radix(&main_part.replace('_', \"\"), radix) {\n+                    missing_char = match (last_group, int) {\n+                        (\"8\", i) if i8::try_from(i).is_ok() => 'i',\n+                        (\"16\", i) if i16::try_from(i).is_ok() => 'i',\n+                        (\"32\", i) if i32::try_from(i).is_ok() => 'i',\n+                        (\"64\", i) if i64::try_from(i).is_ok() => 'i',\n+                        (\"8\", u) if u8::try_from(u).is_ok() => 'u',\n+                        (\"16\", u) if u16::try_from(u).is_ok() => 'u',\n+                        (\"32\", u) if u32::try_from(u).is_ok() => 'u',\n+                        (\"64\", _) => 'u',\n+                        _ => {\n+                            return true;\n+                        },\n+                    }\n+                } else {\n+                    return true;\n+                }\n+            }\n+            *part = main_part;\n             let mut sugg = num_lit.format();\n             sugg.push('_');\n             sugg.push(missing_char);"}, {"sha": "70a118d6b353930ea8c751c0eef2fe0a96b47e0b", "filename": "clippy_lints/src/loops/never_loop.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Floops%2Fnever_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Floops%2Fnever_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fnever_loop.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -168,8 +168,9 @@ fn never_loop_expr(expr: &Expr<'_>, main_loop_id: HirId) -> NeverLoopResult {\n             .operands\n             .iter()\n             .map(|(o, _)| match o {\n-                InlineAsmOperand::In { expr, .. }\n-                | InlineAsmOperand::InOut { expr, .. } => never_loop_expr(expr, main_loop_id),\n+                InlineAsmOperand::In { expr, .. } | InlineAsmOperand::InOut { expr, .. } => {\n+                    never_loop_expr(expr, main_loop_id)\n+                },\n                 InlineAsmOperand::Out { expr, .. } => never_loop_expr_all(&mut expr.iter(), main_loop_id),\n                 InlineAsmOperand::SplitInOut { in_expr, out_expr, .. } => {\n                     never_loop_expr_all(&mut once(in_expr).chain(out_expr.iter()), main_loop_id)"}, {"sha": "ac3d9447b6bd3d35fc2472e35ca7dd00ad84eb9e", "filename": "clippy_lints/src/manual_bits.rs", "status": "modified", "additions": 42, "deletions": 6, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Fmanual_bits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Fmanual_bits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmanual_bits.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -1,6 +1,6 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::source::snippet_opt;\n-use clippy_utils::{meets_msrv, msrvs};\n+use clippy_utils::source::snippet_with_applicability;\n+use clippy_utils::{get_parent_expr, meets_msrv, msrvs};\n use rustc_ast::ast::LitKind;\n use rustc_errors::Applicability;\n use rustc_hir::{BinOpKind, Expr, ExprKind, GenericArg, QPath};\n@@ -24,7 +24,7 @@ declare_clippy_lint! {\n     /// ```\n     /// Use instead:\n     /// ```rust\n-    /// usize::BITS;\n+    /// usize::BITS as usize;\n     /// ```\n     #[clippy::version = \"1.60.0\"]\n     pub MANUAL_BITS,\n@@ -59,16 +59,19 @@ impl<'tcx> LateLintPass<'tcx> for ManualBits {\n             if matches!(resolved_ty.kind(), ty::Int(_) | ty::Uint(_));\n             if let ExprKind::Lit(lit) = &other_expr.kind;\n             if let LitKind::Int(8, _) = lit.node;\n-\n             then {\n+                let mut app = Applicability::MachineApplicable;\n+                let ty_snip = snippet_with_applicability(cx, real_ty.span, \"..\", &mut app);\n+                let sugg = create_sugg(cx, expr, format!(\"{ty_snip}::BITS\"));\n+\n                 span_lint_and_sugg(\n                     cx,\n                     MANUAL_BITS,\n                     expr.span,\n                     \"usage of `mem::size_of::<T>()` to obtain the size of `T` in bits\",\n                     \"consider using\",\n-                    format!(\"{}::BITS\", snippet_opt(cx, real_ty.span).unwrap()),\n-                    Applicability::MachineApplicable,\n+                    sugg,\n+                    app,\n                 );\n             }\n         }\n@@ -108,3 +111,36 @@ fn get_size_of_ty<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> Option<\n         }\n     }\n }\n+\n+fn create_sugg(cx: &LateContext<'_>, expr: &Expr<'_>, base_sugg: String) -> String {\n+    if let Some(parent_expr) = get_parent_expr(cx, expr) {\n+        if is_ty_conversion(parent_expr) {\n+            return base_sugg;\n+        }\n+\n+        // These expressions have precedence over casts, the suggestion therefore\n+        // needs to be wrapped into parentheses\n+        match parent_expr.kind {\n+            ExprKind::Unary(..) | ExprKind::AddrOf(..) | ExprKind::MethodCall(..) => {\n+                return format!(\"({base_sugg} as usize)\");\n+            },\n+            _ => {},\n+        }\n+    }\n+\n+    format!(\"{base_sugg} as usize\")\n+}\n+\n+fn is_ty_conversion(expr: &Expr<'_>) -> bool {\n+    if let ExprKind::Cast(..) = expr.kind {\n+        true\n+    } else if let ExprKind::MethodCall(path, [_], _) = expr.kind\n+        && path.ident.name == rustc_span::sym::try_into\n+    {\n+        // This is only called for `usize` which implements `TryInto`. Therefore,\n+        // we don't have to check here if `self` implements the `TryInto` trait.\n+        true\n+    } else {\n+        false\n+    }\n+}"}, {"sha": "b8d620d81713046ac5892d9c6239cb72157d240f", "filename": "clippy_lints/src/manual_non_exhaustive.rs", "status": "modified", "additions": 116, "deletions": 81, "changes": 197, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Fmanual_non_exhaustive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Fmanual_non_exhaustive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmanual_non_exhaustive.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -1,13 +1,17 @@\n use clippy_utils::attrs::is_doc_hidden;\n use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::source::snippet_opt;\n-use clippy_utils::{meets_msrv, msrvs};\n-use if_chain::if_chain;\n-use rustc_ast::ast::{FieldDef, Item, ItemKind, Variant, VariantData, VisibilityKind};\n+use clippy_utils::{is_lint_allowed, meets_msrv, msrvs};\n+use rustc_ast::ast::{self, VisibilityKind};\n+use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::Applicability;\n-use rustc_lint::{EarlyContext, EarlyLintPass, LintContext};\n+use rustc_hir::def::{CtorKind, CtorOf, DefKind, Res};\n+use rustc_hir::{self as hir, Expr, ExprKind, QPath};\n+use rustc_lint::{EarlyContext, EarlyLintPass, LateContext, LateLintPass, LintContext};\n+use rustc_middle::ty::DefIdTree;\n use rustc_semver::RustcVersion;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n+use rustc_span::def_id::{DefId, LocalDefId};\n use rustc_span::{sym, Span};\n \n declare_clippy_lint! {\n@@ -58,129 +62,160 @@ declare_clippy_lint! {\n     \"manual implementations of the non-exhaustive pattern can be simplified using #[non_exhaustive]\"\n }\n \n-#[derive(Clone)]\n-pub struct ManualNonExhaustive {\n+#[allow(clippy::module_name_repetitions)]\n+pub struct ManualNonExhaustiveStruct {\n     msrv: Option<RustcVersion>,\n }\n \n-impl ManualNonExhaustive {\n+impl ManualNonExhaustiveStruct {\n     #[must_use]\n     pub fn new(msrv: Option<RustcVersion>) -> Self {\n         Self { msrv }\n     }\n }\n \n-impl_lint_pass!(ManualNonExhaustive => [MANUAL_NON_EXHAUSTIVE]);\n+impl_lint_pass!(ManualNonExhaustiveStruct => [MANUAL_NON_EXHAUSTIVE]);\n \n-impl EarlyLintPass for ManualNonExhaustive {\n-    fn check_item(&mut self, cx: &EarlyContext<'_>, item: &Item) {\n-        if !meets_msrv(self.msrv.as_ref(), &msrvs::NON_EXHAUSTIVE) {\n-            return;\n-        }\n+#[allow(clippy::module_name_repetitions)]\n+pub struct ManualNonExhaustiveEnum {\n+    msrv: Option<RustcVersion>,\n+    constructed_enum_variants: FxHashSet<(DefId, DefId)>,\n+    potential_enums: Vec<(LocalDefId, LocalDefId, Span, Span)>,\n+}\n \n-        match &item.kind {\n-            ItemKind::Enum(def, _) => {\n-                check_manual_non_exhaustive_enum(cx, item, &def.variants);\n-            },\n-            ItemKind::Struct(variant_data, _) => {\n-                if let VariantData::Unit(..) = variant_data {\n-                    return;\n-                }\n-\n-                check_manual_non_exhaustive_struct(cx, item, variant_data);\n-            },\n-            _ => {},\n+impl ManualNonExhaustiveEnum {\n+    #[must_use]\n+    pub fn new(msrv: Option<RustcVersion>) -> Self {\n+        Self {\n+            msrv,\n+            constructed_enum_variants: FxHashSet::default(),\n+            potential_enums: Vec::new(),\n         }\n     }\n-\n-    extract_msrv_attr!(EarlyContext);\n }\n \n-fn check_manual_non_exhaustive_enum(cx: &EarlyContext<'_>, item: &Item, variants: &[Variant]) {\n-    fn is_non_exhaustive_marker(variant: &Variant) -> bool {\n-        matches!(variant.data, VariantData::Unit(_))\n-            && variant.ident.as_str().starts_with('_')\n-            && is_doc_hidden(&variant.attrs)\n-    }\n+impl_lint_pass!(ManualNonExhaustiveEnum => [MANUAL_NON_EXHAUSTIVE]);\n \n-    let mut markers = variants.iter().filter(|v| is_non_exhaustive_marker(v));\n-    if_chain! {\n-        if let Some(marker) = markers.next();\n-        if markers.count() == 0 && variants.len() > 1;\n-        then {\n-            span_lint_and_then(\n-                cx,\n-                MANUAL_NON_EXHAUSTIVE,\n-                item.span,\n-                \"this seems like a manual implementation of the non-exhaustive pattern\",\n-                |diag| {\n-                    if_chain! {\n-                        if !item.attrs.iter().any(|attr| attr.has_name(sym::non_exhaustive));\n-                        let header_span = cx.sess().source_map().span_until_char(item.span, '{');\n-                        if let Some(snippet) = snippet_opt(cx, header_span);\n-                        then {\n+impl EarlyLintPass for ManualNonExhaustiveStruct {\n+    fn check_item(&mut self, cx: &EarlyContext<'_>, item: &ast::Item) {\n+        if !meets_msrv(self.msrv.as_ref(), &msrvs::NON_EXHAUSTIVE) {\n+            return;\n+        }\n+\n+        if let ast::ItemKind::Struct(variant_data, _) = &item.kind {\n+            let (fields, delimiter) = match variant_data {\n+                ast::VariantData::Struct(fields, _) => (&**fields, '{'),\n+                ast::VariantData::Tuple(fields, _) => (&**fields, '('),\n+                ast::VariantData::Unit(_) => return,\n+            };\n+            if fields.len() <= 1 {\n+                return;\n+            }\n+            let mut iter = fields.iter().filter_map(|f| match f.vis.kind {\n+                VisibilityKind::Public => None,\n+                VisibilityKind::Inherited => Some(Ok(f)),\n+                _ => Some(Err(())),\n+            });\n+            if let Some(Ok(field)) = iter.next()\n+                && iter.next().is_none()\n+                && field.ty.kind.is_unit()\n+                && field.ident.map_or(true, |name| name.as_str().starts_with('_'))\n+            {\n+                span_lint_and_then(\n+                    cx,\n+                    MANUAL_NON_EXHAUSTIVE,\n+                    item.span,\n+                    \"this seems like a manual implementation of the non-exhaustive pattern\",\n+                    |diag| {\n+                        if !item.attrs.iter().any(|attr| attr.has_name(sym::non_exhaustive))\n+                            && let header_span = cx.sess().source_map().span_until_char(item.span, delimiter)\n+                            && let Some(snippet) = snippet_opt(cx, header_span)\n+                        {\n                             diag.span_suggestion(\n                                 header_span,\n                                 \"add the attribute\",\n                                 format!(\"#[non_exhaustive] {}\", snippet),\n                                 Applicability::Unspecified,\n                             );\n                         }\n+                        diag.span_help(field.span, \"remove this field\");\n                     }\n-                    diag.span_help(marker.span, \"remove this variant\");\n-                });\n+                );\n+            }\n         }\n     }\n+\n+    extract_msrv_attr!(EarlyContext);\n }\n \n-fn check_manual_non_exhaustive_struct(cx: &EarlyContext<'_>, item: &Item, data: &VariantData) {\n-    fn is_private(field: &FieldDef) -> bool {\n-        matches!(field.vis.kind, VisibilityKind::Inherited)\n-    }\n+impl<'tcx> LateLintPass<'tcx> for ManualNonExhaustiveEnum {\n+    fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::Item<'_>) {\n+        if !meets_msrv(self.msrv.as_ref(), &msrvs::NON_EXHAUSTIVE) {\n+            return;\n+        }\n \n-    fn is_non_exhaustive_marker(field: &FieldDef) -> bool {\n-        is_private(field) && field.ty.kind.is_unit() && field.ident.map_or(true, |n| n.as_str().starts_with('_'))\n+        if let hir::ItemKind::Enum(def, _) = &item.kind\n+            && def.variants.len() > 1\n+        {\n+            let mut iter = def.variants.iter().filter_map(|v| {\n+                let id = cx.tcx.hir().local_def_id(v.id);\n+                (matches!(v.data, hir::VariantData::Unit(_))\n+                    && v.ident.as_str().starts_with('_')\n+                    && is_doc_hidden(cx.tcx.get_attrs(id.to_def_id())))\n+                .then(|| (id, v.span))\n+            });\n+            if let Some((id, span)) = iter.next()\n+                && iter.next().is_none()\n+            {\n+                self.potential_enums.push((item.def_id, id, item.span, span));\n+            }\n+        }\n     }\n \n-    fn find_header_span(cx: &EarlyContext<'_>, item: &Item, data: &VariantData) -> Span {\n-        let delimiter = match data {\n-            VariantData::Struct(..) => '{',\n-            VariantData::Tuple(..) => '(',\n-            VariantData::Unit(_) => unreachable!(\"`VariantData::Unit` is already handled above\"),\n-        };\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) {\n+        if let ExprKind::Path(QPath::Resolved(None, p)) = &e.kind\n+            && let [.., name] = p.segments\n+            && let Res::Def(DefKind::Ctor(CtorOf::Variant, CtorKind::Const), id) = p.res\n+            && name.ident.as_str().starts_with('_')\n+        {\n+            let variant_id = cx.tcx.parent(id);\n+            let enum_id = cx.tcx.parent(variant_id);\n \n-        cx.sess().source_map().span_until_char(item.span, delimiter)\n+            self.constructed_enum_variants.insert((enum_id, variant_id));\n+        }\n     }\n \n-    let fields = data.fields();\n-    let private_fields = fields.iter().filter(|f| is_private(f)).count();\n-    let public_fields = fields.iter().filter(|f| f.vis.kind.is_pub()).count();\n-\n-    if_chain! {\n-        if private_fields == 1 && public_fields >= 1 && public_fields == fields.len() - 1;\n-        if let Some(marker) = fields.iter().find(|f| is_non_exhaustive_marker(f));\n-        then {\n+    fn check_crate_post(&mut self, cx: &LateContext<'tcx>) {\n+        for &(enum_id, _, enum_span, variant_span) in\n+            self.potential_enums.iter().filter(|&&(enum_id, variant_id, _, _)| {\n+                !self\n+                    .constructed_enum_variants\n+                    .contains(&(enum_id.to_def_id(), variant_id.to_def_id()))\n+                    && !is_lint_allowed(cx, MANUAL_NON_EXHAUSTIVE, cx.tcx.hir().local_def_id_to_hir_id(enum_id))\n+            })\n+        {\n             span_lint_and_then(\n                 cx,\n                 MANUAL_NON_EXHAUSTIVE,\n-                item.span,\n+                enum_span,\n                 \"this seems like a manual implementation of the non-exhaustive pattern\",\n                 |diag| {\n-                    if_chain! {\n-                        if !item.attrs.iter().any(|attr| attr.has_name(sym::non_exhaustive));\n-                        let header_span = find_header_span(cx, item, data);\n-                        if let Some(snippet) = snippet_opt(cx, header_span);\n-                        then {\n+                    if !cx.tcx.adt_def(enum_id).is_variant_list_non_exhaustive()\n+                        && let header_span = cx.sess().source_map().span_until_char(enum_span, '{')\n+                        && let Some(snippet) = snippet_opt(cx, header_span)\n+                    {\n                             diag.span_suggestion(\n                                 header_span,\n                                 \"add the attribute\",\n                                 format!(\"#[non_exhaustive] {}\", snippet),\n                                 Applicability::Unspecified,\n                             );\n-                        }\n                     }\n-                    diag.span_help(marker.span, \"remove this field\");\n-                });\n+                    diag.span_help(variant_span, \"remove this variant\");\n+                },\n+            );\n         }\n     }\n+\n+    extract_msrv_attr!(LateContext);\n }"}, {"sha": "ceb66947d02c6717a0ba802f61268997c00e48f0", "filename": "clippy_lints/src/map_clone.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Fmap_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Fmap_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmap_clone.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -143,15 +143,11 @@ fn lint_needless_cloning(cx: &LateContext<'_>, root: Span, receiver: Span) {\n impl MapClone {\n     fn lint_explicit_closure(&self, cx: &LateContext<'_>, replace: Span, root: Span, is_copy: bool) {\n         let mut applicability = Applicability::MachineApplicable;\n-        let message = if is_copy {\n-            \"you are using an explicit closure for copying elements\"\n-        } else {\n-            \"you are using an explicit closure for cloning elements\"\n-        };\n-        let sugg_method = if is_copy && meets_msrv(self.msrv.as_ref(), &msrvs::ITERATOR_COPIED) {\n-            \"copied\"\n+\n+        let (message, sugg_method) = if is_copy && meets_msrv(self.msrv.as_ref(), &msrvs::ITERATOR_COPIED) {\n+            (\"you are using an explicit closure for copying elements\", \"copied\")\n         } else {\n-            \"cloned\"\n+            (\"you are using an explicit closure for cloning elements\", \"cloned\")\n         };\n \n         span_lint_and_sugg("}, {"sha": "3349b85f1347a396519aeb5cba96c59813c93cec", "filename": "clippy_lints/src/match_result_ok.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Fmatch_result_ok.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Fmatch_result_ok.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatch_result_ok.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -24,7 +24,7 @@ declare_clippy_lint! {\n     ///     vec.push(value)\n     /// }\n     ///\n-    /// if let Some(valie) = iter.next().ok() {\n+    /// if let Some(value) = iter.next().ok() {\n     ///     vec.push(value)\n     /// }\n     /// ```\n@@ -60,7 +60,7 @@ impl<'tcx> LateLintPass<'tcx> for MatchResultOk {\n         if_chain! {\n             if let ExprKind::MethodCall(ok_path, [ref result_types_0, ..], _) = let_expr.kind; //check is expr.ok() has type Result<T,E>.ok(, _)\n             if let PatKind::TupleStruct(QPath::Resolved(_, x), y, _)  = let_pat.kind; //get operation\n-            if method_chain_args(let_expr, &[\"ok\"]).is_some(); //test to see if using ok() methoduse std::marker::Sized;\n+            if method_chain_args(let_expr, &[\"ok\"]).is_some(); //test to see if using ok() method use std::marker::Sized;\n             if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(result_types_0), sym::Result);\n             if rustc_hir_pretty::to_string(rustc_hir_pretty::NO_ANN, |s| s.print_path(x, false)) == \"Some\";\n "}, {"sha": "2472acb6f6e8b6f974fcf898010e45140bc021ff", "filename": "clippy_lints/src/matches/infallible_destructuring_match.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Fmatches%2Finfallible_destructuring_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Fmatches%2Finfallible_destructuring_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Finfallible_destructuring_match.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "previous_filename": "clippy_lints/src/matches/infalliable_detructuring_match.rs"}, {"sha": "9b7344fb8b0b21a93d9f5a69a9d698921e6c0771", "filename": "clippy_lints/src/matches/match_same_arms.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Fmatches%2Fmatch_same_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Fmatches%2Fmatch_same_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fmatch_same_arms.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -30,7 +30,7 @@ pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, arms: &'tcx [Arm<'_>]) {\n         .map(|a| NormalizedPat::from_pat(cx, &arena, a.pat))\n         .collect();\n \n-    // The furthast forwards a pattern can move without semantic changes\n+    // The furthest forwards a pattern can move without semantic changes\n     let forwards_blocking_idxs: Vec<_> = normalized_pats\n         .iter()\n         .enumerate()\n@@ -43,7 +43,7 @@ pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, arms: &'tcx [Arm<'_>]) {\n         })\n         .collect();\n \n-    // The furthast backwards a pattern can move without semantic changes\n+    // The furthest backwards a pattern can move without semantic changes\n     let backwards_blocking_idxs: Vec<_> = normalized_pats\n         .iter()\n         .enumerate()"}, {"sha": "401ecef460c35cefd52f225576b5ddbd73b021ce", "filename": "clippy_lints/src/matches/mod.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fmod.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -1,4 +1,4 @@\n-use clippy_utils::source::{snippet_opt, walk_span_to_context};\n+use clippy_utils::source::{snippet_opt, span_starts_with, walk_span_to_context};\n use clippy_utils::{meets_msrv, msrvs};\n use rustc_hir::{Arm, Expr, ExprKind, Local, MatchSource, Pat};\n use rustc_lexer::{tokenize, TokenKind};\n@@ -7,7 +7,7 @@ use rustc_semver::RustcVersion;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::{Span, SpanData, SyntaxContext};\n \n-mod infalliable_detructuring_match;\n+mod infallible_destructuring_match;\n mod match_as_ref;\n mod match_bool;\n mod match_like_matches;\n@@ -653,6 +653,9 @@ impl<'tcx> LateLintPass<'tcx> for Matches {\n         }\n \n         if let ExprKind::Match(ex, arms, source) = expr.kind {\n+            if !span_starts_with(cx, expr.span, \"match\") {\n+                return;\n+            }\n             if !contains_cfg_arm(cx, expr, ex, arms) {\n                 if source == MatchSource::Normal {\n                     if !(meets_msrv(self.msrv.as_ref(), &msrvs::MATCHES_MACRO)\n@@ -691,7 +694,7 @@ impl<'tcx> LateLintPass<'tcx> for Matches {\n     }\n \n     fn check_local(&mut self, cx: &LateContext<'tcx>, local: &'tcx Local<'_>) {\n-        self.infallible_destructuring_match_linted |= infalliable_detructuring_match::check(cx, local);\n+        self.infallible_destructuring_match_linted |= infallible_destructuring_match::check(cx, local);\n     }\n \n     fn check_pat(&mut self, cx: &LateContext<'tcx>, pat: &'tcx Pat<'_>) {"}, {"sha": "f920ad4651f9d4b8c8d304cfb55bd1e99eb1d73c", "filename": "clippy_lints/src/matches/needless_match.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Fmatches%2Fneedless_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Fmatches%2Fneedless_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fneedless_match.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -83,7 +83,7 @@ fn check_if_let(cx: &LateContext<'_>, if_let: &higher::IfLet<'_>) -> bool {\n             return false;\n         }\n \n-        // Recurrsively check for each `else if let` phrase,\n+        // Recursively check for each `else if let` phrase,\n         if let Some(ref nested_if_let) = higher::IfLet::hir(cx, if_else) {\n             return check_if_let(cx, nested_if_let);\n         }\n@@ -99,7 +99,7 @@ fn check_if_let(cx: &LateContext<'_>, if_let: &higher::IfLet<'_>) -> bool {\n                 if let ExprKind::Path(ref qpath) = ret.kind {\n                     return is_lang_ctor(cx, qpath, OptionNone) || eq_expr_value(cx, if_let.let_expr, ret);\n                 }\n-                return true;\n+                return false;\n             }\n             return eq_expr_value(cx, if_let.let_expr, ret);\n         }\n@@ -118,7 +118,7 @@ fn strip_return<'hir>(expr: &'hir Expr<'hir>) -> &'hir Expr<'hir> {\n }\n \n /// Manually check for coercion casting by checking if the type of the match operand or let expr\n-/// differs with the assigned local variable or the funtion return type.\n+/// differs with the assigned local variable or the function return type.\n fn expr_ty_matches_p_ty(cx: &LateContext<'_>, expr: &Expr<'_>, p_expr: &Expr<'_>) -> bool {\n     if let Some(p_node) = get_parent_node(cx.tcx, p_expr.hir_id) {\n         match p_node {"}, {"sha": "37b67647efe9e0d6b54abddce1cbec6d5390f65d", "filename": "clippy_lints/src/matches/redundant_pattern_match.rs", "status": "modified", "additions": 6, "deletions": 60, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Fmatches%2Fredundant_pattern_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Fmatches%2Fredundant_pattern_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fredundant_pattern_match.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -2,17 +2,16 @@ use super::REDUNDANT_PATTERN_MATCHING;\n use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::source::snippet;\n use clippy_utils::sugg::Sugg;\n-use clippy_utils::ty::{implements_trait, is_type_diagnostic_item, is_type_lang_item, match_type};\n+use clippy_utils::ty::needs_ordered_drop;\n use clippy_utils::{higher, match_def_path};\n use clippy_utils::{is_lang_ctor, is_trait_method, paths};\n use if_chain::if_chain;\n use rustc_ast::ast::LitKind;\n-use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::Applicability;\n use rustc_hir::LangItem::{OptionNone, PollPending};\n use rustc_hir::{\n     intravisit::{walk_expr, Visitor},\n-    Arm, Block, Expr, ExprKind, LangItem, Node, Pat, PatKind, QPath, UnOp,\n+    Arm, Block, Expr, ExprKind, Node, Pat, PatKind, QPath, UnOp,\n };\n use rustc_lint::LateContext;\n use rustc_middle::ty::{self, subst::GenericArgKind, DefIdTree, Ty};\n@@ -32,59 +31,6 @@ pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n     }\n }\n \n-/// Checks if the drop order for a type matters. Some std types implement drop solely to\n-/// deallocate memory. For these types, and composites containing them, changing the drop order\n-/// won't result in any observable side effects.\n-fn type_needs_ordered_drop<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n-    type_needs_ordered_drop_inner(cx, ty, &mut FxHashSet::default())\n-}\n-\n-fn type_needs_ordered_drop_inner<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, seen: &mut FxHashSet<Ty<'tcx>>) -> bool {\n-    if !seen.insert(ty) {\n-        return false;\n-    }\n-    if !ty.needs_drop(cx.tcx, cx.param_env) {\n-        false\n-    } else if !cx\n-        .tcx\n-        .lang_items()\n-        .drop_trait()\n-        .map_or(false, |id| implements_trait(cx, ty, id, &[]))\n-    {\n-        // This type doesn't implement drop, so no side effects here.\n-        // Check if any component type has any.\n-        match ty.kind() {\n-            ty::Tuple(fields) => fields.iter().any(|ty| type_needs_ordered_drop_inner(cx, ty, seen)),\n-            ty::Array(ty, _) => type_needs_ordered_drop_inner(cx, *ty, seen),\n-            ty::Adt(adt, subs) => adt\n-                .all_fields()\n-                .map(|f| f.ty(cx.tcx, subs))\n-                .any(|ty| type_needs_ordered_drop_inner(cx, ty, seen)),\n-            _ => true,\n-        }\n-    }\n-    // Check for std types which implement drop, but only for memory allocation.\n-    else if is_type_diagnostic_item(cx, ty, sym::Vec)\n-        || is_type_lang_item(cx, ty, LangItem::OwnedBox)\n-        || is_type_diagnostic_item(cx, ty, sym::Rc)\n-        || is_type_diagnostic_item(cx, ty, sym::Arc)\n-        || is_type_diagnostic_item(cx, ty, sym::cstring_type)\n-        || is_type_diagnostic_item(cx, ty, sym::BTreeMap)\n-        || is_type_diagnostic_item(cx, ty, sym::LinkedList)\n-        || match_type(cx, ty, &paths::WEAK_RC)\n-        || match_type(cx, ty, &paths::WEAK_ARC)\n-    {\n-        // Check all of the generic arguments.\n-        if let ty::Adt(_, subs) = ty.kind() {\n-            subs.types().any(|ty| type_needs_ordered_drop_inner(cx, ty, seen))\n-        } else {\n-            true\n-        }\n-    } else {\n-        true\n-    }\n-}\n-\n // Extract the generic arguments out of a type\n fn try_get_generic_ty(ty: Ty<'_>, index: usize) -> Option<Ty<'_>> {\n     if_chain! {\n@@ -115,7 +61,7 @@ fn temporaries_need_ordered_drop<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<\n                 // e.g. In `(String::new(), 0).1` the string is a temporary value.\n                 ExprKind::AddrOf(_, _, expr) | ExprKind::Field(expr, _) => {\n                     if !matches!(expr.kind, ExprKind::Path(_)) {\n-                        if type_needs_ordered_drop(self.cx, self.cx.typeck_results().expr_ty(expr)) {\n+                        if needs_ordered_drop(self.cx, self.cx.typeck_results().expr_ty(expr)) {\n                             self.res = true;\n                         } else {\n                             self.visit_expr(expr);\n@@ -126,7 +72,7 @@ fn temporaries_need_ordered_drop<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<\n                 // e.g. In `(vec![0])[0]` the vector is a temporary value.\n                 ExprKind::Index(base, index) => {\n                     if !matches!(base.kind, ExprKind::Path(_)) {\n-                        if type_needs_ordered_drop(self.cx, self.cx.typeck_results().expr_ty(base)) {\n+                        if needs_ordered_drop(self.cx, self.cx.typeck_results().expr_ty(base)) {\n                             self.res = true;\n                         } else {\n                             self.visit_expr(base);\n@@ -143,7 +89,7 @@ fn temporaries_need_ordered_drop<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<\n                             .typeck_results()\n                             .type_dependent_def_id(expr.hir_id)\n                             .map_or(false, |id| self.cx.tcx.fn_sig(id).skip_binder().inputs()[0].is_ref());\n-                        if self_by_ref && type_needs_ordered_drop(self.cx, self.cx.typeck_results().expr_ty(self_arg)) {\n+                        if self_by_ref && needs_ordered_drop(self.cx, self.cx.typeck_results().expr_ty(self_arg)) {\n                             self.res = true;\n                         } else {\n                             self.visit_expr(self_arg);\n@@ -243,7 +189,7 @@ fn find_sugg_for_if_let<'tcx>(\n     // scrutinee would be, so they have to be considered as well.\n     // e.g. in `if let Some(x) = foo.lock().unwrap().baz.as_ref() { .. }` the lock will be held\n     // for the duration if body.\n-    let needs_drop = type_needs_ordered_drop(cx, check_ty) || temporaries_need_ordered_drop(cx, let_expr);\n+    let needs_drop = needs_ordered_drop(cx, check_ty) || temporaries_need_ordered_drop(cx, let_expr);\n \n     // check that `while_let_on_iterator` lint does not trigger\n     if_chain! {"}, {"sha": "0aadb482acddad443b4161732e31cc7871937146", "filename": "clippy_lints/src/matches/rest_pat_in_fully_bound_struct.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Fmatches%2Frest_pat_in_fully_bound_struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Fmatches%2Frest_pat_in_fully_bound_struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Frest_pat_in_fully_bound_struct.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -14,6 +14,7 @@ pub(crate) fn check(cx: &LateContext<'_>, pat: &Pat<'_>) {\n         if let ty::Adt(def, _) = ty.kind();\n         if def.is_struct() || def.is_union();\n         if fields.len() == def.non_enum_variant().fields.len();\n+        if !def.non_enum_variant().is_field_list_non_exhaustive();\n \n         then {\n             span_lint_and_help("}, {"sha": "ad333df2f2d5d7f24f33b85050a3a021a4729333", "filename": "clippy_lints/src/methods/is_digit_ascii_radix.rs", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Fmethods%2Fis_digit_ascii_radix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Fmethods%2Fis_digit_ascii_radix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fis_digit_ascii_radix.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -0,0 +1,50 @@\n+//! Lint for `c.is_digit(10)`\n+\n+use super::IS_DIGIT_ASCII_RADIX;\n+use clippy_utils::{\n+    consts::constant_full_int, consts::FullInt, diagnostics::span_lint_and_sugg, meets_msrv, msrvs,\n+    source::snippet_with_applicability,\n+};\n+use rustc_errors::Applicability;\n+use rustc_hir::Expr;\n+use rustc_lint::LateContext;\n+use rustc_semver::RustcVersion;\n+\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx Expr<'_>,\n+    self_arg: &'tcx Expr<'_>,\n+    radix: &'tcx Expr<'_>,\n+    msrv: Option<&RustcVersion>,\n+) {\n+    if !meets_msrv(msrv, &msrvs::IS_ASCII_DIGIT) {\n+        return;\n+    }\n+\n+    if !cx.typeck_results().expr_ty_adjusted(self_arg).peel_refs().is_char() {\n+        return;\n+    }\n+\n+    if let Some(radix_val) = constant_full_int(cx, cx.typeck_results(), radix) {\n+        let (num, replacement) = match radix_val {\n+            FullInt::S(10) | FullInt::U(10) => (10, \"is_ascii_digit\"),\n+            FullInt::S(16) | FullInt::U(16) => (16, \"is_ascii_hexdigit\"),\n+            _ => return,\n+        };\n+        let mut applicability = Applicability::MachineApplicable;\n+\n+        span_lint_and_sugg(\n+            cx,\n+            IS_DIGIT_ASCII_RADIX,\n+            expr.span,\n+            &format!(\"use of `char::is_digit` with literal radix of {}\", num),\n+            \"try\",\n+            format!(\n+                \"{}.{}()\",\n+                snippet_with_applicability(cx, self_arg.span, \"..\", &mut applicability),\n+                replacement\n+            ),\n+            applicability,\n+        );\n+    }\n+}"}, {"sha": "152072e09c77275795922332495b9622baea5335", "filename": "clippy_lints/src/methods/iter_with_drain.rs", "status": "modified", "additions": 33, "deletions": 58, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Fmethods%2Fiter_with_drain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Fmethods%2Fiter_with_drain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fiter_with_drain.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -1,72 +1,47 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::higher::Range;\n use clippy_utils::is_integer_const;\n-use clippy_utils::ty::is_type_diagnostic_item;\n-use clippy_utils::{\n-    higher::{self, Range},\n-    SpanlessEq,\n-};\n use rustc_ast::ast::RangeLimits;\n use rustc_errors::Applicability;\n use rustc_hir::{Expr, ExprKind, QPath};\n use rustc_lint::LateContext;\n-use rustc_span::symbol::{sym, Symbol};\n+use rustc_span::symbol::sym;\n use rustc_span::Span;\n \n use super::ITER_WITH_DRAIN;\n \n-const DRAIN_TYPES: &[Symbol] = &[sym::Vec, sym::VecDeque];\n-\n pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>, recv: &Expr<'_>, span: Span, arg: &Expr<'_>) {\n-    let ty = cx.typeck_results().expr_ty(recv).peel_refs();\n-    if let Some(drained_type) = DRAIN_TYPES.iter().find(|&&sym| is_type_diagnostic_item(cx, ty, sym)) {\n-        // Refuse to emit `into_iter` suggestion on draining struct fields due\n-        // to the strong possibility of processing unmovable field.\n-        if let ExprKind::Field(..) = recv.kind {\n-            return;\n-        }\n+    if !matches!(recv.kind, ExprKind::Field(..))\n+        && let Some(adt) = cx.typeck_results().expr_ty(recv).ty_adt_def()\n+        && let Some(ty_name) = cx.tcx.get_diagnostic_name(adt.did())\n+        && matches!(ty_name, sym::Vec | sym::VecDeque)\n+        && let Some(range) = Range::hir(arg)\n+        && is_full_range(cx, recv, range)\n+    {\n+        span_lint_and_sugg(\n+            cx,\n+            ITER_WITH_DRAIN,\n+            span.with_hi(expr.span.hi()),\n+            &format!(\"`drain(..)` used on a `{}`\", ty_name),\n+            \"try this\",\n+            \"into_iter()\".to_string(),\n+            Applicability::MaybeIncorrect,\n+        );\n+    };\n+}\n \n-        if let Some(range) = higher::Range::hir(arg) {\n-            let left_full = match range {\n-                Range { start: Some(start), .. } if is_integer_const(cx, start, 0) => true,\n-                Range { start: None, .. } => true,\n-                _ => false,\n-            };\n-            let full = left_full\n-                && match range {\n-                    Range {\n-                        end: Some(end),\n-                        limits: RangeLimits::HalfOpen,\n-                        ..\n-                    } => {\n-                        // `x.drain(..x.len())` call\n-                        if_chain! {\n-                            if let ExprKind::MethodCall(len_path, len_args, _) = end.kind;\n-                            if len_path.ident.name == sym::len && len_args.len() == 1;\n-                            if let ExprKind::Path(QPath::Resolved(_, drain_path)) = recv.kind;\n-                            if let ExprKind::Path(QPath::Resolved(_, len_path)) = len_args[0].kind;\n-                            if SpanlessEq::new(cx).eq_path(drain_path, len_path);\n-                            then { true }\n-                            else { false }\n-                        }\n-                    },\n-                    Range {\n-                        end: None,\n-                        limits: RangeLimits::HalfOpen,\n-                        ..\n-                    } => true,\n-                    _ => false,\n-                };\n-            if full {\n-                span_lint_and_sugg(\n-                    cx,\n-                    ITER_WITH_DRAIN,\n-                    span.with_hi(expr.span.hi()),\n-                    &format!(\"`drain(..)` used on a `{}`\", drained_type),\n-                    \"try this\",\n-                    \"into_iter()\".to_string(),\n-                    Applicability::MaybeIncorrect,\n-                );\n+fn is_full_range(cx: &LateContext<'_>, container: &Expr<'_>, range: Range<'_>) -> bool {\n+    range.start.map_or(true, |e| is_integer_const(cx, e, 0))\n+        && range.end.map_or(true, |e| {\n+            if range.limits == RangeLimits::HalfOpen\n+                && let ExprKind::Path(QPath::Resolved(None, container_path)) = container.kind\n+                && let ExprKind::MethodCall(name, [self_arg], _) = e.kind\n+                && name.ident.name == sym::len\n+                && let ExprKind::Path(QPath::Resolved(None, path)) = self_arg.kind\n+            {\n+                container_path.res == path.res\n+            } else {\n+                false\n             }\n-        }\n-    }\n+        })\n }"}, {"sha": "f3be71f6b8bb8dd78d6cfc5b2825857dea528e2a", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 87, "deletions": 22, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -26,6 +26,7 @@ mod implicit_clone;\n mod inefficient_to_string;\n mod inspect_for_each;\n mod into_iter_on_ref;\n+mod is_digit_ascii_radix;\n mod iter_cloned_collect;\n mod iter_count;\n mod iter_next_slice;\n@@ -42,6 +43,7 @@ mod map_flatten;\n mod map_identity;\n mod map_unwrap_or;\n mod needless_option_as_deref;\n+mod needless_option_take;\n mod ok_expect;\n mod option_as_ref_deref;\n mod option_map_or_none;\n@@ -294,15 +296,15 @@ declare_clippy_lint! {\n     /// Checks for methods with certain name prefixes and which\n     /// doesn't match how self is taken. The actual rules are:\n     ///\n-    /// |Prefix |Postfix     |`self` taken           | `self` type  |\n-    /// |-------|------------|-----------------------|--------------|\n-    /// |`as_`  | none       |`&self` or `&mut self` | any          |\n-    /// |`from_`| none       | none                  | any          |\n-    /// |`into_`| none       |`self`                 | any          |\n-    /// |`is_`  | none       |`&self` or none        | any          |\n-    /// |`to_`  | `_mut`     |`&mut self`            | any          |\n-    /// |`to_`  | not `_mut` |`self`                 | `Copy`       |\n-    /// |`to_`  | not `_mut` |`&self`                | not `Copy`   |\n+    /// |Prefix |Postfix     |`self` taken                   | `self` type  |\n+    /// |-------|------------|-------------------------------|--------------|\n+    /// |`as_`  | none       |`&self` or `&mut self`         | any          |\n+    /// |`from_`| none       | none                          | any          |\n+    /// |`into_`| none       |`self`                         | any          |\n+    /// |`is_`  | none       |`&mut self` or `&self` or none | any          |\n+    /// |`to_`  | `_mut`     |`&mut self`                    | any          |\n+    /// |`to_`  | not `_mut` |`self`                         | `Copy`       |\n+    /// |`to_`  | not `_mut` |`&self`                        | not `Copy`   |\n     ///\n     /// Note: Clippy doesn't trigger methods with `to_` prefix in:\n     /// - Traits definition.\n@@ -1265,7 +1267,7 @@ declare_clippy_lint! {\n     #[clippy::version = \"1.55.0\"]\n     pub EXTEND_WITH_DRAIN,\n     perf,\n-    \"using vec.append(&mut vec) to move the full range of a vecor to another\"\n+    \"using vec.append(&mut vec) to move the full range of a vector to another\"\n }\n \n declare_clippy_lint! {\n@@ -2007,13 +2009,27 @@ declare_clippy_lint! {\n     /// ### Example\n     /// ```rust,ignore\n     /// // Bad\n-    ///  let (key, value) = _.splitn(2, '=').next_tuple()?;\n-    ///  let value = _.splitn(2, '=').nth(1)?;\n+    /// let s = \"key=value=add\";\n+    /// let (key, value) = s.splitn(2, '=').next_tuple()?;\n+    /// let value = s.splitn(2, '=').nth(1)?;\n     ///\n+    /// let mut parts = s.splitn(2, '=');\n+    /// let key = parts.next()?;\n+    /// let value = parts.next()?;\n+    /// ```\n+    /// Use instead:\n+    /// ```rust,ignore\n     /// // Good\n-    /// let (key, value) = _.split_once('=')?;\n-    /// let value = _.split_once('=')?.1;\n+    /// let s = \"key=value=add\";\n+    /// let (key, value) = s.split_once('=')?;\n+    /// let value = s.split_once('=')?.1;\n+    ///\n+    /// let (key, value) = s.split_once('=')?;\n     /// ```\n+    ///\n+    /// ### Limitations\n+    /// The multiple statement variant currently only detects `iter.next()?`/`iter.next().unwrap()`\n+    /// in two separate `let` statements that immediately follow the `splitn()`\n     #[clippy::version = \"1.57.0\"]\n     pub MANUAL_SPLIT_ONCE,\n     complexity,\n@@ -2099,7 +2115,7 @@ declare_clippy_lint! {\n     /// using `.collect::<String>()` over `.collect::<Vec<String>>().join(\"\")`\n     /// will prevent loop unrolling and will result in a negative performance impact.\n     ///\n-    /// Additionlly, differences have been observed between aarch64 and x86_64 assembly output,\n+    /// Additionally, differences have been observed between aarch64 and x86_64 assembly output,\n     /// with aarch64 tending to producing faster assembly in more cases when using `.collect::<String>()`\n     #[clippy::version = \"1.61.0\"]\n     pub UNNECESSARY_JOIN,\n@@ -2131,6 +2147,56 @@ declare_clippy_lint! {\n     \"no-op use of `deref` or `deref_mut` method to `Option`.\"\n }\n \n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Finds usages of [`char::is_digit`]\n+    /// (https://doc.rust-lang.org/stable/std/primitive.char.html#method.is_digit) that\n+    /// can be replaced with [`is_ascii_digit`]\n+    /// (https://doc.rust-lang.org/stable/std/primitive.char.html#method.is_ascii_digit) or\n+    /// [`is_ascii_hexdigit`]\n+    /// (https://doc.rust-lang.org/stable/std/primitive.char.html#method.is_ascii_hexdigit).\n+    ///\n+    /// ### Why is this bad?\n+    /// `is_digit(..)` is slower and requires specifying the radix.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// let c: char = '6';\n+    /// c.is_digit(10);\n+    /// c.is_digit(16);\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// let c: char = '6';\n+    /// c.is_ascii_digit();\n+    /// c.is_ascii_hexdigit();\n+    /// ```\n+    #[clippy::version = \"1.61.0\"]\n+    pub IS_DIGIT_ASCII_RADIX,\n+    style,\n+    \"use of `char::is_digit(..)` with literal radix of 10 or 16\"\n+}\n+\n+declare_clippy_lint! {\n+    ///\n+    /// ### Why is this bad?\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// let x = Some(3);\n+    /// x.as_ref().take();\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// let x = Some(3);\n+    /// x.as_ref();\n+    /// ```\n+    #[clippy::version = \"1.61.0\"]\n+    pub NEEDLESS_OPTION_TAKE,\n+    complexity,\n+    \"using `.as_ref().take()` on a temporary value\"\n+}\n+\n pub struct Methods {\n     avoid_breaking_exported_api: bool,\n     msrv: Option<RustcVersion>,\n@@ -2219,6 +2285,8 @@ impl_lint_pass!(Methods => [\n     UNNECESSARY_JOIN,\n     ERR_EXPECT,\n     NEEDLESS_OPTION_AS_DEREF,\n+    IS_DIGIT_ASCII_RADIX,\n+    NEEDLESS_OPTION_TAKE,\n ]);\n \n /// Extracts a method call name, args, and `Span` of the method name.\n@@ -2254,7 +2322,7 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n                 single_char_add_str::check(cx, expr, args);\n                 into_iter_on_ref::check(cx, expr, method_span, method_call.ident.name, args);\n                 single_char_pattern::check(cx, expr, method_call.ident.name, args);\n-                unnecessary_to_owned::check(cx, expr, method_call.ident.name, args);\n+                unnecessary_to_owned::check(cx, expr, method_call.ident.name, args, self.msrv.as_ref());\n             },\n             hir::ExprKind::Binary(op, lhs, rhs) if op.node == hir::BinOpKind::Eq || op.node == hir::BinOpKind::Ne => {\n                 let mut info = BinaryExprInfo {\n@@ -2516,6 +2584,7 @@ fn check_methods<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, msrv: Optio\n             },\n             (\"get_or_insert_with\", [arg]) => unnecessary_lazy_eval::check(cx, expr, recv, arg, \"get_or_insert\"),\n             (\"is_file\", []) => filetype_is_file::check(cx, expr, recv),\n+            (\"is_digit\", [radix]) => is_digit_ascii_radix::check(cx, expr, recv, radix, msrv),\n             (\"is_none\", []) => check_is_some_is_none(cx, expr, recv, false),\n             (\"is_some\", []) => check_is_some_is_none(cx, expr, recv, true),\n             (\"join\", [join_arg]) => {\n@@ -2574,12 +2643,7 @@ fn check_methods<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, msrv: Optio\n             (\"splitn\" | \"rsplitn\", [count_arg, pat_arg]) => {\n                 if let Some((Constant::Int(count), _)) = constant(cx, cx.typeck_results(), count_arg) {\n                     suspicious_splitn::check(cx, name, expr, recv, count);\n-                    if count == 2 && meets_msrv(msrv, &msrvs::STR_SPLIT_ONCE) {\n-                        str_splitn::check_manual_split_once(cx, name, expr, recv, pat_arg);\n-                    }\n-                    if count >= 2 {\n-                        str_splitn::check_needless_splitn(cx, name, expr, recv, pat_arg, count);\n-                    }\n+                    str_splitn::check(cx, name, expr, recv, pat_arg, count, msrv);\n                 }\n             },\n             (\"splitn_mut\" | \"rsplitn_mut\", [count_arg, _]) => {\n@@ -2595,6 +2659,7 @@ fn check_methods<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, msrv: Optio\n                     }\n                 }\n             },\n+            (\"take\", []) => needless_option_take::check(cx, expr, recv),\n             (\"to_os_string\" | \"to_owned\" | \"to_path_buf\" | \"to_vec\", []) => {\n                 implicit_clone::check(cx, name, expr, recv);\n             },"}, {"sha": "829c118d2916386974ab7835e8be9fe72a2bf5c1", "filename": "clippy_lints/src/methods/needless_option_take.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Fmethods%2Fneedless_option_take.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Fmethods%2Fneedless_option_take.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fneedless_option_take.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -0,0 +1,41 @@\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::match_def_path;\n+use clippy_utils::source::snippet_with_applicability;\n+use clippy_utils::ty::is_type_diagnostic_item;\n+use rustc_errors::Applicability;\n+use rustc_hir::Expr;\n+use rustc_lint::LateContext;\n+use rustc_span::sym;\n+\n+use super::NEEDLESS_OPTION_TAKE;\n+\n+pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, recv: &'tcx Expr<'_>) {\n+    // Checks if expression type is equal to sym::Option and if the expr is not a syntactic place\n+    if !recv.is_syntactic_place_expr() && is_expr_option(cx, recv) && has_expr_as_ref_path(cx, recv) {\n+        let mut applicability = Applicability::MachineApplicable;\n+        span_lint_and_sugg(\n+            cx,\n+            NEEDLESS_OPTION_TAKE,\n+            expr.span,\n+            \"called `Option::take()` on a temporary value\",\n+            \"try\",\n+            format!(\n+                \"{}\",\n+                snippet_with_applicability(cx, recv.span, \"..\", &mut applicability)\n+            ),\n+            applicability,\n+        );\n+    }\n+}\n+\n+fn is_expr_option(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n+    let expr_type = cx.typeck_results().expr_ty(expr);\n+    is_type_diagnostic_item(cx, expr_type, sym::Option)\n+}\n+\n+fn has_expr_as_ref_path(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n+    if let Some(ref_id) = cx.typeck_results().type_dependent_def_id(expr.hir_id) {\n+        return match_def_path(cx, ref_id, &[\"core\", \"option\", \"Option\", \"as_ref\"]);\n+    }\n+    false\n+}"}, {"sha": "52891eeed0696db2031bcb2fcb67943972c31036", "filename": "clippy_lints/src/methods/str_splitn.rs", "status": "modified", "additions": 240, "deletions": 173, "changes": 413, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Fmethods%2Fstr_splitn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Fmethods%2Fstr_splitn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fstr_splitn.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -1,36 +1,83 @@\n use clippy_utils::consts::{constant, Constant};\n-use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::diagnostics::{span_lint_and_sugg, span_lint_and_then};\n use clippy_utils::source::snippet_with_context;\n-use clippy_utils::{is_diag_item_method, match_def_path, paths};\n+use clippy_utils::usage::local_used_after_expr;\n+use clippy_utils::visitors::expr_visitor;\n+use clippy_utils::{is_diag_item_method, match_def_path, meets_msrv, msrvs, path_to_local_id, paths};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n-use rustc_hir::{Expr, ExprKind, HirId, LangItem, Node, QPath};\n+use rustc_hir::intravisit::Visitor;\n+use rustc_hir::{\n+    BindingAnnotation, Expr, ExprKind, HirId, LangItem, Local, MatchSource, Node, Pat, PatKind, QPath, Stmt, StmtKind,\n+};\n use rustc_lint::LateContext;\n-use rustc_middle::ty::{self, adjustment::Adjust};\n-use rustc_span::{symbol::sym, Span, SyntaxContext};\n+use rustc_middle::ty;\n+use rustc_semver::RustcVersion;\n+use rustc_span::{sym, Span, Symbol, SyntaxContext};\n \n-use super::MANUAL_SPLIT_ONCE;\n+use super::{MANUAL_SPLIT_ONCE, NEEDLESS_SPLITN};\n \n-pub(super) fn check_manual_split_once(\n+pub(super) fn check(\n     cx: &LateContext<'_>,\n     method_name: &str,\n     expr: &Expr<'_>,\n     self_arg: &Expr<'_>,\n     pat_arg: &Expr<'_>,\n+    count: u128,\n+    msrv: Option<&RustcVersion>,\n ) {\n-    if !cx.typeck_results().expr_ty_adjusted(self_arg).peel_refs().is_str() {\n+    if count < 2 || !cx.typeck_results().expr_ty_adjusted(self_arg).peel_refs().is_str() {\n         return;\n     }\n \n+    let needless = |usage_kind| match usage_kind {\n+        IterUsageKind::Nth(n) => count > n + 1,\n+        IterUsageKind::NextTuple => count > 2,\n+    };\n+    let manual = count == 2 && meets_msrv(msrv, &msrvs::STR_SPLIT_ONCE);\n+\n+    match parse_iter_usage(cx, expr.span.ctxt(), cx.tcx.hir().parent_iter(expr.hir_id)) {\n+        Some(usage) if needless(usage.kind) => lint_needless(cx, method_name, expr, self_arg, pat_arg),\n+        Some(usage) if manual => check_manual_split_once(cx, method_name, expr, self_arg, pat_arg, &usage),\n+        None if manual => {\n+            check_manual_split_once_indirect(cx, method_name, expr, self_arg, pat_arg);\n+        },\n+        _ => {},\n+    }\n+}\n+\n+fn lint_needless(cx: &LateContext<'_>, method_name: &str, expr: &Expr<'_>, self_arg: &Expr<'_>, pat_arg: &Expr<'_>) {\n+    let mut app = Applicability::MachineApplicable;\n+    let r = if method_name == \"splitn\" { \"\" } else { \"r\" };\n+\n+    span_lint_and_sugg(\n+        cx,\n+        NEEDLESS_SPLITN,\n+        expr.span,\n+        &format!(\"unnecessary use of `{r}splitn`\"),\n+        \"try this\",\n+        format!(\n+            \"{}.{r}split({})\",\n+            snippet_with_context(cx, self_arg.span, expr.span.ctxt(), \"..\", &mut app).0,\n+            snippet_with_context(cx, pat_arg.span, expr.span.ctxt(), \"..\", &mut app).0,\n+        ),\n+        app,\n+    );\n+}\n+\n+fn check_manual_split_once(\n+    cx: &LateContext<'_>,\n+    method_name: &str,\n+    expr: &Expr<'_>,\n+    self_arg: &Expr<'_>,\n+    pat_arg: &Expr<'_>,\n+    usage: &IterUsage,\n+) {\n     let ctxt = expr.span.ctxt();\n-    let (method_name, msg, reverse) = if method_name == \"splitn\" {\n-        (\"split_once\", \"manual implementation of `split_once`\", false)\n+    let (msg, reverse) = if method_name == \"splitn\" {\n+        (\"manual implementation of `split_once`\", false)\n     } else {\n-        (\"rsplit_once\", \"manual implementation of `rsplit_once`\", true)\n-    };\n-    let usage = match parse_iter_usage(cx, ctxt, cx.tcx.hir().parent_iter(expr.hir_id), reverse) {\n-        Some(x) => x,\n-        None => return,\n+        (\"manual implementation of `rsplit_once`\", true)\n     };\n \n     let mut app = Applicability::MachineApplicable;\n@@ -39,84 +86,198 @@ pub(super) fn check_manual_split_once(\n \n     let sugg = match usage.kind {\n         IterUsageKind::NextTuple => {\n-            format!(\"{}.{}({})\", self_snip, method_name, pat_snip)\n-        },\n-        IterUsageKind::RNextTuple => format!(\"{}.{}({}).map(|(x, y)| (y, x))\", self_snip, method_name, pat_snip),\n-        IterUsageKind::Next | IterUsageKind::Second => {\n-            let self_deref = {\n-                let adjust = cx.typeck_results().expr_adjustments(self_arg);\n-                if adjust.len() < 2 {\n-                    String::new()\n-                } else if cx.typeck_results().expr_ty(self_arg).is_box()\n-                    || adjust\n-                        .iter()\n-                        .any(|a| matches!(a.kind, Adjust::Deref(Some(_))) || a.target.is_box())\n-                {\n-                    format!(\"&{}\", \"*\".repeat(adjust.len().saturating_sub(1)))\n-                } else {\n-                    \"*\".repeat(adjust.len().saturating_sub(2))\n-                }\n-            };\n-            if matches!(usage.kind, IterUsageKind::Next) {\n-                match usage.unwrap_kind {\n-                    Some(UnwrapKind::Unwrap) => {\n-                        if reverse {\n-                            format!(\"{}.{}({}).unwrap().0\", self_snip, method_name, pat_snip)\n-                        } else {\n-                            format!(\n-                                \"{}.{}({}).map_or({}{}, |x| x.0)\",\n-                                self_snip, method_name, pat_snip, self_deref, &self_snip\n-                            )\n-                        }\n-                    },\n-                    Some(UnwrapKind::QuestionMark) => {\n-                        format!(\n-                            \"{}.{}({}).map_or({}{}, |x| x.0)\",\n-                            self_snip, method_name, pat_snip, self_deref, &self_snip\n-                        )\n-                    },\n-                    None => {\n-                        format!(\n-                            \"Some({}.{}({}).map_or({}{}, |x| x.0))\",\n-                            &self_snip, method_name, pat_snip, self_deref, &self_snip\n-                        )\n-                    },\n-                }\n+            if reverse {\n+                format!(\"{self_snip}.rsplit_once({pat_snip}).map(|(x, y)| (y, x))\")\n             } else {\n-                match usage.unwrap_kind {\n-                    Some(UnwrapKind::Unwrap) => {\n-                        if reverse {\n-                            // In this case, no better suggestion is offered.\n-                            return;\n-                        }\n-                        format!(\"{}.{}({}).unwrap().1\", self_snip, method_name, pat_snip)\n-                    },\n-                    Some(UnwrapKind::QuestionMark) => {\n-                        format!(\"{}.{}({})?.1\", self_snip, method_name, pat_snip)\n-                    },\n-                    None => {\n-                        format!(\"{}.{}({}).map(|x| x.1)\", self_snip, method_name, pat_snip)\n-                    },\n-                }\n+                format!(\"{self_snip}.split_once({pat_snip})\")\n+            }\n+        },\n+        IterUsageKind::Nth(1) => {\n+            let (r, field) = if reverse { (\"r\", 0) } else { (\"\", 1) };\n+\n+            match usage.unwrap_kind {\n+                Some(UnwrapKind::Unwrap) => {\n+                    format!(\"{self_snip}.{r}split_once({pat_snip}).unwrap().{field}\")\n+                },\n+                Some(UnwrapKind::QuestionMark) => {\n+                    format!(\"{self_snip}.{r}split_once({pat_snip})?.{field}\")\n+                },\n+                None => {\n+                    format!(\"{self_snip}.{r}split_once({pat_snip}).map(|x| x.{field})\")\n+                },\n             }\n         },\n+        IterUsageKind::Nth(_) => return,\n     };\n \n     span_lint_and_sugg(cx, MANUAL_SPLIT_ONCE, usage.span, msg, \"try this\", sugg, app);\n }\n \n+/// checks for\n+///\n+/// ```\n+/// let mut iter = \"a.b.c\".splitn(2, '.');\n+/// let a = iter.next();\n+/// let b = iter.next();\n+/// ```\n+fn check_manual_split_once_indirect(\n+    cx: &LateContext<'_>,\n+    method_name: &str,\n+    expr: &Expr<'_>,\n+    self_arg: &Expr<'_>,\n+    pat_arg: &Expr<'_>,\n+) -> Option<()> {\n+    let ctxt = expr.span.ctxt();\n+    let mut parents = cx.tcx.hir().parent_iter(expr.hir_id);\n+    if let (_, Node::Local(local)) = parents.next()?\n+        && let PatKind::Binding(BindingAnnotation::Mutable, iter_binding_id, iter_ident, None) = local.pat.kind\n+        && let (iter_stmt_id, Node::Stmt(_)) = parents.next()?\n+        && let (_, Node::Block(enclosing_block)) = parents.next()?\n+\n+        && let mut stmts = enclosing_block\n+            .stmts\n+            .iter()\n+            .skip_while(|stmt| stmt.hir_id != iter_stmt_id)\n+            .skip(1)\n+\n+        && let first = indirect_usage(cx, stmts.next()?, iter_binding_id, ctxt)?\n+        && let second = indirect_usage(cx, stmts.next()?, iter_binding_id, ctxt)?\n+        && first.unwrap_kind == second.unwrap_kind\n+        && first.name != second.name\n+        && !local_used_after_expr(cx, iter_binding_id, second.init_expr)\n+    {\n+        let (r, lhs, rhs) = if method_name == \"splitn\" {\n+            (\"\", first.name, second.name)\n+        } else {\n+            (\"r\", second.name, first.name)\n+        };\n+        let msg = format!(\"manual implementation of `{r}split_once`\");\n+\n+        let mut app = Applicability::MachineApplicable;\n+        let self_snip = snippet_with_context(cx, self_arg.span, ctxt, \"..\", &mut app).0;\n+        let pat_snip = snippet_with_context(cx, pat_arg.span, ctxt, \"..\", &mut app).0;\n+\n+        span_lint_and_then(cx, MANUAL_SPLIT_ONCE, local.span, &msg, |diag| {\n+            diag.span_label(first.span, \"first usage here\");\n+            diag.span_label(second.span, \"second usage here\");\n+\n+            let unwrap = match first.unwrap_kind {\n+                UnwrapKind::Unwrap => \".unwrap()\",\n+                UnwrapKind::QuestionMark => \"?\",\n+            };\n+            diag.span_suggestion_verbose(\n+                local.span,\n+                &format!(\"try `{r}split_once`\"),\n+                format!(\"let ({lhs}, {rhs}) = {self_snip}.{r}split_once({pat_snip}){unwrap};\"),\n+                app,\n+            );\n+\n+            let remove_msg = format!(\"remove the `{iter_ident}` usages\");\n+            diag.span_suggestion(\n+                first.span,\n+                &remove_msg,\n+                String::new(),\n+                app,\n+            );\n+            diag.span_suggestion(\n+                second.span,\n+                &remove_msg,\n+                String::new(),\n+                app,\n+            );\n+        });\n+    }\n+\n+    Some(())\n+}\n+\n+#[derive(Debug)]\n+struct IndirectUsage<'a> {\n+    name: Symbol,\n+    span: Span,\n+    init_expr: &'a Expr<'a>,\n+    unwrap_kind: UnwrapKind,\n+}\n+\n+/// returns `Some(IndirectUsage)` for e.g.\n+///\n+/// ```ignore\n+/// let name = binding.next()?;\n+/// let name = binding.next().unwrap();\n+/// ```\n+fn indirect_usage<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    stmt: &Stmt<'tcx>,\n+    binding: HirId,\n+    ctxt: SyntaxContext,\n+) -> Option<IndirectUsage<'tcx>> {\n+    if let StmtKind::Local(Local {\n+        pat:\n+            Pat {\n+                kind: PatKind::Binding(BindingAnnotation::Unannotated, _, ident, None),\n+                ..\n+            },\n+        init: Some(init_expr),\n+        hir_id: local_hir_id,\n+        ..\n+    }) = stmt.kind\n+    {\n+        let mut path_to_binding = None;\n+        expr_visitor(cx, |expr| {\n+            if path_to_local_id(expr, binding) {\n+                path_to_binding = Some(expr);\n+            }\n+\n+            path_to_binding.is_none()\n+        })\n+        .visit_expr(init_expr);\n+\n+        let mut parents = cx.tcx.hir().parent_iter(path_to_binding?.hir_id);\n+        let iter_usage = parse_iter_usage(cx, ctxt, &mut parents)?;\n+\n+        let (parent_id, _) = parents.find(|(_, node)| {\n+            !matches!(\n+                node,\n+                Node::Expr(Expr {\n+                    kind: ExprKind::Match(.., MatchSource::TryDesugar),\n+                    ..\n+                })\n+            )\n+        })?;\n+\n+        if let IterUsage {\n+            kind: IterUsageKind::Nth(0),\n+            unwrap_kind: Some(unwrap_kind),\n+            ..\n+        } = iter_usage\n+        {\n+            if parent_id == *local_hir_id {\n+                return Some(IndirectUsage {\n+                    name: ident.name,\n+                    span: stmt.span,\n+                    init_expr,\n+                    unwrap_kind,\n+                });\n+            }\n+        }\n+    }\n+\n+    None\n+}\n+\n+#[derive(Debug, Clone, Copy)]\n enum IterUsageKind {\n-    Next,\n-    Second,\n+    Nth(u128),\n     NextTuple,\n-    RNextTuple,\n }\n \n+#[derive(Debug, PartialEq)]\n enum UnwrapKind {\n     Unwrap,\n     QuestionMark,\n }\n \n+#[derive(Debug)]\n struct IterUsage {\n     kind: IterUsageKind,\n     unwrap_kind: Option<UnwrapKind>,\n@@ -128,7 +289,6 @@ fn parse_iter_usage<'tcx>(\n     cx: &LateContext<'tcx>,\n     ctxt: SyntaxContext,\n     mut iter: impl Iterator<Item = (HirId, Node<'tcx>)>,\n-    reverse: bool,\n ) -> Option<IterUsage> {\n     let (kind, span) = match iter.next() {\n         Some((_, Node::Expr(e))) if e.span.ctxt() == ctxt => {\n@@ -141,13 +301,7 @@ fn parse_iter_usage<'tcx>(\n             let iter_id = cx.tcx.get_diagnostic_item(sym::Iterator)?;\n \n             match (name.ident.as_str(), args) {\n-                (\"next\", []) if cx.tcx.trait_of_item(did) == Some(iter_id) => {\n-                    if reverse {\n-                        (IterUsageKind::Second, e.span)\n-                    } else {\n-                        (IterUsageKind::Next, e.span)\n-                    }\n-                },\n+                (\"next\", []) if cx.tcx.trait_of_item(did) == Some(iter_id) => (IterUsageKind::Nth(0), e.span),\n                 (\"next_tuple\", []) => {\n                     return if_chain! {\n                         if match_def_path(cx, did, &paths::ITERTOOLS_NEXT_TUPLE);\n@@ -157,7 +311,7 @@ fn parse_iter_usage<'tcx>(\n                         if subs.len() == 2;\n                         then {\n                             Some(IterUsage {\n-                                kind: if reverse { IterUsageKind::RNextTuple } else { IterUsageKind::NextTuple },\n+                                kind: IterUsageKind::NextTuple,\n                                 span: e.span,\n                                 unwrap_kind: None\n                             })\n@@ -185,11 +339,7 @@ fn parse_iter_usage<'tcx>(\n                                 }\n                             }\n                         };\n-                        match if reverse { idx ^ 1 } else { idx } {\n-                            0 => (IterUsageKind::Next, span),\n-                            1 => (IterUsageKind::Second, span),\n-                            _ => return None,\n-                        }\n+                        (IterUsageKind::Nth(idx), span)\n                     } else {\n                         return None;\n                     }\n@@ -238,86 +388,3 @@ fn parse_iter_usage<'tcx>(\n         span,\n     })\n }\n-\n-use super::NEEDLESS_SPLITN;\n-\n-pub(super) fn check_needless_splitn(\n-    cx: &LateContext<'_>,\n-    method_name: &str,\n-    expr: &Expr<'_>,\n-    self_arg: &Expr<'_>,\n-    pat_arg: &Expr<'_>,\n-    count: u128,\n-) {\n-    if !cx.typeck_results().expr_ty_adjusted(self_arg).peel_refs().is_str() {\n-        return;\n-    }\n-    let ctxt = expr.span.ctxt();\n-    let mut app = Applicability::MachineApplicable;\n-    let (reverse, message) = if method_name == \"splitn\" {\n-        (false, \"unnecessary use of `splitn`\")\n-    } else {\n-        (true, \"unnecessary use of `rsplitn`\")\n-    };\n-    if_chain! {\n-        if count >= 2;\n-        if check_iter(cx, ctxt, cx.tcx.hir().parent_iter(expr.hir_id), count);\n-        then {\n-            span_lint_and_sugg(\n-                cx,\n-                NEEDLESS_SPLITN,\n-                expr.span,\n-                message,\n-                \"try this\",\n-                format!(\n-                    \"{}.{}({})\",\n-                    snippet_with_context(cx, self_arg.span, ctxt, \"..\", &mut app).0,\n-                    if reverse {\"rsplit\"} else {\"split\"},\n-                    snippet_with_context(cx, pat_arg.span, ctxt, \"..\", &mut app).0\n-                ),\n-                app,\n-            );\n-        }\n-    }\n-}\n-\n-fn check_iter<'tcx>(\n-    cx: &LateContext<'tcx>,\n-    ctxt: SyntaxContext,\n-    mut iter: impl Iterator<Item = (HirId, Node<'tcx>)>,\n-    count: u128,\n-) -> bool {\n-    match iter.next() {\n-        Some((_, Node::Expr(e))) if e.span.ctxt() == ctxt => {\n-            let (name, args) = if let ExprKind::MethodCall(name, [_, args @ ..], _) = e.kind {\n-                (name, args)\n-            } else {\n-                return false;\n-            };\n-            if_chain! {\n-                if let Some(did) = cx.typeck_results().type_dependent_def_id(e.hir_id);\n-                if let Some(iter_id) = cx.tcx.get_diagnostic_item(sym::Iterator);\n-                then {\n-                    match (name.ident.as_str(), args) {\n-                        (\"next\", []) if cx.tcx.trait_of_item(did) == Some(iter_id) => {\n-                            return true;\n-                        },\n-                        (\"next_tuple\", []) if count > 2 => {\n-                            return true;\n-                        },\n-                        (\"nth\", [idx_expr]) if cx.tcx.trait_of_item(did) == Some(iter_id) => {\n-                            if let Some((Constant::Int(idx), _)) = constant(cx, cx.typeck_results(), idx_expr) {\n-                                if count > idx + 1 {\n-                                    return true;\n-                                }\n-                            }\n-                        },\n-                        _ =>  return false,\n-                    }\n-                }\n-            }\n-        },\n-        _ => return false,\n-    };\n-    false\n-}"}, {"sha": "02b882e8b55e041bc14f7afc810a6451b6f24927", "filename": "clippy_lints/src/methods/unnecessary_to_owned.rs", "status": "modified", "additions": 19, "deletions": 4, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_to_owned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_to_owned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_to_owned.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -5,6 +5,8 @@ use clippy_utils::source::snippet_opt;\n use clippy_utils::ty::{\n     contains_ty, get_associated_type, get_iterator_item_ty, implements_trait, is_copy, peel_mid_ty_refs,\n };\n+use clippy_utils::{meets_msrv, msrvs};\n+\n use clippy_utils::{fn_def_id, get_parent_expr, is_diag_item_method, is_diag_trait_item};\n use rustc_errors::Applicability;\n use rustc_hir::{def_id::DefId, BorrowKind, Expr, ExprKind};\n@@ -13,12 +15,19 @@ use rustc_middle::mir::Mutability;\n use rustc_middle::ty::adjustment::{Adjust, Adjustment, OverloadedDeref};\n use rustc_middle::ty::subst::{GenericArg, GenericArgKind, SubstsRef};\n use rustc_middle::ty::{self, PredicateKind, ProjectionPredicate, TraitPredicate, Ty};\n+use rustc_semver::RustcVersion;\n use rustc_span::{sym, Symbol};\n use std::cmp::max;\n \n use super::UNNECESSARY_TO_OWNED;\n \n-pub fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>, method_name: Symbol, args: &'tcx [Expr<'tcx>]) {\n+pub fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx Expr<'tcx>,\n+    method_name: Symbol,\n+    args: &'tcx [Expr<'tcx>],\n+    msrv: Option<&RustcVersion>,\n+) {\n     if_chain! {\n         if let Some(method_def_id) = cx.typeck_results().type_dependent_def_id(expr.hir_id);\n         if let [receiver] = args;\n@@ -33,7 +42,7 @@ pub fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>, method_name:\n                 if check_addr_of_expr(cx, expr, method_name, method_def_id, receiver) {\n                     return;\n                 }\n-                if check_into_iter_call_arg(cx, expr, method_name, receiver) {\n+                if check_into_iter_call_arg(cx, expr, method_name, receiver, msrv) {\n                     return;\n                 }\n                 check_other_call_arg(cx, expr, method_name, receiver);\n@@ -178,7 +187,13 @@ fn check_addr_of_expr(\n \n /// Checks whether `expr` is an argument in an `into_iter` call and, if so, determines whether its\n /// call of a `to_owned`-like function is unnecessary.\n-fn check_into_iter_call_arg(cx: &LateContext<'_>, expr: &Expr<'_>, method_name: Symbol, receiver: &Expr<'_>) -> bool {\n+fn check_into_iter_call_arg(\n+    cx: &LateContext<'_>,\n+    expr: &Expr<'_>,\n+    method_name: Symbol,\n+    receiver: &Expr<'_>,\n+    msrv: Option<&RustcVersion>,\n+) -> bool {\n     if_chain! {\n         if let Some(parent) = get_parent_expr(cx, expr);\n         if let Some(callee_def_id) = fn_def_id(cx, parent);\n@@ -192,7 +207,7 @@ fn check_into_iter_call_arg(cx: &LateContext<'_>, expr: &Expr<'_>, method_name:\n             if unnecessary_iter_cloned::check_for_loop_iter(cx, parent, method_name, receiver, true) {\n                 return true;\n             }\n-            let cloned_or_copied = if is_copy(cx, item_ty) { \"copied\" } else { \"cloned\" };\n+            let cloned_or_copied = if is_copy(cx, item_ty) && meets_msrv(msrv, &msrvs::ITERATOR_COPIED) { \"copied\" } else { \"cloned\" };\n             // The next suggestion may be incorrect because the removal of the `to_owned`-like\n             // function could cause the iterator to hold a reference to a resource that is used\n             // mutably. See https://github.com/rust-lang/rust-clippy/issues/8148."}, {"sha": "4b368d3ffae254abd04ba4727b7b30faed484ef3", "filename": "clippy_lints/src/methods/wrong_self_convention.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Fmethods%2Fwrong_self_convention.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Fmethods%2Fwrong_self_convention.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fwrong_self_convention.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -14,7 +14,7 @@ const CONVENTIONS: [(&[Convention], &[SelfKind]); 9] = [\n     (&[Convention::StartsWith(\"as_\")], &[SelfKind::Ref, SelfKind::RefMut]),\n     (&[Convention::StartsWith(\"from_\")], &[SelfKind::No]),\n     (&[Convention::StartsWith(\"into_\")], &[SelfKind::Value]),\n-    (&[Convention::StartsWith(\"is_\")], &[SelfKind::Ref, SelfKind::No]),\n+    (&[Convention::StartsWith(\"is_\")], &[SelfKind::RefMut, SelfKind::Ref, SelfKind::No]),\n     (&[Convention::Eq(\"to_mut\")], &[SelfKind::RefMut]),\n     (&[Convention::StartsWith(\"to_\"), Convention::EndsWith(\"_mut\")], &[SelfKind::RefMut]),\n "}, {"sha": "6860b60acbdb4612e144604db5ddd53b146e5b46", "filename": "clippy_lints/src/misc_early/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Fmisc_early%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Fmisc_early%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc_early%2Fmod.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -361,7 +361,7 @@ impl MiscEarlyLints {\n         // See <https://github.com/rust-lang/rust-clippy/issues/4507> for a regression.\n         // FIXME: Find a better way to detect those cases.\n         let lit_snip = match snippet_opt(cx, lit.span) {\n-            Some(snip) if snip.chars().next().map_or(false, |c| c.is_digit(10)) => snip,\n+            Some(snip) if snip.chars().next().map_or(false, |c| c.is_ascii_digit()) => snip,\n             _ => return,\n         };\n "}, {"sha": "0d95329918984c68a74d541042995ff1a94ec28b", "filename": "clippy_lints/src/missing_inline.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Fmissing_inline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Fmissing_inline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmissing_inline.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -44,7 +44,7 @@ declare_clippy_lint! {\n     /// pub struct PubBaz;\n     /// impl PubBaz {\n     ///    fn private() {} // ok\n-    ///    pub fn not_ptrivate() {} // missing #[inline]\n+    ///    pub fn not_private() {} // missing #[inline]\n     /// }\n     ///\n     /// impl Bar for PubBaz {\n@@ -97,7 +97,7 @@ impl<'tcx> LateLintPass<'tcx> for MissingInline {\n                 let attrs = cx.tcx.hir().attrs(it.hir_id());\n                 check_missing_inline_attrs(cx, attrs, it.span, desc);\n             },\n-            hir::ItemKind::Trait(ref _is_auto, ref _unsafe, ref _generics, _bounds, trait_items) => {\n+            hir::ItemKind::Trait(ref _is_auto, ref _unsafe, _generics, _bounds, trait_items) => {\n                 // note: we need to check if the trait is exported so we can't use\n                 // `LateLintPass::check_trait_item` here.\n                 for tit in trait_items {"}, {"sha": "95395e2e136d9f18024a356d0ea7f3dc1f4f6bd9", "filename": "clippy_lints/src/needless_bitwise_bool.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Fneedless_bitwise_bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Fneedless_bitwise_bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_bitwise_bool.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -53,7 +53,7 @@ fn is_bitwise_operation(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n     false\n }\n \n-fn suggession_snippet(cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<String> {\n+fn suggesstion_snippet(cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<String> {\n     if let ExprKind::Binary(ref op, left, right) = expr.kind {\n         if let (Some(l_snippet), Some(r_snippet)) = (snippet_opt(cx, left.span), snippet_opt(cx, right.span)) {\n             let op_snippet = match op.node {\n@@ -75,7 +75,7 @@ impl LateLintPass<'_> for NeedlessBitwiseBool {\n                 expr.span,\n                 \"use of bitwise operator instead of lazy operator between booleans\",\n                 |diag| {\n-                    if let Some(sugg) = suggession_snippet(cx, expr) {\n+                    if let Some(sugg) = suggesstion_snippet(cx, expr) {\n                         diag.span_suggestion(expr.span, \"try\", sugg, Applicability::MachineApplicable);\n                     }\n                 },"}, {"sha": "b70871b38beab178f63735330657ab8388e2f355", "filename": "clippy_lints/src/needless_late_init.rs", "status": "modified", "additions": 44, "deletions": 10, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Fneedless_late_init.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Fneedless_late_init.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_late_init.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -1,10 +1,14 @@\n use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::path_to_local;\n use clippy_utils::source::snippet_opt;\n-use clippy_utils::visitors::{expr_visitor, is_local_used};\n-use rustc_errors::Applicability;\n+use clippy_utils::ty::needs_ordered_drop;\n+use clippy_utils::visitors::{expr_visitor, expr_visitor_no_bodies, is_local_used};\n+use rustc_errors::{Applicability, MultiSpan};\n use rustc_hir::intravisit::Visitor;\n-use rustc_hir::{Block, Expr, ExprKind, HirId, Local, LocalSource, MatchSource, Node, Pat, PatKind, Stmt, StmtKind};\n+use rustc_hir::{\n+    BindingAnnotation, Block, Expr, ExprKind, HirId, Local, LocalSource, MatchSource, Node, Pat, PatKind, Stmt,\n+    StmtKind,\n+};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::Span;\n@@ -73,6 +77,31 @@ fn contains_assign_expr<'tcx>(cx: &LateContext<'tcx>, stmt: &'tcx Stmt<'tcx>) ->\n     seen\n }\n \n+fn contains_let(cond: &Expr<'_>) -> bool {\n+    let mut seen = false;\n+    expr_visitor_no_bodies(|expr| {\n+        if let ExprKind::Let(_) = expr.kind {\n+            seen = true;\n+        }\n+\n+        !seen\n+    })\n+    .visit_expr(cond);\n+\n+    seen\n+}\n+\n+fn stmt_needs_ordered_drop(cx: &LateContext<'_>, stmt: &Stmt<'_>) -> bool {\n+    let StmtKind::Local(local) = stmt.kind else { return false };\n+    !local.pat.walk_short(|pat| {\n+        if let PatKind::Binding(.., None) = pat.kind {\n+            !needs_ordered_drop(cx, cx.typeck_results().pat_ty(pat))\n+        } else {\n+            true\n+        }\n+    })\n+}\n+\n #[derive(Debug)]\n struct LocalAssign {\n     lhs_id: HirId,\n@@ -187,11 +216,14 @@ fn first_usage<'tcx>(\n     local_stmt_id: HirId,\n     block: &'tcx Block<'tcx>,\n ) -> Option<Usage<'tcx>> {\n+    let significant_drop = needs_ordered_drop(cx, cx.typeck_results().node_type(binding_id));\n+\n     block\n         .stmts\n         .iter()\n         .skip_while(|stmt| stmt.hir_id != local_stmt_id)\n         .skip(1)\n+        .take_while(|stmt| !significant_drop || !stmt_needs_ordered_drop(cx, stmt))\n         .find(|&stmt| is_local_used(cx, stmt, binding_id))\n         .and_then(|stmt| match stmt.kind {\n             StmtKind::Expr(expr) => Some(Usage {\n@@ -235,12 +267,15 @@ fn check<'tcx>(\n     match usage.expr.kind {\n         ExprKind::Assign(..) => {\n             let assign = LocalAssign::new(cx, usage.expr, binding_id)?;\n+            let mut msg_span = MultiSpan::from_spans(vec![local_stmt.span, assign.span]);\n+            msg_span.push_span_label(local_stmt.span, \"created here\");\n+            msg_span.push_span_label(assign.span, \"initialised here\");\n \n             span_lint_and_then(\n                 cx,\n                 NEEDLESS_LATE_INIT,\n-                local_stmt.span,\n-                \"unneeded late initalization\",\n+                msg_span,\n+                \"unneeded late initialization\",\n                 |diag| {\n                     diag.tool_only_span_suggestion(\n                         local_stmt.span,\n@@ -258,14 +293,14 @@ fn check<'tcx>(\n                 },\n             );\n         },\n-        ExprKind::If(_, then_expr, Some(else_expr)) => {\n+        ExprKind::If(cond, then_expr, Some(else_expr)) if !contains_let(cond) => {\n             let (applicability, suggestions) = assignment_suggestions(cx, binding_id, [then_expr, else_expr])?;\n \n             span_lint_and_then(\n                 cx,\n                 NEEDLESS_LATE_INIT,\n                 local_stmt.span,\n-                \"unneeded late initalization\",\n+                \"unneeded late initialization\",\n                 |diag| {\n                     diag.tool_only_span_suggestion(local_stmt.span, \"remove the local\", String::new(), applicability);\n \n@@ -296,7 +331,7 @@ fn check<'tcx>(\n                 cx,\n                 NEEDLESS_LATE_INIT,\n                 local_stmt.span,\n-                \"unneeded late initalization\",\n+                \"unneeded late initialization\",\n                 |diag| {\n                     diag.tool_only_span_suggestion(local_stmt.span, \"remove the local\", String::new(), applicability);\n \n@@ -333,12 +368,11 @@ fn check<'tcx>(\n impl<'tcx> LateLintPass<'tcx> for NeedlessLateInit {\n     fn check_local(&mut self, cx: &LateContext<'tcx>, local: &'tcx Local<'tcx>) {\n         let mut parents = cx.tcx.hir().parent_iter(local.hir_id);\n-\n         if_chain! {\n             if let Local {\n                 init: None,\n                 pat: &Pat {\n-                    kind: PatKind::Binding(_, binding_id, _, None),\n+                    kind: PatKind::Binding(BindingAnnotation::Unannotated, binding_id, _, None),\n                     ..\n                 },\n                 source: LocalSource::Normal,"}, {"sha": "2f733f221d572250866fd51150826a871b83a504", "filename": "clippy_lints/src/new_without_default.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Fnew_without_default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Fnew_without_default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnew_without_default.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -62,7 +62,7 @@ impl<'tcx> LateLintPass<'tcx> for NewWithoutDefault {\n     fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::Item<'_>) {\n         if let hir::ItemKind::Impl(hir::Impl {\n             of_trait: None,\n-            ref generics,\n+            generics,\n             self_ty: impl_self_ty,\n             items,\n             .."}, {"sha": "e3bc40c4b49148962fe3cf94d316c42de3e7220f", "filename": "clippy_lints/src/non_expressive_names.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Fnon_expressive_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Fnon_expressive_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnon_expressive_names.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -197,7 +197,7 @@ impl<'a, 'tcx, 'b> SimilarNamesNameVisitor<'a, 'tcx, 'b> {\n         if interned_name.chars().any(char::is_uppercase) {\n             return;\n         }\n-        if interned_name.chars().all(|c| c.is_digit(10) || c == '_') {\n+        if interned_name.chars().all(|c| c.is_ascii_digit() || c == '_') {\n             span_lint(\n                 self.0.cx,\n                 JUST_UNDERSCORES_AND_DIGITS,"}, {"sha": "e8532db4f711dbc658d9862f8ff6b4851253b5c8", "filename": "clippy_lints/src/octal_escapes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Foctal_escapes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Foctal_escapes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foctal_escapes.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -25,7 +25,7 @@ declare_clippy_lint! {\n     ///\n     /// ### Known problems\n     /// The actual meaning can be the intended one. `\\x00` can be used in these\n-    /// cases to be unambigious.\n+    /// cases to be unambiguous.\n     ///\n     /// The lint does not trigger for format strings in `print!()`, `write!()`\n     /// and friends since the string is already preprocessed when Clippy lints"}, {"sha": "beb812793f81ccfe5d40a44ef3c6840051d3bc6a", "filename": "clippy_lints/src/only_used_in_recursion.rs", "status": "modified", "additions": 24, "deletions": 32, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Fonly_used_in_recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Fonly_used_in_recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fonly_used_in_recursion.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -1,14 +1,15 @@\n use std::collections::VecDeque;\n \n use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::is_lint_allowed;\n use itertools::{izip, Itertools};\n use rustc_ast::{walk_list, Label, Mutability};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::Applicability;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::DefId;\n use rustc_hir::definitions::{DefPathData, DisambiguatedDefPathData};\n-use rustc_hir::intravisit::{walk_expr, FnKind, Visitor};\n+use rustc_hir::intravisit::{walk_expr, walk_stmt, FnKind, Visitor};\n use rustc_hir::{\n     Arm, Block, Body, Expr, ExprKind, Guard, HirId, ImplicitSelfKind, Let, Local, Pat, PatKind, Path, PathSegment,\n     QPath, Stmt, StmtKind, TyKind, UnOp,\n@@ -33,6 +34,9 @@ declare_clippy_lint! {\n     /// and the assigned variables are also only in recursion, it is useless.\n     ///\n     /// ### Known problems\n+    /// Too many code paths in the linting code are currently untested and prone to produce false\n+    /// positives or are prone to have performance implications.\n+    ///\n     /// In some cases, this would not catch all useless arguments.\n     ///\n     /// ```rust\n@@ -85,7 +89,7 @@ declare_clippy_lint! {\n     /// ```\n     #[clippy::version = \"1.60.0\"]\n     pub ONLY_USED_IN_RECURSION,\n-    complexity,\n+    nursery,\n     \"arguments that is only used in recursion can be removed\"\n }\n declare_lint_pass!(OnlyUsedInRecursion => [ONLY_USED_IN_RECURSION]);\n@@ -100,6 +104,9 @@ impl<'tcx> LateLintPass<'tcx> for OnlyUsedInRecursion {\n         _: Span,\n         id: HirId,\n     ) {\n+        if is_lint_allowed(cx, ONLY_USED_IN_RECURSION, id) {\n+            return;\n+        }\n         if let FnKind::ItemFn(ident, ..) | FnKind::Method(ident, ..) = kind {\n             let def_id = id.owner.to_def_id();\n             let data = cx.tcx.def_path(def_id).data;\n@@ -145,7 +152,8 @@ impl<'tcx> LateLintPass<'tcx> for OnlyUsedInRecursion {\n                 is_method: matches!(kind, FnKind::Method(..)),\n                 has_self,\n                 ty_res,\n-                ty_ctx: cx.tcx,\n+                tcx: cx.tcx,\n+                visited_exprs: FxHashSet::default(),\n             };\n \n             visitor.visit_expr(&body.value);\n@@ -206,19 +214,13 @@ impl<'tcx> LateLintPass<'tcx> for OnlyUsedInRecursion {\n }\n \n pub fn is_primitive(ty: Ty<'_>) -> bool {\n-    match ty.kind() {\n-        ty::Bool | ty::Char | ty::Int(_) | ty::Uint(_) | ty::Float(_) | ty::Str => true,\n-        ty::Ref(_, t, _) => is_primitive(*t),\n-        _ => false,\n-    }\n+    let ty = ty.peel_refs();\n+    ty.is_primitive() || ty.is_str()\n }\n \n pub fn is_array(ty: Ty<'_>) -> bool {\n-    match ty.kind() {\n-        ty::Array(..) | ty::Slice(..) => true,\n-        ty::Ref(_, t, _) => is_array(*t),\n-        _ => false,\n-    }\n+    let ty = ty.peel_refs();\n+    ty.is_array() || ty.is_array_slice()\n }\n \n /// This builds the graph of side effect.\n@@ -250,40 +252,30 @@ pub struct SideEffectVisit<'tcx> {\n     is_method: bool,\n     has_self: bool,\n     ty_res: &'tcx TypeckResults<'tcx>,\n-    ty_ctx: TyCtxt<'tcx>,\n+    tcx: TyCtxt<'tcx>,\n+    visited_exprs: FxHashSet<HirId>,\n }\n \n impl<'tcx> Visitor<'tcx> for SideEffectVisit<'tcx> {\n-    fn visit_block(&mut self, b: &'tcx Block<'tcx>) {\n-        b.stmts.iter().for_each(|stmt| {\n-            self.visit_stmt(stmt);\n-            self.ret_vars.clear();\n-        });\n-        walk_list!(self, visit_expr, b.expr);\n-    }\n-\n     fn visit_stmt(&mut self, s: &'tcx Stmt<'tcx>) {\n         match s.kind {\n             StmtKind::Local(Local {\n                 pat, init: Some(init), ..\n             }) => {\n                 self.visit_pat_expr(pat, init, false);\n-                self.ret_vars.clear();\n             },\n-            StmtKind::Item(i) => {\n-                let item = self.ty_ctx.hir().item(i);\n-                self.visit_item(item);\n-                self.ret_vars.clear();\n-            },\n-            StmtKind::Expr(e) | StmtKind::Semi(e) => {\n-                self.visit_expr(e);\n-                self.ret_vars.clear();\n+            StmtKind::Item(_) | StmtKind::Expr(_) | StmtKind::Semi(_) => {\n+                walk_stmt(self, s);\n             },\n             StmtKind::Local(_) => {},\n         }\n+        self.ret_vars.clear();\n     }\n \n     fn visit_expr(&mut self, ex: &'tcx Expr<'tcx>) {\n+        if !self.visited_exprs.insert(ex.hir_id) {\n+            return;\n+        }\n         match ex.kind {\n             ExprKind::Array(exprs) | ExprKind::Tup(exprs) => {\n                 self.ret_vars = exprs\n@@ -307,7 +299,7 @@ impl<'tcx> Visitor<'tcx> for SideEffectVisit<'tcx> {\n             ExprKind::Match(expr, arms, _) => self.visit_match(expr, arms),\n             // since analysing the closure is not easy, just set all variables in it to side-effect\n             ExprKind::Closure(_, _, body_id, _, _) => {\n-                let body = self.ty_ctx.hir().body(body_id);\n+                let body = self.tcx.hir().body(body_id);\n                 self.visit_body(body);\n                 let vars = std::mem::take(&mut self.ret_vars);\n                 self.add_side_effect(vars);"}, {"sha": "ea5a8f0858b66aa14d084b55a585fa8ae7950be0", "filename": "clippy_lints/src/option_if_let_else.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Foption_if_let_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Foption_if_let_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foption_if_let_else.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -78,7 +78,7 @@ fn is_result_ok(cx: &LateContext<'_>, expr: &'_ Expr<'_>) -> bool {\n \n /// A struct containing information about occurrences of the\n /// `if let Some(..) = .. else` construct that this lint detects.\n-struct OptionIfLetElseOccurence {\n+struct OptionIfLetElseOccurrence {\n     option: String,\n     method_sugg: String,\n     some_expr: String,\n@@ -100,9 +100,9 @@ fn format_option_in_sugg(cx: &LateContext<'_>, cond_expr: &Expr<'_>, as_ref: boo\n }\n \n /// If this expression is the option if let/else construct we're detecting, then\n-/// this function returns an `OptionIfLetElseOccurence` struct with details if\n+/// this function returns an `OptionIfLetElseOccurrence` struct with details if\n /// this construct is found, or None if this construct is not found.\n-fn detect_option_if_let_else<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'tcx>) -> Option<OptionIfLetElseOccurence> {\n+fn detect_option_if_let_else<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'tcx>) -> Option<OptionIfLetElseOccurrence> {\n     if_chain! {\n         if !expr.span.from_expansion(); // Don't lint macros, because it behaves weirdly\n         if !in_constant(cx, expr.hir_id);\n@@ -154,7 +154,7 @@ fn detect_option_if_let_else<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'tcx>) ->\n                     }\n                 }\n             }\n-            Some(OptionIfLetElseOccurence {\n+            Some(OptionIfLetElseOccurrence {\n                 option: format_option_in_sugg(cx, cond_expr, as_ref, as_mut),\n                 method_sugg: method_sugg.to_string(),\n                 some_expr: format!(\"|{}{}| {}\", capture_mut, capture_name, Sugg::hir_with_macro_callsite(cx, some_body, \"..\")),"}, {"sha": "c35eeeac67a35c0567501ba3b38e7dcd1bc61f5e", "filename": "clippy_lints/src/ptr.rs", "status": "modified", "additions": 45, "deletions": 36, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fptr.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -3,16 +3,17 @@\n use clippy_utils::diagnostics::{span_lint, span_lint_and_sugg, span_lint_and_then};\n use clippy_utils::source::snippet_opt;\n use clippy_utils::ty::expr_sig;\n+use clippy_utils::visitors::contains_unsafe_block;\n use clippy_utils::{get_expr_use_or_unification_node, is_lint_allowed, path_def_id, path_to_local, paths};\n use if_chain::if_chain;\n use rustc_errors::{Applicability, MultiSpan};\n use rustc_hir::def_id::DefId;\n use rustc_hir::hir_id::HirIdMap;\n use rustc_hir::intravisit::{walk_expr, Visitor};\n use rustc_hir::{\n-    self as hir, AnonConst, BinOpKind, BindingAnnotation, Body, Expr, ExprKind, FnDecl, FnRetTy, GenericArg,\n+    self as hir, AnonConst, BinOpKind, BindingAnnotation, Body, Expr, ExprKind, FnRetTy, FnSig, GenericArg,\n     ImplItemKind, ItemKind, Lifetime, LifetimeName, Mutability, Node, Param, ParamName, PatKind, QPath, TraitFn,\n-    TraitItem, TraitItemKind, TyKind,\n+    TraitItem, TraitItemKind, TyKind, Unsafety,\n };\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::hir::nested_filter;\n@@ -88,19 +89,26 @@ declare_clippy_lint! {\n \n declare_clippy_lint! {\n     /// ### What it does\n-    /// This lint checks for functions that take immutable\n-    /// references and return mutable ones.\n+    /// This lint checks for functions that take immutable references and return\n+    /// mutable ones. This will not trigger if no unsafe code exists as there\n+    /// are multiple safe functions which will do this transformation\n+    ///\n+    /// To be on the conservative side, if there's at least one mutable\n+    /// reference with the output lifetime, this lint will not trigger.\n     ///\n     /// ### Why is this bad?\n-    /// This is trivially unsound, as one can create two\n-    /// mutable references from the same (immutable!) source.\n-    /// This [error](https://github.com/rust-lang/rust/issues/39465)\n-    /// actually lead to an interim Rust release 1.15.1.\n+    /// Creating a mutable reference which can be repeatably derived from an\n+    /// immutable reference is unsound as it allows creating multiple live\n+    /// mutable references to the same object.\n+    ///\n+    /// This [error](https://github.com/rust-lang/rust/issues/39465) actually\n+    /// lead to an interim Rust release 1.15.1.\n     ///\n     /// ### Known problems\n-    /// To be on the conservative side, if there's at least one\n-    /// mutable reference with the output lifetime, this lint will not trigger.\n-    /// In practice, this case is unlikely anyway.\n+    /// This pattern is used by memory allocators to allow allocating multiple\n+    /// objects while returning mutable references to each one. So long as\n+    /// different mutable references are returned each time such a function may\n+    /// be safe.\n     ///\n     /// ### Example\n     /// ```ignore\n@@ -145,7 +153,7 @@ impl<'tcx> LateLintPass<'tcx> for Ptr {\n                 return;\n             }\n \n-            check_mut_from_ref(cx, sig.decl);\n+            check_mut_from_ref(cx, sig, None);\n             for arg in check_fn_args(\n                 cx,\n                 cx.tcx.fn_sig(item.def_id).skip_binder().inputs(),\n@@ -170,10 +178,10 @@ impl<'tcx> LateLintPass<'tcx> for Ptr {\n     fn check_body(&mut self, cx: &LateContext<'tcx>, body: &'tcx Body<'_>) {\n         let hir = cx.tcx.hir();\n         let mut parents = hir.parent_iter(body.value.hir_id);\n-        let (item_id, decl, is_trait_item) = match parents.next() {\n+        let (item_id, sig, is_trait_item) = match parents.next() {\n             Some((_, Node::Item(i))) => {\n                 if let ItemKind::Fn(sig, ..) = &i.kind {\n-                    (i.def_id, sig.decl, false)\n+                    (i.def_id, sig, false)\n                 } else {\n                     return;\n                 }\n@@ -185,22 +193,23 @@ impl<'tcx> LateLintPass<'tcx> for Ptr {\n                     return;\n                 }\n                 if let ImplItemKind::Fn(sig, _) = &i.kind {\n-                    (i.def_id, sig.decl, false)\n+                    (i.def_id, sig, false)\n                 } else {\n                     return;\n                 }\n             },\n             Some((_, Node::TraitItem(i))) => {\n                 if let TraitItemKind::Fn(sig, _) = &i.kind {\n-                    (i.def_id, sig.decl, true)\n+                    (i.def_id, sig, true)\n                 } else {\n                     return;\n                 }\n             },\n             _ => return,\n         };\n \n-        check_mut_from_ref(cx, decl);\n+        check_mut_from_ref(cx, sig, Some(body));\n+        let decl = sig.decl;\n         let sig = cx.tcx.fn_sig(item_id).skip_binder();\n         let lint_args: Vec<_> = check_fn_args(cx, sig.inputs(), decl.inputs, body.params)\n             .filter(|arg| !is_trait_item || arg.mutability() == Mutability::Not)\n@@ -473,31 +482,31 @@ fn check_fn_args<'cx, 'tcx: 'cx>(\n         })\n }\n \n-fn check_mut_from_ref(cx: &LateContext<'_>, decl: &FnDecl<'_>) {\n-    if let FnRetTy::Return(ty) = decl.output {\n-        if let Some((out, Mutability::Mut, _)) = get_rptr_lm(ty) {\n-            let mut immutables = vec![];\n-            for (_, mutbl, argspan) in decl\n-                .inputs\n-                .iter()\n-                .filter_map(get_rptr_lm)\n-                .filter(|&(lt, _, _)| lt.name == out.name)\n-            {\n-                if mutbl == Mutability::Mut {\n-                    return;\n-                }\n-                immutables.push(argspan);\n-            }\n-            if immutables.is_empty() {\n-                return;\n-            }\n+fn check_mut_from_ref<'tcx>(cx: &LateContext<'tcx>, sig: &FnSig<'_>, body: Option<&'tcx Body<'_>>) {\n+    if let FnRetTy::Return(ty) = sig.decl.output\n+        && let Some((out, Mutability::Mut, _)) = get_rptr_lm(ty)\n+    {\n+        let args: Option<Vec<_>> = sig\n+            .decl\n+            .inputs\n+            .iter()\n+            .filter_map(get_rptr_lm)\n+            .filter(|&(lt, _, _)| lt.name == out.name)\n+            .map(|(_, mutability, span)| (mutability == Mutability::Not).then(|| span))\n+            .collect();\n+        if let Some(args) = args\n+            && !args.is_empty()\n+            && body.map_or(true, |body| {\n+                sig.header.unsafety == Unsafety::Unsafe || contains_unsafe_block(cx, &body.value)\n+            })\n+        {\n             span_lint_and_then(\n                 cx,\n                 MUT_FROM_REF,\n                 ty.span,\n                 \"mutable borrow from immutable input(s)\",\n                 |diag| {\n-                    let ms = MultiSpan::from_spans(immutables);\n+                    let ms = MultiSpan::from_spans(args);\n                     diag.span_note(ms, \"immutable borrow here\");\n                 },\n             );"}, {"sha": "9d2b0cedb60a165f18a843a25cb8817468654f00", "filename": "clippy_lints/src/pub_use.rs", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Fpub_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Fpub_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fpub_use.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -0,0 +1,56 @@\n+use clippy_utils::diagnostics::span_lint_and_help;\n+use rustc_ast::ast::{Item, ItemKind, VisibilityKind};\n+use rustc_lint::{EarlyContext, EarlyLintPass};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    ///\n+    /// Restricts the usage of `pub use ...`\n+    ///\n+    /// ### Why is this bad?\n+    ///\n+    /// `pub use` is usually fine, but a project may wish to limit `pub use` instances to prevent\n+    /// unintentional exports or to encourage placing exported items directly in public modules\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// pub mod outer {\n+    ///     mod inner {\n+    ///         pub struct Test {}\n+    ///     }\n+    ///     pub use inner::Test;\n+    /// }\n+    ///\n+    /// use outer::Test;\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// pub mod outer {\n+    ///     pub struct Test {}\n+    /// }\n+    ///\n+    /// use outer::Test;\n+    /// ```\n+    #[clippy::version = \"1.62.0\"]\n+    pub PUB_USE,\n+    restriction,\n+    \"restricts the usage of `pub use`\"\n+}\n+declare_lint_pass!(PubUse => [PUB_USE]);\n+\n+impl EarlyLintPass for PubUse {\n+    fn check_item(&mut self, cx: &EarlyContext<'_>, item: &Item) {\n+        if let ItemKind::Use(_) = item.kind &&\n+            let VisibilityKind::Public = item.vis.kind {\n+                span_lint_and_help(\n+                    cx,\n+                    PUB_USE,\n+                    item.span,\n+                    \"using `pub use`\",\n+                    None,\n+                    \"move the exported item to a public module instead\",\n+                );\n+            }\n+    }\n+}"}, {"sha": "323326381d4079149ce2591abd3c6a402b4e453b", "filename": "clippy_lints/src/redundant_pub_crate.rs", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Fredundant_pub_crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Fredundant_pub_crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fredundant_pub_crate.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -1,10 +1,12 @@\n use clippy_utils::diagnostics::span_lint_and_then;\n use rustc_errors::Applicability;\n+use rustc_hir::def::{DefKind, Res};\n use rustc_hir::{Item, ItemKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::def_id::CRATE_DEF_ID;\n+use rustc_span::hygiene::MacroKind;\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -43,8 +45,11 @@ impl_lint_pass!(RedundantPubCrate => [REDUNDANT_PUB_CRATE]);\n \n impl<'tcx> LateLintPass<'tcx> for RedundantPubCrate {\n     fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx Item<'tcx>) {\n-        if cx.tcx.visibility(item.def_id) == ty::Visibility::Restricted(CRATE_DEF_ID.to_def_id()) {\n-            if !cx.access_levels.is_exported(item.def_id) && self.is_exported.last() == Some(&false) {\n+        if_chain! {\n+            if cx.tcx.visibility(item.def_id) == ty::Visibility::Restricted(CRATE_DEF_ID.to_def_id());\n+            if !cx.access_levels.is_exported(item.def_id) && self.is_exported.last() == Some(&false);\n+            if is_not_macro_export(item);\n+            then {\n                 let span = item.span.with_hi(item.ident.span.hi());\n                 let descr = cx.tcx.def_kind(item.def_id).descr(item.def_id.to_def_id());\n                 span_lint_and_then(\n@@ -75,3 +80,15 @@ impl<'tcx> LateLintPass<'tcx> for RedundantPubCrate {\n         }\n     }\n }\n+\n+fn is_not_macro_export<'tcx>(item: &'tcx Item<'tcx>) -> bool {\n+    if let ItemKind::Use(path, _) = item.kind {\n+        if let Res::Def(DefKind::Macro(MacroKind::Bang), _) = path.res {\n+            return false;\n+        }\n+    } else if let ItemKind::Macro(..) = item.kind {\n+        return false;\n+    }\n+\n+    true\n+}"}, {"sha": "bfc03116fe2d9542678069c605ebf0088137b99a", "filename": "clippy_lints/src/renamed_lints.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Frenamed_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Frenamed_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Frenamed_lints.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -0,0 +1,39 @@\n+// This file is managed by `cargo dev rename_lint`. Prefer using that when possible.\n+\n+#[rustfmt::skip]\n+pub static RENAMED_LINTS: &[(&str, &str)] = &[\n+    (\"clippy::block_in_if_condition_expr\", \"clippy::blocks_in_if_conditions\"),\n+    (\"clippy::block_in_if_condition_stmt\", \"clippy::blocks_in_if_conditions\"),\n+    (\"clippy::box_vec\", \"clippy::box_collection\"),\n+    (\"clippy::const_static_lifetime\", \"clippy::redundant_static_lifetimes\"),\n+    (\"clippy::cyclomatic_complexity\", \"clippy::cognitive_complexity\"),\n+    (\"clippy::disallowed_method\", \"clippy::disallowed_methods\"),\n+    (\"clippy::disallowed_type\", \"clippy::disallowed_types\"),\n+    (\"clippy::for_loop_over_option\", \"clippy::for_loops_over_fallibles\"),\n+    (\"clippy::for_loop_over_result\", \"clippy::for_loops_over_fallibles\"),\n+    (\"clippy::identity_conversion\", \"clippy::useless_conversion\"),\n+    (\"clippy::if_let_some_result\", \"clippy::match_result_ok\"),\n+    (\"clippy::new_without_default_derive\", \"clippy::new_without_default\"),\n+    (\"clippy::option_and_then_some\", \"clippy::bind_instead_of_map\"),\n+    (\"clippy::option_expect_used\", \"clippy::expect_used\"),\n+    (\"clippy::option_map_unwrap_or\", \"clippy::map_unwrap_or\"),\n+    (\"clippy::option_map_unwrap_or_else\", \"clippy::map_unwrap_or\"),\n+    (\"clippy::option_unwrap_used\", \"clippy::unwrap_used\"),\n+    (\"clippy::ref_in_deref\", \"clippy::needless_borrow\"),\n+    (\"clippy::result_expect_used\", \"clippy::expect_used\"),\n+    (\"clippy::result_map_unwrap_or_else\", \"clippy::map_unwrap_or\"),\n+    (\"clippy::result_unwrap_used\", \"clippy::unwrap_used\"),\n+    (\"clippy::single_char_push_str\", \"clippy::single_char_add_str\"),\n+    (\"clippy::stutter\", \"clippy::module_name_repetitions\"),\n+    (\"clippy::to_string_in_display\", \"clippy::recursive_format_impl\"),\n+    (\"clippy::zero_width_space\", \"clippy::invisible_characters\"),\n+    (\"clippy::drop_bounds\", \"drop_bounds\"),\n+    (\"clippy::into_iter_on_array\", \"array_into_iter\"),\n+    (\"clippy::invalid_atomic_ordering\", \"invalid_atomic_ordering\"),\n+    (\"clippy::invalid_ref\", \"invalid_value\"),\n+    (\"clippy::mem_discriminant_non_enum\", \"enum_intrinsics_non_enums\"),\n+    (\"clippy::panic_params\", \"non_fmt_panics\"),\n+    (\"clippy::temporary_cstring_as_ptr\", \"temporary_cstring_as_ptr\"),\n+    (\"clippy::unknown_clippy_lints\", \"unknown_lints\"),\n+    (\"clippy::unused_label\", \"unused_labels\"),\n+];"}, {"sha": "f63925a2f1438ea8a71e6f500f1a5c11a70cd55e", "filename": "clippy_lints/src/same_name_method.rs", "status": "modified", "additions": 98, "deletions": 102, "changes": 200, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Fsame_name_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Fsame_name_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fsame_name_method.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -51,114 +51,110 @@ impl<'tcx> LateLintPass<'tcx> for SameNameMethod {\n         let mut map = FxHashMap::<Res, ExistingName>::default();\n \n         for id in cx.tcx.hir().items() {\n-            if !matches!(cx.tcx.hir().def_kind(id.def_id), DefKind::Impl) {\n-                continue;\n-            }\n-\n-            let item = cx.tcx.hir().item(id);\n-            if let ItemKind::Impl(Impl {\n-                items,\n-                of_trait,\n-                self_ty,\n-                ..\n-            }) = &item.kind\n+            if matches!(cx.tcx.hir().def_kind(id.def_id), DefKind::Impl)\n+                && let item = cx.tcx.hir().item(id)\n+                && let ItemKind::Impl(Impl {\n+                    items,\n+                    of_trait,\n+                    self_ty,\n+                    ..\n+                }) = &item.kind\n+                && let TyKind::Path(QPath::Resolved(_, Path { res, .. })) = self_ty.kind\n             {\n-                if let TyKind::Path(QPath::Resolved(_, Path { res, .. })) = self_ty.kind {\n-                    if !map.contains_key(res) {\n-                        map.insert(\n-                            *res,\n-                            ExistingName {\n-                                impl_methods: BTreeMap::new(),\n-                                trait_methods: BTreeMap::new(),\n-                            },\n-                        );\n-                    }\n-                    let existing_name = map.get_mut(res).unwrap();\n-\n-                    match of_trait {\n-                        Some(trait_ref) => {\n-                            let mut methods_in_trait: BTreeSet<Symbol> = if_chain! {\n-                                if let Some(Node::TraitRef(TraitRef { path, .. })) =\n-                                    cx.tcx.hir().find(trait_ref.hir_ref_id);\n-                                if let Res::Def(DefKind::Trait, did) = path.res;\n-                                then{\n-                                    // FIXME: if\n-                                    // `rustc_middle::ty::assoc::AssocItems::items` is public,\n-                                    // we can iterate its keys instead of `in_definition_order`,\n-                                    // which's more efficient\n-                                    cx.tcx\n-                                        .associated_items(did)\n-                                        .in_definition_order()\n-                                        .filter(|assoc_item| {\n-                                            matches!(assoc_item.kind, AssocKind::Fn)\n-                                        })\n-                                        .map(|assoc_item| assoc_item.name)\n-                                        .collect()\n-                                }else{\n-                                    BTreeSet::new()\n-                                }\n-                            };\n-\n-                            let mut check_trait_method = |method_name: Symbol, trait_method_span: Span| {\n-                                if let Some(impl_span) = existing_name.impl_methods.get(&method_name) {\n-                                    span_lint_and_then(\n-                                        cx,\n-                                        SAME_NAME_METHOD,\n-                                        *impl_span,\n-                                        \"method's name is the same as an existing method in a trait\",\n-                                        |diag| {\n-                                            diag.span_note(\n-                                                trait_method_span,\n-                                                &format!(\"existing `{}` defined here\", method_name),\n-                                            );\n-                                        },\n-                                    );\n-                                }\n-                                if let Some(v) = existing_name.trait_methods.get_mut(&method_name) {\n-                                    v.push(trait_method_span);\n-                                } else {\n-                                    existing_name.trait_methods.insert(method_name, vec![trait_method_span]);\n-                                }\n-                            };\n+                if !map.contains_key(res) {\n+                    map.insert(\n+                        *res,\n+                        ExistingName {\n+                            impl_methods: BTreeMap::new(),\n+                            trait_methods: BTreeMap::new(),\n+                        },\n+                    );\n+                }\n+                let existing_name = map.get_mut(res).unwrap();\n \n-                            for impl_item_ref in (*items).iter().filter(|impl_item_ref| {\n-                                matches!(impl_item_ref.kind, rustc_hir::AssocItemKind::Fn { .. })\n-                            }) {\n-                                let method_name = impl_item_ref.ident.name;\n-                                methods_in_trait.remove(&method_name);\n-                                check_trait_method(method_name, impl_item_ref.span);\n+                match of_trait {\n+                    Some(trait_ref) => {\n+                        let mut methods_in_trait: BTreeSet<Symbol> = if_chain! {\n+                            if let Some(Node::TraitRef(TraitRef { path, .. })) =\n+                                cx.tcx.hir().find(trait_ref.hir_ref_id);\n+                            if let Res::Def(DefKind::Trait, did) = path.res;\n+                            then{\n+                                // FIXME: if\n+                                // `rustc_middle::ty::assoc::AssocItems::items` is public,\n+                                // we can iterate its keys instead of `in_definition_order`,\n+                                // which's more efficient\n+                                cx.tcx\n+                                    .associated_items(did)\n+                                    .in_definition_order()\n+                                    .filter(|assoc_item| {\n+                                        matches!(assoc_item.kind, AssocKind::Fn)\n+                                    })\n+                                    .map(|assoc_item| assoc_item.name)\n+                                    .collect()\n+                            }else{\n+                                BTreeSet::new()\n                             }\n+                        };\n \n-                            for method_name in methods_in_trait {\n-                                check_trait_method(method_name, item.span);\n+                        let mut check_trait_method = |method_name: Symbol, trait_method_span: Span| {\n+                            if let Some(impl_span) = existing_name.impl_methods.get(&method_name) {\n+                                span_lint_and_then(\n+                                    cx,\n+                                    SAME_NAME_METHOD,\n+                                    *impl_span,\n+                                    \"method's name is the same as an existing method in a trait\",\n+                                    |diag| {\n+                                        diag.span_note(\n+                                            trait_method_span,\n+                                            &format!(\"existing `{}` defined here\", method_name),\n+                                        );\n+                                    },\n+                                );\n                             }\n-                        },\n-                        None => {\n-                            for impl_item_ref in (*items).iter().filter(|impl_item_ref| {\n-                                matches!(impl_item_ref.kind, rustc_hir::AssocItemKind::Fn { .. })\n-                            }) {\n-                                let method_name = impl_item_ref.ident.name;\n-                                let impl_span = impl_item_ref.span;\n-                                if let Some(trait_spans) = existing_name.trait_methods.get(&method_name) {\n-                                    span_lint_and_then(\n-                                        cx,\n-                                        SAME_NAME_METHOD,\n-                                        impl_span,\n-                                        \"method's name is the same as an existing method in a trait\",\n-                                        |diag| {\n-                                            // TODO should we `span_note` on every trait?\n-                                            // iterate on trait_spans?\n-                                            diag.span_note(\n-                                                trait_spans[0],\n-                                                &format!(\"existing `{}` defined here\", method_name),\n-                                            );\n-                                        },\n-                                    );\n-                                }\n-                                existing_name.impl_methods.insert(method_name, impl_span);\n+                            if let Some(v) = existing_name.trait_methods.get_mut(&method_name) {\n+                                v.push(trait_method_span);\n+                            } else {\n+                                existing_name.trait_methods.insert(method_name, vec![trait_method_span]);\n                             }\n-                        },\n-                    }\n+                        };\n+\n+                        for impl_item_ref in (*items).iter().filter(|impl_item_ref| {\n+                            matches!(impl_item_ref.kind, rustc_hir::AssocItemKind::Fn { .. })\n+                        }) {\n+                            let method_name = impl_item_ref.ident.name;\n+                            methods_in_trait.remove(&method_name);\n+                            check_trait_method(method_name, impl_item_ref.span);\n+                        }\n+\n+                        for method_name in methods_in_trait {\n+                            check_trait_method(method_name, item.span);\n+                        }\n+                    },\n+                    None => {\n+                        for impl_item_ref in (*items).iter().filter(|impl_item_ref| {\n+                            matches!(impl_item_ref.kind, rustc_hir::AssocItemKind::Fn { .. })\n+                        }) {\n+                            let method_name = impl_item_ref.ident.name;\n+                            let impl_span = impl_item_ref.span;\n+                            if let Some(trait_spans) = existing_name.trait_methods.get(&method_name) {\n+                                span_lint_and_then(\n+                                    cx,\n+                                    SAME_NAME_METHOD,\n+                                    impl_span,\n+                                    \"method's name is the same as an existing method in a trait\",\n+                                    |diag| {\n+                                        // TODO should we `span_note` on every trait?\n+                                        // iterate on trait_spans?\n+                                        diag.span_note(\n+                                            trait_spans[0],\n+                                            &format!(\"existing `{}` defined here\", method_name),\n+                                        );\n+                                    },\n+                                );\n+                            }\n+                            existing_name.impl_methods.insert(method_name, impl_span);\n+                        }\n+                    },\n                 }\n             }\n         }"}, {"sha": "a6c685df721d6fac310117306cb98cd2b46f9a96", "filename": "clippy_lints/src/stable_sort_primitive.rs", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Fstable_sort_primitive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Fstable_sort_primitive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fstable_sort_primitive.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -9,15 +9,25 @@ use rustc_session::{declare_lint_pass, declare_tool_lint};\n declare_clippy_lint! {\n     /// ### What it does\n     /// When sorting primitive values (integers, bools, chars, as well\n-    /// as arrays, slices, and tuples of such items), it is better to\n+    /// as arrays, slices, and tuples of such items), it is typically better to\n     /// use an unstable sort than a stable sort.\n     ///\n     /// ### Why is this bad?\n-    /// Using a stable sort consumes more memory and cpu cycles. Because\n-    /// values which compare equal are identical, preserving their\n+    /// Typically, using a stable sort consumes more memory and cpu cycles.\n+    /// Because values which compare equal are identical, preserving their\n     /// relative order (the guarantee that a stable sort provides) means\n     /// nothing, while the extra costs still apply.\n     ///\n+    /// ### Known problems\n+    ///\n+    /// As pointed out in\n+    /// [issue #8241](https://github.com/rust-lang/rust-clippy/issues/8241),\n+    /// a stable sort can instead be significantly faster for certain scenarios\n+    /// (eg. when a sorted vector is extended with new data and resorted).\n+    ///\n+    /// For more information and benchmarking results, please refer to the\n+    /// issue linked above.\n+    ///\n     /// ### Example\n     /// ```rust\n     /// let mut vec = vec![2, 1, 3];\n@@ -30,7 +40,7 @@ declare_clippy_lint! {\n     /// ```\n     #[clippy::version = \"1.47.0\"]\n     pub STABLE_SORT_PRIMITIVE,\n-    perf,\n+    pedantic,\n     \"use of sort() when sort_unstable() is equivalent\"\n }\n \n@@ -126,7 +136,7 @@ impl LateLintPass<'_> for StableSortPrimitive {\n                         Applicability::MachineApplicable,\n                     );\n                     diag.note(\n-                        \"an unstable sort would perform faster without any observable difference for this data type\",\n+                        \"an unstable sort typically performs faster without any observable difference for this data type\",\n                     );\n                 },\n             );"}, {"sha": "7c196ccaa8ccd2fb610f430e510b4a6aaa918314", "filename": "clippy_lints/src/strings.rs", "status": "modified", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Fstrings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Fstrings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fstrings.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -5,6 +5,7 @@ use clippy_utils::{get_parent_expr, is_lint_allowed, match_function_call, method\n use clippy_utils::{peel_blocks, SpanlessEq};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n+use rustc_hir::def_id::DefId;\n use rustc_hir::{BinOpKind, BorrowKind, Expr, ExprKind, LangItem, QPath};\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::lint::in_external_macro;\n@@ -451,3 +452,58 @@ impl<'tcx> LateLintPass<'tcx> for StringToString {\n         }\n     }\n }\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Warns about calling `str::trim` (or variants) before `str::split_whitespace`.\n+    ///\n+    /// ### Why is this bad?\n+    /// `split_whitespace` already ignores leading and trailing whitespace.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// \" A B C \".trim().split_whitespace();\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// \" A B C \".split_whitespace();\n+    /// ```\n+    #[clippy::version = \"1.62.0\"]\n+    pub TRIM_SPLIT_WHITESPACE,\n+    style,\n+    \"using `str::trim()` or alike before `str::split_whitespace`\"\n+}\n+declare_lint_pass!(TrimSplitWhitespace => [TRIM_SPLIT_WHITESPACE]);\n+\n+impl<'tcx> LateLintPass<'tcx> for TrimSplitWhitespace {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &Expr<'_>) {\n+        let tyckres = cx.typeck_results();\n+        if_chain! {\n+            if let ExprKind::MethodCall(path, [split_recv], split_ws_span) = expr.kind;\n+            if path.ident.name == sym!(split_whitespace);\n+            if let Some(split_ws_def_id) = tyckres.type_dependent_def_id(expr.hir_id);\n+            if cx.tcx.is_diagnostic_item(sym::str_split_whitespace, split_ws_def_id);\n+            if let ExprKind::MethodCall(path, [_trim_recv], trim_span) = split_recv.kind;\n+            if let trim_fn_name @ (\"trim\" | \"trim_start\" | \"trim_end\") = path.ident.name.as_str();\n+            if let Some(trim_def_id) = tyckres.type_dependent_def_id(split_recv.hir_id);\n+            if is_one_of_trim_diagnostic_items(cx, trim_def_id);\n+            then {\n+                span_lint_and_sugg(\n+                    cx,\n+                    TRIM_SPLIT_WHITESPACE,\n+                    trim_span.with_hi(split_ws_span.lo()),\n+                    &format!(\"found call to `str::{}` before `str::split_whitespace`\", trim_fn_name),\n+                    &format!(\"remove `{}()`\", trim_fn_name),\n+                    String::new(),\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n+        }\n+    }\n+}\n+\n+fn is_one_of_trim_diagnostic_items(cx: &LateContext<'_>, trim_def_id: DefId) -> bool {\n+    cx.tcx.is_diagnostic_item(sym::str_trim, trim_def_id)\n+        || cx.tcx.is_diagnostic_item(sym::str_trim_start, trim_def_id)\n+        || cx.tcx.is_diagnostic_item(sym::str_trim_end, trim_def_id)\n+}"}, {"sha": "c4c1aa11004acbc523d2ffe22a25c4148e96f9ff", "filename": "clippy_lints/src/suspicious_operation_groupings.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Fsuspicious_operation_groupings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Fsuspicious_operation_groupings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fsuspicious_operation_groupings.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -550,7 +550,7 @@ fn ident_difference_expr_with_base_location(\n     // IdentIter, then the output of this function will be almost always be correct\n     // in practice.\n     //\n-    // If it turns out that problematic cases are more prelavent than we assume,\n+    // If it turns out that problematic cases are more prevalent than we assume,\n     // then we should be able to change this function to do the correct traversal,\n     // without needing to change the rest of the code.\n "}, {"sha": "78e388a49af1d470291e93a36958e66e6c2c6572", "filename": "clippy_lints/src/trait_bounds.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Ftrait_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Ftrait_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftrait_bounds.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -13,6 +13,7 @@ use rustc_hir::{\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::Span;\n+use std::fmt::Write as _;\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -34,7 +35,7 @@ declare_clippy_lint! {\n     /// ```\n     #[clippy::version = \"1.38.0\"]\n     pub TYPE_REPETITION_IN_BOUNDS,\n-    pedantic,\n+    nursery,\n     \"Types are repeated unnecessary in trait bounds use `+` instead of using `T: _, T: _`\"\n }\n \n@@ -64,7 +65,7 @@ declare_clippy_lint! {\n     /// ```\n     #[clippy::version = \"1.47.0\"]\n     pub TRAIT_DUPLICATION_IN_BOUNDS,\n-    pedantic,\n+    nursery,\n     \"Check if the same trait bounds are specified twice during a function declaration\"\n }\n \n@@ -182,19 +183,19 @@ impl TraitBounds {\n                     for b in v.iter() {\n                         if let GenericBound::Trait(ref poly_trait_ref, _) = b {\n                             let path = &poly_trait_ref.trait_ref.path;\n-                            hint_string.push_str(&format!(\n+                            let _ = write!(hint_string,\n                                 \" {} +\",\n                                 snippet_with_applicability(cx, path.span, \"..\", &mut applicability)\n-                            ));\n+                            );\n                         }\n                     }\n                     for b in p.bounds.iter() {\n                         if let GenericBound::Trait(ref poly_trait_ref, _) = b {\n                             let path = &poly_trait_ref.trait_ref.path;\n-                            hint_string.push_str(&format!(\n+                            let _ = write!(hint_string,\n                                 \" {} +\",\n                                 snippet_with_applicability(cx, path.span, \"..\", &mut applicability)\n-                            ));\n+                            );\n                         }\n                     }\n                     hint_string.truncate(hint_string.len() - 2);\n@@ -241,7 +242,7 @@ fn check_trait_bound_duplication(cx: &LateContext<'_>, gen: &'_ Generics<'_>) {\n                         );\n                     }\n                     else {\n-                        trait_resolutions_direct.push((res_where, span_where))\n+                        trait_resolutions_direct.push((res_where, span_where));\n                     }\n                 }\n             }"}, {"sha": "0cbf5ccefa6d89ea6435cfc3a7647c81fee84e9e", "filename": "clippy_lints/src/transmute/utils.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Ftransmute%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Ftransmute%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute%2Futils.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -1,10 +1,9 @@\n use clippy_utils::last_path_segment;\n use clippy_utils::source::snippet;\n-use clippy_utils::ty::is_normalizable;\n use if_chain::if_chain;\n use rustc_hir::{Expr, GenericArg, QPath, TyKind};\n use rustc_lint::LateContext;\n-use rustc_middle::ty::{self, cast::CastKind, Ty};\n+use rustc_middle::ty::{cast::CastKind, Ty};\n use rustc_span::DUMMY_SP;\n use rustc_typeck::check::{cast::CastCheck, FnCtxt, Inherited};\n \n@@ -34,15 +33,12 @@ pub(super) fn get_type_snippet(cx: &LateContext<'_>, path: &QPath<'_>, to_ref_ty\n // check if the component types of the transmuted collection and the result have different ABI,\n // size or alignment\n pub(super) fn is_layout_incompatible<'tcx>(cx: &LateContext<'tcx>, from: Ty<'tcx>, to: Ty<'tcx>) -> bool {\n-    let empty_param_env = ty::ParamEnv::empty();\n-    // check if `from` and `to` are normalizable to avoid ICE (#4968)\n-    if !(is_normalizable(cx, empty_param_env, from) && is_normalizable(cx, empty_param_env, to)) {\n-        return false;\n-    }\n-    let from_ty_layout = cx.tcx.layout_of(empty_param_env.and(from));\n-    let to_ty_layout = cx.tcx.layout_of(empty_param_env.and(to));\n-    if let (Ok(from_layout), Ok(to_layout)) = (from_ty_layout, to_ty_layout) {\n-        from_layout.size != to_layout.size || from_layout.align != to_layout.align || from_layout.abi != to_layout.abi\n+    if let Ok(from) = cx.tcx.try_normalize_erasing_regions(cx.param_env, from)\n+        && let Ok(to) = cx.tcx.try_normalize_erasing_regions(cx.param_env, to)\n+        && let Ok(from_layout) = cx.tcx.layout_of(cx.param_env.and(from))\n+        && let Ok(to_layout) = cx.tcx.layout_of(cx.param_env.and(to))\n+    {\n+        from_layout.size != to_layout.size || from_layout.align.abi != to_layout.align.abi\n     } else {\n         // no idea about layout, so don't lint\n         false\n@@ -91,7 +87,7 @@ fn check_cast<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>, from_ty: Ty<'tcx>\n             let res = check.do_check(&fn_ctxt);\n \n             // do_check's documentation says that it might return Ok and create\n-            // errors in the fcx instead of returing Err in some cases. Those cases\n+            // errors in the fcx instead of returning Err in some cases. Those cases\n             // should be filtered out before getting here.\n             assert!(\n                 !fn_ctxt.errors_reported_since_creation(),"}, {"sha": "353a6f6b899ea3e743ed57982b8acd130d185e14", "filename": "clippy_lints/src/types/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Ftypes%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Ftypes%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes%2Fmod.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -432,8 +432,8 @@ impl Types {\n     fn check_fn_decl(&mut self, cx: &LateContext<'_>, decl: &FnDecl<'_>, context: CheckTyContext) {\n         // Ignore functions in trait implementations as they are usually forced by the trait definition.\n         //\n-        // FIXME: idially we would like to warn *if the compicated type can be simplified*, but it's hard to\n-        // check.\n+        // FIXME: ideally we would like to warn *if the complicated type can be simplified*, but it's hard\n+        // to check.\n         if context.is_in_trait_impl {\n             return;\n         }"}, {"sha": "465d8a914fb290b2a4e466750f923bc6be9cc4da", "filename": "clippy_lints/src/undocumented_unsafe_blocks.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Fundocumented_unsafe_blocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Fundocumented_unsafe_blocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fundocumented_unsafe_blocks.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -156,8 +156,9 @@ fn text_has_safety_comment(src: &str, line_starts: &[BytePos], offset: usize) ->\n         .array_windows::<2>()\n         .rev()\n         .map_while(|[start, end]| {\n-            src.get(start.to_usize() - offset..end.to_usize() - offset)\n-                .map(|text| (start.to_usize(), text.trim_start()))\n+            let start = start.to_usize() - offset;\n+            let end = end.to_usize() - offset;\n+            src.get(start..end).map(|text| (start, text.trim_start()))\n         })\n         .filter(|(_, text)| !text.is_empty());\n \n@@ -182,7 +183,7 @@ fn text_has_safety_comment(src: &str, line_starts: &[BytePos], offset: usize) ->\n     let (mut line_start, mut line) = (line_start, line);\n     loop {\n         if line.starts_with(\"/*\") {\n-            let src = src[line_start..line_starts.last().unwrap().to_usize()].trim_start();\n+            let src = src[line_start..line_starts.last().unwrap().to_usize() - offset].trim_start();\n             let mut tokens = tokenize(src);\n             return src[..tokens.next().unwrap().len]\n                 .to_ascii_uppercase()"}, {"sha": "f3f1f53aac5652f6c07a0e79daa9bf85a7d21ff9", "filename": "clippy_lints/src/unit_types/let_unit_value.rs", "status": "modified", "additions": 75, "deletions": 5, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Funit_types%2Flet_unit_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Funit_types%2Flet_unit_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funit_types%2Flet_unit_value.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -1,18 +1,46 @@\n use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::source::snippet_with_macro_callsite;\n+use clippy_utils::visitors::for_each_value_source;\n+use core::ops::ControlFlow;\n use rustc_errors::Applicability;\n-use rustc_hir::{Stmt, StmtKind};\n+use rustc_hir::{Expr, ExprKind, PatKind, Stmt, StmtKind};\n use rustc_lint::{LateContext, LintContext};\n use rustc_middle::lint::in_external_macro;\n+use rustc_middle::ty::{self, Ty, TypeFoldable, TypeVisitor};\n \n use super::LET_UNIT_VALUE;\n \n pub(super) fn check(cx: &LateContext<'_>, stmt: &Stmt<'_>) {\n-    if let StmtKind::Local(local) = stmt.kind {\n-        if cx.typeck_results().pat_ty(local.pat).is_unit() {\n-            if in_external_macro(cx.sess(), stmt.span) || local.pat.span.from_expansion() {\n-                return;\n+    if let StmtKind::Local(local) = stmt.kind\n+        && let Some(init) = local.init\n+        && !local.pat.span.from_expansion()\n+        && !in_external_macro(cx.sess(), stmt.span)\n+        && cx.typeck_results().pat_ty(local.pat).is_unit()\n+    {\n+        let needs_inferred = for_each_value_source(init, &mut |e| if needs_inferred_result_ty(cx, e) {\n+            ControlFlow::Continue(())\n+        } else {\n+            ControlFlow::Break(())\n+        }).is_continue();\n+\n+        if needs_inferred {\n+            if !matches!(local.pat.kind, PatKind::Wild) {\n+                span_lint_and_then(\n+                    cx,\n+                    LET_UNIT_VALUE,\n+                    stmt.span,\n+                    \"this let-binding has unit value\",\n+                    |diag| {\n+                            diag.span_suggestion(\n+                                local.pat.span,\n+                                \"use a wild (`_`) binding\",\n+                                \"_\",\n+                                Applicability::MaybeIncorrect, // snippet\n+                            );\n+                    },\n+                );\n             }\n+        } else {\n             span_lint_and_then(\n                 cx,\n                 LET_UNIT_VALUE,\n@@ -33,3 +61,45 @@ pub(super) fn check(cx: &LateContext<'_>, stmt: &Stmt<'_>) {\n         }\n     }\n }\n+\n+fn needs_inferred_result_ty(cx: &LateContext<'_>, e: &Expr<'_>) -> bool {\n+    let id = match e.kind {\n+        ExprKind::Call(\n+            Expr {\n+                kind: ExprKind::Path(ref path),\n+                hir_id,\n+                ..\n+            },\n+            _,\n+        ) => cx.qpath_res(path, *hir_id).opt_def_id(),\n+        ExprKind::MethodCall(..) => cx.typeck_results().type_dependent_def_id(e.hir_id),\n+        _ => return false,\n+    };\n+    if let Some(id) = id\n+        && let sig = cx.tcx.fn_sig(id).skip_binder()\n+        && let ty::Param(output_ty) = *sig.output().kind()\n+    {\n+        sig.inputs().iter().all(|&ty| !ty_contains_param(ty, output_ty.index))\n+    } else {\n+        false\n+    }\n+}\n+\n+fn ty_contains_param(ty: Ty<'_>, index: u32) -> bool {\n+    struct Visitor(u32);\n+    impl<'tcx> TypeVisitor<'tcx> for Visitor {\n+        type BreakTy = ();\n+        fn visit_ty(&mut self, ty: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n+            if let ty::Param(ty) = *ty.kind() {\n+                if ty.index == self.0 {\n+                    ControlFlow::BREAK\n+                } else {\n+                    ControlFlow::CONTINUE\n+                }\n+            } else {\n+                ty.super_visit_with(self)\n+            }\n+        }\n+    }\n+    ty.visit_with(&mut Visitor(index)).is_break()\n+}"}, {"sha": "a9e2073dec251de0d50b62c3b8d12df6531409f3", "filename": "clippy_lints/src/unit_types/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Funit_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Funit_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funit_types%2Fmod.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -23,7 +23,7 @@ declare_clippy_lint! {\n     /// ```\n     #[clippy::version = \"pre 1.29.0\"]\n     pub LET_UNIT_VALUE,\n-    pedantic,\n+    style,\n     \"creating a `let` binding to a value of unit type, which usually can't be used afterwards\"\n }\n "}, {"sha": "8a4f4c0ad9719f041d32083c357a910ebbfe20d4", "filename": "clippy_lints/src/unnecessary_owned_empty_strings.rs", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Funnecessary_owned_empty_strings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Funnecessary_owned_empty_strings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funnecessary_owned_empty_strings.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -0,0 +1,81 @@\n+use clippy_utils::{diagnostics::span_lint_and_sugg, ty::is_type_diagnostic_item};\n+use clippy_utils::{match_def_path, paths};\n+use if_chain::if_chain;\n+use rustc_ast::ast::LitKind;\n+use rustc_errors::Applicability;\n+use rustc_hir::{BorrowKind, Expr, ExprKind, Mutability};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::ty;\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::sym;\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    ///\n+    /// Detects cases of owned empty strings being passed as an argument to a function expecting `&str`\n+    ///\n+    /// ### Why is this bad?\n+    ///\n+    /// This results in longer and less readable code\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// vec![\"1\", \"2\", \"3\"].join(&String::new());\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// vec![\"1\", \"2\", \"3\"].join(\"\");\n+    /// ```\n+    #[clippy::version = \"1.62.0\"]\n+    pub UNNECESSARY_OWNED_EMPTY_STRINGS,\n+    style,\n+    \"detects cases of references to owned empty strings being passed as an argument to a function expecting `&str`\"\n+}\n+declare_lint_pass!(UnnecessaryOwnedEmptyStrings => [UNNECESSARY_OWNED_EMPTY_STRINGS]);\n+\n+impl<'tcx> LateLintPass<'tcx> for UnnecessaryOwnedEmptyStrings {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) {\n+        if_chain! {\n+            if let ExprKind::AddrOf(BorrowKind::Ref, Mutability::Not, inner_expr) = expr.kind;\n+            if let ExprKind::Call(fun, args) = inner_expr.kind;\n+            if let ExprKind::Path(ref qpath) = fun.kind;\n+            if let Some(fun_def_id) = cx.qpath_res(qpath, fun.hir_id).opt_def_id();\n+            if let ty::Ref(_, inner_str, _) = cx.typeck_results().expr_ty_adjusted(expr).kind();\n+            if inner_str.is_str();\n+            then {\n+                if match_def_path(cx, fun_def_id, &paths::STRING_NEW) {\n+                     span_lint_and_sugg(\n+                            cx,\n+                            UNNECESSARY_OWNED_EMPTY_STRINGS,\n+                            expr.span,\n+                            \"usage of `&String::new()` for a function expecting a `&str` argument\",\n+                            \"try\",\n+                            \"\\\"\\\"\".to_owned(),\n+                            Applicability::MachineApplicable,\n+                        );\n+                } else {\n+                    if_chain! {\n+                        if match_def_path(cx, fun_def_id, &paths::FROM_FROM);\n+                        if let [.., last_arg] = args;\n+                        if let ExprKind::Lit(spanned) = &last_arg.kind;\n+                        if let LitKind::Str(symbol, _) = spanned.node;\n+                        if symbol.is_empty();\n+                        let inner_expr_type = cx.typeck_results().expr_ty(inner_expr);\n+                        if is_type_diagnostic_item(cx, inner_expr_type, sym::String);\n+                        then {\n+                            span_lint_and_sugg(\n+                                cx,\n+                                UNNECESSARY_OWNED_EMPTY_STRINGS,\n+                                expr.span,\n+                                \"usage of `&String::from(\\\"\\\")` for a function expecting a `&str` argument\",\n+                                \"try\",\n+                                \"\\\"\\\"\".to_owned(),\n+                                Applicability::MachineApplicable,\n+                            );\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}"}, {"sha": "ae431aac83b82c0ccaf7eaf3a1dfcc1317c5795d", "filename": "clippy_lints/src/unnested_or_patterns.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Funnested_or_patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Funnested_or_patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funnested_or_patterns.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -5,7 +5,7 @@ use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::{meets_msrv, msrvs, over};\n use rustc_ast::mut_visit::*;\n use rustc_ast::ptr::P;\n-use rustc_ast::{self as ast, Pat, PatKind, PatKind::*, DUMMY_NODE_ID};\n+use rustc_ast::{self as ast, Mutability, Pat, PatKind, PatKind::*, DUMMY_NODE_ID};\n use rustc_ast_pretty::pprust;\n use rustc_errors::Applicability;\n use rustc_lint::{EarlyContext, EarlyLintPass};\n@@ -25,7 +25,7 @@ declare_clippy_lint! {\n     /// *disjunctive normal form (DNF)* into *conjunctive normal form (CNF)*.\n     ///\n     /// ### Why is this bad?\n-    /// In the example above, `Some` is repeated, which unncessarily complicates the pattern.\n+    /// In the example above, `Some` is repeated, which unnecessarily complicates the pattern.\n     ///\n     /// ### Example\n     /// ```rust\n@@ -230,6 +230,10 @@ fn transform_with_focus_on_idx(alternatives: &mut Vec<P<Pat>>, focus_idx: usize)\n         // with which a pattern `C(p_0)` may be formed,\n         // which we would want to join with other `C(p_j)`s.\n         Ident(.., None) | Lit(_) | Wild | Path(..) | Range(..) | Rest | MacCall(_)\n+        // Skip immutable refs, as grouping them saves few characters,\n+        // and almost always requires adding parens (increasing noisiness).\n+        // In the case of only two patterns, replacement adds net characters.\n+        | Ref(_, Mutability::Not)\n         // Dealt with elsewhere.\n         | Or(_) | Paren(_) => false,\n         // Transform `box x | ... | box y` into `box (x | y)`.\n@@ -241,10 +245,10 @@ fn transform_with_focus_on_idx(alternatives: &mut Vec<P<Pat>>, focus_idx: usize)\n             |k| matches!(k, Box(_)),\n             |k| always_pat!(k, Box(p) => p),\n         ),\n-        // Transform `&m x | ... | &m y` into `&m (x | y)`.\n-        Ref(target, m1) => extend_with_matching(\n+        // Transform `&mut x | ... | &mut y` into `&mut (x | y)`.\n+        Ref(target, Mutability::Mut) => extend_with_matching(\n             target, start, alternatives,\n-            |k| matches!(k, Ref(_, m2) if m1 == m2), // Mutabilities must match.\n+            |k| matches!(k, Ref(_, Mutability::Mut)),\n             |k| always_pat!(k, Ref(p, _) => p),\n         ),\n         // Transform `b @ p0 | ... b @ p1` into `b @ (p0 | p1)`."}, {"sha": "138f8bccb3f5741ba14987fc31d73fa9e6d34a5f", "filename": "clippy_lints/src/use_self.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Fuse_self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Fuse_self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fuse_self.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -30,7 +30,7 @@ declare_clippy_lint! {\n     ///\n     /// ### Known problems\n     /// - Unaddressed false negative in fn bodies of trait implementations\n-    /// - False positive with assotiated types in traits (#4140)\n+    /// - False positive with associated types in traits (#4140)\n     ///\n     /// ### Example\n     /// ```rust"}, {"sha": "ff5be825b781712030c5383b956721384f1184d6", "filename": "clippy_lints/src/utils/author.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Futils%2Fauthor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Futils%2Fauthor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fauthor.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -70,7 +70,7 @@ macro_rules! bind {\n     };\n }\n \n-/// Transforms the given `Option<T>` varibles into `OptionPat<Binding<T>>`.\n+/// Transforms the given `Option<T>` variables into `OptionPat<Binding<T>>`.\n /// This displays as `Some($name)` or `None` when printed. The name of the inner binding\n /// is set to the name of the variable passed to the macro.\n macro_rules! opt_bind {"}, {"sha": "74b0168a1794be449f2c285effd37b27938a27ac", "filename": "clippy_lints/src/utils/conf.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Futils%2Fconf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Futils%2Fconf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fconf.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -310,6 +310,12 @@ define_Conf! {\n     /// the slice pattern that is suggested. If more elements would be necessary, the lint is suppressed.\n     /// For example, `[_, _, _, e, ..]` is a slice pattern with 4 elements.\n     (max_suggested_slice_pattern_length: u64 = 3),\n+    /// Lint: AWAIT_HOLDING_INVALID_TYPE\n+    (await_holding_invalid_types: Vec<crate::utils::conf::DisallowedType> = Vec::new()),\n+    /// Lint: LARGE_INCLUDE_FILE.\n+    ///\n+    /// The maximum size of a file included via `include_bytes!()` or `include_str!()`, in bytes\n+    (max_include_file_size: u64 = 1_000_000),\n }\n \n /// Search for the configuration file."}, {"sha": "01efc527a8c3abaf5e49f574769657a2312d35d8", "filename": "clippy_lints/src/utils/dump_hir.rs", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Futils%2Fdump_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Futils%2Fdump_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fdump_hir.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -0,0 +1,55 @@\n+use clippy_utils::get_attr;\n+use rustc_hir as hir;\n+use rustc_lint::{LateContext, LateLintPass, LintContext};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+\n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// It formats the attached node with `{:#?}` and writes the result to the\n+    /// standard output. This is intended for debugging.\n+    ///\n+    /// ### Examples\n+    /// ```rs\n+    /// #[clippy::dump]\n+    /// use std::mem;\n+    ///\n+    /// #[clippy::dump]\n+    /// fn foo(input: u32) -> u64 {\n+    ///     input as u64\n+    /// }\n+    /// ```\n+    pub DUMP_HIR,\n+    internal_warn,\n+    \"helper to dump info about code\"\n+}\n+\n+declare_lint_pass!(DumpHir => [DUMP_HIR]);\n+\n+impl<'tcx> LateLintPass<'tcx> for DumpHir {\n+    fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::Item<'_>) {\n+        if has_attr(cx, item.hir_id()) {\n+            println!(\"{item:#?}\");\n+        }\n+    }\n+\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n+        if has_attr(cx, expr.hir_id) {\n+            println!(\"{expr:#?}\");\n+        }\n+    }\n+\n+    fn check_stmt(&mut self, cx: &LateContext<'tcx>, stmt: &'tcx hir::Stmt<'_>) {\n+        match stmt.kind {\n+            hir::StmtKind::Expr(e) | hir::StmtKind::Semi(e) if has_attr(cx, e.hir_id) => return,\n+            _ => {},\n+        }\n+        if has_attr(cx, stmt.hir_id) {\n+            println!(\"{stmt:#?}\");\n+        }\n+    }\n+}\n+\n+fn has_attr(cx: &LateContext<'_>, hir_id: hir::HirId) -> bool {\n+    let attrs = cx.tcx.hir().attrs(hir_id);\n+    get_attr(cx.sess(), attrs, \"dump\").count() > 0\n+}"}, {"sha": "37b114a0cfbc2239b4d539789daf80d638bba804", "filename": "clippy_lints/src/utils/inspector.rs", "status": "removed", "additions": 0, "deletions": 577, "changes": 577, "blob_url": "https://github.com/rust-lang/rust/blob/82f469f81b6daafb448e36c0e811cf2d40836edb/clippy_lints%2Fsrc%2Futils%2Finspector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82f469f81b6daafb448e36c0e811cf2d40836edb/clippy_lints%2Fsrc%2Futils%2Finspector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finspector.rs?ref=82f469f81b6daafb448e36c0e811cf2d40836edb", "patch": "@@ -1,577 +0,0 @@\n-//! checks for attributes\n-\n-use clippy_utils::get_attr;\n-use rustc_ast::ast::{Attribute, InlineAsmTemplatePiece};\n-use rustc_hir as hir;\n-use rustc_lint::{LateContext, LateLintPass, LintContext};\n-use rustc_middle::ty;\n-use rustc_session::Session;\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Dumps every ast/hir node which has the `#[clippy::dump]`\n-    /// attribute\n-    ///\n-    /// ### Example\n-    /// ```rust,ignore\n-    /// #[clippy::dump]\n-    /// extern crate foo;\n-    /// ```\n-    ///\n-    /// prints\n-    ///\n-    /// ```text\n-    /// item `foo`\n-    /// visibility inherited from outer item\n-    /// extern crate dylib source: \"/path/to/foo.so\"\n-    /// ```\n-    pub DEEP_CODE_INSPECTION,\n-    internal_warn,\n-    \"helper to dump info about code\"\n-}\n-\n-declare_lint_pass!(DeepCodeInspector => [DEEP_CODE_INSPECTION]);\n-\n-impl<'tcx> LateLintPass<'tcx> for DeepCodeInspector {\n-    fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::Item<'_>) {\n-        if !has_attr(cx.sess(), cx.tcx.hir().attrs(item.hir_id())) {\n-            return;\n-        }\n-        print_item(cx, item);\n-    }\n-\n-    fn check_impl_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::ImplItem<'_>) {\n-        if !has_attr(cx.sess(), cx.tcx.hir().attrs(item.hir_id())) {\n-            return;\n-        }\n-        println!(\"impl item `{}`\", item.ident.name);\n-        match cx.tcx.visibility(item.def_id) {\n-            ty::Visibility::Public => println!(\"public\"),\n-            ty::Visibility::Restricted(def_id) => {\n-                if def_id.is_top_level_module() {\n-                    println!(\"visible crate wide\")\n-                } else {\n-                    println!(\"visible in module `{}`\", cx.tcx.def_path_str(def_id))\n-                }\n-            },\n-            ty::Visibility::Invisible => println!(\"invisible\"),\n-        }\n-        match item.kind {\n-            hir::ImplItemKind::Const(_, body_id) => {\n-                println!(\"associated constant\");\n-                print_expr(cx, &cx.tcx.hir().body(body_id).value, 1);\n-            },\n-            hir::ImplItemKind::Fn(..) => println!(\"method\"),\n-            hir::ImplItemKind::TyAlias(_) => println!(\"associated type\"),\n-        }\n-    }\n-\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n-        if !has_attr(cx.sess(), cx.tcx.hir().attrs(expr.hir_id)) {\n-            return;\n-        }\n-        print_expr(cx, expr, 0);\n-    }\n-\n-    fn check_arm(&mut self, cx: &LateContext<'tcx>, arm: &'tcx hir::Arm<'_>) {\n-        if !has_attr(cx.sess(), cx.tcx.hir().attrs(arm.hir_id)) {\n-            return;\n-        }\n-        print_pat(cx, arm.pat, 1);\n-        if let Some(ref guard) = arm.guard {\n-            println!(\"guard:\");\n-            print_guard(cx, guard, 1);\n-        }\n-        println!(\"body:\");\n-        print_expr(cx, arm.body, 1);\n-    }\n-\n-    fn check_stmt(&mut self, cx: &LateContext<'tcx>, stmt: &'tcx hir::Stmt<'_>) {\n-        if !has_attr(cx.sess(), cx.tcx.hir().attrs(stmt.hir_id)) {\n-            return;\n-        }\n-        match stmt.kind {\n-            hir::StmtKind::Local(local) => {\n-                println!(\"local variable of type {}\", cx.typeck_results().node_type(local.hir_id));\n-                println!(\"pattern:\");\n-                print_pat(cx, local.pat, 0);\n-                if let Some(e) = local.init {\n-                    println!(\"init expression:\");\n-                    print_expr(cx, e, 0);\n-                }\n-            },\n-            hir::StmtKind::Item(_) => println!(\"item decl\"),\n-            hir::StmtKind::Expr(e) | hir::StmtKind::Semi(e) => print_expr(cx, e, 0),\n-        }\n-    }\n-}\n-\n-fn has_attr(sess: &Session, attrs: &[Attribute]) -> bool {\n-    get_attr(sess, attrs, \"dump\").count() > 0\n-}\n-\n-#[allow(clippy::similar_names)]\n-#[allow(clippy::too_many_lines)]\n-fn print_expr(cx: &LateContext<'_>, expr: &hir::Expr<'_>, indent: usize) {\n-    let ind = \"  \".repeat(indent);\n-    println!(\"{}+\", ind);\n-    println!(\"{}ty: {}\", ind, cx.typeck_results().expr_ty(expr));\n-    println!(\n-        \"{}adjustments: {:?}\",\n-        ind,\n-        cx.typeck_results().adjustments().get(expr.hir_id)\n-    );\n-    match expr.kind {\n-        hir::ExprKind::Box(e) => {\n-            println!(\"{}Box\", ind);\n-            print_expr(cx, e, indent + 1);\n-        },\n-        hir::ExprKind::Array(v) => {\n-            println!(\"{}Array\", ind);\n-            for e in v {\n-                print_expr(cx, e, indent + 1);\n-            }\n-        },\n-        hir::ExprKind::Call(func, args) => {\n-            println!(\"{}Call\", ind);\n-            println!(\"{}function:\", ind);\n-            print_expr(cx, func, indent + 1);\n-            println!(\"{}arguments:\", ind);\n-            for arg in args {\n-                print_expr(cx, arg, indent + 1);\n-            }\n-        },\n-        hir::ExprKind::Let(hir::Let { pat, init, ty, .. }) => {\n-            print_pat(cx, pat, indent + 1);\n-            if let Some(ty) = ty {\n-                println!(\"{}  type annotation: {:?}\", ind, ty);\n-            }\n-            print_expr(cx, init, indent + 1);\n-        },\n-        hir::ExprKind::MethodCall(path, args, _) => {\n-            println!(\"{}MethodCall\", ind);\n-            println!(\"{}method name: {}\", ind, path.ident.name);\n-            for arg in args {\n-                print_expr(cx, arg, indent + 1);\n-            }\n-        },\n-        hir::ExprKind::Tup(v) => {\n-            println!(\"{}Tup\", ind);\n-            for e in v {\n-                print_expr(cx, e, indent + 1);\n-            }\n-        },\n-        hir::ExprKind::Binary(op, lhs, rhs) => {\n-            println!(\"{}Binary\", ind);\n-            println!(\"{}op: {:?}\", ind, op.node);\n-            println!(\"{}lhs:\", ind);\n-            print_expr(cx, lhs, indent + 1);\n-            println!(\"{}rhs:\", ind);\n-            print_expr(cx, rhs, indent + 1);\n-        },\n-        hir::ExprKind::Unary(op, inner) => {\n-            println!(\"{}Unary\", ind);\n-            println!(\"{}op: {:?}\", ind, op);\n-            print_expr(cx, inner, indent + 1);\n-        },\n-        hir::ExprKind::Lit(ref lit) => {\n-            println!(\"{}Lit\", ind);\n-            println!(\"{}{:?}\", ind, lit);\n-        },\n-        hir::ExprKind::Cast(e, target) => {\n-            println!(\"{}Cast\", ind);\n-            print_expr(cx, e, indent + 1);\n-            println!(\"{}target type: {:?}\", ind, target);\n-        },\n-        hir::ExprKind::Type(e, target) => {\n-            println!(\"{}Type\", ind);\n-            print_expr(cx, e, indent + 1);\n-            println!(\"{}target type: {:?}\", ind, target);\n-        },\n-        hir::ExprKind::Loop(..) => {\n-            println!(\"{}Loop\", ind);\n-        },\n-        hir::ExprKind::If(cond, _, ref else_opt) => {\n-            println!(\"{}If\", ind);\n-            println!(\"{}condition:\", ind);\n-            print_expr(cx, cond, indent + 1);\n-            if let Some(els) = *else_opt {\n-                println!(\"{}else:\", ind);\n-                print_expr(cx, els, indent + 1);\n-            }\n-        },\n-        hir::ExprKind::Match(cond, _, ref source) => {\n-            println!(\"{}Match\", ind);\n-            println!(\"{}condition:\", ind);\n-            print_expr(cx, cond, indent + 1);\n-            println!(\"{}source: {:?}\", ind, source);\n-        },\n-        hir::ExprKind::Closure(ref clause, _, _, _, _) => {\n-            println!(\"{}Closure\", ind);\n-            println!(\"{}clause: {:?}\", ind, clause);\n-        },\n-        hir::ExprKind::Yield(sub, _) => {\n-            println!(\"{}Yield\", ind);\n-            print_expr(cx, sub, indent + 1);\n-        },\n-        hir::ExprKind::Block(_, _) => {\n-            println!(\"{}Block\", ind);\n-        },\n-        hir::ExprKind::Assign(lhs, rhs, _) => {\n-            println!(\"{}Assign\", ind);\n-            println!(\"{}lhs:\", ind);\n-            print_expr(cx, lhs, indent + 1);\n-            println!(\"{}rhs:\", ind);\n-            print_expr(cx, rhs, indent + 1);\n-        },\n-        hir::ExprKind::AssignOp(ref binop, lhs, rhs) => {\n-            println!(\"{}AssignOp\", ind);\n-            println!(\"{}op: {:?}\", ind, binop.node);\n-            println!(\"{}lhs:\", ind);\n-            print_expr(cx, lhs, indent + 1);\n-            println!(\"{}rhs:\", ind);\n-            print_expr(cx, rhs, indent + 1);\n-        },\n-        hir::ExprKind::Field(e, ident) => {\n-            println!(\"{}Field\", ind);\n-            println!(\"{}field name: {}\", ind, ident.name);\n-            println!(\"{}struct expr:\", ind);\n-            print_expr(cx, e, indent + 1);\n-        },\n-        hir::ExprKind::Index(arr, idx) => {\n-            println!(\"{}Index\", ind);\n-            println!(\"{}array expr:\", ind);\n-            print_expr(cx, arr, indent + 1);\n-            println!(\"{}index expr:\", ind);\n-            print_expr(cx, idx, indent + 1);\n-        },\n-        hir::ExprKind::Path(hir::QPath::Resolved(ref ty, path)) => {\n-            println!(\"{}Resolved Path, {:?}\", ind, ty);\n-            println!(\"{}path: {:?}\", ind, path);\n-        },\n-        hir::ExprKind::Path(hir::QPath::TypeRelative(ty, seg)) => {\n-            println!(\"{}Relative Path, {:?}\", ind, ty);\n-            println!(\"{}seg: {:?}\", ind, seg);\n-        },\n-        hir::ExprKind::Path(hir::QPath::LangItem(lang_item, ..)) => {\n-            println!(\"{}Lang Item Path, {:?}\", ind, lang_item.name());\n-        },\n-        hir::ExprKind::AddrOf(kind, ref muta, e) => {\n-            println!(\"{}AddrOf\", ind);\n-            println!(\"kind: {:?}\", kind);\n-            println!(\"mutability: {:?}\", muta);\n-            print_expr(cx, e, indent + 1);\n-        },\n-        hir::ExprKind::Break(_, ref e) => {\n-            println!(\"{}Break\", ind);\n-            if let Some(e) = *e {\n-                print_expr(cx, e, indent + 1);\n-            }\n-        },\n-        hir::ExprKind::Continue(_) => println!(\"{}Again\", ind),\n-        hir::ExprKind::Ret(ref e) => {\n-            println!(\"{}Ret\", ind);\n-            if let Some(e) = *e {\n-                print_expr(cx, e, indent + 1);\n-            }\n-        },\n-        hir::ExprKind::InlineAsm(asm) => {\n-            println!(\"{}InlineAsm\", ind);\n-            println!(\"{}template: {}\", ind, InlineAsmTemplatePiece::to_string(asm.template));\n-            println!(\"{}options: {:?}\", ind, asm.options);\n-            println!(\"{}operands:\", ind);\n-            for (op, _op_sp) in asm.operands {\n-                match op {\n-                    hir::InlineAsmOperand::In { expr, .. }\n-                    | hir::InlineAsmOperand::InOut { expr, .. } => {\n-                        print_expr(cx, expr, indent + 1);\n-                    }\n-                    hir::InlineAsmOperand::Out { expr, .. } => {\n-                        if let Some(expr) = expr {\n-                            print_expr(cx, expr, indent + 1);\n-                        }\n-                    },\n-                    hir::InlineAsmOperand::SplitInOut { in_expr, out_expr, .. } => {\n-                        print_expr(cx, in_expr, indent + 1);\n-                        if let Some(out_expr) = out_expr {\n-                            print_expr(cx, out_expr, indent + 1);\n-                        }\n-                    },\n-                    hir::InlineAsmOperand::Const { anon_const }\n-                    | hir::InlineAsmOperand::SymFn { anon_const } => {\n-                        println!(\"{}anon_const:\", ind);\n-                        print_expr(cx, &cx.tcx.hir().body(anon_const.body).value, indent + 1);\n-                    },\n-                    hir::InlineAsmOperand::SymStatic { path, .. } => {\n-                        match path {\n-                            hir::QPath::Resolved(ref ty, path) => {\n-                                println!(\"{}Resolved Path, {:?}\", ind, ty);\n-                                println!(\"{}path: {:?}\", ind, path);\n-                            },\n-                            hir::QPath::TypeRelative(ty, seg) => {\n-                                println!(\"{}Relative Path, {:?}\", ind, ty);\n-                                println!(\"{}seg: {:?}\", ind, seg);\n-                            },\n-                            hir::QPath::LangItem(lang_item, ..) => {\n-                                println!(\"{}Lang Item Path, {:?}\", ind, lang_item.name());\n-                            },\n-                        }\n-                    }\n-                }\n-            }\n-        },\n-        hir::ExprKind::Struct(path, fields, ref base) => {\n-            println!(\"{}Struct\", ind);\n-            println!(\"{}path: {:?}\", ind, path);\n-            for field in fields {\n-                println!(\"{}field \\\"{}\\\":\", ind, field.ident.name);\n-                print_expr(cx, field.expr, indent + 1);\n-            }\n-            if let Some(base) = *base {\n-                println!(\"{}base:\", ind);\n-                print_expr(cx, base, indent + 1);\n-            }\n-        },\n-        hir::ExprKind::ConstBlock(ref anon_const) => {\n-            println!(\"{}ConstBlock\", ind);\n-            println!(\"{}anon_const:\", ind);\n-            print_expr(cx, &cx.tcx.hir().body(anon_const.body).value, indent + 1);\n-        },\n-        hir::ExprKind::Repeat(val, length) => {\n-            println!(\"{}Repeat\", ind);\n-            println!(\"{}value:\", ind);\n-            print_expr(cx, val, indent + 1);\n-            println!(\"{}repeat count:\", ind);\n-            match length {\n-                hir::ArrayLen::Infer(_, _) => println!(\"{}repeat count: _\", ind),\n-                hir::ArrayLen::Body(anon_const) => {\n-                    print_expr(cx, &cx.tcx.hir().body(anon_const.body).value, indent + 1);\n-                },\n-            }\n-        },\n-        hir::ExprKind::Err => {\n-            println!(\"{}Err\", ind);\n-        },\n-        hir::ExprKind::DropTemps(e) => {\n-            println!(\"{}DropTemps\", ind);\n-            print_expr(cx, e, indent + 1);\n-        },\n-    }\n-}\n-\n-fn print_item(cx: &LateContext<'_>, item: &hir::Item<'_>) {\n-    let did = item.def_id;\n-    println!(\"item `{}`\", item.ident.name);\n-    match cx.tcx.visibility(item.def_id) {\n-        ty::Visibility::Public => println!(\"public\"),\n-        ty::Visibility::Restricted(def_id) => {\n-            if def_id.is_top_level_module() {\n-                println!(\"visible crate wide\")\n-            } else {\n-                println!(\"visible in module `{}`\", cx.tcx.def_path_str(def_id))\n-            }\n-        },\n-        ty::Visibility::Invisible => println!(\"invisible\"),\n-    }\n-    match item.kind {\n-        hir::ItemKind::ExternCrate(ref _renamed_from) => {\n-            if let Some(crate_id) = cx.tcx.extern_mod_stmt_cnum(did) {\n-                let source = cx.tcx.used_crate_source(crate_id);\n-                if let Some(ref src) = source.dylib {\n-                    println!(\"extern crate dylib source: {:?}\", src.0);\n-                }\n-                if let Some(ref src) = source.rlib {\n-                    println!(\"extern crate rlib source: {:?}\", src.0);\n-                }\n-            } else {\n-                println!(\"weird extern crate without a crate id\");\n-            }\n-        },\n-        hir::ItemKind::Use(path, ref kind) => println!(\"{:?}, {:?}\", path, kind),\n-        hir::ItemKind::Static(..) => println!(\"static item of type {:#?}\", cx.tcx.type_of(did)),\n-        hir::ItemKind::Const(..) => println!(\"const item of type {:#?}\", cx.tcx.type_of(did)),\n-        hir::ItemKind::Fn(..) => {\n-            let item_ty = cx.tcx.type_of(did);\n-            println!(\"function of type {:#?}\", item_ty);\n-        },\n-        hir::ItemKind::Macro(ref macro_def, _) => {\n-            if macro_def.macro_rules {\n-                println!(\"macro introduced by `macro_rules!`\");\n-            } else {\n-                println!(\"macro introduced by `macro`\");\n-            }\n-        },\n-        hir::ItemKind::Mod(..) => println!(\"module\"),\n-        hir::ItemKind::ForeignMod { abi, .. } => println!(\"foreign module with abi: {}\", abi),\n-        hir::ItemKind::GlobalAsm(asm) => println!(\"global asm: {:?}\", asm),\n-        hir::ItemKind::TyAlias(..) => {\n-            println!(\"type alias for {:?}\", cx.tcx.type_of(did));\n-        },\n-        hir::ItemKind::OpaqueTy(..) => {\n-            println!(\"existential type with real type {:?}\", cx.tcx.type_of(did));\n-        },\n-        hir::ItemKind::Enum(..) => {\n-            println!(\"enum definition of type {:?}\", cx.tcx.type_of(did));\n-        },\n-        hir::ItemKind::Struct(..) => {\n-            println!(\"struct definition of type {:?}\", cx.tcx.type_of(did));\n-        },\n-        hir::ItemKind::Union(..) => {\n-            println!(\"union definition of type {:?}\", cx.tcx.type_of(did));\n-        },\n-        hir::ItemKind::Trait(..) => {\n-            println!(\"trait decl\");\n-            if cx.tcx.trait_is_auto(did.to_def_id()) {\n-                println!(\"trait is auto\");\n-            } else {\n-                println!(\"trait is not auto\");\n-            }\n-        },\n-        hir::ItemKind::TraitAlias(..) => {\n-            println!(\"trait alias\");\n-        },\n-        hir::ItemKind::Impl(hir::Impl {\n-            of_trait: Some(ref _trait_ref),\n-            ..\n-        }) => {\n-            println!(\"trait impl\");\n-        },\n-        hir::ItemKind::Impl(hir::Impl { of_trait: None, .. }) => {\n-            println!(\"impl\");\n-        },\n-    }\n-}\n-\n-#[allow(clippy::similar_names)]\n-#[allow(clippy::too_many_lines)]\n-fn print_pat(cx: &LateContext<'_>, pat: &hir::Pat<'_>, indent: usize) {\n-    let ind = \"  \".repeat(indent);\n-    println!(\"{}+\", ind);\n-    match pat.kind {\n-        hir::PatKind::Wild => println!(\"{}Wild\", ind),\n-        hir::PatKind::Binding(ref mode, .., ident, ref inner) => {\n-            println!(\"{}Binding\", ind);\n-            println!(\"{}mode: {:?}\", ind, mode);\n-            println!(\"{}name: {}\", ind, ident.name);\n-            if let Some(inner) = *inner {\n-                println!(\"{}inner:\", ind);\n-                print_pat(cx, inner, indent + 1);\n-            }\n-        },\n-        hir::PatKind::Or(fields) => {\n-            println!(\"{}Or\", ind);\n-            for field in fields {\n-                print_pat(cx, field, indent + 1);\n-            }\n-        },\n-        hir::PatKind::Struct(ref path, fields, ignore) => {\n-            println!(\"{}Struct\", ind);\n-            println!(\n-                \"{}name: {}\",\n-                ind,\n-                rustc_hir_pretty::to_string(rustc_hir_pretty::NO_ANN, |s| s.print_qpath(path, false))\n-            );\n-            println!(\"{}ignore leftover fields: {}\", ind, ignore);\n-            println!(\"{}fields:\", ind);\n-            for field in fields {\n-                println!(\"{}  field name: {}\", ind, field.ident.name);\n-                if field.is_shorthand {\n-                    println!(\"{}  in shorthand notation\", ind);\n-                }\n-                print_pat(cx, field.pat, indent + 1);\n-            }\n-        },\n-        hir::PatKind::TupleStruct(ref path, fields, opt_dots_position) => {\n-            println!(\"{}TupleStruct\", ind);\n-            println!(\n-                \"{}path: {}\",\n-                ind,\n-                rustc_hir_pretty::to_string(rustc_hir_pretty::NO_ANN, |s| s.print_qpath(path, false))\n-            );\n-            if let Some(dot_position) = opt_dots_position {\n-                println!(\"{}dot position: {}\", ind, dot_position);\n-            }\n-            for field in fields {\n-                print_pat(cx, field, indent + 1);\n-            }\n-        },\n-        hir::PatKind::Path(hir::QPath::Resolved(ref ty, path)) => {\n-            println!(\"{}Resolved Path, {:?}\", ind, ty);\n-            println!(\"{}path: {:?}\", ind, path);\n-        },\n-        hir::PatKind::Path(hir::QPath::TypeRelative(ty, seg)) => {\n-            println!(\"{}Relative Path, {:?}\", ind, ty);\n-            println!(\"{}seg: {:?}\", ind, seg);\n-        },\n-        hir::PatKind::Path(hir::QPath::LangItem(lang_item, ..)) => {\n-            println!(\"{}Lang Item Path, {:?}\", ind, lang_item.name());\n-        },\n-        hir::PatKind::Tuple(pats, opt_dots_position) => {\n-            println!(\"{}Tuple\", ind);\n-            if let Some(dot_position) = opt_dots_position {\n-                println!(\"{}dot position: {}\", ind, dot_position);\n-            }\n-            for field in pats {\n-                print_pat(cx, field, indent + 1);\n-            }\n-        },\n-        hir::PatKind::Box(inner) => {\n-            println!(\"{}Box\", ind);\n-            print_pat(cx, inner, indent + 1);\n-        },\n-        hir::PatKind::Ref(inner, ref muta) => {\n-            println!(\"{}Ref\", ind);\n-            println!(\"{}mutability: {:?}\", ind, muta);\n-            print_pat(cx, inner, indent + 1);\n-        },\n-        hir::PatKind::Lit(e) => {\n-            println!(\"{}Lit\", ind);\n-            print_expr(cx, e, indent + 1);\n-        },\n-        hir::PatKind::Range(ref l, ref r, ref range_end) => {\n-            println!(\"{}Range\", ind);\n-            if let Some(expr) = l {\n-                print_expr(cx, expr, indent + 1);\n-            }\n-            if let Some(expr) = r {\n-                print_expr(cx, expr, indent + 1);\n-            }\n-            match *range_end {\n-                hir::RangeEnd::Included => println!(\"{} end included\", ind),\n-                hir::RangeEnd::Excluded => println!(\"{} end excluded\", ind),\n-            }\n-        },\n-        hir::PatKind::Slice(first_pats, ref range, last_pats) => {\n-            println!(\"{}Slice [a, b, ..i, y, z]\", ind);\n-            println!(\"[a, b]:\");\n-            for pat in first_pats {\n-                print_pat(cx, pat, indent + 1);\n-            }\n-            println!(\"i:\");\n-            if let Some(pat) = *range {\n-                print_pat(cx, pat, indent + 1);\n-            }\n-            println!(\"[y, z]:\");\n-            for pat in last_pats {\n-                print_pat(cx, pat, indent + 1);\n-            }\n-        },\n-    }\n-}\n-\n-fn print_guard(cx: &LateContext<'_>, guard: &hir::Guard<'_>, indent: usize) {\n-    let ind = \"  \".repeat(indent);\n-    println!(\"{}+\", ind);\n-    match guard {\n-        hir::Guard::If(expr) => {\n-            println!(\"{}If\", ind);\n-            print_expr(cx, expr, indent + 1);\n-        },\n-        hir::Guard::IfLet(pat, expr) => {\n-            println!(\"{}IfLet\", ind);\n-            print_pat(cx, pat, indent + 1);\n-            print_expr(cx, expr, indent + 1);\n-        },\n-    }\n-}"}, {"sha": "0e8f40e92101a053ab1d5210b761838ca2447b87", "filename": "clippy_lints/src/utils/internal_lints.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -292,7 +292,7 @@ declare_clippy_lint! {\n     /// Checks for unnecessary conversion from Symbol to a string.\n     ///\n     /// ### Why is this bad?\n-    /// It's faster use symbols directly intead of strings.\n+    /// It's faster use symbols directly instead of strings.\n     ///\n     /// ### Example\n     /// Bad:\n@@ -823,7 +823,7 @@ fn suggest_note(\n         cx,\n         COLLAPSIBLE_SPAN_LINT_CALLS,\n         expr.span,\n-        \"this call is collspible\",\n+        \"this call is collapsible\",\n         \"collapse into\",\n         format!(\n             \"span_lint_and_note({}, {}, {}, {}, {}, {})\","}, {"sha": "8c1910b3b2af8d37aab0874ad8ac0b6456fc5ab5", "filename": "clippy_lints/src/utils/internal_lints/metadata_collector.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -33,7 +33,7 @@ use std::path::Path;\n /// This is the output file of the lint collector.\n const OUTPUT_FILE: &str = \"../util/gh-pages/lints.json\";\n /// These lints are excluded from the export.\n-const BLACK_LISTED_LINTS: [&str; 3] = [\"lint_author\", \"deep_code_inspection\", \"internal_metadata_collector\"];\n+const BLACK_LISTED_LINTS: &[&str] = &[\"lint_author\", \"dump_hir\", \"internal_metadata_collector\"];\n /// These groups will be ignored by the lint group matcher. This is useful for collections like\n /// `clippy::all`\n const IGNORED_LINT_GROUPS: [&str; 1] = [\"clippy::all\"];\n@@ -117,7 +117,7 @@ const APPLICABILITY_NAME_INDEX: usize = 2;\n /// This applicability will be set for unresolved applicability values.\n const APPLICABILITY_UNRESOLVED_STR: &str = \"Unresolved\";\n /// The version that will be displayed if none has been defined\n-const VERION_DEFAULT_STR: &str = \"Unknown\";\n+const VERSION_DEFAULT_STR: &str = \"Unknown\";\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -571,7 +571,7 @@ fn extract_attr_docs(cx: &LateContext<'_>, item: &Item<'_>) -> Option<String> {\n \n fn get_lint_version(cx: &LateContext<'_>, item: &Item<'_>) -> String {\n     extract_clippy_version_value(cx, item).map_or_else(\n-        || VERION_DEFAULT_STR.to_string(),\n+        || VERSION_DEFAULT_STR.to_string(),\n         |version| version.as_str().to_string(),\n     )\n }\n@@ -872,7 +872,7 @@ impl<'a, 'hir> IsMultiSpanScanner<'a, 'hir> {\n         self.suggestion_count += 2;\n     }\n \n-    /// Checks if the suggestions include multiple spanns\n+    /// Checks if the suggestions include multiple spans\n     fn is_multi_part(&self) -> bool {\n         self.suggestion_count > 1\n     }"}, {"sha": "787e9fd982c89c40ab67b3f1f997aa643bd406e8", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -1,5 +1,5 @@\n pub mod author;\n pub mod conf;\n-pub mod inspector;\n+pub mod dump_hir;\n #[cfg(feature = \"internal\")]\n pub mod internal_lints;"}, {"sha": "fdb822c3e5b6d6f5908312885dbff2455323c455", "filename": "clippy_utils/src/consts.rs", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_utils%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_utils%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fconsts.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -5,7 +5,7 @@ use if_chain::if_chain;\n use rustc_ast::ast::{self, LitFloatType, LitKind};\n use rustc_data_structures::sync::Lrc;\n use rustc_hir::def::{DefKind, Res};\n-use rustc_hir::{BinOp, BinOpKind, Block, Expr, ExprKind, HirId, QPath, UnOp};\n+use rustc_hir::{BinOp, BinOpKind, Block, Expr, ExprKind, HirId, Item, ItemKind, Node, QPath, UnOp};\n use rustc_lint::LateContext;\n use rustc_middle::mir::interpret::Scalar;\n use rustc_middle::ty::subst::{Subst, SubstsRef};\n@@ -400,6 +400,22 @@ impl<'a, 'tcx> ConstEvalLateContext<'a, 'tcx> {\n         let res = self.typeck_results.qpath_res(qpath, id);\n         match res {\n             Res::Def(DefKind::Const | DefKind::AssocConst, def_id) => {\n+                // Check if this constant is based on `cfg!(..)`,\n+                // which is NOT constant for our purposes.\n+                if let Some(node) = self.lcx.tcx.hir().get_if_local(def_id) &&\n+                let Node::Item(&Item {\n+                    kind: ItemKind::Const(_, body_id),\n+                    ..\n+                }) = node &&\n+                let Node::Expr(&Expr {\n+                    kind: ExprKind::Lit(_),\n+                    span,\n+                    ..\n+                }) = self.lcx.tcx.hir().get(body_id.hir_id) &&\n+                is_direct_expn_of(span, \"cfg\").is_some() {\n+                    return None;\n+                }\n+\n                 let substs = self.typeck_results.node_substs(id);\n                 let substs = if self.substs.is_empty() {\n                     substs"}, {"sha": "f4da625f1e306a0e083716316ede4a5f07ced8d7", "filename": "clippy_utils/src/hir_utils.rs", "status": "modified", "additions": 25, "deletions": 17, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_utils%2Fsrc%2Fhir_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_utils%2Fsrc%2Fhir_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fhir_utils.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -1,4 +1,4 @@\n-use crate::consts::{constant_context, constant_simple};\n+use crate::consts::constant_simple;\n use crate::source::snippet_opt;\n use rustc_ast::ast::InlineAsmTemplatePiece;\n use rustc_data_structures::fx::FxHasher;\n@@ -16,15 +16,14 @@ use rustc_span::Symbol;\n use std::hash::{Hash, Hasher};\n \n /// Type used to check whether two ast are the same. This is different from the\n-/// operator\n-/// `==` on ast types as this operator would compare true equality with ID and\n-/// span.\n+/// operator `==` on ast types as this operator would compare true equality with\n+/// ID and span.\n ///\n /// Note that some expressions kinds are not considered but could be added.\n pub struct SpanlessEq<'a, 'tcx> {\n     /// Context used to evaluate constant expressions.\n     cx: &'a LateContext<'tcx>,\n-    maybe_typeck_results: Option<&'tcx TypeckResults<'tcx>>,\n+    maybe_typeck_results: Option<(&'tcx TypeckResults<'tcx>, &'tcx TypeckResults<'tcx>)>,\n     allow_side_effects: bool,\n     expr_fallback: Option<Box<dyn FnMut(&Expr<'_>, &Expr<'_>) -> bool + 'a>>,\n }\n@@ -33,7 +32,7 @@ impl<'a, 'tcx> SpanlessEq<'a, 'tcx> {\n     pub fn new(cx: &'a LateContext<'tcx>) -> Self {\n         Self {\n             cx,\n-            maybe_typeck_results: cx.maybe_typeck_results(),\n+            maybe_typeck_results: cx.maybe_typeck_results().map(|x| (x, x)),\n             allow_side_effects: true,\n             expr_fallback: None,\n         }\n@@ -102,9 +101,9 @@ impl HirEqInterExpr<'_, '_, '_> {\n             (&StmtKind::Local(l), &StmtKind::Local(r)) => {\n                 // This additional check ensures that the type of the locals are equivalent even if the init\n                 // expression or type have some inferred parts.\n-                if let Some(typeck) = self.inner.maybe_typeck_results {\n-                    let l_ty = typeck.pat_ty(l.pat);\n-                    let r_ty = typeck.pat_ty(r.pat);\n+                if let Some((typeck_lhs, typeck_rhs)) = self.inner.maybe_typeck_results {\n+                    let l_ty = typeck_lhs.pat_ty(l.pat);\n+                    let r_ty = typeck_rhs.pat_ty(r.pat);\n                     if l_ty != r_ty {\n                         return false;\n                     }\n@@ -182,9 +181,17 @@ impl HirEqInterExpr<'_, '_, '_> {\n     }\n \n     pub fn eq_body(&mut self, left: BodyId, right: BodyId) -> bool {\n-        let cx = self.inner.cx;\n-        let eval_const = |body| constant_context(cx, cx.tcx.typeck_body(body)).expr(&cx.tcx.hir().body(body).value);\n-        eval_const(left) == eval_const(right)\n+        // swap out TypeckResults when hashing a body\n+        let old_maybe_typeck_results = self.inner.maybe_typeck_results.replace((\n+            self.inner.cx.tcx.typeck_body(left),\n+            self.inner.cx.tcx.typeck_body(right),\n+        ));\n+        let res = self.eq_expr(\n+            &self.inner.cx.tcx.hir().body(left).value,\n+            &self.inner.cx.tcx.hir().body(right).value,\n+        );\n+        self.inner.maybe_typeck_results = old_maybe_typeck_results;\n+        res\n     }\n \n     #[allow(clippy::similar_names)]\n@@ -193,10 +200,10 @@ impl HirEqInterExpr<'_, '_, '_> {\n             return false;\n         }\n \n-        if let Some(typeck_results) = self.inner.maybe_typeck_results {\n+        if let Some((typeck_lhs, typeck_rhs)) = self.inner.maybe_typeck_results {\n             if let (Some(l), Some(r)) = (\n-                constant_simple(self.inner.cx, typeck_results, left),\n-                constant_simple(self.inner.cx, typeck_results, right),\n+                constant_simple(self.inner.cx, typeck_lhs, left),\n+                constant_simple(self.inner.cx, typeck_rhs, right),\n             ) {\n                 if l == r {\n                     return true;\n@@ -674,8 +681,9 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n                                 self.hash_expr(out_expr);\n                             }\n                         },\n-                        InlineAsmOperand::Const { anon_const } => self.hash_body(anon_const.body),\n-                        InlineAsmOperand::SymFn { anon_const } => self.hash_body(anon_const.body),\n+                        InlineAsmOperand::Const { anon_const } | InlineAsmOperand::SymFn { anon_const } => {\n+                            self.hash_body(anon_const.body);\n+                        },\n                         InlineAsmOperand::SymStatic { path, def_id: _ } => self.hash_qpath(path),\n                     }\n                 }"}, {"sha": "a268e339bb130df99138102b739e6def1d44c640", "filename": "clippy_utils/src/macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_utils%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_utils%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fmacros.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -367,7 +367,7 @@ impl<'tcx> FormatArgsExpn<'tcx> {\n         expr_visitor_no_bodies(|e| {\n             // if we're still inside of the macro definition...\n             if e.span.ctxt() == expr.span.ctxt() {\n-                // ArgumnetV1::new_<format_trait>(<value>)\n+                // ArgumentV1::new_<format_trait>(<value>)\n                 if_chain! {\n                     if let ExprKind::Call(callee, [val]) = e.kind;\n                     if let ExprKind::Path(QPath::TypeRelative(ty, seg)) = callee.kind;"}, {"sha": "134fd1ce505a092b22022b6c840a8d722cffc2e7", "filename": "clippy_utils/src/msrvs.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_utils%2Fsrc%2Fmsrvs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_utils%2Fsrc%2Fmsrvs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fmsrvs.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -32,4 +32,5 @@ msrv_aliases! {\n     1,28,0 { FROM_BOOL }\n     1,17,0 { FIELD_INIT_SHORTHAND, STATIC_IN_CONST, EXPECT_ERR }\n     1,16,0 { STR_REPEAT }\n+    1,24,0 { IS_ASCII_DIGIT }\n }"}, {"sha": "b92d42e83232ce27501f77e0e904dbe301eca758", "filename": "clippy_utils/src/numeric_literal.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_utils%2Fsrc%2Fnumeric_literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_utils%2Fsrc%2Fnumeric_literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fnumeric_literal.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -57,7 +57,7 @@ impl<'a> NumericLiteral<'a> {\n                 .trim_start()\n                 .chars()\n                 .next()\n-                .map_or(false, |c| c.is_digit(10))\n+                .map_or(false, |c| c.is_ascii_digit())\n         {\n             let (unsuffixed, suffix) = split_suffix(src, lit_kind);\n             let float = matches!(lit_kind, LitKind::Float(..));"}, {"sha": "60971fb716dbdc69e364e137e032b2a5baab05cd", "filename": "clippy_utils/src/paths.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_utils%2Fsrc%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_utils%2Fsrc%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fpaths.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -61,6 +61,7 @@ pub const IO_READ: [&str; 3] = [\"std\", \"io\", \"Read\"];\n pub const IO_WRITE: [&str; 3] = [\"std\", \"io\", \"Write\"];\n pub const IPADDR_V4: [&str; 5] = [\"std\", \"net\", \"ip\", \"IpAddr\", \"V4\"];\n pub const IPADDR_V6: [&str; 5] = [\"std\", \"net\", \"ip\", \"IpAddr\", \"V6\"];\n+pub const ITER_COUNT: [&str; 6] = [\"core\", \"iter\", \"traits\", \"iterator\", \"Iterator\", \"count\"];\n pub const ITER_REPEAT: [&str; 5] = [\"core\", \"iter\", \"sources\", \"repeat\", \"repeat\"];\n #[allow(clippy::invalid_paths)] // internal lints do not know about all external crates\n pub const ITERTOOLS_NEXT_TUPLE: [&str; 3] = [\"itertools\", \"Itertools\", \"next_tuple\"];\n@@ -148,6 +149,8 @@ pub const CONVERT_IDENTITY: [&str; 3] = [\"core\", \"convert\", \"identity\"];\n pub const STD_FS_CREATE_DIR: [&str; 3] = [\"std\", \"fs\", \"create_dir\"];\n pub const STRING_AS_MUT_STR: [&str; 4] = [\"alloc\", \"string\", \"String\", \"as_mut_str\"];\n pub const STRING_AS_STR: [&str; 4] = [\"alloc\", \"string\", \"String\", \"as_str\"];\n+pub const STRING_NEW: [&str; 4] = [\"alloc\", \"string\", \"String\", \"new\"];\n+pub const STR_BYTES: [&str; 4] = [\"core\", \"str\", \"<impl str>\", \"bytes\"];\n pub const STR_ENDS_WITH: [&str; 4] = [\"core\", \"str\", \"<impl str>\", \"ends_with\"];\n pub const STR_FROM_UTF8: [&str; 4] = [\"core\", \"str\", \"converts\", \"from_utf8\"];\n pub const STR_LEN: [&str; 4] = [\"core\", \"str\", \"<impl str>\", \"len\"];"}, {"sha": "75808b1b17461d657f322903733e48fdf467fc2d", "filename": "clippy_utils/src/qualify_min_const_fn.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_utils%2Fsrc%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_utils%2Fsrc%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fqualify_min_const_fn.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -211,8 +211,9 @@ fn check_statement<'tcx>(\n \n         StatementKind::FakeRead(box (_, place)) => check_place(tcx, *place, span, body),\n         // just an assignment\n-        StatementKind::SetDiscriminant { place, .. } | StatementKind::Deinit(place) => \n-            check_place(tcx, **place, span, body),\n+        StatementKind::SetDiscriminant { place, .. } | StatementKind::Deinit(place) => {\n+            check_place(tcx, **place, span, body)\n+        },\n \n         StatementKind::CopyNonOverlapping(box rustc_middle::mir::CopyNonOverlapping { dst, src, count }) => {\n             check_operand(tcx, dst, span, body)?;"}, {"sha": "c69a3d8d2a15ec4d8883fd415ba94eff3496719a", "filename": "clippy_utils/src/source.rs", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_utils%2Fsrc%2Fsource.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_utils%2Fsrc%2Fsource.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fsource.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -7,9 +7,28 @@ use rustc_errors::Applicability;\n use rustc_hir::{Expr, ExprKind};\n use rustc_lint::{LateContext, LintContext};\n use rustc_span::hygiene;\n+use rustc_span::source_map::SourceMap;\n use rustc_span::{BytePos, Pos, Span, SyntaxContext};\n use std::borrow::Cow;\n \n+/// Checks if the span starts with the given text. This will return false if the span crosses\n+/// multiple files or if source is not available.\n+///\n+/// This is used to check for proc macros giving unhelpful spans to things.\n+pub fn span_starts_with<T: LintContext>(cx: &T, span: Span, text: &str) -> bool {\n+    fn helper(sm: &SourceMap, span: Span, text: &str) -> bool {\n+        let pos = sm.lookup_byte_offset(span.lo());\n+        let Some(ref src) = pos.sf.src else {\n+            return false;\n+        };\n+        let end = span.hi() - pos.sf.start_pos;\n+        src.get(pos.pos.0 as usize..end.0 as usize)\n+            // Expression spans can include wrapping parenthesis. Remove them first.\n+            .map_or(false, |s| s.trim_start_matches('(').starts_with(text))\n+    }\n+    helper(cx.sess().source_map(), span, text)\n+}\n+\n /// Like `snippet_block`, but add braces if the expr is not an `ExprKind::Block`.\n /// Also takes an `Option<String>` which can be put inside the braces.\n pub fn expr_block<'a, T: LintContext>(\n@@ -89,7 +108,7 @@ pub fn is_present_in_source<T: LintContext>(cx: &T, span: Span) -> bool {\n     true\n }\n \n-/// Returns the positon just before rarrow\n+/// Returns the position just before rarrow\n ///\n /// ```rust,ignore\n /// fn into(self) -> () {}"}, {"sha": "18915553e61c06cdc97ee45265f796215f617874", "filename": "clippy_utils/src/sugg.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_utils%2Fsrc%2Fsugg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_utils%2Fsrc%2Fsugg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fsugg.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -18,7 +18,7 @@ use rustc_span::source_map::{BytePos, CharPos, Pos, Span, SyntaxContext};\n use rustc_typeck::expr_use_visitor::{Delegate, ExprUseVisitor, PlaceBase, PlaceWithHirId};\n use std::borrow::Cow;\n use std::convert::TryInto;\n-use std::fmt::Display;\n+use std::fmt::{Display, Write as _};\n use std::iter;\n use std::ops::{Add, Neg, Not, Sub};\n \n@@ -902,7 +902,7 @@ impl<'tcx> Delegate<'tcx> for DerefDelegate<'_, 'tcx> {\n             if cmt.place.projections.is_empty() {\n                 // handle item without any projection, that needs an explicit borrowing\n                 // i.e.: suggest `&x` instead of `x`\n-                self.suggestion_start.push_str(&format!(\"{}&{}\", start_snip, ident_str));\n+                let _ = write!(self.suggestion_start, \"{}&{}\", start_snip, ident_str);\n             } else {\n                 // cases where a parent `Call` or `MethodCall` is using the item\n                 // i.e.: suggest `.contains(&x)` for `.find(|x| [1, 2, 3].contains(x)).is_none()`\n@@ -917,8 +917,7 @@ impl<'tcx> Delegate<'tcx> for DerefDelegate<'_, 'tcx> {\n                         // given expression is the self argument and will be handled completely by the compiler\n                         // i.e.: `|x| x.is_something()`\n                         ExprKind::MethodCall(_, [self_expr, ..], _) if self_expr.hir_id == cmt.hir_id => {\n-                            self.suggestion_start\n-                                .push_str(&format!(\"{}{}\", start_snip, ident_str_with_proj));\n+                            let _ = write!(self.suggestion_start, \"{}{}\", start_snip, ident_str_with_proj);\n                             self.next_pos = span.hi();\n                             return;\n                         },\n@@ -1026,8 +1025,7 @@ impl<'tcx> Delegate<'tcx> for DerefDelegate<'_, 'tcx> {\n                     }\n                 }\n \n-                self.suggestion_start\n-                    .push_str(&format!(\"{}{}\", start_snip, replacement_str));\n+                let _ = write!(self.suggestion_start, \"{}{}\", start_snip, replacement_str);\n             }\n             self.next_pos = span.hi();\n         }"}, {"sha": "901e3e5390c5dbbe9a4ac6d54a6adaaa0a737ec7", "filename": "clippy_utils/src/ty.rs", "status": "modified", "additions": 68, "deletions": 3, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fty.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -3,11 +3,11 @@\n #![allow(clippy::module_name_repetitions)]\n \n use rustc_ast::ast::Mutability;\n-use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_hir as hir;\n use rustc_hir::def::{CtorKind, DefKind, Res};\n use rustc_hir::def_id::DefId;\n-use rustc_hir::{Expr, TyKind, Unsafety};\n+use rustc_hir::{Expr, LangItem, TyKind, Unsafety};\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_lint::LateContext;\n use rustc_middle::mir::interpret::{ConstValue, Scalar};\n@@ -22,7 +22,7 @@ use rustc_trait_selection::infer::InferCtxtExt;\n use rustc_trait_selection::traits::query::normalize::AtExt;\n use std::iter;\n \n-use crate::{match_def_path, must_use_attr, path_res};\n+use crate::{match_def_path, must_use_attr, path_res, paths};\n \n // Checks if the given type implements copy.\n pub fn is_copy<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n@@ -83,6 +83,20 @@ pub fn get_associated_type<'tcx>(\n         })\n }\n \n+/// Get the diagnostic name of a type, e.g. `sym::HashMap`. To check if a type\n+/// implements a trait marked with a diagnostic item use [`implements_trait`].\n+///\n+/// For a further exploitation what diagnostic items are see [diagnostic items] in\n+/// rustc-dev-guide.\n+///\n+/// [Diagnostic Items]: https://rustc-dev-guide.rust-lang.org/diagnostics/diagnostic-items.html\n+pub fn get_type_diagnostic_name(cx: &LateContext<'_>, ty: Ty<'_>) -> Option<Symbol> {\n+    match ty.kind() {\n+        ty::Adt(adt, _) => cx.tcx.get_diagnostic_name(adt.did()),\n+        _ => None,\n+    }\n+}\n+\n /// Returns true if ty has `iter` or `iter_mut` methods\n pub fn has_iter_method(cx: &LateContext<'_>, probably_ref_ty: Ty<'_>) -> Option<Symbol> {\n     // FIXME: instead of this hard-coded list, we should check if `<adt>::iter`\n@@ -319,6 +333,57 @@ pub fn match_type(cx: &LateContext<'_>, ty: Ty<'_>, path: &[&str]) -> bool {\n     }\n }\n \n+/// Checks if the drop order for a type matters. Some std types implement drop solely to\n+/// deallocate memory. For these types, and composites containing them, changing the drop order\n+/// won't result in any observable side effects.\n+pub fn needs_ordered_drop<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n+    fn needs_ordered_drop_inner<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, seen: &mut FxHashSet<Ty<'tcx>>) -> bool {\n+        if !seen.insert(ty) {\n+            return false;\n+        }\n+        if !ty.has_significant_drop(cx.tcx, cx.param_env) {\n+            false\n+        }\n+        // Check for std types which implement drop, but only for memory allocation.\n+        else if is_type_lang_item(cx, ty, LangItem::OwnedBox)\n+            || matches!(\n+                get_type_diagnostic_name(cx, ty),\n+                Some(sym::HashSet | sym::Rc | sym::Arc | sym::cstring_type)\n+            )\n+            || match_type(cx, ty, &paths::WEAK_RC)\n+            || match_type(cx, ty, &paths::WEAK_ARC)\n+        {\n+            // Check all of the generic arguments.\n+            if let ty::Adt(_, subs) = ty.kind() {\n+                subs.types().any(|ty| needs_ordered_drop_inner(cx, ty, seen))\n+            } else {\n+                true\n+            }\n+        } else if !cx\n+            .tcx\n+            .lang_items()\n+            .drop_trait()\n+            .map_or(false, |id| implements_trait(cx, ty, id, &[]))\n+        {\n+            // This type doesn't implement drop, so no side effects here.\n+            // Check if any component type has any.\n+            match ty.kind() {\n+                ty::Tuple(fields) => fields.iter().any(|ty| needs_ordered_drop_inner(cx, ty, seen)),\n+                ty::Array(ty, _) => needs_ordered_drop_inner(cx, *ty, seen),\n+                ty::Adt(adt, subs) => adt\n+                    .all_fields()\n+                    .map(|f| f.ty(cx.tcx, subs))\n+                    .any(|ty| needs_ordered_drop_inner(cx, ty, seen)),\n+                _ => true,\n+            }\n+        } else {\n+            true\n+        }\n+    }\n+\n+    needs_ordered_drop_inner(cx, ty, &mut FxHashSet::default())\n+}\n+\n /// Peels off all references on the type. Returns the underlying type and the number of references\n /// removed.\n pub fn peel_mid_ty_refs(ty: Ty<'_>) -> (Ty<'_>, usize) {"}, {"sha": "4236e3aae2fbde4f811106b27547ba1f8276648b", "filename": "clippy_utils/src/usage.rs", "status": "modified", "additions": 31, "deletions": 2, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_utils%2Fsrc%2Fusage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_utils%2Fsrc%2Fusage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fusage.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -3,7 +3,7 @@ use crate::visitors::{expr_visitor, expr_visitor_no_bodies};\n use rustc_hir as hir;\n use rustc_hir::intravisit::{self, Visitor};\n use rustc_hir::HirIdSet;\n-use rustc_hir::{Expr, ExprKind, HirId};\n+use rustc_hir::{Expr, ExprKind, HirId, Node};\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_lint::LateContext;\n use rustc_middle::hir::nested_filter;\n@@ -169,6 +169,32 @@ pub fn contains_return_break_continue_macro(expression: &Expr<'_>) -> bool {\n \n pub fn local_used_after_expr(cx: &LateContext<'_>, local_id: HirId, after: &Expr<'_>) -> bool {\n     let Some(block) = utils::get_enclosing_block(cx, local_id) else { return false };\n+\n+    // for _ in 1..3 {\n+    //    local\n+    // }\n+    //\n+    // let closure = || local;\n+    // closure();\n+    // closure();\n+    let in_loop_or_closure = cx\n+        .tcx\n+        .hir()\n+        .parent_iter(after.hir_id)\n+        .take_while(|&(id, _)| id != block.hir_id)\n+        .any(|(_, node)| {\n+            matches!(\n+                node,\n+                Node::Expr(Expr {\n+                    kind: ExprKind::Loop(..) | ExprKind::Closure(..),\n+                    ..\n+                })\n+            )\n+        });\n+    if in_loop_or_closure {\n+        return true;\n+    }\n+\n     let mut used_after_expr = false;\n     let mut past_expr = false;\n     expr_visitor(cx, |expr| {\n@@ -178,7 +204,10 @@ pub fn local_used_after_expr(cx: &LateContext<'_>, local_id: HirId, after: &Expr\n \n         if expr.hir_id == after.hir_id {\n             past_expr = true;\n-        } else if past_expr && utils::path_to_local_id(expr, local_id) {\n+            return false;\n+        }\n+\n+        if past_expr && utils::path_to_local_id(expr, local_id) {\n             used_after_expr = true;\n         }\n         !used_after_expr"}, {"sha": "c00bc2bd213f9a4fd3c8469fe16f0273167b1191", "filename": "clippy_utils/src/visitors.rs", "status": "modified", "additions": 67, "deletions": 1, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_utils%2Fsrc%2Fvisitors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/clippy_utils%2Fsrc%2Fvisitors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fvisitors.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -1,9 +1,11 @@\n use crate::path_to_local_id;\n+use core::ops::ControlFlow;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::intravisit::{self, walk_block, walk_expr, Visitor};\n use rustc_hir::{\n-    Arm, Block, BlockCheckMode, Body, BodyId, Expr, ExprKind, HirId, ItemId, ItemKind, Stmt, UnOp, Unsafety,\n+    Arm, Block, BlockCheckMode, Body, BodyId, Expr, ExprKind, HirId, ItemId, ItemKind, Stmt, UnOp, UnsafeSource,\n+    Unsafety,\n };\n use rustc_lint::LateContext;\n use rustc_middle::hir::map::Map;\n@@ -370,3 +372,67 @@ pub fn is_expr_unsafe<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>) -> bool {\n     v.visit_expr(e);\n     v.is_unsafe\n }\n+\n+/// Checks if the given expression contains an unsafe block\n+pub fn contains_unsafe_block<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'tcx>) -> bool {\n+    struct V<'cx, 'tcx> {\n+        cx: &'cx LateContext<'tcx>,\n+        found_unsafe: bool,\n+    }\n+    impl<'tcx> Visitor<'tcx> for V<'_, 'tcx> {\n+        type NestedFilter = nested_filter::OnlyBodies;\n+        fn nested_visit_map(&mut self) -> Self::Map {\n+            self.cx.tcx.hir()\n+        }\n+\n+        fn visit_block(&mut self, b: &'tcx Block<'_>) {\n+            if self.found_unsafe {\n+                return;\n+            }\n+            if b.rules == BlockCheckMode::UnsafeBlock(UnsafeSource::UserProvided) {\n+                self.found_unsafe = true;\n+                return;\n+            }\n+            walk_block(self, b);\n+        }\n+    }\n+    let mut v = V {\n+        cx,\n+        found_unsafe: false,\n+    };\n+    v.visit_expr(e);\n+    v.found_unsafe\n+}\n+\n+/// Runs the given function for each sub-expression producing the final value consumed by the parent\n+/// of the give expression.\n+///\n+/// e.g. for the following expression\n+/// ```rust,ignore\n+/// if foo {\n+///     f(0)\n+/// } else {\n+///     1 + 1\n+/// }\n+/// ```\n+/// this will pass both `f(0)` and `1+1` to the given function.\n+pub fn for_each_value_source<'tcx, B>(\n+    e: &'tcx Expr<'tcx>,\n+    f: &mut impl FnMut(&'tcx Expr<'tcx>) -> ControlFlow<B>,\n+) -> ControlFlow<B> {\n+    match e.kind {\n+        ExprKind::Block(Block { expr: Some(e), .. }, _) => for_each_value_source(e, f),\n+        ExprKind::Match(_, arms, _) => {\n+            for arm in arms {\n+                for_each_value_source(arm.body, f)?;\n+            }\n+            ControlFlow::Continue(())\n+        },\n+        ExprKind::If(_, if_expr, Some(else_expr)) => {\n+            for_each_value_source(if_expr, f)?;\n+            for_each_value_source(else_expr, f)\n+        },\n+        ExprKind::DropTemps(e) => for_each_value_source(e, f),\n+        _ => f(e),\n+    }\n+}"}, {"sha": "307cf2f3a9047896fd3912c029e95745c0b29ff2", "filename": "doc/adding_lints.md", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/doc%2Fadding_lints.md", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/doc%2Fadding_lints.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fadding_lints.md?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -22,6 +22,7 @@ because that's clearly a non-descriptive name.\n   - [Adding the lint logic](#adding-the-lint-logic)\n   - [Specifying the lint's minimum supported Rust version (MSRV)](#specifying-the-lints-minimum-supported-rust-version-msrv)\n   - [Author lint](#author-lint)\n+  - [Print HIR lint](#print-hir-lint)\n   - [Documentation](#documentation)\n   - [Running rustfmt](#running-rustfmt)\n   - [Debugging](#debugging)\n@@ -484,6 +485,19 @@ you are implementing your lint.\n \n [author_example]: https://play.rust-lang.org/?version=nightly&mode=debug&edition=2018&gist=9a12cb60e5c6ad4e3003ac6d5e63cf55\n \n+## Print HIR lint\n+\n+To implement a lint, it's helpful to first understand the internal representation\n+that rustc uses. Clippy has the `#[clippy::dump]` attribute that prints the\n+[_High-Level Intermediate Representation (HIR)_] of the item, statement, or \n+expression that the attribute is attached to. To attach the attribute to expressions\n+you often need to enable `#![feature(stmt_expr_attributes)]`.\n+\n+[Here][print_hir_example] you can find an example, just select _Tools_ and run _Clippy_.\n+\n+[_High-Level Intermediate Representation (HIR)_]: https://rustc-dev-guide.rust-lang.org/hir.html\n+[print_hir_example]: https://play.rust-lang.org/?version=nightly&mode=debug&edition=2021&gist=daf14db3a7f39ca467cd1b86c34b9afb\n+\n ## Documentation\n \n The final thing before submitting our PR is to add some documentation to our"}, {"sha": "816efbdaedf36d770aab843378175781f4274fb6", "filename": "lintcheck/src/main.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/lintcheck%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/lintcheck%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/lintcheck%2Fsrc%2Fmain.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -8,6 +8,7 @@\n #![allow(clippy::collapsible_else_if)]\n \n use std::ffi::OsStr;\n+use std::fmt::Write as _;\n use std::process::Command;\n use std::sync::atomic::{AtomicUsize, Ordering};\n use std::{collections::HashMap, io::ErrorKind};\n@@ -110,11 +111,12 @@ impl ClippyWarning {\n             let lint = format!(\"`{}`\", self.linttype);\n \n             let mut output = String::from(\"| \");\n-            output.push_str(&format!(\n+            let _ = write!(\n+                output,\n                 \"[`{}`](../target/lintcheck/sources/{}#L{})\",\n                 file_with_pos, file, self.line\n-            ));\n-            output.push_str(&format!(r#\" | {:<50} | \"{}\" |\"#, lint, self.message));\n+            );\n+            let _ = write!(output, r#\" | {:<50} | \"{}\" |\"#, lint, self.message);\n             output.push('\\n');\n             output\n         } else {\n@@ -304,7 +306,7 @@ impl Crate {\n         let shared_target_dir = clippy_project_root().join(\"target/lintcheck/shared_target_dir\");\n \n         let mut args = if fix {\n-            vec![\"--fix\", \"--allow-no-vcs\", \"--\"]\n+            vec![\"--fix\", \"--\"]\n         } else {\n             vec![\"--\", \"--message-format=json\", \"--\"]\n         };\n@@ -391,7 +393,7 @@ struct LintcheckConfig {\n     lintcheck_results_path: PathBuf,\n     /// whether to just run --fix and not collect all the warnings\n     fix: bool,\n-    /// A list of lint that this lintcheck run shound focus on\n+    /// A list of lints that this lintcheck run should focus on\n     lint_filter: Vec<String>,\n     /// Indicate if the output should support markdown syntax\n     markdown: bool,\n@@ -835,10 +837,11 @@ pub fn main() {\n         text.push_str(\"| file | lint | message |\\n\");\n         text.push_str(\"| --- | --- | --- |\\n\");\n     }\n-    text.push_str(&format!(\"{}\", all_msgs.join(\"\")));\n+    write!(text, \"{}\", all_msgs.join(\"\"));\n     text.push_str(\"\\n\\n### ICEs:\\n\");\n-    ices.iter()\n-        .for_each(|(cratename, msg)| text.push_str(&format!(\"{}: '{}'\", cratename, msg)));\n+    for (cratename, msg) in ices.iter() {\n+        let _ = write!(text, \"{}: '{}'\", cratename, msg);\n+    }\n \n     println!(\"Writing logs to {}\", config.lintcheck_results_path.display());\n     std::fs::create_dir_all(config.lintcheck_results_path.parent().unwrap()).unwrap();"}, {"sha": "03acb51306d7a92081b181f66bbb964bbca66a76", "filename": "rust-toolchain", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/rust-toolchain", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/rust-toolchain", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rust-toolchain?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -1,3 +1,3 @@\n [toolchain]\n-channel = \"nightly-2022-04-07\"\n+channel = \"nightly-2022-05-05\"\n components = [\"cargo\", \"llvm-tools-preview\", \"rust-src\", \"rust-std\", \"rustc\", \"rustc-dev\", \"rustfmt\"]"}, {"sha": "7de40fe63ac23a4559051c6f14c26b34ad4c067a", "filename": "src/driver.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/src%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/src%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdriver.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -165,8 +165,7 @@ fn report_clippy_ice(info: &panic::PanicInfo<'_>, bug_report_url: &str) {\n     // Separate the output with an empty line\n     eprintln!();\n \n-    let fallback_bundle =\n-        rustc_errors::fallback_fluent_bundle(rustc_errors::DEFAULT_LOCALE_RESOURCES, false);\n+    let fallback_bundle = rustc_errors::fallback_fluent_bundle(rustc_errors::DEFAULT_LOCALE_RESOURCES, false);\n     let emitter = Box::new(rustc_errors::emitter::EmitterWriter::stderr(\n         rustc_errors::ColorConfig::Auto,\n         None,"}, {"sha": "eb97d1933d5d71bdd8621993e7cd6a50538d982d", "filename": "tests/dogfood.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fdogfood.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fdogfood.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fdogfood.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -80,9 +80,13 @@ fn run_clippy_for_package(project: &str) {\n         .args(&[\"-D\", \"clippy::pedantic\"])\n         .arg(\"-Cdebuginfo=0\"); // disable debuginfo to generate less data in the target dir\n \n-    // internal lints only exist if we build with the internal feature\n     if cfg!(feature = \"internal\") {\n+        // internal lints only exist if we build with the internal feature\n         command.args(&[\"-D\", \"clippy::internal\"]);\n+    } else {\n+        // running a clippy built without internal lints on the clippy source\n+        // that contains e.g. `allow(clippy::invalid_paths)`\n+        command.args(&[\"-A\", \"unknown_lints\"]);\n     }\n \n     let output = command.output().unwrap();"}, {"sha": "dd1d441203600cf6f3d124177a4ef29f1ea0d67c", "filename": "tests/lint_message_convention.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Flint_message_convention.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Flint_message_convention.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Flint_message_convention.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -66,7 +66,7 @@ fn lint_message_convention() {\n \n     // make sure that lint messages:\n     // * are not capitalized\n-    // * don't have puncuation at the end of the last sentence\n+    // * don't have punctuation at the end of the last sentence\n \n     // these directories have interesting tests\n     let test_dirs = [\"ui\", \"ui-cargo\", \"ui-internal\", \"ui-toml\"]"}, {"sha": "0852fe65aafd0241e2938cef70a1cdee20964720", "filename": "tests/ui-internal/collapsible_span_lint_calls.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui-internal%2Fcollapsible_span_lint_calls.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui-internal%2Fcollapsible_span_lint_calls.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-internal%2Fcollapsible_span_lint_calls.stderr?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -29,15 +29,15 @@ LL | |             db.help(help_msg);\n LL | |         });\n    | |__________^ help: collapse into: `span_lint_and_help(cx, TEST_LINT, expr.span, lint_msg, None, help_msg)`\n \n-error: this call is collspible\n+error: this call is collapsible\n   --> $DIR/collapsible_span_lint_calls.rs:45:9\n    |\n LL | /         span_lint_and_then(cx, TEST_LINT, expr.span, lint_msg, |db| {\n LL | |             db.span_note(expr.span, note_msg);\n LL | |         });\n    | |__________^ help: collapse into: `span_lint_and_note(cx, TEST_LINT, expr.span, lint_msg, Some(expr.span), note_msg)`\n \n-error: this call is collspible\n+error: this call is collapsible\n   --> $DIR/collapsible_span_lint_calls.rs:48:9\n    |\n LL | /         span_lint_and_then(cx, TEST_LINT, expr.span, lint_msg, |db| {"}, {"sha": "eaea218e128886373d6c4ebc82fe5e377a831ce8", "filename": "tests/ui-internal/interning_defined_symbol.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui-internal%2Finterning_defined_symbol.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui-internal%2Finterning_defined_symbol.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-internal%2Finterning_defined_symbol.fixed?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -1,6 +1,6 @@\n // run-rustfix\n #![deny(clippy::internal)]\n-#![allow(clippy::missing_clippy_version_attribute)]\n+#![allow(clippy::missing_clippy_version_attribute, clippy::let_unit_value)]\n #![feature(rustc_private)]\n \n extern crate rustc_span;"}, {"sha": "7efebb8fae486f456a3ade83ac5c510acb81fdc4", "filename": "tests/ui-internal/interning_defined_symbol.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui-internal%2Finterning_defined_symbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui-internal%2Finterning_defined_symbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-internal%2Finterning_defined_symbol.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -1,6 +1,6 @@\n // run-rustfix\n #![deny(clippy::internal)]\n-#![allow(clippy::missing_clippy_version_attribute)]\n+#![allow(clippy::missing_clippy_version_attribute, clippy::let_unit_value)]\n #![feature(rustc_private)]\n \n extern crate rustc_span;"}, {"sha": "fbef5c4564b1bb6444016ec07b0ca11ca91bb5c6", "filename": "tests/ui-toml/await_holding_invalid_type/await_holding_invalid_type.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui-toml%2Fawait_holding_invalid_type%2Fawait_holding_invalid_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui-toml%2Fawait_holding_invalid_type%2Fawait_holding_invalid_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-toml%2Fawait_holding_invalid_type%2Fawait_holding_invalid_type.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -0,0 +1,41 @@\n+#![warn(clippy::await_holding_invalid_type)]\n+use std::net::Ipv4Addr;\n+\n+async fn bad() -> u32 {\n+    let _x = String::from(\"hello\");\n+    baz().await\n+}\n+\n+async fn bad_reason() -> u32 {\n+    let _x = Ipv4Addr::new(127, 0, 0, 1);\n+    baz().await\n+}\n+\n+async fn good() -> u32 {\n+    {\n+        let _x = String::from(\"hi!\");\n+        let _y = Ipv4Addr::new(127, 0, 0, 1);\n+    }\n+    baz().await;\n+    let _x = String::from(\"hi!\");\n+    47\n+}\n+\n+async fn baz() -> u32 {\n+    42\n+}\n+\n+#[allow(clippy::manual_async_fn)]\n+fn block_bad() -> impl std::future::Future<Output = u32> {\n+    async move {\n+        let _x = String::from(\"hi!\");\n+        baz().await\n+    }\n+}\n+\n+fn main() {\n+    good();\n+    bad();\n+    bad_reason();\n+    block_bad();\n+}"}, {"sha": "62c45b54634f4298060b729a3674e9d2bfe1468a", "filename": "tests/ui-toml/await_holding_invalid_type/await_holding_invalid_type.stderr", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui-toml%2Fawait_holding_invalid_type%2Fawait_holding_invalid_type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui-toml%2Fawait_holding_invalid_type%2Fawait_holding_invalid_type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-toml%2Fawait_holding_invalid_type%2Fawait_holding_invalid_type.stderr?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -0,0 +1,25 @@\n+error: `std::string::String` may not be held across an `await` point per `clippy.toml`\n+  --> $DIR/await_holding_invalid_type.rs:5:9\n+   |\n+LL |     let _x = String::from(\"hello\");\n+   |         ^^\n+   |\n+   = note: `-D clippy::await-holding-invalid-type` implied by `-D warnings`\n+   = note: strings are bad\n+\n+error: `std::net::Ipv4Addr` may not be held across an `await` point per `clippy.toml`\n+  --> $DIR/await_holding_invalid_type.rs:10:9\n+   |\n+LL |     let _x = Ipv4Addr::new(127, 0, 0, 1);\n+   |         ^^\n+\n+error: `std::string::String` may not be held across an `await` point per `clippy.toml`\n+  --> $DIR/await_holding_invalid_type.rs:31:13\n+   |\n+LL |         let _x = String::from(\"hi!\");\n+   |             ^^\n+   |\n+   = note: strings are bad\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "79990096b84e0947281b3714c1142f03b33841bf", "filename": "tests/ui-toml/await_holding_invalid_type/clippy.toml", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui-toml%2Fawait_holding_invalid_type%2Fclippy.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui-toml%2Fawait_holding_invalid_type%2Fclippy.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-toml%2Fawait_holding_invalid_type%2Fclippy.toml?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -0,0 +1,4 @@\n+await-holding-invalid-types = [\n+    { path = \"std::string::String\", reason = \"strings are bad\" },\n+    \"std::net::Ipv4Addr\",\n+]"}, {"sha": "4ac0378544c7d724ac4f49e28a7168791e21044a", "filename": "tests/ui-toml/functions_maxlines/test.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui-toml%2Ffunctions_maxlines%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui-toml%2Ffunctions_maxlines%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-toml%2Ffunctions_maxlines%2Ftest.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -1,4 +1,5 @@\n #![warn(clippy::too_many_lines)]\n+#![allow(clippy::let_unit_value)]\n \n // This function should be considered one line.\n fn many_comments_but_one_line_of_code() {"}, {"sha": "dc255bdcabafea568c725c28f65b79074ec024a4", "filename": "tests/ui-toml/functions_maxlines/test.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui-toml%2Ffunctions_maxlines%2Ftest.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui-toml%2Ffunctions_maxlines%2Ftest.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-toml%2Ffunctions_maxlines%2Ftest.stderr?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -1,5 +1,5 @@\n error: this function has too many lines (2/1)\n-  --> $DIR/test.rs:18:1\n+  --> $DIR/test.rs:19:1\n    |\n LL | / fn too_many_lines() {\n LL | |     println!(\"This is bad.\");\n@@ -10,7 +10,7 @@ LL | | }\n    = note: `-D clippy::too-many-lines` implied by `-D warnings`\n \n error: this function has too many lines (4/1)\n-  --> $DIR/test.rs:24:1\n+  --> $DIR/test.rs:25:1\n    |\n LL | / async fn async_too_many_lines() {\n LL | |     println!(\"This is bad.\");\n@@ -19,7 +19,7 @@ LL | | }\n    | |_^\n \n error: this function has too many lines (4/1)\n-  --> $DIR/test.rs:30:1\n+  --> $DIR/test.rs:31:1\n    |\n LL | / fn closure_too_many_lines() {\n LL | |     let _ = {\n@@ -30,7 +30,7 @@ LL | | }\n    | |_^\n \n error: this function has too many lines (2/1)\n-  --> $DIR/test.rs:52:1\n+  --> $DIR/test.rs:53:1\n    |\n LL | / fn comment_before_code() {\n LL | |     let _ = \"test\";"}, {"sha": "ea34bf9fbe01d2d9391064b919ef9142a8c36396", "filename": "tests/ui-toml/large_include_file/clippy.toml", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui-toml%2Flarge_include_file%2Fclippy.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui-toml%2Flarge_include_file%2Fclippy.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-toml%2Flarge_include_file%2Fclippy.toml?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -0,0 +1 @@\n+max-include-file-size = 600"}, {"sha": "f3dbb6ad1cf59a4d4aa385ab5365aef2d9dc9ac2", "filename": "tests/ui-toml/large_include_file/large_include_file.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui-toml%2Flarge_include_file%2Flarge_include_file.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui-toml%2Flarge_include_file%2Flarge_include_file.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-toml%2Flarge_include_file%2Flarge_include_file.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -0,0 +1,16 @@\n+#![warn(clippy::large_include_file)]\n+\n+// Good\n+const GOOD_INCLUDE_BYTES: &[u8; 581] = include_bytes!(\"large_include_file.rs\");\n+const GOOD_INCLUDE_STR: &str = include_str!(\"large_include_file.rs\");\n+\n+#[allow(clippy::large_include_file)]\n+const ALLOWED_TOO_BIG_INCLUDE_BYTES: &[u8; 654] = include_bytes!(\"too_big.txt\");\n+#[allow(clippy::large_include_file)]\n+const ALLOWED_TOO_BIG_INCLUDE_STR: &str = include_str!(\"too_big.txt\");\n+\n+// Bad\n+const TOO_BIG_INCLUDE_BYTES: &[u8; 654] = include_bytes!(\"too_big.txt\");\n+const TOO_BIG_INCLUDE_STR: &str = include_str!(\"too_big.txt\");\n+\n+fn main() {}"}, {"sha": "6a685a58318b9b16d0b6d4189f2bae64eae86216", "filename": "tests/ui-toml/large_include_file/large_include_file.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui-toml%2Flarge_include_file%2Flarge_include_file.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui-toml%2Flarge_include_file%2Flarge_include_file.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-toml%2Flarge_include_file%2Flarge_include_file.stderr?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -0,0 +1,21 @@\n+error: attempted to include a large file\n+  --> $DIR/large_include_file.rs:13:43\n+   |\n+LL | const TOO_BIG_INCLUDE_BYTES: &[u8; 654] = include_bytes!(\"too_big.txt\");\n+   |                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `-D clippy::large-include-file` implied by `-D warnings`\n+   = note: the configuration allows a maximum size of 600 bytes\n+   = note: this error originates in the macro `include_bytes` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: attempted to include a large file\n+  --> $DIR/large_include_file.rs:14:35\n+   |\n+LL | const TOO_BIG_INCLUDE_STR: &str = include_str!(\"too_big.txt\");\n+   |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: the configuration allows a maximum size of 600 bytes\n+   = note: this error originates in the macro `include_str` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "9829c46bc00f63cc6a1dedc8677cb754f2d39b71", "filename": "tests/ui-toml/large_include_file/too_big.txt", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui-toml%2Flarge_include_file%2Ftoo_big.txt", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui-toml%2Flarge_include_file%2Ftoo_big.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-toml%2Flarge_include_file%2Ftoo_big.txt?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -0,0 +1 @@\n+Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Maecenas accumsan lacus vel facilisis volutpat. Etiam dignissim diam quis enim lobortis scelerisque fermentum dui faucibus. Tellus id interdum velit laoreet id donec ultrices. Est ultricies integer quis auctor elit sed vulputate. Erat velit scelerisque in dictum non consectetur a erat nam. Sed blandit libero volutpat sed. Tortor condimentum lacinia quis vel eros. Enim ut tellus elementum sagittis vitae et leo duis. Congue mauris rhoncus aenean vel elit scelerisque. Id consectetur purus ut faucibus pulvinar elementum integer.\n\\ No newline at end of file"}, {"sha": "5dae5af7eb5a9cc9413582d37256b2869abd32c8", "filename": "tests/ui-toml/min_rust_version/min_rust_version.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui-toml%2Fmin_rust_version%2Fmin_rust_version.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui-toml%2Fmin_rust_version%2Fmin_rust_version.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-toml%2Fmin_rust_version%2Fmin_rust_version.stderr?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -1,4 +1,4 @@\n-error: you are using an explicit closure for copying elements\n+error: you are using an explicit closure for cloning elements\n   --> $DIR/min_rust_version.rs:74:26\n    |\n LL |     let _: Option<u64> = Some(&16).map(|b| *b);"}, {"sha": "8701809b4daaaa8901bafbfc9479ac4874244899", "filename": "tests/ui-toml/toml_unknown_key/conf_unknown_key.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui-toml%2Ftoml_unknown_key%2Fconf_unknown_key.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui-toml%2Ftoml_unknown_key%2Fconf_unknown_key.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-toml%2Ftoml_unknown_key%2Fconf_unknown_key.stderr?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -1,4 +1,4 @@\n-error: error reading Clippy's configuration file `$DIR/clippy.toml`: unknown field `foobar`, expected one of `avoid-breaking-exported-api`, `msrv`, `blacklisted-names`, `cognitive-complexity-threshold`, `cyclomatic-complexity-threshold`, `doc-valid-idents`, `too-many-arguments-threshold`, `type-complexity-threshold`, `single-char-binding-names-threshold`, `too-large-for-stack`, `enum-variant-name-threshold`, `enum-variant-size-threshold`, `verbose-bit-mask-threshold`, `literal-representation-threshold`, `trivial-copy-size-limit`, `pass-by-value-size-limit`, `too-many-lines-threshold`, `array-size-threshold`, `vec-box-size-threshold`, `max-trait-bounds`, `max-struct-bools`, `max-fn-params-bools`, `warn-on-all-wildcard-imports`, `disallowed-methods`, `disallowed-types`, `unreadable-literal-lint-fractions`, `upper-case-acronyms-aggressive`, `cargo-ignore-publish`, `standard-macro-braces`, `enforced-import-renames`, `allowed-scripts`, `enable-raw-pointer-heuristic-for-send`, `max-suggested-slice-pattern-length`, `third-party` at line 5 column 1\n+error: error reading Clippy's configuration file `$DIR/clippy.toml`: unknown field `foobar`, expected one of `avoid-breaking-exported-api`, `msrv`, `blacklisted-names`, `cognitive-complexity-threshold`, `cyclomatic-complexity-threshold`, `doc-valid-idents`, `too-many-arguments-threshold`, `type-complexity-threshold`, `single-char-binding-names-threshold`, `too-large-for-stack`, `enum-variant-name-threshold`, `enum-variant-size-threshold`, `verbose-bit-mask-threshold`, `literal-representation-threshold`, `trivial-copy-size-limit`, `pass-by-value-size-limit`, `too-many-lines-threshold`, `array-size-threshold`, `vec-box-size-threshold`, `max-trait-bounds`, `max-struct-bools`, `max-fn-params-bools`, `warn-on-all-wildcard-imports`, `disallowed-methods`, `disallowed-types`, `unreadable-literal-lint-fractions`, `upper-case-acronyms-aggressive`, `cargo-ignore-publish`, `standard-macro-braces`, `enforced-import-renames`, `allowed-scripts`, `enable-raw-pointer-heuristic-for-send`, `max-suggested-slice-pattern-length`, `await-holding-invalid-types`, `max-include-file-size`, `third-party` at line 5 column 1\n \n error: aborting due to previous error\n "}, {"sha": "7bea9563d47d3d1f34b81de73794aea329f10520", "filename": "tests/ui/assertions_on_constants.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fassertions_on_constants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fassertions_on_constants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassertions_on_constants.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -1,4 +1,4 @@\n-#![allow(non_fmt_panics)]\n+#![allow(non_fmt_panics, clippy::needless_bool)]\n \n macro_rules! assert_const {\n     ($len:expr) => {\n@@ -28,6 +28,12 @@ fn main() {\n     assert_const!(3);\n     assert_const!(-1);\n \n-    // Don't lint on this:\n+    // Don't lint if based on `cfg!(..)`:\n     assert!(cfg!(feature = \"hey\") || cfg!(not(feature = \"asdf\")));\n+\n+    let flag: bool = cfg!(not(feature = \"asdf\"));\n+    assert!(flag);\n+\n+    const CFG_FLAG: &bool = &cfg!(feature = \"hey\");\n+    assert!(!CFG_FLAG);\n }"}, {"sha": "ed7b17651e675e8942bceb5867087398b282eff2", "filename": "tests/ui/auxiliary/proc_macro_derive.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fauxiliary%2Fproc_macro_derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fauxiliary%2Fproc_macro_derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fauxiliary%2Fproc_macro_derive.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -13,7 +13,7 @@ use proc_macro::{quote, TokenStream};\n \n #[proc_macro_derive(DeriveSomething)]\n pub fn derive(_: TokenStream) -> TokenStream {\n-    // Shound not trigger `used_underscore_binding`\n+    // Should not trigger `used_underscore_binding`\n     let _inside_derive = 1;\n     assert_eq!(_inside_derive, _inside_derive);\n "}, {"sha": "8ea631f2bbd420fd20795fde30cf81e1bd939d80", "filename": "tests/ui/auxiliary/proc_macro_with_span.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fauxiliary%2Fproc_macro_with_span.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fauxiliary%2Fproc_macro_with_span.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fauxiliary%2Fproc_macro_with_span.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -0,0 +1,32 @@\n+// compile-flags: --emit=link\n+// no-prefer-dynamic\n+\n+#![crate_type = \"proc-macro\"]\n+\n+extern crate proc_macro;\n+\n+use proc_macro::{token_stream::IntoIter, Group, Span, TokenStream, TokenTree};\n+\n+#[proc_macro]\n+pub fn with_span(input: TokenStream) -> TokenStream {\n+    let mut iter = input.into_iter();\n+    let span = iter.next().unwrap().span();\n+    let mut res = TokenStream::new();\n+    write_with_span(span, iter, &mut res);\n+    res\n+}\n+\n+fn write_with_span(s: Span, input: IntoIter, out: &mut TokenStream) {\n+    for mut tt in input {\n+        if let TokenTree::Group(g) = tt {\n+            let mut stream = TokenStream::new();\n+            write_with_span(s, g.stream().into_iter(), &mut stream);\n+            let mut group = Group::new(g.delimiter(), stream);\n+            group.set_span(s);\n+            out.extend([TokenTree::Group(group)]);\n+        } else {\n+            tt.set_span(s);\n+            out.extend([tt]);\n+        }\n+    }\n+}"}, {"sha": "860642363b5f0ecf370379dc2ee071b58a66e72a", "filename": "tests/ui/bytes_count_to_len.fixed", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fbytes_count_to_len.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fbytes_count_to_len.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fbytes_count_to_len.fixed?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -0,0 +1,34 @@\n+// run-rustfix\n+#![warn(clippy::bytes_count_to_len)]\n+use std::fs::File;\n+use std::io::Read;\n+\n+fn main() {\n+    // should fix, because type is String\n+    let _ = String::from(\"foo\").len();\n+\n+    let s1 = String::from(\"foo\");\n+    let _ = s1.len();\n+\n+    // should fix, because type is &str\n+    let _ = \"foo\".len();\n+\n+    let s2 = \"foo\";\n+    let _ = s2.len();\n+\n+    // make sure using count() normally doesn't trigger warning\n+    let vector = [0, 1, 2];\n+    let _ = vector.iter().count();\n+\n+    // The type is slice, so should not fix\n+    let _ = &[1, 2, 3].bytes().count();\n+\n+    let bytes: &[u8] = &[1, 2, 3];\n+    bytes.bytes().count();\n+\n+    // The type is File, so should not fix\n+    let _ = File::open(\"foobar\").unwrap().bytes().count();\n+\n+    let f = File::open(\"foobar\").unwrap();\n+    let _ = f.bytes().count();\n+}"}, {"sha": "162730c2842a1615db2b1fe1cbb5e68d369737a7", "filename": "tests/ui/bytes_count_to_len.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fbytes_count_to_len.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fbytes_count_to_len.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fbytes_count_to_len.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -0,0 +1,34 @@\n+// run-rustfix\n+#![warn(clippy::bytes_count_to_len)]\n+use std::fs::File;\n+use std::io::Read;\n+\n+fn main() {\n+    // should fix, because type is String\n+    let _ = String::from(\"foo\").bytes().count();\n+\n+    let s1 = String::from(\"foo\");\n+    let _ = s1.bytes().count();\n+\n+    // should fix, because type is &str\n+    let _ = \"foo\".bytes().count();\n+\n+    let s2 = \"foo\";\n+    let _ = s2.bytes().count();\n+\n+    // make sure using count() normally doesn't trigger warning\n+    let vector = [0, 1, 2];\n+    let _ = vector.iter().count();\n+\n+    // The type is slice, so should not fix\n+    let _ = &[1, 2, 3].bytes().count();\n+\n+    let bytes: &[u8] = &[1, 2, 3];\n+    bytes.bytes().count();\n+\n+    // The type is File, so should not fix\n+    let _ = File::open(\"foobar\").unwrap().bytes().count();\n+\n+    let f = File::open(\"foobar\").unwrap();\n+    let _ = f.bytes().count();\n+}"}, {"sha": "224deb779871c7bdd81ffa5b38d0d9dcfff2fbb4", "filename": "tests/ui/bytes_count_to_len.stderr", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fbytes_count_to_len.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fbytes_count_to_len.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fbytes_count_to_len.stderr?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -0,0 +1,28 @@\n+error: using long and hard to read `.bytes().count()`\n+  --> $DIR/bytes_count_to_len.rs:8:13\n+   |\n+LL |     let _ = String::from(\"foo\").bytes().count();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider calling `.len()` instead: `String::from(\"foo\").len()`\n+   |\n+   = note: `-D clippy::bytes-count-to-len` implied by `-D warnings`\n+\n+error: using long and hard to read `.bytes().count()`\n+  --> $DIR/bytes_count_to_len.rs:11:13\n+   |\n+LL |     let _ = s1.bytes().count();\n+   |             ^^^^^^^^^^^^^^^^^^ help: consider calling `.len()` instead: `s1.len()`\n+\n+error: using long and hard to read `.bytes().count()`\n+  --> $DIR/bytes_count_to_len.rs:14:13\n+   |\n+LL |     let _ = \"foo\".bytes().count();\n+   |             ^^^^^^^^^^^^^^^^^^^^^ help: consider calling `.len()` instead: `\"foo\".len()`\n+\n+error: using long and hard to read `.bytes().count()`\n+  --> $DIR/bytes_count_to_len.rs:17:13\n+   |\n+LL |     let _ = s2.bytes().count();\n+   |             ^^^^^^^^^^^^^^^^^^ help: consider calling `.len()` instead: `s2.len()`\n+\n+error: aborting due to 4 previous errors\n+"}, {"sha": "e6031e9adaeb66c084d8c96cb421d9d5ee186d91", "filename": "tests/ui/cast.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcast.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -1,13 +1,13 @@\n #![feature(repr128)]\n #![allow(incomplete_features)]\n-\n-#[warn(\n+#![warn(\n     clippy::cast_precision_loss,\n     clippy::cast_possible_truncation,\n     clippy::cast_sign_loss,\n     clippy::cast_possible_wrap\n )]\n-#[allow(clippy::cast_abs_to_unsigned, clippy::no_effect, clippy::unnecessary_operation)]\n+#![allow(clippy::cast_abs_to_unsigned, clippy::no_effect, clippy::unnecessary_operation)]\n+\n fn main() {\n     // Test clippy::cast_precision_loss\n     let x0 = 1i32;\n@@ -252,3 +252,11 @@ fn main() {\n         }\n     }\n }\n+\n+fn avoid_subtract_overflow(q: u32) {\n+    let c = (q >> 16) as u8;\n+    c as usize;\n+\n+    let c = (q / 1000) as u8;\n+    c as usize;\n+}"}, {"sha": "0c63b4af30865da871c4d9b241fd9f6d9dc979aa", "filename": "tests/ui/cast.stderr", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fcast.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fcast.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcast.stderr?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -194,5 +194,17 @@ error: casting `main::E10` to `u16` may truncate the value\n LL |             let _ = self as u16;\n    |                     ^^^^^^^^^^^\n \n-error: aborting due to 31 previous errors\n+error: casting `u32` to `u8` may truncate the value\n+  --> $DIR/cast.rs:257:13\n+   |\n+LL |     let c = (q >> 16) as u8;\n+   |             ^^^^^^^^^^^^^^^\n+\n+error: casting `u32` to `u8` may truncate the value\n+  --> $DIR/cast.rs:260:13\n+   |\n+LL |     let c = (q / 1000) as u8;\n+   |             ^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 33 previous errors\n "}, {"sha": "95bb883df1bf10877db0fff7a242606284dc55a8", "filename": "tests/ui/cast_alignment.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fcast_alignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fcast_alignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcast_alignment.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -44,8 +44,8 @@ fn main() {\n         let _ = core::ptr::read_unaligned(ptr as *const u16);\n         let _ = core::intrinsics::unaligned_volatile_load(ptr as *const u16);\n         let ptr = &mut data as *mut [u8; 2] as *mut u8;\n-        let _ = (ptr as *mut u16).write_unaligned(0);\n-        let _ = core::ptr::write_unaligned(ptr as *mut u16, 0);\n-        let _ = core::intrinsics::unaligned_volatile_store(ptr as *mut u16, 0);\n+        (ptr as *mut u16).write_unaligned(0);\n+        core::ptr::write_unaligned(ptr as *mut u16, 0);\n+        core::intrinsics::unaligned_volatile_store(ptr as *mut u16, 0);\n     }\n }"}, {"sha": "24d7eb28a197aa03b75fd663cbeda11339ee8c4a", "filename": "tests/ui/cast_slice_different_sizes.rs", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fcast_slice_different_sizes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fcast_slice_different_sizes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcast_slice_different_sizes.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -1,3 +1,5 @@\n+#![allow(clippy::let_unit_value)]\n+\n fn main() {\n     let x: [i32; 3] = [1_i32, 2, 3];\n     let r_x = &x;\n@@ -37,3 +39,44 @@ fn main() {\n     let long_chain_restore =\n         r_x as *const [i32] as *const [u32] as *const [u16] as *const [i8] as *const [u8] as *const [u32];\n }\n+\n+// foo and foo2 should not fire, they're the same size\n+fn foo(x: *mut [u8]) -> *mut [u8] {\n+    x as *mut [u8]\n+}\n+\n+fn foo2(x: *mut [u8]) -> *mut [u8] {\n+    x as *mut _\n+}\n+\n+// Test that casts as part of function returns work\n+fn bar(x: *mut [u16]) -> *mut [u8] {\n+    x as *mut [u8]\n+}\n+\n+fn uwu(x: *mut [u16]) -> *mut [u8] {\n+    x as *mut _\n+}\n+\n+fn bar2(x: *mut [u16]) -> *mut [u8] {\n+    x as _\n+}\n+\n+// constify\n+fn bar3(x: *mut [u16]) -> *const [u8] {\n+    x as _\n+}\n+\n+// unconstify\n+fn bar4(x: *const [u16]) -> *mut [u8] {\n+    x as _\n+}\n+\n+// function returns plus blocks\n+fn blocks(x: *mut [u16]) -> *mut [u8] {\n+    ({ x }) as _\n+}\n+\n+fn more_blocks(x: *mut [u16]) -> *mut [u8] {\n+    { ({ x }) as _ }\n+}"}, {"sha": "40721dcd05d5dbc909d140a82d70de3bfb28ddc7", "filename": "tests/ui/cast_slice_different_sizes.stderr", "status": "modified", "additions": 77, "deletions": 8, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fcast_slice_different_sizes.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fcast_slice_different_sizes.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcast_slice_different_sizes.stderr?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -1,31 +1,31 @@\n error: casting between raw pointers to `[i32]` (element size 4) and `[u8]` (element size 1) does not adjust the count\n-  --> $DIR/cast_slice_different_sizes.rs:7:13\n+  --> $DIR/cast_slice_different_sizes.rs:9:13\n    |\n LL |     let b = a as *const [u8];\n    |             ^^^^^^^^^^^^^^^^ help: replace with `ptr::slice_from_raw_parts`: `core::ptr::slice_from_raw_parts(a as *const u8, ..)`\n    |\n    = note: `#[deny(clippy::cast_slice_different_sizes)]` on by default\n \n error: casting between raw pointers to `[u8]` (element size 1) and `[u32]` (element size 4) does not adjust the count\n-  --> $DIR/cast_slice_different_sizes.rs:8:13\n+  --> $DIR/cast_slice_different_sizes.rs:10:13\n    |\n LL |     let c = b as *const [u32];\n    |             ^^^^^^^^^^^^^^^^^ help: replace with `ptr::slice_from_raw_parts`: `core::ptr::slice_from_raw_parts(b as *const u32, ..)`\n \n error: casting between raw pointers to `[i32]` (element size 4) and `[u8]` (element size 1) does not adjust the count\n-  --> $DIR/cast_slice_different_sizes.rs:11:16\n+  --> $DIR/cast_slice_different_sizes.rs:13:16\n    |\n LL |     let loss = r_x as *const [i32] as *const [u8];\n    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace with `ptr::slice_from_raw_parts`: `core::ptr::slice_from_raw_parts(r_x as *const [i32] as *const u8, ..)`\n \n error: casting between raw pointers to `[i32]` (element size 4) and `[u8]` (element size 1) does not adjust the count\n-  --> $DIR/cast_slice_different_sizes.rs:18:24\n+  --> $DIR/cast_slice_different_sizes.rs:20:24\n    |\n LL |     let loss_block_1 = { r_x as *const [i32] } as *const [u8];\n    |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace with `ptr::slice_from_raw_parts`: `core::ptr::slice_from_raw_parts({ r_x as *const [i32] } as *const u8, ..)`\n \n error: casting between raw pointers to `[i32]` (element size 4) and `[u8]` (element size 1) does not adjust the count\n-  --> $DIR/cast_slice_different_sizes.rs:19:24\n+  --> $DIR/cast_slice_different_sizes.rs:21:24\n    |\n LL |       let loss_block_2 = {\n    |  ________________________^\n@@ -43,10 +43,79 @@ LL ~     } as *const u8, ..);\n    |\n \n error: casting between raw pointers to `[i32]` (element size 4) and `[u8]` (element size 1) does not adjust the count\n-  --> $DIR/cast_slice_different_sizes.rs:36:27\n+  --> $DIR/cast_slice_different_sizes.rs:38:27\n    |\n LL |     let long_chain_loss = r_x as *const [i32] as *const [u32] as *const [u16] as *const [i8] as *const [u8];\n-   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace with `ptr::slice_from_raw_parts`: `core::ptr::slice_from_raw_parts(r_x as *const [i32] as *const [u32] as *const [u16] as *const [i8] as *const u8, ..)`\n+   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace with `ptr::slice_from_raw_parts`: `core::ptr::slice_from_raw_parts(r_x as *const [i32] as *const u8, ..)`\n \n-error: aborting due to 6 previous errors\n+error: casting between raw pointers to `[u16]` (element size 2) and `[u8]` (element size 1) does not adjust the count\n+  --> $DIR/cast_slice_different_sizes.rs:53:36\n+   |\n+LL |   fn bar(x: *mut [u16]) -> *mut [u8] {\n+   |  ____________________________________^\n+LL | |     x as *mut [u8]\n+LL | | }\n+   | |_^ help: replace with `ptr::slice_from_raw_parts_mut`: `core::ptr::slice_from_raw_parts_mut(x as *mut u8, ..)`\n+\n+error: casting between raw pointers to `[u16]` (element size 2) and `[u8]` (element size 1) does not adjust the count\n+  --> $DIR/cast_slice_different_sizes.rs:57:36\n+   |\n+LL |   fn uwu(x: *mut [u16]) -> *mut [u8] {\n+   |  ____________________________________^\n+LL | |     x as *mut _\n+LL | | }\n+   | |_^ help: replace with `ptr::slice_from_raw_parts_mut`: `core::ptr::slice_from_raw_parts_mut(x as *mut u8, ..)`\n+\n+error: casting between raw pointers to `[u16]` (element size 2) and `[u8]` (element size 1) does not adjust the count\n+  --> $DIR/cast_slice_different_sizes.rs:61:37\n+   |\n+LL |   fn bar2(x: *mut [u16]) -> *mut [u8] {\n+   |  _____________________________________^\n+LL | |     x as _\n+LL | | }\n+   | |_^ help: replace with `ptr::slice_from_raw_parts_mut`: `core::ptr::slice_from_raw_parts_mut(x as *mut u8, ..)`\n+\n+error: casting between raw pointers to `[u16]` (element size 2) and `[u8]` (element size 1) does not adjust the count\n+  --> $DIR/cast_slice_different_sizes.rs:66:39\n+   |\n+LL |   fn bar3(x: *mut [u16]) -> *const [u8] {\n+   |  _______________________________________^\n+LL | |     x as _\n+LL | | }\n+   | |_^ help: replace with `ptr::slice_from_raw_parts`: `core::ptr::slice_from_raw_parts(x as *const u8, ..)`\n+\n+error: casting between raw pointers to `[u16]` (element size 2) and `[u8]` (element size 1) does not adjust the count\n+  --> $DIR/cast_slice_different_sizes.rs:71:39\n+   |\n+LL |   fn bar4(x: *const [u16]) -> *mut [u8] {\n+   |  _______________________________________^\n+LL | |     x as _\n+LL | | }\n+   | |_^ help: replace with `ptr::slice_from_raw_parts_mut`: `core::ptr::slice_from_raw_parts_mut(x as *mut u8, ..)`\n+\n+error: casting between raw pointers to `[u16]` (element size 2) and `[u8]` (element size 1) does not adjust the count\n+  --> $DIR/cast_slice_different_sizes.rs:76:39\n+   |\n+LL |   fn blocks(x: *mut [u16]) -> *mut [u8] {\n+   |  _______________________________________^\n+LL | |     ({ x }) as _\n+LL | | }\n+   | |_^ help: replace with `ptr::slice_from_raw_parts_mut`: `core::ptr::slice_from_raw_parts_mut(({ x }) as *mut u8, ..)`\n+\n+error: casting between raw pointers to `[u16]` (element size 2) and `[u8]` (element size 1) does not adjust the count\n+  --> $DIR/cast_slice_different_sizes.rs:80:44\n+   |\n+LL |   fn more_blocks(x: *mut [u16]) -> *mut [u8] {\n+   |  ____________________________________________^\n+LL | |     { ({ x }) as _ }\n+LL | | }\n+   | |_^ help: replace with `ptr::slice_from_raw_parts_mut`: `core::ptr::slice_from_raw_parts_mut(({ x }) as *mut u8, ..)`\n+\n+error: casting between raw pointers to `[u16]` (element size 2) and `[u8]` (element size 1) does not adjust the count\n+  --> $DIR/cast_slice_different_sizes.rs:81:5\n+   |\n+LL |     { ({ x }) as _ }\n+   |     ^^^^^^^^^^^^^^^^ help: replace with `ptr::slice_from_raw_parts_mut`: `core::ptr::slice_from_raw_parts_mut(({ x }) as *mut u8, ..)`\n+\n+error: aborting due to 14 previous errors\n "}, {"sha": "d6a5a78506791a0e782c4c4911091d4f96ef7104", "filename": "tests/ui/collapsible_else_if.fixed", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fcollapsible_else_if.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fcollapsible_else_if.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcollapsible_else_if.fixed?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -75,3 +75,10 @@ fn main() {\n         }\n     }\n }\n+\n+#[rustfmt::skip]\n+#[allow(dead_code)]\n+fn issue_7318() {\n+    if true { println!(\"I've been resolved!\")\n+    }else if false {}\n+}"}, {"sha": "4399fc8b2bd1d4b760828576d4d09055a6aaeabd", "filename": "tests/ui/collapsible_else_if.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fcollapsible_else_if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fcollapsible_else_if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcollapsible_else_if.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -89,3 +89,12 @@ fn main() {\n         }\n     }\n }\n+\n+#[rustfmt::skip]\n+#[allow(dead_code)]\n+fn issue_7318() {\n+    if true { println!(\"I've been resolved!\")\n+    }else{\n+        if false {}\n+    }\n+}"}, {"sha": "45b2094c9948b6961e4da37a27bc5ce631ccb56c", "filename": "tests/ui/collapsible_else_if.stderr", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fcollapsible_else_if.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fcollapsible_else_if.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcollapsible_else_if.stderr?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -150,5 +150,14 @@ LL +         println!(\"!\")\n LL +     }\n    |\n \n-error: aborting due to 7 previous errors\n+error: this `else { if .. }` block can be collapsed\n+  --> $DIR/collapsible_else_if.rs:97:10\n+   |\n+LL |       }else{\n+   |  __________^\n+LL | |         if false {}\n+LL | |     }\n+   | |_____^ help: collapse nested if block: `if false {}`\n+\n+error: aborting due to 8 previous errors\n "}, {"sha": "95b6315132526460293acf9da62bbcf617f68ac1", "filename": "tests/ui/crashes/auxiliary/ice-8681-aux.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fcrashes%2Fauxiliary%2Fice-8681-aux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fcrashes%2Fauxiliary%2Fice-8681-aux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcrashes%2Fauxiliary%2Fice-8681-aux.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -0,0 +1,6 @@\n+pub fn foo(x: &u32) -> u32 {\n+    /* Safety:\n+     * This is totally ok.\n+     */\n+    unsafe { *(x as *const u32) }\n+}"}, {"sha": "c6298139601625392c47a5bd3614d3acd5ef1038", "filename": "tests/ui/crashes/ice-2865.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fcrashes%2Fice-2865.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fcrashes%2Fice-2865.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcrashes%2Fice-2865.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -1,4 +1,4 @@\n-#[allow(dead_code)]\n+#![allow(dead_code, clippy::extra_unused_lifetimes)]\n \n /// Test for https://github.com/rust-lang/rust-clippy/issues/2865\n "}, {"sha": "268ba86fc7aa80756b1aa151b1aff72949a4d75c", "filename": "tests/ui/crashes/ice-3151.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fcrashes%2Fice-3151.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fcrashes%2Fice-3151.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcrashes%2Fice-3151.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -1,4 +1,4 @@\n-/// Test for https://github.com/rust-lang/rust-clippy/issues/2865\n+/// Test for https://github.com/rust-lang/rust-clippy/issues/3151\n \n #[derive(Clone)]\n pub struct HashMap<V, S> {"}, {"sha": "ce46bc1acc1b7fbd718f5ffe8de0f19c38e0fe1e", "filename": "tests/ui/crashes/ice-5944.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fcrashes%2Fice-5944.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fcrashes%2Fice-5944.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcrashes%2Fice-5944.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -1,4 +1,5 @@\n #![warn(clippy::repeat_once)]\n+#![allow(clippy::let_unit_value)]\n \n trait Repeat {\n     fn repeat(&self) {}"}, {"sha": "8ed8f3b3a0642f2bea6f9da9a5fd19c08ce850e0", "filename": "tests/ui/crashes/ice-8250.stderr", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fcrashes%2Fice-8250.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fcrashes%2Fice-8250.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcrashes%2Fice-8250.stderr?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -1,11 +1,3 @@\n-error: manual implementation of `split_once`\n-  --> $DIR/ice-8250.rs:2:13\n-   |\n-LL |     let _ = s[1..].splitn(2, '.').next()?;\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `s[1..].split_once('.').map_or(s[1..], |x| x.0)`\n-   |\n-   = note: `-D clippy::manual-split-once` implied by `-D warnings`\n-\n error: unnecessary use of `splitn`\n   --> $DIR/ice-8250.rs:2:13\n    |\n@@ -14,5 +6,5 @@ LL |     let _ = s[1..].splitn(2, '.').next()?;\n    |\n    = note: `-D clippy::needless-splitn` implied by `-D warnings`\n \n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n "}, {"sha": "ee14f011f631bb534baece790c3c07ef901db1cb", "filename": "tests/ui/crashes/ice-8681.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fcrashes%2Fice-8681.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fcrashes%2Fice-8681.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcrashes%2Fice-8681.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -0,0 +1,10 @@\n+// aux-build: ice-8681-aux.rs\n+\n+#![warn(clippy::undocumented_unsafe_blocks)]\n+\n+#[path = \"auxiliary/ice-8681-aux.rs\"]\n+mod ice_8681_aux;\n+\n+fn main() {\n+    let _ = ice_8681_aux::foo(&0u32);\n+}"}, {"sha": "4b3fb764010821e375a167aca49b93620ef0fa7a", "filename": "tests/ui/crashes/ice-96721.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fcrashes%2Fice-96721.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fcrashes%2Fice-96721.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcrashes%2Fice-96721.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -0,0 +1,10 @@\n+macro_rules! foo {\n+    () => {\n+        \"bar.rs\"\n+    };\n+}\n+\n+#[path = foo!()] //~ ERROR malformed `path` attribute\n+mod abc {}\n+\n+fn main() {}"}, {"sha": "78c567b8e772e989945c4098d8c9efbb09d0fd6b", "filename": "tests/ui/crashes/ice-96721.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fcrashes%2Fice-96721.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fcrashes%2Fice-96721.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcrashes%2Fice-96721.stderr?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -0,0 +1,8 @@\n+error: malformed `path` attribute input\n+  --> $DIR/ice-96721.rs:7:1\n+   |\n+LL | #[path = foo!()] //~ ERROR malformed `path` attribute\n+   | ^^^^^^^^^^^^^^^^ help: must be of the form: `#[path = \"file\"]`\n+\n+error: aborting due to previous error\n+"}, {"sha": "a28bff76755b62f982bf364d3e8f3fbfaeb01db7", "filename": "tests/ui/default_numeric_fallback_f64.fixed", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fdefault_numeric_fallback_f64.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fdefault_numeric_fallback_f64.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdefault_numeric_fallback_f64.fixed?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -2,12 +2,15 @@\n // aux-build:macro_rules.rs\n \n #![warn(clippy::default_numeric_fallback)]\n-#![allow(unused)]\n-#![allow(clippy::never_loop)]\n-#![allow(clippy::no_effect)]\n-#![allow(clippy::unnecessary_operation)]\n-#![allow(clippy::branches_sharing_code)]\n-#![allow(clippy::match_single_binding)]\n+#![allow(\n+    unused,\n+    clippy::never_loop,\n+    clippy::no_effect,\n+    clippy::unnecessary_operation,\n+    clippy::branches_sharing_code,\n+    clippy::match_single_binding,\n+    clippy::let_unit_value\n+)]\n \n #[macro_use]\n extern crate macro_rules;"}, {"sha": "b48435cc7b282a049e8c4425381898e7b31b2702", "filename": "tests/ui/default_numeric_fallback_f64.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fdefault_numeric_fallback_f64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fdefault_numeric_fallback_f64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdefault_numeric_fallback_f64.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -2,12 +2,15 @@\n // aux-build:macro_rules.rs\n \n #![warn(clippy::default_numeric_fallback)]\n-#![allow(unused)]\n-#![allow(clippy::never_loop)]\n-#![allow(clippy::no_effect)]\n-#![allow(clippy::unnecessary_operation)]\n-#![allow(clippy::branches_sharing_code)]\n-#![allow(clippy::match_single_binding)]\n+#![allow(\n+    unused,\n+    clippy::never_loop,\n+    clippy::no_effect,\n+    clippy::unnecessary_operation,\n+    clippy::branches_sharing_code,\n+    clippy::match_single_binding,\n+    clippy::let_unit_value\n+)]\n \n #[macro_use]\n extern crate macro_rules;"}, {"sha": "f8b6c7746edbb728f1ee699b2b345bb1963ecd66", "filename": "tests/ui/default_numeric_fallback_f64.stderr", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fdefault_numeric_fallback_f64.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fdefault_numeric_fallback_f64.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdefault_numeric_fallback_f64.stderr?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -1,139 +1,139 @@\n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback_f64.rs:18:17\n+  --> $DIR/default_numeric_fallback_f64.rs:21:17\n    |\n LL |         let x = 0.12;\n    |                 ^^^^ help: consider adding suffix: `0.12_f64`\n    |\n    = note: `-D clippy::default-numeric-fallback` implied by `-D warnings`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback_f64.rs:19:18\n+  --> $DIR/default_numeric_fallback_f64.rs:22:18\n    |\n LL |         let x = [1., 2., 3.];\n    |                  ^^ help: consider adding suffix: `1.0_f64`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback_f64.rs:19:22\n+  --> $DIR/default_numeric_fallback_f64.rs:22:22\n    |\n LL |         let x = [1., 2., 3.];\n    |                      ^^ help: consider adding suffix: `2.0_f64`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback_f64.rs:19:26\n+  --> $DIR/default_numeric_fallback_f64.rs:22:26\n    |\n LL |         let x = [1., 2., 3.];\n    |                          ^^ help: consider adding suffix: `3.0_f64`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback_f64.rs:20:28\n+  --> $DIR/default_numeric_fallback_f64.rs:23:28\n    |\n LL |         let x = if true { (1., 2.) } else { (3., 4.) };\n    |                            ^^ help: consider adding suffix: `1.0_f64`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback_f64.rs:20:32\n+  --> $DIR/default_numeric_fallback_f64.rs:23:32\n    |\n LL |         let x = if true { (1., 2.) } else { (3., 4.) };\n    |                                ^^ help: consider adding suffix: `2.0_f64`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback_f64.rs:20:46\n+  --> $DIR/default_numeric_fallback_f64.rs:23:46\n    |\n LL |         let x = if true { (1., 2.) } else { (3., 4.) };\n    |                                              ^^ help: consider adding suffix: `3.0_f64`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback_f64.rs:20:50\n+  --> $DIR/default_numeric_fallback_f64.rs:23:50\n    |\n LL |         let x = if true { (1., 2.) } else { (3., 4.) };\n    |                                                  ^^ help: consider adding suffix: `4.0_f64`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback_f64.rs:21:23\n+  --> $DIR/default_numeric_fallback_f64.rs:24:23\n    |\n LL |         let x = match 1. {\n    |                       ^^ help: consider adding suffix: `1.0_f64`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback_f64.rs:22:18\n+  --> $DIR/default_numeric_fallback_f64.rs:25:18\n    |\n LL |             _ => 1.,\n    |                  ^^ help: consider adding suffix: `1.0_f64`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback_f64.rs:40:21\n+  --> $DIR/default_numeric_fallback_f64.rs:43:21\n    |\n LL |             let y = 1.;\n    |                     ^^ help: consider adding suffix: `1.0_f64`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback_f64.rs:48:21\n+  --> $DIR/default_numeric_fallback_f64.rs:51:21\n    |\n LL |             let y = 1.;\n    |                     ^^ help: consider adding suffix: `1.0_f64`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback_f64.rs:54:21\n+  --> $DIR/default_numeric_fallback_f64.rs:57:21\n    |\n LL |             let y = 1.;\n    |                     ^^ help: consider adding suffix: `1.0_f64`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback_f64.rs:66:9\n+  --> $DIR/default_numeric_fallback_f64.rs:69:9\n    |\n LL |         1.\n    |         ^^ help: consider adding suffix: `1.0_f64`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback_f64.rs:72:27\n+  --> $DIR/default_numeric_fallback_f64.rs:75:27\n    |\n LL |         let f = || -> _ { 1. };\n    |                           ^^ help: consider adding suffix: `1.0_f64`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback_f64.rs:76:29\n+  --> $DIR/default_numeric_fallback_f64.rs:79:29\n    |\n LL |         let f = || -> f64 { 1. };\n    |                             ^^ help: consider adding suffix: `1.0_f64`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback_f64.rs:90:21\n+  --> $DIR/default_numeric_fallback_f64.rs:93:21\n    |\n LL |         generic_arg(1.);\n    |                     ^^ help: consider adding suffix: `1.0_f64`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback_f64.rs:93:32\n+  --> $DIR/default_numeric_fallback_f64.rs:96:32\n    |\n LL |         let x: _ = generic_arg(1.);\n    |                                ^^ help: consider adding suffix: `1.0_f64`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback_f64.rs:111:28\n+  --> $DIR/default_numeric_fallback_f64.rs:114:28\n    |\n LL |         GenericStruct { x: 1. };\n    |                            ^^ help: consider adding suffix: `1.0_f64`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback_f64.rs:114:36\n+  --> $DIR/default_numeric_fallback_f64.rs:117:36\n    |\n LL |         let _ = GenericStruct { x: 1. };\n    |                                    ^^ help: consider adding suffix: `1.0_f64`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback_f64.rs:132:24\n+  --> $DIR/default_numeric_fallback_f64.rs:135:24\n    |\n LL |         GenericEnum::X(1.);\n    |                        ^^ help: consider adding suffix: `1.0_f64`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback_f64.rs:152:23\n+  --> $DIR/default_numeric_fallback_f64.rs:155:23\n    |\n LL |         s.generic_arg(1.);\n    |                       ^^ help: consider adding suffix: `1.0_f64`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback_f64.rs:159:21\n+  --> $DIR/default_numeric_fallback_f64.rs:162:21\n    |\n LL |             let x = 22.;\n    |                     ^^^ help: consider adding suffix: `22.0_f64`"}, {"sha": "fa85d278c8fcad8c82cd3fba79a9de7d81dcd287", "filename": "tests/ui/default_numeric_fallback_i32.fixed", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fdefault_numeric_fallback_i32.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fdefault_numeric_fallback_i32.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdefault_numeric_fallback_i32.fixed?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -2,11 +2,14 @@\n // aux-build:macro_rules.rs\n \n #![warn(clippy::default_numeric_fallback)]\n-#![allow(unused)]\n-#![allow(clippy::never_loop)]\n-#![allow(clippy::no_effect)]\n-#![allow(clippy::unnecessary_operation)]\n-#![allow(clippy::branches_sharing_code)]\n+#![allow(\n+    unused,\n+    clippy::never_loop,\n+    clippy::no_effect,\n+    clippy::unnecessary_operation,\n+    clippy::branches_sharing_code,\n+    clippy::let_unit_value\n+)]\n \n #[macro_use]\n extern crate macro_rules;"}, {"sha": "71acccd702b062de3964431c62fdf4bed3e1c88b", "filename": "tests/ui/default_numeric_fallback_i32.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fdefault_numeric_fallback_i32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fdefault_numeric_fallback_i32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdefault_numeric_fallback_i32.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -2,11 +2,14 @@\n // aux-build:macro_rules.rs\n \n #![warn(clippy::default_numeric_fallback)]\n-#![allow(unused)]\n-#![allow(clippy::never_loop)]\n-#![allow(clippy::no_effect)]\n-#![allow(clippy::unnecessary_operation)]\n-#![allow(clippy::branches_sharing_code)]\n+#![allow(\n+    unused,\n+    clippy::never_loop,\n+    clippy::no_effect,\n+    clippy::unnecessary_operation,\n+    clippy::branches_sharing_code,\n+    clippy::let_unit_value\n+)]\n \n #[macro_use]\n extern crate macro_rules;"}, {"sha": "3cc84ff1132321873e65e03dcde9d1017e75b379", "filename": "tests/ui/default_numeric_fallback_i32.stderr", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fdefault_numeric_fallback_i32.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fdefault_numeric_fallback_i32.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdefault_numeric_fallback_i32.stderr?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -1,151 +1,151 @@\n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback_i32.rs:17:17\n+  --> $DIR/default_numeric_fallback_i32.rs:20:17\n    |\n LL |         let x = 22;\n    |                 ^^ help: consider adding suffix: `22_i32`\n    |\n    = note: `-D clippy::default-numeric-fallback` implied by `-D warnings`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback_i32.rs:18:18\n+  --> $DIR/default_numeric_fallback_i32.rs:21:18\n    |\n LL |         let x = [1, 2, 3];\n    |                  ^ help: consider adding suffix: `1_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback_i32.rs:18:21\n+  --> $DIR/default_numeric_fallback_i32.rs:21:21\n    |\n LL |         let x = [1, 2, 3];\n    |                     ^ help: consider adding suffix: `2_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback_i32.rs:18:24\n+  --> $DIR/default_numeric_fallback_i32.rs:21:24\n    |\n LL |         let x = [1, 2, 3];\n    |                        ^ help: consider adding suffix: `3_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback_i32.rs:19:28\n+  --> $DIR/default_numeric_fallback_i32.rs:22:28\n    |\n LL |         let x = if true { (1, 2) } else { (3, 4) };\n    |                            ^ help: consider adding suffix: `1_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback_i32.rs:19:31\n+  --> $DIR/default_numeric_fallback_i32.rs:22:31\n    |\n LL |         let x = if true { (1, 2) } else { (3, 4) };\n    |                               ^ help: consider adding suffix: `2_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback_i32.rs:19:44\n+  --> $DIR/default_numeric_fallback_i32.rs:22:44\n    |\n LL |         let x = if true { (1, 2) } else { (3, 4) };\n    |                                            ^ help: consider adding suffix: `3_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback_i32.rs:19:47\n+  --> $DIR/default_numeric_fallback_i32.rs:22:47\n    |\n LL |         let x = if true { (1, 2) } else { (3, 4) };\n    |                                               ^ help: consider adding suffix: `4_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback_i32.rs:20:23\n+  --> $DIR/default_numeric_fallback_i32.rs:23:23\n    |\n LL |         let x = match 1 {\n    |                       ^ help: consider adding suffix: `1_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback_i32.rs:21:13\n+  --> $DIR/default_numeric_fallback_i32.rs:24:13\n    |\n LL |             1 => 1,\n    |             ^ help: consider adding suffix: `1_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback_i32.rs:21:18\n+  --> $DIR/default_numeric_fallback_i32.rs:24:18\n    |\n LL |             1 => 1,\n    |                  ^ help: consider adding suffix: `1_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback_i32.rs:22:18\n+  --> $DIR/default_numeric_fallback_i32.rs:25:18\n    |\n LL |             _ => 2,\n    |                  ^ help: consider adding suffix: `2_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback_i32.rs:39:21\n+  --> $DIR/default_numeric_fallback_i32.rs:42:21\n    |\n LL |             let y = 1;\n    |                     ^ help: consider adding suffix: `1_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback_i32.rs:47:21\n+  --> $DIR/default_numeric_fallback_i32.rs:50:21\n    |\n LL |             let y = 1;\n    |                     ^ help: consider adding suffix: `1_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback_i32.rs:53:21\n+  --> $DIR/default_numeric_fallback_i32.rs:56:21\n    |\n LL |             let y = 1;\n    |                     ^ help: consider adding suffix: `1_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback_i32.rs:65:9\n+  --> $DIR/default_numeric_fallback_i32.rs:68:9\n    |\n LL |         1\n    |         ^ help: consider adding suffix: `1_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback_i32.rs:71:27\n+  --> $DIR/default_numeric_fallback_i32.rs:74:27\n    |\n LL |         let f = || -> _ { 1 };\n    |                           ^ help: consider adding suffix: `1_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback_i32.rs:75:29\n+  --> $DIR/default_numeric_fallback_i32.rs:78:29\n    |\n LL |         let f = || -> i32 { 1 };\n    |                             ^ help: consider adding suffix: `1_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback_i32.rs:89:21\n+  --> $DIR/default_numeric_fallback_i32.rs:92:21\n    |\n LL |         generic_arg(1);\n    |                     ^ help: consider adding suffix: `1_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback_i32.rs:92:32\n+  --> $DIR/default_numeric_fallback_i32.rs:95:32\n    |\n LL |         let x: _ = generic_arg(1);\n    |                                ^ help: consider adding suffix: `1_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback_i32.rs:110:28\n+  --> $DIR/default_numeric_fallback_i32.rs:113:28\n    |\n LL |         GenericStruct { x: 1 };\n    |                            ^ help: consider adding suffix: `1_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback_i32.rs:113:36\n+  --> $DIR/default_numeric_fallback_i32.rs:116:36\n    |\n LL |         let _ = GenericStruct { x: 1 };\n    |                                    ^ help: consider adding suffix: `1_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback_i32.rs:131:24\n+  --> $DIR/default_numeric_fallback_i32.rs:134:24\n    |\n LL |         GenericEnum::X(1);\n    |                        ^ help: consider adding suffix: `1_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback_i32.rs:151:23\n+  --> $DIR/default_numeric_fallback_i32.rs:154:23\n    |\n LL |         s.generic_arg(1);\n    |                       ^ help: consider adding suffix: `1_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback_i32.rs:158:21\n+  --> $DIR/default_numeric_fallback_i32.rs:161:21\n    |\n LL |             let x = 22;\n    |                     ^^ help: consider adding suffix: `22_i32`"}, {"sha": "07270bd76362a1a8cf4eadc533d6c0e01465d259", "filename": "tests/ui/deprecated.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fdeprecated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fdeprecated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdeprecated.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -1,3 +1,7 @@\n+// This file was generated by `cargo dev update_lints`.\n+// Use that command to update this file and do not edit by hand.\n+// Manual edits will be overwritten.\n+\n #![warn(clippy::should_assert_eq)]\n #![warn(clippy::extend_from_slice)]\n #![warn(clippy::range_step_by_zero)]"}, {"sha": "0e142ac8f20e7a3a83d0f1792f7363cb402be641", "filename": "tests/ui/deprecated.stderr", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fdeprecated.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fdeprecated.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdeprecated.stderr?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -1,97 +1,97 @@\n error: lint `clippy::should_assert_eq` has been removed: `assert!()` will be more flexible with RFC 2011\n-  --> $DIR/deprecated.rs:1:9\n+  --> $DIR/deprecated.rs:5:9\n    |\n LL | #![warn(clippy::should_assert_eq)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: `-D renamed-and-removed-lints` implied by `-D warnings`\n \n error: lint `clippy::extend_from_slice` has been removed: `.extend_from_slice(_)` is a faster way to extend a Vec by a slice\n-  --> $DIR/deprecated.rs:2:9\n+  --> $DIR/deprecated.rs:6:9\n    |\n LL | #![warn(clippy::extend_from_slice)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: lint `clippy::range_step_by_zero` has been removed: `iterator.step_by(0)` panics nowadays\n-  --> $DIR/deprecated.rs:3:9\n+  --> $DIR/deprecated.rs:7:9\n    |\n LL | #![warn(clippy::range_step_by_zero)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: lint `clippy::unstable_as_slice` has been removed: `Vec::as_slice` has been stabilized in 1.7\n-  --> $DIR/deprecated.rs:4:9\n+  --> $DIR/deprecated.rs:8:9\n    |\n LL | #![warn(clippy::unstable_as_slice)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: lint `clippy::unstable_as_mut_slice` has been removed: `Vec::as_mut_slice` has been stabilized in 1.7\n-  --> $DIR/deprecated.rs:5:9\n+  --> $DIR/deprecated.rs:9:9\n    |\n LL | #![warn(clippy::unstable_as_mut_slice)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: lint `clippy::misaligned_transmute` has been removed: this lint has been split into cast_ptr_alignment and transmute_ptr_to_ptr\n-  --> $DIR/deprecated.rs:6:9\n+  --> $DIR/deprecated.rs:10:9\n    |\n LL | #![warn(clippy::misaligned_transmute)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: lint `clippy::assign_ops` has been removed: using compound assignment operators (e.g., `+=`) is harmless\n-  --> $DIR/deprecated.rs:7:9\n+  --> $DIR/deprecated.rs:11:9\n    |\n LL | #![warn(clippy::assign_ops)]\n    |         ^^^^^^^^^^^^^^^^^^\n \n error: lint `clippy::if_let_redundant_pattern_matching` has been removed: this lint has been changed to redundant_pattern_matching\n-  --> $DIR/deprecated.rs:8:9\n+  --> $DIR/deprecated.rs:12:9\n    |\n LL | #![warn(clippy::if_let_redundant_pattern_matching)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: lint `clippy::unsafe_vector_initialization` has been removed: the replacement suggested by this lint had substantially different behavior\n-  --> $DIR/deprecated.rs:9:9\n+  --> $DIR/deprecated.rs:13:9\n    |\n LL | #![warn(clippy::unsafe_vector_initialization)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: lint `clippy::unused_collect` has been removed: `collect` has been marked as #[must_use] in rustc and that covers all cases of this lint\n-  --> $DIR/deprecated.rs:10:9\n+  --> $DIR/deprecated.rs:14:9\n    |\n LL | #![warn(clippy::unused_collect)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n \n error: lint `clippy::replace_consts` has been removed: associated-constants `MIN`/`MAX` of integers are preferred to `{min,max}_value()` and module constants\n-  --> $DIR/deprecated.rs:11:9\n+  --> $DIR/deprecated.rs:15:9\n    |\n LL | #![warn(clippy::replace_consts)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n \n error: lint `clippy::regex_macro` has been removed: the regex! macro has been removed from the regex crate in 2018\n-  --> $DIR/deprecated.rs:12:9\n+  --> $DIR/deprecated.rs:16:9\n    |\n LL | #![warn(clippy::regex_macro)]\n    |         ^^^^^^^^^^^^^^^^^^^\n \n error: lint `clippy::find_map` has been removed: this lint has been replaced by `manual_find_map`, a more specific lint\n-  --> $DIR/deprecated.rs:13:9\n+  --> $DIR/deprecated.rs:17:9\n    |\n LL | #![warn(clippy::find_map)]\n    |         ^^^^^^^^^^^^^^^^\n \n error: lint `clippy::filter_map` has been removed: this lint has been replaced by `manual_filter_map`, a more specific lint\n-  --> $DIR/deprecated.rs:14:9\n+  --> $DIR/deprecated.rs:18:9\n    |\n LL | #![warn(clippy::filter_map)]\n    |         ^^^^^^^^^^^^^^^^^^\n \n error: lint `clippy::pub_enum_variant_names` has been removed: set the `avoid-breaking-exported-api` config option to `false` to enable the `enum_variant_names` lint for public items\n-  --> $DIR/deprecated.rs:15:9\n+  --> $DIR/deprecated.rs:19:9\n    |\n LL | #![warn(clippy::pub_enum_variant_names)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: lint `clippy::wrong_pub_self_convention` has been removed: set the `avoid-breaking-exported-api` config option to `false` to enable the `wrong_self_convention` lint for public items\n-  --> $DIR/deprecated.rs:16:9\n+  --> $DIR/deprecated.rs:20:9\n    |\n LL | #![warn(clippy::wrong_pub_self_convention)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"}, {"sha": "b91f7aa0dd8d2bfe51710c8ab57adea3861d498d", "filename": "tests/ui/doc_unsafe.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fdoc_unsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fdoc_unsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdoc_unsafe.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -1,5 +1,7 @@\n // aux-build:doc_unsafe_macros.rs\n \n+#![allow(clippy::let_unit_value)]\n+\n #[macro_use]\n extern crate doc_unsafe_macros;\n "}, {"sha": "904b88eaef62280a1a56991466904e7afd57ef9c", "filename": "tests/ui/doc_unsafe.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fdoc_unsafe.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fdoc_unsafe.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdoc_unsafe.stderr?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -1,5 +1,5 @@\n error: unsafe function's docs miss `# Safety` section\n-  --> $DIR/doc_unsafe.rs:7:1\n+  --> $DIR/doc_unsafe.rs:9:1\n    |\n LL | / pub unsafe fn destroy_the_planet() {\n LL | |     unimplemented!();\n@@ -9,37 +9,37 @@ LL | | }\n    = note: `-D clippy::missing-safety-doc` implied by `-D warnings`\n \n error: unsafe function's docs miss `# Safety` section\n-  --> $DIR/doc_unsafe.rs:30:5\n+  --> $DIR/doc_unsafe.rs:32:5\n    |\n LL | /     pub unsafe fn republished() {\n LL | |         unimplemented!();\n LL | |     }\n    | |_____^\n \n error: unsafe function's docs miss `# Safety` section\n-  --> $DIR/doc_unsafe.rs:38:5\n+  --> $DIR/doc_unsafe.rs:40:5\n    |\n LL |     unsafe fn woefully_underdocumented(self);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: docs for unsafe trait missing `# Safety` section\n-  --> $DIR/doc_unsafe.rs:44:1\n+  --> $DIR/doc_unsafe.rs:46:1\n    |\n LL | / pub unsafe trait UnsafeTrait {\n LL | |     fn method();\n LL | | }\n    | |_^\n \n error: unsafe function's docs miss `# Safety` section\n-  --> $DIR/doc_unsafe.rs:74:5\n+  --> $DIR/doc_unsafe.rs:76:5\n    |\n LL | /     pub unsafe fn more_undocumented_unsafe() -> Self {\n LL | |         unimplemented!();\n LL | |     }\n    | |_____^\n \n error: unsafe function's docs miss `# Safety` section\n-  --> $DIR/doc_unsafe.rs:90:9\n+  --> $DIR/doc_unsafe.rs:92:9\n    |\n LL | /         pub unsafe fn whee() {\n LL | |             unimplemented!()"}, {"sha": "30121033de7eae113ff2025830aae75fa0c24d10", "filename": "tests/ui/drop_non_drop.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fdrop_non_drop.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fdrop_non_drop.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdrop_non_drop.stderr?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -1,4 +1,4 @@\n-error: call to `std::mem::drop` with a value that does not implement `Drop`. Dropping such a type only extends it's contained lifetimes\n+error: call to `std::mem::drop` with a value that does not implement `Drop`. Dropping such a type only extends its contained lifetimes\n   --> $DIR/drop_non_drop.rs:22:5\n    |\n LL |     drop(Foo);\n@@ -11,7 +11,7 @@ note: argument has type `main::Foo`\n LL |     drop(Foo);\n    |          ^^^\n \n-error: call to `std::mem::drop` with a value that does not implement `Drop`. Dropping such a type only extends it's contained lifetimes\n+error: call to `std::mem::drop` with a value that does not implement `Drop`. Dropping such a type only extends its contained lifetimes\n   --> $DIR/drop_non_drop.rs:37:5\n    |\n LL |     drop(Baz(Foo));"}, {"sha": "2e1b768461ab2a1e7483831b842e4822b4c13502", "filename": "tests/ui/empty_drop.fixed", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fempty_drop.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fempty_drop.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fempty_drop.fixed?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -0,0 +1,24 @@\n+// run-rustfix\n+#![warn(clippy::empty_drop)]\n+#![allow(unused)]\n+\n+// should cause an error\n+struct Foo;\n+\n+\n+\n+// shouldn't cause an error\n+struct Bar;\n+\n+impl Drop for Bar {\n+    fn drop(&mut self) {\n+        println!(\"dropping bar!\");\n+    }\n+}\n+\n+// should error\n+struct Baz;\n+\n+\n+\n+fn main() {}"}, {"sha": "75232b0334df6c9153bc927021b4dfd611f75c48", "filename": "tests/ui/empty_drop.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fempty_drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fempty_drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fempty_drop.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -0,0 +1,30 @@\n+// run-rustfix\n+#![warn(clippy::empty_drop)]\n+#![allow(unused)]\n+\n+// should cause an error\n+struct Foo;\n+\n+impl Drop for Foo {\n+    fn drop(&mut self) {}\n+}\n+\n+// shouldn't cause an error\n+struct Bar;\n+\n+impl Drop for Bar {\n+    fn drop(&mut self) {\n+        println!(\"dropping bar!\");\n+    }\n+}\n+\n+// should error\n+struct Baz;\n+\n+impl Drop for Baz {\n+    fn drop(&mut self) {\n+        {}\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "70f7880d03601314e4ea7bd40f6b8d0098b3dd8a", "filename": "tests/ui/empty_drop.stderr", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fempty_drop.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fempty_drop.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fempty_drop.stderr?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -0,0 +1,22 @@\n+error: empty drop implementation\n+  --> $DIR/empty_drop.rs:8:1\n+   |\n+LL | / impl Drop for Foo {\n+LL | |     fn drop(&mut self) {}\n+LL | | }\n+   | |_^ help: try removing this impl\n+   |\n+   = note: `-D clippy::empty-drop` implied by `-D warnings`\n+\n+error: empty drop implementation\n+  --> $DIR/empty_drop.rs:24:1\n+   |\n+LL | / impl Drop for Baz {\n+LL | |     fn drop(&mut self) {\n+LL | |         {}\n+LL | |     }\n+LL | | }\n+   | |_^ help: try removing this impl\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "6c2272f4dff97f350344b4fbb66fc5d4ba4cb146", "filename": "tests/ui/eta.fixed", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Feta.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Feta.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Feta.fixed?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -37,7 +37,7 @@ fn main() {\n     }\n \n     // See #815\n-    let e = Some(1u8).map(divergent);\n+    let e = Some(1u8).map(|a| divergent(a));\n     let e = Some(1u8).map(generic);\n     let e = Some(1u8).map(generic);\n     // See #515\n@@ -211,6 +211,10 @@ fn mutable_closure_in_loop() {\n     let mut closure = |n| value += n;\n     for _ in 0..5 {\n         Some(1).map(&mut closure);\n+\n+        let mut value = 0;\n+        let mut in_loop = |n| value += n;\n+        Some(1).map(in_loop);\n     }\n }\n \n@@ -229,7 +233,7 @@ fn late_bound_lifetimes() {\n     {\n     }\n     map_str(|s| take_asref_path(s));\n-    map_str_to_path(std::convert::AsRef::as_ref);\n+    map_str_to_path(|s| s.as_ref());\n }\n \n mod type_param_bound {\n@@ -275,3 +279,15 @@ mod bind_by_ref {\n         Some(A).map(|ref a| B::from(a));\n     }\n }\n+\n+// #7812 False positive on coerced closure\n+fn coerced_closure() {\n+    fn function_returning_unit<F: FnMut(i32)>(f: F) {}\n+    function_returning_unit(|x| std::process::exit(x));\n+\n+    fn arr() -> &'static [u8; 0] {\n+        &[]\n+    }\n+    fn slice_fn(_: impl FnOnce() -> &'static [u8]) {}\n+    slice_fn(|| arr());\n+}"}, {"sha": "a1a9c0dfbf381d64ae7f47d3fdc46cb1e981ad69", "filename": "tests/ui/eta.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Feta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Feta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Feta.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -211,6 +211,10 @@ fn mutable_closure_in_loop() {\n     let mut closure = |n| value += n;\n     for _ in 0..5 {\n         Some(1).map(|n| closure(n));\n+\n+        let mut value = 0;\n+        let mut in_loop = |n| value += n;\n+        Some(1).map(|n| in_loop(n));\n     }\n }\n \n@@ -275,3 +279,15 @@ mod bind_by_ref {\n         Some(A).map(|ref a| B::from(a));\n     }\n }\n+\n+// #7812 False positive on coerced closure\n+fn coerced_closure() {\n+    fn function_returning_unit<F: FnMut(i32)>(f: F) {}\n+    function_returning_unit(|x| std::process::exit(x));\n+\n+    fn arr() -> &'static [u8; 0] {\n+        &[]\n+    }\n+    fn slice_fn(_: impl FnOnce() -> &'static [u8]) {}\n+    slice_fn(|| arr());\n+}"}, {"sha": "bf2e97e744ab348d639991e748d71df3d87c1b82", "filename": "tests/ui/eta.stderr", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Feta.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Feta.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Feta.stderr?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -24,12 +24,6 @@ error: redundant closure\n LL |     all(&[1, 2, 3], &&2, |x, y| below(x, y)); //is adjusted\n    |                          ^^^^^^^^^^^^^^^^^^ help: replace the closure with the function itself: `below`\n \n-error: redundant closure\n-  --> $DIR/eta.rs:40:27\n-   |\n-LL |     let e = Some(1u8).map(|a| divergent(a));\n-   |                           ^^^^^^^^^^^^^^^^ help: replace the closure with the function itself: `divergent`\n-\n error: redundant closure\n   --> $DIR/eta.rs:41:27\n    |\n@@ -117,10 +111,10 @@ LL |         Some(1).map(|n| closure(n));\n    |                     ^^^^^^^^^^^^^^ help: replace the closure with the function itself: `&mut closure`\n \n error: redundant closure\n-  --> $DIR/eta.rs:232:21\n+  --> $DIR/eta.rs:217:21\n    |\n-LL |     map_str_to_path(|s| s.as_ref());\n-   |                     ^^^^^^^^^^^^^^ help: replace the closure with the method itself: `std::convert::AsRef::as_ref`\n+LL |         Some(1).map(|n| in_loop(n));\n+   |                     ^^^^^^^^^^^^^^ help: replace the closure with the function itself: `in_loop`\n \n-error: aborting due to 20 previous errors\n+error: aborting due to 19 previous errors\n "}, {"sha": "f76127a7105fd5333dc9cca49947f943f394cf21", "filename": "tests/ui/extra_unused_lifetimes.rs", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fextra_unused_lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fextra_unused_lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fextra_unused_lifetimes.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -72,4 +72,46 @@ mod issue4291 {\n     }\n }\n \n+mod issue6437 {\n+    pub struct Scalar;\n+\n+    impl<'a> std::ops::AddAssign<&Scalar> for &mut Scalar {\n+        fn add_assign(&mut self, _rhs: &Scalar) {\n+            unimplemented!();\n+        }\n+    }\n+\n+    impl<'b> Scalar {\n+        pub fn something<'c>() -> Self {\n+            Self\n+        }\n+    }\n+}\n+\n+// https://github.com/rust-lang/rust-clippy/pull/8737#pullrequestreview-951268213\n+mod first_case {\n+    use serde::de::Visitor;\n+    pub trait Expected {\n+        fn fmt(&self, formatter: &mut std::fmt::Formatter);\n+    }\n+\n+    impl<'de, T> Expected for T\n+    where\n+        T: Visitor<'de>,\n+    {\n+        fn fmt(&self, formatter: &mut std::fmt::Formatter) {}\n+    }\n+}\n+\n+// https://github.com/rust-lang/rust-clippy/pull/8737#pullrequestreview-951268213\n+mod second_case {\n+    pub trait Source {\n+        fn hey();\n+    }\n+\n+    impl<'a, T: Source + ?Sized + 'a> Source for Box<T> {\n+        fn hey() {}\n+    }\n+}\n+\n fn main() {}"}, {"sha": "fcc12d4ce14b95977f4a5f46e4509b0b32dac7c6", "filename": "tests/ui/extra_unused_lifetimes.stderr", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fextra_unused_lifetimes.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fextra_unused_lifetimes.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fextra_unused_lifetimes.stderr?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -18,5 +18,23 @@ error: this lifetime isn't used in the function definition\n LL |         fn unused_lt<'a>(x: u8) {}\n    |                      ^^\n \n-error: aborting due to 3 previous errors\n+error: this lifetime isn't used in the impl\n+  --> $DIR/extra_unused_lifetimes.rs:78:10\n+   |\n+LL |     impl<'a> std::ops::AddAssign<&Scalar> for &mut Scalar {\n+   |          ^^\n+\n+error: this lifetime isn't used in the impl\n+  --> $DIR/extra_unused_lifetimes.rs:84:10\n+   |\n+LL |     impl<'b> Scalar {\n+   |          ^^\n+\n+error: this lifetime isn't used in the function definition\n+  --> $DIR/extra_unused_lifetimes.rs:85:26\n+   |\n+LL |         pub fn something<'c>() -> Self {\n+   |                          ^^\n+\n+error: aborting due to 6 previous errors\n "}, {"sha": "4db13d650eb18f8b734e7b36e57ec9e3d7d40d30", "filename": "tests/ui/format_push_string.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fformat_push_string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fformat_push_string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fformat_push_string.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -0,0 +1,7 @@\n+#![warn(clippy::format_push_string)]\n+\n+fn main() {\n+    let mut string = String::new();\n+    string += &format!(\"{:?}\", 1234);\n+    string.push_str(&format!(\"{:?}\", 5678));\n+}"}, {"sha": "953784bcc0684748ba65d296931fb27fb8015c04", "filename": "tests/ui/format_push_string.stderr", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fformat_push_string.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fformat_push_string.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fformat_push_string.stderr?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -0,0 +1,19 @@\n+error: `format!(..)` appended to existing `String`\n+  --> $DIR/format_push_string.rs:5:5\n+   |\n+LL |     string += &format!(\"{:?}\", 1234);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `-D clippy::format-push-string` implied by `-D warnings`\n+   = help: consider using `write!` to avoid the extra allocation\n+\n+error: `format!(..)` appended to existing `String`\n+  --> $DIR/format_push_string.rs:6:5\n+   |\n+LL |     string.push_str(&format!(\"{:?}\", 5678));\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider using `write!` to avoid the extra allocation\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "fec54d00ccb4b8869b90a7c4cdb55e510f8ff543", "filename": "tests/ui/identity_op.rs", "status": "modified", "additions": 33, "deletions": 1, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fidentity_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fidentity_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fidentity_op.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -1,3 +1,5 @@\n+use std::fmt::Write as _;\n+\n const ONE: i64 = 1;\n const NEG_ONE: i64 = -1;\n const ZERO: i64 = 0;\n@@ -7,7 +9,7 @@ struct A(String);\n impl std::ops::Shl<i32> for A {\n     type Output = A;\n     fn shl(mut self, other: i32) -> Self {\n-        self.0.push_str(&format!(\"{}\", other));\n+        let _ = write!(self.0, \"{}\", other);\n         self\n     }\n }\n@@ -75,4 +77,34 @@ fn main() {\n     (x + 1) % 3; // no error\n     4 % 3; // no error\n     4 % -3; // no error\n+\n+    // See #8724\n+    let a = 0;\n+    let b = true;\n+    0 + if b { 1 } else { 2 };\n+    0 + if b { 1 } else { 2 } + if b { 3 } else { 4 }; // no error\n+    0 + match a { 0 => 10, _ => 20 };\n+    0 + match a { 0 => 10, _ => 20 } + match a { 0 => 30, _ => 40 }; // no error\n+    0 + if b { 1 } else { 2 } + match a { 0 => 30, _ => 40 }; // no error\n+    0 + match a { 0 => 10, _ => 20 } + if b { 3 } else { 4 }; // no error\n+    \n+    0 + if b { 0 + 1 } else { 2 };\n+    0 + match a { 0 =>  0 + 10, _ => 20 };\n+    0 + if b { 0 + 1 } else { 2 } + match a { 0 => 0 + 30, _ => 40 };\n+\n+    let _ = 0 + if 0 + 1 > 0 { 1 } else { 2 } + if 0 + 1 > 0 { 3 } else { 4 };\n+    let _ = 0 + match 0 + 1 { 0 => 10, _ => 20 } + match 0 + 1  { 0 => 30, _ => 40 };\n+\n+    0 + if b { 1 } else { 2 } + if b { 3 } else { 4 } + 0;\n+    \n+    0 + { a } + 3; // no error\n+    0 + loop { let mut c = 0; if c == 10 { break c; } c += 1; } + { a * 2 }; // no error\n+    \n+    fn f(_: i32) {\n+        todo!();\n+    }\n+    f(1 * a + { 8 * 5 });\n+    f(0 + if b { 1 } else { 2 } + 3); // no error\n+    const _: i32 = { 2 * 4 } + 0 + 3;\n+    const _: i32 = 0 + { 1 + 2 * 3 } + 3; // no error\n }"}, {"sha": "d8cb65839cbba5595b6c1cc422427ca30603983b", "filename": "tests/ui/identity_op.stderr", "status": "modified", "additions": 109, "deletions": 19, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fidentity_op.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fidentity_op.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fidentity_op.stderr?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -1,112 +1,202 @@\n error: the operation is ineffective. Consider reducing it to `x`\n-  --> $DIR/identity_op.rs:37:5\n+  --> $DIR/identity_op.rs:39:5\n    |\n LL |     x + 0;\n    |     ^^^^^\n    |\n    = note: `-D clippy::identity-op` implied by `-D warnings`\n \n error: the operation is ineffective. Consider reducing it to `x`\n-  --> $DIR/identity_op.rs:38:5\n+  --> $DIR/identity_op.rs:40:5\n    |\n LL |     x + (1 - 1);\n    |     ^^^^^^^^^^^\n \n error: the operation is ineffective. Consider reducing it to `x`\n-  --> $DIR/identity_op.rs:40:5\n+  --> $DIR/identity_op.rs:42:5\n    |\n LL |     0 + x;\n    |     ^^^^^\n \n error: the operation is ineffective. Consider reducing it to `x`\n-  --> $DIR/identity_op.rs:43:5\n+  --> $DIR/identity_op.rs:45:5\n    |\n LL |     x | (0);\n    |     ^^^^^^^\n \n error: the operation is ineffective. Consider reducing it to `x`\n-  --> $DIR/identity_op.rs:46:5\n+  --> $DIR/identity_op.rs:48:5\n    |\n LL |     x * 1;\n    |     ^^^^^\n \n error: the operation is ineffective. Consider reducing it to `x`\n-  --> $DIR/identity_op.rs:47:5\n+  --> $DIR/identity_op.rs:49:5\n    |\n LL |     1 * x;\n    |     ^^^^^\n \n error: the operation is ineffective. Consider reducing it to `x`\n-  --> $DIR/identity_op.rs:53:5\n+  --> $DIR/identity_op.rs:55:5\n    |\n LL |     -1 & x;\n    |     ^^^^^^\n \n error: the operation is ineffective. Consider reducing it to `u`\n-  --> $DIR/identity_op.rs:56:5\n+  --> $DIR/identity_op.rs:58:5\n    |\n LL |     u & 255;\n    |     ^^^^^^^\n \n error: the operation is ineffective. Consider reducing it to `42`\n-  --> $DIR/identity_op.rs:59:5\n+  --> $DIR/identity_op.rs:61:5\n    |\n LL |     42 << 0;\n    |     ^^^^^^^\n \n error: the operation is ineffective. Consider reducing it to `1`\n-  --> $DIR/identity_op.rs:60:5\n+  --> $DIR/identity_op.rs:62:5\n    |\n LL |     1 >> 0;\n    |     ^^^^^^\n \n error: the operation is ineffective. Consider reducing it to `42`\n-  --> $DIR/identity_op.rs:61:5\n+  --> $DIR/identity_op.rs:63:5\n    |\n LL |     42 >> 0;\n    |     ^^^^^^^\n \n error: the operation is ineffective. Consider reducing it to `&x`\n-  --> $DIR/identity_op.rs:62:5\n+  --> $DIR/identity_op.rs:64:5\n    |\n LL |     &x >> 0;\n    |     ^^^^^^^\n \n error: the operation is ineffective. Consider reducing it to `x`\n-  --> $DIR/identity_op.rs:63:5\n+  --> $DIR/identity_op.rs:65:5\n    |\n LL |     x >> &0;\n    |     ^^^^^^^\n \n error: the operation is ineffective. Consider reducing it to `2`\n-  --> $DIR/identity_op.rs:70:5\n+  --> $DIR/identity_op.rs:72:5\n    |\n LL |     2 % 3;\n    |     ^^^^^\n \n error: the operation is ineffective. Consider reducing it to `-2`\n-  --> $DIR/identity_op.rs:71:5\n+  --> $DIR/identity_op.rs:73:5\n    |\n LL |     -2 % 3;\n    |     ^^^^^^\n \n error: the operation is ineffective. Consider reducing it to `2`\n-  --> $DIR/identity_op.rs:72:5\n+  --> $DIR/identity_op.rs:74:5\n    |\n LL |     2 % -3 + x;\n    |     ^^^^^^\n \n error: the operation is ineffective. Consider reducing it to `-2`\n-  --> $DIR/identity_op.rs:73:5\n+  --> $DIR/identity_op.rs:75:5\n    |\n LL |     -2 % -3 + x;\n    |     ^^^^^^^\n \n error: the operation is ineffective. Consider reducing it to `1`\n-  --> $DIR/identity_op.rs:74:9\n+  --> $DIR/identity_op.rs:76:9\n    |\n LL |     x + 1 % 3;\n    |         ^^^^^\n \n-error: aborting due to 18 previous errors\n+error: the operation is ineffective. Consider reducing it to `if b { 1 } else { 2 }`\n+  --> $DIR/identity_op.rs:84:5\n+   |\n+LL |     0 + if b { 1 } else { 2 };\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: the operation is ineffective. Consider reducing it to `match a { 0 => 10, _ => 20 }`\n+  --> $DIR/identity_op.rs:86:5\n+   |\n+LL |     0 + match a { 0 => 10, _ => 20 };\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: the operation is ineffective. Consider reducing it to `if b { 0 + 1 } else { 2 }`\n+  --> $DIR/identity_op.rs:91:5\n+   |\n+LL |     0 + if b { 0 + 1 } else { 2 };\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: the operation is ineffective. Consider reducing it to `1`\n+  --> $DIR/identity_op.rs:91:16\n+   |\n+LL |     0 + if b { 0 + 1 } else { 2 };\n+   |                ^^^^^\n+\n+error: the operation is ineffective. Consider reducing it to `match a { 0 =>  0 + 10, _ => 20 }`\n+  --> $DIR/identity_op.rs:92:5\n+   |\n+LL |     0 + match a { 0 =>  0 + 10, _ => 20 };\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: the operation is ineffective. Consider reducing it to `10`\n+  --> $DIR/identity_op.rs:92:25\n+   |\n+LL |     0 + match a { 0 =>  0 + 10, _ => 20 };\n+   |                         ^^^^^^\n+\n+error: the operation is ineffective. Consider reducing it to `1`\n+  --> $DIR/identity_op.rs:93:16\n+   |\n+LL |     0 + if b { 0 + 1 } else { 2 } + match a { 0 => 0 + 30, _ => 40 };\n+   |                ^^^^^\n+\n+error: the operation is ineffective. Consider reducing it to `30`\n+  --> $DIR/identity_op.rs:93:52\n+   |\n+LL |     0 + if b { 0 + 1 } else { 2 } + match a { 0 => 0 + 30, _ => 40 };\n+   |                                                    ^^^^^^\n+\n+error: the operation is ineffective. Consider reducing it to `1`\n+  --> $DIR/identity_op.rs:95:20\n+   |\n+LL |     let _ = 0 + if 0 + 1 > 0 { 1 } else { 2 } + if 0 + 1 > 0 { 3 } else { 4 };\n+   |                    ^^^^^\n+\n+error: the operation is ineffective. Consider reducing it to `1`\n+  --> $DIR/identity_op.rs:95:52\n+   |\n+LL |     let _ = 0 + if 0 + 1 > 0 { 1 } else { 2 } + if 0 + 1 > 0 { 3 } else { 4 };\n+   |                                                    ^^^^^\n+\n+error: the operation is ineffective. Consider reducing it to `1`\n+  --> $DIR/identity_op.rs:96:23\n+   |\n+LL |     let _ = 0 + match 0 + 1 { 0 => 10, _ => 20 } + match 0 + 1  { 0 => 30, _ => 40 };\n+   |                       ^^^^^\n+\n+error: the operation is ineffective. Consider reducing it to `1`\n+  --> $DIR/identity_op.rs:96:58\n+   |\n+LL |     let _ = 0 + match 0 + 1 { 0 => 10, _ => 20 } + match 0 + 1  { 0 => 30, _ => 40 };\n+   |                                                          ^^^^^\n+\n+error: the operation is ineffective. Consider reducing it to `0 + if b { 1 } else { 2 } + if b { 3 } else { 4 }`\n+  --> $DIR/identity_op.rs:98:5\n+   |\n+LL |     0 + if b { 1 } else { 2 } + if b { 3 } else { 4 } + 0;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: the operation is ineffective. Consider reducing it to `a`\n+  --> $DIR/identity_op.rs:106:7\n+   |\n+LL |     f(1 * a + { 8 * 5 });\n+   |       ^^^^^\n+\n+error: the operation is ineffective. Consider reducing it to `{ 2 * 4 }`\n+  --> $DIR/identity_op.rs:108:20\n+   |\n+LL |     const _: i32 = { 2 * 4 } + 0 + 3;\n+   |                    ^^^^^^^^^^^^^\n+\n+error: aborting due to 33 previous errors\n "}, {"sha": "aea52a852f987d6ab86d899240c9ed81cd3cddc3", "filename": "tests/ui/impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fimpl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fimpl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -1,4 +1,4 @@\n-#![allow(dead_code)]\n+#![allow(dead_code, clippy::extra_unused_lifetimes)]\n #![warn(clippy::multiple_inherent_impl)]\n \n struct MyStruct;"}, {"sha": "c0ba647d707918cbef380c7d9a0cbb7fe02e83d0", "filename": "tests/ui/is_digit_ascii_radix.fixed", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fis_digit_ascii_radix.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fis_digit_ascii_radix.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fis_digit_ascii_radix.fixed?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -0,0 +1,18 @@\n+// run-rustfix\n+\n+#![warn(clippy::is_digit_ascii_radix)]\n+\n+const TEN: u32 = 10;\n+\n+fn main() {\n+    let c: char = '6';\n+\n+    // Should trigger the lint.\n+    let _ = c.is_ascii_digit();\n+    let _ = c.is_ascii_hexdigit();\n+    let _ = c.is_ascii_hexdigit();\n+\n+    // Should not trigger the lint.\n+    let _ = c.is_digit(11);\n+    let _ = c.is_digit(TEN);\n+}"}, {"sha": "68e3f3243d96dabb8f47af2cd321a3ad04d66989", "filename": "tests/ui/is_digit_ascii_radix.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fis_digit_ascii_radix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fis_digit_ascii_radix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fis_digit_ascii_radix.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -0,0 +1,18 @@\n+// run-rustfix\n+\n+#![warn(clippy::is_digit_ascii_radix)]\n+\n+const TEN: u32 = 10;\n+\n+fn main() {\n+    let c: char = '6';\n+\n+    // Should trigger the lint.\n+    let _ = c.is_digit(10);\n+    let _ = c.is_digit(16);\n+    let _ = c.is_digit(0x10);\n+\n+    // Should not trigger the lint.\n+    let _ = c.is_digit(11);\n+    let _ = c.is_digit(TEN);\n+}"}, {"sha": "dc5cb2913ae151c463aba06fb78cf21da04b3914", "filename": "tests/ui/is_digit_ascii_radix.stderr", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fis_digit_ascii_radix.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fis_digit_ascii_radix.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fis_digit_ascii_radix.stderr?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -0,0 +1,22 @@\n+error: use of `char::is_digit` with literal radix of 10\n+  --> $DIR/is_digit_ascii_radix.rs:11:13\n+   |\n+LL |     let _ = c.is_digit(10);\n+   |             ^^^^^^^^^^^^^^ help: try: `c.is_ascii_digit()`\n+   |\n+   = note: `-D clippy::is-digit-ascii-radix` implied by `-D warnings`\n+\n+error: use of `char::is_digit` with literal radix of 16\n+  --> $DIR/is_digit_ascii_radix.rs:12:13\n+   |\n+LL |     let _ = c.is_digit(16);\n+   |             ^^^^^^^^^^^^^^ help: try: `c.is_ascii_hexdigit()`\n+\n+error: use of `char::is_digit` with literal radix of 16\n+  --> $DIR/is_digit_ascii_radix.rs:13:13\n+   |\n+LL |     let _ = c.is_digit(0x10);\n+   |             ^^^^^^^^^^^^^^^^ help: try: `c.is_ascii_hexdigit()`\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "7c2b05d837ba89828bff9c637927f78e54cbc2b6", "filename": "tests/ui/iter_overeager_cloned.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fiter_overeager_cloned.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fiter_overeager_cloned.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fiter_overeager_cloned.fixed?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -1,6 +1,6 @@\n // run-rustfix\n #![warn(clippy::iter_overeager_cloned, clippy::redundant_clone, clippy::filter_next)]\n-#![allow(dead_code)]\n+#![allow(dead_code, clippy::let_unit_value)]\n \n fn main() {\n     let vec = vec![\"1\".to_string(), \"2\".to_string(), \"3\".to_string()];"}, {"sha": "f2d0b155d2c2aa20553caee5e59618d6fc1e923f", "filename": "tests/ui/iter_overeager_cloned.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fiter_overeager_cloned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fiter_overeager_cloned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fiter_overeager_cloned.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -1,6 +1,6 @@\n // run-rustfix\n #![warn(clippy::iter_overeager_cloned, clippy::redundant_clone, clippy::filter_next)]\n-#![allow(dead_code)]\n+#![allow(dead_code, clippy::let_unit_value)]\n \n fn main() {\n     let vec = vec![\"1\".to_string(), \"2\".to_string(), \"3\".to_string()];"}, {"sha": "0330d5549264a122a1c43deee1dfbe41dcea55a3", "filename": "tests/ui/iter_with_drain.fixed", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fiter_with_drain.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fiter_with_drain.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fiter_with_drain.fixed?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -39,6 +39,15 @@ fn should_not_help() {\n     let _: Vec<_> = b.drain(0..a.len()).collect();\n }\n \n+fn _closed_range(mut x: Vec<String>) {\n+    let _: Vec<String> = x.drain(0..=x.len()).collect();\n+}\n+\n+fn _with_mut(x: &mut Vec<String>, y: &mut VecDeque<String>) {\n+    let _: Vec<String> = x.drain(..).collect();\n+    let _: Vec<String> = y.drain(..).collect();\n+}\n+\n #[derive(Default)]\n struct Bomb {\n     fire: Vec<u8>,"}, {"sha": "993936fb8de3d5b345ebcd2ef233e27c24f08420", "filename": "tests/ui/iter_with_drain.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fiter_with_drain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fiter_with_drain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fiter_with_drain.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -39,6 +39,15 @@ fn should_not_help() {\n     let _: Vec<_> = b.drain(0..a.len()).collect();\n }\n \n+fn _closed_range(mut x: Vec<String>) {\n+    let _: Vec<String> = x.drain(0..=x.len()).collect();\n+}\n+\n+fn _with_mut(x: &mut Vec<String>, y: &mut VecDeque<String>) {\n+    let _: Vec<String> = x.drain(..).collect();\n+    let _: Vec<String> = y.drain(..).collect();\n+}\n+\n #[derive(Default)]\n struct Bomb {\n     fire: Vec<u8>,"}, {"sha": "11b50492ab29055ec6223164a2a768a53b9083a8", "filename": "tests/ui/let_underscore_drop.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Flet_underscore_drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Flet_underscore_drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flet_underscore_drop.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -1,4 +1,5 @@\n #![warn(clippy::let_underscore_drop)]\n+#![allow(clippy::let_unit_value)]\n \n struct Droppable;\n "}, {"sha": "ee7bbe995f1684e28bbf064d9cd79cdb2e6c4257", "filename": "tests/ui/let_underscore_drop.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Flet_underscore_drop.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Flet_underscore_drop.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flet_underscore_drop.stderr?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -1,5 +1,5 @@\n error: non-binding `let` on a type that implements `Drop`\n-  --> $DIR/let_underscore_drop.rs:16:5\n+  --> $DIR/let_underscore_drop.rs:17:5\n    |\n LL |     let _ = Box::new(());\n    |     ^^^^^^^^^^^^^^^^^^^^^\n@@ -8,15 +8,15 @@ LL |     let _ = Box::new(());\n    = help: consider using an underscore-prefixed named binding or dropping explicitly with `std::mem::drop`\n \n error: non-binding `let` on a type that implements `Drop`\n-  --> $DIR/let_underscore_drop.rs:17:5\n+  --> $DIR/let_underscore_drop.rs:18:5\n    |\n LL |     let _ = Droppable;\n    |     ^^^^^^^^^^^^^^^^^^\n    |\n    = help: consider using an underscore-prefixed named binding or dropping explicitly with `std::mem::drop`\n \n error: non-binding `let` on a type that implements `Drop`\n-  --> $DIR/let_underscore_drop.rs:18:5\n+  --> $DIR/let_underscore_drop.rs:19:5\n    |\n LL |     let _ = Some(Droppable);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^"}, {"sha": "e72b746232551b87861e2783cf5ce3d7d76dfd21", "filename": "tests/ui/let_unit.fixed", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Flet_unit.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Flet_unit.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flet_unit.fixed?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -61,3 +61,55 @@ fn multiline_sugg() {\n \n #[derive(Copy, Clone)]\n pub struct ContainsUnit(()); // should be fine\n+\n+fn _returns_generic() {\n+    fn f<T>() -> T {\n+        unimplemented!()\n+    }\n+    fn f2<T, U>(_: T) -> U {\n+        unimplemented!()\n+    }\n+    fn f3<T>(x: T) -> T {\n+        x\n+    }\n+    fn f4<T>(mut x: Vec<T>) -> T {\n+        x.pop().unwrap()\n+    }\n+\n+    let _: () = f(); // Ok\n+    let _: () = f(); // Lint.\n+\n+    let _: () = f2(0i32); // Ok\n+    let _: () = f2(0i32); // Lint.\n+\n+    f3(()); // Lint\n+    f3(()); // Lint\n+\n+    f4(vec![()]); // Lint\n+    f4(vec![()]); // Lint\n+\n+    // Ok\n+    let _: () = {\n+        let x = 5;\n+        f2(x)\n+    };\n+\n+    let _: () = if true { f() } else { f2(0) }; // Ok\n+    let _: () = if true { f() } else { f2(0) }; // Lint\n+\n+    // Ok\n+    let _: () = match Some(0) {\n+        None => f2(1),\n+        Some(0) => f(),\n+        Some(1) => f2(3),\n+        Some(_) => f2('x'),\n+    };\n+\n+    // Lint\n+    match Some(0) {\n+        None => f2(1),\n+        Some(0) => f(),\n+        Some(1) => f2(3),\n+        Some(_) => (),\n+    };\n+}"}, {"sha": "47ee0a76724792445b8da0bd6465355b43fafb73", "filename": "tests/ui/let_unit.rs", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Flet_unit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Flet_unit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flet_unit.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -61,3 +61,55 @@ fn multiline_sugg() {\n \n #[derive(Copy, Clone)]\n pub struct ContainsUnit(()); // should be fine\n+\n+fn _returns_generic() {\n+    fn f<T>() -> T {\n+        unimplemented!()\n+    }\n+    fn f2<T, U>(_: T) -> U {\n+        unimplemented!()\n+    }\n+    fn f3<T>(x: T) -> T {\n+        x\n+    }\n+    fn f4<T>(mut x: Vec<T>) -> T {\n+        x.pop().unwrap()\n+    }\n+\n+    let _: () = f(); // Ok\n+    let x: () = f(); // Lint.\n+\n+    let _: () = f2(0i32); // Ok\n+    let x: () = f2(0i32); // Lint.\n+\n+    let _: () = f3(()); // Lint\n+    let x: () = f3(()); // Lint\n+\n+    let _: () = f4(vec![()]); // Lint\n+    let x: () = f4(vec![()]); // Lint\n+\n+    // Ok\n+    let _: () = {\n+        let x = 5;\n+        f2(x)\n+    };\n+\n+    let _: () = if true { f() } else { f2(0) }; // Ok\n+    let x: () = if true { f() } else { f2(0) }; // Lint\n+\n+    // Ok\n+    let _: () = match Some(0) {\n+        None => f2(1),\n+        Some(0) => f(),\n+        Some(1) => f2(3),\n+        Some(_) => f2('x'),\n+    };\n+\n+    // Lint\n+    let _: () = match Some(0) {\n+        None => f2(1),\n+        Some(0) => f(),\n+        Some(1) => f2(3),\n+        Some(_) => (),\n+    };\n+}"}, {"sha": "13ec11a6d33e9a9c12cc06f9a8e37facaab385f3", "filename": "tests/ui/let_unit.stderr", "status": "modified", "additions": 70, "deletions": 1, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Flet_unit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Flet_unit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flet_unit.stderr?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -34,5 +34,74 @@ LL +         .map(|_| ())\n LL +         .next()\n  ...\n \n-error: aborting due to 3 previous errors\n+error: this let-binding has unit value\n+  --> $DIR/let_unit.rs:80:5\n+   |\n+LL |     let x: () = f(); // Lint.\n+   |     ^^^^-^^^^^^^^^^^\n+   |         |\n+   |         help: use a wild (`_`) binding: `_`\n+\n+error: this let-binding has unit value\n+  --> $DIR/let_unit.rs:83:5\n+   |\n+LL |     let x: () = f2(0i32); // Lint.\n+   |     ^^^^-^^^^^^^^^^^^^^^^\n+   |         |\n+   |         help: use a wild (`_`) binding: `_`\n+\n+error: this let-binding has unit value\n+  --> $DIR/let_unit.rs:85:5\n+   |\n+LL |     let _: () = f3(()); // Lint\n+   |     ^^^^^^^^^^^^^^^^^^^ help: omit the `let` binding: `f3(());`\n+\n+error: this let-binding has unit value\n+  --> $DIR/let_unit.rs:86:5\n+   |\n+LL |     let x: () = f3(()); // Lint\n+   |     ^^^^^^^^^^^^^^^^^^^ help: omit the `let` binding: `f3(());`\n+\n+error: this let-binding has unit value\n+  --> $DIR/let_unit.rs:88:5\n+   |\n+LL |     let _: () = f4(vec![()]); // Lint\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^ help: omit the `let` binding: `f4(vec![()]);`\n+\n+error: this let-binding has unit value\n+  --> $DIR/let_unit.rs:89:5\n+   |\n+LL |     let x: () = f4(vec![()]); // Lint\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^ help: omit the `let` binding: `f4(vec![()]);`\n+\n+error: this let-binding has unit value\n+  --> $DIR/let_unit.rs:98:5\n+   |\n+LL |     let x: () = if true { f() } else { f2(0) }; // Lint\n+   |     ^^^^-^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |         |\n+   |         help: use a wild (`_`) binding: `_`\n+\n+error: this let-binding has unit value\n+  --> $DIR/let_unit.rs:109:5\n+   |\n+LL | /     let _: () = match Some(0) {\n+LL | |         None => f2(1),\n+LL | |         Some(0) => f(),\n+LL | |         Some(1) => f2(3),\n+LL | |         Some(_) => (),\n+LL | |     };\n+   | |______^\n+   |\n+help: omit the `let` binding\n+   |\n+LL ~     match Some(0) {\n+LL +         None => f2(1),\n+LL +         Some(0) => f(),\n+LL +         Some(1) => f2(3),\n+LL +         Some(_) => (),\n+LL +     };\n+   |\n+\n+error: aborting due to 11 previous errors\n "}, {"sha": "386360dbdcdb8af4e1b91f9039343a26e7d5601e", "filename": "tests/ui/manual_bits.fixed", "status": "modified", "additions": 40, "deletions": 29, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fmanual_bits.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fmanual_bits.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_bits.fixed?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -1,38 +1,44 @@\n // run-rustfix\n \n #![warn(clippy::manual_bits)]\n-#![allow(clippy::no_effect, path_statements, unused_must_use, clippy::unnecessary_operation)]\n+#![allow(\n+    clippy::no_effect,\n+    clippy::useless_conversion,\n+    path_statements,\n+    unused_must_use,\n+    clippy::unnecessary_operation\n+)]\n \n use std::mem::{size_of, size_of_val};\n \n fn main() {\n-    i8::BITS;\n-    i16::BITS;\n-    i32::BITS;\n-    i64::BITS;\n-    i128::BITS;\n-    isize::BITS;\n-\n-    u8::BITS;\n-    u16::BITS;\n-    u32::BITS;\n-    u64::BITS;\n-    u128::BITS;\n-    usize::BITS;\n-\n-    i8::BITS;\n-    i16::BITS;\n-    i32::BITS;\n-    i64::BITS;\n-    i128::BITS;\n-    isize::BITS;\n-\n-    u8::BITS;\n-    u16::BITS;\n-    u32::BITS;\n-    u64::BITS;\n-    u128::BITS;\n-    usize::BITS;\n+    i8::BITS as usize;\n+    i16::BITS as usize;\n+    i32::BITS as usize;\n+    i64::BITS as usize;\n+    i128::BITS as usize;\n+    isize::BITS as usize;\n+\n+    u8::BITS as usize;\n+    u16::BITS as usize;\n+    u32::BITS as usize;\n+    u64::BITS as usize;\n+    u128::BITS as usize;\n+    usize::BITS as usize;\n+\n+    i8::BITS as usize;\n+    i16::BITS as usize;\n+    i32::BITS as usize;\n+    i64::BITS as usize;\n+    i128::BITS as usize;\n+    isize::BITS as usize;\n+\n+    u8::BITS as usize;\n+    u16::BITS as usize;\n+    u32::BITS as usize;\n+    u64::BITS as usize;\n+    u128::BITS as usize;\n+    usize::BITS as usize;\n \n     size_of::<usize>() * 4;\n     4 * size_of::<usize>();\n@@ -42,7 +48,12 @@ fn main() {\n     size_of_val(&0u32) * 8;\n \n     type Word = u32;\n-    Word::BITS;\n+    Word::BITS as usize;\n     type Bool = bool;\n     size_of::<Bool>() * 8;\n+\n+    let _: u32 = u128::BITS as u32;\n+    let _: u32 = u128::BITS.try_into().unwrap();\n+    let _ = (u128::BITS as usize).pow(5);\n+    let _ = &(u128::BITS as usize);\n }"}, {"sha": "62638f047eb015b299d9b8e45afd4489b9b9a364", "filename": "tests/ui/manual_bits.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fmanual_bits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fmanual_bits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_bits.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -1,7 +1,13 @@\n // run-rustfix\n \n #![warn(clippy::manual_bits)]\n-#![allow(clippy::no_effect, path_statements, unused_must_use, clippy::unnecessary_operation)]\n+#![allow(\n+    clippy::no_effect,\n+    clippy::useless_conversion,\n+    path_statements,\n+    unused_must_use,\n+    clippy::unnecessary_operation\n+)]\n \n use std::mem::{size_of, size_of_val};\n \n@@ -45,4 +51,9 @@ fn main() {\n     size_of::<Word>() * 8;\n     type Bool = bool;\n     size_of::<Bool>() * 8;\n+\n+    let _: u32 = (size_of::<u128>() * 8) as u32;\n+    let _: u32 = (size_of::<u128>() * 8).try_into().unwrap();\n+    let _ = (size_of::<u128>() * 8).pow(5);\n+    let _ = &(size_of::<u128>() * 8);\n }"}, {"sha": "69c591a203d3f2c03eb3ccda6690f35192977126", "filename": "tests/ui/manual_bits.stderr", "status": "modified", "additions": 75, "deletions": 51, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fmanual_bits.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fmanual_bits.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_bits.stderr?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -1,154 +1,178 @@\n error: usage of `mem::size_of::<T>()` to obtain the size of `T` in bits\n-  --> $DIR/manual_bits.rs:9:5\n+  --> $DIR/manual_bits.rs:15:5\n    |\n LL |     size_of::<i8>() * 8;\n-   |     ^^^^^^^^^^^^^^^^^^^ help: consider using: `i8::BITS`\n+   |     ^^^^^^^^^^^^^^^^^^^ help: consider using: `i8::BITS as usize`\n    |\n    = note: `-D clippy::manual-bits` implied by `-D warnings`\n \n error: usage of `mem::size_of::<T>()` to obtain the size of `T` in bits\n-  --> $DIR/manual_bits.rs:10:5\n+  --> $DIR/manual_bits.rs:16:5\n    |\n LL |     size_of::<i16>() * 8;\n-   |     ^^^^^^^^^^^^^^^^^^^^ help: consider using: `i16::BITS`\n+   |     ^^^^^^^^^^^^^^^^^^^^ help: consider using: `i16::BITS as usize`\n \n error: usage of `mem::size_of::<T>()` to obtain the size of `T` in bits\n-  --> $DIR/manual_bits.rs:11:5\n+  --> $DIR/manual_bits.rs:17:5\n    |\n LL |     size_of::<i32>() * 8;\n-   |     ^^^^^^^^^^^^^^^^^^^^ help: consider using: `i32::BITS`\n+   |     ^^^^^^^^^^^^^^^^^^^^ help: consider using: `i32::BITS as usize`\n \n error: usage of `mem::size_of::<T>()` to obtain the size of `T` in bits\n-  --> $DIR/manual_bits.rs:12:5\n+  --> $DIR/manual_bits.rs:18:5\n    |\n LL |     size_of::<i64>() * 8;\n-   |     ^^^^^^^^^^^^^^^^^^^^ help: consider using: `i64::BITS`\n+   |     ^^^^^^^^^^^^^^^^^^^^ help: consider using: `i64::BITS as usize`\n \n error: usage of `mem::size_of::<T>()` to obtain the size of `T` in bits\n-  --> $DIR/manual_bits.rs:13:5\n+  --> $DIR/manual_bits.rs:19:5\n    |\n LL |     size_of::<i128>() * 8;\n-   |     ^^^^^^^^^^^^^^^^^^^^^ help: consider using: `i128::BITS`\n+   |     ^^^^^^^^^^^^^^^^^^^^^ help: consider using: `i128::BITS as usize`\n \n error: usage of `mem::size_of::<T>()` to obtain the size of `T` in bits\n-  --> $DIR/manual_bits.rs:14:5\n+  --> $DIR/manual_bits.rs:20:5\n    |\n LL |     size_of::<isize>() * 8;\n-   |     ^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `isize::BITS`\n+   |     ^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `isize::BITS as usize`\n \n error: usage of `mem::size_of::<T>()` to obtain the size of `T` in bits\n-  --> $DIR/manual_bits.rs:16:5\n+  --> $DIR/manual_bits.rs:22:5\n    |\n LL |     size_of::<u8>() * 8;\n-   |     ^^^^^^^^^^^^^^^^^^^ help: consider using: `u8::BITS`\n+   |     ^^^^^^^^^^^^^^^^^^^ help: consider using: `u8::BITS as usize`\n \n error: usage of `mem::size_of::<T>()` to obtain the size of `T` in bits\n-  --> $DIR/manual_bits.rs:17:5\n+  --> $DIR/manual_bits.rs:23:5\n    |\n LL |     size_of::<u16>() * 8;\n-   |     ^^^^^^^^^^^^^^^^^^^^ help: consider using: `u16::BITS`\n+   |     ^^^^^^^^^^^^^^^^^^^^ help: consider using: `u16::BITS as usize`\n \n error: usage of `mem::size_of::<T>()` to obtain the size of `T` in bits\n-  --> $DIR/manual_bits.rs:18:5\n+  --> $DIR/manual_bits.rs:24:5\n    |\n LL |     size_of::<u32>() * 8;\n-   |     ^^^^^^^^^^^^^^^^^^^^ help: consider using: `u32::BITS`\n+   |     ^^^^^^^^^^^^^^^^^^^^ help: consider using: `u32::BITS as usize`\n \n error: usage of `mem::size_of::<T>()` to obtain the size of `T` in bits\n-  --> $DIR/manual_bits.rs:19:5\n+  --> $DIR/manual_bits.rs:25:5\n    |\n LL |     size_of::<u64>() * 8;\n-   |     ^^^^^^^^^^^^^^^^^^^^ help: consider using: `u64::BITS`\n+   |     ^^^^^^^^^^^^^^^^^^^^ help: consider using: `u64::BITS as usize`\n \n error: usage of `mem::size_of::<T>()` to obtain the size of `T` in bits\n-  --> $DIR/manual_bits.rs:20:5\n+  --> $DIR/manual_bits.rs:26:5\n    |\n LL |     size_of::<u128>() * 8;\n-   |     ^^^^^^^^^^^^^^^^^^^^^ help: consider using: `u128::BITS`\n+   |     ^^^^^^^^^^^^^^^^^^^^^ help: consider using: `u128::BITS as usize`\n \n error: usage of `mem::size_of::<T>()` to obtain the size of `T` in bits\n-  --> $DIR/manual_bits.rs:21:5\n+  --> $DIR/manual_bits.rs:27:5\n    |\n LL |     size_of::<usize>() * 8;\n-   |     ^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `usize::BITS`\n+   |     ^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `usize::BITS as usize`\n \n error: usage of `mem::size_of::<T>()` to obtain the size of `T` in bits\n-  --> $DIR/manual_bits.rs:23:5\n+  --> $DIR/manual_bits.rs:29:5\n    |\n LL |     8 * size_of::<i8>();\n-   |     ^^^^^^^^^^^^^^^^^^^ help: consider using: `i8::BITS`\n+   |     ^^^^^^^^^^^^^^^^^^^ help: consider using: `i8::BITS as usize`\n \n error: usage of `mem::size_of::<T>()` to obtain the size of `T` in bits\n-  --> $DIR/manual_bits.rs:24:5\n+  --> $DIR/manual_bits.rs:30:5\n    |\n LL |     8 * size_of::<i16>();\n-   |     ^^^^^^^^^^^^^^^^^^^^ help: consider using: `i16::BITS`\n+   |     ^^^^^^^^^^^^^^^^^^^^ help: consider using: `i16::BITS as usize`\n \n error: usage of `mem::size_of::<T>()` to obtain the size of `T` in bits\n-  --> $DIR/manual_bits.rs:25:5\n+  --> $DIR/manual_bits.rs:31:5\n    |\n LL |     8 * size_of::<i32>();\n-   |     ^^^^^^^^^^^^^^^^^^^^ help: consider using: `i32::BITS`\n+   |     ^^^^^^^^^^^^^^^^^^^^ help: consider using: `i32::BITS as usize`\n \n error: usage of `mem::size_of::<T>()` to obtain the size of `T` in bits\n-  --> $DIR/manual_bits.rs:26:5\n+  --> $DIR/manual_bits.rs:32:5\n    |\n LL |     8 * size_of::<i64>();\n-   |     ^^^^^^^^^^^^^^^^^^^^ help: consider using: `i64::BITS`\n+   |     ^^^^^^^^^^^^^^^^^^^^ help: consider using: `i64::BITS as usize`\n \n error: usage of `mem::size_of::<T>()` to obtain the size of `T` in bits\n-  --> $DIR/manual_bits.rs:27:5\n+  --> $DIR/manual_bits.rs:33:5\n    |\n LL |     8 * size_of::<i128>();\n-   |     ^^^^^^^^^^^^^^^^^^^^^ help: consider using: `i128::BITS`\n+   |     ^^^^^^^^^^^^^^^^^^^^^ help: consider using: `i128::BITS as usize`\n \n error: usage of `mem::size_of::<T>()` to obtain the size of `T` in bits\n-  --> $DIR/manual_bits.rs:28:5\n+  --> $DIR/manual_bits.rs:34:5\n    |\n LL |     8 * size_of::<isize>();\n-   |     ^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `isize::BITS`\n+   |     ^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `isize::BITS as usize`\n \n error: usage of `mem::size_of::<T>()` to obtain the size of `T` in bits\n-  --> $DIR/manual_bits.rs:30:5\n+  --> $DIR/manual_bits.rs:36:5\n    |\n LL |     8 * size_of::<u8>();\n-   |     ^^^^^^^^^^^^^^^^^^^ help: consider using: `u8::BITS`\n+   |     ^^^^^^^^^^^^^^^^^^^ help: consider using: `u8::BITS as usize`\n \n error: usage of `mem::size_of::<T>()` to obtain the size of `T` in bits\n-  --> $DIR/manual_bits.rs:31:5\n+  --> $DIR/manual_bits.rs:37:5\n    |\n LL |     8 * size_of::<u16>();\n-   |     ^^^^^^^^^^^^^^^^^^^^ help: consider using: `u16::BITS`\n+   |     ^^^^^^^^^^^^^^^^^^^^ help: consider using: `u16::BITS as usize`\n \n error: usage of `mem::size_of::<T>()` to obtain the size of `T` in bits\n-  --> $DIR/manual_bits.rs:32:5\n+  --> $DIR/manual_bits.rs:38:5\n    |\n LL |     8 * size_of::<u32>();\n-   |     ^^^^^^^^^^^^^^^^^^^^ help: consider using: `u32::BITS`\n+   |     ^^^^^^^^^^^^^^^^^^^^ help: consider using: `u32::BITS as usize`\n \n error: usage of `mem::size_of::<T>()` to obtain the size of `T` in bits\n-  --> $DIR/manual_bits.rs:33:5\n+  --> $DIR/manual_bits.rs:39:5\n    |\n LL |     8 * size_of::<u64>();\n-   |     ^^^^^^^^^^^^^^^^^^^^ help: consider using: `u64::BITS`\n+   |     ^^^^^^^^^^^^^^^^^^^^ help: consider using: `u64::BITS as usize`\n \n error: usage of `mem::size_of::<T>()` to obtain the size of `T` in bits\n-  --> $DIR/manual_bits.rs:34:5\n+  --> $DIR/manual_bits.rs:40:5\n    |\n LL |     8 * size_of::<u128>();\n-   |     ^^^^^^^^^^^^^^^^^^^^^ help: consider using: `u128::BITS`\n+   |     ^^^^^^^^^^^^^^^^^^^^^ help: consider using: `u128::BITS as usize`\n \n error: usage of `mem::size_of::<T>()` to obtain the size of `T` in bits\n-  --> $DIR/manual_bits.rs:35:5\n+  --> $DIR/manual_bits.rs:41:5\n    |\n LL |     8 * size_of::<usize>();\n-   |     ^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `usize::BITS`\n+   |     ^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `usize::BITS as usize`\n \n error: usage of `mem::size_of::<T>()` to obtain the size of `T` in bits\n-  --> $DIR/manual_bits.rs:45:5\n+  --> $DIR/manual_bits.rs:51:5\n    |\n LL |     size_of::<Word>() * 8;\n-   |     ^^^^^^^^^^^^^^^^^^^^^ help: consider using: `Word::BITS`\n+   |     ^^^^^^^^^^^^^^^^^^^^^ help: consider using: `Word::BITS as usize`\n+\n+error: usage of `mem::size_of::<T>()` to obtain the size of `T` in bits\n+  --> $DIR/manual_bits.rs:55:18\n+   |\n+LL |     let _: u32 = (size_of::<u128>() * 8) as u32;\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `u128::BITS`\n+\n+error: usage of `mem::size_of::<T>()` to obtain the size of `T` in bits\n+  --> $DIR/manual_bits.rs:56:18\n+   |\n+LL |     let _: u32 = (size_of::<u128>() * 8).try_into().unwrap();\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `u128::BITS`\n+\n+error: usage of `mem::size_of::<T>()` to obtain the size of `T` in bits\n+  --> $DIR/manual_bits.rs:57:13\n+   |\n+LL |     let _ = (size_of::<u128>() * 8).pow(5);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `(u128::BITS as usize)`\n+\n+error: usage of `mem::size_of::<T>()` to obtain the size of `T` in bits\n+  --> $DIR/manual_bits.rs:58:14\n+   |\n+LL |     let _ = &(size_of::<u128>() * 8);\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `(u128::BITS as usize)`\n \n-error: aborting due to 25 previous errors\n+error: aborting due to 29 previous errors\n "}, {"sha": "f23c6d69b4c6a4142c008597588e656711c4e2bd", "filename": "tests/ui/manual_non_exhaustive_enum.rs", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fmanual_non_exhaustive_enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fmanual_non_exhaustive_enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_non_exhaustive_enum.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -0,0 +1,78 @@\n+#![warn(clippy::manual_non_exhaustive)]\n+#![allow(unused)]\n+\n+enum E {\n+    A,\n+    B,\n+    #[doc(hidden)]\n+    _C,\n+}\n+\n+// user forgot to remove the marker\n+#[non_exhaustive]\n+enum Ep {\n+    A,\n+    B,\n+    #[doc(hidden)]\n+    _C,\n+}\n+\n+// marker variant does not have doc hidden attribute, should be ignored\n+enum NoDocHidden {\n+    A,\n+    B,\n+    _C,\n+}\n+\n+// name of variant with doc hidden does not start with underscore, should be ignored\n+enum NoUnderscore {\n+    A,\n+    B,\n+    #[doc(hidden)]\n+    C,\n+}\n+\n+// variant with doc hidden is not unit, should be ignored\n+enum NotUnit {\n+    A,\n+    B,\n+    #[doc(hidden)]\n+    _C(bool),\n+}\n+\n+// variant with doc hidden is the only one, should be ignored\n+enum OnlyMarker {\n+    #[doc(hidden)]\n+    _A,\n+}\n+\n+// variant with multiple markers, should be ignored\n+enum MultipleMarkers {\n+    A,\n+    #[doc(hidden)]\n+    _B,\n+    #[doc(hidden)]\n+    _C,\n+}\n+\n+// already non_exhaustive and no markers, should be ignored\n+#[non_exhaustive]\n+enum NonExhaustive {\n+    A,\n+    B,\n+}\n+\n+// marked is used, don't lint\n+enum UsedHidden {\n+    #[doc(hidden)]\n+    _A,\n+    B,\n+    C,\n+}\n+fn foo(x: &mut UsedHidden) {\n+    if matches!(*x, UsedHidden::B) {\n+        *x = UsedHidden::_A;\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "317a45d2cbd596ab306cae15880279b1c49d8dff", "filename": "tests/ui/manual_non_exhaustive_enum.stderr", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fmanual_non_exhaustive_enum.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fmanual_non_exhaustive_enum.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_non_exhaustive_enum.stderr?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -0,0 +1,41 @@\n+error: this seems like a manual implementation of the non-exhaustive pattern\n+  --> $DIR/manual_non_exhaustive_enum.rs:4:1\n+   |\n+LL |   enum E {\n+   |   ^-----\n+   |   |\n+   |  _help: add the attribute: `#[non_exhaustive] enum E`\n+   | |\n+LL | |     A,\n+LL | |     B,\n+LL | |     #[doc(hidden)]\n+LL | |     _C,\n+LL | | }\n+   | |_^\n+   |\n+   = note: `-D clippy::manual-non-exhaustive` implied by `-D warnings`\n+help: remove this variant\n+  --> $DIR/manual_non_exhaustive_enum.rs:8:5\n+   |\n+LL |     _C,\n+   |     ^^\n+\n+error: this seems like a manual implementation of the non-exhaustive pattern\n+  --> $DIR/manual_non_exhaustive_enum.rs:13:1\n+   |\n+LL | / enum Ep {\n+LL | |     A,\n+LL | |     B,\n+LL | |     #[doc(hidden)]\n+LL | |     _C,\n+LL | | }\n+   | |_^\n+   |\n+help: remove this variant\n+  --> $DIR/manual_non_exhaustive_enum.rs:17:5\n+   |\n+LL |     _C,\n+   |     ^^\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "498eee4447b8841cf275d462abf3d957e3c8403f", "filename": "tests/ui/manual_non_exhaustive_struct.rs", "status": "renamed", "additions": 0, "deletions": 63, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fmanual_non_exhaustive_struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fmanual_non_exhaustive_struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_non_exhaustive_struct.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -1,69 +1,6 @@\n #![warn(clippy::manual_non_exhaustive)]\n #![allow(unused)]\n \n-mod enums {\n-    enum E {\n-        A,\n-        B,\n-        #[doc(hidden)]\n-        _C,\n-    }\n-\n-    // user forgot to remove the marker\n-    #[non_exhaustive]\n-    enum Ep {\n-        A,\n-        B,\n-        #[doc(hidden)]\n-        _C,\n-    }\n-\n-    // marker variant does not have doc hidden attribute, should be ignored\n-    enum NoDocHidden {\n-        A,\n-        B,\n-        _C,\n-    }\n-\n-    // name of variant with doc hidden does not start with underscore, should be ignored\n-    enum NoUnderscore {\n-        A,\n-        B,\n-        #[doc(hidden)]\n-        C,\n-    }\n-\n-    // variant with doc hidden is not unit, should be ignored\n-    enum NotUnit {\n-        A,\n-        B,\n-        #[doc(hidden)]\n-        _C(bool),\n-    }\n-\n-    // variant with doc hidden is the only one, should be ignored\n-    enum OnlyMarker {\n-        #[doc(hidden)]\n-        _A,\n-    }\n-\n-    // variant with multiple markers, should be ignored\n-    enum MultipleMarkers {\n-        A,\n-        #[doc(hidden)]\n-        _B,\n-        #[doc(hidden)]\n-        _C,\n-    }\n-\n-    // already non_exhaustive and no markers, should be ignored\n-    #[non_exhaustive]\n-    enum NonExhaustive {\n-        A,\n-        B,\n-    }\n-}\n-\n mod structs {\n     struct S {\n         pub a: i32,", "previous_filename": "tests/ui/manual_non_exhaustive.rs"}, {"sha": "e0766c17b758038c5cbf7a4ef007a3005c91f5c9", "filename": "tests/ui/manual_non_exhaustive_struct.stderr", "status": "renamed", "additions": 10, "deletions": 48, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fmanual_non_exhaustive_struct.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fmanual_non_exhaustive_struct.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_non_exhaustive_struct.stderr?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -1,44 +1,5 @@\n error: this seems like a manual implementation of the non-exhaustive pattern\n-  --> $DIR/manual_non_exhaustive.rs:5:5\n-   |\n-LL |       enum E {\n-   |       ^-----\n-   |       |\n-   |  _____help: add the attribute: `#[non_exhaustive] enum E`\n-   | |\n-LL | |         A,\n-LL | |         B,\n-LL | |         #[doc(hidden)]\n-LL | |         _C,\n-LL | |     }\n-   | |_____^\n-   |\n-   = note: `-D clippy::manual-non-exhaustive` implied by `-D warnings`\n-help: remove this variant\n-  --> $DIR/manual_non_exhaustive.rs:9:9\n-   |\n-LL |         _C,\n-   |         ^^\n-\n-error: this seems like a manual implementation of the non-exhaustive pattern\n-  --> $DIR/manual_non_exhaustive.rs:14:5\n-   |\n-LL | /     enum Ep {\n-LL | |         A,\n-LL | |         B,\n-LL | |         #[doc(hidden)]\n-LL | |         _C,\n-LL | |     }\n-   | |_____^\n-   |\n-help: remove this variant\n-  --> $DIR/manual_non_exhaustive.rs:18:9\n-   |\n-LL |         _C,\n-   |         ^^\n-\n-error: this seems like a manual implementation of the non-exhaustive pattern\n-  --> $DIR/manual_non_exhaustive.rs:68:5\n+  --> $DIR/manual_non_exhaustive_struct.rs:5:5\n    |\n LL |       struct S {\n    |       ^-------\n@@ -51,14 +12,15 @@ LL | |         _c: (),\n LL | |     }\n    | |_____^\n    |\n+   = note: `-D clippy::manual-non-exhaustive` implied by `-D warnings`\n help: remove this field\n-  --> $DIR/manual_non_exhaustive.rs:71:9\n+  --> $DIR/manual_non_exhaustive_struct.rs:8:9\n    |\n LL |         _c: (),\n    |         ^^^^^^\n \n error: this seems like a manual implementation of the non-exhaustive pattern\n-  --> $DIR/manual_non_exhaustive.rs:76:5\n+  --> $DIR/manual_non_exhaustive_struct.rs:13:5\n    |\n LL | /     struct Sp {\n LL | |         pub a: i32,\n@@ -68,36 +30,36 @@ LL | |     }\n    | |_____^\n    |\n help: remove this field\n-  --> $DIR/manual_non_exhaustive.rs:79:9\n+  --> $DIR/manual_non_exhaustive_struct.rs:16:9\n    |\n LL |         _c: (),\n    |         ^^^^^^\n \n error: this seems like a manual implementation of the non-exhaustive pattern\n-  --> $DIR/manual_non_exhaustive.rs:117:5\n+  --> $DIR/manual_non_exhaustive_struct.rs:54:5\n    |\n LL |     struct T(pub i32, pub i32, ());\n    |     --------^^^^^^^^^^^^^^^^^^^^^^^\n    |     |\n    |     help: add the attribute: `#[non_exhaustive] struct T`\n    |\n help: remove this field\n-  --> $DIR/manual_non_exhaustive.rs:117:32\n+  --> $DIR/manual_non_exhaustive_struct.rs:54:32\n    |\n LL |     struct T(pub i32, pub i32, ());\n    |                                ^^\n \n error: this seems like a manual implementation of the non-exhaustive pattern\n-  --> $DIR/manual_non_exhaustive.rs:121:5\n+  --> $DIR/manual_non_exhaustive_struct.rs:58:5\n    |\n LL |     struct Tp(pub i32, pub i32, ());\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n help: remove this field\n-  --> $DIR/manual_non_exhaustive.rs:121:33\n+  --> $DIR/manual_non_exhaustive_struct.rs:58:33\n    |\n LL |     struct Tp(pub i32, pub i32, ());\n    |                                 ^^\n \n-error: aborting due to 6 previous errors\n+error: aborting due to 4 previous errors\n ", "previous_filename": "tests/ui/manual_non_exhaustive.stderr"}, {"sha": "c7ca770434a318c53308c073bbb72ecc3e540749", "filename": "tests/ui/manual_split_once.fixed", "status": "modified", "additions": 104, "deletions": 13, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fmanual_split_once.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fmanual_split_once.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_split_once.fixed?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -2,55 +2,146 @@\n \n #![feature(custom_inner_attributes)]\n #![warn(clippy::manual_split_once)]\n-#![allow(clippy::iter_skip_next, clippy::iter_nth_zero, clippy::needless_splitn)]\n+#![allow(unused, clippy::iter_skip_next, clippy::iter_nth_zero)]\n \n extern crate itertools;\n \n #[allow(unused_imports)]\n use itertools::Itertools;\n \n fn main() {\n-    let _ = Some(\"key=value\".split_once('=').map_or(\"key=value\", |x| x.0));\n     let _ = \"key=value\".splitn(2, '=').nth(2);\n-    let _ = \"key=value\".split_once('=').map_or(\"key=value\", |x| x.0);\n-    let _ = \"key=value\".split_once('=').map_or(\"key=value\", |x| x.0);\n     let _ = \"key=value\".split_once('=').unwrap().1;\n     let _ = \"key=value\".split_once('=').unwrap().1;\n     let (_, _) = \"key=value\".split_once('=').unwrap();\n \n     let s = String::from(\"key=value\");\n-    let _ = s.split_once('=').map_or(&*s, |x| x.0);\n+    let _ = s.split_once('=').unwrap().1;\n \n     let s = Box::<str>::from(\"key=value\");\n-    let _ = s.split_once('=').map_or(&*s, |x| x.0);\n+    let _ = s.split_once('=').unwrap().1;\n \n     let s = &\"key=value\";\n-    let _ = s.split_once('=').map_or(*s, |x| x.0);\n+    let _ = s.split_once('=').unwrap().1;\n \n     fn _f(s: &str) -> Option<&str> {\n-        let _ = s.split_once(\"key=value\").map_or(s, |x| x.0);\n-        let _ = s.split_once(\"key=value\")?.1;\n-        let _ = s.split_once(\"key=value\")?.1;\n+        let _ = s.split_once('=')?.1;\n+        let _ = s.split_once('=')?.1;\n+        let _ = s.rsplit_once('=')?.0;\n+        let _ = s.rsplit_once('=')?.0;\n         None\n     }\n \n     // Don't lint, slices don't have `split_once`\n     let _ = [0, 1, 2].splitn(2, |&x| x == 1).nth(1).unwrap();\n \n     // `rsplitn` gives the results in the reverse order of `rsplit_once`\n-    let _ = \"key=value\".rsplitn(2, '=').next().unwrap();\n     let _ = \"key=value\".rsplit_once('=').unwrap().0;\n-    let _ = \"key=value\".rsplit_once('=').map(|x| x.1);\n     let (_, _) = \"key=value\".rsplit_once('=').map(|(x, y)| (y, x)).unwrap();\n+    let _ = s.rsplit_once('=').map(|x| x.0);\n+}\n+\n+fn indirect() -> Option<()> {\n+    let (l, r) = \"a.b.c\".split_once('.').unwrap();\n+    \n+    \n+\n+    let (l, r) = \"a.b.c\".split_once('.')?;\n+    \n+    \n+\n+    let (l, r) = \"a.b.c\".rsplit_once('.').unwrap();\n+    \n+    \n+\n+    let (l, r) = \"a.b.c\".rsplit_once('.')?;\n+    \n+    \n+\n+    // could lint, currently doesn't\n+\n+    let mut iter = \"a.b.c\".splitn(2, '.');\n+    let other = 1;\n+    let l = iter.next()?;\n+    let r = iter.next()?;\n+\n+    let mut iter = \"a.b.c\".splitn(2, '.');\n+    let mut mut_binding = iter.next()?;\n+    let r = iter.next()?;\n+\n+    let mut iter = \"a.b.c\".splitn(2, '.');\n+    let tuple = (iter.next()?, iter.next()?);\n+\n+    // should not lint\n+\n+    let mut missing_unwrap = \"a.b.c\".splitn(2, '.');\n+    let l = missing_unwrap.next();\n+    let r = missing_unwrap.next();\n+\n+    let mut mixed_unrap = \"a.b.c\".splitn(2, '.');\n+    let unwrap = mixed_unrap.next().unwrap();\n+    let question_mark = mixed_unrap.next()?;\n+\n+    let mut iter = \"a.b.c\".splitn(2, '.');\n+    let same_name = iter.next()?;\n+    let same_name = iter.next()?;\n+\n+    let mut iter = \"a.b.c\".splitn(2, '.');\n+    let shadows_existing = \"d\";\n+    let shadows_existing = iter.next()?;\n+    let r = iter.next()?;\n+\n+    let mut iter = \"a.b.c\".splitn(2, '.');\n+    let becomes_shadowed = iter.next()?;\n+    let becomes_shadowed = \"d\";\n+    let r = iter.next()?;\n+\n+    let mut iter = \"a.b.c\".splitn(2, '.');\n+    let l = iter.next()?;\n+    let r = iter.next()?;\n+    let third_usage = iter.next()?;\n+\n+    let mut n_three = \"a.b.c\".splitn(3, '.');\n+    let l = n_three.next()?;\n+    let r = n_three.next()?;\n+\n+    let mut iter = \"a.b.c\".splitn(2, '.');\n+    {\n+        let in_block = iter.next()?;\n+    }\n+    let r = iter.next()?;\n+\n+    let mut lacks_binding = \"a.b.c\".splitn(2, '.');\n+    let _ = lacks_binding.next()?;\n+    let r = lacks_binding.next()?;\n+\n+    let mut mapped = \"a.b.c\".splitn(2, '.').map(|_| \"~\");\n+    let l = iter.next()?;\n+    let r = iter.next()?;\n+\n+    let mut assigned = \"\";\n+    let mut iter = \"a.b.c\".splitn(2, '.');\n+    let l = iter.next()?;\n+    assigned = iter.next()?;\n+\n+    None\n }\n \n fn _msrv_1_51() {\n     #![clippy::msrv = \"1.51\"]\n-    // `str::split_once` was stabilized in 1.16. Do not lint this\n+    // `str::split_once` was stabilized in 1.52. Do not lint this\n     let _ = \"key=value\".splitn(2, '=').nth(1).unwrap();\n+\n+    let mut iter = \"a.b.c\".splitn(2, '.');\n+    let a = iter.next().unwrap();\n+    let b = iter.next().unwrap();\n }\n \n fn _msrv_1_52() {\n     #![clippy::msrv = \"1.52\"]\n     let _ = \"key=value\".split_once('=').unwrap().1;\n+\n+    let (a, b) = \"a.b.c\".split_once('.').unwrap();\n+    \n+    \n }"}, {"sha": "ee2848a251ee3b2e666c49644a7768597e41782d", "filename": "tests/ui/manual_split_once.rs", "status": "modified", "additions": 104, "deletions": 13, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fmanual_split_once.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fmanual_split_once.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_split_once.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -2,55 +2,146 @@\n \n #![feature(custom_inner_attributes)]\n #![warn(clippy::manual_split_once)]\n-#![allow(clippy::iter_skip_next, clippy::iter_nth_zero, clippy::needless_splitn)]\n+#![allow(unused, clippy::iter_skip_next, clippy::iter_nth_zero)]\n \n extern crate itertools;\n \n #[allow(unused_imports)]\n use itertools::Itertools;\n \n fn main() {\n-    let _ = \"key=value\".splitn(2, '=').next();\n     let _ = \"key=value\".splitn(2, '=').nth(2);\n-    let _ = \"key=value\".splitn(2, '=').next().unwrap();\n-    let _ = \"key=value\".splitn(2, '=').nth(0).unwrap();\n     let _ = \"key=value\".splitn(2, '=').nth(1).unwrap();\n     let _ = \"key=value\".splitn(2, '=').skip(1).next().unwrap();\n     let (_, _) = \"key=value\".splitn(2, '=').next_tuple().unwrap();\n \n     let s = String::from(\"key=value\");\n-    let _ = s.splitn(2, '=').next().unwrap();\n+    let _ = s.splitn(2, '=').nth(1).unwrap();\n \n     let s = Box::<str>::from(\"key=value\");\n-    let _ = s.splitn(2, '=').nth(0).unwrap();\n+    let _ = s.splitn(2, '=').nth(1).unwrap();\n \n     let s = &\"key=value\";\n-    let _ = s.splitn(2, '=').skip(0).next().unwrap();\n+    let _ = s.splitn(2, '=').skip(1).next().unwrap();\n \n     fn _f(s: &str) -> Option<&str> {\n-        let _ = s.splitn(2, \"key=value\").next()?;\n-        let _ = s.splitn(2, \"key=value\").nth(1)?;\n-        let _ = s.splitn(2, \"key=value\").skip(1).next()?;\n+        let _ = s.splitn(2, '=').nth(1)?;\n+        let _ = s.splitn(2, '=').skip(1).next()?;\n+        let _ = s.rsplitn(2, '=').nth(1)?;\n+        let _ = s.rsplitn(2, '=').skip(1).next()?;\n         None\n     }\n \n     // Don't lint, slices don't have `split_once`\n     let _ = [0, 1, 2].splitn(2, |&x| x == 1).nth(1).unwrap();\n \n     // `rsplitn` gives the results in the reverse order of `rsplit_once`\n-    let _ = \"key=value\".rsplitn(2, '=').next().unwrap();\n     let _ = \"key=value\".rsplitn(2, '=').nth(1).unwrap();\n-    let _ = \"key=value\".rsplitn(2, '=').nth(0);\n     let (_, _) = \"key=value\".rsplitn(2, '=').next_tuple().unwrap();\n+    let _ = s.rsplitn(2, '=').nth(1);\n+}\n+\n+fn indirect() -> Option<()> {\n+    let mut iter = \"a.b.c\".splitn(2, '.');\n+    let l = iter.next().unwrap();\n+    let r = iter.next().unwrap();\n+\n+    let mut iter = \"a.b.c\".splitn(2, '.');\n+    let l = iter.next()?;\n+    let r = iter.next()?;\n+\n+    let mut iter = \"a.b.c\".rsplitn(2, '.');\n+    let r = iter.next().unwrap();\n+    let l = iter.next().unwrap();\n+\n+    let mut iter = \"a.b.c\".rsplitn(2, '.');\n+    let r = iter.next()?;\n+    let l = iter.next()?;\n+\n+    // could lint, currently doesn't\n+\n+    let mut iter = \"a.b.c\".splitn(2, '.');\n+    let other = 1;\n+    let l = iter.next()?;\n+    let r = iter.next()?;\n+\n+    let mut iter = \"a.b.c\".splitn(2, '.');\n+    let mut mut_binding = iter.next()?;\n+    let r = iter.next()?;\n+\n+    let mut iter = \"a.b.c\".splitn(2, '.');\n+    let tuple = (iter.next()?, iter.next()?);\n+\n+    // should not lint\n+\n+    let mut missing_unwrap = \"a.b.c\".splitn(2, '.');\n+    let l = missing_unwrap.next();\n+    let r = missing_unwrap.next();\n+\n+    let mut mixed_unrap = \"a.b.c\".splitn(2, '.');\n+    let unwrap = mixed_unrap.next().unwrap();\n+    let question_mark = mixed_unrap.next()?;\n+\n+    let mut iter = \"a.b.c\".splitn(2, '.');\n+    let same_name = iter.next()?;\n+    let same_name = iter.next()?;\n+\n+    let mut iter = \"a.b.c\".splitn(2, '.');\n+    let shadows_existing = \"d\";\n+    let shadows_existing = iter.next()?;\n+    let r = iter.next()?;\n+\n+    let mut iter = \"a.b.c\".splitn(2, '.');\n+    let becomes_shadowed = iter.next()?;\n+    let becomes_shadowed = \"d\";\n+    let r = iter.next()?;\n+\n+    let mut iter = \"a.b.c\".splitn(2, '.');\n+    let l = iter.next()?;\n+    let r = iter.next()?;\n+    let third_usage = iter.next()?;\n+\n+    let mut n_three = \"a.b.c\".splitn(3, '.');\n+    let l = n_three.next()?;\n+    let r = n_three.next()?;\n+\n+    let mut iter = \"a.b.c\".splitn(2, '.');\n+    {\n+        let in_block = iter.next()?;\n+    }\n+    let r = iter.next()?;\n+\n+    let mut lacks_binding = \"a.b.c\".splitn(2, '.');\n+    let _ = lacks_binding.next()?;\n+    let r = lacks_binding.next()?;\n+\n+    let mut mapped = \"a.b.c\".splitn(2, '.').map(|_| \"~\");\n+    let l = iter.next()?;\n+    let r = iter.next()?;\n+\n+    let mut assigned = \"\";\n+    let mut iter = \"a.b.c\".splitn(2, '.');\n+    let l = iter.next()?;\n+    assigned = iter.next()?;\n+\n+    None\n }\n \n fn _msrv_1_51() {\n     #![clippy::msrv = \"1.51\"]\n-    // `str::split_once` was stabilized in 1.16. Do not lint this\n+    // `str::split_once` was stabilized in 1.52. Do not lint this\n     let _ = \"key=value\".splitn(2, '=').nth(1).unwrap();\n+\n+    let mut iter = \"a.b.c\".splitn(2, '.');\n+    let a = iter.next().unwrap();\n+    let b = iter.next().unwrap();\n }\n \n fn _msrv_1_52() {\n     #![clippy::msrv = \"1.52\"]\n     let _ = \"key=value\".splitn(2, '=').nth(1).unwrap();\n+\n+    let mut iter = \"a.b.c\".splitn(2, '.');\n+    let a = iter.next().unwrap();\n+    let b = iter.next().unwrap();\n }"}, {"sha": "2563a6904b77c928bd94e48fa1fc41473e23bd21", "filename": "tests/ui/manual_split_once.stderr", "status": "modified", "additions": 162, "deletions": 49, "changes": 211, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fmanual_split_once.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fmanual_split_once.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmanual_split_once.stderr?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -1,100 +1,213 @@\n error: manual implementation of `split_once`\n-  --> $DIR/manual_split_once.rs:13:13\n+  --> $DIR/manual_split_once.rs:14:13\n    |\n-LL |     let _ = \"key=value\".splitn(2, '=').next();\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `Some(\"key=value\".split_once('=').map_or(\"key=value\", |x| x.0))`\n+LL |     let _ = \"key=value\".splitn(2, '=').nth(1).unwrap();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `\"key=value\".split_once('=').unwrap().1`\n    |\n    = note: `-D clippy::manual-split-once` implied by `-D warnings`\n \n error: manual implementation of `split_once`\n   --> $DIR/manual_split_once.rs:15:13\n    |\n-LL |     let _ = \"key=value\".splitn(2, '=').next().unwrap();\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `\"key=value\".split_once('=').map_or(\"key=value\", |x| x.0)`\n-\n-error: manual implementation of `split_once`\n-  --> $DIR/manual_split_once.rs:16:13\n-   |\n-LL |     let _ = \"key=value\".splitn(2, '=').nth(0).unwrap();\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `\"key=value\".split_once('=').map_or(\"key=value\", |x| x.0)`\n-\n-error: manual implementation of `split_once`\n-  --> $DIR/manual_split_once.rs:17:13\n-   |\n-LL |     let _ = \"key=value\".splitn(2, '=').nth(1).unwrap();\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `\"key=value\".split_once('=').unwrap().1`\n-\n-error: manual implementation of `split_once`\n-  --> $DIR/manual_split_once.rs:18:13\n-   |\n LL |     let _ = \"key=value\".splitn(2, '=').skip(1).next().unwrap();\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `\"key=value\".split_once('=').unwrap().1`\n \n error: manual implementation of `split_once`\n-  --> $DIR/manual_split_once.rs:19:18\n+  --> $DIR/manual_split_once.rs:16:18\n    |\n LL |     let (_, _) = \"key=value\".splitn(2, '=').next_tuple().unwrap();\n    |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `\"key=value\".split_once('=')`\n \n+error: manual implementation of `split_once`\n+  --> $DIR/manual_split_once.rs:19:13\n+   |\n+LL |     let _ = s.splitn(2, '=').nth(1).unwrap();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `s.split_once('=').unwrap().1`\n+\n error: manual implementation of `split_once`\n   --> $DIR/manual_split_once.rs:22:13\n    |\n-LL |     let _ = s.splitn(2, '=').next().unwrap();\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `s.split_once('=').map_or(&*s, |x| x.0)`\n+LL |     let _ = s.splitn(2, '=').nth(1).unwrap();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `s.split_once('=').unwrap().1`\n \n error: manual implementation of `split_once`\n   --> $DIR/manual_split_once.rs:25:13\n    |\n-LL |     let _ = s.splitn(2, '=').nth(0).unwrap();\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `s.split_once('=').map_or(&*s, |x| x.0)`\n+LL |     let _ = s.splitn(2, '=').skip(1).next().unwrap();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `s.split_once('=').unwrap().1`\n \n error: manual implementation of `split_once`\n-  --> $DIR/manual_split_once.rs:28:13\n+  --> $DIR/manual_split_once.rs:28:17\n    |\n-LL |     let _ = s.splitn(2, '=').skip(0).next().unwrap();\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `s.split_once('=').map_or(*s, |x| x.0)`\n+LL |         let _ = s.splitn(2, '=').nth(1)?;\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `s.split_once('=')?.1`\n \n error: manual implementation of `split_once`\n-  --> $DIR/manual_split_once.rs:31:17\n+  --> $DIR/manual_split_once.rs:29:17\n    |\n-LL |         let _ = s.splitn(2, \"key=value\").next()?;\n-   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `s.split_once(\"key=value\").map_or(s, |x| x.0)`\n+LL |         let _ = s.splitn(2, '=').skip(1).next()?;\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `s.split_once('=')?.1`\n \n-error: manual implementation of `split_once`\n-  --> $DIR/manual_split_once.rs:32:17\n+error: manual implementation of `rsplit_once`\n+  --> $DIR/manual_split_once.rs:30:17\n    |\n-LL |         let _ = s.splitn(2, \"key=value\").nth(1)?;\n-   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `s.split_once(\"key=value\")?.1`\n+LL |         let _ = s.rsplitn(2, '=').nth(1)?;\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `s.rsplit_once('=')?.0`\n \n-error: manual implementation of `split_once`\n-  --> $DIR/manual_split_once.rs:33:17\n+error: manual implementation of `rsplit_once`\n+  --> $DIR/manual_split_once.rs:31:17\n    |\n-LL |         let _ = s.splitn(2, \"key=value\").skip(1).next()?;\n-   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `s.split_once(\"key=value\")?.1`\n+LL |         let _ = s.rsplitn(2, '=').skip(1).next()?;\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `s.rsplit_once('=')?.0`\n \n error: manual implementation of `rsplit_once`\n-  --> $DIR/manual_split_once.rs:42:13\n+  --> $DIR/manual_split_once.rs:39:13\n    |\n LL |     let _ = \"key=value\".rsplitn(2, '=').nth(1).unwrap();\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `\"key=value\".rsplit_once('=').unwrap().0`\n \n error: manual implementation of `rsplit_once`\n-  --> $DIR/manual_split_once.rs:43:13\n+  --> $DIR/manual_split_once.rs:40:18\n    |\n-LL |     let _ = \"key=value\".rsplitn(2, '=').nth(0);\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `\"key=value\".rsplit_once('=').map(|x| x.1)`\n+LL |     let (_, _) = \"key=value\".rsplitn(2, '=').next_tuple().unwrap();\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `\"key=value\".rsplit_once('=').map(|(x, y)| (y, x))`\n \n error: manual implementation of `rsplit_once`\n-  --> $DIR/manual_split_once.rs:44:18\n+  --> $DIR/manual_split_once.rs:41:13\n    |\n-LL |     let (_, _) = \"key=value\".rsplitn(2, '=').next_tuple().unwrap();\n-   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `\"key=value\".rsplit_once('=').map(|(x, y)| (y, x))`\n+LL |     let _ = s.rsplitn(2, '=').nth(1);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `s.rsplit_once('=').map(|x| x.0)`\n+\n+error: manual implementation of `split_once`\n+  --> $DIR/manual_split_once.rs:45:5\n+   |\n+LL |     let mut iter = \"a.b.c\".splitn(2, '.');\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     let l = iter.next().unwrap();\n+   |     ----------------------------- first usage here\n+LL |     let r = iter.next().unwrap();\n+   |     ----------------------------- second usage here\n+   |\n+help: try `split_once`\n+   |\n+LL |     let (l, r) = \"a.b.c\".split_once('.').unwrap();\n+   |\n+help: remove the `iter` usages\n+   |\n+LL -     let l = iter.next().unwrap();\n+LL +     \n+   | \n+help: remove the `iter` usages\n+   |\n+LL -     let r = iter.next().unwrap();\n+LL +     \n+   | \n \n error: manual implementation of `split_once`\n-  --> $DIR/manual_split_once.rs:55:13\n+  --> $DIR/manual_split_once.rs:49:5\n+   |\n+LL |     let mut iter = \"a.b.c\".splitn(2, '.');\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     let l = iter.next()?;\n+   |     --------------------- first usage here\n+LL |     let r = iter.next()?;\n+   |     --------------------- second usage here\n+   |\n+help: try `split_once`\n+   |\n+LL |     let (l, r) = \"a.b.c\".split_once('.')?;\n+   |\n+help: remove the `iter` usages\n+   |\n+LL -     let l = iter.next()?;\n+LL +     \n+   | \n+help: remove the `iter` usages\n+   |\n+LL -     let r = iter.next()?;\n+LL +     \n+   | \n+\n+error: manual implementation of `rsplit_once`\n+  --> $DIR/manual_split_once.rs:53:5\n+   |\n+LL |     let mut iter = \"a.b.c\".rsplitn(2, '.');\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     let r = iter.next().unwrap();\n+   |     ----------------------------- first usage here\n+LL |     let l = iter.next().unwrap();\n+   |     ----------------------------- second usage here\n+   |\n+help: try `rsplit_once`\n+   |\n+LL |     let (l, r) = \"a.b.c\".rsplit_once('.').unwrap();\n+   |\n+help: remove the `iter` usages\n+   |\n+LL -     let r = iter.next().unwrap();\n+LL +     \n+   | \n+help: remove the `iter` usages\n+   |\n+LL -     let l = iter.next().unwrap();\n+LL +     \n+   | \n+\n+error: manual implementation of `rsplit_once`\n+  --> $DIR/manual_split_once.rs:57:5\n+   |\n+LL |     let mut iter = \"a.b.c\".rsplitn(2, '.');\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     let r = iter.next()?;\n+   |     --------------------- first usage here\n+LL |     let l = iter.next()?;\n+   |     --------------------- second usage here\n+   |\n+help: try `rsplit_once`\n+   |\n+LL |     let (l, r) = \"a.b.c\".rsplit_once('.')?;\n+   |\n+help: remove the `iter` usages\n+   |\n+LL -     let r = iter.next()?;\n+LL +     \n+   | \n+help: remove the `iter` usages\n+   |\n+LL -     let l = iter.next()?;\n+LL +     \n+   | \n+\n+error: manual implementation of `split_once`\n+  --> $DIR/manual_split_once.rs:142:13\n    |\n LL |     let _ = \"key=value\".splitn(2, '=').nth(1).unwrap();\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `\"key=value\".split_once('=').unwrap().1`\n \n-error: aborting due to 16 previous errors\n+error: manual implementation of `split_once`\n+  --> $DIR/manual_split_once.rs:144:5\n+   |\n+LL |     let mut iter = \"a.b.c\".splitn(2, '.');\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     let a = iter.next().unwrap();\n+   |     ----------------------------- first usage here\n+LL |     let b = iter.next().unwrap();\n+   |     ----------------------------- second usage here\n+   |\n+help: try `split_once`\n+   |\n+LL |     let (a, b) = \"a.b.c\".split_once('.').unwrap();\n+   |\n+help: remove the `iter` usages\n+   |\n+LL -     let a = iter.next().unwrap();\n+LL +     \n+   | \n+help: remove the `iter` usages\n+   |\n+LL -     let b = iter.next().unwrap();\n+LL +     \n+   | \n+\n+error: aborting due to 19 previous errors\n "}, {"sha": "a7b36d53cd26c7cc1011553d0a1ceb2fd88268ae", "filename": "tests/ui/mistyped_literal_suffix.fixed", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fmistyped_literal_suffix.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fmistyped_literal_suffix.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmistyped_literal_suffix.fixed?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -5,7 +5,8 @@\n     unused_variables,\n     overflowing_literals,\n     clippy::excessive_precision,\n-    clippy::inconsistent_digit_grouping\n+    clippy::inconsistent_digit_grouping,\n+    clippy::unusual_byte_groupings\n )]\n \n fn main() {\n@@ -25,5 +26,18 @@ fn main() {\n     let fail28 = 241_251_235E723_f64;\n     let ok29 = 42279.911_32;\n \n+    // testing that the suggestion actually fits in its type\n+    let fail30 = 127_i8; // should be i8\n+    let fail31 = 240_u8; // should be u8\n+    let ok32 = 360_8; // doesnt fit in either, should be ignored\n+    let fail33 = 0x1234_i16;\n+    let fail34 = 0xABCD_u16;\n+    let ok35 = 0x12345_16;\n+    let fail36 = 0xFFFF_FFFF_FFFF_FFFF_u64; // u64\n+\n+    // issue #6129\n+    let ok37 = 123_32.123;\n+    let ok38 = 124_64.0;\n+\n     let _ = 1.123_45E1_f32;\n }"}, {"sha": "c97b31965c75a7c4cd1f3030dccd3b042f23fd7c", "filename": "tests/ui/mistyped_literal_suffix.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fmistyped_literal_suffix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fmistyped_literal_suffix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmistyped_literal_suffix.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -5,7 +5,8 @@\n     unused_variables,\n     overflowing_literals,\n     clippy::excessive_precision,\n-    clippy::inconsistent_digit_grouping\n+    clippy::inconsistent_digit_grouping,\n+    clippy::unusual_byte_groupings\n )]\n \n fn main() {\n@@ -25,5 +26,18 @@ fn main() {\n     let fail28 = 241251235E723_64;\n     let ok29 = 42279.911_32;\n \n+    // testing that the suggestion actually fits in its type\n+    let fail30 = 127_8; // should be i8\n+    let fail31 = 240_8; // should be u8\n+    let ok32 = 360_8; // doesnt fit in either, should be ignored\n+    let fail33 = 0x1234_16;\n+    let fail34 = 0xABCD_16;\n+    let ok35 = 0x12345_16;\n+    let fail36 = 0xFFFF_FFFF_FFFF_FFFF_64; // u64\n+\n+    // issue #6129\n+    let ok37 = 123_32.123;\n+    let ok38 = 124_64.0;\n+\n     let _ = 1.12345E1_32;\n }"}, {"sha": "fb761d9bde45255085e56a861d791d370516c251", "filename": "tests/ui/mistyped_literal_suffix.stderr", "status": "modified", "additions": 42, "deletions": 12, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fmistyped_literal_suffix.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fmistyped_literal_suffix.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmistyped_literal_suffix.stderr?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -1,70 +1,100 @@\n error: mistyped literal suffix\n-  --> $DIR/mistyped_literal_suffix.rs:12:18\n+  --> $DIR/mistyped_literal_suffix.rs:13:18\n    |\n LL |     let fail14 = 2_32;\n    |                  ^^^^ help: did you mean to write: `2_i32`\n    |\n    = note: `#[deny(clippy::mistyped_literal_suffixes)]` on by default\n \n error: mistyped literal suffix\n-  --> $DIR/mistyped_literal_suffix.rs:13:18\n+  --> $DIR/mistyped_literal_suffix.rs:14:18\n    |\n LL |     let fail15 = 4_64;\n    |                  ^^^^ help: did you mean to write: `4_i64`\n \n error: mistyped literal suffix\n-  --> $DIR/mistyped_literal_suffix.rs:14:18\n+  --> $DIR/mistyped_literal_suffix.rs:15:18\n    |\n LL |     let fail16 = 7_8; //\n    |                  ^^^ help: did you mean to write: `7_i8`\n \n error: mistyped literal suffix\n-  --> $DIR/mistyped_literal_suffix.rs:15:18\n+  --> $DIR/mistyped_literal_suffix.rs:16:18\n    |\n LL |     let fail17 = 23_16; //\n    |                  ^^^^^ help: did you mean to write: `23_i16`\n \n error: mistyped literal suffix\n-  --> $DIR/mistyped_literal_suffix.rs:18:18\n+  --> $DIR/mistyped_literal_suffix.rs:19:18\n    |\n LL |     let fail20 = 2__8; //\n    |                  ^^^^ help: did you mean to write: `2_i8`\n \n error: mistyped literal suffix\n-  --> $DIR/mistyped_literal_suffix.rs:19:18\n+  --> $DIR/mistyped_literal_suffix.rs:20:18\n    |\n LL |     let fail21 = 4___16; //\n    |                  ^^^^^^ help: did you mean to write: `4_i16`\n \n error: mistyped literal suffix\n-  --> $DIR/mistyped_literal_suffix.rs:22:18\n+  --> $DIR/mistyped_literal_suffix.rs:23:18\n    |\n LL |     let fail25 = 1E2_32;\n    |                  ^^^^^^ help: did you mean to write: `1E2_f32`\n \n error: mistyped literal suffix\n-  --> $DIR/mistyped_literal_suffix.rs:23:18\n+  --> $DIR/mistyped_literal_suffix.rs:24:18\n    |\n LL |     let fail26 = 43E7_64;\n    |                  ^^^^^^^ help: did you mean to write: `43E7_f64`\n \n error: mistyped literal suffix\n-  --> $DIR/mistyped_literal_suffix.rs:24:18\n+  --> $DIR/mistyped_literal_suffix.rs:25:18\n    |\n LL |     let fail27 = 243E17_32;\n    |                  ^^^^^^^^^ help: did you mean to write: `243E17_f32`\n \n error: mistyped literal suffix\n-  --> $DIR/mistyped_literal_suffix.rs:25:18\n+  --> $DIR/mistyped_literal_suffix.rs:26:18\n    |\n LL |     let fail28 = 241251235E723_64;\n    |                  ^^^^^^^^^^^^^^^^ help: did you mean to write: `241_251_235E723_f64`\n \n error: mistyped literal suffix\n-  --> $DIR/mistyped_literal_suffix.rs:28:13\n+  --> $DIR/mistyped_literal_suffix.rs:30:18\n+   |\n+LL |     let fail30 = 127_8; // should be i8\n+   |                  ^^^^^ help: did you mean to write: `127_i8`\n+\n+error: mistyped literal suffix\n+  --> $DIR/mistyped_literal_suffix.rs:31:18\n+   |\n+LL |     let fail31 = 240_8; // should be u8\n+   |                  ^^^^^ help: did you mean to write: `240_u8`\n+\n+error: mistyped literal suffix\n+  --> $DIR/mistyped_literal_suffix.rs:33:18\n+   |\n+LL |     let fail33 = 0x1234_16;\n+   |                  ^^^^^^^^^ help: did you mean to write: `0x1234_i16`\n+\n+error: mistyped literal suffix\n+  --> $DIR/mistyped_literal_suffix.rs:34:18\n+   |\n+LL |     let fail34 = 0xABCD_16;\n+   |                  ^^^^^^^^^ help: did you mean to write: `0xABCD_u16`\n+\n+error: mistyped literal suffix\n+  --> $DIR/mistyped_literal_suffix.rs:36:18\n+   |\n+LL |     let fail36 = 0xFFFF_FFFF_FFFF_FFFF_64; // u64\n+   |                  ^^^^^^^^^^^^^^^^^^^^^^^^ help: did you mean to write: `0xFFFF_FFFF_FFFF_FFFF_u64`\n+\n+error: mistyped literal suffix\n+  --> $DIR/mistyped_literal_suffix.rs:42:13\n    |\n LL |     let _ = 1.12345E1_32;\n    |             ^^^^^^^^^^^^ help: did you mean to write: `1.123_45E1_f32`\n \n-error: aborting due to 11 previous errors\n+error: aborting due to 16 previous errors\n "}, {"sha": "370dbd5882161c837c4ffd14a531c99aa7145f0d", "filename": "tests/ui/mut_from_ref.rs", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fmut_from_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fmut_from_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmut_from_ref.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -5,7 +5,7 @@ struct Foo;\n \n impl Foo {\n     fn this_wont_hurt_a_bit(&self) -> &mut Foo {\n-        unimplemented!()\n+        unsafe { unimplemented!() }\n     }\n }\n \n@@ -15,29 +15,37 @@ trait Ouch {\n \n impl Ouch for Foo {\n     fn ouch(x: &Foo) -> &mut Foo {\n-        unimplemented!()\n+        unsafe { unimplemented!() }\n     }\n }\n \n fn fail(x: &u32) -> &mut u16 {\n-    unimplemented!()\n+    unsafe { unimplemented!() }\n }\n \n fn fail_lifetime<'a>(x: &'a u32, y: &mut u32) -> &'a mut u32 {\n-    unimplemented!()\n+    unsafe { unimplemented!() }\n }\n \n fn fail_double<'a, 'b>(x: &'a u32, y: &'a u32, z: &'b mut u32) -> &'a mut u32 {\n-    unimplemented!()\n+    unsafe { unimplemented!() }\n }\n \n // this is OK, because the result borrows y\n fn works<'a>(x: &u32, y: &'a mut u32) -> &'a mut u32 {\n-    unimplemented!()\n+    unsafe { unimplemented!() }\n }\n \n // this is also OK, because the result could borrow y\n fn also_works<'a>(x: &'a u32, y: &'a mut u32) -> &'a mut u32 {\n+    unsafe { unimplemented!() }\n+}\n+\n+unsafe fn also_broken(x: &u32) -> &mut u32 {\n+    unimplemented!()\n+}\n+\n+fn without_unsafe(x: &u32) -> &mut u32 {\n     unimplemented!()\n }\n "}, {"sha": "b76d6a13ffb9cf312d2285886671a976549d18b6", "filename": "tests/ui/mut_from_ref.stderr", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fmut_from_ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fmut_from_ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmut_from_ref.stderr?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -59,5 +59,17 @@ note: immutable borrow here\n LL | fn fail_double<'a, 'b>(x: &'a u32, y: &'a u32, z: &'b mut u32) -> &'a mut u32 {\n    |                           ^^^^^^^     ^^^^^^^\n \n-error: aborting due to 5 previous errors\n+error: mutable borrow from immutable input(s)\n+  --> $DIR/mut_from_ref.rs:44:35\n+   |\n+LL | unsafe fn also_broken(x: &u32) -> &mut u32 {\n+   |                                   ^^^^^^^^\n+   |\n+note: immutable borrow here\n+  --> $DIR/mut_from_ref.rs:44:26\n+   |\n+LL | unsafe fn also_broken(x: &u32) -> &mut u32 {\n+   |                          ^^^^\n+\n+error: aborting due to 6 previous errors\n "}, {"sha": "c1685f7b6d7adeba6f5783c4cb7320d669c61904", "filename": "tests/ui/needless_for_each_fixable.fixed", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fneedless_for_each_fixable.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fneedless_for_each_fixable.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_for_each_fixable.fixed?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -1,6 +1,11 @@\n // run-rustfix\n #![warn(clippy::needless_for_each)]\n-#![allow(unused, clippy::needless_return, clippy::match_single_binding)]\n+#![allow(\n+    unused,\n+    clippy::needless_return,\n+    clippy::match_single_binding,\n+    clippy::let_unit_value\n+)]\n \n use std::collections::HashMap;\n "}, {"sha": "ad17b0956fa93149d2fe436ae3e22755ba1edeb2", "filename": "tests/ui/needless_for_each_fixable.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fneedless_for_each_fixable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fneedless_for_each_fixable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_for_each_fixable.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -1,6 +1,11 @@\n // run-rustfix\n #![warn(clippy::needless_for_each)]\n-#![allow(unused, clippy::needless_return, clippy::match_single_binding)]\n+#![allow(\n+    unused,\n+    clippy::needless_return,\n+    clippy::match_single_binding,\n+    clippy::let_unit_value\n+)]\n \n use std::collections::HashMap;\n "}, {"sha": "08e995851d7a5c9717bbb5e7c9a7239a80003ae9", "filename": "tests/ui/needless_for_each_fixable.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fneedless_for_each_fixable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fneedless_for_each_fixable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_for_each_fixable.stderr?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -1,5 +1,5 @@\n error: needless use of `for_each`\n-  --> $DIR/needless_for_each_fixable.rs:10:5\n+  --> $DIR/needless_for_each_fixable.rs:15:5\n    |\n LL | /     v.iter().for_each(|elem| {\n LL | |         acc += elem;\n@@ -15,7 +15,7 @@ LL +     }\n    |\n \n error: needless use of `for_each`\n-  --> $DIR/needless_for_each_fixable.rs:13:5\n+  --> $DIR/needless_for_each_fixable.rs:18:5\n    |\n LL | /     v.into_iter().for_each(|elem| {\n LL | |         acc += elem;\n@@ -30,7 +30,7 @@ LL +     }\n    |\n \n error: needless use of `for_each`\n-  --> $DIR/needless_for_each_fixable.rs:17:5\n+  --> $DIR/needless_for_each_fixable.rs:22:5\n    |\n LL | /     [1, 2, 3].iter().for_each(|elem| {\n LL | |         acc += elem;\n@@ -45,7 +45,7 @@ LL +     }\n    |\n \n error: needless use of `for_each`\n-  --> $DIR/needless_for_each_fixable.rs:22:5\n+  --> $DIR/needless_for_each_fixable.rs:27:5\n    |\n LL | /     hash_map.iter().for_each(|(k, v)| {\n LL | |         acc += k + v;\n@@ -60,7 +60,7 @@ LL +     }\n    |\n \n error: needless use of `for_each`\n-  --> $DIR/needless_for_each_fixable.rs:25:5\n+  --> $DIR/needless_for_each_fixable.rs:30:5\n    |\n LL | /     hash_map.iter_mut().for_each(|(k, v)| {\n LL | |         acc += *k + *v;\n@@ -75,7 +75,7 @@ LL +     }\n    |\n \n error: needless use of `for_each`\n-  --> $DIR/needless_for_each_fixable.rs:28:5\n+  --> $DIR/needless_for_each_fixable.rs:33:5\n    |\n LL | /     hash_map.keys().for_each(|k| {\n LL | |         acc += k;\n@@ -90,7 +90,7 @@ LL +     }\n    |\n \n error: needless use of `for_each`\n-  --> $DIR/needless_for_each_fixable.rs:31:5\n+  --> $DIR/needless_for_each_fixable.rs:36:5\n    |\n LL | /     hash_map.values().for_each(|v| {\n LL | |         acc += v;\n@@ -105,7 +105,7 @@ LL +     }\n    |\n \n error: needless use of `for_each`\n-  --> $DIR/needless_for_each_fixable.rs:38:5\n+  --> $DIR/needless_for_each_fixable.rs:43:5\n    |\n LL | /     my_vec().iter().for_each(|elem| {\n LL | |         acc += elem;"}, {"sha": "54e66b391b8d8a46068df048cf91c17bf8a5d03c", "filename": "tests/ui/needless_late_init.rs", "status": "modified", "additions": 62, "deletions": 11, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fneedless_late_init.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fneedless_late_init.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_late_init.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -1,4 +1,15 @@\n-#![allow(unused)]\n+#![feature(let_chains)]\n+#![allow(unused, clippy::nonminimal_bool, clippy::let_unit_value)]\n+\n+use std::collections::{BTreeMap, BTreeSet, HashMap, HashSet};\n+use std::rc::Rc;\n+\n+struct SignificantDrop;\n+impl std::ops::Drop for SignificantDrop {\n+    fn drop(&mut self) {\n+        println!(\"dropped\");\n+    }\n+}\n \n fn main() {\n     let a;\n@@ -17,13 +28,6 @@ fn main() {\n         b = \"five\"\n     }\n \n-    let c;\n-    if let Some(n) = Some(5) {\n-        c = n;\n-    } else {\n-        c = -50;\n-    }\n-\n     let d;\n     if true {\n         let temp = 5;\n@@ -36,7 +40,7 @@ fn main() {\n     if true {\n         e = format!(\"{} {}\", a, b);\n     } else {\n-        e = format!(\"{}\", c);\n+        e = format!(\"{}\", n);\n     }\n \n     let f;\n@@ -52,7 +56,27 @@ fn main() {\n         panic!();\n     }\n \n-    println!(\"{}\", a);\n+    // Drop order only matters if both are significant\n+    let x;\n+    let y = SignificantDrop;\n+    x = 1;\n+\n+    let x;\n+    let y = 1;\n+    x = SignificantDrop;\n+\n+    let x;\n+    // types that should be considered insignificant\n+    let y = 1;\n+    let y = \"2\";\n+    let y = String::new();\n+    let y = vec![3.0];\n+    let y = HashMap::<usize, usize>::new();\n+    let y = BTreeMap::<usize, usize>::new();\n+    let y = HashSet::<usize>::new();\n+    let y = BTreeSet::<usize>::new();\n+    let y = Box::new(4);\n+    x = SignificantDrop;\n }\n \n async fn in_async() -> &'static str {\n@@ -176,5 +200,32 @@ fn does_not_lint() {\n     }\n     in_macro!();\n \n-    println!(\"{}\", x);\n+    // ignore if-lets - https://github.com/rust-lang/rust-clippy/issues/8613\n+    let x;\n+    if let Some(n) = Some(\"v\") {\n+        x = 1;\n+    } else {\n+        x = 2;\n+    }\n+\n+    let x;\n+    if true && let Some(n) = Some(\"let chains too\") {\n+        x = 1;\n+    } else {\n+        x = 2;\n+    }\n+\n+    // ignore mut bindings\n+    // https://github.com/shepmaster/twox-hash/blob/b169c16d86eb8ea4a296b0acb9d00ca7e3c3005f/src/sixty_four.rs#L88-L93\n+    // https://github.com/dtolnay/thiserror/blob/21c26903e29cb92ba1a7ff11e82ae2001646b60d/tests/test_generics.rs#L91-L100\n+    let mut x: usize;\n+    x = 1;\n+    x = 2;\n+    x = 3;\n+\n+    // should not move the declaration if `x` has a significant drop, and there\n+    // is another binding with a significant drop between it and the first usage\n+    let x;\n+    let y = SignificantDrop;\n+    x = SignificantDrop;\n }"}, {"sha": "d33a117b288cb5482a5bd0cc87dc446e3f091109", "filename": "tests/ui/needless_late_init.stderr", "status": "modified", "additions": 60, "deletions": 39, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fneedless_late_init.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fneedless_late_init.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_late_init.stderr?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -1,5 +1,5 @@\n-error: unneeded late initalization\n-  --> $DIR/needless_late_init.rs:4:5\n+error: unneeded late initialization\n+  --> $DIR/needless_late_init.rs:15:5\n    |\n LL |     let a;\n    |     ^^^^^^\n@@ -20,8 +20,8 @@ help: add a semicolon after the `match` expression\n LL |     };\n    |      +\n \n-error: unneeded late initalization\n-  --> $DIR/needless_late_init.rs:13:5\n+error: unneeded late initialization\n+  --> $DIR/needless_late_init.rs:24:5\n    |\n LL |     let b;\n    |     ^^^^^^\n@@ -41,29 +41,8 @@ help: add a semicolon after the `if` expression\n LL |     };\n    |      +\n \n-error: unneeded late initalization\n-  --> $DIR/needless_late_init.rs:20:5\n-   |\n-LL |     let c;\n-   |     ^^^^^^\n-   |\n-help: declare `c` here\n-   |\n-LL |     let c = if let Some(n) = Some(5) {\n-   |     +++++++\n-help: remove the assignments from the branches\n-   |\n-LL ~         n\n-LL |     } else {\n-LL ~         -50\n-   |\n-help: add a semicolon after the `if` expression\n-   |\n-LL |     };\n-   |      +\n-\n-error: unneeded late initalization\n-  --> $DIR/needless_late_init.rs:27:5\n+error: unneeded late initialization\n+  --> $DIR/needless_late_init.rs:31:5\n    |\n LL |     let d;\n    |     ^^^^^^\n@@ -83,8 +62,8 @@ help: add a semicolon after the `if` expression\n LL |     };\n    |      +\n \n-error: unneeded late initalization\n-  --> $DIR/needless_late_init.rs:35:5\n+error: unneeded late initialization\n+  --> $DIR/needless_late_init.rs:39:5\n    |\n LL |     let e;\n    |     ^^^^^^\n@@ -97,15 +76,15 @@ help: remove the assignments from the branches\n    |\n LL ~         format!(\"{} {}\", a, b)\n LL |     } else {\n-LL ~         format!(\"{}\", c)\n+LL ~         format!(\"{}\", n)\n    |\n help: add a semicolon after the `if` expression\n    |\n LL |     };\n    |      +\n \n-error: unneeded late initalization\n-  --> $DIR/needless_late_init.rs:42:5\n+error: unneeded late initialization\n+  --> $DIR/needless_late_init.rs:46:5\n    |\n LL |     let f;\n    |     ^^^^^^\n@@ -120,8 +99,8 @@ LL -         1 => f = \"three\",\n LL +         1 => \"three\",\n    | \n \n-error: unneeded late initalization\n-  --> $DIR/needless_late_init.rs:48:5\n+error: unneeded late initialization\n+  --> $DIR/needless_late_init.rs:52:5\n    |\n LL |     let g: usize;\n    |     ^^^^^^^^^^^^^\n@@ -140,8 +119,50 @@ help: add a semicolon after the `if` expression\n LL |     };\n    |      +\n \n-error: unneeded late initalization\n-  --> $DIR/needless_late_init.rs:63:5\n+error: unneeded late initialization\n+  --> $DIR/needless_late_init.rs:60:5\n+   |\n+LL |     let x;\n+   |     ^^^^^^ created here\n+LL |     let y = SignificantDrop;\n+LL |     x = 1;\n+   |     ^^^^^ initialised here\n+   |\n+help: declare `x` here\n+   |\n+LL |     let x = 1;\n+   |     ~~~~~\n+\n+error: unneeded late initialization\n+  --> $DIR/needless_late_init.rs:64:5\n+   |\n+LL |     let x;\n+   |     ^^^^^^ created here\n+LL |     let y = 1;\n+LL |     x = SignificantDrop;\n+   |     ^^^^^^^^^^^^^^^^^^^ initialised here\n+   |\n+help: declare `x` here\n+   |\n+LL |     let x = SignificantDrop;\n+   |     ~~~~~\n+\n+error: unneeded late initialization\n+  --> $DIR/needless_late_init.rs:68:5\n+   |\n+LL |     let x;\n+   |     ^^^^^^ created here\n+...\n+LL |     x = SignificantDrop;\n+   |     ^^^^^^^^^^^^^^^^^^^ initialised here\n+   |\n+help: declare `x` here\n+   |\n+LL |     let x = SignificantDrop;\n+   |     ~~~~~\n+\n+error: unneeded late initialization\n+  --> $DIR/needless_late_init.rs:87:5\n    |\n LL |     let a;\n    |     ^^^^^^\n@@ -161,8 +182,8 @@ help: add a semicolon after the `match` expression\n LL |     };\n    |      +\n \n-error: unneeded late initalization\n-  --> $DIR/needless_late_init.rs:80:5\n+error: unneeded late initialization\n+  --> $DIR/needless_late_init.rs:104:5\n    |\n LL |     let a;\n    |     ^^^^^^\n@@ -182,5 +203,5 @@ help: add a semicolon after the `match` expression\n LL |     };\n    |      +\n \n-error: aborting due to 9 previous errors\n+error: aborting due to 11 previous errors\n "}, {"sha": "724477e8691df1df790fcdb3efa62cccb49da932", "filename": "tests/ui/needless_late_init_fixable.fixed", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fneedless_late_init_fixable.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fneedless_late_init_fixable.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_late_init_fixable.fixed?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -15,11 +15,5 @@ fn main() {\n     let d: usize = 1;\n \n     \n-    let mut e = 1;\n-    e = 2;\n-\n-    \n-    let h = format!(\"{}\", e);\n-\n-    println!(\"{}\", a);\n+    let e = format!(\"{}\", d);\n }"}, {"sha": "3e6bd36367275dd2f2a55118f3da9dd0fd8da22d", "filename": "tests/ui/needless_late_init_fixable.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fneedless_late_init_fixable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fneedless_late_init_fixable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_late_init_fixable.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -14,12 +14,6 @@ fn main() {\n     let d: usize;\n     d = 1;\n \n-    let mut e;\n-    e = 1;\n-    e = 2;\n-\n-    let h;\n-    h = format!(\"{}\", e);\n-\n-    println!(\"{}\", a);\n+    let e;\n+    e = format!(\"{}\", d);\n }"}, {"sha": "8c664309e3e83fe4838fbcfc12d7c5e586109c42", "filename": "tests/ui/needless_late_init_fixable.stderr", "status": "modified", "additions": 25, "deletions": 24, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fneedless_late_init_fixable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fneedless_late_init_fixable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_late_init_fixable.stderr?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -1,69 +1,70 @@\n-error: unneeded late initalization\n+error: unneeded late initialization\n   --> $DIR/needless_late_init_fixable.rs:6:5\n    |\n LL |     let a;\n-   |     ^^^^^^\n+   |     ^^^^^^ created here\n+LL |     a = \"zero\";\n+   |     ^^^^^^^^^^ initialised here\n    |\n    = note: `-D clippy::needless-late-init` implied by `-D warnings`\n help: declare `a` here\n    |\n LL |     let a = \"zero\";\n    |     ~~~~~\n \n-error: unneeded late initalization\n+error: unneeded late initialization\n   --> $DIR/needless_late_init_fixable.rs:9:5\n    |\n LL |     let b;\n-   |     ^^^^^^\n+   |     ^^^^^^ created here\n+LL |     let c;\n+LL |     b = 1;\n+   |     ^^^^^ initialised here\n    |\n help: declare `b` here\n    |\n LL |     let b = 1;\n    |     ~~~~~\n \n-error: unneeded late initalization\n+error: unneeded late initialization\n   --> $DIR/needless_late_init_fixable.rs:10:5\n    |\n LL |     let c;\n-   |     ^^^^^^\n+   |     ^^^^^^ created here\n+LL |     b = 1;\n+LL |     c = 2;\n+   |     ^^^^^ initialised here\n    |\n help: declare `c` here\n    |\n LL |     let c = 2;\n    |     ~~~~~\n \n-error: unneeded late initalization\n+error: unneeded late initialization\n   --> $DIR/needless_late_init_fixable.rs:14:5\n    |\n LL |     let d: usize;\n-   |     ^^^^^^^^^^^^^\n+   |     ^^^^^^^^^^^^^ created here\n+LL |     d = 1;\n+   |     ^^^^^ initialised here\n    |\n help: declare `d` here\n    |\n LL |     let d: usize = 1;\n    |     ~~~~~~~~~~~~\n \n-error: unneeded late initalization\n+error: unneeded late initialization\n   --> $DIR/needless_late_init_fixable.rs:17:5\n    |\n-LL |     let mut e;\n-   |     ^^^^^^^^^^\n+LL |     let e;\n+   |     ^^^^^^ created here\n+LL |     e = format!(\"{}\", d);\n+   |     ^^^^^^^^^^^^^^^^^^^^ initialised here\n    |\n help: declare `e` here\n    |\n-LL |     let mut e = 1;\n-   |     ~~~~~~~~~\n-\n-error: unneeded late initalization\n-  --> $DIR/needless_late_init_fixable.rs:21:5\n-   |\n-LL |     let h;\n-   |     ^^^^^^\n-   |\n-help: declare `h` here\n-   |\n-LL |     let h = format!(\"{}\", e);\n+LL |     let e = format!(\"{}\", d);\n    |     ~~~~~\n \n-error: aborting due to 6 previous errors\n+error: aborting due to 5 previous errors\n "}, {"sha": "b997e5316cf3f451442295cc4a776f4bf41a8c3f", "filename": "tests/ui/needless_match.fixed", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fneedless_match.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fneedless_match.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_match.fixed?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -80,6 +80,18 @@ fn if_let_option() {\n     } else {\n         None\n     };\n+\n+    // Don't trigger\n+    let _ = if let Some(a) = Some(1) { Some(a) } else { Some(2) };\n+}\n+\n+fn if_let_option_result() -> Result<(), ()> {\n+    fn f(x: i32) -> Result<Option<i32>, ()> {\n+        Ok(Some(x))\n+    }\n+    // Don't trigger\n+    let _ = if let Some(v) = f(1)? { Some(v) } else { f(2)? };\n+    Ok(())\n }\n \n fn if_let_result() {"}, {"sha": "90482775a1eebbf7d1fa1621b3c3a233b3739d5a", "filename": "tests/ui/needless_match.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fneedless_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fneedless_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_match.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -103,6 +103,18 @@ fn if_let_option() {\n     } else {\n         None\n     };\n+\n+    // Don't trigger\n+    let _ = if let Some(a) = Some(1) { Some(a) } else { Some(2) };\n+}\n+\n+fn if_let_option_result() -> Result<(), ()> {\n+    fn f(x: i32) -> Result<Option<i32>, ()> {\n+        Ok(Some(x))\n+    }\n+    // Don't trigger\n+    let _ = if let Some(v) = f(1)? { Some(v) } else { f(2)? };\n+    Ok(())\n }\n \n fn if_let_result() {"}, {"sha": "2d679631c6f0d71d9da899d9966bb3bb8e595e3c", "filename": "tests/ui/needless_match.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fneedless_match.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fneedless_match.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_match.stderr?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -72,19 +72,19 @@ LL |     let _ = if let Some(a) = Some(1) { Some(a) } else { None };\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace it with: `Some(1)`\n \n error: this if-let expression is unnecessary\n-  --> $DIR/needless_match.rs:110:31\n+  --> $DIR/needless_match.rs:122:31\n    |\n LL |     let _: Result<i32, i32> = if let Err(e) = x { Err(e) } else { x };\n    |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace it with: `x`\n \n error: this if-let expression is unnecessary\n-  --> $DIR/needless_match.rs:111:31\n+  --> $DIR/needless_match.rs:123:31\n    |\n LL |     let _: Result<i32, i32> = if let Ok(val) = x { Ok(val) } else { x };\n    |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: replace it with: `x`\n \n error: this if-let expression is unnecessary\n-  --> $DIR/needless_match.rs:117:21\n+  --> $DIR/needless_match.rs:129:21\n    |\n LL |       let _: Simple = if let Simple::A = x {\n    |  _____________________^\n@@ -97,7 +97,7 @@ LL | |     };\n    | |_____^ help: replace it with: `x`\n \n error: this match expression is unnecessary\n-  --> $DIR/needless_match.rs:156:26\n+  --> $DIR/needless_match.rs:168:26\n    |\n LL |           let _: Complex = match ce {\n    |  __________________________^"}, {"sha": "acd22c6bb43372e6048a016d656f1bbd6aec2b4f", "filename": "tests/ui/needless_option_as_deref.fixed", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fneedless_option_as_deref.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fneedless_option_as_deref.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_option_as_deref.fixed?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -16,6 +16,20 @@ fn main() {\n     let _ = Some(Box::new(1)).as_deref();\n     let _ = Some(Box::new(1)).as_deref_mut();\n \n+    let mut y = 0;\n+    let mut x = Some(&mut y);\n+    for _ in 0..3 {\n+        let _ = x.as_deref_mut();\n+    }\n+\n+    let mut y = 0;\n+    let mut x = Some(&mut y);\n+    let mut closure = || {\n+        let _ = x.as_deref_mut();\n+    };\n+    closure();\n+    closure();\n+\n     // #7846\n     let mut i = 0;\n     let mut opt_vec = vec![Some(&mut i)];"}, {"sha": "61eda5052a21efed8363013d28c364f042943736", "filename": "tests/ui/needless_option_as_deref.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fneedless_option_as_deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fneedless_option_as_deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_option_as_deref.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -16,6 +16,20 @@ fn main() {\n     let _ = Some(Box::new(1)).as_deref();\n     let _ = Some(Box::new(1)).as_deref_mut();\n \n+    let mut y = 0;\n+    let mut x = Some(&mut y);\n+    for _ in 0..3 {\n+        let _ = x.as_deref_mut();\n+    }\n+\n+    let mut y = 0;\n+    let mut x = Some(&mut y);\n+    let mut closure = || {\n+        let _ = x.as_deref_mut();\n+    };\n+    closure();\n+    closure();\n+\n     // #7846\n     let mut i = 0;\n     let mut opt_vec = vec![Some(&mut i)];"}, {"sha": "29691e81666f7797bc99428b961545f9249331d7", "filename": "tests/ui/needless_option_take.fixed", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fneedless_option_take.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fneedless_option_take.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_option_take.fixed?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -0,0 +1,15 @@\n+// run-rustfix\n+\n+fn main() {\n+    println!(\"Testing non erroneous option_take_on_temporary\");\n+    let mut option = Some(1);\n+    let _ = Box::new(move || option.take().unwrap());\n+\n+    println!(\"Testing non erroneous option_take_on_temporary\");\n+    let x = Some(3);\n+    x.as_ref();\n+\n+    println!(\"Testing erroneous option_take_on_temporary\");\n+    let x = Some(3);\n+    x.as_ref();\n+}"}, {"sha": "9f4109eb4635ac15cb91dc720960b906caeabf6e", "filename": "tests/ui/needless_option_take.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fneedless_option_take.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fneedless_option_take.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_option_take.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -0,0 +1,15 @@\n+// run-rustfix\n+\n+fn main() {\n+    println!(\"Testing non erroneous option_take_on_temporary\");\n+    let mut option = Some(1);\n+    let _ = Box::new(move || option.take().unwrap());\n+\n+    println!(\"Testing non erroneous option_take_on_temporary\");\n+    let x = Some(3);\n+    x.as_ref();\n+\n+    println!(\"Testing erroneous option_take_on_temporary\");\n+    let x = Some(3);\n+    x.as_ref().take();\n+}"}, {"sha": "cb3bf015b369d811634894efd63cb298eb171fd6", "filename": "tests/ui/needless_option_take.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fneedless_option_take.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fneedless_option_take.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_option_take.stderr?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -0,0 +1,10 @@\n+error: called `Option::take()` on a temporary value\n+  --> $DIR/needless_option_take.rs:14:5\n+   |\n+LL |     x.as_ref().take();\n+   |     ^^^^^^^^^^^^^^^^^ help: try: `x.as_ref()`\n+   |\n+   = note: `-D clippy::needless-option-take` implied by `-D warnings`\n+\n+error: aborting due to previous error\n+"}, {"sha": "61f5fc4e679edafbb609cfa70dd550ff3df2e39e", "filename": "tests/ui/needless_splitn.fixed", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fneedless_splitn.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fneedless_splitn.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_splitn.fixed?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -24,4 +24,24 @@ fn main() {\n     let _ = str.rsplitn(2, '=').nth(1);\n     let (_, _) = str.rsplitn(2, '=').next_tuple().unwrap();\n     let (_, _) = str.rsplit('=').next_tuple().unwrap();\n+\n+    let _ = str.split('=').next();\n+    let _ = str.split('=').nth(3);\n+    let _ = str.splitn(5, '=').nth(4);\n+    let _ = str.splitn(5, '=').nth(5);\n+}\n+\n+fn _question_mark(s: &str) -> Option<()> {\n+    let _ = s.split('=').next()?;\n+    let _ = s.split('=').nth(0)?;\n+    let _ = s.rsplit('=').next()?;\n+    let _ = s.rsplit('=').nth(0)?;\n+\n+    Some(())\n+}\n+\n+fn _test_msrv() {\n+    #![clippy::msrv = \"1.51\"]\n+    // `manual_split_once` MSRV shouldn't apply to `needless_splitn`\n+    let _ = \"key=value\".split('=').nth(0).unwrap();\n }"}, {"sha": "71d9a7077faa6f354e9475507b456d8e53e884e9", "filename": "tests/ui/needless_splitn.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fneedless_splitn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fneedless_splitn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_splitn.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -24,4 +24,24 @@ fn main() {\n     let _ = str.rsplitn(2, '=').nth(1);\n     let (_, _) = str.rsplitn(2, '=').next_tuple().unwrap();\n     let (_, _) = str.rsplitn(3, '=').next_tuple().unwrap();\n+\n+    let _ = str.splitn(5, '=').next();\n+    let _ = str.splitn(5, '=').nth(3);\n+    let _ = str.splitn(5, '=').nth(4);\n+    let _ = str.splitn(5, '=').nth(5);\n+}\n+\n+fn _question_mark(s: &str) -> Option<()> {\n+    let _ = s.splitn(2, '=').next()?;\n+    let _ = s.splitn(2, '=').nth(0)?;\n+    let _ = s.rsplitn(2, '=').next()?;\n+    let _ = s.rsplitn(2, '=').nth(0)?;\n+\n+    Some(())\n+}\n+\n+fn _test_msrv() {\n+    #![clippy::msrv = \"1.51\"]\n+    // `manual_split_once` MSRV shouldn't apply to `needless_splitn`\n+    let _ = \"key=value\".splitn(2, '=').nth(0).unwrap();\n }"}, {"sha": "f112b29e7f2066ccb0751f049d479b45d5a79c58", "filename": "tests/ui/needless_splitn.stderr", "status": "modified", "additions": 43, "deletions": 1, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fneedless_splitn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fneedless_splitn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_splitn.stderr?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -36,5 +36,47 @@ error: unnecessary use of `rsplitn`\n LL |     let (_, _) = str.rsplitn(3, '=').next_tuple().unwrap();\n    |                  ^^^^^^^^^^^^^^^^^^^ help: try this: `str.rsplit('=')`\n \n-error: aborting due to 6 previous errors\n+error: unnecessary use of `splitn`\n+  --> $DIR/needless_splitn.rs:28:13\n+   |\n+LL |     let _ = str.splitn(5, '=').next();\n+   |             ^^^^^^^^^^^^^^^^^^ help: try this: `str.split('=')`\n+\n+error: unnecessary use of `splitn`\n+  --> $DIR/needless_splitn.rs:29:13\n+   |\n+LL |     let _ = str.splitn(5, '=').nth(3);\n+   |             ^^^^^^^^^^^^^^^^^^ help: try this: `str.split('=')`\n+\n+error: unnecessary use of `splitn`\n+  --> $DIR/needless_splitn.rs:35:13\n+   |\n+LL |     let _ = s.splitn(2, '=').next()?;\n+   |             ^^^^^^^^^^^^^^^^ help: try this: `s.split('=')`\n+\n+error: unnecessary use of `splitn`\n+  --> $DIR/needless_splitn.rs:36:13\n+   |\n+LL |     let _ = s.splitn(2, '=').nth(0)?;\n+   |             ^^^^^^^^^^^^^^^^ help: try this: `s.split('=')`\n+\n+error: unnecessary use of `rsplitn`\n+  --> $DIR/needless_splitn.rs:37:13\n+   |\n+LL |     let _ = s.rsplitn(2, '=').next()?;\n+   |             ^^^^^^^^^^^^^^^^^ help: try this: `s.rsplit('=')`\n+\n+error: unnecessary use of `rsplitn`\n+  --> $DIR/needless_splitn.rs:38:13\n+   |\n+LL |     let _ = s.rsplitn(2, '=').nth(0)?;\n+   |             ^^^^^^^^^^^^^^^^^ help: try this: `s.rsplit('=')`\n+\n+error: unnecessary use of `splitn`\n+  --> $DIR/needless_splitn.rs:46:13\n+   |\n+LL |     let _ = \"key=value\".splitn(2, '=').nth(0).unwrap();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `\"key=value\".split('=')`\n+\n+error: aborting due to 13 previous errors\n "}, {"sha": "538927b18055a289c771f5cb1cfdc1ba9bfad531", "filename": "tests/ui/new_without_default.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fnew_without_default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fnew_without_default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fnew_without_default.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -1,4 +1,4 @@\n-#![allow(dead_code, clippy::missing_safety_doc)]\n+#![allow(dead_code, clippy::missing_safety_doc, clippy::extra_unused_lifetimes)]\n #![warn(clippy::new_without_default)]\n \n pub struct Foo;"}, {"sha": "583096ac054a15dcc076570b91eb6991d84c258c", "filename": "tests/ui/non_expressive_names.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fnon_expressive_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fnon_expressive_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fnon_expressive_names.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -1,5 +1,5 @@\n #![warn(clippy::all)]\n-#![allow(unused, clippy::println_empty_string, non_snake_case)]\n+#![allow(unused, clippy::println_empty_string, non_snake_case, clippy::let_unit_value)]\n \n #[derive(Clone, Debug)]\n enum MaybeInst {"}, {"sha": "3710b3e9c81e0ac7263f3df216cbddbe77f00e74", "filename": "tests/ui/numbered_fields.fixed", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fnumbered_fields.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fnumbered_fields.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fnumbered_fields.fixed?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -30,4 +30,9 @@ fn main() {\n \n     // Ok because it's in macro\n     let _ = tuple_struct_init!();\n+\n+    type Alias = TupleStruct;\n+\n+    // Aliases can't be tuple constructed #8638\n+    let _ = Alias { 0: 0, 1: 1, 2: 2 };\n }"}, {"sha": "2af84bc0642a534683b963c3d51b37e85761eae4", "filename": "tests/ui/numbered_fields.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fnumbered_fields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fnumbered_fields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fnumbered_fields.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -38,4 +38,9 @@ fn main() {\n \n     // Ok because it's in macro\n     let _ = tuple_struct_init!();\n+\n+    type Alias = TupleStruct;\n+\n+    // Aliases can't be tuple constructed #8638\n+    let _ = Alias { 0: 0, 1: 1, 2: 2 };\n }"}, {"sha": "e12e13a57f1f0b43286aa3b2cf498e385566342e", "filename": "tests/ui/option_if_let_else.fixed", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Foption_if_let_else.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Foption_if_let_else.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Foption_if_let_else.fixed?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -1,6 +1,11 @@\n // run-rustfix\n #![warn(clippy::option_if_let_else)]\n-#![allow(clippy::redundant_closure, clippy::ref_option_ref, clippy::equatable_if_let)]\n+#![allow(\n+    clippy::redundant_closure,\n+    clippy::ref_option_ref,\n+    clippy::equatable_if_let,\n+    clippy::let_unit_value\n+)]\n \n fn bad1(string: Option<&str>) -> (bool, &str) {\n     string.map_or((false, \"hello\"), |x| (true, x))"}, {"sha": "b5206fc26a9e13ae091cfe7cbdb528d56c19901a", "filename": "tests/ui/option_if_let_else.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Foption_if_let_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Foption_if_let_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Foption_if_let_else.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -1,6 +1,11 @@\n // run-rustfix\n #![warn(clippy::option_if_let_else)]\n-#![allow(clippy::redundant_closure, clippy::ref_option_ref, clippy::equatable_if_let)]\n+#![allow(\n+    clippy::redundant_closure,\n+    clippy::ref_option_ref,\n+    clippy::equatable_if_let,\n+    clippy::let_unit_value\n+)]\n \n fn bad1(string: Option<&str>) -> (bool, &str) {\n     if let Some(x) = string {"}, {"sha": "40aef977b989bfd057c7c7fb1b4b7805fd79e08f", "filename": "tests/ui/option_if_let_else.stderr", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Foption_if_let_else.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Foption_if_let_else.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Foption_if_let_else.stderr?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -1,5 +1,5 @@\n error: use Option::map_or instead of an if let/else\n-  --> $DIR/option_if_let_else.rs:6:5\n+  --> $DIR/option_if_let_else.rs:11:5\n    |\n LL | /     if let Some(x) = string {\n LL | |         (true, x)\n@@ -11,19 +11,19 @@ LL | |     }\n    = note: `-D clippy::option-if-let-else` implied by `-D warnings`\n \n error: use Option::map_or instead of an if let/else\n-  --> $DIR/option_if_let_else.rs:24:13\n+  --> $DIR/option_if_let_else.rs:29:13\n    |\n LL |     let _ = if let Some(s) = *string { s.len() } else { 0 };\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `string.map_or(0, |s| s.len())`\n \n error: use Option::map_or instead of an if let/else\n-  --> $DIR/option_if_let_else.rs:25:13\n+  --> $DIR/option_if_let_else.rs:30:13\n    |\n LL |     let _ = if let Some(s) = &num { s } else { &0 };\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `num.as_ref().map_or(&0, |s| s)`\n \n error: use Option::map_or instead of an if let/else\n-  --> $DIR/option_if_let_else.rs:26:13\n+  --> $DIR/option_if_let_else.rs:31:13\n    |\n LL |       let _ = if let Some(s) = &mut num {\n    |  _____________^\n@@ -43,13 +43,13 @@ LL ~     });\n    |\n \n error: use Option::map_or instead of an if let/else\n-  --> $DIR/option_if_let_else.rs:32:13\n+  --> $DIR/option_if_let_else.rs:37:13\n    |\n LL |     let _ = if let Some(ref s) = num { s } else { &0 };\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `num.as_ref().map_or(&0, |s| s)`\n \n error: use Option::map_or instead of an if let/else\n-  --> $DIR/option_if_let_else.rs:33:13\n+  --> $DIR/option_if_let_else.rs:38:13\n    |\n LL |       let _ = if let Some(mut s) = num {\n    |  _____________^\n@@ -69,7 +69,7 @@ LL ~     });\n    |\n \n error: use Option::map_or instead of an if let/else\n-  --> $DIR/option_if_let_else.rs:39:13\n+  --> $DIR/option_if_let_else.rs:44:13\n    |\n LL |       let _ = if let Some(ref mut s) = num {\n    |  _____________^\n@@ -89,7 +89,7 @@ LL ~     });\n    |\n \n error: use Option::map_or instead of an if let/else\n-  --> $DIR/option_if_let_else.rs:48:5\n+  --> $DIR/option_if_let_else.rs:53:5\n    |\n LL | /     if let Some(x) = arg {\n LL | |         let y = x * x;\n@@ -108,7 +108,7 @@ LL +     })\n    |\n \n error: use Option::map_or_else instead of an if let/else\n-  --> $DIR/option_if_let_else.rs:61:13\n+  --> $DIR/option_if_let_else.rs:66:13\n    |\n LL |       let _ = if let Some(x) = arg {\n    |  _____________^\n@@ -120,7 +120,7 @@ LL | |     };\n    | |_____^ help: try: `arg.map_or_else(|| side_effect(), |x| x)`\n \n error: use Option::map_or_else instead of an if let/else\n-  --> $DIR/option_if_let_else.rs:70:13\n+  --> $DIR/option_if_let_else.rs:75:13\n    |\n LL |       let _ = if let Some(x) = arg {\n    |  _____________^\n@@ -143,7 +143,7 @@ LL ~     }, |x| x * x * x * x);\n    |\n \n error: use Option::map_or_else instead of an if let/else\n-  --> $DIR/option_if_let_else.rs:103:13\n+  --> $DIR/option_if_let_else.rs:108:13\n    |\n LL | /             if let Some(idx) = s.find('.') {\n LL | |                 vec![s[..idx].to_string(), s[idx..].to_string()]\n@@ -153,13 +153,13 @@ LL | |             }\n    | |_____________^ help: try: `s.find('.').map_or_else(|| vec![s.to_string()], |idx| vec![s[..idx].to_string(), s[idx..].to_string()])`\n \n error: use Option::map_or instead of an if let/else\n-  --> $DIR/option_if_let_else.rs:127:13\n+  --> $DIR/option_if_let_else.rs:132:13\n    |\n LL |     let _ = if let Some(x) = optional { x + 2 } else { 5 };\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `optional.map_or(5, |x| x + 2)`\n \n error: use Option::map_or instead of an if let/else\n-  --> $DIR/option_if_let_else.rs:136:13\n+  --> $DIR/option_if_let_else.rs:141:13\n    |\n LL |       let _ = if let Some(x) = Some(0) {\n    |  _____________^\n@@ -181,13 +181,13 @@ LL ~         });\n    |\n \n error: use Option::map_or instead of an if let/else\n-  --> $DIR/option_if_let_else.rs:164:13\n+  --> $DIR/option_if_let_else.rs:169:13\n    |\n LL |     let _ = if let Some(x) = Some(0) { s.len() + x } else { s.len() };\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `Some(0).map_or(s.len(), |x| s.len() + x)`\n \n error: use Option::map_or instead of an if let/else\n-  --> $DIR/option_if_let_else.rs:168:13\n+  --> $DIR/option_if_let_else.rs:173:13\n    |\n LL |       let _ = if let Some(x) = Some(0) {\n    |  _____________^"}, {"sha": "29691e81666f7797bc99428b961545f9249331d7", "filename": "tests/ui/option_take_on_temporary.fixed", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Foption_take_on_temporary.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Foption_take_on_temporary.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Foption_take_on_temporary.fixed?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -0,0 +1,15 @@\n+// run-rustfix\n+\n+fn main() {\n+    println!(\"Testing non erroneous option_take_on_temporary\");\n+    let mut option = Some(1);\n+    let _ = Box::new(move || option.take().unwrap());\n+\n+    println!(\"Testing non erroneous option_take_on_temporary\");\n+    let x = Some(3);\n+    x.as_ref();\n+\n+    println!(\"Testing erroneous option_take_on_temporary\");\n+    let x = Some(3);\n+    x.as_ref();\n+}"}, {"sha": "844cc4b7a09281ebaa23604078f83735625b17c7", "filename": "tests/ui/or_then_unwrap.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2For_then_unwrap.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2For_then_unwrap.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2For_then_unwrap.fixed?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -1,7 +1,7 @@\n // run-rustfix\n \n #![warn(clippy::or_then_unwrap)]\n-#![allow(clippy::map_identity)]\n+#![allow(clippy::map_identity, clippy::let_unit_value)]\n \n struct SomeStruct;\n impl SomeStruct {"}, {"sha": "1528ef9be964de41ba522ee5fef9930ca3a159bb", "filename": "tests/ui/or_then_unwrap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2For_then_unwrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2For_then_unwrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2For_then_unwrap.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -1,7 +1,7 @@\n // run-rustfix\n \n #![warn(clippy::or_then_unwrap)]\n-#![allow(clippy::map_identity)]\n+#![allow(clippy::map_identity, clippy::let_unit_value)]\n \n struct SomeStruct;\n impl SomeStruct {"}, {"sha": "041ef17fa6834240c97e3234601e8432f3f0ff0a", "filename": "tests/ui/panicking_macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fpanicking_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fpanicking_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpanicking_macros.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -1,4 +1,4 @@\n-#![allow(clippy::assertions_on_constants, clippy::eq_op)]\n+#![allow(clippy::assertions_on_constants, clippy::eq_op, clippy::let_unit_value)]\n #![feature(inline_const)]\n #![warn(clippy::unimplemented, clippy::unreachable, clippy::todo, clippy::panic)]\n "}, {"sha": "65542bedec7bc36062648d1c9fd5057344661ff5", "filename": "tests/ui/pub_use.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fpub_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fpub_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpub_use.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -0,0 +1,14 @@\n+#![warn(clippy::pub_use)]\n+#![allow(unused_imports)]\n+#![no_main]\n+\n+pub mod outer {\n+    mod inner {\n+        pub struct Test {}\n+    }\n+    // should be linted\n+    pub use inner::Test;\n+}\n+\n+// should not be linted\n+use std::fmt;"}, {"sha": "9ab710df818ca2a3be3394b1b95ceeb32f5a1812", "filename": "tests/ui/pub_use.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fpub_use.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fpub_use.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fpub_use.stderr?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -0,0 +1,11 @@\n+error: using `pub use`\n+  --> $DIR/pub_use.rs:10:5\n+   |\n+LL |     pub use inner::Test;\n+   |     ^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `-D clippy::pub-use` implied by `-D warnings`\n+   = help: move the exported item to a public module instead\n+\n+error: aborting due to previous error\n+"}, {"sha": "106947de68c12802c1c31162e840e970c961c53e", "filename": "tests/ui/redundant_pub_crate.fixed", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fredundant_pub_crate.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fredundant_pub_crate.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fredundant_pub_crate.fixed?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -104,4 +104,14 @@ mod m4 {\n \n pub use m4::*;\n \n+mod issue_8732 {\n+    #[allow(unused_macros)]\n+    macro_rules! some_macro {\n+        () => {};\n+    }\n+\n+    #[allow(unused_imports)]\n+    pub(crate) use some_macro; // ok: macro exports are exempt\n+}\n+\n fn main() {}"}, {"sha": "f96cfd3184384c6e09128891da36b02f88057064", "filename": "tests/ui/redundant_pub_crate.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fredundant_pub_crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fredundant_pub_crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fredundant_pub_crate.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -104,4 +104,14 @@ mod m4 {\n \n pub use m4::*;\n \n+mod issue_8732 {\n+    #[allow(unused_macros)]\n+    macro_rules! some_macro {\n+        () => {};\n+    }\n+\n+    #[allow(unused_imports)]\n+    pub(crate) use some_macro; // ok: macro exports are exempt\n+}\n+\n fn main() {}"}, {"sha": "9c4079ad6d306a39a07518382598878b349d39f9", "filename": "tests/ui/rename.fixed", "status": "modified", "additions": 44, "deletions": 45, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Frename.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Frename.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frename.fixed?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -1,71 +1,70 @@\n-//! Test for Clippy lint renames.\n+// This file was generated by `cargo dev update_lints`.\n+// Use that command to update this file and do not edit by hand.\n+// Manual edits will be overwritten.\n+\n // run-rustfix\n \n-#![allow(dead_code)]\n-// allow the new lint name here, to test if the new name works\n-#![allow(clippy::module_name_repetitions)]\n-#![allow(clippy::new_without_default)]\n+#![allow(clippy::blocks_in_if_conditions)]\n+#![allow(clippy::box_collection)]\n #![allow(clippy::redundant_static_lifetimes)]\n #![allow(clippy::cognitive_complexity)]\n+#![allow(clippy::disallowed_methods)]\n+#![allow(clippy::disallowed_types)]\n+#![allow(clippy::for_loops_over_fallibles)]\n+#![allow(clippy::useless_conversion)]\n+#![allow(clippy::match_result_ok)]\n+#![allow(clippy::new_without_default)]\n #![allow(clippy::bind_instead_of_map)]\n-#![allow(clippy::box_collection)]\n-#![allow(clippy::blocks_in_if_conditions)]\n+#![allow(clippy::expect_used)]\n #![allow(clippy::map_unwrap_or)]\n #![allow(clippy::unwrap_used)]\n-#![allow(clippy::expect_used)]\n-#![allow(clippy::for_loops_over_fallibles)]\n-#![allow(clippy::useless_conversion)]\n-#![allow(clippy::invisible_characters)]\n+#![allow(clippy::needless_borrow)]\n #![allow(clippy::single_char_add_str)]\n-#![allow(clippy::match_result_ok)]\n-#![allow(clippy::disallowed_types)]\n-#![allow(clippy::disallowed_methods)]\n+#![allow(clippy::module_name_repetitions)]\n #![allow(clippy::recursive_format_impl)]\n-// uplifted lints\n-#![allow(invalid_value)]\n-#![allow(array_into_iter)]\n-#![allow(unused_labels)]\n+#![allow(clippy::invisible_characters)]\n #![allow(drop_bounds)]\n-#![allow(temporary_cstring_as_ptr)]\n-#![allow(non_fmt_panics)]\n-#![allow(unknown_lints)]\n+#![allow(array_into_iter)]\n #![allow(invalid_atomic_ordering)]\n+#![allow(invalid_value)]\n #![allow(enum_intrinsics_non_enums)]\n-// warn for the old lint name here, to test if the renaming worked\n-#![warn(clippy::module_name_repetitions)]\n-#![warn(clippy::new_without_default)]\n+#![allow(non_fmt_panics)]\n+#![allow(temporary_cstring_as_ptr)]\n+#![allow(unknown_lints)]\n+#![allow(unused_labels)]\n+#![warn(clippy::blocks_in_if_conditions)]\n+#![warn(clippy::blocks_in_if_conditions)]\n+#![warn(clippy::box_collection)]\n #![warn(clippy::redundant_static_lifetimes)]\n #![warn(clippy::cognitive_complexity)]\n+#![warn(clippy::disallowed_methods)]\n+#![warn(clippy::disallowed_types)]\n+#![warn(clippy::for_loops_over_fallibles)]\n+#![warn(clippy::for_loops_over_fallibles)]\n+#![warn(clippy::useless_conversion)]\n+#![warn(clippy::match_result_ok)]\n+#![warn(clippy::new_without_default)]\n #![warn(clippy::bind_instead_of_map)]\n-#![warn(clippy::box_collection)]\n-#![warn(clippy::blocks_in_if_conditions)]\n-#![warn(clippy::blocks_in_if_conditions)]\n-#![warn(clippy::map_unwrap_or)]\n+#![warn(clippy::expect_used)]\n #![warn(clippy::map_unwrap_or)]\n #![warn(clippy::map_unwrap_or)]\n #![warn(clippy::unwrap_used)]\n-#![warn(clippy::unwrap_used)]\n-#![warn(clippy::expect_used)]\n+#![warn(clippy::needless_borrow)]\n #![warn(clippy::expect_used)]\n-#![warn(clippy::for_loops_over_fallibles)]\n-#![warn(clippy::for_loops_over_fallibles)]\n-#![warn(clippy::useless_conversion)]\n-#![warn(clippy::invisible_characters)]\n+#![warn(clippy::map_unwrap_or)]\n+#![warn(clippy::unwrap_used)]\n #![warn(clippy::single_char_add_str)]\n-#![warn(clippy::match_result_ok)]\n-#![warn(clippy::disallowed_types)]\n-#![warn(clippy::disallowed_methods)]\n-#![warn(clippy::needless_borrow)]\n+#![warn(clippy::module_name_repetitions)]\n #![warn(clippy::recursive_format_impl)]\n-// uplifted lints\n-#![warn(invalid_value)]\n-#![warn(array_into_iter)]\n-#![warn(unused_labels)]\n+#![warn(clippy::invisible_characters)]\n #![warn(drop_bounds)]\n-#![warn(temporary_cstring_as_ptr)]\n-#![warn(non_fmt_panics)]\n-#![warn(unknown_lints)]\n+#![warn(array_into_iter)]\n #![warn(invalid_atomic_ordering)]\n+#![warn(invalid_value)]\n #![warn(enum_intrinsics_non_enums)]\n+#![warn(non_fmt_panics)]\n+#![warn(temporary_cstring_as_ptr)]\n+#![warn(unknown_lints)]\n+#![warn(unused_labels)]\n \n fn main() {}"}, {"sha": "e83e66b7fbd4211dbfc80dd2c903a5fcb807ca94", "filename": "tests/ui/rename.rs", "status": "modified", "additions": 44, "deletions": 45, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Frename.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Frename.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frename.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -1,71 +1,70 @@\n-//! Test for Clippy lint renames.\n+// This file was generated by `cargo dev update_lints`.\n+// Use that command to update this file and do not edit by hand.\n+// Manual edits will be overwritten.\n+\n // run-rustfix\n \n-#![allow(dead_code)]\n-// allow the new lint name here, to test if the new name works\n-#![allow(clippy::module_name_repetitions)]\n-#![allow(clippy::new_without_default)]\n+#![allow(clippy::blocks_in_if_conditions)]\n+#![allow(clippy::box_collection)]\n #![allow(clippy::redundant_static_lifetimes)]\n #![allow(clippy::cognitive_complexity)]\n+#![allow(clippy::disallowed_methods)]\n+#![allow(clippy::disallowed_types)]\n+#![allow(clippy::for_loops_over_fallibles)]\n+#![allow(clippy::useless_conversion)]\n+#![allow(clippy::match_result_ok)]\n+#![allow(clippy::new_without_default)]\n #![allow(clippy::bind_instead_of_map)]\n-#![allow(clippy::box_collection)]\n-#![allow(clippy::blocks_in_if_conditions)]\n+#![allow(clippy::expect_used)]\n #![allow(clippy::map_unwrap_or)]\n #![allow(clippy::unwrap_used)]\n-#![allow(clippy::expect_used)]\n-#![allow(clippy::for_loops_over_fallibles)]\n-#![allow(clippy::useless_conversion)]\n-#![allow(clippy::invisible_characters)]\n+#![allow(clippy::needless_borrow)]\n #![allow(clippy::single_char_add_str)]\n-#![allow(clippy::match_result_ok)]\n-#![allow(clippy::disallowed_types)]\n-#![allow(clippy::disallowed_methods)]\n+#![allow(clippy::module_name_repetitions)]\n #![allow(clippy::recursive_format_impl)]\n-// uplifted lints\n-#![allow(invalid_value)]\n-#![allow(array_into_iter)]\n-#![allow(unused_labels)]\n+#![allow(clippy::invisible_characters)]\n #![allow(drop_bounds)]\n-#![allow(temporary_cstring_as_ptr)]\n-#![allow(non_fmt_panics)]\n-#![allow(unknown_lints)]\n+#![allow(array_into_iter)]\n #![allow(invalid_atomic_ordering)]\n+#![allow(invalid_value)]\n #![allow(enum_intrinsics_non_enums)]\n-// warn for the old lint name here, to test if the renaming worked\n-#![warn(clippy::stutter)]\n-#![warn(clippy::new_without_default_derive)]\n+#![allow(non_fmt_panics)]\n+#![allow(temporary_cstring_as_ptr)]\n+#![allow(unknown_lints)]\n+#![allow(unused_labels)]\n+#![warn(clippy::block_in_if_condition_expr)]\n+#![warn(clippy::block_in_if_condition_stmt)]\n+#![warn(clippy::box_vec)]\n #![warn(clippy::const_static_lifetime)]\n #![warn(clippy::cyclomatic_complexity)]\n+#![warn(clippy::disallowed_method)]\n+#![warn(clippy::disallowed_type)]\n+#![warn(clippy::for_loop_over_option)]\n+#![warn(clippy::for_loop_over_result)]\n+#![warn(clippy::identity_conversion)]\n+#![warn(clippy::if_let_some_result)]\n+#![warn(clippy::new_without_default_derive)]\n #![warn(clippy::option_and_then_some)]\n-#![warn(clippy::box_vec)]\n-#![warn(clippy::block_in_if_condition_expr)]\n-#![warn(clippy::block_in_if_condition_stmt)]\n+#![warn(clippy::option_expect_used)]\n #![warn(clippy::option_map_unwrap_or)]\n #![warn(clippy::option_map_unwrap_or_else)]\n-#![warn(clippy::result_map_unwrap_or_else)]\n #![warn(clippy::option_unwrap_used)]\n-#![warn(clippy::result_unwrap_used)]\n-#![warn(clippy::option_expect_used)]\n+#![warn(clippy::ref_in_deref)]\n #![warn(clippy::result_expect_used)]\n-#![warn(clippy::for_loop_over_option)]\n-#![warn(clippy::for_loop_over_result)]\n-#![warn(clippy::identity_conversion)]\n-#![warn(clippy::zero_width_space)]\n+#![warn(clippy::result_map_unwrap_or_else)]\n+#![warn(clippy::result_unwrap_used)]\n #![warn(clippy::single_char_push_str)]\n-#![warn(clippy::if_let_some_result)]\n-#![warn(clippy::disallowed_type)]\n-#![warn(clippy::disallowed_method)]\n-#![warn(clippy::ref_in_deref)]\n+#![warn(clippy::stutter)]\n #![warn(clippy::to_string_in_display)]\n-// uplifted lints\n-#![warn(clippy::invalid_ref)]\n-#![warn(clippy::into_iter_on_array)]\n-#![warn(clippy::unused_label)]\n+#![warn(clippy::zero_width_space)]\n #![warn(clippy::drop_bounds)]\n-#![warn(clippy::temporary_cstring_as_ptr)]\n-#![warn(clippy::panic_params)]\n-#![warn(clippy::unknown_clippy_lints)]\n+#![warn(clippy::into_iter_on_array)]\n #![warn(clippy::invalid_atomic_ordering)]\n+#![warn(clippy::invalid_ref)]\n #![warn(clippy::mem_discriminant_non_enum)]\n+#![warn(clippy::panic_params)]\n+#![warn(clippy::temporary_cstring_as_ptr)]\n+#![warn(clippy::unknown_clippy_lints)]\n+#![warn(clippy::unused_label)]\n \n fn main() {}"}, {"sha": "f811b10d017104220a46575d3aa7d4af4ce9f827", "filename": "tests/ui/rename.stderr", "status": "modified", "additions": 97, "deletions": 97, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Frename.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Frename.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frename.stderr?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -1,208 +1,208 @@\n-error: lint `clippy::stutter` has been renamed to `clippy::module_name_repetitions`\n+error: lint `clippy::block_in_if_condition_expr` has been renamed to `clippy::blocks_in_if_conditions`\n   --> $DIR/rename.rs:35:9\n    |\n-LL | #![warn(clippy::stutter)]\n-   |         ^^^^^^^^^^^^^^^ help: use the new name: `clippy::module_name_repetitions`\n+LL | #![warn(clippy::block_in_if_condition_expr)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::blocks_in_if_conditions`\n    |\n    = note: `-D renamed-and-removed-lints` implied by `-D warnings`\n \n-error: lint `clippy::new_without_default_derive` has been renamed to `clippy::new_without_default`\n+error: lint `clippy::block_in_if_condition_stmt` has been renamed to `clippy::blocks_in_if_conditions`\n   --> $DIR/rename.rs:36:9\n    |\n-LL | #![warn(clippy::new_without_default_derive)]\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::new_without_default`\n+LL | #![warn(clippy::block_in_if_condition_stmt)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::blocks_in_if_conditions`\n \n-error: lint `clippy::const_static_lifetime` has been renamed to `clippy::redundant_static_lifetimes`\n+error: lint `clippy::box_vec` has been renamed to `clippy::box_collection`\n   --> $DIR/rename.rs:37:9\n    |\n+LL | #![warn(clippy::box_vec)]\n+   |         ^^^^^^^^^^^^^^^ help: use the new name: `clippy::box_collection`\n+\n+error: lint `clippy::const_static_lifetime` has been renamed to `clippy::redundant_static_lifetimes`\n+  --> $DIR/rename.rs:38:9\n+   |\n LL | #![warn(clippy::const_static_lifetime)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::redundant_static_lifetimes`\n \n error: lint `clippy::cyclomatic_complexity` has been renamed to `clippy::cognitive_complexity`\n-  --> $DIR/rename.rs:38:9\n+  --> $DIR/rename.rs:39:9\n    |\n LL | #![warn(clippy::cyclomatic_complexity)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::cognitive_complexity`\n \n-error: lint `clippy::option_and_then_some` has been renamed to `clippy::bind_instead_of_map`\n-  --> $DIR/rename.rs:39:9\n-   |\n-LL | #![warn(clippy::option_and_then_some)]\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::bind_instead_of_map`\n-\n-error: lint `clippy::box_vec` has been renamed to `clippy::box_collection`\n+error: lint `clippy::disallowed_method` has been renamed to `clippy::disallowed_methods`\n   --> $DIR/rename.rs:40:9\n    |\n-LL | #![warn(clippy::box_vec)]\n-   |         ^^^^^^^^^^^^^^^ help: use the new name: `clippy::box_collection`\n+LL | #![warn(clippy::disallowed_method)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::disallowed_methods`\n \n-error: lint `clippy::block_in_if_condition_expr` has been renamed to `clippy::blocks_in_if_conditions`\n+error: lint `clippy::disallowed_type` has been renamed to `clippy::disallowed_types`\n   --> $DIR/rename.rs:41:9\n    |\n-LL | #![warn(clippy::block_in_if_condition_expr)]\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::blocks_in_if_conditions`\n+LL | #![warn(clippy::disallowed_type)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::disallowed_types`\n \n-error: lint `clippy::block_in_if_condition_stmt` has been renamed to `clippy::blocks_in_if_conditions`\n+error: lint `clippy::for_loop_over_option` has been renamed to `clippy::for_loops_over_fallibles`\n   --> $DIR/rename.rs:42:9\n    |\n-LL | #![warn(clippy::block_in_if_condition_stmt)]\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::blocks_in_if_conditions`\n+LL | #![warn(clippy::for_loop_over_option)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::for_loops_over_fallibles`\n \n-error: lint `clippy::option_map_unwrap_or` has been renamed to `clippy::map_unwrap_or`\n+error: lint `clippy::for_loop_over_result` has been renamed to `clippy::for_loops_over_fallibles`\n   --> $DIR/rename.rs:43:9\n    |\n-LL | #![warn(clippy::option_map_unwrap_or)]\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::map_unwrap_or`\n+LL | #![warn(clippy::for_loop_over_result)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::for_loops_over_fallibles`\n \n-error: lint `clippy::option_map_unwrap_or_else` has been renamed to `clippy::map_unwrap_or`\n+error: lint `clippy::identity_conversion` has been renamed to `clippy::useless_conversion`\n   --> $DIR/rename.rs:44:9\n    |\n-LL | #![warn(clippy::option_map_unwrap_or_else)]\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::map_unwrap_or`\n+LL | #![warn(clippy::identity_conversion)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::useless_conversion`\n \n-error: lint `clippy::result_map_unwrap_or_else` has been renamed to `clippy::map_unwrap_or`\n+error: lint `clippy::if_let_some_result` has been renamed to `clippy::match_result_ok`\n   --> $DIR/rename.rs:45:9\n    |\n-LL | #![warn(clippy::result_map_unwrap_or_else)]\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::map_unwrap_or`\n+LL | #![warn(clippy::if_let_some_result)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::match_result_ok`\n \n-error: lint `clippy::option_unwrap_used` has been renamed to `clippy::unwrap_used`\n+error: lint `clippy::new_without_default_derive` has been renamed to `clippy::new_without_default`\n   --> $DIR/rename.rs:46:9\n    |\n-LL | #![warn(clippy::option_unwrap_used)]\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::unwrap_used`\n+LL | #![warn(clippy::new_without_default_derive)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::new_without_default`\n \n-error: lint `clippy::result_unwrap_used` has been renamed to `clippy::unwrap_used`\n+error: lint `clippy::option_and_then_some` has been renamed to `clippy::bind_instead_of_map`\n   --> $DIR/rename.rs:47:9\n    |\n-LL | #![warn(clippy::result_unwrap_used)]\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::unwrap_used`\n+LL | #![warn(clippy::option_and_then_some)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::bind_instead_of_map`\n \n error: lint `clippy::option_expect_used` has been renamed to `clippy::expect_used`\n   --> $DIR/rename.rs:48:9\n    |\n LL | #![warn(clippy::option_expect_used)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::expect_used`\n \n-error: lint `clippy::result_expect_used` has been renamed to `clippy::expect_used`\n+error: lint `clippy::option_map_unwrap_or` has been renamed to `clippy::map_unwrap_or`\n   --> $DIR/rename.rs:49:9\n    |\n-LL | #![warn(clippy::result_expect_used)]\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::expect_used`\n+LL | #![warn(clippy::option_map_unwrap_or)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::map_unwrap_or`\n \n-error: lint `clippy::for_loop_over_option` has been renamed to `clippy::for_loops_over_fallibles`\n+error: lint `clippy::option_map_unwrap_or_else` has been renamed to `clippy::map_unwrap_or`\n   --> $DIR/rename.rs:50:9\n    |\n-LL | #![warn(clippy::for_loop_over_option)]\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::for_loops_over_fallibles`\n+LL | #![warn(clippy::option_map_unwrap_or_else)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::map_unwrap_or`\n \n-error: lint `clippy::for_loop_over_result` has been renamed to `clippy::for_loops_over_fallibles`\n+error: lint `clippy::option_unwrap_used` has been renamed to `clippy::unwrap_used`\n   --> $DIR/rename.rs:51:9\n    |\n-LL | #![warn(clippy::for_loop_over_result)]\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::for_loops_over_fallibles`\n+LL | #![warn(clippy::option_unwrap_used)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::unwrap_used`\n \n-error: lint `clippy::identity_conversion` has been renamed to `clippy::useless_conversion`\n+error: lint `clippy::ref_in_deref` has been renamed to `clippy::needless_borrow`\n   --> $DIR/rename.rs:52:9\n    |\n-LL | #![warn(clippy::identity_conversion)]\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::useless_conversion`\n+LL | #![warn(clippy::ref_in_deref)]\n+   |         ^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::needless_borrow`\n \n-error: lint `clippy::zero_width_space` has been renamed to `clippy::invisible_characters`\n+error: lint `clippy::result_expect_used` has been renamed to `clippy::expect_used`\n   --> $DIR/rename.rs:53:9\n    |\n-LL | #![warn(clippy::zero_width_space)]\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::invisible_characters`\n+LL | #![warn(clippy::result_expect_used)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::expect_used`\n \n-error: lint `clippy::single_char_push_str` has been renamed to `clippy::single_char_add_str`\n+error: lint `clippy::result_map_unwrap_or_else` has been renamed to `clippy::map_unwrap_or`\n   --> $DIR/rename.rs:54:9\n    |\n-LL | #![warn(clippy::single_char_push_str)]\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::single_char_add_str`\n+LL | #![warn(clippy::result_map_unwrap_or_else)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::map_unwrap_or`\n \n-error: lint `clippy::if_let_some_result` has been renamed to `clippy::match_result_ok`\n+error: lint `clippy::result_unwrap_used` has been renamed to `clippy::unwrap_used`\n   --> $DIR/rename.rs:55:9\n    |\n-LL | #![warn(clippy::if_let_some_result)]\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::match_result_ok`\n+LL | #![warn(clippy::result_unwrap_used)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::unwrap_used`\n \n-error: lint `clippy::disallowed_type` has been renamed to `clippy::disallowed_types`\n+error: lint `clippy::single_char_push_str` has been renamed to `clippy::single_char_add_str`\n   --> $DIR/rename.rs:56:9\n    |\n-LL | #![warn(clippy::disallowed_type)]\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::disallowed_types`\n+LL | #![warn(clippy::single_char_push_str)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::single_char_add_str`\n \n-error: lint `clippy::disallowed_method` has been renamed to `clippy::disallowed_methods`\n+error: lint `clippy::stutter` has been renamed to `clippy::module_name_repetitions`\n   --> $DIR/rename.rs:57:9\n    |\n-LL | #![warn(clippy::disallowed_method)]\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::disallowed_methods`\n+LL | #![warn(clippy::stutter)]\n+   |         ^^^^^^^^^^^^^^^ help: use the new name: `clippy::module_name_repetitions`\n \n-error: lint `clippy::ref_in_deref` has been renamed to `clippy::needless_borrow`\n+error: lint `clippy::to_string_in_display` has been renamed to `clippy::recursive_format_impl`\n   --> $DIR/rename.rs:58:9\n    |\n-LL | #![warn(clippy::ref_in_deref)]\n-   |         ^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::needless_borrow`\n+LL | #![warn(clippy::to_string_in_display)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::recursive_format_impl`\n \n-error: lint `clippy::to_string_in_display` has been renamed to `clippy::recursive_format_impl`\n+error: lint `clippy::zero_width_space` has been renamed to `clippy::invisible_characters`\n   --> $DIR/rename.rs:59:9\n    |\n-LL | #![warn(clippy::to_string_in_display)]\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::recursive_format_impl`\n+LL | #![warn(clippy::zero_width_space)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `clippy::invisible_characters`\n \n-error: lint `clippy::invalid_ref` has been renamed to `invalid_value`\n-  --> $DIR/rename.rs:61:9\n+error: lint `clippy::drop_bounds` has been renamed to `drop_bounds`\n+  --> $DIR/rename.rs:60:9\n    |\n-LL | #![warn(clippy::invalid_ref)]\n-   |         ^^^^^^^^^^^^^^^^^^^ help: use the new name: `invalid_value`\n+LL | #![warn(clippy::drop_bounds)]\n+   |         ^^^^^^^^^^^^^^^^^^^ help: use the new name: `drop_bounds`\n \n error: lint `clippy::into_iter_on_array` has been renamed to `array_into_iter`\n-  --> $DIR/rename.rs:62:9\n+  --> $DIR/rename.rs:61:9\n    |\n LL | #![warn(clippy::into_iter_on_array)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `array_into_iter`\n \n-error: lint `clippy::unused_label` has been renamed to `unused_labels`\n+error: lint `clippy::invalid_atomic_ordering` has been renamed to `invalid_atomic_ordering`\n+  --> $DIR/rename.rs:62:9\n+   |\n+LL | #![warn(clippy::invalid_atomic_ordering)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `invalid_atomic_ordering`\n+\n+error: lint `clippy::invalid_ref` has been renamed to `invalid_value`\n   --> $DIR/rename.rs:63:9\n    |\n-LL | #![warn(clippy::unused_label)]\n-   |         ^^^^^^^^^^^^^^^^^^^^ help: use the new name: `unused_labels`\n+LL | #![warn(clippy::invalid_ref)]\n+   |         ^^^^^^^^^^^^^^^^^^^ help: use the new name: `invalid_value`\n \n-error: lint `clippy::drop_bounds` has been renamed to `drop_bounds`\n+error: lint `clippy::mem_discriminant_non_enum` has been renamed to `enum_intrinsics_non_enums`\n   --> $DIR/rename.rs:64:9\n    |\n-LL | #![warn(clippy::drop_bounds)]\n-   |         ^^^^^^^^^^^^^^^^^^^ help: use the new name: `drop_bounds`\n+LL | #![warn(clippy::mem_discriminant_non_enum)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `enum_intrinsics_non_enums`\n \n-error: lint `clippy::temporary_cstring_as_ptr` has been renamed to `temporary_cstring_as_ptr`\n+error: lint `clippy::panic_params` has been renamed to `non_fmt_panics`\n   --> $DIR/rename.rs:65:9\n    |\n-LL | #![warn(clippy::temporary_cstring_as_ptr)]\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `temporary_cstring_as_ptr`\n+LL | #![warn(clippy::panic_params)]\n+   |         ^^^^^^^^^^^^^^^^^^^^ help: use the new name: `non_fmt_panics`\n \n-error: lint `clippy::panic_params` has been renamed to `non_fmt_panics`\n+error: lint `clippy::temporary_cstring_as_ptr` has been renamed to `temporary_cstring_as_ptr`\n   --> $DIR/rename.rs:66:9\n    |\n-LL | #![warn(clippy::panic_params)]\n-   |         ^^^^^^^^^^^^^^^^^^^^ help: use the new name: `non_fmt_panics`\n+LL | #![warn(clippy::temporary_cstring_as_ptr)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `temporary_cstring_as_ptr`\n \n error: lint `clippy::unknown_clippy_lints` has been renamed to `unknown_lints`\n   --> $DIR/rename.rs:67:9\n    |\n LL | #![warn(clippy::unknown_clippy_lints)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `unknown_lints`\n \n-error: lint `clippy::invalid_atomic_ordering` has been renamed to `invalid_atomic_ordering`\n+error: lint `clippy::unused_label` has been renamed to `unused_labels`\n   --> $DIR/rename.rs:68:9\n    |\n-LL | #![warn(clippy::invalid_atomic_ordering)]\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `invalid_atomic_ordering`\n-\n-error: lint `clippy::mem_discriminant_non_enum` has been renamed to `enum_intrinsics_non_enums`\n-  --> $DIR/rename.rs:69:9\n-   |\n-LL | #![warn(clippy::mem_discriminant_non_enum)]\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use the new name: `enum_intrinsics_non_enums`\n+LL | #![warn(clippy::unused_label)]\n+   |         ^^^^^^^^^^^^^^^^^^^^ help: use the new name: `unused_labels`\n \n error: aborting due to 34 previous errors\n "}, {"sha": "086331af6b5673fed75858630f90677e24f5e22c", "filename": "tests/ui/rest_pat_in_fully_bound_structs.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Frest_pat_in_fully_bound_structs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Frest_pat_in_fully_bound_structs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frest_pat_in_fully_bound_structs.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -39,4 +39,19 @@ fn main() {\n \n     // No lint\n     foo!(a_struct);\n+\n+    #[non_exhaustive]\n+    struct B {\n+        a: u32,\n+        b: u32,\n+        c: u64,\n+    }\n+\n+    let b_struct = B { a: 5, b: 42, c: 342 };\n+\n+    match b_struct {\n+        B { a: 5, b: 42, .. } => {},\n+        B { a: 0, b: 0, c: 128, .. } => {}, // No Lint\n+        _ => {},\n+    }\n }"}, {"sha": "3d2295912c9fd08827596a2cef226b76f58e17b0", "filename": "tests/ui/same_functions_in_if_condition.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fsame_functions_in_if_condition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fsame_functions_in_if_condition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsame_functions_in_if_condition.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -1,3 +1,5 @@\n+#![feature(adt_const_params)]\n+#![allow(incomplete_features)]\n #![warn(clippy::same_functions_in_if_condition)]\n #![allow(clippy::ifs_same_cond)] // This warning is different from `ifs_same_cond`.\n #![allow(clippy::if_same_then_else, clippy::comparison_chain)] // all empty blocks\n@@ -87,4 +89,21 @@ fn main() {\n         \"linux\"\n     };\n     println!(\"{}\", os);\n+\n+    #[derive(PartialEq, Eq)]\n+    enum E {\n+        A,\n+        B,\n+    }\n+    fn generic<const P: E>() -> bool {\n+        match P {\n+            E::A => true,\n+            E::B => false,\n+        }\n+    }\n+    if generic::<{ E::A }>() {\n+        println!(\"A\");\n+    } else if generic::<{ E::B }>() {\n+        println!(\"B\");\n+    }\n }"}, {"sha": "71e82910ef7529e6cbef6c67426b334301941ba0", "filename": "tests/ui/same_functions_in_if_condition.stderr", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fsame_functions_in_if_condition.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fsame_functions_in_if_condition.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsame_functions_in_if_condition.stderr?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -1,72 +1,72 @@\n error: this `if` has the same function call as a previous `if`\n-  --> $DIR/same_functions_in_if_condition.rs:29:15\n+  --> $DIR/same_functions_in_if_condition.rs:31:15\n    |\n LL |     } else if function() {\n    |               ^^^^^^^^^^\n    |\n    = note: `-D clippy::same-functions-in-if-condition` implied by `-D warnings`\n note: same as this\n-  --> $DIR/same_functions_in_if_condition.rs:28:8\n+  --> $DIR/same_functions_in_if_condition.rs:30:8\n    |\n LL |     if function() {\n    |        ^^^^^^^^^^\n \n error: this `if` has the same function call as a previous `if`\n-  --> $DIR/same_functions_in_if_condition.rs:34:15\n+  --> $DIR/same_functions_in_if_condition.rs:36:15\n    |\n LL |     } else if fn_arg(a) {\n    |               ^^^^^^^^^\n    |\n note: same as this\n-  --> $DIR/same_functions_in_if_condition.rs:33:8\n+  --> $DIR/same_functions_in_if_condition.rs:35:8\n    |\n LL |     if fn_arg(a) {\n    |        ^^^^^^^^^\n \n error: this `if` has the same function call as a previous `if`\n-  --> $DIR/same_functions_in_if_condition.rs:39:15\n+  --> $DIR/same_functions_in_if_condition.rs:41:15\n    |\n LL |     } else if obj.method() {\n    |               ^^^^^^^^^^^^\n    |\n note: same as this\n-  --> $DIR/same_functions_in_if_condition.rs:38:8\n+  --> $DIR/same_functions_in_if_condition.rs:40:8\n    |\n LL |     if obj.method() {\n    |        ^^^^^^^^^^^^\n \n error: this `if` has the same function call as a previous `if`\n-  --> $DIR/same_functions_in_if_condition.rs:44:15\n+  --> $DIR/same_functions_in_if_condition.rs:46:15\n    |\n LL |     } else if obj.method_arg(a) {\n    |               ^^^^^^^^^^^^^^^^^\n    |\n note: same as this\n-  --> $DIR/same_functions_in_if_condition.rs:43:8\n+  --> $DIR/same_functions_in_if_condition.rs:45:8\n    |\n LL |     if obj.method_arg(a) {\n    |        ^^^^^^^^^^^^^^^^^\n \n error: this `if` has the same function call as a previous `if`\n-  --> $DIR/same_functions_in_if_condition.rs:51:15\n+  --> $DIR/same_functions_in_if_condition.rs:53:15\n    |\n LL |     } else if v.pop() == None {\n    |               ^^^^^^^^^^^^^^^\n    |\n note: same as this\n-  --> $DIR/same_functions_in_if_condition.rs:49:8\n+  --> $DIR/same_functions_in_if_condition.rs:51:8\n    |\n LL |     if v.pop() == None {\n    |        ^^^^^^^^^^^^^^^\n \n error: this `if` has the same function call as a previous `if`\n-  --> $DIR/same_functions_in_if_condition.rs:56:15\n+  --> $DIR/same_functions_in_if_condition.rs:58:15\n    |\n LL |     } else if v.len() == 42 {\n    |               ^^^^^^^^^^^^^\n    |\n note: same as this\n-  --> $DIR/same_functions_in_if_condition.rs:54:8\n+  --> $DIR/same_functions_in_if_condition.rs:56:8\n    |\n LL |     if v.len() == 42 {\n    |        ^^^^^^^^^^^^^"}, {"sha": "a394ef8f25c675b529db3c275eb97308fe835b5b", "filename": "tests/ui/shadow.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fshadow.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -1,4 +1,5 @@\n #![warn(clippy::shadow_same, clippy::shadow_reuse, clippy::shadow_unrelated)]\n+#![allow(clippy::let_unit_value)]\n \n fn shadow_same() {\n     let x = 1;"}, {"sha": "3bd41d0626049da49e07ce5c0f50ce10c6f2c0d4", "filename": "tests/ui/shadow.stderr", "status": "modified", "additions": 44, "deletions": 44, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fshadow.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fshadow.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fshadow.stderr?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -1,266 +1,266 @@\n error: `x` is shadowed by itself in `x`\n-  --> $DIR/shadow.rs:5:9\n+  --> $DIR/shadow.rs:6:9\n    |\n LL |     let x = x;\n    |         ^\n    |\n    = note: `-D clippy::shadow-same` implied by `-D warnings`\n note: previous binding is here\n-  --> $DIR/shadow.rs:4:9\n+  --> $DIR/shadow.rs:5:9\n    |\n LL |     let x = 1;\n    |         ^\n \n error: `mut x` is shadowed by itself in `&x`\n-  --> $DIR/shadow.rs:6:13\n+  --> $DIR/shadow.rs:7:13\n    |\n LL |     let mut x = &x;\n    |             ^\n    |\n note: previous binding is here\n-  --> $DIR/shadow.rs:5:9\n+  --> $DIR/shadow.rs:6:9\n    |\n LL |     let x = x;\n    |         ^\n \n error: `x` is shadowed by itself in `&mut x`\n-  --> $DIR/shadow.rs:7:9\n+  --> $DIR/shadow.rs:8:9\n    |\n LL |     let x = &mut x;\n    |         ^\n    |\n note: previous binding is here\n-  --> $DIR/shadow.rs:6:9\n+  --> $DIR/shadow.rs:7:9\n    |\n LL |     let mut x = &x;\n    |         ^^^^^\n \n error: `x` is shadowed by itself in `*x`\n-  --> $DIR/shadow.rs:8:9\n+  --> $DIR/shadow.rs:9:9\n    |\n LL |     let x = *x;\n    |         ^\n    |\n note: previous binding is here\n-  --> $DIR/shadow.rs:7:9\n+  --> $DIR/shadow.rs:8:9\n    |\n LL |     let x = &mut x;\n    |         ^\n \n error: `x` is shadowed\n-  --> $DIR/shadow.rs:13:9\n+  --> $DIR/shadow.rs:14:9\n    |\n LL |     let x = x.0;\n    |         ^\n    |\n    = note: `-D clippy::shadow-reuse` implied by `-D warnings`\n note: previous binding is here\n-  --> $DIR/shadow.rs:12:9\n+  --> $DIR/shadow.rs:13:9\n    |\n LL |     let x = ([[0]], ());\n    |         ^\n \n error: `x` is shadowed\n-  --> $DIR/shadow.rs:14:9\n+  --> $DIR/shadow.rs:15:9\n    |\n LL |     let x = x[0];\n    |         ^\n    |\n note: previous binding is here\n-  --> $DIR/shadow.rs:13:9\n+  --> $DIR/shadow.rs:14:9\n    |\n LL |     let x = x.0;\n    |         ^\n \n error: `x` is shadowed\n-  --> $DIR/shadow.rs:15:10\n+  --> $DIR/shadow.rs:16:10\n    |\n LL |     let [x] = x;\n    |          ^\n    |\n note: previous binding is here\n-  --> $DIR/shadow.rs:14:9\n+  --> $DIR/shadow.rs:15:9\n    |\n LL |     let x = x[0];\n    |         ^\n \n error: `x` is shadowed\n-  --> $DIR/shadow.rs:16:9\n+  --> $DIR/shadow.rs:17:9\n    |\n LL |     let x = Some(x);\n    |         ^\n    |\n note: previous binding is here\n-  --> $DIR/shadow.rs:15:10\n+  --> $DIR/shadow.rs:16:10\n    |\n LL |     let [x] = x;\n    |          ^\n \n error: `x` is shadowed\n-  --> $DIR/shadow.rs:17:9\n+  --> $DIR/shadow.rs:18:9\n    |\n LL |     let x = foo(x);\n    |         ^\n    |\n note: previous binding is here\n-  --> $DIR/shadow.rs:16:9\n+  --> $DIR/shadow.rs:17:9\n    |\n LL |     let x = Some(x);\n    |         ^\n \n error: `x` is shadowed\n-  --> $DIR/shadow.rs:18:9\n+  --> $DIR/shadow.rs:19:9\n    |\n LL |     let x = || x;\n    |         ^\n    |\n note: previous binding is here\n-  --> $DIR/shadow.rs:17:9\n+  --> $DIR/shadow.rs:18:9\n    |\n LL |     let x = foo(x);\n    |         ^\n \n error: `x` is shadowed\n-  --> $DIR/shadow.rs:19:9\n+  --> $DIR/shadow.rs:20:9\n    |\n LL |     let x = Some(1).map(|_| x)?;\n    |         ^\n    |\n note: previous binding is here\n-  --> $DIR/shadow.rs:18:9\n+  --> $DIR/shadow.rs:19:9\n    |\n LL |     let x = || x;\n    |         ^\n \n error: `y` is shadowed\n-  --> $DIR/shadow.rs:21:9\n+  --> $DIR/shadow.rs:22:9\n    |\n LL |     let y = match y {\n    |         ^\n    |\n note: previous binding is here\n-  --> $DIR/shadow.rs:20:9\n+  --> $DIR/shadow.rs:21:9\n    |\n LL |     let y = 1;\n    |         ^\n \n error: `x` shadows a previous, unrelated binding\n-  --> $DIR/shadow.rs:30:9\n+  --> $DIR/shadow.rs:31:9\n    |\n LL |     let x = 2;\n    |         ^\n    |\n    = note: `-D clippy::shadow-unrelated` implied by `-D warnings`\n note: previous binding is here\n-  --> $DIR/shadow.rs:29:9\n+  --> $DIR/shadow.rs:30:9\n    |\n LL |     let x = 1;\n    |         ^\n \n error: `x` shadows a previous, unrelated binding\n-  --> $DIR/shadow.rs:35:13\n+  --> $DIR/shadow.rs:36:13\n    |\n LL |         let x = 1;\n    |             ^\n    |\n note: previous binding is here\n-  --> $DIR/shadow.rs:34:10\n+  --> $DIR/shadow.rs:35:10\n    |\n LL |     fn f(x: u32) {\n    |          ^\n \n error: `x` shadows a previous, unrelated binding\n-  --> $DIR/shadow.rs:40:14\n+  --> $DIR/shadow.rs:41:14\n    |\n LL |         Some(x) => {\n    |              ^\n    |\n note: previous binding is here\n-  --> $DIR/shadow.rs:37:9\n+  --> $DIR/shadow.rs:38:9\n    |\n LL |     let x = 1;\n    |         ^\n \n error: `x` shadows a previous, unrelated binding\n-  --> $DIR/shadow.rs:41:17\n+  --> $DIR/shadow.rs:42:17\n    |\n LL |             let x = 1;\n    |                 ^\n    |\n note: previous binding is here\n-  --> $DIR/shadow.rs:40:14\n+  --> $DIR/shadow.rs:41:14\n    |\n LL |         Some(x) => {\n    |              ^\n \n error: `x` shadows a previous, unrelated binding\n-  --> $DIR/shadow.rs:45:17\n+  --> $DIR/shadow.rs:46:17\n    |\n LL |     if let Some(x) = Some(1) {}\n    |                 ^\n    |\n note: previous binding is here\n-  --> $DIR/shadow.rs:37:9\n+  --> $DIR/shadow.rs:38:9\n    |\n LL |     let x = 1;\n    |         ^\n \n error: `x` shadows a previous, unrelated binding\n-  --> $DIR/shadow.rs:46:20\n+  --> $DIR/shadow.rs:47:20\n    |\n LL |     while let Some(x) = Some(1) {}\n    |                    ^\n    |\n note: previous binding is here\n-  --> $DIR/shadow.rs:37:9\n+  --> $DIR/shadow.rs:38:9\n    |\n LL |     let x = 1;\n    |         ^\n \n error: `x` shadows a previous, unrelated binding\n-  --> $DIR/shadow.rs:47:15\n+  --> $DIR/shadow.rs:48:15\n    |\n LL |     let _ = |[x]: [u32; 1]| {\n    |               ^\n    |\n note: previous binding is here\n-  --> $DIR/shadow.rs:37:9\n+  --> $DIR/shadow.rs:38:9\n    |\n LL |     let x = 1;\n    |         ^\n \n error: `x` shadows a previous, unrelated binding\n-  --> $DIR/shadow.rs:48:13\n+  --> $DIR/shadow.rs:49:13\n    |\n LL |         let x = 1;\n    |             ^\n    |\n note: previous binding is here\n-  --> $DIR/shadow.rs:47:15\n+  --> $DIR/shadow.rs:48:15\n    |\n LL |     let _ = |[x]: [u32; 1]| {\n    |               ^\n \n error: `y` is shadowed\n-  --> $DIR/shadow.rs:51:17\n+  --> $DIR/shadow.rs:52:17\n    |\n LL |     if let Some(y) = y {}\n    |                 ^\n    |\n note: previous binding is here\n-  --> $DIR/shadow.rs:50:9\n+  --> $DIR/shadow.rs:51:9\n    |\n LL |     let y = Some(1);\n    |         ^\n \n error: `_b` shadows a previous, unrelated binding\n-  --> $DIR/shadow.rs:87:9\n+  --> $DIR/shadow.rs:88:9\n    |\n LL |     let _b = _a;\n    |         ^^\n    |\n note: previous binding is here\n-  --> $DIR/shadow.rs:86:28\n+  --> $DIR/shadow.rs:87:28\n    |\n LL | pub async fn foo2(_a: i32, _b: i64) {\n    |                            ^^"}, {"sha": "c21225d153bd6cf7d928592030e8e44a25cb1cc2", "filename": "tests/ui/similar_names.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fsimilar_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fsimilar_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsimilar_names.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -3,7 +3,8 @@\n     unused,\n     clippy::println_empty_string,\n     clippy::empty_loop,\n-    clippy::diverging_sub_expression\n+    clippy::diverging_sub_expression,\n+    clippy::let_unit_value\n )]\n \n struct Foo {"}, {"sha": "6e77269389737946b636198d686918ec9e8b2f5a", "filename": "tests/ui/similar_names.stderr", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fsimilar_names.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fsimilar_names.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsimilar_names.stderr?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -1,84 +1,84 @@\n error: binding's name is too similar to existing binding\n-  --> $DIR/similar_names.rs:20:9\n+  --> $DIR/similar_names.rs:21:9\n    |\n LL |     let bpple: i32;\n    |         ^^^^^\n    |\n    = note: `-D clippy::similar-names` implied by `-D warnings`\n note: existing binding defined here\n-  --> $DIR/similar_names.rs:18:9\n+  --> $DIR/similar_names.rs:19:9\n    |\n LL |     let apple: i32;\n    |         ^^^^^\n \n error: binding's name is too similar to existing binding\n-  --> $DIR/similar_names.rs:22:9\n+  --> $DIR/similar_names.rs:23:9\n    |\n LL |     let cpple: i32;\n    |         ^^^^^\n    |\n note: existing binding defined here\n-  --> $DIR/similar_names.rs:18:9\n+  --> $DIR/similar_names.rs:19:9\n    |\n LL |     let apple: i32;\n    |         ^^^^^\n \n error: binding's name is too similar to existing binding\n-  --> $DIR/similar_names.rs:46:9\n+  --> $DIR/similar_names.rs:47:9\n    |\n LL |     let bluby: i32;\n    |         ^^^^^\n    |\n note: existing binding defined here\n-  --> $DIR/similar_names.rs:45:9\n+  --> $DIR/similar_names.rs:46:9\n    |\n LL |     let blubx: i32;\n    |         ^^^^^\n \n error: binding's name is too similar to existing binding\n-  --> $DIR/similar_names.rs:50:9\n+  --> $DIR/similar_names.rs:51:9\n    |\n LL |     let coke: i32;\n    |         ^^^^\n    |\n note: existing binding defined here\n-  --> $DIR/similar_names.rs:48:9\n+  --> $DIR/similar_names.rs:49:9\n    |\n LL |     let cake: i32;\n    |         ^^^^\n \n error: binding's name is too similar to existing binding\n-  --> $DIR/similar_names.rs:68:9\n+  --> $DIR/similar_names.rs:69:9\n    |\n LL |     let xyzeabc: i32;\n    |         ^^^^^^^\n    |\n note: existing binding defined here\n-  --> $DIR/similar_names.rs:66:9\n+  --> $DIR/similar_names.rs:67:9\n    |\n LL |     let xyz1abc: i32;\n    |         ^^^^^^^\n \n error: binding's name is too similar to existing binding\n-  --> $DIR/similar_names.rs:72:9\n+  --> $DIR/similar_names.rs:73:9\n    |\n LL |     let parsee: i32;\n    |         ^^^^^^\n    |\n note: existing binding defined here\n-  --> $DIR/similar_names.rs:70:9\n+  --> $DIR/similar_names.rs:71:9\n    |\n LL |     let parser: i32;\n    |         ^^^^^^\n \n error: binding's name is too similar to existing binding\n-  --> $DIR/similar_names.rs:93:16\n+  --> $DIR/similar_names.rs:94:16\n    |\n LL |         bpple: sprang,\n    |                ^^^^^^\n    |\n note: existing binding defined here\n-  --> $DIR/similar_names.rs:92:16\n+  --> $DIR/similar_names.rs:93:16\n    |\n LL |         apple: spring,\n    |                ^^^^^^"}, {"sha": "69c5b236f7cf8dea4d221d6c444cc7fcb12e058e", "filename": "tests/ui/single_char_lifetime_names.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fsingle_char_lifetime_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fsingle_char_lifetime_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsingle_char_lifetime_names.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -1,4 +1,5 @@\n #![warn(clippy::single_char_lifetime_names)]\n+#![allow(clippy::let_unit_value)]\n \n // Lifetimes should only be linted when they're introduced\n struct DiagnosticCtx<'a, 'b>"}, {"sha": "1438b3999dba85ad1b4ddc810854958fb0296dfb", "filename": "tests/ui/single_char_lifetime_names.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fsingle_char_lifetime_names.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fsingle_char_lifetime_names.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsingle_char_lifetime_names.stderr?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -1,5 +1,5 @@\n error: single-character lifetime names are likely uninformative\n-  --> $DIR/single_char_lifetime_names.rs:4:22\n+  --> $DIR/single_char_lifetime_names.rs:5:22\n    |\n LL | struct DiagnosticCtx<'a, 'b>\n    |                      ^^\n@@ -8,31 +8,31 @@ LL | struct DiagnosticCtx<'a, 'b>\n    = help: use a more informative name\n \n error: single-character lifetime names are likely uninformative\n-  --> $DIR/single_char_lifetime_names.rs:4:26\n+  --> $DIR/single_char_lifetime_names.rs:5:26\n    |\n LL | struct DiagnosticCtx<'a, 'b>\n    |                          ^^\n    |\n    = help: use a more informative name\n \n error: single-character lifetime names are likely uninformative\n-  --> $DIR/single_char_lifetime_names.rs:13:6\n+  --> $DIR/single_char_lifetime_names.rs:14:6\n    |\n LL | impl<'a, 'b> DiagnosticCtx<'a, 'b> {\n    |      ^^\n    |\n    = help: use a more informative name\n \n error: single-character lifetime names are likely uninformative\n-  --> $DIR/single_char_lifetime_names.rs:13:10\n+  --> $DIR/single_char_lifetime_names.rs:14:10\n    |\n LL | impl<'a, 'b> DiagnosticCtx<'a, 'b> {\n    |          ^^\n    |\n    = help: use a more informative name\n \n error: single-character lifetime names are likely uninformative\n-  --> $DIR/single_char_lifetime_names.rs:33:15\n+  --> $DIR/single_char_lifetime_names.rs:34:15\n    |\n LL | fn split_once<'a>(base: &'a str, other: &'_ str) -> (&'a str, Option<&'a str>) {\n    |               ^^"}, {"sha": "82387f3d80b7780a0781dd116dfbbd341d47a3b8", "filename": "tests/ui/single_match_else.rs", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fsingle_match_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fsingle_match_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsingle_match_else.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -1,7 +1,12 @@\n+// aux-build: proc_macro_with_span.rs\n+\n #![warn(clippy::single_match_else)]\n #![allow(clippy::needless_return)]\n #![allow(clippy::no_effect)]\n \n+extern crate proc_macro_with_span;\n+use proc_macro_with_span::with_span;\n+\n enum ExprNode {\n     ExprAddrOf,\n     Butterflies,\n@@ -11,13 +16,22 @@ enum ExprNode {\n static NODE: ExprNode = ExprNode::Unicorns;\n \n fn unwrap_addr() -> Option<&'static ExprNode> {\n-    match ExprNode::Butterflies {\n+    let _ = match ExprNode::Butterflies {\n         ExprNode::ExprAddrOf => Some(&NODE),\n         _ => {\n             let x = 5;\n             None\n         },\n-    }\n+    };\n+\n+    // Don't lint\n+    with_span!(span match ExprNode::Butterflies {\n+        ExprNode::ExprAddrOf => Some(&NODE),\n+        _ => {\n+            let x = 5;\n+            None\n+        },\n+    })\n }\n \n macro_rules! unwrap_addr {"}, {"sha": "7756c6f204e67eb016ecf792a3d6cfb7b70efc66", "filename": "tests/ui/single_match_else.stderr", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fsingle_match_else.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fsingle_match_else.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsingle_match_else.stderr?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -1,22 +1,23 @@\n error: you seem to be trying to use `match` for destructuring a single pattern. Consider using `if let`\n-  --> $DIR/single_match_else.rs:14:5\n+  --> $DIR/single_match_else.rs:19:13\n    |\n-LL | /     match ExprNode::Butterflies {\n+LL |       let _ = match ExprNode::Butterflies {\n+   |  _____________^\n LL | |         ExprNode::ExprAddrOf => Some(&NODE),\n LL | |         _ => {\n LL | |             let x = 5;\n LL | |             None\n LL | |         },\n-LL | |     }\n+LL | |     };\n    | |_____^\n    |\n    = note: `-D clippy::single-match-else` implied by `-D warnings`\n help: try this\n    |\n-LL ~     if let ExprNode::ExprAddrOf = ExprNode::Butterflies { Some(&NODE) } else {\n+LL ~     let _ = if let ExprNode::ExprAddrOf = ExprNode::Butterflies { Some(&NODE) } else {\n LL +         let x = 5;\n LL +         None\n-LL +     }\n+LL ~     };\n    |\n \n error: aborting due to previous error"}, {"sha": "c35e0c22ae8994a4cced07921e44d0b281f306c6", "filename": "tests/ui/stable_sort_primitive.stderr", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fstable_sort_primitive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fstable_sort_primitive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fstable_sort_primitive.stderr?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -5,55 +5,55 @@ LL |     vec.sort();\n    |     ^^^^^^^^^^ help: try: `vec.sort_unstable()`\n    |\n    = note: `-D clippy::stable-sort-primitive` implied by `-D warnings`\n-   = note: an unstable sort would perform faster without any observable difference for this data type\n+   = note: an unstable sort typically performs faster without any observable difference for this data type\n \n error: used `sort` on primitive type `bool`\n   --> $DIR/stable_sort_primitive.rs:9:5\n    |\n LL |     vec.sort();\n    |     ^^^^^^^^^^ help: try: `vec.sort_unstable()`\n    |\n-   = note: an unstable sort would perform faster without any observable difference for this data type\n+   = note: an unstable sort typically performs faster without any observable difference for this data type\n \n error: used `sort` on primitive type `char`\n   --> $DIR/stable_sort_primitive.rs:11:5\n    |\n LL |     vec.sort();\n    |     ^^^^^^^^^^ help: try: `vec.sort_unstable()`\n    |\n-   = note: an unstable sort would perform faster without any observable difference for this data type\n+   = note: an unstable sort typically performs faster without any observable difference for this data type\n \n error: used `sort` on primitive type `str`\n   --> $DIR/stable_sort_primitive.rs:13:5\n    |\n LL |     vec.sort();\n    |     ^^^^^^^^^^ help: try: `vec.sort_unstable()`\n    |\n-   = note: an unstable sort would perform faster without any observable difference for this data type\n+   = note: an unstable sort typically performs faster without any observable difference for this data type\n \n error: used `sort` on primitive type `tuple`\n   --> $DIR/stable_sort_primitive.rs:15:5\n    |\n LL |     vec.sort();\n    |     ^^^^^^^^^^ help: try: `vec.sort_unstable()`\n    |\n-   = note: an unstable sort would perform faster without any observable difference for this data type\n+   = note: an unstable sort typically performs faster without any observable difference for this data type\n \n error: used `sort` on primitive type `array`\n   --> $DIR/stable_sort_primitive.rs:17:5\n    |\n LL |     vec.sort();\n    |     ^^^^^^^^^^ help: try: `vec.sort_unstable()`\n    |\n-   = note: an unstable sort would perform faster without any observable difference for this data type\n+   = note: an unstable sort typically performs faster without any observable difference for this data type\n \n error: used `sort` on primitive type `i32`\n   --> $DIR/stable_sort_primitive.rs:19:5\n    |\n LL |     arr.sort();\n    |     ^^^^^^^^^^ help: try: `arr.sort_unstable()`\n    |\n-   = note: an unstable sort would perform faster without any observable difference for this data type\n+   = note: an unstable sort typically performs faster without any observable difference for this data type\n \n error: aborting due to 7 previous errors\n "}, {"sha": "21753e5dc6a47c0546f43f6210392062821d9c9a", "filename": "tests/ui/suspicious_else_formatting.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fsuspicious_else_formatting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fsuspicious_else_formatting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuspicious_else_formatting.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -1,7 +1,7 @@\n // aux-build:proc_macro_suspicious_else_formatting.rs\n \n #![warn(clippy::suspicious_else_formatting)]\n-#![allow(clippy::if_same_then_else)]\n+#![allow(clippy::if_same_then_else, clippy::let_unit_value)]\n \n extern crate proc_macro_suspicious_else_formatting;\n use proc_macro_suspicious_else_formatting::DeriveBadSpan;"}, {"sha": "3c5e9642714657676c3a950ca78c4ac51af3e687", "filename": "tests/ui/to_digit_is_some.fixed", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fto_digit_is_some.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fto_digit_is_some.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fto_digit_is_some.fixed?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -6,6 +6,6 @@ fn main() {\n     let c = 'x';\n     let d = &c;\n \n-    let _ = d.is_digit(10);\n-    let _ = char::is_digit(c, 10);\n+    let _ = d.is_digit(8);\n+    let _ = char::is_digit(c, 8);\n }"}, {"sha": "4f247c06ceedaba747c89d5ff4b602e55c5653cb", "filename": "tests/ui/to_digit_is_some.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fto_digit_is_some.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fto_digit_is_some.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fto_digit_is_some.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -6,6 +6,6 @@ fn main() {\n     let c = 'x';\n     let d = &c;\n \n-    let _ = d.to_digit(10).is_some();\n-    let _ = char::to_digit(c, 10).is_some();\n+    let _ = d.to_digit(8).is_some();\n+    let _ = char::to_digit(c, 8).is_some();\n }"}, {"sha": "10a1b393a3906fced44d5ec028e9e9666282312c", "filename": "tests/ui/to_digit_is_some.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fto_digit_is_some.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fto_digit_is_some.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fto_digit_is_some.stderr?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -1,16 +1,16 @@\n error: use of `.to_digit(..).is_some()`\n   --> $DIR/to_digit_is_some.rs:9:13\n    |\n-LL |     let _ = d.to_digit(10).is_some();\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `d.is_digit(10)`\n+LL |     let _ = d.to_digit(8).is_some();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `d.is_digit(8)`\n    |\n    = note: `-D clippy::to-digit-is-some` implied by `-D warnings`\n \n error: use of `.to_digit(..).is_some()`\n   --> $DIR/to_digit_is_some.rs:10:13\n    |\n-LL |     let _ = char::to_digit(c, 10).is_some();\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `char::is_digit(c, 10)`\n+LL |     let _ = char::to_digit(c, 8).is_some();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `char::is_digit(c, 8)`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "a21d4c5d637daec8678ce052656d1d86bff631aa", "filename": "tests/ui/trait_duplication_in_bounds.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Ftrait_duplication_in_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Ftrait_duplication_in_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftrait_duplication_in_bounds.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -95,4 +95,7 @@ trait FooIter: Iterator<Item = Foo> {\n     }\n }\n \n+// This should not lint\n+fn impl_trait(_: impl AsRef<str>, _: impl AsRef<str>) {}\n+\n fn main() {}"}, {"sha": "d0a4cfb88370e2060620137f7e015632a96ff3e7", "filename": "tests/ui/trait_duplication_in_bounds.stderr", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Ftrait_duplication_in_bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Ftrait_duplication_in_bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftrait_duplication_in_bounds.stderr?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -67,5 +67,13 @@ LL |         Self: Iterator<Item = Foo>,\n    |\n    = help: consider removing this trait bound\n \n-error: aborting due to 8 previous errors\n+error: this trait bound is already specified in the where clause\n+  --> $DIR/trait_duplication_in_bounds.rs:99:23\n+   |\n+LL | fn impl_trait(_: impl AsRef<str>, _: impl AsRef<str>) {}\n+   |                       ^^^^^^^^^^\n+   |\n+   = help: consider removing this trait bound\n+\n+error: aborting due to 9 previous errors\n "}, {"sha": "5a431bee04a45c03d8b54ee438a1b4b003aa611a", "filename": "tests/ui/transmute_collection.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Ftransmute_collection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Ftransmute_collection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftransmute_collection.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -1,7 +1,7 @@\n #![warn(clippy::unsound_collection_transmute)]\n \n use std::collections::{BTreeMap, BTreeSet, BinaryHeap, HashMap, HashSet, VecDeque};\n-use std::mem::transmute;\n+use std::mem::{transmute, MaybeUninit};\n \n fn main() {\n     unsafe {\n@@ -43,5 +43,8 @@ fn main() {\n         // wrong layout\n         let _ = transmute::<_, HashMap<u8, u32>>(HashMap::<u8, [u8; 4]>::new());\n         let _ = transmute::<_, HashMap<u32, u32>>(HashMap::<[u8; 4], u32>::new());\n+\n+        let _ = transmute::<_, Vec<u8>>(Vec::<MaybeUninit<u8>>::new());\n+        let _ = transmute::<_, Vec<*mut u32>>(Vec::<Box<u32>>::new());\n     }\n }"}, {"sha": "e4d352f7367e4502e095b390c1e833f533e64518", "filename": "tests/ui/trim_split_whitespace.fixed", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Ftrim_split_whitespace.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Ftrim_split_whitespace.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftrim_split_whitespace.fixed?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -0,0 +1,91 @@\n+// run-rustfix\n+#![warn(clippy::trim_split_whitespace)]\n+#![allow(clippy::let_unit_value)]\n+\n+struct Custom;\n+impl Custom {\n+    fn trim(self) -> Self {\n+        self\n+    }\n+    fn split_whitespace(self) {}\n+}\n+\n+struct DerefStr(&'static str);\n+impl std::ops::Deref for DerefStr {\n+    type Target = str;\n+    fn deref(&self) -> &Self::Target {\n+        self.0\n+    }\n+}\n+\n+struct DerefStrAndCustom(&'static str);\n+impl std::ops::Deref for DerefStrAndCustom {\n+    type Target = str;\n+    fn deref(&self) -> &Self::Target {\n+        self.0\n+    }\n+}\n+impl DerefStrAndCustom {\n+    fn trim(self) -> Self {\n+        self\n+    }\n+    fn split_whitespace(self) {}\n+}\n+\n+struct DerefStrAndCustomSplit(&'static str);\n+impl std::ops::Deref for DerefStrAndCustomSplit {\n+    type Target = str;\n+    fn deref(&self) -> &Self::Target {\n+        self.0\n+    }\n+}\n+impl DerefStrAndCustomSplit {\n+    #[allow(dead_code)]\n+    fn split_whitespace(self) {}\n+}\n+\n+struct DerefStrAndCustomTrim(&'static str);\n+impl std::ops::Deref for DerefStrAndCustomTrim {\n+    type Target = str;\n+    fn deref(&self) -> &Self::Target {\n+        self.0\n+    }\n+}\n+impl DerefStrAndCustomTrim {\n+    fn trim(self) -> Self {\n+        self\n+    }\n+}\n+\n+fn main() {\n+    // &str\n+    let _ = \" A B C \".split_whitespace(); // should trigger lint\n+    let _ = \" A B C \".split_whitespace(); // should trigger lint\n+    let _ = \" A B C \".split_whitespace(); // should trigger lint\n+\n+    // String\n+    let _ = (\" A B C \").to_string().split_whitespace(); // should trigger lint\n+    let _ = (\" A B C \").to_string().split_whitespace(); // should trigger lint\n+    let _ = (\" A B C \").to_string().split_whitespace(); // should trigger lint\n+\n+    // Custom\n+    let _ = Custom.trim().split_whitespace(); // should not trigger lint\n+\n+    // Deref<Target=str>\n+    let s = DerefStr(\" A B C \");\n+    let _ = s.split_whitespace(); // should trigger lint\n+\n+    // Deref<Target=str> + custom impl\n+    let s = DerefStrAndCustom(\" A B C \");\n+    let _ = s.trim().split_whitespace(); // should not trigger lint\n+\n+    // Deref<Target=str> + only custom split_ws() impl\n+    let s = DerefStrAndCustomSplit(\" A B C \");\n+    let _ = s.split_whitespace(); // should trigger lint\n+    // Expl: trim() is called on str (deref) and returns &str.\n+    //       Thus split_ws() is called on str as well and the custom impl on S is unused\n+\n+    // Deref<Target=str> + only custom trim() impl\n+    let s = DerefStrAndCustomTrim(\" A B C \");\n+    let _ = s.trim().split_whitespace(); // should not trigger lint\n+}"}, {"sha": "f98451a983712c552019b4b9122f3c347eae72d6", "filename": "tests/ui/trim_split_whitespace.rs", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Ftrim_split_whitespace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Ftrim_split_whitespace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftrim_split_whitespace.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -0,0 +1,91 @@\n+// run-rustfix\n+#![warn(clippy::trim_split_whitespace)]\n+#![allow(clippy::let_unit_value)]\n+\n+struct Custom;\n+impl Custom {\n+    fn trim(self) -> Self {\n+        self\n+    }\n+    fn split_whitespace(self) {}\n+}\n+\n+struct DerefStr(&'static str);\n+impl std::ops::Deref for DerefStr {\n+    type Target = str;\n+    fn deref(&self) -> &Self::Target {\n+        self.0\n+    }\n+}\n+\n+struct DerefStrAndCustom(&'static str);\n+impl std::ops::Deref for DerefStrAndCustom {\n+    type Target = str;\n+    fn deref(&self) -> &Self::Target {\n+        self.0\n+    }\n+}\n+impl DerefStrAndCustom {\n+    fn trim(self) -> Self {\n+        self\n+    }\n+    fn split_whitespace(self) {}\n+}\n+\n+struct DerefStrAndCustomSplit(&'static str);\n+impl std::ops::Deref for DerefStrAndCustomSplit {\n+    type Target = str;\n+    fn deref(&self) -> &Self::Target {\n+        self.0\n+    }\n+}\n+impl DerefStrAndCustomSplit {\n+    #[allow(dead_code)]\n+    fn split_whitespace(self) {}\n+}\n+\n+struct DerefStrAndCustomTrim(&'static str);\n+impl std::ops::Deref for DerefStrAndCustomTrim {\n+    type Target = str;\n+    fn deref(&self) -> &Self::Target {\n+        self.0\n+    }\n+}\n+impl DerefStrAndCustomTrim {\n+    fn trim(self) -> Self {\n+        self\n+    }\n+}\n+\n+fn main() {\n+    // &str\n+    let _ = \" A B C \".trim().split_whitespace(); // should trigger lint\n+    let _ = \" A B C \".trim_start().split_whitespace(); // should trigger lint\n+    let _ = \" A B C \".trim_end().split_whitespace(); // should trigger lint\n+\n+    // String\n+    let _ = (\" A B C \").to_string().trim().split_whitespace(); // should trigger lint\n+    let _ = (\" A B C \").to_string().trim_start().split_whitespace(); // should trigger lint\n+    let _ = (\" A B C \").to_string().trim_end().split_whitespace(); // should trigger lint\n+\n+    // Custom\n+    let _ = Custom.trim().split_whitespace(); // should not trigger lint\n+\n+    // Deref<Target=str>\n+    let s = DerefStr(\" A B C \");\n+    let _ = s.trim().split_whitespace(); // should trigger lint\n+\n+    // Deref<Target=str> + custom impl\n+    let s = DerefStrAndCustom(\" A B C \");\n+    let _ = s.trim().split_whitespace(); // should not trigger lint\n+\n+    // Deref<Target=str> + only custom split_ws() impl\n+    let s = DerefStrAndCustomSplit(\" A B C \");\n+    let _ = s.trim().split_whitespace(); // should trigger lint\n+    // Expl: trim() is called on str (deref) and returns &str.\n+    //       Thus split_ws() is called on str as well and the custom impl on S is unused\n+\n+    // Deref<Target=str> + only custom trim() impl\n+    let s = DerefStrAndCustomTrim(\" A B C \");\n+    let _ = s.trim().split_whitespace(); // should not trigger lint\n+}"}, {"sha": "5ae7849e27d2ba6f6df63978ef93730140ba7f79", "filename": "tests/ui/trim_split_whitespace.stderr", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Ftrim_split_whitespace.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Ftrim_split_whitespace.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftrim_split_whitespace.stderr?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -0,0 +1,52 @@\n+error: found call to `str::trim` before `str::split_whitespace`\n+  --> $DIR/trim_split_whitespace.rs:62:23\n+   |\n+LL |     let _ = \" A B C \".trim().split_whitespace(); // should trigger lint\n+   |                       ^^^^^^^ help: remove `trim()`\n+   |\n+   = note: `-D clippy::trim-split-whitespace` implied by `-D warnings`\n+\n+error: found call to `str::trim_start` before `str::split_whitespace`\n+  --> $DIR/trim_split_whitespace.rs:63:23\n+   |\n+LL |     let _ = \" A B C \".trim_start().split_whitespace(); // should trigger lint\n+   |                       ^^^^^^^^^^^^^ help: remove `trim_start()`\n+\n+error: found call to `str::trim_end` before `str::split_whitespace`\n+  --> $DIR/trim_split_whitespace.rs:64:23\n+   |\n+LL |     let _ = \" A B C \".trim_end().split_whitespace(); // should trigger lint\n+   |                       ^^^^^^^^^^^ help: remove `trim_end()`\n+\n+error: found call to `str::trim` before `str::split_whitespace`\n+  --> $DIR/trim_split_whitespace.rs:67:37\n+   |\n+LL |     let _ = (\" A B C \").to_string().trim().split_whitespace(); // should trigger lint\n+   |                                     ^^^^^^^ help: remove `trim()`\n+\n+error: found call to `str::trim_start` before `str::split_whitespace`\n+  --> $DIR/trim_split_whitespace.rs:68:37\n+   |\n+LL |     let _ = (\" A B C \").to_string().trim_start().split_whitespace(); // should trigger lint\n+   |                                     ^^^^^^^^^^^^^ help: remove `trim_start()`\n+\n+error: found call to `str::trim_end` before `str::split_whitespace`\n+  --> $DIR/trim_split_whitespace.rs:69:37\n+   |\n+LL |     let _ = (\" A B C \").to_string().trim_end().split_whitespace(); // should trigger lint\n+   |                                     ^^^^^^^^^^^ help: remove `trim_end()`\n+\n+error: found call to `str::trim` before `str::split_whitespace`\n+  --> $DIR/trim_split_whitespace.rs:76:15\n+   |\n+LL |     let _ = s.trim().split_whitespace(); // should trigger lint\n+   |               ^^^^^^^ help: remove `trim()`\n+\n+error: found call to `str::trim` before `str::split_whitespace`\n+  --> $DIR/trim_split_whitespace.rs:84:15\n+   |\n+LL |     let _ = s.trim().split_whitespace(); // should trigger lint\n+   |               ^^^^^^^ help: remove `trim()`\n+\n+error: aborting due to 8 previous errors\n+"}, {"sha": "d11432f9046111d4ff77f7279250bc7f10083975", "filename": "tests/ui/type_repetition_in_bounds.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Ftype_repetition_in_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Ftype_repetition_in_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype_repetition_in_bounds.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -79,4 +79,7 @@ where\n     u: U,\n }\n \n+// This should not lint\n+fn impl_trait(_: impl AsRef<str>, _: impl AsRef<str>) {}\n+\n fn main() {}"}, {"sha": "abc25e59496bfa13262c3a5b938ce282a7b25edb", "filename": "tests/ui/type_repetition_in_bounds.stderr", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Ftype_repetition_in_bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Ftype_repetition_in_bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype_repetition_in_bounds.stderr?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -19,5 +19,13 @@ LL |     Self: Copy + Default + Ord,\n    |\n    = help: consider combining the bounds: `Self: Clone + Copy + Default + Ord`\n \n-error: aborting due to 2 previous errors\n+error: this type has already been used as a bound predicate\n+  --> $DIR/type_repetition_in_bounds.rs:83:43\n+   |\n+LL | fn impl_trait(_: impl AsRef<str>, _: impl AsRef<str>) {}\n+   |                                           ^^^^^^^^^^\n+   |\n+   = help: consider combining the bounds: `impl AsRef<str>: AsRef<str> + AsRef<str>`\n+\n+error: aborting due to 3 previous errors\n "}, {"sha": "7be15b0b2dd3d4669f7202a15d18bd1b9a2d7c20", "filename": "tests/ui/undocumented_unsafe_blocks.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fundocumented_unsafe_blocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fundocumented_unsafe_blocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fundocumented_unsafe_blocks.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -1,6 +1,7 @@\n // aux-build:proc_macro_unsafe.rs\n \n #![warn(clippy::undocumented_unsafe_blocks)]\n+#![allow(clippy::let_unit_value)]\n \n extern crate proc_macro_unsafe;\n "}, {"sha": "87d445bd7b86b12e39844c8718076717ff517aaf", "filename": "tests/ui/undocumented_unsafe_blocks.stderr", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fundocumented_unsafe_blocks.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fundocumented_unsafe_blocks.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fundocumented_unsafe_blocks.stderr?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -1,5 +1,5 @@\n error: unsafe block missing a safety comment\n-  --> $DIR/undocumented_unsafe_blocks.rs:256:19\n+  --> $DIR/undocumented_unsafe_blocks.rs:257:19\n    |\n LL |     /* Safety: */ unsafe {}\n    |                   ^^^^^^^^^\n@@ -8,103 +8,103 @@ LL |     /* Safety: */ unsafe {}\n    = help: consider adding a safety comment on the preceding line\n \n error: unsafe block missing a safety comment\n-  --> $DIR/undocumented_unsafe_blocks.rs:260:5\n+  --> $DIR/undocumented_unsafe_blocks.rs:261:5\n    |\n LL |     unsafe {}\n    |     ^^^^^^^^^\n    |\n    = help: consider adding a safety comment on the preceding line\n \n error: unsafe block missing a safety comment\n-  --> $DIR/undocumented_unsafe_blocks.rs:264:14\n+  --> $DIR/undocumented_unsafe_blocks.rs:265:14\n    |\n LL |     let _ = [unsafe { 14 }, unsafe { 15 }, 42, unsafe { 16 }];\n    |              ^^^^^^^^^^^^^\n    |\n    = help: consider adding a safety comment on the preceding line\n \n error: unsafe block missing a safety comment\n-  --> $DIR/undocumented_unsafe_blocks.rs:264:29\n+  --> $DIR/undocumented_unsafe_blocks.rs:265:29\n    |\n LL |     let _ = [unsafe { 14 }, unsafe { 15 }, 42, unsafe { 16 }];\n    |                             ^^^^^^^^^^^^^\n    |\n    = help: consider adding a safety comment on the preceding line\n \n error: unsafe block missing a safety comment\n-  --> $DIR/undocumented_unsafe_blocks.rs:264:48\n+  --> $DIR/undocumented_unsafe_blocks.rs:265:48\n    |\n LL |     let _ = [unsafe { 14 }, unsafe { 15 }, 42, unsafe { 16 }];\n    |                                                ^^^^^^^^^^^^^\n    |\n    = help: consider adding a safety comment on the preceding line\n \n error: unsafe block missing a safety comment\n-  --> $DIR/undocumented_unsafe_blocks.rs:268:18\n+  --> $DIR/undocumented_unsafe_blocks.rs:269:18\n    |\n LL |     let _ = (42, unsafe {}, \"test\", unsafe {});\n    |                  ^^^^^^^^^\n    |\n    = help: consider adding a safety comment on the preceding line\n \n error: unsafe block missing a safety comment\n-  --> $DIR/undocumented_unsafe_blocks.rs:268:37\n+  --> $DIR/undocumented_unsafe_blocks.rs:269:37\n    |\n LL |     let _ = (42, unsafe {}, \"test\", unsafe {});\n    |                                     ^^^^^^^^^\n    |\n    = help: consider adding a safety comment on the preceding line\n \n error: unsafe block missing a safety comment\n-  --> $DIR/undocumented_unsafe_blocks.rs:272:14\n+  --> $DIR/undocumented_unsafe_blocks.rs:273:14\n    |\n LL |     let _ = *unsafe { &42 };\n    |              ^^^^^^^^^^^^^^\n    |\n    = help: consider adding a safety comment on the preceding line\n \n error: unsafe block missing a safety comment\n-  --> $DIR/undocumented_unsafe_blocks.rs:277:19\n+  --> $DIR/undocumented_unsafe_blocks.rs:278:19\n    |\n LL |     let _ = match unsafe {} {\n    |                   ^^^^^^^^^\n    |\n    = help: consider adding a safety comment on the preceding line\n \n error: unsafe block missing a safety comment\n-  --> $DIR/undocumented_unsafe_blocks.rs:283:14\n+  --> $DIR/undocumented_unsafe_blocks.rs:284:14\n    |\n LL |     let _ = &unsafe {};\n    |              ^^^^^^^^^\n    |\n    = help: consider adding a safety comment on the preceding line\n \n error: unsafe block missing a safety comment\n-  --> $DIR/undocumented_unsafe_blocks.rs:287:14\n+  --> $DIR/undocumented_unsafe_blocks.rs:288:14\n    |\n LL |     let _ = [unsafe {}; 5];\n    |              ^^^^^^^^^\n    |\n    = help: consider adding a safety comment on the preceding line\n \n error: unsafe block missing a safety comment\n-  --> $DIR/undocumented_unsafe_blocks.rs:291:13\n+  --> $DIR/undocumented_unsafe_blocks.rs:292:13\n    |\n LL |     let _ = unsafe {};\n    |             ^^^^^^^^^\n    |\n    = help: consider adding a safety comment on the preceding line\n \n error: unsafe block missing a safety comment\n-  --> $DIR/undocumented_unsafe_blocks.rs:301:8\n+  --> $DIR/undocumented_unsafe_blocks.rs:302:8\n    |\n LL |     t!(unsafe {});\n    |        ^^^^^^^^^\n    |\n    = help: consider adding a safety comment on the preceding line\n \n error: unsafe block missing a safety comment\n-  --> $DIR/undocumented_unsafe_blocks.rs:307:13\n+  --> $DIR/undocumented_unsafe_blocks.rs:308:13\n    |\n LL |             unsafe {}\n    |             ^^^^^^^^^\n@@ -116,31 +116,31 @@ LL |     t!();\n    = note: this error originates in the macro `t` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: unsafe block missing a safety comment\n-  --> $DIR/undocumented_unsafe_blocks.rs:315:5\n+  --> $DIR/undocumented_unsafe_blocks.rs:316:5\n    |\n LL |     unsafe {} // SAFETY:\n    |     ^^^^^^^^^\n    |\n    = help: consider adding a safety comment on the preceding line\n \n error: unsafe block missing a safety comment\n-  --> $DIR/undocumented_unsafe_blocks.rs:319:5\n+  --> $DIR/undocumented_unsafe_blocks.rs:320:5\n    |\n LL |     unsafe {\n    |     ^^^^^^^^\n    |\n    = help: consider adding a safety comment on the preceding line\n \n error: unsafe block missing a safety comment\n-  --> $DIR/undocumented_unsafe_blocks.rs:329:5\n+  --> $DIR/undocumented_unsafe_blocks.rs:330:5\n    |\n LL |     unsafe {};\n    |     ^^^^^^^^^\n    |\n    = help: consider adding a safety comment on the preceding line\n \n error: unsafe block missing a safety comment\n-  --> $DIR/undocumented_unsafe_blocks.rs:333:20\n+  --> $DIR/undocumented_unsafe_blocks.rs:334:20\n    |\n LL |     println!(\"{}\", unsafe { String::from_utf8_unchecked(vec![]) });\n    |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"}, {"sha": "dac5ce272c02665133022468802bbfe679768d0d", "filename": "tests/ui/uninit.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Funinit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Funinit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funinit.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -1,4 +1,5 @@\n #![feature(stmt_expr_attributes)]\n+#![allow(clippy::let_unit_value)]\n \n use std::mem::{self, MaybeUninit};\n "}, {"sha": "15ef2349489fa711a5ed4a68557a2a8d3b8b3dfd", "filename": "tests/ui/uninit.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Funinit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Funinit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funinit.stderr?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -1,19 +1,19 @@\n error: this call for this type may be undefined behavior\n-  --> $DIR/uninit.rs:6:29\n+  --> $DIR/uninit.rs:7:29\n    |\n LL |     let _: usize = unsafe { MaybeUninit::uninit().assume_init() };\n    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: `#[deny(clippy::uninit_assumed_init)]` on by default\n \n error: this call for this type may be undefined behavior\n-  --> $DIR/uninit.rs:9:31\n+  --> $DIR/uninit.rs:10:31\n    |\n LL |     let _: [u8; 0] = unsafe { MaybeUninit::uninit().assume_init() };\n    |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: this call for this type may be undefined behavior\n-  --> $DIR/uninit.rs:24:29\n+  --> $DIR/uninit.rs:25:29\n    |\n LL |     let _: usize = unsafe { mem::MaybeUninit::uninit().assume_init() };\n    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"}, {"sha": "38be87bddf19845de6797e70384317bdbfb91162", "filename": "tests/ui/unit_arg.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Funit_arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Funit_arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funit_arg.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -7,7 +7,8 @@\n     clippy::unnecessary_wraps,\n     clippy::or_fun_call,\n     clippy::needless_question_mark,\n-    clippy::self_named_constructors\n+    clippy::self_named_constructors,\n+    clippy::let_unit_value\n )]\n \n use std::fmt::Debug;"}, {"sha": "394dee29dc96e5c802826bb52830063e25024ae6", "filename": "tests/ui/unit_arg.stderr", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Funit_arg.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Funit_arg.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funit_arg.stderr?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -1,5 +1,5 @@\n error: passing a unit value to a function\n-  --> $DIR/unit_arg.rs:56:5\n+  --> $DIR/unit_arg.rs:57:5\n    |\n LL | /     foo({\n LL | |         1;\n@@ -20,7 +20,7 @@ LL ~     foo(());\n    |\n \n error: passing a unit value to a function\n-  --> $DIR/unit_arg.rs:59:5\n+  --> $DIR/unit_arg.rs:60:5\n    |\n LL |     foo(foo(1));\n    |     ^^^^^^^^^^^\n@@ -32,7 +32,7 @@ LL ~     foo(());\n    |\n \n error: passing a unit value to a function\n-  --> $DIR/unit_arg.rs:60:5\n+  --> $DIR/unit_arg.rs:61:5\n    |\n LL | /     foo({\n LL | |         foo(1);\n@@ -54,7 +54,7 @@ LL ~     foo(());\n    |\n \n error: passing a unit value to a function\n-  --> $DIR/unit_arg.rs:65:5\n+  --> $DIR/unit_arg.rs:66:5\n    |\n LL | /     b.bar({\n LL | |         1;\n@@ -74,7 +74,7 @@ LL ~     b.bar(());\n    |\n \n error: passing unit values to a function\n-  --> $DIR/unit_arg.rs:68:5\n+  --> $DIR/unit_arg.rs:69:5\n    |\n LL |     taking_multiple_units(foo(0), foo(1));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -87,7 +87,7 @@ LL ~     taking_multiple_units((), ());\n    |\n \n error: passing unit values to a function\n-  --> $DIR/unit_arg.rs:69:5\n+  --> $DIR/unit_arg.rs:70:5\n    |\n LL | /     taking_multiple_units(foo(0), {\n LL | |         foo(1);\n@@ -110,7 +110,7 @@ LL ~     taking_multiple_units((), ());\n    |\n \n error: passing unit values to a function\n-  --> $DIR/unit_arg.rs:73:5\n+  --> $DIR/unit_arg.rs:74:5\n    |\n LL | /     taking_multiple_units(\n LL | |         {\n@@ -140,7 +140,7 @@ LL +         foo(2);\n  ...\n \n error: passing a unit value to a function\n-  --> $DIR/unit_arg.rs:84:13\n+  --> $DIR/unit_arg.rs:85:13\n    |\n LL |     None.or(Some(foo(2)));\n    |             ^^^^^^^^^^^^\n@@ -154,7 +154,7 @@ LL ~     });\n    |\n \n error: passing a unit value to a function\n-  --> $DIR/unit_arg.rs:87:5\n+  --> $DIR/unit_arg.rs:88:5\n    |\n LL |     foo(foo(()));\n    |     ^^^^^^^^^^^^\n@@ -166,7 +166,7 @@ LL ~     foo(());\n    |\n \n error: passing a unit value to a function\n-  --> $DIR/unit_arg.rs:124:5\n+  --> $DIR/unit_arg.rs:125:5\n    |\n LL |     Some(foo(1))\n    |     ^^^^^^^^^^^^"}, {"sha": "43eb54eff477b72518c92b93e5b9448830aea6f0", "filename": "tests/ui/unit_hash.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Funit_hash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Funit_hash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funit_hash.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -1,4 +1,5 @@\n #![warn(clippy::unit_hash)]\n+#![allow(clippy::let_unit_value)]\n \n use std::collections::hash_map::DefaultHasher;\n use std::hash::Hash;"}, {"sha": "050fa55a12bea71bab7f4c44f11b81724d1400cf", "filename": "tests/ui/unit_hash.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Funit_hash.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Funit_hash.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funit_hash.stderr?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -1,5 +1,5 @@\n error: this call to `hash` on the unit type will do nothing\n-  --> $DIR/unit_hash.rs:18:23\n+  --> $DIR/unit_hash.rs:19:23\n    |\n LL |         Foo::Empty => ().hash(&mut state),\n    |                       ^^^^^^^^^^^^^^^^^^^ help: remove the call to `hash` or consider using: `0_u8.hash(&mut state)`\n@@ -8,15 +8,15 @@ LL |         Foo::Empty => ().hash(&mut state),\n    = note: the implementation of `Hash` for `()` is a no-op\n \n error: this call to `hash` on the unit type will do nothing\n-  --> $DIR/unit_hash.rs:23:5\n+  --> $DIR/unit_hash.rs:24:5\n    |\n LL |     res.hash(&mut state);\n    |     ^^^^^^^^^^^^^^^^^^^^ help: remove the call to `hash` or consider using: `0_u8.hash(&mut state)`\n    |\n    = note: the implementation of `Hash` for `()` is a no-op\n \n error: this call to `hash` on the unit type will do nothing\n-  --> $DIR/unit_hash.rs:26:5\n+  --> $DIR/unit_hash.rs:27:5\n    |\n LL |     do_nothing().hash(&mut state);\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: remove the call to `hash` or consider using: `0_u8.hash(&mut state)`"}, {"sha": "f95f91329a2faeeae22da74496d42568e89512c8", "filename": "tests/ui/unnecessary_owned_empty_strings.fixed", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Funnecessary_owned_empty_strings.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Funnecessary_owned_empty_strings.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funnecessary_owned_empty_strings.fixed?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -0,0 +1,22 @@\n+// run-rustfix\n+\n+#![warn(clippy::unnecessary_owned_empty_strings)]\n+\n+fn ref_str_argument(_value: &str) {}\n+\n+#[allow(clippy::ptr_arg)]\n+fn ref_string_argument(_value: &String) {}\n+\n+fn main() {\n+    // should be linted\n+    ref_str_argument(\"\");\n+\n+    // should be linted\n+    ref_str_argument(\"\");\n+\n+    // should not be linted\n+    ref_str_argument(\"\");\n+\n+    // should not be linted\n+    ref_string_argument(&String::new());\n+}"}, {"sha": "0cbdc151ed9b1b0b3a2056ed6e4e78665f175ee0", "filename": "tests/ui/unnecessary_owned_empty_strings.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Funnecessary_owned_empty_strings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Funnecessary_owned_empty_strings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funnecessary_owned_empty_strings.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -0,0 +1,22 @@\n+// run-rustfix\n+\n+#![warn(clippy::unnecessary_owned_empty_strings)]\n+\n+fn ref_str_argument(_value: &str) {}\n+\n+#[allow(clippy::ptr_arg)]\n+fn ref_string_argument(_value: &String) {}\n+\n+fn main() {\n+    // should be linted\n+    ref_str_argument(&String::new());\n+\n+    // should be linted\n+    ref_str_argument(&String::from(\"\"));\n+\n+    // should not be linted\n+    ref_str_argument(\"\");\n+\n+    // should not be linted\n+    ref_string_argument(&String::new());\n+}"}, {"sha": "46bc4597b335f0bfb7be4ce8053f46b3735e95b4", "filename": "tests/ui/unnecessary_owned_empty_strings.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Funnecessary_owned_empty_strings.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Funnecessary_owned_empty_strings.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funnecessary_owned_empty_strings.stderr?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -0,0 +1,16 @@\n+error: usage of `&String::new()` for a function expecting a `&str` argument\n+  --> $DIR/unnecessary_owned_empty_strings.rs:12:22\n+   |\n+LL |     ref_str_argument(&String::new());\n+   |                      ^^^^^^^^^^^^^^ help: try: `\"\"`\n+   |\n+   = note: `-D clippy::unnecessary-owned-empty-strings` implied by `-D warnings`\n+\n+error: usage of `&String::from(\"\")` for a function expecting a `&str` argument\n+  --> $DIR/unnecessary_owned_empty_strings.rs:15:22\n+   |\n+LL |     ref_str_argument(&String::from(\"\"));\n+   |                      ^^^^^^^^^^^^^^^^^ help: try: `\"\"`\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "7455e22d49b21f8df93bea25f1095f5beac55983", "filename": "tests/ui/unnecessary_to_owned.fixed", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Funnecessary_to_owned.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Funnecessary_to_owned.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funnecessary_to_owned.fixed?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -2,6 +2,7 @@\n \n #![allow(clippy::ptr_arg)]\n #![warn(clippy::unnecessary_to_owned)]\n+#![feature(custom_inner_attributes)]\n \n use std::borrow::Cow;\n use std::ffi::{CStr, CString, OsStr, OsString};\n@@ -213,6 +214,17 @@ fn get_file_path(_file_type: &FileType) -> Result<std::path::PathBuf, std::io::E\n \n fn require_string(_: &String) {}\n \n+fn _msrv_1_35() {\n+    #![clippy::msrv = \"1.35\"]\n+    // `copied` was stabilized in 1.36, so clippy should use `cloned`.\n+    let _ = &[\"x\"][..].iter().cloned();\n+}\n+\n+fn _msrv_1_36() {\n+    #![clippy::msrv = \"1.36\"]\n+    let _ = &[\"x\"][..].iter().copied();\n+}\n+\n // https://github.com/rust-lang/rust-clippy/issues/8507\n mod issue_8507 {\n     #![allow(dead_code)]"}, {"sha": "bbcd00ad2204a9a789cee2e457b6d89357aaa223", "filename": "tests/ui/unnecessary_to_owned.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Funnecessary_to_owned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Funnecessary_to_owned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funnecessary_to_owned.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -2,6 +2,7 @@\n \n #![allow(clippy::ptr_arg)]\n #![warn(clippy::unnecessary_to_owned)]\n+#![feature(custom_inner_attributes)]\n \n use std::borrow::Cow;\n use std::ffi::{CStr, CString, OsStr, OsString};\n@@ -213,6 +214,17 @@ fn get_file_path(_file_type: &FileType) -> Result<std::path::PathBuf, std::io::E\n \n fn require_string(_: &String) {}\n \n+fn _msrv_1_35() {\n+    #![clippy::msrv = \"1.35\"]\n+    // `copied` was stabilized in 1.36, so clippy should use `cloned`.\n+    let _ = &[\"x\"][..].to_vec().into_iter();\n+}\n+\n+fn _msrv_1_36() {\n+    #![clippy::msrv = \"1.36\"]\n+    let _ = &[\"x\"][..].to_vec().into_iter();\n+}\n+\n // https://github.com/rust-lang/rust-clippy/issues/8507\n mod issue_8507 {\n     #![allow(dead_code)]"}, {"sha": "f9713559e4f7fce4ac6b3d6096ae1e25ee83ee52", "filename": "tests/ui/unnecessary_to_owned.stderr", "status": "modified", "additions": 94, "deletions": 82, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Funnecessary_to_owned.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Funnecessary_to_owned.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funnecessary_to_owned.stderr?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -1,482 +1,482 @@\n error: redundant clone\n-  --> $DIR/unnecessary_to_owned.rs:150:64\n+  --> $DIR/unnecessary_to_owned.rs:151:64\n    |\n LL |     require_c_str(&CString::from_vec_with_nul(vec![0]).unwrap().to_owned());\n    |                                                                ^^^^^^^^^^^ help: remove this\n    |\n    = note: `-D clippy::redundant-clone` implied by `-D warnings`\n note: this value is dropped without further use\n-  --> $DIR/unnecessary_to_owned.rs:150:20\n+  --> $DIR/unnecessary_to_owned.rs:151:20\n    |\n LL |     require_c_str(&CString::from_vec_with_nul(vec![0]).unwrap().to_owned());\n    |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: redundant clone\n-  --> $DIR/unnecessary_to_owned.rs:151:40\n+  --> $DIR/unnecessary_to_owned.rs:152:40\n    |\n LL |     require_os_str(&OsString::from(\"x\").to_os_string());\n    |                                        ^^^^^^^^^^^^^^^ help: remove this\n    |\n note: this value is dropped without further use\n-  --> $DIR/unnecessary_to_owned.rs:151:21\n+  --> $DIR/unnecessary_to_owned.rs:152:21\n    |\n LL |     require_os_str(&OsString::from(\"x\").to_os_string());\n    |                     ^^^^^^^^^^^^^^^^^^^\n \n error: redundant clone\n-  --> $DIR/unnecessary_to_owned.rs:152:48\n+  --> $DIR/unnecessary_to_owned.rs:153:48\n    |\n LL |     require_path(&std::path::PathBuf::from(\"x\").to_path_buf());\n    |                                                ^^^^^^^^^^^^^^ help: remove this\n    |\n note: this value is dropped without further use\n-  --> $DIR/unnecessary_to_owned.rs:152:19\n+  --> $DIR/unnecessary_to_owned.rs:153:19\n    |\n LL |     require_path(&std::path::PathBuf::from(\"x\").to_path_buf());\n    |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: redundant clone\n-  --> $DIR/unnecessary_to_owned.rs:153:35\n+  --> $DIR/unnecessary_to_owned.rs:154:35\n    |\n LL |     require_str(&String::from(\"x\").to_string());\n    |                                   ^^^^^^^^^^^^ help: remove this\n    |\n note: this value is dropped without further use\n-  --> $DIR/unnecessary_to_owned.rs:153:18\n+  --> $DIR/unnecessary_to_owned.rs:154:18\n    |\n LL |     require_str(&String::from(\"x\").to_string());\n    |                  ^^^^^^^^^^^^^^^^^\n \n error: unnecessary use of `into_owned`\n-  --> $DIR/unnecessary_to_owned.rs:59:36\n+  --> $DIR/unnecessary_to_owned.rs:60:36\n    |\n LL |     require_c_str(&Cow::from(c_str).into_owned());\n    |                                    ^^^^^^^^^^^^^ help: remove this\n    |\n    = note: `-D clippy::unnecessary-to-owned` implied by `-D warnings`\n \n error: unnecessary use of `to_owned`\n-  --> $DIR/unnecessary_to_owned.rs:60:19\n+  --> $DIR/unnecessary_to_owned.rs:61:19\n    |\n LL |     require_c_str(&c_str.to_owned());\n    |                   ^^^^^^^^^^^^^^^^^ help: use: `c_str`\n \n error: unnecessary use of `to_os_string`\n-  --> $DIR/unnecessary_to_owned.rs:62:20\n+  --> $DIR/unnecessary_to_owned.rs:63:20\n    |\n LL |     require_os_str(&os_str.to_os_string());\n    |                    ^^^^^^^^^^^^^^^^^^^^^^ help: use: `os_str`\n \n error: unnecessary use of `into_owned`\n-  --> $DIR/unnecessary_to_owned.rs:63:38\n+  --> $DIR/unnecessary_to_owned.rs:64:38\n    |\n LL |     require_os_str(&Cow::from(os_str).into_owned());\n    |                                      ^^^^^^^^^^^^^ help: remove this\n \n error: unnecessary use of `to_owned`\n-  --> $DIR/unnecessary_to_owned.rs:64:20\n+  --> $DIR/unnecessary_to_owned.rs:65:20\n    |\n LL |     require_os_str(&os_str.to_owned());\n    |                    ^^^^^^^^^^^^^^^^^^ help: use: `os_str`\n \n error: unnecessary use of `to_path_buf`\n-  --> $DIR/unnecessary_to_owned.rs:66:18\n+  --> $DIR/unnecessary_to_owned.rs:67:18\n    |\n LL |     require_path(&path.to_path_buf());\n    |                  ^^^^^^^^^^^^^^^^^^^ help: use: `path`\n \n error: unnecessary use of `into_owned`\n-  --> $DIR/unnecessary_to_owned.rs:67:34\n+  --> $DIR/unnecessary_to_owned.rs:68:34\n    |\n LL |     require_path(&Cow::from(path).into_owned());\n    |                                  ^^^^^^^^^^^^^ help: remove this\n \n error: unnecessary use of `to_owned`\n-  --> $DIR/unnecessary_to_owned.rs:68:18\n+  --> $DIR/unnecessary_to_owned.rs:69:18\n    |\n LL |     require_path(&path.to_owned());\n    |                  ^^^^^^^^^^^^^^^^ help: use: `path`\n \n error: unnecessary use of `to_string`\n-  --> $DIR/unnecessary_to_owned.rs:70:17\n+  --> $DIR/unnecessary_to_owned.rs:71:17\n    |\n LL |     require_str(&s.to_string());\n    |                 ^^^^^^^^^^^^^^ help: use: `s`\n \n error: unnecessary use of `into_owned`\n-  --> $DIR/unnecessary_to_owned.rs:71:30\n+  --> $DIR/unnecessary_to_owned.rs:72:30\n    |\n LL |     require_str(&Cow::from(s).into_owned());\n    |                              ^^^^^^^^^^^^^ help: remove this\n \n error: unnecessary use of `to_owned`\n-  --> $DIR/unnecessary_to_owned.rs:72:17\n+  --> $DIR/unnecessary_to_owned.rs:73:17\n    |\n LL |     require_str(&s.to_owned());\n    |                 ^^^^^^^^^^^^^ help: use: `s`\n \n error: unnecessary use of `to_string`\n-  --> $DIR/unnecessary_to_owned.rs:73:17\n+  --> $DIR/unnecessary_to_owned.rs:74:17\n    |\n LL |     require_str(&x_ref.to_string());\n    |                 ^^^^^^^^^^^^^^^^^^ help: use: `x_ref.as_ref()`\n \n error: unnecessary use of `to_vec`\n-  --> $DIR/unnecessary_to_owned.rs:75:19\n+  --> $DIR/unnecessary_to_owned.rs:76:19\n    |\n LL |     require_slice(&slice.to_vec());\n    |                   ^^^^^^^^^^^^^^^ help: use: `slice`\n \n error: unnecessary use of `into_owned`\n-  --> $DIR/unnecessary_to_owned.rs:76:36\n+  --> $DIR/unnecessary_to_owned.rs:77:36\n    |\n LL |     require_slice(&Cow::from(slice).into_owned());\n    |                                    ^^^^^^^^^^^^^ help: remove this\n \n error: unnecessary use of `to_owned`\n-  --> $DIR/unnecessary_to_owned.rs:77:19\n+  --> $DIR/unnecessary_to_owned.rs:78:19\n    |\n LL |     require_slice(&array.to_owned());\n    |                   ^^^^^^^^^^^^^^^^^ help: use: `array.as_ref()`\n \n error: unnecessary use of `to_owned`\n-  --> $DIR/unnecessary_to_owned.rs:78:19\n+  --> $DIR/unnecessary_to_owned.rs:79:19\n    |\n LL |     require_slice(&array_ref.to_owned());\n    |                   ^^^^^^^^^^^^^^^^^^^^^ help: use: `array_ref.as_ref()`\n \n error: unnecessary use of `to_owned`\n-  --> $DIR/unnecessary_to_owned.rs:79:19\n+  --> $DIR/unnecessary_to_owned.rs:80:19\n    |\n LL |     require_slice(&slice.to_owned());\n    |                   ^^^^^^^^^^^^^^^^^ help: use: `slice`\n \n error: unnecessary use of `to_owned`\n-  --> $DIR/unnecessary_to_owned.rs:80:19\n+  --> $DIR/unnecessary_to_owned.rs:81:19\n    |\n LL |     require_slice(&x_ref.to_owned());\n    |                   ^^^^^^^^^^^^^^^^^ help: use: `x_ref`\n \n error: unnecessary use of `into_owned`\n-  --> $DIR/unnecessary_to_owned.rs:82:42\n+  --> $DIR/unnecessary_to_owned.rs:83:42\n    |\n LL |     require_x(&Cow::<X>::Owned(x.clone()).into_owned());\n    |                                          ^^^^^^^^^^^^^ help: remove this\n \n error: unnecessary use of `to_owned`\n-  --> $DIR/unnecessary_to_owned.rs:83:15\n+  --> $DIR/unnecessary_to_owned.rs:84:15\n    |\n LL |     require_x(&x_ref.to_owned());\n    |               ^^^^^^^^^^^^^^^^^ help: use: `x_ref`\n \n error: unnecessary use of `to_owned`\n-  --> $DIR/unnecessary_to_owned.rs:85:25\n+  --> $DIR/unnecessary_to_owned.rs:86:25\n    |\n LL |     require_deref_c_str(c_str.to_owned());\n    |                         ^^^^^^^^^^^^^^^^ help: use: `c_str`\n \n error: unnecessary use of `to_owned`\n-  --> $DIR/unnecessary_to_owned.rs:86:26\n+  --> $DIR/unnecessary_to_owned.rs:87:26\n    |\n LL |     require_deref_os_str(os_str.to_owned());\n    |                          ^^^^^^^^^^^^^^^^^ help: use: `os_str`\n \n error: unnecessary use of `to_owned`\n-  --> $DIR/unnecessary_to_owned.rs:87:24\n+  --> $DIR/unnecessary_to_owned.rs:88:24\n    |\n LL |     require_deref_path(path.to_owned());\n    |                        ^^^^^^^^^^^^^^^ help: use: `path`\n \n error: unnecessary use of `to_owned`\n-  --> $DIR/unnecessary_to_owned.rs:88:23\n+  --> $DIR/unnecessary_to_owned.rs:89:23\n    |\n LL |     require_deref_str(s.to_owned());\n    |                       ^^^^^^^^^^^^ help: use: `s`\n \n error: unnecessary use of `to_owned`\n-  --> $DIR/unnecessary_to_owned.rs:89:25\n+  --> $DIR/unnecessary_to_owned.rs:90:25\n    |\n LL |     require_deref_slice(slice.to_owned());\n    |                         ^^^^^^^^^^^^^^^^ help: use: `slice`\n \n error: unnecessary use of `to_owned`\n-  --> $DIR/unnecessary_to_owned.rs:91:30\n+  --> $DIR/unnecessary_to_owned.rs:92:30\n    |\n LL |     require_impl_deref_c_str(c_str.to_owned());\n    |                              ^^^^^^^^^^^^^^^^ help: use: `c_str`\n \n error: unnecessary use of `to_owned`\n-  --> $DIR/unnecessary_to_owned.rs:92:31\n+  --> $DIR/unnecessary_to_owned.rs:93:31\n    |\n LL |     require_impl_deref_os_str(os_str.to_owned());\n    |                               ^^^^^^^^^^^^^^^^^ help: use: `os_str`\n \n error: unnecessary use of `to_owned`\n-  --> $DIR/unnecessary_to_owned.rs:93:29\n+  --> $DIR/unnecessary_to_owned.rs:94:29\n    |\n LL |     require_impl_deref_path(path.to_owned());\n    |                             ^^^^^^^^^^^^^^^ help: use: `path`\n \n error: unnecessary use of `to_owned`\n-  --> $DIR/unnecessary_to_owned.rs:94:28\n+  --> $DIR/unnecessary_to_owned.rs:95:28\n    |\n LL |     require_impl_deref_str(s.to_owned());\n    |                            ^^^^^^^^^^^^ help: use: `s`\n \n error: unnecessary use of `to_owned`\n-  --> $DIR/unnecessary_to_owned.rs:95:30\n+  --> $DIR/unnecessary_to_owned.rs:96:30\n    |\n LL |     require_impl_deref_slice(slice.to_owned());\n    |                              ^^^^^^^^^^^^^^^^ help: use: `slice`\n \n error: unnecessary use of `to_owned`\n-  --> $DIR/unnecessary_to_owned.rs:97:29\n+  --> $DIR/unnecessary_to_owned.rs:98:29\n    |\n LL |     require_deref_str_slice(s.to_owned(), slice.to_owned());\n    |                             ^^^^^^^^^^^^ help: use: `s`\n \n error: unnecessary use of `to_owned`\n-  --> $DIR/unnecessary_to_owned.rs:97:43\n+  --> $DIR/unnecessary_to_owned.rs:98:43\n    |\n LL |     require_deref_str_slice(s.to_owned(), slice.to_owned());\n    |                                           ^^^^^^^^^^^^^^^^ help: use: `slice`\n \n error: unnecessary use of `to_owned`\n-  --> $DIR/unnecessary_to_owned.rs:98:29\n+  --> $DIR/unnecessary_to_owned.rs:99:29\n    |\n LL |     require_deref_slice_str(slice.to_owned(), s.to_owned());\n    |                             ^^^^^^^^^^^^^^^^ help: use: `slice`\n \n error: unnecessary use of `to_owned`\n-  --> $DIR/unnecessary_to_owned.rs:98:47\n+  --> $DIR/unnecessary_to_owned.rs:99:47\n    |\n LL |     require_deref_slice_str(slice.to_owned(), s.to_owned());\n    |                                               ^^^^^^^^^^^^ help: use: `s`\n \n error: unnecessary use of `to_owned`\n-  --> $DIR/unnecessary_to_owned.rs:100:26\n+  --> $DIR/unnecessary_to_owned.rs:101:26\n    |\n LL |     require_as_ref_c_str(c_str.to_owned());\n    |                          ^^^^^^^^^^^^^^^^ help: use: `c_str`\n \n error: unnecessary use of `to_owned`\n-  --> $DIR/unnecessary_to_owned.rs:101:27\n+  --> $DIR/unnecessary_to_owned.rs:102:27\n    |\n LL |     require_as_ref_os_str(os_str.to_owned());\n    |                           ^^^^^^^^^^^^^^^^^ help: use: `os_str`\n \n error: unnecessary use of `to_owned`\n-  --> $DIR/unnecessary_to_owned.rs:102:25\n+  --> $DIR/unnecessary_to_owned.rs:103:25\n    |\n LL |     require_as_ref_path(path.to_owned());\n    |                         ^^^^^^^^^^^^^^^ help: use: `path`\n \n error: unnecessary use of `to_owned`\n-  --> $DIR/unnecessary_to_owned.rs:103:24\n+  --> $DIR/unnecessary_to_owned.rs:104:24\n    |\n LL |     require_as_ref_str(s.to_owned());\n    |                        ^^^^^^^^^^^^ help: use: `s`\n \n error: unnecessary use of `to_owned`\n-  --> $DIR/unnecessary_to_owned.rs:104:24\n+  --> $DIR/unnecessary_to_owned.rs:105:24\n    |\n LL |     require_as_ref_str(x.to_owned());\n    |                        ^^^^^^^^^^^^ help: use: `&x`\n \n error: unnecessary use of `to_owned`\n-  --> $DIR/unnecessary_to_owned.rs:105:26\n+  --> $DIR/unnecessary_to_owned.rs:106:26\n    |\n LL |     require_as_ref_slice(array.to_owned());\n    |                          ^^^^^^^^^^^^^^^^ help: use: `array`\n \n error: unnecessary use of `to_owned`\n-  --> $DIR/unnecessary_to_owned.rs:106:26\n+  --> $DIR/unnecessary_to_owned.rs:107:26\n    |\n LL |     require_as_ref_slice(array_ref.to_owned());\n    |                          ^^^^^^^^^^^^^^^^^^^^ help: use: `array_ref`\n \n error: unnecessary use of `to_owned`\n-  --> $DIR/unnecessary_to_owned.rs:107:26\n+  --> $DIR/unnecessary_to_owned.rs:108:26\n    |\n LL |     require_as_ref_slice(slice.to_owned());\n    |                          ^^^^^^^^^^^^^^^^ help: use: `slice`\n \n error: unnecessary use of `to_owned`\n-  --> $DIR/unnecessary_to_owned.rs:109:31\n+  --> $DIR/unnecessary_to_owned.rs:110:31\n    |\n LL |     require_impl_as_ref_c_str(c_str.to_owned());\n    |                               ^^^^^^^^^^^^^^^^ help: use: `c_str`\n \n error: unnecessary use of `to_owned`\n-  --> $DIR/unnecessary_to_owned.rs:110:32\n+  --> $DIR/unnecessary_to_owned.rs:111:32\n    |\n LL |     require_impl_as_ref_os_str(os_str.to_owned());\n    |                                ^^^^^^^^^^^^^^^^^ help: use: `os_str`\n \n error: unnecessary use of `to_owned`\n-  --> $DIR/unnecessary_to_owned.rs:111:30\n+  --> $DIR/unnecessary_to_owned.rs:112:30\n    |\n LL |     require_impl_as_ref_path(path.to_owned());\n    |                              ^^^^^^^^^^^^^^^ help: use: `path`\n \n error: unnecessary use of `to_owned`\n-  --> $DIR/unnecessary_to_owned.rs:112:29\n+  --> $DIR/unnecessary_to_owned.rs:113:29\n    |\n LL |     require_impl_as_ref_str(s.to_owned());\n    |                             ^^^^^^^^^^^^ help: use: `s`\n \n error: unnecessary use of `to_owned`\n-  --> $DIR/unnecessary_to_owned.rs:113:29\n+  --> $DIR/unnecessary_to_owned.rs:114:29\n    |\n LL |     require_impl_as_ref_str(x.to_owned());\n    |                             ^^^^^^^^^^^^ help: use: `&x`\n \n error: unnecessary use of `to_owned`\n-  --> $DIR/unnecessary_to_owned.rs:114:31\n+  --> $DIR/unnecessary_to_owned.rs:115:31\n    |\n LL |     require_impl_as_ref_slice(array.to_owned());\n    |                               ^^^^^^^^^^^^^^^^ help: use: `array`\n \n error: unnecessary use of `to_owned`\n-  --> $DIR/unnecessary_to_owned.rs:115:31\n+  --> $DIR/unnecessary_to_owned.rs:116:31\n    |\n LL |     require_impl_as_ref_slice(array_ref.to_owned());\n    |                               ^^^^^^^^^^^^^^^^^^^^ help: use: `array_ref`\n \n error: unnecessary use of `to_owned`\n-  --> $DIR/unnecessary_to_owned.rs:116:31\n+  --> $DIR/unnecessary_to_owned.rs:117:31\n    |\n LL |     require_impl_as_ref_slice(slice.to_owned());\n    |                               ^^^^^^^^^^^^^^^^ help: use: `slice`\n \n error: unnecessary use of `to_owned`\n-  --> $DIR/unnecessary_to_owned.rs:118:30\n+  --> $DIR/unnecessary_to_owned.rs:119:30\n    |\n LL |     require_as_ref_str_slice(s.to_owned(), array.to_owned());\n    |                              ^^^^^^^^^^^^ help: use: `s`\n \n error: unnecessary use of `to_owned`\n-  --> $DIR/unnecessary_to_owned.rs:118:44\n+  --> $DIR/unnecessary_to_owned.rs:119:44\n    |\n LL |     require_as_ref_str_slice(s.to_owned(), array.to_owned());\n    |                                            ^^^^^^^^^^^^^^^^ help: use: `array`\n \n error: unnecessary use of `to_owned`\n-  --> $DIR/unnecessary_to_owned.rs:119:30\n+  --> $DIR/unnecessary_to_owned.rs:120:30\n    |\n LL |     require_as_ref_str_slice(s.to_owned(), array_ref.to_owned());\n    |                              ^^^^^^^^^^^^ help: use: `s`\n \n error: unnecessary use of `to_owned`\n-  --> $DIR/unnecessary_to_owned.rs:119:44\n+  --> $DIR/unnecessary_to_owned.rs:120:44\n    |\n LL |     require_as_ref_str_slice(s.to_owned(), array_ref.to_owned());\n    |                                            ^^^^^^^^^^^^^^^^^^^^ help: use: `array_ref`\n \n error: unnecessary use of `to_owned`\n-  --> $DIR/unnecessary_to_owned.rs:120:30\n+  --> $DIR/unnecessary_to_owned.rs:121:30\n    |\n LL |     require_as_ref_str_slice(s.to_owned(), slice.to_owned());\n    |                              ^^^^^^^^^^^^ help: use: `s`\n \n error: unnecessary use of `to_owned`\n-  --> $DIR/unnecessary_to_owned.rs:120:44\n+  --> $DIR/unnecessary_to_owned.rs:121:44\n    |\n LL |     require_as_ref_str_slice(s.to_owned(), slice.to_owned());\n    |                                            ^^^^^^^^^^^^^^^^ help: use: `slice`\n \n error: unnecessary use of `to_owned`\n-  --> $DIR/unnecessary_to_owned.rs:121:30\n+  --> $DIR/unnecessary_to_owned.rs:122:30\n    |\n LL |     require_as_ref_slice_str(array.to_owned(), s.to_owned());\n    |                              ^^^^^^^^^^^^^^^^ help: use: `array`\n \n error: unnecessary use of `to_owned`\n-  --> $DIR/unnecessary_to_owned.rs:121:48\n+  --> $DIR/unnecessary_to_owned.rs:122:48\n    |\n LL |     require_as_ref_slice_str(array.to_owned(), s.to_owned());\n    |                                                ^^^^^^^^^^^^ help: use: `s`\n \n error: unnecessary use of `to_owned`\n-  --> $DIR/unnecessary_to_owned.rs:122:30\n+  --> $DIR/unnecessary_to_owned.rs:123:30\n    |\n LL |     require_as_ref_slice_str(array_ref.to_owned(), s.to_owned());\n    |                              ^^^^^^^^^^^^^^^^^^^^ help: use: `array_ref`\n \n error: unnecessary use of `to_owned`\n-  --> $DIR/unnecessary_to_owned.rs:122:52\n+  --> $DIR/unnecessary_to_owned.rs:123:52\n    |\n LL |     require_as_ref_slice_str(array_ref.to_owned(), s.to_owned());\n    |                                                    ^^^^^^^^^^^^ help: use: `s`\n \n error: unnecessary use of `to_owned`\n-  --> $DIR/unnecessary_to_owned.rs:123:30\n+  --> $DIR/unnecessary_to_owned.rs:124:30\n    |\n LL |     require_as_ref_slice_str(slice.to_owned(), s.to_owned());\n    |                              ^^^^^^^^^^^^^^^^ help: use: `slice`\n \n error: unnecessary use of `to_owned`\n-  --> $DIR/unnecessary_to_owned.rs:123:48\n+  --> $DIR/unnecessary_to_owned.rs:124:48\n    |\n LL |     require_as_ref_slice_str(slice.to_owned(), s.to_owned());\n    |                                                ^^^^^^^^^^^^ help: use: `s`\n \n error: unnecessary use of `to_string`\n-  --> $DIR/unnecessary_to_owned.rs:125:20\n+  --> $DIR/unnecessary_to_owned.rs:126:20\n    |\n LL |     let _ = x.join(&x_ref.to_string());\n    |                    ^^^^^^^^^^^^^^^^^^ help: use: `x_ref`\n \n error: unnecessary use of `to_vec`\n-  --> $DIR/unnecessary_to_owned.rs:127:13\n+  --> $DIR/unnecessary_to_owned.rs:128:13\n    |\n LL |     let _ = slice.to_vec().into_iter();\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use: `slice.iter().copied()`\n \n error: unnecessary use of `to_owned`\n-  --> $DIR/unnecessary_to_owned.rs:128:13\n+  --> $DIR/unnecessary_to_owned.rs:129:13\n    |\n LL |     let _ = slice.to_owned().into_iter();\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use: `slice.iter().copied()`\n \n error: unnecessary use of `to_vec`\n-  --> $DIR/unnecessary_to_owned.rs:129:13\n+  --> $DIR/unnecessary_to_owned.rs:130:13\n    |\n LL |     let _ = [std::path::PathBuf::new()][..].to_vec().into_iter();\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use: `[std::path::PathBuf::new()][..].iter().cloned()`\n \n error: unnecessary use of `to_owned`\n-  --> $DIR/unnecessary_to_owned.rs:130:13\n+  --> $DIR/unnecessary_to_owned.rs:131:13\n    |\n LL |     let _ = [std::path::PathBuf::new()][..].to_owned().into_iter();\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use: `[std::path::PathBuf::new()][..].iter().cloned()`\n \n error: unnecessary use of `to_vec`\n-  --> $DIR/unnecessary_to_owned.rs:132:13\n+  --> $DIR/unnecessary_to_owned.rs:133:13\n    |\n LL |     let _ = IntoIterator::into_iter(slice.to_vec());\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use: `slice.iter().copied()`\n \n error: unnecessary use of `to_owned`\n-  --> $DIR/unnecessary_to_owned.rs:133:13\n+  --> $DIR/unnecessary_to_owned.rs:134:13\n    |\n LL |     let _ = IntoIterator::into_iter(slice.to_owned());\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use: `slice.iter().copied()`\n \n error: unnecessary use of `to_vec`\n-  --> $DIR/unnecessary_to_owned.rs:134:13\n+  --> $DIR/unnecessary_to_owned.rs:135:13\n    |\n LL |     let _ = IntoIterator::into_iter([std::path::PathBuf::new()][..].to_vec());\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use: `[std::path::PathBuf::new()][..].iter().cloned()`\n \n error: unnecessary use of `to_owned`\n-  --> $DIR/unnecessary_to_owned.rs:135:13\n+  --> $DIR/unnecessary_to_owned.rs:136:13\n    |\n LL |     let _ = IntoIterator::into_iter([std::path::PathBuf::new()][..].to_owned());\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use: `[std::path::PathBuf::new()][..].iter().cloned()`\n \n error: unnecessary use of `to_vec`\n-  --> $DIR/unnecessary_to_owned.rs:196:14\n+  --> $DIR/unnecessary_to_owned.rs:197:14\n    |\n LL |     for t in file_types.to_vec() {\n    |              ^^^^^^^^^^^^^^^^^^^\n@@ -491,11 +491,23 @@ LL -         let path = match get_file_path(&t) {\n LL +         let path = match get_file_path(t) {\n    | \n \n+error: unnecessary use of `to_vec`\n+  --> $DIR/unnecessary_to_owned.rs:220:14\n+   |\n+LL |     let _ = &[\"x\"][..].to_vec().into_iter();\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use: `[\"x\"][..].iter().cloned()`\n+\n+error: unnecessary use of `to_vec`\n+  --> $DIR/unnecessary_to_owned.rs:225:14\n+   |\n+LL |     let _ = &[\"x\"][..].to_vec().into_iter();\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use: `[\"x\"][..].iter().copied()`\n+\n error: unnecessary use of `to_string`\n-  --> $DIR/unnecessary_to_owned.rs:260:24\n+  --> $DIR/unnecessary_to_owned.rs:272:24\n    |\n LL |         Box::new(build(y.to_string()))\n    |                        ^^^^^^^^^^^^^ help: use: `y`\n \n-error: aborting due to 77 previous errors\n+error: aborting due to 79 previous errors\n "}, {"sha": "c223b5bc711b2a83956542e652457132f8136fd6", "filename": "tests/ui/unnested_or_patterns.fixed", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Funnested_or_patterns.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Funnested_or_patterns.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funnested_or_patterns.fixed?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -6,10 +6,13 @@\n #![allow(unreachable_patterns, irrefutable_let_patterns, unused_variables)]\n \n fn main() {\n+    // Should be ignored by this lint, as nesting requires more characters.\n+    if let &0 | &2 = &0 {}\n+\n     if let box (0 | 2) = Box::new(0) {}\n     if let box (0 | 1 | 2 | 3 | 4) = Box::new(0) {}\n-    const C0: &u8 = &1;\n-    if let &(0 | 2) | C0 = &0 {}\n+    const C0: Option<u8> = Some(1);\n+    if let Some(1 | 2) | C0 = None {}\n     if let &mut (0 | 2) = &mut 0 {}\n     if let x @ (0 | 2) = 0 {}\n     if let (0, 1 | 2 | 3) = (0, 0) {}"}, {"sha": "04cd11036e4e00e954a27faf2c35cfb650db530e", "filename": "tests/ui/unnested_or_patterns.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Funnested_or_patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Funnested_or_patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funnested_or_patterns.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -6,10 +6,13 @@\n #![allow(unreachable_patterns, irrefutable_let_patterns, unused_variables)]\n \n fn main() {\n+    // Should be ignored by this lint, as nesting requires more characters.\n+    if let &0 | &2 = &0 {}\n+\n     if let box 0 | box 2 = Box::new(0) {}\n     if let box ((0 | 1)) | box (2 | 3) | box 4 = Box::new(0) {}\n-    const C0: &u8 = &1;\n-    if let &0 | C0 | &2 = &0 {}\n+    const C0: Option<u8> = Some(1);\n+    if let Some(1) | C0 | Some(2) = None {}\n     if let &mut 0 | &mut 2 = &mut 0 {}\n     if let x @ 0 | x @ 2 = 0 {}\n     if let (0, 1) | (0, 2) | (0, 3) = (0, 0) {}"}, {"sha": "453c66cbba8fc2838311408c637b65e8b20c9e59", "filename": "tests/ui/unnested_or_patterns.stderr", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Funnested_or_patterns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Funnested_or_patterns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Funnested_or_patterns.stderr?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -1,5 +1,5 @@\n error: unnested or-patterns\n-  --> $DIR/unnested_or_patterns.rs:9:12\n+  --> $DIR/unnested_or_patterns.rs:12:12\n    |\n LL |     if let box 0 | box 2 = Box::new(0) {}\n    |            ^^^^^^^^^^^^^\n@@ -11,7 +11,7 @@ LL |     if let box (0 | 2) = Box::new(0) {}\n    |            ~~~~~~~~~~~\n \n error: unnested or-patterns\n-  --> $DIR/unnested_or_patterns.rs:10:12\n+  --> $DIR/unnested_or_patterns.rs:13:12\n    |\n LL |     if let box ((0 | 1)) | box (2 | 3) | box 4 = Box::new(0) {}\n    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -22,18 +22,18 @@ LL |     if let box (0 | 1 | 2 | 3 | 4) = Box::new(0) {}\n    |            ~~~~~~~~~~~~~~~~~~~~~~~\n \n error: unnested or-patterns\n-  --> $DIR/unnested_or_patterns.rs:12:12\n+  --> $DIR/unnested_or_patterns.rs:15:12\n    |\n-LL |     if let &0 | C0 | &2 = &0 {}\n-   |            ^^^^^^^^^^^^\n+LL |     if let Some(1) | C0 | Some(2) = None {}\n+   |            ^^^^^^^^^^^^^^^^^^^^^^\n    |\n help: nest the patterns\n    |\n-LL |     if let &(0 | 2) | C0 = &0 {}\n-   |            ~~~~~~~~~~~~~\n+LL |     if let Some(1 | 2) | C0 = None {}\n+   |            ~~~~~~~~~~~~~~~~\n \n error: unnested or-patterns\n-  --> $DIR/unnested_or_patterns.rs:13:12\n+  --> $DIR/unnested_or_patterns.rs:16:12\n    |\n LL |     if let &mut 0 | &mut 2 = &mut 0 {}\n    |            ^^^^^^^^^^^^^^^\n@@ -44,7 +44,7 @@ LL |     if let &mut (0 | 2) = &mut 0 {}\n    |            ~~~~~~~~~~~~\n \n error: unnested or-patterns\n-  --> $DIR/unnested_or_patterns.rs:14:12\n+  --> $DIR/unnested_or_patterns.rs:17:12\n    |\n LL |     if let x @ 0 | x @ 2 = 0 {}\n    |            ^^^^^^^^^^^^^\n@@ -55,7 +55,7 @@ LL |     if let x @ (0 | 2) = 0 {}\n    |            ~~~~~~~~~~~\n \n error: unnested or-patterns\n-  --> $DIR/unnested_or_patterns.rs:15:12\n+  --> $DIR/unnested_or_patterns.rs:18:12\n    |\n LL |     if let (0, 1) | (0, 2) | (0, 3) = (0, 0) {}\n    |            ^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -66,7 +66,7 @@ LL |     if let (0, 1 | 2 | 3) = (0, 0) {}\n    |            ~~~~~~~~~~~~~~\n \n error: unnested or-patterns\n-  --> $DIR/unnested_or_patterns.rs:16:12\n+  --> $DIR/unnested_or_patterns.rs:19:12\n    |\n LL |     if let (1, 0) | (2, 0) | (3, 0) = (0, 0) {}\n    |            ^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -77,7 +77,7 @@ LL |     if let (1 | 2 | 3, 0) = (0, 0) {}\n    |            ~~~~~~~~~~~~~~\n \n error: unnested or-patterns\n-  --> $DIR/unnested_or_patterns.rs:17:12\n+  --> $DIR/unnested_or_patterns.rs:20:12\n    |\n LL |     if let (x, ..) | (x, 1) | (x, 2) = (0, 1) {}\n    |            ^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -88,7 +88,7 @@ LL |     if let (x, ..) | (x, 1 | 2) = (0, 1) {}\n    |            ~~~~~~~~~~~~~~~~~~~~\n \n error: unnested or-patterns\n-  --> $DIR/unnested_or_patterns.rs:18:12\n+  --> $DIR/unnested_or_patterns.rs:21:12\n    |\n LL |     if let [0] | [1] = [0] {}\n    |            ^^^^^^^^^\n@@ -99,7 +99,7 @@ LL |     if let [0 | 1] = [0] {}\n    |            ~~~~~~~\n \n error: unnested or-patterns\n-  --> $DIR/unnested_or_patterns.rs:19:12\n+  --> $DIR/unnested_or_patterns.rs:22:12\n    |\n LL |     if let [x, 0] | [x, 1] = [0, 1] {}\n    |            ^^^^^^^^^^^^^^^\n@@ -110,7 +110,7 @@ LL |     if let [x, 0 | 1] = [0, 1] {}\n    |            ~~~~~~~~~~\n \n error: unnested or-patterns\n-  --> $DIR/unnested_or_patterns.rs:20:12\n+  --> $DIR/unnested_or_patterns.rs:23:12\n    |\n LL |     if let [x, 0] | [x, 1] | [x, 2] = [0, 1] {}\n    |            ^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -121,7 +121,7 @@ LL |     if let [x, 0 | 1 | 2] = [0, 1] {}\n    |            ~~~~~~~~~~~~~~\n \n error: unnested or-patterns\n-  --> $DIR/unnested_or_patterns.rs:21:12\n+  --> $DIR/unnested_or_patterns.rs:24:12\n    |\n LL |     if let [x, ..] | [x, 1] | [x, 2] = [0, 1] {}\n    |            ^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -132,7 +132,7 @@ LL |     if let [x, ..] | [x, 1 | 2] = [0, 1] {}\n    |            ~~~~~~~~~~~~~~~~~~~~\n \n error: unnested or-patterns\n-  --> $DIR/unnested_or_patterns.rs:23:12\n+  --> $DIR/unnested_or_patterns.rs:26:12\n    |\n LL |     if let TS(0, x) | TS(1, x) = TS(0, 0) {}\n    |            ^^^^^^^^^^^^^^^^^^^\n@@ -143,7 +143,7 @@ LL |     if let TS(0 | 1, x) = TS(0, 0) {}\n    |            ~~~~~~~~~~~~\n \n error: unnested or-patterns\n-  --> $DIR/unnested_or_patterns.rs:24:12\n+  --> $DIR/unnested_or_patterns.rs:27:12\n    |\n LL |     if let TS(1, 0) | TS(2, 0) | TS(3, 0) = TS(0, 0) {}\n    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -154,7 +154,7 @@ LL |     if let TS(1 | 2 | 3, 0) = TS(0, 0) {}\n    |            ~~~~~~~~~~~~~~~~\n \n error: unnested or-patterns\n-  --> $DIR/unnested_or_patterns.rs:25:12\n+  --> $DIR/unnested_or_patterns.rs:28:12\n    |\n LL |     if let TS(x, ..) | TS(x, 1) | TS(x, 2) = TS(0, 0) {}\n    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -165,7 +165,7 @@ LL |     if let TS(x, ..) | TS(x, 1 | 2) = TS(0, 0) {}\n    |            ~~~~~~~~~~~~~~~~~~~~~~~~\n \n error: unnested or-patterns\n-  --> $DIR/unnested_or_patterns.rs:30:12\n+  --> $DIR/unnested_or_patterns.rs:33:12\n    |\n LL |     if let S { x: 0, y } | S { y, x: 1 } = (S { x: 0, y: 1 }) {}\n    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"}, {"sha": "c23231a99e9f049015d44694fbd8d58ee2b8c1c3", "filename": "tests/ui/useless_attribute.fixed", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fuseless_attribute.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fuseless_attribute.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fuseless_attribute.fixed?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -57,6 +57,12 @@ pub use std::io::prelude::*;\n #[allow(clippy::enum_glob_use)]\n pub use std::cmp::Ordering::*;\n \n+// don't lint on clippy::redundant_pub_crate\n+mod c {\n+    #[allow(clippy::redundant_pub_crate)]\n+    pub(crate) struct S;\n+}\n+\n fn test_indented_attr() {\n     #![allow(clippy::almost_swapped)]\n     use std::collections::HashSet;"}, {"sha": "7a7b198ea6078e701ce33c9faf5269f72820f5c4", "filename": "tests/ui/useless_attribute.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fuseless_attribute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fuseless_attribute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fuseless_attribute.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -57,6 +57,12 @@ pub use std::io::prelude::*;\n #[allow(clippy::enum_glob_use)]\n pub use std::cmp::Ordering::*;\n \n+// don't lint on clippy::redundant_pub_crate\n+mod c {\n+    #[allow(clippy::redundant_pub_crate)]\n+    pub(crate) struct S;\n+}\n+\n fn test_indented_attr() {\n     #[allow(clippy::almost_swapped)]\n     use std::collections::HashSet;"}, {"sha": "255d2876355316ed987b39a86231806c7f122d31", "filename": "tests/ui/useless_attribute.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fuseless_attribute.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fuseless_attribute.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fuseless_attribute.stderr?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -13,7 +13,7 @@ LL | #[cfg_attr(feature = \"cargo-clippy\", allow(dead_code))]\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: if you just forgot a `!`, use: `#![cfg_attr(feature = \"cargo-clippy\", allow(dead_code)`\n \n error: useless lint attribute\n-  --> $DIR/useless_attribute.rs:61:5\n+  --> $DIR/useless_attribute.rs:67:5\n    |\n LL |     #[allow(clippy::almost_swapped)]\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: if you just forgot a `!`, use: `#![allow(clippy::almost_swapped)]`"}, {"sha": "b6f47ae906b73709b6096e5ffeeb4caa36dedab3", "filename": "tests/ui/wildcard_imports.fixed", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fwildcard_imports.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fwildcard_imports.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwildcard_imports.fixed?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -8,8 +8,7 @@\n // FIXME: We should likely add another edition 2021 test case for this lint\n \n #![warn(clippy::wildcard_imports)]\n-#![allow(unused)]\n-#![allow(clippy::unnecessary_wraps)]\n+#![allow(unused, clippy::unnecessary_wraps, clippy::let_unit_value)]\n #![warn(unused_imports)]\n \n extern crate wildcard_imports_helper;"}, {"sha": "eb404b7a3de5f661cbb2af6b428ca042830ac985", "filename": "tests/ui/wildcard_imports.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fwildcard_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fwildcard_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwildcard_imports.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -8,8 +8,7 @@\n // FIXME: We should likely add another edition 2021 test case for this lint\n \n #![warn(clippy::wildcard_imports)]\n-#![allow(unused)]\n-#![allow(clippy::unnecessary_wraps)]\n+#![allow(unused, clippy::unnecessary_wraps, clippy::let_unit_value)]\n #![warn(unused_imports)]\n \n extern crate wildcard_imports_helper;"}, {"sha": "626c1754fc82c8720bbc3e1ac84c0f932dbce630", "filename": "tests/ui/wildcard_imports.stderr", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fwildcard_imports.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fwildcard_imports.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwildcard_imports.stderr?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -1,129 +1,129 @@\n error: usage of wildcard import\n-  --> $DIR/wildcard_imports.rs:17:5\n+  --> $DIR/wildcard_imports.rs:16:5\n    |\n LL | use crate::fn_mod::*;\n    |     ^^^^^^^^^^^^^^^^ help: try: `crate::fn_mod::foo`\n    |\n    = note: `-D clippy::wildcard-imports` implied by `-D warnings`\n \n error: usage of wildcard import\n-  --> $DIR/wildcard_imports.rs:18:5\n+  --> $DIR/wildcard_imports.rs:17:5\n    |\n LL | use crate::mod_mod::*;\n    |     ^^^^^^^^^^^^^^^^^ help: try: `crate::mod_mod::inner_mod`\n \n error: usage of wildcard import\n-  --> $DIR/wildcard_imports.rs:19:5\n+  --> $DIR/wildcard_imports.rs:18:5\n    |\n LL | use crate::multi_fn_mod::*;\n    |     ^^^^^^^^^^^^^^^^^^^^^^ help: try: `crate::multi_fn_mod::{multi_bar, multi_foo, multi_inner_mod}`\n \n error: usage of wildcard import\n-  --> $DIR/wildcard_imports.rs:21:5\n+  --> $DIR/wildcard_imports.rs:20:5\n    |\n LL | use crate::struct_mod::*;\n    |     ^^^^^^^^^^^^^^^^^^^^ help: try: `crate::struct_mod::{A, inner_struct_mod}`\n \n error: usage of wildcard import\n-  --> $DIR/wildcard_imports.rs:25:5\n+  --> $DIR/wildcard_imports.rs:24:5\n    |\n LL | use wildcard_imports_helper::inner::inner_for_self_import::*;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `wildcard_imports_helper::inner::inner_for_self_import::inner_extern_bar`\n \n error: usage of wildcard import\n-  --> $DIR/wildcard_imports.rs:26:5\n+  --> $DIR/wildcard_imports.rs:25:5\n    |\n LL | use wildcard_imports_helper::*;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `wildcard_imports_helper::{ExternA, extern_foo}`\n \n error: usage of wildcard import\n-  --> $DIR/wildcard_imports.rs:97:13\n+  --> $DIR/wildcard_imports.rs:96:13\n    |\n LL |         use crate::fn_mod::*;\n    |             ^^^^^^^^^^^^^^^^ help: try: `crate::fn_mod::foo`\n \n error: usage of wildcard import\n-  --> $DIR/wildcard_imports.rs:103:75\n+  --> $DIR/wildcard_imports.rs:102:75\n    |\n LL |         use wildcard_imports_helper::inner::inner_for_self_import::{self, *};\n    |                                                                           ^ help: try: `inner_extern_foo`\n \n error: usage of wildcard import\n-  --> $DIR/wildcard_imports.rs:104:13\n+  --> $DIR/wildcard_imports.rs:103:13\n    |\n LL |         use wildcard_imports_helper::*;\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `wildcard_imports_helper::{ExternA, extern_foo}`\n \n error: usage of wildcard import\n-  --> $DIR/wildcard_imports.rs:115:20\n+  --> $DIR/wildcard_imports.rs:114:20\n    |\n LL |         use self::{inner::*, inner2::*};\n    |                    ^^^^^^^^ help: try: `inner::inner_foo`\n \n error: usage of wildcard import\n-  --> $DIR/wildcard_imports.rs:115:30\n+  --> $DIR/wildcard_imports.rs:114:30\n    |\n LL |         use self::{inner::*, inner2::*};\n    |                              ^^^^^^^^^ help: try: `inner2::inner_bar`\n \n error: usage of wildcard import\n-  --> $DIR/wildcard_imports.rs:122:13\n+  --> $DIR/wildcard_imports.rs:121:13\n    |\n LL |         use wildcard_imports_helper::*;\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `wildcard_imports_helper::{ExternExportedEnum, ExternExportedStruct, extern_exported}`\n \n error: usage of wildcard import\n-  --> $DIR/wildcard_imports.rs:151:9\n+  --> $DIR/wildcard_imports.rs:150:9\n    |\n LL |     use crate::in_fn_test::*;\n    |         ^^^^^^^^^^^^^^^^^^^^ help: try: `crate::in_fn_test::{ExportedEnum, ExportedStruct, exported}`\n \n error: usage of wildcard import\n-  --> $DIR/wildcard_imports.rs:160:9\n+  --> $DIR/wildcard_imports.rs:159:9\n    |\n LL |     use crate:: in_fn_test::  * ;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `crate:: in_fn_test::exported`\n \n error: usage of wildcard import\n-  --> $DIR/wildcard_imports.rs:161:9\n+  --> $DIR/wildcard_imports.rs:160:9\n    |\n LL |       use crate:: fn_mod::\n    |  _________^\n LL | |         *;\n    | |_________^ help: try: `crate:: fn_mod::foo`\n \n error: usage of wildcard import\n-  --> $DIR/wildcard_imports.rs:172:13\n+  --> $DIR/wildcard_imports.rs:171:13\n    |\n LL |         use super::*;\n    |             ^^^^^^^^ help: try: `super::foofoo`\n \n error: usage of wildcard import\n-  --> $DIR/wildcard_imports.rs:207:17\n+  --> $DIR/wildcard_imports.rs:206:17\n    |\n LL |             use super::*;\n    |                 ^^^^^^^^ help: try: `super::insidefoo`\n \n error: usage of wildcard import\n-  --> $DIR/wildcard_imports.rs:215:13\n+  --> $DIR/wildcard_imports.rs:214:13\n    |\n LL |         use super_imports::*;\n    |             ^^^^^^^^^^^^^^^^ help: try: `super_imports::foofoo`\n \n error: usage of wildcard import\n-  --> $DIR/wildcard_imports.rs:224:17\n+  --> $DIR/wildcard_imports.rs:223:17\n    |\n LL |             use super::super::*;\n    |                 ^^^^^^^^^^^^^^^ help: try: `super::super::foofoo`\n \n error: usage of wildcard import\n-  --> $DIR/wildcard_imports.rs:233:13\n+  --> $DIR/wildcard_imports.rs:232:13\n    |\n LL |         use super::super::super_imports::*;\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `super::super::super_imports::foofoo`\n \n error: usage of wildcard import\n-  --> $DIR/wildcard_imports.rs:241:13\n+  --> $DIR/wildcard_imports.rs:240:13\n    |\n LL |         use super::*;\n    |             ^^^^^^^^ help: try: `super::foofoo`"}, {"sha": "e3cc90ee222ada2f2e2ca21742f13a03b10ba50b", "filename": "tests/ui/wrong_self_convention.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fwrong_self_convention.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fwrong_self_convention.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwrong_self_convention.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -193,11 +193,6 @@ pub mod issue8142 {\n     struct S;\n \n     impl S {\n-        // Should lint: is_ methods should only take &self, or no self at all.\n-        fn is_still_buggy(&mut self) -> bool {\n-            false\n-        }\n-\n         // Should not lint: \"no self at all\" is allowed.\n         fn is_forty_two(x: u32) -> bool {\n             x == 42"}, {"sha": "2e7ee51d7e11a7e07593df9a926e2b7912a2f78c", "filename": "tests/ui/wrong_self_convention.stderr", "status": "modified", "additions": 5, "deletions": 13, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fwrong_self_convention.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fwrong_self_convention.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwrong_self_convention.stderr?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -31,7 +31,7 @@ LL |     fn into_i32(&self) {}\n    |\n    = help: consider choosing a less ambiguous name\n \n-error: methods called `is_*` usually take `self` by reference or no `self`\n+error: methods called `is_*` usually take `self` by mutable reference or `self` by reference or no `self`\n   --> $DIR/wrong_self_convention.rs:38:15\n    |\n LL |     fn is_i32(self) {}\n@@ -71,7 +71,7 @@ LL |     pub fn into_i64(&self) {}\n    |\n    = help: consider choosing a less ambiguous name\n \n-error: methods called `is_*` usually take `self` by reference or no `self`\n+error: methods called `is_*` usually take `self` by mutable reference or `self` by reference or no `self`\n   --> $DIR/wrong_self_convention.rs:46:19\n    |\n LL |     pub fn is_i64(self) {}\n@@ -111,7 +111,7 @@ LL |         fn into_i32_ref(&self) {}\n    |\n    = help: consider choosing a less ambiguous name\n \n-error: methods called `is_*` usually take `self` by reference or no `self`\n+error: methods called `is_*` usually take `self` by mutable reference or `self` by reference or no `self`\n   --> $DIR/wrong_self_convention.rs:98:19\n    |\n LL |         fn is_i32(self) {}\n@@ -143,7 +143,7 @@ LL |         fn into_i32_ref(&self);\n    |\n    = help: consider choosing a less ambiguous name\n \n-error: methods called `is_*` usually take `self` by reference or no `self`\n+error: methods called `is_*` usually take `self` by mutable reference or `self` by reference or no `self`\n   --> $DIR/wrong_self_convention.rs:122:19\n    |\n LL |         fn is_i32(self);\n@@ -191,13 +191,5 @@ LL |         fn to_u64(self) -> u64 {\n    |\n    = help: consider choosing a less ambiguous name\n \n-error: methods called `is_*` usually take `self` by reference or no `self`\n-  --> $DIR/wrong_self_convention.rs:197:27\n-   |\n-LL |         fn is_still_buggy(&mut self) -> bool {\n-   |                           ^^^^^^^^^\n-   |\n-   = help: consider choosing a less ambiguous name\n-\n-error: aborting due to 25 previous errors\n+error: aborting due to 24 previous errors\n "}, {"sha": "0dcf4743e8b8dbcd1186b794a9f2846a763a2da2", "filename": "tests/ui/wrong_self_convention2.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fwrong_self_convention2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7cd86aa1be18d608d828239c11e887a762efc92a/tests%2Fui%2Fwrong_self_convention2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwrong_self_convention2.rs?ref=7cd86aa1be18d608d828239c11e887a762efc92a", "patch": "@@ -104,3 +104,13 @@ mod issue4546 {\n         pub fn to_other_thingy(self: Pin<&Self>) {}\n     }\n }\n+\n+mod issue_8480_8513 {\n+    struct Cat(String);\n+\n+    impl Cat {\n+        fn is_animal(&mut self) -> bool {\n+            todo!();\n+        }\n+    }\n+}"}]}