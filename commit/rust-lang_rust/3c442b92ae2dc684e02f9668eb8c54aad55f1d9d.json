{"sha": "3c442b92ae2dc684e02f9668eb8c54aad55f1d9d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNjNDQyYjkyYWUyZGM2ODRlMDJmOTY2OGViOGM1NGFhZDU1ZjFkOWQ=", "commit": {"author": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2014-11-07T22:16:59Z"}, "committer": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2014-11-07T23:26:44Z"}, "message": "syntax: Use UFCS in the expansion of `#[deriving(PartialOrd)]`", "tree": {"sha": "6e993d1cb3606d0ed1ecdc5d97efd6cf96844435", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6e993d1cb3606d0ed1ecdc5d97efd6cf96844435"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3c442b92ae2dc684e02f9668eb8c54aad55f1d9d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3c442b92ae2dc684e02f9668eb8c54aad55f1d9d", "html_url": "https://github.com/rust-lang/rust/commit/3c442b92ae2dc684e02f9668eb8c54aad55f1d9d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3c442b92ae2dc684e02f9668eb8c54aad55f1d9d/comments", "author": null, "committer": null, "parents": [{"sha": "0a3cbf8cf44e41072c11277363a5100cf3a8a161", "url": "https://api.github.com/repos/rust-lang/rust/commits/0a3cbf8cf44e41072c11277363a5100cf3a8a161", "html_url": "https://github.com/rust-lang/rust/commit/0a3cbf8cf44e41072c11277363a5100cf3a8a161"}], "stats": {"total": 54, "additions": 50, "deletions": 4}, "files": [{"sha": "8f3b1edb59f9ba206818b270c0d06a91719c3dc9", "filename": "src/libsyntax/ext/deriving/cmp/ord.rs", "status": "modified", "additions": 25, "deletions": 4, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/3c442b92ae2dc684e02f9668eb8c54aad55f1d9d/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c442b92ae2dc684e02f9668eb8c54aad55f1d9d/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs?ref=3c442b92ae2dc684e02f9668eb8c54aad55f1d9d", "patch": "@@ -107,12 +107,19 @@ pub fn cs_partial_cmp(cx: &mut ExtCtxt, span: Span,\n     let ordering = cx.expr_path(ordering);\n     let equals_expr = cx.expr_some(span, ordering);\n \n+    let partial_cmp_path = vec![\n+        cx.ident_of(\"std\"),\n+        cx.ident_of(\"cmp\"),\n+        cx.ident_of(\"PartialOrd\"),\n+        cx.ident_of(\"partial_cmp\"),\n+    ];\n+\n     /*\n     Builds:\n \n-    let __test = self_field1.partial_cmp(&other_field2);\n+    let __test = ::std::cmp::PartialOrd::partial_cmp(&self_field1, &other_field1);\n     if __test == ::std::option::Some(::std::cmp::Equal) {\n-        let __test = self_field2.partial_cmp(&other_field2);\n+        let __test = ::std::cmp::PartialOrd::partial_cmp(&self_field2, &other_field2);\n         if __test == ::std::option::Some(::std::cmp::Equal) {\n             ...\n         } else {\n@@ -124,18 +131,32 @@ pub fn cs_partial_cmp(cx: &mut ExtCtxt, span: Span,\n \n     FIXME #6449: These `if`s could/should be `match`es.\n     */\n-    cs_same_method_fold(\n+    cs_fold(\n         // foldr nests the if-elses correctly, leaving the first field\n         // as the outermost one, and the last as the innermost.\n         false,\n-        |cx, span, old, new| {\n+        |cx, span, old, self_f, other_fs| {\n             // let __test = new;\n             // if __test == Some(::std::cmp::Equal) {\n             //    old\n             // } else {\n             //    __test\n             // }\n \n+            let new = {\n+                let other_f = match other_fs {\n+                    [ref o_f] => o_f,\n+                    _ => cx.span_bug(span, \"not exactly 2 arguments in `deriving(Ord)`\"),\n+                };\n+\n+                let args = vec![\n+                    cx.expr_addr_of(span, self_f),\n+                    cx.expr_addr_of(span, other_f.clone()),\n+                ];\n+\n+                cx.expr_call_global(span, partial_cmp_path.clone(), args)\n+            };\n+\n             let assign = cx.stmt_let(span, false, test_id, new);\n \n             let cond = cx.expr_binary(span, ast::BiEq,"}, {"sha": "7958b9ec117cbea071278b4369c1b144f190e728", "filename": "src/test/run-pass/issue-18738.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/3c442b92ae2dc684e02f9668eb8c54aad55f1d9d/src%2Ftest%2Frun-pass%2Fissue-18738.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c442b92ae2dc684e02f9668eb8c54aad55f1d9d/src%2Ftest%2Frun-pass%2Fissue-18738.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-18738.rs?ref=3c442b92ae2dc684e02f9668eb8c54aad55f1d9d", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[deriving(PartialEq, PartialOrd)]\n+enum Test<'a> {\n+    Int(&'a int),\n+    Slice(&'a [u8]),\n+}\n+\n+#[deriving(PartialEq, PartialOrd)]\n+struct Version {\n+    vendor_info: &'static str\n+}\n+\n+#[deriving(PartialEq, PartialOrd)]\n+struct Foo(&'static str);\n+\n+fn main() {}"}]}