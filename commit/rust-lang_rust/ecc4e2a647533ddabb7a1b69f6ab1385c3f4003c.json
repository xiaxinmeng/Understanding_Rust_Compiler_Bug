{"sha": "ecc4e2a647533ddabb7a1b69f6ab1385c3f4003c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVjYzRlMmE2NDc1MzNkZGFiYjdhMWI2OWY2YWIxMzg1YzNmNDAwM2M=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2020-04-09T03:29:43Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-04-09T03:29:43Z"}, "message": "Rollup merge of #70896 - cuviper:optional-chain, r=scottmcm\n\nImplement Chain with Option fuses\n\nThe iterators are now \"fused\" with `Option` so we don't need separate state to track which part is already exhausted, and we may also get niche layout for `None`. We don't use the real `Fuse` adapter because its specialization for `FusedIterator` unconditionally descends into the iterator, and that could be expensive to keep revisiting stuff like nested chains. It also hurts compiler performance to add more iterator layers to `Chain`.\n\nThis change was inspired by the [proposal](https://internals.rust-lang.org/t/proposal-implement-iter-chain-using-fuse/12006) on the internals forum. This is an alternate to #70332, directly employing some of the same `Fuse` optimizations as #70366 and #70750.\n\nr? @scottmcm", "tree": {"sha": "de8e9f80a0c55f6f9e546ede1d3646fd0997c3bd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/de8e9f80a0c55f6f9e546ede1d3646fd0997c3bd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ecc4e2a647533ddabb7a1b69f6ab1385c3f4003c", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJejpanCRBK7hj4Ov3rIwAAdHIIAFPYTPolFISCQjkRgI0ZVphY\npihzJqJKIih2JIcE863PicUd3tE9zVeBXPydh3jDTkeUg0qgVGJBXccWDw6qILLa\nMf6QME8sh8NoqIsXqvzZuuV6hb4kHbVb+5WOpRtOrqq+j5Czrg61PQGjj7/psOIp\n6A+GnyHX9tyfw1EFMUN7Wng3IKz1Isrcjb8wSraty5ty1D1ns55VgPwPGDrpOMLY\nbtnNgGNU3QlZrXsZnthsoOtrW8JHx0bzTsyJ2gQBPxLZc+BAyDAkb4UpGqFw8wag\nBbnSmSv7BGDTGhXH7/IkUaUyMiNAbnww1+lIYhj4YomHfiLdO7T47vgJrGbdcN8=\n=r6rH\n-----END PGP SIGNATURE-----\n", "payload": "tree de8e9f80a0c55f6f9e546ede1d3646fd0997c3bd\nparent cefee7bd9a7e188e406cac0190cf4a19fcca27ff\nparent ce8abc63a7e1fcac4b69574e00a70352e583cec8\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1586402983 +0200\ncommitter GitHub <noreply@github.com> 1586402983 +0200\n\nRollup merge of #70896 - cuviper:optional-chain, r=scottmcm\n\nImplement Chain with Option fuses\n\nThe iterators are now \"fused\" with `Option` so we don't need separate state to track which part is already exhausted, and we may also get niche layout for `None`. We don't use the real `Fuse` adapter because its specialization for `FusedIterator` unconditionally descends into the iterator, and that could be expensive to keep revisiting stuff like nested chains. It also hurts compiler performance to add more iterator layers to `Chain`.\n\nThis change was inspired by the [proposal](https://internals.rust-lang.org/t/proposal-implement-iter-chain-using-fuse/12006) on the internals forum. This is an alternate to #70332, directly employing some of the same `Fuse` optimizations as #70366 and #70750.\n\nr? @scottmcm\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ecc4e2a647533ddabb7a1b69f6ab1385c3f4003c", "html_url": "https://github.com/rust-lang/rust/commit/ecc4e2a647533ddabb7a1b69f6ab1385c3f4003c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ecc4e2a647533ddabb7a1b69f6ab1385c3f4003c/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cefee7bd9a7e188e406cac0190cf4a19fcca27ff", "url": "https://api.github.com/repos/rust-lang/rust/commits/cefee7bd9a7e188e406cac0190cf4a19fcca27ff", "html_url": "https://github.com/rust-lang/rust/commit/cefee7bd9a7e188e406cac0190cf4a19fcca27ff"}, {"sha": "ce8abc63a7e1fcac4b69574e00a70352e583cec8", "url": "https://api.github.com/repos/rust-lang/rust/commits/ce8abc63a7e1fcac4b69574e00a70352e583cec8", "html_url": "https://github.com/rust-lang/rust/commit/ce8abc63a7e1fcac4b69574e00a70352e583cec8"}], "stats": {"total": 267, "additions": 113, "deletions": 154}, "files": [{"sha": "2dd405ced20e1577bdbe77ea7a86927a076b0862", "filename": "src/libcore/iter/adapters/chain.rs", "status": "modified", "additions": 113, "deletions": 154, "changes": 267, "blob_url": "https://github.com/rust-lang/rust/blob/ecc4e2a647533ddabb7a1b69f6ab1385c3f4003c/src%2Flibcore%2Fiter%2Fadapters%2Fchain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecc4e2a647533ddabb7a1b69f6ab1385c3f4003c/src%2Flibcore%2Fiter%2Fadapters%2Fchain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fadapters%2Fchain.rs?ref=ecc4e2a647533ddabb7a1b69f6ab1385c3f4003c", "patch": "@@ -1,8 +1,7 @@\n+use crate::iter::{DoubleEndedIterator, FusedIterator, Iterator, TrustedLen};\n use crate::ops::Try;\n use crate::usize;\n \n-use super::super::{DoubleEndedIterator, FusedIterator, Iterator, TrustedLen};\n-\n /// An iterator that links two iterators together, in a chain.\n ///\n /// This `struct` is created by the [`chain`] method on [`Iterator`]. See its\n@@ -14,37 +13,34 @@ use super::super::{DoubleEndedIterator, FusedIterator, Iterator, TrustedLen};\n #[must_use = \"iterators are lazy and do nothing unless consumed\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Chain<A, B> {\n-    a: A,\n-    b: B,\n-    state: ChainState,\n+    // These are \"fused\" with `Option` so we don't need separate state to track which part is\n+    // already exhausted, and we may also get niche layout for `None`. We don't use the real `Fuse`\n+    // adapter because its specialization for `FusedIterator` unconditionally descends into the\n+    // iterator, and that could be expensive to keep revisiting stuff like nested chains. It also\n+    // hurts compiler performance to add more iterator layers to `Chain`.\n+    a: Option<A>,\n+    b: Option<B>,\n }\n impl<A, B> Chain<A, B> {\n     pub(in super::super) fn new(a: A, b: B) -> Chain<A, B> {\n-        Chain { a, b, state: ChainState::Both }\n+        Chain { a: Some(a), b: Some(b) }\n     }\n }\n \n-// The iterator protocol specifies that iteration ends with the return value\n-// `None` from `.next()` (or `.next_back()`) and it is unspecified what\n-// further calls return. The chain adaptor must account for this since it uses\n-// two subiterators.\n-//\n-//  It uses three states:\n-//\n-//  - Both: `a` and `b` are remaining\n-//  - Front: `a` remaining\n-//  - Back: `b` remaining\n-//\n-//  The fourth state (neither iterator is remaining) only occurs after Chain has\n-//  returned None once, so we don't need to store this state.\n-#[derive(Clone, Debug)]\n-enum ChainState {\n-    // both front and back iterator are remaining\n-    Both,\n-    // only front is remaining\n-    Front,\n-    // only back is remaining\n-    Back,\n+/// Fuse the iterator if the expression is `None`.\n+macro_rules! fuse {\n+    ($self:ident . $iter:ident . $($call:tt)+) => {\n+        match $self.$iter {\n+            Some(ref mut iter) => match iter.$($call)+ {\n+                None => {\n+                    $self.$iter = None;\n+                    None\n+                }\n+                item => item,\n+            },\n+            None => None,\n+        }\n+    };\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -57,128 +53,101 @@ where\n \n     #[inline]\n     fn next(&mut self) -> Option<A::Item> {\n-        match self.state {\n-            ChainState::Both => match self.a.next() {\n-                elt @ Some(..) => elt,\n-                None => {\n-                    self.state = ChainState::Back;\n-                    self.b.next()\n-                }\n-            },\n-            ChainState::Front => self.a.next(),\n-            ChainState::Back => self.b.next(),\n+        match fuse!(self.a.next()) {\n+            None => fuse!(self.b.next()),\n+            item => item,\n         }\n     }\n \n     #[inline]\n     #[rustc_inherit_overflow_checks]\n     fn count(self) -> usize {\n-        match self.state {\n-            ChainState::Both => self.a.count() + self.b.count(),\n-            ChainState::Front => self.a.count(),\n-            ChainState::Back => self.b.count(),\n-        }\n+        let a_count = match self.a {\n+            Some(a) => a.count(),\n+            None => 0,\n+        };\n+        let b_count = match self.b {\n+            Some(b) => b.count(),\n+            None => 0,\n+        };\n+        a_count + b_count\n     }\n \n-    fn try_fold<Acc, F, R>(&mut self, init: Acc, mut f: F) -> R\n+    fn try_fold<Acc, F, R>(&mut self, mut acc: Acc, mut f: F) -> R\n     where\n         Self: Sized,\n         F: FnMut(Acc, Self::Item) -> R,\n         R: Try<Ok = Acc>,\n     {\n-        let mut accum = init;\n-        match self.state {\n-            ChainState::Both | ChainState::Front => {\n-                accum = self.a.try_fold(accum, &mut f)?;\n-                if let ChainState::Both = self.state {\n-                    self.state = ChainState::Back;\n-                }\n-            }\n-            _ => {}\n+        if let Some(ref mut a) = self.a {\n+            acc = a.try_fold(acc, &mut f)?;\n+            self.a = None;\n         }\n-        if let ChainState::Back = self.state {\n-            accum = self.b.try_fold(accum, &mut f)?;\n+        if let Some(ref mut b) = self.b {\n+            acc = b.try_fold(acc, f)?;\n+            self.b = None;\n         }\n-        Try::from_ok(accum)\n+        Try::from_ok(acc)\n     }\n \n-    fn fold<Acc, F>(self, init: Acc, mut f: F) -> Acc\n+    fn fold<Acc, F>(self, mut acc: Acc, mut f: F) -> Acc\n     where\n         F: FnMut(Acc, Self::Item) -> Acc,\n     {\n-        let mut accum = init;\n-        match self.state {\n-            ChainState::Both | ChainState::Front => {\n-                accum = self.a.fold(accum, &mut f);\n-            }\n-            _ => {}\n+        if let Some(a) = self.a {\n+            acc = a.fold(acc, &mut f);\n         }\n-        match self.state {\n-            ChainState::Both | ChainState::Back => {\n-                accum = self.b.fold(accum, &mut f);\n-            }\n-            _ => {}\n+        if let Some(b) = self.b {\n+            acc = b.fold(acc, f);\n         }\n-        accum\n+        acc\n     }\n \n     #[inline]\n     fn nth(&mut self, mut n: usize) -> Option<A::Item> {\n-        match self.state {\n-            ChainState::Both | ChainState::Front => {\n-                for x in self.a.by_ref() {\n-                    if n == 0 {\n-                        return Some(x);\n-                    }\n-                    n -= 1;\n-                }\n-                if let ChainState::Both = self.state {\n-                    self.state = ChainState::Back;\n+        if let Some(ref mut a) = self.a {\n+            while let Some(x) = a.next() {\n+                if n == 0 {\n+                    return Some(x);\n                 }\n+                n -= 1;\n             }\n-            ChainState::Back => {}\n+            self.a = None;\n         }\n-        if let ChainState::Back = self.state { self.b.nth(n) } else { None }\n+        fuse!(self.b.nth(n))\n     }\n \n     #[inline]\n     fn find<P>(&mut self, mut predicate: P) -> Option<Self::Item>\n     where\n         P: FnMut(&Self::Item) -> bool,\n     {\n-        match self.state {\n-            ChainState::Both => match self.a.find(&mut predicate) {\n-                None => {\n-                    self.state = ChainState::Back;\n-                    self.b.find(predicate)\n-                }\n-                v => v,\n-            },\n-            ChainState::Front => self.a.find(predicate),\n-            ChainState::Back => self.b.find(predicate),\n+        match fuse!(self.a.find(&mut predicate)) {\n+            None => fuse!(self.b.find(predicate)),\n+            item => item,\n         }\n     }\n \n     #[inline]\n     fn last(self) -> Option<A::Item> {\n-        match self.state {\n-            ChainState::Both => {\n-                // Must exhaust a before b.\n-                let a_last = self.a.last();\n-                let b_last = self.b.last();\n-                b_last.or(a_last)\n-            }\n-            ChainState::Front => self.a.last(),\n-            ChainState::Back => self.b.last(),\n-        }\n+        // Must exhaust a before b.\n+        let a_last = match self.a {\n+            Some(a) => a.last(),\n+            None => None,\n+        };\n+        let b_last = match self.b {\n+            Some(b) => b.last(),\n+            None => None,\n+        };\n+        b_last.or(a_last)\n     }\n \n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        match self.state {\n-            ChainState::Both => {\n-                let (a_lower, a_upper) = self.a.size_hint();\n-                let (b_lower, b_upper) = self.b.size_hint();\n+        match self {\n+            Chain { a: Some(a), b: Some(b) } => {\n+                let (a_lower, a_upper) = a.size_hint();\n+                let (b_lower, b_upper) = b.size_hint();\n \n                 let lower = a_lower.saturating_add(b_lower);\n \n@@ -189,8 +158,9 @@ where\n \n                 (lower, upper)\n             }\n-            ChainState::Front => self.a.size_hint(),\n-            ChainState::Back => self.b.size_hint(),\n+            Chain { a: Some(a), b: None } => a.size_hint(),\n+            Chain { a: None, b: Some(b) } => b.size_hint(),\n+            Chain { a: None, b: None } => (0, Some(0)),\n         }\n     }\n }\n@@ -203,82 +173,71 @@ where\n {\n     #[inline]\n     fn next_back(&mut self) -> Option<A::Item> {\n-        match self.state {\n-            ChainState::Both => match self.b.next_back() {\n-                elt @ Some(..) => elt,\n-                None => {\n-                    self.state = ChainState::Front;\n-                    self.a.next_back()\n-                }\n-            },\n-            ChainState::Front => self.a.next_back(),\n-            ChainState::Back => self.b.next_back(),\n+        match fuse!(self.b.next_back()) {\n+            None => fuse!(self.a.next_back()),\n+            item => item,\n         }\n     }\n \n     #[inline]\n     fn nth_back(&mut self, mut n: usize) -> Option<A::Item> {\n-        match self.state {\n-            ChainState::Both | ChainState::Back => {\n-                for x in self.b.by_ref().rev() {\n-                    if n == 0 {\n-                        return Some(x);\n-                    }\n-                    n -= 1;\n-                }\n-                if let ChainState::Both = self.state {\n-                    self.state = ChainState::Front;\n+        if let Some(ref mut b) = self.b {\n+            while let Some(x) = b.next_back() {\n+                if n == 0 {\n+                    return Some(x);\n                 }\n+                n -= 1;\n             }\n-            ChainState::Front => {}\n+            self.b = None;\n         }\n-        if let ChainState::Front = self.state { self.a.nth_back(n) } else { None }\n+        fuse!(self.a.nth_back(n))\n     }\n \n-    fn try_rfold<Acc, F, R>(&mut self, init: Acc, mut f: F) -> R\n+    #[inline]\n+    fn rfind<P>(&mut self, mut predicate: P) -> Option<Self::Item>\n+    where\n+        P: FnMut(&Self::Item) -> bool,\n+    {\n+        match fuse!(self.b.rfind(&mut predicate)) {\n+            None => fuse!(self.a.rfind(predicate)),\n+            item => item,\n+        }\n+    }\n+\n+    fn try_rfold<Acc, F, R>(&mut self, mut acc: Acc, mut f: F) -> R\n     where\n         Self: Sized,\n         F: FnMut(Acc, Self::Item) -> R,\n         R: Try<Ok = Acc>,\n     {\n-        let mut accum = init;\n-        match self.state {\n-            ChainState::Both | ChainState::Back => {\n-                accum = self.b.try_rfold(accum, &mut f)?;\n-                if let ChainState::Both = self.state {\n-                    self.state = ChainState::Front;\n-                }\n-            }\n-            _ => {}\n+        if let Some(ref mut b) = self.b {\n+            acc = b.try_rfold(acc, &mut f)?;\n+            self.b = None;\n         }\n-        if let ChainState::Front = self.state {\n-            accum = self.a.try_rfold(accum, &mut f)?;\n+        if let Some(ref mut a) = self.a {\n+            acc = a.try_rfold(acc, f)?;\n+            self.a = None;\n         }\n-        Try::from_ok(accum)\n+        Try::from_ok(acc)\n     }\n \n-    fn rfold<Acc, F>(self, init: Acc, mut f: F) -> Acc\n+    fn rfold<Acc, F>(self, mut acc: Acc, mut f: F) -> Acc\n     where\n         F: FnMut(Acc, Self::Item) -> Acc,\n     {\n-        let mut accum = init;\n-        match self.state {\n-            ChainState::Both | ChainState::Back => {\n-                accum = self.b.rfold(accum, &mut f);\n-            }\n-            _ => {}\n+        if let Some(b) = self.b {\n+            acc = b.rfold(acc, &mut f);\n         }\n-        match self.state {\n-            ChainState::Both | ChainState::Front => {\n-                accum = self.a.rfold(accum, &mut f);\n-            }\n-            _ => {}\n+        if let Some(a) = self.a {\n+            acc = a.rfold(acc, f);\n         }\n-        accum\n+        acc\n     }\n }\n \n // Note: *both* must be fused to handle double-ended iterators.\n+// Now that we \"fuse\" both sides, we *could* implement this unconditionally,\n+// but we should be cautious about committing to that in the public API.\n #[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<A, B> FusedIterator for Chain<A, B>\n where"}]}