{"sha": "eeceff317964af160fb785578d2d5666d9c3efe7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVlY2VmZjMxNzk2NGFmMTYwZmI3ODU1NzhkMmQ1NjY2ZDljM2VmZTc=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-01-09T20:07:32Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-01-09T20:07:32Z"}, "message": "Refactor highlighting", "tree": {"sha": "36a2142b0898a347e052bf5721896c90ef0f9fee", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/36a2142b0898a347e052bf5721896c90ef0f9fee"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eeceff317964af160fb785578d2d5666d9c3efe7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eeceff317964af160fb785578d2d5666d9c3efe7", "html_url": "https://github.com/rust-lang/rust/commit/eeceff317964af160fb785578d2d5666d9c3efe7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eeceff317964af160fb785578d2d5666d9c3efe7/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "927657432e77bc971f2b853dec7b98b909351541", "url": "https://api.github.com/repos/rust-lang/rust/commits/927657432e77bc971f2b853dec7b98b909351541", "html_url": "https://github.com/rust-lang/rust/commit/927657432e77bc971f2b853dec7b98b909351541"}], "stats": {"total": 1079, "additions": 551, "deletions": 528}, "files": [{"sha": "b82e3775e1dbb841aa319fdc5627649dc38b2b5c", "filename": "crates/ide/src/syntax_highlighting.rs", "status": "modified", "additions": 33, "deletions": 527, "changes": 560, "blob_url": "https://github.com/rust-lang/rust/blob/eeceff317964af160fb785578d2d5666d9c3efe7/crates%2Fide%2Fsrc%2Fsyntax_highlighting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeceff317964af160fb785578d2d5666d9c3efe7/crates%2Fide%2Fsrc%2Fsyntax_highlighting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting.rs?ref=eeceff317964af160fb785578d2d5666d9c3efe7", "patch": "@@ -3,30 +3,29 @@ pub(crate) mod tags;\n mod highlights;\n mod injector;\n \n+mod highlight;\n mod format;\n-mod inject;\n mod macro_rules;\n+mod inject;\n \n mod html;\n #[cfg(test)]\n mod tests;\n \n-use hir::{AsAssocItem, Local, Name, Semantics, VariantDef};\n-use ide_db::{\n-    defs::{Definition, NameClass, NameRefClass},\n-    RootDatabase,\n-};\n+use hir::{Name, Semantics};\n+use ide_db::RootDatabase;\n use rustc_hash::FxHashMap;\n use syntax::{\n     ast::{self, HasFormatSpecifier},\n-    AstNode, AstToken, Direction, NodeOrToken, SyntaxElement,\n-    SyntaxKind::{self, *},\n-    SyntaxNode, SyntaxToken, TextRange, WalkEvent, T,\n+    AstNode, AstToken, Direction, NodeOrToken,\n+    SyntaxKind::*,\n+    SyntaxNode, TextRange, WalkEvent, T,\n };\n \n use crate::{\n     syntax_highlighting::{\n-        format::FormatStringHighlighter, macro_rules::MacroRulesHighlighter, tags::Highlight,\n+        format::FormatStringHighlighter, highlights::Highlights,\n+        macro_rules::MacroRulesHighlighter, tags::Highlight,\n     },\n     FileId, HlMod, HlTag, SymbolKind,\n };\n@@ -73,8 +72,19 @@ pub(crate) fn highlight(\n         }\n     };\n \n-    let mut bindings_shadow_count: FxHashMap<Name, u32> = FxHashMap::default();\n     let mut hl = highlights::Highlights::new(range_to_highlight);\n+    traverse(&mut hl, &sema, &root, range_to_highlight, syntactic_name_ref_highlighting);\n+    hl.to_vec()\n+}\n+\n+fn traverse(\n+    hl: &mut Highlights,\n+    sema: &Semantics<RootDatabase>,\n+    root: &SyntaxNode,\n+    range_to_highlight: TextRange,\n+    syntactic_name_ref_highlighting: bool,\n+) {\n+    let mut bindings_shadow_count: FxHashMap<Name, u32> = FxHashMap::default();\n \n     let mut current_macro_call: Option<ast::MacroCall> = None;\n     let mut current_macro_rules: Option<ast::MacroRules> = None;\n@@ -128,24 +138,24 @@ pub(crate) fn highlight(\n             }\n             _ => (),\n         }\n-\n         match &event {\n-            // Check for Rust code in documentation\n-            WalkEvent::Leave(NodeOrToken::Node(node)) => {\n-                if ast::Attr::can_cast(node.kind()) {\n-                    inside_attribute = false\n-                }\n-                inject::doc_comment(&mut hl, node);\n-            }\n             WalkEvent::Enter(NodeOrToken::Node(node)) if ast::Attr::can_cast(node.kind()) => {\n                 inside_attribute = true\n             }\n+            WalkEvent::Leave(NodeOrToken::Node(node)) if ast::Attr::can_cast(node.kind()) => {\n+                inside_attribute = false\n+            }\n             _ => (),\n         }\n \n         let element = match event {\n             WalkEvent::Enter(it) => it,\n-            WalkEvent::Leave(_) => continue,\n+            WalkEvent::Leave(it) => {\n+                if let Some(node) = it.as_node() {\n+                    inject::doc_comment(hl, node);\n+                }\n+                continue;\n+            }\n         };\n \n         let range = element.text_range();\n@@ -179,13 +189,13 @@ pub(crate) fn highlight(\n         if let Some(token) = element.as_token().cloned().and_then(ast::String::cast) {\n             if token.is_raw() {\n                 let expanded = element_to_highlight.as_token().unwrap().clone();\n-                if inject::ra_fixture(&mut hl, &sema, token, expanded).is_some() {\n+                if inject::ra_fixture(hl, &sema, token, expanded).is_some() {\n                     continue;\n                 }\n             }\n         }\n \n-        if let Some((mut highlight, binding_hash)) = highlight_element(\n+        if let Some((mut highlight, binding_hash)) = highlight::element(\n             &sema,\n             &mut bindings_shadow_count,\n             syntactic_name_ref_highlighting,\n@@ -202,7 +212,7 @@ pub(crate) fn highlight(\n             if let Some(string) =\n                 element_to_highlight.as_token().cloned().and_then(ast::String::cast)\n             {\n-                format_string_highlighter.highlight_format_string(&mut hl, &string, range);\n+                format_string_highlighter.highlight_format_string(hl, &string, range);\n                 // Highlight escape sequences\n                 if let Some(char_ranges) = string.char_ranges() {\n                     for (piece_range, _) in char_ranges.iter().filter(|(_, char)| char.is_ok()) {\n@@ -218,8 +228,6 @@ pub(crate) fn highlight(\n             }\n         }\n     }\n-\n-    hl.to_vec()\n }\n \n fn macro_call_range(macro_call: &ast::MacroCall) -> Option<TextRange> {\n@@ -237,505 +245,3 @@ fn macro_call_range(macro_call: &ast::MacroCall) -> Option<TextRange> {\n \n     Some(TextRange::new(range_start, range_end))\n }\n-\n-/// Returns true if the parent nodes of `node` all match the `SyntaxKind`s in `kinds` exactly.\n-fn parents_match(mut node: NodeOrToken<SyntaxNode, SyntaxToken>, mut kinds: &[SyntaxKind]) -> bool {\n-    while let (Some(parent), [kind, rest @ ..]) = (&node.parent(), kinds) {\n-        if parent.kind() != *kind {\n-            return false;\n-        }\n-\n-        // FIXME: Would be nice to get parent out of the match, but binding by-move and by-value\n-        // in the same pattern is unstable: rust-lang/rust#68354.\n-        node = node.parent().unwrap().into();\n-        kinds = rest;\n-    }\n-\n-    // Only true if we matched all expected kinds\n-    kinds.len() == 0\n-}\n-\n-fn is_consumed_lvalue(\n-    node: NodeOrToken<SyntaxNode, SyntaxToken>,\n-    local: &Local,\n-    db: &RootDatabase,\n-) -> bool {\n-    // When lvalues are passed as arguments and they're not Copy, then mark them as Consuming.\n-    parents_match(node, &[PATH_SEGMENT, PATH, PATH_EXPR, ARG_LIST]) && !local.ty(db).is_copy(db)\n-}\n-\n-fn highlight_element(\n-    sema: &Semantics<RootDatabase>,\n-    bindings_shadow_count: &mut FxHashMap<Name, u32>,\n-    syntactic_name_ref_highlighting: bool,\n-    element: SyntaxElement,\n-) -> Option<(Highlight, Option<u64>)> {\n-    let db = sema.db;\n-    let mut binding_hash = None;\n-    let highlight: Highlight = match element.kind() {\n-        FN => {\n-            bindings_shadow_count.clear();\n-            return None;\n-        }\n-\n-        // Highlight definitions depending on the \"type\" of the definition.\n-        NAME => {\n-            let name = element.into_node().and_then(ast::Name::cast).unwrap();\n-            let name_kind = NameClass::classify(sema, &name);\n-\n-            if let Some(NameClass::Definition(Definition::Local(local))) = &name_kind {\n-                if let Some(name) = local.name(db) {\n-                    let shadow_count = bindings_shadow_count.entry(name.clone()).or_default();\n-                    *shadow_count += 1;\n-                    binding_hash = Some(calc_binding_hash(&name, *shadow_count))\n-                }\n-            };\n-\n-            match name_kind {\n-                Some(NameClass::ExternCrate(_)) => HlTag::Symbol(SymbolKind::Module).into(),\n-                Some(NameClass::Definition(def)) => highlight_def(db, def) | HlMod::Definition,\n-                Some(NameClass::ConstReference(def)) => highlight_def(db, def),\n-                Some(NameClass::PatFieldShorthand { field_ref, .. }) => {\n-                    let mut h = HlTag::Symbol(SymbolKind::Field).into();\n-                    if let Definition::Field(field) = field_ref {\n-                        if let VariantDef::Union(_) = field.parent_def(db) {\n-                            h |= HlMod::Unsafe;\n-                        }\n-                    }\n-\n-                    h\n-                }\n-                None => highlight_name_by_syntax(name) | HlMod::Definition,\n-            }\n-        }\n-\n-        // Highlight references like the definitions they resolve to\n-        NAME_REF if element.ancestors().any(|it| it.kind() == ATTR) => {\n-            // even though we track whether we are in an attribute or not we still need this special case\n-            // as otherwise we would emit unresolved references for name refs inside attributes\n-            Highlight::from(HlTag::Symbol(SymbolKind::Function))\n-        }\n-        NAME_REF => {\n-            let name_ref = element.into_node().and_then(ast::NameRef::cast).unwrap();\n-            highlight_func_by_name_ref(sema, &name_ref).unwrap_or_else(|| {\n-                match NameRefClass::classify(sema, &name_ref) {\n-                    Some(name_kind) => match name_kind {\n-                        NameRefClass::ExternCrate(_) => HlTag::Symbol(SymbolKind::Module).into(),\n-                        NameRefClass::Definition(def) => {\n-                            if let Definition::Local(local) = &def {\n-                                if let Some(name) = local.name(db) {\n-                                    let shadow_count =\n-                                        bindings_shadow_count.entry(name.clone()).or_default();\n-                                    binding_hash = Some(calc_binding_hash(&name, *shadow_count))\n-                                }\n-                            };\n-\n-                            let mut h = highlight_def(db, def);\n-\n-                            if let Definition::Local(local) = &def {\n-                                if is_consumed_lvalue(name_ref.syntax().clone().into(), local, db) {\n-                                    h |= HlMod::Consuming;\n-                                }\n-                            }\n-\n-                            if let Some(parent) = name_ref.syntax().parent() {\n-                                if matches!(parent.kind(), FIELD_EXPR | RECORD_PAT_FIELD) {\n-                                    if let Definition::Field(field) = def {\n-                                        if let VariantDef::Union(_) = field.parent_def(db) {\n-                                            h |= HlMod::Unsafe;\n-                                        }\n-                                    }\n-                                }\n-                            }\n-\n-                            h\n-                        }\n-                        NameRefClass::FieldShorthand { .. } => {\n-                            HlTag::Symbol(SymbolKind::Field).into()\n-                        }\n-                    },\n-                    None if syntactic_name_ref_highlighting => {\n-                        highlight_name_ref_by_syntax(name_ref, sema)\n-                    }\n-                    None => HlTag::UnresolvedReference.into(),\n-                }\n-            })\n-        }\n-\n-        // Simple token-based highlighting\n-        COMMENT => {\n-            let comment = element.into_token().and_then(ast::Comment::cast)?;\n-            let h = HlTag::Comment;\n-            match comment.kind().doc {\n-                Some(_) => h | HlMod::Documentation,\n-                None => h.into(),\n-            }\n-        }\n-        STRING | BYTE_STRING => HlTag::StringLiteral.into(),\n-        ATTR => HlTag::Attribute.into(),\n-        INT_NUMBER | FLOAT_NUMBER => HlTag::NumericLiteral.into(),\n-        BYTE => HlTag::ByteLiteral.into(),\n-        CHAR => HlTag::CharLiteral.into(),\n-        QUESTION => Highlight::new(HlTag::Operator) | HlMod::ControlFlow,\n-        LIFETIME => {\n-            let lifetime = element.into_node().and_then(ast::Lifetime::cast).unwrap();\n-\n-            match NameClass::classify_lifetime(sema, &lifetime) {\n-                Some(NameClass::Definition(def)) => highlight_def(db, def) | HlMod::Definition,\n-                None => match NameRefClass::classify_lifetime(sema, &lifetime) {\n-                    Some(NameRefClass::Definition(def)) => highlight_def(db, def),\n-                    _ => Highlight::new(HlTag::Symbol(SymbolKind::LifetimeParam)),\n-                },\n-                _ => Highlight::new(HlTag::Symbol(SymbolKind::LifetimeParam)) | HlMod::Definition,\n-            }\n-        }\n-        p if p.is_punct() => match p {\n-            T![&] => {\n-                let h = HlTag::Operator.into();\n-                let is_unsafe = element\n-                    .parent()\n-                    .and_then(ast::RefExpr::cast)\n-                    .map(|ref_expr| sema.is_unsafe_ref_expr(&ref_expr))\n-                    .unwrap_or(false);\n-                if is_unsafe {\n-                    h | HlMod::Unsafe\n-                } else {\n-                    h\n-                }\n-            }\n-            T![::] | T![->] | T![=>] | T![..] | T![=] | T![@] | T![.] => HlTag::Operator.into(),\n-            T![!] if element.parent().and_then(ast::MacroCall::cast).is_some() => {\n-                HlTag::Symbol(SymbolKind::Macro).into()\n-            }\n-            T![!] if element.parent().and_then(ast::NeverType::cast).is_some() => {\n-                HlTag::BuiltinType.into()\n-            }\n-            T![*] if element.parent().and_then(ast::PtrType::cast).is_some() => {\n-                HlTag::Keyword.into()\n-            }\n-            T![*] if element.parent().and_then(ast::PrefixExpr::cast).is_some() => {\n-                let prefix_expr = element.parent().and_then(ast::PrefixExpr::cast)?;\n-\n-                let expr = prefix_expr.expr()?;\n-                let ty = sema.type_of_expr(&expr)?;\n-                if ty.is_raw_ptr() {\n-                    HlTag::Operator | HlMod::Unsafe\n-                } else if let Some(ast::PrefixOp::Deref) = prefix_expr.op_kind() {\n-                    HlTag::Operator.into()\n-                } else {\n-                    HlTag::Punctuation.into()\n-                }\n-            }\n-            T![-] if element.parent().and_then(ast::PrefixExpr::cast).is_some() => {\n-                let prefix_expr = element.parent().and_then(ast::PrefixExpr::cast)?;\n-\n-                let expr = prefix_expr.expr()?;\n-                match expr {\n-                    ast::Expr::Literal(_) => HlTag::NumericLiteral,\n-                    _ => HlTag::Operator,\n-                }\n-                .into()\n-            }\n-            _ if element.parent().and_then(ast::PrefixExpr::cast).is_some() => {\n-                HlTag::Operator.into()\n-            }\n-            _ if element.parent().and_then(ast::BinExpr::cast).is_some() => HlTag::Operator.into(),\n-            _ if element.parent().and_then(ast::RangeExpr::cast).is_some() => {\n-                HlTag::Operator.into()\n-            }\n-            _ if element.parent().and_then(ast::RangePat::cast).is_some() => HlTag::Operator.into(),\n-            _ if element.parent().and_then(ast::RestPat::cast).is_some() => HlTag::Operator.into(),\n-            _ if element.parent().and_then(ast::Attr::cast).is_some() => HlTag::Attribute.into(),\n-            _ => HlTag::Punctuation.into(),\n-        },\n-\n-        k if k.is_keyword() => {\n-            let h = Highlight::new(HlTag::Keyword);\n-            match k {\n-                T![break]\n-                | T![continue]\n-                | T![else]\n-                | T![if]\n-                | T![loop]\n-                | T![match]\n-                | T![return]\n-                | T![while]\n-                | T![in] => h | HlMod::ControlFlow,\n-                T![for] if !is_child_of_impl(&element) => h | HlMod::ControlFlow,\n-                T![unsafe] => h | HlMod::Unsafe,\n-                T![true] | T![false] => HlTag::BoolLiteral.into(),\n-                T![self] => {\n-                    let self_param_is_mut = element\n-                        .parent()\n-                        .and_then(ast::SelfParam::cast)\n-                        .and_then(|p| p.mut_token())\n-                        .is_some();\n-                    let self_path = &element\n-                        .parent()\n-                        .as_ref()\n-                        .and_then(SyntaxNode::parent)\n-                        .and_then(ast::Path::cast)\n-                        .and_then(|p| sema.resolve_path(&p));\n-                    let mut h = HlTag::Symbol(SymbolKind::SelfParam).into();\n-                    if self_param_is_mut\n-                        || matches!(self_path,\n-                            Some(hir::PathResolution::Local(local))\n-                                if local.is_self(db)\n-                                    && (local.is_mut(db) || local.ty(db).is_mutable_reference())\n-                        )\n-                    {\n-                        h |= HlMod::Mutable\n-                    }\n-\n-                    if let Some(hir::PathResolution::Local(local)) = self_path {\n-                        if is_consumed_lvalue(element, &local, db) {\n-                            h |= HlMod::Consuming;\n-                        }\n-                    }\n-\n-                    h\n-                }\n-                T![ref] => element\n-                    .parent()\n-                    .and_then(ast::IdentPat::cast)\n-                    .and_then(|ident_pat| {\n-                        if sema.is_unsafe_ident_pat(&ident_pat) {\n-                            Some(HlMod::Unsafe)\n-                        } else {\n-                            None\n-                        }\n-                    })\n-                    .map(|modifier| h | modifier)\n-                    .unwrap_or(h),\n-                _ => h,\n-            }\n-        }\n-\n-        _ => return None,\n-    };\n-\n-    return Some((highlight, binding_hash));\n-\n-    fn calc_binding_hash(name: &Name, shadow_count: u32) -> u64 {\n-        fn hash<T: std::hash::Hash + std::fmt::Debug>(x: T) -> u64 {\n-            use std::{collections::hash_map::DefaultHasher, hash::Hasher};\n-\n-            let mut hasher = DefaultHasher::new();\n-            x.hash(&mut hasher);\n-            hasher.finish()\n-        }\n-\n-        hash((name, shadow_count))\n-    }\n-}\n-\n-fn is_child_of_impl(element: &SyntaxElement) -> bool {\n-    match element.parent() {\n-        Some(e) => e.kind() == IMPL,\n-        _ => false,\n-    }\n-}\n-\n-fn highlight_func_by_name_ref(\n-    sema: &Semantics<RootDatabase>,\n-    name_ref: &ast::NameRef,\n-) -> Option<Highlight> {\n-    let method_call = name_ref.syntax().parent().and_then(ast::MethodCallExpr::cast)?;\n-    highlight_method_call(sema, &method_call)\n-}\n-\n-fn highlight_method_call(\n-    sema: &Semantics<RootDatabase>,\n-    method_call: &ast::MethodCallExpr,\n-) -> Option<Highlight> {\n-    let func = sema.resolve_method_call(&method_call)?;\n-    let mut h = HlTag::Symbol(SymbolKind::Function).into();\n-    h |= HlMod::Associated;\n-    if func.is_unsafe(sema.db) || sema.is_unsafe_method_call(&method_call) {\n-        h |= HlMod::Unsafe;\n-    }\n-    if let Some(self_param) = func.self_param(sema.db) {\n-        match self_param.access(sema.db) {\n-            hir::Access::Shared => (),\n-            hir::Access::Exclusive => h |= HlMod::Mutable,\n-            hir::Access::Owned => {\n-                if let Some(receiver_ty) =\n-                    method_call.receiver().and_then(|it| sema.type_of_expr(&it))\n-                {\n-                    if !receiver_ty.is_copy(sema.db) {\n-                        h |= HlMod::Consuming\n-                    }\n-                }\n-            }\n-        }\n-    }\n-    Some(h)\n-}\n-\n-fn highlight_def(db: &RootDatabase, def: Definition) -> Highlight {\n-    match def {\n-        Definition::Macro(_) => HlTag::Symbol(SymbolKind::Macro),\n-        Definition::Field(_) => HlTag::Symbol(SymbolKind::Field),\n-        Definition::ModuleDef(def) => match def {\n-            hir::ModuleDef::Module(_) => HlTag::Symbol(SymbolKind::Module),\n-            hir::ModuleDef::Function(func) => {\n-                let mut h = Highlight::new(HlTag::Symbol(SymbolKind::Function));\n-                if func.as_assoc_item(db).is_some() {\n-                    h |= HlMod::Associated;\n-                    if func.self_param(db).is_none() {\n-                        h |= HlMod::Static\n-                    }\n-                }\n-                if func.is_unsafe(db) {\n-                    h |= HlMod::Unsafe;\n-                }\n-                return h;\n-            }\n-            hir::ModuleDef::Adt(hir::Adt::Struct(_)) => HlTag::Symbol(SymbolKind::Struct),\n-            hir::ModuleDef::Adt(hir::Adt::Enum(_)) => HlTag::Symbol(SymbolKind::Enum),\n-            hir::ModuleDef::Adt(hir::Adt::Union(_)) => HlTag::Symbol(SymbolKind::Union),\n-            hir::ModuleDef::Variant(_) => HlTag::Symbol(SymbolKind::Variant),\n-            hir::ModuleDef::Const(konst) => {\n-                let mut h = Highlight::new(HlTag::Symbol(SymbolKind::Const));\n-                if konst.as_assoc_item(db).is_some() {\n-                    h |= HlMod::Associated\n-                }\n-                return h;\n-            }\n-            hir::ModuleDef::Trait(_) => HlTag::Symbol(SymbolKind::Trait),\n-            hir::ModuleDef::TypeAlias(type_) => {\n-                let mut h = Highlight::new(HlTag::Symbol(SymbolKind::TypeAlias));\n-                if type_.as_assoc_item(db).is_some() {\n-                    h |= HlMod::Associated\n-                }\n-                return h;\n-            }\n-            hir::ModuleDef::BuiltinType(_) => HlTag::BuiltinType,\n-            hir::ModuleDef::Static(s) => {\n-                let mut h = Highlight::new(HlTag::Symbol(SymbolKind::Static));\n-                if s.is_mut(db) {\n-                    h |= HlMod::Mutable;\n-                    h |= HlMod::Unsafe;\n-                }\n-                return h;\n-            }\n-        },\n-        Definition::SelfType(_) => HlTag::Symbol(SymbolKind::Impl),\n-        Definition::TypeParam(_) => HlTag::Symbol(SymbolKind::TypeParam),\n-        Definition::ConstParam(_) => HlTag::Symbol(SymbolKind::ConstParam),\n-        Definition::Local(local) => {\n-            let tag = if local.is_param(db) {\n-                HlTag::Symbol(SymbolKind::ValueParam)\n-            } else {\n-                HlTag::Symbol(SymbolKind::Local)\n-            };\n-            let mut h = Highlight::new(tag);\n-            if local.is_mut(db) || local.ty(db).is_mutable_reference() {\n-                h |= HlMod::Mutable;\n-            }\n-            if local.ty(db).as_callable(db).is_some() || local.ty(db).impls_fnonce(db) {\n-                h |= HlMod::Callable;\n-            }\n-            return h;\n-        }\n-        Definition::LifetimeParam(_) => HlTag::Symbol(SymbolKind::LifetimeParam),\n-        Definition::Label(_) => HlTag::Symbol(SymbolKind::Label),\n-    }\n-    .into()\n-}\n-\n-fn highlight_name_by_syntax(name: ast::Name) -> Highlight {\n-    let default = HlTag::UnresolvedReference;\n-\n-    let parent = match name.syntax().parent() {\n-        Some(it) => it,\n-        _ => return default.into(),\n-    };\n-\n-    let tag = match parent.kind() {\n-        STRUCT => HlTag::Symbol(SymbolKind::Struct),\n-        ENUM => HlTag::Symbol(SymbolKind::Enum),\n-        VARIANT => HlTag::Symbol(SymbolKind::Variant),\n-        UNION => HlTag::Symbol(SymbolKind::Union),\n-        TRAIT => HlTag::Symbol(SymbolKind::Trait),\n-        TYPE_ALIAS => HlTag::Symbol(SymbolKind::TypeAlias),\n-        TYPE_PARAM => HlTag::Symbol(SymbolKind::TypeParam),\n-        RECORD_FIELD => HlTag::Symbol(SymbolKind::Field),\n-        MODULE => HlTag::Symbol(SymbolKind::Module),\n-        FN => HlTag::Symbol(SymbolKind::Function),\n-        CONST => HlTag::Symbol(SymbolKind::Const),\n-        STATIC => HlTag::Symbol(SymbolKind::Static),\n-        IDENT_PAT => HlTag::Symbol(SymbolKind::Local),\n-        _ => default,\n-    };\n-\n-    tag.into()\n-}\n-\n-fn highlight_name_ref_by_syntax(name: ast::NameRef, sema: &Semantics<RootDatabase>) -> Highlight {\n-    let default = HlTag::UnresolvedReference;\n-\n-    let parent = match name.syntax().parent() {\n-        Some(it) => it,\n-        _ => return default.into(),\n-    };\n-\n-    match parent.kind() {\n-        METHOD_CALL_EXPR => {\n-            return ast::MethodCallExpr::cast(parent)\n-                .and_then(|method_call| highlight_method_call(sema, &method_call))\n-                .unwrap_or_else(|| HlTag::Symbol(SymbolKind::Function).into());\n-        }\n-        FIELD_EXPR => {\n-            let h = HlTag::Symbol(SymbolKind::Field);\n-            let is_union = ast::FieldExpr::cast(parent)\n-                .and_then(|field_expr| {\n-                    let field = sema.resolve_field(&field_expr)?;\n-                    Some(if let VariantDef::Union(_) = field.parent_def(sema.db) {\n-                        true\n-                    } else {\n-                        false\n-                    })\n-                })\n-                .unwrap_or(false);\n-            if is_union {\n-                h | HlMod::Unsafe\n-            } else {\n-                h.into()\n-            }\n-        }\n-        PATH_SEGMENT => {\n-            let path = match parent.parent().and_then(ast::Path::cast) {\n-                Some(it) => it,\n-                _ => return default.into(),\n-            };\n-            let expr = match path.syntax().parent().and_then(ast::PathExpr::cast) {\n-                Some(it) => it,\n-                _ => {\n-                    // within path, decide whether it is module or adt by checking for uppercase name\n-                    return if name.text().chars().next().unwrap_or_default().is_uppercase() {\n-                        HlTag::Symbol(SymbolKind::Struct)\n-                    } else {\n-                        HlTag::Symbol(SymbolKind::Module)\n-                    }\n-                    .into();\n-                }\n-            };\n-            let parent = match expr.syntax().parent() {\n-                Some(it) => it,\n-                None => return default.into(),\n-            };\n-\n-            match parent.kind() {\n-                CALL_EXPR => HlTag::Symbol(SymbolKind::Function).into(),\n-                _ => if name.text().chars().next().unwrap_or_default().is_uppercase() {\n-                    HlTag::Symbol(SymbolKind::Struct)\n-                } else {\n-                    HlTag::Symbol(SymbolKind::Const)\n-                }\n-                .into(),\n-            }\n-        }\n-        _ => default.into(),\n-    }\n-}"}, {"sha": "1a88975d2c36304c1a565286ac212dfdcf5099ad", "filename": "crates/ide/src/syntax_highlighting/highlight.rs", "status": "added", "additions": 517, "deletions": 0, "changes": 517, "blob_url": "https://github.com/rust-lang/rust/blob/eeceff317964af160fb785578d2d5666d9c3efe7/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeceff317964af160fb785578d2d5666d9c3efe7/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Fhighlight.rs?ref=eeceff317964af160fb785578d2d5666d9c3efe7", "patch": "@@ -0,0 +1,517 @@\n+//! Computes color for a single element.\n+\n+use hir::{AsAssocItem, Semantics, VariantDef};\n+use ide_db::{\n+    defs::{Definition, NameClass, NameRefClass},\n+    RootDatabase,\n+};\n+use rustc_hash::FxHashMap;\n+use syntax::{\n+    ast, AstNode, AstToken, NodeOrToken, SyntaxElement,\n+    SyntaxKind::{self, *},\n+    SyntaxNode, SyntaxToken, T,\n+};\n+\n+use crate::{Highlight, HlMod, HlTag, SymbolKind};\n+\n+pub(super) fn element(\n+    sema: &Semantics<RootDatabase>,\n+    bindings_shadow_count: &mut FxHashMap<hir::Name, u32>,\n+    syntactic_name_ref_highlighting: bool,\n+    element: SyntaxElement,\n+) -> Option<(Highlight, Option<u64>)> {\n+    let db = sema.db;\n+    let mut binding_hash = None;\n+    let highlight: Highlight = match element.kind() {\n+        FN => {\n+            bindings_shadow_count.clear();\n+            return None;\n+        }\n+\n+        // Highlight definitions depending on the \"type\" of the definition.\n+        NAME => {\n+            let name = element.into_node().and_then(ast::Name::cast).unwrap();\n+            let name_kind = NameClass::classify(sema, &name);\n+\n+            if let Some(NameClass::Definition(Definition::Local(local))) = &name_kind {\n+                if let Some(name) = local.name(db) {\n+                    let shadow_count = bindings_shadow_count.entry(name.clone()).or_default();\n+                    *shadow_count += 1;\n+                    binding_hash = Some(calc_binding_hash(&name, *shadow_count))\n+                }\n+            };\n+\n+            match name_kind {\n+                Some(NameClass::ExternCrate(_)) => HlTag::Symbol(SymbolKind::Module).into(),\n+                Some(NameClass::Definition(def)) => highlight_def(db, def) | HlMod::Definition,\n+                Some(NameClass::ConstReference(def)) => highlight_def(db, def),\n+                Some(NameClass::PatFieldShorthand { field_ref, .. }) => {\n+                    let mut h = HlTag::Symbol(SymbolKind::Field).into();\n+                    if let Definition::Field(field) = field_ref {\n+                        if let VariantDef::Union(_) = field.parent_def(db) {\n+                            h |= HlMod::Unsafe;\n+                        }\n+                    }\n+\n+                    h\n+                }\n+                None => highlight_name_by_syntax(name) | HlMod::Definition,\n+            }\n+        }\n+\n+        // Highlight references like the definitions they resolve to\n+        NAME_REF if element.ancestors().any(|it| it.kind() == ATTR) => {\n+            // even though we track whether we are in an attribute or not we still need this special case\n+            // as otherwise we would emit unresolved references for name refs inside attributes\n+            Highlight::from(HlTag::Symbol(SymbolKind::Function))\n+        }\n+        NAME_REF => {\n+            let name_ref = element.into_node().and_then(ast::NameRef::cast).unwrap();\n+            highlight_func_by_name_ref(sema, &name_ref).unwrap_or_else(|| {\n+                match NameRefClass::classify(sema, &name_ref) {\n+                    Some(name_kind) => match name_kind {\n+                        NameRefClass::ExternCrate(_) => HlTag::Symbol(SymbolKind::Module).into(),\n+                        NameRefClass::Definition(def) => {\n+                            if let Definition::Local(local) = &def {\n+                                if let Some(name) = local.name(db) {\n+                                    let shadow_count =\n+                                        bindings_shadow_count.entry(name.clone()).or_default();\n+                                    binding_hash = Some(calc_binding_hash(&name, *shadow_count))\n+                                }\n+                            };\n+\n+                            let mut h = highlight_def(db, def);\n+\n+                            if let Definition::Local(local) = &def {\n+                                if is_consumed_lvalue(name_ref.syntax().clone().into(), local, db) {\n+                                    h |= HlMod::Consuming;\n+                                }\n+                            }\n+\n+                            if let Some(parent) = name_ref.syntax().parent() {\n+                                if matches!(parent.kind(), FIELD_EXPR | RECORD_PAT_FIELD) {\n+                                    if let Definition::Field(field) = def {\n+                                        if let VariantDef::Union(_) = field.parent_def(db) {\n+                                            h |= HlMod::Unsafe;\n+                                        }\n+                                    }\n+                                }\n+                            }\n+\n+                            h\n+                        }\n+                        NameRefClass::FieldShorthand { .. } => {\n+                            HlTag::Symbol(SymbolKind::Field).into()\n+                        }\n+                    },\n+                    None if syntactic_name_ref_highlighting => {\n+                        highlight_name_ref_by_syntax(name_ref, sema)\n+                    }\n+                    None => HlTag::UnresolvedReference.into(),\n+                }\n+            })\n+        }\n+\n+        // Simple token-based highlighting\n+        COMMENT => {\n+            let comment = element.into_token().and_then(ast::Comment::cast)?;\n+            let h = HlTag::Comment;\n+            match comment.kind().doc {\n+                Some(_) => h | HlMod::Documentation,\n+                None => h.into(),\n+            }\n+        }\n+        STRING | BYTE_STRING => HlTag::StringLiteral.into(),\n+        ATTR => HlTag::Attribute.into(),\n+        INT_NUMBER | FLOAT_NUMBER => HlTag::NumericLiteral.into(),\n+        BYTE => HlTag::ByteLiteral.into(),\n+        CHAR => HlTag::CharLiteral.into(),\n+        QUESTION => Highlight::new(HlTag::Operator) | HlMod::ControlFlow,\n+        LIFETIME => {\n+            let lifetime = element.into_node().and_then(ast::Lifetime::cast).unwrap();\n+\n+            match NameClass::classify_lifetime(sema, &lifetime) {\n+                Some(NameClass::Definition(def)) => highlight_def(db, def) | HlMod::Definition,\n+                None => match NameRefClass::classify_lifetime(sema, &lifetime) {\n+                    Some(NameRefClass::Definition(def)) => highlight_def(db, def),\n+                    _ => Highlight::new(HlTag::Symbol(SymbolKind::LifetimeParam)),\n+                },\n+                _ => Highlight::new(HlTag::Symbol(SymbolKind::LifetimeParam)) | HlMod::Definition,\n+            }\n+        }\n+        p if p.is_punct() => match p {\n+            T![&] => {\n+                let h = HlTag::Operator.into();\n+                let is_unsafe = element\n+                    .parent()\n+                    .and_then(ast::RefExpr::cast)\n+                    .map(|ref_expr| sema.is_unsafe_ref_expr(&ref_expr))\n+                    .unwrap_or(false);\n+                if is_unsafe {\n+                    h | HlMod::Unsafe\n+                } else {\n+                    h\n+                }\n+            }\n+            T![::] | T![->] | T![=>] | T![..] | T![=] | T![@] | T![.] => HlTag::Operator.into(),\n+            T![!] if element.parent().and_then(ast::MacroCall::cast).is_some() => {\n+                HlTag::Symbol(SymbolKind::Macro).into()\n+            }\n+            T![!] if element.parent().and_then(ast::NeverType::cast).is_some() => {\n+                HlTag::BuiltinType.into()\n+            }\n+            T![*] if element.parent().and_then(ast::PtrType::cast).is_some() => {\n+                HlTag::Keyword.into()\n+            }\n+            T![*] if element.parent().and_then(ast::PrefixExpr::cast).is_some() => {\n+                let prefix_expr = element.parent().and_then(ast::PrefixExpr::cast)?;\n+\n+                let expr = prefix_expr.expr()?;\n+                let ty = sema.type_of_expr(&expr)?;\n+                if ty.is_raw_ptr() {\n+                    HlTag::Operator | HlMod::Unsafe\n+                } else if let Some(ast::PrefixOp::Deref) = prefix_expr.op_kind() {\n+                    HlTag::Operator.into()\n+                } else {\n+                    HlTag::Punctuation.into()\n+                }\n+            }\n+            T![-] if element.parent().and_then(ast::PrefixExpr::cast).is_some() => {\n+                let prefix_expr = element.parent().and_then(ast::PrefixExpr::cast)?;\n+\n+                let expr = prefix_expr.expr()?;\n+                match expr {\n+                    ast::Expr::Literal(_) => HlTag::NumericLiteral,\n+                    _ => HlTag::Operator,\n+                }\n+                .into()\n+            }\n+            _ if element.parent().and_then(ast::PrefixExpr::cast).is_some() => {\n+                HlTag::Operator.into()\n+            }\n+            _ if element.parent().and_then(ast::BinExpr::cast).is_some() => HlTag::Operator.into(),\n+            _ if element.parent().and_then(ast::RangeExpr::cast).is_some() => {\n+                HlTag::Operator.into()\n+            }\n+            _ if element.parent().and_then(ast::RangePat::cast).is_some() => HlTag::Operator.into(),\n+            _ if element.parent().and_then(ast::RestPat::cast).is_some() => HlTag::Operator.into(),\n+            _ if element.parent().and_then(ast::Attr::cast).is_some() => HlTag::Attribute.into(),\n+            _ => HlTag::Punctuation.into(),\n+        },\n+\n+        k if k.is_keyword() => {\n+            let h = Highlight::new(HlTag::Keyword);\n+            match k {\n+                T![break]\n+                | T![continue]\n+                | T![else]\n+                | T![if]\n+                | T![loop]\n+                | T![match]\n+                | T![return]\n+                | T![while]\n+                | T![in] => h | HlMod::ControlFlow,\n+                T![for] if !is_child_of_impl(&element) => h | HlMod::ControlFlow,\n+                T![unsafe] => h | HlMod::Unsafe,\n+                T![true] | T![false] => HlTag::BoolLiteral.into(),\n+                T![self] => {\n+                    let self_param_is_mut = element\n+                        .parent()\n+                        .and_then(ast::SelfParam::cast)\n+                        .and_then(|p| p.mut_token())\n+                        .is_some();\n+                    let self_path = &element\n+                        .parent()\n+                        .as_ref()\n+                        .and_then(SyntaxNode::parent)\n+                        .and_then(ast::Path::cast)\n+                        .and_then(|p| sema.resolve_path(&p));\n+                    let mut h = HlTag::Symbol(SymbolKind::SelfParam).into();\n+                    if self_param_is_mut\n+                        || matches!(self_path,\n+                            Some(hir::PathResolution::Local(local))\n+                                if local.is_self(db)\n+                                    && (local.is_mut(db) || local.ty(db).is_mutable_reference())\n+                        )\n+                    {\n+                        h |= HlMod::Mutable\n+                    }\n+\n+                    if let Some(hir::PathResolution::Local(local)) = self_path {\n+                        if is_consumed_lvalue(element, &local, db) {\n+                            h |= HlMod::Consuming;\n+                        }\n+                    }\n+\n+                    h\n+                }\n+                T![ref] => element\n+                    .parent()\n+                    .and_then(ast::IdentPat::cast)\n+                    .and_then(|ident_pat| {\n+                        if sema.is_unsafe_ident_pat(&ident_pat) {\n+                            Some(HlMod::Unsafe)\n+                        } else {\n+                            None\n+                        }\n+                    })\n+                    .map(|modifier| h | modifier)\n+                    .unwrap_or(h),\n+                _ => h,\n+            }\n+        }\n+\n+        _ => return None,\n+    };\n+\n+    return Some((highlight, binding_hash));\n+\n+    fn calc_binding_hash(name: &hir::Name, shadow_count: u32) -> u64 {\n+        fn hash<T: std::hash::Hash + std::fmt::Debug>(x: T) -> u64 {\n+            use std::{collections::hash_map::DefaultHasher, hash::Hasher};\n+\n+            let mut hasher = DefaultHasher::new();\n+            x.hash(&mut hasher);\n+            hasher.finish()\n+        }\n+\n+        hash((name, shadow_count))\n+    }\n+}\n+\n+fn highlight_def(db: &RootDatabase, def: Definition) -> Highlight {\n+    match def {\n+        Definition::Macro(_) => HlTag::Symbol(SymbolKind::Macro),\n+        Definition::Field(_) => HlTag::Symbol(SymbolKind::Field),\n+        Definition::ModuleDef(def) => match def {\n+            hir::ModuleDef::Module(_) => HlTag::Symbol(SymbolKind::Module),\n+            hir::ModuleDef::Function(func) => {\n+                let mut h = Highlight::new(HlTag::Symbol(SymbolKind::Function));\n+                if func.as_assoc_item(db).is_some() {\n+                    h |= HlMod::Associated;\n+                    if func.self_param(db).is_none() {\n+                        h |= HlMod::Static\n+                    }\n+                }\n+                if func.is_unsafe(db) {\n+                    h |= HlMod::Unsafe;\n+                }\n+                return h;\n+            }\n+            hir::ModuleDef::Adt(hir::Adt::Struct(_)) => HlTag::Symbol(SymbolKind::Struct),\n+            hir::ModuleDef::Adt(hir::Adt::Enum(_)) => HlTag::Symbol(SymbolKind::Enum),\n+            hir::ModuleDef::Adt(hir::Adt::Union(_)) => HlTag::Symbol(SymbolKind::Union),\n+            hir::ModuleDef::Variant(_) => HlTag::Symbol(SymbolKind::Variant),\n+            hir::ModuleDef::Const(konst) => {\n+                let mut h = Highlight::new(HlTag::Symbol(SymbolKind::Const));\n+                if konst.as_assoc_item(db).is_some() {\n+                    h |= HlMod::Associated\n+                }\n+                return h;\n+            }\n+            hir::ModuleDef::Trait(_) => HlTag::Symbol(SymbolKind::Trait),\n+            hir::ModuleDef::TypeAlias(type_) => {\n+                let mut h = Highlight::new(HlTag::Symbol(SymbolKind::TypeAlias));\n+                if type_.as_assoc_item(db).is_some() {\n+                    h |= HlMod::Associated\n+                }\n+                return h;\n+            }\n+            hir::ModuleDef::BuiltinType(_) => HlTag::BuiltinType,\n+            hir::ModuleDef::Static(s) => {\n+                let mut h = Highlight::new(HlTag::Symbol(SymbolKind::Static));\n+                if s.is_mut(db) {\n+                    h |= HlMod::Mutable;\n+                    h |= HlMod::Unsafe;\n+                }\n+                return h;\n+            }\n+        },\n+        Definition::SelfType(_) => HlTag::Symbol(SymbolKind::Impl),\n+        Definition::TypeParam(_) => HlTag::Symbol(SymbolKind::TypeParam),\n+        Definition::ConstParam(_) => HlTag::Symbol(SymbolKind::ConstParam),\n+        Definition::Local(local) => {\n+            let tag = if local.is_param(db) {\n+                HlTag::Symbol(SymbolKind::ValueParam)\n+            } else {\n+                HlTag::Symbol(SymbolKind::Local)\n+            };\n+            let mut h = Highlight::new(tag);\n+            if local.is_mut(db) || local.ty(db).is_mutable_reference() {\n+                h |= HlMod::Mutable;\n+            }\n+            if local.ty(db).as_callable(db).is_some() || local.ty(db).impls_fnonce(db) {\n+                h |= HlMod::Callable;\n+            }\n+            return h;\n+        }\n+        Definition::LifetimeParam(_) => HlTag::Symbol(SymbolKind::LifetimeParam),\n+        Definition::Label(_) => HlTag::Symbol(SymbolKind::Label),\n+    }\n+    .into()\n+}\n+\n+fn highlight_func_by_name_ref(\n+    sema: &Semantics<RootDatabase>,\n+    name_ref: &ast::NameRef,\n+) -> Option<Highlight> {\n+    let mc = name_ref.syntax().parent().and_then(ast::MethodCallExpr::cast)?;\n+    highlight_method_call(sema, &mc)\n+}\n+\n+fn highlight_method_call(\n+    sema: &Semantics<RootDatabase>,\n+    method_call: &ast::MethodCallExpr,\n+) -> Option<Highlight> {\n+    let func = sema.resolve_method_call(&method_call)?;\n+    let mut h = HlTag::Symbol(SymbolKind::Function).into();\n+    h |= HlMod::Associated;\n+    if func.is_unsafe(sema.db) || sema.is_unsafe_method_call(&method_call) {\n+        h |= HlMod::Unsafe;\n+    }\n+    if let Some(self_param) = func.self_param(sema.db) {\n+        match self_param.access(sema.db) {\n+            hir::Access::Shared => (),\n+            hir::Access::Exclusive => h |= HlMod::Mutable,\n+            hir::Access::Owned => {\n+                if let Some(receiver_ty) =\n+                    method_call.receiver().and_then(|it| sema.type_of_expr(&it))\n+                {\n+                    if !receiver_ty.is_copy(sema.db) {\n+                        h |= HlMod::Consuming\n+                    }\n+                }\n+            }\n+        }\n+    }\n+    Some(h)\n+}\n+\n+fn highlight_name_by_syntax(name: ast::Name) -> Highlight {\n+    let default = HlTag::UnresolvedReference;\n+\n+    let parent = match name.syntax().parent() {\n+        Some(it) => it,\n+        _ => return default.into(),\n+    };\n+\n+    let tag = match parent.kind() {\n+        STRUCT => HlTag::Symbol(SymbolKind::Struct),\n+        ENUM => HlTag::Symbol(SymbolKind::Enum),\n+        VARIANT => HlTag::Symbol(SymbolKind::Variant),\n+        UNION => HlTag::Symbol(SymbolKind::Union),\n+        TRAIT => HlTag::Symbol(SymbolKind::Trait),\n+        TYPE_ALIAS => HlTag::Symbol(SymbolKind::TypeAlias),\n+        TYPE_PARAM => HlTag::Symbol(SymbolKind::TypeParam),\n+        RECORD_FIELD => HlTag::Symbol(SymbolKind::Field),\n+        MODULE => HlTag::Symbol(SymbolKind::Module),\n+        FN => HlTag::Symbol(SymbolKind::Function),\n+        CONST => HlTag::Symbol(SymbolKind::Const),\n+        STATIC => HlTag::Symbol(SymbolKind::Static),\n+        IDENT_PAT => HlTag::Symbol(SymbolKind::Local),\n+        _ => default,\n+    };\n+\n+    tag.into()\n+}\n+\n+fn highlight_name_ref_by_syntax(name: ast::NameRef, sema: &Semantics<RootDatabase>) -> Highlight {\n+    let default = HlTag::UnresolvedReference;\n+\n+    let parent = match name.syntax().parent() {\n+        Some(it) => it,\n+        _ => return default.into(),\n+    };\n+\n+    match parent.kind() {\n+        METHOD_CALL_EXPR => {\n+            return ast::MethodCallExpr::cast(parent)\n+                .and_then(|it| highlight_method_call(sema, &it))\n+                .unwrap_or_else(|| HlTag::Symbol(SymbolKind::Function).into());\n+        }\n+        FIELD_EXPR => {\n+            let h = HlTag::Symbol(SymbolKind::Field);\n+            let is_union = ast::FieldExpr::cast(parent)\n+                .and_then(|field_expr| {\n+                    let field = sema.resolve_field(&field_expr)?;\n+                    Some(if let VariantDef::Union(_) = field.parent_def(sema.db) {\n+                        true\n+                    } else {\n+                        false\n+                    })\n+                })\n+                .unwrap_or(false);\n+            if is_union {\n+                h | HlMod::Unsafe\n+            } else {\n+                h.into()\n+            }\n+        }\n+        PATH_SEGMENT => {\n+            let path = match parent.parent().and_then(ast::Path::cast) {\n+                Some(it) => it,\n+                _ => return default.into(),\n+            };\n+            let expr = match path.syntax().parent().and_then(ast::PathExpr::cast) {\n+                Some(it) => it,\n+                _ => {\n+                    // within path, decide whether it is module or adt by checking for uppercase name\n+                    return if name.text().chars().next().unwrap_or_default().is_uppercase() {\n+                        HlTag::Symbol(SymbolKind::Struct)\n+                    } else {\n+                        HlTag::Symbol(SymbolKind::Module)\n+                    }\n+                    .into();\n+                }\n+            };\n+            let parent = match expr.syntax().parent() {\n+                Some(it) => it,\n+                None => return default.into(),\n+            };\n+\n+            match parent.kind() {\n+                CALL_EXPR => HlTag::Symbol(SymbolKind::Function).into(),\n+                _ => if name.text().chars().next().unwrap_or_default().is_uppercase() {\n+                    HlTag::Symbol(SymbolKind::Struct)\n+                } else {\n+                    HlTag::Symbol(SymbolKind::Const)\n+                }\n+                .into(),\n+            }\n+        }\n+        _ => default.into(),\n+    }\n+}\n+\n+fn is_consumed_lvalue(\n+    node: NodeOrToken<SyntaxNode, SyntaxToken>,\n+    local: &hir::Local,\n+    db: &RootDatabase,\n+) -> bool {\n+    // When lvalues are passed as arguments and they're not Copy, then mark them as Consuming.\n+    parents_match(node, &[PATH_SEGMENT, PATH, PATH_EXPR, ARG_LIST]) && !local.ty(db).is_copy(db)\n+}\n+\n+/// Returns true if the parent nodes of `node` all match the `SyntaxKind`s in `kinds` exactly.\n+fn parents_match(mut node: NodeOrToken<SyntaxNode, SyntaxToken>, mut kinds: &[SyntaxKind]) -> bool {\n+    while let (Some(parent), [kind, rest @ ..]) = (&node.parent(), kinds) {\n+        if parent.kind() != *kind {\n+            return false;\n+        }\n+\n+        // FIXME: Would be nice to get parent out of the match, but binding by-move and by-value\n+        // in the same pattern is unstable: rust-lang/rust#68354.\n+        node = node.parent().unwrap().into();\n+        kinds = rest;\n+    }\n+\n+    // Only true if we matched all expected kinds\n+    kinds.len() == 0\n+}\n+\n+fn is_child_of_impl(element: &SyntaxElement) -> bool {\n+    match element.parent() {\n+        Some(e) => e.kind() == IMPL,\n+        _ => false,\n+    }\n+}"}, {"sha": "281461493532386dfadca675c5ba465ea8f991c0", "filename": "crates/ide/src/syntax_highlighting/inject.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eeceff317964af160fb785578d2d5666d9c3efe7/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Finject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eeceff317964af160fb785578d2d5666d9c3efe7/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Finject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Finject.rs?ref=eeceff317964af160fb785578d2d5666d9c3efe7", "patch": "@@ -1,4 +1,4 @@\n-//! Syntax highlighting injections such as highlighting of documentation tests.\n+//! \"Recursive\" Syntax highlighting for code in doctests and fixtures.\n \n use hir::Semantics;\n use ide_db::call_info::ActiveParameter;"}]}