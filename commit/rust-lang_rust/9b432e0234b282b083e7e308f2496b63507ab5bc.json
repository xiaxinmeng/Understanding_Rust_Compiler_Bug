{"sha": "9b432e0234b282b083e7e308f2496b63507ab5bc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjliNDMyZTAyMzRiMjgyYjA4M2U3ZTMwOGYyNDk2YjYzNTA3YWI1YmM=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2021-04-22T16:14:39Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-04-22T16:14:39Z"}, "message": "Rollup merge of #84377 - jackh726:binder-refactor-fix, r=nikomatsakis\n\nFollowup to #83944\n\nSome cleanups requested by ``@nikomatsakis``\n\nr? ``@nikomatsakis``", "tree": {"sha": "ab3a669a3a363763014ae49cb0d6c3b574a2b59a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ab3a669a3a363763014ae49cb0d6c3b574a2b59a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9b432e0234b282b083e7e308f2496b63507ab5bc", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJggaDvCRBK7hj4Ov3rIwAA3v4IAG7LsXlJGG6OL3042wpQcWKq\nB327F+k2XVMkEG0xBP/4qmQM1zV3IkamwV0HTWS+E2Ib47/kjcBTdJF2M6HwrFcM\nZq1dmRjbV2DOVWZ+I+/qK48LYS5b2e4MSRONj58gss6H4JVf5P2Qijx7SpXOJfWw\nFmxcZcLIimD7ylwxX+wO8jjBHzCdYW8ExHdtfKXKaXCQkxP8nG8XnsDyloyg76M7\nChJpL3PtwoZWtSsm8/RjUwbq74qBOQje7Mdx0/y/B7Mjwj2cJI3jlxZBG17jeotI\nQpcnI4mxyset+pg9db5FkgmLg/N4Na7X3ux8rlAeDe/Y74wxMJafmvKM1Lcuk8c=\n=nYgQ\n-----END PGP SIGNATURE-----\n", "payload": "tree ab3a669a3a363763014ae49cb0d6c3b574a2b59a\nparent 7b6fd616c93fc8b7f8f445c58aa662738a4e5718\nparent c78724f869add98e0f2af8950f760a37ec35243b\nauthor Dylan DPC <dylan.dpc@gmail.com> 1619108079 +0200\ncommitter GitHub <noreply@github.com> 1619108079 +0200\n\nRollup merge of #84377 - jackh726:binder-refactor-fix, r=nikomatsakis\n\nFollowup to #83944\n\nSome cleanups requested by ``@nikomatsakis``\n\nr? ``@nikomatsakis``\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9b432e0234b282b083e7e308f2496b63507ab5bc", "html_url": "https://github.com/rust-lang/rust/commit/9b432e0234b282b083e7e308f2496b63507ab5bc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9b432e0234b282b083e7e308f2496b63507ab5bc/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7b6fd616c93fc8b7f8f445c58aa662738a4e5718", "url": "https://api.github.com/repos/rust-lang/rust/commits/7b6fd616c93fc8b7f8f445c58aa662738a4e5718", "html_url": "https://github.com/rust-lang/rust/commit/7b6fd616c93fc8b7f8f445c58aa662738a4e5718"}, {"sha": "c78724f869add98e0f2af8950f760a37ec35243b", "url": "https://api.github.com/repos/rust-lang/rust/commits/c78724f869add98e0f2af8950f760a37ec35243b", "html_url": "https://github.com/rust-lang/rust/commit/c78724f869add98e0f2af8950f760a37ec35243b"}], "stats": {"total": 676, "additions": 254, "deletions": 422}, "files": [{"sha": "8a3f76415968ec84955837b9e75fde29ea6e15b2", "filename": "compiler/rustc_ast_passes/src/ast_validation.rs", "status": "modified", "additions": 35, "deletions": 10, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/9b432e0234b282b083e7e308f2496b63507ab5bc/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b432e0234b282b083e7e308f2496b63507ab5bc/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs?ref=9b432e0234b282b083e7e308f2496b63507ab5bc", "patch": "@@ -1213,8 +1213,41 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                 deny_equality_constraints(self, predicate, generics);\n             }\n         }\n-\n-        visit::walk_generics(self, generics)\n+        walk_list!(self, visit_generic_param, &generics.params);\n+        for predicate in &generics.where_clause.predicates {\n+            match predicate {\n+                WherePredicate::BoundPredicate(bound_pred) => {\n+                    // A type binding, eg `for<'c> Foo: Send+Clone+'c`\n+                    self.check_late_bound_lifetime_defs(&bound_pred.bound_generic_params);\n+\n+                    // This is slightly complicated. Our representation for poly-trait-refs contains a single\n+                    // binder and thus we only allow a single level of quantification. However,\n+                    // the syntax of Rust permits quantification in two places in where clauses,\n+                    // e.g., `T: for <'a> Foo<'a>` and `for <'a, 'b> &'b T: Foo<'a>`. If both are\n+                    // defined, then error.\n+                    if !bound_pred.bound_generic_params.is_empty() {\n+                        for bound in &bound_pred.bounds {\n+                            match bound {\n+                                GenericBound::Trait(t, _) => {\n+                                    if !t.bound_generic_params.is_empty() {\n+                                        struct_span_err!(\n+                                            self.err_handler(),\n+                                            t.span,\n+                                            E0316,\n+                                            \"nested quantification of lifetimes\"\n+                                        )\n+                                        .emit();\n+                                    }\n+                                }\n+                                GenericBound::Outlives(_) => {}\n+                            }\n+                        }\n+                    }\n+                }\n+                _ => {}\n+            }\n+            self.visit_where_predicate(predicate);\n+        }\n     }\n \n     fn visit_generic_param(&mut self, param: &'a GenericParam) {\n@@ -1263,14 +1296,6 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n         visit::walk_pat(self, pat)\n     }\n \n-    fn visit_where_predicate(&mut self, p: &'a WherePredicate) {\n-        if let &WherePredicate::BoundPredicate(ref bound_predicate) = p {\n-            // A type binding, eg `for<'c> Foo: Send+Clone+'c`\n-            self.check_late_bound_lifetime_defs(&bound_predicate.bound_generic_params);\n-        }\n-        visit::walk_where_predicate(self, p);\n-    }\n-\n     fn visit_poly_trait_ref(&mut self, t: &'a PolyTraitRef, m: &'a TraitBoundModifier) {\n         self.check_late_bound_lifetime_defs(&t.bound_generic_params);\n         visit::walk_poly_trait_ref(self, t, m);"}, {"sha": "174df09cbdbb2b5e4dcea4cb05da17b9f6974f5e", "filename": "compiler/rustc_resolve/src/late/lifetimes.rs", "status": "modified", "additions": 219, "deletions": 412, "changes": 631, "blob_url": "https://github.com/rust-lang/rust/blob/9b432e0234b282b083e7e308f2496b63507ab5bc/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b432e0234b282b083e7e308f2496b63507ab5bc/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs?ref=9b432e0234b282b083e7e308f2496b63507ab5bc", "patch": "@@ -165,29 +165,6 @@ crate struct LifetimeContext<'a, 'tcx> {\n     map: &'a mut NamedRegionMap,\n     scope: ScopeRef<'a>,\n \n-    /// This is slightly complicated. Our representation for poly-trait-refs contains a single\n-    /// binder and thus we only allow a single level of quantification. However,\n-    /// the syntax of Rust permits quantification in two places, e.g., `T: for <'a> Foo<'a>`\n-    /// and `for <'a, 'b> &'b T: Foo<'a>`. In order to get the De Bruijn indices\n-    /// correct when representing these constraints, we should only introduce one\n-    /// scope. However, we want to support both locations for the quantifier and\n-    /// during lifetime resolution we want precise information (so we can't\n-    /// desugar in an earlier phase). Moreso, an error here doesn't cause a bail\n-    /// from type checking, so we need to be extra careful that we don't lose\n-    /// any bound var information.\n-    ///\n-    /// So, if we encounter a quantifier at the outer scope, we set\n-    /// `trait_ref_hack` to the hir id of the bounded type (and introduce a scope).\n-    /// Then, if we encounter a quantifier at the inner scope, then we know to\n-    /// emit an error. Importantly though, we do have to track the lifetimes\n-    /// defined on the outer scope (i.e. the bounded ty), since we continue\n-    /// to type check after emitting an error; we therefore assume that the bound\n-    /// vars on the inner trait refs come from both quantifiers.\n-    ///\n-    /// If we encounter a quantifier in the inner scope `trait_ref_hack` being\n-    /// `None`, then we just introduce the scope at the inner quantifier as normal.\n-    trait_ref_hack: Option<hir::HirId>,\n-\n     /// Used to disallow the use of in-band lifetimes in `fn` or `Fn` syntax.\n     is_in_fn_syntax: bool,\n \n@@ -244,10 +221,7 @@ enum Scope<'a> {\n         /// of the resulting opaque type.\n         opaque_type_parent: bool,\n \n-        /// True only if this `Binder` scope is from the quantifiers on a\n-        /// `PolyTraitRef`. This is necessary for `associated_type_bounds`, which\n-        /// requires binders of nested trait refs to be merged.\n-        from_poly_trait_ref: bool,\n+        scope_type: BinderScopeType,\n \n         /// The late bound vars for a given item are stored by `HirId` to be\n         /// queried later. However, if we enter an elision scope, we have to\n@@ -282,41 +256,6 @@ enum Scope<'a> {\n         s: ScopeRef<'a>,\n     },\n \n-    /// This is a particularly interesting consequence of how we handle poly\n-    /// trait refs. See `trait_ref_hack` for additional info. This bit is\n-    /// important w.r.t. querying late-bound vars.\n-    ///\n-    /// To completely understand why this is necessary, first it's important to\n-    /// realize that `T: for<'a> U + for<'a, 'b> V` is actually two separate\n-    /// trait refs: `T: for<'a> U` and `T: for<'b> V` and as such, the late\n-    /// bound vars on each needs to be tracked separately. Also, in this case,\n-    /// are *three* relevant `HirId`s: one for the entire bound and one\n-    /// for each separate one.\n-    ///\n-    /// Next, imagine three different poly trait refs:\n-    ///   1) `for<'a, 'b> T: U<'a, 'b>`\n-    ///   2) `T: for<'a, 'b> U<'a, 'b>`\n-    ///   3) `for<'a> T: for<'b> U<'a, 'b>`\n-    ///\n-    /// First, note that the third example is semantically invalid and an error,\n-    /// but we *must* handle it as valid, since type checking isn't bailed out\n-    /// of. Other than that, if ask for bound vars for each, we expect\n-    /// `['a, 'b]`. If we *didn't* allow binders before `T`, then we would\n-    /// always introduce a binder scope at the inner trait ref. This is great,\n-    /// because later on during type-checking, we will ask \"what are the late\n-    /// bound vars on this trait ref\". However, because we allow bound vars on\n-    /// the bound itself, we have to have some way of keeping track of the fact\n-    /// that we actually want to store the late bound vars as being associated\n-    /// with the trait ref; this is that.\n-    ///\n-    /// One alternative way to handle this would be to just introduce a new\n-    /// `Binder` scope, but that's semantically a bit different, since bound\n-    /// vars from both `for<...>`s *do* share the same binder level.\n-    TraitRefHackInner {\n-        hir_id: hir::HirId,\n-        s: ScopeRef<'a>,\n-    },\n-\n     /// When we have nested trait refs, we concanetate late bound vars for inner\n     /// trait refs from outer ones. But we also need to include any HRTB\n     /// lifetimes encountered when identifying the trait that an associated type\n@@ -333,6 +272,22 @@ enum Scope<'a> {\n     Root,\n }\n \n+#[derive(Copy, Clone, Debug)]\n+enum BinderScopeType {\n+    /// Any non-concatenating binder scopes.\n+    Normal,\n+    /// Within a syntactic trait ref, there may be multiple poly trait refs that\n+    /// are nested (under the `associcated_type_bounds` feature). The binders of\n+    /// the innner poly trait refs are extended from the outer poly trait refs\n+    /// and don't increase the late bound depth. If you had\n+    /// `T: for<'a>  Foo<Bar: for<'b> Baz<'a, 'b>>`, then the `for<'b>` scope\n+    /// would be `Concatenating`. This also used in trait refs in where clauses\n+    /// where we have two binders `for<> T: for<> Foo` (I've intentionally left\n+    /// out any lifetimes because they aren't needed to show the two scopes).\n+    /// The inner `for<>` has a scope of `Concatenating`.\n+    Concatenating,\n+}\n+\n // A helper struct for debugging scopes without printing parent scopes\n struct TruncatedScopeDebug<'a>(&'a Scope<'a>);\n \n@@ -344,7 +299,7 @@ impl<'a> fmt::Debug for TruncatedScopeDebug<'a> {\n                 next_early_index,\n                 track_lifetime_uses,\n                 opaque_type_parent,\n-                from_poly_trait_ref,\n+                scope_type,\n                 hir_id,\n                 s: _,\n             } => f\n@@ -353,7 +308,7 @@ impl<'a> fmt::Debug for TruncatedScopeDebug<'a> {\n                 .field(\"next_early_index\", next_early_index)\n                 .field(\"track_lifetime_uses\", track_lifetime_uses)\n                 .field(\"opaque_type_parent\", opaque_type_parent)\n-                .field(\"from_poly_trait_ref\", from_poly_trait_ref)\n+                .field(\"scope_type\", scope_type)\n                 .field(\"hir_id\", hir_id)\n                 .field(\"s\", &\"..\")\n                 .finish(),\n@@ -368,11 +323,6 @@ impl<'a> fmt::Debug for TruncatedScopeDebug<'a> {\n                 .field(\"lifetime\", lifetime)\n                 .field(\"s\", &\"..\")\n                 .finish(),\n-            Scope::TraitRefHackInner { hir_id, s: _ } => f\n-                .debug_struct(\"TraitRefHackInner\")\n-                .field(\"hir_id\", hir_id)\n-                .field(\"s\", &\"..\")\n-                .finish(),\n             Scope::Supertrait { lifetimes, s: _ } => f\n                 .debug_struct(\"Supertrait\")\n                 .field(\"lifetimes\", lifetimes)\n@@ -495,7 +445,6 @@ fn do_resolve(\n         tcx,\n         map: &mut named_region_map,\n         scope: ROOT_SCOPE,\n-        trait_ref_hack: None,\n         is_in_fn_syntax: false,\n         is_in_const_generic: false,\n         trait_definition_only,\n@@ -618,6 +567,43 @@ fn late_region_as_bound_region<'tcx>(tcx: TyCtxt<'tcx>, region: &Region) -> ty::\n     }\n }\n \n+impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n+    /// Returns the binders in scope and the type of `Binder` that should be created for a poly trait ref.\n+    fn poly_trait_ref_binder_info(&mut self) -> (Vec<ty::BoundVariableKind>, BinderScopeType) {\n+        let mut scope = self.scope;\n+        let mut supertrait_lifetimes = vec![];\n+        loop {\n+            match scope {\n+                Scope::Body { .. } | Scope::Root => {\n+                    break (vec![], BinderScopeType::Normal);\n+                }\n+\n+                Scope::Elision { s, .. } | Scope::ObjectLifetimeDefault { s, .. } => {\n+                    scope = s;\n+                }\n+\n+                Scope::Supertrait { s, lifetimes } => {\n+                    supertrait_lifetimes = lifetimes.clone();\n+                    scope = s;\n+                }\n+\n+                Scope::TraitRefBoundary { .. } => {\n+                    // We should only see super trait lifetimes if there is a `Binder` above\n+                    assert!(supertrait_lifetimes.is_empty());\n+                    break (vec![], BinderScopeType::Normal);\n+                }\n+\n+                Scope::Binder { hir_id, .. } => {\n+                    // Nested poly trait refs have the binders concatenated\n+                    let mut full_binders =\n+                        self.map.late_bound_vars.entry(*hir_id).or_default().clone();\n+                    full_binders.extend(supertrait_lifetimes.into_iter());\n+                    break (full_binders, BinderScopeType::Concatenating);\n+                }\n+            }\n+        }\n+    }\n+}\n impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n     type Map = Map<'tcx>;\n \n@@ -675,7 +661,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     s: self.scope,\n                     track_lifetime_uses: true,\n                     opaque_type_parent: false,\n-                    from_poly_trait_ref: false,\n+                    scope_type: BinderScopeType::Normal,\n                 };\n                 self.with(scope, move |_old_scope, this| {\n                     intravisit::walk_fn(this, fk, fd, b, s, hir_id)\n@@ -800,12 +786,15 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     next_early_index: index + non_lifetime_count,\n                     opaque_type_parent: true,\n                     track_lifetime_uses,\n-                    from_poly_trait_ref: false,\n+                    scope_type: BinderScopeType::Normal,\n                     s: ROOT_SCOPE,\n                 };\n                 self.with(scope, |old_scope, this| {\n                     this.check_lifetime_params(old_scope, &generics.params);\n-                    intravisit::walk_item(this, item);\n+                    let scope = Scope::TraitRefBoundary { s: this.scope };\n+                    this.with(scope, |_, this| {\n+                        intravisit::walk_item(this, item);\n+                    });\n                 });\n                 self.missing_named_lifetime_spots.pop();\n             }\n@@ -869,7 +858,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     next_early_index,\n                     track_lifetime_uses: true,\n                     opaque_type_parent: false,\n-                    from_poly_trait_ref: false,\n+                    scope_type: BinderScopeType::Normal,\n                 };\n                 self.with(scope, |old_scope, this| {\n                     // a bare fn has no bounds, so everything\n@@ -939,9 +928,12 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n \n                         // Elided lifetimes are not allowed in non-return\n                         // position impl Trait\n-                        let scope = Scope::Elision { elide: Elide::Forbid, s: self.scope };\n+                        let scope = Scope::TraitRefBoundary { s: self.scope };\n                         self.with(scope, |_, this| {\n-                            intravisit::walk_item(this, opaque_ty);\n+                            let scope = Scope::Elision { elide: Elide::Forbid, s: this.scope };\n+                            this.with(scope, |_, this| {\n+                                intravisit::walk_item(this, opaque_ty);\n+                            })\n                         });\n \n                         return;\n@@ -1062,7 +1054,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                             s: this.scope,\n                             track_lifetime_uses: true,\n                             opaque_type_parent: false,\n-                            from_poly_trait_ref: false,\n+                            scope_type: BinderScopeType::Normal,\n                         };\n                         this.with(scope, |_old_scope, this| {\n                             this.visit_generics(generics);\n@@ -1082,7 +1074,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                         s: self.scope,\n                         track_lifetime_uses: true,\n                         opaque_type_parent: false,\n-                        from_poly_trait_ref: false,\n+                        scope_type: BinderScopeType::Normal,\n                     };\n                     self.with(scope, |_old_scope, this| {\n                         let scope = Scope::TraitRefBoundary { s: this.scope };\n@@ -1141,7 +1133,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     s: self.scope,\n                     track_lifetime_uses: true,\n                     opaque_type_parent: true,\n-                    from_poly_trait_ref: false,\n+                    scope_type: BinderScopeType::Normal,\n                 };\n                 self.with(scope, |old_scope, this| {\n                     this.check_lifetime_params(old_scope, &generics.params);\n@@ -1210,7 +1202,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     s: self.scope,\n                     track_lifetime_uses: true,\n                     opaque_type_parent: true,\n-                    from_poly_trait_ref: false,\n+                    scope_type: BinderScopeType::Normal,\n                 };\n                 self.with(scope, |old_scope, this| {\n                     this.check_lifetime_params(old_scope, &generics.params);\n@@ -1270,106 +1262,110 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n         if !self.trait_definition_only {\n             check_mixed_explicit_and_in_band_defs(self.tcx, &generics.params);\n         }\n-        for param in generics.params {\n-            match param.kind {\n-                GenericParamKind::Lifetime { .. } => {}\n-                GenericParamKind::Type { ref default, .. } => {\n-                    walk_list!(self, visit_param_bound, param.bounds);\n-                    if let Some(ref ty) = default {\n-                        self.visit_ty(&ty);\n+        let scope = Scope::TraitRefBoundary { s: self.scope };\n+        self.with(scope, |_, this| {\n+            for param in generics.params {\n+                match param.kind {\n+                    GenericParamKind::Lifetime { .. } => {}\n+                    GenericParamKind::Type { ref default, .. } => {\n+                        walk_list!(this, visit_param_bound, param.bounds);\n+                        if let Some(ref ty) = default {\n+                            this.visit_ty(&ty);\n+                        }\n+                    }\n+                    GenericParamKind::Const { ref ty, .. } => {\n+                        let was_in_const_generic = this.is_in_const_generic;\n+                        this.is_in_const_generic = true;\n+                        walk_list!(this, visit_param_bound, param.bounds);\n+                        this.visit_ty(&ty);\n+                        this.is_in_const_generic = was_in_const_generic;\n                     }\n                 }\n-                GenericParamKind::Const { ref ty, .. } => {\n-                    let was_in_const_generic = self.is_in_const_generic;\n-                    self.is_in_const_generic = true;\n-                    walk_list!(self, visit_param_bound, param.bounds);\n-                    self.visit_ty(&ty);\n-                    self.is_in_const_generic = was_in_const_generic;\n-                }\n-            }\n-        }\n-        for predicate in generics.where_clause.predicates {\n-            match predicate {\n-                &hir::WherePredicate::BoundPredicate(hir::WhereBoundPredicate {\n-                    ref bounded_ty,\n-                    bounds,\n-                    ref bound_generic_params,\n-                    ..\n-                }) => {\n-                    let (lifetimes, binders): (FxHashMap<hir::ParamName, Region>, Vec<_>) =\n-                        bound_generic_params\n-                            .iter()\n-                            .filter_map(|param| match param.kind {\n-                                GenericParamKind::Lifetime { .. } => Some(param),\n-                                _ => None,\n-                            })\n-                            .enumerate()\n-                            .map(|(late_bound_idx, param)| {\n-                                let pair =\n-                                    Region::late(late_bound_idx as u32, &self.tcx.hir(), param);\n-                                let r = late_region_as_bound_region(self.tcx, &pair.1);\n-                                (pair, r)\n-                            })\n-                            .unzip();\n-                    self.map.late_bound_vars.insert(bounded_ty.hir_id, binders.clone());\n-                    let scope = Scope::TraitRefBoundary { s: self.scope };\n-                    self.with(scope, |_, this| {\n-                        if !lifetimes.is_empty() {\n-                            let next_early_index = this.next_early_index();\n-                            let scope = Scope::Binder {\n-                                hir_id: bounded_ty.hir_id,\n-                                lifetimes,\n-                                s: this.scope,\n-                                next_early_index,\n-                                track_lifetime_uses: true,\n-                                opaque_type_parent: false,\n-                                from_poly_trait_ref: true,\n-                            };\n-                            this.with(scope, |old_scope, this| {\n-                                this.check_lifetime_params(old_scope, &bound_generic_params);\n-                                this.visit_ty(&bounded_ty);\n-                                this.trait_ref_hack = Some(bounded_ty.hir_id);\n-                                walk_list!(this, visit_param_bound, bounds);\n-                                this.trait_ref_hack = None;\n-                            })\n-                        } else {\n+            }\n+            for predicate in generics.where_clause.predicates {\n+                match predicate {\n+                    &hir::WherePredicate::BoundPredicate(hir::WhereBoundPredicate {\n+                        ref bounded_ty,\n+                        bounds,\n+                        ref bound_generic_params,\n+                        ..\n+                    }) => {\n+                        let (lifetimes, binders): (FxHashMap<hir::ParamName, Region>, Vec<_>) =\n+                            bound_generic_params\n+                                .iter()\n+                                .filter_map(|param| match param.kind {\n+                                    GenericParamKind::Lifetime { .. } => Some(param),\n+                                    _ => None,\n+                                })\n+                                .enumerate()\n+                                .map(|(late_bound_idx, param)| {\n+                                    let pair =\n+                                        Region::late(late_bound_idx as u32, &this.tcx.hir(), param);\n+                                    let r = late_region_as_bound_region(this.tcx, &pair.1);\n+                                    (pair, r)\n+                                })\n+                                .unzip();\n+                        this.map.late_bound_vars.insert(bounded_ty.hir_id, binders.clone());\n+                        let next_early_index = this.next_early_index();\n+                        // Even if there are no lifetimes defined here, we still wrap it in a binder\n+                        // scope. If there happens to be a nested poly trait ref (an error), that\n+                        // will be `Concatenating` anyways, so we don't have to worry about the depth\n+                        // being wrong.\n+                        let scope = Scope::Binder {\n+                            hir_id: bounded_ty.hir_id,\n+                            lifetimes,\n+                            s: this.scope,\n+                            next_early_index,\n+                            track_lifetime_uses: true,\n+                            opaque_type_parent: false,\n+                            scope_type: BinderScopeType::Normal,\n+                        };\n+                        this.with(scope, |old_scope, this| {\n+                            this.check_lifetime_params(old_scope, &bound_generic_params);\n                             this.visit_ty(&bounded_ty);\n                             walk_list!(this, visit_param_bound, bounds);\n-                        }\n-                    })\n-                }\n-                &hir::WherePredicate::RegionPredicate(hir::WhereRegionPredicate {\n-                    ref lifetime,\n-                    bounds,\n-                    ..\n-                }) => {\n-                    self.visit_lifetime(lifetime);\n-                    walk_list!(self, visit_param_bound, bounds);\n-                }\n-                &hir::WherePredicate::EqPredicate(hir::WhereEqPredicate {\n-                    ref lhs_ty,\n-                    ref rhs_ty,\n-                    ..\n-                }) => {\n-                    self.visit_ty(lhs_ty);\n-                    self.visit_ty(rhs_ty);\n+                        })\n+                    }\n+                    &hir::WherePredicate::RegionPredicate(hir::WhereRegionPredicate {\n+                        ref lifetime,\n+                        bounds,\n+                        ..\n+                    }) => {\n+                        this.visit_lifetime(lifetime);\n+                        walk_list!(this, visit_param_bound, bounds);\n+                    }\n+                    &hir::WherePredicate::EqPredicate(hir::WhereEqPredicate {\n+                        ref lhs_ty,\n+                        ref rhs_ty,\n+                        ..\n+                    }) => {\n+                        this.visit_ty(lhs_ty);\n+                        this.visit_ty(rhs_ty);\n+                    }\n                 }\n             }\n-        }\n+        })\n     }\n \n     fn visit_param_bound(&mut self, bound: &'tcx hir::GenericBound<'tcx>) {\n         match bound {\n-            hir::GenericBound::LangItemTrait(_, _, hir_id, _) if self.trait_ref_hack.is_none() => {\n-                self.map.late_bound_vars.insert(*hir_id, vec![]);\n+            hir::GenericBound::LangItemTrait(_, _, hir_id, _) => {\n+                // FIXME(jackh726): This is pretty weird. `LangItemTrait` doesn't go\n+                // through the regular poly trait ref code, so we don't get another\n+                // chance to introduce a binder. For now, I'm keeping the existing logic\n+                // of \"if there isn't a Binder scope above us, add one\", but I\n+                // imagine there's a better way to go about this.\n+                let (binders, scope_type) = self.poly_trait_ref_binder_info();\n+\n+                self.map.late_bound_vars.insert(*hir_id, binders);\n                 let scope = Scope::Binder {\n                     hir_id: *hir_id,\n                     lifetimes: FxHashMap::default(),\n                     s: self.scope,\n                     next_early_index: self.next_early_index(),\n                     track_lifetime_uses: true,\n                     opaque_type_parent: false,\n-                    from_poly_trait_ref: false,\n+                    scope_type,\n                 };\n                 self.with(scope, |_, this| {\n                     intravisit::walk_param_bound(this, bound);\n@@ -1388,148 +1384,53 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n \n         let should_pop_missing_lt = self.is_trait_ref_fn_scope(trait_ref);\n \n-        let trait_ref_hack = self.trait_ref_hack.take();\n         let next_early_index = self.next_early_index();\n-        // See note on `trait_ref_hack`. If `for<..>` has been defined in both\n-        // the outer and inner part of the trait ref, emit an error.\n-        let has_lifetimes = trait_ref.bound_generic_params.iter().any(|param| match param.kind {\n-            GenericParamKind::Lifetime { .. } => true,\n-            _ => false,\n-        });\n-        if trait_ref_hack.is_some() && has_lifetimes {\n-            struct_span_err!(\n-                self.tcx.sess,\n-                trait_ref.span,\n-                E0316,\n-                \"nested quantification of lifetimes\"\n-            )\n-            .emit();\n-        }\n-\n-        let (binders, lifetimes) = if let Some(hir_id) = trait_ref_hack {\n-            let mut binders = self.map.late_bound_vars.entry(hir_id).or_default().clone();\n-            let initial_bound_vars = binders.len() as u32;\n-            let mut lifetimes: FxHashMap<hir::ParamName, Region> = FxHashMap::default();\n-            let binders_iter = trait_ref\n-                .bound_generic_params\n-                .iter()\n-                .filter_map(|param| match param.kind {\n-                    GenericParamKind::Lifetime { .. } => Some(param),\n-                    _ => None,\n-                })\n-                .enumerate()\n-                .map(|(late_bound_idx, param)| {\n-                    let pair = Region::late(\n-                        initial_bound_vars + late_bound_idx as u32,\n-                        &self.tcx.hir(),\n-                        param,\n-                    );\n-                    let r = late_region_as_bound_region(self.tcx, &pair.1);\n-                    lifetimes.insert(pair.0, pair.1);\n-                    r\n-                });\n-            binders.extend(binders_iter);\n-\n-            (binders, lifetimes)\n-        } else {\n-            let mut supertrait_lifetimes = vec![];\n-            let mut scope = self.scope;\n-            let mut outer_binders = loop {\n-                match scope {\n-                    Scope::Body { .. } | Scope::Root => {\n-                        break vec![];\n-                    }\n-\n-                    Scope::Elision { s, .. } | Scope::ObjectLifetimeDefault { s, .. } => {\n-                        scope = s;\n-                    }\n-\n-                    Scope::TraitRefHackInner { hir_id, .. } => {\n-                        // Nested poly trait refs have the binders concatenated\n-                        // If we reach `TraitRefHackInner`, then there is only one more `Binder` above us,\n-                        // over all the bounds. We don't want this, since all the lifetimes we care about\n-                        // are here anyways.\n-                        let mut full_binders =\n-                            self.map.late_bound_vars.entry(*hir_id).or_default().clone();\n-                        full_binders.extend(supertrait_lifetimes.into_iter());\n-                        break full_binders;\n-                    }\n-\n-                    Scope::Supertrait { s, lifetimes } => {\n-                        supertrait_lifetimes = lifetimes.clone();\n-                        scope = s;\n-                    }\n-\n-                    Scope::TraitRefBoundary { .. } => {\n-                        // We should only see super trait lifetimes if there is a `Binder` above\n-                        assert!(supertrait_lifetimes.is_empty());\n-                        break vec![];\n-                    }\n-\n-                    Scope::Binder { hir_id, from_poly_trait_ref, .. } => {\n-                        if !from_poly_trait_ref {\n-                            // We should only see super trait lifetimes if there is a `Binder` above\n-                            assert!(supertrait_lifetimes.is_empty());\n-                            break vec![];\n-                        }\n-                        // Nested poly trait refs have the binders concatenated\n-                        let mut full_binders =\n-                            self.map.late_bound_vars.entry(*hir_id).or_default().clone();\n-                        full_binders.extend(supertrait_lifetimes.into_iter());\n-                        break full_binders;\n-                    }\n-                }\n-            };\n-            let (lifetimes, local_binders): (FxHashMap<hir::ParamName, Region>, Vec<_>) = trait_ref\n-                .bound_generic_params\n-                .iter()\n-                .filter_map(|param| match param.kind {\n-                    GenericParamKind::Lifetime { .. } => Some(param),\n-                    _ => None,\n-                })\n-                .enumerate()\n-                .map(|(late_bound_idx, param)| {\n-                    let pair = Region::late(\n-                        outer_binders.len() as u32 + late_bound_idx as u32,\n-                        &self.tcx.hir(),\n-                        param,\n-                    );\n-                    let r = late_region_as_bound_region(self.tcx, &pair.1);\n-                    (pair, r)\n-                })\n-                .unzip();\n-\n-            outer_binders.extend(local_binders.into_iter());\n+        let (mut binders, scope_type) = self.poly_trait_ref_binder_info();\n \n-            (outer_binders, lifetimes)\n-        };\n+        let initial_bound_vars = binders.len() as u32;\n+        let mut lifetimes: FxHashMap<hir::ParamName, Region> = FxHashMap::default();\n+        let binders_iter = trait_ref\n+            .bound_generic_params\n+            .iter()\n+            .filter_map(|param| match param.kind {\n+                GenericParamKind::Lifetime { .. } => Some(param),\n+                _ => None,\n+            })\n+            .enumerate()\n+            .map(|(late_bound_idx, param)| {\n+                let pair = Region::late(\n+                    initial_bound_vars + late_bound_idx as u32,\n+                    &self.tcx.hir(),\n+                    param,\n+                );\n+                let r = late_region_as_bound_region(self.tcx, &pair.1);\n+                lifetimes.insert(pair.0, pair.1);\n+                r\n+            });\n+        binders.extend(binders_iter);\n \n         debug!(?binders);\n         self.map.late_bound_vars.insert(trait_ref.trait_ref.hir_ref_id, binders);\n \n-        if trait_ref_hack.is_none() || has_lifetimes {\n-            let scope = Scope::Binder {\n-                hir_id: trait_ref.trait_ref.hir_ref_id,\n-                lifetimes,\n-                s: self.scope,\n-                next_early_index,\n-                track_lifetime_uses: true,\n-                opaque_type_parent: false,\n-                from_poly_trait_ref: true,\n-            };\n-            self.with(scope, |old_scope, this| {\n-                this.check_lifetime_params(old_scope, &trait_ref.bound_generic_params);\n-                walk_list!(this, visit_generic_param, trait_ref.bound_generic_params);\n-                this.visit_trait_ref(&trait_ref.trait_ref);\n-            });\n-        } else {\n-            let scope =\n-                Scope::TraitRefHackInner { hir_id: trait_ref.trait_ref.hir_ref_id, s: self.scope };\n-            self.with(scope, |_old_scope, this| {\n-                this.visit_trait_ref(&trait_ref.trait_ref);\n-            });\n-        }\n-        self.trait_ref_hack = trait_ref_hack;\n+        // Always introduce a scope here, even if this is in a where clause and\n+        // we introduced the binders around the bounded Ty. In that case, we\n+        // just reuse the concatenation functionality also present in nested trait\n+        // refs.\n+        let scope = Scope::Binder {\n+            hir_id: trait_ref.trait_ref.hir_ref_id,\n+            lifetimes,\n+            s: self.scope,\n+            next_early_index,\n+            track_lifetime_uses: true,\n+            opaque_type_parent: false,\n+            scope_type,\n+        };\n+        self.with(scope, |old_scope, this| {\n+            this.check_lifetime_params(old_scope, &trait_ref.bound_generic_params);\n+            walk_list!(this, visit_generic_param, trait_ref.bound_generic_params);\n+            this.visit_trait_ref(&trait_ref.trait_ref);\n+        });\n+\n         if should_pop_missing_lt {\n             self.missing_named_lifetime_spots.pop();\n         }\n@@ -1680,7 +1581,6 @@ fn extract_labels(ctxt: &mut LifetimeContext<'_, '_>, body: &hir::Body<'_>) {\n                 Scope::Body { s, .. }\n                 | Scope::Elision { s, .. }\n                 | Scope::ObjectLifetimeDefault { s, .. }\n-                | Scope::TraitRefHackInner { s, .. }\n                 | Scope::Supertrait { s, .. }\n                 | Scope::TraitRefBoundary { s, .. } => {\n                     scope = s;\n@@ -1871,12 +1771,10 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         let labels_in_fn = take(&mut self.labels_in_fn);\n         let xcrate_object_lifetime_defaults = take(&mut self.xcrate_object_lifetime_defaults);\n         let missing_named_lifetime_spots = take(&mut self.missing_named_lifetime_spots);\n-        let trait_ref_hack = take(&mut self.trait_ref_hack);\n         let mut this = LifetimeContext {\n             tcx: *tcx,\n             map,\n             scope: &wrap_scope,\n-            trait_ref_hack,\n             is_in_fn_syntax: self.is_in_fn_syntax,\n             is_in_const_generic: self.is_in_const_generic,\n             trait_definition_only: self.trait_definition_only,\n@@ -1896,7 +1794,6 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         self.labels_in_fn = this.labels_in_fn;\n         self.xcrate_object_lifetime_defaults = this.xcrate_object_lifetime_defaults;\n         self.missing_named_lifetime_spots = this.missing_named_lifetime_spots;\n-        self.trait_ref_hack = this.trait_ref_hack;\n     }\n \n     /// helper method to determine the span to remove when suggesting the\n@@ -2265,7 +2162,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             s: self.scope,\n             opaque_type_parent: true,\n             track_lifetime_uses: false,\n-            from_poly_trait_ref: false,\n+            scope_type: BinderScopeType::Normal,\n         };\n         self.with(scope, move |old_scope, this| {\n             this.check_lifetime_params(old_scope, &generics.params);\n@@ -2289,7 +2186,6 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 | Scope::Body { s, .. }\n                 | Scope::Elision { s, .. }\n                 | Scope::ObjectLifetimeDefault { s, .. }\n-                | Scope::TraitRefHackInner { s, .. }\n                 | Scope::Supertrait { s, .. }\n                 | Scope::TraitRefBoundary { s, .. } => scope = s,\n             }\n@@ -2323,7 +2219,6 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         // given name or we run out of scopes.\n         // search.\n         let mut late_depth = 0;\n-        let mut in_poly_trait_ref = false;\n         let mut scope = self.scope;\n         let mut outermost_body = None;\n         let result = loop {\n@@ -2341,25 +2236,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     break None;\n                 }\n \n-                Scope::TraitRefBoundary { s, .. } => {\n-                    // We've exited nested poly trait refs; mark that we are no longer in nested trait refs.\n-                    // We don't increase the late depth because this isn't a `Binder` scope.\n-                    //\n-                    // This came up in #83737, which boiled down to a case like this:\n-                    //\n-                    // ```\n-                    // F: for<> Fn(&()) -> Box<dyn for<> Future<Output = ()> + Unpin>,\n-                    //                         //  ^^^^^\n-\n-                    // ```\n-                    //\n-                    // Here, as we traverse upwards from the `dyn for<>` binder, we want to reset `in_poly_trait_ref`\n-                    // to false, so that we avoid excess contaenation when we encounter the outer `for<>`  binder.\n-                    in_poly_trait_ref = false;\n-                    scope = s;\n-                }\n-\n-                Scope::Binder { ref lifetimes, from_poly_trait_ref, s, .. } => {\n+                Scope::Binder { ref lifetimes, scope_type, s, .. } => {\n                     match lifetime_ref.name {\n                         LifetimeName::Param(param_name) => {\n                             if let Some(&def) = lifetimes.get(&param_name.normalize_to_macros_2_0())\n@@ -2369,47 +2246,17 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                         }\n                         _ => bug!(\"expected LifetimeName::Param\"),\n                     }\n-\n-                    match (from_poly_trait_ref, in_poly_trait_ref) {\n-                        // This is the first binder we see that is a poly trait ref; add one to the\n-                        // late depth and mark that we're potentially in nested trait refs.\n-                        (true, false) => {\n-                            in_poly_trait_ref = true;\n-                            late_depth += 1;\n-                        }\n-                        // We've already seen a binder that is a poly trait ref and this one is too,\n-                        // that means that they are nested and we are concatenating the bound vars;\n-                        // don't increase the late depth.\n-                        //\n-                        // This happens specifically with associated trait bounds like the following:\n-                        //\n-                        // ```\n-                        // for<'a> T: Iterator<Item: for<'b> Foo<'a, 'b>>\n-                        // ```\n-                        //\n-                        // In this case, as we traverse `for<'b>`, we would increment `late_depth` but\n-                        // set `in_poly_trait_ref` to true. Then when we traverse `for<'a>`, we would\n-                        // not increment `late_depth` again. (NB: Niko thinks this logic is actually\n-                        // wrong.)\n-                        (true, true) => {}\n-                        // We've exited nested poly trait refs; add one to the late depth and mark\n-                        // that we are no longer in nested trait refs\n-                        (false, true) => {\n-                            in_poly_trait_ref = false;\n-                            late_depth += 1;\n-                        }\n-                        // Any other kind of nested binders: just increase late depth.\n-                        (false, false) => {\n-                            late_depth += 1;\n-                        }\n+                    match scope_type {\n+                        BinderScopeType::Normal => late_depth += 1,\n+                        BinderScopeType::Concatenating => {}\n                     }\n                     scope = s;\n                 }\n \n                 Scope::Elision { s, .. }\n                 | Scope::ObjectLifetimeDefault { s, .. }\n-                | Scope::TraitRefHackInner { s, .. }\n-                | Scope::Supertrait { s, .. } => {\n+                | Scope::Supertrait { s, .. }\n+                | Scope::TraitRefBoundary { s, .. } => {\n                     scope = s;\n                 }\n             }\n@@ -2562,7 +2409,6 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                         Scope::Binder { s, .. }\n                         | Scope::Elision { s, .. }\n                         | Scope::ObjectLifetimeDefault { s, .. }\n-                        | Scope::TraitRefHackInner { s, .. }\n                         | Scope::Supertrait { s, .. }\n                         | Scope::TraitRefBoundary { s, .. } => {\n                             scope = s;\n@@ -2761,7 +2607,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         let mut scope = &*self.scope;\n         let hir_id = loop {\n             match scope {\n-                Scope::Binder { hir_id, .. } | Scope::TraitRefHackInner { hir_id, .. } => {\n+                Scope::Binder { hir_id, .. } => {\n                     break *hir_id;\n                 }\n                 Scope::Body { id, .. } => break id.hir_id,\n@@ -3112,7 +2958,6 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n \n         let span = lifetime_refs[0].span;\n         let mut late_depth = 0;\n-        let mut in_poly_trait_ref = false;\n         let mut scope = self.scope;\n         let mut lifetime_names = FxHashSet::default();\n         let mut lifetime_spans = vec![];\n@@ -3123,35 +2968,17 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n \n                 Scope::Root => break None,\n \n-                Scope::TraitRefBoundary { s, .. } => {\n-                    // We've exited nested poly trait refs; mark that we are no longer in nested trait refs.\n-                    // We don't increase the late depth because this isn't a `Binder` scope\n-                    in_poly_trait_ref = false;\n-                    scope = s;\n-                }\n-\n-                Scope::Binder { s, ref lifetimes, from_poly_trait_ref, .. } => {\n+                Scope::Binder { s, ref lifetimes, scope_type, .. } => {\n                     // collect named lifetimes for suggestions\n                     for name in lifetimes.keys() {\n                         if let hir::ParamName::Plain(name) = name {\n                             lifetime_names.insert(name.name);\n                             lifetime_spans.push(name.span);\n                         }\n                     }\n-                    // See comments in `resolve_lifetime_ref`\n-                    match (from_poly_trait_ref, in_poly_trait_ref) {\n-                        (true, false) => {\n-                            in_poly_trait_ref = true;\n-                            late_depth += 1;\n-                        }\n-                        (true, true) => {}\n-                        (false, true) => {\n-                            in_poly_trait_ref = false;\n-                            late_depth += 1;\n-                        }\n-                        (false, false) => {\n-                            late_depth += 1;\n-                        }\n+                    match scope_type {\n+                        BinderScopeType::Normal => late_depth += 1,\n+                        BinderScopeType::Concatenating => {}\n                     }\n                     scope = s;\n                 }\n@@ -3201,8 +3028,8 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 }\n \n                 Scope::ObjectLifetimeDefault { s, .. }\n-                | Scope::TraitRefHackInner { s, .. }\n-                | Scope::Supertrait { s, .. } => {\n+                | Scope::Supertrait { s, .. }\n+                | Scope::TraitRefBoundary { s, .. } => {\n                     scope = s;\n                 }\n             }\n@@ -3308,31 +3135,13 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n     fn resolve_object_lifetime_default(&mut self, lifetime_ref: &'tcx hir::Lifetime) {\n         debug!(\"resolve_object_lifetime_default(lifetime_ref={:?})\", lifetime_ref);\n         let mut late_depth = 0;\n-        let mut in_poly_trait_ref = false;\n         let mut scope = self.scope;\n         let lifetime = loop {\n             match *scope {\n-                Scope::TraitRefBoundary { s, .. } => {\n-                    // We've exited nested poly trait refs; mark that we are no longer in nested trait refs.\n-                    // We don't increase the late depth because this isn't a `Binder` scope\n-                    in_poly_trait_ref = false;\n-                    scope = s;\n-                }\n-\n-                Scope::Binder { s, from_poly_trait_ref, .. } => {\n-                    match (from_poly_trait_ref, in_poly_trait_ref) {\n-                        (true, false) => {\n-                            in_poly_trait_ref = true;\n-                            late_depth += 1;\n-                        }\n-                        (true, true) => {}\n-                        (false, true) => {\n-                            in_poly_trait_ref = false;\n-                            late_depth += 1;\n-                        }\n-                        (false, false) => {\n-                            late_depth += 1;\n-                        }\n+                Scope::Binder { s, scope_type, .. } => {\n+                    match scope_type {\n+                        BinderScopeType::Normal => late_depth += 1,\n+                        BinderScopeType::Concatenating => {}\n                     }\n                     scope = s;\n                 }\n@@ -3343,7 +3152,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n \n                 Scope::ObjectLifetimeDefault { lifetime: Some(l), .. } => break l,\n \n-                Scope::TraitRefHackInner { s, .. } | Scope::Supertrait { s, .. } => {\n+                Scope::Supertrait { s, .. } | Scope::TraitRefBoundary { s, .. } => {\n                     scope = s;\n                 }\n             }\n@@ -3470,7 +3279,6 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 Scope::Body { s, .. }\n                 | Scope::Elision { s, .. }\n                 | Scope::ObjectLifetimeDefault { s, .. }\n-                | Scope::TraitRefHackInner { s, .. }\n                 | Scope::Supertrait { s, .. }\n                 | Scope::TraitRefBoundary { s, .. } => {\n                     old_scope = s;\n@@ -3529,7 +3337,6 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 } => break false,\n \n                 Scope::ObjectLifetimeDefault { s, .. }\n-                | Scope::TraitRefHackInner { s, .. }\n                 | Scope::Supertrait { s, .. }\n                 | Scope::TraitRefBoundary { s, .. } => scope = s,\n             }"}]}