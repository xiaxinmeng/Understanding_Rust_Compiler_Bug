{"sha": "e0b4287df6635158043e7015d89b619af7f7748d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUwYjQyODdkZjY2MzUxNTgwNDNlNzAxNWQ4OWI2MTlhZjdmNzc0OGQ=", "commit": {"author": {"name": "Corey Richardson", "email": "corey@octayn.net", "date": "2015-01-05T06:51:03Z"}, "committer": {"name": "Corey Richardson", "email": "corey@octayn.net", "date": "2015-01-06T17:04:41Z"}, "message": "Fix fallout", "tree": {"sha": "d67a84c1eb581e288625a206d7d3aa544024e42d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d67a84c1eb581e288625a206d7d3aa544024e42d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e0b4287df6635158043e7015d89b619af7f7748d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e0b4287df6635158043e7015d89b619af7f7748d", "html_url": "https://github.com/rust-lang/rust/commit/e0b4287df6635158043e7015d89b619af7f7748d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e0b4287df6635158043e7015d89b619af7f7748d/comments", "author": {"login": "emberian", "id": 704250, "node_id": "MDQ6VXNlcjcwNDI1MA==", "avatar_url": "https://avatars.githubusercontent.com/u/704250?v=4", "gravatar_id": "", "url": "https://api.github.com/users/emberian", "html_url": "https://github.com/emberian", "followers_url": "https://api.github.com/users/emberian/followers", "following_url": "https://api.github.com/users/emberian/following{/other_user}", "gists_url": "https://api.github.com/users/emberian/gists{/gist_id}", "starred_url": "https://api.github.com/users/emberian/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/emberian/subscriptions", "organizations_url": "https://api.github.com/users/emberian/orgs", "repos_url": "https://api.github.com/users/emberian/repos", "events_url": "https://api.github.com/users/emberian/events{/privacy}", "received_events_url": "https://api.github.com/users/emberian/received_events", "type": "User", "site_admin": false}, "committer": {"login": "emberian", "id": 704250, "node_id": "MDQ6VXNlcjcwNDI1MA==", "avatar_url": "https://avatars.githubusercontent.com/u/704250?v=4", "gravatar_id": "", "url": "https://api.github.com/users/emberian", "html_url": "https://github.com/emberian", "followers_url": "https://api.github.com/users/emberian/followers", "following_url": "https://api.github.com/users/emberian/following{/other_user}", "gists_url": "https://api.github.com/users/emberian/gists{/gist_id}", "starred_url": "https://api.github.com/users/emberian/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/emberian/subscriptions", "organizations_url": "https://api.github.com/users/emberian/orgs", "repos_url": "https://api.github.com/users/emberian/repos", "events_url": "https://api.github.com/users/emberian/events{/privacy}", "received_events_url": "https://api.github.com/users/emberian/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6680c9c5c797101fc5e0608cb2c3657517333148", "url": "https://api.github.com/repos/rust-lang/rust/commits/6680c9c5c797101fc5e0608cb2c3657517333148", "html_url": "https://github.com/rust-lang/rust/commit/6680c9c5c797101fc5e0608cb2c3657517333148"}], "stats": {"total": 402, "additions": 200, "deletions": 202}, "files": [{"sha": "9cb4d154de7b22a910619c5f45b3bfb3ccdc6918", "filename": "src/doc/guide-macros.md", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/e0b4287df6635158043e7015d89b619af7f7748d/src%2Fdoc%2Fguide-macros.md", "raw_url": "https://github.com/rust-lang/rust/raw/e0b4287df6635158043e7015d89b619af7f7748d/src%2Fdoc%2Fguide-macros.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-macros.md?ref=e0b4287df6635158043e7015d89b619af7f7748d", "patch": "@@ -161,7 +161,7 @@ instead of `*` to mean \"at least one\".\n # let input_1 = T::SpecialA(0);\n # let input_2 = T::SpecialA(0);\n macro_rules! early_return {\n-    ($inp:expr, [ $($sp:path)|+ ]) => (\n+    ($inp:expr, [ $($sp:path),+ ]) => (\n         match $inp {\n             $(\n                 $sp(x) => { return x; }\n@@ -171,7 +171,7 @@ macro_rules! early_return {\n     )\n }\n // ...\n-early_return!(input_1, [T::SpecialA|T::SpecialC|T::SpecialD]);\n+early_return!(input_1, [T::SpecialA,T::SpecialC,T::SpecialD]);\n // ...\n early_return!(input_2, [T::SpecialB]);\n # return 0;\n@@ -245,7 +245,7 @@ can solve the problem:\n ~~~~\n macro_rules! biased_match {\n     // special case: `let (x) = ...` is illegal, so use `let x = ...` instead\n-    ( ($e:expr) ~ ($p:pat) else $err:stmt ;\n+    ( ($e:expr) -> ($p:pat) else $err:stmt ;\n       binds $bind_res:ident\n     ) => (\n         let $bind_res = match $e {\n@@ -254,7 +254,7 @@ macro_rules! biased_match {\n         };\n     );\n     // more than one name; use a tuple\n-    ( ($e:expr) ~ ($p:pat) else $err:stmt ;\n+    ( ($e:expr) -> ($p:pat) else $err:stmt ;\n       binds $( $bind_res:ident ),*\n     ) => (\n         let ( $( $bind_res ),* ) = match $e {\n@@ -268,9 +268,9 @@ macro_rules! biased_match {\n # struct T2 { body: T3 }\n # enum T3 { Good2(uint), Bad2}\n # fn f(x: T1) -> uint {\n-biased_match!((x)       ~ (T1::Good1(g1, val)) else { return 0 };\n+biased_match!((x)       -> (T1::Good1(g1, val)) else { return 0 };\n               binds g1, val );\n-biased_match!((g1.body) ~ (T3::Good2(result) )\n+biased_match!((g1.body) -> (T3::Good2(result) )\n                   else { panic!(\"Didn't get good_2\") };\n               binds result );\n // complicated stuff goes here\n@@ -286,7 +286,7 @@ pattern we want is clear:\n ~~~~\n # fn main() {}\n # macro_rules! b {\n-    ( $( ($e:expr) ~ ($p:pat) else $err:stmt ; )*\n+    ( $( ($e:expr) -> ($p:pat) else $err:stmt ; )*\n       binds $( $bind_res:ident ),*\n     )\n # => (0) }\n@@ -317,8 +317,8 @@ input patterns:\n ~~~~\n # fn main() {}\n # macro_rules! b {\n-    (    ($e     :expr) ~ ($p     :pat) else $err     :stmt ;\n-      $( ($e_rest:expr) ~ ($p_rest:pat) else $err_rest:stmt ; )*\n+    (    ($e     :expr) -> ($p     :pat) else $err     :stmt ;\n+      $( ($e_rest:expr) -> ($p_rest:pat) else $err_rest:stmt ; )*\n       binds  $( $bind_res:ident ),*\n     )\n # => (0) }\n@@ -333,14 +333,14 @@ piece of syntax (the `let`) which we only want to transcribe once.\n \n macro_rules! biased_match_rec {\n     // Handle the first layer\n-    (   ($e     :expr) ~ ($p     :pat) else $err     :stmt ;\n-     $( ($e_rest:expr) ~ ($p_rest:pat) else $err_rest:stmt ; )*\n+    (   ($e     :expr) -> ($p     :pat) else $err     :stmt ;\n+     $( ($e_rest:expr) -> ($p_rest:pat) else $err_rest:stmt ; )*\n      binds $( $bind_res:ident ),*\n     ) => (\n         match $e {\n             $p => {\n                 // Recursively handle the next layer\n-                biased_match_rec!($( ($e_rest) ~ ($p_rest) else $err_rest ; )*\n+                biased_match_rec!($( ($e_rest) -> ($p_rest) else $err_rest ; )*\n                                   binds $( $bind_res ),*\n                 )\n             }\n@@ -354,20 +354,20 @@ macro_rules! biased_match_rec {\n // Wrap the whole thing in a `let`.\n macro_rules! biased_match {\n     // special case: `let (x) = ...` is illegal, so use `let x = ...` instead\n-    ( $( ($e:expr) ~ ($p:pat) else $err:stmt ; )*\n+    ( $( ($e:expr) -> ($p:pat) else $err:stmt ; )*\n       binds $bind_res:ident\n     ) => (\n         let $bind_res = biased_match_rec!(\n-            $( ($e) ~ ($p) else $err ; )*\n+            $( ($e) -> ($p) else $err ; )*\n             binds $bind_res\n         );\n     );\n     // more than one name: use a tuple\n-    ( $( ($e:expr) ~ ($p:pat) else $err:stmt ; )*\n+    ( $( ($e:expr) -> ($p:pat) else $err:stmt ; )*\n       binds  $( $bind_res:ident ),*\n     ) => (\n         let ( $( $bind_res ),* ) = biased_match_rec!(\n-            $( ($e) ~ ($p) else $err ; )*\n+            $( ($e) -> ($p) else $err ; )*\n             binds $( $bind_res ),*\n         );\n     )\n@@ -379,8 +379,8 @@ macro_rules! biased_match {\n # enum T3 { Good2(uint), Bad2}\n # fn f(x: T1) -> uint {\n biased_match!(\n-    (x)       ~ (T1::Good1(g1, val)) else { return 0 };\n-    (g1.body) ~ (T3::Good2(result) ) else { panic!(\"Didn't get Good2\") };\n+    (x)       -> (T1::Good1(g1, val)) else { return 0 };\n+    (g1.body) -> (T3::Good2(result) ) else { panic!(\"Didn't get Good2\") };\n     binds val, result );\n // complicated stuff goes here\n return result + val;"}, {"sha": "b0a1fa0b1b4c662f547d027037683aa5f701bcc9", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/e0b4287df6635158043e7015d89b619af7f7748d/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0b4287df6635158043e7015d89b619af7f7748d/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=e0b4287df6635158043e7015d89b619af7f7748d", "patch": "@@ -35,17 +35,16 @@ use slice::{self, SliceExt};\n use uint;\n \n macro_rules! delegate_iter {\n-    (exact $te:ty in $ti:ty) => {\n-        delegate_iter!{$te in $ti}\n-        #[stable]\n+    (exact $te:ty : $ti:ty) => {\n+        delegate_iter!{$te : $ti}\n         impl<'a> ExactSizeIterator for $ti {\n             #[inline]\n             fn len(&self) -> uint {\n                 self.0.len()\n             }\n         }\n     };\n-    ($te:ty in $ti:ty) => {\n+    ($te:ty : $ti:ty) => {\n         #[stable]\n         impl<'a> Iterator for $ti {\n             type Item = $te;\n@@ -67,7 +66,7 @@ macro_rules! delegate_iter {\n             }\n         }\n     };\n-    (pattern $te:ty in $ti:ty) => {\n+    (pattern $te:ty : $ti:ty) => {\n         #[stable]\n         impl<'a, P: CharEq> Iterator for $ti {\n             type Item = $te;\n@@ -89,7 +88,7 @@ macro_rules! delegate_iter {\n             }\n         }\n     };\n-    (pattern forward $te:ty in $ti:ty) => {\n+    (pattern forward $te:ty : $ti:ty) => {\n         #[stable]\n         impl<'a, P: CharEq> Iterator for $ti {\n             type Item = $te;\n@@ -415,7 +414,7 @@ impl<'a> DoubleEndedIterator for CharIndices<'a> {\n #[stable]\n #[derive(Clone)]\n pub struct Bytes<'a>(Map<&'a u8, u8, slice::Iter<'a, u8>, BytesDeref>);\n-delegate_iter!{exact u8 in Bytes<'a>}\n+delegate_iter!{exact u8 : Bytes<'a>}\n \n /// A temporary fn new type that ensures that the `Bytes` iterator\n /// is cloneable.\n@@ -1165,25 +1164,25 @@ impl<'a, S: ?Sized> Str for &'a S where S: Str {\n #[derive(Clone)]\n #[stable]\n pub struct Split<'a, P>(CharSplits<'a, P>);\n-delegate_iter!{pattern &'a str in Split<'a, P>}\n+delegate_iter!{pattern &'a str : Split<'a, P>}\n \n /// Return type of `StrExt::split_terminator`\n #[derive(Clone)]\n #[unstable = \"might get removed in favour of a constructor method on Split\"]\n pub struct SplitTerminator<'a, P>(CharSplits<'a, P>);\n-delegate_iter!{pattern &'a str in SplitTerminator<'a, P>}\n+delegate_iter!{pattern &'a str : SplitTerminator<'a, P>}\n \n /// Return type of `StrExt::splitn`\n #[derive(Clone)]\n #[stable]\n pub struct SplitN<'a, P>(CharSplitsN<'a, P>);\n-delegate_iter!{pattern forward &'a str in SplitN<'a, P>}\n+delegate_iter!{pattern forward &'a str : SplitN<'a, P>}\n \n /// Return type of `StrExt::rsplitn`\n #[derive(Clone)]\n #[stable]\n pub struct RSplitN<'a, P>(CharSplitsN<'a, P>);\n-delegate_iter!{pattern forward &'a str in RSplitN<'a, P>}\n+delegate_iter!{pattern forward &'a str : RSplitN<'a, P>}\n \n /// Methods for string slices\n #[allow(missing_docs)]"}, {"sha": "bced3be01f0d6468cf7e20962d213d8fa3d066b4", "filename": "src/librustc_trans/trans/context.rs", "status": "modified", "additions": 110, "deletions": 110, "changes": 220, "blob_url": "https://github.com/rust-lang/rust/blob/e0b4287df6635158043e7015d89b619af7f7748d/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0b4287df6635158043e7015d89b619af7f7748d/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs?ref=e0b4287df6635158043e7015d89b619af7f7748d", "patch": "@@ -737,7 +737,7 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n \n fn declare_intrinsic(ccx: &CrateContext, key: & &'static str) -> Option<ValueRef> {\n     macro_rules! ifn {\n-        ($name:expr fn() -> $ret:expr) => (\n+        ($name:expr, fn() -> $ret:expr) => (\n             if *key == $name {\n                 let f = base::decl_cdecl_fn(\n                     ccx, $name, Type::func(&[], &$ret),\n@@ -746,7 +746,7 @@ fn declare_intrinsic(ccx: &CrateContext, key: & &'static str) -> Option<ValueRef\n                 return Some(f);\n             }\n         );\n-        ($name:expr fn($($arg:expr),*) -> $ret:expr) => (\n+        ($name:expr, fn($($arg:expr),*) -> $ret:expr) => (\n             if *key == $name {\n                 let f = base::decl_cdecl_fn(ccx, $name,\n                                   Type::func(&[$($arg),*], &$ret), ty::mk_nil(ccx.tcx()));\n@@ -769,111 +769,111 @@ fn declare_intrinsic(ccx: &CrateContext, key: & &'static str) -> Option<ValueRef\n     let t_f32 = Type::f32(ccx);\n     let t_f64 = Type::f64(ccx);\n \n-    ifn!(\"llvm.memcpy.p0i8.p0i8.i32\" fn(i8p, i8p, t_i32, t_i32, i1) -> void);\n-    ifn!(\"llvm.memcpy.p0i8.p0i8.i64\" fn(i8p, i8p, t_i64, t_i32, i1) -> void);\n-    ifn!(\"llvm.memmove.p0i8.p0i8.i32\" fn(i8p, i8p, t_i32, t_i32, i1) -> void);\n-    ifn!(\"llvm.memmove.p0i8.p0i8.i64\" fn(i8p, i8p, t_i64, t_i32, i1) -> void);\n-    ifn!(\"llvm.memset.p0i8.i32\" fn(i8p, t_i8, t_i32, t_i32, i1) -> void);\n-    ifn!(\"llvm.memset.p0i8.i64\" fn(i8p, t_i8, t_i64, t_i32, i1) -> void);\n-\n-    ifn!(\"llvm.trap\" fn() -> void);\n-    ifn!(\"llvm.debugtrap\" fn() -> void);\n-    ifn!(\"llvm.frameaddress\" fn(t_i32) -> i8p);\n-\n-    ifn!(\"llvm.powi.f32\" fn(t_f32, t_i32) -> t_f32);\n-    ifn!(\"llvm.powi.f64\" fn(t_f64, t_i32) -> t_f64);\n-    ifn!(\"llvm.pow.f32\" fn(t_f32, t_f32) -> t_f32);\n-    ifn!(\"llvm.pow.f64\" fn(t_f64, t_f64) -> t_f64);\n-\n-    ifn!(\"llvm.sqrt.f32\" fn(t_f32) -> t_f32);\n-    ifn!(\"llvm.sqrt.f64\" fn(t_f64) -> t_f64);\n-    ifn!(\"llvm.sin.f32\" fn(t_f32) -> t_f32);\n-    ifn!(\"llvm.sin.f64\" fn(t_f64) -> t_f64);\n-    ifn!(\"llvm.cos.f32\" fn(t_f32) -> t_f32);\n-    ifn!(\"llvm.cos.f64\" fn(t_f64) -> t_f64);\n-    ifn!(\"llvm.exp.f32\" fn(t_f32) -> t_f32);\n-    ifn!(\"llvm.exp.f64\" fn(t_f64) -> t_f64);\n-    ifn!(\"llvm.exp2.f32\" fn(t_f32) -> t_f32);\n-    ifn!(\"llvm.exp2.f64\" fn(t_f64) -> t_f64);\n-    ifn!(\"llvm.log.f32\" fn(t_f32) -> t_f32);\n-    ifn!(\"llvm.log.f64\" fn(t_f64) -> t_f64);\n-    ifn!(\"llvm.log10.f32\" fn(t_f32) -> t_f32);\n-    ifn!(\"llvm.log10.f64\" fn(t_f64) -> t_f64);\n-    ifn!(\"llvm.log2.f32\" fn(t_f32) -> t_f32);\n-    ifn!(\"llvm.log2.f64\" fn(t_f64) -> t_f64);\n-\n-    ifn!(\"llvm.fma.f32\" fn(t_f32, t_f32, t_f32) -> t_f32);\n-    ifn!(\"llvm.fma.f64\" fn(t_f64, t_f64, t_f64) -> t_f64);\n-\n-    ifn!(\"llvm.fabs.f32\" fn(t_f32) -> t_f32);\n-    ifn!(\"llvm.fabs.f64\" fn(t_f64) -> t_f64);\n-\n-    ifn!(\"llvm.floor.f32\" fn(t_f32) -> t_f32);\n-    ifn!(\"llvm.floor.f64\" fn(t_f64) -> t_f64);\n-    ifn!(\"llvm.ceil.f32\" fn(t_f32) -> t_f32);\n-    ifn!(\"llvm.ceil.f64\" fn(t_f64) -> t_f64);\n-    ifn!(\"llvm.trunc.f32\" fn(t_f32) -> t_f32);\n-    ifn!(\"llvm.trunc.f64\" fn(t_f64) -> t_f64);\n-\n-    ifn!(\"llvm.rint.f32\" fn(t_f32) -> t_f32);\n-    ifn!(\"llvm.rint.f64\" fn(t_f64) -> t_f64);\n-    ifn!(\"llvm.nearbyint.f32\" fn(t_f32) -> t_f32);\n-    ifn!(\"llvm.nearbyint.f64\" fn(t_f64) -> t_f64);\n-\n-    ifn!(\"llvm.ctpop.i8\" fn(t_i8) -> t_i8);\n-    ifn!(\"llvm.ctpop.i16\" fn(t_i16) -> t_i16);\n-    ifn!(\"llvm.ctpop.i32\" fn(t_i32) -> t_i32);\n-    ifn!(\"llvm.ctpop.i64\" fn(t_i64) -> t_i64);\n-\n-    ifn!(\"llvm.ctlz.i8\" fn(t_i8 , i1) -> t_i8);\n-    ifn!(\"llvm.ctlz.i16\" fn(t_i16, i1) -> t_i16);\n-    ifn!(\"llvm.ctlz.i32\" fn(t_i32, i1) -> t_i32);\n-    ifn!(\"llvm.ctlz.i64\" fn(t_i64, i1) -> t_i64);\n-\n-    ifn!(\"llvm.cttz.i8\" fn(t_i8 , i1) -> t_i8);\n-    ifn!(\"llvm.cttz.i16\" fn(t_i16, i1) -> t_i16);\n-    ifn!(\"llvm.cttz.i32\" fn(t_i32, i1) -> t_i32);\n-    ifn!(\"llvm.cttz.i64\" fn(t_i64, i1) -> t_i64);\n-\n-    ifn!(\"llvm.bswap.i16\" fn(t_i16) -> t_i16);\n-    ifn!(\"llvm.bswap.i32\" fn(t_i32) -> t_i32);\n-    ifn!(\"llvm.bswap.i64\" fn(t_i64) -> t_i64);\n-\n-    ifn!(\"llvm.sadd.with.overflow.i8\" fn(t_i8, t_i8) -> mk_struct!{t_i8, i1});\n-    ifn!(\"llvm.sadd.with.overflow.i16\" fn(t_i16, t_i16) -> mk_struct!{t_i16, i1});\n-    ifn!(\"llvm.sadd.with.overflow.i32\" fn(t_i32, t_i32) -> mk_struct!{t_i32, i1});\n-    ifn!(\"llvm.sadd.with.overflow.i64\" fn(t_i64, t_i64) -> mk_struct!{t_i64, i1});\n-\n-    ifn!(\"llvm.uadd.with.overflow.i8\" fn(t_i8, t_i8) -> mk_struct!{t_i8, i1});\n-    ifn!(\"llvm.uadd.with.overflow.i16\" fn(t_i16, t_i16) -> mk_struct!{t_i16, i1});\n-    ifn!(\"llvm.uadd.with.overflow.i32\" fn(t_i32, t_i32) -> mk_struct!{t_i32, i1});\n-    ifn!(\"llvm.uadd.with.overflow.i64\" fn(t_i64, t_i64) -> mk_struct!{t_i64, i1});\n-\n-    ifn!(\"llvm.ssub.with.overflow.i8\" fn(t_i8, t_i8) -> mk_struct!{t_i8, i1});\n-    ifn!(\"llvm.ssub.with.overflow.i16\" fn(t_i16, t_i16) -> mk_struct!{t_i16, i1});\n-    ifn!(\"llvm.ssub.with.overflow.i32\" fn(t_i32, t_i32) -> mk_struct!{t_i32, i1});\n-    ifn!(\"llvm.ssub.with.overflow.i64\" fn(t_i64, t_i64) -> mk_struct!{t_i64, i1});\n-\n-    ifn!(\"llvm.usub.with.overflow.i8\" fn(t_i8, t_i8) -> mk_struct!{t_i8, i1});\n-    ifn!(\"llvm.usub.with.overflow.i16\" fn(t_i16, t_i16) -> mk_struct!{t_i16, i1});\n-    ifn!(\"llvm.usub.with.overflow.i32\" fn(t_i32, t_i32) -> mk_struct!{t_i32, i1});\n-    ifn!(\"llvm.usub.with.overflow.i64\" fn(t_i64, t_i64) -> mk_struct!{t_i64, i1});\n-\n-    ifn!(\"llvm.smul.with.overflow.i8\" fn(t_i8, t_i8) -> mk_struct!{t_i8, i1});\n-    ifn!(\"llvm.smul.with.overflow.i16\" fn(t_i16, t_i16) -> mk_struct!{t_i16, i1});\n-    ifn!(\"llvm.smul.with.overflow.i32\" fn(t_i32, t_i32) -> mk_struct!{t_i32, i1});\n-    ifn!(\"llvm.smul.with.overflow.i64\" fn(t_i64, t_i64) -> mk_struct!{t_i64, i1});\n-\n-    ifn!(\"llvm.umul.with.overflow.i8\" fn(t_i8, t_i8) -> mk_struct!{t_i8, i1});\n-    ifn!(\"llvm.umul.with.overflow.i16\" fn(t_i16, t_i16) -> mk_struct!{t_i16, i1});\n-    ifn!(\"llvm.umul.with.overflow.i32\" fn(t_i32, t_i32) -> mk_struct!{t_i32, i1});\n-    ifn!(\"llvm.umul.with.overflow.i64\" fn(t_i64, t_i64) -> mk_struct!{t_i64, i1});\n-\n-    ifn!(\"llvm.lifetime.start\" fn(t_i64,i8p) -> void);\n-    ifn!(\"llvm.lifetime.end\" fn(t_i64, i8p) -> void);\n-\n-    ifn!(\"llvm.expect.i1\" fn(i1, i1) -> i1);\n-    ifn!(\"llvm.assume\" fn(i1) -> void);\n+    ifn!(\"llvm.memcpy.p0i8.p0i8.i32\", fn(i8p, i8p, t_i32, t_i32, i1) -> void);\n+    ifn!(\"llvm.memcpy.p0i8.p0i8.i64\", fn(i8p, i8p, t_i64, t_i32, i1) -> void);\n+    ifn!(\"llvm.memmove.p0i8.p0i8.i32\", fn(i8p, i8p, t_i32, t_i32, i1) -> void);\n+    ifn!(\"llvm.memmove.p0i8.p0i8.i64\", fn(i8p, i8p, t_i64, t_i32, i1) -> void);\n+    ifn!(\"llvm.memset.p0i8.i32\", fn(i8p, t_i8, t_i32, t_i32, i1) -> void);\n+    ifn!(\"llvm.memset.p0i8.i64\", fn(i8p, t_i8, t_i64, t_i32, i1) -> void);\n+\n+    ifn!(\"llvm.trap\", fn() -> void);\n+    ifn!(\"llvm.debugtrap\", fn() -> void);\n+    ifn!(\"llvm.frameaddress\", fn(t_i32) -> i8p);\n+\n+    ifn!(\"llvm.powi.f32\", fn(t_f32, t_i32) -> t_f32);\n+    ifn!(\"llvm.powi.f64\", fn(t_f64, t_i32) -> t_f64);\n+    ifn!(\"llvm.pow.f32\", fn(t_f32, t_f32) -> t_f32);\n+    ifn!(\"llvm.pow.f64\", fn(t_f64, t_f64) -> t_f64);\n+\n+    ifn!(\"llvm.sqrt.f32\", fn(t_f32) -> t_f32);\n+    ifn!(\"llvm.sqrt.f64\", fn(t_f64) -> t_f64);\n+    ifn!(\"llvm.sin.f32\", fn(t_f32) -> t_f32);\n+    ifn!(\"llvm.sin.f64\", fn(t_f64) -> t_f64);\n+    ifn!(\"llvm.cos.f32\", fn(t_f32) -> t_f32);\n+    ifn!(\"llvm.cos.f64\", fn(t_f64) -> t_f64);\n+    ifn!(\"llvm.exp.f32\", fn(t_f32) -> t_f32);\n+    ifn!(\"llvm.exp.f64\", fn(t_f64) -> t_f64);\n+    ifn!(\"llvm.exp2.f32\", fn(t_f32) -> t_f32);\n+    ifn!(\"llvm.exp2.f64\", fn(t_f64) -> t_f64);\n+    ifn!(\"llvm.log.f32\", fn(t_f32) -> t_f32);\n+    ifn!(\"llvm.log.f64\", fn(t_f64) -> t_f64);\n+    ifn!(\"llvm.log10.f32\", fn(t_f32) -> t_f32);\n+    ifn!(\"llvm.log10.f64\", fn(t_f64) -> t_f64);\n+    ifn!(\"llvm.log2.f32\", fn(t_f32) -> t_f32);\n+    ifn!(\"llvm.log2.f64\", fn(t_f64) -> t_f64);\n+\n+    ifn!(\"llvm.fma.f32\", fn(t_f32, t_f32, t_f32) -> t_f32);\n+    ifn!(\"llvm.fma.f64\", fn(t_f64, t_f64, t_f64) -> t_f64);\n+\n+    ifn!(\"llvm.fabs.f32\", fn(t_f32) -> t_f32);\n+    ifn!(\"llvm.fabs.f64\", fn(t_f64) -> t_f64);\n+\n+    ifn!(\"llvm.floor.f32\", fn(t_f32) -> t_f32);\n+    ifn!(\"llvm.floor.f64\", fn(t_f64) -> t_f64);\n+    ifn!(\"llvm.ceil.f32\", fn(t_f32) -> t_f32);\n+    ifn!(\"llvm.ceil.f64\", fn(t_f64) -> t_f64);\n+    ifn!(\"llvm.trunc.f32\", fn(t_f32) -> t_f32);\n+    ifn!(\"llvm.trunc.f64\", fn(t_f64) -> t_f64);\n+\n+    ifn!(\"llvm.rint.f32\", fn(t_f32) -> t_f32);\n+    ifn!(\"llvm.rint.f64\", fn(t_f64) -> t_f64);\n+    ifn!(\"llvm.nearbyint.f32\", fn(t_f32) -> t_f32);\n+    ifn!(\"llvm.nearbyint.f64\", fn(t_f64) -> t_f64);\n+\n+    ifn!(\"llvm.ctpop.i8\", fn(t_i8) -> t_i8);\n+    ifn!(\"llvm.ctpop.i16\", fn(t_i16) -> t_i16);\n+    ifn!(\"llvm.ctpop.i32\", fn(t_i32) -> t_i32);\n+    ifn!(\"llvm.ctpop.i64\", fn(t_i64) -> t_i64);\n+\n+    ifn!(\"llvm.ctlz.i8\", fn(t_i8 , i1) -> t_i8);\n+    ifn!(\"llvm.ctlz.i16\", fn(t_i16, i1) -> t_i16);\n+    ifn!(\"llvm.ctlz.i32\", fn(t_i32, i1) -> t_i32);\n+    ifn!(\"llvm.ctlz.i64\", fn(t_i64, i1) -> t_i64);\n+\n+    ifn!(\"llvm.cttz.i8\", fn(t_i8 , i1) -> t_i8);\n+    ifn!(\"llvm.cttz.i16\", fn(t_i16, i1) -> t_i16);\n+    ifn!(\"llvm.cttz.i32\", fn(t_i32, i1) -> t_i32);\n+    ifn!(\"llvm.cttz.i64\", fn(t_i64, i1) -> t_i64);\n+\n+    ifn!(\"llvm.bswap.i16\", fn(t_i16) -> t_i16);\n+    ifn!(\"llvm.bswap.i32\", fn(t_i32) -> t_i32);\n+    ifn!(\"llvm.bswap.i64\", fn(t_i64) -> t_i64);\n+\n+    ifn!(\"llvm.sadd.with.overflow.i8\", fn(t_i8, t_i8) -> mk_struct!{t_i8, i1});\n+    ifn!(\"llvm.sadd.with.overflow.i16\", fn(t_i16, t_i16) -> mk_struct!{t_i16, i1});\n+    ifn!(\"llvm.sadd.with.overflow.i32\", fn(t_i32, t_i32) -> mk_struct!{t_i32, i1});\n+    ifn!(\"llvm.sadd.with.overflow.i64\", fn(t_i64, t_i64) -> mk_struct!{t_i64, i1});\n+\n+    ifn!(\"llvm.uadd.with.overflow.i8\", fn(t_i8, t_i8) -> mk_struct!{t_i8, i1});\n+    ifn!(\"llvm.uadd.with.overflow.i16\", fn(t_i16, t_i16) -> mk_struct!{t_i16, i1});\n+    ifn!(\"llvm.uadd.with.overflow.i32\", fn(t_i32, t_i32) -> mk_struct!{t_i32, i1});\n+    ifn!(\"llvm.uadd.with.overflow.i64\", fn(t_i64, t_i64) -> mk_struct!{t_i64, i1});\n+\n+    ifn!(\"llvm.ssub.with.overflow.i8\", fn(t_i8, t_i8) -> mk_struct!{t_i8, i1});\n+    ifn!(\"llvm.ssub.with.overflow.i16\", fn(t_i16, t_i16) -> mk_struct!{t_i16, i1});\n+    ifn!(\"llvm.ssub.with.overflow.i32\", fn(t_i32, t_i32) -> mk_struct!{t_i32, i1});\n+    ifn!(\"llvm.ssub.with.overflow.i64\", fn(t_i64, t_i64) -> mk_struct!{t_i64, i1});\n+\n+    ifn!(\"llvm.usub.with.overflow.i8\", fn(t_i8, t_i8) -> mk_struct!{t_i8, i1});\n+    ifn!(\"llvm.usub.with.overflow.i16\", fn(t_i16, t_i16) -> mk_struct!{t_i16, i1});\n+    ifn!(\"llvm.usub.with.overflow.i32\", fn(t_i32, t_i32) -> mk_struct!{t_i32, i1});\n+    ifn!(\"llvm.usub.with.overflow.i64\", fn(t_i64, t_i64) -> mk_struct!{t_i64, i1});\n+\n+    ifn!(\"llvm.smul.with.overflow.i8\", fn(t_i8, t_i8) -> mk_struct!{t_i8, i1});\n+    ifn!(\"llvm.smul.with.overflow.i16\", fn(t_i16, t_i16) -> mk_struct!{t_i16, i1});\n+    ifn!(\"llvm.smul.with.overflow.i32\", fn(t_i32, t_i32) -> mk_struct!{t_i32, i1});\n+    ifn!(\"llvm.smul.with.overflow.i64\", fn(t_i64, t_i64) -> mk_struct!{t_i64, i1});\n+\n+    ifn!(\"llvm.umul.with.overflow.i8\", fn(t_i8, t_i8) -> mk_struct!{t_i8, i1});\n+    ifn!(\"llvm.umul.with.overflow.i16\", fn(t_i16, t_i16) -> mk_struct!{t_i16, i1});\n+    ifn!(\"llvm.umul.with.overflow.i32\", fn(t_i32, t_i32) -> mk_struct!{t_i32, i1});\n+    ifn!(\"llvm.umul.with.overflow.i64\", fn(t_i64, t_i64) -> mk_struct!{t_i64, i1});\n+\n+    ifn!(\"llvm.lifetime.start\", fn(t_i64,i8p) -> void);\n+    ifn!(\"llvm.lifetime.end\", fn(t_i64, i8p) -> void);\n+\n+    ifn!(\"llvm.expect.i1\", fn(i1, i1) -> i1);\n+    ifn!(\"llvm.assume\", fn(i1) -> void);\n \n     // Some intrinsics were introduced in later versions of LLVM, but they have\n     // fallbacks in libc or libm and such. Currently, all of these intrinsics\n@@ -882,7 +882,7 @@ fn declare_intrinsic(ccx: &CrateContext, key: & &'static str) -> Option<ValueRef\n         ($name:expr, $cname:ident ($($arg:expr),*) -> $ret:expr) => (\n             if unsafe { llvm::LLVMVersionMinor() >= 4 } {\n                 // The `if key == $name` is already in ifn!\n-                ifn!($name fn($($arg),*) -> $ret);\n+                ifn!($name, fn($($arg),*) -> $ret);\n             } else if *key == $name {\n                 let f = base::decl_cdecl_fn(ccx, stringify!($cname),\n                                       Type::func(&[$($arg),*], &$ret),\n@@ -900,8 +900,8 @@ fn declare_intrinsic(ccx: &CrateContext, key: & &'static str) -> Option<ValueRef\n \n \n     if ccx.sess().opts.debuginfo != NoDebugInfo {\n-        ifn!(\"llvm.dbg.declare\" fn(Type::metadata(ccx), Type::metadata(ccx)) -> void);\n-        ifn!(\"llvm.dbg.value\" fn(Type::metadata(ccx), t_i64, Type::metadata(ccx)) -> void);\n+        ifn!(\"llvm.dbg.declare\", fn(Type::metadata(ccx), Type::metadata(ccx)) -> void);\n+        ifn!(\"llvm.dbg.value\", fn(Type::metadata(ccx), t_i64, Type::metadata(ccx)) -> void);\n     }\n     return None;\n }"}, {"sha": "be44aa99f49d764aca3b65f8dc8baa2d375081da", "filename": "src/libstd/sys/common/backtrace.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/e0b4287df6635158043e7015d89b619af7f7748d/src%2Flibstd%2Fsys%2Fcommon%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0b4287df6635158043e7015d89b619af7f7748d/src%2Flibstd%2Fsys%2Fcommon%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fbacktrace.rs?ref=e0b4287df6635158043e7015d89b619af7f7748d", "patch": "@@ -88,7 +88,7 @@ pub fn demangle(writer: &mut Writer, s: &str) -> IoResult<()> {\n             while rest.len() > 0 {\n                 if rest.starts_with(\"$\") {\n                     macro_rules! demangle {\n-                        ($($pat:expr => $demangled:expr),*) => ({\n+                        ($($pat:expr, => $demangled:expr),*) => ({\n                             $(if rest.starts_with($pat) {\n                                 try!(writer.write_str($demangled));\n                                 rest = rest.slice_from($pat.len());\n@@ -103,22 +103,22 @@ pub fn demangle(writer: &mut Writer, s: &str) -> IoResult<()> {\n \n                     // see src/librustc/back/link.rs for these mappings\n                     demangle! (\n-                        \"$SP$\" => \"@\",\n-                        \"$UP$\" => \"Box\",\n-                        \"$RP$\" => \"*\",\n-                        \"$BP$\" => \"&\",\n-                        \"$LT$\" => \"<\",\n-                        \"$GT$\" => \">\",\n-                        \"$LP$\" => \"(\",\n-                        \"$RP$\" => \")\",\n-                        \"$C$\"  => \",\",\n+                        \"$SP$\", => \"@\",\n+                        \"$UP$\", => \"Box\",\n+                        \"$RP$\", => \"*\",\n+                        \"$BP$\", => \"&\",\n+                        \"$LT$\", => \"<\",\n+                        \"$GT$\", => \">\",\n+                        \"$LP$\", => \"(\",\n+                        \"$RP$\", => \")\",\n+                        \"$C$\", => \",\",\n \n                         // in theory we can demangle any Unicode code point, but\n                         // for simplicity we just catch the common ones.\n-                        \"$u{20}\" => \" \",\n-                        \"$u{27}\" => \"'\",\n-                        \"$u{5b}\" => \"[\",\n-                        \"$u{5d}\" => \"]\"\n+                        \"$u{20}\", => \" \",\n+                        \"$u{27}\", => \"'\",\n+                        \"$u{5b}\", => \"[\",\n+                        \"$u{5d}\", => \"]\"\n                     )\n                 } else {\n                     let idx = match rest.find('$') {"}, {"sha": "1f2db6240653d05676c22cf2617dd24084e56820", "filename": "src/test/compile-fail/macro-input-future-proofing.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e0b4287df6635158043e7015d89b619af7f7748d/src%2Ftest%2Fcompile-fail%2Fmacro-input-future-proofing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0b4287df6635158043e7015d89b619af7f7748d/src%2Ftest%2Fcompile-fail%2Fmacro-input-future-proofing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-input-future-proofing.rs?ref=e0b4287df6635158043e7015d89b619af7f7748d", "patch": "@@ -9,18 +9,18 @@\n // except according to those terms.\n \n macro_rules! errors_everywhere {\n-    ($ty:ty <) => () //~ ERROR `$ty:ty` is followed by `<`, which is not allowed for `ty` fragments\n-    ($ty:ty < foo ,) => () //~ ERROR `$ty:ty` is followed by `<`, which is not allowed for `ty`\n-    ($ty:ty , ) => ()\n-    ( ( $ty:ty ) ) => ()\n-    ( { $ty:ty } ) => ()\n-    ( [ $ty:ty ] ) => ()\n-    ($bl:block < ) => ()\n-    ($pa:pat >) => () //~ ERROR `$pa:pat` is followed by `>` which is not allowed for `pat`\n-    ($pa:pat , ) => ()\n-    ($pa:pat | ) => ()\n-    ($pa:pat $pb:pat $ty:ty ,) => ()\n-    ($($ty:ty)-+) => () //~ ERROR `$ty:ty` is followed by `-` which is not allowed for `ty`\n+    ($ty:ty <) => (); //~ ERROR `$ty:ty` is followed by `<`, which is not allowed for `ty`\n+    ($ty:ty < foo ,) => (); //~ ERROR `$ty:ty` is followed by `<`, which is not allowed for `ty`\n+    ($ty:ty , ) => ();\n+    ( ( $ty:ty ) ) => ();\n+    ( { $ty:ty } ) => ();\n+    ( [ $ty:ty ] ) => ();\n+    ($bl:block < ) => ();\n+    ($pa:pat >) => (); //~ ERROR `$pa:pat` is followed by `>`, which is not allowed for `pat`\n+    ($pa:pat , ) => ();\n+    ($pa:pat | ) => (); //~ ERROR `$pa:pat` is followed by `|`\n+    ($pa:pat $pb:pat $ty:ty ,) => ();\n+    ($($ty:ty)-+) => (); //~ ERROR `$ty:ty` is followed by `-`, which is not allowed for `ty`\n }\n \n fn main() { }"}, {"sha": "28b346c9ed4d0532e240902677419fa09dbd8375", "filename": "src/test/run-pass/const-polymorphic-paths.rs", "status": "modified", "additions": 25, "deletions": 26, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/e0b4287df6635158043e7015d89b619af7f7748d/src%2Ftest%2Frun-pass%2Fconst-polymorphic-paths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0b4287df6635158043e7015d89b619af7f7748d/src%2Ftest%2Frun-pass%2Fconst-polymorphic-paths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-polymorphic-paths.rs?ref=e0b4287df6635158043e7015d89b619af7f7748d", "patch": "@@ -29,7 +29,7 @@ fn odd(x: uint) -> bool { x % 2 == 1 }\n fn dummy_rng() -> DummyRng { DummyRng::new_unseeded() }\n \n macro_rules! tests {\n-    ($($expr:expr: $ty:ty /($($test:expr),*);)+) => (pub fn main() {$({\n+    ($($expr:expr, $ty:ty, ($($test:expr),*);)+) => (pub fn main() {$({\n         const C: $ty = $expr;\n         static S: $ty = $expr;\n         assert!(eq(C($($test),*), $expr($($test),*)));\n@@ -40,45 +40,44 @@ macro_rules! tests {\n \n tests! {\n     // Free function.\n-    id: fn(int) -> int /(5);\n-    id::<int>: fn(int) -> int /(5);\n+    id, fn(int) -> int, (5);\n+    id::<int>, fn(int) -> int, (5);\n \n     // Enum variant constructor.\n-    Some: fn(int) -> Option<int> /(5);\n-    Some::<int>: fn(int) -> Option<int> /(5);\n+    Some, fn(int) -> Option<int>, (5);\n+    Some::<int>, fn(int) -> Option<int>, (5);\n \n     // Tuple struct constructor.\n-    Newt: fn(int) -> Newt<int> /(5);\n-    Newt::<int>: fn(int) -> Newt<int> /(5);\n+    Newt, fn(int) -> Newt<int>, (5);\n+    Newt::<int>, fn(int) -> Newt<int>, (5);\n \n     // Inherent static methods.\n-    Vec::new: fn() -> Vec<()> /();\n-    Vec::<()>::new: fn() -> Vec<()> /();\n-    Vec::with_capacity: fn(uint) -> Vec<()> /(5);\n-    Vec::<()>::with_capacity: fn(uint) -> Vec<()> /(5);\n-    Bitv::from_fn: fn(uint, fn(uint) -> bool) -> Bitv /(5, odd);\n-    Bitv::from_fn::<fn(uint) -> bool>: fn(uint, fn(uint) -> bool) -> Bitv /(5, odd);\n+    Vec::new, fn() -> Vec<()>, ();\n+    Vec::<()>::new, fn() -> Vec<()>, ();\n+    Vec::with_capacity, fn(uint) -> Vec<()>, (5);\n+    Vec::<()>::with_capacity, fn(uint) -> Vec<()>, (5);\n+    Bitv::from_fn, fn(uint, fn(uint) -> bool) -> Bitv, (5, odd);\n+    Bitv::from_fn::<fn(uint) -> bool>, fn(uint, fn(uint) -> bool) -> Bitv, (5, odd);\n \n     // Inherent non-static method.\n-    Vec::map_in_place: fn(Vec<u8>, fn(u8) -> i8) -> Vec<i8>\n-        /(vec![b'f', b'o', b'o'], u8_as_i8);\n-    Vec::map_in_place::<i8, fn(u8) -> i8>: fn(Vec<u8>, fn(u8) -> i8) -> Vec<i8>\n-        /(vec![b'f', b'o', b'o'], u8_as_i8);\n+    Vec::map_in_place, fn(Vec<u8>, fn(u8) -> i8) -> Vec<i8>, (vec![b'f', b'o', b'o'], u8_as_i8);\n+    Vec::map_in_place::<i8, fn(u8) -> i8>, fn(Vec<u8>, fn(u8) -> i8) -> Vec<i8>,\n+        (vec![b'f', b'o', b'o'], u8_as_i8);\n     // FIXME these break with \"type parameter might not appear here pointing at `<u8>`.\n     // Vec::<u8>::map_in_place: fn(Vec<u8>, fn(u8) -> i8) -> Vec<i8>\n-    //     /(vec![b'f', b'o', b'o'], u8_as_i8);\n+    //    , (vec![b'f', b'o', b'o'], u8_as_i8);\n     // Vec::<u8>::map_in_place::<i8, fn(u8) -> i8>: fn(Vec<u8>, fn(u8) -> i8) -> Vec<i8>\n-    //     /(vec![b'f', b'o', b'o'], u8_as_i8);\n+    //    , (vec![b'f', b'o', b'o'], u8_as_i8);\n \n     // Trait static methods.\n     // FIXME qualified path expressions aka UFCS i.e. <T as Trait>::method.\n-    Default::default: fn() -> int /();\n-    Rand::rand: fn(&mut DummyRng) -> int /(&mut dummy_rng());\n-    Rand::rand::<DummyRng>: fn(&mut DummyRng) -> int /(&mut dummy_rng());\n+    Default::default, fn() -> int, ();\n+    Rand::rand, fn(&mut DummyRng) -> int, (&mut dummy_rng());\n+    Rand::rand::<DummyRng>, fn(&mut DummyRng) -> int, (&mut dummy_rng());\n \n     // Trait non-static methods.\n-    Clone::clone: fn(&int) -> int /(&5);\n-    FromIterator::from_iter: fn(OptionIter<int>) -> Vec<int> /(Some(5).into_iter());\n-    FromIterator::from_iter::<OptionIter<int>>: fn(OptionIter<int>) -> Vec<int>\n-        /(Some(5).into_iter());\n+    Clone::clone, fn(&int) -> int, (&5);\n+    FromIterator::from_iter, fn(OptionIter<int>) -> Vec<int>, (Some(5).into_iter());\n+    FromIterator::from_iter::<OptionIter<int>>, fn(OptionIter<int>) -> Vec<int>\n+       , (Some(5).into_iter());\n }"}, {"sha": "0293c4e36ac59c09f89f47ba8c92d51e1e0a74e1", "filename": "src/test/run-pass/nullable-pointer-iotareduction.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e0b4287df6635158043e7015d89b619af7f7748d/src%2Ftest%2Frun-pass%2Fnullable-pointer-iotareduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0b4287df6635158043e7015d89b619af7f7748d/src%2Ftest%2Frun-pass%2Fnullable-pointer-iotareduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnullable-pointer-iotareduction.rs?ref=e0b4287df6635158043e7015d89b619af7f7748d", "patch": "@@ -35,10 +35,10 @@ impl<T> E<T> {\n }\n \n macro_rules! check_option {\n-    ($e:expr: $T:ty) => {{\n-        check_option!($e: $T, |ptr| assert!(*ptr == $e));\n+    ($e:expr, $T:ty) => {{\n+        check_option!($e, $T, |ptr| assert!(*ptr == $e));\n     }};\n-    ($e:expr: $T:ty, |$v:ident| $chk:expr) => {{\n+    ($e:expr, $T:ty, |$v:ident| $chk:expr) => {{\n         assert!(option::Option::None::<$T>.is_none());\n         let e = $e;\n         let s_ = option::Option::Some::<$T>(e);\n@@ -48,10 +48,10 @@ macro_rules! check_option {\n }\n \n macro_rules! check_fancy {\n-    ($e:expr: $T:ty) => {{\n-        check_fancy!($e: $T, |ptr| assert!(*ptr == $e));\n+    ($e:expr, $T:ty) => {{\n+        check_fancy!($e, $T, |ptr| assert!(*ptr == $e));\n     }};\n-    ($e:expr: $T:ty, |$v:ident| $chk:expr) => {{\n+    ($e:expr, $T:ty, |$v:ident| $chk:expr) => {{\n         assert!(E::Nothing::<$T>((), ((), ()), [23i8; 0]).is_none());\n         let e = $e;\n         let t_ = E::Thing::<$T>(23, e);\n@@ -71,12 +71,12 @@ macro_rules! check_type {\n }\n \n pub fn main() {\n-    check_type!(&17: &int);\n-    check_type!(box 18: Box<int>);\n-    check_type!(\"foo\".to_string(): String);\n-    check_type!(vec!(20, 22): Vec<int> );\n+    check_type!(&17, &int);\n+    check_type!(box 18, Box<int>);\n+    check_type!(\"foo\".to_string(), String);\n+    check_type!(vec!(20, 22), Vec<int> );\n     let mint: uint = unsafe { mem::transmute(main) };\n-    check_type!(main: fn(), |pthing| {\n+    check_type!(main, fn(), |pthing| {\n         assert!(mint == unsafe { mem::transmute(*pthing) })\n     });\n }"}]}