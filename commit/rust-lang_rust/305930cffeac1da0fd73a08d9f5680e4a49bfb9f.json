{"sha": "305930cffeac1da0fd73a08d9f5680e4a49bfb9f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMwNTkzMGNmZmVhYzFkYTBmZDczYTA4ZDlmNTY4MGU0YTQ5YmZiOWY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-06-22T05:12:11Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-06-22T05:12:11Z"}, "message": "Auto merge of #62010 - ecstatic-morse:kill-borrows-of-proj, r=pnkfelix\n\nKill conflicting borrows of places with projections.\n\nResolves #62007.\n\nDue to a bug, the previous version of this check did not actually kill all conflicting borrows unless the borrowed place had no projections. Specifically, `sets.on_entry` will always be empty when `statement_effect` is called. It does not contain the set of borrows which are live at this point in the program.\n\n@pnkfelix describes why this was not caught before in #62007, and created an example where the current borrow checker failed unnecessarily. This PR adds their example as a test, but they will likely want to add some additional ones.\n\nr? @pnkfelix", "tree": {"sha": "8a5facc751be7b4aa6f16efeacb5eaa030aa8603", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8a5facc751be7b4aa6f16efeacb5eaa030aa8603"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/305930cffeac1da0fd73a08d9f5680e4a49bfb9f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/305930cffeac1da0fd73a08d9f5680e4a49bfb9f", "html_url": "https://github.com/rust-lang/rust/commit/305930cffeac1da0fd73a08d9f5680e4a49bfb9f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/305930cffeac1da0fd73a08d9f5680e4a49bfb9f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e562b24ae325f5a31b7ba5873e3db426a14e6342", "url": "https://api.github.com/repos/rust-lang/rust/commits/e562b24ae325f5a31b7ba5873e3db426a14e6342", "html_url": "https://github.com/rust-lang/rust/commit/e562b24ae325f5a31b7ba5873e3db426a14e6342"}, {"sha": "f483269625f4f8f0f73bb3dc35986894fc51248a", "url": "https://api.github.com/repos/rust-lang/rust/commits/f483269625f4f8f0f73bb3dc35986894fc51248a", "html_url": "https://github.com/rust-lang/rust/commit/f483269625f4f8f0f73bb3dc35986894fc51248a"}], "stats": {"total": 219, "additions": 189, "deletions": 30}, "files": [{"sha": "7617d3b997d087b2f857ec05c0b3948fa0e87aca", "filename": "src/librustc_mir/dataflow/impls/borrows.rs", "status": "modified", "additions": 25, "deletions": 30, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/305930cffeac1da0fd73a08d9f5680e4a49bfb9f/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/305930cffeac1da0fd73a08d9f5680e4a49bfb9f/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs?ref=305930cffeac1da0fd73a08d9f5680e4a49bfb9f", "patch": "@@ -193,43 +193,38 @@ impl<'a, 'tcx> Borrows<'a, 'tcx> {\n         place: &Place<'tcx>\n     ) {\n         debug!(\"kill_borrows_on_place: place={:?}\", place);\n-        // Handle the `Place::Local(..)` case first and exit early.\n-        if let Place::Base(PlaceBase::Local(local)) = place {\n-            if let Some(borrow_indices) = self.borrow_set.local_map.get(&local) {\n-                debug!(\"kill_borrows_on_place: borrow_indices={:?}\", borrow_indices);\n-                sets.kill_all(borrow_indices);\n+\n+        if let Some(local) = place.base_local() {\n+            let other_borrows_of_local = self\n+                .borrow_set\n+                .local_map\n+                .get(&local)\n+                .into_iter()\n+                .flat_map(|bs| bs.into_iter());\n+\n+            // If the borrowed place is a local with no projections, all other borrows of this\n+            // local must conflict. This is purely an optimization so we don't have to call\n+            // `places_conflict` for every borrow.\n+            if let Place::Base(PlaceBase::Local(_)) = place {\n+                sets.kill_all(other_borrows_of_local);\n                 return;\n             }\n-        }\n-\n-        // Otherwise, look at all borrows that are live and if they conflict with the assignment\n-        // into our place then we can kill them.\n-        let mut borrows = sets.on_entry.clone();\n-        let _ = borrows.union(sets.gen_set);\n-        for borrow_index in borrows.iter() {\n-            let borrow_data = &self.borrows()[borrow_index];\n-            debug!(\n-                \"kill_borrows_on_place: borrow_index={:?} borrow_data={:?}\",\n-                borrow_index, borrow_data,\n-            );\n \n             // By passing `PlaceConflictBias::NoOverlap`, we conservatively assume that any given\n             // pair of array indices are unequal, so that when `places_conflict` returns true, we\n             // will be assured that two places being compared definitely denotes the same sets of\n             // locations.\n-            if places_conflict::places_conflict(\n-                self.tcx,\n-                self.body,\n-                &borrow_data.borrowed_place,\n-                place,\n-                places_conflict::PlaceConflictBias::NoOverlap,\n-            ) {\n-                debug!(\n-                    \"kill_borrows_on_place: (kill) borrow_index={:?} borrow_data={:?}\",\n-                    borrow_index, borrow_data,\n-                );\n-                sets.kill(borrow_index);\n-            }\n+            let definitely_conflicting_borrows = other_borrows_of_local\n+                .filter(|&&i| {\n+                    places_conflict::places_conflict(\n+                        self.tcx,\n+                        self.body,\n+                        &self.borrow_set.borrows[i].borrowed_place,\n+                        place,\n+                        places_conflict::PlaceConflictBias::NoOverlap)\n+                });\n+\n+            sets.kill_all(definitely_conflicting_borrows);\n         }\n     }\n }"}, {"sha": "f6fbea821b52152fd19d0563f2534542b0bf7836", "filename": "src/test/run-pass/borrowck/issue-62007-assign-box.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/305930cffeac1da0fd73a08d9f5680e4a49bfb9f/src%2Ftest%2Frun-pass%2Fborrowck%2Fissue-62007-assign-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/305930cffeac1da0fd73a08d9f5680e4a49bfb9f/src%2Ftest%2Frun-pass%2Fborrowck%2Fissue-62007-assign-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck%2Fissue-62007-assign-box.rs?ref=305930cffeac1da0fd73a08d9f5680e4a49bfb9f", "patch": "@@ -0,0 +1,27 @@\n+// run-pass\n+\n+// Issue #62007: assigning over a deref projection of a box (in this\n+// case, `*list = n;`) should be able to kill all borrows of `*list`,\n+// so that `*list` can be borrowed on the next iteration through the\n+// loop.\n+\n+#![allow(dead_code)]\n+\n+struct List<T> {\n+    value: T,\n+    next: Option<Box<List<T>>>,\n+}\n+\n+fn to_refs<T>(mut list: Box<&mut List<T>>) -> Vec<&mut T> {\n+    let mut result = vec![];\n+    loop {\n+        result.push(&mut list.value);\n+        if let Some(n) = list.next.as_mut() {\n+            *list = n;\n+        } else {\n+            return result;\n+        }\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "5b21c083816a4666bed2c912fdcc923e5393703d", "filename": "src/test/run-pass/borrowck/issue-62007-assign-field.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/305930cffeac1da0fd73a08d9f5680e4a49bfb9f/src%2Ftest%2Frun-pass%2Fborrowck%2Fissue-62007-assign-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/305930cffeac1da0fd73a08d9f5680e4a49bfb9f/src%2Ftest%2Frun-pass%2Fborrowck%2Fissue-62007-assign-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck%2Fissue-62007-assign-field.rs?ref=305930cffeac1da0fd73a08d9f5680e4a49bfb9f", "patch": "@@ -0,0 +1,26 @@\n+// run-pass\n+\n+// Issue #62007: assigning over a field projection (`list.0 = n;` in\n+// this case) should be able to kill all borrows of `list.0`, so that\n+// `list.0` can be borrowed on the next iteration through the loop.\n+\n+#![allow(dead_code)]\n+\n+struct List<T> {\n+    value: T,\n+    next: Option<Box<List<T>>>,\n+}\n+\n+fn to_refs<T>(mut list: (&mut List<T>,)) -> Vec<&mut T> {\n+    let mut result = vec![];\n+    loop {\n+        result.push(&mut (list.0).value);\n+        if let Some(n) = (list.0).next.as_mut() {\n+            list.0 = n;\n+        } else {\n+            return result;\n+        }\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "3ea5d3a7ad007e5222bb5eabc046bd900adc1f7a", "filename": "src/test/ui/nll/issue-62007-assign-const-index.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/305930cffeac1da0fd73a08d9f5680e4a49bfb9f/src%2Ftest%2Fui%2Fnll%2Fissue-62007-assign-const-index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/305930cffeac1da0fd73a08d9f5680e4a49bfb9f/src%2Ftest%2Fui%2Fnll%2Fissue-62007-assign-const-index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-62007-assign-const-index.rs?ref=305930cffeac1da0fd73a08d9f5680e4a49bfb9f", "patch": "@@ -0,0 +1,32 @@\n+// Issue #62007: assigning over a const-index projection of an array\n+// (in this case, `list[I] = n;`) should in theory be able to kill all borrows\n+// of `list[0]`, so that `list[0]` could be borrowed on the next\n+// iteration through the loop.\n+//\n+// Currently the compiler does not allow this. We may want to consider\n+// loosening that restriction in the future. (However, doing so would\n+// at *least* require T-lang team approval, and probably an RFC; e.g.\n+// such loosening might make complicate the user's mental mode; it\n+// also would make code more brittle in the face of refactorings that\n+// replace constants with variables.\n+\n+#![allow(dead_code)]\n+\n+struct List<T> {\n+    value: T,\n+    next: Option<Box<List<T>>>,\n+}\n+\n+fn to_refs<T>(mut list: [&mut List<T>; 2]) -> Vec<&mut T> {\n+    let mut result = vec![];\n+    loop {\n+        result.push(&mut list[0].value); //~ ERROR cannot borrow `list[_].value` as mutable\n+        if let Some(n) = list[0].next.as_mut() { //~ ERROR cannot borrow `list[_].next` as mutable\n+            list[0] = n;\n+        } else {\n+            return result;\n+        }\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "758a14d0177055b7d1d045aa386787c3f88a6595", "filename": "src/test/ui/nll/issue-62007-assign-const-index.stderr", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/305930cffeac1da0fd73a08d9f5680e4a49bfb9f/src%2Ftest%2Fui%2Fnll%2Fissue-62007-assign-const-index.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/305930cffeac1da0fd73a08d9f5680e4a49bfb9f/src%2Ftest%2Fui%2Fnll%2Fissue-62007-assign-const-index.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-62007-assign-const-index.stderr?ref=305930cffeac1da0fd73a08d9f5680e4a49bfb9f", "patch": "@@ -0,0 +1,27 @@\n+error[E0499]: cannot borrow `list[_].value` as mutable more than once at a time\n+  --> $DIR/issue-62007-assign-const-index.rs:23:21\n+   |\n+LL | fn to_refs<T>(mut list: [&mut List<T>; 2]) -> Vec<&mut T> {\n+   |                          - let's call the lifetime of this reference `'1`\n+...\n+LL |         result.push(&mut list[0].value);\n+   |                     ^^^^^^^^^^^^^^^^^^ mutable borrow starts here in previous iteration of loop\n+...\n+LL |             return result;\n+   |                    ------ returning this value requires that `list[_].value` is borrowed for `'1`\n+\n+error[E0499]: cannot borrow `list[_].next` as mutable more than once at a time\n+  --> $DIR/issue-62007-assign-const-index.rs:24:26\n+   |\n+LL | fn to_refs<T>(mut list: [&mut List<T>; 2]) -> Vec<&mut T> {\n+   |                          - let's call the lifetime of this reference `'1`\n+...\n+LL |         if let Some(n) = list[0].next.as_mut() {\n+   |                          ^^^^^^^^^^^^---------\n+   |                          |\n+   |                          mutable borrow starts here in previous iteration of loop\n+   |                          argument requires that `list[_].next` is borrowed for `'1`\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0499`."}, {"sha": "29d92b7b85c1210c333d581e94e69c85c4c31113", "filename": "src/test/ui/nll/issue-62007-assign-differing-fields.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/305930cffeac1da0fd73a08d9f5680e4a49bfb9f/src%2Ftest%2Fui%2Fnll%2Fissue-62007-assign-differing-fields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/305930cffeac1da0fd73a08d9f5680e4a49bfb9f/src%2Ftest%2Fui%2Fnll%2Fissue-62007-assign-differing-fields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-62007-assign-differing-fields.rs?ref=305930cffeac1da0fd73a08d9f5680e4a49bfb9f", "patch": "@@ -0,0 +1,25 @@\n+// Double-check we didn't go too far with our resolution to issue\n+// #62007: assigning over a field projection (`list.1 = n;` in this\n+// case) should kill only borrows of `list.1`; `list.0` can *not*\n+// necessarily be borrowed on the next iteration through the loop.\n+\n+#![allow(dead_code)]\n+\n+struct List<T> {\n+    value: T,\n+    next: Option<Box<List<T>>>,\n+}\n+\n+fn to_refs<'a, T>(mut list: (&'a mut List<T>, &'a mut List<T>)) -> Vec<&'a mut T> {\n+    let mut result = vec![];\n+    loop {\n+        result.push(&mut (list.0).value); //~ ERROR cannot borrow `list.0.value` as mutable\n+        if let Some(n) = (list.0).next.as_mut() { //~ ERROR cannot borrow `list.0.next` as mutable\n+            list.1 = n;\n+        } else {\n+            return result;\n+        }\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "f942d7628b5078b89cae1ae5d49ff0a022751db8", "filename": "src/test/ui/nll/issue-62007-assign-differing-fields.stderr", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/305930cffeac1da0fd73a08d9f5680e4a49bfb9f/src%2Ftest%2Fui%2Fnll%2Fissue-62007-assign-differing-fields.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/305930cffeac1da0fd73a08d9f5680e4a49bfb9f/src%2Ftest%2Fui%2Fnll%2Fissue-62007-assign-differing-fields.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-62007-assign-differing-fields.stderr?ref=305930cffeac1da0fd73a08d9f5680e4a49bfb9f", "patch": "@@ -0,0 +1,27 @@\n+error[E0499]: cannot borrow `list.0.value` as mutable more than once at a time\n+  --> $DIR/issue-62007-assign-differing-fields.rs:16:21\n+   |\n+LL | fn to_refs<'a, T>(mut list: (&'a mut List<T>, &'a mut List<T>)) -> Vec<&'a mut T> {\n+   |            -- lifetime `'a` defined here\n+...\n+LL |         result.push(&mut (list.0).value);\n+   |                     ^^^^^^^^^^^^^^^^^^^ mutable borrow starts here in previous iteration of loop\n+...\n+LL |             return result;\n+   |                    ------ returning this value requires that `list.0.value` is borrowed for `'a`\n+\n+error[E0499]: cannot borrow `list.0.next` as mutable more than once at a time\n+  --> $DIR/issue-62007-assign-differing-fields.rs:17:26\n+   |\n+LL | fn to_refs<'a, T>(mut list: (&'a mut List<T>, &'a mut List<T>)) -> Vec<&'a mut T> {\n+   |            -- lifetime `'a` defined here\n+...\n+LL |         if let Some(n) = (list.0).next.as_mut() {\n+   |                          ^^^^^^^^^^^^^---------\n+   |                          |\n+   |                          mutable borrow starts here in previous iteration of loop\n+   |                          argument requires that `list.0.next` is borrowed for `'a`\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0499`."}]}