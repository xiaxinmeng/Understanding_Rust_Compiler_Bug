{"sha": "81fc51a8d7f4ccb4f0a7b2c7718a2926d9842f59", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgxZmM1MWE4ZDdmNGNjYjRmMGE3YjJjNzcxOGEyOTI2ZDk4NDJmNTk=", "commit": {"author": {"name": "Eric Holk", "email": "eholk@mozilla.com", "date": "2011-06-17T21:32:43Z"}, "committer": {"name": "Eric Holk", "email": "eholk@mozilla.com", "date": "2011-06-17T22:17:46Z"}, "message": "Started using deep_copy for spawn arguments.", "tree": {"sha": "ec7fc68c832b78645cd2e1da1f282ee2aa3c8293", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ec7fc68c832b78645cd2e1da1f282ee2aa3c8293"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/81fc51a8d7f4ccb4f0a7b2c7718a2926d9842f59", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/81fc51a8d7f4ccb4f0a7b2c7718a2926d9842f59", "html_url": "https://github.com/rust-lang/rust/commit/81fc51a8d7f4ccb4f0a7b2c7718a2926d9842f59", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/81fc51a8d7f4ccb4f0a7b2c7718a2926d9842f59/comments", "author": null, "committer": null, "parents": [{"sha": "71e1db596cebc35e2218ae011da2c76ee4ed5532", "url": "https://api.github.com/repos/rust-lang/rust/commits/71e1db596cebc35e2218ae011da2c76ee4ed5532", "html_url": "https://github.com/rust-lang/rust/commit/71e1db596cebc35e2218ae011da2c76ee4ed5532"}], "stats": {"total": 101, "additions": 86, "deletions": 15}, "files": [{"sha": "9e28e43bd73c7f535f94382d9b07023524a1cb3a", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 79, "deletions": 15, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/81fc51a8d7f4ccb4f0a7b2c7718a2926d9842f59/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81fc51a8d7f4ccb4f0a7b2c7718a2926d9842f59/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=81fc51a8d7f4ccb4f0a7b2c7718a2926d9842f59", "patch": "@@ -2429,8 +2429,7 @@ type val_pair_and_ty_fn =\n // Iterates through the elements of a structural type.\n fn iter_structural_ty(&@block_ctxt cx, ValueRef v, &ty::t t, val_and_ty_fn f)\n    -> result {\n-    fn adaptor_fn(val_and_ty_fn f, &@block_ctxt cx, ValueRef av, ValueRef bv,\n-                  ty::t t) -> result {\n+    fn adaptor_fn(val_and_ty_fn f, &@block_ctxt cx, ValueRef av, ValueRef bv,                  ty::t t) -> result {\n         ret f(cx, av, t);\n     }\n     ret iter_structural_ty_full(cx, v, v, t, bind adaptor_fn(f, _, _, _, _));\n@@ -6079,6 +6078,11 @@ fn trans_chan(&@block_ctxt cx, &@ast::expr e, &ast::ann ann) -> result {\n     auto chan_raw_val =\n         bcx.build.Call(bcx.fcx.lcx.ccx.upcalls.new_chan,\n                        [bcx.fcx.lltaskptr, prt_val]);\n+    ret chan_raw_to_val(bcx, e, ann, chan_raw_val);\n+}\n+\n+fn chan_raw_to_val(&@block_ctxt bcx, &@ast::expr e,  &ast::ann ann,\n+                   ValueRef chan_raw_val) -> result {\n     auto chan_ty = node_ann_type(bcx.fcx.lcx.ccx, ann);\n     auto chan_llty = type_of(bcx.fcx.lcx.ccx, e.span, chan_ty);\n     auto chan_val = bcx.build.PointerCast(chan_raw_val, chan_llty);\n@@ -6122,16 +6126,28 @@ fn trans_spawn(&@block_ctxt cx, &ast::spawn_dom dom, &option::t[str] name,\n     //\n     // 5. Oh yeah, we have to create the task before we start it...\n \n+    // But first, we'll create a task.\n+\n+    let ValueRef lltname = C_str(bcx.fcx.lcx.ccx, tname);\n+    auto new_task =\n+        bcx.build.Call(bcx.fcx.lcx.ccx.upcalls.new_task,\n+                       [bcx.fcx.lltaskptr, lltname]);\n+\n     // Translate the arguments, remembering their types and where the values\n     // ended up.\n \n     let vec[ty::t] arg_tys = [];\n     let vec[ValueRef] arg_vals = [];\n     for (@ast::expr e in args) {\n+        auto e_ty = ty::expr_ty(cx.fcx.lcx.ccx.tcx, e);\n         auto arg = trans_expr(bcx, e);\n+\n+        arg = deep_copy(arg.bcx, arg.val, e_ty);\n+\n         bcx = arg.bcx;\n+\n         vec::push[ValueRef](arg_vals, arg.val);\n-        vec::push[ty::t](arg_tys, ty::expr_ty(cx.fcx.lcx.ccx.tcx, e));\n+        vec::push[ty::t](arg_tys, e_ty);\n     }\n     // Make the tuple.\n \n@@ -6152,24 +6168,14 @@ fn trans_spawn(&@block_ctxt cx, &ast::spawn_dom dom, &option::t[str] name,\n         bcx.build.Store(v, target);\n         i += 1u;\n     }\n-    // Now we're ready to do the upcall.\n-\n-    // But first, we'll create a task.\n-\n-    let ValueRef lltname = C_str(bcx.fcx.lcx.ccx, tname);\n-    auto new_task =\n-        bcx.build.Call(bcx.fcx.lcx.ccx.upcalls.new_task,\n-                       [bcx.fcx.lltaskptr, lltname]);\n-    // Okay, start the task.\n \n-    auto llargs_i = bcx.build.PointerCast(llargs.val, T_int());\n     // Generate the wrapper function\n-\n     auto wrapper = mk_spawn_wrapper(bcx, func, args_ty);\n     bcx = wrapper.bcx;\n     auto llfnptr_i = bcx.build.PointerCast(wrapper.val, T_int());\n-    // And start the task\n \n+    // And start the task\n+    auto llargs_i = bcx.build.PointerCast(llargs.val, T_int());\n     auto args_size = size_of(bcx, args_ty).val;\n     bcx.build.Call(bcx.fcx.lcx.ccx.upcalls.start_task,\n                    [bcx.fcx.lltaskptr, new_task, llfnptr_i, llargs_i,\n@@ -6229,6 +6235,64 @@ fn mk_spawn_wrapper(&@block_ctxt cx, &@ast::expr func, &ty::t args_ty) ->\n     ret res(cx, llfndecl);\n }\n \n+// Does a deep copy of a value. This is needed for passing arguments to child\n+// tasks, and for sending things through channels. There are probably some\n+// uniqueness optimizations and things we can do here for tasks in the same\n+// domain.\n+fn deep_copy(&@block_ctxt bcx, ValueRef v, ty::t t) -> result {\n+    auto tcx = bcx.fcx.lcx.ccx.tcx;\n+    if(ty::type_is_scalar(tcx, t)) {\n+        ret res(bcx, v);\n+    }\n+    /*\n+      else if(ty::type_is_chan(tcx, t)) {\n+      // If this is a channel, we need to clone it.\n+      log_err \"Generating clone call for channel argument.\";\n+      \n+      log_err #fmt(\"ty(clone_chan) = %s\", \n+      val_str(bcx.fcx.lcx.ccx.tn,\n+      bcx.fcx.lcx.ccx.upcalls.clone_chan));\n+      \n+      log_err #fmt(\"ty(lltaskptr) = %s\", \n+      val_str(bcx.fcx.lcx.ccx.tn, \n+      bcx.fcx.lltaskptr));\n+      \n+      log_err #fmt(\"ty(new_task) = %s\", \n+      val_str(bcx.fcx.lcx.ccx.tn, \n+      new_task));\n+      \n+      log_err #fmt(\"ty(chan) = %s\", \n+      val_str(bcx.fcx.lcx.ccx.tn, \n+      arg.val));\n+      \n+      auto chan_ptr = bcx.build.PointerCast(arg.val, T_opaque_chan_ptr());\n+      \n+      auto chan_raw_val = \n+      bcx.build.Call(bcx.fcx.lcx.ccx.upcalls.clone_chan,\n+      [bcx.fcx.lltaskptr, new_task, chan_ptr]);\n+      \n+      arg = chan_raw_to_val(bcx, e, ann, chan_raw_val);\n+      \n+      log_err \"Done\";\n+      } \n+    */\n+    else if(ty::type_is_structural(tcx, t)) {\n+        fn inner_deep_copy(&@block_ctxt bcx, ValueRef v, ty::t t) -> result {\n+            auto tcx = bcx.fcx.lcx.ccx.tcx;\n+    \n+            log_err \"Unimplemented type for deep_copy.\";\n+            fail;\n+        }\n+\n+        ret iter_structural_ty(bcx, v, t, inner_deep_copy);\n+    }\n+    else {\n+        bcx.fcx.lcx.ccx.sess.bug(\"unexpected type in \" +\n+                                \"trans::deep_copy: \" +\n+                                ty_to_str(tcx, t));\n+    }\n+}\n+\n fn trans_send(&@block_ctxt cx, &@ast::expr lhs, &@ast::expr rhs,\n               &ast::ann ann) -> result {\n     auto bcx = cx;"}, {"sha": "17af83bf7b2730a9bfdc526be3d53e2591e56c90", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/81fc51a8d7f4ccb4f0a7b2c7718a2926d9842f59/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/81fc51a8d7f4ccb4f0a7b2c7718a2926d9842f59/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=81fc51a8d7f4ccb4f0a7b2c7718a2926d9842f59", "patch": "@@ -719,6 +719,13 @@ fn type_is_bool(&ctxt cx, &t ty) -> bool {\n     }\n }\n \n+fn type_is_chan(&ctxt cx, &t ty) -> bool {\n+    alt (struct(cx, ty)) {\n+        case (ty_chan(_)) { ret true; }\n+        case (_) { ret false; }\n+    }\n+}\n+\n fn type_is_structural(&ctxt cx, &t ty) -> bool {\n     alt (struct(cx, ty)) {\n         case (ty_tup(_)) { ret true; }"}]}