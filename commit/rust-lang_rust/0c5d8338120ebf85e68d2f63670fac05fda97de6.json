{"sha": "0c5d8338120ebf85e68d2f63670fac05fda97de6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBjNWQ4MzM4MTIwZWJmODVlNjhkMmY2MzY3MGZhYzA1ZmRhOTdkZTY=", "commit": {"author": {"name": "Markus Westerlind", "email": "markus.westerlind@distilnetworks.com", "date": "2020-02-25T12:08:38Z"}, "committer": {"name": "Markus Westerlind", "email": "markus.westerlind@distilnetworks.com", "date": "2020-05-05T09:24:23Z"}, "message": "Move projection_cache into the combined undo log", "tree": {"sha": "93fc561a90b2285ac7c1e60a5fce0b04fa3a616d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/93fc561a90b2285ac7c1e60a5fce0b04fa3a616d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0c5d8338120ebf85e68d2f63670fac05fda97de6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0c5d8338120ebf85e68d2f63670fac05fda97de6", "html_url": "https://github.com/rust-lang/rust/commit/0c5d8338120ebf85e68d2f63670fac05fda97de6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0c5d8338120ebf85e68d2f63670fac05fda97de6/comments", "author": null, "committer": null, "parents": [{"sha": "c50fc6e113ee3905992521e1bd2431f6b2cd5c20", "url": "https://api.github.com/repos/rust-lang/rust/commits/c50fc6e113ee3905992521e1bd2431f6b2cd5c20", "html_url": "https://github.com/rust-lang/rust/commit/c50fc6e113ee3905992521e1bd2431f6b2cd5c20"}], "stats": {"total": 132, "additions": 79, "deletions": 53}, "files": [{"sha": "c5e25b0a2c7227be8f44e3525731d3d8fedc0938", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0c5d8338120ebf85e68d2f63670fac05fda97de6/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/0c5d8338120ebf85e68d2f63670fac05fda97de6/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=0c5d8338120ebf85e68d2f63670fac05fda97de6", "patch": "@@ -485,7 +485,7 @@ version = \"0.0.212\"\n dependencies = [\n  \"cargo_metadata 0.9.1\",\n  \"if_chain\",\n- \"itertools 0.9.0\",\n+ \"itertools 0.8.0\",\n  \"lazy_static 1.4.0\",\n  \"pulldown-cmark 0.7.1\",\n  \"quine-mc_cluskey\",\n@@ -1629,15 +1629,6 @@ dependencies = [\n  \"either\",\n ]\n \n-[[package]]\n-name = \"itertools\"\n-version = \"0.9.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"284f18f85651fe11e8a991b2adb42cb078325c996ed026d994719efcfca1d54b\"\n-dependencies = [\n- \"either\",\n-]\n-\n [[package]]\n name = \"itoa\"\n version = \"0.4.4\"\n@@ -2188,7 +2179,6 @@ dependencies = [\n  \"rustc-workspace-hack\",\n  \"rustc_version\",\n  \"serde\",\n- \"serde_json\",\n  \"shell-escape\",\n  \"vergen\",\n ]"}, {"sha": "fe3c5a8afc90e1647669642a4576fb9e0f8d3868", "filename": "src/librustc_data_structures/snapshot_map/mod.rs", "status": "modified", "additions": 19, "deletions": 7, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/0c5d8338120ebf85e68d2f63670fac05fda97de6/src%2Flibrustc_data_structures%2Fsnapshot_map%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c5d8338120ebf85e68d2f63670fac05fda97de6/src%2Flibrustc_data_structures%2Fsnapshot_map%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fsnapshot_map%2Fmod.rs?ref=0c5d8338120ebf85e68d2f63670fac05fda97de6", "patch": "@@ -1,5 +1,6 @@\n use crate::fx::FxHashMap;\n use crate::undo_log::{Rollback, Snapshots, UndoLogs, VecLog};\n+use std::borrow::{Borrow, BorrowMut};\n use std::hash::Hash;\n use std::marker::PhantomData;\n use std::ops;\n@@ -10,6 +11,7 @@ pub use crate::undo_log::Snapshot;\n mod tests;\n \n pub type SnapshotMapStorage<K, V> = SnapshotMap<K, V, FxHashMap<K, V>, ()>;\n+pub type SnapshotMapRef<'a, K, V, L> = SnapshotMap<K, V, &'a mut FxHashMap<K, V>, &'a mut L>;\n \n pub struct SnapshotMap<K, V, M = FxHashMap<K, V>, L = VecLog<UndoLog<K, V>>> {\n     map: M,\n@@ -43,16 +45,16 @@ impl<K, V, M, L> SnapshotMap<K, V, M, L> {\n impl<K, V, M, L> SnapshotMap<K, V, M, L>\n where\n     K: Hash + Clone + Eq,\n-    M: AsMut<FxHashMap<K, V>> + AsRef<FxHashMap<K, V>>,\n+    M: BorrowMut<FxHashMap<K, V>> + Borrow<FxHashMap<K, V>>,\n     L: UndoLogs<UndoLog<K, V>>,\n {\n     pub fn clear(&mut self) {\n-        self.map.as_mut().clear();\n+        self.map.borrow_mut().clear();\n         self.undo_log.clear();\n     }\n \n     pub fn insert(&mut self, key: K, value: V) -> bool {\n-        match self.map.as_mut().insert(key.clone(), value) {\n+        match self.map.borrow_mut().insert(key.clone(), value) {\n             None => {\n                 self.undo_log.push(UndoLog::Inserted(key));\n                 true\n@@ -65,7 +67,7 @@ where\n     }\n \n     pub fn remove(&mut self, key: K) -> bool {\n-        match self.map.as_mut().remove(&key) {\n+        match self.map.borrow_mut().remove(&key) {\n             Some(old_value) => {\n                 self.undo_log.push(UndoLog::Overwrite(key, old_value));\n                 true\n@@ -75,7 +77,7 @@ where\n     }\n \n     pub fn get(&self, key: &K) -> Option<&V> {\n-        self.map.as_ref().get(key)\n+        self.map.borrow().get(key)\n     }\n }\n \n@@ -99,11 +101,21 @@ where\n impl<'k, K, V, M, L> ops::Index<&'k K> for SnapshotMap<K, V, M, L>\n where\n     K: Hash + Clone + Eq,\n-    M: AsRef<FxHashMap<K, V>>,\n+    M: Borrow<FxHashMap<K, V>>,\n {\n     type Output = V;\n     fn index(&self, key: &'k K) -> &V {\n-        &self.map.as_ref()[key]\n+        &self.map.borrow()[key]\n+    }\n+}\n+\n+impl<K, V, M, L> Rollback<UndoLog<K, V>> for SnapshotMap<K, V, M, L>\n+where\n+    K: Eq + Hash,\n+    M: Rollback<UndoLog<K, V>>,\n+{\n+    fn reverse(&mut self, undo: UndoLog<K, V>) {\n+        self.map.reverse(undo)\n     }\n }\n "}, {"sha": "685dc1ab8a4ea20c7ec41f32d587a9a0a8c0fe44", "filename": "src/librustc_infer/infer/mod.rs", "status": "modified", "additions": 17, "deletions": 8, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/0c5d8338120ebf85e68d2f63670fac05fda97de6/src%2Flibrustc_infer%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c5d8338120ebf85e68d2f63670fac05fda97de6/src%2Flibrustc_infer%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fmod.rs?ref=0c5d8338120ebf85e68d2f63670fac05fda97de6", "patch": "@@ -141,7 +141,7 @@ pub struct InferCtxtInner<'tcx> {\n     /// Cache for projections. This cache is snapshotted along with the infcx.\n     ///\n     /// Public so that `traits::project` can use it.\n-    pub projection_cache: traits::ProjectionCache<'tcx>,\n+    pub projection_cache: traits::ProjectionCacheStorage<'tcx>,\n \n     /// We instantiate `UnificationTable` with `bounds<Ty>` because the types\n     /// that might instantiate a general type variable have an order,\n@@ -213,6 +213,10 @@ impl<'tcx> InferCtxtInner<'tcx> {\n         }\n     }\n \n+    pub(crate) fn projection_cache(&mut self) -> traits::ProjectionCache<'tcx, '_> {\n+        self.projection_cache.with_log(&mut self.undo_log)\n+    }\n+\n     fn type_variables(&mut self) -> type_variable::TypeVariableTable<'tcx, '_> {\n         self.type_variables.with_log(&mut self.undo_log)\n     }\n@@ -265,6 +269,7 @@ pub(crate) enum UndoLog<'tcx> {\n     FloatUnificationTable(sv::UndoLog<ut::Delegate<ty::FloatVid>>),\n     RegionConstraintCollector(region_constraints::UndoLog<'tcx>),\n     RegionUnificationTable(sv::UndoLog<ut::Delegate<ty::RegionVid>>),\n+    ProjectionCache(traits::UndoLog<'tcx>),\n }\n \n impl<'tcx> From<region_constraints::UndoLog<'tcx>> for UndoLog<'tcx> {\n@@ -327,6 +332,12 @@ impl<'tcx> From<sv::UndoLog<ut::Delegate<ty::RegionVid>>> for UndoLog<'tcx> {\n     }\n }\n \n+impl<'tcx> From<traits::UndoLog<'tcx>> for UndoLog<'tcx> {\n+    fn from(l: traits::UndoLog<'tcx>) -> Self {\n+        Self::ProjectionCache(l)\n+    }\n+}\n+\n pub(crate) type UnificationTable<'a, 'tcx, T> =\n     ut::UnificationTable<ut::InPlace<T, &'a mut ut::UnificationStorage<T>, &'a mut Logs<'tcx>>>;\n \n@@ -336,6 +347,7 @@ struct RollbackView<'tcx, 'a> {\n     int_unification_table: &'a mut ut::UnificationStorage<ty::IntVid>,\n     float_unification_table: &'a mut ut::UnificationStorage<ty::FloatVid>,\n     region_constraints: &'a mut RegionConstraintStorage<'tcx>,\n+    projection_cache: &'a mut traits::ProjectionCacheStorage<'tcx>,\n }\n \n impl<'tcx> Rollback<UndoLog<'tcx>> for RollbackView<'tcx, '_> {\n@@ -349,6 +361,7 @@ impl<'tcx> Rollback<UndoLog<'tcx>> for RollbackView<'tcx, '_> {\n             UndoLog::RegionUnificationTable(undo) => {\n                 self.region_constraints.unification_table.reverse(undo)\n             }\n+            UndoLog::ProjectionCache(undo) => self.projection_cache.reverse(undo),\n         }\n     }\n }\n@@ -885,7 +898,6 @@ impl<'tcx> InferOk<'tcx, ()> {\n \n #[must_use = \"once you start a snapshot, you should always consume it\"]\n pub struct CombinedSnapshot<'a, 'tcx> {\n-    projection_cache_snapshot: traits::ProjectionCacheSnapshot,\n     undo_snapshot: Snapshot<'tcx>,\n     type_snapshot: type_variable::Snapshot<'tcx>,\n     const_snapshot: usize,\n@@ -1016,7 +1028,6 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         inner.undo_log.num_open_snapshots += 1;\n         let undo_snapshot = Snapshot { undo_len: inner.undo_log.logs.len(), _marker: PhantomData };\n         CombinedSnapshot {\n-            projection_cache_snapshot: inner.projection_cache.snapshot(),\n             undo_snapshot,\n             type_snapshot: inner.type_variables().snapshot(),\n             const_snapshot: inner.const_unification_table().len(),\n@@ -1036,7 +1047,6 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     fn rollback_to(&self, cause: &str, snapshot: CombinedSnapshot<'a, 'tcx>) {\n         debug!(\"rollback_to(cause={})\", cause);\n         let CombinedSnapshot {\n-            projection_cache_snapshot,\n             undo_snapshot,\n             type_snapshot: _,\n             const_snapshot: _,\n@@ -1062,6 +1072,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             int_unification_table,\n             float_unification_table,\n             region_constraints,\n+            projection_cache,\n             ..\n         } = inner;\n         inner.undo_log.rollback_to(\n@@ -1071,17 +1082,16 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 int_unification_table,\n                 float_unification_table,\n                 region_constraints: region_constraints.as_mut().unwrap(),\n+                projection_cache,\n             },\n             undo_snapshot,\n         );\n-        inner.projection_cache.rollback_to(projection_cache_snapshot);\n         inner.region_obligations.truncate(region_obligations_snapshot);\n     }\n \n     fn commit_from(&self, snapshot: CombinedSnapshot<'a, 'tcx>) {\n         debug!(\"commit_from()\");\n         let CombinedSnapshot {\n-            projection_cache_snapshot,\n             undo_snapshot,\n             type_snapshot: _,\n             const_snapshot: _,\n@@ -1100,7 +1110,6 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n         let mut inner = self.inner.borrow_mut();\n         inner.undo_log.commit(undo_snapshot);\n-        inner.projection_cache.commit(projection_cache_snapshot);\n     }\n \n     /// Executes `f` and commit the bindings.\n@@ -1773,7 +1782,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     pub fn clear_caches(&self) {\n         self.selection_cache.clear();\n         self.evaluation_cache.clear();\n-        self.inner.borrow_mut().projection_cache.clear();\n+        self.inner.borrow_mut().projection_cache().clear();\n     }\n \n     fn universe(&self) -> ty::UniverseIndex {"}, {"sha": "640ea7774cd33d8d7a2cbc47b2c1098d52a3d49d", "filename": "src/librustc_infer/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0c5d8338120ebf85e68d2f63670fac05fda97de6/src%2Flibrustc_infer%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c5d8338120ebf85e68d2f63670fac05fda97de6/src%2Flibrustc_infer%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Ftraits%2Fmod.rs?ref=0c5d8338120ebf85e68d2f63670fac05fda97de6", "patch": "@@ -20,6 +20,7 @@ pub use self::Vtable::*;\n \n pub use self::engine::{TraitEngine, TraitEngineExt};\n pub use self::project::MismatchedProjectionTypes;\n+pub(crate) use self::project::UndoLog;\n pub use self::project::{\n     Normalized, NormalizedTy, ProjectionCache, ProjectionCacheEntry, ProjectionCacheKey,\n     ProjectionCacheSnapshot, Reveal,"}, {"sha": "0c51dafef6fb69b3fdb860bb7af40874da35604b", "filename": "src/librustc_infer/traits/project.rs", "status": "modified", "additions": 40, "deletions": 26, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/0c5d8338120ebf85e68d2f63670fac05fda97de6/src%2Flibrustc_infer%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c5d8338120ebf85e68d2f63670fac05fda97de6/src%2Flibrustc_infer%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Ftraits%2Fproject.rs?ref=0c5d8338120ebf85e68d2f63670fac05fda97de6", "patch": "@@ -8,6 +8,9 @@ use rustc_middle::ty::{self, Ty};\n \n pub use rustc_middle::traits::Reveal;\n \n+pub(crate) type UndoLog<'tcx> =\n+    snapshot_map::UndoLog<ProjectionCacheKey<'tcx>, ProjectionCacheEntry<'tcx>>;\n+\n #[derive(Clone)]\n pub struct MismatchedProjectionTypes<'tcx> {\n     pub err: ty::error::TypeError<'tcx>,\n@@ -58,9 +61,14 @@ impl<'tcx, T> Normalized<'tcx, T> {\n //\n // FIXME: we probably also want some sort of cross-infcx cache here to\n // reduce the amount of duplication. Let's see what we get with the Chalk reforms.\n+pub struct ProjectionCache<'tcx, 'a> {\n+    map: &'a mut SnapshotMapStorage<ProjectionCacheKey<'tcx>, ProjectionCacheEntry<'tcx>>,\n+    undo_log: &'a mut Logs<'tcx>,\n+}\n+\n #[derive(Default)]\n-pub struct ProjectionCache<'tcx> {\n-    map: SnapshotMap<ProjectionCacheKey<'tcx>, ProjectionCacheEntry<'tcx>>,\n+pub struct ProjectionCacheStorage<'tcx> {\n+    map: SnapshotMapStorage<ProjectionCacheKey<'tcx>, ProjectionCacheEntry<'tcx>>,\n }\n \n #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n@@ -82,26 +90,24 @@ pub enum ProjectionCacheEntry<'tcx> {\n     NormalizedTy(NormalizedTy<'tcx>),\n }\n \n-// N.B., intentionally not Clone\n-pub struct ProjectionCacheSnapshot {\n-    snapshot: Snapshot,\n-}\n-\n-impl<'tcx> ProjectionCache<'tcx> {\n-    pub fn clear(&mut self) {\n-        self.map.clear();\n-    }\n-\n-    pub fn snapshot(&mut self) -> ProjectionCacheSnapshot {\n-        ProjectionCacheSnapshot { snapshot: self.map.snapshot() }\n+impl<'tcx> ProjectionCacheStorage<'tcx> {\n+    pub(crate) fn with_log<'a>(\n+        &'a mut self,\n+        undo_log: &'a mut Logs<'tcx>,\n+    ) -> ProjectionCache<'tcx, 'a> {\n+        ProjectionCache { map: &mut self.map, undo_log }\n     }\n+}\n \n-    pub fn rollback_to(&mut self, snapshot: ProjectionCacheSnapshot) {\n-        self.map.rollback_to(snapshot.snapshot);\n+impl<'tcx> ProjectionCache<'tcx, '_> {\n+    fn map(\n+        &mut self,\n+    ) -> SnapshotMapRef<'_, ProjectionCacheKey<'tcx>, ProjectionCacheEntry<'tcx>, Logs<'tcx>> {\n+        self.map.with_log(self.undo_log)\n     }\n \n-    pub fn commit(&mut self, snapshot: ProjectionCacheSnapshot) {\n-        self.map.commit(snapshot.snapshot);\n+    pub fn clear(&mut self) {\n+        self.map().clear();\n     }\n \n     /// Try to start normalize `key`; returns an error if\n@@ -111,11 +117,12 @@ impl<'tcx> ProjectionCache<'tcx> {\n         &mut self,\n         key: ProjectionCacheKey<'tcx>,\n     ) -> Result<(), ProjectionCacheEntry<'tcx>> {\n-        if let Some(entry) = self.map.get(&key) {\n+        let mut map = self.map();\n+        if let Some(entry) = map.get(&key) {\n             return Err(entry.clone());\n         }\n \n-        self.map.insert(key, ProjectionCacheEntry::InProgress);\n+        map.insert(key, ProjectionCacheEntry::InProgress);\n         Ok(())\n     }\n \n@@ -125,7 +132,7 @@ impl<'tcx> ProjectionCache<'tcx> {\n             \"ProjectionCacheEntry::insert_ty: adding cache entry: key={:?}, value={:?}\",\n             key, value\n         );\n-        let fresh_key = self.map.insert(key, ProjectionCacheEntry::NormalizedTy(value));\n+        let fresh_key = self.map().insert(key, ProjectionCacheEntry::NormalizedTy(value));\n         assert!(!fresh_key, \"never started projecting `{:?}`\", key);\n     }\n \n@@ -134,7 +141,8 @@ impl<'tcx> ProjectionCache<'tcx> {\n     /// snapshot - if the snapshot is rolled back, the obligations will be\n     /// marked as incomplete again).\n     pub fn complete(&mut self, key: ProjectionCacheKey<'tcx>) {\n-        let ty = match self.map.get(&key) {\n+        let mut map = self.map();\n+        let ty = match map.get(&key) {\n             Some(&ProjectionCacheEntry::NormalizedTy(ref ty)) => {\n                 debug!(\"ProjectionCacheEntry::complete({:?}) - completing {:?}\", key, ty);\n                 ty.value\n@@ -147,7 +155,7 @@ impl<'tcx> ProjectionCache<'tcx> {\n             }\n         };\n \n-        self.map.insert(\n+        map.insert(\n             key,\n             ProjectionCacheEntry::NormalizedTy(Normalized { value: ty, obligations: vec![] }),\n         );\n@@ -159,7 +167,7 @@ impl<'tcx> ProjectionCache<'tcx> {\n         // We want to insert `ty` with no obligations. If the existing value\n         // already has no obligations (as is common) we don't insert anything.\n         if !ty.obligations.is_empty() {\n-            self.map.insert(\n+            self.map().insert(\n                 key,\n                 ProjectionCacheEntry::NormalizedTy(Normalized {\n                     value: ty.value,\n@@ -174,14 +182,20 @@ impl<'tcx> ProjectionCache<'tcx> {\n     /// type information (in which case, the \"fully resolved\" key will\n     /// be different).\n     pub fn ambiguous(&mut self, key: ProjectionCacheKey<'tcx>) {\n-        let fresh = self.map.insert(key, ProjectionCacheEntry::Ambiguous);\n+        let fresh = self.map().insert(key, ProjectionCacheEntry::Ambiguous);\n         assert!(!fresh, \"never started projecting `{:?}`\", key);\n     }\n \n     /// Indicates that trying to normalize `key` resulted in\n     /// error.\n     pub fn error(&mut self, key: ProjectionCacheKey<'tcx>) {\n-        let fresh = self.map.insert(key, ProjectionCacheEntry::Error);\n+        let fresh = self.map().insert(key, ProjectionCacheEntry::Error);\n         assert!(!fresh, \"never started projecting `{:?}`\", key);\n     }\n }\n+\n+impl<'tcx> Rollback<UndoLog<'tcx>> for ProjectionCacheStorage<'tcx> {\n+    fn reverse(&mut self, undo: UndoLog<'tcx>) {\n+        self.map.reverse(undo);\n+    }\n+}"}, {"sha": "38590abf1f706d521bcce582026cb5a6770b7d67", "filename": "src/librustc_trait_selection/traits/select.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c5d8338120ebf85e68d2f63670fac05fda97de6/src%2Flibrustc_trait_selection%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c5d8338120ebf85e68d2f63670fac05fda97de6/src%2Flibrustc_trait_selection%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fselect.rs?ref=0c5d8338120ebf85e68d2f63670fac05fda97de6", "patch": "@@ -471,7 +471,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                         if let Some(key) =\n                             ProjectionCacheKey::from_poly_projection_predicate(self, data)\n                         {\n-                            self.infcx.inner.borrow_mut().projection_cache.complete(key);\n+                            self.infcx.inner.borrow_mut().projection_cache().complete(key);\n                         }\n                         result\n                     }"}]}