{"sha": "e2b2bfe10ce5d36e9568173cb6cb9c7456b03a61", "node_id": "C_kwDOAAsO6NoAKGUyYjJiZmUxMGNlNWQzNmU5NTY4MTczY2I2Y2I5Yzc0NTZiMDNhNjE", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-01-26T22:45:22Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-01-26T22:45:22Z"}, "message": "Rollup merge of #92256 - fee1-dead:improve-selection-err, r=oli-obk\n\nImprove selection errors for `~const` trait bounds", "tree": {"sha": "a7ac618fc130011154e20d0c431a4ed7fb8a91e0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a7ac618fc130011154e20d0c431a4ed7fb8a91e0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e2b2bfe10ce5d36e9568173cb6cb9c7456b03a61", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJh8c8CCRBK7hj4Ov3rIwAAYZ8IAAkU8pa68q/RCjHDx43XI6En\nZCY+XavgM0Sh0/1cZ0TZ8Nwc+FbYs90j+8Sy8tkYw4kh0yagkyotJUKo4x6kaQ2d\ng9OmgP8X2JtudQN07Cb9D9EGYp+DHGqdz5L3tssps8wvboacCr98rj+3A23paao3\nbQuG5z3dUUVC2dssMHHU4sOeLPAsQ+rXxhO+cOXkqd6dASNMpgs6ezimfvOxdwbH\nsJnzMov9Fof69aFq4NzHfImcGQMy1RpSTqYkaVs48MpsvYz0B8NwSdsKpAbYHYvN\nTsL/FagQJ+OJg7z/cOd1Kma7I99TxezW7JmQvbWz+Ke+zdo/Enhy5qrdlLXUTFY=\n=UWau\n-----END PGP SIGNATURE-----\n", "payload": "tree a7ac618fc130011154e20d0c431a4ed7fb8a91e0\nparent e249812597cb1a57ff704e340a62fbe2d22c7565\nparent 8b76cad0a7e4a7743d4dd44dd53f077f3d0b8924\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1643237122 +0100\ncommitter GitHub <noreply@github.com> 1643237122 +0100\n\nRollup merge of #92256 - fee1-dead:improve-selection-err, r=oli-obk\n\nImprove selection errors for `~const` trait bounds\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e2b2bfe10ce5d36e9568173cb6cb9c7456b03a61", "html_url": "https://github.com/rust-lang/rust/commit/e2b2bfe10ce5d36e9568173cb6cb9c7456b03a61", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e2b2bfe10ce5d36e9568173cb6cb9c7456b03a61/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e249812597cb1a57ff704e340a62fbe2d22c7565", "url": "https://api.github.com/repos/rust-lang/rust/commits/e249812597cb1a57ff704e340a62fbe2d22c7565", "html_url": "https://github.com/rust-lang/rust/commit/e249812597cb1a57ff704e340a62fbe2d22c7565"}, {"sha": "8b76cad0a7e4a7743d4dd44dd53f077f3d0b8924", "url": "https://api.github.com/repos/rust-lang/rust/commits/8b76cad0a7e4a7743d4dd44dd53f077f3d0b8924", "html_url": "https://github.com/rust-lang/rust/commit/8b76cad0a7e4a7743d4dd44dd53f077f3d0b8924"}], "stats": {"total": 646, "additions": 428, "deletions": 218}, "files": [{"sha": "1123cab807651b29a4024f5b86c31c3bb01697d1", "filename": "compiler/rustc_middle/src/traits/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e2b2bfe10ce5d36e9568173cb6cb9c7456b03a61/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2b2bfe10ce5d36e9568173cb6cb9c7456b03a61/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs?ref=e2b2bfe10ce5d36e9568173cb6cb9c7456b03a61", "patch": "@@ -402,7 +402,7 @@ impl ObligationCauseCode<'_> {\n \n // `ObligationCauseCode` is used a lot. Make sure it doesn't unintentionally get bigger.\n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-static_assert_size!(ObligationCauseCode<'_>, 40);\n+static_assert_size!(ObligationCauseCode<'_>, 48);\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n pub enum StatementAsExpression {\n@@ -440,11 +440,11 @@ pub struct IfExpressionCause {\n \n #[derive(Clone, Debug, PartialEq, Eq, Hash, Lift)]\n pub struct DerivedObligationCause<'tcx> {\n-    /// The trait reference of the parent obligation that led to the\n+    /// The trait predicate of the parent obligation that led to the\n     /// current obligation. Note that only trait obligations lead to\n-    /// derived obligations, so we just store the trait reference here\n+    /// derived obligations, so we just store the trait predicate here\n     /// directly.\n-    pub parent_trait_ref: ty::PolyTraitRef<'tcx>,\n+    pub parent_trait_pred: ty::PolyTraitPredicate<'tcx>,\n \n     /// The parent trait had this cause.\n     pub parent_code: Lrc<ObligationCauseCode<'tcx>>,"}, {"sha": "6174c922e2d063df5e3fbef6c88ed5b504037310", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e2b2bfe10ce5d36e9568173cb6cb9c7456b03a61/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2b2bfe10ce5d36e9568173cb6cb9c7456b03a61/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=e2b2bfe10ce5d36e9568173cb6cb9c7456b03a61", "patch": "@@ -766,6 +766,17 @@ impl<'tcx> TraitPredicate<'tcx> {\n             *param_env = param_env.with_constness(self.constness.and(param_env.constness()))\n         }\n     }\n+\n+    /// Remap the constness of this predicate before emitting it for diagnostics.\n+    pub fn remap_constness_diag(&mut self, param_env: ParamEnv<'tcx>) {\n+        // this is different to `remap_constness` that callees want to print this predicate\n+        // in case of selection errors. `T: ~const Drop` bounds cannot end up here when the\n+        // param_env is not const because we it is always satisfied in non-const contexts.\n+        if let hir::Constness::NotConst = param_env.constness() {\n+            self.constness = ty::BoundConstness::NotConst;\n+        }\n+    }\n+\n     pub fn def_id(self) -> DefId {\n         self.trait_ref.def_id\n     }\n@@ -784,6 +795,14 @@ impl<'tcx> PolyTraitPredicate<'tcx> {\n     pub fn self_ty(self) -> ty::Binder<'tcx, Ty<'tcx>> {\n         self.map_bound(|trait_ref| trait_ref.self_ty())\n     }\n+\n+    /// Remap the constness of this predicate before emitting it for diagnostics.\n+    pub fn remap_constness_diag(&mut self, param_env: ParamEnv<'tcx>) {\n+        *self = self.map_bound(|mut p| {\n+            p.remap_constness_diag(param_env);\n+            p\n+        });\n+    }\n }\n \n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, TyEncodable, TyDecodable)]"}, {"sha": "ddcc8680d835269bd4f34257bccb79f01db361c6", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 41, "deletions": 2, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/e2b2bfe10ce5d36e9568173cb6cb9c7456b03a61/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2b2bfe10ce5d36e9568173cb6cb9c7456b03a61/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=e2b2bfe10ce5d36e9568173cb6cb9c7456b03a61", "patch": "@@ -2413,6 +2413,29 @@ impl<'tcx> ty::Binder<'tcx, ty::TraitRef<'tcx>> {\n     }\n }\n \n+#[derive(Copy, Clone, TypeFoldable, Lift)]\n+pub struct TraitPredPrintModifiersAndPath<'tcx>(ty::TraitPredicate<'tcx>);\n+\n+impl<'tcx> fmt::Debug for TraitPredPrintModifiersAndPath<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        fmt::Display::fmt(self, f)\n+    }\n+}\n+\n+impl<'tcx> ty::TraitPredicate<'tcx> {\n+    pub fn print_modifiers_and_trait_path(self) -> TraitPredPrintModifiersAndPath<'tcx> {\n+        TraitPredPrintModifiersAndPath(self)\n+    }\n+}\n+\n+impl<'tcx> ty::PolyTraitPredicate<'tcx> {\n+    pub fn print_modifiers_and_trait_path(\n+        self,\n+    ) -> ty::Binder<'tcx, TraitPredPrintModifiersAndPath<'tcx>> {\n+        self.map_bound(TraitPredPrintModifiersAndPath)\n+    }\n+}\n+\n forward_display_to_print! {\n     Ty<'tcx>,\n     &'tcx ty::List<ty::Binder<'tcx, ty::ExistentialPredicate<'tcx>>>,\n@@ -2427,6 +2450,7 @@ forward_display_to_print! {\n     ty::Binder<'tcx, TraitRefPrintOnlyTraitName<'tcx>>,\n     ty::Binder<'tcx, ty::FnSig<'tcx>>,\n     ty::Binder<'tcx, ty::TraitPredicate<'tcx>>,\n+    ty::Binder<'tcx, TraitPredPrintModifiersAndPath<'tcx>>,\n     ty::Binder<'tcx, ty::SubtypePredicate<'tcx>>,\n     ty::Binder<'tcx, ty::ProjectionPredicate<'tcx>>,\n     ty::Binder<'tcx, ty::OutlivesPredicate<Ty<'tcx>, ty::Region<'tcx>>>,\n@@ -2491,6 +2515,18 @@ define_print_and_forward_display! {\n         p!(print_def_path(self.0.def_id, &[]));\n     }\n \n+    TraitPredPrintModifiersAndPath<'tcx> {\n+        if let ty::BoundConstness::ConstIfConst = self.0.constness {\n+            p!(\"~const \")\n+        }\n+\n+        if let ty::ImplPolarity::Negative = self.0.polarity {\n+            p!(\"!\")\n+        }\n+\n+        p!(print(self.0.trait_ref.print_only_trait_path()));\n+    }\n+\n     ty::ParamTy {\n         p!(write(\"{}\", self.name))\n     }\n@@ -2508,8 +2544,11 @@ define_print_and_forward_display! {\n     }\n \n     ty::TraitPredicate<'tcx> {\n-        p!(print(self.trait_ref.self_ty()), \": \",\n-           print(self.trait_ref.print_only_trait_path()))\n+        p!(print(self.trait_ref.self_ty()), \": \");\n+        if let ty::BoundConstness::ConstIfConst = self.constness {\n+            p!(\"~const \");\n+        }\n+        p!(print(self.trait_ref.print_only_trait_path()))\n     }\n \n     ty::ProjectionPredicate<'tcx> {"}, {"sha": "d99bdd3bdd5be8242b70211d2242edbe49347ca3", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e2b2bfe10ce5d36e9568173cb6cb9c7456b03a61/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2b2bfe10ce5d36e9568173cb6cb9c7456b03a61/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=e2b2bfe10ce5d36e9568173cb6cb9c7456b03a61", "patch": "@@ -321,6 +321,7 @@ symbols! {\n         and,\n         and_then,\n         any,\n+        append_const_msg,\n         arbitrary_enum_discriminant,\n         arbitrary_self_types,\n         arith_offset,"}, {"sha": "37cf41a0ec2e28066a402a8bd9fd2897266723e0", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 68, "deletions": 31, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/e2b2bfe10ce5d36e9568173cb6cb9c7456b03a61/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2b2bfe10ce5d36e9568173cb6cb9c7456b03a61/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=e2b2bfe10ce5d36e9568173cb6cb9c7456b03a61", "patch": "@@ -205,6 +205,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         self.note_obligation_cause_code(\n             &mut err,\n             &obligation.predicate,\n+            obligation.param_env,\n             obligation.cause.code(),\n             &mut vec![],\n             &mut Default::default(),\n@@ -288,7 +289,11 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 match bound_predicate.skip_binder() {\n                     ty::PredicateKind::Trait(trait_predicate) => {\n                         let trait_predicate = bound_predicate.rebind(trait_predicate);\n-                        let trait_predicate = self.resolve_vars_if_possible(trait_predicate);\n+                        let mut trait_predicate = self.resolve_vars_if_possible(trait_predicate);\n+\n+                        trait_predicate.remap_constness_diag(obligation.param_env);\n+                        let predicate_is_const = ty::BoundConstness::ConstIfConst\n+                            == trait_predicate.skip_binder().constness;\n \n                         if self.tcx.sess.has_errors() && trait_predicate.references_error() {\n                             return;\n@@ -305,13 +310,18 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                             })\n                             .unwrap_or_default();\n \n-                        let OnUnimplementedNote { message, label, note, enclosing_scope } =\n-                            self.on_unimplemented_note(trait_ref, &obligation);\n+                        let OnUnimplementedNote {\n+                            message,\n+                            label,\n+                            note,\n+                            enclosing_scope,\n+                            append_const_msg,\n+                        } = self.on_unimplemented_note(trait_ref, &obligation);\n                         let have_alt_message = message.is_some() || label.is_some();\n                         let is_try_conversion = self.is_try_conversion(span, trait_ref.def_id());\n                         let is_unsize =\n                             { Some(trait_ref.def_id()) == self.tcx.lang_items().unsize_trait() };\n-                        let (message, note) = if is_try_conversion {\n+                        let (message, note, append_const_msg) = if is_try_conversion {\n                             (\n                                 Some(format!(\n                                     \"`?` couldn't convert the error to `{}`\",\n@@ -322,21 +332,38 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                                         conversion on the error value using the `From` trait\"\n                                         .to_owned(),\n                                 ),\n+                                Some(None),\n                             )\n                         } else {\n-                            (message, note)\n+                            (message, note, append_const_msg)\n                         };\n \n                         let mut err = struct_span_err!(\n                             self.tcx.sess,\n                             span,\n                             E0277,\n                             \"{}\",\n-                            message.unwrap_or_else(|| format!(\n-                                \"the trait bound `{}` is not satisfied{}\",\n-                                trait_ref.without_const().to_predicate(tcx),\n-                                post_message,\n-                            ))\n+                            message\n+                                .and_then(|cannot_do_this| {\n+                                    match (predicate_is_const, append_const_msg) {\n+                                        // do nothing if predicate is not const\n+                                        (false, _) => Some(cannot_do_this),\n+                                        // suggested using default post message\n+                                        (true, Some(None)) => {\n+                                            Some(format!(\"{cannot_do_this} in const contexts\"))\n+                                        }\n+                                        // overriden post message\n+                                        (true, Some(Some(post_message))) => {\n+                                            Some(format!(\"{cannot_do_this}{post_message}\"))\n+                                        }\n+                                        // fallback to generic message\n+                                        (true, None) => None,\n+                                    }\n+                                })\n+                                .unwrap_or_else(|| format!(\n+                                    \"the trait bound `{}` is not satisfied{}\",\n+                                    trait_predicate, post_message,\n+                                ))\n                         );\n \n                         if is_try_conversion {\n@@ -384,15 +411,15 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                             format!(\n                                 \"{}the trait `{}` is not implemented for `{}`\",\n                                 pre_message,\n-                                trait_ref.print_only_trait_path(),\n+                                trait_predicate.print_modifiers_and_trait_path(),\n                                 trait_ref.skip_binder().self_ty(),\n                             )\n                         };\n \n                         if self.suggest_add_reference_to_arg(\n                             &obligation,\n                             &mut err,\n-                            &trait_ref,\n+                            trait_predicate,\n                             have_alt_message,\n                         ) {\n                             self.note_obligation_cause(&mut err, &obligation);\n@@ -435,18 +462,28 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                             err.span_label(enclosing_scope_span, s.as_str());\n                         }\n \n-                        self.suggest_dereferences(&obligation, &mut err, trait_ref);\n-                        self.suggest_fn_call(&obligation, &mut err, trait_ref);\n-                        self.suggest_remove_reference(&obligation, &mut err, trait_ref);\n-                        self.suggest_semicolon_removal(&obligation, &mut err, span, trait_ref);\n+                        self.suggest_dereferences(&obligation, &mut err, trait_predicate);\n+                        self.suggest_fn_call(&obligation, &mut err, trait_predicate);\n+                        self.suggest_remove_reference(&obligation, &mut err, trait_predicate);\n+                        self.suggest_semicolon_removal(\n+                            &obligation,\n+                            &mut err,\n+                            span,\n+                            trait_predicate,\n+                        );\n                         self.note_version_mismatch(&mut err, &trait_ref);\n                         self.suggest_remove_await(&obligation, &mut err);\n \n                         if Some(trait_ref.def_id()) == tcx.lang_items().try_trait() {\n-                            self.suggest_await_before_try(&mut err, &obligation, trait_ref, span);\n+                            self.suggest_await_before_try(\n+                                &mut err,\n+                                &obligation,\n+                                trait_predicate,\n+                                span,\n+                            );\n                         }\n \n-                        if self.suggest_impl_trait(&mut err, span, &obligation, trait_ref) {\n+                        if self.suggest_impl_trait(&mut err, span, &obligation, trait_predicate) {\n                             err.emit();\n                             return;\n                         }\n@@ -494,7 +531,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                             // which is somewhat confusing.\n                             self.suggest_restricting_param_bound(\n                                 &mut err,\n-                                trait_ref,\n+                                trait_predicate,\n                                 obligation.cause.body_id,\n                             );\n                         } else if !have_alt_message {\n@@ -506,7 +543,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                         // Changing mutability doesn't make a difference to whether we have\n                         // an `Unsize` impl (Fixes ICE in #71036)\n                         if !is_unsize {\n-                            self.suggest_change_mut(&obligation, &mut err, trait_ref);\n+                            self.suggest_change_mut(&obligation, &mut err, trait_predicate);\n                         }\n \n                         // If this error is due to `!: Trait` not implemented but `(): Trait` is\n@@ -1121,7 +1158,7 @@ trait InferCtxtPrivExt<'hir, 'tcx> {\n     fn mk_trait_obligation_with_new_self_ty(\n         &self,\n         param_env: ty::ParamEnv<'tcx>,\n-        trait_ref: ty::PolyTraitRef<'tcx>,\n+        trait_ref: ty::PolyTraitPredicate<'tcx>,\n         new_self_ty: Ty<'tcx>,\n     ) -> PredicateObligation<'tcx>;\n \n@@ -1541,7 +1578,7 @@ impl<'a, 'tcx> InferCtxtPrivExt<'a, 'tcx> for InferCtxt<'a, 'tcx> {\n     ) -> Option<(String, Option<Span>)> {\n         match code {\n             ObligationCauseCode::BuiltinDerivedObligation(data) => {\n-                let parent_trait_ref = self.resolve_vars_if_possible(data.parent_trait_ref);\n+                let parent_trait_ref = self.resolve_vars_if_possible(data.parent_trait_pred);\n                 match self.get_parent_trait_ref(&data.parent_code) {\n                     Some(t) => Some(t),\n                     None => {\n@@ -1594,21 +1631,20 @@ impl<'a, 'tcx> InferCtxtPrivExt<'a, 'tcx> for InferCtxt<'a, 'tcx> {\n     fn mk_trait_obligation_with_new_self_ty(\n         &self,\n         param_env: ty::ParamEnv<'tcx>,\n-        trait_ref: ty::PolyTraitRef<'tcx>,\n+        trait_ref: ty::PolyTraitPredicate<'tcx>,\n         new_self_ty: Ty<'tcx>,\n     ) -> PredicateObligation<'tcx> {\n         assert!(!new_self_ty.has_escaping_bound_vars());\n \n-        let trait_ref = trait_ref.map_bound_ref(|tr| ty::TraitRef {\n-            substs: self.tcx.mk_substs_trait(new_self_ty, &tr.substs[1..]),\n+        let trait_pred = trait_ref.map_bound_ref(|tr| ty::TraitPredicate {\n+            trait_ref: ty::TraitRef {\n+                substs: self.tcx.mk_substs_trait(new_self_ty, &tr.trait_ref.substs[1..]),\n+                ..tr.trait_ref\n+            },\n             ..*tr\n         });\n \n-        Obligation::new(\n-            ObligationCause::dummy(),\n-            param_env,\n-            trait_ref.without_const().to_predicate(self.tcx),\n-        )\n+        Obligation::new(ObligationCause::dummy(), param_env, trait_pred.to_predicate(self.tcx))\n     }\n \n     #[instrument(skip(self), level = \"debug\")]\n@@ -2009,6 +2045,7 @@ impl<'a, 'tcx> InferCtxtPrivExt<'a, 'tcx> for InferCtxt<'a, 'tcx> {\n             self.note_obligation_cause_code(\n                 err,\n                 &obligation.predicate,\n+                obligation.param_env,\n                 obligation.cause.code(),\n                 &mut vec![],\n                 &mut Default::default(),\n@@ -2156,7 +2193,7 @@ impl<'a, 'tcx> InferCtxtPrivExt<'a, 'tcx> for InferCtxt<'a, 'tcx> {\n         cause_code: &ObligationCauseCode<'tcx>,\n     ) -> bool {\n         if let ObligationCauseCode::BuiltinDerivedObligation(ref data) = cause_code {\n-            let parent_trait_ref = self.resolve_vars_if_possible(data.parent_trait_ref);\n+            let parent_trait_ref = self.resolve_vars_if_possible(data.parent_trait_pred);\n             let self_ty = parent_trait_ref.skip_binder().self_ty();\n             if obligated_types.iter().any(|ot| ot == &self_ty) {\n                 return true;"}, {"sha": "8c0dbe9b064eab0794a8679259754dd46d4983ec", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 116, "deletions": 110, "changes": 226, "blob_url": "https://github.com/rust-lang/rust/blob/e2b2bfe10ce5d36e9568173cb6cb9c7456b03a61/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2b2bfe10ce5d36e9568173cb6cb9c7456b03a61/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=e2b2bfe10ce5d36e9568173cb6cb9c7456b03a61", "patch": "@@ -48,15 +48,15 @@ pub trait InferCtxtExt<'tcx> {\n     fn suggest_restricting_param_bound(\n         &self,\n         err: &mut DiagnosticBuilder<'_>,\n-        trait_ref: ty::PolyTraitRef<'tcx>,\n+        trait_pred: ty::PolyTraitPredicate<'tcx>,\n         body_id: hir::HirId,\n     );\n \n     fn suggest_dereferences(\n         &self,\n         obligation: &PredicateObligation<'tcx>,\n         err: &mut DiagnosticBuilder<'tcx>,\n-        trait_ref: ty::PolyTraitRef<'tcx>,\n+        trait_pred: ty::PolyTraitPredicate<'tcx>,\n     );\n \n     fn get_closure_name(\n@@ -70,22 +70,22 @@ pub trait InferCtxtExt<'tcx> {\n         &self,\n         obligation: &PredicateObligation<'tcx>,\n         err: &mut DiagnosticBuilder<'_>,\n-        trait_ref: ty::Binder<'tcx, ty::TraitRef<'tcx>>,\n+        trait_pred: ty::PolyTraitPredicate<'tcx>,\n     );\n \n     fn suggest_add_reference_to_arg(\n         &self,\n         obligation: &PredicateObligation<'tcx>,\n         err: &mut DiagnosticBuilder<'_>,\n-        trait_ref: &ty::Binder<'tcx, ty::TraitRef<'tcx>>,\n+        trait_pred: ty::PolyTraitPredicate<'tcx>,\n         has_custom_message: bool,\n     ) -> bool;\n \n     fn suggest_remove_reference(\n         &self,\n         obligation: &PredicateObligation<'tcx>,\n         err: &mut DiagnosticBuilder<'_>,\n-        trait_ref: ty::Binder<'tcx, ty::TraitRef<'tcx>>,\n+        trait_pred: ty::PolyTraitPredicate<'tcx>,\n     );\n \n     fn suggest_remove_await(\n@@ -98,15 +98,15 @@ pub trait InferCtxtExt<'tcx> {\n         &self,\n         obligation: &PredicateObligation<'tcx>,\n         err: &mut DiagnosticBuilder<'_>,\n-        trait_ref: ty::Binder<'tcx, ty::TraitRef<'tcx>>,\n+        trait_pred: ty::PolyTraitPredicate<'tcx>,\n     );\n \n     fn suggest_semicolon_removal(\n         &self,\n         obligation: &PredicateObligation<'tcx>,\n         err: &mut DiagnosticBuilder<'_>,\n         span: Span,\n-        trait_ref: ty::Binder<'tcx, ty::TraitRef<'tcx>>,\n+        trait_pred: ty::PolyTraitPredicate<'tcx>,\n     );\n \n     fn return_type_span(&self, obligation: &PredicateObligation<'tcx>) -> Option<Span>;\n@@ -116,7 +116,7 @@ pub trait InferCtxtExt<'tcx> {\n         err: &mut DiagnosticBuilder<'_>,\n         span: Span,\n         obligation: &PredicateObligation<'tcx>,\n-        trait_ref: ty::Binder<'tcx, ty::TraitRef<'tcx>>,\n+        trait_pred: ty::PolyTraitPredicate<'tcx>,\n     ) -> bool;\n \n     fn point_at_returns_when_relevant(\n@@ -154,7 +154,7 @@ pub trait InferCtxtExt<'tcx> {\n         interior_extra_info: Option<(Option<Span>, Span, Option<hir::HirId>, Option<Span>)>,\n         inner_generator_body: Option<&hir::Body<'tcx>>,\n         outer_generator: Option<DefId>,\n-        trait_ref: ty::TraitRef<'tcx>,\n+        trait_pred: ty::TraitPredicate<'tcx>,\n         target_ty: Ty<'tcx>,\n         typeck_results: Option<&ty::TypeckResults<'tcx>>,\n         obligation: &PredicateObligation<'tcx>,\n@@ -165,6 +165,7 @@ pub trait InferCtxtExt<'tcx> {\n         &self,\n         err: &mut DiagnosticBuilder<'_>,\n         predicate: &T,\n+        param_env: ty::ParamEnv<'tcx>,\n         cause_code: &ObligationCauseCode<'tcx>,\n         obligated_types: &mut Vec<&ty::TyS<'tcx>>,\n         seen_requirements: &mut FxHashSet<DefId>,\n@@ -178,7 +179,7 @@ pub trait InferCtxtExt<'tcx> {\n         &self,\n         err: &mut DiagnosticBuilder<'_>,\n         obligation: &PredicateObligation<'tcx>,\n-        trait_ref: ty::Binder<'tcx, ty::TraitRef<'tcx>>,\n+        trait_pred: ty::PolyTraitPredicate<'tcx>,\n         span: Span,\n     );\n }\n@@ -204,7 +205,7 @@ fn suggest_restriction<'tcx>(\n     err: &mut DiagnosticBuilder<'_>,\n     fn_sig: Option<&hir::FnSig<'_>>,\n     projection: Option<&ty::ProjectionTy<'_>>,\n-    trait_ref: ty::PolyTraitRef<'tcx>,\n+    trait_pred: ty::PolyTraitPredicate<'tcx>,\n     super_traits: Option<(&Ident, &hir::GenericBounds<'_>)>,\n ) {\n     // When we are dealing with a trait, `super_traits` will be `Some`:\n@@ -257,9 +258,9 @@ fn suggest_restriction<'tcx>(\n         // The type param `T: Trait` we will suggest to introduce.\n         let type_param = format!(\"{}: {}\", type_param_name, bound_str);\n \n-        // FIXME: modify the `trait_ref` instead of string shenanigans.\n+        // FIXME: modify the `trait_pred` instead of string shenanigans.\n         // Turn `<impl Trait as Foo>::Bar: Qux` into `<T as Foo>::Bar: Qux`.\n-        let pred = trait_ref.without_const().to_predicate(tcx).to_string();\n+        let pred = trait_pred.to_predicate(tcx).to_string();\n         let pred = pred.replace(&impl_trait_str, &type_param_name);\n         let mut sugg = vec![\n             // Find the last of the generic parameters contained within the span of\n@@ -301,19 +302,19 @@ fn suggest_restriction<'tcx>(\n                 .find(|p| !matches!(p.kind, hir::GenericParamKind::Type { synthetic: true, .. })),\n             super_traits,\n         ) {\n-            (_, None) => predicate_constraint(\n-                generics,\n-                trait_ref.without_const().to_predicate(tcx).to_string(),\n+            (_, None) => predicate_constraint(generics, trait_pred.to_predicate(tcx).to_string()),\n+            (None, Some((ident, []))) => (\n+                ident.span.shrink_to_hi(),\n+                format!(\": {}\", trait_pred.print_modifiers_and_trait_path()),\n+            ),\n+            (_, Some((_, [.., bounds]))) => (\n+                bounds.span().shrink_to_hi(),\n+                format!(\" + {}\", trait_pred.print_modifiers_and_trait_path()),\n+            ),\n+            (Some(_), Some((_, []))) => (\n+                generics.span.shrink_to_hi(),\n+                format!(\": {}\", trait_pred.print_modifiers_and_trait_path()),\n             ),\n-            (None, Some((ident, []))) => {\n-                (ident.span.shrink_to_hi(), format!(\": {}\", trait_ref.print_only_trait_path()))\n-            }\n-            (_, Some((_, [.., bounds]))) => {\n-                (bounds.span().shrink_to_hi(), format!(\" + {}\", trait_ref.print_only_trait_path()))\n-            }\n-            (Some(_), Some((_, []))) => {\n-                (generics.span.shrink_to_hi(), format!(\": {}\", trait_ref.print_only_trait_path()))\n-            }\n         };\n \n         err.span_suggestion_verbose(\n@@ -329,10 +330,10 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n     fn suggest_restricting_param_bound(\n         &self,\n         mut err: &mut DiagnosticBuilder<'_>,\n-        trait_ref: ty::PolyTraitRef<'tcx>,\n+        trait_pred: ty::PolyTraitPredicate<'tcx>,\n         body_id: hir::HirId,\n     ) {\n-        let self_ty = trait_ref.skip_binder().self_ty();\n+        let self_ty = trait_pred.skip_binder().self_ty();\n         let (param_ty, projection) = match self_ty.kind() {\n             ty::Param(_) => (true, None),\n             ty::Projection(projection) => (false, Some(projection)),\n@@ -358,7 +359,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                         err,\n                         None,\n                         projection,\n-                        trait_ref,\n+                        trait_pred,\n                         Some((ident, bounds)),\n                     );\n                     return;\n@@ -372,7 +373,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                     assert!(param_ty);\n                     // Restricting `Self` for a single method.\n                     suggest_restriction(\n-                        self.tcx, &generics, \"`Self`\", err, None, projection, trait_ref, None,\n+                        self.tcx, &generics, \"`Self`\", err, None, projection, trait_pred, None,\n                     );\n                     return;\n                 }\n@@ -398,7 +399,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                         err,\n                         Some(fn_sig),\n                         projection,\n-                        trait_ref,\n+                        trait_pred,\n                         None,\n                     );\n                     return;\n@@ -417,7 +418,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                         err,\n                         None,\n                         projection,\n-                        trait_ref,\n+                        trait_pred,\n                         None,\n                     );\n                     return;\n@@ -442,15 +443,16 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 {\n                     // Missing generic type parameter bound.\n                     let param_name = self_ty.to_string();\n-                    let constraint =\n-                        with_no_trimmed_paths(|| trait_ref.print_only_trait_path().to_string());\n+                    let constraint = with_no_trimmed_paths(|| {\n+                        trait_pred.print_modifiers_and_trait_path().to_string()\n+                    });\n                     if suggest_constraining_type_param(\n                         self.tcx,\n                         generics,\n                         &mut err,\n                         &param_name,\n                         &constraint,\n-                        Some(trait_ref.def_id()),\n+                        Some(trait_pred.def_id()),\n                     ) {\n                         return;\n                     }\n@@ -471,7 +473,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 }) if !param_ty => {\n                     // Missing generic type parameter bound.\n                     let param_name = self_ty.to_string();\n-                    let constraint = trait_ref.print_only_trait_path().to_string();\n+                    let constraint = trait_pred.print_modifiers_and_trait_path().to_string();\n                     if suggest_arbitrary_trait_bound(generics, &mut err, &param_name, &constraint) {\n                         return;\n                     }\n@@ -492,7 +494,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         &self,\n         obligation: &PredicateObligation<'tcx>,\n         err: &mut DiagnosticBuilder<'tcx>,\n-        trait_ref: ty::PolyTraitRef<'tcx>,\n+        trait_pred: ty::PolyTraitPredicate<'tcx>,\n     ) {\n         // It only make sense when suggesting dereferences for arguments\n         let code = if let ObligationCauseCode::FunctionArgumentObligation { parent_code, .. } =\n@@ -505,13 +507,13 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         let param_env = obligation.param_env;\n         let body_id = obligation.cause.body_id;\n         let span = obligation.cause.span;\n-        let real_trait_ref = match &*code {\n+        let real_trait_pred = match &*code {\n             ObligationCauseCode::ImplDerivedObligation(cause)\n             | ObligationCauseCode::DerivedObligation(cause)\n-            | ObligationCauseCode::BuiltinDerivedObligation(cause) => cause.parent_trait_ref,\n-            _ => trait_ref,\n+            | ObligationCauseCode::BuiltinDerivedObligation(cause) => cause.parent_trait_pred,\n+            _ => trait_pred,\n         };\n-        let real_ty = match real_trait_ref.self_ty().no_bound_vars() {\n+        let real_ty = match real_trait_pred.self_ty().no_bound_vars() {\n             Some(ty) => ty,\n             None => return,\n         };\n@@ -522,7 +524,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 // Re-add the `&`\n                 let ty = self.tcx.mk_ref(region, TypeAndMut { ty, mutbl });\n                 let obligation =\n-                    self.mk_trait_obligation_with_new_self_ty(param_env, real_trait_ref, ty);\n+                    self.mk_trait_obligation_with_new_self_ty(param_env, real_trait_pred, ty);\n                 Some(steps).filter(|_| self.predicate_may_hold(&obligation))\n             }) {\n                 if steps > 0 {\n@@ -589,9 +591,9 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         &self,\n         obligation: &PredicateObligation<'tcx>,\n         err: &mut DiagnosticBuilder<'_>,\n-        trait_ref: ty::Binder<'tcx, ty::TraitRef<'tcx>>,\n+        trait_pred: ty::PolyTraitPredicate<'tcx>,\n     ) {\n-        let self_ty = match trait_ref.self_ty().no_bound_vars() {\n+        let self_ty = match trait_pred.self_ty().no_bound_vars() {\n             None => return,\n             Some(ty) => ty,\n         };\n@@ -611,7 +613,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         };\n \n         let new_obligation =\n-            self.mk_trait_obligation_with_new_self_ty(obligation.param_env, trait_ref, output_ty);\n+            self.mk_trait_obligation_with_new_self_ty(obligation.param_env, trait_pred, output_ty);\n \n         match self.evaluate_obligation(&new_obligation) {\n             Ok(\n@@ -682,7 +684,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         &self,\n         obligation: &PredicateObligation<'tcx>,\n         err: &mut DiagnosticBuilder<'_>,\n-        poly_trait_ref: &ty::Binder<'tcx, ty::TraitRef<'tcx>>,\n+        poly_trait_pred: ty::PolyTraitPredicate<'tcx>,\n         has_custom_message: bool,\n     ) -> bool {\n         let span = obligation.cause.span;\n@@ -715,24 +717,18 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         let param_env = obligation.param_env;\n \n         // Try to apply the original trait binding obligation by borrowing.\n-        let mut try_borrowing = |old_ref: ty::Binder<'tcx, ty::TraitRef<'tcx>>,\n+        let mut try_borrowing = |old_pred: ty::PolyTraitPredicate<'tcx>,\n                                  blacklist: &[DefId]|\n          -> bool {\n-            if blacklist.contains(&old_ref.def_id()) {\n+            if blacklist.contains(&old_pred.def_id()) {\n                 return false;\n             }\n \n-            let orig_ty = old_ref.self_ty().skip_binder();\n+            let orig_ty = old_pred.self_ty().skip_binder();\n             let mk_result = |new_ty| {\n-                let new_ref = old_ref.rebind(ty::TraitRef::new(\n-                    old_ref.def_id(),\n-                    self.tcx.mk_substs_trait(new_ty, &old_ref.skip_binder().substs[1..]),\n-                ));\n-                self.predicate_must_hold_modulo_regions(&Obligation::new(\n-                    ObligationCause::dummy(),\n-                    param_env,\n-                    new_ref.without_const().to_predicate(self.tcx),\n-                ))\n+                let obligation =\n+                    self.mk_trait_obligation_with_new_self_ty(param_env, old_pred, new_ty);\n+                self.predicate_must_hold_modulo_regions(&obligation)\n             };\n             let imm_result = mk_result(self.tcx.mk_imm_ref(self.tcx.lifetimes.re_static, orig_ty));\n             let mut_result = mk_result(self.tcx.mk_mut_ref(self.tcx.lifetimes.re_static, orig_ty));\n@@ -748,7 +744,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                     let msg = format!(\n                         \"the trait bound `{}: {}` is not satisfied\",\n                         orig_ty,\n-                        old_ref.print_only_trait_path(),\n+                        old_pred.print_modifiers_and_trait_path(),\n                     );\n                     if has_custom_message {\n                         err.note(&msg);\n@@ -764,7 +760,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                         span,\n                         &format!(\n                             \"expected an implementor of trait `{}`\",\n-                            old_ref.print_only_trait_path(),\n+                            old_pred.print_modifiers_and_trait_path(),\n                         ),\n                     );\n \n@@ -806,11 +802,11 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         };\n \n         if let ObligationCauseCode::ImplDerivedObligation(obligation) = code {\n-            try_borrowing(obligation.parent_trait_ref, &[])\n+            try_borrowing(obligation.parent_trait_pred, &[])\n         } else if let ObligationCauseCode::BindingObligation(_, _)\n         | ObligationCauseCode::ItemObligation(_) = code\n         {\n-            try_borrowing(*poly_trait_ref, &never_suggest_borrow)\n+            try_borrowing(poly_trait_pred, &never_suggest_borrow)\n         } else {\n             false\n         }\n@@ -822,7 +818,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         &self,\n         obligation: &PredicateObligation<'tcx>,\n         err: &mut DiagnosticBuilder<'_>,\n-        trait_ref: ty::Binder<'tcx, ty::TraitRef<'tcx>>,\n+        trait_pred: ty::PolyTraitPredicate<'tcx>,\n     ) {\n         let span = obligation.cause.span;\n \n@@ -834,7 +830,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 return;\n             }\n \n-            let mut suggested_ty = match trait_ref.self_ty().no_bound_vars() {\n+            let mut suggested_ty = match trait_pred.self_ty().no_bound_vars() {\n                 Some(ty) => ty,\n                 None => return,\n             };\n@@ -847,7 +843,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n \n                 let new_obligation = self.mk_trait_obligation_with_new_self_ty(\n                     obligation.param_env,\n-                    trait_ref,\n+                    trait_pred,\n                     suggested_ty,\n                 );\n \n@@ -941,7 +937,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         &self,\n         obligation: &PredicateObligation<'tcx>,\n         err: &mut DiagnosticBuilder<'_>,\n-        trait_ref: ty::Binder<'tcx, ty::TraitRef<'tcx>>,\n+        trait_pred: ty::PolyTraitPredicate<'tcx>,\n     ) {\n         let points_at_arg = matches!(\n             obligation.cause.code(),\n@@ -956,14 +952,15 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 // Do not suggest removal of borrow from type arguments.\n                 return;\n             }\n-            let trait_ref = self.resolve_vars_if_possible(trait_ref);\n-            if trait_ref.has_infer_types_or_consts() {\n+            let trait_pred = self.resolve_vars_if_possible(trait_pred);\n+            if trait_pred.has_infer_types_or_consts() {\n                 // Do not ICE while trying to find if a reborrow would succeed on a trait with\n                 // unresolved bindings.\n                 return;\n             }\n \n-            if let ty::Ref(region, t_type, mutability) = *trait_ref.skip_binder().self_ty().kind() {\n+            if let ty::Ref(region, t_type, mutability) = *trait_pred.skip_binder().self_ty().kind()\n+            {\n                 if region.is_late_bound() || t_type.has_escaping_bound_vars() {\n                     // Avoid debug assertion in `mk_obligation_for_def_id`.\n                     //\n@@ -980,7 +977,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n \n                 let new_obligation = self.mk_trait_obligation_with_new_self_ty(\n                     obligation.param_env,\n-                    trait_ref,\n+                    trait_pred,\n                     suggested_ty,\n                 );\n                 let suggested_ty_would_satisfy_obligation = self\n@@ -1002,9 +999,9 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                     } else {\n                         err.note(&format!(\n                             \"`{}` is implemented for `{:?}`, but not for `{:?}`\",\n-                            trait_ref.print_only_trait_path(),\n+                            trait_pred.print_modifiers_and_trait_path(),\n                             suggested_ty,\n-                            trait_ref.skip_binder().self_ty(),\n+                            trait_pred.skip_binder().self_ty(),\n                         ));\n                     }\n                 }\n@@ -1017,7 +1014,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         obligation: &PredicateObligation<'tcx>,\n         err: &mut DiagnosticBuilder<'_>,\n         span: Span,\n-        trait_ref: ty::Binder<'tcx, ty::TraitRef<'tcx>>,\n+        trait_pred: ty::PolyTraitPredicate<'tcx>,\n     ) {\n         let is_empty_tuple =\n             |ty: ty::Binder<'tcx, Ty<'_>>| *ty.skip_binder().kind() == ty::Tuple(ty::List::empty());\n@@ -1033,7 +1030,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             if let hir::ExprKind::Block(blk, _) = &body.value.kind {\n                 if sig.decl.output.span().overlaps(span)\n                     && blk.expr.is_none()\n-                    && is_empty_tuple(trait_ref.self_ty())\n+                    && is_empty_tuple(trait_pred.self_ty())\n                 {\n                     // FIXME(estebank): When encountering a method with a trait\n                     // bound not satisfied in the return type with a body that has\n@@ -1069,7 +1066,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         err: &mut DiagnosticBuilder<'_>,\n         span: Span,\n         obligation: &PredicateObligation<'tcx>,\n-        trait_ref: ty::Binder<'tcx, ty::TraitRef<'tcx>>,\n+        trait_pred: ty::PolyTraitPredicate<'tcx>,\n     ) -> bool {\n         match obligation.cause.code().peel_derives() {\n             // Only suggest `impl Trait` if the return type is unsized because it is `dyn Trait`.\n@@ -1088,8 +1085,8 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             return false;\n         };\n         let body = hir.body(*body_id);\n-        let trait_ref = self.resolve_vars_if_possible(trait_ref);\n-        let ty = trait_ref.skip_binder().self_ty();\n+        let trait_pred = self.resolve_vars_if_possible(trait_pred);\n+        let ty = trait_pred.skip_binder().self_ty();\n         let is_object_safe = match ty.kind() {\n             ty::Dynamic(predicates, _) => {\n                 // If the `dyn Trait` is not object safe, do not suggest `Box<dyn Trait>`.\n@@ -1326,9 +1323,9 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             trait_ref.rebind(sig).to_string()\n         }\n \n-        let argument_kind = match expected_ref.skip_binder().substs.type_at(0) {\n-            t if t.is_closure() => \"closure\",\n-            t if t.is_generator() => \"generator\",\n+        let argument_kind = match expected_ref.skip_binder().self_ty().kind() {\n+            ty::Closure(..) => \"closure\",\n+            ty::Generator(..) => \"generator\",\n             _ => \"function\",\n         };\n         let mut err = struct_span_err!(\n@@ -1455,7 +1452,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         // bound was introduced. At least one generator should be present for this diagnostic to be\n         // modified.\n         let (mut trait_ref, mut target_ty) = match obligation.predicate.kind().skip_binder() {\n-            ty::PredicateKind::Trait(p) => (Some(p.trait_ref), Some(p.self_ty())),\n+            ty::PredicateKind::Trait(p) => (Some(p), Some(p.self_ty())),\n             _ => (None, None),\n         };\n         let mut generator = None;\n@@ -1473,11 +1470,11 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 ObligationCauseCode::DerivedObligation(derived_obligation)\n                 | ObligationCauseCode::BuiltinDerivedObligation(derived_obligation)\n                 | ObligationCauseCode::ImplDerivedObligation(derived_obligation) => {\n-                    let ty = derived_obligation.parent_trait_ref.skip_binder().self_ty();\n+                    let ty = derived_obligation.parent_trait_pred.skip_binder().self_ty();\n                     debug!(\n                         \"maybe_note_obligation_cause_for_async_await: \\\n                             parent_trait_ref={:?} self_ty.kind={:?}\",\n-                        derived_obligation.parent_trait_ref,\n+                        derived_obligation.parent_trait_pred,\n                         ty.kind()\n                     );\n \n@@ -1495,7 +1492,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                             seen_upvar_tys_infer_tuple = true;\n                         }\n                         _ if generator.is_none() => {\n-                            trait_ref = Some(derived_obligation.parent_trait_ref.skip_binder());\n+                            trait_ref = Some(derived_obligation.parent_trait_pred.skip_binder());\n                             target_ty = Some(ty);\n                         }\n                         _ => {}\n@@ -1651,7 +1648,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         interior_extra_info: Option<(Option<Span>, Span, Option<hir::HirId>, Option<Span>)>,\n         inner_generator_body: Option<&hir::Body<'tcx>>,\n         outer_generator: Option<DefId>,\n-        trait_ref: ty::TraitRef<'tcx>,\n+        trait_pred: ty::TraitPredicate<'tcx>,\n         target_ty: Ty<'tcx>,\n         typeck_results: Option<&ty::TypeckResults<'tcx>>,\n         obligation: &PredicateObligation<'tcx>,\n@@ -1671,7 +1668,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         // not implemented.\n         let hir = self.tcx.hir();\n         let trait_explanation = if let Some(name @ (sym::Send | sym::Sync)) =\n-            self.tcx.get_diagnostic_name(trait_ref.def_id)\n+            self.tcx.get_diagnostic_name(trait_pred.def_id())\n         {\n             let (trait_name, trait_verb) =\n                 if name == sym::Send { (\"`Send`\", \"sent\") } else { (\"`Sync`\", \"shared\") };\n@@ -1713,7 +1710,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n \n             format!(\"is not {}\", trait_name)\n         } else {\n-            format!(\"does not implement `{}`\", trait_ref.print_only_trait_path())\n+            format!(\"does not implement `{}`\", trait_pred.print_modifiers_and_trait_path())\n         };\n \n         let mut explain_yield = |interior_span: Span,\n@@ -1894,6 +1891,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         self.note_obligation_cause_code(\n             err,\n             &obligation.predicate,\n+            obligation.param_env,\n             next_code.unwrap(),\n             &mut Vec::new(),\n             &mut Default::default(),\n@@ -1904,6 +1902,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         &self,\n         err: &mut DiagnosticBuilder<'_>,\n         predicate: &T,\n+        param_env: ty::ParamEnv<'tcx>,\n         cause_code: &ObligationCauseCode<'tcx>,\n         obligated_types: &mut Vec<&ty::TyS<'tcx>>,\n         seen_requirements: &mut FxHashSet<DefId>,\n@@ -2134,7 +2133,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 err.note(\"shared static variables must have a type that implements `Sync`\");\n             }\n             ObligationCauseCode::BuiltinDerivedObligation(ref data) => {\n-                let parent_trait_ref = self.resolve_vars_if_possible(data.parent_trait_ref);\n+                let parent_trait_ref = self.resolve_vars_if_possible(data.parent_trait_pred);\n                 let ty = parent_trait_ref.skip_binder().self_ty();\n                 if parent_trait_ref.references_error() {\n                     err.cancel();\n@@ -2149,7 +2148,8 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                     if let ObligationCauseCode::BuiltinDerivedObligation(ref data) =\n                         *data.parent_code\n                     {\n-                        let parent_trait_ref = self.resolve_vars_if_possible(data.parent_trait_ref);\n+                        let parent_trait_ref =\n+                            self.resolve_vars_if_possible(data.parent_trait_pred);\n                         let ty = parent_trait_ref.skip_binder().self_ty();\n                         matches!(ty.kind(), ty::Generator(..))\n                             || matches!(ty.kind(), ty::Closure(..))\n@@ -2172,13 +2172,14 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n \n                 obligated_types.push(ty);\n \n-                let parent_predicate = parent_trait_ref.without_const().to_predicate(tcx);\n+                let parent_predicate = parent_trait_ref.to_predicate(tcx);\n                 if !self.is_recursive_obligation(obligated_types, &data.parent_code) {\n                     // #74711: avoid a stack overflow\n                     ensure_sufficient_stack(|| {\n                         self.note_obligation_cause_code(\n                             err,\n                             &parent_predicate,\n+                            param_env,\n                             &data.parent_code,\n                             obligated_types,\n                             seen_requirements,\n@@ -2189,6 +2190,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                         self.note_obligation_cause_code(\n                             err,\n                             &parent_predicate,\n+                            param_env,\n                             &cause_code.peel_derives(),\n                             obligated_types,\n                             seen_requirements,\n@@ -2197,17 +2199,18 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 }\n             }\n             ObligationCauseCode::ImplDerivedObligation(ref data) => {\n-                let mut parent_trait_ref = self.resolve_vars_if_possible(data.parent_trait_ref);\n-                let parent_def_id = parent_trait_ref.def_id();\n+                let mut parent_trait_pred = self.resolve_vars_if_possible(data.parent_trait_pred);\n+                parent_trait_pred.remap_constness_diag(param_env);\n+                let parent_def_id = parent_trait_pred.def_id();\n                 let msg = format!(\n                     \"required because of the requirements on the impl of `{}` for `{}`\",\n-                    parent_trait_ref.print_only_trait_path(),\n-                    parent_trait_ref.skip_binder().self_ty()\n+                    parent_trait_pred.print_modifiers_and_trait_path(),\n+                    parent_trait_pred.skip_binder().self_ty()\n                 );\n                 let mut candidates = vec![];\n                 self.tcx.for_each_relevant_impl(\n                     parent_def_id,\n-                    parent_trait_ref.self_ty().skip_binder(),\n+                    parent_trait_pred.self_ty().skip_binder(),\n                     |impl_def_id| match self.tcx.hir().get_if_local(impl_def_id) {\n                         Some(Node::Item(hir::Item {\n                             kind: hir::ItemKind::Impl(hir::Impl { .. }),\n@@ -2236,21 +2239,21 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                     _ => err.note(&msg),\n                 };\n \n-                let mut parent_predicate = parent_trait_ref.without_const().to_predicate(tcx);\n+                let mut parent_predicate = parent_trait_pred.to_predicate(tcx);\n                 let mut data = data;\n                 let mut count = 0;\n                 seen_requirements.insert(parent_def_id);\n                 while let ObligationCauseCode::ImplDerivedObligation(child) = &*data.parent_code {\n                     // Skip redundant recursive obligation notes. See `ui/issue-20413.rs`.\n-                    let child_trait_ref = self.resolve_vars_if_possible(child.parent_trait_ref);\n-                    let child_def_id = child_trait_ref.def_id();\n+                    let child_trait_pred = self.resolve_vars_if_possible(child.parent_trait_pred);\n+                    let child_def_id = child_trait_pred.def_id();\n                     if seen_requirements.insert(child_def_id) {\n                         break;\n                     }\n                     count += 1;\n                     data = child;\n-                    parent_predicate = child_trait_ref.without_const().to_predicate(tcx);\n-                    parent_trait_ref = child_trait_ref;\n+                    parent_predicate = child_trait_pred.to_predicate(tcx);\n+                    parent_trait_pred = child_trait_pred;\n                 }\n                 if count > 0 {\n                     err.note(&format!(\n@@ -2260,29 +2263,31 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                     ));\n                     err.note(&format!(\n                         \"required because of the requirements on the impl of `{}` for `{}`\",\n-                        parent_trait_ref.print_only_trait_path(),\n-                        parent_trait_ref.skip_binder().self_ty()\n+                        parent_trait_pred.print_modifiers_and_trait_path(),\n+                        parent_trait_pred.skip_binder().self_ty()\n                     ));\n                 }\n                 // #74711: avoid a stack overflow\n                 ensure_sufficient_stack(|| {\n                     self.note_obligation_cause_code(\n                         err,\n                         &parent_predicate,\n+                        param_env,\n                         &data.parent_code,\n                         obligated_types,\n                         seen_requirements,\n                     )\n                 });\n             }\n             ObligationCauseCode::DerivedObligation(ref data) => {\n-                let parent_trait_ref = self.resolve_vars_if_possible(data.parent_trait_ref);\n-                let parent_predicate = parent_trait_ref.without_const().to_predicate(tcx);\n+                let parent_trait_ref = self.resolve_vars_if_possible(data.parent_trait_pred);\n+                let parent_predicate = parent_trait_ref.to_predicate(tcx);\n                 // #74711: avoid a stack overflow\n                 ensure_sufficient_stack(|| {\n                     self.note_obligation_cause_code(\n                         err,\n                         &parent_predicate,\n+                        param_env,\n                         &data.parent_code,\n                         obligated_types,\n                         seen_requirements,\n@@ -2336,6 +2341,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                     self.note_obligation_cause_code(\n                         err,\n                         predicate,\n+                        param_env,\n                         &parent_code,\n                         obligated_types,\n                         seen_requirements,\n@@ -2426,15 +2432,15 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         &self,\n         err: &mut DiagnosticBuilder<'_>,\n         obligation: &PredicateObligation<'tcx>,\n-        trait_ref: ty::Binder<'tcx, ty::TraitRef<'tcx>>,\n+        trait_pred: ty::PolyTraitPredicate<'tcx>,\n         span: Span,\n     ) {\n         debug!(\n-            \"suggest_await_before_try: obligation={:?}, span={:?}, trait_ref={:?}, trait_ref_self_ty={:?}\",\n+            \"suggest_await_before_try: obligation={:?}, span={:?}, trait_pred={:?}, trait_pred_self_ty={:?}\",\n             obligation,\n             span,\n-            trait_ref,\n-            trait_ref.self_ty()\n+            trait_pred,\n+            trait_pred.self_ty()\n         );\n         let body_hir_id = obligation.cause.body_id;\n         let item_id = self.tcx.hir().get_parent_node(body_hir_id);\n@@ -2444,7 +2450,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             if let Some(hir::GeneratorKind::Async(_)) = body.generator_kind {\n                 let future_trait = self.tcx.require_lang_item(LangItem::Future, None);\n \n-                let self_ty = self.resolve_vars_if_possible(trait_ref.self_ty());\n+                let self_ty = self.resolve_vars_if_possible(trait_pred.self_ty());\n \n                 // Do not check on infer_types to avoid panic in evaluate_obligation.\n                 if self_ty.has_infer_types() {\n@@ -2464,7 +2470,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 let projection_ty = ty::ProjectionTy {\n                     // `T`\n                     substs: self.tcx.mk_substs_trait(\n-                        trait_ref.self_ty().skip_binder(),\n+                        trait_pred.self_ty().skip_binder(),\n                         self.fresh_substs_for_item(span, item_def_id),\n                     ),\n                     // `Future::Output`\n@@ -2489,7 +2495,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 );\n                 let try_obligation = self.mk_trait_obligation_with_new_self_ty(\n                     obligation.param_env,\n-                    trait_ref,\n+                    trait_pred,\n                     normalized_ty,\n                 );\n                 debug!(\"suggest_await_before_try: try_trait_obligation {:?}\", try_obligation);"}, {"sha": "6b20476b95594de9862dc530417b850ea9a0728b", "filename": "compiler/rustc_trait_selection/src/traits/on_unimplemented.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/e2b2bfe10ce5d36e9568173cb6cb9c7456b03a61/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fon_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2b2bfe10ce5d36e9568173cb6cb9c7456b03a61/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fon_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fon_unimplemented.rs?ref=e2b2bfe10ce5d36e9568173cb6cb9c7456b03a61", "patch": "@@ -19,6 +19,7 @@ pub struct OnUnimplementedDirective {\n     pub label: Option<OnUnimplementedFormatString>,\n     pub note: Option<OnUnimplementedFormatString>,\n     pub enclosing_scope: Option<OnUnimplementedFormatString>,\n+    pub append_const_msg: Option<Option<Symbol>>,\n }\n \n #[derive(Default)]\n@@ -27,6 +28,11 @@ pub struct OnUnimplementedNote {\n     pub label: Option<String>,\n     pub note: Option<String>,\n     pub enclosing_scope: Option<String>,\n+    /// Append a message for `~const Trait` errors. `None` means not requested and\n+    /// should fallback to a generic message, `Some(None)` suggests using the default\n+    /// appended message, `Some(Some(s))` suggests use the `s` message instead of the\n+    /// default one..\n+    pub append_const_msg: Option<Option<Symbol>>,\n }\n \n fn parse_error(\n@@ -89,6 +95,7 @@ impl<'tcx> OnUnimplementedDirective {\n         let mut note = None;\n         let mut enclosing_scope = None;\n         let mut subcommands = vec![];\n+        let mut append_const_msg = None;\n \n         let parse_value = |value_str| {\n             OnUnimplementedFormatString::try_parse(tcx, trait_def_id, value_str, span).map(Some)\n@@ -131,6 +138,14 @@ impl<'tcx> OnUnimplementedDirective {\n                     }\n                     continue;\n                 }\n+            } else if item.has_name(sym::append_const_msg) && append_const_msg.is_none() {\n+                if let Some(msg) = item.value_str() {\n+                    append_const_msg = Some(Some(msg));\n+                    continue;\n+                } else if item.is_word() {\n+                    append_const_msg = Some(None);\n+                    continue;\n+                }\n             }\n \n             // nothing found\n@@ -153,6 +168,7 @@ impl<'tcx> OnUnimplementedDirective {\n                 label,\n                 note,\n                 enclosing_scope,\n+                append_const_msg,\n             })\n         }\n     }\n@@ -183,6 +199,7 @@ impl<'tcx> OnUnimplementedDirective {\n                 )?),\n                 note: None,\n                 enclosing_scope: None,\n+                append_const_msg: None,\n             }))\n         } else {\n             return Err(ErrorReported);\n@@ -201,6 +218,7 @@ impl<'tcx> OnUnimplementedDirective {\n         let mut label = None;\n         let mut note = None;\n         let mut enclosing_scope = None;\n+        let mut append_const_msg = None;\n         info!(\"evaluate({:?}, trait_ref={:?}, options={:?})\", self, trait_ref, options);\n \n         for command in self.subcommands.iter().chain(Some(self)).rev() {\n@@ -235,6 +253,8 @@ impl<'tcx> OnUnimplementedDirective {\n             if let Some(ref enclosing_scope_) = command.enclosing_scope {\n                 enclosing_scope = Some(enclosing_scope_.clone());\n             }\n+\n+            append_const_msg = command.append_const_msg.clone();\n         }\n \n         let options: FxHashMap<Symbol, String> =\n@@ -244,6 +264,7 @@ impl<'tcx> OnUnimplementedDirective {\n             message: message.map(|m| m.format(tcx, trait_ref, &options)),\n             note: note.map(|n| n.format(tcx, trait_ref, &options)),\n             enclosing_scope: enclosing_scope.map(|e_s| e_s.format(tcx, trait_ref, &options)),\n+            append_const_msg,\n         }\n     }\n }"}, {"sha": "2e20ea34e10ef15693997fc9182c76e129ddc71e", "filename": "compiler/rustc_trait_selection/src/traits/select/confirmation.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e2b2bfe10ce5d36e9568173cb6cb9c7456b03a61/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2b2bfe10ce5d36e9568173cb6cb9c7456b03a61/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs?ref=e2b2bfe10ce5d36e9568173cb6cb9c7456b03a61", "patch": "@@ -659,7 +659,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             _ => bug!(\"closure candidate for non-closure {:?}\", obligation),\n         };\n \n-        let obligation_predicate = obligation.predicate.to_poly_trait_ref();\n+        let obligation_predicate = obligation.predicate;\n         let Normalized { value: obligation_predicate, mut obligations } =\n             ensure_sufficient_stack(|| {\n                 normalize_with_depth(\n@@ -689,7 +689,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         obligations.extend(self.confirm_poly_trait_refs(\n             obligation.cause.clone(),\n             obligation.param_env,\n-            obligation_predicate,\n+            obligation_predicate.to_poly_trait_ref(),\n             trait_ref,\n         )?);\n "}, {"sha": "ae5369054837597bac04241bee668339fcd48112", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e2b2bfe10ce5d36e9568173cb6cb9c7456b03a61/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2b2bfe10ce5d36e9568173cb6cb9c7456b03a61/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=e2b2bfe10ce5d36e9568173cb6cb9c7456b03a61", "patch": "@@ -2413,7 +2413,7 @@ impl<'tcx> TraitObligationExt<'tcx> for TraitObligation<'tcx> {\n         // chain. Ideally, we should have a way to configure this either\n         // by using -Z verbose or just a CLI argument.\n         let derived_cause = DerivedObligationCause {\n-            parent_trait_ref: obligation.predicate.to_poly_trait_ref(),\n+            parent_trait_pred: obligation.predicate,\n             parent_code: obligation.cause.clone_code(),\n         };\n         let derived_code = variant(derived_cause);"}, {"sha": "2c5e7e40cc862912aeb385180f64c17b1c612b3f", "filename": "compiler/rustc_trait_selection/src/traits/specialize/mod.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e2b2bfe10ce5d36e9568173cb6cb9c7456b03a61/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2b2bfe10ce5d36e9568173cb6cb9c7456b03a61/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fmod.rs?ref=e2b2bfe10ce5d36e9568173cb6cb9c7456b03a61", "patch": "@@ -506,12 +506,21 @@ crate fn to_pretty_impl_header(tcx: TyCtxt<'_>, impl_def_id: DefId) -> Option<St\n     let mut pretty_predicates =\n         Vec::with_capacity(predicates.len() + types_without_default_bounds.len());\n \n-    for (p, _) in predicates {\n+    for (mut p, _) in predicates {\n         if let Some(poly_trait_ref) = p.to_opt_poly_trait_pred() {\n             if Some(poly_trait_ref.def_id()) == sized_trait {\n                 types_without_default_bounds.remove(poly_trait_ref.self_ty().skip_binder());\n                 continue;\n             }\n+\n+            if ty::BoundConstness::ConstIfConst == poly_trait_ref.skip_binder().constness {\n+                let new_trait_pred = poly_trait_ref.map_bound(|mut trait_pred| {\n+                    trait_pred.constness = ty::BoundConstness::NotConst;\n+                    trait_pred\n+                });\n+\n+                p = tcx.mk_predicate(new_trait_pred.map_bound(ty::PredicateKind::Trait))\n+            }\n         }\n         pretty_predicates.push(p.to_string());\n     }"}, {"sha": "493cb199f114485d544538a14e22f1e8dbd7d41e", "filename": "compiler/rustc_trait_selection/src/traits/wf.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e2b2bfe10ce5d36e9568173cb6cb9c7456b03a61/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2b2bfe10ce5d36e9568173cb6cb9c7456b03a61/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs?ref=e2b2bfe10ce5d36e9568173cb6cb9c7456b03a61", "patch": "@@ -306,10 +306,9 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n \n         let extend = |obligation: traits::PredicateObligation<'tcx>| {\n             let mut cause = cause.clone();\n-            if let Some(parent_trait_ref) = obligation.predicate.to_opt_poly_trait_pred() {\n+            if let Some(parent_trait_pred) = obligation.predicate.to_opt_poly_trait_pred() {\n                 let derived_cause = traits::DerivedObligationCause {\n-                    // FIXME(fee1-dead): when improving error messages, change this to PolyTraitPredicate\n-                    parent_trait_ref: parent_trait_ref.map_bound(|t| t.trait_ref),\n+                    parent_trait_pred,\n                     parent_code: obligation.cause.clone_code(),\n                 };\n                 *cause.make_mut_code() ="}, {"sha": "4b56cc5321b37d577aa11eea427250d4810a6c7b", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/checks.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e2b2bfe10ce5d36e9568173cb6cb9c7456b03a61/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2b2bfe10ce5d36e9568173cb6cb9c7456b03a61/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs?ref=e2b2bfe10ce5d36e9568173cb6cb9c7456b03a61", "patch": "@@ -1021,7 +1021,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 ObligationCauseCode::BuiltinDerivedObligation(code) |\n                 ObligationCauseCode::ImplDerivedObligation(code) |\n                 ObligationCauseCode::DerivedObligation(code) => {\n-                    code.parent_trait_ref.self_ty().skip_binder().into()\n+                    code.parent_trait_pred.self_ty().skip_binder().into()\n                 }\n                 _ if let ty::PredicateKind::Trait(predicate) =\n                     error.obligation.predicate.kind().skip_binder() => {"}, {"sha": "58ea197d3e94041c7b6157a24c1e2d4d6c013cb9", "filename": "compiler/rustc_typeck/src/check/method/suggest.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e2b2bfe10ce5d36e9568173cb6cb9c7456b03a61/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2b2bfe10ce5d36e9568173cb6cb9c7456b03a61/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs?ref=e2b2bfe10ce5d36e9568173cb6cb9c7456b03a61", "patch": "@@ -823,9 +823,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             _ => None,\n                         })\n                     {\n-                        let parent_trait_ref = data.parent_trait_ref;\n+                        let parent_trait_ref = data.parent_trait_pred;\n                         let parent_def_id = parent_trait_ref.def_id();\n-                        let path = parent_trait_ref.print_only_trait_path();\n+                        let path = parent_trait_ref.print_modifiers_and_trait_path();\n                         let tr_self_ty = parent_trait_ref.skip_binder().self_ty();\n                         let mut candidates = vec![];\n                         self.tcx.for_each_relevant_impl("}, {"sha": "1af352d542ac65fcf8dd99780cd9badf773bb217", "filename": "library/core/src/cmp.rs", "status": "modified", "additions": 28, "deletions": 6, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/e2b2bfe10ce5d36e9568173cb6cb9c7456b03a61/library%2Fcore%2Fsrc%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2b2bfe10ce5d36e9568173cb6cb9c7456b03a61/library%2Fcore%2Fsrc%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fcmp.rs?ref=e2b2bfe10ce5d36e9568173cb6cb9c7456b03a61", "patch": "@@ -199,9 +199,20 @@ use self::Ordering::*;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(alias = \"==\")]\n #[doc(alias = \"!=\")]\n-#[rustc_on_unimplemented(\n-    message = \"can't compare `{Self}` with `{Rhs}`\",\n-    label = \"no implementation for `{Self} == {Rhs}`\"\n+#[cfg_attr(\n+    bootstrap,\n+    rustc_on_unimplemented(\n+        message = \"can't compare `{Self}` with `{Rhs}`\",\n+        label = \"no implementation for `{Self} == {Rhs}`\"\n+    )\n+)]\n+#[cfg_attr(\n+    not(bootstrap),\n+    rustc_on_unimplemented(\n+        message = \"can't compare `{Self}` with `{Rhs}`\",\n+        label = \"no implementation for `{Self} == {Rhs}`\",\n+        append_const_msg,\n+    )\n )]\n #[rustc_diagnostic_item = \"PartialEq\"]\n pub trait PartialEq<Rhs: ?Sized = Self> {\n@@ -1031,9 +1042,20 @@ impl PartialOrd for Ordering {\n #[doc(alias = \"<\")]\n #[doc(alias = \"<=\")]\n #[doc(alias = \">=\")]\n-#[rustc_on_unimplemented(\n-    message = \"can't compare `{Self}` with `{Rhs}`\",\n-    label = \"no implementation for `{Self} < {Rhs}` and `{Self} > {Rhs}`\"\n+#[cfg_attr(\n+    bootstrap,\n+    rustc_on_unimplemented(\n+        message = \"can't compare `{Self}` with `{Rhs}`\",\n+        label = \"no implementation for `{Self} < {Rhs}` and `{Self} > {Rhs}`\",\n+    )\n+)]\n+#[cfg_attr(\n+    not(bootstrap),\n+    rustc_on_unimplemented(\n+        message = \"can't compare `{Self}` with `{Rhs}`\",\n+        label = \"no implementation for `{Self} < {Rhs}` and `{Self} > {Rhs}`\",\n+        append_const_msg,\n+    )\n )]\n #[rustc_diagnostic_item = \"PartialOrd\"]\n pub trait PartialOrd<Rhs: ?Sized = Self>: PartialEq<Rhs> {"}, {"sha": "e367be8c167c720d64ecb26125d4d25c963e7980", "filename": "library/core/src/ops/arith.rs", "status": "modified", "additions": 30, "deletions": 5, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/e2b2bfe10ce5d36e9568173cb6cb9c7456b03a61/library%2Fcore%2Fsrc%2Fops%2Farith.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2b2bfe10ce5d36e9568173cb6cb9c7456b03a61/library%2Fcore%2Fsrc%2Fops%2Farith.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fops%2Farith.rs?ref=e2b2bfe10ce5d36e9568173cb6cb9c7456b03a61", "patch": "@@ -65,11 +65,36 @@\n /// ```\n #[lang = \"add\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_on_unimplemented(\n-    on(all(_Self = \"{integer}\", Rhs = \"{float}\"), message = \"cannot add a float to an integer\",),\n-    on(all(_Self = \"{float}\", Rhs = \"{integer}\"), message = \"cannot add an integer to a float\",),\n-    message = \"cannot add `{Rhs}` to `{Self}`\",\n-    label = \"no implementation for `{Self} + {Rhs}`\"\n+#[cfg_attr(\n+    bootstrap,\n+    rustc_on_unimplemented(\n+        on(\n+            all(_Self = \"{integer}\", Rhs = \"{float}\"),\n+            message = \"cannot add a float to an integer\",\n+        ),\n+        on(\n+            all(_Self = \"{float}\", Rhs = \"{integer}\"),\n+            message = \"cannot add an integer to a float\",\n+        ),\n+        message = \"cannot add `{Rhs}` to `{Self}`\",\n+        label = \"no implementation for `{Self} + {Rhs}`\"\n+    )\n+)]\n+#[cfg_attr(\n+    not(bootstrap),\n+    rustc_on_unimplemented(\n+        on(\n+            all(_Self = \"{integer}\", Rhs = \"{float}\"),\n+            message = \"cannot add a float to an integer\",\n+        ),\n+        on(\n+            all(_Self = \"{float}\", Rhs = \"{integer}\"),\n+            message = \"cannot add an integer to a float\",\n+        ),\n+        message = \"cannot add `{Rhs}` to `{Self}`\",\n+        label = \"no implementation for `{Self} + {Rhs}`\",\n+        append_const_msg,\n+    )\n )]\n #[doc(alias = \"+\")]\n pub trait Add<Rhs = Self> {"}, {"sha": "f3c82c5f96816280de4c0de4e239561b3f5c9bdf", "filename": "src/test/ui/consts/const-block-const-bound.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e2b2bfe10ce5d36e9568173cb6cb9c7456b03a61/src%2Ftest%2Fui%2Fconsts%2Fconst-block-const-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2b2bfe10ce5d36e9568173cb6cb9c7456b03a61/src%2Ftest%2Fui%2Fconsts%2Fconst-block-const-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-block-const-bound.rs?ref=e2b2bfe10ce5d36e9568173cb6cb9c7456b03a61", "patch": "@@ -16,8 +16,8 @@ impl !Drop for NonDrop {}\n fn main() {\n     const {\n         f(UnconstDrop);\n-        //~^ ERROR the trait bound `UnconstDrop: Drop` is not satisfied\n+        //~^ ERROR the trait bound `UnconstDrop: ~const Drop` is not satisfied\n         f(NonDrop);\n-        //~^ ERROR the trait bound `NonDrop: Drop` is not satisfied\n+        //~^ ERROR the trait bound `NonDrop: ~const Drop` is not satisfied\n     }\n }"}, {"sha": "b5f5694ba83284d7581f60aa9ce97636ac401e39", "filename": "src/test/ui/consts/const-block-const-bound.stderr", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e2b2bfe10ce5d36e9568173cb6cb9c7456b03a61/src%2Ftest%2Fui%2Fconsts%2Fconst-block-const-bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e2b2bfe10ce5d36e9568173cb6cb9c7456b03a61/src%2Ftest%2Fui%2Fconsts%2Fconst-block-const-bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-block-const-bound.stderr?ref=e2b2bfe10ce5d36e9568173cb6cb9c7456b03a61", "patch": "@@ -1,8 +1,8 @@\n-error[E0277]: the trait bound `UnconstDrop: Drop` is not satisfied\n+error[E0277]: the trait bound `UnconstDrop: ~const Drop` is not satisfied\n   --> $DIR/const-block-const-bound.rs:18:11\n    |\n LL |         f(UnconstDrop);\n-   |         - ^^^^^^^^^^^ the trait `Drop` is not implemented for `UnconstDrop`\n+   |         - ^^^^^^^^^^^ expected an implementor of trait `~const Drop`\n    |         |\n    |         required by a bound introduced by this call\n    |\n@@ -11,16 +11,18 @@ note: required by a bound in `f`\n    |\n LL | const fn f<T: ~const Drop>(x: T) {}\n    |               ^^^^^^^^^^^ required by this bound in `f`\n-help: consider introducing a `where` bound, but there might be an alternative better way to express this requirement\n+help: consider borrowing here\n    |\n-LL | fn main() where UnconstDrop: Drop {\n-   |           +++++++++++++++++++++++\n+LL |         f(&UnconstDrop);\n+   |           +\n+LL |         f(&mut UnconstDrop);\n+   |           ++++\n \n-error[E0277]: the trait bound `NonDrop: Drop` is not satisfied\n+error[E0277]: the trait bound `NonDrop: ~const Drop` is not satisfied\n   --> $DIR/const-block-const-bound.rs:20:11\n    |\n LL |         f(NonDrop);\n-   |         - ^^^^^^^ the trait `Drop` is not implemented for `NonDrop`\n+   |         - ^^^^^^^ expected an implementor of trait `~const Drop`\n    |         |\n    |         required by a bound introduced by this call\n    |\n@@ -29,6 +31,12 @@ note: required by a bound in `f`\n    |\n LL | const fn f<T: ~const Drop>(x: T) {}\n    |               ^^^^^^^^^^^ required by this bound in `f`\n+help: consider borrowing here\n+   |\n+LL |         f(&NonDrop);\n+   |           +\n+LL |         f(&mut NonDrop);\n+   |           ++++\n \n error: aborting due to 2 previous errors\n "}, {"sha": "7d924e2b7f366880b1243b3e3a3f6d56ab3b83a2", "filename": "src/test/ui/intrinsics/const-eval-select-bad.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e2b2bfe10ce5d36e9568173cb6cb9c7456b03a61/src%2Ftest%2Fui%2Fintrinsics%2Fconst-eval-select-bad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2b2bfe10ce5d36e9568173cb6cb9c7456b03a61/src%2Ftest%2Fui%2Fintrinsics%2Fconst-eval-select-bad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fintrinsics%2Fconst-eval-select-bad.rs?ref=e2b2bfe10ce5d36e9568173cb6cb9c7456b03a61", "patch": "@@ -4,9 +4,9 @@ use std::intrinsics::const_eval_select;\n \n const fn not_fn_items() {\n     const_eval_select((), || {}, || {});\n-    //~^ ERROR expected a `FnOnce<()>` closure\n+    //~^ ERROR the trait bound\n     const_eval_select((), 42, 0xDEADBEEF);\n-    //~^ ERROR expected a `FnOnce<()>` closure\n+    //~^ ERROR the trait bound\n     //~| ERROR expected a `FnOnce<()>` closure\n }\n "}, {"sha": "083b00645388eb02d09352b79fe9634919134e14", "filename": "src/test/ui/intrinsics/const-eval-select-bad.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e2b2bfe10ce5d36e9568173cb6cb9c7456b03a61/src%2Ftest%2Fui%2Fintrinsics%2Fconst-eval-select-bad.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e2b2bfe10ce5d36e9568173cb6cb9c7456b03a61/src%2Ftest%2Fui%2Fintrinsics%2Fconst-eval-select-bad.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fintrinsics%2Fconst-eval-select-bad.stderr?ref=e2b2bfe10ce5d36e9568173cb6cb9c7456b03a61", "patch": "@@ -1,28 +1,28 @@\n-error[E0277]: expected a `FnOnce<()>` closure, found `[closure@$DIR/const-eval-select-bad.rs:6:27: 6:32]`\n+error[E0277]: the trait bound `[closure@$DIR/const-eval-select-bad.rs:6:27: 6:32]: ~const FnOnce<()>` is not satisfied\n   --> $DIR/const-eval-select-bad.rs:6:27\n    |\n LL |     const_eval_select((), || {}, || {});\n    |     -----------------     ^^^^^ expected an `FnOnce<()>` closure, found `[closure@$DIR/const-eval-select-bad.rs:6:27: 6:32]`\n    |     |\n    |     required by a bound introduced by this call\n    |\n-   = help: the trait `FnOnce<()>` is not implemented for `[closure@$DIR/const-eval-select-bad.rs:6:27: 6:32]`\n+   = help: the trait `~const FnOnce<()>` is not implemented for `[closure@$DIR/const-eval-select-bad.rs:6:27: 6:32]`\n    = note: wrap the `[closure@$DIR/const-eval-select-bad.rs:6:27: 6:32]` in a closure with no arguments: `|| { /* code */ }`\n note: required by a bound in `const_eval_select`\n   --> $SRC_DIR/core/src/intrinsics.rs:LL:COL\n    |\n LL |     F: ~const FnOnce<ARG, Output = RET>,\n    |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ required by this bound in `const_eval_select`\n \n-error[E0277]: expected a `FnOnce<()>` closure, found `{integer}`\n+error[E0277]: the trait bound `{integer}: ~const FnOnce<()>` is not satisfied\n   --> $DIR/const-eval-select-bad.rs:8:27\n    |\n LL |     const_eval_select((), 42, 0xDEADBEEF);\n    |     -----------------     ^^ expected an `FnOnce<()>` closure, found `{integer}`\n    |     |\n    |     required by a bound introduced by this call\n    |\n-   = help: the trait `FnOnce<()>` is not implemented for `{integer}`\n+   = help: the trait `~const FnOnce<()>` is not implemented for `{integer}`\n    = note: wrap the `{integer}` in a closure with no arguments: `|| { /* code */ }`\n note: required by a bound in `const_eval_select`\n   --> $SRC_DIR/core/src/intrinsics.rs:LL:COL"}, {"sha": "99eacaa837f91a5bff0ef288af7b8081c0b71143", "filename": "src/test/ui/rfc-2632-const-trait-impl/assoc-type.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e2b2bfe10ce5d36e9568173cb6cb9c7456b03a61/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fassoc-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2b2bfe10ce5d36e9568173cb6cb9c7456b03a61/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fassoc-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fassoc-type.rs?ref=e2b2bfe10ce5d36e9568173cb6cb9c7456b03a61", "patch": "@@ -1,5 +1,5 @@\n-// FIXME(fee1-dead): this should have a better error message\n #![feature(const_trait_impl)]\n+\n struct NonConstAdd(i32);\n \n impl std::ops::Add for NonConstAdd {\n@@ -16,7 +16,7 @@ trait Foo {\n \n impl const Foo for NonConstAdd {\n     type Bar = NonConstAdd;\n-    //~^ ERROR\n+    //~^ ERROR: cannot add `NonConstAdd` to `NonConstAdd` in const contexts\n }\n \n trait Baz {"}, {"sha": "429b9f3364be1d46e52faa50f0eee6a3c5a77fbd", "filename": "src/test/ui/rfc-2632-const-trait-impl/assoc-type.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e2b2bfe10ce5d36e9568173cb6cb9c7456b03a61/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fassoc-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e2b2bfe10ce5d36e9568173cb6cb9c7456b03a61/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fassoc-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fassoc-type.stderr?ref=e2b2bfe10ce5d36e9568173cb6cb9c7456b03a61", "patch": "@@ -1,19 +1,19 @@\n-error[E0277]: cannot add `NonConstAdd` to `NonConstAdd`\n+error[E0277]: cannot add `NonConstAdd` to `NonConstAdd` in const contexts\n   --> $DIR/assoc-type.rs:18:16\n    |\n LL |     type Bar = NonConstAdd;\n    |                ^^^^^^^^^^^ no implementation for `NonConstAdd + NonConstAdd`\n    |\n-   = help: the trait `Add` is not implemented for `NonConstAdd`\n+   = help: the trait `~const Add` is not implemented for `NonConstAdd`\n note: required by a bound in `Foo::Bar`\n   --> $DIR/assoc-type.rs:14:15\n    |\n LL |     type Bar: ~const std::ops::Add;\n    |               ^^^^^^^^^^^^^^^^^^^^ required by this bound in `Foo::Bar`\n help: consider introducing a `where` bound, but there might be an alternative better way to express this requirement\n    |\n-LL | impl const Foo for NonConstAdd where NonConstAdd: Add {\n-   |                                ++++++++++++++++++++++\n+LL | impl const Foo for NonConstAdd where NonConstAdd: ~const Add {\n+   |                                +++++++++++++++++++++++++++++\n \n error: aborting due to previous error\n "}, {"sha": "13cffaba91a1ddd191235bdd30143778818f63b9", "filename": "src/test/ui/rfc-2632-const-trait-impl/call-generic-method-nonconst.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e2b2bfe10ce5d36e9568173cb6cb9c7456b03a61/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fcall-generic-method-nonconst.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e2b2bfe10ce5d36e9568173cb6cb9c7456b03a61/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fcall-generic-method-nonconst.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fcall-generic-method-nonconst.stderr?ref=e2b2bfe10ce5d36e9568173cb6cb9c7456b03a61", "patch": "@@ -1,12 +1,12 @@\n-error[E0277]: can't compare `S` with `S`\n+error[E0277]: can't compare `S` with `S` in const contexts\n   --> $DIR/call-generic-method-nonconst.rs:19:34\n    |\n LL | pub const EQ: bool = equals_self(&S);\n    |                      ----------- ^^ no implementation for `S == S`\n    |                      |\n    |                      required by a bound introduced by this call\n    |\n-   = help: the trait `PartialEq` is not implemented for `S`\n+   = help: the trait `~const PartialEq` is not implemented for `S`\n note: required by a bound in `equals_self`\n   --> $DIR/call-generic-method-nonconst.rs:12:25\n    |"}, {"sha": "df776908a03655a3de0bdf68b8d69931b9dc77a7", "filename": "src/test/ui/rfc-2632-const-trait-impl/const-drop-fail.precise.stderr", "status": "modified", "additions": 19, "deletions": 7, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e2b2bfe10ce5d36e9568173cb6cb9c7456b03a61/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-drop-fail.precise.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e2b2bfe10ce5d36e9568173cb6cb9c7456b03a61/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-drop-fail.precise.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-drop-fail.precise.stderr?ref=e2b2bfe10ce5d36e9568173cb6cb9c7456b03a61", "patch": "@@ -1,26 +1,32 @@\n-error[E0277]: the trait bound `NonTrivialDrop: Drop` is not satisfied\n+error[E0277]: the trait bound `NonTrivialDrop: ~const Drop` is not satisfied\n   --> $DIR/const-drop-fail.rs:44:5\n    |\n LL |         const _: () = check($exp);\n    |                       ----- required by a bound introduced by this call\n ...\n LL |     NonTrivialDrop,\n-   |     ^^^^^^^^^^^^^^ the trait `Drop` is not implemented for `NonTrivialDrop`\n+   |     ^^^^^^^^^^^^^^ expected an implementor of trait `~const Drop`\n    |\n note: required by a bound in `check`\n   --> $DIR/const-drop-fail.rs:35:19\n    |\n LL | const fn check<T: ~const Drop>(_: T) {}\n    |                   ^^^^^^^^^^^ required by this bound in `check`\n+help: consider borrowing here\n+   |\n+LL |     &NonTrivialDrop,\n+   |     +\n+LL |     &mut NonTrivialDrop,\n+   |     ++++\n \n-error[E0277]: the trait bound `NonTrivialDrop: Drop` is not satisfied in `ConstImplWithDropGlue`\n+error[E0277]: the trait bound `NonTrivialDrop: ~const Drop` is not satisfied in `ConstImplWithDropGlue`\n   --> $DIR/const-drop-fail.rs:46:5\n    |\n LL |         const _: () = check($exp);\n    |                       ----- required by a bound introduced by this call\n ...\n LL |     ConstImplWithDropGlue(NonTrivialDrop),\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ within `ConstImplWithDropGlue`, the trait `Drop` is not implemented for `NonTrivialDrop`\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ within `ConstImplWithDropGlue`, the trait `~const Drop` is not implemented for `NonTrivialDrop`\n    |\n note: required because it appears within the type `ConstImplWithDropGlue`\n   --> $DIR/const-drop-fail.rs:17:8\n@@ -33,16 +39,16 @@ note: required by a bound in `check`\n LL | const fn check<T: ~const Drop>(_: T) {}\n    |                   ^^^^^^^^^^^ required by this bound in `check`\n \n-error[E0277]: the trait bound `NonTrivialDrop: A` is not satisfied\n+error[E0277]: the trait bound `ConstDropImplWithBounds<NonTrivialDrop>: ~const Drop` is not satisfied\n   --> $DIR/const-drop-fail.rs:48:5\n    |\n LL |         const _: () = check($exp);\n    |                       ----- required by a bound introduced by this call\n ...\n LL |     ConstDropImplWithBounds::<NonTrivialDrop>(PhantomData),\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `A` is not implemented for `NonTrivialDrop`\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected an implementor of trait `~const Drop`\n    |\n-note: required because of the requirements on the impl of `Drop` for `ConstDropImplWithBounds<NonTrivialDrop>`\n+note: required because of the requirements on the impl of `~const Drop` for `ConstDropImplWithBounds<NonTrivialDrop>`\n   --> $DIR/const-drop-fail.rs:29:25\n    |\n LL | impl<T: ~const A> const Drop for ConstDropImplWithBounds<T> {\n@@ -52,6 +58,12 @@ note: required by a bound in `check`\n    |\n LL | const fn check<T: ~const Drop>(_: T) {}\n    |                   ^^^^^^^^^^^ required by this bound in `check`\n+help: consider borrowing here\n+   |\n+LL |     &ConstDropImplWithBounds::<NonTrivialDrop>(PhantomData),\n+   |     +\n+LL |     &mut ConstDropImplWithBounds::<NonTrivialDrop>(PhantomData),\n+   |     ++++\n \n error: aborting due to 3 previous errors\n "}, {"sha": "df776908a03655a3de0bdf68b8d69931b9dc77a7", "filename": "src/test/ui/rfc-2632-const-trait-impl/const-drop-fail.stock.stderr", "status": "modified", "additions": 19, "deletions": 7, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e2b2bfe10ce5d36e9568173cb6cb9c7456b03a61/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-drop-fail.stock.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e2b2bfe10ce5d36e9568173cb6cb9c7456b03a61/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-drop-fail.stock.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-drop-fail.stock.stderr?ref=e2b2bfe10ce5d36e9568173cb6cb9c7456b03a61", "patch": "@@ -1,26 +1,32 @@\n-error[E0277]: the trait bound `NonTrivialDrop: Drop` is not satisfied\n+error[E0277]: the trait bound `NonTrivialDrop: ~const Drop` is not satisfied\n   --> $DIR/const-drop-fail.rs:44:5\n    |\n LL |         const _: () = check($exp);\n    |                       ----- required by a bound introduced by this call\n ...\n LL |     NonTrivialDrop,\n-   |     ^^^^^^^^^^^^^^ the trait `Drop` is not implemented for `NonTrivialDrop`\n+   |     ^^^^^^^^^^^^^^ expected an implementor of trait `~const Drop`\n    |\n note: required by a bound in `check`\n   --> $DIR/const-drop-fail.rs:35:19\n    |\n LL | const fn check<T: ~const Drop>(_: T) {}\n    |                   ^^^^^^^^^^^ required by this bound in `check`\n+help: consider borrowing here\n+   |\n+LL |     &NonTrivialDrop,\n+   |     +\n+LL |     &mut NonTrivialDrop,\n+   |     ++++\n \n-error[E0277]: the trait bound `NonTrivialDrop: Drop` is not satisfied in `ConstImplWithDropGlue`\n+error[E0277]: the trait bound `NonTrivialDrop: ~const Drop` is not satisfied in `ConstImplWithDropGlue`\n   --> $DIR/const-drop-fail.rs:46:5\n    |\n LL |         const _: () = check($exp);\n    |                       ----- required by a bound introduced by this call\n ...\n LL |     ConstImplWithDropGlue(NonTrivialDrop),\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ within `ConstImplWithDropGlue`, the trait `Drop` is not implemented for `NonTrivialDrop`\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ within `ConstImplWithDropGlue`, the trait `~const Drop` is not implemented for `NonTrivialDrop`\n    |\n note: required because it appears within the type `ConstImplWithDropGlue`\n   --> $DIR/const-drop-fail.rs:17:8\n@@ -33,16 +39,16 @@ note: required by a bound in `check`\n LL | const fn check<T: ~const Drop>(_: T) {}\n    |                   ^^^^^^^^^^^ required by this bound in `check`\n \n-error[E0277]: the trait bound `NonTrivialDrop: A` is not satisfied\n+error[E0277]: the trait bound `ConstDropImplWithBounds<NonTrivialDrop>: ~const Drop` is not satisfied\n   --> $DIR/const-drop-fail.rs:48:5\n    |\n LL |         const _: () = check($exp);\n    |                       ----- required by a bound introduced by this call\n ...\n LL |     ConstDropImplWithBounds::<NonTrivialDrop>(PhantomData),\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `A` is not implemented for `NonTrivialDrop`\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected an implementor of trait `~const Drop`\n    |\n-note: required because of the requirements on the impl of `Drop` for `ConstDropImplWithBounds<NonTrivialDrop>`\n+note: required because of the requirements on the impl of `~const Drop` for `ConstDropImplWithBounds<NonTrivialDrop>`\n   --> $DIR/const-drop-fail.rs:29:25\n    |\n LL | impl<T: ~const A> const Drop for ConstDropImplWithBounds<T> {\n@@ -52,6 +58,12 @@ note: required by a bound in `check`\n    |\n LL | const fn check<T: ~const Drop>(_: T) {}\n    |                   ^^^^^^^^^^^ required by this bound in `check`\n+help: consider borrowing here\n+   |\n+LL |     &ConstDropImplWithBounds::<NonTrivialDrop>(PhantomData),\n+   |     +\n+LL |     &mut ConstDropImplWithBounds::<NonTrivialDrop>(PhantomData),\n+   |     ++++\n \n error: aborting due to 3 previous errors\n "}, {"sha": "76ea17159ac79d57e5c279b98264decb59afaf06", "filename": "src/test/ui/rfc-2632-const-trait-impl/default-method-body-is-const-body-checking.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e2b2bfe10ce5d36e9568173cb6cb9c7456b03a61/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fdefault-method-body-is-const-body-checking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2b2bfe10ce5d36e9568173cb6cb9c7456b03a61/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fdefault-method-body-is-const-body-checking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fdefault-method-body-is-const-body-checking.rs?ref=e2b2bfe10ce5d36e9568173cb6cb9c7456b03a61", "patch": "@@ -10,7 +10,7 @@ pub trait Foo {\n     #[default_method_body_is_const]\n     fn foo() {\n         foo::<()>();\n-        //~^ ERROR the trait bound `(): Tr` is not satisfied\n+        //~^ ERROR the trait bound `(): ~const Tr` is not satisfied\n     }\n }\n "}, {"sha": "05a74757b94f119dd90efdbbbc51f98c5983c372", "filename": "src/test/ui/rfc-2632-const-trait-impl/default-method-body-is-const-body-checking.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e2b2bfe10ce5d36e9568173cb6cb9c7456b03a61/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fdefault-method-body-is-const-body-checking.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e2b2bfe10ce5d36e9568173cb6cb9c7456b03a61/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fdefault-method-body-is-const-body-checking.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fdefault-method-body-is-const-body-checking.stderr?ref=e2b2bfe10ce5d36e9568173cb6cb9c7456b03a61", "patch": "@@ -1,8 +1,8 @@\n-error[E0277]: the trait bound `(): Tr` is not satisfied\n+error[E0277]: the trait bound `(): ~const Tr` is not satisfied\n   --> $DIR/default-method-body-is-const-body-checking.rs:12:15\n    |\n LL |         foo::<()>();\n-   |               ^^ the trait `Tr` is not implemented for `()`\n+   |               ^^ the trait `~const Tr` is not implemented for `()`\n    |\n note: required by a bound in `foo`\n   --> $DIR/default-method-body-is-const-body-checking.rs:7:28\n@@ -11,8 +11,8 @@ LL | const fn foo<T>() where T: ~const Tr {}\n    |                            ^^^^^^^^^ required by this bound in `foo`\n help: consider introducing a `where` bound, but there might be an alternative better way to express this requirement\n    |\n-LL | pub trait Foo where (): Tr {\n-   |               ++++++++++++\n+LL | pub trait Foo where (): ~const Tr {\n+   |               +++++++++++++++++++\n \n error: aborting due to previous error\n "}, {"sha": "903cd924ca55b466d3cf8d7f338fdde95993ef0f", "filename": "src/test/ui/rfc-2632-const-trait-impl/trait-where-clause.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e2b2bfe10ce5d36e9568173cb6cb9c7456b03a61/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Ftrait-where-clause.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e2b2bfe10ce5d36e9568173cb6cb9c7456b03a61/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Ftrait-where-clause.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Ftrait-where-clause.stderr?ref=e2b2bfe10ce5d36e9568173cb6cb9c7456b03a61", "patch": "@@ -1,8 +1,8 @@\n-error[E0277]: the trait bound `T: Bar` is not satisfied\n+error[E0277]: the trait bound `T: ~const Bar` is not satisfied\n   --> $DIR/trait-where-clause.rs:14:5\n    |\n LL |     T::b();\n-   |     ^^^^ the trait `Bar` is not implemented for `T`\n+   |     ^^^^ the trait `~const Bar` is not implemented for `T`\n    |\n note: required by a bound in `Foo::b`\n   --> $DIR/trait-where-clause.rs:8:24\n@@ -11,14 +11,14 @@ LL |     fn b() where Self: ~const Bar;\n    |                        ^^^^^^^^^^ required by this bound in `Foo::b`\n help: consider further restricting this bound\n    |\n-LL | const fn test1<T: ~const Foo + Bar + Bar>() {\n-   |                                    +++++\n+LL | const fn test1<T: ~const Foo + Bar + ~const Bar>() {\n+   |                                    ++++++++++++\n \n-error[E0277]: the trait bound `T: Bar` is not satisfied\n+error[E0277]: the trait bound `T: ~const Bar` is not satisfied\n   --> $DIR/trait-where-clause.rs:16:5\n    |\n LL |     T::c::<T>();\n-   |     ^^^^^^^^^ the trait `Bar` is not implemented for `T`\n+   |     ^^^^^^^^^ the trait `~const Bar` is not implemented for `T`\n    |\n note: required by a bound in `Foo::c`\n   --> $DIR/trait-where-clause.rs:9:13\n@@ -27,8 +27,8 @@ LL |     fn c<T: ~const Bar>();\n    |             ^^^^^^^^^^ required by this bound in `Foo::c`\n help: consider further restricting this bound\n    |\n-LL | const fn test1<T: ~const Foo + Bar + Bar>() {\n-   |                                    +++++\n+LL | const fn test1<T: ~const Foo + Bar + ~const Bar>() {\n+   |                                    ++++++++++++\n \n error[E0277]: the trait bound `T: Bar` is not satisfied\n   --> $DIR/trait-where-clause.rs:28:5"}]}