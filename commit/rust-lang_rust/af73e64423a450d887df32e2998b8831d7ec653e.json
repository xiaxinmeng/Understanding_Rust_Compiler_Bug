{"sha": "af73e64423a450d887df32e2998b8831d7ec653e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFmNzNlNjQ0MjNhNDUwZDg4N2RmMzJlMjk5OGI4ODMxZDdlYzY1M2U=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-01-19T05:05:48Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-01-19T05:05:48Z"}, "message": "Auto merge of #56722 - Aaron1011:fix/blanket-eval-overflow, r=nikomatsakis\n\nFix stack overflow when finding blanket impls\n\nCurrently, SelectionContext tries to prevent stack overflow by keeping\ntrack of the current recursion depth. However, this depth tracking is\nonly used when performing normal section (which includes confirmation).\nNo such tracking is performed for evaluate_obligation_recursively, which\ncan allow a stack overflow to occur.\n\nTo fix this, this commit tracks the current predicate evaluation depth.\nThis is done separately from the existing obligation depth tracking:\nan obligation overflow can occur across multiple calls to 'select' (e.g.\nwhen fulfilling a trait), while a predicate evaluation overflow can only\nhappen as a result of a deep recursive call stack.\n\nFixes #56701\n\nI've re-used `tcx.sess.recursion_limit` when checking for predication evaluation overflows. This is such a weird corner case that I don't believe it's necessary to have a separate setting controlling the maximum depth.", "tree": {"sha": "551bdaadaf845322311ea630e7973fd933a21f1f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/551bdaadaf845322311ea630e7973fd933a21f1f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/af73e64423a450d887df32e2998b8831d7ec653e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/af73e64423a450d887df32e2998b8831d7ec653e", "html_url": "https://github.com/rust-lang/rust/commit/af73e64423a450d887df32e2998b8831d7ec653e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/af73e64423a450d887df32e2998b8831d7ec653e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "53b622a48a7945e223dbc5cfb30f7cbd38acc7c5", "url": "https://api.github.com/repos/rust-lang/rust/commits/53b622a48a7945e223dbc5cfb30f7cbd38acc7c5", "html_url": "https://github.com/rust-lang/rust/commit/53b622a48a7945e223dbc5cfb30f7cbd38acc7c5"}, {"sha": "9b68dcd32a1be5d219a6bcedc2c9fc63d6d463a4", "url": "https://api.github.com/repos/rust-lang/rust/commits/9b68dcd32a1be5d219a6bcedc2c9fc63d6d463a4", "html_url": "https://github.com/rust-lang/rust/commit/9b68dcd32a1be5d219a6bcedc2c9fc63d6d463a4"}], "stats": {"total": 155, "additions": 117, "deletions": 38}, "files": [{"sha": "05a6cce895d1f3fd759e4e425aec562836f84071", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 73, "deletions": 25, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/af73e64423a450d887df32e2998b8831d7ec653e/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af73e64423a450d887df32e2998b8831d7ec653e/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=af73e64423a450d887df32e2998b8831d7ec653e", "patch": "@@ -42,7 +42,7 @@ use rustc_data_structures::bit_set::GrowableBitSet;\n use rustc_data_structures::sync::Lock;\n use rustc_target::spec::abi::Abi;\n use std::cmp;\n-use std::fmt;\n+use std::fmt::{self, Display};\n use std::iter;\n use std::rc::Rc;\n use util::nodemap::{FxHashMap, FxHashSet};\n@@ -629,7 +629,8 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         obligation: &PredicateObligation<'tcx>,\n     ) -> Result<EvaluationResult, OverflowError> {\n         self.evaluation_probe(|this| {\n-            this.evaluate_predicate_recursively(TraitObligationStackList::empty(), obligation)\n+            this.evaluate_predicate_recursively(TraitObligationStackList::empty(),\n+                obligation.clone())\n         })\n     }\n \n@@ -655,12 +656,12 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         predicates: I,\n     ) -> Result<EvaluationResult, OverflowError>\n     where\n-        I: IntoIterator<Item = &'a PredicateObligation<'tcx>>,\n+        I: IntoIterator<Item = PredicateObligation<'tcx>>,\n         'tcx: 'a,\n     {\n         let mut result = EvaluatedToOk;\n         for obligation in predicates {\n-            let eval = self.evaluate_predicate_recursively(stack, obligation)?;\n+            let eval = self.evaluate_predicate_recursively(stack, obligation.clone())?;\n             debug!(\n                 \"evaluate_predicate_recursively({:?}) = {:?}\",\n                 obligation, eval\n@@ -679,9 +680,19 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     fn evaluate_predicate_recursively<'o>(\n         &mut self,\n         previous_stack: TraitObligationStackList<'o, 'tcx>,\n-        obligation: &PredicateObligation<'tcx>,\n+        obligation: PredicateObligation<'tcx>,\n     ) -> Result<EvaluationResult, OverflowError> {\n-        debug!(\"evaluate_predicate_recursively({:?})\", obligation);\n+        debug!(\"evaluate_predicate_recursively(previous_stack={:?}, obligation={:?})\",\n+            previous_stack.head(), obligation);\n+\n+        // Previous_stack stores a TraitObligatiom, while 'obligation' is\n+        // a PredicateObligation. These are distinct types, so we can't\n+        // use any Option combinator method that would force them to be\n+        // the same\n+        match previous_stack.head() {\n+            Some(h) => self.check_recursion_limit(&obligation, h.obligation)?,\n+            None => self.check_recursion_limit(&obligation, &obligation)?\n+        }\n \n         match obligation.predicate {\n             ty::Predicate::Trait(ref t) => {\n@@ -695,8 +706,9 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 match self.infcx\n                     .subtype_predicate(&obligation.cause, obligation.param_env, p)\n                 {\n-                    Some(Ok(InferOk { obligations, .. })) => {\n-                        self.evaluate_predicates_recursively(previous_stack, &obligations)\n+                    Some(Ok(InferOk { mut obligations, .. })) => {\n+                        self.add_depth(obligations.iter_mut(), obligation.recursion_depth);\n+                        self.evaluate_predicates_recursively(previous_stack,obligations.into_iter())\n                     }\n                     Some(Err(_)) => Ok(EvaluatedToErr),\n                     None => Ok(EvaluatedToAmbig),\n@@ -710,8 +722,9 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 ty,\n                 obligation.cause.span,\n             ) {\n-                Some(obligations) => {\n-                    self.evaluate_predicates_recursively(previous_stack, obligations.iter())\n+                Some(mut obligations) => {\n+                    self.add_depth(obligations.iter_mut(), obligation.recursion_depth);\n+                    self.evaluate_predicates_recursively(previous_stack, obligations.into_iter())\n                 }\n                 None => Ok(EvaluatedToAmbig),\n             },\n@@ -733,10 +746,11 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             ty::Predicate::Projection(ref data) => {\n                 let project_obligation = obligation.with(data.clone());\n                 match project::poly_project_and_unify_type(self, &project_obligation) {\n-                    Ok(Some(subobligations)) => {\n+                    Ok(Some(mut subobligations)) => {\n+                        self.add_depth(subobligations.iter_mut(), obligation.recursion_depth);\n                         let result = self.evaluate_predicates_recursively(\n                             previous_stack,\n-                            subobligations.iter(),\n+                            subobligations.into_iter(),\n                         );\n                         if let Some(key) =\n                             ProjectionCacheKey::from_poly_projection_predicate(self, data)\n@@ -1005,7 +1019,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             match this.confirm_candidate(stack.obligation, candidate) {\n                 Ok(selection) => this.evaluate_predicates_recursively(\n                     stack.list(),\n-                    selection.nested_obligations().iter(),\n+                    selection.nested_obligations().into_iter()\n                 ),\n                 Err(..) => Ok(EvaluatedToErr),\n             }\n@@ -1080,6 +1094,45 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             .insert(trait_ref, WithDepNode::new(dep_node, result));\n     }\n \n+    // For various reasons, it's possible for a subobligation\n+    // to have a *lower* recursion_depth than the obligation used to create it.\n+    // Projection sub-obligations may be returned from the projection cache,\n+    // which results in obligations with an 'old' recursion_depth.\n+    // Additionally, methods like ty::wf::obligations and\n+    // InferCtxt.subtype_predicate produce subobligations without\n+    // taking in a 'parent' depth, causing the generated subobligations\n+    // to have a recursion_depth of 0\n+    //\n+    // To ensure that obligation_depth never decreasees, we force all subobligations\n+    // to have at least the depth of the original obligation.\n+    fn add_depth<T: 'cx, I: Iterator<Item = &'cx mut Obligation<'tcx, T>>>(&self, it: I,\n+                                                                           min_depth: usize) {\n+        it.for_each(|o| o.recursion_depth = cmp::max(min_depth, o.recursion_depth) + 1);\n+    }\n+\n+    // Check that the recursion limit has not been exceeded.\n+    //\n+    // The weird return type of this function allows it to be used with the 'try' (?)\n+    // operator within certain functions\n+    fn check_recursion_limit<T: Display + TypeFoldable<'tcx>, V: Display + TypeFoldable<'tcx>>(\n+        &self,\n+        obligation: &Obligation<'tcx, T>,\n+        error_obligation: &Obligation<'tcx, V>\n+    ) -> Result<(), OverflowError>  {\n+        let recursion_limit = *self.infcx.tcx.sess.recursion_limit.get();\n+        if obligation.recursion_depth >= recursion_limit {\n+            match self.query_mode {\n+                TraitQueryMode::Standard => {\n+                    self.infcx().report_overflow_error(error_obligation, true);\n+                }\n+                TraitQueryMode::Canonical => {\n+                    return Err(OverflowError);\n+                }\n+            }\n+        }\n+        Ok(())\n+    }\n+\n     ///////////////////////////////////////////////////////////////////////////\n     // CANDIDATE ASSEMBLY\n     //\n@@ -1096,17 +1149,8 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     ) -> SelectionResult<'tcx, SelectionCandidate<'tcx>> {\n         // Watch out for overflow. This intentionally bypasses (and does\n         // not update) the cache.\n-        let recursion_limit = *self.infcx.tcx.sess.recursion_limit.get();\n-        if stack.obligation.recursion_depth >= recursion_limit {\n-            match self.query_mode {\n-                TraitQueryMode::Standard => {\n-                    self.infcx().report_overflow_error(&stack.obligation, true);\n-                }\n-                TraitQueryMode::Canonical => {\n-                    return Err(Overflow);\n-                }\n-            }\n-        }\n+        self.check_recursion_limit(&stack.obligation, &stack.obligation)?;\n+\n \n         // Check the cache. Note that we freshen the trait-ref\n         // separately rather than using `stack.fresh_trait_ref` --\n@@ -1767,7 +1811,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         self.evaluation_probe(|this| {\n             match this.match_where_clause_trait_ref(stack.obligation, where_clause_trait_ref) {\n                 Ok(obligations) => {\n-                    this.evaluate_predicates_recursively(stack.list(), obligations.iter())\n+                    this.evaluate_predicates_recursively(stack.list(), obligations.into_iter())\n                 }\n                 Err(()) => Ok(EvaluatedToErr),\n             }\n@@ -3802,6 +3846,10 @@ impl<'o, 'tcx> TraitObligationStackList<'o, 'tcx> {\n     fn with(r: &'o TraitObligationStack<'o, 'tcx>) -> TraitObligationStackList<'o, 'tcx> {\n         TraitObligationStackList { head: Some(r) }\n     }\n+\n+    fn head(&self) -> Option<&'o TraitObligationStack<'o, 'tcx>> {\n+        self.head\n+    }\n }\n \n impl<'o, 'tcx> Iterator for TraitObligationStackList<'o, 'tcx> {"}, {"sha": "c0a8dd87ee2d5460109d8d2b627df503d3bc3a9f", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/af73e64423a450d887df32e2998b8831d7ec653e/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af73e64423a450d887df32e2998b8831d7ec653e/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=af73e64423a450d887df32e2998b8831d7ec653e", "patch": "@@ -516,7 +516,7 @@ recursion limit (which can be set via the `recursion_limit` attribute).\n For a somewhat artificial example:\n \n ```compile_fail,E0055\n-#![recursion_limit=\"2\"]\n+#![recursion_limit=\"5\"]\n \n struct Foo;\n \n@@ -526,9 +526,9 @@ impl Foo {\n \n fn main() {\n     let foo = Foo;\n-    let ref_foo = &&Foo;\n+    let ref_foo = &&&&&Foo;\n \n-    // error, reached the recursion limit while auto-dereferencing `&&Foo`\n+    // error, reached the recursion limit while auto-dereferencing `&&&&&Foo`\n     ref_foo.foo();\n }\n ```"}, {"sha": "7ce7e29e872356b25815d5e9fb8b32141024aa5e", "filename": "src/test/run-pass/weird-exprs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af73e64423a450d887df32e2998b8831d7ec653e/src%2Ftest%2Frun-pass%2Fweird-exprs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af73e64423a450d887df32e2998b8831d7ec653e/src%2Ftest%2Frun-pass%2Fweird-exprs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fweird-exprs.rs?ref=af73e64423a450d887df32e2998b8831d7ec653e", "patch": "@@ -4,7 +4,7 @@\n #![allow(unused_parens)]\n // compile-flags: -Z borrowck=compare\n \n-#![recursion_limit = \"128\"]\n+#![recursion_limit = \"256\"]\n \n use std::cell::Cell;\n use std::mem::swap;"}, {"sha": "6fb30a4ff4c30144ab689511c2c7a72f6fa603dc", "filename": "src/test/rustdoc/issue-56701.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/af73e64423a450d887df32e2998b8831d7ec653e/src%2Ftest%2Frustdoc%2Fissue-56701.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af73e64423a450d887df32e2998b8831d7ec653e/src%2Ftest%2Frustdoc%2Fissue-56701.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-56701.rs?ref=af73e64423a450d887df32e2998b8831d7ec653e", "patch": "@@ -0,0 +1,34 @@\n+// This shouldn't cause a stack overflow when rustdoc is run\n+\n+use std::ops::Deref;\n+use std::ops::DerefMut;\n+\n+pub trait SimpleTrait {\n+    type SimpleT;\n+}\n+\n+impl<Inner: SimpleTrait, Outer: Deref<Target = Inner>> SimpleTrait for Outer {\n+    type SimpleT = Inner::SimpleT;\n+}\n+\n+pub trait AnotherTrait {\n+    type AnotherT;\n+}\n+\n+impl<T, Simple: SimpleTrait<SimpleT = Vec<T>>> AnotherTrait for Simple {\n+    type AnotherT = T;\n+}\n+\n+pub struct Unrelated<Inner, UnrelatedT: DerefMut<Target = Vec<Inner>>>(UnrelatedT);\n+\n+impl<Inner, UnrelatedT: DerefMut<Target = Vec<Inner>>> Deref for Unrelated<Inner, UnrelatedT> {\n+    type Target = Vec<Inner>;\n+\n+    fn deref(&self) -> &Self::Target {\n+        &self.0\n+    }\n+}\n+\n+\n+pub fn main() { }\n+"}, {"sha": "0738c3f65b95f90c7c194768d958d694c0240a6e", "filename": "src/test/ui/did_you_mean/recursion_limit.stderr", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/af73e64423a450d887df32e2998b8831d7ec653e/src%2Ftest%2Fui%2Fdid_you_mean%2Frecursion_limit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/af73e64423a450d887df32e2998b8831d7ec653e/src%2Ftest%2Fui%2Fdid_you_mean%2Frecursion_limit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Frecursion_limit.stderr?ref=af73e64423a450d887df32e2998b8831d7ec653e", "patch": "@@ -1,11 +1,10 @@\n-error[E0275]: overflow evaluating the requirement `K: std::marker::Send`\n+error[E0275]: overflow evaluating the requirement `J: std::marker::Send`\n   --> $DIR/recursion_limit.rs:34:5\n    |\n LL |     is_send::<A>(); //~ ERROR overflow evaluating the requirement\n    |     ^^^^^^^^^^^^\n    |\n    = help: consider adding a `#![recursion_limit=\"20\"]` attribute to your crate\n-   = note: required because it appears within the type `J`\n    = note: required because it appears within the type `I`\n    = note: required because it appears within the type `H`\n    = note: required because it appears within the type `G`"}, {"sha": "b525575d98d46a7997f57da6ceb862a92c3d199f", "filename": "src/test/ui/error-codes/E0055.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/af73e64423a450d887df32e2998b8831d7ec653e/src%2Ftest%2Fui%2Ferror-codes%2FE0055.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af73e64423a450d887df32e2998b8831d7ec653e/src%2Ftest%2Fui%2Ferror-codes%2FE0055.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0055.rs?ref=af73e64423a450d887df32e2998b8831d7ec653e", "patch": "@@ -1,4 +1,4 @@\n-#![recursion_limit=\"2\"]\n+#![recursion_limit=\"5\"]\n struct Foo;\n \n impl Foo {\n@@ -7,7 +7,7 @@ impl Foo {\n \n fn main() {\n     let foo = Foo;\n-    let ref_foo = &&Foo;\n+    let ref_foo = &&&&&Foo;\n     ref_foo.foo();\n     //~^ ERROR E0055\n }"}, {"sha": "d06566ffbe9a9c20195f8a11def3dfc827756a4a", "filename": "src/test/ui/error-codes/E0055.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af73e64423a450d887df32e2998b8831d7ec653e/src%2Ftest%2Fui%2Ferror-codes%2FE0055.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/af73e64423a450d887df32e2998b8831d7ec653e/src%2Ftest%2Fui%2Ferror-codes%2FE0055.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0055.stderr?ref=af73e64423a450d887df32e2998b8831d7ec653e", "patch": "@@ -4,7 +4,7 @@ error[E0055]: reached the recursion limit while auto-dereferencing `Foo`\n LL |     ref_foo.foo();\n    |             ^^^ deref recursion limit reached\n    |\n-   = help: consider adding a `#![recursion_limit=\"4\"]` attribute to your crate\n+   = help: consider adding a `#![recursion_limit=\"10\"]` attribute to your crate\n \n error: aborting due to previous error\n "}, {"sha": "f2b0f392bc8bc45caa37e5e2f9ff54d16ca93697", "filename": "src/test/ui/error-codes/E0275.stderr", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/af73e64423a450d887df32e2998b8831d7ec653e/src%2Ftest%2Fui%2Ferror-codes%2FE0275.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/af73e64423a450d887df32e2998b8831d7ec653e/src%2Ftest%2Fui%2Ferror-codes%2FE0275.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0275.stderr?ref=af73e64423a450d887df32e2998b8831d7ec653e", "patch": "@@ -1,11 +1,10 @@\n-error[E0275]: overflow evaluating the requirement `Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<T>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>: std::marker::Sized`\n+error[E0275]: overflow evaluating the requirement `Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<T>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>: Foo`\n   --> $DIR/E0275.rs:5:1\n    |\n LL | impl<T> Foo for T where Bar<T>: Foo {} //~ ERROR E0275\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: consider adding a `#![recursion_limit=\"128\"]` attribute to your crate\n-   = note: required because of the requirements on the impl of `Foo` for `Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<T>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>`\n    = note: required because of the requirements on the impl of `Foo` for `Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<T>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>`\n    = note: required because of the requirements on the impl of `Foo` for `Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<T>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>`\n    = note: required because of the requirements on the impl of `Foo` for `Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<Bar<T>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>`"}, {"sha": "1c353fec8aabf4b8563cad45bb449d21fa038a24", "filename": "src/test/ui/issues/issue-20413.stderr", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/af73e64423a450d887df32e2998b8831d7ec653e/src%2Ftest%2Fui%2Fissues%2Fissue-20413.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/af73e64423a450d887df32e2998b8831d7ec653e/src%2Ftest%2Fui%2Fissues%2Fissue-20413.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-20413.stderr?ref=af73e64423a450d887df32e2998b8831d7ec653e", "patch": "@@ -6,7 +6,7 @@ LL | struct NoData<T>;\n    |\n    = help: consider removing `T` or using a marker such as `std::marker::PhantomData`\n \n-error[E0275]: overflow evaluating the requirement `NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<T>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>: std::marker::Sized`\n+error[E0275]: overflow evaluating the requirement `NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<T>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>: Foo`\n   --> $DIR/issue-20413.rs:8:1\n    |\n LL | / impl<T> Foo for T where NoData<T>: Foo {\n@@ -18,7 +18,6 @@ LL | | }\n    | |_^\n    |\n    = help: consider adding a `#![recursion_limit=\"128\"]` attribute to your crate\n-   = note: required because of the requirements on the impl of `Foo` for `NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<T>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>`\n    = note: required because of the requirements on the impl of `Foo` for `NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<T>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>`\n    = note: required because of the requirements on the impl of `Foo` for `NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<T>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>`\n    = note: required because of the requirements on the impl of `Foo` for `NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<NoData<T>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>`"}]}