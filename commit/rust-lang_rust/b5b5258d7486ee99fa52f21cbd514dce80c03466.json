{"sha": "b5b5258d7486ee99fa52f21cbd514dce80c03466", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI1YjUyNThkNzQ4NmVlOTlmYTUyZjIxY2JkNTE0ZGNlODBjMDM0NjY=", "commit": {"author": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2019-12-13T23:04:27Z"}, "committer": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2019-12-26T21:50:14Z"}, "message": "Retire `to_ptr` which should already have no users but still kept getting new ones", "tree": {"sha": "6cf5550fc6ae82b182a63a0d77fd4de9c055d57f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6cf5550fc6ae82b182a63a0d77fd4de9c055d57f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b5b5258d7486ee99fa52f21cbd514dce80c03466", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b5b5258d7486ee99fa52f21cbd514dce80c03466", "html_url": "https://github.com/rust-lang/rust/commit/b5b5258d7486ee99fa52f21cbd514dce80c03466", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b5b5258d7486ee99fa52f21cbd514dce80c03466/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1e40681f50bf820844480b375ab0379aef4ec429", "url": "https://api.github.com/repos/rust-lang/rust/commits/1e40681f50bf820844480b375ab0379aef4ec429", "html_url": "https://github.com/rust-lang/rust/commit/1e40681f50bf820844480b375ab0379aef4ec429"}], "stats": {"total": 38, "additions": 19, "deletions": 19}, "files": [{"sha": "93f167cdb9e54cf9b14e830ea41a14818c81447a", "filename": "src/librustc/mir/interpret/value.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b5b5258d7486ee99fa52f21cbd514dce80c03466/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5b5258d7486ee99fa52f21cbd514dce80c03466/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs?ref=b5b5258d7486ee99fa52f21cbd514dce80c03466", "patch": "@@ -367,8 +367,9 @@ impl<'tcx, Tag> Scalar<Tag> {\n     }\n \n     /// Do not call this method!  Use either `assert_ptr` or `force_ptr`.\n+    /// This method is intentionally private, do not make it public.\n     #[inline]\n-    pub fn to_ptr(self) -> InterpResult<'tcx, Pointer<Tag>> {\n+    fn to_ptr(self) -> InterpResult<'tcx, Pointer<Tag>> {\n         match self {\n             Scalar::Raw { data: 0, .. } => throw_unsup!(InvalidNullPointerUsage),\n             Scalar::Raw { .. } => throw_unsup!(ReadBytesAsPointer),\n@@ -544,12 +545,6 @@ impl<'tcx, Tag> ScalarMaybeUndef<Tag> {\n         }\n     }\n \n-    /// Do not call this method!  Use either `assert_ptr` or `force_ptr`.\n-    #[inline(always)]\n-    pub fn to_ptr(self) -> InterpResult<'tcx, Pointer<Tag>> {\n-        self.not_undef()?.to_ptr()\n-    }\n-\n     /// Do not call this method!  Use either `assert_bits` or `force_bits`.\n     #[inline(always)]\n     pub fn to_bits(self, target_size: Size) -> InterpResult<'tcx, u128> {"}, {"sha": "120f05ba7d974f8a3ad1277198614d01d78da89f", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b5b5258d7486ee99fa52f21cbd514dce80c03466/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5b5258d7486ee99fa52f21cbd514dce80c03466/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=b5b5258d7486ee99fa52f21cbd514dce80c03466", "patch": "@@ -537,8 +537,8 @@ pub fn super_relate_consts<R: TypeRelation<'tcx>>(\n                         Ok(ConstValue::Scalar(a_val))\n                     } else if let ty::FnPtr(_) = a.ty.kind {\n                         let alloc_map = tcx.alloc_map.lock();\n-                        let a_instance = alloc_map.unwrap_fn(a_val.to_ptr().unwrap().alloc_id);\n-                        let b_instance = alloc_map.unwrap_fn(b_val.to_ptr().unwrap().alloc_id);\n+                        let a_instance = alloc_map.unwrap_fn(a_val.assert_ptr().alloc_id);\n+                        let b_instance = alloc_map.unwrap_fn(b_val.assert_ptr().alloc_id);\n                         if a_instance == b_instance {\n                             Ok(ConstValue::Scalar(a_val))\n                         } else {"}, {"sha": "745b6aabfa6bbd3e474112dcbc1f1b8c9601a457", "filename": "src/librustc_mir/const_eval/eval_queries.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b5b5258d7486ee99fa52f21cbd514dce80c03466/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5b5258d7486ee99fa52f21cbd514dce80c03466/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs?ref=b5b5258d7486ee99fa52f21cbd514dce80c03466", "patch": "@@ -119,7 +119,7 @@ pub(super) fn op_to_const<'tcx>(\n     };\n     let val = match immediate {\n         Ok(mplace) => {\n-            let ptr = mplace.ptr.to_ptr().unwrap();\n+            let ptr = mplace.ptr.assert_ptr();\n             let alloc = ecx.tcx.alloc_map.lock().unwrap_memory(ptr.alloc_id);\n             ConstValue::ByRef { alloc, offset: ptr.offset }\n         }\n@@ -133,7 +133,7 @@ pub(super) fn op_to_const<'tcx>(\n                 // comes from a constant so it can happen have `Undef`, because the indirect\n                 // memory that was read had undefined bytes.\n                 let mplace = op.assert_mem_place();\n-                let ptr = mplace.ptr.to_ptr().unwrap();\n+                let ptr = mplace.ptr.assert_ptr();\n                 let alloc = ecx.tcx.alloc_map.lock().unwrap_memory(ptr.alloc_id);\n                 ConstValue::ByRef { alloc, offset: ptr.offset }\n             }\n@@ -176,7 +176,7 @@ fn validate_and_turn_into_const<'tcx>(\n         // Statics/promoteds are always `ByRef`, for the rest `op_to_const` decides\n         // whether they become immediates.\n         if is_static || cid.promoted.is_some() {\n-            let ptr = mplace.ptr.to_ptr()?;\n+            let ptr = mplace.ptr.assert_ptr();\n             Ok(tcx.mk_const(ty::Const {\n                 val: ty::ConstKind::Value(ConstValue::ByRef {\n                     alloc: ecx.tcx.alloc_map.lock().unwrap_memory(ptr.alloc_id),"}, {"sha": "e8576b198dc24c9e8a027285f9cefd521adbc779", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b5b5258d7486ee99fa52f21cbd514dce80c03466/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5b5258d7486ee99fa52f21cbd514dce80c03466/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=b5b5258d7486ee99fa52f21cbd514dce80c03466", "patch": "@@ -743,7 +743,9 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // FIXME: should we tell the user that there was a local which was never written to?\n         if let LocalValue::Live(Operand::Indirect(MemPlace { ptr, .. })) = local {\n             trace!(\"deallocating local\");\n-            let ptr = ptr.to_ptr()?;\n+            // All locals have a backing allocation, even if the allocation is empty\n+            // due to the local having ZST type.\n+            let ptr = ptr.assert_ptr();\n             if log_enabled!(::log::Level::Trace) {\n                 self.memory.dump_alloc(ptr.alloc_id);\n             }"}, {"sha": "aaeff02fc052a1481237a7b1c90451b221e779b0", "filename": "src/librustc_mir/interpret/intern.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b5b5258d7486ee99fa52f21cbd514dce80c03466/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5b5258d7486ee99fa52f21cbd514dce80c03466/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintern.rs?ref=b5b5258d7486ee99fa52f21cbd514dce80c03466", "patch": "@@ -191,11 +191,12 @@ impl<'rt, 'mir, 'tcx, M: CompileTimeMachine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx\n             if let ty::Dynamic(..) =\n                 self.ecx.tcx.struct_tail_erasing_lifetimes(referenced_ty, self.ecx.param_env).kind\n             {\n-                if let Ok(vtable) = mplace.meta.unwrap().to_ptr() {\n-                    // explitly choose `Immutable` here, since vtables are immutable, even\n-                    // if the reference of the fat pointer is mutable\n-                    self.intern_shallow(vtable.alloc_id, Mutability::Not, None)?;\n-                }\n+                // Validation has already errored on an invalid vtable pointer so this `assert_ptr`\n+                // will never panic.\n+                let vtable = mplace.meta.unwrap().assert_ptr();\n+                // explitly choose `Immutable` here, since vtables are immutable, even\n+                // if the reference of the fat pointer is mutable\n+                self.intern_shallow(vtable.alloc_id, Mutability::Not, None)?;\n             }\n             // Check if we have encountered this pointer+layout combination before.\n             // Only recurse for allocation-backed pointers.\n@@ -280,7 +281,9 @@ pub fn intern_const_alloc_recursive<M: CompileTimeMachine<'mir, 'tcx>>(\n         ecx,\n         leftover_allocations,\n         base_intern_mode,\n-        ret.ptr.to_ptr()?.alloc_id,\n+        // The outermost allocation must exist, because we allocated it with\n+        // `Memory::allocate`.\n+        ret.ptr.assert_ptr().alloc_id,\n         base_mutability,\n         Some(ret.layout.ty),\n     )?;"}]}