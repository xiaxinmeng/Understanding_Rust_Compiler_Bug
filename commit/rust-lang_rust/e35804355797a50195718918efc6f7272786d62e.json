{"sha": "e35804355797a50195718918efc6f7272786d62e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUzNTgwNDM1NTc5N2E1MDE5NTcxODkxOGVmYzZmNzI3Mjc4NmQ2MmU=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-07-29T10:05:20Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-07-29T10:05:20Z"}, "message": "Merge #5566\n\n5566: Owned AST IR r=matklad a=matklad\n\n\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "bf6efbe6dc66cf81c0a08e06c0fff82cdc3ecf82", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bf6efbe6dc66cf81c0a08e06c0fff82cdc3ecf82"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e35804355797a50195718918efc6f7272786d62e", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfIUngCRBK7hj4Ov3rIwAAdHIIAISi7ONbPLj2BeGYoia1UIJC\n/bjERHwZchMibE1rso3/h0GMdR8TnBLHrWZYHueC7ISzMfUJP3xB1nsoN1cXl+q0\n762dr5Qs3ht0vfXe/o4ZLeTpPdFol4LP9HCNBmEyLqvz1tKIur5PDqzQkGEVrLpM\nn+BNpvILH1JK7dv4WQx2fYc5J4vYCkA/roDdDMgWFf29qALqAUCr3A+Vh6Yp+IPn\n+QWwoKAdJ4iZE/nhCmCmthx26XZNE17E8fdc8au4NJCVeYK0nfLa7GQ/ZDc8yiaI\nOMmsUoKl9ut8jNM1o3EK2tuaAIS+rjJseaq4176u5pCRMkUqBuPt1ey81PlfFWc=\n=0FAP\n-----END PGP SIGNATURE-----\n", "payload": "tree bf6efbe6dc66cf81c0a08e06c0fff82cdc3ecf82\nparent 9a9ddcc29793e5ba3bfece096e222736e2172555\nparent 627eddbc7e5eb13fc17c1c655ee1c3864c6dd4fe\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1596017120 +0000\ncommitter GitHub <noreply@github.com> 1596017120 +0000\n\nMerge #5566\n\n5566: Owned AST IR r=matklad a=matklad\n\n\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e35804355797a50195718918efc6f7272786d62e", "html_url": "https://github.com/rust-lang/rust/commit/e35804355797a50195718918efc6f7272786d62e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e35804355797a50195718918efc6f7272786d62e/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9a9ddcc29793e5ba3bfece096e222736e2172555", "url": "https://api.github.com/repos/rust-lang/rust/commits/9a9ddcc29793e5ba3bfece096e222736e2172555", "html_url": "https://github.com/rust-lang/rust/commit/9a9ddcc29793e5ba3bfece096e222736e2172555"}, {"sha": "627eddbc7e5eb13fc17c1c655ee1c3864c6dd4fe", "url": "https://api.github.com/repos/rust-lang/rust/commits/627eddbc7e5eb13fc17c1c655ee1c3864c6dd4fe", "html_url": "https://github.com/rust-lang/rust/commit/627eddbc7e5eb13fc17c1c655ee1c3864c6dd4fe"}], "stats": {"total": 3859, "additions": 1934, "deletions": 1925}, "files": [{"sha": "425814d732805c3fbbe39d020f3c85fe97fe5479", "filename": "xtask/src/ast_src.rs", "status": "modified", "additions": 1919, "deletions": 1911, "changes": 3830, "blob_url": "https://github.com/rust-lang/rust/blob/e35804355797a50195718918efc6f7272786d62e/xtask%2Fsrc%2Fast_src.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e35804355797a50195718918efc6f7272786d62e/xtask%2Fsrc%2Fast_src.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fast_src.rs?ref=e35804355797a50195718918efc6f7272786d62e"}, {"sha": "5a18b3e2b36030bda26550d70b167fde2fa13bb4", "filename": "xtask/src/codegen/gen_syntax.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/e35804355797a50195718918efc6f7272786d62e/xtask%2Fsrc%2Fcodegen%2Fgen_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e35804355797a50195718918efc6f7272786d62e/xtask%2Fsrc%2Fcodegen%2Fgen_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fcodegen%2Fgen_syntax.rs?ref=e35804355797a50195718918efc6f7272786d62e", "patch": "@@ -9,28 +9,29 @@ use proc_macro2::{Punct, Spacing};\n use quote::{format_ident, quote};\n \n use crate::{\n-    ast_src::{AstSrc, Field, FieldSrc, KindsSrc, AST_SRC, KINDS_SRC},\n+    ast_src::{rust_ast, AstSrc, Field, FieldSrc, KindsSrc, KINDS_SRC},\n     codegen::{self, update, Mode},\n     project_root, Result,\n };\n \n pub fn generate_syntax(mode: Mode) -> Result<()> {\n+    let ast = rust_ast();\n     let syntax_kinds_file = project_root().join(codegen::SYNTAX_KINDS);\n     let syntax_kinds = generate_syntax_kinds(KINDS_SRC)?;\n     update(syntax_kinds_file.as_path(), &syntax_kinds, mode)?;\n \n     let ast_tokens_file = project_root().join(codegen::AST_TOKENS);\n-    let contents = generate_tokens(AST_SRC)?;\n+    let contents = generate_tokens(&ast)?;\n     update(ast_tokens_file.as_path(), &contents, mode)?;\n \n     let ast_nodes_file = project_root().join(codegen::AST_NODES);\n-    let contents = generate_nodes(KINDS_SRC, AST_SRC)?;\n+    let contents = generate_nodes(KINDS_SRC, &ast)?;\n     update(ast_nodes_file.as_path(), &contents, mode)?;\n \n     Ok(())\n }\n \n-fn generate_tokens(grammar: AstSrc<'_>) -> Result<String> {\n+fn generate_tokens(grammar: &AstSrc) -> Result<String> {\n     let tokens = grammar.tokens.iter().map(|token| {\n         let name = format_ident!(\"{}\", token);\n         let kind = format_ident!(\"{}\", to_upper_snake_case(token));\n@@ -62,13 +63,13 @@ fn generate_tokens(grammar: AstSrc<'_>) -> Result<String> {\n     Ok(pretty)\n }\n \n-fn generate_nodes(kinds: KindsSrc<'_>, grammar: AstSrc<'_>) -> Result<String> {\n+fn generate_nodes(kinds: KindsSrc<'_>, grammar: &AstSrc) -> Result<String> {\n     let (node_defs, node_boilerplate_impls): (Vec<_>, Vec<_>) = grammar\n         .nodes\n         .iter()\n         .map(|node| {\n             let name = format_ident!(\"{}\", node.name);\n-            let kind = format_ident!(\"{}\", to_upper_snake_case(node.name));\n+            let kind = format_ident!(\"{}\", to_upper_snake_case(&node.name));\n             let traits = node.traits.iter().map(|trait_name| {\n                 let trait_name = format_ident!(\"{}\", trait_name);\n                 quote!(impl ast::#trait_name for #name {})\n@@ -192,8 +193,8 @@ fn generate_nodes(kinds: KindsSrc<'_>, grammar: AstSrc<'_>) -> Result<String> {\n         })\n         .unzip();\n \n-    let enum_names = grammar.enums.iter().map(|it| it.name);\n-    let node_names = grammar.nodes.iter().map(|it| it.name);\n+    let enum_names = grammar.enums.iter().map(|it| &it.name);\n+    let node_names = grammar.nodes.iter().map(|it| &it.name);\n \n     let display_impls =\n         enum_names.chain(node_names.clone()).map(|it| format_ident!(\"{}\", it)).map(|name| {\n@@ -212,7 +213,7 @@ fn generate_nodes(kinds: KindsSrc<'_>, grammar: AstSrc<'_>) -> Result<String> {\n         .nodes\n         .iter()\n         .map(|kind| to_pascal_case(kind))\n-        .filter(|name| !defined_nodes.contains(name.as_str()))\n+        .filter(|name| !defined_nodes.iter().any(|&it| it == name))\n     {\n         eprintln!(\"Warning: node {} not defined in ast source\", node);\n     }\n@@ -236,20 +237,20 @@ fn generate_nodes(kinds: KindsSrc<'_>, grammar: AstSrc<'_>) -> Result<String> {\n     let mut res = String::with_capacity(ast.len() * 2);\n \n     let mut docs =\n-        grammar.nodes.iter().map(|it| it.doc).chain(grammar.enums.iter().map(|it| it.doc));\n+        grammar.nodes.iter().map(|it| &it.doc).chain(grammar.enums.iter().map(|it| &it.doc));\n \n     for chunk in ast.split(\"# [ pretty_doc_comment_placeholder_workaround ]\") {\n         res.push_str(chunk);\n         if let Some(doc) = docs.next() {\n-            write_doc_comment(doc, &mut res);\n+            write_doc_comment(&doc, &mut res);\n         }\n     }\n \n     let pretty = crate::reformat(res)?;\n     Ok(pretty)\n }\n \n-fn write_doc_comment(contents: &[&str], dest: &mut String) {\n+fn write_doc_comment(contents: &[String], dest: &mut String) {\n     for line in contents {\n         writeln!(dest, \"///{}\", line).unwrap();\n     }\n@@ -413,7 +414,7 @@ fn to_pascal_case(s: &str) -> String {\n     buf\n }\n \n-impl Field<'_> {\n+impl Field {\n     fn is_many(&self) -> bool {\n         matches!(self, Field::Node { src: FieldSrc::Many(_), .. })\n     }\n@@ -429,7 +430,7 @@ impl Field<'_> {\n     fn method_name(&self) -> proc_macro2::Ident {\n         match self {\n             Field::Token(name) => {\n-                let name = match *name {\n+                let name = match name.as_str() {\n                     \";\" => \"semicolon\",\n                     \"->\" => \"thin_arrow\",\n                     \"'{'\" => \"l_curly\","}]}