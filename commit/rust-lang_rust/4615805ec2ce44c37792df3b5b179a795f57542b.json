{"sha": "4615805ec2ce44c37792df3b5b179a795f57542b", "node_id": "C_kwDOAAsO6NoAKDQ2MTU4MDVlYzJjZTQ0YzM3NzkyZGYzYjViMTc5YTc5NWY1NzU0MmI", "commit": {"author": {"name": "Miguel Raz Guzm\u00e1n Macedo", "email": "miguelraz@gmail.com", "date": "2022-03-26T22:10:25Z"}, "committer": {"name": "The Atelier", "email": "workingjubilee@gmail.com", "date": "2022-12-04T00:12:00Z"}, "message": "add remainder dot_product and cleanup\n\ncleanup dot_product and README.md", "tree": {"sha": "15afb5152a2ef9ac8b2fd3bfb0cc681e8468051d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/15afb5152a2ef9ac8b2fd3bfb0cc681e8468051d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4615805ec2ce44c37792df3b5b179a795f57542b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4615805ec2ce44c37792df3b5b179a795f57542b", "html_url": "https://github.com/rust-lang/rust/commit/4615805ec2ce44c37792df3b5b179a795f57542b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4615805ec2ce44c37792df3b5b179a795f57542b/comments", "author": {"login": "miguelraz", "id": 13056181, "node_id": "MDQ6VXNlcjEzMDU2MTgx", "avatar_url": "https://avatars.githubusercontent.com/u/13056181?v=4", "gravatar_id": "", "url": "https://api.github.com/users/miguelraz", "html_url": "https://github.com/miguelraz", "followers_url": "https://api.github.com/users/miguelraz/followers", "following_url": "https://api.github.com/users/miguelraz/following{/other_user}", "gists_url": "https://api.github.com/users/miguelraz/gists{/gist_id}", "starred_url": "https://api.github.com/users/miguelraz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/miguelraz/subscriptions", "organizations_url": "https://api.github.com/users/miguelraz/orgs", "repos_url": "https://api.github.com/users/miguelraz/repos", "events_url": "https://api.github.com/users/miguelraz/events{/privacy}", "received_events_url": "https://api.github.com/users/miguelraz/received_events", "type": "User", "site_admin": false}, "committer": {"login": "workingjubilee", "id": 46493976, "node_id": "MDQ6VXNlcjQ2NDkzOTc2", "avatar_url": "https://avatars.githubusercontent.com/u/46493976?v=4", "gravatar_id": "", "url": "https://api.github.com/users/workingjubilee", "html_url": "https://github.com/workingjubilee", "followers_url": "https://api.github.com/users/workingjubilee/followers", "following_url": "https://api.github.com/users/workingjubilee/following{/other_user}", "gists_url": "https://api.github.com/users/workingjubilee/gists{/gist_id}", "starred_url": "https://api.github.com/users/workingjubilee/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/workingjubilee/subscriptions", "organizations_url": "https://api.github.com/users/workingjubilee/orgs", "repos_url": "https://api.github.com/users/workingjubilee/repos", "events_url": "https://api.github.com/users/workingjubilee/events{/privacy}", "received_events_url": "https://api.github.com/users/workingjubilee/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c08a4d1f10473bfbdddf3d2eefc40e1194a633a7", "url": "https://api.github.com/repos/rust-lang/rust/commits/c08a4d1f10473bfbdddf3d2eefc40e1194a633a7", "html_url": "https://github.com/rust-lang/rust/commit/c08a4d1f10473bfbdddf3d2eefc40e1194a633a7"}], "stats": {"total": 114, "additions": 95, "deletions": 19}, "files": [{"sha": "82747f1b5a6f9c7091f7d3e1ad13d357d9619efb", "filename": "crates/core_simd/examples/README.md", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4615805ec2ce44c37792df3b5b179a795f57542b/crates%2Fcore_simd%2Fexamples%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/4615805ec2ce44c37792df3b5b179a795f57542b/crates%2Fcore_simd%2Fexamples%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fexamples%2FREADME.md?ref=4615805ec2ce44c37792df3b5b179a795f57542b", "patch": "@@ -10,10 +10,4 @@ Run the tests with the command\n cargo run --example dot_product\n ```\n \n-and the benchmarks via the command\n-\n-```\n-cargo run --example --benchmark ???\n-```\n-\n-and measure the timings on your local system.\n+and verify the code for `dot_product.rs` on your machine."}, {"sha": "ed210192e2a4b427cc4dda818fcc8cdb1c26c21e", "filename": "crates/core_simd/examples/dot_product.rs", "status": "modified", "additions": 94, "deletions": 12, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/4615805ec2ce44c37792df3b5b179a795f57542b/crates%2Fcore_simd%2Fexamples%2Fdot_product.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4615805ec2ce44c37792df3b5b179a795f57542b/crates%2Fcore_simd%2Fexamples%2Fdot_product.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fexamples%2Fdot_product.rs?ref=4615805ec2ce44c37792df3b5b179a795f57542b", "patch": "@@ -1,39 +1,113 @@\n // Code taken from the `packed_simd` crate\n // Run this code with `cargo test --example dot_product`\n+//use std::iter::zip;\n+\n #![feature(array_chunks)]\n+#![feature(slice_as_chunks)]\n+// Add these imports to use the stdsimd library\n+#![feature(portable_simd)]\n use core_simd::*;\n \n-/// This is your barebones dot product implementation: \n-/// Take 2 vectors, multiply them element wise and *then*\n-/// add up the result. In the next example we will see if there\n-///  is any difference to adding as we go along multiplying.\n+// This is your barebones dot product implementation:\n+// Take 2 vectors, multiply them element wise and *then*\n+// go along the resulting array and add up the result.\n+// In the next example we will see if there\n+//  is any difference to adding and multiplying in tandem.\n pub fn dot_prod_0(a: &[f32], b: &[f32]) -> f32 {\n     assert_eq!(a.len(), b.len());\n \n-    a.iter()\n-    .zip(b.iter())\n-    .map(|a, b| a * b)\n-    .sum()\n+    a.iter().zip(b.iter()).map(|(a, b)| a * b).sum()\n }\n \n+// When dealing with SIMD, it is very important to think about the amount\n+// of data movement and when it happens. We're going over simple computation examples here, and yet\n+// it is not trivial to understand what may or may not contribute to performance\n+// changes. Eventually, you will need tools to inspect the generated assembly and confirm your\n+// hypothesis and benchmarks - we will mention them later on.\n+// With the use of `fold`, we're doing a multiplication,\n+// and then adding it to the sum, one element from both vectors at a time.\n pub fn dot_prod_1(a: &[f32], b: &[f32]) -> f32 {\n     assert_eq!(a.len(), b.len());\n     a.iter()\n-    .zip(b.iter())\n-    .fold(0.0, |a, b| a * b)\n+        .zip(b.iter())\n+        .fold(0.0, |a, zipped| a + zipped.0 * zipped.1)\n }\n \n+// We now move on to the SIMD implementations: notice the following constructs:\n+// `array_chunks::<4>`: mapping this over the vector will let use construct SIMD vectors\n+// `f32x4::from_array`: construct the SIMD vector from a slice\n+// `(a * b).reduce_sum()`: Multiply both f32x4 vectors together, and then reduce them.\n+// This approach essentially uses SIMD to produce a vector of length N/4 of all the products,\n+// and then add those with `sum()`. This is suboptimal.\n+// TODO: ASCII diagrams\n pub fn dot_prod_simd_0(a: &[f32], b: &[f32]) -> f32 {\n     assert_eq!(a.len(), b.len());\n-\n     // TODO handle remainder when a.len() % 4 != 0\n     a.array_chunks::<4>()\n         .map(|&a| f32x4::from_array(a))\n         .zip(b.array_chunks::<4>().map(|&b| f32x4::from_array(b)))\n-        .map(|(a, b)| (a * b).horizontal_sum())\n+        .map(|(a, b)| (a * b).reduce_sum())\n         .sum()\n }\n \n+// There's some simple ways to improve the previous code:\n+// 1. Make a `zero` `f32x4` SIMD vector that we will be accumulating into\n+// So that there is only one `sum()` reduction when the last `f32x4` has been processed\n+// 2. Exploit Fused Multiply Add so that the multiplication, addition and sinking into the reduciton\n+// happen in the same step.\n+// If the arrays are large, minimizing the data shuffling will lead to great perf.\n+// If the arrays are small, handling the remainder elements when the length isn't a multiple of 4\n+// Can become a problem.\n+pub fn dot_prod_simd_1(a: &[f32], b: &[f32]) -> f32 {\n+    assert_eq!(a.len(), b.len());\n+    // TODO handle remainder when a.len() % 4 != 0\n+    a.array_chunks::<4>()\n+        .map(|&a| f32x4::from_array(a))\n+        .zip(b.array_chunks::<4>().map(|&b| f32x4::from_array(b)))\n+        .fold(f32x4::splat(0.0), |acc, zipped| acc + zipped.0 * zipped.1)\n+        .reduce_sum()\n+}\n+\n+// A lot of knowledgeable use of SIMD comes from knowing specific instructions that are\n+// available - let's try to use the `mul_add` instruction, which is the fused-multiply-add we were looking for.\n+use std_float::StdFloat;\n+pub fn dot_prod_simd_2(a: &[f32], b: &[f32]) -> f32 {\n+    assert_eq!(a.len(), b.len());\n+    // TODO handle remainder when a.len() % 4 != 0\n+    let mut res = f32x4::splat(0.0);\n+    a.array_chunks::<4>()\n+        .map(|&a| f32x4::from_array(a))\n+        .zip(b.array_chunks::<4>().map(|&b| f32x4::from_array(b)))\n+        .for_each(|(a, b)| {\n+            res = a.mul_add(b, res);\n+        });\n+    res.reduce_sum()\n+}\n+\n+// Finally, we will write the same operation but handling the loop remainder.\n+const LANES: usize = 4;\n+pub fn dot_prod_simd_3(a: &[f32], b: &[f32]) -> f32 {\n+    assert_eq!(a.len(), b.len());\n+\n+    let (a_extra, a_chunks) = a.as_rchunks();\n+    let (b_extra, b_chunks) = b.as_rchunks();\n+\n+    // These are always true, but for emphasis:\n+    assert_eq!(a_chunks.len(), b_chunks.len());\n+    assert_eq!(a_extra.len(), b_extra.len());\n+\n+    let mut sums = [0.0; LANES];\n+    for ((x, y), d) in std::iter::zip(a_extra, b_extra).zip(&mut sums) {\n+        *d = x * y;\n+    }\n+\n+    let mut sums = f32x4::from_array(sums);\n+    std::iter::zip(a_chunks, b_chunks).for_each(|(x, y)| {\n+        sums += f32x4::from_array(*x) * f32x4::from_array(*y);\n+    });\n+\n+    sums.reduce_sum()\n+}\n fn main() {\n     // Empty main to make cargo happy\n }\n@@ -45,10 +119,18 @@ mod tests {\n         use super::*;\n         let a: Vec<f32> = vec![1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0];\n         let b: Vec<f32> = vec![-8.0, -7.0, -6.0, -5.0, 4.0, 3.0, 2.0, 1.0];\n+        let x: Vec<f32> = [0.5; 1003].to_vec();\n+        let y: Vec<f32> = [2.0; 1003].to_vec();\n \n+        // Basic check\n         assert_eq!(0.0, dot_prod_0(&a, &b));\n         assert_eq!(0.0, dot_prod_1(&a, &b));\n         assert_eq!(0.0, dot_prod_simd_0(&a, &b));\n         assert_eq!(0.0, dot_prod_simd_1(&a, &b));\n+        assert_eq!(0.0, dot_prod_simd_2(&a, &b));\n+        assert_eq!(0.0, dot_prod_simd_3(&a, &b));\n+\n+        // We can handle vectors that are non-multiples of 4\n+        assert_eq!(1003.0, dot_prod_simd_3(&x, &y));\n     }\n }"}]}