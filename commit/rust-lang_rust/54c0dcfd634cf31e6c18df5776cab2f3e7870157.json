{"sha": "54c0dcfd634cf31e6c18df5776cab2f3e7870157", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU0YzBkY2ZkNjM0Y2YzMWU2YzE4ZGY1Nzc2Y2FiMmYzZTc4NzAxNTc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-07-28T21:17:54Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-07-28T21:17:54Z"}, "message": "Auto merge of #34956 - nikomatsakis:incr-comp-o-files, r=mw\n\nEnable reuse of `.o` files if nothing has changed\n\nThis PR completes a first \"spike\" for incremental compilation by enabling us to reuse `.o` files when nothing has changed. When in incr. mode, we will save `.o` files into the temporary directory, then copy them back out again if they are still valid. The code is still a bit rough but it does seem to work. =)\n\nr? @michaelwoerister\n\nFixes #34036\nFixes #34037\nFixes #34038", "tree": {"sha": "2799b3d4c1256ae7ab7895750deb19193d48a4af", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2799b3d4c1256ae7ab7895750deb19193d48a4af"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/54c0dcfd634cf31e6c18df5776cab2f3e7870157", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/54c0dcfd634cf31e6c18df5776cab2f3e7870157", "html_url": "https://github.com/rust-lang/rust/commit/54c0dcfd634cf31e6c18df5776cab2f3e7870157", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/54c0dcfd634cf31e6c18df5776cab2f3e7870157/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d1df3fecdf8dc959fbd8901603a16e5bc0bfa21d", "url": "https://api.github.com/repos/rust-lang/rust/commits/d1df3fecdf8dc959fbd8901603a16e5bc0bfa21d", "html_url": "https://github.com/rust-lang/rust/commit/d1df3fecdf8dc959fbd8901603a16e5bc0bfa21d"}, {"sha": "42cd5d4ee28a1c1b3bf4f07e27b1ca5a03fd9b02", "url": "https://api.github.com/repos/rust-lang/rust/commits/42cd5d4ee28a1c1b3bf4f07e27b1ca5a03fd9b02", "html_url": "https://github.com/rust-lang/rust/commit/42cd5d4ee28a1c1b3bf4f07e27b1ca5a03fd9b02"}], "stats": {"total": 1442, "additions": 1245, "deletions": 197}, "files": [{"sha": "c9247539990a9a8273508a2ea673a6ce6d65a0aa", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/54c0dcfd634cf31e6c18df5776cab2f3e7870157/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54c0dcfd634cf31e6c18df5776cab2f3e7870157/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=54c0dcfd634cf31e6c18df5776cab2f3e7870157", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n use std::fmt::Debug;\n+use std::sync::Arc;\n \n macro_rules! try_opt {\n     ($e:expr) => (\n@@ -45,6 +46,10 @@ pub enum DepNode<D: Clone + Debug> {\n     // in an extern crate.\n     MetaData(D),\n \n+    // Represents some artifact that we save to disk. Note that these\n+    // do not have a def-id as part of their identifier.\n+    WorkProduct(Arc<WorkProductId>),\n+\n     // Represents different phases in the compiler.\n     CrateReader,\n     CollectLanguageItems,\n@@ -189,6 +194,11 @@ impl<D: Clone + Debug> DepNode<D> {\n             TransCrate => Some(TransCrate),\n             TransWriteMetadata => Some(TransWriteMetadata),\n             LinkBinary => Some(LinkBinary),\n+\n+            // work product names do not need to be mapped, because\n+            // they are always absolute.\n+            WorkProduct(ref id) => Some(WorkProduct(id.clone())),\n+\n             Hir(ref d) => op(d).map(Hir),\n             MetaData(ref d) => op(d).map(MetaData),\n             CollectItem(ref d) => op(d).map(CollectItem),\n@@ -229,3 +239,12 @@ impl<D: Clone + Debug> DepNode<D> {\n         }\n     }\n }\n+\n+/// A \"work product\" corresponds to a `.o` (or other) file that we\n+/// save in between runs. These ids do not have a DefId but rather\n+/// some independent path or string that persists between runs without\n+/// the need to be mapped or unmapped. (This ensures we can serialize\n+/// them even in the absence of a tcx.)\n+#[derive(Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n+pub struct WorkProductId(pub String);\n+"}, {"sha": "bb027b11b45afa6bed09f25340ab648b6cbb8c00", "filename": "src/librustc/dep_graph/graph.rs", "status": "modified", "additions": 106, "deletions": 9, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/54c0dcfd634cf31e6c18df5776cab2f3e7870157/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54c0dcfd634cf31e6c18df5776cab2f3e7870157/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fgraph.rs?ref=54c0dcfd634cf31e6c18df5776cab2f3e7870157", "patch": "@@ -9,42 +9,65 @@\n // except according to those terms.\n \n use hir::def_id::DefId;\n+use rustc_data_structures::fnv::FnvHashMap;\n+use session::config::OutputType;\n+use std::cell::{Ref, RefCell};\n use std::rc::Rc;\n+use std::sync::Arc;\n \n-use super::dep_node::DepNode;\n+use super::dep_node::{DepNode, WorkProductId};\n use super::query::DepGraphQuery;\n use super::raii;\n use super::thread::{DepGraphThreadData, DepMessage};\n \n #[derive(Clone)]\n pub struct DepGraph {\n-    data: Rc<DepGraphThreadData>\n+    data: Rc<DepGraphData>\n+}\n+\n+struct DepGraphData {\n+    /// We send messages to the thread to let it build up the dep-graph\n+    /// from the current run.\n+    thread: DepGraphThreadData,\n+\n+    /// When we load, there may be `.o` files, cached mir, or other such\n+    /// things available to us. If we find that they are not dirty, we\n+    /// load the path to the file storing those work-products here into\n+    /// this map. We can later look for and extract that data.\n+    previous_work_products: RefCell<FnvHashMap<Arc<WorkProductId>, WorkProduct>>,\n+\n+    /// Work-products that we generate in this run.\n+    work_products: RefCell<FnvHashMap<Arc<WorkProductId>, WorkProduct>>,\n }\n \n impl DepGraph {\n     pub fn new(enabled: bool) -> DepGraph {\n         DepGraph {\n-            data: Rc::new(DepGraphThreadData::new(enabled))\n+            data: Rc::new(DepGraphData {\n+                thread: DepGraphThreadData::new(enabled),\n+                previous_work_products: RefCell::new(FnvHashMap()),\n+                work_products: RefCell::new(FnvHashMap())\n+            })\n         }\n     }\n \n     /// True if we are actually building a dep-graph. If this returns false,\n     /// then the other methods on this `DepGraph` will have no net effect.\n     #[inline]\n     pub fn enabled(&self) -> bool {\n-        self.data.enabled()\n+        self.data.thread.enabled()\n     }\n \n     pub fn query(&self) -> DepGraphQuery<DefId> {\n-        self.data.query()\n+        self.data.thread.query()\n     }\n \n     pub fn in_ignore<'graph>(&'graph self) -> raii::IgnoreTask<'graph> {\n-        raii::IgnoreTask::new(&self.data)\n+        raii::IgnoreTask::new(&self.data.thread)\n     }\n \n     pub fn in_task<'graph>(&'graph self, key: DepNode<DefId>) -> raii::DepTask<'graph> {\n-        raii::DepTask::new(&self.data, key)\n+        raii::DepTask::new(&self.data.thread, key)\n     }\n \n     pub fn with_ignore<OP,R>(&self, op: OP) -> R\n@@ -62,10 +85,84 @@ impl DepGraph {\n     }\n \n     pub fn read(&self, v: DepNode<DefId>) {\n-        self.data.enqueue(DepMessage::Read(v));\n+        self.data.thread.enqueue(DepMessage::Read(v));\n     }\n \n     pub fn write(&self, v: DepNode<DefId>) {\n-        self.data.enqueue(DepMessage::Write(v));\n+        self.data.thread.enqueue(DepMessage::Write(v));\n+    }\n+\n+    /// Indicates that a previous work product exists for `v`. This is\n+    /// invoked during initial start-up based on what nodes are clean\n+    /// (and what files exist in the incr. directory).\n+    pub fn insert_previous_work_product(&self, v: &Arc<WorkProductId>, data: WorkProduct) {\n+        debug!(\"insert_previous_work_product({:?}, {:?})\", v, data);\n+        self.data.previous_work_products.borrow_mut()\n+                                        .insert(v.clone(), data);\n+    }\n+\n+    /// Indicates that we created the given work-product in this run\n+    /// for `v`. This record will be preserved and loaded in the next\n+    /// run.\n+    pub fn insert_work_product(&self, v: &Arc<WorkProductId>, data: WorkProduct) {\n+        debug!(\"insert_work_product({:?}, {:?})\", v, data);\n+        self.data.work_products.borrow_mut()\n+                               .insert(v.clone(), data);\n     }\n+\n+    /// Check whether a previous work product exists for `v` and, if\n+    /// so, return the path that leads to it. Used to skip doing work.\n+    pub fn previous_work_product(&self, v: &Arc<WorkProductId>) -> Option<WorkProduct> {\n+        self.data.previous_work_products.borrow()\n+                                        .get(v)\n+                                        .cloned()\n+    }\n+\n+    /// Access the map of work-products created during this run. Only\n+    /// used during saving of the dep-graph.\n+    pub fn work_products(&self) -> Ref<FnvHashMap<Arc<WorkProductId>, WorkProduct>> {\n+        self.data.work_products.borrow()\n+    }\n+}\n+\n+/// A \"work product\" is an intermediate result that we save into the\n+/// incremental directory for later re-use. The primary example are\n+/// the object files that we save for each partition at code\n+/// generation time.\n+///\n+/// Each work product is associated with a dep-node, representing the\n+/// process that produced the work-product. If that dep-node is found\n+/// to be dirty when we load up, then we will delete the work-product\n+/// at load time. If the work-product is found to be clean, then we\n+/// will keep a record in the `previous_work_products` list.\n+///\n+/// In addition, work products have an associated hash. This hash is\n+/// an extra hash that can be used to decide if the work-product from\n+/// a previous compilation can be re-used (in addition to the dirty\n+/// edges check).\n+///\n+/// As the primary example, consider the object files we generate for\n+/// each partition. In the first run, we create partitions based on\n+/// the symbols that need to be compiled. For each partition P, we\n+/// hash the symbols in P and create a `WorkProduct` record associated\n+/// with `DepNode::TransPartition(P)`; the hash is the set of symbols\n+/// in P.\n+///\n+/// The next time we compile, if the `DepNode::TransPartition(P)` is\n+/// judged to be clean (which means none of the things we read to\n+/// generate the partition were found to be dirty), it will be loaded\n+/// into previous work products. We will then regenerate the set of\n+/// symbols in the partition P and hash them (note that new symbols\n+/// may be added -- for example, new monomorphizations -- even if\n+/// nothing in P changed!). We will compare that hash against the\n+/// previous hash. If it matches up, we can reuse the object file.\n+#[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n+pub struct WorkProduct {\n+    /// Extra hash used to decide if work-product is still suitable;\n+    /// note that this is *not* a hash of the work-product itself.\n+    /// See documentation on `WorkProduct` type for an example.\n+    pub input_hash: u64,\n+\n+    /// Saved files associated with this CGU\n+    pub saved_files: Vec<(OutputType, String)>,\n }"}, {"sha": "a499cb10f2325d3032f72d58b106ef18a5559d10", "filename": "src/librustc/dep_graph/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/54c0dcfd634cf31e6c18df5776cab2f3e7870157/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54c0dcfd634cf31e6c18df5776cab2f3e7870157/src%2Flibrustc%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fmod.rs?ref=54c0dcfd634cf31e6c18df5776cab2f3e7870157", "patch": "@@ -20,7 +20,9 @@ mod visit;\n \n pub use self::dep_tracking_map::{DepTrackingMap, DepTrackingMapConfig};\n pub use self::dep_node::DepNode;\n+pub use self::dep_node::WorkProductId;\n pub use self::graph::DepGraph;\n+pub use self::graph::WorkProduct;\n pub use self::query::DepGraphQuery;\n pub use self::visit::visit_all_items_in_krate;\n pub use self::raii::DepTask;"}, {"sha": "690395399efa166cd1bf244415a60a7f894151a6", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/54c0dcfd634cf31e6c18df5776cab2f3e7870157/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54c0dcfd634cf31e6c18df5776cab2f3e7870157/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=54c0dcfd634cf31e6c18df5776cab2f3e7870157", "patch": "@@ -61,7 +61,7 @@ pub enum DebugInfoLevel {\n     FullDebugInfo,\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, Hash)]\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n pub enum OutputType {\n     Bitcode,\n     Assembly,\n@@ -105,6 +105,17 @@ impl OutputType {\n             OutputType::DepInfo => \"dep-info\",\n         }\n     }\n+\n+    pub fn extension(&self) -> &'static str {\n+        match *self {\n+            OutputType::Bitcode => \"bc\",\n+            OutputType::Assembly => \"s\",\n+            OutputType::LlvmAssembly => \"ll\",\n+            OutputType::Object => \"o\",\n+            OutputType::DepInfo => \"d\",\n+            OutputType::Exe => \"\",\n+        }\n+    }\n }\n \n #[derive(Clone)]\n@@ -215,15 +226,7 @@ impl OutputFilenames {\n                      flavor: OutputType,\n                      codegen_unit_name: Option<&str>)\n                      -> PathBuf {\n-        let extension = match flavor {\n-            OutputType::Bitcode => \"bc\",\n-            OutputType::Assembly => \"s\",\n-            OutputType::LlvmAssembly => \"ll\",\n-            OutputType::Object => \"o\",\n-            OutputType::DepInfo => \"d\",\n-            OutputType::Exe => \"\",\n-        };\n-\n+        let extension = flavor.extension();\n         self.temp_path_ext(extension, codegen_unit_name)\n     }\n "}, {"sha": "cee18232ec98a05b71e2400ffc63b9a30bb833b3", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/54c0dcfd634cf31e6c18df5776cab2f3e7870157/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54c0dcfd634cf31e6c18df5776cab2f3e7870157/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=54c0dcfd634cf31e6c18df5776cab2f3e7870157", "patch": "@@ -80,7 +80,7 @@ pub struct Session {\n     // forms a unique global identifier for the crate. It is used to allow\n     // multiple crates with the same name to coexist. See the\n     // trans::back::symbol_names module for more information.\n-    pub crate_disambiguator: Cell<ast::Name>,\n+    pub crate_disambiguator: RefCell<token::InternedString>,\n     pub features: RefCell<feature_gate::Features>,\n \n     /// The maximum recursion limit for potentially infinitely recursive\n@@ -106,6 +106,9 @@ pub struct Session {\n }\n \n impl Session {\n+    pub fn local_crate_disambiguator(&self) -> token::InternedString {\n+        self.crate_disambiguator.borrow().clone()\n+    }\n     pub fn struct_span_warn<'a, S: Into<MultiSpan>>(&'a self,\n                                                     sp: S,\n                                                     msg: &str)\n@@ -438,7 +441,7 @@ pub fn build_session_(sopts: config::Options,\n         plugin_attributes: RefCell::new(Vec::new()),\n         crate_types: RefCell::new(Vec::new()),\n         dependency_formats: RefCell::new(FnvHashMap()),\n-        crate_disambiguator: Cell::new(token::intern(\"\")),\n+        crate_disambiguator: RefCell::new(token::intern(\"\").as_str()),\n         features: RefCell::new(feature_gate::Features::new()),\n         recursion_limit: Cell::new(64),\n         next_node_id: Cell::new(1),"}, {"sha": "5444dd9476120ed2f8cb01418c7bb14b81afb83c", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/54c0dcfd634cf31e6c18df5776cab2f3e7870157/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54c0dcfd634cf31e6c18df5776cab2f3e7870157/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=54c0dcfd634cf31e6c18df5776cab2f3e7870157", "patch": "@@ -504,7 +504,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n     pub fn crate_disambiguator(self, cnum: ast::CrateNum) -> token::InternedString {\n         if cnum == LOCAL_CRATE {\n-            self.sess.crate_disambiguator.get().as_str()\n+            self.sess.local_crate_disambiguator()\n         } else {\n             self.sess.cstore.crate_disambiguator(cnum)\n         }"}, {"sha": "f4e1c06090e591a9d5d2abd1f33d4db4b019b10f", "filename": "src/librustc/util/fs.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/54c0dcfd634cf31e6c18df5776cab2f3e7870157/src%2Flibrustc%2Futil%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54c0dcfd634cf31e6c18df5776cab2f3e7870157/src%2Flibrustc%2Futil%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Ffs.rs?ref=54c0dcfd634cf31e6c18df5776cab2f3e7870157", "patch": "@@ -10,6 +10,8 @@\n \n use std::path::{self, Path, PathBuf};\n use std::ffi::OsString;\n+use std::fs;\n+use std::io;\n \n // Unfortunately, on windows, it looks like msvcrt.dll is silently translating\n // verbatim paths under the hood to non-verbatim paths! This manifests itself as\n@@ -53,3 +55,15 @@ pub fn fix_windows_verbatim_for_gcc(p: &Path) -> PathBuf {\n         _ => p.to_path_buf(),\n     }\n }\n+\n+/// Copy `p` into `q`, preferring to use hard-linking if possible. If\n+/// `q` already exists, it is removed first.\n+pub fn link_or_copy<P: AsRef<Path>, Q: AsRef<Path>>(p: P, q: Q) -> io::Result<()> {\n+    let p = p.as_ref();\n+    let q = q.as_ref();\n+    if q.exists() {\n+        try!(fs::remove_file(&q));\n+    }\n+    fs::hard_link(p, q)\n+        .or_else(|_| fs::copy(p, q).map(|_| ()))\n+}"}, {"sha": "f172f38b809686f2995c10639ca4e05945882482", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 19, "deletions": 13, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/54c0dcfd634cf31e6c18df5776cab2f3e7870157/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54c0dcfd634cf31e6c18df5776cab2f3e7870157/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=54c0dcfd634cf31e6c18df5776cab2f3e7870157", "patch": "@@ -88,7 +88,7 @@ pub fn compile_input(sess: &Session,\n     // We need nested scopes here, because the intermediate results can keep\n     // large chunks of memory alive and we want to free them as soon as\n     // possible to keep the peak memory usage low\n-    let (outputs, trans) = {\n+    let (outputs, trans, crate_name) = {\n         let krate = match phase_1_parse_input(sess, cfg, input) {\n             Ok(krate) => krate,\n             Err(mut parse_error) => {\n@@ -113,21 +113,21 @@ pub fn compile_input(sess: &Session,\n         };\n \n         let outputs = build_output_filenames(input, outdir, output, &krate.attrs, sess);\n-        let id = link::find_crate_name(Some(sess), &krate.attrs, input);\n+        let crate_name = link::find_crate_name(Some(sess), &krate.attrs, input);\n         let ExpansionResult { expanded_crate, defs, analysis, resolutions, mut hir_forest } = {\n             phase_2_configure_and_expand(\n-                sess, &cstore, krate, &id, addl_plugins, control.make_glob_map,\n+                sess, &cstore, krate, &crate_name, addl_plugins, control.make_glob_map,\n                 |expanded_crate| {\n                     let mut state = CompileState::state_after_expand(\n-                        input, sess, outdir, output, &cstore, expanded_crate, &id,\n+                        input, sess, outdir, output, &cstore, expanded_crate, &crate_name,\n                     );\n                     controller_entry_point!(after_expand, sess, state, Ok(()));\n                     Ok(())\n                 }\n             )?\n         };\n \n-        write_out_deps(sess, &outputs, &id);\n+        write_out_deps(sess, &outputs, &crate_name);\n \n         let arenas = ty::CtxtArenas::new();\n \n@@ -151,7 +151,7 @@ pub fn compile_input(sess: &Session,\n                                                                   &resolutions,\n                                                                   &expanded_crate,\n                                                                   &hir_map.krate(),\n-                                                                  &id),\n+                                                                  &crate_name),\n                                     Ok(()));\n         }\n \n@@ -171,7 +171,7 @@ pub fn compile_input(sess: &Session,\n                                     analysis,\n                                     resolutions,\n                                     &arenas,\n-                                    &id,\n+                                    &crate_name,\n                                     |tcx, mir_map, analysis, result| {\n             {\n                 // Eventually, we will want to track plugins.\n@@ -186,7 +186,7 @@ pub fn compile_input(sess: &Session,\n                                                                    &analysis,\n                                                                    mir_map.as_ref(),\n                                                                    tcx,\n-                                                                   &id);\n+                                                                   &crate_name);\n                 (control.after_analysis.callback)(&mut state);\n \n                 if control.after_analysis.stop == Compilation::Stop {\n@@ -212,11 +212,11 @@ pub fn compile_input(sess: &Session,\n             // Discard interned strings as they are no longer required.\n             token::clear_ident_interner();\n \n-            Ok((outputs, trans))\n+            Ok((outputs, trans, crate_name.clone()))\n         })??\n     };\n \n-    let phase5_result = phase_5_run_llvm_passes(sess, &trans, &outputs);\n+    let phase5_result = phase_5_run_llvm_passes(sess, &crate_name, &trans, &outputs);\n \n     controller_entry_point!(after_llvm,\n                             sess,\n@@ -566,7 +566,8 @@ pub fn phase_2_configure_and_expand<'a, F>(sess: &Session,\n     });\n \n     *sess.crate_types.borrow_mut() = collect_crate_types(sess, &krate.attrs);\n-    sess.crate_disambiguator.set(token::intern(&compute_crate_disambiguator(sess)));\n+    *sess.crate_disambiguator.borrow_mut() =\n+        token::intern(&compute_crate_disambiguator(sess)).as_str();\n \n     time(time_passes, \"recursion limit\", || {\n         middle::recursion_limit::update_recursion_limit(sess, &krate);\n@@ -1019,6 +1020,7 @@ pub fn phase_4_translate_to_llvm<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n /// Run LLVM itself, producing a bitcode file, assembly file or object file\n /// as a side effect.\n pub fn phase_5_run_llvm_passes(sess: &Session,\n+                               crate_name: &str,\n                                trans: &trans::CrateTranslation,\n                                outputs: &OutputFilenames) -> CompileResult {\n     if sess.opts.cg.no_integrated_as {\n@@ -1040,6 +1042,10 @@ pub fn phase_5_run_llvm_passes(sess: &Session,\n              || write::run_passes(sess, trans, &sess.opts.output_types, outputs));\n     }\n \n+    time(sess.time_passes(),\n+         \"serialize work products\",\n+         move || rustc_incremental::save_work_products(sess, crate_name));\n+\n     if sess.err_count() > 0 {\n         Err(sess.err_count())\n     } else {\n@@ -1063,14 +1069,14 @@ fn escape_dep_filename(filename: &str) -> String {\n     filename.replace(\" \", \"\\\\ \")\n }\n \n-fn write_out_deps(sess: &Session, outputs: &OutputFilenames, id: &str) {\n+fn write_out_deps(sess: &Session, outputs: &OutputFilenames, crate_name: &str) {\n     let mut out_filenames = Vec::new();\n     for output_type in sess.opts.output_types.keys() {\n         let file = outputs.path(*output_type);\n         match *output_type {\n             OutputType::Exe => {\n                 for output in sess.crate_types.borrow().iter() {\n-                    let p = link::filename_for_input(sess, *output, id, outputs);\n+                    let p = link::filename_for_input(sess, *output, crate_name, outputs);\n                     out_filenames.push(p);\n                 }\n             }"}, {"sha": "7b1e0d2d0c8b676fb9e84832b13cab9981fef2f5", "filename": "src/librustc_incremental/calculate_svh.rs", "status": "modified", "additions": 40, "deletions": 7, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/54c0dcfd634cf31e6c18df5776cab2f3e7870157/src%2Flibrustc_incremental%2Fcalculate_svh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54c0dcfd634cf31e6c18df5776cab2f3e7870157/src%2Flibrustc_incremental%2Fcalculate_svh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh.rs?ref=54c0dcfd634cf31e6c18df5776cab2f3e7870157", "patch": "@@ -36,7 +36,7 @@ impl<'a, 'tcx> SvhCalculate for TyCtxt<'a, 'tcx, 'tcx> {\n         // to ensure it is not incorporating implementation artifacts into\n         // the hash that are not otherwise visible.)\n \n-        let crate_disambiguator = self.sess.crate_disambiguator.get();\n+        let crate_disambiguator = self.sess.local_crate_disambiguator();\n         let krate = self.map.krate();\n \n         // FIXME: this should use SHA1, not SipHash. SipHash is not built to\n@@ -47,10 +47,10 @@ impl<'a, 'tcx> SvhCalculate for TyCtxt<'a, 'tcx, 'tcx> {\n         // FIXME(#32753) -- at (*) we `to_le` for endianness, but is\n         // this enough, and does it matter anyway?\n         \"crate_disambiguator\".hash(&mut state);\n-        crate_disambiguator.as_str().len().to_le().hash(&mut state); // (*)\n-        crate_disambiguator.as_str().hash(&mut state);\n+        crate_disambiguator.len().to_le().hash(&mut state); // (*)\n+        crate_disambiguator.hash(&mut state);\n \n-        debug!(\"crate_disambiguator: {:?}\", crate_disambiguator.as_str());\n+        debug!(\"crate_disambiguator: {:?}\", crate_disambiguator);\n         debug!(\"state: {:?}\", state);\n \n         {\n@@ -119,6 +119,7 @@ mod svh_visitor {\n     use rustc::ty::TyCtxt;\n     use rustc::hir;\n     use rustc::hir::*;\n+    use rustc::hir::map::DefPath;\n     use rustc::hir::intravisit as visit;\n     use rustc::hir::intravisit::{Visitor, FnKind};\n \n@@ -135,6 +136,15 @@ mod svh_visitor {\n                    -> Self {\n             StrictVersionHashVisitor { st: st, tcx: tcx }\n         }\n+\n+        fn hash_def_path(&mut self, path: &DefPath) {\n+            self.tcx.crate_name(path.krate).hash(self.st);\n+            self.tcx.crate_disambiguator(path.krate).hash(self.st);\n+            for data in &path.data {\n+                data.data.as_interned_str().hash(self.st);\n+                data.disambiguator.hash(self.st);\n+            }\n+        }\n     }\n \n     // To off-load the bulk of the hash-computation on #[derive(Hash)],\n@@ -289,19 +299,21 @@ mod svh_visitor {\n \n     impl<'a, 'tcx> Visitor<'a> for StrictVersionHashVisitor<'a, 'tcx> {\n         fn visit_nested_item(&mut self, item: ItemId) {\n-            debug!(\"visit_nested_item: {:?} st={:?}\", item, self.st);\n-            let def_path = self.tcx.map.def_path_from_id(item.id);\n-            def_path.hash(self.st);\n+            let def_path = self.tcx.map.def_path_from_id(item.id).unwrap();\n+            debug!(\"visit_nested_item: def_path={:?} st={:?}\", def_path, self.st);\n+            self.hash_def_path(&def_path);\n         }\n \n         fn visit_variant_data(&mut self, s: &'a VariantData, name: Name,\n                               g: &'a Generics, _: NodeId, _: Span) {\n+            debug!(\"visit_variant_data: st={:?}\", self.st);\n             SawStructDef(name.as_str()).hash(self.st);\n             visit::walk_generics(self, g);\n             visit::walk_struct_def(self, s)\n         }\n \n         fn visit_variant(&mut self, v: &'a Variant, g: &'a Generics, item_id: NodeId) {\n+            debug!(\"visit_variant: st={:?}\", self.st);\n             SawVariant.hash(self.st);\n             // walk_variant does not call walk_generics, so do it here.\n             visit::walk_generics(self, g);\n@@ -323,14 +335,17 @@ mod svh_visitor {\n         // pattern, please move that method up above this comment.)\n \n         fn visit_name(&mut self, _: Span, name: Name) {\n+            debug!(\"visit_name: st={:?}\", self.st);\n             SawIdent(name.as_str()).hash(self.st);\n         }\n \n         fn visit_lifetime(&mut self, l: &'a Lifetime) {\n+            debug!(\"visit_lifetime: st={:?}\", self.st);\n             SawLifetime(l.name.as_str()).hash(self.st);\n         }\n \n         fn visit_lifetime_def(&mut self, l: &'a LifetimeDef) {\n+            debug!(\"visit_lifetime_def: st={:?}\", self.st);\n             SawLifetimeDef(l.lifetime.name.as_str()).hash(self.st);\n         }\n \n@@ -340,14 +355,18 @@ mod svh_visitor {\n         // that a change to a crate body will require downstream\n         // crates to be recompiled.\n         fn visit_expr(&mut self, ex: &'a Expr) {\n+            debug!(\"visit_expr: st={:?}\", self.st);\n             SawExpr(saw_expr(&ex.node)).hash(self.st); visit::walk_expr(self, ex)\n         }\n \n         fn visit_stmt(&mut self, s: &'a Stmt) {\n+            debug!(\"visit_stmt: st={:?}\", self.st);\n             SawStmt(saw_stmt(&s.node)).hash(self.st); visit::walk_stmt(self, s)\n         }\n \n         fn visit_foreign_item(&mut self, i: &'a ForeignItem) {\n+            debug!(\"visit_foreign_item: st={:?}\", self.st);\n+\n             // FIXME (#14132) ideally we would incorporate privacy (or\n             // perhaps reachability) somewhere here, so foreign items\n             // that do not leak into downstream crates would not be\n@@ -357,6 +376,7 @@ mod svh_visitor {\n \n         fn visit_item(&mut self, i: &'a Item) {\n             debug!(\"visit_item: {:?} st={:?}\", i, self.st);\n+\n             // FIXME (#14132) ideally would incorporate reachability\n             // analysis somewhere here, so items that never leak into\n             // downstream crates (e.g. via monomorphisation or\n@@ -365,55 +385,68 @@ mod svh_visitor {\n         }\n \n         fn visit_mod(&mut self, m: &'a Mod, _s: Span, _n: NodeId) {\n+            debug!(\"visit_mod: st={:?}\", self.st);\n             SawMod.hash(self.st); visit::walk_mod(self, m)\n         }\n \n         fn visit_decl(&mut self, d: &'a Decl) {\n+            debug!(\"visit_decl: st={:?}\", self.st);\n             SawDecl.hash(self.st); visit::walk_decl(self, d)\n         }\n \n         fn visit_ty(&mut self, t: &'a Ty) {\n+            debug!(\"visit_ty: st={:?}\", self.st);\n             SawTy.hash(self.st); visit::walk_ty(self, t)\n         }\n \n         fn visit_generics(&mut self, g: &'a Generics) {\n+            debug!(\"visit_generics: st={:?}\", self.st);\n             SawGenerics.hash(self.st); visit::walk_generics(self, g)\n         }\n \n         fn visit_fn(&mut self, fk: FnKind<'a>, fd: &'a FnDecl,\n                     b: &'a Block, s: Span, _: NodeId) {\n+            debug!(\"visit_fn: st={:?}\", self.st);\n             SawFn.hash(self.st); visit::walk_fn(self, fk, fd, b, s)\n         }\n \n         fn visit_trait_item(&mut self, ti: &'a TraitItem) {\n+            debug!(\"visit_trait_item: st={:?}\", self.st);\n             SawTraitItem.hash(self.st); visit::walk_trait_item(self, ti)\n         }\n \n         fn visit_impl_item(&mut self, ii: &'a ImplItem) {\n+            debug!(\"visit_impl_item: st={:?}\", self.st);\n             SawImplItem.hash(self.st); visit::walk_impl_item(self, ii)\n         }\n \n         fn visit_struct_field(&mut self, s: &'a StructField) {\n+            debug!(\"visit_struct_field: st={:?}\", self.st);\n             SawStructField.hash(self.st); visit::walk_struct_field(self, s)\n         }\n \n         fn visit_path(&mut self, path: &'a Path, _: ast::NodeId) {\n+            debug!(\"visit_path: st={:?}\", self.st);\n             SawPath.hash(self.st); visit::walk_path(self, path)\n         }\n \n         fn visit_block(&mut self, b: &'a Block) {\n+            debug!(\"visit_block: st={:?}\", self.st);\n             SawBlock.hash(self.st); visit::walk_block(self, b)\n         }\n \n         fn visit_pat(&mut self, p: &'a Pat) {\n+            debug!(\"visit_pat: st={:?}\", self.st);\n             SawPat.hash(self.st); visit::walk_pat(self, p)\n         }\n \n         fn visit_local(&mut self, l: &'a Local) {\n+            debug!(\"visit_local: st={:?}\", self.st);\n             SawLocal.hash(self.st); visit::walk_local(self, l)\n         }\n \n         fn visit_arm(&mut self, a: &'a Arm) {\n+            debug!(\"visit_arm: st={:?}\", self.st);\n             SawArm.hash(self.st); visit::walk_arm(self, a)\n         }\n     }"}, {"sha": "0d11b0794feacea61a4292f1be2c7bc7286b0d58", "filename": "src/librustc_incremental/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/54c0dcfd634cf31e6c18df5776cab2f3e7870157/src%2Flibrustc_incremental%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54c0dcfd634cf31e6c18df5776cab2f3e7870157/src%2Flibrustc_incremental%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Flib.rs?ref=54c0dcfd634cf31e6c18df5776cab2f3e7870157", "patch": "@@ -19,6 +19,7 @@\n       html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n #![cfg_attr(not(stage0), deny(warnings))]\n \n+#![feature(question_mark)]\n #![feature(rustc_private)]\n #![feature(staged_api)]\n \n@@ -40,3 +41,6 @@ pub use assert_dep_graph::assert_dep_graph;\n pub use calculate_svh::SvhCalculate;\n pub use persist::load_dep_graph;\n pub use persist::save_dep_graph;\n+pub use persist::save_trans_partition;\n+pub use persist::save_work_products;\n+pub use persist::in_incr_comp_dir;"}, {"sha": "95e9a16f29bbe927db40164283e00576231eb789", "filename": "src/librustc_incremental/persist/data.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/54c0dcfd634cf31e6c18df5776cab2f3e7870157/src%2Flibrustc_incremental%2Fpersist%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54c0dcfd634cf31e6c18df5776cab2f3e7870157/src%2Flibrustc_incremental%2Fpersist%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdata.rs?ref=54c0dcfd634cf31e6c18df5776cab2f3e7870157", "patch": "@@ -10,8 +10,9 @@\n \n //! The data that we will serialize and deserialize.\n \n-use rustc::dep_graph::DepNode;\n+use rustc::dep_graph::{DepNode, WorkProduct, WorkProductId};\n use rustc::hir::def_id::DefIndex;\n+use std::sync::Arc;\n \n use super::directory::DefPathIndex;\n \n@@ -55,6 +56,15 @@ pub struct SerializedHash {\n     pub hash: u64,\n }\n \n+#[derive(Debug, RustcEncodable, RustcDecodable)]\n+pub struct SerializedWorkProduct {\n+    /// node that produced the work-product\n+    pub id: Arc<WorkProductId>,\n+\n+    /// work-product data itself\n+    pub work_product: WorkProduct,\n+}\n+\n /// Data for use when downstream crates get recompiled.\n #[derive(Debug, RustcEncodable, RustcDecodable)]\n pub struct SerializedMetadataHashes {"}, {"sha": "36b6c79c40f5dc9379fac023bb43b567d0334198", "filename": "src/librustc_incremental/persist/load.rs", "status": "modified", "additions": 107, "deletions": 26, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/54c0dcfd634cf31e6c18df5776cab2f3e7870157/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54c0dcfd634cf31e6c18df5776cab2f3e7870157/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fload.rs?ref=54c0dcfd634cf31e6c18df5776cab2f3e7870157", "patch": "@@ -14,12 +14,13 @@ use rbml::Error;\n use rbml::opaque::Decoder;\n use rustc::dep_graph::DepNode;\n use rustc::hir::def_id::DefId;\n+use rustc::session::Session;\n use rustc::ty::TyCtxt;\n use rustc_data_structures::fnv::FnvHashSet;\n use rustc_serialize::Decodable as RustcDecodable;\n use std::io::Read;\n-use std::fs::File;\n-use std::path::Path;\n+use std::fs::{self, File};\n+use std::path::{Path};\n \n use super::data::*;\n use super::directory::*;\n@@ -38,50 +39,74 @@ type CleanEdges = Vec<(DepNode<DefId>, DepNode<DefId>)>;\n /// actually it doesn't matter all that much.) See `README.md` for\n /// more general overview.\n pub fn load_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n+    if tcx.sess.opts.incremental.is_none() {\n+        return;\n+    }\n+\n     let _ignore = tcx.dep_graph.in_ignore();\n+    load_dep_graph_if_exists(tcx);\n+    dirty_clean::check_dirty_clean_annotations(tcx);\n+}\n \n-    if let Some(dep_graph) = dep_graph_path(tcx) {\n-        // FIXME(#32754) lock file?\n-        load_dep_graph_if_exists(tcx, &dep_graph);\n-        dirty_clean::check_dirty_clean_annotations(tcx);\n+fn load_dep_graph_if_exists<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n+    let dep_graph_path = dep_graph_path(tcx).unwrap();\n+    let dep_graph_data = match load_data(tcx.sess, &dep_graph_path) {\n+        Some(p) => p,\n+        None => return // no file\n+    };\n+\n+    let work_products_path = tcx_work_products_path(tcx).unwrap();\n+    let work_products_data = match load_data(tcx.sess, &work_products_path) {\n+        Some(p) => p,\n+        None => return // no file\n+    };\n+\n+    match decode_dep_graph(tcx, &dep_graph_data, &work_products_data) {\n+        Ok(()) => return,\n+        Err(err) => {\n+            tcx.sess.warn(\n+                &format!(\"decoding error in dep-graph from `{}` and `{}`: {}\",\n+                         dep_graph_path.display(),\n+                         work_products_path.display(),\n+                         err));\n+        }\n     }\n }\n \n-pub fn load_dep_graph_if_exists<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, path: &Path) {\n+fn load_data(sess: &Session, path: &Path) -> Option<Vec<u8>> {\n     if !path.exists() {\n-        return;\n+        return None;\n     }\n \n     let mut data = vec![];\n     match\n         File::open(path)\n         .and_then(|mut file| file.read_to_end(&mut data))\n     {\n-        Ok(_) => { }\n+        Ok(_) => {\n+            Some(data)\n+        }\n         Err(err) => {\n-            tcx.sess.err(\n+            sess.err(\n                 &format!(\"could not load dep-graph from `{}`: {}\",\n                          path.display(), err));\n-            return;\n+            None\n         }\n     }\n \n-    match decode_dep_graph(tcx, &data) {\n-        Ok(dirty) => dirty,\n-        Err(err) => {\n-            bug!(\"decoding error in dep-graph from `{}`: {}\", path.display(), err);\n-        }\n-    }\n }\n \n+/// Decode the dep graph and load the edges/nodes that are still clean\n+/// into `tcx.dep_graph`.\n pub fn decode_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                  data: &[u8])\n+                                  dep_graph_data: &[u8],\n+                                  work_products_data: &[u8])\n                                   -> Result<(), Error>\n {\n     // Deserialize the directory and dep-graph.\n-    let mut decoder = Decoder::new(data, 0);\n-    let directory = try!(DefIdDirectory::decode(&mut decoder));\n-    let serialized_dep_graph = try!(SerializedDepGraph::decode(&mut decoder));\n+    let mut dep_graph_decoder = Decoder::new(dep_graph_data, 0);\n+    let directory = try!(DefIdDirectory::decode(&mut dep_graph_decoder));\n+    let serialized_dep_graph = try!(SerializedDepGraph::decode(&mut dep_graph_decoder));\n \n     debug!(\"decode_dep_graph: directory = {:#?}\", directory);\n     debug!(\"decode_dep_graph: serialized_dep_graph = {:#?}\", serialized_dep_graph);\n@@ -121,12 +146,18 @@ pub fn decode_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // Add nodes and edges that are not dirty into our main graph.\n     let dep_graph = tcx.dep_graph.clone();\n     for (source, target) in clean_edges.into_iter().chain(clean_nodes) {\n-        let _task = dep_graph.in_task(target.clone());\n-        dep_graph.read(source.clone());\n-\n         debug!(\"decode_dep_graph: clean edge: {:?} -> {:?}\", source, target);\n+\n+        let _task = dep_graph.in_task(target);\n+        dep_graph.read(source);\n     }\n \n+    // Add in work-products that are still clean, and delete those that are\n+    // dirty.\n+    let mut work_product_decoder = Decoder::new(work_products_data, 0);\n+    let work_products = try!(<Vec<SerializedWorkProduct>>::decode(&mut work_product_decoder));\n+    reconcile_work_products(tcx, work_products, &dirty_nodes);\n+\n     Ok(())\n }\n \n@@ -141,9 +172,9 @@ fn initial_dirty_nodes<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         match hash.node.map_def(|&i| retraced.def_id(i)) {\n             Some(dep_node) => {\n                 let current_hash = hcx.hash(&dep_node).unwrap();\n-                debug!(\"initial_dirty_nodes: hash of {:?} is {:?}, was {:?}\",\n-                       dep_node, current_hash, hash.hash);\n                 if current_hash != hash.hash {\n+                    debug!(\"initial_dirty_nodes: {:?} is dirty as hash is {:?}, was {:?}\",\n+                           dep_node, current_hash, hash.hash);\n                     dirty_nodes.insert(dep_node);\n                 }\n             }\n@@ -177,6 +208,8 @@ fn compute_clean_edges(serialized_edges: &[(SerializedEdge)],\n                 clean_edges.push((source, target))\n             } else {\n                 // source removed, target must be dirty\n+                debug!(\"compute_clean_edges: {:?} dirty because {:?} no longer exists\",\n+                       target, serialized_source);\n                 dirty_nodes.insert(target);\n             }\n         } else {\n@@ -213,3 +246,51 @@ fn compute_clean_edges(serialized_edges: &[(SerializedEdge)],\n \n     clean_edges\n }\n+\n+/// Go through the list of work-products produced in the previous run.\n+/// Delete any whose nodes have been found to be dirty or which are\n+/// otherwise no longer applicable.\n+fn reconcile_work_products<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                     work_products: Vec<SerializedWorkProduct>,\n+                                     dirty_nodes: &DirtyNodes) {\n+    debug!(\"reconcile_work_products({:?})\", work_products);\n+    for swp in work_products {\n+        let dep_node = DepNode::WorkProduct(swp.id.clone());\n+        if dirty_nodes.contains(&dep_node) {\n+            debug!(\"reconcile_work_products: dep-node for {:?} is dirty\", swp);\n+            delete_dirty_work_product(tcx, swp);\n+        } else {\n+            let all_files_exist =\n+                swp.work_product\n+                   .saved_files\n+                   .iter()\n+                   .all(|&(_, ref file_name)| {\n+                       let path = in_incr_comp_dir(tcx.sess, &file_name).unwrap();\n+                       path.exists()\n+                   });\n+            if all_files_exist {\n+                debug!(\"reconcile_work_products: all files for {:?} exist\", swp);\n+                tcx.dep_graph.insert_previous_work_product(&swp.id, swp.work_product);\n+            } else {\n+                debug!(\"reconcile_work_products: some file for {:?} does not exist\", swp);\n+                delete_dirty_work_product(tcx, swp);\n+            }\n+        }\n+    }\n+}\n+\n+fn delete_dirty_work_product(tcx: TyCtxt,\n+                             swp: SerializedWorkProduct) {\n+    debug!(\"delete_dirty_work_product({:?})\", swp);\n+    for &(_, ref file_name) in &swp.work_product.saved_files {\n+        let path = in_incr_comp_dir(tcx.sess, file_name).unwrap();\n+        match fs::remove_file(&path) {\n+            Ok(()) => { }\n+            Err(err) => {\n+                tcx.sess.warn(\n+                    &format!(\"file-system error deleting outdated file `{}`: {}\",\n+                             path.display(), err));\n+            }\n+        }\n+    }\n+}"}, {"sha": "1157f494ce604e32c2d9fdd5512416f1c8c967fe", "filename": "src/librustc_incremental/persist/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/54c0dcfd634cf31e6c18df5776cab2f3e7870157/src%2Flibrustc_incremental%2Fpersist%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54c0dcfd634cf31e6c18df5776cab2f3e7870157/src%2Flibrustc_incremental%2Fpersist%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fmod.rs?ref=54c0dcfd634cf31e6c18df5776cab2f3e7870157", "patch": "@@ -19,6 +19,10 @@ mod hash;\n mod load;\n mod save;\n mod util;\n+mod work_product;\n \n pub use self::load::load_dep_graph;\n pub use self::save::save_dep_graph;\n+pub use self::save::save_work_products;\n+pub use self::work_product::save_trans_partition;\n+pub use self::util::in_incr_comp_dir;"}, {"sha": "305250d59623c50d644da6ad3cb3e7de2f538e19", "filename": "src/librustc_incremental/persist/save.rs", "status": "modified", "additions": 39, "deletions": 12, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/54c0dcfd634cf31e6c18df5776cab2f3e7870157/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54c0dcfd634cf31e6c18df5776cab2f3e7870157/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs?ref=54c0dcfd634cf31e6c18df5776cab2f3e7870157", "patch": "@@ -11,6 +11,7 @@\n use rbml::opaque::Encoder;\n use rustc::dep_graph::DepNode;\n use rustc::middle::cstore::LOCAL_CRATE;\n+use rustc::session::Session;\n use rustc::ty::TyCtxt;\n use rustc_serialize::{Encodable as RustcEncodable};\n use std::hash::{Hasher, SipHasher};\n@@ -24,19 +25,26 @@ use super::hash::*;\n use super::util::*;\n \n pub fn save_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n+    debug!(\"save_dep_graph()\");\n     let _ignore = tcx.dep_graph.in_ignore();\n+    let sess = tcx.sess;\n     let mut hcx = HashContext::new(tcx);\n-    save_in(&mut hcx, dep_graph_path(tcx), encode_dep_graph);\n-    save_in(&mut hcx, metadata_hash_path(tcx, LOCAL_CRATE), encode_metadata_hashes);\n+    save_in(sess, dep_graph_path(tcx), |e| encode_dep_graph(&mut hcx, e));\n+    save_in(sess, metadata_hash_path(tcx, LOCAL_CRATE), |e| encode_metadata_hashes(&mut hcx, e));\n }\n \n-fn save_in<'a, 'tcx, F>(hcx: &mut HashContext<'a, 'tcx>,\n-                        opt_path_buf: Option<PathBuf>,\n-                        encode: F)\n-    where F: FnOnce(&mut HashContext<'a, 'tcx>, &mut Encoder) -> io::Result<()>\n-{\n-    let tcx = hcx.tcx;\n+pub fn save_work_products(sess: &Session, local_crate_name: &str) {\n+    debug!(\"save_work_products()\");\n+    let _ignore = sess.dep_graph.in_ignore();\n+    let path = sess_work_products_path(sess, local_crate_name);\n+    save_in(sess, path, |e| encode_work_products(sess, e));\n+}\n \n+fn save_in<F>(sess: &Session,\n+              opt_path_buf: Option<PathBuf>,\n+              encode: F)\n+    where F: FnOnce(&mut Encoder) -> io::Result<()>\n+{\n     let path_buf = match opt_path_buf {\n         Some(p) => p,\n         None => return\n@@ -49,7 +57,7 @@ fn save_in<'a, 'tcx, F>(hcx: &mut HashContext<'a, 'tcx>,\n         match fs::remove_file(&path_buf) {\n             Ok(()) => { }\n             Err(err) => {\n-                tcx.sess.err(\n+                sess.err(\n                     &format!(\"unable to delete old dep-graph at `{}`: {}\",\n                              path_buf.display(), err));\n                 return;\n@@ -59,10 +67,10 @@ fn save_in<'a, 'tcx, F>(hcx: &mut HashContext<'a, 'tcx>,\n \n     // generate the data in a memory buffer\n     let mut wr = Cursor::new(Vec::new());\n-    match encode(hcx, &mut Encoder::new(&mut wr)) {\n+    match encode(&mut Encoder::new(&mut wr)) {\n         Ok(()) => { }\n         Err(err) => {\n-            tcx.sess.err(\n+            sess.err(\n                 &format!(\"could not encode dep-graph to `{}`: {}\",\n                          path_buf.display(), err));\n             return;\n@@ -77,7 +85,7 @@ fn save_in<'a, 'tcx, F>(hcx: &mut HashContext<'a, 'tcx>,\n     {\n         Ok(_) => { }\n         Err(err) => {\n-            tcx.sess.err(\n+            sess.err(\n                 &format!(\"failed to write dep-graph to `{}`: {}\",\n                          path_buf.display(), err));\n             return;\n@@ -192,3 +200,22 @@ pub fn encode_metadata_hashes<'a, 'tcx>(hcx: &mut HashContext<'a, 'tcx>,\n \n     Ok(())\n }\n+\n+pub fn encode_work_products(sess: &Session,\n+                            encoder: &mut Encoder)\n+                            -> io::Result<()>\n+{\n+    let work_products: Vec<_> =\n+        sess.dep_graph.work_products()\n+                     .iter()\n+                     .map(|(id, work_product)| {\n+                         SerializedWorkProduct {\n+                             id: id.clone(),\n+                             work_product: work_product.clone(),\n+                         }\n+                     })\n+                     .collect();\n+\n+    work_products.encode(encoder)\n+}\n+"}, {"sha": "f1e81fdb266b9b201271281c02851e8248b16083", "filename": "src/librustc_incremental/persist/util.rs", "status": "modified", "additions": 35, "deletions": 11, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/54c0dcfd634cf31e6c18df5776cab2f3e7870157/src%2Flibrustc_incremental%2Fpersist%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54c0dcfd634cf31e6c18df5776cab2f3e7870157/src%2Flibrustc_incremental%2Fpersist%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Futil.rs?ref=54c0dcfd634cf31e6c18df5776cab2f3e7870157", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n use rustc::middle::cstore::LOCAL_CRATE;\n+use rustc::session::Session;\n use rustc::ty::TyCtxt;\n \n use std::fs;\n@@ -17,33 +18,56 @@ use std::path::{Path, PathBuf};\n use syntax::ast;\n \n pub fn dep_graph_path(tcx: TyCtxt) -> Option<PathBuf> {\n-    path(tcx, LOCAL_CRATE, \"local\")\n+    tcx_path(tcx, LOCAL_CRATE, \"local\")\n }\n \n pub fn metadata_hash_path(tcx: TyCtxt, cnum: ast::CrateNum) -> Option<PathBuf> {\n-    path(tcx, cnum, \"metadata\")\n+    tcx_path(tcx, cnum, \"metadata\")\n }\n \n-fn path(tcx: TyCtxt, cnum: ast::CrateNum, suffix: &str) -> Option<PathBuf> {\n+pub fn tcx_work_products_path(tcx: TyCtxt) -> Option<PathBuf> {\n+    let crate_name = tcx.crate_name(LOCAL_CRATE);\n+    sess_work_products_path(tcx.sess, &crate_name)\n+}\n+\n+pub fn sess_work_products_path(sess: &Session,\n+                               local_crate_name: &str)\n+                               -> Option<PathBuf> {\n+    let crate_disambiguator = sess.local_crate_disambiguator();\n+    path(sess, local_crate_name, &crate_disambiguator, \"work-products\")\n+}\n+\n+pub fn in_incr_comp_dir(sess: &Session, file_name: &str) -> Option<PathBuf> {\n+    sess.opts.incremental.as_ref().map(|incr_dir| incr_dir.join(file_name))\n+}\n+\n+fn tcx_path(tcx: TyCtxt,\n+            cnum: ast::CrateNum,\n+            middle: &str)\n+            -> Option<PathBuf> {\n+    path(tcx.sess, &tcx.crate_name(cnum), &tcx.crate_disambiguator(cnum), middle)\n+}\n+\n+fn path(sess: &Session,\n+        crate_name: &str,\n+        crate_disambiguator: &str,\n+        middle: &str)\n+        -> Option<PathBuf> {\n     // For now, just save/load dep-graph from\n     // directory/dep_graph.rbml\n-    tcx.sess.opts.incremental.as_ref().and_then(|incr_dir| {\n+    sess.opts.incremental.as_ref().and_then(|incr_dir| {\n         match create_dir_racy(&incr_dir) {\n             Ok(()) => {}\n             Err(err) => {\n-                tcx.sess.err(\n+                sess.err(\n                     &format!(\"could not create the directory `{}`: {}\",\n                              incr_dir.display(), err));\n                 return None;\n             }\n         }\n \n-        let crate_name = tcx.crate_name(cnum);\n-        let crate_disambiguator = tcx.crate_disambiguator(cnum);\n-        let file_name = format!(\"{}-{}.{}.bin\",\n-                                crate_name,\n-                                crate_disambiguator,\n-                                suffix);\n+        let file_name = format!(\"{}-{}.{}.bin\", crate_name, crate_disambiguator, middle);\n+\n         Some(incr_dir.join(file_name))\n     })\n }"}, {"sha": "c106ea8f262691ec83cfe693efaaadc6663734c2", "filename": "src/librustc_incremental/persist/work_product.rs", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/54c0dcfd634cf31e6c18df5776cab2f3e7870157/src%2Flibrustc_incremental%2Fpersist%2Fwork_product.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54c0dcfd634cf31e6c18df5776cab2f3e7870157/src%2Flibrustc_incremental%2Fpersist%2Fwork_product.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fwork_product.rs?ref=54c0dcfd634cf31e6c18df5776cab2f3e7870157", "patch": "@@ -0,0 +1,63 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! This module contains files for saving intermediate work-products.\n+\n+use persist::util::*;\n+use rustc::dep_graph::{WorkProduct, WorkProductId};\n+use rustc::session::Session;\n+use rustc::session::config::OutputType;\n+use rustc::util::fs::link_or_copy;\n+use std::path::PathBuf;\n+use std::sync::Arc;\n+\n+pub fn save_trans_partition(sess: &Session,\n+                            cgu_name: &str,\n+                            partition_hash: u64,\n+                            files: &[(OutputType, PathBuf)]) {\n+    debug!(\"save_trans_partition({:?},{},{:?})\",\n+           cgu_name,\n+           partition_hash,\n+           files);\n+    if sess.opts.incremental.is_none() {\n+        return;\n+    }\n+    let work_product_id = Arc::new(WorkProductId(cgu_name.to_string()));\n+\n+    let saved_files: Option<Vec<_>> =\n+        files.iter()\n+             .map(|&(kind, ref path)| {\n+                 let file_name = format!(\"cgu-{}.{}\", cgu_name, kind.extension());\n+                 let path_in_incr_dir = in_incr_comp_dir(sess, &file_name).unwrap();\n+                 match link_or_copy(path, &path_in_incr_dir) {\n+                     Ok(_) => Some((kind, file_name)),\n+                     Err(err) => {\n+                         sess.warn(&format!(\"error copying object file `{}` \\\n+                                             to incremental directory as `{}`: {}\",\n+                                            path.display(),\n+                                            path_in_incr_dir.display(),\n+                                            err));\n+                         None\n+                     }\n+                 }\n+             })\n+             .collect();\n+    let saved_files = match saved_files {\n+        Some(v) => v,\n+        None => return,\n+    };\n+\n+    let work_product = WorkProduct {\n+        input_hash: partition_hash,\n+        saved_files: saved_files,\n+    };\n+\n+    sess.dep_graph.insert_work_product(&work_product_id, work_product);\n+}"}, {"sha": "0b60fc386a7bbd8a84d2392fadc448499ae00851", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/54c0dcfd634cf31e6c18df5776cab2f3e7870157/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54c0dcfd634cf31e6c18df5776cab2f3e7870157/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=54c0dcfd634cf31e6c18df5776cab2f3e7870157", "patch": "@@ -243,7 +243,7 @@ impl<'a> CrateReader<'a> {\n \n         // Check for (potential) conflicts with the local crate\n         if self.local_crate_name == crate_name &&\n-           self.sess.crate_disambiguator.get().as_str() == disambiguator {\n+           self.sess.local_crate_disambiguator() == disambiguator {\n             span_fatal!(self.sess, span, E0519,\n                         \"the current crate is indistinguishable from one of its \\\n                          dependencies: it has the same crate-name `{}` and was \\"}, {"sha": "c896263de948ec295040a5e27b92c5a80fb3fd11", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/54c0dcfd634cf31e6c18df5776cab2f3e7870157/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54c0dcfd634cf31e6c18df5776cab2f3e7870157/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=54c0dcfd634cf31e6c18df5776cab2f3e7870157", "patch": "@@ -1893,7 +1893,7 @@ fn encode_metadata_inner(rbml_w: &mut Encoder,\n     encode_crate_name(rbml_w, &ecx.link_meta.crate_name);\n     encode_crate_triple(rbml_w, &ecx.tcx.sess.opts.target_triple);\n     encode_hash(rbml_w, &ecx.link_meta.crate_hash);\n-    encode_crate_disambiguator(rbml_w, &ecx.tcx.sess.crate_disambiguator.get().as_str());\n+    encode_crate_disambiguator(rbml_w, &ecx.tcx.sess.local_crate_disambiguator());\n     encode_dylib_dependency_formats(rbml_w, &ecx);\n     encode_panic_strategy(rbml_w, &ecx);\n "}, {"sha": "e0532e7476f511545d0bf7ac2ae98ac307d4548c", "filename": "src/librustc_trans/assert_module_sources.rs", "status": "added", "additions": 149, "deletions": 0, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/54c0dcfd634cf31e6c18df5776cab2f3e7870157/src%2Flibrustc_trans%2Fassert_module_sources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54c0dcfd634cf31e6c18df5776cab2f3e7870157/src%2Flibrustc_trans%2Fassert_module_sources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fassert_module_sources.rs?ref=54c0dcfd634cf31e6c18df5776cab2f3e7870157", "patch": "@@ -0,0 +1,149 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! This pass is only used for UNIT TESTS related to incremental\n+//! compilation. It tests whether a particular `.o` file will be re-used\n+//! from a previous compilation or whether it must be regenerated.\n+//!\n+//! The user adds annotations to the crate of the following form:\n+//!\n+//! ```\n+//! #![rustc_partition_reused(module=\"spike\", cfg=\"rpass2\")]\n+//! #![rustc_partition_translated(module=\"spike-x\", cfg=\"rpass2\")]\n+//! ```\n+//!\n+//! The first indicates (in the cfg `rpass2`) that `spike.o` will be\n+//! reused, the second that `spike-x.o` will be recreated. If these\n+//! annotations are inaccurate, errors are reported.\n+//!\n+//! The reason that we use `cfg=...` and not `#[cfg_attr]` is so that\n+//! the HIR doesn't change as a result of the annotations, which might\n+//! perturb the reuse results.\n+\n+use rustc::ty::TyCtxt;\n+use syntax::ast;\n+use syntax::attr::AttrMetaMethods;\n+use syntax::parse::token::InternedString;\n+\n+use {ModuleSource, ModuleTranslation};\n+\n+const PARTITION_REUSED: &'static str = \"rustc_partition_reused\";\n+const PARTITION_TRANSLATED: &'static str = \"rustc_partition_translated\";\n+\n+const MODULE: &'static str = \"module\";\n+const CFG: &'static str = \"cfg\";\n+\n+#[derive(Debug, PartialEq)]\n+enum Disposition { Reused, Translated }\n+\n+pub fn assert_module_sources<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                       modules: &[ModuleTranslation]) {\n+    let _ignore = tcx.dep_graph.in_ignore();\n+\n+    if tcx.sess.opts.incremental.is_none() {\n+        return;\n+    }\n+\n+    let ams = AssertModuleSource { tcx: tcx, modules: modules };\n+    for attr in &tcx.map.krate().attrs {\n+        ams.check_attr(attr);\n+    }\n+}\n+\n+struct AssertModuleSource<'a, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    modules: &'a [ModuleTranslation],\n+}\n+\n+impl<'a, 'tcx> AssertModuleSource<'a, 'tcx> {\n+    fn check_attr(&self, attr: &ast::Attribute) {\n+        let disposition = if attr.check_name(PARTITION_REUSED) {\n+            Disposition::Reused\n+        } else if attr.check_name(PARTITION_TRANSLATED) {\n+            Disposition::Translated\n+        } else {\n+            return;\n+        };\n+\n+        if !self.check_config(attr) {\n+            debug!(\"check_attr: config does not match, ignoring attr\");\n+            return;\n+        }\n+\n+        let mname = self.field(attr, MODULE);\n+        let mtrans = self.modules.iter().find(|mtrans| &mtrans.name[..] == &mname[..]);\n+        let mtrans = match mtrans {\n+            Some(m) => m,\n+            None => {\n+                debug!(\"module name `{}` not found amongst:\", mname);\n+                for mtrans in self.modules {\n+                    debug!(\"module named `{}` with disposition {:?}\",\n+                           mtrans.name,\n+                           self.disposition(mtrans));\n+                }\n+\n+                self.tcx.sess.span_err(\n+                    attr.span,\n+                    &format!(\"no module named `{}`\", mname));\n+                return;\n+            }\n+        };\n+\n+        let mtrans_disposition = self.disposition(mtrans);\n+        if disposition != mtrans_disposition {\n+            self.tcx.sess.span_err(\n+                attr.span,\n+                &format!(\"expected module named `{}` to be {:?} but is {:?}\",\n+                         mname,\n+                         disposition,\n+                         mtrans_disposition));\n+        }\n+    }\n+\n+    fn disposition(&self, mtrans: &ModuleTranslation) -> Disposition {\n+        match mtrans.source {\n+            ModuleSource::Preexisting(_) => Disposition::Reused,\n+            ModuleSource::Translated(_) => Disposition::Translated,\n+        }\n+    }\n+\n+    fn field(&self, attr: &ast::Attribute, name: &str) -> InternedString {\n+        for item in attr.meta_item_list().unwrap_or(&[]) {\n+            if item.check_name(name) {\n+                if let Some(value) = item.value_str() {\n+                    return value;\n+                } else {\n+                    self.tcx.sess.span_fatal(\n+                        item.span,\n+                        &format!(\"associated value expected for `{}`\", name));\n+                }\n+            }\n+        }\n+\n+        self.tcx.sess.span_fatal(\n+            attr.span,\n+            &format!(\"no field `{}`\", name));\n+    }\n+\n+    /// Scan for a `cfg=\"foo\"` attribute and check whether we have a\n+    /// cfg flag called `foo`.\n+    fn check_config(&self, attr: &ast::Attribute) -> bool {\n+        let config = &self.tcx.map.krate().config;\n+        let value = self.field(attr, CFG);\n+        debug!(\"check_config(config={:?}, value={:?})\", config, value);\n+        if config.iter().any(|c| c.check_name(&value[..])) {\n+            debug!(\"check_config: matched\");\n+            return true;\n+        }\n+        debug!(\"check_config: no match found\");\n+        return false;\n+    }\n+\n+}"}, {"sha": "4b9d5dd9e8d67a2342b4e2333c9187655c700624", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 69, "deletions": 10, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/54c0dcfd634cf31e6c18df5776cab2f3e7870157/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54c0dcfd634cf31e6c18df5776cab2f3e7870157/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=54c0dcfd634cf31e6c18df5776cab2f3e7870157", "patch": "@@ -10,15 +10,17 @@\n \n use back::lto;\n use back::link::{get_linker, remove};\n+use rustc_incremental::save_trans_partition;\n use session::config::{OutputFilenames, Passes, SomePasses, AllPasses};\n use session::Session;\n use session::config::{self, OutputType};\n use llvm;\n use llvm::{ModuleRef, TargetMachineRef, PassManagerRef, DiagnosticInfoRef, ContextRef};\n use llvm::SMDiagnosticRef;\n-use {CrateTranslation, ModuleTranslation};\n+use {CrateTranslation, ModuleLlvm, ModuleSource, ModuleTranslation};\n use util::common::time;\n use util::common::path2cstr;\n+use util::fs::link_or_copy;\n use errors::{self, Handler, Level, DiagnosticBuilder};\n use errors::emitter::Emitter;\n use syntax_pos::MultiSpan;\n@@ -335,6 +337,8 @@ struct CodegenContext<'a> {\n     remark: Passes,\n     // Worker thread number\n     worker: usize,\n+    // Directory where incremental data is stored (if any)\n+    incremental: Option<PathBuf>,\n }\n \n impl<'a> CodegenContext<'a> {\n@@ -345,6 +349,7 @@ impl<'a> CodegenContext<'a> {\n             plugin_passes: sess.plugin_llvm_passes.borrow().clone(),\n             remark: sess.opts.cg.remark.clone(),\n             worker: 0,\n+            incremental: sess.opts.incremental.clone(),\n         }\n     }\n }\n@@ -422,10 +427,11 @@ unsafe extern \"C\" fn diagnostic_handler(info: DiagnosticInfoRef, user: *mut c_vo\n // Unsafe due to LLVM calls.\n unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n                                mtrans: ModuleTranslation,\n+                               mllvm: ModuleLlvm,\n                                config: ModuleConfig,\n                                output_names: OutputFilenames) {\n-    let llmod = mtrans.llmod;\n-    let llcx = mtrans.llcx;\n+    let llmod = mllvm.llmod;\n+    let llcx = mllvm.llcx;\n     let tm = config.tm;\n \n     // llcx doesn't outlive this function, so we can put this on the stack.\n@@ -609,7 +615,7 @@ unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n \n     if copy_bc_to_obj {\n         debug!(\"copying bitcode {:?} to obj {:?}\", bc_out, obj_out);\n-        if let Err(e) = fs::copy(&bc_out, &obj_out) {\n+        if let Err(e) = link_or_copy(&bc_out, &obj_out) {\n             cgcx.handler.err(&format!(\"failed to copy bitcode to object file: {}\", e));\n         }\n     }\n@@ -628,8 +634,14 @@ unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n pub fn cleanup_llvm(trans: &CrateTranslation) {\n     for module in trans.modules.iter() {\n         unsafe {\n-            llvm::LLVMDisposeModule(module.llmod);\n-            llvm::LLVMContextDispose(module.llcx);\n+            match module.source {\n+                ModuleSource::Translated(llvm) => {\n+                    llvm::LLVMDisposeModule(llvm.llmod);\n+                    llvm::LLVMContextDispose(llvm.llcx);\n+                }\n+                ModuleSource::Preexisting(_) => {\n+                }\n+            }\n         }\n     }\n }\n@@ -743,6 +755,23 @@ pub fn run_passes(sess: &Session,\n         run_work_multithreaded(sess, work_items, num_workers);\n     }\n \n+    // If in incr. comp. mode, preserve the `.o` files for potential re-use\n+    for mtrans in trans.modules.iter() {\n+        let mut files = vec![];\n+\n+        if modules_config.emit_obj {\n+            let path = crate_output.temp_path(OutputType::Object, Some(&mtrans.name));\n+            files.push((OutputType::Object, path));\n+        }\n+\n+        if modules_config.emit_bc {\n+            let path = crate_output.temp_path(OutputType::Bitcode, Some(&mtrans.name));\n+            files.push((OutputType::Bitcode, path));\n+        }\n+\n+        save_trans_partition(sess, &mtrans.name, mtrans.symbol_name_hash, &files);\n+    }\n+\n     // All codegen is finished.\n     unsafe {\n         llvm::LLVMRustDisposeTargetMachine(tm);\n@@ -916,10 +945,37 @@ fn build_work_item(sess: &Session,\n fn execute_work_item(cgcx: &CodegenContext,\n                      work_item: WorkItem) {\n     unsafe {\n-        optimize_and_codegen(cgcx,\n-                             work_item.mtrans,\n-                             work_item.config,\n-                             work_item.output_names);\n+        match work_item.mtrans.source {\n+            ModuleSource::Translated(mllvm) => {\n+                debug!(\"llvm-optimizing {:?}\", work_item.mtrans.name);\n+                optimize_and_codegen(cgcx,\n+                                     work_item.mtrans,\n+                                     mllvm,\n+                                     work_item.config,\n+                                     work_item.output_names);\n+            }\n+            ModuleSource::Preexisting(wp) => {\n+                let incremental = cgcx.incremental.as_ref().unwrap();\n+                let name = &work_item.mtrans.name;\n+                for (kind, saved_file) in wp.saved_files {\n+                    let obj_out = work_item.output_names.temp_path(kind, Some(name));\n+                    let source_file = incremental.join(&saved_file);\n+                    debug!(\"copying pre-existing module `{}` from {:?} to {}\",\n+                           work_item.mtrans.name,\n+                           source_file,\n+                           obj_out.display());\n+                    match link_or_copy(&source_file, &obj_out) {\n+                        Ok(()) => { }\n+                        Err(err) => {\n+                            cgcx.handler.err(&format!(\"unable to copy {} to {}: {}\",\n+                                                      source_file.display(),\n+                                                      obj_out.display(),\n+                                                      err));\n+                        }\n+                    }\n+                }\n+            }\n+        }\n     }\n }\n \n@@ -955,6 +1011,8 @@ fn run_work_multithreaded(sess: &Session,\n         let mut tx = Some(tx);\n         futures.push(rx);\n \n+        let incremental = sess.opts.incremental.clone();\n+\n         thread::Builder::new().name(format!(\"codegen-{}\", i)).spawn(move || {\n             let diag_handler = Handler::with_emitter(true, false, box diag_emitter);\n \n@@ -966,6 +1024,7 @@ fn run_work_multithreaded(sess: &Session,\n                 plugin_passes: plugin_passes,\n                 remark: remark,\n                 worker: i,\n+                incremental: incremental,\n             };\n \n             loop {"}, {"sha": "5a19ddff7462af5130a5b909334e19a34f2d22da", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 110, "deletions": 43, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/54c0dcfd634cf31e6c18df5776cab2f3e7870157/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54c0dcfd634cf31e6c18df5776cab2f3e7870157/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=54c0dcfd634cf31e6c18df5776cab2f3e7870157", "patch": "@@ -26,8 +26,11 @@\n #![allow(non_camel_case_types)]\n \n use super::CrateTranslation;\n+use super::ModuleLlvm;\n+use super::ModuleSource;\n use super::ModuleTranslation;\n \n+use assert_module_sources;\n use back::link;\n use back::linker::LinkerInfo;\n use llvm::{BasicBlockRef, Linkage, ValueRef, Vector, get_param};\n@@ -40,7 +43,7 @@ use rustc::ty::subst::{self, Substs};\n use rustc::traits;\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n use rustc::ty::adjustment::CustomCoerceUnsized;\n-use rustc::dep_graph::DepNode;\n+use rustc::dep_graph::{DepNode, WorkProduct};\n use rustc::hir::map as hir_map;\n use rustc::util::common::time;\n use rustc::mir::mir_map::MirMap;\n@@ -2133,7 +2136,7 @@ pub fn maybe_create_entry_wrapper(ccx: &CrateContext) {\n \n     let instance = Instance::mono(ccx.shared(), main_def_id);\n \n-    if !ccx.codegen_unit().items.contains_key(&TransItem::Fn(instance)) {\n+    if !ccx.codegen_unit().contains_item(&TransItem::Fn(instance)) {\n         // We want to create the wrapper in the same codegen unit as Rust's main\n         // function.\n         return;\n@@ -2257,20 +2260,28 @@ fn write_metadata(cx: &SharedCrateContext,\n \n /// Find any symbols that are defined in one compilation unit, but not declared\n /// in any other compilation unit.  Give these symbols internal linkage.\n-fn internalize_symbols<'a, 'tcx>(ccxs: &CrateContextList<'a, 'tcx>,\n+fn internalize_symbols<'a, 'tcx>(sess: &Session,\n+                                 ccxs: &CrateContextList<'a, 'tcx>,\n                                  symbol_map: &SymbolMap<'tcx>,\n                                  reachable: &FnvHashSet<&str>) {\n     let scx = ccxs.shared();\n     let tcx = scx.tcx();\n \n+    // In incr. comp. mode, we can't necessarily see all refs since we\n+    // don't generate LLVM IR for reused modules, so skip this\n+    // step. Later we should get smarter.\n+    if sess.opts.debugging_opts.incremental.is_some() {\n+        return;\n+    }\n+\n     // 'unsafe' because we are holding on to CStr's from the LLVM module within\n     // this block.\n     unsafe {\n         let mut referenced_somewhere = FnvHashSet();\n \n         // Collect all symbols that need to stay externally visible because they\n         // are referenced via a declaration in some other codegen unit.\n-        for ccx in ccxs.iter() {\n+        for ccx in ccxs.iter_need_trans() {\n             for val in iter_globals(ccx.llmod()).chain(iter_functions(ccx.llmod())) {\n                 let linkage = llvm::LLVMGetLinkage(val);\n                 // We only care about external declarations (not definitions)\n@@ -2315,7 +2326,7 @@ fn internalize_symbols<'a, 'tcx>(ccxs: &CrateContextList<'a, 'tcx>,\n         // Examine each external definition.  If the definition is not used in\n         // any other compilation unit, and is not reachable from other crates,\n         // then give it internal linkage.\n-        for ccx in ccxs.iter() {\n+        for ccx in ccxs.iter_need_trans() {\n             for val in iter_globals(ccx.llmod()).chain(iter_functions(ccx.llmod())) {\n                 let linkage = llvm::LLVMGetLinkage(val);\n \n@@ -2362,7 +2373,7 @@ fn create_imps(cx: &CrateContextList) {\n         \"\\x01__imp_\"\n     };\n     unsafe {\n-        for ccx in cx.iter() {\n+        for ccx in cx.iter_need_trans() {\n             let exported: Vec<_> = iter_globals(ccx.llmod())\n                                        .filter(|&val| {\n                                            llvm::LLVMGetLinkage(val) ==\n@@ -2514,8 +2525,11 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     let metadata_module = ModuleTranslation {\n         name: \"metadata\".to_string(),\n-        llcx: shared_ccx.metadata_llcx(),\n-        llmod: shared_ccx.metadata_llmod(),\n+        symbol_name_hash: 0, // we always rebuild metadata, at least for now\n+        source: ModuleSource::Translated(ModuleLlvm {\n+            llcx: shared_ccx.metadata_llcx(),\n+            llmod: shared_ccx.metadata_llmod(),\n+        }),\n     };\n     let no_builtins = attr::contains_name(&krate.attrs, \"no_builtins\");\n \n@@ -2525,17 +2539,34 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     let symbol_map = Rc::new(symbol_map);\n \n+    let previous_work_products = trans_reuse_previous_work_products(tcx,\n+                                                                    &codegen_units,\n+                                                                    &symbol_map);\n+\n     let crate_context_list = CrateContextList::new(&shared_ccx,\n                                                    codegen_units,\n+                                                   previous_work_products,\n                                                    symbol_map.clone());\n-    let modules = crate_context_list.iter()\n-        .map(|ccx| ModuleTranslation {\n-            name: String::from(&ccx.codegen_unit().name[..]),\n-            llcx: ccx.llcx(),\n-            llmod: ccx.llmod()\n+    let modules: Vec<_> = crate_context_list.iter_all()\n+        .map(|ccx| {\n+            let source = match ccx.previous_work_product() {\n+                Some(buf) => ModuleSource::Preexisting(buf.clone()),\n+                None => ModuleSource::Translated(ModuleLlvm {\n+                    llcx: ccx.llcx(),\n+                    llmod: ccx.llmod(),\n+                }),\n+            };\n+\n+            ModuleTranslation {\n+                name: String::from(ccx.codegen_unit().name()),\n+                symbol_name_hash: ccx.codegen_unit().compute_symbol_name_hash(tcx, &symbol_map),\n+                source: source,\n+            }\n         })\n         .collect();\n \n+    assert_module_sources::assert_module_sources(tcx, &modules);\n+\n     // Skip crate items and just output metadata in -Z no-trans mode.\n     if tcx.sess.opts.no_trans {\n         let linker_info = LinkerInfo::new(&shared_ccx, &[]);\n@@ -2551,41 +2582,44 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n \n     // Instantiate translation items without filling out definitions yet...\n-    for ccx in crate_context_list.iter() {\n-        let trans_items = ccx.codegen_unit()\n-                             .items_in_deterministic_order(tcx, &symbol_map);\n+    for ccx in crate_context_list.iter_need_trans() {\n+        let cgu = ccx.codegen_unit();\n+        let trans_items = cgu.items_in_deterministic_order(tcx, &symbol_map);\n \n-        for (trans_item, linkage) in trans_items {\n-            trans_item.predefine(&ccx, linkage);\n-        }\n+        tcx.dep_graph.with_task(cgu.work_product_dep_node(), || {\n+            for (trans_item, linkage) in trans_items {\n+                trans_item.predefine(&ccx, linkage);\n+            }\n+        });\n     }\n \n     // ... and now that we have everything pre-defined, fill out those definitions.\n-    for ccx in crate_context_list.iter() {\n-        let trans_items = ccx.codegen_unit()\n-                             .items_in_deterministic_order(tcx, &symbol_map);\n-\n-        for (trans_item, _) in trans_items {\n-           trans_item.define(&ccx);\n-        }\n+    for ccx in crate_context_list.iter_need_trans() {\n+        let cgu = ccx.codegen_unit();\n+        let trans_items = cgu.items_in_deterministic_order(tcx, &symbol_map);\n+        tcx.dep_graph.with_task(cgu.work_product_dep_node(), || {\n+            for (trans_item, _) in trans_items {\n+                trans_item.define(&ccx);\n+            }\n \n-        // If this codegen unit contains the main function, also create the\n-        // wrapper here\n-        maybe_create_entry_wrapper(&ccx);\n+            // If this codegen unit contains the main function, also create the\n+            // wrapper here\n+            maybe_create_entry_wrapper(&ccx);\n \n-        // Run replace-all-uses-with for statics that need it\n-        for &(old_g, new_g) in ccx.statics_to_rauw().borrow().iter() {\n-            unsafe {\n-                let bitcast = llvm::LLVMConstPointerCast(new_g, llvm::LLVMTypeOf(old_g));\n-                llvm::LLVMReplaceAllUsesWith(old_g, bitcast);\n-                llvm::LLVMDeleteGlobal(old_g);\n+            // Run replace-all-uses-with for statics that need it\n+            for &(old_g, new_g) in ccx.statics_to_rauw().borrow().iter() {\n+                unsafe {\n+                    let bitcast = llvm::LLVMConstPointerCast(new_g, llvm::LLVMTypeOf(old_g));\n+                    llvm::LLVMReplaceAllUsesWith(old_g, bitcast);\n+                    llvm::LLVMDeleteGlobal(old_g);\n+                }\n             }\n-        }\n \n-        // Finalize debuginfo\n-        if ccx.sess().opts.debuginfo != NoDebugInfo {\n-            debuginfo::finalize(&ccx);\n-        }\n+            // Finalize debuginfo\n+            if ccx.sess().opts.debuginfo != NoDebugInfo {\n+                debuginfo::finalize(&ccx);\n+            }\n+        });\n     }\n \n     symbol_names_test::report_symbol_names(&shared_ccx);\n@@ -2654,7 +2688,8 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n \n     time(shared_ccx.sess().time_passes(), \"internalize symbols\", || {\n-        internalize_symbols(&crate_context_list,\n+        internalize_symbols(sess,\n+                            &crate_context_list,\n                             &symbol_map,\n                             &reachable_symbols.iter()\n                                               .map(|s| &s[..])\n@@ -2679,6 +2714,38 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n }\n \n+/// For each CGU, identify if we can reuse an existing object file (or\n+/// maybe other context).\n+fn trans_reuse_previous_work_products(tcx: TyCtxt,\n+                                      codegen_units: &[CodegenUnit],\n+                                      symbol_map: &SymbolMap)\n+                                      -> Vec<Option<WorkProduct>> {\n+    debug!(\"trans_reuse_previous_work_products()\");\n+    codegen_units\n+        .iter()\n+        .map(|cgu| {\n+            let id = cgu.work_product_id();\n+\n+            let hash = cgu.compute_symbol_name_hash(tcx, symbol_map);\n+\n+            debug!(\"trans_reuse_previous_work_products: id={:?} hash={}\", id, hash);\n+\n+            if let Some(work_product) = tcx.dep_graph.previous_work_product(&id) {\n+                if work_product.input_hash == hash {\n+                    debug!(\"trans_reuse_previous_work_products: reusing {:?}\", work_product);\n+                    return Some(work_product);\n+                } else {\n+                    debug!(\"trans_reuse_previous_work_products: \\\n+                            not reusing {:?} because hash changed to {:?}\",\n+                           work_product, hash);\n+                }\n+            }\n+\n+            None\n+        })\n+        .collect()\n+}\n+\n fn collect_and_partition_translation_items<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>)\n                                                      -> (Vec<CodegenUnit<'tcx>>, SymbolMap<'tcx>) {\n     let time_passes = scx.sess().time_passes();\n@@ -2739,10 +2806,10 @@ fn collect_and_partition_translation_items<'a, 'tcx>(scx: &SharedCrateContext<'a\n         let mut item_to_cgus = HashMap::new();\n \n         for cgu in &codegen_units {\n-            for (&trans_item, &linkage) in &cgu.items {\n+            for (&trans_item, &linkage) in cgu.items() {\n                 item_to_cgus.entry(trans_item)\n                             .or_insert(Vec::new())\n-                            .push((cgu.name.clone(), linkage));\n+                            .push((cgu.name().clone(), linkage));\n             }\n         }\n "}, {"sha": "571d2731fb21648be44c087a2541cd892c2945e7", "filename": "src/librustc_trans/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/54c0dcfd634cf31e6c18df5776cab2f3e7870157/src%2Flibrustc_trans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54c0dcfd634cf31e6c18df5776cab2f3e7870157/src%2Flibrustc_trans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fconsts.rs?ref=54c0dcfd634cf31e6c18df5776cab2f3e7870157", "patch": "@@ -1029,7 +1029,7 @@ pub fn get_static<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, def_id: DefId)\n                 assert!(!ccx.external_srcs().borrow().contains_key(&id));\n \n                 let defined_in_current_codegen_unit = ccx.codegen_unit()\n-                                                         .items\n+                                                         .items()\n                                                          .contains_key(&TransItem::Static(id));\n                 if defined_in_current_codegen_unit {\n                     if declare::get_declared_value(ccx, sym).is_none() {"}, {"sha": "a8f8474e94070dc25a0891e52752df9ac3323924", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 53, "deletions": 17, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/54c0dcfd634cf31e6c18df5776cab2f3e7870157/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54c0dcfd634cf31e6c18df5776cab2f3e7870157/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=54c0dcfd634cf31e6c18df5776cab2f3e7870157", "patch": "@@ -10,7 +10,7 @@\n \n use llvm;\n use llvm::{ContextRef, ModuleRef, ValueRef, BuilderRef};\n-use rustc::dep_graph::{DepNode, DepTrackingMap, DepTrackingMapConfig};\n+use rustc::dep_graph::{DepNode, DepTrackingMap, DepTrackingMapConfig, WorkProduct};\n use middle::cstore::LinkMeta;\n use rustc::hir::def::ExportMap;\n use rustc::hir::def_id::DefId;\n@@ -95,6 +95,7 @@ pub struct SharedCrateContext<'a, 'tcx: 'a> {\n pub struct LocalCrateContext<'tcx> {\n     llmod: ModuleRef,\n     llcx: ContextRef,\n+    previous_work_product: Option<WorkProduct>,\n     tn: TypeNames, // FIXME: This seems to be largely unused.\n     codegen_unit: CodegenUnit<'tcx>,\n     needs_unwind_cleanup_cache: RefCell<FnvHashMap<Ty<'tcx>, bool>>,\n@@ -198,24 +199,39 @@ pub struct CrateContextList<'a, 'tcx: 'a> {\n }\n \n impl<'a, 'tcx: 'a> CrateContextList<'a, 'tcx> {\n-\n     pub fn new(shared_ccx: &'a SharedCrateContext<'a, 'tcx>,\n                codegen_units: Vec<CodegenUnit<'tcx>>,\n+               previous_work_products: Vec<Option<WorkProduct>>,\n                symbol_map: Rc<SymbolMap<'tcx>>)\n                -> CrateContextList<'a, 'tcx> {\n         CrateContextList {\n             shared: shared_ccx,\n-            local_ccxs: codegen_units.into_iter().map(|codegen_unit| {\n-                LocalCrateContext::new(shared_ccx, codegen_unit, symbol_map.clone())\n+            local_ccxs: codegen_units.into_iter().zip(previous_work_products).map(|(cgu, wp)| {\n+                LocalCrateContext::new(shared_ccx, cgu, wp, symbol_map.clone())\n             }).collect()\n         }\n     }\n \n-    pub fn iter<'b>(&'b self) -> CrateContextIterator<'b, 'tcx> {\n+    /// Iterate over all crate contexts, whether or not they need\n+    /// translation.  That is, whether or not a `.o` file is available\n+    /// for re-use from a previous incr. comp.).\n+    pub fn iter_all<'b>(&'b self) -> CrateContextIterator<'b, 'tcx> {\n         CrateContextIterator {\n             shared: self.shared,\n             index: 0,\n-            local_ccxs: &self.local_ccxs[..]\n+            local_ccxs: &self.local_ccxs[..],\n+            filter_to_previous_work_product_unavail: false,\n+        }\n+    }\n+\n+    /// Iterator over all CCX that need translation (cannot reuse results from\n+    /// previous incr. comp.).\n+    pub fn iter_need_trans<'b>(&'b self) -> CrateContextIterator<'b, 'tcx> {\n+        CrateContextIterator {\n+            shared: self.shared,\n+            index: 0,\n+            local_ccxs: &self.local_ccxs[..],\n+            filter_to_previous_work_product_unavail: true,\n         }\n     }\n \n@@ -239,24 +255,38 @@ pub struct CrateContextIterator<'a, 'tcx: 'a> {\n     shared: &'a SharedCrateContext<'a, 'tcx>,\n     local_ccxs: &'a [LocalCrateContext<'tcx>],\n     index: usize,\n+\n+    /// if true, only return results where `previous_work_product` is none\n+    filter_to_previous_work_product_unavail: bool,\n }\n \n impl<'a, 'tcx> Iterator for CrateContextIterator<'a,'tcx> {\n     type Item = CrateContext<'a, 'tcx>;\n \n     fn next(&mut self) -> Option<CrateContext<'a, 'tcx>> {\n-        if self.index >= self.local_ccxs.len() {\n-            return None;\n-        }\n+        loop {\n+            if self.index >= self.local_ccxs.len() {\n+                return None;\n+            }\n \n-        let index = self.index;\n-        self.index += 1;\n+            let index = self.index;\n+            self.index += 1;\n \n-        Some(CrateContext {\n-            shared: self.shared,\n-            index: index,\n-            local_ccxs: self.local_ccxs,\n-        })\n+            let ccx = CrateContext {\n+                shared: self.shared,\n+                index: index,\n+                local_ccxs: self.local_ccxs,\n+            };\n+\n+            if\n+                self.filter_to_previous_work_product_unavail &&\n+                ccx.previous_work_product().is_some()\n+            {\n+                continue;\n+            }\n+\n+            return Some(ccx);\n+        }\n     }\n }\n \n@@ -510,6 +540,7 @@ impl<'b, 'tcx> SharedCrateContext<'b, 'tcx> {\n impl<'tcx> LocalCrateContext<'tcx> {\n     fn new<'a>(shared: &SharedCrateContext<'a, 'tcx>,\n                codegen_unit: CodegenUnit<'tcx>,\n+               previous_work_product: Option<WorkProduct>,\n                symbol_map: Rc<SymbolMap<'tcx>>)\n            -> LocalCrateContext<'tcx> {\n         unsafe {\n@@ -521,7 +552,7 @@ impl<'tcx> LocalCrateContext<'tcx> {\n             // crashes if the module identifier is same as other symbols\n             // such as a function name in the module.\n             // 1. http://llvm.org/bugs/show_bug.cgi?id=11479\n-            let llmod_id = format!(\"{}.rs\", codegen_unit.name);\n+            let llmod_id = format!(\"{}.rs\", codegen_unit.name());\n \n             let (llcx, llmod) = create_context_and_module(&shared.tcx.sess,\n                                                           &llmod_id[..]);\n@@ -535,6 +566,7 @@ impl<'tcx> LocalCrateContext<'tcx> {\n             let local_ccx = LocalCrateContext {\n                 llmod: llmod,\n                 llcx: llcx,\n+                previous_work_product: previous_work_product,\n                 codegen_unit: codegen_unit,\n                 tn: TypeNames::new(),\n                 needs_unwind_cleanup_cache: RefCell::new(FnvHashMap()),\n@@ -694,6 +726,10 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         self.local().llcx\n     }\n \n+    pub fn previous_work_product(&self) -> Option<&WorkProduct> {\n+        self.local().previous_work_product.as_ref()\n+    }\n+\n     pub fn codegen_unit(&self) -> &CodegenUnit<'tcx> {\n         &self.local().codegen_unit\n     }"}, {"sha": "6bc48546dfa8c7c9b7b9f4454d0218d7618c8137", "filename": "src/librustc_trans/glue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/54c0dcfd634cf31e6c18df5776cab2f3e7870157/src%2Flibrustc_trans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54c0dcfd634cf31e6c18df5776cab2f3e7870157/src%2Flibrustc_trans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fglue.rs?ref=54c0dcfd634cf31e6c18df5776cab2f3e7870157", "patch": "@@ -239,7 +239,7 @@ fn get_drop_glue_core<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                     Falling back to on-demand instantiation.\",\n                     g,\n                     TransItem::DropGlue(g).to_raw_string(),\n-                    ccx.codegen_unit().name);\n+                    ccx.codegen_unit().name());\n \n             ccx.stats().n_fallback_instantiations.set(ccx.stats()\n                                                          .n_fallback_instantiations"}, {"sha": "81a1dbeb7fe74db7431b49909611326134d1d58c", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/54c0dcfd634cf31e6c18df5776cab2f3e7870157/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54c0dcfd634cf31e6c18df5776cab2f3e7870157/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=54c0dcfd634cf31e6c18df5776cab2f3e7870157", "patch": "@@ -37,6 +37,8 @@\n #![feature(unicode)]\n #![feature(question_mark)]\n \n+use rustc::dep_graph::WorkProduct;\n+\n extern crate arena;\n extern crate flate;\n extern crate getopts;\n@@ -86,6 +88,7 @@ mod macros;\n mod abi;\n mod adt;\n mod asm;\n+mod assert_module_sources;\n mod attributes;\n mod base;\n mod basic_block;\n@@ -132,7 +135,27 @@ mod value;\n \n #[derive(Clone)]\n pub struct ModuleTranslation {\n+    /// The name of the module. When the crate may be saved between\n+    /// compilations, incremental compilation requires that name be\n+    /// unique amongst **all** crates.  Therefore, it should contain\n+    /// something unique to this crate (e.g., a module path) as well\n+    /// as the crate name and disambiguator.\n     pub name: String,\n+    pub symbol_name_hash: u64,\n+    pub source: ModuleSource,\n+}\n+\n+#[derive(Clone)]\n+pub enum ModuleSource {\n+    /// Copy the `.o` files or whatever from the incr. comp. directory.\n+    Preexisting(WorkProduct),\n+\n+    /// Rebuild from this LLVM module.\n+    Translated(ModuleLlvm),\n+}\n+\n+#[derive(Copy, Clone)]\n+pub struct ModuleLlvm {\n     pub llcx: llvm::ContextRef,\n     pub llmod: llvm::ModuleRef,\n }"}, {"sha": "96a05f11bfd119e65fcecc4b9b7a6e7c92bf81b6", "filename": "src/librustc_trans/monomorphize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/54c0dcfd634cf31e6c18df5776cab2f3e7870157/src%2Flibrustc_trans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54c0dcfd634cf31e6c18df5776cab2f3e7870157/src%2Flibrustc_trans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmonomorphize.rs?ref=54c0dcfd634cf31e6c18df5776cab2f3e7870157", "patch": "@@ -52,7 +52,7 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         debug!(\"leaving monomorphic fn {:?}\", instance);\n         return (val, mono_ty);\n     } else {\n-        assert!(!ccx.codegen_unit().items.contains_key(&TransItem::Fn(instance)));\n+        assert!(!ccx.codegen_unit().contains_item(&TransItem::Fn(instance)));\n     }\n \n     debug!(\"monomorphic_fn({:?})\", instance);"}, {"sha": "ade6e8abeb32a5ac07d27eba578131c015c9cac4", "filename": "src/librustc_trans/partitioning.rs", "status": "modified", "additions": 62, "deletions": 22, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/54c0dcfd634cf31e6c18df5776cab2f3e7870157/src%2Flibrustc_trans%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54c0dcfd634cf31e6c18df5776cab2f3e7870157/src%2Flibrustc_trans%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fpartitioning.rs?ref=54c0dcfd634cf31e6c18df5776cab2f3e7870157", "patch": "@@ -119,12 +119,15 @@\n use collector::InliningMap;\n use llvm;\n use monomorphize;\n+use rustc::dep_graph::{DepNode, WorkProductId};\n use rustc::hir::def_id::DefId;\n use rustc::hir::map::DefPathData;\n use rustc::session::config::NUMBERED_CODEGEN_UNIT_MARKER;\n use rustc::ty::TyCtxt;\n use rustc::ty::item_path::characteristic_def_id_of_type;\n use std::cmp::Ordering;\n+use std::hash::{Hash, Hasher, SipHasher};\n+use std::sync::Arc;\n use symbol_map::SymbolMap;\n use syntax::ast::NodeId;\n use syntax::parse::token::{self, InternedString};\n@@ -140,11 +143,59 @@ pub enum PartitioningStrategy {\n }\n \n pub struct CodegenUnit<'tcx> {\n-    pub name: InternedString,\n-    pub items: FnvHashMap<TransItem<'tcx>, llvm::Linkage>,\n+    /// A name for this CGU. Incremental compilation requires that\n+    /// name be unique amongst **all** crates.  Therefore, it should\n+    /// contain something unique to this crate (e.g., a module path)\n+    /// as well as the crate name and disambiguator.\n+    name: InternedString,\n+\n+    items: FnvHashMap<TransItem<'tcx>, llvm::Linkage>,\n }\n \n impl<'tcx> CodegenUnit<'tcx> {\n+    pub fn new(name: InternedString,\n+               items: FnvHashMap<TransItem<'tcx>, llvm::Linkage>)\n+               -> Self {\n+        CodegenUnit {\n+            name: name,\n+            items: items,\n+        }\n+    }\n+\n+    pub fn empty(name: InternedString) -> Self {\n+        Self::new(name, FnvHashMap())\n+    }\n+\n+    pub fn contains_item(&self, item: &TransItem<'tcx>) -> bool {\n+        self.items.contains_key(item)\n+    }\n+\n+    pub fn name(&self) -> &str {\n+        &self.name\n+    }\n+\n+    pub fn items(&self) -> &FnvHashMap<TransItem<'tcx>, llvm::Linkage> {\n+        &self.items\n+    }\n+\n+    pub fn work_product_id(&self) -> Arc<WorkProductId> {\n+        Arc::new(WorkProductId(self.name().to_string()))\n+    }\n+\n+    pub fn work_product_dep_node(&self) -> DepNode<DefId> {\n+        DepNode::WorkProduct(self.work_product_id())\n+    }\n+\n+    pub fn compute_symbol_name_hash(&self, tcx: TyCtxt, symbol_map: &SymbolMap) -> u64 {\n+        let mut state = SipHasher::new();\n+        let all_items = self.items_in_deterministic_order(tcx, symbol_map);\n+        for (item, _) in all_items {\n+            let symbol_name = symbol_map.get(item).unwrap();\n+            symbol_name.hash(&mut state);\n+        }\n+        state.finish()\n+    }\n+\n     pub fn items_in_deterministic_order(&self,\n                                         tcx: TyCtxt,\n                                         symbol_map: &SymbolMap)\n@@ -277,10 +328,7 @@ fn place_root_translation_items<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             };\n \n             let make_codegen_unit = || {\n-                CodegenUnit {\n-                    name: codegen_unit_name.clone(),\n-                    items: FnvHashMap(),\n-                }\n+                CodegenUnit::empty(codegen_unit_name.clone())\n             };\n \n             let mut codegen_unit = codegen_units.entry(codegen_unit_name.clone())\n@@ -319,10 +367,7 @@ fn place_root_translation_items<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     if codegen_units.is_empty() {\n         let codegen_unit_name = InternedString::new(FALLBACK_CODEGEN_UNIT);\n         codegen_units.entry(codegen_unit_name.clone())\n-                     .or_insert_with(|| CodegenUnit {\n-                         name: codegen_unit_name.clone(),\n-                         items: FnvHashMap(),\n-                     });\n+                     .or_insert_with(|| CodegenUnit::empty(codegen_unit_name.clone()));\n     }\n \n     PreInliningPartitioning {\n@@ -362,10 +407,8 @@ fn merge_codegen_units<'tcx>(initial_partitioning: &mut PreInliningPartitioning<\n     // we reach the target count\n     while codegen_units.len() < target_cgu_count {\n         let index = codegen_units.len();\n-        codegen_units.push(CodegenUnit {\n-            name: numbered_codegen_unit_name(crate_name, index),\n-            items: FnvHashMap()\n-        });\n+        codegen_units.push(\n+            CodegenUnit::empty(numbered_codegen_unit_name(crate_name, index)));\n     }\n }\n \n@@ -381,10 +424,8 @@ fn place_inlined_translation_items<'tcx>(initial_partitioning: PreInliningPartit\n             follow_inlining(*root, inlining_map, &mut reachable);\n         }\n \n-        let mut new_codegen_unit = CodegenUnit {\n-            name: codegen_unit.name.clone(),\n-            items: FnvHashMap(),\n-        };\n+        let mut new_codegen_unit =\n+            CodegenUnit::empty(codegen_unit.name.clone());\n \n         // Add all translation items that are not already there\n         for trans_item in reachable {\n@@ -560,10 +601,9 @@ fn single_codegen_unit<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         items.insert(trans_item, linkage);\n     }\n \n-    CodegenUnit {\n-        name: numbered_codegen_unit_name(&tcx.crate_name[..], 0),\n-        items: items\n-    }\n+    CodegenUnit::new(\n+        numbered_codegen_unit_name(&tcx.crate_name[..], 0),\n+        items)\n }\n \n fn numbered_codegen_unit_name(crate_name: &str, index: usize) -> InternedString {"}, {"sha": "fc2758e50f2ce2a2c703db6a7d5a0f88fef5ee4d", "filename": "src/librustc_trans/trans_item.rs", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/54c0dcfd634cf31e6c18df5776cab2f3e7870157/src%2Flibrustc_trans%2Ftrans_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54c0dcfd634cf31e6c18df5776cab2f3e7870157/src%2Flibrustc_trans%2Ftrans_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans_item.rs?ref=54c0dcfd634cf31e6c18df5776cab2f3e7870157", "patch": "@@ -23,12 +23,12 @@ use glue::DropGlueKind;\n use llvm;\n use monomorphize::{self, Instance};\n use inline;\n+use rustc::dep_graph::DepNode;\n use rustc::hir;\n use rustc::hir::map as hir_map;\n use rustc::hir::def_id::DefId;\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n use rustc::ty::subst;\n-use rustc::dep_graph::DepNode;\n use rustc_const_eval::fatal_const_eval_err;\n use std::hash::{Hash, Hasher};\n use syntax::ast::{self, NodeId};\n@@ -68,16 +68,27 @@ impl<'tcx> Hash for TransItem<'tcx> {\n impl<'a, 'tcx> TransItem<'tcx> {\n \n     pub fn define(&self, ccx: &CrateContext<'a, 'tcx>) {\n-\n         debug!(\"BEGIN IMPLEMENTING '{} ({})' in cgu {}\",\n                   self.to_string(ccx.tcx()),\n                   self.to_raw_string(),\n-                  ccx.codegen_unit().name);\n+                  ccx.codegen_unit().name());\n+\n+        // (*) This code executes in the context of a dep-node for the\n+        // entire CGU. In some cases, we introduce dep-nodes for\n+        // particular items that we are translating (these nodes will\n+        // have read edges coming into the CGU node). These smaller\n+        // nodes are not needed for correctness -- we always\n+        // invalidate an entire CGU at a time -- but they enable\n+        // finer-grained testing, since you can write tests that check\n+        // that the incoming edges to a particular fn are from a\n+        // particular set.\n \n         self.register_reads(ccx);\n \n         match *self {\n             TransItem::Static(node_id) => {\n+                let def_id = ccx.tcx().map.local_def_id(node_id);\n+                let _task = ccx.tcx().dep_graph.in_task(DepNode::TransCrateItem(def_id)); // (*)\n                 let item = ccx.tcx().map.expect_item(node_id);\n                 if let hir::ItemStatic(_, m, ref expr) = item.node {\n                     match consts::trans_static(&ccx, m, expr, item.id, &item.attrs) {\n@@ -93,6 +104,9 @@ impl<'a, 'tcx> TransItem<'tcx> {\n                 }\n             }\n             TransItem::Fn(instance) => {\n+                let _task = ccx.tcx().dep_graph.in_task(\n+                    DepNode::TransCrateItem(instance.def)); // (*)\n+\n                 base::trans_instance(&ccx, instance);\n             }\n             TransItem::DropGlue(dg) => {\n@@ -103,7 +117,7 @@ impl<'a, 'tcx> TransItem<'tcx> {\n         debug!(\"END IMPLEMENTING '{} ({})' in cgu {}\",\n                self.to_string(ccx.tcx()),\n                self.to_raw_string(),\n-               ccx.codegen_unit().name);\n+               ccx.codegen_unit().name());\n     }\n \n     /// If necessary, creates a subtask for trans'ing a particular item and registers reads on\n@@ -152,7 +166,7 @@ impl<'a, 'tcx> TransItem<'tcx> {\n         debug!(\"BEGIN PREDEFINING '{} ({})' in cgu {}\",\n                self.to_string(ccx.tcx()),\n                self.to_raw_string(),\n-               ccx.codegen_unit().name);\n+               ccx.codegen_unit().name());\n \n         let symbol_name = ccx.symbol_map()\n                              .get_or_compute(ccx.shared(), *self);\n@@ -174,7 +188,7 @@ impl<'a, 'tcx> TransItem<'tcx> {\n         debug!(\"END PREDEFINING '{} ({})' in cgu {}\",\n                self.to_string(ccx.tcx()),\n                self.to_raw_string(),\n-               ccx.codegen_unit().name);\n+               ccx.codegen_unit().name());\n     }\n \n     fn predefine_static(ccx: &CrateContext<'a, 'tcx>,"}, {"sha": "f80f25a2e776d7c1521233542715417c33ed004b", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/54c0dcfd634cf31e6c18df5776cab2f3e7870157/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54c0dcfd634cf31e6c18df5776cab2f3e7870157/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=54c0dcfd634cf31e6c18df5776cab2f3e7870157", "patch": "@@ -481,6 +481,16 @@ pub const KNOWN_ATTRIBUTES: &'static [(&'static str, AttributeType, AttributeGat\n                                         is just used for rustc unit tests \\\n                                         and will never be stable\",\n                                        cfg_fn!(rustc_attrs))),\n+    (\"rustc_partition_reused\", Whitelisted, Gated(\"rustc_attrs\",\n+                                                  \"this attribute \\\n+                                                   is just used for rustc unit tests \\\n+                                                   and will never be stable\",\n+                                                  cfg_fn!(rustc_attrs))),\n+    (\"rustc_partition_translated\", Whitelisted, Gated(\"rustc_attrs\",\n+                                                      \"this attribute \\\n+                                                       is just used for rustc unit tests \\\n+                                                       and will never be stable\",\n+                                                      cfg_fn!(rustc_attrs))),\n     (\"rustc_symbol_name\", Whitelisted, Gated(\"rustc_attrs\",\n                                              \"internal rustc attributes will never be stable\",\n                                              cfg_fn!(rustc_attrs))),"}, {"sha": "ff5fd634714497bf53a38f11bc1aa323844a5a8c", "filename": "src/test/incremental/rlib_cross_crate/auxiliary/a.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/54c0dcfd634cf31e6c18df5776cab2f3e7870157/src%2Ftest%2Fincremental%2Frlib_cross_crate%2Fauxiliary%2Fa.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54c0dcfd634cf31e6c18df5776cab2f3e7870157/src%2Ftest%2Fincremental%2Frlib_cross_crate%2Fauxiliary%2Fa.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Frlib_cross_crate%2Fauxiliary%2Fa.rs?ref=54c0dcfd634cf31e6c18df5776cab2f3e7870157", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// no-prefer-dynamic\n+\n+#![crate_type=\"rlib\"]\n+\n+#[cfg(rpass1)]\n+pub type X = u32;\n+\n+#[cfg(rpass2)]\n+pub type X = i32;\n+\n+// this version doesn't actually change anything:\n+#[cfg(rpass3)]\n+pub type X = i32;\n+\n+pub type Y = char;"}, {"sha": "55398370425a3bcecedd4b3d0e12a8bee55d73a2", "filename": "src/test/incremental/rlib_cross_crate/b.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/54c0dcfd634cf31e6c18df5776cab2f3e7870157/src%2Ftest%2Fincremental%2Frlib_cross_crate%2Fb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54c0dcfd634cf31e6c18df5776cab2f3e7870157/src%2Ftest%2Fincremental%2Frlib_cross_crate%2Fb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Frlib_cross_crate%2Fb.rs?ref=54c0dcfd634cf31e6c18df5776cab2f3e7870157", "patch": "@@ -0,0 +1,38 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Same test as `type_alias_cross_crate`, but with\n+// `no-prefer-dynamic`, ensuring that we test what happens when we\n+// build rlibs (before we were only testing dylibs, which meant we\n+// didn't realize we had to preserve a `bc` file as well).\n+\n+// aux-build:a.rs\n+// revisions:rpass1 rpass2 rpass3\n+// no-prefer-dynamic\n+\n+\n+#![feature(rustc_attrs)]\n+\n+extern crate a;\n+\n+#[rustc_dirty(label=\"TypeckItemBody\", cfg=\"rpass2\")]\n+#[rustc_clean(label=\"TypeckItemBody\", cfg=\"rpass3\")]\n+pub fn use_X() -> u32 {\n+    let x: a::X = 22;\n+    x as u32\n+}\n+\n+#[rustc_clean(label=\"TypeckItemBody\", cfg=\"rpass2\")]\n+#[rustc_clean(label=\"TypeckItemBody\", cfg=\"rpass3\")]\n+pub fn use_Y() {\n+    let x: a::Y = 'c';\n+}\n+\n+pub fn main() { }"}, {"sha": "b00c68a184ed015765e3384555c229a80ac83e67", "filename": "src/test/incremental/spike-neg1.rs", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/54c0dcfd634cf31e6c18df5776cab2f3e7870157/src%2Ftest%2Fincremental%2Fspike-neg1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54c0dcfd634cf31e6c18df5776cab2f3e7870157/src%2Ftest%2Fincremental%2Fspike-neg1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fspike-neg1.rs?ref=54c0dcfd634cf31e6c18df5776cab2f3e7870157", "patch": "@@ -0,0 +1,62 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// A variant of the first \"spike\" test that serves to test the\n+// `rustc_partition_reused` and `rustc_partition_translated` tests.\n+// Here we change and say that the `x` module will be reused (when in\n+// fact it will not), and then indicate that the test itself\n+// should-fail (because an error will be reported, and hence the\n+// revision rpass2 will not compile, despite being named rpass).\n+\n+// revisions:rpass1 rpass2\n+// should-fail\n+\n+#![feature(rustc_attrs)]\n+\n+#![rustc_partition_reused(module=\"spike_neg1\", cfg=\"rpass2\")]\n+#![rustc_partition_reused(module=\"spike_neg1-x\", cfg=\"rpass2\")] // this is wrong!\n+#![rustc_partition_reused(module=\"spike_neg1-y\", cfg=\"rpass2\")]\n+\n+mod x {\n+    pub struct X {\n+        x: u32, y: u32,\n+    }\n+\n+    #[cfg(rpass1)]\n+    fn make() -> X {\n+        X { x: 22, y: 0 }\n+    }\n+\n+    #[cfg(rpass2)]\n+    fn make() -> X {\n+        X { x: 11, y: 11 }\n+    }\n+\n+    pub fn new() -> X {\n+        make()\n+    }\n+\n+    pub fn sum(x: &X) -> u32 {\n+        x.x + x.y\n+    }\n+}\n+\n+mod y {\n+    use x;\n+\n+    pub fn assert_sum() -> bool {\n+        let x = x::new();\n+        x::sum(&x) == 22\n+    }\n+}\n+\n+pub fn main() {\n+    y::assert_sum();\n+}"}, {"sha": "472d11d7f90286b1b6066529e58cbda0d8f16162", "filename": "src/test/incremental/spike-neg2.rs", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/54c0dcfd634cf31e6c18df5776cab2f3e7870157/src%2Ftest%2Fincremental%2Fspike-neg2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54c0dcfd634cf31e6c18df5776cab2f3e7870157/src%2Ftest%2Fincremental%2Fspike-neg2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fspike-neg2.rs?ref=54c0dcfd634cf31e6c18df5776cab2f3e7870157", "patch": "@@ -0,0 +1,62 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// A variant of the first \"spike\" test that serves to test the\n+// `rustc_partition_reused` and `rustc_partition_translated` tests.\n+// Here we change and say that the `y` module will be translated (when\n+// in fact it will not), and then indicate that the test itself\n+// should-fail (because an error will be reported, and hence the\n+// revision rpass2 will not compile, despite being named rpass).\n+\n+// revisions:rpass1 rpass2\n+// should-fail\n+\n+#![feature(rustc_attrs)]\n+\n+#![rustc_partition_reused(module=\"spike_neg2\", cfg=\"rpass2\")]\n+#![rustc_partition_translated(module=\"spike_neg2-x\", cfg=\"rpass2\")]\n+#![rustc_partition_translated(module=\"spike_neg2-y\", cfg=\"rpass2\")] // this is wrong!\n+\n+mod x {\n+    pub struct X {\n+        x: u32, y: u32,\n+    }\n+\n+    #[cfg(rpass1)]\n+    fn make() -> X {\n+        X { x: 22, y: 0 }\n+    }\n+\n+    #[cfg(rpass2)]\n+    fn make() -> X {\n+        X { x: 11, y: 11 }\n+    }\n+\n+    pub fn new() -> X {\n+        make()\n+    }\n+\n+    pub fn sum(x: &X) -> u32 {\n+        x.x + x.y\n+    }\n+}\n+\n+mod y {\n+    use x;\n+\n+    pub fn assert_sum() -> bool {\n+        let x = x::new();\n+        x::sum(&x) == 22\n+    }\n+}\n+\n+pub fn main() {\n+    y::assert_sum();\n+}"}, {"sha": "68af20d41915159dcc778d9e028c50e1589567e5", "filename": "src/test/incremental/spike.rs", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/54c0dcfd634cf31e6c18df5776cab2f3e7870157/src%2Ftest%2Fincremental%2Fspike.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54c0dcfd634cf31e6c18df5776cab2f3e7870157/src%2Ftest%2Fincremental%2Fspike.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fspike.rs?ref=54c0dcfd634cf31e6c18df5776cab2f3e7870157", "patch": "@@ -0,0 +1,63 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// A first \"spike\" for incremental compilation: here, we change the\n+// content of the `make` function, and we find that we can reuse the\n+// `y` module entirely (but not the `x` module).\n+\n+// revisions:rpass1 rpass2\n+\n+#![feature(rustc_attrs)]\n+\n+#![rustc_partition_reused(module=\"spike\", cfg=\"rpass2\")]\n+#![rustc_partition_translated(module=\"spike-x\", cfg=\"rpass2\")]\n+#![rustc_partition_reused(module=\"spike-y\", cfg=\"rpass2\")]\n+\n+mod x {\n+    pub struct X {\n+        x: u32, y: u32,\n+    }\n+\n+    #[cfg(rpass1)]\n+    fn make() -> X {\n+        X { x: 22, y: 0 }\n+    }\n+\n+    #[cfg(rpass2)]\n+    fn make() -> X {\n+        X { x: 11, y: 11 }\n+    }\n+\n+    #[rustc_dirty(label=\"TypeckItemBody\", cfg=\"rpass2\")]\n+    #[rustc_clean(label=\"ItemSignature\", cfg=\"rpass2\")]\n+    pub fn new() -> X {\n+        make()\n+    }\n+\n+    #[rustc_clean(label=\"TypeckItemBody\", cfg=\"rpass2\")]\n+    #[rustc_clean(label=\"ItemSignature\", cfg=\"rpass2\")]\n+    pub fn sum(x: &X) -> u32 {\n+        x.x + x.y\n+    }\n+}\n+\n+mod y {\n+    use x;\n+\n+    #[rustc_clean(label=\"TypeckItemBody\", cfg=\"rpass2\")]\n+    pub fn assert_sum() -> bool {\n+        let x = x::new();\n+        x::sum(&x) == 22\n+    }\n+}\n+\n+pub fn main() {\n+    y::assert_sum();\n+}"}, {"sha": "b58295d47f21d2633160a79b350e378db8b43d09", "filename": "src/test/run-make/execution-engine/test.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/54c0dcfd634cf31e6c18df5776cab2f3e7870157/src%2Ftest%2Frun-make%2Fexecution-engine%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54c0dcfd634cf31e6c18df5776cab2f3e7870157/src%2Ftest%2Frun-make%2Fexecution-engine%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fexecution-engine%2Ftest.rs?ref=54c0dcfd634cf31e6c18df5776cab2f3e7870157", "patch": "@@ -20,6 +20,7 @@ extern crate rustc_metadata;\n extern crate rustc_resolve;\n extern crate rustc_errors;\n extern crate rustc_errors as errors;\n+extern crate rustc_trans;\n #[macro_use] extern crate syntax;\n \n use std::ffi::{CStr, CString};\n@@ -37,6 +38,7 @@ use rustc::session::build_session;\n use rustc_driver::{driver, abort_on_err};\n use rustc_resolve::MakeGlobMap;\n use rustc_metadata::cstore::CStore;\n+use rustc_trans::ModuleSource;\n use libc::c_void;\n \n use rustc_errors::registry::Registry;\n@@ -261,7 +263,10 @@ fn compile_program(input: &str, sysroot: PathBuf)\n                 .filter_map(|(_, p)| p).collect();\n \n             assert_eq!(trans.modules.len(), 1);\n-            let llmod = trans.modules[0].llmod;\n+            let llmod = match trans.modules[0].source {\n+                ModuleSource::Preexisting(_) => unimplemented!(),\n+                ModuleSource::Translated(llvm) => llvm.llmod,\n+            };\n \n             // Workaround because raw pointers do not impl Send\n             let modp = llmod as usize;"}, {"sha": "19e410fef538821dad9b6c7ff9d1b8422a7661d2", "filename": "src/test/run-make/llvm-phase/test.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/54c0dcfd634cf31e6c18df5776cab2f3e7870157/src%2Ftest%2Frun-make%2Fllvm-phase%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/54c0dcfd634cf31e6c18df5776cab2f3e7870157/src%2Ftest%2Frun-make%2Fllvm-phase%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fllvm-phase%2Ftest.rs?ref=54c0dcfd634cf31e6c18df5776cab2f3e7870157", "patch": "@@ -13,11 +13,13 @@\n extern crate rustc;\n extern crate rustc_driver;\n extern crate rustc_llvm;\n+extern crate rustc_trans;\n #[macro_use] extern crate syntax;\n extern crate getopts;\n \n use rustc_driver::{CompilerCalls, Compilation};\n use rustc_driver::driver::CompileController;\n+use rustc_trans::ModuleSource;\n use rustc::session::Session;\n use syntax::codemap::FileLoader;\n use std::io;\n@@ -51,7 +53,10 @@ impl<'a> CompilerCalls<'a> for JitCalls {\n             state.session.abort_if_errors();\n             let trans = state.trans.unwrap();\n             assert_eq!(trans.modules.len(), 1);\n-            let rs_llmod = trans.modules[0].llmod;\n+            let rs_llmod = match trans.modules[0].source {\n+                ModuleSource::Preexisting(_) => unimplemented!(),\n+                ModuleSource::Translated(llvm) => llvm.llmod,\n+            };\n             unsafe { rustc_llvm::LLVMDumpModule(rs_llmod) };\n         });\n         cc"}]}