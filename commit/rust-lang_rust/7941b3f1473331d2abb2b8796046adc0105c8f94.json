{"sha": "7941b3f1473331d2abb2b8796046adc0105c8f94", "node_id": "C_kwDOAAsO6NoAKDc5NDFiM2YxNDczMzMxZDJhYmIyYjg3OTYwNDZhZGMwMTA1YzhmOTQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-03-24T22:52:34Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-03-24T22:52:34Z"}, "message": "Auto merge of #95273 - flip1995:clippyup, r=manishearth\n\nUpdate Clippy\n\nr? `@Manishearth`", "tree": {"sha": "428f63a02ce82dd70c97a70b7bd596cbd502aeed", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/428f63a02ce82dd70c97a70b7bd596cbd502aeed"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7941b3f1473331d2abb2b8796046adc0105c8f94", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7941b3f1473331d2abb2b8796046adc0105c8f94", "html_url": "https://github.com/rust-lang/rust/commit/7941b3f1473331d2abb2b8796046adc0105c8f94", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7941b3f1473331d2abb2b8796046adc0105c8f94/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "63b8f01bb5ca277e7df8d7efe094ed4244c1790c", "url": "https://api.github.com/repos/rust-lang/rust/commits/63b8f01bb5ca277e7df8d7efe094ed4244c1790c", "html_url": "https://github.com/rust-lang/rust/commit/63b8f01bb5ca277e7df8d7efe094ed4244c1790c"}, {"sha": "3365e9a120fcce6994a95ecc324a6c911b2a1403", "url": "https://api.github.com/repos/rust-lang/rust/commits/3365e9a120fcce6994a95ecc324a6c911b2a1403", "html_url": "https://github.com/rust-lang/rust/commit/3365e9a120fcce6994a95ecc324a6c911b2a1403"}], "stats": {"total": 2503, "additions": 1957, "deletions": 546}, "files": [{"sha": "b6f70a7f18300227ce4cf88379d2231813c98f1b", "filename": "src/tools/clippy/.github/ISSUE_TEMPLATE/bug_report.yml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7941b3f1473331d2abb2b8796046adc0105c8f94/src%2Ftools%2Fclippy%2F.github%2FISSUE_TEMPLATE%2Fbug_report.yml", "raw_url": "https://github.com/rust-lang/rust/raw/7941b3f1473331d2abb2b8796046adc0105c8f94/src%2Ftools%2Fclippy%2F.github%2FISSUE_TEMPLATE%2Fbug_report.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2F.github%2FISSUE_TEMPLATE%2Fbug_report.yml?ref=7941b3f1473331d2abb2b8796046adc0105c8f94", "patch": "@@ -18,7 +18,7 @@ body:\n     id: reproducer\n     attributes:\n       label: Reproducer\n-      description: Please provide the code and steps to repoduce the bug\n+      description: Please provide the code and steps to reproduce the bug\n       value: |\n         I tried this code:\n "}, {"sha": "88f71931d92b58432cfaa4e003422562bf9de0c0", "filename": "src/tools/clippy/CHANGELOG.md", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7941b3f1473331d2abb2b8796046adc0105c8f94/src%2Ftools%2Fclippy%2FCHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/7941b3f1473331d2abb2b8796046adc0105c8f94/src%2Ftools%2Fclippy%2FCHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2FCHANGELOG.md?ref=7941b3f1473331d2abb2b8796046adc0105c8f94", "patch": "@@ -3069,6 +3069,7 @@ Released 2018-09-13\n [`bytes_nth`]: https://rust-lang.github.io/rust-clippy/master/index.html#bytes_nth\n [`cargo_common_metadata`]: https://rust-lang.github.io/rust-clippy/master/index.html#cargo_common_metadata\n [`case_sensitive_file_extension_comparisons`]: https://rust-lang.github.io/rust-clippy/master/index.html#case_sensitive_file_extension_comparisons\n+[`cast_enum_constructor`]: https://rust-lang.github.io/rust-clippy/master/index.html#cast_enum_constructor\n [`cast_enum_truncation`]: https://rust-lang.github.io/rust-clippy/master/index.html#cast_enum_truncation\n [`cast_lossless`]: https://rust-lang.github.io/rust-clippy/master/index.html#cast_lossless\n [`cast_possible_truncation`]: https://rust-lang.github.io/rust-clippy/master/index.html#cast_possible_truncation\n@@ -3366,6 +3367,7 @@ Released 2018-09-13\n [`option_map_unit_fn`]: https://rust-lang.github.io/rust-clippy/master/index.html#option_map_unit_fn\n [`option_option`]: https://rust-lang.github.io/rust-clippy/master/index.html#option_option\n [`or_fun_call`]: https://rust-lang.github.io/rust-clippy/master/index.html#or_fun_call\n+[`or_then_unwrap`]: https://rust-lang.github.io/rust-clippy/master/index.html#or_then_unwrap\n [`out_of_bounds_indexing`]: https://rust-lang.github.io/rust-clippy/master/index.html#out_of_bounds_indexing\n [`overflow_check_conditional`]: https://rust-lang.github.io/rust-clippy/master/index.html#overflow_check_conditional\n [`panic`]: https://rust-lang.github.io/rust-clippy/master/index.html#panic\n@@ -3506,6 +3508,7 @@ Released 2018-09-13\n [`unnecessary_filter_map`]: https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_filter_map\n [`unnecessary_find_map`]: https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_find_map\n [`unnecessary_fold`]: https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_fold\n+[`unnecessary_join`]: https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_join\n [`unnecessary_lazy_evaluations`]: https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_lazy_evaluations\n [`unnecessary_mut_passed`]: https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_mut_passed\n [`unnecessary_operation`]: https://rust-lang.github.io/rust-clippy/master/index.html#unnecessary_operation"}, {"sha": "1973692e105f74050c0d191185667111aefcd061", "filename": "src/tools/clippy/clippy_lints/src/casts/cast_enum_constructor.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/7941b3f1473331d2abb2b8796046adc0105c8f94/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Fcast_enum_constructor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7941b3f1473331d2abb2b8796046adc0105c8f94/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Fcast_enum_constructor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Fcast_enum_constructor.rs?ref=7941b3f1473331d2abb2b8796046adc0105c8f94", "patch": "@@ -0,0 +1,21 @@\n+use clippy_utils::diagnostics::span_lint;\n+use rustc_hir::def::{CtorKind, CtorOf, DefKind, Res};\n+use rustc_hir::{Expr, ExprKind};\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::{self, Ty};\n+\n+use super::CAST_ENUM_CONSTRUCTOR;\n+\n+pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>, cast_expr: &Expr<'_>, cast_from: Ty<'_>) {\n+    if matches!(cast_from.kind(), ty::FnDef(..))\n+        && let ExprKind::Path(path) = &cast_expr.kind\n+        && let Res::Def(DefKind::Ctor(CtorOf::Variant, CtorKind::Fn), _) = cx.qpath_res(path, cast_expr.hir_id)\n+    {\n+        span_lint(\n+            cx,\n+            CAST_ENUM_CONSTRUCTOR,\n+            expr.span,\n+            \"cast of an enum tuple constructor to an integer\",\n+        );\n+    }\n+}"}, {"sha": "be59145afa0032a3cd7c8882c770dd48f4a53288", "filename": "src/tools/clippy/clippy_lints/src/casts/mod.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/7941b3f1473331d2abb2b8796046adc0105c8f94/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7941b3f1473331d2abb2b8796046adc0105c8f94/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Fmod.rs?ref=7941b3f1473331d2abb2b8796046adc0105c8f94", "patch": "@@ -1,3 +1,4 @@\n+mod cast_enum_constructor;\n mod cast_lossless;\n mod cast_possible_truncation;\n mod cast_possible_wrap;\n@@ -454,6 +455,24 @@ declare_clippy_lint! {\n     \"casting using `as` between raw pointers to slices of types with different sizes\"\n }\n \n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for casts from an enum tuple constructor to an integer.\n+    ///\n+    /// ### Why is this bad?\n+    /// The cast is easily confused with casting a c-like enum value to an integer.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// enum E { X(i32) };\n+    /// let _ = E::X as usize;\n+    /// ```\n+    #[clippy::version = \"1.61.0\"]\n+    pub CAST_ENUM_CONSTRUCTOR,\n+    suspicious,\n+    \"casts from an enum tuple constructor to an integer\"\n+}\n+\n pub struct Casts {\n     msrv: Option<RustcVersion>,\n }\n@@ -481,6 +500,7 @@ impl_lint_pass!(Casts => [\n     CHAR_LIT_AS_U8,\n     PTR_AS_PTR,\n     CAST_ENUM_TRUNCATION,\n+    CAST_ENUM_CONSTRUCTOR\n ]);\n \n impl<'tcx> LateLintPass<'tcx> for Casts {\n@@ -518,6 +538,7 @@ impl<'tcx> LateLintPass<'tcx> for Casts {\n                     cast_sign_loss::check(cx, expr, cast_expr, cast_from, cast_to);\n                 }\n                 cast_lossless::check(cx, expr, cast_expr, cast_from, cast_to, &self.msrv);\n+                cast_enum_constructor::check(cx, expr, cast_expr, cast_from);\n             }\n         }\n "}, {"sha": "eae2723a7dac1f60ea6e1282a8385e8ae07166ec", "filename": "src/tools/clippy/clippy_lints/src/collapsible_if.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7941b3f1473331d2abb2b8796046adc0105c8f94/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcollapsible_if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7941b3f1473331d2abb2b8796046adc0105c8f94/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcollapsible_if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcollapsible_if.rs?ref=7941b3f1473331d2abb2b8796046adc0105c8f94", "patch": "@@ -42,7 +42,7 @@ declare_clippy_lint! {\n     ///\n     /// Should be written:\n     ///\n-    /// ```rust.ignore\n+    /// ```rust,ignore\n     /// if x && y {\n     ///     \u2026\n     /// }\n@@ -76,7 +76,7 @@ declare_clippy_lint! {\n     ///\n     /// Should be written:\n     ///\n-    /// ```rust.ignore\n+    /// ```rust,ignore\n     /// if x {\n     ///     \u2026\n     /// } else if y {"}, {"sha": "703aa458f44e5a074ac0cd3a1cc33b1573444223", "filename": "src/tools/clippy/clippy_lints/src/doc.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7941b3f1473331d2abb2b8796046adc0105c8f94/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7941b3f1473331d2abb2b8796046adc0105c8f94/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdoc.rs?ref=7941b3f1473331d2abb2b8796046adc0105c8f94", "patch": "@@ -637,12 +637,6 @@ fn check_code(cx: &LateContext<'_>, text: &str, edition: Edition, span: Span) {\n                 loop {\n                     match parser.parse_item(ForceCollect::No) {\n                         Ok(Some(item)) => match &item.kind {\n-                            // Tests with one of these items are ignored\n-                            ItemKind::Static(..)\n-                            | ItemKind::Const(..)\n-                            | ItemKind::ExternCrate(..)\n-                            | ItemKind::ForeignMod(..) => return false,\n-                            // We found a main function ...\n                             ItemKind::Fn(box Fn {\n                                 sig, body: Some(block), ..\n                             }) if item.ident.name == sym::main => {\n@@ -661,8 +655,13 @@ fn check_code(cx: &LateContext<'_>, text: &str, edition: Edition, span: Span) {\n                                     return false;\n                                 }\n                             },\n-                            // Another function was found; this case is ignored too\n-                            ItemKind::Fn(..) => return false,\n+                            // Tests with one of these items are ignored\n+                            ItemKind::Static(..)\n+                            | ItemKind::Const(..)\n+                            | ItemKind::ExternCrate(..)\n+                            | ItemKind::ForeignMod(..)\n+                            // Another function was found; this case is ignored\n+                            | ItemKind::Fn(..) => return false,\n                             _ => {},\n                         },\n                         Ok(None) => break,"}, {"sha": "132a466267626e51fd6b0444e0e48763db3880d5", "filename": "src/tools/clippy/clippy_lints/src/lib.register_all.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7941b3f1473331d2abb2b8796046adc0105c8f94/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_all.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7941b3f1473331d2abb2b8796046adc0105c8f94/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_all.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_all.rs?ref=7941b3f1473331d2abb2b8796046adc0105c8f94", "patch": "@@ -23,6 +23,7 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(bool_assert_comparison::BOOL_ASSERT_COMPARISON),\n     LintId::of(booleans::LOGIC_BUG),\n     LintId::of(booleans::NONMINIMAL_BOOL),\n+    LintId::of(casts::CAST_ENUM_CONSTRUCTOR),\n     LintId::of(casts::CAST_ENUM_TRUNCATION),\n     LintId::of(casts::CAST_REF_TO_MUT),\n     LintId::of(casts::CAST_SLICE_DIFFERENT_SIZES),\n@@ -166,7 +167,6 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(methods::ITER_NTH_ZERO),\n     LintId::of(methods::ITER_OVEREAGER_CLONED),\n     LintId::of(methods::ITER_SKIP_NEXT),\n-    LintId::of(methods::ITER_WITH_DRAIN),\n     LintId::of(methods::MANUAL_FILTER_MAP),\n     LintId::of(methods::MANUAL_FIND_MAP),\n     LintId::of(methods::MANUAL_SATURATING_ARITHMETIC),\n@@ -182,6 +182,7 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(methods::OPTION_FILTER_MAP),\n     LintId::of(methods::OPTION_MAP_OR_NONE),\n     LintId::of(methods::OR_FUN_CALL),\n+    LintId::of(methods::OR_THEN_UNWRAP),\n     LintId::of(methods::RESULT_MAP_OR_INTO_OPTION),\n     LintId::of(methods::SEARCH_IS_SOME),\n     LintId::of(methods::SHOULD_IMPLEMENT_TRAIT),\n@@ -290,7 +291,6 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(transmute::UNSOUND_COLLECTION_TRANSMUTE),\n     LintId::of(transmute::WRONG_TRANSMUTE),\n     LintId::of(transmuting_null::TRANSMUTING_NULL),\n-    LintId::of(try_err::TRY_ERR),\n     LintId::of(types::BORROWED_BOX),\n     LintId::of(types::BOX_COLLECTION),\n     LintId::of(types::REDUNDANT_ALLOCATION),"}, {"sha": "a2ce69065f94d47685a1c47f1fa8deb01ecbc05b", "filename": "src/tools/clippy/clippy_lints/src/lib.register_complexity.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7941b3f1473331d2abb2b8796046adc0105c8f94/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_complexity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7941b3f1473331d2abb2b8796046adc0105c8f94/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_complexity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_complexity.rs?ref=7941b3f1473331d2abb2b8796046adc0105c8f94", "patch": "@@ -47,6 +47,7 @@ store.register_group(true, \"clippy::complexity\", Some(\"clippy_complexity\"), vec!\n     LintId::of(methods::NEEDLESS_SPLITN),\n     LintId::of(methods::OPTION_AS_REF_DEREF),\n     LintId::of(methods::OPTION_FILTER_MAP),\n+    LintId::of(methods::OR_THEN_UNWRAP),\n     LintId::of(methods::SEARCH_IS_SOME),\n     LintId::of(methods::SKIP_WHILE_NEXT),\n     LintId::of(methods::UNNECESSARY_FILTER_MAP),"}, {"sha": "21f1ef562b5a31482c01c3a56af620d9450e2ad4", "filename": "src/tools/clippy/clippy_lints/src/lib.register_lints.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7941b3f1473331d2abb2b8796046adc0105c8f94/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7941b3f1473331d2abb2b8796046adc0105c8f94/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_lints.rs?ref=7941b3f1473331d2abb2b8796046adc0105c8f94", "patch": "@@ -70,6 +70,7 @@ store.register_lints(&[\n     cargo::REDUNDANT_FEATURE_NAMES,\n     cargo::WILDCARD_DEPENDENCIES,\n     case_sensitive_file_extension_comparisons::CASE_SENSITIVE_FILE_EXTENSION_COMPARISONS,\n+    casts::CAST_ENUM_CONSTRUCTOR,\n     casts::CAST_ENUM_TRUNCATION,\n     casts::CAST_LOSSLESS,\n     casts::CAST_POSSIBLE_TRUNCATION,\n@@ -319,6 +320,7 @@ store.register_lints(&[\n     methods::OPTION_FILTER_MAP,\n     methods::OPTION_MAP_OR_NONE,\n     methods::OR_FUN_CALL,\n+    methods::OR_THEN_UNWRAP,\n     methods::RESULT_MAP_OR_INTO_OPTION,\n     methods::SEARCH_IS_SOME,\n     methods::SHOULD_IMPLEMENT_TRAIT,\n@@ -332,6 +334,7 @@ store.register_lints(&[\n     methods::UNNECESSARY_FILTER_MAP,\n     methods::UNNECESSARY_FIND_MAP,\n     methods::UNNECESSARY_FOLD,\n+    methods::UNNECESSARY_JOIN,\n     methods::UNNECESSARY_LAZY_EVALUATIONS,\n     methods::UNNECESSARY_TO_OWNED,\n     methods::UNWRAP_OR_ELSE_DEFAULT,"}, {"sha": "c2fc67afba517f4447d33df8bfc5d504015f6c77", "filename": "src/tools/clippy/clippy_lints/src/lib.register_nursery.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7941b3f1473331d2abb2b8796046adc0105c8f94/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_nursery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7941b3f1473331d2abb2b8796046adc0105c8f94/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_nursery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_nursery.rs?ref=7941b3f1473331d2abb2b8796046adc0105c8f94", "patch": "@@ -13,6 +13,7 @@ store.register_group(true, \"clippy::nursery\", Some(\"clippy_nursery\"), vec![\n     LintId::of(future_not_send::FUTURE_NOT_SEND),\n     LintId::of(index_refutable_slice::INDEX_REFUTABLE_SLICE),\n     LintId::of(let_if_seq::USELESS_LET_IF_SEQ),\n+    LintId::of(methods::ITER_WITH_DRAIN),\n     LintId::of(missing_const_for_fn::MISSING_CONST_FOR_FN),\n     LintId::of(mutable_debug_assertion::DEBUG_ASSERT_WITH_MUT_CALL),\n     LintId::of(mutex_atomic::MUTEX_ATOMIC),"}, {"sha": "eb6534cb8cae761433a0a979ff932f78d063f5a7", "filename": "src/tools/clippy/clippy_lints/src/lib.register_pedantic.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7941b3f1473331d2abb2b8796046adc0105c8f94/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_pedantic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7941b3f1473331d2abb2b8796046adc0105c8f94/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_pedantic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_pedantic.rs?ref=7941b3f1473331d2abb2b8796046adc0105c8f94", "patch": "@@ -63,6 +63,7 @@ store.register_group(true, \"clippy::pedantic\", Some(\"clippy_pedantic\"), vec![\n     LintId::of(methods::IMPLICIT_CLONE),\n     LintId::of(methods::INEFFICIENT_TO_STRING),\n     LintId::of(methods::MAP_UNWRAP_OR),\n+    LintId::of(methods::UNNECESSARY_JOIN),\n     LintId::of(misc::FLOAT_CMP),\n     LintId::of(misc::USED_UNDERSCORE_BINDING),\n     LintId::of(mut_mut::MUT_MUT),"}, {"sha": "f2f5c988d8f9056b557e05ac61e43287b01ef2d6", "filename": "src/tools/clippy/clippy_lints/src/lib.register_perf.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7941b3f1473331d2abb2b8796046adc0105c8f94/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_perf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7941b3f1473331d2abb2b8796046adc0105c8f94/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_perf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_perf.rs?ref=7941b3f1473331d2abb2b8796046adc0105c8f94", "patch": "@@ -16,7 +16,6 @@ store.register_group(true, \"clippy::perf\", Some(\"clippy_perf\"), vec![\n     LintId::of(methods::EXTEND_WITH_DRAIN),\n     LintId::of(methods::ITER_NTH),\n     LintId::of(methods::ITER_OVEREAGER_CLONED),\n-    LintId::of(methods::ITER_WITH_DRAIN),\n     LintId::of(methods::MANUAL_STR_REPEAT),\n     LintId::of(methods::OR_FUN_CALL),\n     LintId::of(methods::SINGLE_CHAR_PATTERN),"}, {"sha": "6ab139b2fb67b551a80d88a6cf17638111539f01", "filename": "src/tools/clippy/clippy_lints/src/lib.register_restriction.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7941b3f1473331d2abb2b8796046adc0105c8f94/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_restriction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7941b3f1473331d2abb2b8796046adc0105c8f94/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_restriction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_restriction.rs?ref=7941b3f1473331d2abb2b8796046adc0105c8f94", "patch": "@@ -62,6 +62,7 @@ store.register_group(true, \"clippy::restriction\", Some(\"clippy_restriction\"), ve\n     LintId::of(strings::STRING_SLICE),\n     LintId::of(strings::STRING_TO_STRING),\n     LintId::of(strings::STR_TO_STRING),\n+    LintId::of(try_err::TRY_ERR),\n     LintId::of(types::RC_BUFFER),\n     LintId::of(types::RC_MUTEX),\n     LintId::of(undocumented_unsafe_blocks::UNDOCUMENTED_UNSAFE_BLOCKS),"}, {"sha": "dcf399cf9562f3d7c814b8b04b75b2299d336fab", "filename": "src/tools/clippy/clippy_lints/src/lib.register_style.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7941b3f1473331d2abb2b8796046adc0105c8f94/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7941b3f1473331d2abb2b8796046adc0105c8f94/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_style.rs?ref=7941b3f1473331d2abb2b8796046adc0105c8f94", "patch": "@@ -105,7 +105,6 @@ store.register_group(true, \"clippy::style\", Some(\"clippy_style\"), vec![\n     LintId::of(single_component_path_imports::SINGLE_COMPONENT_PATH_IMPORTS),\n     LintId::of(tabs_in_doc_comments::TABS_IN_DOC_COMMENTS),\n     LintId::of(to_digit_is_some::TO_DIGIT_IS_SOME),\n-    LintId::of(try_err::TRY_ERR),\n     LintId::of(unsafe_removed_from_name::UNSAFE_REMOVED_FROM_NAME),\n     LintId::of(unused_unit::UNUSED_UNIT),\n     LintId::of(upper_case_acronyms::UPPER_CASE_ACRONYMS),"}, {"sha": "fa3a88e1368ce5cde3ff9aee911e993d4231c604", "filename": "src/tools/clippy/clippy_lints/src/lib.register_suspicious.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7941b3f1473331d2abb2b8796046adc0105c8f94/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_suspicious.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7941b3f1473331d2abb2b8796046adc0105c8f94/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_suspicious.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.register_suspicious.rs?ref=7941b3f1473331d2abb2b8796046adc0105c8f94", "patch": "@@ -7,6 +7,7 @@ store.register_group(true, \"clippy::suspicious\", Some(\"clippy_suspicious\"), vec!\n     LintId::of(attrs::BLANKET_CLIPPY_RESTRICTION_LINTS),\n     LintId::of(await_holding_invalid::AWAIT_HOLDING_LOCK),\n     LintId::of(await_holding_invalid::AWAIT_HOLDING_REFCELL_REF),\n+    LintId::of(casts::CAST_ENUM_CONSTRUCTOR),\n     LintId::of(casts::CAST_ENUM_TRUNCATION),\n     LintId::of(eval_order_dependence::EVAL_ORDER_DEPENDENCE),\n     LintId::of(float_equality_without_abs::FLOAT_EQUALITY_WITHOUT_ABS),"}, {"sha": "f2a07999144482e48231ba3e4bf19edbf4d71d77", "filename": "src/tools/clippy/clippy_lints/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7941b3f1473331d2abb2b8796046adc0105c8f94/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7941b3f1473331d2abb2b8796046adc0105c8f94/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.rs?ref=7941b3f1473331d2abb2b8796046adc0105c8f94", "patch": "@@ -23,6 +23,7 @@\n \n // FIXME: switch to something more ergonomic here, once available.\n // (Currently there is no way to opt into sysroot crates without `extern crate`.)\n+extern crate rustc_arena;\n extern crate rustc_ast;\n extern crate rustc_ast_pretty;\n extern crate rustc_attr;"}, {"sha": "b8591fe0db0ad31a3e94fc030f69310a3f137f7f", "filename": "src/tools/clippy/clippy_lints/src/matches/match_same_arms.rs", "status": "modified", "additions": 353, "deletions": 43, "changes": 396, "blob_url": "https://github.com/rust-lang/rust/blob/7941b3f1473331d2abb2b8796046adc0105c8f94/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fmatch_same_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7941b3f1473331d2abb2b8796046adc0105c8f94/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fmatch_same_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches%2Fmatch_same_arms.rs?ref=7941b3f1473331d2abb2b8796046adc0105c8f94", "patch": "@@ -1,19 +1,66 @@\n use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::source::snippet;\n use clippy_utils::{path_to_local, search_same, SpanlessEq, SpanlessHash};\n-use rustc_hir::{Arm, Expr, HirId, HirIdMap, HirIdSet, Pat, PatKind};\n+use core::cmp::Ordering;\n+use core::iter;\n+use core::slice;\n+use rustc_arena::DroplessArena;\n+use rustc_ast::ast::LitKind;\n+use rustc_errors::Applicability;\n+use rustc_hir::def_id::DefId;\n+use rustc_hir::{Arm, Expr, ExprKind, HirId, HirIdMap, HirIdSet, Pat, PatKind, RangeEnd};\n use rustc_lint::LateContext;\n+use rustc_middle::ty;\n+use rustc_span::Symbol;\n use std::collections::hash_map::Entry;\n \n use super::MATCH_SAME_ARMS;\n \n-pub(crate) fn check<'tcx>(cx: &LateContext<'tcx>, arms: &'tcx [Arm<'_>]) {\n+#[allow(clippy::too_many_lines)]\n+pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, arms: &'tcx [Arm<'_>]) {\n     let hash = |&(_, arm): &(usize, &Arm<'_>)| -> u64 {\n         let mut h = SpanlessHash::new(cx);\n         h.hash_expr(arm.body);\n         h.finish()\n     };\n \n+    let arena = DroplessArena::default();\n+    let normalized_pats: Vec<_> = arms\n+        .iter()\n+        .map(|a| NormalizedPat::from_pat(cx, &arena, a.pat))\n+        .collect();\n+\n+    // The furthast forwards a pattern can move without semantic changes\n+    let forwards_blocking_idxs: Vec<_> = normalized_pats\n+        .iter()\n+        .enumerate()\n+        .map(|(i, pat)| {\n+            normalized_pats[i + 1..]\n+                .iter()\n+                .enumerate()\n+                .find_map(|(j, other)| pat.has_overlapping_values(other).then(|| i + 1 + j))\n+                .unwrap_or(normalized_pats.len())\n+        })\n+        .collect();\n+\n+    // The furthast backwards a pattern can move without semantic changes\n+    let backwards_blocking_idxs: Vec<_> = normalized_pats\n+        .iter()\n+        .enumerate()\n+        .map(|(i, pat)| {\n+            normalized_pats[..i]\n+                .iter()\n+                .enumerate()\n+                .rev()\n+                .zip(forwards_blocking_idxs[..i].iter().copied().rev())\n+                .skip_while(|&(_, forward_block)| forward_block > i)\n+                .find_map(|((j, other), forward_block)| {\n+                    (forward_block == i || pat.has_overlapping_values(other)).then(|| j)\n+                })\n+                .unwrap_or(0)\n+        })\n+        .collect();\n+\n     let eq = |&(lindex, lhs): &(usize, &Arm<'_>), &(rindex, rhs): &(usize, &Arm<'_>)| -> bool {\n         let min_index = usize::min(lindex, rindex);\n         let max_index = usize::max(lindex, rindex);\n@@ -42,53 +89,316 @@ pub(crate) fn check<'tcx>(cx: &LateContext<'tcx>, arms: &'tcx [Arm<'_>]) {\n             }\n         };\n         // Arms with a guard are ignored, those can\u2019t always be merged together\n-        // This is also the case for arms in-between each there is an arm with a guard\n-        (min_index..=max_index).all(|index| arms[index].guard.is_none())\n-            && SpanlessEq::new(cx)\n-                .expr_fallback(eq_fallback)\n-                .eq_expr(lhs.body, rhs.body)\n-            // these checks could be removed to allow unused bindings\n-            && bindings_eq(lhs.pat, local_map.keys().copied().collect())\n-            && bindings_eq(rhs.pat, local_map.values().copied().collect())\n+        // If both arms overlap with an arm in between then these can't be merged either.\n+        !(backwards_blocking_idxs[max_index] > min_index && forwards_blocking_idxs[min_index] < max_index)\n+                && lhs.guard.is_none()\n+                && rhs.guard.is_none()\n+                && SpanlessEq::new(cx)\n+                    .expr_fallback(eq_fallback)\n+                    .eq_expr(lhs.body, rhs.body)\n+                // these checks could be removed to allow unused bindings\n+                && bindings_eq(lhs.pat, local_map.keys().copied().collect())\n+                && bindings_eq(rhs.pat, local_map.values().copied().collect())\n     };\n \n     let indexed_arms: Vec<(usize, &Arm<'_>)> = arms.iter().enumerate().collect();\n-    for (&(_, i), &(_, j)) in search_same(&indexed_arms, hash, eq) {\n-        span_lint_and_then(\n-            cx,\n-            MATCH_SAME_ARMS,\n-            j.body.span,\n-            \"this `match` has identical arm bodies\",\n-            |diag| {\n-                diag.span_note(i.body.span, \"same as this\");\n-\n-                // Note: this does not use `span_suggestion` on purpose:\n-                // there is no clean way\n-                // to remove the other arm. Building a span and suggest to replace it to \"\"\n-                // makes an even more confusing error message. Also in order not to make up a\n-                // span for the whole pattern, the suggestion is only shown when there is only\n-                // one pattern. The user should know about `|` if they are already using it\u2026\n-\n-                let lhs = snippet(cx, i.pat.span, \"<pat1>\");\n-                let rhs = snippet(cx, j.pat.span, \"<pat2>\");\n-\n-                if let PatKind::Wild = j.pat.kind {\n-                    // if the last arm is _, then i could be integrated into _\n-                    // note that i.pat cannot be _, because that would mean that we're\n-                    // hiding all the subsequent arms, and rust won't compile\n-                    diag.span_note(\n-                        i.body.span,\n-                        &format!(\n-                            \"`{}` has the same arm body as the `_` wildcard, consider removing it\",\n-                            lhs\n-                        ),\n-                    );\n+    for (&(i, arm1), &(j, arm2)) in search_same(&indexed_arms, hash, eq) {\n+        if matches!(arm2.pat.kind, PatKind::Wild) {\n+            span_lint_and_then(\n+                cx,\n+                MATCH_SAME_ARMS,\n+                arm1.span,\n+                \"this match arm has an identical body to the `_` wildcard arm\",\n+                |diag| {\n+                    diag.span_suggestion(\n+                        arm1.span,\n+                        \"try removing the arm\",\n+                        String::new(),\n+                        Applicability::MaybeIncorrect,\n+                    )\n+                    .help(\"or try changing either arm body\")\n+                    .span_note(arm2.span, \"`_` wildcard arm here\");\n+                },\n+            );\n+        } else {\n+            let back_block = backwards_blocking_idxs[j];\n+            let (keep_arm, move_arm) = if back_block < i || (back_block == 0 && forwards_blocking_idxs[i] <= j) {\n+                (arm1, arm2)\n+            } else {\n+                (arm2, arm1)\n+            };\n+\n+            span_lint_and_then(\n+                cx,\n+                MATCH_SAME_ARMS,\n+                keep_arm.span,\n+                \"this match arm has an identical body to another arm\",\n+                |diag| {\n+                    let move_pat_snip = snippet(cx, move_arm.pat.span, \"<pat2>\");\n+                    let keep_pat_snip = snippet(cx, keep_arm.pat.span, \"<pat1>\");\n+\n+                    diag.span_suggestion(\n+                        keep_arm.pat.span,\n+                        \"try merging the arm patterns\",\n+                        format!(\"{} | {}\", keep_pat_snip, move_pat_snip),\n+                        Applicability::MaybeIncorrect,\n+                    )\n+                    .help(\"or try changing either arm body\")\n+                    .span_note(move_arm.span, \"other arm here\");\n+                },\n+            );\n+        }\n+    }\n+}\n+\n+#[derive(Clone, Copy)]\n+enum NormalizedPat<'a> {\n+    Wild,\n+    Struct(Option<DefId>, &'a [(Symbol, Self)]),\n+    Tuple(Option<DefId>, &'a [Self]),\n+    Or(&'a [Self]),\n+    Path(Option<DefId>),\n+    LitStr(Symbol),\n+    LitBytes(&'a [u8]),\n+    LitInt(u128),\n+    LitBool(bool),\n+    Range(PatRange),\n+    /// A slice pattern. If the second value is `None`, then this matches an exact size. Otherwise\n+    /// the first value contains everything before the `..` wildcard pattern, and the second value\n+    /// contains everything afterwards. Note that either side, or both sides, may contain zero\n+    /// patterns.\n+    Slice(&'a [Self], Option<&'a [Self]>),\n+}\n+\n+#[derive(Clone, Copy)]\n+struct PatRange {\n+    start: u128,\n+    end: u128,\n+    bounds: RangeEnd,\n+}\n+impl PatRange {\n+    fn contains(&self, x: u128) -> bool {\n+        x >= self.start\n+            && match self.bounds {\n+                RangeEnd::Included => x <= self.end,\n+                RangeEnd::Excluded => x < self.end,\n+            }\n+    }\n+\n+    fn overlaps(&self, other: &Self) -> bool {\n+        // Note: Empty ranges are impossible, so this is correct even though it would return true if an\n+        // empty exclusive range were to reside within an inclusive range.\n+        (match self.bounds {\n+            RangeEnd::Included => self.end >= other.start,\n+            RangeEnd::Excluded => self.end > other.start,\n+        } && match other.bounds {\n+            RangeEnd::Included => self.start <= other.end,\n+            RangeEnd::Excluded => self.start < other.end,\n+        })\n+    }\n+}\n+\n+/// Iterates over the pairs of fields with matching names.\n+fn iter_matching_struct_fields<'a>(\n+    left: &'a [(Symbol, NormalizedPat<'a>)],\n+    right: &'a [(Symbol, NormalizedPat<'a>)],\n+) -> impl Iterator<Item = (&'a NormalizedPat<'a>, &'a NormalizedPat<'a>)> + 'a {\n+    struct Iter<'a>(\n+        slice::Iter<'a, (Symbol, NormalizedPat<'a>)>,\n+        slice::Iter<'a, (Symbol, NormalizedPat<'a>)>,\n+    );\n+    impl<'a> Iterator for Iter<'a> {\n+        type Item = (&'a NormalizedPat<'a>, &'a NormalizedPat<'a>);\n+        fn next(&mut self) -> Option<Self::Item> {\n+            // Note: all the fields in each slice are sorted by symbol value.\n+            let mut left = self.0.next()?;\n+            let mut right = self.1.next()?;\n+            loop {\n+                match left.0.cmp(&right.0) {\n+                    Ordering::Equal => return Some((&left.1, &right.1)),\n+                    Ordering::Less => left = self.0.next()?,\n+                    Ordering::Greater => right = self.1.next()?,\n+                }\n+            }\n+        }\n+    }\n+    Iter(left.iter(), right.iter())\n+}\n+\n+#[allow(clippy::similar_names)]\n+impl<'a> NormalizedPat<'a> {\n+    #[allow(clippy::too_many_lines)]\n+    fn from_pat(cx: &LateContext<'_>, arena: &'a DroplessArena, pat: &'a Pat<'_>) -> Self {\n+        match pat.kind {\n+            PatKind::Wild | PatKind::Binding(.., None) => Self::Wild,\n+            PatKind::Binding(.., Some(pat)) | PatKind::Box(pat) | PatKind::Ref(pat, _) => {\n+                Self::from_pat(cx, arena, pat)\n+            },\n+            PatKind::Struct(ref path, fields, _) => {\n+                let fields =\n+                    arena.alloc_from_iter(fields.iter().map(|f| (f.ident.name, Self::from_pat(cx, arena, f.pat))));\n+                fields.sort_by_key(|&(name, _)| name);\n+                Self::Struct(cx.qpath_res(path, pat.hir_id).opt_def_id(), fields)\n+            },\n+            PatKind::TupleStruct(ref path, pats, wild_idx) => {\n+                let adt = match cx.typeck_results().pat_ty(pat).ty_adt_def() {\n+                    Some(x) => x,\n+                    None => return Self::Wild,\n+                };\n+                let (var_id, variant) = if adt.is_enum() {\n+                    match cx.qpath_res(path, pat.hir_id).opt_def_id() {\n+                        Some(x) => (Some(x), adt.variant_with_ctor_id(x)),\n+                        None => return Self::Wild,\n+                    }\n                 } else {\n-                    diag.span_help(i.pat.span, &format!(\"consider refactoring into `{} | {}`\", lhs, rhs,))\n-                        .help(\"...or consider changing the match arm bodies\");\n+                    (None, adt.non_enum_variant())\n+                };\n+                let (front, back) = match wild_idx {\n+                    Some(i) => pats.split_at(i),\n+                    None => (pats, [].as_slice()),\n+                };\n+                let pats = arena.alloc_from_iter(\n+                    front\n+                        .iter()\n+                        .map(|pat| Self::from_pat(cx, arena, pat))\n+                        .chain(iter::repeat_with(|| Self::Wild).take(variant.fields.len() - pats.len()))\n+                        .chain(back.iter().map(|pat| Self::from_pat(cx, arena, pat))),\n+                );\n+                Self::Tuple(var_id, pats)\n+            },\n+            PatKind::Or(pats) => Self::Or(arena.alloc_from_iter(pats.iter().map(|pat| Self::from_pat(cx, arena, pat)))),\n+            PatKind::Path(ref path) => Self::Path(cx.qpath_res(path, pat.hir_id).opt_def_id()),\n+            PatKind::Tuple(pats, wild_idx) => {\n+                let field_count = match cx.typeck_results().pat_ty(pat).kind() {\n+                    ty::Tuple(subs) => subs.len(),\n+                    _ => return Self::Wild,\n+                };\n+                let (front, back) = match wild_idx {\n+                    Some(i) => pats.split_at(i),\n+                    None => (pats, [].as_slice()),\n+                };\n+                let pats = arena.alloc_from_iter(\n+                    front\n+                        .iter()\n+                        .map(|pat| Self::from_pat(cx, arena, pat))\n+                        .chain(iter::repeat_with(|| Self::Wild).take(field_count - pats.len()))\n+                        .chain(back.iter().map(|pat| Self::from_pat(cx, arena, pat))),\n+                );\n+                Self::Tuple(None, pats)\n+            },\n+            PatKind::Lit(e) => match &e.kind {\n+                // TODO: Handle negative integers. They're currently treated as a wild match.\n+                ExprKind::Lit(lit) => match lit.node {\n+                    LitKind::Str(sym, _) => Self::LitStr(sym),\n+                    LitKind::ByteStr(ref bytes) => Self::LitBytes(&**bytes),\n+                    LitKind::Byte(val) => Self::LitInt(val.into()),\n+                    LitKind::Char(val) => Self::LitInt(val.into()),\n+                    LitKind::Int(val, _) => Self::LitInt(val),\n+                    LitKind::Bool(val) => Self::LitBool(val),\n+                    LitKind::Float(..) | LitKind::Err(_) => Self::Wild,\n+                },\n+                _ => Self::Wild,\n+            },\n+            PatKind::Range(start, end, bounds) => {\n+                // TODO: Handle negative integers. They're currently treated as a wild match.\n+                let start = match start {\n+                    None => 0,\n+                    Some(e) => match &e.kind {\n+                        ExprKind::Lit(lit) => match lit.node {\n+                            LitKind::Int(val, _) => val,\n+                            LitKind::Char(val) => val.into(),\n+                            LitKind::Byte(val) => val.into(),\n+                            _ => return Self::Wild,\n+                        },\n+                        _ => return Self::Wild,\n+                    },\n+                };\n+                let (end, bounds) = match end {\n+                    None => (u128::MAX, RangeEnd::Included),\n+                    Some(e) => match &e.kind {\n+                        ExprKind::Lit(lit) => match lit.node {\n+                            LitKind::Int(val, _) => (val, bounds),\n+                            LitKind::Char(val) => (val.into(), bounds),\n+                            LitKind::Byte(val) => (val.into(), bounds),\n+                            _ => return Self::Wild,\n+                        },\n+                        _ => return Self::Wild,\n+                    },\n+                };\n+                Self::Range(PatRange { start, end, bounds })\n+            },\n+            PatKind::Slice(front, wild_pat, back) => Self::Slice(\n+                arena.alloc_from_iter(front.iter().map(|pat| Self::from_pat(cx, arena, pat))),\n+                wild_pat.map(|_| &*arena.alloc_from_iter(back.iter().map(|pat| Self::from_pat(cx, arena, pat)))),\n+            ),\n+        }\n+    }\n+\n+    /// Checks if two patterns overlap in the values they can match assuming they are for the same\n+    /// type.\n+    fn has_overlapping_values(&self, other: &Self) -> bool {\n+        match (*self, *other) {\n+            (Self::Wild, _) | (_, Self::Wild) => true,\n+            (Self::Or(pats), ref other) | (ref other, Self::Or(pats)) => {\n+                pats.iter().any(|pat| pat.has_overlapping_values(other))\n+            },\n+            (Self::Struct(lpath, lfields), Self::Struct(rpath, rfields)) => {\n+                if lpath != rpath {\n+                    return false;\n+                }\n+                iter_matching_struct_fields(lfields, rfields).all(|(lpat, rpat)| lpat.has_overlapping_values(rpat))\n+            },\n+            (Self::Tuple(lpath, lpats), Self::Tuple(rpath, rpats)) => {\n+                if lpath != rpath {\n+                    return false;\n                 }\n+                lpats\n+                    .iter()\n+                    .zip(rpats.iter())\n+                    .all(|(lpat, rpat)| lpat.has_overlapping_values(rpat))\n+            },\n+            (Self::Path(x), Self::Path(y)) => x == y,\n+            (Self::LitStr(x), Self::LitStr(y)) => x == y,\n+            (Self::LitBytes(x), Self::LitBytes(y)) => x == y,\n+            (Self::LitInt(x), Self::LitInt(y)) => x == y,\n+            (Self::LitBool(x), Self::LitBool(y)) => x == y,\n+            (Self::Range(ref x), Self::Range(ref y)) => x.overlaps(y),\n+            (Self::Range(ref range), Self::LitInt(x)) | (Self::LitInt(x), Self::Range(ref range)) => range.contains(x),\n+            (Self::Slice(lpats, None), Self::Slice(rpats, None)) => {\n+                lpats.len() == rpats.len() && lpats.iter().zip(rpats.iter()).all(|(x, y)| x.has_overlapping_values(y))\n             },\n-        );\n+            (Self::Slice(pats, None), Self::Slice(front, Some(back)))\n+            | (Self::Slice(front, Some(back)), Self::Slice(pats, None)) => {\n+                // Here `pats` is an exact size match. If the combined lengths of `front` and `back` are greater\n+                // then the minium length required will be greater than the length of `pats`.\n+                if pats.len() < front.len() + back.len() {\n+                    return false;\n+                }\n+                pats[..front.len()]\n+                    .iter()\n+                    .zip(front.iter())\n+                    .chain(pats[pats.len() - back.len()..].iter().zip(back.iter()))\n+                    .all(|(x, y)| x.has_overlapping_values(y))\n+            },\n+            (Self::Slice(lfront, Some(lback)), Self::Slice(rfront, Some(rback))) => lfront\n+                .iter()\n+                .zip(rfront.iter())\n+                .chain(lback.iter().rev().zip(rback.iter().rev()))\n+                .all(|(x, y)| x.has_overlapping_values(y)),\n+\n+            // Enums can mix unit variants with tuple/struct variants. These can never overlap.\n+            (Self::Path(_), Self::Tuple(..) | Self::Struct(..))\n+            | (Self::Tuple(..) | Self::Struct(..), Self::Path(_)) => false,\n+\n+            // Tuples can be matched like a struct.\n+            (Self::Tuple(x, _), Self::Struct(y, _)) | (Self::Struct(x, _), Self::Tuple(y, _)) => {\n+                // TODO: check fields here.\n+                x == y\n+            },\n+\n+            // TODO: Lit* with Path, Range with Path, LitBytes with Slice\n+            _ => true,\n+        }\n     }\n }\n "}, {"sha": "f447940ea3b5aaa84a2845c7ff8bbffc1e08fc1b", "filename": "src/tools/clippy/clippy_lints/src/methods/map_flatten.rs", "status": "modified", "additions": 54, "deletions": 64, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/7941b3f1473331d2abb2b8796046adc0105c8f94/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmap_flatten.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7941b3f1473331d2abb2b8796046adc0105c8f94/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmap_flatten.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmap_flatten.rs?ref=7941b3f1473331d2abb2b8796046adc0105c8f94", "patch": "@@ -1,83 +1,73 @@\n-use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::diagnostics::span_lint_and_sugg_for_edges;\n use clippy_utils::is_trait_method;\n-use clippy_utils::source::snippet;\n+use clippy_utils::source::snippet_with_applicability;\n use clippy_utils::ty::is_type_diagnostic_item;\n use rustc_errors::Applicability;\n-use rustc_hir as hir;\n+use rustc_hir::Expr;\n use rustc_lint::LateContext;\n use rustc_middle::ty;\n-use rustc_span::symbol::sym;\n+use rustc_span::{symbol::sym, Span};\n \n use super::MAP_FLATTEN;\n \n /// lint use of `map().flatten()` for `Iterators` and 'Options'\n-pub(super) fn check<'tcx>(\n-    cx: &LateContext<'tcx>,\n-    expr: &'tcx hir::Expr<'_>,\n-    recv: &'tcx hir::Expr<'_>,\n-    map_arg: &'tcx hir::Expr<'_>,\n-) {\n-    // lint if caller of `.map().flatten()` is an Iterator\n-    if is_trait_method(cx, expr, sym::Iterator) {\n-        let map_closure_ty = cx.typeck_results().expr_ty(map_arg);\n-        let is_map_to_option = match map_closure_ty.kind() {\n-            ty::Closure(_, _) | ty::FnDef(_, _) | ty::FnPtr(_) => {\n-                let map_closure_sig = match map_closure_ty.kind() {\n-                    ty::Closure(_, substs) => substs.as_closure().sig(),\n-                    _ => map_closure_ty.fn_sig(cx.tcx),\n-                };\n-                let map_closure_return_ty = cx.tcx.erase_late_bound_regions(map_closure_sig.output());\n-                is_type_diagnostic_item(cx, map_closure_return_ty, sym::Option)\n-            },\n-            _ => false,\n-        };\n-\n-        let method_to_use = if is_map_to_option {\n-            // `(...).map(...)` has type `impl Iterator<Item=Option<...>>\n-            \"filter_map\"\n-        } else {\n-            // `(...).map(...)` has type `impl Iterator<Item=impl Iterator<...>>\n-            \"flat_map\"\n-        };\n-        let func_snippet = snippet(cx, map_arg.span, \"..\");\n-        let hint = format!(\".{0}({1})\", method_to_use, func_snippet);\n-        span_lint_and_sugg(\n+pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>, recv: &Expr<'_>, map_arg: &Expr<'_>, map_span: Span) {\n+    if let Some((caller_ty_name, method_to_use)) = try_get_caller_ty_name_and_method_name(cx, expr, recv, map_arg) {\n+        let mut applicability = Applicability::MachineApplicable;\n+        let help_msgs = [\n+            &format!(\"try replacing `map` with `{}`\", method_to_use),\n+            \"and remove the `.flatten()`\",\n+        ];\n+        let closure_snippet = snippet_with_applicability(cx, map_arg.span, \"..\", &mut applicability);\n+        span_lint_and_sugg_for_edges(\n             cx,\n             MAP_FLATTEN,\n-            expr.span.with_lo(recv.span.hi()),\n-            \"called `map(..).flatten()` on an `Iterator`\",\n-            &format!(\"try using `{}` instead\", method_to_use),\n-            hint,\n-            Applicability::MachineApplicable,\n+            expr.span.with_lo(map_span.lo()),\n+            &format!(\"called `map(..).flatten()` on `{}`\", caller_ty_name),\n+            &help_msgs,\n+            format!(\"{}({})\", method_to_use, closure_snippet),\n+            applicability,\n         );\n     }\n+}\n \n-    // lint if caller of `.map().flatten()` is an Option or Result\n-    let caller_type = match cx.typeck_results().expr_ty(recv).kind() {\n-        ty::Adt(adt, _) => {\n+fn try_get_caller_ty_name_and_method_name(\n+    cx: &LateContext<'_>,\n+    expr: &Expr<'_>,\n+    caller_expr: &Expr<'_>,\n+    map_arg: &Expr<'_>,\n+) -> Option<(&'static str, &'static str)> {\n+    if is_trait_method(cx, expr, sym::Iterator) {\n+        if is_map_to_option(cx, map_arg) {\n+            // `(...).map(...)` has type `impl Iterator<Item=Option<...>>\n+            Some((\"Iterator\", \"filter_map\"))\n+        } else {\n+            // `(...).map(...)` has type `impl Iterator<Item=impl Iterator<...>>\n+            Some((\"Iterator\", \"flat_map\"))\n+        }\n+    } else {\n+        if let ty::Adt(adt, _) = cx.typeck_results().expr_ty(caller_expr).kind() {\n             if cx.tcx.is_diagnostic_item(sym::Option, adt.did()) {\n-                \"Option\"\n+                return Some((\"Option\", \"and_then\"));\n             } else if cx.tcx.is_diagnostic_item(sym::Result, adt.did()) {\n-                \"Result\"\n-            } else {\n-                return;\n+                return Some((\"Result\", \"and_then\"));\n             }\n-        },\n-        _ => {\n-            return;\n-        },\n-    };\n+        }\n+        None\n+    }\n+}\n \n-    let func_snippet = snippet(cx, map_arg.span, \"..\");\n-    let hint = format!(\".and_then({})\", func_snippet);\n-    let lint_info = format!(\"called `map(..).flatten()` on an `{}`\", caller_type);\n-    span_lint_and_sugg(\n-        cx,\n-        MAP_FLATTEN,\n-        expr.span.with_lo(recv.span.hi()),\n-        &lint_info,\n-        \"try using `and_then` instead\",\n-        hint,\n-        Applicability::MachineApplicable,\n-    );\n+fn is_map_to_option(cx: &LateContext<'_>, map_arg: &Expr<'_>) -> bool {\n+    let map_closure_ty = cx.typeck_results().expr_ty(map_arg);\n+    match map_closure_ty.kind() {\n+        ty::Closure(_, _) | ty::FnDef(_, _) | ty::FnPtr(_) => {\n+            let map_closure_sig = match map_closure_ty.kind() {\n+                ty::Closure(_, substs) => substs.as_closure().sig(),\n+                _ => map_closure_ty.fn_sig(cx.tcx),\n+            };\n+            let map_closure_return_ty = cx.tcx.erase_late_bound_regions(map_closure_sig.output());\n+            is_type_diagnostic_item(cx, map_closure_return_ty, sym::Option)\n+        },\n+        _ => false,\n+    }\n }"}, {"sha": "9d4e1fa39940139b1c1248df21649db552b66cd7", "filename": "src/tools/clippy/clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 79, "deletions": 2, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/7941b3f1473331d2abb2b8796046adc0105c8f94/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7941b3f1473331d2abb2b8796046adc0105c8f94/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=7941b3f1473331d2abb2b8796046adc0105c8f94", "patch": "@@ -45,6 +45,7 @@ mod option_as_ref_deref;\n mod option_map_or_none;\n mod option_map_unwrap_or;\n mod or_fun_call;\n+mod or_then_unwrap;\n mod search_is_some;\n mod single_char_add_str;\n mod single_char_insert_string;\n@@ -59,6 +60,7 @@ mod uninit_assumed_init;\n mod unnecessary_filter_map;\n mod unnecessary_fold;\n mod unnecessary_iter_cloned;\n+mod unnecessary_join;\n mod unnecessary_lazy_eval;\n mod unnecessary_to_owned;\n mod unwrap_or_else_default;\n@@ -778,6 +780,42 @@ declare_clippy_lint! {\n     \"using any `*or` method with a function call, which suggests `*or_else`\"\n }\n \n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for `.or(\u2026).unwrap()` calls to Options and Results.\n+    ///\n+    /// ### Why is this bad?\n+    /// You should use `.unwrap_or(\u2026)` instead for clarity.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// # let fallback = \"fallback\";\n+    /// // Result\n+    /// # type Error = &'static str;\n+    /// # let result: Result<&str, Error> = Err(\"error\");\n+    /// let value = result.or::<Error>(Ok(fallback)).unwrap();\n+    ///\n+    /// // Option\n+    /// # let option: Option<&str> = None;\n+    /// let value = option.or(Some(fallback)).unwrap();\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// # let fallback = \"fallback\";\n+    /// // Result\n+    /// # let result: Result<&str, &str> = Err(\"error\");\n+    /// let value = result.unwrap_or(fallback);\n+    ///\n+    /// // Option\n+    /// # let option: Option<&str> = None;\n+    /// let value = option.unwrap_or(fallback);\n+    /// ```\n+    #[clippy::version = \"1.61.0\"]\n+    pub OR_THEN_UNWRAP,\n+    complexity,\n+    \"checks for `.or(\u2026).unwrap()` calls to Options and Results.\"\n+}\n+\n declare_clippy_lint! {\n     /// ### What it does\n     /// Checks for calls to `.expect(&format!(...))`, `.expect(foo(..))`,\n@@ -1140,7 +1178,7 @@ declare_clippy_lint! {\n     /// ```\n     #[clippy::version = \"1.61.0\"]\n     pub ITER_WITH_DRAIN,\n-    perf,\n+    nursery,\n     \"replace `.drain(..)` with `.into_iter()`\"\n }\n \n@@ -2012,6 +2050,35 @@ declare_clippy_lint! {\n     \"unnecessary calls to `to_owned`-like functions\"\n }\n \n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Checks for use of `.collect::<Vec<String>>().join(\"\")` on iterators.\n+    ///\n+    /// ### Why is this bad?\n+    /// `.collect::<String>()` is more concise and usually more performant\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// let vector = vec![\"hello\",  \"world\"];\n+    /// let output = vector.iter().map(|item| item.to_uppercase()).collect::<Vec<String>>().join(\"\");\n+    /// println!(\"{}\", output);\n+    /// ```\n+    /// The correct use would be:\n+    /// ```rust\n+    /// let vector = vec![\"hello\",  \"world\"];\n+    /// let output = vector.iter().map(|item| item.to_uppercase()).collect::<String>();\n+    /// println!(\"{}\", output);\n+    /// ```\n+    /// ### Known problems\n+    /// While `.collect::<String>()` is more performant in most cases, there are cases where\n+    /// using `.collect::<String>()` over `.collect::<Vec<String>>().join(\"\")`\n+    /// will prevent loop unrolling and will result in a negative performance impact.\n+    #[clippy::version = \"1.61.0\"]\n+    pub UNNECESSARY_JOIN,\n+    pedantic,\n+    \"using `.collect::<Vec<String>>().join(\\\"\\\")` on an iterator\"\n+}\n+\n pub struct Methods {\n     avoid_breaking_exported_api: bool,\n     msrv: Option<RustcVersion>,\n@@ -2039,6 +2106,7 @@ impl_lint_pass!(Methods => [\n     OPTION_MAP_OR_NONE,\n     BIND_INSTEAD_OF_MAP,\n     OR_FUN_CALL,\n+    OR_THEN_UNWRAP,\n     EXPECT_FUN_CALL,\n     CHARS_NEXT_CMP,\n     CHARS_LAST_CMP,\n@@ -2096,6 +2164,7 @@ impl_lint_pass!(Methods => [\n     MANUAL_SPLIT_ONCE,\n     NEEDLESS_SPLITN,\n     UNNECESSARY_TO_OWNED,\n+    UNNECESSARY_JOIN,\n ]);\n \n /// Extracts a method call name, args, and `Span` of the method name.\n@@ -2377,7 +2446,7 @@ fn check_methods<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, msrv: Optio\n                 flat_map_option::check(cx, expr, arg, span);\n             },\n             (name @ \"flatten\", args @ []) => match method_call(recv) {\n-                Some((\"map\", [recv, map_arg], _)) => map_flatten::check(cx, expr, recv, map_arg),\n+                Some((\"map\", [recv, map_arg], map_span)) => map_flatten::check(cx, expr, recv, map_arg, map_span),\n                 Some((\"cloned\", [recv2], _)) => iter_overeager_cloned::check(cx, expr, recv2, name, args),\n                 _ => {},\n             },\n@@ -2391,6 +2460,11 @@ fn check_methods<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, msrv: Optio\n             (\"is_file\", []) => filetype_is_file::check(cx, expr, recv),\n             (\"is_none\", []) => check_is_some_is_none(cx, expr, recv, false),\n             (\"is_some\", []) => check_is_some_is_none(cx, expr, recv, true),\n+            (\"join\", [join_arg]) => {\n+                if let Some((\"collect\", _, span)) = method_call(recv) {\n+                    unnecessary_join::check(cx, expr, recv, join_arg, span);\n+                }\n+            },\n             (\"last\", args @ []) | (\"skip\", args @ [_]) => {\n                 if let Some((name2, [recv2, args2 @ ..], _span2)) = method_call(recv) {\n                     if let (\"cloned\", []) = (name2, args2) {\n@@ -2474,6 +2548,9 @@ fn check_methods<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, msrv: Optio\n                     Some((\"get_mut\", [recv, get_arg], _)) => {\n                         get_unwrap::check(cx, expr, recv, get_arg, true);\n                     },\n+                    Some((\"or\", [recv, or_arg], or_span)) => {\n+                        or_then_unwrap::check(cx, expr, recv, or_arg, or_span);\n+                    },\n                     _ => {},\n                 }\n                 unwrap_used::check(cx, expr, recv);"}, {"sha": "be5768c354504790eb9e073750d88759e9a1725a", "filename": "src/tools/clippy/clippy_lints/src/methods/or_then_unwrap.rs", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/7941b3f1473331d2abb2b8796046adc0105c8f94/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2For_then_unwrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7941b3f1473331d2abb2b8796046adc0105c8f94/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2For_then_unwrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2For_then_unwrap.rs?ref=7941b3f1473331d2abb2b8796046adc0105c8f94", "patch": "@@ -0,0 +1,68 @@\n+use clippy_utils::source::snippet_with_applicability;\n+use clippy_utils::ty::is_type_diagnostic_item;\n+use clippy_utils::{diagnostics::span_lint_and_sugg, is_lang_ctor};\n+use rustc_errors::Applicability;\n+use rustc_hir::{lang_items::LangItem, Expr, ExprKind};\n+use rustc_lint::LateContext;\n+use rustc_span::{sym, Span};\n+\n+use super::OR_THEN_UNWRAP;\n+\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    unwrap_expr: &Expr<'_>,\n+    recv: &'tcx Expr<'tcx>,\n+    or_arg: &'tcx Expr<'_>,\n+    or_span: Span,\n+) {\n+    let ty = cx.typeck_results().expr_ty(recv); // get type of x (we later check if it's Option or Result)\n+    let title;\n+    let or_arg_content: Span;\n+\n+    if is_type_diagnostic_item(cx, ty, sym::Option) {\n+        title = \"found `.or(Some(\u2026)).unwrap()`\";\n+        if let Some(content) = get_content_if_ctor_matches(cx, or_arg, LangItem::OptionSome) {\n+            or_arg_content = content;\n+        } else {\n+            return;\n+        }\n+    } else if is_type_diagnostic_item(cx, ty, sym::Result) {\n+        title = \"found `.or(Ok(\u2026)).unwrap()`\";\n+        if let Some(content) = get_content_if_ctor_matches(cx, or_arg, LangItem::ResultOk) {\n+            or_arg_content = content;\n+        } else {\n+            return;\n+        }\n+    } else {\n+        // Someone has implemented a struct with .or(...).unwrap() chaining,\n+        // but it's not an Option or a Result, so bail\n+        return;\n+    }\n+\n+    let mut applicability = Applicability::MachineApplicable;\n+    let suggestion = format!(\n+        \"unwrap_or({})\",\n+        snippet_with_applicability(cx, or_arg_content, \"..\", &mut applicability)\n+    );\n+\n+    span_lint_and_sugg(\n+        cx,\n+        OR_THEN_UNWRAP,\n+        unwrap_expr.span.with_lo(or_span.lo()),\n+        title,\n+        \"try this\",\n+        suggestion,\n+        applicability,\n+    );\n+}\n+\n+fn get_content_if_ctor_matches(cx: &LateContext<'_>, expr: &Expr<'_>, item: LangItem) -> Option<Span> {\n+    if let ExprKind::Call(some_expr, [arg]) = expr.kind\n+        && let ExprKind::Path(qpath) = &some_expr.kind\n+        && is_lang_ctor(cx, qpath, item)\n+    {\n+        Some(arg.span)\n+    } else {\n+        None\n+    }\n+}"}, {"sha": "973b8a7e6bf6a9409f44e399e31d2bbbd3e1ea10", "filename": "src/tools/clippy/clippy_lints/src/methods/unnecessary_join.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/7941b3f1473331d2abb2b8796046adc0105c8f94/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_join.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7941b3f1473331d2abb2b8796046adc0105c8f94/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_join.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_join.rs?ref=7941b3f1473331d2abb2b8796046adc0105c8f94", "patch": "@@ -0,0 +1,41 @@\n+use clippy_utils::{diagnostics::span_lint_and_sugg, ty::is_type_diagnostic_item};\n+use rustc_ast::ast::LitKind;\n+use rustc_errors::Applicability;\n+use rustc_hir::{Expr, ExprKind};\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::{Ref, Slice};\n+use rustc_span::{sym, Span};\n+\n+use super::UNNECESSARY_JOIN;\n+\n+pub(super) fn check<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx Expr<'tcx>,\n+    join_self_arg: &'tcx Expr<'tcx>,\n+    join_arg: &'tcx Expr<'tcx>,\n+    span: Span,\n+) {\n+    let applicability = Applicability::MachineApplicable;\n+    let collect_output_adjusted_type = cx.typeck_results().expr_ty_adjusted(join_self_arg);\n+    if_chain! {\n+        // the turbofish for collect is ::<Vec<String>>\n+        if let Ref(_, ref_type, _) = collect_output_adjusted_type.kind();\n+        if let Slice(slice) = ref_type.kind();\n+        if is_type_diagnostic_item(cx, *slice, sym::String);\n+        // the argument for join is \"\"\n+        if let ExprKind::Lit(spanned) = &join_arg.kind;\n+        if let LitKind::Str(symbol, _) = spanned.node;\n+        if symbol.is_empty();\n+        then {\n+            span_lint_and_sugg(\n+                cx,\n+                UNNECESSARY_JOIN,\n+                span.with_hi(expr.span.hi()),\n+                r#\"called `.collect<Vec<String>>().join(\"\")` on an iterator\"#,\n+                \"try using\",\n+                \"collect::<String>()\".to_owned(),\n+                applicability,\n+            );\n+        }\n+    }\n+}"}, {"sha": "2369be708129403f242fcdbfd55204d1295cf47b", "filename": "src/tools/clippy/clippy_lints/src/methods/unnecessary_lazy_eval.rs", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/7941b3f1473331d2abb2b8796046adc0105c8f94/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_lazy_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7941b3f1473331d2abb2b8796046adc0105c8f94/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_lazy_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_lazy_eval.rs?ref=7941b3f1473331d2abb2b8796046adc0105c8f94", "patch": "@@ -1,4 +1,4 @@\n-use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::source::snippet;\n use clippy_utils::ty::is_type_diagnostic_item;\n use clippy_utils::{eager_or_lazy, usage};\n@@ -48,20 +48,19 @@ pub(super) fn check<'tcx>(\n                     Applicability::MaybeIncorrect\n                 };\n \n-                span_lint_and_sugg(\n-                    cx,\n-                    UNNECESSARY_LAZY_EVALUATIONS,\n-                    expr.span,\n-                    msg,\n-                    &format!(\"use `{}` instead\", simplify_using),\n-                    format!(\n-                        \"{0}.{1}({2})\",\n-                        snippet(cx, recv.span, \"..\"),\n-                        simplify_using,\n-                        snippet(cx, body_expr.span, \"..\"),\n-                    ),\n-                    applicability,\n-                );\n+                // This is a duplicate of what's happening in clippy_lints::methods::method_call,\n+                // which isn't ideal, We want to get the method call span,\n+                // but prefer to avoid changing the signature of the function itself.\n+                if let hir::ExprKind::MethodCall(_, _, span) = expr.kind {\n+                    span_lint_and_then(cx, UNNECESSARY_LAZY_EVALUATIONS, expr.span, msg, |diag| {\n+                        diag.span_suggestion(\n+                            span,\n+                            &format!(\"use `{}(..)` instead\", simplify_using),\n+                            format!(\"{}({})\", simplify_using, snippet(cx, body_expr.span, \"..\")),\n+                            applicability,\n+                        );\n+                    });\n+                }\n             }\n         }\n     }"}, {"sha": "1555758fc4ad825b6b013a7bb1014544123f6804", "filename": "src/tools/clippy/clippy_lints/src/methods/unnecessary_to_owned.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/7941b3f1473331d2abb2b8796046adc0105c8f94/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_to_owned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7941b3f1473331d2abb2b8796046adc0105c8f94/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_to_owned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_to_owned.rs?ref=7941b3f1473331d2abb2b8796046adc0105c8f94", "patch": "@@ -2,7 +2,9 @@ use super::implicit_clone::is_clone_like;\n use super::unnecessary_iter_cloned::{self, is_into_iter};\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::snippet_opt;\n-use clippy_utils::ty::{get_associated_type, get_iterator_item_ty, implements_trait, is_copy, peel_mid_ty_refs};\n+use clippy_utils::ty::{\n+    contains_ty, get_associated_type, get_iterator_item_ty, implements_trait, is_copy, peel_mid_ty_refs,\n+};\n use clippy_utils::{fn_def_id, get_parent_expr, is_diag_item_method, is_diag_trait_item};\n use rustc_errors::Applicability;\n use rustc_hir::{def_id::DefId, BorrowKind, Expr, ExprKind};\n@@ -114,7 +116,12 @@ fn check_addr_of_expr(\n                     parent.span,\n                     &format!(\"unnecessary use of `{}`\", method_name),\n                     \"use\",\n-                    format!(\"{:&>width$}{}\", \"\", receiver_snippet, width = n_target_refs - n_receiver_refs),\n+                    format!(\n+                        \"{:&>width$}{}\",\n+                        \"\",\n+                        receiver_snippet,\n+                        width = n_target_refs - n_receiver_refs\n+                    ),\n                     Applicability::MachineApplicable,\n                 );\n                 return true;\n@@ -182,20 +189,10 @@ fn check_into_iter_call_arg(cx: &LateContext<'_>, expr: &Expr<'_>, method_name:\n         if let Some(item_ty) = get_iterator_item_ty(cx, parent_ty);\n         if let Some(receiver_snippet) = snippet_opt(cx, receiver.span);\n         then {\n-            if unnecessary_iter_cloned::check_for_loop_iter(\n-                cx,\n-                parent,\n-                method_name,\n-                receiver,\n-                true,\n-            ) {\n+            if unnecessary_iter_cloned::check_for_loop_iter(cx, parent, method_name, receiver, true) {\n                 return true;\n             }\n-            let cloned_or_copied = if is_copy(cx, item_ty) {\n-                \"copied\"\n-            } else {\n-                \"cloned\"\n-            };\n+            let cloned_or_copied = if is_copy(cx, item_ty) { \"copied\" } else { \"cloned\" };\n             // The next suggestion may be incorrect because the removal of the `to_owned`-like\n             // function could cause the iterator to hold a reference to a resource that is used\n             // mutably. See https://github.com/rust-lang/rust-clippy/issues/8148.\n@@ -243,18 +240,19 @@ fn check_other_call_arg<'tcx>(\n         if if trait_predicate.def_id() == deref_trait_id {\n             if let [projection_predicate] = projection_predicates[..] {\n                 let normalized_ty =\n-                    cx.tcx.subst_and_normalize_erasing_regions(call_substs, cx.param_env, projection_predicate.term);\n+                    cx.tcx\n+                        .subst_and_normalize_erasing_regions(call_substs, cx.param_env, projection_predicate.term);\n                 implements_trait(cx, receiver_ty, deref_trait_id, &[])\n-                    && get_associated_type(cx, receiver_ty, deref_trait_id,\n-                    \"Target\").map_or(false, |ty| ty::Term::Ty(ty) == normalized_ty)\n+                    && get_associated_type(cx, receiver_ty, deref_trait_id, \"Target\")\n+                        .map_or(false, |ty| ty::Term::Ty(ty) == normalized_ty)\n             } else {\n                 false\n             }\n         } else if trait_predicate.def_id() == as_ref_trait_id {\n             let composed_substs = compose_substs(\n                 cx,\n                 &trait_predicate.trait_ref.substs.iter().skip(1).collect::<Vec<_>>()[..],\n-                call_substs\n+                call_substs,\n             );\n             implements_trait(cx, receiver_ty, as_ref_trait_id, &composed_substs)\n         } else {\n@@ -264,6 +262,12 @@ fn check_other_call_arg<'tcx>(\n         // `Target = T`.\n         if n_refs > 0 || is_copy(cx, receiver_ty) || trait_predicate.def_id() != deref_trait_id;\n         let n_refs = max(n_refs, if is_copy(cx, receiver_ty) { 0 } else { 1 });\n+        // If the trait is `AsRef` and the input type variable `T` occurs in the output type, then\n+        // `T` must not be instantiated with a reference\n+        // (https://github.com/rust-lang/rust-clippy/issues/8507).\n+        if (n_refs == 0 && !receiver_ty.is_ref())\n+            || trait_predicate.def_id() != as_ref_trait_id\n+            || !contains_ty(fn_sig.output(), input);\n         if let Some(receiver_snippet) = snippet_opt(cx, receiver.span);\n         then {\n             span_lint_and_sugg(\n@@ -339,11 +343,7 @@ fn get_input_traits_and_projections<'tcx>(\n                 if let Some(arg) = substs.iter().next();\n                 if let GenericArgKind::Type(arg_ty) = arg.unpack();\n                 if arg_ty == input;\n-                then {\n-                    true\n-                } else {\n-                    false\n-                }\n+                then { true } else { false }\n             }\n         };\n         match predicate.kind().skip_binder() {"}, {"sha": "ba1997e70e1314ee631fdf87832121c6372250f8", "filename": "src/tools/clippy/clippy_lints/src/ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7941b3f1473331d2abb2b8796046adc0105c8f94/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7941b3f1473331d2abb2b8796046adc0105c8f94/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr.rs?ref=7941b3f1473331d2abb2b8796046adc0105c8f94", "patch": "@@ -436,7 +436,7 @@ fn check_fn_args<'cx, 'tcx: 'cx>(\n                             DerefTy::Path,\n                             None,\n                         ),\n-                        Some(sym::Cow) => {\n+                        Some(sym::Cow) if mutability == Mutability::Not => {\n                             let ty_name = name.args\n                                 .and_then(|args| {\n                                     args.args.iter().find_map(|a| match a {"}, {"sha": "66b79513032f6e8871e52ed543dafc9eb8585b5e", "filename": "src/tools/clippy/clippy_lints/src/single_component_path_imports.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7941b3f1473331d2abb2b8796046adc0105c8f94/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsingle_component_path_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7941b3f1473331d2abb2b8796046adc0105c8f94/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsingle_component_path_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsingle_component_path_imports.rs?ref=7941b3f1473331d2abb2b8796046adc0105c8f94", "patch": "@@ -1,5 +1,5 @@\n use clippy_utils::diagnostics::{span_lint_and_help, span_lint_and_sugg};\n-use rustc_ast::{ptr::P, Crate, Item, ItemKind, MacroDef, ModKind, UseTreeKind, VisibilityKind};\n+use rustc_ast::{ptr::P, Crate, Item, ItemKind, MacroDef, ModKind, UseTreeKind};\n use rustc_errors::Applicability;\n use rustc_lint::{EarlyContext, EarlyLintPass, LintContext};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n@@ -76,14 +76,13 @@ fn check_mod(cx: &EarlyContext<'_>, items: &[P<Item>]) {\n         );\n     }\n \n-    for single_use in &single_use_usages {\n-        if !imports_reused_with_self.contains(&single_use.0) {\n-            let can_suggest = single_use.2;\n+    for (name, span, can_suggest) in single_use_usages {\n+        if !imports_reused_with_self.contains(&name) {\n             if can_suggest {\n                 span_lint_and_sugg(\n                     cx,\n                     SINGLE_COMPONENT_PATH_IMPORTS,\n-                    single_use.1,\n+                    span,\n                     \"this import is redundant\",\n                     \"remove it entirely\",\n                     String::new(),\n@@ -93,7 +92,7 @@ fn check_mod(cx: &EarlyContext<'_>, items: &[P<Item>]) {\n                 span_lint_and_help(\n                     cx,\n                     SINGLE_COMPONENT_PATH_IMPORTS,\n-                    single_use.1,\n+                    span,\n                     \"this import is redundant\",\n                     None,\n                     \"remove this import\",\n@@ -124,14 +123,11 @@ fn track_uses(\n         ItemKind::Use(use_tree) => {\n             let segments = &use_tree.prefix.segments;\n \n-            let should_report =\n-                |name: &Symbol| !macros.contains(name) || matches!(item.vis.kind, VisibilityKind::Inherited);\n-\n             // keep track of `use some_module;` usages\n             if segments.len() == 1 {\n                 if let UseTreeKind::Simple(None, _, _) = use_tree.kind {\n                     let name = segments[0].ident.name;\n-                    if should_report(&name) {\n+                    if !macros.contains(&name) {\n                         single_use_usages.push((name, item.span, true));\n                     }\n                 }\n@@ -146,7 +142,7 @@ fn track_uses(\n                         if segments.len() == 1 {\n                             if let UseTreeKind::Simple(None, _, _) = tree.0.kind {\n                                 let name = segments[0].ident.name;\n-                                if should_report(&name) {\n+                                if !macros.contains(&name) {\n                                     single_use_usages.push((name, tree.0.span, false));\n                                 }\n                             }"}, {"sha": "02569bd3a476e50e3b0ea759ad9930712847f481", "filename": "src/tools/clippy/clippy_lints/src/transmute/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7941b3f1473331d2abb2b8796046adc0105c8f94/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7941b3f1473331d2abb2b8796046adc0105c8f94/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Fmod.rs?ref=7941b3f1473331d2abb2b8796046adc0105c8f94", "patch": "@@ -415,7 +415,8 @@ impl<'tcx> LateLintPass<'tcx> for Transmute {\n                 // And see https://github.com/rust-lang/rust/issues/51911 for dereferencing raw pointers.\n                 let const_context = in_constant(cx, e.hir_id);\n \n-                let from_ty = cx.typeck_results().expr_ty(arg);\n+                let from_ty = cx.typeck_results().expr_ty_adjusted(arg);\n+                // Adjustments for `to_ty` happen after the call to `transmute`, so don't use them.\n                 let to_ty = cx.typeck_results().expr_ty(e);\n \n                 // If useless_transmute is triggered, the other lints can be skipped."}, {"sha": "f5e21267a8976e4aff843095c42782569b9c73cd", "filename": "src/tools/clippy/clippy_lints/src/transmute/transmute_undefined_repr.rs", "status": "modified", "additions": 68, "deletions": 30, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/7941b3f1473331d2abb2b8796046adc0105c8f94/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Ftransmute_undefined_repr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7941b3f1473331d2abb2b8796046adc0105c8f94/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Ftransmute_undefined_repr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Ftransmute_undefined_repr.rs?ref=7941b3f1473331d2abb2b8796046adc0105c8f94", "patch": "@@ -3,8 +3,8 @@ use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::ty::is_c_void;\n use rustc_hir::Expr;\n use rustc_lint::LateContext;\n-use rustc_middle::ty::subst::Subst;\n-use rustc_middle::ty::{self, Ty, TypeAndMut};\n+use rustc_middle::ty::subst::{Subst, SubstsRef};\n+use rustc_middle::ty::{self, IntTy, Ty, TypeAndMut, UintTy};\n use rustc_span::Span;\n \n #[allow(clippy::too_many_lines)]\n@@ -23,7 +23,8 @@ pub(super) fn check<'tcx>(\n                 unsized_ty,\n                 to_ty: to_sub_ty,\n             } => match reduce_ty(cx, to_sub_ty) {\n-                ReducedTy::IntArray | ReducedTy::TypeErasure => break,\n+                ReducedTy::TypeErasure => break,\n+                ReducedTy::UnorderedFields(ty) if is_size_pair(ty) => break,\n                 ReducedTy::Ref(to_sub_ty) => {\n                     from_ty = unsized_ty;\n                     to_ty = to_sub_ty;\n@@ -48,7 +49,8 @@ pub(super) fn check<'tcx>(\n                 unsized_ty,\n                 from_ty: from_sub_ty,\n             } => match reduce_ty(cx, from_sub_ty) {\n-                ReducedTy::IntArray | ReducedTy::TypeErasure => break,\n+                ReducedTy::TypeErasure => break,\n+                ReducedTy::UnorderedFields(ty) if is_size_pair(ty) => break,\n                 ReducedTy::Ref(from_sub_ty) => {\n                     from_ty = from_sub_ty;\n                     to_ty = unsized_ty;\n@@ -123,9 +125,19 @@ pub(super) fn check<'tcx>(\n                 from_ty: from_sub_ty,\n                 to_ty: to_sub_ty,\n             } => match (reduce_ty(cx, from_sub_ty), reduce_ty(cx, to_sub_ty)) {\n-                (ReducedTy::IntArray | ReducedTy::TypeErasure, _)\n-                | (_, ReducedTy::IntArray | ReducedTy::TypeErasure) => return false,\n+                (ReducedTy::TypeErasure, _) | (_, ReducedTy::TypeErasure) => return false,\n                 (ReducedTy::UnorderedFields(from_ty), ReducedTy::UnorderedFields(to_ty)) if from_ty != to_ty => {\n+                    let same_adt_did = if let (ty::Adt(from_def, from_subs), ty::Adt(to_def, to_subs))\n+                        = (from_ty.kind(), to_ty.kind())\n+                        && from_def == to_def\n+                    {\n+                        if same_except_params(from_subs, to_subs) {\n+                            return false;\n+                        }\n+                        Some(from_def.did())\n+                    } else {\n+                        None\n+                    };\n                     span_lint_and_then(\n                         cx,\n                         TRANSMUTE_UNDEFINED_REPR,\n@@ -135,21 +147,17 @@ pub(super) fn check<'tcx>(\n                             from_ty_orig, to_ty_orig\n                         ),\n                         |diag| {\n-                            if_chain! {\n-                                if let (Some(from_def), Some(to_def)) = (from_ty.ty_adt_def(), to_ty.ty_adt_def());\n-                                if from_def == to_def;\n-                                then {\n-                                    diag.note(&format!(\n-                                        \"two instances of the same generic type (`{}`) may have different layouts\",\n-                                        cx.tcx.item_name(from_def.did())\n-                                    ));\n-                                } else {\n-                                    if from_ty_orig.peel_refs() != from_ty {\n-                                        diag.note(&format!(\"the contained type `{}` has an undefined layout\", from_ty));\n-                                    }\n-                                    if to_ty_orig.peel_refs() != to_ty {\n-                                        diag.note(&format!(\"the contained type `{}` has an undefined layout\", to_ty));\n-                                    }\n+                            if let Some(same_adt_did) = same_adt_did {\n+                                diag.note(&format!(\n+                                    \"two instances of the same generic type (`{}`) may have different layouts\",\n+                                    cx.tcx.item_name(same_adt_did)\n+                                ));\n+                            } else {\n+                                if from_ty_orig.peel_refs() != from_ty {\n+                                    diag.note(&format!(\"the contained type `{}` has an undefined layout\", from_ty));\n+                                }\n+                                if to_ty_orig.peel_refs() != to_ty {\n+                                    diag.note(&format!(\"the contained type `{}` has an undefined layout\", to_ty));\n                                 }\n                             }\n                         },\n@@ -196,10 +204,13 @@ pub(super) fn check<'tcx>(\n                     continue;\n                 },\n                 (\n-                    ReducedTy::OrderedFields(_) | ReducedTy::Ref(_) | ReducedTy::Other(_),\n-                    ReducedTy::OrderedFields(_) | ReducedTy::Ref(_) | ReducedTy::Other(_),\n+                    ReducedTy::OrderedFields(_) | ReducedTy::Ref(_) | ReducedTy::Other(_) | ReducedTy::Param,\n+                    ReducedTy::OrderedFields(_) | ReducedTy::Ref(_) | ReducedTy::Other(_) | ReducedTy::Param,\n                 )\n-                | (ReducedTy::UnorderedFields(_), ReducedTy::UnorderedFields(_)) => break,\n+                | (\n+                    ReducedTy::UnorderedFields(_) | ReducedTy::Param,\n+                    ReducedTy::UnorderedFields(_) | ReducedTy::Param,\n+                ) => break,\n             },\n         }\n     }\n@@ -263,9 +274,8 @@ enum ReducedTy<'tcx> {\n     UnorderedFields(Ty<'tcx>),\n     /// The type is a reference to the contained type.\n     Ref(Ty<'tcx>),\n-    /// The type is an array of a primitive integer type. These can be used as storage for a value\n-    /// of another type.\n-    IntArray,\n+    /// The type is a generic parameter.\n+    Param,\n     /// Any other type.\n     Other(Ty<'tcx>),\n }\n@@ -275,17 +285,18 @@ fn reduce_ty<'tcx>(cx: &LateContext<'tcx>, mut ty: Ty<'tcx>) -> ReducedTy<'tcx>\n     loop {\n         ty = cx.tcx.try_normalize_erasing_regions(cx.param_env, ty).unwrap_or(ty);\n         return match *ty.kind() {\n-            ty::Array(sub_ty, _) if matches!(sub_ty.kind(), ty::Int(_) | ty::Uint(_)) => ReducedTy::IntArray,\n+            ty::Array(sub_ty, _) if matches!(sub_ty.kind(), ty::Int(_) | ty::Uint(_)) => ReducedTy::TypeErasure,\n             ty::Array(sub_ty, _) | ty::Slice(sub_ty) => {\n                 ty = sub_ty;\n                 continue;\n             },\n             ty::Tuple(args) if args.is_empty() => ReducedTy::TypeErasure,\n             ty::Tuple(args) => {\n-                let Some(sized_ty) = args.iter().find(|&ty| !is_zero_sized_ty(cx, ty)) else {\n+                let mut iter = args.iter();\n+                let Some(sized_ty) = iter.find(|&ty| !is_zero_sized_ty(cx, ty)) else {\n                     return ReducedTy::OrderedFields(ty);\n                 };\n-                if args.iter().all(|ty| is_zero_sized_ty(cx, ty)) {\n+                if iter.all(|ty| is_zero_sized_ty(cx, ty)) {\n                     ty = sized_ty;\n                     continue;\n                 }\n@@ -313,9 +324,12 @@ fn reduce_ty<'tcx>(cx: &LateContext<'tcx>, mut ty: Ty<'tcx>) -> ReducedTy<'tcx>\n             ty::Adt(def, _) if def.is_enum() && (def.variants().is_empty() || is_c_void(cx, ty)) => {\n                 ReducedTy::TypeErasure\n             },\n+            // TODO: Check if the conversion to or from at least one of a union's fields is valid.\n+            ty::Adt(def, _) if def.is_union() => ReducedTy::TypeErasure,\n             ty::Foreign(_) => ReducedTy::TypeErasure,\n             ty::Ref(_, ty, _) => ReducedTy::Ref(ty),\n             ty::RawPtr(ty) => ReducedTy::Ref(ty.ty),\n+            ty::Param(_) => ReducedTy::Param,\n             _ => ReducedTy::Other(ty),\n         };\n     }\n@@ -332,3 +346,27 @@ fn is_zero_sized_ty<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n         }\n     }\n }\n+\n+fn is_size_pair(ty: Ty<'_>) -> bool {\n+    if let ty::Tuple(tys) = *ty.kind()\n+        && let [ty1, ty2] = &**tys\n+    {\n+        matches!(ty1.kind(), ty::Int(IntTy::Isize) | ty::Uint(UintTy::Usize))\n+            && matches!(ty2.kind(), ty::Int(IntTy::Isize) | ty::Uint(UintTy::Usize))\n+    } else {\n+        false\n+    }\n+}\n+\n+fn same_except_params(subs1: SubstsRef<'_>, subs2: SubstsRef<'_>) -> bool {\n+    // TODO: check const parameters as well. Currently this will consider `Array<5>` the same as\n+    // `Array<6>`\n+    for (ty1, ty2) in subs1.types().zip(subs2.types()).filter(|(ty1, ty2)| ty1 != ty2) {\n+        match (ty1.kind(), ty2.kind()) {\n+            (ty::Param(_), _) | (_, ty::Param(_)) => (),\n+            (ty::Adt(adt1, subs1), ty::Adt(adt2, subs2)) if adt1 == adt2 && same_except_params(subs1, subs2) => (),\n+            _ => return false,\n+        }\n+    }\n+    true\n+}"}, {"sha": "e108f7be12e6a69c7835db14c506239fdc9e33fa", "filename": "src/tools/clippy/clippy_lints/src/try_err.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7941b3f1473331d2abb2b8796046adc0105c8f94/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftry_err.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7941b3f1473331d2abb2b8796046adc0105c8f94/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftry_err.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftry_err.rs?ref=7941b3f1473331d2abb2b8796046adc0105c8f94", "patch": "@@ -43,7 +43,7 @@ declare_clippy_lint! {\n     /// ```\n     #[clippy::version = \"1.38.0\"]\n     pub TRY_ERR,\n-    style,\n+    restriction,\n     \"return errors explicitly rather than hiding them behind a `?`\"\n }\n "}, {"sha": "b3fad6ce7b65137e8a0a6a8e0c0c6fd2210c9c88", "filename": "src/tools/clippy/clippy_lints/src/utils/internal_lints/metadata_collector.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7941b3f1473331d2abb2b8796046adc0105c8f94/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7941b3f1473331d2abb2b8796046adc0105c8f94/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs?ref=7941b3f1473331d2abb2b8796046adc0105c8f94", "patch": "@@ -85,14 +85,15 @@ macro_rules! CONFIGURATION_VALUE_TEMPLATE {\n     };\n }\n \n-const LINT_EMISSION_FUNCTIONS: [&[&str]; 7] = [\n+const LINT_EMISSION_FUNCTIONS: [&[&str]; 8] = [\n     &[\"clippy_utils\", \"diagnostics\", \"span_lint\"],\n     &[\"clippy_utils\", \"diagnostics\", \"span_lint_and_help\"],\n     &[\"clippy_utils\", \"diagnostics\", \"span_lint_and_note\"],\n     &[\"clippy_utils\", \"diagnostics\", \"span_lint_hir\"],\n     &[\"clippy_utils\", \"diagnostics\", \"span_lint_and_sugg\"],\n     &[\"clippy_utils\", \"diagnostics\", \"span_lint_and_then\"],\n     &[\"clippy_utils\", \"diagnostics\", \"span_lint_hir_and_then\"],\n+    &[\"clippy_utils\", \"diagnostics\", \"span_lint_and_sugg_for_edges\"],\n ];\n const SUGGESTION_DIAGNOSTIC_BUILDER_METHODS: [(&str, bool); 9] = [\n     (\"span_suggestion\", false),"}, {"sha": "f3d818cc3485dd0c617da2a3591418a2b39b032a", "filename": "src/tools/clippy/clippy_lints/src/write.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7941b3f1473331d2abb2b8796046adc0105c8f94/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7941b3f1473331d2abb2b8796046adc0105c8f94/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fwrite.rs?ref=7941b3f1473331d2abb2b8796046adc0105c8f94", "patch": "@@ -581,14 +581,19 @@ impl Write {\n             };\n \n             let replacement: String = match lit.token.kind {\n-                LitKind::Integer | LitKind::Float | LitKind::Err => continue,\n                 LitKind::StrRaw(_) | LitKind::ByteStrRaw(_) if matches!(fmtstr.style, StrStyle::Raw(_)) => {\n                     lit.token.symbol.as_str().replace('{', \"{{\").replace('}', \"}}\")\n                 },\n                 LitKind::Str | LitKind::ByteStr if matches!(fmtstr.style, StrStyle::Cooked) => {\n                     lit.token.symbol.as_str().replace('{', \"{{\").replace('}', \"}}\")\n                 },\n-                LitKind::StrRaw(_) | LitKind::Str | LitKind::ByteStrRaw(_) | LitKind::ByteStr => continue,\n+                LitKind::StrRaw(_)\n+                | LitKind::Str\n+                | LitKind::ByteStrRaw(_)\n+                | LitKind::ByteStr\n+                | LitKind::Integer\n+                | LitKind::Float\n+                | LitKind::Err => continue,\n                 LitKind::Byte | LitKind::Char => match lit.token.symbol.as_str() {\n                     \"\\\"\" if matches!(fmtstr.style, StrStyle::Cooked) => \"\\\\\\\"\",\n                     \"\\\"\" if matches!(fmtstr.style, StrStyle::Raw(0)) => continue,"}, {"sha": "625a53899df94d69e0dbf8db91b9856ea677e69d", "filename": "src/tools/clippy/clippy_utils/src/diagnostics.rs", "status": "modified", "additions": 85, "deletions": 1, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/7941b3f1473331d2abb2b8796046adc0105c8f94/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7941b3f1473331d2abb2b8796046adc0105c8f94/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fdiagnostics.rs?ref=7941b3f1473331d2abb2b8796046adc0105c8f94", "patch": "@@ -8,7 +8,7 @@\n //! Thank you!\n //! ~The `INTERNAL_METADATA_COLLECTOR` lint\n \n-use rustc_errors::{Applicability, Diagnostic};\n+use rustc_errors::{emitter::MAX_SUGGESTION_HIGHLIGHT_LINES, Applicability, Diagnostic};\n use rustc_hir::HirId;\n use rustc_lint::{LateContext, Lint, LintContext};\n use rustc_span::source_map::{MultiSpan, Span};\n@@ -213,6 +213,90 @@ pub fn span_lint_and_sugg<'a, T: LintContext>(\n     });\n }\n \n+/// Like [`span_lint_and_sugg`] with a focus on the edges. The output will either\n+/// emit single span or multispan suggestion depending on the number of its lines.\n+///\n+/// If the given suggestion string has more lines than the maximum display length defined by\n+/// [`MAX_SUGGESTION_HIGHLIGHT_LINES`][`rustc_errors::emitter::MAX_SUGGESTION_HIGHLIGHT_LINES`],\n+/// this function will split the suggestion and span to showcase the change for the top and\n+/// bottom edge of the code. For normal suggestions, in one display window, the help message\n+/// will be combined with a colon.\n+///\n+/// Multipart suggestions like the one being created here currently cannot be\n+/// applied by rustfix (See [rustfix#141](https://github.com/rust-lang/rustfix/issues/141)).\n+/// Testing rustfix with this lint emission function might require a file with\n+/// suggestions that can be fixed and those that can't. See\n+/// [clippy#8520](https://github.com/rust-lang/rust-clippy/pull/8520/files) for\n+/// an example and of this.\n+///\n+/// # Example for a long suggestion\n+///\n+/// ```text\n+/// error: called `map(..).flatten()` on `Option`\n+///   --> $DIR/map_flatten.rs:8:10\n+///    |\n+/// LL |           .map(|x| {\n+///    |  __________^\n+/// LL | |             if x <= 5 {\n+/// LL | |                 Some(x)\n+/// LL | |             } else {\n+/// ...  |\n+/// LL | |         })\n+/// LL | |         .flatten();\n+///    | |__________________^\n+///    |\n+///   = note: `-D clippy::map-flatten` implied by `-D warnings`\n+/// help: try replacing `map` with `and_then`\n+///    |\n+/// LL ~         .and_then(|x| {\n+/// LL +             if x <= 5 {\n+/// LL +                 Some(x)\n+///    |\n+/// help: and remove the `.flatten()`\n+///    |\n+/// LL +                 None\n+/// LL +             }\n+/// LL ~         });\n+///    |\n+/// ```\n+pub fn span_lint_and_sugg_for_edges(\n+    cx: &LateContext<'_>,\n+    lint: &'static Lint,\n+    sp: Span,\n+    msg: &str,\n+    helps: &[&str; 2],\n+    sugg: String,\n+    applicability: Applicability,\n+) {\n+    span_lint_and_then(cx, lint, sp, msg, |diag| {\n+        let sugg_lines_count = sugg.lines().count();\n+        if sugg_lines_count > MAX_SUGGESTION_HIGHLIGHT_LINES {\n+            let sm = cx.sess().source_map();\n+            if let (Ok(line_upper), Ok(line_bottom)) = (sm.lookup_line(sp.lo()), sm.lookup_line(sp.hi())) {\n+                let split_idx = MAX_SUGGESTION_HIGHLIGHT_LINES / 2;\n+                let span_upper = sm.span_until_char(sp.with_hi(line_upper.sf.lines[line_upper.line + split_idx]), '\\n');\n+                let span_bottom = sp.with_lo(line_bottom.sf.lines[line_bottom.line - split_idx]);\n+\n+                let sugg_lines_vec = sugg.lines().collect::<Vec<&str>>();\n+                let sugg_upper = sugg_lines_vec[..split_idx].join(\"\\n\");\n+                let sugg_bottom = sugg_lines_vec[sugg_lines_count - split_idx..].join(\"\\n\");\n+\n+                diag.span_suggestion(span_upper, helps[0], sugg_upper, applicability);\n+                diag.span_suggestion(span_bottom, helps[1], sugg_bottom, applicability);\n+\n+                return;\n+            }\n+        }\n+        diag.span_suggestion_with_style(\n+            sp,\n+            &helps.join(\", \"),\n+            sugg,\n+            applicability,\n+            rustc_errors::SuggestionStyle::ShowAlways,\n+        );\n+    });\n+}\n+\n /// Create a suggestion made from several `span \u2192 replacement`.\n ///\n /// Note: in the JSON format (used by `compiletest_rs`), the help message will"}, {"sha": "1fc9979f3dd7de45db66a7dd5eb6fd8a48506841", "filename": "src/tools/clippy/clippy_utils/src/sugg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7941b3f1473331d2abb2b8796046adc0105c8f94/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fsugg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7941b3f1473331d2abb2b8796046adc0105c8f94/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fsugg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fsugg.rs?ref=7941b3f1473331d2abb2b8796046adc0105c8f94", "patch": "@@ -808,7 +808,7 @@ pub fn deref_closure_args<'tcx>(cx: &LateContext<'_>, closure: &'tcx hir::Expr<'\n             closure_arg_is_type_annotated_double_ref,\n             next_pos: closure.span.lo(),\n             suggestion_start: String::new(),\n-            applicability: Applicability::MaybeIncorrect,\n+            applicability: Applicability::MachineApplicable,\n         };\n \n         let fn_def_id = cx.tcx.hir().local_def_id(closure.hir_id);"}, {"sha": "5befb856a023470c0e211f281807f65a6fa17fa3", "filename": "src/tools/clippy/rust-toolchain", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7941b3f1473331d2abb2b8796046adc0105c8f94/src%2Ftools%2Fclippy%2Frust-toolchain", "raw_url": "https://github.com/rust-lang/rust/raw/7941b3f1473331d2abb2b8796046adc0105c8f94/src%2Ftools%2Fclippy%2Frust-toolchain", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Frust-toolchain?ref=7941b3f1473331d2abb2b8796046adc0105c8f94", "patch": "@@ -1,3 +1,3 @@\n [toolchain]\n-channel = \"nightly-2022-03-14\"\n+channel = \"nightly-2022-03-24\"\n components = [\"cargo\", \"llvm-tools-preview\", \"rust-src\", \"rust-std\", \"rustc\", \"rustc-dev\", \"rustfmt\"]"}, {"sha": "0193454ad144c0b3136b186ed4be2ecb535d4c48", "filename": "src/tools/clippy/tests/ui/cast_enum_constructor.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/7941b3f1473331d2abb2b8796046adc0105c8f94/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcast_enum_constructor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7941b3f1473331d2abb2b8796046adc0105c8f94/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcast_enum_constructor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcast_enum_constructor.rs?ref=7941b3f1473331d2abb2b8796046adc0105c8f94", "patch": "@@ -0,0 +1,17 @@\n+#![warn(clippy::cast_enum_constructor)]\n+#![allow(clippy::fn_to_numeric_cast)]\n+\n+fn main() {\n+    enum Foo {\n+        Y(u32),\n+    }\n+\n+    enum Bar {\n+        X,\n+    }\n+\n+    let _ = Foo::Y as usize;\n+    let _ = Foo::Y as isize;\n+    let _ = Foo::Y as fn(u32) -> Foo;\n+    let _ = Bar::X as usize;\n+}"}, {"sha": "710909dd26fa8ac9458035b90f22a55d4b8b5ea7", "filename": "src/tools/clippy/tests/ui/cast_enum_constructor.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7941b3f1473331d2abb2b8796046adc0105c8f94/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcast_enum_constructor.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7941b3f1473331d2abb2b8796046adc0105c8f94/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcast_enum_constructor.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcast_enum_constructor.stderr?ref=7941b3f1473331d2abb2b8796046adc0105c8f94", "patch": "@@ -0,0 +1,16 @@\n+error: cast of an enum tuple constructor to an integer\n+  --> $DIR/cast_enum_constructor.rs:13:13\n+   |\n+LL |     let _ = Foo::Y as usize;\n+   |             ^^^^^^^^^^^^^^^\n+   |\n+   = note: `-D clippy::cast-enum-constructor` implied by `-D warnings`\n+\n+error: cast of an enum tuple constructor to an integer\n+  --> $DIR/cast_enum_constructor.rs:14:13\n+   |\n+LL |     let _ = Foo::Y as isize;\n+   |             ^^^^^^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "7d47ee09dc1acfdac5e5932713fff966412fab88", "filename": "src/tools/clippy/tests/ui/map_flatten.rs", "status": "modified", "additions": 49, "deletions": 25, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/7941b3f1473331d2abb2b8796046adc0105c8f94/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmap_flatten.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7941b3f1473331d2abb2b8796046adc0105c8f94/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmap_flatten.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmap_flatten.rs?ref=7941b3f1473331d2abb2b8796046adc0105c8f94", "patch": "@@ -1,31 +1,55 @@\n-// run-rustfix\n-\n-#![warn(clippy::all, clippy::pedantic)]\n-#![allow(clippy::let_underscore_drop)]\n-#![allow(clippy::missing_docs_in_private_items)]\n-#![allow(clippy::map_identity)]\n-#![allow(clippy::redundant_closure)]\n-#![allow(clippy::unnecessary_wraps)]\n+#![warn(clippy::map_flatten)]\n #![feature(result_flattening)]\n \n-fn main() {\n-    // mapping to Option on Iterator\n-    fn option_id(x: i8) -> Option<i8> {\n-        Some(x)\n-    }\n-    let option_id_ref: fn(i8) -> Option<i8> = option_id;\n-    let option_id_closure = |x| Some(x);\n-    let _: Vec<_> = vec![5_i8; 6].into_iter().map(option_id).flatten().collect();\n-    let _: Vec<_> = vec![5_i8; 6].into_iter().map(option_id_ref).flatten().collect();\n-    let _: Vec<_> = vec![5_i8; 6].into_iter().map(option_id_closure).flatten().collect();\n-    let _: Vec<_> = vec![5_i8; 6].into_iter().map(|x| x.checked_add(1)).flatten().collect();\n+// issue #8506, multi-line\n+#[rustfmt::skip]\n+fn long_span() {\n+    let _: Option<i32> = Some(1)\n+        .map(|x| {\n+            if x <= 5 {\n+                Some(x)\n+            } else {\n+                None\n+            }\n+        })\n+        .flatten();\n \n-    // mapping to Iterator on Iterator\n-    let _: Vec<_> = vec![5_i8; 6].into_iter().map(|x| 0..x).flatten().collect();\n+    let _: Result<i32, i32> = Ok(1)\n+        .map(|x| {\n+            if x == 1 {\n+                Ok(x)\n+            } else {\n+                Err(0)\n+            }\n+        })\n+        .flatten();\n \n-    // mapping to Option on Option\n-    let _: Option<_> = (Some(Some(1))).map(|x| x).flatten();\n+    let result: Result<i32, i32> = Ok(2);\n+    fn do_something() { }\n+    let _: Result<i32, i32> = result\n+        .map(|res| {\n+            if res > 0 {\n+                do_something();\n+                Ok(res)\n+            } else {\n+                Err(0)\n+            }\n+        })\n+        .flatten();\n+        \n+    let _: Vec<_> = vec![5_i8; 6]\n+        .into_iter()\n+        .map(|some_value| {\n+            if some_value > 3 {\n+                Some(some_value)\n+            } else {\n+                None\n+            }\n+        })\n+        .flatten()\n+        .collect();\n+}\n \n-    // mapping to Result on Result\n-    let _: Result<_, &str> = (Ok(Ok(1))).map(|x| x).flatten();\n+fn main() {\n+    long_span();\n }"}, {"sha": "c9c60df838f67bf07bd70cc38fb0f3b238a7d44e", "filename": "src/tools/clippy/tests/ui/map_flatten.stderr", "status": "modified", "additions": 93, "deletions": 32, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/7941b3f1473331d2abb2b8796046adc0105c8f94/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmap_flatten.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7941b3f1473331d2abb2b8796046adc0105c8f94/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmap_flatten.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmap_flatten.stderr?ref=7941b3f1473331d2abb2b8796046adc0105c8f94", "patch": "@@ -1,46 +1,107 @@\n-error: called `map(..).flatten()` on an `Iterator`\n-  --> $DIR/map_flatten.rs:18:46\n+error: called `map(..).flatten()` on `Option`\n+  --> $DIR/map_flatten.rs:8:10\n    |\n-LL |     let _: Vec<_> = vec![5_i8; 6].into_iter().map(option_id).flatten().collect();\n-   |                                              ^^^^^^^^^^^^^^^^^^^^^^^^^ help: try using `filter_map` instead: `.filter_map(option_id)`\n+LL |           .map(|x| {\n+   |  __________^\n+LL | |             if x <= 5 {\n+LL | |                 Some(x)\n+LL | |             } else {\n+...  |\n+LL | |         })\n+LL | |         .flatten();\n+   | |__________________^\n    |\n    = note: `-D clippy::map-flatten` implied by `-D warnings`\n-\n-error: called `map(..).flatten()` on an `Iterator`\n-  --> $DIR/map_flatten.rs:19:46\n+help: try replacing `map` with `and_then`\n    |\n-LL |     let _: Vec<_> = vec![5_i8; 6].into_iter().map(option_id_ref).flatten().collect();\n-   |                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try using `filter_map` instead: `.filter_map(option_id_ref)`\n-\n-error: called `map(..).flatten()` on an `Iterator`\n-  --> $DIR/map_flatten.rs:20:46\n+LL ~         .and_then(|x| {\n+LL +             if x <= 5 {\n+LL +                 Some(x)\n    |\n-LL |     let _: Vec<_> = vec![5_i8; 6].into_iter().map(option_id_closure).flatten().collect();\n-   |                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try using `filter_map` instead: `.filter_map(option_id_closure)`\n-\n-error: called `map(..).flatten()` on an `Iterator`\n-  --> $DIR/map_flatten.rs:21:46\n+help: and remove the `.flatten()`\n+   |\n+LL +                 None\n+LL +             }\n+LL ~         });\n    |\n-LL |     let _: Vec<_> = vec![5_i8; 6].into_iter().map(|x| x.checked_add(1)).flatten().collect();\n-   |                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try using `filter_map` instead: `.filter_map(|x| x.checked_add(1))`\n \n-error: called `map(..).flatten()` on an `Iterator`\n-  --> $DIR/map_flatten.rs:24:46\n+error: called `map(..).flatten()` on `Result`\n+  --> $DIR/map_flatten.rs:18:10\n+   |\n+LL |           .map(|x| {\n+   |  __________^\n+LL | |             if x == 1 {\n+LL | |                 Ok(x)\n+LL | |             } else {\n+...  |\n+LL | |         })\n+LL | |         .flatten();\n+   | |__________________^\n+   |\n+help: try replacing `map` with `and_then`\n+   |\n+LL ~         .and_then(|x| {\n+LL +             if x == 1 {\n+LL +                 Ok(x)\n+   |\n+help: and remove the `.flatten()`\n+   |\n+LL +                 Err(0)\n+LL +             }\n+LL ~         });\n    |\n-LL |     let _: Vec<_> = vec![5_i8; 6].into_iter().map(|x| 0..x).flatten().collect();\n-   |                                              ^^^^^^^^^^^^^^^^^^^^^^^^ help: try using `flat_map` instead: `.flat_map(|x| 0..x)`\n \n-error: called `map(..).flatten()` on an `Option`\n-  --> $DIR/map_flatten.rs:27:39\n+error: called `map(..).flatten()` on `Result`\n+  --> $DIR/map_flatten.rs:30:10\n+   |\n+LL |           .map(|res| {\n+   |  __________^\n+LL | |             if res > 0 {\n+LL | |                 do_something();\n+LL | |                 Ok(res)\n+...  |\n+LL | |         })\n+LL | |         .flatten();\n+   | |__________________^\n+   |\n+help: try replacing `map` with `and_then`\n+   |\n+LL ~         .and_then(|res| {\n+LL +             if res > 0 {\n+LL +                 do_something();\n+   |\n+help: and remove the `.flatten()`\n+   |\n+LL +                 Err(0)\n+LL +             }\n+LL ~         });\n    |\n-LL |     let _: Option<_> = (Some(Some(1))).map(|x| x).flatten();\n-   |                                       ^^^^^^^^^^^^^^^^^^^^^ help: try using `and_then` instead: `.and_then(|x| x)`\n \n-error: called `map(..).flatten()` on an `Result`\n-  --> $DIR/map_flatten.rs:30:41\n+error: called `map(..).flatten()` on `Iterator`\n+  --> $DIR/map_flatten.rs:42:10\n+   |\n+LL |           .map(|some_value| {\n+   |  __________^\n+LL | |             if some_value > 3 {\n+LL | |                 Some(some_value)\n+LL | |             } else {\n+...  |\n+LL | |         })\n+LL | |         .flatten()\n+   | |__________________^\n+   |\n+help: try replacing `map` with `filter_map`\n+   |\n+LL ~         .filter_map(|some_value| {\n+LL +             if some_value > 3 {\n+LL +                 Some(some_value)\n+   |\n+help: and remove the `.flatten()`\n+   |\n+LL +                 None\n+LL +             }\n+LL +         })\n    |\n-LL |     let _: Result<_, &str> = (Ok(Ok(1))).map(|x| x).flatten();\n-   |                                         ^^^^^^^^^^^^^^^^^^^^^ help: try using `and_then` instead: `.and_then(|x| x)`\n \n-error: aborting due to 7 previous errors\n+error: aborting due to 4 previous errors\n "}, {"sha": "fec3a95edd62da54cddde339c8566e0fa56656e9", "filename": "src/tools/clippy/tests/ui/map_flatten_fixable.fixed", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7941b3f1473331d2abb2b8796046adc0105c8f94/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmap_flatten_fixable.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/7941b3f1473331d2abb2b8796046adc0105c8f94/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmap_flatten_fixable.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmap_flatten_fixable.fixed?ref=7941b3f1473331d2abb2b8796046adc0105c8f94", "previous_filename": "src/tools/clippy/tests/ui/map_flatten.fixed"}, {"sha": "aa1f76e335af0dad3a395921b3e25e6fbf82b6a4", "filename": "src/tools/clippy/tests/ui/map_flatten_fixable.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/7941b3f1473331d2abb2b8796046adc0105c8f94/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmap_flatten_fixable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7941b3f1473331d2abb2b8796046adc0105c8f94/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmap_flatten_fixable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmap_flatten_fixable.rs?ref=7941b3f1473331d2abb2b8796046adc0105c8f94", "patch": "@@ -0,0 +1,31 @@\n+// run-rustfix\n+\n+#![warn(clippy::all, clippy::pedantic)]\n+#![allow(clippy::let_underscore_drop)]\n+#![allow(clippy::missing_docs_in_private_items)]\n+#![allow(clippy::map_identity)]\n+#![allow(clippy::redundant_closure)]\n+#![allow(clippy::unnecessary_wraps)]\n+#![feature(result_flattening)]\n+\n+fn main() {\n+    // mapping to Option on Iterator\n+    fn option_id(x: i8) -> Option<i8> {\n+        Some(x)\n+    }\n+    let option_id_ref: fn(i8) -> Option<i8> = option_id;\n+    let option_id_closure = |x| Some(x);\n+    let _: Vec<_> = vec![5_i8; 6].into_iter().map(option_id).flatten().collect();\n+    let _: Vec<_> = vec![5_i8; 6].into_iter().map(option_id_ref).flatten().collect();\n+    let _: Vec<_> = vec![5_i8; 6].into_iter().map(option_id_closure).flatten().collect();\n+    let _: Vec<_> = vec![5_i8; 6].into_iter().map(|x| x.checked_add(1)).flatten().collect();\n+\n+    // mapping to Iterator on Iterator\n+    let _: Vec<_> = vec![5_i8; 6].into_iter().map(|x| 0..x).flatten().collect();\n+\n+    // mapping to Option on Option\n+    let _: Option<_> = (Some(Some(1))).map(|x| x).flatten();\n+\n+    // mapping to Result on Result\n+    let _: Result<_, &str> = (Ok(Ok(1))).map(|x| x).flatten();\n+}"}, {"sha": "c91c73846b69fb475a8d2d35064c8352b4aca6e9", "filename": "src/tools/clippy/tests/ui/map_flatten_fixable.stderr", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/7941b3f1473331d2abb2b8796046adc0105c8f94/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmap_flatten_fixable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7941b3f1473331d2abb2b8796046adc0105c8f94/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmap_flatten_fixable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmap_flatten_fixable.stderr?ref=7941b3f1473331d2abb2b8796046adc0105c8f94", "patch": "@@ -0,0 +1,80 @@\n+error: called `map(..).flatten()` on `Iterator`\n+  --> $DIR/map_flatten_fixable.rs:18:47\n+   |\n+LL |     let _: Vec<_> = vec![5_i8; 6].into_iter().map(option_id).flatten().collect();\n+   |                                               ^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `-D clippy::map-flatten` implied by `-D warnings`\n+help: try replacing `map` with `filter_map`, and remove the `.flatten()`\n+   |\n+LL |     let _: Vec<_> = vec![5_i8; 6].into_iter().filter_map(option_id).collect();\n+   |                                               ~~~~~~~~~~~~~~~~~~~~~\n+\n+error: called `map(..).flatten()` on `Iterator`\n+  --> $DIR/map_flatten_fixable.rs:19:47\n+   |\n+LL |     let _: Vec<_> = vec![5_i8; 6].into_iter().map(option_id_ref).flatten().collect();\n+   |                                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: try replacing `map` with `filter_map`, and remove the `.flatten()`\n+   |\n+LL |     let _: Vec<_> = vec![5_i8; 6].into_iter().filter_map(option_id_ref).collect();\n+   |                                               ~~~~~~~~~~~~~~~~~~~~~~~~~\n+\n+error: called `map(..).flatten()` on `Iterator`\n+  --> $DIR/map_flatten_fixable.rs:20:47\n+   |\n+LL |     let _: Vec<_> = vec![5_i8; 6].into_iter().map(option_id_closure).flatten().collect();\n+   |                                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: try replacing `map` with `filter_map`, and remove the `.flatten()`\n+   |\n+LL |     let _: Vec<_> = vec![5_i8; 6].into_iter().filter_map(option_id_closure).collect();\n+   |                                               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+\n+error: called `map(..).flatten()` on `Iterator`\n+  --> $DIR/map_flatten_fixable.rs:21:47\n+   |\n+LL |     let _: Vec<_> = vec![5_i8; 6].into_iter().map(|x| x.checked_add(1)).flatten().collect();\n+   |                                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: try replacing `map` with `filter_map`, and remove the `.flatten()`\n+   |\n+LL |     let _: Vec<_> = vec![5_i8; 6].into_iter().filter_map(|x| x.checked_add(1)).collect();\n+   |                                               ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+\n+error: called `map(..).flatten()` on `Iterator`\n+  --> $DIR/map_flatten_fixable.rs:24:47\n+   |\n+LL |     let _: Vec<_> = vec![5_i8; 6].into_iter().map(|x| 0..x).flatten().collect();\n+   |                                               ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: try replacing `map` with `flat_map`, and remove the `.flatten()`\n+   |\n+LL |     let _: Vec<_> = vec![5_i8; 6].into_iter().flat_map(|x| 0..x).collect();\n+   |                                               ~~~~~~~~~~~~~~~~~~\n+\n+error: called `map(..).flatten()` on `Option`\n+  --> $DIR/map_flatten_fixable.rs:27:40\n+   |\n+LL |     let _: Option<_> = (Some(Some(1))).map(|x| x).flatten();\n+   |                                        ^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: try replacing `map` with `and_then`, and remove the `.flatten()`\n+   |\n+LL |     let _: Option<_> = (Some(Some(1))).and_then(|x| x);\n+   |                                        ~~~~~~~~~~~~~~~\n+\n+error: called `map(..).flatten()` on `Result`\n+  --> $DIR/map_flatten_fixable.rs:30:42\n+   |\n+LL |     let _: Result<_, &str> = (Ok(Ok(1))).map(|x| x).flatten();\n+   |                                          ^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: try replacing `map` with `and_then`, and remove the `.flatten()`\n+   |\n+LL |     let _: Result<_, &str> = (Ok(Ok(1))).and_then(|x| x);\n+   |                                          ~~~~~~~~~~~~~~~\n+\n+error: aborting due to 7 previous errors\n+"}, {"sha": "b6d04263b37a3e7e7327425fe8d2d802b8f913fc", "filename": "src/tools/clippy/tests/ui/match_same_arms.stderr", "status": "modified", "additions": 79, "deletions": 86, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/7941b3f1473331d2abb2b8796046adc0105c8f94/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmatch_same_arms.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7941b3f1473331d2abb2b8796046adc0105c8f94/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmatch_same_arms.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmatch_same_arms.stderr?ref=7941b3f1473331d2abb2b8796046adc0105c8f94", "patch": "@@ -1,128 +1,121 @@\n-error: this `match` has identical arm bodies\n-  --> $DIR/match_same_arms.rs:13:14\n+error: this match arm has an identical body to the `_` wildcard arm\n+  --> $DIR/match_same_arms.rs:11:9\n    |\n-LL |         _ => 0, //~ ERROR match arms have same body\n-   |              ^\n+LL |         Abc::A => 0,\n+   |         ^^^^^^^^^^^ help: try removing the arm\n    |\n    = note: `-D clippy::match-same-arms` implied by `-D warnings`\n-note: same as this\n-  --> $DIR/match_same_arms.rs:11:19\n+   = help: or try changing either arm body\n+note: `_` wildcard arm here\n+  --> $DIR/match_same_arms.rs:13:9\n    |\n-LL |         Abc::A => 0,\n-   |                   ^\n-note: `Abc::A` has the same arm body as the `_` wildcard, consider removing it\n-  --> $DIR/match_same_arms.rs:11:19\n-   |\n-LL |         Abc::A => 0,\n-   |                   ^\n+LL |         _ => 0, //~ ERROR match arms have same body\n+   |         ^^^^^^\n \n-error: this `match` has identical arm bodies\n-  --> $DIR/match_same_arms.rs:18:20\n-   |\n-LL |         (.., 3) => 42, //~ ERROR match arms have same body\n-   |                    ^^\n-   |\n-note: same as this\n-  --> $DIR/match_same_arms.rs:17:23\n-   |\n-LL |         (1, .., 3) => 42,\n-   |                       ^^\n-help: consider refactoring into `(1, .., 3) | (.., 3)`\n+error: this match arm has an identical body to another arm\n   --> $DIR/match_same_arms.rs:17:9\n    |\n LL |         (1, .., 3) => 42,\n-   |         ^^^^^^^^^^\n-   = help: ...or consider changing the match arm bodies\n+   |         ----------^^^^^^\n+   |         |\n+   |         help: try merging the arm patterns: `(1, .., 3) | (.., 3)`\n+   |\n+   = help: or try changing either arm body\n+note: other arm here\n+  --> $DIR/match_same_arms.rs:18:9\n+   |\n+LL |         (.., 3) => 42, //~ ERROR match arms have same body\n+   |         ^^^^^^^^^^^^^\n \n-error: this `match` has identical arm bodies\n-  --> $DIR/match_same_arms.rs:24:15\n+error: this match arm has an identical body to another arm\n+  --> $DIR/match_same_arms.rs:24:9\n    |\n LL |         51 => 1, //~ ERROR match arms have same body\n-   |               ^\n+   |         --^^^^^\n+   |         |\n+   |         help: try merging the arm patterns: `51 | 42`\n    |\n-note: same as this\n-  --> $DIR/match_same_arms.rs:23:15\n-   |\n-LL |         42 => 1,\n-   |               ^\n-help: consider refactoring into `42 | 51`\n+   = help: or try changing either arm body\n+note: other arm here\n   --> $DIR/match_same_arms.rs:23:9\n    |\n LL |         42 => 1,\n-   |         ^^\n-   = help: ...or consider changing the match arm bodies\n+   |         ^^^^^^^\n \n-error: this `match` has identical arm bodies\n-  --> $DIR/match_same_arms.rs:26:15\n-   |\n-LL |         52 => 2, //~ ERROR match arms have same body\n-   |               ^\n-   |\n-note: same as this\n-  --> $DIR/match_same_arms.rs:25:15\n-   |\n-LL |         41 => 2,\n-   |               ^\n-help: consider refactoring into `41 | 52`\n+error: this match arm has an identical body to another arm\n   --> $DIR/match_same_arms.rs:25:9\n    |\n LL |         41 => 2,\n-   |         ^^\n-   = help: ...or consider changing the match arm bodies\n+   |         --^^^^^\n+   |         |\n+   |         help: try merging the arm patterns: `41 | 52`\n+   |\n+   = help: or try changing either arm body\n+note: other arm here\n+  --> $DIR/match_same_arms.rs:26:9\n+   |\n+LL |         52 => 2, //~ ERROR match arms have same body\n+   |         ^^^^^^^\n \n-error: this `match` has identical arm bodies\n-  --> $DIR/match_same_arms.rs:32:14\n+error: this match arm has an identical body to another arm\n+  --> $DIR/match_same_arms.rs:32:9\n    |\n LL |         2 => 2, //~ ERROR 2nd matched arms have same body\n-   |              ^\n-   |\n-note: same as this\n-  --> $DIR/match_same_arms.rs:31:14\n+   |         -^^^^^\n+   |         |\n+   |         help: try merging the arm patterns: `2 | 1`\n    |\n-LL |         1 => 2,\n-   |              ^\n-help: consider refactoring into `1 | 2`\n+   = help: or try changing either arm body\n+note: other arm here\n   --> $DIR/match_same_arms.rs:31:9\n    |\n LL |         1 => 2,\n-   |         ^\n-   = help: ...or consider changing the match arm bodies\n+   |         ^^^^^^\n \n-error: this `match` has identical arm bodies\n-  --> $DIR/match_same_arms.rs:33:14\n+error: this match arm has an identical body to another arm\n+  --> $DIR/match_same_arms.rs:33:9\n    |\n LL |         3 => 2, //~ ERROR 3rd matched arms have same body\n-   |              ^\n-   |\n-note: same as this\n-  --> $DIR/match_same_arms.rs:31:14\n+   |         -^^^^^\n+   |         |\n+   |         help: try merging the arm patterns: `3 | 1`\n    |\n-LL |         1 => 2,\n-   |              ^\n-help: consider refactoring into `1 | 3`\n+   = help: or try changing either arm body\n+note: other arm here\n   --> $DIR/match_same_arms.rs:31:9\n    |\n LL |         1 => 2,\n-   |         ^\n-   = help: ...or consider changing the match arm bodies\n+   |         ^^^^^^\n \n-error: this `match` has identical arm bodies\n-  --> $DIR/match_same_arms.rs:50:55\n+error: this match arm has an identical body to another arm\n+  --> $DIR/match_same_arms.rs:32:9\n    |\n-LL |                 CommandInfo::External { name, .. } => name.to_string(),\n-   |                                                       ^^^^^^^^^^^^^^^^\n+LL |         2 => 2, //~ ERROR 2nd matched arms have same body\n+   |         -^^^^^\n+   |         |\n+   |         help: try merging the arm patterns: `2 | 3`\n    |\n-note: same as this\n-  --> $DIR/match_same_arms.rs:49:54\n+   = help: or try changing either arm body\n+note: other arm here\n+  --> $DIR/match_same_arms.rs:33:9\n    |\n-LL |                 CommandInfo::BuiltIn { name, .. } => name.to_string(),\n-   |                                                      ^^^^^^^^^^^^^^^^\n-help: consider refactoring into `CommandInfo::BuiltIn { name, .. } | CommandInfo::External { name, .. }`\n+LL |         3 => 2, //~ ERROR 3rd matched arms have same body\n+   |         ^^^^^^\n+\n+error: this match arm has an identical body to another arm\n+  --> $DIR/match_same_arms.rs:50:17\n+   |\n+LL |                 CommandInfo::External { name, .. } => name.to_string(),\n+   |                 ----------------------------------^^^^^^^^^^^^^^^^^^^^\n+   |                 |\n+   |                 help: try merging the arm patterns: `CommandInfo::External { name, .. } | CommandInfo::BuiltIn { name, .. }`\n+   |\n+   = help: or try changing either arm body\n+note: other arm here\n   --> $DIR/match_same_arms.rs:49:17\n    |\n LL |                 CommandInfo::BuiltIn { name, .. } => name.to_string(),\n-   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   = help: ...or consider changing the match arm bodies\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to 7 previous errors\n+error: aborting due to 8 previous errors\n "}, {"sha": "dbfeb4379d513f7d910ef64346eadf197571ad11", "filename": "src/tools/clippy/tests/ui/match_same_arms2.rs", "status": "modified", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/7941b3f1473331d2abb2b8796046adc0105c8f94/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmatch_same_arms2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7941b3f1473331d2abb2b8796046adc0105c8f94/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmatch_same_arms2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmatch_same_arms2.rs?ref=7941b3f1473331d2abb2b8796046adc0105c8f94", "patch": "@@ -174,4 +174,57 @@ fn main() {\n         Some(2) => 2,\n         _ => 1,\n     };\n+\n+    enum Foo {\n+        X(u32),\n+        Y(u32),\n+        Z(u32),\n+    }\n+\n+    // Don't lint. `Foo::X(0)` and `Foo::Z(_)` overlap with the arm in between.\n+    let _ = match Foo::X(0) {\n+        Foo::X(0) => 1,\n+        Foo::X(_) | Foo::Y(_) | Foo::Z(0) => 2,\n+        Foo::Z(_) => 1,\n+        _ => 0,\n+    };\n+\n+    // Suggest moving `Foo::Z(_)` up.\n+    let _ = match Foo::X(0) {\n+        Foo::X(0) => 1,\n+        Foo::X(_) | Foo::Y(_) => 2,\n+        Foo::Z(_) => 1,\n+        _ => 0,\n+    };\n+\n+    // Suggest moving `Foo::X(0)` down.\n+    let _ = match Foo::X(0) {\n+        Foo::X(0) => 1,\n+        Foo::Y(_) | Foo::Z(0) => 2,\n+        Foo::Z(_) => 1,\n+        _ => 0,\n+    };\n+\n+    // Don't lint.\n+    let _ = match 0 {\n+        -2 => 1,\n+        -5..=50 => 2,\n+        -150..=88 => 1,\n+        _ => 3,\n+    };\n+\n+    struct Bar {\n+        x: u32,\n+        y: u32,\n+        z: u32,\n+    }\n+\n+    // Lint.\n+    let _ = match None {\n+        Some(Bar { x: 0, y: 5, .. }) => 1,\n+        Some(Bar { y: 10, z: 0, .. }) => 2,\n+        None => 50,\n+        Some(Bar { y: 0, x: 5, .. }) => 1,\n+        _ => 200,\n+    };\n }"}, {"sha": "14a672ba2fec1d0a5098cb1720566f8639632b1b", "filename": "src/tools/clippy/tests/ui/match_same_arms2.stderr", "status": "modified", "additions": 118, "deletions": 110, "changes": 228, "blob_url": "https://github.com/rust-lang/rust/blob/7941b3f1473331d2abb2b8796046adc0105c8f94/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmatch_same_arms2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7941b3f1473331d2abb2b8796046adc0105c8f94/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmatch_same_arms2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmatch_same_arms2.stderr?ref=7941b3f1473331d2abb2b8796046adc0105c8f94", "patch": "@@ -1,175 +1,138 @@\n-error: this `match` has identical arm bodies\n-  --> $DIR/match_same_arms2.rs:20:14\n+error: this match arm has an identical body to the `_` wildcard arm\n+  --> $DIR/match_same_arms2.rs:11:9\n    |\n-LL |           _ => {\n-   |  ______________^\n-LL | |             //~ ERROR match arms have same body\n+LL | /         42 => {\n LL | |             foo();\n LL | |             let mut a = 42 + [23].len() as i32;\n+LL | |             if true {\n ...  |\n LL | |             a\n LL | |         },\n-   | |_________^\n+   | |_________^ help: try removing the arm\n    |\n    = note: `-D clippy::match-same-arms` implied by `-D warnings`\n-note: same as this\n-  --> $DIR/match_same_arms2.rs:11:15\n+   = help: or try changing either arm body\n+note: `_` wildcard arm here\n+  --> $DIR/match_same_arms2.rs:20:9\n    |\n-LL |           42 => {\n-   |  _______________^\n-LL | |             foo();\n-LL | |             let mut a = 42 + [23].len() as i32;\n-LL | |             if true {\n-...  |\n-LL | |             a\n-LL | |         },\n-   | |_________^\n-note: `42` has the same arm body as the `_` wildcard, consider removing it\n-  --> $DIR/match_same_arms2.rs:11:15\n-   |\n-LL |           42 => {\n-   |  _______________^\n+LL | /         _ => {\n+LL | |             //~ ERROR match arms have same body\n LL | |             foo();\n LL | |             let mut a = 42 + [23].len() as i32;\n-LL | |             if true {\n ...  |\n LL | |             a\n LL | |         },\n    | |_________^\n \n-error: this `match` has identical arm bodies\n-  --> $DIR/match_same_arms2.rs:34:15\n+error: this match arm has an identical body to another arm\n+  --> $DIR/match_same_arms2.rs:34:9\n    |\n LL |         51 => foo(), //~ ERROR match arms have same body\n-   |               ^^^^^\n+   |         --^^^^^^^^^\n+   |         |\n+   |         help: try merging the arm patterns: `51 | 42`\n    |\n-note: same as this\n-  --> $DIR/match_same_arms2.rs:33:15\n-   |\n-LL |         42 => foo(),\n-   |               ^^^^^\n-help: consider refactoring into `42 | 51`\n+   = help: or try changing either arm body\n+note: other arm here\n   --> $DIR/match_same_arms2.rs:33:9\n    |\n LL |         42 => foo(),\n-   |         ^^\n-   = help: ...or consider changing the match arm bodies\n+   |         ^^^^^^^^^^^\n \n-error: this `match` has identical arm bodies\n-  --> $DIR/match_same_arms2.rs:40:17\n+error: this match arm has an identical body to another arm\n+  --> $DIR/match_same_arms2.rs:40:9\n    |\n LL |         None => 24, //~ ERROR match arms have same body\n-   |                 ^^\n+   |         ----^^^^^^\n+   |         |\n+   |         help: try merging the arm patterns: `None | Some(_)`\n    |\n-note: same as this\n-  --> $DIR/match_same_arms2.rs:39:20\n-   |\n-LL |         Some(_) => 24,\n-   |                    ^^\n-help: consider refactoring into `Some(_) | None`\n+   = help: or try changing either arm body\n+note: other arm here\n   --> $DIR/match_same_arms2.rs:39:9\n    |\n LL |         Some(_) => 24,\n-   |         ^^^^^^^\n-   = help: ...or consider changing the match arm bodies\n+   |         ^^^^^^^^^^^^^\n \n-error: this `match` has identical arm bodies\n-  --> $DIR/match_same_arms2.rs:62:28\n+error: this match arm has an identical body to another arm\n+  --> $DIR/match_same_arms2.rs:62:9\n    |\n LL |         (None, Some(a)) => bar(a), //~ ERROR match arms have same body\n-   |                            ^^^^^^\n-   |\n-note: same as this\n-  --> $DIR/match_same_arms2.rs:61:28\n+   |         ---------------^^^^^^^^^^\n+   |         |\n+   |         help: try merging the arm patterns: `(None, Some(a)) | (Some(a), None)`\n    |\n-LL |         (Some(a), None) => bar(a),\n-   |                            ^^^^^^\n-help: consider refactoring into `(Some(a), None) | (None, Some(a))`\n+   = help: or try changing either arm body\n+note: other arm here\n   --> $DIR/match_same_arms2.rs:61:9\n    |\n LL |         (Some(a), None) => bar(a),\n-   |         ^^^^^^^^^^^^^^^\n-   = help: ...or consider changing the match arm bodies\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: this `match` has identical arm bodies\n-  --> $DIR/match_same_arms2.rs:68:26\n-   |\n-LL |         (.., Some(a)) => bar(a), //~ ERROR match arms have same body\n-   |                          ^^^^^^\n-   |\n-note: same as this\n-  --> $DIR/match_same_arms2.rs:67:26\n-   |\n-LL |         (Some(a), ..) => bar(a),\n-   |                          ^^^^^^\n-help: consider refactoring into `(Some(a), ..) | (.., Some(a))`\n+error: this match arm has an identical body to another arm\n   --> $DIR/match_same_arms2.rs:67:9\n    |\n LL |         (Some(a), ..) => bar(a),\n-   |         ^^^^^^^^^^^^^\n-   = help: ...or consider changing the match arm bodies\n-\n-error: this `match` has identical arm bodies\n-  --> $DIR/match_same_arms2.rs:102:29\n-   |\n-LL |         (Ok(_), Some(x)) => println!(\"ok {}\", x),\n-   |                             ^^^^^^^^^^^^^^^^^^^^\n+   |         -------------^^^^^^^^^^\n+   |         |\n+   |         help: try merging the arm patterns: `(Some(a), ..) | (.., Some(a))`\n    |\n-note: same as this\n-  --> $DIR/match_same_arms2.rs:101:29\n+   = help: or try changing either arm body\n+note: other arm here\n+  --> $DIR/match_same_arms2.rs:68:9\n    |\n-LL |         (Ok(x), Some(_)) => println!(\"ok {}\", x),\n-   |                             ^^^^^^^^^^^^^^^^^^^^\n-help: consider refactoring into `(Ok(x), Some(_)) | (Ok(_), Some(x))`\n+LL |         (.., Some(a)) => bar(a), //~ ERROR match arms have same body\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: this match arm has an identical body to another arm\n   --> $DIR/match_same_arms2.rs:101:9\n    |\n LL |         (Ok(x), Some(_)) => println!(\"ok {}\", x),\n-   |         ^^^^^^^^^^^^^^^^\n-   = help: ...or consider changing the match arm bodies\n-   = note: this error originates in the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n+   |         ----------------^^^^^^^^^^^^^^^^^^^^^^^^\n+   |         |\n+   |         help: try merging the arm patterns: `(Ok(x), Some(_)) | (Ok(_), Some(x))`\n+   |\n+   = help: or try changing either arm body\n+note: other arm here\n+  --> $DIR/match_same_arms2.rs:102:9\n+   |\n+LL |         (Ok(_), Some(x)) => println!(\"ok {}\", x),\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: this `match` has identical arm bodies\n-  --> $DIR/match_same_arms2.rs:117:18\n+error: this match arm has an identical body to another arm\n+  --> $DIR/match_same_arms2.rs:117:9\n    |\n LL |         Ok(_) => println!(\"ok\"),\n-   |                  ^^^^^^^^^^^^^^\n-   |\n-note: same as this\n-  --> $DIR/match_same_arms2.rs:116:18\n+   |         -----^^^^^^^^^^^^^^^^^^\n+   |         |\n+   |         help: try merging the arm patterns: `Ok(_) | Ok(3)`\n    |\n-LL |         Ok(3) => println!(\"ok\"),\n-   |                  ^^^^^^^^^^^^^^\n-help: consider refactoring into `Ok(3) | Ok(_)`\n+   = help: or try changing either arm body\n+note: other arm here\n   --> $DIR/match_same_arms2.rs:116:9\n    |\n LL |         Ok(3) => println!(\"ok\"),\n-   |         ^^^^^\n-   = help: ...or consider changing the match arm bodies\n-   = note: this error originates in the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: this `match` has identical arm bodies\n-  --> $DIR/match_same_arms2.rs:144:14\n+error: this match arm has an identical body to another arm\n+  --> $DIR/match_same_arms2.rs:144:9\n    |\n LL |           1 => {\n-   |  ______________^\n+   |           ^ help: try merging the arm patterns: `1 | 0`\n+   |  _________|\n+   | |\n LL | |             empty!(0);\n LL | |         },\n    | |_________^\n    |\n-note: same as this\n-  --> $DIR/match_same_arms2.rs:141:14\n+   = help: or try changing either arm body\n+note: other arm here\n+  --> $DIR/match_same_arms2.rs:141:9\n    |\n-LL |           0 => {\n-   |  ______________^\n+LL | /         0 => {\n LL | |             empty!(0);\n LL | |         },\n    | |_________^\n-help: consider refactoring into `0 | 1`\n-  --> $DIR/match_same_arms2.rs:141:9\n-   |\n-LL |         0 => {\n-   |         ^\n-   = help: ...or consider changing the match arm bodies\n \n error: match expression looks like `matches!` macro\n   --> $DIR/match_same_arms2.rs:162:16\n@@ -184,5 +147,50 @@ LL | |     };\n    |\n    = note: `-D clippy::match-like-matches-macro` implied by `-D warnings`\n \n-error: aborting due to 9 previous errors\n+error: this match arm has an identical body to another arm\n+  --> $DIR/match_same_arms2.rs:194:9\n+   |\n+LL |         Foo::X(0) => 1,\n+   |         ---------^^^^^\n+   |         |\n+   |         help: try merging the arm patterns: `Foo::X(0) | Foo::Z(_)`\n+   |\n+   = help: or try changing either arm body\n+note: other arm here\n+  --> $DIR/match_same_arms2.rs:196:9\n+   |\n+LL |         Foo::Z(_) => 1,\n+   |         ^^^^^^^^^^^^^^\n+\n+error: this match arm has an identical body to another arm\n+  --> $DIR/match_same_arms2.rs:204:9\n+   |\n+LL |         Foo::Z(_) => 1,\n+   |         ---------^^^^^\n+   |         |\n+   |         help: try merging the arm patterns: `Foo::Z(_) | Foo::X(0)`\n+   |\n+   = help: or try changing either arm body\n+note: other arm here\n+  --> $DIR/match_same_arms2.rs:202:9\n+   |\n+LL |         Foo::X(0) => 1,\n+   |         ^^^^^^^^^^^^^^\n+\n+error: this match arm has an identical body to another arm\n+  --> $DIR/match_same_arms2.rs:227:9\n+   |\n+LL |         Some(Bar { y: 0, x: 5, .. }) => 1,\n+   |         ----------------------------^^^^^\n+   |         |\n+   |         help: try merging the arm patterns: `Some(Bar { y: 0, x: 5, .. }) | Some(Bar { x: 0, y: 5, .. })`\n+   |\n+   = help: or try changing either arm body\n+note: other arm here\n+  --> $DIR/match_same_arms2.rs:224:9\n+   |\n+LL |         Some(Bar { x: 0, y: 5, .. }) => 1,\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 12 previous errors\n "}, {"sha": "27d4b795a5eeb8fd31307b952f03006c23068784", "filename": "src/tools/clippy/tests/ui/or_then_unwrap.fixed", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/7941b3f1473331d2abb2b8796046adc0105c8f94/src%2Ftools%2Fclippy%2Ftests%2Fui%2For_then_unwrap.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/7941b3f1473331d2abb2b8796046adc0105c8f94/src%2Ftools%2Fclippy%2Ftests%2Fui%2For_then_unwrap.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2For_then_unwrap.fixed?ref=7941b3f1473331d2abb2b8796046adc0105c8f94", "patch": "@@ -0,0 +1,52 @@\n+// run-rustfix\n+\n+#![warn(clippy::or_then_unwrap)]\n+#![allow(clippy::map_identity)]\n+\n+struct SomeStruct {}\n+impl SomeStruct {\n+    fn or(self, _: Option<Self>) -> Self {\n+        self\n+    }\n+    fn unwrap(&self) {}\n+}\n+\n+struct SomeOtherStruct {}\n+impl SomeOtherStruct {\n+    fn or(self) -> Self {\n+        self\n+    }\n+    fn unwrap(&self) {}\n+}\n+\n+fn main() {\n+    let option: Option<&str> = None;\n+    let _ = option.unwrap_or(\"fallback\"); // should trigger lint\n+\n+    let result: Result<&str, &str> = Err(\"Error\");\n+    let _ = result.unwrap_or(\"fallback\"); // should trigger lint\n+\n+    // as part of a method chain\n+    let option: Option<&str> = None;\n+    let _ = option.map(|v| v).unwrap_or(\"fallback\").to_string().chars(); // should trigger lint\n+\n+    // Not Option/Result\n+    let instance = SomeStruct {};\n+    let _ = instance.or(Some(SomeStruct {})).unwrap(); // should not trigger lint\n+\n+    // or takes no argument\n+    let instance = SomeOtherStruct {};\n+    let _ = instance.or().unwrap(); // should not trigger lint and should not panic\n+\n+    // None in or\n+    let option: Option<&str> = None;\n+    let _ = option.or(None).unwrap(); // should not trigger lint\n+\n+    // Not Err in or\n+    let result: Result<&str, &str> = Err(\"Error\");\n+    let _ = result.or::<&str>(Err(\"Other Error\")).unwrap(); // should not trigger lint\n+\n+    // other function between\n+    let option: Option<&str> = None;\n+    let _ = option.or(Some(\"fallback\")).map(|v| v).unwrap(); // should not trigger lint\n+}"}, {"sha": "0dab5ae2f1c04167c996b5e82e9975a27efe615c", "filename": "src/tools/clippy/tests/ui/or_then_unwrap.rs", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/7941b3f1473331d2abb2b8796046adc0105c8f94/src%2Ftools%2Fclippy%2Ftests%2Fui%2For_then_unwrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7941b3f1473331d2abb2b8796046adc0105c8f94/src%2Ftools%2Fclippy%2Ftests%2Fui%2For_then_unwrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2For_then_unwrap.rs?ref=7941b3f1473331d2abb2b8796046adc0105c8f94", "patch": "@@ -0,0 +1,52 @@\n+// run-rustfix\n+\n+#![warn(clippy::or_then_unwrap)]\n+#![allow(clippy::map_identity)]\n+\n+struct SomeStruct {}\n+impl SomeStruct {\n+    fn or(self, _: Option<Self>) -> Self {\n+        self\n+    }\n+    fn unwrap(&self) {}\n+}\n+\n+struct SomeOtherStruct {}\n+impl SomeOtherStruct {\n+    fn or(self) -> Self {\n+        self\n+    }\n+    fn unwrap(&self) {}\n+}\n+\n+fn main() {\n+    let option: Option<&str> = None;\n+    let _ = option.or(Some(\"fallback\")).unwrap(); // should trigger lint\n+\n+    let result: Result<&str, &str> = Err(\"Error\");\n+    let _ = result.or::<&str>(Ok(\"fallback\")).unwrap(); // should trigger lint\n+\n+    // as part of a method chain\n+    let option: Option<&str> = None;\n+    let _ = option.map(|v| v).or(Some(\"fallback\")).unwrap().to_string().chars(); // should trigger lint\n+\n+    // Not Option/Result\n+    let instance = SomeStruct {};\n+    let _ = instance.or(Some(SomeStruct {})).unwrap(); // should not trigger lint\n+\n+    // or takes no argument\n+    let instance = SomeOtherStruct {};\n+    let _ = instance.or().unwrap(); // should not trigger lint and should not panic\n+\n+    // None in or\n+    let option: Option<&str> = None;\n+    let _ = option.or(None).unwrap(); // should not trigger lint\n+\n+    // Not Err in or\n+    let result: Result<&str, &str> = Err(\"Error\");\n+    let _ = result.or::<&str>(Err(\"Other Error\")).unwrap(); // should not trigger lint\n+\n+    // other function between\n+    let option: Option<&str> = None;\n+    let _ = option.or(Some(\"fallback\")).map(|v| v).unwrap(); // should not trigger lint\n+}"}, {"sha": "da88154c59f71f9b714f90416ef3a461954db6fe", "filename": "src/tools/clippy/tests/ui/or_then_unwrap.stderr", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7941b3f1473331d2abb2b8796046adc0105c8f94/src%2Ftools%2Fclippy%2Ftests%2Fui%2For_then_unwrap.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7941b3f1473331d2abb2b8796046adc0105c8f94/src%2Ftools%2Fclippy%2Ftests%2Fui%2For_then_unwrap.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2For_then_unwrap.stderr?ref=7941b3f1473331d2abb2b8796046adc0105c8f94", "patch": "@@ -0,0 +1,22 @@\n+error: found `.or(Some(\u2026)).unwrap()`\n+  --> $DIR/or_then_unwrap.rs:24:20\n+   |\n+LL |     let _ = option.or(Some(\"fallback\")).unwrap(); // should trigger lint\n+   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or(\"fallback\")`\n+   |\n+   = note: `-D clippy::or-then-unwrap` implied by `-D warnings`\n+\n+error: found `.or(Ok(\u2026)).unwrap()`\n+  --> $DIR/or_then_unwrap.rs:27:20\n+   |\n+LL |     let _ = result.or::<&str>(Ok(\"fallback\")).unwrap(); // should trigger lint\n+   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or(\"fallback\")`\n+\n+error: found `.or(Some(\u2026)).unwrap()`\n+  --> $DIR/or_then_unwrap.rs:31:31\n+   |\n+LL |     let _ = option.map(|v| v).or(Some(\"fallback\")).unwrap().to_string().chars(); // should trigger lint\n+   |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `unwrap_or(\"fallback\")`\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "03dd938a2339e57cda8eca5088c8b06a3c5d03ab", "filename": "src/tools/clippy/tests/ui/ptr_arg.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7941b3f1473331d2abb2b8796046adc0105c8f94/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fptr_arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7941b3f1473331d2abb2b8796046adc0105c8f94/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fptr_arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fptr_arg.rs?ref=7941b3f1473331d2abb2b8796046adc0105c8f94", "patch": "@@ -194,3 +194,10 @@ fn two_vecs(a: &mut Vec<u32>, b: &mut Vec<u32>) {\n     a.push(0);\n     b.push(1);\n }\n+\n+// Issue #8495\n+fn cow_conditional_to_mut(a: &mut Cow<str>) {\n+    if a.is_empty() {\n+        a.to_mut().push_str(\"foo\");\n+    }\n+}"}, {"sha": "e43f5d381aaa1087a928a49d86529693a74fdba9", "filename": "src/tools/clippy/tests/ui/single_component_path_imports_macro.fixed", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/63b8f01bb5ca277e7df8d7efe094ed4244c1790c/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsingle_component_path_imports_macro.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/63b8f01bb5ca277e7df8d7efe094ed4244c1790c/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsingle_component_path_imports_macro.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsingle_component_path_imports_macro.fixed?ref=63b8f01bb5ca277e7df8d7efe094ed4244c1790c", "patch": "@@ -1,20 +0,0 @@\n-// run-rustfix\n-#![warn(clippy::single_component_path_imports)]\n-#![allow(unused_imports)]\n-\n-// #7106: use statements exporting a macro within a crate should not trigger lint\n-\n-macro_rules! m1 {\n-    () => {};\n-}\n-pub(crate) use m1; // ok\n-\n-macro_rules! m2 {\n-    () => {};\n-}\n- // fail\n-\n-fn main() {\n-    m1!();\n-    m2!();\n-}"}, {"sha": "fda294a61546b5c6fa2befd83ef8281b92bba9ea", "filename": "src/tools/clippy/tests/ui/single_component_path_imports_macro.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7941b3f1473331d2abb2b8796046adc0105c8f94/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsingle_component_path_imports_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7941b3f1473331d2abb2b8796046adc0105c8f94/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsingle_component_path_imports_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsingle_component_path_imports_macro.rs?ref=7941b3f1473331d2abb2b8796046adc0105c8f94", "patch": "@@ -1,8 +1,8 @@\n-// run-rustfix\n #![warn(clippy::single_component_path_imports)]\n #![allow(unused_imports)]\n \n // #7106: use statements exporting a macro within a crate should not trigger lint\n+// #7923: normal `use` statements of macros should also not trigger the lint\n \n macro_rules! m1 {\n     () => {};\n@@ -12,7 +12,7 @@ pub(crate) use m1; // ok\n macro_rules! m2 {\n     () => {};\n }\n-use m2; // fail\n+use m2; // ok\n \n fn main() {\n     m1!();"}, {"sha": "37d5176129ff30a2d06733b35c2b2c9b5404574f", "filename": "src/tools/clippy/tests/ui/single_component_path_imports_macro.stderr", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/63b8f01bb5ca277e7df8d7efe094ed4244c1790c/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsingle_component_path_imports_macro.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/63b8f01bb5ca277e7df8d7efe094ed4244c1790c/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsingle_component_path_imports_macro.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsingle_component_path_imports_macro.stderr?ref=63b8f01bb5ca277e7df8d7efe094ed4244c1790c", "patch": "@@ -1,10 +0,0 @@\n-error: this import is redundant\n-  --> $DIR/single_component_path_imports_macro.rs:15:1\n-   |\n-LL | use m2; // fail\n-   | ^^^^^^^ help: remove it entirely\n-   |\n-   = note: `-D clippy::single-component-path-imports` implied by `-D warnings`\n-\n-error: aborting due to previous error\n-"}, {"sha": "b06ed4a917376f63775d02dd60f3d4afc4d2ac75", "filename": "src/tools/clippy/tests/ui/transmute_undefined_repr.rs", "status": "modified", "additions": 54, "deletions": 1, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/7941b3f1473331d2abb2b8796046adc0105c8f94/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftransmute_undefined_repr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7941b3f1473331d2abb2b8796046adc0105c8f94/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftransmute_undefined_repr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftransmute_undefined_repr.rs?ref=7941b3f1473331d2abb2b8796046adc0105c8f94", "patch": "@@ -1,8 +1,9 @@\n #![warn(clippy::transmute_undefined_repr)]\n #![allow(clippy::unit_arg, clippy::transmute_ptr_to_ref)]\n \n+use core::any::TypeId;\n use core::ffi::c_void;\n-use core::mem::{size_of, transmute};\n+use core::mem::{size_of, transmute, MaybeUninit};\n \n fn value<T>() -> T {\n     unimplemented!()\n@@ -87,5 +88,57 @@ fn main() {\n \n         let _: *const [u8] = transmute(value::<Box<[u8]>>()); // Ok\n         let _: Box<[u8]> = transmute(value::<*mut [u8]>()); // Ok\n+\n+        let _: Ty2<u32, u32> = transmute(value::<(Ty2<u32, u32>,)>()); // Ok\n+        let _: (Ty2<u32, u32>,) = transmute(value::<Ty2<u32, u32>>()); // Ok\n+\n+        let _: Ty2<u32, u32> = transmute(value::<(Ty2<u32, u32>, ())>()); // Ok\n+        let _: (Ty2<u32, u32>, ()) = transmute(value::<Ty2<u32, u32>>()); // Ok\n+\n+        let _: Ty2<u32, u32> = transmute(value::<((), Ty2<u32, u32>)>()); // Ok\n+        let _: ((), Ty2<u32, u32>) = transmute(value::<Ty2<u32, u32>>()); // Ok\n+\n+        let _: (usize, usize) = transmute(value::<&[u8]>()); // Ok\n+        let _: &[u8] = transmute(value::<(usize, usize)>()); // Ok\n+\n+        trait Trait {}\n+        let _: (isize, isize) = transmute(value::<&dyn Trait>()); // Ok\n+        let _: &dyn Trait = transmute(value::<(isize, isize)>()); // Ok\n+\n+        let _: MaybeUninit<Ty2<u32, u32>> = transmute(value::<Ty2<u32, u32>>()); // Ok\n+        let _: Ty2<u32, u32> = transmute(value::<MaybeUninit<Ty2<u32, u32>>>()); // Ok\n+\n+        let _: Ty<&[u32]> = transmute::<&[u32], _>(value::<&Vec<u32>>()); // Ok\n+    }\n+}\n+\n+fn _with_generics<T: 'static, U: 'static>() {\n+    if TypeId::of::<T>() != TypeId::of::<u32>() || TypeId::of::<T>() != TypeId::of::<U>() {\n+        return;\n+    }\n+    unsafe {\n+        let _: &u32 = transmute(value::<&T>()); // Ok\n+        let _: &T = transmute(value::<&u32>()); // Ok\n+\n+        let _: Vec<U> = transmute(value::<Vec<T>>()); // Ok\n+        let _: Vec<T> = transmute(value::<Vec<U>>()); // Ok\n+\n+        let _: Ty<&u32> = transmute(value::<&T>()); // Ok\n+        let _: Ty<&T> = transmute(value::<&u32>()); // Ok\n+\n+        let _: Vec<u32> = transmute(value::<Vec<T>>()); // Ok\n+        let _: Vec<T> = transmute(value::<Vec<u32>>()); // Ok\n+\n+        let _: &Ty2<u32, u32> = transmute(value::<&Ty2<T, U>>()); // Ok\n+        let _: &Ty2<T, U> = transmute(value::<&Ty2<u32, u32>>()); // Ok\n+\n+        let _: Vec<Vec<u32>> = transmute(value::<Vec<Vec<T>>>()); // Ok\n+        let _: Vec<Vec<T>> = transmute(value::<Vec<Vec<u32>>>()); // Ok\n+\n+        let _: Vec<Ty2<T, u32>> = transmute(value::<Vec<Ty2<U, i32>>>()); // Err\n+        let _: Vec<Ty2<U, i32>> = transmute(value::<Vec<Ty2<T, u32>>>()); // Err\n+\n+        let _: *const u32 = transmute(value::<Box<T>>()); // Ok\n+        let _: Box<T> = transmute(value::<*const u32>()); // Ok\n     }\n }"}, {"sha": "28bfba6c7571dc249ad3c97ae5c31982a4e07f9a", "filename": "src/tools/clippy/tests/ui/transmute_undefined_repr.stderr", "status": "modified", "additions": 25, "deletions": 9, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/7941b3f1473331d2abb2b8796046adc0105c8f94/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftransmute_undefined_repr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7941b3f1473331d2abb2b8796046adc0105c8f94/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftransmute_undefined_repr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftransmute_undefined_repr.stderr?ref=7941b3f1473331d2abb2b8796046adc0105c8f94", "patch": "@@ -1,64 +1,80 @@\n error: transmute from `Ty2<u32, i32>` which has an undefined layout\n-  --> $DIR/transmute_undefined_repr.rs:26:33\n+  --> $DIR/transmute_undefined_repr.rs:27:33\n    |\n LL |         let _: Ty2C<u32, i32> = transmute(value::<Ty2<u32, i32>>()); // Lint, Ty2 is unordered\n    |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::transmute-undefined-repr` implied by `-D warnings`\n \n error: transmute into `Ty2<u32, i32>` which has an undefined layout\n-  --> $DIR/transmute_undefined_repr.rs:27:32\n+  --> $DIR/transmute_undefined_repr.rs:28:32\n    |\n LL |         let _: Ty2<u32, i32> = transmute(value::<Ty2C<u32, i32>>()); // Lint, Ty2 is unordered\n    |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: transmute from `Ty<Ty2<u32, i32>>` to `Ty2<u32, f32>`, both of which have an undefined layout\n-  --> $DIR/transmute_undefined_repr.rs:32:32\n+  --> $DIR/transmute_undefined_repr.rs:33:32\n    |\n LL |         let _: Ty2<u32, f32> = transmute(value::<Ty<Ty2<u32, i32>>>()); // Lint, different Ty2 instances\n    |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: two instances of the same generic type (`Ty2`) may have different layouts\n \n error: transmute from `Ty2<u32, f32>` to `Ty<Ty2<u32, i32>>`, both of which have an undefined layout\n-  --> $DIR/transmute_undefined_repr.rs:33:36\n+  --> $DIR/transmute_undefined_repr.rs:34:36\n    |\n LL |         let _: Ty<Ty2<u32, i32>> = transmute(value::<Ty2<u32, f32>>()); // Lint, different Ty2 instances\n    |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: two instances of the same generic type (`Ty2`) may have different layouts\n \n error: transmute from `Ty<&Ty2<u32, i32>>` to `&Ty2<u32, f32>`, both of which have an undefined layout\n-  --> $DIR/transmute_undefined_repr.rs:38:33\n+  --> $DIR/transmute_undefined_repr.rs:39:33\n    |\n LL |         let _: &Ty2<u32, f32> = transmute(value::<Ty<&Ty2<u32, i32>>>()); // Lint, different Ty2 instances\n    |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: two instances of the same generic type (`Ty2`) may have different layouts\n \n error: transmute from `&Ty2<u32, f32>` to `Ty<&Ty2<u32, i32>>`, both of which have an undefined layout\n-  --> $DIR/transmute_undefined_repr.rs:39:37\n+  --> $DIR/transmute_undefined_repr.rs:40:37\n    |\n LL |         let _: Ty<&Ty2<u32, i32>> = transmute(value::<&Ty2<u32, f32>>()); // Lint, different Ty2 instances\n    |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: two instances of the same generic type (`Ty2`) may have different layouts\n \n error: transmute from `std::boxed::Box<Ty2<u32, u32>>` to `&mut Ty2<u32, f32>`, both of which have an undefined layout\n-  --> $DIR/transmute_undefined_repr.rs:56:45\n+  --> $DIR/transmute_undefined_repr.rs:57:45\n    |\n LL |         let _: &'static mut Ty2<u32, f32> = transmute(value::<Box<Ty2<u32, u32>>>()); // Lint, different Ty2 instances\n    |                                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: two instances of the same generic type (`Ty2`) may have different layouts\n \n error: transmute from `&mut Ty2<u32, f32>` to `std::boxed::Box<Ty2<u32, u32>>`, both of which have an undefined layout\n-  --> $DIR/transmute_undefined_repr.rs:57:37\n+  --> $DIR/transmute_undefined_repr.rs:58:37\n    |\n LL |         let _: Box<Ty2<u32, u32>> = transmute(value::<&'static mut Ty2<u32, f32>>()); // Lint, different Ty2 instances\n    |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: two instances of the same generic type (`Ty2`) may have different layouts\n \n-error: aborting due to 8 previous errors\n+error: transmute from `std::vec::Vec<Ty2<U, i32>>` to `std::vec::Vec<Ty2<T, u32>>`, both of which have an undefined layout\n+  --> $DIR/transmute_undefined_repr.rs:138:35\n+   |\n+LL |         let _: Vec<Ty2<T, u32>> = transmute(value::<Vec<Ty2<U, i32>>>()); // Err\n+   |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: two instances of the same generic type (`Vec`) may have different layouts\n+\n+error: transmute from `std::vec::Vec<Ty2<T, u32>>` to `std::vec::Vec<Ty2<U, i32>>`, both of which have an undefined layout\n+  --> $DIR/transmute_undefined_repr.rs:139:35\n+   |\n+LL |         let _: Vec<Ty2<U, i32>> = transmute(value::<Vec<Ty2<T, u32>>>()); // Err\n+   |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: two instances of the same generic type (`Vec`) may have different layouts\n+\n+error: aborting due to 10 previous errors\n "}, {"sha": "de9418c8d1adc4af6ab0e578ef3697b2a95a1c72", "filename": "src/tools/clippy/tests/ui/transmutes_expressible_as_ptr_casts.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7941b3f1473331d2abb2b8796046adc0105c8f94/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftransmutes_expressible_as_ptr_casts.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7941b3f1473331d2abb2b8796046adc0105c8f94/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftransmutes_expressible_as_ptr_casts.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftransmutes_expressible_as_ptr_casts.stderr?ref=7941b3f1473331d2abb2b8796046adc0105c8f94", "patch": "@@ -34,13 +34,13 @@ error: transmute from a reference to a pointer\n LL |     let _array_ptr_transmute = unsafe { transmute::<&[i32; 4], *const [i32; 4]>(array_ref) };\n    |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `array_ref as *const [i32; 4]`\n \n-error: transmute from `fn(usize) -> u8 {main::foo}` to `*const usize` which could be expressed as a pointer cast instead\n+error: transmute from `fn(usize) -> u8` to `*const usize` which could be expressed as a pointer cast instead\n   --> $DIR/transmutes_expressible_as_ptr_casts.rs:48:41\n    |\n LL |     let _usize_ptr_transmute = unsafe { transmute::<fn(usize) -> u8, *const usize>(foo) };\n    |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `foo as *const usize`\n \n-error: transmute from `fn(usize) -> u8 {main::foo}` to `usize` which could be expressed as a pointer cast instead\n+error: transmute from `fn(usize) -> u8` to `usize` which could be expressed as a pointer cast instead\n   --> $DIR/transmutes_expressible_as_ptr_casts.rs:52:49\n    |\n LL |     let _usize_from_fn_ptr_transmute = unsafe { transmute::<fn(usize) -> u8, usize>(foo) };"}, {"sha": "7e12c6ae4be98476f26fd7d4d0f6d29187c5bd22", "filename": "src/tools/clippy/tests/ui/unnecessary_join.fixed", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/7941b3f1473331d2abb2b8796046adc0105c8f94/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_join.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/7941b3f1473331d2abb2b8796046adc0105c8f94/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_join.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_join.fixed?ref=7941b3f1473331d2abb2b8796046adc0105c8f94", "patch": "@@ -0,0 +1,35 @@\n+// run-rustfix\n+\n+#![warn(clippy::unnecessary_join)]\n+\n+fn main() {\n+    // should be linted\n+    let vector = vec![\"hello\", \"world\"];\n+    let output = vector\n+        .iter()\n+        .map(|item| item.to_uppercase())\n+        .collect::<String>();\n+    println!(\"{}\", output);\n+\n+    // should be linted\n+    let vector = vec![\"hello\", \"world\"];\n+    let output = vector\n+        .iter()\n+        .map(|item| item.to_uppercase())\n+        .collect::<String>();\n+    println!(\"{}\", output);\n+\n+    // should not be linted\n+    let vector = vec![\"hello\", \"world\"];\n+    let output = vector\n+        .iter()\n+        .map(|item| item.to_uppercase())\n+        .collect::<Vec<String>>()\n+        .join(\"\\n\");\n+    println!(\"{}\", output);\n+\n+    // should not be linted\n+    let vector = vec![\"hello\", \"world\"];\n+    let output = vector.iter().map(|item| item.to_uppercase()).collect::<String>();\n+    println!(\"{}\", output);\n+}"}, {"sha": "0a21656a7558e3fb40c826c7de1c7f376ccecf09", "filename": "src/tools/clippy/tests/ui/unnecessary_join.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/7941b3f1473331d2abb2b8796046adc0105c8f94/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_join.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7941b3f1473331d2abb2b8796046adc0105c8f94/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_join.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_join.rs?ref=7941b3f1473331d2abb2b8796046adc0105c8f94", "patch": "@@ -0,0 +1,37 @@\n+// run-rustfix\n+\n+#![warn(clippy::unnecessary_join)]\n+\n+fn main() {\n+    // should be linted\n+    let vector = vec![\"hello\", \"world\"];\n+    let output = vector\n+        .iter()\n+        .map(|item| item.to_uppercase())\n+        .collect::<Vec<String>>()\n+        .join(\"\");\n+    println!(\"{}\", output);\n+\n+    // should be linted\n+    let vector = vec![\"hello\", \"world\"];\n+    let output = vector\n+        .iter()\n+        .map(|item| item.to_uppercase())\n+        .collect::<Vec<_>>()\n+        .join(\"\");\n+    println!(\"{}\", output);\n+\n+    // should not be linted\n+    let vector = vec![\"hello\", \"world\"];\n+    let output = vector\n+        .iter()\n+        .map(|item| item.to_uppercase())\n+        .collect::<Vec<String>>()\n+        .join(\"\\n\");\n+    println!(\"{}\", output);\n+\n+    // should not be linted\n+    let vector = vec![\"hello\", \"world\"];\n+    let output = vector.iter().map(|item| item.to_uppercase()).collect::<String>();\n+    println!(\"{}\", output);\n+}"}, {"sha": "0b14b143affd67db55a42ed5b3d094b0c4aa7815", "filename": "src/tools/clippy/tests/ui/unnecessary_join.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7941b3f1473331d2abb2b8796046adc0105c8f94/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_join.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7941b3f1473331d2abb2b8796046adc0105c8f94/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_join.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_join.stderr?ref=7941b3f1473331d2abb2b8796046adc0105c8f94", "patch": "@@ -0,0 +1,20 @@\n+error: called `.collect<Vec<String>>().join(\"\")` on an iterator\n+  --> $DIR/unnecessary_join.rs:11:10\n+   |\n+LL |           .collect::<Vec<String>>()\n+   |  __________^\n+LL | |         .join(\"\");\n+   | |_________________^ help: try using: `collect::<String>()`\n+   |\n+   = note: `-D clippy::unnecessary-join` implied by `-D warnings`\n+\n+error: called `.collect<Vec<String>>().join(\"\")` on an iterator\n+  --> $DIR/unnecessary_join.rs:20:10\n+   |\n+LL |           .collect::<Vec<_>>()\n+   |  __________^\n+LL | |         .join(\"\");\n+   | |_________________^ help: try using: `collect::<String>()`\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "65fcdc43061bfe8557441050c3cc73c54121ccb5", "filename": "src/tools/clippy/tests/ui/unnecessary_lazy_eval.fixed", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7941b3f1473331d2abb2b8796046adc0105c8f94/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_lazy_eval.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/7941b3f1473331d2abb2b8796046adc0105c8f94/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_lazy_eval.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_lazy_eval.fixed?ref=7941b3f1473331d2abb2b8796046adc0105c8f94", "patch": "@@ -115,6 +115,14 @@ fn main() {\n     let _: Result<usize, usize> = res.or(Ok(2));\n     let _: Result<usize, usize> = res.or(Ok(astronomers_pi));\n     let _: Result<usize, usize> = res.or(Ok(ext_str.some_field));\n+    let _: Result<usize, usize> = res.\n+        // some lines\n+        // some lines\n+        // some lines\n+        // some lines\n+        // some lines\n+        // some lines\n+        or(Ok(ext_str.some_field));\n \n     // neither bind_instead_of_map nor unnecessary_lazy_eval applies here\n     let _: Result<usize, usize> = res.and_then(|x| Err(x));"}, {"sha": "206080ed69ada8dd7735ed9b6551cd7b12dc672b", "filename": "src/tools/clippy/tests/ui/unnecessary_lazy_eval.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7941b3f1473331d2abb2b8796046adc0105c8f94/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_lazy_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7941b3f1473331d2abb2b8796046adc0105c8f94/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_lazy_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_lazy_eval.rs?ref=7941b3f1473331d2abb2b8796046adc0105c8f94", "patch": "@@ -115,6 +115,14 @@ fn main() {\n     let _: Result<usize, usize> = res.or_else(|_| Ok(2));\n     let _: Result<usize, usize> = res.or_else(|_| Ok(astronomers_pi));\n     let _: Result<usize, usize> = res.or_else(|_| Ok(ext_str.some_field));\n+    let _: Result<usize, usize> = res.\n+        // some lines\n+        // some lines\n+        // some lines\n+        // some lines\n+        // some lines\n+        // some lines\n+        or_else(|_| Ok(ext_str.some_field));\n \n     // neither bind_instead_of_map nor unnecessary_lazy_eval applies here\n     let _: Result<usize, usize> = res.and_then(|x| Err(x));"}, {"sha": "7e4dd7730e71530b79aa78b6f41937a13c90b143", "filename": "src/tools/clippy/tests/ui/unnecessary_lazy_eval.stderr", "status": "modified", "additions": 112, "deletions": 33, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/7941b3f1473331d2abb2b8796046adc0105c8f94/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_lazy_eval.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7941b3f1473331d2abb2b8796046adc0105c8f94/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_lazy_eval.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_lazy_eval.stderr?ref=7941b3f1473331d2abb2b8796046adc0105c8f94", "patch": "@@ -2,195 +2,274 @@ error: unnecessary closure used to substitute value for `Option::None`\n   --> $DIR/unnecessary_lazy_eval.rs:35:13\n    |\n LL |     let _ = opt.unwrap_or_else(|| 2);\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^ help: use `unwrap_or` instead: `opt.unwrap_or(2)`\n+   |             ^^^^--------------------\n+   |                 |\n+   |                 help: use `unwrap_or(..)` instead: `unwrap_or(2)`\n    |\n    = note: `-D clippy::unnecessary-lazy-evaluations` implied by `-D warnings`\n \n error: unnecessary closure used to substitute value for `Option::None`\n   --> $DIR/unnecessary_lazy_eval.rs:36:13\n    |\n LL |     let _ = opt.unwrap_or_else(|| astronomers_pi);\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `unwrap_or` instead: `opt.unwrap_or(astronomers_pi)`\n+   |             ^^^^---------------------------------\n+   |                 |\n+   |                 help: use `unwrap_or(..)` instead: `unwrap_or(astronomers_pi)`\n \n error: unnecessary closure used to substitute value for `Option::None`\n   --> $DIR/unnecessary_lazy_eval.rs:37:13\n    |\n LL |     let _ = opt.unwrap_or_else(|| ext_str.some_field);\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `unwrap_or` instead: `opt.unwrap_or(ext_str.some_field)`\n+   |             ^^^^-------------------------------------\n+   |                 |\n+   |                 help: use `unwrap_or(..)` instead: `unwrap_or(ext_str.some_field)`\n \n error: unnecessary closure used to substitute value for `Option::None`\n   --> $DIR/unnecessary_lazy_eval.rs:39:13\n    |\n LL |     let _ = opt.and_then(|_| ext_opt);\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `and` instead: `opt.and(ext_opt)`\n+   |             ^^^^---------------------\n+   |                 |\n+   |                 help: use `and(..)` instead: `and(ext_opt)`\n \n error: unnecessary closure used to substitute value for `Option::None`\n   --> $DIR/unnecessary_lazy_eval.rs:40:13\n    |\n LL |     let _ = opt.or_else(|| ext_opt);\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^ help: use `or` instead: `opt.or(ext_opt)`\n+   |             ^^^^-------------------\n+   |                 |\n+   |                 help: use `or(..)` instead: `or(ext_opt)`\n \n error: unnecessary closure used to substitute value for `Option::None`\n   --> $DIR/unnecessary_lazy_eval.rs:41:13\n    |\n LL |     let _ = opt.or_else(|| None);\n-   |             ^^^^^^^^^^^^^^^^^^^^ help: use `or` instead: `opt.or(None)`\n+   |             ^^^^----------------\n+   |                 |\n+   |                 help: use `or(..)` instead: `or(None)`\n \n error: unnecessary closure used to substitute value for `Option::None`\n   --> $DIR/unnecessary_lazy_eval.rs:42:13\n    |\n LL |     let _ = opt.get_or_insert_with(|| 2);\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `get_or_insert` instead: `opt.get_or_insert(2)`\n+   |             ^^^^------------------------\n+   |                 |\n+   |                 help: use `get_or_insert(..)` instead: `get_or_insert(2)`\n \n error: unnecessary closure used to substitute value for `Option::None`\n   --> $DIR/unnecessary_lazy_eval.rs:43:13\n    |\n LL |     let _ = opt.ok_or_else(|| 2);\n-   |             ^^^^^^^^^^^^^^^^^^^^ help: use `ok_or` instead: `opt.ok_or(2)`\n+   |             ^^^^----------------\n+   |                 |\n+   |                 help: use `ok_or(..)` instead: `ok_or(2)`\n \n error: unnecessary closure used to substitute value for `Option::None`\n   --> $DIR/unnecessary_lazy_eval.rs:44:13\n    |\n LL |     let _ = nested_tuple_opt.unwrap_or_else(|| Some((1, 2)));\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `unwrap_or` instead: `nested_tuple_opt.unwrap_or(Some((1, 2)))`\n+   |             ^^^^^^^^^^^^^^^^^-------------------------------\n+   |                              |\n+   |                              help: use `unwrap_or(..)` instead: `unwrap_or(Some((1, 2)))`\n \n error: unnecessary closure used to substitute value for `Option::None`\n   --> $DIR/unnecessary_lazy_eval.rs:47:13\n    |\n LL |     let _ = Some(10).unwrap_or_else(|| 2);\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `unwrap_or` instead: `Some(10).unwrap_or(2)`\n+   |             ^^^^^^^^^--------------------\n+   |                      |\n+   |                      help: use `unwrap_or(..)` instead: `unwrap_or(2)`\n \n error: unnecessary closure used to substitute value for `Option::None`\n   --> $DIR/unnecessary_lazy_eval.rs:48:13\n    |\n LL |     let _ = Some(10).and_then(|_| ext_opt);\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `and` instead: `Some(10).and(ext_opt)`\n+   |             ^^^^^^^^^---------------------\n+   |                      |\n+   |                      help: use `and(..)` instead: `and(ext_opt)`\n \n error: unnecessary closure used to substitute value for `Option::None`\n   --> $DIR/unnecessary_lazy_eval.rs:49:28\n    |\n LL |     let _: Option<usize> = None.or_else(|| ext_opt);\n-   |                            ^^^^^^^^^^^^^^^^^^^^^^^^ help: use `or` instead: `None.or(ext_opt)`\n+   |                            ^^^^^-------------------\n+   |                                 |\n+   |                                 help: use `or(..)` instead: `or(ext_opt)`\n \n error: unnecessary closure used to substitute value for `Option::None`\n   --> $DIR/unnecessary_lazy_eval.rs:50:13\n    |\n LL |     let _ = None.get_or_insert_with(|| 2);\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `get_or_insert` instead: `None.get_or_insert(2)`\n+   |             ^^^^^------------------------\n+   |                  |\n+   |                  help: use `get_or_insert(..)` instead: `get_or_insert(2)`\n \n error: unnecessary closure used to substitute value for `Option::None`\n   --> $DIR/unnecessary_lazy_eval.rs:51:35\n    |\n LL |     let _: Result<usize, usize> = None.ok_or_else(|| 2);\n-   |                                   ^^^^^^^^^^^^^^^^^^^^^ help: use `ok_or` instead: `None.ok_or(2)`\n+   |                                   ^^^^^----------------\n+   |                                        |\n+   |                                        help: use `ok_or(..)` instead: `ok_or(2)`\n \n error: unnecessary closure used to substitute value for `Option::None`\n   --> $DIR/unnecessary_lazy_eval.rs:52:28\n    |\n LL |     let _: Option<usize> = None.or_else(|| None);\n-   |                            ^^^^^^^^^^^^^^^^^^^^^ help: use `or` instead: `None.or(None)`\n+   |                            ^^^^^----------------\n+   |                                 |\n+   |                                 help: use `or(..)` instead: `or(None)`\n \n error: unnecessary closure used to substitute value for `Option::None`\n   --> $DIR/unnecessary_lazy_eval.rs:55:13\n    |\n LL |     let _ = deep.0.unwrap_or_else(|| 2);\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `unwrap_or` instead: `deep.0.unwrap_or(2)`\n+   |             ^^^^^^^--------------------\n+   |                    |\n+   |                    help: use `unwrap_or(..)` instead: `unwrap_or(2)`\n \n error: unnecessary closure used to substitute value for `Option::None`\n   --> $DIR/unnecessary_lazy_eval.rs:56:13\n    |\n LL |     let _ = deep.0.and_then(|_| ext_opt);\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `and` instead: `deep.0.and(ext_opt)`\n+   |             ^^^^^^^---------------------\n+   |                    |\n+   |                    help: use `and(..)` instead: `and(ext_opt)`\n \n error: unnecessary closure used to substitute value for `Option::None`\n   --> $DIR/unnecessary_lazy_eval.rs:57:13\n    |\n LL |     let _ = deep.0.or_else(|| None);\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^ help: use `or` instead: `deep.0.or(None)`\n+   |             ^^^^^^^----------------\n+   |                    |\n+   |                    help: use `or(..)` instead: `or(None)`\n \n error: unnecessary closure used to substitute value for `Option::None`\n   --> $DIR/unnecessary_lazy_eval.rs:58:13\n    |\n LL |     let _ = deep.0.get_or_insert_with(|| 2);\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `get_or_insert` instead: `deep.0.get_or_insert(2)`\n+   |             ^^^^^^^------------------------\n+   |                    |\n+   |                    help: use `get_or_insert(..)` instead: `get_or_insert(2)`\n \n error: unnecessary closure used to substitute value for `Option::None`\n   --> $DIR/unnecessary_lazy_eval.rs:59:13\n    |\n LL |     let _ = deep.0.ok_or_else(|| 2);\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^ help: use `ok_or` instead: `deep.0.ok_or(2)`\n+   |             ^^^^^^^----------------\n+   |                    |\n+   |                    help: use `ok_or(..)` instead: `ok_or(2)`\n \n error: unnecessary closure used to substitute value for `Option::None`\n   --> $DIR/unnecessary_lazy_eval.rs:79:28\n    |\n LL |     let _: Option<usize> = None.or_else(|| Some(3));\n-   |                            ^^^^^^^^^^^^^^^^^^^^^^^^ help: use `or` instead: `None.or(Some(3))`\n+   |                            ^^^^^-------------------\n+   |                                 |\n+   |                                 help: use `or(..)` instead: `or(Some(3))`\n \n error: unnecessary closure used to substitute value for `Option::None`\n   --> $DIR/unnecessary_lazy_eval.rs:80:13\n    |\n LL |     let _ = deep.0.or_else(|| Some(3));\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `or` instead: `deep.0.or(Some(3))`\n+   |             ^^^^^^^-------------------\n+   |                    |\n+   |                    help: use `or(..)` instead: `or(Some(3))`\n \n error: unnecessary closure used to substitute value for `Option::None`\n   --> $DIR/unnecessary_lazy_eval.rs:81:13\n    |\n LL |     let _ = opt.or_else(|| Some(3));\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^ help: use `or` instead: `opt.or(Some(3))`\n+   |             ^^^^-------------------\n+   |                 |\n+   |                 help: use `or(..)` instead: `or(Some(3))`\n \n error: unnecessary closure used to substitute value for `Result::Err`\n   --> $DIR/unnecessary_lazy_eval.rs:87:13\n    |\n LL |     let _ = res2.unwrap_or_else(|_| 2);\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `unwrap_or` instead: `res2.unwrap_or(2)`\n+   |             ^^^^^---------------------\n+   |                  |\n+   |                  help: use `unwrap_or(..)` instead: `unwrap_or(2)`\n \n error: unnecessary closure used to substitute value for `Result::Err`\n   --> $DIR/unnecessary_lazy_eval.rs:88:13\n    |\n LL |     let _ = res2.unwrap_or_else(|_| astronomers_pi);\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `unwrap_or` instead: `res2.unwrap_or(astronomers_pi)`\n+   |             ^^^^^----------------------------------\n+   |                  |\n+   |                  help: use `unwrap_or(..)` instead: `unwrap_or(astronomers_pi)`\n \n error: unnecessary closure used to substitute value for `Result::Err`\n   --> $DIR/unnecessary_lazy_eval.rs:89:13\n    |\n LL |     let _ = res2.unwrap_or_else(|_| ext_str.some_field);\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `unwrap_or` instead: `res2.unwrap_or(ext_str.some_field)`\n+   |             ^^^^^--------------------------------------\n+   |                  |\n+   |                  help: use `unwrap_or(..)` instead: `unwrap_or(ext_str.some_field)`\n \n error: unnecessary closure used to substitute value for `Result::Err`\n   --> $DIR/unnecessary_lazy_eval.rs:111:35\n    |\n LL |     let _: Result<usize, usize> = res.and_then(|_| Err(2));\n-   |                                   ^^^^^^^^^^^^^^^^^^^^^^^^ help: use `and` instead: `res.and(Err(2))`\n+   |                                   ^^^^--------------------\n+   |                                       |\n+   |                                       help: use `and(..)` instead: `and(Err(2))`\n \n error: unnecessary closure used to substitute value for `Result::Err`\n   --> $DIR/unnecessary_lazy_eval.rs:112:35\n    |\n LL |     let _: Result<usize, usize> = res.and_then(|_| Err(astronomers_pi));\n-   |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `and` instead: `res.and(Err(astronomers_pi))`\n+   |                                   ^^^^---------------------------------\n+   |                                       |\n+   |                                       help: use `and(..)` instead: `and(Err(astronomers_pi))`\n \n error: unnecessary closure used to substitute value for `Result::Err`\n   --> $DIR/unnecessary_lazy_eval.rs:113:35\n    |\n LL |     let _: Result<usize, usize> = res.and_then(|_| Err(ext_str.some_field));\n-   |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `and` instead: `res.and(Err(ext_str.some_field))`\n+   |                                   ^^^^-------------------------------------\n+   |                                       |\n+   |                                       help: use `and(..)` instead: `and(Err(ext_str.some_field))`\n \n error: unnecessary closure used to substitute value for `Result::Err`\n   --> $DIR/unnecessary_lazy_eval.rs:115:35\n    |\n LL |     let _: Result<usize, usize> = res.or_else(|_| Ok(2));\n-   |                                   ^^^^^^^^^^^^^^^^^^^^^^ help: use `or` instead: `res.or(Ok(2))`\n+   |                                   ^^^^------------------\n+   |                                       |\n+   |                                       help: use `or(..)` instead: `or(Ok(2))`\n \n error: unnecessary closure used to substitute value for `Result::Err`\n   --> $DIR/unnecessary_lazy_eval.rs:116:35\n    |\n LL |     let _: Result<usize, usize> = res.or_else(|_| Ok(astronomers_pi));\n-   |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `or` instead: `res.or(Ok(astronomers_pi))`\n+   |                                   ^^^^-------------------------------\n+   |                                       |\n+   |                                       help: use `or(..)` instead: `or(Ok(astronomers_pi))`\n \n error: unnecessary closure used to substitute value for `Result::Err`\n   --> $DIR/unnecessary_lazy_eval.rs:117:35\n    |\n LL |     let _: Result<usize, usize> = res.or_else(|_| Ok(ext_str.some_field));\n-   |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `or` instead: `res.or(Ok(ext_str.some_field))`\n+   |                                   ^^^^-----------------------------------\n+   |                                       |\n+   |                                       help: use `or(..)` instead: `or(Ok(ext_str.some_field))`\n \n-error: aborting due to 32 previous errors\n+error: unnecessary closure used to substitute value for `Result::Err`\n+  --> $DIR/unnecessary_lazy_eval.rs:118:35\n+   |\n+LL |       let _: Result<usize, usize> = res.\n+   |  ___________________________________^\n+LL | |         // some lines\n+LL | |         // some lines\n+LL | |         // some lines\n+...  |\n+LL | |         // some lines\n+LL | |         or_else(|_| Ok(ext_str.some_field));\n+   | |_________----------------------------------^\n+   |           |\n+   |           help: use `or(..)` instead: `or(Ok(ext_str.some_field))`\n+\n+error: aborting due to 33 previous errors\n "}, {"sha": "20acab6e844f86bb3b885956f9cecbd3d181d15e", "filename": "src/tools/clippy/tests/ui/unnecessary_lazy_eval_unfixable.stderr", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7941b3f1473331d2abb2b8796046adc0105c8f94/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_lazy_eval_unfixable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7941b3f1473331d2abb2b8796046adc0105c8f94/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_lazy_eval_unfixable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_lazy_eval_unfixable.stderr?ref=7941b3f1473331d2abb2b8796046adc0105c8f94", "patch": "@@ -2,21 +2,27 @@ error: unnecessary closure used to substitute value for `Result::Err`\n   --> $DIR/unnecessary_lazy_eval_unfixable.rs:12:13\n    |\n LL |     let _ = Ok(1).unwrap_or_else(|()| 2);\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `unwrap_or` instead: `Ok(1).unwrap_or(2)`\n+   |             ^^^^^^----------------------\n+   |                   |\n+   |                   help: use `unwrap_or(..)` instead: `unwrap_or(2)`\n    |\n    = note: `-D clippy::unnecessary-lazy-evaluations` implied by `-D warnings`\n \n error: unnecessary closure used to substitute value for `Result::Err`\n   --> $DIR/unnecessary_lazy_eval_unfixable.rs:16:13\n    |\n LL |     let _ = Ok(1).unwrap_or_else(|e::E| 2);\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `unwrap_or` instead: `Ok(1).unwrap_or(2)`\n+   |             ^^^^^^------------------------\n+   |                   |\n+   |                   help: use `unwrap_or(..)` instead: `unwrap_or(2)`\n \n error: unnecessary closure used to substitute value for `Result::Err`\n   --> $DIR/unnecessary_lazy_eval_unfixable.rs:17:13\n    |\n LL |     let _ = Ok(1).unwrap_or_else(|SomeStruct { .. }| 2);\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use `unwrap_or` instead: `Ok(1).unwrap_or(2)`\n+   |             ^^^^^^-------------------------------------\n+   |                   |\n+   |                   help: use `unwrap_or(..)` instead: `unwrap_or(2)`\n \n error: aborting due to 3 previous errors\n "}, {"sha": "38ba41ac54ecb2ca7814f135f1525b44d66a825a", "filename": "src/tools/clippy/tests/ui/unnecessary_to_owned.fixed", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/7941b3f1473331d2abb2b8796046adc0105c8f94/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_to_owned.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/7941b3f1473331d2abb2b8796046adc0105c8f94/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_to_owned.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_to_owned.fixed?ref=7941b3f1473331d2abb2b8796046adc0105c8f94", "patch": "@@ -212,3 +212,51 @@ fn get_file_path(_file_type: &FileType) -> Result<std::path::PathBuf, std::io::E\n }\n \n fn require_string(_: &String) {}\n+\n+// https://github.com/rust-lang/rust-clippy/issues/8507\n+mod issue_8507 {\n+    #![allow(dead_code)]\n+\n+    struct Opaque<P>(P);\n+\n+    pub trait Abstracted {}\n+\n+    impl<P> Abstracted for Opaque<P> {}\n+\n+    fn build<P>(p: P) -> Opaque<P>\n+    where\n+        P: AsRef<str>,\n+    {\n+        Opaque(p)\n+    }\n+\n+    // Should not lint.\n+    fn test_str(s: &str) -> Box<dyn Abstracted> {\n+        Box::new(build(s.to_string()))\n+    }\n+\n+    // Should not lint.\n+    fn test_x(x: super::X) -> Box<dyn Abstracted> {\n+        Box::new(build(x))\n+    }\n+\n+    #[derive(Clone, Copy)]\n+    struct Y(&'static str);\n+\n+    impl AsRef<str> for Y {\n+        fn as_ref(&self) -> &str {\n+            self.0\n+        }\n+    }\n+\n+    impl ToString for Y {\n+        fn to_string(&self) -> String {\n+            self.0.to_string()\n+        }\n+    }\n+\n+    // Should lint because Y is copy.\n+    fn test_y(y: Y) -> Box<dyn Abstracted> {\n+        Box::new(build(y))\n+    }\n+}"}, {"sha": "15fb7ee83e3d100a50cfa13dfd54cf12afcd7cd0", "filename": "src/tools/clippy/tests/ui/unnecessary_to_owned.rs", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/7941b3f1473331d2abb2b8796046adc0105c8f94/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_to_owned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7941b3f1473331d2abb2b8796046adc0105c8f94/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_to_owned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_to_owned.rs?ref=7941b3f1473331d2abb2b8796046adc0105c8f94", "patch": "@@ -212,3 +212,51 @@ fn get_file_path(_file_type: &FileType) -> Result<std::path::PathBuf, std::io::E\n }\n \n fn require_string(_: &String) {}\n+\n+// https://github.com/rust-lang/rust-clippy/issues/8507\n+mod issue_8507 {\n+    #![allow(dead_code)]\n+\n+    struct Opaque<P>(P);\n+\n+    pub trait Abstracted {}\n+\n+    impl<P> Abstracted for Opaque<P> {}\n+\n+    fn build<P>(p: P) -> Opaque<P>\n+    where\n+        P: AsRef<str>,\n+    {\n+        Opaque(p)\n+    }\n+\n+    // Should not lint.\n+    fn test_str(s: &str) -> Box<dyn Abstracted> {\n+        Box::new(build(s.to_string()))\n+    }\n+\n+    // Should not lint.\n+    fn test_x(x: super::X) -> Box<dyn Abstracted> {\n+        Box::new(build(x))\n+    }\n+\n+    #[derive(Clone, Copy)]\n+    struct Y(&'static str);\n+\n+    impl AsRef<str> for Y {\n+        fn as_ref(&self) -> &str {\n+            self.0\n+        }\n+    }\n+\n+    impl ToString for Y {\n+        fn to_string(&self) -> String {\n+            self.0.to_string()\n+        }\n+    }\n+\n+    // Should lint because Y is copy.\n+    fn test_y(y: Y) -> Box<dyn Abstracted> {\n+        Box::new(build(y.to_string()))\n+    }\n+}"}, {"sha": "c53ce32be775706f91d4ce47b2e4b5bd4220abd9", "filename": "src/tools/clippy/tests/ui/unnecessary_to_owned.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7941b3f1473331d2abb2b8796046adc0105c8f94/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_to_owned.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7941b3f1473331d2abb2b8796046adc0105c8f94/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_to_owned.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_to_owned.stderr?ref=7941b3f1473331d2abb2b8796046adc0105c8f94", "patch": "@@ -491,5 +491,11 @@ LL -         let path = match get_file_path(&t) {\n LL +         let path = match get_file_path(t) {\n    | \n \n-error: aborting due to 76 previous errors\n+error: unnecessary use of `to_string`\n+  --> $DIR/unnecessary_to_owned.rs:260:24\n+   |\n+LL |         Box::new(build(y.to_string()))\n+   |                        ^^^^^^^^^^^^^ help: use: `y`\n+\n+error: aborting due to 77 previous errors\n "}]}