{"sha": "025b7c433c109dad2c84f1cbeae422a3ffbd01b6", "node_id": "C_kwDOAAsO6NoAKDAyNWI3YzQzM2MxMDlkYWQyYzg0ZjFjYmVhZTQyMmEzZmZiZDAxYjY", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-02-22T03:49:15Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-02-28T03:27:50Z"}, "message": "fix ICE when passing empty block to while-loop condition", "tree": {"sha": "bf23d61d106259c1515fd543af2c8494df1d47a9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bf23d61d106259c1515fd543af2c8494df1d47a9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/025b7c433c109dad2c84f1cbeae422a3ffbd01b6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/025b7c433c109dad2c84f1cbeae422a3ffbd01b6", "html_url": "https://github.com/rust-lang/rust/commit/025b7c433c109dad2c84f1cbeae422a3ffbd01b6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/025b7c433c109dad2c84f1cbeae422a3ffbd01b6/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d973b358c6dc5261f9c13e4ef7f9ab58586d628e", "url": "https://api.github.com/repos/rust-lang/rust/commits/d973b358c6dc5261f9c13e4ef7f9ab58586d628e", "html_url": "https://github.com/rust-lang/rust/commit/d973b358c6dc5261f9c13e4ef7f9ab58586d628e"}], "stats": {"total": 182, "additions": 111, "deletions": 71}, "files": [{"sha": "15284dc008f507e5d3fb301607284e51a520028b", "filename": "compiler/rustc_typeck/src/check/expr.rs", "status": "modified", "additions": 24, "deletions": 11, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/025b7c433c109dad2c84f1cbeae422a3ffbd01b6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025b7c433c109dad2c84f1cbeae422a3ffbd01b6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs?ref=025b7c433c109dad2c84f1cbeae422a3ffbd01b6", "patch": "@@ -842,7 +842,27 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         );\n         err.span_label(lhs.span, \"cannot assign to this expression\");\n \n-        let mut parent = self.tcx.hir().get_parent_node(lhs.hir_id);\n+        self.comes_from_while_condition(lhs.hir_id, |expr| {\n+            err.span_suggestion_verbose(\n+                expr.span.shrink_to_lo(),\n+                \"you might have meant to use pattern destructuring\",\n+                \"let \".to_string(),\n+                Applicability::MachineApplicable,\n+            );\n+        });\n+\n+        err.emit();\n+    }\n+\n+    // Check if an expression `original_expr_id` comes from the condition of a while loop,\n+    // as opposed from the body of a while loop, which we can naively check by iterating\n+    // parents until we find a loop...\n+    pub(super) fn comes_from_while_condition(\n+        &self,\n+        original_expr_id: HirId,\n+        then: impl FnOnce(&hir::Expr<'_>),\n+    ) {\n+        let mut parent = self.tcx.hir().get_parent_node(original_expr_id);\n         while let Some(node) = self.tcx.hir().find(parent) {\n             match node {\n                 hir::Node::Expr(hir::Expr {\n@@ -863,21 +883,16 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         ),\n                     ..\n                 }) => {\n-                    // Check if our lhs is a child of the condition of a while loop\n-                    let expr_is_ancestor = std::iter::successors(Some(lhs.hir_id), |id| {\n+                    // Check if our original expression is a child of the condition of a while loop\n+                    let expr_is_ancestor = std::iter::successors(Some(original_expr_id), |id| {\n                         self.tcx.hir().find_parent_node(*id)\n                     })\n                     .take_while(|id| *id != parent)\n                     .any(|id| id == expr.hir_id);\n                     // if it is, then we have a situation like `while Some(0) = value.get(0) {`,\n                     // where `while let` was more likely intended.\n                     if expr_is_ancestor {\n-                        err.span_suggestion_verbose(\n-                            expr.span.shrink_to_lo(),\n-                            \"you might have meant to use pattern destructuring\",\n-                            \"let \".to_string(),\n-                            Applicability::MachineApplicable,\n-                        );\n+                        then(expr);\n                     }\n                     break;\n                 }\n@@ -890,8 +905,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 }\n             }\n         }\n-\n-        err.emit();\n     }\n \n     // A generic function for checking the 'then' and 'else' clauses in an 'if'"}, {"sha": "769b0f191012ce8b15c70f41cccf8d27b78fa182", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/checks.rs", "status": "modified", "additions": 74, "deletions": 60, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/025b7c433c109dad2c84f1cbeae422a3ffbd01b6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025b7c433c109dad2c84f1cbeae422a3ffbd01b6/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs?ref=025b7c433c109dad2c84f1cbeae422a3ffbd01b6", "patch": "@@ -770,55 +770,57 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let prev_diverges = self.diverges.get();\n         let ctxt = BreakableCtxt { coerce: Some(coerce), may_break: false };\n \n-        let (ctxt, ()) = self.with_breakable_ctxt(blk.hir_id, ctxt, || {\n-            for (pos, s) in blk.stmts.iter().enumerate() {\n-                self.check_stmt(s, blk.stmts.len() - 1 == pos);\n-            }\n+        let (ctxt, ()) =\n+            self.with_breakable_ctxt(blk.hir_id, ctxt, || {\n+                for (pos, s) in blk.stmts.iter().enumerate() {\n+                    self.check_stmt(s, blk.stmts.len() - 1 == pos);\n+                }\n \n-            // check the tail expression **without** holding the\n-            // `enclosing_breakables` lock below.\n-            let tail_expr_ty = tail_expr.map(|t| self.check_expr_with_expectation(t, expected));\n-\n-            let mut enclosing_breakables = self.enclosing_breakables.borrow_mut();\n-            let ctxt = enclosing_breakables.find_breakable(blk.hir_id);\n-            let coerce = ctxt.coerce.as_mut().unwrap();\n-            if let Some(tail_expr_ty) = tail_expr_ty {\n-                let tail_expr = tail_expr.unwrap();\n-                let span = self.get_expr_coercion_span(tail_expr);\n-                let cause = self.cause(span, ObligationCauseCode::BlockTailExpression(blk.hir_id));\n-                coerce.coerce(self, &cause, tail_expr, tail_expr_ty);\n-            } else {\n-                // Subtle: if there is no explicit tail expression,\n-                // that is typically equivalent to a tail expression\n-                // of `()` -- except if the block diverges. In that\n-                // case, there is no value supplied from the tail\n-                // expression (assuming there are no other breaks,\n-                // this implies that the type of the block will be\n-                // `!`).\n-                //\n-                // #41425 -- label the implicit `()` as being the\n-                // \"found type\" here, rather than the \"expected type\".\n-                if !self.diverges.get().is_always() {\n-                    // #50009 -- Do not point at the entire fn block span, point at the return type\n-                    // span, as it is the cause of the requirement, and\n-                    // `consider_hint_about_removing_semicolon` will point at the last expression\n-                    // if it were a relevant part of the error. This improves usability in editors\n-                    // that highlight errors inline.\n-                    let mut sp = blk.span;\n-                    let mut fn_span = None;\n-                    if let Some((decl, ident)) = self.get_parent_fn_decl(blk.hir_id) {\n-                        let ret_sp = decl.output.span();\n-                        if let Some(block_sp) = self.parent_item_span(blk.hir_id) {\n-                            // HACK: on some cases (`ui/liveness/liveness-issue-2163.rs`) the\n-                            // output would otherwise be incorrect and even misleading. Make sure\n-                            // the span we're aiming at correspond to a `fn` body.\n-                            if block_sp == blk.span {\n-                                sp = ret_sp;\n-                                fn_span = Some(ident.span);\n+                // check the tail expression **without** holding the\n+                // `enclosing_breakables` lock below.\n+                let tail_expr_ty = tail_expr.map(|t| self.check_expr_with_expectation(t, expected));\n+\n+                let mut enclosing_breakables = self.enclosing_breakables.borrow_mut();\n+                let ctxt = enclosing_breakables.find_breakable(blk.hir_id);\n+                let coerce = ctxt.coerce.as_mut().unwrap();\n+                if let Some(tail_expr_ty) = tail_expr_ty {\n+                    let tail_expr = tail_expr.unwrap();\n+                    let span = self.get_expr_coercion_span(tail_expr);\n+                    let cause =\n+                        self.cause(span, ObligationCauseCode::BlockTailExpression(blk.hir_id));\n+                    coerce.coerce(self, &cause, tail_expr, tail_expr_ty);\n+                } else {\n+                    // Subtle: if there is no explicit tail expression,\n+                    // that is typically equivalent to a tail expression\n+                    // of `()` -- except if the block diverges. In that\n+                    // case, there is no value supplied from the tail\n+                    // expression (assuming there are no other breaks,\n+                    // this implies that the type of the block will be\n+                    // `!`).\n+                    //\n+                    // #41425 -- label the implicit `()` as being the\n+                    // \"found type\" here, rather than the \"expected type\".\n+                    if !self.diverges.get().is_always() {\n+                        // #50009 -- Do not point at the entire fn block span, point at the return type\n+                        // span, as it is the cause of the requirement, and\n+                        // `consider_hint_about_removing_semicolon` will point at the last expression\n+                        // if it were a relevant part of the error. This improves usability in editors\n+                        // that highlight errors inline.\n+                        let mut sp = blk.span;\n+                        let mut fn_span = None;\n+                        if let Some((decl, ident)) = self.get_parent_fn_decl(blk.hir_id) {\n+                            let ret_sp = decl.output.span();\n+                            if let Some(block_sp) = self.parent_item_span(blk.hir_id) {\n+                                // HACK: on some cases (`ui/liveness/liveness-issue-2163.rs`) the\n+                                // output would otherwise be incorrect and even misleading. Make sure\n+                                // the span we're aiming at correspond to a `fn` body.\n+                                if block_sp == blk.span {\n+                                    sp = ret_sp;\n+                                    fn_span = Some(ident.span);\n+                                }\n                             }\n                         }\n-                    }\n-                    coerce.coerce_forced_unit(\n+                        coerce.coerce_forced_unit(\n                         self,\n                         &self.misc(sp),\n                         &mut |err| {\n@@ -827,19 +829,31 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 if expected_ty == self.tcx.types.bool {\n                                     // If this is caused by a missing `let` in a `while let`,\n                                     // silence this redundant error, as we already emit E0070.\n-                                    let parent = self.tcx.hir().get_parent_node(blk.hir_id);\n-                                    let parent = self.tcx.hir().get_parent_node(parent);\n-                                    let parent = self.tcx.hir().get_parent_node(parent);\n-                                    let parent = self.tcx.hir().get_parent_node(parent);\n-                                    let parent = self.tcx.hir().get_parent_node(parent);\n-                                    match self.tcx.hir().find(parent) {\n-                                        Some(hir::Node::Expr(hir::Expr {\n-                                            kind: hir::ExprKind::Loop(_, _, hir::LoopSource::While, _),\n-                                            ..\n-                                        })) => {\n+\n+                                    // Our block must be a `assign desugar local; assignment`\n+                                    if let Some(hir::Node::Block(hir::Block {\n+                                        stmts:\n+                                            [hir::Stmt {\n+                                                kind:\n+                                                    hir::StmtKind::Local(hir::Local {\n+                                                        source: hir::LocalSource::AssignDesugar(_),\n+                                                        ..\n+                                                    }),\n+                                                ..\n+                                            }, hir::Stmt {\n+                                                kind:\n+                                                    hir::StmtKind::Expr(hir::Expr {\n+                                                        kind: hir::ExprKind::Assign(..),\n+                                                        ..\n+                                                    }),\n+                                                ..\n+                                            }],\n+                                        ..\n+                                    })) = self.tcx.hir().find(blk.hir_id)\n+                                    {\n+                                        self.comes_from_while_condition(blk.hir_id, |_| {\n                                             err.downgrade_to_delayed_bug();\n-                                        }\n-                                        _ => {}\n+                                        })\n                                     }\n                                 }\n                             }\n@@ -853,9 +867,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         },\n                         false,\n                     );\n+                    }\n                 }\n-            }\n-        });\n+            });\n \n         if ctxt.may_break {\n             // If we can break from the block, then the block's exit is always reachable"}, {"sha": "929759766f279f8707806036e838931ae59960bc", "filename": "src/test/ui/typeck/while-loop-block-cond.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/025b7c433c109dad2c84f1cbeae422a3ffbd01b6/src%2Ftest%2Fui%2Ftypeck%2Fwhile-loop-block-cond.rs", "raw_url": "https://github.com/rust-lang/rust/raw/025b7c433c109dad2c84f1cbeae422a3ffbd01b6/src%2Ftest%2Fui%2Ftypeck%2Fwhile-loop-block-cond.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fwhile-loop-block-cond.rs?ref=025b7c433c109dad2c84f1cbeae422a3ffbd01b6", "patch": "@@ -0,0 +1,4 @@\n+fn main() {\n+    while {} {}\n+    //~^ ERROR mismatched types [E0308]\n+}"}, {"sha": "598273af9cfc4c5d6f70e44eff0c1b3d00f94b03", "filename": "src/test/ui/typeck/while-loop-block-cond.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/025b7c433c109dad2c84f1cbeae422a3ffbd01b6/src%2Ftest%2Fui%2Ftypeck%2Fwhile-loop-block-cond.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/025b7c433c109dad2c84f1cbeae422a3ffbd01b6/src%2Ftest%2Fui%2Ftypeck%2Fwhile-loop-block-cond.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fwhile-loop-block-cond.stderr?ref=025b7c433c109dad2c84f1cbeae422a3ffbd01b6", "patch": "@@ -0,0 +1,9 @@\n+error[E0308]: mismatched types\n+  --> $DIR/while-loop-block-cond.rs:2:11\n+   |\n+LL |     while {} {}\n+   |           ^^ expected `bool`, found `()`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}]}