{"sha": "19630ead410873a08b271606b8ac5a27029d70b6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE5NjMwZWFkNDEwODczYTA4YjI3MTYwNmI4YWM1YTI3MDI5ZDcwYjY=", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2021-01-15T14:36:15Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2021-01-27T09:05:05Z"}, "message": "Remove cache usage wherever possible", "tree": {"sha": "f297d2b1517dabaaf54b3591df918c08847641b6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f297d2b1517dabaaf54b3591df918c08847641b6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/19630ead410873a08b271606b8ac5a27029d70b6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/19630ead410873a08b271606b8ac5a27029d70b6", "html_url": "https://github.com/rust-lang/rust/commit/19630ead410873a08b271606b8ac5a27029d70b6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/19630ead410873a08b271606b8ac5a27029d70b6/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c448270099444486cdf3c22bc841a5c673d9da4f", "url": "https://api.github.com/repos/rust-lang/rust/commits/c448270099444486cdf3c22bc841a5c673d9da4f", "html_url": "https://github.com/rust-lang/rust/commit/c448270099444486cdf3c22bc841a5c673d9da4f"}], "stats": {"total": 345, "additions": 179, "deletions": 166}, "files": [{"sha": "1f9e7f8ae5cd424be37326c3fc198a1c336b03e4", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/19630ead410873a08b271606b8ac5a27029d70b6/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19630ead410873a08b271606b8ac5a27029d70b6/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=19630ead410873a08b271606b8ac5a27029d70b6", "patch": "@@ -368,7 +368,7 @@ crate fn build_impl(\n     // Only inline impl if the implementing type is\n     // reachable in rustdoc generated documentation\n     if !did.is_local() {\n-        if let Some(did) = for_.def_id(&cx.cache) {\n+        if let Some(did) = for_.def_id() {\n             if !cx.renderinfo.borrow().access_levels.is_public(did) {\n                 return;\n             }\n@@ -410,19 +410,19 @@ crate fn build_impl(\n         clean::GenericBound::TraitBound(polyt, _) => polyt.trait_,\n         clean::GenericBound::Outlives(..) => unreachable!(),\n     });\n-    if trait_.def_id(&cx.cache) == tcx.lang_items().deref_trait() {\n+    if trait_.def_id() == tcx.lang_items().deref_trait() {\n         super::build_deref_target_impls(cx, &trait_items, ret);\n     }\n-    if let Some(trait_did) = trait_.def_id(&cx.cache) {\n+    if let Some(trait_did) = trait_.def_id() {\n         record_extern_trait(cx, trait_did);\n     }\n \n     let provided = trait_\n-        .def_id(&cx.cache)\n+        .def_id()\n         .map(|did| tcx.provided_trait_methods(did).map(|meth| meth.ident.name).collect())\n         .unwrap_or_default();\n \n-    debug!(\"build_impl: impl {:?} for {:?}\", trait_.def_id(&cx.cache), for_.def_id(&cx.cache));\n+    debug!(\"build_impl: impl {:?} for {:?}\", trait_.def_id(), for_.def_id());\n \n     let mut item = clean::Item::from_def_id_and_parts(\n         did,"}, {"sha": "03454bb8b7ff08a110aace63c353d59ef1c7e1be", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/19630ead410873a08b271606b8ac5a27029d70b6/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19630ead410873a08b271606b8ac5a27029d70b6/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=19630ead410873a08b271606b8ac5a27029d70b6", "patch": "@@ -2089,17 +2089,17 @@ fn clean_impl(impl_: &hir::Impl<'_>, hir_id: hir::HirId, cx: &DocContext<'_>) ->\n \n     // If this impl block is an implementation of the Deref trait, then we\n     // need to try inlining the target's inherent impl blocks as well.\n-    if trait_.def_id(&cx.cache) == cx.tcx.lang_items().deref_trait() {\n+    if trait_.def_id() == cx.tcx.lang_items().deref_trait() {\n         build_deref_target_impls(cx, &items, &mut ret);\n     }\n \n     let provided: FxHashSet<Symbol> = trait_\n-        .def_id(&cx.cache)\n+        .def_id()\n         .map(|did| cx.tcx.provided_trait_methods(did).map(|meth| meth.ident.name).collect())\n         .unwrap_or_default();\n \n     let for_ = impl_.self_ty.clean(cx);\n-    let type_alias = for_.def_id(&cx.cache).and_then(|did| match cx.tcx.def_kind(did) {\n+    let type_alias = for_.def_id().and_then(|did| match cx.tcx.def_kind(did) {\n         DefKind::TyAlias => Some(cx.tcx.type_of(did).clean(cx)),\n         _ => None,\n     });"}, {"sha": "1e3c3a23c988411d56016a8e29da3a2abae0c9d5", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 57, "deletions": 21, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/19630ead410873a08b271606b8ac5a27029d70b6/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19630ead410873a08b271606b8ac5a27029d70b6/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=19630ead410873a08b271606b8ac5a27029d70b6", "patch": "@@ -958,7 +958,7 @@ impl GenericBound {\n     crate fn is_sized_bound(&self, cx: &DocContext<'_>) -> bool {\n         use rustc_hir::TraitBoundModifier as TBM;\n         if let GenericBound::TraitBound(PolyTrait { ref trait_, .. }, TBM::None) = *self {\n-            if trait_.def_id(&cx.cache) == cx.tcx.lang_items().sized_trait() {\n+            if trait_.def_id() == cx.tcx.lang_items().sized_trait() {\n                 return true;\n             }\n         }\n@@ -1171,9 +1171,16 @@ crate enum FnRetTy {\n }\n \n impl GetDefId for FnRetTy {\n-    fn def_id(&self, cache: &Cache) -> Option<DefId> {\n+    fn def_id(&self) -> Option<DefId> {\n         match *self {\n-            Return(ref ty) => ty.def_id(cache),\n+            Return(ref ty) => ty.def_id(),\n+            DefaultReturn => None,\n+        }\n+    }\n+\n+    fn def_id_full(&self, cache: &Cache) -> Option<DefId> {\n+        match *self {\n+            Return(ref ty) => ty.def_id_full(cache),\n             DefaultReturn => None,\n         }\n     }\n@@ -1299,12 +1306,20 @@ crate enum TypeKind {\n }\n \n crate trait GetDefId {\n-    fn def_id(&self, cache: &Cache) -> Option<DefId>;\n+    /// Doesn't retrieve primitive types `DefId`. Use `def_id_full` if you want it.\n+    fn def_id(&self) -> Option<DefId>;\n+    /// Retrieves all types' `DefId` (including primitives). If you're not interested about\n+    /// primitives, use `def_id`.\n+    fn def_id_full(&self, cache: &Cache) -> Option<DefId>;\n }\n \n impl<T: GetDefId> GetDefId for Option<T> {\n-    fn def_id(&self, cache: &Cache) -> Option<DefId> {\n-        self.as_ref().and_then(|d| d.def_id(cache))\n+    fn def_id(&self) -> Option<DefId> {\n+        self.as_ref().and_then(|d| d.def_id())\n+    }\n+\n+    fn def_id_full(&self, cache: &Cache) -> Option<DefId> {\n+        self.as_ref().and_then(|d| d.def_id_full(cache))\n     }\n }\n \n@@ -1393,33 +1408,50 @@ impl Type {\n     }\n }\n \n-impl GetDefId for Type {\n-    fn def_id(&self, cache: &Cache) -> Option<DefId> {\n+impl Type {\n+    fn inner_def_id(&self, cache: Option<&Cache>) -> Option<DefId> {\n+        fn inner<T: GetDefId>(t: &T, cache: Option<&Cache>) -> Option<DefId> {\n+            match cache {\n+                Some(c) => t.def_id_full(c),\n+                None => t.def_id(),\n+            }\n+        }\n+\n         match *self {\n             ResolvedPath { did, .. } => Some(did),\n-            Primitive(p) => cache.primitive_locations.get(&p).cloned(),\n+            Primitive(p) => cache.and_then(|c| c.primitive_locations.get(&p).cloned()),\n             BorrowedRef { type_: box Generic(..), .. } => {\n-                Primitive(PrimitiveType::Reference).def_id(cache)\n+                inner(&Primitive(PrimitiveType::Reference), cache)\n             }\n-            BorrowedRef { ref type_, .. } => type_.def_id(cache),\n+            BorrowedRef { ref type_, .. } => inner(&**type_, cache),\n             Tuple(ref tys) => {\n                 if tys.is_empty() {\n-                    Primitive(PrimitiveType::Unit).def_id(cache)\n+                    inner(&Primitive(PrimitiveType::Unit), cache)\n                 } else {\n-                    Primitive(PrimitiveType::Tuple).def_id(cache)\n+                    inner(&Primitive(PrimitiveType::Tuple), cache)\n                 }\n             }\n-            BareFunction(..) => Primitive(PrimitiveType::Fn).def_id(cache),\n-            Never => Primitive(PrimitiveType::Never).def_id(cache),\n-            Slice(..) => Primitive(PrimitiveType::Slice).def_id(cache),\n-            Array(..) => Primitive(PrimitiveType::Array).def_id(cache),\n-            RawPointer(..) => Primitive(PrimitiveType::RawPointer).def_id(cache),\n-            QPath { ref self_type, .. } => self_type.def_id(cache),\n+            BareFunction(..) => inner(&Primitive(PrimitiveType::Fn), cache),\n+            Never => inner(&Primitive(PrimitiveType::Never), cache),\n+            Slice(..) => inner(&Primitive(PrimitiveType::Slice), cache),\n+            Array(..) => inner(&Primitive(PrimitiveType::Array), cache),\n+            RawPointer(..) => inner(&Primitive(PrimitiveType::RawPointer), cache),\n+            QPath { ref self_type, .. } => inner(&**self_type, cache),\n             _ => None,\n         }\n     }\n }\n \n+impl GetDefId for Type {\n+    fn def_id(&self) -> Option<DefId> {\n+        self.inner_def_id(None)\n+    }\n+\n+    fn def_id_full(&self, cache: &Cache) -> Option<DefId> {\n+        self.inner_def_id(Some(cache))\n+    }\n+}\n+\n impl PrimitiveType {\n     crate fn from_hir(prim: hir::PrimTy) -> PrimitiveType {\n         match prim {\n@@ -1814,8 +1846,12 @@ crate struct Typedef {\n }\n \n impl GetDefId for Typedef {\n-    fn def_id(&self, cache: &Cache) -> Option<DefId> {\n-        self.type_.def_id(cache)\n+    fn def_id(&self) -> Option<DefId> {\n+        self.type_.def_id()\n+    }\n+\n+    fn def_id_full(&self, cache: &Cache) -> Option<DefId> {\n+        self.type_.def_id_full(cache)\n     }\n }\n "}, {"sha": "869d48fc25e07b8ce2d03d6a444a3ba279051b81", "filename": "src/librustdoc/clean/utils.rs", "status": "modified", "additions": 7, "deletions": 17, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/19630ead410873a08b271606b8ac5a27029d70b6/src%2Flibrustdoc%2Fclean%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19630ead410873a08b271606b8ac5a27029d70b6/src%2Flibrustdoc%2Fclean%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Futils.rs?ref=19630ead410873a08b271606b8ac5a27029d70b6", "patch": "@@ -179,9 +179,7 @@ crate fn get_real_types(\n     if arg.is_full_generic() {\n         let arg_s = Symbol::intern(&arg.print(&cx.cache).to_string());\n         if let Some(where_pred) = generics.where_predicates.iter().find(|g| match g {\n-            WherePredicate::BoundPredicate { ty, .. } => {\n-                ty.def_id(&cx.cache) == arg.def_id(&cx.cache)\n-            }\n+            WherePredicate::BoundPredicate { ty, .. } => ty.def_id() == arg.def_id(),\n             _ => false,\n         }) {\n             let bounds = where_pred.get_bounds().unwrap_or_else(|| &[]);\n@@ -197,7 +195,7 @@ crate fn get_real_types(\n                                 res.extend(adds);\n                             } else if !ty.is_full_generic() {\n                                 if let Some(kind) =\n-                                    ty.def_id(&cx.cache).map(|did| cx.tcx.def_kind(did).clean(cx))\n+                                    ty.def_id().map(|did| cx.tcx.def_kind(did).clean(cx))\n                                 {\n                                     res.insert((ty, kind));\n                                 }\n@@ -214,17 +212,15 @@ crate fn get_real_types(\n                     if !adds.is_empty() {\n                         res.extend(adds);\n                     } else if !ty.is_full_generic() {\n-                        if let Some(kind) =\n-                            ty.def_id(&cx.cache).map(|did| cx.tcx.def_kind(did).clean(cx))\n-                        {\n+                        if let Some(kind) = ty.def_id().map(|did| cx.tcx.def_kind(did).clean(cx)) {\n                             res.insert((ty.clone(), kind));\n                         }\n                     }\n                 }\n             }\n         }\n     } else {\n-        if let Some(kind) = arg.def_id(&cx.cache).map(|did| cx.tcx.def_kind(did).clean(cx)) {\n+        if let Some(kind) = arg.def_id().map(|did| cx.tcx.def_kind(did).clean(cx)) {\n             res.insert((arg.clone(), kind));\n         }\n         if let Some(gens) = arg.generics() {\n@@ -234,9 +230,7 @@ crate fn get_real_types(\n                     if !adds.is_empty() {\n                         res.extend(adds);\n                     }\n-                } else if let Some(kind) =\n-                    gen.def_id(&cx.cache).map(|did| cx.tcx.def_kind(did).clean(cx))\n-                {\n+                } else if let Some(kind) = gen.def_id().map(|did| cx.tcx.def_kind(did).clean(cx)) {\n                     res.insert((gen.clone(), kind));\n                 }\n             }\n@@ -263,9 +257,7 @@ crate fn get_all_types(\n         if !args.is_empty() {\n             all_types.extend(args);\n         } else {\n-            if let Some(kind) =\n-                arg.type_.def_id(&cx.cache).map(|did| cx.tcx.def_kind(did).clean(cx))\n-            {\n+            if let Some(kind) = arg.type_.def_id().map(|did| cx.tcx.def_kind(did).clean(cx)) {\n                 all_types.insert((arg.type_.clone(), kind));\n             }\n         }\n@@ -275,9 +267,7 @@ crate fn get_all_types(\n         FnRetTy::Return(ref return_type) => {\n             let mut ret = get_real_types(generics, &return_type, cx, 0);\n             if ret.is_empty() {\n-                if let Some(kind) =\n-                    return_type.def_id(&cx.cache).map(|did| cx.tcx.def_kind(did).clean(cx))\n-                {\n+                if let Some(kind) = return_type.def_id().map(|did| cx.tcx.def_kind(did).clean(cx)) {\n                     ret.insert((return_type.clone(), kind));\n                 }\n             }"}, {"sha": "c506f5a37b15baf8be82405d6fc64a439c317c04", "filename": "src/librustdoc/formats/cache.rs", "status": "modified", "additions": 48, "deletions": 69, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/19630ead410873a08b271606b8ac5a27029d70b6/src%2Flibrustdoc%2Fformats%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19630ead410873a08b271606b8ac5a27029d70b6/src%2Flibrustdoc%2Fformats%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Fcache.rs?ref=19630ead410873a08b271606b8ac5a27029d70b6", "patch": "@@ -194,10 +194,7 @@ impl Cache {\n \n         cache.stack.push(krate.name.to_string());\n \n-        krate = {\n-            let mut cache_wrapper = CacheWrapper { cache: &mut cache, tmp_cache: Cache::default() };\n-            cache_wrapper.fold_crate(krate)\n-        };\n+        krate = cache.fold_crate(krate);\n \n         for (trait_did, dids, impl_) in cache.orphan_trait_impls.drain(..) {\n             if cache.traits.contains_key(&trait_did) {\n@@ -211,15 +208,7 @@ impl Cache {\n     }\n }\n \n-/// This struct is needed because we need to use an empty `Cache` for all functions requiring\n-/// a `Cache`. If we use the already filled one (`cache` in here), it'll provide information\n-/// about implementations that aren't related to the type being checked.\n-struct CacheWrapper<'a> {\n-    cache: &'a mut Cache,\n-    tmp_cache: Cache,\n-}\n-\n-impl<'a> DocFolder for CacheWrapper<'a> {\n+impl DocFolder for Cache {\n     fn fold_item(&mut self, item: clean::Item) -> Option<clean::Item> {\n         if item.def_id.is_local() {\n             debug!(\"folding {} \\\"{:?}\\\", id {:?}\", item.type_(), item.name, item.def_id);\n@@ -229,21 +218,17 @@ impl<'a> DocFolder for CacheWrapper<'a> {\n         // we don't want it or its children in the search index.\n         let orig_stripped_mod = match *item.kind {\n             clean::StrippedItem(box clean::ModuleItem(..)) => {\n-                mem::replace(&mut self.cache.stripped_mod, true)\n+                mem::replace(&mut self.stripped_mod, true)\n             }\n-            _ => self.cache.stripped_mod,\n+            _ => self.stripped_mod,\n         };\n \n         // If the impl is from a masked crate or references something from a\n         // masked crate then remove it completely.\n         if let clean::ImplItem(ref i) = *item.kind {\n-            if self.cache.masked_crates.contains(&item.def_id.krate)\n-                || i.trait_\n-                    .def_id(&self.tmp_cache)\n-                    .map_or(false, |d| self.cache.masked_crates.contains(&d.krate))\n-                || i.for_\n-                    .def_id(&self.tmp_cache)\n-                    .map_or(false, |d| self.cache.masked_crates.contains(&d.krate))\n+            if self.masked_crates.contains(&item.def_id.krate)\n+                || i.trait_.def_id().map_or(false, |d| self.masked_crates.contains(&d.krate))\n+                || i.for_.def_id().map_or(false, |d| self.masked_crates.contains(&d.krate))\n             {\n                 return None;\n             }\n@@ -252,15 +237,14 @@ impl<'a> DocFolder for CacheWrapper<'a> {\n         // Propagate a trait method's documentation to all implementors of the\n         // trait.\n         if let clean::TraitItem(ref t) = *item.kind {\n-            self.cache.traits.entry(item.def_id).or_insert_with(|| t.clone());\n+            self.traits.entry(item.def_id).or_insert_with(|| t.clone());\n         }\n \n         // Collect all the implementors of traits.\n         if let clean::ImplItem(ref i) = *item.kind {\n-            if let Some(did) = i.trait_.def_id(&self.tmp_cache) {\n+            if let Some(did) = i.trait_.def_id() {\n                 if i.blanket_impl.is_none() {\n-                    self.cache\n-                        .implementors\n+                    self.implementors\n                         .entry(did)\n                         .or_default()\n                         .push(Impl { impl_item: item.clone() });\n@@ -273,7 +257,7 @@ impl<'a> DocFolder for CacheWrapper<'a> {\n             let (parent, is_inherent_impl_item) = match *item.kind {\n                 clean::StrippedItem(..) => ((None, None), false),\n                 clean::AssocConstItem(..) | clean::TypedefItem(_, true)\n-                    if self.cache.parent_is_trait_impl =>\n+                    if self.parent_is_trait_impl =>\n                 {\n                     // skip associated items in trait impls\n                     ((None, None), false)\n@@ -283,18 +267,18 @@ impl<'a> DocFolder for CacheWrapper<'a> {\n                 | clean::StructFieldItem(..)\n                 | clean::VariantItem(..) => (\n                     (\n-                        Some(*self.cache.parent_stack.last().expect(\"parent_stack is empty\")),\n-                        Some(&self.cache.stack[..self.cache.stack.len() - 1]),\n+                        Some(*self.parent_stack.last().expect(\"parent_stack is empty\")),\n+                        Some(&self.stack[..self.stack.len() - 1]),\n                     ),\n                     false,\n                 ),\n                 clean::MethodItem(..) | clean::AssocConstItem(..) => {\n-                    if self.cache.parent_stack.is_empty() {\n+                    if self.parent_stack.is_empty() {\n                         ((None, None), false)\n                     } else {\n-                        let last = self.cache.parent_stack.last().expect(\"parent_stack is empty 2\");\n+                        let last = self.parent_stack.last().expect(\"parent_stack is empty 2\");\n                         let did = *last;\n-                        let path = match self.cache.paths.get(&did) {\n+                        let path = match self.paths.get(&did) {\n                             // The current stack not necessarily has correlation\n                             // for where the type was defined. On the other\n                             // hand, `paths` always has the right\n@@ -306,24 +290,24 @@ impl<'a> DocFolder for CacheWrapper<'a> {\n                                 | ItemType::Union\n                                 | ItemType::Enum,\n                             )) => Some(&fqp[..fqp.len() - 1]),\n-                            Some(..) => Some(&*self.cache.stack),\n+                            Some(..) => Some(&*self.stack),\n                             None => None,\n                         };\n                         ((Some(*last), path), true)\n                     }\n                 }\n-                _ => ((None, Some(&*self.cache.stack)), false),\n+                _ => ((None, Some(&*self.stack)), false),\n             };\n \n             match parent {\n-                (parent, Some(path)) if is_inherent_impl_item || !self.cache.stripped_mod => {\n+                (parent, Some(path)) if is_inherent_impl_item || !self.stripped_mod => {\n                     debug_assert!(!item.is_stripped());\n \n                     // A crate has a module at its root, containing all items,\n                     // which should not be indexed. The crate-item itself is\n                     // inserted later on when serializing the search-index.\n                     if item.def_id.index != CRATE_DEF_INDEX {\n-                        self.cache.search_index.push(IndexItem {\n+                        self.search_index.push(IndexItem {\n                             ty: item.type_(),\n                             name: s.to_string(),\n                             path: path.join(\"::\"),\n@@ -332,22 +316,21 @@ impl<'a> DocFolder for CacheWrapper<'a> {\n                                 .map_or_else(String::new, |x| short_markdown_summary(&x.as_str())),\n                             parent,\n                             parent_idx: None,\n-                            search_type: get_index_search_type(&item, &self.tmp_cache),\n+                            search_type: get_index_search_type(&item, None),\n                         });\n \n                         for alias in item.attrs.get_doc_aliases() {\n-                            self.cache\n-                                .aliases\n+                            self.aliases\n                                 .entry(alias.to_lowercase())\n                                 .or_insert(Vec::new())\n-                                .push(self.cache.search_index.len() - 1);\n+                                .push(self.search_index.len() - 1);\n                         }\n                     }\n                 }\n                 (Some(parent), None) if is_inherent_impl_item => {\n                     // We have a parent, but we don't know where they're\n                     // defined yet. Wait for later to index this item.\n-                    self.cache.orphan_impl_items.push((parent, item.clone()));\n+                    self.orphan_impl_items.push((parent, item.clone()));\n                 }\n                 _ => {}\n             }\n@@ -356,7 +339,7 @@ impl<'a> DocFolder for CacheWrapper<'a> {\n         // Keep track of the fully qualified path for this item.\n         let pushed = match item.name {\n             Some(n) if !n.is_empty() => {\n-                self.cache.stack.push(n.to_string());\n+                self.stack.push(n.to_string());\n                 true\n             }\n             _ => false,\n@@ -378,54 +361,54 @@ impl<'a> DocFolder for CacheWrapper<'a> {\n             | clean::MacroItem(..)\n             | clean::ProcMacroItem(..)\n             | clean::VariantItem(..)\n-                if !self.cache.stripped_mod =>\n+                if !self.stripped_mod =>\n             {\n                 // Re-exported items mean that the same id can show up twice\n                 // in the rustdoc ast that we're looking at. We know,\n                 // however, that a re-exported item doesn't show up in the\n                 // `public_items` map, so we can skip inserting into the\n                 // paths map if there was already an entry present and we're\n                 // not a public item.\n-                if !self.cache.paths.contains_key(&item.def_id)\n-                    || self.cache.access_levels.is_public(item.def_id)\n+                if !self.paths.contains_key(&item.def_id)\n+                    || self.access_levels.is_public(item.def_id)\n                 {\n-                    self.cache.paths.insert(item.def_id, (self.cache.stack.clone(), item.type_()));\n+                    self.paths.insert(item.def_id, (self.stack.clone(), item.type_()));\n                 }\n             }\n             clean::PrimitiveItem(..) => {\n-                self.cache.paths.insert(item.def_id, (self.cache.stack.clone(), item.type_()));\n+                self.paths.insert(item.def_id, (self.stack.clone(), item.type_()));\n             }\n \n             _ => {}\n         }\n \n         // Maintain the parent stack\n-        let orig_parent_is_trait_impl = self.cache.parent_is_trait_impl;\n+        let orig_parent_is_trait_impl = self.parent_is_trait_impl;\n         let parent_pushed = match *item.kind {\n             clean::TraitItem(..)\n             | clean::EnumItem(..)\n             | clean::ForeignTypeItem\n             | clean::StructItem(..)\n             | clean::UnionItem(..)\n             | clean::VariantItem(..) => {\n-                self.cache.parent_stack.push(item.def_id);\n-                self.cache.parent_is_trait_impl = false;\n+                self.parent_stack.push(item.def_id);\n+                self.parent_is_trait_impl = false;\n                 true\n             }\n             clean::ImplItem(ref i) => {\n-                self.cache.parent_is_trait_impl = i.trait_.is_some();\n+                self.parent_is_trait_impl = i.trait_.is_some();\n                 match i.for_ {\n                     clean::ResolvedPath { did, .. } => {\n-                        self.cache.parent_stack.push(did);\n+                        self.parent_stack.push(did);\n                         true\n                     }\n                     ref t => {\n                         let prim_did = t\n                             .primitive_type()\n-                            .and_then(|t| self.cache.primitive_locations.get(&t).cloned());\n+                            .and_then(|t| self.primitive_locations.get(&t).cloned());\n                         match prim_did {\n                             Some(did) => {\n-                                self.cache.parent_stack.push(did);\n+                                self.parent_stack.push(did);\n                                 true\n                             }\n                             None => false,\n@@ -450,9 +433,8 @@ impl<'a> DocFolder for CacheWrapper<'a> {\n                     dids.insert(did);\n                 }\n                 ref t => {\n-                    let did = t\n-                        .primitive_type()\n-                        .and_then(|t| self.cache.primitive_locations.get(&t).cloned());\n+                    let did =\n+                        t.primitive_type().and_then(|t| self.primitive_locations.get(&t).cloned());\n \n                     if let Some(did) = did {\n                         dids.insert(did);\n@@ -462,36 +444,33 @@ impl<'a> DocFolder for CacheWrapper<'a> {\n \n             if let Some(generics) = i.trait_.as_ref().and_then(|t| t.generics()) {\n                 for bound in generics {\n-                    if let Some(did) = bound.def_id(&self.tmp_cache) {\n+                    if let Some(did) = bound.def_id() {\n                         dids.insert(did);\n                     }\n                 }\n             }\n             let impl_item = Impl { impl_item: item };\n-            if impl_item\n-                .trait_did(&self.tmp_cache)\n-                .map_or(true, |d| self.cache.traits.contains_key(&d))\n-            {\n+            if impl_item.trait_did().map_or(true, |d| self.traits.contains_key(&d)) {\n                 for did in dids {\n-                    self.cache.impls.entry(did).or_insert(vec![]).push(impl_item.clone());\n+                    self.impls.entry(did).or_insert(vec![]).push(impl_item.clone());\n                 }\n             } else {\n-                let trait_did = impl_item.trait_did(&self.tmp_cache).expect(\"no trait did\");\n-                self.cache.orphan_trait_impls.push((trait_did, dids, impl_item));\n+                let trait_did = impl_item.trait_did().expect(\"no trait did\");\n+                self.orphan_trait_impls.push((trait_did, dids, impl_item));\n             }\n             None\n         } else {\n             Some(item)\n         };\n \n         if pushed {\n-            self.cache.stack.pop().expect(\"stack already empty\");\n+            self.stack.pop().expect(\"stack already empty\");\n         }\n         if parent_pushed {\n-            self.cache.parent_stack.pop().expect(\"parent stack already empty\");\n+            self.parent_stack.pop().expect(\"parent stack already empty\");\n         }\n-        self.cache.stripped_mod = orig_stripped_mod;\n-        self.cache.parent_is_trait_impl = orig_parent_is_trait_impl;\n+        self.stripped_mod = orig_stripped_mod;\n+        self.parent_is_trait_impl = orig_parent_is_trait_impl;\n         ret\n     }\n }"}, {"sha": "1ce6572bbed044f7b205958c10c07a26412f41c4", "filename": "src/librustdoc/formats/mod.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/19630ead410873a08b271606b8ac5a27029d70b6/src%2Flibrustdoc%2Fformats%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19630ead410873a08b271606b8ac5a27029d70b6/src%2Flibrustdoc%2Fformats%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Fmod.rs?ref=19630ead410873a08b271606b8ac5a27029d70b6", "patch": "@@ -39,7 +39,11 @@ impl Impl {\n         }\n     }\n \n-    crate fn trait_did(&self, cache: &Cache) -> Option<DefId> {\n-        self.inner_impl().trait_.def_id(cache)\n+    crate fn trait_did(&self) -> Option<DefId> {\n+        self.inner_impl().trait_.def_id()\n+    }\n+\n+    crate fn trait_did_full(&self, cache: &Cache) -> Option<DefId> {\n+        self.inner_impl().trait_.def_id_full(cache)\n     }\n }"}, {"sha": "74a770b9548530d9b4caa460f8da31639aec6b6a", "filename": "src/librustdoc/html/render/cache.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/19630ead410873a08b271606b8ac5a27029d70b6/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19630ead410873a08b271606b8ac5a27029d70b6/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs?ref=19630ead410873a08b271606b8ac5a27029d70b6", "patch": "@@ -78,7 +78,7 @@ crate fn build_index(krate: &clean::Crate, cache: &mut Cache) -> String {\n                 desc: item.doc_value().map_or_else(String::new, |s| short_markdown_summary(&s)),\n                 parent: Some(did),\n                 parent_idx: None,\n-                search_type: get_index_search_type(&item, cache),\n+                search_type: get_index_search_type(&item, Some(cache)),\n             });\n             for alias in item.attrs.get_doc_aliases() {\n                 cache\n@@ -164,7 +164,10 @@ crate fn build_index(krate: &clean::Crate, cache: &mut Cache) -> String {\n     )\n }\n \n-crate fn get_index_search_type(item: &clean::Item, cache: &Cache) -> Option<IndexItemFunctionType> {\n+crate fn get_index_search_type(\n+    item: &clean::Item,\n+    cache: Option<&Cache>,\n+) -> Option<IndexItemFunctionType> {\n     let (all_types, ret_types) = match *item.kind {\n         clean::FunctionItem(ref f) => (&f.all_types, &f.ret_types),\n         clean::MethodItem(ref m, _) => (&m.all_types, &m.ret_types),\n@@ -174,22 +177,22 @@ crate fn get_index_search_type(item: &clean::Item, cache: &Cache) -> Option<Inde\n \n     let inputs = all_types\n         .iter()\n-        .map(|(ty, kind)| TypeWithKind::from((get_index_type(&ty, cache), *kind)))\n+        .map(|(ty, kind)| TypeWithKind::from((get_index_type(&ty, &cache), *kind)))\n         .filter(|a| a.ty.name.is_some())\n         .collect();\n     let output = ret_types\n         .iter()\n-        .map(|(ty, kind)| TypeWithKind::from((get_index_type(&ty, cache), *kind)))\n+        .map(|(ty, kind)| TypeWithKind::from((get_index_type(&ty, &cache), *kind)))\n         .filter(|a| a.ty.name.is_some())\n         .collect::<Vec<_>>();\n     let output = if output.is_empty() { None } else { Some(output) };\n \n     Some(IndexItemFunctionType { inputs, output })\n }\n \n-fn get_index_type(clean_type: &clean::Type, cache: &Cache) -> RenderType {\n+fn get_index_type(clean_type: &clean::Type, cache: &Option<&Cache>) -> RenderType {\n     RenderType {\n-        ty: clean_type.def_id(cache),\n+        ty: cache.map_or_else(|| clean_type.def_id(), |cache| clean_type.def_id_full(cache)),\n         idx: None,\n         name: get_index_type_name(clean_type, true).map(|s| s.as_str().to_ascii_lowercase()),\n         generics: get_generics(clean_type, cache),\n@@ -216,14 +219,14 @@ fn get_index_type_name(clean_type: &clean::Type, accept_generic: bool) -> Option\n     }\n }\n \n-fn get_generics(clean_type: &clean::Type, cache: &Cache) -> Option<Vec<Generic>> {\n+fn get_generics(clean_type: &clean::Type, cache: &Option<&Cache>) -> Option<Vec<Generic>> {\n     clean_type.generics().and_then(|types| {\n         let r = types\n             .iter()\n             .filter_map(|t| {\n                 get_index_type_name(t, false).map(|name| Generic {\n                     name: name.as_str().to_ascii_lowercase(),\n-                    defid: t.def_id(cache),\n+                    defid: cache.map_or_else(|| t.def_id(), |cache| t.def_id_full(cache)),\n                     idx: None,\n                 })\n             })"}, {"sha": "f4ff1f3b6d55b6bb492d11b2fc32e8c6f45fdbdd", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 27, "deletions": 22, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/19630ead410873a08b271606b8ac5a27029d70b6/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19630ead410873a08b271606b8ac5a27029d70b6/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=19630ead410873a08b271606b8ac5a27029d70b6", "patch": "@@ -2515,7 +2515,7 @@ fn render_impls(\n     let mut impls = traits\n         .iter()\n         .map(|i| {\n-            let did = i.trait_did(cx.cache()).unwrap();\n+            let did = i.trait_did_full(cx.cache()).unwrap();\n             let assoc_link = AssocItemLink::GotoSource(did, &i.inner_impl().provided_trait_methods);\n             let mut buffer = if w.is_for_html() { Buffer::html() } else { Buffer::new() };\n             render_impl(\n@@ -2755,7 +2755,10 @@ fn item_trait(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, t: &clean::Tra\n         }\n \n         let (local, foreign) = implementors.iter().partition::<Vec<_>, _>(|i| {\n-            i.inner_impl().for_.def_id(cx.cache()).map_or(true, |d| cx.cache.paths.contains_key(&d))\n+            i.inner_impl()\n+                .for_\n+                .def_id_full(cx.cache())\n+                .map_or(true, |d| cx.cache.paths.contains_key(&d))\n         });\n \n         let (mut synthetic, mut concrete): (Vec<&&Impl>, Vec<&&Impl>) =\n@@ -3518,7 +3521,9 @@ fn render_assoc_items(\n                     \"deref-methods-{:#}\",\n                     type_.print(cx.cache())\n                 )));\n-                cx.deref_id_map.borrow_mut().insert(type_.def_id(cx.cache()).unwrap(), id.clone());\n+                cx.deref_id_map\n+                    .borrow_mut()\n+                    .insert(type_.def_id_full(cx.cache()).unwrap(), id.clone());\n                 write!(\n                     w,\n                     \"<h2 id=\\\"{id}\\\" class=\\\"small-section-header\\\">\\\n@@ -3553,11 +3558,11 @@ fn render_assoc_items(\n     if !traits.is_empty() {\n         let deref_impl = traits\n             .iter()\n-            .find(|t| t.inner_impl().trait_.def_id(cx.cache()) == cx.cache.deref_trait_did);\n+            .find(|t| t.inner_impl().trait_.def_id_full(cx.cache()) == cx.cache.deref_trait_did);\n         if let Some(impl_) = deref_impl {\n-            let has_deref_mut = traits\n-                .iter()\n-                .any(|t| t.inner_impl().trait_.def_id(cx.cache()) == cx.cache.deref_mut_trait_did);\n+            let has_deref_mut = traits.iter().any(|t| {\n+                t.inner_impl().trait_.def_id_full(cx.cache()) == cx.cache.deref_mut_trait_did\n+            });\n             render_deref_methods(w, cx, impl_, containing_item, has_deref_mut);\n         }\n \n@@ -3636,8 +3641,8 @@ fn render_deref_methods(\n         .expect(\"Expected associated type binding\");\n     let what =\n         AssocItemRender::DerefFor { trait_: deref_type, type_: real_target, deref_mut_: deref_mut };\n-    if let Some(did) = target.def_id(cx.cache()) {\n-        if let Some(type_did) = impl_.inner_impl().for_.def_id(cx.cache()) {\n+    if let Some(did) = target.def_id_full(cx.cache()) {\n+        if let Some(type_did) = impl_.inner_impl().for_.def_id_full(cx.cache()) {\n             // `impl Deref<Target = S> for S`\n             if did == type_did {\n                 // Avoid infinite cycles\n@@ -3684,11 +3689,11 @@ fn spotlight_decl(decl: &clean::FnDecl, c: &Cache) -> String {\n     let mut out = Buffer::html();\n     let mut trait_ = String::new();\n \n-    if let Some(did) = decl.output.def_id(c) {\n+    if let Some(did) = decl.output.def_id_full(c) {\n         if let Some(impls) = c.impls.get(&did) {\n             for i in impls {\n                 let impl_ = i.inner_impl();\n-                if impl_.trait_.def_id(c).map_or(false, |d| c.traits[&d].is_spotlight) {\n+                if impl_.trait_.def_id_full(c).map_or(false, |d| c.traits[&d].is_spotlight) {\n                     if out.is_empty() {\n                         out.push_str(&format!(\n                             \"<h3 class=\\\"notable\\\">Notable traits for {}</h3>\\\n@@ -3703,7 +3708,7 @@ fn spotlight_decl(decl: &clean::FnDecl, c: &Cache) -> String {\n                         \"<span class=\\\"where fmt-newline\\\">{}</span>\",\n                         impl_.print(c)\n                     ));\n-                    let t_did = impl_.trait_.def_id(c).unwrap();\n+                    let t_did = impl_.trait_.def_id_full(c).unwrap();\n                     for it in &impl_.items {\n                         if let clean::TypedefItem(ref tydef, _) = *it.kind {\n                             out.push_str(\"<span class=\\\"where fmt-newline\\\">    \");\n@@ -3754,7 +3759,7 @@ fn render_impl(\n     aliases: &[String],\n ) {\n     let traits = &cx.cache.traits;\n-    let trait_ = i.trait_did(cx.cache()).map(|did| &traits[&did]);\n+    let trait_ = i.trait_did_full(cx.cache()).map(|did| &traits[&did]);\n \n     if render_mode == RenderMode::Normal {\n         let id = cx.derive_id(match i.inner_impl().trait_ {\n@@ -3998,7 +4003,7 @@ fn render_impl(\n             if i.items.iter().any(|m| m.name == n) {\n                 continue;\n             }\n-            let did = i.trait_.as_ref().unwrap().def_id(cx.cache()).unwrap();\n+            let did = i.trait_.as_ref().unwrap().def_id_full(cx.cache()).unwrap();\n             let assoc_link = AssocItemLink::GotoSource(did, &i.provided_trait_methods);\n \n             doc_impl_item(\n@@ -4309,7 +4314,7 @@ fn sidebar_assoc_items(cx: &Context<'_>, it: &clean::Item) -> String {\n             if let Some(impl_) = v\n                 .iter()\n                 .filter(|i| i.inner_impl().trait_.is_some())\n-                .find(|i| i.inner_impl().trait_.def_id(cx.cache()) == cx.cache.deref_trait_did)\n+                .find(|i| i.inner_impl().trait_.def_id_full(cx.cache()) == cx.cache.deref_trait_did)\n             {\n                 out.push_str(&sidebar_deref_methods(cx, impl_, v));\n             }\n@@ -4396,9 +4401,9 @@ fn sidebar_deref_methods(cx: &Context<'_>, impl_: &Impl, v: &Vec<Impl>) -> Strin\n         let deref_mut = v\n             .iter()\n             .filter(|i| i.inner_impl().trait_.is_some())\n-            .any(|i| i.inner_impl().trait_.def_id(cx.cache()) == c.deref_mut_trait_did);\n+            .any(|i| i.inner_impl().trait_.def_id_full(cx.cache()) == c.deref_mut_trait_did);\n         let inner_impl = target\n-            .def_id(cx.cache())\n+            .def_id_full(cx.cache())\n             .or_else(|| {\n                 target.primitive_type().and_then(|prim| c.primitive_locations.get(&prim).cloned())\n             })\n@@ -4414,7 +4419,7 @@ fn sidebar_deref_methods(cx: &Context<'_>, impl_: &Impl, v: &Vec<Impl>) -> Strin\n             if !ret.is_empty() {\n                 let deref_id_map = cx.deref_id_map.borrow();\n                 let id = deref_id_map\n-                    .get(&real_target.def_id(cx.cache()).unwrap())\n+                    .get(&real_target.def_id_full(cx.cache()).unwrap())\n                     .expect(\"Deref section without derived id\");\n                 out.push_str(&format!(\n                     \"<a class=\\\"sidebar-title\\\" href=\\\"#{}\\\">Methods from {}&lt;Target={}&gt;</a>\",\n@@ -4429,14 +4434,14 @@ fn sidebar_deref_methods(cx: &Context<'_>, impl_: &Impl, v: &Vec<Impl>) -> Strin\n         }\n \n         // Recurse into any further impls that might exist for `target`\n-        if let Some(target_did) = target.def_id(cx.cache()) {\n+        if let Some(target_did) = target.def_id_full(cx.cache()) {\n             if let Some(target_impls) = c.impls.get(&target_did) {\n                 if let Some(target_deref_impl) = target_impls\n                     .iter()\n                     .filter(|i| i.inner_impl().trait_.is_some())\n-                    .find(|i| i.inner_impl().trait_.def_id(cx.cache()) == c.deref_trait_did)\n+                    .find(|i| i.inner_impl().trait_.def_id_full(cx.cache()) == c.deref_trait_did)\n                 {\n-                    if let Some(type_did) = impl_.inner_impl().for_.def_id(cx.cache()) {\n+                    if let Some(type_did) = impl_.inner_impl().for_.def_id_full(cx.cache()) {\n                         // `impl Deref<Target = S> for S`\n                         if target_did == type_did {\n                             // Avoid infinite cycles\n@@ -4580,7 +4585,7 @@ fn sidebar_trait(cx: &Context<'_>, buf: &mut Buffer, it: &clean::Item, t: &clean\n             .filter(|i| {\n                 i.inner_impl()\n                     .for_\n-                    .def_id(cx.cache())\n+                    .def_id_full(cx.cache())\n                     .map_or(false, |d| !cx.cache.paths.contains_key(&d))\n             })\n             .filter_map(|i| extract_for_impl_name(&i.impl_item, cx.cache()))"}, {"sha": "7b5e9e5905f334372eadb979d930c92d81ddf81b", "filename": "src/librustdoc/passes/collect_trait_impls.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/19630ead410873a08b271606b8ac5a27029d70b6/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19630ead410873a08b271606b8ac5a27029d70b6/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs?ref=19630ead410873a08b271606b8ac5a27029d70b6", "patch": "@@ -2,7 +2,6 @@ use super::Pass;\n use crate::clean::*;\n use crate::core::DocContext;\n use crate::fold::DocFolder;\n-use crate::formats::cache::Cache;\n \n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n@@ -97,12 +96,12 @@ crate fn collect_trait_impls(krate: Crate, cx: &DocContext<'_>) -> Crate {\n     // Gather all type to `Deref` target edges.\n     for it in &new_items {\n         if let ImplItem(Impl { ref for_, ref trait_, ref items, .. }) = *it.kind {\n-            if trait_.def_id(&cx.cache) == cx.tcx.lang_items().deref_trait() {\n+            if trait_.def_id() == cx.tcx.lang_items().deref_trait() {\n                 let target = items.iter().find_map(|item| match *item.kind {\n                     TypedefItem(ref t, true) => Some(&t.type_),\n                     _ => None,\n                 });\n-                if let (Some(for_did), Some(target)) = (for_.def_id(&cx.cache), target) {\n+                if let (Some(for_did), Some(target)) = (for_.def_id(), target) {\n                     type_did_to_deref_target.insert(for_did, target);\n                 }\n             }\n@@ -113,20 +112,19 @@ crate fn collect_trait_impls(krate: Crate, cx: &DocContext<'_>) -> Crate {\n         map: &FxHashMap<DefId, &Type>,\n         cleaner: &mut BadImplStripper,\n         type_did: &DefId,\n-        cache: &Cache,\n     ) {\n         if let Some(target) = map.get(type_did) {\n             debug!(\"add_deref_target: type {:?}, target {:?}\", type_did, target);\n             if let Some(target_prim) = target.primitive_type() {\n                 cleaner.prims.insert(target_prim);\n-            } else if let Some(target_did) = target.def_id(cache) {\n+            } else if let Some(target_did) = target.def_id() {\n                 // `impl Deref<Target = S> for S`\n                 if target_did == *type_did {\n                     // Avoid infinite cycles\n                     return;\n                 }\n                 cleaner.items.insert(target_did);\n-                add_deref_target(map, cleaner, &target_did, cache);\n+                add_deref_target(map, cleaner, &target_did);\n             }\n         }\n     }\n@@ -135,14 +133,14 @@ crate fn collect_trait_impls(krate: Crate, cx: &DocContext<'_>) -> Crate {\n         // `Deref` target type and the impl for type positions, this map of types is keyed by\n         // `DefId` and for convenience uses a special cleaner that accepts `DefId`s directly.\n         if cleaner.keep_impl_with_def_id(type_did) {\n-            add_deref_target(&type_did_to_deref_target, &mut cleaner, type_did, &cx.cache);\n+            add_deref_target(&type_did_to_deref_target, &mut cleaner, type_did);\n         }\n     }\n \n     new_items.retain(|it| {\n         if let ImplItem(Impl { ref for_, ref trait_, ref blanket_impl, .. }) = *it.kind {\n-            cleaner.keep_impl(for_, &cx.cache)\n-                || trait_.as_ref().map_or(false, |t| cleaner.keep_impl(t, &cx.cache))\n+            cleaner.keep_impl(for_)\n+                || trait_.as_ref().map_or(false, |t| cleaner.keep_impl(t))\n                 || blanket_impl.is_some()\n         } else {\n             true\n@@ -218,13 +216,13 @@ struct BadImplStripper {\n }\n \n impl BadImplStripper {\n-    fn keep_impl(&self, ty: &Type, cache: &Cache) -> bool {\n+    fn keep_impl(&self, ty: &Type) -> bool {\n         if let Generic(_) = ty {\n             // keep impls made on generics\n             true\n         } else if let Some(prim) = ty.primitive_type() {\n             self.prims.contains(&prim)\n-        } else if let Some(did) = ty.def_id(cache) {\n+        } else if let Some(did) = ty.def_id() {\n             self.keep_impl_with_def_id(&did)\n         } else {\n             false"}, {"sha": "a276b7a63371b0687af69d0f3ff05a12dd206473", "filename": "src/librustdoc/passes/strip_hidden.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/19630ead410873a08b271606b8ac5a27029d70b6/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19630ead410873a08b271606b8ac5a27029d70b6/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs?ref=19630ead410873a08b271606b8ac5a27029d70b6", "patch": "@@ -15,7 +15,7 @@ crate const STRIP_HIDDEN: Pass = Pass {\n };\n \n /// Strip items marked `#[doc(hidden)]`\n-crate fn strip_hidden(krate: clean::Crate, cx: &DocContext<'_>) -> clean::Crate {\n+crate fn strip_hidden(krate: clean::Crate, _: &DocContext<'_>) -> clean::Crate {\n     let mut retained = DefIdSet::default();\n \n     // strip all #[doc(hidden)] items\n@@ -25,7 +25,7 @@ crate fn strip_hidden(krate: clean::Crate, cx: &DocContext<'_>) -> clean::Crate\n     };\n \n     // strip all impls referencing stripped items\n-    let mut stripper = ImplStripper { retained: &retained, cache: &cx.cache };\n+    let mut stripper = ImplStripper { retained: &retained };\n     stripper.fold_crate(krate)\n }\n "}, {"sha": "e812bcd87fe3c8c838a764c4e7b1a346ba9e58b9", "filename": "src/librustdoc/passes/strip_private.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/19630ead410873a08b271606b8ac5a27029d70b6/src%2Flibrustdoc%2Fpasses%2Fstrip_private.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19630ead410873a08b271606b8ac5a27029d70b6/src%2Flibrustdoc%2Fpasses%2Fstrip_private.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstrip_private.rs?ref=19630ead410873a08b271606b8ac5a27029d70b6", "patch": "@@ -30,6 +30,6 @@ crate fn strip_private(mut krate: clean::Crate, cx: &DocContext<'_>) -> clean::C\n     }\n \n     // strip all impls referencing private items\n-    let mut stripper = ImplStripper { retained: &retained, cache: &cx.cache };\n+    let mut stripper = ImplStripper { retained: &retained };\n     stripper.fold_crate(krate)\n }"}, {"sha": "162b70973b418e25f77855fca860b661c45eba10", "filename": "src/librustdoc/passes/stripper.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/19630ead410873a08b271606b8ac5a27029d70b6/src%2Flibrustdoc%2Fpasses%2Fstripper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/19630ead410873a08b271606b8ac5a27029d70b6/src%2Flibrustdoc%2Fpasses%2Fstripper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstripper.rs?ref=19630ead410873a08b271606b8ac5a27029d70b6", "patch": "@@ -4,7 +4,6 @@ use std::mem;\n \n use crate::clean::{self, GetDefId, Item};\n use crate::fold::{DocFolder, StripItem};\n-use crate::formats::cache::Cache;\n \n crate struct Stripper<'a> {\n     crate retained: &'a mut DefIdSet,\n@@ -118,7 +117,6 @@ impl<'a> DocFolder for Stripper<'a> {\n /// This stripper discards all impls which reference stripped items\n crate struct ImplStripper<'a> {\n     crate retained: &'a DefIdSet,\n-    crate cache: &'a Cache,\n }\n \n impl<'a> DocFolder for ImplStripper<'a> {\n@@ -128,21 +126,21 @@ impl<'a> DocFolder for ImplStripper<'a> {\n             if imp.trait_.is_none() && imp.items.is_empty() {\n                 return None;\n             }\n-            if let Some(did) = imp.for_.def_id(&self.cache) {\n+            if let Some(did) = imp.for_.def_id() {\n                 if did.is_local() && !imp.for_.is_generic() && !self.retained.contains(&did) {\n                     debug!(\"ImplStripper: impl item for stripped type; removing\");\n                     return None;\n                 }\n             }\n-            if let Some(did) = imp.trait_.def_id(&self.cache) {\n+            if let Some(did) = imp.trait_.def_id() {\n                 if did.is_local() && !self.retained.contains(&did) {\n                     debug!(\"ImplStripper: impl item for stripped trait; removing\");\n                     return None;\n                 }\n             }\n             if let Some(generics) = imp.trait_.as_ref().and_then(|t| t.generics()) {\n                 for typaram in generics {\n-                    if let Some(did) = typaram.def_id(&self.cache) {\n+                    if let Some(did) = typaram.def_id() {\n                         if did.is_local() && !self.retained.contains(&did) {\n                             debug!(\n                                 \"ImplStripper: stripped item in trait's generics; removing impl\""}]}