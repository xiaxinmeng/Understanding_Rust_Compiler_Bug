{"sha": "62aa8d7de96bc6439d14db3197313604292aa314", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYyYWE4ZDdkZTk2YmM2NDM5ZDE0ZGIzMTk3MzEzNjA0MjkyYWEzMTQ=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-03-08T22:48:11Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-03-10T19:05:22Z"}, "message": "Simplify the interface to check_fn by pulling some of the madness out to its callers", "tree": {"sha": "c53db7713499cd74828d876ed3598c63771871e9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c53db7713499cd74828d876ed3598c63771871e9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/62aa8d7de96bc6439d14db3197313604292aa314", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/62aa8d7de96bc6439d14db3197313604292aa314", "html_url": "https://github.com/rust-lang/rust/commit/62aa8d7de96bc6439d14db3197313604292aa314", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/62aa8d7de96bc6439d14db3197313604292aa314/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "267f6c212f471c100060edaaf85a26e9a7ba820f", "url": "https://api.github.com/repos/rust-lang/rust/commits/267f6c212f471c100060edaaf85a26e9a7ba820f", "html_url": "https://github.com/rust-lang/rust/commit/267f6c212f471c100060edaaf85a26e9a7ba820f"}], "stats": {"total": 95, "additions": 56, "deletions": 39}, "files": [{"sha": "cdc1f258cb5440fc7ebb072185afd68a8d8d533d", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 56, "deletions": 39, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/62aa8d7de96bc6439d14db3197313604292aa314/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62aa8d7de96bc6439d14db3197313604292aa314/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=62aa8d7de96bc6439d14db3197313604292aa314", "patch": "@@ -162,7 +162,17 @@ pub struct inherited {\n     adjustments: HashMap<ast::node_id, @ty::AutoAdjustment>\n }\n \n-pub enum FnKind { ForLoop, DoBlock, Vanilla }\n+pub enum FnKind {\n+    // This is a for-closure.  The ty::t is the return type of the\n+    // enclosing function.\n+    ForLoop(ty::t),\n+\n+    // A do-closure.\n+    DoBlock,\n+\n+    // A normal closure or fn item.\n+    Vanilla\n+}\n \n pub struct FnCtxt {\n     // var_bindings, locals and next_var_id are shared\n@@ -250,8 +260,14 @@ pub fn check_bare_fn(ccx: @mut CrateCtxt,\n     let fty = ty::node_id_to_type(ccx.tcx, id);\n     match ty::get(fty).sty {\n         ty::ty_bare_fn(ref fn_ty) => {\n-            check_fn(ccx, self_info, fn_ty.purity, None,\n-                     &fn_ty.sig, decl, body, Vanilla, None)\n+            let fcx =\n+                check_fn(ccx, self_info, fn_ty.purity,\n+                         &fn_ty.sig, decl, body, Vanilla,\n+                         @Nil, blank_inherited(ccx));;\n+\n+            vtable::resolve_in_block(fcx, body);\n+            regionck::regionck_fn(fcx, body);\n+            writeback::resolve_type_vars_in_fn(fcx, decl, body, self_info);\n         }\n         _ => ccx.tcx.sess.impossible_case(body.span,\n                                  \"check_bare_fn: function type expected\")\n@@ -261,26 +277,34 @@ pub fn check_bare_fn(ccx: @mut CrateCtxt,\n pub fn check_fn(ccx: @mut CrateCtxt,\n                 +self_info: Option<SelfInfo>,\n                 purity: ast::purity,\n-                sigil: Option<ast::Sigil>,\n                 fn_sig: &ty::FnSig,\n                 decl: &ast::fn_decl,\n                 body: &ast::blk,\n                 fn_kind: FnKind,\n-                old_fcx: Option<@mut FnCtxt>) {\n+                inherited_isr: isr_alist,\n+                inherited: @inherited) -> @mut FnCtxt\n+{\n+    /*!\n+     *\n+     * Helper used by check_bare_fn and check_expr_fn.  Does the\n+     * grungy work of checking a function body and returns the\n+     * function context used for that purpose, since in the case of a\n+     * fn item there is still a bit more to do.\n+     *\n+     * - ...\n+     * - inherited_isr: regions in scope from the enclosing fn (if any)\n+     * - inherited: other fields inherited from the enclosing fn (if any)\n+     */\n+\n     let tcx = ccx.tcx;\n-    let indirect_ret = match fn_kind {\n-        ForLoop => true, _ => false\n-    };\n \n     // ______________________________________________________________________\n     // First, we have to replace any bound regions in the fn and self\n     // types with free ones.  The free region references will be bound\n     // the node_id of the body block.\n \n     let (isr, self_info, fn_sig) = {\n-        let old_isr = option::map_default(&old_fcx, @Nil,\n-                                          |fcx| fcx.in_scope_regions);\n-        replace_bound_regions_in_fn_sig(tcx, old_isr, self_info, fn_sig,\n+        replace_bound_regions_in_fn_sig(tcx, inherited_isr, self_info, fn_sig,\n                                         |br| ty::re_free(body.node.id, br))\n     };\n \n@@ -296,23 +320,13 @@ pub fn check_fn(ccx: @mut CrateCtxt,\n     // Create the function context.  This is either derived from scratch or,\n     // in the case of function expressions, based on the outer context.\n     let fcx: @mut FnCtxt = {\n-        let (purity, inherited) = match old_fcx {\n-            None => (purity, blank_inherited(ccx)),\n-            Some(fcx) => {\n-                (ty::determine_inherited_purity(fcx.purity, purity,\n-                                                sigil.get()),\n-                 fcx.inh)\n-            }\n+        // In a for-loop, you have an 'indirect return' because return\n+        // does not return out of the directly enclosing fn\n+        let indirect_ret_ty = match fn_kind {\n+            ForLoop(t) => Some(t),\n+            DoBlock | Vanilla => None\n         };\n \n-        let indirect_ret_ty = if indirect_ret {\n-            let ofcx = old_fcx.get();\n-            match ofcx.indirect_ret_ty {\n-              Some(t) => Some(t),\n-              None => Some(ofcx.ret_ty)\n-            }\n-        } else { None };\n-\n         @mut FnCtxt {\n             self_info: self_info,\n             ret_ty: ret_ty,\n@@ -370,15 +384,7 @@ pub fn check_fn(ccx: @mut CrateCtxt,\n         fcx.write_ty(input.id, *arg);\n     }\n \n-    // If we don't have any enclosing function scope, it is time to\n-    // force any remaining type vars to be resolved.\n-    // If we have an enclosing function scope, our type variables will be\n-    // resolved when the enclosing scope finishes up.\n-    if old_fcx.is_none() {\n-        vtable::resolve_in_block(fcx, body);\n-        regionck::regionck_fn(fcx, body);\n-        writeback::resolve_type_vars_in_fn(fcx, decl, body, self_info);\n-    }\n+    return fcx;\n \n     fn gather_locals(fcx: @mut FnCtxt,\n                      decl: &ast::fn_decl,\n@@ -903,7 +909,7 @@ pub impl FnCtxt {\n                                       a: ty::t,\n                                       err: &ty::type_err) {\n         match self.fn_kind {\n-            ForLoop if !ty::type_is_bool(e) && !ty::type_is_nil(a) =>\n+            ForLoop(_) if !ty::type_is_bool(e) && !ty::type_is_nil(a) =>\n                     self.tcx().sess.span_err(sp, fmt!(\"A for-loop body must \\\n                         return (), but it returns %s here. \\\n                         Perhaps you meant to write a `do`-block?\",\n@@ -1667,10 +1673,15 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n \n         fcx.write_ty(expr.id, fty);\n \n+        let inherited_purity =\n+            ty::determine_inherited_purity(fcx.purity, purity,\n+                                           fn_ty.sigil);\n+\n         // We inherit the same self info as the enclosing scope,\n         // since the function we're checking might capture `self`\n-        check_fn(fcx.ccx, fcx.self_info, fn_ty.purity, Some(fn_ty.sigil),\n-                 &fn_ty.sig, decl, body, fn_kind, Some(fcx));\n+        check_fn(fcx.ccx, fcx.self_info, inherited_purity,\n+                 &fn_ty.sig, decl, body, fn_kind,\n+                 fcx.in_scope_regions, fcx.inh);\n     }\n \n \n@@ -2080,7 +2091,13 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                 // derived errors. If we passed in ForLoop in the\n                 // error case, we'd potentially emit a spurious error\n                 // message because of the indirect_ret_ty.\n-                let fn_kind = if err_happened {Vanilla} else {ForLoop};\n+                let fn_kind = if err_happened {\n+                    Vanilla\n+                } else {\n+                    let indirect_ret_ty =\n+                        fcx.indirect_ret_ty.get_or_default(fcx.ret_ty);\n+                    ForLoop(indirect_ret_ty)\n+                };\n                 check_expr_fn(fcx, loop_body, None,\n                               decl, body, fn_kind, Some(inner_ty));\n                 demand::suptype(fcx, loop_body.span,"}]}