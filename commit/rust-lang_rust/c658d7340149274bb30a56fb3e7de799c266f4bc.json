{"sha": "c658d7340149274bb30a56fb3e7de799c266f4bc", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM2NThkNzM0MDE0OTI3NGJiMzBhNTZmYjNlN2RlNzk5YzI2NmY0YmM=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-11-30T18:16:21Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-12-02T12:42:30Z"}, "message": "resolve: Avoid \"self-confirming\" resolutions in import validation", "tree": {"sha": "38757e0272350e3238593293fab956ff9fbb05fb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/38757e0272350e3238593293fab956ff9fbb05fb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c658d7340149274bb30a56fb3e7de799c266f4bc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c658d7340149274bb30a56fb3e7de799c266f4bc", "html_url": "https://github.com/rust-lang/rust/commit/c658d7340149274bb30a56fb3e7de799c266f4bc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c658d7340149274bb30a56fb3e7de799c266f4bc/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0765eb95b5e9e15fc29aa7725a01621dfeca2649", "url": "https://api.github.com/repos/rust-lang/rust/commits/0765eb95b5e9e15fc29aa7725a01621dfeca2649", "html_url": "https://github.com/rust-lang/rust/commit/0765eb95b5e9e15fc29aa7725a01621dfeca2649"}], "stats": {"total": 82, "additions": 46, "deletions": 36}, "files": [{"sha": "b9de05f7d6f484270bf4058a668cdd138a224556", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c658d7340149274bb30a56fb3e7de799c266f4bc/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c658d7340149274bb30a56fb3e7de799c266f4bc/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=c658d7340149274bb30a56fb3e7de799c266f4bc", "patch": "@@ -230,13 +230,18 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                 }\n \n                 let subclass = SingleImport {\n-                    target: ident,\n                     source: source.ident,\n-                    result: PerNS {\n+                    target: ident,\n+                    source_bindings: PerNS {\n                         type_ns: Cell::new(Err(Undetermined)),\n                         value_ns: Cell::new(Err(Undetermined)),\n                         macro_ns: Cell::new(Err(Undetermined)),\n                     },\n+                    target_bindings: PerNS {\n+                        type_ns: Cell::new(None),\n+                        value_ns: Cell::new(None),\n+                        macro_ns: Cell::new(None),\n+                    },\n                     type_ns_only,\n                 };\n                 self.add_import_directive("}, {"sha": "04495d2ea9bfd2b8f83d0c533928196ba2bfea34", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c658d7340149274bb30a56fb3e7de799c266f4bc/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c658d7340149274bb30a56fb3e7de799c266f4bc/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=c658d7340149274bb30a56fb3e7de799c266f4bc", "patch": "@@ -1521,6 +1521,7 @@ pub struct Resolver<'a, 'b: 'a> {\n \n     /// FIXME: Refactor things so that this is passed through arguments and not resolver.\n     last_import_segment: bool,\n+    blacklisted_binding: Option<&'a NameBinding<'a>>,\n \n     /// The idents for the primitive types.\n     primitive_type_table: PrimitiveTypeTable,\n@@ -1871,6 +1872,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n             current_self_type: None,\n             current_self_item: None,\n             last_import_segment: false,\n+            blacklisted_binding: None,\n \n             primitive_type_table: PrimitiveTypeTable::new(),\n "}, {"sha": "1707eeca1430c7bf16ac00cd492cd09c76a0553d", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c658d7340149274bb30a56fb3e7de799c266f4bc/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c658d7340149274bb30a56fb3e7de799c266f4bc/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=c658d7340149274bb30a56fb3e7de799c266f4bc", "patch": "@@ -977,12 +977,14 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                 let what = self.binding_description(binding, ident,\n                                                     flags.contains(Flags::MISC_FROM_PRELUDE));\n                 let note_msg = format!(\"this import refers to {what}\", what = what);\n-                if binding.span.is_dummy() {\n+                let label_span = if binding.span.is_dummy() {\n                     err.note(&note_msg);\n+                    ident.span\n                 } else {\n                     err.span_note(binding.span, &note_msg);\n-                    err.span_label(binding.span, \"not an extern crate passed with `--extern`\");\n-                }\n+                    binding.span\n+                };\n+                err.span_label(label_span, \"not an extern crate passed with `--extern`\");\n                 err.emit();\n             }\n "}, {"sha": "8695e38e1523b2344b1d27ea3039f83480b9914e", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 29, "deletions": 16, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/c658d7340149274bb30a56fb3e7de799c266f4bc/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c658d7340149274bb30a56fb3e7de799c266f4bc/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=c658d7340149274bb30a56fb3e7de799c266f4bc", "patch": "@@ -42,9 +42,10 @@ use std::{mem, ptr};\n #[derive(Clone, Debug)]\n pub enum ImportDirectiveSubclass<'a> {\n     SingleImport {\n-        target: Ident,\n         source: Ident,\n-        result: PerNS<Cell<Result<&'a NameBinding<'a>, Determinacy>>>,\n+        target: Ident,\n+        source_bindings: PerNS<Cell<Result<&'a NameBinding<'a>, Determinacy>>>,\n+        target_bindings: PerNS<Cell<Option<&'a NameBinding<'a>>>>,\n         type_ns_only: bool,\n     },\n     GlobImport {\n@@ -227,6 +228,11 @@ impl<'a, 'crateloader> Resolver<'a, 'crateloader> {\n         }\n \n         let check_usable = |this: &mut Self, binding: &'a NameBinding<'a>| {\n+            if let Some(blacklisted_binding) = this.blacklisted_binding {\n+                if ptr::eq(binding, blacklisted_binding) {\n+                    return Err((Determined, Weak::No));\n+                }\n+            }\n             // `extern crate` are always usable for backwards compatibility, see issue #37020,\n             // remove this together with `PUB_USE_OF_PRIVATE_EXTERN_CRATE`.\n             let usable = this.is_accessible(binding.vis) || binding.is_extern_crate();\n@@ -642,10 +648,10 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n             if let Some((span, err, note)) = self.finalize_import(import) {\n                 errors = true;\n \n-                if let SingleImport { source, ref result, .. } = import.subclass {\n+                if let SingleImport { source, ref source_bindings, .. } = import.subclass {\n                     if source.name == \"self\" {\n                         // Silence `unresolved import` error if E0429 is already emitted\n-                        if let Err(Determined) = result.value_ns.get() {\n+                        if let Err(Determined) = source_bindings.value_ns.get() {\n                             continue;\n                         }\n                     }\n@@ -765,9 +771,11 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n         };\n \n         directive.imported_module.set(Some(module));\n-        let (source, target, result, type_ns_only) = match directive.subclass {\n-            SingleImport { source, target, ref result, type_ns_only } =>\n-                (source, target, result, type_ns_only),\n+        let (source, target, source_bindings, target_bindings, type_ns_only) =\n+                match directive.subclass {\n+            SingleImport { source, target, ref source_bindings,\n+                           ref target_bindings, type_ns_only } =>\n+                (source, target, source_bindings, target_bindings, type_ns_only),\n             GlobImport { .. } => {\n                 self.resolve_glob_import(directive);\n                 return true;\n@@ -777,7 +785,7 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n \n         let mut indeterminate = false;\n         self.per_ns(|this, ns| if !type_ns_only || ns == TypeNS {\n-            if let Err(Undetermined) = result[ns].get() {\n+            if let Err(Undetermined) = source_bindings[ns].get() {\n                 // For better failure detection, pretend that the import will\n                 // not define any names while resolving its module path.\n                 let orig_vis = directive.vis.replace(ty::Visibility::Invisible);\n@@ -786,13 +794,13 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n                 );\n                 directive.vis.set(orig_vis);\n \n-                result[ns].set(binding);\n+                source_bindings[ns].set(binding);\n             } else {\n                 return\n             };\n \n             let parent = directive.parent_scope.module;\n-            match result[ns].get() {\n+            match source_bindings[ns].get() {\n                 Err(Undetermined) => indeterminate = true,\n                 Err(Determined) => {\n                     this.update_resolution(parent, target, ns, |_, resolution| {\n@@ -810,6 +818,7 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n                 }\n                 Ok(binding) => {\n                     let imported_binding = this.import(binding, directive);\n+                    target_bindings[ns].set(Some(imported_binding));\n                     let conflict = this.try_define(parent, target, ns, imported_binding);\n                     if let Err(old_binding) = conflict {\n                         this.report_conflict(parent, target, ns, imported_binding, old_binding);\n@@ -879,8 +888,9 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n             PathResult::Indeterminate | PathResult::NonModule(..) => unreachable!(),\n         };\n \n-        let (ident, result, type_ns_only) = match directive.subclass {\n-            SingleImport { source, ref result, type_ns_only, .. } => (source, result, type_ns_only),\n+        let (ident, source_bindings, target_bindings, type_ns_only) = match directive.subclass {\n+            SingleImport { source, ref source_bindings, ref target_bindings, type_ns_only, .. } =>\n+                (source, source_bindings, target_bindings, type_ns_only),\n             GlobImport { is_prelude, ref max_vis } => {\n                 if directive.module_path.len() <= 1 {\n                     // HACK(eddyb) `lint_if_path_starts_with_module` needs at least\n@@ -919,17 +929,20 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n         let mut all_ns_err = true;\n         self.per_ns(|this, ns| if !type_ns_only || ns == TypeNS {\n             let orig_vis = directive.vis.replace(ty::Visibility::Invisible);\n+            let orig_blacklisted_binding =\n+                mem::replace(&mut this.blacklisted_binding, target_bindings[ns].get());\n             let orig_last_import_segment = mem::replace(&mut this.last_import_segment, true);\n             let binding = this.resolve_ident_in_module(\n                 module, ident, ns, Some(&directive.parent_scope), true, directive.span\n             );\n             this.last_import_segment = orig_last_import_segment;\n+            this.blacklisted_binding = orig_blacklisted_binding;\n             directive.vis.set(orig_vis);\n \n             match binding {\n                 Ok(binding) => {\n                     // Consistency checks, analogous to `finalize_current_module_macro_resolutions`.\n-                    let initial_def = result[ns].get().map(|initial_binding| {\n+                    let initial_def = source_bindings[ns].get().map(|initial_binding| {\n                         all_ns_err = false;\n                         this.record_use(ident, ns, initial_binding,\n                                         directive.module_path.is_empty());\n@@ -1034,7 +1047,7 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n         let mut reexport_error = None;\n         let mut any_successful_reexport = false;\n         self.per_ns(|this, ns| {\n-            if let Ok(binding) = result[ns].get() {\n+            if let Ok(binding) = source_bindings[ns].get() {\n                 let vis = directive.vis.get();\n                 if !binding.pseudo_vis().is_at_least(vis, &*this) {\n                     reexport_error = Some((ns, binding));\n@@ -1078,7 +1091,7 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n             let mut full_path = directive.module_path.clone();\n             full_path.push(Segment::from_ident(ident));\n             self.per_ns(|this, ns| {\n-                if let Ok(binding) = result[ns].get() {\n+                if let Ok(binding) = source_bindings[ns].get() {\n                     this.lint_if_path_starts_with_module(\n                         directive.crate_lint(),\n                         &full_path,\n@@ -1092,7 +1105,7 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n         // Record what this import resolves to for later uses in documentation,\n         // this may resolve to either a value or a type, but for documentation\n         // purposes it's good enough to just favor one over the other.\n-        self.per_ns(|this, ns| if let Some(binding) = result[ns].get().ok() {\n+        self.per_ns(|this, ns| if let Some(binding) = source_bindings[ns].get().ok() {\n             let mut def = binding.def();\n             if let Def::Macro(def_id, _) = def {\n                 // `DefId`s from the \"built-in macro crate\" should not leak from resolve because"}, {"sha": "0631f2c355f7c36c2b9ccdcfbca5dba6da0a8cd5", "filename": "src/test/ui/feature-gates/feature-gate-uniform-paths.stderr", "status": "modified", "additions": 3, "deletions": 15, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c658d7340149274bb30a56fb3e7de799c266f4bc/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-uniform-paths.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c658d7340149274bb30a56fb3e7de799c266f4bc/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-uniform-paths.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-uniform-paths.stderr?ref=c658d7340149274bb30a56fb3e7de799c266f4bc", "patch": "@@ -25,11 +25,7 @@ LL | use inline; //~ ERROR imports can only refer to extern crate names\n    |     ^^^^^^ not an extern crate passed with `--extern`\n    |\n    = help: add #![feature(uniform_paths)] to the crate attributes to enable\n-note: this import refers to the built-in attribute imported here\n-  --> $DIR/feature-gate-uniform-paths.rs:21:5\n-   |\n-LL | use inline; //~ ERROR imports can only refer to extern crate names\n-   |     ^^^^^^\n+   = note: this import refers to a built-in attribute\n \n error[E0658]: imports can only refer to extern crate names passed with `--extern` on stable channel (see issue #53130)\n   --> $DIR/feature-gate-uniform-paths.rs:23:5\n@@ -38,11 +34,7 @@ LL | use Vec; //~ ERROR imports can only refer to extern crate names\n    |     ^^^ not an extern crate passed with `--extern`\n    |\n    = help: add #![feature(uniform_paths)] to the crate attributes to enable\n-note: this import refers to the struct imported here\n-  --> $DIR/feature-gate-uniform-paths.rs:23:5\n-   |\n-LL | use Vec; //~ ERROR imports can only refer to extern crate names\n-   |     ^^^\n+   = note: this import refers to a struct from prelude\n \n error[E0658]: imports can only refer to extern crate names passed with `--extern` on stable channel (see issue #53130)\n   --> $DIR/feature-gate-uniform-paths.rs:25:5\n@@ -51,11 +43,7 @@ LL | use vec; //~ ERROR imports can only refer to extern crate names\n    |     ^^^ not an extern crate passed with `--extern`\n    |\n    = help: add #![feature(uniform_paths)] to the crate attributes to enable\n-note: this import refers to the macro imported here\n-  --> $DIR/feature-gate-uniform-paths.rs:25:5\n-   |\n-LL | use vec; //~ ERROR imports can only refer to extern crate names\n-   |     ^^^\n+   = note: this import refers to a macro from prelude\n \n error: aborting due to 4 previous errors\n "}]}