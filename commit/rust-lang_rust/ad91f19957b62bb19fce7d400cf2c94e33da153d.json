{"sha": "ad91f19957b62bb19fce7d400cf2c94e33da153d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFkOTFmMTk5NTdiNjJiYjE5ZmNlN2Q0MDBjZjJjOTRlMzNkYTE1M2Q=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-02-22T12:06:19Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-03-09T14:45:29Z"}, "message": "typeck: Support multiple expressions getting coerced at the same type.", "tree": {"sha": "6dd5b3ee424c4927ab97c65b760404570b843647", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6dd5b3ee424c4927ab97c65b760404570b843647"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ad91f19957b62bb19fce7d400cf2c94e33da153d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ad91f19957b62bb19fce7d400cf2c94e33da153d", "html_url": "https://github.com/rust-lang/rust/commit/ad91f19957b62bb19fce7d400cf2c94e33da153d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ad91f19957b62bb19fce7d400cf2c94e33da153d/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3ff4c347c7f8958fe6fabf5dd385409ff84b3a54", "url": "https://api.github.com/repos/rust-lang/rust/commits/3ff4c347c7f8958fe6fabf5dd385409ff84b3a54", "html_url": "https://github.com/rust-lang/rust/commit/3ff4c347c7f8958fe6fabf5dd385409ff84b3a54"}], "stats": {"total": 441, "additions": 225, "deletions": 216}, "files": [{"sha": "bf60f435a2213f3a2ec9332431ef65f134c23990", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad91f19957b62bb19fce7d400cf2c94e33da153d/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad91f19957b62bb19fce7d400cf2c94e33da153d/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=ad91f19957b62bb19fce7d400cf2c94e33da153d", "patch": "@@ -82,7 +82,7 @@ pub fn check_call<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         autoderef(fcx,\n                   callee_expr.span,\n                   original_callee_ty,\n-                  Some(callee_expr),\n+                  || Some(callee_expr),\n                   UnresolvedTypeAction::Error,\n                   LvaluePreference::NoPreference,\n                   |adj_ty, idx| {"}, {"sha": "42aaea9db5f6cee8ef14894ff6e4fb7f3d73564b", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 66, "deletions": 49, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/ad91f19957b62bb19fce7d400cf2c94e33da153d/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad91f19957b62bb19fce7d400cf2c94e33da153d/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=ad91f19957b62bb19fce7d400cf2c94e33da153d", "patch": "@@ -87,6 +87,14 @@ struct Coerce<'a, 'tcx: 'a> {\n type CoerceResult<'tcx> = RelateResult<'tcx, Option<AutoAdjustment<'tcx>>>;\n \n impl<'f, 'tcx> Coerce<'f, 'tcx> {\n+    fn new(fcx: &'a FnCtxt<'a, 'tcx>, origin: TypeOrigin) -> Self {\n+        Coerce {\n+            fcx: fcx,\n+            origin: origin,\n+            unsizing_obligations: RefCell::new(vec![])\n+        }\n+    }\n+\n     fn tcx(&self) -> &TyCtxt<'tcx> {\n         self.fcx.tcx()\n     }\n@@ -96,16 +104,17 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         Ok(None) // No coercion required.\n     }\n \n-    fn coerce(&self,\n-              expr_a: &hir::Expr,\n-              a: Ty<'tcx>,\n-              b: Ty<'tcx>)\n-              -> CoerceResult<'tcx> {\n-        debug!(\"Coerce.tys({:?} => {:?})\",\n-               a,\n-               b);\n+    fn coerce<'a, E, I>(&self,\n+                        exprs: &E,\n+                        a: Ty<'tcx>,\n+                        b: Ty<'tcx>)\n+                        -> CoerceResult<'tcx>\n+        // FIXME(eddyb) use copyable iterators when that becomes ergonomic.\n+        where E: Fn() -> I,\n+              I: IntoIterator<Item=&'a hir::Expr> {\n \n         let a = self.fcx.infcx().shallow_resolve(a);\n+        debug!(\"Coerce.tys({:?} => {:?})\", a, b);\n \n         // Just ignore error types.\n         if a.references_error() || b.references_error() {\n@@ -156,15 +165,18 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n     /// Reborrows `&mut A` to `&mut B` and `&(mut) A` to `&B`.\n     /// To match `A` with `B`, autoderef will be performed,\n     /// calling `deref`/`deref_mut` where necessary.\n-    fn coerce_borrowed_pointer(&self,\n-                               expr_a: &hir::Expr,\n-                               a: Ty<'tcx>,\n-                               b: Ty<'tcx>,\n-                               mutbl_b: hir::Mutability)\n-                               -> CoerceResult<'tcx> {\n-        debug!(\"coerce_borrowed_pointer(a={:?}, b={:?})\",\n-               a,\n-               b);\n+    fn coerce_borrowed_pointer<'a, E, I>(&self,\n+                                         span: Span,\n+                                         exprs: &E,\n+                                         a: Ty<'tcx>,\n+                                         b: Ty<'tcx>,\n+                                         mutbl_b: hir::Mutability)\n+                                         -> CoerceResult<'tcx>\n+        // FIXME(eddyb) use copyable iterators when that becomes ergonomic.\n+        where E: Fn() -> I,\n+              I: IntoIterator<Item=&'a hir::Expr> {\n+\n+        debug!(\"coerce_borrowed_pointer(a={:?}, b={:?})\", a, b);\n \n         // If we have a parameter of type `&M T_a` and the value\n         // provided is `expr`, we will be adding an implicit borrow,\n@@ -179,17 +191,15 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n             _ => return self.subtype(a, b)\n         }\n \n-        let coercion = Coercion(self.origin.span());\n+        let span = self.origin.span();\n+        let coercion = Coercion(span);\n         let r_borrow = self.fcx.infcx().next_region_var(coercion);\n         let r_borrow = self.tcx().mk_region(r_borrow);\n         let autoref = Some(AutoPtr(r_borrow, mutbl_b));\n \n         let lvalue_pref = LvaluePreference::from_mutbl(mutbl_b);\n         let mut first_error = None;\n-        let (_, autoderefs, success) = autoderef(self.fcx,\n-                                                 expr_a.span,\n-                                                 a,\n-                                                 Some(expr_a),\n+        let (_, autoderefs, success) = autoderef(self.fcx, span, a, exprs,\n                                                  UnresolvedTypeAction::Ignore,\n                                                  lvalue_pref,\n                                                  |inner_ty, autoderef| {\n@@ -323,9 +333,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n             }\n         }\n \n-        let mut obligations = self.unsizing_obligations.borrow_mut();\n-        assert!(obligations.is_empty());\n-        *obligations = leftover_predicates;\n+        *self.unsizing_obligations.borrow_mut() = leftover_predicates;\n \n         let adjustment = AutoDerefRef {\n             autoderefs: if reborrow.is_some() { 1 } else { 0 },\n@@ -425,39 +433,48 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n     }\n }\n \n-pub fn try<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n-                     expr: &hir::Expr,\n-                     a: Ty<'tcx>,\n-                     b: Ty<'tcx>)\n-                     -> RelateResult<'tcx, ()> {\n-    debug!(\"coercion::try({:?} -> {:?})\", a, b);\n-    let mut unsizing_obligations = vec![];\n-    let adjustment = try!(indent(|| {\n-        fcx.infcx().commit_if_ok(|_| {\n-            let coerce = Coerce {\n-                fcx: fcx,\n-                origin: TypeOrigin::ExprAssignable(expr.span),\n-                unsizing_obligations: RefCell::new(vec![])\n-            };\n-            let adjustment = try!(coerce.coerce(expr, a, b));\n-            unsizing_obligations = coerce.unsizing_obligations.into_inner();\n-            Ok(adjustment)\n-        })\n-    }));\n+fn apply<'a, 'b, 'tcx, E, I>(coerce: &mut Coerce<'a, 'tcx>,\n+                             exprs: &E,\n+                             a: Ty<'tcx>,\n+                             b: Ty<'tcx>)\n+                             -> RelateResult<'tcx, Ty<'tcx>>\n+    where E: Fn() -> I,\n+          I: IntoIterator<Item=&'b hir::Expr> {\n+\n+    let (ty, adjustment) = try!(indent(|| coerce.coerce(exprs, a, b)));\n \n-    if let Some(AdjustDerefRef(auto)) = adjustment {\n+    let fcx = coerce.fcx;\n+    if let AdjustDerefRef(auto) = adjustment {\n         if auto.unsize.is_some() {\n-            for obligation in unsizing_obligations {\n+            for obligation in coerce.unsizing_obligations.borrow_mut().drain() {\n                 fcx.register_predicate(obligation);\n             }\n         }\n     }\n \n-    if let Some(adjustment) = adjustment {\n+    if !adjustment.is_identity() {\n         debug!(\"Success, coerced with {:?}\", adjustment);\n-        fcx.write_adjustment(expr.id, adjustment);\n+        for expr in exprs() {\n+            assert!(!fcx.inh.tables.borrow().adjustments.contains(&expr.id));\n+            fcx.write_adjustment(expr.id, adjustment);\n+        }\n     }\n-    Ok(())\n+    Ok(ty)\n+}\n+\n+/// Attempt to coerce an expression from a type (a) to another type (b).\n+/// Adjustments are only recorded if the coercion was successful.\n+/// The expressions *must not* have any pre-existing adjustments.\n+pub fn try<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                     expr: &hir::Expr,\n+                     a: Ty<'tcx>,\n+                     b: Ty<'tcx>)\n+                     -> RelateResult<'tcx, ()> {\n+    debug!(\"coercion::try({:?} -> {:?})\", a, b);\n+    let mut coerce = Coerce::new(fcx, TypeOrigin::ExprAssignable(expr.span));\n+    fcx.infcx().commit_if_ok(|_| {\n+        apply(&mut coerce, &|| Some(expr), a, b)\n+    }).map(|_| ())\n }\n \n fn coerce_mutbls<'tcx>(from_mutbl: hir::Mutability,"}, {"sha": "f4268deee37c5a381517ba0a52feaf836ee1ed48", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 83, "deletions": 81, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/ad91f19957b62bb19fce7d400cf2c94e33da153d/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad91f19957b62bb19fce7d400cf2c94e33da153d/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=ad91f19957b62bb19fce7d400cf2c94e33da153d", "patch": "@@ -158,7 +158,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n         let (autoderefd_ty, n, result) = check::autoderef(self.fcx,\n                                                           self.span,\n                                                           unadjusted_self_ty,\n-                                                          Some(self.self_expr),\n+                                                          || Some(self.self_expr),\n                                                           UnresolvedTypeAction::Error,\n                                                           NoPreference,\n                                                           |_, n| {\n@@ -287,7 +287,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n         let (_, _, result) = check::autoderef(self.fcx,\n                                               self.span,\n                                               self_ty,\n-                                              None,\n+                                              || None,\n                                               UnresolvedTypeAction::Error,\n                                               NoPreference,\n                                               |ty, _| {\n@@ -509,7 +509,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                 check::autoderef(self.fcx,\n                                  expr.span,\n                                  self.fcx.expr_ty(expr),\n-                                 Some(expr),\n+                                 || Some(expr),\n                                  UnresolvedTypeAction::Error,\n                                  PreferMutLvalue,\n                                  |_, autoderefs| {\n@@ -522,92 +522,94 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n             }\n \n             // Don't retry the first one or we might infinite loop!\n-            if i != 0 {\n-                match expr.node {\n-                    hir::ExprIndex(ref base_expr, ref index_expr) => {\n-                        // If this is an overloaded index, the\n-                        // adjustment will include an extra layer of\n-                        // autoref because the method is an &self/&mut\n-                        // self method. We have to peel it off to get\n-                        // the raw adjustment that `try_index_step`\n-                        // expects. This is annoying and horrible. We\n-                        // ought to recode this routine so it doesn't\n-                        // (ab)use the normal type checking paths.\n-                        let adj = self.fcx.inh.tables.borrow().adjustments.get(&base_expr.id)\n-                                                                          .cloned();\n-                        let (autoderefs, unsize) = match adj {\n-                            Some(AdjustDerefRef(adr)) => match adr.autoref {\n-                                None => {\n-                                    assert!(adr.unsize.is_none());\n-                                    (adr.autoderefs, None)\n-                                }\n-                                Some(AutoPtr(_, _)) => {\n-                                    (adr.autoderefs, adr.unsize.map(|target| {\n-                                        target.builtin_deref(false, NoPreference)\n-                                              .expect(\"fixup: AutoPtr is not &T\").ty\n-                                    }))\n-                                }\n-                                Some(_) => {\n-                                    self.tcx().sess.span_bug(\n-                                        base_expr.span,\n-                                        &format!(\"unexpected adjustment autoref {:?}\",\n-                                                adr));\n-                                }\n-                            },\n-                            None => (0, None),\n+            if i == 0 {\n+                continue;\n+            }\n+            match expr.node {\n+                hir::ExprIndex(ref base_expr, ref index_expr) => {\n+                    // If this is an overloaded index, the\n+                    // adjustment will include an extra layer of\n+                    // autoref because the method is an &self/&mut\n+                    // self method. We have to peel it off to get\n+                    // the raw adjustment that `try_index_step`\n+                    // expects. This is annoying and horrible. We\n+                    // ought to recode this routine so it doesn't\n+                    // (ab)use the normal type checking paths.\n+                    let adj = self.fcx.inh.tables.borrow().adjustments.get(&base_expr.id)\n+                                                                        .cloned();\n+                    let (autoderefs, unsize) = match adj {\n+                        Some(AdjustDerefRef(adr)) => match adr.autoref {\n+                            None => {\n+                                assert!(adr.unsize.is_none());\n+                                (adr.autoderefs, None)\n+                            }\n+                            Some(AutoPtr(_, _)) => {\n+                                (adr.autoderefs, adr.unsize.map(|target| {\n+                                    target.builtin_deref(false, NoPreference)\n+                                            .expect(\"fixup: AutoPtr is not &T\").ty\n+                                }))\n+                            }\n                             Some(_) => {\n                                 self.tcx().sess.span_bug(\n                                     base_expr.span,\n-                                    \"unexpected adjustment type\");\n+                                    &format!(\"unexpected adjustment autoref {:?}\",\n+                                            adr));\n                             }\n-                        };\n-\n-                        let (adjusted_base_ty, unsize) = if let Some(target) = unsize {\n-                            (target, true)\n-                        } else {\n-                            (self.fcx.adjust_expr_ty(base_expr,\n-                                Some(&AdjustDerefRef(AutoDerefRef {\n-                                    autoderefs: autoderefs,\n-                                    autoref: None,\n-                                    unsize: None\n-                                }))), false)\n-                        };\n-                        let index_expr_ty = self.fcx.expr_ty(&index_expr);\n-\n-                        let result = check::try_index_step(\n-                            self.fcx,\n-                            ty::MethodCall::expr(expr.id),\n-                            expr,\n-                            &base_expr,\n-                            adjusted_base_ty,\n-                            autoderefs,\n-                            unsize,\n-                            PreferMutLvalue,\n-                            index_expr_ty);\n-\n-                        if let Some((input_ty, return_ty)) = result {\n-                            demand::suptype(self.fcx, index_expr.span, input_ty, index_expr_ty);\n-\n-                            let expr_ty = self.fcx.expr_ty(&expr);\n-                            demand::suptype(self.fcx, expr.span, expr_ty, return_ty);\n+                        },\n+                        None => (0, None),\n+                        Some(_) => {\n+                            self.tcx().sess.span_bug(\n+                                base_expr.span,\n+                                \"unexpected adjustment type\");\n                         }\n+                    };\n+\n+                    let (adjusted_base_ty, unsize) = if let Some(target) = unsize {\n+                        (target, true)\n+                    } else {\n+                        (self.fcx.adjust_expr_ty(base_expr,\n+                            Some(&AdjustDerefRef(AutoDerefRef {\n+                                autoderefs: autoderefs,\n+                                autoref: None,\n+                                unsize: None\n+                            }))), false)\n+                    };\n+                    let index_expr_ty = self.fcx.expr_ty(&index_expr);\n+\n+                    let result = check::try_index_step(\n+                        self.fcx,\n+                        ty::MethodCall::expr(expr.id),\n+                        expr,\n+                        &base_expr,\n+                        adjusted_base_ty,\n+                        autoderefs,\n+                        unsize,\n+                        PreferMutLvalue,\n+                        index_expr_ty);\n+\n+                    if let Some((input_ty, return_ty)) = result {\n+                        demand::suptype(self.fcx, index_expr.span, input_ty, index_expr_ty);\n+\n+                        let expr_ty = self.fcx.expr_ty(&expr);\n+                        demand::suptype(self.fcx, expr.span, expr_ty, return_ty);\n                     }\n-                    hir::ExprUnary(hir::UnDeref, ref base_expr) => {\n-                        // if this is an overloaded deref, then re-evaluate with\n-                        // a preference for mut\n-                        let method_call = ty::MethodCall::expr(expr.id);\n-                        if self.fcx.inh.tables.borrow().method_map.contains_key(&method_call) {\n-                            check::try_overloaded_deref(\n-                                self.fcx,\n-                                expr.span,\n-                                Some(method_call),\n-                                Some(&base_expr),\n-                                self.fcx.expr_ty(&base_expr),\n-                                PreferMutLvalue);\n-                        }\n+                }\n+                hir::ExprUnary(hir::UnDeref, ref base_expr) => {\n+                    // if this is an overloaded deref, then re-evaluate with\n+                    // a preference for mut\n+                    let method_call = ty::MethodCall::expr(expr.id);\n+                    if self.fcx.inh.tables.borrow().method_map.contains_key(&method_call) {\n+                        let method = check::try_overloaded_deref(\n+                            self.fcx,\n+                            expr.span,\n+                            Some(&base_expr),\n+                            self.fcx.expr_ty(&base_expr),\n+                            PreferMutLvalue);\n+                        let method = method.expect(\"re-trying deref failed\");\n+                        self.fcx.inh.tables.borrow_mut().method_map.insert(method_call, method);\n                     }\n-                    _ => {}\n                 }\n+                _ => {}\n             }\n         }\n     }"}, {"sha": "d11a07cb41ff77a3f28be6adb14899cc6a524525", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad91f19957b62bb19fce7d400cf2c94e33da153d/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad91f19957b62bb19fce7d400cf2c94e33da153d/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=ad91f19957b62bb19fce7d400cf2c94e33da153d", "patch": "@@ -200,7 +200,7 @@ fn create_steps<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     let (final_ty, dereferences, _) = check::autoderef(fcx,\n                                                        span,\n                                                        self_ty,\n-                                                       None,\n+                                                       || None,\n                                                        UnresolvedTypeAction::Error,\n                                                        NoPreference,\n                                                        |t, d| {"}, {"sha": "7dc9d46c303f0c5271636286e57bd24b6b936004", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad91f19957b62bb19fce7d400cf2c94e33da153d/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad91f19957b62bb19fce7d400cf2c94e33da153d/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=ad91f19957b62bb19fce7d400cf2c94e33da153d", "patch": "@@ -351,7 +351,7 @@ fn type_derefs_to_local<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         return is_local(fcx.resolve_type_vars_if_possible(rcvr_ty));\n     }\n \n-    check::autoderef(fcx, span, rcvr_ty, None,\n+    check::autoderef(fcx, span, rcvr_ty, || None,\n                      check::UnresolvedTypeAction::Ignore, ty::NoPreference,\n                      |ty, _| {\n         if is_local(ty) {"}, {"sha": "311b6a9772c0bfbe350fedcda919810c23d55e00", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 73, "deletions": 83, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/ad91f19957b62bb19fce7d400cf2c94e33da153d/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad91f19957b62bb19fce7d400cf2c94e33da153d/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=ad91f19957b62bb19fce7d400cf2c94e33da153d", "patch": "@@ -2053,20 +2053,21 @@ pub enum UnresolvedTypeAction {\n ///\n /// Note: this method does not modify the adjustments table. The caller is responsible for\n /// inserting an AutoAdjustment record into the `fcx` using one of the suitable methods.\n-pub fn autoderef<'a, 'tcx, T, F>(fcx: &FnCtxt<'a, 'tcx>,\n-                                 sp: Span,\n-                                 base_ty: Ty<'tcx>,\n-                                 opt_expr: Option<&hir::Expr>,\n-                                 unresolved_type_action: UnresolvedTypeAction,\n-                                 mut lvalue_pref: LvaluePreference,\n-                                 mut should_stop: F)\n-                                 -> (Ty<'tcx>, usize, Option<T>)\n-    where F: FnMut(Ty<'tcx>, usize) -> Option<T>,\n+pub fn autoderef<'a, 'b, 'tcx, E, I, T, F>(fcx: &FnCtxt<'a, 'tcx>,\n+                                           sp: Span,\n+                                           base_ty: Ty<'tcx>,\n+                                           maybe_exprs: E,\n+                                           unresolved_type_action: UnresolvedTypeAction,\n+                                           mut lvalue_pref: LvaluePreference,\n+                                           mut should_stop: F)\n+                                           -> (Ty<'tcx>, usize, Option<T>)\n+    // FIXME(eddyb) use copyable iterators when that becomes ergonomic.\n+    where E: Fn() -> I,\n+          I: IntoIterator<Item=&'b hir::Expr>,\n+          F: FnMut(Ty<'tcx>, usize) -> Option<T>,\n {\n-    debug!(\"autoderef(base_ty={:?}, opt_expr={:?}, lvalue_pref={:?})\",\n-           base_ty,\n-           opt_expr,\n-           lvalue_pref);\n+    debug!(\"autoderef(base_ty={:?}, lvalue_pref={:?})\",\n+           base_ty, lvalue_pref);\n \n     let mut t = base_ty;\n     for autoderefs in 0..fcx.tcx().sess.recursion_limit.get() {\n@@ -2092,34 +2093,34 @@ pub fn autoderef<'a, 'tcx, T, F>(fcx: &FnCtxt<'a, 'tcx>,\n         }\n \n         // Otherwise, deref if type is derefable:\n-        let mt = match resolved_t.builtin_deref(false, lvalue_pref) {\n-            Some(mt) => Some(mt),\n-            None => {\n-                let method_call =\n-                    opt_expr.map(|expr| MethodCall::autoderef(expr.id, autoderefs as u32));\n-\n-                // Super subtle: it might seem as though we should\n-                // pass `opt_expr` to `try_overloaded_deref`, so that\n-                // the (implicit) autoref of using an overloaded deref\n-                // would get added to the adjustment table. However we\n-                // do not do that, because it's kind of a\n-                // \"meta-adjustment\" -- instead, we just leave it\n-                // unrecorded and know that there \"will be\" an\n-                // autoref. regionck and other bits of the code base,\n-                // when they encounter an overloaded autoderef, have\n-                // to do some reconstructive surgery. This is a pretty\n-                // complex mess that is begging for a proper MIR.\n-                try_overloaded_deref(fcx, sp, method_call, None, resolved_t, lvalue_pref)\n+\n+        // Super subtle: it might seem as though we should\n+        // pass `opt_expr` to `try_overloaded_deref`, so that\n+        // the (implicit) autoref of using an overloaded deref\n+        // would get added to the adjustment table. However we\n+        // do not do that, because it's kind of a\n+        // \"meta-adjustment\" -- instead, we just leave it\n+        // unrecorded and know that there \"will be\" an\n+        // autoref. regionck and other bits of the code base,\n+        // when they encounter an overloaded autoderef, have\n+        // to do some reconstructive surgery. This is a pretty\n+        // complex mess that is begging for a proper MIR.\n+        let mt = if let Some(mt) = resolved_t.builtin_deref(false, lvalue_pref) {\n+            mt\n+        } else if let Some(method) = try_overloaded_deref(fcx, sp, None,\n+                                                          resolved_t, lvalue_pref) {\n+            for expr in maybe_exprs() {\n+                let method_call = MethodCall::autoderef(expr.id, autoderefs as u32);\n+                fcx.inh.tables.borrow_mut().method_map.insert(method_call, method);\n             }\n+            make_overloaded_lvalue_return_type(fcx.tcx(), method)\n+        } else {\n+            return (resolved_t, autoderefs, None);\n         };\n-        match mt {\n-            Some(mt) => {\n-                t = mt.ty;\n-                if mt.mutbl == hir::MutImmutable {\n-                    lvalue_pref = NoPreference;\n-                }\n-            }\n-            None => return (resolved_t, autoderefs, None)\n+\n+        t = mt.ty;\n+        if mt.mutbl == hir::MutImmutable {\n+            lvalue_pref = NoPreference;\n         }\n     }\n \n@@ -2132,11 +2133,10 @@ pub fn autoderef<'a, 'tcx, T, F>(fcx: &FnCtxt<'a, 'tcx>,\n \n fn try_overloaded_deref<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                   span: Span,\n-                                  method_call: Option<MethodCall>,\n                                   base_expr: Option<&hir::Expr>,\n                                   base_ty: Ty<'tcx>,\n                                   lvalue_pref: LvaluePreference)\n-                                  -> Option<ty::TypeAndMut<'tcx>>\n+                                  -> Option<MethodCallee<'tcx>>\n {\n     // Try DerefMut first, if preferred.\n     let method = match (lvalue_pref, fcx.tcx().lang_items.deref_mut_trait()) {\n@@ -2158,33 +2158,23 @@ fn try_overloaded_deref<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         (method, _) => method\n     };\n \n-    make_overloaded_lvalue_return_type(fcx, method_call, method)\n+    method\n }\n \n /// For the overloaded lvalue expressions (`*x`, `x[3]`), the trait returns a type of `&T`, but the\n /// actual type we assign to the *expression* is `T`. So this function just peels off the return\n-/// type by one layer to yield `T`. It also inserts the `method-callee` into the method map.\n-fn make_overloaded_lvalue_return_type<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n-                                                method_call: Option<MethodCall>,\n-                                                method: Option<MethodCallee<'tcx>>)\n-                                                -> Option<ty::TypeAndMut<'tcx>>\n+/// type by one layer to yield `T`.\n+fn make_overloaded_lvalue_return_type<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                            method: MethodCallee<'tcx>)\n+                                            -> ty::TypeAndMut<'tcx>\n {\n-    match method {\n-        Some(method) => {\n-            // extract method return type, which will be &T;\n-            // all LB regions should have been instantiated during method lookup\n-            let ret_ty = method.ty.fn_ret();\n-            let ret_ty = fcx.tcx().no_late_bound_regions(&ret_ty).unwrap().unwrap();\n-\n-            if let Some(method_call) = method_call {\n-                fcx.inh.tables.borrow_mut().method_map.insert(method_call, method);\n-            }\n+    // extract method return type, which will be &T;\n+    // all LB regions should have been instantiated during method lookup\n+    let ret_ty = method.ty.fn_ret();\n+    let ret_ty = tcx.no_late_bound_regions(&ret_ty).unwrap().unwrap();\n \n-            // method returns &T, but the type as visible to user is T, so deref\n-            ret_ty.builtin_deref(true, NoPreference)\n-        }\n-        None => None,\n-    }\n+    // method returns &T, but the type as visible to user is T, so deref\n+    ret_ty.builtin_deref(true, NoPreference).unwrap()\n }\n \n fn lookup_indexing<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n@@ -2202,7 +2192,7 @@ fn lookup_indexing<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     let (ty, autoderefs, final_mt) = autoderef(fcx,\n                                                base_expr.span,\n                                                base_ty,\n-                                               Some(base_expr),\n+                                               || Some(base_expr),\n                                                UnresolvedTypeAction::Error,\n                                                lvalue_pref,\n                                                |adj_ty, idx| {\n@@ -2299,10 +2289,10 @@ fn try_index_step<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     // If some lookup succeeds, write callee into table and extract index/element\n     // type from the method signature.\n     // If some lookup succeeded, install method in table\n-    method.and_then(|method| {\n+    method.map(|method| {\n         debug!(\"try_index_step: success, using overloaded indexing\");\n-        make_overloaded_lvalue_return_type(fcx, Some(method_call), Some(method)).\n-            map(|ret| (input_ty, ret.ty))\n+        fcx.inh.tables.borrow_mut().method_map.insert(method_call, method);\n+        (input_ty, make_overloaded_lvalue_return_type(fcx.tcx(), method).ty)\n     })\n }\n \n@@ -2907,7 +2897,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         let (_, autoderefs, field_ty) = autoderef(fcx,\n                                                   expr.span,\n                                                   expr_t,\n-                                                  Some(base),\n+                                                  || Some(base),\n                                                   UnresolvedTypeAction::Error,\n                                                   lvalue_pref,\n                                                   |base_t, _| {\n@@ -3005,7 +2995,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         let (_, autoderefs, field_ty) = autoderef(fcx,\n                                                   expr.span,\n                                                   expr_t,\n-                                                  Some(base),\n+                                                  || Some(base),\n                                                   UnresolvedTypeAction::Error,\n                                                   lvalue_pref,\n                                                   |base_t, _| {\n@@ -3253,21 +3243,21 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n             match unop {\n                 hir::UnDeref => {\n                     oprnd_t = structurally_resolved_type(fcx, expr.span, oprnd_t);\n-                    oprnd_t = match oprnd_t.builtin_deref(true, NoPreference) {\n-                        Some(mt) => mt.ty,\n-                        None => match try_overloaded_deref(fcx, expr.span,\n-                                                           Some(MethodCall::expr(expr.id)),\n-                                                           Some(&oprnd), oprnd_t, lvalue_pref) {\n-                            Some(mt) => mt.ty,\n-                            None => {\n-                                fcx.type_error_message(expr.span, |actual| {\n-                                    format!(\"type `{}` cannot be \\\n-                                            dereferenced\", actual)\n-                                }, oprnd_t, None);\n-                                tcx.types.err\n-                            }\n-                        }\n-                    };\n+\n+                    if let Some(mt) = oprnd_t.builtin_deref(true, NoPreference) {\n+                        oprnd_t = mt.ty;\n+                    } else if let Some(method) = try_overloaded_deref(\n+                            fcx, expr.span, Some(&oprnd), oprnd_t, lvalue_pref) {\n+                        oprnd_t = make_overloaded_lvalue_return_type(tcx, method).ty;\n+                        fcx.inh.tables.borrow_mut().method_map.insert(MethodCall::expr(expr.id),\n+                                                                      method);\n+                    } else {\n+                        fcx.type_error_message(expr.span, |actual| {\n+                            format!(\"type `{}` cannot be \\\n+                                    dereferenced\", actual)\n+                        }, oprnd_t, None);\n+                        oprnd_t = tcx.types.err;\n+                    }\n                 }\n                 hir::UnNot => {\n                     oprnd_t = structurally_resolved_type(fcx, oprnd.span,"}]}