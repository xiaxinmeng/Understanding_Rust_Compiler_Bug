{"sha": "1773c6d154abe5da00b31bb16139addcaa443bbb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE3NzNjNmQxNTRhYmU1ZGEwMGIzMWJiMTYxMzlhZGRjYWE0NDNiYmI=", "commit": {"author": {"name": "Igor Aleksanov", "email": "popzxc@yandex.ru", "date": "2020-10-03T11:35:26Z"}, "committer": {"name": "Igor Aleksanov", "email": "popzxc@yandex.ru", "date": "2020-10-12T07:59:54Z"}, "message": "Extract helper functions into a separate module", "tree": {"sha": "1b6f0c6b6a031bcc74d3a46004553fcdaf6d0d16", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1b6f0c6b6a031bcc74d3a46004553fcdaf6d0d16"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1773c6d154abe5da00b31bb16139addcaa443bbb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1773c6d154abe5da00b31bb16139addcaa443bbb", "html_url": "https://github.com/rust-lang/rust/commit/1773c6d154abe5da00b31bb16139addcaa443bbb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1773c6d154abe5da00b31bb16139addcaa443bbb/comments", "author": {"login": "popzxc", "id": 12111581, "node_id": "MDQ6VXNlcjEyMTExNTgx", "avatar_url": "https://avatars.githubusercontent.com/u/12111581?v=4", "gravatar_id": "", "url": "https://api.github.com/users/popzxc", "html_url": "https://github.com/popzxc", "followers_url": "https://api.github.com/users/popzxc/followers", "following_url": "https://api.github.com/users/popzxc/following{/other_user}", "gists_url": "https://api.github.com/users/popzxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/popzxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/popzxc/subscriptions", "organizations_url": "https://api.github.com/users/popzxc/orgs", "repos_url": "https://api.github.com/users/popzxc/repos", "events_url": "https://api.github.com/users/popzxc/events{/privacy}", "received_events_url": "https://api.github.com/users/popzxc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "popzxc", "id": 12111581, "node_id": "MDQ6VXNlcjEyMTExNTgx", "avatar_url": "https://avatars.githubusercontent.com/u/12111581?v=4", "gravatar_id": "", "url": "https://api.github.com/users/popzxc", "html_url": "https://github.com/popzxc", "followers_url": "https://api.github.com/users/popzxc/followers", "following_url": "https://api.github.com/users/popzxc/following{/other_user}", "gists_url": "https://api.github.com/users/popzxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/popzxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/popzxc/subscriptions", "organizations_url": "https://api.github.com/users/popzxc/orgs", "repos_url": "https://api.github.com/users/popzxc/repos", "events_url": "https://api.github.com/users/popzxc/events{/privacy}", "received_events_url": "https://api.github.com/users/popzxc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f5cea35986a0c8182ca427f10e20bc97ec564315", "url": "https://api.github.com/repos/rust-lang/rust/commits/f5cea35986a0c8182ca427f10e20bc97ec564315", "html_url": "https://github.com/rust-lang/rust/commit/f5cea35986a0c8182ca427f10e20bc97ec564315"}], "stats": {"total": 141, "additions": 112, "deletions": 29}, "files": [{"sha": "1a0906492d6553ae54e5179d44798e8c068e333d", "filename": "crates/hir_ty/src/diagnostics/decl_check.rs", "status": "modified", "additions": 20, "deletions": 29, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/1773c6d154abe5da00b31bb16139addcaa443bbb/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fdecl_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1773c6d154abe5da00b31bb16139addcaa443bbb/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fdecl_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fdecl_check.rs?ref=1773c6d154abe5da00b31bb16139addcaa443bbb", "patch": "@@ -9,6 +9,8 @@\n // If you see these lines in the pull request, feel free to call me stupid :P.\n #![allow(dead_code, unused_imports, unused_variables)]\n \n+mod str_helpers;\n+\n use std::sync::Arc;\n \n use hir_def::{\n@@ -18,7 +20,7 @@ use hir_def::{\n     item_tree::ItemTreeNode,\n     resolver::{resolver_for_expr, ResolveValueResult, ValueNs},\n     src::HasSource,\n-    AdtId, FunctionId, Lookup, ModuleDefId,\n+    AdtId, EnumId, FunctionId, Lookup, ModuleDefId, StructId,\n };\n use hir_expand::{diagnostics::DiagnosticSink, name::Name};\n use syntax::{\n@@ -28,7 +30,7 @@ use syntax::{\n \n use crate::{\n     db::HirDatabase,\n-    diagnostics::{CaseType, IncorrectCase},\n+    diagnostics::{decl_check::str_helpers::*, CaseType, IncorrectCase},\n     lower::CallableDefId,\n     ApplicationTy, InferenceResult, Ty, TypeCtor,\n };\n@@ -191,41 +193,30 @@ impl<'a, 'b> DeclValidator<'a, 'b> {\n         }\n     }\n \n-    fn validate_adt(&mut self, db: &dyn HirDatabase, adt: AdtId) {}\n-}\n-\n-fn pat_equals_to_name(pat: Option<ast::Pat>, name: &Name) -> bool {\n-    if let Some(ast::Pat::IdentPat(ident)) = pat {\n-        ident.to_string() == name.to_string()\n-    } else {\n-        false\n+    fn validate_adt(&mut self, db: &dyn HirDatabase, adt: AdtId) {\n+        match adt {\n+            AdtId::StructId(struct_id) => self.validate_struct(db, struct_id),\n+            AdtId::EnumId(enum_id) => self.validate_enum(db, enum_id),\n+            AdtId::UnionId(_) => {\n+                // Unions aren't yet supported by this validator.\n+            }\n+        }\n     }\n-}\n \n-fn to_lower_snake_case(ident: &str) -> Option<String> {\n-    // First, assume that it's UPPER_SNAKE_CASE.\n-    if let Some(normalized) = to_lower_snake_case_from_upper_snake_case(ident) {\n-        return Some(normalized);\n+    fn validate_struct(&mut self, db: &dyn HirDatabase, struct_id: StructId) {\n+        let data = db.struct_data(struct_id);\n     }\n \n-    // Otherwise, assume that it's CamelCase.\n-    let lower_snake_case = stdx::to_lower_snake_case(ident);\n-\n-    if lower_snake_case == ident {\n-        None\n-    } else {\n-        Some(lower_snake_case)\n+    fn validate_enum(&mut self, db: &dyn HirDatabase, enum_id: EnumId) {\n+        let data = db.enum_data(enum_id);\n     }\n }\n \n-fn to_lower_snake_case_from_upper_snake_case(ident: &str) -> Option<String> {\n-    let is_upper_snake_case = ident.chars().all(|c| c.is_ascii_uppercase() || c == '_');\n-\n-    if is_upper_snake_case {\n-        let string = ident.chars().map(|c| c.to_ascii_lowercase()).collect();\n-        Some(string)\n+fn pat_equals_to_name(pat: Option<ast::Pat>, name: &Name) -> bool {\n+    if let Some(ast::Pat::IdentPat(ident)) = pat {\n+        ident.to_string() == name.to_string()\n     } else {\n-        None\n+        false\n     }\n }\n "}, {"sha": "3d8f1b5f2d146d992fe9365f9d836386d1867ace", "filename": "crates/hir_ty/src/diagnostics/decl_check/str_helpers.rs", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/1773c6d154abe5da00b31bb16139addcaa443bbb/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fdecl_check%2Fstr_helpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1773c6d154abe5da00b31bb16139addcaa443bbb/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fdecl_check%2Fstr_helpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fdecl_check%2Fstr_helpers.rs?ref=1773c6d154abe5da00b31bb16139addcaa443bbb", "patch": "@@ -0,0 +1,92 @@\n+pub fn to_camel_case(ident: &str) -> Option<String> {\n+    let mut output = String::new();\n+\n+    if is_camel_case(ident) {\n+        return None;\n+    }\n+\n+    let mut capital_added = false;\n+    for chr in ident.chars() {\n+        if chr.is_alphabetic() {\n+            if !capital_added {\n+                output.push(chr.to_ascii_uppercase());\n+                capital_added = true;\n+            } else {\n+                output.push(chr.to_ascii_lowercase());\n+            }\n+        } else if chr == '_' {\n+            // Skip this character and make the next one capital.\n+            capital_added = false;\n+        } else {\n+            // Put the characted as-is.\n+            output.push(chr);\n+        }\n+    }\n+\n+    if output == ident {\n+        None\n+    } else {\n+        Some(output)\n+    }\n+}\n+\n+pub fn to_lower_snake_case(ident: &str) -> Option<String> {\n+    // First, assume that it's UPPER_SNAKE_CASE.\n+    if let Some(normalized) = to_lower_snake_case_from_upper_snake_case(ident) {\n+        return Some(normalized);\n+    }\n+\n+    // Otherwise, assume that it's CamelCase.\n+    let lower_snake_case = stdx::to_lower_snake_case(ident);\n+\n+    if lower_snake_case == ident {\n+        None\n+    } else {\n+        Some(lower_snake_case)\n+    }\n+}\n+\n+fn to_lower_snake_case_from_upper_snake_case(ident: &str) -> Option<String> {\n+    if is_upper_snake_case(ident) {\n+        let string = ident.chars().map(|c| c.to_ascii_lowercase()).collect();\n+        Some(string)\n+    } else {\n+        None\n+    }\n+}\n+\n+fn is_upper_snake_case(ident: &str) -> bool {\n+    ident.chars().all(|c| c.is_ascii_uppercase() || c == '_')\n+}\n+\n+fn is_camel_case(ident: &str) -> bool {\n+    // We assume that the string is either snake case or camel case.\n+    ident.chars().all(|c| c != '_')\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+    use expect_test::{expect, Expect};\n+\n+    fn check<F: Fn(&str) -> Option<String>>(fun: F, input: &str, expect: Expect) {\n+        // `None` is translated to empty string, meaning that there is nothing to fix.\n+        let output = fun(input).unwrap_or_default();\n+\n+        expect.assert_eq(&output);\n+    }\n+\n+    #[test]\n+    fn test_to_lower_snake_case() {\n+        check(to_lower_snake_case, \"lower_snake_case\", expect![[\"\"]]);\n+        check(to_lower_snake_case, \"UPPER_SNAKE_CASE\", expect![[\"upper_snake_case\"]]);\n+        check(to_lower_snake_case, \"CamelCase\", expect![[\"camel_case\"]]);\n+    }\n+\n+    #[test]\n+    fn test_to_camel_case() {\n+        check(to_camel_case, \"CamelCase\", expect![[\"\"]]);\n+        check(to_camel_case, \"lower_snake_case\", expect![[\"LowerSnakeCase\"]]);\n+        check(to_camel_case, \"UPPER_SNAKE_CASE\", expect![[\"UpperSnakeCase\"]]);\n+    }\n+}"}]}