{"sha": "d317da48b1341eec28ed070002a7110b39b9ae15", "node_id": "C_kwDOAAsO6NoAKGQzMTdkYTQ4YjEzNDFlZWMyOGVkMDcwMDAyYTcxMTBiMzliOWFlMTU", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2021-12-10T21:40:32Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-12-10T21:40:32Z"}, "message": "Rollup merge of #91325 - RalfJung:const_eval_select, r=dtolnay\n\nadjust const_eval_select documentation\n\n\"The Rust compiler assumes\" indicates that this is language UB, but [I don't think that is a good idea](https://rust-lang.zulipchat.com/#narrow/stream/146212-t-compiler.2Fconst-eval/topic/const_eval_select.20assumptions). This UB would be very hard to test for and looks like a way-too-big footgun. ``@oli-obk`` suggested this is meant to be more like \"library UB\", so I tried to adjust the docs accordingly.\n\nI also removed all references to \"referential transparency\". That is a rather vague concept used to mean many different things, and I honestly have no idea what exactly is meant by it in this specific instance. But I assume ``@fee1-dead`` had in their mind a property that all `const fn` code upholds, so by demanding that the runtime code and the const-time code are *observably equivalent*, whatever that property is would also be enforced here.\n\nCc ``@rust-lang/wg-const-eval``", "tree": {"sha": "65f021f374e4c2015a9f4ec5dc4ffc6e0c242e69", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/65f021f374e4c2015a9f4ec5dc4ffc6e0c242e69"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d317da48b1341eec28ed070002a7110b39b9ae15", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhs8lQCRBK7hj4Ov3rIwAAHngIABtISl2hBdAywq0eY4hkt4mZ\nSwu6H/e+6B6JBmYsjbwtrbvy7LNZoHpAd1JQiywMjquQJlI55H42PFiM+2MgnvnX\nzYt7GGQinX+vdsJy5QJiMydTj8LmXWB73qPbHzQ0NrTX2da2A/smXPt0658ZF6ga\njBN6h7dSqnKk6y+DFc63BMT5upIpRNh2m7wPwzHyHt1k+aRpsWFpxSmM3LvA+loe\nap9fOLI2rnRpX5Ub5xLUSma3ZpT+KGjozLkgj40K27HgKrhpXS3cZaho/KT0mkIO\nHUt74/ONdA/QxYZTuZxsxo8426uYMABhmSvfvu1C1wIDZ5pf8D3yFm1mb7JwuBU=\n=Yg2f\n-----END PGP SIGNATURE-----\n", "payload": "tree 65f021f374e4c2015a9f4ec5dc4ffc6e0c242e69\nparent 60aa03aa71e6057bded100d24519e6309c2152d6\nparent 85558ad5b39d435d3c57e3e0df5f4c160ee0c6e3\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1639172432 +0100\ncommitter GitHub <noreply@github.com> 1639172432 +0100\n\nRollup merge of #91325 - RalfJung:const_eval_select, r=dtolnay\n\nadjust const_eval_select documentation\n\n\"The Rust compiler assumes\" indicates that this is language UB, but [I don't think that is a good idea](https://rust-lang.zulipchat.com/#narrow/stream/146212-t-compiler.2Fconst-eval/topic/const_eval_select.20assumptions). This UB would be very hard to test for and looks like a way-too-big footgun. ``@oli-obk`` suggested this is meant to be more like \"library UB\", so I tried to adjust the docs accordingly.\n\nI also removed all references to \"referential transparency\". That is a rather vague concept used to mean many different things, and I honestly have no idea what exactly is meant by it in this specific instance. But I assume ``@fee1-dead`` had in their mind a property that all `const fn` code upholds, so by demanding that the runtime code and the const-time code are *observably equivalent*, whatever that property is would also be enforced here.\n\nCc ``@rust-lang/wg-const-eval``\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d317da48b1341eec28ed070002a7110b39b9ae15", "html_url": "https://github.com/rust-lang/rust/commit/d317da48b1341eec28ed070002a7110b39b9ae15", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d317da48b1341eec28ed070002a7110b39b9ae15/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "60aa03aa71e6057bded100d24519e6309c2152d6", "url": "https://api.github.com/repos/rust-lang/rust/commits/60aa03aa71e6057bded100d24519e6309c2152d6", "html_url": "https://github.com/rust-lang/rust/commit/60aa03aa71e6057bded100d24519e6309c2152d6"}, {"sha": "85558ad5b39d435d3c57e3e0df5f4c160ee0c6e3", "url": "https://api.github.com/repos/rust-lang/rust/commits/85558ad5b39d435d3c57e3e0df5f4c160ee0c6e3", "html_url": "https://github.com/rust-lang/rust/commit/85558ad5b39d435d3c57e3e0df5f4c160ee0c6e3"}], "stats": {"total": 53, "additions": 37, "deletions": 16}, "files": [{"sha": "8c6a7a56966afc493c6f61e120dd9329d45dfa8e", "filename": "library/core/src/intrinsics.rs", "status": "modified", "additions": 35, "deletions": 14, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/d317da48b1341eec28ed070002a7110b39b9ae15/library%2Fcore%2Fsrc%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d317da48b1341eec28ed070002a7110b39b9ae15/library%2Fcore%2Fsrc%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fintrinsics.rs?ref=d317da48b1341eec28ed070002a7110b39b9ae15", "patch": "@@ -2070,8 +2070,8 @@ pub const unsafe fn copy_nonoverlapping<T>(src: *const T, dst: *mut T, count: us\n     #[cfg(debug_assertions)]\n     const fn compiletime_check<T>(_src: *const T, _dst: *mut T, _count: usize) {}\n     #[cfg(debug_assertions)]\n-    // SAFETY: runtime debug-assertions are a best-effort basis; it's fine to\n-    // not do them during compile time\n+    // SAFETY: As per our safety precondition, we may assume that the `abort` above is never reached.\n+    // Therefore, compiletime_check and runtime_check are observably equivalent.\n     unsafe {\n         const_eval_select((src, dst, count), compiletime_check, runtime_check);\n     }\n@@ -2161,8 +2161,8 @@ pub const unsafe fn copy<T>(src: *const T, dst: *mut T, count: usize) {\n     #[cfg(debug_assertions)]\n     const fn compiletime_check<T>(_src: *const T, _dst: *mut T) {}\n     #[cfg(debug_assertions)]\n-    // SAFETY: runtime debug-assertions are a best-effort basis; it's fine to\n-    // not do them during compile time\n+    // SAFETY: As per our safety precondition, we may assume that the `abort` above is never reached.\n+    // Therefore, compiletime_check and runtime_check are observably equivalent.\n     unsafe {\n         const_eval_select((src, dst), compiletime_check, runtime_check);\n     }\n@@ -2273,19 +2273,40 @@ pub unsafe fn write_bytes<T>(dst: *mut T, val: u8, count: usize) {\n ///\n /// # Safety\n ///\n-/// This intrinsic allows breaking [referential transparency] in `const fn`\n-/// and is therefore `unsafe`.\n+/// The two functions must behave observably equivalent. Safe code in other\n+/// crates may assume that calling a `const fn` at compile-time and at run-time\n+/// produces the same result. A function that produces a different result when\n+/// evaluated at run-time, or has any other observable side-effects, is\n+/// *unsound*.\n ///\n-/// Code that uses this intrinsic must be extremely careful to ensure that\n-/// `const fn`s remain referentially-transparent independently of when they\n-/// are evaluated.\n+/// Here is an example of how this could cause a problem:\n+/// ```no_run\n+/// #![feature(const_eval_select)]\n+/// use std::hint::unreachable_unchecked;\n+/// use std::intrinsics::const_eval_select;\n ///\n-/// The Rust compiler assumes that it is sound to replace a call to a `const\n-/// fn` with the result produced by evaluating it at compile-time. If\n-/// evaluating the function at run-time were to produce a different result,\n-/// or have any other observable side-effects, the behavior is undefined.\n+/// // Crate A\n+/// pub const fn inconsistent() -> i32 {\n+///     fn runtime() -> i32 { 1 }\n+///     const fn compiletime() -> i32 { 2 }\n ///\n-/// [referential transparency]: https://en.wikipedia.org/wiki/Referential_transparency\n+///     unsafe {\n+//          // \u26a0 This code violates the required equivalence of `compiletime`\n+///         // and `runtime`.\n+///         const_eval_select((), compiletime, runtime)\n+///     }\n+/// }\n+///\n+/// // Crate B\n+/// const X: i32 = inconsistent();\n+/// let x = inconsistent();\n+/// if x != X { unsafe { unreachable_unchecked(); }}\n+/// ```\n+///\n+/// This code causes Undefined Behavior when being run, since the\n+/// `unreachable_unchecked` is actually being reached. The bug is in *crate A*,\n+/// which violates the principle that a `const fn` must behave the same at\n+/// compile-time and at run-time. The unsafe code in crate B is fine.\n #[unstable(\n     feature = \"const_eval_select\",\n     issue = \"none\","}, {"sha": "e7972838184815eccbb039bf6504838f454c5348", "filename": "library/core/src/slice/raw.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d317da48b1341eec28ed070002a7110b39b9ae15/library%2Fcore%2Fsrc%2Fslice%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d317da48b1341eec28ed070002a7110b39b9ae15/library%2Fcore%2Fsrc%2Fslice%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fraw.rs?ref=d317da48b1341eec28ed070002a7110b39b9ae15", "patch": "@@ -149,8 +149,8 @@ const fn debug_check_data_len<T>(data: *const T, len: usize) {\n     // it is not required for safety (the safety must be guatanteed by\n     // the `from_raw_parts[_mut]` caller).\n     //\n-    // Since the checks are not required, we ignore them in CTFE as they can't\n-    // be done there (alignment does not make much sense there).\n+    // As per our safety precondition, we may assume that assertion above never fails.\n+    // Therefore, noop and rt_check are observably equivalent.\n     unsafe {\n         crate::intrinsics::const_eval_select((data,), noop, rt_check);\n     }"}]}