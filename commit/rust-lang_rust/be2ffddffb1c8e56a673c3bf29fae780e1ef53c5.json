{"sha": "be2ffddffb1c8e56a673c3bf29fae780e1ef53c5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJlMmZmZGRmZmIxYzhlNTZhNjczYzNiZjI5ZmFlNzgwZTFlZjUzYzU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-02-06T15:15:56Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-02-06T15:15:56Z"}, "message": "Auto merge of #31417 - alexcrichton:cloexec-all-the-things, r=brson\n\nThese commits finish up closing out https://github.com/rust-lang/rust/issues/24237 by filling out all locations we create new file descriptors with variants that atomically create the file descriptor and set CLOEXEC where possible. Previous support for doing this in `File::open` was added in #27971 and support for `try_clone` was added in #27980. This commit fills out:\n\n* `Socket::new` now passes `SOCK_CLOEXEC`\n* `Socket::accept` now uses `accept4`\n* `pipe2` is used instead of `pipe`\n\nUnfortunately most of this support is Linux-specific, and most of it is post-2.6.18 (our oldest supported version), so all of the detection here is done dynamically. It looks like OSX does not have equivalent variants for these functions, so there's nothing more we can do there. Support for BSDs can be added over time if they also have these functions.\n\nCloses #24237", "tree": {"sha": "d8491d6e538b249499dd44d4b0e6d224749b6eda", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d8491d6e538b249499dd44d4b0e6d224749b6eda"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/be2ffddffb1c8e56a673c3bf29fae780e1ef53c5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/be2ffddffb1c8e56a673c3bf29fae780e1ef53c5", "html_url": "https://github.com/rust-lang/rust/commit/be2ffddffb1c8e56a673c3bf29fae780e1ef53c5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/be2ffddffb1c8e56a673c3bf29fae780e1ef53c5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "695c907dcc7c81c5fc052f426f7764476c12cf15", "url": "https://api.github.com/repos/rust-lang/rust/commits/695c907dcc7c81c5fc052f426f7764476c12cf15", "html_url": "https://github.com/rust-lang/rust/commit/695c907dcc7c81c5fc052f426f7764476c12cf15"}, {"sha": "812b309c4791e08aa5bd8dda26c820af43c5fa29", "url": "https://api.github.com/repos/rust-lang/rust/commits/812b309c4791e08aa5bd8dda26c820af43c5fa29", "html_url": "https://github.com/rust-lang/rust/commit/812b309c4791e08aa5bd8dda26c820af43c5fa29"}], "stats": {"total": 247, "additions": 202, "deletions": 45}, "files": [{"sha": "a64ee24718c0289b82a77d692cf56f8a1226de51", "filename": "src/liblibc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblibc?ref=be2ffddffb1c8e56a673c3bf29fae780e1ef53c5", "patch": "@@ -1 +1 @@\n-Subproject commit 30f70baa6cc1ba3ddebb55b988fafbad0c0cc810\n+Subproject commit a64ee24718c0289b82a77d692cf56f8a1226de51"}, {"sha": "0eadee54e26638e70f793a5c5f77f92f6e01470f", "filename": "src/libstd/sys/unix/fd.rs", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/be2ffddffb1c8e56a673c3bf29fae780e1ef53c5/src%2Flibstd%2Fsys%2Funix%2Ffd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be2ffddffb1c8e56a673c3bf29fae780e1ef53c5/src%2Flibstd%2Fsys%2Funix%2Ffd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffd.rs?ref=be2ffddffb1c8e56a673c3bf29fae780e1ef53c5", "patch": "@@ -77,9 +77,7 @@ impl FileDesc {\n         // follow a strategy similar to musl [1] where if passing\n         // F_DUPFD_CLOEXEC causes `fcntl` to return EINVAL it means it's not\n         // supported (the third parameter, 0, is always valid), so we stop\n-        // trying that. We also *still* call the `set_cloexec` method as\n-        // apparently some kernel at some point stopped setting CLOEXEC even\n-        // though it reported doing so on F_DUPFD_CLOEXEC.\n+        // trying that.\n         //\n         // Also note that Android doesn't have F_DUPFD_CLOEXEC, but get it to\n         // resolve so we at least compile this.\n@@ -95,14 +93,25 @@ impl FileDesc {\n             fd.set_cloexec();\n             fd\n         };\n-        static TRY_CLOEXEC: AtomicBool = AtomicBool::new(true);\n+        static TRY_CLOEXEC: AtomicBool =\n+            AtomicBool::new(!cfg!(target_os = \"android\"));\n         let fd = self.raw();\n-        if !cfg!(target_os = \"android\") && TRY_CLOEXEC.load(Ordering::Relaxed) {\n+        if TRY_CLOEXEC.load(Ordering::Relaxed) {\n             match cvt(unsafe { libc::fcntl(fd, F_DUPFD_CLOEXEC, 0) }) {\n+                // We *still* call the `set_cloexec` method as apparently some\n+                // linux kernel at some point stopped setting CLOEXEC even\n+                // though it reported doing so on F_DUPFD_CLOEXEC.\n+                Ok(fd) => {\n+                    return Ok(if cfg!(target_os = \"linux\") {\n+                        make_filedesc(fd)\n+                    } else {\n+                        FileDesc::new(fd)\n+                    })\n+                }\n                 Err(ref e) if e.raw_os_error() == Some(libc::EINVAL) => {\n                     TRY_CLOEXEC.store(false, Ordering::Relaxed);\n                 }\n-                res => return res.map(make_filedesc),\n+                Err(e) => return Err(e),\n             }\n         }\n         cvt(unsafe { libc::fcntl(fd, libc::F_DUPFD, 0) }).map(make_filedesc)"}, {"sha": "fc387dbbd471d2e7eb908a3e5b9407673fa5b24d", "filename": "src/libstd/sys/unix/fs.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/be2ffddffb1c8e56a673c3bf29fae780e1ef53c5/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be2ffddffb1c8e56a673c3bf29fae780e1ef53c5/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffs.rs?ref=be2ffddffb1c8e56a673c3bf29fae780e1ef53c5", "patch": "@@ -413,10 +413,18 @@ impl File {\n             libc::open(path.as_ptr(), flags, opts.mode as c_int)\n         }));\n         let fd = FileDesc::new(fd);\n-        // Even though we open with the O_CLOEXEC flag, still set CLOEXEC here,\n-        // in case the open flag is not supported (it's just ignored by the OS\n-        // in that case).\n-        fd.set_cloexec();\n+\n+        // Currently the standard library supports Linux 2.6.18 which did not\n+        // have the O_CLOEXEC flag (passed above). If we're running on an older\n+        // Linux kernel then the flag is just ignored by the OS, so we continue\n+        // to explicitly ask for a CLOEXEC fd here.\n+        //\n+        // The CLOEXEC flag, however, is supported on versions of OSX/BSD/etc\n+        // that we support, so we only do this on Linux currently.\n+        if cfg!(target_os = \"linux\") {\n+            fd.set_cloexec();\n+        }\n+\n         Ok(File(fd))\n     }\n "}, {"sha": "01769a75afde3d301a41247a204e198636eb2a9b", "filename": "src/libstd/sys/unix/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/be2ffddffb1c8e56a673c3bf29fae780e1ef53c5/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be2ffddffb1c8e56a673c3bf29fae780e1ef53c5/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fmod.rs?ref=be2ffddffb1c8e56a673c3bf29fae780e1ef53c5", "patch": "@@ -27,6 +27,9 @@ use ops::Neg;\n #[cfg(target_os = \"openbsd\")]   pub use os::openbsd as platform;\n #[cfg(target_os = \"solaris\")]   pub use os::solaris as platform;\n \n+#[macro_use]\n+pub mod weak;\n+\n pub mod backtrace;\n pub mod condvar;\n pub mod ext;"}, {"sha": "507cc0f4ea46191e930fc0ced1ba266dc7843910", "filename": "src/libstd/sys/unix/net.rs", "status": "modified", "additions": 46, "deletions": 3, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/be2ffddffb1c8e56a673c3bf29fae780e1ef53c5/src%2Flibstd%2Fsys%2Funix%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be2ffddffb1c8e56a673c3bf29fae780e1ef53c5/src%2Flibstd%2Fsys%2Funix%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fnet.rs?ref=be2ffddffb1c8e56a673c3bf29fae780e1ef53c5", "patch": "@@ -12,7 +12,7 @@ use prelude::v1::*;\n \n use ffi::CStr;\n use io;\n-use libc::{self, c_int, size_t};\n+use libc::{self, c_int, size_t, sockaddr, socklen_t};\n use net::{SocketAddr, Shutdown};\n use str;\n use sys::fd::FileDesc;\n@@ -25,6 +25,16 @@ pub use libc as netc;\n \n pub type wrlen_t = size_t;\n \n+// See below for the usage of SOCK_CLOEXEC, but this constant is only defined on\n+// Linux currently (e.g. support doesn't exist on other platforms). In order to\n+// get name resolution to work and things to compile we just define a dummy\n+// SOCK_CLOEXEC here for other platforms. Note that the dummy constant isn't\n+// actually ever used (the blocks below are wrapped in `if cfg!` as well.\n+#[cfg(target_os = \"linux\")]\n+use libc::SOCK_CLOEXEC;\n+#[cfg(not(target_os = \"linux\"))]\n+const SOCK_CLOEXEC: c_int = 0;\n+\n pub struct Socket(FileDesc);\n \n pub fn init() {}\n@@ -48,15 +58,48 @@ impl Socket {\n             SocketAddr::V6(..) => libc::AF_INET6,\n         };\n         unsafe {\n+            // On linux we first attempt to pass the SOCK_CLOEXEC flag to\n+            // atomically create the socket and set it as CLOEXEC. Support for\n+            // this option, however, was added in 2.6.27, and we still support\n+            // 2.6.18 as a kernel, so if the returned error is EINVAL we\n+            // fallthrough to the fallback.\n+            if cfg!(target_os = \"linux\") {\n+                match cvt(libc::socket(fam, ty | SOCK_CLOEXEC, 0)) {\n+                    Ok(fd) => return Ok(Socket(FileDesc::new(fd))),\n+                    Err(ref e) if e.raw_os_error() == Some(libc::EINVAL) => {}\n+                    Err(e) => return Err(e),\n+                }\n+            }\n+\n             let fd = try!(cvt(libc::socket(fam, ty, 0)));\n             let fd = FileDesc::new(fd);\n             fd.set_cloexec();\n             Ok(Socket(fd))\n         }\n     }\n \n-    pub fn accept(&self, storage: *mut libc::sockaddr,\n-                  len: *mut libc::socklen_t) -> io::Result<Socket> {\n+    pub fn accept(&self, storage: *mut sockaddr, len: *mut socklen_t)\n+                  -> io::Result<Socket> {\n+        // Unfortunately the only known way right now to accept a socket and\n+        // atomically set the CLOEXEC flag is to use the `accept4` syscall on\n+        // Linux. This was added in 2.6.28, however, and because we support\n+        // 2.6.18 we must detect this support dynamically.\n+        if cfg!(target_os = \"linux\") {\n+            weak! {\n+                fn accept4(c_int, *mut sockaddr, *mut socklen_t, c_int) -> c_int\n+            }\n+            if let Some(accept) = accept4.get() {\n+                let res = cvt_r(|| unsafe {\n+                    accept(self.0.raw(), storage, len, SOCK_CLOEXEC)\n+                });\n+                match res {\n+                    Ok(fd) => return Ok(Socket(FileDesc::new(fd))),\n+                    Err(ref e) if e.raw_os_error() == Some(libc::ENOSYS) => {}\n+                    Err(e) => return Err(e),\n+                }\n+            }\n+        }\n+\n         let fd = try!(cvt_r(|| unsafe {\n             libc::accept(self.0.raw(), storage, len)\n         }));"}, {"sha": "9527b1e2243d3e10a02b10e2659829a03badb8b4", "filename": "src/libstd/sys/unix/pipe.rs", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/be2ffddffb1c8e56a673c3bf29fae780e1ef53c5/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be2ffddffb1c8e56a673c3bf29fae780e1ef53c5/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs?ref=be2ffddffb1c8e56a673c3bf29fae780e1ef53c5", "patch": "@@ -8,9 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use sys::fd::FileDesc;\n use io;\n-use libc;\n+use libc::{self, c_int};\n+use sys::cvt_r;\n+use sys::fd::FileDesc;\n \n ////////////////////////////////////////////////////////////////////////////////\n // Anonymous pipes\n@@ -20,6 +21,24 @@ pub struct AnonPipe(FileDesc);\n \n pub fn anon_pipe() -> io::Result<(AnonPipe, AnonPipe)> {\n     let mut fds = [0; 2];\n+\n+    // Unfortunately the only known way right now to create atomically set the\n+    // CLOEXEC flag is to use the `pipe2` syscall on Linux. This was added in\n+    // 2.6.27, however, and because we support 2.6.18 we must detect this\n+    // support dynamically.\n+    if cfg!(target_os = \"linux\") {\n+        weak! { fn pipe2(*mut c_int, c_int) -> c_int }\n+        if let Some(pipe) = pipe2.get() {\n+            match cvt_r(|| unsafe { pipe(fds.as_mut_ptr(), libc::O_CLOEXEC) }) {\n+                Ok(_) => {\n+                    return Ok((AnonPipe(FileDesc::new(fds[0])),\n+                               AnonPipe(FileDesc::new(fds[1]))))\n+                }\n+                Err(ref e) if e.raw_os_error() == Some(libc::ENOSYS) => {}\n+                Err(e) => return Err(e),\n+            }\n+        }\n+    }\n     if unsafe { libc::pipe(fds.as_mut_ptr()) == 0 } {\n         Ok((AnonPipe::from_fd(fds[0]), AnonPipe::from_fd(fds[1])))\n     } else {"}, {"sha": "a7195bab74192cff39f0759d301c2c95a5d68876", "filename": "src/libstd/sys/unix/thread.rs", "status": "modified", "additions": 2, "deletions": 27, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/be2ffddffb1c8e56a673c3bf29fae780e1ef53c5/src%2Flibstd%2Fsys%2Funix%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be2ffddffb1c8e56a673c3bf29fae780e1ef53c5/src%2Flibstd%2Fsys%2Funix%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fthread.rs?ref=be2ffddffb1c8e56a673c3bf29fae780e1ef53c5", "patch": "@@ -317,37 +317,12 @@ pub mod guard {\n // storage.  We need that information to avoid blowing up when a small stack\n // is created in an application with big thread-local storage requirements.\n // See #6233 for rationale and details.\n-//\n-// Use dlsym to get the symbol value at runtime, both for\n-// compatibility with older versions of glibc, and to avoid creating\n-// dependencies on GLIBC_PRIVATE symbols.  Assumes that we've been\n-// dynamically linked to libpthread but that is currently always the\n-// case.  We previously used weak linkage (under the same assumption),\n-// but that caused Debian to detect an unnecessarily strict versioned\n-// dependency on libc6 (#23628).\n #[cfg(target_os = \"linux\")]\n #[allow(deprecated)]\n fn min_stack_size(attr: *const libc::pthread_attr_t) -> usize {\n-    use dynamic_lib::DynamicLibrary;\n-    use sync::Once;\n-\n-    type F = unsafe extern \"C\" fn(*const libc::pthread_attr_t) -> libc::size_t;\n-    static INIT: Once = Once::new();\n-    static mut __pthread_get_minstack: Option<F> = None;\n-\n-    INIT.call_once(|| {\n-        let lib = match DynamicLibrary::open(None) {\n-            Ok(l) => l,\n-            Err(..) => return,\n-        };\n-        unsafe {\n-            if let Ok(f) = lib.symbol(\"__pthread_get_minstack\") {\n-                __pthread_get_minstack = Some(mem::transmute::<*const (), F>(f));\n-            }\n-        }\n-    });\n+    weak!(fn __pthread_get_minstack(*const libc::pthread_attr_t) -> libc::size_t);\n \n-    match unsafe { __pthread_get_minstack } {\n+    match __pthread_get_minstack.get() {\n         None => libc::PTHREAD_STACK_MIN as usize,\n         Some(f) => unsafe { f(attr) as usize },\n     }"}, {"sha": "e6f85c08d1246cf06ee0f88ad9935b49cbf83262", "filename": "src/libstd/sys/unix/weak.rs", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/be2ffddffb1c8e56a673c3bf29fae780e1ef53c5/src%2Flibstd%2Fsys%2Funix%2Fweak.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be2ffddffb1c8e56a673c3bf29fae780e1ef53c5/src%2Flibstd%2Fsys%2Funix%2Fweak.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fweak.rs?ref=be2ffddffb1c8e56a673c3bf29fae780e1ef53c5", "patch": "@@ -0,0 +1,85 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Support for \"weak linkage\" to symbols on Unix\n+//!\n+//! Some I/O operations we do in libstd require newer versions of OSes but we\n+//! need to maintain binary compatibility with older releases for now. In order\n+//! to use the new functionality when available we use this module for\n+//! detection.\n+//!\n+//! One option to use here is weak linkage, but that is unfortunately only\n+//! really workable on Linux. Hence, use dlsym to get the symbol value at\n+//! runtime. This is also done for compatibility with older versions of glibc,\n+//! and to avoid creating dependencies on GLIBC_PRIVATE symbols. It assumes that\n+//! we've been dynamically linked to the library the symbol comes from, but that\n+//! is currently always the case for things like libpthread/libc.\n+//!\n+//! A long time ago this used weak linkage for the __pthread_get_minstack\n+//! symbol, but that caused Debian to detect an unnecessarily strict versioned\n+//! dependency on libc6 (#23628).\n+\n+use libc;\n+\n+use ffi::CString;\n+use marker;\n+use mem;\n+use sync::atomic::{AtomicUsize, Ordering};\n+\n+macro_rules! weak {\n+    (fn $name:ident($($t:ty),*) -> $ret:ty) => (\n+        static $name: ::sys::weak::Weak<unsafe extern fn($($t),*) -> $ret> =\n+            ::sys::weak::Weak::new(stringify!($name));\n+    )\n+}\n+\n+pub struct Weak<F> {\n+    name: &'static str,\n+    addr: AtomicUsize,\n+    _marker: marker::PhantomData<F>,\n+}\n+\n+impl<F> Weak<F> {\n+    pub const fn new(name: &'static str) -> Weak<F> {\n+        Weak {\n+            name: name,\n+            addr: AtomicUsize::new(1),\n+            _marker: marker::PhantomData,\n+        }\n+    }\n+\n+    pub fn get(&self) -> Option<&F> {\n+        assert_eq!(mem::size_of::<F>(), mem::size_of::<usize>());\n+        unsafe {\n+            if self.addr.load(Ordering::SeqCst) == 1 {\n+                self.addr.store(fetch(self.name), Ordering::SeqCst);\n+            }\n+            if self.addr.load(Ordering::SeqCst) == 0 {\n+                None\n+            } else {\n+                mem::transmute::<&AtomicUsize, Option<&F>>(&self.addr)\n+            }\n+        }\n+    }\n+}\n+\n+unsafe fn fetch(name: &str) -> usize {\n+    let name = match CString::new(name) {\n+        Ok(cstr) => cstr,\n+        Err(..) => return 0,\n+    };\n+    let lib = libc::dlopen(0 as *const _, libc::RTLD_LAZY);\n+    if lib.is_null() {\n+        return 0\n+    }\n+    let ret = libc::dlsym(lib, name.as_ptr()) as usize;\n+    libc::dlclose(lib);\n+    return ret\n+}"}, {"sha": "3c7d2861c877e317d4e2918e9381311b4f7e9e8e", "filename": "src/test/run-pass/fds-are-cloexec.rs", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/be2ffddffb1c8e56a673c3bf29fae780e1ef53c5/src%2Ftest%2Frun-pass%2Ffds-are-cloexec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be2ffddffb1c8e56a673c3bf29fae780e1ef53c5/src%2Ftest%2Frun-pass%2Ffds-are-cloexec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffds-are-cloexec.rs?ref=be2ffddffb1c8e56a673c3bf29fae780e1ef53c5", "patch": "@@ -16,11 +16,11 @@\n extern crate libc;\n \n use std::env;\n-use std::fs::{self, File};\n+use std::fs::File;\n use std::io;\n use std::net::{TcpListener, TcpStream, UdpSocket};\n use std::os::unix::prelude::*;\n-use std::process::Command;\n+use std::process::{Command, Stdio};\n use std::thread;\n \n fn main() {\n@@ -45,6 +45,17 @@ fn parent() {\n     let udp1 = UdpSocket::bind(\"127.0.0.1:0\").unwrap();\n     let udp2 = udp1.try_clone().unwrap();\n \n+    let mut child = Command::new(env::args().next().unwrap())\n+                            .arg(\"100\")\n+                            .stdout(Stdio::piped())\n+                            .stdin(Stdio::piped())\n+                            .stderr(Stdio::piped())\n+                            .spawn().unwrap();\n+    let pipe1 = child.stdin.take().unwrap();\n+    let pipe2 = child.stdout.take().unwrap();\n+    let pipe3 = child.stderr.take().unwrap();\n+\n+\n     let status = Command::new(env::args().next().unwrap())\n                         .arg(file.as_raw_fd().to_string())\n                         .arg(tcp1.as_raw_fd().to_string())\n@@ -55,9 +66,13 @@ fn parent() {\n                         .arg(tcp6.as_raw_fd().to_string())\n                         .arg(udp1.as_raw_fd().to_string())\n                         .arg(udp2.as_raw_fd().to_string())\n+                        .arg(pipe1.as_raw_fd().to_string())\n+                        .arg(pipe2.as_raw_fd().to_string())\n+                        .arg(pipe3.as_raw_fd().to_string())\n                         .status()\n                         .unwrap();\n     assert!(status.success());\n+    child.wait().unwrap();\n }\n \n fn child(args: &[String]) {"}]}