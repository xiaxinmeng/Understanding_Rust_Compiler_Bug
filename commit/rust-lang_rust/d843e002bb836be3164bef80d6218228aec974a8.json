{"sha": "d843e002bb836be3164bef80d6218228aec974a8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ4NDNlMDAyYmI4MzZiZTMxNjRiZWY4MGQ2MjE4MjI4YWVjOTc0YTg=", "commit": {"author": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2020-01-05T00:29:45Z"}, "committer": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2020-01-10T00:47:05Z"}, "message": "Check for `?const` in invalid contexts during AST validation", "tree": {"sha": "cd9a38a32866096da3ab8a6bb86cef1127d5ae7b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cd9a38a32866096da3ab8a6bb86cef1127d5ae7b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d843e002bb836be3164bef80d6218228aec974a8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d843e002bb836be3164bef80d6218228aec974a8", "html_url": "https://github.com/rust-lang/rust/commit/d843e002bb836be3164bef80d6218228aec974a8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d843e002bb836be3164bef80d6218228aec974a8/comments", "author": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "31edbe9acacceb24f0e31a73e0c45f852977c663", "url": "https://api.github.com/repos/rust-lang/rust/commits/31edbe9acacceb24f0e31a73e0c45f852977c663", "html_url": "https://github.com/rust-lang/rust/commit/31edbe9acacceb24f0e31a73e0c45f852977c663"}], "stats": {"total": 74, "additions": 74, "deletions": 0}, "files": [{"sha": "1e5e39217b7aad346cf0f79fa29e3792bb35af1f", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/d843e002bb836be3164bef80d6218228aec974a8/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d843e002bb836be3164bef80d6218228aec974a8/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=d843e002bb836be3164bef80d6218228aec974a8", "patch": "@@ -24,6 +24,23 @@ use syntax::walk_list;\n \n use rustc_error_codes::*;\n \n+#[derive(Clone, Copy)]\n+enum BoundContext {\n+    ImplTrait,\n+    TraitBounds,\n+    TraitObject,\n+}\n+\n+impl BoundContext {\n+    fn description(&self) -> &'static str {\n+        match self {\n+            Self::ImplTrait => \"`impl Trait`\",\n+            Self::TraitBounds => \"supertraits\",\n+            Self::TraitObject => \"trait objects\",\n+        }\n+    }\n+}\n+\n struct AstValidator<'a> {\n     session: &'a Session,\n     has_proc_macro_decls: bool,\n@@ -33,6 +50,11 @@ struct AstValidator<'a> {\n     /// e.g., `impl Iterator<Item = impl Debug>`.\n     outer_impl_trait: Option<Span>,\n \n+    /// Tracks the context in which a bound can appear.\n+    ///\n+    /// This is used to forbid `?const Trait` bounds in certain contexts.\n+    bound_context_stack: Vec<Option<BoundContext>>,\n+\n     /// Used to ban `impl Trait` in path projections like `<impl Iterator>::Item`\n     /// or `Foo::Bar<impl Trait>`\n     is_impl_trait_banned: bool,\n@@ -58,9 +80,21 @@ impl<'a> AstValidator<'a> {\n     }\n \n     fn with_impl_trait(&mut self, outer: Option<Span>, f: impl FnOnce(&mut Self)) {\n+        self.bound_context_stack.push(outer.map(|_| BoundContext::ImplTrait));\n         let old = mem::replace(&mut self.outer_impl_trait, outer);\n         f(self);\n         self.outer_impl_trait = old;\n+        self.bound_context_stack.pop();\n+    }\n+\n+    fn with_bound_context(&mut self, ctx: Option<BoundContext>, f: impl FnOnce(&mut Self)) {\n+        self.bound_context_stack.push(ctx);\n+        f(self);\n+        self.bound_context_stack.pop();\n+    }\n+\n+    fn innermost_bound_context(&mut self) -> Option<BoundContext> {\n+        self.bound_context_stack.iter().rev().find(|x| x.is_some()).copied().flatten()\n     }\n \n     fn visit_assoc_ty_constraint_from_generic_args(&mut self, constraint: &'a AssocTyConstraint) {\n@@ -84,6 +118,11 @@ impl<'a> AstValidator<'a> {\n             TyKind::ImplTrait(..) => {\n                 self.with_impl_trait(Some(t.span), |this| visit::walk_ty(this, t))\n             }\n+            TyKind::TraitObject(..) => {\n+                self.with_bound_context(Some(BoundContext::TraitObject), |this| {\n+                    visit::walk_ty(this, t)\n+                });\n+            }\n             TyKind::Path(ref qself, ref path) => {\n                 // We allow these:\n                 //  - `Option<impl Trait>`\n@@ -192,6 +231,8 @@ impl<'a> AstValidator<'a> {\n         }\n     }\n \n+    // FIXME(ecstaticmorse): Instead, use the `bound_context_stack` to check this in\n+    // `visit_param_bound`.\n     fn no_questions_in_bounds(&self, bounds: &GenericBounds, where_: &str, is_trait: bool) {\n         for bound in bounds {\n             if let GenericBound::Trait(ref poly, TraitBoundModifier::Maybe) = *bound {\n@@ -697,6 +738,15 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                     }\n                 }\n                 self.no_questions_in_bounds(bounds, \"supertraits\", true);\n+\n+                // Equivalent of `visit::walk_item` for `ItemKind::Trait` that inserts a bound\n+                // context for the supertraits.\n+                self.visit_generics(generics);\n+                self.with_bound_context(Some(BoundContext::TraitBounds), |this| {\n+                    walk_list!(this, visit_param_bound, bounds);\n+                });\n+                walk_list!(self, visit_trait_item, trait_items);\n+                return;\n             }\n             ItemKind::Mod(_) => {\n                 // Ensure that `path` attributes on modules are recorded as used (cf. issue #35584).\n@@ -841,6 +891,29 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n         visit::walk_generic_param(self, param);\n     }\n \n+    fn visit_param_bound(&mut self, bound: &'a GenericBound) {\n+        if let GenericBound::Trait(poly, maybe_bound) = bound {\n+            match poly.trait_ref.constness {\n+                Some(Constness::NotConst) => {\n+                    if *maybe_bound == TraitBoundModifier::Maybe {\n+                        self.err_handler()\n+                            .span_err(bound.span(), \"`?const` and `?` are mutually exclusive\");\n+                    }\n+\n+                    if let Some(ctx) = self.innermost_bound_context() {\n+                        let msg = format!(\"`?const` is not permitted in {}\", ctx.description());\n+                        self.err_handler().span_err(bound.span(), &msg);\n+                    }\n+                }\n+\n+                Some(Constness::Const) => bug!(\"Parser should reject bare `const` on bounds\"),\n+                None => {}\n+            }\n+        }\n+\n+        visit::walk_param_bound(self, bound)\n+    }\n+\n     fn visit_pat(&mut self, pat: &'a Pat) {\n         match pat.kind {\n             PatKind::Lit(ref expr) => {\n@@ -949,6 +1022,7 @@ pub fn check_crate(session: &Session, krate: &Crate, lints: &mut lint::LintBuffe\n         session,\n         has_proc_macro_decls: false,\n         outer_impl_trait: None,\n+        bound_context_stack: Vec::new(),\n         is_impl_trait_banned: false,\n         is_assoc_ty_bound_banned: false,\n         lint_buffer: lints,"}]}