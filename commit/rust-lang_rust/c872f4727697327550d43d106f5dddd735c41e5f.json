{"sha": "c872f4727697327550d43d106f5dddd735c41e5f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM4NzJmNDcyNzY5NzMyNzU1MGQ0M2QxMDZmNWRkZGQ3MzVjNDFlNWY=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2017-08-25T14:15:12Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2017-08-25T14:15:12Z"}, "message": "Merge remote-tracking branch 'origin/master' into gen", "tree": {"sha": "e9b63fc7d07b2608cac0c00c1e06ef2e33017b0a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e9b63fc7d07b2608cac0c00c1e06ef2e33017b0a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c872f4727697327550d43d106f5dddd735c41e5f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c872f4727697327550d43d106f5dddd735c41e5f", "html_url": "https://github.com/rust-lang/rust/commit/c872f4727697327550d43d106f5dddd735c41e5f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c872f4727697327550d43d106f5dddd735c41e5f/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b44e51cd62a982c8ab97b1b794ada57bdda44e85", "url": "https://api.github.com/repos/rust-lang/rust/commits/b44e51cd62a982c8ab97b1b794ada57bdda44e85", "html_url": "https://github.com/rust-lang/rust/commit/b44e51cd62a982c8ab97b1b794ada57bdda44e85"}, {"sha": "ba65645c78a87f1fa5c6d7132130bb3175fbe68b", "url": "https://api.github.com/repos/rust-lang/rust/commits/ba65645c78a87f1fa5c6d7132130bb3175fbe68b", "html_url": "https://github.com/rust-lang/rust/commit/ba65645c78a87f1fa5c6d7132130bb3175fbe68b"}], "stats": {"total": 4455, "additions": 3016, "deletions": 1439}, "files": [{"sha": "78a9f509bbcb4c79b37608963b241f748b8aa64b", "filename": "README.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c872f4727697327550d43d106f5dddd735c41e5f/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/c872f4727697327550d43d106f5dddd735c41e5f/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=c872f4727697327550d43d106f5dddd735c41e5f", "patch": "@@ -135,7 +135,7 @@ Windows build triples are:\n     - `i686-pc-windows-msvc`\n     - `x86_64-pc-windows-msvc`\n \n-The build triple can be specified by either specifying `--build=ABI` when\n+The build triple can be specified by either specifying `--build=<triple>` when\n invoking `x.py` commands, or by copying the `config.toml` file (as described\n in Building From Source), and modifying the `build` option under the `[build]`\n section."}, {"sha": "c3a7367a2ee54d1795f46c78e32afcf06f87a8e5", "filename": "RELEASES.md", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c872f4727697327550d43d106f5dddd735c41e5f/RELEASES.md", "raw_url": "https://github.com/rust-lang/rust/raw/c872f4727697327550d43d106f5dddd735c41e5f/RELEASES.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.md?ref=c872f4727697327550d43d106f5dddd735c41e5f", "patch": "@@ -92,7 +92,7 @@ Stabilized APIs\n Cargo\n -----\n - [Cargo API token location moved from `~/.cargo/config` to\n-  `~/cargo/credentials`.][cargo/3978]\n+  `~/.cargo/credentials`.][cargo/3978]\n - [Cargo will now build `main.rs` binaries that are in sub-directories of\n   `src/bin`.][cargo/4214] ie. Having `src/bin/server/main.rs` and\n   `src/bin/client/main.rs` generates `target/debug/server` and `target/debug/client`\n@@ -172,7 +172,6 @@ Compatibility Notes\n [`slice::sort_unstable`]: https://doc.rust-lang.org/std/primitive.slice.html#method.sort_unstable\n [`ste::from_boxed_utf8_unchecked`]: https://doc.rust-lang.org/std/str/fn.from_boxed_utf8_unchecked.html\n [`str::as_bytes_mut`]: https://doc.rust-lang.org/std/primitive.str.html#method.as_bytes_mut\n-[`str::as_bytes_mut`]: https://doc.rust-lang.org/std/primitive.str.html#method.as_bytes_mut\n [`str::from_utf8_mut`]: https://doc.rust-lang.org/std/str/fn.from_utf8_mut.html\n [`str::from_utf8_unchecked_mut`]: https://doc.rust-lang.org/std/str/fn.from_utf8_unchecked_mut.html\n [`str::get_mut`]: https://doc.rust-lang.org/std/primitive.str.html#method.get_mut\n@@ -898,6 +897,9 @@ Compatibility Notes\n * [Ctrl-Z returns from `Stdin.read()` when reading from the console on\n   Windows][38274]\n * [Clean up semantics of `self` in an import list][38313]\n+* Reimplemented lifetime elision. This change was almost entirely compatible\n+  with existing code, but it did close a number of small bugs and loopholes,\n+  as well as being more accepting in some other [cases][41105].\n \n [37057]: https://github.com/rust-lang/rust/pull/37057\n [37761]: https://github.com/rust-lang/rust/pull/37761\n@@ -932,6 +934,7 @@ Compatibility Notes\n [39048]: https://github.com/rust-lang/rust/pull/39048\n [39282]: https://github.com/rust-lang/rust/pull/39282\n [39379]: https://github.com/rust-lang/rust/pull/39379\n+[41105]: https://github.com/rust-lang/rust/issues/41105\n [`<*const T>::wrapping_offset`]: https://doc.rust-lang.org/std/primitive.pointer.html#method.wrapping_offset\n [`<*mut T>::wrapping_offset`]: https://doc.rust-lang.org/std/primitive.pointer.html#method.wrapping_offset\n [`Duration::checked_add`]: https://doc.rust-lang.org/std/time/struct.Duration.html#method.checked_add"}, {"sha": "fd1f03b9d0e24bb17d73e2bec658316c5c786e1f", "filename": "config.toml.example", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c872f4727697327550d43d106f5dddd735c41e5f/config.toml.example", "raw_url": "https://github.com/rust-lang/rust/raw/c872f4727697327550d43d106f5dddd735c41e5f/config.toml.example", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/config.toml.example?ref=c872f4727697327550d43d106f5dddd735c41e5f", "patch": "@@ -292,6 +292,12 @@\n # build native code.\n #android-ndk = \"/path/to/ndk\"\n \n+# Force static or dynamic linkage of the standard library for this target. If\n+# this target is a host for rustc, this will also affect the linkage of the\n+# compiler itself. This is useful for building rustc on targets that normally\n+# only use static libraries. If unset, the target's default linkage is used.\n+#crt-static = false\n+\n # The root location of the MUSL installation directory. The library directory\n # will also need to contain libunwind.a for an unwinding implementation. Note\n # that this option only makes sense for MUSL targets that produce statically"}, {"sha": "2e844ceb17831d59edd6f7481e8de525a7e54748", "filename": "src/bootstrap/README.md", "status": "modified", "additions": 20, "deletions": 16, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/c872f4727697327550d43d106f5dddd735c41e5f/src%2Fbootstrap%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/c872f4727697327550d43d106f5dddd735c41e5f/src%2Fbootstrap%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2FREADME.md?ref=c872f4727697327550d43d106f5dddd735c41e5f", "patch": "@@ -73,16 +73,19 @@ The script accepts commands, flags, and arguments to determine what to do:\n \n ## Configuring rustbuild\n \n-There are currently two primary methods for configuring the rustbuild build\n-system. First, the `./configure` options serialized in `config.mk` will be\n-parsed and read. That is, if any `./configure` options are passed, they'll be\n-handled naturally.\n+There are currently two methods for configuring the rustbuild build system.\n \n-Next, rustbuild offers a TOML-based configuration system with a `config.toml`\n+First, rustbuild offers a TOML-based configuration system with a `config.toml`\n file in the same location as `config.mk`. An example of this configuration can\n-be found at `config.toml.example`, and the configuration file\n-can also be passed as `--config path/to/config.toml` if the build system is\n-being invoked manually (via the python script).\n+be found at `config.toml.example`, and the configuration file can also be passed\n+as `--config path/to/config.toml` if the build system is being invoked manually\n+(via the python script).\n+\n+Next, the `./configure` options serialized in `config.mk` will be\n+parsed and read. That is, if any `./configure` options are passed, they'll be\n+handled naturally. `./configure` should almost never be used for local\n+installations, and is primarily useful for CI. Prefer to customize behavior\n+using `config.toml`.\n \n Finally, rustbuild makes use of the [gcc-rs crate] which has [its own\n method][env-vars] of configuring C compilers and C flags via environment\n@@ -310,17 +313,18 @@ After that, each module in rustbuild should have enough documentation to keep\n you up and running. Some general areas that you may be interested in modifying\n are:\n \n-* Adding a new build tool? Take a look at `bootstrap/step.rs` for examples of\n+* Adding a new build tool? Take a look at `bootstrap/tool.rs` for examples of\n   other tools.\n * Adding a new compiler crate? Look no further! Adding crates can be done by\n   adding a new directory with `Cargo.toml` followed by configuring all\n   `Cargo.toml` files accordingly.\n-* Adding a new dependency from crates.io? We're still working on that, so hold\n-  off on that for now.\n-* Adding a new configuration option? Take a look at `bootstrap/config.rs` or\n-  perhaps `bootstrap/flags.rs` and then modify the build elsewhere to read that\n-  option.\n+* Adding a new dependency from crates.io? This should just work inside the\n+  compiler artifacts stage (everything other than libtest and libstd).\n+* Adding a new configuration option? You'll want to modify `bootstrap/flags.rs`\n+  for command line flags and then `bootstrap/config.rs` to copy the flags to the\n+  `Config` struct.\n * Adding a sanity check? Take a look at `bootstrap/sanity.rs`.\n \n-If you have any questions feel free to reach out on `#rust-internals` on IRC or\n-open an issue in the bug tracker!\n+If you have any questions feel free to reach out on `#rust-infra` on IRC or ask on\n+internals.rust-lang.org. When you encounter bugs, please file issues on the\n+rust-lang/rust issue tracker."}, {"sha": "0baca9e58f4fe2e753b0f7907647a1cdf91ab968", "filename": "src/bootstrap/bin/rustc.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c872f4727697327550d43d106f5dddd735c41e5f/src%2Fbootstrap%2Fbin%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c872f4727697327550d43d106f5dddd735c41e5f/src%2Fbootstrap%2Fbin%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Frustc.rs?ref=c872f4727697327550d43d106f5dddd735c41e5f", "patch": "@@ -237,9 +237,13 @@ fn main() {\n             }\n         }\n \n-        if target.contains(\"pc-windows-msvc\") {\n-            cmd.arg(\"-Z\").arg(\"unstable-options\");\n-            cmd.arg(\"-C\").arg(\"target-feature=+crt-static\");\n+        if let Ok(s) = env::var(\"RUSTC_CRT_STATIC\") {\n+            if s == \"true\" {\n+                cmd.arg(\"-C\").arg(\"target-feature=+crt-static\");\n+            }\n+            if s == \"false\" {\n+                cmd.arg(\"-C\").arg(\"target-feature=-crt-static\");\n+            }\n         }\n \n         // Force all crates compiled by this compiler to (a) be unstable and (b)"}, {"sha": "298f6a004a20aefd1c6da6c892bf62b6c9450bd1", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c872f4727697327550d43d106f5dddd735c41e5f/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c872f4727697327550d43d106f5dddd735c41e5f/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=c872f4727697327550d43d106f5dddd735c41e5f", "patch": "@@ -503,6 +503,10 @@ impl<'a> Builder<'a> {\n             cargo.env(\"RUSTC_METADATA_SUFFIX\", \"rustc\");\n         }\n \n+        if let Some(x) = self.crt_static(target) {\n+            cargo.env(\"RUSTC_CRT_STATIC\", x.to_string());\n+        }\n+\n         // Enable usage of unstable features\n         cargo.env(\"RUSTC_BOOTSTRAP\", \"1\");\n         self.add_rust_test_threads(&mut cargo);"}, {"sha": "335e1690a2ea0252a97860079309257a5aa0e0d4", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 27, "deletions": 13, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/c872f4727697327550d43d106f5dddd735c41e5f/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c872f4727697327550d43d106f5dddd735c41e5f/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=c872f4727697327550d43d106f5dddd735c41e5f", "patch": "@@ -77,6 +77,14 @@ impl Step for Std {\n                 target,\n             });\n             println!(\"Uplifting stage1 std ({} -> {})\", from.host, target);\n+\n+            // Even if we're not building std this stage, the new sysroot must\n+            // still contain the musl startup objects.\n+            if target.contains(\"musl\") && !target.contains(\"mips\") {\n+                let libdir = builder.sysroot_libdir(compiler, target);\n+                copy_musl_third_party_objects(build, target, &libdir);\n+            }\n+\n             builder.ensure(StdLink {\n                 compiler: from,\n                 target_compiler: compiler,\n@@ -89,6 +97,11 @@ impl Step for Std {\n         println!(\"Building stage{} std artifacts ({} -> {})\", compiler.stage,\n                 &compiler.host, target);\n \n+        if target.contains(\"musl\") && !target.contains(\"mips\") {\n+            let libdir = builder.sysroot_libdir(compiler, target);\n+            copy_musl_third_party_objects(build, target, &libdir);\n+        }\n+\n         let out_dir = build.cargo_out(compiler, Mode::Libstd, target);\n         build.clear_if_dirty(&out_dir, &builder.rustc(compiler));\n         let mut cargo = builder.cargo(compiler, Mode::Libstd, target, \"build\");\n@@ -105,6 +118,20 @@ impl Step for Std {\n     }\n }\n \n+/// Copies the crt(1,i,n).o startup objects\n+///\n+/// Since musl supports fully static linking, we can cross link for it even\n+/// with a glibc-targeting toolchain, given we have the appropriate startup\n+/// files. As those shipped with glibc won't work, copy the ones provided by\n+/// musl so we have them on linux-gnu hosts.\n+fn copy_musl_third_party_objects(build: &Build,\n+                                 target: Interned<String>,\n+                                 into: &Path) {\n+    for &obj in &[\"crt1.o\", \"crti.o\", \"crtn.o\"] {\n+        copy(&build.musl_root(target).unwrap().join(\"lib\").join(obj), &into.join(obj));\n+    }\n+}\n+\n /// Configure cargo to compile the standard library, adding appropriate env vars\n /// and such.\n pub fn std_cargo(build: &Build,\n@@ -189,10 +216,6 @@ impl Step for StdLink {\n         let libdir = builder.sysroot_libdir(target_compiler, target);\n         add_to_sysroot(&libdir, &libstd_stamp(build, compiler, target));\n \n-        if target.contains(\"musl\") && !target.contains(\"mips\") {\n-            copy_musl_third_party_objects(build, target, &libdir);\n-        }\n-\n         if build.config.sanitizers && compiler.stage != 0 && target == \"x86_64-apple-darwin\" {\n             // The sanitizers are only built in stage1 or above, so the dylibs will\n             // be missing in stage0 and causes panic. See the `std()` function above\n@@ -208,15 +231,6 @@ impl Step for StdLink {\n     }\n }\n \n-/// Copies the crt(1,i,n).o startup objects\n-///\n-/// Only required for musl targets that statically link to libc\n-fn copy_musl_third_party_objects(build: &Build, target: Interned<String>, into: &Path) {\n-    for &obj in &[\"crt1.o\", \"crti.o\", \"crtn.o\"] {\n-        copy(&build.musl_root(target).unwrap().join(\"lib\").join(obj), &into.join(obj));\n-    }\n-}\n-\n fn copy_apple_sanitizer_dylibs(native_dir: &Path, platform: &str, into: &Path) {\n     for &sanitizer in &[\"asan\", \"tsan\"] {\n         let filename = format!(\"libclang_rt.{}_{}_dynamic.dylib\", sanitizer, platform);"}, {"sha": "f43035fbfe8a1a75b342fee167b2ef449e42441f", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c872f4727697327550d43d106f5dddd735c41e5f/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c872f4727697327550d43d106f5dddd735c41e5f/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=c872f4727697327550d43d106f5dddd735c41e5f", "patch": "@@ -143,6 +143,7 @@ pub struct Target {\n     pub cc: Option<PathBuf>,\n     pub cxx: Option<PathBuf>,\n     pub ndk: Option<PathBuf>,\n+    pub crt_static: Option<bool>,\n     pub musl_root: Option<PathBuf>,\n     pub qemu_rootfs: Option<PathBuf>,\n }\n@@ -275,6 +276,7 @@ struct TomlTarget {\n     cc: Option<String>,\n     cxx: Option<String>,\n     android_ndk: Option<String>,\n+    crt_static: Option<bool>,\n     musl_root: Option<String>,\n     qemu_rootfs: Option<String>,\n }\n@@ -446,6 +448,7 @@ impl Config {\n                 }\n                 target.cxx = cfg.cxx.clone().map(PathBuf::from);\n                 target.cc = cfg.cc.clone().map(PathBuf::from);\n+                target.crt_static = cfg.crt_static.clone();\n                 target.musl_root = cfg.musl_root.clone().map(PathBuf::from);\n                 target.qemu_rootfs = cfg.qemu_rootfs.clone().map(PathBuf::from);\n "}, {"sha": "55358f2ffcb7334deda2c7e4ecde1180cdd9c7d6", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c872f4727697327550d43d106f5dddd735c41e5f/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c872f4727697327550d43d106f5dddd735c41e5f/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=c872f4727697327550d43d106f5dddd735c41e5f", "patch": "@@ -656,6 +656,16 @@ impl Build {\n         base\n     }\n \n+    /// Returns if this target should statically link the C runtime, if specified\n+    fn crt_static(&self, target: Interned<String>) -> Option<bool> {\n+        if target.contains(\"pc-windows-msvc\") {\n+            Some(true)\n+        } else {\n+            self.config.target_config.get(&target)\n+                .and_then(|t| t.crt_static)\n+        }\n+    }\n+\n     /// Returns the \"musl root\" for this `target`, if defined\n     fn musl_root(&self, target: Interned<String>) -> Option<&Path> {\n         self.config.target_config.get(&target)"}, {"sha": "a64a6130929cbb7c16792c9a844e999d751a4e56", "filename": "src/bootstrap/sanity.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c872f4727697327550d43d106f5dddd735c41e5f/src%2Fbootstrap%2Fsanity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c872f4727697327550d43d106f5dddd735c41e5f/src%2Fbootstrap%2Fsanity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fsanity.rs?ref=c872f4727697327550d43d106f5dddd735c41e5f", "patch": "@@ -151,8 +151,15 @@ pub fn check(build: &mut Build) {\n             panic!(\"the iOS target is only supported on macOS\");\n         }\n \n-        // Make sure musl-root is valid if specified\n+        // Make sure musl-root is valid\n         if target.contains(\"musl\") && !target.contains(\"mips\") {\n+            // If this is a native target (host is also musl) and no musl-root is given,\n+            // fall back to the system toolchain in /usr before giving up\n+            if build.musl_root(*target).is_none() && build.config.build == *target {\n+                let target = build.config.target_config.entry(target.clone())\n+                                 .or_insert(Default::default());\n+                target.musl_root = Some(\"/usr\".into());\n+            }\n             match build.musl_root(*target) {\n                 Some(root) => {\n                     if fs::metadata(root.join(\"lib/libc.a\")).is_err() {"}, {"sha": "d734ae6a2cf61b2184bba55d315bff8024a7ea3a", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 295, "deletions": 5, "changes": 300, "blob_url": "https://github.com/rust-lang/rust/blob/c872f4727697327550d43d106f5dddd735c41e5f/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c872f4727697327550d43d106f5dddd735c41e5f/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=c872f4727697327550d43d106f5dddd735c41e5f", "patch": "@@ -16,16 +16,13 @@\n //!\n //! [arc]: struct.Arc.html\n \n-use boxed::Box;\n-\n use core::sync::atomic;\n use core::sync::atomic::Ordering::{Acquire, Relaxed, Release, SeqCst};\n use core::borrow;\n use core::fmt;\n use core::cmp::Ordering;\n use core::intrinsics::abort;\n-use core::mem;\n-use core::mem::uninitialized;\n+use core::mem::{self, size_of_val, uninitialized};\n use core::ops::Deref;\n use core::ops::CoerceUnsized;\n use core::ptr::{self, Shared};\n@@ -34,7 +31,10 @@ use core::hash::{Hash, Hasher};\n use core::{isize, usize};\n use core::convert::From;\n \n-use heap::{Heap, Alloc, Layout};\n+use heap::{Heap, Alloc, Layout, box_free};\n+use boxed::Box;\n+use string::String;\n+use vec::Vec;\n \n /// A soft limit on the amount of references that may be made to an `Arc`.\n ///\n@@ -532,6 +532,141 @@ impl<T: ?Sized> Arc<T> {\n     }\n }\n \n+impl<T: ?Sized> Arc<T> {\n+    // Allocates an `ArcInner<T>` with sufficient space for an unsized value\n+    unsafe fn allocate_for_ptr(ptr: *const T) -> *mut ArcInner<T> {\n+        // Create a fake ArcInner to find allocation size and alignment\n+        let fake_ptr = ptr as *mut ArcInner<T>;\n+\n+        let layout = Layout::for_value(&*fake_ptr);\n+\n+        let mem = Heap.alloc(layout)\n+            .unwrap_or_else(|e| Heap.oom(e));\n+\n+        // Initialize the real ArcInner\n+        let inner = set_data_ptr(ptr as *mut T, mem) as *mut ArcInner<T>;\n+\n+        ptr::write(&mut (*inner).strong, atomic::AtomicUsize::new(1));\n+        ptr::write(&mut (*inner).weak, atomic::AtomicUsize::new(1));\n+\n+        inner\n+    }\n+\n+    fn from_box(v: Box<T>) -> Arc<T> {\n+        unsafe {\n+            let bptr = Box::into_raw(v);\n+\n+            let value_size = size_of_val(&*bptr);\n+            let ptr = Self::allocate_for_ptr(bptr);\n+\n+            // Copy value as bytes\n+            ptr::copy_nonoverlapping(\n+                bptr as *const T as *const u8,\n+                &mut (*ptr).data as *mut _ as *mut u8,\n+                value_size);\n+\n+            // Free the allocation without dropping its contents\n+            box_free(bptr);\n+\n+            Arc { ptr: Shared::new_unchecked(ptr) }\n+        }\n+    }\n+}\n+\n+// Sets the data pointer of a `?Sized` raw pointer.\n+//\n+// For a slice/trait object, this sets the `data` field and leaves the rest\n+// unchanged. For a sized raw pointer, this simply sets the pointer.\n+unsafe fn set_data_ptr<T: ?Sized, U>(mut ptr: *mut T, data: *mut U) -> *mut T {\n+    ptr::write(&mut ptr as *mut _ as *mut *mut u8, data as *mut u8);\n+    ptr\n+}\n+\n+impl<T> Arc<[T]> {\n+    // Copy elements from slice into newly allocated Arc<[T]>\n+    //\n+    // Unsafe because the caller must either take ownership or bind `T: Copy`\n+    unsafe fn copy_from_slice(v: &[T]) -> Arc<[T]> {\n+        let v_ptr = v as *const [T];\n+        let ptr = Self::allocate_for_ptr(v_ptr);\n+\n+        ptr::copy_nonoverlapping(\n+            v.as_ptr(),\n+            &mut (*ptr).data as *mut [T] as *mut T,\n+            v.len());\n+\n+        Arc { ptr: Shared::new_unchecked(ptr) }\n+    }\n+}\n+\n+// Specialization trait used for From<&[T]>\n+trait ArcFromSlice<T> {\n+    fn from_slice(slice: &[T]) -> Self;\n+}\n+\n+impl<T: Clone> ArcFromSlice<T> for Arc<[T]> {\n+    #[inline]\n+    default fn from_slice(v: &[T]) -> Self {\n+        // Panic guard while cloning T elements.\n+        // In the event of a panic, elements that have been written\n+        // into the new ArcInner will be dropped, then the memory freed.\n+        struct Guard<T> {\n+            mem: *mut u8,\n+            elems: *mut T,\n+            layout: Layout,\n+            n_elems: usize,\n+        }\n+\n+        impl<T> Drop for Guard<T> {\n+            fn drop(&mut self) {\n+                use core::slice::from_raw_parts_mut;\n+\n+                unsafe {\n+                    let slice = from_raw_parts_mut(self.elems, self.n_elems);\n+                    ptr::drop_in_place(slice);\n+\n+                    Heap.dealloc(self.mem, self.layout.clone());\n+                }\n+            }\n+        }\n+\n+        unsafe {\n+            let v_ptr = v as *const [T];\n+            let ptr = Self::allocate_for_ptr(v_ptr);\n+\n+            let mem = ptr as *mut _ as *mut u8;\n+            let layout = Layout::for_value(&*ptr);\n+\n+            // Pointer to first element\n+            let elems = &mut (*ptr).data as *mut [T] as *mut T;\n+\n+            let mut guard = Guard{\n+                mem: mem,\n+                elems: elems,\n+                layout: layout,\n+                n_elems: 0,\n+            };\n+\n+            for (i, item) in v.iter().enumerate() {\n+                ptr::write(elems.offset(i as isize), item.clone());\n+                guard.n_elems += 1;\n+            }\n+\n+            // All clear. Forget the guard so it doesn't free the new ArcInner.\n+            mem::forget(guard);\n+\n+            Arc { ptr: Shared::new_unchecked(ptr) }\n+        }\n+    }\n+}\n+\n+impl<T: Copy> ArcFromSlice<T> for Arc<[T]> {\n+    #[inline]\n+    fn from_slice(v: &[T]) -> Self {\n+        unsafe { Arc::copy_from_slice(v) }\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized> Clone for Arc<T> {\n     /// Makes a clone of the `Arc` pointer.\n@@ -1216,8 +1351,56 @@ impl<T> From<T> for Arc<T> {\n     }\n }\n \n+#[stable(feature = \"shared_from_slice\", since = \"1.21.0\")]\n+impl<'a, T: Clone> From<&'a [T]> for Arc<[T]> {\n+    #[inline]\n+    fn from(v: &[T]) -> Arc<[T]> {\n+        <Self as ArcFromSlice<T>>::from_slice(v)\n+    }\n+}\n+\n+#[stable(feature = \"shared_from_slice\", since = \"1.21.0\")]\n+impl<'a> From<&'a str> for Arc<str> {\n+    #[inline]\n+    fn from(v: &str) -> Arc<str> {\n+        unsafe { mem::transmute(<Arc<[u8]>>::from(v.as_bytes())) }\n+    }\n+}\n+\n+#[stable(feature = \"shared_from_slice\", since = \"1.21.0\")]\n+impl From<String> for Arc<str> {\n+    #[inline]\n+    fn from(v: String) -> Arc<str> {\n+        Arc::from(&v[..])\n+    }\n+}\n+\n+#[stable(feature = \"shared_from_slice\", since = \"1.21.0\")]\n+impl<T: ?Sized> From<Box<T>> for Arc<T> {\n+    #[inline]\n+    fn from(v: Box<T>) -> Arc<T> {\n+        Arc::from_box(v)\n+    }\n+}\n+\n+#[stable(feature = \"shared_from_slice\", since = \"1.21.0\")]\n+impl<T> From<Vec<T>> for Arc<[T]> {\n+    #[inline]\n+    fn from(mut v: Vec<T>) -> Arc<[T]> {\n+        unsafe {\n+            let arc = Arc::copy_from_slice(&v);\n+\n+            // Allow the Vec to free its memory, but not destroy its contents\n+            v.set_len(0);\n+\n+            arc\n+        }\n+    }\n+}\n+\n #[cfg(test)]\n mod tests {\n+    use std::boxed::Box;\n     use std::clone::Clone;\n     use std::sync::mpsc::channel;\n     use std::mem::drop;\n@@ -1520,6 +1703,113 @@ mod tests {\n         }\n         t.join().unwrap();\n     }\n+\n+    #[test]\n+    fn test_from_str() {\n+        let r: Arc<str> = Arc::from(\"foo\");\n+\n+        assert_eq!(&r[..], \"foo\");\n+    }\n+\n+    #[test]\n+    fn test_copy_from_slice() {\n+        let s: &[u32] = &[1, 2, 3];\n+        let r: Arc<[u32]> = Arc::from(s);\n+\n+        assert_eq!(&r[..], [1, 2, 3]);\n+    }\n+\n+    #[test]\n+    fn test_clone_from_slice() {\n+        #[derive(Clone, Debug, Eq, PartialEq)]\n+        struct X(u32);\n+\n+        let s: &[X] = &[X(1), X(2), X(3)];\n+        let r: Arc<[X]> = Arc::from(s);\n+\n+        assert_eq!(&r[..], s);\n+    }\n+\n+    #[test]\n+    #[should_panic]\n+    fn test_clone_from_slice_panic() {\n+        use std::string::{String, ToString};\n+\n+        struct Fail(u32, String);\n+\n+        impl Clone for Fail {\n+            fn clone(&self) -> Fail {\n+                if self.0 == 2 {\n+                    panic!();\n+                }\n+                Fail(self.0, self.1.clone())\n+            }\n+        }\n+\n+        let s: &[Fail] = &[\n+            Fail(0, \"foo\".to_string()),\n+            Fail(1, \"bar\".to_string()),\n+            Fail(2, \"baz\".to_string()),\n+        ];\n+\n+        // Should panic, but not cause memory corruption\n+        let _r: Arc<[Fail]> = Arc::from(s);\n+    }\n+\n+    #[test]\n+    fn test_from_box() {\n+        let b: Box<u32> = box 123;\n+        let r: Arc<u32> = Arc::from(b);\n+\n+        assert_eq!(*r, 123);\n+    }\n+\n+    #[test]\n+    fn test_from_box_str() {\n+        use std::string::String;\n+\n+        let s = String::from(\"foo\").into_boxed_str();\n+        let r: Arc<str> = Arc::from(s);\n+\n+        assert_eq!(&r[..], \"foo\");\n+    }\n+\n+    #[test]\n+    fn test_from_box_slice() {\n+        let s = vec![1, 2, 3].into_boxed_slice();\n+        let r: Arc<[u32]> = Arc::from(s);\n+\n+        assert_eq!(&r[..], [1, 2, 3]);\n+    }\n+\n+    #[test]\n+    fn test_from_box_trait() {\n+        use std::fmt::Display;\n+        use std::string::ToString;\n+\n+        let b: Box<Display> = box 123;\n+        let r: Arc<Display> = Arc::from(b);\n+\n+        assert_eq!(r.to_string(), \"123\");\n+    }\n+\n+    #[test]\n+    fn test_from_box_trait_zero_sized() {\n+        use std::fmt::Debug;\n+\n+        let b: Box<Debug> = box ();\n+        let r: Arc<Debug> = Arc::from(b);\n+\n+        assert_eq!(format!(\"{:?}\", r), \"()\");\n+    }\n+\n+    #[test]\n+    fn test_from_vec() {\n+        let v = vec![1, 2, 3];\n+        let r: Arc<[u32]> = Arc::from(v);\n+\n+        assert_eq!(&r[..], [1, 2, 3]);\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "eb9c7df9bf2e08938f529ac0aedec6b17e09fc39", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c872f4727697327550d43d106f5dddd735c41e5f/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c872f4727697327550d43d106f5dddd735c41e5f/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=c872f4727697327550d43d106f5dddd735c41e5f", "patch": "@@ -122,7 +122,7 @@\n #![feature(unsize)]\n #![feature(allocator_internals)]\n \n-#![cfg_attr(not(test), feature(fused, fn_traits, placement_new_protocol))]\n+#![cfg_attr(not(test), feature(fused, fn_traits, placement_new_protocol, swap_with_slice))]\n #![cfg_attr(test, feature(test, box_heap))]\n \n // Allow testing this library"}, {"sha": "47f537caf31c45bddb197416b706b5c177cdd8dc", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 291, "deletions": 60, "changes": 351, "blob_url": "https://github.com/rust-lang/rust/blob/c872f4727697327550d43d106f5dddd735c41e5f/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c872f4727697327550d43d106f5dddd735c41e5f/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=c872f4727697327550d43d106f5dddd735c41e5f", "patch": "@@ -252,14 +252,15 @@ use core::hash::{Hash, Hasher};\n use core::intrinsics::abort;\n use core::marker;\n use core::marker::Unsize;\n-use core::mem::{self, forget, size_of, size_of_val, uninitialized};\n+use core::mem::{self, forget, size_of_val, uninitialized};\n use core::ops::Deref;\n use core::ops::CoerceUnsized;\n use core::ptr::{self, Shared};\n use core::convert::From;\n \n use heap::{Heap, Alloc, Layout, box_free};\n-use raw_vec::RawVec;\n+use string::String;\n+use vec::Vec;\n \n struct RcBox<T: ?Sized> {\n     strong: Cell<usize>,\n@@ -421,64 +422,6 @@ impl<T> Rc<T> {\n     }\n }\n \n-impl Rc<str> {\n-    /// Constructs a new `Rc<str>` from a string slice.\n-    #[doc(hidden)]\n-    #[unstable(feature = \"rustc_private\",\n-               reason = \"for internal use in rustc\",\n-               issue = \"27812\")]\n-    pub fn __from_str(value: &str) -> Rc<str> {\n-        unsafe {\n-            // Allocate enough space for `RcBox<str>`.\n-            let aligned_len = 2 + (value.len() + size_of::<usize>() - 1) / size_of::<usize>();\n-            let vec = RawVec::<usize>::with_capacity(aligned_len);\n-            let ptr = vec.ptr();\n-            forget(vec);\n-            // Initialize fields of `RcBox<str>`.\n-            *ptr.offset(0) = 1; // strong: Cell::new(1)\n-            *ptr.offset(1) = 1; // weak: Cell::new(1)\n-            ptr::copy_nonoverlapping(value.as_ptr(), ptr.offset(2) as *mut u8, value.len());\n-            // Combine the allocation address and the string length into a fat pointer to `RcBox`.\n-            let rcbox_ptr: *mut RcBox<str> = mem::transmute([ptr as usize, value.len()]);\n-            assert!(aligned_len * size_of::<usize>() == size_of_val(&*rcbox_ptr));\n-            Rc { ptr: Shared::new_unchecked(rcbox_ptr) }\n-        }\n-    }\n-}\n-\n-impl<T> Rc<[T]> {\n-    /// Constructs a new `Rc<[T]>` from a `Box<[T]>`.\n-    #[doc(hidden)]\n-    #[unstable(feature = \"rustc_private\",\n-               reason = \"for internal use in rustc\",\n-               issue = \"27812\")]\n-    pub fn __from_array(value: Box<[T]>) -> Rc<[T]> {\n-        unsafe {\n-            let ptr: *mut RcBox<[T]> =\n-                mem::transmute([mem::align_of::<RcBox<[T; 1]>>(), value.len()]);\n-            // FIXME(custom-DST): creating this invalid &[T] is dubiously defined,\n-            // we should have a better way of getting the size/align\n-            // of a DST from its unsized part.\n-            let ptr = Heap.alloc(Layout::for_value(&*ptr))\n-                .unwrap_or_else(|e| Heap.oom(e));\n-            let ptr: *mut RcBox<[T]> = mem::transmute([ptr as usize, value.len()]);\n-\n-            // Initialize the new RcBox.\n-            ptr::write(&mut (*ptr).strong, Cell::new(1));\n-            ptr::write(&mut (*ptr).weak, Cell::new(1));\n-            ptr::copy_nonoverlapping(\n-                value.as_ptr(),\n-                &mut (*ptr).value as *mut [T] as *mut T,\n-                value.len());\n-\n-            // Free the original allocation without freeing its (moved) contents.\n-            box_free(Box::into_raw(value));\n-\n-            Rc { ptr: Shared::new_unchecked(ptr as *mut _) }\n-        }\n-    }\n-}\n-\n impl<T: ?Sized> Rc<T> {\n     /// Creates a new [`Weak`][weak] pointer to this value.\n     ///\n@@ -665,6 +608,140 @@ impl<T: Clone> Rc<T> {\n     }\n }\n \n+impl<T: ?Sized> Rc<T> {\n+    // Allocates an `RcBox<T>` with sufficient space for an unsized value\n+    unsafe fn allocate_for_ptr(ptr: *const T) -> *mut RcBox<T> {\n+        // Create a fake RcBox to find allocation size and alignment\n+        let fake_ptr = ptr as *mut RcBox<T>;\n+\n+        let layout = Layout::for_value(&*fake_ptr);\n+\n+        let mem = Heap.alloc(layout)\n+            .unwrap_or_else(|e| Heap.oom(e));\n+\n+        // Initialize the real RcBox\n+        let inner = set_data_ptr(ptr as *mut T, mem) as *mut RcBox<T>;\n+\n+        ptr::write(&mut (*inner).strong, Cell::new(1));\n+        ptr::write(&mut (*inner).weak, Cell::new(1));\n+\n+        inner\n+    }\n+\n+    fn from_box(v: Box<T>) -> Rc<T> {\n+        unsafe {\n+            let bptr = Box::into_raw(v);\n+\n+            let value_size = size_of_val(&*bptr);\n+            let ptr = Self::allocate_for_ptr(bptr);\n+\n+            // Copy value as bytes\n+            ptr::copy_nonoverlapping(\n+                bptr as *const T as *const u8,\n+                &mut (*ptr).value as *mut _ as *mut u8,\n+                value_size);\n+\n+            // Free the allocation without dropping its contents\n+            box_free(bptr);\n+\n+            Rc { ptr: Shared::new_unchecked(ptr) }\n+        }\n+    }\n+}\n+\n+// Sets the data pointer of a `?Sized` raw pointer.\n+//\n+// For a slice/trait object, this sets the `data` field and leaves the rest\n+// unchanged. For a sized raw pointer, this simply sets the pointer.\n+unsafe fn set_data_ptr<T: ?Sized, U>(mut ptr: *mut T, data: *mut U) -> *mut T {\n+    ptr::write(&mut ptr as *mut _ as *mut *mut u8, data as *mut u8);\n+    ptr\n+}\n+\n+impl<T> Rc<[T]> {\n+    // Copy elements from slice into newly allocated Rc<[T]>\n+    //\n+    // Unsafe because the caller must either take ownership or bind `T: Copy`\n+    unsafe fn copy_from_slice(v: &[T]) -> Rc<[T]> {\n+        let v_ptr = v as *const [T];\n+        let ptr = Self::allocate_for_ptr(v_ptr);\n+\n+        ptr::copy_nonoverlapping(\n+            v.as_ptr(),\n+            &mut (*ptr).value as *mut [T] as *mut T,\n+            v.len());\n+\n+        Rc { ptr: Shared::new_unchecked(ptr) }\n+    }\n+}\n+\n+trait RcFromSlice<T> {\n+    fn from_slice(slice: &[T]) -> Self;\n+}\n+\n+impl<T: Clone> RcFromSlice<T> for Rc<[T]> {\n+    #[inline]\n+    default fn from_slice(v: &[T]) -> Self {\n+        // Panic guard while cloning T elements.\n+        // In the event of a panic, elements that have been written\n+        // into the new RcBox will be dropped, then the memory freed.\n+        struct Guard<T> {\n+            mem: *mut u8,\n+            elems: *mut T,\n+            layout: Layout,\n+            n_elems: usize,\n+        }\n+\n+        impl<T> Drop for Guard<T> {\n+            fn drop(&mut self) {\n+                use core::slice::from_raw_parts_mut;\n+\n+                unsafe {\n+                    let slice = from_raw_parts_mut(self.elems, self.n_elems);\n+                    ptr::drop_in_place(slice);\n+\n+                    Heap.dealloc(self.mem, self.layout.clone());\n+                }\n+            }\n+        }\n+\n+        unsafe {\n+            let v_ptr = v as *const [T];\n+            let ptr = Self::allocate_for_ptr(v_ptr);\n+\n+            let mem = ptr as *mut _ as *mut u8;\n+            let layout = Layout::for_value(&*ptr);\n+\n+            // Pointer to first element\n+            let elems = &mut (*ptr).value as *mut [T] as *mut T;\n+\n+            let mut guard = Guard{\n+                mem: mem,\n+                elems: elems,\n+                layout: layout,\n+                n_elems: 0,\n+            };\n+\n+            for (i, item) in v.iter().enumerate() {\n+                ptr::write(elems.offset(i as isize), item.clone());\n+                guard.n_elems += 1;\n+            }\n+\n+            // All clear. Forget the guard so it doesn't free the new RcBox.\n+            forget(guard);\n+\n+            Rc { ptr: Shared::new_unchecked(ptr) }\n+        }\n+    }\n+}\n+\n+impl<T: Copy> RcFromSlice<T> for Rc<[T]> {\n+    #[inline]\n+    fn from_slice(v: &[T]) -> Self {\n+        unsafe { Rc::copy_from_slice(v) }\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized> Deref for Rc<T> {\n     type Target = T;\n@@ -959,6 +1036,53 @@ impl<T> From<T> for Rc<T> {\n     }\n }\n \n+#[stable(feature = \"shared_from_slice\", since = \"1.21.0\")]\n+impl<'a, T: Clone> From<&'a [T]> for Rc<[T]> {\n+    #[inline]\n+    fn from(v: &[T]) -> Rc<[T]> {\n+        <Self as RcFromSlice<T>>::from_slice(v)\n+    }\n+}\n+\n+#[stable(feature = \"shared_from_slice\", since = \"1.21.0\")]\n+impl<'a> From<&'a str> for Rc<str> {\n+    #[inline]\n+    fn from(v: &str) -> Rc<str> {\n+        unsafe { mem::transmute(<Rc<[u8]>>::from(v.as_bytes())) }\n+    }\n+}\n+\n+#[stable(feature = \"shared_from_slice\", since = \"1.21.0\")]\n+impl From<String> for Rc<str> {\n+    #[inline]\n+    fn from(v: String) -> Rc<str> {\n+        Rc::from(&v[..])\n+    }\n+}\n+\n+#[stable(feature = \"shared_from_slice\", since = \"1.21.0\")]\n+impl<T: ?Sized> From<Box<T>> for Rc<T> {\n+    #[inline]\n+    fn from(v: Box<T>) -> Rc<T> {\n+        Rc::from_box(v)\n+    }\n+}\n+\n+#[stable(feature = \"shared_from_slice\", since = \"1.21.0\")]\n+impl<T> From<Vec<T>> for Rc<[T]> {\n+    #[inline]\n+    fn from(mut v: Vec<T>) -> Rc<[T]> {\n+        unsafe {\n+            let rc = Rc::copy_from_slice(&v);\n+\n+            // Allow the Vec to free its memory, but not destroy its contents\n+            v.set_len(0);\n+\n+            rc\n+        }\n+    }\n+}\n+\n /// `Weak` is a version of [`Rc`] that holds a non-owning reference to the\n /// managed value. The value is accessed by calling [`upgrade`] on the `Weak`\n /// pointer, which returns an [`Option`]`<`[`Rc`]`<T>>`.\n@@ -1465,6 +1589,113 @@ mod tests {\n         assert!(Rc::ptr_eq(&five, &same_five));\n         assert!(!Rc::ptr_eq(&five, &other_five));\n     }\n+\n+    #[test]\n+    fn test_from_str() {\n+        let r: Rc<str> = Rc::from(\"foo\");\n+\n+        assert_eq!(&r[..], \"foo\");\n+    }\n+\n+    #[test]\n+    fn test_copy_from_slice() {\n+        let s: &[u32] = &[1, 2, 3];\n+        let r: Rc<[u32]> = Rc::from(s);\n+\n+        assert_eq!(&r[..], [1, 2, 3]);\n+    }\n+\n+    #[test]\n+    fn test_clone_from_slice() {\n+        #[derive(Clone, Debug, Eq, PartialEq)]\n+        struct X(u32);\n+\n+        let s: &[X] = &[X(1), X(2), X(3)];\n+        let r: Rc<[X]> = Rc::from(s);\n+\n+        assert_eq!(&r[..], s);\n+    }\n+\n+    #[test]\n+    #[should_panic]\n+    fn test_clone_from_slice_panic() {\n+        use std::string::{String, ToString};\n+\n+        struct Fail(u32, String);\n+\n+        impl Clone for Fail {\n+            fn clone(&self) -> Fail {\n+                if self.0 == 2 {\n+                    panic!();\n+                }\n+                Fail(self.0, self.1.clone())\n+            }\n+        }\n+\n+        let s: &[Fail] = &[\n+            Fail(0, \"foo\".to_string()),\n+            Fail(1, \"bar\".to_string()),\n+            Fail(2, \"baz\".to_string()),\n+        ];\n+\n+        // Should panic, but not cause memory corruption\n+        let _r: Rc<[Fail]> = Rc::from(s);\n+    }\n+\n+    #[test]\n+    fn test_from_box() {\n+        let b: Box<u32> = box 123;\n+        let r: Rc<u32> = Rc::from(b);\n+\n+        assert_eq!(*r, 123);\n+    }\n+\n+    #[test]\n+    fn test_from_box_str() {\n+        use std::string::String;\n+\n+        let s = String::from(\"foo\").into_boxed_str();\n+        let r: Rc<str> = Rc::from(s);\n+\n+        assert_eq!(&r[..], \"foo\");\n+    }\n+\n+    #[test]\n+    fn test_from_box_slice() {\n+        let s = vec![1, 2, 3].into_boxed_slice();\n+        let r: Rc<[u32]> = Rc::from(s);\n+\n+        assert_eq!(&r[..], [1, 2, 3]);\n+    }\n+\n+    #[test]\n+    fn test_from_box_trait() {\n+        use std::fmt::Display;\n+        use std::string::ToString;\n+\n+        let b: Box<Display> = box 123;\n+        let r: Rc<Display> = Rc::from(b);\n+\n+        assert_eq!(r.to_string(), \"123\");\n+    }\n+\n+    #[test]\n+    fn test_from_box_trait_zero_sized() {\n+        use std::fmt::Debug;\n+\n+        let b: Box<Debug> = box ();\n+        let r: Rc<Debug> = Rc::from(b);\n+\n+        assert_eq!(format!(\"{:?}\", r), \"()\");\n+    }\n+\n+    #[test]\n+    fn test_from_vec() {\n+        let v = vec![1, 2, 3];\n+        let r: Rc<[u32]> = Rc::from(v);\n+\n+        assert_eq!(&r[..], [1, 2, 3]);\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "cbf242e884a70cda7258c98aa969b1f783b028ba", "filename": "src/liballoc/slice.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/c872f4727697327550d43d106f5dddd735c41e5f/src%2Fliballoc%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c872f4727697327550d43d106f5dddd735c41e5f/src%2Fliballoc%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fslice.rs?ref=c872f4727697327550d43d106f5dddd735c41e5f", "patch": "@@ -1461,6 +1461,31 @@ impl<T> [T] {\n         core_slice::SliceExt::copy_from_slice(self, src)\n     }\n \n+    /// Swaps all elements in `self` with those in `src`.\n+    ///\n+    /// The length of `src` must be the same as `self`.\n+    ///\n+    /// # Panics\n+    ///\n+    /// This function will panic if the two slices have different lengths.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// #![feature(swap_with_slice)]\n+    ///\n+    /// let mut src = [1, 2, 3];\n+    /// let mut dst = [7, 8, 9];\n+    ///\n+    /// src.swap_with_slice(&mut dst);\n+    /// assert_eq!(src, [7, 8, 9]);\n+    /// assert_eq!(dst, [1, 2, 3]);\n+    /// ```\n+    #[unstable(feature = \"swap_with_slice\", issue = \"44030\")]\n+    pub fn swap_with_slice(&mut self, src: &mut [T]) {\n+        core_slice::SliceExt::swap_with_slice(self, src)\n+    }\n+\n     /// Copies `self` into a new `Vec`.\n     ///\n     /// # Examples"}, {"sha": "31d8266510a1ea652cb400e407829307f90938b5", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c872f4727697327550d43d106f5dddd735c41e5f/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c872f4727697327550d43d106f5dddd735c41e5f/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=c872f4727697327550d43d106f5dddd735c41e5f", "patch": "@@ -212,6 +212,9 @@ pub trait SliceExt {\n     #[stable(feature = \"copy_from_slice\", since = \"1.9.0\")]\n     fn copy_from_slice(&mut self, src: &[Self::Item]) where Self::Item: Copy;\n \n+    #[unstable(feature = \"swap_with_slice\", issue = \"44030\")]\n+    fn swap_with_slice(&mut self, src: &mut [Self::Item]);\n+\n     #[stable(feature = \"sort_unstable\", since = \"1.20.0\")]\n     fn sort_unstable(&mut self)\n         where Self::Item: Ord;\n@@ -673,6 +676,16 @@ impl<T> SliceExt for [T] {\n         }\n     }\n \n+    #[inline]\n+    fn swap_with_slice(&mut self, src: &mut [T]) {\n+        assert!(self.len() == src.len(),\n+                \"destination and source slices have different lengths\");\n+        unsafe {\n+            ptr::swap_nonoverlapping(\n+                self.as_mut_ptr(), src.as_mut_ptr(), self.len());\n+        }\n+    }\n+\n     #[inline]\n     fn binary_search_by_key<'a, B, F, Q: ?Sized>(&'a self, b: &Q, mut f: F) -> Result<usize, usize>\n         where F: FnMut(&'a Self::Item) -> B,"}, {"sha": "38665b403d6abdf65b96217fe5f825dd7ed5ec8f", "filename": "src/libproc_macro/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c872f4727697327550d43d106f5dddd735c41e5f/src%2Flibproc_macro%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c872f4727697327550d43d106f5dddd735c41e5f/src%2Flibproc_macro%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Flib.rs?ref=c872f4727697327550d43d106f5dddd735c41e5f", "patch": "@@ -241,14 +241,14 @@ pub enum TokenNode {\n }\n \n /// Describes how a sequence of token trees is delimited.\n-#[derive(Copy, Clone, Debug)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n pub enum Delimiter {\n     /// `( ... )`\n     Parenthesis,\n-    /// `[ ... ]`\n-    Brace,\n     /// `{ ... }`\n+    Brace,\n+    /// `[ ... ]`\n     Bracket,\n     /// An implicit delimiter, e.g. `$var`, where $var is  `...`.\n     None,\n@@ -274,7 +274,7 @@ impl Term {\n }\n \n /// Whether an `Op` is either followed immediately by another `Op` or followed by whitespace.\n-#[derive(Copy, Clone, Debug)]\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n pub enum Spacing {\n     /// e.g. `+` is `Alone` in `+ =`."}, {"sha": "809d1dfcf60a2ff479798bc722197e958a312b99", "filename": "src/librustc/dep_graph/edges.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c872f4727697327550d43d106f5dddd735c41e5f/src%2Flibrustc%2Fdep_graph%2Fedges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c872f4727697327550d43d106f5dddd735c41e5f/src%2Flibrustc%2Fdep_graph%2Fedges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fedges.rs?ref=c872f4727697327550d43d106f5dddd735c41e5f", "patch": "@@ -244,8 +244,8 @@ impl DepGraphEdges {\n         self.edges.insert((source, target));\n     }\n \n-    pub fn add_node(&mut self, node: DepNode) {\n-        self.get_or_create_node(node);\n+    pub fn add_node(&mut self, node: DepNode) -> DepNodeIndex {\n+        self.get_or_create_node(node)\n     }\n \n     #[inline]"}, {"sha": "c487fc963ca14a46ae9f0b01eb8e2ded237247b2", "filename": "src/librustc/dep_graph/graph.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c872f4727697327550d43d106f5dddd735c41e5f/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c872f4727697327550d43d106f5dddd735c41e5f/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fgraph.rs?ref=c872f4727697327550d43d106f5dddd735c41e5f", "patch": "@@ -12,6 +12,7 @@ use rustc_data_structures::fx::FxHashMap;\n use session::config::OutputType;\n use std::cell::{Ref, RefCell};\n use std::rc::Rc;\n+use util::common::{ProfileQueriesMsg, profq_msg};\n \n use super::dep_node::{DepNode, DepKind, WorkProductId};\n use super::query::DepGraphQuery;\n@@ -118,7 +119,13 @@ impl DepGraph {\n     {\n         if let Some(ref data) = self.data {\n             data.edges.borrow_mut().push_task(key);\n+            if cfg!(debug_assertions) {\n+                profq_msg(ProfileQueriesMsg::TaskBegin(key.clone()))\n+            };\n             let result = task(cx, arg);\n+            if cfg!(debug_assertions) {\n+                profq_msg(ProfileQueriesMsg::TaskEnd)\n+            };\n             let dep_node_index = data.edges.borrow_mut().pop_task(key);\n             (result, dep_node_index)\n         } else {\n@@ -166,6 +173,14 @@ impl DepGraph {\n         self.data.as_ref().unwrap().edges.borrow_mut().add_node(node);\n     }\n \n+    pub fn alloc_input_node(&self, node: DepNode) -> DepNodeIndex {\n+        if let Some(ref data) = self.data {\n+            data.edges.borrow_mut().add_node(node)\n+        } else {\n+            DepNodeIndex::INVALID\n+        }\n+    }\n+\n     /// Indicates that a previous work product exists for `v`. This is\n     /// invoked during initial start-up based on what nodes are clean\n     /// (and what files exist in the incr. directory)."}, {"sha": "f027dd34f29b4be3d2a3964e02ce3a5b42a1a8a9", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c872f4727697327550d43d106f5dddd735c41e5f/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c872f4727697327550d43d106f5dddd735c41e5f/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=c872f4727697327550d43d106f5dddd735c41e5f", "patch": "@@ -687,6 +687,21 @@ attributes:\n See also https://doc.rust-lang.org/book/first-edition/no-stdlib.html\n \"##,\n \n+E0214: r##\"\n+A generic type was described using parentheses rather than angle brackets. For\n+example:\n+\n+```compile_fail,E0214\n+fn main() {\n+    let v: Vec(&str) = vec![\"foo\"];\n+}\n+```\n+\n+This is not currently supported: `v` should be defined as `Vec<&str>`.\n+Parentheses are currently only used with generic types when defining parameters\n+for `Fn`-family traits.\n+\"##,\n+\n E0261: r##\"\n When using a lifetime like `'a` in a type, it must be declared before being\n used."}, {"sha": "880605ee377f7ffbd01d9c7f7a96956f4b54ec31", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/c872f4727697327550d43d106f5dddd735c41e5f/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c872f4727697327550d43d106f5dddd735c41e5f/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=c872f4727697327550d43d106f5dddd735c41e5f", "patch": "@@ -617,17 +617,9 @@ pub fn walk_path_segment<'v, V: Visitor<'v>>(visitor: &mut V,\n pub fn walk_path_parameters<'v, V: Visitor<'v>>(visitor: &mut V,\n                                                 _path_span: Span,\n                                                 path_parameters: &'v PathParameters) {\n-    match *path_parameters {\n-        AngleBracketedParameters(ref data) => {\n-            walk_list!(visitor, visit_ty, &data.types);\n-            walk_list!(visitor, visit_lifetime, &data.lifetimes);\n-            walk_list!(visitor, visit_assoc_type_binding, &data.bindings);\n-        }\n-        ParenthesizedParameters(ref data) => {\n-            walk_list!(visitor, visit_ty, &data.inputs);\n-            walk_list!(visitor, visit_ty, &data.output);\n-        }\n-    }\n+    walk_list!(visitor, visit_lifetime, &path_parameters.lifetimes);\n+    walk_list!(visitor, visit_ty, &path_parameters.types);\n+    walk_list!(visitor, visit_assoc_type_binding, &path_parameters.bindings);\n }\n \n pub fn walk_assoc_type_binding<'v, V: Visitor<'v>>(visitor: &mut V,\n@@ -835,7 +827,16 @@ pub fn walk_trait_item_ref<'v, V: Visitor<'v>>(visitor: &mut V, trait_item_ref:\n \n pub fn walk_impl_item<'v, V: Visitor<'v>>(visitor: &mut V, impl_item: &'v ImplItem) {\n     // NB: Deliberately force a compilation error if/when new fields are added.\n-    let ImplItem { id: _, name, ref vis, ref defaultness, ref attrs, ref node, span } = *impl_item;\n+    let ImplItem {\n+        id: _,\n+        hir_id: _,\n+        name,\n+        ref vis,\n+        ref defaultness,\n+        ref attrs,\n+        ref node,\n+        span\n+    } = *impl_item;\n \n     visitor.visit_name(span, name);\n     visitor.visit_vis(vis);"}, {"sha": "f6ded6468b102d80f439406ef8b20151b4d39f45", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 94, "deletions": 31, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/c872f4727697327550d43d106f5dddd735c41e5f/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c872f4727697327550d43d106f5dddd735c41e5f/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=c872f4727697327550d43d106f5dddd735c41e5f", "patch": "@@ -45,15 +45,16 @@ use hir::map::{Definitions, DefKey, REGULAR_SPACE};\n use hir::map::definitions::DefPathData;\n use hir::def_id::{DefIndex, DefId, CRATE_DEF_INDEX};\n use hir::def::{Def, PathResolution};\n+use lint::builtin::PARENTHESIZED_PARAMS_IN_TYPES_AND_MODULES;\n use rustc_data_structures::indexed_vec::IndexVec;\n use session::Session;\n+use util::common::FN_OUTPUT_NAME;\n use util::nodemap::{DefIdMap, FxHashMap, NodeMap};\n \n use std::collections::BTreeMap;\n use std::fmt::Debug;\n use std::iter;\n use std::mem;\n-\n use syntax::attr;\n use syntax::ast::*;\n use syntax::errors;\n@@ -163,6 +164,12 @@ struct LoweredNodeId {\n     hir_id: hir::HirId,\n }\n \n+enum ParenthesizedGenericArgs {\n+    Ok,\n+    Warn,\n+    Err,\n+}\n+\n impl<'a> LoweringContext<'a> {\n     fn lower_crate(mut self, c: &Crate) -> hir::Crate {\n         /// Full-crate AST visitor that inserts into a fresh\n@@ -761,6 +768,21 @@ impl<'a> LoweringContext<'a> {\n                     Def::Trait(def_id) if i + 1 == proj_start => Some(def_id),\n                     _ => None\n                 };\n+                let parenthesized_generic_args = match resolution.base_def() {\n+                    // `a::b::Trait(Args)`\n+                    Def::Trait(..) if i + 1 == proj_start => ParenthesizedGenericArgs::Ok,\n+                    // `a::b::Trait(Args)::TraitItem`\n+                    Def::Method(..) |\n+                    Def::AssociatedConst(..) |\n+                    Def::AssociatedTy(..) if i + 2 == proj_start => ParenthesizedGenericArgs::Ok,\n+                    // Avoid duplicated errors\n+                    Def::Err => ParenthesizedGenericArgs::Ok,\n+                    // An error\n+                    Def::Struct(..) | Def::Enum(..) | Def::Union(..) | Def::TyAlias(..) |\n+                    Def::Variant(..) if i + 1 == proj_start => ParenthesizedGenericArgs::Err,\n+                    // A warning for now, for compatibility reasons\n+                    _ => ParenthesizedGenericArgs::Warn,\n+                };\n \n                 let num_lifetimes = type_def_id.map_or(0, |def_id| {\n                     if let Some(&n) = self.type_def_lifetime_params.get(&def_id) {\n@@ -771,7 +793,8 @@ impl<'a> LoweringContext<'a> {\n                     self.type_def_lifetime_params.insert(def_id, n);\n                     n\n                 });\n-                self.lower_path_segment(p.span, segment, param_mode, num_lifetimes)\n+                self.lower_path_segment(p.span, segment, param_mode, num_lifetimes,\n+                                        parenthesized_generic_args)\n             }).collect(),\n             span: p.span,\n         });\n@@ -806,7 +829,8 @@ impl<'a> LoweringContext<'a> {\n         //   3. `<<std::vec::Vec<T>>::IntoIter>::Item`\n         // * final path is `<<<std::vec::Vec<T>>::IntoIter>::Item>::clone`\n         for (i, segment) in p.segments.iter().enumerate().skip(proj_start) {\n-            let segment = P(self.lower_path_segment(p.span, segment, param_mode, 0));\n+            let segment = P(self.lower_path_segment(p.span, segment, param_mode, 0,\n+                                                    ParenthesizedGenericArgs::Warn));\n             let qpath = hir::QPath::TypeRelative(ty, segment);\n \n             // It's finished, return the extension of the right node type.\n@@ -839,7 +863,8 @@ impl<'a> LoweringContext<'a> {\n         hir::Path {\n             def: self.expect_full_def(id),\n             segments: segments.map(|segment| {\n-                self.lower_path_segment(p.span, segment, param_mode, 0)\n+                self.lower_path_segment(p.span, segment, param_mode, 0,\n+                                        ParenthesizedGenericArgs::Err)\n             }).chain(name.map(|name| {\n                 hir::PathSegment {\n                     name,\n@@ -863,29 +888,37 @@ impl<'a> LoweringContext<'a> {\n                           path_span: Span,\n                           segment: &PathSegment,\n                           param_mode: ParamMode,\n-                          expected_lifetimes: usize)\n+                          expected_lifetimes: usize,\n+                          parenthesized_generic_args: ParenthesizedGenericArgs)\n                           -> hir::PathSegment {\n         let mut parameters = if let Some(ref parameters) = segment.parameters {\n+            let msg = \"parenthesized parameters may only be used with a trait\";\n             match **parameters {\n                 PathParameters::AngleBracketed(ref data) => {\n-                    let data = self.lower_angle_bracketed_parameter_data(data, param_mode);\n-                    hir::AngleBracketedParameters(data)\n+                    self.lower_angle_bracketed_parameter_data(data, param_mode)\n                 }\n-                PathParameters::Parenthesized(ref data) => {\n-                    hir::ParenthesizedParameters(self.lower_parenthesized_parameter_data(data))\n+                PathParameters::Parenthesized(ref data) => match parenthesized_generic_args {\n+                    ParenthesizedGenericArgs::Ok => self.lower_parenthesized_parameter_data(data),\n+                    ParenthesizedGenericArgs::Warn => {\n+                        self.sess.buffer_lint(PARENTHESIZED_PARAMS_IN_TYPES_AND_MODULES,\n+                                              CRATE_NODE_ID, data.span, msg.into());\n+                        hir::PathParameters::none()\n+                    }\n+                    ParenthesizedGenericArgs::Err => {\n+                        struct_span_err!(self.sess, data.span, E0214, \"{}\", msg)\n+                            .span_label(data.span, \"only traits may use parentheses\").emit();\n+                        hir::PathParameters::none()\n+                    }\n                 }\n             }\n         } else {\n-            let data = self.lower_angle_bracketed_parameter_data(&Default::default(), param_mode);\n-            hir::AngleBracketedParameters(data)\n+            self.lower_angle_bracketed_parameter_data(&Default::default(), param_mode)\n         };\n \n-        if let hir::AngleBracketedParameters(ref mut data) = parameters {\n-            if data.lifetimes.is_empty() {\n-                data.lifetimes = (0..expected_lifetimes).map(|_| {\n-                    self.elided_lifetime(path_span)\n-                }).collect();\n-            }\n+        if !parameters.parenthesized && parameters.lifetimes.is_empty() {\n+            parameters.lifetimes = (0..expected_lifetimes).map(|_| {\n+                self.elided_lifetime(path_span)\n+            }).collect();\n         }\n \n         hir::PathSegment {\n@@ -897,24 +930,38 @@ impl<'a> LoweringContext<'a> {\n     fn lower_angle_bracketed_parameter_data(&mut self,\n                                             data: &AngleBracketedParameterData,\n                                             param_mode: ParamMode)\n-                                            -> hir::AngleBracketedParameterData {\n+                                            -> hir::PathParameters {\n         let &AngleBracketedParameterData { ref lifetimes, ref types, ref bindings, .. } = data;\n-        hir::AngleBracketedParameterData {\n+        hir::PathParameters {\n             lifetimes: self.lower_lifetimes(lifetimes),\n             types: types.iter().map(|ty| self.lower_ty(ty)).collect(),\n             infer_types: types.is_empty() && param_mode == ParamMode::Optional,\n             bindings: bindings.iter().map(|b| self.lower_ty_binding(b)).collect(),\n+            parenthesized: false,\n         }\n     }\n \n     fn lower_parenthesized_parameter_data(&mut self,\n                                           data: &ParenthesizedParameterData)\n-                                          -> hir::ParenthesizedParameterData {\n+                                          -> hir::PathParameters {\n         let &ParenthesizedParameterData { ref inputs, ref output, span } = data;\n-        hir::ParenthesizedParameterData {\n-            inputs: inputs.iter().map(|ty| self.lower_ty(ty)).collect(),\n-            output: output.as_ref().map(|ty| self.lower_ty(ty)),\n-            span,\n+        let inputs = inputs.iter().map(|ty| self.lower_ty(ty)).collect();\n+        let mk_tup = |this: &mut Self, tys, span| {\n+            P(hir::Ty { node: hir::TyTup(tys), id: this.next_id().node_id, span })\n+        };\n+\n+        hir::PathParameters {\n+            lifetimes: hir::HirVec::new(),\n+            types: hir_vec![mk_tup(self, inputs, span)],\n+            infer_types: false,\n+            bindings: hir_vec![hir::TypeBinding {\n+                id: self.next_id().node_id,\n+                name: Symbol::intern(FN_OUTPUT_NAME),\n+                ty: output.as_ref().map(|ty| self.lower_ty(&ty))\n+                                   .unwrap_or_else(|| mk_tup(self, hir::HirVec::new(), span)),\n+                span: output.as_ref().map_or(span, |ty| ty.span),\n+            }],\n+            parenthesized: true,\n         }\n     }\n \n@@ -1280,7 +1327,12 @@ impl<'a> LoweringContext<'a> {\n                             path.span = span;\n \n                             self.allocate_hir_id_counter(import.id, import);\n-                            self.with_hir_id_owner(import.id, |this| {\n+                            let LoweredNodeId {\n+                                node_id: import_node_id,\n+                                hir_id: import_hir_id,\n+                            } = self.lower_node_id(import.id);\n+\n+                            self.with_hir_id_owner(import_node_id, |this| {\n                                 let vis = match *vis {\n                                     hir::Visibility::Public => hir::Visibility::Public,\n                                     hir::Visibility::Crate => hir::Visibility::Crate,\n@@ -1294,8 +1346,9 @@ impl<'a> LoweringContext<'a> {\n                                     }\n                                 };\n \n-                                this.items.insert(import.id, hir::Item {\n-                                    id: import.id,\n+                                this.items.insert(import_node_id, hir::Item {\n+                                    id: import_node_id,\n+                                    hir_id: import_hir_id,\n                                     name: import.rename.unwrap_or(ident).name,\n                                     attrs: attrs.clone(),\n                                     node: hir::ItemUse(P(path), hir::UseKind::Single),\n@@ -1426,8 +1479,11 @@ impl<'a> LoweringContext<'a> {\n \n     fn lower_trait_item(&mut self, i: &TraitItem) -> hir::TraitItem {\n         self.with_parent_def(i.id, |this| {\n+            let LoweredNodeId { node_id, hir_id } = this.lower_node_id(i.id);\n+\n             hir::TraitItem {\n-                id: this.lower_node_id(i.id).node_id,\n+                id: node_id,\n+                hir_id,\n                 name: this.lower_ident(i.ident),\n                 attrs: this.lower_attrs(&i.attrs),\n                 node: match i.node {\n@@ -1487,8 +1543,11 @@ impl<'a> LoweringContext<'a> {\n \n     fn lower_impl_item(&mut self, i: &ImplItem) -> hir::ImplItem {\n         self.with_parent_def(i.id, |this| {\n+            let LoweredNodeId { node_id, hir_id } = this.lower_node_id(i.id);\n+\n             hir::ImplItem {\n-                id: this.lower_node_id(i.id).node_id,\n+                id: node_id,\n+                hir_id,\n                 name: this.lower_ident(i.ident),\n                 attrs: this.lower_attrs(&i.attrs),\n                 vis: this.lower_visibility(&i.vis, None),\n@@ -1579,8 +1638,11 @@ impl<'a> LoweringContext<'a> {\n             this.lower_item_kind(i.id, &mut name, &attrs, &mut vis, &i.node)\n         });\n \n+        let LoweredNodeId { node_id, hir_id } = self.lower_node_id(i.id);\n+\n         Some(hir::Item {\n-            id: self.lower_node_id(i.id).node_id,\n+            id: node_id,\n+            hir_id,\n             name,\n             attrs,\n             node,\n@@ -1889,7 +1951,8 @@ impl<'a> LoweringContext<'a> {\n                 hir::ExprCall(f, args.iter().map(|x| self.lower_expr(x)).collect())\n             }\n             ExprKind::MethodCall(ref seg, ref args) => {\n-                let hir_seg = self.lower_path_segment(e.span, seg, ParamMode::Optional, 0);\n+                let hir_seg = self.lower_path_segment(e.span, seg, ParamMode::Optional, 0,\n+                                                      ParenthesizedGenericArgs::Err);\n                 let args = args.iter().map(|x| self.lower_expr(x)).collect();\n                 hir::ExprMethodCall(hir_seg, seg.span, args)\n             }"}, {"sha": "a54068c648310ffbda503d9ba5f8c1925a0e6a7c", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 165, "deletions": 29, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/c872f4727697327550d43d106f5dddd735c41e5f/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c872f4727697327550d43d106f5dddd735c41e5f/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=c872f4727697327550d43d106f5dddd735c41e5f", "patch": "@@ -10,33 +10,55 @@\n \n use super::*;\n \n+use dep_graph::{DepGraph, DepKind, DepNodeIndex};\n use hir::intravisit::{Visitor, NestedVisitorMap};\n use std::iter::repeat;\n use syntax::ast::{NodeId, CRATE_NODE_ID};\n use syntax_pos::Span;\n \n /// A Visitor that walks over the HIR and collects Nodes into a HIR map\n-pub struct NodeCollector<'hir> {\n+pub(super) struct NodeCollector<'a, 'hir> {\n     /// The crate\n-    pub krate: &'hir Crate,\n+    krate: &'hir Crate,\n     /// The node map\n-    pub(super) map: Vec<MapEntry<'hir>>,\n+    map: Vec<MapEntry<'hir>>,\n     /// The parent of this node\n-    pub parent_node: NodeId,\n+    parent_node: NodeId,\n+\n+    current_dep_node_owner: DefIndex,\n+    current_dep_node_index: DepNodeIndex,\n+\n+    dep_graph: &'a DepGraph,\n+    definitions: &'a definitions::Definitions,\n }\n \n-impl<'hir> NodeCollector<'hir> {\n-    pub fn root(krate: &'hir Crate) -> NodeCollector<'hir> {\n+impl<'a, 'hir> NodeCollector<'a, 'hir> {\n+    pub(super) fn root(krate: &'hir Crate,\n+                dep_graph: &'a DepGraph,\n+                definitions: &'a definitions::Definitions)\n+                -> NodeCollector<'a, 'hir> {\n+        let root_mod_def_path_hash = definitions.def_path_hash(CRATE_DEF_INDEX);\n+        let root_mod_dep_node = root_mod_def_path_hash.to_dep_node(DepKind::Hir);\n+        let root_mod_dep_node_index = dep_graph.alloc_input_node(root_mod_dep_node);\n+\n         let mut collector = NodeCollector {\n             krate,\n             map: vec![],\n             parent_node: CRATE_NODE_ID,\n+            current_dep_node_index: root_mod_dep_node_index,\n+            current_dep_node_owner: CRATE_DEF_INDEX,\n+            dep_graph,\n+            definitions,\n         };\n-        collector.insert_entry(CRATE_NODE_ID, RootCrate);\n+        collector.insert_entry(CRATE_NODE_ID, RootCrate(root_mod_dep_node_index));\n \n         collector\n     }\n \n+    pub(super) fn into_map(self) -> Vec<MapEntry<'hir>> {\n+        self.map\n+    }\n+\n     fn insert_entry(&mut self, id: NodeId, entry: MapEntry<'hir>) {\n         debug!(\"hir_map: {:?} => {:?}\", id, entry);\n         let len = self.map.len();\n@@ -47,8 +69,55 @@ impl<'hir> NodeCollector<'hir> {\n     }\n \n     fn insert(&mut self, id: NodeId, node: Node<'hir>) {\n-        let entry = MapEntry::from_node(self.parent_node, node);\n+        let parent = self.parent_node;\n+        let dep_node_index = self.current_dep_node_index;\n+\n+        let entry = match node {\n+            NodeItem(n) => EntryItem(parent, dep_node_index, n),\n+            NodeForeignItem(n) => EntryForeignItem(parent, dep_node_index, n),\n+            NodeTraitItem(n) => EntryTraitItem(parent, dep_node_index, n),\n+            NodeImplItem(n) => EntryImplItem(parent, dep_node_index, n),\n+            NodeVariant(n) => EntryVariant(parent, dep_node_index, n),\n+            NodeField(n) => EntryField(parent, dep_node_index, n),\n+            NodeExpr(n) => EntryExpr(parent, dep_node_index, n),\n+            NodeStmt(n) => EntryStmt(parent, dep_node_index, n),\n+            NodeTy(n) => EntryTy(parent, dep_node_index, n),\n+            NodeTraitRef(n) => EntryTraitRef(parent, dep_node_index, n),\n+            NodeBinding(n) => EntryBinding(parent, dep_node_index, n),\n+            NodePat(n) => EntryPat(parent, dep_node_index, n),\n+            NodeBlock(n) => EntryBlock(parent, dep_node_index, n),\n+            NodeStructCtor(n) => EntryStructCtor(parent, dep_node_index, n),\n+            NodeLifetime(n) => EntryLifetime(parent, dep_node_index, n),\n+            NodeTyParam(n) => EntryTyParam(parent, dep_node_index, n),\n+            NodeVisibility(n) => EntryVisibility(parent, dep_node_index, n),\n+            NodeLocal(n) => EntryLocal(parent, dep_node_index, n),\n+        };\n+\n+        // Make sure that the DepNode of some node coincides with the HirId\n+        // owner of that node.\n+        if cfg!(debug_assertions) {\n+            let hir_id_owner = self.definitions.node_to_hir_id(id).owner;\n+\n+            if hir_id_owner != self.current_dep_node_owner {\n+                let node_str = match self.definitions.opt_def_index(id) {\n+                    Some(def_index) => {\n+                        self.definitions.def_path(def_index).to_string_no_crate()\n+                    }\n+                    None => format!(\"{:?}\", node)\n+                };\n+\n+                bug!(\"inconsistent DepNode for `{}`: \\\n+                      current_dep_node_owner={}, hir_id.owner={}\",\n+                    node_str,\n+                    self.definitions\n+                        .def_path(self.current_dep_node_owner)\n+                        .to_string_no_crate(),\n+                    self.definitions.def_path(hir_id_owner).to_string_no_crate())\n+            }\n+        }\n+\n         self.insert_entry(id, entry);\n+\n     }\n \n     fn with_parent<F: FnOnce(&mut Self)>(&mut self, parent_id: NodeId, f: F) {\n@@ -57,9 +126,27 @@ impl<'hir> NodeCollector<'hir> {\n         f(self);\n         self.parent_node = parent_node;\n     }\n+\n+    fn with_dep_node_owner<F: FnOnce(&mut Self)>(&mut self,\n+                                                 dep_node_owner: DefIndex,\n+                                                 f: F) {\n+        let prev_owner = self.current_dep_node_owner;\n+        let prev_index = self.current_dep_node_index;\n+\n+        // When we enter a new owner (item, impl item, or trait item), we always\n+        // start out again with DepKind::Hir.\n+        let new_dep_node = self.definitions\n+                               .def_path_hash(dep_node_owner)\n+                               .to_dep_node(DepKind::Hir);\n+        self.current_dep_node_index = self.dep_graph.alloc_input_node(new_dep_node);\n+        self.current_dep_node_owner = dep_node_owner;\n+        f(self);\n+        self.current_dep_node_index = prev_index;\n+        self.current_dep_node_owner = prev_owner;\n+    }\n }\n \n-impl<'hir> Visitor<'hir> for NodeCollector<'hir> {\n+impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n     /// Because we want to track parent items and so forth, enable\n     /// deep walking so that we walk nested items in the context of\n     /// their outer items.\n@@ -82,25 +169,37 @@ impl<'hir> Visitor<'hir> for NodeCollector<'hir> {\n     }\n \n     fn visit_nested_body(&mut self, id: BodyId) {\n+        // When we enter a body, we switch to DepKind::HirBody.\n+        // Note that current_dep_node_index might already be DepKind::HirBody,\n+        // e.g. when entering the body of a closure that is already part of a\n+        // surrounding body. That's expected and not a problem.\n+        let prev_index = self.current_dep_node_index;\n+        let new_dep_node = self.definitions\n+                               .def_path_hash(self.current_dep_node_owner)\n+                               .to_dep_node(DepKind::HirBody);\n+        self.current_dep_node_index = self.dep_graph.alloc_input_node(new_dep_node);\n         self.visit_body(self.krate.body(id));\n+        self.current_dep_node_index = prev_index;\n     }\n \n     fn visit_item(&mut self, i: &'hir Item) {\n         debug!(\"visit_item: {:?}\", i);\n-\n-        self.insert(i.id, NodeItem(i));\n-\n-        self.with_parent(i.id, |this| {\n-            match i.node {\n-                ItemStruct(ref struct_def, _) => {\n-                    // If this is a tuple-like struct, register the constructor.\n-                    if !struct_def.is_struct() {\n-                        this.insert(struct_def.id(), NodeStructCtor(struct_def));\n+        debug_assert_eq!(i.hir_id.owner,\n+                         self.definitions.opt_def_index(i.id).unwrap());\n+        self.with_dep_node_owner(i.hir_id.owner, |this| {\n+            this.insert(i.id, NodeItem(i));\n+            this.with_parent(i.id, |this| {\n+                match i.node {\n+                    ItemStruct(ref struct_def, _) => {\n+                        // If this is a tuple-like struct, register the constructor.\n+                        if !struct_def.is_struct() {\n+                            this.insert(struct_def.id(), NodeStructCtor(struct_def));\n+                        }\n                     }\n+                    _ => {}\n                 }\n-                _ => {}\n-            }\n-            intravisit::walk_item(this, i);\n+                intravisit::walk_item(this, i);\n+            });\n         });\n     }\n \n@@ -121,18 +220,26 @@ impl<'hir> Visitor<'hir> for NodeCollector<'hir> {\n     }\n \n     fn visit_trait_item(&mut self, ti: &'hir TraitItem) {\n-        self.insert(ti.id, NodeTraitItem(ti));\n-\n-        self.with_parent(ti.id, |this| {\n-            intravisit::walk_trait_item(this, ti);\n+        debug_assert_eq!(ti.hir_id.owner,\n+                         self.definitions.opt_def_index(ti.id).unwrap());\n+        self.with_dep_node_owner(ti.hir_id.owner, |this| {\n+            this.insert(ti.id, NodeTraitItem(ti));\n+\n+            this.with_parent(ti.id, |this| {\n+                intravisit::walk_trait_item(this, ti);\n+            });\n         });\n     }\n \n     fn visit_impl_item(&mut self, ii: &'hir ImplItem) {\n-        self.insert(ii.id, NodeImplItem(ii));\n-\n-        self.with_parent(ii.id, |this| {\n-            intravisit::walk_impl_item(this, ii);\n+        debug_assert_eq!(ii.hir_id.owner,\n+                         self.definitions.opt_def_index(ii.id).unwrap());\n+        self.with_dep_node_owner(ii.hir_id.owner, |this| {\n+            this.insert(ii.id, NodeImplItem(ii));\n+\n+            this.with_parent(ii.id, |this| {\n+                intravisit::walk_impl_item(this, ii);\n+            });\n         });\n     }\n \n@@ -238,4 +345,33 @@ impl<'hir> Visitor<'hir> for NodeCollector<'hir> {\n             intravisit::walk_struct_field(this, field);\n         });\n     }\n+\n+    fn visit_trait_item_ref(&mut self, ii: &'hir TraitItemRef) {\n+        // Do not visit the duplicate information in TraitItemRef. We want to\n+        // map the actual nodes, not the duplicate ones in the *Ref.\n+        let TraitItemRef {\n+            id,\n+            name: _,\n+            kind: _,\n+            span: _,\n+            defaultness: _,\n+        } = *ii;\n+\n+        self.visit_nested_trait_item(id);\n+    }\n+\n+    fn visit_impl_item_ref(&mut self, ii: &'hir ImplItemRef) {\n+        // Do not visit the duplicate information in ImplItemRef. We want to\n+        // map the actual nodes, not the duplicate ones in the *Ref.\n+        let ImplItemRef {\n+            id,\n+            name: _,\n+            kind: _,\n+            span: _,\n+            vis: _,\n+            defaultness: _,\n+        } = *ii;\n+\n+        self.visit_nested_impl_item(id);\n+    }\n }"}, {"sha": "b4e00455a743b7f0a3b0fa007f9f7f7b82cc8187", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 132, "deletions": 193, "changes": 325, "blob_url": "https://github.com/rust-lang/rust/blob/c872f4727697327550d43d106f5dddd735c41e5f/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c872f4727697327550d43d106f5dddd735c41e5f/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=c872f4727697327550d43d106f5dddd735c41e5f", "patch": "@@ -15,7 +15,7 @@ pub use self::def_collector::{DefCollector, MacroInvocationData};\n pub use self::definitions::{Definitions, DefKey, DefPath, DefPathData,\n                             DisambiguatedDefPathData, DefPathHash};\n \n-use dep_graph::{DepGraph, DepNode, DepKind};\n+use dep_graph::{DepGraph, DepNode, DepKind, DepNodeIndex};\n \n use hir::def_id::{CRATE_DEF_INDEX, DefId, DefIndexAddressSpace};\n \n@@ -74,27 +74,28 @@ enum MapEntry<'hir> {\n     NotPresent,\n \n     /// All the node types, with a parent ID.\n-    EntryItem(NodeId, &'hir Item),\n-    EntryForeignItem(NodeId, &'hir ForeignItem),\n-    EntryTraitItem(NodeId, &'hir TraitItem),\n-    EntryImplItem(NodeId, &'hir ImplItem),\n-    EntryVariant(NodeId, &'hir Variant),\n-    EntryField(NodeId, &'hir StructField),\n-    EntryExpr(NodeId, &'hir Expr),\n-    EntryStmt(NodeId, &'hir Stmt),\n-    EntryTy(NodeId, &'hir Ty),\n-    EntryTraitRef(NodeId, &'hir TraitRef),\n-    EntryBinding(NodeId, &'hir Pat),\n-    EntryPat(NodeId, &'hir Pat),\n-    EntryBlock(NodeId, &'hir Block),\n-    EntryStructCtor(NodeId, &'hir VariantData),\n-    EntryLifetime(NodeId, &'hir Lifetime),\n-    EntryTyParam(NodeId, &'hir TyParam),\n-    EntryVisibility(NodeId, &'hir Visibility),\n-    EntryLocal(NodeId, &'hir Local),\n-\n-    /// Roots for node trees.\n-    RootCrate,\n+    EntryItem(NodeId, DepNodeIndex, &'hir Item),\n+    EntryForeignItem(NodeId, DepNodeIndex, &'hir ForeignItem),\n+    EntryTraitItem(NodeId, DepNodeIndex, &'hir TraitItem),\n+    EntryImplItem(NodeId, DepNodeIndex, &'hir ImplItem),\n+    EntryVariant(NodeId, DepNodeIndex, &'hir Variant),\n+    EntryField(NodeId, DepNodeIndex, &'hir StructField),\n+    EntryExpr(NodeId, DepNodeIndex, &'hir Expr),\n+    EntryStmt(NodeId, DepNodeIndex, &'hir Stmt),\n+    EntryTy(NodeId, DepNodeIndex, &'hir Ty),\n+    EntryTraitRef(NodeId, DepNodeIndex, &'hir TraitRef),\n+    EntryBinding(NodeId, DepNodeIndex, &'hir Pat),\n+    EntryPat(NodeId, DepNodeIndex, &'hir Pat),\n+    EntryBlock(NodeId, DepNodeIndex, &'hir Block),\n+    EntryStructCtor(NodeId, DepNodeIndex, &'hir VariantData),\n+    EntryLifetime(NodeId, DepNodeIndex, &'hir Lifetime),\n+    EntryTyParam(NodeId, DepNodeIndex, &'hir TyParam),\n+    EntryVisibility(NodeId, DepNodeIndex, &'hir Visibility),\n+    EntryLocal(NodeId, DepNodeIndex, &'hir Local),\n+\n+    /// Roots for node trees. The DepNodeIndex is the dependency node of the\n+    /// crate's root module.\n+    RootCrate(DepNodeIndex),\n }\n \n impl<'hir> Clone for MapEntry<'hir> {\n@@ -104,75 +105,52 @@ impl<'hir> Clone for MapEntry<'hir> {\n }\n \n impl<'hir> MapEntry<'hir> {\n-    fn from_node(p: NodeId, node: Node<'hir>) -> MapEntry<'hir> {\n-        match node {\n-            NodeItem(n) => EntryItem(p, n),\n-            NodeForeignItem(n) => EntryForeignItem(p, n),\n-            NodeTraitItem(n) => EntryTraitItem(p, n),\n-            NodeImplItem(n) => EntryImplItem(p, n),\n-            NodeVariant(n) => EntryVariant(p, n),\n-            NodeField(n) => EntryField(p, n),\n-            NodeExpr(n) => EntryExpr(p, n),\n-            NodeStmt(n) => EntryStmt(p, n),\n-            NodeTy(n) => EntryTy(p, n),\n-            NodeTraitRef(n) => EntryTraitRef(p, n),\n-            NodeBinding(n) => EntryBinding(p, n),\n-            NodePat(n) => EntryPat(p, n),\n-            NodeBlock(n) => EntryBlock(p, n),\n-            NodeStructCtor(n) => EntryStructCtor(p, n),\n-            NodeLifetime(n) => EntryLifetime(p, n),\n-            NodeTyParam(n) => EntryTyParam(p, n),\n-            NodeVisibility(n) => EntryVisibility(p, n),\n-            NodeLocal(n) => EntryLocal(p, n),\n-        }\n-    }\n-\n     fn parent_node(self) -> Option<NodeId> {\n         Some(match self {\n-            EntryItem(id, _) => id,\n-            EntryForeignItem(id, _) => id,\n-            EntryTraitItem(id, _) => id,\n-            EntryImplItem(id, _) => id,\n-            EntryVariant(id, _) => id,\n-            EntryField(id, _) => id,\n-            EntryExpr(id, _) => id,\n-            EntryStmt(id, _) => id,\n-            EntryTy(id, _) => id,\n-            EntryTraitRef(id, _) => id,\n-            EntryBinding(id, _) => id,\n-            EntryPat(id, _) => id,\n-            EntryBlock(id, _) => id,\n-            EntryStructCtor(id, _) => id,\n-            EntryLifetime(id, _) => id,\n-            EntryTyParam(id, _) => id,\n-            EntryVisibility(id, _) => id,\n-            EntryLocal(id, _) => id,\n+            EntryItem(id, _, _) => id,\n+            EntryForeignItem(id, _, _) => id,\n+            EntryTraitItem(id, _, _) => id,\n+            EntryImplItem(id, _, _) => id,\n+            EntryVariant(id, _, _) => id,\n+            EntryField(id, _, _) => id,\n+            EntryExpr(id, _, _) => id,\n+            EntryStmt(id, _, _) => id,\n+            EntryTy(id, _, _) => id,\n+            EntryTraitRef(id, _, _) => id,\n+            EntryBinding(id, _, _) => id,\n+            EntryPat(id, _, _) => id,\n+            EntryBlock(id, _, _) => id,\n+            EntryStructCtor(id, _, _) => id,\n+            EntryLifetime(id, _, _) => id,\n+            EntryTyParam(id, _, _) => id,\n+            EntryVisibility(id, _, _) => id,\n+            EntryLocal(id, _, _) => id,\n \n             NotPresent |\n-            RootCrate => return None,\n+            RootCrate(_) => return None,\n         })\n     }\n \n     fn to_node(self) -> Option<Node<'hir>> {\n         Some(match self {\n-            EntryItem(_, n) => NodeItem(n),\n-            EntryForeignItem(_, n) => NodeForeignItem(n),\n-            EntryTraitItem(_, n) => NodeTraitItem(n),\n-            EntryImplItem(_, n) => NodeImplItem(n),\n-            EntryVariant(_, n) => NodeVariant(n),\n-            EntryField(_, n) => NodeField(n),\n-            EntryExpr(_, n) => NodeExpr(n),\n-            EntryStmt(_, n) => NodeStmt(n),\n-            EntryTy(_, n) => NodeTy(n),\n-            EntryTraitRef(_, n) => NodeTraitRef(n),\n-            EntryBinding(_, n) => NodeBinding(n),\n-            EntryPat(_, n) => NodePat(n),\n-            EntryBlock(_, n) => NodeBlock(n),\n-            EntryStructCtor(_, n) => NodeStructCtor(n),\n-            EntryLifetime(_, n) => NodeLifetime(n),\n-            EntryTyParam(_, n) => NodeTyParam(n),\n-            EntryVisibility(_, n) => NodeVisibility(n),\n-            EntryLocal(_, n) => NodeLocal(n),\n+            EntryItem(_, _, n) => NodeItem(n),\n+            EntryForeignItem(_, _, n) => NodeForeignItem(n),\n+            EntryTraitItem(_, _, n) => NodeTraitItem(n),\n+            EntryImplItem(_, _, n) => NodeImplItem(n),\n+            EntryVariant(_, _, n) => NodeVariant(n),\n+            EntryField(_, _, n) => NodeField(n),\n+            EntryExpr(_, _, n) => NodeExpr(n),\n+            EntryStmt(_, _, n) => NodeStmt(n),\n+            EntryTy(_, _, n) => NodeTy(n),\n+            EntryTraitRef(_, _, n) => NodeTraitRef(n),\n+            EntryBinding(_, _, n) => NodeBinding(n),\n+            EntryPat(_, _, n) => NodePat(n),\n+            EntryBlock(_, _, n) => NodeBlock(n),\n+            EntryStructCtor(_, _, n) => NodeStructCtor(n),\n+            EntryLifetime(_, _, n) => NodeLifetime(n),\n+            EntryTyParam(_, _, n) => NodeTyParam(n),\n+            EntryVisibility(_, _, n) => NodeVisibility(n),\n+            EntryLocal(_, _, n) => NodeLocal(n),\n \n             NotPresent |\n             RootCrate => return None\n@@ -181,7 +159,7 @@ impl<'hir> MapEntry<'hir> {\n \n     fn associated_body(self) -> Option<BodyId> {\n         match self {\n-            EntryItem(_, item) => {\n+            EntryItem(_, _, item) => {\n                 match item.node {\n                     ItemConst(_, body) |\n                     ItemStatic(.., body) |\n@@ -190,23 +168,23 @@ impl<'hir> MapEntry<'hir> {\n                 }\n             }\n \n-            EntryTraitItem(_, item) => {\n+            EntryTraitItem(_, _, item) => {\n                 match item.node {\n                     TraitItemKind::Const(_, Some(body)) |\n                     TraitItemKind::Method(_, TraitMethod::Provided(body)) => Some(body),\n                     _ => None\n                 }\n             }\n \n-            EntryImplItem(_, item) => {\n+            EntryImplItem(_, _, item) => {\n                 match item.node {\n                     ImplItemKind::Const(_, body) |\n                     ImplItemKind::Method(_, body) => Some(body),\n                     _ => None,\n                 }\n             }\n \n-            EntryExpr(_, expr) => {\n+            EntryExpr(_, _, expr) => {\n                 match expr.node {\n                     ExprClosure(.., body, _, _) => Some(body),\n                     _ => None,\n@@ -284,83 +262,40 @@ impl<'hir> Map<'hir> {\n     /// read recorded). If the function just returns a DefId or\n     /// NodeId, no actual content was returned, so no read is needed.\n     pub fn read(&self, id: NodeId) {\n-        self.dep_graph.read(self.dep_node(id));\n-    }\n-\n-    fn dep_node(&self, id0: NodeId) -> DepNode {\n-        let mut id = id0;\n-        let mut last_expr = None;\n-        loop {\n-            let entry = self.map[id.as_usize()];\n-            match entry {\n-                EntryItem(..) |\n-                EntryTraitItem(..) |\n-                EntryImplItem(..) => {\n-                    let def_index = self.definitions.opt_def_index(id).unwrap();\n+        let entry = self.map[id.as_usize()];\n+        match entry {\n+            EntryItem(_, dep_node_index, _) |\n+            EntryTraitItem(_, dep_node_index, _) |\n+            EntryImplItem(_, dep_node_index, _) |\n+            EntryVariant(_, dep_node_index, _) |\n+            EntryForeignItem(_, dep_node_index, _) |\n+            EntryField(_, dep_node_index, _) |\n+            EntryStmt(_, dep_node_index, _) |\n+            EntryTy(_, dep_node_index, _) |\n+            EntryTraitRef(_, dep_node_index, _) |\n+            EntryBinding(_, dep_node_index, _) |\n+            EntryPat(_, dep_node_index, _) |\n+            EntryBlock(_, dep_node_index, _) |\n+            EntryStructCtor(_, dep_node_index, _) |\n+            EntryLifetime(_, dep_node_index, _) |\n+            EntryTyParam(_, dep_node_index, _) |\n+            EntryVisibility(_, dep_node_index, _) |\n+            EntryExpr(_, dep_node_index, _) |\n+            EntryLocal(_, dep_node_index, _) |\n+            RootCrate(dep_node_index) => {\n+                self.dep_graph.read_index(dep_node_index);\n+            }\n+            NotPresent => {\n+                // Some nodes, notably macro definitions, are not\n+                // present in the map for whatever reason, but\n+                // they *do* have def-ids. So if we encounter an\n+                // empty hole, check for that case.\n+                if let Some(def_index) = self.definitions.opt_def_index(id) {\n                     let def_path_hash = self.definitions.def_path_hash(def_index);\n-\n-                    if let Some(last_id) = last_expr {\n-                        // The body may have a separate dep node\n-                        if entry.is_body_owner(last_id) {\n-                            return def_path_hash.to_dep_node(DepKind::HirBody);\n-                        }\n-                    }\n-                    return def_path_hash.to_dep_node(DepKind::Hir);\n-                }\n-\n-                EntryVariant(p, v) => {\n-                    id = p;\n-\n-                    if last_expr.is_some() {\n-                        if v.node.disr_expr.map(|e| e.node_id) == last_expr {\n-                            // The enum parent holds both Hir and HirBody nodes.\n-                            let def_index = self.definitions.opt_def_index(id).unwrap();\n-                            let def_path_hash = self.definitions.def_path_hash(def_index);\n-                            return def_path_hash.to_dep_node(DepKind::HirBody);\n-                        }\n-                    }\n-                }\n-\n-                EntryForeignItem(p, _) |\n-                EntryField(p, _) |\n-                EntryStmt(p, _) |\n-                EntryTy(p, _) |\n-                EntryTraitRef(p, _) |\n-                EntryBinding(p, _) |\n-                EntryPat(p, _) |\n-                EntryBlock(p, _) |\n-                EntryStructCtor(p, _) |\n-                EntryLifetime(p, _) |\n-                EntryTyParam(p, _) |\n-                EntryVisibility(p, _) |\n-                EntryLocal(p, _) =>\n-                    id = p,\n-\n-                EntryExpr(p, _) => {\n-                    last_expr = Some(id);\n-                    id = p;\n-                }\n-\n-                RootCrate => {\n-                    let def_path_hash = self.definitions.def_path_hash(CRATE_DEF_INDEX);\n-                    return def_path_hash.to_dep_node(DepKind::Hir);\n+                    self.dep_graph.read(def_path_hash.to_dep_node(DepKind::Hir));\n+                } else {\n+                    bug!(\"called HirMap::read() with invalid NodeId\")\n                 }\n-\n-                NotPresent =>\n-                    // Some nodes, notably macro definitions, are not\n-                    // present in the map for whatever reason, but\n-                    // they *do* have def-ids. So if we encounter an\n-                    // empty hole, check for that case.\n-                    return self.definitions.opt_def_index(id)\n-                               .map(|def_index| {\n-                                    let def_path_hash = self.definitions.def_path_hash(def_index);\n-                                    def_path_hash.to_dep_node(DepKind::Hir)\n-                                })\n-                               .unwrap_or_else(|| {\n-                                   bug!(\"Walking parents from `{}` \\\n-                                         led to `NotPresent` at `{}`\",\n-                                        id0, id)\n-                               }),\n             }\n         }\n     }\n@@ -483,7 +418,7 @@ impl<'hir> Map<'hir> {\n                 Some(body_id)\n             } else {\n                 // For some expressions, the expression is its own body.\n-                if let EntryExpr(_, expr) = entry {\n+                if let EntryExpr(_, _, expr) = entry {\n                     Some(BodyId { node_id: expr.id })\n                 } else {\n                     None\n@@ -762,7 +697,7 @@ impl<'hir> Map<'hir> {\n     pub fn get_foreign_abi(&self, id: NodeId) -> Abi {\n         let parent = self.get_parent(id);\n         let abi = match self.find_entry(parent) {\n-            Some(EntryItem(_, i)) => {\n+            Some(EntryItem(_, _, i)) => {\n                 match i.node {\n                     ItemForeignMod(ref nm) => Some(nm.abi),\n                     _ => None\n@@ -913,27 +848,27 @@ impl<'hir> Map<'hir> {\n     pub fn span(&self, id: NodeId) -> Span {\n         self.read(id); // reveals span from node\n         match self.find_entry(id) {\n-            Some(EntryItem(_, item)) => item.span,\n-            Some(EntryForeignItem(_, foreign_item)) => foreign_item.span,\n-            Some(EntryTraitItem(_, trait_method)) => trait_method.span,\n-            Some(EntryImplItem(_, impl_item)) => impl_item.span,\n-            Some(EntryVariant(_, variant)) => variant.span,\n-            Some(EntryField(_, field)) => field.span,\n-            Some(EntryExpr(_, expr)) => expr.span,\n-            Some(EntryStmt(_, stmt)) => stmt.span,\n-            Some(EntryTy(_, ty)) => ty.span,\n-            Some(EntryTraitRef(_, tr)) => tr.path.span,\n-            Some(EntryBinding(_, pat)) => pat.span,\n-            Some(EntryPat(_, pat)) => pat.span,\n-            Some(EntryBlock(_, block)) => block.span,\n-            Some(EntryStructCtor(_, _)) => self.expect_item(self.get_parent(id)).span,\n-            Some(EntryLifetime(_, lifetime)) => lifetime.span,\n-            Some(EntryTyParam(_, ty_param)) => ty_param.span,\n-            Some(EntryVisibility(_, &Visibility::Restricted { ref path, .. })) => path.span,\n-            Some(EntryVisibility(_, v)) => bug!(\"unexpected Visibility {:?}\", v),\n-            Some(EntryLocal(_, local)) => local.span,\n-\n-            Some(RootCrate) => self.forest.krate.span,\n+            Some(EntryItem(_, _, item)) => item.span,\n+            Some(EntryForeignItem(_, _, foreign_item)) => foreign_item.span,\n+            Some(EntryTraitItem(_, _, trait_method)) => trait_method.span,\n+            Some(EntryImplItem(_, _, impl_item)) => impl_item.span,\n+            Some(EntryVariant(_, _, variant)) => variant.span,\n+            Some(EntryField(_, _, field)) => field.span,\n+            Some(EntryExpr(_, _, expr)) => expr.span,\n+            Some(EntryStmt(_, _, stmt)) => stmt.span,\n+            Some(EntryTy(_, _, ty)) => ty.span,\n+            Some(EntryTraitRef(_, _, tr)) => tr.path.span,\n+            Some(EntryBinding(_, _, pat)) => pat.span,\n+            Some(EntryPat(_, _, pat)) => pat.span,\n+            Some(EntryBlock(_, _, block)) => block.span,\n+            Some(EntryStructCtor(_, _, _)) => self.expect_item(self.get_parent(id)).span,\n+            Some(EntryLifetime(_, _, lifetime)) => lifetime.span,\n+            Some(EntryTyParam(_, _, ty_param)) => ty_param.span,\n+            Some(EntryVisibility(_, _, &Visibility::Restricted { ref path, .. })) => path.span,\n+            Some(EntryVisibility(_, _, v)) => bug!(\"unexpected Visibility {:?}\", v),\n+            Some(EntryLocal(_, _, local)) => local.span,\n+\n+            Some(RootCrate(_)) => self.forest.krate.span,\n             Some(NotPresent) | None => {\n                 bug!(\"hir::map::Map::span: id not in map: {:?}\", id)\n             }\n@@ -1031,12 +966,12 @@ impl<'a, 'hir> Iterator for NodesMatchingSuffix<'a, 'hir> {\n             }\n             self.idx = NodeId::from_u32(self.idx.as_u32() + 1);\n             let name = match self.map.find_entry(idx) {\n-                Some(EntryItem(_, n))       => n.name(),\n-                Some(EntryForeignItem(_, n))=> n.name(),\n-                Some(EntryTraitItem(_, n))  => n.name(),\n-                Some(EntryImplItem(_, n))   => n.name(),\n-                Some(EntryVariant(_, n))    => n.name(),\n-                Some(EntryField(_, n))      => n.name(),\n+                Some(EntryItem(_, _, n))       => n.name(),\n+                Some(EntryForeignItem(_, _, n))=> n.name(),\n+                Some(EntryTraitItem(_, _, n))  => n.name(),\n+                Some(EntryImplItem(_, _, n))   => n.name(),\n+                Some(EntryVariant(_, _, n))    => n.name(),\n+                Some(EntryField(_, _, n))      => n.name(),\n                 _ => continue,\n             };\n             if self.matches_names(self.map.get_parent(idx), name) {\n@@ -1062,9 +997,13 @@ impl Named for ImplItem { fn name(&self) -> Name { self.name } }\n pub fn map_crate<'hir>(forest: &'hir mut Forest,\n                        definitions: Definitions)\n                        -> Map<'hir> {\n-    let mut collector = NodeCollector::root(&forest.krate);\n-    intravisit::walk_crate(&mut collector, &forest.krate);\n-    let map = collector.map;\n+    let map = {\n+        let mut collector = NodeCollector::root(&forest.krate,\n+                                                &forest.dep_graph,\n+                                                &definitions);\n+        intravisit::walk_crate(&mut collector, &forest.krate);\n+        collector.into_map()\n+    };\n \n     if log_enabled!(::log::LogLevel::Debug) {\n         // This only makes sense for ordered stores; note the"}, {"sha": "46b8cb0a2e2c80b5638d21b9a81305dd5f06bcc5", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 29, "deletions": 71, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/c872f4727697327550d43d106f5dddd735c41e5f/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c872f4727697327550d43d106f5dddd735c41e5f/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=c872f4727697327550d43d106f5dddd735c41e5f", "patch": "@@ -26,7 +26,6 @@ pub use self::TyParamBound::*;\n pub use self::UnOp::*;\n pub use self::UnsafeSource::*;\n pub use self::Visibility::{Public, Inherited};\n-pub use self::PathParameters::*;\n \n use hir::def::Def;\n use hir::def_id::{DefId, DefIndex, CRATE_DEF_INDEX};\n@@ -227,65 +226,7 @@ impl PathSegment {\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n-pub enum PathParameters {\n-    /// The `<'a, A,B,C>` in `foo::bar::baz::<'a, A,B,C>`\n-    AngleBracketedParameters(AngleBracketedParameterData),\n-    /// The `(A,B)` and `C` in `Foo(A,B) -> C`\n-    ParenthesizedParameters(ParenthesizedParameterData),\n-}\n-\n-impl PathParameters {\n-    pub fn none() -> PathParameters {\n-        AngleBracketedParameters(AngleBracketedParameterData {\n-            lifetimes: HirVec::new(),\n-            types: HirVec::new(),\n-            infer_types: true,\n-            bindings: HirVec::new(),\n-        })\n-    }\n-\n-    /// Returns the types that the user wrote. Note that these do not necessarily map to the type\n-    /// parameters in the parenthesized case.\n-    pub fn types(&self) -> HirVec<&P<Ty>> {\n-        match *self {\n-            AngleBracketedParameters(ref data) => {\n-                data.types.iter().collect()\n-            }\n-            ParenthesizedParameters(ref data) => {\n-                data.inputs\n-                    .iter()\n-                    .chain(data.output.iter())\n-                    .collect()\n-            }\n-        }\n-    }\n-\n-    pub fn lifetimes(&self) -> HirVec<&Lifetime> {\n-        match *self {\n-            AngleBracketedParameters(ref data) => {\n-                data.lifetimes.iter().collect()\n-            }\n-            ParenthesizedParameters(_) => {\n-                HirVec::new()\n-            }\n-        }\n-    }\n-\n-    pub fn bindings(&self) -> HirVec<&TypeBinding> {\n-        match *self {\n-            AngleBracketedParameters(ref data) => {\n-                data.bindings.iter().collect()\n-            }\n-            ParenthesizedParameters(_) => {\n-                HirVec::new()\n-            }\n-        }\n-    }\n-}\n-\n-/// A path like `Foo<'a, T>`\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n-pub struct AngleBracketedParameterData {\n+pub struct PathParameters {\n     /// The lifetime parameters for this path segment.\n     pub lifetimes: HirVec<Lifetime>,\n     /// The type parameters for this path segment, if present.\n@@ -298,19 +239,33 @@ pub struct AngleBracketedParameterData {\n     /// Bindings (equality constraints) on associated types, if present.\n     /// E.g., `Foo<A=Bar>`.\n     pub bindings: HirVec<TypeBinding>,\n+    /// Were parameters written in parenthesized form `Fn(T) -> U`?\n+    /// This is required mostly for pretty-printing and diagnostics,\n+    /// but also for changing lifetime elision rules to be \"function-like\".\n+    pub parenthesized: bool,\n }\n \n-/// A path like `Foo(A,B) -> C`\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n-pub struct ParenthesizedParameterData {\n-    /// Overall span\n-    pub span: Span,\n-\n-    /// `(A,B)`\n-    pub inputs: HirVec<P<Ty>>,\n+impl PathParameters {\n+    pub fn none() -> Self {\n+        Self {\n+            lifetimes: HirVec::new(),\n+            types: HirVec::new(),\n+            infer_types: true,\n+            bindings: HirVec::new(),\n+            parenthesized: false,\n+        }\n+    }\n \n-    /// `C`\n-    pub output: Option<P<Ty>>,\n+    pub fn inputs(&self) -> &[P<Ty>] {\n+        if self.parenthesized {\n+            if let Some(ref ty) = self.types.get(0) {\n+                if let TyTup(ref tys) = ty.node {\n+                    return tys;\n+                }\n+            }\n+        }\n+        bug!(\"PathParameters::inputs: not a `Fn(T) -> U`\");\n+    }\n }\n \n /// The AST represents all type param bounds as types.\n@@ -1272,6 +1227,7 @@ pub struct TraitItemId {\n pub struct TraitItem {\n     pub id: NodeId,\n     pub name: Name,\n+    pub hir_id: HirId,\n     pub attrs: HirVec<Attribute>,\n     pub node: TraitItemKind,\n     pub span: Span,\n@@ -1313,6 +1269,7 @@ pub struct ImplItemId {\n pub struct ImplItem {\n     pub id: NodeId,\n     pub name: Name,\n+    pub hir_id: HirId,\n     pub vis: Visibility,\n     pub defaultness: Defaultness,\n     pub attrs: HirVec<Attribute>,\n@@ -1719,8 +1676,9 @@ pub struct ItemId {\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct Item {\n     pub name: Name,\n-    pub attrs: HirVec<Attribute>,\n     pub id: NodeId,\n+    pub hir_id: HirId,\n+    pub attrs: HirVec<Attribute>,\n     pub node: Item_,\n     pub vis: Visibility,\n     pub span: Span,"}, {"sha": "80269592bb78e676cf08a54ffb2e5ba0204335b3", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 42, "deletions": 48, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/c872f4727697327550d43d106f5dddd735c41e5f/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c872f4727697327550d43d106f5dddd735c41e5f/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=c872f4727697327550d43d106f5dddd735c41e5f", "patch": "@@ -1194,9 +1194,9 @@ impl<'a> State<'a> {\n         self.print_expr(&args[0])?;\n         self.s.word(\".\")?;\n         self.print_name(segment.name)?;\n-        if !segment.parameters.lifetimes().is_empty() ||\n-                !segment.parameters.types().is_empty() ||\n-                !segment.parameters.bindings().is_empty() {\n+        if !segment.parameters.lifetimes.is_empty() ||\n+                !segment.parameters.types.is_empty() ||\n+                !segment.parameters.bindings.is_empty() {\n             self.print_path_parameters(&segment.parameters, true)?;\n         }\n         self.print_call_post(base_args)\n@@ -1585,61 +1585,55 @@ impl<'a> State<'a> {\n                              parameters: &hir::PathParameters,\n                              colons_before_params: bool)\n                              -> io::Result<()> {\n-        match *parameters {\n-            hir::AngleBracketedParameters(ref data) => {\n-                let start = if colons_before_params { \"::<\" } else { \"<\" };\n-                let empty = Cell::new(true);\n-                let start_or_comma = |this: &mut Self| {\n-                    if empty.get() {\n-                        empty.set(false);\n-                        this.s.word(start)\n-                    } else {\n-                        this.word_space(\",\")\n-                    }\n-                };\n+        if parameters.parenthesized {\n+            self.s.word(\"(\")?;\n+            self.commasep(Inconsistent, parameters.inputs(), |s, ty| s.print_type(&ty))?;\n+            self.s.word(\")\")?;\n \n-                if !data.lifetimes.iter().all(|lt| lt.is_elided()) {\n-                    for lifetime in &data.lifetimes {\n-                        start_or_comma(self)?;\n-                        self.print_lifetime(lifetime)?;\n-                    }\n-                }\n-\n-                if !data.types.is_empty() {\n-                    start_or_comma(self)?;\n-                    self.commasep(Inconsistent, &data.types, |s, ty| s.print_type(&ty))?;\n+            self.space_if_not_bol()?;\n+            self.word_space(\"->\")?;\n+            self.print_type(&parameters.bindings[0].ty)?;\n+        } else {\n+            let start = if colons_before_params { \"::<\" } else { \"<\" };\n+            let empty = Cell::new(true);\n+            let start_or_comma = |this: &mut Self| {\n+                if empty.get() {\n+                    empty.set(false);\n+                    this.s.word(start)\n+                } else {\n+                    this.word_space(\",\")\n                 }\n+            };\n \n-                // FIXME(eddyb) This would leak into error messages, e.g.:\n-                // \"non-exhaustive patterns: `Some::<..>(_)` not covered\".\n-                if data.infer_types && false {\n+            if !parameters.lifetimes.iter().all(|lt| lt.is_elided()) {\n+                for lifetime in &parameters.lifetimes {\n                     start_or_comma(self)?;\n-                    self.s.word(\"..\")?;\n+                    self.print_lifetime(lifetime)?;\n                 }\n+            }\n \n-                for binding in data.bindings.iter() {\n-                    start_or_comma(self)?;\n-                    self.print_name(binding.name)?;\n-                    self.s.space()?;\n-                    self.word_space(\"=\")?;\n-                    self.print_type(&binding.ty)?;\n-                }\n+            if !parameters.types.is_empty() {\n+                start_or_comma(self)?;\n+                self.commasep(Inconsistent, &parameters.types, |s, ty| s.print_type(&ty))?;\n+            }\n \n-                if !empty.get() {\n-                    self.s.word(\">\")?\n-                }\n+            // FIXME(eddyb) This would leak into error messages, e.g.:\n+            // \"non-exhaustive patterns: `Some::<..>(_)` not covered\".\n+            if parameters.infer_types && false {\n+                start_or_comma(self)?;\n+                self.s.word(\"..\")?;\n             }\n \n-            hir::ParenthesizedParameters(ref data) => {\n-                self.s.word(\"(\")?;\n-                self.commasep(Inconsistent, &data.inputs, |s, ty| s.print_type(&ty))?;\n-                self.s.word(\")\")?;\n+            for binding in parameters.bindings.iter() {\n+                start_or_comma(self)?;\n+                self.print_name(binding.name)?;\n+                self.s.space()?;\n+                self.word_space(\"=\")?;\n+                self.print_type(&binding.ty)?;\n+            }\n \n-                if let Some(ref ty) = data.output {\n-                    self.space_if_not_bol()?;\n-                    self.word_space(\"->\")?;\n-                    self.print_type(&ty)?;\n-                }\n+            if !empty.get() {\n+                self.s.word(\">\")?\n             }\n         }\n "}, {"sha": "411f5e26e4d059e54c93c549c69112cc90154744", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 6, "deletions": 13, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c872f4727697327550d43d106f5dddd735c41e5f/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c872f4727697327550d43d106f5dddd735c41e5f/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=c872f4727697327550d43d106f5dddd735c41e5f", "patch": "@@ -133,22 +133,12 @@ impl_stable_hash_for!(struct hir::PathSegment {\n     parameters\n });\n \n-impl_stable_hash_for!(enum hir::PathParameters {\n-    AngleBracketedParameters(data),\n-    ParenthesizedParameters(data)\n-});\n-\n-impl_stable_hash_for!(struct hir::AngleBracketedParameterData {\n+impl_stable_hash_for!(struct hir::PathParameters {\n     lifetimes,\n     types,\n     infer_types,\n-    bindings\n-});\n-\n-impl_stable_hash_for!(struct hir::ParenthesizedParameterData {\n-    span,\n-    inputs,\n-    output\n+    bindings,\n+    parenthesized\n });\n \n impl_stable_hash_for!(enum hir::TyParamBound {\n@@ -743,6 +733,7 @@ impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::T\n                                           hasher: &mut StableHasher<W>) {\n         let hir::TraitItem {\n             id,\n+            hir_id: _,\n             name,\n             ref attrs,\n             ref node,\n@@ -776,6 +767,7 @@ impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::I\n                                           hasher: &mut StableHasher<W>) {\n         let hir::ImplItem {\n             id,\n+            hir_id: _,\n             name,\n             ref vis,\n             defaultness,\n@@ -932,6 +924,7 @@ impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::I\n             name,\n             ref attrs,\n             id,\n+            hir_id: _,\n             ref node,\n             ref vis,\n             span"}, {"sha": "a8e98e53db394960de8abd5537dfdae7fafb763d", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/c872f4727697327550d43d106f5dddd735c41e5f/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c872f4727697327550d43d106f5dddd735c41e5f/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=c872f4727697327550d43d106f5dddd735c41e5f", "patch": "@@ -915,18 +915,15 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                                 def: Def,\n                                 depth: usize,\n                                 params: &'tcx hir::PathParameters) {\n-        let data = match *params {\n-            hir::ParenthesizedParameters(ref data) => {\n-                self.visit_fn_like_elision(&data.inputs, data.output.as_ref());\n-                return;\n-            }\n-            hir::AngleBracketedParameters(ref data) => data\n-        };\n+        if params.parenthesized {\n+            self.visit_fn_like_elision(params.inputs(), Some(&params.bindings[0].ty));\n+            return;\n+        }\n \n-        if data.lifetimes.iter().all(|l| l.is_elided()) {\n-            self.resolve_elided_lifetimes(&data.lifetimes);\n+        if params.lifetimes.iter().all(|l| l.is_elided()) {\n+            self.resolve_elided_lifetimes(&params.lifetimes);\n         } else {\n-            for l in &data.lifetimes { self.visit_lifetime(l); }\n+            for l in &params.lifetimes { self.visit_lifetime(l); }\n         }\n \n         // Figure out if this is a type/trait segment,\n@@ -995,13 +992,13 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                             Some(Region::Static)\n                         }\n                     }\n-                    Set1::One(r) => r.subst(&data.lifetimes, map),\n+                    Set1::One(r) => r.subst(&params.lifetimes, map),\n                     Set1::Many => None\n                 }\n             }).collect()\n         });\n \n-        for (i, ty) in data.types.iter().enumerate() {\n+        for (i, ty) in params.types.iter().enumerate() {\n             if let Some(&lt) = object_lifetime_defaults.get(i) {\n                 let scope = Scope::ObjectLifetimeDefault {\n                     lifetime: lt,\n@@ -1013,7 +1010,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             }\n         }\n \n-        for b in &data.bindings { self.visit_assoc_type_binding(b); }\n+        for b in &params.bindings { self.visit_assoc_type_binding(b); }\n     }\n \n     fn visit_fn_like_elision(&mut self, inputs: &'tcx [P<hir::Ty>],"}, {"sha": "d2ed29a3a0ff636c3d778b9ed9c26e81e62c85f6", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c872f4727697327550d43d106f5dddd735c41e5f/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c872f4727697327550d43d106f5dddd735c41e5f/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=c872f4727697327550d43d106f5dddd735c41e5f", "patch": "@@ -123,7 +123,8 @@ impl<'a, 'tcx: 'a> Annotator<'a, 'tcx> {\n                    item_sp: Span, kind: AnnotationKind, visit_children: F)\n         where F: FnOnce(&mut Self)\n     {\n-        if self.index.staged_api[&LOCAL_CRATE] {\n+        if self.tcx.sess.features.borrow().staged_api {\n+            // This crate explicitly wants staged API.\n             debug!(\"annotate(id = {:?}, attrs = {:?})\", id, attrs);\n             if let Some(..) = attr::find_deprecation(self.tcx.sess.diagnostic(), attrs, item_sp) {\n                 self.tcx.sess.span_err(item_sp, \"`#[deprecated]` cannot be used in staged api, \\\n@@ -204,6 +205,15 @@ impl<'a, 'tcx: 'a> Annotator<'a, 'tcx> {\n                 }\n             }\n \n+            // Propagate unstability.  This can happen even for non-staged-api crates in case\n+            // -Zforce-unstable-if-unmarked is set.\n+            if let Some(stab) = self.parent_stab {\n+                if stab.level.is_unstable() {\n+                    let def_id = self.tcx.hir.local_def_id(id);\n+                    self.index.stab_map.insert(def_id, Some(stab));\n+                }\n+            }\n+\n             if let Some(depr) = attr::find_deprecation(self.tcx.sess.diagnostic(), attrs, item_sp) {\n                 if kind == AnnotationKind::Prohibited {\n                     self.tcx.sess.span_err(item_sp, \"This deprecation annotation is useless\");"}, {"sha": "99fe8e60ae52b139d049d47e6fc9ef21296b8d19", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c872f4727697327550d43d106f5dddd735c41e5f/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c872f4727697327550d43d106f5dddd735c41e5f/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=c872f4727697327550d43d106f5dddd735c41e5f", "patch": "@@ -995,6 +995,10 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n           \"dump the dependency graph to $RUST_DEP_GRAPH (default: /tmp/dep_graph.gv)\"),\n     query_dep_graph: bool = (false, parse_bool, [UNTRACKED],\n           \"enable queries of the dependency graph for regression testing\"),\n+    profile_queries: bool = (false, parse_bool, [UNTRACKED],\n+          \"trace and profile the queries of the incremental compilation framework\"),\n+    profile_queries_and_keys: bool = (false, parse_bool, [UNTRACKED],\n+          \"trace and profile the queries and keys of the incremental compilation framework\"),\n     no_analysis: bool = (false, parse_bool, [UNTRACKED],\n           \"parse and expand the source, but run no analysis\"),\n     extra_plugins: Vec<String> = (Vec::new(), parse_list, [TRACKED],"}, {"sha": "823a637c7e0d4272c70876efd577a26c0664efdd", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/c872f4727697327550d43d106f5dddd735c41e5f/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c872f4727697327550d43d106f5dddd735c41e5f/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=c872f4727697327550d43d106f5dddd735c41e5f", "patch": "@@ -389,6 +389,13 @@ impl Session {\n     }\n     pub fn verbose(&self) -> bool { self.opts.debugging_opts.verbose }\n     pub fn time_passes(&self) -> bool { self.opts.debugging_opts.time_passes }\n+    pub fn profile_queries(&self) -> bool {\n+        self.opts.debugging_opts.profile_queries ||\n+            self.opts.debugging_opts.profile_queries_and_keys\n+    }\n+    pub fn profile_queries_and_keys(&self) -> bool {\n+        self.opts.debugging_opts.profile_queries_and_keys\n+    }\n     pub fn count_llvm_insns(&self) -> bool {\n         self.opts.debugging_opts.count_llvm_insns\n     }\n@@ -429,6 +436,31 @@ impl Session {\n             .unwrap_or(self.opts.debug_assertions)\n     }\n \n+    pub fn crt_static(&self) -> bool {\n+        // If the target does not opt in to crt-static support, use its default.\n+        if self.target.target.options.crt_static_respected {\n+            self.crt_static_feature()\n+        } else {\n+            self.target.target.options.crt_static_default\n+        }\n+    }\n+\n+    pub fn crt_static_feature(&self) -> bool {\n+        let requested_features = self.opts.cg.target_feature.split(',');\n+        let found_negative = requested_features.clone().any(|r| r == \"-crt-static\");\n+        let found_positive = requested_features.clone().any(|r| r == \"+crt-static\");\n+\n+        // If the target we're compiling for requests a static crt by default,\n+        // then see if the `-crt-static` feature was passed to disable that.\n+        // Otherwise if we don't have a static crt by default then see if the\n+        // `+crt-static` feature was passed.\n+        if self.target.target.options.crt_static_default {\n+            !found_negative\n+        } else {\n+            found_positive\n+        }\n+    }\n+\n     pub fn must_not_eliminate_frame_pointers(&self) -> bool {\n         self.opts.debuginfo != DebugInfoLevel::NoDebugInfo ||\n         !self.target.target.options.eliminate_frame_pointer"}, {"sha": "c69ac71ec5568ca2500121d77ca721de615494e2", "filename": "src/librustc/ty/maps.rs", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/c872f4727697327550d43d106f5dddd735c41e5f/src%2Flibrustc%2Fty%2Fmaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c872f4727697327550d43d106f5dddd735c41e5f/src%2Flibrustc%2Fty%2Fmaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps.rs?ref=c872f4727697327550d43d106f5dddd735c41e5f", "patch": "@@ -28,6 +28,7 @@ use ty::steal::Steal;\n use ty::subst::Substs;\n use ty::fast_reject::SimplifiedType;\n use util::nodemap::{DefIdSet, NodeSet};\n+use util::common::{profq_msg, ProfileQueriesMsg};\n \n use rustc_data_structures::indexed_vec::IndexVec;\n use rustc_data_structures::fx::FxHashMap;\n@@ -513,6 +514,29 @@ impl<'tcx> QueryDescription for queries::lint_levels<'tcx> {\n     }\n }\n \n+// If enabled, send a message to the profile-queries thread\n+macro_rules! profq_msg {\n+    ($tcx:expr, $msg:expr) => {\n+        if cfg!(debug_assertions) {\n+            if  $tcx.sess.profile_queries() {\n+                profq_msg($msg)\n+            }\n+        }\n+    }\n+}\n+\n+// If enabled, format a key using its debug string, which can be\n+// expensive to compute (in terms of time).\n+macro_rules! profq_key {\n+    ($tcx:expr, $key:expr) => {\n+        if cfg!(debug_assertions) {\n+            if $tcx.sess.profile_queries_and_keys() {\n+                Some(format!(\"{:?}\", $key))\n+            } else { None }\n+        } else { None }\n+    }\n+}\n+\n macro_rules! define_maps {\n     (<$tcx:tt>\n      $($(#[$attr:meta])*\n@@ -539,6 +563,12 @@ macro_rules! define_maps {\n             $($(#[$attr])* $name($K)),*\n         }\n \n+        #[allow(bad_style)]\n+        #[derive(Clone, Debug, PartialEq, Eq)]\n+        pub enum QueryMsg {\n+            $($name(Option<String>)),*\n+        }\n+\n         impl<$tcx> Query<$tcx> {\n             pub fn describe(&self, tcx: TyCtxt) -> String {\n                 let (r, name) = match *self {\n@@ -588,10 +618,20 @@ macro_rules! define_maps {\n                        key,\n                        span);\n \n+                profq_msg!(tcx,\n+                    ProfileQueriesMsg::QueryBegin(\n+                        span.clone(),\n+                        QueryMsg::$name(profq_key!(tcx, key))\n+                    )\n+                );\n+\n                 if let Some(&(ref result, dep_node_index)) = tcx.maps.$name.borrow().map.get(&key) {\n                     tcx.dep_graph.read_index(dep_node_index);\n+                    profq_msg!(tcx, ProfileQueriesMsg::CacheHit);\n                     return Ok(f(result));\n                 }\n+                // else, we are going to run the provider:\n+                profq_msg!(tcx, ProfileQueriesMsg::ProviderBegin);\n \n                 // FIXME(eddyb) Get more valid Span's on queries.\n                 // def_span guard is necessary to prevent a recursive loop,\n@@ -619,6 +659,7 @@ macro_rules! define_maps {\n                         tcx.dep_graph.with_task(dep_node, tcx, key, run_provider)\n                     }\n                 })?;\n+                profq_msg!(tcx, ProfileQueriesMsg::ProviderEnd);\n \n                 tcx.dep_graph.read_index(dep_node_index);\n "}, {"sha": "3516f7dfb25b0e1e538b8d8a076dc9288ca67196", "filename": "src/librustc/ty/wf.rs", "status": "modified", "additions": 47, "deletions": 5, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/c872f4727697327550d43d106f5dddd735c41e5f/src%2Flibrustc%2Fty%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c872f4727697327550d43d106f5dddd735c41e5f/src%2Flibrustc%2Fty%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwf.rs?ref=c872f4727697327550d43d106f5dddd735c41e5f", "patch": "@@ -58,7 +58,7 @@ pub fn trait_obligations<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n                                          -> Vec<traits::PredicateObligation<'tcx>>\n {\n     let mut wf = WfPredicates { infcx, param_env, body_id, span, out: vec![] };\n-    wf.compute_trait_ref(trait_ref);\n+    wf.compute_trait_ref(trait_ref, Elaborate::All);\n     wf.normalize()\n }\n \n@@ -74,7 +74,7 @@ pub fn predicate_obligations<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n     // (*) ok to skip binders, because wf code is prepared for it\n     match *predicate {\n         ty::Predicate::Trait(ref t) => {\n-            wf.compute_trait_ref(&t.skip_binder().trait_ref); // (*)\n+            wf.compute_trait_ref(&t.skip_binder().trait_ref, Elaborate::None); // (*)\n         }\n         ty::Predicate::Equate(ref t) => {\n             wf.compute(t.skip_binder().0);\n@@ -114,6 +114,35 @@ struct WfPredicates<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     out: Vec<traits::PredicateObligation<'tcx>>,\n }\n \n+/// Controls whether we \"elaborate\" supertraits and so forth on the WF\n+/// predicates. This is a kind of hack to address #43784. The\n+/// underlying problem in that issue was a trait structure like:\n+///\n+/// ```\n+/// trait Foo: Copy { }\n+/// trait Bar: Foo { }\n+/// impl<T: Bar> Foo for T { }\n+/// impl<T> Bar for T { }\n+/// ```\n+///\n+/// Here, in the `Foo` impl, we will check that `T: Copy` holds -- but\n+/// we decide that this is true because `T: Bar` is in the\n+/// where-clauses (and we can elaborate that to include `T:\n+/// Copy`). This wouldn't be a problem, except that when we check the\n+/// `Bar` impl, we decide that `T: Foo` must hold because of the `Foo`\n+/// impl. And so nowhere did we check that `T: Copy` holds!\n+///\n+/// To resolve this, we elaborate the WF requirements that must be\n+/// proven when checking impls. This means that (e.g.) the `impl Bar\n+/// for T` will be forced to prove not only that `T: Foo` but also `T:\n+/// Copy` (which it won't be able to do, because there is no `Copy`\n+/// impl for `T`).\n+#[derive(Debug, PartialEq, Eq, Copy, Clone)]\n+enum Elaborate {\n+    All,\n+    None,\n+}\n+\n impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n     fn cause(&mut self, code: traits::ObligationCauseCode<'tcx>) -> traits::ObligationCause<'tcx> {\n         traits::ObligationCause::new(self.span, self.body_id, code)\n@@ -135,12 +164,25 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n \n     /// Pushes the obligations required for `trait_ref` to be WF into\n     /// `self.out`.\n-    fn compute_trait_ref(&mut self, trait_ref: &ty::TraitRef<'tcx>) {\n+    fn compute_trait_ref(&mut self, trait_ref: &ty::TraitRef<'tcx>, elaborate: Elaborate) {\n         let obligations = self.nominal_obligations(trait_ref.def_id, trait_ref.substs);\n-        self.out.extend(obligations);\n \n         let cause = self.cause(traits::MiscObligation);\n         let param_env = self.param_env;\n+\n+        if let Elaborate::All = elaborate {\n+            let predicates = obligations.iter()\n+                                        .map(|obligation| obligation.predicate.clone())\n+                                        .collect();\n+            let implied_obligations = traits::elaborate_predicates(self.infcx.tcx, predicates);\n+            let implied_obligations = implied_obligations.map(|pred| {\n+                traits::Obligation::new(cause.clone(), param_env, pred)\n+            });\n+            self.out.extend(implied_obligations);\n+        }\n+\n+        self.out.extend(obligations);\n+\n         self.out.extend(\n             trait_ref.substs.types()\n                             .filter(|ty| !ty.has_escaping_regions())\n@@ -156,7 +198,7 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n         // WF and (b) the trait-ref holds.  (It may also be\n         // normalizable and be WF that way.)\n         let trait_ref = data.trait_ref(self.infcx.tcx);\n-        self.compute_trait_ref(&trait_ref);\n+        self.compute_trait_ref(&trait_ref, Elaborate::None);\n \n         if !data.has_escaping_regions() {\n             let predicate = trait_ref.to_predicate();"}, {"sha": "618a4ed331e766056cf1a207a86cd5dca747902e", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/c872f4727697327550d43d106f5dddd735c41e5f/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c872f4727697327550d43d106f5dddd735c41e5f/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=c872f4727697327550d43d106f5dddd735c41e5f", "patch": "@@ -19,6 +19,11 @@ use std::iter::repeat;\n use std::path::Path;\n use std::time::{Duration, Instant};\n \n+use std::sync::mpsc::{Sender};\n+use syntax_pos::{Span};\n+use ty::maps::{QueryMsg};\n+use dep_graph::{DepNode};\n+\n // The name of the associated type for `Fn` return types\n pub const FN_OUTPUT_NAME: &'static str = \"Output\";\n \n@@ -29,6 +34,72 @@ pub struct ErrorReported;\n \n thread_local!(static TIME_DEPTH: Cell<usize> = Cell::new(0));\n \n+/// Initialized for -Z profile-queries\n+thread_local!(static PROFQ_CHAN: RefCell<Option<Sender<ProfileQueriesMsg>>> = RefCell::new(None));\n+\n+/// Parameters to the `Dump` variant of type `ProfileQueriesMsg`.\n+#[derive(Clone,Debug)]\n+pub struct ProfQDumpParams {\n+    /// A base path for the files we will dump\n+    pub path:String,\n+    /// To ensure that the compiler waits for us to finish our dumps\n+    pub ack:Sender<()>,\n+    /// toggle dumping a log file with every `ProfileQueriesMsg`\n+    pub dump_profq_msg_log:bool,\n+}\n+\n+/// A sequence of these messages induce a trace of query-based incremental compilation.\n+/// FIXME(matthewhammer): Determine whether we should include cycle detection here or not.\n+#[derive(Clone,Debug)]\n+pub enum ProfileQueriesMsg {\n+    /// begin a timed pass\n+    TimeBegin(String),\n+    /// end a timed pass\n+    TimeEnd,\n+    /// begin a task (see dep_graph::graph::with_task)\n+    TaskBegin(DepNode),\n+    /// end a task\n+    TaskEnd,\n+    /// begin a new query\n+    QueryBegin(Span, QueryMsg),\n+    /// query is satisfied by using an already-known value for the given key\n+    CacheHit,\n+    /// query requires running a provider; providers may nest, permitting queries to nest.\n+    ProviderBegin,\n+    /// query is satisfied by a provider terminating with a value\n+    ProviderEnd,\n+    /// dump a record of the queries to the given path\n+    Dump(ProfQDumpParams),\n+    /// halt the profiling/monitoring background thread\n+    Halt\n+}\n+\n+/// If enabled, send a message to the profile-queries thread\n+pub fn profq_msg(msg: ProfileQueriesMsg) {\n+    PROFQ_CHAN.with(|sender|{\n+        if let Some(s) = sender.borrow().as_ref() {\n+            s.send(msg).unwrap()\n+        } else {\n+            // Do nothing.\n+            //\n+            // FIXME(matthewhammer): Multi-threaded translation phase triggers the panic below.\n+            // From backtrace: rustc_trans::back::write::spawn_work::{{closure}}.\n+            //\n+            // panic!(\"no channel on which to send profq_msg: {:?}\", msg)\n+        }\n+    })\n+}\n+\n+/// Set channel for profile queries channel\n+pub fn profq_set_chan(s: Sender<ProfileQueriesMsg>) -> bool {\n+    PROFQ_CHAN.with(|chan|{\n+        if chan.borrow().is_none() {\n+            *chan.borrow_mut() = Some(s);\n+            true\n+        } else { false }\n+    })\n+}\n+\n /// Read the current depth of `time()` calls. This is used to\n /// encourage indentation across threads.\n pub fn time_depth() -> usize {\n@@ -53,9 +124,15 @@ pub fn time<T, F>(do_it: bool, what: &str, f: F) -> T where\n         r\n     });\n \n+    if cfg!(debug_assertions) {\n+        profq_msg(ProfileQueriesMsg::TimeBegin(what.to_string()))\n+    };\n     let start = Instant::now();\n     let rv = f();\n     let dur = start.elapsed();\n+    if cfg!(debug_assertions) {\n+        profq_msg(ProfileQueriesMsg::TimeEnd)\n+    };\n \n     print_time_passes_entry_internal(what, dur);\n "}, {"sha": "124c840cc56d63cbf311a8676598e8bb7e8586e6", "filename": "src/librustc_apfloat/ieee.rs", "status": "modified", "additions": 96, "deletions": 30, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/c872f4727697327550d43d106f5dddd735c41e5f/src%2Flibrustc_apfloat%2Fieee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c872f4727697327550d43d106f5dddd735c41e5f/src%2Flibrustc_apfloat%2Fieee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_apfloat%2Fieee.rs?ref=c872f4727697327550d43d106f5dddd735c41e5f", "patch": "@@ -460,18 +460,15 @@ impl<S: Semantics> fmt::Display for IeeeFloat<S> {\n             // rem <- sig % 10\n             // sig <- sig / 10\n             let mut rem = 0;\n-            for limb in sig.iter_mut().rev() {\n-                // We don't have an integer doubly wide than Limb,\n-                // so we have to split the divrem on two halves.\n-                const HALF_BITS: usize = LIMB_BITS / 2;\n-                let mut halves = [*limb & ((1 << HALF_BITS) - 1), *limb >> HALF_BITS];\n-                for half in halves.iter_mut().rev() {\n-                    *half |= rem << HALF_BITS;\n-                    rem = *half % 10;\n-                    *half /= 10;\n-                }\n-                *limb = halves[0] | (halves[1] << HALF_BITS);\n-            }\n+\n+            // Use 64-bit division and remainder, with 32-bit chunks from sig.\n+            sig::each_chunk(&mut sig, 32, |chunk| {\n+                let chunk = chunk as u32;\n+                let combined = ((rem as u64) << 32) | (chunk as u64);\n+                rem = (combined % 10) as u8;\n+                (combined / 10) as u32 as Limb\n+            });\n+\n             // Reduce the sigificand to avoid wasting time dividing 0's.\n             while sig.last() == Some(&0) {\n                 sig.pop();\n@@ -491,7 +488,7 @@ impl<S: Semantics> fmt::Display for IeeeFloat<S> {\n                 exp += 1;\n             } else {\n                 in_trail = false;\n-                buffer.push(b'0' + digit as u8);\n+                buffer.push(b'0' + digit);\n             }\n         }\n \n@@ -2065,7 +2062,7 @@ impl<S: Semantics> IeeeFloat<S> {\n         };\n \n         // Attempt dec_sig * 10^dec_exp with increasing precision.\n-        let mut attempt = 1;\n+        let mut attempt = 0;\n         loop {\n             let calc_precision = (LIMB_BITS << attempt) - 1;\n             attempt += 1;\n@@ -2310,6 +2307,17 @@ mod sig {\n         limbs.iter().all(|&l| l == 0)\n     }\n \n+    /// One, not zero, based LSB. That is, returns 0 for a zeroed significand.\n+    pub(super) fn olsb(limbs: &[Limb]) -> usize {\n+        for i in 0..limbs.len() {\n+            if limbs[i] != 0 {\n+                return i * LIMB_BITS + limbs[i].trailing_zeros() as usize + 1;\n+            }\n+        }\n+\n+        0\n+    }\n+\n     /// One, not zero, based MSB. That is, returns 0 for a zeroed significand.\n     pub(super) fn omsb(limbs: &[Limb]) -> usize {\n         for i in (0..limbs.len()).rev() {\n@@ -2468,6 +2476,20 @@ mod sig {\n         }\n     }\n \n+    /// For every consecutive chunk of `bits` bits from `limbs`,\n+    /// going from most significant to the least significant bits,\n+    /// call `f` to transform those bits and store the result back.\n+    pub(super) fn each_chunk<F: FnMut(Limb) -> Limb>(limbs: &mut [Limb], bits: usize, mut f: F) {\n+        assert_eq!(LIMB_BITS % bits, 0);\n+        for limb in limbs.iter_mut().rev() {\n+            let mut r = 0;\n+            for i in (0..LIMB_BITS / bits).rev() {\n+                r |= f((*limb >> (i * bits)) & ((1 << bits) - 1)) << (i * bits);\n+            }\n+            *limb = r;\n+        }\n+    }\n+\n     /// Increment in-place, return the carry flag.\n     pub(super) fn increment(dst: &mut [Limb]) -> Limb {\n         for x in dst {\n@@ -2686,10 +2708,6 @@ mod sig {\n         divisor: &mut [Limb],\n         precision: usize,\n     ) -> Loss {\n-        // Zero the quotient before setting bits in it.\n-        for x in &mut quotient[..limbs_for_bits(precision)] {\n-            *x = 0;\n-        }\n \n         // Normalize the divisor.\n         let bits = precision - omsb(divisor);\n@@ -2700,6 +2718,13 @@ mod sig {\n         let bits = precision - omsb(dividend);\n         shift_left(dividend, exp, bits);\n \n+        // Division by 1.\n+        let olsb_divisor = olsb(divisor);\n+        if olsb_divisor == precision {\n+            quotient.copy_from_slice(dividend);\n+            return Loss::ExactlyZero;\n+        }\n+\n         // Ensure the dividend >= divisor initially for the loop below.\n         // Incidentally, this means that the division loop below is\n         // guaranteed to set the integer bit to one.\n@@ -2708,6 +2733,58 @@ mod sig {\n             assert_ne!(cmp(dividend, divisor), Ordering::Less)\n         }\n \n+        // Helper for figuring out the lost fraction.\n+        let lost_fraction = |dividend: &[Limb], divisor: &[Limb]| {\n+            match cmp(dividend, divisor) {\n+                Ordering::Greater => Loss::MoreThanHalf,\n+                Ordering::Equal => Loss::ExactlyHalf,\n+                Ordering::Less => {\n+                    if is_all_zeros(dividend) {\n+                        Loss::ExactlyZero\n+                    } else {\n+                        Loss::LessThanHalf\n+                    }\n+                }\n+            }\n+        };\n+\n+        // Try to perform a (much faster) short division for small divisors.\n+        let divisor_bits = precision - (olsb_divisor - 1);\n+        macro_rules! try_short_div {\n+            ($W:ty, $H:ty, $half:expr) => {\n+                if divisor_bits * 2 <= $half {\n+                    // Extract the small divisor.\n+                    let _: Loss = shift_right(divisor, &mut 0, olsb_divisor - 1);\n+                    let divisor = divisor[0] as $H as $W;\n+\n+                    // Shift the dividend to produce a quotient with the unit bit set.\n+                    let top_limb = *dividend.last().unwrap();\n+                    let mut rem = (top_limb >> (LIMB_BITS - (divisor_bits - 1))) as $H;\n+                    shift_left(dividend, &mut 0, divisor_bits - 1);\n+\n+                    // Apply short division in place on $H (of $half bits) chunks.\n+                    each_chunk(dividend, $half, |chunk| {\n+                        let chunk = chunk as $H;\n+                        let combined = ((rem as $W) << $half) | (chunk as $W);\n+                        rem = (combined % divisor) as $H;\n+                        (combined / divisor) as $H as Limb\n+                    });\n+                    quotient.copy_from_slice(dividend);\n+\n+                    return lost_fraction(&[(rem as Limb) << 1], &[divisor as Limb]);\n+                }\n+            }\n+        }\n+\n+        try_short_div!(u32, u16, 16);\n+        try_short_div!(u64, u32, 32);\n+        try_short_div!(u128, u64, 64);\n+\n+        // Zero the quotient before setting bits in it.\n+        for x in &mut quotient[..limbs_for_bits(precision)] {\n+            *x = 0;\n+        }\n+\n         // Long division.\n         for bit in (0..precision).rev() {\n             if cmp(dividend, divisor) != Ordering::Less {\n@@ -2717,17 +2794,6 @@ mod sig {\n             shift_left(dividend, &mut 0, 1);\n         }\n \n-        // Figure out the lost fraction.\n-        match cmp(dividend, divisor) {\n-            Ordering::Greater => Loss::MoreThanHalf,\n-            Ordering::Equal => Loss::ExactlyHalf,\n-            Ordering::Less => {\n-                if is_all_zeros(dividend) {\n-                    Loss::ExactlyZero\n-                } else {\n-                    Loss::LessThanHalf\n-                }\n-            }\n-        }\n+        lost_fraction(dividend, divisor)\n     }\n }"}, {"sha": "31d428d2668395e4830ae934ec12495617abd241", "filename": "src/librustc_back/target/l4re_base.rs", "status": "modified", "additions": 55, "deletions": 5, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/c872f4727697327550d43d106f5dddd735c41e5f/src%2Flibrustc_back%2Ftarget%2Fl4re_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c872f4727697327550d43d106f5dddd735c41e5f/src%2Flibrustc_back%2Ftarget%2Fl4re_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fl4re_base.rs?ref=c872f4727697327550d43d106f5dddd735c41e5f", "patch": "@@ -12,21 +12,71 @@ use PanicStrategy;\n use LinkerFlavor;\n use target::{LinkArgs, TargetOptions};\n use std::default::Default;\n+use std::env;\n+use std::process::Command;\n \n-pub fn opts() -> TargetOptions {\n+// Use GCC to locate code for crt* libraries from the host, not from L4Re. Note\n+// that a few files also come from L4Re, for these, the function shouldn't be\n+// used. This uses GCC for the location of the file, but GCC is required for L4Re anyway.\n+fn get_path_or(filename: &str) -> String {\n+    let child = Command::new(\"gcc\")\n+        .arg(format!(\"-print-file-name={}\", filename)).output()\n+        .expect(\"Failed to execute GCC\");\n+    String::from_utf8(child.stdout)\n+        .expect(\"Couldn't read path from GCC\").trim().into()\n+}\n+\n+pub fn opts() -> Result<TargetOptions, String> {\n+    let l4re_lib_path = env::var_os(\"L4RE_LIBDIR\").ok_or(\"Unable to find L4Re \\\n+        library directory: L4RE_LIBDIR not set.\")?.into_string().unwrap();\n     let mut pre_link_args = LinkArgs::new();\n     pre_link_args.insert(LinkerFlavor::Ld, vec![\n-            \"-nostdlib\".to_string(),\n+        format!(\"-T{}/main_stat.ld\", l4re_lib_path),\n+        \"--defsym=__executable_start=0x01000000\".to_string(),\n+        \"--defsym=__L4_KIP_ADDR__=0x6ffff000\".to_string(),\n+        format!(\"{}/crt1.o\", l4re_lib_path),\n+        format!(\"{}/crti.o\", l4re_lib_path),\n+        get_path_or(\"crtbeginT.o\"),\n+    ]);\n+    let mut post_link_args = LinkArgs::new();\n+    post_link_args.insert(LinkerFlavor::Ld, vec![\n+        format!(\"{}/l4f/libpthread.a\", l4re_lib_path),\n+        format!(\"{}/l4f/libc_be_sig.a\", l4re_lib_path),\n+        format!(\"{}/l4f/libc_be_sig_noop.a\", l4re_lib_path),\n+        format!(\"{}/l4f/libc_be_socket_noop.a\", l4re_lib_path),\n+        format!(\"{}/l4f/libc_be_fs_noop.a\", l4re_lib_path),\n+        format!(\"{}/l4f/libc_be_sem_noop.a\", l4re_lib_path),\n+        format!(\"{}/l4f/libl4re-vfs.o.a\", l4re_lib_path),\n+        format!(\"{}/l4f/lib4re.a\", l4re_lib_path),\n+        format!(\"{}/l4f/lib4re-util.a\", l4re_lib_path),\n+        format!(\"{}/l4f/libc_support_misc.a\", l4re_lib_path),\n+        format!(\"{}/l4f/libsupc++.a\", l4re_lib_path),\n+        format!(\"{}/l4f/lib4shmc.a\", l4re_lib_path),\n+        format!(\"{}/l4f/lib4re-c.a\", l4re_lib_path),\n+        format!(\"{}/l4f/lib4re-c-util.a\", l4re_lib_path),\n+        get_path_or(\"libgcc_eh.a\"),\n+        format!(\"{}/l4f/libdl.a\", l4re_lib_path),\n+        \"--start-group\".to_string(),\n+        format!(\"{}/l4f/libl4util.a\", l4re_lib_path),\n+        format!(\"{}/l4f/libc_be_l4re.a\", l4re_lib_path),\n+        format!(\"{}/l4f/libuc_c.a\", l4re_lib_path),\n+        format!(\"{}/l4f/libc_be_l4refile.a\", l4re_lib_path),\n+        \"--end-group\".to_string(),\n+        format!(\"{}/l4f/libl4sys.a\", l4re_lib_path),\n+        \"-gc-sections\".to_string(),\n+        get_path_or(\"crtend.o\"),\n+        format!(\"{}/crtn.o\", l4re_lib_path),\n     ]);\n \n-    TargetOptions {\n+    Ok(TargetOptions {\n         executables: true,\n         has_elf_tls: false,\n-        exe_allocation_crate: Some(\"alloc_system\".to_string()),\n+        exe_allocation_crate: None,\n         panic_strategy: PanicStrategy::Abort,\n         linker: \"ld\".to_string(),\n         pre_link_args,\n+        post_link_args,\n         target_family: Some(\"unix\".to_string()),\n         .. Default::default()\n-    }\n+    })\n }"}, {"sha": "6e5e139715cccadef9f458f483354a94c3441997", "filename": "src/librustc_back/target/linux_musl_base.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c872f4727697327550d43d106f5dddd735c41e5f/src%2Flibrustc_back%2Ftarget%2Flinux_musl_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c872f4727697327550d43d106f5dddd735c41e5f/src%2Flibrustc_back%2Ftarget%2Flinux_musl_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Flinux_musl_base.rs?ref=c872f4727697327550d43d106f5dddd735c41e5f", "patch": "@@ -60,15 +60,10 @@ pub fn opts() -> TargetOptions {\n     base.pre_link_objects_exe.push(\"crti.o\".to_string());\n     base.post_link_objects.push(\"crtn.o\".to_string());\n \n-    // MUSL support doesn't currently include dynamic linking, so there's no\n-    // need for dylibs or rpath business. Additionally `-pie` is incompatible\n-    // with `-static`, so we can't pass `-pie`.\n-    base.dynamic_linking = false;\n-    base.has_rpath = false;\n-    base.position_independent_executables = false;\n-\n     // These targets statically link libc by default\n     base.crt_static_default = true;\n+    // These targets allow the user to choose between static and dynamic linking.\n+    base.crt_static_respected = true;\n \n     base\n }"}, {"sha": "130e1b695dbd5b7bbcdab87d5bb3edc6fab29588", "filename": "src/librustc_back/target/mod.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c872f4727697327550d43d106f5dddd735c41e5f/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c872f4727697327550d43d106f5dddd735c41e5f/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmod.rs?ref=c872f4727697327550d43d106f5dddd735c41e5f", "patch": "@@ -416,8 +416,12 @@ pub struct TargetOptions {\n     /// ABIs are considered to be supported on all platforms and cannot be blacklisted.\n     pub abi_blacklist: Vec<Abi>,\n \n+    /// Whether or not linking dylibs to a static CRT is allowed.\n+    pub crt_static_allows_dylibs: bool,\n     /// Whether or not the CRT is statically linked by default.\n     pub crt_static_default: bool,\n+    /// Whether or not crt-static is respected by the compiler (or is a no-op).\n+    pub crt_static_respected: bool,\n \n     /// Whether or not stack probes (__rust_probestack) are enabled\n     pub stack_probes: bool,\n@@ -478,7 +482,9 @@ impl Default for TargetOptions {\n             max_atomic_width: None,\n             panic_strategy: PanicStrategy::Unwind,\n             abi_blacklist: vec![],\n+            crt_static_allows_dylibs: false,\n             crt_static_default: false,\n+            crt_static_respected: false,\n             stack_probes: false,\n         }\n     }\n@@ -714,7 +720,9 @@ impl Target {\n         key!(max_atomic_width, Option<u64>);\n         key!(min_atomic_width, Option<u64>);\n         try!(key!(panic_strategy, PanicStrategy));\n+        key!(crt_static_allows_dylibs, bool);\n         key!(crt_static_default, bool);\n+        key!(crt_static_respected, bool);\n         key!(stack_probes, bool);\n \n         if let Some(array) = obj.find(\"abi-blacklist\").and_then(Json::as_array) {\n@@ -902,7 +910,9 @@ impl ToJson for Target {\n         target_option_val!(min_atomic_width);\n         target_option_val!(max_atomic_width);\n         target_option_val!(panic_strategy);\n+        target_option_val!(crt_static_allows_dylibs);\n         target_option_val!(crt_static_default);\n+        target_option_val!(crt_static_respected);\n         target_option_val!(stack_probes);\n \n         if default.abi_blacklist != self.options.abi_blacklist {"}, {"sha": "42a4e6f5f11885e873f933603830d884dad74180", "filename": "src/librustc_back/target/windows_msvc_base.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c872f4727697327550d43d106f5dddd735c41e5f/src%2Flibrustc_back%2Ftarget%2Fwindows_msvc_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c872f4727697327550d43d106f5dddd735c41e5f/src%2Flibrustc_back%2Ftarget%2Fwindows_msvc_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fwindows_msvc_base.rs?ref=c872f4727697327550d43d106f5dddd735c41e5f", "patch": "@@ -63,6 +63,8 @@ pub fn opts() -> TargetOptions {\n         is_like_windows: true,\n         is_like_msvc: true,\n         pre_link_args: args,\n+        crt_static_allows_dylibs: true,\n+        crt_static_respected: true,\n \n         .. Default::default()\n     }"}, {"sha": "99d3171e1c0e0f9dc1eef6f7d616dc9e5c28f77c", "filename": "src/librustc_back/target/x86_64_unknown_l4re_uclibc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c872f4727697327550d43d106f5dddd735c41e5f/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_l4re_uclibc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c872f4727697327550d43d106f5dddd735c41e5f/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_l4re_uclibc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_l4re_uclibc.rs?ref=c872f4727697327550d43d106f5dddd735c41e5f", "patch": "@@ -12,7 +12,7 @@ use LinkerFlavor;\n use target::{Target, TargetResult};\n \n pub fn target() -> TargetResult {\n-    let mut base = super::l4re_base::opts();\n+    let mut base = super::l4re_base::opts()?;\n     base.cpu = \"x86-64\".to_string();\n     base.max_atomic_width = Some(64);\n "}, {"sha": "57b92eb8f8891aa0b39e126935b71d92fda1de93", "filename": "src/librustc_borrowck/borrowck/gather_loans/move_error.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/c872f4727697327550d43d106f5dddd735c41e5f/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c872f4727697327550d43d106f5dddd735c41e5f/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs?ref=c872f4727697327550d43d106f5dddd735c41e5f", "patch": "@@ -153,20 +153,19 @@ fn report_cannot_move_out_of<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n         }\n \n         Categorization::Interior(ref b, mc::InteriorElement(ik)) => {\n-            match (&b.ty.sty, ik) {\n-                (&ty::TySlice(..), _) |\n-                (_, Kind::Index) => {\n-                    let mut err = struct_span_err!(bccx, move_from.span, E0508,\n-                                                   \"cannot move out of type `{}`, \\\n-                                                    a non-copy array\",\n-                                                   b.ty);\n-                    err.span_label(move_from.span, \"cannot move out of here\");\n-                    err\n-                }\n-                (_, Kind::Pattern) => {\n+            let type_name = match (&b.ty.sty, ik) {\n+                (&ty::TyArray(_, _), Kind::Index) => \"array\",\n+                (&ty::TySlice(_), _) => \"slice\",\n+                _ => {\n                     span_bug!(move_from.span, \"this path should not cause illegal move\");\n-                }\n-            }\n+                },\n+            };\n+            let mut err = struct_span_err!(bccx, move_from.span, E0508,\n+                                           \"cannot move out of type `{}`, \\\n+                                            a non-copy {}\",\n+                                           b.ty, type_name);\n+            err.span_label(move_from.span, \"cannot move out of here\");\n+            err\n         }\n \n         Categorization::Downcast(ref b, _) |"}, {"sha": "6ceb17be052232fd324f7f3766319794102133dd", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 18, "deletions": 4, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c872f4727697327550d43d106f5dddd735c41e5f/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c872f4727697327550d43d106f5dddd735c41e5f/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=c872f4727697327550d43d106f5dddd735c41e5f", "patch": "@@ -64,6 +64,8 @@ use arena::DroplessArena;\n \n use derive_registrar;\n \n+use profile;\n+\n pub fn compile_input(sess: &Session,\n                      cstore: &CStore,\n                      input: &Input,\n@@ -105,6 +107,10 @@ pub fn compile_input(sess: &Session,\n         sess.abort_if_errors();\n     }\n \n+    if sess.profile_queries() {\n+        profile::begin();\n+    }\n+\n     // We need nested scopes here, because the intermediate results can keep\n     // large chunks of memory alive and we want to free them as soon as\n     // possible to keep the peak memory usage low\n@@ -537,6 +543,10 @@ pub fn phase_1_parse_input<'a>(control: &CompileController,\n                                -> PResult<'a, ast::Crate> {\n     sess.diagnostic().set_continue_after_error(control.continue_parse_after_error);\n \n+    if sess.profile_queries() {\n+        profile::begin();\n+    }\n+\n     let krate = time(sess.time_passes(), \"parsing\", || {\n         match *input {\n             Input::File(ref file) => {\n@@ -833,10 +843,6 @@ pub fn phase_2_configure_and_expand<F>(sess: &Session,\n         })\n     })?;\n \n-    time(time_passes,\n-         \"early lint checks\",\n-         || lint::check_ast_crate(sess, &krate));\n-\n     // Lower ast -> hir.\n     let hir_forest = time(time_passes, \"lowering ast -> hir\", || {\n         let hir_crate = lower_crate(sess, &krate, &mut resolver);\n@@ -848,6 +854,10 @@ pub fn phase_2_configure_and_expand<F>(sess: &Session,\n         hir_map::Forest::new(hir_crate, &sess.dep_graph)\n     });\n \n+    time(time_passes,\n+         \"early lint checks\",\n+         || lint::check_ast_crate(sess, &krate));\n+\n     // Discard hygiene data, which isn't required after lowering to HIR.\n     if !keep_hygiene_data(sess) {\n         syntax::ext::hygiene::clear_markings();\n@@ -1122,6 +1132,10 @@ pub fn phase_4_translate_to_llvm<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n              \"translation\",\n              move || trans::trans_crate(tcx, analysis, incremental_hashes_map, output_filenames));\n \n+    if tcx.sess.profile_queries() {\n+        profile::dump(\"profile_queries\".to_string())\n+    }\n+\n     translation\n }\n "}, {"sha": "d7b5d4a6fe3ba40ff73b3e56b82393ffde544040", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c872f4727697327550d43d106f5dddd735c41e5f/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c872f4727697327550d43d106f5dddd735c41e5f/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=c872f4727697327550d43d106f5dddd735c41e5f", "patch": "@@ -104,6 +104,7 @@ use syntax_pos::{DUMMY_SP, MultiSpan};\n #[cfg(test)]\n mod test;\n \n+pub mod profile;\n pub mod driver;\n pub mod pretty;\n pub mod target_features;"}, {"sha": "061077d05a438560f820b3c45d83dbf74427434a", "filename": "src/librustc_driver/profile/mod.rs", "status": "added", "additions": 316, "deletions": 0, "changes": 316, "blob_url": "https://github.com/rust-lang/rust/blob/c872f4727697327550d43d106f5dddd735c41e5f/src%2Flibrustc_driver%2Fprofile%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c872f4727697327550d43d106f5dddd735c41e5f/src%2Flibrustc_driver%2Fprofile%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fprofile%2Fmod.rs?ref=c872f4727697327550d43d106f5dddd735c41e5f", "patch": "@@ -0,0 +1,316 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rustc::util::common::{ProfQDumpParams, ProfileQueriesMsg, profq_msg, profq_set_chan};\n+use std::sync::mpsc::{Receiver};\n+use std::io::{Write};\n+use rustc::dep_graph::{DepNode};\n+use std::time::{Duration, Instant};\n+\n+pub mod trace;\n+\n+/// begin a profile thread, if not already running\n+pub fn begin() {\n+    use std::thread;\n+    use std::sync::mpsc::{channel};\n+    let (tx, rx) = channel();\n+    if profq_set_chan(tx) {\n+        thread::spawn(move||profile_queries_thread(rx));\n+    }\n+}\n+\n+/// dump files with profiling information to the given base path, and\n+/// wait for this dump to complete.\n+///\n+/// wraps the RPC (send/recv channel logic) of requesting a dump.\n+pub fn dump(path:String) {\n+    use std::sync::mpsc::{channel};\n+    let (tx, rx) = channel();\n+    let params = ProfQDumpParams{\n+        path, ack:tx,\n+        // FIXME: Add another compiler flag to toggle whether this log\n+        // is written; false for now\n+        dump_profq_msg_log:true,\n+    };\n+    profq_msg(ProfileQueriesMsg::Dump(params));\n+    let _ = rx.recv().unwrap();\n+}\n+\n+// State for parsing recursive trace structure in separate thread, via messages\n+#[derive(Clone, Eq, PartialEq)]\n+enum ParseState {\n+    // No (local) parse state; may be parsing a tree, focused on a\n+    // sub-tree that could be anything.\n+    Clear,\n+    // Have Query information from the last message\n+    HaveQuery(trace::Query, Instant),\n+    // Have \"time-begin\" information from the last message (doit flag, and message)\n+    HaveTimeBegin(String, Instant),\n+    // Have \"task-begin\" information from the last message\n+    HaveTaskBegin(DepNode, Instant),\n+}\n+struct StackFrame {\n+    pub parse_st: ParseState,\n+    pub traces:   Vec<trace::Rec>,\n+}\n+\n+fn total_duration(traces: &Vec<trace::Rec>) -> Duration {\n+    let mut sum : Duration = Duration::new(0,0);\n+    for t in traces.iter() { sum += t.dur_total; }\n+    return sum\n+}\n+\n+// profiling thread; retains state (in local variables) and dump traces, upon request.\n+fn profile_queries_thread(r:Receiver<ProfileQueriesMsg>) {\n+    use self::trace::*;\n+    use std::fs::File;\n+    use std::time::{Instant};\n+\n+    let mut profq_msgs : Vec<ProfileQueriesMsg> = vec![];\n+    let mut frame : StackFrame = StackFrame{ parse_st:ParseState::Clear, traces:vec![] };\n+    let mut stack : Vec<StackFrame> = vec![];\n+    loop {\n+        let msg = r.recv();\n+        if let Err(_recv_err) = msg {\n+            // FIXME: Perhaps do something smarter than simply quitting?\n+            break\n+        };\n+        let msg = msg.unwrap();\n+        debug!(\"profile_queries_thread: {:?}\", msg);\n+\n+        // Meta-level versus _actual_ queries messages\n+        match msg {\n+            ProfileQueriesMsg::Halt => return,\n+            ProfileQueriesMsg::Dump(params) => {\n+                assert!(stack.len() == 0);\n+                assert!(frame.parse_st == ParseState::Clear);\n+                {\n+                    // write log of all messages\n+                    if params.dump_profq_msg_log {\n+                        let mut log_file =\n+                            File::create(format!(\"{}.log.txt\", params.path)).unwrap();\n+                        for m in profq_msgs.iter() {\n+                            writeln!(&mut log_file, \"{:?}\", m).unwrap()\n+                        };\n+                    }\n+\n+                    // write HTML file, and counts file\n+                    let html_path = format!(\"{}.html\", params.path);\n+                    let mut html_file = File::create(&html_path).unwrap();\n+\n+                    let counts_path = format!(\"{}.counts.txt\", params.path);\n+                    let mut counts_file = File::create(&counts_path).unwrap();\n+\n+                    write!(html_file, \"<html>\\n\").unwrap();\n+                    write!(html_file,\n+                           \"<head>\\n<link rel=\\\"stylesheet\\\" type=\\\"text/css\\\" href=\\\"{}\\\">\\n\",\n+                           \"profile_queries.css\").unwrap();\n+                    write!(html_file, \"<style>\\n\").unwrap();\n+                    trace::write_style(&mut html_file);\n+                    write!(html_file, \"</style>\\n\").unwrap();\n+                    write!(html_file, \"</head>\\n\").unwrap();\n+                    write!(html_file, \"<body>\\n\").unwrap();\n+                    trace::write_traces(&mut html_file, &mut counts_file, &frame.traces);\n+                    write!(html_file, \"</body>\\n</html>\\n\").unwrap();\n+\n+                    let ack_path = format!(\"{}.ack\", params.path);\n+                    let ack_file = File::create(&ack_path).unwrap();\n+                    drop(ack_file);\n+\n+                    // Tell main thread that we are done, e.g., so it can exit\n+                    params.ack.send(()).unwrap();\n+                }\n+                continue\n+            }\n+            // Actual query message:\n+            msg => {\n+                // Record msg in our log\n+                profq_msgs.push(msg.clone());\n+                // Respond to the message, knowing that we've already handled Halt and Dump, above.\n+                match (frame.parse_st.clone(), msg) {\n+                    (_,ProfileQueriesMsg::Halt) => unreachable!(),\n+                    (_,ProfileQueriesMsg::Dump(_)) => unreachable!(),\n+\n+                    // Parse State: Clear\n+                    (ParseState::Clear,\n+                     ProfileQueriesMsg::QueryBegin(span,querymsg)) => {\n+                        let start = Instant::now();\n+                        frame.parse_st = ParseState::HaveQuery\n+                            (Query{span:span, msg:querymsg}, start)\n+                    },\n+                    (ParseState::Clear,\n+                     ProfileQueriesMsg::CacheHit) => {\n+                        panic!(\"parse error: unexpected CacheHit; expected QueryBegin\")\n+                    },\n+                    (ParseState::Clear,\n+                     ProfileQueriesMsg::ProviderBegin) => {\n+                        panic!(\"parse error: expected QueryBegin before beginning a provider\")\n+                    },\n+                    (ParseState::Clear,\n+                     ProfileQueriesMsg::ProviderEnd) => {\n+                        let provider_extent = frame.traces;\n+                        match stack.pop() {\n+                            None =>\n+                                panic!(\"parse error: expected a stack frame; found an empty stack\"),\n+                            Some(old_frame) => {\n+                                match old_frame.parse_st {\n+                                    ParseState::HaveQuery(q, start) => {\n+                                        let duration = start.elapsed();\n+                                        frame = StackFrame{\n+                                            parse_st:ParseState::Clear,\n+                                            traces:old_frame.traces\n+                                        };\n+                                        let dur_extent = total_duration(&provider_extent);\n+                                        let trace = Rec {\n+                                            effect: Effect::QueryBegin(q, CacheCase::Miss),\n+                                            extent: Box::new(provider_extent),\n+                                            start: start,\n+                                            dur_self: duration - dur_extent,\n+                                            dur_total: duration,\n+                                        };\n+                                        frame.traces.push( trace );\n+                                    },\n+                                    _ => panic!(\"internal parse error: malformed parse stack\")\n+                                }\n+                            }\n+                        }\n+                    },\n+\n+\n+                    (ParseState::Clear,\n+                     ProfileQueriesMsg::TimeBegin(msg)) => {\n+                        let start = Instant::now();\n+                        frame.parse_st = ParseState::HaveTimeBegin(msg, start);\n+                        stack.push(frame);\n+                        frame = StackFrame{parse_st:ParseState::Clear, traces:vec![]};\n+                    },\n+                    (_, ProfileQueriesMsg::TimeBegin(_)) =>\n+                        panic!(\"parse error; did not expect time begin here\"),\n+\n+                    (ParseState::Clear,\n+                     ProfileQueriesMsg::TimeEnd) => {\n+                        let provider_extent = frame.traces;\n+                        match stack.pop() {\n+                            None =>\n+                                panic!(\"parse error: expected a stack frame; found an empty stack\"),\n+                            Some(old_frame) => {\n+                                match old_frame.parse_st {\n+                                    ParseState::HaveTimeBegin(msg, start) => {\n+                                        let duration = start.elapsed();\n+                                        frame = StackFrame{\n+                                            parse_st:ParseState::Clear,\n+                                            traces:old_frame.traces\n+                                        };\n+                                        let dur_extent = total_duration(&provider_extent);\n+                                        let trace = Rec {\n+                                            effect: Effect::TimeBegin(msg),\n+                                            extent: Box::new(provider_extent),\n+                                            start: start,\n+                                            dur_total: duration,\n+                                            dur_self: duration - dur_extent,\n+                                        };\n+                                        frame.traces.push( trace );\n+                                    },\n+                                    _ => panic!(\"internal parse error: malformed parse stack\")\n+                                }\n+                            }\n+                        }\n+                    },\n+                    (_, ProfileQueriesMsg::TimeEnd) => { panic!(\"parse error\") }\n+\n+                    (ParseState::Clear,\n+                     ProfileQueriesMsg::TaskBegin(key)) => {\n+                        let start = Instant::now();\n+                        frame.parse_st = ParseState::HaveTaskBegin(key, start);\n+                        stack.push(frame);\n+                        frame = StackFrame{parse_st:ParseState::Clear, traces:vec![]};\n+                    },\n+                    (_, ProfileQueriesMsg::TaskBegin(_)) =>\n+                        panic!(\"parse error; did not expect time begin here\"),\n+\n+                    (ParseState::Clear,\n+                     ProfileQueriesMsg::TaskEnd) => {\n+                        let provider_extent = frame.traces;\n+                        match stack.pop() {\n+                            None =>\n+                                panic!(\"parse error: expected a stack frame; found an empty stack\"),\n+                            Some(old_frame) => {\n+                                match old_frame.parse_st {\n+                                    ParseState::HaveTaskBegin(key, start) => {\n+                                        let duration = start.elapsed();\n+                                        frame = StackFrame{\n+                                            parse_st:ParseState::Clear,\n+                                            traces:old_frame.traces\n+                                        };\n+                                        let dur_extent = total_duration(&provider_extent);\n+                                        let trace = Rec {\n+                                            effect: Effect::TaskBegin(key),\n+                                            extent: Box::new(provider_extent),\n+                                            start: start,\n+                                            dur_total: duration,\n+                                            dur_self: duration - dur_extent,\n+                                        };\n+                                        frame.traces.push( trace );\n+                                    },\n+                                    _ => panic!(\"internal parse error: malformed parse stack\")\n+                                }\n+                            }\n+                        }\n+                    },\n+                    (_, ProfileQueriesMsg::TaskEnd) => { panic!(\"parse error\") }\n+\n+                    // Parse State: HaveQuery\n+                    (ParseState::HaveQuery(q,start),\n+                     ProfileQueriesMsg::CacheHit) => {\n+                        let duration = start.elapsed();\n+                        let trace : Rec = Rec{\n+                            effect: Effect::QueryBegin(q, CacheCase::Hit),\n+                            extent: Box::new(vec![]),\n+                            start: start,\n+                            dur_self: duration,\n+                            dur_total: duration,\n+                        };\n+                        frame.traces.push( trace );\n+                        frame.parse_st = ParseState::Clear;\n+                    },\n+                    (ParseState::HaveQuery(_,_),\n+                     ProfileQueriesMsg::ProviderBegin) => {\n+                        stack.push(frame);\n+                        frame = StackFrame{parse_st:ParseState::Clear, traces:vec![]};\n+                    },\n+\n+                    //\n+                    //\n+                    // Parse errors:\n+\n+                    (ParseState::HaveQuery(q,_),\n+                     ProfileQueriesMsg::ProviderEnd) => {\n+                        panic!(\"parse error: unexpected ProviderEnd; \\\n+                                expected something else to follow BeginQuery for {:?}\", q)\n+                    },\n+                    (ParseState::HaveQuery(q1,_),\n+                     ProfileQueriesMsg::QueryBegin(span2,querymsg2)) => {\n+                        panic!(\"parse error: unexpected QueryBegin; \\\n+                                earlier query is unfinished: {:?} and now {:?}\",\n+                               q1, Query{span:span2, msg:querymsg2})\n+                    },\n+\n+                    (ParseState::HaveTimeBegin(_, _), _) => {\n+                        unreachable!()\n+                    },\n+                    (ParseState::HaveTaskBegin(_, _), _) => {\n+                        unreachable!()\n+                    },\n+                }\n+\n+            }\n+        }\n+    }\n+}"}, {"sha": "f5079836c3ca40f6d248b42fd024bb5d23777cd3", "filename": "src/librustc_driver/profile/trace.rs", "status": "added", "additions": 315, "deletions": 0, "changes": 315, "blob_url": "https://github.com/rust-lang/rust/blob/c872f4727697327550d43d106f5dddd735c41e5f/src%2Flibrustc_driver%2Fprofile%2Ftrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c872f4727697327550d43d106f5dddd735c41e5f/src%2Flibrustc_driver%2Fprofile%2Ftrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fprofile%2Ftrace.rs?ref=c872f4727697327550d43d106f5dddd735c41e5f", "patch": "@@ -0,0 +1,315 @@\n+// Copyright 2012-2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use super::*;\n+use syntax_pos::Span;\n+use rustc::ty::maps::QueryMsg;\n+use std::fs::File;\n+use std::time::{Duration, Instant};\n+use std::collections::hash_map::HashMap;\n+use rustc::dep_graph::{DepNode};\n+\n+#[derive(Debug, Clone, Eq, PartialEq)]\n+pub struct Query {\n+    pub span: Span,\n+    pub msg: QueryMsg,\n+}\n+pub enum Effect {\n+    QueryBegin(Query, CacheCase),\n+    TimeBegin(String),\n+    TaskBegin(DepNode),\n+}\n+pub enum CacheCase {\n+    Hit, Miss\n+}\n+/// Recursive trace structure\n+pub struct Rec {\n+    pub effect: Effect,\n+    pub start: Instant,\n+    pub dur_self: Duration,\n+    pub dur_total: Duration,\n+    pub extent: Box<Vec<Rec>>,\n+}\n+pub struct QueryMetric {\n+    pub count: usize,\n+    pub dur_self: Duration,\n+    pub dur_total: Duration,\n+}\n+\n+pub fn cons_of_query_msg(q: &trace::Query) -> String {\n+    let s = format!(\"{:?}\", q.msg);\n+    let cons: Vec<&str> = s.split(|d| d == '(' || d == '{').collect();\n+    assert!(cons.len() > 0 && cons[0] != \"\");\n+    cons[0].to_string()\n+}\n+\n+pub fn cons_of_key(k: &DepNode) -> String {\n+    let s = format!(\"{:?}\", k);\n+    let cons: Vec<&str> = s.split(|d| d == '(' || d == '{').collect();\n+    assert!(cons.len() > 0 && cons[0] != \"\");\n+    cons[0].to_string()\n+}\n+\n+// First return value is text; second return value is a CSS class\n+pub fn html_of_effect(eff: &Effect) -> (String, String) {\n+    match *eff {\n+        Effect::TimeBegin(ref msg) => {\n+            (msg.clone(),\n+             format!(\"time-begin\"))\n+        },\n+        Effect::TaskBegin(ref key) => {\n+            let cons = cons_of_key(key);\n+            (cons.clone(), format!(\"{} task-begin\", cons))\n+        },\n+        Effect::QueryBegin(ref qmsg, ref cc) => {\n+            let cons = cons_of_query_msg(qmsg);\n+            (cons.clone(),\n+             format!(\"{} {}\",\n+                     cons,\n+                     match *cc {\n+                         CacheCase::Hit => \"hit\",\n+                         CacheCase::Miss => \"miss\",\n+                     }))\n+        }\n+    }\n+}\n+\n+// First return value is text; second return value is a CSS class\n+fn html_of_duration(_start: &Instant, dur: &Duration) -> (String, String) {\n+    use rustc::util::common::duration_to_secs_str;\n+    (duration_to_secs_str(dur.clone()),\n+     \"\".to_string()\n+    )\n+}\n+\n+fn html_of_fraction(frac: f64) -> (String, String) {\n+    let css = {\n+        if       frac > 0.50  { format!(\"frac-50\") }\n+        else if  frac > 0.40  { format!(\"frac-40\") }\n+        else if  frac > 0.30  { format!(\"frac-30\") }\n+        else if  frac > 0.20  { format!(\"frac-20\") }\n+        else if  frac > 0.10  { format!(\"frac-10\") }\n+        else if  frac > 0.05  { format!(\"frac-05\") }\n+        else if  frac > 0.02  { format!(\"frac-02\") }\n+        else if  frac > 0.01  { format!(\"frac-01\") }\n+        else if  frac > 0.001 { format!(\"frac-001\") }\n+        else                  { format!(\"frac-0\") }\n+    };\n+    let percent = frac * 100.0;\n+    if percent > 0.1 { (format!(\"{:.1}%\", percent), css) }\n+    else { (format!(\"< 0.1%\", ), css) }\n+}\n+\n+fn total_duration(traces: &Vec<Rec>) -> Duration {\n+    let mut sum : Duration = Duration::new(0,0);\n+    for t in traces.iter() {\n+        sum += t.dur_total;\n+    }\n+    return sum\n+}\n+\n+fn duration_div(nom: Duration, den: Duration) -> f64 {\n+    fn to_nanos(d: Duration) -> u64 {\n+        d.as_secs() * 1_000_000_000 + d.subsec_nanos() as u64\n+    }\n+\n+    to_nanos(nom) as f64 / to_nanos(den) as f64\n+}\n+\n+fn write_traces_rec(file: &mut File, traces: &Vec<Rec>, total: Duration, depth: usize) {\n+    for t in traces {\n+        let (eff_text, eff_css_classes) = html_of_effect(&t.effect);\n+        let (dur_text, dur_css_classes) = html_of_duration(&t.start, &t.dur_total);\n+        let fraction = duration_div(t.dur_total, total);\n+        let percent = fraction * 100.0;\n+        let (frc_text, frc_css_classes) = html_of_fraction(fraction);\n+        write!(file, \"<div class=\\\"trace depth-{} extent-{}{} {} {} {}\\\">\\n\",\n+               depth,\n+               t.extent.len(),\n+               /* Heuristic for 'important' CSS class: */\n+               if t.extent.len() > 5 || percent >= 1.0 {\n+                   \" important\" }\n+               else { \"\" },\n+               eff_css_classes,\n+               dur_css_classes,\n+               frc_css_classes,\n+        ).unwrap();\n+        write!(file, \"<div class=\\\"eff\\\">{}</div>\\n\", eff_text).unwrap();\n+        write!(file, \"<div class=\\\"dur\\\">{}</div>\\n\", dur_text).unwrap();\n+        write!(file, \"<div class=\\\"frc\\\">{}</div>\\n\", frc_text).unwrap();\n+        write_traces_rec(file, &t.extent, total, depth + 1);\n+        write!(file, \"</div>\\n\").unwrap();\n+    }\n+}\n+\n+fn compute_counts_rec(counts: &mut HashMap<String,QueryMetric>, traces: &Vec<Rec>) {\n+    for t in traces.iter() {\n+        match t.effect {\n+            Effect::TimeBegin(ref msg) => {\n+                let qm = match counts.get(msg) {\n+                    Some(_qm) => { panic!(\"TimeBegin with non-unique, repeat message\") }\n+                    None => QueryMetric{\n+                        count: 1,\n+                        dur_self: t.dur_self,\n+                        dur_total: t.dur_total,\n+                    }};\n+                counts.insert(msg.clone(), qm);\n+            },\n+            Effect::TaskBegin(ref key) => {\n+                let cons = cons_of_key(key);\n+                let qm = match counts.get(&cons) {\n+                    Some(qm) =>\n+                        QueryMetric{\n+                            count: qm.count + 1,\n+                            dur_self: qm.dur_self + t.dur_self,\n+                            dur_total: qm.dur_total + t.dur_total,\n+                        },\n+                    None => QueryMetric{\n+                        count: 1,\n+                        dur_self: t.dur_self,\n+                        dur_total: t.dur_total,\n+                    }};\n+                counts.insert(cons, qm);\n+            },\n+            Effect::QueryBegin(ref qmsg, ref _cc) => {\n+                let qcons = cons_of_query_msg(qmsg);\n+                let qm = match counts.get(&qcons) {\n+                    Some(qm) =>\n+                        QueryMetric{\n+                            count: qm.count + 1,\n+                            dur_total: qm.dur_total + t.dur_total,\n+                            dur_self: qm.dur_self + t.dur_self\n+                        },\n+                    None => QueryMetric{\n+                        count: 1,\n+                        dur_total: t.dur_total,\n+                        dur_self: t.dur_self,\n+                    }\n+                };\n+                counts.insert(qcons, qm);\n+            }\n+        }\n+        compute_counts_rec(counts, &t.extent)\n+    }\n+}\n+\n+pub fn write_counts(count_file: &mut File, counts: &mut HashMap<String,QueryMetric>) {\n+    use rustc::util::common::duration_to_secs_str;\n+    use std::cmp::Ordering;\n+\n+    let mut data = vec![];\n+    for (ref cons, ref qm) in counts.iter() {\n+        data.push((cons.clone(), qm.count.clone(), qm.dur_total.clone(), qm.dur_self.clone()));\n+    };\n+    data.sort_by(|&(_,_,_,self1),&(_,_,_,self2)|\n+                 if self1 > self2 { Ordering::Less } else { Ordering::Greater } );\n+    for (cons, count, dur_total, dur_self) in data {\n+        write!(count_file, \"{}, {}, {}, {}\\n\",\n+               cons, count,\n+               duration_to_secs_str(dur_total),\n+               duration_to_secs_str(dur_self)\n+        ).unwrap();\n+    }\n+}\n+\n+pub fn write_traces(html_file: &mut File, counts_file: &mut File, traces: &Vec<Rec>) {\n+    let mut counts : HashMap<String,QueryMetric> = HashMap::new();\n+    compute_counts_rec(&mut counts, traces);\n+    write_counts(counts_file, &mut counts);\n+\n+    let total : Duration = total_duration(traces);\n+    write_traces_rec(html_file, traces, total, 0)\n+}\n+\n+pub fn write_style(html_file: &mut File) {\n+    write!(html_file,\"{}\", \"\n+body {\n+    font-family: sans-serif;\n+    background: black;\n+}\n+.trace {\n+    color: black;\n+    display: inline-block;\n+    border-style: solid;\n+    border-color: red;\n+    border-width: 1px;\n+    border-radius: 5px;\n+    padding: 0px;\n+    margin: 1px;\n+    font-size: 0px;\n+}\n+.task-begin {\n+    border-width: 1px;\n+    color: white;\n+    border-color: #ff8;\n+    font-size: 0px;\n+}\n+.miss {\n+    border-color: red;\n+    border-width: 1px;\n+}\n+.extent-0 {\n+    padding: 2px;\n+}\n+.time-begin {\n+    border-width: 4px;\n+    font-size: 12px;\n+    color: white;\n+    border-color: #afa;\n+}\n+.important {\n+    border-width: 3px;\n+    font-size: 12px;\n+    color: white;\n+    border-color: #f77;\n+}\n+.hit {\n+    padding: 0px;\n+    border-color: blue;\n+    border-width: 3px;\n+}\n+.eff {\n+  color: #fff;\n+  display: inline-block;\n+}\n+.frc {\n+  color: #7f7;\n+  display: inline-block;\n+}\n+.dur {\n+  display: none\n+}\n+.frac-50 {\n+  padding: 10px;\n+  border-width: 10px;\n+  font-size: 32px;\n+}\n+.frac-40 {\n+  padding: 8px;\n+  border-width: 8px;\n+  font-size: 24px;\n+}\n+.frac-30 {\n+  padding: 6px;\n+  border-width: 6px;\n+  font-size: 18px;\n+}\n+.frac-20 {\n+  padding: 4px;\n+  border-width: 6px;\n+  font-size: 16px;\n+}\n+.frac-10 {\n+  padding: 2px;\n+  border-width: 6px;\n+  font-size: 14px;\n+}\n+\").unwrap();\n+}"}, {"sha": "96264472b5f8e53e0fe752afd6f5d174ef6ebcdf", "filename": "src/librustc_driver/target_features.rs", "status": "modified", "additions": 1, "deletions": 15, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c872f4727697327550d43d106f5dddd735c41e5f/src%2Flibrustc_driver%2Ftarget_features.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c872f4727697327550d43d106f5dddd735c41e5f/src%2Flibrustc_driver%2Ftarget_features.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftarget_features.rs?ref=c872f4727697327550d43d106f5dddd735c41e5f", "patch": "@@ -25,21 +25,7 @@ pub fn add_configuration(cfg: &mut ast::CrateConfig, sess: &Session) {\n         cfg.insert((tf, Some(feat)));\n     }\n \n-    let requested_features = sess.opts.cg.target_feature.split(',');\n-    let found_negative = requested_features.clone().any(|r| r == \"-crt-static\");\n-    let found_positive = requested_features.clone().any(|r| r == \"+crt-static\");\n-\n-    // If the target we're compiling for requests a static crt by default,\n-    // then see if the `-crt-static` feature was passed to disable that.\n-    // Otherwise if we don't have a static crt by default then see if the\n-    // `+crt-static` feature was passed.\n-    let crt_static = if sess.target.target.options.crt_static_default {\n-        !found_negative\n-    } else {\n-        found_positive\n-    };\n-\n-    if crt_static {\n+    if sess.crt_static_feature() {\n         cfg.insert((tf, Some(Symbol::intern(\"crt-static\"))));\n     }\n }"}, {"sha": "72058747a76d284f7046bb8ca89521eb264d2b4a", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c872f4727697327550d43d106f5dddd735c41e5f/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c872f4727697327550d43d106f5dddd735c41e5f/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=c872f4727697327550d43d106f5dddd735c41e5f", "patch": "@@ -893,7 +893,7 @@ impl<'a, 'tcx> CrateMetadata {\n         if def_key.disambiguated_data.data == DefPathData::StructCtor {\n             item = self.entry(def_key.parent.unwrap());\n         }\n-        let result = Rc::__from_array(self.get_attributes(&item).into_boxed_slice());\n+        let result: Rc<[ast::Attribute]> = Rc::from(self.get_attributes(&item));\n         let vec_ = &mut self.attribute_cache.borrow_mut()[node_as];\n         if vec_.len() < node_index + 1 {\n             vec_.resize(node_index + 1, None);"}, {"sha": "0224393c3fe5caa8ced7f76728c006ee37f2494e", "filename": "src/librustc_mir/borrow_check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c872f4727697327550d43d106f5dddd735c41e5f/src%2Flibrustc_mir%2Fborrow_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c872f4727697327550d43d106f5dddd735c41e5f/src%2Flibrustc_mir%2Fborrow_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check.rs?ref=c872f4727697327550d43d106f5dddd735c41e5f", "patch": "@@ -50,7 +50,7 @@ fn mir_borrowck<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) {\n     debug!(\"run query mir_borrowck: {}\", tcx.node_path_str(src.item_id()));\n \n     let mir: &Mir<'tcx> = &mir.borrow();\n-    if !tcx.has_attr(def_id, \"rustc_mir_borrowck\") || !tcx.sess.opts.debugging_opts.borrowck_mir {\n+    if !tcx.has_attr(def_id, \"rustc_mir_borrowck\") && !tcx.sess.opts.debugging_opts.borrowck_mir {\n         return;\n     }\n "}, {"sha": "ffe444933a3b1c04db6599b07ec38b17258b2f1b", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c872f4727697327550d43d106f5dddd735c41e5f/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c872f4727697327550d43d106f5dddd735c41e5f/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=c872f4727697327550d43d106f5dddd735c41e5f", "patch": "@@ -140,14 +140,6 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n             ExprKind::Continue(Some(ident)) => {\n                 self.check_label(ident.node, ident.span);\n             }\n-            ExprKind::MethodCall(ref segment, ..) => {\n-                if let Some(ref params) = segment.parameters {\n-                    if let PathParameters::Parenthesized(..) = **params {\n-                        self.err_handler().span_err(expr.span,\n-                            \"parenthesized parameters cannot be used on method calls\");\n-                    }\n-                }\n-            }\n             _ => {}\n         }\n "}, {"sha": "602b71dca05aba92af522e92c4a7fd160531b79b", "filename": "src/librustc_plugin/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c872f4727697327550d43d106f5dddd735c41e5f/src%2Flibrustc_plugin%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c872f4727697327550d43d106f5dddd735c41e5f/src%2Flibrustc_plugin%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_plugin%2Flib.rs?ref=c872f4727697327550d43d106f5dddd735c41e5f", "patch": "@@ -69,6 +69,7 @@\n #![deny(warnings)]\n \n #![feature(rustc_diagnostic_macros)]\n+#![feature(staged_api)]\n \n #[macro_use] extern crate syntax;\n "}, {"sha": "4e211d83cff3e79551168f2aac1d2dce38d30daf", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c872f4727697327550d43d106f5dddd735c41e5f/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c872f4727697327550d43d106f5dddd735c41e5f/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=c872f4727697327550d43d106f5dddd735c41e5f", "patch": "@@ -902,7 +902,7 @@ fn link_args(cmd: &mut Linker,\n         let mut args = args.iter().chain(more_args.iter()).chain(used_link_args.iter());\n \n         if get_reloc_model(sess) == llvm::RelocMode::PIC\n-            && !args.any(|x| *x == \"-static\") {\n+            && !sess.crt_static() && !args.any(|x| *x == \"-static\") {\n             cmd.position_independent_executable();\n         }\n     }\n@@ -966,11 +966,13 @@ fn link_args(cmd: &mut Linker,\n     add_upstream_rust_crates(cmd, sess, crate_type, tmpdir);\n     add_upstream_native_libraries(cmd, sess, crate_type);\n \n-    // # Telling the linker what we're doing\n-\n+    // Tell the linker what we're doing.\n     if crate_type != config::CrateTypeExecutable {\n         cmd.build_dylib(out_filename);\n     }\n+    if crate_type == config::CrateTypeExecutable && sess.crt_static() {\n+        cmd.build_static_executable();\n+    }\n \n     // FIXME (#2397): At some point we want to rpath our guesses as to\n     // where extern libraries might live, based on the"}, {"sha": "9b0a5e3f4a5b11603119d84d516d147e5cd843d0", "filename": "src/librustc_trans/back/linker.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c872f4727697327550d43d106f5dddd735c41e5f/src%2Flibrustc_trans%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c872f4727697327550d43d106f5dddd735c41e5f/src%2Flibrustc_trans%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flinker.rs?ref=c872f4727697327550d43d106f5dddd735c41e5f", "patch": "@@ -110,6 +110,7 @@ pub trait Linker {\n     fn debuginfo(&mut self);\n     fn no_default_libraries(&mut self);\n     fn build_dylib(&mut self, out_filename: &Path);\n+    fn build_static_executable(&mut self);\n     fn args(&mut self, args: &[String]);\n     fn export_symbols(&mut self, tmpdir: &Path, crate_type: CrateType);\n     fn subsystem(&mut self, subsystem: &str);\n@@ -179,6 +180,7 @@ impl<'a> Linker for GccLinker<'a> {\n     fn position_independent_executable(&mut self) { self.cmd.arg(\"-pie\"); }\n     fn partial_relro(&mut self) { self.linker_arg(\"-z,relro\"); }\n     fn full_relro(&mut self) { self.linker_arg(\"-z,relro,-z,now\"); }\n+    fn build_static_executable(&mut self) { self.cmd.arg(\"-static\"); }\n     fn args(&mut self, args: &[String]) { self.cmd.args(args); }\n \n     fn link_rust_dylib(&mut self, lib: &str, _path: &Path) {\n@@ -396,6 +398,10 @@ impl<'a> Linker for MsvcLinker<'a> {\n         self.cmd.arg(arg);\n     }\n \n+    fn build_static_executable(&mut self) {\n+        // noop\n+    }\n+\n     fn gc_sections(&mut self, _keep_metadata: bool) {\n         // MSVC's ICF (Identical COMDAT Folding) link optimization is\n         // slow for Rust and thus we disable it by default when not in\n@@ -683,6 +689,10 @@ impl<'a> Linker for EmLinker<'a> {\n         bug!(\"building dynamic library is unsupported on Emscripten\")\n     }\n \n+    fn build_static_executable(&mut self) {\n+        // noop\n+    }\n+\n     fn export_symbols(&mut self, _tmpdir: &Path, crate_type: CrateType) {\n         let symbols = &self.info.exports[&crate_type];\n "}, {"sha": "aa8637fabe85f0e10cf7b95c9992cc861eb5eb21", "filename": "src/librustc_trans_utils/link.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c872f4727697327550d43d106f5dddd735c41e5f/src%2Flibrustc_trans_utils%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c872f4727697327550d43d106f5dddd735c41e5f/src%2Flibrustc_trans_utils%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans_utils%2Flink.rs?ref=c872f4727697327550d43d106f5dddd735c41e5f", "patch": "@@ -123,8 +123,11 @@ pub fn invalid_output_for_target(sess: &Session,\n     match (sess.target.target.options.dynamic_linking,\n            sess.target.target.options.executables, crate_type) {\n         (false, _, config::CrateTypeCdylib) |\n-        (false, _, config::CrateTypeProcMacro) |\n-        (false, _, config::CrateTypeDylib) => true,\n+        (false, _, config::CrateTypeDylib) |\n+        (false, _, config::CrateTypeProcMacro) => true,\n+        (true, _, config::CrateTypeCdylib) |\n+        (true, _, config::CrateTypeDylib) => sess.crt_static() &&\n+            !sess.target.target.options.crt_static_allows_dylibs,\n         (_, false, config::CrateTypeExecutable) => true,\n         _ => false\n     }"}, {"sha": "ee1e6bd950fa17e8c8385511d9284b1e7743d73e", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 31, "deletions": 133, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/c872f4727697327550d43d106f5dddd735c41e5f/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c872f4727697327550d43d106f5dddd735c41e5f/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=c872f4727697327550d43d106f5dddd735c41e5f", "patch": "@@ -22,16 +22,14 @@ use rustc::ty::subst::{Kind, Subst, Substs};\n use rustc::traits;\n use rustc::ty::{self, Ty, TyCtxt, ToPredicate, TypeFoldable};\n use rustc::ty::wf::object_region_bounds;\n-use rustc::lint::builtin::PARENTHESIZED_PARAMS_IN_TYPES_AND_MODULES;\n use rustc_back::slice;\n use require_c_abi_if_variadic;\n-use util::common::{ErrorReported, FN_OUTPUT_NAME};\n+use util::common::ErrorReported;\n use util::nodemap::FxHashSet;\n \n use std::iter;\n use syntax::{abi, ast};\n use syntax::feature_gate::{GateIssue, emit_feature_err};\n-use syntax::symbol::Symbol;\n use syntax_pos::Span;\n \n pub trait AstConv<'gcx, 'tcx> {\n@@ -152,21 +150,6 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         item_segment: &hir::PathSegment)\n         -> &'tcx Substs<'tcx>\n     {\n-        let tcx = self.tcx();\n-\n-        match item_segment.parameters {\n-            hir::AngleBracketedParameters(_) => {}\n-            hir::ParenthesizedParameters(..) => {\n-                self.prohibit_parenthesized_params(item_segment, true);\n-\n-                return Substs::for_item(tcx, def_id, |_, _| {\n-                    tcx.types.re_static\n-                }, |_, _| {\n-                    tcx.types.err\n-                });\n-            }\n-        }\n-\n         let (substs, assoc_bindings) =\n             self.create_substs_for_ast_path(span,\n                                             def_id,\n@@ -196,19 +179,13 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                parameters={:?})\",\n                def_id, self_ty, parameters);\n \n-        let (lifetimes, num_types_provided, infer_types) = match *parameters {\n-            hir::AngleBracketedParameters(ref data) => {\n-                (&data.lifetimes[..], data.types.len(), data.infer_types)\n-            }\n-            hir::ParenthesizedParameters(_) => (&[][..], 1, false)\n-        };\n-\n         // If the type is parameterized by this region, then replace this\n         // region with the current anon region binding (in other words,\n         // whatever & would get replaced with).\n         let decl_generics = tcx.generics_of(def_id);\n+        let num_types_provided = parameters.types.len();\n         let expected_num_region_params = decl_generics.regions.len();\n-        let supplied_num_region_params = lifetimes.len();\n+        let supplied_num_region_params = parameters.lifetimes.len();\n         if expected_num_region_params != supplied_num_region_params {\n             report_lifetime_number_error(tcx, span,\n                                          supplied_num_region_params,\n@@ -220,7 +197,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n \n         // Check the number of type parameters supplied by the user.\n         let ty_param_defs = &decl_generics.types[self_ty.is_some() as usize..];\n-        if !infer_types || num_types_provided > ty_param_defs.len() {\n+        if !parameters.infer_types || num_types_provided > ty_param_defs.len() {\n             check_type_argument_count(tcx, span, num_types_provided, ty_param_defs);\n         }\n \n@@ -237,10 +214,9 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             false\n         };\n \n-        let mut output_assoc_binding = None;\n         let substs = Substs::for_item(tcx, def_id, |def, _| {\n             let i = def.index as usize - self_ty.is_some() as usize;\n-            if let Some(lifetime) = lifetimes.get(i) {\n+            if let Some(lifetime) = parameters.lifetimes.get(i) {\n                 self.ast_region_to_region(lifetime, Some(def))\n             } else {\n                 tcx.types.re_static\n@@ -256,18 +232,8 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             let i = i - self_ty.is_some() as usize - decl_generics.regions.len();\n             if i < num_types_provided {\n                 // A provided type parameter.\n-                match *parameters {\n-                    hir::AngleBracketedParameters(ref data) => {\n-                        self.ast_ty_to_ty(&data.types[i])\n-                    }\n-                    hir::ParenthesizedParameters(ref data) => {\n-                        assert_eq!(i, 0);\n-                        let (ty, assoc) = self.convert_parenthesized_parameters(data);\n-                        output_assoc_binding = Some(assoc);\n-                        ty\n-                    }\n-                }\n-            } else if infer_types {\n+                self.ast_ty_to_ty(&parameters.types[i])\n+            } else if parameters.infer_types {\n                 // No type parameters were provided, we can infer all.\n                 let ty_var = if !default_needs_object_self(def) {\n                     self.ty_infer_for_def(def, substs, span)\n@@ -306,57 +272,20 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             }\n         });\n \n-        let assoc_bindings = match *parameters {\n-            hir::AngleBracketedParameters(ref data) => {\n-                data.bindings.iter().map(|b| {\n-                    ConvertedBinding {\n-                        item_name: b.name,\n-                        ty: self.ast_ty_to_ty(&b.ty),\n-                        span: b.span\n-                    }\n-                }).collect()\n-            }\n-            hir::ParenthesizedParameters(ref data) => {\n-                vec![output_assoc_binding.unwrap_or_else(|| {\n-                    // This is an error condition, but we should\n-                    // get the associated type binding anyway.\n-                    self.convert_parenthesized_parameters(data).1\n-                })]\n+        let assoc_bindings = parameters.bindings.iter().map(|binding| {\n+            ConvertedBinding {\n+                item_name: binding.name,\n+                ty: self.ast_ty_to_ty(&binding.ty),\n+                span: binding.span,\n             }\n-        };\n+        }).collect();\n \n         debug!(\"create_substs_for_ast_path(decl_generics={:?}, self_ty={:?}) -> {:?}\",\n                decl_generics, self_ty, substs);\n \n         (substs, assoc_bindings)\n     }\n \n-    fn convert_parenthesized_parameters(&self,\n-                                        data: &hir::ParenthesizedParameterData)\n-                                        -> (Ty<'tcx>, ConvertedBinding<'tcx>)\n-    {\n-        let inputs = self.tcx().mk_type_list(data.inputs.iter().map(|a_t| {\n-            self.ast_ty_to_ty(a_t)\n-        }));\n-\n-        let (output, output_span) = match data.output {\n-            Some(ref output_ty) => {\n-                (self.ast_ty_to_ty(output_ty), output_ty.span)\n-            }\n-            None => {\n-                (self.tcx().mk_nil(), data.span)\n-            }\n-        };\n-\n-        let output_binding = ConvertedBinding {\n-            item_name: Symbol::intern(FN_OUTPUT_NAME),\n-            ty: output,\n-            span: output_span\n-        };\n-\n-        (self.tcx().mk_ty(ty::TyTuple(inputs, false)), output_binding)\n-    }\n-\n     /// Instantiates the path for the given trait reference, assuming that it's\n     /// bound to a valid trait type. Returns the def_id for the defining trait.\n     /// Fails if the type is a type other than a trait type.\n@@ -453,29 +382,17 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n \n         let trait_def = self.tcx().trait_def(trait_def_id);\n \n-        match trait_segment.parameters {\n-            hir::AngleBracketedParameters(_) => {\n-                // For now, require that parenthetical notation be used\n-                // only with `Fn()` etc.\n-                if !self.tcx().sess.features.borrow().unboxed_closures && trait_def.paren_sugar {\n-                    emit_feature_err(&self.tcx().sess.parse_sess,\n-                                     \"unboxed_closures\", span, GateIssue::Language,\n-                                     \"\\\n-                        the precise format of `Fn`-family traits' \\\n-                        type parameters is subject to change. \\\n-                        Use parenthetical notation (Fn(Foo, Bar) -> Baz) instead\");\n-                }\n-            }\n-            hir::ParenthesizedParameters(_) => {\n-                // For now, require that parenthetical notation be used\n-                // only with `Fn()` etc.\n-                if !self.tcx().sess.features.borrow().unboxed_closures && !trait_def.paren_sugar {\n-                    emit_feature_err(&self.tcx().sess.parse_sess,\n-                                     \"unboxed_closures\", span, GateIssue::Language,\n-                                     \"\\\n-                        parenthetical notation is only stable when used with `Fn`-family traits\");\n-                }\n-            }\n+        if !self.tcx().sess.features.borrow().unboxed_closures &&\n+           trait_segment.parameters.parenthesized != trait_def.paren_sugar {\n+            // For now, require that parenthetical notation be used only with `Fn()` etc.\n+            let msg = if trait_def.paren_sugar {\n+                \"the precise format of `Fn`-family traits' type parameters is subject to change. \\\n+                 Use parenthetical notation (Fn(Foo, Bar) -> Baz) instead\"\n+            } else {\n+                \"parenthetical notation is only stable when used with `Fn`-family traits\"\n+            };\n+            emit_feature_err(&self.tcx().sess.parse_sess, \"unboxed_closures\",\n+                             span, GateIssue::Language, msg);\n         }\n \n         self.create_substs_for_ast_path(span,\n@@ -951,47 +868,28 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n \n     pub fn prohibit_type_params(&self, segments: &[hir::PathSegment]) {\n         for segment in segments {\n-            if let hir::ParenthesizedParameters(_) = segment.parameters {\n-                self.prohibit_parenthesized_params(segment, false);\n-                break;\n-            }\n-            for typ in segment.parameters.types() {\n+            for typ in &segment.parameters.types {\n                 struct_span_err!(self.tcx().sess, typ.span, E0109,\n                                  \"type parameters are not allowed on this type\")\n                     .span_label(typ.span, \"type parameter not allowed\")\n                     .emit();\n                 break;\n             }\n-            for lifetime in segment.parameters.lifetimes() {\n+            for lifetime in &segment.parameters.lifetimes {\n                 struct_span_err!(self.tcx().sess, lifetime.span, E0110,\n                                  \"lifetime parameters are not allowed on this type\")\n                     .span_label(lifetime.span,\n                                 \"lifetime parameter not allowed on this type\")\n                     .emit();\n                 break;\n             }\n-            for binding in segment.parameters.bindings() {\n+            for binding in &segment.parameters.bindings {\n                 self.prohibit_projection(binding.span);\n                 break;\n             }\n         }\n     }\n \n-    pub fn prohibit_parenthesized_params(&self, segment: &hir::PathSegment, emit_error: bool) {\n-        if let hir::ParenthesizedParameters(ref data) = segment.parameters {\n-            if emit_error {\n-                struct_span_err!(self.tcx().sess, data.span, E0214,\n-                          \"parenthesized parameters may only be used with a trait\")\n-                    .span_label(data.span, \"only traits may use parentheses\")\n-                    .emit();\n-            } else {\n-                let msg = \"parenthesized parameters may only be used with a trait\";\n-                self.tcx().lint_node(PARENTHESIZED_PARAMS_IN_TYPES_AND_MODULES,\n-                                     ast::CRATE_NODE_ID, data.span, msg);\n-            }\n-        }\n-    }\n-\n     pub fn prohibit_projection(&self, span: Span) {\n         let mut err = struct_span_err!(self.tcx().sess, span, E0229,\n                                        \"associated type bindings are not allowed here\");\n@@ -1392,13 +1290,13 @@ fn split_auto_traits<'a, 'b, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                     Some(trait_did) == tcx.lang_items.sync_trait() {\n                     let segments = &bound.trait_ref.path.segments;\n                     let parameters = &segments[segments.len() - 1].parameters;\n-                    if !parameters.types().is_empty() {\n+                    if !parameters.types.is_empty() {\n                         check_type_argument_count(tcx, bound.trait_ref.path.span,\n-                                                  parameters.types().len(), &[]);\n+                                                  parameters.types.len(), &[]);\n                     }\n-                    if !parameters.lifetimes().is_empty() {\n+                    if !parameters.lifetimes.is_empty() {\n                         report_lifetime_number_error(tcx, bound.trait_ref.path.span,\n-                                                     parameters.lifetimes().len(), 0);\n+                                                     parameters.lifetimes.len(), 0);\n                     }\n                     true\n                 } else {"}, {"sha": "e406ce845a6d11d4770dfca6483acfb26712fe20", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c872f4727697327550d43d106f5dddd735c41e5f/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c872f4727697327550d43d106f5dddd735c41e5f/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=c872f4727697327550d43d106f5dddd735c41e5f", "patch": "@@ -807,8 +807,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             let lub_ty = self.commit_if_ok(|_| {\n                 self.at(cause, self.param_env)\n                     .lub(prev_ty, new_ty)\n-                    .map(|ok| self.register_infer_ok_obligations(ok))\n-            });\n+            }).map(|ok| self.register_infer_ok_obligations(ok));\n \n             if lub_ty.is_ok() {\n                 // We have a LUB of prev_ty and new_ty, just return it.\n@@ -884,8 +883,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 return self.commit_if_ok(|_| {\n                     self.at(cause, self.param_env)\n                         .lub(prev_ty, new_ty)\n-                        .map(|ok| self.register_infer_ok_obligations(ok))\n-                });\n+                }).map(|ok| self.register_infer_ok_obligations(ok));\n             }\n         }\n \n@@ -898,8 +896,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     self.commit_if_ok(|_| {\n                         self.at(cause, self.param_env)\n                             .lub(prev_ty, new_ty)\n-                            .map(|ok| self.register_infer_ok_obligations(ok))\n-                    })\n+                    }).map(|ok| self.register_infer_ok_obligations(ok))\n                 }\n             }\n             Ok(ok) => {"}, {"sha": "db383b6305b4a424fd60490907442f62c2e92363", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c872f4727697327550d43d106f5dddd735c41e5f/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c872f4727697327550d43d106f5dddd735c41e5f/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=c872f4727697327550d43d106f5dddd735c41e5f", "patch": "@@ -311,17 +311,14 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n \n         // Create subst for early-bound lifetime parameters, combining\n         // parameters from the type and those from the method.\n-        let (supplied_types, supplied_lifetimes) = match segment.parameters {\n-            hir::AngleBracketedParameters(ref data) => (&data.types, &data.lifetimes),\n-            _ => bug!(\"unexpected generic arguments: {:?}\", segment.parameters),\n-        };\n         assert_eq!(method_generics.parent_count(), parent_substs.len());\n+        let provided = &segment.parameters;\n         Substs::for_item(self.tcx, pick.item.def_id, |def, _| {\n             let i = def.index as usize;\n             if i < parent_substs.len() {\n                 parent_substs.region_at(i)\n-            } else if let Some(lifetime) =\n-                    supplied_lifetimes.get(i - parent_substs.len()) {\n+            } else if let Some(lifetime)\n+                    = provided.lifetimes.get(i - parent_substs.len()) {\n                 AstConv::ast_region_to_region(self.fcx, lifetime, Some(def))\n             } else {\n                 self.region_var_for_def(self.span, def)\n@@ -330,8 +327,8 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n             let i = def.index as usize;\n             if i < parent_substs.len() {\n                 parent_substs.type_at(i)\n-            } else if let Some(ast_ty) =\n-                    supplied_types.get(i - parent_substs.len() - method_generics.regions.len()) {\n+            } else if let Some(ast_ty)\n+                    = provided.types.get(i - parent_substs.len() - method_generics.regions.len()) {\n                 self.to_ty(ast_ty)\n             } else {\n                 self.type_var_for_def(self.span, def, cur_substs)"}, {"sha": "3cc568bbbde88a2712a9a28284d9cda69652ed74", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 9, "deletions": 28, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/c872f4727697327550d43d106f5dddd735c41e5f/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c872f4727697327550d43d106f5dddd735c41e5f/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=c872f4727697327550d43d106f5dddd735c41e5f", "patch": "@@ -4678,11 +4678,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 i -= fn_start;\n                 fn_segment\n             };\n-            let lifetimes = match segment.map(|(s, _)| &s.parameters) {\n-                Some(&hir::AngleBracketedParameters(ref data)) => &data.lifetimes[..],\n-                Some(&hir::ParenthesizedParameters(_)) => bug!(),\n-                None => &[]\n-            };\n+            let lifetimes = segment.map_or(&[][..], |(s, _)| &s.parameters.lifetimes[..]);\n \n             if let Some(lifetime) = lifetimes.get(i) {\n                 AstConv::ast_region_to_region(self, lifetime, Some(def))\n@@ -4705,13 +4701,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 i -= fn_start;\n                 fn_segment\n             };\n-            let (types, infer_types) = match segment.map(|(s, _)| &s.parameters) {\n-                Some(&hir::AngleBracketedParameters(ref data)) => {\n-                    (&data.types[..], data.infer_types)\n-                }\n-                Some(&hir::ParenthesizedParameters(_)) => bug!(),\n-                None => (&[][..], true)\n-            };\n+            let (types, infer_types) = segment.map_or((&[][..], true), |(s, _)| {\n+                (&s.parameters.types[..], s.parameters.infer_types)\n+            });\n \n             // Skip over the lifetimes in the same segment.\n             if let Some((_, generics)) = segment {\n@@ -4785,19 +4777,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                   span: Span,\n                                   segment: &mut Option<(&hir::PathSegment, &ty::Generics)>,\n                                   is_method_call: bool) {\n-        let (lifetimes, types, infer_types, bindings) = {\n-            match segment.map(|(s, _)| &s.parameters) {\n-                Some(&hir::AngleBracketedParameters(ref data)) => {\n-                    (&data.lifetimes[..], &data.types[..], data.infer_types, &data.bindings[..])\n-                }\n-                Some(&hir::ParenthesizedParameters(_)) => {\n-                    AstConv::prohibit_parenthesized_params(self, &segment.as_ref().unwrap().0,\n-                                                           false);\n-                    (&[][..], &[][..], true, &[][..])\n-                }\n-                None => (&[][..], &[][..], true, &[][..])\n-            }\n-        };\n+        let (lifetimes, types, infer_types, bindings) = segment.map_or(\n+            (&[][..], &[][..], true, &[][..]),\n+            |(s, _)| (&s.parameters.lifetimes[..], &s.parameters.types[..],\n+                      s.parameters.infer_types, &s.parameters.bindings[..]));\n         let infer_lifetimes = lifetimes.len() == 0;\n \n         let count_lifetime_params = |n| {\n@@ -4843,9 +4826,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         }\n \n         if !bindings.is_empty() {\n-            span_err!(self.tcx.sess, bindings[0].span, E0182,\n-                      \"unexpected binding of associated item in expression path \\\n-                       (only allowed in type paths)\");\n+            AstConv::prohibit_projection(self, bindings[0].span);\n         }\n \n         // Check provided lifetime parameters."}, {"sha": "377908b1ab9d40e2f2059f74f9f09de29b58ff51", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c872f4727697327550d43d106f5dddd735c41e5f/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c872f4727697327550d43d106f5dddd735c41e5f/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=c872f4727697327550d43d106f5dddd735c41e5f", "patch": "@@ -1814,12 +1814,12 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n                     // check whether this predicate applies to our current projection\n                     let cause = self.fcx.misc(span);\n                     match self.at(&cause, self.fcx.param_env).eq(outlives.0, ty) {\n-                        Ok(ok) => {\n-                            self.register_infer_ok_obligations(ok);\n-                            Ok(outlives.1)\n-                        }\n-                        Err(_) => { Err(()) }\n+                        Ok(ok) => Ok((ok, outlives.1)),\n+                        Err(_) => Err(())\n                     }\n+                }).map(|(ok, result)| {\n+                    self.register_infer_ok_obligations(ok);\n+                    result\n                 });\n \n                 debug!(\"projection_bounds: region_result={:?}\","}, {"sha": "375099350444261d097ab92df3a24a367dbdd887", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 54, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/c872f4727697327550d43d106f5dddd735c41e5f/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c872f4727697327550d43d106f5dddd735c41e5f/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=c872f4727697327550d43d106f5dddd735c41e5f", "patch": "@@ -1636,45 +1636,6 @@ fn bar(foo: Foo) -> u32 {\n ```\n \"##,\n \n-E0182: r##\"\n-You bound an associated type in an expression path which is not\n-allowed.\n-\n-Erroneous code example:\n-\n-```compile_fail,E0182\n-trait Foo {\n-    type A;\n-    fn bar() -> isize;\n-}\n-\n-impl Foo for isize {\n-    type A = usize;\n-    fn bar() -> isize { 42 }\n-}\n-\n-// error: unexpected binding of associated item in expression path\n-let x: isize = Foo::<A=usize>::bar();\n-```\n-\n-To give a concrete type when using the Universal Function Call Syntax,\n-use \"Type as Trait\". Example:\n-\n-```\n-trait Foo {\n-    type A;\n-    fn bar() -> isize;\n-}\n-\n-impl Foo for isize {\n-    type A = usize;\n-    fn bar() -> isize { 42 }\n-}\n-\n-let x: isize = <isize as Foo>::bar(); // ok!\n-```\n-\"##,\n-\n E0184: r##\"\n Explicitly implementing both Drop and Copy for a type is currently disallowed.\n This feature can make some sense in theory, but the current implementation is\n@@ -2359,21 +2320,6 @@ impl Foo {\n \"##,\n      */\n \n-E0214: r##\"\n-A generic type was described using parentheses rather than angle brackets. For\n-example:\n-\n-```compile_fail,E0214\n-fn main() {\n-    let v: Vec(&str) = vec![\"foo\"];\n-}\n-```\n-\n-This is not currently supported: `v` should be defined as `Vec<&str>`.\n-Parentheses are currently only used with generic types when defining parameters\n-for `Fn`-family traits.\n-\"##,\n-\n E0220: r##\"\n You used an associated type which isn't defined in the trait.\n Erroneous code example:\n@@ -4721,6 +4667,7 @@ register_diagnostics! {\n //  E0172, // non-trait found in a type sum, moved to resolve\n //  E0173, // manual implementations of unboxed closure traits are experimental\n //  E0174,\n+//  E0182, // merged into E0229\n     E0183,\n //  E0187, // can't infer the kind of the closure\n //  E0188, // can not cast an immutable reference to a mutable pointer"}, {"sha": "42a4e4423c8d17186414c19df2f3e243ee50773f", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 16, "deletions": 21, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/c872f4727697327550d43d106f5dddd735c41e5f/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c872f4727697327550d43d106f5dddd735c41e5f/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=c872f4727697327550d43d106f5dddd735c41e5f", "patch": "@@ -1794,16 +1794,14 @@ impl Clean<Type> for hir::Ty {\n                     let mut lt_substs = FxHashMap();\n                     for (i, ty_param) in generics.ty_params.iter().enumerate() {\n                         let ty_param_def = Def::TyParam(cx.tcx.hir.local_def_id(ty_param.id));\n-                        if let Some(ty) = provided_params.types().get(i).cloned()\n-                                                                        .cloned() {\n+                        if let Some(ty) = provided_params.types.get(i).cloned() {\n                             ty_substs.insert(ty_param_def, ty.unwrap().clean(cx));\n                         } else if let Some(default) = ty_param.default.clone() {\n                             ty_substs.insert(ty_param_def, default.unwrap().clean(cx));\n                         }\n                     }\n                     for (i, lt_param) in generics.lifetimes.iter().enumerate() {\n-                        if let Some(lt) = provided_params.lifetimes().get(i).cloned()\n-                                                                            .cloned() {\n+                        if let Some(lt) = provided_params.lifetimes.get(i).cloned() {\n                             if !lt.is_elided() {\n                                 lt_substs.insert(lt_param.lifetime.id, lt.clean(cx));\n                             }\n@@ -2314,24 +2312,21 @@ pub enum PathParameters {\n \n impl Clean<PathParameters> for hir::PathParameters {\n     fn clean(&self, cx: &DocContext) -> PathParameters {\n-        match *self {\n-            hir::AngleBracketedParameters(ref data) => {\n-                PathParameters::AngleBracketed {\n-                    lifetimes: if data.lifetimes.iter().all(|lt| lt.is_elided()) {\n-                        vec![]\n-                    } else {\n-                        data.lifetimes.clean(cx)\n-                    },\n-                    types: data.types.clean(cx),\n-                    bindings: data.bindings.clean(cx),\n-                }\n+        if self.parenthesized {\n+            let output = self.bindings[0].ty.clean(cx);\n+            PathParameters::Parenthesized {\n+                inputs: self.inputs().clean(cx),\n+                output: if output != Type::Tuple(Vec::new()) { Some(output) } else { None }\n             }\n-\n-            hir::ParenthesizedParameters(ref data) => {\n-                PathParameters::Parenthesized {\n-                    inputs: data.inputs.clean(cx),\n-                    output: data.output.clean(cx),\n-                }\n+        } else {\n+            PathParameters::AngleBracketed {\n+                lifetimes: if self.lifetimes.iter().all(|lt| lt.is_elided()) {\n+                    vec![]\n+                } else {\n+                    self.lifetimes.clean(cx)\n+                },\n+                types: self.types.clean(cx),\n+                bindings: self.bindings.clean(cx),\n             }\n         }\n     }"}, {"sha": "26a64f6cd2245620d8d4d66220fa0c9e516b7f70", "filename": "src/librustdoc/html/static/rustdoc.css", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c872f4727697327550d43d106f5dddd735c41e5f/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/c872f4727697327550d43d106f5dddd735c41e5f/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css?ref=c872f4727697327550d43d106f5dddd735c41e5f", "patch": "@@ -126,6 +126,10 @@ p {\n \tmargin: 0 0 .6em 0;\n }\n \n+summary {\n+\toutline: none;\n+}\n+\n code, pre {\n \tfont-family: \"Source Code Pro\", Menlo, Monaco, Consolas, \"DejaVu Sans Mono\", Inconsolata, monospace;\n \twhite-space: pre-wrap;"}, {"sha": "f57dec98b795b652ffea961e3c97b52203b28a71", "filename": "src/libstd/build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c872f4727697327550d43d106f5dddd735c41e5f/src%2Flibstd%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c872f4727697327550d43d106f5dddd735c41e5f/src%2Flibstd%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbuild.rs?ref=c872f4727697327550d43d106f5dddd735c41e5f", "patch": "@@ -30,7 +30,7 @@ fn main() {\n             println!(\"cargo:rustc-link-lib=dl\");\n             println!(\"cargo:rustc-link-lib=log\");\n             println!(\"cargo:rustc-link-lib=gcc\");\n-        } else if !target.contains(\"musl\") || target.contains(\"mips\") {\n+        } else if !target.contains(\"musl\") {\n             println!(\"cargo:rustc-link-lib=dl\");\n             println!(\"cargo:rustc-link-lib=rt\");\n             println!(\"cargo:rustc-link-lib=pthread\");"}, {"sha": "0fff833e7d83e2a9bc93f1fd07150a1a3cfe4278", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 65, "deletions": 41, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/c872f4727697327550d43d106f5dddd735c41e5f/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c872f4727697327550d43d106f5dddd735c41e5f/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=c872f4727697327550d43d106f5dddd735c41e5f", "patch": "@@ -401,28 +401,29 @@ fn read_to_end<R: Read + ?Sized>(r: &mut R, buf: &mut Vec<u8>) -> Result<usize>\n ///\n /// Implementors of the `Read` trait are called 'readers'.\n ///\n-/// Readers are defined by one required method, `read()`. Each call to `read`\n+/// Readers are defined by one required method, [`read()`]. Each call to [`read()`]\n /// will attempt to pull bytes from this source into a provided buffer. A\n-/// number of other methods are implemented in terms of `read()`, giving\n+/// number of other methods are implemented in terms of [`read()`], giving\n /// implementors a number of ways to read bytes while only needing to implement\n /// a single method.\n ///\n /// Readers are intended to be composable with one another. Many implementors\n-/// throughout `std::io` take and provide types which implement the `Read`\n+/// throughout [`std::io`] take and provide types which implement the `Read`\n /// trait.\n ///\n-/// Please note that each call to `read` may involve a system call, and\n-/// therefore, using something that implements [`BufRead`][bufread], such as\n-/// [`BufReader`][bufreader], will be more efficient.\n-///\n-/// [bufread]: trait.BufRead.html\n-/// [bufreader]: struct.BufReader.html\n+/// Please note that each call to [`read()`] may involve a system call, and\n+/// therefore, using something that implements [`BufRead`], such as\n+/// [`BufReader`], will be more efficient.\n ///\n /// # Examples\n ///\n-/// [`File`][file]s implement `Read`:\n+/// [`File`]s implement `Read`:\n ///\n-/// [file]: ../fs/struct.File.html\n+/// [`read()`]: trait.Read.html#tymethod.read\n+/// [`std::io`]: ../../std/io/index.html\n+/// [`File`]: ../fs/struct.File.html\n+/// [`BufRead`]: trait.BufRead.html\n+/// [`BufReader`]: struct.BufReader.html\n ///\n /// ```\n /// use std::io;\n@@ -455,9 +456,9 @@ pub trait Read {\n     ///\n     /// This function does not provide any guarantees about whether it blocks\n     /// waiting for data, but if an object needs to block for a read but cannot\n-    /// it will typically signal this via an `Err` return value.\n+    /// it will typically signal this via an [`Err`] return value.\n     ///\n-    /// If the return value of this method is `Ok(n)`, then it must be\n+    /// If the return value of this method is [`Ok(n)`], then it must be\n     /// guaranteed that `0 <= n <= buf.len()`. A nonzero `n` value indicates\n     /// that the buffer `buf` has been filled in with `n` bytes of data from this\n     /// source. If `n` is `0`, then it can indicate one of two scenarios:\n@@ -478,14 +479,17 @@ pub trait Read {\n     /// variant will be returned. If an error is returned then it must be\n     /// guaranteed that no bytes were read.\n     ///\n-    /// An error of the `ErrorKind::Interrupted` kind is non-fatal and the read\n+    /// An error of the [`ErrorKind::Interrupted`] kind is non-fatal and the read\n     /// operation should be retried if there is nothing else to do.\n     ///\n     /// # Examples\n     ///\n-    /// [`File`][file]s implement `Read`:\n+    /// [`File`]s implement `Read`:\n     ///\n-    /// [file]: ../fs/struct.File.html\n+    /// [`Err`]: ../../std/result/enum.Result.html#variant.Err\n+    /// [`Ok(n)`]: ../../std/result/enum.Result.html#variant.Ok\n+    /// [`ErrorKind::Interrupted`]: ../../std/io/enum.ErrorKind.html#variant.Interrupted\n+    /// [`File`]: ../fs/struct.File.html\n     ///\n     /// ```\n     /// use std::io;\n@@ -511,8 +515,8 @@ pub trait Read {\n     /// buffers.\n     ///\n     /// If a `Read`er guarantees that it can work properly with uninitialized\n-    /// memory, it should call `Initializer::nop()`. See the documentation for\n-    /// `Initializer` for details.\n+    /// memory, it should call [`Initializer::nop()`]. See the documentation for\n+    /// [`Initializer`] for details.\n     ///\n     /// The behavior of this method must be independent of the state of the\n     /// `Read`er - the method only takes `&self` so that it can be used through\n@@ -523,6 +527,9 @@ pub trait Read {\n     /// This method is unsafe because a `Read`er could otherwise return a\n     /// non-zeroing `Initializer` from another `Read` type without an `unsafe`\n     /// block.\n+    ///\n+    /// [`Initializer::nop()`]: ../../std/io/struct.Initializer.html#method.nop\n+    /// [`Initializer`]: ../../std/io/struct.Initializer.html\n     #[unstable(feature = \"read_initializer\", issue = \"42788\")]\n     #[inline]\n     unsafe fn initializer(&self) -> Initializer {\n@@ -532,16 +539,16 @@ pub trait Read {\n     /// Read all bytes until EOF in this source, placing them into `buf`.\n     ///\n     /// All bytes read from this source will be appended to the specified buffer\n-    /// `buf`. This function will continuously call `read` to append more data to\n-    /// `buf` until `read` returns either `Ok(0)` or an error of\n-    /// non-`ErrorKind::Interrupted` kind.\n+    /// `buf`. This function will continuously call [`read()`] to append more data to\n+    /// `buf` until [`read()`] returns either [`Ok(0)`] or an error of\n+    /// non-[`ErrorKind::Interrupted`] kind.\n     ///\n     /// If successful, this function will return the total number of bytes read.\n     ///\n     /// # Errors\n     ///\n     /// If this function encounters an error of the kind\n-    /// `ErrorKind::Interrupted` then the error is ignored and the operation\n+    /// [`ErrorKind::Interrupted`] then the error is ignored and the operation\n     /// will continue.\n     ///\n     /// If any other read error is encountered then this function immediately\n@@ -550,9 +557,12 @@ pub trait Read {\n     ///\n     /// # Examples\n     ///\n-    /// [`File`][file]s implement `Read`:\n+    /// [`File`]s implement `Read`:\n     ///\n-    /// [file]: ../fs/struct.File.html\n+    /// [`read()`]: trait.Read.html#tymethod.read\n+    /// [`Ok(0)`]: ../../std/result/enum.Result.html#variant.Ok\n+    /// [`ErrorKind::Interrupted`]: ../../std/io/enum.ErrorKind.html#variant.Interrupted\n+    /// [`File`]: ../fs/struct.File.html\n     ///\n     /// ```\n     /// use std::io;\n@@ -633,11 +643,11 @@ pub trait Read {\n     /// # Errors\n     ///\n     /// If this function encounters an error of the kind\n-    /// `ErrorKind::Interrupted` then the error is ignored and the operation\n+    /// [`ErrorKind::Interrupted`] then the error is ignored and the operation\n     /// will continue.\n     ///\n     /// If this function encounters an \"end of file\" before completely filling\n-    /// the buffer, it returns an error of the kind `ErrorKind::UnexpectedEof`.\n+    /// the buffer, it returns an error of the kind [`ErrorKind::UnexpectedEof`].\n     /// The contents of `buf` are unspecified in this case.\n     ///\n     /// If any other read error is encountered then this function immediately\n@@ -649,9 +659,11 @@ pub trait Read {\n     ///\n     /// # Examples\n     ///\n-    /// [`File`][file]s implement `Read`:\n+    /// [`File`]s implement `Read`:\n     ///\n-    /// [file]: ../fs/struct.File.html\n+    /// [`File`]: ../fs/struct.File.html\n+    /// [`ErrorKind::Interrupted`]: ../../std/io/enum.ErrorKind.html#variant.Interrupted\n+    /// [`ErrorKind::UnexpectedEof`]: ../../std/io/enum.ErrorKind.html#variant.UnexpectedEof\n     ///\n     /// ```\n     /// use std::io;\n@@ -722,18 +734,24 @@ pub trait Read {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn by_ref(&mut self) -> &mut Self where Self: Sized { self }\n \n-    /// Transforms this `Read` instance to an `Iterator` over its bytes.\n+    /// Transforms this `Read` instance to an [`Iterator`] over its bytes.\n     ///\n-    /// The returned type implements `Iterator` where the `Item` is `Result<u8,\n-    /// R::Err>`.  The yielded item is `Ok` if a byte was successfully read and\n-    /// `Err` otherwise for I/O errors. EOF is mapped to returning `None` from\n+    /// The returned type implements [`Iterator`] where the `Item` is [`Result`]`<`[`u8`]`,\n+    /// R::Err>`. The yielded item is [`Ok`] if a byte was successfully read and\n+    /// [`Err`] otherwise for I/O errors. EOF is mapped to returning [`None`] from\n     /// this iterator.\n     ///\n     /// # Examples\n     ///\n     /// [`File`][file]s implement `Read`:\n     ///\n     /// [file]: ../fs/struct.File.html\n+    /// [`Iterator`]: ../../std/iter/trait.Iterator.html\n+    /// [`Result`]: ../../std/result/enum.Result.html\n+    /// [`u8`]: ../../std/primitive.u8.html\n+    /// [`Ok`]: ../../std/result/enum.Result.html#variant.Ok\n+    /// [`Err`]: ../../std/result/enum.Result.html#variant.Err\n+    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n     ///\n     /// ```\n     /// use std::io;\n@@ -754,22 +772,26 @@ pub trait Read {\n         Bytes { inner: self }\n     }\n \n-    /// Transforms this `Read` instance to an `Iterator` over `char`s.\n+    /// Transforms this `Read` instance to an [`Iterator`] over [`char`]s.\n     ///\n     /// This adaptor will attempt to interpret this reader as a UTF-8 encoded\n-    /// sequence of characters. The returned iterator will return `None` once\n+    /// sequence of characters. The returned iterator will return [`None`] once\n     /// EOF is reached for this reader. Otherwise each element yielded will be a\n-    /// `Result<char, E>` where `E` may contain information about what I/O error\n+    /// [`Result`]`<`[`char`]`, E>` where `E` may contain information about what I/O error\n     /// occurred or where decoding failed.\n     ///\n     /// Currently this adaptor will discard intermediate data read, and should\n     /// be avoided if this is not desired.\n     ///\n     /// # Examples\n     ///\n-    /// [`File`][file]s implement `Read`:\n+    /// [`File`]s implement `Read`:\n     ///\n-    /// [file]: ../fs/struct.File.html\n+    /// [`File`]: ../fs/struct.File.html\n+    /// [`Iterator`]: ../../std/iter/trait.Iterator.html\n+    /// [`Result`]: ../../std/result/enum.Result.html\n+    /// [`char`]: ../../std/primitive.char.html\n+    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n     ///\n     /// ```\n     /// #![feature(io)]\n@@ -832,15 +854,17 @@ pub trait Read {\n     /// Creates an adaptor which will read at most `limit` bytes from it.\n     ///\n     /// This function returns a new instance of `Read` which will read at most\n-    /// `limit` bytes, after which it will always return EOF (`Ok(0)`). Any\n+    /// `limit` bytes, after which it will always return EOF ([`Ok(0)`]). Any\n     /// read errors will not count towards the number of bytes read and future\n-    /// calls to `read` may succeed.\n+    /// calls to [`read()`] may succeed.\n     ///\n     /// # Examples\n     ///\n-    /// [`File`][file]s implement `Read`:\n+    /// [`File`]s implement `Read`:\n     ///\n-    /// [file]: ../fs/struct.File.html\n+    /// [`File`]: ../fs/struct.File.html\n+    /// [`Ok(0)`]: ../../std/result/enum.Result.html#variant.Ok\n+    /// [`read()`]: trait.Read.html#tymethod.read\n     ///\n     /// ```\n     /// use std::io;"}, {"sha": "30495f297453d33e7c62bfa21b591c27f36d75a5", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c872f4727697327550d43d106f5dddd735c41e5f/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c872f4727697327550d43d106f5dddd735c41e5f/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=c872f4727697327550d43d106f5dddd735c41e5f", "patch": "@@ -81,7 +81,7 @@\n //! Note the documentation for the primitives [`str`] and [`[T]`][slice] (also\n //! called 'slice'). Many method calls on [`String`] and [`Vec<T>`] are actually\n //! calls to methods on [`str`] and [`[T]`][slice] respectively, via [deref\n-//! coercions].\n+//! coercions][deref-coercions].\n //!\n //! Third, the standard library defines [The Rust Prelude], a small collection\n //! of items - mostly traits - that are imported into every module of every\n@@ -203,7 +203,7 @@\n //! [`use`]: ../book/first-edition/crates-and-modules.html#importing-modules-with-use\n //! [crate root]: ../book/first-edition/crates-and-modules.html#basic-terminology-crates-and-modules\n //! [crates.io]: https://crates.io\n-//! [deref coercions]: ../book/first-edition/deref-coercions.html\n+//! [deref-coercions]: ../book/second-edition/ch15-02-deref.html#implicit-deref-coercions-with-functions-and-methods\n //! [files]: fs/struct.File.html\n //! [multithreading]: thread/index.html\n //! [other]: #what-is-in-the-standard-library-documentation"}, {"sha": "830b9dc475d6daf534bd0e4e803aa379f9bc389a", "filename": "src/libstd/path.rs", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c872f4727697327550d43d106f5dddd735c41e5f/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c872f4727697327550d43d106f5dddd735c41e5f/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=c872f4727697327550d43d106f5dddd735c41e5f", "patch": "@@ -323,6 +323,11 @@ unsafe fn u8_slice_as_os_str(s: &[u8]) -> &OsStr {\n     mem::transmute(s)\n }\n \n+// Detect scheme on Redox\n+fn has_redox_scheme(s: &[u8]) -> bool {\n+    cfg!(target_os = \"redox\") && s.split(|b| *b == b'/').next().unwrap_or(b\"\").contains(&b':')\n+}\n+\n ////////////////////////////////////////////////////////////////////////////////\n // Cross-platform, iterator-independent parsing\n ////////////////////////////////////////////////////////////////////////////////\n@@ -1685,8 +1690,12 @@ impl Path {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[allow(deprecated)]\n     pub fn is_absolute(&self) -> bool {\n-        // FIXME: Remove target_os = \"redox\" and allow Redox prefixes\n-        self.has_root() && (cfg!(unix) || cfg!(target_os = \"redox\") || self.prefix().is_some())\n+        if !cfg!(target_os = \"redox\") {\n+            self.has_root() && (cfg!(unix) || self.prefix().is_some())\n+        } else {\n+            // FIXME: Allow Redox prefixes\n+            has_redox_scheme(self.as_u8_slice())\n+        }\n     }\n \n     /// Returns `true` if the `Path` is relative, i.e. not absolute.\n@@ -2050,7 +2059,8 @@ impl Path {\n         Components {\n             path: self.as_u8_slice(),\n             prefix,\n-            has_physical_root: has_physical_root(self.as_u8_slice(), prefix),\n+            has_physical_root: has_physical_root(self.as_u8_slice(), prefix) ||\n+                               has_redox_scheme(self.as_u8_slice()),\n             front: State::Prefix,\n             back: State::Body,\n         }\n@@ -3953,4 +3963,10 @@ mod tests {\n         assert_eq!(path, path_buf);\n         assert!(path_buf.into_os_string().capacity() >= 15);\n     }\n+\n+    #[test]\n+    fn display_format_flags() {\n+        assert_eq!(format!(\"a{:#<5}b\", Path::new(\"\").display()), \"a#####b\");\n+        assert_eq!(format!(\"a{:#<5}b\", Path::new(\"a\").display()), \"aa####b\");\n+    }\n }"}, {"sha": "76ef36cc9a733737663fdba36ed588c48fe31ede", "filename": "src/libstd/primitive_docs.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c872f4727697327550d43d106f5dddd735c41e5f/src%2Flibstd%2Fprimitive_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c872f4727697327550d43d106f5dddd735c41e5f/src%2Flibstd%2Fprimitive_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprimitive_docs.rs?ref=c872f4727697327550d43d106f5dddd735c41e5f", "patch": "@@ -188,9 +188,10 @@ mod prim_unit { }\n /// Working with raw pointers in Rust is uncommon,\n /// typically limited to a few patterns.\n ///\n-/// Use the [`null`] function to create null pointers, and the [`is_null`] method\n-/// of the `*const T` type  to check for null. The `*const T` type also defines\n-/// the [`offset`] method, for pointer math.\n+/// Use the [`null`] and [`null_mut`] functions to create null pointers, and the\n+/// [`is_null`] method of the `*const T` and `*mut T` types to check for null.\n+/// The `*const T` and `*mut T` types also define the [`offset`] method, for\n+/// pointer math.\n ///\n /// # Common ways to create raw pointers\n ///\n@@ -261,6 +262,7 @@ mod prim_unit { }\n /// *[See also the `std::ptr` module](ptr/index.html).*\n ///\n /// [`null`]: ../std/ptr/fn.null.html\n+/// [`null_mut`]: ../std/ptr/fn.null_mut.html\n /// [`is_null`]: ../std/primitive.pointer.html#method.is_null\n /// [`offset`]: ../std/primitive.pointer.html#method.offset\n /// [`into_raw`]: ../std/boxed/struct.Box.html#method.into_raw"}, {"sha": "b89a73cd28a090ea8aa684c4d3a51569ff6efe27", "filename": "src/libstd/sys_common/wtf8.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c872f4727697327550d43d106f5dddd735c41e5f/src%2Flibstd%2Fsys_common%2Fwtf8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c872f4727697327550d43d106f5dddd735c41e5f/src%2Flibstd%2Fsys_common%2Fwtf8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fwtf8.rs?ref=c872f4727697327550d43d106f5dddd735c41e5f", "patch": "@@ -452,10 +452,14 @@ impl fmt::Display for Wtf8 {\n                     pos = surrogate_pos + 3;\n                 },\n                 None => {\n-                    formatter.write_str(unsafe {\n+                    let s = unsafe {\n                         str::from_utf8_unchecked(&wtf8_bytes[pos..])\n-                    })?;\n-                    return Ok(());\n+                    };\n+                    if pos == 0 {\n+                        return s.fmt(formatter)\n+                    } else {\n+                        return formatter.write_str(s)\n+                    }\n                 }\n             }\n         }"}, {"sha": "ee103c803f542b58d447bebd2322ca06341ec627", "filename": "src/libstd/thread/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c872f4727697327550d43d106f5dddd735c41e5f/src%2Flibstd%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c872f4727697327550d43d106f5dddd735c41e5f/src%2Flibstd%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Fmod.rs?ref=c872f4727697327550d43d106f5dddd735c41e5f", "patch": "@@ -374,7 +374,7 @@ impl Builder {\n     {\n         let Builder { name, stack_size } = self;\n \n-        let stack_size = stack_size.unwrap_or(util::min_stack());\n+        let stack_size = stack_size.unwrap_or_else(util::min_stack);\n \n         let my_thread = Thread::new(name);\n         let their_thread = my_thread.clone();"}, {"sha": "d568baa2cd7706c2da8619c1f28139b60721f67f", "filename": "src/libstd_unicode/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c872f4727697327550d43d106f5dddd735c41e5f/src%2Flibstd_unicode%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c872f4727697327550d43d106f5dddd735c41e5f/src%2Flibstd_unicode%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd_unicode%2Flib.rs?ref=c872f4727697327550d43d106f5dddd735c41e5f", "patch": "@@ -34,7 +34,6 @@\n \n #![feature(core_char_ext)]\n #![feature(str_internals)]\n-#![feature(core_intrinsics)]\n #![feature(decode_utf8)]\n #![feature(fused)]\n #![feature(fn_traits)]"}, {"sha": "253dcb6a159510735506e2d7ecd988166d4832ed", "filename": "src/libstd_unicode/lossy.rs", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c872f4727697327550d43d106f5dddd735c41e5f/src%2Flibstd_unicode%2Flossy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c872f4727697327550d43d106f5dddd735c41e5f/src%2Flibstd_unicode%2Flossy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd_unicode%2Flossy.rs?ref=c872f4727697327550d43d106f5dddd735c41e5f", "patch": "@@ -12,7 +12,7 @@ use core::str as core_str;\n use core::fmt;\n use core::fmt::Write;\n use char;\n-use core::intrinsics;\n+use core::mem;\n \n \n /// Lossy UTF-8 string.\n@@ -27,7 +27,7 @@ impl Utf8Lossy {\n     }\n \n     pub fn from_bytes(bytes: &[u8]) -> &Utf8Lossy {\n-        unsafe { intrinsics::transmute(bytes) }\n+        unsafe { mem::transmute(bytes) }\n     }\n \n     pub fn chunks(&self) -> Utf8LossyChunksIter {\n@@ -153,7 +153,21 @@ impl<'a> Iterator for Utf8LossyChunksIter<'a> {\n \n impl fmt::Display for Utf8Lossy {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        // If we're the empty string then our iterator won't actually yield\n+        // anything, so perform the formatting manually\n+        if self.bytes.len() == 0 {\n+            return \"\".fmt(f)\n+        }\n+\n         for Utf8LossyChunk { valid, broken } in self.chunks() {\n+            // If we successfully decoded the whole chunk as a valid string then\n+            // we can return a direct formatting of the string which will also\n+            // respect various formatting flags if possible.\n+            if valid.len() == self.bytes.len() {\n+                assert!(broken.is_empty());\n+                return valid.fmt(f)\n+            }\n+\n             f.write_str(valid)?;\n             if !broken.is_empty() {\n                 f.write_char(char::REPLACEMENT_CHARACTER)?;"}, {"sha": "c1c2faaef0b32bae49aff453f18c35844479a51c", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/c872f4727697327550d43d106f5dddd735c41e5f/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c872f4727697327550d43d106f5dddd735c41e5f/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=c872f4727697327550d43d106f5dddd735c41e5f", "patch": "@@ -844,6 +844,32 @@ pub struct Expr {\n     pub attrs: ThinVec<Attribute>\n }\n \n+impl Expr {\n+    /// Wether this expression would be valid somewhere that expects a value, for example, an `if`\n+    /// condition.\n+    pub fn returns(&self) -> bool {\n+        if let ExprKind::Block(ref block) = self.node {\n+            match block.stmts.last().map(|last_stmt| &last_stmt.node) {\n+                // implicit return\n+                Some(&StmtKind::Expr(_)) => true,\n+                Some(&StmtKind::Semi(ref expr)) => {\n+                    if let ExprKind::Ret(_) = expr.node {\n+                        // last statement is explicit return\n+                        true\n+                    } else {\n+                        false\n+                    }\n+                }\n+                // This is a block that doesn't end in either an implicit or explicit return\n+                _ => false,\n+            }\n+        } else {\n+            // This is not a block, it is a value\n+            true\n+        }\n+    }\n+}\n+\n impl fmt::Debug for Expr {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"expr({}: {})\", self.id, pprust::expr_to_string(self))"}, {"sha": "d2bf943ec172c3f9fda4656f37ceb07e84ada3f2", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c872f4727697327550d43d106f5dddd735c41e5f/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c872f4727697327550d43d106f5dddd735c41e5f/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=c872f4727697327550d43d106f5dddd735c41e5f", "patch": "@@ -1776,7 +1776,13 @@ impl<'a> Parser<'a> {\n \n     pub fn parse_path_common(&mut self, style: PathStyle, enable_warning: bool)\n                              -> PResult<'a, ast::Path> {\n-        maybe_whole!(self, NtPath, |x| x);\n+        maybe_whole!(self, NtPath, |path| {\n+            if style == PathStyle::Mod &&\n+               path.segments.iter().any(|segment| segment.parameters.is_some()) {\n+                self.diagnostic().span_err(path.span, \"unexpected generic arguments in path\");\n+            }\n+            path\n+        });\n \n         let lo = self.meta_var_span.unwrap_or(self.span);\n         let mut segments = Vec::new();\n@@ -2973,6 +2979,18 @@ impl<'a> Parser<'a> {\n         }\n         let lo = self.prev_span;\n         let cond = self.parse_expr_res(RESTRICTION_NO_STRUCT_LITERAL, None)?;\n+\n+        // Verify that the parsed `if` condition makes sense as a condition. If it is a block, then\n+        // verify that the last statement is either an implicit return (no `;`) or an explicit\n+        // return. This won't catch blocks with an explicit `return`, but that would be caught by\n+        // the dead code lint.\n+        if self.eat_keyword(keywords::Else) || !cond.returns() {\n+            let sp = lo.next_point();\n+            let mut err = self.diagnostic()\n+                .struct_span_err(sp, \"missing condition for `if` statemement\");\n+            err.span_label(sp, \"expected if condition here\");\n+            return Err(err)\n+        }\n         let thn = self.parse_block()?;\n         let mut els: Option<P<Expr>> = None;\n         let mut hi = thn.span;"}, {"sha": "5e34688f8cb8f0e7ffc6997cee5aa353bf728843", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c872f4727697327550d43d106f5dddd735c41e5f/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c872f4727697327550d43d106f5dddd735c41e5f/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=c872f4727697327550d43d106f5dddd735c41e5f", "patch": "@@ -37,6 +37,7 @@\n #![feature(libc)]\n #![feature(set_stdio)]\n #![feature(panic_unwind)]\n+#![feature(staged_api)]\n \n extern crate getopts;\n extern crate term;"}, {"sha": "dc1464b905b0dacb95167815183f1008de61c3c8", "filename": "src/libunwind/build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c872f4727697327550d43d106f5dddd735c41e5f/src%2Flibunwind%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c872f4727697327550d43d106f5dddd735c41e5f/src%2Flibunwind%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunwind%2Fbuild.rs?ref=c872f4727697327550d43d106f5dddd735c41e5f", "patch": "@@ -16,7 +16,7 @@ fn main() {\n \n     if target.contains(\"linux\") {\n         if target.contains(\"musl\") && !target.contains(\"mips\") {\n-            println!(\"cargo:rustc-link-lib=static=unwind\");\n+            // musl is handled in lib.rs\n         } else if !target.contains(\"android\") {\n             println!(\"cargo:rustc-link-lib=gcc_s\");\n         }"}, {"sha": "2f425d8e9860ea9e19a19e047dd5d575dd64a81a", "filename": "src/libunwind/lib.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c872f4727697327550d43d106f5dddd735c41e5f/src%2Flibunwind%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c872f4727697327550d43d106f5dddd735c41e5f/src%2Flibunwind%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunwind%2Flib.rs?ref=c872f4727697327550d43d106f5dddd735c41e5f", "patch": "@@ -15,6 +15,7 @@\n #![deny(warnings)]\n \n #![feature(cfg_target_vendor)]\n+#![feature(link_cfg)]\n #![feature(staged_api)]\n #![feature(unwind_attributes)]\n #![feature(static_nobundle)]\n@@ -28,3 +29,8 @@ extern crate libc;\n mod libunwind;\n #[cfg(not(target_env = \"msvc\"))]\n pub use libunwind::*;\n+\n+#[cfg(all(target_env = \"musl\", not(target_arch = \"mips\")))]\n+#[link(name = \"unwind\", kind = \"static\", cfg(target_feature = \"crt-static\"))]\n+#[link(name = \"gcc_s\", cfg(not(target_feature = \"crt-static\")))]\n+extern {}"}, {"sha": "847393ba2b89f4168069b2ad97c1d09fd0cf9cac", "filename": "src/test/compile-fail/associated-types-eq-expr-path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c872f4727697327550d43d106f5dddd735c41e5f/src%2Ftest%2Fcompile-fail%2Fassociated-types-eq-expr-path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c872f4727697327550d43d106f5dddd735c41e5f/src%2Ftest%2Fcompile-fail%2Fassociated-types-eq-expr-path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types-eq-expr-path.rs?ref=c872f4727697327550d43d106f5dddd735c41e5f", "patch": "@@ -22,5 +22,5 @@ impl Foo for isize {\n \n pub fn main() {\n     let x: isize = Foo::<A=usize>::bar();\n-    //~^ ERROR unexpected binding of associated item in expression path\n+    //~^ ERROR associated type bindings are not allowed here\n }"}, {"sha": "30cdd07b399986de54b3e7137d31833ea310717d", "filename": "src/test/compile-fail/issue-12567.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c872f4727697327550d43d106f5dddd735c41e5f/src%2Ftest%2Fcompile-fail%2Fissue-12567.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c872f4727697327550d43d106f5dddd735c41e5f/src%2Ftest%2Fcompile-fail%2Fissue-12567.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-12567.rs?ref=c872f4727697327550d43d106f5dddd735c41e5f", "patch": "@@ -15,12 +15,12 @@ fn match_vecs<'a, T>(l1: &'a [T], l2: &'a [T]) {\n         (&[], &[]) => println!(\"both empty\"),\n         (&[], &[hd, ..]) | (&[hd, ..], &[])\n             => println!(\"one empty\"),\n-        //~^^ ERROR: cannot move out of type `[T]`, a non-copy array\n-        //~^^^ ERROR: cannot move out of type `[T]`, a non-copy array\n+        //~^^ ERROR: cannot move out of type `[T]`, a non-copy slice\n+        //~^^^ ERROR: cannot move out of type `[T]`, a non-copy slice\n         (&[hd1, ..], &[hd2, ..])\n             => println!(\"both nonempty\"),\n-        //~^^ ERROR: cannot move out of type `[T]`, a non-copy array\n-        //~^^^ ERROR: cannot move out of type `[T]`, a non-copy array\n+        //~^^ ERROR: cannot move out of type `[T]`, a non-copy slice\n+        //~^^^ ERROR: cannot move out of type `[T]`, a non-copy slice\n     }\n }\n "}, {"sha": "431fc8a5aa2b2c1196ac4afe918f50b6e2ed6830", "filename": "src/test/compile-fail/issue-43424.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c872f4727697327550d43d106f5dddd735c41e5f/src%2Ftest%2Fcompile-fail%2Fissue-43424.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c872f4727697327550d43d106f5dddd735c41e5f/src%2Ftest%2Fcompile-fail%2Fissue-43424.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-43424.rs?ref=c872f4727697327550d43d106f5dddd735c41e5f", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(unused)]\n+\n+macro_rules! m {\n+    ($attr_path: path) => {\n+        #[$attr_path]\n+        fn f() {}\n+    }\n+}\n+\n+m!(inline<u8>); //~ ERROR: unexpected generic arguments in path\n+\n+fn main() {}"}, {"sha": "e9f62152888147aaaa75dcb2bc75818ec408778c", "filename": "src/test/compile-fail/issue-43431.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/c872f4727697327550d43d106f5dddd735c41e5f/src%2Ftest%2Fcompile-fail%2Fissue-43431.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c872f4727697327550d43d106f5dddd735c41e5f/src%2Ftest%2Fcompile-fail%2Fissue-43431.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-43431.rs?ref=c872f4727697327550d43d106f5dddd735c41e5f", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(fn_traits)]\n+\n+trait CallSingle<A, B> {\n+    fn call(&self, a: A) -> B where Self: Fn(A) -> B;\n+}\n+\n+impl<A, B, F: Fn(A) -> B> CallSingle<A, B> for F {\n+    fn call(&self, a: A) -> B {\n+        <Self as Fn(A) -> B>::call(self, (a,))\n+        //~^ ERROR associated type bindings are not allowed here\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "94b5c0034a76deca5addf72a4af88fe64b2a54aa", "filename": "src/test/compile-fail/issue-43784-associated-type.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/c872f4727697327550d43d106f5dddd735c41e5f/src%2Ftest%2Fcompile-fail%2Fissue-43784-associated-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c872f4727697327550d43d106f5dddd735c41e5f/src%2Ftest%2Fcompile-fail%2Fissue-43784-associated-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-43784-associated-type.rs?ref=c872f4727697327550d43d106f5dddd735c41e5f", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub trait Partial<X: ?Sized>: Copy {\n+}\n+\n+pub trait Complete {\n+    type Assoc: Partial<Self>;\n+}\n+\n+impl<T> Partial<T> for T::Assoc where\n+    T: Complete\n+{\n+}\n+\n+impl<T> Complete for T { //~ ERROR the trait bound `T: std::marker::Copy` is not satisfied\n+    type Assoc = T;\n+}"}, {"sha": "e70df113da33cfcb7e3b2e212e222789052f3602", "filename": "src/test/compile-fail/issue-43784-supertrait.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c872f4727697327550d43d106f5dddd735c41e5f/src%2Ftest%2Fcompile-fail%2Fissue-43784-supertrait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c872f4727697327550d43d106f5dddd735c41e5f/src%2Ftest%2Fcompile-fail%2Fissue-43784-supertrait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-43784-supertrait.rs?ref=c872f4727697327550d43d106f5dddd735c41e5f", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub trait Partial: Copy {\n+}\n+\n+pub trait Complete: Partial {\n+}\n+\n+impl<T> Partial for T where T: Complete {}\n+impl<T> Complete for T {} //~ ERROR the trait bound `T: std::marker::Copy` is not satisfied"}, {"sha": "6c0793ee78f19c5adaed14a58312e894162f2050", "filename": "src/test/compile-fail/method-call-type-binding.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c872f4727697327550d43d106f5dddd735c41e5f/src%2Ftest%2Fcompile-fail%2Fmethod-call-type-binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c872f4727697327550d43d106f5dddd735c41e5f/src%2Ftest%2Fcompile-fail%2Fmethod-call-type-binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmethod-call-type-binding.rs?ref=c872f4727697327550d43d106f5dddd735c41e5f", "patch": "@@ -9,5 +9,5 @@\n // except according to those terms.\n \n fn main() {\n-    0.clone::<T = u8>(); //~ ERROR unexpected binding of associated item\n+    0.clone::<T = u8>(); //~ ERROR associated type bindings are not allowed here\n }"}, {"sha": "796b13538b22ad9da1e3691b5b596afe20858984", "filename": "src/test/compile-fail/move-out-of-array-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c872f4727697327550d43d106f5dddd735c41e5f/src%2Ftest%2Fcompile-fail%2Fmove-out-of-array-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c872f4727697327550d43d106f5dddd735c41e5f/src%2Ftest%2Fcompile-fail%2Fmove-out-of-array-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmove-out-of-array-1.rs?ref=c872f4727697327550d43d106f5dddd735c41e5f", "patch": "@@ -24,5 +24,5 @@ fn main() {\n }\n \n fn foo(a: [D; 4], i: usize) -> D {\n-    a[i] //~ ERROR cannot move out of type `[D; 4]`\n+    a[i] //~ ERROR cannot move out of type `[D; 4]`, a non-copy array\n }"}, {"sha": "9ca9e0984e47668d2ed62315a6ad28062666b7e0", "filename": "src/test/compile-fail/move-out-of-slice-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c872f4727697327550d43d106f5dddd735c41e5f/src%2Ftest%2Fcompile-fail%2Fmove-out-of-slice-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c872f4727697327550d43d106f5dddd735c41e5f/src%2Ftest%2Fcompile-fail%2Fmove-out-of-slice-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmove-out-of-slice-1.rs?ref=c872f4727697327550d43d106f5dddd735c41e5f", "patch": "@@ -15,7 +15,7 @@ struct A;\n fn main() {\n     let a: Box<[A]> = Box::new([A]);\n     match a {\n-        box [a] => {}, //~ ERROR cannot move out of type `[A]`\n+        box [a] => {}, //~ ERROR cannot move out of type `[A]`, a non-copy slice\n         _ => {}\n     }\n }"}, {"sha": "512fb24a0c2262df58d33095abf4698799f343f1", "filename": "src/test/compile-fail/stability-attribute-non-staged-force-unstable.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c872f4727697327550d43d106f5dddd735c41e5f/src%2Ftest%2Fcompile-fail%2Fstability-attribute-non-staged-force-unstable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c872f4727697327550d43d106f5dddd735c41e5f/src%2Ftest%2Fcompile-fail%2Fstability-attribute-non-staged-force-unstable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstability-attribute-non-staged-force-unstable.rs?ref=c872f4727697327550d43d106f5dddd735c41e5f", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags:-Zforce-unstable-if-unmarked\n+\n+#[unstable] //~ ERROR: stability attributes may not be used\n+#[stable] //~ ERROR: stability attributes may not be used\n+#[rustc_deprecated] //~ ERROR: stability attributes may not be used\n+fn main() { }"}, {"sha": "5fcde4facbe8d5ecb1d05dcd4e4ad846e796b7c8", "filename": "src/test/compile-fail/unboxed-closure-sugar-used-on-struct.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c872f4727697327550d43d106f5dddd735c41e5f/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-used-on-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c872f4727697327550d43d106f5dddd735c41e5f/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-used-on-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-used-on-struct.rs?ref=c872f4727697327550d43d106f5dddd735c41e5f", "patch": "@@ -16,6 +16,7 @@ struct Bar<A> {\n \n fn foo(b: Box<Bar()>) {\n     //~^ ERROR parenthesized parameters may only be used with a trait\n+    //~| ERROR the type placeholder `_` is not allowed within types on item signatures\n }\n \n fn main() { }"}, {"sha": "0ceb5ed5e755dcd3b12febd418422184a4ee42c9", "filename": "src/test/run-pass-fulldeps/issue-13560.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c872f4727697327550d43d106f5dddd735c41e5f/src%2Ftest%2Frun-pass-fulldeps%2Fissue-13560.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c872f4727697327550d43d106f5dddd735c41e5f/src%2Ftest%2Frun-pass-fulldeps%2Fissue-13560.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fissue-13560.rs?ref=c872f4727697327550d43d106f5dddd735c41e5f", "patch": "@@ -11,7 +11,6 @@\n // aux-build:issue-13560-1.rs\n // aux-build:issue-13560-2.rs\n // aux-build:issue-13560-3.rs\n-// ignore-musl\n \n // Regression test for issue #13560, the test itself is all in the dependent\n // libraries. The fail which previously failed to compile is the one numbered 3."}, {"sha": "9839a2c704105d704ca23e7132675931ab3c938e", "filename": "src/test/run-pass-fulldeps/linkage-visibility.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c872f4727697327550d43d106f5dddd735c41e5f/src%2Ftest%2Frun-pass-fulldeps%2Flinkage-visibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c872f4727697327550d43d106f5dddd735c41e5f/src%2Ftest%2Frun-pass-fulldeps%2Flinkage-visibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Flinkage-visibility.rs?ref=c872f4727697327550d43d106f5dddd735c41e5f", "patch": "@@ -11,7 +11,6 @@\n // aux-build:linkage-visibility.rs\n // ignore-android: FIXME(#10356)\n // ignore-windows: std::dynamic_lib does not work on Windows well\n-// ignore-musl\n // ignore-emscripten no dynamic linking\n \n extern crate linkage_visibility as foo;"}, {"sha": "542117eca1209bfd3991819f7c8b61502046e7c2", "filename": "src/test/run-pass/deprecation-in-force-unstable.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c872f4727697327550d43d106f5dddd735c41e5f/src%2Ftest%2Frun-pass%2Fdeprecation-in-force-unstable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c872f4727697327550d43d106f5dddd735c41e5f/src%2Ftest%2Frun-pass%2Fdeprecation-in-force-unstable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdeprecation-in-force-unstable.rs?ref=c872f4727697327550d43d106f5dddd735c41e5f", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags:-Zforce-unstable-if-unmarked\n+\n+#[deprecated] // should work even with -Zforce-unstable-if-unmarked\n+fn main() { }"}, {"sha": "e1992e4fc5032f5d13bd43360311403fe418fbb1", "filename": "src/test/run-pass/issue-43923.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c872f4727697327550d43d106f5dddd735c41e5f/src%2Ftest%2Frun-pass%2Fissue-43923.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c872f4727697327550d43d106f5dddd735c41e5f/src%2Ftest%2Frun-pass%2Fissue-43923.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-43923.rs?ref=c872f4727697327550d43d106f5dddd735c41e5f", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct A<T: ?Sized> { ptr: T }\n+\n+fn foo<T>(x: &A<[T]>) {}\n+\n+fn main() {\n+    let a = foo;\n+    let b = A { ptr: [a, a, a] };\n+    a(&A { ptr: [()] });\n+}"}, {"sha": "079f6a6b641e9178dd2aae3402e6537bdf256b4b", "filename": "src/test/run-pass/union/union-basic.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c872f4727697327550d43d106f5dddd735c41e5f/src%2Ftest%2Frun-pass%2Funion%2Funion-basic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c872f4727697327550d43d106f5dddd735c41e5f/src%2Ftest%2Frun-pass%2Funion%2Funion-basic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funion%2Funion-basic.rs?ref=c872f4727697327550d43d106f5dddd735c41e5f", "patch": "@@ -10,10 +10,6 @@\n \n // aux-build:union.rs\n \n-// FIXME: This test case makes little-endian assumptions.\n-// ignore-s390x\n-// ignore-sparc\n-\n extern crate union;\n use std::mem::{size_of, align_of, zeroed};\n \n@@ -39,7 +35,7 @@ fn local() {\n         assert_eq!(w.b, 0);\n         w.a = 1;\n         assert_eq!(w.a, 1);\n-        assert_eq!(w.b, 1);\n+        assert_eq!(w.b.to_le(), 1);\n     }\n }\n \n@@ -60,7 +56,7 @@ fn xcrate() {\n         assert_eq!(w.b, 0);\n         w.a = 1;\n         assert_eq!(w.a, 1);\n-        assert_eq!(w.b, 1);\n+        assert_eq!(w.b.to_le(), 1);\n     }\n }\n "}, {"sha": "863780439127642bce9520c075fe565469d6f555", "filename": "src/test/ui/issue-13483.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/c872f4727697327550d43d106f5dddd735c41e5f/src%2Ftest%2Fui%2Fissue-13483.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c872f4727697327550d43d106f5dddd735c41e5f/src%2Ftest%2Fui%2Fissue-13483.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-13483.rs?ref=c872f4727697327550d43d106f5dddd735c41e5f", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    if true {\n+    } else if {\n+    } else {\n+    }\n+}\n+\n+fn foo() {\n+    if true {\n+    } else if {\n+    }\n+    bar();\n+}\n+\n+fn bar() {}"}, {"sha": "3446969dfd21311b504756e2628f1297f96b345a", "filename": "src/test/ui/issue-13483.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c872f4727697327550d43d106f5dddd735c41e5f/src%2Ftest%2Fui%2Fissue-13483.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c872f4727697327550d43d106f5dddd735c41e5f/src%2Ftest%2Fui%2Fissue-13483.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-13483.stderr?ref=c872f4727697327550d43d106f5dddd735c41e5f", "patch": "@@ -0,0 +1,14 @@\n+error: missing condition for `if` statemement\n+  --> $DIR/issue-13483.rs:13:14\n+   |\n+13 |     } else if {\n+   |              ^ expected if condition here\n+\n+error: missing condition for `if` statemement\n+  --> $DIR/issue-13483.rs:20:14\n+   |\n+20 |     } else if {\n+   |              ^ expected if condition here\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "793ea68beba139e9defe8eaad0d055e4aae25b9b", "filename": "src/test/ui/span/import-ty-params.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c872f4727697327550d43d106f5dddd735c41e5f/src%2Ftest%2Fui%2Fspan%2Fimport-ty-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c872f4727697327550d43d106f5dddd735c41e5f/src%2Ftest%2Fui%2Fspan%2Fimport-ty-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fimport-ty-params.rs?ref=c872f4727697327550d43d106f5dddd735c41e5f", "patch": "@@ -21,10 +21,10 @@ macro_rules! import {\n }\n \n fn f1() {\n-    import! { a::b::c::S<u8> } //~ ERROR generic arguments in import path\n+    import! { a::b::c::S<u8> } //~ ERROR unexpected generic arguments in path\n }\n fn f2() {\n-    import! { a::b::c::S<> } //~ ERROR generic arguments in import path\n+    import! { a::b::c::S<> } //~ ERROR unexpected generic arguments in path\n }\n \n fn main() {}"}, {"sha": "e2c3e34c47160c100779d2c4b316ce4a557d5ede", "filename": "src/test/ui/span/import-ty-params.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c872f4727697327550d43d106f5dddd735c41e5f/src%2Ftest%2Fui%2Fspan%2Fimport-ty-params.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c872f4727697327550d43d106f5dddd735c41e5f/src%2Ftest%2Fui%2Fspan%2Fimport-ty-params.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fimport-ty-params.stderr?ref=c872f4727697327550d43d106f5dddd735c41e5f", "patch": "@@ -1,14 +1,14 @@\n-error: generic arguments in import path\n-  --> $DIR/import-ty-params.rs:24:25\n+error: unexpected generic arguments in path\n+  --> $DIR/import-ty-params.rs:24:15\n    |\n-24 |     import! { a::b::c::S<u8> } //~ ERROR generic arguments in import path\n-   |                         ^^^^\n+24 |     import! { a::b::c::S<u8> } //~ ERROR unexpected generic arguments in path\n+   |               ^^^^^^^^^^^^^^\n \n-error: generic arguments in import path\n-  --> $DIR/import-ty-params.rs:27:25\n+error: unexpected generic arguments in path\n+  --> $DIR/import-ty-params.rs:27:15\n    |\n-27 |     import! { a::b::c::S<> } //~ ERROR generic arguments in import path\n-   |                         ^^\n+27 |     import! { a::b::c::S<> } //~ ERROR unexpected generic arguments in path\n+   |               ^^^^^^^^^^^^\n \n error: aborting due to 2 previous errors\n "}, {"sha": "c2443b024ceb22899c214e0ab16cf376edd6aaf5", "filename": "src/test/ui/span/macro-ty-params.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c872f4727697327550d43d106f5dddd735c41e5f/src%2Ftest%2Fui%2Fspan%2Fmacro-ty-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c872f4727697327550d43d106f5dddd735c41e5f/src%2Ftest%2Fui%2Fspan%2Fmacro-ty-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fmacro-ty-params.rs?ref=c872f4727697327550d43d106f5dddd735c41e5f", "patch": "@@ -16,16 +16,6 @@ macro_rules! m {\n \n fn main() {\n     foo::<T>!();\n-    //~^ ERROR generic arguments in macro path\n-    //~| ERROR generic arguments in macro path\n-    //~| ERROR generic arguments in macro path\n     foo::<>!();\n-    //~^ ERROR generic arguments in macro path\n-    //~| ERROR generic arguments in macro path\n-    //~| ERROR generic arguments in macro path\n     m!(MyTrait<>);\n-    //~^ ERROR generic arguments in macro path\n-    //~| ERROR generic arguments in macro path\n-    //~| ERROR generic arguments in macro path\n-    //~| ERROR generic arguments in macro path\n }"}, {"sha": "1d2f7bb2f07e9777feb72826d7af48ceb8d78f15", "filename": "src/test/ui/span/macro-ty-params.stderr", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c872f4727697327550d43d106f5dddd735c41e5f/src%2Ftest%2Fui%2Fspan%2Fmacro-ty-params.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c872f4727697327550d43d106f5dddd735c41e5f/src%2Ftest%2Fui%2Fspan%2Fmacro-ty-params.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fmacro-ty-params.stderr?ref=c872f4727697327550d43d106f5dddd735c41e5f", "patch": "@@ -1,20 +1,32 @@\n+error: unexpected generic arguments in path\n+  --> $DIR/macro-ty-params.rs:20:8\n+   |\n+20 |     m!(MyTrait<>);\n+   |        ^^^^^^^^^\n+\n+error: unexpected generic arguments in path\n+  --> $DIR/macro-ty-params.rs:20:8\n+   |\n+20 |     m!(MyTrait<>);\n+   |        ^^^^^^^^^\n+\n error: generic arguments in macro path\n   --> $DIR/macro-ty-params.rs:18:8\n    |\n 18 |     foo::<T>!();\n    |        ^^^^^\n \n error: generic arguments in macro path\n-  --> $DIR/macro-ty-params.rs:22:8\n+  --> $DIR/macro-ty-params.rs:19:8\n    |\n-22 |     foo::<>!();\n+19 |     foo::<>!();\n    |        ^^^^\n \n error: generic arguments in macro path\n-  --> $DIR/macro-ty-params.rs:26:15\n+  --> $DIR/macro-ty-params.rs:20:15\n    |\n-26 |     m!(MyTrait<>);\n+20 |     m!(MyTrait<>);\n    |               ^^\n \n-error: aborting due to 3 previous errors\n+error: aborting due to 5 previous errors\n "}, {"sha": "2a4a5edd04c0849d1c0a898ecc961cf85b8177ec", "filename": "src/test/ui/span/visibility-ty-params.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c872f4727697327550d43d106f5dddd735c41e5f/src%2Ftest%2Fui%2Fspan%2Fvisibility-ty-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c872f4727697327550d43d106f5dddd735c41e5f/src%2Ftest%2Fui%2Fspan%2Fvisibility-ty-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fvisibility-ty-params.rs?ref=c872f4727697327550d43d106f5dddd735c41e5f", "patch": "@@ -13,11 +13,11 @@ macro_rules! m {\n }\n \n struct S<T>(T);\n-m!{ S<u8> } //~ ERROR generic arguments in visibility path\n+m!{ S<u8> } //~ ERROR unexpected generic arguments in path\n //~^ ERROR expected module, found struct `S`\n \n mod m {\n-    m!{ m<> } //~ ERROR generic arguments in visibility path\n+    m!{ m<> } //~ ERROR unexpected generic arguments in path\n }\n \n fn main() {}"}, {"sha": "673b9a38e035f3cdf19ed59eba19ade5dc311401", "filename": "src/test/ui/span/visibility-ty-params.stderr", "status": "modified", "additions": 9, "deletions": 17, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/c872f4727697327550d43d106f5dddd735c41e5f/src%2Ftest%2Fui%2Fspan%2Fvisibility-ty-params.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c872f4727697327550d43d106f5dddd735c41e5f/src%2Ftest%2Fui%2Fspan%2Fvisibility-ty-params.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fvisibility-ty-params.stderr?ref=c872f4727697327550d43d106f5dddd735c41e5f", "patch": "@@ -1,22 +1,14 @@\n-error: generic arguments in visibility path\n-  --> $DIR/visibility-ty-params.rs:16:6\n-   |\n-16 | m!{ S<u8> } //~ ERROR generic arguments in visibility path\n-   |      ^^^^\n-\n-error: generic arguments in visibility path\n-  --> $DIR/visibility-ty-params.rs:20:10\n+error: unexpected generic arguments in path\n+  --> $DIR/visibility-ty-params.rs:16:5\n    |\n-20 |     m!{ m<> } //~ ERROR generic arguments in visibility path\n-   |          ^^\n+16 | m!{ S<u8> } //~ ERROR unexpected generic arguments in path\n+   |     ^^^^^\n \n-error[E0577]: expected module, found struct `S`\n-  --> $DIR/visibility-ty-params.rs:16:5\n+error: unexpected generic arguments in path\n+  --> $DIR/visibility-ty-params.rs:20:9\n    |\n-16 | m!{ S<u8> } //~ ERROR generic arguments in visibility path\n-   |     -^^^^\n-   |     |\n-   |     did you mean `m`?\n+20 |     m!{ m<> } //~ ERROR unexpected generic arguments in path\n+   |         ^^^\n \n-error: aborting due to 3 previous errors\n+error: aborting due to 2 previous errors\n "}, {"sha": "20239e974788bfac32b6fa34aa4ca9ab8e0ab219", "filename": "src/tools/compiletest/src/main.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c872f4727697327550d43d106f5dddd735c41e5f/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c872f4727697327550d43d106f5dddd735c41e5f/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs?ref=c872f4727697327550d43d106f5dddd735c41e5f", "patch": "@@ -39,7 +39,6 @@ use util::logv;\n \n use self::header::EarlyProps;\n \n-pub mod procsrv;\n pub mod util;\n mod json;\n pub mod header;"}, {"sha": "ffcc60e78529247e1cd3ccd97a78c02d4a10b38f", "filename": "src/tools/compiletest/src/procsrv.rs", "status": "removed", "additions": 0, "deletions": 134, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/b44e51cd62a982c8ab97b1b794ada57bdda44e85/src%2Ftools%2Fcompiletest%2Fsrc%2Fprocsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b44e51cd62a982c8ab97b1b794ada57bdda44e85/src%2Ftools%2Fcompiletest%2Fsrc%2Fprocsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fprocsrv.rs?ref=b44e51cd62a982c8ab97b1b794ada57bdda44e85", "patch": "@@ -1,134 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use std::env;\n-use std::ffi::OsString;\n-use std::io::prelude::*;\n-use std::io;\n-use std::path::PathBuf;\n-use std::process::{Child, Command, ExitStatus, Output, Stdio};\n-\n-/// Get the name of the environment variable that holds dynamic library\n-/// locations\n-pub fn dylib_env_var() -> &'static str {\n-    if cfg!(windows) {\n-        \"PATH\"\n-    } else if cfg!(target_os = \"macos\") {\n-        \"DYLD_LIBRARY_PATH\"\n-    } else if cfg!(target_os = \"haiku\") {\n-        \"LIBRARY_PATH\"\n-    } else {\n-        \"LD_LIBRARY_PATH\"\n-    }\n-}\n-\n-/// Add `lib_path` and `aux_path` (if it is `Some`) to the dynamic library\n-/// env var\n-fn add_target_env(cmd: &mut Command, lib_path: &str, aux_path: Option<&str>) {\n-    // Need to be sure to put both the lib_path and the aux path in the dylib\n-    // search path for the child.\n-    let var = dylib_env_var();\n-    let mut path = env::split_paths(&env::var_os(var).unwrap_or(OsString::new()))\n-        .collect::<Vec<_>>();\n-    if let Some(p) = aux_path {\n-        path.insert(0, PathBuf::from(p))\n-    }\n-    path.insert(0, PathBuf::from(lib_path));\n-\n-    // Add the new dylib search path var\n-    let newpath = env::join_paths(&path).unwrap();\n-    cmd.env(var, newpath);\n-}\n-\n-/// Represents exit status, stdout and stderr of a completed process\n-pub struct Result {\n-    pub status: ExitStatus,\n-    pub out: String,\n-    pub err: String,\n-}\n-\n-/// Runs a test program\n-///\n-/// # Params\n-///  - `lib_path` Path to search for required library\n-///  - `prog` command to run\n-///  - `aux_path` Optional extra path to search for required\n-///    auxiliary libraries\n-///  - `args` List of arguments to pass to `prog`\n-///  - `env` List of environment variables to set, `.0` is variable name,\n-///    `.1` is value\n-///  - `input` String to be fed as stdin\n-///  - `current_dir` Optional working dir to run command in\n-///\n-pub fn run(lib_path: &str,\n-           prog: &str,\n-           aux_path: Option<&str>,\n-           args: &[String],\n-           env: Vec<(String, String)>,\n-           input: Option<String>,\n-           current_dir: Option<String>)\n-           -> io::Result<Result> {\n-\n-    let mut cmd = Command::new(prog);\n-    cmd.args(args)\n-        .stdout(Stdio::piped())\n-        .stderr(Stdio::piped())\n-        .stdin(Stdio::piped());\n-\n-    add_target_env(&mut cmd, lib_path, aux_path);\n-    for (key, val) in env {\n-        cmd.env(&key, &val);\n-    }\n-    if let Some(cwd) = current_dir {\n-        cmd.current_dir(cwd);\n-    }\n-\n-    let mut process = cmd.spawn()?;\n-    if let Some(input) = input {\n-        process.stdin.as_mut().unwrap().write_all(input.as_bytes()).unwrap();\n-    }\n-    let Output { status, stdout, stderr } = process.wait_with_output().unwrap();\n-\n-    Ok(Result {\n-        status,\n-        out: String::from_utf8(stdout).unwrap(),\n-        err: String::from_utf8(stderr).unwrap(),\n-    })\n-}\n-\n-/// Same as `run`, but return process rather than waiting on completion\n-pub fn run_background(lib_path: &str,\n-                      prog: &str,\n-                      aux_path: Option<&str>,\n-                      args: &[String],\n-                      env: Vec<(String, String)>,\n-                      input: Option<String>,\n-                      current_dir: Option<String>)\n-                      -> io::Result<Child> {\n-\n-    let mut cmd = Command::new(prog);\n-    cmd.args(args)\n-       .stdin(Stdio::piped())\n-       .stdout(Stdio::piped());\n-    add_target_env(&mut cmd, lib_path, aux_path);\n-    for (key, val) in env {\n-        cmd.env(&key, &val);\n-    }\n-    if let Some(cwd) = current_dir {\n-        cmd.current_dir(cwd);\n-    }\n-\n-    let mut process = cmd.spawn()?;\n-    if let Some(input) = input {\n-        process.stdin.as_mut().unwrap().write_all(input.as_bytes()).unwrap();\n-    }\n-\n-    Ok(process)\n-}"}, {"sha": "d2a0c776b33e683f4c830b62bd458d2de45cce6a", "filename": "src/tools/compiletest/src/runtest.rs", "status": "modified", "additions": 240, "deletions": 316, "changes": 556, "blob_url": "https://github.com/rust-lang/rust/blob/c872f4727697327550d43d106f5dddd735c41e5f/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c872f4727697327550d43d106f5dddd735c41e5f/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs?ref=c872f4727697327550d43d106f5dddd735c41e5f", "patch": "@@ -17,22 +17,35 @@ use errors::{self, ErrorKind, Error};\n use filetime::FileTime;\n use json;\n use header::TestProps;\n-use procsrv;\n use test::TestPaths;\n use util::logv;\n \n+use std::collections::HashMap;\n use std::collections::HashSet;\n use std::env;\n+use std::ffi::OsString;\n use std::fs::{self, File, create_dir_all};\n use std::io::prelude::*;\n use std::io::{self, BufReader};\n use std::path::{Path, PathBuf};\n-use std::process::{Command, Output, ExitStatus};\n+use std::process::{Command, Output, ExitStatus, Stdio};\n use std::str;\n-use std::collections::HashMap;\n \n use extract_gdb_version;\n \n+/// The name of the environment variable that holds dynamic library locations.\n+pub fn dylib_env_var() -> &'static str {\n+    if cfg!(windows) {\n+        \"PATH\"\n+    } else if cfg!(target_os = \"macos\") {\n+        \"DYLD_LIBRARY_PATH\"\n+    } else if cfg!(target_os = \"haiku\") {\n+        \"LIBRARY_PATH\"\n+    } else {\n+        \"LD_LIBRARY_PATH\"\n+    }\n+}\n+\n pub fn run(config: Config, testpaths: &TestPaths) {\n     match &*config.target {\n \n@@ -325,37 +338,23 @@ impl<'test> TestCx<'test> {\n         }\n     }\n \n-    fn print_source(&self,\n-                    src: String,\n-                    pretty_type: &str)\n-                    -> ProcRes {\n+    fn print_source(&self, src: String, pretty_type: &str) -> ProcRes {\n         let aux_dir = self.aux_output_dir_name();\n-        self.compose_and_run(self.make_pp_args(pretty_type.to_owned()),\n-                             self.props.exec_env.clone(),\n+\n+        let mut rustc = Command::new(&self.config.rustc_path);\n+        rustc.arg(\"-\")\n+            .arg(\"-Zunstable-options\")\n+            .args(&[\"--unpretty\", &pretty_type])\n+            .args(&[\"--target\", &self.config.target])\n+            .arg(\"-L\").arg(&aux_dir)\n+            .args(self.split_maybe_args(&self.config.target_rustcflags))\n+            .args(&self.props.compile_flags)\n+            .envs(self.props.exec_env.clone());\n+\n+        self.compose_and_run(rustc,\n                              self.config.compile_lib_path.to_str().unwrap(),\n                              Some(aux_dir.to_str().unwrap()),\n-                             Some(src),\n-                             None)\n-    }\n-\n-    fn make_pp_args(&self,\n-                    pretty_type: String)\n-                    -> ProcArgs {\n-        let aux_dir = self.aux_output_dir_name();\n-        // FIXME (#9639): This needs to handle non-utf8 paths\n-        let mut args = vec![\"-\".to_owned(),\n-                            \"-Zunstable-options\".to_owned(),\n-                            \"--unpretty\".to_owned(),\n-                            pretty_type,\n-                            format!(\"--target={}\", self.config.target),\n-                            \"-L\".to_owned(),\n-                            aux_dir.to_str().unwrap().to_owned()];\n-        args.extend(self.split_maybe_args(&self.config.target_rustcflags));\n-        args.extend(self.props.compile_flags.iter().cloned());\n-        ProcArgs {\n-            prog: self.config.rustc_path.to_str().unwrap().to_owned(),\n-            args,\n-        }\n+                             Some(src))\n     }\n \n     fn compare_source(&self,\n@@ -379,45 +378,35 @@ actual:\\n\\\n     }\n \n     fn typecheck_source(&self, src: String) -> ProcRes {\n-        let args = self.make_typecheck_args();\n-        self.compose_and_run_compiler(args, Some(src))\n-    }\n+        let mut rustc = Command::new(&self.config.rustc_path);\n+\n+        let out_dir = self.output_base_name().with_extension(\"pretty-out\");\n+        let _ = fs::remove_dir_all(&out_dir);\n+        create_dir_all(&out_dir).unwrap();\n \n-    fn make_typecheck_args(&self) -> ProcArgs {\n-        let aux_dir = self.aux_output_dir_name();\n         let target = if self.props.force_host {\n             &*self.config.host\n         } else {\n             &*self.config.target\n         };\n \n-        let out_dir = self.output_base_name().with_extension(\"pretty-out\");\n-        let _ = fs::remove_dir_all(&out_dir);\n-        create_dir_all(&out_dir).unwrap();\n+        let aux_dir = self.aux_output_dir_name();\n+\n+        rustc.arg(\"-\")\n+            .arg(\"-Zno-trans\")\n+            .arg(\"--out-dir\").arg(&out_dir)\n+            .arg(&format!(\"--target={}\", target))\n+            .arg(\"-L\").arg(&self.config.build_base)\n+            .arg(\"-L\").arg(aux_dir);\n \n-        // FIXME (#9639): This needs to handle non-utf8 paths\n-        let mut args = vec![\"-\".to_owned(),\n-                            \"-Zno-trans\".to_owned(),\n-                            \"--out-dir\".to_owned(),\n-                            out_dir.to_str().unwrap().to_owned(),\n-                            format!(\"--target={}\", target),\n-                            \"-L\".to_owned(),\n-                            self.config.build_base.to_str().unwrap().to_owned(),\n-                            \"-L\".to_owned(),\n-                            aux_dir.to_str().unwrap().to_owned()];\n         if let Some(revision) = self.revision {\n-            args.extend(vec![\n-                \"--cfg\".to_string(),\n-                revision.to_string(),\n-            ]);\n-        }\n-        args.extend(self.split_maybe_args(&self.config.target_rustcflags));\n-        args.extend(self.props.compile_flags.iter().cloned());\n-        // FIXME (#9639): This needs to handle non-utf8 paths\n-        ProcArgs {\n-            prog: self.config.rustc_path.to_str().unwrap().to_owned(),\n-            args,\n+            rustc.args(&[\"--cfg\", revision]);\n         }\n+\n+        rustc.args(self.split_maybe_args(&self.config.target_rustcflags));\n+        rustc.args(&self.props.compile_flags);\n+\n+        self.compose_and_run_compiler(rustc, Some(src))\n     }\n \n     fn run_debuginfo_gdb_test(&self) {\n@@ -500,32 +489,19 @@ actual:\\n\\\n                 debug!(\"script_str = {}\", script_str);\n                 self.dump_output_file(&script_str, \"debugger.script\");\n \n+                let adb_path = &self.config.adb_path;\n \n-                procsrv::run(\"\",\n-                             &self.config.adb_path,\n-                             None,\n-                             &[\n-                                 \"push\".to_owned(),\n-                                 exe_file.to_str().unwrap().to_owned(),\n-                                 self.config.adb_test_dir.clone()\n-                             ],\n-                             Vec::new(),\n-                             None,\n-                             None)\n-                    .expect(&format!(\"failed to exec `{:?}`\", self.config.adb_path));\n-\n-                procsrv::run(\"\",\n-                             &self.config.adb_path,\n-                             None,\n-                             &[\n-                                 \"forward\".to_owned(),\n-                                 \"tcp:5039\".to_owned(),\n-                                 \"tcp:5039\".to_owned()\n-                             ],\n-                             Vec::new(),\n-                             None,\n-                             None)\n-                    .expect(&format!(\"failed to exec `{:?}`\", self.config.adb_path));\n+                Command::new(adb_path)\n+                    .arg(\"push\")\n+                    .arg(&exe_file)\n+                    .arg(&self.config.adb_test_dir)\n+                    .status()\n+                    .expect(&format!(\"failed to exec `{:?}`\", adb_path));\n+\n+                Command::new(adb_path)\n+                    .args(&[\"forward\", \"tcp:5039\", \"tcp:5039\"])\n+                    .status()\n+                    .expect(&format!(\"failed to exec `{:?}`\", adb_path));\n \n                 let adb_arg = format!(\"export LD_LIBRARY_PATH={}; \\\n                                        gdbserver{} :5039 {}/{}\",\n@@ -537,23 +513,17 @@ actual:\\n\\\n                                       .unwrap());\n \n                 debug!(\"adb arg: {}\", adb_arg);\n-                let mut process = procsrv::run_background(\"\",\n-                                                          &self.config.adb_path\n-                                                          ,\n-                                                          None,\n-                                                          &[\n-                                                              \"shell\".to_owned(),\n-                                                              adb_arg.clone()\n-                                                          ],\n-                                                          Vec::new(),\n-                                                          None,\n-                                                          None)\n-                    .expect(&format!(\"failed to exec `{:?}`\", self.config.adb_path));\n+                let mut adb = Command::new(adb_path)\n+                    .args(&[\"shell\", &adb_arg])\n+                    .stdout(Stdio::piped())\n+                    .stderr(Stdio::inherit())\n+                    .spawn()\n+                    .expect(&format!(\"failed to exec `{:?}`\", adb_path));\n \n                 // Wait for the gdbserver to print out \"Listening on port ...\"\n                 // at which point we know that it's started and then we can\n                 // execute the debugger below.\n-                let mut stdout = BufReader::new(process.stdout.take().unwrap());\n+                let mut stdout = BufReader::new(adb.stdout.take().unwrap());\n                 let mut line = String::new();\n                 loop {\n                     line.truncate(0);\n@@ -574,33 +544,29 @@ actual:\\n\\\n \n                 let mut gdb_path = tool_path;\n                 gdb_path.push_str(\"/bin/gdb\");\n-                let procsrv::Result {\n-                    out,\n-                    err,\n-                    status\n-                } = procsrv::run(\"\",\n-                                 &gdb_path,\n-                                 None,\n-                                 &debugger_opts,\n-                                 Vec::new(),\n-                                 None,\n-                                 None)\n+                let Output {\n+                    status,\n+                    stdout,\n+                    stderr\n+                } = Command::new(&gdb_path)\n+                    .args(&debugger_opts)\n+                    .output()\n                     .expect(&format!(\"failed to exec `{:?}`\", gdb_path));\n                 let cmdline = {\n-                    let cmdline = self.make_cmdline(\"\",\n-                                                    &format!(\"{}-gdb\", self.config.target),\n-                                                    &debugger_opts);\n+                    let mut gdb = Command::new(&format!(\"{}-gdb\", self.config.target));\n+                    gdb.args(&debugger_opts);\n+                    let cmdline = self.make_cmdline(&gdb, \"\");\n                     logv(self.config, format!(\"executing {}\", cmdline));\n                     cmdline\n                 };\n \n                 debugger_run_result = ProcRes {\n                     status,\n-                    stdout: out,\n-                    stderr: err,\n+                    stdout: String::from_utf8(stdout).unwrap(),\n+                    stderr: String::from_utf8(stderr).unwrap(),\n                     cmdline,\n                 };\n-                if process.kill().is_err() {\n+                if adb.kill().is_err() {\n                     println!(\"Adb process is already finished.\");\n                 }\n             }\n@@ -679,19 +645,14 @@ actual:\\n\\\n                          \"-nx\".to_owned(),\n                          format!(\"-command={}\", debugger_script.to_str().unwrap())];\n \n-                let proc_args = ProcArgs {\n-                    prog: self.config.gdb.as_ref().unwrap().to_owned(),\n-                    args: debugger_opts,\n-                };\n-\n-                let environment = vec![(\"PYTHONPATH\".to_owned(), rust_pp_module_abs_path)];\n+                let mut gdb = Command::new(self.config.gdb.as_ref().unwrap());\n+                gdb.args(&debugger_opts)\n+                    .env(\"PYTHONPATH\", rust_pp_module_abs_path);\n \n                 debugger_run_result =\n-                    self.compose_and_run(proc_args,\n-                                         environment,\n+                    self.compose_and_run(gdb,\n                                          self.config.run_lib_path.to_str().unwrap(),\n                                          None,\n-                                         None,\n                                          None);\n             }\n         }\n@@ -1154,26 +1115,24 @@ actual:\\n\\\n     }\n \n     fn compile_test(&self) -> ProcRes {\n-        let aux_dir = self.aux_output_dir_name();\n-        // FIXME (#9639): This needs to handle non-utf8 paths\n-        let mut extra_args = vec![\"-L\".to_owned(),\n-                                  aux_dir.to_str().unwrap().to_owned()];\n+        let mut rustc = self.make_compile_args(\n+            &self.testpaths.file, TargetLocation::ThisFile(self.make_exe_name()));\n+\n+        rustc.arg(\"-L\").arg(&self.aux_output_dir_name());\n+\n         match self.config.mode {\n             CompileFail | Ui => {\n                 // compile-fail and ui tests tend to have tons of unused code as\n                 // it's just testing various pieces of the compile, but we don't\n                 // want to actually assert warnings about all this code. Instead\n                 // let's just ignore unused code warnings by defaults and tests\n                 // can turn it back on if needed.\n-                extra_args.push(\"-A\".to_owned());\n-                extra_args.push(\"unused\".to_owned());\n+                rustc.args(&[\"-A\", \"unused\"]);\n             }\n             _ => {}\n         }\n-        let args = self.make_compile_args(extra_args,\n-                                          &self.testpaths.file,\n-                                          TargetLocation::ThisFile(self.make_exe_name()));\n-        self.compose_and_run_compiler(args, None)\n+\n+        self.compose_and_run_compiler(rustc, None)\n     }\n \n     fn document(&self, out_dir: &Path) -> ProcRes {\n@@ -1197,22 +1156,20 @@ actual:\\n\\\n         }\n \n         let aux_dir = self.aux_output_dir_name();\n-        let mut args = vec![\"-L\".to_owned(),\n-                            aux_dir.to_str().unwrap().to_owned(),\n-                            \"-o\".to_owned(),\n-                            out_dir.to_str().unwrap().to_owned(),\n-                            self.testpaths.file.to_str().unwrap().to_owned()];\n-        args.extend(self.props.compile_flags.iter().cloned());\n-        let args = ProcArgs {\n-            prog: self.config.rustdoc_path\n-                .as_ref().expect(\"--rustdoc-path passed\").to_str().unwrap().to_owned(),\n-            args,\n-        };\n-        self.compose_and_run_compiler(args, None)\n+\n+        let rustdoc_path = self.config.rustdoc_path.as_ref().expect(\"--rustdoc-path passed\");\n+        let mut rustdoc = Command::new(rustdoc_path);\n+\n+        rustdoc.arg(\"-L\").arg(aux_dir)\n+            .arg(\"-o\").arg(out_dir)\n+            .arg(&self.testpaths.file)\n+            .args(&self.props.compile_flags);\n+\n+        self.compose_and_run_compiler(rustdoc, None)\n     }\n \n     fn exec_compiled_test(&self) -> ProcRes {\n-        let env = self.props.exec_env.clone();\n+        let env = &self.props.exec_env;\n \n         match &*self.config.target {\n             // This is pretty similar to below, we're transforming:\n@@ -1230,41 +1187,39 @@ actual:\\n\\\n             // the process) and then report back the same result.\n             _ if self.config.remote_test_client.is_some() => {\n                 let aux_dir = self.aux_output_dir_name();\n-                let mut args = self.make_run_args();\n-                let mut program = args.prog.clone();\n+                let ProcArgs { mut prog, args } = self.make_run_args();\n                 if let Ok(entries) = aux_dir.read_dir() {\n                     for entry in entries {\n                         let entry = entry.unwrap();\n                         if !entry.path().is_file() {\n                             continue\n                         }\n-                        program.push_str(\":\");\n-                        program.push_str(entry.path().to_str().unwrap());\n+                        prog.push_str(\":\");\n+                        prog.push_str(entry.path().to_str().unwrap());\n                     }\n                 }\n-                args.args.insert(0, program);\n-                args.args.insert(0, \"run\".to_string());\n-                args.prog = self.config.remote_test_client.clone().unwrap()\n-                                .into_os_string().into_string().unwrap();\n-                self.compose_and_run(args,\n-                                     env,\n+                let mut test_client = Command::new(\n+                    self.config.remote_test_client.as_ref().unwrap());\n+                test_client\n+                    .args(&[\"run\", &prog])\n+                    .args(args)\n+                    .envs(env.clone());\n+                self.compose_and_run(test_client,\n                                      self.config.run_lib_path.to_str().unwrap(),\n                                      Some(aux_dir.to_str().unwrap()),\n-                                     None,\n                                      None)\n             }\n             _ => {\n                 let aux_dir = self.aux_output_dir_name();\n-                let working_dir =\n-                    Some(self.output_base_name()\n-                             .parent().unwrap()\n-                             .to_str().unwrap().to_owned());\n-                self.compose_and_run(self.make_run_args(),\n-                                     env,\n+                let ProcArgs { prog, args } = self.make_run_args();\n+                let mut program = Command::new(&prog);\n+                program.args(args)\n+                    .current_dir(&self.output_base_name().parent().unwrap())\n+                    .envs(env.clone());\n+                self.compose_and_run(program,\n                                      self.config.run_lib_path.to_str().unwrap(),\n                                      Some(aux_dir.to_str().unwrap()),\n-                                     None,\n-                                     working_dir)\n+                                     None)\n             }\n         }\n     }\n@@ -1293,23 +1248,33 @@ actual:\\n\\\n         }\n     }\n \n-    fn compose_and_run_compiler(&self, args: ProcArgs, input: Option<String>) -> ProcRes {\n+    fn compose_and_run_compiler(&self, mut rustc: Command, input: Option<String>) -> ProcRes {\n         if !self.props.aux_builds.is_empty() {\n             create_dir_all(&self.aux_output_dir_name()).unwrap();\n         }\n \n         let aux_dir = self.aux_output_dir_name();\n-        // FIXME (#9639): This needs to handle non-utf8 paths\n-        let extra_link_args = vec![\"-L\".to_owned(),\n-                                   aux_dir.to_str().unwrap().to_owned()];\n \n         for rel_ab in &self.props.aux_builds {\n             let aux_testpaths = self.compute_aux_test_paths(rel_ab);\n             let aux_props = self.props.from_aux_file(&aux_testpaths.file,\n                                                      self.revision,\n                                                      self.config);\n-            let mut crate_type = if aux_props.no_prefer_dynamic {\n-                Vec::new()\n+            let aux_output = {\n+                let f = self.make_lib_name(&self.testpaths.file);\n+                let parent = f.parent().unwrap();\n+                TargetLocation::ThisDirectory(parent.to_path_buf())\n+            };\n+            let aux_cx = TestCx {\n+                config: self.config,\n+                props: &aux_props,\n+                testpaths: &aux_testpaths,\n+                revision: self.revision\n+            };\n+            let mut aux_rustc = aux_cx.make_compile_args(&aux_testpaths.file, aux_output);\n+\n+            let crate_type = if aux_props.no_prefer_dynamic {\n+                None\n             } else if (self.config.target.contains(\"musl\") && !aux_props.force_host) ||\n                       self.config.target.contains(\"emscripten\") {\n                 // We primarily compile all auxiliary libraries as dynamic libraries\n@@ -1321,28 +1286,20 @@ actual:\\n\\\n                 // dynamic libraries so we just go back to building a normal library. Note,\n                 // however, that for MUSL if the library is built with `force_host` then\n                 // it's ok to be a dylib as the host should always support dylibs.\n-                vec![\"--crate-type=lib\".to_owned()]\n+                Some(\"lib\")\n             } else {\n-                vec![\"--crate-type=dylib\".to_owned()]\n-            };\n-            crate_type.extend(extra_link_args.clone());\n-            let aux_output = {\n-                let f = self.make_lib_name(&self.testpaths.file);\n-                let parent = f.parent().unwrap();\n-                TargetLocation::ThisDirectory(parent.to_path_buf())\n+                Some(\"dylib\")\n             };\n-            let aux_cx = TestCx {\n-                config: self.config,\n-                props: &aux_props,\n-                testpaths: &aux_testpaths,\n-                revision: self.revision\n-            };\n-            let aux_args = aux_cx.make_compile_args(crate_type, &aux_testpaths.file, aux_output);\n-            let auxres = aux_cx.compose_and_run(aux_args,\n-                                                Vec::new(),\n+\n+            if let Some(crate_type) = crate_type {\n+                aux_rustc.args(&[\"--crate-type\", crate_type]);\n+            }\n+\n+            aux_rustc.arg(\"-L\").arg(&aux_dir);\n+\n+            let auxres = aux_cx.compose_and_run(aux_rustc,\n                                                 aux_cx.config.compile_lib_path.to_str().unwrap(),\n                                                 Some(aux_dir.to_str().unwrap()),\n-                                                None,\n                                                 None);\n             if !auxres.status.success() {\n                 self.fatal_proc_rec(\n@@ -1352,67 +1309,89 @@ actual:\\n\\\n             }\n         }\n \n-        self.compose_and_run(args,\n-                             self.props.rustc_env.clone(),\n+        rustc.envs(self.props.rustc_env.clone());\n+        self.compose_and_run(rustc,\n                              self.config.compile_lib_path.to_str().unwrap(),\n                              Some(aux_dir.to_str().unwrap()),\n-                             input,\n-                             None)\n+                             input)\n     }\n \n     fn compose_and_run(&self,\n-                       ProcArgs{ args, prog }: ProcArgs,\n-                       procenv: Vec<(String, String)> ,\n+                       mut command: Command,\n                        lib_path: &str,\n                        aux_path: Option<&str>,\n-                       input: Option<String>,\n-                       working_dir: Option<String>) -> ProcRes {\n-        self.program_output(lib_path, prog, aux_path, args, procenv, input, working_dir)\n-    }\n+                       input: Option<String>) -> ProcRes {\n+        let cmdline =\n+        {\n+            let cmdline = self.make_cmdline(&command, lib_path);\n+            logv(self.config, format!(\"executing {}\", cmdline));\n+            cmdline\n+        };\n \n-    fn make_compile_args(&self,\n-                         extras: Vec<String> ,\n-                         input_file: &Path,\n-                         output_file: TargetLocation)\n-                         -> ProcArgs\n-    {\n-        let target = if self.props.force_host {\n-            &*self.config.host\n-        } else {\n-            &*self.config.target\n+        command\n+            .stdout(Stdio::piped())\n+            .stderr(Stdio::piped())\n+            .stdin(Stdio::piped());\n+\n+        // Need to be sure to put both the lib_path and the aux path in the dylib\n+        // search path for the child.\n+        let mut path = env::split_paths(&env::var_os(dylib_env_var()).unwrap_or(OsString::new()))\n+            .collect::<Vec<_>>();\n+        if let Some(p) = aux_path {\n+            path.insert(0, PathBuf::from(p))\n+        }\n+        path.insert(0, PathBuf::from(lib_path));\n+\n+        // Add the new dylib search path var\n+        let newpath = env::join_paths(&path).unwrap();\n+        command.env(dylib_env_var(), newpath);\n+\n+        let mut child = command.spawn().expect(&format!(\"failed to exec `{:?}`\", &command));\n+        if let Some(input) = input {\n+            child.stdin.as_mut().unwrap().write_all(input.as_bytes()).unwrap();\n+        }\n+        let Output { status, stdout, stderr } = child.wait_with_output().unwrap();\n+\n+        let result = ProcRes {\n+            status,\n+            stdout: String::from_utf8(stdout).unwrap(),\n+            stderr: String::from_utf8(stderr).unwrap(),\n+            cmdline,\n         };\n \n-        // FIXME (#9639): This needs to handle non-utf8 paths\n-        let mut args = vec![input_file.to_str().unwrap().to_owned(),\n-                            \"-L\".to_owned(),\n-                            self.config.build_base.to_str().unwrap().to_owned()];\n+        self.dump_output(&result.stdout, &result.stderr);\n+\n+        result\n+    }\n+\n+    fn make_compile_args(&self, input_file: &Path, output_file: TargetLocation) -> Command {\n+        let mut rustc = Command::new(&self.config.rustc_path);\n+        rustc.arg(input_file)\n+            .arg(\"-L\").arg(&self.config.build_base);\n \n         // Optionally prevent default --target if specified in test compile-flags.\n         let custom_target = self.props.compile_flags\n             .iter()\n             .fold(false, |acc, x| acc || x.starts_with(\"--target\"));\n \n         if !custom_target {\n-            args.extend(vec![\n-                format!(\"--target={}\", target),\n-            ]);\n+            let target = if self.props.force_host {\n+                &*self.config.host\n+            } else {\n+                &*self.config.target\n+            };\n+\n+            rustc.arg(&format!(\"--target={}\", target));\n         }\n \n         if let Some(revision) = self.revision {\n-            args.extend(vec![\n-                \"--cfg\".to_string(),\n-                revision.to_string(),\n-            ]);\n+            rustc.args(&[\"--cfg\", revision]);\n         }\n \n         if let Some(ref incremental_dir) = self.props.incremental_dir {\n-            args.extend(vec![\n-                \"-Z\".to_string(),\n-                format!(\"incremental={}\", incremental_dir.display()),\n-            ]);\n+            rustc.args(&[\"-Z\", &format!(\"incremental={}\", incremental_dir.display())]);\n         }\n \n-\n         match self.config.mode {\n             CompileFail |\n             ParseFail |\n@@ -1421,27 +1400,22 @@ actual:\\n\\\n                 // fashion, then you want JSON mode. Old-skool error\n                 // patterns still match the raw compiler output.\n                 if self.props.error_patterns.is_empty() {\n-                    args.extend([\"--error-format\",\n-                                 \"json\"]\n-                                .iter()\n-                                .map(|s| s.to_string()));\n+                    rustc.args(&[\"--error-format\", \"json\"]);\n                 }\n             }\n             MirOpt => {\n-                args.extend([\"-Zdump-mir=all\",\n-                             \"-Zmir-opt-level=3\",\n-                             \"-Zdump-mir-exclude-pass-number\"]\n-                            .iter()\n-                            .map(|s| s.to_string()));\n-\n+                rustc.args(&[\n+                    \"-Zdump-mir=all\",\n+                    \"-Zmir-opt-level=3\",\n+                    \"-Zdump-mir-exclude-pass-number\"]);\n \n                 let mir_dump_dir = self.get_mir_dump_dir();\n                 create_dir_all(mir_dump_dir.as_path()).unwrap();\n                 let mut dir_opt = \"-Zdump-mir-dir=\".to_string();\n                 dir_opt.push_str(mir_dump_dir.to_str().unwrap());\n                 debug!(\"dir_opt: {:?}\", dir_opt);\n \n-                args.push(dir_opt);\n+                rustc.arg(dir_opt);\n             }\n             RunPass |\n             RunFail |\n@@ -1458,32 +1432,28 @@ actual:\\n\\\n             }\n         }\n \n-        args.extend_from_slice(&extras);\n         if !self.props.no_prefer_dynamic {\n-            args.push(\"-C\".to_owned());\n-            args.push(\"prefer-dynamic\".to_owned());\n+            rustc.args(&[\"-C\", \"prefer-dynamic\"]);\n         }\n-        let path = match output_file {\n+\n+        match output_file {\n             TargetLocation::ThisFile(path) => {\n-                args.push(\"-o\".to_owned());\n-                path\n+                rustc.arg(\"-o\").arg(path);\n             }\n             TargetLocation::ThisDirectory(path) => {\n-                args.push(\"--out-dir\".to_owned());\n-                path\n+                rustc.arg(\"--out-dir\").arg(path);\n             }\n-        };\n-        args.push(path.to_str().unwrap().to_owned());\n+        }\n+\n         if self.props.force_host {\n-            args.extend(self.split_maybe_args(&self.config.host_rustcflags));\n+            rustc.args(self.split_maybe_args(&self.config.host_rustcflags));\n         } else {\n-            args.extend(self.split_maybe_args(&self.config.target_rustcflags));\n-        }\n-        args.extend(self.props.compile_flags.iter().cloned());\n-        ProcArgs {\n-            prog: self.config.rustc_path.to_str().unwrap().to_owned(),\n-            args,\n+            rustc.args(self.split_maybe_args(&self.config.target_rustcflags));\n         }\n+\n+        rustc.args(&self.props.compile_flags);\n+\n+        rustc\n     }\n \n     fn make_lib_name(&self, auxfile: &Path) -> PathBuf {\n@@ -1554,58 +1524,20 @@ actual:\\n\\\n         }\n     }\n \n-    fn program_output(&self,\n-                      lib_path: &str,\n-                      prog: String,\n-                      aux_path: Option<&str>,\n-                      args: Vec<String>,\n-                      env: Vec<(String, String)>,\n-                      input: Option<String>,\n-                      working_dir: Option<String>)\n-                      -> ProcRes {\n-        let cmdline =\n-        {\n-            let cmdline = self.make_cmdline(lib_path,\n-                                            &prog,\n-                                            &args);\n-            logv(self.config, format!(\"executing {}\", cmdline));\n-            cmdline\n-        };\n-\n-        let procsrv::Result {\n-            out,\n-            err,\n-            status\n-        } = procsrv::run(lib_path,\n-                         &prog,\n-                         aux_path,\n-                         &args,\n-                         env,\n-                         input,\n-                         working_dir).expect(&format!(\"failed to exec `{}`\", prog));\n-        self.dump_output(&out, &err);\n-        ProcRes {\n-            status,\n-            stdout: out,\n-            stderr: err,\n-            cmdline,\n-        }\n-    }\n-\n-    fn make_cmdline(&self, libpath: &str, prog: &str, args: &[String]) -> String {\n+    fn make_cmdline(&self, command: &Command, libpath: &str) -> String {\n         use util;\n \n         // Linux and mac don't require adjusting the library search path\n         if cfg!(unix) {\n-            format!(\"{} {}\", prog, args.join(\" \"))\n+            format!(\"{:?}\", command)\n         } else {\n             // Build the LD_LIBRARY_PATH variable as it would be seen on the command line\n             // for diagnostic purposes\n             fn lib_path_cmd_prefix(path: &str) -> String {\n                 format!(\"{}=\\\"{}\\\"\", util::lib_path_env_var(), util::make_new_path(path))\n             }\n \n-            format!(\"{} {} {}\", lib_path_cmd_prefix(libpath), prog, args.join(\" \"))\n+            format!(\"{} {:?}\", lib_path_cmd_prefix(libpath), command)\n         }\n     }\n \n@@ -1723,30 +1655,22 @@ actual:\\n\\\n \n     fn compile_test_and_save_ir(&self) -> ProcRes {\n         let aux_dir = self.aux_output_dir_name();\n-        // FIXME (#9639): This needs to handle non-utf8 paths\n-        let mut link_args = vec![\"-L\".to_owned(),\n-                                 aux_dir.to_str().unwrap().to_owned()];\n-        let llvm_args = vec![\"--emit=llvm-ir\".to_owned(),];\n-        link_args.extend(llvm_args);\n-        let args = self.make_compile_args(link_args,\n-                                          &self.testpaths.file,\n-                                          TargetLocation::ThisDirectory(\n-                                              self.output_base_name().parent()\n-                                                                     .unwrap()\n-                                                                     .to_path_buf()));\n-        self.compose_and_run_compiler(args, None)\n+\n+        let output_file = TargetLocation::ThisDirectory(\n+            self.output_base_name().parent().unwrap().to_path_buf());\n+        let mut rustc = self.make_compile_args(&self.testpaths.file, output_file);\n+        rustc.arg(\"-L\").arg(aux_dir)\n+            .arg(\"--emit=llvm-ir\");\n+\n+        self.compose_and_run_compiler(rustc, None)\n     }\n \n     fn check_ir_with_filecheck(&self) -> ProcRes {\n         let irfile = self.output_base_name().with_extension(\"ll\");\n-        let prog = self.config.llvm_filecheck.as_ref().unwrap();\n-        let proc_args = ProcArgs {\n-            // FIXME (#9639): This needs to handle non-utf8 paths\n-            prog: prog.to_str().unwrap().to_owned(),\n-            args: vec![format!(\"-input-file={}\", irfile.to_str().unwrap()),\n-                       self.testpaths.file.to_str().unwrap().to_owned()]\n-        };\n-        self.compose_and_run(proc_args, Vec::new(), \"\", None, None, None)\n+        let mut filecheck = Command::new(self.config.llvm_filecheck.as_ref().unwrap());\n+        filecheck.arg(\"--input-file\").arg(irfile)\n+            .arg(&self.testpaths.file);\n+        self.compose_and_run(filecheck, \"\", None, None)\n     }\n \n     fn run_codegen_test(&self) {\n@@ -2179,7 +2103,7 @@ actual:\\n\\\n            .env(\"RUSTDOC\",\n                cwd.join(&self.config.rustdoc_path.as_ref().expect(\"--rustdoc-path passed\")))\n            .env(\"TMPDIR\", &tmpdir)\n-           .env(\"LD_LIB_PATH_ENVVAR\", procsrv::dylib_env_var())\n+           .env(\"LD_LIB_PATH_ENVVAR\", dylib_env_var())\n            .env(\"HOST_RPATH_DIR\", cwd.join(&self.config.compile_lib_path))\n            .env(\"TARGET_RPATH_DIR\", cwd.join(&self.config.run_lib_path))\n            .env(\"LLVM_COMPONENTS\", &self.config.llvm_components)"}]}