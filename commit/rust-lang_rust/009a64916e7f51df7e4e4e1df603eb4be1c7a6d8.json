{"sha": "009a64916e7f51df7e4e4e1df603eb4be1c7a6d8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAwOWE2NDkxNmU3ZjUxZGY3ZTRlNGUxZGY2MDNlYjRiZTFjN2E2ZDg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-04-28T08:26:45Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-04-28T08:26:45Z"}, "message": "Auto merge of #32980 - Aatch:better-mir-building, r=nagisa\n\nVarious improvements to MIR and LLVM IR Construction\n\nPrimarily affects the MIR construction, which indirectly improves LLVM\nIR generation, but some LLVM IR changes have been made too.\n\n* Handle \"statement expressions\" more intelligently. These are\n  expressions that always evaluate to `()`. Previously a temporary would\n  be generated as a destination to translate into, which is unnecessary.\n\n  This affects assignment, augmented assignment, `return`, `break` and\n  `continue`.\n* Avoid inserting drops for non-drop types in more places. Scheduled\n  drops were already skipped for types that we knew wouldn't need\n  dropping at construction time. However manually-inserted drops like\n  those for `x` in `x = y;` were still generated. `build_drop` now takes\n  a type parameter like its `schedule_drop` counterpart and checks to\n  see if the type needs dropping.\n\n* Avoid generating an extra temporary for an assignment where the types\n  involved don't need dropping. Previously an expression like\n  `a = b + 1;` would result in a temporary for `b + 1`. This is so the\n  RHS can be evaluated, then the LHS evaluated and dropped and have\n  everything work correctly. However, this isn't necessary if the `LHS`\n  doesn't need a drop, as we can just overwrite the existing value.\n\n* Improves lvalue analysis to allow treating an `Rvalue::Use` as an\n  operand in certain conditions. The reason for it never being an\n  operand is so it can be zeroed/drop-filled, but this is only true for\n  types that need dropping.\n\nThe first two changes result in significantly fewer MIR blocks being\ngenerated, as previously almost every statement would end up generating\na new block due to the drop of the `()` temporary being generated.", "tree": {"sha": "6acdf574529f5f4027fab5c3c097cd69bf360058", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6acdf574529f5f4027fab5c3c097cd69bf360058"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/009a64916e7f51df7e4e4e1df603eb4be1c7a6d8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/009a64916e7f51df7e4e4e1df603eb4be1c7a6d8", "html_url": "https://github.com/rust-lang/rust/commit/009a64916e7f51df7e4e4e1df603eb4be1c7a6d8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/009a64916e7f51df7e4e4e1df603eb4be1c7a6d8/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cf3970aac536ea446a967a246cc3527a11d89655", "url": "https://api.github.com/repos/rust-lang/rust/commits/cf3970aac536ea446a967a246cc3527a11d89655", "html_url": "https://github.com/rust-lang/rust/commit/cf3970aac536ea446a967a246cc3527a11d89655"}, {"sha": "5bda576cd6b3be40f62a37e134ee7245e911fb8b", "url": "https://api.github.com/repos/rust-lang/rust/commits/5bda576cd6b3be40f62a37e134ee7245e911fb8b", "html_url": "https://github.com/rust-lang/rust/commit/5bda576cd6b3be40f62a37e134ee7245e911fb8b"}], "stats": {"total": 480, "additions": 298, "deletions": 182}, "files": [{"sha": "49029f9642e087c1655e7b12b2083a4f6dde6bc2", "filename": "src/librustc_mir/build/block.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/009a64916e7f51df7e4e4e1df603eb4be1c7a6d8/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/009a64916e7f51df7e4e4e1df603eb4be1c7a6d8/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fblock.rs?ref=009a64916e7f51df7e4e4e1df603eb4be1c7a6d8", "patch": "@@ -44,11 +44,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                     StmtKind::Expr { scope, expr } => {\n                         unpack!(block = this.in_scope(scope, block, |this, _| {\n                             let expr = this.hir.mirror(expr);\n-                            let expr_span = expr.span;\n-                            let temp = this.temp(expr.ty.clone());\n-                            unpack!(block = this.into(&temp, block, expr));\n-                            unpack!(block = this.build_drop(block, expr_span, temp));\n-                            block.unit()\n+                            this.stmt_expr(block, expr)\n                         }));\n                     }\n                     StmtKind::Let { remainder_scope, init_scope, pattern, initializer } => {"}, {"sha": "8992381135ea873d0a379e1218ba180813467104", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/009a64916e7f51df7e4e4e1df603eb4be1c7a6d8/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/009a64916e7f51df7e4e4e1df603eb4be1c7a6d8/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=009a64916e7f51df7e4e4e1df603eb4be1c7a6d8", "patch": "@@ -189,6 +189,11 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                 block.and(Rvalue::Aggregate(AggregateKind::Adt(adt_def, variant_index, substs),\n                                             fields))\n             }\n+            ExprKind::Assign { .. } |\n+            ExprKind::AssignOp { .. } => {\n+                block = unpack!(this.stmt_expr(block, expr));\n+                block.and(this.unit_rvalue())\n+            }\n             ExprKind::Literal { .. } |\n             ExprKind::Block { .. } |\n             ExprKind::Match { .. } |\n@@ -201,8 +206,6 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n             ExprKind::Index { .. } |\n             ExprKind::VarRef { .. } |\n             ExprKind::SelfRef |\n-            ExprKind::Assign { .. } |\n-            ExprKind::AssignOp { .. } |\n             ExprKind::Break { .. } |\n             ExprKind::Continue { .. } |\n             ExprKind::Return { .. } |"}, {"sha": "b7729b01737bad6628f5fbd22c76039aa603c92d", "filename": "src/librustc_mir/build/expr/into.rs", "status": "modified", "additions": 9, "deletions": 78, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/009a64916e7f51df7e4e4e1df603eb4be1c7a6d8/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/009a64916e7f51df7e4e4e1df603eb4be1c7a6d8/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs?ref=009a64916e7f51df7e4e4e1df603eb4be1c7a6d8", "patch": "@@ -12,12 +12,9 @@\n \n use build::{BlockAnd, BlockAndExtension, Builder};\n use build::expr::category::{Category, RvalueFunc};\n-use build::scope::LoopScope;\n use hair::*;\n-use rustc::middle::region::CodeExtent;\n use rustc::ty;\n use rustc::mir::repr::*;\n-use syntax::codemap::Span;\n \n impl<'a,'tcx> Builder<'a,'tcx> {\n     /// Compile `expr`, storing the result into `destination`, which\n@@ -207,65 +204,6 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                 }\n                 exit_block.unit()\n             }\n-            ExprKind::Assign { lhs, rhs } => {\n-                // Note: we evaluate assignments right-to-left. This\n-                // is better for borrowck interaction with overloaded\n-                // operators like x[j] = x[i].\n-                let lhs = this.hir.mirror(lhs);\n-                let lhs_span = lhs.span;\n-                let rhs = unpack!(block = this.as_operand(block, rhs));\n-                let lhs = unpack!(block = this.as_lvalue(block, lhs));\n-                unpack!(block = this.build_drop(block, lhs_span, lhs.clone()));\n-                this.cfg.push_assign(block, scope_id, expr_span, &lhs, Rvalue::Use(rhs));\n-                block.unit()\n-            }\n-            ExprKind::AssignOp { op, lhs, rhs } => {\n-                // FIXME(#28160) there is an interesting semantics\n-                // question raised here -- should we \"freeze\" the\n-                // value of the lhs here?  I'm inclined to think not,\n-                // since it seems closer to the semantics of the\n-                // overloaded version, which takes `&mut self`.  This\n-                // only affects weird things like `x += {x += 1; x}`\n-                // -- is that equal to `x + (x + 1)` or `2*(x+1)`?\n-\n-                // As above, RTL.\n-                let rhs = unpack!(block = this.as_operand(block, rhs));\n-                let lhs = unpack!(block = this.as_lvalue(block, lhs));\n-\n-                // we don't have to drop prior contents or anything\n-                // because AssignOp is only legal for Copy types\n-                // (overloaded ops should be desugared into a call).\n-                this.cfg.push_assign(block, scope_id, expr_span, &lhs,\n-                                     Rvalue::BinaryOp(op,\n-                                                      Operand::Consume(lhs.clone()),\n-                                                      rhs));\n-\n-                block.unit()\n-            }\n-            ExprKind::Continue { label } => {\n-                this.break_or_continue(expr_span, label, block,\n-                                       |loop_scope| loop_scope.continue_block)\n-            }\n-            ExprKind::Break { label } => {\n-                this.break_or_continue(expr_span, label, block, |loop_scope| {\n-                    loop_scope.might_break = true;\n-                    loop_scope.break_block\n-                })\n-            }\n-            ExprKind::Return { value } => {\n-                block = match value {\n-                    Some(value) => unpack!(this.into(&Lvalue::ReturnPointer, block, value)),\n-                    None => {\n-                        this.cfg.push_assign_unit(block, scope_id,\n-                                                  expr_span, &Lvalue::ReturnPointer);\n-                        block\n-                    }\n-                };\n-                let extent = this.extent_of_return_scope();\n-                let return_block = this.return_block();\n-                this.exit_scope(expr_span, extent, block, return_block);\n-                this.cfg.start_new_block().unit()\n-            }\n             ExprKind::Call { ty, fun, args } => {\n                 let diverges = match ty.sty {\n                     ty::TyFnDef(_, _, ref f) | ty::TyFnPtr(ref f) => {\n@@ -294,6 +232,15 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                 success.unit()\n             }\n \n+            // These cases don't actually need a destination\n+            ExprKind::Assign { .. } |\n+            ExprKind::AssignOp { .. } |\n+            ExprKind::Continue { .. } |\n+            ExprKind::Break { .. } |\n+            ExprKind::Return {.. } => {\n+                this.stmt_expr(block, expr)\n+            }\n+\n             // these are the cases that are more naturally handled by some other mode\n             ExprKind::Unary { .. } |\n             ExprKind::Binary { .. } |\n@@ -327,20 +274,4 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n             }\n         }\n     }\n-\n-    fn break_or_continue<F>(&mut self,\n-                            span: Span,\n-                            label: Option<CodeExtent>,\n-                            block: BasicBlock,\n-                            exit_selector: F)\n-                            -> BlockAnd<()>\n-        where F: FnOnce(&mut LoopScope) -> BasicBlock\n-    {\n-        let (exit_block, extent) = {\n-            let loop_scope = self.find_loop_scope(span, label);\n-            (exit_selector(loop_scope), loop_scope.extent)\n-        };\n-        self.exit_scope(span, extent, block, exit_block);\n-        self.cfg.start_new_block().unit()\n-    }\n }"}, {"sha": "17b34f4586e8b6e0cdc65db49e54a359cbb4987f", "filename": "src/librustc_mir/build/expr/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/009a64916e7f51df7e4e4e1df603eb4be1c7a6d8/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/009a64916e7f51df7e4e4e1df603eb4be1c7a6d8/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fmod.rs?ref=009a64916e7f51df7e4e4e1df603eb4be1c7a6d8", "patch": "@@ -77,3 +77,4 @@ mod as_operand;\n mod as_temp;\n mod category;\n mod into;\n+mod stmt;"}, {"sha": "3c1672b919751172031677c10f67944d999a6514", "filename": "src/librustc_mir/build/expr/stmt.rs", "status": "added", "additions": 135, "deletions": 0, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/009a64916e7f51df7e4e4e1df603eb4be1c7a6d8/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/009a64916e7f51df7e4e4e1df603eb4be1c7a6d8/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fstmt.rs?ref=009a64916e7f51df7e4e4e1df603eb4be1c7a6d8", "patch": "@@ -0,0 +1,135 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use build::{BlockAnd, BlockAndExtension, Builder};\n+use build::scope::LoopScope;\n+use hair::*;\n+use rustc::middle::region::CodeExtent;\n+use rustc::mir::repr::*;\n+use syntax::codemap::Span;\n+\n+impl<'a,'tcx> Builder<'a,'tcx> {\n+\n+    pub fn stmt_expr(&mut self, mut block: BasicBlock, expr: Expr<'tcx>) -> BlockAnd<()> {\n+        let this = self;\n+        let expr_span = expr.span;\n+        let scope_id = this.innermost_scope_id();\n+        // Handle a number of expressions that don't need a destination at all. This\n+        // avoids needing a mountain of temporary `()` variables.\n+        match expr.kind {\n+            ExprKind::Scope { extent, value } => {\n+                let value = this.hir.mirror(value);\n+                this.in_scope(extent, block, |this, _| this.stmt_expr(block, value))\n+            }\n+            ExprKind::Assign { lhs, rhs } => {\n+                let lhs = this.hir.mirror(lhs);\n+                let rhs = this.hir.mirror(rhs);\n+                let scope_id = this.innermost_scope_id();\n+                let lhs_span = lhs.span;\n+\n+                let lhs_ty = lhs.ty;\n+                let rhs_ty = rhs.ty;\n+\n+                let lhs_needs_drop = this.hir.needs_drop(lhs_ty);\n+                let rhs_needs_drop = this.hir.needs_drop(rhs_ty);\n+\n+                // Note: we evaluate assignments right-to-left. This\n+                // is better for borrowck interaction with overloaded\n+                // operators like x[j] = x[i].\n+\n+                // Generate better code for things that don't need to be\n+                // dropped.\n+                let rhs = if lhs_needs_drop || rhs_needs_drop {\n+                    let op = unpack!(block = this.as_operand(block, rhs));\n+                    Rvalue::Use(op)\n+                } else {\n+                    unpack!(block = this.as_rvalue(block, rhs))\n+                };\n+\n+                let lhs = unpack!(block = this.as_lvalue(block, lhs));\n+                unpack!(block = this.build_drop(block, lhs_span, lhs.clone(), lhs_ty));\n+                this.cfg.push_assign(block, scope_id, expr_span, &lhs, rhs);\n+                block.unit()\n+            }\n+            ExprKind::AssignOp { op, lhs, rhs } => {\n+                // FIXME(#28160) there is an interesting semantics\n+                // question raised here -- should we \"freeze\" the\n+                // value of the lhs here?  I'm inclined to think not,\n+                // since it seems closer to the semantics of the\n+                // overloaded version, which takes `&mut self`.  This\n+                // only affects weird things like `x += {x += 1; x}`\n+                // -- is that equal to `x + (x + 1)` or `2*(x+1)`?\n+\n+                // As above, RTL.\n+                let rhs = unpack!(block = this.as_operand(block, rhs));\n+                let lhs = unpack!(block = this.as_lvalue(block, lhs));\n+\n+                // we don't have to drop prior contents or anything\n+                // because AssignOp is only legal for Copy types\n+                // (overloaded ops should be desugared into a call).\n+                this.cfg.push_assign(block, scope_id, expr_span, &lhs,\n+                                     Rvalue::BinaryOp(op,\n+                                                      Operand::Consume(lhs.clone()),\n+                                                      rhs));\n+\n+                block.unit()\n+            }\n+            ExprKind::Continue { label } => {\n+                this.break_or_continue(expr_span, label, block,\n+                                       |loop_scope| loop_scope.continue_block)\n+            }\n+            ExprKind::Break { label } => {\n+                this.break_or_continue(expr_span, label, block, |loop_scope| {\n+                    loop_scope.might_break = true;\n+                    loop_scope.break_block\n+                })\n+            }\n+            ExprKind::Return { value } => {\n+                block = match value {\n+                    Some(value) => unpack!(this.into(&Lvalue::ReturnPointer, block, value)),\n+                    None => {\n+                        this.cfg.push_assign_unit(block, scope_id,\n+                                                  expr_span, &Lvalue::ReturnPointer);\n+                        block\n+                    }\n+                };\n+                let extent = this.extent_of_return_scope();\n+                let return_block = this.return_block();\n+                this.exit_scope(expr_span, extent, block, return_block);\n+                this.cfg.start_new_block().unit()\n+            }\n+            _ => {\n+                let expr_span = expr.span;\n+                let expr_ty = expr.ty;\n+                let temp = this.temp(expr.ty.clone());\n+                unpack!(block = this.into(&temp, block, expr));\n+                unpack!(block = this.build_drop(block, expr_span, temp, expr_ty));\n+                block.unit()\n+            }\n+        }\n+    }\n+\n+    fn break_or_continue<F>(&mut self,\n+                            span: Span,\n+                            label: Option<CodeExtent>,\n+                            block: BasicBlock,\n+                            exit_selector: F)\n+                            -> BlockAnd<()>\n+        where F: FnOnce(&mut LoopScope) -> BasicBlock\n+    {\n+        let (exit_block, extent) = {\n+            let loop_scope = self.find_loop_scope(span, label);\n+            (exit_selector(loop_scope), loop_scope.extent)\n+        };\n+        self.exit_scope(span, extent, block, exit_block);\n+        self.cfg.start_new_block().unit()\n+    }\n+\n+}"}, {"sha": "5daaf37d878144a58c574496a2c53b0eacdd8eb9", "filename": "src/librustc_mir/build/misc.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/009a64916e7f51df7e4e4e1df603eb4be1c7a6d8/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/009a64916e7f51df7e4e4e1df603eb4be1c7a6d8/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs?ref=009a64916e7f51df7e4e4e1df603eb4be1c7a6d8", "patch": "@@ -46,6 +46,10 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n         Operand::Constant(constant)\n     }\n \n+    pub fn unit_rvalue(&mut self) -> Rvalue<'tcx> {\n+        Rvalue::Aggregate(AggregateKind::Tuple, vec![])\n+    }\n+\n     pub fn push_usize(&mut self,\n                       block: BasicBlock,\n                       scope_id: ScopeId,"}, {"sha": "95c931df9e5cc3a7f56cd5c01faade649b59f762", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/009a64916e7f51df7e4e4e1df603eb4be1c7a6d8/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/009a64916e7f51df7e4e4e1df603eb4be1c7a6d8/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=009a64916e7f51df7e4e4e1df603eb4be1c7a6d8", "patch": "@@ -497,8 +497,11 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n     pub fn build_drop(&mut self,\n                       block: BasicBlock,\n                       span: Span,\n-                      value: Lvalue<'tcx>)\n-                      -> BlockAnd<()> {\n+                      value: Lvalue<'tcx>,\n+                      ty: Ty<'tcx>) -> BlockAnd<()> {\n+        if !self.hir.needs_drop(ty) {\n+            return block.unit();\n+        }\n         let scope_id = self.innermost_scope_id();\n         let next_target = self.cfg.start_new_block();\n         let diverge_target = self.diverge_cleanup();"}, {"sha": "9f032cdbfe5130fa42b2dff8a9e2b289150179c2", "filename": "src/librustc_trans/builder.rs", "status": "modified", "additions": 31, "deletions": 24, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/009a64916e7f51df7e4e4e1df603eb4be1c7a6d8/src%2Flibrustc_trans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/009a64916e7f51df7e4e4e1df603eb4be1c7a6d8/src%2Flibrustc_trans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbuilder.rs?ref=009a64916e7f51df7e4e4e1df603eb4be1c7a6d8", "patch": "@@ -165,8 +165,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                   args: &[ValueRef],\n                   then: BasicBlockRef,\n                   catch: BasicBlockRef,\n-                  bundle: Option<&OperandBundleDef>)\n-                  -> ValueRef {\n+                  bundle: Option<&OperandBundleDef>) -> ValueRef {\n         self.count_insn(\"invoke\");\n \n         debug!(\"Invoke {:?} with args ({})\",\n@@ -176,6 +175,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                    .collect::<Vec<String>>()\n                    .join(\", \"));\n \n+        check_call(\"invoke\", llfn, args);\n+\n         let bundle = bundle.as_ref().map(|b| b.raw()).unwrap_or(0 as *mut _);\n \n         unsafe {\n@@ -856,28 +857,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                    .collect::<Vec<String>>()\n                    .join(\", \"));\n \n-        let mut fn_ty = val_ty(llfn);\n-        // Strip off pointers\n-        while fn_ty.kind() == llvm::TypeKind::Pointer {\n-            fn_ty = fn_ty.element_type();\n-        }\n-\n-        assert!(fn_ty.kind() == llvm::TypeKind::Function,\n-                \"builder::call not passed a function\");\n-\n-        let param_tys = fn_ty.func_params();\n-\n-        let iter = param_tys.into_iter()\n-            .zip(args.iter().map(|&v| val_ty(v)));\n-        for (i, (expected_ty, actual_ty)) in iter.enumerate() {\n-            if expected_ty != actual_ty {\n-                bug!(\"Type mismatch in function call of {:?}. \\\n-                      Expected {:?} for param {}, got {:?}\",\n-                     Value(llfn),\n-                     expected_ty, i, actual_ty);\n-\n-            }\n-        }\n+        check_call(\"call\", llfn, args);\n \n         let bundle = bundle.as_ref().map(|b| b.raw()).unwrap_or(0 as *mut _);\n \n@@ -1121,3 +1101,30 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n     }\n }\n+\n+fn check_call(typ: &str, llfn: ValueRef, args: &[ValueRef]) {\n+    if cfg!(debug_assertions) {\n+        let mut fn_ty = val_ty(llfn);\n+        // Strip off pointers\n+        while fn_ty.kind() == llvm::TypeKind::Pointer {\n+            fn_ty = fn_ty.element_type();\n+        }\n+\n+        assert!(fn_ty.kind() == llvm::TypeKind::Function,\n+                \"builder::{} not passed a function\", typ);\n+\n+        let param_tys = fn_ty.func_params();\n+\n+        let iter = param_tys.into_iter()\n+            .zip(args.iter().map(|&v| val_ty(v)));\n+        for (i, (expected_ty, actual_ty)) in iter.enumerate() {\n+            if expected_ty != actual_ty {\n+                bug!(\"Type mismatch in function call of {:?}. \\\n+                      Expected {:?} for param {}, got {:?}\",\n+                     Value(llfn),\n+                     expected_ty, i, actual_ty);\n+\n+            }\n+        }\n+    }\n+}"}, {"sha": "0b88ba554da678fa0d1aa79978fe46b926b3ea5a", "filename": "src/librustc_trans/mir/analyze.rs", "status": "modified", "additions": 17, "deletions": 10, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/009a64916e7f51df7e4e4e1df603eb4be1c7a6d8/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/009a64916e7f51df7e4e4e1df603eb4be1c7a6d8/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs?ref=009a64916e7f51df7e4e4e1df603eb4be1c7a6d8", "patch": "@@ -14,13 +14,13 @@\n use rustc_data_structures::bitvec::BitVector;\n use rustc::mir::repr as mir;\n use rustc::mir::visit::{Visitor, LvalueContext};\n-use common::{self, Block};\n+use common::{self, Block, BlockAndBuilder};\n use super::rvalue;\n \n pub fn lvalue_temps<'bcx,'tcx>(bcx: Block<'bcx,'tcx>,\n-                               mir: &mir::Mir<'tcx>)\n-                               -> BitVector {\n-    let mut analyzer = TempAnalyzer::new(mir.temp_decls.len());\n+                               mir: &mir::Mir<'tcx>) -> BitVector {\n+    let bcx = bcx.build();\n+    let mut analyzer = TempAnalyzer::new(mir, &bcx, mir.temp_decls.len());\n \n     analyzer.visit_mir(mir);\n \n@@ -30,7 +30,8 @@ pub fn lvalue_temps<'bcx,'tcx>(bcx: Block<'bcx,'tcx>,\n         if ty.is_scalar() ||\n             ty.is_unique() ||\n             ty.is_region_ptr() ||\n-            ty.is_simd()\n+            ty.is_simd() ||\n+            common::type_is_zero_size(bcx.ccx(), ty)\n         {\n             // These sorts of types are immediates that we can store\n             // in an ValueRef without an alloca.\n@@ -50,14 +51,20 @@ pub fn lvalue_temps<'bcx,'tcx>(bcx: Block<'bcx,'tcx>,\n     analyzer.lvalue_temps\n }\n \n-struct TempAnalyzer {\n+struct TempAnalyzer<'mir, 'bcx: 'mir, 'tcx: 'bcx> {\n+    mir: &'mir mir::Mir<'tcx>,\n+    bcx: &'mir BlockAndBuilder<'bcx, 'tcx>,\n     lvalue_temps: BitVector,\n     seen_assigned: BitVector\n }\n \n-impl TempAnalyzer {\n-    fn new(temp_count: usize) -> TempAnalyzer {\n+impl<'mir, 'bcx, 'tcx> TempAnalyzer<'mir, 'bcx, 'tcx> {\n+    fn new(mir: &'mir mir::Mir<'tcx>,\n+           bcx: &'mir BlockAndBuilder<'bcx, 'tcx>,\n+           temp_count: usize) -> TempAnalyzer<'mir, 'bcx, 'tcx> {\n         TempAnalyzer {\n+            mir: mir,\n+            bcx: bcx,\n             lvalue_temps: BitVector::new(temp_count),\n             seen_assigned: BitVector::new(temp_count)\n         }\n@@ -75,7 +82,7 @@ impl TempAnalyzer {\n     }\n }\n \n-impl<'tcx> Visitor<'tcx> for TempAnalyzer {\n+impl<'mir, 'bcx, 'tcx> Visitor<'tcx> for TempAnalyzer<'mir, 'bcx, 'tcx> {\n     fn visit_assign(&mut self,\n                     block: mir::BasicBlock,\n                     lvalue: &mir::Lvalue<'tcx>,\n@@ -85,7 +92,7 @@ impl<'tcx> Visitor<'tcx> for TempAnalyzer {\n         match *lvalue {\n             mir::Lvalue::Temp(index) => {\n                 self.mark_assigned(index as usize);\n-                if !rvalue::rvalue_creates_operand(rvalue) {\n+                if !rvalue::rvalue_creates_operand(self.mir, self.bcx, rvalue) {\n                     self.mark_as_lvalue(index as usize);\n                 }\n             }"}, {"sha": "d0b47934bcf16baae773ca6ee71e7d5df9b39401", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 36, "deletions": 36, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/009a64916e7f51df7e4e4e1df603eb4be1c7a6d8/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/009a64916e7f51df7e4e4e1df603eb4be1c7a6d8/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=009a64916e7f51df7e4e4e1df603eb4be1c7a6d8", "patch": "@@ -436,47 +436,47 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                                 fn_ty: &FnType,\n                                 next_idx: &mut usize,\n                                 callee: &mut CalleeData) {\n-        // FIXME: consider having some optimization to avoid tupling/untupling\n-        // (and storing/loading in the case of immediates)\n-\n-        // avoid trans_operand for pointless copying\n-        let lv = match *operand {\n-            mir::Operand::Consume(ref lvalue) => self.trans_lvalue(bcx, lvalue),\n-            mir::Operand::Constant(ref constant) => {\n-                // FIXME: consider being less pessimized\n-                if constant.ty.is_nil() {\n-                    return;\n-                }\n-\n-                let ty = bcx.monomorphize(&constant.ty);\n-                let lv = LvalueRef::alloca(bcx, ty, \"__untuple_alloca\");\n-                let constant = self.trans_constant(bcx, constant);\n-                self.store_operand(bcx, lv.llval, constant);\n-                lv\n-           }\n-        };\n+        let tuple = self.trans_operand(bcx, operand);\n \n-        let lv_ty = lv.ty.to_ty(bcx.tcx());\n-        let result_types = match lv_ty.sty {\n+        let arg_types = match tuple.ty.sty {\n             ty::TyTuple(ref tys) => tys,\n-            _ => span_bug!(\n-                self.mir.span,\n-                \"bad final argument to \\\"rust-call\\\" fn {:?}\", lv_ty)\n+            _ => span_bug!(self.mir.span,\n+                           \"bad final argument to \\\"rust-call\\\" fn {:?}\", tuple.ty)\n         };\n \n-        let base_repr = adt::represent_type(bcx.ccx(), lv_ty);\n-        let base = adt::MaybeSizedValue::sized(lv.llval);\n-        for (n, &ty) in result_types.iter().enumerate() {\n-            let ptr = adt::trans_field_ptr_builder(bcx, &base_repr, base, Disr(0), n);\n-            let val = if common::type_is_fat_ptr(bcx.tcx(), ty) {\n-                let (lldata, llextra) = load_fat_ptr(bcx, ptr);\n-                FatPtr(lldata, llextra)\n-            } else {\n-                // Don't bother loading the value, trans_argument will.\n-                Ref(ptr)\n-            };\n-            self.trans_argument(bcx, val, llargs, fn_ty, next_idx, callee);\n+        // Handle both by-ref and immediate tuples.\n+        match tuple.val {\n+            Ref(llval) => {\n+                let base_repr = adt::represent_type(bcx.ccx(), tuple.ty);\n+                let base = adt::MaybeSizedValue::sized(llval);\n+                for (n, &ty) in arg_types.iter().enumerate() {\n+                    let ptr = adt::trans_field_ptr_builder(bcx, &base_repr, base, Disr(0), n);\n+                    let val = if common::type_is_fat_ptr(bcx.tcx(), ty) {\n+                        let (lldata, llextra) = load_fat_ptr(bcx, ptr);\n+                        FatPtr(lldata, llextra)\n+                    } else {\n+                        // trans_argument will load this if it needs to\n+                        Ref(ptr)\n+                    };\n+                    self.trans_argument(bcx, val, llargs, fn_ty, next_idx, callee);\n+                }\n+\n+            }\n+            Immediate(llval) => {\n+                for (n, &ty) in arg_types.iter().enumerate() {\n+                    let mut elem = bcx.extract_value(llval, n);\n+                    // Truncate bools to i1, if needed\n+                    if ty.is_bool() && common::val_ty(elem) != Type::i1(bcx.ccx()) {\n+                        elem = bcx.trunc(elem, Type::i1(bcx.ccx()));\n+                    }\n+                    // If the tuple is immediate, the elements are as well\n+                    let val = Immediate(elem);\n+                    self.trans_argument(bcx, val, llargs, fn_ty, next_idx, callee);\n+                }\n+            }\n+            FatPtr(_, _) => bug!(\"tuple is a fat pointer?!\")\n         }\n+\n     }\n \n     fn get_personality_slot(&mut self, bcx: &BlockAndBuilder<'bcx, 'tcx>) -> ValueRef {"}, {"sha": "75d9ca32a21de3ed324336ef5a436eab023f1b7b", "filename": "src/librustc_trans/mir/mod.rs", "status": "modified", "additions": 22, "deletions": 3, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/009a64916e7f51df7e4e4e1df603eb4be1c7a6d8/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/009a64916e7f51df7e4e4e1df603eb4be1c7a6d8/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fmod.rs?ref=009a64916e7f51df7e4e4e1df603eb4be1c7a6d8", "patch": "@@ -16,7 +16,7 @@ use rustc::mir::repr as mir;\n use rustc::mir::tcx::LvalueTy;\n use session::config::FullDebugInfo;\n use base;\n-use common::{self, Block, BlockAndBuilder, FunctionContext};\n+use common::{self, Block, BlockAndBuilder, CrateContext, FunctionContext};\n use debuginfo::{self, declare_local, DebugLoc, VariableAccess, VariableKind};\n use machine;\n use type_of;\n@@ -34,7 +34,7 @@ use rustc_data_structures::bitvec::BitVector;\n use self::lvalue::{LvalueRef, get_dataptr, get_meta};\n use rustc_mir::traversal;\n \n-use self::operand::OperandRef;\n+use self::operand::{OperandRef, OperandValue};\n \n #[derive(Clone)]\n pub enum CachedMir<'mir, 'tcx: 'mir> {\n@@ -108,6 +108,25 @@ enum TempRef<'tcx> {\n     Operand(Option<OperandRef<'tcx>>),\n }\n \n+impl<'tcx> TempRef<'tcx> {\n+    fn new_operand<'bcx>(ccx: &CrateContext<'bcx, 'tcx>,\n+                         ty: ty::Ty<'tcx>) -> TempRef<'tcx> {\n+        if common::type_is_zero_size(ccx, ty) {\n+            // Zero-size temporaries aren't always initialized, which\n+            // doesn't matter because they don't contain data, but\n+            // we need something in the operand.\n+            let val = OperandValue::Immediate(common::C_nil(ccx));\n+            let op = OperandRef {\n+                val: val,\n+                ty: ty\n+            };\n+            TempRef::Operand(Some(op))\n+        } else {\n+            TempRef::Operand(None)\n+        }\n+    }\n+}\n+\n ///////////////////////////////////////////////////////////////////////////\n \n pub fn trans_mir<'blk, 'tcx: 'blk>(fcx: &'blk FunctionContext<'blk, 'tcx>) {\n@@ -154,7 +173,7 @@ pub fn trans_mir<'blk, 'tcx: 'blk>(fcx: &'blk FunctionContext<'blk, 'tcx>) {\n                                   // If this is an immediate temp, we do not create an\n                                   // alloca in advance. Instead we wait until we see the\n                                   // definition and update the operand there.\n-                                  TempRef::Operand(None)\n+                                  TempRef::new_operand(bcx.ccx(), mty)\n                               })\n                               .collect();\n "}, {"sha": "67d7f44cbbf41ab7764aeee42878a2c9fcdc9b8d", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 19, "deletions": 8, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/009a64916e7f51df7e4e4e1df603eb4be1c7a6d8/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/009a64916e7f51df7e4e4e1df603eb4be1c7a6d8/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=009a64916e7f51df7e4e4e1df603eb4be1c7a6d8", "patch": "@@ -29,6 +29,7 @@ use type_of;\n use tvec;\n use value::Value;\n use Disr;\n+use glue;\n \n use super::MirContext;\n use super::operand::{OperandRef, OperandValue};\n@@ -217,7 +218,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n             }\n \n             _ => {\n-                assert!(rvalue_creates_operand(rvalue));\n+                assert!(rvalue_creates_operand(&self.mir, &bcx, rvalue));\n                 let (bcx, temp) = self.trans_rvalue_operand(bcx, rvalue, debug_loc);\n                 self.store_operand(&bcx, dest.llval, temp);\n                 bcx\n@@ -231,7 +232,8 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                                 debug_loc: DebugLoc)\n                                 -> (BlockAndBuilder<'bcx, 'tcx>, OperandRef<'tcx>)\n     {\n-        assert!(rvalue_creates_operand(rvalue), \"cannot trans {:?} to operand\", rvalue);\n+        assert!(rvalue_creates_operand(&self.mir, &bcx, rvalue),\n+                \"cannot trans {:?} to operand\", rvalue);\n \n         match *rvalue {\n             mir::Rvalue::Cast(ref kind, ref source, cast_ty) => {\n@@ -483,7 +485,10 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 (bcx, operand)\n             }\n \n-            mir::Rvalue::Use(..) |\n+            mir::Rvalue::Use(ref operand) => {\n+                let operand = self.trans_operand(&bcx, operand);\n+                (bcx, operand)\n+            }\n             mir::Rvalue::Repeat(..) |\n             mir::Rvalue::Aggregate(..) |\n             mir::Rvalue::Slice { .. } |\n@@ -599,7 +604,9 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n     }\n }\n \n-pub fn rvalue_creates_operand<'tcx>(rvalue: &mir::Rvalue<'tcx>) -> bool {\n+pub fn rvalue_creates_operand<'bcx, 'tcx>(mir: &mir::Mir<'tcx>,\n+                                          bcx: &BlockAndBuilder<'bcx, 'tcx>,\n+                                          rvalue: &mir::Rvalue<'tcx>) -> bool {\n     match *rvalue {\n         mir::Rvalue::Ref(..) |\n         mir::Rvalue::Len(..) |\n@@ -608,16 +615,20 @@ pub fn rvalue_creates_operand<'tcx>(rvalue: &mir::Rvalue<'tcx>) -> bool {\n         mir::Rvalue::UnaryOp(..) |\n         mir::Rvalue::Box(..) =>\n             true,\n-        mir::Rvalue::Use(..) | // (**)\n         mir::Rvalue::Repeat(..) |\n         mir::Rvalue::Aggregate(..) |\n         mir::Rvalue::Slice { .. } |\n         mir::Rvalue::InlineAsm { .. } =>\n             false,\n+        mir::Rvalue::Use(ref operand) => {\n+            let ty = mir.operand_ty(bcx.tcx(), operand);\n+            let ty = bcx.monomorphize(&ty);\n+            // Types that don't need dropping can just be an operand,\n+            // this allows temporary lvalues, used as rvalues, to\n+            // avoid a stack slot when it's unnecessary\n+            !glue::type_needs_drop(bcx.tcx(), ty)\n+        }\n     }\n \n     // (*) this is only true if the type is suitable\n-    // (**) we need to zero-out the source operand after moving, so we are restricted to either\n-    // ensuring all users of `Use` zero it out themselves or not allowing to \u201ccreate\u201d operand for\n-    // it.\n }"}, {"sha": "c9a4e540fa06b92948239af8c0bb3eef96351a99", "filename": "src/librustc_trans/mir/statement.rs", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/009a64916e7f51df7e4e4e1df603eb4be1c7a6d8/src%2Flibrustc_trans%2Fmir%2Fstatement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/009a64916e7f51df7e4e4e1df603eb4be1c7a6d8/src%2Flibrustc_trans%2Fmir%2Fstatement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fstatement.rs?ref=009a64916e7f51df7e4e4e1df603eb4be1c7a6d8", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use rustc::mir::repr as mir;\n-use common::BlockAndBuilder;\n+use common::{self, BlockAndBuilder};\n use debuginfo::DebugLoc;\n \n use super::MirContext;\n@@ -42,9 +42,18 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                                 bcx\n                             }\n                             TempRef::Operand(Some(_)) => {\n-                                span_bug!(statement.span,\n-                                          \"operand {:?} already assigned\",\n-                                          rvalue);\n+                                let ty = self.mir.lvalue_ty(bcx.tcx(), lvalue);\n+                                let ty = bcx.monomorphize(&ty.to_ty(bcx.tcx()));\n+\n+                                if !common::type_is_zero_size(bcx.ccx(), ty) {\n+                                    span_bug!(statement.span,\n+                                              \"operand {:?} already assigned\",\n+                                              rvalue);\n+                                } else {\n+                                    // If the type is zero-sized, it's already been set here,\n+                                    // but we still need to make sure we translate the operand\n+                                    self.trans_rvalue_operand(bcx, rvalue, debug_loc).0\n+                                }\n                             }\n                         }\n                     }"}, {"sha": "c43c254f33911e6c8636c5108f6ac72728966941", "filename": "src/test/codegen-units/item-collection/impl-in-non-instantiated-generic.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/009a64916e7f51df7e4e4e1df603eb4be1c7a6d8/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fimpl-in-non-instantiated-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/009a64916e7f51df7e4e4e1df603eb4be1c7a6d8/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fimpl-in-non-instantiated-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fimpl-in-non-instantiated-generic.rs?ref=009a64916e7f51df7e4e4e1df603eb4be1c7a6d8", "patch": "@@ -32,5 +32,3 @@ pub fn generic_function<T>(x: T) -> (T, i32) {\n fn main() {\n     0i64.foo();\n }\n-\n-//~ TRANS_ITEM drop-glue i8"}, {"sha": "ba77266d07248213059a742f7c85efe75c801362", "filename": "src/test/codegen-units/item-collection/non-generic-closures.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/009a64916e7f51df7e4e4e1df603eb4be1c7a6d8/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fnon-generic-closures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/009a64916e7f51df7e4e4e1df603eb4be1c7a6d8/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fnon-generic-closures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fnon-generic-closures.rs?ref=009a64916e7f51df7e4e4e1df603eb4be1c7a6d8", "patch": "@@ -59,5 +59,3 @@ fn main() {\n fn run_closure(f: &Fn(i32)) {\n     f(3);\n }\n-\n-//~ TRANS_ITEM drop-glue i8"}, {"sha": "469f2c08c39c2abbefc8cd82cb2181b9bacd6086", "filename": "src/test/codegen-units/partitioning/inlining-from-extern-crate.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/009a64916e7f51df7e4e4e1df603eb4be1c7a6d8/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Finlining-from-extern-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/009a64916e7f51df7e4e4e1df603eb4be1c7a6d8/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Finlining-from-extern-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Finlining-from-extern-crate.rs?ref=009a64916e7f51df7e4e4e1df603eb4be1c7a6d8", "patch": "@@ -57,5 +57,3 @@ mod mod2 {\n         cgu_explicit_inlining::never_inlined();\n     }\n }\n-\n-//~ TRANS_ITEM drop-glue i8"}, {"sha": "d2bfa83834665e28d0de8df53258c65e6e0489fe", "filename": "src/test/codegen-units/partitioning/local-inlining.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/009a64916e7f51df7e4e4e1df603eb4be1c7a6d8/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-inlining.rs", "raw_url": "https://github.com/rust-lang/rust/raw/009a64916e7f51df7e4e4e1df603eb4be1c7a6d8/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-inlining.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-inlining.rs?ref=009a64916e7f51df7e4e4e1df603eb4be1c7a6d8", "patch": "@@ -50,5 +50,3 @@ mod non_user {\n \n     }\n }\n-\n-//~ TRANS_ITEM drop-glue i8"}, {"sha": "2e47dc5c9020f23e65913e470064bea432e3a9d1", "filename": "src/test/codegen-units/partitioning/local-transitive-inlining.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/009a64916e7f51df7e4e4e1df603eb4be1c7a6d8/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-transitive-inlining.rs", "raw_url": "https://github.com/rust-lang/rust/raw/009a64916e7f51df7e4e4e1df603eb4be1c7a6d8/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-transitive-inlining.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fpartitioning%2Flocal-transitive-inlining.rs?ref=009a64916e7f51df7e4e4e1df603eb4be1c7a6d8", "patch": "@@ -50,5 +50,3 @@ mod non_user {\n \n     }\n }\n-\n-//~ TRANS_ITEM drop-glue i8"}]}