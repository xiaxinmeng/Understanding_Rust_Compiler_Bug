{"sha": "b899251f2dfe3a9849f844418e0d11e2073c2423", "node_id": "C_kwDOAAsO6NoAKGI4OTkyNTFmMmRmZTNhOTg0OWY4NDQ0MThlMGQxMWUyMDczYzI0MjM", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-04-02T21:22:35Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-04-02T22:29:55Z"}, "message": "Fix late-bound ICE in unsized return suggestion", "tree": {"sha": "aa83b90e067a8cd143fde33b1ee3fc1d5875fd60", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aa83b90e067a8cd143fde33b1ee3fc1d5875fd60"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b899251f2dfe3a9849f844418e0d11e2073c2423", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b899251f2dfe3a9849f844418e0d11e2073c2423", "html_url": "https://github.com/rust-lang/rust/commit/b899251f2dfe3a9849f844418e0d11e2073c2423", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b899251f2dfe3a9849f844418e0d11e2073c2423/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fbc45b650a9c517ca87b0af8f108efbf50689299", "url": "https://api.github.com/repos/rust-lang/rust/commits/fbc45b650a9c517ca87b0af8f108efbf50689299", "html_url": "https://github.com/rust-lang/rust/commit/fbc45b650a9c517ca87b0af8f108efbf50689299"}], "stats": {"total": 326, "additions": 242, "deletions": 84}, "files": [{"sha": "ac17b0d68657eec9b202b909cd4bb7d589015601", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 79, "deletions": 55, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/b899251f2dfe3a9849f844418e0d11e2073c2423/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b899251f2dfe3a9849f844418e0d11e2073c2423/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=b899251f2dfe3a9849f844418e0d11e2073c2423", "patch": "@@ -1045,8 +1045,8 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         }\n \n         let hir = self.tcx.hir();\n-        let parent_node = hir.get_parent_node(obligation.cause.body_id);\n-        let node = hir.find(parent_node);\n+        let fn_hir_id = hir.get_parent_node(obligation.cause.body_id);\n+        let node = hir.find(fn_hir_id);\n         let Some(hir::Node::Item(hir::Item {\n             kind: hir::ItemKind::Fn(sig, _, body_id),\n             ..\n@@ -1084,16 +1084,17 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         visitor.visit_body(&body);\n \n         let typeck_results = self.in_progress_typeck_results.map(|t| t.borrow()).unwrap();\n+        let Some(liberated_sig) = typeck_results.liberated_fn_sigs().get(fn_hir_id) else { return false; };\n \n-        let mut ret_types = visitor\n+        let ret_types = visitor\n             .returns\n             .iter()\n-            .filter_map(|expr| typeck_results.node_type_opt(expr.hir_id))\n-            .map(|ty| self.resolve_vars_if_possible(ty));\n+            .filter_map(|expr| Some((expr.span, typeck_results.node_type_opt(expr.hir_id)?)))\n+            .map(|(expr_span, ty)| (expr_span, self.resolve_vars_if_possible(ty)));\n         let (last_ty, all_returns_have_same_type, only_never_return) = ret_types.clone().fold(\n             (None, true, true),\n             |(last_ty, mut same, only_never_return): (std::option::Option<Ty<'_>>, bool, bool),\n-             ty| {\n+             (_, ty)| {\n                 let ty = self.resolve_vars_if_possible(ty);\n                 same &=\n                     !matches!(ty.kind(), ty::Error(_))\n@@ -1114,39 +1115,60 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 (Some(ty), same, only_never_return && matches!(ty.kind(), ty::Never))\n             },\n         );\n-        let all_returns_conform_to_trait =\n-            if let Some(ty_ret_ty) = typeck_results.node_type_opt(ret_ty.hir_id) {\n-                match ty_ret_ty.kind() {\n-                    ty::Dynamic(predicates, _) => {\n-                        let cause = ObligationCause::misc(ret_ty.span, ret_ty.hir_id);\n-                        let param_env = ty::ParamEnv::empty();\n-                        only_never_return\n-                            || ret_types.all(|returned_ty| {\n-                                predicates.iter().all(|predicate| {\n-                                    let pred = predicate.with_self_ty(self.tcx, returned_ty);\n-                                    let obl = Obligation::new(cause.clone(), param_env, pred);\n-                                    self.predicate_may_hold(&obl)\n-                                })\n+        let mut spans_and_needs_box = vec![];\n+\n+        match liberated_sig.output().kind() {\n+            ty::Dynamic(predicates, _) => {\n+                let cause = ObligationCause::misc(ret_ty.span, fn_hir_id);\n+                let param_env = ty::ParamEnv::empty();\n+\n+                if !only_never_return {\n+                    for (expr_span, return_ty) in ret_types {\n+                        let self_ty_satisfies_dyn_predicates = |self_ty| {\n+                            predicates.iter().all(|predicate| {\n+                                let pred = predicate.with_self_ty(self.tcx, self_ty);\n+                                let obl = Obligation::new(cause.clone(), param_env, pred);\n+                                self.predicate_may_hold(&obl)\n                             })\n+                        };\n+\n+                        if let ty::Adt(def, substs) = return_ty.kind()\n+                            && def.is_box()\n+                            && self_ty_satisfies_dyn_predicates(substs.type_at(0))\n+                        {\n+                            spans_and_needs_box.push((expr_span, false));\n+                        } else if self_ty_satisfies_dyn_predicates(return_ty) {\n+                            spans_and_needs_box.push((expr_span, true));\n+                        } else {\n+                            return false;\n+                        }\n                     }\n-                    _ => false,\n                 }\n-            } else {\n-                true\n-            };\n+            }\n+            _ => return false,\n+        };\n \n         let sm = self.tcx.sess.source_map();\n-        let (true, hir::TyKind::TraitObject(..), Ok(snippet), true) = (\n-            // Verify that we're dealing with a return `dyn Trait`\n-            ret_ty.span.overlaps(span),\n-            &ret_ty.kind,\n-            sm.span_to_snippet(ret_ty.span),\n-            // If any of the return types does not conform to the trait, then we can't\n-            // suggest `impl Trait` nor trait objects: it is a type mismatch error.\n-            all_returns_conform_to_trait,\n-        ) else {\n+        if !ret_ty.span.overlaps(span) {\n             return false;\n+        }\n+        let snippet = if let hir::TyKind::TraitObject(..) = ret_ty.kind {\n+            if let Ok(snippet) = sm.span_to_snippet(ret_ty.span) {\n+                snippet\n+            } else {\n+                return false;\n+            }\n+        } else {\n+            // Substitute the type, so we can print a fixup given `type Alias = dyn Trait`\n+            let name = liberated_sig.output().to_string();\n+            let name =\n+                name.strip_prefix('(').and_then(|name| name.strip_suffix(')')).unwrap_or(&name);\n+            if !name.starts_with(\"dyn \") {\n+                return false;\n+            }\n+            name.to_owned()\n         };\n+\n         err.code(error_code!(E0746));\n         err.set_primary_message(\"return type cannot have an unboxed trait object\");\n         err.children.clear();\n@@ -1156,6 +1178,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         let trait_obj_msg = \"for information on trait objects, see \\\n             <https://doc.rust-lang.org/book/ch17-02-trait-objects.html\\\n             #using-trait-objects-that-allow-for-values-of-different-types>\";\n+\n         let has_dyn = snippet.split_whitespace().next().map_or(false, |s| s == \"dyn\");\n         let trait_obj = if has_dyn { &snippet[4..] } else { &snippet };\n         if only_never_return {\n@@ -1183,26 +1206,25 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         } else {\n             if is_object_safe {\n                 // Suggest `-> Box<dyn Trait>` and `Box::new(returned_value)`.\n-                // Get all the return values and collect their span and suggestion.\n-                let mut suggestions: Vec<_> = visitor\n-                    .returns\n-                    .iter()\n-                    .flat_map(|expr| {\n-                        [\n-                            (expr.span.shrink_to_lo(), \"Box::new(\".to_string()),\n-                            (expr.span.shrink_to_hi(), \")\".to_string()),\n-                        ]\n-                        .into_iter()\n-                    })\n-                    .collect();\n-                if !suggestions.is_empty() {\n-                    // Add the suggestion for the return type.\n-                    suggestions.push((ret_ty.span, format!(\"Box<dyn {}>\", trait_obj)));\n-                    err.multipart_suggestion(\n-                        \"return a boxed trait object instead\",\n-                        suggestions,\n-                        Applicability::MaybeIncorrect,\n-                    );\n+                err.multipart_suggestion(\n+                    \"return a boxed trait object instead\",\n+                    vec![\n+                        (ret_ty.span.shrink_to_lo(), \"Box<\".to_string()),\n+                        (span.shrink_to_hi(), \">\".to_string()),\n+                    ],\n+                    Applicability::MaybeIncorrect,\n+                );\n+                for (span, needs_box) in spans_and_needs_box {\n+                    if needs_box {\n+                        err.multipart_suggestion(\n+                            \"... and box this value\",\n+                            vec![\n+                                (span.shrink_to_lo(), \"Box::new(\".to_string()),\n+                                (span.shrink_to_hi(), \")\".to_string()),\n+                            ],\n+                            Applicability::MaybeIncorrect,\n+                        );\n+                    }\n                 }\n             } else {\n                 // This is currently not possible to trigger because E0038 takes precedence, but\n@@ -2677,13 +2699,15 @@ fn suggest_trait_object_return_type_alternatives(\n         Applicability::MaybeIncorrect,\n     );\n     if is_object_safe {\n-        err.span_suggestion(\n-            ret_ty,\n+        err.multipart_suggestion(\n             &format!(\n                 \"use a boxed trait object if all return paths implement trait `{}`\",\n                 trait_obj,\n             ),\n-            format!(\"Box<dyn {}>\", trait_obj),\n+            vec![\n+                (ret_ty.shrink_to_lo(), \"Box<\".to_string()),\n+                (ret_ty.shrink_to_hi(), \">\".to_string()),\n+            ],\n             Applicability::MaybeIncorrect,\n         );\n     }"}, {"sha": "f90399b6b945888bad12c687d671387595b81093", "filename": "src/test/ui/impl-trait/dyn-trait-return-should-be-impl-trait.stderr", "status": "modified", "additions": 19, "deletions": 11, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/b899251f2dfe3a9849f844418e0d11e2073c2423/src%2Ftest%2Fui%2Fimpl-trait%2Fdyn-trait-return-should-be-impl-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b899251f2dfe3a9849f844418e0d11e2073c2423/src%2Ftest%2Fui%2Fimpl-trait%2Fdyn-trait-return-should-be-impl-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fdyn-trait-return-should-be-impl-trait.stderr?ref=b899251f2dfe3a9849f844418e0d11e2073c2423", "patch": "@@ -81,7 +81,7 @@ LL | fn bak() -> impl Trait { unimplemented!() }\n help: use a boxed trait object if all return paths implement trait `Trait`\n    |\n LL | fn bak() -> Box<dyn Trait> { unimplemented!() }\n-   |             ~~~~~~~~~~~~~~\n+   |             ++++         +\n \n error[E0746]: return type cannot have an unboxed trait object\n   --> $DIR/dyn-trait-return-should-be-impl-trait.rs:19:13\n@@ -95,12 +95,16 @@ LL | fn bal() -> dyn Trait {\n    = note: you can create a new `enum` with a variant for each returned type\n help: return a boxed trait object instead\n    |\n-LL ~ fn bal() -> Box<dyn Trait> {\n-LL |     if true {\n-LL ~         return Box::new(Struct);\n-LL |     }\n-LL ~     Box::new(42)\n+LL | fn bal() -> Box<dyn Trait> {\n+   |             ++++         +\n+help: ... and box this value\n+   |\n+LL |         return Box::new(Struct);\n+   |                +++++++++      +\n+help: ... and box this value\n    |\n+LL |     Box::new(42)\n+   |     +++++++++  +\n \n error[E0308]: `if` and `else` have incompatible types\n   --> $DIR/dyn-trait-return-should-be-impl-trait.rs:29:9\n@@ -126,12 +130,16 @@ LL | fn bax() -> dyn Trait {\n    = note: you can create a new `enum` with a variant for each returned type\n help: return a boxed trait object instead\n    |\n-LL ~ fn bax() -> Box<dyn Trait> {\n-LL |     if true {\n-LL ~         Box::new(Struct)\n-LL |     } else {\n-LL ~         Box::new(42)\n+LL | fn bax() -> Box<dyn Trait> {\n+   |             ++++         +\n+help: ... and box this value\n+   |\n+LL |         Box::new(Struct)\n+   |         +++++++++      +\n+help: ... and box this value\n    |\n+LL |         Box::new(42)\n+   |         +++++++++  +\n \n error[E0308]: mismatched types\n   --> $DIR/dyn-trait-return-should-be-impl-trait.rs:34:16"}, {"sha": "10510c1754eda5ca842c6d8f0d4fac312ed4b5ee", "filename": "src/test/ui/impl-trait/point-to-type-err-cause-on-impl-trait-return.stderr", "status": "modified", "additions": 32, "deletions": 17, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/b899251f2dfe3a9849f844418e0d11e2073c2423/src%2Ftest%2Fui%2Fimpl-trait%2Fpoint-to-type-err-cause-on-impl-trait-return.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b899251f2dfe3a9849f844418e0d11e2073c2423/src%2Ftest%2Fui%2Fimpl-trait%2Fpoint-to-type-err-cause-on-impl-trait-return.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fpoint-to-type-err-cause-on-impl-trait-return.stderr?ref=b899251f2dfe3a9849f844418e0d11e2073c2423", "patch": "@@ -103,13 +103,16 @@ LL | fn hat() -> dyn std::fmt::Display {\n    = note: you can create a new `enum` with a variant for each returned type\n help: return a boxed trait object instead\n    |\n-LL ~ fn hat() -> Box<dyn std::fmt::Display> {\n-LL |     match 13 {\n-LL |         0 => {\n-LL ~             return Box::new(0i32);\n-LL |         }\n-LL |         _ => {\n- ...\n+LL | fn hat() -> Box<dyn std::fmt::Display> {\n+   |             ++++                     +\n+help: ... and box this value\n+   |\n+LL |             return Box::new(0i32);\n+   |                    +++++++++    +\n+help: ... and box this value\n+   |\n+LL |             Box::new(1u32)\n+   |             +++++++++    +\n \n error[E0308]: `match` arms have incompatible types\n   --> $DIR/point-to-type-err-cause-on-impl-trait-return.rs:80:14\n@@ -135,12 +138,20 @@ LL | fn pug() -> dyn std::fmt::Display {\n    = note: you can create a new `enum` with a variant for each returned type\n help: return a boxed trait object instead\n    |\n-LL ~ fn pug() -> Box<dyn std::fmt::Display> {\n-LL |     match 13 {\n-LL ~         0 => Box::new(0i32),\n-LL ~         1 => Box::new(1u32),\n-LL ~         _ => Box::new(2u32),\n+LL | fn pug() -> Box<dyn std::fmt::Display> {\n+   |             ++++                     +\n+help: ... and box this value\n+   |\n+LL |         0 => Box::new(0i32),\n+   |              +++++++++    +\n+help: ... and box this value\n    |\n+LL |         1 => Box::new(1u32),\n+   |              +++++++++    +\n+help: ... and box this value\n+   |\n+LL |         _ => Box::new(2u32),\n+   |              +++++++++    +\n \n error[E0308]: `if` and `else` have incompatible types\n   --> $DIR/point-to-type-err-cause-on-impl-trait-return.rs:89:9\n@@ -166,12 +177,16 @@ LL | fn man() -> dyn std::fmt::Display {\n    = note: you can create a new `enum` with a variant for each returned type\n help: return a boxed trait object instead\n    |\n-LL ~ fn man() -> Box<dyn std::fmt::Display> {\n-LL |     if false {\n-LL ~         Box::new(0i32)\n-LL |     } else {\n-LL ~         Box::new(1u32)\n+LL | fn man() -> Box<dyn std::fmt::Display> {\n+   |             ++++                     +\n+help: ... and box this value\n+   |\n+LL |         Box::new(0i32)\n+   |         +++++++++    +\n+help: ... and box this value\n    |\n+LL |         Box::new(1u32)\n+   |         +++++++++    +\n \n error: aborting due to 14 previous errors\n "}, {"sha": "28478457b296db68779f5227322583c657f518b9", "filename": "src/test/ui/issues/issue-18107.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b899251f2dfe3a9849f844418e0d11e2073c2423/src%2Ftest%2Fui%2Fissues%2Fissue-18107.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b899251f2dfe3a9849f844418e0d11e2073c2423/src%2Ftest%2Fui%2Fissues%2Fissue-18107.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-18107.stderr?ref=b899251f2dfe3a9849f844418e0d11e2073c2423", "patch": "@@ -15,7 +15,7 @@ LL |     impl AbstractRenderer\n help: use a boxed trait object if all return paths implement trait `AbstractRenderer`\n    |\n LL |     Box<dyn AbstractRenderer>\n-   |\n+   |     ++++                    +\n \n error: aborting due to previous error\n "}, {"sha": "2fa741bc1c50be20cfe238326de0a362e84f8e1b", "filename": "src/test/ui/unsized/box-instead-of-dyn-fn.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b899251f2dfe3a9849f844418e0d11e2073c2423/src%2Ftest%2Fui%2Funsized%2Fbox-instead-of-dyn-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b899251f2dfe3a9849f844418e0d11e2073c2423/src%2Ftest%2Fui%2Funsized%2Fbox-instead-of-dyn-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsized%2Fbox-instead-of-dyn-fn.rs?ref=b899251f2dfe3a9849f844418e0d11e2073c2423", "patch": "@@ -0,0 +1,15 @@\n+use std::fmt::Debug;\n+\n+// Test to suggest boxing the return type, and the closure branch of the `if`\n+\n+fn print_on_or_the_other<'a>(a: i32, b: &'a String) -> dyn Fn() + 'a {\n+    //~^ ERROR return type cannot have an unboxed trait object\n+    if a % 2 == 0 {\n+        move || println!(\"{a}\")\n+    } else {\n+        Box::new(move || println!(\"{}\", b))\n+        //~^ ERROR `if` and `else` have incompatible types\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "80f61cb3eae11724071bdedda531f4dd80d706e9", "filename": "src/test/ui/unsized/box-instead-of-dyn-fn.stderr", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/b899251f2dfe3a9849f844418e0d11e2073c2423/src%2Ftest%2Fui%2Funsized%2Fbox-instead-of-dyn-fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b899251f2dfe3a9849f844418e0d11e2073c2423/src%2Ftest%2Fui%2Funsized%2Fbox-instead-of-dyn-fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsized%2Fbox-instead-of-dyn-fn.stderr?ref=b899251f2dfe3a9849f844418e0d11e2073c2423", "patch": "@@ -0,0 +1,39 @@\n+error[E0308]: `if` and `else` have incompatible types\n+  --> $DIR/box-instead-of-dyn-fn.rs:10:9\n+   |\n+LL | /     if a % 2 == 0 {\n+LL | |         move || println!(\"{a}\")\n+   | |         ----------------------- expected because of this\n+LL | |     } else {\n+LL | |         Box::new(move || println!(\"{}\", b))\n+   | |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected closure, found struct `Box`\n+LL | |\n+LL | |     }\n+   | |_____- `if` and `else` have incompatible types\n+   |\n+   = note: expected type `[closure@$DIR/box-instead-of-dyn-fn.rs:8:9: 8:32]`\n+            found struct `Box<[closure@$DIR/box-instead-of-dyn-fn.rs:10:18: 10:43]>`\n+\n+error[E0746]: return type cannot have an unboxed trait object\n+  --> $DIR/box-instead-of-dyn-fn.rs:5:56\n+   |\n+LL | fn print_on_or_the_other<'a>(a: i32, b: &'a String) -> dyn Fn() + 'a {\n+   |                                                        ^^^^^^^^^^^^^ doesn't have a size known at compile-time\n+   |\n+   = note: for information on trait objects, see <https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types>\n+   = note: if all the returned values were of the same type you could use `impl Fn() + 'a` as the return type\n+   = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\n+   = note: you can create a new `enum` with a variant for each returned type\n+help: return a boxed trait object instead\n+   |\n+LL | fn print_on_or_the_other<'a>(a: i32, b: &'a String) -> Box<dyn Fn() + 'a> {\n+   |                                                        ++++             +\n+help: ... and box this value\n+   |\n+LL |         Box::new(move || println!(\"{a}\"))\n+   |         +++++++++                       +\n+\n+error: aborting due to 2 previous errors\n+\n+Some errors have detailed explanations: E0308, E0746.\n+For more information about an error, try `rustc --explain E0308`."}, {"sha": "096b1a93574fc81dbbfda6bb2f51efefc249a798", "filename": "src/test/ui/unsized/issue-91801.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b899251f2dfe3a9849f844418e0d11e2073c2423/src%2Ftest%2Fui%2Funsized%2Fissue-91801.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b899251f2dfe3a9849f844418e0d11e2073c2423/src%2Ftest%2Fui%2Funsized%2Fissue-91801.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsized%2Fissue-91801.rs?ref=b899251f2dfe3a9849f844418e0d11e2073c2423", "patch": "@@ -0,0 +1,19 @@\n+pub struct Something;\n+\n+type Validator<'a> = dyn 'a + Send + Sync + Fn(&'a Something) -> Result<(), ()>;\n+\n+pub static ALL_VALIDATORS: &[(&'static str, &'static Validator)] =\n+    &[(\"validate that credits and debits balance\", &validate_something)];\n+\n+fn or<'a>(first: &'static Validator<'a>, second: &'static Validator<'a>) -> Validator<'a> {\n+    //~^ ERROR return type cannot have an unboxed trait object\n+    return Box::new(move |something: &'_ Something| -> Result<(), ()> {\n+        first(something).or_else(|_| second(something))\n+    });\n+}\n+\n+fn validate_something(_: &Something) -> Result<(), ()> {\n+    Ok(())\n+}\n+\n+fn main() {}"}, {"sha": "e854514958629fb4a988eaac5cb27e9879fdc0ba", "filename": "src/test/ui/unsized/issue-91801.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b899251f2dfe3a9849f844418e0d11e2073c2423/src%2Ftest%2Fui%2Funsized%2Fissue-91801.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b899251f2dfe3a9849f844418e0d11e2073c2423/src%2Ftest%2Fui%2Funsized%2Fissue-91801.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsized%2Fissue-91801.stderr?ref=b899251f2dfe3a9849f844418e0d11e2073c2423", "patch": "@@ -0,0 +1,15 @@\n+error[E0746]: return type cannot have an unboxed trait object\n+  --> $DIR/issue-91801.rs:8:77\n+   |\n+LL | fn or<'a>(first: &'static Validator<'a>, second: &'static Validator<'a>) -> Validator<'a> {\n+   |                                                                             ^^^^^^^^^^^^^ doesn't have a size known at compile-time\n+   |\n+   = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\n+help: use `impl Fn(&'a Something) -> Result<(), ()> + Send + Sync + 'a` as the return type, as all return paths are of type `Box<[closure@$DIR/issue-91801.rs:10:21: 12:6]>`, which implements `Fn(&'a Something) -> Result<(), ()> + Send + Sync + 'a`\n+   |\n+LL | fn or<'a>(first: &'static Validator<'a>, second: &'static Validator<'a>) -> impl Fn(&'a Something) -> Result<(), ()> + Send + Sync + 'a {\n+   |                                                                             ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0746`."}, {"sha": "c74897cc4bc501a70b1ff5a33d1c009464c10fc5", "filename": "src/test/ui/unsized/issue-91803.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b899251f2dfe3a9849f844418e0d11e2073c2423/src%2Ftest%2Fui%2Funsized%2Fissue-91803.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b899251f2dfe3a9849f844418e0d11e2073c2423/src%2Ftest%2Fui%2Funsized%2Fissue-91803.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsized%2Fissue-91803.rs?ref=b899251f2dfe3a9849f844418e0d11e2073c2423", "patch": "@@ -0,0 +1,8 @@\n+trait Foo<'a> {}\n+\n+fn or<'a>(first: &'static dyn Foo<'a>) -> dyn Foo<'a> {\n+    //~^ ERROR return type cannot have an unboxed trait object\n+    return Box::new(panic!());\n+}\n+\n+fn main() {}"}, {"sha": "2dad9e8929421befe3407081974920bc686cfabf", "filename": "src/test/ui/unsized/issue-91803.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b899251f2dfe3a9849f844418e0d11e2073c2423/src%2Ftest%2Fui%2Funsized%2Fissue-91803.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b899251f2dfe3a9849f844418e0d11e2073c2423/src%2Ftest%2Fui%2Funsized%2Fissue-91803.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsized%2Fissue-91803.stderr?ref=b899251f2dfe3a9849f844418e0d11e2073c2423", "patch": "@@ -0,0 +1,15 @@\n+error[E0746]: return type cannot have an unboxed trait object\n+  --> $DIR/issue-91803.rs:3:43\n+   |\n+LL | fn or<'a>(first: &'static dyn Foo<'a>) -> dyn Foo<'a> {\n+   |                                           ^^^^^^^^^^^ doesn't have a size known at compile-time\n+   |\n+   = note: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\n+help: use `impl Foo<'a>` as the return type, as all return paths are of type `Box<_>`, which implements `Foo<'a>`\n+   |\n+LL | fn or<'a>(first: &'static dyn Foo<'a>) -> impl Foo<'a> {\n+   |                                           ~~~~~~~~~~~~\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0746`."}]}