{"sha": "0409f8610612e8261a0139ec9c57396089cea060", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA0MDlmODYxMDYxMmU4MjYxYTAxMzllYzljNTczOTYwODljZWEwNjA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-06-05T20:10:45Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-06-05T20:10:45Z"}, "message": "auto merge of #6938 : jbclements/rust/hygiene_fns_and_cleanup, r=jbclements\n\nI'm close to flipping the switch on hygiene for let-bound identifiers.  This commit adds a bunch of support functions for that change... but also a huge amount of cleanup in syntax.rc. The most interesting of these are\r\n\r\n- the use of TLS for the interners everywhere.  We had already breached the \"no-global-state\" dam by using TLS for encoding, and it saves a lot of code just to use it everywhere.\r\nAlso, there were many places where two or more interners were passed in attached to different structures, and the danger of having those diverge seemed greater that the danger of having a single one get big and heavy. If the interner size proves to be a problem, it should be quite simple to add a \"parameterize\"-like dynamic binding form--because we don't have interesting continuation operations (or tail calling, mostly) this should just be a case of a mutation followed by another later mutation. Again, this is only if the interner gets too big.\r\n\r\n- I renamed the \"repr\" field of the identifier to \"name\". I can see the case for \"repr\" when there's only one field in the structure, but that's no longer the case; there's now a name and a context (both are uints).\r\n\r\n- the interner now just maps between strings and uints, rather than between idents and uints. The former state made perfect sense when identifiers didn't have syntax contexts, but that's no longer the case.\r\n\r\nI've run this patch against a fairly recent incoming, and it appears to pass all tests. Let's see if it can be merged....", "tree": {"sha": "adb67739bc831dd5487911eb2f721613ecc0aa9f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/adb67739bc831dd5487911eb2f721613ecc0aa9f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0409f8610612e8261a0139ec9c57396089cea060", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0409f8610612e8261a0139ec9c57396089cea060", "html_url": "https://github.com/rust-lang/rust/commit/0409f8610612e8261a0139ec9c57396089cea060", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0409f8610612e8261a0139ec9c57396089cea060/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c5fea4a6738cea28402c905cd81d6f2eb8d355ea", "url": "https://api.github.com/repos/rust-lang/rust/commits/c5fea4a6738cea28402c905cd81d6f2eb8d355ea", "html_url": "https://github.com/rust-lang/rust/commit/c5fea4a6738cea28402c905cd81d6f2eb8d355ea"}, {"sha": "91b652695b97c5aef51fdc37c0111b0453ee584e", "url": "https://api.github.com/repos/rust-lang/rust/commits/91b652695b97c5aef51fdc37c0111b0453ee584e", "html_url": "https://github.com/rust-lang/rust/commit/91b652695b97c5aef51fdc37c0111b0453ee584e"}], "stats": {"total": 1569, "additions": 875, "deletions": 694}, "files": [{"sha": "8f72d302bef686398707a60de94fab4b79505ce2", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0409f8610612e8261a0139ec9c57396089cea060/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0409f8610612e8261a0139ec9c57396089cea060/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=0409f8610612e8261a0139ec9c57396089cea060", "patch": "@@ -734,7 +734,7 @@ pub fn mangle_internal_name_by_path(ccx: @CrateContext, path: path) -> ~str {\n }\n \n pub fn mangle_internal_name_by_seq(ccx: @CrateContext, flav: &str) -> ~str {\n-    return fmt!(\"%s_%u\", flav, (ccx.names)(flav).repr);\n+    return fmt!(\"%s_%u\", flav, (ccx.names)(flav).name);\n }\n \n "}, {"sha": "928f7d5a79179e6eab1d7508f49aacf506259576", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0409f8610612e8261a0139ec9c57396089cea060/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0409f8610612e8261a0139ec9c57396089cea060/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=0409f8610612e8261a0139ec9c57396089cea060", "patch": "@@ -39,6 +39,7 @@ use syntax::attr;\n use syntax::codemap;\n use syntax::diagnostic;\n use syntax::parse;\n+use syntax::parse::token;\n use syntax::print::{pp, pprust};\n use syntax;\n \n@@ -230,7 +231,7 @@ pub fn compile_rest(sess: Session,\n                               sess.filesearch,\n                               session::sess_os_to_meta_os(sess.targ_cfg.os),\n                               sess.opts.is_static,\n-                              sess.parse_sess.interner));\n+                              token::get_ident_interner()));\n \n     let lang_items = time(time_passes, ~\"language item collection\", ||\n                           middle::lang_items::collect_language_items(crate, sess));\n@@ -455,7 +456,7 @@ pub fn pretty_print_input(sess: Session, cfg: ast::crate_cfg, input: &input,\n     let is_expanded = upto != cu_parse;\n     let src = sess.codemap.get_filemap(source_name(input)).src;\n     do io::with_str_reader(*src) |rdr| {\n-        pprust::print_crate(sess.codemap, sess.parse_sess.interner,\n+        pprust::print_crate(sess.codemap, token::get_ident_interner(),\n                             sess.span_diagnostic, crate.unwrap(),\n                             source_name(input),\n                             rdr, io::stdout(), ann, is_expanded);\n@@ -754,7 +755,7 @@ pub fn build_session_(sopts: @session::options,\n     let target_cfg = build_target_config(sopts, demitter);\n     let p_s = parse::new_parse_sess_special_handler(span_diagnostic_handler,\n                                                     cm);\n-    let cstore = @mut cstore::mk_cstore(p_s.interner);\n+    let cstore = @mut cstore::mk_cstore(token::get_ident_interner());\n     let filesearch = filesearch::mk_filesearch(\n         &sopts.maybe_sysroot,\n         sopts.target_triple,\n@@ -963,7 +964,7 @@ pub fn early_error(emitter: diagnostic::Emitter, msg: ~str) -> ! {\n \n pub fn list_metadata(sess: Session, path: &Path, out: @io::Writer) {\n     metadata::loader::list_file_metadata(\n-        sess.parse_sess.interner,\n+        token::get_ident_interner(),\n         session::sess_os_to_meta_os(sess.targ_cfg.os), path, out);\n }\n "}, {"sha": "211665942a88dd06842a3feb1e4d9dd1530aa7e1", "filename": "src/librustc/driver/session.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0409f8610612e8261a0139ec9c57396089cea060/src%2Flibrustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0409f8610612e8261a0139ec9c57396089cea060/src%2Flibrustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fsession.rs?ref=0409f8610612e8261a0139ec9c57396089cea060", "patch": "@@ -26,6 +26,7 @@ use syntax::diagnostic;\n use syntax::parse::ParseSess;\n use syntax::{ast, codemap};\n use syntax::abi;\n+use syntax::parse::token;\n use syntax;\n \n use core::hashmap::HashMap;\n@@ -293,14 +294,19 @@ impl Session_ {\n         self.opts.optimize == No && !self.debugging_opt(no_debug_borrows)\n     }\n \n+    // pointless function, now...\n     pub fn str_of(@self, id: ast::ident) -> @~str {\n-        self.parse_sess.interner.get(id)\n+        token::ident_to_str(&id)\n     }\n+\n+    // pointless function, now...\n     pub fn ident_of(@self, st: &str) -> ast::ident {\n-        self.parse_sess.interner.intern(st)\n+        token::str_to_ident(st)\n     }\n+\n+    // pointless function, now...\n     pub fn intr(@self) -> @syntax::parse::token::ident_interner {\n-        self.parse_sess.interner\n+        token::get_ident_interner()\n     }\n }\n "}, {"sha": "cda7d1fa93702659233f5b65b8433203dc3faf02", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0409f8610612e8261a0139ec9c57396089cea060/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0409f8610612e8261a0139ec9c57396089cea060/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=0409f8610612e8261a0139ec9c57396089cea060", "patch": "@@ -22,6 +22,7 @@ use syntax::codemap::{dummy_sp, span, ExpandedFrom, CallInfo, NameAndSpan};\n use syntax::codemap;\n use syntax::ext::base::ExtCtxt;\n use syntax::fold;\n+use syntax::parse::token;\n use syntax::print::pprust;\n use syntax::{ast, ast_util};\n \n@@ -143,7 +144,7 @@ fn fold_item(cx: @mut TestCtxt, i: @ast::item, fld: @fold::ast_fold)\n           -> Option<@ast::item> {\n     cx.path.push(i.ident);\n     debug!(\"current path: %s\",\n-           ast_util::path_name_i(copy cx.path, cx.sess.parse_sess.interner));\n+           ast_util::path_name_i(copy cx.path));\n \n     if is_test_fn(cx, i) || is_bench_fn(i) {\n         match i.node {\n@@ -411,13 +412,10 @@ fn mk_test_desc_and_fn_rec(cx: &TestCtxt, test: &Test) -> @ast::expr {\n \n     let ext_cx = cx.ext_cx;\n \n-    debug!(\"encoding %s\", ast_util::path_name_i(path,\n-                                                cx.sess.parse_sess.interner));\n+    debug!(\"encoding %s\", ast_util::path_name_i(path));\n \n     let name_lit: ast::lit =\n-        nospan(ast::lit_str(@ast_util::path_name_i(\n-            path,\n-            cx.sess.parse_sess.interner)));\n+        nospan(ast::lit_str(@ast_util::path_name_i(path)));\n \n     let name_expr = @ast::expr {\n           id: cx.sess.next_node_id(),"}, {"sha": "546c516c287ca28583cc358b0a1c9b3fc3b420ed", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0409f8610612e8261a0139ec9c57396089cea060/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0409f8610612e8261a0139ec9c57396089cea060/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=0409f8610612e8261a0139ec9c57396089cea060", "patch": "@@ -22,6 +22,7 @@ use core::vec;\n use syntax::attr;\n use syntax::codemap::{span, dummy_sp};\n use syntax::diagnostic::span_handler;\n+use syntax::parse::token;\n use syntax::parse::token::ident_interner;\n use syntax::visit;\n use syntax::ast;\n@@ -176,7 +177,7 @@ fn visit_item(e: @mut Env, i: @ast::item) {\n                             }\n                             nn\n                         }\n-                        None => e.intr.get(i.ident)\n+                        None => token::ident_to_str(&i.ident)\n                     };\n                 if attr::find_attrs_by_name(i.attrs, \"nolink\").is_empty() {\n                     already_added =\n@@ -235,7 +236,7 @@ fn resolve_crate(e: @mut Env,\n                  hash: @~str,\n                  span: span)\n               -> ast::crate_num {\n-    let metas = metas_with_ident(@/*bad*/copy *e.intr.get(ident), metas);\n+    let metas = metas_with_ident(token::ident_to_str(&ident), metas);\n \n     match existing_match(e, metas, hash) {\n       None => {\n@@ -276,7 +277,7 @@ fn resolve_crate(e: @mut Env,\n             match attr::last_meta_item_value_str_by_name(load_ctxt.metas,\n                                                          \"name\") {\n                 Some(v) => v,\n-                None => e.intr.get(ident),\n+                None => token::ident_to_str(&ident),\n             };\n         let cmeta = @cstore::crate_metadata {\n             name: cname,\n@@ -305,10 +306,11 @@ fn resolve_crate_deps(e: @mut Env, cdata: @~[u8]) -> cstore::cnum_map {\n     for decoder::get_crate_deps(e.intr, cdata).each |dep| {\n         let extrn_cnum = dep.cnum;\n         let cname = dep.name;\n+        let cname_str = token::ident_to_str(&dep.name);\n         let cmetas = metas_with(dep.vers, @~\"vers\", ~[]);\n         debug!(\"resolving dep crate %s ver: %s hash: %s\",\n-               *e.intr.get(dep.name), *dep.vers, *dep.hash);\n-        match existing_match(e, metas_with_ident(e.intr.get(cname),\n+               *cname_str, *dep.vers, *dep.hash);\n+        match existing_match(e, metas_with_ident(cname_str,\n                                                  copy cmetas),\n                              dep.hash) {\n           Some(local_cnum) => {"}, {"sha": "baf93416379a89d2268198c96b90bdb345714d4c", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0409f8610612e8261a0139ec9c57396089cea060/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0409f8610612e8261a0139ec9c57396089cea060/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=0409f8610612e8261a0139ec9c57396089cea060", "patch": "@@ -40,6 +40,7 @@ use syntax::parse::token::{StringRef, ident_interner, special_idents};\n use syntax::print::pprust;\n use syntax::{ast, ast_util};\n use syntax::codemap;\n+use syntax::parse::token;\n \n type cmd = @crate_metadata;\n \n@@ -297,10 +298,10 @@ fn item_path(intr: @ident_interner, item_doc: ebml::Doc) -> ast_map::path {\n     for reader::docs(path_doc) |tag, elt_doc| {\n         if tag == tag_path_elt_mod {\n             let str = reader::doc_as_str(elt_doc);\n-            result.push(ast_map::path_mod(intr.intern(str)));\n+            result.push(ast_map::path_mod(token::str_to_ident(str)));\n         } else if tag == tag_path_elt_name {\n             let str = reader::doc_as_str(elt_doc);\n-            result.push(ast_map::path_name(intr.intern(str)));\n+            result.push(ast_map::path_name(token::str_to_ident(str)));\n         } else {\n             // ignore tag_path_len element\n         }\n@@ -314,8 +315,8 @@ fn item_name(intr: @ident_interner, item: ebml::Doc) -> ast::ident {\n     do reader::with_doc_data(name) |data| {\n         let string = str::from_bytes_slice(data);\n         match intr.find_equiv(&StringRef(string)) {\n-            None => intr.intern(string),\n-            Some(val) => val,\n+            None => token::str_to_ident(string),\n+            Some(val) => ast::new_ident(val),\n         }\n     }\n }\n@@ -843,7 +844,7 @@ pub fn get_type_name_if_impl(intr: @ident_interner,\n     }\n \n     for reader::tagged_docs(item, tag_item_impl_type_basename) |doc| {\n-        return Some(intr.intern(str::from_bytes(reader::doc_data(doc))));\n+        return Some(token::str_to_ident(str::from_bytes(reader::doc_data(doc))));\n     }\n \n     return None;\n@@ -1095,7 +1096,7 @@ pub fn get_crate_deps(intr: @ident_interner, data: @~[u8]) -> ~[crate_dep] {\n     }\n     for reader::tagged_docs(depsdoc, tag_crate_dep) |depdoc| {\n         deps.push(crate_dep {cnum: crate_num,\n-                  name: intr.intern(docstr(depdoc, tag_crate_dep_name)),\n+                  name: token::str_to_ident(docstr(depdoc, tag_crate_dep_name)),\n                   vers: @docstr(depdoc, tag_crate_dep_vers),\n                   hash: @docstr(depdoc, tag_crate_dep_hash)});\n         crate_num += 1;\n@@ -1109,7 +1110,7 @@ fn list_crate_deps(intr: @ident_interner, data: @~[u8], out: @io::Writer) {\n     for get_crate_deps(intr, data).each |dep| {\n         out.write_str(\n             fmt!(\"%d %s-%s-%s\\n\",\n-                 dep.cnum, *intr.get(dep.name), *dep.hash, *dep.vers));\n+                 dep.cnum, *token::ident_to_str(&dep.name), *dep.hash, *dep.vers));\n     }\n \n     out.write_str(\"\\n\");"}, {"sha": "2365897c4d7c94379d910e20aa85914327a201c4", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0409f8610612e8261a0139ec9c57396089cea060/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0409f8610612e8261a0139ec9c57396089cea060/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=0409f8610612e8261a0139ec9c57396089cea060", "patch": "@@ -43,6 +43,7 @@ use syntax::opt_vec::OptVec;\n use syntax::opt_vec;\n use syntax::parse::token::special_idents;\n use syntax::{ast_util, visit};\n+use syntax::parse::token;\n use syntax;\n use writer = extra::ebml::writer;\n \n@@ -141,8 +142,7 @@ fn add_to_index(ecx: @EncodeContext,\n     full_path.push(name);\n     index.push(\n         entry {\n-            val: ast_util::path_name_i(full_path,\n-                                       ecx.tcx.sess.parse_sess.interner),\n+            val: ast_util::path_name_i(full_path),\n             pos: ebml_w.writer.tell()\n         });\n }\n@@ -485,8 +485,7 @@ fn encode_info_for_mod(ecx: @EncodeContext,\n                         (%?/%?)\",\n                         *ecx.tcx.sess.str_of(ident),\n                         did,\n-                        ast_map::node_id_to_str(ecx.tcx.items, did, ecx.tcx\n-                                                .sess.parse_sess.interner));\n+                        ast_map::node_id_to_str(ecx.tcx.items, did, token::get_ident_interner()));\n \n                 ebml_w.start_tag(tag_mod_impl);\n                 ebml_w.wr_str(def_to_str(local_def(did)));\n@@ -1055,7 +1054,7 @@ fn encode_info_for_item(ecx: @EncodeContext,\n                         tcx.sess.span_unimpl(\n                             item.span,\n                             fmt!(\"Method %s is both provided and static\",\n-                                 *tcx.sess.intr().get(method_ty.ident)));\n+                                 *token::ident_to_str(&method_ty.ident)));\n                     }\n                     encode_type_param_bounds(ebml_w, ecx,\n                                              &m.generics.ty_params);"}, {"sha": "1ebf8f2e9f471574fba6782191b5a5baa383a861", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0409f8610612e8261a0139ec9c57396089cea060/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0409f8610612e8261a0139ec9c57396089cea060/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=0409f8610612e8261a0139ec9c57396089cea060", "patch": "@@ -19,6 +19,7 @@ use metadata::filesearch::FileSearch;\n use metadata::filesearch;\n use syntax::codemap::span;\n use syntax::diagnostic::span_handler;\n+use syntax::parse::token;\n use syntax::parse::token::ident_interner;\n use syntax::print::pprust;\n use syntax::{ast, attr};\n@@ -59,7 +60,7 @@ pub fn load_library_crate(cx: &Context) -> (~str, @~[u8]) {\n       None => {\n         cx.diag.span_fatal(\n             cx.span, fmt!(\"can't find crate for `%s`\",\n-                          *cx.intr.get(cx.ident)));\n+                          *token::ident_to_str(&cx.ident)));\n       }\n     }\n }"}, {"sha": "8bde4e37d54d81b1887699e70c8fc726b4759324", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0409f8610612e8261a0139ec9c57396089cea060/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0409f8610612e8261a0139ec9c57396089cea060/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=0409f8610612e8261a0139ec9c57396089cea060", "patch": "@@ -41,6 +41,7 @@ use syntax::codemap::span;\n use syntax::codemap;\n use syntax::fold::*;\n use syntax::fold;\n+use syntax::parse::token;\n use syntax;\n use writer = extra::ebml::writer;\n \n@@ -86,7 +87,7 @@ pub fn encode_inlined_item(ecx: @e::EncodeContext,\n                            ii: ast::inlined_item,\n                            maps: Maps) {\n     debug!(\"> Encoding inlined item: %s::%s (%u)\",\n-           ast_map::path_to_str(path, ecx.tcx.sess.parse_sess.interner),\n+           ast_map::path_to_str(path, token::get_ident_interner()),\n            *ecx.tcx.sess.str_of(ii.ident()),\n            ebml_w.writer.tell());\n \n@@ -99,7 +100,7 @@ pub fn encode_inlined_item(ecx: @e::EncodeContext,\n     ebml_w.end_tag();\n \n     debug!(\"< Encoded inlined fn: %s::%s (%u)\",\n-           ast_map::path_to_str(path, ecx.tcx.sess.parse_sess.interner),\n+           ast_map::path_to_str(path, token::get_ident_interner()),\n            *ecx.tcx.sess.str_of(ii.ident()),\n            ebml_w.writer.tell());\n }\n@@ -119,7 +120,7 @@ pub fn decode_inlined_item(cdata: @cstore::crate_metadata,\n       None => None,\n       Some(ast_doc) => {\n         debug!(\"> Decoding inlined fn: %s::?\",\n-               ast_map::path_to_str(path, tcx.sess.parse_sess.interner));\n+               ast_map::path_to_str(path, token::get_ident_interner()));\n         let mut ast_dsr = reader::Decoder(ast_doc);\n         let from_id_range = Decodable::decode(&mut ast_dsr);\n         let to_id_range = reserve_id_range(dcx.tcx.sess, from_id_range);\n@@ -132,7 +133,7 @@ pub fn decode_inlined_item(cdata: @cstore::crate_metadata,\n         let ii = renumber_ast(xcx, raw_ii);\n         debug!(\"Fn named: %s\", *tcx.sess.str_of(ii.ident()));\n         debug!(\"< Decoded inlined fn: %s::%s\",\n-               ast_map::path_to_str(path, tcx.sess.parse_sess.interner),\n+               ast_map::path_to_str(path, token::get_ident_interner()),\n                *tcx.sess.str_of(ii.ident()));\n         ast_map::map_decoded_item(tcx.sess.diagnostic(),\n                                   dcx.tcx.items, path, &ii);\n@@ -1167,7 +1168,7 @@ impl fake_ext_ctxt for fake_session {\n         }\n     }\n     fn ident_of(&self, st: &str) -> ast::ident {\n-        self.interner.intern(st)\n+        token::str_to_ident(st)\n     }\n }\n \n@@ -1236,9 +1237,9 @@ fn test_simplification() {\n     match (item_out, item_exp) {\n       (ast::ii_item(item_out), ast::ii_item(item_exp)) => {\n         assert!(pprust::item_to_str(item_out,\n-                                         ext_cx.parse_sess().interner)\n+                                    token::get_ident_interner())\n                      == pprust::item_to_str(item_exp,\n-                                            ext_cx.parse_sess().interner));\n+                                            token::get_ident_interner()));\n       }\n       _ => fail!()\n     }"}, {"sha": "fa3bae3f5ac92600440da4e7c970c4995d7e0b65", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0409f8610612e8261a0139ec9c57396089cea060/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0409f8610612e8261a0139ec9c57396089cea060/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=0409f8610612e8261a0139ec9c57396089cea060", "patch": "@@ -30,6 +30,7 @@ use syntax::ast;\n use syntax::ast_map;\n use syntax::visit;\n use syntax::codemap::span;\n+use syntax::parse::token;\n \n macro_rules! if_ok(\n     ($inp: expr) => (\n@@ -710,8 +711,8 @@ impl BorrowckCtxt {\n         match *loan_path {\n             LpVar(id) => {\n                 match self.tcx.items.find(&id) {\n-                    Some(&ast_map::node_local(ident)) => {\n-                        str::push_str(out, *self.tcx.sess.intr().get(ident));\n+                    Some(&ast_map::node_local(ref ident)) => {\n+                        str::push_str(out, *token::ident_to_str(ident));\n                     }\n                     r => {\n                         self.tcx.sess.bug(\n@@ -724,9 +725,9 @@ impl BorrowckCtxt {\n             LpExtend(lp_base, _, LpInterior(mc::InteriorField(fname))) => {\n                 self.append_loan_path_to_str_from_interior(lp_base, out);\n                 match fname {\n-                    mc::NamedField(fname) => {\n+                    mc::NamedField(ref fname) => {\n                         str::push_char(out, '.');\n-                        str::push_str(out, *self.tcx.sess.intr().get(fname));\n+                        str::push_str(out, *token::ident_to_str(fname));\n                     }\n                     mc::PositionalField(idx) => {\n                         str::push_char(out, '#'); // invent a notation here"}, {"sha": "fe30b9c4fd7213a538bab9698f94a59733dd8bf6", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 16, "deletions": 48, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/0409f8610612e8261a0139ec9c57396089cea060/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0409f8610612e8261a0139ec9c57396089cea060/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=0409f8610612e8261a0139ec9c57396089cea060", "patch": "@@ -35,6 +35,7 @@ use syntax::ast_util::{Private, Public, is_local};\n use syntax::ast_util::{variant_visibility_to_privacy, visibility_to_privacy};\n use syntax::attr;\n use syntax::codemap::span;\n+use syntax::parse::token;\n use syntax::visit;\n \n pub fn check_crate(tcx: ty::ctxt,\n@@ -120,7 +121,7 @@ pub fn check_crate(tcx: ty::ctxt,\n                                        ast_map::node_id_to_str(\n                                             tcx.items,\n                                             method_id,\n-                                            tcx.sess.parse_sess.interner)));\n+                                           token::get_ident_interner())));\n             }\n             None => {\n                 tcx.sess.span_bug(span, \"method not found in \\\n@@ -184,7 +185,7 @@ pub fn check_crate(tcx: ty::ctxt,\n                                        ast_map::node_id_to_str(\n                                             tcx.items,\n                                             method_id,\n-                                            tcx.sess.parse_sess.interner)));\n+                                           token::get_ident_interner())));\n             }\n             None => {\n                 tcx.sess.span_bug(span, \"method not found in \\\n@@ -216,9 +217,7 @@ pub fn check_crate(tcx: ty::ctxt,\n                                            ast_map::node_id_to_str(\n                                                 tcx.items,\n                                                 item_id,\n-                                                tcx.sess\n-                                                   .parse_sess\n-                                                   .interner)));\n+                                               token::get_ident_interner())));\n                 }\n                 None => {\n                     tcx.sess.span_bug(span, \"item not found in AST map?!\");\n@@ -236,8 +235,7 @@ pub fn check_crate(tcx: ty::ctxt,\n             if field.ident != ident { loop; }\n             if field.vis == private {\n                 tcx.sess.span_err(span, fmt!(\"field `%s` is private\",\n-                                             *tcx.sess.parse_sess.interner\n-                                                 .get(ident)));\n+                                             *token::ident_to_str(&ident)));\n             }\n             break;\n         }\n@@ -257,19 +255,15 @@ pub fn check_crate(tcx: ty::ctxt,\n                      !privileged_items.contains(&(container_id.node))) {\n                 tcx.sess.span_err(span,\n                                   fmt!(\"method `%s` is private\",\n-                                       *tcx.sess\n-                                           .parse_sess\n-                                           .interner\n-                                           .get(*name)));\n+                                       *token::ident_to_str(name)));\n             }\n         } else {\n             let visibility =\n                 csearch::get_item_visibility(tcx.sess.cstore, method_id);\n             if visibility != public {\n                 tcx.sess.span_err(span,\n                                   fmt!(\"method `%s` is private\",\n-                                       *tcx.sess.parse_sess.interner\n-                                           .get(*name)));\n+                                       *token::ident_to_str(name)));\n             }\n         }\n     };\n@@ -289,23 +283,13 @@ pub fn check_crate(tcx: ty::ctxt,\n                             !privileged_items.contains(&def_id.node) {\n                         tcx.sess.span_err(span,\n                                           fmt!(\"function `%s` is private\",\n-                                               *tcx.sess\n-                                                   .parse_sess\n-                                                   .interner\n-                                                   .get(copy *path\n-                                                             .idents\n-                                                             .last())));\n+                                               *token::ident_to_str(path.idents.last())));\n                     }\n                 } else if csearch::get_item_visibility(tcx.sess.cstore,\n                                                        def_id) != public {\n                     tcx.sess.span_err(span,\n                                       fmt!(\"function `%s` is private\",\n-                                           *tcx.sess\n-                                               .parse_sess\n-                                               .interner\n-                                               .get(copy *path\n-                                                         .idents\n-                                                         .last())));\n+                                           *token::ident_to_str(path.idents.last())));\n                 }\n             }\n             _ => {}\n@@ -335,28 +319,17 @@ pub fn check_crate(tcx: ty::ctxt,\n                             match item.node {\n                                 item_trait(_, _, ref methods) => {\n                                     if method_num >= (*methods).len() {\n-                                        tcx.sess.span_bug(span, \"method \\\n-                                                                 number \\\n-                                                                 out of \\\n-                                                                 range?!\");\n+                                        tcx.sess.span_bug(span, \"method number out of range?!\");\n                                     }\n                                     match (*methods)[method_num] {\n                                         provided(method)\n                                              if method.vis == private &&\n                                              !privileged_items\n                                              .contains(&(trait_id.node)) => {\n                                             tcx.sess.span_err(span,\n-                                                              fmt!(\"method\n-                                                                    `%s` \\\n-                                                                    is \\\n-                                                                    private\",\n-                                                                   *tcx\n-                                                                   .sess\n-                                                                   .parse_sess\n-                                                                   .interner\n-                                                                   .get\n-                                                                   (method\n-                                                                    .ident)));\n+                                                              fmt!(\"method `%s` is private\",\n+                                                                   *token::ident_to_str(&method\n+                                                                                        .ident)));\n                                         }\n                                         provided(_) | required(_) => {\n                                             // Required methods can't be\n@@ -365,20 +338,15 @@ pub fn check_crate(tcx: ty::ctxt,\n                                     }\n                                 }\n                                 _ => {\n-                                    tcx.sess.span_bug(span, \"trait wasn't \\\n-                                                             actually a \\\n-                                                             trait?!\");\n+                                    tcx.sess.span_bug(span, \"trait wasn't actually a trait?!\");\n                                 }\n                             }\n                         }\n                         Some(_) => {\n-                            tcx.sess.span_bug(span, \"trait wasn't an \\\n-                                                     item?!\");\n+                            tcx.sess.span_bug(span, \"trait wasn't an item?!\");\n                         }\n                         None => {\n-                            tcx.sess.span_bug(span, \"trait item wasn't \\\n-                                                     found in the AST \\\n-                                                     map?!\");\n+                            tcx.sess.span_bug(span, \"trait item wasn't found in the AST map?!\");\n                         }\n                     }\n                 } else {"}, {"sha": "5ccb38b960d5883ec9af7d2673b7cbc4dcf9e414", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0409f8610612e8261a0139ec9c57396089cea060/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0409f8610612e8261a0139ec9c57396089cea060/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=0409f8610612e8261a0139ec9c57396089cea060", "patch": "@@ -30,6 +30,7 @@ use core::hashmap::{HashMap, HashSet};\n use syntax::ast_map;\n use syntax::codemap::span;\n use syntax::print::pprust;\n+use syntax::parse::token;\n use syntax::parse::token::special_idents;\n use syntax::{ast, visit};\n \n@@ -595,7 +596,7 @@ impl DetermineRpCtxt {\n \n         debug!(\"add_rp() variance for %s: %? == %? ^ %?\",\n                ast_map::node_id_to_str(self.ast_map, id,\n-                                       self.sess.parse_sess.interner),\n+                                       token::get_ident_interner()),\n                joined_variance, old_variance, variance);\n \n         if Some(joined_variance) != old_variance {\n@@ -614,9 +615,9 @@ impl DetermineRpCtxt {\n         debug!(\"add dependency from %d -> %d (%s -> %s) with variance %?\",\n                from, self.item_id,\n                ast_map::node_id_to_str(self.ast_map, from,\n-                                       self.sess.parse_sess.interner),\n+                                       token::get_ident_interner()),\n                ast_map::node_id_to_str(self.ast_map, self.item_id,\n-                                       self.sess.parse_sess.interner),\n+                                       token::get_ident_interner()),\n                copy self.ambient_variance);\n         let vec = match self.dep_map.find(&from) {\n             Some(&vec) => vec,\n@@ -951,7 +952,7 @@ pub fn determine_rp_in_crate(sess: Session,\n             debug!(\"item %? (%s) is parameterized with variance %?\",\n                    key,\n                    ast_map::node_id_to_str(ast_map, key,\n-                                           sess.parse_sess.interner),\n+                                           token::get_ident_interner()),\n                    value);\n         }\n         \"----\""}, {"sha": "c23932b14b51c1e02a067bde4fa71e5b049975a0", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0409f8610612e8261a0139ec9c57396089cea060/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0409f8610612e8261a0139ec9c57396089cea060/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=0409f8610612e8261a0139ec9c57396089cea060", "patch": "@@ -28,6 +28,7 @@ use syntax::ast_util::{path_to_ident, walk_pat, trait_method_to_ty_method};\n use syntax::ast_util::{Privacy, Public, Private};\n use syntax::ast_util::{variant_visibility_to_privacy, visibility_to_privacy};\n use syntax::attr::{attr_metas, contains_name};\n+use syntax::parse::token;\n use syntax::parse::token::ident_interner;\n use syntax::parse::token::special_idents;\n use syntax::print::pprust::path_to_str;\n@@ -727,7 +728,7 @@ impl PrimitiveTypeTable {\n                   intr: @ident_interner,\n                   string: &str,\n                   primitive_type: prim_ty) {\n-        let ident = intr.intern(string);\n+        let ident = token::str_to_ident(string);\n         self.primitive_types.insert(ident, primitive_type);\n     }\n }\n@@ -805,8 +806,7 @@ pub fn Resolver(session: Session,\n         self_ident: special_idents::self_,\n         type_self_ident: special_idents::type_self,\n \n-        primitive_type_table: @PrimitiveTypeTable(session.\n-                                                  parse_sess.interner),\n+        primitive_type_table: @PrimitiveTypeTable(token::get_ident_interner()),\n \n         namespaces: ~[ TypeNS, ValueNS ],\n \n@@ -2942,17 +2942,17 @@ impl Resolver {\n                                  module_: @mut Module,\n                                  module_path: &[ident])\n                                  -> ResolveResult<ModulePrefixResult> {\n-        let interner = self.session.parse_sess.interner;\n+        let interner = token::get_ident_interner();\n \n         // Start at the current module if we see `self` or `super`, or at the\n         // top of the crate otherwise.\n         let mut containing_module;\n         let mut i;\n-        if *interner.get(module_path[0]) == ~\"self\" {\n+        if *token::ident_to_str(&module_path[0]) == ~\"self\" {\n             containing_module =\n                 self.get_nearest_normal_module_parent_or_self(module_);\n             i = 1;\n-        } else if *interner.get(module_path[0]) == ~\"super\" {\n+        } else if *token::ident_to_str(&module_path[0]) == ~\"super\" {\n             containing_module =\n                 self.get_nearest_normal_module_parent_or_self(module_);\n             i = 0;  // We'll handle `super` below.\n@@ -2962,7 +2962,7 @@ impl Resolver {\n \n         // Now loop through all the `super`s we find.\n         while i < module_path.len() &&\n-                *interner.get(module_path[i]) == ~\"super\" {\n+                *token::ident_to_str(&module_path[i]) == ~\"super\" {\n             debug!(\"(resolving module prefix) resolving `super` at %s\",\n                    self.module_to_str(containing_module));\n             match self.get_nearest_normal_module_parent(containing_module) {"}, {"sha": "ba88fe09e70abd758ec4e4ed7113efb4e4edf9cc", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0409f8610612e8261a0139ec9c57396089cea060/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0409f8610612e8261a0139ec9c57396089cea060/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=0409f8610612e8261a0139ec9c57396089cea060", "patch": "@@ -78,7 +78,8 @@ use syntax::ast_map::{path, path_elt_to_str, path_name};\n use syntax::ast_util::{local_def, path_to_ident};\n use syntax::attr;\n use syntax::codemap::span;\n-use syntax::parse::token::special_idents;\n+use syntax::parse::token;\n+use syntax::parse::token::{special_idents};\n use syntax::print::pprust::stmt_to_str;\n use syntax::visit;\n use syntax::{ast, ast_util, codemap, ast_map};\n@@ -2257,10 +2258,10 @@ pub fn register_fn_fuller(ccx: @CrateContext,\n                           -> ValueRef {\n     debug!(\"register_fn_fuller creating fn for item %d with path %s\",\n            node_id,\n-           ast_map::path_to_str(path, ccx.sess.parse_sess.interner));\n+           ast_map::path_to_str(path, token::get_ident_interner()));\n \n     let ps = if attr::attrs_contains_name(attrs, \"no_mangle\") {\n-        path_elt_to_str(*path.last(), ccx.sess.parse_sess.interner)\n+        path_elt_to_str(*path.last(), token::get_ident_interner())\n     } else {\n         mangle_exported_name(ccx, /*bad*/copy path, node_type)\n     };\n@@ -2504,7 +2505,7 @@ pub fn get_item_val(ccx: @CrateContext, id: ast::node_id) -> ValueRef {\n                 }\n                 ast::foreign_item_const(*) => {\n                     let typ = ty::node_id_to_type(tcx, ni.id);\n-                    let ident = ccx.sess.parse_sess.interner.get(ni.ident);\n+                    let ident = token::ident_to_str(&ni.ident);\n                     let g = do str::as_c_str(*ident) |buf| {\n                         unsafe {\n                             llvm::LLVMAddGlobal(ccx.llmod,\n@@ -3069,7 +3070,7 @@ pub fn trans_crate(sess: session::Session,\n         lib::llvm::associate_type(tn, @\"tydesc\", tydesc_type);\n         let crate_map = decl_crate_map(sess, link_meta, llmod);\n         let dbg_cx = if sess.opts.debuginfo {\n-            Some(debuginfo::mk_ctxt(copy llmod_id, sess.parse_sess.interner))\n+            Some(debuginfo::mk_ctxt(copy llmod_id, token::get_ident_interner()))\n         } else {\n             None\n         };\n@@ -3104,7 +3105,7 @@ pub fn trans_crate(sess: session::Session,\n               lltypes: @mut HashMap::new(),\n               llsizingtypes: @mut HashMap::new(),\n               adt_reprs: @mut HashMap::new(),\n-              names: new_namegen(sess.parse_sess.interner),\n+              names: new_namegen(token::get_ident_interner()),\n               next_addrspace: new_addrspace_gen(),\n               symbol_hasher: symbol_hasher,\n               type_hashcodes: @mut HashMap::new(),"}, {"sha": "8831cde110541a19af3141a68be929c48e7ad463", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0409f8610612e8261a0139ec9c57396089cea060/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0409f8610612e8261a0139ec9c57396089cea060/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=0409f8610612e8261a0139ec9c57396089cea060", "patch": "@@ -52,16 +52,19 @@ use core::vec;\n use syntax::ast::ident;\n use syntax::ast_map::{path, path_elt};\n use syntax::codemap::span;\n+use syntax::parse::token;\n use syntax::parse::token::ident_interner;\n use syntax::{ast, ast_map};\n use syntax::abi::{X86, X86_64, Arm, Mips};\n \n+// NOTE: this thunk is totally pointless now that we're not passing\n+// interners around...\n pub type namegen = @fn(s: &str) -> ident;\n pub fn new_namegen(intr: @ident_interner) -> namegen {\n     let f: @fn(s: &str) -> ident = |prefix| {\n-        intr.gensym(fmt!(\"%s_%u\",\n-                          prefix,\n-                          intr.gensym(prefix).repr))\n+        token::str_to_ident(fmt!(\"%s_%u\",\n+                                 prefix,\n+                                 token::gensym(prefix)))\n     };\n     f\n }\n@@ -1195,7 +1198,7 @@ pub fn C_cstr(cx: @CrateContext, s: @~str) -> ValueRef {\n             llvm::LLVMConstString(buf, s.len() as c_uint, False)\n         };\n         let g =\n-            str::as_c_str(fmt!(\"str%u\", (cx.names)(\"str\").repr),\n+            str::as_c_str(fmt!(\"str%u\", (cx.names)(\"str\").name),\n                         |buf| llvm::LLVMAddGlobal(cx.llmod, val_ty(sc), buf));\n         llvm::LLVMSetInitializer(g, sc);\n         llvm::LLVMSetGlobalConstant(g, True);\n@@ -1287,7 +1290,7 @@ pub fn C_bytes_plus_null(bytes: &[u8]) -> ValueRef {\n pub fn C_shape(ccx: @CrateContext, bytes: ~[u8]) -> ValueRef {\n     unsafe {\n         let llshape = C_bytes_plus_null(bytes);\n-        let name = fmt!(\"shape%u\", (ccx.names)(\"shape\").repr);\n+        let name = fmt!(\"shape%u\", (ccx.names)(\"shape\").name);\n         let llglobal = str::as_c_str(name, |buf| {\n             llvm::LLVMAddGlobal(ccx.llmod, val_ty(llshape), buf)\n         });"}, {"sha": "dfcf364233be2aebac98f697f6b702a688280a08", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0409f8610612e8261a0139ec9c57396089cea060/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0409f8610612e8261a0139ec9c57396089cea060/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=0409f8610612e8261a0139ec9c57396089cea060", "patch": "@@ -41,6 +41,7 @@ use syntax::{ast, ast_util};\n use syntax::{attr, ast_map};\n use syntax::opt_vec;\n use syntax::parse::token::special_idents;\n+use syntax::parse::token;\n use syntax::abi::{X86, X86_64, Arm, Mips};\n use syntax::abi::{RustIntrinsic, Rust, Stdcall, Fastcall,\n                   Cdecl, Aapcs, C};\n@@ -343,8 +344,7 @@ pub fn trans_foreign_mod(ccx: @CrateContext,\n                 }\n             }\n             ast::foreign_item_const(*) => {\n-                let ident = ccx.sess.parse_sess.interner.get(\n-                    foreign_item.ident);\n+                let ident = token::ident_to_str(&foreign_item.ident);\n                 ccx.item_symbols.insert(foreign_item.id, copy *ident);\n             }\n         }"}, {"sha": "9c84b4ffa997f2298435d37e4d652c45696a7bfe", "filename": "src/librustc/middle/trans/type_use.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0409f8610612e8261a0139ec9c57396089cea060/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0409f8610612e8261a0139ec9c57396089cea060/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=0409f8610612e8261a0139ec9c57396089cea060", "patch": "@@ -42,6 +42,7 @@ use syntax::ast;\n use syntax::ast::*;\n use syntax::ast_map;\n use syntax::ast_util;\n+use syntax::parse::token;\n use syntax::visit;\n \n pub type type_uses = uint; // Bitmask\n@@ -170,7 +171,7 @@ pub fn type_uses_for(ccx: @CrateContext, fn_id: def_id, n_tps: uint)\n                               ast_map::node_id_to_str(\n                                 ccx.tcx.items,\n                                 fn_id_loc.node,\n-                                ccx.tcx.sess.parse_sess.interner)));\n+                                token::get_ident_interner())));\n       }\n     }\n     let Context { uses, _ } = cx;"}, {"sha": "363af7c9e56cac2d0e7a26d3c287271640f33dba", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0409f8610612e8261a0139ec9c57396089cea060/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0409f8610612e8261a0139ec9c57396089cea060/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=0409f8610612e8261a0139ec9c57396089cea060", "patch": "@@ -43,6 +43,7 @@ use syntax::ast_util;\n use syntax::attr;\n use syntax::codemap::span;\n use syntax::codemap;\n+use syntax::parse::token;\n use syntax::parse::token::special_idents;\n use syntax::{ast, ast_map};\n use syntax::opt_vec::OptVec;\n@@ -2678,7 +2679,7 @@ impl cmp::TotalOrd for bound_region {\n             (&ty::br_anon(ref a1), &ty::br_anon(ref a2)) => a1.cmp(a2),\n             (&ty::br_anon(*), _) => cmp::Less,\n \n-            (&ty::br_named(ref a1), &ty::br_named(ref a2)) => a1.repr.cmp(&a2.repr),\n+            (&ty::br_named(ref a1), &ty::br_named(ref a2)) => a1.name.cmp(&a2.name),\n             (&ty::br_named(*), _) => cmp::Less,\n \n             (&ty::br_cap_avoid(ref a1, @ref b1),\n@@ -2819,7 +2820,7 @@ pub fn node_id_to_trait_ref(cx: ctxt, id: ast::node_id) -> @ty::TraitRef {\n        None => cx.sess.bug(\n            fmt!(\"node_id_to_trait_ref: no trait ref for node `%s`\",\n                 ast_map::node_id_to_str(cx.items, id,\n-                                        cx.sess.parse_sess.interner)))\n+                                        token::get_ident_interner())))\n     }\n }\n \n@@ -2830,7 +2831,7 @@ pub fn node_id_to_type(cx: ctxt, id: ast::node_id) -> t {\n        None => cx.sess.bug(\n            fmt!(\"node_id_to_type: no type for node `%s`\",\n                 ast_map::node_id_to_str(cx.items, id,\n-                                        cx.sess.parse_sess.interner)))\n+                                        token::get_ident_interner())))\n     }\n }\n \n@@ -3821,7 +3822,7 @@ pub fn substd_enum_variants(cx: ctxt,\n }\n \n pub fn item_path_str(cx: ctxt, id: ast::def_id) -> ~str {\n-    ast_map::path_to_str(item_path(cx, id), cx.sess.parse_sess.interner)\n+    ast_map::path_to_str(item_path(cx, id), token::get_ident_interner())\n }\n \n pub enum DtorKind {\n@@ -4107,7 +4108,7 @@ pub fn lookup_struct_fields(cx: ctxt, did: ast::def_id) -> ~[field_ty] {\n            cx.sess.bug(\n                fmt!(\"struct ID not bound to an item: %s\",\n                     ast_map::node_id_to_str(cx.items, did.node,\n-                                            cx.sess.parse_sess.interner)));\n+                                            token::get_ident_interner())));\n        }\n     }\n         }"}, {"sha": "c69aeeb4aa8b890443e4dfa64906e203a56fc5ac", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0409f8610612e8261a0139ec9c57396089cea060/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0409f8610612e8261a0139ec9c57396089cea060/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=0409f8610612e8261a0139ec9c57396089cea060", "patch": "@@ -127,6 +127,7 @@ use syntax::codemap::span;\n use syntax::codemap;\n use syntax::opt_vec::OptVec;\n use syntax::opt_vec;\n+use syntax::parse::token;\n use syntax::parse::token::special_idents;\n use syntax::print::pprust;\n use syntax::visit;\n@@ -815,7 +816,7 @@ impl FnCtxt {\n                     fmt!(\"no type for node %d: %s in fcx %s\",\n                          id, ast_map::node_id_to_str(\n                              self.tcx().items, id,\n-                             self.tcx().sess.parse_sess.interner),\n+                             token::get_ident_interner()),\n                          self.tag()));\n             }\n         }\n@@ -829,7 +830,7 @@ impl FnCtxt {\n                     fmt!(\"no type substs for node %d: %s in fcx %s\",\n                          id, ast_map::node_id_to_str(\n                              self.tcx().items, id,\n-                             self.tcx().sess.parse_sess.interner),\n+                             token::get_ident_interner()),\n                          self.tag()));\n             }\n         }"}, {"sha": "2ec4cc65528f3ba777354c7b5be644c04f93d74b", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0409f8610612e8261a0139ec9c57396089cea060/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0409f8610612e8261a0139ec9c57396089cea060/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=0409f8610612e8261a0139ec9c57396089cea060", "patch": "@@ -28,6 +28,7 @@ use middle::typeck;\n use syntax::abi::AbiSet;\n use syntax::ast_map;\n use syntax::codemap::span;\n+use syntax::parse::token;\n use syntax::print::pprust;\n use syntax::{ast, ast_util};\n \n@@ -200,7 +201,7 @@ pub fn re_scope_id_to_str(cx: ctxt, node_id: ast::node_id) -> ~str {\n       _ => { cx.sess.bug(\n           fmt!(\"re_scope refers to %s\",\n                ast_map::node_id_to_str(cx.items, node_id,\n-                                       cx.sess.parse_sess.interner))) }\n+                                       token::get_ident_interner()))) }\n     }\n }\n \n@@ -654,7 +655,7 @@ impl Repr for ty::Method {\n \n impl Repr for ast::ident {\n     fn repr(&self, tcx: ctxt) -> ~str {\n-        copy *tcx.sess.intr().get(*self)\n+        copy *token::ident_to_str(self)\n     }\n }\n "}, {"sha": "1175175c2d6b96cba4cce87a53636896f7238796", "filename": "src/librustdoc/extract.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0409f8610612e8261a0139ec9c57396089cea060/src%2Flibrustdoc%2Fextract.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0409f8610612e8261a0139ec9c57396089cea060/src%2Flibrustdoc%2Fextract.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fextract.rs?ref=0409f8610612e8261a0139ec9c57396089cea060", "patch": "@@ -18,16 +18,17 @@ use doc;\n \n use core::vec;\n use syntax::ast;\n-use syntax::parse::token::{ident_interner};\n+use syntax::parse::token::{ident_interner, ident_to_str};\n use syntax::parse::token;\n \n // Hack; rather than thread an interner through everywhere, rely on\n // thread-local data\n+// Hack-Becomes-Feature: using thread-local-state everywhere...\n pub fn to_str(id: ast::ident) -> ~str {\n-    let intr = token::get_ident_interner();\n-    return copy *(*intr).get(id);\n+    return copy *ident_to_str(&id);\n }\n \n+// get rid of this pointless function:\n pub fn interner() -> @ident_interner {\n     return token::get_ident_interner();\n }"}, {"sha": "82336addb62fc6ef0d3fb0814712e73fe60f9f9b", "filename": "src/librustdoc/tystr_pass.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0409f8610612e8261a0139ec9c57396089cea060/src%2Flibrustdoc%2Ftystr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0409f8610612e8261a0139ec9c57396089cea060/src%2Flibrustdoc%2Ftystr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftystr_pass.rs?ref=0409f8610612e8261a0139ec9c57396089cea060", "patch": "@@ -24,6 +24,7 @@ use pass::Pass;\n use core::vec;\n use syntax::ast;\n use syntax::print::pprust;\n+use syntax::parse::token;\n use syntax::ast_map;\n \n pub fn mk_pass() -> Pass {\n@@ -76,7 +77,7 @@ fn get_fn_sig(srv: astsrv::Srv, fn_id: doc::AstId) -> Option<~str> {\n                 node: ast::foreign_item_fn(ref decl, purity, ref tys), _\n             }, _, _, _) => {\n                 Some(pprust::fun_to_str(decl, purity, ident, None, tys,\n-                                        extract::interner()))\n+                                       token::get_ident_interner()))\n             }\n             _ => fail!(\"get_fn_sig: fn_id not bound to a fn item\")\n         }"}, {"sha": "88482c94336dab503018c494d1f650582245e125", "filename": "src/librusti/rusti.rc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0409f8610612e8261a0139ec9c57396089cea060/src%2Flibrusti%2Frusti.rc", "raw_url": "https://github.com/rust-lang/rust/raw/0409f8610612e8261a0139ec9c57396089cea060/src%2Flibrusti%2Frusti.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrusti%2Frusti.rc?ref=0409f8610612e8261a0139ec9c57396089cea060", "patch": "@@ -174,7 +174,7 @@ fn run(repl: Repl, input: ~str) -> Repl {\n         _ => fail!()\n     };\n     debug!(\"recording input into repl history\");\n-    record(repl, blk, sess.parse_sess.interner)\n+    record(repl, blk, token::get_ident_interner())\n }\n \n // Compiles a crate given by the filename as a library if the compiled"}, {"sha": "b763c1c2d761712e3f10c73f2da8e189961f577a", "filename": "src/libstd/rand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0409f8610612e8261a0139ec9c57396089cea060/src%2Flibstd%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0409f8610612e8261a0139ec9c57396089cea060/src%2Flibstd%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand.rs?ref=0409f8610612e8261a0139ec9c57396089cea060", "patch": "@@ -25,7 +25,7 @@ distributions like normal and exponential.\n use core::rand::RngUtil;\n \n fn main() {\n-    let rng = rand::rng();\n+    let mut rng = rand::rng();\n     if rng.gen() { // bool\n         println(fmt!(\"int: %d, uint: %u\", rng.gen(), rng.gen()))\n     }"}, {"sha": "5bbc5d4e819e0c8526d49ec850117bd9b17a725a", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/0409f8610612e8261a0139ec9c57396089cea060/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0409f8610612e8261a0139ec9c57396089cea060/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=0409f8610612e8261a0139ec9c57396089cea060", "patch": "@@ -15,7 +15,7 @@ use core::prelude::*;\n use codemap::{span, spanned};\n use abi::AbiSet;\n use opt_vec::OptVec;\n-use parse::token::get_ident_interner;\n+use parse::token::{ident_to_str, interner_get, str_to_ident};\n \n use core::hashmap::HashMap;\n use core::option::Option;\n@@ -25,12 +25,15 @@ use core::to_str::ToStr;\n use extra::serialize::{Encodable, Decodable, Encoder, Decoder};\n \n \n-// an identifier contains an index into the interner\n-// table and a SyntaxContext to track renaming and\n+// an identifier contains a Name (index into the interner\n+// table) and a SyntaxContext to track renaming and\n // macro expansion per Flatt et al., \"Macros\n // That Work Together\"\n #[deriving(Eq)]\n-pub struct ident { repr: Name, ctxt: SyntaxContext }\n+pub struct ident { name: Name, ctxt: SyntaxContext }\n+\n+/// Construct an identifier with the given name and an empty context:\n+pub fn new_ident(name: Name) -> ident { ident {name: name, ctxt: empty_ctxt}}\n \n // a SyntaxContext represents a chain of macro-expandings\n // and renamings. Each macro expansion corresponds to\n@@ -72,30 +75,29 @@ pub enum SyntaxContext_ {\n     IllegalCtxt()\n }\n \n-// a name represents an identifier\n+// a name is a part of an identifier, representing a string\n+// or gensym. It's the result of interning.\n pub type Name = uint;\n // a mark represents a unique id associated\n // with a macro expansion\n pub type Mrk = uint;\n \n impl<S:Encoder> Encodable<S> for ident {\n     fn encode(&self, s: &mut S) {\n-        let intr = get_ident_interner();\n-        s.emit_str(*(*intr).get(*self));\n+        s.emit_str(*interner_get(self.name));\n     }\n }\n \n impl<D:Decoder> Decodable<D> for ident {\n     fn decode(d: &mut D) -> ident {\n-        let intr = get_ident_interner();\n-        (*intr).intern(d.read_str())\n+        str_to_ident(d.read_str())\n     }\n }\n \n impl to_bytes::IterBytes for ident {\n     #[inline(always)]\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n-        self.repr.iter_bytes(lsb0, f)\n+        self.name.iter_bytes(lsb0, f)\n     }\n }\n \n@@ -385,6 +387,7 @@ pub type stmt = spanned<stmt_>;\n \n #[deriving(Eq, Encodable, Decodable)]\n pub enum stmt_ {\n+    // could be an item or a local (let) binding:\n     stmt_decl(@decl, node_id),\n \n     // expr without trailing semi-colon (must have unit type):\n@@ -414,7 +417,9 @@ pub type decl = spanned<decl_>;\n \n #[deriving(Eq, Encodable, Decodable)]\n pub enum decl_ {\n+    // a local (let) binding:\n     decl_local(@local),\n+    // an item binding:\n     decl_item(@item),\n }\n "}, {"sha": "ec77ba8853041a1aefb2fa3836241a3b3fccce04", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0409f8610612e8261a0139ec9c57396089cea060/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0409f8610612e8261a0139ec9c57396089cea060/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=0409f8610612e8261a0139ec9c57396089cea060", "patch": "@@ -58,8 +58,8 @@ pub fn path_to_str_with_sep(p: &[path_elt], sep: &str, itr: @ident_interner)\n                          -> ~str {\n     let strs = do p.map |e| {\n         match *e {\n-          path_mod(s) => copy *itr.get(s),\n-          path_name(s) => copy *itr.get(s)\n+          path_mod(s) => copy *itr.get(s.name),\n+          path_name(s) => copy *itr.get(s.name)\n         }\n     };\n     str::connect(strs, sep)\n@@ -68,9 +68,9 @@ pub fn path_to_str_with_sep(p: &[path_elt], sep: &str, itr: @ident_interner)\n pub fn path_ident_to_str(p: &path, i: ident, itr: @ident_interner) -> ~str {\n     if vec::is_empty(*p) {\n         //FIXME /* FIXME (#2543) */ copy *i\n-        copy *itr.get(i)\n+        copy *itr.get(i.name)\n     } else {\n-        fmt!(\"%s::%s\", path_to_str(*p, itr), *itr.get(i))\n+        fmt!(\"%s::%s\", path_to_str(*p, itr), *itr.get(i.name))\n     }\n }\n \n@@ -80,8 +80,8 @@ pub fn path_to_str(p: &[path_elt], itr: @ident_interner) -> ~str {\n \n pub fn path_elt_to_str(pe: path_elt, itr: @ident_interner) -> ~str {\n     match pe {\n-        path_mod(s) => copy *itr.get(s),\n-        path_name(s) => copy *itr.get(s)\n+        path_mod(s) => copy *itr.get(s.name),\n+        path_name(s) => copy *itr.get(s.name)\n     }\n }\n \n@@ -356,16 +356,16 @@ pub fn node_id_to_str(map: map, id: node_id, itr: @ident_interner) -> ~str {\n       }\n       Some(&node_method(m, _, path)) => {\n         fmt!(\"method %s in %s (id=%?)\",\n-             *itr.get(m.ident), path_to_str(*path, itr), id)\n+             *itr.get(m.ident.name), path_to_str(*path, itr), id)\n       }\n       Some(&node_trait_method(ref tm, _, path)) => {\n         let m = ast_util::trait_method_to_ty_method(&**tm);\n         fmt!(\"method %s in %s (id=%?)\",\n-             *itr.get(m.ident), path_to_str(*path, itr), id)\n+             *itr.get(m.ident.name), path_to_str(*path, itr), id)\n       }\n       Some(&node_variant(ref variant, _, path)) => {\n         fmt!(\"variant %s in %s (id=%?)\",\n-             *itr.get(variant.node.name), path_to_str(*path, itr), id)\n+             *itr.get(variant.node.name.name), path_to_str(*path, itr), id)\n       }\n       Some(&node_expr(expr)) => {\n         fmt!(\"expr %s (id=%?)\", pprust::expr_to_str(expr, itr), id)\n@@ -381,7 +381,7 @@ pub fn node_id_to_str(map: map, id: node_id, itr: @ident_interner) -> ~str {\n         fmt!(\"arg (id=%?)\", id)\n       }\n       Some(&node_local(ident)) => {\n-        fmt!(\"local (id=%?, name=%s)\", id, *itr.get(ident))\n+        fmt!(\"local (id=%?, name=%s)\", id, *itr.get(ident.name))\n       }\n       Some(&node_block(_)) => {\n         fmt!(\"block\")"}, {"sha": "d99363d7ee5f7330e64261b1cbac3cf7c4883d48", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 83, "deletions": 46, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/0409f8610612e8261a0139ec9c57396089cea060/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0409f8610612e8261a0139ec9c57396089cea060/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=0409f8610612e8261a0139ec9c57396089cea060", "patch": "@@ -14,6 +14,8 @@ use ast::*;\n use ast;\n use ast_util;\n use codemap::{span, spanned};\n+use core::cast;\n+use core::local_data;\n use opt_vec;\n use parse::token;\n use visit;\n@@ -24,12 +26,11 @@ use core::option;\n use core::str;\n use core::to_bytes;\n \n-pub fn path_name_i(idents: &[ident], intr: @token::ident_interner) -> ~str {\n+pub fn path_name_i(idents: &[ident]) -> ~str {\n     // FIXME: Bad copies (#2543 -- same for everything else that says \"bad\")\n-    str::connect(idents.map(|i| copy *intr.get(*i)), \"::\")\n+    str::connect(idents.map(|i| copy *token::interner_get(i.name)), \"::\")\n }\n \n-\n pub fn path_to_ident(p: @Path) -> ident { copy *p.idents.last() }\n \n pub fn local_def(id: node_id) -> def_id {\n@@ -620,16 +621,22 @@ pub enum Privacy {\n \n // HYGIENE FUNCTIONS\n \n-/// Construct an identifier with the given repr and an empty context:\n-pub fn new_ident(repr: uint) -> ident { ident {repr: repr, ctxt: 0}}\n+/// Construct an identifier with the given name and an empty context:\n+pub fn new_ident(name: Name) -> ident { ident {name: name, ctxt: 0}}\n \n /// Extend a syntax context with a given mark\n-pub fn new_mark (m:Mrk, tail:SyntaxContext,table:&mut SCTable)\n+pub fn new_mark(m:Mrk, tail:SyntaxContext) -> SyntaxContext {\n+    new_mark_internal(m,tail,get_sctable())\n+}\n+\n+// Extend a syntax context with a given mark and table\n+// FIXME #4536 : currently pub to allow testing\n+pub fn new_mark_internal(m:Mrk, tail:SyntaxContext,table:&mut SCTable)\n     -> SyntaxContext {\n     let key = (tail,m);\n     // FIXME #5074 : can't use more natural style because we're missing\n     // flow-sensitivity. Results in two lookups on a hash table hit.\n-    // also applies to new_rename, below.\n+    // also applies to new_rename_internal, below.\n     // let try_lookup = table.mark_memo.find(&key);\n     match table.mark_memo.contains_key(&key) {\n         false => {\n@@ -647,7 +654,13 @@ pub fn new_mark (m:Mrk, tail:SyntaxContext,table:&mut SCTable)\n }\n \n /// Extend a syntax context with a given rename\n-pub fn new_rename (id:ident, to:Name, tail:SyntaxContext, table: &mut SCTable)\n+pub fn new_rename(id:ident, to:Name, tail:SyntaxContext) -> SyntaxContext {\n+    new_rename_internal(id, to, tail, get_sctable())\n+}\n+\n+// Extend a syntax context with a given rename and sctable\n+// FIXME #4536 : currently pub to allow testing\n+pub fn new_rename_internal(id:ident, to:Name, tail:SyntaxContext, table: &mut SCTable)\n     -> SyntaxContext {\n     let key = (tail,id,to);\n     // FIXME #5074\n@@ -669,34 +682,58 @@ pub fn new_rename (id:ident, to:Name, tail:SyntaxContext, table: &mut SCTable)\n \n /// Make a fresh syntax context table with EmptyCtxt in slot zero\n /// and IllegalCtxt in slot one.\n-pub fn new_sctable() -> SCTable {\n+// FIXME #4536 : currently pub to allow testing\n+pub fn new_sctable_internal() -> SCTable {\n     SCTable {\n         table: ~[EmptyCtxt,IllegalCtxt],\n         mark_memo: HashMap::new(),\n         rename_memo: HashMap::new()\n     }\n }\n \n+// fetch the SCTable from TLS, create one if it doesn't yet exist.\n+pub fn get_sctable() -> @mut SCTable {\n+    unsafe {\n+        let sctable_key = (cast::transmute::<(uint, uint),\n+                           &fn(v: @@mut SCTable)>(\n+                               (-4 as uint, 0u)));\n+        match local_data::local_data_get(sctable_key) {\n+            None => {\n+                let new_table = @@mut new_sctable_internal();\n+                local_data::local_data_set(sctable_key,new_table);\n+                *new_table\n+            },\n+            Some(intr) => *intr\n+        }\n+    }\n+}\n+\n /// Add a value to the end of a vec, return its index\n fn idx_push<T>(vec: &mut ~[T], val: T) -> uint {\n     vec.push(val);\n     vec.len() - 1\n }\n \n /// Resolve a syntax object to a name, per MTWT.\n-pub fn resolve (id : ident, table : &mut SCTable) -> Name {\n+pub fn resolve(id : ident) -> Name {\n+    resolve_internal(id, get_sctable())\n+}\n+\n+// Resolve a syntax object to a name, per MTWT.\n+// FIXME #4536 : currently pub to allow testing\n+pub fn resolve_internal(id : ident, table : &mut SCTable) -> Name {\n     match table.table[id.ctxt] {\n-        EmptyCtxt => id.repr,\n+        EmptyCtxt => id.name,\n         // ignore marks here:\n-        Mark(_,subctxt) => resolve (ident{repr:id.repr, ctxt: subctxt},table),\n+        Mark(_,subctxt) => resolve_internal(ident{name:id.name, ctxt: subctxt},table),\n         // do the rename if necessary:\n-        Rename(ident{repr,ctxt},toname,subctxt) => {\n+        Rename(ident{name,ctxt},toname,subctxt) => {\n             // this could be cached or computed eagerly:\n-            let resolvedfrom = resolve(ident{repr:repr,ctxt:ctxt},table);\n-            let resolvedthis = resolve(ident{repr:id.repr,ctxt:subctxt},table);\n+            let resolvedfrom = resolve_internal(ident{name:name,ctxt:ctxt},table);\n+            let resolvedthis = resolve_internal(ident{name:id.name,ctxt:subctxt},table);\n             if ((resolvedthis == resolvedfrom)\n-                && (marksof (ctxt,resolvedthis,table)\n-                    == marksof (subctxt,resolvedthis,table))) {\n+                && (marksof(ctxt,resolvedthis,table)\n+                    == marksof(subctxt,resolvedthis,table))) {\n                 toname\n             } else {\n                 resolvedthis\n@@ -777,11 +814,11 @@ mod test {\n     // convert a list of uints to an @~[ident]\n     // (ignores the interner completely)\n     fn uints_to_idents (uints: &~[uint]) -> @~[ident] {\n-        @uints.map(|u|{ ident {repr:*u, ctxt: empty_ctxt} })\n+        @uints.map(|u|{ ident {name:*u, ctxt: empty_ctxt} })\n     }\n \n     fn id (u : uint, s: SyntaxContext) -> ident {\n-        ident{repr:u, ctxt: s}\n+        ident{name:u, ctxt: s}\n     }\n \n     // because of the SCTable, I now need a tidy way of\n@@ -798,8 +835,8 @@ mod test {\n         -> SyntaxContext {\n         tscs.foldr(tail, |tsc : &TestSC,tail : SyntaxContext|\n                   {match *tsc {\n-                      M(mrk) => new_mark(mrk,tail,table),\n-                      R(ident,name) => new_rename(ident,name,tail,table)}})\n+                      M(mrk) => new_mark_internal(mrk,tail,table),\n+                      R(ident,name) => new_rename_internal(ident,name,tail,table)}})\n     }\n \n     // gather a SyntaxContext back into a vector of TestSCs\n@@ -824,7 +861,7 @@ mod test {\n     }\n \n     #[test] fn test_unfold_refold(){\n-        let mut t = new_sctable();\n+        let mut t = new_sctable_internal();\n \n         let test_sc = ~[M(3),R(id(101,0),14),M(9)];\n         assert_eq!(unfold_test_sc(copy test_sc,empty_ctxt,&mut t),4);\n@@ -838,11 +875,11 @@ mod test {\n     // in a vector. v[0] will be the outermost mark.\n     fn unfold_marks(mrks:~[Mrk],tail:SyntaxContext,table: &mut SCTable) -> SyntaxContext {\n         mrks.foldr(tail, |mrk:&Mrk,tail:SyntaxContext|\n-                   {new_mark(*mrk,tail,table)})\n+                   {new_mark_internal(*mrk,tail,table)})\n     }\n \n     #[test] fn unfold_marks_test() {\n-        let mut t = new_sctable();\n+        let mut t = new_sctable_internal();\n \n         assert_eq!(unfold_marks(~[3,7],empty_ctxt,&mut t),3);\n         assert_eq!(t.table[2],Mark(7,0));\n@@ -852,7 +889,7 @@ mod test {\n     #[test] fn test_marksof () {\n         let stopname = 242;\n         let name1 = 243;\n-        let mut t = new_sctable();\n+        let mut t = new_sctable_internal();\n         assert_eq!(marksof (empty_ctxt,stopname,&t),~[]);\n         // FIXME #5074: ANF'd to dodge nested calls\n         { let ans = unfold_marks(~[4,98],empty_ctxt,&mut t);\n@@ -866,13 +903,13 @@ mod test {\n         // rename where stop doesn't match:\n         { let chain = ~[M(9),\n                         R(id(name1,\n-                             new_mark (4, empty_ctxt,&mut t)),\n+                             new_mark_internal (4, empty_ctxt,&mut t)),\n                           100101102),\n                         M(14)];\n          let ans = unfold_test_sc(chain,empty_ctxt,&mut t);\n          assert_eq! (marksof (ans, stopname, &t), ~[9,14]);}\n         // rename where stop does match\n-        { let name1sc = new_mark(4, empty_ctxt, &mut t);\n+        { let name1sc = new_mark_internal(4, empty_ctxt, &mut t);\n          let chain = ~[M(9),\n                        R(id(name1, name1sc),\n                          stopname),\n@@ -884,59 +921,59 @@ mod test {\n \n     #[test] fn resolve_tests () {\n         let a = 40;\n-        let mut t = new_sctable();\n+        let mut t = new_sctable_internal();\n         // - ctxt is MT\n-        assert_eq!(resolve(id(a,empty_ctxt),&mut t),a);\n+        assert_eq!(resolve_internal(id(a,empty_ctxt),&mut t),a);\n         // - simple ignored marks\n         { let sc = unfold_marks(~[1,2,3],empty_ctxt,&mut t);\n-         assert_eq!(resolve(id(a,sc),&mut t),a);}\n+         assert_eq!(resolve_internal(id(a,sc),&mut t),a);}\n         // - orthogonal rename where names don't match\n         { let sc = unfold_test_sc(~[R(id(50,empty_ctxt),51),M(12)],empty_ctxt,&mut t);\n-         assert_eq!(resolve(id(a,sc),&mut t),a);}\n+         assert_eq!(resolve_internal(id(a,sc),&mut t),a);}\n         // - rename where names do match, but marks don't\n-        { let sc1 = new_mark(1,empty_ctxt,&mut t);\n+        { let sc1 = new_mark_internal(1,empty_ctxt,&mut t);\n          let sc = unfold_test_sc(~[R(id(a,sc1),50),\n                                    M(1),\n                                    M(2)],\n                                  empty_ctxt,&mut t);\n-        assert_eq!(resolve(id(a,sc),&mut t), a);}\n+        assert_eq!(resolve_internal(id(a,sc),&mut t), a);}\n         // - rename where names and marks match\n         { let sc1 = unfold_test_sc(~[M(1),M(2)],empty_ctxt,&mut t);\n          let sc = unfold_test_sc(~[R(id(a,sc1),50),M(1),M(2)],empty_ctxt,&mut t);\n-         assert_eq!(resolve(id(a,sc),&mut t), 50); }\n+         assert_eq!(resolve_internal(id(a,sc),&mut t), 50); }\n         // - rename where names and marks match by literal sharing\n         { let sc1 = unfold_test_sc(~[M(1),M(2)],empty_ctxt,&mut t);\n          let sc = unfold_test_sc(~[R(id(a,sc1),50)],sc1,&mut t);\n-         assert_eq!(resolve(id(a,sc),&mut t), 50); }\n+         assert_eq!(resolve_internal(id(a,sc),&mut t), 50); }\n         // - two renames of the same var.. can only happen if you use\n         // local-expand to prevent the inner binding from being renamed\n         // during the rename-pass caused by the first:\n         io::println(\"about to run bad test\");\n         { let sc = unfold_test_sc(~[R(id(a,empty_ctxt),50),\n                                     R(id(a,empty_ctxt),51)],\n                                   empty_ctxt,&mut t);\n-         assert_eq!(resolve(id(a,sc),&mut t), 51); }\n+         assert_eq!(resolve_internal(id(a,sc),&mut t), 51); }\n         // the simplest double-rename:\n-        { let a_to_a50 = new_rename(id(a,empty_ctxt),50,empty_ctxt,&mut t);\n-         let a50_to_a51 = new_rename(id(a,a_to_a50),51,a_to_a50,&mut t);\n-         assert_eq!(resolve(id(a,a50_to_a51),&mut t),51);\n+        { let a_to_a50 = new_rename_internal(id(a,empty_ctxt),50,empty_ctxt,&mut t);\n+         let a50_to_a51 = new_rename_internal(id(a,a_to_a50),51,a_to_a50,&mut t);\n+         assert_eq!(resolve_internal(id(a,a50_to_a51),&mut t),51);\n          // mark on the outside doesn't stop rename:\n-         let sc = new_mark(9,a50_to_a51,&mut t);\n-         assert_eq!(resolve(id(a,sc),&mut t),51);\n+         let sc = new_mark_internal(9,a50_to_a51,&mut t);\n+         assert_eq!(resolve_internal(id(a,sc),&mut t),51);\n          // but mark on the inside does:\n          let a50_to_a51_b = unfold_test_sc(~[R(id(a,a_to_a50),51),\n                                               M(9)],\n                                            a_to_a50,\n                                            &mut t);\n-         assert_eq!(resolve(id(a,a50_to_a51_b),&mut t),50);}\n+         assert_eq!(resolve_internal(id(a,a50_to_a51_b),&mut t),50);}\n     }\n \n     #[test] fn hashing_tests () {\n-        let mut t = new_sctable();\n-        assert_eq!(new_mark(12,empty_ctxt,&mut t),2);\n-        assert_eq!(new_mark(13,empty_ctxt,&mut t),3);\n+        let mut t = new_sctable_internal();\n+        assert_eq!(new_mark_internal(12,empty_ctxt,&mut t),2);\n+        assert_eq!(new_mark_internal(13,empty_ctxt,&mut t),3);\n         // using the same one again should result in the same index:\n-        assert_eq!(new_mark(12,empty_ctxt,&mut t),2);\n+        assert_eq!(new_mark_internal(12,empty_ctxt,&mut t),2);\n         // I'm assuming that the rename table will behave the same....\n     }\n "}, {"sha": "a3432a00edc03f8b265f33ba54229ca072420df4", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 95, "deletions": 44, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/0409f8610612e8261a0139ec9c57396089cea060/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0409f8610612e8261a0139ec9c57396089cea060/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=0409f8610612e8261a0139ec9c57396089cea060", "patch": "@@ -11,13 +11,15 @@\n use core::prelude::*;\n \n use ast;\n+use ast::Name;\n use codemap;\n use codemap::{CodeMap, span, ExpnInfo, ExpandedFrom};\n use codemap::CallInfo;\n use diagnostic::span_handler;\n use ext;\n use parse;\n use parse::token;\n+use parse::token::{ident_to_str, intern, str_to_ident};\n \n use core::hashmap::HashMap;\n use core::vec;\n@@ -91,29 +93,33 @@ pub enum SyntaxExtension {\n     IdentTT(SyntaxExpanderTTItem),\n }\n \n+// The SyntaxEnv is the environment that's threaded through the expansion\n+// of macros. It contains bindings for macros, and also a special binding\n+// for \" block\" (not a legal identifier) that maps to a BlockInfo\n pub type SyntaxEnv = @mut MapChain<Name, Transformer>;\n \n-// Name : the domain of SyntaxEnvs\n-// want to change these to uints....\n-// note that we use certain strings that are not legal as identifiers\n-// to indicate, for instance, how blocks are supposed to behave.\n-type Name = @~str;\n-\n // Transformer : the codomain of SyntaxEnvs\n \n-// NB: it may seem crazy to lump both of these into one environment;\n-// what would it mean to bind \"foo\" to BlockLimit(true)? The idea\n-// is that this follows the lead of MTWT, and accommodates growth\n-// toward a more uniform syntax syntax (sorry) where blocks are just\n-// another kind of transformer.\n-\n pub enum Transformer {\n     // this identifier maps to a syntax extension or macro\n     SE(SyntaxExtension),\n-    // should blocks occurring here limit macro scopes?\n-    ScopeMacros(bool)\n+    // blockinfo : this is ... well, it's simpler than threading\n+    // another whole data stack-structured data structure through\n+    // expansion. Basically, there's an invariant that every\n+    // map must contain a binding for \" block\".\n+    BlockInfo(BlockInfo)\n+}\n+\n+pub struct BlockInfo {\n+    // should macros escape from this scope?\n+    macros_escape : bool,\n+    // what are the pending renames?\n+    pending_renames : @mut RenameList\n }\n \n+// a list of ident->name renamings\n+type RenameList = ~[(ast::ident,Name)];\n+\n // The base map of methods for expanding syntax extension\n // AST nodes into full ASTs\n pub fn syntax_expander_table() -> SyntaxEnv {\n@@ -127,77 +133,80 @@ pub fn syntax_expander_table() -> SyntaxEnv {\n     }\n     let mut syntax_expanders = HashMap::new();\n     // NB identifier starts with space, and can't conflict with legal idents\n-    syntax_expanders.insert(@~\" block\",\n-                            @ScopeMacros(true));\n-    syntax_expanders.insert(@~\"macro_rules\",\n+    syntax_expanders.insert(intern(&\" block\"),\n+                            @BlockInfo(BlockInfo{\n+                                macros_escape : false,\n+                                pending_renames : @mut ~[]\n+                            }));\n+    syntax_expanders.insert(intern(&\"macro_rules\"),\n                             builtin_item_tt(\n                                 ext::tt::macro_rules::add_new_extension));\n-    syntax_expanders.insert(@~\"fmt\",\n+    syntax_expanders.insert(intern(&\"fmt\"),\n                             builtin_normal_tt(ext::fmt::expand_syntax_ext));\n     syntax_expanders.insert(\n-        @~\"auto_encode\",\n+        intern(&\"auto_encode\"),\n         @SE(ItemDecorator(ext::auto_encode::expand_auto_encode)));\n     syntax_expanders.insert(\n-        @~\"auto_decode\",\n+        intern(&\"auto_decode\"),\n         @SE(ItemDecorator(ext::auto_encode::expand_auto_decode)));\n-    syntax_expanders.insert(@~\"env\",\n+    syntax_expanders.insert(intern(&\"env\"),\n                             builtin_normal_tt(ext::env::expand_syntax_ext));\n-    syntax_expanders.insert(@~\"bytes\",\n+    syntax_expanders.insert(intern(\"bytes\"),\n                             builtin_normal_tt(ext::bytes::expand_syntax_ext));\n-    syntax_expanders.insert(@~\"concat_idents\",\n+    syntax_expanders.insert(intern(\"concat_idents\"),\n                             builtin_normal_tt(\n                                 ext::concat_idents::expand_syntax_ext));\n-    syntax_expanders.insert(@~\"log_syntax\",\n+    syntax_expanders.insert(intern(&\"log_syntax\"),\n                             builtin_normal_tt(\n                                 ext::log_syntax::expand_syntax_ext));\n-    syntax_expanders.insert(@~\"deriving\",\n+    syntax_expanders.insert(intern(&\"deriving\"),\n                             @SE(ItemDecorator(\n                                 ext::deriving::expand_meta_deriving)));\n \n     // Quasi-quoting expanders\n-    syntax_expanders.insert(@~\"quote_tokens\",\n+    syntax_expanders.insert(intern(&\"quote_tokens\"),\n                        builtin_normal_tt(ext::quote::expand_quote_tokens));\n-    syntax_expanders.insert(@~\"quote_expr\",\n+    syntax_expanders.insert(intern(&\"quote_expr\"),\n                        builtin_normal_tt(ext::quote::expand_quote_expr));\n-    syntax_expanders.insert(@~\"quote_ty\",\n+    syntax_expanders.insert(intern(&\"quote_ty\"),\n                        builtin_normal_tt(ext::quote::expand_quote_ty));\n-    syntax_expanders.insert(@~\"quote_item\",\n+    syntax_expanders.insert(intern(&\"quote_item\"),\n                        builtin_normal_tt(ext::quote::expand_quote_item));\n-    syntax_expanders.insert(@~\"quote_pat\",\n+    syntax_expanders.insert(intern(&\"quote_pat\"),\n                        builtin_normal_tt(ext::quote::expand_quote_pat));\n-    syntax_expanders.insert(@~\"quote_stmt\",\n+    syntax_expanders.insert(intern(&\"quote_stmt\"),\n                        builtin_normal_tt(ext::quote::expand_quote_stmt));\n \n-    syntax_expanders.insert(@~\"line\",\n+    syntax_expanders.insert(intern(&\"line\"),\n                             builtin_normal_tt(\n                                 ext::source_util::expand_line));\n-    syntax_expanders.insert(@~\"col\",\n+    syntax_expanders.insert(intern(&\"col\"),\n                             builtin_normal_tt(\n                                 ext::source_util::expand_col));\n-    syntax_expanders.insert(@~\"file\",\n+    syntax_expanders.insert(intern(&\"file\"),\n                             builtin_normal_tt(\n                                 ext::source_util::expand_file));\n-    syntax_expanders.insert(@~\"stringify\",\n+    syntax_expanders.insert(intern(&\"stringify\"),\n                             builtin_normal_tt(\n                                 ext::source_util::expand_stringify));\n-    syntax_expanders.insert(@~\"include\",\n+    syntax_expanders.insert(intern(&\"include\"),\n                             builtin_normal_tt(\n                                 ext::source_util::expand_include));\n-    syntax_expanders.insert(@~\"include_str\",\n+    syntax_expanders.insert(intern(&\"include_str\"),\n                             builtin_normal_tt(\n                                 ext::source_util::expand_include_str));\n-    syntax_expanders.insert(@~\"include_bin\",\n+    syntax_expanders.insert(intern(&\"include_bin\"),\n                             builtin_normal_tt(\n                                 ext::source_util::expand_include_bin));\n-    syntax_expanders.insert(@~\"module_path\",\n+    syntax_expanders.insert(intern(&\"module_path\"),\n                             builtin_normal_tt(\n                                 ext::source_util::expand_mod));\n-    syntax_expanders.insert(@~\"proto\",\n+    syntax_expanders.insert(intern(&\"proto\"),\n                             builtin_item_tt(ext::pipes::expand_proto));\n-    syntax_expanders.insert(@~\"asm\",\n+    syntax_expanders.insert(intern(&\"asm\"),\n                             builtin_normal_tt(ext::asm::expand_asm));\n     syntax_expanders.insert(\n-        @~\"trace_macros\",\n+        intern(&\"trace_macros\"),\n         builtin_normal_tt(ext::trace_macros::expand_trace_macros));\n     MapChain::new(~syntax_expanders)\n }\n@@ -301,10 +310,10 @@ impl ExtCtxt {\n         *self.trace_mac = x\n     }\n     pub fn str_of(&self, id: ast::ident) -> ~str {\n-        copy *self.parse_sess.interner.get(id)\n+        copy *ident_to_str(&id)\n     }\n     pub fn ident_of(&self, st: &str) -> ast::ident {\n-        self.parse_sess.interner.intern(st)\n+        str_to_ident(st)\n     }\n }\n \n@@ -470,6 +479,15 @@ impl <K: Eq + Hash + IterBytes ,V: Copy> MapChain<K,V>{\n         }\n     }\n \n+    fn find_in_topmost_frame(&self, key: &K) -> Option<@V> {\n+        let map = match *self {\n+            BaseMapChain(ref map) => map,\n+            ConsMapChain(ref map,_) => map\n+        };\n+        // strip one layer of indirection off the pointer.\n+        map.find(key).map(|r| {**r})\n+    }\n+\n     // insert the binding into the top-level map\n     fn insert (&mut self, key: K, ext: @V) -> bool {\n         // can't abstract over get_map because of flow sensitivity...\n@@ -478,7 +496,40 @@ impl <K: Eq + Hash + IterBytes ,V: Copy> MapChain<K,V>{\n             ConsMapChain (~ref mut map,_) => map.insert(key,ext)\n         }\n     }\n+    // insert the binding into the topmost frame for which the binding\n+    // associated with 'n' exists and satisfies pred\n+    // ... there are definitely some opportunities for abstraction\n+    // here that I'm ignoring. (e.g., manufacturing a predicate on\n+    // the maps in the chain, and using an abstract \"find\".\n+    fn insert_into_frame(&mut self, key: K, ext: @V, n: K, pred: &fn(&@V)->bool) {\n+        match *self {\n+            BaseMapChain (~ref mut map) => {\n+                if satisfies_pred(map,&n,pred) {\n+                    map.insert(key,ext);\n+                } else {\n+                    fail!(~\"expected map chain containing satisfying frame\")\n+                }\n+            },\n+            ConsMapChain (~ref mut map, rest) => {\n+                if satisfies_pred(map,&n,pred) {\n+                    map.insert(key,ext);\n+                } else {\n+                    rest.insert_into_frame(key,ext,n,pred)\n+                }\n+            }\n+        }\n+    }\n+}\n \n+// returns true if the binding for 'n' satisfies 'pred' in 'map'\n+fn satisfies_pred<K : Eq + Hash + IterBytes,V>(map : &mut HashMap<K,V>,\n+                                               n: &K,\n+                                               pred: &fn(&V)->bool)\n+    -> bool {\n+    match map.find(n) {\n+        Some(ref v) => (pred(*v)),\n+        None => false\n+    }\n }\n \n #[cfg(test)]"}, {"sha": "bfb234106b8b1256cfe14423cdaa0618f76d21e4", "filename": "src/libsyntax/ext/concat_idents.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0409f8610612e8261a0139ec9c57396089cea060/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0409f8610612e8261a0139ec9c57396089cea060/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fconcat_idents.rs?ref=0409f8610612e8261a0139ec9c57396089cea060", "patch": "@@ -15,6 +15,7 @@ use codemap::span;\n use ext::base::*;\n use ext::base;\n use parse::token;\n+use parse::token::{str_to_ident};\n \n pub fn expand_syntax_ext(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n     -> base::MacResult {\n@@ -33,7 +34,7 @@ pub fn expand_syntax_ext(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n             }\n         }\n     }\n-    let res = cx.parse_sess().interner.intern(res_str);\n+    let res = str_to_ident(res_str);\n \n     let e = @ast::expr {\n         id: cx.next_id(),"}, {"sha": "96a0461de1eb24781ffaa1c96f45ad3003f15913", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 158, "deletions": 95, "changes": 253, "blob_url": "https://github.com/rust-lang/rust/blob/0409f8610612e8261a0139ec9c57396089cea060/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0409f8610612e8261a0139ec9c57396089cea060/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=0409f8610612e8261a0139ec9c57396089cea060", "patch": "@@ -11,18 +11,21 @@\n use core::prelude::*;\n \n use ast::{blk_, attribute_, attr_outer, meta_word};\n-use ast::{crate, expr_, expr_mac, mac_invoc_tt};\n-use ast::{item_mac, stmt_, stmt_mac, stmt_expr, stmt_semi};\n+use ast::{crate, decl_local, expr_, expr_mac, mac_invoc_tt};\n+use ast::{item_mac, local_, stmt_, stmt_decl, stmt_mac, stmt_expr, stmt_semi};\n use ast::{SCTable, illegal_ctxt};\n use ast;\n-use ast_util::{new_rename, new_mark, resolve};\n+use ast_util::{new_rename, new_mark, resolve, get_sctable};\n use attr;\n use codemap;\n use codemap::{span, CallInfo, ExpandedFrom, NameAndSpan, spanned};\n use ext::base::*;\n use fold::*;\n use parse;\n use parse::{parse_item_from_source_str};\n+use parse::token::{ident_to_str, intern, fresh_name};\n+use visit;\n+use visit::{Visitor,mk_vt};\n \n use core::vec;\n \n@@ -46,15 +49,14 @@ pub fn expand_expr(extsbox: @mut SyntaxEnv,\n                             fmt!(\"expected macro name without module \\\n                                   separators\"));\n                     }\n-                    /* using idents and token::special_idents would make the\n-                    the macro names be hygienic */\n-                    let extname = cx.parse_sess().interner.get(pth.idents[0]);\n+                    let extname = &pth.idents[0];\n+                    let extnamestr = ident_to_str(extname);\n                     // leaving explicit deref here to highlight unbox op:\n-                    match (*extsbox).find(&extname) {\n+                    match (*extsbox).find(&extname.name) {\n                         None => {\n                             cx.span_fatal(\n                                 pth.span,\n-                                fmt!(\"macro undefined: '%s'\", *extname))\n+                                fmt!(\"macro undefined: '%s'\", *extnamestr))\n                         }\n                         Some(@SE(NormalTT(SyntaxExpanderTT{\n                             expander: exp,\n@@ -63,7 +65,7 @@ pub fn expand_expr(extsbox: @mut SyntaxEnv,\n                             cx.bt_push(ExpandedFrom(CallInfo {\n                                 call_site: s,\n                                 callee: NameAndSpan {\n-                                    name: copy *extname,\n+                                    name: copy *extnamestr,\n                                     span: exp_sp,\n                                 },\n                             }));\n@@ -76,7 +78,7 @@ pub fn expand_expr(extsbox: @mut SyntaxEnv,\n                                         pth.span,\n                                         fmt!(\n                                             \"non-expr macro in expr pos: %s\",\n-                                            *extname\n+                                            *extnamestr\n                                         )\n                                     )\n                                 }\n@@ -92,7 +94,7 @@ pub fn expand_expr(extsbox: @mut SyntaxEnv,\n                         _ => {\n                             cx.span_fatal(\n                                 pth.span,\n-                                fmt!(\"'%s' is not a tt-style macro\", *extname)\n+                                fmt!(\"'%s' is not a tt-style macro\", *extnamestr)\n                             )\n                         }\n                     }\n@@ -129,7 +131,7 @@ pub fn expand_mod_items(extsbox: @mut SyntaxEnv,\n         do vec::foldr(item.attrs, ~[*item]) |attr, items| {\n             let mname = attr::get_attr_name(attr);\n \n-            match (*extsbox).find(&mname) {\n+            match (*extsbox).find(&intern(*mname)) {\n               Some(@SE(ItemDecorator(dec_fn))) => {\n                   cx.bt_push(ExpandedFrom(CallInfo {\n                       call_site: attr.span,\n@@ -153,16 +155,20 @@ pub fn expand_mod_items(extsbox: @mut SyntaxEnv,\n \n // eval $e with a new exts frame:\n macro_rules! with_exts_frame (\n-    ($extsboxexpr:expr,$e:expr) =>\n+    ($extsboxexpr:expr,$macros_escape:expr,$e:expr) =>\n     ({let extsbox = $extsboxexpr;\n       let oldexts = *extsbox;\n       *extsbox = oldexts.push_frame();\n+      extsbox.insert(intern(special_block_name),\n+                     @BlockInfo(BlockInfo{macros_escape:$macros_escape,pending_renames:@mut ~[]}));\n       let result = $e;\n       *extsbox = oldexts;\n       result\n      })\n )\n \n+static special_block_name : &'static str = \" block\";\n+\n // When we enter a module, record it, for the sake of `module!`\n pub fn expand_item(extsbox: @mut SyntaxEnv,\n                    cx: @ExtCtxt,\n@@ -180,14 +186,8 @@ pub fn expand_item(extsbox: @mut SyntaxEnv,\n           match it.node {\n               ast::item_mod(_) | ast::item_foreign_mod(_) => {\n                   cx.mod_push(it.ident);\n-                  let result =\n-                      // don't push a macro scope for macro_escape:\n-                      if contains_macro_escape(it.attrs) {\n-                      orig(it,fld)\n-                  } else {\n-                      // otherwise, push a scope:\n-                      with_exts_frame!(extsbox,orig(it,fld))\n-                  };\n+                  let macro_escape = contains_macro_escape(it.attrs);\n+                  let result = with_exts_frame!(extsbox,macro_escape,orig(it,fld));\n                   cx.mod_pop();\n                   result\n               }\n@@ -203,31 +203,6 @@ pub fn contains_macro_escape (attrs: &[ast::attribute]) -> bool {\n     attrs.any(|attr| \"macro_escape\" == *attr::get_attr_name(attr))\n }\n \n-// this macro disables (one layer of) macro\n-// scoping, to allow a block to add macro bindings\n-// to its parent env\n-macro_rules! without_macro_scoping(\n-    ($extsexpr:expr,$exp:expr) =>\n-    ({\n-        // only evaluate this once:\n-        let exts = $extsexpr;\n-        // capture the existing binding:\n-        let existingBlockBinding =\n-            match exts.find(&@~\" block\"){\n-                Some(binding) => binding,\n-                None => cx.bug(\"expected to find \\\" block\\\" binding\")\n-            };\n-        // this prevents the block from limiting the macros' scope:\n-        exts.insert(@~\" block\",@ScopeMacros(false));\n-        let result = $exp;\n-        // reset the block binding. Note that since the original\n-        // one may have been inherited, this procedure may wind\n-        // up introducing a block binding where one didn't exist\n-        // before.\n-        exts.insert(@~\" block\",existingBlockBinding);\n-        result\n-    }))\n-\n // Support for item-position macro invocations, exactly the same\n // logic as for expression-position macro invocations.\n pub fn expand_item_mac(extsbox: @mut SyntaxEnv,\n@@ -241,22 +216,23 @@ pub fn expand_item_mac(extsbox: @mut SyntaxEnv,\n         _ => cx.span_bug(it.span, \"invalid item macro invocation\")\n     };\n \n-    let extname = cx.parse_sess().interner.get(pth.idents[0]);\n-    let expanded = match (*extsbox).find(&extname) {\n+    let extname = &pth.idents[0];\n+    let extnamestr = ident_to_str(extname);\n+    let expanded = match (*extsbox).find(&extname.name) {\n         None => cx.span_fatal(pth.span,\n-                              fmt!(\"macro undefined: '%s!'\", *extname)),\n+                              fmt!(\"macro undefined: '%s!'\", *extnamestr)),\n \n         Some(@SE(NormalTT(ref expand))) => {\n             if it.ident != parse::token::special_idents::invalid {\n                 cx.span_fatal(pth.span,\n                               fmt!(\"macro %s! expects no ident argument, \\\n-                                    given '%s'\", *extname,\n-                                   *cx.parse_sess().interner.get(it.ident)));\n+                                    given '%s'\", *extnamestr,\n+                                   *ident_to_str(&it.ident)));\n             }\n             cx.bt_push(ExpandedFrom(CallInfo {\n                 call_site: it.span,\n                 callee: NameAndSpan {\n-                    name: copy *extname,\n+                    name: copy *extnamestr,\n                     span: expand.span\n                 }\n             }));\n@@ -266,36 +242,53 @@ pub fn expand_item_mac(extsbox: @mut SyntaxEnv,\n             if it.ident == parse::token::special_idents::invalid {\n                 cx.span_fatal(pth.span,\n                               fmt!(\"macro %s! expects an ident argument\",\n-                                   *extname));\n+                                   *extnamestr));\n             }\n             cx.bt_push(ExpandedFrom(CallInfo {\n                 call_site: it.span,\n                 callee: NameAndSpan {\n-                    name: copy *extname,\n+                    name: copy *extnamestr,\n                     span: expand.span\n                 }\n             }));\n             ((*expand).expander)(cx, it.span, it.ident, tts)\n         }\n         _ => cx.span_fatal(\n-            it.span, fmt!(\"%s! is not legal in item position\", *extname))\n+            it.span, fmt!(\"%s! is not legal in item position\", *extnamestr))\n     };\n \n     let maybe_it = match expanded {\n         MRItem(it) => fld.fold_item(it),\n         MRExpr(_) => cx.span_fatal(pth.span,\n                                     ~\"expr macro in item position: \"\n-                                    + *extname),\n+                                    + *extnamestr),\n         MRAny(_, item_maker, _) => item_maker().chain(|i| {fld.fold_item(i)}),\n         MRDef(ref mdef) => {\n-            extsbox.insert(@/*bad*/ copy mdef.name, @SE((*mdef).ext));\n+            insert_macro(*extsbox,intern(mdef.name), @SE((*mdef).ext));\n             None\n         }\n     };\n     cx.bt_pop();\n     return maybe_it;\n }\n \n+\n+// insert a macro into the innermost frame that doesn't have the\n+// macro_escape tag.\n+fn insert_macro(exts: SyntaxEnv, name: ast::Name, transformer: @Transformer) {\n+    let is_non_escaping_block =\n+        |t : &@Transformer| -> bool{\n+        match t {\n+            &@BlockInfo(BlockInfo {macros_escape:false,_}) => true,\n+            &@BlockInfo(BlockInfo {_}) => false,\n+            _ => fail!(fmt!(\"special identifier %? was bound to a non-BlockInfo\",\n+                            special_block_name))\n+        }\n+    };\n+    exts.insert_into_frame(name,transformer,intern(special_block_name),\n+                           is_non_escaping_block)\n+}\n+\n // expand a stmt\n pub fn expand_stmt(extsbox: @mut SyntaxEnv,\n                    cx: @ExtCtxt,\n@@ -321,16 +314,17 @@ pub fn expand_stmt(extsbox: @mut SyntaxEnv,\n             fmt!(\"expected macro name without module \\\n                   separators\"));\n     }\n-    let extname = cx.parse_sess().interner.get(pth.idents[0]);\n-    let (fully_expanded, sp) = match (*extsbox).find(&extname) {\n+    let extname = &pth.idents[0];\n+    let extnamestr = ident_to_str(extname);\n+    let (fully_expanded, sp) = match (*extsbox).find(&extname.name) {\n         None =>\n-            cx.span_fatal(pth.span, fmt!(\"macro undefined: '%s'\", *extname)),\n+            cx.span_fatal(pth.span, fmt!(\"macro undefined: '%s'\", *extnamestr)),\n \n         Some(@SE(NormalTT(\n             SyntaxExpanderTT{expander: exp, span: exp_sp}))) => {\n             cx.bt_push(ExpandedFrom(CallInfo {\n                 call_site: sp,\n-                callee: NameAndSpan { name: copy *extname, span: exp_sp }\n+                callee: NameAndSpan { name: copy *extnamestr, span: exp_sp }\n             }));\n             let expanded = match exp(cx, mac.span, tts) {\n                 MRExpr(e) =>\n@@ -339,7 +333,7 @@ pub fn expand_stmt(extsbox: @mut SyntaxEnv,\n                 MRAny(_,_,stmt_mkr) => stmt_mkr(),\n                 _ => cx.span_fatal(\n                     pth.span,\n-                    fmt!(\"non-stmt macro in stmt pos: %s\", *extname))\n+                    fmt!(\"non-stmt macro in stmt pos: %s\", *extnamestr))\n             };\n \n             //keep going, outside-in\n@@ -360,7 +354,7 @@ pub fn expand_stmt(extsbox: @mut SyntaxEnv,\n \n         _ => {\n             cx.span_fatal(pth.span,\n-                          fmt!(\"'%s' is not a tt-style macro\", *extname))\n+                          fmt!(\"'%s' is not a tt-style macro\", *extnamestr))\n         }\n     };\n \n@@ -371,7 +365,33 @@ pub fn expand_stmt(extsbox: @mut SyntaxEnv,\n \n }\n \n-\n+// return a visitor that extracts the pat_ident paths\n+// from a given pattern and puts them in a mutable\n+// array (passed in to the traversal)\n+pub fn new_name_finder() -> @Visitor<@mut ~[ast::ident]> {\n+    let default_visitor = visit::default_visitor();\n+    @Visitor{\n+        visit_pat : |p:@ast::pat,ident_accum:@mut ~[ast::ident],v:visit::vt<@mut ~[ast::ident]>| {\n+            match *p {\n+                // we found a pat_ident!\n+                ast::pat{id:_, node: ast::pat_ident(_,path,ref inner), span:_} => {\n+                    match path {\n+                        // a path of length one:\n+                        @ast::Path{global: false,idents: [id], span:_,rp:_,types:_} =>\n+                        ident_accum.push(id),\n+                        // I believe these must be enums...\n+                        _ => ()\n+                    }\n+                    // visit optional subpattern of pat_ident:\n+                    for inner.each |subpat: &@ast::pat| { (v.visit_pat)(*subpat, ident_accum, v) }\n+                }\n+                // use the default traversal for non-pat_idents\n+                _ => visit::visit_pat(p,ident_accum,v)\n+            }\n+        },\n+        .. *default_visitor\n+    }\n+}\n \n pub fn expand_block(extsbox: @mut SyntaxEnv,\n                     cx: @ExtCtxt,\n@@ -380,21 +400,49 @@ pub fn expand_block(extsbox: @mut SyntaxEnv,\n                     fld: @ast_fold,\n                     orig: @fn(&blk_, span, @ast_fold) -> (blk_, span))\n                  -> (blk_, span) {\n-    match (*extsbox).find(&@~\" block\") {\n-        // no scope limit on macros in this block, no need\n-        // to push an exts frame:\n-        Some(@ScopeMacros(false)) => {\n-            orig (blk,sp,fld)\n-        },\n-        // this block should limit the scope of its macros:\n-        Some(@ScopeMacros(true)) => {\n-            // see note below about treatment of exts table\n-            with_exts_frame!(extsbox,orig(blk,sp,fld))\n+    // see note below about treatment of exts table\n+    with_exts_frame!(extsbox,false,orig(blk,sp,fld))\n+}\n+\n+\n+// get the (innermost) BlockInfo from an exts stack\n+fn get_block_info(exts : SyntaxEnv) -> BlockInfo {\n+    match exts.find_in_topmost_frame(&intern(special_block_name)) {\n+        Some(@BlockInfo(bi)) => bi,\n+        _ => fail!(fmt!(\"special identifier %? was bound to a non-BlockInfo\",\n+                       @~\" block\"))\n+    }\n+}\n+\n+\n+// given a mutable list of renames, return a tree-folder that applies those\n+// renames.\n+fn renames_to_fold(renames : @mut ~[(ast::ident,ast::Name)]) -> @ast_fold {\n+    let afp = default_ast_fold();\n+    let f_pre = @AstFoldFns {\n+        fold_ident: |id,_| {\n+            // the individual elements are memoized... it would\n+            // also be possible to memoize on the whole list at once.\n+            let new_ctxt = renames.foldl(id.ctxt,|ctxt,&(from,to)| {\n+                new_rename(from,to,*ctxt)\n+            });\n+            ast::ident{name:id.name,ctxt:new_ctxt}\n         },\n-        _ => cx.span_bug(sp, \"expected ScopeMacros binding for \\\" block\\\"\")\n+        .. *afp\n+    };\n+    make_fold(f_pre)\n+}\n+\n+// perform a bunch of renames\n+fn apply_pending_renames(folder : @ast_fold, stmt : ast::stmt) -> @ast::stmt {\n+    match folder.fold_stmt(&stmt) {\n+        Some(s) => s,\n+        None => fail!(fmt!(\"renaming of stmt produced None\"))\n     }\n }\n \n+\n+\n pub fn new_span(cx: @ExtCtxt, sp: span) -> span {\n     /* this discards information in the case of macro-defining macros */\n     return span {lo: sp.lo, hi: sp.hi, expn_info: cx.backtrace()};\n@@ -663,35 +711,33 @@ pub fn fun_to_ident_folder(f: @fn(ast::ident)->ast::ident) -> @ast_fold{\n \n // update the ctxts in a path to get a rename node\n pub fn new_ident_renamer(from: ast::ident,\n-                      to: ast::Name,\n-                      table: @mut SCTable) ->\n+                      to: ast::Name) ->\n     @fn(ast::ident)->ast::ident {\n     |id : ast::ident|\n     ast::ident{\n-        repr: id.repr,\n-        ctxt: new_rename(from,to,id.ctxt,table)\n+        name: id.name,\n+        ctxt: new_rename(from,to,id.ctxt)\n     }\n }\n \n \n // update the ctxts in a path to get a mark node\n-pub fn new_ident_marker(mark: uint,\n-                        table: @mut SCTable) ->\n+pub fn new_ident_marker(mark: uint) ->\n     @fn(ast::ident)->ast::ident {\n     |id : ast::ident|\n     ast::ident{\n-        repr: id.repr,\n-        ctxt: new_mark(mark,id.ctxt,table)\n+        name: id.name,\n+        ctxt: new_mark(mark,id.ctxt)\n     }\n }\n \n // perform resolution (in the MTWT sense) on all of the\n // idents in the tree. This is the final step in expansion.\n-pub fn new_ident_resolver(table: @mut SCTable) ->\n+pub fn new_ident_resolver() ->\n     @fn(ast::ident)->ast::ident {\n     |id : ast::ident|\n     ast::ident {\n-        repr : resolve(id,table),\n+        name : resolve(id),\n         ctxt : illegal_ctxt\n     }\n }\n@@ -702,13 +748,17 @@ mod test {\n     use super::*;\n     use ast;\n     use ast::{attribute_, attr_outer, meta_word, empty_ctxt};\n-    use ast_util::{new_sctable};\n+    use ast_util::{get_sctable};\n     use codemap;\n     use codemap::spanned;\n     use parse;\n+    use parse::token::{gensym, intern, get_ident_interner};\n+    use print::pprust;\n+    use util::parser_testing::{string_to_item, string_to_pat, strs_to_idents};\n+    use visit::{mk_vt,Visitor};\n+\n     use core::io;\n     use core::option::{None, Some};\n-    use util::parser_testing::{string_to_item_and_sess};\n \n     // make sure that fail! is present\n     #[test] fn fail_exists_test () {\n@@ -812,20 +862,33 @@ mod test {\n \n     #[test]\n     fn renaming () {\n-        let (maybe_item_ast,sess) = string_to_item_and_sess(@~\"fn a() -> int { let b = 13; b} \");\n+        let maybe_item_ast = string_to_item(@~\"fn a() -> int { let b = 13; b }\");\n         let item_ast = match maybe_item_ast {\n             Some(x) => x,\n             None => fail!(\"test case fail\")\n         };\n-        let table = @mut new_sctable();\n-        let a_name = 100; // enforced by testing_interner\n-        let a2_name = sess.interner.gensym(\"a2\").repr;\n-        let renamer = new_ident_renamer(ast::ident{repr:a_name,ctxt:empty_ctxt},\n-                                        a2_name,table);\n+        let a_name = intern(\"a\");\n+        let a2_name = intern(\"a2\");\n+        let renamer = new_ident_renamer(ast::ident{name:a_name,ctxt:empty_ctxt},\n+                                        a2_name);\n         let renamed_ast = fun_to_ident_folder(renamer).fold_item(item_ast).get();\n-        let resolver = new_ident_resolver(table);\n+        let resolver = new_ident_resolver();\n         let resolved_ast = fun_to_ident_folder(resolver).fold_item(renamed_ast).get();\n-        io::print(fmt!(\"ast: %?\\n\",resolved_ast))\n+        let resolved_as_str = pprust::item_to_str(resolved_ast,\n+                                                  get_ident_interner());\n+        assert_eq!(resolved_as_str,~\"fn a2() -> int { let b = 13; b }\");\n+\n+\n     }\n \n+    // sigh... it looks like I have two different renaming mechanisms, now...\n+\n+    #[test]\n+    fn pat_idents(){\n+        let pat = string_to_pat(@~\"(a,Foo{x:c @ (b,9),y:Bar(4,d)})\");\n+        let pat_idents = new_name_finder();\n+        let idents = @mut ~[];\n+        ((*pat_idents).visit_pat)(pat,idents, mk_vt(pat_idents));\n+        assert_eq!(idents,@mut strs_to_idents(~[\"a\",\"c\",\"b\",\"d\"]));\n+    }\n }"}, {"sha": "67d3f84d1ff3e7b7e3956456f560aa2bf3297979", "filename": "src/libsyntax/ext/fmt.rs", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/0409f8610612e8261a0139ec9c57396089cea060/src%2Flibsyntax%2Fext%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0409f8610612e8261a0139ec9c57396089cea060/src%2Flibsyntax%2Fext%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ffmt.rs?ref=0409f8610612e8261a0139ec9c57396089cea060", "patch": "@@ -25,6 +25,7 @@ use ext::build::AstBuilder;\n use core::option;\n use core::unstable::extfmt::ct::*;\n use core::vec;\n+use parse::token::{str_to_ident};\n \n pub fn expand_syntax_ext(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n     -> base::MacResult {\n@@ -53,12 +54,11 @@ fn pieces_to_expr(cx: @ExtCtxt, sp: span,\n                   pieces: ~[Piece], args: ~[@ast::expr])\n    -> @ast::expr {\n     fn make_path_vec(cx: @ExtCtxt, ident: &str) -> ~[ast::ident] {\n-        let intr = cx.parse_sess().interner;\n-        return ~[intr.intern(\"std\"),\n-                 intr.intern(\"unstable\"),\n-                 intr.intern(\"extfmt\"),\n-                 intr.intern(\"rt\"),\n-                 intr.intern(ident)];\n+        return ~[str_to_ident(\"std\"),\n+                 str_to_ident(\"unstable\"),\n+                 str_to_ident(\"extfmt\"),\n+                 str_to_ident(\"rt\"),\n+                 str_to_ident(ident)];\n     }\n     fn make_rt_path_expr(cx: @ExtCtxt, sp: span, nm: &str) -> @ast::expr {\n         let path = make_path_vec(cx, nm);\n@@ -112,15 +112,14 @@ fn pieces_to_expr(cx: @ExtCtxt, sp: span,\n         fn make_conv_struct(cx: @ExtCtxt, sp: span, flags_expr: @ast::expr,\n                          width_expr: @ast::expr, precision_expr: @ast::expr,\n                          ty_expr: @ast::expr) -> @ast::expr {\n-            let intr = cx.parse_sess().interner;\n             cx.expr_struct(\n                 sp,\n                 cx.path_global(sp, make_path_vec(cx, \"Conv\")),\n                 ~[\n-                    cx.field_imm(sp, intr.intern(\"flags\"), flags_expr),\n-                    cx.field_imm(sp, intr.intern(\"width\"), width_expr),\n-                    cx.field_imm(sp, intr.intern(\"precision\"), precision_expr),\n-                    cx.field_imm(sp, intr.intern(\"ty\"), ty_expr)\n+                    cx.field_imm(sp, str_to_ident(\"flags\"), flags_expr),\n+                    cx.field_imm(sp, str_to_ident(\"width\"), width_expr),\n+                    cx.field_imm(sp, str_to_ident(\"precision\"), precision_expr),\n+                    cx.field_imm(sp, str_to_ident(\"ty\"), ty_expr)\n                 ]\n             )\n         }\n@@ -255,11 +254,11 @@ fn pieces_to_expr(cx: @ExtCtxt, sp: span,\n     let nargs = args.len();\n \n     /* 'ident' is the local buffer building up the result of fmt! */\n-    let ident = cx.parse_sess().interner.intern(\"__fmtbuf\");\n+    let ident = str_to_ident(\"__fmtbuf\");\n     let buf = || cx.expr_ident(fmt_sp, ident);\n-    let core_ident = cx.parse_sess().interner.intern(\"std\");\n-    let str_ident = cx.parse_sess().interner.intern(\"str\");\n-    let push_ident = cx.parse_sess().interner.intern(\"push_str\");\n+    let core_ident = str_to_ident(\"std\");\n+    let str_ident = str_to_ident(\"str\");\n+    let push_ident = str_to_ident(\"push_str\");\n     let mut stms = ~[];\n \n     /* Translate each piece (portion of the fmt expression) by invoking the"}, {"sha": "3ad4f87083f3db0d1ba484fe18b255c92e3c0508", "filename": "src/libsyntax/ext/log_syntax.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0409f8610612e8261a0139ec9c57396089cea060/src%2Flibsyntax%2Fext%2Flog_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0409f8610612e8261a0139ec9c57396089cea060/src%2Flibsyntax%2Fext%2Flog_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Flog_syntax.rs?ref=0409f8610612e8261a0139ec9c57396089cea060", "patch": "@@ -15,6 +15,7 @@ use codemap;\n use ext::base::*;\n use ext::base;\n use print;\n+use parse::token::{get_ident_interner};\n \n use core::io;\n use core::vec;\n@@ -28,7 +29,7 @@ pub fn expand_syntax_ext(cx: @ExtCtxt,\n     io::stdout().write_line(\n         print::pprust::tt_to_str(\n             ast::tt_delim(vec::to_owned(tt)),\n-            cx.parse_sess().interner));\n+            get_ident_interner()));\n \n     //trivial expression\n     MRExpr(@ast::expr {"}, {"sha": "3f4b5ee54f1936e0bbeb14f328f65f940c7212f1", "filename": "src/libsyntax/ext/pipes/mod.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0409f8610612e8261a0139ec9c57396089cea060/src%2Flibsyntax%2Fext%2Fpipes%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0409f8610612e8261a0139ec9c57396089cea060/src%2Flibsyntax%2Fext%2Fpipes%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fmod.rs?ref=0409f8610612e8261a0139ec9c57396089cea060", "patch": "@@ -52,7 +52,6 @@ use ext::pipes::pipec::gen_init;\n use ext::pipes::proto::visit;\n use parse::lexer::{new_tt_reader, reader};\n use parse::parser::Parser;\n-\n use core::option::None;\n \n pub mod ast_builder;\n@@ -68,7 +67,6 @@ pub fn expand_proto(cx: @ExtCtxt, _sp: span, id: ast::ident,\n     let sess = cx.parse_sess();\n     let cfg = cx.cfg();\n     let tt_rdr = new_tt_reader(copy cx.parse_sess().span_diagnostic,\n-                               cx.parse_sess().interner,\n                                None,\n                                copy tt);\n     let rdr = tt_rdr as @reader;"}, {"sha": "a89fd26df4c8b07844d1fa1da8ec2480e4e5ab6f", "filename": "src/libsyntax/ext/pipes/parse_proto.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0409f8610612e8261a0139ec9c57396089cea060/src%2Flibsyntax%2Fext%2Fpipes%2Fparse_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0409f8610612e8261a0139ec9c57396089cea060/src%2Flibsyntax%2Fext%2Fpipes%2Fparse_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fparse_proto.rs?ref=0409f8610612e8261a0139ec9c57396089cea060", "patch": "@@ -17,6 +17,7 @@ use ext::pipes::proto::*;\n use parse::common::SeqSep;\n use parse::parser;\n use parse::token;\n+use parse::token::{interner_get};\n \n pub trait proto_parser {\n     fn parse_proto(&self, id: ~str) -> protocol;\n@@ -42,11 +43,11 @@ impl proto_parser for parser::Parser {\n \n     fn parse_state(&self, proto: protocol) {\n         let id = self.parse_ident();\n-        let name = copy *self.interner.get(id);\n+        let name = copy *interner_get(id.name);\n \n         self.expect(&token::COLON);\n         let dir = match copy *self.token {\n-            token::IDENT(n, _) => self.interner.get(n),\n+            token::IDENT(n, _) => interner_get(n.name),\n             _ => fail!()\n         };\n         self.bump();\n@@ -77,7 +78,7 @@ impl proto_parser for parser::Parser {\n     }\n \n     fn parse_message(&self, state: state) {\n-        let mname = copy *self.interner.get(self.parse_ident());\n+        let mname = copy *interner_get(self.parse_ident().name);\n \n         let args = if *self.token == token::LPAREN {\n             self.parse_unspanned_seq(\n@@ -96,7 +97,7 @@ impl proto_parser for parser::Parser {\n \n         let next = match *self.token {\n           token::IDENT(_, _) => {\n-            let name = copy *self.interner.get(self.parse_ident());\n+            let name = copy *interner_get(self.parse_ident().name);\n             let ntys = if *self.token == token::LT {\n                 self.parse_unspanned_seq(\n                     &token::LT,"}, {"sha": "1e5b3c3ee7eb4f8dedb15bbe7047d1201c7ef972", "filename": "src/libsyntax/ext/pipes/pipec.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0409f8610612e8261a0139ec9c57396089cea060/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0409f8610612e8261a0139ec9c57396089cea060/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs?ref=0409f8610612e8261a0139ec9c57396089cea060", "patch": "@@ -325,10 +325,10 @@ impl gen_init for protocol {\n \n         cx.parse_item(fmt!(\"pub fn init%s() -> (server::%s, client::%s)\\\n                             { pub use std::pipes::HasBuffer; %s }\",\n-                           start_state.generics.to_source(cx),\n-                           start_state.to_ty(cx).to_source(cx),\n-                           start_state.to_ty(cx).to_source(cx),\n-                           body.to_source(cx)))\n+                           start_state.generics.to_source(),\n+                           start_state.to_ty(cx).to_source(),\n+                           start_state.to_ty(cx).to_source(),\n+                           body.to_source()))\n     }\n \n     fn gen_buffer_init(&self, ext_cx: @ExtCtxt) -> @ast::expr {"}, {"sha": "062532afef8d63ad69f7b361201a0979bc40ae88", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 98, "deletions": 98, "changes": 196, "blob_url": "https://github.com/rust-lang/rust/blob/0409f8610612e8261a0139ec9c57396089cea060/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0409f8610612e8261a0139ec9c57396089cea060/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=0409f8610612e8261a0139ec9c57396089cea060", "patch": "@@ -63,142 +63,142 @@ pub mod rt {\n \n     trait ToSource : ToTokens {\n         // Takes a thing and generates a string containing rust code for it.\n-        pub fn to_source(cx: @ExtCtxt) -> ~str;\n+        pub fn to_source() -> ~str;\n \n         // If you can make source, you can definitely make tokens.\n         pub fn to_tokens(cx: @ExtCtxt) -> ~[token_tree] {\n-            cx.parse_tts(self.to_source(cx))\n+            cx.parse_tts(self.to_source())\n         }\n     }\n \n     */\n \n     pub trait ToSource {\n         // Takes a thing and generates a string containing rust code for it.\n-        pub fn to_source(&self, cx: @ExtCtxt) -> ~str;\n+        pub fn to_source(&self) -> ~str;\n     }\n \n     impl ToSource for ast::ident {\n-        fn to_source(&self, cx: @ExtCtxt) -> ~str {\n-            copy *cx.parse_sess().interner.get(*self)\n+        fn to_source(&self) -> ~str {\n+            copy *ident_to_str(self)\n         }\n     }\n \n     impl ToSource for @ast::item {\n-        fn to_source(&self, cx: @ExtCtxt) -> ~str {\n-            item_to_str(*self, cx.parse_sess().interner)\n+        fn to_source(&self) -> ~str {\n+            item_to_str(*self, get_ident_interner())\n         }\n     }\n \n     impl<'self> ToSource for &'self [@ast::item] {\n-        fn to_source(&self, cx: @ExtCtxt) -> ~str {\n-            str::connect(self.map(|i| i.to_source(cx)), \"\\n\\n\")\n+        fn to_source(&self) -> ~str {\n+            str::connect(self.map(|i| i.to_source()), ~\"\\n\\n\")\n         }\n     }\n \n     impl ToSource for @ast::Ty {\n-        fn to_source(&self, cx: @ExtCtxt) -> ~str {\n-            ty_to_str(*self, cx.parse_sess().interner)\n+        fn to_source(&self) -> ~str {\n+            ty_to_str(*self, get_ident_interner())\n         }\n     }\n \n     impl<'self> ToSource for &'self [@ast::Ty] {\n-        fn to_source(&self, cx: @ExtCtxt) -> ~str {\n-            str::connect(self.map(|i| i.to_source(cx)), \", \")\n+        fn to_source(&self) -> ~str {\n+            str::connect(self.map(|i| i.to_source()), ~\", \")\n         }\n     }\n \n     impl ToSource for Generics {\n-        fn to_source(&self, cx: @ExtCtxt) -> ~str {\n-            pprust::generics_to_str(self, cx.parse_sess().interner)\n+        fn to_source(&self) -> ~str {\n+            pprust::generics_to_str(self, get_ident_interner())\n         }\n     }\n \n     impl ToSource for @ast::expr {\n-        fn to_source(&self, cx: @ExtCtxt) -> ~str {\n-            pprust::expr_to_str(*self, cx.parse_sess().interner)\n+        fn to_source(&self) -> ~str {\n+            pprust::expr_to_str(*self, get_ident_interner())\n         }\n     }\n \n     impl ToSource for ast::blk {\n-        fn to_source(&self, cx: @ExtCtxt) -> ~str {\n-            pprust::block_to_str(self, cx.parse_sess().interner)\n+        fn to_source(&self) -> ~str {\n+            pprust::block_to_str(self, get_ident_interner())\n         }\n     }\n \n     impl<'self> ToSource for &'self str {\n-        fn to_source(&self, _cx: @ExtCtxt) -> ~str {\n+        fn to_source(&self) -> ~str {\n             let lit = dummy_spanned(ast::lit_str(@str::to_owned(*self)));\n             pprust::lit_to_str(@lit)\n         }\n     }\n \n     impl ToSource for int {\n-        fn to_source(&self, _cx: @ExtCtxt) -> ~str {\n+        fn to_source(&self) -> ~str {\n             let lit = dummy_spanned(ast::lit_int(*self as i64, ast::ty_i));\n             pprust::lit_to_str(@lit)\n         }\n     }\n \n     impl ToSource for i8 {\n-        fn to_source(&self, _cx: @ExtCtxt) -> ~str {\n+        fn to_source(&self) -> ~str {\n             let lit = dummy_spanned(ast::lit_int(*self as i64, ast::ty_i8));\n             pprust::lit_to_str(@lit)\n         }\n     }\n \n     impl ToSource for i16 {\n-        fn to_source(&self, _cx: @ExtCtxt) -> ~str {\n+        fn to_source(&self) -> ~str {\n             let lit = dummy_spanned(ast::lit_int(*self as i64, ast::ty_i16));\n             pprust::lit_to_str(@lit)\n         }\n     }\n \n \n     impl ToSource for i32 {\n-        fn to_source(&self, _cx: @ExtCtxt) -> ~str {\n+        fn to_source(&self) -> ~str {\n             let lit = dummy_spanned(ast::lit_int(*self as i64, ast::ty_i32));\n             pprust::lit_to_str(@lit)\n         }\n     }\n \n     impl ToSource for i64 {\n-        fn to_source(&self, _cx: @ExtCtxt) -> ~str {\n+        fn to_source(&self) -> ~str {\n             let lit = dummy_spanned(ast::lit_int(*self as i64, ast::ty_i64));\n             pprust::lit_to_str(@lit)\n         }\n     }\n \n     impl ToSource for uint {\n-        fn to_source(&self, _cx: @ExtCtxt) -> ~str {\n+        fn to_source(&self) -> ~str {\n             let lit = dummy_spanned(ast::lit_uint(*self as u64, ast::ty_u));\n             pprust::lit_to_str(@lit)\n         }\n     }\n \n     impl ToSource for u8 {\n-        fn to_source(&self, _cx: @ExtCtxt) -> ~str {\n+        fn to_source(&self) -> ~str {\n             let lit = dummy_spanned(ast::lit_uint(*self as u64, ast::ty_u8));\n             pprust::lit_to_str(@lit)\n         }\n     }\n \n     impl ToSource for u16 {\n-        fn to_source(&self, _cx: @ExtCtxt) -> ~str {\n+        fn to_source(&self) -> ~str {\n             let lit = dummy_spanned(ast::lit_uint(*self as u64, ast::ty_u16));\n             pprust::lit_to_str(@lit)\n         }\n     }\n \n     impl ToSource for u32 {\n-        fn to_source(&self, _cx: @ExtCtxt) -> ~str {\n+        fn to_source(&self) -> ~str {\n             let lit = dummy_spanned(ast::lit_uint(*self as u64, ast::ty_u32));\n             pprust::lit_to_str(@lit)\n         }\n     }\n \n     impl ToSource for u64 {\n-        fn to_source(&self, _cx: @ExtCtxt) -> ~str {\n+        fn to_source(&self) -> ~str {\n             let lit = dummy_spanned(ast::lit_uint(*self as u64, ast::ty_u64));\n             pprust::lit_to_str(@lit)\n         }\n@@ -208,115 +208,115 @@ pub mod rt {\n \n     impl ToTokens for ast::ident {\n         fn to_tokens(&self, cx: @ExtCtxt) -> ~[token_tree] {\n-            cx.parse_tts(self.to_source(cx))\n+            cx.parse_tts(self.to_source())\n         }\n     }\n \n     impl ToTokens for @ast::item {\n         fn to_tokens(&self, cx: @ExtCtxt) -> ~[token_tree] {\n-            cx.parse_tts(self.to_source(cx))\n+            cx.parse_tts(self.to_source())\n         }\n     }\n \n     impl<'self> ToTokens for &'self [@ast::item] {\n         fn to_tokens(&self, cx: @ExtCtxt) -> ~[token_tree] {\n-            cx.parse_tts(self.to_source(cx))\n+            cx.parse_tts(self.to_source())\n         }\n     }\n \n     impl ToTokens for @ast::Ty {\n         fn to_tokens(&self, cx: @ExtCtxt) -> ~[token_tree] {\n-            cx.parse_tts(self.to_source(cx))\n+            cx.parse_tts(self.to_source())\n         }\n     }\n \n     impl<'self> ToTokens for &'self [@ast::Ty] {\n         fn to_tokens(&self, cx: @ExtCtxt) -> ~[token_tree] {\n-            cx.parse_tts(self.to_source(cx))\n+            cx.parse_tts(self.to_source())\n         }\n     }\n \n     impl ToTokens for Generics {\n         fn to_tokens(&self, cx: @ExtCtxt) -> ~[token_tree] {\n-            cx.parse_tts(self.to_source(cx))\n+            cx.parse_tts(self.to_source())\n         }\n     }\n \n     impl ToTokens for @ast::expr {\n         fn to_tokens(&self, cx: @ExtCtxt) -> ~[token_tree] {\n-            cx.parse_tts(self.to_source(cx))\n+            cx.parse_tts(self.to_source())\n         }\n     }\n \n     impl ToTokens for ast::blk {\n         fn to_tokens(&self, cx: @ExtCtxt) -> ~[token_tree] {\n-            cx.parse_tts(self.to_source(cx))\n+            cx.parse_tts(self.to_source())\n         }\n     }\n \n     impl<'self> ToTokens for &'self str {\n         fn to_tokens(&self, cx: @ExtCtxt) -> ~[token_tree] {\n-            cx.parse_tts(self.to_source(cx))\n+            cx.parse_tts(self.to_source())\n         }\n     }\n \n     impl ToTokens for int {\n         fn to_tokens(&self, cx: @ExtCtxt) -> ~[token_tree] {\n-            cx.parse_tts(self.to_source(cx))\n+            cx.parse_tts(self.to_source())\n         }\n     }\n \n     impl ToTokens for i8 {\n         fn to_tokens(&self, cx: @ExtCtxt) -> ~[token_tree] {\n-            cx.parse_tts(self.to_source(cx))\n+            cx.parse_tts(self.to_source())\n         }\n     }\n \n     impl ToTokens for i16 {\n         fn to_tokens(&self, cx: @ExtCtxt) -> ~[token_tree] {\n-            cx.parse_tts(self.to_source(cx))\n+            cx.parse_tts(self.to_source())\n         }\n     }\n \n     impl ToTokens for i32 {\n         fn to_tokens(&self, cx: @ExtCtxt) -> ~[token_tree] {\n-            cx.parse_tts(self.to_source(cx))\n+            cx.parse_tts(self.to_source())\n         }\n     }\n \n     impl ToTokens for i64 {\n         fn to_tokens(&self, cx: @ExtCtxt) -> ~[token_tree] {\n-            cx.parse_tts(self.to_source(cx))\n+            cx.parse_tts(self.to_source())\n         }\n     }\n \n     impl ToTokens for uint {\n         fn to_tokens(&self, cx: @ExtCtxt) -> ~[token_tree] {\n-            cx.parse_tts(self.to_source(cx))\n+            cx.parse_tts(self.to_source())\n         }\n     }\n \n     impl ToTokens for u8 {\n         fn to_tokens(&self, cx: @ExtCtxt) -> ~[token_tree] {\n-            cx.parse_tts(self.to_source(cx))\n+            cx.parse_tts(self.to_source())\n         }\n     }\n \n     impl ToTokens for u16 {\n         fn to_tokens(&self, cx: @ExtCtxt) -> ~[token_tree] {\n-            cx.parse_tts(self.to_source(cx))\n+            cx.parse_tts(self.to_source())\n         }\n     }\n \n     impl ToTokens for u32 {\n         fn to_tokens(&self, cx: @ExtCtxt) -> ~[token_tree] {\n-            cx.parse_tts(self.to_source(cx))\n+            cx.parse_tts(self.to_source())\n         }\n     }\n \n     impl ToTokens for u64 {\n         fn to_tokens(&self, cx: @ExtCtxt) -> ~[token_tree] {\n-            cx.parse_tts(self.to_source(cx))\n+            cx.parse_tts(self.to_source())\n         }\n     }\n \n@@ -417,25 +417,25 @@ pub fn expand_quote_stmt(cx: @ExtCtxt,\n                                     ~[e_attrs], tts))\n }\n \n-fn ids_ext(cx: @ExtCtxt, strs: ~[~str]) -> ~[ast::ident] {\n-    strs.map(|str| cx.parse_sess().interner.intern(*str))\n+fn ids_ext(strs: ~[~str]) -> ~[ast::ident] {\n+    strs.map(|str| str_to_ident(*str))\n }\n \n-fn id_ext(cx: @ExtCtxt, str: &str) -> ast::ident {\n-    cx.parse_sess().interner.intern(str)\n+fn id_ext(str: &str) -> ast::ident {\n+    str_to_ident(str)\n }\n \n // Lift an ident to the expr that evaluates to that ident.\n fn mk_ident(cx: @ExtCtxt, sp: span, ident: ast::ident) -> @ast::expr {\n     let e_str = cx.expr_str(sp, cx.str_of(ident));\n     cx.expr_method_call(sp,\n-                        cx.expr_ident(sp, id_ext(cx, \"ext_cx\")),\n-                        id_ext(cx, \"ident_of\"),\n+                        cx.expr_ident(sp, id_ext(\"ext_cx\")),\n+                        id_ext(\"ident_of\"),\n                         ~[e_str])\n }\n \n fn mk_bytepos(cx: @ExtCtxt, sp: span, bpos: BytePos) -> @ast::expr {\n-    let path = id_ext(cx, \"BytePos\");\n+    let path = id_ext(\"BytePos\");\n     let arg = cx.expr_uint(sp, bpos.to_uint());\n     cx.expr_call_ident(sp, path, ~[arg])\n }\n@@ -453,20 +453,20 @@ fn mk_binop(cx: @ExtCtxt, sp: span, bop: token::binop) -> @ast::expr {\n         SHL => \"SHL\",\n         SHR => \"SHR\"\n     };\n-    cx.expr_ident(sp, id_ext(cx, name))\n+    cx.expr_ident(sp, id_ext(name))\n }\n \n fn mk_token(cx: @ExtCtxt, sp: span, tok: &token::Token) -> @ast::expr {\n \n     match *tok {\n         BINOP(binop) => {\n             return cx.expr_call_ident(sp,\n-                                      id_ext(cx, \"BINOP\"),\n+                                      id_ext(\"BINOP\"),\n                                       ~[mk_binop(cx, sp, binop)]);\n         }\n         BINOPEQ(binop) => {\n             return cx.expr_call_ident(sp,\n-                                      id_ext(cx, \"BINOPEQ\"),\n+                                      id_ext(\"BINOPEQ\"),\n                                       ~[mk_binop(cx, sp, binop)]);\n         }\n \n@@ -479,12 +479,12 @@ fn mk_token(cx: @ExtCtxt, sp: span, tok: &token::Token) -> @ast::expr {\n                 ast::ty_i32 => ~\"ty_i32\",\n                 ast::ty_i64 => ~\"ty_i64\"\n             };\n-            let e_ity = cx.expr_ident(sp, id_ext(cx, s_ity));\n+            let e_ity = cx.expr_ident(sp, id_ext(s_ity));\n \n             let e_i64 = cx.expr_lit(sp, ast::lit_int(i, ast::ty_i64));\n \n             return cx.expr_call_ident(sp,\n-                                      id_ext(cx, \"LIT_INT\"),\n+                                      id_ext(\"LIT_INT\"),\n                                       ~[e_i64, e_ity]);\n         }\n \n@@ -496,20 +496,20 @@ fn mk_token(cx: @ExtCtxt, sp: span, tok: &token::Token) -> @ast::expr {\n                 ast::ty_u32 => ~\"ty_u32\",\n                 ast::ty_u64 => ~\"ty_u64\"\n             };\n-            let e_uty = cx.expr_ident(sp, id_ext(cx, s_uty));\n+            let e_uty = cx.expr_ident(sp, id_ext(s_uty));\n \n             let e_u64 = cx.expr_lit(sp, ast::lit_uint(u, ast::ty_u64));\n \n             return cx.expr_call_ident(sp,\n-                                      id_ext(cx, \"LIT_UINT\"),\n+                                      id_ext(\"LIT_UINT\"),\n                                       ~[e_u64, e_uty]);\n         }\n \n         LIT_INT_UNSUFFIXED(i) => {\n             let e_i64 = cx.expr_lit(sp, ast::lit_int(i, ast::ty_i64));\n \n             return cx.expr_call_ident(sp,\n-                                      id_ext(cx, \"LIT_INT_UNSUFFIXED\"),\n+                                      id_ext(\"LIT_INT_UNSUFFIXED\"),\n                                       ~[e_i64]);\n         }\n \n@@ -519,37 +519,37 @@ fn mk_token(cx: @ExtCtxt, sp: span, tok: &token::Token) -> @ast::expr {\n                 ast::ty_f32 => ~\"ty_f32\",\n                 ast::ty_f64 => ~\"ty_f64\"\n             };\n-            let e_fty = cx.expr_ident(sp, id_ext(cx, s_fty));\n+            let e_fty = cx.expr_ident(sp, id_ext(s_fty));\n \n             let e_fident = mk_ident(cx, sp, fident);\n \n             return cx.expr_call_ident(sp,\n-                                      id_ext(cx, \"LIT_FLOAT\"),\n+                                      id_ext(\"LIT_FLOAT\"),\n                                       ~[e_fident, e_fty]);\n         }\n \n         LIT_STR(ident) => {\n             return cx.expr_call_ident(sp,\n-                                      id_ext(cx, \"LIT_STR\"),\n+                                      id_ext(\"LIT_STR\"),\n                                       ~[mk_ident(cx, sp, ident)]);\n         }\n \n         IDENT(ident, b) => {\n             return cx.expr_call_ident(sp,\n-                                      id_ext(cx, \"IDENT\"),\n+                                      id_ext(\"IDENT\"),\n                                       ~[mk_ident(cx, sp, ident),\n                                         cx.expr_bool(sp, b)]);\n         }\n \n         LIFETIME(ident) => {\n             return cx.expr_call_ident(sp,\n-                                      id_ext(cx, \"LIFETIME\"),\n+                                      id_ext(\"LIFETIME\"),\n                                       ~[mk_ident(cx, sp, ident)]);\n         }\n \n         DOC_COMMENT(ident) => {\n             return cx.expr_call_ident(sp,\n-                                      id_ext(cx, \"DOC_COMMENT\"),\n+                                      id_ext(\"DOC_COMMENT\"),\n                                       ~[mk_ident(cx, sp, ident)]);\n         }\n \n@@ -593,7 +593,7 @@ fn mk_token(cx: @ExtCtxt, sp: span, tok: &token::Token) -> @ast::expr {\n         EOF => \"EOF\",\n         _ => fail!()\n     };\n-    cx.expr_ident(sp, id_ext(cx, name))\n+    cx.expr_ident(sp, id_ext(name))\n }\n \n \n@@ -603,14 +603,14 @@ fn mk_tt(cx: @ExtCtxt, sp: span, tt: &ast::token_tree)\n     match *tt {\n \n         ast::tt_tok(sp, ref tok) => {\n-            let e_sp = cx.expr_ident(sp, id_ext(cx, \"sp\"));\n+            let e_sp = cx.expr_ident(sp, id_ext(\"sp\"));\n             let e_tok = cx.expr_call_ident(sp,\n-                                           id_ext(cx, \"tt_tok\"),\n+                                           id_ext(\"tt_tok\"),\n                                            ~[e_sp, mk_token(cx, sp, tok)]);\n             let e_push =\n                 cx.expr_method_call(sp,\n-                                    cx.expr_ident(sp, id_ext(cx, \"tt\")),\n-                                    id_ext(cx, \"push\"),\n+                                    cx.expr_ident(sp, id_ext(\"tt\")),\n+                                    id_ext(\"push\"),\n                                     ~[e_tok]);\n             ~[cx.stmt_expr(e_push)]\n         }\n@@ -625,13 +625,13 @@ fn mk_tt(cx: @ExtCtxt, sp: span, tt: &ast::token_tree)\n             let e_to_toks =\n                 cx.expr_method_call(sp,\n                                     cx.expr_ident(sp, ident),\n-                                    id_ext(cx, \"to_tokens\"),\n-                                    ~[cx.expr_ident(sp, id_ext(cx, \"ext_cx\"))]);\n+                                    id_ext(\"to_tokens\"),\n+                                    ~[cx.expr_ident(sp, id_ext(\"ext_cx\"))]);\n \n             let e_push =\n                 cx.expr_method_call(sp,\n-                                    cx.expr_ident(sp, id_ext(cx, \"tt\")),\n-                                    id_ext(cx, \"push_all_move\"),\n+                                    cx.expr_ident(sp, id_ext(\"tt\")),\n+                                    id_ext(\"push_all_move\"),\n                                     ~[e_to_toks]);\n \n             ~[cx.stmt_expr(e_push)]\n@@ -671,10 +671,10 @@ fn expand_tts(cx: @ExtCtxt,\n     // import the runtime module, followed by a tt-building expression.\n \n     let uses = ~[ cx.view_use_glob(sp, ast::public,\n-                                   ids_ext(cx, ~[~\"syntax\",\n-                                                 ~\"ext\",\n-                                                 ~\"quote\",\n-                                                 ~\"rt\"])) ];\n+                                   ids_ext(~[~\"syntax\",\n+                                             ~\"ext\",\n+                                             ~\"quote\",\n+                                             ~\"rt\"])) ];\n \n     // We also bind a single value, sp, to ext_cx.call_site()\n     //\n@@ -703,23 +703,23 @@ fn expand_tts(cx: @ExtCtxt,\n     // worth the hassle.\n \n     let e_sp = cx.expr_method_call(sp,\n-                                   cx.expr_ident(sp, id_ext(cx, \"ext_cx\")),\n-                                   id_ext(cx, \"call_site\"),\n+                                   cx.expr_ident(sp, id_ext(\"ext_cx\")),\n+                                   id_ext(\"call_site\"),\n                                    ~[]);\n \n     let stmt_let_sp = cx.stmt_let(sp, false,\n-                                  id_ext(cx, \"sp\"),\n+                                  id_ext(\"sp\"),\n                                   e_sp);\n \n     let stmt_let_tt = cx.stmt_let(sp, true,\n-                                  id_ext(cx, \"tt\"),\n+                                  id_ext(\"tt\"),\n                                   cx.expr_vec_uniq(sp, ~[]));\n \n     cx.expr_blk(\n         cx.blk_all(sp, uses,\n                    ~[stmt_let_sp,\n                      stmt_let_tt] + mk_tts(cx, sp, tts),\n-                   Some(cx.expr_ident(sp, id_ext(cx, \"tt\")))))\n+                   Some(cx.expr_ident(sp, id_ext(\"tt\")))))\n }\n \n fn expand_parse_call(cx: @ExtCtxt,\n@@ -730,25 +730,25 @@ fn expand_parse_call(cx: @ExtCtxt,\n     let tts_expr = expand_tts(cx, sp, tts);\n \n     let cfg_call = || cx.expr_method_call(\n-        sp, cx.expr_ident(sp, id_ext(cx, \"ext_cx\")),\n-        id_ext(cx, \"cfg\"), ~[]);\n+        sp, cx.expr_ident(sp, id_ext(\"ext_cx\")),\n+        id_ext(\"cfg\"), ~[]);\n \n     let parse_sess_call = || cx.expr_method_call(\n-        sp, cx.expr_ident(sp, id_ext(cx, \"ext_cx\")),\n-        id_ext(cx, \"parse_sess\"), ~[]);\n+        sp, cx.expr_ident(sp, id_ext(\"ext_cx\")),\n+        id_ext(\"parse_sess\"), ~[]);\n \n     let new_parser_call =\n         cx.expr_call_global(sp,\n-                            ids_ext(cx, ~[~\"syntax\",\n-                                          ~\"ext\",\n-                                          ~\"quote\",\n-                                          ~\"rt\",\n-                                          ~\"new_parser_from_tts\"]),\n+                            ids_ext(~[~\"syntax\",\n+                                      ~\"ext\",\n+                                      ~\"quote\",\n+                                      ~\"rt\",\n+                                      ~\"new_parser_from_tts\"]),\n                             ~[parse_sess_call(),\n                               cfg_call(),\n                               tts_expr]);\n \n     cx.expr_method_call(sp, new_parser_call,\n-                        id_ext(cx, parse_method),\n+                        id_ext(parse_method),\n                         arg_exprs)\n }"}, {"sha": "fcdfb0a6ba7b6dd1e2aef289b2b4ce6c8d3616d3", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0409f8610612e8261a0139ec9c57396089cea060/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0409f8610612e8261a0139ec9c57396089cea060/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=0409f8610612e8261a0139ec9c57396089cea060", "patch": "@@ -18,6 +18,7 @@ use ext::base::*;\n use ext::base;\n use ext::build::AstBuilder;\n use parse;\n+use parse::token::{get_ident_interner};\n use print::pprust;\n \n use core::io;\n@@ -65,7 +66,7 @@ pub fn expand_file(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n \n pub fn expand_stringify(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n     -> base::MacResult {\n-    let s = pprust::tts_to_str(tts, cx.parse_sess().interner);\n+    let s = pprust::tts_to_str(tts, get_ident_interner());\n     base::MRExpr(cx.expr_str(sp, s))\n }\n "}, {"sha": "3baf432f24d6590795de1dce9461c86ca9fc67da", "filename": "src/libsyntax/ext/trace_macros.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0409f8610612e8261a0139ec9c57396089cea060/src%2Flibsyntax%2Fext%2Ftrace_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0409f8610612e8261a0139ec9c57396089cea060/src%2Flibsyntax%2Fext%2Ftrace_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftrace_macros.rs?ref=0409f8610612e8261a0139ec9c57396089cea060", "patch": "@@ -28,7 +28,6 @@ pub fn expand_trace_macros(cx: @ExtCtxt,\n     let cfg = cx.cfg();\n     let tt_rdr = new_tt_reader(\n         copy cx.parse_sess().span_diagnostic,\n-        cx.parse_sess().interner,\n         None,\n         vec::to_owned(tt)\n     );"}, {"sha": "9fb9def84e9cbee8f61dee925a6471498e8f88fa", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0409f8610612e8261a0139ec9c57396089cea060/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0409f8610612e8261a0139ec9c57396089cea060/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=0409f8610612e8261a0139ec9c57396089cea060", "patch": "@@ -19,7 +19,7 @@ use codemap;\n use parse::lexer::*; //resolve bug?\n use parse::ParseSess;\n use parse::parser::Parser;\n-use parse::token::{Token, EOF, to_str, nonterminal};\n+use parse::token::{Token, EOF, to_str, nonterminal, get_ident_interner, ident_to_str};\n use parse::token;\n \n use core::hashmap::HashMap;\n@@ -201,13 +201,13 @@ pub fn nameize(p_s: @mut ParseSess, ms: &[matcher], res: &[@named_match])\n             };\n           }\n           codemap::spanned {\n-                node: match_nonterminal(bind_name, _, idx), span: sp\n+                node: match_nonterminal(ref bind_name, _, idx), span: sp\n           } => {\n-            if ret_val.contains_key(&bind_name) {\n+            if ret_val.contains_key(bind_name) {\n                 p_s.span_diagnostic.span_fatal(sp, ~\"Duplicated bind name: \"+\n-                                               *p_s.interner.get(bind_name))\n+                                               *ident_to_str(bind_name))\n             }\n-            ret_val.insert(bind_name, res[idx]);\n+            ret_val.insert(*bind_name, res[idx]);\n           }\n         }\n     }\n@@ -372,9 +372,9 @@ pub fn parse(\n                 || bb_eis.len() > 1u {\n                 let nts = str::connect(vec::map(bb_eis, |ei| {\n                     match ei.elts[ei.idx].node {\n-                      match_nonterminal(bind,name,_) => {\n-                        fmt!(\"%s ('%s')\", *sess.interner.get(name),\n-                             *sess.interner.get(bind))\n+                      match_nonterminal(ref bind,ref name,_) => {\n+                        fmt!(\"%s ('%s')\", *ident_to_str(name),\n+                             *ident_to_str(bind))\n                       }\n                       _ => fail!()\n                     } }), \" or \");\n@@ -384,7 +384,7 @@ pub fn parse(\n                     nts, next_eis.len()));\n             } else if (bb_eis.len() == 0u && next_eis.len() == 0u) {\n                 return failure(sp, ~\"No rules expected the token: \"\n-                            + to_str(rdr.interner(), &tok));\n+                            + to_str(get_ident_interner(), &tok));\n             } else if (next_eis.len() > 0u) {\n                 /* Now process the next token */\n                 while(next_eis.len() > 0u) {\n@@ -396,9 +396,9 @@ pub fn parse(\n \n                 let mut ei = bb_eis.pop();\n                 match ei.elts[ei.idx].node {\n-                  match_nonterminal(_, name, idx) => {\n+                  match_nonterminal(_, ref name, idx) => {\n                     ei.matches[idx].push(@matched_nonterminal(\n-                        parse_nt(&rust_parser, *sess.interner.get(name))));\n+                        parse_nt(&rust_parser, *ident_to_str(name))));\n                     ei.idx += 1u;\n                   }\n                   _ => fail!()\n@@ -430,7 +430,7 @@ pub fn parse_nt(p: &Parser, name: &str) -> nonterminal {\n       \"ident\" => match *p.token {\n         token::IDENT(sn,b) => { p.bump(); token::nt_ident(sn,b) }\n         _ => p.fatal(~\"expected ident, found \"\n-                     + token::to_str(p.reader.interner(), &copy *p.token))\n+                     + token::to_str(get_ident_interner(), &copy *p.token))\n       },\n       \"path\" => token::nt_path(p.parse_path_with_tps(false)),\n       \"tt\" => {"}, {"sha": "1822117507d7fffcc75b7c56f9886c6754946c7e", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0409f8610612e8261a0139ec9c57396089cea060/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0409f8610612e8261a0139ec9c57396089cea060/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=0409f8610612e8261a0139ec9c57396089cea060", "patch": "@@ -21,7 +21,7 @@ use ext::tt::macro_parser::{named_match, matched_seq, matched_nonterminal};\n use ext::tt::macro_parser::{parse, parse_or_else, success, failure};\n use parse::lexer::{new_tt_reader, reader};\n use parse::parser::Parser;\n-use parse::token::special_idents;\n+use parse::token::{get_ident_interner, special_idents, gensym_ident, ident_to_str};\n use parse::token::{FAT_ARROW, SEMI, nt_matchers, nt_tt};\n use print;\n \n@@ -38,8 +38,8 @@ pub fn add_new_extension(cx: @ExtCtxt,\n         spanned { node: copy m, span: dummy_sp() }\n     }\n \n-    let lhs_nm =  cx.parse_sess().interner.gensym(\"lhs\");\n-    let rhs_nm =  cx.parse_sess().interner.gensym(\"rhs\");\n+    let lhs_nm =  gensym_ident(\"lhs\");\n+    let rhs_nm =  gensym_ident(\"rhs\");\n \n     // The grammar for macro_rules! is:\n     // $( $lhs:mtcs => $rhs:tt );+\n@@ -57,7 +57,7 @@ pub fn add_new_extension(cx: @ExtCtxt,\n \n     // Parse the macro_rules! invocation (`none` is for no interpolations):\n     let arg_reader = new_tt_reader(copy cx.parse_sess().span_diagnostic,\n-                                   cx.parse_sess().interner, None, copy arg);\n+                                   None, copy arg);\n     let argument_map = parse_or_else(cx.parse_sess(),\n                                      cx.cfg(),\n                                      arg_reader as @reader,\n@@ -85,23 +85,21 @@ pub fn add_new_extension(cx: @ExtCtxt,\n                              cx.str_of(name),\n                              print::pprust::tt_to_str(\n                                  ast::tt_delim(vec::to_owned(arg)),\n-                                 cx.parse_sess().interner)));\n+                                 get_ident_interner())));\n         }\n \n         // Which arm's failure should we report? (the one furthest along)\n         let mut best_fail_spot = dummy_sp();\n         let mut best_fail_msg = ~\"internal error: ran no matchers\";\n \n         let s_d = cx.parse_sess().span_diagnostic;\n-        let itr = cx.parse_sess().interner;\n \n         for lhses.eachi |i, lhs| { // try each arm's matchers\n             match *lhs {\n               @matched_nonterminal(nt_matchers(ref mtcs)) => {\n                 // `none` is because we're not interpolating\n                 let arg_rdr = new_tt_reader(\n                     s_d,\n-                    itr,\n                     None,\n                     vec::to_owned(arg)\n                 ) as @reader;\n@@ -122,7 +120,7 @@ pub fn add_new_extension(cx: @ExtCtxt,\n                         _ => cx.span_bug(sp, \"bad thing in rhs\")\n                     };\n                     // rhs has holes ( `$id` and `$(...)` that need filled)\n-                    let trncbr = new_tt_reader(s_d, itr, Some(named_matches),\n+                    let trncbr = new_tt_reader(s_d, Some(named_matches),\n                                                rhs);\n                     let p = @Parser(cx.parse_sess(),\n                                     cx.cfg(),\n@@ -151,7 +149,7 @@ pub fn add_new_extension(cx: @ExtCtxt,\n         |cx, sp, arg| generic_extension(cx, sp, name, arg, *lhses, *rhses);\n \n     return MRDef(MacroDef{\n-        name: copy *cx.parse_sess().interner.get(name),\n+        name: copy *ident_to_str(&name),\n         ext: NormalTT(base::SyntaxExpanderTT{expander: exp, span: Some(sp)})\n     });\n }"}, {"sha": "f0b078603dbd09b526b4d1bf89fb9996f244a203", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/0409f8610612e8261a0139ec9c57396089cea060/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0409f8610612e8261a0139ec9c57396089cea060/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=0409f8610612e8261a0139ec9c57396089cea060", "patch": "@@ -15,7 +15,8 @@ use ast::{token_tree, tt_delim, tt_tok, tt_seq, tt_nonterminal,ident};\n use codemap::{span, dummy_sp};\n use diagnostic::span_handler;\n use ext::tt::macro_parser::{named_match, matched_seq, matched_nonterminal};\n-use parse::token::{EOF, INTERPOLATED, IDENT, Token, nt_ident, ident_interner};\n+use parse::token::{EOF, INTERPOLATED, IDENT, Token, nt_ident};\n+use parse::token::{ident_to_str};\n use parse::lexer::TokenAndSpan;\n \n use core::hashmap::HashMap;\n@@ -33,7 +34,6 @@ struct TtFrame {\n \n pub struct TtReader {\n     sp_diag: @span_handler,\n-    interner: @ident_interner,\n     // the unzipped tree:\n     stack: @mut TtFrame,\n     /* for MBE-style macro transcription */\n@@ -49,13 +49,11 @@ pub struct TtReader {\n  *  `src` contains no `tt_seq`s and `tt_nonterminal`s, `interp` can (and\n  *  should) be none. */\n pub fn new_tt_reader(sp_diag: @span_handler,\n-                     itr: @ident_interner,\n                      interp: Option<HashMap<ident,@named_match>>,\n                      src: ~[ast::token_tree])\n                   -> @mut TtReader {\n     let r = @mut TtReader {\n         sp_diag: sp_diag,\n-        interner: itr,\n         stack: @mut TtFrame {\n             forest: @mut src,\n             idx: 0u,\n@@ -93,7 +91,6 @@ fn dup_tt_frame(f: @mut TtFrame) -> @mut TtFrame {\n pub fn dup_tt_reader(r: @mut TtReader) -> @mut TtReader {\n     @mut TtReader {\n         sp_diag: r.sp_diag,\n-        interner: r.interner,\n         stack: dup_tt_frame(r.stack),\n         repeat_idx: copy r.repeat_idx,\n         repeat_len: copy r.repeat_len,\n@@ -126,7 +123,7 @@ fn lookup_cur_matched(r: &mut TtReader, name: ident) -> @named_match {\n         Some(s) => lookup_cur_matched_by_matched(r, s),\n         None => {\n             r.sp_diag.span_fatal(r.cur_span, fmt!(\"unknown macro variable `%s`\",\n-                                                  *r.interner.get(name)));\n+                                                  *ident_to_str(&name)));\n         }\n     }\n }\n@@ -139,13 +136,13 @@ fn lockstep_iter_size(t: &token_tree, r: &mut TtReader) -> lis {\n         match lhs {\n           lis_unconstrained => copy rhs,\n           lis_contradiction(_) => copy lhs,\n-          lis_constraint(l_len, l_id) => match rhs {\n+          lis_constraint(l_len, ref l_id) => match rhs {\n             lis_unconstrained => copy lhs,\n             lis_contradiction(_) => copy rhs,\n             lis_constraint(r_len, _) if l_len == r_len => copy lhs,\n-            lis_constraint(r_len, r_id) => {\n-                let l_n = copy *r.interner.get(l_id);\n-                let r_n = copy *r.interner.get(r_id);\n+            lis_constraint(r_len, ref r_id) => {\n+                let l_n = copy *ident_to_str(l_id);\n+                let r_n = copy *ident_to_str(r_id);\n                 lis_contradiction(fmt!(\"Inconsistent lockstep iteration: \\\n                                        '%s' has %u items, but '%s' has %u\",\n                                         l_n, l_len, r_n, r_len))\n@@ -295,7 +292,7 @@ pub fn tt_next_token(r: &mut TtReader) -> TokenAndSpan {\n                 r.sp_diag.span_fatal(\n                     copy r.cur_span, /* blame the macro writer */\n                     fmt!(\"variable '%s' is still repeating at this depth\",\n-                         *r.interner.get(ident)));\n+                         *ident_to_str(&ident)));\n               }\n             }\n           }"}, {"sha": "dab8dd3b4b6a3d20ca7701bdc5b297596e41c594", "filename": "src/libsyntax/parse/comments.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0409f8610612e8261a0139ec9c57396089cea060/src%2Flibsyntax%2Fparse%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0409f8610612e8261a0139ec9c57396089cea060/src%2Flibsyntax%2Fparse%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcomments.rs?ref=0409f8610612e8261a0139ec9c57396089cea060", "patch": "@@ -18,6 +18,7 @@ use parse::lexer::{StringReader, bump, is_eof, nextch, TokenAndSpan};\n use parse::lexer::{is_line_non_doc_comment, is_block_non_doc_comment};\n use parse::lexer;\n use parse::token;\n+use parse::token::{get_ident_interner};\n use parse;\n \n use core::io;\n@@ -323,12 +324,9 @@ pub fn gather_comments_and_literals(span_diagnostic:\n                                     srdr: @io::Reader)\n                                  -> (~[cmnt], ~[lit]) {\n     let src = @str::from_bytes(srdr.read_whole_stream());\n-    let itr = parse::token::mk_fake_ident_interner();\n     let cm = CodeMap::new();\n     let filemap = cm.new_filemap(path, src);\n-    let rdr = lexer::new_low_level_string_reader(span_diagnostic,\n-                                                 filemap,\n-                                                 itr);\n+    let rdr = lexer::new_low_level_string_reader(span_diagnostic, filemap);\n \n     let mut comments: ~[cmnt] = ~[];\n     let mut literals: ~[lit] = ~[];\n@@ -358,7 +356,7 @@ pub fn gather_comments_and_literals(span_diagnostic:\n             debug!(\"tok lit: %s\", s);\n             literals.push(lit {lit: s, pos: sp.lo});\n         } else {\n-            debug!(\"tok: %s\", token::to_str(rdr.interner, &tok));\n+            debug!(\"tok: %s\", token::to_str(get_ident_interner(), &tok));\n         }\n         first_read = false;\n     }"}, {"sha": "9fb69821953ac3cbe1f6ec03e66b4e867f42c2d9", "filename": "src/libsyntax/parse/common.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0409f8610612e8261a0139ec9c57396089cea060/src%2Flibsyntax%2Fparse%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0409f8610612e8261a0139ec9c57396089cea060/src%2Flibsyntax%2Fparse%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcommon.rs?ref=0409f8610612e8261a0139ec9c57396089cea060", "patch": "@@ -16,6 +16,7 @@ use parse::lexer::reader;\n use parse::parser::Parser;\n use parse::token::keywords;\n use parse::token;\n+use parse::token::{get_ident_interner};\n \n use opt_vec;\n use opt_vec::OptVec;\n@@ -49,13 +50,13 @@ pub fn seq_sep_none() -> SeqSep {\n // maps any token back to a string. not necessary if you know it's\n // an identifier....\n pub fn token_to_str(reader: @reader, token: &token::Token) -> ~str {\n-    token::to_str(reader.interner(), token)\n+    token::to_str(get_ident_interner(), token)\n }\n \n impl Parser {\n     // convert a token to a string using self's reader\n     pub fn token_to_str(&self, token: &token::Token) -> ~str {\n-        token::to_str(self.reader.interner(), token)\n+        token::to_str(get_ident_interner(), token)\n     }\n \n     // convert the current token to a string using self's reader\n@@ -142,7 +143,7 @@ impl Parser {\n     // true. Otherwise, return false.\n     pub fn eat_keyword(&self, kw: keywords::Keyword) -> bool {\n         let is_kw = match *self.token {\n-            token::IDENT(sid, false) => kw.to_ident().repr == sid.repr,\n+            token::IDENT(sid, false) => kw.to_ident().name == sid.name,\n             _ => false\n         };\n         if is_kw { self.bump() }"}, {"sha": "84700f052c9c4bf13f871dbb6cbb0a551680effd", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 29, "deletions": 38, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/0409f8610612e8261a0139ec9c57396089cea060/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0409f8610612e8261a0139ec9c57396089cea060/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=0409f8610612e8261a0139ec9c57396089cea060", "patch": "@@ -17,6 +17,7 @@ use diagnostic::span_handler;\n use ext::tt::transcribe::{tt_next_token};\n use ext::tt::transcribe::{dup_tt_reader};\n use parse::token;\n+use parse::token::{str_to_ident};\n \n use core::char;\n use core::either;\n@@ -30,7 +31,6 @@ pub trait reader {\n     fn next_token(@mut self) -> TokenAndSpan;\n     fn fatal(@mut self, ~str) -> !;\n     fn span_diag(@mut self) -> @span_handler;\n-    fn interner(@mut self) -> @token::ident_interner;\n     fn peek(@mut self) -> TokenAndSpan;\n     fn dup(@mut self) -> @reader;\n }\n@@ -50,25 +50,22 @@ pub struct StringReader {\n     // The last character to be read\n     curr: char,\n     filemap: @codemap::FileMap,\n-    interner: @token::ident_interner,\n     /* cached: */\n     peek_tok: token::Token,\n     peek_span: span\n }\n \n pub fn new_string_reader(span_diagnostic: @span_handler,\n-                         filemap: @codemap::FileMap,\n-                         itr: @token::ident_interner)\n+                         filemap: @codemap::FileMap)\n                       -> @mut StringReader {\n-    let r = new_low_level_string_reader(span_diagnostic, filemap, itr);\n+    let r = new_low_level_string_reader(span_diagnostic, filemap);\n     string_advance_token(r); /* fill in peek_* */\n     return r;\n }\n \n /* For comments.rs, which hackily pokes into 'pos' and 'curr' */\n pub fn new_low_level_string_reader(span_diagnostic: @span_handler,\n-                                   filemap: @codemap::FileMap,\n-                                   itr: @token::ident_interner)\n+                                   filemap: @codemap::FileMap)\n                                 -> @mut StringReader {\n     // Force the initial reader bump to start on a fresh line\n     let initial_char = '\\n';\n@@ -79,7 +76,6 @@ pub fn new_low_level_string_reader(span_diagnostic: @span_handler,\n         col: CharPos(0),\n         curr: initial_char,\n         filemap: filemap,\n-        interner: itr,\n         /* dummy values; not read */\n         peek_tok: token::EOF,\n         peek_span: codemap::dummy_sp()\n@@ -100,7 +96,6 @@ fn dup_string_reader(r: @mut StringReader) -> @mut StringReader {\n         col: r.col,\n         curr: r.curr,\n         filemap: r.filemap,\n-        interner: r.interner,\n         peek_tok: copy r.peek_tok,\n         peek_span: copy r.peek_span\n     }\n@@ -121,7 +116,6 @@ impl reader for StringReader {\n         self.span_diagnostic.span_fatal(copy self.peek_span, m)\n     }\n     fn span_diag(@mut self) -> @span_handler { self.span_diagnostic }\n-    fn interner(@mut self) -> @token::ident_interner { self.interner }\n     fn peek(@mut self) -> TokenAndSpan {\n         TokenAndSpan {\n             tok: copy self.peek_tok,\n@@ -138,7 +132,6 @@ impl reader for TtReader {\n         self.sp_diag.span_fatal(copy self.cur_span, m);\n     }\n     fn span_diag(@mut self) -> @span_handler { self.sp_diag }\n-    fn interner(@mut self) -> @token::ident_interner { self.interner }\n     fn peek(@mut self) -> TokenAndSpan {\n         TokenAndSpan {\n             tok: copy self.cur_tok,\n@@ -277,7 +270,7 @@ fn consume_any_line_comment(rdr: @mut StringReader)\n                 // but comments with only more \"/\"s are not\n                 if !is_line_non_doc_comment(acc) {\n                     return Some(TokenAndSpan{\n-                        tok: token::DOC_COMMENT(rdr.interner.intern(acc)),\n+                        tok: token::DOC_COMMENT(str_to_ident(acc)),\n                         sp: codemap::mk_sp(start_bpos, rdr.pos)\n                     });\n                 }\n@@ -331,7 +324,7 @@ fn consume_block_comment(rdr: @mut StringReader)\n             // but comments with only \"*\"s between two \"/\"s are not\n             if !is_block_non_doc_comment(acc) {\n                 return Some(TokenAndSpan{\n-                    tok: token::DOC_COMMENT(rdr.interner.intern(acc)),\n+                    tok: token::DOC_COMMENT(str_to_ident(acc)),\n                     sp: codemap::mk_sp(start_bpos, rdr.pos)\n                 });\n             }\n@@ -477,12 +470,12 @@ fn scan_number(c: char, rdr: @mut StringReader) -> token::Token {\n         if c == '3' && n == '2' {\n             bump(rdr);\n             bump(rdr);\n-            return token::LIT_FLOAT(rdr.interner.intern(num_str),\n+            return token::LIT_FLOAT(str_to_ident(num_str),\n                                  ast::ty_f32);\n         } else if c == '6' && n == '4' {\n             bump(rdr);\n             bump(rdr);\n-            return token::LIT_FLOAT(rdr.interner.intern(num_str),\n+            return token::LIT_FLOAT(str_to_ident(num_str),\n                                  ast::ty_f64);\n             /* FIXME (#2252): if this is out of range for either a\n             32-bit or 64-bit float, it won't be noticed till the\n@@ -494,9 +487,9 @@ fn scan_number(c: char, rdr: @mut StringReader) -> token::Token {\n     }\n     if is_float {\n         if is_machine_float {\n-            return token::LIT_FLOAT(rdr.interner.intern(num_str), ast::ty_f);\n+            return token::LIT_FLOAT(str_to_ident(num_str), ast::ty_f);\n         }\n-        return token::LIT_FLOAT_UNSUFFIXED(rdr.interner.intern(num_str));\n+        return token::LIT_FLOAT_UNSUFFIXED(str_to_ident(num_str));\n     } else {\n         if str::len(num_str) == 0u {\n             rdr.fatal(~\"no valid digits found for number\");\n@@ -559,7 +552,7 @@ fn next_token_inner(rdr: @mut StringReader) -> token::Token {\n         let is_mod_name = c == ':' && nextch(rdr) == ':';\n \n         // FIXME: perform NFKC normalization here. (Issue #2253)\n-        return token::IDENT(rdr.interner.intern(accum_str), is_mod_name);\n+        return token::IDENT(str_to_ident(accum_str), is_mod_name);\n     }\n     if is_dec_digit(c) {\n         return scan_number(c, rdr);\n@@ -669,7 +662,7 @@ fn next_token_inner(rdr: @mut StringReader) -> token::Token {\n                 lifetime_name.push_char(rdr.curr);\n                 bump(rdr);\n             }\n-            return token::LIFETIME(rdr.interner.intern(lifetime_name));\n+            return token::LIFETIME(str_to_ident(lifetime_name));\n         }\n \n         // Otherwise it is a character constant:\n@@ -742,7 +735,7 @@ fn next_token_inner(rdr: @mut StringReader) -> token::Token {\n             }\n         }\n         bump(rdr);\n-        return token::LIT_STR(rdr.interner.intern(accum_str));\n+        return token::LIT_STR(str_to_ident(accum_str));\n       }\n       '-' => {\n         if nextch(rdr) == '>' {\n@@ -786,31 +779,29 @@ mod test {\n     use core::option::None;\n     use diagnostic;\n     use parse::token;\n+    use parse::token::{str_to_ident};\n \n     // represents a testing reader (incl. both reader and interner)\n     struct Env {\n-        interner: @token::ident_interner,\n         string_reader: @mut StringReader\n     }\n \n     // open a string reader for the given string\n     fn setup(teststr: ~str) -> Env {\n         let cm = CodeMap::new();\n         let fm = cm.new_filemap(~\"zebra.rs\", @teststr);\n-        let ident_interner = token::get_ident_interner();\n         let span_handler =\n             diagnostic::mk_span_handler(diagnostic::mk_handler(None),@cm);\n         Env {\n-            interner: ident_interner,\n-            string_reader: new_string_reader(span_handler,fm,ident_interner)\n+            string_reader: new_string_reader(span_handler,fm)\n         }\n     }\n \n     #[test] fn t1 () {\n-        let Env {interner: ident_interner, string_reader} =\n+        let Env {string_reader} =\n             setup(~\"/* my source file */ \\\n                     fn main() { io::println(~\\\"zebra\\\"); }\\n\");\n-        let id = ident_interner.intern(\"fn\");\n+        let id = str_to_ident(\"fn\");\n         let tok1 = string_reader.next_token();\n         let tok2 = TokenAndSpan{\n             tok:token::IDENT(id, false),\n@@ -821,7 +812,7 @@ mod test {\n         // read another token:\n         let tok3 = string_reader.next_token();\n         let tok4 = TokenAndSpan{\n-            tok:token::IDENT(ident_interner.intern(\"main\"), false),\n+            tok:token::IDENT(str_to_ident(\"main\"), false),\n             sp:span {lo:BytePos(24),hi:BytePos(28),expn_info: None}};\n         assert_eq!(tok3,tok4);\n         // the lparen is already read:\n@@ -839,39 +830,39 @@ mod test {\n     }\n \n     // make the identifier by looking up the string in the interner\n-    fn mk_ident (env: Env, id: &str, is_mod_name: bool) -> token::Token {\n-        token::IDENT (env.interner.intern(id),is_mod_name)\n+    fn mk_ident (id: &str, is_mod_name: bool) -> token::Token {\n+        token::IDENT (str_to_ident(id),is_mod_name)\n     }\n \n     #[test] fn doublecolonparsing () {\n         let env = setup (~\"a b\");\n         check_tokenization (env,\n-                           ~[mk_ident (env,\"a\",false),\n-                             mk_ident (env,\"b\",false)]);\n+                           ~[mk_ident(\"a\",false),\n+                             mk_ident(\"b\",false)]);\n     }\n \n     #[test] fn dcparsing_2 () {\n         let env = setup (~\"a::b\");\n         check_tokenization (env,\n-                           ~[mk_ident (env,\"a\",true),\n+                           ~[mk_ident(\"a\",true),\n                              token::MOD_SEP,\n-                             mk_ident (env,\"b\",false)]);\n+                             mk_ident(\"b\",false)]);\n     }\n \n     #[test] fn dcparsing_3 () {\n         let env = setup (~\"a ::b\");\n         check_tokenization (env,\n-                           ~[mk_ident (env,\"a\",false),\n+                           ~[mk_ident(\"a\",false),\n                              token::MOD_SEP,\n-                             mk_ident (env,\"b\",false)]);\n+                             mk_ident(\"b\",false)]);\n     }\n \n     #[test] fn dcparsing_4 () {\n         let env = setup (~\"a:: b\");\n         check_tokenization (env,\n-                           ~[mk_ident (env,\"a\",true),\n+                           ~[mk_ident(\"a\",true),\n                              token::MOD_SEP,\n-                             mk_ident (env,\"b\",false)]);\n+                             mk_ident(\"b\",false)]);\n     }\n \n     #[test] fn character_a() {\n@@ -899,7 +890,7 @@ mod test {\n         let env = setup(~\"'abc\");\n         let TokenAndSpan {tok, sp: _} =\n             env.string_reader.next_token();\n-        let id = env.interner.intern(\"abc\");\n+        let id = token::str_to_ident(\"abc\");\n         assert_eq!(tok, token::LIFETIME(id));\n     }\n "}, {"sha": "d7248204e1cf74278e3065103b163883ccc4c68c", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 16, "deletions": 30, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/0409f8610612e8261a0139ec9c57396089cea060/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0409f8610612e8261a0139ec9c57396089cea060/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=0409f8610612e8261a0139ec9c57396089cea060", "patch": "@@ -19,7 +19,6 @@ use diagnostic::{span_handler, mk_span_handler, mk_handler, Emitter};\n use parse::attr::parser_attr;\n use parse::lexer::reader;\n use parse::parser::Parser;\n-use parse::token::{ident_interner, get_ident_interner};\n \n use core::io;\n use core::option::{None, Option, Some};\n@@ -43,14 +42,10 @@ pub mod classify;\n pub mod obsolete;\n \n // info about a parsing session.\n-// This structure and the reader both have\n-// an interner associated with them. If they're\n-// not the same, bad things can happen.\n pub struct ParseSess {\n     cm: @codemap::CodeMap, // better be the same as the one in the reader!\n     next_id: node_id,\n     span_diagnostic: @span_handler, // better be the same as the one in the reader!\n-    interner: @ident_interner,\n }\n \n pub fn new_parse_sess(demitter: Option<Emitter>) -> @mut ParseSess {\n@@ -59,7 +54,6 @@ pub fn new_parse_sess(demitter: Option<Emitter>) -> @mut ParseSess {\n         cm: cm,\n         next_id: 1,\n         span_diagnostic: mk_span_handler(mk_handler(demitter), cm),\n-        interner: get_ident_interner(),\n     }\n }\n \n@@ -70,7 +64,6 @@ pub fn new_parse_sess_special_handler(sh: @span_handler,\n         cm: cm,\n         next_id: 1,\n         span_diagnostic: sh,\n-        interner: get_ident_interner(),\n     }\n }\n \n@@ -312,9 +305,7 @@ pub fn filemap_to_tts(sess: @mut ParseSess, filemap: @FileMap)\n     // it appears to me that the cfg doesn't matter here... indeed,\n     // parsing tt's probably shouldn't require a parser at all.\n     let cfg = ~[];\n-    let srdr = lexer::new_string_reader(copy sess.span_diagnostic,\n-                                        filemap,\n-                                        sess.interner);\n+    let srdr = lexer::new_string_reader(copy sess.span_diagnostic, filemap);\n     let p1 = Parser(sess, cfg, srdr as @reader);\n     p1.parse_all_token_trees()\n }\n@@ -325,7 +316,6 @@ pub fn tts_to_parser(sess: @mut ParseSess,\n                      cfg: ast::crate_cfg) -> Parser {\n     let trdr = lexer::new_tt_reader(\n         copy sess.span_diagnostic,\n-        sess.interner,\n         None,\n         tts\n     );\n@@ -351,12 +341,13 @@ mod test {\n     use codemap::{span, BytePos, spanned};\n     use opt_vec;\n     use ast;\n+    use ast::{new_ident};\n     use abi;\n     use parse::parser::Parser;\n-    use parse::token::intern;\n-    use util::parser_testing::{string_to_tts_and_sess,string_to_parser};\n+    use parse::token::{intern, str_to_ident};\n+    use util::parser_testing::{string_to_tts_and_sess, string_to_parser};\n     use util::parser_testing::{string_to_expr, string_to_item};\n-    use util::parser_testing::{string_to_stmt};\n+    use util::parser_testing::{string_to_stmt, strs_to_idents};\n \n     // map a string to tts, return the tt without its parsesess\n     fn string_to_tts_only(source_str : @~str) -> ~[ast::token_tree] {\n@@ -377,17 +368,12 @@ mod test {\n         span{lo:BytePos(a),hi:BytePos(b),expn_info:None}\n     }\n \n-    // convert a vector of uints to a vector of ast::idents\n-    fn ints_to_idents(ids: ~[~str]) -> ~[ast::ident] {\n-        ids.map(|u| intern(*u))\n-    }\n-\n     #[test] fn path_exprs_1 () {\n         assert_eq!(string_to_expr(@~\"a\"),\n                    @ast::expr{id:1,\n                               node:ast::expr_path(@ast::Path {span:sp(0,1),\n                                                               global:false,\n-                                                              idents:~[intern(\"a\")],\n+                                                              idents:~[str_to_ident(\"a\")],\n                                                               rp:None,\n                                                               types:~[]}),\n                               span:sp(0,1)})\n@@ -399,7 +385,7 @@ mod test {\n                                node:ast::expr_path(\n                                    @ast::Path {span:sp(0,6),\n                                                global:true,\n-                                               idents:ints_to_idents(~[~\"a\",~\"b\"]),\n+                                               idents:strs_to_idents(~[\"a\",\"b\"]),\n                                                rp:None,\n                                                types:~[]}),\n                               span:sp(0,6)})\n@@ -449,7 +435,7 @@ mod test {\n                                                   node:ast::expr_path(\n                                                       @ast::Path{span:sp(7,8),\n                                                                  global:false,\n-                                                                 idents:~[intern(\"d\")],\n+                                                                 idents:~[str_to_ident(\"d\")],\n                                                                  rp:None,\n                                                                  types:~[]\n                                                                 }),\n@@ -466,7 +452,7 @@ mod test {\n                                @ast::Path{\n                                    span:sp(0,1),\n                                    global:false,\n-                                   idents:~[intern(\"b\")],\n+                                   idents:~[str_to_ident(\"b\")],\n                                    rp:None,\n                                    types: ~[]}),\n                            span: sp(0,1)},\n@@ -487,7 +473,7 @@ mod test {\n                                                   @ast::Path{\n                                                       span:sp(0,1),\n                                                       global:false,\n-                                                      idents:~[intern(\"b\")],\n+                                                      idents:~[str_to_ident(\"b\")],\n                                                       rp: None,\n                                                       types: ~[]},\n                                                   None // no idea\n@@ -506,7 +492,7 @@ mod test {\n                                         span:sp(4,4), // this is bizarre...\n                                         // check this in the original parser?\n                                         global:false,\n-                                        idents:~[intern(\"int\")],\n+                                        idents:~[str_to_ident(\"int\")],\n                                         rp: None,\n                                         types: ~[]},\n                                                        2),\n@@ -516,7 +502,7 @@ mod test {\n                                                            @ast::Path{\n                                                                span:sp(0,1),\n                                                                global:false,\n-                                                               idents:~[intern(\"b\")],\n+                                                               idents:~[str_to_ident(\"b\")],\n                                                                rp: None,\n                                                                types: ~[]},\n                                                            None // no idea\n@@ -532,7 +518,7 @@ mod test {\n         // assignment order of the node_ids.\n         assert_eq!(string_to_item(@~\"fn a (b : int) { b; }\"),\n                   Some(\n-                      @ast::item{ident:intern(\"a\"),\n+                      @ast::item{ident:str_to_ident(\"a\"),\n                             attrs:~[],\n                             id: 9, // fixme\n                             node: ast::item_fn(ast::fn_decl{\n@@ -542,7 +528,7 @@ mod test {\n                                                 node: ast::ty_path(@ast::Path{\n                                         span:sp(10,13),\n                                         global:false,\n-                                        idents:~[intern(\"int\")],\n+                                        idents:~[str_to_ident(\"int\")],\n                                         rp: None,\n                                         types: ~[]},\n                                                        2),\n@@ -553,7 +539,7 @@ mod test {\n                                                        @ast::Path{\n                                                            span:sp(6,7),\n                                                            global:false,\n-                                                           idents:~[intern(\"b\")],\n+                                                           idents:~[str_to_ident(\"b\")],\n                                                            rp: None,\n                                                            types: ~[]},\n                                                        None // no idea\n@@ -583,7 +569,7 @@ mod test {\n                                                         @ast::Path{\n                                                             span:sp(17,18),\n                                                             global:false,\n-                                                            idents:~[intern(\"b\")],\n+                                                            idents:~[str_to_ident(\"b\")],\n                                                             rp:None,\n                                                             types: ~[]}),\n                                                     span: sp(17,18)},"}, {"sha": "2fd0a7e33fff0f90b01644f46cf487f280172862", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/0409f8610612e8261a0139ec9c57396089cea060/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0409f8610612e8261a0139ec9c57396089cea060/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=0409f8610612e8261a0139ec9c57396089cea060", "patch": "@@ -85,7 +85,7 @@ use parse::obsolete::{ObsoleteLifetimeNotation, ObsoleteConstManagedPointer};\n use parse::obsolete::{ObsoletePurity, ObsoleteStaticMethod};\n use parse::obsolete::{ObsoleteConstItem, ObsoleteFixedLengthVectorType};\n use parse::obsolete::{ObsoleteNamedExternModule, ObsoleteMultipleLocalDecl};\n-use parse::token::{can_begin_expr, is_ident, is_ident_or_path};\n+use parse::token::{can_begin_expr, get_ident_interner, ident_to_str, is_ident, is_ident_or_path};\n use parse::token::{is_plain_ident, INTERPOLATED, keywords, special_idents, token_to_binop};\n use parse::token;\n use parse::{new_sub_parser_from_file, next_node_id, ParseSess};\n@@ -219,7 +219,7 @@ pub fn Parser(sess: @mut ParseSess,\n               rdr: @reader)\n            -> Parser {\n     let tok0 = copy rdr.next_token();\n-    let interner = rdr.interner();\n+    let interner = get_ident_interner();\n \n     Parser {\n         reader: rdr,\n@@ -333,7 +333,7 @@ impl Parser {\n     pub fn get_id(&self) -> node_id { next_node_id(self.sess) }\n \n     pub fn id_to_str(&self, id: ident) -> @~str {\n-        self.sess.interner.get(id)\n+        get_ident_interner().get(id.name)\n     }\n \n     // is this one of the keywords that signals a closure type?\n@@ -2628,6 +2628,13 @@ impl Parser {\n             // to the macro clause of parse_item_or_view_item. This\n             // could use some cleanup, it appears to me.\n \n+            // whoops! I now have a guess: I'm guessing the \"parens-only\"\n+            // rule here is deliberate, to allow macro users to use parens\n+            // for things that should be parsed as stmt_mac, and braces\n+            // for things that should expand into items. Tricky, and\n+            // somewhat awkward... and probably undocumented. Of course,\n+            // I could just be wrong.\n+\n             check_expected_item(self, item_attrs);\n \n             // Potential trouble: if we allow macros with paths instead of\n@@ -3363,7 +3370,7 @@ impl Parser {\n             }\n             if fields.len() == 0 {\n                 self.fatal(fmt!(\"Unit-like struct should be written as `struct %s;`\",\n-                                *self.interner.get(class_name)));\n+                                *get_ident_interner().get(class_name.name)));\n             }\n             self.bump();\n         } else if *self.token == token::LPAREN {\n@@ -3575,7 +3582,7 @@ impl Parser {\n     }\n \n     fn push_mod_path(&self, id: ident, attrs: ~[ast::attribute]) {\n-        let default_path = self.sess.interner.get(id);\n+        let default_path = token::interner_get(id.name);\n         let file_path = match ::attr::first_attr_value_str_by_name(\n             attrs, \"path\") {\n \n@@ -3598,7 +3605,7 @@ impl Parser {\n         let prefix = prefix.dir_path();\n         let mod_path_stack = &*self.mod_path_stack;\n         let mod_path = Path(\".\").push_many(*mod_path_stack);\n-        let default_path = *self.sess.interner.get(id) + \".rs\";\n+        let default_path = *token::interner_get(id.name) + \".rs\";\n         let file_path = match ::attr::first_attr_value_str_by_name(\n             outer_attrs, \"path\") {\n             Some(d) => {\n@@ -3973,7 +3980,7 @@ impl Parser {\n         match *self.token {\n             token::LIT_STR(s) => {\n                 self.bump();\n-                let the_string = self.id_to_str(s);\n+                let the_string = ident_to_str(&s);\n                 let mut words = ~[];\n                 for str::each_word(*the_string) |s| { words.push(s) }\n                 let mut abis = AbiSet::empty();\n@@ -4535,7 +4542,7 @@ impl Parser {\n         match *self.token {\n             token::LIT_STR(s) => {\n                 self.bump();\n-                self.id_to_str(s)\n+                ident_to_str(&s)\n             }\n             _ =>  self.fatal(\"expected string literal\")\n         }"}, {"sha": "ecf83483c21fe680b6c606d72b10b49fa0f0b342", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 150, "deletions": 98, "changes": 248, "blob_url": "https://github.com/rust-lang/rust/blob/0409f8610612e8261a0139ec9c57396089cea060/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0409f8610612e8261a0139ec9c57396089cea060/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=0409f8610612e8261a0139ec9c57396089cea060", "patch": "@@ -11,6 +11,7 @@\n use core::prelude::*;\n \n use ast;\n+use ast::Name;\n use ast_util;\n use parse::token;\n use util::interner::StrInterner;\n@@ -21,6 +22,9 @@ use core::char;\n use core::cmp::Equiv;\n use core::local_data;\n use core::str;\n+use core::hashmap::HashSet;\n+use core::rand;\n+use core::rand::RngUtil;\n use core::to_bytes;\n \n #[deriving(Encodable, Decodable, Eq)]\n@@ -176,29 +180,29 @@ pub fn to_str(in: @ident_interner, t: &Token) -> ~str {\n           u.to_str() + ast_util::uint_ty_to_str(t)\n       }\n       LIT_INT_UNSUFFIXED(i) => { i.to_str() }\n-      LIT_FLOAT(s, t) => {\n-        let mut body = copy *in.get(s);\n+      LIT_FLOAT(ref s, t) => {\n+        let mut body = copy *ident_to_str(s);\n         if body.ends_with(\".\") {\n             body += \"0\";  // `10.f` is not a float literal\n         }\n         body + ast_util::float_ty_to_str(t)\n       }\n-      LIT_FLOAT_UNSUFFIXED(s) => {\n-        let mut body = copy *in.get(s);\n+      LIT_FLOAT_UNSUFFIXED(ref s) => {\n+        let mut body = copy *ident_to_str(s);\n         if body.ends_with(\".\") {\n             body += \"0\";  // `10.f` is not a float literal\n         }\n         body\n       }\n-      LIT_STR(s) => { ~\"\\\"\" + str::escape_default(*in.get(s)) + \"\\\"\" }\n+      LIT_STR(ref s) => { ~\"\\\"\" + str::escape_default(*ident_to_str(s)) + \"\\\"\" }\n \n       /* Name components */\n-      IDENT(s, _) => copy *in.get(s),\n-      LIFETIME(s) => fmt!(\"'%s\", *in.get(s)),\n+      IDENT(s, _) => copy *in.get(s.name),\n+      LIFETIME(s) => fmt!(\"'%s\", *in.get(s.name)),\n       UNDERSCORE => ~\"_\",\n \n       /* Other */\n-      DOC_COMMENT(s) => copy *in.get(s),\n+      DOC_COMMENT(ref s) => copy *ident_to_str(s),\n       EOF => ~\"<eof>\",\n       INTERPOLATED(ref nt) => {\n         match nt {\n@@ -304,47 +308,47 @@ pub fn is_bar(t: &Token) -> bool {\n pub mod special_idents {\n     use ast::ident;\n \n-    pub static underscore : ident = ident { repr: 0, ctxt: 0};\n-    pub static anon : ident = ident { repr: 1, ctxt: 0};\n-    pub static invalid : ident = ident { repr: 2, ctxt: 0}; // ''\n-    pub static unary : ident = ident { repr: 3, ctxt: 0};\n-    pub static not_fn : ident = ident { repr: 4, ctxt: 0};\n-    pub static idx_fn : ident = ident { repr: 5, ctxt: 0};\n-    pub static unary_minus_fn : ident = ident { repr: 6, ctxt: 0};\n-    pub static clownshoes_extensions : ident = ident { repr: 7, ctxt: 0};\n+    pub static underscore : ident = ident { name: 0, ctxt: 0};\n+    pub static anon : ident = ident { name: 1, ctxt: 0};\n+    pub static invalid : ident = ident { name: 2, ctxt: 0}; // ''\n+    pub static unary : ident = ident { name: 3, ctxt: 0};\n+    pub static not_fn : ident = ident { name: 4, ctxt: 0};\n+    pub static idx_fn : ident = ident { name: 5, ctxt: 0};\n+    pub static unary_minus_fn : ident = ident { name: 6, ctxt: 0};\n+    pub static clownshoes_extensions : ident = ident { name: 7, ctxt: 0};\n \n-    pub static self_ : ident = ident { repr: 8, ctxt: 0}; // 'self'\n+    pub static self_ : ident = ident { name: 8, ctxt: 0}; // 'self'\n \n     /* for matcher NTs */\n-    pub static item : ident = ident { repr: 9, ctxt: 0};\n-    pub static block : ident = ident { repr: 10, ctxt: 0};\n-    pub static stmt : ident = ident { repr: 11, ctxt: 0};\n-    pub static pat : ident = ident { repr: 12, ctxt: 0};\n-    pub static expr : ident = ident { repr: 13, ctxt: 0};\n-    pub static ty : ident = ident { repr: 14, ctxt: 0};\n-    pub static ident : ident = ident { repr: 15, ctxt: 0};\n-    pub static path : ident = ident { repr: 16, ctxt: 0};\n-    pub static tt : ident = ident { repr: 17, ctxt: 0};\n-    pub static matchers : ident = ident { repr: 18, ctxt: 0};\n-\n-    pub static str : ident = ident { repr: 19, ctxt: 0}; // for the type\n+    pub static item : ident = ident { name: 9, ctxt: 0};\n+    pub static block : ident = ident { name: 10, ctxt: 0};\n+    pub static stmt : ident = ident { name: 11, ctxt: 0};\n+    pub static pat : ident = ident { name: 12, ctxt: 0};\n+    pub static expr : ident = ident { name: 13, ctxt: 0};\n+    pub static ty : ident = ident { name: 14, ctxt: 0};\n+    pub static ident : ident = ident { name: 15, ctxt: 0};\n+    pub static path : ident = ident { name: 16, ctxt: 0};\n+    pub static tt : ident = ident { name: 17, ctxt: 0};\n+    pub static matchers : ident = ident { name: 18, ctxt: 0};\n+\n+    pub static str : ident = ident { name: 19, ctxt: 0}; // for the type\n \n     /* outside of libsyntax */\n-    pub static ty_visitor : ident = ident { repr: 20, ctxt: 0};\n-    pub static arg : ident = ident { repr: 21, ctxt: 0};\n-    pub static descrim : ident = ident { repr: 22, ctxt: 0};\n-    pub static clownshoe_abi : ident = ident { repr: 23, ctxt: 0};\n-    pub static clownshoe_stack_shim : ident = ident { repr: 24, ctxt: 0};\n-    pub static tydesc : ident = ident { repr: 25, ctxt: 0};\n-    pub static main : ident = ident { repr: 26, ctxt: 0};\n-    pub static opaque : ident = ident { repr: 27, ctxt: 0};\n-    pub static blk : ident = ident { repr: 28, ctxt: 0};\n-    pub static statik : ident = ident { repr: 29, ctxt: 0};\n-    pub static intrinsic : ident = ident { repr: 30, ctxt: 0};\n-    pub static clownshoes_foreign_mod: ident = ident { repr: 31, ctxt: 0};\n-    pub static unnamed_field: ident = ident { repr: 32, ctxt: 0};\n-    pub static c_abi: ident = ident { repr: 33, ctxt: 0};\n-    pub static type_self: ident = ident { repr: 34, ctxt: 0};    // `Self`\n+    pub static ty_visitor : ident = ident { name: 20, ctxt: 0};\n+    pub static arg : ident = ident { name: 21, ctxt: 0};\n+    pub static descrim : ident = ident { name: 22, ctxt: 0};\n+    pub static clownshoe_abi : ident = ident { name: 23, ctxt: 0};\n+    pub static clownshoe_stack_shim : ident = ident { name: 24, ctxt: 0};\n+    pub static tydesc : ident = ident { name: 25, ctxt: 0};\n+    pub static main : ident = ident { name: 26, ctxt: 0};\n+    pub static opaque : ident = ident { name: 27, ctxt: 0};\n+    pub static blk : ident = ident { name: 28, ctxt: 0};\n+    pub static statik : ident = ident { name: 29, ctxt: 0};\n+    pub static intrinsic : ident = ident { name: 30, ctxt: 0};\n+    pub static clownshoes_foreign_mod: ident = ident { name: 31, ctxt: 0};\n+    pub static unnamed_field: ident = ident { name: 32, ctxt: 0};\n+    pub static c_abi: ident = ident { name: 33, ctxt: 0};\n+    pub static type_self: ident = ident { name: 34, ctxt: 0};    // `Self`\n }\n \n pub struct StringRef<'self>(&'self str);\n@@ -394,25 +398,22 @@ pub struct ident_interner {\n }\n \n impl ident_interner {\n-    pub fn intern(&self, val: &str) -> ast::ident {\n-        ast::ident { repr: self.interner.intern(val), ctxt: 0 }\n+    pub fn intern(&self, val: &str) -> Name {\n+        self.interner.intern(val)\n     }\n-    pub fn gensym(&self, val: &str) -> ast::ident {\n-        ast::ident { repr: self.interner.gensym(val), ctxt: 0 }\n+    pub fn gensym(&self, val: &str) -> Name {\n+        self.interner.gensym(val)\n     }\n-    pub fn get(&self, idx: ast::ident) -> @~str {\n-        self.interner.get(idx.repr)\n+    pub fn get(&self, idx: Name) -> @~str {\n+        self.interner.get(idx)\n     }\n+    // is this really something that should be exposed?\n     pub fn len(&self) -> uint {\n         self.interner.len()\n     }\n-    pub fn find_equiv<Q:Hash +\n-                        IterBytes +\n-                        Equiv<@~str>>(&self, val: &Q) -> Option<ast::ident> {\n-        match self.interner.find_equiv(val) {\n-            Some(v) => Some(ast::ident { repr: v, ctxt: 0 }),\n-            None => None,\n-        }\n+    pub fn find_equiv<Q:Hash + IterBytes + Equiv<@~str>>(&self, val: &Q)\n+                                                     -> Option<Name> {\n+        self.interner.find_equiv(val)\n     }\n }\n \n@@ -530,11 +531,51 @@ pub fn mk_fake_ident_interner() -> @ident_interner {\n }\n \n // maps a string to its interned representation\n-pub fn intern(str : &str) -> ast::ident {\n+pub fn intern(str : &str) -> Name {\n     let interner = get_ident_interner();\n     interner.intern(str)\n }\n \n+// gensyms a new uint, using the current interner\n+pub fn gensym(str : &str) -> Name {\n+    let interner = get_ident_interner();\n+    interner.gensym(str)\n+}\n+\n+// map an interned representation back to a string\n+pub fn interner_get(name : Name) -> @~str {\n+    get_ident_interner().get(name)\n+}\n+\n+// maps an identifier to the string that it corresponds to\n+pub fn ident_to_str(id : &ast::ident) -> @~str {\n+    interner_get(id.name)\n+}\n+\n+// maps a string to an identifier with an empty syntax context\n+pub fn str_to_ident(str : &str) -> ast::ident {\n+    ast::new_ident(intern(str))\n+}\n+\n+// maps a string to a gensym'ed identifier\n+pub fn gensym_ident(str : &str) -> ast::ident {\n+    ast::new_ident(gensym(str))\n+}\n+\n+\n+// create a fresh name. In principle, this is just a\n+// gensym, but for debugging purposes, you'd like the\n+// resulting name to have a suggestive stringify, without\n+// paying the cost of guaranteeing that the name is\n+// truly unique.  I'm going to try to strike a balance\n+// by using a gensym with a name that has a random number\n+// at the end. So, the gensym guarantees the uniqueness,\n+// and the int helps to avoid confusion.\n+pub fn fresh_name(src_name : &str) -> Name {\n+    let num = rand::rng().gen_uint_range(0,0xffff);\n+   gensym(fmt!(\"%s_%u\",src_name,num))\n+}\n+\n /**\n  * All the valid words that have meaning in the Rust language.\n  *\n@@ -590,57 +631,57 @@ pub mod keywords {\n     impl Keyword {\n         pub fn to_ident(&self) -> ident {\n             match *self {\n-                As => ident { repr: 35, ctxt: 0 },\n-                   Break => ident { repr: 36, ctxt: 0 },\n-                   Const => ident { repr: 37, ctxt: 0 },\n-                   Copy => ident { repr: 38, ctxt: 0 },\n-                   Do => ident { repr: 39, ctxt: 0 },\n-                   Else => ident { repr: 41, ctxt: 0 },\n-                   Enum => ident { repr: 42, ctxt: 0 },\n-                   Extern => ident { repr: 43, ctxt: 0 },\n-                   False => ident { repr: 44, ctxt: 0 },\n-                   Fn => ident { repr: 45, ctxt: 0 },\n-                   For => ident { repr: 46, ctxt: 0 },\n-                   If => ident { repr: 47, ctxt: 0 },\n-                   Impl => ident { repr: 48, ctxt: 0 },\n-                   Let => ident { repr: 49, ctxt: 0 },\n-                   __Log => ident { repr: 50, ctxt: 0 },\n-                   Loop => ident { repr: 51, ctxt: 0 },\n-                   Match => ident { repr: 52, ctxt: 0 },\n-                   Mod => ident { repr: 53, ctxt: 0 },\n-                   Mut => ident { repr: 54, ctxt: 0 },\n-                   Once => ident { repr: 55, ctxt: 0 },\n-                   Priv => ident { repr: 56, ctxt: 0 },\n-                   Pub => ident { repr: 57, ctxt: 0 },\n-                   Pure => ident { repr: 58, ctxt: 0 },\n-                   Ref => ident { repr: 59, ctxt: 0 },\n-                   Return => ident { repr: 60, ctxt: 0 },\n-                   Static => ident { repr: 29, ctxt: 0 },\n-                   Self => ident { repr: 8, ctxt: 0 },\n-                   Struct => ident { repr: 61, ctxt: 0 },\n-                   Super => ident { repr: 62, ctxt: 0 },\n-                   True => ident { repr: 63, ctxt: 0 },\n-                   Trait => ident { repr: 64, ctxt: 0 },\n-                   Type => ident { repr: 65, ctxt: 0 },\n-                   Unsafe => ident { repr: 66, ctxt: 0 },\n-                   Use => ident { repr: 67, ctxt: 0 },\n-                   While => ident { repr: 68, ctxt: 0 },\n-                   Be => ident { repr: 69, ctxt: 0 },\n+                As => ident { name: 35, ctxt: 0 },\n+                   Break => ident { name: 36, ctxt: 0 },\n+                   Const => ident { name: 37, ctxt: 0 },\n+                   Copy => ident { name: 38, ctxt: 0 },\n+                   Do => ident { name: 39, ctxt: 0 },\n+                   Else => ident { name: 41, ctxt: 0 },\n+                   Enum => ident { name: 42, ctxt: 0 },\n+                   Extern => ident { name: 43, ctxt: 0 },\n+                   False => ident { name: 44, ctxt: 0 },\n+                   Fn => ident { name: 45, ctxt: 0 },\n+                   For => ident { name: 46, ctxt: 0 },\n+                   If => ident { name: 47, ctxt: 0 },\n+                   Impl => ident { name: 48, ctxt: 0 },\n+                   Let => ident { name: 49, ctxt: 0 },\n+                   __Log => ident { name: 50, ctxt: 0 },\n+                   Loop => ident { name: 51, ctxt: 0 },\n+                   Match => ident { name: 52, ctxt: 0 },\n+                   Mod => ident { name: 53, ctxt: 0 },\n+                   Mut => ident { name: 54, ctxt: 0 },\n+                   Once => ident { name: 55, ctxt: 0 },\n+                   Priv => ident { name: 56, ctxt: 0 },\n+                   Pub => ident { name: 57, ctxt: 0 },\n+                   Pure => ident { name: 58, ctxt: 0 },\n+                   Ref => ident { name: 59, ctxt: 0 },\n+                   Return => ident { name: 60, ctxt: 0 },\n+                   Static => ident { name: 29, ctxt: 0 },\n+                   Self => ident { name: 8, ctxt: 0 },\n+                   Struct => ident { name: 61, ctxt: 0 },\n+                   Super => ident { name: 62, ctxt: 0 },\n+                   True => ident { name: 63, ctxt: 0 },\n+                   Trait => ident { name: 64, ctxt: 0 },\n+                   Type => ident { name: 65, ctxt: 0 },\n+                   Unsafe => ident { name: 66, ctxt: 0 },\n+                   Use => ident { name: 67, ctxt: 0 },\n+                   While => ident { name: 68, ctxt: 0 },\n+                   Be => ident { name: 69, ctxt: 0 },\n             }\n         }\n     }\n }\n \n pub fn is_keyword(kw: keywords::Keyword, tok: &Token) -> bool {\n     match *tok {\n-        token::IDENT(sid, false) => { kw.to_ident().repr == sid.repr }\n+        token::IDENT(sid, false) => { kw.to_ident().name == sid.name }\n         _ => { false }\n     }\n }\n \n pub fn is_any_keyword(tok: &Token) -> bool {\n     match *tok {\n-        token::IDENT(sid, false) => match sid.repr {\n+        token::IDENT(sid, false) => match sid.name {\n             8 | 29 | 35 .. 69 => true,\n             _ => false,\n         },\n@@ -650,7 +691,7 @@ pub fn is_any_keyword(tok: &Token) -> bool {\n \n pub fn is_strict_keyword(tok: &Token) -> bool {\n     match *tok {\n-        token::IDENT(sid, false) => match sid.repr {\n+        token::IDENT(sid, false) => match sid.name {\n             8 | 29 | 35 .. 68 => true,\n             _ => false,\n         },\n@@ -660,10 +701,21 @@ pub fn is_strict_keyword(tok: &Token) -> bool {\n \n pub fn is_reserved_keyword(tok: &Token) -> bool {\n     match *tok {\n-        token::IDENT(sid, false) => match sid.repr {\n+        token::IDENT(sid, false) => match sid.name {\n             69 => true,\n             _ => false,\n         },\n         _ => false,\n     }\n }\n+\n+#[cfg(test)]\n+mod test {\n+    use super::*;\n+    use std::io;\n+    #[test] fn t1() {\n+        let a = fresh_name(\"ghi\");\n+        io::println(fmt!(\"interned name: %u,\\ntextual name: %s\\n\",\n+                         a,*interner_get(a)));\n+    }\n+}"}, {"sha": "57e78d3ad8409701f3664b2cb89fcfd04f6ad1a1", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0409f8610612e8261a0139ec9c57396089cea060/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0409f8610612e8261a0139ec9c57396089cea060/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=0409f8610612e8261a0139ec9c57396089cea060", "patch": "@@ -21,7 +21,7 @@ use codemap::{CodeMap, BytePos};\n use codemap;\n use diagnostic;\n use parse::classify::expr_is_simple_block;\n-use parse::token::ident_interner;\n+use parse::token::{ident_interner, ident_to_str};\n use parse::{comments, token};\n use parse;\n use print::pp::{break_offset, word, space, zerobreak, hardbreak};\n@@ -1475,7 +1475,7 @@ pub fn print_decl(s: @ps, decl: @ast::decl) {\n }\n \n pub fn print_ident(s: @ps, ident: ast::ident) {\n-    word(s.s, *s.intr.get(ident));\n+    word(s.s, *ident_to_str(&ident));\n }\n \n pub fn print_for_decl(s: @ps, loc: @ast::local, coll: @ast::expr) {\n@@ -2236,7 +2236,7 @@ mod test {\n     use codemap;\n     use core::cmp::Eq;\n     use core::option::None;\n-    use parse;\n+    use parse::token;\n \n     fn string_check<T:Eq> (given : &T, expected: &T) {\n         if !(given == expected) {\n@@ -2246,8 +2246,7 @@ mod test {\n \n     #[test]\n     fn test_fun_to_str() {\n-        let mock_interner = parse::token::mk_fake_ident_interner();\n-        let abba_ident = mock_interner.intern(\"abba\");\n+        let abba_ident = token::str_to_ident(\"abba\");\n \n         let decl = ast::fn_decl {\n             inputs: ~[],\n@@ -2258,14 +2257,13 @@ mod test {\n         };\n         let generics = ast_util::empty_generics();\n         assert_eq!(&fun_to_str(&decl, ast::impure_fn, abba_ident,\n-                               None, &generics, mock_interner),\n+                               None, &generics, token::get_ident_interner()),\n                    &~\"fn abba()\");\n     }\n \n     #[test]\n     fn test_variant_to_str() {\n-        let mock_interner = parse::token::mk_fake_ident_interner();\n-        let ident = mock_interner.intern(\"principal_skinner\");\n+        let ident = token::str_to_ident(\"principal_skinner\");\n \n         let var = codemap::respan(codemap::dummy_sp(), ast::variant_ {\n             name: ident,\n@@ -2277,7 +2275,7 @@ mod test {\n             vis: ast::public,\n         });\n \n-        let varstr = variant_to_str(&var,mock_interner);\n+        let varstr = variant_to_str(&var,token::get_ident_interner());\n         assert_eq!(&varstr,&~\"pub principal_skinner\");\n     }\n }"}, {"sha": "b55050184fedca88b1f3169f5f31b60df4fc42ec", "filename": "src/libsyntax/util/interner.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0409f8610612e8261a0139ec9c57396089cea060/src%2Flibsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0409f8610612e8261a0139ec9c57396089cea060/src%2Flibsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Finterner.rs?ref=0409f8610612e8261a0139ec9c57396089cea060", "patch": "@@ -64,9 +64,6 @@ impl<T:Eq + IterBytes + Hash + Const + Copy> Interner<T> {\n         new_idx\n     }\n \n-    // this isn't \"pure\" in the traditional sense, because it can go from\n-    // failing to returning a value as items are interned. But for typestate,\n-    // where we first check a pred and then rely on it, ceasing to fail is ok.\n     pub fn get(&self, idx: uint) -> T { self.vect[idx] }\n \n     pub fn len(&self) -> uint { let vect = &*self.vect; vect.len() }"}, {"sha": "c5528069926f0923d1a398802143a7cced0c17d0", "filename": "src/libsyntax/util/parser_testing.rs", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/0409f8610612e8261a0139ec9c57396089cea060/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0409f8610612e8261a0139ec9c57396089cea060/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fparser_testing.rs?ref=0409f8610612e8261a0139ec9c57396089cea060", "patch": "@@ -10,11 +10,11 @@\n \n use core::option::{Option,None};\n use ast;\n-use parse::parser::Parser;\n use parse::{new_parse_sess};\n-\n-use syntax::parse::{ParseSess,string_to_filemap,filemap_to_tts};\n-use syntax::parse::{new_parser_from_source_str};\n+use parse::{ParseSess,string_to_filemap,filemap_to_tts};\n+use parse::{new_parser_from_source_str};\n+use parse::parser::Parser;\n+use parse::token;\n \n // map a string to tts, using a made-up filename: return both the token_trees\n // and the ParseSess\n@@ -54,7 +54,18 @@ pub fn string_to_item_and_sess (source_str : @~str) -> (Option<@ast::item>,@mut\n     (p.parse_item(~[]),ps)\n }\n \n-pub fn string_to_stmt (source_str : @~str) -> @ast::stmt {\n+// parse a string, return a stmt\n+pub fn string_to_stmt(source_str : @~str) -> @ast::stmt {\n     string_to_parser(source_str).parse_stmt(~[])\n }\n \n+// parse a string, return a pat. Uses \"irrefutable\"... which doesn't\n+// (currently) affect parsing.\n+pub fn string_to_pat(source_str : @~str) -> @ast::pat {\n+    string_to_parser(source_str).parse_pat()\n+}\n+\n+// convert a vector of strings to a vector of ast::idents\n+pub fn strs_to_idents(ids: ~[&str]) -> ~[ast::ident] {\n+    ids.map(|u| token::str_to_ident(*u))\n+}"}]}