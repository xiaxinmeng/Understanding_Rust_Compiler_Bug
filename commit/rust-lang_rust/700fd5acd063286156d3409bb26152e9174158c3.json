{"sha": "700fd5acd063286156d3409bb26152e9174158c3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcwMGZkNWFjZDA2MzI4NjE1NmQzNDA5YmIyNjE1MmU5MTc0MTU4YzM=", "commit": {"author": {"name": "Mark Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2018-03-23T21:02:59Z"}, "committer": {"name": "Mark Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2018-03-23T21:02:59Z"}, "message": "Remove getopts leftover from tree\n\nThis was attempted but left incomplete in PR #42664, where only the toml\nfile was removed.", "tree": {"sha": "18c006b2fe59d4de68e461bc028ffbdf8d27bf7c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/18c006b2fe59d4de68e461bc028ffbdf8d27bf7c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/700fd5acd063286156d3409bb26152e9174158c3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/700fd5acd063286156d3409bb26152e9174158c3", "html_url": "https://github.com/rust-lang/rust/commit/700fd5acd063286156d3409bb26152e9174158c3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/700fd5acd063286156d3409bb26152e9174158c3/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "55e1104dd918a809d2751d325c11d59c85485a2e", "url": "https://api.github.com/repos/rust-lang/rust/commits/55e1104dd918a809d2751d325c11d59c85485a2e", "html_url": "https://github.com/rust-lang/rust/commit/55e1104dd918a809d2751d325c11d59c85485a2e"}], "stats": {"total": 1622, "additions": 0, "deletions": 1622}, "files": [{"sha": "81fa0374f549e903f5384737f1d000d6c4a8ba2d", "filename": "src/libgetopts/lib.rs", "status": "removed", "additions": 0, "deletions": 1622, "changes": 1622, "blob_url": "https://github.com/rust-lang/rust/blob/55e1104dd918a809d2751d325c11d59c85485a2e/src%2Flibgetopts%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55e1104dd918a809d2751d325c11d59c85485a2e/src%2Flibgetopts%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgetopts%2Flib.rs?ref=55e1104dd918a809d2751d325c11d59c85485a2e", "patch": "@@ -1,1622 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Simple getopt alternative.\n-//!\n-//! Construct a vector of options, either by using `reqopt`, `optopt`, and `optflag`\n-//! or by building them from components yourself, and pass them to `getopts`,\n-//! along with a vector of actual arguments (not including `argv[0]`). You'll\n-//! either get a failure code back, or a match. You'll have to verify whether\n-//! the amount of 'free' arguments in the match is what you expect. Use `opt_*`\n-//! accessors to get argument values out of the matches object.\n-//!\n-//! Single-character options are expected to appear on the command line with a\n-//! single preceding dash; multiple-character options are expected to be\n-//! proceeded by two dashes. Options that expect an argument accept their\n-//! argument following either a space or an equals sign. Single-character\n-//! options don't require the space.\n-//!\n-//! # Example\n-//!\n-//! The following example shows simple command line parsing for an application\n-//! that requires an input file to be specified, accepts an optional output\n-//! file name following `-o`, and accepts both `-h` and `--help` as optional flags.\n-//!\n-//! ```{.rust}\n-//! #![feature(rustc_private)]\n-//!\n-//! extern crate getopts;\n-//! use getopts::{optopt,optflag,getopts,OptGroup,usage};\n-//! use std::env;\n-//!\n-//! fn do_work(inp: &str, out: Option<String>) {\n-//!     println!(\"{}\", inp);\n-//!     match out {\n-//!         Some(x) => println!(\"{}\", x),\n-//!         None => println!(\"No Output\"),\n-//!     }\n-//! }\n-//!\n-//! fn print_usage(program: &str, opts: &[OptGroup]) {\n-//!     let brief = format!(\"Usage: {} [options]\", program);\n-//!     print!(\"{}\", usage(&brief, opts));\n-//! }\n-//!\n-//! fn main() {\n-//!     let args: Vec<String> = env::args().collect();\n-//!\n-//!     let program = args[0].clone();\n-//!\n-//!     let opts = &[\n-//!         optopt(\"o\", \"\", \"set output file name\", \"NAME\"),\n-//!         optflag(\"h\", \"help\", \"print this help menu\")\n-//!     ];\n-//!     let matches = match getopts(&args[1..], opts) {\n-//!         Ok(m) => { m }\n-//!         Err(f) => { panic!(f.to_string()) }\n-//!     };\n-//!     if matches.opt_present(\"h\") {\n-//!         print_usage(&program, opts);\n-//!         return;\n-//!     }\n-//!     let output = matches.opt_str(\"o\");\n-//!     let input = if !matches.free.is_empty() {\n-//!         matches.free[0].clone()\n-//!     } else {\n-//!         print_usage(&program, opts);\n-//!         return;\n-//!     };\n-//!     do_work(&input, output);\n-//! }\n-//! ```\n-\n-#![doc(html_logo_url = \"https://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n-       html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n-       html_root_url = \"https://doc.rust-lang.org/nightly/\",\n-       html_playground_url = \"https://play.rust-lang.org/\",\n-       test(attr(deny(warnings))))]\n-\n-#![deny(missing_docs)]\n-#![deny(warnings)]\n-\n-use self::Name::*;\n-use self::HasArg::*;\n-use self::Occur::*;\n-use self::Fail::*;\n-use self::Optval::*;\n-use self::SplitWithinState::*;\n-use self::Whitespace::*;\n-use self::LengthLimit::*;\n-\n-use std::fmt;\n-use std::iter::repeat;\n-use std::result;\n-\n-/// Name of an option. Either a string or a single char.\n-#[derive(Clone, PartialEq, Eq, Debug)]\n-pub enum Name {\n-    /// A string representing the long name of an option.\n-    /// For example: \"help\"\n-    Long(String),\n-    /// A char representing the short name of an option.\n-    /// For example: 'h'\n-    Short(char),\n-}\n-\n-/// Describes whether an option has an argument.\n-#[derive(Clone, Copy, PartialEq, Eq, Debug)]\n-pub enum HasArg {\n-    /// The option requires an argument.\n-    Yes,\n-    /// The option takes no argument.\n-    No,\n-    /// The option argument is optional.\n-    Maybe,\n-}\n-\n-/// Describes how often an option may occur.\n-#[derive(Clone, Copy, PartialEq, Eq, Debug)]\n-pub enum Occur {\n-    /// The option occurs once.\n-    Req,\n-    /// The option occurs at most once.\n-    Optional,\n-    /// The option occurs zero or more times.\n-    Multi,\n-}\n-\n-/// A description of a possible option.\n-#[derive(Clone, PartialEq, Eq, Debug)]\n-pub struct Opt {\n-    /// Name of the option\n-    pub name: Name,\n-    /// Whether it has an argument\n-    pub hasarg: HasArg,\n-    /// How often it can occur\n-    pub occur: Occur,\n-    /// Which options it aliases\n-    pub aliases: Vec<Opt>,\n-}\n-\n-/// One group of options, e.g., both `-h` and `--help`, along with\n-/// their shared description and properties.\n-#[derive(Clone, PartialEq, Eq, Debug)]\n-pub struct OptGroup {\n-    /// Short name of the option, e.g. `h` for a `-h` option\n-    pub short_name: String,\n-    /// Long name of the option, e.g. `help` for a `--help` option\n-    pub long_name: String,\n-    /// Hint for argument, e.g. `FILE` for a `-o FILE` option\n-    pub hint: String,\n-    /// Description for usage help text\n-    pub desc: String,\n-    /// Whether option has an argument\n-    pub hasarg: HasArg,\n-    /// How often it can occur\n-    pub occur: Occur,\n-}\n-\n-/// Describes whether an option is given at all or has a value.\n-#[derive(Clone, PartialEq, Eq, Debug)]\n-enum Optval {\n-    Val(String),\n-    Given,\n-}\n-\n-/// The result of checking command line arguments. Contains a vector\n-/// of matches and a vector of free strings.\n-#[derive(Clone, PartialEq, Eq, Debug)]\n-pub struct Matches {\n-    /// Options that matched\n-    opts: Vec<Opt>,\n-    /// Values of the Options that matched\n-    vals: Vec<Vec<Optval>>,\n-    /// Free string fragments\n-    pub free: Vec<String>,\n-}\n-\n-/// The type returned when the command line does not conform to the\n-/// expected format. Use the `Debug` implementation to output detailed\n-/// information.\n-#[derive(Clone, PartialEq, Eq, Debug)]\n-pub enum Fail {\n-    /// The option requires an argument but none was passed.\n-    ArgumentMissing(String),\n-    /// The passed option is not declared among the possible options.\n-    UnrecognizedOption(String),\n-    /// A required option is not present.\n-    OptionMissing(String),\n-    /// A single occurrence option is being used multiple times.\n-    OptionDuplicated(String),\n-    /// There's an argument being passed to a non-argument option.\n-    UnexpectedArgument(String),\n-}\n-\n-/// The type of failure that occurred.\n-#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n-#[allow(missing_docs)]\n-pub enum FailType {\n-    ArgumentMissing_,\n-    UnrecognizedOption_,\n-    OptionMissing_,\n-    OptionDuplicated_,\n-    UnexpectedArgument_,\n-}\n-\n-/// The result of parsing a command line with a set of options.\n-pub type Result = result::Result<Matches, Fail>;\n-\n-impl Name {\n-    fn from_str(nm: &str) -> Name {\n-        if nm.len() == 1 {\n-            Short(nm.chars().next().unwrap())\n-        } else {\n-            Long(nm.to_owned())\n-        }\n-    }\n-\n-    fn to_string(&self) -> String {\n-        match *self {\n-            Short(ch) => ch.to_string(),\n-            Long(ref s) => s.to_owned(),\n-        }\n-    }\n-}\n-\n-impl OptGroup {\n-    /// Translate OptGroup into Opt.\n-    /// (Both short and long names correspond to different Opts).\n-    pub fn long_to_short(&self) -> Opt {\n-        let OptGroup {\n-            short_name,\n-            long_name,\n-            hasarg,\n-            occur,\n-            ..\n-        } = (*self).clone();\n-\n-        match (short_name.len(), long_name.len()) {\n-            (0, 0) => panic!(\"this long-format option was given no name\"),\n-            (0, _) => {\n-                Opt {\n-                    name: Long((long_name)),\n-                    hasarg,\n-                    occur,\n-                    aliases: Vec::new(),\n-                }\n-            }\n-            (1, 0) => {\n-                Opt {\n-                    name: Short(short_name.chars().next().unwrap()),\n-                    hasarg,\n-                    occur,\n-                    aliases: Vec::new(),\n-                }\n-            }\n-            (1, _) => {\n-                Opt {\n-                    name: Long((long_name)),\n-                    hasarg,\n-                    occur,\n-                    aliases: vec![Opt {\n-                                      name: Short(short_name.chars().next().unwrap()),\n-                                      hasarg,\n-                                      occur,\n-                                      aliases: Vec::new(),\n-                                  }],\n-                }\n-            }\n-            _ => panic!(\"something is wrong with the long-form opt\"),\n-        }\n-    }\n-}\n-\n-impl Matches {\n-    fn opt_vals(&self, nm: &str) -> Vec<Optval> {\n-        match find_opt(&self.opts[..], Name::from_str(nm)) {\n-            Some(id) => self.vals[id].clone(),\n-            None => panic!(\"No option '{}' defined\", nm),\n-        }\n-    }\n-\n-    fn opt_val(&self, nm: &str) -> Option<Optval> {\n-        let vals = self.opt_vals(nm);\n-        if vals.is_empty() {\n-            None\n-        } else {\n-            Some(vals[0].clone())\n-        }\n-    }\n-\n-    /// Returns true if an option was matched.\n-    pub fn opt_present(&self, nm: &str) -> bool {\n-        !self.opt_vals(nm).is_empty()\n-    }\n-\n-    /// Returns the number of times an option was matched.\n-    pub fn opt_count(&self, nm: &str) -> usize {\n-        self.opt_vals(nm).len()\n-    }\n-\n-    /// Returns true if any of several options were matched.\n-    pub fn opts_present(&self, names: &[String]) -> bool {\n-        for nm in names {\n-            match find_opt(&self.opts, Name::from_str(&**nm)) {\n-                Some(id) if !self.vals[id].is_empty() => return true,\n-                _ => (),\n-            };\n-        }\n-        false\n-    }\n-\n-    /// Returns the string argument supplied to one of several matching options or `None`.\n-    pub fn opts_str(&self, names: &[String]) -> Option<String> {\n-        for nm in names {\n-            if let Some(Val(ref s)) = self.opt_val(&nm[..]) {\n-                  return Some(s.clone())\n-            }\n-        }\n-        None\n-    }\n-\n-    /// Returns a vector of the arguments provided to all matches of the given\n-    /// option.\n-    ///\n-    /// Used when an option accepts multiple values.\n-    pub fn opt_strs(&self, nm: &str) -> Vec<String> {\n-        let mut acc: Vec<String> = Vec::new();\n-        let r = self.opt_vals(nm);\n-        for v in &r {\n-            match *v {\n-                Val(ref s) => acc.push((*s).clone()),\n-                _ => (),\n-            }\n-        }\n-        acc\n-    }\n-\n-    /// Returns the string argument supplied to a matching option or `None`.\n-    pub fn opt_str(&self, nm: &str) -> Option<String> {\n-        let vals = self.opt_vals(nm);\n-        if vals.is_empty() {\n-            return None::<String>;\n-        }\n-        match vals[0] {\n-            Val(ref s) => Some((*s).clone()),\n-            _ => None,\n-        }\n-    }\n-\n-\n-    /// Returns the matching string, a default, or none.\n-    ///\n-    /// Returns none if the option was not present, `def` if the option was\n-    /// present but no argument was provided, and the argument if the option was\n-    /// present and an argument was provided.\n-    pub fn opt_default(&self, nm: &str, def: &str) -> Option<String> {\n-        let vals = self.opt_vals(nm);\n-        if vals.is_empty() {\n-            None\n-        } else {\n-            match vals[0] {\n-                Val(ref s) => Some((*s).clone()),\n-                _ => Some(def.to_owned()),\n-            }\n-        }\n-    }\n-}\n-\n-fn is_arg(arg: &str) -> bool {\n-    arg.len() > 1 && arg.as_bytes()[0] == b'-'\n-}\n-\n-fn find_opt(opts: &[Opt], nm: Name) -> Option<usize> {\n-    // Search main options.\n-    let pos = opts.iter().position(|opt| opt.name == nm);\n-    if pos.is_some() {\n-        return pos;\n-    }\n-\n-    // Search in aliases.\n-    for candidate in opts {\n-        if candidate.aliases.iter().position(|opt| opt.name == nm).is_some() {\n-            return opts.iter().position(|opt| opt.name == candidate.name);\n-        }\n-    }\n-\n-    None\n-}\n-\n-/// Create a long option that is required and takes an argument.\n-///\n-/// * `short_name` - e.g. `\"h\"` for a `-h` option, or `\"\"` for none\n-/// * `long_name` - e.g. `\"help\"` for a `--help` option, or `\"\"` for none\n-/// * `desc` - Description for usage help\n-/// * `hint` - Hint that is used in place of the argument in the usage help,\n-///   e.g. `\"FILE\"` for a `-o FILE` option\n-pub fn reqopt(short_name: &str, long_name: &str, desc: &str, hint: &str) -> OptGroup {\n-    let len = short_name.len();\n-    assert!(len == 1 || len == 0);\n-    OptGroup {\n-        short_name: short_name.to_owned(),\n-        long_name: long_name.to_owned(),\n-        hint: hint.to_owned(),\n-        desc: desc.to_owned(),\n-        hasarg: Yes,\n-        occur: Req,\n-    }\n-}\n-\n-/// Create a long option that is optional and takes an argument.\n-///\n-/// * `short_name` - e.g. `\"h\"` for a `-h` option, or `\"\"` for none\n-/// * `long_name` - e.g. `\"help\"` for a `--help` option, or `\"\"` for none\n-/// * `desc` - Description for usage help\n-/// * `hint` - Hint that is used in place of the argument in the usage help,\n-///   e.g. `\"FILE\"` for a `-o FILE` option\n-pub fn optopt(short_name: &str, long_name: &str, desc: &str, hint: &str) -> OptGroup {\n-    let len = short_name.len();\n-    assert!(len == 1 || len == 0);\n-    OptGroup {\n-        short_name: short_name.to_owned(),\n-        long_name: long_name.to_owned(),\n-        hint: hint.to_owned(),\n-        desc: desc.to_owned(),\n-        hasarg: Yes,\n-        occur: Optional,\n-    }\n-}\n-\n-/// Create a long option that is optional and does not take an argument.\n-///\n-/// * `short_name` - e.g. `\"h\"` for a `-h` option, or `\"\"` for none\n-/// * `long_name` - e.g. `\"help\"` for a `--help` option, or `\"\"` for none\n-/// * `desc` - Description for usage help\n-pub fn optflag(short_name: &str, long_name: &str, desc: &str) -> OptGroup {\n-    let len = short_name.len();\n-    assert!(len == 1 || len == 0);\n-    OptGroup {\n-        short_name: short_name.to_owned(),\n-        long_name: long_name.to_owned(),\n-        hint: \"\".to_owned(),\n-        desc: desc.to_owned(),\n-        hasarg: No,\n-        occur: Optional,\n-    }\n-}\n-\n-/// Create a long option that can occur more than once and does not\n-/// take an argument.\n-///\n-/// * `short_name` - e.g. `\"h\"` for a `-h` option, or `\"\"` for none\n-/// * `long_name` - e.g. `\"help\"` for a `--help` option, or `\"\"` for none\n-/// * `desc` - Description for usage help\n-pub fn optflagmulti(short_name: &str, long_name: &str, desc: &str) -> OptGroup {\n-    let len = short_name.len();\n-    assert!(len == 1 || len == 0);\n-    OptGroup {\n-        short_name: short_name.to_owned(),\n-        long_name: long_name.to_owned(),\n-        hint: \"\".to_owned(),\n-        desc: desc.to_owned(),\n-        hasarg: No,\n-        occur: Multi,\n-    }\n-}\n-\n-/// Create a long option that is optional and takes an optional argument.\n-///\n-/// * `short_name` - e.g. `\"h\"` for a `-h` option, or `\"\"` for none\n-/// * `long_name` - e.g. `\"help\"` for a `--help` option, or `\"\"` for none\n-/// * `desc` - Description for usage help\n-/// * `hint` - Hint that is used in place of the argument in the usage help,\n-///   e.g. `\"FILE\"` for a `-o FILE` option\n-pub fn optflagopt(short_name: &str, long_name: &str, desc: &str, hint: &str) -> OptGroup {\n-    let len = short_name.len();\n-    assert!(len == 1 || len == 0);\n-    OptGroup {\n-        short_name: short_name.to_owned(),\n-        long_name: long_name.to_owned(),\n-        hint: hint.to_owned(),\n-        desc: desc.to_owned(),\n-        hasarg: Maybe,\n-        occur: Optional,\n-    }\n-}\n-\n-/// Create a long option that is optional, takes an argument, and may occur\n-/// multiple times.\n-///\n-/// * `short_name` - e.g. `\"h\"` for a `-h` option, or `\"\"` for none\n-/// * `long_name` - e.g. `\"help\"` for a `--help` option, or `\"\"` for none\n-/// * `desc` - Description for usage help\n-/// * `hint` - Hint that is used in place of the argument in the usage help,\n-///   e.g. `\"FILE\"` for a `-o FILE` option\n-pub fn optmulti(short_name: &str, long_name: &str, desc: &str, hint: &str) -> OptGroup {\n-    let len = short_name.len();\n-    assert!(len == 1 || len == 0);\n-    OptGroup {\n-        short_name: short_name.to_owned(),\n-        long_name: long_name.to_owned(),\n-        hint: hint.to_owned(),\n-        desc: desc.to_owned(),\n-        hasarg: Yes,\n-        occur: Multi,\n-    }\n-}\n-\n-/// Create a generic option group, stating all parameters explicitly\n-pub fn opt(short_name: &str,\n-           long_name: &str,\n-           desc: &str,\n-           hint: &str,\n-           hasarg: HasArg,\n-           occur: Occur)\n-           -> OptGroup {\n-    let len = short_name.len();\n-    assert!(len == 1 || len == 0);\n-    OptGroup {\n-        short_name: short_name.to_owned(),\n-        long_name: long_name.to_owned(),\n-        hint: hint.to_owned(),\n-        desc: desc.to_owned(),\n-        hasarg,\n-        occur,\n-    }\n-}\n-\n-impl fmt::Display for Fail {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        match *self {\n-            ArgumentMissing(ref nm) => write!(f, \"Argument to option '{}' missing.\", *nm),\n-            UnrecognizedOption(ref nm) => write!(f, \"Unrecognized option: '{}'.\", *nm),\n-            OptionMissing(ref nm) => write!(f, \"Required option '{}' missing.\", *nm),\n-            OptionDuplicated(ref nm) => write!(f, \"Option '{}' given more than once.\", *nm),\n-            UnexpectedArgument(ref nm) => write!(f, \"Option '{}' does not take an argument.\", *nm),\n-        }\n-    }\n-}\n-\n-/// Parse command line arguments according to the provided options.\n-///\n-/// On success returns `Ok(Matches)`. Use methods such as `opt_present`\n-/// `opt_str`, etc. to interrogate results.\n-/// # Panics\n-///\n-/// Returns `Err(Fail)` on failure: use the `Debug` implementation of `Fail` to display\n-/// information about it.\n-pub fn getopts(args: &[String], optgrps: &[OptGroup]) -> Result {\n-    let opts: Vec<Opt> = optgrps.iter().map(|x| x.long_to_short()).collect();\n-    let n_opts = opts.len();\n-\n-    fn f(_x: usize) -> Vec<Optval> {\n-        Vec::new()\n-    }\n-\n-    let mut vals: Vec<_> = (0..n_opts).map(f).collect();\n-    let mut free: Vec<String> = Vec::new();\n-    let l = args.len();\n-    let mut i = 0;\n-    while i < l {\n-        let cur = args[i].clone();\n-        let curlen = cur.len();\n-        if !is_arg(&cur[..]) {\n-            free.push(cur);\n-        } else if cur == \"--\" {\n-            let mut j = i + 1;\n-            while j < l {\n-                free.push(args[j].clone());\n-                j += 1;\n-            }\n-            break;\n-        } else {\n-            let mut names;\n-            let mut i_arg = None;\n-            if cur.as_bytes()[1] == b'-' {\n-                let tail = &cur[2..curlen];\n-                let tail_eq: Vec<&str> = tail.splitn(2, '=').collect();\n-                if tail_eq.len() <= 1 {\n-                    names = vec![Long(tail.to_owned())];\n-                } else {\n-                    names = vec![Long(tail_eq[0].to_owned())];\n-                    i_arg = Some(tail_eq[1].to_owned());\n-                }\n-            } else {\n-                let mut j = 1;\n-                names = Vec::new();\n-                while j < curlen {\n-                    let ch = cur[j..].chars().next().unwrap();\n-                    let opt = Short(ch);\n-\n-                    // In a series of potential options (eg. -aheJ), if we\n-                    // see one which takes an argument, we assume all\n-                    // subsequent characters make up the argument. This\n-                    // allows options such as -L/usr/local/lib/foo to be\n-                    // interpreted correctly\n-\n-                    let opt_id = match find_opt(&opts, opt.clone()) {\n-                        Some(id) => id,\n-                        None => return Err(UnrecognizedOption(opt.to_string())),\n-                    };\n-\n-                    names.push(opt);\n-\n-                    let arg_follows = match opts[opt_id].hasarg {\n-                        Yes | Maybe => true,\n-                        No => false,\n-                    };\n-\n-                    let next = j + ch.len_utf8();\n-                    if arg_follows && next < curlen {\n-                        i_arg = Some((&cur[next..curlen]).to_owned());\n-                        break;\n-                    }\n-\n-                    j = next;\n-                }\n-            }\n-            let mut name_pos = 0;\n-            for nm in &names {\n-                name_pos += 1;\n-                let optid = match find_opt(&opts, (*nm).clone()) {\n-                    Some(id) => id,\n-                    None => return Err(UnrecognizedOption(nm.to_string())),\n-                };\n-                match opts[optid].hasarg {\n-                    No => {\n-                        if name_pos == names.len() && !i_arg.is_none() {\n-                            return Err(UnexpectedArgument(nm.to_string()));\n-                        }\n-                        let v = &mut vals[optid];\n-                        v.push(Given);\n-                    }\n-                    Maybe => {\n-                        if !i_arg.is_none() {\n-                            let v = &mut vals[optid];\n-                            v.push(Val((i_arg.clone()).unwrap()));\n-                        } else if name_pos < names.len() || i + 1 == l || is_arg(&args[i + 1][..]) {\n-                            let v = &mut vals[optid];\n-                            v.push(Given);\n-                        } else {\n-                            i += 1;\n-                            let v = &mut vals[optid];\n-                            v.push(Val(args[i].clone()));\n-                        }\n-                    }\n-                    Yes => {\n-                        if !i_arg.is_none() {\n-                            let v = &mut vals[optid];\n-                            v.push(Val(i_arg.clone().unwrap()));\n-                        } else if i + 1 == l {\n-                            return Err(ArgumentMissing(nm.to_string()));\n-                        } else {\n-                            i += 1;\n-                            let v = &mut vals[optid];\n-                            v.push(Val(args[i].clone()));\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-        i += 1;\n-    }\n-    for i in 0..n_opts {\n-        let n = vals[i].len();\n-        let occ = opts[i].occur;\n-        if occ == Req && n == 0 {\n-            return Err(OptionMissing(opts[i].name.to_string()));\n-        }\n-        if occ != Multi && n > 1 {\n-            return Err(OptionDuplicated(opts[i].name.to_string()));\n-        }\n-    }\n-    Ok(Matches {\n-        opts,\n-        vals,\n-        free,\n-    })\n-}\n-\n-/// Derive a usage message from a set of long options.\n-pub fn usage(brief: &str, opts: &[OptGroup]) -> String {\n-\n-    let desc_sep = format!(\"\\n{}\", repeat(\" \").take(24).collect::<String>());\n-\n-    let rows = opts.iter().map(|optref| {\n-        let OptGroup{short_name,\n-                     long_name,\n-                     hint,\n-                     desc,\n-                     hasarg,\n-                     ..} = (*optref).clone();\n-\n-        let mut row = repeat(\" \").take(4).collect::<String>();\n-\n-        // short option\n-        match short_name.len() {\n-            0 => {}\n-            1 => {\n-                row.push('-');\n-                row.push_str(&short_name[..]);\n-                row.push(' ');\n-            }\n-            _ => panic!(\"the short name should only be 1 ascii char long\"),\n-        }\n-\n-        // long option\n-        match long_name.len() {\n-            0 => {}\n-            _ => {\n-                row.push_str(\"--\");\n-                row.push_str(&long_name[..]);\n-                row.push(' ');\n-            }\n-        }\n-\n-        // arg\n-        match hasarg {\n-            No => {}\n-            Yes => row.push_str(&hint[..]),\n-            Maybe => {\n-                row.push('[');\n-                row.push_str(&hint[..]);\n-                row.push(']');\n-            }\n-        }\n-\n-        // FIXME(https://github.com/rust-lang-nursery/getopts/issues/7)\n-        // should be graphemes not codepoints\n-        //\n-        // here we just need to indent the start of the description\n-        let rowlen = row.chars().count();\n-        if rowlen < 24 {\n-            for _ in 0..24 - rowlen {\n-                row.push(' ');\n-            }\n-        } else {\n-            row.push_str(&desc_sep[..]);\n-        }\n-\n-        // Normalize desc to contain words separated by one space character\n-        let mut desc_normalized_whitespace = String::new();\n-        for word in desc.split_whitespace() {\n-            desc_normalized_whitespace.push_str(word);\n-            desc_normalized_whitespace.push(' ');\n-        }\n-\n-        // FIXME(https://github.com/rust-lang-nursery/getopts/issues/7)\n-        // should be graphemes not codepoints\n-        let mut desc_rows = Vec::new();\n-        each_split_within(&desc_normalized_whitespace[..], 54, |substr| {\n-            desc_rows.push(substr.to_owned());\n-            true\n-        });\n-\n-        // FIXME(https://github.com/rust-lang-nursery/getopts/issues/7)\n-        // should be graphemes not codepoints\n-        //\n-        // wrapped description\n-        row.push_str(&desc_rows.join(&desc_sep[..]));\n-\n-        row\n-    });\n-\n-    format!(\"{}\\n\\nOptions:\\n{}\\n\",\n-            brief,\n-            rows.collect::<Vec<String>>().join(\"\\n\"))\n-}\n-\n-fn format_option(opt: &OptGroup) -> String {\n-    let mut line = String::new();\n-\n-    if opt.occur != Req {\n-        line.push('[');\n-    }\n-\n-    // Use short_name is possible, but fallback to long_name.\n-    if !opt.short_name.is_empty() {\n-        line.push('-');\n-        line.push_str(&opt.short_name[..]);\n-    } else {\n-        line.push_str(\"--\");\n-        line.push_str(&opt.long_name[..]);\n-    }\n-\n-    if opt.hasarg != No {\n-        line.push(' ');\n-        if opt.hasarg == Maybe {\n-            line.push('[');\n-        }\n-        line.push_str(&opt.hint[..]);\n-        if opt.hasarg == Maybe {\n-            line.push(']');\n-        }\n-    }\n-\n-    if opt.occur != Req {\n-        line.push(']');\n-    }\n-    if opt.occur == Multi {\n-        line.push_str(\"..\");\n-    }\n-\n-    line\n-}\n-\n-/// Derive a short one-line usage summary from a set of long options.\n-pub fn short_usage(program_name: &str, opts: &[OptGroup]) -> String {\n-    let mut line = format!(\"Usage: {} \", program_name);\n-    line.push_str(&opts.iter()\n-                       .map(format_option)\n-                       .collect::<Vec<String>>()\n-                       .join(\" \")[..]);\n-    line\n-}\n-\n-#[derive(Copy, Clone)]\n-enum SplitWithinState {\n-    A, // leading whitespace, initial state\n-    B, // words\n-    C, // internal and trailing whitespace\n-}\n-#[derive(Copy, Clone)]\n-enum Whitespace {\n-    Ws, // current char is whitespace\n-    Cr, // current char is not whitespace\n-}\n-#[derive(Copy, Clone)]\n-enum LengthLimit {\n-    UnderLim, // current char makes current substring still fit in limit\n-    OverLim, // current char makes current substring no longer fit in limit\n-}\n-\n-\n-/// Splits a string into substrings with possibly internal whitespace,\n-/// each of them at most `lim` bytes long. The substrings have leading and trailing\n-/// whitespace removed, and are only cut at whitespace boundaries.\n-///\n-/// Note: Function was moved here from `std::str` because this module is the only place that\n-/// uses it, and because it was too specific for a general string function.\n-///\n-/// # Panics\n-///\n-/// Panics during iteration if the string contains a non-whitespace\n-/// sequence longer than the limit.\n-fn each_split_within<F>(ss: &str, lim: usize, mut it: F) -> bool\n-    where F: FnMut(&str) -> bool\n-{\n-    // Just for fun, let's write this as a state machine:\n-\n-    let mut slice_start = 0;\n-    let mut last_start = 0;\n-    let mut last_end = 0;\n-    let mut state = A;\n-    let mut fake_i = ss.len();\n-    let mut lim = lim;\n-\n-    let mut cont = true;\n-\n-    // if the limit is larger than the string, lower it to save cycles\n-    if lim >= fake_i {\n-        lim = fake_i;\n-    }\n-\n-    let mut machine = |cont: &mut bool, (i, c): (usize, char)| -> bool {\n-        let whitespace = if c.is_whitespace() {\n-            Ws\n-        } else {\n-            Cr\n-        };\n-        let limit = if (i - slice_start + 1) <= lim {\n-            UnderLim\n-        } else {\n-            OverLim\n-        };\n-\n-        state = match (state, whitespace, limit) {\n-            (A, Ws, _) => A,\n-            (A, Cr, _) => {\n-                slice_start = i;\n-                last_start = i;\n-                B\n-            }\n-\n-            (B, Cr, UnderLim) => B,\n-            (B, Cr, OverLim) if (i - last_start + 1) > lim => {\n-                panic!(\"word starting with {} longer than limit!\",\n-                       &ss[last_start..i + 1])\n-            }\n-            (B, Cr, OverLim) => {\n-                *cont = it(&ss[slice_start..last_end]);\n-                slice_start = last_start;\n-                B\n-            }\n-            (B, Ws, UnderLim) => {\n-                last_end = i;\n-                C\n-            }\n-            (B, Ws, OverLim) => {\n-                last_end = i;\n-                *cont = it(&ss[slice_start..last_end]);\n-                A\n-            }\n-\n-            (C, Cr, UnderLim) => {\n-                last_start = i;\n-                B\n-            }\n-            (C, Cr, OverLim) => {\n-                *cont = it(&ss[slice_start..last_end]);\n-                slice_start = i;\n-                last_start = i;\n-                last_end = i;\n-                B\n-            }\n-            (C, Ws, OverLim) => {\n-                *cont = it(&ss[slice_start..last_end]);\n-                A\n-            }\n-            (C, Ws, UnderLim) => C,\n-        };\n-\n-        *cont\n-    };\n-\n-    ss.char_indices().all(|x| machine(&mut cont, x));\n-\n-    // Let the automaton 'run out' by supplying trailing whitespace\n-    while cont &&\n-          match state {\n-        B | C => true,\n-        A => false,\n-    } {\n-        machine(&mut cont, (fake_i, ' '));\n-        fake_i += 1;\n-    }\n-    cont\n-}\n-\n-#[test]\n-fn test_split_within() {\n-    fn t(s: &str, i: usize, u: &[String]) {\n-        let mut v = Vec::new();\n-        each_split_within(s, i, |s| {\n-            v.push(s.to_string());\n-            true\n-        });\n-        assert!(v.iter().zip(u).all(|(a, b)| a == b));\n-    }\n-    t(\"\", 0, &[]);\n-    t(\"\", 15, &[]);\n-    t(\"hello\", 15, &[\"hello\".to_string()]);\n-    t(\"\\nMary had a little lamb\\nLittle lamb\\n\",\n-      15,\n-      &[\"Mary had a\".to_string(), \"little lamb\".to_string(), \"Little lamb\".to_string()]);\n-    t(\"\\nMary had a little lamb\\nLittle lamb\\n\",\n-      ::std::usize::MAX,\n-      &[\"Mary had a little lamb\\nLittle lamb\".to_string()]);\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use super::*;\n-\n-    use std::result::Result::{Err, Ok};\n-    use std::result;\n-\n-    // Tests for reqopt\n-    #[test]\n-    fn test_reqopt() {\n-        let long_args = vec![\"--test=20\".to_string()];\n-        let opts = vec![reqopt(\"t\", \"test\", \"testing\", \"TEST\")];\n-        let rs = getopts(&long_args, &opts);\n-        match rs {\n-            Ok(ref m) => {\n-                assert!(m.opt_present(\"test\"));\n-                assert_eq!(m.opt_str(\"test\").unwrap(), \"20\");\n-                assert!(m.opt_present(\"t\"));\n-                assert_eq!(m.opt_str(\"t\").unwrap(), \"20\");\n-            }\n-            _ => {\n-                panic!(\"test_reqopt failed (long arg)\");\n-            }\n-        }\n-        let short_args = vec![\"-t\".to_string(), \"20\".to_string()];\n-        match getopts(&short_args, &opts) {\n-            Ok(ref m) => {\n-                assert!((m.opt_present(\"test\")));\n-                assert_eq!(m.opt_str(\"test\").unwrap(), \"20\");\n-                assert!((m.opt_present(\"t\")));\n-                assert_eq!(m.opt_str(\"t\").unwrap(), \"20\");\n-            }\n-            _ => {\n-                panic!(\"test_reqopt failed (short arg)\");\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn test_reqopt_missing() {\n-        let args = vec![\"blah\".to_string()];\n-        let opts = vec![reqopt(\"t\", \"test\", \"testing\", \"TEST\")];\n-        let rs = getopts(&args, &opts);\n-        match rs {\n-            Err(OptionMissing(_)) => {}\n-            _ => panic!(),\n-        }\n-    }\n-\n-    #[test]\n-    fn test_reqopt_no_arg() {\n-        let long_args = vec![\"--test\".to_string()];\n-        let opts = vec![reqopt(\"t\", \"test\", \"testing\", \"TEST\")];\n-        let rs = getopts(&long_args, &opts);\n-        match rs {\n-            Err(ArgumentMissing(_)) => {}\n-            _ => panic!(),\n-        }\n-        let short_args = vec![\"-t\".to_string()];\n-        match getopts(&short_args, &opts) {\n-            Err(ArgumentMissing(_)) => {}\n-            _ => panic!(),\n-        }\n-    }\n-\n-    #[test]\n-    fn test_reqopt_multi() {\n-        let args = vec![\"--test=20\".to_string(), \"-t\".to_string(), \"30\".to_string()];\n-        let opts = vec![reqopt(\"t\", \"test\", \"testing\", \"TEST\")];\n-        let rs = getopts(&args, &opts);\n-        match rs {\n-            Err(OptionDuplicated(_)) => {}\n-            _ => panic!(),\n-        }\n-    }\n-\n-    // Tests for optopt\n-    #[test]\n-    fn test_optopt() {\n-        let long_args = vec![\"--test=20\".to_string()];\n-        let opts = vec![optopt(\"t\", \"test\", \"testing\", \"TEST\")];\n-        let rs = getopts(&long_args, &opts);\n-        match rs {\n-            Ok(ref m) => {\n-                assert!(m.opt_present(\"test\"));\n-                assert_eq!(m.opt_str(\"test\").unwrap(), \"20\");\n-                assert!((m.opt_present(\"t\")));\n-                assert_eq!(m.opt_str(\"t\").unwrap(), \"20\");\n-            }\n-            _ => panic!(),\n-        }\n-        let short_args = vec![\"-t\".to_string(), \"20\".to_string()];\n-        match getopts(&short_args, &opts) {\n-            Ok(ref m) => {\n-                assert!((m.opt_present(\"test\")));\n-                assert_eq!(m.opt_str(\"test\").unwrap(), \"20\");\n-                assert!((m.opt_present(\"t\")));\n-                assert_eq!(m.opt_str(\"t\").unwrap(), \"20\");\n-            }\n-            _ => panic!(),\n-        }\n-    }\n-\n-    #[test]\n-    fn test_optopt_missing() {\n-        let args = vec![\"blah\".to_string()];\n-        let opts = vec![optopt(\"t\", \"test\", \"testing\", \"TEST\")];\n-        let rs = getopts(&args, &opts);\n-        match rs {\n-            Ok(ref m) => {\n-                assert!(!m.opt_present(\"test\"));\n-                assert!(!m.opt_present(\"t\"));\n-            }\n-            _ => panic!(),\n-        }\n-    }\n-\n-    #[test]\n-    fn test_optopt_no_arg() {\n-        let long_args = vec![\"--test\".to_string()];\n-        let opts = vec![optopt(\"t\", \"test\", \"testing\", \"TEST\")];\n-        let rs = getopts(&long_args, &opts);\n-        match rs {\n-            Err(ArgumentMissing(_)) => {}\n-            _ => panic!(),\n-        }\n-        let short_args = vec![\"-t\".to_string()];\n-        match getopts(&short_args, &opts) {\n-            Err(ArgumentMissing(_)) => {}\n-            _ => panic!(),\n-        }\n-    }\n-\n-    #[test]\n-    fn test_optopt_multi() {\n-        let args = vec![\"--test=20\".to_string(), \"-t\".to_string(), \"30\".to_string()];\n-        let opts = vec![optopt(\"t\", \"test\", \"testing\", \"TEST\")];\n-        let rs = getopts(&args, &opts);\n-        match rs {\n-            Err(OptionDuplicated(_)) => {}\n-            _ => panic!(),\n-        }\n-    }\n-\n-    // Tests for optflag\n-    #[test]\n-    fn test_optflag() {\n-        let long_args = vec![\"--test\".to_string()];\n-        let opts = vec![optflag(\"t\", \"test\", \"testing\")];\n-        let rs = getopts(&long_args, &opts);\n-        match rs {\n-            Ok(ref m) => {\n-                assert!(m.opt_present(\"test\"));\n-                assert!(m.opt_present(\"t\"));\n-            }\n-            _ => panic!(),\n-        }\n-        let short_args = vec![\"-t\".to_string()];\n-        match getopts(&short_args, &opts) {\n-            Ok(ref m) => {\n-                assert!(m.opt_present(\"test\"));\n-                assert!(m.opt_present(\"t\"));\n-            }\n-            _ => panic!(),\n-        }\n-    }\n-\n-    #[test]\n-    fn test_optflag_missing() {\n-        let args = vec![\"blah\".to_string()];\n-        let opts = vec![optflag(\"t\", \"test\", \"testing\")];\n-        let rs = getopts(&args, &opts);\n-        match rs {\n-            Ok(ref m) => {\n-                assert!(!m.opt_present(\"test\"));\n-                assert!(!m.opt_present(\"t\"));\n-            }\n-            _ => panic!(),\n-        }\n-    }\n-\n-    #[test]\n-    fn test_optflag_long_arg() {\n-        let args = vec![\"--test=20\".to_string()];\n-        let opts = vec![optflag(\"t\", \"test\", \"testing\")];\n-        let rs = getopts(&args, &opts);\n-        match rs {\n-            Err(UnexpectedArgument(_)) => {}\n-            _ => panic!(),\n-        }\n-    }\n-\n-    #[test]\n-    fn test_optflag_multi() {\n-        let args = vec![\"--test\".to_string(), \"-t\".to_string()];\n-        let opts = vec![optflag(\"t\", \"test\", \"testing\")];\n-        let rs = getopts(&args, &opts);\n-        match rs {\n-            Err(OptionDuplicated(_)) => {}\n-            _ => panic!(),\n-        }\n-    }\n-\n-    #[test]\n-    fn test_optflag_short_arg() {\n-        let args = vec![\"-t\".to_string(), \"20\".to_string()];\n-        let opts = vec![optflag(\"t\", \"test\", \"testing\")];\n-        let rs = getopts(&args, &opts);\n-        match rs {\n-            Ok(ref m) => {\n-                // The next variable after the flag is just a free argument\n-\n-                assert!(m.free[0] == \"20\");\n-            }\n-            _ => panic!(),\n-        }\n-    }\n-\n-    // Tests for optflagmulti\n-    #[test]\n-    fn test_optflagmulti_short1() {\n-        let args = vec![\"-v\".to_string()];\n-        let opts = vec![optflagmulti(\"v\", \"verbose\", \"verbosity\")];\n-        let rs = getopts(&args, &opts);\n-        match rs {\n-            Ok(ref m) => {\n-                assert_eq!(m.opt_count(\"v\"), 1);\n-            }\n-            _ => panic!(),\n-        }\n-    }\n-\n-    #[test]\n-    fn test_optflagmulti_short2a() {\n-        let args = vec![\"-v\".to_string(), \"-v\".to_string()];\n-        let opts = vec![optflagmulti(\"v\", \"verbose\", \"verbosity\")];\n-        let rs = getopts(&args, &opts);\n-        match rs {\n-            Ok(ref m) => {\n-                assert_eq!(m.opt_count(\"v\"), 2);\n-            }\n-            _ => panic!(),\n-        }\n-    }\n-\n-    #[test]\n-    fn test_optflagmulti_short2b() {\n-        let args = vec![\"-vv\".to_string()];\n-        let opts = vec![optflagmulti(\"v\", \"verbose\", \"verbosity\")];\n-        let rs = getopts(&args, &opts);\n-        match rs {\n-            Ok(ref m) => {\n-                assert_eq!(m.opt_count(\"v\"), 2);\n-            }\n-            _ => panic!(),\n-        }\n-    }\n-\n-    #[test]\n-    fn test_optflagmulti_long1() {\n-        let args = vec![\"--verbose\".to_string()];\n-        let opts = vec![optflagmulti(\"v\", \"verbose\", \"verbosity\")];\n-        let rs = getopts(&args, &opts);\n-        match rs {\n-            Ok(ref m) => {\n-                assert_eq!(m.opt_count(\"verbose\"), 1);\n-            }\n-            _ => panic!(),\n-        }\n-    }\n-\n-    #[test]\n-    fn test_optflagmulti_long2() {\n-        let args = vec![\"--verbose\".to_string(), \"--verbose\".to_string()];\n-        let opts = vec![optflagmulti(\"v\", \"verbose\", \"verbosity\")];\n-        let rs = getopts(&args, &opts);\n-        match rs {\n-            Ok(ref m) => {\n-                assert_eq!(m.opt_count(\"verbose\"), 2);\n-            }\n-            _ => panic!(),\n-        }\n-    }\n-\n-    #[test]\n-    fn test_optflagmulti_mix() {\n-        let args = vec![\"--verbose\".to_string(),\n-                        \"-v\".to_string(),\n-                        \"-vv\".to_string(),\n-                        \"verbose\".to_string()];\n-        let opts = vec![optflagmulti(\"v\", \"verbose\", \"verbosity\")];\n-        let rs = getopts(&args, &opts);\n-        match rs {\n-            Ok(ref m) => {\n-                assert_eq!(m.opt_count(\"verbose\"), 4);\n-                assert_eq!(m.opt_count(\"v\"), 4);\n-            }\n-            _ => panic!(),\n-        }\n-    }\n-\n-    // Tests for optmulti\n-    #[test]\n-    fn test_optmulti() {\n-        let long_args = vec![\"--test=20\".to_string()];\n-        let opts = vec![optmulti(\"t\", \"test\", \"testing\", \"TEST\")];\n-        let rs = getopts(&long_args, &opts);\n-        match rs {\n-            Ok(ref m) => {\n-                assert!((m.opt_present(\"test\")));\n-                assert_eq!(m.opt_str(\"test\").unwrap(), \"20\");\n-                assert!((m.opt_present(\"t\")));\n-                assert_eq!(m.opt_str(\"t\").unwrap(), \"20\");\n-            }\n-            _ => panic!(),\n-        }\n-        let short_args = vec![\"-t\".to_string(), \"20\".to_string()];\n-        match getopts(&short_args, &opts) {\n-            Ok(ref m) => {\n-                assert!((m.opt_present(\"test\")));\n-                assert_eq!(m.opt_str(\"test\").unwrap(), \"20\");\n-                assert!((m.opt_present(\"t\")));\n-                assert_eq!(m.opt_str(\"t\").unwrap(), \"20\");\n-            }\n-            _ => panic!(),\n-        }\n-    }\n-\n-    #[test]\n-    fn test_optmulti_missing() {\n-        let args = vec![\"blah\".to_string()];\n-        let opts = vec![optmulti(\"t\", \"test\", \"testing\", \"TEST\")];\n-        let rs = getopts(&args, &opts);\n-        match rs {\n-            Ok(ref m) => {\n-                assert!(!m.opt_present(\"test\"));\n-                assert!(!m.opt_present(\"t\"));\n-            }\n-            _ => panic!(),\n-        }\n-    }\n-\n-    #[test]\n-    fn test_optmulti_no_arg() {\n-        let long_args = vec![\"--test\".to_string()];\n-        let opts = vec![optmulti(\"t\", \"test\", \"testing\", \"TEST\")];\n-        let rs = getopts(&long_args, &opts);\n-        match rs {\n-            Err(ArgumentMissing(_)) => {}\n-            _ => panic!(),\n-        }\n-        let short_args = vec![\"-t\".to_string()];\n-        match getopts(&short_args, &opts) {\n-            Err(ArgumentMissing(_)) => {}\n-            _ => panic!(),\n-        }\n-    }\n-\n-    #[test]\n-    fn test_optmulti_multi() {\n-        let args = vec![\"--test=20\".to_string(), \"-t\".to_string(), \"30\".to_string()];\n-        let opts = vec![optmulti(\"t\", \"test\", \"testing\", \"TEST\")];\n-        let rs = getopts(&args, &opts);\n-        match rs {\n-            Ok(ref m) => {\n-                assert!(m.opt_present(\"test\"));\n-                assert_eq!(m.opt_str(\"test\").unwrap(), \"20\");\n-                assert!(m.opt_present(\"t\"));\n-                assert_eq!(m.opt_str(\"t\").unwrap(), \"20\");\n-                let pair = m.opt_strs(\"test\");\n-                assert!(pair[0] == \"20\");\n-                assert!(pair[1] == \"30\");\n-            }\n-            _ => panic!(),\n-        }\n-    }\n-\n-    #[test]\n-    fn test_unrecognized_option() {\n-        let long_args = vec![\"--untest\".to_string()];\n-        let opts = vec![optmulti(\"t\", \"test\", \"testing\", \"TEST\")];\n-        let rs = getopts(&long_args, &opts);\n-        match rs {\n-            Err(UnrecognizedOption(_)) => {}\n-            _ => panic!(),\n-        }\n-        let short_args = vec![\"-u\".to_string()];\n-        match getopts(&short_args, &opts) {\n-            Err(UnrecognizedOption(_)) => {}\n-            _ => panic!(),\n-        }\n-    }\n-\n-    #[test]\n-    fn test_combined() {\n-        let args = vec![\"prog\".to_string(),\n-                        \"free1\".to_string(),\n-                        \"-s\".to_string(),\n-                        \"20\".to_string(),\n-                        \"free2\".to_string(),\n-                        \"--flag\".to_string(),\n-                        \"--long=30\".to_string(),\n-                        \"-f\".to_string(),\n-                        \"-m\".to_string(),\n-                        \"40\".to_string(),\n-                        \"-m\".to_string(),\n-                        \"50\".to_string(),\n-                        \"-n\".to_string(),\n-                        \"-A B\".to_string(),\n-                        \"-n\".to_string(),\n-                        \"-60 70\".to_string()];\n-        let opts = vec![optopt(\"s\", \"something\", \"something\", \"SOMETHING\"),\n-                        optflag(\"\", \"flag\", \"a flag\"),\n-                        reqopt(\"\", \"long\", \"hi\", \"LONG\"),\n-                        optflag(\"f\", \"\", \"another flag\"),\n-                        optmulti(\"m\", \"\", \"mmmmmm\", \"YUM\"),\n-                        optmulti(\"n\", \"\", \"nothing\", \"NOTHING\"),\n-                        optopt(\"\", \"notpresent\", \"nothing to see here\", \"NOPE\")];\n-        let rs = getopts(&args, &opts);\n-        match rs {\n-            Ok(ref m) => {\n-                assert!(m.free[0] == \"prog\");\n-                assert!(m.free[1] == \"free1\");\n-                assert_eq!(m.opt_str(\"s\").unwrap(), \"20\");\n-                assert!(m.free[2] == \"free2\");\n-                assert!((m.opt_present(\"flag\")));\n-                assert_eq!(m.opt_str(\"long\").unwrap(), \"30\");\n-                assert!((m.opt_present(\"f\")));\n-                let pair = m.opt_strs(\"m\");\n-                assert!(pair[0] == \"40\");\n-                assert!(pair[1] == \"50\");\n-                let pair = m.opt_strs(\"n\");\n-                assert!(pair[0] == \"-A B\");\n-                assert!(pair[1] == \"-60 70\");\n-                assert!((!m.opt_present(\"notpresent\")));\n-            }\n-            _ => panic!(),\n-        }\n-    }\n-\n-    #[test]\n-    fn test_multi() {\n-        let opts = vec![optopt(\"e\", \"\", \"encrypt\", \"ENCRYPT\"),\n-                        optopt(\"\", \"encrypt\", \"encrypt\", \"ENCRYPT\"),\n-                        optopt(\"f\", \"\", \"flag\", \"FLAG\")];\n-\n-        let args_single = vec![\"-e\".to_string(), \"foo\".to_string()];\n-        let matches_single = &match getopts(&args_single, &opts) {\n-            result::Result::Ok(m) => m,\n-            result::Result::Err(_) => panic!(),\n-        };\n-        assert!(matches_single.opts_present(&[\"e\".to_string()]));\n-        assert!(matches_single.opts_present(&[\"encrypt\".to_string(), \"e\".to_string()]));\n-        assert!(matches_single.opts_present(&[\"e\".to_string(), \"encrypt\".to_string()]));\n-        assert!(!matches_single.opts_present(&[\"encrypt\".to_string()]));\n-        assert!(!matches_single.opts_present(&[\"thing\".to_string()]));\n-        assert!(!matches_single.opts_present(&[]));\n-\n-        assert_eq!(matches_single.opts_str(&[\"e\".to_string()]).unwrap(), \"foo\");\n-        assert_eq!(matches_single.opts_str(&[\"e\".to_string(), \"encrypt\".to_string()]).unwrap(),\n-                   \"foo\");\n-        assert_eq!(matches_single.opts_str(&[\"encrypt\".to_string(), \"e\".to_string()]).unwrap(),\n-                   \"foo\");\n-\n-        let args_both = vec![\"-e\".to_string(),\n-                             \"foo\".to_string(),\n-                             \"--encrypt\".to_string(),\n-                             \"foo\".to_string()];\n-        let matches_both = &match getopts(&args_both, &opts) {\n-            result::Result::Ok(m) => m,\n-            result::Result::Err(_) => panic!(),\n-        };\n-        assert!(matches_both.opts_present(&[\"e\".to_string()]));\n-        assert!(matches_both.opts_present(&[\"encrypt\".to_string()]));\n-        assert!(matches_both.opts_present(&[\"encrypt\".to_string(), \"e\".to_string()]));\n-        assert!(matches_both.opts_present(&[\"e\".to_string(), \"encrypt\".to_string()]));\n-        assert!(!matches_both.opts_present(&[\"f\".to_string()]));\n-        assert!(!matches_both.opts_present(&[\"thing\".to_string()]));\n-        assert!(!matches_both.opts_present(&[]));\n-\n-        assert_eq!(matches_both.opts_str(&[\"e\".to_string()]).unwrap(), \"foo\");\n-        assert_eq!(matches_both.opts_str(&[\"encrypt\".to_string()]).unwrap(),\n-                   \"foo\");\n-        assert_eq!(matches_both.opts_str(&[\"e\".to_string(), \"encrypt\".to_string()]).unwrap(),\n-                   \"foo\");\n-        assert_eq!(matches_both.opts_str(&[\"encrypt\".to_string(), \"e\".to_string()]).unwrap(),\n-                   \"foo\");\n-    }\n-\n-    #[test]\n-    fn test_nospace() {\n-        let args = vec![\"-Lfoo\".to_string(), \"-M.\".to_string()];\n-        let opts = vec![optmulti(\"L\", \"\", \"library directory\", \"LIB\"),\n-                        optmulti(\"M\", \"\", \"something\", \"MMMM\")];\n-        let matches = &match getopts(&args, &opts) {\n-            result::Result::Ok(m) => m,\n-            result::Result::Err(_) => panic!(),\n-        };\n-        assert!(matches.opts_present(&[\"L\".to_string()]));\n-        assert_eq!(matches.opts_str(&[\"L\".to_string()]).unwrap(), \"foo\");\n-        assert!(matches.opts_present(&[\"M\".to_string()]));\n-        assert_eq!(matches.opts_str(&[\"M\".to_string()]).unwrap(), \".\");\n-\n-    }\n-\n-    #[test]\n-    fn test_nospace_conflict() {\n-        let args = vec![\"-vvLverbose\".to_string(), \"-v\".to_string()];\n-        let opts = vec![optmulti(\"L\", \"\", \"library directory\", \"LIB\"),\n-                        optflagmulti(\"v\", \"verbose\", \"Verbose\")];\n-        let matches = &match getopts(&args, &opts) {\n-            result::Result::Ok(m) => m,\n-            result::Result::Err(e) => panic!(\"{}\", e),\n-        };\n-        assert!(matches.opts_present(&[\"L\".to_string()]));\n-        assert_eq!(matches.opts_str(&[\"L\".to_string()]).unwrap(), \"verbose\");\n-        assert!(matches.opts_present(&[\"v\".to_string()]));\n-        assert_eq!(3, matches.opt_count(\"v\"));\n-    }\n-\n-    #[test]\n-    fn test_long_to_short() {\n-        let mut short = Opt {\n-            name: Name::Long(\"banana\".to_string()),\n-            hasarg: HasArg::Yes,\n-            occur: Occur::Req,\n-            aliases: Vec::new(),\n-        };\n-        short.aliases = vec![Opt {\n-                                 name: Name::Short('b'),\n-                                 hasarg: HasArg::Yes,\n-                                 occur: Occur::Req,\n-                                 aliases: Vec::new(),\n-                             }];\n-        let verbose = reqopt(\"b\", \"banana\", \"some bananas\", \"VAL\");\n-\n-        assert!(verbose.long_to_short() == short);\n-    }\n-\n-    #[test]\n-    fn test_aliases_long_and_short() {\n-        let opts = vec![optflagmulti(\"a\", \"apple\", \"Desc\")];\n-\n-        let args = vec![\"-a\".to_string(), \"--apple\".to_string(), \"-a\".to_string()];\n-\n-        let matches = getopts(&args, &opts).unwrap();\n-        assert_eq!(3, matches.opt_count(\"a\"));\n-        assert_eq!(3, matches.opt_count(\"apple\"));\n-    }\n-\n-    #[test]\n-    fn test_usage() {\n-        let optgroups = vec![reqopt(\"b\", \"banana\", \"Desc\", \"VAL\"),\n-                             optopt(\"a\", \"012345678901234567890123456789\", \"Desc\", \"VAL\"),\n-                             optflag(\"k\", \"kiwi\", \"Desc\"),\n-                             optflagopt(\"p\", \"\", \"Desc\", \"VAL\"),\n-                             optmulti(\"l\", \"\", \"Desc\", \"VAL\")];\n-\n-        let expected =\n-\"Usage: fruits\n-\n-Options:\n-    -b --banana VAL     Desc\n-    -a --012345678901234567890123456789 VAL\n-                        Desc\n-    -k --kiwi           Desc\n-    -p [VAL]            Desc\n-    -l VAL              Desc\n-\";\n-\n-        let generated_usage = usage(\"Usage: fruits\", &optgroups);\n-\n-        assert_eq!(generated_usage, expected);\n-    }\n-\n-    #[test]\n-    fn test_usage_description_wrapping() {\n-        // indentation should be 24 spaces\n-        // lines wrap after 78: or rather descriptions wrap after 54\n-\n-        let optgroups = vec![optflag(\"k\",\n-                                     \"kiwi\",\n-                                     // 54\n-                                     \"This is a long description which won't be wrapped..+..\"),\n-                             optflag(\"a\",\n-                                     \"apple\",\n-                                     \"This is a long description which _will_ be wrapped..+..\")];\n-\n-        let expected =\n-\"Usage: fruits\n-\n-Options:\n-    -k --kiwi           This is a long description which won't be wrapped..+..\n-    -a --apple          This is a long description which _will_ be\n-                        wrapped..+..\n-\";\n-\n-        let usage = usage(\"Usage: fruits\", &optgroups);\n-\n-        assert!(usage == expected)\n-    }\n-\n-    #[test]\n-    fn test_usage_description_multibyte_handling() {\n-        let optgroups = vec![optflag(\"k\",\n-                                     \"k\\u{2013}w\\u{2013}\",\n-                                     \"The word kiwi is normally spelled with two i's\"),\n-                             optflag(\"a\",\n-                                     \"apple\",\n-                                     \"This \\u{201C}description\\u{201D} has some characters that \\\n-                                      could confuse the line wrapping; an apple costs 0.51\u20ac in \\\n-                                      some parts of Europe.\")];\n-\n-        let expected =\n-\"Usage: fruits\n-\n-Options:\n-    -k --k\u2013w\u2013           The word kiwi is normally spelled with two i's\n-    -a --apple          This \u201cdescription\u201d has some characters that could\n-                        confuse the line wrapping; an apple costs 0.51\u20ac in\n-                        some parts of Europe.\n-\";\n-\n-        let usage = usage(\"Usage: fruits\", &optgroups);\n-\n-        assert!(usage == expected)\n-    }\n-\n-    #[test]\n-    fn test_short_usage() {\n-        let optgroups = vec![reqopt(\"b\", \"banana\", \"Desc\", \"VAL\"),\n-                             optopt(\"a\", \"012345678901234567890123456789\", \"Desc\", \"VAL\"),\n-                             optflag(\"k\", \"kiwi\", \"Desc\"),\n-                             optflagopt(\"p\", \"\", \"Desc\", \"VAL\"),\n-                             optmulti(\"l\", \"\", \"Desc\", \"VAL\")];\n-\n-        let expected = \"Usage: fruits -b VAL [-a VAL] [-k] [-p [VAL]] [-l VAL]..\".to_string();\n-        let generated_usage = short_usage(\"fruits\", &optgroups);\n-\n-        assert_eq!(generated_usage, expected);\n-    }\n-\n-    #[test]\n-    fn test_args_with_equals() {\n-        let args = vec![\"--one\".to_string(), \"A=B\".to_string(),\n-                        \"--two=C=D\".to_string()];\n-        let opts = vec![optopt(\"o\", \"one\", \"One\", \"INFO\"),\n-                        optopt(\"t\", \"two\", \"Two\", \"INFO\")];\n-        let matches = &match getopts(&args, &opts) {\n-            result::Result::Ok(m) => m,\n-            result::Result::Err(e) => panic!(\"{}\", e)\n-        };\n-        assert_eq!(matches.opts_str(&[\"o\".to_string()]).unwrap(), \"A=B\");\n-        assert_eq!(matches.opts_str(&[\"t\".to_string()]).unwrap(), \"C=D\");\n-    }\n-}"}]}