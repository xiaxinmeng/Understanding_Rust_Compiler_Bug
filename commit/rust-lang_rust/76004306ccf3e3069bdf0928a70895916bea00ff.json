{"sha": "76004306ccf3e3069bdf0928a70895916bea00ff", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc2MDA0MzA2Y2NmM2UzMDY5YmRmMDkyOGE3MDg5NTkxNmJlYTAwZmY=", "commit": {"author": {"name": "mcarton", "email": "cartonmartin+git@gmail.com", "date": "2016-02-27T23:46:02Z"}, "committer": {"name": "mcarton", "email": "cartonmartin+git@gmail.com", "date": "2016-02-28T11:16:13Z"}, "message": "Lint manual swaps", "tree": {"sha": "d56c2adddb2dfde0055d078fb619e549c24e7575", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d56c2adddb2dfde0055d078fb619e549c24e7575"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/76004306ccf3e3069bdf0928a70895916bea00ff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/76004306ccf3e3069bdf0928a70895916bea00ff", "html_url": "https://github.com/rust-lang/rust/commit/76004306ccf3e3069bdf0928a70895916bea00ff", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/76004306ccf3e3069bdf0928a70895916bea00ff/comments", "author": {"login": "mcarton", "id": 3751788, "node_id": "MDQ6VXNlcjM3NTE3ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/3751788?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcarton", "html_url": "https://github.com/mcarton", "followers_url": "https://api.github.com/users/mcarton/followers", "following_url": "https://api.github.com/users/mcarton/following{/other_user}", "gists_url": "https://api.github.com/users/mcarton/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcarton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcarton/subscriptions", "organizations_url": "https://api.github.com/users/mcarton/orgs", "repos_url": "https://api.github.com/users/mcarton/repos", "events_url": "https://api.github.com/users/mcarton/events{/privacy}", "received_events_url": "https://api.github.com/users/mcarton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mcarton", "id": 3751788, "node_id": "MDQ6VXNlcjM3NTE3ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/3751788?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcarton", "html_url": "https://github.com/mcarton", "followers_url": "https://api.github.com/users/mcarton/followers", "following_url": "https://api.github.com/users/mcarton/following{/other_user}", "gists_url": "https://api.github.com/users/mcarton/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcarton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcarton/subscriptions", "organizations_url": "https://api.github.com/users/mcarton/orgs", "repos_url": "https://api.github.com/users/mcarton/repos", "events_url": "https://api.github.com/users/mcarton/events{/privacy}", "received_events_url": "https://api.github.com/users/mcarton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "72ef26272d9718f5495b3a143010e031ba898e5a", "url": "https://api.github.com/repos/rust-lang/rust/commits/72ef26272d9718f5495b3a143010e031ba898e5a", "html_url": "https://github.com/rust-lang/rust/commit/72ef26272d9718f5495b3a143010e031ba898e5a"}], "stats": {"total": 173, "additions": 137, "deletions": 36}, "files": [{"sha": "f421cbdb7c9c211cedea5aa0b25a730d5bbe2002", "filename": "README.md", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/76004306ccf3e3069bdf0928a70895916bea00ff/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/76004306ccf3e3069bdf0928a70895916bea00ff/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=76004306ccf3e3069bdf0928a70895916bea00ff", "patch": "@@ -8,11 +8,12 @@ A collection of lints to catch common mistakes and improve your Rust code.\n [Jump to usage instructions](#usage)\n \n ##Lints\n-There are 126 lints included in this crate:\n+There are 127 lints included in this crate:\n \n name                                                                                                                 | default | meaning\n ---------------------------------------------------------------------------------------------------------------------|---------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n [absurd_extreme_comparisons](https://github.com/Manishearth/rust-clippy/wiki#absurd_extreme_comparisons)             | warn    | a comparison involving a maximum or minimum value involves a case that is always true or always false\n+[almost_swapped](https://github.com/Manishearth/rust-clippy/wiki#almost_swapped)                                     | warn    | `foo = bar; bar = foo` sequence\n [approx_constant](https://github.com/Manishearth/rust-clippy/wiki#approx_constant)                                   | warn    | the approximate of a known float constant (in `std::f64::consts` or `std::f32::consts`) is found; suggests to use the constant\n [bad_bit_mask](https://github.com/Manishearth/rust-clippy/wiki#bad_bit_mask)                                         | warn    | expressions of the form `_ & mask == select` that will only ever return `true` or `false` (because in the example `select` containing bits that `mask` doesn't have)\n [block_in_if_condition_expr](https://github.com/Manishearth/rust-clippy/wiki#block_in_if_condition_expr)             | warn    | braces can be eliminated in conditions that are expressions, e.g `if { true } ...`\n@@ -62,6 +63,7 @@ name\n [let_and_return](https://github.com/Manishearth/rust-clippy/wiki#let_and_return)                                     | warn    | creating a let-binding and then immediately returning it like `let x = expr; x` at the end of a block\n [let_unit_value](https://github.com/Manishearth/rust-clippy/wiki#let_unit_value)                                     | warn    | creating a let binding to a value of unit type, which usually can't be used afterwards\n [linkedlist](https://github.com/Manishearth/rust-clippy/wiki#linkedlist)                                             | warn    | usage of LinkedList, usually a vector is faster, or a more specialized data structure like a VecDeque\n+[manual_swap](https://github.com/Manishearth/rust-clippy/wiki#manual_swap)                                           | warn    | manual swap\n [map_clone](https://github.com/Manishearth/rust-clippy/wiki#map_clone)                                               | warn    | using `.map(|x| x.clone())` to clone an iterator or option's contents (recommends `.cloned()` instead)\n [map_entry](https://github.com/Manishearth/rust-clippy/wiki#map_entry)                                               | warn    | use of `contains_key` followed by `insert` on a `HashMap` or `BTreeMap`\n [match_bool](https://github.com/Manishearth/rust-clippy/wiki#match_bool)                                             | warn    | a match on boolean expression; recommends `if..else` block instead\n@@ -114,7 +116,6 @@ name\n [string_to_string](https://github.com/Manishearth/rust-clippy/wiki#string_to_string)                                 | warn    | calling `String::to_string` which is inefficient\n [suspicious_assignment_formatting](https://github.com/Manishearth/rust-clippy/wiki#suspicious_assignment_formatting) | warn    | suspicious formatting of `*=`, `-=` or `!=`\n [suspicious_else_formatting](https://github.com/Manishearth/rust-clippy/wiki#suspicious_else_formatting)             | warn    | suspicious formatting of `else if`\n-[suspicious_swap](https://github.com/Manishearth/rust-clippy/wiki#suspicious_swap)                                   | warn    | `foo = bar; bar = foo` sequence\n [temporary_assignment](https://github.com/Manishearth/rust-clippy/wiki#temporary_assignment)                         | warn    | assignments to temporaries\n [toplevel_ref_arg](https://github.com/Manishearth/rust-clippy/wiki#toplevel_ref_arg)                                 | warn    | An entire binding was declared as `ref`, in a function argument (`fn foo(ref x: Bar)`), or a `let` statement (`let ref x = foo()`). In such cases, it is preferred to take references with `&`.\n [trivial_regex](https://github.com/Manishearth/rust-clippy/wiki#trivial_regex)                                       | warn    | finds trivial regular expressions in `Regex::new(_)` invocations"}, {"sha": "5debe2ed50ce6f30a0aede9d4fa19c0e10dca448", "filename": "src/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/76004306ccf3e3069bdf0928a70895916bea00ff/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76004306ccf3e3069bdf0928a70895916bea00ff/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=76004306ccf3e3069bdf0928a70895916bea00ff", "patch": "@@ -287,7 +287,8 @@ pub fn plugin_registrar(reg: &mut Registry) {\n         returns::LET_AND_RETURN,\n         returns::NEEDLESS_RETURN,\n         strings::STRING_LIT_AS_BYTES,\n-        swap::SUSPICIOUS_SWAP,\n+        swap::ALMOST_SWAPPED,\n+        swap::MANUAL_SWAP,\n         temporary_assignment::TEMPORARY_ASSIGNMENT,\n         transmute::USELESS_TRANSMUTE,\n         types::ABSURD_EXTREME_COMPARISONS,"}, {"sha": "6d7212233fbbbf1b261af2ee6eba7ef79ca659ef", "filename": "src/swap.rs", "status": "modified", "additions": 104, "deletions": 32, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/76004306ccf3e3069bdf0928a70895916bea00ff/src%2Fswap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76004306ccf3e3069bdf0928a70895916bea00ff/src%2Fswap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fswap.rs?ref=76004306ccf3e3069bdf0928a70895916bea00ff", "patch": "@@ -1,7 +1,26 @@\n use rustc::lint::*;\n use rustc_front::hir::*;\n-use utils::{differing_macro_contexts, snippet_opt, span_lint_and_then, SpanlessEq};\n use syntax::codemap::mk_sp;\n+use utils::{differing_macro_contexts, snippet_opt, span_lint_and_then, SpanlessEq};\n+\n+/// **What it does:** This lints manual swapping.\n+///\n+/// **Why is this bad?** The `std::mem::swap` function exposes the intent better without\n+/// deinitializing or copying either variable.\n+///\n+/// **Known problems:** None.\n+///\n+/// **Example:**\n+/// ```rust,ignore\n+/// let t = b;\n+/// b = a;\n+/// a = t;\n+/// ```\n+declare_lint! {\n+    pub MANUAL_SWAP,\n+    Warn,\n+    \"manual swap\"\n+}\n \n /// **What it does:** This lints `foo = bar; bar = foo` sequences.\n ///\n@@ -15,7 +34,7 @@ use syntax::codemap::mk_sp;\n /// b = a;\n /// ```\n declare_lint! {\n-    pub SUSPICIOUS_SWAP,\n+    pub ALMOST_SWAPPED,\n     Warn,\n     \"`foo = bar; bar = foo` sequence\"\n }\n@@ -25,42 +44,95 @@ pub struct Swap;\n \n impl LintPass for Swap {\n     fn get_lints(&self) -> LintArray {\n-        lint_array![SUSPICIOUS_SWAP]\n+        lint_array![MANUAL_SWAP, ALMOST_SWAPPED]\n     }\n }\n \n impl LateLintPass for Swap {\n     fn check_block(&mut self, cx: &LateContext, block: &Block) {\n-        for w in block.stmts.windows(2) {\n-            if_let_chain!{[\n-                let StmtSemi(ref first, _) = w[0].node,\n-                let StmtSemi(ref second, _) = w[1].node,\n-                !differing_macro_contexts(first.span, second.span),\n-                let ExprAssign(ref lhs0, ref rhs0) = first.node,\n-                let ExprAssign(ref lhs1, ref rhs1) = second.node,\n-                SpanlessEq::new(cx).ignore_fn().eq_expr(lhs0, rhs1),\n-                SpanlessEq::new(cx).ignore_fn().eq_expr(lhs1, rhs0)\n-            ], {\n-                let (what, lhs, rhs) = if let (Some(first), Some(second)) = (snippet_opt(cx, lhs0.span), snippet_opt(cx, rhs0.span)) {\n-                    (format!(\" `{}` and `{}`\", first, second), first, second)\n-                } else {\n-                    (\"\".to_owned(), \"\".to_owned(), \"\".to_owned())\n-                };\n+        check_manual_swap(cx, block);\n+        check_suspicious_swap(cx, block);\n+    }\n+}\n+\n+/// Implementation of the `MANUAL_SWAP` lint.\n+fn check_manual_swap(cx: &LateContext, block: &Block) {\n+    for w in block.stmts.windows(3) {\n+        if_let_chain!{[\n+            // let t = foo();\n+            let StmtDecl(ref tmp, _) = w[0].node,\n+            let DeclLocal(ref tmp) = tmp.node,\n+            let Some(ref tmp_init) = tmp.init,\n+            let PatKind::Ident(_, ref tmp_name, None) = tmp.pat.node,\n+\n+            // foo() = bar();\n+            let StmtSemi(ref first, _) = w[1].node,\n+            let ExprAssign(ref lhs1, ref rhs1) = first.node,\n+\n+            // bar() = t;\n+            let StmtSemi(ref second, _) = w[2].node,\n+            let ExprAssign(ref lhs2, ref rhs2) = second.node,\n+            let ExprPath(None, ref rhs2) = rhs2.node,\n+            rhs2.segments.len() == 1,\n+\n+            tmp_name.node.name.as_str() == rhs2.segments[0].identifier.name.as_str(),\n+            SpanlessEq::new(cx).ignore_fn().eq_expr(tmp_init, lhs1),\n+            SpanlessEq::new(cx).ignore_fn().eq_expr(rhs1, lhs2)\n+        ], {\n+            let (what, lhs, rhs) = if let (Some(first), Some(second)) = (snippet_opt(cx, lhs1.span), snippet_opt(cx, rhs1.span)) {\n+                (format!(\" `{}` and `{}`\", first, second), first, second)\n+            } else {\n+                (\"\".to_owned(), \"\".to_owned(), \"\".to_owned())\n+            };\n+\n+            let span = mk_sp(tmp.span.lo, second.span.hi);\n+\n+            span_lint_and_then(cx,\n+                               MANUAL_SWAP,\n+                               span,\n+                               &format!(\"this looks like you are swapping{} manually\", what),\n+                               |db| {\n+                                   if !what.is_empty() {\n+                                       db.span_suggestion(span, \"try\",\n+                                                          format!(\"std::mem::swap(&mut {}, &mut {})\", lhs, rhs));\n+                                       db.fileline_note(span, \"or maybe you should use `std::mem::replace`?\");\n+                                   }\n+                               });\n+        }}\n+    }\n+}\n+\n+/// Implementation of the `ALMOST_SWAPPED` lint.\n+fn check_suspicious_swap(cx: &LateContext, block: &Block) {\n+    for w in block.stmts.windows(2) {\n+        if_let_chain!{[\n+            let StmtSemi(ref first, _) = w[0].node,\n+            let StmtSemi(ref second, _) = w[1].node,\n+            !differing_macro_contexts(first.span, second.span),\n+            let ExprAssign(ref lhs0, ref rhs0) = first.node,\n+            let ExprAssign(ref lhs1, ref rhs1) = second.node,\n+            SpanlessEq::new(cx).ignore_fn().eq_expr(lhs0, rhs1),\n+            SpanlessEq::new(cx).ignore_fn().eq_expr(lhs1, rhs0)\n+        ], {\n+            let (what, lhs, rhs) = if let (Some(first), Some(second)) = (snippet_opt(cx, lhs0.span), snippet_opt(cx, rhs0.span)) {\n+                (format!(\" `{}` and `{}`\", first, second), first, second)\n+            } else {\n+                (\"\".to_owned(), \"\".to_owned(), \"\".to_owned())\n+            };\n \n-                let span = mk_sp(first.span.lo, second.span.hi);\n+            let span = mk_sp(first.span.lo, second.span.hi);\n \n-                span_lint_and_then(cx,\n-                                   SUSPICIOUS_SWAP,\n-                                   span,\n-                                   &format!(\"this looks like you are trying to swap{}\", what),\n-                                   |db| {\n-                                       if !what.is_empty() {\n-                                           db.span_suggestion(span, \"try\",\n-                                                              format!(\"std::mem::swap({}, {})\", lhs, rhs));\n-                                           db.fileline_note(span, \"or maybe you should use `std::mem::replace`?\");\n-                                       }\n-                                   });\n-            }}\n-        }\n+            span_lint_and_then(cx,\n+                               ALMOST_SWAPPED,\n+                               span,\n+                               &format!(\"this looks like you are trying to swap{}\", what),\n+                               |db| {\n+                                   if !what.is_empty() {\n+                                       db.span_suggestion(span, \"try\",\n+                                                          format!(\"std::mem::swap(&mut {}, &mut {})\", lhs, rhs));\n+                                       db.fileline_note(span, \"or maybe you should use `std::mem::replace`?\");\n+                                   }\n+                               });\n+        }}\n     }\n }"}, {"sha": "cc0570e6c631012c7cc5c1937767f5e58938301f", "filename": "tests/compile-fail/swap.rs", "status": "modified", "additions": 28, "deletions": 1, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/76004306ccf3e3069bdf0928a70895916bea00ff/tests%2Fcompile-fail%2Fswap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76004306ccf3e3069bdf0928a70895916bea00ff/tests%2Fcompile-fail%2Fswap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fswap.rs?ref=76004306ccf3e3069bdf0928a70895916bea00ff", "patch": "@@ -4,6 +4,8 @@\n #![deny(clippy)]\n #![allow(unused_assignments)]\n \n+struct Foo(u32);\n+\n fn main() {\n     let mut a = 42;\n     let mut b = 1337;\n@@ -12,6 +14,31 @@ fn main() {\n     b = a;\n     //~^^ ERROR this looks like you are trying to swap `a` and `b`\n     //~| HELP try\n-    //~| SUGGESTION std::mem::swap(a, b);\n+    //~| SUGGESTION std::mem::swap(&mut a, &mut b);\n+    //~| NOTE or maybe you should use `std::mem::replace`?\n+\n+    let t = a;\n+    a = b;\n+    b = t;\n+    //~^^^ ERROR this looks like you are swapping `a` and `b` manually\n+    //~| HELP try\n+    //~| SUGGESTION std::mem::swap(&mut a, &mut b);\n+    //~| NOTE or maybe you should use `std::mem::replace`?\n+\n+    let mut c = Foo(42);\n+\n+    c.0 = a;\n+    a = c.0;\n+    //~^^ ERROR this looks like you are trying to swap `c.0` and `a`\n+    //~| HELP try\n+    //~| SUGGESTION std::mem::swap(&mut c.0, &mut a);\n+    //~| NOTE or maybe you should use `std::mem::replace`?\n+\n+    let t = c.0;\n+    c.0 = a;\n+    a = t;\n+    //~^^^ ERROR this looks like you are swapping `c.0` and `a` manually\n+    //~| HELP try\n+    //~| SUGGESTION std::mem::swap(&mut c.0, &mut a);\n     //~| NOTE or maybe you should use `std::mem::replace`?\n }"}]}