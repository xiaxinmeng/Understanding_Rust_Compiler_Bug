{"sha": "1745a2cd08d1aa7437ec3d080c9ca85434b54cf5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE3NDVhMmNkMDhkMWFhNzQzN2VjM2QwODBjOWNhODU0MzRiNTRjZjU=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-03-26T20:27:34Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-04-05T09:36:02Z"}, "message": "refactor check_call_inner to have a better name and be readable", "tree": {"sha": "40ce12443253358a276dd6f649196c0deac97a16", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/40ce12443253358a276dd6f649196c0deac97a16"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1745a2cd08d1aa7437ec3d080c9ca85434b54cf5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1745a2cd08d1aa7437ec3d080c9ca85434b54cf5", "html_url": "https://github.com/rust-lang/rust/commit/1745a2cd08d1aa7437ec3d080c9ca85434b54cf5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1745a2cd08d1aa7437ec3d080c9ca85434b54cf5/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "babe50633349cd29f0a0757079e0e13bdc0310fa", "url": "https://api.github.com/repos/rust-lang/rust/commits/babe50633349cd29f0a0757079e0e13bdc0310fa", "html_url": "https://github.com/rust-lang/rust/commit/babe50633349cd29f0a0757079e0e13bdc0310fa"}], "stats": {"total": 190, "additions": 86, "deletions": 104}, "files": [{"sha": "516ec3a50cd96c793955338e1f7d8230107ef09d", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 86, "deletions": 104, "changes": 190, "blob_url": "https://github.com/rust-lang/rust/blob/1745a2cd08d1aa7437ec3d080c9ca85434b54cf5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1745a2cd08d1aa7437ec3d080c9ca85434b54cf5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=1745a2cd08d1aa7437ec3d080c9ca85434b54cf5", "patch": "@@ -1122,9 +1122,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                                unifier: &fn()) {\n     debug!(\">> typechecking %s\", fcx.expr_to_str(expr));\n \n-    // A generic function to factor out common logic from call and\n-    // overloaded operations\n-    fn check_call_inner(\n+    fn check_argument_types(\n         fcx: @mut FnCtxt,\n         sp: span,\n         call_expr_id: ast::node_id,\n@@ -1134,18 +1132,24 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         sugar: ast::CallSugar,\n         deref_args: DerefArgs) -> ty::t\n     {\n+        /*!\n+         *\n+         * Generic function that factors out common logic from\n+         * function calls, method calls and overloaded operators.\n+         */\n+\n         let tcx = fcx.ccx.tcx;\n \n         // Replace all region parameters in the arguments and return\n         // type with fresh region variables.\n \n-        debug!(\"check_call_inner: before universal quant., in_fty=%s\",\n+        debug!(\"check_argument_types: before universal quant., in_fty=%s\",\n                fcx.infcx().ty_to_str(in_fty));\n \n-        let formal_tys;\n+        let sty = structure_of(fcx, sp, in_fty);\n \n         // FIXME(#3678) For now, do not permit calls to C abi functions.\n-        match structure_of(fcx, sp, in_fty) {\n+        match sty {\n             ty::ty_bare_fn(ty::BareFnTy {abis, _}) => {\n                 if !abis.is_rust() {\n                     tcx.sess.span_err(\n@@ -1157,68 +1161,65 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n             _ => {}\n         }\n \n-        // This is subtle: we expect `fty` to be a function type, which\n-        // normally introduce a level of binding.  In this case, we want to\n-        // process the types bound by the function but not by any nested\n-        // functions.  Therefore, we match one level of structure.\n-        let ret_ty = match structure_of(fcx, sp, in_fty) {\n-            ty::ty_bare_fn(ty::BareFnTy {sig: ref sig, _}) |\n-            ty::ty_closure(ty::ClosureTy {sig: ref sig, _}) => {\n-                let (_, _, sig) =\n-                    replace_bound_regions_in_fn_sig(\n-                        tcx, @Nil, None, sig,\n-                        |_br| fcx.infcx().next_region_var(\n-                            sp, call_expr_id));\n-\n-                let supplied_arg_count = args.len();\n-\n-                // Grab the argument types, supplying fresh type variables\n-                // if the wrong number of arguments were supplied\n-                let expected_arg_count = sig.inputs.len();\n-                formal_tys = if expected_arg_count == supplied_arg_count {\n-                    sig.inputs.map(|a| a.ty)\n-                } else {\n-                    let suffix = match sugar {\n-                        ast::NoSugar => \"\",\n-                        ast::DoSugar => \" (including the closure passed by \\\n-                                         the `do` keyword)\",\n-                        ast::ForSugar => \" (including the closure passed by \\\n-                                          the `for` keyword)\"\n-                    };\n-                    let msg = fmt!(\"this function takes %u parameter%s but \\\n-                                    %u parameter%s supplied%s\",\n-                                   expected_arg_count,\n-                                   if expected_arg_count == 1 {\"\"}\n-                                   else {\"s\"},\n-                                   supplied_arg_count,\n-                                   if supplied_arg_count == 1 {\" was\"}\n-                                   else {\"s were\"},\n-                                   suffix);\n-\n-                    tcx.sess.span_err(sp, msg);\n-\n-                    vec::from_fn(supplied_arg_count, |_| ty::mk_err(tcx))\n-                };\n-\n-                sig.output\n-            }\n-\n+        // Extract the function signature from `in_fty`.\n+        let sig = match sty {\n+            ty::ty_bare_fn(ty::BareFnTy {sig: sig, _}) |\n+            ty::ty_closure(ty::ClosureTy {sig: sig, _}) => sig,\n             _ => {\n                 fcx.type_error_message(sp, |actual| {\n-                    fmt!(\"expected function or foreign function but \\\n+                    fmt!(\"expected function but \\\n                           found `%s`\", actual) }, in_fty, None);\n \n                 // check each arg against \"error\", in order to set up\n                 // all the node type bindings\n-                formal_tys = args.map(|_x| ty::mk_err(tcx));\n-                ty::mk_err(tcx)\n+                FnSig {bound_lifetime_names: opt_vec::Empty,\n+                       inputs: args.map(|_x| ty::arg {mode: ast::expl(ast::by_copy),\n+                                                      ty: ty::mk_err(tcx)}),\n+                       output: ty::mk_err(tcx)}\n             }\n         };\n \n-        debug!(\"check_call_inner: after universal quant., \\\n-                formal_tys=%? ret_ty=%s\",\n+        // Replace any bound regions that appear in the function\n+        // signature with region variables\n+        let (_, _, sig) =\n+            replace_bound_regions_in_fn_sig(\n+                tcx, @Nil, None, &sig,\n+                |_br| fcx.infcx().next_region_var(\n+                    sp, call_expr_id));\n+\n+        // Grab the argument types, supplying fresh type variables\n+        // if the wrong number of arguments were supplied\n+        let supplied_arg_count = args.len();\n+        let expected_arg_count = sig.inputs.len();\n+        let formal_tys = if expected_arg_count == supplied_arg_count {\n+            sig.inputs.map(|a| a.ty)\n+        } else {\n+            let suffix = match sugar {\n+                ast::NoSugar => \"\",\n+                ast::DoSugar => \" (including the closure passed by \\\n+                                 the `do` keyword)\",\n+                ast::ForSugar => \" (including the closure passed by \\\n+                                  the `for` keyword)\"\n+            };\n+            let msg = fmt!(\"this function takes %u parameter%s but \\\n+                            %u parameter%s supplied%s\",\n+                           expected_arg_count,\n+                           if expected_arg_count == 1 {\"\"}\n+                           else {\"s\"},\n+                           supplied_arg_count,\n+                           if supplied_arg_count == 1 {\" was\"}\n+                           else {\"s were\"},\n+                           suffix);\n+\n+            tcx.sess.span_err(sp, msg);\n+\n+            vec::from_elem(supplied_arg_count, ty::mk_err(tcx))\n+        };\n+\n+        debug!(\"check_argument_types: after universal quant., \\\n+                formal_tys=%? sig.output=%s\",\n                formal_tys.map(|t| fcx.infcx().ty_to_str(*t)),\n-               fcx.infcx().ty_to_str(ret_ty));\n+               fcx.infcx().ty_to_str(sig.output));\n \n         // Check the arguments.\n         // We do this in a pretty awful way: first we typecheck any arguments\n@@ -1269,7 +1270,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n             }\n         }\n \n-        ret_ty\n+        sig.output\n     }\n \n     // A generic function for checking assignment expressions\n@@ -1284,43 +1285,23 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         // The callee checks for bot / err, we don't need to\n     }\n \n-    // A generic function for doing all of the checking for call or\n-    // method expressions\n-    fn check_call_or_method(fcx: @mut FnCtxt,\n-                            sp: span,\n-                            call_expr_id: ast::node_id,\n-                            fn_ty: ty::t,\n-                            expr: @ast::expr,\n-                            args: &[@ast::expr],\n-                            sugar: ast::CallSugar)\n-    {\n-\n-        // Call the generic checker.\n-        let ret_ty = check_call_inner(fcx, sp, call_expr_id,\n-                                           fn_ty, expr, args, sugar,\n-                                           DontDerefArgs);\n-        // Pull the return type out of the type of the function.\n-        fcx.write_ty(call_expr_id, ret_ty);\n-        // Callee checks for bot and err, no need for that\n-    }\n-\n     // A generic function for doing all of the checking for call expressions\n     fn check_call(fcx: @mut FnCtxt,\n-                  sp: span,\n-                  call_expr_id: ast::node_id,\n+                  call_expr: @ast::expr,\n                   f: @ast::expr,\n                   args: &[@ast::expr],\n                   sugar: ast::CallSugar) {\n         // Index expressions need to be handled separately, to inform them\n         // that they appear in call position.\n-        let mut _bot = check_expr(fcx, f);\n-        check_call_or_method(fcx,\n-                             sp,\n-                             call_expr_id,\n-                             fcx.expr_ty(f),\n-                             f,\n-                             args,\n-                             sugar)\n+        check_expr(fcx, f);\n+\n+        // Call the generic checker.\n+        let ret_ty = check_argument_types(fcx, call_expr.span, call_expr.id,\n+                                          fcx.expr_ty(f), f, args, sugar,\n+                                          DontDerefArgs);\n+\n+        // Pull the return type out of the type of the function.\n+        fcx.write_ty(call_expr.id, ret_ty);\n     }\n \n     // Checks a method call.\n@@ -1369,13 +1350,14 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n             }\n         }\n \n-        check_call_or_method(fcx,\n-                             expr.span,\n-                             expr.id,\n-                             fcx.node_ty(expr.callee_id),\n-                             expr,\n-                             args,\n-                             sugar)\n+        // Call the generic checker.\n+        let fn_ty = fcx.node_ty(expr.callee_id);\n+        let ret_ty = check_argument_types(fcx, expr.span, expr.id,\n+                                          fn_ty, expr, args, sugar,\n+                                          DontDerefArgs);\n+\n+        // Pull the return type out of the type of the function.\n+        fcx.write_ty(expr.id, ret_ty);\n     }\n \n     // A generic function for checking the then and else in an if\n@@ -1423,20 +1405,20 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                 let method_ty = fcx.node_ty(op_ex.callee_id);\n                 let method_map = fcx.inh.method_map;\n                 method_map.insert(op_ex.id, *origin);\n-                check_call_inner(fcx, op_ex.span,\n-                                 op_ex.id, method_ty,\n-                                 op_ex, args,\n-                                 ast::NoSugar, deref_args)\n+                check_argument_types(fcx, op_ex.span,\n+                                     op_ex.id, method_ty,\n+                                     op_ex, args,\n+                                     ast::NoSugar, deref_args)\n             }\n             _ => {\n                 let tcx = fcx.tcx();\n                 unbound_method();\n                 // Check the args anyway\n                 // so we get all the error messages\n                 let expected_ty = ty::mk_err(tcx);\n-                check_call_inner(fcx, op_ex.span, op_ex.id,\n-                                 expected_ty, op_ex, args,\n-                                 ast::NoSugar, deref_args);\n+                check_argument_types(fcx, op_ex.span, op_ex.id,\n+                                     expected_ty, op_ex, args,\n+                                     ast::NoSugar, deref_args);\n                 ty::mk_err(tcx)\n             }\n         }\n@@ -2546,7 +2528,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         fcx.write_ty(id, fcx.node_ty(b.node.id));\n       }\n       ast::expr_call(f, ref args, sugar) => {\n-          check_call(fcx, expr.span, expr.id, f, *args, sugar);\n+          check_call(fcx, expr, f, *args, sugar);\n           let f_ty = fcx.expr_ty(f);\n           let (args_bot, args_err) = args.foldl((false, false),\n              |&(rest_bot, rest_err), a| {"}]}