{"sha": "7450c4e3e83674de975c3f029a6bec6dab334ac2", "node_id": "C_kwDOAAsO6NoAKDc0NTBjNGUzZTgzNjc0ZGU5NzVjM2YwMjlhNmJlYzZkYWIzMzRhYzI", "commit": {"author": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-04-08T07:38:28Z"}, "committer": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-04-09T00:11:40Z"}, "message": "Remove explicit delimiter token trees from `Delimited`.\n\nThey were introduced by the final commit in #95159 and gave a\nperformance win. But since the introduction of `MatcherLoc` they are no\nlonger needed. This commit reverts that change, making the code a bit\nsimpler.", "tree": {"sha": "38710054aea7ec7b87549d0468fcda310cc545d5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/38710054aea7ec7b87549d0468fcda310cc545d5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7450c4e3e83674de975c3f029a6bec6dab334ac2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7450c4e3e83674de975c3f029a6bec6dab334ac2", "html_url": "https://github.com/rust-lang/rust/commit/7450c4e3e83674de975c3f029a6bec6dab334ac2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7450c4e3e83674de975c3f029a6bec6dab334ac2/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c2afaba465e0bf44b9b37beba8d908b78dcdadc7", "url": "https://api.github.com/repos/rust-lang/rust/commits/c2afaba465e0bf44b9b37beba8d908b78dcdadc7", "html_url": "https://github.com/rust-lang/rust/commit/c2afaba465e0bf44b9b37beba8d908b78dcdadc7"}], "stats": {"total": 154, "additions": 58, "deletions": 96}, "files": [{"sha": "c1f1b4e505c3685c56333c625844900be2ab0dcb", "filename": "compiler/rustc_expand/src/mbe.rs", "status": "modified", "additions": 10, "deletions": 34, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/7450c4e3e83674de975c3f029a6bec6dab334ac2/compiler%2Frustc_expand%2Fsrc%2Fmbe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7450c4e3e83674de975c3f029a6bec6dab334ac2/compiler%2Frustc_expand%2Fsrc%2Fmbe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe.rs?ref=7450c4e3e83674de975c3f029a6bec6dab334ac2", "patch": "@@ -17,48 +17,24 @@ use rustc_data_structures::sync::Lrc;\n use rustc_span::symbol::Ident;\n use rustc_span::Span;\n \n-/// Contains the sub-token-trees of a \"delimited\" token tree such as `(a b c)`. The delimiter itself\n-/// might be `NoDelim`.\n+/// Contains the sub-token-trees of a \"delimited\" token tree such as `(a b c)`. The delimiters\n+/// might be `NoDelim`, but they are not represented explicitly.\n #[derive(Clone, PartialEq, Encodable, Decodable, Debug)]\n struct Delimited {\n     delim: token::DelimToken,\n-    /// Note: This contains the opening and closing delimiters tokens (e.g. `(` and `)`). Note that\n-    /// these could be `NoDelim`. These token kinds must match `delim`, and the methods below\n-    /// debug_assert this.\n-    all_tts: Vec<TokenTree>,\n+    /// FIXME: #67062 has details about why this is sub-optimal.\n+    tts: Vec<TokenTree>,\n }\n \n impl Delimited {\n-    /// Returns a `self::TokenTree` with a `Span` corresponding to the opening delimiter. Panics if\n-    /// the delimiter is `NoDelim`.\n-    fn open_tt(&self) -> &TokenTree {\n-        let tt = self.all_tts.first().unwrap();\n-        debug_assert!(matches!(\n-            tt,\n-            &TokenTree::Token(token::Token { kind: token::OpenDelim(d), .. }) if d == self.delim\n-        ));\n-        tt\n+    /// Returns a `self::TokenTree` with a `Span` corresponding to the opening delimiter.\n+    fn open_tt(&self, span: DelimSpan) -> TokenTree {\n+        TokenTree::token(token::OpenDelim(self.delim), span.open)\n     }\n \n-    /// Returns a `self::TokenTree` with a `Span` corresponding to the closing delimiter. Panics if\n-    /// the delimiter is `NoDelim`.\n-    fn close_tt(&self) -> &TokenTree {\n-        let tt = self.all_tts.last().unwrap();\n-        debug_assert!(matches!(\n-            tt,\n-            &TokenTree::Token(token::Token { kind: token::CloseDelim(d), .. }) if d == self.delim\n-        ));\n-        tt\n-    }\n-\n-    /// Returns the tts excluding the outer delimiters.\n-    ///\n-    /// FIXME: #67062 has details about why this is sub-optimal.\n-    fn inner_tts(&self) -> &[TokenTree] {\n-        // These functions are called for the assertions within them.\n-        let _open_tt = self.open_tt();\n-        let _close_tt = self.close_tt();\n-        &self.all_tts[1..self.all_tts.len() - 1]\n+    /// Returns a `self::TokenTree` with a `Span` corresponding to the closing delimiter.\n+    fn close_tt(&self, span: DelimSpan) -> TokenTree {\n+        TokenTree::token(token::CloseDelim(self.delim), span.close)\n     }\n }\n "}, {"sha": "fbacebf99c050032d01d6b65137f5399d147ee81", "filename": "compiler/rustc_expand/src/mbe/macro_check.rs", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7450c4e3e83674de975c3f029a6bec6dab334ac2/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7450c4e3e83674de975c3f029a6bec6dab334ac2/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_check.rs?ref=7450c4e3e83674de975c3f029a6bec6dab334ac2", "patch": "@@ -282,7 +282,7 @@ fn check_binders(\n         // `MetaVarExpr` can not appear in the LHS of a macro arm\n         TokenTree::MetaVarExpr(..) => {}\n         TokenTree::Delimited(_, ref del) => {\n-            for tt in del.inner_tts() {\n+            for tt in &del.tts {\n                 check_binders(sess, node_id, tt, macros, binders, ops, valid);\n             }\n         }\n@@ -345,7 +345,7 @@ fn check_occurrences(\n             check_ops_is_prefix(sess, node_id, macros, binders, ops, dl.entire(), name);\n         }\n         TokenTree::Delimited(_, ref del) => {\n-            check_nested_occurrences(sess, node_id, del.inner_tts(), macros, binders, ops, valid);\n+            check_nested_occurrences(sess, node_id, &del.tts, macros, binders, ops, valid);\n         }\n         TokenTree::Sequence(_, ref seq) => {\n             let ops = ops.push(seq.kleene);\n@@ -432,20 +432,14 @@ fn check_nested_occurrences(\n             {\n                 let macro_rules = state == NestedMacroState::MacroRulesNotName;\n                 state = NestedMacroState::Empty;\n-                let rest = check_nested_macro(\n-                    sess,\n-                    node_id,\n-                    macro_rules,\n-                    del.inner_tts(),\n-                    &nested_macros,\n-                    valid,\n-                );\n+                let rest =\n+                    check_nested_macro(sess, node_id, macro_rules, &del.tts, &nested_macros, valid);\n                 // If we did not check the whole macro definition, then check the rest as if outside\n                 // the macro definition.\n                 check_nested_occurrences(\n                     sess,\n                     node_id,\n-                    &del.inner_tts()[rest..],\n+                    &del.tts[rest..],\n                     macros,\n                     binders,\n                     ops,"}, {"sha": "29020691da38c6275679749e47074cd72dd4a47f", "filename": "compiler/rustc_expand/src/mbe/macro_parser.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7450c4e3e83674de975c3f029a6bec6dab334ac2/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7450c4e3e83674de975c3f029a6bec6dab334ac2/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs?ref=7450c4e3e83674de975c3f029a6bec6dab334ac2", "patch": "@@ -151,9 +151,11 @@ pub(super) fn compute_locs(sess: &ParseSess, matcher: &[TokenTree]) -> Vec<Match\n                 TokenTree::Token(token) => {\n                     locs.push(MatcherLoc::Token { token: token.clone() });\n                 }\n-                TokenTree::Delimited(_, delimited) => {\n+                TokenTree::Delimited(span, delimited) => {\n                     locs.push(MatcherLoc::Delimited);\n-                    inner(sess, &delimited.all_tts, locs, next_metavar, seq_depth);\n+                    inner(sess, &[delimited.open_tt(*span)], locs, next_metavar, seq_depth);\n+                    inner(sess, &delimited.tts, locs, next_metavar, seq_depth);\n+                    inner(sess, &[delimited.close_tt(*span)], locs, next_metavar, seq_depth);\n                 }\n                 TokenTree::Sequence(_, seq) => {\n                     // We can't determine `idx_first_after` and construct the final\n@@ -293,7 +295,7 @@ pub(super) fn count_metavar_decls(matcher: &[TokenTree]) -> usize {\n         .map(|tt| match tt {\n             TokenTree::MetaVarDecl(..) => 1,\n             TokenTree::Sequence(_, seq) => seq.num_captures,\n-            TokenTree::Delimited(_, delim) => count_metavar_decls(delim.inner_tts()),\n+            TokenTree::Delimited(_, delim) => count_metavar_decls(&delim.tts),\n             TokenTree::Token(..) => 0,\n             TokenTree::MetaVar(..) | TokenTree::MetaVarExpr(..) => unreachable!(),\n         })"}, {"sha": "31dae6a2fb437b6b531b31e0a3135ea4f74bcb5c", "filename": "compiler/rustc_expand/src/mbe/macro_rules.rs", "status": "modified", "additions": 20, "deletions": 24, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/7450c4e3e83674de975c3f029a6bec6dab334ac2/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7450c4e3e83674de975c3f029a6bec6dab334ac2/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs?ref=7450c4e3e83674de975c3f029a6bec6dab334ac2", "patch": "@@ -263,9 +263,7 @@ fn generic_extension<'cx, 'tt>(\n \n                 // Ignore the delimiters on the RHS.\n                 let rhs = match &rhses[i] {\n-                    mbe::TokenTree::Delimited(_, delimited) => {\n-                        delimited.inner_tts().to_vec().clone()\n-                    }\n+                    mbe::TokenTree::Delimited(_, delimited) => delimited.tts.to_vec(),\n                     _ => cx.span_bug(sp, \"malformed macro rhs\"),\n                 };\n                 let arm_span = rhses[i].span();\n@@ -470,17 +468,16 @@ pub fn compile_declarative_macro(\n             .iter()\n             .map(|m| {\n                 if let MatchedTokenTree(ref tt) = *m {\n-                    let mut tts = vec![];\n-                    mbe::quoted::parse(\n+                    let tt = mbe::quoted::parse(\n                         tt.clone().into(),\n                         true,\n                         &sess.parse_sess,\n                         def.id,\n                         features,\n                         edition,\n-                        &mut tts,\n-                    );\n-                    let tt = tts.pop().unwrap();\n+                    )\n+                    .pop()\n+                    .unwrap();\n                     valid &= check_lhs_nt_follows(&sess.parse_sess, features, &def, &tt);\n                     return tt;\n                 }\n@@ -495,17 +492,16 @@ pub fn compile_declarative_macro(\n             .iter()\n             .map(|m| {\n                 if let MatchedTokenTree(ref tt) = *m {\n-                    let mut tts = vec![];\n-                    mbe::quoted::parse(\n+                    return mbe::quoted::parse(\n                         tt.clone().into(),\n                         false,\n                         &sess.parse_sess,\n                         def.id,\n                         features,\n                         edition,\n-                        &mut tts,\n-                    );\n-                    return tts.pop().unwrap();\n+                    )\n+                    .pop()\n+                    .unwrap();\n                 }\n                 sess.parse_sess.span_diagnostic.span_bug(def.span, \"wrong-structured lhs\")\n             })\n@@ -544,7 +540,7 @@ pub fn compile_declarative_macro(\n                 // Ignore the delimiters around the matcher.\n                 match lhs {\n                     mbe::TokenTree::Delimited(_, delimited) => {\n-                        mbe::macro_parser::compute_locs(&sess.parse_sess, delimited.inner_tts())\n+                        mbe::macro_parser::compute_locs(&sess.parse_sess, &delimited.tts)\n                     }\n                     _ => sess.parse_sess.span_diagnostic.span_bug(def.span, \"malformed macro lhs\"),\n                 }\n@@ -576,7 +572,7 @@ fn check_lhs_nt_follows(\n     // lhs is going to be like TokenTree::Delimited(...), where the\n     // entire lhs is those tts. Or, it can be a \"bare sequence\", not wrapped in parens.\n     if let mbe::TokenTree::Delimited(_, delimited) = lhs {\n-        check_matcher(sess, features, def, delimited.inner_tts())\n+        check_matcher(sess, features, def, &delimited.tts)\n     } else {\n         let msg = \"invalid macro matcher; matchers must be contained in balanced delimiters\";\n         sess.span_diagnostic.span_err(lhs.span(), msg);\n@@ -597,7 +593,7 @@ fn check_lhs_no_empty_seq(sess: &ParseSess, tts: &[mbe::TokenTree]) -> bool {\n             | TokenTree::MetaVarDecl(..)\n             | TokenTree::MetaVarExpr(..) => (),\n             TokenTree::Delimited(_, ref del) => {\n-                if !check_lhs_no_empty_seq(sess, del.inner_tts()) {\n+                if !check_lhs_no_empty_seq(sess, &del.tts) {\n                     return false;\n                 }\n             }\n@@ -692,9 +688,9 @@ impl FirstSets {\n                     | TokenTree::MetaVarExpr(..) => {\n                         first.replace_with(tt.clone());\n                     }\n-                    TokenTree::Delimited(_span, ref delimited) => {\n-                        build_recur(sets, delimited.inner_tts());\n-                        first.replace_with(delimited.open_tt().clone());\n+                    TokenTree::Delimited(span, ref delimited) => {\n+                        build_recur(sets, &delimited.tts);\n+                        first.replace_with(delimited.open_tt(span));\n                     }\n                     TokenTree::Sequence(sp, ref seq_rep) => {\n                         let subfirst = build_recur(sets, &seq_rep.tts);\n@@ -758,8 +754,8 @@ impl FirstSets {\n                     first.add_one(tt.clone());\n                     return first;\n                 }\n-                TokenTree::Delimited(_span, ref delimited) => {\n-                    first.add_one(delimited.open_tt().clone());\n+                TokenTree::Delimited(span, ref delimited) => {\n+                    first.add_one(delimited.open_tt(span));\n                     return first;\n                 }\n                 TokenTree::Sequence(sp, ref seq_rep) => {\n@@ -945,9 +941,9 @@ fn check_matcher_core(\n                     suffix_first = build_suffix_first();\n                 }\n             }\n-            TokenTree::Delimited(_span, ref d) => {\n-                let my_suffix = TokenSet::singleton(d.close_tt().clone());\n-                check_matcher_core(sess, features, def, first_sets, d.inner_tts(), &my_suffix);\n+            TokenTree::Delimited(span, ref d) => {\n+                let my_suffix = TokenSet::singleton(d.close_tt(span));\n+                check_matcher_core(sess, features, def, first_sets, &d.tts, &my_suffix);\n                 // don't track non NT tokens\n                 last.replace_with_irrelevant();\n "}, {"sha": "a99a18aae119a4c49c12ceea5f3a1e854c5d77dd", "filename": "compiler/rustc_expand/src/mbe/quoted.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/7450c4e3e83674de975c3f029a6bec6dab334ac2/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fquoted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7450c4e3e83674de975c3f029a6bec6dab334ac2/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fquoted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fquoted.rs?ref=7450c4e3e83674de975c3f029a6bec6dab334ac2", "patch": "@@ -45,8 +45,10 @@ pub(super) fn parse(\n     node_id: NodeId,\n     features: &Features,\n     edition: Edition,\n-    result: &mut Vec<TokenTree>,\n-) {\n+) -> Vec<TokenTree> {\n+    // Will contain the final collection of `self::TokenTree`\n+    let mut result = Vec::new();\n+\n     // For each token tree in `input`, parse the token into a `self::TokenTree`, consuming\n     // additional trees if need be.\n     let mut trees = input.trees();\n@@ -113,6 +115,7 @@ pub(super) fn parse(\n             _ => result.push(tree),\n         }\n     }\n+    result\n }\n \n /// Asks for the `macro_metavar_expr` feature if it is not already declared\n@@ -205,8 +208,7 @@ fn parse_tree(\n                     // If we didn't find a metavar expression above, then we must have a\n                     // repetition sequence in the macro (e.g. `$(pat)*`).  Parse the\n                     // contents of the sequence itself\n-                    let mut sequence = vec![];\n-                    parse(tts, parsing_patterns, sess, node_id, features, edition, &mut sequence);\n+                    let sequence = parse(tts, parsing_patterns, sess, node_id, features, edition);\n                     // Get the Kleene operator and optional separator\n                     let (separator, kleene) =\n                         parse_sep_and_kleene_op(&mut trees, delim_span.entire(), sess);\n@@ -269,15 +271,13 @@ fn parse_tree(\n \n         // `tree` is the beginning of a delimited set of tokens (e.g., `(` or `{`). We need to\n         // descend into the delimited set and further parse it.\n-        tokenstream::TokenTree::Delimited(span, delim, tts) => {\n-            let mut all_tts = vec![];\n-            // Add the explicit open and close delimiters, which\n-            // `tokenstream::TokenTree::Delimited` lacks.\n-            all_tts.push(TokenTree::token(token::OpenDelim(delim), span.open));\n-            parse(tts, parsing_patterns, sess, node_id, features, edition, &mut all_tts);\n-            all_tts.push(TokenTree::token(token::CloseDelim(delim), span.close));\n-            TokenTree::Delimited(span, Lrc::new(Delimited { delim, all_tts }))\n-        }\n+        tokenstream::TokenTree::Delimited(span, delim, tts) => TokenTree::Delimited(\n+            span,\n+            Lrc::new(Delimited {\n+                delim,\n+                tts: parse(tts, parsing_patterns, sess, node_id, features, edition),\n+            }),\n+        ),\n     }\n }\n "}, {"sha": "b1ab2cc45781a2874165687d675da77ef8f67872", "filename": "compiler/rustc_expand/src/mbe/transcribe.rs", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7450c4e3e83674de975c3f029a6bec6dab334ac2/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7450c4e3e83674de975c3f029a6bec6dab334ac2/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Ftranscribe.rs?ref=7450c4e3e83674de975c3f029a6bec6dab334ac2", "patch": "@@ -10,7 +10,7 @@ use rustc_errors::{pluralize, PResult};\n use rustc_errors::{DiagnosticBuilder, ErrorGuaranteed};\n use rustc_span::hygiene::{LocalExpnId, Transparency};\n use rustc_span::symbol::{sym, Ident, MacroRulesNormalizedIdent};\n-use rustc_span::{Span, DUMMY_SP};\n+use rustc_span::Span;\n \n use smallvec::{smallvec, SmallVec};\n use std::mem;\n@@ -34,14 +34,8 @@ enum Frame {\n \n impl Frame {\n     /// Construct a new frame around the delimited set of tokens.\n-    fn new(mut tts: Vec<mbe::TokenTree>) -> Frame {\n-        // Need to add empty delimiters.\n-        let open_tt = mbe::TokenTree::token(token::OpenDelim(token::NoDelim), DUMMY_SP);\n-        let close_tt = mbe::TokenTree::token(token::CloseDelim(token::NoDelim), DUMMY_SP);\n-        tts.insert(0, open_tt);\n-        tts.push(close_tt);\n-\n-        let forest = Lrc::new(mbe::Delimited { delim: token::NoDelim, all_tts: tts });\n+    fn new(tts: Vec<mbe::TokenTree>) -> Frame {\n+        let forest = Lrc::new(mbe::Delimited { delim: token::NoDelim, tts });\n         Frame::Delimited { forest, idx: 0, span: DelimSpan::dummy() }\n     }\n }\n@@ -52,7 +46,7 @@ impl Iterator for Frame {\n     fn next(&mut self) -> Option<mbe::TokenTree> {\n         match *self {\n             Frame::Delimited { ref forest, ref mut idx, .. } => {\n-                let res = forest.inner_tts().get(*idx).cloned();\n+                let res = forest.tts.get(*idx).cloned();\n                 *idx += 1;\n                 res\n             }\n@@ -388,7 +382,7 @@ fn lockstep_iter_size(\n     use mbe::TokenTree;\n     match *tree {\n         TokenTree::Delimited(_, ref delimited) => {\n-            delimited.inner_tts().iter().fold(LockstepIterSize::Unconstrained, |size, tt| {\n+            delimited.tts.iter().fold(LockstepIterSize::Unconstrained, |size, tt| {\n                 size.with(lockstep_iter_size(tt, interpolations, repeats))\n             })\n         }"}]}