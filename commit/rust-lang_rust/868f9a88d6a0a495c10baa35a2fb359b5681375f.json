{"sha": "868f9a88d6a0a495c10baa35a2fb359b5681375f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg2OGY5YTg4ZDZhMGE0OTVjMTBiYWEzNWEyZmIzNTliNTY4MTM3NWY=", "commit": {"author": {"name": "Vadim Chugunov", "email": "vadimcn@gmail.com", "date": "2013-06-14T18:38:29Z"}, "committer": {"name": "Vadim Chugunov", "email": "vadimcn@gmail.com", "date": "2013-06-17T15:41:23Z"}, "message": "Use DIBuilder in debuginfo", "tree": {"sha": "5a7ae055af7f09ff1870ebab08a9393912de34a5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5a7ae055af7f09ff1870ebab08a9393912de34a5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/868f9a88d6a0a495c10baa35a2fb359b5681375f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/868f9a88d6a0a495c10baa35a2fb359b5681375f", "html_url": "https://github.com/rust-lang/rust/commit/868f9a88d6a0a495c10baa35a2fb359b5681375f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/868f9a88d6a0a495c10baa35a2fb359b5681375f/comments", "author": {"login": "vadimcn", "id": 3203809, "node_id": "MDQ6VXNlcjMyMDM4MDk=", "avatar_url": "https://avatars.githubusercontent.com/u/3203809?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vadimcn", "html_url": "https://github.com/vadimcn", "followers_url": "https://api.github.com/users/vadimcn/followers", "following_url": "https://api.github.com/users/vadimcn/following{/other_user}", "gists_url": "https://api.github.com/users/vadimcn/gists{/gist_id}", "starred_url": "https://api.github.com/users/vadimcn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vadimcn/subscriptions", "organizations_url": "https://api.github.com/users/vadimcn/orgs", "repos_url": "https://api.github.com/users/vadimcn/repos", "events_url": "https://api.github.com/users/vadimcn/events{/privacy}", "received_events_url": "https://api.github.com/users/vadimcn/received_events", "type": "User", "site_admin": false}, "committer": {"login": "vadimcn", "id": 3203809, "node_id": "MDQ6VXNlcjMyMDM4MDk=", "avatar_url": "https://avatars.githubusercontent.com/u/3203809?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vadimcn", "html_url": "https://github.com/vadimcn", "followers_url": "https://api.github.com/users/vadimcn/followers", "following_url": "https://api.github.com/users/vadimcn/following{/other_user}", "gists_url": "https://api.github.com/users/vadimcn/gists{/gist_id}", "starred_url": "https://api.github.com/users/vadimcn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vadimcn/subscriptions", "organizations_url": "https://api.github.com/users/vadimcn/orgs", "repos_url": "https://api.github.com/users/vadimcn/repos", "events_url": "https://api.github.com/users/vadimcn/events{/privacy}", "received_events_url": "https://api.github.com/users/vadimcn/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5f0e494d9d7c7c4c866414abd7701d22902415b6", "url": "https://api.github.com/repos/rust-lang/rust/commits/5f0e494d9d7c7c4c866414abd7701d22902415b6", "html_url": "https://github.com/rust-lang/rust/commit/5f0e494d9d7c7c4c866414abd7701d22902415b6"}], "stats": {"total": 1540, "additions": 832, "deletions": 708}, "files": [{"sha": "ece0c1cb19092e11ce94994fe6c9480a2be2588d", "filename": "src/librustc/lib/llvm.rs", "status": "modified", "additions": 183, "deletions": 2, "changes": 185, "blob_url": "https://github.com/rust-lang/rust/blob/868f9a88d6a0a495c10baa35a2fb359b5681375f/src%2Flibrustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/868f9a88d6a0a495c10baa35a2fb359b5681375f/src%2Flibrustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib%2Fllvm.rs?ref=868f9a88d6a0a495c10baa35a2fb359b5681375f", "patch": "@@ -224,13 +224,51 @@ pub type SectionIteratorRef = *SectionIterator_opaque;\n pub enum Pass_opaque {}\n pub type PassRef = *Pass_opaque;\n \n+pub mod debuginfo {\n+    use core::prelude::*;\n+    use super::{ValueRef};\n+    \n+    pub enum DIBuilder_opaque {}\n+    pub type DIBuilderRef = *DIBuilder_opaque;\n+    \n+    pub type DIDescriptor = ValueRef;\n+    pub type DIScope = DIDescriptor;\n+    pub type DILocation = DIDescriptor;\n+    pub type DIFile = DIScope;\n+    pub type DILexicalBlock = DIScope;\n+    pub type DISubprogram = DIScope;\n+    pub type DIType = DIDescriptor;\n+    pub type DIBasicType = DIType;\n+    pub type DIDerivedType = DIType;\n+    pub type DICompositeType = DIDerivedType;\n+    pub type DIVariable = DIDescriptor;\n+    pub type DIArray = DIDescriptor;\n+    pub type DISubrange = DIDescriptor;\n+\n+    pub enum DIDescriptorFlags {\n+      FlagPrivate            = 1 << 0,\n+      FlagProtected          = 1 << 1,\n+      FlagFwdDecl            = 1 << 2,\n+      FlagAppleBlock         = 1 << 3,\n+      FlagBlockByrefStruct   = 1 << 4,\n+      FlagVirtual            = 1 << 5,\n+      FlagArtificial         = 1 << 6,\n+      FlagExplicit           = 1 << 7,\n+      FlagPrototyped         = 1 << 8,\n+      FlagObjcClassComplete  = 1 << 9,\n+      FlagObjectPointer      = 1 << 10,\n+      FlagVector             = 1 << 11,\n+      FlagStaticMember       = 1 << 12\n+    }\n+}\n+\n pub mod llvm {\n     use super::{AtomicBinOp, AtomicOrdering, BasicBlockRef, ExecutionEngineRef};\n     use super::{Bool, BuilderRef, ContextRef, MemoryBufferRef, ModuleRef};\n     use super::{ObjectFileRef, Opcode, PassManagerRef, PassManagerBuilderRef};\n     use super::{SectionIteratorRef, TargetDataRef, TypeKind, TypeRef, UseRef};\n-    use super::{ValueRef,PassRef};\n-\n+    use super::{ValueRef, PassRef};\n+    use super::debuginfo::*;\n     use core::libc::{c_char, c_int, c_longlong, c_ushort, c_uint, c_ulonglong};\n \n     #[link_args = \"-Lrustllvm -lrustllvm\"]\n@@ -1885,6 +1923,149 @@ pub mod llvm {\n                                     AlignStack: Bool, Dialect: c_uint)\n                                  -> ValueRef;\n \n+\n+        #[fast_ffi]\n+        pub unsafe fn DIBuilder_new(M: ModuleRef) -> DIBuilderRef;\n+\n+        #[fast_ffi]\n+        pub unsafe fn DIBuilder_delete(Builder: DIBuilderRef);\n+\n+        #[fast_ffi]\n+        pub unsafe fn DIBuilder_finalize(Builder: DIBuilderRef);\n+\n+        #[fast_ffi]\n+        pub unsafe fn DIBuilder_createCompileUnit(\n+            Builder: DIBuilderRef,\n+            Lang: c_uint,\n+            File: *c_char,\n+            Dir: *c_char,\n+            Producer: *c_char,\n+            isOptimized: bool,\n+            Flags: *c_char,\n+            RuntimeVer: c_uint,\n+            SplitName: *c_char);\n+\n+        #[fast_ffi]\n+        pub unsafe fn DIBuilder_createFile(\n+            Builder: DIBuilderRef,\n+            Filename: *c_char,\n+            Directory: *c_char) -> DIFile;\n+\n+        #[fast_ffi]\n+        pub unsafe fn DIBuilder_createSubroutineType(\n+            Builder: DIBuilderRef,\n+            File: DIFile,\n+            ParameterTypes: DIArray) -> DICompositeType;\n+\n+        #[fast_ffi]\n+        pub unsafe fn DIBuilder_createFunction(\n+            Builder: DIBuilderRef,\n+            Scope: DIDescriptor,\n+            Name: *c_char,\n+            LinkageName: *c_char,\n+            File: DIFile,\n+            LineNo: c_uint,\n+            Ty: DIType,\n+            isLocalToUnit: bool,\n+            isDefinition: bool,\n+            ScopeLine: c_uint,\n+            Flags: c_uint,\n+            isOptimized: bool,\n+            Fn: ValueRef,\n+            TParam: ValueRef,\n+            Decl: ValueRef) -> DISubprogram;\n+\n+        #[fast_ffi]\n+        pub unsafe fn DIBuilder_createBasicType(\n+            Builder: DIBuilderRef,\n+            Name: *c_char,\n+            SizeInBits: c_ulonglong,\n+            AlignInBits: c_ulonglong,\n+            Encoding: c_uint) -> DIBasicType;\n+\n+        #[fast_ffi]\n+        pub unsafe fn DIBuilder_createPointerType(\n+            Builder: DIBuilderRef,\n+            PointeeTy: DIType,\n+            SizeInBits: c_ulonglong,\n+            AlignInBits: c_ulonglong,\n+            Name: *c_char) -> DIDerivedType;\n+\n+        #[fast_ffi]\n+        pub unsafe fn DIBuilder_createStructType(\n+            Builder: DIBuilderRef,\n+            Scope: DIDescriptor,\n+            Name: *c_char,\n+            File: DIFile,\n+            LineNumber: c_uint,\n+            SizeInBits: c_ulonglong,\n+            AlignInBits: c_ulonglong,\n+            Flags: c_uint,\n+            DerivedFrom: DIType,\n+            Elements: DIArray,\n+            RunTimeLang: c_uint,\n+            VTableHolder: ValueRef) -> DICompositeType;\n+\n+        #[fast_ffi]\n+        pub unsafe fn DIBuilder_createMemberType(\n+            Builder: DIBuilderRef,\n+            Scope: DIDescriptor,\n+            Name: *c_char,\n+            File: DIFile,\n+            LineNo: c_uint,\n+            SizeInBits: c_ulonglong,\n+            AlignInBits: c_ulonglong,\n+            OffsetInBits: c_ulonglong,\n+            Flags: c_uint,\n+            Ty: DIType) -> DIDerivedType;\n+\n+        #[fast_ffi]\n+        pub unsafe fn DIBuilder_createLexicalBlock(\n+            Builder: DIBuilderRef,\n+            Scope: DIDescriptor,\n+            File: DIFile,\n+            Line: c_uint,\n+            Col: c_uint) -> DILexicalBlock;\n+\n+        #[fast_ffi]\n+        pub unsafe fn DIBuilder_createLocalVariable(\n+            Builder: DIBuilderRef,\n+            Tag: c_uint,\n+            Scope: DIDescriptor,\n+            Name: *c_char,\n+            File: DIFile,\n+            LineNo: c_uint,\n+            Ty: DIType,\n+            AlwaysPreserve: bool,\n+            Flags: c_uint,\n+            ArgNo: c_uint) -> DIVariable;\n+\n+        #[fast_ffi]\n+        pub unsafe fn DIBuilder_createVectorType(\n+            Builder: DIBuilderRef,\n+            Size: c_ulonglong,\n+            AlignInBits: c_ulonglong,\n+            Ty: DIType,\n+            Subscripts: DIArray) -> DIType;\n+\n+        #[fast_ffi]\n+        pub unsafe fn DIBuilder_getOrCreateSubrange(\n+            Builder: DIBuilderRef,\n+            Lo: c_longlong,\n+            Count: c_longlong) -> DISubrange;\n+\n+        #[fast_ffi]\n+        pub unsafe fn DIBuilder_getOrCreateArray(\n+            Builder: DIBuilderRef,\n+            Ptr: *DIDescriptor,\n+            Count: c_uint) -> DIArray;\n+\n+        #[fast_ffi]\n+        pub unsafe fn DIBuilder_insertDeclare(\n+            Builder: DIBuilderRef,\n+            Val: ValueRef,\n+            VarInfo: DIVariable,\n+            InsertBefore: *c_void) -> *c_void;\n     }\n }\n "}, {"sha": "580e7fa1900a83795fa1316b3e86672fbdfe686e", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/868f9a88d6a0a495c10baa35a2fb359b5681375f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/868f9a88d6a0a495c10baa35a2fb359b5681375f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=868f9a88d6a0a495c10baa35a2fb359b5681375f", "patch": "@@ -3074,6 +3074,7 @@ pub fn trans_crate(sess: session::Session,\n     // 1. http://llvm.org/bugs/show_bug.cgi?id=11479\n     let llmod_id = link_meta.name.to_owned() + \".rc\";\n \n+            Some(debuginfo::mk_ctxt(llmod, copy llmod_id))\n     // FIXME(#6511): get LLVM building with --enable-threads so this\n     //               function can be called\n     // if !llvm::LLVMRustStartMultithreading() {\n@@ -3102,7 +3103,10 @@ pub fn trans_crate(sess: session::Session,\n     fill_crate_map(ccx, ccx.crate_map);\n     glue::emit_tydescs(ccx);\n     write_abi_version(ccx);\n-\n+        if ccx.sess.opts.debuginfo {\n+            debuginfo::finalize(ccx);\n+        }\n+        \n     // Translate the metadata.\n     write_metadata(ccx, crate);\n     if ccx.sess.trans_stats() {"}, {"sha": "a01c2b89bf9d0e410fb8af084bd7f02bf60c056c", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 424, "deletions": 705, "changes": 1129, "blob_url": "https://github.com/rust-lang/rust/blob/868f9a88d6a0a495c10baa35a2fb359b5681375f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/868f9a88d6a0a495c10baa35a2fb359b5681375f/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=868f9a88d6a0a495c10baa35a2fb359b5681375f", "patch": "@@ -11,31 +11,27 @@\n use core::prelude::*;\n \n use driver::session;\n-use lib::llvm::ValueRef;\n use lib::llvm::llvm;\n-use middle::trans::context::task_llcx;\n+use lib::llvm::{ValueRef, ModuleRef, ContextRef};\n+use lib::llvm::debuginfo::*;\n use middle::trans::common::*;\n use middle::trans::machine;\n use middle::trans::type_of;\n use middle::trans;\n use middle::ty;\n use util::ppaux::ty_to_str;\n \n-use core::cast;\n use core::hashmap::HashMap;\n use core::libc;\n-use core::option;\n-use core::ptr;\n-use core::str;\n-use core::sys;\n-use core::vec;\n+use core::libc::c_uint;\n+use core::str::as_c_str;\n use syntax::codemap::span;\n+use syntax::parse::token::ident_interner;\n use syntax::{ast, codemap, ast_util, ast_map};\n \n-static LLVMDebugVersion: int = (9 << 16);\n+static LLVMDebugVersion: int = (12 << 16);\n \n-static DW_LANG_RUST: int = 0x9000;\n-static DW_VIRTUALITY_none: int = 0;\n+static DW_LANG_RUST: int = 12; //0x9000;\n \n static CompileUnitTag: int = 17;\n static FileDescriptorTag: int = 41;\n@@ -59,302 +55,185 @@ static DW_ATE_signed_char: int = 0x06;\n static DW_ATE_unsigned: int = 0x07;\n static DW_ATE_unsigned_char: int = 0x08;\n \n-fn llstr(s: &str) -> ValueRef {\n-    do str::as_c_str(s) |sbuf| {\n-        unsafe {\n-            llvm::LLVMMDStringInContext(task_llcx(),\n-                                        sbuf,\n-                                        s.len() as libc::c_uint)\n-        }\n-    }\n-}\n-fn lltag(lltag: int) -> ValueRef {\n-    lli32(LLVMDebugVersion | lltag)\n-}\n-fn lli32(val: int) -> ValueRef {\n-    C_i32(val as i32)\n-}\n-fn lli64(val: int) -> ValueRef {\n-    C_i64(val as i64)\n-}\n-fn lli1(bval: bool) -> ValueRef {\n-    C_i1(bval)\n-}\n-fn llmdnode(elems: &[ValueRef]) -> ValueRef {\n-    unsafe {\n-        llvm::LLVMMDNodeInContext(task_llcx(),\n-                                  vec::raw::to_ptr(elems),\n-                                  elems.len() as libc::c_uint)\n-    }\n-}\n-fn llunused() -> ValueRef {\n-    lli32(0x0)\n-}\n-fn llnull() -> ValueRef {\n-    unsafe {\n-        cast::transmute(ptr::null::<ValueRef>())\n-    }\n-}\n-\n-fn add_named_metadata(cx: &CrateContext, name: ~str, val: ValueRef) {\n-    str::as_c_str(name, |sbuf| {\n-        unsafe {\n-            llvm::LLVMAddNamedMetadataOperand(cx.llmod, sbuf, val)\n-        }\n-    })\n-}\n-\n ////////////////\n \n pub struct DebugContext {\n-    llmetadata: metadata_cache,\n+    //llmetadata: metadata_cache,\n     names: namegen,\n-    crate_file: ~str\n-}\n-\n-pub fn mk_ctxt(crate: ~str) -> DebugContext {\n+    crate_file: ~str,\n+    builder: DIBuilderRef,\n+    \n+    created_files: @mut HashMap<~str, DIFile>,\n+    created_functions: @mut HashMap<ast::node_id, DISubprogram>,\n+    created_blocks: @mut HashMap<ast::node_id, DILexicalBlock>,\n+    created_types: @mut HashMap<uint, DIType>\n+}\n+\n+/** Create new DebugContext */\n+pub fn mk_ctxt(llmod: ModuleRef, crate: ~str, intr: @ident_interner) -> DebugContext {\n+    debug!(\"mk_ctxt\");\n+    let builder = unsafe { llvm::DIBuilder_new(llmod) };\n     DebugContext {\n-        llmetadata: @mut HashMap::new(),\n-        names: new_namegen(),\n-        crate_file: crate\n-    }\n+        //llmetadata: @mut HashMap::new(),\n+        names: new_namegen(intr),\n+        crate_file: crate,\n+        builder: builder,\n+        created_files: @mut HashMap::new(),\n+        created_functions: @mut HashMap::new(),\n+        created_blocks: @mut HashMap::new(),\n+        created_types: @mut HashMap::new(),\n }\n-\n-fn update_cache(cache: metadata_cache, mdtag: int, val: debug_metadata) {\n-    let mut existing = match cache.pop(&mdtag) {\n-        Some(arr) => arr, None => ~[]\n-    };\n-    existing.push(val);\n-    cache.insert(mdtag, existing);\n }\n \n-struct Metadata<T> {\n-    node: ValueRef,\n-    data: T\n+#[inline(always)]\n+fn get_builder(cx: @CrateContext) -> DIBuilderRef {\n+    let dbg_cx = cx.dbg_cx.get_ref();\n+    return dbg_cx.builder;\n }\n \n-struct FileMetadata {\n-    path: ~str\n-}\n-struct CompileUnitMetadata {\n-    name: ~str\n-}\n-struct SubProgramMetadata {\n-    id: ast::node_id\n-}\n-struct LocalVarMetadata {\n-    id: ast::node_id\n-}\n-struct TyDescMetadata {\n-    hash: uint\n-}\n-struct BlockMetadata {\n-    start: codemap::Loc,\n-    end: codemap::Loc\n-}\n-struct ArgumentMetadata {\n-    id: ast::node_id\n-}\n-struct RetvalMetadata {\n-    id: ast::node_id\n-}\n-\n-type metadata_cache = @mut HashMap<int, ~[debug_metadata]>;\n-\n-enum debug_metadata {\n-    file_metadata(@Metadata<FileMetadata>),\n-    compile_unit_metadata(@Metadata<CompileUnitMetadata>),\n-    subprogram_metadata(@Metadata<SubProgramMetadata>),\n-    local_var_metadata(@Metadata<LocalVarMetadata>),\n-    tydesc_metadata(@Metadata<TyDescMetadata>),\n-    block_metadata(@Metadata<BlockMetadata>),\n-    argument_metadata(@Metadata<ArgumentMetadata>),\n-    retval_metadata(@Metadata<RetvalMetadata>),\n+fn create_DIArray(builder: DIBuilderRef, arr: &[DIDescriptor]) -> DIArray {\n+    return unsafe { \n+        llvm::DIBuilder_getOrCreateArray(builder, vec::raw::to_ptr(arr), arr.len() as u32) \n+    };\n }\n \n-fn cast_safely<T:Copy,U>(val: T) -> U {\n+/** Create any deferred debug metadata nodes */\n+pub fn finalize(cx: @CrateContext) {\n+    debug!(\"finalize\");\n+    create_compile_unit(cx);\n     unsafe {\n-        let val2 = val;\n-        return cast::transmute(val2);\n-    }\n+        llvm::DIBuilder_finalize(get_builder(cx));\n+        llvm::DIBuilder_delete(get_builder(cx));\n+    };\n }\n \n-fn md_from_metadata<T>(val: debug_metadata) -> T {\n-    match val {\n-      file_metadata(md) => cast_safely(md),\n-      compile_unit_metadata(md) => cast_safely(md),\n-      subprogram_metadata(md) => cast_safely(md),\n-      local_var_metadata(md) => cast_safely(md),\n-      tydesc_metadata(md) => cast_safely(md),\n-      block_metadata(md) => cast_safely(md),\n-      argument_metadata(md) => cast_safely(md),\n-      retval_metadata(md) => cast_safely(md)\n-    }\n+fn filename_from_span(cx: @CrateContext, sp: codemap::span) -> ~str {\n+    /*bad*/copy cx.sess.codemap.lookup_char_pos(sp.lo).file.name\n }\n \n-fn cached_metadata<T:Copy>(cache: metadata_cache,\n-                            mdtag: int,\n-                            eq_fn: &fn(md: T) -> bool)\n-                         -> Option<T> {\n-    if cache.contains_key(&mdtag) {\n-        let items = cache.get(&mdtag);\n-        for items.each |item| {\n-            let md: T = md_from_metadata::<T>(*item);\n-            if eq_fn(copy md) {\n-                return option::Some(copy md);\n-            }\n-        }\n-    }\n-    return option::None;\n-}\n-\n-fn create_compile_unit(cx: &mut CrateContext) -> @Metadata<CompileUnitMetadata> {\n-    let cache = get_cache(cx);\n-    let crate_name = /*bad*/copy (/*bad*/copy cx.dbg_cx).get().crate_file;\n-    let tg = CompileUnitTag;\n-    match cached_metadata::<@Metadata<CompileUnitMetadata>>(cache, tg,\n-                        |md| md.data.name == crate_name) {\n-      option::Some(md) => return md,\n-      option::None => ()\n-    }\n+//fn filename_from_span<'cx>(cx: &'cx CrateContext, sp: codemap::span) -> &'cx str {\n+//    let fname: &str = cx.sess.codemap.lookup_char_pos(sp.lo).file.name;\n+//  return fname;\n+//}\n \n-    let (_, work_dir) = get_file_path_and_dir(\n-        cx.sess.working_dir.to_str(), crate_name);\n-    let unit_metadata = ~[lltag(tg),\n-                         llunused(),\n-                         lli32(DW_LANG_RUST),\n-                         llstr(crate_name),\n-                         llstr(work_dir),\n-                         llstr(env!(\"CFG_VERSION\")),\n-                         lli1(true), // deprecated: main compile unit\n-                         lli1(cx.sess.opts.optimize != session::No),\n-                         llstr(\"\"), // flags (???)\n-                         lli32(0) // runtime version (???)\n-                        ];\n-    let unit_node = llmdnode(unit_metadata);\n-    add_named_metadata(cx, ~\"llvm.dbg.cu\", unit_node);\n-    let mdval = @Metadata {\n-        node: unit_node,\n-        data: CompileUnitMetadata {\n-            name: crate_name\n-        }\n+fn get_file_path_and_dir(work_dir: &str, full_path: &str) -> (~str, ~str) {\n+    let full_path = \n+        if str::starts_with(full_path, work_dir) {\n+            str::slice(full_path, str::len(work_dir) + 1u,\n+                       str::len(full_path)).to_owned()\n+        } else {\n+            full_path.to_owned()\n     };\n-    update_cache(cache, tg, compile_unit_metadata(mdval));\n-\n-    return mdval;\n+    \n+    return (full_path, work_dir.to_owned());\n }\n \n-fn get_cache(cx: &CrateContext) -> metadata_cache {\n-    cx.dbg_cx.get_ref().llmetadata\n-}\n-\n-fn get_file_path_and_dir(work_dir: &str, full_path: &str) -> (~str, ~str) {\n-    (if full_path.starts_with(work_dir) {\n-        full_path.slice(work_dir.len() + 1u,\n-                   full_path.len()).to_owned()\n-    } else {\n-        full_path.to_owned()\n-    }, work_dir.to_owned())\n-}\n+fn create_compile_unit(cx: @CrateContext) {\n+    let crate_name: &str = cx.dbg_cx.get_ref().crate_file;\n \n-fn create_file(cx: &mut CrateContext, full_path: ~str)\n-    -> @Metadata<FileMetadata> {\n-    let cache = get_cache(cx);;\n-    let tg = FileDescriptorTag;\n-    match cached_metadata::<@Metadata<FileMetadata>>(\n-        cache, tg, |md| md.data.path == full_path) {\n-        option::Some(md) => return md,\n-        option::None => ()\n+    let (_, work_dir) = get_file_path_and_dir(\n+        cx.sess.working_dir.to_str(), crate_name);\n+        \n+    let producer = fmt!(\"rustc version %s\", env!(\"CFG_VERSION\"));\n+\n+    do as_c_str(crate_name) |crate_name| {\n+    do as_c_str(work_dir) |work_dir| {\n+    do as_c_str(producer) |producer| {\n+    do as_c_str(\"\") |flags| {\n+    do as_c_str(\"\") |split_name| { unsafe {\n+        llvm::DIBuilder_createCompileUnit(get_builder(cx),\n+            DW_LANG_RUST as c_uint, crate_name, work_dir, producer,\n+            cx.sess.opts.optimize != session::No,\n+            flags, 0, split_name);\n+    }}}}}};\n+}\n+\n+fn create_file(cx: @CrateContext, full_path: &str) -> DIFile {\n+    let mut dbg_cx = cx.dbg_cx.get_ref();\n+\n+    match dbg_cx.created_files.find(&full_path.to_owned()) {\n+        Some(file_md) => return *file_md,\n+        None => ()\n     }\n \n+    debug!(\"create_file: %s\", full_path);\n+\n     let (file_path, work_dir) =\n         get_file_path_and_dir(cx.sess.working_dir.to_str(),\n                               full_path);\n-    let unit_node = create_compile_unit(cx).node;\n-    let file_md = ~[lltag(tg),\n-                   llstr(file_path),\n-                   llstr(work_dir),\n-                   unit_node];\n-    let val = llmdnode(file_md);\n-    let mdval = @Metadata {\n-        node: val,\n-        data: FileMetadata {\n-            path: full_path\n-        }\n-    };\n-    update_cache(cache, tg, file_metadata(mdval));\n-    return mdval;\n+\n+    let file_md =\n+        do as_c_str(file_path) |file_path| {\n+        do as_c_str(work_dir) |work_dir| { unsafe {\n+            llvm::DIBuilder_createFile(get_builder(cx), file_path, work_dir)\n+        }}};\n+\n+    dbg_cx.created_files.insert(full_path.to_owned(), file_md);\n+    return file_md;\n }\n \n fn line_from_span(cm: @codemap::CodeMap, sp: span) -> uint {\n     cm.lookup_char_pos(sp.lo).line\n }\n \n-fn create_block(mut cx: block) -> @Metadata<BlockMetadata> {\n-    let cache = get_cache(cx.ccx());\n-    while cx.node_info.is_none() {\n-        match cx.parent {\n-          Some(b) => cx = b,\n+fn create_block(bcx: block) -> DILexicalBlock {\n+    let mut bcx = bcx;\n+    let mut dbg_cx = bcx.ccx().dbg_cx.get_ref();    \n+\n+    while bcx.node_info.is_none() {\n+        match bcx.parent {\n+          Some(b) => bcx = b,\n           None => fail!()\n         }\n     }\n-    let sp = cx.node_info.get().span;\n-\n-    let start = cx.sess().codemap.lookup_char_pos(sp.lo);\n-    let fname = /*bad*/copy start.file.name;\n-    let end = cx.sess().codemap.lookup_char_pos(sp.hi);\n-    let tg = LexicalBlockTag;\n-    /*match cached_metadata::<@Metadata<BlockMetadata>>(\n-        cache, tg,\n-        {|md| start == md.data.start && end == md.data.end}) {\n-      option::Some(md) { return md; }\n-      option::None {}\n-    }*/\n-\n-    let parent = match cx.parent {\n-        None => create_function(cx.fcx).node,\n-        Some(bcx) => create_block(bcx).node\n-    };\n-    let file_node = create_file(cx.ccx(), /* bad */ fname.to_owned());\n-    let unique_id = match cache.find(&LexicalBlockTag) {\n-      option::Some(v) => v.len() as int,\n-      option::None => 0\n+    let sp = bcx.node_info.get().span;\n+    let id = bcx.node_info.get().id;\n+\n+    match dbg_cx.created_blocks.find(&id) {\n+        Some(block) => return *block,\n+        None => ()\n+    }\n+\n+    debug!(\"create_block: %s\", bcx.sess().codemap.span_to_str(sp));\n+\n+    let start = bcx.sess().codemap.lookup_char_pos(sp.lo);\n+    let end = bcx.sess().codemap.lookup_char_pos(sp.hi);\n+    \n+    let parent = match bcx.parent {\n+        None => create_function(bcx.fcx),\n+        Some(b) => create_block(b)\n     };\n-    let lldata = ~[lltag(tg),\n-                  parent,\n-                  lli32(start.line.to_int()),\n-                  lli32(start.col.to_int()),\n-                  file_node.node,\n-                  lli32(unique_id)\n-                 ];\n-    let val = llmdnode(lldata);\n-    let mdval = @Metadata {\n-        node: val,\n-        data: BlockMetadata {\n-            start: start,\n-            end: end\n-        }\n+\n+    let file_md = create_file(bcx.ccx(), start.file.name);\n+    \n+    let block_md = unsafe {\n+        llvm::LLVMDIBuilderCreateLexicalBlock(\n+            dcx.builder,\n+            parent, file_md,\n+            start.line.to_int() as c_uint, start.col.to_int() as c_uint) \n     };\n-    //update_cache(cache, tg, block_metadata(mdval));\n-    return mdval;\n+\n+    dbg_cx.created_blocks.insert(id, block_md);\n+\n+    return block_md;\n }\n \n-fn size_and_align_of(cx: &mut CrateContext, t: ty::t) -> (int, int) {\n+fn size_and_align_of(cx: @CrateContext, t: ty::t) -> (uint, uint) {\n     let llty = type_of::type_of(cx, t);\n-    (machine::llsize_of_real(cx, llty) as int,\n-     machine::llalign_of_pref(cx, llty) as int)\n+    (machine::llsize_of_real(cx, llty),\n+     machine::llalign_of_pref(cx, llty))\n }\n \n-fn create_basic_type(cx: &mut CrateContext, t: ty::t, span: span)\n-    -> @Metadata<TyDescMetadata> {\n-    let cache = get_cache(cx);\n-    let tg = BasicTypeDescriptorTag;\n-    match cached_metadata::<@Metadata<TyDescMetadata>>(\n-        cache, tg, |md| ty::type_id(t) == md.data.hash) {\n-      option::Some(md) => return md,\n-      option::None => ()\n+fn create_basic_type(cx: @CrateContext, t: ty::t, span: span) -> DIType{\n+    let mut dbg_cx = cx.dbg_cx.get_ref();\n+    let ty_id = ty::type_id(t);\n+    match dbg_cx.created_types.find(&ty_id) {\n+        Some(ty_md) => return *ty_md,\n+        None => ()\n     }\n \n+    debug!(\"create_basic_type: %?\", ty::get(t));\n+\n     let (name, encoding) = match ty::get(t).sty {\n         ty::ty_nil | ty::ty_bot => (~\"uint\", DW_ATE_unsigned),\n         ty::ty_bool => (~\"bool\", DW_ATE_boolean),\n@@ -378,383 +257,255 @@ fn create_basic_type(cx: &mut CrateContext, t: ty::t, span: span)\n             ast::ty_f32 => (~\"f32\", DW_ATE_float),\n             ast::ty_f64 => (~\"f64\", DW_ATE_float)\n         },\n-        _ => cx.sess.bug(\"debuginfo::create_basic_type - t is invalid type\")\n+        _ => cx.sess.bug(~\"debuginfo::create_basic_type - t is invalid type\")\n     };\n \n-    let fname = filename_from_span(cx, span);\n-    let file_node = create_file(cx, fname.to_owned());\n-    let cu_node = create_compile_unit(cx);\n     let (size, align) = size_and_align_of(cx, t);\n-    let lldata = ~[lltag(tg),\n-                  cu_node.node,\n-                  llstr(name),\n-                  file_node.node,\n-                  lli32(0), //XXX source line\n-                  lli64(size * 8),  // size in bits\n-                  lli64(align * 8), // alignment in bits\n-                  lli64(0), //XXX offset?\n-                  lli32(0), //XXX flags?\n-                  lli32(encoding)];\n-    let llnode = llmdnode(lldata);\n-    let mdval = @Metadata {\n-        node: llnode,\n-        data: TyDescMetadata {\n-            hash: ty::type_id(t)\n-        }\n-    };\n-    update_cache(cache, tg, tydesc_metadata(mdval));\n-    add_named_metadata(cx, ~\"llvm.dbg.ty\", llnode);\n-    return mdval;\n+    let ty_md = do as_c_str(name) |name| { unsafe {\n+            llvm::LLVMDIBuilderCreateBasicType(\n+                dcx.builder, name,\n+                size * 8 as u64, align * 8 as u64, encoding as c_uint)\n+        }};\n+\n+    dbg_cx.created_types.insert(ty_id, ty_md);\n+    return ty_md;\n }\n \n-fn create_pointer_type(cx: &mut CrateContext, t: ty::t, span: span,\n-                       pointee: @Metadata<TyDescMetadata>)\n-    -> @Metadata<TyDescMetadata> {\n-    let tg = PointerTypeTag;\n-    /*let cache = cx.llmetadata;\n-    match cached_metadata::<@Metadata<TyDescMetadata>>(\n-        cache, tg, {|md| ty::hash_ty(t) == ty::hash_ty(md.data.hash)}) {\n-      option::Some(md) { return md; }\n-      option::None {}\n-    }*/\n+fn create_pointer_type(cx: @CrateContext, t: ty::t, span: span, pointee: DIType) -> DIType {\n     let (size, align) = size_and_align_of(cx, t);\n-    let fname = filename_from_span(cx, span);\n-    let file_node = create_file(cx, fname.to_owned());\n-    //let cu_node = create_compile_unit(cx, fname);\n     let name = ty_to_str(cx.tcx, t);\n-    let llnode = create_derived_type(tg, file_node.node, name, 0, size * 8,\n-                                     align * 8, 0, pointee.node);\n-    let mdval = @Metadata {\n-        node: llnode,\n-        data: TyDescMetadata {\n-            hash: ty::type_id(t)\n-        }\n-    };\n-    //update_cache(cache, tg, tydesc_metadata(mdval));\n-    add_named_metadata(cx, ~\"llvm.dbg.ty\", llnode);\n-    return mdval;\n-}\n-\n-struct StructCtxt {\n-    file: ValueRef,\n-    name: @str,\n-    line: int,\n-    members: ~[ValueRef],\n-    total_size: int,\n-    align: int\n-}\n-\n-fn finish_structure(cx: @mut StructCtxt) -> ValueRef {\n-    return create_composite_type(StructureTypeTag,\n-                                 cx.name,\n-                                 cx.file,\n-                                 cx.line,\n-                                 cx.total_size,\n-                                 cx.align,\n-                                 0,\n-                                 None,\n-                                 Some(/*bad*/copy cx.members));\n-}\n-\n-fn create_structure(file: @Metadata<FileMetadata>, name: @str, line: int)\n-                 -> @mut StructCtxt {\n-    let cx = @mut StructCtxt {\n-        file: file.node,\n-        name: name,\n-        line: line,\n-        members: ~[],\n-        total_size: 0,\n-        align: 64 //XXX different alignment per arch?\n-    };\n-    return cx;\n-}\n+    let ptr_md = do as_c_str(name) |name| { unsafe {\n+        llvm::DIBuilder_createPointerType(get_builder(cx), \n+                pointee, size * 8 as u64, align * 8 as u64, name)\n+    }};\n+    return ptr_md;\n+}\n+\n+struct StructContext {\n+    cx: @CrateContext,\n+    file: DIFile,\n+    name: ~str,\n+    line: uint,\n+    members: ~[DIDerivedType],\n+    total_size: uint,\n+    align: uint\n+}\n+\n+impl StructContext {\n+    fn create(cx: @CrateContext, file: DIFile, name: ~str, line: uint) -> ~StructContext {\n+        let scx = ~StructContext {\n+            cx: cx,\n+            file: file,\n+            name: name,\n+            line: line,\n+            members: ~[],\n+            total_size: 0,\n+            align: 64 //XXX different alignment per arch?\n+        };\n+        return scx;\n+    }\n \n-fn create_derived_type(type_tag: int, file: ValueRef, name: &str, line: int,\n-                       size: int, align: int, offset: int, ty: ValueRef)\n-    -> ValueRef {\n-    let lldata = ~[lltag(type_tag),\n-                  file,\n-                  llstr(name),\n-                  file,\n-                  lli32(line),\n-                  lli64(size),\n-                  lli64(align),\n-                  lli64(offset),\n-                  lli32(0),\n-                  ty];\n-    return llmdnode(lldata);\n-}\n+    fn add_member(&mut self, name: &str, line: uint, size: uint, align: uint, ty: DIType) {\n+        let mem_t = do as_c_str(name) |name| { unsafe {\n+            llvm::DIBuilder_createMemberType(get_builder(self.cx), \n+                ptr::null(), name, self.file, line as c_uint,\n+                size * 8 as u64, align * 8 as u64, self.total_size as u64, \n+                0, ty)\n+            }};\n+        // XXX What about member alignment???\n+        self.members.push(mem_t);\n+        self.total_size += size * 8;\n+    }\n \n-fn add_member(cx: @mut StructCtxt,\n-              name: &str,\n-              line: int,\n-              size: int,\n-              align: int,\n-              ty: ValueRef) {\n-    cx.members.push(create_derived_type(MemberTag, cx.file, name, line,\n-                                        size * 8, align * 8, cx.total_size,\n-                                        ty));\n-    cx.total_size += size * 8;\n+    fn finalize(&self) -> DICompositeType {\n+        let members_md = create_DIArray(get_builder(self.cx), self.members);\n+\n+        let struct_md =\n+            do as_c_str(self.name) |name| { unsafe {\n+                llvm::LLVMDIBuilderCreateStructType(\n+                    dcx.builder, ptr::null(), name, \n+                    self.file, self.line as c_uint,\n+                    self.total_size as u64, self.align as u64, 0, ptr::null(),\n+                    members_md, 0, ptr::null())\n+            }};\n+        return struct_md;\n+    }\n }\n \n-fn create_struct(cx: &mut CrateContext, t: ty::t, fields: ~[ty::field],\n-                 span: span) -> @Metadata<TyDescMetadata> {\n+fn create_struct(cx: @CrateContext, t: ty::t, fields: ~[ty::field], span: span) -> DICompositeType {\n     let fname = filename_from_span(cx, span);\n-    let file_node = create_file(cx, fname.to_owned());\n-    let scx = create_structure(file_node, (ty_to_str(cx.tcx, t)).to_managed(),\n-                               line_from_span(cx.sess.codemap, span) as int);\n+    let file_md = create_file(cx, fname);\n+    let line = line_from_span(cx.sess.codemap, span);\n+\n+    let mut scx = StructContext::create(cx, file_md, ty_to_str(cx.tcx, t), line);\n     for fields.each |field| {\n         let field_t = field.mt.ty;\n         let ty_md = create_ty(cx, field_t, span);\n         let (size, align) = size_and_align_of(cx, field_t);\n-        add_member(scx, cx.sess.str_of(field.ident),\n-                   line_from_span(cx.sess.codemap, span) as int,\n-                   size as int, align as int, ty_md.node);\n+        scx.add_member(cx.sess.str_of(field.ident),\n+                   line_from_span(cx.sess.codemap, span),\n+                   size, align, ty_md);\n     }\n-    let mdval = @Metadata {\n-        node: finish_structure(scx),\n-        data: TyDescMetadata {\n-            hash: ty::type_id(t)\n-        }\n-    };\n-    return mdval;\n+    return scx.finalize();\n }\n \n-fn create_tuple(cx: &mut CrateContext, t: ty::t, elements: &[ty::t], span: span)\n-    -> @Metadata<TyDescMetadata> {\n+// returns (void* type as a ValueRef, size in bytes, align in bytes)\n+fn voidptr() -> (DIDerivedType, uint, uint) {\n+    let size = sys::size_of::<ValueRef>();\n+    let align = sys::min_align_of::<ValueRef>();\n+    let vp = ptr::null();\n+    /*\n+    let vp = create_derived_type(PointerTypeTag, null, ~\"\", 0,\n+                                 size, align, 0, null);\n+    */\n+    return (vp, size, align);\n+}\n+\n+fn create_tuple(cx: @CrateContext, t: ty::t, elements: &[ty::t], span: span) -> DICompositeType {\n     let fname = filename_from_span(cx, span);\n-    let file_node = create_file(cx, fname.to_owned());\n-    let scx = create_structure(file_node,\n-                               cx.sess.str_of(\n-                                   ((/*bad*/copy cx.dbg_cx).get().names)\n-                                   (\"tuple\")),\n-                               line_from_span(cx.sess.codemap, span) as int);\n+    let file_md = create_file(cx, fname);\n+\n+    let name = (cx.sess.str_of((dcx.names)(\"tuple\"))).to_owned();\n+    let mut scx = StructContext::create(cx, file_md, name, loc.line);\n+\n     for elements.each |element| {\n         let ty_md = create_ty(cx, *element, span);\n         let (size, align) = size_and_align_of(cx, *element);\n-        add_member(scx, \"\", line_from_span(cx.sess.codemap, span) as int,\n-                   size as int, align as int, ty_md.node);\n+        scx.add_member(\"\", line_from_span(cx.sess.codemap, span),\n+                   size, align, ty_md);\n     }\n-    let mdval = @Metadata {\n-        node: finish_structure(scx),\n-        data: TyDescMetadata {\n-            hash: ty::type_id(t)\n-        }\n-    };\n-    return mdval;\n-}\n-\n-// returns (void* type as a ValueRef, size in bytes, align in bytes)\n-fn voidptr() -> (ValueRef, int, int) {\n-    let null = ptr::null();\n-    let size = sys::size_of::<ValueRef>() as int;\n-    let align = sys::min_align_of::<ValueRef>() as int;\n-    let vp = create_derived_type(PointerTypeTag, null, \"\", 0,\n-                                 size, align, 0, null);\n-    return (vp, size, align);\n+    return scx.finalize();\n }\n \n-fn create_boxed_type(cx: &mut CrateContext, contents: ty::t,\n-                     span: span, boxed: @Metadata<TyDescMetadata>)\n-    -> @Metadata<TyDescMetadata> {\n-    //let tg = StructureTypeTag;\n-    /*let cache = cx.llmetadata;\n-    match cached_metadata::<@Metadata<TyDescMetadata>>(\n-        cache, tg, {|md| ty::hash_ty(contents) == ty::hash_ty(md.data.hash)}) {\n-      option::Some(md) { return md; }\n-      option::None {}\n-    }*/\n+fn create_boxed_type(cx: @CrateContext, contents: ty::t,\n+                     span: span, boxed: DIType) -> DICompositeType {\n     let fname = filename_from_span(cx, span);\n-    let file_node = create_file(cx, fname.to_owned());\n-    //let cu_node = create_compile_unit_metadata(cx, fname);\n+    let file_md = create_file(cx, fname);\n     let int_t = ty::mk_int();\n     let refcount_type = create_basic_type(cx, int_t, span);\n     let name = ty_to_str(cx.tcx, contents);\n-    let scx = create_structure(file_node, (fmt!(\"box<%s>\", name)).to_managed(), 0);\n-    add_member(scx, \"refcnt\", 0, sys::size_of::<uint>() as int,\n-               sys::min_align_of::<uint>() as int, refcount_type.node);\n+\n+    let mut scx = StructContext::create(cx, file_md, fmt!(\"box<%s>\", name), 0);\n+    scx.add_member(\"refcnt\", 0, sys::size_of::<uint>(),\n+               sys::min_align_of::<uint>(), refcount_type);\n     // the tydesc and other pointers should be irrelevant to the\n     // debugger, so treat them as void* types\n     let (vp, vpsize, vpalign) = voidptr();\n-    add_member(scx, \"tydesc\", 0, vpsize, vpalign, vp);\n-    add_member(scx, \"prev\", 0, vpsize, vpalign, vp);\n-    add_member(scx, \"next\", 0, vpsize, vpalign, vp);\n+    scx.add_member(\"tydesc\", 0, vpsize, vpalign, vp);\n+    scx.add_member(\"prev\", 0, vpsize, vpalign, vp);\n+    scx.add_member(\"next\", 0, vpsize, vpalign, vp);\n     let (size, align) = size_and_align_of(cx, contents);\n-    add_member(scx, \"boxed\", 0, size, align, boxed.node);\n-    let llnode = finish_structure(scx);\n-    let mdval = @Metadata {\n-        node: llnode,\n-        data: TyDescMetadata {\n-            hash: ty::type_id(contents)\n-        }\n-    };\n-    //update_cache(cache, tg, tydesc_metadata(mdval));\n-    add_named_metadata(cx, ~\"llvm.dbg.ty\", llnode);\n-    return mdval;\n-}\n-\n-fn create_composite_type(type_tag: int, name: &str, file: ValueRef,\n-                         line: int, size: int, align: int, offset: int,\n-                         derived: Option<ValueRef>,\n-                         members: Option<~[ValueRef]>)\n-    -> ValueRef {\n-    let lldata = ~[lltag(type_tag),\n-                  file,\n-                  llstr(name), // type name\n-                  file, // source file definition\n-                  lli32(line), // source line definition\n-                  lli64(size), // size of members\n-                  lli64(align), // align\n-                  lli32/*64*/(offset), // offset\n-                  lli32(0), // flags\n-                  if derived.is_none() {\n-                      llnull()\n-                  } else { // derived from\n-                      derived.get()\n-                  },\n-                  if members.is_none() {\n-                      llnull()\n-                  } else { //members\n-                      llmdnode(members.get())\n-                  },\n-                  lli32(0),  // runtime language\n-                  llnull()\n-                 ];\n-    return llmdnode(lldata);\n+    scx.add_member(\"boxed\", 0, size, align, boxed);\n+    return scx.finalize();\n }\n \n-fn create_fixed_vec(cx: &mut CrateContext, vec_t: ty::t, elem_t: ty::t,\n-                    len: int, span: span) -> @Metadata<TyDescMetadata> {\n-    let t_md = create_ty(cx, elem_t, span);\n+fn create_fixed_vec(cx: @CrateContext, vec_t: ty::t, elem_t: ty::t,\n+                    len: uint, span: span) -> DIType {\n+    let elem_ty_md = create_ty(cx, elem_t, span);\n     let fname = filename_from_span(cx, span);\n-    let file_node = create_file(cx, fname.to_owned());\n+    let file_md = create_file(cx, fname);\n     let (size, align) = size_and_align_of(cx, elem_t);\n-    let subrange = llmdnode([lltag(SubrangeTag), lli64(0), lli64(len - 1)]);\n-    let name = fmt!(\"[%s]\", ty_to_str(cx.tcx, elem_t));\n-    let array = create_composite_type(ArrayTypeTag, name, file_node.node, 0,\n-                                      size * len, align, 0, Some(t_md.node),\n-                                      Some(~[subrange]));\n-    @Metadata {\n-        node: array,\n-        data: TyDescMetadata {\n-            hash: ty::type_id(vec_t)\n-        }\n-    }\n+\n+    let subrange = unsafe {\n+        llvm::DIBuilder_getOrCreateSubrange(get_builder(cx), 0_i64, (len-1) as i64) };\n+\n+    let subscripts = create_DIArray(get_builder(cx), [subrange]);\n+    return unsafe {\n+        llvm::DIBuilder_createVectorType(get_builder(cx), \n+            size * len as u64, align as u64, elem_ty_md, subscripts) \n+    };\n }\n \n-fn create_boxed_vec(cx: &mut CrateContext, vec_t: ty::t, elem_t: ty::t,\n-                    vec_ty_span: codemap::span)\n-    -> @Metadata<TyDescMetadata> {\n+fn create_boxed_vec(cx: @CrateContext, vec_t: ty::t, elem_t: ty::t,\n+                    vec_ty_span: codemap::span) -> DICompositeType {\n     let fname = filename_from_span(cx, vec_ty_span);\n-    let file_node = create_file(cx, fname.to_owned());\n+    let file_md = create_file(cx, fname);\n     let elem_ty_md = create_ty(cx, elem_t, vec_ty_span);\n-    let vec_scx = create_structure(file_node,\n-                               ty_to_str(cx.tcx, vec_t).to_managed(), 0);\n+\n+    let mut vec_scx = StructContext::create(cx, file_md, ty_to_str(cx.tcx, vec_t), 0);\n+\n     let size_t_type = create_basic_type(cx, ty::mk_uint(), vec_ty_span);\n-    add_member(vec_scx, \"fill\", 0, sys::size_of::<libc::size_t>() as int,\n-               sys::min_align_of::<libc::size_t>() as int, size_t_type.node);\n-    add_member(vec_scx, \"alloc\", 0, sys::size_of::<libc::size_t>() as int,\n-               sys::min_align_of::<libc::size_t>() as int, size_t_type.node);\n-    let subrange = llmdnode([lltag(SubrangeTag), lli64(0), lli64(0)]);\n+    vec_scx.add_member(\"fill\", 0, sys::size_of::<libc::size_t>(),\n+               sys::min_align_of::<libc::size_t>(), size_t_type);\n+    vec_scx.add_member(\"alloc\", 0, sys::size_of::<libc::size_t>(),\n+               sys::min_align_of::<libc::size_t>(), size_t_type);\n+    let subrange = unsafe { llvm::DIBuilder_getOrCreateSubrange(get_builder(cx), 0_i64, 0_i64) };\n     let (arr_size, arr_align) = size_and_align_of(cx, elem_t);\n     let name = fmt!(\"[%s]\", ty_to_str(cx.tcx, elem_t));\n-    let data_ptr = create_composite_type(ArrayTypeTag, name, file_node.node, 0,\n-                                         arr_size, arr_align, 0,\n-                                         Some(elem_ty_md.node),\n-                                         Some(~[subrange]));\n-    add_member(vec_scx, \"data\", 0, 0, // clang says the size should be 0\n-               sys::min_align_of::<u8>() as int, data_ptr);\n-    let llnode = finish_structure(vec_scx);\n-    let vec_md = @Metadata {\n-        node: llnode,\n-        data: TyDescMetadata {\n-            hash: ty::type_id(vec_t)\n-        }\n-    };\n \n-    let box_scx = create_structure(file_node, (fmt!(\"box<%s>\", name)).to_managed(), 0);\n+    let subscripts = create_DIArray(get_builder(cx), [subrange]);\n+    let data_ptr = unsafe { llvm::DIBuilder_createVectorType(get_builder(cx), \n+                arr_size as u64, arr_align as u64, elem_ty_md, subscripts) };\n+    vec_scx.add_member(\"data\", 0, 0, // clang says the size should be 0\n+               sys::min_align_of::<u8>(), data_ptr);\n+    let vec_md = vec_scx.finalize();\n+\n+    let mut box_scx = StructContext::create(cx, file_md, fmt!(\"box<%s>\", name), 0);\n     let int_t = ty::mk_int();\n     let refcount_type = create_basic_type(cx, int_t, vec_ty_span);\n-    add_member(box_scx, \"refcnt\", 0, sys::size_of::<uint>() as int,\n-               sys::min_align_of::<uint>() as int, refcount_type.node);\n+    box_scx.add_member(\"refcnt\", 0, sys::size_of::<uint>(),\n+               sys::min_align_of::<uint>(), refcount_type);\n     let (vp, vpsize, vpalign) = voidptr();\n-    add_member(box_scx, \"tydesc\", 0, vpsize, vpalign, vp);\n-    add_member(box_scx, \"prev\", 0, vpsize, vpalign, vp);\n-    add_member(box_scx, \"next\", 0, vpsize, vpalign, vp);\n-    let size = 2 * sys::size_of::<int>() as int;\n-    let align = sys::min_align_of::<int>() as int;\n-    add_member(box_scx, \"boxed\", 0, size, align, vec_md.node);\n-    let llnode = finish_structure(box_scx);\n-    let mdval = @Metadata {\n-        node: llnode,\n-        data: TyDescMetadata {\n-            hash: ty::type_id(elem_t)\n-        }\n-    };\n+    box_scx.add_member(\"tydesc\", 0, vpsize, vpalign, vp);\n+    box_scx.add_member(\"prev\", 0, vpsize, vpalign, vp);\n+    box_scx.add_member(\"next\", 0, vpsize, vpalign, vp);\n+    let size = 2 * sys::size_of::<int>();\n+    let align = sys::min_align_of::<int>();\n+    box_scx.add_member(\"boxed\", 0, size, align, vec_md);\n+    let mdval = box_scx.finalize();\n     return mdval;\n }\n \n-fn create_vec_slice(cx: &mut CrateContext, vec_t: ty::t, elem_t: ty::t, span: span)\n-    -> @Metadata<TyDescMetadata> {\n+fn create_vec_slice(cx: @CrateContext, vec_t: ty::t, elem_t: ty::t, span: span) -> DICompositeType {\n     let fname = filename_from_span(cx, span);\n-    let file_node = create_file(cx, fname.to_owned());\n+    let file_md = create_file(cx, fname);\n     let elem_ty_md = create_ty(cx, elem_t, span);\n     let uint_type = create_basic_type(cx, ty::mk_uint(), span);\n     let elem_ptr = create_pointer_type(cx, elem_t, span, elem_ty_md);\n-    let scx = create_structure(file_node, ty_to_str(cx.tcx, vec_t).to_managed(), 0);\n+\n+    let mut scx = StructContext::create(cx, file_md, ty_to_str(cx.tcx, vec_t), 0);\n     let (_, ptr_size, ptr_align) = voidptr();\n-    add_member(scx, \"vec\", 0, ptr_size, ptr_align, elem_ptr.node);\n-    add_member(scx, \"length\", 0, sys::size_of::<uint>() as int,\n-               sys::min_align_of::<uint>() as int, uint_type.node);\n-    let llnode = finish_structure(scx);\n-    let mdval = @Metadata {\n-        node: llnode,\n-        data: TyDescMetadata {\n-            hash: ty::type_id(vec_t)\n-        }\n-    };\n-    return mdval;\n+    scx.add_member(\"vec\", 0, ptr_size, ptr_align, elem_ptr);\n+    scx.add_member(\"length\", 0, sys::size_of::<uint>(),\n+               sys::min_align_of::<uint>(), uint_type);\n+    return scx.finalize();\n }\n \n-fn create_fn_ty(cx: &mut CrateContext, fn_ty: ty::t, inputs: ~[ty::t], output: ty::t,\n-                span: span) -> @Metadata<TyDescMetadata> {\n+fn create_fn_ty(cx: @CrateContext, fn_ty: ty::t, inputs: ~[ty::t], output: ty::t,\n+                span: span) -> DICompositeType {\n     let fname = filename_from_span(cx, span);\n-    let file_node = create_file(cx, fname.to_owned());\n+    let file_md = create_file(cx, fname);\n     let (vp, _, _) = voidptr();\n     let output_md = create_ty(cx, output, span);\n     let output_ptr_md = create_pointer_type(cx, output, span, output_md);\n-    let inputs_vals = do inputs.map |arg| { create_ty(cx, *arg, span).node };\n-    let members = ~[output_ptr_md.node, vp] + inputs_vals;\n-    let llnode = create_composite_type(SubroutineTag, \"\", file_node.node,\n-                                       0, 0, 0, 0, None, Some(members));\n-    let mdval = @Metadata {\n-        node: llnode,\n-        data: TyDescMetadata {\n-            hash: ty::type_id(fn_ty)\n-        }\n+    let inputs_vals = do inputs.map |arg| { create_ty(cx, *arg, span) };\n+    let members = ~[output_ptr_md, vp] + inputs_vals;\n+\n+    return unsafe {\n+        llvm::DIBuilder_createSubroutineType(get_builder(cx), file_md, \n+            create_DIArray(get_builder(cx), members)) \n     };\n-    return mdval;\n }\n \n-fn create_ty(cx: &mut CrateContext, t: ty::t, span: span)\n-    -> @Metadata<TyDescMetadata> {\n+fn create_ty(cx: @CrateContext, t: ty::t, span: span) -> DIType {\n+    let mut dbg_cx = cx.dbg_cx.get_ref();\n+    let ty_id = ty::type_id(t);\n+    match dbg_cx.created_types.find(&ty_id) {\n+        Some(ty_md) => return *ty_md,\n+        None => ()\n+    }\n+\n     debug!(\"create_ty: %?\", ty::get(t));\n-    /*let cache = get_cache(cx);\n-    match cached_metadata::<@Metadata<TyDescMetadata>>(\n-        cache, tg, {|md| t == md.data.hash}) {\n-      option::Some(md) { return md; }\n-      option::None {}\n-    }*/\n \n     let sty = copy ty::get(t).sty;\n-    match sty {\n+    let ty_md = match sty {\n         ty::ty_nil | ty::ty_bot | ty::ty_bool | ty::ty_int(_) | ty::ty_uint(_)\n         | ty::ty_float(_) => create_basic_type(cx, t, span),\n         ty::ty_estr(ref vstore) => {\n             let i8_t = ty::mk_i8();\n             match *vstore {\n                 ty::vstore_fixed(len) => {\n-                    create_fixed_vec(cx, t, i8_t, len as int + 1, span)\n+                    create_fixed_vec(cx, t, i8_t, len + 1, span)\n                 },\n                 ty::vstore_uniq | ty::vstore_box => {\n                     let box_md = create_boxed_vec(cx, t, i8_t, span);\n@@ -776,7 +527,7 @@ fn create_ty(cx: &mut CrateContext, t: ty::t, span: span)\n         ty::ty_evec(ref mt, ref vstore) => {\n             match *vstore {\n                 ty::vstore_fixed(len) => {\n-                    create_fixed_vec(cx, t, mt.ty, len as int, span)\n+                    create_fixed_vec(cx, t, mt.ty, len, span)\n                 },\n                 ty::vstore_uniq | ty::vstore_box => {\n                     let box_md = create_boxed_vec(cx, t, mt.ty, span);\n@@ -812,156 +563,141 @@ fn create_ty(cx: &mut CrateContext, t: ty::t, span: span)\n         ty::ty_tup(ref elements) => {\n             create_tuple(cx, t, *elements, span)\n         },\n-        _ => cx.sess.bug(\"debuginfo: unexpected type in create_ty\")\n-    }\n-}\n-\n-fn filename_from_span(cx: &CrateContext, sp: codemap::span) -> @str {\n-    cx.sess.codemap.lookup_char_pos(sp.lo).file.name\n-}\n+        _ => cx.sess.bug(~\"debuginfo: unexpected type in create_ty\")\n+    };\n \n-fn create_var(type_tag: int, context: ValueRef, name: &str, file: ValueRef,\n-              line: int, ret_ty: ValueRef) -> ValueRef {\n-    let lldata = ~[lltag(type_tag),\n-                  context,\n-                  llstr(name),\n-                  file,\n-                  lli32(line),\n-                  ret_ty,\n-                  lli32(0)\n-                 ];\n-    return llmdnode(lldata);\n+    dbg_cx.created_types.insert(ty_id, ty_md);\n+    return ty_md;\n }\n \n-pub fn create_local_var(bcx: block, local: @ast::local)\n-    -> @Metadata<LocalVarMetadata> {\n+pub fn create_local_var(bcx: block, local: @ast::local) -> DIVariable {\n+    debug!(\"create_local_var\");\n     let cx = bcx.ccx();\n+    /*\n     let cache = get_cache(cx);\n     let tg = AutoVariableTag;\n     match cached_metadata::<@Metadata<LocalVarMetadata>>(\n         cache, tg, |md| md.data.id == local.node.id) {\n       option::Some(md) => return md,\n       option::None => ()\n     }\n+    */\n \n     let name = match local.node.pat.node {\n       ast::pat_ident(_, pth, _) => ast_util::path_to_ident(pth),\n       // FIXME this should be handled (#2533)\n       _ => fail!(\"no single variable name for local\")\n     };\n-    let loc = cx.sess.codemap.lookup_char_pos(local.span.lo);\n+    let name: &str = cx.sess.str_of(ident);\n+    debug!(\"create_local_var: %s\", name);\n+\n+    let loc = span_start(cx, local.span);\n     let ty = node_id_type(bcx, local.node.id);\n     let tymd = create_ty(cx, ty, local.node.ty.span);\n-    let filemd = create_file(cx, /*bad*/ loc.file.name.to_owned());\n+    let filemd = create_file(cx, /*bad*/copy loc.file.name);\n     let context = match bcx.parent {\n-        None => create_function(bcx.fcx).node,\n-        Some(_) => create_block(bcx).node\n+        None => create_function(bcx.fcx),\n+        Some(_) => create_block(bcx)\n     };\n-    let mdnode = create_var(tg, context, cx.sess.str_of(name),\n-                            filemd.node, loc.line as int, tymd.node);\n-    let mdval = @Metadata {\n-        node: mdnode,\n-        data: LocalVarMetadata {\n-            id: local.node.id\n-        }\n-    };\n-    update_cache(cache, AutoVariableTag, local_var_metadata(mdval));\n-\n-    // FIXME(#6814) Should use `pat_util::pat_bindings` for pats like (a, b) etc\n-    let llptr = match bcx.fcx.lllocals.find_copy(&local.node.pat.id) {\n-        Some(v) => v,\n-        None => {\n-            bcx.tcx().sess.span_bug(\n-                local.span,\n-                fmt!(\"No entry in lllocals table for %?\", local.node.id));\n+\n+    let mdval = do as_c_str(*cx.sess.str_of(name)) |name| { unsafe {\n+        llvm::DIBuilder_createLocalVariable(get_builder(cx), AutoVariableTag as u32,\n+                 ptr::null(), name, filemd, loc.line as c_uint, tymd, false, 0, 0)\n+        }};\n+\n+    let llptr = match bcx.fcx.lllocals.find(&local.node.id) {\n+      option::Some(&local_mem(v)) => v,\n+      option::Some(_) => {\n+        bcx.tcx().sess.span_bug(local.span, \"local is bound to something weird\");\n         }\n+      option::None => {\n+        match bcx.fcx.lllocals.get_copy(&local.node.pat.id) {\n+          local_imm(v) => v,\n+          _ => bcx.tcx().sess.span_bug(local.span, \"local is bound to something weird\")\n+    }\n+      }\n     };\n-    let declargs = ~[llmdnode([llptr]), mdnode];\n-    trans::build::Call(bcx, cx.intrinsics.get_copy(&(\"llvm.dbg.declare\")),\n+    /*\n+    llvm::DIBuilder_insertDeclare(get_builder(cx), llptr, mdval, \n+\n+    let declargs = ~[llmdnode(~[llptr]), mdnode];\n+    trans::build::Call(bcx, *cx.intrinsics.get(&~\"llvm.dbg.declare\"),\n                        declargs);\n+    */\n     return mdval;\n-}\n+    }\n \n-pub fn create_arg(bcx: block, arg: ast::arg, sp: span)\n-    -> Option<@Metadata<ArgumentMetadata>> {\n-    let fcx = bcx.fcx;\n-    let cx = fcx.ccx;\n+pub fn create_arg(bcx: block, arg: ast::arg, sp: span) -> Option<DIVariable> {\n+    debug!(\"create_arg\");\n+    let fcx = bcx.fcx, cx = *fcx.ccx;\n+    /*\n     let cache = get_cache(cx);\n     let tg = ArgVariableTag;\n     match cached_metadata::<@Metadata<ArgumentMetadata>>(\n         cache, ArgVariableTag, |md| md.data.id == arg.id) {\n       option::Some(md) => return Some(md),\n       option::None => ()\n     }\n+    */\n \n     let loc = cx.sess.codemap.lookup_char_pos(sp.lo);\n     if \"<intrinsic>\" == loc.file.name {\n         return None;\n     }\n     let ty = node_id_type(bcx, arg.id);\n     let tymd = create_ty(cx, ty, arg.ty.span);\n-    let filemd = create_file(cx, /* bad */ loc.file.name.to_owned());\n+    let filemd = create_file(cx, /*bad*/copy loc.file.name);\n     let context = create_function(bcx.fcx);\n \n     match arg.pat.node {\n         ast::pat_ident(_, path, _) => {\n             // XXX: This is wrong; it should work for multiple bindings.\n-            let mdnode = create_var(\n-                tg,\n-                context.node,\n-                cx.sess.str_of(*path.idents.last()),\n-                filemd.node,\n-                loc.line as int,\n-                tymd.node\n-            );\n-\n-            let mdval = @Metadata {\n-                node: mdnode,\n-                data: ArgumentMetadata {\n-                    id: arg.id\n-                }\n+            let ident = path.idents.last();\n+            let name: &str = cx.sess.str_of(*ident);\n+            let mdnode = do as_c_str(name) |name| { unsafe {\n+                llvm::LLVMDIBuilderCreateLocalVariable(dcx.builder,\n+                    ArgVariableTag as u32, context, name,\n+                    filemd, loc.line as c_uint, tymd, false, 0, 0)\n+                    // XXX need to pass a real argument number\n+            }};\n+\n+            let llptr = match fcx.llargs.get_copy(&arg.id) {\n+              local_mem(v) | local_imm(v) => v,\n             };\n-            update_cache(cache, tg, argument_metadata(mdval));\n-\n-            let llptr = fcx.llargs.get_copy(&arg.id);\n-            let declargs = ~[llmdnode([llptr]), mdnode];\n-            trans::build::Call(bcx,\n-                               cx.intrinsics.get_copy(&(\"llvm.dbg.declare\")),\n-                               declargs);\n-            return Some(mdval);\n+            \n+            /*\n+            llvm::DIBuilder_insertDeclare(get_builder(cx), mdnode, llptr, mdnode\n+            */\n+            \n+            return Some(mdnode);\n         }\n         _ => {\n             return None;\n         }\n     }\n }\n \n-pub fn update_source_pos(cx: block, s: span) {\n-    if !cx.sess().opts.debuginfo || (*s.lo == 0 && *s.hi == 0) {\n-        return;\n-    }\n-    let cm = cx.sess().codemap;\n-    let blockmd = create_block(cx);\n-    let loc = cm.lookup_char_pos(s.lo);\n-    let scopedata = ~[lli32(loc.line.to_int()),\n-                     lli32(loc.col.to_int()),\n-                     blockmd.node,\n-                     llnull()];\n-    let dbgscope = llmdnode(scopedata);\n+fn create_debug_loc(line: int, col: int, scope: DIScope) -> DILocation {\n+    let elems = ~[C_i32(line as i32), C_i32(col as i32), scope, ptr::null()];\n     unsafe {\n-        llvm::LLVMSetCurrentDebugLocation(trans::build::B(cx), dbgscope);\n+        return llvm::LLVMMDNode(vec::raw::to_ptr(elems), elems.len() as libc::c_uint);\n     }\n }\n \n-pub fn create_function(fcx: fn_ctxt) -> @Metadata<SubProgramMetadata> {\n-    let mut cx = fcx.ccx;\n-\n-    debug!(\"~~\");\n+    let cm = bcx.sess().codemap;\n+    let blockmd = create_block(bcx);\n+    let loc = cm.lookup_char_pos(sp.lo);\n+    let dbgscope = create_debug_loc(loc.line.to_int(), loc.col.to_int(), blockmd);\n+    unsafe {\n+        llvm::LLVMSetCurrentDebugLocation(trans::build::B(bcx), dbgscope);\n+    }\n+}\n \n+pub fn create_function(fcx: fn_ctxt) -> DISubprogram {\n+    let cx = *fcx.ccx;\n+    let mut dbg_cx = cx.dbg_cx.get_ref();\n     let fcx = &mut *fcx;\n-\n     let sp = fcx.span.get();\n-    debug!(\"%s\", cx.sess.codemap.span_to_str(sp));\n \n     let (ident, ret_ty, id) = match cx.tcx.items.get_copy(&fcx.id) {\n       ast_map::node_item(item, _) => {\n@@ -978,7 +714,6 @@ pub fn create_function(fcx: fn_ctxt) -> @Metadata<SubProgramMetadata> {\n       ast_map::node_expr(expr) => {\n         match expr.node {\n           ast::expr_fn_block(ref decl, _) => {\n-            let dbg_cx = cx.dbg_cx.get_ref();\n             ((dbg_cx.names)(\"fn\"), decl.output, expr.id)\n           }\n           _ => fcx.ccx.sess.span_bug(expr.span,\n@@ -988,62 +723,46 @@ pub fn create_function(fcx: fn_ctxt) -> @Metadata<SubProgramMetadata> {\n       _ => fcx.ccx.sess.bug(\"create_function: unexpected sort of node\")\n     };\n \n-    debug!(\"%?\", ident);\n-    debug!(\"%?\", id);\n-\n-    let cache = get_cache(cx);\n-    match cached_metadata::<@Metadata<SubProgramMetadata>>(\n-        cache, SubprogramTag, |md| md.data.id == id) {\n-      option::Some(md) => return md,\n-      option::None => ()\n+    match dbg_cx.created_functions.find(&id) {\n+        Some(fn_md) => return *fn_md,\n+        None => ()\n     }\n \n+    debug!(\"create_function: %s, %s\", cx.sess.str_of(ident), cx.sess.codemap.span_to_str(span));\n+\n     let loc = cx.sess.codemap.lookup_char_pos(sp.lo);\n-    let file_node = create_file(cx, loc.file.name.to_owned()).node;\n-    let ty_node = if cx.sess.opts.extra_debuginfo {\n+    let file_md = create_file(cx, loc.file.name);\n+\n+    let ret_ty_md = if cx.sess.opts.extra_debuginfo {\n         match ret_ty.node {\n-          ast::ty_nil => llnull(),\n+          ast::ty_nil => ptr::null(),\n           _ => create_ty(cx, ty::node_id_to_type(cx.tcx, id),\n-                         ret_ty.span).node\n+                         ret_ty.span)\n         }\n     } else {\n-        llnull()\n+        ptr::null()\n     };\n-    let sub_node = create_composite_type(SubroutineTag, \"\", file_node, 0, 0,\n-                                         0, 0, option::None,\n-                                         option::Some(~[ty_node]));\n-\n-    let fn_metadata = ~[lltag(SubprogramTag),\n-                       llunused(),\n-                       file_node,\n-                       llstr(cx.sess.str_of(ident)),\n-                        //XXX fully-qualified C++ name:\n-                       llstr(cx.sess.str_of(ident)),\n-                       llstr(\"\"), //XXX MIPS name?????\n-                       file_node,\n-                       lli32(loc.line as int),\n-                       sub_node,\n-                       lli1(false), //XXX static (check export)\n-                       lli1(true), // defined in compilation unit\n-                       lli32(DW_VIRTUALITY_none), // virtual-ness\n-                       lli32(0i), //index into virt func\n-                       /*llnull()*/ lli32(0), // base type with vtbl\n-                       lli32(256), // flags\n-                       lli1(cx.sess.opts.optimize != session::No),\n-                       fcx.llfn\n-                       //list of template params\n-                       //func decl descriptor\n-                       //list of func vars\n-                      ];\n-    let val = llmdnode(fn_metadata);\n-    add_named_metadata(cx, ~\"llvm.dbg.sp\", val);\n-    let mdval = @Metadata {\n-        node: val,\n-        data: SubProgramMetadata {\n-            id: id\n-        }\n-    };\n-    update_cache(cache, SubprogramTag, subprogram_metadata(mdval));\n \n-    return mdval;\n+    let fn_ty = unsafe {\n+        llvm::DIBuilder_createSubroutineType(get_builder(cx),\n+            file_md, create_DIArray(get_builder(cx), [ret_ty_md]))\n+        };\n+\n+    let fn_md =\n+        do as_c_str(cx.sess.str_of(ident)) |name| {\n+        do as_c_str(cx.sess.str_of(ident)) |linkage| { unsafe {\n+            llvm::LLVMDIBuilderCreateFunction(\n+                dcx.builder,\n+                file_md,\n+                name, linkage,\n+                file_md, loc.line as c_uint,\n+                fn_ty, false, true,\n+                loc.line as c_uint,\n+                FlagPrototyped as c_uint,\n+                cx.sess.opts.optimize != session::No,\n+                fcx.llfn, ptr::null(), ptr::null())\n+            }}};\n+\n+    dbg_cx.created_functions.insert(id, fn_md);\n+    return fn_md;\n }"}, {"sha": "315e7c4bcb120be91e6802b0e0f6c3137e7f4cb5", "filename": "src/rustllvm/RustWrapper.cpp", "status": "modified", "additions": 201, "deletions": 0, "changes": 201, "blob_url": "https://github.com/rust-lang/rust/blob/868f9a88d6a0a495c10baa35a2fb359b5681375f/src%2Frustllvm%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/868f9a88d6a0a495c10baa35a2fb359b5681375f/src%2Frustllvm%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FRustWrapper.cpp?ref=868f9a88d6a0a495c10baa35a2fb359b5681375f", "patch": "@@ -560,3 +560,204 @@ extern \"C\" bool LLVMRustStartMultithreading() {\n     assert(lock.release());\n     return ret;\n }\n+\n+\n+typedef DIBuilder* DIBuilderRef;\n+\n+template<typename DIT>\n+DIT unwrapDI(LLVMValueRef ref) { return DIT(ref ? unwrap<MDNode>(ref) : NULL); }\n+\n+extern \"C\" DIBuilderRef DIBuilder_new(LLVMModuleRef M) {\n+    return new DIBuilder(*unwrap(M));\n+}\n+\n+extern \"C\" void DIBuilder_delete(DIBuilderRef Builder) {\n+    delete Builder;\n+}\n+\n+extern \"C\" void DIBuilder_finalize(DIBuilderRef Builder) {\n+    Builder->finalize();\n+}\n+\n+extern \"C\" void DIBuilder_createCompileUnit(\n+    DIBuilderRef Builder,\n+    unsigned Lang,\n+    const char* File,\n+    const char* Dir,\n+    const char* Producer,\n+    bool isOptimized,\n+    const char* Flags,\n+    unsigned RuntimeVer,\n+    const char* SplitName) {\n+    Builder->createCompileUnit(Lang, File, Dir, Producer, isOptimized,\n+        Flags, RuntimeVer, SplitName);\n+}\n+\n+extern \"C\" LLVMValueRef DIBuilder_createFile(\n+    DIBuilderRef Builder,\n+    const char* Filename,\n+    const char* Directory) {\n+    return wrap(Builder->createFile(Filename, Directory));\n+}\n+\n+extern \"C\" LLVMValueRef DIBuilder_createSubroutineType(\n+    DIBuilderRef Builder,\n+    LLVMValueRef File, \n+    LLVMValueRef ParameterTypes) {\n+    return wrap(Builder->createSubroutineType(\n+        unwrapDI<DIFile>(File), \n+        unwrapDI<DIArray>(ParameterTypes)));\n+}\n+\n+extern \"C\" LLVMValueRef DIBuilder_createFunction(\n+    DIBuilderRef Builder,\n+    LLVMValueRef Scope, \n+    const char* Name,\n+    const char* LinkageName,\n+    LLVMValueRef File,  \n+    unsigned LineNo,\n+    LLVMValueRef Ty, \n+    bool isLocalToUnit,\n+    bool isDefinition,\n+    unsigned ScopeLine,\n+    unsigned Flags,\n+    bool isOptimized,\n+    LLVMValueRef Fn,\n+    LLVMValueRef TParam,\n+    LLVMValueRef Decl) {\n+    return wrap(Builder->createFunction(\n+        unwrapDI<DIScope>(Scope), Name, LinkageName, \n+        unwrapDI<DIFile>(File), LineNo, \n+        unwrapDI<DIType>(Ty), isLocalToUnit, isDefinition, ScopeLine, \n+        Flags, isOptimized,\n+        unwrap<Function>(Fn), \n+        unwrapDI<MDNode*>(TParam),\n+        unwrapDI<MDNode*>(Decl)));\n+}\n+\n+extern \"C\" LLVMValueRef DIBuilder_createBasicType(\n+    DIBuilderRef Builder,\n+    const char* Name,\n+    uint64_t SizeInBits,\n+    uint64_t AlignInBits,\n+    unsigned Encoding) {\n+    return wrap(Builder->createBasicType(\n+        Name, SizeInBits, \n+        AlignInBits, Encoding));\n+}\n+    \n+extern \"C\" LLVMValueRef DIBuilder_createPointerType(\n+    DIBuilderRef Builder,\n+    LLVMValueRef PointeeTy,\n+    uint64_t SizeInBits,\n+    uint64_t AlignInBits,\n+    const char* Name) {\n+    return wrap(Builder->createPointerType(\n+        unwrapDI<DIType>(PointeeTy), SizeInBits, AlignInBits, Name));\n+}\n+\n+extern \"C\" LLVMValueRef DIBuilder_createStructType(\n+    DIBuilderRef Builder,\n+    LLVMValueRef Scope,\n+    const char* Name,\n+    LLVMValueRef File,\n+    unsigned LineNumber,\n+    uint64_t SizeInBits,\n+    uint64_t AlignInBits,\n+    unsigned Flags,\n+    LLVMValueRef DerivedFrom,\n+    LLVMValueRef Elements,\n+    unsigned RunTimeLang,\n+    LLVMValueRef VTableHolder) {\n+    return wrap(Builder->createStructType(\n+        unwrapDI<DIDescriptor>(Scope), Name, \n+        unwrapDI<DIFile>(File), LineNumber, \n+        SizeInBits, AlignInBits, Flags, \n+        unwrapDI<DIType>(DerivedFrom), \n+        unwrapDI<DIArray>(Elements), RunTimeLang, \n+        unwrapDI<MDNode*>(VTableHolder)));\n+}\n+\n+extern \"C\" LLVMValueRef DIBuilder_createMemberType(\n+    DIBuilderRef Builder,\n+    LLVMValueRef Scope,\n+    const char* Name,\n+    LLVMValueRef File,\n+    unsigned LineNo,\n+    uint64_t SizeInBits,\n+    uint64_t AlignInBits,\n+    uint64_t OffsetInBits,\n+    unsigned Flags,\n+    LLVMValueRef Ty) {\n+    return wrap(Builder->createMemberType(\n+        unwrapDI<DIDescriptor>(Scope), Name, \n+        unwrapDI<DIFile>(File), LineNo,\n+        SizeInBits, AlignInBits, OffsetInBits, Flags, \n+        unwrapDI<DIType>(Ty)));\n+}\n+    \n+extern \"C\" LLVMValueRef DIBuilder_createLexicalBlock(\n+    DIBuilderRef Builder,\n+    LLVMValueRef Scope,\n+    LLVMValueRef File,\n+    unsigned Line,\n+    unsigned Col) {\n+    return wrap(Builder->createLexicalBlock(\n+        unwrapDI<DIDescriptor>(Scope), \n+        unwrapDI<DIFile>(File), Line, Col));\n+}\n+    \n+extern \"C\" LLVMValueRef DIBuilder_createLocalVariable(\n+    DIBuilderRef Builder,\n+    unsigned Tag,\n+    LLVMValueRef Scope,\n+    const char* Name,\n+    LLVMValueRef File,\n+    unsigned LineNo,\n+    LLVMValueRef Ty,\n+    bool AlwaysPreserve,\n+    unsigned Flags,\n+    unsigned ArgNo) {\n+    return wrap(Builder->createLocalVariable(Tag, \n+        unwrapDI<DIDescriptor>(Scope), Name, \n+        unwrapDI<DIFile>(File), \n+        LineNo, \n+        unwrapDI<DIType>(Ty), AlwaysPreserve, Flags, ArgNo));\n+}\n+\n+extern \"C\" LLVMValueRef DIBuilder_createVectorType(\n+    DIBuilderRef Builder,\n+    uint64_t Size,  \n+    uint64_t AlignInBits,  \n+    LLVMValueRef Ty, \n+    LLVMValueRef Subscripts) {\n+    return wrap(Builder->createVectorType(Size, AlignInBits,\n+        unwrapDI<DIType>(Ty), \n+        unwrapDI<DIArray>(Subscripts)));\n+}\n+\n+extern \"C\" LLVMValueRef DIBuilder_getOrCreateSubrange(\n+    DIBuilderRef Builder, \n+    int64_t Lo, \n+    int64_t Count) {\n+    return wrap(Builder->getOrCreateSubrange(Lo, Count));\n+}\n+\n+extern \"C\" LLVMValueRef DIBuilder_getOrCreateArray(\n+    DIBuilderRef Builder,\n+    LLVMValueRef* Ptr, \n+    unsigned Count) {\n+    return wrap(Builder->getOrCreateArray(\n+        ArrayRef<Value*>(reinterpret_cast<Value**>(Ptr), Count)));\n+}\n+\n+extern \"C\" LLVMValueRef DIBuilder_insertDeclare(\n+    DIBuilderRef Builder,\n+    LLVMValueRef Val,\n+    LLVMValueRef VarInfo,\n+    LLVMValueRef InsertBefore) {\n+    return wrap(Builder->insertDeclare(\n+        unwrap(Val), \n+        unwrapDI<DIVariable>(VarInfo), \n+        unwrap<Instruction>(InsertBefore)));\n+}"}, {"sha": "71d574aecbec07babc63ad39e90251fe2b287482", "filename": "src/rustllvm/rustllvm.def.in", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/868f9a88d6a0a495c10baa35a2fb359b5681375f/src%2Frustllvm%2Frustllvm.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/868f9a88d6a0a495c10baa35a2fb359b5681375f/src%2Frustllvm%2Frustllvm.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2Frustllvm.def.in?ref=868f9a88d6a0a495c10baa35a2fb359b5681375f", "patch": "@@ -588,3 +588,20 @@ LLVMInlineAsm\n LLVMInitializePasses\n LLVMAddPass\n LLVMCreatePass\n+DIBuilder_new\n+DIBuilder_delete\n+DIBuilder_finalize\n+DIBuilder_createCompileUnit\n+DIBuilder_createLocalVariable\n+DIBuilder_createFunction\n+DIBuilder_createFile\n+DIBuilder_createLexicalBlock\n+DIBuilder_createBasicType\n+DIBuilder_createPointerType\n+DIBuilder_createMemberType\n+DIBuilder_createStructType\n+DIBuilder_getOrCreateSubrange\n+DIBuilder_createVectorType\n+DIBuilder_createSubroutineType\n+DIBuilder_getOrCreateArray\n+DIBuilder_insertDeclare"}, {"sha": "d4202abd2854e685a9e6c0774143bbf67b5eb6fd", "filename": "src/rustllvm/rustllvm.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/868f9a88d6a0a495c10baa35a2fb359b5681375f/src%2Frustllvm%2Frustllvm.h", "raw_url": "https://github.com/rust-lang/rust/raw/868f9a88d6a0a495c10baa35a2fb359b5681375f/src%2Frustllvm%2Frustllvm.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2Frustllvm.h?ref=868f9a88d6a0a495c10baa35a2fb359b5681375f", "patch": "@@ -43,6 +43,8 @@\n #include \"llvm/Transforms/IPO.h\"\n #include \"llvm/Transforms/Instrumentation.h\"\n #include \"llvm/Transforms/Vectorize.h\"\n+#include \"llvm/DebugInfo.h\"\n+#include \"llvm/DIBuilder.h\"\n #include \"llvm-c/Core.h\"\n #include \"llvm-c/BitReader.h\"\n #include \"llvm-c/ExecutionEngine.h\""}]}