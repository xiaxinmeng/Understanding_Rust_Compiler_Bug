{"sha": "24a9a14dfa2e14250e8bb60cc70a2a6b20260980", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI0YTlhMTRkZmEyZTE0MjUwZThiYjYwY2M3MGEyYTZiMjAyNjA5ODA=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2017-05-30T17:24:37Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2017-05-30T17:41:38Z"}, "message": "fix various small nits", "tree": {"sha": "358dccbe0711bb5c428c1aa077dd5d1ec7176a1b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/358dccbe0711bb5c428c1aa077dd5d1ec7176a1b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/24a9a14dfa2e14250e8bb60cc70a2a6b20260980", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/24a9a14dfa2e14250e8bb60cc70a2a6b20260980", "html_url": "https://github.com/rust-lang/rust/commit/24a9a14dfa2e14250e8bb60cc70a2a6b20260980", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/24a9a14dfa2e14250e8bb60cc70a2a6b20260980/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "633a34d6d35b7d73e929ecb38bd90d9298092fe2", "url": "https://api.github.com/repos/rust-lang/rust/commits/633a34d6d35b7d73e929ecb38bd90d9298092fe2", "html_url": "https://github.com/rust-lang/rust/commit/633a34d6d35b7d73e929ecb38bd90d9298092fe2"}], "stats": {"total": 49, "additions": 25, "deletions": 24}, "files": [{"sha": "3af3bee3c8badae69c68bf3095b5c74dc9f9f424", "filename": "src/bin/miri.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/24a9a14dfa2e14250e8bb60cc70a2a6b20260980/src%2Fbin%2Fmiri.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24a9a14dfa2e14250e8bb60cc70a2a6b20260980/src%2Fbin%2Fmiri.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fmiri.rs?ref=24a9a14dfa2e14250e8bb60cc70a2a6b20260980", "patch": "@@ -95,8 +95,8 @@ fn after_analysis<'a, 'tcx>(state: &mut CompileState<'a, 'tcx>) {\n         state.hir_crate.unwrap().visit_all_item_likes(&mut Visitor(limits, tcx, state));\n     } else if let Some((entry_node_id, _)) = *state.session.entry_fn.borrow() {\n         let entry_def_id = tcx.hir.local_def_id(entry_node_id);\n-        let start_wrapper = tcx.lang_items.start_fn()\n-                                      .and_then(|start_fn| if tcx.is_mir_available(start_fn) { Some(start_fn) } else { None });\n+        let start_wrapper = tcx.lang_items.start_fn().and_then(|start_fn|\n+                                if tcx.is_mir_available(start_fn) { Some(start_fn) } else { None });\n         miri::eval_main(tcx, entry_def_id, start_wrapper, limits);\n \n         state.session.abort_if_errors();"}, {"sha": "b44116e5b10185944c786578180aa6dfc5045c23", "filename": "src/eval_context.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/24a9a14dfa2e14250e8bb60cc70a2a6b20260980/src%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24a9a14dfa2e14250e8bb60cc70a2a6b20260980/src%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval_context.rs?ref=24a9a14dfa2e14250e8bb60cc70a2a6b20260980", "patch": "@@ -1558,6 +1558,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     }\n \n     pub(super) fn dump_local(&self, lvalue: Lvalue<'tcx>) {\n+        // Debug output\n         if let Lvalue::Local { frame, local, field } = lvalue {\n             let mut allocs = Vec::new();\n             let mut msg = format!(\"{:?}\", local);\n@@ -1744,17 +1745,14 @@ pub fn eval_main<'a, 'tcx: 'a>(\n             let ty = ecx.tcx.types.isize;\n             let layout = ecx.type_layout(ty)?;\n             let size = layout.size(&ecx.tcx.data_layout).bytes();\n-            let align = layout.align(&ecx.tcx.data_layout).pref(); // FIXME is this right?\n+            let align = layout.align(&ecx.tcx.data_layout).abi();\n             ecx.memory.allocate(size, align)?\n         };\n         ecx.frame_mut().return_lvalue = Lvalue::from_ptr(ret_ptr);\n \n-        loop {\n-            if !ecx.step()? {\n-                ecx.memory.deallocate(ret_ptr)?;\n-                return Ok(());\n-            }\n-        }\n+        while ecx.step()? {}\n+        ecx.memory.deallocate(ret_ptr)?;\n+        return Ok(());\n     }\n \n     let mut ecx = EvalContext::new(tcx, limits);"}, {"sha": "799c30f0d4e38ac27a7aee895dfa351ce1a4329f", "filename": "src/terminator/mod.rs", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/24a9a14dfa2e14250e8bb60cc70a2a6b20260980/src%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24a9a14dfa2e14250e8bb60cc70a2a6b20260980/src%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fterminator%2Fmod.rs?ref=24a9a14dfa2e14250e8bb60cc70a2a6b20260980", "patch": "@@ -131,7 +131,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         Ok(())\n     }\n \n-    /// Decides whether it is okay to call the method with signature `real_sig` using signature `sig`\n+    /// Decides whether it is okay to call the method with signature `real_sig` using signature `sig`.\n+    /// FIXME: This should take into account the platform-dependent ABI description.\n     fn check_sig_compat(\n         &mut self,\n         sig: ty::FnSig<'tcx>,\n@@ -284,12 +285,6 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 trace!(\"arg_locals: {:?}\", self.frame().mir.args_iter().collect::<Vec<_>>());\n                 trace!(\"arg_operands: {:?}\", arg_operands);\n                 match sig.abi {\n-                    Abi::Rust | Abi::C => {\n-                        for (arg_local, (arg_val, arg_ty)) in arg_locals.zip(args) {\n-                            let dest = self.eval_lvalue(&mir::Lvalue::Local(arg_local))?;\n-                            self.write_value(arg_val, dest, arg_ty)?;\n-                        }\n-                    }\n                     Abi::RustCall => {\n                         assert_eq!(args.len(), 2);\n \n@@ -332,8 +327,13 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                         } else {\n                             bug!(\"rust-call ABI tuple argument was {:?}, {:?}\", arg_ty, layout);\n                         }\n+                    },\n+                    _ => {\n+                        for (arg_local, (arg_val, arg_ty)) in arg_locals.zip(args) {\n+                            let dest = self.eval_lvalue(&mir::Lvalue::Local(arg_local))?;\n+                            self.write_value(arg_val, dest, arg_ty)?;\n+                        }\n                     }\n-                    _ => unimplemented!(),\n                 }\n                 Ok(())\n             },\n@@ -520,7 +520,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         // Still, we can make many things mostly work by \"emulating\" or ignoring some functions.\n         match &path[..] {\n             \"std::io::_print\" => {\n-                trace!(\"Ignoring output.\");\n+                trace!(\"Ignoring output.  To run programs that print, make sure you have a libstd with full MIR.\");\n                 self.goto_block(destination.unwrap().1);\n                 Ok(())\n             },\n@@ -595,15 +595,16 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             }\n \n             \"__rust_maybe_catch_panic\" => {\n+                // fn __rust_maybe_catch_panic(f: fn(*mut u8), data: *mut u8, data_ptr: *mut usize, vtable_ptr: *mut usize) -> u32\n                 // We abort on panic, so not much is going on here, but we still have to call the closure\n                 let u8_ptr_ty = self.tcx.mk_mut_ptr(self.tcx.types.u8);\n                 let f = args[0].read_ptr(&self.memory)?;\n-                let data = args[1].read_ptr(&self.memory)?; // FIXME: Why does value_to_primval(args[2], u8_ptr_ty)?.to_ptr()? here end up doing the Wrong Thing (TM)?\n+                let data = args[1].read_ptr(&self.memory)?;\n                 let f_instance = self.memory.get_fn(f.alloc_id)?;\n                 self.write_primval(dest, PrimVal::Bytes(0), dest_ty)?;\n \n-                // Now we make a functon call.  TODO: Consider making this re-usable?  EvalContext::step does sth. similar for the TLS dtors,\n-                // and of coruse eval_main.\n+                // Now we make a function call.  TODO: Consider making this re-usable?  EvalContext::step does sth. similar for the TLS dtors,\n+                // and of course eval_main.\n                 let mir = self.load_mir(f_instance.def)?;\n                 self.push_stack_frame(\n                     f_instance,\n@@ -614,11 +615,13 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 )?;\n \n                 let arg_local = self.frame().mir.args_iter().next().ok_or(EvalError::AbiViolation(\"Argument to __rust_maybe_catch_panic does not take enough arguments.\".to_owned()))?;\n-                let dest = self.eval_lvalue(&mir::Lvalue::Local(arg_local))?;\n-                self.write_value(Value::ByVal(PrimVal::Ptr(data)), dest, u8_ptr_ty)?;\n+                let arg_dest = self.eval_lvalue(&mir::Lvalue::Local(arg_local))?;\n+                self.write_value(Value::ByVal(PrimVal::Ptr(data)), arg_dest, u8_ptr_ty)?;\n+\n+                // We ourselbes return 0\n+                self.write_primval(dest, PrimVal::Bytes(0), dest_ty)?;\n \n                 // Don't fall through\n-                // FIXME: Do we have to do self.dump_local(ret) anywhere?\n                 return Ok(());\n             }\n "}]}