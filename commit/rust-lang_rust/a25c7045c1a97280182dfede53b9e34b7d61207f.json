{"sha": "a25c7045c1a97280182dfede53b9e34b7d61207f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEyNWM3MDQ1YzFhOTcyODAxODJkZmVkZTUzYjllMzRiN2Q2MTIwN2Y=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-05-30T21:58:16Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-05-31T04:48:35Z"}, "message": "Rewrite deriving(Decodable, Encodable)\n\nNow it uses the generic deriving code and should in theory work in all cases.", "tree": {"sha": "7842d7fd2351c4482b2aa67f4ed7a31c33c799d4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7842d7fd2351c4482b2aa67f4ed7a31c33c799d4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a25c7045c1a97280182dfede53b9e34b7d61207f", "comment_count": 4, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a25c7045c1a97280182dfede53b9e34b7d61207f", "html_url": "https://github.com/rust-lang/rust/commit/a25c7045c1a97280182dfede53b9e34b7d61207f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a25c7045c1a97280182dfede53b9e34b7d61207f/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d01c7d0d42f204f4532a06b482383a1513ff0e33", "url": "https://api.github.com/repos/rust-lang/rust/commits/d01c7d0d42f204f4532a06b482383a1513ff0e33", "html_url": "https://github.com/rust-lang/rust/commit/d01c7d0d42f204f4532a06b482383a1513ff0e33"}], "stats": {"total": 1264, "additions": 307, "deletions": 957}, "files": [{"sha": "1991b2456d97d8da3c425f2f0da865d9c500f30b", "filename": "src/libsyntax/ext/deriving/decodable.rs", "status": "modified", "additions": 133, "deletions": 393, "changes": 526, "blob_url": "https://github.com/rust-lang/rust/blob/a25c7045c1a97280182dfede53b9e34b7d61207f/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a25c7045c1a97280182dfede53b9e34b7d61207f/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs?ref=a25c7045c1a97280182dfede53b9e34b7d61207f", "patch": "@@ -14,410 +14,150 @@ encodable.rs for more.\n */\n \n use core::prelude::*;\n+use core::vec;\n+use core::uint;\n \n-use ast::*;\n-use ast;\n-use ast_util;\n-use codemap::{span, spanned};\n+use ast::{meta_item, item, expr, m_mutbl};\n+use codemap::span;\n use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n-use ext::deriving::*;\n-use opt_vec;\n-\n-use core::uint;\n-\n-pub fn expand_deriving_decodable(\n-    cx: @ExtCtxt,\n-    span: span,\n-    _mitem: @meta_item,\n-    in_items: ~[@item]\n-) -> ~[@item] {\n-    expand_deriving(\n-        cx,\n-        span,\n-        in_items,\n-        expand_deriving_decodable_struct_def,\n-        expand_deriving_decodable_enum_def\n-    )\n-}\n-\n-fn create_derived_decodable_impl(\n-    cx: @ExtCtxt,\n-    span: span,\n-    type_ident: ident,\n-    generics: &Generics,\n-    method: @method\n-) -> @item {\n-    let decoder_ty_param = cx.typaram(\n-        cx.ident_of(\"__D\"),\n-        @opt_vec::with(\n-            cx.typarambound(\n-                cx.path_global(\n-                    span,\n-                    ~[\n-                        cx.ident_of(\"extra\"),\n-                        cx.ident_of(\"serialize\"),\n-                        cx.ident_of(\"Decoder\"),\n-                    ]))));\n-\n-    // All the type parameters need to bound to the trait.\n-    let generic_ty_params = opt_vec::with(decoder_ty_param);\n-\n-    let methods = [method];\n-    let trait_path = cx.path_all(\n-        span,\n-        true,\n-        ~[\n-            cx.ident_of(\"extra\"),\n-            cx.ident_of(\"serialize\"),\n-            cx.ident_of(\"Decodable\")\n-        ],\n-        None,\n-        ~[\n-            cx.ty_ident(span, cx.ident_of(\"__D\"))\n+use ext::deriving::generic::*;\n+\n+pub fn expand_deriving_decodable(cx: @ExtCtxt,\n+                                 span: span,\n+                                 mitem: @meta_item,\n+                                 in_items: ~[@item]) -> ~[@item] {\n+    let trait_def = TraitDef {\n+        path: Path::new_(~[\"extra\", \"serialize\", \"Decodable\"], None,\n+                         ~[~Literal(Path::new_local(\"__D\"))], true),\n+        additional_bounds: ~[],\n+        generics: LifetimeBounds {\n+            lifetimes: ~[],\n+            bounds: ~[(\"__D\", ~[Path::new(~[\"extra\", \"serialize\", \"Decoder\"])])],\n+        },\n+        methods: ~[\n+            MethodDef {\n+                name: \"decode\",\n+                generics: LifetimeBounds::empty(),\n+                explicit_self: None,\n+                args: ~[Ptr(~Literal(Path::new_local(\"__D\")),\n+                            Borrowed(None, m_mutbl))],\n+                ret_ty: Self,\n+                const_nonmatching: true,\n+                combine_substructure: decodable_substructure,\n+            },\n         ]\n-    );\n-    create_derived_impl(\n-        cx,\n-        span,\n-        type_ident,\n-        generics,\n-        methods,\n-        trait_path,\n-        Generics { ty_params: generic_ty_params, lifetimes: opt_vec::Empty },\n-        opt_vec::Empty\n-    )\n-}\n-\n-// Creates a method from the given set of statements conforming to the\n-// signature of the `decodable` method.\n-fn create_decode_method(\n-    cx: @ExtCtxt,\n-    span: span,\n-    type_ident: ast::ident,\n-    generics: &Generics,\n-    expr: @ast::expr\n-) -> @method {\n-    // Create the `e` parameter.\n-    let d_arg_type = cx.ty_rptr(\n-        span,\n-        cx.ty_ident(span, cx.ident_of(\"__D\")),\n-        None,\n-        ast::m_mutbl\n-    );\n-    let d_ident = cx.ident_of(\"__d\");\n-    let d_arg = cx.arg(span, d_ident, d_arg_type);\n-\n-    // Create the type of the return value.\n-    let output_type = create_self_type_with_params(\n-        cx,\n-        span,\n-        type_ident,\n-        generics\n-    );\n-\n-    // Create the function declaration.\n-    let inputs = ~[d_arg];\n-    let fn_decl = cx.fn_decl(inputs, output_type);\n-\n-    // Create the body block.\n-    let body_block = cx.blk_expr(expr);\n+    };\n \n-    // Create the method.\n-    let explicit_self = spanned { node: sty_static, span: span };\n-    let method_ident = cx.ident_of(\"decode\");\n-    @ast::method {\n-        ident: method_ident,\n-        attrs: ~[],\n-        generics: ast_util::empty_generics(),\n-        explicit_self: explicit_self,\n-        purity: impure_fn,\n-        decl: fn_decl,\n-        body: body_block,\n-        id: cx.next_id(),\n-        span: span,\n-        self_id: cx.next_id(),\n-        vis: public\n-    }\n+    expand_deriving_generic(cx, span, mitem, in_items,\n+                            &trait_def)\n }\n \n-fn call_substructure_decode_method(\n-    cx: @ExtCtxt,\n-    span: span\n-) -> @ast::expr {\n-    // Call the substructure method.\n-    cx.expr_call(\n-        span,\n-        cx.expr_path(\n-            cx.path_global(\n-                span,\n-                ~[\n-                    cx.ident_of(\"extra\"),\n+fn decodable_substructure(cx: @ExtCtxt, span: span,\n+                          substr: &Substructure) -> @expr {\n+    let decoder = substr.nonself_args[0];\n+    let recurse = ~[cx.ident_of(\"extra\"),\n                     cx.ident_of(\"serialize\"),\n                     cx.ident_of(\"Decodable\"),\n-                    cx.ident_of(\"decode\"),\n-                ]\n-            )\n-        ),\n-        ~[\n-            cx.expr_ident(span, cx.ident_of(\"__d\"))\n-        ]\n-    )\n-}\n-\n-fn expand_deriving_decodable_struct_def(\n-    cx: @ExtCtxt,\n-    span: span,\n-    struct_def: &struct_def,\n-    type_ident: ident,\n-    generics: &Generics\n-) -> @item {\n-    // Create the method.\n-    let method = expand_deriving_decodable_struct_method(\n-        cx,\n-        span,\n-        struct_def,\n-        type_ident,\n-        generics\n-    );\n-\n-    // Create the implementation.\n-    create_derived_decodable_impl(\n-        cx,\n-        span,\n-        type_ident,\n-        generics,\n-        method\n-    )\n-}\n-\n-fn expand_deriving_decodable_enum_def(\n-    cx: @ExtCtxt,\n-    span: span,\n-    enum_definition: &enum_def,\n-    type_ident: ident,\n-    generics: &Generics\n-) -> @item {\n-    // Create the method.\n-    let method = expand_deriving_decodable_enum_method(\n-        cx,\n-        span,\n-        enum_definition,\n-        type_ident,\n-        generics\n-    );\n-\n-    // Create the implementation.\n-    create_derived_decodable_impl(\n-        cx,\n-        span,\n-        type_ident,\n-        generics,\n-        method\n-    )\n-}\n-\n-fn create_read_struct_field(\n-    cx: @ExtCtxt,\n-    span: span,\n-    idx: uint,\n-    ident: ident\n-) -> ast::field {\n-    // Call the substructure method.\n-    let decode_expr = call_substructure_decode_method(cx, span);\n-\n-    let d_id = cx.ident_of(\"__d\");\n-\n-    let call_expr = cx.expr_method_call(\n-        span,\n-        cx.expr_ident(span, d_id),\n-        cx.ident_of(\"read_struct_field\"),\n-        ~[\n-            cx.expr_str(span, cx.str_of(ident)),\n-            cx.expr_uint(span, idx),\n-            cx.lambda_expr_1(span, decode_expr, d_id)\n-        ]\n-    );\n-\n-    cx.field_imm(span, ident, call_expr)\n-}\n-\n-fn create_read_struct_arg(\n-    cx: @ExtCtxt,\n-    span: span,\n-    idx: uint,\n-    ident: ident\n-) -> ast::field {\n-    // Call the substructure method.\n-    let decode_expr = call_substructure_decode_method(cx, span);\n-\n-    let call_expr = cx.expr_method_call(\n-        span,\n-        cx.expr_ident(span, cx.ident_of(\"__d\")),\n-        cx.ident_of(\"read_struct_arg\"),\n-        ~[\n-            cx.expr_uint(span, idx),\n-            cx.lambda_expr_0(span, decode_expr),\n-        ]\n-    );\n-\n-    cx.field_imm(span, ident, call_expr)\n-}\n-\n-fn expand_deriving_decodable_struct_method(\n-    cx: @ExtCtxt,\n-    span: span,\n-    struct_def: &struct_def,\n-    type_ident: ident,\n-    generics: &Generics\n-) -> @method {\n-    // Create the body of the method.\n-    let mut i = 0;\n-    let mut fields = ~[];\n-    for struct_def.fields.each |struct_field| {\n-        match struct_field.node.kind {\n-            named_field(ident, _) => {\n-                fields.push(create_read_struct_field(cx, span, i, ident));\n-            }\n-            unnamed_field => {\n-                cx.span_unimpl(\n-                    span,\n-                    \"unnamed fields with `deriving(Decodable)`\"\n-                );\n-            }\n-        }\n-        i += 1;\n-    }\n-\n-    let d_id = cx.ident_of(\"__d\");\n-\n-    let read_struct_expr = cx.expr_method_call(\n-        span,\n-        cx.expr_ident(span, d_id),\n-        cx.ident_of(\"read_struct\"),\n-        ~[\n-            cx.expr_str(span, cx.str_of(type_ident)),\n-            cx.expr_uint(span, fields.len()),\n-            cx.lambda_expr_1(\n-                span,\n-                cx.expr_struct_ident(span, type_ident, fields),\n-                d_id)\n-        ]\n-    );\n-\n-    // Create the method itself.\n-    create_decode_method(cx, span, type_ident, generics, read_struct_expr)\n-}\n-\n-fn create_read_variant_arg(\n-    cx: @ExtCtxt,\n-    span: span,\n-    idx: uint,\n-    variant: &ast::variant\n-) -> ast::arm {\n-    // Create the matching pattern.\n-    let pat = cx.pat_lit(span, cx.expr_uint(span, idx));\n-\n-    // Feed each argument in this variant to the decode function\n-    // as well.\n-    let variant_arg_len = variant_arg_count(cx, span, variant);\n-\n-    let expr = if variant_arg_len == 0 {\n-        cx.expr_ident(span, variant.node.name)\n-    } else {\n-        // Feed the discriminant to the decode function.\n-        let mut args = ~[];\n-\n-        for uint::range(0, variant_arg_len) |j| {\n-            // Call the substructure method.\n-            let expr = call_substructure_decode_method(cx, span);\n-\n-            let d_id = cx.ident_of(\"__d\");\n-\n-            let call_expr = cx.expr_method_call(\n-                span,\n-                cx.expr_ident(span, d_id),\n-                cx.ident_of(\"read_enum_variant_arg\"),\n-                ~[\n-                    cx.expr_uint(span, j),\n-                    cx.lambda_expr_1(span, expr, d_id),\n-                ]\n-            );\n-\n-            args.push(call_expr);\n+                    cx.ident_of(\"decode\")];\n+    // throw an underscore in front to suppress unused variable warnings\n+    let blkarg = cx.ident_of(\"_d\");\n+    let blkdecoder = cx.expr_ident(span, blkarg);\n+    let calldecode = cx.expr_call_global(span, recurse, ~[blkdecoder]);\n+    let lambdadecode = cx.lambda_expr_1(span, calldecode, blkarg);\n+\n+    return match *substr.fields {\n+        StaticStruct(_, ref summary) => {\n+            let nfields = match *summary {\n+                Left(n) => n, Right(ref fields) => fields.len()\n+            };\n+            let read_struct_field = cx.ident_of(\"read_struct_field\");\n+\n+            let getarg = |name: ~str, field: uint| {\n+                cx.expr_method_call(span, blkdecoder, read_struct_field,\n+                                    ~[cx.expr_str(span, name),\n+                                      cx.expr_uint(span, field),\n+                                      lambdadecode])\n+            };\n+\n+            let result = match *summary {\n+                Left(n) => {\n+                    if n == 0 {\n+                        cx.expr_ident(span, substr.type_ident)\n+                    } else {\n+                        let mut fields = vec::with_capacity(n);\n+                        for uint::range(0, n) |i| {\n+                            fields.push(getarg(fmt!(\"_field%u\", i), i));\n+                        }\n+                        cx.expr_call_ident(span, substr.type_ident, fields)\n+                    }\n+                }\n+                Right(ref fields) => {\n+                    let fields = do fields.mapi |i, f| {\n+                        cx.field_imm(span, *f, getarg(cx.str_of(*f), i))\n+                    };\n+                    cx.expr_struct_ident(span, substr.type_ident, fields)\n+                }\n+            };\n+\n+            cx.expr_method_call(span, decoder, cx.ident_of(\"read_struct\"),\n+                                ~[cx.expr_str(span, cx.str_of(substr.type_ident)),\n+                                  cx.expr_uint(span, nfields),\n+                                  cx.lambda_expr_1(span, result, blkarg)])\n         }\n+        StaticEnum(_, ref fields) => {\n+            let variant = cx.ident_of(\"i\");\n+\n+            let mut arms = ~[];\n+            let mut variants = ~[];\n+            let rvariant_arg = cx.ident_of(\"read_enum_variant_arg\");\n+\n+            for fields.eachi |i, f| {\n+                let (name, parts) = match *f { (i, ref p) => (i, p) };\n+                variants.push(cx.expr_str(span, cx.str_of(name)));\n+\n+                let getarg = |field: uint| {\n+                    cx.expr_method_call(span, blkdecoder, rvariant_arg,\n+                                        ~[cx.expr_uint(span, field),\n+                                          lambdadecode])\n+                };\n+\n+                let decoded = match *parts {\n+                    Left(n) => {\n+                        if n == 0 {\n+                            cx.expr_ident(span, name)\n+                        } else {\n+                            let mut fields = vec::with_capacity(n);\n+                            for uint::range(0, n) |i| {\n+                                fields.push(getarg(i));\n+                            }\n+                            cx.expr_call_ident(span, name, fields)\n+                        }\n+                    }\n+                    Right(ref fields) => {\n+                        let fields = do fields.mapi |i, f| {\n+                            cx.field_imm(span, *f, getarg(i))\n+                        };\n+                        cx.expr_struct_ident(span, name, fields)\n+                    }\n+                };\n+                arms.push(cx.arm(span,\n+                                 ~[cx.pat_lit(span, cx.expr_uint(span, i))],\n+                                 decoded));\n+            }\n \n-        cx.expr_call_ident(span, variant.node.name, args)\n-    };\n-\n-    // Create the arm.\n-    cx.arm(span, ~[pat], expr)\n-}\n-\n-fn create_read_enum_variant(\n-    cx: @ExtCtxt,\n-    span: span,\n-    enum_definition: &enum_def\n-) -> @expr {\n-    // Create a vector that contains all the variant names.\n-    let expr_arm_names = cx.expr_vec(\n-        span,\n-        do enum_definition.variants.map |variant| {\n-            cx.expr_str(\n-                span,\n-                cx.str_of(variant.node.name)\n-            )\n+            arms.push(cx.arm_unreachable(span));\n+\n+            let result = cx.expr_match(span, cx.expr_ident(span, variant), arms);\n+            let lambda = cx.lambda_expr(span, ~[blkarg, variant], result);\n+            let variant_vec = cx.expr_vec(span, variants);\n+            let result = cx.expr_method_call(span, blkdecoder,\n+                                             cx.ident_of(\"read_enum_variant\"),\n+                                             ~[variant_vec, lambda]);\n+            cx.expr_method_call(span, decoder, cx.ident_of(\"read_enum\"),\n+                                ~[cx.expr_str(span, cx.str_of(substr.type_ident)),\n+                                  cx.lambda_expr_1(span, result, blkarg)])\n         }\n-    );\n-\n-    // Create the arms of the match in the method body.\n-    let mut arms = do enum_definition.variants.mapi |i, variant| {\n-        create_read_variant_arg(cx, span, i, variant)\n+        _ => cx.bug(\"expected StaticEnum or StaticStruct in deriving(Decodable)\")\n     };\n-\n-    // Add the impossible case arm.\n-    arms.push(cx.arm_unreachable(span));\n-\n-    // Create the read_enum_variant expression.\n-    cx.expr_method_call(\n-        span,\n-        cx.expr_ident(span, cx.ident_of(\"__d\")),\n-        cx.ident_of(\"read_enum_variant\"),\n-        ~[\n-            expr_arm_names,\n-            cx.lambda_expr(span,\n-                           ~[cx.ident_of(\"__d\"), cx.ident_of(\"__i\")],\n-                           cx.expr_match(span, cx.expr_ident(span, cx.ident_of(\"__i\")), arms))\n-        ]\n-    )\n-}\n-\n-fn expand_deriving_decodable_enum_method(\n-    cx: @ExtCtxt,\n-    span: span,\n-    enum_definition: &enum_def,\n-    type_ident: ast::ident,\n-    generics: &Generics\n-) -> @method {\n-    let read_enum_variant_expr = create_read_enum_variant(\n-        cx,\n-        span,\n-        enum_definition\n-    );\n-\n-    let d_id = cx.ident_of(\"__d\");\n-\n-    // Create the read_enum expression\n-    let read_enum_expr = cx.expr_method_call(\n-        span,\n-        cx.expr_ident(span, d_id),\n-        cx.ident_of(\"read_enum\"),\n-        ~[\n-            cx.expr_str(span, cx.str_of(type_ident)),\n-            cx.lambda_expr_1(span, read_enum_variant_expr, d_id)\n-        ]\n-    );\n-\n-    // Create the method.\n-    create_decode_method(cx, span, type_ident, generics, read_enum_expr)\n }"}, {"sha": "b9c4bf7bf26af1f04a9e930a5ba4358d9e589c42", "filename": "src/libsyntax/ext/deriving/encodable.rs", "status": "modified", "additions": 99, "deletions": 564, "changes": 663, "blob_url": "https://github.com/rust-lang/rust/blob/a25c7045c1a97280182dfede53b9e34b7d61207f/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a25c7045c1a97280182dfede53b9e34b7d61207f/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs?ref=a25c7045c1a97280182dfede53b9e34b7d61207f", "patch": "@@ -77,578 +77,113 @@ would yield functions like:\n \n use core::prelude::*;\n \n-use ast;\n-use ast::*;\n+use ast::{meta_item, item, expr, m_imm, m_mutbl};\n+use codemap::span;\n use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n-use ext::deriving::*;\n-use codemap::{span, spanned};\n-use ast_util;\n-use opt_vec;\n-\n-pub fn expand_deriving_encodable(\n-    cx: @ExtCtxt,\n-    span: span,\n-    _mitem: @meta_item,\n-    in_items: ~[@item]\n-) -> ~[@item] {\n-    expand_deriving(\n-        cx,\n-        span,\n-        in_items,\n-        expand_deriving_encodable_struct_def,\n-        expand_deriving_encodable_enum_def\n-    )\n-}\n-\n-fn create_derived_encodable_impl(\n-    cx: @ExtCtxt,\n-    span: span,\n-    type_ident: ident,\n-    generics: &Generics,\n-    method: @method\n-) -> @item {\n-    let encoder_ty_param = cx.typaram(\n-        cx.ident_of(\"__E\"),\n-        @opt_vec::with(\n-            cx.typarambound(\n-                cx.path_global(\n-                    span,\n-                    ~[\n-                        cx.ident_of(\"extra\"),\n-                        cx.ident_of(\"serialize\"),\n-                        cx.ident_of(\"Encoder\"),\n-                    ]))));\n-\n-    // All the type parameters need to bound to the trait.\n-    let generic_ty_params = opt_vec::with(encoder_ty_param);\n-\n-    let methods = [method];\n-    let trait_path = cx.path_all(\n-        span,\n-        true,\n-        ~[\n-            cx.ident_of(\"extra\"),\n-            cx.ident_of(\"serialize\"),\n-            cx.ident_of(\"Encodable\")\n-        ],\n-        None,\n-        ~[\n-            cx.ty_ident(span, cx.ident_of(\"__E\"))\n+use ext::deriving::generic::*;\n+\n+pub fn expand_deriving_encodable(cx: @ExtCtxt,\n+                                 span: span,\n+                                 mitem: @meta_item,\n+                                 in_items: ~[@item]) -> ~[@item] {\n+    let trait_def = TraitDef {\n+        path: Path::new_(~[\"extra\", \"serialize\", \"Encodable\"], None,\n+                         ~[~Literal(Path::new_local(\"__E\"))], true),\n+        additional_bounds: ~[],\n+        generics: LifetimeBounds {\n+            lifetimes: ~[],\n+            bounds: ~[(\"__E\", ~[Path::new(~[\"extra\", \"serialize\", \"Encoder\"])])],\n+        },\n+        methods: ~[\n+            MethodDef {\n+                name: \"encode\",\n+                generics: LifetimeBounds::empty(),\n+                explicit_self: Some(Some(Borrowed(None, m_imm))),\n+                args: ~[Ptr(~Literal(Path::new_local(\"__E\")),\n+                            Borrowed(None, m_mutbl))],\n+                ret_ty: nil_ty(),\n+                const_nonmatching: true,\n+                combine_substructure: encodable_substructure,\n+            },\n         ]\n-    );\n-    create_derived_impl(\n-        cx,\n-        span,\n-        type_ident,\n-        generics,\n-        methods,\n-        trait_path,\n-        Generics { ty_params: generic_ty_params, lifetimes: opt_vec::Empty },\n-        opt_vec::Empty\n-    )\n-}\n-\n-// Creates a method from the given set of statements conforming to the\n-// signature of the `encodable` method.\n-fn create_encode_method(\n-    cx: @ExtCtxt,\n-    span: span,\n-    statements: ~[@stmt]\n-) -> @method {\n-    // Create the `e` parameter.\n-    let e_arg_type = cx.ty_rptr(\n-        span,\n-        cx.ty_ident(span, cx.ident_of(\"__E\")),\n-        None,\n-        ast::m_mutbl\n-    );\n-    let e_arg = cx.arg(span, cx.ident_of(\"__e\"), e_arg_type);\n-\n-    // Create the type of the return value.\n-    let output_type = cx.ty_nil();\n-\n-    // Create the function declaration.\n-    let inputs = ~[e_arg];\n-    let fn_decl = cx.fn_decl(inputs, output_type);\n-\n-    // Create the body block.\n-    let body_block = cx.blk(span, statements, None);\n-\n-    // Create the method.\n-    let explicit_self = spanned { node: sty_region(None, m_imm), span: span };\n-    let method_ident = cx.ident_of(\"encode\");\n-    @ast::method {\n-        ident: method_ident,\n-        attrs: ~[],\n-        generics: ast_util::empty_generics(),\n-        explicit_self: explicit_self,\n-        purity: impure_fn,\n-        decl: fn_decl,\n-        body: body_block,\n-        id: cx.next_id(),\n-        span: span,\n-        self_id: cx.next_id(),\n-        vis: public\n-    }\n-}\n-\n-fn call_substructure_encode_method(\n-    cx: @ExtCtxt,\n-    span: span,\n-    self_field: @expr\n-) -> @ast::expr {\n-    // Gather up the parameters we want to chain along.\n-    let e_ident = cx.ident_of(\"__e\");\n-    let e_expr = cx.expr_ident(span, e_ident);\n-\n-    // Call the substructure method.\n-    let encode_ident = cx.ident_of(\"encode\");\n-    cx.expr_method_call(\n-        span,\n-        self_field,\n-        encode_ident,\n-        ~[e_expr]\n-    )\n-}\n-\n-fn expand_deriving_encodable_struct_def(\n-    cx: @ExtCtxt,\n-    span: span,\n-    struct_def: &struct_def,\n-    type_ident: ident,\n-    generics: &Generics\n-) -> @item {\n-    // Create the method.\n-    let method = expand_deriving_encodable_struct_method(\n-        cx,\n-        span,\n-        type_ident,\n-        struct_def\n-    );\n-\n-    // Create the implementation.\n-    create_derived_encodable_impl(\n-        cx,\n-        span,\n-        type_ident,\n-        generics,\n-        method\n-    )\n-}\n-\n-fn expand_deriving_encodable_enum_def(\n-    cx: @ExtCtxt,\n-    span: span,\n-    enum_definition: &enum_def,\n-    type_ident: ident,\n-    generics: &Generics\n-) -> @item {\n-    // Create the method.\n-    let method = expand_deriving_encodable_enum_method(\n-        cx,\n-        span,\n-        type_ident,\n-        enum_definition\n-    );\n+    };\n \n-    // Create the implementation.\n-    create_derived_encodable_impl(\n-        cx,\n-        span,\n-        type_ident,\n-        generics,\n-        method\n-    )\n+    expand_deriving_generic(cx, span, mitem, in_items,\n+                            &trait_def)\n }\n \n-fn expand_deriving_encodable_struct_method(\n-    cx: @ExtCtxt,\n-    span: span,\n-    type_ident: ident,\n-    struct_def: &struct_def\n-) -> @method {\n-    // Create the body of the method.\n-    let mut idx = 0;\n-    let mut statements = ~[];\n-    for struct_def.fields.each |struct_field| {\n-        match struct_field.node.kind {\n-            named_field(ident, _) => {\n-                // Create the accessor for this field.\n-                let self_field = cx.expr_field_access(span,\n-                                                      cx.expr_self(span),\n-                                                      ident);\n-\n-                // Call the substructure method.\n-                let encode_expr = call_substructure_encode_method(\n-                    cx,\n-                    span,\n-                    self_field\n-                );\n-\n-                let e_ident = cx.ident_of(\"__e\");\n-\n-                let call_expr = cx.expr_method_call(\n-                    span,\n-                    cx.expr_ident(span, e_ident),\n-                    cx.ident_of(\"emit_struct_field\"),\n-                    ~[\n-                        cx.expr_str(span, cx.str_of(ident)),\n-                        cx.expr_uint(span, idx),\n-                        cx.lambda_expr_1(span, encode_expr, e_ident)\n-                    ]\n-                );\n-\n-                statements.push(cx.stmt_expr(call_expr));\n+fn encodable_substructure(cx: @ExtCtxt, span: span,\n+                          substr: &Substructure) -> @expr {\n+    let encoder = substr.nonself_args[0];\n+    // throw an underscore in front to suppress unused variable warnings\n+    let blkarg = cx.ident_of(\"_e\");\n+    let blkencoder = cx.expr_ident(span, blkarg);\n+    let encode = cx.ident_of(\"encode\");\n+\n+    return match *substr.fields {\n+        Struct(ref fields) => {\n+            let emit_struct_field = cx.ident_of(\"emit_struct_field\");\n+            let mut stmts = ~[];\n+            for fields.eachi |i, f| {\n+                let (name, val) = match *f {\n+                    (Some(id), e, _) => (cx.str_of(id), e),\n+                    (None, e, _) => (fmt!(\"_field%u\", i), e)\n+                };\n+                let enc = cx.expr_method_call(span, val, encode, ~[blkencoder]);\n+                let lambda = cx.lambda_expr_1(span, enc, blkarg);\n+                let call = cx.expr_method_call(span, blkencoder,\n+                                               emit_struct_field,\n+                                               ~[cx.expr_str(span, name),\n+                                                 cx.expr_uint(span, i),\n+                                                 lambda]);\n+                stmts.push(cx.stmt_expr(call));\n             }\n-            unnamed_field => {\n-                cx.span_unimpl(\n-                    span,\n-                    \"unnamed fields with `deriving(Encodable)`\"\n-                );\n-            }\n-        }\n-        idx += 1;\n-    }\n \n-    let e_id = cx.ident_of(\"__e\");\n-    let emit_struct_stmt = cx.expr_method_call(\n-        span,\n-        cx.expr_ident(span, e_id),\n-        cx.ident_of(\"emit_struct\"),\n-        ~[\n-            cx.expr_str(span, cx.str_of(type_ident)),\n-            cx.expr_uint(span, statements.len()),\n-            cx.lambda_stmts_1(span, statements, e_id),\n-        ]\n-    );\n-\n-    let statements = ~[cx.stmt_expr(emit_struct_stmt)];\n-\n-    // Create the method itself.\n-    return create_encode_method(cx, span, statements);\n-}\n-\n-fn expand_deriving_encodable_enum_method(\n-    cx: @ExtCtxt,\n-    span: span,\n-    type_ident: ast::ident,\n-    enum_definition: &enum_def\n-) -> @method {\n-    // Create the arms of the match in the method body.\n-    let arms = do enum_definition.variants.mapi |i, variant| {\n-        // Create the matching pattern.\n-        let (pat, fields) = create_enum_variant_pattern(cx, span, variant, \"__self\", ast::m_imm);\n-\n-        // Feed the discriminant to the encode function.\n-        let mut stmts = ~[];\n-\n-        // Feed each argument in this variant to the encode function\n-        // as well.\n-        let variant_arg_len = variant_arg_count(cx, span, variant);\n-        for fields.eachi |j, &(_, field)| {\n-            // Call the substructure method.\n-            let expr = call_substructure_encode_method(cx, span, field);\n-\n-            let e_ident = cx.ident_of(\"__e\");\n-            let call_expr = cx.expr_method_call(\n-                span,\n-                cx.expr_ident(span, e_ident),\n-                cx.ident_of(\"emit_enum_variant_arg\"),\n-                ~[\n-                    cx.expr_uint(span, j),\n-                    cx.lambda_expr_1(span, expr, e_ident),\n-                ]\n-            );\n-\n-            stmts.push(cx.stmt_expr(call_expr));\n-        }\n-\n-        // Create the pattern body.\n-        let e_id = cx.ident_of(\"__e\");\n-\n-        let call_expr = cx.expr_method_call(\n-            span,\n-            cx.expr_ident(span, e_id),\n-            cx.ident_of(\"emit_enum_variant\"),\n-            ~[\n-                cx.expr_str(span, cx.str_of(variant.node.name)),\n-                cx.expr_uint(span, i),\n-                cx.expr_uint(span, variant_arg_len),\n-                cx.lambda_stmts_1(span, stmts, e_id)\n-            ]\n-        );\n-\n-        //let match_body_block = cx.blk_expr(call_expr);\n+            let blk = cx.lambda_stmts_1(span, stmts, blkarg);\n+            cx.expr_method_call(span, encoder, cx.ident_of(\"emit_struct\"),\n+                                ~[cx.expr_str(span, cx.str_of(substr.type_ident)),\n+                                  cx.expr_uint(span, fields.len()),\n+                                  blk])\n+        }\n+\n+        EnumMatching(idx, variant, ref fields) => {\n+            // We're not generating an AST that the borrow checker is expecting,\n+            // so we need to generate a unique local variable to take the\n+            // mutable loan out on, otherwise we get conflicts which don't\n+            // actually exist.\n+            let me = cx.stmt_let(span, false, blkarg, encoder);\n+            let encoder = cx.expr_ident(span, blkarg);\n+            let emit_variant_arg = cx.ident_of(\"emit_enum_variant_arg\");\n+            let mut stmts = ~[];\n+            for fields.eachi |i, f| {\n+                let val = match *f { (_, e, _) => e };\n+                let enc = cx.expr_method_call(span, val, encode, ~[blkencoder]);\n+                let lambda = cx.lambda_expr_1(span, enc, blkarg);\n+                let call = cx.expr_method_call(span, blkencoder,\n+                                               emit_variant_arg,\n+                                               ~[cx.expr_uint(span, i),\n+                                                 lambda]);\n+                stmts.push(cx.stmt_expr(call));\n+            }\n \n-        // Create the arm.\n-        cx.arm(span, ~[pat], call_expr) //match_body_block)\n+            let blk = cx.lambda_stmts_1(span, stmts, blkarg);\n+            let name = cx.expr_str(span, cx.str_of(variant.node.name));\n+            let call = cx.expr_method_call(span, blkencoder,\n+                                           cx.ident_of(\"emit_enum_variant\"),\n+                                           ~[name,\n+                                             cx.expr_uint(span, idx),\n+                                             cx.expr_uint(span, fields.len()),\n+                                             blk]);\n+            let blk = cx.lambda_expr_1(span, call, blkarg);\n+            let ret = cx.expr_method_call(span, encoder,\n+                                          cx.ident_of(\"emit_enum\"),\n+                                          ~[cx.expr_str(span,\n+                                            cx.str_of(substr.type_ident)),\n+                                            blk]);\n+            cx.expr_blk(cx.blk(span, ~[me], Some(ret)))\n+        }\n+\n+        _ => cx.bug(\"expected Struct or EnumMatching in deriving(Encodable)\")\n     };\n-\n-    let e_ident = cx.ident_of(\"__e\");\n-\n-    // Create the method body.\n-    let lambda_expr = cx.lambda_expr_1(\n-        span,\n-        expand_enum_or_struct_match(cx, span, arms),\n-        e_ident);\n-\n-    let call_expr = cx.expr_method_call(\n-        span,\n-        cx.expr_ident(span, e_ident),\n-        cx.ident_of(\"emit_enum\"),\n-        ~[\n-            cx.expr_str(span, cx.str_of(type_ident)),\n-            lambda_expr,\n-        ]\n-    );\n-\n-    let stmt = cx.stmt_expr(call_expr);\n-\n-    // Create the method.\n-    create_encode_method(cx, span, ~[stmt])\n-}\n-\n-#[cfg(test)]\n-mod test {\n-    extern mod extra;\n-    use core::option::{None, Some};\n-    use extra::serialize::Encodable;\n-    use extra::serialize::Encoder;\n-\n-    // just adding the ones I want to test, for now:\n-    #[deriving(Eq)]\n-    pub enum call {\n-        CallToEmitEnum(~str),\n-        CallToEmitEnumVariant(~str, uint, uint),\n-        CallToEmitEnumVariantArg(uint),\n-        CallToEmitUint(uint),\n-        CallToEmitNil,\n-        CallToEmitStruct(~str,uint),\n-        CallToEmitField(~str,uint),\n-        CallToEmitOption,\n-        CallToEmitOptionNone,\n-        CallToEmitOptionSome,\n-        // all of the ones I was too lazy to handle:\n-        CallToOther\n-    }\n-    // using `@mut` rather than changing the\n-    // type of self in every method of every encoder everywhere.\n-    pub struct TestEncoder {call_log : @mut ~[call]}\n-\n-    pub impl TestEncoder {\n-        // these self's should be &mut self's, as well....\n-        fn add_to_log (&self, c : call) {\n-            self.call_log.push(copy c);\n-        }\n-        fn add_unknown_to_log (&self) {\n-            self.add_to_log (CallToOther)\n-        }\n-    }\n-\n-    impl Encoder for TestEncoder {\n-        fn emit_nil(&mut self) { self.add_to_log(CallToEmitNil) }\n-\n-        fn emit_uint(&mut self, v: uint) {\n-            self.add_to_log(CallToEmitUint(v));\n-        }\n-        fn emit_u64(&mut self, _v: u64) { self.add_unknown_to_log(); }\n-        fn emit_u32(&mut self, _v: u32) { self.add_unknown_to_log(); }\n-        fn emit_u16(&mut self, _v: u16) { self.add_unknown_to_log(); }\n-        fn emit_u8(&mut self, _v: u8)   { self.add_unknown_to_log(); }\n-\n-        fn emit_int(&mut self, _v: int) { self.add_unknown_to_log(); }\n-        fn emit_i64(&mut self, _v: i64) { self.add_unknown_to_log(); }\n-        fn emit_i32(&mut self, _v: i32) { self.add_unknown_to_log(); }\n-        fn emit_i16(&mut self, _v: i16) { self.add_unknown_to_log(); }\n-        fn emit_i8(&mut self, _v: i8)   { self.add_unknown_to_log(); }\n-\n-        fn emit_bool(&mut self, _v: bool) { self.add_unknown_to_log(); }\n-\n-        fn emit_f64(&mut self, _v: f64) { self.add_unknown_to_log(); }\n-        fn emit_f32(&mut self, _v: f32) { self.add_unknown_to_log(); }\n-        fn emit_float(&mut self, _v: float) { self.add_unknown_to_log(); }\n-\n-        fn emit_char(&mut self, _v: char) { self.add_unknown_to_log(); }\n-        fn emit_str(&mut self, _v: &str) { self.add_unknown_to_log(); }\n-\n-        fn emit_enum(&mut self, name: &str, f: &fn(&mut TestEncoder)) {\n-            self.add_to_log(CallToEmitEnum(name.to_str()));\n-            f(self);\n-        }\n-\n-        fn emit_enum_variant(&mut self,\n-                             name: &str,\n-                             id: uint,\n-                             cnt: uint,\n-                             f: &fn(&mut TestEncoder)) {\n-            self.add_to_log(CallToEmitEnumVariant(name.to_str(), id, cnt));\n-            f(self);\n-        }\n-\n-        fn emit_enum_variant_arg(&mut self,\n-                                 idx: uint,\n-                                 f: &fn(&mut TestEncoder)) {\n-            self.add_to_log(CallToEmitEnumVariantArg(idx));\n-            f(self);\n-        }\n-\n-        fn emit_enum_struct_variant(&mut self,\n-                                    name: &str,\n-                                    id: uint,\n-                                    cnt: uint,\n-                                    f: &fn(&mut TestEncoder)) {\n-            self.emit_enum_variant(name, id, cnt, f)\n-        }\n-\n-        fn emit_enum_struct_variant_field(&mut self,\n-                                          _name: &str,\n-                                          idx: uint,\n-                                          f: &fn(&mut TestEncoder)) {\n-            self.emit_enum_variant_arg(idx, f)\n-        }\n-\n-        fn emit_struct(&mut self,\n-                       name: &str,\n-                       len: uint,\n-                       f: &fn(&mut TestEncoder)) {\n-            self.add_to_log(CallToEmitStruct (name.to_str(),len));\n-            f(self);\n-        }\n-        fn emit_struct_field(&mut self,\n-                             name: &str,\n-                             idx: uint,\n-                             f: &fn(&mut TestEncoder)) {\n-            self.add_to_log(CallToEmitField (name.to_str(),idx));\n-            f(self);\n-        }\n-\n-        fn emit_tuple(&mut self, _len: uint, f: &fn(&mut TestEncoder)) {\n-            self.add_unknown_to_log();\n-            f(self);\n-        }\n-        fn emit_tuple_arg(&mut self, _idx: uint, f: &fn(&mut TestEncoder)) {\n-            self.add_unknown_to_log();\n-            f(self);\n-        }\n-\n-        fn emit_tuple_struct(&mut self,\n-                             _name: &str,\n-                             _len: uint,\n-                             f: &fn(&mut TestEncoder)) {\n-            self.add_unknown_to_log();\n-            f(self);\n-        }\n-\n-        fn emit_tuple_struct_arg(&mut self,\n-                                 _idx: uint,\n-                                 f: &fn(&mut TestEncoder)) {\n-            self.add_unknown_to_log();\n-            f(self);\n-        }\n-\n-        fn emit_option(&mut self, f: &fn(&mut TestEncoder)) {\n-            self.add_to_log(CallToEmitOption);\n-            f(self);\n-        }\n-        fn emit_option_none(&mut self) {\n-            self.add_to_log(CallToEmitOptionNone);\n-        }\n-        fn emit_option_some(&mut self, f: &fn(&mut TestEncoder)) {\n-            self.add_to_log(CallToEmitOptionSome);\n-            f(self);\n-        }\n-\n-        fn emit_seq(&mut self, _len: uint, f: &fn(&mut TestEncoder)) {\n-            self.add_unknown_to_log();\n-            f(self);\n-        }\n-        fn emit_seq_elt(&mut self, _idx: uint, f: &fn(&mut TestEncoder)) {\n-            self.add_unknown_to_log();\n-            f(self);\n-        }\n-\n-        fn emit_map(&mut self, _len: uint, f: &fn(&mut TestEncoder)) {\n-            self.add_unknown_to_log();\n-            f(self);\n-        }\n-        fn emit_map_elt_key(&mut self, _idx: uint, f: &fn(&mut TestEncoder)) {\n-            self.add_unknown_to_log();\n-            f(self);\n-        }\n-        fn emit_map_elt_val(&mut self, _idx: uint, f: &fn(&mut TestEncoder)) {\n-            self.add_unknown_to_log();\n-            f(self);\n-        }\n-    }\n-\n-\n-    fn to_call_log<E:Encodable<TestEncoder>>(val: E) -> ~[call] {\n-        let mut te = TestEncoder {\n-            call_log: @mut ~[]\n-        };\n-        val.encode(&mut te);\n-        copy *te.call_log\n-    }\n-\n-    #[deriving(Encodable)]\n-    enum Written {\n-        Book(uint,uint),\n-        Magazine(~str)\n-    }\n-\n-    #[test]\n-    fn test_encode_enum() {\n-        assert_eq!(\n-            to_call_log(Book(34,44)),\n-            ~[\n-                CallToEmitEnum(~\"Written\"),\n-                CallToEmitEnumVariant(~\"Book\",0,2),\n-                CallToEmitEnumVariantArg(0),\n-                CallToEmitUint(34),\n-                CallToEmitEnumVariantArg(1),\n-                CallToEmitUint(44),\n-            ]\n-        );\n-    }\n-\n-    pub struct BPos(uint);\n-\n-    #[deriving(Encodable)]\n-    pub struct HasPos { pos : BPos }\n-\n-    #[test]\n-    fn test_encode_newtype() {\n-        assert_eq!(\n-            to_call_log(HasPos { pos:BPos(48) }),\n-            ~[\n-                CallToEmitStruct(~\"HasPos\",1),\n-                CallToEmitField(~\"pos\",0),\n-                CallToEmitUint(48),\n-            ]\n-        );\n-    }\n-\n-    #[test]\n-    fn test_encode_option() {\n-        let mut v = None;\n-\n-        assert_eq!(\n-            to_call_log(v),\n-            ~[\n-                CallToEmitOption,\n-                CallToEmitOptionNone,\n-            ]\n-        );\n-\n-        v = Some(54u);\n-        assert_eq!(\n-            to_call_log(v),\n-            ~[\n-                CallToEmitOption,\n-                CallToEmitOptionSome,\n-                CallToEmitUint(54)\n-            ]\n-        );\n-    }\n }"}, {"sha": "5458dcfa02707429ffc743dcdb0eaedb047bb377", "filename": "src/test/run-pass/deriving-encodable-decodable.rs", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/a25c7045c1a97280182dfede53b9e34b7d61207f/src%2Ftest%2Frun-pass%2Fderiving-encodable-decodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a25c7045c1a97280182dfede53b9e34b7d61207f/src%2Ftest%2Frun-pass%2Fderiving-encodable-decodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-encodable-decodable.rs?ref=a25c7045c1a97280182dfede53b9e34b7d61207f", "patch": "@@ -0,0 +1,75 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This actually tests a lot more than just encodable/decodable, but it gets the\n+// job done at least\n+\n+extern mod extra;\n+\n+use std::io;\n+use std::rand::{random, Rand};\n+use extra::serialize::*;\n+use extra::ebml;\n+use extra::ebml::writer::Encoder;\n+use extra::ebml::reader::Decoder;\n+\n+#[deriving(Encodable, Decodable, Eq, Rand)]\n+struct A;\n+#[deriving(Encodable, Decodable, Eq, Rand)]\n+struct B(int);\n+#[deriving(Encodable, Decodable, Eq, Rand)]\n+struct C(int, int, uint);\n+\n+#[deriving(Encodable, Decodable, Eq, Rand)]\n+struct D {\n+    a: int,\n+    b: uint,\n+}\n+\n+#[deriving(Encodable, Decodable, Eq, Rand)]\n+enum E {\n+    E1,\n+    E2(uint),\n+    E3(D),\n+    E4{ x: uint },\n+}\n+\n+#[deriving(Encodable, Decodable, Eq, Rand)]\n+enum F { F1 }\n+\n+#[deriving(Encodable, Decodable, Eq, Rand)]\n+struct G<T> {\n+    t: T\n+}\n+\n+fn roundtrip<T: Rand + Eq + Encodable<Encoder> + Decodable<Decoder>>() {\n+    let obj: T = random();\n+    let bytes = do io::with_bytes_writer |w| {\n+        let mut e = Encoder(w);\n+        obj.encode(&mut e);\n+    };\n+    let doc = ebml::reader::Doc(@bytes);\n+    let mut dec = Decoder(doc);\n+    let obj2 = Decodable::decode(&mut dec);\n+    assert!(obj == obj2);\n+}\n+\n+pub fn main() {\n+    roundtrip::<A>();\n+    roundtrip::<B>();\n+    roundtrip::<C>();\n+    roundtrip::<D>();\n+\n+    for 20.times {\n+        roundtrip::<E>();\n+        roundtrip::<F>();\n+        roundtrip::<G<int>>();\n+    }\n+}"}]}