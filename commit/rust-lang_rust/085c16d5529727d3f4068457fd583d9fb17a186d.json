{"sha": "085c16d5529727d3f4068457fd583d9fb17a186d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA4NWMxNmQ1NTI5NzI3ZDNmNDA2ODQ1N2ZkNTgzZDlmYjE3YTE4NmQ=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-06-04T10:12:47Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-06-04T10:12:47Z"}, "message": "Rollup merge of #72923 - Patryk27:fix/52468, r=estebank\n\nImprove E0433, so that it suggests missing imports\n\nCloses #52468", "tree": {"sha": "4cdc59ba93adeff9cfd911641efd5052f7d7bd59", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4cdc59ba93adeff9cfd911641efd5052f7d7bd59"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/085c16d5529727d3f4068457fd583d9fb17a186d", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJe2MkgCRBK7hj4Ov3rIwAAdHIIADNUvPtUpFIXI4T/Ws+GFGrX\nSALJCTKnoJBRSm56hxJtLnQKyGkAC0KnysbcHNg9LUzbH/H26lwSfwMzccNjcuEo\nbe2BPXrIdn9cFt+ffOqKygysygb1WLR1Iwjs49lx+rWwm/7oTcz87ZyDg1A57ehQ\nSy6koPjNPb9XwOAthy8brDpaobZPjBs6dlPHCLrgKomd4sa/iMs/54F3CVdmAi+p\njzDN3gV82BhK2DHlPDZQ7Z1cc+bPuB55gyJWWnMvqqCa0Sg5Y5JIEvfQuYU+VWF5\n/xuUAS+RofpDmii9IH7zy/eY2c5f1CB2eH3FAbXETPza9yoXGdbeaaYwACADY4w=\n=+pSA\n-----END PGP SIGNATURE-----\n", "payload": "tree 4cdc59ba93adeff9cfd911641efd5052f7d7bd59\nparent adc321a1e3c9a3304befa09589bb60f5146f4ade\nparent c55d55e850865138d9d2d1bc365bc08ad4d1a07c\nauthor Dylan DPC <dylan.dpc@gmail.com> 1591265567 +0200\ncommitter GitHub <noreply@github.com> 1591265567 +0200\n\nRollup merge of #72923 - Patryk27:fix/52468, r=estebank\n\nImprove E0433, so that it suggests missing imports\n\nCloses #52468\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/085c16d5529727d3f4068457fd583d9fb17a186d", "html_url": "https://github.com/rust-lang/rust/commit/085c16d5529727d3f4068457fd583d9fb17a186d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/085c16d5529727d3f4068457fd583d9fb17a186d/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "adc321a1e3c9a3304befa09589bb60f5146f4ade", "url": "https://api.github.com/repos/rust-lang/rust/commits/adc321a1e3c9a3304befa09589bb60f5146f4ade", "html_url": "https://github.com/rust-lang/rust/commit/adc321a1e3c9a3304befa09589bb60f5146f4ade"}, {"sha": "c55d55e850865138d9d2d1bc365bc08ad4d1a07c", "url": "https://api.github.com/repos/rust-lang/rust/commits/c55d55e850865138d9d2d1bc365bc08ad4d1a07c", "html_url": "https://github.com/rust-lang/rust/commit/c55d55e850865138d9d2d1bc365bc08ad4d1a07c"}], "stats": {"total": 245, "additions": 198, "deletions": 47}, "files": [{"sha": "cbb2878011c5f2741e4fc206c421d6ea4cba901d", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/085c16d5529727d3f4068457fd583d9fb17a186d/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/085c16d5529727d3f4068457fd583d9fb17a186d/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=085c16d5529727d3f4068457fd583d9fb17a186d", "patch": "@@ -1475,7 +1475,7 @@ crate fn show_candidates(\n     // This is `None` if all placement locations are inside expansions\n     use_placement_span: Option<Span>,\n     candidates: &[ImportSuggestion],\n-    better: bool,\n+    instead: bool,\n     found_use: bool,\n ) {\n     if candidates.is_empty() {\n@@ -1486,6 +1486,7 @@ crate fn show_candidates(\n     // by iterating through a hash map, so make sure they are ordered:\n     let mut path_strings: Vec<_> =\n         candidates.iter().map(|c| path_names_to_string(&c.path)).collect();\n+\n     path_strings.sort();\n     path_strings.dedup();\n \n@@ -1494,8 +1495,9 @@ crate fn show_candidates(\n     } else {\n         (\"one of these\", \"items\")\n     };\n-    let instead = if better { \" instead\" } else { \"\" };\n-    let msg = format!(\"consider importing {} {}{}\", determiner, kind, instead);\n+\n+    let instead = if instead { \" instead\" } else { \"\" };\n+    let mut msg = format!(\"consider importing {} {}{}\", determiner, kind, instead);\n \n     if let Some(span) = use_placement_span {\n         for candidate in &mut path_strings {\n@@ -1507,12 +1509,13 @@ crate fn show_candidates(\n \n         err.span_suggestions(span, &msg, path_strings.into_iter(), Applicability::Unspecified);\n     } else {\n-        let mut msg = msg;\n         msg.push(':');\n+\n         for candidate in path_strings {\n             msg.push('\\n');\n             msg.push_str(&candidate);\n         }\n+\n         err.note(&msg);\n     }\n }"}, {"sha": "2085c8109fd5c826cb344531543b6245506a2981", "filename": "src/librustc_resolve/late.rs", "status": "modified", "additions": 116, "deletions": 30, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/085c16d5529727d3f4068457fd583d9fb17a186d/src%2Flibrustc_resolve%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/085c16d5529727d3f4068457fd583d9fb17a186d/src%2Flibrustc_resolve%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate.rs?ref=085c16d5529727d3f4068457fd583d9fb17a186d", "patch": "@@ -29,8 +29,9 @@ use rustc_span::Span;\n use smallvec::{smallvec, SmallVec};\n \n use log::debug;\n+use rustc_span::source_map::{respan, Spanned};\n use std::collections::BTreeSet;\n-use std::mem::replace;\n+use std::mem::{replace, take};\n \n mod diagnostics;\n crate mod lifetimes;\n@@ -234,6 +235,13 @@ impl<'a> PathSource<'a> {\n         }\n     }\n \n+    fn is_call(self) -> bool {\n+        match self {\n+            PathSource::Expr(Some(&Expr { kind: ExprKind::Call(..), .. })) => true,\n+            _ => false,\n+        }\n+    }\n+\n     crate fn is_expected(self, res: Res) -> bool {\n         match self {\n             PathSource::Type => match res {\n@@ -1620,14 +1628,83 @@ impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n \n         let report_errors = |this: &mut Self, res: Option<Res>| {\n             let (err, candidates) = this.smart_resolve_report_errors(path, span, source, res);\n+\n             let def_id = this.parent_scope.module.normal_ancestor_id;\n-            let better = res.is_some();\n+            let instead = res.is_some();\n             let suggestion =\n                 if res.is_none() { this.report_missing_type_error(path) } else { None };\n-            this.r.use_injections.push(UseError { err, candidates, def_id, better, suggestion });\n+\n+            this.r.use_injections.push(UseError { err, candidates, def_id, instead, suggestion });\n+\n             PartialRes::new(Res::Err)\n         };\n \n+        // For paths originating from calls (like in `HashMap::new()`), tries\n+        // to enrich the plain `failed to resolve: ...` message with hints\n+        // about possible missing imports.\n+        //\n+        // Similar thing, for types, happens in `report_errors` above.\n+        let report_errors_for_call = |this: &mut Self, parent_err: Spanned<ResolutionError<'a>>| {\n+            if !source.is_call() {\n+                return Some(parent_err);\n+            }\n+\n+            // Before we start looking for candidates, we have to get our hands\n+            // on the type user is trying to perform invocation on; basically:\n+            // we're transforming `HashMap::new` into just `HashMap`\n+            let path = if let Some((_, path)) = path.split_last() {\n+                path\n+            } else {\n+                return Some(parent_err);\n+            };\n+\n+            let (mut err, candidates) =\n+                this.smart_resolve_report_errors(path, span, PathSource::Type, None);\n+\n+            if candidates.is_empty() {\n+                err.cancel();\n+                return Some(parent_err);\n+            }\n+\n+            // There are two different error messages user might receive at\n+            // this point:\n+            // - E0412 cannot find type `{}` in this scope\n+            // - E0433 failed to resolve: use of undeclared type or module `{}`\n+            //\n+            // The first one is emitted for paths in type-position, and the\n+            // latter one - for paths in expression-position.\n+            //\n+            // Thus (since we're in expression-position at this point), not to\n+            // confuse the user, we want to keep the *message* from E0432 (so\n+            // `parent_err`), but we want *hints* from E0412 (so `err`).\n+            //\n+            // And that's what happens below - we're just mixing both messages\n+            // into a single one.\n+            let mut parent_err = this.r.into_struct_error(parent_err.span, parent_err.node);\n+\n+            parent_err.cancel();\n+\n+            err.message = take(&mut parent_err.message);\n+            err.code = take(&mut parent_err.code);\n+            err.children = take(&mut parent_err.children);\n+\n+            drop(parent_err);\n+\n+            let def_id = this.parent_scope.module.normal_ancestor_id;\n+\n+            this.r.use_injections.push(UseError {\n+                err,\n+                candidates,\n+                def_id,\n+                instead: false,\n+                suggestion: None,\n+            });\n+\n+            // We don't return `Some(parent_err)` here, because the error will\n+            // be already printed as part of the `use` injections\n+            None\n+        };\n+\n         let partial_res = match self.resolve_qpath_anywhere(\n             id,\n             qself,\n@@ -1637,14 +1714,15 @@ impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n             source.defer_to_typeck(),\n             crate_lint,\n         ) {\n-            Some(partial_res) if partial_res.unresolved_segments() == 0 => {\n+            Ok(Some(partial_res)) if partial_res.unresolved_segments() == 0 => {\n                 if is_expected(partial_res.base_res()) || partial_res.base_res() == Res::Err {\n                     partial_res\n                 } else {\n                     report_errors(self, Some(partial_res.base_res()))\n                 }\n             }\n-            Some(partial_res) if source.defer_to_typeck() => {\n+\n+            Ok(Some(partial_res)) if source.defer_to_typeck() => {\n                 // Not fully resolved associated item `T::A::B` or `<T as Tr>::A::B`\n                 // or `<T>::A::B`. If `B` should be resolved in value namespace then\n                 // it needs to be added to the trait map.\n@@ -1655,25 +1733,34 @@ impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                 }\n \n                 let mut std_path = vec![Segment::from_ident(Ident::with_dummy_span(sym::std))];\n+\n                 std_path.extend(path);\n+\n                 if self.r.primitive_type_table.primitive_types.contains_key(&path[0].ident.name) {\n-                    let cl = CrateLint::No;\n-                    let ns = Some(ns);\n                     if let PathResult::Module(_) | PathResult::NonModule(_) =\n-                        self.resolve_path(&std_path, ns, false, span, cl)\n+                        self.resolve_path(&std_path, Some(ns), false, span, CrateLint::No)\n                     {\n-                        // check if we wrote `str::from_utf8` instead of `std::str::from_utf8`\n+                        // Check if we wrote `str::from_utf8` instead of `std::str::from_utf8`\n                         let item_span =\n                             path.iter().last().map(|segment| segment.ident.span).unwrap_or(span);\n-                        debug!(\"accessed item from `std` submodule as a bare type {:?}\", std_path);\n+\n                         let mut hm = self.r.session.confused_type_with_std_module.borrow_mut();\n                         hm.insert(item_span, span);\n-                        // In some places (E0223) we only have access to the full path\n                         hm.insert(span, span);\n                     }\n                 }\n+\n                 partial_res\n             }\n+\n+            Err(err) => {\n+                if let Some(err) = report_errors_for_call(self, err) {\n+                    self.r.report_error(err.span, err.node);\n+                }\n+\n+                PartialRes::new(Res::Err)\n+            }\n+\n             _ => report_errors(self, None),\n         };\n \n@@ -1682,6 +1769,7 @@ impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n             // Avoid recording definition of `A::B` in `<T as A>::B::C`.\n             self.r.record_partial_res(id, partial_res);\n         }\n+\n         partial_res\n     }\n \n@@ -1711,17 +1799,16 @@ impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         span: Span,\n         defer_to_typeck: bool,\n         crate_lint: CrateLint,\n-    ) -> Option<PartialRes> {\n+    ) -> Result<Option<PartialRes>, Spanned<ResolutionError<'a>>> {\n         let mut fin_res = None;\n+\n         for (i, ns) in [primary_ns, TypeNS, ValueNS].iter().cloned().enumerate() {\n             if i == 0 || ns != primary_ns {\n-                match self.resolve_qpath(id, qself, path, ns, span, crate_lint) {\n-                    // If defer_to_typeck, then resolution > no resolution,\n-                    // otherwise full resolution > partial resolution > no resolution.\n+                match self.resolve_qpath(id, qself, path, ns, span, crate_lint)? {\n                     Some(partial_res)\n                         if partial_res.unresolved_segments() == 0 || defer_to_typeck =>\n                     {\n-                        return Some(partial_res);\n+                        return Ok(Some(partial_res));\n                     }\n                     partial_res => {\n                         if fin_res.is_none() {\n@@ -1732,19 +1819,19 @@ impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n             }\n         }\n \n-        // `MacroNS`\n         assert!(primary_ns != MacroNS);\n+\n         if qself.is_none() {\n             let path_seg = |seg: &Segment| PathSegment::from_ident(seg.ident);\n             let path = Path { segments: path.iter().map(path_seg).collect(), span };\n             if let Ok((_, res)) =\n                 self.r.resolve_macro_path(&path, None, &self.parent_scope, false, false)\n             {\n-                return Some(PartialRes::new(res));\n+                return Ok(Some(PartialRes::new(res)));\n             }\n         }\n \n-        fin_res\n+        Ok(fin_res)\n     }\n \n     /// Handles paths that may refer to associated items.\n@@ -1756,7 +1843,7 @@ impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         ns: Namespace,\n         span: Span,\n         crate_lint: CrateLint,\n-    ) -> Option<PartialRes> {\n+    ) -> Result<Option<PartialRes>, Spanned<ResolutionError<'a>>> {\n         debug!(\n             \"resolve_qpath(id={:?}, qself={:?}, path={:?}, ns={:?}, span={:?})\",\n             id, qself, path, ns, span,\n@@ -1767,10 +1854,10 @@ impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                 // This is a case like `<T>::B`, where there is no\n                 // trait to resolve.  In that case, we leave the `B`\n                 // segment to be resolved by type-check.\n-                return Some(PartialRes::with_unresolved_segments(\n+                return Ok(Some(PartialRes::with_unresolved_segments(\n                     Res::Def(DefKind::Mod, DefId::local(CRATE_DEF_INDEX)),\n                     path.len(),\n-                ));\n+                )));\n             }\n \n             // Make sure `A::B` in `<T as A::B>::C` is a trait item.\n@@ -1800,10 +1887,10 @@ impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n             // The remaining segments (the `C` in our example) will\n             // have to be resolved by type-check, since that requires doing\n             // trait resolution.\n-            return Some(PartialRes::with_unresolved_segments(\n+            return Ok(Some(PartialRes::with_unresolved_segments(\n                 partial_res.base_res(),\n                 partial_res.unresolved_segments() + path.len() - qself.position - 1,\n-            ));\n+            )));\n         }\n \n         let result = match self.resolve_path(&path, Some(ns), true, span, crate_lint) {\n@@ -1838,11 +1925,10 @@ impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                 PartialRes::new(module.res().unwrap())\n             }\n             PathResult::Failed { is_error_from_last_segment: false, span, label, suggestion } => {\n-                self.r.report_error(span, ResolutionError::FailedToResolve { label, suggestion });\n-                PartialRes::new(Res::Err)\n+                return Err(respan(span, ResolutionError::FailedToResolve { label, suggestion }));\n             }\n-            PathResult::Module(..) | PathResult::Failed { .. } => return None,\n-            PathResult::Indeterminate => bug!(\"indetermined path result in resolve_qpath\"),\n+            PathResult::Module(..) | PathResult::Failed { .. } => return Ok(None),\n+            PathResult::Indeterminate => bug!(\"indeterminate path result in resolve_qpath\"),\n         };\n \n         if path.len() > 1\n@@ -1862,7 +1948,7 @@ impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                     PathResult::Module(ModuleOrUniformRoot::Module(module)) => {\n                         module.res().unwrap()\n                     }\n-                    _ => return Some(result),\n+                    _ => return Ok(Some(result)),\n                 }\n             };\n             if result.base_res() == unqualified_result {\n@@ -1871,7 +1957,7 @@ impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n             }\n         }\n \n-        Some(result)\n+        Ok(Some(result))\n     }\n \n     fn with_resolved_label(&mut self, label: Option<Label>, id: NodeId, f: impl FnOnce(&mut Self)) {"}, {"sha": "c7f10fac6bc0826b9556a63b8bd54da5400fea7a", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/085c16d5529727d3f4068457fd583d9fb17a186d/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/085c16d5529727d3f4068457fd583d9fb17a186d/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=085c16d5529727d3f4068457fd583d9fb17a186d", "patch": "@@ -618,13 +618,13 @@ struct PrivacyError<'a> {\n \n struct UseError<'a> {\n     err: DiagnosticBuilder<'a>,\n-    /// Attach `use` statements for these candidates.\n+    /// Candidates which user could `use` to access the missing type.\n     candidates: Vec<ImportSuggestion>,\n-    /// The `NodeId` of the module to place the use-statements in.\n+    /// The `DefId` of the module to place the use-statements in.\n     def_id: DefId,\n-    /// Whether the diagnostic should state that it's \"better\".\n-    better: bool,\n-    /// Extra free form suggestion. Currently used to suggest new type parameter.\n+    /// Whether the diagnostic should say \"instead\" (as in `consider importing ... instead`).\n+    instead: bool,\n+    /// Extra free-form suggestion.\n     suggestion: Option<(Span, &'static str, String, Applicability)>,\n }\n \n@@ -2577,12 +2577,12 @@ impl<'a> Resolver<'a> {\n     }\n \n     fn report_with_use_injections(&mut self, krate: &Crate) {\n-        for UseError { mut err, candidates, def_id, better, suggestion } in\n+        for UseError { mut err, candidates, def_id, instead, suggestion } in\n             self.use_injections.drain(..)\n         {\n             let (span, found_use) = UsePlacementFinder::check(&self.definitions, krate, def_id);\n             if !candidates.is_empty() {\n-                diagnostics::show_candidates(&mut err, span, &candidates, better, found_use);\n+                diagnostics::show_candidates(&mut err, span, &candidates, instead, found_use);\n             } else if let Some((span, msg, sugg, appl)) = suggestion {\n                 err.span_suggestion(span, msg, sugg, appl);\n             }"}, {"sha": "a4daf86cc8a211145cf2daf26a2fbb3e0513b58d", "filename": "src/test/ui/derived-errors/issue-31997-1.stderr", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/085c16d5529727d3f4068457fd583d9fb17a186d/src%2Ftest%2Fui%2Fderived-errors%2Fissue-31997-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/085c16d5529727d3f4068457fd583d9fb17a186d/src%2Ftest%2Fui%2Fderived-errors%2Fissue-31997-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderived-errors%2Fissue-31997-1.stderr?ref=085c16d5529727d3f4068457fd583d9fb17a186d", "patch": "@@ -2,7 +2,14 @@ error[E0433]: failed to resolve: use of undeclared type or module `HashMap`\n   --> $DIR/issue-31997-1.rs:20:19\n    |\n LL |     let mut map = HashMap::new();\n-   |                   ^^^^^^^ use of undeclared type or module `HashMap`\n+   |                   ^^^^^^^ not found in this scope\n+   |\n+help: consider importing one of these items\n+   |\n+LL | use std::collections::HashMap;\n+   |\n+LL | use std::collections::hash_map::HashMap;\n+   |\n \n error: aborting due to previous error\n "}, {"sha": "d555e6542632bcdc3c86940ef570b748b754ac60", "filename": "src/test/ui/error-codes/E0433.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/085c16d5529727d3f4068457fd583d9fb17a186d/src%2Ftest%2Fui%2Ferror-codes%2FE0433.rs", "raw_url": "https://github.com/rust-lang/rust/raw/085c16d5529727d3f4068457fd583d9fb17a186d/src%2Ftest%2Fui%2Ferror-codes%2FE0433.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0433.rs?ref=085c16d5529727d3f4068457fd583d9fb17a186d", "patch": "@@ -1,3 +1,3 @@\n fn main () {\n-    let map = HashMap::new(); //~ ERROR E0433\n+    let map = NonExistingMap::new(); //~ ERROR E0433\n }"}, {"sha": "d9555e1fcf7a8718101600602f1565cf3dd03558", "filename": "src/test/ui/error-codes/E0433.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/085c16d5529727d3f4068457fd583d9fb17a186d/src%2Ftest%2Fui%2Ferror-codes%2FE0433.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/085c16d5529727d3f4068457fd583d9fb17a186d/src%2Ftest%2Fui%2Ferror-codes%2FE0433.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0433.stderr?ref=085c16d5529727d3f4068457fd583d9fb17a186d", "patch": "@@ -1,8 +1,8 @@\n-error[E0433]: failed to resolve: use of undeclared type or module `HashMap`\n+error[E0433]: failed to resolve: use of undeclared type or module `NonExistingMap`\n   --> $DIR/E0433.rs:2:15\n    |\n-LL |     let map = HashMap::new();\n-   |               ^^^^^^^ use of undeclared type or module `HashMap`\n+LL |     let map = NonExistingMap::new();\n+   |               ^^^^^^^^^^^^^^ use of undeclared type or module `NonExistingMap`\n \n error: aborting due to previous error\n "}, {"sha": "c0539434d02073e43920490c63404573a6a50122", "filename": "src/test/ui/hygiene/no_implicit_prelude.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/085c16d5529727d3f4068457fd583d9fb17a186d/src%2Ftest%2Fui%2Fhygiene%2Fno_implicit_prelude.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/085c16d5529727d3f4068457fd583d9fb17a186d/src%2Ftest%2Fui%2Fhygiene%2Fno_implicit_prelude.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fno_implicit_prelude.stderr?ref=085c16d5529727d3f4068457fd583d9fb17a186d", "patch": "@@ -13,9 +13,15 @@ LL |     fn f() { ::bar::m!(); }\n    |              ------------ in this macro invocation\n ...\n LL |         Vec::new();\n-   |         ^^^ use of undeclared type or module `Vec`\n+   |         ^^^ not found in this scope\n    |\n    = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+help: consider importing one of these items\n+   |\n+LL |     use std::prelude::v1::Vec;\n+   |\n+LL |     use std::vec::Vec;\n+   |\n \n error[E0599]: no method named `clone` found for unit type `()` in the current scope\n   --> $DIR/no_implicit_prelude.rs:12:12"}, {"sha": "8c9bc6d76b8b20895283eadf11a51e3580cd953b", "filename": "src/test/ui/resolve/use_suggestion.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/085c16d5529727d3f4068457fd583d9fb17a186d/src%2Ftest%2Fui%2Fresolve%2Fuse_suggestion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/085c16d5529727d3f4068457fd583d9fb17a186d/src%2Ftest%2Fui%2Fresolve%2Fuse_suggestion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fuse_suggestion.rs?ref=085c16d5529727d3f4068457fd583d9fb17a186d", "patch": "@@ -0,0 +1,7 @@\n+fn main() {\n+    let x1 = HashMap::new(); //~ ERROR failed to resolve\n+    let x2 = GooMap::new(); //~ ERROR failed to resolve\n+\n+    let y1: HashMap; //~ ERROR cannot find type\n+    let y2: GooMap; //~ ERROR cannot find type\n+}"}, {"sha": "2fd3d5dccd23d16b17bf0d522b25ea7c2b3eb94f", "filename": "src/test/ui/resolve/use_suggestion.stderr", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/085c16d5529727d3f4068457fd583d9fb17a186d/src%2Ftest%2Fui%2Fresolve%2Fuse_suggestion.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/085c16d5529727d3f4068457fd583d9fb17a186d/src%2Ftest%2Fui%2Fresolve%2Fuse_suggestion.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fuse_suggestion.stderr?ref=085c16d5529727d3f4068457fd583d9fb17a186d", "patch": "@@ -0,0 +1,42 @@\n+error[E0433]: failed to resolve: use of undeclared type or module `GooMap`\n+  --> $DIR/use_suggestion.rs:3:14\n+   |\n+LL |     let x2 = GooMap::new();\n+   |              ^^^^^^ use of undeclared type or module `GooMap`\n+\n+error[E0433]: failed to resolve: use of undeclared type or module `HashMap`\n+  --> $DIR/use_suggestion.rs:2:14\n+   |\n+LL |     let x1 = HashMap::new();\n+   |              ^^^^^^^ not found in this scope\n+   |\n+help: consider importing one of these items\n+   |\n+LL | use std::collections::HashMap;\n+   |\n+LL | use std::collections::hash_map::HashMap;\n+   |\n+\n+error[E0412]: cannot find type `HashMap` in this scope\n+  --> $DIR/use_suggestion.rs:5:13\n+   |\n+LL |     let y1: HashMap;\n+   |             ^^^^^^^ not found in this scope\n+   |\n+help: consider importing one of these items\n+   |\n+LL | use std::collections::HashMap;\n+   |\n+LL | use std::collections::hash_map::HashMap;\n+   |\n+\n+error[E0412]: cannot find type `GooMap` in this scope\n+  --> $DIR/use_suggestion.rs:6:13\n+   |\n+LL |     let y2: GooMap;\n+   |             ^^^^^^ not found in this scope\n+\n+error: aborting due to 4 previous errors\n+\n+Some errors have detailed explanations: E0412, E0433.\n+For more information about an error, try `rustc --explain E0412`."}]}