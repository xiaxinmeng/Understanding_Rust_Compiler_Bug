{"sha": "250ae7923f9b41d826463d21a8187f1b5f0592ab", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI1MGFlNzkyM2Y5YjQxZDgyNjQ2M2QyMWE4MTg3ZjFiNWYwNTkyYWI=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-04-10T13:43:26Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-04-22T14:18:21Z"}, "message": "rustc: make MemCategorizationContext immutable.", "tree": {"sha": "fdc778937b14351e94f519a0268edbbb19ee003c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fdc778937b14351e94f519a0268edbbb19ee003c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/250ae7923f9b41d826463d21a8187f1b5f0592ab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/250ae7923f9b41d826463d21a8187f1b5f0592ab", "html_url": "https://github.com/rust-lang/rust/commit/250ae7923f9b41d826463d21a8187f1b5f0592ab", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/250ae7923f9b41d826463d21a8187f1b5f0592ab/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "45c8cb3597256390c69ff5ad6a7ee565114a1ec7", "url": "https://api.github.com/repos/rust-lang/rust/commits/45c8cb3597256390c69ff5ad6a7ee565114a1ec7", "html_url": "https://github.com/rust-lang/rust/commit/45c8cb3597256390c69ff5ad6a7ee565114a1ec7"}], "stats": {"total": 126, "additions": 60, "deletions": 66}, "files": [{"sha": "e4178cee144b199438c3e51c7d589dfafd2a842c", "filename": "src/librustc/middle/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/250ae7923f9b41d826463d21a8187f1b5f0592ab/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/250ae7923f9b41d826463d21a8187f1b5f0592ab/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=250ae7923f9b41d826463d21a8187f1b5f0592ab", "patch": "@@ -381,8 +381,7 @@ impl<'a> GatherLoanCtxt<'a> {\n                 Some(method) => {\n                     // Treat overloaded autoderefs as if an AutoRef adjustment\n                     // was applied on the base type, as that is always the case.\n-                    let mut mc = self.bccx.mc();\n-                    let cmt = match mc.cat_expr_autoderefd(expr, i) {\n+                    let cmt = match self.bccx.mc().cat_expr_autoderefd(expr, i) {\n                         Ok(v) => v,\n                         Err(()) => self.tcx().sess.span_bug(expr.span, \"Err from mc\")\n                     };\n@@ -431,7 +430,7 @@ impl<'a> GatherLoanCtxt<'a> {\n                     autoref: Some(ref autoref),\n                     autoderefs}) => {\n                 self.guarantee_autoderefs(expr, autoderefs);\n-                let mut mc = self.bccx.mc();\n+                let mc = self.bccx.mc();\n                 let cmt = match mc.cat_expr_autoderefd(expr, autoderefs) {\n                     Ok(v) => v,\n                     Err(()) => self.tcx().sess.span_bug(expr.span, \"Err from mc\")\n@@ -793,7 +792,7 @@ impl<'a> GatherLoanCtxt<'a> {\n          * `gather_pat()`.\n          */\n \n-        let mut mc = self.bccx.mc();\n+        let mc = self.bccx.mc();\n         for arg in decl.inputs.iter() {\n             let arg_ty = ty::node_id_to_type(self.tcx(), arg.pat.id);\n "}, {"sha": "0a040eb4e236f46cefb00194f4fc023763df2c56", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/250ae7923f9b41d826463d21a8187f1b5f0592ab/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/250ae7923f9b41d826463d21a8187f1b5f0592ab/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=250ae7923f9b41d826463d21a8187f1b5f0592ab", "patch": "@@ -910,7 +910,7 @@ impl<'a> mc::Typer for &'a ty::ctxt {\n         *self\n     }\n \n-    fn node_ty(&mut self, id: ast::NodeId) -> mc::McResult<ty::t> {\n+    fn node_ty(&self, id: ast::NodeId) -> mc::McResult<ty::t> {\n         Ok(ty::node_id_to_type(*self, id))\n     }\n \n@@ -922,15 +922,15 @@ impl<'a> mc::Typer for &'a ty::ctxt {\n         &self.adjustments\n     }\n \n-    fn is_method_call(&mut self, id: ast::NodeId) -> bool {\n+    fn is_method_call(&self, id: ast::NodeId) -> bool {\n         self.method_map.borrow().contains_key(&typeck::MethodCall::expr(id))\n     }\n \n-    fn temporary_scope(&mut self, id: ast::NodeId) -> Option<ast::NodeId> {\n+    fn temporary_scope(&self, id: ast::NodeId) -> Option<ast::NodeId> {\n         self.region_maps.temporary_scope(id)\n     }\n \n-    fn upvar_borrow(&mut self, id: ty::UpvarId) -> ty::UpvarBorrow {\n+    fn upvar_borrow(&self, id: ty::UpvarId) -> ty::UpvarBorrow {\n         self.upvar_borrow_map.borrow().get_copy(&id)\n     }\n }"}, {"sha": "1a54d7d937f550e29ef206650ed07da94a435d1e", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 27, "deletions": 31, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/250ae7923f9b41d826463d21a8187f1b5f0592ab/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/250ae7923f9b41d826463d21a8187f1b5f0592ab/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=250ae7923f9b41d826463d21a8187f1b5f0592ab", "patch": "@@ -266,12 +266,12 @@ pub type McResult<T> = Result<T, ()>;\n  */\n pub trait Typer {\n     fn tcx<'a>(&'a self) -> &'a ty::ctxt;\n-    fn node_ty(&mut self, id: ast::NodeId) -> McResult<ty::t>;\n+    fn node_ty(&self, id: ast::NodeId) -> McResult<ty::t>;\n     fn node_method_ty(&self, method_call: typeck::MethodCall) -> Option<ty::t>;\n-    fn is_method_call(&mut self, id: ast::NodeId) -> bool;\n-    fn temporary_scope(&mut self, rvalue_id: ast::NodeId) -> Option<ast::NodeId>;\n-    fn upvar_borrow(&mut self, upvar_id: ty::UpvarId) -> ty::UpvarBorrow;\n     fn adjustments<'a>(&'a self) -> &'a RefCell<NodeMap<ty::AutoAdjustment>>;\n+    fn is_method_call(&self, id: ast::NodeId) -> bool;\n+    fn temporary_scope(&self, rvalue_id: ast::NodeId) -> Option<ast::NodeId>;\n+    fn upvar_borrow(&self, upvar_id: ty::UpvarId) -> ty::UpvarBorrow;\n }\n \n impl MutabilityCategory {\n@@ -353,30 +353,26 @@ impl<TYPER:Typer> MemCategorizationContext<TYPER> {\n         self.typer.tcx()\n     }\n \n-    fn adjustment(&mut self, id: ast::NodeId) -> Option<@ty::AutoAdjustment> {\n-        self.typer.adjustment(id)\n-    }\n-\n-    fn expr_ty(&mut self, expr: &ast::Expr) -> McResult<ty::t> {\n+    fn expr_ty(&self, expr: &ast::Expr) -> McResult<ty::t> {\n         self.typer.node_ty(expr.id)\n     }\n \n-    fn expr_ty_adjusted(&mut self, expr: &ast::Expr) -> McResult<ty::t> {\n+    fn expr_ty_adjusted(&self, expr: &ast::Expr) -> McResult<ty::t> {\n         let unadjusted_ty = if_ok!(self.expr_ty(expr));\n         Ok(ty::adjust_ty(self.tcx(), expr.span, expr.id, unadjusted_ty,\n                          self.typer.adjustments().borrow().find(&expr.id),\n                          |method_call| self.typer.node_method_ty(method_call)))\n     }\n \n-    fn node_ty(&mut self, id: ast::NodeId) -> McResult<ty::t> {\n+    fn node_ty(&self, id: ast::NodeId) -> McResult<ty::t> {\n         self.typer.node_ty(id)\n     }\n \n-    fn pat_ty(&mut self, pat: @ast::Pat) -> McResult<ty::t> {\n+    fn pat_ty(&self, pat: @ast::Pat) -> McResult<ty::t> {\n         self.typer.node_ty(pat.id)\n     }\n \n-    pub fn cat_expr(&mut self, expr: &ast::Expr) -> McResult<cmt> {\n+    pub fn cat_expr(&self, expr: &ast::Expr) -> McResult<cmt> {\n         match self.typer.adjustments().borrow().find(&expr.id) {\n             None => {\n                 // No adjustments.\n@@ -420,7 +416,7 @@ impl<TYPER:Typer> MemCategorizationContext<TYPER> {\n         }\n     }\n \n-    pub fn cat_expr_autoderefd(&mut self, expr: &ast::Expr, autoderefs: uint)\n+    pub fn cat_expr_autoderefd(&self, expr: &ast::Expr, autoderefs: uint)\n                                -> McResult<cmt> {\n         let mut cmt = if_ok!(self.cat_expr_unadjusted(expr));\n         for deref in range(1u, autoderefs + 1) {\n@@ -429,7 +425,7 @@ impl<TYPER:Typer> MemCategorizationContext<TYPER> {\n         return Ok(cmt);\n     }\n \n-    pub fn cat_expr_unadjusted(&mut self, expr: &ast::Expr) -> McResult<cmt> {\n+    pub fn cat_expr_unadjusted(&self, expr: &ast::Expr) -> McResult<cmt> {\n         debug!(\"cat_expr: id={} expr={}\", expr.id, expr.repr(self.tcx()));\n \n         let expr_ty = if_ok!(self.expr_ty(expr));\n@@ -478,7 +474,7 @@ impl<TYPER:Typer> MemCategorizationContext<TYPER> {\n         }\n     }\n \n-    pub fn cat_def(&mut self,\n+    pub fn cat_def(&self,\n                    id: ast::NodeId,\n                    span: Span,\n                    expr_ty: ty::t,\n@@ -593,7 +589,7 @@ impl<TYPER:Typer> MemCategorizationContext<TYPER> {\n         }\n     }\n \n-    fn cat_upvar(&mut self,\n+    fn cat_upvar(&self,\n                  id: ast::NodeId,\n                  span: Span,\n                  var_id: ast::NodeId,\n@@ -643,7 +639,7 @@ impl<TYPER:Typer> MemCategorizationContext<TYPER> {\n         Ok(deref_cmt)\n     }\n \n-    pub fn cat_rvalue_node(&mut self,\n+    pub fn cat_rvalue_node(&self,\n                            id: ast::NodeId,\n                            span: Span,\n                            expr_ty: ty::t)\n@@ -658,7 +654,7 @@ impl<TYPER:Typer> MemCategorizationContext<TYPER> {\n         }\n     }\n \n-    pub fn cat_rvalue(&mut self,\n+    pub fn cat_rvalue(&self,\n                       cmt_id: ast::NodeId,\n                       span: Span,\n                       temp_scope: ty::Region,\n@@ -672,7 +668,7 @@ impl<TYPER:Typer> MemCategorizationContext<TYPER> {\n         }\n     }\n \n-    pub fn cat_field<N:ast_node>(&mut self,\n+    pub fn cat_field<N:ast_node>(&self,\n                                  node: &N,\n                                  base_cmt: cmt,\n                                  f_name: ast::Ident,\n@@ -687,11 +683,11 @@ impl<TYPER:Typer> MemCategorizationContext<TYPER> {\n         }\n     }\n \n-    pub fn cat_deref_obj<N:ast_node>(&mut self, node: &N, base_cmt: cmt) -> cmt {\n+    pub fn cat_deref_obj<N:ast_node>(&self, node: &N, base_cmt: cmt) -> cmt {\n         self.cat_deref_common(node, base_cmt, 0, ty::mk_nil())\n     }\n \n-    fn cat_deref<N:ast_node>(&mut self,\n+    fn cat_deref<N:ast_node>(&self,\n                              node: &N,\n                              base_cmt: cmt,\n                              deref_cnt: uint)\n@@ -723,7 +719,7 @@ impl<TYPER:Typer> MemCategorizationContext<TYPER> {\n         }\n     }\n \n-    fn cat_deref_common<N:ast_node>(&mut self,\n+    fn cat_deref_common<N:ast_node>(&self,\n                                     node: &N,\n                                     base_cmt: cmt,\n                                     deref_cnt: uint,\n@@ -749,7 +745,7 @@ impl<TYPER:Typer> MemCategorizationContext<TYPER> {\n         }\n     }\n \n-    pub fn cat_index<N:ast_node>(&mut self,\n+    pub fn cat_index<N:ast_node>(&self,\n                                  elt: &N,\n                                  base_cmt: cmt,\n                                  derefs: uint)\n@@ -836,7 +832,7 @@ impl<TYPER:Typer> MemCategorizationContext<TYPER> {\n         }\n     }\n \n-    pub fn cat_slice_pattern(&mut self,\n+    pub fn cat_slice_pattern(&self,\n                              vec_cmt: cmt,\n                              slice_pat: @ast::Pat)\n                              -> McResult<(cmt, ast::Mutability, ty::Region)> {\n@@ -883,7 +879,7 @@ impl<TYPER:Typer> MemCategorizationContext<TYPER> {\n         }\n     }\n \n-    pub fn cat_imm_interior<N:ast_node>(&mut self,\n+    pub fn cat_imm_interior<N:ast_node>(&self,\n                                         node: &N,\n                                         base_cmt: cmt,\n                                         interior_ty: ty::t,\n@@ -898,7 +894,7 @@ impl<TYPER:Typer> MemCategorizationContext<TYPER> {\n         }\n     }\n \n-    pub fn cat_downcast<N:ast_node>(&mut self,\n+    pub fn cat_downcast<N:ast_node>(&self,\n                                     node: &N,\n                                     base_cmt: cmt,\n                                     downcast_ty: ty::t)\n@@ -912,12 +908,12 @@ impl<TYPER:Typer> MemCategorizationContext<TYPER> {\n         }\n     }\n \n-    pub fn cat_pattern(&mut self,\n+    pub fn cat_pattern(&self,\n                        cmt: cmt,\n-                       pat: @ast::Pat,\n-                       op: |&mut MemCategorizationContext<TYPER>,\n+                       pat: &ast::Pat,\n+                       op: |&MemCategorizationContext<TYPER>,\n                             cmt,\n-                            @ast::Pat|)\n+                            &ast::Pat|)\n                        -> McResult<()> {\n         // Here, `cmt` is the categorization for the value being\n         // matched and pat is the pattern it is being matched against."}, {"sha": "50ba1421458490c7df166e1b8a426edcffddeb9b", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 26, "deletions": 27, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/250ae7923f9b41d826463d21a8187f1b5f0592ab/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/250ae7923f9b41d826463d21a8187f1b5f0592ab/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=250ae7923f9b41d826463d21a8187f1b5f0592ab", "patch": "@@ -236,7 +236,7 @@ impl<'a> Rcx<'a> {\n     }\n \n     /// Try to resolve the type for the given node.\n-    fn resolve_node_type(&mut self, id: ast::NodeId) -> ty::t {\n+    fn resolve_node_type(&self, id: ast::NodeId) -> ty::t {\n         let t = self.fcx.node_ty(id);\n         self.resolve_type(t)\n     }\n@@ -261,12 +261,12 @@ impl<'a> Rcx<'a> {\n     }\n }\n \n-impl<'a, 'b> mc::Typer for &'a mut Rcx<'b> {\n+impl<'a, 'b> mc::Typer for &'a Rcx<'b> {\n     fn tcx<'a>(&'a self) -> &'a ty::ctxt {\n         self.fcx.tcx()\n     }\n \n-    fn node_ty(&mut self, id: ast::NodeId) -> mc::McResult<ty::t> {\n+    fn node_ty(&self, id: ast::NodeId) -> mc::McResult<ty::t> {\n         let t = self.resolve_node_type(id);\n         if ty::type_is_error(t) {Err(())} else {Ok(t)}\n     }\n@@ -279,15 +279,15 @@ impl<'a, 'b> mc::Typer for &'a mut Rcx<'b> {\n         &self.fcx.inh.adjustments\n     }\n \n-    fn is_method_call(&mut self, id: ast::NodeId) -> bool {\n+    fn is_method_call(&self, id: ast::NodeId) -> bool {\n         self.fcx.inh.method_map.borrow().contains_key(&MethodCall::expr(id))\n     }\n \n-    fn temporary_scope(&mut self, id: ast::NodeId) -> Option<ast::NodeId> {\n+    fn temporary_scope(&self, id: ast::NodeId) -> Option<ast::NodeId> {\n         self.tcx().region_maps.temporary_scope(id)\n     }\n \n-    fn upvar_borrow(&mut self, id: ty::UpvarId) -> ty::UpvarBorrow {\n+    fn upvar_borrow(&self, id: ty::UpvarId) -> ty::UpvarBorrow {\n         self.fcx.inh.upvar_borrow_map.borrow().get_copy(&id)\n     }\n }\n@@ -870,7 +870,7 @@ fn constrain_autoderefs(rcx: &mut Rcx,\n                                 method.ty.repr(rcx.tcx())))\n                 };\n                 {\n-                    let mut mc = mc::MemCategorizationContext { typer: &mut *rcx };\n+                    let mc = mc::MemCategorizationContext { typer: &*rcx };\n                     let self_cmt = ignore_err!(mc.cat_expr_autoderefd(deref_expr, i));\n                     link_region(mc.typer, deref_expr.span, r, m, self_cmt);\n                 }\n@@ -1027,13 +1027,13 @@ fn link_addr_of(rcx: &mut Rcx, expr: &ast::Expr,\n     debug!(\"link_addr_of(base=?)\");\n \n     let cmt = {\n-        let mut mc = mc::MemCategorizationContext { typer: &mut *rcx };\n+        let mc = mc::MemCategorizationContext { typer: &*rcx };\n         ignore_err!(mc.cat_expr(base))\n     };\n     link_region_from_node_type(rcx, expr.span, expr.id, mutability, cmt);\n }\n \n-fn link_local(rcx: &mut Rcx, local: &ast::Local) {\n+fn link_local(rcx: &Rcx, local: &ast::Local) {\n     /*!\n      * Computes the guarantors for any ref bindings in a `let` and\n      * then ensures that the lifetime of the resulting pointer is\n@@ -1045,32 +1045,32 @@ fn link_local(rcx: &mut Rcx, local: &ast::Local) {\n         None => { return; }\n         Some(expr) => expr,\n     };\n-    let mut mc = mc::MemCategorizationContext { typer: rcx };\n+    let mc = mc::MemCategorizationContext { typer: rcx };\n     let discr_cmt = ignore_err!(mc.cat_expr(init_expr));\n-    link_pattern(&mut mc, discr_cmt, local.pat);\n+    link_pattern(mc, discr_cmt, local.pat);\n }\n \n-fn link_match(rcx: &mut Rcx, discr: &ast::Expr, arms: &[ast::Arm]) {\n+fn link_match(rcx: &Rcx, discr: &ast::Expr, arms: &[ast::Arm]) {\n     /*!\n      * Computes the guarantors for any ref bindings in a match and\n      * then ensures that the lifetime of the resulting pointer is\n      * linked to the lifetime of its guarantor (if any).\n      */\n \n     debug!(\"regionck::for_match()\");\n-    let mut mc = mc::MemCategorizationContext { typer: rcx };\n+    let mc = mc::MemCategorizationContext { typer: rcx };\n     let discr_cmt = ignore_err!(mc.cat_expr(discr));\n     debug!(\"discr_cmt={}\", discr_cmt.repr(mc.typer.tcx()));\n     for arm in arms.iter() {\n         for &root_pat in arm.pats.iter() {\n-            link_pattern(&mut mc, discr_cmt, root_pat);\n+            link_pattern(mc, discr_cmt, root_pat);\n         }\n     }\n }\n \n-fn link_pattern(mc: &mut mc::MemCategorizationContext<&mut Rcx>,\n+fn link_pattern(mc: mc::MemCategorizationContext<&Rcx>,\n                 discr_cmt: mc::cmt,\n-                root_pat: @ast::Pat) {\n+                root_pat: &ast::Pat) {\n     /*!\n      * Link lifetimes of any ref bindings in `root_pat` to\n      * the pointers found in the discriminant, if needed.\n@@ -1100,7 +1100,7 @@ fn link_pattern(mc: &mut mc::MemCategorizationContext<&mut Rcx>,\n         });\n }\n \n-fn link_autoref(rcx: &mut Rcx,\n+fn link_autoref(rcx: &Rcx,\n                 expr: &ast::Expr,\n                 autoderefs: uint,\n                 autoref: &ty::AutoRef) {\n@@ -1110,7 +1110,7 @@ fn link_autoref(rcx: &mut Rcx,\n      */\n \n     debug!(\"link_autoref(autoref={:?})\", autoref);\n-    let mut mc = mc::MemCategorizationContext { typer: rcx };\n+    let mc = mc::MemCategorizationContext { typer: rcx };\n     let expr_cmt = ignore_err!(mc.cat_expr_autoderefd(expr, autoderefs));\n     debug!(\"expr_cmt={}\", expr_cmt.repr(mc.typer.tcx()));\n \n@@ -1133,7 +1133,7 @@ fn link_autoref(rcx: &mut Rcx,\n     }\n }\n \n-fn link_by_ref(rcx: &mut Rcx,\n+fn link_by_ref(rcx: &Rcx,\n                expr: &ast::Expr,\n                callee_scope: ast::NodeId) {\n     /*!\n@@ -1145,13 +1145,13 @@ fn link_by_ref(rcx: &mut Rcx,\n     let tcx = rcx.tcx();\n     debug!(\"link_by_ref(expr={}, callee_scope={})\",\n            expr.repr(tcx), callee_scope);\n-    let mut mc = mc::MemCategorizationContext { typer: rcx };\n+    let mc = mc::MemCategorizationContext { typer: rcx };\n     let expr_cmt = ignore_err!(mc.cat_expr(expr));\n     let region_min = ty::ReScope(callee_scope);\n     link_region(mc.typer, expr.span, region_min, ast::MutImmutable, expr_cmt);\n }\n \n-fn link_region_from_node_type(rcx: &mut Rcx,\n+fn link_region_from_node_type(rcx: &Rcx,\n                               span: Span,\n                               id: ast::NodeId,\n                               mutbl: ast::Mutability,\n@@ -1171,7 +1171,7 @@ fn link_region_from_node_type(rcx: &mut Rcx,\n     }\n }\n \n-fn link_region(rcx: &mut Rcx,\n+fn link_region(rcx: &Rcx,\n                span: Span,\n                region_min: ty::Region,\n                mutbl: ast::Mutability,\n@@ -1282,20 +1282,20 @@ fn link_region(rcx: &mut Rcx,\n     }\n }\n \n-fn adjust_borrow_kind_for_assignment_lhs(rcx: &mut Rcx,\n+fn adjust_borrow_kind_for_assignment_lhs(rcx: &Rcx,\n                                          lhs: &ast::Expr) {\n     /*!\n      * Adjusts the inferred borrow_kind as needed to account\n      * for upvars that are assigned to in an assignment\n      * expression.\n      */\n \n-    let mut mc = mc::MemCategorizationContext { typer: rcx };\n+    let mc = mc::MemCategorizationContext { typer: rcx };\n     let cmt = ignore_err!(mc.cat_expr(lhs));\n     adjust_upvar_borrow_kind_for_mut(mc.typer, cmt);\n }\n \n-fn adjust_upvar_borrow_kind_for_mut(rcx: &mut Rcx,\n+fn adjust_upvar_borrow_kind_for_mut(rcx: &Rcx,\n                                     cmt: mc::cmt) {\n     let mut cmt = cmt;\n     loop {\n@@ -1350,8 +1350,7 @@ fn adjust_upvar_borrow_kind_for_mut(rcx: &mut Rcx,\n     }\n }\n \n-fn adjust_upvar_borrow_kind_for_unique(rcx: &mut Rcx,\n-                                       cmt: mc::cmt) {\n+fn adjust_upvar_borrow_kind_for_unique(rcx: &Rcx, cmt: mc::cmt) {\n     let mut cmt = cmt;\n     loop {\n         debug!(\"adjust_upvar_borrow_kind_for_unique(cmt={})\","}]}