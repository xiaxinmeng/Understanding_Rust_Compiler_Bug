{"sha": "f1739b14a1346419a4598339aee32aab07e0d12e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYxNzM5YjE0YTEzNDY0MTlhNDU5ODMzOWFlZTMyYWFiMDdlMGQxMmU=", "commit": {"author": {"name": "Sean McArthur", "email": "sean.monstar@gmail.com", "date": "2014-03-18T17:58:26Z"}, "committer": {"name": "Sean McArthur", "email": "sean.monstar@gmail.com", "date": "2014-03-28T00:41:55Z"}, "message": "serialize: use Result\n\nAll of Decoder and Encoder's methods now return a Result.\n\nEncodable.encode() and Decodable.decode() return a Result as well.\n\nfixes #12292", "tree": {"sha": "1f22c1cc492f9729cd1420654f97f3b511938369", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1f22c1cc492f9729cd1420654f97f3b511938369"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f1739b14a1346419a4598339aee32aab07e0d12e", "comment_count": 9, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f1739b14a1346419a4598339aee32aab07e0d12e", "html_url": "https://github.com/rust-lang/rust/commit/f1739b14a1346419a4598339aee32aab07e0d12e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f1739b14a1346419a4598339aee32aab07e0d12e/comments", "author": {"login": "seanmonstar", "id": 51479, "node_id": "MDQ6VXNlcjUxNDc5", "avatar_url": "https://avatars.githubusercontent.com/u/51479?v=4", "gravatar_id": "", "url": "https://api.github.com/users/seanmonstar", "html_url": "https://github.com/seanmonstar", "followers_url": "https://api.github.com/users/seanmonstar/followers", "following_url": "https://api.github.com/users/seanmonstar/following{/other_user}", "gists_url": "https://api.github.com/users/seanmonstar/gists{/gist_id}", "starred_url": "https://api.github.com/users/seanmonstar/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/seanmonstar/subscriptions", "organizations_url": "https://api.github.com/users/seanmonstar/orgs", "repos_url": "https://api.github.com/users/seanmonstar/repos", "events_url": "https://api.github.com/users/seanmonstar/events{/privacy}", "received_events_url": "https://api.github.com/users/seanmonstar/received_events", "type": "User", "site_admin": false}, "committer": {"login": "seanmonstar", "id": 51479, "node_id": "MDQ6VXNlcjUxNDc5", "avatar_url": "https://avatars.githubusercontent.com/u/51479?v=4", "gravatar_id": "", "url": "https://api.github.com/users/seanmonstar", "html_url": "https://github.com/seanmonstar", "followers_url": "https://api.github.com/users/seanmonstar/followers", "following_url": "https://api.github.com/users/seanmonstar/following{/other_user}", "gists_url": "https://api.github.com/users/seanmonstar/gists{/gist_id}", "starred_url": "https://api.github.com/users/seanmonstar/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/seanmonstar/subscriptions", "organizations_url": "https://api.github.com/users/seanmonstar/orgs", "repos_url": "https://api.github.com/users/seanmonstar/repos", "events_url": "https://api.github.com/users/seanmonstar/events{/privacy}", "received_events_url": "https://api.github.com/users/seanmonstar/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "13dafa09f1a80b8b50f41cab42ac2bfd24dfa6b9", "url": "https://api.github.com/repos/rust-lang/rust/commits/13dafa09f1a80b8b50f41cab42ac2bfd24dfa6b9", "html_url": "https://github.com/rust-lang/rust/commit/13dafa09f1a80b8b50f41cab42ac2bfd24dfa6b9"}], "stats": {"total": 7823, "additions": 6481, "deletions": 1342}, "files": [{"sha": "610764f17ad70f7d1cb3a6526d62c1ba69f6247f", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f1739b14a1346419a4598339aee32aab07e0d12e/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1739b14a1346419a4598339aee32aab07e0d12e/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=f1739b14a1346419a4598339aee32aab07e0d12e", "patch": "@@ -168,6 +168,18 @@ impl Input {\n     }\n }\n \n+// FIXME: remove unwrap_ after snapshot\n+#[cfg(stage0)]\n+fn unwrap_<T>(t: T) -> T {\n+    t\n+}\n+\n+#[cfg(not(stage0))]\n+fn unwrap_<T, E>(r: Result<T, E>) -> T {\n+    r.unwrap()\n+}\n+\n+\n pub fn phase_1_parse_input(sess: &Session, cfg: ast::CrateConfig, input: &Input)\n     -> ast::Crate {\n     let krate = time(sess.time_passes(), \"parsing\", (), |_| {\n@@ -187,7 +199,8 @@ pub fn phase_1_parse_input(sess: &Session, cfg: ast::CrateConfig, input: &Input)\n     if sess.opts.debugging_opts & session::AST_JSON_NOEXPAND != 0 {\n         let mut stdout = io::BufferedWriter::new(io::stdout());\n         let mut json = json::PrettyEncoder::new(&mut stdout);\n-        krate.encode(&mut json);\n+        // unwrapping so IoError isn't ignored\n+        unwrap_(krate.encode(&mut json));\n     }\n \n     if sess.show_span() {\n@@ -262,7 +275,8 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n     if sess.opts.debugging_opts & session::AST_JSON != 0 {\n         let mut stdout = io::BufferedWriter::new(io::stdout());\n         let mut json = json::PrettyEncoder::new(&mut stdout);\n-        krate.encode(&mut json);\n+        // unwrapping so IoError isn't ignored\n+        unwrap_(krate.encode(&mut json));\n     }\n \n     (krate, map)"}, {"sha": "f61e85f3f3f9db407fc1b5e2defa25400da25292", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/f1739b14a1346419a4598339aee32aab07e0d12e/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1739b14a1346419a4598339aee32aab07e0d12e/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=f1739b14a1346419a4598339aee32aab07e0d12e", "patch": "@@ -47,6 +47,17 @@ use syntax::crateid::CrateId;\n \n pub type Cmd = @crate_metadata;\n \n+// FIXME: remove unwrap_ after a snapshot\n+#[cfg(stage0)]\n+fn unwrap_<T>(t: T) -> T {\n+    t\n+}\n+\n+#[cfg(not(stage0))]\n+fn unwrap_<T, E>(r: Result<T, E>) -> T {\n+    r.unwrap()\n+}\n+\n // A function that takes a def_id relative to the crate being searched and\n // returns a def_id relative to the compilation environment, i.e. if we hit a\n // def_id for an item defined in another crate, somebody needs to figure out\n@@ -59,15 +70,15 @@ fn lookup_hash<'a>(d: ebml::Doc<'a>, eq_fn: |&[u8]| -> bool,\n     let table = reader::get_doc(index, tag_index_table);\n     let hash_pos = table.start + (hash % 256 * 4) as uint;\n     let pos = u64_from_be_bytes(d.data, hash_pos, 4) as uint;\n-    let tagged_doc = reader::doc_at(d.data, pos);\n+    let tagged_doc = unwrap_(reader::doc_at(d.data, pos));\n \n     let belt = tag_index_buckets_bucket_elt;\n \n     let mut ret = None;\n     reader::tagged_docs(tagged_doc.doc, belt, |elt| {\n         let pos = u64_from_be_bytes(elt.data, elt.start, 4) as uint;\n         if eq_fn(elt.data.slice(elt.start + 4, elt.end)) {\n-            ret = Some(reader::doc_at(d.data, pos).doc);\n+            ret = Some(unwrap_(reader::doc_at(d.data, pos)).doc);\n             false\n         } else {\n             true\n@@ -853,7 +864,7 @@ pub fn get_item_variances(cdata: Cmd, id: ast::NodeId) -> ty::ItemVariances {\n     let item_doc = lookup_item(id, data);\n     let variance_doc = reader::get_doc(item_doc, tag_item_variances);\n     let mut decoder = reader::Decoder(variance_doc);\n-    Decodable::decode(&mut decoder)\n+    unwrap_(Decodable::decode(&mut decoder))\n }\n \n pub fn get_provided_trait_methods(intr: @IdentInterner, cdata: Cmd,"}, {"sha": "5b47f1f56216bbb0caf01c89a779db6079b0478e", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 69, "deletions": 62, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/f1739b14a1346419a4598339aee32aab07e0d12e/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1739b14a1346419a4598339aee32aab07e0d12e/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=f1739b14a1346419a4598339aee32aab07e0d12e", "patch": "@@ -62,8 +62,15 @@ pub enum InlinedItemRef<'a> {\n     IIForeignRef(&'a ast::ForeignItem)\n }\n \n+// FIXME: remove this Encoder type after a snapshot\n+#[cfg(stage0)]\n+pub type Encoder<'a> = writer::Encoder<'a>;\n+\n+#[cfg(not(stage0))]\n+pub type Encoder<'a> = writer::Encoder<'a, MemWriter>;\n+\n pub type EncodeInlinedItem<'a> = 'a |ecx: &EncodeContext,\n-                                     ebml_w: &mut writer::Encoder,\n+                                     ebml_w: &mut Encoder,\n                                      ii: InlinedItemRef|;\n \n pub struct EncodeParams<'a> {\n@@ -106,15 +113,15 @@ pub struct EncodeContext<'a> {\n     type_abbrevs: abbrev_map,\n }\n \n-fn encode_name(ebml_w: &mut writer::Encoder, name: Name) {\n+fn encode_name(ebml_w: &mut Encoder, name: Name) {\n     ebml_w.wr_tagged_str(tag_paths_data_name, token::get_name(name).get());\n }\n \n-fn encode_impl_type_basename(ebml_w: &mut writer::Encoder, name: Ident) {\n+fn encode_impl_type_basename(ebml_w: &mut Encoder, name: Ident) {\n     ebml_w.wr_tagged_str(tag_item_impl_type_basename, token::get_ident(name).get());\n }\n \n-pub fn encode_def_id(ebml_w: &mut writer::Encoder, id: DefId) {\n+pub fn encode_def_id(ebml_w: &mut Encoder, id: DefId) {\n     ebml_w.wr_tagged_str(tag_def_id, def_to_str(id));\n }\n \n@@ -124,7 +131,7 @@ struct entry<T> {\n     pos: u64\n }\n \n-fn encode_trait_ref(ebml_w: &mut writer::Encoder,\n+fn encode_trait_ref(ebml_w: &mut Encoder,\n                     ecx: &EncodeContext,\n                     trait_ref: &ty::TraitRef,\n                     tag: uint) {\n@@ -140,7 +147,7 @@ fn encode_trait_ref(ebml_w: &mut writer::Encoder,\n     ebml_w.end_tag();\n }\n \n-fn encode_impl_vtables(ebml_w: &mut writer::Encoder,\n+fn encode_impl_vtables(ebml_w: &mut Encoder,\n                        ecx: &EncodeContext,\n                        vtables: &typeck::impl_res) {\n     ebml_w.start_tag(tag_item_impl_vtables);\n@@ -150,7 +157,7 @@ fn encode_impl_vtables(ebml_w: &mut writer::Encoder,\n }\n \n // Item info table encoding\n-fn encode_family(ebml_w: &mut writer::Encoder, c: char) {\n+fn encode_family(ebml_w: &mut Encoder, c: char) {\n     ebml_w.start_tag(tag_items_data_item_family);\n     ebml_w.writer.write(&[c as u8]);\n     ebml_w.end_tag();\n@@ -160,7 +167,7 @@ pub fn def_to_str(did: DefId) -> ~str {\n     format!(\"{}:{}\", did.krate, did.node)\n }\n \n-fn encode_ty_type_param_defs(ebml_w: &mut writer::Encoder,\n+fn encode_ty_type_param_defs(ebml_w: &mut Encoder,\n                              ecx: &EncodeContext,\n                              params: &[ty::TypeParameterDef],\n                              tag: uint) {\n@@ -177,7 +184,7 @@ fn encode_ty_type_param_defs(ebml_w: &mut writer::Encoder,\n     }\n }\n \n-fn encode_region_param_defs(ebml_w: &mut writer::Encoder,\n+fn encode_region_param_defs(ebml_w: &mut Encoder,\n                             params: &[ty::RegionParameterDef]) {\n     for param in params.iter() {\n         ebml_w.start_tag(tag_region_param_def);\n@@ -193,7 +200,7 @@ fn encode_region_param_defs(ebml_w: &mut writer::Encoder,\n     }\n }\n \n-fn encode_item_variances(ebml_w: &mut writer::Encoder,\n+fn encode_item_variances(ebml_w: &mut Encoder,\n                          ecx: &EncodeContext,\n                          id: ast::NodeId) {\n     let v = ty::item_variances(ecx.tcx, ast_util::local_def(id));\n@@ -202,7 +209,7 @@ fn encode_item_variances(ebml_w: &mut writer::Encoder,\n     ebml_w.end_tag();\n }\n \n-fn encode_bounds_and_type(ebml_w: &mut writer::Encoder,\n+fn encode_bounds_and_type(ebml_w: &mut Encoder,\n                           ecx: &EncodeContext,\n                           tpt: &ty::ty_param_bounds_and_ty) {\n     encode_ty_type_param_defs(ebml_w, ecx, tpt.generics.type_param_defs(),\n@@ -211,15 +218,15 @@ fn encode_bounds_and_type(ebml_w: &mut writer::Encoder,\n     encode_type(ecx, ebml_w, tpt.ty);\n }\n \n-fn encode_variant_id(ebml_w: &mut writer::Encoder, vid: DefId) {\n+fn encode_variant_id(ebml_w: &mut Encoder, vid: DefId) {\n     ebml_w.start_tag(tag_items_data_item_variant);\n     let s = def_to_str(vid);\n     ebml_w.writer.write(s.as_bytes());\n     ebml_w.end_tag();\n }\n \n pub fn write_type(ecx: &EncodeContext,\n-                  ebml_w: &mut writer::Encoder,\n+                  ebml_w: &mut Encoder,\n                   typ: ty::t) {\n     let ty_str_ctxt = &tyencode::ctxt {\n         diag: ecx.diag,\n@@ -231,7 +238,7 @@ pub fn write_type(ecx: &EncodeContext,\n }\n \n pub fn write_vstore(ecx: &EncodeContext,\n-                    ebml_w: &mut writer::Encoder,\n+                    ebml_w: &mut Encoder,\n                     vstore: ty::vstore) {\n     let ty_str_ctxt = &tyencode::ctxt {\n         diag: ecx.diag,\n@@ -243,15 +250,15 @@ pub fn write_vstore(ecx: &EncodeContext,\n }\n \n fn encode_type(ecx: &EncodeContext,\n-               ebml_w: &mut writer::Encoder,\n+               ebml_w: &mut Encoder,\n                typ: ty::t) {\n     ebml_w.start_tag(tag_items_data_item_type);\n     write_type(ecx, ebml_w, typ);\n     ebml_w.end_tag();\n }\n \n fn encode_method_fty(ecx: &EncodeContext,\n-                     ebml_w: &mut writer::Encoder,\n+                     ebml_w: &mut Encoder,\n                      typ: &ty::BareFnTy) {\n     ebml_w.start_tag(tag_item_method_fty);\n \n@@ -267,7 +274,7 @@ fn encode_method_fty(ecx: &EncodeContext,\n }\n \n fn encode_symbol(ecx: &EncodeContext,\n-                 ebml_w: &mut writer::Encoder,\n+                 ebml_w: &mut Encoder,\n                  id: NodeId) {\n     ebml_w.start_tag(tag_items_data_item_symbol);\n     match ecx.item_symbols.borrow().find(&id) {\n@@ -284,22 +291,22 @@ fn encode_symbol(ecx: &EncodeContext,\n }\n \n fn encode_disr_val(_: &EncodeContext,\n-                   ebml_w: &mut writer::Encoder,\n+                   ebml_w: &mut Encoder,\n                    disr_val: ty::Disr) {\n     ebml_w.start_tag(tag_disr_val);\n     let s = disr_val.to_str();\n     ebml_w.writer.write(s.as_bytes());\n     ebml_w.end_tag();\n }\n \n-fn encode_parent_item(ebml_w: &mut writer::Encoder, id: DefId) {\n+fn encode_parent_item(ebml_w: &mut Encoder, id: DefId) {\n     ebml_w.start_tag(tag_items_data_parent_item);\n     let s = def_to_str(id);\n     ebml_w.writer.write(s.as_bytes());\n     ebml_w.end_tag();\n }\n \n-fn encode_struct_fields(ebml_w: &mut writer::Encoder,\n+fn encode_struct_fields(ebml_w: &mut Encoder,\n                         def: @StructDef) {\n     for f in def.fields.iter() {\n         match f.node.kind {\n@@ -321,7 +328,7 @@ fn encode_struct_fields(ebml_w: &mut writer::Encoder,\n }\n \n fn encode_enum_variant_info(ecx: &EncodeContext,\n-                            ebml_w: &mut writer::Encoder,\n+                            ebml_w: &mut Encoder,\n                             id: NodeId,\n                             variants: &[P<Variant>],\n                             index: @RefCell<Vec<entry<i64>> >,\n@@ -378,7 +385,7 @@ fn encode_enum_variant_info(ecx: &EncodeContext,\n     }\n }\n \n-fn encode_path<PI: Iterator<PathElem> + Clone>(ebml_w: &mut writer::Encoder,\n+fn encode_path<PI: Iterator<PathElem> + Clone>(ebml_w: &mut Encoder,\n                                                mut path: PI) {\n     ebml_w.start_tag(tag_path);\n     ebml_w.wr_tagged_u32(tag_path_len, path.clone().len() as u32);\n@@ -392,7 +399,7 @@ fn encode_path<PI: Iterator<PathElem> + Clone>(ebml_w: &mut writer::Encoder,\n     ebml_w.end_tag();\n }\n \n-fn encode_reexported_static_method(ebml_w: &mut writer::Encoder,\n+fn encode_reexported_static_method(ebml_w: &mut Encoder,\n                                    exp: &middle::resolve::Export2,\n                                    method_def_id: DefId,\n                                    method_ident: Ident) {\n@@ -409,7 +416,7 @@ fn encode_reexported_static_method(ebml_w: &mut writer::Encoder,\n }\n \n fn encode_reexported_static_base_methods(ecx: &EncodeContext,\n-                                         ebml_w: &mut writer::Encoder,\n+                                         ebml_w: &mut Encoder,\n                                          exp: &middle::resolve::Export2)\n                                          -> bool {\n     match ecx.tcx.inherent_impls.borrow().find(&exp.def_id) {\n@@ -429,7 +436,7 @@ fn encode_reexported_static_base_methods(ecx: &EncodeContext,\n }\n \n fn encode_reexported_static_trait_methods(ecx: &EncodeContext,\n-                                          ebml_w: &mut writer::Encoder,\n+                                          ebml_w: &mut Encoder,\n                                           exp: &middle::resolve::Export2)\n                                           -> bool {\n     match ecx.tcx.trait_methods_cache.borrow().find(&exp.def_id) {\n@@ -447,7 +454,7 @@ fn encode_reexported_static_trait_methods(ecx: &EncodeContext,\n }\n \n fn encode_reexported_static_methods(ecx: &EncodeContext,\n-                                    ebml_w: &mut writer::Encoder,\n+                                    ebml_w: &mut Encoder,\n                                     mod_path: PathElems,\n                                     exp: &middle::resolve::Export2) {\n     match ecx.tcx.map.find(exp.def_id.node) {\n@@ -527,7 +534,7 @@ fn each_auxiliary_node_id(item: @Item, callback: |NodeId| -> bool) -> bool {\n }\n \n fn encode_reexports(ecx: &EncodeContext,\n-                    ebml_w: &mut writer::Encoder,\n+                    ebml_w: &mut Encoder,\n                     id: NodeId,\n                     path: PathElems) {\n     debug!(\"(encoding info for module) encoding reexports for {}\", id);\n@@ -560,7 +567,7 @@ fn encode_reexports(ecx: &EncodeContext,\n }\n \n fn encode_info_for_mod(ecx: &EncodeContext,\n-                       ebml_w: &mut writer::Encoder,\n+                       ebml_w: &mut Encoder,\n                        md: &Mod,\n                        id: NodeId,\n                        path: PathElems,\n@@ -613,7 +620,7 @@ fn encode_info_for_mod(ecx: &EncodeContext,\n     ebml_w.end_tag();\n }\n \n-fn encode_struct_field_family(ebml_w: &mut writer::Encoder,\n+fn encode_struct_field_family(ebml_w: &mut Encoder,\n                               visibility: Visibility) {\n     encode_family(ebml_w, match visibility {\n         Public => 'g',\n@@ -622,7 +629,7 @@ fn encode_struct_field_family(ebml_w: &mut writer::Encoder,\n     });\n }\n \n-fn encode_visibility(ebml_w: &mut writer::Encoder, visibility: Visibility) {\n+fn encode_visibility(ebml_w: &mut Encoder, visibility: Visibility) {\n     ebml_w.start_tag(tag_items_data_item_visibility);\n     let ch = match visibility {\n         Public => 'y',\n@@ -633,7 +640,7 @@ fn encode_visibility(ebml_w: &mut writer::Encoder, visibility: Visibility) {\n     ebml_w.end_tag();\n }\n \n-fn encode_explicit_self(ebml_w: &mut writer::Encoder, explicit_self: ast::ExplicitSelf_) {\n+fn encode_explicit_self(ebml_w: &mut Encoder, explicit_self: ast::ExplicitSelf_) {\n     ebml_w.start_tag(tag_item_trait_method_explicit_self);\n \n     // Encode the base self type.\n@@ -650,7 +657,7 @@ fn encode_explicit_self(ebml_w: &mut writer::Encoder, explicit_self: ast::Explic\n \n     ebml_w.end_tag();\n \n-    fn encode_mutability(ebml_w: &mut writer::Encoder,\n+    fn encode_mutability(ebml_w: &mut Encoder,\n                          m: ast::Mutability) {\n         match m {\n             MutImmutable => { ebml_w.writer.write(&[ 'i' as u8 ]); }\n@@ -659,13 +666,13 @@ fn encode_explicit_self(ebml_w: &mut writer::Encoder, explicit_self: ast::Explic\n     }\n }\n \n-fn encode_method_sort(ebml_w: &mut writer::Encoder, sort: char) {\n+fn encode_method_sort(ebml_w: &mut Encoder, sort: char) {\n     ebml_w.start_tag(tag_item_trait_method_sort);\n     ebml_w.writer.write(&[ sort as u8 ]);\n     ebml_w.end_tag();\n }\n \n-fn encode_provided_source(ebml_w: &mut writer::Encoder,\n+fn encode_provided_source(ebml_w: &mut Encoder,\n                           source_opt: Option<DefId>) {\n     for source in source_opt.iter() {\n         ebml_w.start_tag(tag_item_method_provided_source);\n@@ -677,7 +684,7 @@ fn encode_provided_source(ebml_w: &mut writer::Encoder,\n \n /* Returns an index of items in this class */\n fn encode_info_for_struct(ecx: &EncodeContext,\n-                          ebml_w: &mut writer::Encoder,\n+                          ebml_w: &mut Encoder,\n                           fields: &[StructField],\n                           global_index: @RefCell<Vec<entry<i64>> >)\n                           -> Vec<entry<i64>> {\n@@ -712,7 +719,7 @@ fn encode_info_for_struct(ecx: &EncodeContext,\n }\n \n fn encode_info_for_struct_ctor(ecx: &EncodeContext,\n-                               ebml_w: &mut writer::Encoder,\n+                               ebml_w: &mut Encoder,\n                                name: ast::Ident,\n                                ctor_id: NodeId,\n                                index: @RefCell<Vec<entry<i64>> >,\n@@ -746,7 +753,7 @@ fn encode_info_for_struct_ctor(ecx: &EncodeContext,\n }\n \n fn encode_method_ty_fields(ecx: &EncodeContext,\n-                           ebml_w: &mut writer::Encoder,\n+                           ebml_w: &mut Encoder,\n                            method_ty: &ty::Method) {\n     encode_def_id(ebml_w, method_ty.def_id);\n     encode_name(ebml_w, method_ty.ident.name);\n@@ -767,7 +774,7 @@ fn encode_method_ty_fields(ecx: &EncodeContext,\n }\n \n fn encode_info_for_method(ecx: &EncodeContext,\n-                          ebml_w: &mut writer::Encoder,\n+                          ebml_w: &mut Encoder,\n                           m: &ty::Method,\n                           impl_path: PathElems,\n                           is_default_impl: bool,\n@@ -836,7 +843,7 @@ fn should_inline(attrs: &[Attribute]) -> bool {\n \n // Encodes the inherent implementations of a structure, enumeration, or trait.\n fn encode_inherent_implementations(ecx: &EncodeContext,\n-                                   ebml_w: &mut writer::Encoder,\n+                                   ebml_w: &mut Encoder,\n                                    def_id: DefId) {\n     match ecx.tcx.inherent_impls.borrow().find(&def_id) {\n         None => {}\n@@ -852,7 +859,7 @@ fn encode_inherent_implementations(ecx: &EncodeContext,\n \n // Encodes the implementations of a trait defined in this crate.\n fn encode_extension_implementations(ecx: &EncodeContext,\n-                                    ebml_w: &mut writer::Encoder,\n+                                    ebml_w: &mut Encoder,\n                                     trait_def_id: DefId) {\n     match ecx.tcx.trait_impls.borrow().find(&trait_def_id) {\n         None => {}\n@@ -867,14 +874,14 @@ fn encode_extension_implementations(ecx: &EncodeContext,\n }\n \n fn encode_info_for_item(ecx: &EncodeContext,\n-                        ebml_w: &mut writer::Encoder,\n+                        ebml_w: &mut Encoder,\n                         item: &Item,\n                         index: @RefCell<Vec<entry<i64>> >,\n                         path: PathElems,\n                         vis: ast::Visibility) {\n     let tcx = ecx.tcx;\n \n-    fn add_to_index(item: &Item, ebml_w: &writer::Encoder,\n+    fn add_to_index(item: &Item, ebml_w: &Encoder,\n                      index: @RefCell<Vec<entry<i64>> >) {\n         index.borrow_mut().push(entry {\n             val: item.id as i64,\n@@ -1211,7 +1218,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n }\n \n fn encode_info_for_foreign_item(ecx: &EncodeContext,\n-                                ebml_w: &mut writer::Encoder,\n+                                ebml_w: &mut Encoder,\n                                 nitem: &ForeignItem,\n                                 index: @RefCell<Vec<entry<i64>> >,\n                                 path: PathElems,\n@@ -1253,7 +1260,7 @@ fn encode_info_for_foreign_item(ecx: &EncodeContext,\n fn my_visit_expr(_e: &Expr) { }\n \n fn my_visit_item(i: &Item,\n-                 ebml_w: &mut writer::Encoder,\n+                 ebml_w: &mut Encoder,\n                  ecx_ptr: *int,\n                  index: @RefCell<Vec<entry<i64>> >) {\n     let mut ebml_w = unsafe { ebml_w.unsafe_clone() };\n@@ -1265,7 +1272,7 @@ fn my_visit_item(i: &Item,\n }\n \n fn my_visit_foreign_item(ni: &ForeignItem,\n-                         ebml_w: &mut writer::Encoder,\n+                         ebml_w: &mut Encoder,\n                          ecx_ptr:*int,\n                          index: @RefCell<Vec<entry<i64>> >) {\n     // See above\n@@ -1286,7 +1293,7 @@ fn my_visit_foreign_item(ni: &ForeignItem,\n }\n \n struct EncodeVisitor<'a,'b> {\n-    ebml_w_for_visit_item: &'a mut writer::Encoder<'b>,\n+    ebml_w_for_visit_item: &'a mut Encoder<'b>,\n     ecx_ptr:*int,\n     index: @RefCell<Vec<entry<i64>> >,\n }\n@@ -1313,7 +1320,7 @@ impl<'a,'b> visit::Visitor<()> for EncodeVisitor<'a,'b> {\n }\n \n fn encode_info_for_items(ecx: &EncodeContext,\n-                         ebml_w: &mut writer::Encoder,\n+                         ebml_w: &mut Encoder,\n                          krate: &Crate)\n                          -> Vec<entry<i64>> {\n     let index = @RefCell::new(Vec::new());\n@@ -1369,7 +1376,7 @@ fn create_index<T:Clone + Hash + 'static>(\n }\n \n fn encode_index<T:'static>(\n-                ebml_w: &mut writer::Encoder,\n+                ebml_w: &mut Encoder,\n                 buckets: Vec<@Vec<entry<T>> > ,\n                 write_fn: |&mut MemWriter, &T|) {\n     ebml_w.start_tag(tag_index);\n@@ -1407,7 +1414,7 @@ fn write_i64(writer: &mut MemWriter, &n: &i64) {\n     wr.write_be_u32(n as u32);\n }\n \n-fn encode_meta_item(ebml_w: &mut writer::Encoder, mi: @MetaItem) {\n+fn encode_meta_item(ebml_w: &mut Encoder, mi: @MetaItem) {\n     match mi.node {\n       MetaWord(ref name) => {\n         ebml_w.start_tag(tag_meta_item_word);\n@@ -1444,7 +1451,7 @@ fn encode_meta_item(ebml_w: &mut writer::Encoder, mi: @MetaItem) {\n     }\n }\n \n-fn encode_attributes(ebml_w: &mut writer::Encoder, attrs: &[Attribute]) {\n+fn encode_attributes(ebml_w: &mut Encoder, attrs: &[Attribute]) {\n     ebml_w.start_tag(tag_attributes);\n     for attr in attrs.iter() {\n         ebml_w.start_tag(tag_attribute);\n@@ -1480,7 +1487,7 @@ fn synthesize_crate_attrs(ecx: &EncodeContext,\n     attrs\n }\n \n-fn encode_crate_deps(ebml_w: &mut writer::Encoder, cstore: &cstore::CStore) {\n+fn encode_crate_deps(ebml_w: &mut Encoder, cstore: &cstore::CStore) {\n     fn get_ordered_deps(cstore: &cstore::CStore) -> Vec<decoder::CrateDep> {\n         // Pull the cnums and name,vers,hash out of cstore\n         let mut deps = Vec::new();\n@@ -1518,7 +1525,7 @@ fn encode_crate_deps(ebml_w: &mut writer::Encoder, cstore: &cstore::CStore) {\n     ebml_w.end_tag();\n }\n \n-fn encode_lang_items(ecx: &EncodeContext, ebml_w: &mut writer::Encoder) {\n+fn encode_lang_items(ecx: &EncodeContext, ebml_w: &mut Encoder) {\n     ebml_w.start_tag(tag_lang_items);\n \n     for (i, def_id) in ecx.tcx.lang_items.items() {\n@@ -1548,7 +1555,7 @@ fn encode_lang_items(ecx: &EncodeContext, ebml_w: &mut writer::Encoder) {\n     ebml_w.end_tag();   // tag_lang_items\n }\n \n-fn encode_native_libraries(ecx: &EncodeContext, ebml_w: &mut writer::Encoder) {\n+fn encode_native_libraries(ecx: &EncodeContext, ebml_w: &mut Encoder) {\n     ebml_w.start_tag(tag_native_libraries);\n \n     for &(ref lib, kind) in ecx.tcx.sess.cstore.get_used_libraries()\n@@ -1574,7 +1581,7 @@ fn encode_native_libraries(ecx: &EncodeContext, ebml_w: &mut writer::Encoder) {\n     ebml_w.end_tag();\n }\n \n-fn encode_macro_registrar_fn(ecx: &EncodeContext, ebml_w: &mut writer::Encoder) {\n+fn encode_macro_registrar_fn(ecx: &EncodeContext, ebml_w: &mut Encoder) {\n     match *ecx.tcx.sess.macro_registrar_fn.borrow() {\n         Some(did) => {\n             ebml_w.start_tag(tag_macro_registrar_fn);\n@@ -1587,7 +1594,7 @@ fn encode_macro_registrar_fn(ecx: &EncodeContext, ebml_w: &mut writer::Encoder)\n \n struct MacroDefVisitor<'a, 'b> {\n     ecx: &'a EncodeContext<'a>,\n-    ebml_w: &'a mut writer::Encoder<'b>\n+    ebml_w: &'a mut Encoder<'b>\n }\n \n impl<'a, 'b> Visitor<()> for MacroDefVisitor<'a, 'b> {\n@@ -1608,7 +1615,7 @@ impl<'a, 'b> Visitor<()> for MacroDefVisitor<'a, 'b> {\n \n fn encode_macro_defs(ecx: &EncodeContext,\n                      krate: &Crate,\n-                     ebml_w: &mut writer::Encoder) {\n+                     ebml_w: &mut Encoder) {\n     ebml_w.start_tag(tag_exported_macros);\n     {\n         let mut visitor = MacroDefVisitor {\n@@ -1622,7 +1629,7 @@ fn encode_macro_defs(ecx: &EncodeContext,\n \n struct ImplVisitor<'a,'b> {\n     ecx: &'a EncodeContext<'a>,\n-    ebml_w: &'a mut writer::Encoder<'b>,\n+    ebml_w: &'a mut Encoder<'b>,\n }\n \n impl<'a,'b> Visitor<()> for ImplVisitor<'a,'b> {\n@@ -1660,7 +1667,7 @@ impl<'a,'b> Visitor<()> for ImplVisitor<'a,'b> {\n /// * Implementations of traits not defined in this crate.\n fn encode_impls(ecx: &EncodeContext,\n                 krate: &Crate,\n-                ebml_w: &mut writer::Encoder) {\n+                ebml_w: &mut Encoder) {\n     ebml_w.start_tag(tag_impls);\n \n     {\n@@ -1676,7 +1683,7 @@ fn encode_impls(ecx: &EncodeContext,\n \n fn encode_misc_info(ecx: &EncodeContext,\n                     krate: &Crate,\n-                    ebml_w: &mut writer::Encoder) {\n+                    ebml_w: &mut Encoder) {\n     ebml_w.start_tag(tag_misc_info);\n     ebml_w.start_tag(tag_misc_info_crate_items);\n     for &item in krate.module.items.iter() {\n@@ -1699,7 +1706,7 @@ fn encode_misc_info(ecx: &EncodeContext,\n     ebml_w.end_tag();\n }\n \n-fn encode_crate_dep(ebml_w: &mut writer::Encoder,\n+fn encode_crate_dep(ebml_w: &mut Encoder,\n                     dep: decoder::CrateDep) {\n     ebml_w.start_tag(tag_crate_dep);\n     ebml_w.start_tag(tag_crate_dep_crateid);\n@@ -1711,13 +1718,13 @@ fn encode_crate_dep(ebml_w: &mut writer::Encoder,\n     ebml_w.end_tag();\n }\n \n-fn encode_hash(ebml_w: &mut writer::Encoder, hash: &Svh) {\n+fn encode_hash(ebml_w: &mut Encoder, hash: &Svh) {\n     ebml_w.start_tag(tag_crate_hash);\n     ebml_w.writer.write(hash.as_str().as_bytes());\n     ebml_w.end_tag();\n }\n \n-fn encode_crate_id(ebml_w: &mut writer::Encoder, crate_id: &CrateId) {\n+fn encode_crate_id(ebml_w: &mut Encoder, crate_id: &CrateId) {\n     ebml_w.start_tag(tag_crate_crateid);\n     ebml_w.writer.write(crate_id.to_str().as_bytes());\n     ebml_w.end_tag();"}, {"sha": "fd72a5f838a6e9463ca01e9fe415bc9c52f4861c", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 231, "deletions": 169, "changes": 400, "blob_url": "https://github.com/rust-lang/rust/blob/f1739b14a1346419a4598339aee32aab07e0d12e/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1739b14a1346419a4598339aee32aab07e0d12e/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=f1739b14a1346419a4598339aee32aab07e0d12e", "patch": "@@ -9,6 +9,8 @@\n // except according to those terms.\n \n #[allow(non_camel_case_types)];\n+// FIXME: remove this after snapshot, and Results are handled\n+#[allow(unused_must_use)];\n \n use c = metadata::common;\n use cstore = metadata::cstore;\n@@ -36,6 +38,9 @@ use std::libc;\n use std::cast;\n use std::cell::RefCell;\n use std::io::Seek;\n+// FIXME: remove this attr after snapshot\n+#[cfg(not(stage0))]\n+use std::io::MemWriter;\n use std::rc::Rc;\n \n use serialize::ebml::reader;\n@@ -76,11 +81,41 @@ trait tr_intern {\n     fn tr_intern(&self, xcx: &ExtendedDecodeContext) -> ast::DefId;\n }\n \n+// FIXME: remove this Encoder type after snapshot\n+#[cfg(stage0)]\n+pub type Encoder<'a> = writer::Encoder<'a>;\n+\n+#[cfg(not(stage0))]\n+pub type Encoder<'a> = writer::Encoder<'a, MemWriter>;\n+\n+// FIXME: remove unwrap_ and wrap_ after snapshot\n+#[cfg(stage0)]\n+fn unwrap_<T>(t: T) -> T {\n+    t\n+}\n+\n+#[cfg(not(stage0))]\n+fn unwrap_<T, E>(r: Result<T, E>) -> T {\n+    r.unwrap()\n+}\n+\n+#[cfg(stage0)]\n+fn wrap_<T>(t: T) -> T {\n+    t\n+}\n+\n+#[cfg(not(stage0))]\n+fn wrap_<T, E>(t: T) -> Result<T, E> {\n+    Ok(t)\n+}\n+\n+\n+\n // ______________________________________________________________________\n // Top-level methods.\n \n pub fn encode_inlined_item(ecx: &e::EncodeContext,\n-                           ebml_w: &mut writer::Encoder,\n+                           ebml_w: &mut Encoder,\n                            ii: e::InlinedItemRef,\n                            maps: &Maps) {\n     let id = match ii {\n@@ -106,7 +141,7 @@ pub fn encode_inlined_item(ecx: &e::EncodeContext,\n            ebml_w.writer.tell());\n }\n \n-pub fn encode_exported_macro(ebml_w: &mut writer::Encoder, i: &ast::Item) {\n+pub fn encode_exported_macro(ebml_w: &mut Encoder, i: &ast::Item) {\n     match i.node {\n         ast::ItemMac(..) => encode_ast(ebml_w, ast::IIItem(@i.clone())),\n         _ => fail!(\"expected a macro\")\n@@ -136,7 +171,7 @@ pub fn decode_inlined_item(cdata: @cstore::crate_metadata,\n             path_as_str.as_ref().map(|x| x.as_slice())\n         });\n         let mut ast_dsr = reader::Decoder(ast_doc);\n-        let from_id_range = Decodable::decode(&mut ast_dsr);\n+        let from_id_range = unwrap_(Decodable::decode(&mut ast_dsr));\n         let to_id_range = reserve_id_range(&dcx.tcx.sess, from_id_range);\n         let xcx = &ExtendedDecodeContext {\n             dcx: dcx,\n@@ -272,27 +307,50 @@ trait def_id_encoder_helpers {\n     fn emit_def_id(&mut self, did: ast::DefId);\n }\n \n+#[cfg(stage0)]\n impl<S:serialize::Encoder> def_id_encoder_helpers for S {\n     fn emit_def_id(&mut self, did: ast::DefId) {\n         did.encode(self)\n     }\n }\n \n+#[cfg(not(stage0))]\n+impl<S:serialize::Encoder<E>, E> def_id_encoder_helpers for S {\n+    fn emit_def_id(&mut self, did: ast::DefId) {\n+        unwrap_(did.encode(self))\n+    }\n+}\n+\n trait def_id_decoder_helpers {\n     fn read_def_id(&mut self, xcx: &ExtendedDecodeContext) -> ast::DefId;\n     fn read_def_id_noxcx(&mut self,\n                          cdata: @cstore::crate_metadata) -> ast::DefId;\n }\n \n+#[cfg(stage0)]\n impl<D:serialize::Decoder> def_id_decoder_helpers for D {\n     fn read_def_id(&mut self, xcx: &ExtendedDecodeContext) -> ast::DefId {\n-        let did: ast::DefId = Decodable::decode(self);\n+        let did: ast::DefId = unwrap_(Decodable::decode(self));\n         did.tr(xcx)\n     }\n \n     fn read_def_id_noxcx(&mut self,\n                          cdata: @cstore::crate_metadata) -> ast::DefId {\n-        let did: ast::DefId = Decodable::decode(self);\n+        let did: ast::DefId = unwrap_(Decodable::decode(self));\n+        decoder::translate_def_id(cdata, did)\n+    }\n+}\n+\n+#[cfg(not(stage0))]\n+impl<D:serialize::Decoder<E>, E> def_id_decoder_helpers for D {\n+    fn read_def_id(&mut self, xcx: &ExtendedDecodeContext) -> ast::DefId {\n+        let did: ast::DefId = unwrap_(Decodable::decode(self));\n+        did.tr(xcx)\n+    }\n+\n+    fn read_def_id_noxcx(&mut self,\n+                         cdata: @cstore::crate_metadata) -> ast::DefId {\n+        let did: ast::DefId = unwrap_(Decodable::decode(self));\n         decoder::translate_def_id(cdata, did)\n     }\n }\n@@ -312,7 +370,7 @@ impl<D:serialize::Decoder> def_id_decoder_helpers for D {\n // We also have to adjust the spans: for now we just insert a dummy span,\n // but eventually we should add entries to the local codemap as required.\n \n-fn encode_ast(ebml_w: &mut writer::Encoder, item: ast::InlinedItem) {\n+fn encode_ast(ebml_w: &mut Encoder, item: ast::InlinedItem) {\n     ebml_w.start_tag(c::tag_tree as uint);\n     item.encode(ebml_w);\n     ebml_w.end_tag();\n@@ -372,7 +430,7 @@ fn simplify_ast(ii: e::InlinedItemRef) -> ast::InlinedItem {\n fn decode_ast(par_doc: ebml::Doc) -> ast::InlinedItem {\n     let chi_doc = par_doc.get(c::tag_tree as uint);\n     let mut d = reader::Decoder(chi_doc);\n-    Decodable::decode(&mut d)\n+    unwrap_(Decodable::decode(&mut d))\n }\n \n struct AstRenumberer<'a> {\n@@ -418,7 +476,7 @@ fn renumber_and_map_ast(xcx: &ExtendedDecodeContext,\n \n fn decode_def(xcx: &ExtendedDecodeContext, doc: ebml::Doc) -> ast::Def {\n     let mut dsr = reader::Decoder(doc);\n-    let def: ast::Def = Decodable::decode(&mut dsr);\n+    let def: ast::Def = unwrap_(Decodable::decode(&mut dsr));\n     def.tr(xcx)\n }\n \n@@ -525,8 +583,8 @@ impl tr for ty::BoundRegion {\n // ______________________________________________________________________\n // Encoding and decoding of freevar information\n \n-fn encode_freevar_entry(ebml_w: &mut writer::Encoder, fv: @freevar_entry) {\n-    (*fv).encode(ebml_w)\n+fn encode_freevar_entry(ebml_w: &mut Encoder, fv: @freevar_entry) {\n+    unwrap_((*fv).encode(ebml_w))\n }\n \n trait ebml_decoder_helper {\n@@ -537,7 +595,7 @@ trait ebml_decoder_helper {\n impl<'a> ebml_decoder_helper for reader::Decoder<'a> {\n     fn read_freevar_entry(&mut self, xcx: &ExtendedDecodeContext)\n                           -> freevar_entry {\n-        let fv: freevar_entry = Decodable::decode(self);\n+        let fv: freevar_entry = unwrap_(Decodable::decode(self));\n         fv.tr(xcx)\n     }\n }\n@@ -562,7 +620,7 @@ trait capture_var_helper {\n impl<'a> capture_var_helper for reader::Decoder<'a> {\n     fn read_capture_var(&mut self, xcx: &ExtendedDecodeContext)\n                         -> moves::CaptureVar {\n-        let cvar: moves::CaptureVar = Decodable::decode(self);\n+        let cvar: moves::CaptureVar = unwrap_(Decodable::decode(self));\n         cvar.tr(xcx)\n     }\n }\n@@ -585,45 +643,45 @@ trait read_method_callee_helper {\n }\n \n fn encode_method_callee(ecx: &e::EncodeContext,\n-                        ebml_w: &mut writer::Encoder,\n+                        ebml_w: &mut Encoder,\n                         autoderef: u32,\n                         method: &MethodCallee) {\n-    ebml_w.emit_struct(\"MethodCallee\", 4, |ebml_w| {\n+    unwrap_(ebml_w.emit_struct(\"MethodCallee\", 4, |ebml_w| {\n         ebml_w.emit_struct_field(\"autoderef\", 0u, |ebml_w| {\n-            autoderef.encode(ebml_w);\n+            autoderef.encode(ebml_w)\n         });\n         ebml_w.emit_struct_field(\"origin\", 1u, |ebml_w| {\n-            method.origin.encode(ebml_w);\n+            method.origin.encode(ebml_w)\n         });\n         ebml_w.emit_struct_field(\"ty\", 2u, |ebml_w| {\n-            ebml_w.emit_ty(ecx, method.ty);\n+            wrap_(ebml_w.emit_ty(ecx, method.ty))\n         });\n         ebml_w.emit_struct_field(\"substs\", 3u, |ebml_w| {\n-            ebml_w.emit_substs(ecx, &method.substs);\n-        });\n-    })\n+            wrap_(ebml_w.emit_substs(ecx, &method.substs))\n+        })\n+    }));\n }\n \n impl<'a> read_method_callee_helper for reader::Decoder<'a> {\n     fn read_method_callee(&mut self, xcx: &ExtendedDecodeContext) -> (u32, MethodCallee) {\n-        self.read_struct(\"MethodCallee\", 4, |this| {\n-            let autoderef = this.read_struct_field(\"autoderef\", 0, |this| {\n+        unwrap_(self.read_struct(\"MethodCallee\", 4, |this| {\n+            let autoderef = unwrap_(this.read_struct_field(\"autoderef\", 0, |this| {\n                 Decodable::decode(this)\n-            });\n-            (autoderef, MethodCallee {\n-                origin: this.read_struct_field(\"origin\", 1, |this| {\n+            }));\n+            wrap_((autoderef, MethodCallee {\n+                origin: unwrap_(this.read_struct_field(\"origin\", 1, |this| {\n                     let method_origin: MethodOrigin =\n-                        Decodable::decode(this);\n-                    method_origin.tr(xcx)\n-                }),\n-                ty: this.read_struct_field(\"ty\", 2, |this| {\n-                    this.read_ty(xcx)\n-                }),\n-                substs: this.read_struct_field(\"substs\", 3, |this| {\n-                    this.read_substs(xcx)\n-                })\n-            })\n-        })\n+                        unwrap_(Decodable::decode(this));\n+                    wrap_(method_origin.tr(xcx))\n+                })),\n+                ty: unwrap_(this.read_struct_field(\"ty\", 2, |this| {\n+                    wrap_(this.read_ty(xcx))\n+                })),\n+                substs: unwrap_(this.read_struct_field(\"substs\", 3, |this| {\n+                    wrap_(this.read_substs(xcx))\n+                }))\n+            }))\n+        }))\n     }\n }\n \n@@ -655,70 +713,70 @@ impl tr for MethodOrigin {\n // Encoding and decoding vtable_res\n \n fn encode_vtable_res_with_key(ecx: &e::EncodeContext,\n-                              ebml_w: &mut writer::Encoder,\n+                              ebml_w: &mut Encoder,\n                               autoderef: u32,\n                               dr: typeck::vtable_res) {\n-    ebml_w.emit_struct(\"VtableWithKey\", 2, |ebml_w| {\n+    unwrap_(ebml_w.emit_struct(\"VtableWithKey\", 2, |ebml_w| {\n         ebml_w.emit_struct_field(\"autoderef\", 0u, |ebml_w| {\n-            autoderef.encode(ebml_w);\n+            autoderef.encode(ebml_w)\n         });\n         ebml_w.emit_struct_field(\"vtable_res\", 1u, |ebml_w| {\n-            encode_vtable_res(ecx, ebml_w, dr);\n-        });\n-    })\n+            wrap_(encode_vtable_res(ecx, ebml_w, dr))\n+        })\n+    }))\n }\n \n pub fn encode_vtable_res(ecx: &e::EncodeContext,\n-                     ebml_w: &mut writer::Encoder,\n+                     ebml_w: &mut Encoder,\n                      dr: typeck::vtable_res) {\n     // can't autogenerate this code because automatic code of\n     // ty::t doesn't work, and there is no way (atm) to have\n     // hand-written encoding routines combine with auto-generated\n     // ones.  perhaps we should fix this.\n-    ebml_w.emit_from_vec(dr.as_slice(), |ebml_w, param_tables| {\n-        encode_vtable_param_res(ecx, ebml_w, *param_tables);\n-    })\n+    unwrap_(ebml_w.emit_from_vec(dr.as_slice(), |ebml_w, param_tables| {\n+        wrap_(encode_vtable_param_res(ecx, ebml_w, *param_tables))\n+    }))\n }\n \n pub fn encode_vtable_param_res(ecx: &e::EncodeContext,\n-                     ebml_w: &mut writer::Encoder,\n+                     ebml_w: &mut Encoder,\n                      param_tables: typeck::vtable_param_res) {\n-    ebml_w.emit_from_vec(param_tables.as_slice(), |ebml_w, vtable_origin| {\n-        encode_vtable_origin(ecx, ebml_w, vtable_origin)\n-    })\n+    unwrap_(ebml_w.emit_from_vec(param_tables.as_slice(), |ebml_w, vtable_origin| {\n+        wrap_(encode_vtable_origin(ecx, ebml_w, vtable_origin))\n+    }))\n }\n \n \n pub fn encode_vtable_origin(ecx: &e::EncodeContext,\n-                        ebml_w: &mut writer::Encoder,\n+                        ebml_w: &mut Encoder,\n                         vtable_origin: &typeck::vtable_origin) {\n-    ebml_w.emit_enum(\"vtable_origin\", |ebml_w| {\n+    unwrap_(ebml_w.emit_enum(\"vtable_origin\", |ebml_w| {\n         match *vtable_origin {\n           typeck::vtable_static(def_id, ref tys, vtable_res) => {\n             ebml_w.emit_enum_variant(\"vtable_static\", 0u, 3u, |ebml_w| {\n                 ebml_w.emit_enum_variant_arg(0u, |ebml_w| {\n-                    ebml_w.emit_def_id(def_id)\n+                    wrap_(ebml_w.emit_def_id(def_id))\n                 });\n                 ebml_w.emit_enum_variant_arg(1u, |ebml_w| {\n-                    ebml_w.emit_tys(ecx, tys.as_slice());\n+                    wrap_(ebml_w.emit_tys(ecx, tys.as_slice()))\n                 });\n                 ebml_w.emit_enum_variant_arg(2u, |ebml_w| {\n-                    encode_vtable_res(ecx, ebml_w, vtable_res);\n+                    wrap_(encode_vtable_res(ecx, ebml_w, vtable_res))\n                 })\n             })\n           }\n           typeck::vtable_param(pn, bn) => {\n             ebml_w.emit_enum_variant(\"vtable_param\", 1u, 2u, |ebml_w| {\n                 ebml_w.emit_enum_variant_arg(0u, |ebml_w| {\n-                    pn.encode(ebml_w);\n+                    pn.encode(ebml_w)\n                 });\n                 ebml_w.emit_enum_variant_arg(1u, |ebml_w| {\n-                    ebml_w.emit_uint(bn);\n+                    ebml_w.emit_uint(bn)\n                 })\n             })\n           }\n         }\n-    })\n+    }))\n }\n \n pub trait vtable_decoder_helpers {\n@@ -742,71 +800,71 @@ impl<'a> vtable_decoder_helpers for reader::Decoder<'a> {\n                                 tcx: &ty::ctxt,\n                                 cdata: @cstore::crate_metadata)\n                                 -> (u32, typeck::vtable_res) {\n-        self.read_struct(\"VtableWithKey\", 2, |this| {\n-            let autoderef = this.read_struct_field(\"autoderef\", 0, |this| {\n+        unwrap_(self.read_struct(\"VtableWithKey\", 2, |this| {\n+            let autoderef = unwrap_(this.read_struct_field(\"autoderef\", 0, |this| {\n                 Decodable::decode(this)\n-            });\n-            (autoderef, this.read_struct_field(\"vtable_res\", 1, |this| {\n-                this.read_vtable_res(tcx, cdata)\n-            }))\n-        })\n+            }));\n+            wrap_((autoderef, unwrap_(this.read_struct_field(\"vtable_res\", 1, |this| {\n+                wrap_(this.read_vtable_res(tcx, cdata))\n+            }))))\n+        }))\n     }\n \n     fn read_vtable_res(&mut self,\n                        tcx: &ty::ctxt, cdata: @cstore::crate_metadata)\n                       -> typeck::vtable_res {\n-        @self.read_to_vec(|this|\n-                          this.read_vtable_param_res(tcx, cdata))\n+        @unwrap_(self.read_to_vec(|this|\n+                          wrap_(this.read_vtable_param_res(tcx, cdata))))\n              .move_iter()\n              .collect()\n     }\n \n     fn read_vtable_param_res(&mut self,\n                              tcx: &ty::ctxt, cdata: @cstore::crate_metadata)\n                       -> typeck::vtable_param_res {\n-        @self.read_to_vec(|this|\n-                          this.read_vtable_origin(tcx, cdata))\n+        @unwrap_(self.read_to_vec(|this|\n+                          wrap_(this.read_vtable_origin(tcx, cdata))))\n              .move_iter()\n              .collect()\n     }\n \n     fn read_vtable_origin(&mut self,\n                           tcx: &ty::ctxt, cdata: @cstore::crate_metadata)\n         -> typeck::vtable_origin {\n-        self.read_enum(\"vtable_origin\", |this| {\n+        unwrap_(self.read_enum(\"vtable_origin\", |this| {\n             this.read_enum_variant([\"vtable_static\",\n                                     \"vtable_param\",\n                                     \"vtable_self\"],\n                                    |this, i| {\n-                match i {\n+                wrap_(match i {\n                   0 => {\n                     typeck::vtable_static(\n-                        this.read_enum_variant_arg(0u, |this| {\n-                            this.read_def_id_noxcx(cdata)\n-                        }),\n-                        this.read_enum_variant_arg(1u, |this| {\n-                            this.read_tys_noxcx(tcx, cdata)\n-                        }),\n-                        this.read_enum_variant_arg(2u, |this| {\n-                            this.read_vtable_res(tcx, cdata)\n-                        })\n+                        unwrap_(this.read_enum_variant_arg(0u, |this| {\n+                            wrap_(this.read_def_id_noxcx(cdata))\n+                        })),\n+                        unwrap_(this.read_enum_variant_arg(1u, |this| {\n+                            wrap_(this.read_tys_noxcx(tcx, cdata))\n+                        })),\n+                        unwrap_(this.read_enum_variant_arg(2u, |this| {\n+                            wrap_(this.read_vtable_res(tcx, cdata))\n+                        }))\n                     )\n                   }\n                   1 => {\n                     typeck::vtable_param(\n-                        this.read_enum_variant_arg(0u, |this| {\n+                        unwrap_(this.read_enum_variant_arg(0u, |this| {\n                             Decodable::decode(this)\n-                        }),\n-                        this.read_enum_variant_arg(1u, |this| {\n+                        })),\n+                        unwrap_(this.read_enum_variant_arg(1u, |this| {\n                             this.read_uint()\n-                        })\n+                        }))\n                     )\n                   }\n                   // hard to avoid - user input\n                   _ => fail!(\"bad enum variant\")\n-                }\n+                })\n             })\n-        })\n+        }))\n     }\n }\n \n@@ -842,27 +900,27 @@ trait ebml_writer_helpers {\n     fn emit_auto_adjustment(&mut self, ecx: &e::EncodeContext, adj: &ty::AutoAdjustment);\n }\n \n-impl<'a> ebml_writer_helpers for writer::Encoder<'a> {\n+impl<'a> ebml_writer_helpers for Encoder<'a> {\n     fn emit_ty(&mut self, ecx: &e::EncodeContext, ty: ty::t) {\n-        self.emit_opaque(|this| e::write_type(ecx, this, ty))\n+        self.emit_opaque(|this| wrap_(e::write_type(ecx, this, ty)));\n     }\n \n     fn emit_vstore(&mut self, ecx: &e::EncodeContext, vstore: ty::vstore) {\n-        self.emit_opaque(|this| e::write_vstore(ecx, this, vstore))\n+        self.emit_opaque(|this| wrap_(e::write_vstore(ecx, this, vstore)));\n     }\n \n     fn emit_tys(&mut self, ecx: &e::EncodeContext, tys: &[ty::t]) {\n-        self.emit_from_vec(tys, |this, ty| this.emit_ty(ecx, *ty))\n+        self.emit_from_vec(tys, |this, ty| wrap_(this.emit_ty(ecx, *ty)));\n     }\n \n     fn emit_type_param_def(&mut self,\n                            ecx: &e::EncodeContext,\n                            type_param_def: &ty::TypeParameterDef) {\n         self.emit_opaque(|this| {\n-            tyencode::enc_type_param_def(this.writer,\n+            wrap_(tyencode::enc_type_param_def(this.writer,\n                                          &ecx.ty_str_ctxt(),\n-                                         type_param_def)\n-        })\n+                                         type_param_def))\n+        });\n     }\n \n     fn emit_tpbt(&mut self,\n@@ -874,22 +932,24 @@ impl<'a> ebml_writer_helpers for writer::Encoder<'a> {\n                     this.emit_struct_field(\"type_param_defs\", 0, |this| {\n                         this.emit_from_vec(tpbt.generics.type_param_defs(),\n                                            |this, type_param_def| {\n-                            this.emit_type_param_def(ecx, type_param_def);\n+                            wrap_(this.emit_type_param_def(ecx, type_param_def))\n                         })\n                     });\n                     this.emit_struct_field(\"region_param_defs\", 1, |this| {\n-                        tpbt.generics.region_param_defs().encode(this);\n+                        tpbt.generics.region_param_defs().encode(this)\n                     })\n                 })\n             });\n             this.emit_struct_field(\"ty\", 1, |this| {\n-                this.emit_ty(ecx, tpbt.ty);\n+                wrap_(this.emit_ty(ecx, tpbt.ty))\n             })\n-        })\n+        });\n     }\n \n     fn emit_substs(&mut self, ecx: &e::EncodeContext, substs: &ty::substs) {\n-        self.emit_opaque(|this| tyencode::enc_substs(this.writer, &ecx.ty_str_ctxt(), substs))\n+        self.emit_opaque(|this| wrap_(tyencode::enc_substs(this.writer,\n+                                                           &ecx.ty_str_ctxt(),\n+                                                           substs)));\n     }\n \n     fn emit_auto_adjustment(&mut self, ecx: &e::EncodeContext, adj: &ty::AutoAdjustment) {\n@@ -898,14 +958,14 @@ impl<'a> ebml_writer_helpers for writer::Encoder<'a> {\n                 ty::AutoAddEnv(region, sigil) => {\n                     this.emit_enum_variant(\"AutoAddEnv\", 0, 2, |this| {\n                         this.emit_enum_variant_arg(0, |this| region.encode(this));\n-                        this.emit_enum_variant_arg(1, |this| sigil.encode(this));\n-                    });\n+                        this.emit_enum_variant_arg(1, |this| sigil.encode(this))\n+                    })\n                 }\n \n                 ty::AutoDerefRef(ref auto_deref_ref) => {\n                     this.emit_enum_variant(\"AutoDerefRef\", 1, 1, |this| {\n-                        this.emit_enum_variant_arg(0, |this| auto_deref_ref.encode(this));\n-                    });\n+                        this.emit_enum_variant_arg(0, |this| auto_deref_ref.encode(this))\n+                    })\n                 }\n \n                 ty::AutoObject(sigil, region, m, b, def_id, ref substs) => {\n@@ -915,8 +975,8 @@ impl<'a> ebml_writer_helpers for writer::Encoder<'a> {\n                         this.emit_enum_variant_arg(2, |this| m.encode(this));\n                         this.emit_enum_variant_arg(3, |this| b.encode(this));\n                         this.emit_enum_variant_arg(4, |this| def_id.encode(this));\n-                        this.emit_enum_variant_arg(5, |this| this.emit_substs(ecx, substs));\n-                    });\n+                        this.emit_enum_variant_arg(5, |this| wrap_(this.emit_substs(ecx, substs)))\n+                    })\n                 }\n             }\n         });\n@@ -928,23 +988,23 @@ trait write_tag_and_id {\n     fn id(&mut self, id: ast::NodeId);\n }\n \n-impl<'a> write_tag_and_id for writer::Encoder<'a> {\n+impl<'a> write_tag_and_id for Encoder<'a> {\n     fn tag(&mut self,\n            tag_id: c::astencode_tag,\n-           f: |&mut writer::Encoder<'a>|) {\n+           f: |&mut Encoder<'a>|) {\n         self.start_tag(tag_id as uint);\n         f(self);\n         self.end_tag();\n     }\n \n     fn id(&mut self, id: ast::NodeId) {\n-        self.wr_tagged_u64(c::tag_table_id as uint, id as u64)\n+        self.wr_tagged_u64(c::tag_table_id as uint, id as u64);\n     }\n }\n \n struct SideTableEncodingIdVisitor<'a,'b> {\n     ecx_ptr: *libc::c_void,\n-    new_ebml_w: &'a mut writer::Encoder<'b>,\n+    new_ebml_w: &'a mut Encoder<'b>,\n     maps: &'a Maps,\n }\n \n@@ -969,7 +1029,7 @@ impl<'a,'b> ast_util::IdVisitingOperation for\n \n fn encode_side_tables_for_ii(ecx: &e::EncodeContext,\n                              maps: &Maps,\n-                             ebml_w: &mut writer::Encoder,\n+                             ebml_w: &mut Encoder,\n                              ii: &ast::InlinedItem) {\n     ebml_w.start_tag(c::tag_table as uint);\n     let mut new_ebml_w = unsafe {\n@@ -991,7 +1051,7 @@ fn encode_side_tables_for_ii(ecx: &e::EncodeContext,\n \n fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n                              maps: &Maps,\n-                             ebml_w: &mut writer::Encoder,\n+                             ebml_w: &mut Encoder,\n                              id: ast::NodeId) {\n     let tcx = ecx.tcx;\n \n@@ -1000,7 +1060,7 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n     for def in tcx.def_map.borrow().find(&id).iter() {\n         ebml_w.tag(c::tag_table_def, |ebml_w| {\n             ebml_w.id(id);\n-            ebml_w.tag(c::tag_table_val, |ebml_w| (*def).encode(ebml_w));\n+            ebml_w.tag(c::tag_table_val, |ebml_w| unwrap_((*def).encode(ebml_w)));\n         })\n     }\n \n@@ -1027,8 +1087,8 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n             ebml_w.id(id);\n             ebml_w.tag(c::tag_table_val, |ebml_w| {\n                 ebml_w.emit_from_vec(fv.as_slice(), |ebml_w, fv_entry| {\n-                    encode_freevar_entry(ebml_w, *fv_entry)\n-                })\n+                    wrap_(encode_freevar_entry(ebml_w, *fv_entry))\n+                });\n             })\n         })\n     }\n@@ -1112,8 +1172,8 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n             ebml_w.id(id);\n             ebml_w.tag(c::tag_table_val, |ebml_w| {\n                 ebml_w.emit_from_vec(cap_vars.as_slice(), |ebml_w, cap_var| {\n-                    cap_var.encode(ebml_w);\n-                })\n+                    cap_var.encode(ebml_w)\n+                });\n             })\n         })\n     }\n@@ -1158,20 +1218,20 @@ trait ebml_decoder_decoder_helpers {\n impl<'a> ebml_decoder_decoder_helpers for reader::Decoder<'a> {\n     fn read_ty_noxcx(&mut self,\n                      tcx: &ty::ctxt, cdata: @cstore::crate_metadata) -> ty::t {\n-        self.read_opaque(|_, doc| {\n-            tydecode::parse_ty_data(\n+        unwrap_(self.read_opaque(|_, doc| {\n+            wrap_(tydecode::parse_ty_data(\n                 doc.data,\n                 cdata.cnum,\n                 doc.start,\n                 tcx,\n-                |_, id| decoder::translate_def_id(cdata, id))\n-        })\n+                |_, id| decoder::translate_def_id(cdata, id)))\n+        }))\n     }\n \n     fn read_tys_noxcx(&mut self,\n                       tcx: &ty::ctxt,\n                       cdata: @cstore::crate_metadata) -> Vec<ty::t> {\n-        self.read_to_vec(|this| this.read_ty_noxcx(tcx, cdata) )\n+        unwrap_(self.read_to_vec(|this| wrap_(this.read_ty_noxcx(tcx, cdata)) ))\n             .move_iter()\n             .collect()\n     }\n@@ -1182,7 +1242,7 @@ impl<'a> ebml_decoder_decoder_helpers for reader::Decoder<'a> {\n         // context.  However, we do not bother, because region types\n         // are not used during trans.\n \n-        return self.read_opaque(|this, doc| {\n+        return unwrap_(self.read_opaque(|this, doc| {\n             debug!(\"read_ty({})\", type_string(doc));\n \n             let ty = tydecode::parse_ty_data(\n@@ -1192,8 +1252,8 @@ impl<'a> ebml_decoder_decoder_helpers for reader::Decoder<'a> {\n                 xcx.dcx.tcx,\n                 |s, a| this.convert_def_id(xcx, s, a));\n \n-            ty\n-        });\n+            wrap_(ty)\n+        }));\n \n         fn type_string(doc: ebml::Doc) -> ~str {\n             let mut str = ~\"\";\n@@ -1205,94 +1265,95 @@ impl<'a> ebml_decoder_decoder_helpers for reader::Decoder<'a> {\n     }\n \n     fn read_tys(&mut self, xcx: &ExtendedDecodeContext) -> Vec<ty::t> {\n-        self.read_to_vec(|this| this.read_ty(xcx)).move_iter().collect()\n+        unwrap_(self.read_to_vec(|this| wrap_(this.read_ty(xcx)))).move_iter().collect()\n     }\n \n     fn read_type_param_def(&mut self, xcx: &ExtendedDecodeContext)\n                            -> ty::TypeParameterDef {\n-        self.read_opaque(|this, doc| {\n-            tydecode::parse_type_param_def_data(\n+        unwrap_(self.read_opaque(|this, doc| {\n+            wrap_(tydecode::parse_type_param_def_data(\n                 doc.data,\n                 doc.start,\n                 xcx.dcx.cdata.cnum,\n                 xcx.dcx.tcx,\n-                |s, a| this.convert_def_id(xcx, s, a))\n-        })\n+                |s, a| this.convert_def_id(xcx, s, a)))\n+        }))\n     }\n \n     fn read_ty_param_bounds_and_ty(&mut self, xcx: &ExtendedDecodeContext)\n                                    -> ty::ty_param_bounds_and_ty {\n-        self.read_struct(\"ty_param_bounds_and_ty\", 2, |this| {\n-            ty::ty_param_bounds_and_ty {\n-                generics: this.read_struct_field(\"generics\", 0, |this| {\n+        unwrap_(self.read_struct(\"ty_param_bounds_and_ty\", 2, |this| {\n+            wrap_(ty::ty_param_bounds_and_ty {\n+                generics: unwrap_(this.read_struct_field(\"generics\", 0, |this| {\n                     this.read_struct(\"Generics\", 2, |this| {\n-                        ty::Generics {\n+                        wrap_(ty::Generics {\n                             type_param_defs:\n-                                this.read_struct_field(\"type_param_defs\",\n+                                unwrap_(this.read_struct_field(\"type_param_defs\",\n                                                        0,\n                                                        |this| {\n-                                    Rc::new(this.read_to_vec(|this|\n-                                                             this.read_type_param_def(xcx))\n+                                    wrap_(Rc::new(unwrap_(this.read_to_vec(|this|\n+                                                             wrap_(this.read_type_param_def(xcx))))\n                                                 .move_iter()\n-                                                .collect())\n-                            }),\n+                                                .collect()))\n+                            })),\n                             region_param_defs:\n-                                this.read_struct_field(\"region_param_defs\",\n+                                unwrap_(this.read_struct_field(\"region_param_defs\",\n                                                        1,\n                                                        |this| {\n                                     Decodable::decode(this)\n-                                })\n-                        }\n+                                }))\n+                        })\n                     })\n-                }),\n-                ty: this.read_struct_field(\"ty\", 1, |this| {\n-                    this.read_ty(xcx)\n-                })\n-            }\n-        })\n+                })),\n+                ty: unwrap_(this.read_struct_field(\"ty\", 1, |this| {\n+                    wrap_(this.read_ty(xcx))\n+                }))\n+            })\n+        }))\n     }\n \n     fn read_substs(&mut self, xcx: &ExtendedDecodeContext) -> ty::substs {\n-        self.read_opaque(|this, doc| {\n-            tydecode::parse_substs_data(doc.data,\n+        unwrap_(self.read_opaque(|this, doc| {\n+            wrap_(tydecode::parse_substs_data(doc.data,\n                                         xcx.dcx.cdata.cnum,\n                                         doc.start,\n                                         xcx.dcx.tcx,\n-                                        |s, a| this.convert_def_id(xcx, s, a))\n-        })\n+                                        |s, a| this.convert_def_id(xcx, s, a)))\n+        }))\n     }\n \n     fn read_auto_adjustment(&mut self, xcx: &ExtendedDecodeContext) -> ty::AutoAdjustment {\n-        self.read_enum(\"AutoAdjustment\", |this| {\n+        unwrap_(self.read_enum(\"AutoAdjustment\", |this| {\n             let variants = [\"AutoAddEnv\", \"AutoDerefRef\", \"AutoObject\"];\n             this.read_enum_variant(variants, |this, i| {\n-                match i {\n+                wrap_(match i {\n                     0 => {\n                         let region: ty::Region =\n-                            this.read_enum_variant_arg(0, |this| Decodable::decode(this));\n+                            unwrap_(this.read_enum_variant_arg(0, |this| Decodable::decode(this)));\n                         let sigil: ast::Sigil =\n-                            this.read_enum_variant_arg(1, |this| Decodable::decode(this));\n+                            unwrap_(this.read_enum_variant_arg(1, |this| Decodable::decode(this)));\n \n                         ty:: AutoAddEnv(region.tr(xcx), sigil)\n                     }\n                     1 => {\n                         let auto_deref_ref: ty::AutoDerefRef =\n-                            this.read_enum_variant_arg(0, |this| Decodable::decode(this));\n+                            unwrap_(this.read_enum_variant_arg(0, |this| Decodable::decode(this)));\n \n                         ty::AutoDerefRef(auto_deref_ref.tr(xcx))\n                     }\n                     2 => {\n                         let sigil: ast::Sigil =\n-                            this.read_enum_variant_arg(0, |this| Decodable::decode(this));\n+                            unwrap_(this.read_enum_variant_arg(0, |this| Decodable::decode(this)));\n                         let region: Option<ty::Region> =\n-                            this.read_enum_variant_arg(1, |this| Decodable::decode(this));\n+                            unwrap_(this.read_enum_variant_arg(1, |this| Decodable::decode(this)));\n                         let m: ast::Mutability =\n-                            this.read_enum_variant_arg(2, |this| Decodable::decode(this));\n+                            unwrap_(this.read_enum_variant_arg(2, |this| Decodable::decode(this)));\n                         let b: ty::BuiltinBounds =\n-                            this.read_enum_variant_arg(3, |this| Decodable::decode(this));\n+                            unwrap_(this.read_enum_variant_arg(3, |this| Decodable::decode(this)));\n                         let def_id: ast::DefId =\n-                            this.read_enum_variant_arg(4, |this| Decodable::decode(this));\n-                        let substs = this.read_enum_variant_arg(5, |this| this.read_substs(xcx));\n+                            unwrap_(this.read_enum_variant_arg(4, |this| Decodable::decode(this)));\n+                        let substs = unwrap_(\n+                            this.read_enum_variant_arg(5, |this| wrap_(this.read_substs(xcx))));\n \n                         let region = match region {\n                             Some(r) => Some(r.tr(xcx)),\n@@ -1302,9 +1363,9 @@ impl<'a> ebml_decoder_decoder_helpers for reader::Decoder<'a> {\n                         ty::AutoObject(sigil, region, m, b, def_id.tr(xcx), substs)\n                     }\n                     _ => fail!(\"bad enum variant for ty::AutoAdjustment\")\n-                }\n+                })\n             })\n-        })\n+        }))\n     }\n \n     fn convert_def_id(&mut self,\n@@ -1387,9 +1448,9 @@ fn decode_side_tables(xcx: &ExtendedDecodeContext,\n                         dcx.tcx.node_type_substs.borrow_mut().insert(id, tys);\n                     }\n                     c::tag_table_freevars => {\n-                        let fv_info = @val_dsr.read_to_vec(|val_dsr| {\n-                            @val_dsr.read_freevar_entry(xcx)\n-                        }).move_iter().collect();\n+                        let fv_info = @unwrap_(val_dsr.read_to_vec(|val_dsr| {\n+                            wrap_(@val_dsr.read_freevar_entry(xcx))\n+                        })).move_iter().collect();\n                         dcx.tcx.freevars.borrow_mut().insert(id, fv_info);\n                     }\n                     c::tag_table_tcache => {\n@@ -1425,7 +1486,8 @@ fn decode_side_tables(xcx: &ExtendedDecodeContext,\n                     }\n                     c::tag_table_capture_map => {\n                         let cvars =\n-                                val_dsr.read_to_vec(|val_dsr| val_dsr.read_capture_var(xcx))\n+                                unwrap_(val_dsr.read_to_vec(\n+                                            |val_dsr| wrap_(val_dsr.read_capture_var(xcx))))\n                                        .move_iter()\n                                        .collect();\n                         dcx.maps.capture_map.borrow_mut().insert(id, Rc::new(cvars));\n@@ -1447,7 +1509,7 @@ fn decode_side_tables(xcx: &ExtendedDecodeContext,\n // Testing of astencode_gen\n \n #[cfg(test)]\n-fn encode_item_ast(ebml_w: &mut writer::Encoder, item: @ast::Item) {\n+fn encode_item_ast(ebml_w: &mut Encoder, item: @ast::Item) {\n     ebml_w.start_tag(c::tag_tree as uint);\n     (*item).encode(ebml_w);\n     ebml_w.end_tag();\n@@ -1457,7 +1519,7 @@ fn encode_item_ast(ebml_w: &mut writer::Encoder, item: @ast::Item) {\n fn decode_item_ast(par_doc: ebml::Doc) -> @ast::Item {\n     let chi_doc = par_doc.get(c::tag_tree as uint);\n     let mut d = reader::Decoder(chi_doc);\n-    @Decodable::decode(&mut d)\n+    @unwrap_(Decodable::decode(&mut d))\n }\n \n #[cfg(test)]"}, {"sha": "38b3901a0eea353f8c7ce6391d2d74c1c7ead3ac", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f1739b14a1346419a4598339aee32aab07e0d12e/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1739b14a1346419a4598339aee32aab07e0d12e/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=f1739b14a1346419a4598339aee32aab07e0d12e", "patch": "@@ -327,6 +327,17 @@ fn rust_input(cratefile: &str, matches: &getopts::Matches) -> Output {\n     return pm.run_plugins(krate);\n }\n \n+// FIXME: remove unwrap_ after snapshot\n+#[cfg(stage0)]\n+fn unwrap_<T>(t: T) -> T {\n+    t\n+}\n+\n+#[cfg(not(stage0))]\n+fn unwrap_<T, E>(r: Result<T, E>) -> T {\n+    r.unwrap()\n+}\n+\n /// This input format purely deserializes the json output file. No passes are\n /// run over the deserialized output.\n fn json_input(input: &str) -> Result<Output, ~str> {\n@@ -352,7 +363,7 @@ fn json_input(input: &str) -> Result<Output, ~str> {\n             let krate = match obj.pop(&~\"crate\") {\n                 Some(json) => {\n                     let mut d = json::Decoder::new(json);\n-                    Decodable::decode(&mut d)\n+                    unwrap_(Decodable::decode(&mut d))\n                 }\n                 None => return Err(~\"malformed json\"),\n             };\n@@ -384,7 +395,7 @@ fn json_output(krate: clean::Crate, res: Vec<plugins::PluginJson> ,\n         let mut w = MemWriter::new();\n         {\n             let mut encoder = json::Encoder::new(&mut w as &mut io::Writer);\n-            krate.encode(&mut encoder);\n+            unwrap_(krate.encode(&mut encoder));\n         }\n         str::from_utf8_owned(w.unwrap()).unwrap()\n     };"}, {"sha": "8631fef5168abe5ab95323a6c3ddeb9f20d2611b", "filename": "src/libserialize/collection_impls.rs", "status": "modified", "additions": 132, "deletions": 110, "changes": 242, "blob_url": "https://github.com/rust-lang/rust/blob/f1739b14a1346419a4598339aee32aab07e0d12e/src%2Flibserialize%2Fcollection_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1739b14a1346419a4598339aee32aab07e0d12e/src%2Flibserialize%2Fcollection_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fcollection_impls.rs?ref=f1739b14a1346419a4598339aee32aab07e0d12e", "patch": "@@ -20,272 +20,294 @@ use collections::{DList, RingBuf, TreeMap, TreeSet, Deque, HashMap, HashSet,\n use collections::enum_set::{EnumSet, CLike};\n \n impl<\n-    S: Encoder,\n-    T: Encodable<S>\n-> Encodable<S> for DList<T> {\n-    fn encode(&self, s: &mut S) {\n+    E,\n+    S: Encoder<E>,\n+    T: Encodable<S, E>\n+> Encodable<S, E> for DList<T> {\n+    fn encode(&self, s: &mut S) -> Result<(), E> {\n         s.emit_seq(self.len(), |s| {\n             for (i, e) in self.iter().enumerate() {\n-                s.emit_seq_elt(i, |s| e.encode(s));\n+                try!(s.emit_seq_elt(i, |s| e.encode(s)));\n             }\n+            Ok(())\n         })\n     }\n }\n \n-impl<D:Decoder,T:Decodable<D>> Decodable<D> for DList<T> {\n-    fn decode(d: &mut D) -> DList<T> {\n-        let mut list = DList::new();\n+impl<E, D:Decoder<E>,T:Decodable<D, E>> Decodable<D, E> for DList<T> {\n+    fn decode(d: &mut D) -> Result<DList<T>, E> {\n         d.read_seq(|d, len| {\n+            let mut list = DList::new();\n             for i in range(0u, len) {\n-                list.push_back(d.read_seq_elt(i, |d| Decodable::decode(d)));\n+                list.push_back(try!(d.read_seq_elt(i, |d| Decodable::decode(d))));\n             }\n-        });\n-        list\n+            Ok(list)\n+        })\n     }\n }\n \n impl<\n-    S: Encoder,\n-    T: Encodable<S>\n-> Encodable<S> for RingBuf<T> {\n-    fn encode(&self, s: &mut S) {\n+    E,\n+    S: Encoder<E>,\n+    T: Encodable<S, E>\n+> Encodable<S, E> for RingBuf<T> {\n+    fn encode(&self, s: &mut S) -> Result<(), E> {\n         s.emit_seq(self.len(), |s| {\n             for (i, e) in self.iter().enumerate() {\n-                s.emit_seq_elt(i, |s| e.encode(s));\n+                try!(s.emit_seq_elt(i, |s| e.encode(s)));\n             }\n+            Ok(())\n         })\n     }\n }\n \n-impl<D:Decoder,T:Decodable<D>> Decodable<D> for RingBuf<T> {\n-    fn decode(d: &mut D) -> RingBuf<T> {\n-        let mut deque = RingBuf::new();\n+impl<E, D:Decoder<E>,T:Decodable<D, E>> Decodable<D, E> for RingBuf<T> {\n+    fn decode(d: &mut D) -> Result<RingBuf<T>, E> {\n         d.read_seq(|d, len| {\n+            let mut deque: RingBuf<T> = RingBuf::new();\n             for i in range(0u, len) {\n-                deque.push_back(d.read_seq_elt(i, |d| Decodable::decode(d)));\n+                deque.push_back(try!(d.read_seq_elt(i, |d| Decodable::decode(d))));\n             }\n-        });\n-        deque\n+            Ok(deque)\n+        })\n     }\n }\n \n impl<\n-    E: Encoder,\n-    K: Encodable<E> + Eq + TotalOrd,\n-    V: Encodable<E> + Eq\n-> Encodable<E> for TreeMap<K, V> {\n-    fn encode(&self, e: &mut E) {\n+    E,\n+    S: Encoder<E>,\n+    K: Encodable<S, E> + Eq + TotalOrd,\n+    V: Encodable<S, E> + Eq\n+> Encodable<S, E> for TreeMap<K, V> {\n+    fn encode(&self, e: &mut S) -> Result<(), E> {\n         e.emit_map(self.len(), |e| {\n             let mut i = 0;\n             for (key, val) in self.iter() {\n-                e.emit_map_elt_key(i, |e| key.encode(e));\n-                e.emit_map_elt_val(i, |e| val.encode(e));\n+                try!(e.emit_map_elt_key(i, |e| key.encode(e)));\n+                try!(e.emit_map_elt_val(i, |e| val.encode(e)));\n                 i += 1;\n             }\n+            Ok(())\n         })\n     }\n }\n \n impl<\n-    D: Decoder,\n-    K: Decodable<D> + Eq + TotalOrd,\n-    V: Decodable<D> + Eq\n-> Decodable<D> for TreeMap<K, V> {\n-    fn decode(d: &mut D) -> TreeMap<K, V> {\n+    E,\n+    D: Decoder<E>,\n+    K: Decodable<D, E> + Eq + TotalOrd,\n+    V: Decodable<D, E> + Eq\n+> Decodable<D, E> for TreeMap<K, V> {\n+    fn decode(d: &mut D) -> Result<TreeMap<K, V>, E> {\n         d.read_map(|d, len| {\n             let mut map = TreeMap::new();\n             for i in range(0u, len) {\n-                let key = d.read_map_elt_key(i, |d| Decodable::decode(d));\n-                let val = d.read_map_elt_val(i, |d| Decodable::decode(d));\n+                let key = try!(d.read_map_elt_key(i, |d| Decodable::decode(d)));\n+                let val = try!(d.read_map_elt_val(i, |d| Decodable::decode(d)));\n                 map.insert(key, val);\n             }\n-            map\n+            Ok(map)\n         })\n     }\n }\n \n impl<\n-    S: Encoder,\n-    T: Encodable<S> + Eq + TotalOrd\n-> Encodable<S> for TreeSet<T> {\n-    fn encode(&self, s: &mut S) {\n+    E,\n+    S: Encoder<E>,\n+    T: Encodable<S, E> + Eq + TotalOrd\n+> Encodable<S, E> for TreeSet<T> {\n+    fn encode(&self, s: &mut S) -> Result<(), E> {\n         s.emit_seq(self.len(), |s| {\n             let mut i = 0;\n             for e in self.iter() {\n-                s.emit_seq_elt(i, |s| e.encode(s));\n+                try!(s.emit_seq_elt(i, |s| e.encode(s)));\n                 i += 1;\n             }\n+            Ok(())\n         })\n     }\n }\n \n impl<\n-    D: Decoder,\n-    T: Decodable<D> + Eq + TotalOrd\n-> Decodable<D> for TreeSet<T> {\n-    fn decode(d: &mut D) -> TreeSet<T> {\n+    E,\n+    D: Decoder<E>,\n+    T: Decodable<D, E> + Eq + TotalOrd\n+> Decodable<D, E> for TreeSet<T> {\n+    fn decode(d: &mut D) -> Result<TreeSet<T>, E> {\n         d.read_seq(|d, len| {\n             let mut set = TreeSet::new();\n             for i in range(0u, len) {\n-                set.insert(d.read_seq_elt(i, |d| Decodable::decode(d)));\n+                set.insert(try!(d.read_seq_elt(i, |d| Decodable::decode(d))));\n             }\n-            set\n+            Ok(set)\n         })\n     }\n }\n \n impl<\n-    S: Encoder,\n-    T: Encodable<S> + CLike\n-> Encodable<S> for EnumSet<T> {\n-    fn encode(&self, s: &mut S) {\n+    E,\n+    S: Encoder<E>,\n+    T: Encodable<S, E> + CLike\n+> Encodable<S, E> for EnumSet<T> {\n+    fn encode(&self, s: &mut S) -> Result<(), E> {\n         let mut bits = 0;\n         for item in self.iter() {\n             bits |= item.to_uint();\n         }\n-        s.emit_uint(bits);\n+        s.emit_uint(bits)\n     }\n }\n \n impl<\n-    D: Decoder,\n-    T: Decodable<D> + CLike\n-> Decodable<D> for EnumSet<T> {\n-    fn decode(d: &mut D) -> EnumSet<T> {\n-        let bits = d.read_uint();\n+    E,\n+    D: Decoder<E>,\n+    T: Decodable<D, E> + CLike\n+> Decodable<D, E> for EnumSet<T> {\n+    fn decode(d: &mut D) -> Result<EnumSet<T>, E> {\n+        let bits = try!(d.read_uint());\n         let mut set = EnumSet::empty();\n         for bit in range(0, uint::BITS) {\n             if bits & (1 << bit) != 0 {\n                 set.add(CLike::from_uint(1 << bit));\n             }\n         }\n-        set\n+        Ok(set)\n     }\n }\n \n impl<\n-    E: Encoder,\n-    K: Encodable<E> + Hash<S> + TotalEq,\n-    V: Encodable<E>,\n-    S,\n-    H: Hasher<S>\n-> Encodable<E> for HashMap<K, V, H> {\n-    fn encode(&self, e: &mut E) {\n+    E,\n+    S: Encoder<E>,\n+    K: Encodable<S, E> + Hash<X> + TotalEq,\n+    V: Encodable<S, E>,\n+    X,\n+    H: Hasher<X>\n+> Encodable<S, E> for HashMap<K, V, H> {\n+    fn encode(&self, e: &mut S) -> Result<(), E> {\n         e.emit_map(self.len(), |e| {\n             let mut i = 0;\n             for (key, val) in self.iter() {\n-                e.emit_map_elt_key(i, |e| key.encode(e));\n-                e.emit_map_elt_val(i, |e| val.encode(e));\n+                try!(e.emit_map_elt_key(i, |e| key.encode(e)));\n+                try!(e.emit_map_elt_val(i, |e| val.encode(e)));\n                 i += 1;\n             }\n+            Ok(())\n         })\n     }\n }\n \n impl<\n-    D: Decoder,\n-    K: Decodable<D> + Hash<S> + TotalEq,\n-    V: Decodable<D>,\n+    E,\n+    D: Decoder<E>,\n+    K: Decodable<D, E> + Hash<S> + TotalEq,\n+    V: Decodable<D, E>,\n     S,\n     H: Hasher<S> + Default\n-> Decodable<D> for HashMap<K, V, H> {\n-    fn decode(d: &mut D) -> HashMap<K, V, H> {\n+> Decodable<D, E> for HashMap<K, V, H> {\n+    fn decode(d: &mut D) -> Result<HashMap<K, V, H>, E> {\n         d.read_map(|d, len| {\n             let hasher = Default::default();\n             let mut map = HashMap::with_capacity_and_hasher(len, hasher);\n             for i in range(0u, len) {\n-                let key = d.read_map_elt_key(i, |d| Decodable::decode(d));\n-                let val = d.read_map_elt_val(i, |d| Decodable::decode(d));\n+                let key = try!(d.read_map_elt_key(i, |d| Decodable::decode(d)));\n+                let val = try!(d.read_map_elt_val(i, |d| Decodable::decode(d)));\n                 map.insert(key, val);\n             }\n-            map\n+            Ok(map)\n         })\n     }\n }\n \n impl<\n-    E: Encoder,\n-    T: Encodable<E> + Hash<S> + TotalEq,\n-    S,\n-    H: Hasher<S>\n-> Encodable<E> for HashSet<T, H> {\n-    fn encode(&self, s: &mut E) {\n+    E,\n+    S: Encoder<E>,\n+    T: Encodable<S, E> + Hash<X> + TotalEq,\n+    X,\n+    H: Hasher<X>\n+> Encodable<S, E> for HashSet<T, H> {\n+    fn encode(&self, s: &mut S) -> Result<(), E> {\n         s.emit_seq(self.len(), |s| {\n             let mut i = 0;\n             for e in self.iter() {\n-                s.emit_seq_elt(i, |s| e.encode(s));\n+                try!(s.emit_seq_elt(i, |s| e.encode(s)));\n                 i += 1;\n             }\n+            Ok(())\n         })\n     }\n }\n \n impl<\n-    D: Decoder,\n-    T: Decodable<D> + Hash<S> + TotalEq,\n+    E,\n+    D: Decoder<E>,\n+    T: Decodable<D, E> + Hash<S> + TotalEq,\n     S,\n     H: Hasher<S> + Default\n-> Decodable<D> for HashSet<T, H> {\n-    fn decode(d: &mut D) -> HashSet<T, H> {\n+> Decodable<D, E> for HashSet<T, H> {\n+    fn decode(d: &mut D) -> Result<HashSet<T, H>, E> {\n         d.read_seq(|d, len| {\n             let mut set = HashSet::with_capacity_and_hasher(len, Default::default());\n             for i in range(0u, len) {\n-                set.insert(d.read_seq_elt(i, |d| Decodable::decode(d)));\n+                set.insert(try!(d.read_seq_elt(i, |d| Decodable::decode(d))));\n             }\n-            set\n+            Ok(set)\n         })\n     }\n }\n \n impl<\n-    E: Encoder,\n-    V: Encodable<E>\n-> Encodable<E> for TrieMap<V> {\n-    fn encode(&self, e: &mut E) {\n+    E,\n+    S: Encoder<E>,\n+    V: Encodable<S, E>\n+> Encodable<S, E> for TrieMap<V> {\n+    fn encode(&self, e: &mut S) -> Result<(), E> {\n         e.emit_map(self.len(), |e| {\n                 for (i, (key, val)) in self.iter().enumerate() {\n-                    e.emit_map_elt_key(i, |e| key.encode(e));\n-                    e.emit_map_elt_val(i, |e| val.encode(e));\n+                    try!(e.emit_map_elt_key(i, |e| key.encode(e)));\n+                    try!(e.emit_map_elt_val(i, |e| val.encode(e)));\n                 }\n-            });\n+                Ok(())\n+            })\n     }\n }\n \n impl<\n-    D: Decoder,\n-    V: Decodable<D>\n-> Decodable<D> for TrieMap<V> {\n-    fn decode(d: &mut D) -> TrieMap<V> {\n+    E,\n+    D: Decoder<E>,\n+    V: Decodable<D, E>\n+> Decodable<D, E> for TrieMap<V> {\n+    fn decode(d: &mut D) -> Result<TrieMap<V>, E> {\n         d.read_map(|d, len| {\n             let mut map = TrieMap::new();\n             for i in range(0u, len) {\n-                let key = d.read_map_elt_key(i, |d| Decodable::decode(d));\n-                let val = d.read_map_elt_val(i, |d| Decodable::decode(d));\n+                let key = try!(d.read_map_elt_key(i, |d| Decodable::decode(d)));\n+                let val = try!(d.read_map_elt_val(i, |d| Decodable::decode(d)));\n                 map.insert(key, val);\n             }\n-            map\n+            Ok(map)\n         })\n     }\n }\n \n-impl<S: Encoder> Encodable<S> for TrieSet {\n-    fn encode(&self, s: &mut S) {\n+impl<E, S: Encoder<E>> Encodable<S, E> for TrieSet {\n+    fn encode(&self, s: &mut S) -> Result<(), E> {\n         s.emit_seq(self.len(), |s| {\n                 for (i, e) in self.iter().enumerate() {\n-                    s.emit_seq_elt(i, |s| e.encode(s));\n+                    try!(s.emit_seq_elt(i, |s| e.encode(s)));\n                 }\n+                Ok(())\n             })\n     }\n }\n \n-impl<D: Decoder> Decodable<D> for TrieSet {\n-    fn decode(d: &mut D) -> TrieSet {\n+impl<E, D: Decoder<E>> Decodable<D, E> for TrieSet {\n+    fn decode(d: &mut D) -> Result<TrieSet, E> {\n         d.read_seq(|d, len| {\n             let mut set = TrieSet::new();\n             for i in range(0u, len) {\n-                set.insert(d.read_seq_elt(i, |d| Decodable::decode(d)));\n+                set.insert(try!(d.read_seq_elt(i, |d| Decodable::decode(d))));\n             }\n-            set\n+            Ok(set)\n         })\n     }\n }"}, {"sha": "5994fbc5d10051f7e94bfe936cd381c0b5b3c289", "filename": "src/libserialize/collection_impls_old.rs", "status": "added", "additions": 292, "deletions": 0, "changes": 292, "blob_url": "https://github.com/rust-lang/rust/blob/f1739b14a1346419a4598339aee32aab07e0d12e/src%2Flibserialize%2Fcollection_impls_old.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1739b14a1346419a4598339aee32aab07e0d12e/src%2Flibserialize%2Fcollection_impls_old.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fcollection_impls_old.rs?ref=f1739b14a1346419a4598339aee32aab07e0d12e", "patch": "@@ -0,0 +1,292 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Implementations of serialization for structures found in libcollections\n+\n+use std::uint;\n+use std::default::Default;\n+use std::hash::{Hash, Hasher};\n+\n+use {Decodable, Encodable, Decoder, Encoder};\n+use collections::{DList, RingBuf, TreeMap, TreeSet, Deque, HashMap, HashSet,\n+                  TrieMap, TrieSet};\n+use collections::enum_set::{EnumSet, CLike};\n+\n+impl<\n+    S: Encoder,\n+    T: Encodable<S>\n+> Encodable<S> for DList<T> {\n+    fn encode(&self, s: &mut S) {\n+        s.emit_seq(self.len(), |s| {\n+            for (i, e) in self.iter().enumerate() {\n+                s.emit_seq_elt(i, |s| e.encode(s));\n+            }\n+        })\n+    }\n+}\n+\n+impl<D:Decoder,T:Decodable<D>> Decodable<D> for DList<T> {\n+    fn decode(d: &mut D) -> DList<T> {\n+        let mut list = DList::new();\n+        d.read_seq(|d, len| {\n+            for i in range(0u, len) {\n+                list.push_back(d.read_seq_elt(i, |d| Decodable::decode(d)));\n+            }\n+        });\n+        list\n+    }\n+}\n+\n+impl<\n+    S: Encoder,\n+    T: Encodable<S>\n+> Encodable<S> for RingBuf<T> {\n+    fn encode(&self, s: &mut S) {\n+        s.emit_seq(self.len(), |s| {\n+            for (i, e) in self.iter().enumerate() {\n+                s.emit_seq_elt(i, |s| e.encode(s));\n+            }\n+        })\n+    }\n+}\n+\n+impl<D:Decoder,T:Decodable<D>> Decodable<D> for RingBuf<T> {\n+    fn decode(d: &mut D) -> RingBuf<T> {\n+        let mut deque = RingBuf::new();\n+        d.read_seq(|d, len| {\n+            for i in range(0u, len) {\n+                deque.push_back(d.read_seq_elt(i, |d| Decodable::decode(d)));\n+            }\n+        });\n+        deque\n+    }\n+}\n+\n+impl<\n+    E: Encoder,\n+    K: Encodable<E> + Eq + TotalOrd,\n+    V: Encodable<E> + Eq\n+> Encodable<E> for TreeMap<K, V> {\n+    fn encode(&self, e: &mut E) {\n+        e.emit_map(self.len(), |e| {\n+            let mut i = 0;\n+            for (key, val) in self.iter() {\n+                e.emit_map_elt_key(i, |e| key.encode(e));\n+                e.emit_map_elt_val(i, |e| val.encode(e));\n+                i += 1;\n+            }\n+        })\n+    }\n+}\n+\n+impl<\n+    D: Decoder,\n+    K: Decodable<D> + Eq + TotalOrd,\n+    V: Decodable<D> + Eq\n+> Decodable<D> for TreeMap<K, V> {\n+    fn decode(d: &mut D) -> TreeMap<K, V> {\n+        d.read_map(|d, len| {\n+            let mut map = TreeMap::new();\n+            for i in range(0u, len) {\n+                let key = d.read_map_elt_key(i, |d| Decodable::decode(d));\n+                let val = d.read_map_elt_val(i, |d| Decodable::decode(d));\n+                map.insert(key, val);\n+            }\n+            map\n+        })\n+    }\n+}\n+\n+impl<\n+    S: Encoder,\n+    T: Encodable<S> + Eq + TotalOrd\n+> Encodable<S> for TreeSet<T> {\n+    fn encode(&self, s: &mut S) {\n+        s.emit_seq(self.len(), |s| {\n+            let mut i = 0;\n+            for e in self.iter() {\n+                s.emit_seq_elt(i, |s| e.encode(s));\n+                i += 1;\n+            }\n+        })\n+    }\n+}\n+\n+impl<\n+    D: Decoder,\n+    T: Decodable<D> + Eq + TotalOrd\n+> Decodable<D> for TreeSet<T> {\n+    fn decode(d: &mut D) -> TreeSet<T> {\n+        d.read_seq(|d, len| {\n+            let mut set = TreeSet::new();\n+            for i in range(0u, len) {\n+                set.insert(d.read_seq_elt(i, |d| Decodable::decode(d)));\n+            }\n+            set\n+        })\n+    }\n+}\n+\n+impl<\n+    S: Encoder,\n+    T: Encodable<S> + CLike\n+> Encodable<S> for EnumSet<T> {\n+    fn encode(&self, s: &mut S) {\n+        let mut bits = 0;\n+        for item in self.iter() {\n+            bits |= item.to_uint();\n+        }\n+        s.emit_uint(bits);\n+    }\n+}\n+\n+impl<\n+    D: Decoder,\n+    T: Decodable<D> + CLike\n+> Decodable<D> for EnumSet<T> {\n+    fn decode(d: &mut D) -> EnumSet<T> {\n+        let bits = d.read_uint();\n+        let mut set = EnumSet::empty();\n+        for bit in range(0, uint::BITS) {\n+            if bits & (1 << bit) != 0 {\n+                set.add(CLike::from_uint(1 << bit));\n+            }\n+        }\n+        set\n+    }\n+}\n+\n+impl<\n+    E: Encoder,\n+    K: Encodable<E> + Hash<S> + TotalEq,\n+    V: Encodable<E>,\n+    S,\n+    H: Hasher<S>\n+> Encodable<E> for HashMap<K, V, H> {\n+    fn encode(&self, e: &mut E) {\n+        e.emit_map(self.len(), |e| {\n+            let mut i = 0;\n+            for (key, val) in self.iter() {\n+                e.emit_map_elt_key(i, |e| key.encode(e));\n+                e.emit_map_elt_val(i, |e| val.encode(e));\n+                i += 1;\n+            }\n+        })\n+    }\n+}\n+\n+impl<\n+    D: Decoder,\n+    K: Decodable<D> + Hash<S> + TotalEq,\n+    V: Decodable<D>,\n+    S,\n+    H: Hasher<S> + Default\n+> Decodable<D> for HashMap<K, V, H> {\n+    fn decode(d: &mut D) -> HashMap<K, V, H> {\n+        d.read_map(|d, len| {\n+            let hasher = Default::default();\n+            let mut map = HashMap::with_capacity_and_hasher(len, hasher);\n+            for i in range(0u, len) {\n+                let key = d.read_map_elt_key(i, |d| Decodable::decode(d));\n+                let val = d.read_map_elt_val(i, |d| Decodable::decode(d));\n+                map.insert(key, val);\n+            }\n+            map\n+        })\n+    }\n+}\n+\n+impl<\n+    E: Encoder,\n+    T: Encodable<E> + Hash<S> + TotalEq,\n+    S,\n+    H: Hasher<S>\n+> Encodable<E> for HashSet<T, H> {\n+    fn encode(&self, s: &mut E) {\n+        s.emit_seq(self.len(), |s| {\n+            let mut i = 0;\n+            for e in self.iter() {\n+                s.emit_seq_elt(i, |s| e.encode(s));\n+                i += 1;\n+            }\n+        })\n+    }\n+}\n+\n+impl<\n+    D: Decoder,\n+    T: Decodable<D> + Hash<S> + TotalEq,\n+    S,\n+    H: Hasher<S> + Default\n+> Decodable<D> for HashSet<T, H> {\n+    fn decode(d: &mut D) -> HashSet<T, H> {\n+        d.read_seq(|d, len| {\n+            let mut set = HashSet::with_capacity_and_hasher(len, Default::default());\n+            for i in range(0u, len) {\n+                set.insert(d.read_seq_elt(i, |d| Decodable::decode(d)));\n+            }\n+            set\n+        })\n+    }\n+}\n+\n+impl<\n+    E: Encoder,\n+    V: Encodable<E>\n+> Encodable<E> for TrieMap<V> {\n+    fn encode(&self, e: &mut E) {\n+        e.emit_map(self.len(), |e| {\n+                for (i, (key, val)) in self.iter().enumerate() {\n+                    e.emit_map_elt_key(i, |e| key.encode(e));\n+                    e.emit_map_elt_val(i, |e| val.encode(e));\n+                }\n+            });\n+    }\n+}\n+\n+impl<\n+    D: Decoder,\n+    V: Decodable<D>\n+> Decodable<D> for TrieMap<V> {\n+    fn decode(d: &mut D) -> TrieMap<V> {\n+        d.read_map(|d, len| {\n+            let mut map = TrieMap::new();\n+            for i in range(0u, len) {\n+                let key = d.read_map_elt_key(i, |d| Decodable::decode(d));\n+                let val = d.read_map_elt_val(i, |d| Decodable::decode(d));\n+                map.insert(key, val);\n+            }\n+            map\n+        })\n+    }\n+}\n+\n+impl<S: Encoder> Encodable<S> for TrieSet {\n+    fn encode(&self, s: &mut S) {\n+        s.emit_seq(self.len(), |s| {\n+                for (i, e) in self.iter().enumerate() {\n+                    s.emit_seq_elt(i, |s| e.encode(s));\n+                }\n+            })\n+    }\n+}\n+\n+impl<D: Decoder> Decodable<D> for TrieSet {\n+    fn decode(d: &mut D) -> TrieSet {\n+        d.read_seq(|d, len| {\n+            let mut set = TrieSet::new();\n+            for i in range(0u, len) {\n+                set.insert(d.read_seq_elt(i, |d| Decodable::decode(d)));\n+            }\n+            set\n+        })\n+    }\n+}\n+"}, {"sha": "cc2385665a21a207a19a3e80be812037f0a350d2", "filename": "src/libserialize/ebml.rs", "status": "modified", "additions": 346, "deletions": 287, "changes": 633, "blob_url": "https://github.com/rust-lang/rust/blob/f1739b14a1346419a4598339aee32aab07e0d12e/src%2Flibserialize%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1739b14a1346419a4598339aee32aab07e0d12e/src%2Flibserialize%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Febml.rs?ref=f1739b14a1346419a4598339aee32aab07e0d12e", "patch": "@@ -10,12 +10,9 @@\n \n #[allow(missing_doc)];\n \n+use std::io;\n use std::str;\n \n-macro_rules! try( ($e:expr) => (\n-    match $e { Ok(e) => e, Err(e) => { self.last_error = Err(e); return } }\n-) )\n-\n // Simple Extensible Binary Markup Language (ebml) reader and writer on a\n // cursor model. See the specification here:\n //     http://www.matroska.org/technical/specs/rfc/index.html\n@@ -79,6 +76,13 @@ pub enum EbmlEncoderTag {\n \n     EsLabel, // Used only when debugging\n }\n+\n+#[deriving(Show)]\n+pub enum Error {\n+    IntTooBig(uint),\n+    Expected(~str),\n+    IoError(io::IoError)\n+}\n // --------------------------------------\n \n pub mod reader {\n@@ -94,43 +98,57 @@ pub mod reader {\n     use super::{ EsVec, EsMap, EsEnum, EsVecLen, EsVecElt, EsMapLen, EsMapKey,\n         EsEnumVid, EsU64, EsU32, EsU16, EsU8, EsInt, EsI64, EsI32, EsI16, EsI8,\n         EsBool, EsF64, EsF32, EsChar, EsStr, EsMapVal, EsEnumBody, EsUint,\n-        EsOpaque, EsLabel, EbmlEncoderTag, Doc, TaggedDoc };\n+        EsOpaque, EsLabel, EbmlEncoderTag, Doc, TaggedDoc, Error, IntTooBig,\n+        Expected };\n \n+    pub type DecodeResult<T> = Result<T, Error>;\n     // ebml reading\n \n+    macro_rules! try_or(\n+        ($e:expr, $r:expr) => (\n+            match $e {\n+                Ok(e) => e,\n+                Err(e) => {\n+                    debug!(\"ignored error: {}\", e);\n+                    return $r\n+                }\n+            }\n+        )\n+    )\n+\n     pub struct Res {\n         val: uint,\n         next: uint\n     }\n \n     #[inline(never)]\n-    fn vuint_at_slow(data: &[u8], start: uint) -> Res {\n+    fn vuint_at_slow(data: &[u8], start: uint) -> DecodeResult<Res> {\n         let a = data[start];\n         if a & 0x80u8 != 0u8 {\n-            return Res {val: (a & 0x7fu8) as uint, next: start + 1u};\n+            return Ok(Res {val: (a & 0x7fu8) as uint, next: start + 1u});\n         }\n         if a & 0x40u8 != 0u8 {\n-            return Res {val: ((a & 0x3fu8) as uint) << 8u |\n+            return Ok(Res {val: ((a & 0x3fu8) as uint) << 8u |\n                         (data[start + 1u] as uint),\n-                    next: start + 2u};\n+                    next: start + 2u});\n         }\n         if a & 0x20u8 != 0u8 {\n-            return Res {val: ((a & 0x1fu8) as uint) << 16u |\n+            return Ok(Res {val: ((a & 0x1fu8) as uint) << 16u |\n                         (data[start + 1u] as uint) << 8u |\n                         (data[start + 2u] as uint),\n-                    next: start + 3u};\n+                    next: start + 3u});\n         }\n         if a & 0x10u8 != 0u8 {\n-            return Res {val: ((a & 0x0fu8) as uint) << 24u |\n+            return Ok(Res {val: ((a & 0x0fu8) as uint) << 24u |\n                         (data[start + 1u] as uint) << 16u |\n                         (data[start + 2u] as uint) << 8u |\n                         (data[start + 3u] as uint),\n-                    next: start + 4u};\n+                    next: start + 4u});\n         }\n-        fail!(\"vint too big\");\n+        Err(IntTooBig(a as uint))\n     }\n \n-    pub fn vuint_at(data: &[u8], start: uint) -> Res {\n+    pub fn vuint_at(data: &[u8], start: uint) -> DecodeResult<Res> {\n         use std::mem::from_be32;\n \n         if data.len() - start < 4 {\n@@ -166,32 +184,32 @@ pub mod reader {\n \n             let i = (val >> 28u) as uint;\n             let (shift, mask) = SHIFT_MASK_TABLE[i];\n-            Res {\n+            Ok(Res {\n                 val: ((val >> shift) & mask) as uint,\n                 next: start + (((32 - shift) >> 3) as uint)\n-            }\n+            })\n         }\n     }\n \n     pub fn Doc<'a>(data: &'a [u8]) -> Doc<'a> {\n         Doc { data: data, start: 0u, end: data.len() }\n     }\n \n-    pub fn doc_at<'a>(data: &'a [u8], start: uint) -> TaggedDoc<'a> {\n-        let elt_tag = vuint_at(data, start);\n-        let elt_size = vuint_at(data, elt_tag.next);\n+    pub fn doc_at<'a>(data: &'a [u8], start: uint) -> DecodeResult<TaggedDoc<'a>> {\n+        let elt_tag = try!(vuint_at(data, start));\n+        let elt_size = try!(vuint_at(data, elt_tag.next));\n         let end = elt_size.next + elt_size.val;\n-        TaggedDoc {\n+        Ok(TaggedDoc {\n             tag: elt_tag.val,\n             doc: Doc { data: data, start: elt_size.next, end: end }\n-        }\n+        })\n     }\n \n     pub fn maybe_get_doc<'a>(d: Doc<'a>, tg: uint) -> Option<Doc<'a>> {\n         let mut pos = d.start;\n         while pos < d.end {\n-            let elt_tag = vuint_at(d.data, pos);\n-            let elt_size = vuint_at(d.data, elt_tag.next);\n+            let elt_tag = try_or!(vuint_at(d.data, pos), None);\n+            let elt_size = try_or!(vuint_at(d.data, elt_tag.next), None);\n             pos = elt_size.next + elt_size.val;\n             if elt_tag.val == tg {\n                 return Some(Doc { data: d.data, start: elt_size.next,\n@@ -214,8 +232,8 @@ pub mod reader {\n     pub fn docs<'a>(d: Doc<'a>, it: |uint, Doc<'a>| -> bool) -> bool {\n         let mut pos = d.start;\n         while pos < d.end {\n-            let elt_tag = vuint_at(d.data, pos);\n-            let elt_size = vuint_at(d.data, elt_tag.next);\n+            let elt_tag = try_or!(vuint_at(d.data, pos), false);\n+            let elt_size = try_or!(vuint_at(d.data, elt_tag.next), false);\n             pos = elt_size.next + elt_size.val;\n             let doc = Doc { data: d.data, start: elt_size.next, end: pos };\n             if !it(elt_tag.val, doc) {\n@@ -228,8 +246,8 @@ pub mod reader {\n     pub fn tagged_docs<'a>(d: Doc<'a>, tg: uint, it: |Doc<'a>| -> bool) -> bool {\n         let mut pos = d.start;\n         while pos < d.end {\n-            let elt_tag = vuint_at(d.data, pos);\n-            let elt_size = vuint_at(d.data, elt_tag.next);\n+            let elt_tag = try_or!(vuint_at(d.data, pos), false);\n+            let elt_size = try_or!(vuint_at(d.data, elt_tag.next), false);\n             pos = elt_size.next + elt_size.val;\n             if elt_tag.val == tg {\n                 let doc = Doc { data: d.data, start: elt_size.next,\n@@ -285,28 +303,29 @@ pub mod reader {\n     }\n \n     impl<'doc> Decoder<'doc> {\n-        fn _check_label(&mut self, lbl: &str) {\n+        fn _check_label(&mut self, lbl: &str) -> DecodeResult<()> {\n             if self.pos < self.parent.end {\n                 let TaggedDoc { tag: r_tag, doc: r_doc } =\n-                    doc_at(self.parent.data, self.pos);\n+                    try!(doc_at(self.parent.data, self.pos));\n \n                 if r_tag == (EsLabel as uint) {\n                     self.pos = r_doc.end;\n                     let str = r_doc.as_str_slice();\n                     if lbl != str {\n-                        fail!(\"Expected label {} but found {}\", lbl, str);\n+                        return Err(Expected(format!(\"Expected label {} but found {}\", lbl, str)));\n                     }\n                 }\n             }\n+            Ok(())\n         }\n \n-        fn next_doc(&mut self, exp_tag: EbmlEncoderTag) -> Doc<'doc> {\n+        fn next_doc(&mut self, exp_tag: EbmlEncoderTag) -> DecodeResult<Doc<'doc>> {\n             debug!(\". next_doc(exp_tag={:?})\", exp_tag);\n             if self.pos >= self.parent.end {\n-                fail!(\"no more documents in current node!\");\n+                return Err(Expected(format!(\"no more documents in current node!\")));\n             }\n             let TaggedDoc { tag: r_tag, doc: r_doc } =\n-                doc_at(self.parent.data, self.pos);\n+                try!(doc_at(self.parent.data, self.pos));\n             debug!(\"self.parent={}-{} self.pos={} r_tag={} r_doc={}-{}\",\n                    self.parent.start,\n                    self.parent.end,\n@@ -315,273 +334,282 @@ pub mod reader {\n                    r_doc.start,\n                    r_doc.end);\n             if r_tag != (exp_tag as uint) {\n-                fail!(\"expected EBML doc with tag {:?} but found tag {:?}\",\n-                       exp_tag, r_tag);\n+                return Err(Expected(format!(\"expected EBML doc with tag {:?} but found tag {:?}\",\n+                       exp_tag, r_tag)));\n             }\n             if r_doc.end > self.parent.end {\n-                fail!(\"invalid EBML, child extends to {:#x}, parent to {:#x}\",\n-                      r_doc.end, self.parent.end);\n+                return Err(Expected(format!(\"invalid EBML, child extends to {:#x}, parent to {:#x}\",\n+                      r_doc.end, self.parent.end)));\n             }\n             self.pos = r_doc.end;\n-            r_doc\n+            Ok(r_doc)\n         }\n \n         fn push_doc<T>(&mut self, exp_tag: EbmlEncoderTag,\n-                       f: |&mut Decoder<'doc>| -> T) -> T {\n-            let d = self.next_doc(exp_tag);\n+                       f: |&mut Decoder<'doc>| -> DecodeResult<T>) -> DecodeResult<T> {\n+            let d = try!(self.next_doc(exp_tag));\n             let old_parent = self.parent;\n             let old_pos = self.pos;\n             self.parent = d;\n             self.pos = d.start;\n-            let r = f(self);\n+            let r = try!(f(self));\n             self.parent = old_parent;\n             self.pos = old_pos;\n-            r\n+            Ok(r)\n         }\n \n-        fn _next_uint(&mut self, exp_tag: EbmlEncoderTag) -> uint {\n-            let r = doc_as_u32(self.next_doc(exp_tag));\n+        fn _next_uint(&mut self, exp_tag: EbmlEncoderTag) -> DecodeResult<uint> {\n+            let r = doc_as_u32(try!(self.next_doc(exp_tag)));\n             debug!(\"_next_uint exp_tag={:?} result={}\", exp_tag, r);\n-            r as uint\n+            Ok(r as uint)\n         }\n \n-        pub fn read_opaque<R>(&mut self, op: |&mut Decoder<'doc>, Doc| -> R) -> R {\n-            let doc = self.next_doc(EsOpaque);\n+        pub fn read_opaque<R>(&mut self,\n+                              op: |&mut Decoder<'doc>, Doc| -> DecodeResult<R>) -> DecodeResult<R> {\n+            let doc = try!(self.next_doc(EsOpaque));\n \n             let (old_parent, old_pos) = (self.parent, self.pos);\n             self.parent = doc;\n             self.pos = doc.start;\n \n-            let result = op(self, doc);\n+            let result = try!(op(self, doc));\n \n             self.parent = old_parent;\n             self.pos = old_pos;\n-            result\n+            Ok(result)\n         }\n     }\n \n-    impl<'doc> serialize::Decoder for Decoder<'doc> {\n-        fn read_nil(&mut self) -> () { () }\n+    impl<'doc> serialize::Decoder<Error> for Decoder<'doc> {\n+        fn read_nil(&mut self) -> DecodeResult<()> { Ok(()) }\n \n-        fn read_u64(&mut self) -> u64 { doc_as_u64(self.next_doc(EsU64)) }\n-        fn read_u32(&mut self) -> u32 { doc_as_u32(self.next_doc(EsU32)) }\n-        fn read_u16(&mut self) -> u16 { doc_as_u16(self.next_doc(EsU16)) }\n-        fn read_u8 (&mut self) -> u8  { doc_as_u8 (self.next_doc(EsU8 )) }\n-        fn read_uint(&mut self) -> uint {\n-            let v = doc_as_u64(self.next_doc(EsUint));\n+        fn read_u64(&mut self) -> DecodeResult<u64> { Ok(doc_as_u64(try!(self.next_doc(EsU64)))) }\n+        fn read_u32(&mut self) -> DecodeResult<u32> { Ok(doc_as_u32(try!(self.next_doc(EsU32)))) }\n+        fn read_u16(&mut self) -> DecodeResult<u16> { Ok(doc_as_u16(try!(self.next_doc(EsU16)))) }\n+        fn read_u8 (&mut self) -> DecodeResult<u8 > { Ok(doc_as_u8 (try!(self.next_doc(EsU8 )))) }\n+        fn read_uint(&mut self) -> DecodeResult<uint> {\n+            let v = doc_as_u64(try!(self.next_doc(EsUint)));\n             if v > (::std::uint::MAX as u64) {\n-                fail!(\"uint {} too large for this architecture\", v);\n+                Err(IntTooBig(v as uint))\n+            } else {\n+                Ok(v as uint)\n             }\n-            v as uint\n         }\n \n-        fn read_i64(&mut self) -> i64 {\n-            doc_as_u64(self.next_doc(EsI64)) as i64\n+        fn read_i64(&mut self) -> DecodeResult<i64> {\n+            Ok(doc_as_u64(try!(self.next_doc(EsI64))) as i64)\n         }\n-        fn read_i32(&mut self) -> i32 {\n-            doc_as_u32(self.next_doc(EsI32)) as i32\n+        fn read_i32(&mut self) -> DecodeResult<i32> {\n+            Ok(doc_as_u32(try!(self.next_doc(EsI32))) as i32)\n         }\n-        fn read_i16(&mut self) -> i16 {\n-            doc_as_u16(self.next_doc(EsI16)) as i16\n+        fn read_i16(&mut self) -> DecodeResult<i16> {\n+            Ok(doc_as_u16(try!(self.next_doc(EsI16))) as i16)\n         }\n-        fn read_i8 (&mut self) -> i8 {\n-            doc_as_u8(self.next_doc(EsI8 )) as i8\n+        fn read_i8 (&mut self) -> DecodeResult<i8> {\n+            Ok(doc_as_u8(try!(self.next_doc(EsI8 ))) as i8)\n         }\n-        fn read_int(&mut self) -> int {\n-            let v = doc_as_u64(self.next_doc(EsInt)) as i64;\n+        fn read_int(&mut self) -> DecodeResult<int> {\n+            let v = doc_as_u64(try!(self.next_doc(EsInt))) as i64;\n             if v > (int::MAX as i64) || v < (int::MIN as i64) {\n                 debug!(\"FIXME \\\\#6122: Removing this makes this function miscompile\");\n-                fail!(\"int {} out of range for this architecture\", v);\n+                Err(IntTooBig(v as uint))\n+            } else {\n+                Ok(v as int)\n             }\n-            v as int\n         }\n \n-        fn read_bool(&mut self) -> bool {\n-            doc_as_u8(self.next_doc(EsBool)) != 0\n+        fn read_bool(&mut self) -> DecodeResult<bool> {\n+            Ok(doc_as_u8(try!(self.next_doc(EsBool))) != 0)\n         }\n \n-        fn read_f64(&mut self) -> f64 {\n-            let bits = doc_as_u64(self.next_doc(EsF64));\n-            unsafe { transmute(bits) }\n+        fn read_f64(&mut self) -> DecodeResult<f64> {\n+            let bits = doc_as_u64(try!(self.next_doc(EsF64)));\n+            Ok(unsafe { transmute(bits) })\n         }\n-        fn read_f32(&mut self) -> f32 {\n-            let bits = doc_as_u32(self.next_doc(EsF32));\n-            unsafe { transmute(bits) }\n+        fn read_f32(&mut self) -> DecodeResult<f32> {\n+            let bits = doc_as_u32(try!(self.next_doc(EsF32)));\n+            Ok(unsafe { transmute(bits) })\n         }\n-        fn read_char(&mut self) -> char {\n-            char::from_u32(doc_as_u32(self.next_doc(EsChar))).unwrap()\n+        fn read_char(&mut self) -> DecodeResult<char> {\n+            Ok(char::from_u32(doc_as_u32(try!(self.next_doc(EsChar)))).unwrap())\n         }\n-        fn read_str(&mut self) -> ~str {\n-            self.next_doc(EsStr).as_str()\n+        fn read_str(&mut self) -> DecodeResult<~str> {\n+            Ok(try!(self.next_doc(EsStr)).as_str())\n         }\n \n         // Compound types:\n-        fn read_enum<T>(&mut self, name: &str, f: |&mut Decoder<'doc>| -> T) -> T {\n+        fn read_enum<T>(&mut self,\n+                        name: &str,\n+                        f: |&mut Decoder<'doc>| -> DecodeResult<T>) -> DecodeResult<T> {\n             debug!(\"read_enum({})\", name);\n-            self._check_label(name);\n+            try!(self._check_label(name));\n \n-            let doc = self.next_doc(EsEnum);\n+            let doc = try!(self.next_doc(EsEnum));\n \n             let (old_parent, old_pos) = (self.parent, self.pos);\n             self.parent = doc;\n             self.pos = self.parent.start;\n \n-            let result = f(self);\n+            let result = try!(f(self));\n \n             self.parent = old_parent;\n             self.pos = old_pos;\n-            result\n+            Ok(result)\n         }\n \n         fn read_enum_variant<T>(&mut self,\n                                 _: &[&str],\n-                                f: |&mut Decoder<'doc>, uint| -> T)\n-                                -> T {\n+                                f: |&mut Decoder<'doc>, uint| -> DecodeResult<T>)\n+                                -> DecodeResult<T> {\n             debug!(\"read_enum_variant()\");\n-            let idx = self._next_uint(EsEnumVid);\n+            let idx = try!(self._next_uint(EsEnumVid));\n             debug!(\"  idx={}\", idx);\n \n-            let doc = self.next_doc(EsEnumBody);\n+            let doc = try!(self.next_doc(EsEnumBody));\n \n             let (old_parent, old_pos) = (self.parent, self.pos);\n             self.parent = doc;\n             self.pos = self.parent.start;\n \n-            let result = f(self, idx);\n+            let result = try!(f(self, idx));\n \n             self.parent = old_parent;\n             self.pos = old_pos;\n-            result\n+            Ok(result)\n         }\n \n         fn read_enum_variant_arg<T>(&mut self,\n                                     idx: uint,\n-                                    f: |&mut Decoder<'doc>| -> T) -> T {\n+                                    f: |&mut Decoder<'doc>| -> DecodeResult<T>) -> DecodeResult<T> {\n             debug!(\"read_enum_variant_arg(idx={})\", idx);\n             f(self)\n         }\n \n         fn read_enum_struct_variant<T>(&mut self,\n                                        _: &[&str],\n-                                       f: |&mut Decoder<'doc>, uint| -> T)\n-                                       -> T {\n+                                       f: |&mut Decoder<'doc>, uint| -> DecodeResult<T>)\n+                                       -> DecodeResult<T> {\n             debug!(\"read_enum_struct_variant()\");\n-            let idx = self._next_uint(EsEnumVid);\n+            let idx = try!(self._next_uint(EsEnumVid));\n             debug!(\"  idx={}\", idx);\n \n-            let doc = self.next_doc(EsEnumBody);\n+            let doc = try!(self.next_doc(EsEnumBody));\n \n             let (old_parent, old_pos) = (self.parent, self.pos);\n             self.parent = doc;\n             self.pos = self.parent.start;\n \n-            let result = f(self, idx);\n+            let result = try!(f(self, idx));\n \n             self.parent = old_parent;\n             self.pos = old_pos;\n-            result\n+            Ok(result)\n         }\n \n         fn read_enum_struct_variant_field<T>(&mut self,\n                                              name: &str,\n                                              idx: uint,\n-                                             f: |&mut Decoder<'doc>| -> T)\n-                                             -> T {\n+                                             f: |&mut Decoder<'doc>| -> DecodeResult<T>)\n+                                             -> DecodeResult<T> {\n             debug!(\"read_enum_struct_variant_arg(name={}, idx={})\", name, idx);\n             f(self)\n         }\n \n         fn read_struct<T>(&mut self,\n                           name: &str,\n                           _: uint,\n-                          f: |&mut Decoder<'doc>| -> T)\n-                          -> T {\n+                          f: |&mut Decoder<'doc>| -> DecodeResult<T>)\n+                          -> DecodeResult<T> {\n             debug!(\"read_struct(name={})\", name);\n             f(self)\n         }\n \n         fn read_struct_field<T>(&mut self,\n                                 name: &str,\n                                 idx: uint,\n-                                f: |&mut Decoder<'doc>| -> T)\n-                                -> T {\n+                                f: |&mut Decoder<'doc>| -> DecodeResult<T>)\n+                                -> DecodeResult<T> {\n             debug!(\"read_struct_field(name={}, idx={})\", name, idx);\n-            self._check_label(name);\n+            try!(self._check_label(name));\n             f(self)\n         }\n \n-        fn read_tuple<T>(&mut self, f: |&mut Decoder<'doc>, uint| -> T) -> T {\n+        fn read_tuple<T>(&mut self,\n+                         f: |&mut Decoder<'doc>, uint| -> DecodeResult<T>) -> DecodeResult<T> {\n             debug!(\"read_tuple()\");\n             self.read_seq(f)\n         }\n \n-        fn read_tuple_arg<T>(&mut self, idx: uint, f: |&mut Decoder<'doc>| -> T)\n-                             -> T {\n+        fn read_tuple_arg<T>(&mut self, idx: uint, f: |&mut Decoder<'doc>| -> DecodeResult<T>)\n+                             -> DecodeResult<T> {\n             debug!(\"read_tuple_arg(idx={})\", idx);\n             self.read_seq_elt(idx, f)\n         }\n \n         fn read_tuple_struct<T>(&mut self,\n                                 name: &str,\n-                                f: |&mut Decoder<'doc>, uint| -> T)\n-                                -> T {\n+                                f: |&mut Decoder<'doc>, uint| -> DecodeResult<T>)\n+                                -> DecodeResult<T> {\n             debug!(\"read_tuple_struct(name={})\", name);\n             self.read_tuple(f)\n         }\n \n         fn read_tuple_struct_arg<T>(&mut self,\n                                     idx: uint,\n-                                    f: |&mut Decoder<'doc>| -> T)\n-                                    -> T {\n+                                    f: |&mut Decoder<'doc>| -> DecodeResult<T>)\n+                                    -> DecodeResult<T> {\n             debug!(\"read_tuple_struct_arg(idx={})\", idx);\n             self.read_tuple_arg(idx, f)\n         }\n \n-        fn read_option<T>(&mut self, f: |&mut Decoder<'doc>, bool| -> T) -> T {\n+        fn read_option<T>(&mut self,\n+                          f: |&mut Decoder<'doc>, bool| -> DecodeResult<T>) -> DecodeResult<T> {\n             debug!(\"read_option()\");\n             self.read_enum(\"Option\", |this| {\n                 this.read_enum_variant([\"None\", \"Some\"], |this, idx| {\n                     match idx {\n                         0 => f(this, false),\n                         1 => f(this, true),\n-                        _ => fail!(),\n+                        _ => Err(Expected(format!(\"Expected None or Some\"))),\n                     }\n                 })\n             })\n         }\n \n-        fn read_seq<T>(&mut self, f: |&mut Decoder<'doc>, uint| -> T) -> T {\n+        fn read_seq<T>(&mut self,\n+                       f: |&mut Decoder<'doc>, uint| -> DecodeResult<T>) -> DecodeResult<T> {\n             debug!(\"read_seq()\");\n             self.push_doc(EsVec, |d| {\n-                let len = d._next_uint(EsVecLen);\n+                let len = try!(d._next_uint(EsVecLen));\n                 debug!(\"  len={}\", len);\n                 f(d, len)\n             })\n         }\n \n-        fn read_seq_elt<T>(&mut self, idx: uint, f: |&mut Decoder<'doc>| -> T)\n-                           -> T {\n+        fn read_seq_elt<T>(&mut self, idx: uint, f: |&mut Decoder<'doc>| -> DecodeResult<T>)\n+                           -> DecodeResult<T> {\n             debug!(\"read_seq_elt(idx={})\", idx);\n             self.push_doc(EsVecElt, f)\n         }\n \n-        fn read_map<T>(&mut self, f: |&mut Decoder<'doc>, uint| -> T) -> T {\n+        fn read_map<T>(&mut self,\n+                       f: |&mut Decoder<'doc>, uint| -> DecodeResult<T>) -> DecodeResult<T> {\n             debug!(\"read_map()\");\n             self.push_doc(EsMap, |d| {\n-                let len = d._next_uint(EsMapLen);\n+                let len = try!(d._next_uint(EsMapLen));\n                 debug!(\"  len={}\", len);\n                 f(d, len)\n             })\n         }\n \n-        fn read_map_elt_key<T>(&mut self, idx: uint, f: |&mut Decoder<'doc>| -> T)\n-                               -> T {\n+        fn read_map_elt_key<T>(&mut self, idx: uint, f: |&mut Decoder<'doc>| -> DecodeResult<T>)\n+                               -> DecodeResult<T> {\n             debug!(\"read_map_elt_key(idx={})\", idx);\n             self.push_doc(EsMapKey, f)\n         }\n \n-        fn read_map_elt_val<T>(&mut self, idx: uint, f: |&mut Decoder<'doc>| -> T)\n-                               -> T {\n+        fn read_map_elt_val<T>(&mut self, idx: uint, f: |&mut Decoder<'doc>| -> DecodeResult<T>)\n+                               -> DecodeResult<T> {\n             debug!(\"read_map_elt_val(idx={})\", idx);\n             self.push_doc(EsMapVal, f)\n         }\n@@ -593,7 +621,6 @@ pub mod writer {\n     use std::clone::Clone;\n     use std::io;\n     use std::io::{Writer, Seek};\n-    use std::io::MemWriter;\n     use std::io::extensions::u64_to_be_bytes;\n \n     use super::{ EsVec, EsMap, EsEnum, EsVecLen, EsVecElt, EsMapLen, EsMapKey,\n@@ -603,150 +630,153 @@ pub mod writer {\n \n     use serialize;\n \n+\n+    pub type EncodeResult = io::IoResult<()>;\n+\n     // ebml writing\n-    pub struct Encoder<'a> {\n-        // FIXME(#5665): this should take a trait object. Note that if you\n-        //               delete this comment you should consider removing the\n-        //               unwrap()'s below of the results of the calls to\n-        //               write(). We're guaranteed that writing into a MemWriter\n-        //               won't fail, but this is not true for all I/O streams in\n-        //               general.\n-        writer: &'a mut MemWriter,\n+    pub struct Encoder<'a, W> {\n+        writer: &'a mut W,\n         priv size_positions: ~[uint],\n-        last_error: io::IoResult<()>,\n     }\n \n-    fn write_sized_vuint(w: &mut MemWriter, n: uint, size: uint) {\n+    fn write_sized_vuint<W: Writer>(w: &mut W, n: uint, size: uint) -> EncodeResult {\n         match size {\n             1u => w.write(&[0x80u8 | (n as u8)]),\n             2u => w.write(&[0x40u8 | ((n >> 8_u) as u8), n as u8]),\n             3u => w.write(&[0x20u8 | ((n >> 16_u) as u8), (n >> 8_u) as u8,\n                             n as u8]),\n             4u => w.write(&[0x10u8 | ((n >> 24_u) as u8), (n >> 16_u) as u8,\n                             (n >> 8_u) as u8, n as u8]),\n-            _ => fail!(\"vint to write too big: {}\", n)\n-        }.unwrap()\n+            _ => Err(io::IoError {\n+                kind: io::OtherIoError,\n+                desc: \"int too big\",\n+                detail: Some(format!(\"{}\", n))\n+            })\n+        }\n     }\n \n-    fn write_vuint(w: &mut MemWriter, n: uint) {\n-        if n < 0x7f_u { write_sized_vuint(w, n, 1u); return; }\n-        if n < 0x4000_u { write_sized_vuint(w, n, 2u); return; }\n-        if n < 0x200000_u { write_sized_vuint(w, n, 3u); return; }\n-        if n < 0x10000000_u { write_sized_vuint(w, n, 4u); return; }\n-        fail!(\"vint to write too big: {}\", n);\n+    fn write_vuint<W: Writer>(w: &mut W, n: uint) -> EncodeResult {\n+        if n < 0x7f_u { return write_sized_vuint(w, n, 1u); }\n+        if n < 0x4000_u { return write_sized_vuint(w, n, 2u); }\n+        if n < 0x200000_u { return write_sized_vuint(w, n, 3u); }\n+        if n < 0x10000000_u { return write_sized_vuint(w, n, 4u); }\n+        Err(io::IoError {\n+            kind: io::OtherIoError,\n+            desc: \"int too big\",\n+            detail: Some(format!(\"{}\", n))\n+        })\n     }\n \n-    pub fn Encoder<'a>(w: &'a mut MemWriter) -> Encoder<'a> {\n+    pub fn Encoder<'a, W: Writer + Seek>(w: &'a mut W) -> Encoder<'a, W> {\n         let size_positions: ~[uint] = ~[];\n         Encoder {\n             writer: w,\n             size_positions: size_positions,\n-            last_error: Ok(()),\n         }\n     }\n \n     // FIXME (#2741): Provide a function to write the standard ebml header.\n-    impl<'a> Encoder<'a> {\n+    impl<'a, W: Writer + Seek> Encoder<'a, W> {\n         /// FIXME(pcwalton): Workaround for badness in trans. DO NOT USE ME.\n-        pub unsafe fn unsafe_clone(&self) -> Encoder<'a> {\n+        pub unsafe fn unsafe_clone(&self) -> Encoder<'a, W> {\n             Encoder {\n                 writer: cast::transmute_copy(&self.writer),\n                 size_positions: self.size_positions.clone(),\n-                last_error: Ok(()),\n             }\n         }\n \n-        pub fn start_tag(&mut self, tag_id: uint) {\n+        pub fn start_tag(&mut self, tag_id: uint) -> EncodeResult {\n             debug!(\"Start tag {}\", tag_id);\n \n             // Write the enum ID:\n-            write_vuint(self.writer, tag_id);\n+            try!(write_vuint(self.writer, tag_id));\n \n             // Write a placeholder four-byte size.\n             self.size_positions.push(try!(self.writer.tell()) as uint);\n             let zeroes: &[u8] = &[0u8, 0u8, 0u8, 0u8];\n-            try!(self.writer.write(zeroes));\n+            self.writer.write(zeroes)\n         }\n \n-        pub fn end_tag(&mut self) {\n+        pub fn end_tag(&mut self) -> EncodeResult {\n             let last_size_pos = self.size_positions.pop().unwrap();\n             let cur_pos = try!(self.writer.tell());\n             try!(self.writer.seek(last_size_pos as i64, io::SeekSet));\n             let size = cur_pos as uint - last_size_pos - 4;\n-            write_sized_vuint(self.writer, size, 4u);\n-            try!(self.writer.seek(cur_pos as i64, io::SeekSet));\n+            try!(write_sized_vuint(self.writer, size, 4u));\n+            let r = try!(self.writer.seek(cur_pos as i64, io::SeekSet));\n \n             debug!(\"End tag (size = {})\", size);\n+            Ok(r)\n         }\n \n-        pub fn wr_tag(&mut self, tag_id: uint, blk: ||) {\n-            self.start_tag(tag_id);\n-            blk();\n-            self.end_tag();\n+        pub fn wr_tag(&mut self, tag_id: uint, blk: || -> EncodeResult) -> EncodeResult {\n+            try!(self.start_tag(tag_id));\n+            try!(blk());\n+            self.end_tag()\n         }\n \n-        pub fn wr_tagged_bytes(&mut self, tag_id: uint, b: &[u8]) {\n-            write_vuint(self.writer, tag_id);\n-            write_vuint(self.writer, b.len());\n-            self.writer.write(b).unwrap();\n+        pub fn wr_tagged_bytes(&mut self, tag_id: uint, b: &[u8]) -> EncodeResult {\n+            try!(write_vuint(self.writer, tag_id));\n+            try!(write_vuint(self.writer, b.len()));\n+            self.writer.write(b)\n         }\n \n-        pub fn wr_tagged_u64(&mut self, tag_id: uint, v: u64) {\n+        pub fn wr_tagged_u64(&mut self, tag_id: uint, v: u64) -> EncodeResult {\n             u64_to_be_bytes(v, 8u, |v| {\n-                self.wr_tagged_bytes(tag_id, v);\n+                self.wr_tagged_bytes(tag_id, v)\n             })\n         }\n \n-        pub fn wr_tagged_u32(&mut self, tag_id: uint, v: u32) {\n+        pub fn wr_tagged_u32(&mut self, tag_id: uint, v: u32)  -> EncodeResult{\n             u64_to_be_bytes(v as u64, 4u, |v| {\n-                self.wr_tagged_bytes(tag_id, v);\n+                self.wr_tagged_bytes(tag_id, v)\n             })\n         }\n \n-        pub fn wr_tagged_u16(&mut self, tag_id: uint, v: u16) {\n+        pub fn wr_tagged_u16(&mut self, tag_id: uint, v: u16) -> EncodeResult {\n             u64_to_be_bytes(v as u64, 2u, |v| {\n-                self.wr_tagged_bytes(tag_id, v);\n+                self.wr_tagged_bytes(tag_id, v)\n             })\n         }\n \n-        pub fn wr_tagged_u8(&mut self, tag_id: uint, v: u8) {\n-            self.wr_tagged_bytes(tag_id, &[v]);\n+        pub fn wr_tagged_u8(&mut self, tag_id: uint, v: u8) -> EncodeResult {\n+            self.wr_tagged_bytes(tag_id, &[v])\n         }\n \n-        pub fn wr_tagged_i64(&mut self, tag_id: uint, v: i64) {\n+        pub fn wr_tagged_i64(&mut self, tag_id: uint, v: i64) -> EncodeResult {\n             u64_to_be_bytes(v as u64, 8u, |v| {\n-                self.wr_tagged_bytes(tag_id, v);\n+                self.wr_tagged_bytes(tag_id, v)\n             })\n         }\n \n-        pub fn wr_tagged_i32(&mut self, tag_id: uint, v: i32) {\n+        pub fn wr_tagged_i32(&mut self, tag_id: uint, v: i32) -> EncodeResult {\n             u64_to_be_bytes(v as u64, 4u, |v| {\n-                self.wr_tagged_bytes(tag_id, v);\n+                self.wr_tagged_bytes(tag_id, v)\n             })\n         }\n \n-        pub fn wr_tagged_i16(&mut self, tag_id: uint, v: i16) {\n+        pub fn wr_tagged_i16(&mut self, tag_id: uint, v: i16) -> EncodeResult {\n             u64_to_be_bytes(v as u64, 2u, |v| {\n-                self.wr_tagged_bytes(tag_id, v);\n+                self.wr_tagged_bytes(tag_id, v)\n             })\n         }\n \n-        pub fn wr_tagged_i8(&mut self, tag_id: uint, v: i8) {\n-            self.wr_tagged_bytes(tag_id, &[v as u8]);\n+        pub fn wr_tagged_i8(&mut self, tag_id: uint, v: i8) -> EncodeResult {\n+            self.wr_tagged_bytes(tag_id, &[v as u8])\n         }\n \n-        pub fn wr_tagged_str(&mut self, tag_id: uint, v: &str) {\n-            self.wr_tagged_bytes(tag_id, v.as_bytes());\n+        pub fn wr_tagged_str(&mut self, tag_id: uint, v: &str) -> EncodeResult {\n+            self.wr_tagged_bytes(tag_id, v.as_bytes())\n         }\n \n-        pub fn wr_bytes(&mut self, b: &[u8]) {\n+        pub fn wr_bytes(&mut self, b: &[u8]) -> EncodeResult {\n             debug!(\"Write {} bytes\", b.len());\n-            self.writer.write(b).unwrap();\n+            self.writer.write(b)\n         }\n \n-        pub fn wr_str(&mut self, s: &str) {\n+        pub fn wr_str(&mut self, s: &str) -> EncodeResult {\n             debug!(\"Write str: {}\", s);\n-            self.writer.write(s.as_bytes()).unwrap();\n+            self.writer.write(s.as_bytes())\n         }\n     }\n \n@@ -757,196 +787,225 @@ pub mod writer {\n     // Totally lame approach.\n     static DEBUG: bool = true;\n \n-    impl<'a> Encoder<'a> {\n+    impl<'a, W: Writer + Seek> Encoder<'a, W> {\n         // used internally to emit things like the vector length and so on\n-        fn _emit_tagged_uint(&mut self, t: EbmlEncoderTag, v: uint) {\n+        fn _emit_tagged_uint(&mut self, t: EbmlEncoderTag, v: uint) -> EncodeResult {\n             assert!(v <= 0xFFFF_FFFF_u);\n-            self.wr_tagged_u32(t as uint, v as u32);\n+            self.wr_tagged_u32(t as uint, v as u32)\n         }\n \n-        fn _emit_label(&mut self, label: &str) {\n+        fn _emit_label(&mut self, label: &str) -> EncodeResult {\n             // There are various strings that we have access to, such as\n             // the name of a record field, which do not actually appear in\n             // the encoded EBML (normally).  This is just for\n             // efficiency.  When debugging, though, we can emit such\n             // labels and then they will be checked by decoder to\n             // try and check failures more quickly.\n             if DEBUG { self.wr_tagged_str(EsLabel as uint, label) }\n+            else { Ok(()) }\n         }\n \n-        pub fn emit_opaque(&mut self, f: |&mut Encoder|) {\n-            self.start_tag(EsOpaque as uint);\n-            f(self);\n-            self.end_tag();\n+        pub fn emit_opaque(&mut self, f: |&mut Encoder<W>| -> EncodeResult) -> EncodeResult {\n+            try!(self.start_tag(EsOpaque as uint));\n+            try!(f(self));\n+            self.end_tag()\n         }\n     }\n \n-    impl<'a> serialize::Encoder for Encoder<'a> {\n-        fn emit_nil(&mut self) {}\n+    impl<'a, W: Writer + Seek> serialize::Encoder<io::IoError> for Encoder<'a, W> {\n+        fn emit_nil(&mut self) -> EncodeResult {\n+            Ok(())\n+        }\n \n-        fn emit_uint(&mut self, v: uint) {\n-            self.wr_tagged_u64(EsUint as uint, v as u64);\n+        fn emit_uint(&mut self, v: uint) -> EncodeResult {\n+            self.wr_tagged_u64(EsUint as uint, v as u64)\n         }\n-        fn emit_u64(&mut self, v: u64) {\n-            self.wr_tagged_u64(EsU64 as uint, v);\n+        fn emit_u64(&mut self, v: u64) -> EncodeResult {\n+            self.wr_tagged_u64(EsU64 as uint, v)\n         }\n-        fn emit_u32(&mut self, v: u32) {\n-            self.wr_tagged_u32(EsU32 as uint, v);\n+        fn emit_u32(&mut self, v: u32) -> EncodeResult {\n+            self.wr_tagged_u32(EsU32 as uint, v)\n         }\n-        fn emit_u16(&mut self, v: u16) {\n-            self.wr_tagged_u16(EsU16 as uint, v);\n+        fn emit_u16(&mut self, v: u16) -> EncodeResult {\n+            self.wr_tagged_u16(EsU16 as uint, v)\n         }\n-        fn emit_u8(&mut self, v: u8) {\n-            self.wr_tagged_u8(EsU8 as uint, v);\n+        fn emit_u8(&mut self, v: u8) -> EncodeResult {\n+            self.wr_tagged_u8(EsU8 as uint, v)\n         }\n \n-        fn emit_int(&mut self, v: int) {\n-            self.wr_tagged_i64(EsInt as uint, v as i64);\n+        fn emit_int(&mut self, v: int) -> EncodeResult {\n+            self.wr_tagged_i64(EsInt as uint, v as i64)\n         }\n-        fn emit_i64(&mut self, v: i64) {\n-            self.wr_tagged_i64(EsI64 as uint, v);\n+        fn emit_i64(&mut self, v: i64) -> EncodeResult {\n+            self.wr_tagged_i64(EsI64 as uint, v)\n         }\n-        fn emit_i32(&mut self, v: i32) {\n-            self.wr_tagged_i32(EsI32 as uint, v);\n+        fn emit_i32(&mut self, v: i32) -> EncodeResult {\n+            self.wr_tagged_i32(EsI32 as uint, v)\n         }\n-        fn emit_i16(&mut self, v: i16) {\n-            self.wr_tagged_i16(EsI16 as uint, v);\n+        fn emit_i16(&mut self, v: i16) -> EncodeResult {\n+            self.wr_tagged_i16(EsI16 as uint, v)\n         }\n-        fn emit_i8(&mut self, v: i8) {\n-            self.wr_tagged_i8(EsI8 as uint, v);\n+        fn emit_i8(&mut self, v: i8) -> EncodeResult {\n+            self.wr_tagged_i8(EsI8 as uint, v)\n         }\n \n-        fn emit_bool(&mut self, v: bool) {\n+        fn emit_bool(&mut self, v: bool) -> EncodeResult {\n             self.wr_tagged_u8(EsBool as uint, v as u8)\n         }\n \n-        fn emit_f64(&mut self, v: f64) {\n+        fn emit_f64(&mut self, v: f64) -> EncodeResult {\n             let bits = unsafe { cast::transmute(v) };\n-            self.wr_tagged_u64(EsF64 as uint, bits);\n+            self.wr_tagged_u64(EsF64 as uint, bits)\n         }\n-        fn emit_f32(&mut self, v: f32) {\n+        fn emit_f32(&mut self, v: f32) -> EncodeResult {\n             let bits = unsafe { cast::transmute(v) };\n-            self.wr_tagged_u32(EsF32 as uint, bits);\n+            self.wr_tagged_u32(EsF32 as uint, bits)\n         }\n-        fn emit_char(&mut self, v: char) {\n-            self.wr_tagged_u32(EsChar as uint, v as u32);\n+        fn emit_char(&mut self, v: char) -> EncodeResult {\n+            self.wr_tagged_u32(EsChar as uint, v as u32)\n         }\n \n-        fn emit_str(&mut self, v: &str) {\n+        fn emit_str(&mut self, v: &str) -> EncodeResult {\n             self.wr_tagged_str(EsStr as uint, v)\n         }\n \n-        fn emit_enum(&mut self, name: &str, f: |&mut Encoder<'a>|) {\n-            self._emit_label(name);\n-            self.start_tag(EsEnum as uint);\n-            f(self);\n-            self.end_tag();\n+        fn emit_enum(&mut self,\n+                     name: &str,\n+                     f: |&mut Encoder<'a, W>| -> EncodeResult) -> EncodeResult {\n+            try!(self._emit_label(name));\n+            try!(self.start_tag(EsEnum as uint));\n+            try!(f(self));\n+            self.end_tag()\n         }\n \n         fn emit_enum_variant(&mut self,\n                              _: &str,\n                              v_id: uint,\n                              _: uint,\n-                             f: |&mut Encoder<'a>|) {\n-            self._emit_tagged_uint(EsEnumVid, v_id);\n-            self.start_tag(EsEnumBody as uint);\n-            f(self);\n-            self.end_tag();\n+                             f: |&mut Encoder<'a, W>| -> EncodeResult) -> EncodeResult {\n+            try!(self._emit_tagged_uint(EsEnumVid, v_id));\n+            try!(self.start_tag(EsEnumBody as uint));\n+            try!(f(self));\n+            self.end_tag()\n         }\n \n-        fn emit_enum_variant_arg(&mut self, _: uint, f: |&mut Encoder<'a>|) {\n+        fn emit_enum_variant_arg(&mut self,\n+                                 _: uint,\n+                                 f: |&mut Encoder<'a, W>| -> EncodeResult) -> EncodeResult {\n             f(self)\n         }\n \n         fn emit_enum_struct_variant(&mut self,\n                                     v_name: &str,\n                                     v_id: uint,\n                                     cnt: uint,\n-                                    f: |&mut Encoder<'a>|) {\n+                                    f: |&mut Encoder<'a, W>| -> EncodeResult) -> EncodeResult {\n             self.emit_enum_variant(v_name, v_id, cnt, f)\n         }\n \n         fn emit_enum_struct_variant_field(&mut self,\n                                           _: &str,\n                                           idx: uint,\n-                                          f: |&mut Encoder<'a>|) {\n+                                          f: |&mut Encoder<'a, W>| -> EncodeResult)\n+            -> EncodeResult {\n             self.emit_enum_variant_arg(idx, f)\n         }\n \n         fn emit_struct(&mut self,\n                        _: &str,\n                        _len: uint,\n-                       f: |&mut Encoder<'a>|) {\n+                       f: |&mut Encoder<'a, W>| -> EncodeResult) -> EncodeResult {\n             f(self)\n         }\n \n         fn emit_struct_field(&mut self,\n                              name: &str,\n                              _: uint,\n-                             f: |&mut Encoder<'a>|) {\n-            self._emit_label(name);\n+                             f: |&mut Encoder<'a, W>| -> EncodeResult) -> EncodeResult {\n+            try!(self._emit_label(name));\n             f(self)\n         }\n \n-        fn emit_tuple(&mut self, len: uint, f: |&mut Encoder<'a>|) {\n+        fn emit_tuple(&mut self,\n+                      len: uint,\n+                      f: |&mut Encoder<'a, W>| -> EncodeResult) -> EncodeResult {\n             self.emit_seq(len, f)\n         }\n-        fn emit_tuple_arg(&mut self, idx: uint, f: |&mut Encoder<'a>|) {\n+        fn emit_tuple_arg(&mut self,\n+                          idx: uint,\n+                          f: |&mut Encoder<'a, W>| -> EncodeResult) -> EncodeResult {\n             self.emit_seq_elt(idx, f)\n         }\n \n         fn emit_tuple_struct(&mut self,\n                              _: &str,\n                              len: uint,\n-                             f: |&mut Encoder<'a>|) {\n+                             f: |&mut Encoder<'a, W>| -> EncodeResult) -> EncodeResult {\n             self.emit_seq(len, f)\n         }\n         fn emit_tuple_struct_arg(&mut self,\n                                  idx: uint,\n-                                 f: |&mut Encoder<'a>|) {\n+                                 f: |&mut Encoder<'a, W>| -> EncodeResult) -> EncodeResult {\n             self.emit_seq_elt(idx, f)\n         }\n \n-        fn emit_option(&mut self, f: |&mut Encoder<'a>|) {\n-            self.emit_enum(\"Option\", f);\n+        fn emit_option(&mut self,\n+                       f: |&mut Encoder<'a, W>| -> EncodeResult) -> EncodeResult {\n+            self.emit_enum(\"Option\", f)\n         }\n-        fn emit_option_none(&mut self) {\n-            self.emit_enum_variant(\"None\", 0, 0, |_| ())\n+        fn emit_option_none(&mut self) -> EncodeResult {\n+            self.emit_enum_variant(\"None\", 0, 0, |_| Ok(()))\n         }\n-        fn emit_option_some(&mut self, f: |&mut Encoder<'a>|) {\n+        fn emit_option_some(&mut self,\n+                            f: |&mut Encoder<'a, W>| -> EncodeResult) -> EncodeResult {\n+\n             self.emit_enum_variant(\"Some\", 1, 1, f)\n         }\n \n-        fn emit_seq(&mut self, len: uint, f: |&mut Encoder<'a>|) {\n-            self.start_tag(EsVec as uint);\n-            self._emit_tagged_uint(EsVecLen, len);\n-            f(self);\n-            self.end_tag();\n+        fn emit_seq(&mut self,\n+                    len: uint,\n+                    f: |&mut Encoder<'a, W>| -> EncodeResult) -> EncodeResult {\n+\n+            try!(self.start_tag(EsVec as uint));\n+            try!(self._emit_tagged_uint(EsVecLen, len));\n+            try!(f(self));\n+            self.end_tag()\n         }\n \n-        fn emit_seq_elt(&mut self, _idx: uint, f: |&mut Encoder<'a>|) {\n-            self.start_tag(EsVecElt as uint);\n-            f(self);\n-            self.end_tag();\n+        fn emit_seq_elt(&mut self,\n+                        _idx: uint,\n+                        f: |&mut Encoder<'a, W>| -> EncodeResult) -> EncodeResult {\n+\n+            try!(self.start_tag(EsVecElt as uint));\n+            try!(f(self));\n+            self.end_tag()\n         }\n \n-        fn emit_map(&mut self, len: uint, f: |&mut Encoder<'a>|) {\n-            self.start_tag(EsMap as uint);\n-            self._emit_tagged_uint(EsMapLen, len);\n-            f(self);\n-            self.end_tag();\n+        fn emit_map(&mut self,\n+                    len: uint,\n+                    f: |&mut Encoder<'a, W>| -> EncodeResult) -> EncodeResult {\n+\n+            try!(self.start_tag(EsMap as uint));\n+            try!(self._emit_tagged_uint(EsMapLen, len));\n+            try!(f(self));\n+            self.end_tag()\n         }\n \n-        fn emit_map_elt_key(&mut self, _idx: uint, f: |&mut Encoder<'a>|) {\n-            self.start_tag(EsMapKey as uint);\n-            f(self);\n-            self.end_tag();\n+        fn emit_map_elt_key(&mut self,\n+                            _idx: uint,\n+                            f: |&mut Encoder<'a, W>| -> EncodeResult) -> EncodeResult {\n+\n+            try!(self.start_tag(EsMapKey as uint));\n+            try!(f(self));\n+            self.end_tag()\n         }\n \n-        fn emit_map_elt_val(&mut self, _idx: uint, f: |&mut Encoder<'a>|) {\n-            self.start_tag(EsMapVal as uint);\n-            f(self);\n-            self.end_tag();\n+        fn emit_map_elt_val(&mut self,\n+                            _idx: uint,\n+                            f: |&mut Encoder<'a, W>| -> EncodeResult) -> EncodeResult {\n+            try!(self.start_tag(EsMapVal as uint));\n+            try!(f(self));\n+            self.end_tag()\n         }\n     }\n }\n@@ -979,34 +1038,34 @@ mod tests {\n         let mut res: reader::Res;\n \n         // Class A\n-        res = reader::vuint_at(data, 0);\n+        res = reader::vuint_at(data, 0).unwrap();\n         assert_eq!(res.val, 0);\n         assert_eq!(res.next, 1);\n-        res = reader::vuint_at(data, res.next);\n+        res = reader::vuint_at(data, res.next).unwrap();\n         assert_eq!(res.val, (1 << 7) - 1);\n         assert_eq!(res.next, 2);\n \n         // Class B\n-        res = reader::vuint_at(data, res.next);\n+        res = reader::vuint_at(data, res.next).unwrap();\n         assert_eq!(res.val, 0);\n         assert_eq!(res.next, 4);\n-        res = reader::vuint_at(data, res.next);\n+        res = reader::vuint_at(data, res.next).unwrap();\n         assert_eq!(res.val, (1 << 14) - 1);\n         assert_eq!(res.next, 6);\n \n         // Class C\n-        res = reader::vuint_at(data, res.next);\n+        res = reader::vuint_at(data, res.next).unwrap();\n         assert_eq!(res.val, 0);\n         assert_eq!(res.next, 9);\n-        res = reader::vuint_at(data, res.next);\n+        res = reader::vuint_at(data, res.next).unwrap();\n         assert_eq!(res.val, (1 << 21) - 1);\n         assert_eq!(res.next, 12);\n \n         // Class D\n-        res = reader::vuint_at(data, res.next);\n+        res = reader::vuint_at(data, res.next).unwrap();\n         assert_eq!(res.val, 0);\n         assert_eq!(res.next, 16);\n-        res = reader::vuint_at(data, res.next);\n+        res = reader::vuint_at(data, res.next).unwrap();\n         assert_eq!(res.val, (1 << 28) - 1);\n         assert_eq!(res.next, 20);\n     }\n@@ -1018,11 +1077,11 @@ mod tests {\n             let mut wr = MemWriter::new();\n             {\n                 let mut ebml_w = writer::Encoder(&mut wr);\n-                v.encode(&mut ebml_w);\n+                let _ = v.encode(&mut ebml_w);\n             }\n             let ebml_doc = reader::Doc(wr.get_ref());\n             let mut deser = reader::Decoder(ebml_doc);\n-            let v1 = Decodable::decode(&mut deser);\n+            let v1 = Decodable::decode(&mut deser).unwrap();\n             debug!(\"v1 == {:?}\", v1);\n             assert_eq!(v, v1);\n         }\n@@ -1052,7 +1111,7 @@ mod bench {\n         bh.iter(|| {\n             let mut i = 0;\n             while i < data.len() {\n-                sum += reader::vuint_at(data, i).val;\n+                sum += reader::vuint_at(data, i).unwrap().val;\n                 i += 4;\n             }\n         });\n@@ -1071,7 +1130,7 @@ mod bench {\n         bh.iter(|| {\n             let mut i = 1;\n             while i < data.len() {\n-                sum += reader::vuint_at(data, i).val;\n+                sum += reader::vuint_at(data, i).unwrap().val;\n                 i += 4;\n             }\n         });\n@@ -1091,7 +1150,7 @@ mod bench {\n         bh.iter(|| {\n             let mut i = 0;\n             while i < data.len() {\n-                sum += reader::vuint_at(data, i).val;\n+                sum += reader::vuint_at(data, i).unwrap().val;\n                 i += 4;\n             }\n         });\n@@ -1111,7 +1170,7 @@ mod bench {\n         bh.iter(|| {\n             let mut i = 1;\n             while i < data.len() {\n-                sum += reader::vuint_at(data, i).val;\n+                sum += reader::vuint_at(data, i).unwrap().val;\n                 i += 4;\n             }\n         });"}, {"sha": "1c66960672fa0d54da175bf37ed1982c08841f7d", "filename": "src/libserialize/ebml_old.rs", "status": "added", "additions": 1120, "deletions": 0, "changes": 1120, "blob_url": "https://github.com/rust-lang/rust/blob/f1739b14a1346419a4598339aee32aab07e0d12e/src%2Flibserialize%2Febml_old.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1739b14a1346419a4598339aee32aab07e0d12e/src%2Flibserialize%2Febml_old.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Febml_old.rs?ref=f1739b14a1346419a4598339aee32aab07e0d12e", "patch": "@@ -0,0 +1,1120 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[allow(missing_doc)];\n+\n+use std::str;\n+\n+macro_rules! try( ($e:expr) => (\n+    match $e { Ok(e) => e, Err(e) => { self.last_error = Err(e); return } }\n+) )\n+\n+// Simple Extensible Binary Markup Language (ebml) reader and writer on a\n+// cursor model. See the specification here:\n+//     http://www.matroska.org/technical/specs/rfc/index.html\n+\n+// Common data structures\n+#[deriving(Clone)]\n+pub struct Doc<'a> {\n+    data: &'a [u8],\n+    start: uint,\n+    end: uint,\n+}\n+\n+impl<'doc> Doc<'doc> {\n+    pub fn get<'a>(&'a self, tag: uint) -> Doc<'a> {\n+        reader::get_doc(*self, tag)\n+    }\n+\n+    pub fn as_str_slice<'a>(&'a self) -> &'a str {\n+        str::from_utf8(self.data.slice(self.start, self.end)).unwrap()\n+    }\n+\n+    pub fn as_str(&self) -> ~str {\n+        self.as_str_slice().to_owned()\n+    }\n+}\n+\n+pub struct TaggedDoc<'a> {\n+    priv tag: uint,\n+    doc: Doc<'a>,\n+}\n+\n+pub enum EbmlEncoderTag {\n+    EsUint,     // 0\n+    EsU64,      // 1\n+    EsU32,      // 2\n+    EsU16,      // 3\n+    EsU8,       // 4\n+    EsInt,      // 5\n+    EsI64,      // 6\n+    EsI32,      // 7\n+    EsI16,      // 8\n+    EsI8,       // 9\n+    EsBool,     // 10\n+    EsChar,     // 11\n+    EsStr,      // 12\n+    EsF64,      // 13\n+    EsF32,      // 14\n+    EsFloat,    // 15\n+    EsEnum,     // 16\n+    EsEnumVid,  // 17\n+    EsEnumBody, // 18\n+    EsVec,      // 19\n+    EsVecLen,   // 20\n+    EsVecElt,   // 21\n+    EsMap,      // 22\n+    EsMapLen,   // 23\n+    EsMapKey,   // 24\n+    EsMapVal,   // 25\n+\n+    EsOpaque,\n+\n+    EsLabel, // Used only when debugging\n+}\n+// --------------------------------------\n+\n+pub mod reader {\n+    use std::char;\n+\n+    use std::cast::transmute;\n+    use std::int;\n+    use std::option::{None, Option, Some};\n+    use std::io::extensions::u64_from_be_bytes;\n+\n+    use serialize;\n+\n+    use super::{ EsVec, EsMap, EsEnum, EsVecLen, EsVecElt, EsMapLen, EsMapKey,\n+        EsEnumVid, EsU64, EsU32, EsU16, EsU8, EsInt, EsI64, EsI32, EsI16, EsI8,\n+        EsBool, EsF64, EsF32, EsChar, EsStr, EsMapVal, EsEnumBody, EsUint,\n+        EsOpaque, EsLabel, EbmlEncoderTag, Doc, TaggedDoc };\n+\n+    // ebml reading\n+\n+    pub struct Res {\n+        val: uint,\n+        next: uint\n+    }\n+\n+    #[inline(never)]\n+    fn vuint_at_slow(data: &[u8], start: uint) -> Res {\n+        let a = data[start];\n+        if a & 0x80u8 != 0u8 {\n+            return Res {val: (a & 0x7fu8) as uint, next: start + 1u};\n+        }\n+        if a & 0x40u8 != 0u8 {\n+            return Res {val: ((a & 0x3fu8) as uint) << 8u |\n+                        (data[start + 1u] as uint),\n+                    next: start + 2u};\n+        }\n+        if a & 0x20u8 != 0u8 {\n+            return Res {val: ((a & 0x1fu8) as uint) << 16u |\n+                        (data[start + 1u] as uint) << 8u |\n+                        (data[start + 2u] as uint),\n+                    next: start + 3u};\n+        }\n+        if a & 0x10u8 != 0u8 {\n+            return Res {val: ((a & 0x0fu8) as uint) << 24u |\n+                        (data[start + 1u] as uint) << 16u |\n+                        (data[start + 2u] as uint) << 8u |\n+                        (data[start + 3u] as uint),\n+                    next: start + 4u};\n+        }\n+        fail!(\"vint too big\");\n+    }\n+\n+    pub fn vuint_at(data: &[u8], start: uint) -> Res {\n+        use std::mem::from_be32;\n+\n+        if data.len() - start < 4 {\n+            return vuint_at_slow(data, start);\n+        }\n+\n+        // Lookup table for parsing EBML Element IDs as per http://ebml.sourceforge.net/specs/\n+        // The Element IDs are parsed by reading a big endian u32 positioned at data[start].\n+        // Using the four most significant bits of the u32 we lookup in the table below how the\n+        // element ID should be derived from it.\n+        //\n+        // The table stores tuples (shift, mask) where shift is the number the u32 should be right\n+        // shifted with and mask is the value the right shifted value should be masked with.\n+        // If for example the most significant bit is set this means it's a class A ID and the u32\n+        // should be right shifted with 24 and masked with 0x7f. Therefore we store (24, 0x7f) at\n+        // index 0x8 - 0xF (four bit numbers where the most significant bit is set).\n+        //\n+        // By storing the number of shifts and masks in a table instead of checking in order if\n+        // the most significant bit is set, the second most significant bit is set etc. we can\n+        // replace up to three \"and+branch\" with a single table lookup which gives us a measured\n+        // speedup of around 2x on x86_64.\n+        static SHIFT_MASK_TABLE: [(u32, u32), ..16] = [\n+            (0, 0x0), (0, 0x0fffffff),\n+            (8, 0x1fffff), (8, 0x1fffff),\n+            (16, 0x3fff), (16, 0x3fff), (16, 0x3fff), (16, 0x3fff),\n+            (24, 0x7f), (24, 0x7f), (24, 0x7f), (24, 0x7f),\n+            (24, 0x7f), (24, 0x7f), (24, 0x7f), (24, 0x7f)\n+        ];\n+\n+        unsafe {\n+            let ptr = data.as_ptr().offset(start as int) as *i32;\n+            let val = from_be32(*ptr) as u32;\n+\n+            let i = (val >> 28u) as uint;\n+            let (shift, mask) = SHIFT_MASK_TABLE[i];\n+            Res {\n+                val: ((val >> shift) & mask) as uint,\n+                next: start + (((32 - shift) >> 3) as uint)\n+            }\n+        }\n+    }\n+\n+    pub fn Doc<'a>(data: &'a [u8]) -> Doc<'a> {\n+        Doc { data: data, start: 0u, end: data.len() }\n+    }\n+\n+    pub fn doc_at<'a>(data: &'a [u8], start: uint) -> TaggedDoc<'a> {\n+        let elt_tag = vuint_at(data, start);\n+        let elt_size = vuint_at(data, elt_tag.next);\n+        let end = elt_size.next + elt_size.val;\n+        TaggedDoc {\n+            tag: elt_tag.val,\n+            doc: Doc { data: data, start: elt_size.next, end: end }\n+        }\n+    }\n+\n+    pub fn maybe_get_doc<'a>(d: Doc<'a>, tg: uint) -> Option<Doc<'a>> {\n+        let mut pos = d.start;\n+        while pos < d.end {\n+            let elt_tag = vuint_at(d.data, pos);\n+            let elt_size = vuint_at(d.data, elt_tag.next);\n+            pos = elt_size.next + elt_size.val;\n+            if elt_tag.val == tg {\n+                return Some(Doc { data: d.data, start: elt_size.next,\n+                                  end: pos });\n+            }\n+        }\n+        None\n+    }\n+\n+    pub fn get_doc<'a>(d: Doc<'a>, tg: uint) -> Doc<'a> {\n+        match maybe_get_doc(d, tg) {\n+            Some(d) => d,\n+            None => {\n+                error!(\"failed to find block with tag {}\", tg);\n+                fail!();\n+            }\n+        }\n+    }\n+\n+    pub fn docs<'a>(d: Doc<'a>, it: |uint, Doc<'a>| -> bool) -> bool {\n+        let mut pos = d.start;\n+        while pos < d.end {\n+            let elt_tag = vuint_at(d.data, pos);\n+            let elt_size = vuint_at(d.data, elt_tag.next);\n+            pos = elt_size.next + elt_size.val;\n+            let doc = Doc { data: d.data, start: elt_size.next, end: pos };\n+            if !it(elt_tag.val, doc) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    pub fn tagged_docs<'a>(d: Doc<'a>, tg: uint, it: |Doc<'a>| -> bool) -> bool {\n+        let mut pos = d.start;\n+        while pos < d.end {\n+            let elt_tag = vuint_at(d.data, pos);\n+            let elt_size = vuint_at(d.data, elt_tag.next);\n+            pos = elt_size.next + elt_size.val;\n+            if elt_tag.val == tg {\n+                let doc = Doc { data: d.data, start: elt_size.next,\n+                                end: pos };\n+                if !it(doc) {\n+                    return false;\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+\n+    pub fn with_doc_data<'a, T>(d: Doc<'a>, f: |x: &'a [u8]| -> T) -> T {\n+        f(d.data.slice(d.start, d.end))\n+    }\n+\n+\n+    pub fn doc_as_u8(d: Doc) -> u8 {\n+        assert_eq!(d.end, d.start + 1u);\n+        d.data[d.start]\n+    }\n+\n+    pub fn doc_as_u16(d: Doc) -> u16 {\n+        assert_eq!(d.end, d.start + 2u);\n+        u64_from_be_bytes(d.data, d.start, 2u) as u16\n+    }\n+\n+    pub fn doc_as_u32(d: Doc) -> u32 {\n+        assert_eq!(d.end, d.start + 4u);\n+        u64_from_be_bytes(d.data, d.start, 4u) as u32\n+    }\n+\n+    pub fn doc_as_u64(d: Doc) -> u64 {\n+        assert_eq!(d.end, d.start + 8u);\n+        u64_from_be_bytes(d.data, d.start, 8u)\n+    }\n+\n+    pub fn doc_as_i8(d: Doc) -> i8 { doc_as_u8(d) as i8 }\n+    pub fn doc_as_i16(d: Doc) -> i16 { doc_as_u16(d) as i16 }\n+    pub fn doc_as_i32(d: Doc) -> i32 { doc_as_u32(d) as i32 }\n+    pub fn doc_as_i64(d: Doc) -> i64 { doc_as_u64(d) as i64 }\n+\n+    pub struct Decoder<'a> {\n+        priv parent: Doc<'a>,\n+        priv pos: uint,\n+    }\n+\n+    pub fn Decoder<'a>(d: Doc<'a>) -> Decoder<'a> {\n+        Decoder {\n+            parent: d,\n+            pos: d.start\n+        }\n+    }\n+\n+    impl<'doc> Decoder<'doc> {\n+        fn _check_label(&mut self, lbl: &str) {\n+            if self.pos < self.parent.end {\n+                let TaggedDoc { tag: r_tag, doc: r_doc } =\n+                    doc_at(self.parent.data, self.pos);\n+\n+                if r_tag == (EsLabel as uint) {\n+                    self.pos = r_doc.end;\n+                    let str = r_doc.as_str_slice();\n+                    if lbl != str {\n+                        fail!(\"Expected label {} but found {}\", lbl, str);\n+                    }\n+                }\n+            }\n+        }\n+\n+        fn next_doc(&mut self, exp_tag: EbmlEncoderTag) -> Doc<'doc> {\n+            debug!(\". next_doc(exp_tag={:?})\", exp_tag);\n+            if self.pos >= self.parent.end {\n+                fail!(\"no more documents in current node!\");\n+            }\n+            let TaggedDoc { tag: r_tag, doc: r_doc } =\n+                doc_at(self.parent.data, self.pos);\n+            debug!(\"self.parent={}-{} self.pos={} r_tag={} r_doc={}-{}\",\n+                   self.parent.start,\n+                   self.parent.end,\n+                   self.pos,\n+                   r_tag,\n+                   r_doc.start,\n+                   r_doc.end);\n+            if r_tag != (exp_tag as uint) {\n+                fail!(\"expected EBML doc with tag {:?} but found tag {:?}\",\n+                       exp_tag, r_tag);\n+            }\n+            if r_doc.end > self.parent.end {\n+                fail!(\"invalid EBML, child extends to {:#x}, parent to {:#x}\",\n+                      r_doc.end, self.parent.end);\n+            }\n+            self.pos = r_doc.end;\n+            r_doc\n+        }\n+\n+        fn push_doc<T>(&mut self, exp_tag: EbmlEncoderTag,\n+                       f: |&mut Decoder<'doc>| -> T) -> T {\n+            let d = self.next_doc(exp_tag);\n+            let old_parent = self.parent;\n+            let old_pos = self.pos;\n+            self.parent = d;\n+            self.pos = d.start;\n+            let r = f(self);\n+            self.parent = old_parent;\n+            self.pos = old_pos;\n+            r\n+        }\n+\n+        fn _next_uint(&mut self, exp_tag: EbmlEncoderTag) -> uint {\n+            let r = doc_as_u32(self.next_doc(exp_tag));\n+            debug!(\"_next_uint exp_tag={:?} result={}\", exp_tag, r);\n+            r as uint\n+        }\n+\n+        pub fn read_opaque<R>(&mut self, op: |&mut Decoder<'doc>, Doc| -> R) -> R {\n+            let doc = self.next_doc(EsOpaque);\n+\n+            let (old_parent, old_pos) = (self.parent, self.pos);\n+            self.parent = doc;\n+            self.pos = doc.start;\n+\n+            let result = op(self, doc);\n+\n+            self.parent = old_parent;\n+            self.pos = old_pos;\n+            result\n+        }\n+    }\n+\n+    impl<'doc> serialize::Decoder for Decoder<'doc> {\n+        fn read_nil(&mut self) -> () { () }\n+\n+        fn read_u64(&mut self) -> u64 { doc_as_u64(self.next_doc(EsU64)) }\n+        fn read_u32(&mut self) -> u32 { doc_as_u32(self.next_doc(EsU32)) }\n+        fn read_u16(&mut self) -> u16 { doc_as_u16(self.next_doc(EsU16)) }\n+        fn read_u8 (&mut self) -> u8  { doc_as_u8 (self.next_doc(EsU8 )) }\n+        fn read_uint(&mut self) -> uint {\n+            let v = doc_as_u64(self.next_doc(EsUint));\n+            if v > (::std::uint::MAX as u64) {\n+                fail!(\"uint {} too large for this architecture\", v);\n+            }\n+            v as uint\n+        }\n+\n+        fn read_i64(&mut self) -> i64 {\n+            doc_as_u64(self.next_doc(EsI64)) as i64\n+        }\n+        fn read_i32(&mut self) -> i32 {\n+            doc_as_u32(self.next_doc(EsI32)) as i32\n+        }\n+        fn read_i16(&mut self) -> i16 {\n+            doc_as_u16(self.next_doc(EsI16)) as i16\n+        }\n+        fn read_i8 (&mut self) -> i8 {\n+            doc_as_u8(self.next_doc(EsI8 )) as i8\n+        }\n+        fn read_int(&mut self) -> int {\n+            let v = doc_as_u64(self.next_doc(EsInt)) as i64;\n+            if v > (int::MAX as i64) || v < (int::MIN as i64) {\n+                debug!(\"FIXME \\\\#6122: Removing this makes this function miscompile\");\n+                fail!(\"int {} out of range for this architecture\", v);\n+            }\n+            v as int\n+        }\n+\n+        fn read_bool(&mut self) -> bool {\n+            doc_as_u8(self.next_doc(EsBool)) != 0\n+        }\n+\n+        fn read_f64(&mut self) -> f64 {\n+            let bits = doc_as_u64(self.next_doc(EsF64));\n+            unsafe { transmute(bits) }\n+        }\n+        fn read_f32(&mut self) -> f32 {\n+            let bits = doc_as_u32(self.next_doc(EsF32));\n+            unsafe { transmute(bits) }\n+        }\n+        fn read_char(&mut self) -> char {\n+            char::from_u32(doc_as_u32(self.next_doc(EsChar))).unwrap()\n+        }\n+        fn read_str(&mut self) -> ~str {\n+            self.next_doc(EsStr).as_str()\n+        }\n+\n+        // Compound types:\n+        fn read_enum<T>(&mut self, name: &str, f: |&mut Decoder<'doc>| -> T) -> T {\n+            debug!(\"read_enum({})\", name);\n+            self._check_label(name);\n+\n+            let doc = self.next_doc(EsEnum);\n+\n+            let (old_parent, old_pos) = (self.parent, self.pos);\n+            self.parent = doc;\n+            self.pos = self.parent.start;\n+\n+            let result = f(self);\n+\n+            self.parent = old_parent;\n+            self.pos = old_pos;\n+            result\n+        }\n+\n+        fn read_enum_variant<T>(&mut self,\n+                                _: &[&str],\n+                                f: |&mut Decoder<'doc>, uint| -> T)\n+                                -> T {\n+            debug!(\"read_enum_variant()\");\n+            let idx = self._next_uint(EsEnumVid);\n+            debug!(\"  idx={}\", idx);\n+\n+            let doc = self.next_doc(EsEnumBody);\n+\n+            let (old_parent, old_pos) = (self.parent, self.pos);\n+            self.parent = doc;\n+            self.pos = self.parent.start;\n+\n+            let result = f(self, idx);\n+\n+            self.parent = old_parent;\n+            self.pos = old_pos;\n+            result\n+        }\n+\n+        fn read_enum_variant_arg<T>(&mut self,\n+                                    idx: uint,\n+                                    f: |&mut Decoder<'doc>| -> T) -> T {\n+            debug!(\"read_enum_variant_arg(idx={})\", idx);\n+            f(self)\n+        }\n+\n+        fn read_enum_struct_variant<T>(&mut self,\n+                                       _: &[&str],\n+                                       f: |&mut Decoder<'doc>, uint| -> T)\n+                                       -> T {\n+            debug!(\"read_enum_struct_variant()\");\n+            let idx = self._next_uint(EsEnumVid);\n+            debug!(\"  idx={}\", idx);\n+\n+            let doc = self.next_doc(EsEnumBody);\n+\n+            let (old_parent, old_pos) = (self.parent, self.pos);\n+            self.parent = doc;\n+            self.pos = self.parent.start;\n+\n+            let result = f(self, idx);\n+\n+            self.parent = old_parent;\n+            self.pos = old_pos;\n+            result\n+        }\n+\n+        fn read_enum_struct_variant_field<T>(&mut self,\n+                                             name: &str,\n+                                             idx: uint,\n+                                             f: |&mut Decoder<'doc>| -> T)\n+                                             -> T {\n+            debug!(\"read_enum_struct_variant_arg(name={}, idx={})\", name, idx);\n+            f(self)\n+        }\n+\n+        fn read_struct<T>(&mut self,\n+                          name: &str,\n+                          _: uint,\n+                          f: |&mut Decoder<'doc>| -> T)\n+                          -> T {\n+            debug!(\"read_struct(name={})\", name);\n+            f(self)\n+        }\n+\n+        fn read_struct_field<T>(&mut self,\n+                                name: &str,\n+                                idx: uint,\n+                                f: |&mut Decoder<'doc>| -> T)\n+                                -> T {\n+            debug!(\"read_struct_field(name={}, idx={})\", name, idx);\n+            self._check_label(name);\n+            f(self)\n+        }\n+\n+        fn read_tuple<T>(&mut self, f: |&mut Decoder<'doc>, uint| -> T) -> T {\n+            debug!(\"read_tuple()\");\n+            self.read_seq(f)\n+        }\n+\n+        fn read_tuple_arg<T>(&mut self, idx: uint, f: |&mut Decoder<'doc>| -> T)\n+                             -> T {\n+            debug!(\"read_tuple_arg(idx={})\", idx);\n+            self.read_seq_elt(idx, f)\n+        }\n+\n+        fn read_tuple_struct<T>(&mut self,\n+                                name: &str,\n+                                f: |&mut Decoder<'doc>, uint| -> T)\n+                                -> T {\n+            debug!(\"read_tuple_struct(name={})\", name);\n+            self.read_tuple(f)\n+        }\n+\n+        fn read_tuple_struct_arg<T>(&mut self,\n+                                    idx: uint,\n+                                    f: |&mut Decoder<'doc>| -> T)\n+                                    -> T {\n+            debug!(\"read_tuple_struct_arg(idx={})\", idx);\n+            self.read_tuple_arg(idx, f)\n+        }\n+\n+        fn read_option<T>(&mut self, f: |&mut Decoder<'doc>, bool| -> T) -> T {\n+            debug!(\"read_option()\");\n+            self.read_enum(\"Option\", |this| {\n+                this.read_enum_variant([\"None\", \"Some\"], |this, idx| {\n+                    match idx {\n+                        0 => f(this, false),\n+                        1 => f(this, true),\n+                        _ => fail!(),\n+                    }\n+                })\n+            })\n+        }\n+\n+        fn read_seq<T>(&mut self, f: |&mut Decoder<'doc>, uint| -> T) -> T {\n+            debug!(\"read_seq()\");\n+            self.push_doc(EsVec, |d| {\n+                let len = d._next_uint(EsVecLen);\n+                debug!(\"  len={}\", len);\n+                f(d, len)\n+            })\n+        }\n+\n+        fn read_seq_elt<T>(&mut self, idx: uint, f: |&mut Decoder<'doc>| -> T)\n+                           -> T {\n+            debug!(\"read_seq_elt(idx={})\", idx);\n+            self.push_doc(EsVecElt, f)\n+        }\n+\n+        fn read_map<T>(&mut self, f: |&mut Decoder<'doc>, uint| -> T) -> T {\n+            debug!(\"read_map()\");\n+            self.push_doc(EsMap, |d| {\n+                let len = d._next_uint(EsMapLen);\n+                debug!(\"  len={}\", len);\n+                f(d, len)\n+            })\n+        }\n+\n+        fn read_map_elt_key<T>(&mut self, idx: uint, f: |&mut Decoder<'doc>| -> T)\n+                               -> T {\n+            debug!(\"read_map_elt_key(idx={})\", idx);\n+            self.push_doc(EsMapKey, f)\n+        }\n+\n+        fn read_map_elt_val<T>(&mut self, idx: uint, f: |&mut Decoder<'doc>| -> T)\n+                               -> T {\n+            debug!(\"read_map_elt_val(idx={})\", idx);\n+            self.push_doc(EsMapVal, f)\n+        }\n+    }\n+}\n+\n+pub mod writer {\n+    use std::cast;\n+    use std::clone::Clone;\n+    use std::io;\n+    use std::io::{Writer, Seek};\n+    use std::io::MemWriter;\n+    use std::io::extensions::u64_to_be_bytes;\n+\n+    use super::{ EsVec, EsMap, EsEnum, EsVecLen, EsVecElt, EsMapLen, EsMapKey,\n+        EsEnumVid, EsU64, EsU32, EsU16, EsU8, EsInt, EsI64, EsI32, EsI16, EsI8,\n+        EsBool, EsF64, EsF32, EsChar, EsStr, EsMapVal, EsEnumBody, EsUint,\n+        EsOpaque, EsLabel, EbmlEncoderTag };\n+\n+    use serialize;\n+\n+    // ebml writing\n+    pub struct Encoder<'a> {\n+        // FIXME(#5665): this should take a trait object. Note that if you\n+        //               delete this comment you should consider removing the\n+        //               unwrap()'s below of the results of the calls to\n+        //               write(). We're guaranteed that writing into a MemWriter\n+        //               won't fail, but this is not true for all I/O streams in\n+        //               general.\n+        writer: &'a mut MemWriter,\n+        priv size_positions: ~[uint],\n+        last_error: io::IoResult<()>,\n+    }\n+\n+    fn write_sized_vuint(w: &mut MemWriter, n: uint, size: uint) {\n+        match size {\n+            1u => w.write(&[0x80u8 | (n as u8)]),\n+            2u => w.write(&[0x40u8 | ((n >> 8_u) as u8), n as u8]),\n+            3u => w.write(&[0x20u8 | ((n >> 16_u) as u8), (n >> 8_u) as u8,\n+                            n as u8]),\n+            4u => w.write(&[0x10u8 | ((n >> 24_u) as u8), (n >> 16_u) as u8,\n+                            (n >> 8_u) as u8, n as u8]),\n+            _ => fail!(\"vint to write too big: {}\", n)\n+        }.unwrap()\n+    }\n+\n+    fn write_vuint(w: &mut MemWriter, n: uint) {\n+        if n < 0x7f_u { write_sized_vuint(w, n, 1u); return; }\n+        if n < 0x4000_u { write_sized_vuint(w, n, 2u); return; }\n+        if n < 0x200000_u { write_sized_vuint(w, n, 3u); return; }\n+        if n < 0x10000000_u { write_sized_vuint(w, n, 4u); return; }\n+        fail!(\"vint to write too big: {}\", n);\n+    }\n+\n+    pub fn Encoder<'a>(w: &'a mut MemWriter) -> Encoder<'a> {\n+        let size_positions: ~[uint] = ~[];\n+        Encoder {\n+            writer: w,\n+            size_positions: size_positions,\n+            last_error: Ok(()),\n+        }\n+    }\n+\n+    // FIXME (#2741): Provide a function to write the standard ebml header.\n+    impl<'a> Encoder<'a> {\n+        /// FIXME(pcwalton): Workaround for badness in trans. DO NOT USE ME.\n+        pub unsafe fn unsafe_clone(&self) -> Encoder<'a> {\n+            Encoder {\n+                writer: cast::transmute_copy(&self.writer),\n+                size_positions: self.size_positions.clone(),\n+                last_error: Ok(()),\n+            }\n+        }\n+\n+        pub fn start_tag(&mut self, tag_id: uint) {\n+            debug!(\"Start tag {}\", tag_id);\n+\n+            // Write the enum ID:\n+            write_vuint(self.writer, tag_id);\n+\n+            // Write a placeholder four-byte size.\n+            self.size_positions.push(try!(self.writer.tell()) as uint);\n+            let zeroes: &[u8] = &[0u8, 0u8, 0u8, 0u8];\n+            try!(self.writer.write(zeroes));\n+        }\n+\n+        pub fn end_tag(&mut self) {\n+            let last_size_pos = self.size_positions.pop().unwrap();\n+            let cur_pos = try!(self.writer.tell());\n+            try!(self.writer.seek(last_size_pos as i64, io::SeekSet));\n+            let size = cur_pos as uint - last_size_pos - 4;\n+            write_sized_vuint(self.writer, size, 4u);\n+            try!(self.writer.seek(cur_pos as i64, io::SeekSet));\n+\n+            debug!(\"End tag (size = {})\", size);\n+        }\n+\n+        pub fn wr_tag(&mut self, tag_id: uint, blk: ||) {\n+            self.start_tag(tag_id);\n+            blk();\n+            self.end_tag();\n+        }\n+\n+        pub fn wr_tagged_bytes(&mut self, tag_id: uint, b: &[u8]) {\n+            write_vuint(self.writer, tag_id);\n+            write_vuint(self.writer, b.len());\n+            self.writer.write(b).unwrap();\n+        }\n+\n+        pub fn wr_tagged_u64(&mut self, tag_id: uint, v: u64) {\n+            u64_to_be_bytes(v, 8u, |v| {\n+                self.wr_tagged_bytes(tag_id, v);\n+            })\n+        }\n+\n+        pub fn wr_tagged_u32(&mut self, tag_id: uint, v: u32) {\n+            u64_to_be_bytes(v as u64, 4u, |v| {\n+                self.wr_tagged_bytes(tag_id, v);\n+            })\n+        }\n+\n+        pub fn wr_tagged_u16(&mut self, tag_id: uint, v: u16) {\n+            u64_to_be_bytes(v as u64, 2u, |v| {\n+                self.wr_tagged_bytes(tag_id, v);\n+            })\n+        }\n+\n+        pub fn wr_tagged_u8(&mut self, tag_id: uint, v: u8) {\n+            self.wr_tagged_bytes(tag_id, &[v]);\n+        }\n+\n+        pub fn wr_tagged_i64(&mut self, tag_id: uint, v: i64) {\n+            u64_to_be_bytes(v as u64, 8u, |v| {\n+                self.wr_tagged_bytes(tag_id, v);\n+            })\n+        }\n+\n+        pub fn wr_tagged_i32(&mut self, tag_id: uint, v: i32) {\n+            u64_to_be_bytes(v as u64, 4u, |v| {\n+                self.wr_tagged_bytes(tag_id, v);\n+            })\n+        }\n+\n+        pub fn wr_tagged_i16(&mut self, tag_id: uint, v: i16) {\n+            u64_to_be_bytes(v as u64, 2u, |v| {\n+                self.wr_tagged_bytes(tag_id, v);\n+            })\n+        }\n+\n+        pub fn wr_tagged_i8(&mut self, tag_id: uint, v: i8) {\n+            self.wr_tagged_bytes(tag_id, &[v as u8]);\n+        }\n+\n+        pub fn wr_tagged_str(&mut self, tag_id: uint, v: &str) {\n+            self.wr_tagged_bytes(tag_id, v.as_bytes());\n+        }\n+\n+        pub fn wr_bytes(&mut self, b: &[u8]) {\n+            debug!(\"Write {} bytes\", b.len());\n+            self.writer.write(b).unwrap();\n+        }\n+\n+        pub fn wr_str(&mut self, s: &str) {\n+            debug!(\"Write str: {}\", s);\n+            self.writer.write(s.as_bytes()).unwrap();\n+        }\n+    }\n+\n+    // FIXME (#2743): optionally perform \"relaxations\" on end_tag to more\n+    // efficiently encode sizes; this is a fixed point iteration\n+\n+    // Set to true to generate more debugging in EBML code.\n+    // Totally lame approach.\n+    static DEBUG: bool = true;\n+\n+    impl<'a> Encoder<'a> {\n+        // used internally to emit things like the vector length and so on\n+        fn _emit_tagged_uint(&mut self, t: EbmlEncoderTag, v: uint) {\n+            assert!(v <= 0xFFFF_FFFF_u);\n+            self.wr_tagged_u32(t as uint, v as u32);\n+        }\n+\n+        fn _emit_label(&mut self, label: &str) {\n+            // There are various strings that we have access to, such as\n+            // the name of a record field, which do not actually appear in\n+            // the encoded EBML (normally).  This is just for\n+            // efficiency.  When debugging, though, we can emit such\n+            // labels and then they will be checked by decoder to\n+            // try and check failures more quickly.\n+            if DEBUG { self.wr_tagged_str(EsLabel as uint, label) }\n+        }\n+\n+        pub fn emit_opaque(&mut self, f: |&mut Encoder|) {\n+            self.start_tag(EsOpaque as uint);\n+            f(self);\n+            self.end_tag();\n+        }\n+    }\n+\n+    impl<'a> serialize::Encoder for Encoder<'a> {\n+        fn emit_nil(&mut self) {}\n+\n+        fn emit_uint(&mut self, v: uint) {\n+            self.wr_tagged_u64(EsUint as uint, v as u64);\n+        }\n+        fn emit_u64(&mut self, v: u64) {\n+            self.wr_tagged_u64(EsU64 as uint, v);\n+        }\n+        fn emit_u32(&mut self, v: u32) {\n+            self.wr_tagged_u32(EsU32 as uint, v);\n+        }\n+        fn emit_u16(&mut self, v: u16) {\n+            self.wr_tagged_u16(EsU16 as uint, v);\n+        }\n+        fn emit_u8(&mut self, v: u8) {\n+            self.wr_tagged_u8(EsU8 as uint, v);\n+        }\n+\n+        fn emit_int(&mut self, v: int) {\n+            self.wr_tagged_i64(EsInt as uint, v as i64);\n+        }\n+        fn emit_i64(&mut self, v: i64) {\n+            self.wr_tagged_i64(EsI64 as uint, v);\n+        }\n+        fn emit_i32(&mut self, v: i32) {\n+            self.wr_tagged_i32(EsI32 as uint, v);\n+        }\n+        fn emit_i16(&mut self, v: i16) {\n+            self.wr_tagged_i16(EsI16 as uint, v);\n+        }\n+        fn emit_i8(&mut self, v: i8) {\n+            self.wr_tagged_i8(EsI8 as uint, v);\n+        }\n+\n+        fn emit_bool(&mut self, v: bool) {\n+            self.wr_tagged_u8(EsBool as uint, v as u8)\n+        }\n+\n+        fn emit_f64(&mut self, v: f64) {\n+            let bits = unsafe { cast::transmute(v) };\n+            self.wr_tagged_u64(EsF64 as uint, bits);\n+        }\n+        fn emit_f32(&mut self, v: f32) {\n+            let bits = unsafe { cast::transmute(v) };\n+            self.wr_tagged_u32(EsF32 as uint, bits);\n+        }\n+        fn emit_char(&mut self, v: char) {\n+            self.wr_tagged_u32(EsChar as uint, v as u32);\n+        }\n+\n+        fn emit_str(&mut self, v: &str) {\n+            self.wr_tagged_str(EsStr as uint, v)\n+        }\n+\n+        fn emit_enum(&mut self, name: &str, f: |&mut Encoder<'a>|) {\n+            self._emit_label(name);\n+            self.start_tag(EsEnum as uint);\n+            f(self);\n+            self.end_tag();\n+        }\n+\n+        fn emit_enum_variant(&mut self,\n+                             _: &str,\n+                             v_id: uint,\n+                             _: uint,\n+                             f: |&mut Encoder<'a>|) {\n+            self._emit_tagged_uint(EsEnumVid, v_id);\n+            self.start_tag(EsEnumBody as uint);\n+            f(self);\n+            self.end_tag();\n+        }\n+\n+        fn emit_enum_variant_arg(&mut self, _: uint, f: |&mut Encoder<'a>|) {\n+            f(self)\n+        }\n+\n+        fn emit_enum_struct_variant(&mut self,\n+                                    v_name: &str,\n+                                    v_id: uint,\n+                                    cnt: uint,\n+                                    f: |&mut Encoder<'a>|) {\n+            self.emit_enum_variant(v_name, v_id, cnt, f)\n+        }\n+\n+        fn emit_enum_struct_variant_field(&mut self,\n+                                          _: &str,\n+                                          idx: uint,\n+                                          f: |&mut Encoder<'a>|) {\n+            self.emit_enum_variant_arg(idx, f)\n+        }\n+\n+        fn emit_struct(&mut self,\n+                       _: &str,\n+                       _len: uint,\n+                       f: |&mut Encoder<'a>|) {\n+            f(self)\n+        }\n+\n+        fn emit_struct_field(&mut self,\n+                             name: &str,\n+                             _: uint,\n+                             f: |&mut Encoder<'a>|) {\n+            self._emit_label(name);\n+            f(self)\n+        }\n+\n+        fn emit_tuple(&mut self, len: uint, f: |&mut Encoder<'a>|) {\n+            self.emit_seq(len, f)\n+        }\n+        fn emit_tuple_arg(&mut self, idx: uint, f: |&mut Encoder<'a>|) {\n+            self.emit_seq_elt(idx, f)\n+        }\n+\n+        fn emit_tuple_struct(&mut self,\n+                             _: &str,\n+                             len: uint,\n+                             f: |&mut Encoder<'a>|) {\n+            self.emit_seq(len, f)\n+        }\n+        fn emit_tuple_struct_arg(&mut self,\n+                                 idx: uint,\n+                                 f: |&mut Encoder<'a>|) {\n+            self.emit_seq_elt(idx, f)\n+        }\n+\n+        fn emit_option(&mut self, f: |&mut Encoder<'a>|) {\n+            self.emit_enum(\"Option\", f);\n+        }\n+        fn emit_option_none(&mut self) {\n+            self.emit_enum_variant(\"None\", 0, 0, |_| ())\n+        }\n+        fn emit_option_some(&mut self, f: |&mut Encoder<'a>|) {\n+            self.emit_enum_variant(\"Some\", 1, 1, f)\n+        }\n+\n+        fn emit_seq(&mut self, len: uint, f: |&mut Encoder<'a>|) {\n+            self.start_tag(EsVec as uint);\n+            self._emit_tagged_uint(EsVecLen, len);\n+            f(self);\n+            self.end_tag();\n+        }\n+\n+        fn emit_seq_elt(&mut self, _idx: uint, f: |&mut Encoder<'a>|) {\n+            self.start_tag(EsVecElt as uint);\n+            f(self);\n+            self.end_tag();\n+        }\n+\n+        fn emit_map(&mut self, len: uint, f: |&mut Encoder<'a>|) {\n+            self.start_tag(EsMap as uint);\n+            self._emit_tagged_uint(EsMapLen, len);\n+            f(self);\n+            self.end_tag();\n+        }\n+\n+        fn emit_map_elt_key(&mut self, _idx: uint, f: |&mut Encoder<'a>|) {\n+            self.start_tag(EsMapKey as uint);\n+            f(self);\n+            self.end_tag();\n+        }\n+\n+        fn emit_map_elt_val(&mut self, _idx: uint, f: |&mut Encoder<'a>|) {\n+            self.start_tag(EsMapVal as uint);\n+            f(self);\n+            self.end_tag();\n+        }\n+    }\n+}\n+\n+// ___________________________________________________________________________\n+// Testing\n+\n+#[cfg(test)]\n+mod tests {\n+    use ebml::reader;\n+    use ebml::writer;\n+    use {Encodable, Decodable};\n+\n+    use std::io::MemWriter;\n+    use std::option::{None, Option, Some};\n+\n+    #[test]\n+    fn test_vuint_at() {\n+        let data = [\n+            0x80,\n+            0xff,\n+            0x40, 0x00,\n+            0x7f, 0xff,\n+            0x20, 0x00, 0x00,\n+            0x3f, 0xff, 0xff,\n+            0x10, 0x00, 0x00, 0x00,\n+            0x1f, 0xff, 0xff, 0xff\n+        ];\n+\n+        let mut res: reader::Res;\n+\n+        // Class A\n+        res = reader::vuint_at(data, 0);\n+        assert_eq!(res.val, 0);\n+        assert_eq!(res.next, 1);\n+        res = reader::vuint_at(data, res.next);\n+        assert_eq!(res.val, (1 << 7) - 1);\n+        assert_eq!(res.next, 2);\n+\n+        // Class B\n+        res = reader::vuint_at(data, res.next);\n+        assert_eq!(res.val, 0);\n+        assert_eq!(res.next, 4);\n+        res = reader::vuint_at(data, res.next);\n+        assert_eq!(res.val, (1 << 14) - 1);\n+        assert_eq!(res.next, 6);\n+\n+        // Class C\n+        res = reader::vuint_at(data, res.next);\n+        assert_eq!(res.val, 0);\n+        assert_eq!(res.next, 9);\n+        res = reader::vuint_at(data, res.next);\n+        assert_eq!(res.val, (1 << 21) - 1);\n+        assert_eq!(res.next, 12);\n+\n+        // Class D\n+        res = reader::vuint_at(data, res.next);\n+        assert_eq!(res.val, 0);\n+        assert_eq!(res.next, 16);\n+        res = reader::vuint_at(data, res.next);\n+        assert_eq!(res.val, (1 << 28) - 1);\n+        assert_eq!(res.next, 20);\n+    }\n+\n+    #[test]\n+    fn test_option_int() {\n+        fn test_v(v: Option<int>) {\n+            debug!(\"v == {:?}\", v);\n+            let mut wr = MemWriter::new();\n+            {\n+                let mut ebml_w = writer::Encoder(&mut wr);\n+                v.encode(&mut ebml_w);\n+            }\n+            let ebml_doc = reader::Doc(wr.get_ref());\n+            let mut deser = reader::Decoder(ebml_doc);\n+            let v1 = Decodable::decode(&mut deser);\n+            debug!(\"v1 == {:?}\", v1);\n+            assert_eq!(v, v1);\n+        }\n+\n+        test_v(Some(22));\n+        test_v(None);\n+        test_v(Some(3));\n+    }\n+}\n+\n+#[cfg(test)]\n+mod bench {\n+    extern crate test;\n+    use self::test::BenchHarness;\n+    use ebml::reader;\n+\n+    #[bench]\n+    pub fn vuint_at_A_aligned(bh: &mut BenchHarness) {\n+        use std::slice;\n+        let data = slice::from_fn(4*100, |i| {\n+            match i % 2 {\n+              0 => 0x80u8,\n+              _ => i as u8,\n+            }\n+        });\n+        let mut sum = 0u;\n+        bh.iter(|| {\n+            let mut i = 0;\n+            while i < data.len() {\n+                sum += reader::vuint_at(data, i).val;\n+                i += 4;\n+            }\n+        });\n+    }\n+\n+    #[bench]\n+    pub fn vuint_at_A_unaligned(bh: &mut BenchHarness) {\n+        use std::slice;\n+        let data = slice::from_fn(4*100+1, |i| {\n+            match i % 2 {\n+              1 => 0x80u8,\n+              _ => i as u8\n+            }\n+        });\n+        let mut sum = 0u;\n+        bh.iter(|| {\n+            let mut i = 1;\n+            while i < data.len() {\n+                sum += reader::vuint_at(data, i).val;\n+                i += 4;\n+            }\n+        });\n+    }\n+\n+    #[bench]\n+    pub fn vuint_at_D_aligned(bh: &mut BenchHarness) {\n+        use std::slice;\n+        let data = slice::from_fn(4*100, |i| {\n+            match i % 4 {\n+              0 => 0x10u8,\n+              3 => i as u8,\n+              _ => 0u8\n+            }\n+        });\n+        let mut sum = 0u;\n+        bh.iter(|| {\n+            let mut i = 0;\n+            while i < data.len() {\n+                sum += reader::vuint_at(data, i).val;\n+                i += 4;\n+            }\n+        });\n+    }\n+\n+    #[bench]\n+    pub fn vuint_at_D_unaligned(bh: &mut BenchHarness) {\n+        use std::slice;\n+        let data = slice::from_fn(4*100+1, |i| {\n+            match i % 4 {\n+              1 => 0x10u8,\n+              0 => i as u8,\n+              _ => 0u8\n+            }\n+        });\n+        let mut sum = 0u;\n+        bh.iter(|| {\n+            let mut i = 1;\n+            while i < data.len() {\n+                sum += reader::vuint_at(data, i).val;\n+                i += 4;\n+            }\n+        });\n+    }\n+}\n+"}, {"sha": "f2bdef445bd7d121fd4f835a5aadb1ead4ea7a45", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 412, "deletions": 448, "changes": 860, "blob_url": "https://github.com/rust-lang/rust/blob/f1739b14a1346419a4598339aee32aab07e0d12e/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1739b14a1346419a4598339aee32aab07e0d12e/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=f1739b14a1346419a4598339aee32aab07e0d12e", "patch": "@@ -72,7 +72,10 @@ fn main() {\n     let mut m = io::MemWriter::new();\n     {\n         let mut encoder = json::Encoder::new(&mut m as &mut std::io::Writer);\n-        to_encode_object.encode(&mut encoder);\n+        match to_encode_object.encode(&mut encoder) {\n+            Ok(()) => (),\n+            Err(e) => fail!(\"json encoding error: {}\", e)\n+        };\n     }\n }\n ```\n@@ -141,7 +144,10 @@ fn main() {\n             ~\"{\\\"attr1\\\":1,\\\"attr2\\\":\\\"toto\\\"}\";\n     let json_object = json::from_str(json_str_to_decode);\n     let mut decoder = json::Decoder::new(json_object.unwrap());\n-    let decoded_object: MyStruct = Decodable::decode(&mut decoder); // create the final object\n+    let decoded_object: MyStruct = match Decodable::decode(&mut decoder) {\n+        Ok(v) => v,\n+        Err(e) => fail!(\"Decoding error: {}\", e)\n+    }; // create the final object\n }\n ```\n \n@@ -174,7 +180,7 @@ fn main() {\n \n     let json_object = json::from_str(encoded_str);\n     let mut decoder = json::Decoder::new(json_object.unwrap());\n-    let decoded1: TestStruct1 = Decodable::decode(&mut decoder); // create the final object\n+    let decoded1: TestStruct1 = Decodable::decode(&mut decoder).unwrap(); // create the final object\n }\n ```\n \n@@ -219,7 +225,7 @@ fn main() {\n \n     let mut decoder = json::Decoder::new(json::from_str(json_str).unwrap());\n     // create the final object\n-    let decoded2: TestStruct1 = Decodable::decode(&mut decoder);\n+    let decoded2: TestStruct1 = Decodable::decode(&mut decoder).unwrap();\n }\n ```\n \n@@ -237,10 +243,6 @@ use std::fmt;\n use Encodable;\n use collections::TreeMap;\n \n-macro_rules! try( ($e:expr) => (\n-    match $e { Ok(e) => e, Err(e) => { self.error = Err(e); return } }\n-) )\n-\n /// Represents a json value\n #[deriving(Clone, Eq)]\n pub enum Json {\n@@ -255,25 +257,18 @@ pub enum Json {\n pub type List = ~[Json];\n pub type Object = TreeMap<~str, Json>;\n \n-#[deriving(Eq)]\n-/// If an error occurs while parsing some JSON, this is the structure which is\n-/// returned\n-pub struct Error {\n-    /// The line number at which the error occurred\n-    priv line: uint,\n-    /// The column number at which the error occurred\n-    priv col: uint,\n-    /// A message describing the type of the error\n-    priv msg: ~str,\n+#[deriving(Eq, Show)]\n+pub enum Error {\n+    /// msg, line, col\n+    ParseError(~str, uint, uint),\n+    ExpectedError(~str, ~str),\n+    MissingFieldError(~str),\n+    UnknownVariantError(~str),\n+    IoError(io::IoError)\n }\n \n-fn io_error_to_error(io: io::IoError) -> Error {\n-    Error {\n-        line: 0,\n-        col: 0,\n-        msg: format!(\"io error: {}\", io)\n-    }\n-}\n+pub type EncodeResult = io::IoResult<()>;\n+pub type DecodeResult<T> = Result<T, Error>;\n \n fn escape_str(s: &str) -> ~str {\n     let mut escaped = ~\"\\\"\";\n@@ -304,183 +299,203 @@ fn spaces(n: uint) -> ~str {\n /// A structure for implementing serialization to JSON.\n pub struct Encoder<'a> {\n     priv wr: &'a mut io::Writer,\n-    priv error: io::IoResult<()>,\n }\n \n impl<'a> Encoder<'a> {\n     /// Creates a new JSON encoder whose output will be written to the writer\n     /// specified.\n     pub fn new<'a>(wr: &'a mut io::Writer) -> Encoder<'a> {\n-        Encoder { wr: wr, error: Ok(()) }\n+        Encoder { wr: wr }\n     }\n \n     /// Encode the specified struct into a json [u8]\n-    pub fn buffer_encode<T:Encodable<Encoder<'a>>>(to_encode_object: &T) -> ~[u8]  {\n+    pub fn buffer_encode<T:Encodable<Encoder<'a>, io::IoError>>(to_encode_object: &T) -> ~[u8]  {\n        //Serialize the object in a string using a writer\n         let mut m = MemWriter::new();\n         {\n             let mut encoder = Encoder::new(&mut m as &mut io::Writer);\n-            to_encode_object.encode(&mut encoder);\n+            // MemWriter never Errs\n+            let _ = to_encode_object.encode(&mut encoder);\n         }\n         m.unwrap()\n     }\n \n     /// Encode the specified struct into a json str\n-    pub fn str_encode<T:Encodable<Encoder<'a>>>(to_encode_object: &T) -> ~str  {\n+    pub fn str_encode<T:Encodable<Encoder<'a>, io::IoError>>(to_encode_object: &T) -> ~str  {\n         let buff:~[u8] = Encoder::buffer_encode(to_encode_object);\n         str::from_utf8_owned(buff).unwrap()\n     }\n }\n \n-impl<'a> ::Encoder for Encoder<'a> {\n-    fn emit_nil(&mut self) { try!(write!(self.wr, \"null\")) }\n+impl<'a> ::Encoder<io::IoError> for Encoder<'a> {\n+    fn emit_nil(&mut self) -> EncodeResult { write!(self.wr, \"null\") }\n \n-    fn emit_uint(&mut self, v: uint) { self.emit_f64(v as f64); }\n-    fn emit_u64(&mut self, v: u64) { self.emit_f64(v as f64); }\n-    fn emit_u32(&mut self, v: u32) { self.emit_f64(v as f64); }\n-    fn emit_u16(&mut self, v: u16) { self.emit_f64(v as f64); }\n-    fn emit_u8(&mut self, v: u8)   { self.emit_f64(v as f64); }\n+    fn emit_uint(&mut self, v: uint) -> EncodeResult { self.emit_f64(v as f64) }\n+    fn emit_u64(&mut self, v: u64) -> EncodeResult { self.emit_f64(v as f64) }\n+    fn emit_u32(&mut self, v: u32) -> EncodeResult { self.emit_f64(v as f64) }\n+    fn emit_u16(&mut self, v: u16) -> EncodeResult { self.emit_f64(v as f64) }\n+    fn emit_u8(&mut self, v: u8) -> EncodeResult  { self.emit_f64(v as f64) }\n \n-    fn emit_int(&mut self, v: int) { self.emit_f64(v as f64); }\n-    fn emit_i64(&mut self, v: i64) { self.emit_f64(v as f64); }\n-    fn emit_i32(&mut self, v: i32) { self.emit_f64(v as f64); }\n-    fn emit_i16(&mut self, v: i16) { self.emit_f64(v as f64); }\n-    fn emit_i8(&mut self, v: i8)   { self.emit_f64(v as f64); }\n+    fn emit_int(&mut self, v: int) -> EncodeResult { self.emit_f64(v as f64) }\n+    fn emit_i64(&mut self, v: i64) -> EncodeResult { self.emit_f64(v as f64) }\n+    fn emit_i32(&mut self, v: i32) -> EncodeResult { self.emit_f64(v as f64) }\n+    fn emit_i16(&mut self, v: i16) -> EncodeResult { self.emit_f64(v as f64) }\n+    fn emit_i8(&mut self, v: i8) -> EncodeResult  { self.emit_f64(v as f64) }\n \n-    fn emit_bool(&mut self, v: bool) {\n+    fn emit_bool(&mut self, v: bool) -> EncodeResult {\n         if v {\n-            try!(write!(self.wr, \"true\"));\n+            write!(self.wr, \"true\")\n         } else {\n-            try!(write!(self.wr, \"false\"));\n+            write!(self.wr, \"false\")\n         }\n     }\n \n-    fn emit_f64(&mut self, v: f64) {\n-        try!(write!(self.wr, \"{}\", f64::to_str_digits(v, 6u)))\n+    fn emit_f64(&mut self, v: f64) -> EncodeResult {\n+        write!(self.wr, \"{}\", f64::to_str_digits(v, 6u))\n     }\n-    fn emit_f32(&mut self, v: f32) { self.emit_f64(v as f64); }\n+    fn emit_f32(&mut self, v: f32) -> EncodeResult { self.emit_f64(v as f64) }\n \n-    fn emit_char(&mut self, v: char) { self.emit_str(str::from_char(v)) }\n-    fn emit_str(&mut self, v: &str) {\n-        try!(write!(self.wr, \"{}\", escape_str(v)))\n+    fn emit_char(&mut self, v: char) -> EncodeResult { self.emit_str(str::from_char(v)) }\n+    fn emit_str(&mut self, v: &str) -> EncodeResult {\n+        write!(self.wr, \"{}\", escape_str(v))\n     }\n \n-    fn emit_enum(&mut self, _name: &str, f: |&mut Encoder<'a>|) { f(self) }\n+    fn emit_enum(&mut self,\n+                 _name: &str,\n+                 f: |&mut Encoder<'a>| -> EncodeResult) -> EncodeResult { f(self) }\n \n     fn emit_enum_variant(&mut self,\n                          name: &str,\n                          _id: uint,\n                          cnt: uint,\n-                         f: |&mut Encoder<'a>|) {\n+                         f: |&mut Encoder<'a>| -> EncodeResult) -> EncodeResult {\n         // enums are encoded as strings or objects\n         // Bunny => \"Bunny\"\n         // Kangaroo(34,\"William\") => {\"variant\": \"Kangaroo\", \"fields\": [34,\"William\"]}\n         if cnt == 0 {\n-            try!(write!(self.wr, \"{}\", escape_str(name)));\n+            write!(self.wr, \"{}\", escape_str(name))\n         } else {\n             try!(write!(self.wr, \"\\\\{\\\"variant\\\":\"));\n             try!(write!(self.wr, \"{}\", escape_str(name)));\n             try!(write!(self.wr, \",\\\"fields\\\":[\"));\n-            f(self);\n-            try!(write!(self.wr, \"]\\\\}\"));\n+            try!(f(self));\n+            write!(self.wr, \"]\\\\}\")\n         }\n     }\n \n-    fn emit_enum_variant_arg(&mut self, idx: uint, f: |&mut Encoder<'a>|) {\n+    fn emit_enum_variant_arg(&mut self,\n+                             idx: uint,\n+                             f: |&mut Encoder<'a>| -> EncodeResult) -> EncodeResult {\n         if idx != 0 {\n             try!(write!(self.wr, \",\"));\n         }\n-        f(self);\n+        f(self)\n     }\n \n     fn emit_enum_struct_variant(&mut self,\n                                 name: &str,\n                                 id: uint,\n                                 cnt: uint,\n-                                f: |&mut Encoder<'a>|) {\n+                                f: |&mut Encoder<'a>| -> EncodeResult) -> EncodeResult {\n         self.emit_enum_variant(name, id, cnt, f)\n     }\n \n     fn emit_enum_struct_variant_field(&mut self,\n                                       _: &str,\n                                       idx: uint,\n-                                      f: |&mut Encoder<'a>|) {\n+                                      f: |&mut Encoder<'a>| -> EncodeResult) -> EncodeResult {\n         self.emit_enum_variant_arg(idx, f)\n     }\n \n-    fn emit_struct(&mut self, _: &str, _: uint, f: |&mut Encoder<'a>|) {\n+    fn emit_struct(&mut self,\n+                   _: &str,\n+                   _: uint,\n+                   f: |&mut Encoder<'a>| -> EncodeResult) -> EncodeResult {\n         try!(write!(self.wr, r\"\\{\"));\n-        f(self);\n-        try!(write!(self.wr, r\"\\}\"));\n+        try!(f(self));\n+        write!(self.wr, r\"\\}\")\n     }\n \n     fn emit_struct_field(&mut self,\n                          name: &str,\n                          idx: uint,\n-                         f: |&mut Encoder<'a>|) {\n-        if idx != 0 { try!(write!(self.wr, \",\")) }\n+                         f: |&mut Encoder<'a>| -> EncodeResult) -> EncodeResult {\n+        if idx != 0 { try!(write!(self.wr, \",\")); }\n         try!(write!(self.wr, \"{}:\", escape_str(name)));\n-        f(self);\n+        f(self)\n     }\n \n-    fn emit_tuple(&mut self, len: uint, f: |&mut Encoder<'a>|) {\n+    fn emit_tuple(&mut self, len: uint, f: |&mut Encoder<'a>| -> EncodeResult) -> EncodeResult {\n         self.emit_seq(len, f)\n     }\n-    fn emit_tuple_arg(&mut self, idx: uint, f: |&mut Encoder<'a>|) {\n+    fn emit_tuple_arg(&mut self,\n+                      idx: uint,\n+                      f: |&mut Encoder<'a>| -> EncodeResult) -> EncodeResult {\n         self.emit_seq_elt(idx, f)\n     }\n \n     fn emit_tuple_struct(&mut self,\n                          _name: &str,\n                          len: uint,\n-                         f: |&mut Encoder<'a>|) {\n+                         f: |&mut Encoder<'a>| -> EncodeResult) -> EncodeResult {\n         self.emit_seq(len, f)\n     }\n-    fn emit_tuple_struct_arg(&mut self, idx: uint, f: |&mut Encoder<'a>|) {\n+    fn emit_tuple_struct_arg(&mut self,\n+                             idx: uint,\n+                             f: |&mut Encoder<'a>| -> EncodeResult) -> EncodeResult {\n         self.emit_seq_elt(idx, f)\n     }\n \n-    fn emit_option(&mut self, f: |&mut Encoder<'a>|) { f(self); }\n-    fn emit_option_none(&mut self) { self.emit_nil(); }\n-    fn emit_option_some(&mut self, f: |&mut Encoder<'a>|) { f(self); }\n+    fn emit_option(&mut self, f: |&mut Encoder<'a>| -> EncodeResult) -> EncodeResult {\n+        f(self)\n+    }\n+    fn emit_option_none(&mut self) -> EncodeResult { self.emit_nil() }\n+    fn emit_option_some(&mut self, f: |&mut Encoder<'a>| -> EncodeResult) -> EncodeResult {\n+        f(self)\n+    }\n \n-    fn emit_seq(&mut self, _len: uint, f: |&mut Encoder<'a>|) {\n+    fn emit_seq(&mut self, _len: uint, f: |&mut Encoder<'a>| -> EncodeResult) -> EncodeResult {\n         try!(write!(self.wr, \"[\"));\n-        f(self);\n-        try!(write!(self.wr, \"]\"));\n+        try!(f(self));\n+        write!(self.wr, \"]\")\n     }\n \n-    fn emit_seq_elt(&mut self, idx: uint, f: |&mut Encoder<'a>|) {\n+    fn emit_seq_elt(&mut self, idx: uint, f: |&mut Encoder<'a>| -> EncodeResult) -> EncodeResult {\n         if idx != 0 {\n             try!(write!(self.wr, \",\"));\n         }\n         f(self)\n     }\n \n-    fn emit_map(&mut self, _len: uint, f: |&mut Encoder<'a>|) {\n+    fn emit_map(&mut self, _len: uint, f: |&mut Encoder<'a>| -> EncodeResult) -> EncodeResult {\n         try!(write!(self.wr, r\"\\{\"));\n-        f(self);\n-        try!(write!(self.wr, r\"\\}\"));\n+        try!(f(self));\n+        write!(self.wr, r\"\\}\")\n     }\n \n-    fn emit_map_elt_key(&mut self, idx: uint, f: |&mut Encoder<'a>|) {\n+    fn emit_map_elt_key(&mut self,\n+                        idx: uint,\n+                        f: |&mut Encoder<'a>| -> EncodeResult) -> EncodeResult {\n         use std::str::from_utf8;\n         if idx != 0 { try!(write!(self.wr, \",\")) }\n         // ref #12967, make sure to wrap a key in double quotes,\n         // in the event that its of a type that omits them (eg numbers)\n         let mut buf = MemWriter::new();\n         let mut check_encoder = Encoder::new(&mut buf);\n-        f(&mut check_encoder);\n+        try!(f(&mut check_encoder));\n         let buf = buf.unwrap();\n         let out = from_utf8(buf).unwrap();\n         let needs_wrapping = out.char_at(0) != '\"' &&\n             out.char_at_reverse(out.len()) != '\"';\n         if needs_wrapping { try!(write!(self.wr, \"\\\"\")); }\n-        f(self);\n+        try!(f(self));\n         if needs_wrapping { try!(write!(self.wr, \"\\\"\")); }\n+        Ok(())\n     }\n \n-    fn emit_map_elt_val(&mut self, _idx: uint, f: |&mut Encoder<'a>|) {\n+    fn emit_map_elt_val(&mut self,\n+                        _idx: uint,\n+                        f: |&mut Encoder<'a>| -> EncodeResult) -> EncodeResult {\n         try!(write!(self.wr, \":\"));\n         f(self)\n     }\n@@ -491,7 +506,6 @@ impl<'a> ::Encoder for Encoder<'a> {\n pub struct PrettyEncoder<'a> {\n     priv wr: &'a mut io::Writer,\n     priv indent: uint,\n-    priv error: io::IoResult<()>,\n }\n \n impl<'a> PrettyEncoder<'a> {\n@@ -500,68 +514,69 @@ impl<'a> PrettyEncoder<'a> {\n         PrettyEncoder {\n             wr: wr,\n             indent: 0,\n-            error: Ok(())\n         }\n     }\n }\n \n-impl<'a> ::Encoder for PrettyEncoder<'a> {\n-    fn emit_nil(&mut self) { try!(write!(self.wr, \"null\")); }\n+impl<'a> ::Encoder<io::IoError> for PrettyEncoder<'a> {\n+    fn emit_nil(&mut self) -> EncodeResult { write!(self.wr, \"null\") }\n \n-    fn emit_uint(&mut self, v: uint) { self.emit_f64(v as f64); }\n-    fn emit_u64(&mut self, v: u64) { self.emit_f64(v as f64); }\n-    fn emit_u32(&mut self, v: u32) { self.emit_f64(v as f64); }\n-    fn emit_u16(&mut self, v: u16) { self.emit_f64(v as f64); }\n-    fn emit_u8(&mut self, v: u8)   { self.emit_f64(v as f64); }\n+    fn emit_uint(&mut self, v: uint) -> EncodeResult { self.emit_f64(v as f64) }\n+    fn emit_u64(&mut self, v: u64) -> EncodeResult { self.emit_f64(v as f64) }\n+    fn emit_u32(&mut self, v: u32) -> EncodeResult { self.emit_f64(v as f64) }\n+    fn emit_u16(&mut self, v: u16) -> EncodeResult { self.emit_f64(v as f64) }\n+    fn emit_u8(&mut self, v: u8) -> EncodeResult { self.emit_f64(v as f64) }\n \n-    fn emit_int(&mut self, v: int) { self.emit_f64(v as f64); }\n-    fn emit_i64(&mut self, v: i64) { self.emit_f64(v as f64); }\n-    fn emit_i32(&mut self, v: i32) { self.emit_f64(v as f64); }\n-    fn emit_i16(&mut self, v: i16) { self.emit_f64(v as f64); }\n-    fn emit_i8(&mut self, v: i8)   { self.emit_f64(v as f64); }\n+    fn emit_int(&mut self, v: int) -> EncodeResult { self.emit_f64(v as f64) }\n+    fn emit_i64(&mut self, v: i64) -> EncodeResult { self.emit_f64(v as f64) }\n+    fn emit_i32(&mut self, v: i32) -> EncodeResult { self.emit_f64(v as f64) }\n+    fn emit_i16(&mut self, v: i16) -> EncodeResult { self.emit_f64(v as f64) }\n+    fn emit_i8(&mut self, v: i8) -> EncodeResult { self.emit_f64(v as f64) }\n \n-    fn emit_bool(&mut self, v: bool) {\n+    fn emit_bool(&mut self, v: bool) -> EncodeResult {\n         if v {\n-            try!(write!(self.wr, \"true\"));\n+            write!(self.wr, \"true\")\n         } else {\n-            try!(write!(self.wr, \"false\"));\n+            write!(self.wr, \"false\")\n         }\n     }\n \n-    fn emit_f64(&mut self, v: f64) {\n-        try!(write!(self.wr, \"{}\", f64::to_str_digits(v, 6u)));\n+    fn emit_f64(&mut self, v: f64) -> EncodeResult {\n+        write!(self.wr, \"{}\", f64::to_str_digits(v, 6u))\n     }\n-    fn emit_f32(&mut self, v: f32) { self.emit_f64(v as f64); }\n+    fn emit_f32(&mut self, v: f32) -> EncodeResult { self.emit_f64(v as f64) }\n \n-    fn emit_char(&mut self, v: char) { self.emit_str(str::from_char(v)) }\n-    fn emit_str(&mut self, v: &str) {\n-        try!(write!(self.wr, \"{}\", escape_str(v)));\n+    fn emit_char(&mut self, v: char) -> EncodeResult { self.emit_str(str::from_char(v)) }\n+    fn emit_str(&mut self, v: &str) -> EncodeResult {\n+        write!(self.wr, \"{}\", escape_str(v))\n     }\n \n-    fn emit_enum(&mut self, _name: &str, f: |&mut PrettyEncoder<'a>|) {\n+    fn emit_enum(&mut self,\n+                 _name: &str,\n+                 f: |&mut PrettyEncoder<'a>| -> EncodeResult) -> EncodeResult {\n         f(self)\n     }\n \n     fn emit_enum_variant(&mut self,\n                          name: &str,\n                          _: uint,\n                          cnt: uint,\n-                         f: |&mut PrettyEncoder<'a>|) {\n+                         f: |&mut PrettyEncoder<'a>| -> EncodeResult) -> EncodeResult {\n         if cnt == 0 {\n-            try!(write!(self.wr, \"{}\", escape_str(name)));\n+            write!(self.wr, \"{}\", escape_str(name))\n         } else {\n             self.indent += 2;\n             try!(write!(self.wr, \"[\\n{}{},\\n\", spaces(self.indent),\n                           escape_str(name)));\n-            f(self);\n+            try!(f(self));\n             self.indent -= 2;\n-            try!(write!(self.wr, \"\\n{}]\", spaces(self.indent)));\n+            write!(self.wr, \"\\n{}]\", spaces(self.indent))\n         }\n     }\n \n     fn emit_enum_variant_arg(&mut self,\n                              idx: uint,\n-                             f: |&mut PrettyEncoder<'a>|) {\n+                             f: |&mut PrettyEncoder<'a>| -> EncodeResult) -> EncodeResult {\n         if idx != 0 {\n             try!(write!(self.wr, \",\\n\"));\n         }\n@@ -573,82 +588,94 @@ impl<'a> ::Encoder for PrettyEncoder<'a> {\n                                 name: &str,\n                                 id: uint,\n                                 cnt: uint,\n-                                f: |&mut PrettyEncoder<'a>|) {\n+                                f: |&mut PrettyEncoder<'a>| -> EncodeResult) -> EncodeResult {\n         self.emit_enum_variant(name, id, cnt, f)\n     }\n \n     fn emit_enum_struct_variant_field(&mut self,\n                                       _: &str,\n                                       idx: uint,\n-                                      f: |&mut PrettyEncoder<'a>|) {\n+                                      f: |&mut PrettyEncoder<'a>| -> EncodeResult) -> EncodeResult {\n         self.emit_enum_variant_arg(idx, f)\n     }\n \n \n     fn emit_struct(&mut self,\n                    _: &str,\n                    len: uint,\n-                   f: |&mut PrettyEncoder<'a>|) {\n+                   f: |&mut PrettyEncoder<'a>| -> EncodeResult) -> EncodeResult {\n         if len == 0 {\n-            try!(write!(self.wr, \"\\\\{\\\\}\"));\n+            write!(self.wr, \"\\\\{\\\\}\")\n         } else {\n             try!(write!(self.wr, \"\\\\{\"));\n             self.indent += 2;\n-            f(self);\n+            try!(f(self));\n             self.indent -= 2;\n-            try!(write!(self.wr, \"\\n{}\\\\}\", spaces(self.indent)));\n+            write!(self.wr, \"\\n{}\\\\}\", spaces(self.indent))\n         }\n     }\n \n     fn emit_struct_field(&mut self,\n                          name: &str,\n                          idx: uint,\n-                         f: |&mut PrettyEncoder<'a>|) {\n+                         f: |&mut PrettyEncoder<'a>| -> EncodeResult) -> EncodeResult {\n         if idx == 0 {\n             try!(write!(self.wr, \"\\n\"));\n         } else {\n             try!(write!(self.wr, \",\\n\"));\n         }\n         try!(write!(self.wr, \"{}{}: \", spaces(self.indent), escape_str(name)));\n-        f(self);\n+        f(self)\n     }\n \n-    fn emit_tuple(&mut self, len: uint, f: |&mut PrettyEncoder<'a>|) {\n+    fn emit_tuple(&mut self,\n+                  len: uint,\n+                  f: |&mut PrettyEncoder<'a>| -> EncodeResult) -> EncodeResult {\n         self.emit_seq(len, f)\n     }\n-    fn emit_tuple_arg(&mut self, idx: uint, f: |&mut PrettyEncoder<'a>|) {\n+    fn emit_tuple_arg(&mut self,\n+                      idx: uint,\n+                      f: |&mut PrettyEncoder<'a>| -> EncodeResult) -> EncodeResult {\n         self.emit_seq_elt(idx, f)\n     }\n \n     fn emit_tuple_struct(&mut self,\n                          _: &str,\n                          len: uint,\n-                         f: |&mut PrettyEncoder<'a>|) {\n+                         f: |&mut PrettyEncoder<'a>| -> EncodeResult) -> EncodeResult {\n         self.emit_seq(len, f)\n     }\n     fn emit_tuple_struct_arg(&mut self,\n                              idx: uint,\n-                             f: |&mut PrettyEncoder<'a>|) {\n+                             f: |&mut PrettyEncoder<'a>| -> EncodeResult) -> EncodeResult {\n         self.emit_seq_elt(idx, f)\n     }\n \n-    fn emit_option(&mut self, f: |&mut PrettyEncoder<'a>|) { f(self); }\n-    fn emit_option_none(&mut self) { self.emit_nil(); }\n-    fn emit_option_some(&mut self, f: |&mut PrettyEncoder<'a>|) { f(self); }\n+    fn emit_option(&mut self, f: |&mut PrettyEncoder<'a>| -> EncodeResult) -> EncodeResult {\n+        f(self)\n+    }\n+    fn emit_option_none(&mut self) -> EncodeResult { self.emit_nil() }\n+    fn emit_option_some(&mut self, f: |&mut PrettyEncoder<'a>| -> EncodeResult) -> EncodeResult {\n+        f(self)\n+    }\n \n-    fn emit_seq(&mut self, len: uint, f: |&mut PrettyEncoder<'a>|) {\n+    fn emit_seq(&mut self,\n+                len: uint,\n+                f: |&mut PrettyEncoder<'a>| -> EncodeResult) -> EncodeResult {\n         if len == 0 {\n-            try!(write!(self.wr, \"[]\"));\n+            write!(self.wr, \"[]\")\n         } else {\n             try!(write!(self.wr, \"[\"));\n             self.indent += 2;\n-            f(self);\n+            try!(f(self));\n             self.indent -= 2;\n-            try!(write!(self.wr, \"\\n{}]\", spaces(self.indent)));\n+            write!(self.wr, \"\\n{}]\", spaces(self.indent))\n         }\n     }\n \n-    fn emit_seq_elt(&mut self, idx: uint, f: |&mut PrettyEncoder<'a>|) {\n+    fn emit_seq_elt(&mut self,\n+                    idx: uint,\n+                    f: |&mut PrettyEncoder<'a>| -> EncodeResult) -> EncodeResult {\n         if idx == 0 {\n             try!(write!(self.wr, \"\\n\"));\n         } else {\n@@ -658,19 +685,23 @@ impl<'a> ::Encoder for PrettyEncoder<'a> {\n         f(self)\n     }\n \n-    fn emit_map(&mut self, len: uint, f: |&mut PrettyEncoder<'a>|) {\n+    fn emit_map(&mut self,\n+                len: uint,\n+                f: |&mut PrettyEncoder<'a>| -> EncodeResult) -> EncodeResult {\n         if len == 0 {\n-            try!(write!(self.wr, \"\\\\{\\\\}\"));\n+            write!(self.wr, \"\\\\{\\\\}\")\n         } else {\n             try!(write!(self.wr, \"\\\\{\"));\n             self.indent += 2;\n-            f(self);\n+            try!(f(self));\n             self.indent -= 2;\n-            try!(write!(self.wr, \"\\n{}\\\\}\", spaces(self.indent)));\n+            write!(self.wr, \"\\n{}\\\\}\", spaces(self.indent))\n         }\n     }\n \n-    fn emit_map_elt_key(&mut self, idx: uint, f: |&mut PrettyEncoder<'a>|) {\n+    fn emit_map_elt_key(&mut self,\n+                        idx: uint,\n+                        f: |&mut PrettyEncoder<'a>| -> EncodeResult) -> EncodeResult {\n         use std::str::from_utf8;\n         if idx == 0 {\n             try!(write!(self.wr, \"\\n\"));\n@@ -682,24 +713,27 @@ impl<'a> ::Encoder for PrettyEncoder<'a> {\n         // in the event that its of a type that omits them (eg numbers)\n         let mut buf = MemWriter::new();\n         let mut check_encoder = PrettyEncoder::new(&mut buf);\n-        f(&mut check_encoder);\n+        try!(f(&mut check_encoder));\n         let buf = buf.unwrap();\n         let out = from_utf8(buf).unwrap();\n         let needs_wrapping = out.char_at(0) != '\"' &&\n             out.char_at_reverse(out.len()) != '\"';\n         if needs_wrapping { try!(write!(self.wr, \"\\\"\")); }\n-        f(self);\n+        try!(f(self));\n         if needs_wrapping { try!(write!(self.wr, \"\\\"\")); }\n+        Ok(())\n     }\n \n-    fn emit_map_elt_val(&mut self, _idx: uint, f: |&mut PrettyEncoder<'a>|) {\n+    fn emit_map_elt_val(&mut self,\n+                        _idx: uint,\n+                        f: |&mut PrettyEncoder<'a>| -> EncodeResult) -> EncodeResult {\n         try!(write!(self.wr, \": \"));\n-        f(self);\n+        f(self)\n     }\n }\n \n-impl<E: ::Encoder> Encodable<E> for Json {\n-    fn encode(&self, e: &mut E) {\n+impl<E: ::Encoder<io::IoError>> Encodable<E, io::IoError> for Json {\n+    fn encode(&self, e: &mut E) -> EncodeResult {\n         match *self {\n             Number(v) => v.encode(e),\n             String(ref v) => v.encode(e),\n@@ -713,18 +747,16 @@ impl<E: ::Encoder> Encodable<E> for Json {\n \n impl Json {\n     /// Encodes a json value into a io::writer.  Uses a single line.\n-    pub fn to_writer(&self, wr: &mut io::Writer) -> io::IoResult<()> {\n+    pub fn to_writer(&self, wr: &mut io::Writer) -> EncodeResult {\n         let mut encoder = Encoder::new(wr);\n-        self.encode(&mut encoder);\n-        encoder.error\n+        self.encode(&mut encoder)\n     }\n \n     /// Encodes a json value into a io::writer.\n     /// Pretty-prints in a more readable format.\n-    pub fn to_pretty_writer(&self, wr: &mut io::Writer) -> io::IoResult<()> {\n+    pub fn to_pretty_writer(&self, wr: &mut io::Writer) -> EncodeResult {\n         let mut encoder = PrettyEncoder::new(wr);\n-        self.encode(&mut encoder);\n-        encoder.error\n+        self.encode(&mut encoder)\n     }\n \n     /// Encodes a json value into a string\n@@ -888,7 +920,7 @@ impl<T: Iterator<char>> Parser<T> {\n }\n \n impl<T: Iterator<char>> Parser<T> {\n-    pub fn parse(&mut self) -> Result<Json, Error> {\n+    pub fn parse(&mut self) -> DecodeResult<Json> {\n         match self.parse_value() {\n           Ok(value) => {\n             // Skip trailing whitespaces.\n@@ -927,11 +959,11 @@ impl<T : Iterator<char>> Parser<T> {\n         self.ch == Some(c)\n     }\n \n-    fn error<T>(&self, msg: ~str) -> Result<T, Error> {\n-        Err(Error { line: self.line, col: self.col, msg: msg })\n+    fn error<T>(&self, msg: ~str) -> DecodeResult<T> {\n+        Err(ParseError(msg, self.line, self.col))\n     }\n \n-    fn parse_value(&mut self) -> Result<Json, Error> {\n+    fn parse_value(&mut self) -> DecodeResult<Json> {\n         self.parse_whitespace();\n \n         if self.eof() { return self.error(~\"EOF while parsing value\"); }\n@@ -960,7 +992,7 @@ impl<T : Iterator<char>> Parser<T> {\n               self.ch_is('\\r') { self.bump(); }\n     }\n \n-    fn parse_ident(&mut self, ident: &str, value: Json) -> Result<Json, Error> {\n+    fn parse_ident(&mut self, ident: &str, value: Json) -> DecodeResult<Json> {\n         if ident.chars().all(|c| Some(c) == self.next_char()) {\n             self.bump();\n             Ok(value)\n@@ -969,7 +1001,7 @@ impl<T : Iterator<char>> Parser<T> {\n         }\n     }\n \n-    fn parse_number(&mut self) -> Result<Json, Error> {\n+    fn parse_number(&mut self) -> DecodeResult<Json> {\n         let mut neg = 1.0;\n \n         if self.ch_is('-') {\n@@ -999,7 +1031,7 @@ impl<T : Iterator<char>> Parser<T> {\n         Ok(Number(neg * res))\n     }\n \n-    fn parse_integer(&mut self) -> Result<f64, Error> {\n+    fn parse_integer(&mut self) -> DecodeResult<f64> {\n         let mut res = 0.0;\n \n         match self.ch_or_null() {\n@@ -1030,7 +1062,7 @@ impl<T : Iterator<char>> Parser<T> {\n         Ok(res)\n     }\n \n-    fn parse_decimal(&mut self, res: f64) -> Result<f64, Error> {\n+    fn parse_decimal(&mut self, res: f64) -> DecodeResult<f64> {\n         self.bump();\n \n         // Make sure a digit follows the decimal place.\n@@ -1056,7 +1088,7 @@ impl<T : Iterator<char>> Parser<T> {\n         Ok(res)\n     }\n \n-    fn parse_exponent(&mut self, mut res: f64) -> Result<f64, Error> {\n+    fn parse_exponent(&mut self, mut res: f64) -> DecodeResult<f64> {\n         self.bump();\n \n         let mut exp = 0u;\n@@ -1096,7 +1128,7 @@ impl<T : Iterator<char>> Parser<T> {\n         Ok(res)\n     }\n \n-    fn parse_str(&mut self) -> Result<~str, Error> {\n+    fn parse_str(&mut self) -> DecodeResult<~str> {\n         let mut escape = false;\n         let mut res = ~\"\";\n \n@@ -1160,7 +1192,7 @@ impl<T : Iterator<char>> Parser<T> {\n         }\n     }\n \n-    fn parse_list(&mut self) -> Result<Json, Error> {\n+    fn parse_list(&mut self) -> DecodeResult<Json> {\n         self.bump();\n         self.parse_whitespace();\n \n@@ -1193,7 +1225,7 @@ impl<T : Iterator<char>> Parser<T> {\n         };\n     }\n \n-    fn parse_object(&mut self) -> Result<Json, Error> {\n+    fn parse_object(&mut self) -> DecodeResult<Json> {\n         self.bump();\n         self.parse_whitespace();\n \n@@ -1245,21 +1277,21 @@ impl<T : Iterator<char>> Parser<T> {\n }\n \n /// Decodes a json value from an `&mut io::Reader`\n-pub fn from_reader(rdr: &mut io::Reader) -> Result<Json, Error> {\n+pub fn from_reader(rdr: &mut io::Reader) -> DecodeResult<Json> {\n     let contents = match rdr.read_to_end() {\n         Ok(c) => c,\n-        Err(e) => return Err(io_error_to_error(e))\n+        Err(e) => return Err(IoError(e))\n     };\n     let s = match str::from_utf8_owned(contents) {\n         Some(s) => s,\n-        None => return Err(Error { line: 0, col: 0, msg: ~\"contents not utf-8\" })\n+        None => return Err(ParseError(~\"contents not utf-8\", 0, 0))\n     };\n     let mut parser = Parser::new(s.chars());\n     parser.parse()\n }\n \n /// Decodes a json value from a string\n-pub fn from_str(s: &str) -> Result<Json, Error> {\n+pub fn from_str(s: &str) -> DecodeResult<Json> {\n     let mut parser = Parser::new(s.chars());\n     parser.parse()\n }\n@@ -1279,147 +1311,134 @@ impl Decoder {\n }\n \n impl Decoder {\n-    fn err(&self, msg: &str) -> ! {\n-        fail!(\"JSON decode error: {}\", msg);\n-    }\n-    fn missing_field(&self, field: &str, object: ~Object) -> ! {\n-        self.err(format!(\"missing required '{}' field in object: {}\",\n-                         field, Object(object).to_str()))\n-    }\n-    fn expected(&self, expected: &str, found: &Json) -> ! {\n-        let found_s = match *found {\n-            Null => \"null\",\n-            List(..) => \"list\",\n-            Object(..) => \"object\",\n-            Number(..) => \"number\",\n-            String(..) => \"string\",\n-            Boolean(..) => \"boolean\"\n-        };\n-        self.err(format!(\"expected {expct} but found {fnd}: {val}\",\n-                         expct=expected, fnd=found_s, val=found.to_str()))\n+    fn pop(&mut self) -> Json {\n+        self.stack.pop().unwrap()\n     }\n }\n \n-impl ::Decoder for Decoder {\n-    fn read_nil(&mut self) -> () {\n-        debug!(\"read_nil\");\n-        match self.stack.pop().unwrap() {\n-            Null => (),\n-            value => self.expected(\"null\", &value)\n+macro_rules! expect(\n+    ($e:expr, Null) => ({\n+        match $e {\n+            Null => Ok(()),\n+            other => Err(ExpectedError(~\"Null\", format!(\"{}\", other)))\n+        }\n+    });\n+    ($e:expr, $t:ident) => ({\n+        match $e {\n+            $t(v) => Ok(v),\n+            other => Err(ExpectedError(stringify!($t).to_owned(), format!(\"{}\", other)))\n         }\n+    })\n+)\n+\n+impl ::Decoder<Error> for Decoder {\n+    fn read_nil(&mut self) -> DecodeResult<()> {\n+        debug!(\"read_nil\");\n+        try!(expect!(self.pop(), Null));\n+        Ok(())\n     }\n \n-    fn read_u64(&mut self)  -> u64  { self.read_f64() as u64 }\n-    fn read_u32(&mut self)  -> u32  { self.read_f64() as u32 }\n-    fn read_u16(&mut self)  -> u16  { self.read_f64() as u16 }\n-    fn read_u8 (&mut self)  -> u8   { self.read_f64() as u8 }\n-    fn read_uint(&mut self) -> uint { self.read_f64() as uint }\n+    fn read_u64(&mut self)  -> DecodeResult<u64 > { Ok(try!(self.read_f64()) as u64) }\n+    fn read_u32(&mut self)  -> DecodeResult<u32 > { Ok(try!(self.read_f64()) as u32) }\n+    fn read_u16(&mut self)  -> DecodeResult<u16 > { Ok(try!(self.read_f64()) as u16) }\n+    fn read_u8 (&mut self)  -> DecodeResult<u8  > { Ok(try!(self.read_f64()) as u8) }\n+    fn read_uint(&mut self) -> DecodeResult<uint> { Ok(try!(self.read_f64()) as uint) }\n \n-    fn read_i64(&mut self) -> i64 { self.read_f64() as i64 }\n-    fn read_i32(&mut self) -> i32 { self.read_f64() as i32 }\n-    fn read_i16(&mut self) -> i16 { self.read_f64() as i16 }\n-    fn read_i8 (&mut self) -> i8  { self.read_f64() as i8 }\n-    fn read_int(&mut self) -> int { self.read_f64() as int }\n+    fn read_i64(&mut self) -> DecodeResult<i64> { Ok(try!(self.read_f64()) as i64) }\n+    fn read_i32(&mut self) -> DecodeResult<i32> { Ok(try!(self.read_f64()) as i32) }\n+    fn read_i16(&mut self) -> DecodeResult<i16> { Ok(try!(self.read_f64()) as i16) }\n+    fn read_i8 (&mut self) -> DecodeResult<i8 > { Ok(try!(self.read_f64()) as i8) }\n+    fn read_int(&mut self) -> DecodeResult<int> { Ok(try!(self.read_f64()) as int) }\n \n-    fn read_bool(&mut self) -> bool {\n+    fn read_bool(&mut self) -> DecodeResult<bool> {\n         debug!(\"read_bool\");\n-        match self.stack.pop().unwrap() {\n-            Boolean(b) => b,\n-            value => self.expected(\"boolean\", &value)\n-        }\n+        Ok(try!(expect!(self.pop(), Boolean)))\n     }\n \n-    fn read_f64(&mut self) -> f64 {\n+    fn read_f64(&mut self) -> DecodeResult<f64> {\n         use std::from_str::FromStr;\n         debug!(\"read_f64\");\n-        match self.stack.pop().unwrap() {\n-            Number(f) => f,\n+        match self.pop() {\n+            Number(f) => Ok(f),\n             String(s) => {\n                 // re: #12967.. a type w/ numeric keys (ie HashMap<uint, V> etc)\n                 // is going to have a string here, as per JSON spec..\n-                FromStr::from_str(s).unwrap()\n+                Ok(FromStr::from_str(s).unwrap())\n             },\n-            value => self.expected(\"number\", &value)\n+            value => Err(ExpectedError(~\"Number\", format!(\"{}\", value)))\n         }\n     }\n \n-    fn read_f32(&mut self) -> f32 { self.read_f64() as f32 }\n+    fn read_f32(&mut self) -> DecodeResult<f32> { Ok(try!(self.read_f64()) as f32) }\n \n-    fn read_char(&mut self) -> char {\n-        let s = self.read_str();\n+    fn read_char(&mut self) -> DecodeResult<char> {\n+        let s = try!(self.read_str());\n         {\n             let mut it = s.chars();\n             match (it.next(), it.next()) {\n                 // exactly one character\n-                (Some(c), None) => return c,\n+                (Some(c), None) => return Ok(c),\n                 _ => ()\n             }\n         }\n-        self.expected(\"single character string\", &String(s))\n+        Err(ExpectedError(~\"single character string\", format!(\"{}\", s)))\n     }\n \n-    fn read_str(&mut self) -> ~str {\n+    fn read_str(&mut self) -> DecodeResult<~str> {\n         debug!(\"read_str\");\n-        match self.stack.pop().unwrap() {\n-            String(s) => s,\n-            value => self.expected(\"string\", &value)\n-        }\n+        Ok(try!(expect!(self.pop(), String)))\n     }\n \n-    fn read_enum<T>(&mut self, name: &str, f: |&mut Decoder| -> T) -> T {\n+    fn read_enum<T>(&mut self,\n+                    name: &str,\n+                    f: |&mut Decoder| -> DecodeResult<T>) -> DecodeResult<T> {\n         debug!(\"read_enum({})\", name);\n         f(self)\n     }\n \n     fn read_enum_variant<T>(&mut self,\n                             names: &[&str],\n-                            f: |&mut Decoder, uint| -> T)\n-                            -> T {\n+                            f: |&mut Decoder, uint| -> DecodeResult<T>)\n+                            -> DecodeResult<T> {\n         debug!(\"read_enum_variant(names={:?})\", names);\n-        let name = match self.stack.pop().unwrap() {\n+        let name = match self.pop() {\n             String(s) => s,\n             Object(mut o) => {\n                 let n = match o.pop(&~\"variant\") {\n                     Some(String(s)) => s,\n-                    Some(val) => self.expected(\"string\", &val),\n-                    None => self.missing_field(\"variant\", o)\n+                    Some(val) => return Err(ExpectedError(~\"String\", format!(\"{}\", val))),\n+                    None => return Err(MissingFieldError(~\"variant\"))\n                 };\n                 match o.pop(&~\"fields\") {\n                     Some(List(l)) => {\n                         for field in l.move_rev_iter() {\n                             self.stack.push(field.clone());\n                         }\n                     },\n-                    Some(val) => self.expected(\"list\", &val),\n-                    None => {\n-                        // re-insert the variant field so we're\n-                        // printing the \"whole\" struct in the error\n-                        // message... ick.\n-                        o.insert(~\"variant\", String(n));\n-                        self.missing_field(\"fields\", o);\n-                    }\n+                    Some(val) => return Err(ExpectedError(~\"List\", format!(\"{}\", val))),\n+                    None => return Err(MissingFieldError(~\"fields\"))\n                 }\n                 n\n             }\n-            json => self.expected(\"string or object\", &json)\n+            json => return Err(ExpectedError(~\"String or Object\", format!(\"{}\", json)))\n         };\n         let idx = match names.iter().position(|n| str::eq_slice(*n, name)) {\n             Some(idx) => idx,\n-            None => self.err(format!(\"unknown variant name: {}\", name))\n+            None => return Err(UnknownVariantError(name))\n         };\n         f(self, idx)\n     }\n \n-    fn read_enum_variant_arg<T>(&mut self, idx: uint, f: |&mut Decoder| -> T)\n-                                -> T {\n+    fn read_enum_variant_arg<T>(&mut self, idx: uint, f: |&mut Decoder| -> DecodeResult<T>)\n+                                -> DecodeResult<T> {\n         debug!(\"read_enum_variant_arg(idx={})\", idx);\n         f(self)\n     }\n \n     fn read_enum_struct_variant<T>(&mut self,\n                                    names: &[&str],\n-                                   f: |&mut Decoder, uint| -> T)\n-                                   -> T {\n+                                   f: |&mut Decoder, uint| -> DecodeResult<T>)\n+                                   -> DecodeResult<T> {\n         debug!(\"read_enum_struct_variant(names={:?})\", names);\n         self.read_enum_variant(names, f)\n     }\n@@ -1428,122 +1447,113 @@ impl ::Decoder for Decoder {\n     fn read_enum_struct_variant_field<T>(&mut self,\n                                          name: &str,\n                                          idx: uint,\n-                                         f: |&mut Decoder| -> T)\n-                                         -> T {\n+                                         f: |&mut Decoder| -> DecodeResult<T>)\n+                                         -> DecodeResult<T> {\n         debug!(\"read_enum_struct_variant_field(name={}, idx={})\", name, idx);\n         self.read_enum_variant_arg(idx, f)\n     }\n \n     fn read_struct<T>(&mut self,\n                       name: &str,\n                       len: uint,\n-                      f: |&mut Decoder| -> T)\n-                      -> T {\n+                      f: |&mut Decoder| -> DecodeResult<T>)\n+                      -> DecodeResult<T> {\n         debug!(\"read_struct(name={}, len={})\", name, len);\n-        let value = f(self);\n-        self.stack.pop().unwrap();\n-        value\n+        let value = try!(f(self));\n+        self.pop();\n+        Ok(value)\n     }\n \n     fn read_struct_field<T>(&mut self,\n                             name: &str,\n                             idx: uint,\n-                            f: |&mut Decoder| -> T)\n-                            -> T {\n+                            f: |&mut Decoder| -> DecodeResult<T>)\n+                            -> DecodeResult<T> {\n         debug!(\"read_struct_field(name={}, idx={})\", name, idx);\n-        match self.stack.pop().unwrap() {\n-            Object(mut obj) => {\n-                let value = match obj.pop(&name.to_owned()) {\n-                    None => self.missing_field(name, obj),\n-                    Some(json) => {\n-                        self.stack.push(json);\n-                        f(self)\n-                    }\n-                };\n-                self.stack.push(Object(obj));\n-                value\n+        let mut obj = try!(expect!(self.pop(), Object));\n+\n+        let value = match obj.pop(&name.to_owned()) {\n+            None => return Err(MissingFieldError(name.to_owned())),\n+            Some(json) => {\n+                self.stack.push(json);\n+                try!(f(self))\n             }\n-            value => self.expected(\"object\", &value)\n-        }\n+        };\n+        self.stack.push(Object(obj));\n+        Ok(value)\n     }\n \n-    fn read_tuple<T>(&mut self, f: |&mut Decoder, uint| -> T) -> T {\n+    fn read_tuple<T>(&mut self, f: |&mut Decoder, uint| -> DecodeResult<T>) -> DecodeResult<T> {\n         debug!(\"read_tuple()\");\n         self.read_seq(f)\n     }\n \n-    fn read_tuple_arg<T>(&mut self, idx: uint, f: |&mut Decoder| -> T) -> T {\n+    fn read_tuple_arg<T>(&mut self,\n+                         idx: uint,\n+                         f: |&mut Decoder| -> DecodeResult<T>) -> DecodeResult<T> {\n         debug!(\"read_tuple_arg(idx={})\", idx);\n         self.read_seq_elt(idx, f)\n     }\n \n     fn read_tuple_struct<T>(&mut self,\n                             name: &str,\n-                            f: |&mut Decoder, uint| -> T)\n-                            -> T {\n+                            f: |&mut Decoder, uint| -> DecodeResult<T>)\n+                            -> DecodeResult<T> {\n         debug!(\"read_tuple_struct(name={})\", name);\n         self.read_tuple(f)\n     }\n \n     fn read_tuple_struct_arg<T>(&mut self,\n                                 idx: uint,\n-                                f: |&mut Decoder| -> T)\n-                                -> T {\n+                                f: |&mut Decoder| -> DecodeResult<T>)\n+                                -> DecodeResult<T> {\n         debug!(\"read_tuple_struct_arg(idx={})\", idx);\n         self.read_tuple_arg(idx, f)\n     }\n \n-    fn read_option<T>(&mut self, f: |&mut Decoder, bool| -> T) -> T {\n-        match self.stack.pop().unwrap() {\n+    fn read_option<T>(&mut self, f: |&mut Decoder, bool| -> DecodeResult<T>) -> DecodeResult<T> {\n+        match self.pop() {\n             Null => f(self, false),\n             value => { self.stack.push(value); f(self, true) }\n         }\n     }\n \n-    fn read_seq<T>(&mut self, f: |&mut Decoder, uint| -> T) -> T {\n+    fn read_seq<T>(&mut self, f: |&mut Decoder, uint| -> DecodeResult<T>) -> DecodeResult<T> {\n         debug!(\"read_seq()\");\n-        let len = match self.stack.pop().unwrap() {\n-            List(list) => {\n-                let len = list.len();\n-                for v in list.move_rev_iter() {\n-                    self.stack.push(v);\n-                }\n-                len\n-            }\n-            value => self.expected(\"list\", &value)\n-        };\n+        let list = try!(expect!(self.pop(), List));\n+        let len = list.len();\n+        for v in list.move_rev_iter() {\n+            self.stack.push(v);\n+        }\n         f(self, len)\n     }\n \n-    fn read_seq_elt<T>(&mut self, idx: uint, f: |&mut Decoder| -> T) -> T {\n+    fn read_seq_elt<T>(&mut self,\n+                       idx: uint,\n+                       f: |&mut Decoder| -> DecodeResult<T>) -> DecodeResult<T> {\n         debug!(\"read_seq_elt(idx={})\", idx);\n         f(self)\n     }\n \n-    fn read_map<T>(&mut self, f: |&mut Decoder, uint| -> T) -> T {\n+    fn read_map<T>(&mut self, f: |&mut Decoder, uint| -> DecodeResult<T>) -> DecodeResult<T> {\n         debug!(\"read_map()\");\n-        let len = match self.stack.pop().unwrap() {\n-            Object(obj) => {\n-                let len = obj.len();\n-                for (key, value) in obj.move_iter() {\n-                    self.stack.push(value);\n-                    self.stack.push(String(key));\n-                }\n-                len\n-            }\n-            value => self.expected(\"object\", &value)\n-        };\n+        let obj = try!(expect!(self.pop(), Object));\n+        let len = obj.len();\n+        for (key, value) in obj.move_iter() {\n+            self.stack.push(value);\n+            self.stack.push(String(key));\n+        }\n         f(self, len)\n     }\n \n-    fn read_map_elt_key<T>(&mut self, idx: uint, f: |&mut Decoder| -> T)\n-                           -> T {\n+    fn read_map_elt_key<T>(&mut self, idx: uint, f: |&mut Decoder| -> DecodeResult<T>)\n+                           -> DecodeResult<T> {\n         debug!(\"read_map_elt_key(idx={})\", idx);\n         f(self)\n     }\n \n-    fn read_map_elt_val<T>(&mut self, idx: uint, f: |&mut Decoder| -> T)\n-                           -> T {\n+    fn read_map_elt_val<T>(&mut self, idx: uint, f: |&mut Decoder| -> DecodeResult<T>)\n+                           -> DecodeResult<T> {\n         debug!(\"read_map_elt_val(idx={})\", idx);\n         f(self)\n     }\n@@ -1735,17 +1745,12 @@ impl fmt::Show for Json {\n     }\n }\n \n-impl fmt::Show for Error {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f.buf, \"{}:{}: {}\", self.line, self.col, self.msg)\n-    }\n-}\n-\n #[cfg(test)]\n mod tests {\n     use {Encodable, Decodable};\n     use super::{Encoder, Decoder, Error, Boolean, Number, List, String, Null,\n-                PrettyEncoder, Object, Json, from_str};\n+                PrettyEncoder, Object, Json, from_str, ParseError, ExpectedError,\n+                MissingFieldError, UnknownVariantError, DecodeResult };\n     use std::io;\n     use collections::TreeMap;\n \n@@ -1931,14 +1936,14 @@ mod tests {\n         assert_eq!(\n             with_str_writer(|wr| {\n                 let mut encoder = Encoder::new(wr);\n-                animal.encode(&mut encoder);\n+                animal.encode(&mut encoder).unwrap();\n             }),\n             ~\"\\\"Dog\\\"\"\n         );\n         assert_eq!(\n             with_str_writer(|wr| {\n                 let mut encoder = PrettyEncoder::new(wr);\n-                animal.encode(&mut encoder);\n+                animal.encode(&mut encoder).unwrap();\n             }),\n             ~\"\\\"Dog\\\"\"\n         );\n@@ -1947,14 +1952,14 @@ mod tests {\n         assert_eq!(\n             with_str_writer(|wr| {\n                 let mut encoder = Encoder::new(wr);\n-                animal.encode(&mut encoder);\n+                animal.encode(&mut encoder).unwrap();\n             }),\n             ~\"{\\\"variant\\\":\\\"Frog\\\",\\\"fields\\\":[\\\"Henry\\\",349]}\"\n         );\n         assert_eq!(\n             with_str_writer(|wr| {\n                 let mut encoder = PrettyEncoder::new(wr);\n-                animal.encode(&mut encoder);\n+                animal.encode(&mut encoder).unwrap();\n             }),\n             ~\"\\\n             [\\n  \\\n@@ -1970,14 +1975,14 @@ mod tests {\n         let value = Some(~\"jodhpurs\");\n         let s = with_str_writer(|wr| {\n             let mut encoder = Encoder::new(wr);\n-            value.encode(&mut encoder);\n+            value.encode(&mut encoder).unwrap();\n         });\n         assert_eq!(s, ~\"\\\"jodhpurs\\\"\");\n \n         let value = Some(~\"jodhpurs\");\n         let s = with_str_writer(|wr| {\n             let mut encoder = PrettyEncoder::new(wr);\n-            value.encode(&mut encoder);\n+            value.encode(&mut encoder).unwrap();\n         });\n         assert_eq!(s, ~\"\\\"jodhpurs\\\"\");\n     }\n@@ -1987,49 +1992,49 @@ mod tests {\n         let value: Option<~str> = None;\n         let s = with_str_writer(|wr| {\n             let mut encoder = Encoder::new(wr);\n-            value.encode(&mut encoder);\n+            value.encode(&mut encoder).unwrap();\n         });\n         assert_eq!(s, ~\"null\");\n \n         let s = with_str_writer(|wr| {\n             let mut encoder = Encoder::new(wr);\n-            value.encode(&mut encoder);\n+            value.encode(&mut encoder).unwrap();\n         });\n         assert_eq!(s, ~\"null\");\n     }\n \n     #[test]\n     fn test_trailing_characters() {\n         assert_eq!(from_str(\"nulla\"),\n-            Err(Error {line: 1u, col: 5u, msg: ~\"trailing characters\"}));\n+            Err(ParseError(~\"trailing characters\", 1u, 5u)));\n         assert_eq!(from_str(\"truea\"),\n-            Err(Error {line: 1u, col: 5u, msg: ~\"trailing characters\"}));\n+            Err(ParseError(~\"trailing characters\", 1u, 5u)));\n         assert_eq!(from_str(\"falsea\"),\n-            Err(Error {line: 1u, col: 6u, msg: ~\"trailing characters\"}));\n+            Err(ParseError(~\"trailing characters\", 1u, 6u)));\n         assert_eq!(from_str(\"1a\"),\n-            Err(Error {line: 1u, col: 2u, msg: ~\"trailing characters\"}));\n+            Err(ParseError(~\"trailing characters\", 1u, 2u)));\n         assert_eq!(from_str(\"[]a\"),\n-            Err(Error {line: 1u, col: 3u, msg: ~\"trailing characters\"}));\n+            Err(ParseError(~\"trailing characters\", 1u, 3u)));\n         assert_eq!(from_str(\"{}a\"),\n-            Err(Error {line: 1u, col: 3u, msg: ~\"trailing characters\"}));\n+            Err(ParseError(~\"trailing characters\", 1u, 3u)));\n     }\n \n     #[test]\n     fn test_read_identifiers() {\n         assert_eq!(from_str(\"n\"),\n-            Err(Error {line: 1u, col: 2u, msg: ~\"invalid syntax\"}));\n+            Err(ParseError(~\"invalid syntax\", 1u, 2u)));\n         assert_eq!(from_str(\"nul\"),\n-            Err(Error {line: 1u, col: 4u, msg: ~\"invalid syntax\"}));\n+            Err(ParseError(~\"invalid syntax\", 1u, 4u)));\n \n         assert_eq!(from_str(\"t\"),\n-            Err(Error {line: 1u, col: 2u, msg: ~\"invalid syntax\"}));\n+            Err(ParseError(~\"invalid syntax\", 1u, 2u)));\n         assert_eq!(from_str(\"truz\"),\n-            Err(Error {line: 1u, col: 4u, msg: ~\"invalid syntax\"}));\n+            Err(ParseError(~\"invalid syntax\", 1u, 4u)));\n \n         assert_eq!(from_str(\"f\"),\n-            Err(Error {line: 1u, col: 2u, msg: ~\"invalid syntax\"}));\n+            Err(ParseError(~\"invalid syntax\", 1u, 2u)));\n         assert_eq!(from_str(\"faz\"),\n-            Err(Error {line: 1u, col: 3u, msg: ~\"invalid syntax\"}));\n+            Err(ParseError(~\"invalid syntax\", 1u, 3u)));\n \n         assert_eq!(from_str(\"null\"), Ok(Null));\n         assert_eq!(from_str(\"true\"), Ok(Boolean(true)));\n@@ -2042,35 +2047,35 @@ mod tests {\n     #[test]\n     fn test_decode_identifiers() {\n         let mut decoder = Decoder::new(from_str(\"null\").unwrap());\n-        let v: () = Decodable::decode(&mut decoder);\n+        let v: () = Decodable::decode(&mut decoder).unwrap();\n         assert_eq!(v, ());\n \n         let mut decoder = Decoder::new(from_str(\"true\").unwrap());\n-        let v: bool = Decodable::decode(&mut decoder);\n+        let v: bool = Decodable::decode(&mut decoder).unwrap();\n         assert_eq!(v, true);\n \n         let mut decoder = Decoder::new(from_str(\"false\").unwrap());\n-        let v: bool = Decodable::decode(&mut decoder);\n+        let v: bool = Decodable::decode(&mut decoder).unwrap();\n         assert_eq!(v, false);\n     }\n \n     #[test]\n     fn test_read_number() {\n         assert_eq!(from_str(\"+\"),\n-            Err(Error {line: 1u, col: 1u, msg: ~\"invalid syntax\"}));\n+            Err(ParseError(~\"invalid syntax\", 1u, 1u)));\n         assert_eq!(from_str(\".\"),\n-            Err(Error {line: 1u, col: 1u, msg: ~\"invalid syntax\"}));\n+            Err(ParseError(~\"invalid syntax\", 1u, 1u)));\n \n         assert_eq!(from_str(\"-\"),\n-            Err(Error {line: 1u, col: 2u, msg: ~\"invalid number\"}));\n+            Err(ParseError(~\"invalid number\", 1u, 2u)));\n         assert_eq!(from_str(\"00\"),\n-            Err(Error {line: 1u, col: 2u, msg: ~\"invalid number\"}));\n+            Err(ParseError(~\"invalid number\", 1u, 2u)));\n         assert_eq!(from_str(\"1.\"),\n-            Err(Error {line: 1u, col: 3u, msg: ~\"invalid number\"}));\n+            Err(ParseError(~\"invalid number\", 1u, 3u)));\n         assert_eq!(from_str(\"1e\"),\n-            Err(Error {line: 1u, col: 3u, msg: ~\"invalid number\"}));\n+            Err(ParseError(~\"invalid number\", 1u, 3u)));\n         assert_eq!(from_str(\"1e+\"),\n-            Err(Error {line: 1u, col: 4u, msg: ~\"invalid number\"}));\n+            Err(ParseError(~\"invalid number\", 1u, 4u)));\n \n         assert_eq!(from_str(\"3\"), Ok(Number(3.0)));\n         assert_eq!(from_str(\"3.1\"), Ok(Number(3.1)));\n@@ -2085,42 +2090,40 @@ mod tests {\n     #[test]\n     fn test_decode_numbers() {\n         let mut decoder = Decoder::new(from_str(\"3\").unwrap());\n-        let v: f64 = Decodable::decode(&mut decoder);\n+        let v: f64 = Decodable::decode(&mut decoder).unwrap();\n         assert_eq!(v, 3.0);\n \n         let mut decoder = Decoder::new(from_str(\"3.1\").unwrap());\n-        let v: f64 = Decodable::decode(&mut decoder);\n+        let v: f64 = Decodable::decode(&mut decoder).unwrap();\n         assert_eq!(v, 3.1);\n \n         let mut decoder = Decoder::new(from_str(\"-1.2\").unwrap());\n-        let v: f64 = Decodable::decode(&mut decoder);\n+        let v: f64 = Decodable::decode(&mut decoder).unwrap();\n         assert_eq!(v, -1.2);\n \n         let mut decoder = Decoder::new(from_str(\"0.4\").unwrap());\n-        let v: f64 = Decodable::decode(&mut decoder);\n+        let v: f64 = Decodable::decode(&mut decoder).unwrap();\n         assert_eq!(v, 0.4);\n \n         let mut decoder = Decoder::new(from_str(\"0.4e5\").unwrap());\n-        let v: f64 = Decodable::decode(&mut decoder);\n+        let v: f64 = Decodable::decode(&mut decoder).unwrap();\n         assert_eq!(v, 0.4e5);\n \n         let mut decoder = Decoder::new(from_str(\"0.4e15\").unwrap());\n-        let v: f64 = Decodable::decode(&mut decoder);\n+        let v: f64 = Decodable::decode(&mut decoder).unwrap();\n         assert_eq!(v, 0.4e15);\n \n         let mut decoder = Decoder::new(from_str(\"0.4e-01\").unwrap());\n-        let v: f64 = Decodable::decode(&mut decoder);\n+        let v: f64 = Decodable::decode(&mut decoder).unwrap();\n         assert_eq!(v, 0.4e-01);\n     }\n \n     #[test]\n     fn test_read_str() {\n         assert_eq!(from_str(\"\\\"\"),\n-            Err(Error {line: 1u, col: 2u, msg: ~\"EOF while parsing string\"\n-        }));\n+            Err(ParseError(~\"EOF while parsing string\", 1u, 2u)));\n         assert_eq!(from_str(\"\\\"lol\"),\n-            Err(Error {line: 1u, col: 5u, msg: ~\"EOF while parsing string\"\n-        }));\n+            Err(ParseError(~\"EOF while parsing string\", 1u, 5u)));\n \n         assert_eq!(from_str(\"\\\"\\\"\"), Ok(String(~\"\")));\n         assert_eq!(from_str(\"\\\"foo\\\"\"), Ok(String(~\"foo\")));\n@@ -2137,54 +2140,54 @@ mod tests {\n     #[test]\n     fn test_decode_str() {\n         let mut decoder = Decoder::new(from_str(\"\\\"\\\"\").unwrap());\n-        let v: ~str = Decodable::decode(&mut decoder);\n+        let v: ~str = Decodable::decode(&mut decoder).unwrap();\n         assert_eq!(v, ~\"\");\n \n         let mut decoder = Decoder::new(from_str(\"\\\"foo\\\"\").unwrap());\n-        let v: ~str = Decodable::decode(&mut decoder);\n+        let v: ~str = Decodable::decode(&mut decoder).unwrap();\n         assert_eq!(v, ~\"foo\");\n \n         let mut decoder = Decoder::new(from_str(\"\\\"\\\\\\\"\\\"\").unwrap());\n-        let v: ~str = Decodable::decode(&mut decoder);\n+        let v: ~str = Decodable::decode(&mut decoder).unwrap();\n         assert_eq!(v, ~\"\\\"\");\n \n         let mut decoder = Decoder::new(from_str(\"\\\"\\\\b\\\"\").unwrap());\n-        let v: ~str = Decodable::decode(&mut decoder);\n+        let v: ~str = Decodable::decode(&mut decoder).unwrap();\n         assert_eq!(v, ~\"\\x08\");\n \n         let mut decoder = Decoder::new(from_str(\"\\\"\\\\n\\\"\").unwrap());\n-        let v: ~str = Decodable::decode(&mut decoder);\n+        let v: ~str = Decodable::decode(&mut decoder).unwrap();\n         assert_eq!(v, ~\"\\n\");\n \n         let mut decoder = Decoder::new(from_str(\"\\\"\\\\r\\\"\").unwrap());\n-        let v: ~str = Decodable::decode(&mut decoder);\n+        let v: ~str = Decodable::decode(&mut decoder).unwrap();\n         assert_eq!(v, ~\"\\r\");\n \n         let mut decoder = Decoder::new(from_str(\"\\\"\\\\t\\\"\").unwrap());\n-        let v: ~str = Decodable::decode(&mut decoder);\n+        let v: ~str = Decodable::decode(&mut decoder).unwrap();\n         assert_eq!(v, ~\"\\t\");\n \n         let mut decoder = Decoder::new(from_str(\"\\\"\\\\u12ab\\\"\").unwrap());\n-        let v: ~str = Decodable::decode(&mut decoder);\n+        let v: ~str = Decodable::decode(&mut decoder).unwrap();\n         assert_eq!(v, ~\"\\u12ab\");\n \n         let mut decoder = Decoder::new(from_str(\"\\\"\\\\uAB12\\\"\").unwrap());\n-        let v: ~str = Decodable::decode(&mut decoder);\n+        let v: ~str = Decodable::decode(&mut decoder).unwrap();\n         assert_eq!(v, ~\"\\uAB12\");\n     }\n \n     #[test]\n     fn test_read_list() {\n         assert_eq!(from_str(\"[\"),\n-            Err(Error {line: 1u, col: 2u, msg: ~\"EOF while parsing value\"}));\n+            Err(ParseError(~\"EOF while parsing value\", 1u, 2u)));\n         assert_eq!(from_str(\"[1\"),\n-            Err(Error {line: 1u, col: 3u, msg: ~\"EOF while parsing list\"}));\n+            Err(ParseError(~\"EOF while parsing list\", 1u, 3u)));\n         assert_eq!(from_str(\"[1,\"),\n-            Err(Error {line: 1u, col: 4u, msg: ~\"EOF while parsing value\"}));\n+            Err(ParseError(~\"EOF while parsing value\", 1u, 4u)));\n         assert_eq!(from_str(\"[1,]\"),\n-            Err(Error {line: 1u, col: 4u, msg: ~\"invalid syntax\"}));\n+            Err(ParseError(~\"invalid syntax\", 1u, 4u)));\n         assert_eq!(from_str(\"[6 7]\"),\n-            Err(Error {line: 1u, col: 4u, msg: ~\"expected `,` or `]`\"}));\n+            Err(ParseError(~\"expected `,` or `]`\", 1u, 4u)));\n \n         assert_eq!(from_str(\"[]\"), Ok(List(~[])));\n         assert_eq!(from_str(\"[ ]\"), Ok(List(~[])));\n@@ -2202,79 +2205,55 @@ mod tests {\n     #[test]\n     fn test_decode_list() {\n         let mut decoder = Decoder::new(from_str(\"[]\").unwrap());\n-        let v: ~[()] = Decodable::decode(&mut decoder);\n+        let v: ~[()] = Decodable::decode(&mut decoder).unwrap();\n         assert_eq!(v, ~[]);\n \n         let mut decoder = Decoder::new(from_str(\"[null]\").unwrap());\n-        let v: ~[()] = Decodable::decode(&mut decoder);\n+        let v: ~[()] = Decodable::decode(&mut decoder).unwrap();\n         assert_eq!(v, ~[()]);\n \n         let mut decoder = Decoder::new(from_str(\"[true]\").unwrap());\n-        let v: ~[bool] = Decodable::decode(&mut decoder);\n+        let v: ~[bool] = Decodable::decode(&mut decoder).unwrap();\n         assert_eq!(v, ~[true]);\n \n         let mut decoder = Decoder::new(from_str(\"[true]\").unwrap());\n-        let v: ~[bool] = Decodable::decode(&mut decoder);\n+        let v: ~[bool] = Decodable::decode(&mut decoder).unwrap();\n         assert_eq!(v, ~[true]);\n \n         let mut decoder = Decoder::new(from_str(\"[3, 1]\").unwrap());\n-        let v: ~[int] = Decodable::decode(&mut decoder);\n+        let v: ~[int] = Decodable::decode(&mut decoder).unwrap();\n         assert_eq!(v, ~[3, 1]);\n \n         let mut decoder = Decoder::new(from_str(\"[[3], [1, 2]]\").unwrap());\n-        let v: ~[~[uint]] = Decodable::decode(&mut decoder);\n+        let v: ~[~[uint]] = Decodable::decode(&mut decoder).unwrap();\n         assert_eq!(v, ~[~[3], ~[1, 2]]);\n     }\n \n     #[test]\n     fn test_read_object() {\n         assert_eq!(from_str(\"{\"),\n-            Err(Error {\n-                line: 1u,\n-                col: 2u,\n-                msg: ~\"EOF while parsing object\"}));\n+            Err(ParseError(~\"EOF while parsing object\", 1u, 2u)));\n         assert_eq!(from_str(\"{ \"),\n-            Err(Error {\n-                line: 1u,\n-                col: 3u,\n-                msg: ~\"EOF while parsing object\"}));\n+            Err(ParseError(~\"EOF while parsing object\", 1u, 3u)));\n         assert_eq!(from_str(\"{1\"),\n-            Err(Error {\n-                line: 1u,\n-                col: 2u,\n-                msg: ~\"key must be a string\"}));\n+            Err(ParseError(~\"key must be a string\", 1u, 2u)));\n         assert_eq!(from_str(\"{ \\\"a\\\"\"),\n-            Err(Error {\n-                line: 1u,\n-                col: 6u,\n-                msg: ~\"EOF while parsing object\"}));\n+            Err(ParseError(~\"EOF while parsing object\", 1u, 6u)));\n         assert_eq!(from_str(\"{\\\"a\\\"\"),\n-            Err(Error {\n-                line: 1u,\n-                col: 5u,\n-                msg: ~\"EOF while parsing object\"}));\n+            Err(ParseError(~\"EOF while parsing object\", 1u, 5u)));\n         assert_eq!(from_str(\"{\\\"a\\\" \"),\n-            Err(Error {\n-                line: 1u,\n-                col: 6u,\n-                msg: ~\"EOF while parsing object\"}));\n+            Err(ParseError(~\"EOF while parsing object\", 1u, 6u)));\n \n         assert_eq!(from_str(\"{\\\"a\\\" 1\"),\n-            Err(Error {line: 1u, col: 6u, msg: ~\"expected `:`\"}));\n+            Err(ParseError(~\"expected `:`\", 1u, 6u)));\n         assert_eq!(from_str(\"{\\\"a\\\":\"),\n-            Err(Error {line: 1u, col: 6u, msg: ~\"EOF while parsing value\"}));\n+            Err(ParseError(~\"EOF while parsing value\", 1u, 6u)));\n         assert_eq!(from_str(\"{\\\"a\\\":1\"),\n-            Err(Error {\n-                line: 1u,\n-                col: 7u,\n-                msg: ~\"EOF while parsing object\"}));\n+            Err(ParseError(~\"EOF while parsing object\", 1u, 7u)));\n         assert_eq!(from_str(\"{\\\"a\\\":1 1\"),\n-            Err(Error {line: 1u, col: 8u, msg: ~\"expected `,` or `}`\"}));\n+            Err(ParseError(~\"expected `,` or `}`\", 1u, 8u)));\n         assert_eq!(from_str(\"{\\\"a\\\":1,\"),\n-            Err(Error {\n-                line: 1u,\n-                col: 8u,\n-                msg: ~\"EOF while parsing object\"}));\n+            Err(ParseError(~\"EOF while parsing object\", 1u, 8u)));\n \n         assert_eq!(from_str(\"{}\").unwrap(), mk_object([]));\n         assert_eq!(from_str(\"{\\\"a\\\": 3}\").unwrap(),\n@@ -2324,7 +2303,7 @@ mod tests {\n             ]\n         }\";\n         let mut decoder = Decoder::new(from_str(s).unwrap());\n-        let v: Outer = Decodable::decode(&mut decoder);\n+        let v: Outer = Decodable::decode(&mut decoder).unwrap();\n         assert_eq!(\n             v,\n             Outer {\n@@ -2338,31 +2317,31 @@ mod tests {\n     #[test]\n     fn test_decode_option() {\n         let mut decoder = Decoder::new(from_str(\"null\").unwrap());\n-        let value: Option<~str> = Decodable::decode(&mut decoder);\n+        let value: Option<~str> = Decodable::decode(&mut decoder).unwrap();\n         assert_eq!(value, None);\n \n         let mut decoder = Decoder::new(from_str(\"\\\"jodhpurs\\\"\").unwrap());\n-        let value: Option<~str> = Decodable::decode(&mut decoder);\n+        let value: Option<~str> = Decodable::decode(&mut decoder).unwrap();\n         assert_eq!(value, Some(~\"jodhpurs\"));\n     }\n \n     #[test]\n     fn test_decode_enum() {\n         let mut decoder = Decoder::new(from_str(\"\\\"Dog\\\"\").unwrap());\n-        let value: Animal = Decodable::decode(&mut decoder);\n+        let value: Animal = Decodable::decode(&mut decoder).unwrap();\n         assert_eq!(value, Dog);\n \n         let s = \"{\\\"variant\\\":\\\"Frog\\\",\\\"fields\\\":[\\\"Henry\\\",349]}\";\n         let mut decoder = Decoder::new(from_str(s).unwrap());\n-        let value: Animal = Decodable::decode(&mut decoder);\n+        let value: Animal = Decodable::decode(&mut decoder).unwrap();\n         assert_eq!(value, Frog(~\"Henry\", 349));\n     }\n \n     #[test]\n     fn test_decode_map() {\n         let s = ~\"{\\\"a\\\": \\\"Dog\\\", \\\"b\\\": {\\\"variant\\\":\\\"Frog\\\",\\\"fields\\\":[\\\"Henry\\\", 349]}}\";\n         let mut decoder = Decoder::new(from_str(s).unwrap());\n-        let mut map: TreeMap<~str, Animal> = Decodable::decode(&mut decoder);\n+        let mut map: TreeMap<~str, Animal> = Decodable::decode(&mut decoder).unwrap();\n \n         assert_eq!(map.pop(&~\"a\"), Some(Dog));\n         assert_eq!(map.pop(&~\"b\"), Some(Frog(~\"Henry\", 349)));\n@@ -2371,10 +2350,7 @@ mod tests {\n     #[test]\n     fn test_multiline_errors() {\n         assert_eq!(from_str(\"{\\n  \\\"foo\\\":\\n \\\"bar\\\"\"),\n-            Err(Error {\n-                line: 3u,\n-                col: 8u,\n-                msg: ~\"EOF while parsing object\"}));\n+            Err(ParseError(~\"EOF while parsing object\", 3u, 8u)));\n     }\n \n     #[deriving(Decodable)]\n@@ -2389,60 +2365,48 @@ mod tests {\n         A(f64),\n         B(~str)\n     }\n-    fn check_err<T: Decodable<Decoder>>(to_parse: &'static str, expected_error: &str) {\n-        use std::any::AnyRefExt;\n-        use std::task;\n-        let res = task::try(proc() {\n-            // either fails in `decode` (which is what we want), or\n-            // returns Some(error_message)/None if the string was\n-            // invalid or valid JSON.\n-            match from_str(to_parse) {\n-                Err(e) => Some(e.to_str()),\n-                Ok(json) => {\n-                    let _: T = Decodable::decode(&mut Decoder::new(json));\n-                    None\n-                }\n-            }\n-        });\n+    fn check_err<T: Decodable<Decoder, Error>>(to_parse: &'static str, expected: Error) {\n+        let res: DecodeResult<T> = match from_str(to_parse) {\n+            Err(e) => Err(e),\n+            Ok(json) => Decodable::decode(&mut Decoder::new(json))\n+        };\n         match res {\n-            Ok(Some(parse_error)) => fail!(\"`{}` is not valid json: {}\",\n-                                           to_parse, parse_error),\n-            Ok(None) => fail!(\"`{}` parsed & decoded ok, expecting error `{}`\",\n-                              to_parse, expected_error),\n+            Ok(_) => fail!(\"`{}` parsed & decoded ok, expecting error `{}`\",\n+                              to_parse, expected),\n+            Err(ParseError(e, _, _)) => fail!(\"`{}` is not valid json: {}\",\n+                                           to_parse, e),\n             Err(e) => {\n-                let err = e.as_ref::<~str>().unwrap();\n-                assert!(err.contains(expected_error),\n-                        \"`{}` errored incorrectly, found `{}` expecting `{}`\",\n-                        to_parse, *err, expected_error);\n+                assert_eq!(e, expected);\n             }\n+\n         }\n     }\n     #[test]\n     fn test_decode_errors_struct() {\n-        check_err::<DecodeStruct>(\"[]\", \"object but found list\");\n+        check_err::<DecodeStruct>(\"[]\", ExpectedError(~\"Object\", ~\"[]\"));\n         check_err::<DecodeStruct>(\"{\\\"x\\\": true, \\\"y\\\": true, \\\"z\\\": \\\"\\\", \\\"w\\\": []}\",\n-                                  \"number but found boolean\");\n+                                  ExpectedError(~\"Number\", ~\"true\"));\n         check_err::<DecodeStruct>(\"{\\\"x\\\": 1, \\\"y\\\": [], \\\"z\\\": \\\"\\\", \\\"w\\\": []}\",\n-                                  \"boolean but found list\");\n+                                  ExpectedError(~\"Boolean\", ~\"[]\"));\n         check_err::<DecodeStruct>(\"{\\\"x\\\": 1, \\\"y\\\": true, \\\"z\\\": {}, \\\"w\\\": []}\",\n-                                  \"string but found object\");\n+                                  ExpectedError(~\"String\", ~\"{}\"));\n         check_err::<DecodeStruct>(\"{\\\"x\\\": 1, \\\"y\\\": true, \\\"z\\\": \\\"\\\", \\\"w\\\": null}\",\n-                                  \"list but found null\");\n+                                  ExpectedError(~\"List\", ~\"null\"));\n         check_err::<DecodeStruct>(\"{\\\"x\\\": 1, \\\"y\\\": true, \\\"z\\\": \\\"\\\"}\",\n-                                  \"'w' field in object\");\n+                                  MissingFieldError(~\"w\"));\n     }\n     #[test]\n     fn test_decode_errors_enum() {\n         check_err::<DecodeEnum>(\"{}\",\n-                                \"'variant' field in object\");\n+                                MissingFieldError(~\"variant\"));\n         check_err::<DecodeEnum>(\"{\\\"variant\\\": 1}\",\n-                                \"string but found number\");\n+                                ExpectedError(~\"String\", ~\"1\"));\n         check_err::<DecodeEnum>(\"{\\\"variant\\\": \\\"A\\\"}\",\n-                                \"'fields' field in object\");\n+                                MissingFieldError(~\"fields\"));\n         check_err::<DecodeEnum>(\"{\\\"variant\\\": \\\"A\\\", \\\"fields\\\": null}\",\n-                                \"list but found null\");\n+                                ExpectedError(~\"List\", ~\"null\"));\n         check_err::<DecodeEnum>(\"{\\\"variant\\\": \\\"C\\\", \\\"fields\\\": []}\",\n-                                \"unknown variant name\");\n+                                UnknownVariantError(~\"C\"));\n     }\n \n     #[test]\n@@ -2561,7 +2525,7 @@ mod tests {\n         let mut mem_buf = MemWriter::new();\n         {\n             let mut encoder = Encoder::new(&mut mem_buf as &mut io::Writer);\n-            hm.encode(&mut encoder)\n+            hm.encode(&mut encoder).unwrap();\n         }\n         let bytes = mem_buf.unwrap();\n         let json_str = from_utf8(bytes).unwrap();\n@@ -2581,7 +2545,7 @@ mod tests {\n         let mut mem_buf = MemWriter::new();\n         {\n             let mut encoder = PrettyEncoder::new(&mut mem_buf as &mut io::Writer);\n-            hm.encode(&mut encoder)\n+            hm.encode(&mut encoder).unwrap();\n         }\n         let bytes = mem_buf.unwrap();\n         let json_str = from_utf8(bytes).unwrap();\n@@ -2600,6 +2564,6 @@ mod tests {\n             Ok(o) => o\n         };\n         let mut decoder = Decoder::new(json_obj);\n-        let _hm: HashMap<uint, bool> = Decodable::decode(&mut decoder);\n+        let _hm: HashMap<uint, bool> = Decodable::decode(&mut decoder).unwrap();\n     }\n }"}, {"sha": "cc4c86599fae39b623afc4627d95f09f001cd21f", "filename": "src/libserialize/json_old.rs", "status": "added", "additions": 2606, "deletions": 0, "changes": 2606, "blob_url": "https://github.com/rust-lang/rust/blob/f1739b14a1346419a4598339aee32aab07e0d12e/src%2Flibserialize%2Fjson_old.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1739b14a1346419a4598339aee32aab07e0d12e/src%2Flibserialize%2Fjson_old.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson_old.rs?ref=f1739b14a1346419a4598339aee32aab07e0d12e", "patch": "@@ -0,0 +1,2606 @@\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Rust JSON serialization library\n+// Copyright (c) 2011 Google Inc.\n+\n+#[forbid(non_camel_case_types)];\n+#[allow(missing_doc)];\n+\n+/*!\n+JSON parsing and serialization\n+\n+# What is JSON?\n+\n+JSON (JavaScript Object Notation) is a way to write data in Javascript.\n+Like XML it allows one to encode structured data in a text format that can be read by humans easily.\n+Its native compatibility with JavaScript and its simple syntax make it used widely.\n+\n+Json data are encoded in a form of \"key\":\"value\".\n+Data types that can be encoded are JavaScript types :\n+boolean (`true` or `false`), number (`f64`), string, array, object, null.\n+An object is a series of string keys mapping to values, in `\"key\": value` format.\n+Arrays are enclosed in square brackets ([ ... ]) and objects in curly brackets ({ ... }).\n+A simple JSON document encoding a person, his/her age, address and phone numbers could look like:\n+\n+```ignore\n+{\n+    \"FirstName\": \"John\",\n+    \"LastName\": \"Doe\",\n+    \"Age\": 43,\n+    \"Address\": {\n+        \"Street\": \"Downing Street 10\",\n+        \"City\": \"London\",\n+        \"Country\": \"Great Britain\"\n+    },\n+    \"PhoneNumbers\": [\n+        \"+44 1234567\",\n+        \"+44 2345678\"\n+    ]\n+}\n+```\n+\n+# Rust Type-based Encoding and Decoding\n+\n+Rust provides a mechanism for low boilerplate encoding & decoding\n+of values to and from JSON via the serialization API.\n+To be able to encode a piece of data, it must implement the `serialize::Encodable` trait.\n+To be able to decode a piece of data, it must implement the `serialize::Decodable` trait.\n+The Rust compiler provides an annotation to automatically generate\n+the code for these traits: `#[deriving(Decodable, Encodable)]`\n+\n+To encode using Encodable :\n+\n+```rust\n+use std::io;\n+use serialize::{json, Encodable};\n+\n+ #[deriving(Encodable)]\n+ pub struct TestStruct   {\n+    data_str: ~str,\n+ }\n+\n+fn main() {\n+    let to_encode_object = TestStruct{data_str:~\"example of string to encode\"};\n+    let mut m = io::MemWriter::new();\n+    {\n+        let mut encoder = json::Encoder::new(&mut m as &mut std::io::Writer);\n+        to_encode_object.encode(&mut encoder);\n+    }\n+}\n+```\n+\n+Two wrapper functions are provided to encode a Encodable object\n+into a string (~str) or buffer (~[u8]): `str_encode(&m)` and `buffer_encode(&m)`.\n+\n+```rust\n+use serialize::json;\n+let to_encode_object = ~\"example of string to encode\";\n+let encoded_str: ~str = json::Encoder::str_encode(&to_encode_object);\n+```\n+\n+JSON API provide an enum `json::Json` and a trait `ToJson` to encode object.\n+The trait `ToJson` encode object into a container `json::Json` and the API provide writer\n+to encode them into a stream or a string ...\n+\n+When using `ToJson` the `Encodable` trait implementation is not mandatory.\n+\n+A basic `ToJson` example using a TreeMap of attribute name / attribute value:\n+\n+\n+```rust\n+extern crate collections;\n+extern crate serialize;\n+\n+use serialize::json;\n+use serialize::json::ToJson;\n+use collections::TreeMap;\n+\n+pub struct MyStruct  {\n+    attr1: u8,\n+    attr2: ~str,\n+}\n+\n+impl ToJson for MyStruct {\n+    fn to_json( &self ) -> json::Json {\n+        let mut d = ~TreeMap::new();\n+        d.insert(~\"attr1\", self.attr1.to_json());\n+        d.insert(~\"attr2\", self.attr2.to_json());\n+        json::Object(d)\n+    }\n+}\n+\n+fn main() {\n+    let test2: MyStruct = MyStruct {attr1: 1, attr2:~\"test\"};\n+    let tjson: json::Json = test2.to_json();\n+    let json_str: ~str = tjson.to_str();\n+}\n+```\n+\n+To decode a JSON string using `Decodable` trait :\n+\n+```rust\n+extern crate serialize;\n+use serialize::{json, Decodable};\n+\n+#[deriving(Decodable)]\n+pub struct MyStruct  {\n+     attr1: u8,\n+     attr2: ~str,\n+}\n+\n+fn main() {\n+    let json_str_to_decode: ~str =\n+            ~\"{\\\"attr1\\\":1,\\\"attr2\\\":\\\"toto\\\"}\";\n+    let json_object = json::from_str(json_str_to_decode);\n+    let mut decoder = json::Decoder::new(json_object.unwrap());\n+    let decoded_object: MyStruct = Decodable::decode(&mut decoder); // create the final object\n+}\n+```\n+\n+# Examples of use\n+\n+## Using Autoserialization\n+\n+Create a struct called TestStruct1 and serialize and deserialize it to and from JSON\n+using the serialization API, using the derived serialization code.\n+\n+```rust\n+extern crate serialize;\n+use serialize::{json, Encodable, Decodable};\n+\n+ #[deriving(Decodable, Encodable)] //generate Decodable, Encodable impl.\n+ pub struct TestStruct1  {\n+    data_int: u8,\n+    data_str: ~str,\n+    data_vector: ~[u8],\n+ }\n+\n+// To serialize use the `json::str_encode` to encode an object in a string.\n+// It calls the generated `Encodable` impl.\n+fn main() {\n+    let to_encode_object = TestStruct1\n+         {data_int: 1, data_str:~\"toto\", data_vector:~[2,3,4,5]};\n+    let encoded_str: ~str = json::Encoder::str_encode(&to_encode_object);\n+\n+    // To deserialize use the `json::from_str` and `json::Decoder`\n+\n+    let json_object = json::from_str(encoded_str);\n+    let mut decoder = json::Decoder::new(json_object.unwrap());\n+    let decoded1: TestStruct1 = Decodable::decode(&mut decoder); // create the final object\n+}\n+```\n+\n+## Using `ToJson`\n+\n+This example use the ToJson impl to deserialize the JSON string.\n+Example of `ToJson` trait implementation for TestStruct1.\n+\n+```rust\n+extern crate serialize;\n+extern crate collections;\n+\n+use serialize::json::ToJson;\n+use serialize::{json, Encodable, Decodable};\n+use collections::TreeMap;\n+\n+#[deriving(Decodable, Encodable)] // generate Decodable, Encodable impl.\n+pub struct TestStruct1  {\n+    data_int: u8,\n+    data_str: ~str,\n+    data_vector: ~[u8],\n+}\n+\n+impl ToJson for TestStruct1 {\n+    fn to_json( &self ) -> json::Json {\n+        let mut d = ~TreeMap::new();\n+        d.insert(~\"data_int\", self.data_int.to_json());\n+        d.insert(~\"data_str\", self.data_str.to_json());\n+        d.insert(~\"data_vector\", self.data_vector.to_json());\n+        json::Object(d)\n+    }\n+}\n+\n+fn main() {\n+    // Serialization using our impl of to_json\n+\n+    let test2: TestStruct1 = TestStruct1 {data_int: 1, data_str:~\"toto\", data_vector:~[2,3,4,5]};\n+    let tjson: json::Json = test2.to_json();\n+    let json_str: ~str = tjson.to_str();\n+\n+    // Deserialize like before.\n+\n+    let mut decoder = json::Decoder::new(json::from_str(json_str).unwrap());\n+    // create the final object\n+    let decoded2: TestStruct1 = Decodable::decode(&mut decoder);\n+}\n+```\n+\n+*/\n+\n+use std::char;\n+use std::f64;\n+use collections::HashMap;\n+use std::io;\n+use std::io::MemWriter;\n+use std::num;\n+use std::str;\n+use std::fmt;\n+\n+use Encodable;\n+use collections::TreeMap;\n+\n+macro_rules! try( ($e:expr) => (\n+    match $e { Ok(e) => e, Err(e) => { self.error = Err(e); return } }\n+) )\n+\n+/// Represents a json value\n+#[deriving(Clone, Eq)]\n+pub enum Json {\n+    Number(f64),\n+    String(~str),\n+    Boolean(bool),\n+    List(List),\n+    Object(~Object),\n+    Null,\n+}\n+\n+pub type List = ~[Json];\n+pub type Object = TreeMap<~str, Json>;\n+\n+#[deriving(Eq)]\n+/// If an error occurs while parsing some JSON, this is the structure which is\n+/// returned\n+pub struct Error {\n+    /// The line number at which the error occurred\n+    priv line: uint,\n+    /// The column number at which the error occurred\n+    priv col: uint,\n+    /// A message describing the type of the error\n+    priv msg: ~str,\n+}\n+\n+fn io_error_to_error(io: io::IoError) -> Error {\n+    Error {\n+        line: 0,\n+        col: 0,\n+        msg: format!(\"io error: {}\", io)\n+    }\n+}\n+\n+fn escape_str(s: &str) -> ~str {\n+    let mut escaped = ~\"\\\"\";\n+    for c in s.chars() {\n+        match c {\n+          '\"' => escaped.push_str(\"\\\\\\\"\"),\n+          '\\\\' => escaped.push_str(\"\\\\\\\\\"),\n+          '\\x08' => escaped.push_str(\"\\\\b\"),\n+          '\\x0c' => escaped.push_str(\"\\\\f\"),\n+          '\\n' => escaped.push_str(\"\\\\n\"),\n+          '\\r' => escaped.push_str(\"\\\\r\"),\n+          '\\t' => escaped.push_str(\"\\\\t\"),\n+          _ => escaped.push_char(c),\n+        }\n+    };\n+\n+    escaped.push_char('\"');\n+\n+    escaped\n+}\n+\n+fn spaces(n: uint) -> ~str {\n+    let mut ss = ~\"\";\n+    for _ in range(0, n) { ss.push_str(\" \"); }\n+    return ss;\n+}\n+\n+/// A structure for implementing serialization to JSON.\n+pub struct Encoder<'a> {\n+    priv wr: &'a mut io::Writer,\n+    priv error: io::IoResult<()>,\n+}\n+\n+impl<'a> Encoder<'a> {\n+    /// Creates a new JSON encoder whose output will be written to the writer\n+    /// specified.\n+    pub fn new<'a>(wr: &'a mut io::Writer) -> Encoder<'a> {\n+        Encoder { wr: wr, error: Ok(()) }\n+    }\n+\n+    /// Encode the specified struct into a json [u8]\n+    pub fn buffer_encode<T:Encodable<Encoder<'a>>>(to_encode_object: &T) -> ~[u8]  {\n+       //Serialize the object in a string using a writer\n+        let mut m = MemWriter::new();\n+        {\n+            let mut encoder = Encoder::new(&mut m as &mut io::Writer);\n+            to_encode_object.encode(&mut encoder);\n+        }\n+        m.unwrap()\n+    }\n+\n+    /// Encode the specified struct into a json str\n+    pub fn str_encode<T:Encodable<Encoder<'a>>>(to_encode_object: &T) -> ~str  {\n+        let buff:~[u8] = Encoder::buffer_encode(to_encode_object);\n+        str::from_utf8_owned(buff).unwrap()\n+    }\n+}\n+\n+impl<'a> ::Encoder for Encoder<'a> {\n+    fn emit_nil(&mut self) { try!(write!(self.wr, \"null\")) }\n+\n+    fn emit_uint(&mut self, v: uint) { self.emit_f64(v as f64); }\n+    fn emit_u64(&mut self, v: u64) { self.emit_f64(v as f64); }\n+    fn emit_u32(&mut self, v: u32) { self.emit_f64(v as f64); }\n+    fn emit_u16(&mut self, v: u16) { self.emit_f64(v as f64); }\n+    fn emit_u8(&mut self, v: u8)   { self.emit_f64(v as f64); }\n+\n+    fn emit_int(&mut self, v: int) { self.emit_f64(v as f64); }\n+    fn emit_i64(&mut self, v: i64) { self.emit_f64(v as f64); }\n+    fn emit_i32(&mut self, v: i32) { self.emit_f64(v as f64); }\n+    fn emit_i16(&mut self, v: i16) { self.emit_f64(v as f64); }\n+    fn emit_i8(&mut self, v: i8)   { self.emit_f64(v as f64); }\n+\n+    fn emit_bool(&mut self, v: bool) {\n+        if v {\n+            try!(write!(self.wr, \"true\"));\n+        } else {\n+            try!(write!(self.wr, \"false\"));\n+        }\n+    }\n+\n+    fn emit_f64(&mut self, v: f64) {\n+        try!(write!(self.wr, \"{}\", f64::to_str_digits(v, 6u)))\n+    }\n+    fn emit_f32(&mut self, v: f32) { self.emit_f64(v as f64); }\n+\n+    fn emit_char(&mut self, v: char) { self.emit_str(str::from_char(v)) }\n+    fn emit_str(&mut self, v: &str) {\n+        try!(write!(self.wr, \"{}\", escape_str(v)))\n+    }\n+\n+    fn emit_enum(&mut self, _name: &str, f: |&mut Encoder<'a>|) { f(self) }\n+\n+    fn emit_enum_variant(&mut self,\n+                         name: &str,\n+                         _id: uint,\n+                         cnt: uint,\n+                         f: |&mut Encoder<'a>|) {\n+        // enums are encoded as strings or objects\n+        // Bunny => \"Bunny\"\n+        // Kangaroo(34,\"William\") => {\"variant\": \"Kangaroo\", \"fields\": [34,\"William\"]}\n+        if cnt == 0 {\n+            try!(write!(self.wr, \"{}\", escape_str(name)));\n+        } else {\n+            try!(write!(self.wr, \"\\\\{\\\"variant\\\":\"));\n+            try!(write!(self.wr, \"{}\", escape_str(name)));\n+            try!(write!(self.wr, \",\\\"fields\\\":[\"));\n+            f(self);\n+            try!(write!(self.wr, \"]\\\\}\"));\n+        }\n+    }\n+\n+    fn emit_enum_variant_arg(&mut self, idx: uint, f: |&mut Encoder<'a>|) {\n+        if idx != 0 {\n+            try!(write!(self.wr, \",\"));\n+        }\n+        f(self);\n+    }\n+\n+    fn emit_enum_struct_variant(&mut self,\n+                                name: &str,\n+                                id: uint,\n+                                cnt: uint,\n+                                f: |&mut Encoder<'a>|) {\n+        self.emit_enum_variant(name, id, cnt, f)\n+    }\n+\n+    fn emit_enum_struct_variant_field(&mut self,\n+                                      _: &str,\n+                                      idx: uint,\n+                                      f: |&mut Encoder<'a>|) {\n+        self.emit_enum_variant_arg(idx, f)\n+    }\n+\n+    fn emit_struct(&mut self, _: &str, _: uint, f: |&mut Encoder<'a>|) {\n+        try!(write!(self.wr, r\"\\{\"));\n+        f(self);\n+        try!(write!(self.wr, r\"\\}\"));\n+    }\n+\n+    fn emit_struct_field(&mut self,\n+                         name: &str,\n+                         idx: uint,\n+                         f: |&mut Encoder<'a>|) {\n+        if idx != 0 { try!(write!(self.wr, \",\")) }\n+        try!(write!(self.wr, \"{}:\", escape_str(name)));\n+        f(self);\n+    }\n+\n+    fn emit_tuple(&mut self, len: uint, f: |&mut Encoder<'a>|) {\n+        self.emit_seq(len, f)\n+    }\n+    fn emit_tuple_arg(&mut self, idx: uint, f: |&mut Encoder<'a>|) {\n+        self.emit_seq_elt(idx, f)\n+    }\n+\n+    fn emit_tuple_struct(&mut self,\n+                         _name: &str,\n+                         len: uint,\n+                         f: |&mut Encoder<'a>|) {\n+        self.emit_seq(len, f)\n+    }\n+    fn emit_tuple_struct_arg(&mut self, idx: uint, f: |&mut Encoder<'a>|) {\n+        self.emit_seq_elt(idx, f)\n+    }\n+\n+    fn emit_option(&mut self, f: |&mut Encoder<'a>|) { f(self); }\n+    fn emit_option_none(&mut self) { self.emit_nil(); }\n+    fn emit_option_some(&mut self, f: |&mut Encoder<'a>|) { f(self); }\n+\n+    fn emit_seq(&mut self, _len: uint, f: |&mut Encoder<'a>|) {\n+        try!(write!(self.wr, \"[\"));\n+        f(self);\n+        try!(write!(self.wr, \"]\"));\n+    }\n+\n+    fn emit_seq_elt(&mut self, idx: uint, f: |&mut Encoder<'a>|) {\n+        if idx != 0 {\n+            try!(write!(self.wr, \",\"));\n+        }\n+        f(self)\n+    }\n+\n+    fn emit_map(&mut self, _len: uint, f: |&mut Encoder<'a>|) {\n+        try!(write!(self.wr, r\"\\{\"));\n+        f(self);\n+        try!(write!(self.wr, r\"\\}\"));\n+    }\n+\n+    fn emit_map_elt_key(&mut self, idx: uint, f: |&mut Encoder<'a>|) {\n+        use std::str::from_utf8;\n+        if idx != 0 { try!(write!(self.wr, \",\")) }\n+        // ref #12967, make sure to wrap a key in double quotes,\n+        // in the event that its of a type that omits them (eg numbers)\n+        let mut buf = MemWriter::new();\n+        let mut check_encoder = Encoder::new(&mut buf);\n+        f(&mut check_encoder);\n+        let buf = buf.unwrap();\n+        let out = from_utf8(buf).unwrap();\n+        let needs_wrapping = out.char_at(0) != '\"' &&\n+            out.char_at_reverse(out.len()) != '\"';\n+        if needs_wrapping { try!(write!(self.wr, \"\\\"\")); }\n+        f(self);\n+        if needs_wrapping { try!(write!(self.wr, \"\\\"\")); }\n+    }\n+\n+    fn emit_map_elt_val(&mut self, _idx: uint, f: |&mut Encoder<'a>|) {\n+        try!(write!(self.wr, \":\"));\n+        f(self)\n+    }\n+}\n+\n+/// Another encoder for JSON, but prints out human-readable JSON instead of\n+/// compact data\n+pub struct PrettyEncoder<'a> {\n+    priv wr: &'a mut io::Writer,\n+    priv indent: uint,\n+    priv error: io::IoResult<()>,\n+}\n+\n+impl<'a> PrettyEncoder<'a> {\n+    /// Creates a new encoder whose output will be written to the specified writer\n+    pub fn new<'a>(wr: &'a mut io::Writer) -> PrettyEncoder<'a> {\n+        PrettyEncoder {\n+            wr: wr,\n+            indent: 0,\n+            error: Ok(())\n+        }\n+    }\n+}\n+\n+impl<'a> ::Encoder for PrettyEncoder<'a> {\n+    fn emit_nil(&mut self) { try!(write!(self.wr, \"null\")); }\n+\n+    fn emit_uint(&mut self, v: uint) { self.emit_f64(v as f64); }\n+    fn emit_u64(&mut self, v: u64) { self.emit_f64(v as f64); }\n+    fn emit_u32(&mut self, v: u32) { self.emit_f64(v as f64); }\n+    fn emit_u16(&mut self, v: u16) { self.emit_f64(v as f64); }\n+    fn emit_u8(&mut self, v: u8)   { self.emit_f64(v as f64); }\n+\n+    fn emit_int(&mut self, v: int) { self.emit_f64(v as f64); }\n+    fn emit_i64(&mut self, v: i64) { self.emit_f64(v as f64); }\n+    fn emit_i32(&mut self, v: i32) { self.emit_f64(v as f64); }\n+    fn emit_i16(&mut self, v: i16) { self.emit_f64(v as f64); }\n+    fn emit_i8(&mut self, v: i8)   { self.emit_f64(v as f64); }\n+\n+    fn emit_bool(&mut self, v: bool) {\n+        if v {\n+            try!(write!(self.wr, \"true\"));\n+        } else {\n+            try!(write!(self.wr, \"false\"));\n+        }\n+    }\n+\n+    fn emit_f64(&mut self, v: f64) {\n+        try!(write!(self.wr, \"{}\", f64::to_str_digits(v, 6u)));\n+    }\n+    fn emit_f32(&mut self, v: f32) { self.emit_f64(v as f64); }\n+\n+    fn emit_char(&mut self, v: char) { self.emit_str(str::from_char(v)) }\n+    fn emit_str(&mut self, v: &str) {\n+        try!(write!(self.wr, \"{}\", escape_str(v)));\n+    }\n+\n+    fn emit_enum(&mut self, _name: &str, f: |&mut PrettyEncoder<'a>|) {\n+        f(self)\n+    }\n+\n+    fn emit_enum_variant(&mut self,\n+                         name: &str,\n+                         _: uint,\n+                         cnt: uint,\n+                         f: |&mut PrettyEncoder<'a>|) {\n+        if cnt == 0 {\n+            try!(write!(self.wr, \"{}\", escape_str(name)));\n+        } else {\n+            self.indent += 2;\n+            try!(write!(self.wr, \"[\\n{}{},\\n\", spaces(self.indent),\n+                          escape_str(name)));\n+            f(self);\n+            self.indent -= 2;\n+            try!(write!(self.wr, \"\\n{}]\", spaces(self.indent)));\n+        }\n+    }\n+\n+    fn emit_enum_variant_arg(&mut self,\n+                             idx: uint,\n+                             f: |&mut PrettyEncoder<'a>|) {\n+        if idx != 0 {\n+            try!(write!(self.wr, \",\\n\"));\n+        }\n+        try!(write!(self.wr, \"{}\", spaces(self.indent)));\n+        f(self)\n+    }\n+\n+    fn emit_enum_struct_variant(&mut self,\n+                                name: &str,\n+                                id: uint,\n+                                cnt: uint,\n+                                f: |&mut PrettyEncoder<'a>|) {\n+        self.emit_enum_variant(name, id, cnt, f)\n+    }\n+\n+    fn emit_enum_struct_variant_field(&mut self,\n+                                      _: &str,\n+                                      idx: uint,\n+                                      f: |&mut PrettyEncoder<'a>|) {\n+        self.emit_enum_variant_arg(idx, f)\n+    }\n+\n+\n+    fn emit_struct(&mut self,\n+                   _: &str,\n+                   len: uint,\n+                   f: |&mut PrettyEncoder<'a>|) {\n+        if len == 0 {\n+            try!(write!(self.wr, \"\\\\{\\\\}\"));\n+        } else {\n+            try!(write!(self.wr, \"\\\\{\"));\n+            self.indent += 2;\n+            f(self);\n+            self.indent -= 2;\n+            try!(write!(self.wr, \"\\n{}\\\\}\", spaces(self.indent)));\n+        }\n+    }\n+\n+    fn emit_struct_field(&mut self,\n+                         name: &str,\n+                         idx: uint,\n+                         f: |&mut PrettyEncoder<'a>|) {\n+        if idx == 0 {\n+            try!(write!(self.wr, \"\\n\"));\n+        } else {\n+            try!(write!(self.wr, \",\\n\"));\n+        }\n+        try!(write!(self.wr, \"{}{}: \", spaces(self.indent), escape_str(name)));\n+        f(self);\n+    }\n+\n+    fn emit_tuple(&mut self, len: uint, f: |&mut PrettyEncoder<'a>|) {\n+        self.emit_seq(len, f)\n+    }\n+    fn emit_tuple_arg(&mut self, idx: uint, f: |&mut PrettyEncoder<'a>|) {\n+        self.emit_seq_elt(idx, f)\n+    }\n+\n+    fn emit_tuple_struct(&mut self,\n+                         _: &str,\n+                         len: uint,\n+                         f: |&mut PrettyEncoder<'a>|) {\n+        self.emit_seq(len, f)\n+    }\n+    fn emit_tuple_struct_arg(&mut self,\n+                             idx: uint,\n+                             f: |&mut PrettyEncoder<'a>|) {\n+        self.emit_seq_elt(idx, f)\n+    }\n+\n+    fn emit_option(&mut self, f: |&mut PrettyEncoder<'a>|) { f(self); }\n+    fn emit_option_none(&mut self) { self.emit_nil(); }\n+    fn emit_option_some(&mut self, f: |&mut PrettyEncoder<'a>|) { f(self); }\n+\n+    fn emit_seq(&mut self, len: uint, f: |&mut PrettyEncoder<'a>|) {\n+        if len == 0 {\n+            try!(write!(self.wr, \"[]\"));\n+        } else {\n+            try!(write!(self.wr, \"[\"));\n+            self.indent += 2;\n+            f(self);\n+            self.indent -= 2;\n+            try!(write!(self.wr, \"\\n{}]\", spaces(self.indent)));\n+        }\n+    }\n+\n+    fn emit_seq_elt(&mut self, idx: uint, f: |&mut PrettyEncoder<'a>|) {\n+        if idx == 0 {\n+            try!(write!(self.wr, \"\\n\"));\n+        } else {\n+            try!(write!(self.wr, \",\\n\"));\n+        }\n+        try!(write!(self.wr, \"{}\", spaces(self.indent)));\n+        f(self)\n+    }\n+\n+    fn emit_map(&mut self, len: uint, f: |&mut PrettyEncoder<'a>|) {\n+        if len == 0 {\n+            try!(write!(self.wr, \"\\\\{\\\\}\"));\n+        } else {\n+            try!(write!(self.wr, \"\\\\{\"));\n+            self.indent += 2;\n+            f(self);\n+            self.indent -= 2;\n+            try!(write!(self.wr, \"\\n{}\\\\}\", spaces(self.indent)));\n+        }\n+    }\n+\n+    fn emit_map_elt_key(&mut self, idx: uint, f: |&mut PrettyEncoder<'a>|) {\n+        use std::str::from_utf8;\n+        if idx == 0 {\n+            try!(write!(self.wr, \"\\n\"));\n+        } else {\n+            try!(write!(self.wr, \",\\n\"));\n+        }\n+        try!(write!(self.wr, \"{}\", spaces(self.indent)));\n+        // ref #12967, make sure to wrap a key in double quotes,\n+        // in the event that its of a type that omits them (eg numbers)\n+        let mut buf = MemWriter::new();\n+        let mut check_encoder = PrettyEncoder::new(&mut buf);\n+        f(&mut check_encoder);\n+        let buf = buf.unwrap();\n+        let out = from_utf8(buf).unwrap();\n+        let needs_wrapping = out.char_at(0) != '\"' &&\n+            out.char_at_reverse(out.len()) != '\"';\n+        if needs_wrapping { try!(write!(self.wr, \"\\\"\")); }\n+        f(self);\n+        if needs_wrapping { try!(write!(self.wr, \"\\\"\")); }\n+    }\n+\n+    fn emit_map_elt_val(&mut self, _idx: uint, f: |&mut PrettyEncoder<'a>|) {\n+        try!(write!(self.wr, \": \"));\n+        f(self);\n+    }\n+}\n+\n+impl<E: ::Encoder> Encodable<E> for Json {\n+    fn encode(&self, e: &mut E) {\n+        match *self {\n+            Number(v) => v.encode(e),\n+            String(ref v) => v.encode(e),\n+            Boolean(v) => v.encode(e),\n+            List(ref v) => v.encode(e),\n+            Object(ref v) => v.encode(e),\n+            Null => e.emit_nil(),\n+        }\n+    }\n+}\n+\n+impl Json {\n+    /// Encodes a json value into a io::writer.  Uses a single line.\n+    pub fn to_writer(&self, wr: &mut io::Writer) -> io::IoResult<()> {\n+        let mut encoder = Encoder::new(wr);\n+        self.encode(&mut encoder);\n+        encoder.error\n+    }\n+\n+    /// Encodes a json value into a io::writer.\n+    /// Pretty-prints in a more readable format.\n+    pub fn to_pretty_writer(&self, wr: &mut io::Writer) -> io::IoResult<()> {\n+        let mut encoder = PrettyEncoder::new(wr);\n+        self.encode(&mut encoder);\n+        encoder.error\n+    }\n+\n+    /// Encodes a json value into a string\n+    pub fn to_pretty_str(&self) -> ~str {\n+        let mut s = MemWriter::new();\n+        self.to_pretty_writer(&mut s as &mut io::Writer).unwrap();\n+        str::from_utf8_owned(s.unwrap()).unwrap()\n+    }\n+\n+     /// If the Json value is an Object, returns the value associated with the provided key.\n+    /// Otherwise, returns None.\n+    pub fn find<'a>(&'a self, key: &~str) -> Option<&'a Json>{\n+        match self {\n+            &Object(ref map) => map.find(key),\n+            _ => None\n+        }\n+    }\n+\n+    /// Attempts to get a nested Json Object for each key in `keys`.\n+    /// If any key is found not to exist, find_path will return None.\n+    /// Otherwise, it will return the Json value associated with the final key.\n+    pub fn find_path<'a>(&'a self, keys: &[&~str]) -> Option<&'a Json>{\n+        let mut target = self;\n+        for key in keys.iter() {\n+            match target.find(*key) {\n+                Some(t) => { target = t; },\n+                None => return None\n+            }\n+        }\n+        Some(target)\n+    }\n+\n+    /// If the Json value is an Object, performs a depth-first search until\n+    /// a value associated with the provided key is found. If no value is found\n+    /// or the Json value is not an Object, returns None.\n+    pub fn search<'a>(&'a self, key: &~str) -> Option<&'a Json> {\n+        match self {\n+            &Object(ref map) => {\n+                match map.find(key) {\n+                    Some(json_value) => Some(json_value),\n+                    None => {\n+                        let mut value : Option<&'a Json> = None;\n+                        for (_, v) in map.iter() {\n+                            value = v.search(key);\n+                            if value.is_some() {\n+                                break;\n+                            }\n+                        }\n+                        value\n+                    }\n+                }\n+            },\n+            _ => None\n+        }\n+    }\n+\n+    /// Returns true if the Json value is an Object. Returns false otherwise.\n+    pub fn is_object<'a>(&'a self) -> bool {\n+        self.as_object().is_some()\n+    }\n+\n+    /// If the Json value is an Object, returns the associated TreeMap.\n+    /// Returns None otherwise.\n+    pub fn as_object<'a>(&'a self) -> Option<&'a Object> {\n+        match self {\n+            &Object(ref map) => Some(&**map),\n+            _ => None\n+        }\n+    }\n+\n+    /// Returns true if the Json value is a List. Returns false otherwise.\n+    pub fn is_list<'a>(&'a self) -> bool {\n+        self.as_list().is_some()\n+    }\n+\n+    /// If the Json value is a List, returns the associated vector.\n+    /// Returns None otherwise.\n+    pub fn as_list<'a>(&'a self) -> Option<&'a List> {\n+        match self {\n+            &List(ref list) => Some(&*list),\n+            _ => None\n+        }\n+    }\n+\n+    /// Returns true if the Json value is a String. Returns false otherwise.\n+    pub fn is_string<'a>(&'a self) -> bool {\n+        self.as_string().is_some()\n+    }\n+\n+    /// If the Json value is a String, returns the associated str.\n+    /// Returns None otherwise.\n+    pub fn as_string<'a>(&'a self) -> Option<&'a str> {\n+        match *self {\n+            String(ref s) => Some(s.as_slice()),\n+            _ => None\n+        }\n+    }\n+\n+    /// Returns true if the Json value is a Number. Returns false otherwise.\n+    pub fn is_number(&self) -> bool {\n+        self.as_number().is_some()\n+    }\n+\n+    /// If the Json value is a Number, returns the associated f64.\n+    /// Returns None otherwise.\n+    pub fn as_number(&self) -> Option<f64> {\n+        match self {\n+            &Number(n) => Some(n),\n+            _ => None\n+        }\n+    }\n+\n+    /// Returns true if the Json value is a Boolean. Returns false otherwise.\n+    pub fn is_boolean(&self) -> bool {\n+        self.as_boolean().is_some()\n+    }\n+\n+    /// If the Json value is a Boolean, returns the associated bool.\n+    /// Returns None otherwise.\n+    pub fn as_boolean(&self) -> Option<bool> {\n+        match self {\n+            &Boolean(b) => Some(b),\n+            _ => None\n+        }\n+    }\n+\n+    /// Returns true if the Json value is a Null. Returns false otherwise.\n+    pub fn is_null(&self) -> bool {\n+        self.as_null().is_some()\n+    }\n+\n+    /// If the Json value is a Null, returns ().\n+    /// Returns None otherwise.\n+    pub fn as_null(&self) -> Option<()> {\n+        match self {\n+            &Null => Some(()),\n+            _ => None\n+        }\n+    }\n+}\n+\n+pub struct Parser<T> {\n+    priv rdr: T,\n+    priv ch: Option<char>,\n+    priv line: uint,\n+    priv col: uint,\n+}\n+\n+impl<T: Iterator<char>> Parser<T> {\n+    /// Decode a json value from an Iterator<char>\n+    pub fn new(rdr: T) -> Parser<T> {\n+        let mut p = Parser {\n+            rdr: rdr,\n+            ch: Some('\\x00'),\n+            line: 1,\n+            col: 0,\n+        };\n+        p.bump();\n+        p\n+    }\n+}\n+\n+impl<T: Iterator<char>> Parser<T> {\n+    pub fn parse(&mut self) -> Result<Json, Error> {\n+        match self.parse_value() {\n+          Ok(value) => {\n+            // Skip trailing whitespaces.\n+            self.parse_whitespace();\n+            // Make sure there is no trailing characters.\n+            if self.eof() {\n+                Ok(value)\n+            } else {\n+                self.error(~\"trailing characters\")\n+            }\n+          }\n+          Err(e) => Err(e)\n+        }\n+    }\n+}\n+\n+impl<T : Iterator<char>> Parser<T> {\n+    fn eof(&self) -> bool { self.ch.is_none() }\n+    fn ch_or_null(&self) -> char { self.ch.unwrap_or('\\x00') }\n+    fn bump(&mut self) {\n+        self.ch = self.rdr.next();\n+\n+        if self.ch_is('\\n') {\n+            self.line += 1u;\n+            self.col = 1u;\n+        } else {\n+            self.col += 1u;\n+        }\n+    }\n+\n+    fn next_char(&mut self) -> Option<char> {\n+        self.bump();\n+        self.ch\n+    }\n+    fn ch_is(&self, c: char) -> bool {\n+        self.ch == Some(c)\n+    }\n+\n+    fn error<T>(&self, msg: ~str) -> Result<T, Error> {\n+        Err(Error { line: self.line, col: self.col, msg: msg })\n+    }\n+\n+    fn parse_value(&mut self) -> Result<Json, Error> {\n+        self.parse_whitespace();\n+\n+        if self.eof() { return self.error(~\"EOF while parsing value\"); }\n+\n+        match self.ch_or_null() {\n+            'n' => self.parse_ident(\"ull\", Null),\n+            't' => self.parse_ident(\"rue\", Boolean(true)),\n+            'f' => self.parse_ident(\"alse\", Boolean(false)),\n+            '0' .. '9' | '-' => self.parse_number(),\n+            '\"' => {\n+                match self.parse_str() {\n+                    Ok(s) => Ok(String(s)),\n+                    Err(e) => Err(e),\n+                }\n+            },\n+            '[' => self.parse_list(),\n+            '{' => self.parse_object(),\n+            _ => self.error(~\"invalid syntax\"),\n+        }\n+    }\n+\n+    fn parse_whitespace(&mut self) {\n+        while self.ch_is(' ') ||\n+              self.ch_is('\\n') ||\n+              self.ch_is('\\t') ||\n+              self.ch_is('\\r') { self.bump(); }\n+    }\n+\n+    fn parse_ident(&mut self, ident: &str, value: Json) -> Result<Json, Error> {\n+        if ident.chars().all(|c| Some(c) == self.next_char()) {\n+            self.bump();\n+            Ok(value)\n+        } else {\n+            self.error(~\"invalid syntax\")\n+        }\n+    }\n+\n+    fn parse_number(&mut self) -> Result<Json, Error> {\n+        let mut neg = 1.0;\n+\n+        if self.ch_is('-') {\n+            self.bump();\n+            neg = -1.0;\n+        }\n+\n+        let mut res = match self.parse_integer() {\n+          Ok(res) => res,\n+          Err(e) => return Err(e)\n+        };\n+\n+        if self.ch_is('.') {\n+            match self.parse_decimal(res) {\n+              Ok(r) => res = r,\n+              Err(e) => return Err(e)\n+            }\n+        }\n+\n+        if self.ch_is('e') || self.ch_is('E') {\n+            match self.parse_exponent(res) {\n+              Ok(r) => res = r,\n+              Err(e) => return Err(e)\n+            }\n+        }\n+\n+        Ok(Number(neg * res))\n+    }\n+\n+    fn parse_integer(&mut self) -> Result<f64, Error> {\n+        let mut res = 0.0;\n+\n+        match self.ch_or_null() {\n+            '0' => {\n+                self.bump();\n+\n+                // There can be only one leading '0'.\n+                match self.ch_or_null() {\n+                    '0' .. '9' => return self.error(~\"invalid number\"),\n+                    _ => ()\n+                }\n+            },\n+            '1' .. '9' => {\n+                while !self.eof() {\n+                    match self.ch_or_null() {\n+                        c @ '0' .. '9' => {\n+                            res *= 10.0;\n+                            res += ((c as int) - ('0' as int)) as f64;\n+\n+                            self.bump();\n+                        }\n+                        _ => break,\n+                    }\n+                }\n+            }\n+            _ => return self.error(~\"invalid number\"),\n+        }\n+        Ok(res)\n+    }\n+\n+    fn parse_decimal(&mut self, res: f64) -> Result<f64, Error> {\n+        self.bump();\n+\n+        // Make sure a digit follows the decimal place.\n+        match self.ch_or_null() {\n+            '0' .. '9' => (),\n+             _ => return self.error(~\"invalid number\")\n+        }\n+\n+        let mut res = res;\n+        let mut dec = 1.0;\n+        while !self.eof() {\n+            match self.ch_or_null() {\n+                c @ '0' .. '9' => {\n+                    dec /= 10.0;\n+                    res += (((c as int) - ('0' as int)) as f64) * dec;\n+\n+                    self.bump();\n+                }\n+                _ => break,\n+            }\n+        }\n+\n+        Ok(res)\n+    }\n+\n+    fn parse_exponent(&mut self, mut res: f64) -> Result<f64, Error> {\n+        self.bump();\n+\n+        let mut exp = 0u;\n+        let mut neg_exp = false;\n+\n+        if self.ch_is('+') {\n+            self.bump();\n+        } else if self.ch_is('-') {\n+            self.bump();\n+            neg_exp = true;\n+        }\n+\n+        // Make sure a digit follows the exponent place.\n+        match self.ch_or_null() {\n+            '0' .. '9' => (),\n+            _ => return self.error(~\"invalid number\")\n+        }\n+        while !self.eof() {\n+            match self.ch_or_null() {\n+                c @ '0' .. '9' => {\n+                    exp *= 10;\n+                    exp += (c as uint) - ('0' as uint);\n+\n+                    self.bump();\n+                }\n+                _ => break\n+            }\n+        }\n+\n+        let exp: f64 = num::pow(10u as f64, exp);\n+        if neg_exp {\n+            res /= exp;\n+        } else {\n+            res *= exp;\n+        }\n+\n+        Ok(res)\n+    }\n+\n+    fn parse_str(&mut self) -> Result<~str, Error> {\n+        let mut escape = false;\n+        let mut res = ~\"\";\n+\n+        loop {\n+            self.bump();\n+            if self.eof() {\n+                return self.error(~\"EOF while parsing string\");\n+            }\n+\n+            if escape {\n+                match self.ch_or_null() {\n+                    '\"' => res.push_char('\"'),\n+                    '\\\\' => res.push_char('\\\\'),\n+                    '/' => res.push_char('/'),\n+                    'b' => res.push_char('\\x08'),\n+                    'f' => res.push_char('\\x0c'),\n+                    'n' => res.push_char('\\n'),\n+                    'r' => res.push_char('\\r'),\n+                    't' => res.push_char('\\t'),\n+                    'u' => {\n+                        // Parse \\u1234.\n+                        let mut i = 0u;\n+                        let mut n = 0u;\n+                        while i < 4u && !self.eof() {\n+                            self.bump();\n+                            n = match self.ch_or_null() {\n+                                c @ '0' .. '9' => n * 16u + (c as uint) - ('0' as uint),\n+                                'a' | 'A' => n * 16u + 10u,\n+                                'b' | 'B' => n * 16u + 11u,\n+                                'c' | 'C' => n * 16u + 12u,\n+                                'd' | 'D' => n * 16u + 13u,\n+                                'e' | 'E' => n * 16u + 14u,\n+                                'f' | 'F' => n * 16u + 15u,\n+                                _ => return self.error(\n+                                    ~\"invalid \\\\u escape (unrecognized hex)\")\n+                            };\n+\n+                            i += 1u;\n+                        }\n+\n+                        // Error out if we didn't parse 4 digits.\n+                        if i != 4u {\n+                            return self.error(\n+                                ~\"invalid \\\\u escape (not four digits)\");\n+                        }\n+\n+                        res.push_char(char::from_u32(n as u32).unwrap());\n+                    }\n+                    _ => return self.error(~\"invalid escape\"),\n+                }\n+                escape = false;\n+            } else if self.ch_is('\\\\') {\n+                escape = true;\n+            } else {\n+                match self.ch {\n+                    Some('\"') => { self.bump(); return Ok(res); },\n+                    Some(c) => res.push_char(c),\n+                    None => unreachable!()\n+                }\n+            }\n+        }\n+    }\n+\n+    fn parse_list(&mut self) -> Result<Json, Error> {\n+        self.bump();\n+        self.parse_whitespace();\n+\n+        let mut values = ~[];\n+\n+        if self.ch_is(']') {\n+            self.bump();\n+            return Ok(List(values));\n+        }\n+\n+        loop {\n+            match self.parse_value() {\n+              Ok(v) => values.push(v),\n+              Err(e) => return Err(e)\n+            }\n+\n+            self.parse_whitespace();\n+            if self.eof() {\n+                return self.error(~\"EOF while parsing list\");\n+            }\n+\n+            if self.ch_is(',') {\n+                self.bump();\n+            } else if self.ch_is(']') {\n+                self.bump();\n+                return Ok(List(values));\n+            } else {\n+                return self.error(~\"expected `,` or `]`\")\n+            }\n+        };\n+    }\n+\n+    fn parse_object(&mut self) -> Result<Json, Error> {\n+        self.bump();\n+        self.parse_whitespace();\n+\n+        let mut values = ~TreeMap::new();\n+\n+        if self.ch_is('}') {\n+          self.bump();\n+          return Ok(Object(values));\n+        }\n+\n+        while !self.eof() {\n+            self.parse_whitespace();\n+\n+            if !self.ch_is('\"') {\n+                return self.error(~\"key must be a string\");\n+            }\n+\n+            let key = match self.parse_str() {\n+              Ok(key) => key,\n+              Err(e) => return Err(e)\n+            };\n+\n+            self.parse_whitespace();\n+\n+            if !self.ch_is(':') {\n+                if self.eof() { break; }\n+                return self.error(~\"expected `:`\");\n+            }\n+            self.bump();\n+\n+            match self.parse_value() {\n+              Ok(value) => { values.insert(key, value); }\n+              Err(e) => return Err(e)\n+            }\n+            self.parse_whitespace();\n+\n+            match self.ch_or_null() {\n+                ',' => self.bump(),\n+                '}' => { self.bump(); return Ok(Object(values)); },\n+                _ => {\n+                    if self.eof() { break; }\n+                    return self.error(~\"expected `,` or `}`\");\n+                }\n+            }\n+        }\n+\n+        return self.error(~\"EOF while parsing object\");\n+    }\n+}\n+\n+/// Decodes a json value from an `&mut io::Reader`\n+pub fn from_reader(rdr: &mut io::Reader) -> Result<Json, Error> {\n+    let contents = match rdr.read_to_end() {\n+        Ok(c) => c,\n+        Err(e) => return Err(io_error_to_error(e))\n+    };\n+    let s = match str::from_utf8_owned(contents) {\n+        Some(s) => s,\n+        None => return Err(Error { line: 0, col: 0, msg: ~\"contents not utf-8\" })\n+    };\n+    let mut parser = Parser::new(s.chars());\n+    parser.parse()\n+}\n+\n+/// Decodes a json value from a string\n+pub fn from_str(s: &str) -> Result<Json, Error> {\n+    let mut parser = Parser::new(s.chars());\n+    parser.parse()\n+}\n+\n+/// A structure to decode JSON to values in rust.\n+pub struct Decoder {\n+    priv stack: ~[Json],\n+}\n+\n+impl Decoder {\n+    /// Creates a new decoder instance for decoding the specified JSON value.\n+    pub fn new(json: Json) -> Decoder {\n+        Decoder {\n+            stack: ~[json]\n+        }\n+    }\n+}\n+\n+impl Decoder {\n+    fn err(&self, msg: &str) -> ! {\n+        fail!(\"JSON decode error: {}\", msg);\n+    }\n+    fn missing_field(&self, field: &str, object: ~Object) -> ! {\n+        self.err(format!(\"missing required '{}' field in object: {}\",\n+                         field, Object(object).to_str()))\n+    }\n+    fn expected(&self, expected: &str, found: &Json) -> ! {\n+        let found_s = match *found {\n+            Null => \"null\",\n+            List(..) => \"list\",\n+            Object(..) => \"object\",\n+            Number(..) => \"number\",\n+            String(..) => \"string\",\n+            Boolean(..) => \"boolean\"\n+        };\n+        self.err(format!(\"expected {expct} but found {fnd}: {val}\",\n+                         expct=expected, fnd=found_s, val=found.to_str()))\n+    }\n+}\n+\n+impl ::Decoder for Decoder {\n+    fn read_nil(&mut self) -> () {\n+        debug!(\"read_nil\");\n+        match self.stack.pop().unwrap() {\n+            Null => (),\n+            value => self.expected(\"null\", &value)\n+        }\n+    }\n+\n+    fn read_u64(&mut self)  -> u64  { self.read_f64() as u64 }\n+    fn read_u32(&mut self)  -> u32  { self.read_f64() as u32 }\n+    fn read_u16(&mut self)  -> u16  { self.read_f64() as u16 }\n+    fn read_u8 (&mut self)  -> u8   { self.read_f64() as u8 }\n+    fn read_uint(&mut self) -> uint { self.read_f64() as uint }\n+\n+    fn read_i64(&mut self) -> i64 { self.read_f64() as i64 }\n+    fn read_i32(&mut self) -> i32 { self.read_f64() as i32 }\n+    fn read_i16(&mut self) -> i16 { self.read_f64() as i16 }\n+    fn read_i8 (&mut self) -> i8  { self.read_f64() as i8 }\n+    fn read_int(&mut self) -> int { self.read_f64() as int }\n+\n+    fn read_bool(&mut self) -> bool {\n+        debug!(\"read_bool\");\n+        match self.stack.pop().unwrap() {\n+            Boolean(b) => b,\n+            value => self.expected(\"boolean\", &value)\n+        }\n+    }\n+\n+    fn read_f64(&mut self) -> f64 {\n+        use std::from_str::FromStr;\n+        debug!(\"read_f64\");\n+        match self.stack.pop().unwrap() {\n+            Number(f) => f,\n+            String(s) => {\n+                // re: #12967.. a type w/ numeric keys (ie HashMap<uint, V> etc)\n+                // is going to have a string here, as per JSON spec..\n+                FromStr::from_str(s).unwrap()\n+            },\n+            value => self.expected(\"number\", &value)\n+        }\n+    }\n+\n+    fn read_f32(&mut self) -> f32 { self.read_f64() as f32 }\n+\n+    fn read_char(&mut self) -> char {\n+        let s = self.read_str();\n+        {\n+            let mut it = s.chars();\n+            match (it.next(), it.next()) {\n+                // exactly one character\n+                (Some(c), None) => return c,\n+                _ => ()\n+            }\n+        }\n+        self.expected(\"single character string\", &String(s))\n+    }\n+\n+    fn read_str(&mut self) -> ~str {\n+        debug!(\"read_str\");\n+        match self.stack.pop().unwrap() {\n+            String(s) => s,\n+            value => self.expected(\"string\", &value)\n+        }\n+    }\n+\n+    fn read_enum<T>(&mut self, name: &str, f: |&mut Decoder| -> T) -> T {\n+        debug!(\"read_enum({})\", name);\n+        f(self)\n+    }\n+\n+    fn read_enum_variant<T>(&mut self,\n+                            names: &[&str],\n+                            f: |&mut Decoder, uint| -> T)\n+                            -> T {\n+        debug!(\"read_enum_variant(names={:?})\", names);\n+        let name = match self.stack.pop().unwrap() {\n+            String(s) => s,\n+            Object(mut o) => {\n+                let n = match o.pop(&~\"variant\") {\n+                    Some(String(s)) => s,\n+                    Some(val) => self.expected(\"string\", &val),\n+                    None => self.missing_field(\"variant\", o)\n+                };\n+                match o.pop(&~\"fields\") {\n+                    Some(List(l)) => {\n+                        for field in l.move_rev_iter() {\n+                            self.stack.push(field.clone());\n+                        }\n+                    },\n+                    Some(val) => self.expected(\"list\", &val),\n+                    None => {\n+                        // re-insert the variant field so we're\n+                        // printing the \"whole\" struct in the error\n+                        // message... ick.\n+                        o.insert(~\"variant\", String(n));\n+                        self.missing_field(\"fields\", o);\n+                    }\n+                }\n+                n\n+            }\n+            json => self.expected(\"string or object\", &json)\n+        };\n+        let idx = match names.iter().position(|n| str::eq_slice(*n, name)) {\n+            Some(idx) => idx,\n+            None => self.err(format!(\"unknown variant name: {}\", name))\n+        };\n+        f(self, idx)\n+    }\n+\n+    fn read_enum_variant_arg<T>(&mut self, idx: uint, f: |&mut Decoder| -> T)\n+                                -> T {\n+        debug!(\"read_enum_variant_arg(idx={})\", idx);\n+        f(self)\n+    }\n+\n+    fn read_enum_struct_variant<T>(&mut self,\n+                                   names: &[&str],\n+                                   f: |&mut Decoder, uint| -> T)\n+                                   -> T {\n+        debug!(\"read_enum_struct_variant(names={:?})\", names);\n+        self.read_enum_variant(names, f)\n+    }\n+\n+\n+    fn read_enum_struct_variant_field<T>(&mut self,\n+                                         name: &str,\n+                                         idx: uint,\n+                                         f: |&mut Decoder| -> T)\n+                                         -> T {\n+        debug!(\"read_enum_struct_variant_field(name={}, idx={})\", name, idx);\n+        self.read_enum_variant_arg(idx, f)\n+    }\n+\n+    fn read_struct<T>(&mut self,\n+                      name: &str,\n+                      len: uint,\n+                      f: |&mut Decoder| -> T)\n+                      -> T {\n+        debug!(\"read_struct(name={}, len={})\", name, len);\n+        let value = f(self);\n+        self.stack.pop().unwrap();\n+        value\n+    }\n+\n+    fn read_struct_field<T>(&mut self,\n+                            name: &str,\n+                            idx: uint,\n+                            f: |&mut Decoder| -> T)\n+                            -> T {\n+        debug!(\"read_struct_field(name={}, idx={})\", name, idx);\n+        match self.stack.pop().unwrap() {\n+            Object(mut obj) => {\n+                let value = match obj.pop(&name.to_owned()) {\n+                    None => self.missing_field(name, obj),\n+                    Some(json) => {\n+                        self.stack.push(json);\n+                        f(self)\n+                    }\n+                };\n+                self.stack.push(Object(obj));\n+                value\n+            }\n+            value => self.expected(\"object\", &value)\n+        }\n+    }\n+\n+    fn read_tuple<T>(&mut self, f: |&mut Decoder, uint| -> T) -> T {\n+        debug!(\"read_tuple()\");\n+        self.read_seq(f)\n+    }\n+\n+    fn read_tuple_arg<T>(&mut self, idx: uint, f: |&mut Decoder| -> T) -> T {\n+        debug!(\"read_tuple_arg(idx={})\", idx);\n+        self.read_seq_elt(idx, f)\n+    }\n+\n+    fn read_tuple_struct<T>(&mut self,\n+                            name: &str,\n+                            f: |&mut Decoder, uint| -> T)\n+                            -> T {\n+        debug!(\"read_tuple_struct(name={})\", name);\n+        self.read_tuple(f)\n+    }\n+\n+    fn read_tuple_struct_arg<T>(&mut self,\n+                                idx: uint,\n+                                f: |&mut Decoder| -> T)\n+                                -> T {\n+        debug!(\"read_tuple_struct_arg(idx={})\", idx);\n+        self.read_tuple_arg(idx, f)\n+    }\n+\n+    fn read_option<T>(&mut self, f: |&mut Decoder, bool| -> T) -> T {\n+        match self.stack.pop().unwrap() {\n+            Null => f(self, false),\n+            value => { self.stack.push(value); f(self, true) }\n+        }\n+    }\n+\n+    fn read_seq<T>(&mut self, f: |&mut Decoder, uint| -> T) -> T {\n+        debug!(\"read_seq()\");\n+        let len = match self.stack.pop().unwrap() {\n+            List(list) => {\n+                let len = list.len();\n+                for v in list.move_rev_iter() {\n+                    self.stack.push(v);\n+                }\n+                len\n+            }\n+            value => self.expected(\"list\", &value)\n+        };\n+        f(self, len)\n+    }\n+\n+    fn read_seq_elt<T>(&mut self, idx: uint, f: |&mut Decoder| -> T) -> T {\n+        debug!(\"read_seq_elt(idx={})\", idx);\n+        f(self)\n+    }\n+\n+    fn read_map<T>(&mut self, f: |&mut Decoder, uint| -> T) -> T {\n+        debug!(\"read_map()\");\n+        let len = match self.stack.pop().unwrap() {\n+            Object(obj) => {\n+                let len = obj.len();\n+                for (key, value) in obj.move_iter() {\n+                    self.stack.push(value);\n+                    self.stack.push(String(key));\n+                }\n+                len\n+            }\n+            value => self.expected(\"object\", &value)\n+        };\n+        f(self, len)\n+    }\n+\n+    fn read_map_elt_key<T>(&mut self, idx: uint, f: |&mut Decoder| -> T)\n+                           -> T {\n+        debug!(\"read_map_elt_key(idx={})\", idx);\n+        f(self)\n+    }\n+\n+    fn read_map_elt_val<T>(&mut self, idx: uint, f: |&mut Decoder| -> T)\n+                           -> T {\n+        debug!(\"read_map_elt_val(idx={})\", idx);\n+        f(self)\n+    }\n+}\n+\n+/// Test if two json values are less than one another\n+impl Ord for Json {\n+    fn lt(&self, other: &Json) -> bool {\n+        match *self {\n+            Number(f0) => {\n+                match *other {\n+                    Number(f1) => f0 < f1,\n+                    String(_) | Boolean(_) | List(_) | Object(_) |\n+                    Null => true\n+                }\n+            }\n+\n+            String(ref s0) => {\n+                match *other {\n+                    Number(_) => false,\n+                    String(ref s1) => s0 < s1,\n+                    Boolean(_) | List(_) | Object(_) | Null => true\n+                }\n+            }\n+\n+            Boolean(b0) => {\n+                match *other {\n+                    Number(_) | String(_) => false,\n+                    Boolean(b1) => b0 < b1,\n+                    List(_) | Object(_) | Null => true\n+                }\n+            }\n+\n+            List(ref l0) => {\n+                match *other {\n+                    Number(_) | String(_) | Boolean(_) => false,\n+                    List(ref l1) => (*l0) < (*l1),\n+                    Object(_) | Null => true\n+                }\n+            }\n+\n+            Object(ref d0) => {\n+                match *other {\n+                    Number(_) | String(_) | Boolean(_) | List(_) => false,\n+                    Object(ref d1) => d0 < d1,\n+                    Null => true\n+                }\n+            }\n+\n+            Null => {\n+                match *other {\n+                    Number(_) | String(_) | Boolean(_) | List(_) |\n+                    Object(_) =>\n+                        false,\n+                    Null => true\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+/// A trait for converting values to JSON\n+pub trait ToJson {\n+    /// Converts the value of `self` to an instance of JSON\n+    fn to_json(&self) -> Json;\n+}\n+\n+impl ToJson for Json {\n+    fn to_json(&self) -> Json { (*self).clone() }\n+}\n+\n+impl ToJson for int {\n+    fn to_json(&self) -> Json { Number(*self as f64) }\n+}\n+\n+impl ToJson for i8 {\n+    fn to_json(&self) -> Json { Number(*self as f64) }\n+}\n+\n+impl ToJson for i16 {\n+    fn to_json(&self) -> Json { Number(*self as f64) }\n+}\n+\n+impl ToJson for i32 {\n+    fn to_json(&self) -> Json { Number(*self as f64) }\n+}\n+\n+impl ToJson for i64 {\n+    fn to_json(&self) -> Json { Number(*self as f64) }\n+}\n+\n+impl ToJson for uint {\n+    fn to_json(&self) -> Json { Number(*self as f64) }\n+}\n+\n+impl ToJson for u8 {\n+    fn to_json(&self) -> Json { Number(*self as f64) }\n+}\n+\n+impl ToJson for u16 {\n+    fn to_json(&self) -> Json { Number(*self as f64) }\n+}\n+\n+impl ToJson for u32 {\n+    fn to_json(&self) -> Json { Number(*self as f64) }\n+}\n+\n+impl ToJson for u64 {\n+    fn to_json(&self) -> Json { Number(*self as f64) }\n+}\n+\n+impl ToJson for f32 {\n+    fn to_json(&self) -> Json { Number(*self as f64) }\n+}\n+\n+impl ToJson for f64 {\n+    fn to_json(&self) -> Json { Number(*self) }\n+}\n+\n+impl ToJson for () {\n+    fn to_json(&self) -> Json { Null }\n+}\n+\n+impl ToJson for bool {\n+    fn to_json(&self) -> Json { Boolean(*self) }\n+}\n+\n+impl ToJson for ~str {\n+    fn to_json(&self) -> Json { String((*self).clone()) }\n+}\n+\n+impl<A:ToJson,B:ToJson> ToJson for (A, B) {\n+    fn to_json(&self) -> Json {\n+        match *self {\n+          (ref a, ref b) => {\n+            List(~[a.to_json(), b.to_json()])\n+          }\n+        }\n+    }\n+}\n+\n+impl<A:ToJson,B:ToJson,C:ToJson> ToJson for (A, B, C) {\n+    fn to_json(&self) -> Json {\n+        match *self {\n+          (ref a, ref b, ref c) => {\n+            List(~[a.to_json(), b.to_json(), c.to_json()])\n+          }\n+        }\n+    }\n+}\n+\n+impl<A:ToJson> ToJson for ~[A] {\n+    fn to_json(&self) -> Json { List(self.map(|elt| elt.to_json())) }\n+}\n+\n+impl<A:ToJson> ToJson for TreeMap<~str, A> {\n+    fn to_json(&self) -> Json {\n+        let mut d = TreeMap::new();\n+        for (key, value) in self.iter() {\n+            d.insert((*key).clone(), value.to_json());\n+        }\n+        Object(~d)\n+    }\n+}\n+\n+impl<A:ToJson> ToJson for HashMap<~str, A> {\n+    fn to_json(&self) -> Json {\n+        let mut d = TreeMap::new();\n+        for (key, value) in self.iter() {\n+            d.insert((*key).clone(), value.to_json());\n+        }\n+        Object(~d)\n+    }\n+}\n+\n+impl<A:ToJson> ToJson for Option<A> {\n+    fn to_json(&self) -> Json {\n+        match *self {\n+          None => Null,\n+          Some(ref value) => value.to_json()\n+        }\n+    }\n+}\n+\n+impl fmt::Show for Json {\n+    /// Encodes a json value into a string\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        self.to_writer(f.buf)\n+    }\n+}\n+\n+impl fmt::Show for Error {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f.buf, \"{}:{}: {}\", self.line, self.col, self.msg)\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use {Encodable, Decodable};\n+    use super::{Encoder, Decoder, Error, Boolean, Number, List, String, Null,\n+                PrettyEncoder, Object, Json, from_str};\n+    use std::io;\n+    use collections::TreeMap;\n+\n+    #[deriving(Eq, Encodable, Decodable, Show)]\n+    enum Animal {\n+        Dog,\n+        Frog(~str, int)\n+    }\n+\n+    #[deriving(Eq, Encodable, Decodable, Show)]\n+    struct Inner {\n+        a: (),\n+        b: uint,\n+        c: ~[~str],\n+    }\n+\n+    #[deriving(Eq, Encodable, Decodable, Show)]\n+    struct Outer {\n+        inner: ~[Inner],\n+    }\n+\n+    fn mk_object(items: &[(~str, Json)]) -> Json {\n+        let mut d = ~TreeMap::new();\n+\n+        for item in items.iter() {\n+            match *item {\n+                (ref key, ref value) => { d.insert((*key).clone(), (*value).clone()); },\n+            }\n+        };\n+\n+        Object(d)\n+    }\n+\n+    #[test]\n+    fn test_write_null() {\n+        assert_eq!(Null.to_str(), ~\"null\");\n+        assert_eq!(Null.to_pretty_str(), ~\"null\");\n+    }\n+\n+\n+    #[test]\n+    fn test_write_number() {\n+        assert_eq!(Number(3.0).to_str(), ~\"3\");\n+        assert_eq!(Number(3.0).to_pretty_str(), ~\"3\");\n+\n+        assert_eq!(Number(3.1).to_str(), ~\"3.1\");\n+        assert_eq!(Number(3.1).to_pretty_str(), ~\"3.1\");\n+\n+        assert_eq!(Number(-1.5).to_str(), ~\"-1.5\");\n+        assert_eq!(Number(-1.5).to_pretty_str(), ~\"-1.5\");\n+\n+        assert_eq!(Number(0.5).to_str(), ~\"0.5\");\n+        assert_eq!(Number(0.5).to_pretty_str(), ~\"0.5\");\n+    }\n+\n+    #[test]\n+    fn test_write_str() {\n+        assert_eq!(String(~\"\").to_str(), ~\"\\\"\\\"\");\n+        assert_eq!(String(~\"\").to_pretty_str(), ~\"\\\"\\\"\");\n+\n+        assert_eq!(String(~\"foo\").to_str(), ~\"\\\"foo\\\"\");\n+        assert_eq!(String(~\"foo\").to_pretty_str(), ~\"\\\"foo\\\"\");\n+    }\n+\n+    #[test]\n+    fn test_write_bool() {\n+        assert_eq!(Boolean(true).to_str(), ~\"true\");\n+        assert_eq!(Boolean(true).to_pretty_str(), ~\"true\");\n+\n+        assert_eq!(Boolean(false).to_str(), ~\"false\");\n+        assert_eq!(Boolean(false).to_pretty_str(), ~\"false\");\n+    }\n+\n+    #[test]\n+    fn test_write_list() {\n+        assert_eq!(List(~[]).to_str(), ~\"[]\");\n+        assert_eq!(List(~[]).to_pretty_str(), ~\"[]\");\n+\n+        assert_eq!(List(~[Boolean(true)]).to_str(), ~\"[true]\");\n+        assert_eq!(\n+            List(~[Boolean(true)]).to_pretty_str(),\n+            ~\"\\\n+            [\\n  \\\n+                true\\n\\\n+            ]\"\n+        );\n+\n+        let long_test_list = List(~[\n+            Boolean(false),\n+            Null,\n+            List(~[String(~\"foo\\nbar\"), Number(3.5)])]);\n+\n+        assert_eq!(long_test_list.to_str(),\n+            ~\"[false,null,[\\\"foo\\\\nbar\\\",3.5]]\");\n+        assert_eq!(\n+            long_test_list.to_pretty_str(),\n+            ~\"\\\n+            [\\n  \\\n+                false,\\n  \\\n+                null,\\n  \\\n+                [\\n    \\\n+                    \\\"foo\\\\nbar\\\",\\n    \\\n+                    3.5\\n  \\\n+                ]\\n\\\n+            ]\"\n+        );\n+    }\n+\n+    #[test]\n+    fn test_write_object() {\n+        assert_eq!(mk_object([]).to_str(), ~\"{}\");\n+        assert_eq!(mk_object([]).to_pretty_str(), ~\"{}\");\n+\n+        assert_eq!(\n+            mk_object([(~\"a\", Boolean(true))]).to_str(),\n+            ~\"{\\\"a\\\":true}\"\n+        );\n+        assert_eq!(\n+            mk_object([(~\"a\", Boolean(true))]).to_pretty_str(),\n+            ~\"\\\n+            {\\n  \\\n+                \\\"a\\\": true\\n\\\n+            }\"\n+        );\n+\n+        let complex_obj = mk_object([\n+                (~\"b\", List(~[\n+                    mk_object([(~\"c\", String(~\"\\x0c\\r\"))]),\n+                    mk_object([(~\"d\", String(~\"\"))])\n+                ]))\n+            ]);\n+\n+        assert_eq!(\n+            complex_obj.to_str(),\n+            ~\"{\\\n+                \\\"b\\\":[\\\n+                    {\\\"c\\\":\\\"\\\\f\\\\r\\\"},\\\n+                    {\\\"d\\\":\\\"\\\"}\\\n+                ]\\\n+            }\"\n+        );\n+        assert_eq!(\n+            complex_obj.to_pretty_str(),\n+            ~\"\\\n+            {\\n  \\\n+                \\\"b\\\": [\\n    \\\n+                    {\\n      \\\n+                        \\\"c\\\": \\\"\\\\f\\\\r\\\"\\n    \\\n+                    },\\n    \\\n+                    {\\n      \\\n+                        \\\"d\\\": \\\"\\\"\\n    \\\n+                    }\\n  \\\n+                ]\\n\\\n+            }\"\n+        );\n+\n+        let a = mk_object([\n+            (~\"a\", Boolean(true)),\n+            (~\"b\", List(~[\n+                mk_object([(~\"c\", String(~\"\\x0c\\r\"))]),\n+                mk_object([(~\"d\", String(~\"\"))])\n+            ]))\n+        ]);\n+\n+        // We can't compare the strings directly because the object fields be\n+        // printed in a different order.\n+        assert_eq!(a.clone(), from_str(a.to_str()).unwrap());\n+        assert_eq!(a.clone(), from_str(a.to_pretty_str()).unwrap());\n+    }\n+\n+    fn with_str_writer(f: |&mut io::Writer|) -> ~str {\n+        use std::io::MemWriter;\n+        use std::str;\n+\n+        let mut m = MemWriter::new();\n+        f(&mut m as &mut io::Writer);\n+        str::from_utf8_owned(m.unwrap()).unwrap()\n+    }\n+\n+    #[test]\n+    fn test_write_enum() {\n+        let animal = Dog;\n+        assert_eq!(\n+            with_str_writer(|wr| {\n+                let mut encoder = Encoder::new(wr);\n+                animal.encode(&mut encoder);\n+            }),\n+            ~\"\\\"Dog\\\"\"\n+        );\n+        assert_eq!(\n+            with_str_writer(|wr| {\n+                let mut encoder = PrettyEncoder::new(wr);\n+                animal.encode(&mut encoder);\n+            }),\n+            ~\"\\\"Dog\\\"\"\n+        );\n+\n+        let animal = Frog(~\"Henry\", 349);\n+        assert_eq!(\n+            with_str_writer(|wr| {\n+                let mut encoder = Encoder::new(wr);\n+                animal.encode(&mut encoder);\n+            }),\n+            ~\"{\\\"variant\\\":\\\"Frog\\\",\\\"fields\\\":[\\\"Henry\\\",349]}\"\n+        );\n+        assert_eq!(\n+            with_str_writer(|wr| {\n+                let mut encoder = PrettyEncoder::new(wr);\n+                animal.encode(&mut encoder);\n+            }),\n+            ~\"\\\n+            [\\n  \\\n+                \\\"Frog\\\",\\n  \\\n+                \\\"Henry\\\",\\n  \\\n+                349\\n\\\n+            ]\"\n+        );\n+    }\n+\n+    #[test]\n+    fn test_write_some() {\n+        let value = Some(~\"jodhpurs\");\n+        let s = with_str_writer(|wr| {\n+            let mut encoder = Encoder::new(wr);\n+            value.encode(&mut encoder);\n+        });\n+        assert_eq!(s, ~\"\\\"jodhpurs\\\"\");\n+\n+        let value = Some(~\"jodhpurs\");\n+        let s = with_str_writer(|wr| {\n+            let mut encoder = PrettyEncoder::new(wr);\n+            value.encode(&mut encoder);\n+        });\n+        assert_eq!(s, ~\"\\\"jodhpurs\\\"\");\n+    }\n+\n+    #[test]\n+    fn test_write_none() {\n+        let value: Option<~str> = None;\n+        let s = with_str_writer(|wr| {\n+            let mut encoder = Encoder::new(wr);\n+            value.encode(&mut encoder);\n+        });\n+        assert_eq!(s, ~\"null\");\n+\n+        let s = with_str_writer(|wr| {\n+            let mut encoder = Encoder::new(wr);\n+            value.encode(&mut encoder);\n+        });\n+        assert_eq!(s, ~\"null\");\n+    }\n+\n+    #[test]\n+    fn test_trailing_characters() {\n+        assert_eq!(from_str(\"nulla\"),\n+            Err(Error {line: 1u, col: 5u, msg: ~\"trailing characters\"}));\n+        assert_eq!(from_str(\"truea\"),\n+            Err(Error {line: 1u, col: 5u, msg: ~\"trailing characters\"}));\n+        assert_eq!(from_str(\"falsea\"),\n+            Err(Error {line: 1u, col: 6u, msg: ~\"trailing characters\"}));\n+        assert_eq!(from_str(\"1a\"),\n+            Err(Error {line: 1u, col: 2u, msg: ~\"trailing characters\"}));\n+        assert_eq!(from_str(\"[]a\"),\n+            Err(Error {line: 1u, col: 3u, msg: ~\"trailing characters\"}));\n+        assert_eq!(from_str(\"{}a\"),\n+            Err(Error {line: 1u, col: 3u, msg: ~\"trailing characters\"}));\n+    }\n+\n+    #[test]\n+    fn test_read_identifiers() {\n+        assert_eq!(from_str(\"n\"),\n+            Err(Error {line: 1u, col: 2u, msg: ~\"invalid syntax\"}));\n+        assert_eq!(from_str(\"nul\"),\n+            Err(Error {line: 1u, col: 4u, msg: ~\"invalid syntax\"}));\n+\n+        assert_eq!(from_str(\"t\"),\n+            Err(Error {line: 1u, col: 2u, msg: ~\"invalid syntax\"}));\n+        assert_eq!(from_str(\"truz\"),\n+            Err(Error {line: 1u, col: 4u, msg: ~\"invalid syntax\"}));\n+\n+        assert_eq!(from_str(\"f\"),\n+            Err(Error {line: 1u, col: 2u, msg: ~\"invalid syntax\"}));\n+        assert_eq!(from_str(\"faz\"),\n+            Err(Error {line: 1u, col: 3u, msg: ~\"invalid syntax\"}));\n+\n+        assert_eq!(from_str(\"null\"), Ok(Null));\n+        assert_eq!(from_str(\"true\"), Ok(Boolean(true)));\n+        assert_eq!(from_str(\"false\"), Ok(Boolean(false)));\n+        assert_eq!(from_str(\" null \"), Ok(Null));\n+        assert_eq!(from_str(\" true \"), Ok(Boolean(true)));\n+        assert_eq!(from_str(\" false \"), Ok(Boolean(false)));\n+    }\n+\n+    #[test]\n+    fn test_decode_identifiers() {\n+        let mut decoder = Decoder::new(from_str(\"null\").unwrap());\n+        let v: () = Decodable::decode(&mut decoder);\n+        assert_eq!(v, ());\n+\n+        let mut decoder = Decoder::new(from_str(\"true\").unwrap());\n+        let v: bool = Decodable::decode(&mut decoder);\n+        assert_eq!(v, true);\n+\n+        let mut decoder = Decoder::new(from_str(\"false\").unwrap());\n+        let v: bool = Decodable::decode(&mut decoder);\n+        assert_eq!(v, false);\n+    }\n+\n+    #[test]\n+    fn test_read_number() {\n+        assert_eq!(from_str(\"+\"),\n+            Err(Error {line: 1u, col: 1u, msg: ~\"invalid syntax\"}));\n+        assert_eq!(from_str(\".\"),\n+            Err(Error {line: 1u, col: 1u, msg: ~\"invalid syntax\"}));\n+\n+        assert_eq!(from_str(\"-\"),\n+            Err(Error {line: 1u, col: 2u, msg: ~\"invalid number\"}));\n+        assert_eq!(from_str(\"00\"),\n+            Err(Error {line: 1u, col: 2u, msg: ~\"invalid number\"}));\n+        assert_eq!(from_str(\"1.\"),\n+            Err(Error {line: 1u, col: 3u, msg: ~\"invalid number\"}));\n+        assert_eq!(from_str(\"1e\"),\n+            Err(Error {line: 1u, col: 3u, msg: ~\"invalid number\"}));\n+        assert_eq!(from_str(\"1e+\"),\n+            Err(Error {line: 1u, col: 4u, msg: ~\"invalid number\"}));\n+\n+        assert_eq!(from_str(\"3\"), Ok(Number(3.0)));\n+        assert_eq!(from_str(\"3.1\"), Ok(Number(3.1)));\n+        assert_eq!(from_str(\"-1.2\"), Ok(Number(-1.2)));\n+        assert_eq!(from_str(\"0.4\"), Ok(Number(0.4)));\n+        assert_eq!(from_str(\"0.4e5\"), Ok(Number(0.4e5)));\n+        assert_eq!(from_str(\"0.4e+15\"), Ok(Number(0.4e15)));\n+        assert_eq!(from_str(\"0.4e-01\"), Ok(Number(0.4e-01)));\n+        assert_eq!(from_str(\" 3 \"), Ok(Number(3.0)));\n+    }\n+\n+    #[test]\n+    fn test_decode_numbers() {\n+        let mut decoder = Decoder::new(from_str(\"3\").unwrap());\n+        let v: f64 = Decodable::decode(&mut decoder);\n+        assert_eq!(v, 3.0);\n+\n+        let mut decoder = Decoder::new(from_str(\"3.1\").unwrap());\n+        let v: f64 = Decodable::decode(&mut decoder);\n+        assert_eq!(v, 3.1);\n+\n+        let mut decoder = Decoder::new(from_str(\"-1.2\").unwrap());\n+        let v: f64 = Decodable::decode(&mut decoder);\n+        assert_eq!(v, -1.2);\n+\n+        let mut decoder = Decoder::new(from_str(\"0.4\").unwrap());\n+        let v: f64 = Decodable::decode(&mut decoder);\n+        assert_eq!(v, 0.4);\n+\n+        let mut decoder = Decoder::new(from_str(\"0.4e5\").unwrap());\n+        let v: f64 = Decodable::decode(&mut decoder);\n+        assert_eq!(v, 0.4e5);\n+\n+        let mut decoder = Decoder::new(from_str(\"0.4e15\").unwrap());\n+        let v: f64 = Decodable::decode(&mut decoder);\n+        assert_eq!(v, 0.4e15);\n+\n+        let mut decoder = Decoder::new(from_str(\"0.4e-01\").unwrap());\n+        let v: f64 = Decodable::decode(&mut decoder);\n+        assert_eq!(v, 0.4e-01);\n+    }\n+\n+    #[test]\n+    fn test_read_str() {\n+        assert_eq!(from_str(\"\\\"\"),\n+            Err(Error {line: 1u, col: 2u, msg: ~\"EOF while parsing string\"\n+        }));\n+        assert_eq!(from_str(\"\\\"lol\"),\n+            Err(Error {line: 1u, col: 5u, msg: ~\"EOF while parsing string\"\n+        }));\n+\n+        assert_eq!(from_str(\"\\\"\\\"\"), Ok(String(~\"\")));\n+        assert_eq!(from_str(\"\\\"foo\\\"\"), Ok(String(~\"foo\")));\n+        assert_eq!(from_str(\"\\\"\\\\\\\"\\\"\"), Ok(String(~\"\\\"\")));\n+        assert_eq!(from_str(\"\\\"\\\\b\\\"\"), Ok(String(~\"\\x08\")));\n+        assert_eq!(from_str(\"\\\"\\\\n\\\"\"), Ok(String(~\"\\n\")));\n+        assert_eq!(from_str(\"\\\"\\\\r\\\"\"), Ok(String(~\"\\r\")));\n+        assert_eq!(from_str(\"\\\"\\\\t\\\"\"), Ok(String(~\"\\t\")));\n+        assert_eq!(from_str(\" \\\"foo\\\" \"), Ok(String(~\"foo\")));\n+        assert_eq!(from_str(\"\\\"\\\\u12ab\\\"\"), Ok(String(~\"\\u12ab\")));\n+        assert_eq!(from_str(\"\\\"\\\\uAB12\\\"\"), Ok(String(~\"\\uAB12\")));\n+    }\n+\n+    #[test]\n+    fn test_decode_str() {\n+        let mut decoder = Decoder::new(from_str(\"\\\"\\\"\").unwrap());\n+        let v: ~str = Decodable::decode(&mut decoder);\n+        assert_eq!(v, ~\"\");\n+\n+        let mut decoder = Decoder::new(from_str(\"\\\"foo\\\"\").unwrap());\n+        let v: ~str = Decodable::decode(&mut decoder);\n+        assert_eq!(v, ~\"foo\");\n+\n+        let mut decoder = Decoder::new(from_str(\"\\\"\\\\\\\"\\\"\").unwrap());\n+        let v: ~str = Decodable::decode(&mut decoder);\n+        assert_eq!(v, ~\"\\\"\");\n+\n+        let mut decoder = Decoder::new(from_str(\"\\\"\\\\b\\\"\").unwrap());\n+        let v: ~str = Decodable::decode(&mut decoder);\n+        assert_eq!(v, ~\"\\x08\");\n+\n+        let mut decoder = Decoder::new(from_str(\"\\\"\\\\n\\\"\").unwrap());\n+        let v: ~str = Decodable::decode(&mut decoder);\n+        assert_eq!(v, ~\"\\n\");\n+\n+        let mut decoder = Decoder::new(from_str(\"\\\"\\\\r\\\"\").unwrap());\n+        let v: ~str = Decodable::decode(&mut decoder);\n+        assert_eq!(v, ~\"\\r\");\n+\n+        let mut decoder = Decoder::new(from_str(\"\\\"\\\\t\\\"\").unwrap());\n+        let v: ~str = Decodable::decode(&mut decoder);\n+        assert_eq!(v, ~\"\\t\");\n+\n+        let mut decoder = Decoder::new(from_str(\"\\\"\\\\u12ab\\\"\").unwrap());\n+        let v: ~str = Decodable::decode(&mut decoder);\n+        assert_eq!(v, ~\"\\u12ab\");\n+\n+        let mut decoder = Decoder::new(from_str(\"\\\"\\\\uAB12\\\"\").unwrap());\n+        let v: ~str = Decodable::decode(&mut decoder);\n+        assert_eq!(v, ~\"\\uAB12\");\n+    }\n+\n+    #[test]\n+    fn test_read_list() {\n+        assert_eq!(from_str(\"[\"),\n+            Err(Error {line: 1u, col: 2u, msg: ~\"EOF while parsing value\"}));\n+        assert_eq!(from_str(\"[1\"),\n+            Err(Error {line: 1u, col: 3u, msg: ~\"EOF while parsing list\"}));\n+        assert_eq!(from_str(\"[1,\"),\n+            Err(Error {line: 1u, col: 4u, msg: ~\"EOF while parsing value\"}));\n+        assert_eq!(from_str(\"[1,]\"),\n+            Err(Error {line: 1u, col: 4u, msg: ~\"invalid syntax\"}));\n+        assert_eq!(from_str(\"[6 7]\"),\n+            Err(Error {line: 1u, col: 4u, msg: ~\"expected `,` or `]`\"}));\n+\n+        assert_eq!(from_str(\"[]\"), Ok(List(~[])));\n+        assert_eq!(from_str(\"[ ]\"), Ok(List(~[])));\n+        assert_eq!(from_str(\"[true]\"), Ok(List(~[Boolean(true)])));\n+        assert_eq!(from_str(\"[ false ]\"), Ok(List(~[Boolean(false)])));\n+        assert_eq!(from_str(\"[null]\"), Ok(List(~[Null])));\n+        assert_eq!(from_str(\"[3, 1]\"),\n+                     Ok(List(~[Number(3.0), Number(1.0)])));\n+        assert_eq!(from_str(\"\\n[3, 2]\\n\"),\n+                     Ok(List(~[Number(3.0), Number(2.0)])));\n+        assert_eq!(from_str(\"[2, [4, 1]]\"),\n+               Ok(List(~[Number(2.0), List(~[Number(4.0), Number(1.0)])])));\n+    }\n+\n+    #[test]\n+    fn test_decode_list() {\n+        let mut decoder = Decoder::new(from_str(\"[]\").unwrap());\n+        let v: ~[()] = Decodable::decode(&mut decoder);\n+        assert_eq!(v, ~[]);\n+\n+        let mut decoder = Decoder::new(from_str(\"[null]\").unwrap());\n+        let v: ~[()] = Decodable::decode(&mut decoder);\n+        assert_eq!(v, ~[()]);\n+\n+        let mut decoder = Decoder::new(from_str(\"[true]\").unwrap());\n+        let v: ~[bool] = Decodable::decode(&mut decoder);\n+        assert_eq!(v, ~[true]);\n+\n+        let mut decoder = Decoder::new(from_str(\"[true]\").unwrap());\n+        let v: ~[bool] = Decodable::decode(&mut decoder);\n+        assert_eq!(v, ~[true]);\n+\n+        let mut decoder = Decoder::new(from_str(\"[3, 1]\").unwrap());\n+        let v: ~[int] = Decodable::decode(&mut decoder);\n+        assert_eq!(v, ~[3, 1]);\n+\n+        let mut decoder = Decoder::new(from_str(\"[[3], [1, 2]]\").unwrap());\n+        let v: ~[~[uint]] = Decodable::decode(&mut decoder);\n+        assert_eq!(v, ~[~[3], ~[1, 2]]);\n+    }\n+\n+    #[test]\n+    fn test_read_object() {\n+        assert_eq!(from_str(\"{\"),\n+            Err(Error {\n+                line: 1u,\n+                col: 2u,\n+                msg: ~\"EOF while parsing object\"}));\n+        assert_eq!(from_str(\"{ \"),\n+            Err(Error {\n+                line: 1u,\n+                col: 3u,\n+                msg: ~\"EOF while parsing object\"}));\n+        assert_eq!(from_str(\"{1\"),\n+            Err(Error {\n+                line: 1u,\n+                col: 2u,\n+                msg: ~\"key must be a string\"}));\n+        assert_eq!(from_str(\"{ \\\"a\\\"\"),\n+            Err(Error {\n+                line: 1u,\n+                col: 6u,\n+                msg: ~\"EOF while parsing object\"}));\n+        assert_eq!(from_str(\"{\\\"a\\\"\"),\n+            Err(Error {\n+                line: 1u,\n+                col: 5u,\n+                msg: ~\"EOF while parsing object\"}));\n+        assert_eq!(from_str(\"{\\\"a\\\" \"),\n+            Err(Error {\n+                line: 1u,\n+                col: 6u,\n+                msg: ~\"EOF while parsing object\"}));\n+\n+        assert_eq!(from_str(\"{\\\"a\\\" 1\"),\n+            Err(Error {line: 1u, col: 6u, msg: ~\"expected `:`\"}));\n+        assert_eq!(from_str(\"{\\\"a\\\":\"),\n+            Err(Error {line: 1u, col: 6u, msg: ~\"EOF while parsing value\"}));\n+        assert_eq!(from_str(\"{\\\"a\\\":1\"),\n+            Err(Error {\n+                line: 1u,\n+                col: 7u,\n+                msg: ~\"EOF while parsing object\"}));\n+        assert_eq!(from_str(\"{\\\"a\\\":1 1\"),\n+            Err(Error {line: 1u, col: 8u, msg: ~\"expected `,` or `}`\"}));\n+        assert_eq!(from_str(\"{\\\"a\\\":1,\"),\n+            Err(Error {\n+                line: 1u,\n+                col: 8u,\n+                msg: ~\"EOF while parsing object\"}));\n+\n+        assert_eq!(from_str(\"{}\").unwrap(), mk_object([]));\n+        assert_eq!(from_str(\"{\\\"a\\\": 3}\").unwrap(),\n+                  mk_object([(~\"a\", Number(3.0))]));\n+\n+        assert_eq!(from_str(\n+                      \"{ \\\"a\\\": null, \\\"b\\\" : true }\").unwrap(),\n+                  mk_object([\n+                      (~\"a\", Null),\n+                      (~\"b\", Boolean(true))]));\n+        assert_eq!(from_str(\"\\n{ \\\"a\\\": null, \\\"b\\\" : true }\\n\").unwrap(),\n+                  mk_object([\n+                      (~\"a\", Null),\n+                      (~\"b\", Boolean(true))]));\n+        assert_eq!(from_str(\n+                      \"{\\\"a\\\" : 1.0 ,\\\"b\\\": [ true ]}\").unwrap(),\n+                  mk_object([\n+                      (~\"a\", Number(1.0)),\n+                      (~\"b\", List(~[Boolean(true)]))\n+                  ]));\n+        assert_eq!(from_str(\n+                      ~\"{\" +\n+                          \"\\\"a\\\": 1.0, \" +\n+                          \"\\\"b\\\": [\" +\n+                              \"true,\" +\n+                              \"\\\"foo\\\\nbar\\\", \" +\n+                              \"{ \\\"c\\\": {\\\"d\\\": null} } \" +\n+                          \"]\" +\n+                      \"}\").unwrap(),\n+                  mk_object([\n+                      (~\"a\", Number(1.0)),\n+                      (~\"b\", List(~[\n+                          Boolean(true),\n+                          String(~\"foo\\nbar\"),\n+                          mk_object([\n+                              (~\"c\", mk_object([(~\"d\", Null)]))\n+                          ])\n+                      ]))\n+                  ]));\n+    }\n+\n+    #[test]\n+    fn test_decode_struct() {\n+        let s = ~\"{\n+            \\\"inner\\\": [\n+                { \\\"a\\\": null, \\\"b\\\": 2, \\\"c\\\": [\\\"abc\\\", \\\"xyz\\\"] }\n+            ]\n+        }\";\n+        let mut decoder = Decoder::new(from_str(s).unwrap());\n+        let v: Outer = Decodable::decode(&mut decoder);\n+        assert_eq!(\n+            v,\n+            Outer {\n+                inner: ~[\n+                    Inner { a: (), b: 2, c: ~[~\"abc\", ~\"xyz\"] }\n+                ]\n+            }\n+        );\n+    }\n+\n+    #[test]\n+    fn test_decode_option() {\n+        let mut decoder = Decoder::new(from_str(\"null\").unwrap());\n+        let value: Option<~str> = Decodable::decode(&mut decoder);\n+        assert_eq!(value, None);\n+\n+        let mut decoder = Decoder::new(from_str(\"\\\"jodhpurs\\\"\").unwrap());\n+        let value: Option<~str> = Decodable::decode(&mut decoder);\n+        assert_eq!(value, Some(~\"jodhpurs\"));\n+    }\n+\n+    #[test]\n+    fn test_decode_enum() {\n+        let mut decoder = Decoder::new(from_str(\"\\\"Dog\\\"\").unwrap());\n+        let value: Animal = Decodable::decode(&mut decoder);\n+        assert_eq!(value, Dog);\n+\n+        let s = \"{\\\"variant\\\":\\\"Frog\\\",\\\"fields\\\":[\\\"Henry\\\",349]}\";\n+        let mut decoder = Decoder::new(from_str(s).unwrap());\n+        let value: Animal = Decodable::decode(&mut decoder);\n+        assert_eq!(value, Frog(~\"Henry\", 349));\n+    }\n+\n+    #[test]\n+    fn test_decode_map() {\n+        let s = ~\"{\\\"a\\\": \\\"Dog\\\", \\\"b\\\": {\\\"variant\\\":\\\"Frog\\\",\\\"fields\\\":[\\\"Henry\\\", 349]}}\";\n+        let mut decoder = Decoder::new(from_str(s).unwrap());\n+        let mut map: TreeMap<~str, Animal> = Decodable::decode(&mut decoder);\n+\n+        assert_eq!(map.pop(&~\"a\"), Some(Dog));\n+        assert_eq!(map.pop(&~\"b\"), Some(Frog(~\"Henry\", 349)));\n+    }\n+\n+    #[test]\n+    fn test_multiline_errors() {\n+        assert_eq!(from_str(\"{\\n  \\\"foo\\\":\\n \\\"bar\\\"\"),\n+            Err(Error {\n+                line: 3u,\n+                col: 8u,\n+                msg: ~\"EOF while parsing object\"}));\n+    }\n+\n+    #[deriving(Decodable)]\n+    struct DecodeStruct {\n+        x: f64,\n+        y: bool,\n+        z: ~str,\n+        w: ~[DecodeStruct]\n+    }\n+    #[deriving(Decodable)]\n+    enum DecodeEnum {\n+        A(f64),\n+        B(~str)\n+    }\n+    fn check_err<T: Decodable<Decoder>>(to_parse: &'static str, expected_error: &str) {\n+        use std::any::AnyRefExt;\n+        use std::task;\n+        let res = task::try(proc() {\n+            // either fails in `decode` (which is what we want), or\n+            // returns Some(error_message)/None if the string was\n+            // invalid or valid JSON.\n+            match from_str(to_parse) {\n+                Err(e) => Some(e.to_str()),\n+                Ok(json) => {\n+                    let _: T = Decodable::decode(&mut Decoder::new(json));\n+                    None\n+                }\n+            }\n+        });\n+        match res {\n+            Ok(Some(parse_error)) => fail!(\"`{}` is not valid json: {}\",\n+                                           to_parse, parse_error),\n+            Ok(None) => fail!(\"`{}` parsed & decoded ok, expecting error `{}`\",\n+                              to_parse, expected_error),\n+            Err(e) => {\n+                let err = e.as_ref::<~str>().unwrap();\n+                assert!(err.contains(expected_error),\n+                        \"`{}` errored incorrectly, found `{}` expecting `{}`\",\n+                        to_parse, *err, expected_error);\n+            }\n+        }\n+    }\n+    #[test]\n+    fn test_decode_errors_struct() {\n+        check_err::<DecodeStruct>(\"[]\", \"object but found list\");\n+        check_err::<DecodeStruct>(\"{\\\"x\\\": true, \\\"y\\\": true, \\\"z\\\": \\\"\\\", \\\"w\\\": []}\",\n+                                  \"number but found boolean\");\n+        check_err::<DecodeStruct>(\"{\\\"x\\\": 1, \\\"y\\\": [], \\\"z\\\": \\\"\\\", \\\"w\\\": []}\",\n+                                  \"boolean but found list\");\n+        check_err::<DecodeStruct>(\"{\\\"x\\\": 1, \\\"y\\\": true, \\\"z\\\": {}, \\\"w\\\": []}\",\n+                                  \"string but found object\");\n+        check_err::<DecodeStruct>(\"{\\\"x\\\": 1, \\\"y\\\": true, \\\"z\\\": \\\"\\\", \\\"w\\\": null}\",\n+                                  \"list but found null\");\n+        check_err::<DecodeStruct>(\"{\\\"x\\\": 1, \\\"y\\\": true, \\\"z\\\": \\\"\\\"}\",\n+                                  \"'w' field in object\");\n+    }\n+    #[test]\n+    fn test_decode_errors_enum() {\n+        check_err::<DecodeEnum>(\"{}\",\n+                                \"'variant' field in object\");\n+        check_err::<DecodeEnum>(\"{\\\"variant\\\": 1}\",\n+                                \"string but found number\");\n+        check_err::<DecodeEnum>(\"{\\\"variant\\\": \\\"A\\\"}\",\n+                                \"'fields' field in object\");\n+        check_err::<DecodeEnum>(\"{\\\"variant\\\": \\\"A\\\", \\\"fields\\\": null}\",\n+                                \"list but found null\");\n+        check_err::<DecodeEnum>(\"{\\\"variant\\\": \\\"C\\\", \\\"fields\\\": []}\",\n+                                \"unknown variant name\");\n+    }\n+\n+    #[test]\n+    fn test_find(){\n+        let json_value = from_str(\"{\\\"dog\\\" : \\\"cat\\\"}\").unwrap();\n+        let found_str = json_value.find(&~\"dog\");\n+        assert!(found_str.is_some() && found_str.unwrap().as_string().unwrap() == &\"cat\");\n+    }\n+\n+    #[test]\n+    fn test_find_path(){\n+        let json_value = from_str(\"{\\\"dog\\\":{\\\"cat\\\": {\\\"mouse\\\" : \\\"cheese\\\"}}}\").unwrap();\n+        let found_str = json_value.find_path(&[&~\"dog\", &~\"cat\", &~\"mouse\"]);\n+        assert!(found_str.is_some() && found_str.unwrap().as_string().unwrap() == &\"cheese\");\n+    }\n+\n+    #[test]\n+    fn test_search(){\n+        let json_value = from_str(\"{\\\"dog\\\":{\\\"cat\\\": {\\\"mouse\\\" : \\\"cheese\\\"}}}\").unwrap();\n+        let found_str = json_value.search(&~\"mouse\").and_then(|j| j.as_string());\n+        assert!(found_str.is_some());\n+        assert!(found_str.unwrap() == &\"cheese\");\n+    }\n+\n+    #[test]\n+    fn test_is_object(){\n+        let json_value = from_str(\"{}\").unwrap();\n+        assert!(json_value.is_object());\n+    }\n+\n+    #[test]\n+    fn test_as_object(){\n+        let json_value = from_str(\"{}\").unwrap();\n+        let json_object = json_value.as_object();\n+        assert!(json_object.is_some());\n+    }\n+\n+    #[test]\n+    fn test_is_list(){\n+        let json_value = from_str(\"[1, 2, 3]\").unwrap();\n+        assert!(json_value.is_list());\n+    }\n+\n+    #[test]\n+    fn test_as_list(){\n+        let json_value = from_str(\"[1, 2, 3]\").unwrap();\n+        let json_list = json_value.as_list();\n+        let expected_length = 3;\n+        assert!(json_list.is_some() && json_list.unwrap().len() == expected_length);\n+    }\n+\n+    #[test]\n+    fn test_is_string(){\n+        let json_value = from_str(\"\\\"dog\\\"\").unwrap();\n+        assert!(json_value.is_string());\n+    }\n+\n+    #[test]\n+    fn test_as_string(){\n+        let json_value = from_str(\"\\\"dog\\\"\").unwrap();\n+        let json_str = json_value.as_string();\n+        let expected_str = &\"dog\";\n+        assert_eq!(json_str, Some(expected_str));\n+    }\n+\n+    #[test]\n+    fn test_is_number(){\n+        let json_value = from_str(\"12\").unwrap();\n+        assert!(json_value.is_number());\n+    }\n+\n+    #[test]\n+    fn test_as_number(){\n+        let json_value = from_str(\"12\").unwrap();\n+        let json_num = json_value.as_number();\n+        let expected_num = 12f64;\n+        assert!(json_num.is_some() && json_num.unwrap() == expected_num);\n+    }\n+\n+    #[test]\n+    fn test_is_boolean(){\n+        let json_value = from_str(\"false\").unwrap();\n+        assert!(json_value.is_boolean());\n+    }\n+\n+    #[test]\n+    fn test_as_boolean(){\n+        let json_value = from_str(\"false\").unwrap();\n+        let json_bool = json_value.as_boolean();\n+        let expected_bool = false;\n+        assert!(json_bool.is_some() && json_bool.unwrap() == expected_bool);\n+    }\n+\n+    #[test]\n+    fn test_is_null(){\n+        let json_value = from_str(\"null\").unwrap();\n+        assert!(json_value.is_null());\n+    }\n+\n+    #[test]\n+    fn test_as_null(){\n+        let json_value = from_str(\"null\").unwrap();\n+        let json_null = json_value.as_null();\n+        let expected_null = ();\n+        assert!(json_null.is_some() && json_null.unwrap() == expected_null);\n+    }\n+\n+    #[test]\n+    fn test_encode_hashmap_with_numeric_key() {\n+        use std::str::from_utf8;\n+        use std::io::Writer;\n+        use std::io::MemWriter;\n+        use collections::HashMap;\n+        let mut hm: HashMap<uint, bool> = HashMap::new();\n+        hm.insert(1, true);\n+        let mut mem_buf = MemWriter::new();\n+        {\n+            let mut encoder = Encoder::new(&mut mem_buf as &mut io::Writer);\n+            hm.encode(&mut encoder)\n+        }\n+        let bytes = mem_buf.unwrap();\n+        let json_str = from_utf8(bytes).unwrap();\n+        match from_str(json_str) {\n+            Err(_) => fail!(\"Unable to parse json_str: {:?}\", json_str),\n+            _ => {} // it parsed and we are good to go\n+        }\n+    }\n+    #[test]\n+    fn test_prettyencode_hashmap_with_numeric_key() {\n+        use std::str::from_utf8;\n+        use std::io::Writer;\n+        use std::io::MemWriter;\n+        use collections::HashMap;\n+        let mut hm: HashMap<uint, bool> = HashMap::new();\n+        hm.insert(1, true);\n+        let mut mem_buf = MemWriter::new();\n+        {\n+            let mut encoder = PrettyEncoder::new(&mut mem_buf as &mut io::Writer);\n+            hm.encode(&mut encoder)\n+        }\n+        let bytes = mem_buf.unwrap();\n+        let json_str = from_utf8(bytes).unwrap();\n+        match from_str(json_str) {\n+            Err(_) => fail!(\"Unable to parse json_str: {:?}\", json_str),\n+            _ => {} // it parsed and we are good to go\n+        }\n+    }\n+    #[test]\n+    fn test_hashmap_with_numeric_key_can_handle_double_quote_delimited_key() {\n+        use collections::HashMap;\n+        use Decodable;\n+        let json_str = \"{\\\"1\\\":true}\";\n+        let json_obj = match from_str(json_str) {\n+            Err(_) => fail!(\"Unable to parse json_str: {:?}\", json_str),\n+            Ok(o) => o\n+        };\n+        let mut decoder = Decoder::new(json_obj);\n+        let _hm: HashMap<uint, bool> = Decodable::decode(&mut decoder);\n+    }\n+}\n+"}, {"sha": "86e03aae6733ce565415c5d395e75c461f082ef9", "filename": "src/libserialize/lib.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/f1739b14a1346419a4598339aee32aab07e0d12e/src%2Flibserialize%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1739b14a1346419a4598339aee32aab07e0d12e/src%2Flibserialize%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Flib.rs?ref=f1739b14a1346419a4598339aee32aab07e0d12e", "patch": "@@ -34,10 +34,31 @@ extern crate collections;\n pub use self::serialize::{Decoder, Encoder, Decodable, Encodable,\n                           DecoderHelpers, EncoderHelpers};\n \n+// FIXME: remove _old.rs files after snapshot\n+#[cfg(not(stage0))]\n mod serialize;\n+#[cfg(not(stage0))]\n mod collection_impls;\n \n pub mod base64;\n+#[cfg(not(stage0))]\n pub mod ebml;\n pub mod hex;\n+#[cfg(not(stage0))]\n+pub mod json;\n+\n+#[cfg(stage0)]\n+#[path=\"./serialize_old.rs\"]\n+pub mod serialize;\n+\n+#[cfg(stage0)]\n+#[path=\"./collection_impls_old.rs\"]\n+mod collection_impls;\n+\n+#[cfg(stage0)]\n+#[path=\"./ebml_old.rs\"]\n+pub mod ebml;\n+\n+#[cfg(stage0)]\n+#[path=\"./json_old.rs\"]\n pub mod json;"}, {"sha": "6cda8d9ffb5801f8d6fed88a3606bf03f43914fb", "filename": "src/libserialize/serialize.rs", "status": "modified", "additions": 250, "deletions": 223, "changes": 473, "blob_url": "https://github.com/rust-lang/rust/blob/f1739b14a1346419a4598339aee32aab07e0d12e/src%2Flibserialize%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1739b14a1346419a4598339aee32aab07e0d12e/src%2Flibserialize%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fserialize.rs?ref=f1739b14a1346419a4598339aee32aab07e0d12e", "patch": "@@ -18,444 +18,465 @@ use std::path;\n use std::rc::Rc;\n use std::slice;\n \n-pub trait Encoder {\n+pub trait Encoder<E> {\n     // Primitive types:\n-    fn emit_nil(&mut self);\n-    fn emit_uint(&mut self, v: uint);\n-    fn emit_u64(&mut self, v: u64);\n-    fn emit_u32(&mut self, v: u32);\n-    fn emit_u16(&mut self, v: u16);\n-    fn emit_u8(&mut self, v: u8);\n-    fn emit_int(&mut self, v: int);\n-    fn emit_i64(&mut self, v: i64);\n-    fn emit_i32(&mut self, v: i32);\n-    fn emit_i16(&mut self, v: i16);\n-    fn emit_i8(&mut self, v: i8);\n-    fn emit_bool(&mut self, v: bool);\n-    fn emit_f64(&mut self, v: f64);\n-    fn emit_f32(&mut self, v: f32);\n-    fn emit_char(&mut self, v: char);\n-    fn emit_str(&mut self, v: &str);\n+    fn emit_nil(&mut self) -> Result<(), E>;\n+    fn emit_uint(&mut self, v: uint) -> Result<(), E>;\n+    fn emit_u64(&mut self, v: u64) -> Result<(), E>;\n+    fn emit_u32(&mut self, v: u32) -> Result<(), E>;\n+    fn emit_u16(&mut self, v: u16) -> Result<(), E>;\n+    fn emit_u8(&mut self, v: u8) -> Result<(), E>;\n+    fn emit_int(&mut self, v: int) -> Result<(), E>;\n+    fn emit_i64(&mut self, v: i64) -> Result<(), E>;\n+    fn emit_i32(&mut self, v: i32) -> Result<(), E>;\n+    fn emit_i16(&mut self, v: i16) -> Result<(), E>;\n+    fn emit_i8(&mut self, v: i8) -> Result<(), E>;\n+    fn emit_bool(&mut self, v: bool) -> Result<(), E>;\n+    fn emit_f64(&mut self, v: f64) -> Result<(), E>;\n+    fn emit_f32(&mut self, v: f32) -> Result<(), E>;\n+    fn emit_char(&mut self, v: char) -> Result<(), E>;\n+    fn emit_str(&mut self, v: &str) -> Result<(), E>;\n \n     // Compound types:\n-    fn emit_enum(&mut self, name: &str, f: |&mut Self|);\n+    fn emit_enum(&mut self, name: &str, f: |&mut Self| -> Result<(), E>) -> Result<(), E>;\n \n     fn emit_enum_variant(&mut self,\n                          v_name: &str,\n                          v_id: uint,\n                          len: uint,\n-                         f: |&mut Self|);\n-    fn emit_enum_variant_arg(&mut self, a_idx: uint, f: |&mut Self|);\n+                         f: |&mut Self| -> Result<(), E>) -> Result<(), E>;\n+    fn emit_enum_variant_arg(&mut self,\n+                             a_idx: uint,\n+                             f: |&mut Self| -> Result<(), E>) -> Result<(), E>;\n \n     fn emit_enum_struct_variant(&mut self,\n                                 v_name: &str,\n                                 v_id: uint,\n                                 len: uint,\n-                                f: |&mut Self|);\n+                                f: |&mut Self| -> Result<(), E>) -> Result<(), E>;\n     fn emit_enum_struct_variant_field(&mut self,\n                                       f_name: &str,\n                                       f_idx: uint,\n-                                      f: |&mut Self|);\n+                                      f: |&mut Self| -> Result<(), E>) -> Result<(), E>;\n \n-    fn emit_struct(&mut self, name: &str, len: uint, f: |&mut Self|);\n+    fn emit_struct(&mut self,\n+                   name: &str,\n+                   len: uint,\n+                   f: |&mut Self| -> Result<(), E>) -> Result<(), E>;\n     fn emit_struct_field(&mut self,\n                          f_name: &str,\n                          f_idx: uint,\n-                         f: |&mut Self|);\n+                         f: |&mut Self| -> Result<(), E>) -> Result<(), E>;\n \n-    fn emit_tuple(&mut self, len: uint, f: |&mut Self|);\n-    fn emit_tuple_arg(&mut self, idx: uint, f: |&mut Self|);\n+    fn emit_tuple(&mut self, len: uint, f: |&mut Self| -> Result<(), E>) -> Result<(), E>;\n+    fn emit_tuple_arg(&mut self, idx: uint, f: |&mut Self| -> Result<(), E>) -> Result<(), E>;\n \n-    fn emit_tuple_struct(&mut self, name: &str, len: uint, f: |&mut Self|);\n-    fn emit_tuple_struct_arg(&mut self, f_idx: uint, f: |&mut Self|);\n+    fn emit_tuple_struct(&mut self,\n+                         name: &str,\n+                         len: uint,\n+                         f: |&mut Self| -> Result<(), E>) -> Result<(), E>;\n+    fn emit_tuple_struct_arg(&mut self,\n+                             f_idx: uint,\n+                             f: |&mut Self| -> Result<(), E>) -> Result<(), E>;\n \n     // Specialized types:\n-    fn emit_option(&mut self, f: |&mut Self|);\n-    fn emit_option_none(&mut self);\n-    fn emit_option_some(&mut self, f: |&mut Self|);\n+    fn emit_option(&mut self, f: |&mut Self| -> Result<(), E>) -> Result<(), E>;\n+    fn emit_option_none(&mut self) -> Result<(), E>;\n+    fn emit_option_some(&mut self, f: |&mut Self| -> Result<(), E>) -> Result<(), E>;\n \n-    fn emit_seq(&mut self, len: uint, f: |this: &mut Self|);\n-    fn emit_seq_elt(&mut self, idx: uint, f: |this: &mut Self|);\n+    fn emit_seq(&mut self, len: uint, f: |this: &mut Self| -> Result<(), E>) -> Result<(), E>;\n+    fn emit_seq_elt(&mut self, idx: uint, f: |this: &mut Self| -> Result<(), E>) -> Result<(), E>;\n \n-    fn emit_map(&mut self, len: uint, f: |&mut Self|);\n-    fn emit_map_elt_key(&mut self, idx: uint, f: |&mut Self|);\n-    fn emit_map_elt_val(&mut self, idx: uint, f: |&mut Self|);\n+    fn emit_map(&mut self, len: uint, f: |&mut Self| -> Result<(), E>) -> Result<(), E>;\n+    fn emit_map_elt_key(&mut self, idx: uint, f: |&mut Self| -> Result<(), E>) -> Result<(), E>;\n+    fn emit_map_elt_val(&mut self, idx: uint, f: |&mut Self| -> Result<(), E>) -> Result<(), E>;\n }\n \n-pub trait Decoder {\n+pub trait Decoder<E> {\n     // Primitive types:\n-    fn read_nil(&mut self) -> ();\n-    fn read_uint(&mut self) -> uint;\n-    fn read_u64(&mut self) -> u64;\n-    fn read_u32(&mut self) -> u32;\n-    fn read_u16(&mut self) -> u16;\n-    fn read_u8(&mut self) -> u8;\n-    fn read_int(&mut self) -> int;\n-    fn read_i64(&mut self) -> i64;\n-    fn read_i32(&mut self) -> i32;\n-    fn read_i16(&mut self) -> i16;\n-    fn read_i8(&mut self) -> i8;\n-    fn read_bool(&mut self) -> bool;\n-    fn read_f64(&mut self) -> f64;\n-    fn read_f32(&mut self) -> f32;\n-    fn read_char(&mut self) -> char;\n-    fn read_str(&mut self) -> ~str;\n+    fn read_nil(&mut self) -> Result<(), E>;\n+    fn read_uint(&mut self) -> Result<uint, E>;\n+    fn read_u64(&mut self) -> Result<u64, E>;\n+    fn read_u32(&mut self) -> Result<u32, E>;\n+    fn read_u16(&mut self) -> Result<u16, E>;\n+    fn read_u8(&mut self) -> Result<u8, E>;\n+    fn read_int(&mut self) -> Result<int, E>;\n+    fn read_i64(&mut self) -> Result<i64, E>;\n+    fn read_i32(&mut self) -> Result<i32, E>;\n+    fn read_i16(&mut self) -> Result<i16, E>;\n+    fn read_i8(&mut self) -> Result<i8, E>;\n+    fn read_bool(&mut self) -> Result<bool, E>;\n+    fn read_f64(&mut self) -> Result<f64, E>;\n+    fn read_f32(&mut self) -> Result<f32, E>;\n+    fn read_char(&mut self) -> Result<char, E>;\n+    fn read_str(&mut self) -> Result<~str, E>;\n \n     // Compound types:\n-    fn read_enum<T>(&mut self, name: &str, f: |&mut Self| -> T) -> T;\n+    fn read_enum<T>(&mut self, name: &str, f: |&mut Self| -> Result<T, E>) -> Result<T, E>;\n \n     fn read_enum_variant<T>(&mut self,\n                             names: &[&str],\n-                            f: |&mut Self, uint| -> T)\n-                            -> T;\n+                            f: |&mut Self, uint| -> Result<T, E>)\n+                            -> Result<T, E>;\n     fn read_enum_variant_arg<T>(&mut self,\n                                 a_idx: uint,\n-                                f: |&mut Self| -> T)\n-                                -> T;\n+                                f: |&mut Self| -> Result<T, E>)\n+                                -> Result<T, E>;\n \n     fn read_enum_struct_variant<T>(&mut self,\n                                    names: &[&str],\n-                                   f: |&mut Self, uint| -> T)\n-                                   -> T;\n+                                   f: |&mut Self, uint| -> Result<T, E>)\n+                                   -> Result<T, E>;\n     fn read_enum_struct_variant_field<T>(&mut self,\n                                          &f_name: &str,\n                                          f_idx: uint,\n-                                         f: |&mut Self| -> T)\n-                                         -> T;\n+                                         f: |&mut Self| -> Result<T, E>)\n+                                         -> Result<T, E>;\n \n-    fn read_struct<T>(&mut self, s_name: &str, len: uint, f: |&mut Self| -> T)\n-                      -> T;\n+    fn read_struct<T>(&mut self, s_name: &str, len: uint, f: |&mut Self| -> Result<T, E>)\n+                      -> Result<T, E>;\n     fn read_struct_field<T>(&mut self,\n                             f_name: &str,\n                             f_idx: uint,\n-                            f: |&mut Self| -> T)\n-                            -> T;\n+                            f: |&mut Self| -> Result<T, E>)\n+                            -> Result<T, E>;\n \n-    fn read_tuple<T>(&mut self, f: |&mut Self, uint| -> T) -> T;\n-    fn read_tuple_arg<T>(&mut self, a_idx: uint, f: |&mut Self| -> T) -> T;\n+    fn read_tuple<T>(&mut self, f: |&mut Self, uint| -> Result<T, E>) -> Result<T, E>;\n+    fn read_tuple_arg<T>(&mut self, a_idx: uint, f: |&mut Self| -> Result<T, E>) -> Result<T, E>;\n \n     fn read_tuple_struct<T>(&mut self,\n                             s_name: &str,\n-                            f: |&mut Self, uint| -> T)\n-                            -> T;\n+                            f: |&mut Self, uint| -> Result<T, E>)\n+                            -> Result<T, E>;\n     fn read_tuple_struct_arg<T>(&mut self,\n                                 a_idx: uint,\n-                                f: |&mut Self| -> T)\n-                                -> T;\n+                                f: |&mut Self| -> Result<T, E>)\n+                                -> Result<T, E>;\n \n     // Specialized types:\n-    fn read_option<T>(&mut self, f: |&mut Self, bool| -> T) -> T;\n+    fn read_option<T>(&mut self, f: |&mut Self, bool| -> Result<T, E>) -> Result<T, E>;\n \n-    fn read_seq<T>(&mut self, f: |&mut Self, uint| -> T) -> T;\n-    fn read_seq_elt<T>(&mut self, idx: uint, f: |&mut Self| -> T) -> T;\n+    fn read_seq<T>(&mut self, f: |&mut Self, uint| -> Result<T, E>) -> Result<T, E>;\n+    fn read_seq_elt<T>(&mut self, idx: uint, f: |&mut Self| -> Result<T, E>) -> Result<T, E>;\n \n-    fn read_map<T>(&mut self, f: |&mut Self, uint| -> T) -> T;\n-    fn read_map_elt_key<T>(&mut self, idx: uint, f: |&mut Self| -> T) -> T;\n-    fn read_map_elt_val<T>(&mut self, idx: uint, f: |&mut Self| -> T) -> T;\n+    fn read_map<T>(&mut self, f: |&mut Self, uint| -> Result<T, E>) -> Result<T, E>;\n+    fn read_map_elt_key<T>(&mut self, idx: uint, f: |&mut Self| -> Result<T, E>) -> Result<T, E>;\n+    fn read_map_elt_val<T>(&mut self, idx: uint, f: |&mut Self| -> Result<T, E>) -> Result<T, E>;\n }\n \n-pub trait Encodable<S:Encoder> {\n-    fn encode(&self, s: &mut S);\n+pub trait Encodable<S:Encoder<E>, E> {\n+    fn encode(&self, s: &mut S) -> Result<(), E>;\n }\n \n-pub trait Decodable<D:Decoder> {\n-    fn decode(d: &mut D) -> Self;\n+pub trait Decodable<D:Decoder<E>, E> {\n+    fn decode(d: &mut D) -> Result<Self, E>;\n }\n \n-impl<S:Encoder> Encodable<S> for uint {\n-    fn encode(&self, s: &mut S) {\n+macro_rules! try ( ($e:expr) => (\n+    match $e { Ok(v) => v, Err(e) => return Err(e) }\n+))\n+\n+impl<E, S:Encoder<E>> Encodable<S, E> for uint {\n+    fn encode(&self, s: &mut S) -> Result<(), E> {\n         s.emit_uint(*self)\n     }\n }\n \n-impl<D:Decoder> Decodable<D> for uint {\n-    fn decode(d: &mut D) -> uint {\n+impl<E, D:Decoder<E>> Decodable<D, E> for uint {\n+    fn decode(d: &mut D) -> Result<uint, E> {\n         d.read_uint()\n     }\n }\n \n-impl<S:Encoder> Encodable<S> for u8 {\n-    fn encode(&self, s: &mut S) {\n+impl<E, S:Encoder<E>> Encodable<S, E> for u8 {\n+    fn encode(&self, s: &mut S) -> Result<(), E> {\n         s.emit_u8(*self)\n     }\n }\n \n-impl<D:Decoder> Decodable<D> for u8 {\n-    fn decode(d: &mut D) -> u8 {\n+impl<E, D:Decoder<E>> Decodable<D, E> for u8 {\n+    fn decode(d: &mut D) -> Result<u8, E> {\n         d.read_u8()\n     }\n }\n \n-impl<S:Encoder> Encodable<S> for u16 {\n-    fn encode(&self, s: &mut S) {\n+impl<E, S:Encoder<E>> Encodable<S, E> for u16 {\n+    fn encode(&self, s: &mut S) -> Result<(), E> {\n         s.emit_u16(*self)\n     }\n }\n \n-impl<D:Decoder> Decodable<D> for u16 {\n-    fn decode(d: &mut D) -> u16 {\n+impl<E, D:Decoder<E>> Decodable<D, E> for u16 {\n+    fn decode(d: &mut D) -> Result<u16, E> {\n         d.read_u16()\n     }\n }\n \n-impl<S:Encoder> Encodable<S> for u32 {\n-    fn encode(&self, s: &mut S) {\n+impl<E, S:Encoder<E>> Encodable<S, E> for u32 {\n+    fn encode(&self, s: &mut S) -> Result<(), E> {\n         s.emit_u32(*self)\n     }\n }\n \n-impl<D:Decoder> Decodable<D> for u32 {\n-    fn decode(d: &mut D) -> u32 {\n+impl<E, D:Decoder<E>> Decodable<D, E> for u32 {\n+    fn decode(d: &mut D) -> Result<u32, E> {\n         d.read_u32()\n     }\n }\n \n-impl<S:Encoder> Encodable<S> for u64 {\n-    fn encode(&self, s: &mut S) {\n+impl<E, S:Encoder<E>> Encodable<S, E> for u64 {\n+    fn encode(&self, s: &mut S) -> Result<(), E> {\n         s.emit_u64(*self)\n     }\n }\n \n-impl<D:Decoder> Decodable<D> for u64 {\n-    fn decode(d: &mut D) -> u64 {\n+impl<E, D:Decoder<E>> Decodable<D, E> for u64 {\n+    fn decode(d: &mut D) -> Result<u64, E> {\n         d.read_u64()\n     }\n }\n \n-impl<S:Encoder> Encodable<S> for int {\n-    fn encode(&self, s: &mut S) {\n+impl<E, S:Encoder<E>> Encodable<S, E> for int {\n+    fn encode(&self, s: &mut S) -> Result<(), E> {\n         s.emit_int(*self)\n     }\n }\n \n-impl<D:Decoder> Decodable<D> for int {\n-    fn decode(d: &mut D) -> int {\n+impl<E, D:Decoder<E>> Decodable<D, E> for int {\n+    fn decode(d: &mut D) -> Result<int, E> {\n         d.read_int()\n     }\n }\n \n-impl<S:Encoder> Encodable<S> for i8 {\n-    fn encode(&self, s: &mut S) {\n+impl<E, S:Encoder<E>> Encodable<S, E> for i8 {\n+    fn encode(&self, s: &mut S) -> Result<(), E> {\n         s.emit_i8(*self)\n     }\n }\n \n-impl<D:Decoder> Decodable<D> for i8 {\n-    fn decode(d: &mut D) -> i8 {\n+impl<E, D:Decoder<E>> Decodable<D, E> for i8 {\n+    fn decode(d: &mut D) -> Result<i8, E> {\n         d.read_i8()\n     }\n }\n \n-impl<S:Encoder> Encodable<S> for i16 {\n-    fn encode(&self, s: &mut S) {\n+impl<E, S:Encoder<E>> Encodable<S, E> for i16 {\n+    fn encode(&self, s: &mut S) -> Result<(), E> {\n         s.emit_i16(*self)\n     }\n }\n \n-impl<D:Decoder> Decodable<D> for i16 {\n-    fn decode(d: &mut D) -> i16 {\n+impl<E, D:Decoder<E>> Decodable<D, E> for i16 {\n+    fn decode(d: &mut D) -> Result<i16, E> {\n         d.read_i16()\n     }\n }\n \n-impl<S:Encoder> Encodable<S> for i32 {\n-    fn encode(&self, s: &mut S) {\n+impl<E, S:Encoder<E>> Encodable<S, E> for i32 {\n+    fn encode(&self, s: &mut S) -> Result<(), E> {\n         s.emit_i32(*self)\n     }\n }\n \n-impl<D:Decoder> Decodable<D> for i32 {\n-    fn decode(d: &mut D) -> i32 {\n+impl<E, D:Decoder<E>> Decodable<D, E> for i32 {\n+    fn decode(d: &mut D) -> Result<i32, E> {\n         d.read_i32()\n     }\n }\n \n-impl<S:Encoder> Encodable<S> for i64 {\n-    fn encode(&self, s: &mut S) {\n+impl<E, S:Encoder<E>> Encodable<S, E> for i64 {\n+    fn encode(&self, s: &mut S) -> Result<(), E> {\n         s.emit_i64(*self)\n     }\n }\n \n-impl<D:Decoder> Decodable<D> for i64 {\n-    fn decode(d: &mut D) -> i64 {\n+impl<E, D:Decoder<E>> Decodable<D, E> for i64 {\n+    fn decode(d: &mut D) -> Result<i64, E> {\n         d.read_i64()\n     }\n }\n \n-impl<'a, S:Encoder> Encodable<S> for &'a str {\n-    fn encode(&self, s: &mut S) {\n+impl<'a, E, S:Encoder<E>> Encodable<S, E> for &'a str {\n+    fn encode(&self, s: &mut S) -> Result<(), E> {\n         s.emit_str(*self)\n     }\n }\n \n-impl<S:Encoder> Encodable<S> for ~str {\n-    fn encode(&self, s: &mut S) {\n+impl<E, S:Encoder<E>> Encodable<S, E> for ~str {\n+    fn encode(&self, s: &mut S) -> Result<(), E> {\n         s.emit_str(*self)\n     }\n }\n \n-impl<D:Decoder> Decodable<D> for ~str {\n-    fn decode(d: &mut D) -> ~str {\n+impl<E, D:Decoder<E>> Decodable<D, E> for ~str {\n+    fn decode(d: &mut D) -> Result<~str, E> {\n         d.read_str()\n     }\n }\n \n-impl<S:Encoder> Encodable<S> for f32 {\n-    fn encode(&self, s: &mut S) {\n+impl<E, S:Encoder<E>> Encodable<S, E> for f32 {\n+    fn encode(&self, s: &mut S) -> Result<(), E> {\n         s.emit_f32(*self)\n     }\n }\n \n-impl<D:Decoder> Decodable<D> for f32 {\n-    fn decode(d: &mut D) -> f32 {\n+impl<E, D:Decoder<E>> Decodable<D, E> for f32 {\n+    fn decode(d: &mut D) -> Result<f32, E> {\n         d.read_f32()\n     }\n }\n \n-impl<S:Encoder> Encodable<S> for f64 {\n-    fn encode(&self, s: &mut S) {\n+impl<E, S:Encoder<E>> Encodable<S, E> for f64 {\n+    fn encode(&self, s: &mut S) -> Result<(), E> {\n         s.emit_f64(*self)\n     }\n }\n \n-impl<D:Decoder> Decodable<D> for f64 {\n-    fn decode(d: &mut D) -> f64 {\n+impl<E, D:Decoder<E>> Decodable<D, E> for f64 {\n+    fn decode(d: &mut D) -> Result<f64, E> {\n         d.read_f64()\n     }\n }\n \n-impl<S:Encoder> Encodable<S> for bool {\n-    fn encode(&self, s: &mut S) {\n+impl<E, S:Encoder<E>> Encodable<S, E> for bool {\n+    fn encode(&self, s: &mut S) -> Result<(), E> {\n         s.emit_bool(*self)\n     }\n }\n \n-impl<D:Decoder> Decodable<D> for bool {\n-    fn decode(d: &mut D) -> bool {\n+impl<E, D:Decoder<E>> Decodable<D, E> for bool {\n+    fn decode(d: &mut D) -> Result<bool, E> {\n         d.read_bool()\n     }\n }\n \n-impl<S:Encoder> Encodable<S> for char {\n-    fn encode(&self, s: &mut S) {\n+impl<E, S:Encoder<E>> Encodable<S, E> for char {\n+    fn encode(&self, s: &mut S) -> Result<(), E> {\n         s.emit_char(*self)\n     }\n }\n \n-impl<D:Decoder> Decodable<D> for char {\n-    fn decode(d: &mut D) -> char {\n+impl<E, D:Decoder<E>> Decodable<D, E> for char {\n+    fn decode(d: &mut D) -> Result<char, E> {\n         d.read_char()\n     }\n }\n \n-impl<S:Encoder> Encodable<S> for () {\n-    fn encode(&self, s: &mut S) {\n+impl<E, S:Encoder<E>> Encodable<S, E> for () {\n+    fn encode(&self, s: &mut S) -> Result<(), E> {\n         s.emit_nil()\n     }\n }\n \n-impl<D:Decoder> Decodable<D> for () {\n-    fn decode(d: &mut D) -> () {\n+impl<E, D:Decoder<E>> Decodable<D, E> for () {\n+    fn decode(d: &mut D) -> Result<(), E> {\n         d.read_nil()\n     }\n }\n \n-impl<'a, S:Encoder,T:Encodable<S>> Encodable<S> for &'a T {\n-    fn encode(&self, s: &mut S) {\n+impl<'a, E, S:Encoder<E>,T:Encodable<S, E>> Encodable<S, E> for &'a T {\n+    fn encode(&self, s: &mut S) -> Result<(), E> {\n         (**self).encode(s)\n     }\n }\n \n-impl<S:Encoder,T:Encodable<S>> Encodable<S> for ~T {\n-    fn encode(&self, s: &mut S) {\n+impl<E, S:Encoder<E>,T:Encodable<S, E>> Encodable<S, E> for ~T {\n+    fn encode(&self, s: &mut S) -> Result<(), E> {\n         (**self).encode(s)\n     }\n }\n \n-impl<D:Decoder,T:Decodable<D>> Decodable<D> for ~T {\n-    fn decode(d: &mut D) -> ~T {\n-        ~Decodable::decode(d)\n+impl<E, D:Decoder<E>,T:Decodable<D, E>> Decodable<D, E> for ~T {\n+    fn decode(d: &mut D) -> Result<~T, E> {\n+        Ok(~try!(Decodable::decode(d)))\n     }\n }\n \n-impl<S:Encoder,T:Encodable<S>> Encodable<S> for @T {\n-    fn encode(&self, s: &mut S) {\n+impl<E, S:Encoder<E>,T:Encodable<S, E>> Encodable<S, E> for @T {\n+    fn encode(&self, s: &mut S) -> Result<(), E> {\n         (**self).encode(s)\n     }\n }\n \n-impl<S:Encoder,T:Encodable<S>> Encodable<S> for Rc<T> {\n+impl<E, S:Encoder<E>,T:Encodable<S, E>> Encodable<S, E> for Rc<T> {\n     #[inline]\n-    fn encode(&self, s: &mut S) {\n+    fn encode(&self, s: &mut S) -> Result<(), E> {\n         (**self).encode(s)\n     }\n }\n \n-impl<D:Decoder,T:Decodable<D>> Decodable<D> for Rc<T> {\n+impl<E, D:Decoder<E>,T:Decodable<D, E>> Decodable<D, E> for Rc<T> {\n     #[inline]\n-    fn decode(d: &mut D) -> Rc<T> {\n-        Rc::new(Decodable::decode(d))\n+    fn decode(d: &mut D) -> Result<Rc<T>, E> {\n+        Ok(Rc::new(try!(Decodable::decode(d))))\n     }\n }\n \n-impl<D:Decoder,T:Decodable<D> + 'static> Decodable<D> for @T {\n-    fn decode(d: &mut D) -> @T {\n-        @Decodable::decode(d)\n+impl<E, D:Decoder<E>,T:Decodable<D, E> + 'static> Decodable<D, E> for @T {\n+    fn decode(d: &mut D) -> Result<@T, E> {\n+        Ok(@try!(Decodable::decode(d)))\n     }\n }\n \n-impl<'a, S:Encoder,T:Encodable<S>> Encodable<S> for &'a [T] {\n-    fn encode(&self, s: &mut S) {\n+impl<'a, E, S:Encoder<E>,T:Encodable<S, E>> Encodable<S, E> for &'a [T] {\n+    fn encode(&self, s: &mut S) -> Result<(), E> {\n         s.emit_seq(self.len(), |s| {\n             for (i, e) in self.iter().enumerate() {\n-                s.emit_seq_elt(i, |s| e.encode(s))\n+                try!(s.emit_seq_elt(i, |s| e.encode(s)))\n             }\n+            Ok(())\n         })\n     }\n }\n \n-impl<S:Encoder,T:Encodable<S>> Encodable<S> for ~[T] {\n-    fn encode(&self, s: &mut S) {\n+impl<E, S:Encoder<E>,T:Encodable<S, E>> Encodable<S, E> for ~[T] {\n+    fn encode(&self, s: &mut S) -> Result<(), E> {\n         s.emit_seq(self.len(), |s| {\n             for (i, e) in self.iter().enumerate() {\n-                s.emit_seq_elt(i, |s| e.encode(s))\n+                try!(s.emit_seq_elt(i, |s| e.encode(s)))\n             }\n+            Ok(())\n         })\n     }\n }\n \n-impl<D:Decoder,T:Decodable<D>> Decodable<D> for ~[T] {\n-    fn decode(d: &mut D) -> ~[T] {\n+impl<E, D:Decoder<E>,T:Decodable<D, E>> Decodable<D, E> for ~[T] {\n+    fn decode(d: &mut D) -> Result<~[T], E> {\n         d.read_seq(|d, len| {\n-            slice::from_fn(len, |i| {\n-                d.read_seq_elt(i, |d| Decodable::decode(d))\n-            })\n+            let mut v: ~[T] = slice::with_capacity(len);\n+            for i in range(0, len) {\n+                v.push(try!(d.read_seq_elt(i, |d| Decodable::decode(d))));\n+            }\n+            Ok(v)\n         })\n     }\n }\n \n-impl<S:Encoder,T:Encodable<S>> Encodable<S> for Vec<T> {\n-    fn encode(&self, s: &mut S) {\n+impl<E, S:Encoder<E>,T:Encodable<S, E>> Encodable<S, E> for Vec<T> {\n+    fn encode(&self, s: &mut S) -> Result<(), E> {\n         s.emit_seq(self.len(), |s| {\n             for (i, e) in self.iter().enumerate() {\n-                s.emit_seq_elt(i, |s| e.encode(s))\n+                try!(s.emit_seq_elt(i, |s| e.encode(s)))\n             }\n+            Ok(())\n         })\n     }\n }\n \n-impl<D:Decoder,T:Decodable<D>> Decodable<D> for Vec<T> {\n-    fn decode(d: &mut D) -> Vec<T> {\n+impl<E, D:Decoder<E>,T:Decodable<D, E>> Decodable<D, E> for Vec<T> {\n+    fn decode(d: &mut D) -> Result<Vec<T>, E> {\n         d.read_seq(|d, len| {\n-            Vec::from_fn(len, |i| {\n-                d.read_seq_elt(i, |d| Decodable::decode(d))\n-            })\n+            let mut v = Vec::with_capacity(len);\n+            for i in range(0, len) {\n+                v.push(try!(d.read_seq_elt(i, |d| Decodable::decode(d))));\n+            }\n+            Ok(v)\n         })\n     }\n }\n \n-impl<S:Encoder,T:Encodable<S>> Encodable<S> for Option<T> {\n-    fn encode(&self, s: &mut S) {\n+impl<E, S:Encoder<E>,T:Encodable<S, E>> Encodable<S, E> for Option<T> {\n+    fn encode(&self, s: &mut S) -> Result<(), E> {\n         s.emit_option(|s| {\n             match *self {\n                 None => s.emit_option_none(),\n@@ -465,13 +486,13 @@ impl<S:Encoder,T:Encodable<S>> Encodable<S> for Option<T> {\n     }\n }\n \n-impl<D:Decoder,T:Decodable<D>> Decodable<D> for Option<T> {\n-    fn decode(d: &mut D) -> Option<T> {\n+impl<E, D:Decoder<E>,T:Decodable<D, E>> Decodable<D, E> for Option<T> {\n+    fn decode(d: &mut D) -> Result<Option<T>, E> {\n         d.read_option(|d, b| {\n             if b {\n-                Some(Decodable::decode(d))\n+                Ok(Some(try!(Decodable::decode(d))))\n             } else {\n-                None\n+                Ok(None)\n             }\n         })\n     }\n@@ -482,30 +503,31 @@ macro_rules! peel(($name:ident, $($other:ident,)*) => (tuple!($($other,)*)))\n macro_rules! tuple (\n     () => ();\n     ( $($name:ident,)+ ) => (\n-        impl<D:Decoder,$($name:Decodable<D>),*> Decodable<D> for ($($name,)*) {\n+        impl<E, D:Decoder<E>,$($name:Decodable<D, E>),*> Decodable<D,E> for ($($name,)*) {\n             #[allow(uppercase_variables)]\n-            fn decode(d: &mut D) -> ($($name,)*) {\n+            fn decode(d: &mut D) -> Result<($($name,)*), E> {\n                 d.read_tuple(|d, amt| {\n                     let mut i = 0;\n-                    let ret = ($(d.read_tuple_arg({ i+=1; i-1 }, |d| -> $name {\n+                    let ret = ($(try!(d.read_tuple_arg({ i+=1; i-1 }, |d| -> Result<$name,E> {\n                         Decodable::decode(d)\n-                    }),)*);\n+                    })),)*);\n                     assert!(amt == i,\n                             \"expected tuple of length `{}`, found tuple \\\n                              of length `{}`\", i, amt);\n-                    return ret;\n+                    return Ok(ret);\n                 })\n             }\n         }\n-        impl<S:Encoder,$($name:Encodable<S>),*> Encodable<S> for ($($name,)*) {\n+        impl<E, S:Encoder<E>,$($name:Encodable<S, E>),*> Encodable<S, E> for ($($name,)*) {\n             #[allow(uppercase_variables)]\n-            fn encode(&self, s: &mut S) {\n+            fn encode(&self, s: &mut S) -> Result<(), E> {\n                 let ($(ref $name,)*) = *self;\n                 let mut n = 0;\n                 $(let $name = $name; n += 1;)*\n                 s.emit_tuple(n, |s| {\n                     let mut i = 0;\n-                    $(s.emit_seq_elt({ i+=1; i-1 }, |s| $name.encode(s));)*\n+                    $(try!(s.emit_seq_elt({ i+=1; i-1 }, |s| $name.encode(s)));)*\n+                    Ok(())\n                 })\n             }\n         }\n@@ -515,29 +537,29 @@ macro_rules! tuple (\n \n tuple! { T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, }\n \n-impl<E: Encoder> Encodable<E> for path::posix::Path {\n-    fn encode(&self, e: &mut E) {\n+impl<E, S: Encoder<E>> Encodable<S, E> for path::posix::Path {\n+    fn encode(&self, e: &mut S) -> Result<(), E> {\n         self.as_vec().encode(e)\n     }\n }\n \n-impl<D: Decoder> Decodable<D> for path::posix::Path {\n-    fn decode(d: &mut D) -> path::posix::Path {\n-        let bytes: ~[u8] = Decodable::decode(d);\n-        path::posix::Path::new(bytes)\n+impl<E, D: Decoder<E>> Decodable<D, E> for path::posix::Path {\n+    fn decode(d: &mut D) -> Result<path::posix::Path, E> {\n+        let bytes: ~[u8] = try!(Decodable::decode(d));\n+        Ok(path::posix::Path::new(bytes))\n     }\n }\n \n-impl<E: Encoder> Encodable<E> for path::windows::Path {\n-    fn encode(&self, e: &mut E) {\n+impl<E, S: Encoder<E>> Encodable<S, E> for path::windows::Path {\n+    fn encode(&self, e: &mut S) -> Result<(), E> {\n         self.as_vec().encode(e)\n     }\n }\n \n-impl<D: Decoder> Decodable<D> for path::windows::Path {\n-    fn decode(d: &mut D) -> path::windows::Path {\n-        let bytes: ~[u8] = Decodable::decode(d);\n-        path::windows::Path::new(bytes)\n+impl<E, D: Decoder<E>> Decodable<D, E> for path::windows::Path {\n+    fn decode(d: &mut D) -> Result<path::windows::Path, E> {\n+        let bytes: ~[u8] = try!(Decodable::decode(d));\n+        Ok(path::windows::Path::new(bytes))\n     }\n }\n \n@@ -546,32 +568,37 @@ impl<D: Decoder> Decodable<D> for path::windows::Path {\n //\n // In some cases, these should eventually be coded as traits.\n \n-pub trait EncoderHelpers {\n-    fn emit_from_vec<T>(&mut self, v: &[T], f: |&mut Self, v: &T|);\n+pub trait EncoderHelpers<E> {\n+    fn emit_from_vec<T>(&mut self,\n+                        v: &[T],\n+                        f: |&mut Self, v: &T| -> Result<(), E>) -> Result<(), E>;\n }\n \n-impl<S:Encoder> EncoderHelpers for S {\n-    fn emit_from_vec<T>(&mut self, v: &[T], f: |&mut S, &T|) {\n+impl<E, S:Encoder<E>> EncoderHelpers<E> for S {\n+    fn emit_from_vec<T>(&mut self, v: &[T], f: |&mut S, &T| -> Result<(), E>) -> Result<(), E> {\n         self.emit_seq(v.len(), |this| {\n             for (i, e) in v.iter().enumerate() {\n-                this.emit_seq_elt(i, |this| {\n+                try!(this.emit_seq_elt(i, |this| {\n                     f(this, e)\n-                })\n+                }));\n             }\n+            Ok(())\n         })\n     }\n }\n \n-pub trait DecoderHelpers {\n-    fn read_to_vec<T>(&mut self, f: |&mut Self| -> T) -> ~[T];\n+pub trait DecoderHelpers<E> {\n+    fn read_to_vec<T>(&mut self, f: |&mut Self| -> Result<T, E>) -> Result<~[T], E>;\n }\n \n-impl<D:Decoder> DecoderHelpers for D {\n-    fn read_to_vec<T>(&mut self, f: |&mut D| -> T) -> ~[T] {\n+impl<E, D:Decoder<E>> DecoderHelpers<E> for D {\n+    fn read_to_vec<T>(&mut self, f: |&mut D| -> Result<T, E>) -> Result<~[T], E> {\n         self.read_seq(|this, len| {\n-            slice::from_fn(len, |i| {\n-                this.read_seq_elt(i, |this| f(this))\n-            })\n+            let mut v = slice::with_capacity(len);\n+            for i in range(0, len) {\n+                v.push(try!(this.read_seq_elt(i, |this| f(this))));\n+            }\n+            Ok(v)\n         })\n     }\n }"}, {"sha": "4043cbe65fe944ec3749ac6413f99b670df37bd4", "filename": "src/libserialize/serialize_old.rs", "status": "added", "additions": 688, "deletions": 0, "changes": 688, "blob_url": "https://github.com/rust-lang/rust/blob/f1739b14a1346419a4598339aee32aab07e0d12e/src%2Flibserialize%2Fserialize_old.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1739b14a1346419a4598339aee32aab07e0d12e/src%2Flibserialize%2Fserialize_old.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fserialize_old.rs?ref=f1739b14a1346419a4598339aee32aab07e0d12e", "patch": "@@ -0,0 +1,688 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Support code for encoding and decoding types.\n+\n+/*\n+Core encoding and decoding interfaces.\n+*/\n+\n+use std::path;\n+use std::rc::Rc;\n+use std::slice;\n+\n+pub trait Encoder {\n+    // Primitive types:\n+    fn emit_nil(&mut self);\n+    fn emit_uint(&mut self, v: uint);\n+    fn emit_u64(&mut self, v: u64);\n+    fn emit_u32(&mut self, v: u32);\n+    fn emit_u16(&mut self, v: u16);\n+    fn emit_u8(&mut self, v: u8);\n+    fn emit_int(&mut self, v: int);\n+    fn emit_i64(&mut self, v: i64);\n+    fn emit_i32(&mut self, v: i32);\n+    fn emit_i16(&mut self, v: i16);\n+    fn emit_i8(&mut self, v: i8);\n+    fn emit_bool(&mut self, v: bool);\n+    fn emit_f64(&mut self, v: f64);\n+    fn emit_f32(&mut self, v: f32);\n+    fn emit_char(&mut self, v: char);\n+    fn emit_str(&mut self, v: &str);\n+\n+    // Compound types:\n+    fn emit_enum(&mut self, name: &str, f: |&mut Self|);\n+\n+    fn emit_enum_variant(&mut self,\n+                         v_name: &str,\n+                         v_id: uint,\n+                         len: uint,\n+                         f: |&mut Self|);\n+    fn emit_enum_variant_arg(&mut self, a_idx: uint, f: |&mut Self|);\n+\n+    fn emit_enum_struct_variant(&mut self,\n+                                v_name: &str,\n+                                v_id: uint,\n+                                len: uint,\n+                                f: |&mut Self|);\n+    fn emit_enum_struct_variant_field(&mut self,\n+                                      f_name: &str,\n+                                      f_idx: uint,\n+                                      f: |&mut Self|);\n+\n+    fn emit_struct(&mut self, name: &str, len: uint, f: |&mut Self|);\n+    fn emit_struct_field(&mut self,\n+                         f_name: &str,\n+                         f_idx: uint,\n+                         f: |&mut Self|);\n+\n+    fn emit_tuple(&mut self, len: uint, f: |&mut Self|);\n+    fn emit_tuple_arg(&mut self, idx: uint, f: |&mut Self|);\n+\n+    fn emit_tuple_struct(&mut self, name: &str, len: uint, f: |&mut Self|);\n+    fn emit_tuple_struct_arg(&mut self, f_idx: uint, f: |&mut Self|);\n+\n+    // Specialized types:\n+    fn emit_option(&mut self, f: |&mut Self|);\n+    fn emit_option_none(&mut self);\n+    fn emit_option_some(&mut self, f: |&mut Self|);\n+\n+    fn emit_seq(&mut self, len: uint, f: |this: &mut Self|);\n+    fn emit_seq_elt(&mut self, idx: uint, f: |this: &mut Self|);\n+\n+    fn emit_map(&mut self, len: uint, f: |&mut Self|);\n+    fn emit_map_elt_key(&mut self, idx: uint, f: |&mut Self|);\n+    fn emit_map_elt_val(&mut self, idx: uint, f: |&mut Self|);\n+}\n+\n+pub trait Decoder {\n+    // Primitive types:\n+    fn read_nil(&mut self) -> ();\n+    fn read_uint(&mut self) -> uint;\n+    fn read_u64(&mut self) -> u64;\n+    fn read_u32(&mut self) -> u32;\n+    fn read_u16(&mut self) -> u16;\n+    fn read_u8(&mut self) -> u8;\n+    fn read_int(&mut self) -> int;\n+    fn read_i64(&mut self) -> i64;\n+    fn read_i32(&mut self) -> i32;\n+    fn read_i16(&mut self) -> i16;\n+    fn read_i8(&mut self) -> i8;\n+    fn read_bool(&mut self) -> bool;\n+    fn read_f64(&mut self) -> f64;\n+    fn read_f32(&mut self) -> f32;\n+    fn read_char(&mut self) -> char;\n+    fn read_str(&mut self) -> ~str;\n+\n+    // Compound types:\n+    fn read_enum<T>(&mut self, name: &str, f: |&mut Self| -> T) -> T;\n+\n+    fn read_enum_variant<T>(&mut self,\n+                            names: &[&str],\n+                            f: |&mut Self, uint| -> T)\n+                            -> T;\n+    fn read_enum_variant_arg<T>(&mut self,\n+                                a_idx: uint,\n+                                f: |&mut Self| -> T)\n+                                -> T;\n+\n+    fn read_enum_struct_variant<T>(&mut self,\n+                                   names: &[&str],\n+                                   f: |&mut Self, uint| -> T)\n+                                   -> T;\n+    fn read_enum_struct_variant_field<T>(&mut self,\n+                                         &f_name: &str,\n+                                         f_idx: uint,\n+                                         f: |&mut Self| -> T)\n+                                         -> T;\n+\n+    fn read_struct<T>(&mut self, s_name: &str, len: uint, f: |&mut Self| -> T)\n+                      -> T;\n+    fn read_struct_field<T>(&mut self,\n+                            f_name: &str,\n+                            f_idx: uint,\n+                            f: |&mut Self| -> T)\n+                            -> T;\n+\n+    fn read_tuple<T>(&mut self, f: |&mut Self, uint| -> T) -> T;\n+    fn read_tuple_arg<T>(&mut self, a_idx: uint, f: |&mut Self| -> T) -> T;\n+\n+    fn read_tuple_struct<T>(&mut self,\n+                            s_name: &str,\n+                            f: |&mut Self, uint| -> T)\n+                            -> T;\n+    fn read_tuple_struct_arg<T>(&mut self,\n+                                a_idx: uint,\n+                                f: |&mut Self| -> T)\n+                                -> T;\n+\n+    // Specialized types:\n+    fn read_option<T>(&mut self, f: |&mut Self, bool| -> T) -> T;\n+\n+    fn read_seq<T>(&mut self, f: |&mut Self, uint| -> T) -> T;\n+    fn read_seq_elt<T>(&mut self, idx: uint, f: |&mut Self| -> T) -> T;\n+\n+    fn read_map<T>(&mut self, f: |&mut Self, uint| -> T) -> T;\n+    fn read_map_elt_key<T>(&mut self, idx: uint, f: |&mut Self| -> T) -> T;\n+    fn read_map_elt_val<T>(&mut self, idx: uint, f: |&mut Self| -> T) -> T;\n+}\n+\n+pub trait Encodable<S:Encoder> {\n+    fn encode(&self, s: &mut S);\n+}\n+\n+pub trait Decodable<D:Decoder> {\n+    fn decode(d: &mut D) -> Self;\n+}\n+\n+impl<S:Encoder> Encodable<S> for uint {\n+    fn encode(&self, s: &mut S) {\n+        s.emit_uint(*self)\n+    }\n+}\n+\n+impl<D:Decoder> Decodable<D> for uint {\n+    fn decode(d: &mut D) -> uint {\n+        d.read_uint()\n+    }\n+}\n+\n+impl<S:Encoder> Encodable<S> for u8 {\n+    fn encode(&self, s: &mut S) {\n+        s.emit_u8(*self)\n+    }\n+}\n+\n+impl<D:Decoder> Decodable<D> for u8 {\n+    fn decode(d: &mut D) -> u8 {\n+        d.read_u8()\n+    }\n+}\n+\n+impl<S:Encoder> Encodable<S> for u16 {\n+    fn encode(&self, s: &mut S) {\n+        s.emit_u16(*self)\n+    }\n+}\n+\n+impl<D:Decoder> Decodable<D> for u16 {\n+    fn decode(d: &mut D) -> u16 {\n+        d.read_u16()\n+    }\n+}\n+\n+impl<S:Encoder> Encodable<S> for u32 {\n+    fn encode(&self, s: &mut S) {\n+        s.emit_u32(*self)\n+    }\n+}\n+\n+impl<D:Decoder> Decodable<D> for u32 {\n+    fn decode(d: &mut D) -> u32 {\n+        d.read_u32()\n+    }\n+}\n+\n+impl<S:Encoder> Encodable<S> for u64 {\n+    fn encode(&self, s: &mut S) {\n+        s.emit_u64(*self)\n+    }\n+}\n+\n+impl<D:Decoder> Decodable<D> for u64 {\n+    fn decode(d: &mut D) -> u64 {\n+        d.read_u64()\n+    }\n+}\n+\n+impl<S:Encoder> Encodable<S> for int {\n+    fn encode(&self, s: &mut S) {\n+        s.emit_int(*self)\n+    }\n+}\n+\n+impl<D:Decoder> Decodable<D> for int {\n+    fn decode(d: &mut D) -> int {\n+        d.read_int()\n+    }\n+}\n+\n+impl<S:Encoder> Encodable<S> for i8 {\n+    fn encode(&self, s: &mut S) {\n+        s.emit_i8(*self)\n+    }\n+}\n+\n+impl<D:Decoder> Decodable<D> for i8 {\n+    fn decode(d: &mut D) -> i8 {\n+        d.read_i8()\n+    }\n+}\n+\n+impl<S:Encoder> Encodable<S> for i16 {\n+    fn encode(&self, s: &mut S) {\n+        s.emit_i16(*self)\n+    }\n+}\n+\n+impl<D:Decoder> Decodable<D> for i16 {\n+    fn decode(d: &mut D) -> i16 {\n+        d.read_i16()\n+    }\n+}\n+\n+impl<S:Encoder> Encodable<S> for i32 {\n+    fn encode(&self, s: &mut S) {\n+        s.emit_i32(*self)\n+    }\n+}\n+\n+impl<D:Decoder> Decodable<D> for i32 {\n+    fn decode(d: &mut D) -> i32 {\n+        d.read_i32()\n+    }\n+}\n+\n+impl<S:Encoder> Encodable<S> for i64 {\n+    fn encode(&self, s: &mut S) {\n+        s.emit_i64(*self)\n+    }\n+}\n+\n+impl<D:Decoder> Decodable<D> for i64 {\n+    fn decode(d: &mut D) -> i64 {\n+        d.read_i64()\n+    }\n+}\n+\n+impl<'a, S:Encoder> Encodable<S> for &'a str {\n+    fn encode(&self, s: &mut S) {\n+        s.emit_str(*self)\n+    }\n+}\n+\n+impl<S:Encoder> Encodable<S> for ~str {\n+    fn encode(&self, s: &mut S) {\n+        s.emit_str(*self)\n+    }\n+}\n+\n+impl<D:Decoder> Decodable<D> for ~str {\n+    fn decode(d: &mut D) -> ~str {\n+        d.read_str()\n+    }\n+}\n+\n+impl<S:Encoder> Encodable<S> for f32 {\n+    fn encode(&self, s: &mut S) {\n+        s.emit_f32(*self)\n+    }\n+}\n+\n+impl<D:Decoder> Decodable<D> for f32 {\n+    fn decode(d: &mut D) -> f32 {\n+        d.read_f32()\n+    }\n+}\n+\n+impl<S:Encoder> Encodable<S> for f64 {\n+    fn encode(&self, s: &mut S) {\n+        s.emit_f64(*self)\n+    }\n+}\n+\n+impl<D:Decoder> Decodable<D> for f64 {\n+    fn decode(d: &mut D) -> f64 {\n+        d.read_f64()\n+    }\n+}\n+\n+impl<S:Encoder> Encodable<S> for bool {\n+    fn encode(&self, s: &mut S) {\n+        s.emit_bool(*self)\n+    }\n+}\n+\n+impl<D:Decoder> Decodable<D> for bool {\n+    fn decode(d: &mut D) -> bool {\n+        d.read_bool()\n+    }\n+}\n+\n+impl<S:Encoder> Encodable<S> for char {\n+    fn encode(&self, s: &mut S) {\n+        s.emit_char(*self)\n+    }\n+}\n+\n+impl<D:Decoder> Decodable<D> for char {\n+    fn decode(d: &mut D) -> char {\n+        d.read_char()\n+    }\n+}\n+\n+impl<S:Encoder> Encodable<S> for () {\n+    fn encode(&self, s: &mut S) {\n+        s.emit_nil()\n+    }\n+}\n+\n+impl<D:Decoder> Decodable<D> for () {\n+    fn decode(d: &mut D) -> () {\n+        d.read_nil()\n+    }\n+}\n+\n+impl<'a, S:Encoder,T:Encodable<S>> Encodable<S> for &'a T {\n+    fn encode(&self, s: &mut S) {\n+        (**self).encode(s)\n+    }\n+}\n+\n+impl<S:Encoder,T:Encodable<S>> Encodable<S> for ~T {\n+    fn encode(&self, s: &mut S) {\n+        (**self).encode(s)\n+    }\n+}\n+\n+impl<D:Decoder,T:Decodable<D>> Decodable<D> for ~T {\n+    fn decode(d: &mut D) -> ~T {\n+        ~Decodable::decode(d)\n+    }\n+}\n+\n+impl<S:Encoder,T:Encodable<S>> Encodable<S> for @T {\n+    fn encode(&self, s: &mut S) {\n+        (**self).encode(s)\n+    }\n+}\n+\n+impl<S:Encoder,T:Encodable<S>> Encodable<S> for Rc<T> {\n+    #[inline]\n+    fn encode(&self, s: &mut S) {\n+        (**self).encode(s)\n+    }\n+}\n+\n+impl<D:Decoder,T:Decodable<D>> Decodable<D> for Rc<T> {\n+    #[inline]\n+    fn decode(d: &mut D) -> Rc<T> {\n+        Rc::new(Decodable::decode(d))\n+    }\n+}\n+\n+impl<D:Decoder,T:Decodable<D> + 'static> Decodable<D> for @T {\n+    fn decode(d: &mut D) -> @T {\n+        @Decodable::decode(d)\n+    }\n+}\n+\n+impl<'a, S:Encoder,T:Encodable<S>> Encodable<S> for &'a [T] {\n+    fn encode(&self, s: &mut S) {\n+        s.emit_seq(self.len(), |s| {\n+            for (i, e) in self.iter().enumerate() {\n+                s.emit_seq_elt(i, |s| e.encode(s))\n+            }\n+        })\n+    }\n+}\n+\n+impl<S:Encoder,T:Encodable<S>> Encodable<S> for ~[T] {\n+    fn encode(&self, s: &mut S) {\n+        s.emit_seq(self.len(), |s| {\n+            for (i, e) in self.iter().enumerate() {\n+                s.emit_seq_elt(i, |s| e.encode(s))\n+            }\n+        })\n+    }\n+}\n+\n+impl<D:Decoder,T:Decodable<D>> Decodable<D> for ~[T] {\n+    fn decode(d: &mut D) -> ~[T] {\n+        d.read_seq(|d, len| {\n+            slice::from_fn(len, |i| {\n+                d.read_seq_elt(i, |d| Decodable::decode(d))\n+            })\n+        })\n+    }\n+}\n+\n+impl<S:Encoder,T:Encodable<S>> Encodable<S> for Vec<T> {\n+    fn encode(&self, s: &mut S) {\n+        s.emit_seq(self.len(), |s| {\n+            for (i, e) in self.iter().enumerate() {\n+                s.emit_seq_elt(i, |s| e.encode(s))\n+            }\n+        })\n+    }\n+}\n+\n+impl<D:Decoder,T:Decodable<D>> Decodable<D> for Vec<T> {\n+    fn decode(d: &mut D) -> Vec<T> {\n+        d.read_seq(|d, len| {\n+            Vec::from_fn(len, |i| {\n+                d.read_seq_elt(i, |d| Decodable::decode(d))\n+            })\n+        })\n+    }\n+}\n+\n+impl<S:Encoder,T:Encodable<S>> Encodable<S> for Option<T> {\n+    fn encode(&self, s: &mut S) {\n+        s.emit_option(|s| {\n+            match *self {\n+                None => s.emit_option_none(),\n+                Some(ref v) => s.emit_option_some(|s| v.encode(s)),\n+            }\n+        })\n+    }\n+}\n+\n+impl<D:Decoder,T:Decodable<D>> Decodable<D> for Option<T> {\n+    fn decode(d: &mut D) -> Option<T> {\n+        d.read_option(|d, b| {\n+            if b {\n+                Some(Decodable::decode(d))\n+            } else {\n+                None\n+            }\n+        })\n+    }\n+}\n+\n+impl<S:Encoder,T0:Encodable<S>,T1:Encodable<S>> Encodable<S> for (T0, T1) {\n+    fn encode(&self, s: &mut S) {\n+        match *self {\n+            (ref t0, ref t1) => {\n+                s.emit_seq(2, |s| {\n+                    s.emit_seq_elt(0, |s| t0.encode(s));\n+                    s.emit_seq_elt(1, |s| t1.encode(s));\n+                })\n+            }\n+        }\n+    }\n+}\n+\n+impl<D:Decoder,T0:Decodable<D>,T1:Decodable<D>> Decodable<D> for (T0, T1) {\n+    fn decode(d: &mut D) -> (T0, T1) {\n+        d.read_seq(|d, len| {\n+            assert_eq!(len, 2);\n+            (\n+                d.read_seq_elt(0, |d| Decodable::decode(d)),\n+                d.read_seq_elt(1, |d| Decodable::decode(d))\n+            )\n+        })\n+    }\n+}\n+\n+impl<\n+    S: Encoder,\n+    T0: Encodable<S>,\n+    T1: Encodable<S>,\n+    T2: Encodable<S>\n+> Encodable<S> for (T0, T1, T2) {\n+    fn encode(&self, s: &mut S) {\n+        match *self {\n+            (ref t0, ref t1, ref t2) => {\n+                s.emit_seq(3, |s| {\n+                    s.emit_seq_elt(0, |s| t0.encode(s));\n+                    s.emit_seq_elt(1, |s| t1.encode(s));\n+                    s.emit_seq_elt(2, |s| t2.encode(s));\n+                })\n+            }\n+        }\n+    }\n+}\n+\n+impl<\n+    D: Decoder,\n+    T0: Decodable<D>,\n+    T1: Decodable<D>,\n+    T2: Decodable<D>\n+> Decodable<D> for (T0, T1, T2) {\n+    fn decode(d: &mut D) -> (T0, T1, T2) {\n+        d.read_seq(|d, len| {\n+            assert_eq!(len, 3);\n+            (\n+                d.read_seq_elt(0, |d| Decodable::decode(d)),\n+                d.read_seq_elt(1, |d| Decodable::decode(d)),\n+                d.read_seq_elt(2, |d| Decodable::decode(d))\n+            )\n+        })\n+    }\n+}\n+\n+impl<\n+    S: Encoder,\n+    T0: Encodable<S>,\n+    T1: Encodable<S>,\n+    T2: Encodable<S>,\n+    T3: Encodable<S>\n+> Encodable<S> for (T0, T1, T2, T3) {\n+    fn encode(&self, s: &mut S) {\n+        match *self {\n+            (ref t0, ref t1, ref t2, ref t3) => {\n+                s.emit_seq(4, |s| {\n+                    s.emit_seq_elt(0, |s| t0.encode(s));\n+                    s.emit_seq_elt(1, |s| t1.encode(s));\n+                    s.emit_seq_elt(2, |s| t2.encode(s));\n+                    s.emit_seq_elt(3, |s| t3.encode(s));\n+                })\n+            }\n+        }\n+    }\n+}\n+\n+impl<\n+    D: Decoder,\n+    T0: Decodable<D>,\n+    T1: Decodable<D>,\n+    T2: Decodable<D>,\n+    T3: Decodable<D>\n+> Decodable<D> for (T0, T1, T2, T3) {\n+    fn decode(d: &mut D) -> (T0, T1, T2, T3) {\n+        d.read_seq(|d, len| {\n+            assert_eq!(len, 4);\n+            (\n+                d.read_seq_elt(0, |d| Decodable::decode(d)),\n+                d.read_seq_elt(1, |d| Decodable::decode(d)),\n+                d.read_seq_elt(2, |d| Decodable::decode(d)),\n+                d.read_seq_elt(3, |d| Decodable::decode(d))\n+            )\n+        })\n+    }\n+}\n+\n+impl<\n+    S: Encoder,\n+    T0: Encodable<S>,\n+    T1: Encodable<S>,\n+    T2: Encodable<S>,\n+    T3: Encodable<S>,\n+    T4: Encodable<S>\n+> Encodable<S> for (T0, T1, T2, T3, T4) {\n+    fn encode(&self, s: &mut S) {\n+        match *self {\n+            (ref t0, ref t1, ref t2, ref t3, ref t4) => {\n+                s.emit_seq(5, |s| {\n+                    s.emit_seq_elt(0, |s| t0.encode(s));\n+                    s.emit_seq_elt(1, |s| t1.encode(s));\n+                    s.emit_seq_elt(2, |s| t2.encode(s));\n+                    s.emit_seq_elt(3, |s| t3.encode(s));\n+                    s.emit_seq_elt(4, |s| t4.encode(s));\n+                })\n+            }\n+        }\n+    }\n+}\n+\n+impl<\n+    D: Decoder,\n+    T0: Decodable<D>,\n+    T1: Decodable<D>,\n+    T2: Decodable<D>,\n+    T3: Decodable<D>,\n+    T4: Decodable<D>\n+> Decodable<D> for (T0, T1, T2, T3, T4) {\n+    fn decode(d: &mut D) -> (T0, T1, T2, T3, T4) {\n+        d.read_seq(|d, len| {\n+            assert_eq!(len, 5);\n+            (\n+                d.read_seq_elt(0, |d| Decodable::decode(d)),\n+                d.read_seq_elt(1, |d| Decodable::decode(d)),\n+                d.read_seq_elt(2, |d| Decodable::decode(d)),\n+                d.read_seq_elt(3, |d| Decodable::decode(d)),\n+                d.read_seq_elt(4, |d| Decodable::decode(d))\n+            )\n+        })\n+    }\n+}\n+\n+impl<E: Encoder> Encodable<E> for path::posix::Path {\n+    fn encode(&self, e: &mut E) {\n+        self.as_vec().encode(e)\n+    }\n+}\n+\n+impl<D: Decoder> Decodable<D> for path::posix::Path {\n+    fn decode(d: &mut D) -> path::posix::Path {\n+        let bytes: ~[u8] = Decodable::decode(d);\n+        path::posix::Path::new(bytes)\n+    }\n+}\n+\n+impl<E: Encoder> Encodable<E> for path::windows::Path {\n+    fn encode(&self, e: &mut E) {\n+        self.as_vec().encode(e)\n+    }\n+}\n+\n+impl<D: Decoder> Decodable<D> for path::windows::Path {\n+    fn decode(d: &mut D) -> path::windows::Path {\n+        let bytes: ~[u8] = Decodable::decode(d);\n+        path::windows::Path::new(bytes)\n+    }\n+}\n+\n+// ___________________________________________________________________________\n+// Helper routines\n+//\n+// In some cases, these should eventually be coded as traits.\n+\n+pub trait EncoderHelpers {\n+    fn emit_from_vec<T>(&mut self, v: &[T], f: |&mut Self, v: &T|);\n+}\n+\n+impl<S:Encoder> EncoderHelpers for S {\n+    fn emit_from_vec<T>(&mut self, v: &[T], f: |&mut S, &T|) {\n+        self.emit_seq(v.len(), |this| {\n+            for (i, e) in v.iter().enumerate() {\n+                this.emit_seq_elt(i, |this| {\n+                    f(this, e)\n+                })\n+            }\n+        })\n+    }\n+}\n+\n+pub trait DecoderHelpers {\n+    fn read_to_vec<T>(&mut self, f: |&mut Self| -> T) -> ~[T];\n+}\n+\n+impl<D:Decoder> DecoderHelpers for D {\n+    fn read_to_vec<T>(&mut self, f: |&mut D| -> T) -> ~[T] {\n+        self.read_seq(|this, len| {\n+            slice::from_fn(len, |i| {\n+                this.read_seq_elt(i, |this| f(this))\n+            })\n+        })\n+    }\n+}\n+"}, {"sha": "a44fbce421b441413b757630b50040a707ad970b", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/f1739b14a1346419a4598339aee32aab07e0d12e/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1739b14a1346419a4598339aee32aab07e0d12e/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=f1739b14a1346419a4598339aee32aab07e0d12e", "patch": "@@ -98,18 +98,35 @@ pub type Name = u32;\n /// A mark represents a unique id associated with a macro expansion\n pub type Mrk = u32;\n \n+// FIXME: remove stage0 Encodables after snapshot\n+#[cfg(stage0)]\n impl<S: Encoder> Encodable<S> for Ident {\n     fn encode(&self, s: &mut S) {\n         s.emit_str(token::get_ident(*self).get());\n     }\n }\n \n+#[cfg(stage0)]\n impl<D:Decoder> Decodable<D> for Ident {\n     fn decode(d: &mut D) -> Ident {\n         str_to_ident(d.read_str())\n     }\n }\n \n+#[cfg(not(stage0))]\n+impl<S: Encoder<E>, E> Encodable<S, E> for Ident {\n+    fn encode(&self, s: &mut S) -> Result<(), E> {\n+        s.emit_str(token::get_ident(*self).get())\n+    }\n+}\n+\n+#[cfg(not(stage0))]\n+impl<D:Decoder<E>, E> Decodable<D, E> for Ident {\n+    fn decode(d: &mut D) -> Result<Ident, E> {\n+        Ok(str_to_ident(try!(d.read_str())))\n+    }\n+}\n+\n /// Function name (not all functions have names)\n pub type FnIdent = Option<Ident>;\n \n@@ -1166,7 +1183,9 @@ mod test {\n     use super::*;\n \n     // are ASTs encodable?\n+    // FIXME: remove stage0 test after snapshot\n     #[test]\n+    #[cfg(stage0)]\n     fn check_asts_encodable() {\n         let e = Crate {\n             module: Mod {view_items: Vec::new(), items: Vec::new()},\n@@ -1181,4 +1200,22 @@ mod test {\n         // doesn't matter which encoder we use....\n         let _f = &e as &serialize::Encodable<json::Encoder>;\n     }\n+\n+    #[test]\n+    #[cfg(not(stage0))]\n+    fn check_asts_encodable() {\n+        use std::io;\n+        let e = Crate {\n+            module: Mod {view_items: Vec::new(), items: Vec::new()},\n+            attrs: Vec::new(),\n+            config: Vec::new(),\n+            span: Span {\n+                lo: BytePos(10),\n+                hi: BytePos(20),\n+                expn_info: None,\n+            },\n+        };\n+        // doesn't matter which encoder we use....\n+        let _f = &e as &serialize::Encodable<json::Encoder, io::IoError>;\n+    }\n }"}, {"sha": "f3ff7f97ee2e1b22e0f3356c8d864ee793899e0d", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f1739b14a1346419a4598339aee32aab07e0d12e/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1739b14a1346419a4598339aee32aab07e0d12e/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=f1739b14a1346419a4598339aee32aab07e0d12e", "patch": "@@ -110,19 +110,37 @@ impl Eq for Span {\n \n impl TotalEq for Span {}\n \n+// FIXME: remove stage0 Encodables/Decodables after snapshot\n+#[cfg(stage0)]\n impl<S:Encoder> Encodable<S> for Span {\n     /* Note #1972 -- spans are encoded but not decoded */\n     fn encode(&self, s: &mut S) {\n         s.emit_nil()\n     }\n }\n \n+#[cfg(stage0)]\n impl<D:Decoder> Decodable<D> for Span {\n     fn decode(_d: &mut D) -> Span {\n         DUMMY_SP\n     }\n }\n \n+#[cfg(not(stage0))]\n+impl<S:Encoder<E>, E> Encodable<S, E> for Span {\n+    /* Note #1972 -- spans are encoded but not decoded */\n+    fn encode(&self, s: &mut S) -> Result<(), E> {\n+        s.emit_nil()\n+    }\n+}\n+\n+#[cfg(not(stage0))]\n+impl<D:Decoder<E>, E> Decodable<D, E> for Span {\n+    fn decode(_d: &mut D) -> Result<Span, E> {\n+        Ok(DUMMY_SP)\n+    }\n+}\n+\n pub fn spanned<T>(lo: BytePos, hi: BytePos, t: T) -> Spanned<T> {\n     respan(mk_sp(lo, hi), t)\n }"}, {"sha": "1c2c63cd91974c25ba5df368a98c1897d5259f82", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/f1739b14a1346419a4598339aee32aab07e0d12e/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1739b14a1346419a4598339aee32aab07e0d12e/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=f1739b14a1346419a4598339aee32aab07e0d12e", "patch": "@@ -142,6 +142,10 @@ pub trait AstBuilder {\n     fn expr_fail(&self, span: Span, msg: InternedString) -> @ast::Expr;\n     fn expr_unreachable(&self, span: Span) -> @ast::Expr;\n \n+    fn expr_ok(&self, span: Span, expr: @ast::Expr) -> @ast::Expr;\n+    fn expr_err(&self, span: Span, expr: @ast::Expr) -> @ast::Expr;\n+    fn expr_try(&self, span: Span, head: @ast::Expr) -> @ast::Expr;\n+\n     fn pat(&self, span: Span, pat: ast::Pat_) -> @ast::Pat;\n     fn pat_wild(&self, span: Span) -> @ast::Pat;\n     fn pat_lit(&self, span: Span, expr: @ast::Expr) -> @ast::Pat;\n@@ -638,6 +642,50 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n                            \"internal error: entered unreachable code\"))\n     }\n \n+    fn expr_ok(&self, sp: Span, expr: @ast::Expr) -> @ast::Expr {\n+        let ok = vec!(\n+            self.ident_of(\"std\"),\n+            self.ident_of(\"result\"),\n+            self.ident_of(\"Ok\"));\n+        self.expr_call_global(sp, ok, vec!(expr))\n+    }\n+\n+    fn expr_err(&self, sp: Span, expr: @ast::Expr) -> @ast::Expr {\n+        let err = vec!(\n+            self.ident_of(\"std\"),\n+            self.ident_of(\"result\"),\n+            self.ident_of(\"Err\"));\n+        self.expr_call_global(sp, err, vec!(expr))\n+    }\n+\n+    fn expr_try(&self, sp: Span, head: @ast::Expr) -> @ast::Expr {\n+        let ok = self.ident_of(\"Ok\");\n+        let ok_path = self.path_ident(sp, ok);\n+        let err = self.ident_of(\"Err\");\n+        let err_path = self.path_ident(sp, err);\n+\n+        let binding_variable = self.ident_of(\"__try_var\");\n+        let binding_pat = self.pat_ident(sp, binding_variable);\n+        let binding_expr = self.expr_ident(sp, binding_variable);\n+\n+        // Ok(__try_var) pattern\n+        let ok_pat = self.pat_enum(sp, ok_path, vec!(binding_pat));\n+\n+        // Err(__try_var)  (pattern and expression resp.)\n+        let err_pat = self.pat_enum(sp, err_path, vec!(binding_pat));\n+        let err_inner_expr = self.expr_call_ident(sp, err, vec!(binding_expr));\n+        // return Err(__try_var)\n+        let err_expr = self.expr(sp, ast::ExprRet(Some(err_inner_expr)));\n+\n+        // Ok(__try_var) => __try_var\n+        let ok_arm = self.arm(sp, vec!(ok_pat), binding_expr);\n+        // Err(__try_var) => return Err(__try_var)\n+        let err_arm = self.arm(sp, vec!(err_pat), err_expr);\n+\n+        // match head { Ok() => ..., Err() => ... }\n+        self.expr_match(sp, head, vec!(ok_arm, err_arm))\n+    }\n+\n \n     fn pat(&self, span: Span, pat: ast::Pat_) -> @ast::Pat {\n         @ast::Pat { id: ast::DUMMY_NODE_ID, node: pat, span: span }"}, {"sha": "579de82c8db376efe4a73c536ff3746c437765fa", "filename": "src/libsyntax/ext/deriving/decodable.rs", "status": "modified", "additions": 20, "deletions": 10, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/f1739b14a1346419a4598339aee32aab07e0d12e/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1739b14a1346419a4598339aee32aab07e0d12e/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs?ref=f1739b14a1346419a4598339aee32aab07e0d12e", "patch": "@@ -30,11 +30,15 @@ pub fn expand_deriving_decodable(cx: &mut ExtCtxt,\n         span: span,\n         attributes: Vec::new(),\n         path: Path::new_(vec!(\"serialize\", \"Decodable\"), None,\n-                         vec!(~Literal(Path::new_local(\"__D\"))), true),\n+                         vec!(~Literal(Path::new_local(\"__D\")),\n+                              ~Literal(Path::new_local(\"__E\"))), true),\n         additional_bounds: Vec::new(),\n         generics: LifetimeBounds {\n             lifetimes: Vec::new(),\n-            bounds: vec!((\"__D\", vec!(Path::new(vec!(\"serialize\", \"Decoder\"))))),\n+            bounds: vec!((\"__D\", vec!(Path::new_(\n+                            vec!(\"serialize\", \"Decoder\"), None,\n+                            vec!(~Literal(Path::new_local(\"__E\"))), true))),\n+                         (\"__E\", vec!()))\n         },\n         methods: vec!(\n             MethodDef {\n@@ -43,7 +47,8 @@ pub fn expand_deriving_decodable(cx: &mut ExtCtxt,\n                 explicit_self: None,\n                 args: vec!(Ptr(~Literal(Path::new_local(\"__D\")),\n                             Borrowed(None, MutMutable))),\n-                ret_ty: Self,\n+                ret_ty: Literal(Path::new_(vec!(\"std\", \"result\", \"Result\"), None,\n+                                          vec!(~Self, ~Literal(Path::new_local(\"__E\"))), true)),\n                 inline: false,\n                 const_nonmatching: true,\n                 combine_substructure: decodable_substructure,\n@@ -78,11 +83,13 @@ fn decodable_substructure(cx: &mut ExtCtxt, trait_span: Span,\n                                               substr.type_ident,\n                                               summary,\n                                               |cx, span, name, field| {\n-                cx.expr_method_call(span, blkdecoder, read_struct_field,\n-                                    vec!(cx.expr_str(span, name),\n-                                      cx.expr_uint(span, field),\n-                                      lambdadecode))\n+                cx.expr_try(span,\n+                    cx.expr_method_call(span, blkdecoder, read_struct_field,\n+                                        vec!(cx.expr_str(span, name),\n+                                          cx.expr_uint(span, field),\n+                                          lambdadecode)))\n             });\n+            let result = cx.expr_ok(trait_span, result);\n             cx.expr_method_call(trait_span,\n                                 decoder,\n                                 cx.ident_of(\"read_struct\"),\n@@ -108,8 +115,9 @@ fn decodable_substructure(cx: &mut ExtCtxt, trait_span: Span,\n                                                    parts,\n                                                    |cx, span, _, field| {\n                     let idx = cx.expr_uint(span, field);\n-                    cx.expr_method_call(span, blkdecoder, rvariant_arg,\n-                                        vec!(idx, lambdadecode))\n+                    cx.expr_try(span,\n+                        cx.expr_method_call(span, blkdecoder, rvariant_arg,\n+                                            vec!(idx, lambdadecode)))\n                 });\n \n                 arms.push(cx.arm(v_span,\n@@ -119,7 +127,9 @@ fn decodable_substructure(cx: &mut ExtCtxt, trait_span: Span,\n \n             arms.push(cx.arm_unreachable(trait_span));\n \n-            let result = cx.expr_match(trait_span, cx.expr_ident(trait_span, variant), arms);\n+            let result = cx.expr_ok(trait_span,\n+                                    cx.expr_match(trait_span,\n+                                                  cx.expr_ident(trait_span, variant), arms));\n             let lambda = cx.lambda_expr(trait_span, vec!(blkarg, variant), result);\n             let variant_vec = cx.expr_vec(trait_span, variants);\n             let result = cx.expr_method_call(trait_span, blkdecoder,"}, {"sha": "90ea8701562e632fb842e3f4593fc9d8139bce50", "filename": "src/libsyntax/ext/deriving/encodable.rs", "status": "modified", "additions": 35, "deletions": 5, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/f1739b14a1346419a4598339aee32aab07e0d12e/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1739b14a1346419a4598339aee32aab07e0d12e/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs?ref=f1739b14a1346419a4598339aee32aab07e0d12e", "patch": "@@ -82,7 +82,7 @@ would yield functions like:\n ```\n */\n \n-use ast::{MetaItem, Item, Expr, MutMutable};\n+use ast::{MetaItem, Item, Expr, ExprRet, MutMutable, LitNil};\n use codemap::Span;\n use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n@@ -98,20 +98,28 @@ pub fn expand_deriving_encodable(cx: &mut ExtCtxt,\n         span: span,\n         attributes: Vec::new(),\n         path: Path::new_(vec!(\"serialize\", \"Encodable\"), None,\n-                         vec!(~Literal(Path::new_local(\"__E\"))), true),\n+                         vec!(~Literal(Path::new_local(\"__S\")),\n+                              ~Literal(Path::new_local(\"__E\"))), true),\n         additional_bounds: Vec::new(),\n         generics: LifetimeBounds {\n             lifetimes: Vec::new(),\n-            bounds: vec!((\"__E\", vec!(Path::new(vec!(\"serialize\", \"Encoder\"))))),\n+            bounds: vec!((\"__S\", vec!(Path::new_(\n+                            vec!(\"serialize\", \"Encoder\"), None,\n+                            vec!(~Literal(Path::new_local(\"__E\"))), true))),\n+                         (\"__E\", vec!()))\n         },\n         methods: vec!(\n             MethodDef {\n                 name: \"encode\",\n                 generics: LifetimeBounds::empty(),\n                 explicit_self: borrowed_explicit_self(),\n-                args: vec!(Ptr(~Literal(Path::new_local(\"__E\")),\n+                args: vec!(Ptr(~Literal(Path::new_local(\"__S\")),\n                             Borrowed(None, MutMutable))),\n-                ret_ty: nil_ty(),\n+                ret_ty: Literal(Path::new_(vec!(\"std\", \"result\", \"Result\"),\n+                                           None,\n+                                           vec!(~Tuple(Vec::new()),\n+                                                ~Literal(Path::new_local(\"__E\"))),\n+                                           true)),\n                 inline: false,\n                 const_nonmatching: true,\n                 combine_substructure: encodable_substructure,\n@@ -133,6 +141,7 @@ fn encodable_substructure(cx: &mut ExtCtxt, trait_span: Span,\n         Struct(ref fields) => {\n             let emit_struct_field = cx.ident_of(\"emit_struct_field\");\n             let mut stmts = Vec::new();\n+            let last = fields.len() - 1;\n             for (i, &FieldInfo {\n                     name,\n                     self_,\n@@ -152,6 +161,13 @@ fn encodable_substructure(cx: &mut ExtCtxt, trait_span: Span,\n                                                vec!(cx.expr_str(span, name),\n                                                  cx.expr_uint(span, i),\n                                                  lambda));\n+\n+                // last call doesn't need a try!\n+                let call = if i != last {\n+                    cx.expr_try(span, call)\n+                } else {\n+                    cx.expr(span, ExprRet(Some(call)))\n+                };\n                 stmts.push(cx.stmt_expr(call));\n             }\n \n@@ -175,16 +191,30 @@ fn encodable_substructure(cx: &mut ExtCtxt, trait_span: Span,\n             let encoder = cx.expr_ident(trait_span, blkarg);\n             let emit_variant_arg = cx.ident_of(\"emit_enum_variant_arg\");\n             let mut stmts = Vec::new();\n+            let last = fields.len() - 1;\n             for (i, &FieldInfo { self_, span, .. }) in fields.iter().enumerate() {\n                 let enc = cx.expr_method_call(span, self_, encode, vec!(blkencoder));\n                 let lambda = cx.lambda_expr_1(span, enc, blkarg);\n                 let call = cx.expr_method_call(span, blkencoder,\n                                                emit_variant_arg,\n                                                vec!(cx.expr_uint(span, i),\n                                                  lambda));\n+                let call = if i != last {\n+                    cx.expr_try(span, call)\n+                } else {\n+                    cx.expr(span, ExprRet(Some(call)))\n+                };\n                 stmts.push(cx.stmt_expr(call));\n             }\n \n+            // enums with no fields need to return Ok()\n+            if stmts.len() == 0 {\n+                let ret_ok = cx.expr(trait_span,\n+                                     ExprRet(Some(cx.expr_ok(trait_span,\n+                                                             cx.expr_lit(trait_span, LitNil)))));\n+                stmts.push(cx.stmt_expr(ret_ok));\n+            }\n+\n             let blk = cx.lambda_stmts_1(trait_span, stmts, blkarg);\n             let name = cx.expr_str(trait_span, token::get_ident(variant.node.name));\n             let call = cx.expr_method_call(trait_span, blkencoder,"}, {"sha": "c4ce3c5cb551c986a603c4db0b94dbc250123511", "filename": "src/libsyntax/owned_slice.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f1739b14a1346419a4598339aee32aab07e0d12e/src%2Flibsyntax%2Fowned_slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1739b14a1346419a4598339aee32aab07e0d12e/src%2Flibsyntax%2Fowned_slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fowned_slice.rs?ref=f1739b14a1346419a4598339aee32aab07e0d12e", "patch": "@@ -131,14 +131,34 @@ impl<T> FromIterator<T> for OwnedSlice<T> {\n     }\n }\n \n+// FIXME: remove stage0 Encodables/Decodables after snapshot\n+#[cfg(stage0)]\n impl<S: Encoder, T: Encodable<S>> Encodable<S> for OwnedSlice<T> {\n     fn encode(&self, s: &mut S) {\n        self.as_slice().encode(s)\n     }\n }\n \n+#[cfg(stage0)]\n impl<D: Decoder, T: Decodable<D>> Decodable<D> for OwnedSlice<T> {\n     fn decode(d: &mut D) -> OwnedSlice<T> {\n         OwnedSlice::from_vec(Decodable::decode(d))\n     }\n }\n+\n+#[cfg(not(stage0))]\n+impl<S: Encoder<E>, T: Encodable<S, E>, E> Encodable<S, E> for OwnedSlice<T> {\n+    fn encode(&self, s: &mut S) -> Result<(), E> {\n+       self.as_slice().encode(s)\n+    }\n+}\n+\n+#[cfg(not(stage0))]\n+impl<D: Decoder<E>, T: Decodable<D, E>, E> Decodable<D, E> for OwnedSlice<T> {\n+    fn decode(d: &mut D) -> Result<OwnedSlice<T>, E> {\n+        Ok(OwnedSlice::from_vec(match Decodable::decode(d) {\n+            Ok(t) => t,\n+            Err(e) => return Err(e)\n+        }))\n+    }\n+}"}, {"sha": "2df93deea14b66669f4b718ac81d15fdb37d217b", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f1739b14a1346419a4598339aee32aab07e0d12e/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1739b14a1346419a4598339aee32aab07e0d12e/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=f1739b14a1346419a4598339aee32aab07e0d12e", "patch": "@@ -288,14 +288,23 @@ mod test {\n     use util::parser_testing::{string_to_expr, string_to_item};\n     use util::parser_testing::string_to_stmt;\n \n-    #[cfg(test)]\n+    // FIXME: remove stage0 to_json_str after snapshot\n+    #[cfg(stage0)]\n     fn to_json_str<'a, E: Encodable<json::Encoder<'a>>>(val: &E) -> ~str {\n         let mut writer = MemWriter::new();\n         let mut encoder = json::Encoder::new(&mut writer as &mut io::Writer);\n         val.encode(&mut encoder);\n         str::from_utf8_owned(writer.unwrap()).unwrap()\n     }\n \n+    #[cfg(not(stage0))]\n+    fn to_json_str<'a, E: Encodable<json::Encoder<'a>, io::IoError>>(val: &E) -> ~str {\n+        let mut writer = MemWriter::new();\n+        let mut encoder = json::Encoder::new(&mut writer as &mut io::Writer);\n+        let _ = val.encode(&mut encoder);\n+        str::from_utf8_owned(writer.unwrap()).unwrap()\n+    }\n+\n     // produce a codemap::span\n     fn sp(a: u32, b: u32) -> Span {\n         Span{lo:BytePos(a),hi:BytePos(b),expn_info:None}"}, {"sha": "7bb920bdf56dc3b2f1228b8ea594046049c40c26", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/f1739b14a1346419a4598339aee32aab07e0d12e/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1739b14a1346419a4598339aee32aab07e0d12e/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=f1739b14a1346419a4598339aee32aab07e0d12e", "patch": "@@ -602,18 +602,35 @@ impl<'a> Equiv<&'a str> for InternedString {\n     }\n }\n \n+// FIXME: remove stage0 Encodables/Decodables after snapshot\n+#[cfg(stage0)]\n impl<D:Decoder> Decodable<D> for InternedString {\n     fn decode(d: &mut D) -> InternedString {\n         get_name(get_ident_interner().intern(d.read_str()))\n     }\n }\n \n+#[cfg(stage0)]\n impl<E:Encoder> Encodable<E> for InternedString {\n     fn encode(&self, e: &mut E) {\n         e.emit_str(self.string.as_slice())\n     }\n }\n \n+#[cfg(not(stage0))]\n+impl<D:Decoder<E>, E> Decodable<D, E> for InternedString {\n+    fn decode(d: &mut D) -> Result<InternedString, E> {\n+        Ok(get_name(get_ident_interner().intern(try!(d.read_str()))))\n+    }\n+}\n+\n+#[cfg(not(stage0))]\n+impl<S:Encoder<E>, E> Encodable<S, E> for InternedString {\n+    fn encode(&self, s: &mut S) -> Result<(), E> {\n+        s.emit_str(self.string.as_slice())\n+    }\n+}\n+\n /// Returns the string contents of a name, using the task-local interner.\n #[inline]\n pub fn get_name(name: Name) -> InternedString {"}, {"sha": "751dc58450f91ceeb5058581f631d96ec29af8a0", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f1739b14a1346419a4598339aee32aab07e0d12e/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1739b14a1346419a4598339aee32aab07e0d12e/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=f1739b14a1346419a4598339aee32aab07e0d12e", "patch": "@@ -46,7 +46,7 @@ use stats::Stats;\n use time::precise_time_ns;\n use getopts::{OptGroup, optflag, optopt};\n use serialize::{json, Decodable};\n-use serialize::json::ToJson;\n+use serialize::json::{Json, ToJson};\n use term::Terminal;\n use term::color::{Color, RED, YELLOW, GREEN, CYAN};\n \n@@ -1018,6 +1018,23 @@ impl ToJson for Metric {\n     }\n }\n \n+// FIXME: remove decode_ after snapshot\n+#[cfg(stage0)]\n+fn decode_(json: Json) -> MetricMap {\n+    let mut decoder = json::Decoder::new(json);\n+    MetricMap(Decodable::decode(&mut decoder))\n+}\n+\n+#[cfg(not(stage0))]\n+fn decode_(json: Json) -> MetricMap {\n+    let mut decoder = json::Decoder::new(json);\n+    MetricMap(match Decodable::decode(&mut decoder) {\n+        Ok(t) => t,\n+        Err(e) => fail!(\"failure decoding JSON: {}\", e)\n+    })\n+}\n+\n+\n impl MetricMap {\n \n     pub fn new() -> MetricMap {\n@@ -1034,8 +1051,7 @@ impl MetricMap {\n         assert!(p.exists());\n         let mut f = File::open(p).unwrap();\n         let value = json::from_reader(&mut f as &mut io::Reader).unwrap();\n-        let mut decoder = json::Decoder::new(value);\n-        MetricMap(Decodable::decode(&mut decoder))\n+        decode_(value)\n     }\n \n     /// Write MetricDiff to a file."}, {"sha": "0065c90c91a12cac92d6af752263fb7a4602a3c1", "filename": "src/libuuid/lib.rs", "status": "modified", "additions": 33, "deletions": 3, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/f1739b14a1346419a4598339aee32aab07e0d12e/src%2Flibuuid%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1739b14a1346419a4598339aee32aab07e0d12e/src%2Flibuuid%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibuuid%2Flib.rs?ref=f1739b14a1346419a4598339aee32aab07e0d12e", "patch": "@@ -490,20 +490,39 @@ impl Eq for Uuid {\n impl TotalEq for Uuid {}\n \n // FIXME #9845: Test these more thoroughly\n+// FIXME: remove stage0 Encodable/Decodable after snapshot\n+#[cfg(stage0)]\n impl<T: Encoder> Encodable<T> for Uuid {\n     /// Encode a UUID as a hypenated string\n     fn encode(&self, e: &mut T) {\n-        e.emit_str(self.to_hyphenated_str());\n+        e.emit_str(self.to_hyphenated_str())\n     }\n }\n \n+#[cfg(stage0)]\n impl<T: Decoder> Decodable<T> for Uuid {\n     /// Decode a UUID from a string\n     fn decode(d: &mut T) -> Uuid {\n         from_str(d.read_str()).unwrap()\n     }\n }\n \n+#[cfg(not(stage0))]\n+impl<T: Encoder<E>, E> Encodable<T, E> for Uuid {\n+    /// Encode a UUID as a hypenated string\n+    fn encode(&self, e: &mut T) -> Result<(), E> {\n+        e.emit_str(self.to_hyphenated_str())\n+    }\n+}\n+\n+#[cfg(not(stage0))]\n+impl<T: Decoder<E>, E> Decodable<T, E> for Uuid {\n+    /// Decode a UUID from a string\n+    fn decode(d: &mut T) -> Result<Uuid, E> {\n+        Ok(from_str(try!(d.read_str())).unwrap())\n+    }\n+}\n+\n /// Generates a random instance of UUID (V4 conformant)\n impl rand::Rand for Uuid {\n     #[inline]\n@@ -528,6 +547,17 @@ mod test {\n     use std::str;\n     use std::io::MemWriter;\n \n+    // FIXME: remove unwrap_ after snapshot\n+    #[cfg(stage0)]\n+    fn unwrap_<T>(t: T) -> T {\n+        t\n+    }\n+\n+    #[cfg(not(stage0))]\n+    fn unwrap_<T, E>(t: Result<T, E>) -> T {\n+        t.unwrap()\n+    }\n+\n     #[test]\n     fn test_nil() {\n         let nil = Uuid::nil();\n@@ -797,9 +827,9 @@ mod test {\n \n         let u = Uuid::new_v4();\n         let mut wr = MemWriter::new();\n-        u.encode(&mut ebml::writer::Encoder(&mut wr));\n+        let _ = u.encode(&mut ebml::writer::Encoder(&mut wr));\n         let doc = ebml::reader::Doc(wr.get_ref());\n-        let u2 = Decodable::decode(&mut ebml::reader::Decoder(doc));\n+        let u2 = unwrap_(Decodable::decode(&mut ebml::reader::Decoder(doc)));\n         assert_eq!(u, u2);\n     }\n "}, {"sha": "a049279c5c40b4d21851a605d80728e71f315ab0", "filename": "src/libworkcache/lib.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f1739b14a1346419a4598339aee32aab07e0d12e/src%2Flibworkcache%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1739b14a1346419a4598339aee32aab07e0d12e/src%2Flibworkcache%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibworkcache%2Flib.rs?ref=f1739b14a1346419a4598339aee32aab07e0d12e", "patch": "@@ -203,7 +203,7 @@ impl Database {\n                                     self.db_filename.display(), e.to_str()),\n                     Ok(r) => {\n                         let mut decoder = json::Decoder::new(r);\n-                        self.db_cache = Decodable::decode(&mut decoder);\n+                        self.db_cache = Decodable::decode(&mut decoder).unwrap();\n                     }\n                 }\n             }\n@@ -252,19 +252,19 @@ enum Work<'a, T> {\n     WorkFromTask(&'a Prep<'a>, Receiver<(Exec, T)>),\n }\n \n-fn json_encode<'a, T:Encodable<json::Encoder<'a>>>(t: &T) -> ~str {\n+fn json_encode<'a, T:Encodable<json::Encoder<'a>, io::IoError>>(t: &T) -> ~str {\n     let mut writer = MemWriter::new();\n     let mut encoder = json::Encoder::new(&mut writer as &mut io::Writer);\n-    t.encode(&mut encoder);\n+    let _ = t.encode(&mut encoder);\n     str::from_utf8_owned(writer.unwrap()).unwrap()\n }\n \n // FIXME(#5121)\n-fn json_decode<T:Decodable<json::Decoder>>(s: &str) -> T {\n+fn json_decode<T:Decodable<json::Decoder, json::Error>>(s: &str) -> T {\n     debug!(\"json decoding: {}\", s);\n     let j = json::from_str(s).unwrap();\n     let mut decoder = json::Decoder::new(j);\n-    Decodable::decode(&mut decoder)\n+    Decodable::decode(&mut decoder).unwrap()\n }\n \n impl Context {\n@@ -392,15 +392,15 @@ impl<'a> Prep<'a> {\n     }\n \n     pub fn exec<'a, T:Send +\n-        Encodable<json::Encoder<'a>> +\n-        Decodable<json::Decoder>>(\n+        Encodable<json::Encoder<'a>, io::IoError> +\n+        Decodable<json::Decoder, json::Error>>(\n             &'a self, blk: proc:Send(&mut Exec) -> T) -> T {\n         self.exec_work(blk).unwrap()\n     }\n \n     fn exec_work<'a, T:Send +\n-        Encodable<json::Encoder<'a>> +\n-        Decodable<json::Decoder>>( // FIXME(#5121)\n+        Encodable<json::Encoder<'a>, io::IoError> +\n+        Decodable<json::Decoder, json::Error>>( // FIXME(#5121)\n             &'a self, blk: proc:Send(&mut Exec) -> T) -> Work<'a, T> {\n         let mut bo = Some(blk);\n \n@@ -443,8 +443,8 @@ impl<'a> Prep<'a> {\n }\n \n impl<'a, T:Send +\n-       Encodable<json::Encoder<'a>> +\n-       Decodable<json::Decoder>>\n+       Encodable<json::Encoder<'a>, io::IoError> +\n+       Decodable<json::Decoder, json::Error>>\n     Work<'a, T> { // FIXME(#5121)\n \n     pub fn from_value(elt: T) -> Work<'a, T> {"}, {"sha": "7f72850aaaf4fbfd00e3e1dd835eccc1a474e403", "filename": "src/test/run-pass/issue-4016.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f1739b14a1346419a4598339aee32aab07e0d12e/src%2Ftest%2Frun-pass%2Fissue-4016.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1739b14a1346419a4598339aee32aab07e0d12e/src%2Ftest%2Frun-pass%2Fissue-4016.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-4016.rs?ref=f1739b14a1346419a4598339aee32aab07e0d12e", "patch": "@@ -15,12 +15,12 @@ extern crate serialize;\n \n use serialize::{json, Decodable};\n \n-trait JD : Decodable<json::Decoder> { }\n+trait JD : Decodable<json::Decoder, json::Error> { }\n \n fn exec<T: JD>() {\n     let doc = json::from_str(\"\").unwrap();\n     let mut decoder = json::Decoder::new(doc);\n-    let _v: T = Decodable::decode(&mut decoder);\n+    let _v: T = Decodable::decode(&mut decoder).unwrap();\n     fail!()\n }\n "}, {"sha": "72efd25251264ff18c7db5d9c6f0fd53728a60b1", "filename": "src/test/run-pass/issue-4036.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f1739b14a1346419a4598339aee32aab07e0d12e/src%2Ftest%2Frun-pass%2Fissue-4036.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f1739b14a1346419a4598339aee32aab07e0d12e/src%2Ftest%2Frun-pass%2Fissue-4036.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-4036.rs?ref=f1739b14a1346419a4598339aee32aab07e0d12e", "patch": "@@ -20,5 +20,5 @@ use serialize::{json, Decodable};\n pub fn main() {\n     let json = json::from_str(\"[1]\").unwrap();\n     let mut decoder = json::Decoder::new(json);\n-    let _x: Vec<int> = Decodable::decode(&mut decoder);\n+    let _x: Vec<int> = Decodable::decode(&mut decoder).unwrap();\n }"}]}