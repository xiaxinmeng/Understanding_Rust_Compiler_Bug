{"sha": "7472bae5e76918bad5904c31e43b4237c015d6a5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc0NzJiYWU1ZTc2OTE4YmFkNTkwNGMzMWU0M2I0MjM3YzAxNWQ2YTU=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2013-10-10T20:48:11Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2013-10-12T00:15:52Z"}, "message": "rustpkg: Set exit codes properly and make tests take advantage of that\n\nWhen I started writing the rustpkg tests, task failure didn't set the\nexit code properly. But bblum's work from July fixed that. Hooray! I\njust didn't know about it till now.\n\nSo, now rustpkg uses exit codes in a more conventional way, and some of\nthe tests are simpler.\n\nThe bigger issue will be to make task failure propagate the error message.\nRight now, rustpkg does most of the work in separate tasks, which means if\na task fails, rustpkg can't distinguish between different types of failure\n(see #3408)", "tree": {"sha": "aadd51184b04985cc41269bacfd08530bfc0fea2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aadd51184b04985cc41269bacfd08530bfc0fea2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7472bae5e76918bad5904c31e43b4237c015d6a5", "comment_count": 9, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7472bae5e76918bad5904c31e43b4237c015d6a5", "html_url": "https://github.com/rust-lang/rust/commit/7472bae5e76918bad5904c31e43b4237c015d6a5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7472bae5e76918bad5904c31e43b4237c015d6a5/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "80878ff369cabc63967a6ebfd69f3e5fa692ceff", "url": "https://api.github.com/repos/rust-lang/rust/commits/80878ff369cabc63967a6ebfd69f3e5fa692ceff", "html_url": "https://github.com/rust-lang/rust/commit/80878ff369cabc63967a6ebfd69f3e5fa692ceff"}], "stats": {"total": 99, "additions": 72, "deletions": 27}, "files": [{"sha": "3b3cfe45b7a36b51f6097503b75ea606988c6c8b", "filename": "src/librustpkg/context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7472bae5e76918bad5904c31e43b4237c015d6a5/src%2Flibrustpkg%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7472bae5e76918bad5904c31e43b4237c015d6a5/src%2Flibrustpkg%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fcontext.rs?ref=7472bae5e76918bad5904c31e43b4237c015d6a5", "patch": "@@ -210,11 +210,11 @@ impl RustcFlags {\n }\n \n /// Returns true if any of the flags given are incompatible with the cmd\n-pub fn flags_ok_for_cmd(flags: &RustcFlags,\n+pub fn flags_forbidden_for_cmd(flags: &RustcFlags,\n                         cfgs: &[~str],\n                         cmd: &str, user_supplied_opt_level: bool) -> bool {\n     let complain = |s| {\n-        println!(\"The {} option can only be used with the build command:\n+        println!(\"The {} option can only be used with the `build` command:\n                   rustpkg [options..] build {} [package-ID]\", s, s);\n     };\n "}, {"sha": "daa5eee62d205d29ba996685e1928f3edf612b20", "filename": "src/librustpkg/exit_codes.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7472bae5e76918bad5904c31e43b4237c015d6a5/src%2Flibrustpkg%2Fexit_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7472bae5e76918bad5904c31e43b4237c015d6a5/src%2Flibrustpkg%2Fexit_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fexit_codes.rs?ref=7472bae5e76918bad5904c31e43b4237c015d6a5", "patch": "@@ -9,3 +9,6 @@\n // except according to those terms.\n \n pub static COPY_FAILED_CODE: int = 65;\n+pub static BAD_FLAG_CODE: int    = 67;\n+pub static NONEXISTENT_PACKAGE_CODE: int = 68;\n+"}, {"sha": "63195112747ac862a78cb8ce141a5990dbe22dbe", "filename": "src/librustpkg/rustpkg.rs", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7472bae5e76918bad5904c31e43b4237c015d6a5/src%2Flibrustpkg%2Frustpkg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7472bae5e76918bad5904c31e43b4237c015d6a5/src%2Flibrustpkg%2Frustpkg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Frustpkg.rs?ref=7472bae5e76918bad5904c31e43b4237c015d6a5", "patch": "@@ -50,7 +50,7 @@ use package_source::PkgSrc;\n use target::{WhatToBuild, Everything, is_lib, is_main, is_test, is_bench, Tests};\n // use workcache_support::{discover_outputs, digest_only_date};\n use workcache_support::digest_only_date;\n-use exit_codes::COPY_FAILED_CODE;\n+use exit_codes::{COPY_FAILED_CODE, BAD_FLAG_CODE};\n \n pub mod api;\n mod conditions;\n@@ -701,7 +701,7 @@ pub fn main_args(args: &[~str]) -> int {\n             return 1;\n         }\n     };\n-    let mut help = matches.opt_present(\"h\") ||\n+    let help = matches.opt_present(\"h\") ||\n                    matches.opt_present(\"help\");\n     let no_link = matches.opt_present(\"no-link\");\n     let no_trans = matches.opt_present(\"no-trans\");\n@@ -798,8 +798,11 @@ pub fn main_args(args: &[~str]) -> int {\n             return 0;\n         }\n         Some(cmd) => {\n-            help |= context::flags_ok_for_cmd(&rustc_flags, cfgs, *cmd, user_supplied_opt_level);\n-            if help {\n+            let bad_option = context::flags_forbidden_for_cmd(&rustc_flags,\n+                                                              cfgs,\n+                                                              *cmd,\n+                                                              user_supplied_opt_level);\n+            if help || bad_option {\n                 match *cmd {\n                     ~\"build\" => usage::build(),\n                     ~\"clean\" => usage::clean(),\n@@ -814,7 +817,12 @@ pub fn main_args(args: &[~str]) -> int {\n                     ~\"unprefer\" => usage::unprefer(),\n                     _ => usage::general()\n                 };\n-                return 0;\n+                if bad_option {\n+                    return BAD_FLAG_CODE;\n+                }\n+                else {\n+                    return 0;\n+                }\n             } else {\n                 cmd\n             }"}, {"sha": "d03243599ef5984abb48565a186fb3f7165e3864", "filename": "src/librustpkg/tests.rs", "status": "modified", "additions": 54, "deletions": 20, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/7472bae5e76918bad5904c31e43b4237c015d6a5/src%2Flibrustpkg%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7472bae5e76918bad5904c31e43b4237c015d6a5/src%2Flibrustpkg%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftests.rs?ref=7472bae5e76918bad5904c31e43b4237c015d6a5", "patch": "@@ -36,6 +36,7 @@ use syntax::diagnostic;\n use target::*;\n use package_source::PkgSrc;\n use source_control::{CheckedOutSources, DirToUse, safe_git_clone};\n+use exit_codes::{BAD_FLAG_CODE, COPY_FAILED_CODE};\n use util::datestamp;\n \n fn fake_ctxt(sysroot: Path, workspace: &Path) -> BuildContext {\n@@ -244,14 +245,26 @@ fn rustpkg_exec() -> Path {\n fn command_line_test(args: &[~str], cwd: &Path) -> ProcessOutput {\n     match command_line_test_with_env(args, cwd, None) {\n         Success(r) => r,\n-        _ => fail2!(\"Command line test failed\")\n+        Fail(error) => fail2!(\"Command line test failed with error {}\", error)\n     }\n }\n \n fn command_line_test_partial(args: &[~str], cwd: &Path) -> ProcessResult {\n     command_line_test_with_env(args, cwd, None)\n }\n \n+fn command_line_test_expect_fail(args: &[~str],\n+                                 cwd: &Path,\n+                                 env: Option<~[(~str, ~str)]>,\n+                                 expected_exitcode: int) {\n+    match command_line_test_with_env(args, cwd, env) {\n+        Success(_) => fail2!(\"Should have failed with {}, but it succeeded\", expected_exitcode),\n+        Fail(error) if error == expected_exitcode => (), // ok\n+        Fail(other) => fail2!(\"Expected to fail with {}, but failed with {} instead\",\n+                              expected_exitcode, other)\n+    }\n+}\n+\n enum ProcessResult {\n     Success(ProcessOutput),\n     Fail(int) // exit code\n@@ -1448,11 +1461,11 @@ fn compile_flag_fail() {\n     let p_id = PkgId::new(\"foo\");\n     let workspace = create_local_package(&p_id);\n     let workspace = workspace.path();\n-    command_line_test([test_sysroot().to_str(),\n+    command_line_test_expect_fail([test_sysroot().to_str(),\n                        ~\"install\",\n                        ~\"--no-link\",\n                        ~\"foo\"],\n-                      workspace);\n+                      workspace, None, BAD_FLAG_CODE);\n     assert!(!built_executable_exists(workspace, \"foo\"));\n     assert!(!object_file_exists(workspace, \"foo\"));\n }\n@@ -1488,14 +1501,11 @@ fn notrans_flag_fail() {\n     let flags_to_test = [~\"--no-trans\", ~\"--parse-only\",\n                          ~\"--pretty\", ~\"-S\"];\n     for flag in flags_to_test.iter() {\n-        command_line_test([test_sysroot().to_str(),\n+        command_line_test_expect_fail([test_sysroot().to_str(),\n                            ~\"install\",\n                            flag.clone(),\n                            ~\"foo\"],\n-                          workspace);\n-        // Ideally we'd test that rustpkg actually fails, but\n-        // since task failure doesn't set the exit code properly,\n-        // we can't tell\n+                          workspace, None, BAD_FLAG_CODE);\n         assert!(!built_executable_exists(workspace, \"foo\"));\n         assert!(!object_file_exists(workspace, \"foo\"));\n         assert!(!lib_exists(workspace, &Path(\"foo\"), NoVersion));\n@@ -1522,11 +1532,11 @@ fn dash_S_fail() {\n     let p_id = PkgId::new(\"foo\");\n     let workspace = create_local_package(&p_id);\n     let workspace = workspace.path();\n-    command_line_test([test_sysroot().to_str(),\n+    command_line_test_expect_fail([test_sysroot().to_str(),\n                        ~\"install\",\n                        ~\"-S\",\n                        ~\"foo\"],\n-                      workspace);\n+                       workspace, None, BAD_FLAG_CODE);\n     assert!(!built_executable_exists(workspace, \"foo\"));\n     assert!(!object_file_exists(workspace, \"foo\"));\n     assert!(!assembly_file_exists(workspace, \"foo\"));\n@@ -1587,11 +1597,13 @@ fn test_emit_llvm_S_fail() {\n     let p_id = PkgId::new(\"foo\");\n     let workspace = create_local_package(&p_id);\n     let workspace = workspace.path();\n-    command_line_test([test_sysroot().to_str(),\n+    command_line_test_expect_fail([test_sysroot().to_str(),\n                        ~\"install\",\n                        ~\"-S\", ~\"--emit-llvm\",\n                        ~\"foo\"],\n-                      workspace);\n+                       workspace,\n+                       None,\n+                       BAD_FLAG_CODE);\n     assert!(!built_executable_exists(workspace, \"foo\"));\n     assert!(!object_file_exists(workspace, \"foo\"));\n     assert!(!llvm_assembly_file_exists(workspace, \"foo\"));\n@@ -1620,11 +1632,13 @@ fn test_emit_llvm_fail() {\n     let p_id = PkgId::new(\"foo\");\n     let workspace = create_local_package(&p_id);\n     let workspace = workspace.path();\n-    command_line_test([test_sysroot().to_str(),\n+    command_line_test_expect_fail([test_sysroot().to_str(),\n                        ~\"install\",\n                        ~\"--emit-llvm\",\n                        ~\"foo\"],\n-                      workspace);\n+                                  workspace,\n+                                  None,\n+                                  BAD_FLAG_CODE);\n     assert!(!built_executable_exists(workspace, \"foo\"));\n     assert!(!object_file_exists(workspace, \"foo\"));\n     assert!(!llvm_bitcode_file_exists(workspace, \"foo\"));\n@@ -1665,11 +1679,10 @@ fn test_build_install_flags_fail() {\n                      ~[~\"--target\", host_triple()],\n                      ~[~\"--target-cpu\", ~\"generic\"],\n                      ~[~\"-Z\", ~\"--time-passes\"]];\n+    let cwd = os::getcwd();\n     for flag in forbidden.iter() {\n-        let output = command_line_test_output([test_sysroot().to_str(),\n-                           ~\"list\"] + *flag);\n-        assert!(output.len() > 1);\n-        assert!(output[1].find_str(\"can only be used with\").is_some());\n+        command_line_test_expect_fail([test_sysroot().to_str(),\n+                           ~\"list\"] + *flag, &cwd, None, BAD_FLAG_CODE);\n     }\n }\n \n@@ -1686,6 +1699,7 @@ fn test_optimized_build() {\n     assert!(built_executable_exists(workspace, \"foo\"));\n }\n \n+#[test]\n fn pkgid_pointing_to_subdir() {\n     // The actual repo is mockgithub.com/mozilla/some_repo\n     // rustpkg should recognize that and treat the part after some_repo/ as a subdir\n@@ -1717,6 +1731,7 @@ fn pkgid_pointing_to_subdir() {\n     assert_executable_exists(workspace, \"testpkg\");\n }\n \n+#[test]\n fn test_recursive_deps() {\n     let a_id = PkgId::new(\"a\");\n     let b_id = PkgId::new(\"b\");\n@@ -1762,6 +1777,7 @@ fn test_install_to_rust_path() {\n     assert!(!executable_exists(second_workspace, \"foo\"));\n }\n \n+#[test]\n fn test_target_specific_build_dir() {\n     let p_id = PkgId::new(\"foo\");\n     let workspace = create_local_package(&p_id);\n@@ -1870,8 +1886,9 @@ fn correct_package_name_with_rust_path_hack() {\n     let rust_path = Some(~[(~\"RUST_PATH\", format!(\"{}:{}\", dest_workspace.to_str(),\n                         foo_workspace.push_many([\"src\", \"foo-0.1\"]).to_str()))]);\n     // bar doesn't exist, but we want to make sure rustpkg doesn't think foo is bar\n-    command_line_test_with_env([~\"install\", ~\"--rust-path-hack\", ~\"bar\"],\n-                               dest_workspace, rust_path);\n+    command_line_test_expect_fail([~\"install\", ~\"--rust-path-hack\", ~\"bar\"],\n+                                  // FIXME #3408: Should be NONEXISTENT_PACKAGE_CODE\n+                               dest_workspace, rust_path, COPY_FAILED_CODE);\n     assert!(!executable_exists(dest_workspace, \"bar\"));\n     assert!(!lib_exists(dest_workspace, &bar_id.path.clone(), bar_id.version.clone()));\n     assert!(!executable_exists(dest_workspace, \"foo\"));\n@@ -2050,6 +2067,23 @@ fn test_7402() {\n     assert_executable_exists(dest_workspace, \"foo\");\n }\n \n+#[test]\n+fn test_compile_error() {\n+    let foo_id = PkgId::new(\"foo\");\n+    let foo_workspace = create_local_package(&foo_id);\n+    let foo_workspace = foo_workspace.path();\n+    let main_crate = foo_workspace.push_many([\"src\", \"foo-0.1\", \"main.rs\"]);\n+    // Write something bogus\n+    writeFile(&main_crate, \"pub fn main() { if 42 != ~\\\"the answer\\\" { fail!(); } }\");\n+    let result = command_line_test_partial([~\"build\", ~\"foo\"], foo_workspace);\n+    match result {\n+        Success(*) => fail2!(\"Failed by succeeding!\"), // should be a compile error\n+        Fail(status) => {\n+            debug2!(\"Failed with status {:?}... that's good, right?\", status);\n+        }\n+    }\n+}\n+\n /// Returns true if p exists and is executable\n fn is_executable(p: &Path) -> bool {\n     use std::libc::consts::os::posix88::{S_IXUSR};"}]}