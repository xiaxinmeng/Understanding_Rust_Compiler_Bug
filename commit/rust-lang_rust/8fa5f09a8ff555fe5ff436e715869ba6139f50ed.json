{"sha": "8fa5f09a8ff555fe5ff436e715869ba6139f50ed", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhmYTVmMDlhOGZmNTU1ZmU1ZmY0MzZlNzE1ODY5YmE2MTM5ZjUwZWQ=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-10-22T16:28:47Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-10-22T20:58:08Z"}, "message": "distinguish projections from the env/obj-types vs those from\ntrait definitions, and give prefence to the former. This is consistent\nwith what we do for selection. It also works around a limitation\nthat was leading to #28871.", "tree": {"sha": "a72f0b54f20e36518707ba2de58c8e03f0375c84", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a72f0b54f20e36518707ba2de58c8e03f0375c84"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8fa5f09a8ff555fe5ff436e715869ba6139f50ed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8fa5f09a8ff555fe5ff436e715869ba6139f50ed", "html_url": "https://github.com/rust-lang/rust/commit/8fa5f09a8ff555fe5ff436e715869ba6139f50ed", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8fa5f09a8ff555fe5ff436e715869ba6139f50ed/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "83cf3ce4981e2ff1a3d7629665b7ec884adbb9de", "url": "https://api.github.com/repos/rust-lang/rust/commits/83cf3ce4981e2ff1a3d7629665b7ec884adbb9de", "html_url": "https://github.com/rust-lang/rust/commit/83cf3ce4981e2ff1a3d7629665b7ec884adbb9de"}], "stats": {"total": 105, "additions": 93, "deletions": 12}, "files": [{"sha": "bf90b3a02a870f5f6e013d552cc22940566f7d19", "filename": "src/librustc/middle/traits/project.rs", "status": "modified", "additions": 62, "deletions": 12, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/8fa5f09a8ff555fe5ff436e715869ba6139f50ed/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fa5f09a8ff555fe5ff436e715869ba6139f50ed/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs?ref=8fa5f09a8ff555fe5ff436e715869ba6139f50ed", "patch": "@@ -54,9 +54,19 @@ pub struct MismatchedProjectionTypes<'tcx> {\n \n #[derive(PartialEq, Eq, Debug)]\n enum ProjectionTyCandidate<'tcx> {\n+    // from a where-clause in the env or object type\n     ParamEnv(ty::PolyProjectionPredicate<'tcx>),\n+\n+    // from the definition of `Trait` when you have something like <<A as Trait>::B as Trait2>::C\n+    TraitDef(ty::PolyProjectionPredicate<'tcx>),\n+\n+    // defined in an impl\n     Impl(VtableImplData<'tcx, PredicateObligation<'tcx>>),\n+\n+    // closure return type\n     Closure(VtableClosureData<'tcx, PredicateObligation<'tcx>>),\n+\n+    // fn pointer return type\n     FnPointer(Ty<'tcx>),\n }\n \n@@ -491,7 +501,11 @@ fn project_type<'cx,'tcx>(\n            candidates.vec.len(),\n            candidates.ambiguous);\n \n-    // We probably need some winnowing logic similar to select here.\n+    // Inherent ambiguity that prevents us from even enumerating the\n+    // candidates.\n+    if candidates.ambiguous {\n+        return Err(ProjectionTyError::TooManyCandidates);\n+    }\n \n     // Drop duplicates.\n     //\n@@ -512,10 +526,30 @@ fn project_type<'cx,'tcx>(\n         }\n     }\n \n-    if candidates.ambiguous || candidates.vec.len() > 1 {\n-        return Err(ProjectionTyError::TooManyCandidates);\n+    // Prefer where-clauses. As in select, if there are multiple\n+    // candidates, we prefer where-clause candidates over impls.  This\n+    // may seem a bit surprising, since impls are the source of\n+    // \"truth\" in some sense, but in fact some of the impls that SEEM\n+    // applicable are not, because of nested obligations. Where\n+    // clauses are the safer choice. See the comment on\n+    // `select::SelectionCandidate` and #21974 for more details.\n+    if candidates.vec.len() > 1 {\n+        debug!(\"retaining param-env candidates only from {:?}\", candidates.vec);\n+        candidates.vec.retain(|c| match *c {\n+            ProjectionTyCandidate::ParamEnv(..) => true,\n+            ProjectionTyCandidate::Impl(..) |\n+            ProjectionTyCandidate::Closure(..) |\n+            ProjectionTyCandidate::TraitDef(..) |\n+            ProjectionTyCandidate::FnPointer(..) => false,\n+        });\n+        debug!(\"resulting candidate set: {:?}\", candidates.vec);\n+        if candidates.vec.len() != 1 {\n+            return Err(ProjectionTyError::TooManyCandidates);\n+        }\n     }\n \n+    assert!(candidates.vec.len() <= 1);\n+\n     match candidates.vec.pop() {\n         Some(candidate) => {\n             let (ty, obligations) = confirm_candidate(selcx, obligation, candidate);\n@@ -538,9 +572,14 @@ fn assemble_candidates_from_param_env<'cx,'tcx>(\n     obligation_trait_ref: &ty::TraitRef<'tcx>,\n     candidate_set: &mut ProjectionTyCandidateSet<'tcx>)\n {\n+    debug!(\"assemble_candidates_from_param_env(..)\");\n     let env_predicates = selcx.param_env().caller_bounds.iter().cloned();\n-    assemble_candidates_from_predicates(selcx, obligation, obligation_trait_ref,\n-                                        candidate_set, env_predicates);\n+    assemble_candidates_from_predicates(selcx,\n+                                        obligation,\n+                                        obligation_trait_ref,\n+                                        candidate_set,\n+                                        ProjectionTyCandidate::ParamEnv,\n+                                        env_predicates);\n }\n \n /// In the case of a nested projection like <<A as Foo>::FooT as Bar>::BarT, we may find\n@@ -559,6 +598,8 @@ fn assemble_candidates_from_trait_def<'cx,'tcx>(\n     obligation_trait_ref: &ty::TraitRef<'tcx>,\n     candidate_set: &mut ProjectionTyCandidateSet<'tcx>)\n {\n+    debug!(\"assemble_candidates_from_trait_def(..)\");\n+\n     // Check whether the self-type is itself a projection.\n     let trait_ref = match obligation_trait_ref.self_ty().sty {\n         ty::TyProjection(ref data) => data.trait_ref.clone(),\n@@ -575,15 +616,20 @@ fn assemble_candidates_from_trait_def<'cx,'tcx>(\n     let trait_predicates = selcx.tcx().lookup_predicates(trait_ref.def_id);\n     let bounds = trait_predicates.instantiate(selcx.tcx(), trait_ref.substs);\n     let bounds = elaborate_predicates(selcx.tcx(), bounds.predicates.into_vec());\n-    assemble_candidates_from_predicates(selcx, obligation, obligation_trait_ref,\n-                                        candidate_set, bounds)\n+    assemble_candidates_from_predicates(selcx,\n+                                        obligation,\n+                                        obligation_trait_ref,\n+                                        candidate_set,\n+                                        ProjectionTyCandidate::TraitDef,\n+                                        bounds)\n }\n \n fn assemble_candidates_from_predicates<'cx,'tcx,I>(\n     selcx: &mut SelectionContext<'cx,'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n     obligation_trait_ref: &ty::TraitRef<'tcx>,\n     candidate_set: &mut ProjectionTyCandidateSet<'tcx>,\n+    ctor: fn(ty::PolyProjectionPredicate<'tcx>) -> ProjectionTyCandidate<'tcx>,\n     env_predicates: I)\n     where I: Iterator<Item=ty::Predicate<'tcx>>\n {\n@@ -614,8 +660,7 @@ fn assemble_candidates_from_predicates<'cx,'tcx,I>(\n                        data, is_match, same_name);\n \n                 if is_match {\n-                    candidate_set.vec.push(\n-                        ProjectionTyCandidate::ParamEnv(data.clone()));\n+                    candidate_set.vec.push(ctor(data.clone()));\n                 }\n             }\n             _ => { }\n@@ -647,8 +692,12 @@ fn assemble_candidates_from_object_type<'cx,'tcx>(\n                                           .map(|p| p.to_predicate())\n                                           .collect();\n     let env_predicates = elaborate_predicates(selcx.tcx(), env_predicates);\n-    assemble_candidates_from_predicates(selcx, obligation, obligation_trait_ref,\n-                                        candidate_set, env_predicates)\n+    assemble_candidates_from_predicates(selcx,\n+                                        obligation,\n+                                        obligation_trait_ref,\n+                                        candidate_set,\n+                                        ProjectionTyCandidate::ParamEnv,\n+                                        env_predicates)\n }\n \n fn assemble_candidates_from_impls<'cx,'tcx>(\n@@ -746,7 +795,8 @@ fn confirm_candidate<'cx,'tcx>(\n            obligation);\n \n     match candidate {\n-        ProjectionTyCandidate::ParamEnv(poly_projection) => {\n+        ProjectionTyCandidate::ParamEnv(poly_projection) |\n+        ProjectionTyCandidate::TraitDef(poly_projection) => {\n             confirm_param_env_candidate(selcx, obligation, poly_projection)\n         }\n "}, {"sha": "8e9bd5b104252a6b96f64b3dc478704cd5944d36", "filename": "src/test/run-pass/issue-28871.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/8fa5f09a8ff555fe5ff436e715869ba6139f50ed/src%2Ftest%2Frun-pass%2Fissue-28871.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fa5f09a8ff555fe5ff436e715869ba6139f50ed/src%2Ftest%2Frun-pass%2Fissue-28871.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-28871.rs?ref=8fa5f09a8ff555fe5ff436e715869ba6139f50ed", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Regression test for #28871. The problem is that rustc encountered\n+// two ways to project, one from a where clause and one from the where\n+// clauses on the trait definition. (In fact, in this case, the where\n+// clauses originated from the trait definition as well.) The true\n+// cause of the error is that the trait definition where clauses are\n+// not being normalized, and hence the two sources are considered in\n+// conflict, and not a duplicate. Hacky solution is to prefer where\n+// clauses over the data found in the trait definition.\n+\n+trait T {\n+    type T;\n+}\n+\n+struct S;\n+impl T for S {\n+    type T = S;\n+}\n+\n+trait T2 {\n+    type T: Iterator<Item=<S as T>::T>;\n+}"}]}