{"sha": "cd3f31d9d13652c62795a985d91f7c6c6673b7a8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNkM2YzMWQ5ZDEzNjUyYzYyNzk1YTk4NWQ5MWY3YzZjNjY3M2I3YTg=", "commit": {"author": {"name": "Kevin Ballard", "email": "kevin@sb.org", "date": "2014-05-04T06:34:26Z"}, "committer": {"name": "Kevin Ballard", "email": "kevin@sb.org", "date": "2014-05-08T19:06:22Z"}, "message": "Handle fallout in libserialize\n\nAPI Changes:\n\n- from_base64() returns Result<Vec<u8>, FromBase64Error>\n- from_hex() returns Result<Vec<u8>, FromHexError>\n- json::List is a Vec<Json>\n- Decodable is no longer implemented on ~[T] (but Encodable still is)\n- DecoderHelpers::read_to_vec() returns a Result<Vec<T>, E>", "tree": {"sha": "a62f41a5cd27125c53b9663e72d82f1852c224f4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a62f41a5cd27125c53b9663e72d82f1852c224f4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cd3f31d9d13652c62795a985d91f7c6c6673b7a8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cd3f31d9d13652c62795a985d91f7c6c6673b7a8", "html_url": "https://github.com/rust-lang/rust/commit/cd3f31d9d13652c62795a985d91f7c6c6673b7a8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cd3f31d9d13652c62795a985d91f7c6c6673b7a8/comments", "author": {"login": "lilyball", "id": 714, "node_id": "MDQ6VXNlcjcxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/714?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lilyball", "html_url": "https://github.com/lilyball", "followers_url": "https://api.github.com/users/lilyball/followers", "following_url": "https://api.github.com/users/lilyball/following{/other_user}", "gists_url": "https://api.github.com/users/lilyball/gists{/gist_id}", "starred_url": "https://api.github.com/users/lilyball/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lilyball/subscriptions", "organizations_url": "https://api.github.com/users/lilyball/orgs", "repos_url": "https://api.github.com/users/lilyball/repos", "events_url": "https://api.github.com/users/lilyball/events{/privacy}", "received_events_url": "https://api.github.com/users/lilyball/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lilyball", "id": 714, "node_id": "MDQ6VXNlcjcxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/714?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lilyball", "html_url": "https://github.com/lilyball", "followers_url": "https://api.github.com/users/lilyball/followers", "following_url": "https://api.github.com/users/lilyball/following{/other_user}", "gists_url": "https://api.github.com/users/lilyball/gists{/gist_id}", "starred_url": "https://api.github.com/users/lilyball/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lilyball/subscriptions", "organizations_url": "https://api.github.com/users/lilyball/orgs", "repos_url": "https://api.github.com/users/lilyball/repos", "events_url": "https://api.github.com/users/lilyball/events{/privacy}", "received_events_url": "https://api.github.com/users/lilyball/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2a0dac6f58fb07d5fb6a4dfa94e10ddaa44315a7", "url": "https://api.github.com/repos/rust-lang/rust/commits/2a0dac6f58fb07d5fb6a4dfa94e10ddaa44315a7", "html_url": "https://github.com/rust-lang/rust/commit/2a0dac6f58fb07d5fb6a4dfa94e10ddaa44315a7"}], "stats": {"total": 161, "additions": 73, "deletions": 88}, "files": [{"sha": "4709365ebff533fe7d0647fbfee3f2720c40cb85", "filename": "src/libserialize/base64.rs", "status": "modified", "additions": 18, "deletions": 19, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/cd3f31d9d13652c62795a985d91f7c6c6673b7a8/src%2Flibserialize%2Fbase64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd3f31d9d13652c62795a985d91f7c6c6673b7a8/src%2Flibserialize%2Fbase64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fbase64.rs?ref=cd3f31d9d13652c62795a985d91f7c6c6673b7a8", "patch": "@@ -146,7 +146,7 @@ impl<'a> ToBase64 for &'a [u8] {\n         }\n \n         unsafe {\n-            str::raw::from_utf8_owned(v.move_iter().collect())\n+            str::raw::from_utf8(v.as_slice()).to_owned()\n         }\n     }\n }\n@@ -155,7 +155,7 @@ impl<'a> ToBase64 for &'a [u8] {\n pub trait FromBase64 {\n     /// Converts the value of `self`, interpreted as base64 encoded data, into\n     /// an owned vector of bytes, returning the vector.\n-    fn from_base64(&self) -> Result<~[u8], FromBase64Error>;\n+    fn from_base64(&self) -> Result<Vec<u8>, FromBase64Error>;\n }\n \n /// Errors that can occur when decoding a base64 encoded string\n@@ -192,22 +192,21 @@ impl<'a> FromBase64 for &'a str {\n      * ```rust\n      * extern crate serialize;\n      * use serialize::base64::{ToBase64, FromBase64, STANDARD};\n-     * use std::str;\n      *\n      * fn main () {\n      *     let hello_str = bytes!(\"Hello, World\").to_base64(STANDARD);\n      *     println!(\"base64 output: {}\", hello_str);\n      *     let res = hello_str.from_base64();\n      *     if res.is_ok() {\n-     *       let opt_bytes = str::from_utf8_owned(res.unwrap());\n+     *       let opt_bytes = StrBuf::from_utf8(res.unwrap());\n      *       if opt_bytes.is_some() {\n      *         println!(\"decoded from base64: {}\", opt_bytes.unwrap());\n      *       }\n      *     }\n      * }\n      * ```\n      */\n-    fn from_base64(&self) -> Result<~[u8], FromBase64Error> {\n+    fn from_base64(&self) -> Result<Vec<u8>, FromBase64Error> {\n         let mut r = Vec::new();\n         let mut buf: u32 = 0;\n         let mut modulus = 0;\n@@ -256,7 +255,7 @@ impl<'a> FromBase64 for &'a str {\n             _ => return Err(InvalidBase64Length),\n         }\n \n-        Ok(r.move_iter().collect())\n+        Ok(r)\n     }\n }\n \n@@ -301,21 +300,21 @@ mod tests {\n \n     #[test]\n     fn test_from_base64_basic() {\n-        assert_eq!(\"\".from_base64().unwrap(), \"\".as_bytes().to_owned());\n-        assert_eq!(\"Zg==\".from_base64().unwrap(), \"f\".as_bytes().to_owned());\n-        assert_eq!(\"Zm8=\".from_base64().unwrap(), \"fo\".as_bytes().to_owned());\n-        assert_eq!(\"Zm9v\".from_base64().unwrap(), \"foo\".as_bytes().to_owned());\n-        assert_eq!(\"Zm9vYg==\".from_base64().unwrap(), \"foob\".as_bytes().to_owned());\n-        assert_eq!(\"Zm9vYmE=\".from_base64().unwrap(), \"fooba\".as_bytes().to_owned());\n-        assert_eq!(\"Zm9vYmFy\".from_base64().unwrap(), \"foobar\".as_bytes().to_owned());\n+        assert_eq!(\"\".from_base64().unwrap().as_slice(), \"\".as_bytes());\n+        assert_eq!(\"Zg==\".from_base64().unwrap().as_slice(), \"f\".as_bytes());\n+        assert_eq!(\"Zm8=\".from_base64().unwrap().as_slice(), \"fo\".as_bytes());\n+        assert_eq!(\"Zm9v\".from_base64().unwrap().as_slice(), \"foo\".as_bytes());\n+        assert_eq!(\"Zm9vYg==\".from_base64().unwrap().as_slice(), \"foob\".as_bytes());\n+        assert_eq!(\"Zm9vYmE=\".from_base64().unwrap().as_slice(), \"fooba\".as_bytes());\n+        assert_eq!(\"Zm9vYmFy\".from_base64().unwrap().as_slice(), \"foobar\".as_bytes());\n     }\n \n     #[test]\n     fn test_from_base64_newlines() {\n-        assert_eq!(\"Zm9v\\r\\nYmFy\".from_base64().unwrap(),\n-                   \"foobar\".as_bytes().to_owned());\n-        assert_eq!(\"Zm9vYg==\\r\\n\".from_base64().unwrap(),\n-                   \"foob\".as_bytes().to_owned());\n+        assert_eq!(\"Zm9v\\r\\nYmFy\".from_base64().unwrap().as_slice(),\n+                   \"foobar\".as_bytes());\n+        assert_eq!(\"Zm9vYg==\\r\\n\".from_base64().unwrap().as_slice(),\n+                   \"foob\".as_bytes());\n     }\n \n     #[test]\n@@ -341,8 +340,8 @@ mod tests {\n         for _ in range(0, 1000) {\n             let times = task_rng().gen_range(1u, 100);\n             let v = Vec::from_fn(times, |_| random::<u8>());\n-            assert_eq!(v.as_slice().to_base64(STANDARD).from_base64().unwrap(),\n-                       v.as_slice().to_owned());\n+            assert_eq!(v.as_slice().to_base64(STANDARD).from_base64().unwrap().as_slice(),\n+                       v.as_slice());\n         }\n     }\n "}, {"sha": "c463d97dba4d48fe960b36f79c1621615de10852", "filename": "src/libserialize/hex.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/cd3f31d9d13652c62795a985d91f7c6c6673b7a8/src%2Flibserialize%2Fhex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd3f31d9d13652c62795a985d91f7c6c6673b7a8/src%2Flibserialize%2Fhex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fhex.rs?ref=cd3f31d9d13652c62795a985d91f7c6c6673b7a8", "patch": "@@ -45,7 +45,7 @@ impl<'a> ToHex for &'a [u8] {\n         }\n \n         unsafe {\n-            str::raw::from_utf8_owned(v.move_iter().collect())\n+            str::raw::from_utf8(v.as_slice()).to_owned()\n         }\n     }\n }\n@@ -54,7 +54,7 @@ impl<'a> ToHex for &'a [u8] {\n pub trait FromHex {\n     /// Converts the value of `self`, interpreted as hexadecimal encoded data,\n     /// into an owned vector of bytes, returning the vector.\n-    fn from_hex(&self) -> Result<~[u8], FromHexError>;\n+    fn from_hex(&self) -> Result<Vec<u8>, FromHexError>;\n }\n \n /// Errors that can occur when decoding a hex encoded string\n@@ -91,19 +91,18 @@ impl<'a> FromHex for &'a str {\n      * ```rust\n      * extern crate serialize;\n      * use serialize::hex::{FromHex, ToHex};\n-     * use std::str;\n      *\n      * fn main () {\n      *     let hello_str = \"Hello, World\".as_bytes().to_hex();\n      *     println!(\"{}\", hello_str);\n      *     let bytes = hello_str.from_hex().unwrap();\n      *     println!(\"{:?}\", bytes);\n-     *     let result_str = str::from_utf8_owned(bytes).unwrap();\n+     *     let result_str = StrBuf::from_utf8(bytes).unwrap();\n      *     println!(\"{}\", result_str);\n      * }\n      * ```\n      */\n-    fn from_hex(&self) -> Result<~[u8], FromHexError> {\n+    fn from_hex(&self) -> Result<Vec<u8>, FromHexError> {\n         // This may be an overestimate if there is any whitespace\n         let mut b = Vec::with_capacity(self.len() / 2);\n         let mut modulus = 0;\n@@ -150,10 +149,10 @@ mod tests {\n \n     #[test]\n     pub fn test_from_hex_okay() {\n-        assert_eq!(\"666f6f626172\".from_hex().unwrap(),\n-                   \"foobar\".as_bytes().to_owned());\n-        assert_eq!(\"666F6F626172\".from_hex().unwrap(),\n-                   \"foobar\".as_bytes().to_owned());\n+        assert_eq!(\"666f6f626172\".from_hex().unwrap().as_slice(),\n+                   \"foobar\".as_bytes());\n+        assert_eq!(\"666F6F626172\".from_hex().unwrap().as_slice(),\n+                   \"foobar\".as_bytes());\n     }\n \n     #[test]\n@@ -169,8 +168,8 @@ mod tests {\n \n     #[test]\n     pub fn test_from_hex_ignores_whitespace() {\n-        assert_eq!(\"666f 6f6\\r\\n26172 \".from_hex().unwrap(),\n-                   \"foobar\".as_bytes().to_owned());\n+        assert_eq!(\"666f 6f6\\r\\n26172 \".from_hex().unwrap().as_slice(),\n+                   \"foobar\".as_bytes());\n     }\n \n     #[test]\n@@ -183,8 +182,8 @@ mod tests {\n     #[test]\n     pub fn test_from_hex_all_bytes() {\n         for i in range(0, 256) {\n-            assert_eq!(format!(\"{:02x}\", i as uint).from_hex().unwrap(), ~[i as u8]);\n-            assert_eq!(format!(\"{:02X}\", i as uint).from_hex().unwrap(), ~[i as u8]);\n+            assert_eq!(format!(\"{:02x}\", i as uint).from_hex().unwrap().as_slice(), &[i as u8]);\n+            assert_eq!(format!(\"{:02X}\", i as uint).from_hex().unwrap().as_slice(), &[i as u8]);\n         }\n     }\n "}, {"sha": "56c0349d9eb8731ade32f15e329d27b3a6794a42", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 38, "deletions": 38, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/cd3f31d9d13652c62795a985d91f7c6c6673b7a8/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd3f31d9d13652c62795a985d91f7c6c6673b7a8/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=cd3f31d9d13652c62795a985d91f7c6c6673b7a8", "patch": "@@ -258,7 +258,7 @@ pub enum Json {\n     Null,\n }\n \n-pub type List = ~[Json];\n+pub type List = Vec<Json>;\n pub type Object = TreeMap<~str, Json>;\n \n /// The errors that can arise while parsing a JSON stream.\n@@ -2211,7 +2211,7 @@ impl<A:ToJson,B:ToJson> ToJson for (A, B) {\n     fn to_json(&self) -> Json {\n         match *self {\n           (ref a, ref b) => {\n-            List(box [a.to_json(), b.to_json()])\n+            List(vec![a.to_json(), b.to_json()])\n           }\n         }\n     }\n@@ -2221,7 +2221,7 @@ impl<A:ToJson,B:ToJson,C:ToJson> ToJson for (A, B, C) {\n     fn to_json(&self) -> Json {\n         match *self {\n           (ref a, ref b, ref c) => {\n-            List(box [a.to_json(), b.to_json(), c.to_json()])\n+            List(vec![a.to_json(), b.to_json(), c.to_json()])\n           }\n         }\n     }\n@@ -2298,12 +2298,12 @@ mod tests {\n     struct Inner {\n         a: (),\n         b: uint,\n-        c: ~[~str],\n+        c: Vec<~str>,\n     }\n \n     #[deriving(Eq, Encodable, Decodable, Show)]\n     struct Outer {\n-        inner: ~[Inner],\n+        inner: Vec<Inner>,\n     }\n \n     fn mk_object(items: &[(~str, Json)]) -> Json {\n@@ -2360,22 +2360,22 @@ mod tests {\n \n     #[test]\n     fn test_write_list() {\n-        assert_eq!(List(~[]).to_str(), \"[]\".to_owned());\n-        assert_eq!(List(~[]).to_pretty_str(), \"[]\".to_owned());\n+        assert_eq!(List(vec![]).to_str(), \"[]\".to_owned());\n+        assert_eq!(List(vec![]).to_pretty_str(), \"[]\".to_owned());\n \n-        assert_eq!(List(~[Boolean(true)]).to_str(), \"[true]\".to_owned());\n+        assert_eq!(List(vec![Boolean(true)]).to_str(), \"[true]\".to_owned());\n         assert_eq!(\n-            List(~[Boolean(true)]).to_pretty_str(),\n+            List(vec![Boolean(true)]).to_pretty_str(),\n             \"\\\n             [\\n  \\\n                 true\\n\\\n             ]\".to_owned()\n         );\n \n-        let long_test_list = List(box [\n+        let long_test_list = List(vec![\n             Boolean(false),\n             Null,\n-            List(box [String(\"foo\\nbar\".to_owned()), Number(3.5)])]);\n+            List(vec![String(\"foo\\nbar\".to_owned()), Number(3.5)])]);\n \n         assert_eq!(long_test_list.to_str(),\n             \"[false,null,[\\\"foo\\\\nbar\\\",3.5]]\".to_owned());\n@@ -2411,7 +2411,7 @@ mod tests {\n         );\n \n         let complex_obj = mk_object([\n-                (\"b\".to_owned(), List(box [\n+                (\"b\".to_owned(), List(vec![\n                     mk_object([(\"c\".to_owned(), String(\"\\x0c\\r\".to_owned()))]),\n                     mk_object([(\"d\".to_owned(), String(\"\".to_owned()))])\n                 ]))\n@@ -2443,7 +2443,7 @@ mod tests {\n \n         let a = mk_object([\n             (\"a\".to_owned(), Boolean(true)),\n-            (\"b\".to_owned(), List(box [\n+            (\"b\".to_owned(), List(vec![\n                 mk_object([(\"c\".to_owned(), String(\"\\x0c\\r\".to_owned()))]),\n                 mk_object([(\"d\".to_owned(), String(\"\".to_owned()))])\n             ]))\n@@ -2678,44 +2678,44 @@ mod tests {\n         assert_eq!(from_str(\"[1,]\"),  Err(SyntaxError(InvalidSyntax,        1, 4)));\n         assert_eq!(from_str(\"[6 7]\"), Err(SyntaxError(InvalidSyntax,        1, 4)));\n \n-        assert_eq!(from_str(\"[]\"), Ok(List(~[])));\n-        assert_eq!(from_str(\"[ ]\"), Ok(List(~[])));\n-        assert_eq!(from_str(\"[true]\"), Ok(List(~[Boolean(true)])));\n-        assert_eq!(from_str(\"[ false ]\"), Ok(List(~[Boolean(false)])));\n-        assert_eq!(from_str(\"[null]\"), Ok(List(~[Null])));\n+        assert_eq!(from_str(\"[]\"), Ok(List(vec![])));\n+        assert_eq!(from_str(\"[ ]\"), Ok(List(vec![])));\n+        assert_eq!(from_str(\"[true]\"), Ok(List(vec![Boolean(true)])));\n+        assert_eq!(from_str(\"[ false ]\"), Ok(List(vec![Boolean(false)])));\n+        assert_eq!(from_str(\"[null]\"), Ok(List(vec![Null])));\n         assert_eq!(from_str(\"[3, 1]\"),\n-                     Ok(List(~[Number(3.0), Number(1.0)])));\n+                     Ok(List(vec![Number(3.0), Number(1.0)])));\n         assert_eq!(from_str(\"\\n[3, 2]\\n\"),\n-                     Ok(List(~[Number(3.0), Number(2.0)])));\n+                     Ok(List(vec![Number(3.0), Number(2.0)])));\n         assert_eq!(from_str(\"[2, [4, 1]]\"),\n-               Ok(List(~[Number(2.0), List(~[Number(4.0), Number(1.0)])])));\n+               Ok(List(vec![Number(2.0), List(vec![Number(4.0), Number(1.0)])])));\n     }\n \n     #[test]\n     fn test_decode_list() {\n         let mut decoder = Decoder::new(from_str(\"[]\").unwrap());\n-        let v: ~[()] = Decodable::decode(&mut decoder).unwrap();\n-        assert_eq!(v, ~[]);\n+        let v: Vec<()> = Decodable::decode(&mut decoder).unwrap();\n+        assert_eq!(v, vec![]);\n \n         let mut decoder = Decoder::new(from_str(\"[null]\").unwrap());\n-        let v: ~[()] = Decodable::decode(&mut decoder).unwrap();\n-        assert_eq!(v, ~[()]);\n+        let v: Vec<()> = Decodable::decode(&mut decoder).unwrap();\n+        assert_eq!(v, vec![()]);\n \n         let mut decoder = Decoder::new(from_str(\"[true]\").unwrap());\n-        let v: ~[bool] = Decodable::decode(&mut decoder).unwrap();\n-        assert_eq!(v, ~[true]);\n+        let v: Vec<bool> = Decodable::decode(&mut decoder).unwrap();\n+        assert_eq!(v, vec![true]);\n \n         let mut decoder = Decoder::new(from_str(\"[true]\").unwrap());\n-        let v: ~[bool] = Decodable::decode(&mut decoder).unwrap();\n-        assert_eq!(v, ~[true]);\n+        let v: Vec<bool> = Decodable::decode(&mut decoder).unwrap();\n+        assert_eq!(v, vec![true]);\n \n         let mut decoder = Decoder::new(from_str(\"[3, 1]\").unwrap());\n-        let v: ~[int] = Decodable::decode(&mut decoder).unwrap();\n-        assert_eq!(v, ~[3, 1]);\n+        let v: Vec<int> = Decodable::decode(&mut decoder).unwrap();\n+        assert_eq!(v, vec![3, 1]);\n \n         let mut decoder = Decoder::new(from_str(\"[[3], [1, 2]]\").unwrap());\n-        let v: ~[~[uint]] = Decodable::decode(&mut decoder).unwrap();\n-        assert_eq!(v, ~[~[3], ~[1, 2]]);\n+        let v: Vec<Vec<uint>> = Decodable::decode(&mut decoder).unwrap();\n+        assert_eq!(v, vec![vec![3], vec![1, 2]]);\n     }\n \n     #[test]\n@@ -2750,7 +2750,7 @@ mod tests {\n                       \"{\\\"a\\\" : 1.0 ,\\\"b\\\": [ true ]}\").unwrap(),\n                   mk_object([\n                       (\"a\".to_owned(), Number(1.0)),\n-                      (\"b\".to_owned(), List(~[Boolean(true)]))\n+                      (\"b\".to_owned(), List(vec![Boolean(true)]))\n                   ]));\n         assert_eq!(from_str(\n                       \"{\".to_owned() +\n@@ -2763,7 +2763,7 @@ mod tests {\n                       \"}\").unwrap(),\n                   mk_object([\n                       (\"a\".to_owned(), Number(1.0)),\n-                      (\"b\".to_owned(), List(~[\n+                      (\"b\".to_owned(), List(vec![\n                           Boolean(true),\n                           String(\"foo\\nbar\".to_owned()),\n                           mk_object([\n@@ -2785,8 +2785,8 @@ mod tests {\n         assert_eq!(\n             v,\n             Outer {\n-                inner: ~[\n-                    Inner { a: (), b: 2, c: ~[\"abc\".to_owned(), \"xyz\".to_owned()] }\n+                inner: vec![\n+                    Inner { a: (), b: 2, c: vec![\"abc\".to_owned(), \"xyz\".to_owned()] }\n                 ]\n             }\n         );\n@@ -2837,7 +2837,7 @@ mod tests {\n         x: f64,\n         y: bool,\n         z: ~str,\n-        w: ~[DecodeStruct]\n+        w: Vec<DecodeStruct>\n     }\n     #[deriving(Decodable)]\n     enum DecodeEnum {"}, {"sha": "90385d7cce9a463730405b685c11e2be1e4f8036", "filename": "src/libserialize/serialize.rs", "status": "modified", "additions": 5, "deletions": 18, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/cd3f31d9d13652c62795a985d91f7c6c6673b7a8/src%2Flibserialize%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd3f31d9d13652c62795a985d91f7c6c6673b7a8/src%2Flibserialize%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fserialize.rs?ref=cd3f31d9d13652c62795a985d91f7c6c6673b7a8", "patch": "@@ -451,19 +451,6 @@ impl<E, S:Encoder<E>,T:Encodable<S, E>> Encodable<S, E> for ~[T] {\n     }\n }\n \n-impl<E, D:Decoder<E>,T:Decodable<D, E>> Decodable<D, E> for ~[T] {\n-    fn decode(d: &mut D) -> Result<~[T], E> {\n-        d.read_seq(|d, len| {\n-            let mut v: Vec<T> = Vec::with_capacity(len);\n-            for i in range(0, len) {\n-                v.push(try!(d.read_seq_elt(i, |d| Decodable::decode(d))));\n-            }\n-            let k = v.move_iter().collect::<~[T]>();\n-            Ok(k)\n-        })\n-    }\n-}\n-\n impl<E, S:Encoder<E>,T:Encodable<S, E>> Encodable<S, E> for Vec<T> {\n     fn encode(&self, s: &mut S) -> Result<(), E> {\n         s.emit_seq(self.len(), |s| {\n@@ -557,7 +544,7 @@ impl<E, S: Encoder<E>> Encodable<S, E> for path::posix::Path {\n \n impl<E, D: Decoder<E>> Decodable<D, E> for path::posix::Path {\n     fn decode(d: &mut D) -> Result<path::posix::Path, E> {\n-        let bytes: ~[u8] = try!(Decodable::decode(d));\n+        let bytes: Vec<u8> = try!(Decodable::decode(d));\n         Ok(path::posix::Path::new(bytes))\n     }\n }\n@@ -570,7 +557,7 @@ impl<E, S: Encoder<E>> Encodable<S, E> for path::windows::Path {\n \n impl<E, D: Decoder<E>> Decodable<D, E> for path::windows::Path {\n     fn decode(d: &mut D) -> Result<path::windows::Path, E> {\n-        let bytes: ~[u8] = try!(Decodable::decode(d));\n+        let bytes: Vec<u8> = try!(Decodable::decode(d));\n         Ok(path::windows::Path::new(bytes))\n     }\n }\n@@ -600,17 +587,17 @@ impl<E, S:Encoder<E>> EncoderHelpers<E> for S {\n }\n \n pub trait DecoderHelpers<E> {\n-    fn read_to_vec<T>(&mut self, f: |&mut Self| -> Result<T, E>) -> Result<~[T], E>;\n+    fn read_to_vec<T>(&mut self, f: |&mut Self| -> Result<T, E>) -> Result<Vec<T>, E>;\n }\n \n impl<E, D:Decoder<E>> DecoderHelpers<E> for D {\n-    fn read_to_vec<T>(&mut self, f: |&mut D| -> Result<T, E>) -> Result<~[T], E> {\n+    fn read_to_vec<T>(&mut self, f: |&mut D| -> Result<T, E>) -> Result<Vec<T>, E> {\n         self.read_seq(|this, len| {\n             let mut v = Vec::with_capacity(len);\n             for i in range(0, len) {\n                 v.push(try!(this.read_seq_elt(i, |this| f(this))));\n             }\n-            Ok(v.move_iter().collect())\n+            Ok(v)\n         })\n     }\n }"}]}