{"sha": "afe106cdc8b5dbcbeedb292b87dc7d7ae58964f1", "node_id": "C_kwDOAAsO6NoAKGFmZTEwNmNkYzhiNWRiY2JlZWRiMjkyYjg3ZGM3ZDdhZTU4OTY0ZjE", "commit": {"author": {"name": "The 8472", "email": "git@infinite-source.de", "date": "2023-04-19T20:14:28Z"}, "committer": {"name": "The 8472", "email": "git@infinite-source.de", "date": "2023-04-28T21:08:54Z"}, "message": "[review] add comments, turn flag into enum", "tree": {"sha": "fc94a9f14c3f2592206e9d4bfea5a5a8e52a64be", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fc94a9f14c3f2592206e9d4bfea5a5a8e52a64be"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/afe106cdc8b5dbcbeedb292b87dc7d7ae58964f1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/afe106cdc8b5dbcbeedb292b87dc7d7ae58964f1", "html_url": "https://github.com/rust-lang/rust/commit/afe106cdc8b5dbcbeedb292b87dc7d7ae58964f1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/afe106cdc8b5dbcbeedb292b87dc7d7ae58964f1/comments", "author": {"login": "the8472", "id": 1065730, "node_id": "MDQ6VXNlcjEwNjU3MzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1065730?v=4", "gravatar_id": "", "url": "https://api.github.com/users/the8472", "html_url": "https://github.com/the8472", "followers_url": "https://api.github.com/users/the8472/followers", "following_url": "https://api.github.com/users/the8472/following{/other_user}", "gists_url": "https://api.github.com/users/the8472/gists{/gist_id}", "starred_url": "https://api.github.com/users/the8472/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/the8472/subscriptions", "organizations_url": "https://api.github.com/users/the8472/orgs", "repos_url": "https://api.github.com/users/the8472/repos", "events_url": "https://api.github.com/users/the8472/events{/privacy}", "received_events_url": "https://api.github.com/users/the8472/received_events", "type": "User", "site_admin": false}, "committer": {"login": "the8472", "id": 1065730, "node_id": "MDQ6VXNlcjEwNjU3MzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1065730?v=4", "gravatar_id": "", "url": "https://api.github.com/users/the8472", "html_url": "https://github.com/the8472", "followers_url": "https://api.github.com/users/the8472/followers", "following_url": "https://api.github.com/users/the8472/following{/other_user}", "gists_url": "https://api.github.com/users/the8472/gists{/gist_id}", "starred_url": "https://api.github.com/users/the8472/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/the8472/subscriptions", "organizations_url": "https://api.github.com/users/the8472/orgs", "repos_url": "https://api.github.com/users/the8472/repos", "events_url": "https://api.github.com/users/the8472/events{/privacy}", "received_events_url": "https://api.github.com/users/the8472/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "67a835d755a97770edb320d315d542859b11f854", "url": "https://api.github.com/repos/rust-lang/rust/commits/67a835d755a97770edb320d315d542859b11f854", "html_url": "https://github.com/rust-lang/rust/commit/67a835d755a97770edb320d315d542859b11f854"}], "stats": {"total": 67, "additions": 44, "deletions": 23}, "files": [{"sha": "a49c9e5829788bf007496aabd40e00a6912c6c9e", "filename": "compiler/rustc_abi/src/layout.rs", "status": "modified", "additions": 44, "deletions": 23, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/afe106cdc8b5dbcbeedb292b87dc7d7ae58964f1/compiler%2Frustc_abi%2Fsrc%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/afe106cdc8b5dbcbeedb292b87dc7d7ae58964f1/compiler%2Frustc_abi%2Fsrc%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_abi%2Fsrc%2Flayout.rs?ref=afe106cdc8b5dbcbeedb292b87dc7d7ae58964f1", "patch": "@@ -50,7 +50,7 @@ pub trait LayoutCalculator {\n         repr: &ReprOptions,\n         kind: StructKind,\n     ) -> Option<LayoutS> {\n-        let layout = univariant(self, dl, fields, repr, kind, true);\n+        let layout = univariant(self, dl, fields, repr, kind, NicheBias::Start);\n         // Enums prefer niches close to the beginning or the end of the variants so that other (smaller)\n         // data-carrying variants can be packed into the space after/before the niche.\n         // If the default field ordering does not give us a niche at the front then we do a second\n@@ -66,7 +66,7 @@ pub trait LayoutCalculator {\n                 // (e.g. a trailing bool) and there is tail padding. But it's non-trivial to get\n                 // the unpadded size so we try anyway.\n                 if fields.len() > 1 && head_space != 0 && tail_space > 0 {\n-                    let alt_layout = univariant(self, dl, fields, repr, kind, false)\n+                    let alt_layout = univariant(self, dl, fields, repr, kind, NicheBias::End)\n                         .expect(\"alt layout should always work\");\n                     let niche = alt_layout\n                         .largest_niche\n@@ -776,13 +776,19 @@ pub trait LayoutCalculator {\n     }\n }\n \n+/// Determines towards which end of a struct layout optimizations will try to place the best niches.\n+enum NicheBias {\n+    Start,\n+    End,\n+}\n+\n fn univariant(\n     this: &(impl LayoutCalculator + ?Sized),\n     dl: &TargetDataLayout,\n     fields: &IndexSlice<FieldIdx, Layout<'_>>,\n     repr: &ReprOptions,\n     kind: StructKind,\n-    niche_bias_start: bool,\n+    niche_bias: NicheBias,\n ) -> Option<LayoutS> {\n     let pack = repr.pack;\n     let mut align = if pack.is_some() { dl.i8_align } else { dl.aggregate_align };\n@@ -809,7 +815,10 @@ fn univariant(\n         } else {\n             let max_field_align = fields.iter().map(|f| f.align().abi.bytes()).max().unwrap_or(1);\n             let any_niche = fields.iter().any(|f| f.largest_niche().is_some());\n-            let effective_field_align = |layout: Layout<'_>| {\n+\n+            // Calculates a sort key to group fields by their alignment or possibly some size-derived\n+            // pseudo-alignment.\n+            let alignment_group_key = |layout: Layout<'_>| {\n                 if let Some(pack) = pack {\n                     // return the packed alignment in bytes\n                     layout.align().abi.min(pack).bytes()\n@@ -818,10 +827,13 @@ fn univariant(\n                     // This is ok since `pack` applies to all fields equally.\n                     // The calculation assumes that size is an integer multiple of align, except for ZSTs.\n                     //\n-                    // group [u8; 4] with align-4 or [u8; 6] with align-2 fields\n                     let align = layout.align().abi.bytes();\n                     let size = layout.size().bytes();\n+                    // group [u8; 4] with align-4 or [u8; 6] with align-2 fields\n                     let size_as_align = align.max(size).trailing_zeros();\n+                    // Given `A(u8, [u8; 16])` and `B(bool, [u8; 16])` we want to bump the array\n+                    // to the front in the first case (for aligned loads) but keep the bool in front\n+                    // in the second case for its niches.\n                     let size_as_align = if any_niche {\n                         max_field_align.trailing_zeros().min(size_as_align)\n                     } else {\n@@ -833,35 +845,43 @@ fn univariant(\n \n             match kind {\n                 StructKind::AlwaysSized | StructKind::MaybeUnsized => {\n+                    // Currently `LayoutS` only exposes a single niche so sorting is usually sufficient\n+                    // to get one niche into the preferred position. If it ever supported multiple niches\n+                    // then a more advanced pick-and-pack approach could provide better results.\n+                    // But even for the single-niche cache it's not optimal. E.g. for\n+                    // A(u32, (bool, u8), u16) it would be possible to move the bool to the front\n+                    // but it would require packing the tuple together with the u16 to build a 4-byte\n+                    // group so that the u32 can be placed after it without padding. This kind\n+                    // of packing can't be achieved by sorting.\n                     optimizing.sort_by_key(|&x| {\n                         let f = fields[x];\n                         let field_size = f.size().bytes();\n                         let niche_size = f.largest_niche().map_or(0, |n| n.available(dl));\n-                        let niche_size = if niche_bias_start {\n-                            u128::MAX - niche_size // large niche first\n-                        } else {\n-                            niche_size // large niche last\n+                        let niche_size_key = match niche_bias {\n+                            // large niche first\n+                            NicheBias::Start => !niche_size,\n+                            // large niche last\n+                            NicheBias::End => niche_size,\n                         };\n-                        let inner_niche_placement = if niche_bias_start {\n-                            f.largest_niche().map_or(0, |n| n.offset.bytes())\n-                        } else {\n-                            f.largest_niche().map_or(0, |n| {\n-                                field_size - n.value.size(dl).bytes() - n.offset.bytes()\n-                            })\n+                        let inner_niche_offset_key = match niche_bias {\n+                            NicheBias::Start => f.largest_niche().map_or(0, |n| n.offset.bytes()),\n+                            NicheBias::End => f.largest_niche().map_or(0, |n| {\n+                                !(field_size - n.value.size(dl).bytes() - n.offset.bytes())\n+                            }),\n                         };\n \n                         (\n                             // Place ZSTs first to avoid \"interesting offsets\", especially with only one\n                             // or two non-ZST fields. This helps Scalar/ScalarPair layouts.\n                             !f.0.is_zst(),\n                             // Then place largest alignments first.\n-                            cmp::Reverse(effective_field_align(f)),\n+                            cmp::Reverse(alignment_group_key(f)),\n                             // Then prioritize niche placement within alignment group according to\n                             // `niche_bias_start`.\n-                            niche_size,\n+                            niche_size_key,\n                             // Then among fields with equally-sized niches prefer the ones\n                             // closer to the start/end of the field.\n-                            inner_niche_placement,\n+                            inner_niche_offset_key,\n                         )\n                     });\n                 }\n@@ -874,7 +894,7 @@ fn univariant(\n                     optimizing.sort_by_key(|&x| {\n                         let f = fields[x];\n                         let niche_size = f.largest_niche().map_or(0, |n| n.available(dl));\n-                        (effective_field_align(f), niche_size)\n+                        (alignment_group_key(f), niche_size)\n                     });\n                 }\n             }\n@@ -927,10 +947,11 @@ fn univariant(\n \n         if let Some(mut niche) = field.largest_niche() {\n             let available = niche.available(dl);\n-            let prefer_new_niche = if niche_bias_start {\n-                available > largest_niche_available\n-            } else {\n-                available >= largest_niche_available\n+            // Pick up larger niches.\n+            let prefer_new_niche = match niche_bias {\n+                NicheBias::Start => available > largest_niche_available,\n+                // if there are several niches of the same size then pick the last one\n+                NicheBias::End => available >= largest_niche_available,\n             };\n             if prefer_new_niche {\n                 largest_niche_available = available;"}]}