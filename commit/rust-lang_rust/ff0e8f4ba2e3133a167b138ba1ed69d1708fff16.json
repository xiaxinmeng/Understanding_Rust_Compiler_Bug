{"sha": "ff0e8f4ba2e3133a167b138ba1ed69d1708fff16", "node_id": "C_kwDOAAsO6NoAKGZmMGU4ZjRiYTJlMzEzM2ExNjdiMTM4YmExZWQ2OWQxNzA4ZmZmMTY", "commit": {"author": {"name": "Eric Holk", "email": "ericholk@microsoft.com", "date": "2021-11-11T01:32:04Z"}, "committer": {"name": "Eric Holk", "email": "ericholk@microsoft.com", "date": "2022-01-18T22:25:26Z"}, "message": "Revamped DropRange data structure\n\nNot currently working. Need to flow drop information.", "tree": {"sha": "0ca1c70c4906f6224b6b5d7ff77f96b32dd1dce5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0ca1c70c4906f6224b6b5d7ff77f96b32dd1dce5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ff0e8f4ba2e3133a167b138ba1ed69d1708fff16", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ff0e8f4ba2e3133a167b138ba1ed69d1708fff16", "html_url": "https://github.com/rust-lang/rust/commit/ff0e8f4ba2e3133a167b138ba1ed69d1708fff16", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ff0e8f4ba2e3133a167b138ba1ed69d1708fff16/comments", "author": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ba7d12731eb23154ea42feecec172bbef73fd865", "url": "https://api.github.com/repos/rust-lang/rust/commits/ba7d12731eb23154ea42feecec172bbef73fd865", "html_url": "https://github.com/rust-lang/rust/commit/ba7d12731eb23154ea42feecec172bbef73fd865"}], "stats": {"total": 565, "additions": 273, "deletions": 292}, "files": [{"sha": "b46696dde7cf4adaab66dbecc59474fa5006fb6c", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff0e8f4ba2e3133a167b138ba1ed69d1708fff16/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/ff0e8f4ba2e3133a167b138ba1ed69d1708fff16/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=ff0e8f4ba2e3133a167b138ba1ed69d1708fff16", "patch": "@@ -4383,7 +4383,6 @@ dependencies = [\n name = \"rustc_typeck\"\n version = \"0.0.0\"\n dependencies = [\n- \"itertools 0.9.0\",\n  \"rustc_arena\",\n  \"rustc_ast\",\n  \"rustc_attr\",\n@@ -4396,6 +4395,7 @@ dependencies = [\n  \"rustc_lint\",\n  \"rustc_macros\",\n  \"rustc_middle\",\n+ \"rustc_serialize\",\n  \"rustc_session\",\n  \"rustc_span\",\n  \"rustc_target\","}, {"sha": "3279c331ade18b4e007ca3b12a01d607142aa48b", "filename": "compiler/rustc_typeck/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff0e8f4ba2e3133a167b138ba1ed69d1708fff16/compiler%2Frustc_typeck%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/ff0e8f4ba2e3133a167b138ba1ed69d1708fff16/compiler%2Frustc_typeck%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2FCargo.toml?ref=ff0e8f4ba2e3133a167b138ba1ed69d1708fff16", "patch": "@@ -8,7 +8,6 @@ test = false\n doctest = false\n \n [dependencies]\n-itertools = \"0.9\"\n rustc_arena = { path = \"../rustc_arena\" }\n tracing = \"0.1\"\n rustc_macros = { path = \"../rustc_macros\" }\n@@ -28,3 +27,4 @@ rustc_infer = { path = \"../rustc_infer\" }\n rustc_trait_selection = { path = \"../rustc_trait_selection\" }\n rustc_ty_utils = { path = \"../rustc_ty_utils\" }\n rustc_lint = { path = \"../rustc_lint\" }\n+rustc_serialize = { path = \"../rustc_serialize\" }"}, {"sha": "33533ab6189f0d5f3bdd3ead9cf0739f4de88a27", "filename": "compiler/rustc_typeck/src/check/generator_interior.rs", "status": "modified", "additions": 98, "deletions": 290, "changes": 388, "blob_url": "https://github.com/rust-lang/rust/blob/ff0e8f4ba2e3133a167b138ba1ed69d1708fff16/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff0e8f4ba2e3133a167b138ba1ed69d1708fff16/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior.rs?ref=ff0e8f4ba2e3133a167b138ba1ed69d1708fff16", "patch": "@@ -3,13 +3,12 @@\n //! is calculated in `rustc_const_eval::transform::generator` and may be a subset of the\n //! types computed here.\n \n-use std::mem;\n-\n use crate::expr_use_visitor::{self, ExprUseVisitor};\n \n+use self::drop_ranges::DropRanges;\n+\n use super::FnCtxt;\n use hir::{HirIdMap, Node};\n-use itertools::Itertools;\n use rustc_data_structures::fx::{FxHashSet, FxIndexSet};\n use rustc_errors::pluralize;\n use rustc_hir as hir;\n@@ -30,6 +29,8 @@ use tracing::debug;\n #[cfg(test)]\n mod tests;\n \n+mod drop_ranges;\n+\n struct InteriorVisitor<'a, 'tcx> {\n     fcx: &'a FnCtxt<'a, 'tcx>,\n     types: FxIndexSet<ty::GeneratorInteriorTypeCause<'tcx>>,\n@@ -45,7 +46,7 @@ struct InteriorVisitor<'a, 'tcx> {\n     guard_bindings: SmallVec<[SmallVec<[HirId; 4]>; 1]>,\n     guard_bindings_set: HirIdSet,\n     linted_values: HirIdSet,\n-    drop_ranges: HirIdMap<DropRange>,\n+    drop_ranges: DropRanges,\n }\n \n impl<'a, 'tcx> InteriorVisitor<'a, 'tcx> {\n@@ -85,14 +86,10 @@ impl<'a, 'tcx> InteriorVisitor<'a, 'tcx> {\n                                 yield_data.expr_and_pat_count, self.expr_count, source_span\n                             );\n \n-                            match self.drop_ranges.get(&hir_id) {\n-                                Some(range)\n-                                    if range.is_dropped_at(yield_data.expr_and_pat_count) =>\n-                                {\n-                                    debug!(\"value is dropped at yield point; not recording\");\n-                                    return false;\n-                                }\n-                                _ => (),\n+                            if self.drop_ranges.is_dropped_at(hir_id, yield_data.expr_and_pat_count)\n+                            {\n+                                debug!(\"value is dropped at yield point; not recording\");\n+                                return false;\n                             }\n \n                             // If it is a borrowing happening in the guard,\n@@ -233,25 +230,27 @@ pub fn resolve_interior<'a, 'tcx>(\n     let body = fcx.tcx.hir().body(body_id);\n \n     let mut visitor = {\n-        let mut drop_range_visitor = DropRangeVisitor {\n+        let mut expr_use_visitor = ExprUseDelegate {\n             hir: fcx.tcx.hir(),\n             consumed_places: <_>::default(),\n             borrowed_places: <_>::default(),\n-            drop_ranges: <_>::default(),\n-            expr_count: 0,\n         };\n \n         // Run ExprUseVisitor to find where values are consumed.\n         ExprUseVisitor::new(\n-            &mut drop_range_visitor,\n+            &mut expr_use_visitor,\n             &fcx.infcx,\n             def_id.expect_local(),\n             fcx.param_env,\n             &fcx.typeck_results.borrow(),\n         )\n         .consume_body(body);\n+\n+        let mut drop_range_visitor = DropRangeVisitor::from(expr_use_visitor);\n         intravisit::walk_body(&mut drop_range_visitor, body);\n \n+        drop_range_visitor.drop_ranges.propagate_to_fixpoint();\n+\n         InteriorVisitor {\n             fcx,\n             types: FxIndexSet::default(),\n@@ -673,29 +672,46 @@ fn check_must_not_suspend_def(\n     false\n }\n \n-/// This struct facilitates computing the ranges for which a place is uninitialized.\n-struct DropRangeVisitor<'tcx> {\n+struct ExprUseDelegate<'tcx> {\n     hir: Map<'tcx>,\n     /// Maps a HirId to a set of HirIds that are dropped by that node.\n     consumed_places: HirIdMap<HirIdSet>,\n     borrowed_places: HirIdSet,\n-    drop_ranges: HirIdMap<DropRange>,\n-    expr_count: usize,\n }\n \n-impl DropRangeVisitor<'tcx> {\n+impl<'tcx> ExprUseDelegate<'tcx> {\n     fn mark_consumed(&mut self, consumer: HirId, target: HirId) {\n         if !self.consumed_places.contains_key(&consumer) {\n             self.consumed_places.insert(consumer, <_>::default());\n         }\n         self.consumed_places.get_mut(&consumer).map(|places| places.insert(target));\n     }\n+}\n \n-    fn drop_range(&mut self, hir_id: &HirId) -> &mut DropRange {\n-        if !self.drop_ranges.contains_key(hir_id) {\n-            self.drop_ranges.insert(*hir_id, DropRange::empty());\n+/// This struct facilitates computing the ranges for which a place is uninitialized.\n+struct DropRangeVisitor<'tcx> {\n+    hir: Map<'tcx>,\n+    /// Maps a HirId to a set of HirIds that are dropped by that node.\n+    consumed_places: HirIdMap<HirIdSet>,\n+    borrowed_places: HirIdSet,\n+    drop_ranges: DropRanges,\n+    expr_count: usize,\n+}\n+\n+impl<'tcx> DropRangeVisitor<'tcx> {\n+    fn from(uses: ExprUseDelegate<'tcx>) -> Self {\n+        debug!(\"consumed_places: {:?}\", uses.consumed_places);\n+        let drop_ranges = DropRanges::new(\n+            uses.consumed_places.iter().flat_map(|(_, places)| places.iter().copied()),\n+            &uses.hir,\n+        );\n+        Self {\n+            hir: uses.hir,\n+            consumed_places: uses.consumed_places,\n+            borrowed_places: uses.borrowed_places,\n+            drop_ranges,\n+            expr_count: 0,\n         }\n-        self.drop_ranges.get_mut(hir_id).unwrap()\n     }\n \n     fn record_drop(&mut self, hir_id: HirId) {\n@@ -704,41 +720,10 @@ impl DropRangeVisitor<'tcx> {\n         } else {\n             debug!(\"marking {:?} as dropped at {}\", hir_id, self.expr_count);\n             let count = self.expr_count;\n-            self.drop_range(&hir_id).drop(count);\n+            self.drop_ranges.drop_at(hir_id, count);\n         }\n     }\n \n-    fn swap_drop_ranges(&mut self, mut other: HirIdMap<DropRange>) -> HirIdMap<DropRange> {\n-        mem::swap(&mut self.drop_ranges, &mut other);\n-        other\n-    }\n-\n-    fn fork_drop_ranges(&self) -> HirIdMap<DropRange> {\n-        self.drop_ranges.iter().map(|(k, v)| (*k, v.fork_at(self.expr_count))).collect()\n-    }\n-\n-    fn intersect_drop_ranges(&mut self, drops: HirIdMap<DropRange>) {\n-        drops.into_iter().for_each(|(k, v)| match self.drop_ranges.get_mut(&k) {\n-            Some(ranges) => *ranges = ranges.intersect(&v),\n-            None => {\n-                self.drop_ranges.insert(k, v);\n-            }\n-        })\n-    }\n-\n-    fn merge_drop_ranges_at(&mut self, drops: HirIdMap<DropRange>, join_point: usize) {\n-        drops.into_iter().for_each(|(k, v)| {\n-            if !self.drop_ranges.contains_key(&k) {\n-                self.drop_ranges.insert(k, DropRange { events: vec![] });\n-            }\n-            self.drop_ranges.get_mut(&k).unwrap().merge_with(&v, join_point);\n-        });\n-    }\n-\n-    fn merge_drop_ranges(&mut self, drops: HirIdMap<DropRange>) {\n-        self.merge_drop_ranges_at(drops, self.expr_count);\n-    }\n-\n     /// ExprUseVisitor's consume callback doesn't go deep enough for our purposes in all\n     /// expressions. This method consumes a little deeper into the expression when needed.\n     fn consume_expr(&mut self, expr: &hir::Expr<'_>) {\n@@ -748,18 +733,7 @@ impl DropRangeVisitor<'tcx> {\n             .get(&expr.hir_id)\n             .map_or(vec![], |places| places.iter().cloned().collect());\n         for place in places {\n-            self.record_drop(place);\n-            if let Some(Node::Expr(expr)) = self.hir.find(place) {\n-                match expr.kind {\n-                    hir::ExprKind::Path(hir::QPath::Resolved(\n-                        _,\n-                        hir::Path { res: hir::def::Res::Local(hir_id), .. },\n-                    )) => {\n-                        self.record_drop(*hir_id);\n-                    }\n-                    _ => (),\n-                }\n-            }\n+            for_each_consumable(place, self.hir.find(place), |hir_id| self.record_drop(hir_id));\n         }\n     }\n \n@@ -771,13 +745,28 @@ impl DropRangeVisitor<'tcx> {\n         {\n             let location = self.expr_count;\n             debug!(\"reinitializing {:?} at {}\", hir_id, location);\n-            self.drop_range(hir_id).reinit(location)\n+            self.drop_ranges.reinit_at(*hir_id, location);\n         } else {\n             debug!(\"reinitializing {:?} is not supported\", expr);\n         }\n     }\n }\n \n+fn for_each_consumable(place: HirId, node: Option<Node<'_>>, mut f: impl FnMut(HirId)) {\n+    f(place);\n+    if let Some(Node::Expr(expr)) = node {\n+        match expr.kind {\n+            hir::ExprKind::Path(hir::QPath::Resolved(\n+                _,\n+                hir::Path { res: hir::def::Res::Local(hir_id), .. },\n+            )) => {\n+                f(*hir_id);\n+            }\n+            _ => (),\n+        }\n+    }\n+}\n+\n fn place_hir_id(place: &Place<'_>) -> Option<HirId> {\n     match place.base {\n         PlaceBase::Rvalue | PlaceBase::StaticItem => None,\n@@ -786,7 +775,7 @@ fn place_hir_id(place: &Place<'_>) -> Option<HirId> {\n     }\n }\n \n-impl<'tcx> expr_use_visitor::Delegate<'tcx> for DropRangeVisitor<'tcx> {\n+impl<'tcx> expr_use_visitor::Delegate<'tcx> for ExprUseDelegate<'tcx> {\n     fn consume(\n         &mut self,\n         place_with_id: &expr_use_visitor::PlaceWithHirId<'tcx>,\n@@ -839,58 +828,41 @@ impl<'tcx> Visitor<'tcx> for DropRangeVisitor<'tcx> {\n     fn visit_expr(&mut self, expr: &'tcx Expr<'tcx>) {\n         let mut reinit = None;\n         match expr.kind {\n-            ExprKind::AssignOp(_op, lhs, rhs) => {\n-                // These operations are weird because their order of evaluation depends on whether\n-                // the operator is overloaded. In a perfect world, we'd just ask the type checker\n-                // whether this is a method call, but we also need to match the expression IDs\n-                // from RegionResolutionVisitor. RegionResolutionVisitor doesn't know the order,\n-                // so it runs both orders and picks the most conservative. We'll mirror that here.\n-                let mut old_count = self.expr_count;\n-                self.visit_expr(lhs);\n-                self.visit_expr(rhs);\n-\n-                let old_drops = self.swap_drop_ranges(<_>::default());\n-                std::mem::swap(&mut old_count, &mut self.expr_count);\n-                self.visit_expr(rhs);\n-                self.visit_expr(lhs);\n-\n-                // We should have visited the same number of expressions in either order.\n-                assert_eq!(old_count, self.expr_count);\n-\n-                self.intersect_drop_ranges(old_drops);\n-            }\n+            // ExprKind::AssignOp(_op, lhs, rhs) => {\n+            //     // These operations are weird because their order of evaluation depends on whether\n+            //     // the operator is overloaded. In a perfect world, we'd just ask the type checker\n+            //     // whether this is a method call, but we also need to match the expression IDs\n+            //     // from RegionResolutionVisitor. RegionResolutionVisitor doesn't know the order,\n+            //     // so it runs both orders and picks the most conservative. We'll mirror that here.\n+            //     let mut old_count = self.expr_count;\n+            //     self.visit_expr(lhs);\n+            //     self.visit_expr(rhs);\n+\n+            //     let old_drops = self.swap_drop_ranges(<_>::default());\n+            //     std::mem::swap(&mut old_count, &mut self.expr_count);\n+            //     self.visit_expr(rhs);\n+            //     self.visit_expr(lhs);\n+\n+            //     // We should have visited the same number of expressions in either order.\n+            //     assert_eq!(old_count, self.expr_count);\n+\n+            //     self.intersect_drop_ranges(old_drops);\n+            // }\n             ExprKind::If(test, if_true, if_false) => {\n                 self.visit_expr(test);\n \n-                match if_false {\n-                    Some(if_false) => {\n-                        let mut true_ranges = self.fork_drop_ranges();\n-                        let mut false_ranges = self.fork_drop_ranges();\n+                let fork = self.expr_count - 1;\n \n-                        true_ranges = self.swap_drop_ranges(true_ranges);\n-                        self.visit_expr(if_true);\n-                        true_ranges = self.swap_drop_ranges(true_ranges);\n+                self.drop_ranges.add_control_edge(fork, self.expr_count);\n+                self.visit_expr(if_true);\n+                let true_end = self.expr_count - 1;\n \n-                        false_ranges =\n-                            self.swap_drop_ranges(trim_drop_ranges(&false_ranges, self.expr_count));\n-                        self.visit_expr(if_false);\n-                        false_ranges = self.swap_drop_ranges(false_ranges);\n-\n-                        self.merge_drop_ranges(true_ranges);\n-                        self.merge_drop_ranges(false_ranges);\n-                    }\n-                    None => {\n-                        let mut true_ranges = self.fork_drop_ranges();\n-                        debug!(\"true branch drop range fork: {:?}\", true_ranges);\n-                        true_ranges = self.swap_drop_ranges(true_ranges);\n-                        self.visit_expr(if_true);\n-                        true_ranges = self.swap_drop_ranges(true_ranges);\n-                        debug!(\"true branch computed drop_ranges: {:?}\", true_ranges);\n-                        debug!(\"drop ranges before merging: {:?}\", self.drop_ranges);\n-                        self.merge_drop_ranges(true_ranges);\n-                        debug!(\"drop ranges after merging: {:?}\", self.drop_ranges);\n-                    }\n+                if let Some(if_false) = if_false {\n+                    self.drop_ranges.add_control_edge(fork, self.expr_count);\n+                    self.visit_expr(if_false);\n                 }\n+\n+                self.drop_ranges.add_control_edge(true_end, self.expr_count);\n             }\n             ExprKind::Assign(lhs, rhs, _) => {\n                 self.visit_expr(lhs);\n@@ -899,27 +871,18 @@ impl<'tcx> Visitor<'tcx> for DropRangeVisitor<'tcx> {\n                 reinit = Some(lhs);\n             }\n             ExprKind::Loop(body, ..) => {\n-                // FIXME: we probably need to iterate this to a fixpoint.\n-                let body_drop_ranges = self.fork_drop_ranges();\n-                let old_drop_ranges = self.swap_drop_ranges(body_drop_ranges);\n-\n-                let join_point = self.expr_count;\n-\n+                let loop_begin = self.expr_count;\n                 self.visit_block(body);\n-\n-                let body_drop_ranges = self.swap_drop_ranges(old_drop_ranges);\n-                self.merge_drop_ranges_at(body_drop_ranges, join_point);\n+                self.drop_ranges.add_control_edge(self.expr_count - 1, loop_begin);\n             }\n             ExprKind::Match(scrutinee, arms, ..) => {\n                 self.visit_expr(scrutinee);\n \n-                let forked_ranges = self.fork_drop_ranges();\n+                let fork = self.expr_count - 1;\n                 let arm_drops = arms\n                     .iter()\n-                    .map(|Arm { hir_id, pat, body, guard, .. }| {\n-                        debug!(\"match arm {:?} starts at {}\", hir_id, self.expr_count);\n-                        let old_ranges = self\n-                            .swap_drop_ranges(trim_drop_ranges(&forked_ranges, self.expr_count));\n+                    .map(|Arm { pat, body, guard, .. }| {\n+                        self.drop_ranges.add_control_edge(fork, self.expr_count);\n                         self.visit_pat(pat);\n                         match guard {\n                             Some(Guard::If(expr)) => self.visit_expr(expr),\n@@ -930,10 +893,12 @@ impl<'tcx> Visitor<'tcx> for DropRangeVisitor<'tcx> {\n                             None => (),\n                         }\n                         self.visit_expr(body);\n-                        self.swap_drop_ranges(old_ranges)\n+                        self.expr_count - 1\n                     })\n                     .collect::<Vec<_>>();\n-                arm_drops.into_iter().for_each(|drops| self.merge_drop_ranges(drops));\n+                arm_drops.into_iter().for_each(|arm_end| {\n+                    self.drop_ranges.add_control_edge(arm_end, self.expr_count)\n+                });\n             }\n             _ => intravisit::walk_expr(self, expr),\n         }\n@@ -952,160 +917,3 @@ impl<'tcx> Visitor<'tcx> for DropRangeVisitor<'tcx> {\n         self.expr_count += 1;\n     }\n }\n-\n-fn trim_drop_ranges(drop_ranges: &HirIdMap<DropRange>, trim_from: usize) -> HirIdMap<DropRange> {\n-    drop_ranges.iter().map(|(k, v)| (*k, v.trimmed(trim_from))).collect()\n-}\n-\n-#[derive(Clone, Debug, PartialEq, Eq)]\n-enum Event {\n-    Drop(usize),\n-    Reinit(usize),\n-}\n-\n-impl Event {\n-    fn location(&self) -> usize {\n-        match *self {\n-            Event::Drop(i) | Event::Reinit(i) => i,\n-        }\n-    }\n-}\n-\n-impl PartialOrd for Event {\n-    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {\n-        self.location().partial_cmp(&other.location())\n-    }\n-}\n-\n-#[derive(Clone, Debug, PartialEq, Eq)]\n-struct DropRange {\n-    events: Vec<Event>,\n-}\n-\n-impl DropRange {\n-    fn empty() -> Self {\n-        Self { events: vec![] }\n-    }\n-\n-    fn intersect(&self, other: &Self) -> Self {\n-        let mut events = vec![];\n-        self.events\n-            .iter()\n-            .merge_join_by(other.events.iter(), |a, b| a.partial_cmp(b).unwrap())\n-            .fold((false, false), |(left, right), event| match event {\n-                itertools::EitherOrBoth::Both(_, _) => todo!(),\n-                itertools::EitherOrBoth::Left(e) => match e {\n-                    Event::Drop(i) => {\n-                        if !left && right {\n-                            events.push(Event::Drop(*i));\n-                        }\n-                        (true, right)\n-                    }\n-                    Event::Reinit(i) => {\n-                        if left && !right {\n-                            events.push(Event::Reinit(*i));\n-                        }\n-                        (false, right)\n-                    }\n-                },\n-                itertools::EitherOrBoth::Right(e) => match e {\n-                    Event::Drop(i) => {\n-                        if left && !right {\n-                            events.push(Event::Drop(*i));\n-                        }\n-                        (left, true)\n-                    }\n-                    Event::Reinit(i) => {\n-                        if !left && right {\n-                            events.push(Event::Reinit(*i));\n-                        }\n-                        (left, false)\n-                    }\n-                },\n-            });\n-        Self { events }\n-    }\n-\n-    fn is_dropped_at(&self, id: usize) -> bool {\n-        let dropped = match self.events.iter().try_fold(false, |is_dropped, event| {\n-            if event.location() <= id {\n-                Ok(match event {\n-                    Event::Drop(_) => true,\n-                    Event::Reinit(_) => false,\n-                })\n-            } else {\n-                Err(is_dropped)\n-            }\n-        }) {\n-            Ok(is_dropped) | Err(is_dropped) => is_dropped,\n-        };\n-        trace!(\"is_dropped_at({}): events = {:?}, dropped = {}\", id, self.events, dropped);\n-        dropped\n-    }\n-\n-    fn drop(&mut self, location: usize) {\n-        self.events.push(Event::Drop(location))\n-    }\n-\n-    fn reinit(&mut self, location: usize) {\n-        self.events.push(Event::Reinit(location));\n-    }\n-\n-    /// Merges another range with this one. Meant to be used at control flow join points.\n-    ///\n-    /// After merging, the value will be dead at the end of the range only if it was dead\n-    /// at the end of both self and other.\n-    #[tracing::instrument]\n-    fn merge_with(&mut self, other: &DropRange, join_point: usize) {\n-        let join_event = if self.is_dropped_at(join_point) && other.is_dropped_at(join_point) {\n-            Event::Drop(join_point)\n-        } else {\n-            Event::Reinit(join_point)\n-        };\n-        let events: Vec<_> = self\n-            .events\n-            .iter()\n-            .merge([join_event].iter())\n-            .merge(other.events.iter())\n-            .dedup()\n-            .cloned()\n-            .collect();\n-\n-        trace!(\"events after merging: {:?}\", events);\n-\n-        self.events = events;\n-    }\n-\n-    /// Creates a new DropRange from this one at the split point.\n-    ///\n-    /// Used to model branching control flow.\n-    fn fork_at(&self, split_point: usize) -> Self {\n-        let result = Self {\n-            events: vec![if self.is_dropped_at(split_point) {\n-                Event::Drop(split_point)\n-            } else {\n-                Event::Reinit(split_point)\n-            }],\n-        };\n-        trace!(\"forking at {}: {:?}; result = {:?}\", split_point, self.events, result);\n-        result\n-    }\n-\n-    fn trimmed(&self, trim_from: usize) -> Self {\n-        let start = if self.is_dropped_at(trim_from) {\n-            Event::Drop(trim_from)\n-        } else {\n-            Event::Reinit(trim_from)\n-        };\n-\n-        let result = Self {\n-            events: [start]\n-                .iter()\n-                .chain(self.events.iter().skip_while(|event| event.location() <= trim_from))\n-                .cloned()\n-                .collect(),\n-        };\n-        trace!(\"trimmed {:?} at {}, got {:?}\", self, trim_from, result);\n-        result\n-    }\n-}"}, {"sha": "dadd9b8d75367e5eabfedf9cea16d609fc6f53dc", "filename": "compiler/rustc_typeck/src/check/generator_interior/drop_ranges.rs", "status": "added", "additions": 173, "deletions": 0, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/ff0e8f4ba2e3133a167b138ba1ed69d1708fff16/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff0e8f4ba2e3133a167b138ba1ed69d1708fff16/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges.rs?ref=ff0e8f4ba2e3133a167b138ba1ed69d1708fff16", "patch": "@@ -0,0 +1,173 @@\n+use rustc_hir::{HirId, HirIdMap};\n+use rustc_index::bit_set::BitSet;\n+use rustc_index::vec::IndexVec;\n+use rustc_middle::hir::map::Map;\n+\n+use super::for_each_consumable;\n+\n+rustc_index::newtype_index! {\n+    pub struct PostOrderId {\n+        DEBUG_FORMAT = \"id({})\",\n+    }\n+}\n+\n+rustc_index::newtype_index! {\n+    pub struct HirIdIndex {\n+        DEBUG_FORMAT = \"hidx({})\",\n+    }\n+}\n+\n+pub struct DropRanges {\n+    hir_id_map: HirIdMap<HirIdIndex>,\n+    nodes: IndexVec<PostOrderId, NodeInfo>,\n+}\n+\n+/// DropRanges keeps track of what values are definitely dropped at each point in the code.\n+///\n+/// Values of interest are defined by the hir_id of their place. Locations in code are identified\n+/// by their index in the post-order traversal. At its core, DropRanges maps\n+/// (hir_id, post_order_id) -> bool, where a true value indicates that the value is definitely\n+/// dropped at the point of the node identified by post_order_id.\n+impl DropRanges {\n+    pub fn new(hir_ids: impl Iterator<Item = HirId>, hir: &Map<'_>) -> Self {\n+        let mut hir_id_map = HirIdMap::<HirIdIndex>::default();\n+        let mut next = <_>::from(0u32);\n+        for hir_id in hir_ids {\n+            for_each_consumable(hir_id, hir.find(hir_id), |hir_id| {\n+                if !hir_id_map.contains_key(&hir_id) {\n+                    hir_id_map.insert(hir_id, next);\n+                    next = <_>::from(next.index() + 1);\n+                }\n+            });\n+        }\n+        debug!(\"hir_id_map: {:?}\", hir_id_map);\n+        Self { hir_id_map, nodes: <_>::default() }\n+    }\n+\n+    fn hidx(&self, hir_id: HirId) -> HirIdIndex {\n+        *self.hir_id_map.get(&hir_id).unwrap()\n+    }\n+\n+    pub fn is_dropped_at(&mut self, hir_id: HirId, location: usize) -> bool {\n+        self.hir_id_map\n+            .get(&hir_id)\n+            .copied()\n+            .map_or(false, |hir_id| self.node(location.into()).drop_state.contains(hir_id))\n+    }\n+\n+    /// Returns the number of values (hir_ids) that are tracked\n+    fn num_values(&self) -> usize {\n+        self.hir_id_map.len()\n+    }\n+\n+    fn node(&mut self, id: PostOrderId) -> &NodeInfo {\n+        let size = self.num_values();\n+        self.nodes.ensure_contains_elem(id, || NodeInfo::new(size));\n+        &self.nodes[id]\n+    }\n+\n+    fn node_mut(&mut self, id: PostOrderId) -> &mut NodeInfo {\n+        let size = self.num_values();\n+        self.nodes.ensure_contains_elem(id, || NodeInfo::new(size));\n+        &mut self.nodes[id]\n+    }\n+\n+    pub fn add_control_edge(&mut self, from: usize, to: usize) {\n+        self.node_mut(from.into()).successors.push(to.into());\n+    }\n+\n+    pub fn drop_at(&mut self, value: HirId, location: usize) {\n+        let value = self.hidx(value);\n+        self.node_mut(location.into()).drops.push(value);\n+    }\n+\n+    pub fn reinit_at(&mut self, value: HirId, location: usize) {\n+        let value = match self.hir_id_map.get(&value) {\n+            Some(value) => *value,\n+            // If there's no value, this is never consumed and therefore is never dropped. We can\n+            // ignore this.\n+            None => return,\n+        };\n+        self.node_mut(location.into()).reinits.push(value);\n+    }\n+\n+    pub fn propagate_to_fixpoint(&mut self) {\n+        while self.propagate() {}\n+    }\n+\n+    fn propagate(&mut self) -> bool {\n+        let mut visited = BitSet::new_empty(self.nodes.len());\n+\n+        self.visit(&mut visited, PostOrderId::from(0usize), PostOrderId::from(0usize), false)\n+    }\n+\n+    fn visit(\n+        &mut self,\n+        visited: &mut BitSet<PostOrderId>,\n+        id: PostOrderId,\n+        pred_id: PostOrderId,\n+        mut changed: bool,\n+    ) -> bool {\n+        if visited.contains(id) {\n+            return changed;\n+        }\n+        visited.insert(id);\n+\n+        changed &= self.nodes[id].merge_with(&self.nodes[pred_id]);\n+\n+        if self.nodes[id].successors.len() == 0 {\n+            self.visit(visited, PostOrderId::from(id.index() + 1), id, changed)\n+        } else {\n+            self.nodes[id]\n+                .successors\n+                .iter()\n+                .fold(changed, |changed, &succ| self.visit(visited, succ, id, changed))\n+        }\n+    }\n+}\n+\n+struct NodeInfo {\n+    /// IDs of nodes that can follow this one in the control flow\n+    ///\n+    /// If the vec is empty, then control proceeds to the next node.\n+    successors: Vec<PostOrderId>,\n+\n+    /// List of hir_ids that are dropped by this node.\n+    drops: Vec<HirIdIndex>,\n+\n+    /// List of hir_ids that are reinitialized by this node.\n+    reinits: Vec<HirIdIndex>,\n+\n+    /// Set of values that are definitely dropped at this point.\n+    drop_state: BitSet<HirIdIndex>,\n+}\n+\n+impl NodeInfo {\n+    fn new(num_values: usize) -> Self {\n+        Self {\n+            successors: vec![],\n+            drops: vec![],\n+            reinits: vec![],\n+            drop_state: BitSet::new_empty(num_values),\n+        }\n+    }\n+\n+    fn merge_with(&mut self, other: &NodeInfo) -> bool {\n+        let mut changed = false;\n+        for place in &self.drops {\n+            if !self.drop_state.contains(place) && !self.reinits.contains(&place) {\n+                changed = true;\n+                self.drop_state.insert(place);\n+            }\n+        }\n+\n+        for place in &self.reinits {\n+            if self.drop_state.contains(place) {\n+                changed = true;\n+                self.drop_state.remove(place);\n+            }\n+        }\n+\n+        changed\n+    }\n+}"}]}