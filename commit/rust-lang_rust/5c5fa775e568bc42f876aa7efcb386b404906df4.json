{"sha": "5c5fa775e568bc42f876aa7efcb386b404906df4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVjNWZhNzc1ZTU2OGJjNDJmODc2YWE3ZWZjYjM4NmI0MDQ5MDZkZjQ=", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2019-05-22T05:17:53Z"}, "committer": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2019-05-24T18:50:21Z"}, "message": "review comments", "tree": {"sha": "3913ec15eee84bad790ebd7c79406651b7319f3f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3913ec15eee84bad790ebd7c79406651b7319f3f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5c5fa775e568bc42f876aa7efcb386b404906df4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5c5fa775e568bc42f876aa7efcb386b404906df4", "html_url": "https://github.com/rust-lang/rust/commit/5c5fa775e568bc42f876aa7efcb386b404906df4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5c5fa775e568bc42f876aa7efcb386b404906df4/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "24160171e48a277ef71e84e14fbffffe3c81438a", "url": "https://api.github.com/repos/rust-lang/rust/commits/24160171e48a277ef71e84e14fbffffe3c81438a", "html_url": "https://github.com/rust-lang/rust/commit/24160171e48a277ef71e84e14fbffffe3c81438a"}], "stats": {"total": 139, "additions": 73, "deletions": 66}, "files": [{"sha": "6fed83021609d76a16a4cf8dc2302a836d92a0bb", "filename": "src/libfmt_macros/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c5fa775e568bc42f876aa7efcb386b404906df4/src%2Flibfmt_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c5fa775e568bc42f876aa7efcb386b404906df4/src%2Flibfmt_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2Flib.rs?ref=5c5fa775e568bc42f876aa7efcb386b404906df4", "patch": "@@ -627,7 +627,7 @@ mod tests {\n     use super::*;\n \n     fn same(fmt: &'static str, p: &[Piece<'static>]) {\n-        let parser = Parser::new(fmt, None, vec![], false, None);\n+        let parser = Parser::new(fmt, None, vec![], false);\n         assert!(parser.collect::<Vec<Piece<'static>>>() == p);\n     }\n \n@@ -643,7 +643,7 @@ mod tests {\n     }\n \n     fn musterr(s: &str) {\n-        let mut p = Parser::new(s, None, vec![], false, None);\n+        let mut p = Parser::new(s, None, vec![], false);\n         p.next();\n         assert!(!p.errors.is_empty());\n     }"}, {"sha": "5ccec05dda20b3ae6e698a83ab5e32f182ce07a9", "filename": "src/libsyntax/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c5fa775e568bc42f876aa7efcb386b404906df4/src%2Flibsyntax%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c5fa775e568bc42f876aa7efcb386b404906df4/src%2Flibsyntax%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fconfig.rs?ref=5c5fa775e568bc42f876aa7efcb386b404906df4", "patch": "@@ -98,7 +98,7 @@ impl<'a> StripUnconfigured<'a> {\n             self.sess.span_diagnostic.struct_span_err(attr.span, \"bad `cfg_attr` attribute\")\n                 .span_label(attr.span, \"missing condition and attribute\")\n                 .note(\"`cfg_attr` must be of the form: \\\n-                       `#[cfg_attr(condition, attribute)]`\")\n+                       `#[cfg_attr(condition, attribute, other_attribute, ...)]`\")\n                 .note(\"for more information, visit \\\n                        <https://doc.rust-lang.org/reference/conditional-compilation.html\\\n                        #the-cfg_attr-attribute>\")"}, {"sha": "dbec379e76995cc0025b28e960ab437d54ce64f2", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5c5fa775e568bc42f876aa7efcb386b404906df4/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c5fa775e568bc42f876aa7efcb386b404906df4/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=5c5fa775e568bc42f876aa7efcb386b404906df4", "patch": "@@ -11,7 +11,7 @@ use crate::parse::{self, parser, DirectoryOwnership};\n use crate::parse::token;\n use crate::ptr::P;\n use crate::symbol::{kw, sym, Ident, Symbol};\n-use crate::ThinVec;\n+use crate::{ThinVec, MACRO_ARGUMENTS};\n use crate::tokenstream::{self, TokenStream};\n \n use errors::{DiagnosticBuilder, DiagnosticId};\n@@ -850,11 +850,7 @@ impl<'a> ExtCtxt<'a> {\n     }\n \n     pub fn new_parser_from_tts(&self, tts: &[tokenstream::TokenTree]) -> parser::Parser<'a> {\n-        parse::stream_to_parser(\n-            self.parse_sess,\n-            tts.iter().cloned().collect(),\n-            Some(\"macro arguments\"),\n-        )\n+        parse::stream_to_parser(self.parse_sess, tts.iter().cloned().collect(), MACRO_ARGUMENTS)\n     }\n     pub fn source_map(&self) -> &'a SourceMap { self.parse_sess.source_map() }\n     pub fn parse_sess(&self) -> &'a parse::ParseSess { self.parse_sess }"}, {"sha": "e55226b8579bda2566c2929225d8212c72343c96", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c5fa775e568bc42f876aa7efcb386b404906df4/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c5fa775e568bc42f876aa7efcb386b404906df4/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=5c5fa775e568bc42f876aa7efcb386b404906df4", "patch": "@@ -664,7 +664,7 @@ pub fn parse(\n         directory,\n         recurse_into_modules,\n         true,\n-        Some(\"macro arguments\"),\n+        crate::MACRO_ARGUMENTS,\n     );\n \n     // A queue of possible matcher positions. We initialize it with the matcher position in which"}, {"sha": "4229121b3d0759cdf370a535e66700b1aac43679", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c5fa775e568bc42f876aa7efcb386b404906df4/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c5fa775e568bc42f876aa7efcb386b404906df4/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=5c5fa775e568bc42f876aa7efcb386b404906df4", "patch": "@@ -31,6 +31,8 @@ pub use rustc_data_structures::thin_vec::ThinVec;\n use ast::AttrId;\n use syntax_pos::edition::Edition;\n \n+const MACRO_ARGUMENTS: Option<&'static str> = Some(\"macro arguments\");\n+\n // A variant of 'try!' that panics on an Err. This is used as a crutch on the\n // way towards a non-panic!-prone parser. It should be used for fatal parsing\n // errors; eventually we plan to convert all code using panictry to just use"}, {"sha": "8174367ca45319636c2d951abde4a1771b7f7cab", "filename": "src/libsyntax/parse/diagnostics.rs", "status": "modified", "additions": 54, "deletions": 2, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/5c5fa775e568bc42f876aa7efcb386b404906df4/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c5fa775e568bc42f876aa7efcb386b404906df4/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs?ref=5c5fa775e568bc42f876aa7efcb386b404906df4", "patch": "@@ -13,7 +13,7 @@ use crate::symbol::kw;\n use crate::ThinVec;\n use errors::{Applicability, DiagnosticBuilder};\n use log::debug;\n-use syntax_pos::Span;\n+use syntax_pos::{Span, DUMMY_SP};\n \n pub trait RecoverQPath: Sized + 'static {\n     const PATH_STYLE: PathStyle = PathStyle::Expr;\n@@ -201,7 +201,7 @@ impl<'a> Parser<'a> {\n \n         let mut path = ast::Path {\n             segments: Vec::new(),\n-            span: syntax_pos::DUMMY_SP,\n+            span: DUMMY_SP,\n         };\n         self.parse_path_segments(&mut path.segments, T::PATH_STYLE)?;\n         path.span = ty_span.to(self.prev_span);\n@@ -267,6 +267,58 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n+    /// Create a `DiagnosticBuilder` for an unexpected token `t` and try to recover if it is a\n+    /// closing delimiter.\n+    pub fn unexpected_try_recover(\n+        &mut self,\n+        t: &token::Token,\n+    ) -> PResult<'a, bool /* recovered */> {\n+        let token_str = pprust::token_to_string(t);\n+        let this_token_str = self.this_token_descr();\n+        let (prev_sp, sp) = match (&self.token, self.subparser_name) {\n+            // Point at the end of the macro call when reaching end of macro arguments.\n+            (token::Token::Eof, Some(_)) => {\n+                let sp = self.sess.source_map().next_point(self.span);\n+                (sp, sp)\n+            }\n+            // We don't want to point at the following span after DUMMY_SP.\n+            // This happens when the parser finds an empty TokenStream.\n+            _ if self.prev_span == DUMMY_SP => (self.span, self.span),\n+            // EOF, don't want to point at the following char, but rather the last token.\n+            (token::Token::Eof, None) => (self.prev_span, self.span),\n+            _ => (self.sess.source_map().next_point(self.prev_span), self.span),\n+        };\n+        let msg = format!(\n+            \"expected `{}`, found {}\",\n+            token_str,\n+            match (&self.token, self.subparser_name) {\n+                (token::Token::Eof, Some(origin)) => format!(\"end of {}\", origin),\n+                _ => this_token_str,\n+            },\n+        );\n+        let mut err = self.struct_span_err(sp, &msg);\n+        let label_exp = format!(\"expected `{}`\", token_str);\n+        match self.recover_closing_delimiter(&[t.clone()], err) {\n+            Err(e) => err = e,\n+            Ok(recovered) => {\n+                return Ok(recovered);\n+            }\n+        }\n+        let cm = self.sess.source_map();\n+        match (cm.lookup_line(prev_sp.lo()), cm.lookup_line(sp.lo())) {\n+            (Ok(ref a), Ok(ref b)) if a.line == b.line => {\n+                // When the spans are in the same line, it means that the only content\n+                // between them is whitespace, point only at the found token.\n+                err.span_label(sp, label_exp);\n+            }\n+            _ => {\n+                err.span_label(prev_sp, label_exp);\n+                err.span_label(sp, \"unexpected token\");\n+            }\n+        }\n+        Err(err)\n+    }\n+\n     /// Consume alternative await syntaxes like `await <expr>`, `await? <expr>`, `await(<expr>)`\n     /// and `await { <expr> }`.\n     crate fn parse_incorrect_await_syntax("}, {"sha": "fc76987c17530ed854e1d2226692a965d2cc0636", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5c5fa775e568bc42f876aa7efcb386b404906df4/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c5fa775e568bc42f876aa7efcb386b404906df4/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=5c5fa775e568bc42f876aa7efcb386b404906df4", "patch": "@@ -248,7 +248,7 @@ fn maybe_source_file_to_parser(\n // must preserve old name for now, because quote! from the *existing*\n // compiler expands into it\n pub fn new_parser_from_tts(sess: &ParseSess, tts: Vec<TokenTree>) -> Parser<'_> {\n-    stream_to_parser(sess, tts.into_iter().collect(), Some(\"macro arguments\"))\n+    stream_to_parser(sess, tts.into_iter().collect(), crate::MACRO_ARGUMENTS)\n }\n \n \n@@ -331,9 +331,9 @@ pub fn maybe_file_to_stream(\n pub fn stream_to_parser<'a>(\n     sess: &'a ParseSess,\n     stream: TokenStream,\n-    is_subparser: Option<&'static str>,\n+    subparser_name: Option<&'static str>,\n ) -> Parser<'a> {\n-    Parser::new(sess, stream, None, true, false, is_subparser)\n+    Parser::new(sess, stream, None, true, false, subparser_name)\n }\n \n /// Given stream, the `ParseSess` and the base directory, produces a parser."}, {"sha": "77b41aaa117f79851493c2d2f38ae943f9f29c8f", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 7, "deletions": 50, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/5c5fa775e568bc42f876aa7efcb386b404906df4/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c5fa775e568bc42f876aa7efcb386b404906df4/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=5c5fa775e568bc42f876aa7efcb386b404906df4", "patch": "@@ -233,8 +233,8 @@ pub struct Parser<'a> {\n     /// error.\n     crate unclosed_delims: Vec<UnmatchedBrace>,\n     last_unexpected_token_span: Option<Span>,\n-    /// If `true`, this `Parser` is not parsing Rust code but rather a macro call.\n-    is_subparser: Option<&'static str>,\n+    /// If present, this `Parser` is not parsing Rust code but rather a macro call.\n+    crate subparser_name: Option<&'static str>,\n }\n \n impl<'a> Drop for Parser<'a> {\n@@ -541,7 +541,7 @@ impl<'a> Parser<'a> {\n         directory: Option<Directory<'a>>,\n         recurse_into_file_modules: bool,\n         desugar_doc_comments: bool,\n-        is_subparser: Option<&'static str>,\n+        subparser_name: Option<&'static str>,\n     ) -> Self {\n         let mut parser = Parser {\n             sess,\n@@ -572,7 +572,7 @@ impl<'a> Parser<'a> {\n             max_angle_bracket_count: 0,\n             unclosed_delims: Vec::new(),\n             last_unexpected_token_span: None,\n-            is_subparser,\n+            subparser_name,\n         };\n \n         let tok = parser.next_tok();\n@@ -636,56 +636,13 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Expects and consumes the token `t`. Signals an error if the next token is not `t`.\n-    pub fn expect(&mut self, t: &token::Token) -> PResult<'a,  bool /* recovered */> {\n+    pub fn expect(&mut self, t: &token::Token) -> PResult<'a, bool /* recovered */> {\n         if self.expected_tokens.is_empty() {\n             if self.token == *t {\n                 self.bump();\n                 Ok(false)\n             } else {\n-                let token_str = pprust::token_to_string(t);\n-                let this_token_str = self.this_token_descr();\n-                let (prev_sp, sp) = match (&self.token, self.is_subparser) {\n-                    // Point at the end of the macro call when reaching end of macro arguments.\n-                    (token::Token::Eof, Some(_)) => {\n-                        let sp = self.sess.source_map().next_point(self.span);\n-                        (sp, sp)\n-                    }\n-                    // We don't want to point at the following span after DUMMY_SP.\n-                    // This happens when the parser finds an empty TokenStream.\n-                    _ if self.prev_span == DUMMY_SP => (self.span, self.span),\n-                    // EOF, don't want to point at the following char, but rather the last token.\n-                    (token::Token::Eof, None) => (self.prev_span, self.span),\n-                    _ => (self.sess.source_map().next_point(self.prev_span), self.span),\n-                };\n-                let msg = format!(\n-                    \"expected `{}`, found {}\",\n-                    token_str,\n-                    match (&self.token, self.is_subparser) {\n-                        (token::Token::Eof, Some(origin)) => format!(\"end of {}\", origin),\n-                        _ => this_token_str,\n-                    },\n-                );\n-                let mut err = self.struct_span_err(sp, &msg);\n-                let label_exp = format!(\"expected `{}`\", token_str);\n-                match self.recover_closing_delimiter(&[t.clone()], err) {\n-                    Err(e) => err = e,\n-                    Ok(recovered) => {\n-                        return Ok(recovered);\n-                    }\n-                }\n-                let cm = self.sess.source_map();\n-                match (cm.lookup_line(prev_sp.lo()), cm.lookup_line(sp.lo())) {\n-                    (Ok(ref a), Ok(ref b)) if a.line == b.line => {\n-                        // When the spans are in the same line, it means that the only content\n-                        // between them is whitespace, point only at the found token.\n-                        err.span_label(sp, label_exp);\n-                    }\n-                    _ => {\n-                        err.span_label(prev_sp, label_exp);\n-                        err.span_label(sp, \"unexpected token\");\n-                    }\n-                }\n-                Err(err)\n+                self.unexpected_try_recover(t)\n             }\n         } else {\n             self.expect_one_of(slice::from_ref(t), &[])\n@@ -2644,7 +2601,7 @@ impl<'a> Parser<'a> {\n                         }\n                         Err(mut err) => {\n                             self.cancel(&mut err);\n-                            let (span, msg) = match (&self.token, self.is_subparser) {\n+                            let (span, msg) = match (&self.token, self.subparser_name) {\n                                 (&token::Token::Eof, Some(origin)) => {\n                                     let sp = self.sess.source_map().next_point(self.span);\n                                     (sp, format!( \"expected expression, found end of {}\", origin))"}, {"sha": "ad8015bf385a5d9597d4bd3c06337c2c7fce74df", "filename": "src/test/ui/malformed/malformed-special-attrs.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c5fa775e568bc42f876aa7efcb386b404906df4/src%2Ftest%2Fui%2Fmalformed%2Fmalformed-special-attrs.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5c5fa775e568bc42f876aa7efcb386b404906df4/src%2Ftest%2Fui%2Fmalformed%2Fmalformed-special-attrs.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmalformed%2Fmalformed-special-attrs.stderr?ref=5c5fa775e568bc42f876aa7efcb386b404906df4", "patch": "@@ -4,7 +4,7 @@ error: bad `cfg_attr` attribute\n LL | #[cfg_attr]\n    | ^^^^^^^^^^^ missing condition and attribute\n    |\n-   = note: `cfg_attr` must be of the form: `#[cfg_attr(condition, attribute)]`\n+   = note: `cfg_attr` must be of the form: `#[cfg_attr(condition, attribute, other_attribute, ...)]`\n    = note: for more information, visit <https://doc.rust-lang.org/reference/conditional-compilation.html#the-cfg_attr-attribute>\n \n error: expected `(`, found `=`"}, {"sha": "4b6d23890653d44637f1694095c9f593451edb48", "filename": "src/test/ui/parser/macro/bad-macro-argument.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/5c5fa775e568bc42f876aa7efcb386b404906df4/src%2Ftest%2Fui%2Fparser%2Fmacro%2Fbad-macro-argument.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c5fa775e568bc42f876aa7efcb386b404906df4/src%2Ftest%2Fui%2Fparser%2Fmacro%2Fbad-macro-argument.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fmacro%2Fbad-macro-argument.rs?ref=5c5fa775e568bc42f876aa7efcb386b404906df4", "previous_filename": "src/test/ui/parser/bad-macro-argument.rs"}, {"sha": "3cd8accb662948cc4b5d90ff687c3edcee74058a", "filename": "src/test/ui/parser/macro/bad-macro-argument.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/5c5fa775e568bc42f876aa7efcb386b404906df4/src%2Ftest%2Fui%2Fparser%2Fmacro%2Fbad-macro-argument.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5c5fa775e568bc42f876aa7efcb386b404906df4/src%2Ftest%2Fui%2Fparser%2Fmacro%2Fbad-macro-argument.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fmacro%2Fbad-macro-argument.stderr?ref=5c5fa775e568bc42f876aa7efcb386b404906df4", "previous_filename": "src/test/ui/parser/bad-macro-argument.stderr"}]}