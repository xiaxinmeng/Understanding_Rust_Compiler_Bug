{"sha": "bb333ca3926df37a6529e4546147642bbce89c41", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJiMzMzY2EzOTI2ZGYzN2E2NTI5ZTQ1NDYxNDc2NDJiYmNlODljNDE=", "commit": {"author": {"name": "John Clements", "email": "clements@racket-lang.org", "date": "2014-07-12T22:00:23Z"}, "committer": {"name": "John Clements", "email": "clements@racket-lang.org", "date": "2014-07-13T17:10:38Z"}, "message": "expansion abstraction", "tree": {"sha": "6e0e748a5d49e4aa233f81a76820f8a5fab9ea28", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6e0e748a5d49e4aa233f81a76820f8a5fab9ea28"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bb333ca3926df37a6529e4546147642bbce89c41", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bb333ca3926df37a6529e4546147642bbce89c41", "html_url": "https://github.com/rust-lang/rust/commit/bb333ca3926df37a6529e4546147642bbce89c41", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bb333ca3926df37a6529e4546147642bbce89c41/comments", "author": {"login": "jbclements", "id": 226617, "node_id": "MDQ6VXNlcjIyNjYxNw==", "avatar_url": "https://avatars.githubusercontent.com/u/226617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jbclements", "html_url": "https://github.com/jbclements", "followers_url": "https://api.github.com/users/jbclements/followers", "following_url": "https://api.github.com/users/jbclements/following{/other_user}", "gists_url": "https://api.github.com/users/jbclements/gists{/gist_id}", "starred_url": "https://api.github.com/users/jbclements/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jbclements/subscriptions", "organizations_url": "https://api.github.com/users/jbclements/orgs", "repos_url": "https://api.github.com/users/jbclements/repos", "events_url": "https://api.github.com/users/jbclements/events{/privacy}", "received_events_url": "https://api.github.com/users/jbclements/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jbclements", "id": 226617, "node_id": "MDQ6VXNlcjIyNjYxNw==", "avatar_url": "https://avatars.githubusercontent.com/u/226617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jbclements", "html_url": "https://github.com/jbclements", "followers_url": "https://api.github.com/users/jbclements/followers", "following_url": "https://api.github.com/users/jbclements/following{/other_user}", "gists_url": "https://api.github.com/users/jbclements/gists{/gist_id}", "starred_url": "https://api.github.com/users/jbclements/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jbclements/subscriptions", "organizations_url": "https://api.github.com/users/jbclements/orgs", "repos_url": "https://api.github.com/users/jbclements/repos", "events_url": "https://api.github.com/users/jbclements/events{/privacy}", "received_events_url": "https://api.github.com/users/jbclements/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2c4b6d6f7d6001bf9241f90f1465f4a98490a0d9", "url": "https://api.github.com/repos/rust-lang/rust/commits/2c4b6d6f7d6001bf9241f90f1465f4a98490a0d9", "html_url": "https://github.com/rust-lang/rust/commit/2c4b6d6f7d6001bf9241f90f1465f4a98490a0d9"}], "stats": {"total": 258, "additions": 114, "deletions": 144}, "files": [{"sha": "36ec299b705ba37a92f151f7837ce092edfafeca", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 114, "deletions": 144, "changes": 258, "blob_url": "https://github.com/rust-lang/rust/blob/bb333ca3926df37a6529e4546147642bbce89c41/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb333ca3926df37a6529e4546147642bbce89c41/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=bb333ca3926df37a6529e4546147642bbce89c41", "patch": "@@ -37,92 +37,28 @@ pub fn expand_expr(e: Gc<ast::Expr>, fld: &mut MacroExpander) -> Gc<ast::Expr> {\n         // expr_mac should really be expr_ext or something; it's the\n         // entry-point for all syntax extensions.\n         ExprMac(ref mac) => {\n-            match (*mac).node {\n-                // it would almost certainly be cleaner to pass the whole\n-                // macro invocation in, rather than pulling it apart and\n-                // marking the tts and the ctxt separately. This also goes\n-                // for the other three macro invocation chunks of code\n-                // in this file.\n-                // Token-tree macros:\n-                MacInvocTT(ref pth, ref tts, _) => {\n-                    if pth.segments.len() > 1u {\n-                        fld.cx.span_err(pth.span,\n-                                        \"expected macro name without module \\\n-                                         separators\");\n-                        // let compilation continue\n-                        return DummyResult::raw_expr(e.span);\n-                    }\n-                    let extname = pth.segments.get(0).identifier;\n-                    let extnamestr = token::get_ident(extname);\n-                    let marked_after = match fld.extsbox.find(&extname.name) {\n-                        None => {\n-                            fld.cx.span_err(\n-                                pth.span,\n-                                format!(\"macro undefined: '{}!'\",\n-                                        extnamestr.get()).as_slice());\n-\n-                            // let compilation continue\n-                            return DummyResult::raw_expr(e.span);\n-                        }\n-                        Some(&NormalTT(ref expandfun, exp_span)) => {\n-                            fld.cx.bt_push(ExpnInfo {\n-                                call_site: e.span,\n-                                callee: NameAndSpan {\n-                                    name: extnamestr.get().to_string(),\n-                                    format: MacroBang,\n-                                    span: exp_span,\n-                                },\n-                            });\n-                            let fm = fresh_mark();\n-                            // mark before:\n-                            let marked_before = mark_tts(tts.as_slice(), fm);\n-\n-                            // The span that we pass to the expanders we want to\n-                            // be the root of the call stack. That's the most\n-                            // relevant span and it's the actual invocation of\n-                            // the macro.\n-                            let mac_span = original_span(fld.cx);\n-\n-                            let expanded = match expandfun.expand(fld.cx,\n-                                                   mac_span.call_site,\n-                                                   marked_before.as_slice()).make_expr() {\n-                                Some(e) => e,\n-                                None => {\n-                                    fld.cx.span_err(\n-                                        pth.span,\n-                                        format!(\"non-expression macro in expression position: {}\",\n-                                                extnamestr.get().as_slice()\n-                                        ).as_slice());\n-                                    return DummyResult::raw_expr(e.span);\n-                                }\n-                            };\n+            let expanded_expr = match expand_mac_invoc(mac,&e.span,\n+                                                       |r|{r.make_expr()},\n+                                                       |expr,fm|{mark_expr(expr,fm)},\n+                                                       fld) {\n+                Some(expr) => expr,\n+                None => {\n+                    return DummyResult::raw_expr(e.span);\n+                }\n+            };\n \n-                            // mark after:\n-                            mark_expr(expanded,fm)\n-                        }\n-                        _ => {\n-                            fld.cx.span_err(\n-                                pth.span,\n-                                format!(\"'{}' is not a tt-style macro\",\n-                                        extnamestr.get()).as_slice());\n-                            return DummyResult::raw_expr(e.span);\n-                        }\n-                    };\n+            // Keep going, outside-in.\n+            //\n+            // FIXME(pcwalton): Is it necessary to clone the\n+            // node here?\n+            let fully_expanded =\n+                fld.fold_expr(expanded_expr).node.clone();\n+            fld.cx.bt_pop();\n \n-                    // Keep going, outside-in.\n-                    //\n-                    // FIXME(pcwalton): Is it necessary to clone the\n-                    // node here?\n-                    let fully_expanded =\n-                        fld.fold_expr(marked_after).node.clone();\n-                    fld.cx.bt_pop();\n-\n-                    box(GC) ast::Expr {\n-                        id: ast::DUMMY_NODE_ID,\n-                        node: fully_expanded,\n-                        span: e.span,\n-                    }\n-                }\n+            box(GC) ast::Expr {\n+                id: ast::DUMMY_NODE_ID,\n+                node: fully_expanded,\n+                span: e.span,\n             }\n         }\n \n@@ -246,6 +182,88 @@ pub fn expand_expr(e: Gc<ast::Expr>, fld: &mut MacroExpander) -> Gc<ast::Expr> {\n     }\n }\n \n+/// Expand a (not-ident-style) macro invocation. Returns the result\n+/// of expansion and the mark which must be applied to the result.\n+/// Our current interface doesn't allow us to apply the mark to the\n+/// result until after calling make_expr, make_items, etc.\n+fn expand_mac_invoc<T>(mac: &ast::Mac, span: &codemap::Span,\n+                       parse_thunk: |Box<MacResult>|->Option<T>,\n+                       mark_thunk: |T,Mrk|->T,\n+                       fld: &mut MacroExpander)\n+    -> Option<T> {\n+    match (*mac).node {\n+        // it would almost certainly be cleaner to pass the whole\n+        // macro invocation in, rather than pulling it apart and\n+        // marking the tts and the ctxt separately. This also goes\n+        // for the other three macro invocation chunks of code\n+        // in this file.\n+        // Token-tree macros:\n+        MacInvocTT(ref pth, ref tts, _) => {\n+            if pth.segments.len() > 1u {\n+                fld.cx.span_err(pth.span,\n+                                \"expected macro name without module \\\n+                                separators\");\n+                // let compilation continue\n+                return None;\n+            }\n+            let extname = pth.segments.get(0).identifier;\n+            let extnamestr = token::get_ident(extname);\n+            match fld.extsbox.find(&extname.name) {\n+                None => {\n+                    fld.cx.span_err(\n+                        pth.span,\n+                        format!(\"macro undefined: '{}!'\",\n+                                extnamestr.get()).as_slice());\n+\n+                    // let compilation continue\n+                    None\n+                }\n+                Some(&NormalTT(ref expandfun, exp_span)) => {\n+                    fld.cx.bt_push(ExpnInfo {\n+                            call_site: *span,\n+                            callee: NameAndSpan {\n+                                name: extnamestr.get().to_string(),\n+                                format: MacroBang,\n+                                span: exp_span,\n+                            },\n+                        });\n+                    let fm = fresh_mark();\n+                    let marked_before = mark_tts(tts.as_slice(), fm);\n+\n+                    // The span that we pass to the expanders we want to\n+                    // be the root of the call stack. That's the most\n+                    // relevant span and it's the actual invocation of\n+                    // the macro.\n+                    let mac_span = original_span(fld.cx);\n+\n+                    let expanded = expandfun.expand(fld.cx,\n+                                                    mac_span.call_site,\n+                                                    marked_before.as_slice());\n+                    let parsed = match parse_thunk(expanded) {\n+                        Some(e) => e,\n+                        None => {\n+                            fld.cx.span_err(\n+                                pth.span,\n+                                format!(\"non-expression macro in expression position: {}\",\n+                                        extnamestr.get().as_slice()\n+                                        ).as_slice());\n+                            return None;\n+                        }\n+                    };\n+                    Some(mark_thunk(parsed,fm))\n+                }\n+                _ => {\n+                    fld.cx.span_err(\n+                        pth.span,\n+                        format!(\"'{}' is not a tt-style macro\",\n+                                extnamestr.get()).as_slice());\n+                    None\n+                }\n+            }\n+        }\n+    }\n+}\n+\n /// Rename loop label and expand its loop body\n ///\n /// The renaming procedure for loop is different in the sense that the loop\n@@ -543,75 +561,27 @@ fn expand_item_mac(it: Gc<ast::Item>, fld: &mut MacroExpander)\n     return items;\n }\n \n-// expand a stmt\n+/// Expand a stmt\n+//\n+// I don't understand why this returns a vector... it looks like someone got\n+// half done adding machinery to allow macros to expand into multiple statements.\n fn expand_stmt(s: &Stmt, fld: &mut MacroExpander) -> SmallVector<Gc<Stmt>> {\n-    // why the copying here and not in expand_expr?\n-    // looks like classic changed-in-only-one-place\n-    let (pth, tts, semi) = match s.node {\n-        StmtMac(ref mac, semi) => {\n-            match mac.node {\n-                MacInvocTT(ref pth, ref tts, _) => {\n-                    (pth, (*tts).clone(), semi)\n-                }\n-            }\n-        }\n+    let (mac, semi) = match s.node {\n+        StmtMac(ref mac, semi) => (mac, semi),\n         _ => return expand_non_macro_stmt(s, fld)\n     };\n-    if pth.segments.len() > 1u {\n-        fld.cx.span_err(pth.span, \"expected macro name without module separators\");\n-        return SmallVector::zero();\n-    }\n-    let extname = pth.segments.get(0).identifier;\n-    let extnamestr = token::get_ident(extname);\n-    let marked_after = match fld.extsbox.find(&extname.name) {\n+    let expanded_stmt = match expand_mac_invoc(mac,s.span,\n+                                                |r|{r.make_stmt()},\n+                                                |sts,mrk|{mark_stmt(sts,mrk)},\n+                                                fld) {\n+        Some(stmt) => stmt,\n         None => {\n-            fld.cx.span_err(pth.span,\n-                            format!(\"macro undefined: '{}!'\",\n-                                    extnamestr).as_slice());\n-            return SmallVector::zero();\n-        }\n-\n-        Some(&NormalTT(ref expandfun, exp_span)) => {\n-            fld.cx.bt_push(ExpnInfo {\n-                call_site: s.span,\n-                callee: NameAndSpan {\n-                    name: extnamestr.get().to_string(),\n-                    format: MacroBang,\n-                    span: exp_span,\n-                }\n-            });\n-            let fm = fresh_mark();\n-            // mark before expansion:\n-            let marked_tts = mark_tts(tts.as_slice(), fm);\n-\n-            // See the comment in expand_expr for why we want the original span,\n-            // not the current mac.span.\n-            let mac_span = original_span(fld.cx);\n-\n-            let expanded = match expandfun.expand(fld.cx,\n-                                                  mac_span.call_site,\n-                                                  marked_tts.as_slice()).make_stmt() {\n-                Some(stmt) => stmt,\n-                None => {\n-                    fld.cx.span_err(pth.span,\n-                                    format!(\"non-statement macro in statement position: {}\",\n-                                            extnamestr).as_slice());\n-                    return SmallVector::zero();\n-                }\n-            };\n-\n-            mark_stmt(&*expanded,fm)\n-        }\n-\n-        _ => {\n-            fld.cx.span_err(pth.span, format!(\"'{}' is not a tt-style macro\",\n-                                              extnamestr).as_slice());\n             return SmallVector::zero();\n         }\n     };\n \n     // Keep going, outside-in.\n-    let fully_expanded = fld.fold_stmt(&*marked_after);\n+    let fully_expanded = fld.fold_stmt(&*expanded_stmt);\n     fld.cx.bt_pop();\n     let fully_expanded: SmallVector<Gc<Stmt>> = fully_expanded.move_iter()\n             .map(|s| box(GC) Spanned { span: s.span, node: s.node.clone() })"}]}