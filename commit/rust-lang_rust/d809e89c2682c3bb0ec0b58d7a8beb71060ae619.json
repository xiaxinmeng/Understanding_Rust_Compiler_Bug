{"sha": "d809e89c2682c3bb0ec0b58d7a8beb71060ae619", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ4MDllODljMjY4MmMzYmIwZWMwYjU4ZDdhOGJlYjcxMDYwYWU2MTk=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-12-11T23:16:36Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-12-14T00:14:28Z"}, "message": "Replace some Eq impls with deriving_eq", "tree": {"sha": "3e31eb1e518adf5f6c27dab2390b2973e95c7b6e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3e31eb1e518adf5f6c27dab2390b2973e95c7b6e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d809e89c2682c3bb0ec0b58d7a8beb71060ae619", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d809e89c2682c3bb0ec0b58d7a8beb71060ae619", "html_url": "https://github.com/rust-lang/rust/commit/d809e89c2682c3bb0ec0b58d7a8beb71060ae619", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d809e89c2682c3bb0ec0b58d7a8beb71060ae619/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "742f354ffb08d81f6977aabc78a854cced22b9d3", "url": "https://api.github.com/repos/rust-lang/rust/commits/742f354ffb08d81f6977aabc78a854cced22b9d3", "html_url": "https://github.com/rust-lang/rust/commit/742f354ffb08d81f6977aabc78a854cced22b9d3"}], "stats": {"total": 287, "additions": 24, "deletions": 263}, "files": [{"sha": "eb7d753ea08bab51ddf66a08e7003a6a25e02aed", "filename": "src/libcore/core.rc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d809e89c2682c3bb0ec0b58d7a8beb71060ae619/src%2Flibcore%2Fcore.rc", "raw_url": "https://github.com/rust-lang/rust/raw/d809e89c2682c3bb0ec0b58d7a8beb71060ae619/src%2Flibcore%2Fcore.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rc?ref=d809e89c2682c3bb0ec0b58d7a8beb71060ae619", "patch": "@@ -240,6 +240,8 @@ mod core {\n     pub const warn : u32 = 2_u32;\n     pub const info : u32 = 3_u32;\n     pub const debug : u32 = 4_u32;\n+\n+    pub use cmp;\n }\n \n "}, {"sha": "74b29f3a5f1caf213e6c3b7da00bf68868a871fc", "filename": "src/libcore/either.rs", "status": "modified", "additions": 1, "deletions": 20, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/d809e89c2682c3bb0ec0b58d7a8beb71060ae619/src%2Flibcore%2Feither.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d809e89c2682c3bb0ec0b58d7a8beb71060ae619/src%2Flibcore%2Feither.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Feither.rs?ref=d809e89c2682c3bb0ec0b58d7a8beb71060ae619", "patch": "@@ -18,6 +18,7 @@ use cmp::Eq;\n use result::Result;\n \n /// The either type\n+#[deriving_eq]\n pub enum Either<T, U> {\n     Left(T),\n     Right(U)\n@@ -141,26 +142,6 @@ pub pure fn unwrap_right<T,U>(eith: Either<T,U>) -> U {\n     }\n }\n \n-impl<T:Eq,U:Eq> Either<T,U> : Eq {\n-    pure fn eq(&self, other: &Either<T,U>) -> bool {\n-        match (*self) {\n-            Left(ref a) => {\n-                match (*other) {\n-                    Left(ref b) => (*a).eq(b),\n-                    Right(_) => false\n-                }\n-            }\n-            Right(ref a) => {\n-                match (*other) {\n-                    Left(_) => false,\n-                    Right(ref b) => (*a).eq(b)\n-                }\n-            }\n-        }\n-    }\n-    pure fn ne(&self, other: &Either<T,U>) -> bool { !(*self).eq(other) }\n-}\n-\n #[test]\n fn test_either_left() {\n     let val = Left(10);"}, {"sha": "1c9ad6ba81a2a9f651483aff129d086ba7561694", "filename": "src/libcore/extfmt.rs", "status": "modified", "additions": 1, "deletions": 16, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d809e89c2682c3bb0ec0b58d7a8beb71060ae619/src%2Flibcore%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d809e89c2682c3bb0ec0b58d7a8beb71060ae619/src%2Flibcore%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fextfmt.rs?ref=d809e89c2682c3bb0ec0b58d7a8beb71060ae619", "patch": "@@ -445,24 +445,9 @@ pub mod rt {\n             };\n     }\n \n+    #[deriving_eq]\n     pub enum PadMode { PadSigned, PadUnsigned, PadNozero, PadFloat }\n \n-    pub impl PadMode : Eq {\n-        pure fn eq(&self, other: &PadMode) -> bool {\n-            match ((*self), (*other)) {\n-                (PadSigned, PadSigned) => true,\n-                (PadUnsigned, PadUnsigned) => true,\n-                (PadNozero, PadNozero) => true,\n-                (PadFloat, PadFloat) => true,\n-                (PadSigned, _) => false,\n-                (PadUnsigned, _) => false,\n-                (PadNozero, _) => false,\n-                (PadFloat, _) => false\n-            }\n-        }\n-        pure fn ne(&self, other: &PadMode) -> bool { !(*self).eq(other) }\n-    }\n-\n     pub fn pad(cv: Conv, s: ~str, mode: PadMode) -> ~str {\n         let mut s = move s; // sadtimes\n         let uwidth : uint = match cv.width {"}, {"sha": "098e24e03dd1f8c911e0c7be0f7d85a0f395a577", "filename": "src/libcore/io.rs", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d809e89c2682c3bb0ec0b58d7a8beb71060ae619/src%2Flibcore%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d809e89c2682c3bb0ec0b58d7a8beb71060ae619/src%2Flibcore%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fio.rs?ref=d809e89c2682c3bb0ec0b58d7a8beb71060ae619", "patch": "@@ -523,18 +523,9 @@ pub pure fn with_str_reader<T>(s: &str, f: fn(Reader) -> T) -> T {\n pub enum FileFlag { Append, Create, Truncate, NoFlag, }\n \n // What type of writer are we?\n+#[deriving_eq]\n pub enum WriterType { Screen, File }\n \n-pub impl WriterType : Eq {\n-    pure fn eq(&self, other: &WriterType) -> bool {\n-        match ((*self), (*other)) {\n-            (Screen, Screen) | (File, File) => true,\n-            (Screen, _) | (File, _) => false\n-        }\n-    }\n-    pure fn ne(&self, other: &WriterType) -> bool { !(*self).eq(other) }\n-}\n-\n // FIXME (#2004): Seekable really should be orthogonal.\n // FIXME (#2004): eventually u64\n /// The raw underlying writer trait. All writers must implement this."}, {"sha": "f7de25bf021a567fd6cf798f87b1983ca29bef77", "filename": "src/libcore/option.rs", "status": "modified", "additions": 1, "deletions": 21, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d809e89c2682c3bb0ec0b58d7a8beb71060ae619/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d809e89c2682c3bb0ec0b58d7a8beb71060ae619/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=d809e89c2682c3bb0ec0b58d7a8beb71060ae619", "patch": "@@ -47,6 +47,7 @@ let unwrapped_msg = match move msg {\n use cmp::Eq;\n \n /// The option type\n+#[deriving_eq]\n pub enum Option<T> {\n     None,\n     Some(T),\n@@ -310,27 +311,6 @@ impl<T: Copy> Option<T> {\n     pure fn while_some(blk: fn(v: T) -> Option<T>) { while_some(self, blk) }\n }\n \n-impl<T: Eq> Option<T> : Eq {\n-    pure fn eq(&self, other: &Option<T>) -> bool {\n-        match (*self) {\n-            None => {\n-                match (*other) {\n-                    None => true,\n-                    Some(_) => false\n-                }\n-            }\n-            Some(ref self_contents) => {\n-                match (*other) {\n-                    None => false,\n-                    Some(ref other_contents) =>\n-                        (*self_contents).eq(other_contents)\n-                }\n-            }\n-        }\n-    }\n-    pure fn ne(&self, other: &Option<T>) -> bool { !(*self).eq(other) }\n-}\n-\n #[test]\n fn test_unwrap_ptr() {\n     let x = ~0;"}, {"sha": "cdd66364c1183f7c19af0b9cfec7e0eea8a4c458", "filename": "src/libcore/path.rs", "status": "modified", "additions": 2, "deletions": 18, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d809e89c2682c3bb0ec0b58d7a8beb71060ae619/src%2Flibcore%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d809e89c2682c3bb0ec0b58d7a8beb71060ae619/src%2Flibcore%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpath.rs?ref=d809e89c2682c3bb0ec0b58d7a8beb71060ae619", "patch": "@@ -20,6 +20,7 @@ Cross-platform file path handling\n \n use cmp::Eq;\n \n+#[deriving_eq]\n pub struct WindowsPath {\n     host: Option<~str>,\n     device: Option<~str>,\n@@ -31,6 +32,7 @@ pub pure fn WindowsPath(s: &str) -> WindowsPath {\n     from_str(s)\n }\n \n+#[deriving_eq]\n pub struct PosixPath {\n     is_absolute: bool,\n     components: ~[~str],\n@@ -356,24 +358,6 @@ impl PosixPath : ToStr {\n     }\n }\n \n-impl PosixPath : Eq {\n-    pure fn eq(&self, other: &PosixPath) -> bool {\n-        return (*self).is_absolute == (*other).is_absolute &&\n-            (*self).components == (*other).components;\n-    }\n-    pure fn ne(&self, other: &PosixPath) -> bool { !(*self).eq(other) }\n-}\n-\n-impl WindowsPath : Eq {\n-    pure fn eq(&self, other: &WindowsPath) -> bool {\n-        return (*self).host == (*other).host &&\n-            (*self).device == (*other).device &&\n-            (*self).is_absolute == (*other).is_absolute &&\n-            (*self).components == (*other).components;\n-    }\n-    pure fn ne(&self, other: &WindowsPath) -> bool { !(*self).eq(other) }\n-}\n-\n // FIXME (#3227): when default methods in traits are working, de-duplicate\n // PosixPath and WindowsPath, most of their methods are common.\n impl PosixPath : GenericPath {"}, {"sha": "46bef4dd68aea29d799e844bb73934c554afbf88", "filename": "src/libcore/repr.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d809e89c2682c3bb0ec0b58d7a8beb71060ae619/src%2Flibcore%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d809e89c2682c3bb0ec0b58d7a8beb71060ae619/src%2Flibcore%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frepr.rs?ref=d809e89c2682c3bb0ec0b58d7a8beb71060ae619", "patch": "@@ -518,20 +518,14 @@ fn test_repr2() {\n \n // Old non-factored implementation, transitional...\n \n+#[deriving_eq]\n enum EnumVisitState {\n     PreVariant,     // We're before the variant we're interested in.\n     InVariant,      // We're inside the variant we're interested in.\n     PostVariant,    // We're after the variant we're interested in.\n     Degenerate      // This is a degenerate enum (exactly 1 variant)\n }\n \n-impl EnumVisitState : cmp::Eq {\n-    pure fn eq(&self, other: &EnumVisitState) -> bool {\n-        ((*self) as uint) == ((*other) as uint)\n-    }\n-    pure fn ne(&self, other: &EnumVisitState) -> bool { !(*self).eq(other) }\n-}\n-\n struct EnumState {\n     end_ptr: *c_void,\n     state: EnumVisitState"}, {"sha": "a1e7df28872a8f22b571aea46fa03575dac32640", "filename": "src/libcore/result.rs", "status": "modified", "additions": 1, "deletions": 20, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/d809e89c2682c3bb0ec0b58d7a8beb71060ae619/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d809e89c2682c3bb0ec0b58d7a8beb71060ae619/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=d809e89c2682c3bb0ec0b58d7a8beb71060ae619", "patch": "@@ -19,6 +19,7 @@ use cmp::Eq;\n use either::Either;\n \n /// The result type\n+#[deriving_eq]\n pub enum Result<T, U> {\n     /// Contains the successful result value\n     Ok(T),\n@@ -374,26 +375,6 @@ pub fn unwrap_err<T, U>(res: Result<T, U>) -> U {\n     }\n }\n \n-impl<T:Eq,U:Eq> Result<T,U> : Eq {\n-    pure fn eq(&self, other: &Result<T,U>) -> bool {\n-        match (*self) {\n-            Ok(ref e0a) => {\n-                match (*other) {\n-                    Ok(ref e0b) => *e0a == *e0b,\n-                    _ => false\n-                }\n-            }\n-            Err(ref e0a) => {\n-                match (*other) {\n-                    Err(ref e0b) => *e0a == *e0b,\n-                    _ => false\n-                }\n-            }\n-        }\n-    }\n-    pure fn ne(&self, other: &Result<T,U>) -> bool { !(*self).eq(other) }\n-}\n-\n #[cfg(test)]\n #[allow(non_implicitly_copyable_typarams)]\n mod tests {"}, {"sha": "6db7aae16b03adfe065d830161d87e64474e2ef9", "filename": "src/libcore/task/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d809e89c2682c3bb0ec0b58d7a8beb71060ae619/src%2Flibcore%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d809e89c2682c3bb0ec0b58d7a8beb71060ae619/src%2Flibcore%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fmod.rs?ref=d809e89c2682c3bb0ec0b58d7a8beb71060ae619", "patch": "@@ -55,6 +55,7 @@ pub enum Task {\n     TaskHandle(task_id)\n }\n \n+// XXX: deriving\n impl Task : cmp::Eq {\n     pure fn eq(&self, other: &Task) -> bool { *(*self) == *(*other) }\n     pure fn ne(&self, other: &Task) -> bool { !(*self).eq(other) }"}, {"sha": "38540524daca3974847fab55c95eb42bb61695f8", "filename": "src/libstd/getopts.rs", "status": "modified", "additions": 10, "deletions": 115, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/d809e89c2682c3bb0ec0b58d7a8beb71060ae619/src%2Flibstd%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d809e89c2682c3bb0ec0b58d7a8beb71060ae619/src%2Flibstd%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fgetopts.rs?ref=d809e89c2682c3bb0ec0b58d7a8beb71060ae619", "patch": "@@ -79,16 +79,20 @@ use core::result::{Err, Ok};\n use core::option;\n use core::option::{Some, None};\n \n+#[deriving_eq]\n enum Name {\n     Long(~str),\n     Short(char),\n }\n \n+#[deriving_eq]\n enum HasArg { Yes, No, Maybe, }\n \n+#[deriving_eq]\n enum Occur { Req, Optional, Multi, }\n \n /// A description of a possible option\n+#[deriving_eq]\n pub struct Opt {\n     name: Name,\n     hasarg: HasArg,\n@@ -102,49 +106,6 @@ fn mkname(nm: &str) -> Name {\n         } else { Long(unm) };\n }\n \n-impl Name : Eq {\n-    pure fn eq(&self, other: &Name) -> bool {\n-        match (*self) {\n-            Long(ref e0a) => {\n-                match (*other) {\n-                    Long(ref e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-            Short(e0a) => {\n-                match (*other) {\n-                    Short(e0b) => e0a == e0b,\n-                    _ => false\n-                }\n-            }\n-        }\n-    }\n-    pure fn ne(&self, other: &Name) -> bool { !(*self).eq(other) }\n-}\n-\n-impl Occur : Eq {\n-    pure fn eq(&self, other: &Occur) -> bool {\n-        ((*self) as uint) == ((*other) as uint)\n-    }\n-    pure fn ne(&self, other: &Occur) -> bool { !(*self).eq(other) }\n-}\n-\n-impl HasArg : Eq {\n-    pure fn eq(&self, other: &HasArg) -> bool {\n-        ((*self) as uint) == ((*other) as uint)\n-    }\n-    pure fn ne(&self, other: &HasArg) -> bool { !(*self).eq(other) }\n-}\n-\n-impl Opt : Eq {\n-    pure fn eq(&self, other: &Opt) -> bool {\n-        (*self).name   == (*other).name   &&\n-        (*self).hasarg == (*other).hasarg &&\n-        (*self).occur  == (*other).occur\n-    }\n-    pure fn ne(&self, other: &Opt) -> bool { !(*self).eq(other) }\n-}\n-\n /// Create an option that is required and takes an argument\n pub fn reqopt(name: &str) -> Opt {\n     return Opt {name: mkname(name), hasarg: Yes, occur: Req};\n@@ -178,39 +139,20 @@ pub fn optmulti(name: &str) -> Opt {\n     return Opt {name: mkname(name), hasarg: Yes, occur: Multi};\n }\n \n+#[deriving_eq]\n enum Optval { Val(~str), Given, }\n \n /**\n  * The result of checking command line arguments. Contains a vector\n  * of matches and a vector of free strings.\n  */\n+#[deriving_eq]\n pub struct Matches {\n     opts: ~[Opt],\n     vals: ~[~[Optval]],\n     free: ~[~str]\n }\n \n-impl Optval : Eq {\n-    pure fn eq(&self, other: &Optval) -> bool {\n-        match (*self) {\n-            Val(ref s) => match *other { Val (ref os) => s == os,\n-                                          Given => false },\n-            Given       => match *other { Val(_) => false,\n-                                          Given => true }\n-        }\n-    }\n-    pure fn ne(&self, other: &Optval) -> bool { !(*self).eq(other) }\n-}\n-\n-impl Matches : Eq {\n-    pure fn eq(&self, other: &Matches) -> bool {\n-        (*self).opts == (*other).opts &&\n-        (*self).vals == (*other).vals &&\n-        (*self).free == (*other).free\n-    }\n-    pure fn ne(&self, other: &Matches) -> bool { !(*self).eq(other) }\n-}\n-\n fn is_arg(arg: &str) -> bool {\n     return arg.len() > 1 && arg[0] == '-' as u8;\n }\n@@ -230,6 +172,7 @@ fn find_opt(opts: &[Opt], nm: Name) -> Option<uint> {\n  * The type returned when the command line does not conform to the\n  * expected format. Pass this value to <fail_str> to get an error message.\n  */\n+#[deriving_eq]\n pub enum Fail_ {\n     ArgumentMissing(~str),\n     UnrecognizedOption(~str),\n@@ -238,35 +181,6 @@ pub enum Fail_ {\n     UnexpectedArgument(~str),\n }\n \n-impl Fail_ : Eq {\n-    // this whole thing should be easy to infer...\n-    pure fn eq(&self, other: &Fail_) -> bool {\n-        match (*self) {\n-            ArgumentMissing(ref s) => {\n-                match *other { ArgumentMissing(ref so)    => s == so,\n-                               _                          => false }\n-            }\n-            UnrecognizedOption(ref s) => {\n-                match *other { UnrecognizedOption(ref so) => s == so,\n-                               _                          => false }\n-            }\n-            OptionMissing(ref s) => {\n-                match *other { OptionMissing(ref so)      => s == so,\n-                               _                          => false }\n-            }\n-            OptionDuplicated(ref s) => {\n-                match *other { OptionDuplicated(ref so)   => s == so,\n-                               _                          => false }\n-            }\n-            UnexpectedArgument(ref s) => {\n-                match *other { UnexpectedArgument(ref so) => s == so,\n-                               _                          => false }\n-            }\n-        }\n-    }\n-    pure fn ne(&self, other: &Fail_) -> bool { !(*self).eq(other) }\n-}\n-\n /// Convert a `fail_` enum into an error string\n pub fn fail_str(f: Fail_) -> ~str {\n     return match f {\n@@ -523,6 +437,7 @@ pub fn opt_default(mm: &Matches, nm: &str, def: &str) -> Option<~str> {\n                            _      => Some::<~str>(str::from_slice(def)) }\n }\n \n+#[deriving_eq]\n enum FailType {\n     ArgumentMissing_,\n     UnrecognizedOption_,\n@@ -531,13 +446,6 @@ enum FailType {\n     UnexpectedArgument_,\n }\n \n-impl FailType : Eq {\n-    pure fn eq(&self, other: &FailType) -> bool {\n-        ((*self) as uint) == ((*other) as uint)\n-    }\n-    pure fn ne(&self, other: &FailType) -> bool { !(*self).eq(other) }\n-}\n-\n /** A module which provides a way to specify descriptions and\n  *  groups of short and long option names, together.\n  */\n@@ -546,6 +454,7 @@ pub mod groups {\n     /** one group of options, e.g., both -h and --help, along with\n      * their shared description and properties\n      */\n+    #[deriving_eq]\n     pub struct OptGroup {\n         short_name: ~str,\n         long_name: ~str,\n@@ -555,20 +464,6 @@ pub mod groups {\n         occur: Occur\n     }\n \n-    impl OptGroup : Eq {\n-        pure fn eq(&self, other: &OptGroup) -> bool {\n-            (*self).short_name == (*other).short_name &&\n-            (*self).long_name  == (*other).long_name  &&\n-            (*self).hint       == (*other).hint       &&\n-            (*self).desc       == (*other).desc       &&\n-            (*self).hasarg     == (*other).hasarg     &&\n-            (*self).occur      == (*other).occur\n-        }\n-        pure fn ne(&self, other: &OptGroup) -> bool {\n-            !self.eq(other)\n-        }\n-    }\n-\n     /// Create a long option that is required and takes an argument\n     pub fn reqopt(short_name: &str, long_name: &str,\n                   desc: &str, hint: &str) -> OptGroup {\n@@ -733,7 +628,7 @@ mod tests {\n     #[legacy_exports];\n     use opt = getopts;\n     use result::{Err, Ok};\n-    use opt::groups::OptGroup;\n+    use getopts::groups::OptGroup;\n \n     fn check_fail_type(f: Fail_, ft: FailType) {\n         match f {"}, {"sha": "6d2c10eb8274b6c16997b889db7d02258ac16f8e", "filename": "src/libstd/list.rs", "status": "modified", "additions": 1, "deletions": 20, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/d809e89c2682c3bb0ec0b58d7a8beb71060ae619/src%2Flibstd%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d809e89c2682c3bb0ec0b58d7a8beb71060ae619/src%2Flibstd%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flist.rs?ref=d809e89c2682c3bb0ec0b58d7a8beb71060ae619", "patch": "@@ -16,6 +16,7 @@ use core::option;\n use option::*;\n use option::{Some, None};\n \n+#[deriving_eq]\n pub enum List<T> {\n     Cons(T, @List<T>),\n     Nil,\n@@ -157,26 +158,6 @@ pub fn each<T>(l: @List<T>, f: fn(&T) -> bool) {\n     }\n }\n \n-impl<T:Eq> List<T> : Eq {\n-    pure fn eq(&self, other: &List<T>) -> bool {\n-        match (*self) {\n-            Cons(ref e0a, e1a) => {\n-                match (*other) {\n-                    Cons(ref e0b, e1b) => e0a == e0b && e1a == e1b,\n-                    _ => false\n-                }\n-            }\n-            Nil => {\n-                match (*other) {\n-                    Nil => true,\n-                    _ => false\n-                }\n-            }\n-        }\n-    }\n-    pure fn ne(&self, other: &List<T>) -> bool { !(*self).eq(other) }\n-}\n-\n #[cfg(test)]\n mod tests {\n     #[legacy_exports];"}, {"sha": "2bf735dd584e9c5adebf080d12692bffbf1153d8", "filename": "src/libstd/test.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d809e89c2682c3bb0ec0b58d7a8beb71060ae619/src%2Flibstd%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d809e89c2682c3bb0ec0b58d7a8beb71060ae619/src%2Flibstd%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftest.rs?ref=d809e89c2682c3bb0ec0b58d7a8beb71060ae619", "patch": "@@ -92,15 +92,9 @@ fn parse_opts(args: &[~str]) -> OptRes {\n     return either::Left(test_opts);\n }\n \n+#[deriving_eq]\n pub enum TestResult { TrOk, TrFailed, TrIgnored, }\n \n-impl TestResult : Eq {\n-    pure fn eq(&self, other: &TestResult) -> bool {\n-        ((*self) as uint) == ((*other) as uint)\n-    }\n-    pure fn ne(&self, other: &TestResult) -> bool { !(*self).eq(other) }\n-}\n-\n type ConsoleTestState =\n     @{out: io::Writer,\n       log_out: Option<io::Writer>,"}, {"sha": "71151c330606a6f14a61a5f979b8a6f325fd50e0", "filename": "src/libstd/workcache.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d809e89c2682c3bb0ec0b58d7a8beb71060ae619/src%2Flibstd%2Fworkcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d809e89c2682c3bb0ec0b58d7a8beb71060ae619/src%2Flibstd%2Fworkcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fworkcache.rs?ref=d809e89c2682c3bb0ec0b58d7a8beb71060ae619", "patch": "@@ -79,6 +79,7 @@ use serialization::{Serializer,Serializable,\n *\n */\n \n+#[deriving_eq]\n struct WorkKey {\n     kind: ~str,\n     name: ~str\n@@ -100,15 +101,6 @@ impl WorkKey {\n     }\n }\n \n-impl WorkKey: core::cmp::Eq {\n-    pure fn eq(&self, other: &WorkKey) -> bool {\n-        self.kind == other.kind && self.name == other.name\n-    }\n-    pure fn ne(&self, other: &WorkKey) -> bool {\n-        self.kind != other.kind || self.name != other.name\n-    }\n-}\n-\n type WorkMap = LinearMap<WorkKey, ~str>;\n \n struct Database {"}]}