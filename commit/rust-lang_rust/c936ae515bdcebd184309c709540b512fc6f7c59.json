{"sha": "c936ae515bdcebd184309c709540b512fc6f7c59", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM5MzZhZTUxNWJkY2ViZDE4NDMwOWM3MDk1NDBiNTEyZmM2ZjdjNTk=", "commit": {"author": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2012-07-18T19:58:59Z"}, "committer": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2012-07-18T21:07:35Z"}, "message": "Linked failure: Make joining a taskgroup O(1)", "tree": {"sha": "4aa7063592e224e5d1e417f51299a2bfb56e1d72", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4aa7063592e224e5d1e417f51299a2bfb56e1d72"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c936ae515bdcebd184309c709540b512fc6f7c59", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c936ae515bdcebd184309c709540b512fc6f7c59", "html_url": "https://github.com/rust-lang/rust/commit/c936ae515bdcebd184309c709540b512fc6f7c59", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c936ae515bdcebd184309c709540b512fc6f7c59/comments", "author": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e0ea67a2a60c694a6c3424d99e4692c2725b8506", "url": "https://api.github.com/repos/rust-lang/rust/commits/e0ea67a2a60c694a6c3424d99e4692c2725b8506", "html_url": "https://github.com/rust-lang/rust/commit/e0ea67a2a60c694a6c3424d99e4692c2725b8506"}], "stats": {"total": 53, "additions": 33, "deletions": 20}, "files": [{"sha": "f3608205e10c5ab3117569f1e59e355afb526a58", "filename": "src/libcore/task.rs", "status": "modified", "additions": 33, "deletions": 20, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/c936ae515bdcebd184309c709540b512fc6f7c59/src%2Flibcore%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c936ae515bdcebd184309c709540b512fc6f7c59/src%2Flibcore%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask.rs?ref=c936ae515bdcebd184309c709540b512fc6f7c59", "patch": "@@ -584,7 +584,8 @@ type rust_closure = libc::c_void;\n \n /* linked failure */\n \n-type taskgroup_arc = arc::exclusive<option<dvec::dvec<option<*rust_task>>>>;\n+type taskgroup_arc =\n+    arc::exclusive<option<(dvec::dvec<option<*rust_task>>,dvec::dvec<uint>)>>;\n \n class taskgroup {\n     // FIXME (#2816): Change dvec to an O(1) data structure (and change 'me'\n@@ -594,9 +595,6 @@ class taskgroup {\n     let me:         *rust_task;\n     let my_pos:     uint;\n     // let parent_group: taskgroup_arc; // FIXME (#1868) (bblum)\n-    // FIXME (#1868) XXX bblum: add a list of empty slots to get runtime back\n-    // Indicates whether this is the main (root) taskgroup. If so, failure\n-    // here should take down the entire runtime.\n     let is_main:    bool;\n     new(-tasks: taskgroup_arc, me: *rust_task, my_pos: uint, is_main: bool) {\n         self.tasks   = tasks;\n@@ -621,29 +619,40 @@ fn enlist_in_taskgroup(group_arc: taskgroup_arc,\n                        me: *rust_task) -> option<uint> {\n     do group_arc.with |_c, state| {\n         // If 'none', the group was failing. Can't enlist.\n-        do state.map |tasks| {\n+        let mut newstate = none;\n+        *state <-> newstate;\n+        if newstate.is_some() {\n+            let (tasks,empty_slots) = option::unwrap(newstate);\n             // Try to find an empty slot.\n-            alt tasks.position(|x| x == none) {\n-                some(empty_index) {\n-                    tasks.set_elt(empty_index, some(me));\n-                    empty_index\n-                }\n-                none {\n-                    tasks.push(some(me));\n-                    tasks.len() - 1\n-                }\n-            }\n+            let slotno = if empty_slots.len() > 0 {\n+                let empty_index = empty_slots.pop();\n+                assert tasks[empty_index] == none;\n+                tasks.set_elt(empty_index, some(me));\n+                empty_index\n+            } else {\n+                tasks.push(some(me));\n+                tasks.len() - 1\n+            };\n+            *state = some((tasks,empty_slots));\n+            some(slotno)\n+        } else {\n+            none\n         }\n     }\n }\n \n // NB: Runs in destructor/post-exit context. Can't 'fail'.\n fn leave_taskgroup(group_arc: taskgroup_arc, me: *rust_task, index: uint) {\n     do group_arc.with |_c, state| {\n+        let mut newstate = none;\n+        *state <-> newstate;\n         // If 'none', already failing and we've already gotten a kill signal.\n-        do state.map |tasks| {\n+        if newstate.is_some() {\n+            let (tasks,empty_slots) = option::unwrap(newstate);\n             assert tasks[index] == some(me);\n             tasks.set_elt(index, none);\n+            empty_slots.push(index);\n+            *state = some((tasks,empty_slots));\n         };\n     };\n }\n@@ -664,7 +673,8 @@ fn kill_taskgroup(group_arc: taskgroup_arc, me: *rust_task, index: uint,\n         // Might already be none, if somebody is failing simultaneously.\n         // That's ok; only one task needs to do the dirty work. (Might also\n         // see 'none' if somebody already failed and we got a kill signal.)\n-        do newstate.map |tasks| {\n+        if newstate.is_some() {\n+            let (tasks,_empty_slots) = option::unwrap(newstate);\n             // First remove ourself (killing ourself won't do much good). This\n             // is duplicated here to avoid having to lock twice.\n             assert tasks[index] == some(me);\n@@ -679,7 +689,9 @@ fn kill_taskgroup(group_arc: taskgroup_arc, me: *rust_task, index: uint,\n             if is_main {\n                 rustrt::rust_task_kill_all(me);\n             }\n-        };\n+            // Do NOT restore state to some(..)! It stays none to indicate\n+            // that the whole taskgroup is failing, to forbid new spawns.\n+        }\n         // (note: multiple tasks may reach this point)\n     };\n }\n@@ -700,7 +712,8 @@ fn share_parent_taskgroup() -> (taskgroup_arc, bool) {\n         }\n         none {\n             // Main task, doing first spawn ever.\n-            let tasks = arc::exclusive(some(dvec::from_elem(some(me))));\n+            let tasks = arc::exclusive(some((dvec::from_elem(some(me)),\n+                                             dvec::dvec())));\n             let group = @taskgroup(tasks.clone(), me, 0, true);\n             unsafe { local_set(me, taskgroup_key(), group); }\n             // Tell child task it's also in the main group.\n@@ -715,7 +728,7 @@ fn spawn_raw(opts: task_opts, +f: fn~()) {\n         share_parent_taskgroup()\n     } else {\n         // Detached from the parent group; create a new (non-main) one.\n-        (arc::exclusive(some(dvec::from_elem(none))), false)\n+        (arc::exclusive(some((dvec::dvec(),dvec::dvec()))), false)\n     };\n \n     unsafe {"}]}