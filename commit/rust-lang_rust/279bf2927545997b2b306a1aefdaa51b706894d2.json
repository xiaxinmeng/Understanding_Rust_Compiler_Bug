{"sha": "279bf2927545997b2b306a1aefdaa51b706894d2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI3OWJmMjkyNzU0NTk5N2IyYjMwNmExYWVmZGFhNTFiNzA2ODk0ZDI=", "commit": {"author": {"name": "Joshua Nelson", "email": "jyn514@gmail.com", "date": "2020-11-15T12:05:46Z"}, "committer": {"name": "Joshua Nelson", "email": "jyn514@gmail.com", "date": "2020-11-15T12:07:10Z"}, "message": "Get rid of `Class::None`\n\nThis is mostly me learning the codebase, so feel free to close the PR.\nIt does have the small benefit that we statically know rustdoc isn't\ngenerating useless `span`s, though.", "tree": {"sha": "8cf3b25c51a7414f405ad641e37dc1871527c8ab", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8cf3b25c51a7414f405ad641e37dc1871527c8ab"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/279bf2927545997b2b306a1aefdaa51b706894d2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/279bf2927545997b2b306a1aefdaa51b706894d2", "html_url": "https://github.com/rust-lang/rust/commit/279bf2927545997b2b306a1aefdaa51b706894d2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/279bf2927545997b2b306a1aefdaa51b706894d2/comments", "author": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "98d66340d6e63eda115afc8b0da1d87965881936", "url": "https://api.github.com/repos/rust-lang/rust/commits/98d66340d6e63eda115afc8b0da1d87965881936", "html_url": "https://github.com/rust-lang/rust/commit/98d66340d6e63eda115afc8b0da1d87965881936"}], "stats": {"total": 33, "additions": 16, "deletions": 17}, "files": [{"sha": "b1f0eb9036912b10ef0e672359bf963395f8a7f0", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/279bf2927545997b2b306a1aefdaa51b706894d2/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/279bf2927545997b2b306a1aefdaa51b706894d2/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=279bf2927545997b2b306a1aefdaa51b706894d2", "patch": "@@ -62,7 +62,6 @@ fn write_footer(out: &mut String, playground_button: Option<&str>) {\n /// How a span of text is classified. Mostly corresponds to token kinds.\n #[derive(Clone, Copy, Debug, Eq, PartialEq)]\n enum Class {\n-    None,\n     Comment,\n     DocComment,\n     Attribute,\n@@ -87,7 +86,6 @@ impl Class {\n     /// Returns the css class expected by rustdoc for each `Class`.\n     fn as_html(self) -> &'static str {\n         match self {\n-            Class::None => \"\",\n             Class::Comment => \"comment\",\n             Class::DocComment => \"doccomment\",\n             Class::Attribute => \"attribute\",\n@@ -110,7 +108,7 @@ impl Class {\n }\n \n enum Highlight<'a> {\n-    Token { text: &'a str, class: Class },\n+    Token { text: &'a str, class: Option<Class> },\n     EnterSpan { class: Class },\n     ExitSpan,\n }\n@@ -164,8 +162,9 @@ impl<'a> Classifier<'a> {\n     /// a couple of following ones as well.\n     fn advance(&mut self, token: TokenKind, text: &'a str, sink: &mut dyn FnMut(Highlight<'a>)) {\n         let lookahead = self.peek();\n+        let no_highlight = |sink: &mut dyn FnMut(_)| sink(Highlight::Token { text, class: None });\n         let class = match token {\n-            TokenKind::Whitespace => Class::None,\n+            TokenKind::Whitespace => return no_highlight(sink),\n             TokenKind::LineComment { doc_style } | TokenKind::BlockComment { doc_style, .. } => {\n                 if doc_style.is_some() {\n                     Class::DocComment\n@@ -190,12 +189,12 @@ impl<'a> Classifier<'a> {\n             TokenKind::And => match lookahead {\n                 Some(TokenKind::And) => {\n                     let _and = self.tokens.next();\n-                    sink(Highlight::Token { text: \"&&\", class: Class::Op });\n+                    sink(Highlight::Token { text: \"&&\", class: Some(Class::Op) });\n                     return;\n                 }\n                 Some(TokenKind::Eq) => {\n                     let _eq = self.tokens.next();\n-                    sink(Highlight::Token { text: \"&=\", class: Class::Op });\n+                    sink(Highlight::Token { text: \"&=\", class: Some(Class::Op) });\n                     return;\n                 }\n                 Some(TokenKind::Whitespace) => Class::Op,\n@@ -226,7 +225,7 @@ impl<'a> Classifier<'a> {\n             | TokenKind::At\n             | TokenKind::Tilde\n             | TokenKind::Colon\n-            | TokenKind::Unknown => Class::None,\n+            | TokenKind::Unknown => return no_highlight(sink),\n \n             TokenKind::Question => Class::QuestionMark,\n \n@@ -235,7 +234,7 @@ impl<'a> Classifier<'a> {\n                     self.in_macro_nonterminal = true;\n                     Class::MacroNonTerminal\n                 }\n-                _ => Class::None,\n+                _ => return no_highlight(sink),\n             },\n \n             // This might be the start of an attribute. We're going to want to\n@@ -251,8 +250,8 @@ impl<'a> Classifier<'a> {\n                             self.in_attribute = true;\n                             sink(Highlight::EnterSpan { class: Class::Attribute });\n                         }\n-                        sink(Highlight::Token { text: \"#\", class: Class::None });\n-                        sink(Highlight::Token { text: \"!\", class: Class::None });\n+                        sink(Highlight::Token { text: \"#\", class: None });\n+                        sink(Highlight::Token { text: \"!\", class: None });\n                         return;\n                     }\n                     // Case 2: #[outer_attribute]\n@@ -262,16 +261,16 @@ impl<'a> Classifier<'a> {\n                     }\n                     _ => (),\n                 }\n-                Class::None\n+                return no_highlight(sink);\n             }\n             TokenKind::CloseBracket => {\n                 if self.in_attribute {\n                     self.in_attribute = false;\n-                    sink(Highlight::Token { text: \"]\", class: Class::None });\n+                    sink(Highlight::Token { text: \"]\", class: None });\n                     sink(Highlight::ExitSpan);\n                     return;\n                 }\n-                Class::None\n+                return no_highlight(sink);\n             }\n             TokenKind::Literal { kind, .. } => match kind {\n                 // Text literals.\n@@ -307,7 +306,7 @@ impl<'a> Classifier<'a> {\n         };\n         // Anything that didn't return above is the simple case where we the\n         // class just spans a single token, so we can use the `string` method.\n-        sink(Highlight::Token { text, class });\n+        sink(Highlight::Token { text, class: Some(class) });\n     }\n \n     fn peek(&mut self) -> Option<TokenKind> {\n@@ -337,10 +336,10 @@ fn exit_span(out: &mut String) {\n /// ```\n /// The latter can be thought of as a shorthand for the former, which is more\n /// flexible.\n-fn string<T: Display>(out: &mut String, text: T, klass: Class) {\n+fn string<T: Display>(out: &mut String, text: T, klass: Option<Class>) {\n     match klass {\n-        Class::None => write!(out, \"{}\", text).unwrap(),\n-        klass => write!(out, \"<span class=\\\"{}\\\">{}</span>\", klass.as_html(), text).unwrap(),\n+        None => write!(out, \"{}\", text).unwrap(),\n+        Some(klass) => write!(out, \"<span class=\\\"{}\\\">{}</span>\", klass.as_html(), text).unwrap(),\n     }\n }\n "}]}