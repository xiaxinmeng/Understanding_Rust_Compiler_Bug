{"sha": "1113eb5cc07f19eab34fa7984f08a4ba9fd2c987", "node_id": "MDY6Q29tbWl0NzI0NzEyOjExMTNlYjVjYzA3ZjE5ZWFiMzRmYTc5ODRmMDhhNGJhOWZkMmM5ODc=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-12-21T14:29:40Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-12-21T14:29:40Z"}, "message": "Rollup merge of #67059 - TommasoBianchi:dropck_fix_pr, r=pnkfelix\n\nFix too restrictive checks on Drop impls\n\nFixes #34426. Fixes #58311.\n\nThis PR completes and extends #59497 (which has been inactive for a while now).\nThe problem generating both issues was that when checking that the `Predicate`s of the `Drop` impl are exactly the same as the ones of the struct definition, the check was essentially performed by a simple `==` operator, which was not handling correctly HRTBs and involved `Fn` types.\n\nThe implemented solution relies on the `relate` machinery to more correctly equate `Predicate`s, and on `anonymize_late_bound_regions` to handle HRTB in a more general way. As the `Relate` trait currently is implemented only for `TraitPredicate` and `ProjectionPredicate` (and as they were the ones generating problems), `relate` is used only for them while for other `Predicate`s the equality check is kept. I'm currently considering whether it would make sense to implement the `Relate` trait also for all other `Predicate`s to render the proposed solution more general.", "tree": {"sha": "fa2b0cd93202f26c9fe26bd435edca5f95c34607", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fa2b0cd93202f26c9fe26bd435edca5f95c34607"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1113eb5cc07f19eab34fa7984f08a4ba9fd2c987", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJd/ixVCRBK7hj4Ov3rIwAAdHIIACX41y992tORw1QtiFkPh64k\nOVfjhLPFrkbdZCiUPjb0GCWzXN2Z2KPTkZ8gc6DdU0hc2LP912SZ2AZaeiEqkLT8\nft9dy2EApiwBH1A81DB58TAP0yAQ7ka20Sr4Xbb9jjyiA4JCg7pPt6hLt2xXG2Qg\ncWJxZz7UxC+pzd0Ry4JCpZBbg/oJFvPo4AH7QVcrti5dUntzqZzpN3sx9hYAf+dy\nMSNUAFMfvQX7mhevE50aUAVi4cjOhqOodSFgpc+G/WQZFccO9SD8nHpelT4ApapE\nIWgnAP9QNzNB5Y6yKlDq5BWr7hbhMnu052VRwAT6BMMqo4O7ZQwLAKpF3ChrVJY=\n=1vP1\n-----END PGP SIGNATURE-----\n", "payload": "tree fa2b0cd93202f26c9fe26bd435edca5f95c34607\nparent c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06\nparent b08d697236b236e96b0e8e6894e05aefe5a11b39\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1576938580 +0100\ncommitter GitHub <noreply@github.com> 1576938580 +0100\n\nRollup merge of #67059 - TommasoBianchi:dropck_fix_pr, r=pnkfelix\n\nFix too restrictive checks on Drop impls\n\nFixes #34426. Fixes #58311.\n\nThis PR completes and extends #59497 (which has been inactive for a while now).\nThe problem generating both issues was that when checking that the `Predicate`s of the `Drop` impl are exactly the same as the ones of the struct definition, the check was essentially performed by a simple `==` operator, which was not handling correctly HRTBs and involved `Fn` types.\n\nThe implemented solution relies on the `relate` machinery to more correctly equate `Predicate`s, and on `anonymize_late_bound_regions` to handle HRTB in a more general way. As the `Relate` trait currently is implemented only for `TraitPredicate` and `ProjectionPredicate` (and as they were the ones generating problems), `relate` is used only for them while for other `Predicate`s the equality check is kept. I'm currently considering whether it would make sense to implement the `Relate` trait also for all other `Predicate`s to render the proposed solution more general.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1113eb5cc07f19eab34fa7984f08a4ba9fd2c987", "html_url": "https://github.com/rust-lang/rust/commit/1113eb5cc07f19eab34fa7984f08a4ba9fd2c987", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1113eb5cc07f19eab34fa7984f08a4ba9fd2c987/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06", "url": "https://api.github.com/repos/rust-lang/rust/commits/c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06", "html_url": "https://github.com/rust-lang/rust/commit/c64eecf4d0907095928fb36fd3a1dd5fb2d9ff06"}, {"sha": "b08d697236b236e96b0e8e6894e05aefe5a11b39", "url": "https://api.github.com/repos/rust-lang/rust/commits/b08d697236b236e96b0e8e6894e05aefe5a11b39", "html_url": "https://github.com/rust-lang/rust/commit/b08d697236b236e96b0e8e6894e05aefe5a11b39"}], "stats": {"total": 244, "additions": 227, "deletions": 17}, "files": [{"sha": "025bb05f63a4a069e35f176abdafce18b6b9f15a", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 139, "deletions": 17, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/1113eb5cc07f19eab34fa7984f08a4ba9fd2c987/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1113eb5cc07f19eab34fa7984f08a4ba9fd2c987/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=1113eb5cc07f19eab34fa7984f08a4ba9fd2c987", "patch": "@@ -2,13 +2,15 @@ use crate::check::regionck::RegionCtxt;\n \n use crate::hir;\n use crate::hir::def_id::DefId;\n+use crate::util::common::ErrorReported;\n use rustc::infer::outlives::env::OutlivesEnvironment;\n use rustc::infer::{InferOk, SuppressRegionErrors};\n use rustc::middle::region;\n use rustc::traits::{ObligationCause, TraitEngine, TraitEngineExt};\n+use rustc::ty::error::TypeError;\n+use rustc::ty::relate::{Relate, RelateResult, TypeRelation};\n use rustc::ty::subst::{Subst, SubstsRef};\n-use rustc::ty::{self, Ty, TyCtxt};\n-use crate::util::common::ErrorReported;\n+use rustc::ty::{self, Predicate, Ty, TyCtxt};\n \n use syntax_pos::Span;\n \n@@ -56,8 +58,10 @@ pub fn check_drop_impl(tcx: TyCtxt<'_>, drop_impl_did: DefId) -> Result<(), Erro\n             // already checked by coherence, but compilation may\n             // not have been terminated.\n             let span = tcx.def_span(drop_impl_did);\n-            tcx.sess.delay_span_bug(span,\n-                &format!(\"should have been rejected by coherence check: {}\", dtor_self_type));\n+            tcx.sess.delay_span_bug(\n+                span,\n+                &format!(\"should have been rejected by coherence check: {}\", dtor_self_type),\n+            );\n             Err(ErrorReported)\n         }\n     }\n@@ -85,10 +89,7 @@ fn ensure_drop_params_and_item_params_correspond<'tcx>(\n         let fresh_impl_self_ty = drop_impl_ty.subst(tcx, fresh_impl_substs);\n \n         let cause = &ObligationCause::misc(drop_impl_span, drop_impl_hir_id);\n-        match infcx\n-            .at(cause, impl_param_env)\n-            .eq(named_type, fresh_impl_self_ty)\n-        {\n+        match infcx.at(cause, impl_param_env).eq(named_type, fresh_impl_self_ty) {\n             Ok(InferOk { obligations, .. }) => {\n                 fulfillment_cx.register_predicate_obligations(infcx, obligations);\n             }\n@@ -99,12 +100,13 @@ fn ensure_drop_params_and_item_params_correspond<'tcx>(\n                     drop_impl_span,\n                     E0366,\n                     \"Implementations of Drop cannot be specialized\"\n-                ).span_note(\n+                )\n+                .span_note(\n                     item_span,\n                     \"Use same sequence of generic type and region \\\n                      parameters that is on the struct/enum definition\",\n                 )\n-                    .emit();\n+                .emit();\n                 return Err(ErrorReported);\n             }\n         }\n@@ -194,6 +196,8 @@ fn ensure_drop_predicates_are_implied_by_item_defn<'tcx>(\n     let assumptions_in_impl_context = generic_assumptions.instantiate(tcx, &self_to_impl_substs);\n     let assumptions_in_impl_context = assumptions_in_impl_context.predicates;\n \n+    let self_param_env = tcx.param_env(self_type_did);\n+\n     // An earlier version of this code attempted to do this checking\n     // via the traits::fulfill machinery. However, it ran into trouble\n     // since the fulfill machinery merely turns outlives-predicates\n@@ -207,27 +211,49 @@ fn ensure_drop_predicates_are_implied_by_item_defn<'tcx>(\n         // to take on a structure that is roughly an alpha-renaming of\n         // the generic parameters of the item definition.)\n \n-        // This path now just checks *all* predicates via the direct\n-        // lookup, rather than using fulfill machinery.\n+        // This path now just checks *all* predicates via an instantiation of\n+        // the `SimpleEqRelation`, which simply forwards to the `relate` machinery\n+        // after taking care of anonymizing late bound regions.\n         //\n         // However, it may be more efficient in the future to batch\n-        // the analysis together via the fulfill , rather than the\n-        // repeated `contains` calls.\n+        // the analysis together via the fulfill (see comment above regarding\n+        // the usage of the fulfill machinery), rather than the\n+        // repeated `.iter().any(..)` calls.\n \n-        if !assumptions_in_impl_context.contains(&predicate) {\n+        // This closure is a more robust way to check `Predicate` equality\n+        // than simple `==` checks (which were the previous implementation).\n+        // It relies on `ty::relate` for `TraitPredicate` and `ProjectionPredicate`\n+        // (which implement the Relate trait), while delegating on simple equality\n+        // for the other `Predicate`.\n+        // This implementation solves (Issue #59497) and (Issue #58311).\n+        // It is unclear to me at the moment whether the approach based on `relate`\n+        // could be extended easily also to the other `Predicate`.\n+        let predicate_matches_closure = |p: &'_ Predicate<'tcx>| {\n+            let mut relator: SimpleEqRelation<'tcx> = SimpleEqRelation::new(tcx, self_param_env);\n+            match (predicate, p) {\n+                (Predicate::Trait(a), Predicate::Trait(b)) => relator.relate(a, b).is_ok(),\n+                (Predicate::Projection(a), Predicate::Projection(b)) => {\n+                    relator.relate(a, b).is_ok()\n+                }\n+                _ => predicate == p,\n+            }\n+        };\n+\n+        if !assumptions_in_impl_context.iter().any(predicate_matches_closure) {\n             let item_span = tcx.hir().span(self_type_hir_id);\n             struct_span_err!(\n                 tcx.sess,\n                 drop_impl_span,\n                 E0367,\n                 \"The requirement `{}` is added only by the Drop impl.\",\n                 predicate\n-            ).span_note(\n+            )\n+            .span_note(\n                 item_span,\n                 \"The same requirement must be part of \\\n                  the struct/enum definition\",\n             )\n-                .emit();\n+            .emit();\n             result = Err(ErrorReported);\n         }\n     }\n@@ -253,3 +279,99 @@ crate fn check_drop_obligations<'a, 'tcx>(\n \n     Ok(())\n }\n+\n+// This is an implementation of the TypeRelation trait with the\n+// aim of simply comparing for equality (without side-effects).\n+// It is not intended to be used anywhere else other than here.\n+crate struct SimpleEqRelation<'tcx> {\n+    tcx: TyCtxt<'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+}\n+\n+impl<'tcx> SimpleEqRelation<'tcx> {\n+    fn new(tcx: TyCtxt<'tcx>, param_env: ty::ParamEnv<'tcx>) -> SimpleEqRelation<'tcx> {\n+        SimpleEqRelation { tcx, param_env }\n+    }\n+}\n+\n+impl TypeRelation<'tcx> for SimpleEqRelation<'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx> {\n+        self.tcx\n+    }\n+\n+    fn param_env(&self) -> ty::ParamEnv<'tcx> {\n+        self.param_env\n+    }\n+\n+    fn tag(&self) -> &'static str {\n+        \"dropck::SimpleEqRelation\"\n+    }\n+\n+    fn a_is_expected(&self) -> bool {\n+        true\n+    }\n+\n+    fn relate_with_variance<T: Relate<'tcx>>(\n+        &mut self,\n+        _: ty::Variance,\n+        a: &T,\n+        b: &T,\n+    ) -> RelateResult<'tcx, T> {\n+        // Here we ignore variance because we require drop impl's types\n+        // to be *exactly* the same as to the ones in the struct definition.\n+        self.relate(a, b)\n+    }\n+\n+    fn tys(&mut self, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n+        debug!(\"SimpleEqRelation::tys(a={:?}, b={:?})\", a, b);\n+        ty::relate::super_relate_tys(self, a, b)\n+    }\n+\n+    fn regions(\n+        &mut self,\n+        a: ty::Region<'tcx>,\n+        b: ty::Region<'tcx>,\n+    ) -> RelateResult<'tcx, ty::Region<'tcx>> {\n+        debug!(\"SimpleEqRelation::regions(a={:?}, b={:?})\", a, b);\n+\n+        // We can just equate the regions because LBRs have been\n+        // already anonymized.\n+        if a == b {\n+            Ok(a)\n+        } else {\n+            // I'm not sure is this `TypeError` is the right one, but\n+            // it should not matter as it won't be checked (the dropck\n+            // will emit its own, more informative and higher-level errors\n+            // in case anything goes wrong).\n+            Err(TypeError::RegionsPlaceholderMismatch)\n+        }\n+    }\n+\n+    fn consts(\n+        &mut self,\n+        a: &'tcx ty::Const<'tcx>,\n+        b: &'tcx ty::Const<'tcx>,\n+    ) -> RelateResult<'tcx, &'tcx ty::Const<'tcx>> {\n+        debug!(\"SimpleEqRelation::consts(a={:?}, b={:?})\", a, b);\n+        ty::relate::super_relate_consts(self, a, b)\n+    }\n+\n+    fn binders<T>(\n+        &mut self,\n+        a: &ty::Binder<T>,\n+        b: &ty::Binder<T>,\n+    ) -> RelateResult<'tcx, ty::Binder<T>>\n+    where\n+        T: Relate<'tcx>,\n+    {\n+        debug!(\"SimpleEqRelation::binders({:?}: {:?}\", a, b);\n+\n+        // Anonymizing the LBRs is necessary to solve (Issue #59497).\n+        // After we do so, it should be totally fine to skip the binders.\n+        let anon_a = self.tcx.anonymize_late_bound_regions(a);\n+        let anon_b = self.tcx.anonymize_late_bound_regions(b);\n+        self.relate(anon_a.skip_binder(), anon_b.skip_binder())?;\n+\n+        Ok(a.clone())\n+    }\n+}"}, {"sha": "2934217df346e06057d94d5d723ae2a6f1a95ead", "filename": "src/test/ui/dropck/dropck_fn_type.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/1113eb5cc07f19eab34fa7984f08a4ba9fd2c987/src%2Ftest%2Fui%2Fdropck%2Fdropck_fn_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1113eb5cc07f19eab34fa7984f08a4ba9fd2c987/src%2Ftest%2Fui%2Fdropck%2Fdropck_fn_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdropck%2Fdropck_fn_type.rs?ref=1113eb5cc07f19eab34fa7984f08a4ba9fd2c987", "patch": "@@ -0,0 +1,20 @@\n+// run-pass\n+//! Regression test for #58311, regarding the usage of Fn types in drop impls\n+\n+// All of this Drop impls should compile.\n+\n+#[allow(dead_code)]\n+struct S<F: Fn() -> [u8; 1]>(F);\n+\n+impl<F: Fn() -> [u8; 1]> Drop for S<F> {\n+    fn drop(&mut self) {}\n+}\n+\n+#[allow(dead_code)]\n+struct P<A, F: FnOnce() -> [A; 10]>(F);\n+\n+impl<A, F: FnOnce() -> [A; 10]> Drop for P<A, F> {\n+    fn drop(&mut self) {}\n+}\n+\n+fn main() {}"}, {"sha": "98e8e88a2599553e6c94a5e8d9ba1bce423ccba0", "filename": "src/test/ui/dropck/dropck_traits.rs", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/1113eb5cc07f19eab34fa7984f08a4ba9fd2c987/src%2Ftest%2Fui%2Fdropck%2Fdropck_traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1113eb5cc07f19eab34fa7984f08a4ba9fd2c987/src%2Ftest%2Fui%2Fdropck%2Fdropck_traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdropck%2Fdropck_traits.rs?ref=1113eb5cc07f19eab34fa7984f08a4ba9fd2c987", "patch": "@@ -0,0 +1,68 @@\n+// run-pass\n+//! Regression test for #34426, regarding HRTB in drop impls\n+\n+// All of this Drop impls should compile.\n+\n+pub trait Lifetime<'a> {}\n+impl<'a> Lifetime<'a> for i32 {}\n+\n+#[allow(dead_code)]\n+struct Foo<L>\n+where\n+    for<'a> L: Lifetime<'a>,\n+{\n+    l: L,\n+}\n+\n+impl<L> Drop for Foo<L>\n+where\n+    for<'a> L: Lifetime<'a>,\n+{\n+    fn drop(&mut self) {}\n+}\n+\n+#[allow(dead_code)]\n+struct Foo2<L>\n+where\n+    for<'a> L: Lifetime<'a>,\n+{\n+    l: L,\n+}\n+\n+impl<T: for<'a> Lifetime<'a>> Drop for Foo2<T>\n+where\n+    for<'x> T: Lifetime<'x>,\n+{\n+    fn drop(&mut self) {}\n+}\n+\n+pub trait Lifetime2<'a, 'b> {}\n+impl<'a, 'b> Lifetime2<'a, 'b> for i32 {}\n+\n+#[allow(dead_code)]\n+struct Bar<L>\n+where\n+    for<'a, 'b> L: Lifetime2<'a, 'b>,\n+{\n+    l: L,\n+}\n+\n+impl<L> Drop for Bar<L>\n+where\n+    for<'a, 'b> L: Lifetime2<'a, 'b>,\n+{\n+    fn drop(&mut self) {}\n+}\n+\n+#[allow(dead_code)]\n+struct FnHolder<T: for<'a> Fn(&'a T, dyn for<'b> Lifetime2<'a, 'b>) -> u8>(T);\n+\n+impl<T: for<'a> Fn(&'a T, dyn for<'b> Lifetime2<'a, 'b>) -> u8> Drop for FnHolder<T> {\n+    fn drop(&mut self) {}\n+}\n+\n+fn main() {\n+    let _foo = Foo { l: 0 };\n+\n+    let _bar = Bar { l: 0 };\n+}"}]}