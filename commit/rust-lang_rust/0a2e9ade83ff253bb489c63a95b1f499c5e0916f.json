{"sha": "0a2e9ade83ff253bb489c63a95b1f499c5e0916f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBhMmU5YWRlODNmZjI1M2JiNDg5YzYzYTk1YjFmNDk5YzVlMDkxNmY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-11-29T12:17:45Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-11-29T12:17:45Z"}, "message": "Auto merge of #46362 - kennytm:rollup, r=kennytm\n\nRollup of 10 pull requests\n\n- Successful merges: #45969, #46077, #46219, #46287, #46293, #46322, #46323, #46330, #46354, #46356\n- Failed merges:", "tree": {"sha": "6fe2c8003b84d6e710ad6d57b77427b66b9c4ad4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6fe2c8003b84d6e710ad6d57b77427b66b9c4ad4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0a2e9ade83ff253bb489c63a95b1f499c5e0916f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0a2e9ade83ff253bb489c63a95b1f499c5e0916f", "html_url": "https://github.com/rust-lang/rust/commit/0a2e9ade83ff253bb489c63a95b1f499c5e0916f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0a2e9ade83ff253bb489c63a95b1f499c5e0916f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dc0e227745765c198958f0298785d18bcf61d4ae", "url": "https://api.github.com/repos/rust-lang/rust/commits/dc0e227745765c198958f0298785d18bcf61d4ae", "html_url": "https://github.com/rust-lang/rust/commit/dc0e227745765c198958f0298785d18bcf61d4ae"}, {"sha": "51bd916af49dff0e88cf3cd01d507aa5fabc6cf8", "url": "https://api.github.com/repos/rust-lang/rust/commits/51bd916af49dff0e88cf3cd01d507aa5fabc6cf8", "html_url": "https://github.com/rust-lang/rust/commit/51bd916af49dff0e88cf3cd01d507aa5fabc6cf8"}], "stats": {"total": 922, "additions": 404, "deletions": 518}, "files": [{"sha": "320759b923373762a24372e39ec58f17ac1e154e", "filename": ".travis.yml", "status": "modified", "additions": 26, "deletions": 10, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/0a2e9ade83ff253bb489c63a95b1f499c5e0916f/.travis.yml", "raw_url": "https://github.com/rust-lang/rust/raw/0a2e9ade83ff253bb489c63a95b1f499c5e0916f/.travis.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.travis.yml?ref=0a2e9ade83ff253bb489c63a95b1f499c5e0916f", "patch": "@@ -16,12 +16,11 @@ matrix:\n       if: type = pull_request OR branch = auto\n \n     - env: IMAGE=dist-x86_64-linux DEPLOY=1\n-      if: branch = auto\n+      if: branch = try OR branch = auto\n \n-    # \"alternate\" deployments, these are \"nightlies\" but don't have assertions\n-    # turned on, they're deployed to a different location primarily for projects\n-    # which are stuck on nightly and don't want llvm assertions in the artifacts\n-    # that they use.\n+    # \"alternate\" deployments, these are \"nightlies\" but have LLVM assertions\n+    # turned on, they're deployed to a different location primarily for\n+    # additional testing.\n     - env: IMAGE=dist-x86_64-linux DEPLOY_ALT=1\n       if: branch = try OR branch = auto\n \n@@ -312,22 +311,39 @@ deploy:\n       branch: auto\n       condition: $DEPLOY = 1\n \n+  # this is the same as the above deployment provider except that it uploads to\n+  # a slightly different directory and has a different trigger\n   - provider: s3\n     bucket: rust-lang-ci2\n     skip_cleanup: true\n     local_dir: deploy\n-    upload_dir: rustc-builds-try\n+    upload_dir: rustc-builds-alt\n     acl: public_read\n     region: us-west-1\n     access_key_id: AKIAJVBODR3IA4O72THQ\n     secret_access_key:\n       secure: \"kUGd3t7JcVWFESgIlzvsM8viZgCA9Encs3creW0xLJaLSeI1iVjlJK4h/2/nO6y224AFrh/GUfsNr4/4AlxPuYb8OU5oC5Lv+Ff2JiRDYtuNpyQSKAQp+bRYytWMtrmhja91h118Mbm90cUfcLPwkdiINgJNTXhPKg5Cqu3VYn0=\"\n     on:\n-      branch: try\n+      branch: auto\n       condition: $DEPLOY_ALT = 1\n \n-  # this is the same as the above deployment provider except that it uploads to\n-  # a slightly different directory and has a different trigger\n+  # These two providers are the same as the two above, except deploy on the\n+  # try branch. Travis does not appear to provide a way to use \"or\" in these\n+  # conditions.\n+  - provider: s3\n+    bucket: rust-lang-ci2\n+    skip_cleanup: true\n+    local_dir: deploy\n+    upload_dir: rustc-builds\n+    acl: public_read\n+    region: us-west-1\n+    access_key_id: AKIAJVBODR3IA4O72THQ\n+    secret_access_key:\n+      secure: \"kUGd3t7JcVWFESgIlzvsM8viZgCA9Encs3creW0xLJaLSeI1iVjlJK4h/2/nO6y224AFrh/GUfsNr4/4AlxPuYb8OU5oC5Lv+Ff2JiRDYtuNpyQSKAQp+bRYytWMtrmhja91h118Mbm90cUfcLPwkdiINgJNTXhPKg5Cqu3VYn0=\"\n+    on:\n+      branch: try\n+      condition: $DEPLOY = 1\n+\n   - provider: s3\n     bucket: rust-lang-ci2\n     skip_cleanup: true\n@@ -339,5 +355,5 @@ deploy:\n     secret_access_key:\n       secure: \"kUGd3t7JcVWFESgIlzvsM8viZgCA9Encs3creW0xLJaLSeI1iVjlJK4h/2/nO6y224AFrh/GUfsNr4/4AlxPuYb8OU5oC5Lv+Ff2JiRDYtuNpyQSKAQp+bRYytWMtrmhja91h118Mbm90cUfcLPwkdiINgJNTXhPKg5Cqu3VYn0=\"\n     on:\n-      branch: auto\n+      branch: try\n       condition: $DEPLOY_ALT = 1"}, {"sha": "0eee7fb722eabf7968cf5546ba798c2ddf7b0ea8", "filename": "src/liballoc/slice.rs", "status": "modified", "additions": 106, "deletions": 127, "changes": 233, "blob_url": "https://github.com/rust-lang/rust/blob/0a2e9ade83ff253bb489c63a95b1f499c5e0916f/src%2Fliballoc%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a2e9ade83ff253bb489c63a95b1f499c5e0916f/src%2Fliballoc%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fslice.rs?ref=0a2e9ade83ff253bb489c63a95b1f499c5e0916f", "patch": "@@ -1428,15 +1428,45 @@ impl<T> [T] {\n     ///\n     /// # Examples\n     ///\n+    /// Cloning two elements from a slice into another:\n+    ///\n+    /// ```\n+    /// let src = [1, 2, 3, 4];\n+    /// let mut dst = [0, 0];\n+    ///\n+    /// dst.clone_from_slice(&src[2..]);\n+    ///\n+    /// assert_eq!(src, [1, 2, 3, 4]);\n+    /// assert_eq!(dst, [3, 4]);\n+    /// ```\n+    ///\n+    /// Rust enforces that there can only be one mutable reference with no\n+    /// immutable references to a particular piece of data in a particular\n+    /// scope. Because of this, attempting to use `clone_from_slice` on a\n+    /// single slice will result in a compile failure:\n+    ///\n+    /// ```compile_fail\n+    /// let mut slice = [1, 2, 3, 4, 5];\n+    ///\n+    /// slice[..2].clone_from_slice(&slice[3..]); // compile fail!\n+    /// ```\n+    ///\n+    /// To work around this, we can use [`split_at_mut`] to create two distinct\n+    /// sub-slices from a slice:\n+    ///\n     /// ```\n-    /// let mut dst = [0, 0, 0];\n-    /// let src = [1, 2, 3];\n+    /// let mut slice = [1, 2, 3, 4, 5];\n     ///\n-    /// dst.clone_from_slice(&src);\n-    /// assert!(dst == [1, 2, 3]);\n+    /// {\n+    ///     let (left, right) = slice.split_at_mut(2);\n+    ///     left.clone_from_slice(&right[1..]);\n+    /// }\n+    ///\n+    /// assert_eq!(slice, [4, 5, 3, 4, 5]);\n     /// ```\n     ///\n     /// [`copy_from_slice`]: #method.copy_from_slice\n+    /// [`split_at_mut`]: #method.split_at_mut\n     #[stable(feature = \"clone_from_slice\", since = \"1.7.0\")]\n     pub fn clone_from_slice(&mut self, src: &[T]) where T: Clone {\n         core_slice::SliceExt::clone_from_slice(self, src)\n@@ -1454,15 +1484,45 @@ impl<T> [T] {\n     ///\n     /// # Examples\n     ///\n+    /// Copying two elements from a slice into another:\n+    ///\n+    /// ```\n+    /// let src = [1, 2, 3, 4];\n+    /// let mut dst = [0, 0];\n+    ///\n+    /// dst.copy_from_slice(&src[2..]);\n+    ///\n+    /// assert_eq!(src, [1, 2, 3, 4]);\n+    /// assert_eq!(dst, [3, 4]);\n+    /// ```\n+    ///\n+    /// Rust enforces that there can only be one mutable reference with no\n+    /// immutable references to a particular piece of data in a particular\n+    /// scope. Because of this, attempting to use `copy_from_slice` on a\n+    /// single slice will result in a compile failure:\n+    ///\n+    /// ```compile_fail\n+    /// let mut slice = [1, 2, 3, 4, 5];\n+    ///\n+    /// slice[..2].copy_from_slice(&slice[3..]); // compile fail!\n+    /// ```\n+    ///\n+    /// To work around this, we can use [`split_at_mut`] to create two distinct\n+    /// sub-slices from a slice:\n+    ///\n     /// ```\n-    /// let mut dst = [0, 0, 0];\n-    /// let src = [1, 2, 3];\n+    /// let mut slice = [1, 2, 3, 4, 5];\n     ///\n-    /// dst.copy_from_slice(&src);\n-    /// assert_eq!(src, dst);\n+    /// {\n+    ///     let (left, right) = slice.split_at_mut(2);\n+    ///     left.copy_from_slice(&right[1..]);\n+    /// }\n+    ///\n+    /// assert_eq!(slice, [4, 5, 3, 4, 5]);\n     /// ```\n     ///\n     /// [`clone_from_slice`]: #method.clone_from_slice\n+    /// [`split_at_mut`]: #method.split_at_mut\n     #[stable(feature = \"copy_from_slice\", since = \"1.9.0\")]\n     pub fn copy_from_slice(&mut self, src: &[T]) where T: Copy {\n         core_slice::SliceExt::copy_from_slice(self, src)\n@@ -1478,16 +1538,49 @@ impl<T> [T] {\n     ///\n     /// # Example\n     ///\n+    /// Swapping two elements across slices:\n+    ///\n+    /// ```\n+    /// #![feature(swap_with_slice)]\n+    ///\n+    /// let mut slice1 = [0, 0];\n+    /// let mut slice2 = [1, 2, 3, 4];\n+    ///\n+    /// slice1.swap_with_slice(&mut slice2[2..]);\n+    ///\n+    /// assert_eq!(slice1, [3, 4]);\n+    /// assert_eq!(slice2, [1, 2, 0, 0]);\n+    /// ```\n+    ///\n+    /// Rust enforces that there can only be one mutable reference to a\n+    /// particular piece of data in a particular scope. Because of this,\n+    /// attempting to use `swap_with_slice` on a single slice will result in\n+    /// a compile failure:\n+    ///\n+    /// ```compile_fail\n+    /// #![feature(swap_with_slice)]\n+    ///\n+    /// let mut slice = [1, 2, 3, 4, 5];\n+    /// slice[..2].swap_with_slice(&mut slice[3..]); // compile fail!\n+    /// ```\n+    ///\n+    /// To work around this, we can use [`split_at_mut`] to create two distinct\n+    /// mutable sub-slices from a slice:\n+    ///\n     /// ```\n     /// #![feature(swap_with_slice)]\n     ///\n-    /// let mut slice1 = [1, 2, 3];\n-    /// let mut slice2 = [7, 8, 9];\n+    /// let mut slice = [1, 2, 3, 4, 5];\n+    ///\n+    /// {\n+    ///     let (left, right) = slice.split_at_mut(2);\n+    ///     left.swap_with_slice(&mut right[1..]);\n+    /// }\n     ///\n-    /// slice1.swap_with_slice(&mut slice2);\n-    /// assert_eq!(slice1, [7, 8, 9]);\n-    /// assert_eq!(slice2, [1, 2, 3]);\n+    /// assert_eq!(slice, [4, 5, 3, 1, 2]);\n     /// ```\n+    ///\n+    /// [`split_at_mut`]: #method.split_at_mut\n     #[unstable(feature = \"swap_with_slice\", issue = \"44030\")]\n     pub fn swap_with_slice(&mut self, other: &mut [T]) {\n         core_slice::SliceExt::swap_with_slice(self, other)\n@@ -1626,120 +1719,6 @@ impl [u8] {\n             byte.make_ascii_lowercase();\n         }\n     }\n-\n-    /// Checks if all bytes of this slice are ASCII alphabetic characters:\n-    ///\n-    /// - U+0041 'A' ... U+005A 'Z', or\n-    /// - U+0061 'a' ... U+007A 'z'.\n-    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n-    #[inline]\n-    pub fn is_ascii_alphabetic(&self) -> bool {\n-        self.iter().all(|b| b.is_ascii_alphabetic())\n-    }\n-\n-    /// Checks if all bytes of this slice are ASCII uppercase characters:\n-    /// U+0041 'A' ... U+005A 'Z'.\n-    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n-    #[inline]\n-    pub fn is_ascii_uppercase(&self) -> bool {\n-        self.iter().all(|b| b.is_ascii_uppercase())\n-    }\n-\n-    /// Checks if all bytes of this slice are ASCII lowercase characters:\n-    /// U+0061 'a' ... U+007A 'z'.\n-    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n-    #[inline]\n-    pub fn is_ascii_lowercase(&self) -> bool {\n-        self.iter().all(|b| b.is_ascii_lowercase())\n-    }\n-\n-    /// Checks if all bytes of this slice are ASCII alphanumeric characters:\n-    ///\n-    /// - U+0041 'A' ... U+005A 'Z', or\n-    /// - U+0061 'a' ... U+007A 'z', or\n-    /// - U+0030 '0' ... U+0039 '9'.\n-    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n-    #[inline]\n-    pub fn is_ascii_alphanumeric(&self) -> bool {\n-        self.iter().all(|b| b.is_ascii_alphanumeric())\n-    }\n-\n-    /// Checks if all bytes of this slice are ASCII decimal digit:\n-    /// U+0030 '0' ... U+0039 '9'.\n-    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n-    #[inline]\n-    pub fn is_ascii_digit(&self) -> bool {\n-        self.iter().all(|b| b.is_ascii_digit())\n-    }\n-\n-    /// Checks if all bytes of this slice are ASCII hexadecimal digits:\n-    ///\n-    /// - U+0030 '0' ... U+0039 '9', or\n-    /// - U+0041 'A' ... U+0046 'F', or\n-    /// - U+0061 'a' ... U+0066 'f'.\n-    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n-    #[inline]\n-    pub fn is_ascii_hexdigit(&self) -> bool {\n-        self.iter().all(|b| b.is_ascii_hexdigit())\n-    }\n-\n-    /// Checks if all bytes of this slice are ASCII punctuation characters:\n-    ///\n-    /// - U+0021 ... U+002F `! \" # $ % & ' ( ) * + , - . /`, or\n-    /// - U+003A ... U+0040 `: ; < = > ? @`, or\n-    /// - U+005B ... U+0060 `[ \\\\ ] ^ _ \\``, or\n-    /// - U+007B ... U+007E `{ | } ~`\n-    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n-    #[inline]\n-    pub fn is_ascii_punctuation(&self) -> bool {\n-        self.iter().all(|b| b.is_ascii_punctuation())\n-    }\n-\n-    /// Checks if all bytes of this slice are ASCII graphic characters:\n-    /// U+0021 '@' ... U+007E '~'.\n-    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n-    #[inline]\n-    pub fn is_ascii_graphic(&self) -> bool {\n-        self.iter().all(|b| b.is_ascii_graphic())\n-    }\n-\n-    /// Checks if all bytes of this slice are ASCII whitespace characters:\n-    /// U+0020 SPACE, U+0009 HORIZONTAL TAB, U+000A LINE FEED,\n-    /// U+000C FORM FEED, or U+000D CARRIAGE RETURN.\n-    ///\n-    /// Rust uses the WhatWG Infra Standard's [definition of ASCII\n-    /// whitespace][infra-aw]. There are several other definitions in\n-    /// wide use. For instance, [the POSIX locale][pct] includes\n-    /// U+000B VERTICAL TAB as well as all the above characters,\n-    /// but\u2014from the very same specification\u2014[the default rule for\n-    /// \"field splitting\" in the Bourne shell][bfs] considers *only*\n-    /// SPACE, HORIZONTAL TAB, and LINE FEED as whitespace.\n-    ///\n-    /// If you are writing a program that will process an existing\n-    /// file format, check what that format's definition of whitespace is\n-    /// before using this function.\n-    ///\n-    /// [infra-aw]: https://infra.spec.whatwg.org/#ascii-whitespace\n-    /// [pct]: http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap07.html#tag_07_03_01\n-    /// [bfs]: http://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_06_05\n-    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n-    #[inline]\n-    pub fn is_ascii_whitespace(&self) -> bool {\n-        self.iter().all(|b| b.is_ascii_whitespace())\n-    }\n-\n-    /// Checks if all bytes of this slice are ASCII control characters:\n-    ///\n-    /// - U+0000 NUL ... U+001F UNIT SEPARATOR, or\n-    /// - U+007F DELETE.\n-    ///\n-    /// Note that most ASCII whitespace characters are control\n-    /// characters, but SPACE is not.\n-    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n-    #[inline]\n-    pub fn is_ascii_control(&self) -> bool {\n-        self.iter().all(|b| b.is_ascii_control())\n-    }\n }\n \n ////////////////////////////////////////////////////////////////////////////////"}, {"sha": "9755c5d54f24d0d648a0e444124f4d9086445f57", "filename": "src/liballoc/str.rs", "status": "modified", "additions": 0, "deletions": 147, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/0a2e9ade83ff253bb489c63a95b1f499c5e0916f/src%2Fliballoc%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a2e9ade83ff253bb489c63a95b1f499c5e0916f/src%2Fliballoc%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstr.rs?ref=0a2e9ade83ff253bb489c63a95b1f499c5e0916f", "patch": "@@ -2199,153 +2199,6 @@ impl str {\n         let me = unsafe { self.as_bytes_mut() };\n         me.make_ascii_lowercase()\n     }\n-\n-    /// Checks if all characters of this string are ASCII alphabetic\n-    /// characters:\n-    ///\n-    /// - U+0041 'A' ... U+005A 'Z', or\n-    /// - U+0061 'a' ... U+007A 'z'.\n-    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n-    #[inline]\n-    pub fn is_ascii_alphabetic(&self) -> bool {\n-        self.bytes().all(|b| b.is_ascii_alphabetic())\n-    }\n-\n-    /// Checks if all characters of this string are ASCII uppercase characters:\n-    /// U+0041 'A' ... U+005A 'Z'.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// #![feature(ascii_ctype)]\n-    ///\n-    /// // Only ascii uppercase characters\n-    /// assert!(\"HELLO\".is_ascii_uppercase());\n-    ///\n-    /// // While all characters are ascii, 'y' and 'e' are not uppercase\n-    /// assert!(!\"Bye\".is_ascii_uppercase());\n-    ///\n-    /// // While all characters are uppercase, '\u00dc' is not ascii\n-    /// assert!(!\"TSCH\u00dcSS\".is_ascii_uppercase());\n-    /// ```\n-    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n-    #[inline]\n-    pub fn is_ascii_uppercase(&self) -> bool {\n-        self.bytes().all(|b| b.is_ascii_uppercase())\n-    }\n-\n-    /// Checks if all characters of this string are ASCII lowercase characters:\n-    /// U+0061 'a' ... U+007A 'z'.\n-    ///\n-    /// # Example\n-    ///\n-    /// ```\n-    /// #![feature(ascii_ctype)]\n-    ///\n-    /// // Only ascii uppercase characters\n-    /// assert!(\"hello\".is_ascii_lowercase());\n-    ///\n-    /// // While all characters are ascii, 'B' is not lowercase\n-    /// assert!(!\"Bye\".is_ascii_lowercase());\n-    ///\n-    /// // While all characters are lowercase, '\u00dc' is not ascii\n-    /// assert!(!\"tsch\u00fcss\".is_ascii_lowercase());\n-    /// ```\n-    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n-    #[inline]\n-    pub fn is_ascii_lowercase(&self) -> bool {\n-        self.bytes().all(|b| b.is_ascii_lowercase())\n-    }\n-\n-    /// Checks if all characters of this string are ASCII alphanumeric\n-    /// characters:\n-    ///\n-    /// - U+0041 'A' ... U+005A 'Z', or\n-    /// - U+0061 'a' ... U+007A 'z', or\n-    /// - U+0030 '0' ... U+0039 '9'.\n-    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n-    #[inline]\n-    pub fn is_ascii_alphanumeric(&self) -> bool {\n-        self.bytes().all(|b| b.is_ascii_alphanumeric())\n-    }\n-\n-    /// Checks if all characters of this string are ASCII decimal digit:\n-    /// U+0030 '0' ... U+0039 '9'.\n-    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n-    #[inline]\n-    pub fn is_ascii_digit(&self) -> bool {\n-        self.bytes().all(|b| b.is_ascii_digit())\n-    }\n-\n-    /// Checks if all characters of this string are ASCII hexadecimal digits:\n-    ///\n-    /// - U+0030 '0' ... U+0039 '9', or\n-    /// - U+0041 'A' ... U+0046 'F', or\n-    /// - U+0061 'a' ... U+0066 'f'.\n-    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n-    #[inline]\n-    pub fn is_ascii_hexdigit(&self) -> bool {\n-        self.bytes().all(|b| b.is_ascii_hexdigit())\n-    }\n-\n-    /// Checks if all characters of this string are ASCII punctuation\n-    /// characters:\n-    ///\n-    /// - U+0021 ... U+002F `! \" # $ % & ' ( ) * + , - . /`, or\n-    /// - U+003A ... U+0040 `: ; < = > ? @`, or\n-    /// - U+005B ... U+0060 ``[ \\ ] ^ _ ` ``, or\n-    /// - U+007B ... U+007E `{ | } ~`\n-    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n-    #[inline]\n-    pub fn is_ascii_punctuation(&self) -> bool {\n-        self.bytes().all(|b| b.is_ascii_punctuation())\n-    }\n-\n-    /// Checks if all characters of this string are ASCII graphic characters:\n-    /// U+0021 '@' ... U+007E '~'.\n-    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n-    #[inline]\n-    pub fn is_ascii_graphic(&self) -> bool {\n-        self.bytes().all(|b| b.is_ascii_graphic())\n-    }\n-\n-    /// Checks if all characters of this string are ASCII whitespace characters:\n-    /// U+0020 SPACE, U+0009 HORIZONTAL TAB, U+000A LINE FEED,\n-    /// U+000C FORM FEED, or U+000D CARRIAGE RETURN.\n-    ///\n-    /// Rust uses the WhatWG Infra Standard's [definition of ASCII\n-    /// whitespace][infra-aw]. There are several other definitions in\n-    /// wide use. For instance, [the POSIX locale][pct] includes\n-    /// U+000B VERTICAL TAB as well as all the above characters,\n-    /// but\u2014from the very same specification\u2014[the default rule for\n-    /// \"field splitting\" in the Bourne shell][bfs] considers *only*\n-    /// SPACE, HORIZONTAL TAB, and LINE FEED as whitespace.\n-    ///\n-    /// If you are writing a program that will process an existing\n-    /// file format, check what that format's definition of whitespace is\n-    /// before using this function.\n-    ///\n-    /// [infra-aw]: https://infra.spec.whatwg.org/#ascii-whitespace\n-    /// [pct]: http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap07.html#tag_07_03_01\n-    /// [bfs]: http://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_06_05\n-    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n-    #[inline]\n-    pub fn is_ascii_whitespace(&self) -> bool {\n-        self.bytes().all(|b| b.is_ascii_whitespace())\n-    }\n-\n-    /// Checks if all characters of this string are ASCII control characters:\n-    ///\n-    /// - U+0000 NUL ... U+001F UNIT SEPARATOR, or\n-    /// - U+007F DELETE.\n-    ///\n-    /// Note that most ASCII whitespace characters are control\n-    /// characters, but SPACE is not.\n-    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n-    #[inline]\n-    pub fn is_ascii_control(&self) -> bool {\n-        self.bytes().all(|b| b.is_ascii_control())\n-    }\n }\n \n /// Converts a boxed slice of bytes to a boxed string slice without checking"}, {"sha": "d4cd3f6264efc9020318e4ef1b102ef6b62b82e5", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0a2e9ade83ff253bb489c63a95b1f499c5e0916f/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a2e9ade83ff253bb489c63a95b1f499c5e0916f/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=0a2e9ade83ff253bb489c63a95b1f499c5e0916f", "patch": "@@ -329,7 +329,6 @@ impl<T> Cell<T> {\n     /// let c = Cell::new(5);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_const_unstable(feature = \"const_cell_new\")]\n     #[inline]\n     pub const fn new(value: T) -> Cell<T> {\n         Cell {\n@@ -544,7 +543,6 @@ impl<T> RefCell<T> {\n     /// let c = RefCell::new(5);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_const_unstable(feature = \"const_refcell_new\")]\n     #[inline]\n     pub const fn new(value: T) -> RefCell<T> {\n         RefCell {\n@@ -1215,7 +1213,6 @@ impl<T> UnsafeCell<T> {\n     /// let uc = UnsafeCell::new(5);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_const_unstable(feature = \"const_unsafe_cell_new\")]\n     #[inline]\n     pub const fn new(value: T) -> UnsafeCell<T> {\n         UnsafeCell { value: value }"}, {"sha": "ee989854a3772e29362d6dc94250bb18b94a7b73", "filename": "src/libcore/fmt/num.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a2e9ade83ff253bb489c63a95b1f499c5e0916f/src%2Flibcore%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a2e9ade83ff253bb489c63a95b1f499c5e0916f/src%2Flibcore%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fnum.rs?ref=0a2e9ade83ff253bb489c63a95b1f499c5e0916f", "patch": "@@ -134,7 +134,7 @@ macro_rules! radix {\n     }\n }\n \n-radix! { Binary,    2, \"0b\", x @  0 ...  2 => b'0' + x }\n+radix! { Binary,    2, \"0b\", x @  0 ...  1 => b'0' + x }\n radix! { Octal,     8, \"0o\", x @  0 ...  7 => b'0' + x }\n radix! { Decimal,  10, \"\",   x @  0 ...  9 => b'0' + x }\n radix! { LowerHex, 16, \"0x\", x @  0 ...  9 => b'0' + x,"}, {"sha": "07b45ad6a50f6db62646e014bd2acebd893f1b63", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 0, "deletions": 34, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/0a2e9ade83ff253bb489c63a95b1f499c5e0916f/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a2e9ade83ff253bb489c63a95b1f499c5e0916f/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=0a2e9ade83ff253bb489c63a95b1f499c5e0916f", "patch": "@@ -85,47 +85,13 @@\n #![feature(prelude_import)]\n #![feature(repr_simd, platform_intrinsics)]\n #![feature(rustc_attrs)]\n-#![feature(rustc_const_unstable)]\n #![feature(specialization)]\n #![feature(staged_api)]\n #![feature(unboxed_closures)]\n #![feature(untagged_unions)]\n #![feature(unwind_attributes)]\n-#![feature(const_min_value)]\n-#![feature(const_max_value)]\n-#![feature(const_atomic_bool_new)]\n-#![feature(const_atomic_isize_new)]\n-#![feature(const_atomic_usize_new)]\n-#![feature(const_atomic_i8_new)]\n-#![feature(const_atomic_u8_new)]\n-#![feature(const_atomic_i16_new)]\n-#![feature(const_atomic_u16_new)]\n-#![feature(const_atomic_i32_new)]\n-#![feature(const_atomic_u32_new)]\n-#![feature(const_atomic_i64_new)]\n-#![feature(const_atomic_u64_new)]\n-#![feature(const_unsafe_cell_new)]\n-#![feature(const_cell_new)]\n-#![feature(const_nonzero_new)]\n #![cfg_attr(not(stage0), feature(doc_spotlight))]\n \n-#![cfg_attr(not(stage0), feature(const_min_value))]\n-#![cfg_attr(not(stage0), feature(const_max_value))]\n-#![cfg_attr(not(stage0), feature(const_atomic_bool_new))]\n-#![cfg_attr(not(stage0), feature(const_atomic_isize_new))]\n-#![cfg_attr(not(stage0), feature(const_atomic_usize_new))]\n-#![cfg_attr(not(stage0), feature(const_atomic_i8_new))]\n-#![cfg_attr(not(stage0), feature(const_atomic_u8_new))]\n-#![cfg_attr(not(stage0), feature(const_atomic_i16_new))]\n-#![cfg_attr(not(stage0), feature(const_atomic_u16_new))]\n-#![cfg_attr(not(stage0), feature(const_atomic_i32_new))]\n-#![cfg_attr(not(stage0), feature(const_atomic_u32_new))]\n-#![cfg_attr(not(stage0), feature(const_atomic_i64_new))]\n-#![cfg_attr(not(stage0), feature(const_atomic_u64_new))]\n-#![cfg_attr(not(stage0), feature(const_unsafe_cell_new))]\n-#![cfg_attr(not(stage0), feature(const_cell_new))]\n-#![cfg_attr(not(stage0), feature(const_nonzero_new))]\n-\n #[prelude_import]\n #[allow(unused)]\n use prelude::v1::*;"}, {"sha": "5b1a9399c39bfda3932cb975a1817706f85a342d", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a2e9ade83ff253bb489c63a95b1f499c5e0916f/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a2e9ade83ff253bb489c63a95b1f499c5e0916f/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=0a2e9ade83ff253bb489c63a95b1f499c5e0916f", "patch": "@@ -311,7 +311,6 @@ pub fn forget<T>(t: T) {\n /// [alignment]: ./fn.align_of.html\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_const_unstable(feature = \"const_size_of\")]\n pub const fn size_of<T>() -> usize {\n     unsafe { intrinsics::size_of::<T>() }\n }\n@@ -403,7 +402,6 @@ pub fn min_align_of_val<T: ?Sized>(val: &T) -> usize {\n /// ```\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_const_unstable(feature = \"const_align_of\")]\n pub const fn align_of<T>() -> usize {\n     unsafe { intrinsics::min_align_of::<T>() }\n }"}, {"sha": "2c966eb3b5794e2e15791d95136c5f4ab22a1721", "filename": "src/libcore/nonzero.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0a2e9ade83ff253bb489c63a95b1f499c5e0916f/src%2Flibcore%2Fnonzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a2e9ade83ff253bb489c63a95b1f499c5e0916f/src%2Flibcore%2Fnonzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnonzero.rs?ref=0a2e9ade83ff253bb489c63a95b1f499c5e0916f", "patch": "@@ -70,7 +70,6 @@ impl<T: Zeroable> NonZero<T> {\n     #[unstable(feature = \"nonzero\",\n                reason = \"needs an RFC to flesh out the design\",\n                issue = \"27730\")]\n-    #[rustc_const_unstable(feature = \"const_nonzero_new\")]\n     #[inline]\n     pub const unsafe fn new_unchecked(inner: T) -> Self {\n         NonZero(inner)"}, {"sha": "5b9dd4b1c6999d30884939d9a528b88e0f3860e6", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 10, "deletions": 14, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0a2e9ade83ff253bb489c63a95b1f499c5e0916f/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a2e9ade83ff253bb489c63a95b1f499c5e0916f/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=0a2e9ade83ff253bb489c63a95b1f499c5e0916f", "patch": "@@ -110,7 +110,6 @@ macro_rules! int_impl {\n         /// assert_eq!(i8::min_value(), -128);\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[rustc_const_unstable(feature = \"const_min_value\")]\n         #[inline]\n         pub const fn min_value() -> Self {\n             !0 ^ ((!0 as $UnsignedT) >> 1) as Self\n@@ -124,7 +123,6 @@ macro_rules! int_impl {\n         /// assert_eq!(i8::max_value(), 127);\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[rustc_const_unstable(feature = \"const_max_value\")]\n         #[inline]\n         pub const fn max_value() -> Self {\n             !Self::min_value()\n@@ -1290,7 +1288,6 @@ macro_rules! uint_impl {\n         /// assert_eq!(u8::min_value(), 0);\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[rustc_const_unstable(feature = \"const_min_value\")]\n         #[inline]\n         pub const fn min_value() -> Self { 0 }\n \n@@ -1302,7 +1299,6 @@ macro_rules! uint_impl {\n         /// assert_eq!(u8::max_value(), 255);\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        #[rustc_const_unstable(feature = \"const_max_value\")]\n         #[inline]\n         pub const fn max_value() -> Self { !0 }\n \n@@ -2438,7 +2434,7 @@ impl u8 {\n     /// assert!(!lf.is_ascii_alphabetic());\n     /// assert!(!esc.is_ascii_alphabetic());\n     /// ```\n-    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n+    #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n     #[inline]\n     pub fn is_ascii_alphabetic(&self) -> bool {\n         if *self >= 0x80 { return false; }\n@@ -2476,7 +2472,7 @@ impl u8 {\n     /// assert!(!lf.is_ascii_uppercase());\n     /// assert!(!esc.is_ascii_uppercase());\n     /// ```\n-    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n+    #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n     #[inline]\n     pub fn is_ascii_uppercase(&self) -> bool {\n         if *self >= 0x80 { return false }\n@@ -2514,7 +2510,7 @@ impl u8 {\n     /// assert!(!lf.is_ascii_lowercase());\n     /// assert!(!esc.is_ascii_lowercase());\n     /// ```\n-    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n+    #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n     #[inline]\n     pub fn is_ascii_lowercase(&self) -> bool {\n         if *self >= 0x80 { return false }\n@@ -2555,7 +2551,7 @@ impl u8 {\n     /// assert!(!lf.is_ascii_alphanumeric());\n     /// assert!(!esc.is_ascii_alphanumeric());\n     /// ```\n-    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n+    #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n     #[inline]\n     pub fn is_ascii_alphanumeric(&self) -> bool {\n         if *self >= 0x80 { return false }\n@@ -2593,7 +2589,7 @@ impl u8 {\n     /// assert!(!lf.is_ascii_digit());\n     /// assert!(!esc.is_ascii_digit());\n     /// ```\n-    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n+    #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n     #[inline]\n     pub fn is_ascii_digit(&self) -> bool {\n         if *self >= 0x80 { return false }\n@@ -2634,7 +2630,7 @@ impl u8 {\n     /// assert!(!lf.is_ascii_hexdigit());\n     /// assert!(!esc.is_ascii_hexdigit());\n     /// ```\n-    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n+    #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n     #[inline]\n     pub fn is_ascii_hexdigit(&self) -> bool {\n         if *self >= 0x80 { return false }\n@@ -2676,7 +2672,7 @@ impl u8 {\n     /// assert!(!lf.is_ascii_punctuation());\n     /// assert!(!esc.is_ascii_punctuation());\n     /// ```\n-    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n+    #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n     #[inline]\n     pub fn is_ascii_punctuation(&self) -> bool {\n         if *self >= 0x80 { return false }\n@@ -2714,7 +2710,7 @@ impl u8 {\n     /// assert!(!lf.is_ascii_graphic());\n     /// assert!(!esc.is_ascii_graphic());\n     /// ```\n-    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n+    #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n     #[inline]\n     pub fn is_ascii_graphic(&self) -> bool {\n         if *self >= 0x80 { return false; }\n@@ -2769,7 +2765,7 @@ impl u8 {\n     /// assert!(lf.is_ascii_whitespace());\n     /// assert!(!esc.is_ascii_whitespace());\n     /// ```\n-    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n+    #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n     #[inline]\n     pub fn is_ascii_whitespace(&self) -> bool {\n         if *self >= 0x80 { return false; }\n@@ -2809,7 +2805,7 @@ impl u8 {\n     /// assert!(lf.is_ascii_control());\n     /// assert!(esc.is_ascii_control());\n     /// ```\n-    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n+    #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n     #[inline]\n     pub fn is_ascii_control(&self) -> bool {\n         if *self >= 0x80 { return false; }"}, {"sha": "5e70c8283f454f0ffe0c1aad366bc9bc0e4c6506", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0a2e9ade83ff253bb489c63a95b1f499c5e0916f/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a2e9ade83ff253bb489c63a95b1f499c5e0916f/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=0a2e9ade83ff253bb489c63a95b1f499c5e0916f", "patch": "@@ -74,7 +74,6 @@ pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T) {\n /// ```\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_const_unstable(feature = \"const_ptr_null\")]\n pub const fn null<T>() -> *const T { 0 as *const T }\n \n /// Creates a null mutable raw pointer.\n@@ -89,7 +88,6 @@ pub const fn null<T>() -> *const T { 0 as *const T }\n /// ```\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_const_unstable(feature = \"const_ptr_null_mut\")]\n pub const fn null_mut<T>() -> *mut T { 0 as *mut T }\n \n /// Swaps the values at two mutable locations of the same type, without\n@@ -2347,7 +2345,6 @@ impl<T: ?Sized> Unique<T> {\n     ///\n     /// `ptr` must be non-null.\n     #[unstable(feature = \"unique\", issue = \"27730\")]\n-    #[rustc_const_unstable(feature = \"const_unique_new\")]\n     pub const unsafe fn new_unchecked(ptr: *mut T) -> Self {\n         Unique { pointer: NonZero::new_unchecked(ptr), _marker: PhantomData }\n     }\n@@ -2482,7 +2479,6 @@ impl<T: ?Sized> Shared<T> {\n     ///\n     /// `ptr` must be non-null.\n     #[unstable(feature = \"shared\", issue = \"27730\")]\n-    #[rustc_const_unstable(feature = \"const_shared_new\")]\n     pub const unsafe fn new_unchecked(ptr: *mut T) -> Self {\n         Shared { pointer: NonZero::new_unchecked(ptr), _marker: PhantomData }\n     }"}, {"sha": "4c6ff4d1bb475d99f16286e1c7cfd762e3947e76", "filename": "src/libcore/sync/atomic.rs", "status": "modified", "additions": 8, "deletions": 14, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/0a2e9ade83ff253bb489c63a95b1f499c5e0916f/src%2Flibcore%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a2e9ade83ff253bb489c63a95b1f499c5e0916f/src%2Flibcore%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsync%2Fatomic.rs?ref=0a2e9ade83ff253bb489c63a95b1f499c5e0916f", "patch": "@@ -242,7 +242,6 @@ impl AtomicBool {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_const_unstable(feature = \"const_atomic_bool_new\")]\n     pub const fn new(v: bool) -> AtomicBool {\n         AtomicBool { v: UnsafeCell::new(v as u8) }\n     }\n@@ -656,7 +655,6 @@ impl<T> AtomicPtr<T> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_const_unstable(feature = \"const_atomic_ptr_new\")]\n     pub const fn new(p: *mut T) -> AtomicPtr<T> {\n         AtomicPtr { p: UnsafeCell::new(p) }\n     }\n@@ -926,6 +924,13 @@ impl<T> AtomicPtr<T> {\n     }\n }\n \n+#[cfg(target_has_atomic = \"8\")]\n+#[stable(feature = \"atomic_bool_from\", since = \"1.24.0\")]\n+impl From<bool> for AtomicBool {\n+    #[inline]\n+    fn from(b: bool) -> Self { Self::new(b) }\n+}\n+\n #[cfg(target_has_atomic = \"ptr\")]\n #[stable(feature = \"atomic_from\", since = \"1.23.0\")]\n impl<T> From<*mut T> for AtomicPtr<T> {\n@@ -935,7 +940,7 @@ impl<T> From<*mut T> for AtomicPtr<T> {\n \n #[cfg(target_has_atomic = \"ptr\")]\n macro_rules! atomic_int {\n-    ($stable:meta, $const_unstable:meta,\n+    ($stable:meta,\n      $stable_cxchg:meta,\n      $stable_debug:meta,\n      $stable_access:meta,\n@@ -1004,7 +1009,6 @@ macro_rules! atomic_int {\n             /// ```\n             #[inline]\n             #[$stable]\n-            #[$const_unstable]\n             pub const fn new(v: $int_type) -> Self {\n                 $atomic_type {v: UnsafeCell::new(v)}\n             }\n@@ -1368,7 +1372,6 @@ macro_rules! atomic_int {\n #[cfg(target_has_atomic = \"8\")]\n atomic_int! {\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n-    rustc_const_unstable(feature = \"const_atomic_i8_new\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n@@ -1378,7 +1381,6 @@ atomic_int! {\n #[cfg(target_has_atomic = \"8\")]\n atomic_int! {\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n-    rustc_const_unstable(feature = \"const_atomic_u8_new\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n@@ -1388,7 +1390,6 @@ atomic_int! {\n #[cfg(target_has_atomic = \"16\")]\n atomic_int! {\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n-    rustc_const_unstable(feature = \"const_atomic_i16_new\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n@@ -1398,7 +1399,6 @@ atomic_int! {\n #[cfg(target_has_atomic = \"16\")]\n atomic_int! {\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n-    rustc_const_unstable(feature = \"const_atomic_u16_new\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n@@ -1408,7 +1408,6 @@ atomic_int! {\n #[cfg(target_has_atomic = \"32\")]\n atomic_int! {\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n-    rustc_const_unstable(feature = \"const_atomic_i32_new\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n@@ -1418,7 +1417,6 @@ atomic_int! {\n #[cfg(target_has_atomic = \"32\")]\n atomic_int! {\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n-    rustc_const_unstable(feature = \"const_atomic_u32_new\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n@@ -1428,7 +1426,6 @@ atomic_int! {\n #[cfg(target_has_atomic = \"64\")]\n atomic_int! {\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n-    rustc_const_unstable(feature = \"const_atomic_i64_new\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n@@ -1438,7 +1435,6 @@ atomic_int! {\n #[cfg(target_has_atomic = \"64\")]\n atomic_int! {\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n-    rustc_const_unstable(feature = \"const_atomic_u64_new\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n     unstable(feature = \"integer_atomics\", issue = \"32976\"),\n@@ -1448,7 +1444,6 @@ atomic_int! {\n #[cfg(target_has_atomic = \"ptr\")]\n atomic_int!{\n     stable(feature = \"rust1\", since = \"1.0.0\"),\n-    rustc_const_unstable(feature = \"const_atomic_isize_new\"),\n     stable(feature = \"extended_compare_and_swap\", since = \"1.10.0\"),\n     stable(feature = \"atomic_debug\", since = \"1.3.0\"),\n     stable(feature = \"atomic_access\", since = \"1.15.0\"),\n@@ -1458,7 +1453,6 @@ atomic_int!{\n #[cfg(target_has_atomic = \"ptr\")]\n atomic_int!{\n     stable(feature = \"rust1\", since = \"1.0.0\"),\n-    rustc_const_unstable(feature = \"const_atomic_usize_new\"),\n     stable(feature = \"extended_compare_and_swap\", since = \"1.10.0\"),\n     stable(feature = \"atomic_debug\", since = \"1.3.0\"),\n     stable(feature = \"atomic_access\", since = \"1.15.0\"),"}, {"sha": "0e445cdac358a1bbe0018816a787f753d0039a56", "filename": "src/libcore/tests/lib.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0a2e9ade83ff253bb489c63a95b1f499c5e0916f/src%2Flibcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a2e9ade83ff253bb489c63a95b1f499c5e0916f/src%2Flibcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Flib.rs?ref=0a2e9ade83ff253bb489c63a95b1f499c5e0916f", "patch": "@@ -42,10 +42,6 @@\n #![feature(try_trait)]\n #![feature(unique)]\n \n-#![feature(const_atomic_bool_new)]\n-#![feature(const_atomic_usize_new)]\n-#![feature(const_atomic_isize_new)]\n-\n extern crate core;\n extern crate test;\n "}, {"sha": "a8c80aaa0309ed75c5d4714d7ec40a519e4a3de7", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0a2e9ade83ff253bb489c63a95b1f499c5e0916f/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a2e9ade83ff253bb489c63a95b1f499c5e0916f/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=0a2e9ade83ff253bb489c63a95b1f499c5e0916f", "patch": "@@ -64,7 +64,6 @@\n #![feature(underscore_lifetimes)]\n #![feature(trace_macros)]\n #![feature(test)]\n-#![feature(const_atomic_bool_new)]\n \n #![recursion_limit=\"512\"]\n "}, {"sha": "7dea3dae0bcd1a3dbd7da417b59fc943eabbbb58", "filename": "src/librustc_apfloat/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a2e9ade83ff253bb489c63a95b1f499c5e0916f/src%2Flibrustc_apfloat%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a2e9ade83ff253bb489c63a95b1f499c5e0916f/src%2Flibrustc_apfloat%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_apfloat%2Flib.rs?ref=0a2e9ade83ff253bb489c63a95b1f499c5e0916f", "patch": "@@ -45,8 +45,6 @@\n #![deny(warnings)]\n #![forbid(unsafe_code)]\n \n-#![feature(const_max_value)]\n-#![feature(const_min_value)]\n #![feature(i128_type)]\n #![feature(slice_patterns)]\n #![feature(try_from)]"}, {"sha": "5e569e21de7b7bb21090ec53ec6c60b68498872a", "filename": "src/librustc_const_eval/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a2e9ade83ff253bb489c63a95b1f499c5e0916f/src%2Flibrustc_const_eval%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a2e9ade83ff253bb489c63a95b1f499c5e0916f/src%2Flibrustc_const_eval%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Flib.rs?ref=0a2e9ade83ff253bb489c63a95b1f499c5e0916f", "patch": "@@ -25,8 +25,6 @@\n #![feature(box_syntax)]\n #![feature(i128_type)]\n \n-#![feature(const_min_value)]\n-\n extern crate arena;\n #[macro_use] extern crate syntax;\n #[macro_use] extern crate log;"}, {"sha": "095b8bb50dc6c20fdd891b61e9c45c613802a207", "filename": "src/librustc_const_math/lib.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0a2e9ade83ff253bb489c63a95b1f499c5e0916f/src%2Flibrustc_const_math%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a2e9ade83ff253bb489c63a95b1f499c5e0916f/src%2Flibrustc_const_math%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_math%2Flib.rs?ref=0a2e9ade83ff253bb489c63a95b1f499c5e0916f", "patch": "@@ -22,9 +22,6 @@\n #![feature(i128)]\n #![feature(i128_type)]\n \n-#![feature(const_min_value)]\n-#![feature(const_max_value)]\n-\n extern crate rustc_apfloat;\n \n extern crate syntax;"}, {"sha": "619c0dc847ebcb0ed71a2ec4beb32cf55bed542e", "filename": "src/librustc_mir/diagnostics.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0a2e9ade83ff253bb489c63a95b1f499c5e0916f/src%2Flibrustc_mir%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a2e9ade83ff253bb489c63a95b1f499c5e0916f/src%2Flibrustc_mir%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdiagnostics.rs?ref=0a2e9ade83ff253bb489c63a95b1f499c5e0916f", "patch": "@@ -770,8 +770,6 @@ static B: &'static AtomicUsize = &A; // ok!\n You can also have this error while using a cell type:\n \n ```compile_fail,E0492\n-#![feature(const_cell_new)]\n-\n use std::cell::Cell;\n \n const A: Cell<usize> = Cell::new(1);\n@@ -798,8 +796,6 @@ However, if you still wish to use these types, you can achieve this by an unsafe\n wrapper:\n \n ```\n-#![feature(const_cell_new)]\n-\n use std::cell::Cell;\n use std::marker::Sync;\n "}, {"sha": "3d1bd81fe21a31f1aa1fc37e4059e51ad4c87ec4", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0a2e9ade83ff253bb489c63a95b1f499c5e0916f/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a2e9ade83ff253bb489c63a95b1f499c5e0916f/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=0a2e9ade83ff253bb489c63a95b1f499c5e0916f", "patch": "@@ -33,9 +33,6 @@\n #![feature(slice_patterns)]\n #![feature(conservative_impl_trait)]\n \n-#![feature(const_atomic_bool_new)]\n-#![feature(const_once_new)]\n-\n use rustc::dep_graph::WorkProduct;\n use syntax_pos::symbol::Symbol;\n "}, {"sha": "a9ea96134faf2aa7f7d2691c8138b5b1c6c65cf2", "filename": "src/librustc_trans/llvm_util.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0a2e9ade83ff253bb489c63a95b1f499c5e0916f/src%2Flibrustc_trans%2Fllvm_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a2e9ade83ff253bb489c63a95b1f499c5e0916f/src%2Flibrustc_trans%2Fllvm_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fllvm_util.rs?ref=0a2e9ade83ff253bb489c63a95b1f499c5e0916f", "patch": "@@ -85,7 +85,7 @@ const X86_WHITELIST: &'static [&'static str] = &[\"avx\\0\", \"avx2\\0\", \"bmi\\0\", \"bm\n                                                  \"avx512dq\\0\", \"avx512er\\0\",\n                                                  \"avx512f\\0\", \"avx512ifma\\0\",\n                                                  \"avx512pf\\0\", \"avx512vbmi\\0\",\n-                                                 \"avx512vl\\0\", \"avx512vpopcntdq\\0\"];\n+                                                 \"avx512vl\\0\", \"avx512vpopcntdq\\0\", \"mmx\\0\"];\n \n const HEXAGON_WHITELIST: &'static [&'static str] = &[\"hvx\\0\", \"hvx-double\\0\"];\n \n@@ -94,6 +94,8 @@ const POWERPC_WHITELIST: &'static [&'static str] = &[\"altivec\\0\",\n                                                      \"power8-vector\\0\", \"power9-vector\\0\",\n                                                      \"vsx\\0\"];\n \n+const MIPS_WHITELIST: &'static [&'static str] = &[\"msa\\0\"];\n+\n pub fn target_features(sess: &Session) -> Vec<Symbol> {\n     let target_machine = create_target_machine(sess);\n \n@@ -102,6 +104,7 @@ pub fn target_features(sess: &Session) -> Vec<Symbol> {\n         \"aarch64\" => AARCH64_WHITELIST,\n         \"x86\" | \"x86_64\" => X86_WHITELIST,\n         \"hexagon\" => HEXAGON_WHITELIST,\n+        \"mips\" | \"mips64\" => MIPS_WHITELIST,\n         \"powerpc\" | \"powerpc64\" => POWERPC_WHITELIST,\n         _ => &[],\n     };"}, {"sha": "312da2035744939518fadc2336579708d73e557b", "filename": "src/libstd/ascii.rs", "status": "modified", "additions": 166, "deletions": 43, "changes": 209, "blob_url": "https://github.com/rust-lang/rust/blob/0a2e9ade83ff253bb489c63a95b1f499c5e0916f/src%2Flibstd%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a2e9ade83ff253bb489c63a95b1f499c5e0916f/src%2Flibstd%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fascii.rs?ref=0a2e9ade83ff253bb489c63a95b1f499c5e0916f", "patch": "@@ -490,77 +490,199 @@ impl AsciiExt for [u8] {\n     }\n }\n \n-macro_rules! impl_by_delegating {\n-    ($ty:ty, $owned:ty) => {\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        impl AsciiExt for $ty {\n-            type Owned = $owned;\n+macro_rules! delegating_ascii_methods {\n+    () => {\n+        #[inline]\n+        fn is_ascii(&self) -> bool { self.is_ascii() }\n \n-            #[inline]\n-            fn is_ascii(&self) -> bool { self.is_ascii() }\n+        #[inline]\n+        fn to_ascii_uppercase(&self) -> Self::Owned { self.to_ascii_uppercase() }\n \n-            #[inline]\n-            fn to_ascii_uppercase(&self) -> Self::Owned { self.to_ascii_uppercase() }\n+        #[inline]\n+        fn to_ascii_lowercase(&self) -> Self::Owned { self.to_ascii_lowercase() }\n \n-            #[inline]\n-            fn to_ascii_lowercase(&self) -> Self::Owned { self.to_ascii_lowercase() }\n+        #[inline]\n+        fn eq_ignore_ascii_case(&self, o: &Self) -> bool { self.eq_ignore_ascii_case(o) }\n \n-            #[inline]\n-            fn eq_ignore_ascii_case(&self, o: &Self) -> bool { self.eq_ignore_ascii_case(o) }\n+        #[inline]\n+        fn make_ascii_uppercase(&mut self) { self.make_ascii_uppercase(); }\n \n-            #[inline]\n-            fn make_ascii_uppercase(&mut self) { self.make_ascii_uppercase(); }\n-\n-            #[inline]\n-            fn make_ascii_lowercase(&mut self) { self.make_ascii_lowercase(); }\n+        #[inline]\n+        fn make_ascii_lowercase(&mut self) { self.make_ascii_lowercase(); }\n+    }\n+}\n \n-            #[inline]\n-            fn is_ascii_alphabetic(&self) -> bool { self.is_ascii_alphabetic() }\n+macro_rules! delegating_ascii_ctype_methods {\n+    () => {\n+        #[inline]\n+        fn is_ascii_alphabetic(&self) -> bool { self.is_ascii_alphabetic() }\n \n-            #[inline]\n-            fn is_ascii_uppercase(&self) -> bool { self.is_ascii_uppercase() }\n+        #[inline]\n+        fn is_ascii_uppercase(&self) -> bool { self.is_ascii_uppercase() }\n \n-            #[inline]\n-            fn is_ascii_lowercase(&self) -> bool { self.is_ascii_lowercase() }\n+        #[inline]\n+        fn is_ascii_lowercase(&self) -> bool { self.is_ascii_lowercase() }\n \n-            #[inline]\n-            fn is_ascii_alphanumeric(&self) -> bool { self.is_ascii_alphanumeric() }\n+        #[inline]\n+        fn is_ascii_alphanumeric(&self) -> bool { self.is_ascii_alphanumeric() }\n \n-            #[inline]\n-            fn is_ascii_digit(&self) -> bool { self.is_ascii_digit() }\n+        #[inline]\n+        fn is_ascii_digit(&self) -> bool { self.is_ascii_digit() }\n \n-            #[inline]\n-            fn is_ascii_hexdigit(&self) -> bool { self.is_ascii_hexdigit() }\n+        #[inline]\n+        fn is_ascii_hexdigit(&self) -> bool { self.is_ascii_hexdigit() }\n \n-            #[inline]\n-            fn is_ascii_punctuation(&self) -> bool { self.is_ascii_punctuation() }\n+        #[inline]\n+        fn is_ascii_punctuation(&self) -> bool { self.is_ascii_punctuation() }\n \n-            #[inline]\n-            fn is_ascii_graphic(&self) -> bool { self.is_ascii_graphic() }\n+        #[inline]\n+        fn is_ascii_graphic(&self) -> bool { self.is_ascii_graphic() }\n \n-            #[inline]\n-            fn is_ascii_whitespace(&self) -> bool { self.is_ascii_whitespace() }\n+        #[inline]\n+        fn is_ascii_whitespace(&self) -> bool { self.is_ascii_whitespace() }\n \n-            #[inline]\n-            fn is_ascii_control(&self) -> bool { self.is_ascii_control() }\n-        }\n+        #[inline]\n+        fn is_ascii_control(&self) -> bool { self.is_ascii_control() }\n     }\n }\n \n-impl_by_delegating!(u8, u8);\n-impl_by_delegating!(char, char);\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl AsciiExt for u8 {\n+    type Owned = u8;\n+\n+    delegating_ascii_methods!();\n+    delegating_ascii_ctype_methods!();\n+}\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl AsciiExt for char {\n+    type Owned = char;\n+\n+    delegating_ascii_methods!();\n+    delegating_ascii_ctype_methods!();\n+}\n \n // FIXME(LukasKalbertodt): the macro invocation should replace the impl block\n // for `[u8]` above. But this is not possible until the stage0 compiler is new\n // enough to contain the inherent ascii methods for `[u8]`.\n #[cfg(not(stage0))]\n-impl_by_delegating!([u8], Vec<u8>);\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl AsciiExt for [u8] {\n+    type Owned = Vec<u8>;\n+\n+    delegating_ascii_methods!();\n+\n+    #[inline]\n+    fn is_ascii_alphabetic(&self) -> bool {\n+        self.iter().all(|b| b.is_ascii_alphabetic())\n+    }\n+\n+    #[inline]\n+    fn is_ascii_uppercase(&self) -> bool {\n+        self.iter().all(|b| b.is_ascii_uppercase())\n+    }\n+\n+    #[inline]\n+    fn is_ascii_lowercase(&self) -> bool {\n+        self.iter().all(|b| b.is_ascii_lowercase())\n+    }\n+\n+    #[inline]\n+    fn is_ascii_alphanumeric(&self) -> bool {\n+        self.iter().all(|b| b.is_ascii_alphanumeric())\n+    }\n+\n+    #[inline]\n+    fn is_ascii_digit(&self) -> bool {\n+        self.iter().all(|b| b.is_ascii_digit())\n+    }\n+\n+    #[inline]\n+    fn is_ascii_hexdigit(&self) -> bool {\n+        self.iter().all(|b| b.is_ascii_hexdigit())\n+    }\n+\n+    #[inline]\n+    fn is_ascii_punctuation(&self) -> bool {\n+        self.iter().all(|b| b.is_ascii_punctuation())\n+    }\n+\n+    #[inline]\n+    fn is_ascii_graphic(&self) -> bool {\n+        self.iter().all(|b| b.is_ascii_graphic())\n+    }\n+\n+    #[inline]\n+    fn is_ascii_whitespace(&self) -> bool {\n+        self.iter().all(|b| b.is_ascii_whitespace())\n+    }\n+\n+    #[inline]\n+    fn is_ascii_control(&self) -> bool {\n+        self.iter().all(|b| b.is_ascii_control())\n+    }\n+}\n \n // FIXME(LukasKalbertodt): the macro invocation should replace the impl block\n // for `str` above. But this is not possible until the stage0 compiler is new\n // enough to contain the inherent ascii methods for `str`.\n #[cfg(not(stage0))]\n-impl_by_delegating!(str, String);\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl AsciiExt for str {\n+    type Owned = String;\n+\n+    delegating_ascii_methods!();\n+\n+    #[inline]\n+    fn is_ascii_alphabetic(&self) -> bool {\n+        self.bytes().all(|b| b.is_ascii_alphabetic())\n+    }\n+\n+    #[inline]\n+    fn is_ascii_uppercase(&self) -> bool {\n+        self.bytes().all(|b| b.is_ascii_uppercase())\n+    }\n+\n+    #[inline]\n+    fn is_ascii_lowercase(&self) -> bool {\n+        self.bytes().all(|b| b.is_ascii_lowercase())\n+    }\n+\n+    #[inline]\n+    fn is_ascii_alphanumeric(&self) -> bool {\n+        self.bytes().all(|b| b.is_ascii_alphanumeric())\n+    }\n+\n+    #[inline]\n+    fn is_ascii_digit(&self) -> bool {\n+        self.bytes().all(|b| b.is_ascii_digit())\n+    }\n+\n+    #[inline]\n+    fn is_ascii_hexdigit(&self) -> bool {\n+        self.bytes().all(|b| b.is_ascii_hexdigit())\n+    }\n+\n+    #[inline]\n+    fn is_ascii_punctuation(&self) -> bool {\n+        self.bytes().all(|b| b.is_ascii_punctuation())\n+    }\n+\n+    #[inline]\n+    fn is_ascii_graphic(&self) -> bool {\n+        self.bytes().all(|b| b.is_ascii_graphic())\n+    }\n+\n+    #[inline]\n+    fn is_ascii_whitespace(&self) -> bool {\n+        self.bytes().all(|b| b.is_ascii_whitespace())\n+    }\n+\n+    #[inline]\n+    fn is_ascii_control(&self) -> bool {\n+        self.bytes().all(|b| b.is_ascii_control())\n+    }\n+}\n \n /// An iterator over the escaped version of a byte.\n ///\n@@ -684,6 +806,7 @@ mod tests {\n     //! Note that most of these tests are not testing `AsciiExt` methods, but\n     //! test inherent ascii methods of char, u8, str and [u8]. `AsciiExt` is\n     //! just using those methods, though.\n+    use super::AsciiExt;\n     use char::from_u32;\n \n     #[test]"}, {"sha": "bf177ac7f2c239c6091db5e2cc1db5e09f5ed524", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0a2e9ade83ff253bb489c63a95b1f499c5e0916f/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a2e9ade83ff253bb489c63a95b1f499c5e0916f/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=0a2e9ade83ff253bb489c63a95b1f499c5e0916f", "patch": "@@ -256,15 +256,6 @@\n #![feature(collections_range)]\n #![feature(compiler_builtins_lib)]\n #![feature(const_fn)]\n-#![feature(const_max_value)]\n-#![feature(const_atomic_bool_new)]\n-#![feature(const_atomic_isize_new)]\n-#![feature(const_atomic_usize_new)]\n-#![feature(const_unsafe_cell_new)]\n-#![feature(const_cell_new)]\n-#![feature(const_once_new)]\n-#![feature(const_ptr_null)]\n-#![feature(const_ptr_null_mut)]\n #![feature(core_float)]\n #![feature(core_intrinsics)]\n #![feature(dropck_eyepatch)]\n@@ -306,7 +297,6 @@\n #![feature(repr_align)]\n #![feature(repr_simd)]\n #![feature(rustc_attrs)]\n-#![feature(rustc_const_unstable)]\n #![feature(shared)]\n #![feature(sip_hash_13)]\n #![feature(slice_bytes)]\n@@ -331,7 +321,6 @@\n #![feature(doc_masked)]\n #![feature(doc_spotlight)]\n #![cfg_attr(test, feature(update_panic_count))]\n-#![cfg_attr(windows, feature(const_atomic_ptr_new))]\n #![cfg_attr(windows, feature(used))]\n \n #![default_lib_allocator]"}, {"sha": "2dd3aebe6108ee839a83e5088d387bc8f76e0a53", "filename": "src/libstd/sync/mpsc/mod.rs", "status": "modified", "additions": 66, "deletions": 5, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/0a2e9ade83ff253bb489c63a95b1f499c5e0916f/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a2e9ade83ff253bb489c63a95b1f499c5e0916f/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs?ref=0a2e9ade83ff253bb489c63a95b1f499c5e0916f", "patch": "@@ -1297,11 +1297,72 @@ impl<T> Receiver<T> {\n             Err(TryRecvError::Disconnected)\n                 => Err(RecvTimeoutError::Disconnected),\n             Err(TryRecvError::Empty)\n-                => self.recv_max_until(Instant::now() + timeout)\n+                => self.recv_deadline(Instant::now() + timeout)\n         }\n     }\n \n-    fn recv_max_until(&self, deadline: Instant) -> Result<T, RecvTimeoutError> {\n+    /// Attempts to wait for a value on this receiver, returning an error if the\n+    /// corresponding channel has hung up, or if `deadline` is reached.\n+    ///\n+    /// This function will always block the current thread if there is no data\n+    /// available and it's possible for more data to be sent. Once a message is\n+    /// sent to the corresponding [`Sender`][] (or [`SyncSender`]), then this\n+    /// receiver will wake up and return that message.\n+    ///\n+    /// If the corresponding [`Sender`] has disconnected, or it disconnects while\n+    /// this call is blocking, this call will wake up and return [`Err`] to\n+    /// indicate that no more messages can ever be received on this channel.\n+    /// However, since channels are buffered, messages sent before the disconnect\n+    /// will still be properly received.\n+    ///\n+    /// [`Sender`]: struct.Sender.html\n+    /// [`SyncSender`]: struct.SyncSender.html\n+    /// [`Err`]: ../../../std/result/enum.Result.html#variant.Err\n+    ///\n+    /// # Examples\n+    ///\n+    /// Successfully receiving value before reaching deadline:\n+    ///\n+    /// ```no_run\n+    /// #![feature(deadline_api)]\n+    /// use std::thread;\n+    /// use std::time::{Duration, Instant};\n+    /// use std::sync::mpsc;\n+    ///\n+    /// let (send, recv) = mpsc::channel();\n+    ///\n+    /// thread::spawn(move || {\n+    ///     send.send('a').unwrap();\n+    /// });\n+    ///\n+    /// assert_eq!(\n+    ///     recv.recv_deadline(Instant::now() + Duration::from_millis(400)),\n+    ///     Ok('a')\n+    /// );\n+    /// ```\n+    ///\n+    /// Receiving an error upon reaching deadline:\n+    ///\n+    /// ```no_run\n+    /// #![feature(deadline_api)]\n+    /// use std::thread;\n+    /// use std::time::{Duration, Instant};\n+    /// use std::sync::mpsc;\n+    ///\n+    /// let (send, recv) = mpsc::channel();\n+    ///\n+    /// thread::spawn(move || {\n+    ///     thread::sleep(Duration::from_millis(800));\n+    ///     send.send('a').unwrap();\n+    /// });\n+    ///\n+    /// assert_eq!(\n+    ///     recv.recv_deadline(Instant::now() + Duration::from_millis(400)),\n+    ///     Err(mpsc::RecvTimeoutError::Timeout)\n+    /// );\n+    /// ```\n+    #[unstable(feature = \"deadline_api\", issue = \"46316\")]\n+    pub fn recv_deadline(&self, deadline: Instant) -> Result<T, RecvTimeoutError> {\n         use self::RecvTimeoutError::*;\n \n         loop {\n@@ -1625,7 +1686,7 @@ impl<T: Send> error::Error for TrySendError<T> {\n     }\n }\n \n-#[stable(feature = \"mpsc_error_conversions\", since = \"1.23.0\")]\n+#[stable(feature = \"mpsc_error_conversions\", since = \"1.24.0\")]\n impl<T> From<SendError<T>> for TrySendError<T> {\n     fn from(err: SendError<T>) -> TrySendError<T> {\n         match err {\n@@ -1686,7 +1747,7 @@ impl error::Error for TryRecvError {\n     }\n }\n \n-#[stable(feature = \"mpsc_error_conversions\", since = \"1.23.0\")]\n+#[stable(feature = \"mpsc_error_conversions\", since = \"1.24.0\")]\n impl From<RecvError> for TryRecvError {\n     fn from(err: RecvError) -> TryRecvError {\n         match err {\n@@ -1727,7 +1788,7 @@ impl error::Error for RecvTimeoutError {\n     }\n }\n \n-#[stable(feature = \"mpsc_error_conversions\", since = \"1.23.0\")]\n+#[stable(feature = \"mpsc_error_conversions\", since = \"1.24.0\")]\n impl From<RecvError> for RecvTimeoutError {\n     fn from(err: RecvError) -> RecvTimeoutError {\n         match err {"}, {"sha": "6fd8b6a5bbae43c2f9b3db50638f8f662b494832", "filename": "src/libstd/sync/once.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0a2e9ade83ff253bb489c63a95b1f499c5e0916f/src%2Flibstd%2Fsync%2Fonce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a2e9ade83ff253bb489c63a95b1f499c5e0916f/src%2Flibstd%2Fsync%2Fonce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fonce.rs?ref=0a2e9ade83ff253bb489c63a95b1f499c5e0916f", "patch": "@@ -156,7 +156,6 @@ struct Finish {\n impl Once {\n     /// Creates a new `Once` value.\n     #[stable(feature = \"once_new\", since = \"1.2.0\")]\n-    #[rustc_const_unstable(feature = \"const_once_new\")]\n     pub const fn new() -> Once {\n         Once {\n             state: AtomicUsize::new(INCOMPLETE),"}, {"sha": "6b573e5011bfabc1bf1289ed2587a896d0579c34", "filename": "src/libstd_unicode/char.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0a2e9ade83ff253bb489c63a95b1f499c5e0916f/src%2Flibstd_unicode%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a2e9ade83ff253bb489c63a95b1f499c5e0916f/src%2Flibstd_unicode%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd_unicode%2Fchar.rs?ref=0a2e9ade83ff253bb489c63a95b1f499c5e0916f", "patch": "@@ -1109,7 +1109,7 @@ impl char {\n     /// assert!(!lf.is_ascii_alphabetic());\n     /// assert!(!esc.is_ascii_alphabetic());\n     /// ```\n-    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n+    #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n     #[inline]\n     pub fn is_ascii_alphabetic(&self) -> bool {\n         self.is_ascii() && (*self as u8).is_ascii_alphabetic()\n@@ -1143,7 +1143,7 @@ impl char {\n     /// assert!(!lf.is_ascii_uppercase());\n     /// assert!(!esc.is_ascii_uppercase());\n     /// ```\n-    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n+    #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n     #[inline]\n     pub fn is_ascii_uppercase(&self) -> bool {\n         self.is_ascii() && (*self as u8).is_ascii_uppercase()\n@@ -1177,7 +1177,7 @@ impl char {\n     /// assert!(!lf.is_ascii_lowercase());\n     /// assert!(!esc.is_ascii_lowercase());\n     /// ```\n-    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n+    #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n     #[inline]\n     pub fn is_ascii_lowercase(&self) -> bool {\n         self.is_ascii() && (*self as u8).is_ascii_lowercase()\n@@ -1214,7 +1214,7 @@ impl char {\n     /// assert!(!lf.is_ascii_alphanumeric());\n     /// assert!(!esc.is_ascii_alphanumeric());\n     /// ```\n-    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n+    #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n     #[inline]\n     pub fn is_ascii_alphanumeric(&self) -> bool {\n         self.is_ascii() && (*self as u8).is_ascii_alphanumeric()\n@@ -1248,7 +1248,7 @@ impl char {\n     /// assert!(!lf.is_ascii_digit());\n     /// assert!(!esc.is_ascii_digit());\n     /// ```\n-    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n+    #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n     #[inline]\n     pub fn is_ascii_digit(&self) -> bool {\n         self.is_ascii() && (*self as u8).is_ascii_digit()\n@@ -1285,7 +1285,7 @@ impl char {\n     /// assert!(!lf.is_ascii_hexdigit());\n     /// assert!(!esc.is_ascii_hexdigit());\n     /// ```\n-    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n+    #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n     #[inline]\n     pub fn is_ascii_hexdigit(&self) -> bool {\n         self.is_ascii() && (*self as u8).is_ascii_hexdigit()\n@@ -1323,7 +1323,7 @@ impl char {\n     /// assert!(!lf.is_ascii_punctuation());\n     /// assert!(!esc.is_ascii_punctuation());\n     /// ```\n-    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n+    #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n     #[inline]\n     pub fn is_ascii_punctuation(&self) -> bool {\n         self.is_ascii() && (*self as u8).is_ascii_punctuation()\n@@ -1357,7 +1357,7 @@ impl char {\n     /// assert!(!lf.is_ascii_graphic());\n     /// assert!(!esc.is_ascii_graphic());\n     /// ```\n-    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n+    #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n     #[inline]\n     pub fn is_ascii_graphic(&self) -> bool {\n         self.is_ascii() && (*self as u8).is_ascii_graphic()\n@@ -1408,7 +1408,7 @@ impl char {\n     /// assert!(lf.is_ascii_whitespace());\n     /// assert!(!esc.is_ascii_whitespace());\n     /// ```\n-    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n+    #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n     #[inline]\n     pub fn is_ascii_whitespace(&self) -> bool {\n         self.is_ascii() && (*self as u8).is_ascii_whitespace()\n@@ -1444,7 +1444,7 @@ impl char {\n     /// assert!(lf.is_ascii_control());\n     /// assert!(esc.is_ascii_control());\n     /// ```\n-    #[unstable(feature = \"ascii_ctype\", issue = \"39658\")]\n+    #[stable(feature = \"ascii_ctype_on_intrinsics\", since = \"1.24.0\")]\n     #[inline]\n     pub fn is_ascii_control(&self) -> bool {\n         self.is_ascii() && (*self as u8).is_ascii_control()"}, {"sha": "bc88ff9244c99bc39ca393f622654537b02d137d", "filename": "src/test/compile-fail-fulldeps/dropck_tarena_cycle_checked.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0a2e9ade83ff253bb489c63a95b1f499c5e0916f/src%2Ftest%2Fcompile-fail-fulldeps%2Fdropck_tarena_cycle_checked.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a2e9ade83ff253bb489c63a95b1f499c5e0916f/src%2Ftest%2Fcompile-fail-fulldeps%2Fdropck_tarena_cycle_checked.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fdropck_tarena_cycle_checked.rs?ref=0a2e9ade83ff253bb489c63a95b1f499c5e0916f", "patch": "@@ -17,7 +17,6 @@\n //  for the error message we see here.)\n \n #![feature(rustc_private)]\n-#![feature(const_atomic_usize_new)]\n \n extern crate arena;\n "}, {"sha": "823cb89b365ca6d580f5aa21a04d4411522f0aec", "filename": "src/test/compile-fail/const-fn-feature-flags.rs", "status": "removed", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/dc0e227745765c198958f0298785d18bcf61d4ae/src%2Ftest%2Fcompile-fail%2Fconst-fn-feature-flags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc0e227745765c198958f0298785d18bcf61d4ae/src%2Ftest%2Fcompile-fail%2Fconst-fn-feature-flags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-fn-feature-flags.rs?ref=dc0e227745765c198958f0298785d18bcf61d4ae", "patch": "@@ -1,24 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Test use of const fns in std using individual feature gates.\n-\n-use std::cell::Cell;\n-\n-const CELL: Cell<i32> = Cell::new(42); //~ERROR not yet stable as a const fn\n-    //~^HELP #![feature(const_cell_new)]\n-\n-fn main() {\n-    let v = CELL.get();\n-    CELL.set(v+1);\n-\n-    assert_eq!(CELL.get(), v);\n-}\n-"}, {"sha": "b6b7fa1a233d7a9d22a8a762a3ac6777f0fdf989", "filename": "src/test/compile-fail/dropck_trait_cycle_checked.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a2e9ade83ff253bb489c63a95b1f499c5e0916f/src%2Ftest%2Fcompile-fail%2Fdropck_trait_cycle_checked.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a2e9ade83ff253bb489c63a95b1f499c5e0916f/src%2Ftest%2Fcompile-fail%2Fdropck_trait_cycle_checked.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdropck_trait_cycle_checked.rs?ref=0a2e9ade83ff253bb489c63a95b1f499c5e0916f", "patch": "@@ -13,8 +13,6 @@\n //\n // (Compare against compile-fail/dropck_vec_cycle_checked.rs)\n \n-#![feature(const_atomic_usize_new)]\n-\n use std::cell::Cell;\n use id::Id;\n "}, {"sha": "07123c6949255a84c972cec9937a643c9baa6585", "filename": "src/test/compile-fail/issue-17718-const-borrow.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a2e9ade83ff253bb489c63a95b1f499c5e0916f/src%2Ftest%2Fcompile-fail%2Fissue-17718-const-borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a2e9ade83ff253bb489c63a95b1f499c5e0916f/src%2Ftest%2Fcompile-fail%2Fissue-17718-const-borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17718-const-borrow.rs?ref=0a2e9ade83ff253bb489c63a95b1f499c5e0916f", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(const_unsafe_cell_new)]\n-\n use std::cell::UnsafeCell;\n \n const A: UnsafeCell<usize> = UnsafeCell::new(1);"}, {"sha": "0fd31454596e645ece7c87be14ea4a34f29f3518", "filename": "src/test/compile-fail/issue-43733-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a2e9ade83ff253bb489c63a95b1f499c5e0916f/src%2Ftest%2Fcompile-fail%2Fissue-43733-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a2e9ade83ff253bb489c63a95b1f499c5e0916f/src%2Ftest%2Fcompile-fail%2Fissue-43733-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-43733-2.rs?ref=0a2e9ade83ff253bb489c63a95b1f499c5e0916f", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(const_fn, const_cell_new, const_unsafe_cell_new)]\n+#![feature(const_fn)]\n #![feature(cfg_target_thread_local, thread_local_internals)]\n \n // On platforms *without* `#[thread_local]`, use"}, {"sha": "3979790e3d4c7498cb09516281144873f4968106", "filename": "src/test/compile-fail/issue-7364.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a2e9ade83ff253bb489c63a95b1f499c5e0916f/src%2Ftest%2Fcompile-fail%2Fissue-7364.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a2e9ade83ff253bb489c63a95b1f499c5e0916f/src%2Ftest%2Fcompile-fail%2Fissue-7364.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-7364.rs?ref=0a2e9ade83ff253bb489c63a95b1f499c5e0916f", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(box_syntax, const_refcell_new)]\n+#![feature(box_syntax)]\n \n use std::cell::RefCell;\n "}, {"sha": "8fc910d8a6daa46a63be49e2039a6348c8cdc2e4", "filename": "src/test/debuginfo/constant-debug-locs.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0a2e9ade83ff253bb489c63a95b1f499c5e0916f/src%2Ftest%2Fdebuginfo%2Fconstant-debug-locs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a2e9ade83ff253bb489c63a95b1f499c5e0916f/src%2Ftest%2Fdebuginfo%2Fconstant-debug-locs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fconstant-debug-locs.rs?ref=0a2e9ade83ff253bb489c63a95b1f499c5e0916f", "patch": "@@ -15,7 +15,6 @@\n #![allow(dead_code, unused_variables)]\n #![feature(omit_gdb_pretty_printer_section)]\n #![omit_gdb_pretty_printer_section]\n-#![feature(const_unsafe_cell_new)]\n #![feature(static_mutex)]\n \n // This test makes sure that the compiler doesn't crash when trying to assign"}, {"sha": "adc72aa0ea23b5fed2f1ed33535e5269165ca50d", "filename": "src/test/run-pass-fulldeps/vector-sort-panic-safe.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0a2e9ade83ff253bb489c63a95b1f499c5e0916f/src%2Ftest%2Frun-pass-fulldeps%2Fvector-sort-panic-safe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a2e9ade83ff253bb489c63a95b1f499c5e0916f/src%2Ftest%2Frun-pass-fulldeps%2Fvector-sort-panic-safe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fvector-sort-panic-safe.rs?ref=0a2e9ade83ff253bb489c63a95b1f499c5e0916f", "patch": "@@ -12,7 +12,6 @@\n \n #![feature(rustc_private)]\n #![feature(sort_unstable)]\n-#![feature(const_atomic_usize_new)]\n \n extern crate rand;\n "}, {"sha": "4466a95cb39b950655b6fa6a131e61763375874a", "filename": "src/test/run-pass-valgrind/cast-enum-with-dtor.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0a2e9ade83ff253bb489c63a95b1f499c5e0916f/src%2Ftest%2Frun-pass-valgrind%2Fcast-enum-with-dtor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a2e9ade83ff253bb489c63a95b1f499c5e0916f/src%2Ftest%2Frun-pass-valgrind%2Fcast-enum-with-dtor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-valgrind%2Fcast-enum-with-dtor.rs?ref=0a2e9ade83ff253bb489c63a95b1f499c5e0916f", "patch": "@@ -11,7 +11,6 @@\n // no-prefer-dynamic\n \n #![allow(dead_code)]\n-#![feature(const_atomic_usize_new)]\n \n // check dtor calling order when casting enums.\n "}, {"sha": "5ceb1013ad811dae95339b9f71300b0bac42e718", "filename": "src/test/run-pass/associated-types-project-from-type-param-via-bound-in-where.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a2e9ade83ff253bb489c63a95b1f499c5e0916f/src%2Ftest%2Frun-pass%2Fassociated-types-project-from-type-param-via-bound-in-where.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a2e9ade83ff253bb489c63a95b1f499c5e0916f/src%2Ftest%2Frun-pass%2Fassociated-types-project-from-type-param-via-bound-in-where.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types-project-from-type-param-via-bound-in-where.rs?ref=0a2e9ade83ff253bb489c63a95b1f499c5e0916f", "patch": "@@ -12,8 +12,6 @@\n // `Item` originates in a where-clause, not the declaration of\n // `T`. Issue #20300.\n \n-#![feature(const_atomic_usize_new)]\n-\n use std::marker::{PhantomData};\n use std::sync::atomic::{AtomicUsize};\n use std::sync::atomic::Ordering::SeqCst;"}, {"sha": "2bc8b4b7ba032546c78df44c5c2b6a9493373c3d", "filename": "src/test/run-pass/auxiliary/issue-17718-aux.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a2e9ade83ff253bb489c63a95b1f499c5e0916f/src%2Ftest%2Frun-pass%2Fauxiliary%2Fissue-17718-aux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a2e9ade83ff253bb489c63a95b1f499c5e0916f/src%2Ftest%2Frun-pass%2Fauxiliary%2Fissue-17718-aux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauxiliary%2Fissue-17718-aux.rs?ref=0a2e9ade83ff253bb489c63a95b1f499c5e0916f", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(const_atomic_usize_new)]\n-\n use std::sync::atomic;\n \n pub const C1: usize = 1;"}, {"sha": "e9457886be80d890a5e8287823777ab2508e1ed9", "filename": "src/test/run-pass/auxiliary/thread-local-extern-static.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0a2e9ade83ff253bb489c63a95b1f499c5e0916f/src%2Ftest%2Frun-pass%2Fauxiliary%2Fthread-local-extern-static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a2e9ade83ff253bb489c63a95b1f499c5e0916f/src%2Ftest%2Frun-pass%2Fauxiliary%2Fthread-local-extern-static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauxiliary%2Fthread-local-extern-static.rs?ref=0a2e9ade83ff253bb489c63a95b1f499c5e0916f", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n #![feature(cfg_target_thread_local, const_fn, thread_local)]\n-#![feature(const_cell_new)]\n #![crate_type = \"lib\"]\n \n #[cfg(target_thread_local)]"}, {"sha": "db055e6886a83675471159a0eea0527244f66d10", "filename": "src/test/run-pass/box-of-array-of-drop-1.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a2e9ade83ff253bb489c63a95b1f499c5e0916f/src%2Ftest%2Frun-pass%2Fbox-of-array-of-drop-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a2e9ade83ff253bb489c63a95b1f499c5e0916f/src%2Ftest%2Frun-pass%2Fbox-of-array-of-drop-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbox-of-array-of-drop-1.rs?ref=0a2e9ade83ff253bb489c63a95b1f499c5e0916f", "patch": "@@ -13,8 +13,6 @@\n \n // ignore-emscripten no threads support\n \n-#![feature(const_atomic_usize_new)]\n-\n use std::thread;\n use std::sync::atomic::{AtomicUsize, Ordering};\n "}, {"sha": "9dde53bb31dc57a1fc08e24f2099240d8592fbdd", "filename": "src/test/run-pass/box-of-array-of-drop-2.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a2e9ade83ff253bb489c63a95b1f499c5e0916f/src%2Ftest%2Frun-pass%2Fbox-of-array-of-drop-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a2e9ade83ff253bb489c63a95b1f499c5e0916f/src%2Ftest%2Frun-pass%2Fbox-of-array-of-drop-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbox-of-array-of-drop-2.rs?ref=0a2e9ade83ff253bb489c63a95b1f499c5e0916f", "patch": "@@ -13,8 +13,6 @@\n \n // ignore-emscripten no threads support\n \n-#![feature(const_atomic_usize_new)]\n-\n use std::thread;\n use std::sync::atomic::{AtomicUsize, Ordering};\n "}, {"sha": "a7736a2eb3431c321afa50e0359e2e2320dcecbc", "filename": "src/test/run-pass/const-fn-feature-flags.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0a2e9ade83ff253bb489c63a95b1f499c5e0916f/src%2Ftest%2Frun-pass%2Fconst-fn-feature-flags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a2e9ade83ff253bb489c63a95b1f499c5e0916f/src%2Ftest%2Frun-pass%2Fconst-fn-feature-flags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-fn-feature-flags.rs?ref=0a2e9ade83ff253bb489c63a95b1f499c5e0916f", "patch": "@@ -8,9 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// Test use of const fns in std using individual feature gates.\n-\n-#![feature(const_cell_new)]\n+// Test use of stabilized const fns in std formerly using individual feature gates.\n \n use std::cell::Cell;\n "}, {"sha": "06fbe9bf4f63958372c055f193e81dd09fe87a97", "filename": "src/test/run-pass/const-size_of-align_of.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a2e9ade83ff253bb489c63a95b1f499c5e0916f/src%2Ftest%2Frun-pass%2Fconst-size_of-align_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a2e9ade83ff253bb489c63a95b1f499c5e0916f/src%2Ftest%2Frun-pass%2Fconst-size_of-align_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-size_of-align_of.rs?ref=0a2e9ade83ff253bb489c63a95b1f499c5e0916f", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(const_fn, const_size_of, const_align_of)]\n+#![feature(const_fn)]\n \n use std::mem;\n "}, {"sha": "5f7629fa267776e2838246a238536ac14aed8c5a", "filename": "src/test/run-pass/issue-17718-static-unsafe-interior.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0a2e9ade83ff253bb489c63a95b1f499c5e0916f/src%2Ftest%2Frun-pass%2Fissue-17718-static-unsafe-interior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a2e9ade83ff253bb489c63a95b1f499c5e0916f/src%2Ftest%2Frun-pass%2Fissue-17718-static-unsafe-interior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-17718-static-unsafe-interior.rs?ref=0a2e9ade83ff253bb489c63a95b1f499c5e0916f", "patch": "@@ -10,9 +10,6 @@\n \n // pretty-expanded FIXME #23616\n \n-#![feature(core)]\n-#![feature(const_unsafe_cell_new)]\n-\n use std::marker;\n use std::cell::UnsafeCell;\n "}, {"sha": "502e4a816640a152a519e99b400bb06cf3418a32", "filename": "src/test/run-pass/issue-17718.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0a2e9ade83ff253bb489c63a95b1f499c5e0916f/src%2Ftest%2Frun-pass%2Fissue-17718.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a2e9ade83ff253bb489c63a95b1f499c5e0916f/src%2Ftest%2Frun-pass%2Fissue-17718.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-17718.rs?ref=0a2e9ade83ff253bb489c63a95b1f499c5e0916f", "patch": "@@ -10,10 +10,6 @@\n \n // aux-build:issue-17718-aux.rs\n \n-\n-#![feature(core)]\n-#![feature(const_atomic_usize_new)]\n-\n extern crate issue_17718_aux as other;\n \n use std::sync::atomic::{AtomicUsize, Ordering};"}, {"sha": "a61f294465d9893f574a82f2cab355512f3365c7", "filename": "src/test/run-pass/issue-21486.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a2e9ade83ff253bb489c63a95b1f499c5e0916f/src%2Ftest%2Frun-pass%2Fissue-21486.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a2e9ade83ff253bb489c63a95b1f499c5e0916f/src%2Ftest%2Frun-pass%2Fissue-21486.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-21486.rs?ref=0a2e9ade83ff253bb489c63a95b1f499c5e0916f", "patch": "@@ -12,8 +12,6 @@\n // created via FRU and control-flow breaks in the middle of\n // construction.\n \n-#![feature(const_atomic_usize_new)]\n-\n use std::sync::atomic::{Ordering, AtomicUsize};\n \n #[derive(Debug)]"}, {"sha": "6d43451af6b9148fa48a5ec0de5f9841e4139256", "filename": "src/test/run-pass/issue-26655.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a2e9ade83ff253bb489c63a95b1f499c5e0916f/src%2Ftest%2Frun-pass%2Fissue-26655.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a2e9ade83ff253bb489c63a95b1f499c5e0916f/src%2Ftest%2Frun-pass%2Fissue-26655.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-26655.rs?ref=0a2e9ade83ff253bb489c63a95b1f499c5e0916f", "patch": "@@ -12,8 +12,6 @@\n \n // Check that the destructors of simple enums are run on unwinding\n \n-#![feature(const_atomic_usize_new)]\n-\n use std::sync::atomic::{Ordering, AtomicUsize};\n use std::thread;\n "}, {"sha": "9dba477a7e5e5c0e0085947f9f35146d3b9c45a5", "filename": "src/test/run-pass/issue-27997.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a2e9ade83ff253bb489c63a95b1f499c5e0916f/src%2Ftest%2Frun-pass%2Fissue-27997.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a2e9ade83ff253bb489c63a95b1f499c5e0916f/src%2Ftest%2Frun-pass%2Fissue-27997.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-27997.rs?ref=0a2e9ade83ff253bb489c63a95b1f499c5e0916f", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(const_atomic_usize_new)]\n-\n use std::sync::atomic::{Ordering, AtomicUsize};\n \n use std::mem;"}, {"sha": "d1a63b443927630a1d30d2813f8266bb709016b0", "filename": "src/test/run-pass/nested-vec-3.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a2e9ade83ff253bb489c63a95b1f499c5e0916f/src%2Ftest%2Frun-pass%2Fnested-vec-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a2e9ade83ff253bb489c63a95b1f499c5e0916f/src%2Ftest%2Frun-pass%2Fnested-vec-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnested-vec-3.rs?ref=0a2e9ade83ff253bb489c63a95b1f499c5e0916f", "patch": "@@ -14,8 +14,6 @@\n // the contents implement Drop and we hit a panic in the middle of\n // construction.\n \n-#![feature(const_atomic_usize_new)]\n-\n use std::thread;\n use std::sync::atomic::{AtomicUsize, Ordering};\n "}, {"sha": "8d692f2241bc79171b1fa139a356788704f18d8e", "filename": "src/test/run-pass/panic-handler-chain.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0a2e9ade83ff253bb489c63a95b1f499c5e0916f/src%2Ftest%2Frun-pass%2Fpanic-handler-chain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a2e9ade83ff253bb489c63a95b1f499c5e0916f/src%2Ftest%2Frun-pass%2Fpanic-handler-chain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpanic-handler-chain.rs?ref=0a2e9ade83ff253bb489c63a95b1f499c5e0916f", "patch": "@@ -11,7 +11,6 @@\n // ignore-emscripten no threads support\n \n #![feature(panic_handler, std_panic)]\n-#![feature(const_atomic_usize_new)]\n \n use std::sync::atomic::{AtomicUsize, Ordering};\n use std::panic;"}, {"sha": "81da13afaa59e6b49c6d6a87174b896a3e14f6c6", "filename": "src/test/run-pass/panic-handler-set-twice.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0a2e9ade83ff253bb489c63a95b1f499c5e0916f/src%2Ftest%2Frun-pass%2Fpanic-handler-set-twice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a2e9ade83ff253bb489c63a95b1f499c5e0916f/src%2Ftest%2Frun-pass%2Fpanic-handler-set-twice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpanic-handler-set-twice.rs?ref=0a2e9ade83ff253bb489c63a95b1f499c5e0916f", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n #![feature(panic_handler, std_panic)]\n-#![feature(const_atomic_usize_new)]\n \n // ignore-emscripten no threads support\n "}, {"sha": "3059c8e9e89633c44fc757c8c13f6fa13ca630ab", "filename": "src/test/run-pass/struct-order-of-eval-3.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a2e9ade83ff253bb489c63a95b1f499c5e0916f/src%2Ftest%2Frun-pass%2Fstruct-order-of-eval-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a2e9ade83ff253bb489c63a95b1f499c5e0916f/src%2Ftest%2Frun-pass%2Fstruct-order-of-eval-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstruct-order-of-eval-3.rs?ref=0a2e9ade83ff253bb489c63a95b1f499c5e0916f", "patch": "@@ -11,8 +11,6 @@\n // Checks that functional-record-update order-of-eval is as expected\n // even when no Drop-implementations are involved.\n \n-#![feature(const_atomic_usize_new)]\n-\n use std::sync::atomic::{Ordering, AtomicUsize};\n \n struct W { wrapped: u32 }"}, {"sha": "2ae9ebc34e1b3f89e0a2546efae10fba8f6b6a06", "filename": "src/test/run-pass/struct-order-of-eval-4.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a2e9ade83ff253bb489c63a95b1f499c5e0916f/src%2Ftest%2Frun-pass%2Fstruct-order-of-eval-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a2e9ade83ff253bb489c63a95b1f499c5e0916f/src%2Ftest%2Frun-pass%2Fstruct-order-of-eval-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstruct-order-of-eval-4.rs?ref=0a2e9ade83ff253bb489c63a95b1f499c5e0916f", "patch": "@@ -11,8 +11,6 @@\n // Checks that struct-literal expression order-of-eval is as expected\n // even when no Drop-implementations are involved.\n \n-#![feature(const_atomic_usize_new)]\n-\n use std::sync::atomic::{Ordering, AtomicUsize};\n \n struct W { wrapped: u32 }"}, {"sha": "455c9dc57f52be87c55f713988d8a23da15489e2", "filename": "src/test/ui/span/dropck_arr_cycle_checked.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a2e9ade83ff253bb489c63a95b1f499c5e0916f/src%2Ftest%2Fui%2Fspan%2Fdropck_arr_cycle_checked.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a2e9ade83ff253bb489c63a95b1f499c5e0916f/src%2Ftest%2Fui%2Fspan%2Fdropck_arr_cycle_checked.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fdropck_arr_cycle_checked.rs?ref=0a2e9ade83ff253bb489c63a95b1f499c5e0916f", "patch": "@@ -13,7 +13,7 @@\n //\n // (Compare against compile-fail/dropck_vec_cycle_checked.rs)\n \n-#![feature(const_atomic_usize_new)]\n+\n \n use std::cell::Cell;\n use id::Id;"}, {"sha": "5e7cb79680c1e99797d81690cd1973bd993504ae", "filename": "src/test/ui/span/dropck_vec_cycle_checked.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a2e9ade83ff253bb489c63a95b1f499c5e0916f/src%2Ftest%2Fui%2Fspan%2Fdropck_vec_cycle_checked.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a2e9ade83ff253bb489c63a95b1f499c5e0916f/src%2Ftest%2Fui%2Fspan%2Fdropck_vec_cycle_checked.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fdropck_vec_cycle_checked.rs?ref=0a2e9ade83ff253bb489c63a95b1f499c5e0916f", "patch": "@@ -12,7 +12,7 @@\n //\n // (Compare against compile-fail/dropck_arr_cycle_checked.rs)\n \n-#![feature(const_atomic_usize_new)]\n+\n \n use std::cell::Cell;\n use id::Id;"}, {"sha": "c4596e7c3684d26412c34ab40dc169c66fd31251", "filename": "src/test/ui/span/vec-must-not-hide-type-from-dropck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0a2e9ade83ff253bb489c63a95b1f499c5e0916f/src%2Ftest%2Fui%2Fspan%2Fvec-must-not-hide-type-from-dropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a2e9ade83ff253bb489c63a95b1f499c5e0916f/src%2Ftest%2Fui%2Fspan%2Fvec-must-not-hide-type-from-dropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fvec-must-not-hide-type-from-dropck.rs?ref=0a2e9ade83ff253bb489c63a95b1f499c5e0916f", "patch": "@@ -23,7 +23,7 @@\n // conditions above to be satisfied, meaning that if the dropck is\n // sound, it should reject this code.\n \n-#![feature(const_atomic_usize_new)]\n+\n \n use std::cell::Cell;\n use id::Id;"}]}