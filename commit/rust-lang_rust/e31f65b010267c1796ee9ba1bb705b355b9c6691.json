{"sha": "e31f65b010267c1796ee9ba1bb705b355b9c6691", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUzMWY2NWIwMTAyNjdjMTc5NmVlOWJhMWJiNzA1YjM1NWI5YzY2OTE=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2016-01-30T12:27:17Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2016-01-30T12:27:17Z"}, "message": "Rollup merge of #31292 - alexcrichton:osx-dtors-in-dtors-in-dtors, r=aturon\n\nThis test has been deadlocking and causing problems on the bots basically since\nits inception. Some memory safety issues were fixed in 987dc84b, but the\ndeadlocks remained afterwards unfortunately.\n\nAfter some investigation, I've concluded that this is just a situation where OSX\nis not guaranteed to run destructors. The fix in 987dc84b observed that OSX was\nrewriting the backing TLS memory to its initial state during destruction while\nwe weren't looking, and this would have the effect of canceling the destructors\nof any other initialized TLS slots.\n\nWhile very difficult to pin down, this is basically what I assume is happening\nhere, so there doesn't seem to really be anythig we can do to ensure the test\nrobustly passes on OSX, so just ignore it for now.", "tree": {"sha": "98e4c1a93768b5d30e6077c92e38e1ebd000f9a8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/98e4c1a93768b5d30e6077c92e38e1ebd000f9a8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e31f65b010267c1796ee9ba1bb705b355b9c6691", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e31f65b010267c1796ee9ba1bb705b355b9c6691", "html_url": "https://github.com/rust-lang/rust/commit/e31f65b010267c1796ee9ba1bb705b355b9c6691", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e31f65b010267c1796ee9ba1bb705b355b9c6691/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5ff52dbf2ffdde50a126c4ad1a2da2cebbba317a", "url": "https://api.github.com/repos/rust-lang/rust/commits/5ff52dbf2ffdde50a126c4ad1a2da2cebbba317a", "html_url": "https://github.com/rust-lang/rust/commit/5ff52dbf2ffdde50a126c4ad1a2da2cebbba317a"}, {"sha": "b960de0984cec27989746eec6fa706b3a7b46ad3", "url": "https://api.github.com/repos/rust-lang/rust/commits/b960de0984cec27989746eec6fa706b3a7b46ad3", "html_url": "https://github.com/rust-lang/rust/commit/b960de0984cec27989746eec6fa706b3a7b46ad3"}], "stats": {"total": 25, "additions": 25, "deletions": 0}, "files": [{"sha": "d1f5cf81c038da88f5ceb3c8c27a680f9c64840f", "filename": "src/libstd/thread/local.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/e31f65b010267c1796ee9ba1bb705b355b9c6691/src%2Flibstd%2Fthread%2Flocal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e31f65b010267c1796ee9ba1bb705b355b9c6691/src%2Flibstd%2Fthread%2Flocal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Flocal.rs?ref=e31f65b010267c1796ee9ba1bb705b355b9c6691", "patch": "@@ -56,6 +56,26 @@ use mem;\n ///     assert_eq!(*f.borrow(), 2);\n /// });\n /// ```\n+///\n+/// # Platform-specific behavior\n+///\n+/// Note that a \"best effort\" is made to ensure that destructors for types\n+/// stored in thread local storage are run, but not all platforms can gurantee\n+/// that destructors will be run for all types in thread local storage. For\n+/// example, there are a number of known caveats where destructors are not run:\n+///\n+/// 1. On Unix systems when pthread-based TLS is being used, destructors will\n+///    not be run for TLS values on the main thread when it exits. Note that the\n+///    application will exit immediately after the main thread exits as well.\n+/// 2. On all platforms it's possible for TLS to re-initialize other TLS slots\n+///    during destruction. Some platforms ensure that this cannot happen\n+///    infinitely by preventing re-initialization of any slot that has been\n+///    destroyed, but not all platforms have this guard. Those platforms that do\n+///    not guard typically have a synthetic limit after which point no more\n+///    destructors are run.\n+/// 3. On OSX, initializing TLS during destruction of other TLS slots can\n+///    sometimes cancel *all* destructors for the current thread, whether or not\n+///    the slots have already had their destructors run or not.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct LocalKey<T: 'static> {\n     // This outer `LocalKey<T>` type is what's going to be stored in statics,\n@@ -602,7 +622,12 @@ mod tests {\n         }).join().ok().unwrap();\n     }\n \n+    // Note that this test will deadlock if TLS destructors aren't run (this\n+    // requires the destructor to be run to pass the test). OSX has a known bug\n+    // where dtors-in-dtors may cancel other destructors, so we just ignore this\n+    // test on OSX.\n     #[test]\n+    #[cfg_attr(target_os = \"macos\", ignore)]\n     fn dtors_in_dtors_in_dtors() {\n         struct S1(Sender<()>);\n         thread_local!(static K1: UnsafeCell<Option<S1>> = UnsafeCell::new(None));"}]}