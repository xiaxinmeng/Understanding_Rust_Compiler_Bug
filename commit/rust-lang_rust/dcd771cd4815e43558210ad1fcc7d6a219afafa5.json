{"sha": "dcd771cd4815e43558210ad1fcc7d6a219afafa5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRjZDc3MWNkNDgxNWU0MzU1ODIxMGFkMWZjYzdkNmEyMTlhZmFmYTU=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-12-22T22:50:52Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-12-22T22:50:52Z"}, "message": "Merge branch 'master' of github.com:graydon/rust", "tree": {"sha": "2d5cf78ec849b55bb18e3ec898d76b7b0517552a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2d5cf78ec849b55bb18e3ec898d76b7b0517552a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dcd771cd4815e43558210ad1fcc7d6a219afafa5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dcd771cd4815e43558210ad1fcc7d6a219afafa5", "html_url": "https://github.com/rust-lang/rust/commit/dcd771cd4815e43558210ad1fcc7d6a219afafa5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dcd771cd4815e43558210ad1fcc7d6a219afafa5/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8b580954fe140dd45db61d719a49065c3e31de95", "url": "https://api.github.com/repos/rust-lang/rust/commits/8b580954fe140dd45db61d719a49065c3e31de95", "html_url": "https://github.com/rust-lang/rust/commit/8b580954fe140dd45db61d719a49065c3e31de95"}, {"sha": "9587c672301663d46f8d97d34bb82cd0506f8454", "url": "https://api.github.com/repos/rust-lang/rust/commits/9587c672301663d46f8d97d34bb82cd0506f8454", "html_url": "https://github.com/rust-lang/rust/commit/9587c672301663d46f8d97d34bb82cd0506f8454"}], "stats": {"total": 738, "additions": 334, "deletions": 404}, "files": [{"sha": "ee32a31aabb9e51170d104afd37d859a2074063c", "filename": "src/comp/front/test.rs", "status": "modified", "additions": 13, "deletions": 25, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/dcd771cd4815e43558210ad1fcc7d6a219afafa5/src%2Fcomp%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcd771cd4815e43558210ad1fcc7d6a219afafa5/src%2Fcomp%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Ftest.rs?ref=dcd771cd4815e43558210ad1fcc7d6a219afafa5", "patch": "@@ -51,7 +51,7 @@ fn fold_mod(_cx: test_ctxt, m: ast::_mod, fld: fold::ast_fold) -> ast::_mod {\n     // we want to be main.\n     fn nomain(&&item: @ast::item) -> option::t<@ast::item> {\n         alt item.node {\n-          ast::item_fn(f, _) {\n+          ast::item_fn(_, _, _) {\n             if item.ident == \"main\" {\n                 option::none\n             } else { option::some(item) }\n@@ -83,7 +83,7 @@ fn fold_item(cx: test_ctxt, &&i: @ast::item, fld: fold::ast_fold) ->\n \n     if is_test_fn(i) {\n         alt i.node {\n-          ast::item_fn(f, _) when f.decl.purity == ast::unsafe_fn {\n+          ast::item_fn(decl, _, _) when decl.purity == ast::unsafe_fn {\n             cx.sess.span_fatal(\n                 i.span,\n                 \"unsafe functions cannot be used for tests\");\n@@ -110,9 +110,9 @@ fn is_test_fn(i: @ast::item) -> bool {\n \n     fn has_test_signature(i: @ast::item) -> bool {\n         alt i.node {\n-          ast::item_fn(f, tps) {\n-            let input_cnt = vec::len(f.decl.inputs);\n-            let no_output = f.decl.output.node == ast::ty_nil;\n+          ast::item_fn(decl, tps, _) {\n+            let input_cnt = vec::len(decl.inputs);\n+            let no_output = decl.output.node == ast::ty_nil;\n             let tparm_cnt = vec::len(tps);\n             input_cnt == 0u && no_output && tparm_cnt == 0u\n           }\n@@ -190,13 +190,12 @@ fn mk_tests(cx: test_ctxt) -> @ast::item {\n     let ret_ty = mk_test_desc_vec_ty(cx);\n \n     let decl: ast::fn_decl =\n-        {inputs: [],\n+        {proto: ast::proto_bare,\n+         inputs: [],\n          output: ret_ty,\n          purity: ast::impure_fn,\n-         il: ast::il_normal,\n          cf: ast::return_val,\n          constraints: []};\n-    let proto = ast::proto_bare;\n \n     // The vector of test_descs for this crate\n     let test_descs = mk_test_desc_vec(cx);\n@@ -205,9 +204,7 @@ fn mk_tests(cx: test_ctxt) -> @ast::item {\n         default_block([], option::some(test_descs), cx.sess.next_node_id());\n     let body = nospan(body_);\n \n-    let fn_ = {decl: decl, proto: proto, body: body};\n-\n-    let item_ = ast::item_fn(fn_, []);\n+    let item_ = ast::item_fn(decl, [], body);\n     let item: ast::item =\n         {ident: \"tests\",\n          attrs: [],\n@@ -325,10 +322,10 @@ fn mk_test_wrapper(cx: test_ctxt,\n         ast::stmt_expr(@call_expr, cx.sess.next_node_id()));\n \n     let wrapper_decl: ast::fn_decl = {\n+        proto: ast::proto_bare,\n         inputs: [],\n         output: @nospan(ast::ty_nil),\n         purity: ast::impure_fn,\n-        il: ast::il_normal,\n         cf: ast::return_val,\n         constraints: []\n     };\n@@ -341,20 +338,14 @@ fn mk_test_wrapper(cx: test_ctxt,\n         rules: ast::default_blk\n     });\n \n-    let wrapper_fn: ast::_fn = {\n-        decl: wrapper_decl,\n-        proto: ast::proto_bare,\n-        body: wrapper_body\n-    };\n-\n     let wrapper_capture: @ast::capture_clause = @{\n         copies: [],\n         moves: []\n     };\n \n     let wrapper_expr: ast::expr = {\n         id: cx.sess.next_node_id(),\n-        node: ast::expr_fn(wrapper_fn, wrapper_capture),\n+        node: ast::expr_fn(wrapper_decl, wrapper_body, wrapper_capture),\n         span: span\n     };\n \n@@ -375,13 +366,12 @@ fn mk_main(cx: test_ctxt) -> @ast::item {\n     let ret_ty = nospan(ast::ty_nil);\n \n     let decl: ast::fn_decl =\n-        {inputs: [args_arg],\n+        {proto: ast::proto_bare,\n+         inputs: [args_arg],\n          output: @ret_ty,\n          purity: ast::impure_fn,\n-         il: ast::il_normal,\n          cf: ast::return_val,\n          constraints: []};\n-    let proto = ast::proto_bare;\n \n     let test_main_call_expr = mk_test_main_call(cx);\n \n@@ -390,9 +380,7 @@ fn mk_main(cx: test_ctxt) -> @ast::item {\n                       cx.sess.next_node_id());\n     let body = {node: body_, span: dummy_sp()};\n \n-    let fn_ = {decl: decl, proto: proto, body: body};\n-\n-    let item_ = ast::item_fn(fn_, []);\n+    let item_ = ast::item_fn(decl, [], body);\n     let item: ast::item =\n         {ident: \"main\",\n          attrs: [],"}, {"sha": "0e536d0a001943c66ed456d1f791152e9c8384ef", "filename": "src/comp/metadata/common.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dcd771cd4815e43558210ad1fcc7d6a219afafa5/src%2Fcomp%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcd771cd4815e43558210ad1fcc7d6a219afafa5/src%2Fcomp%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fcommon.rs?ref=dcd771cd4815e43558210ad1fcc7d6a219afafa5", "patch": "@@ -62,8 +62,6 @@ const tag_crate_deps: uint = 0x25u;\n // A single crate dependency\n const tag_crate_dep: uint = 0x26u;\n \n-const tag_items_data_item_inlineness: uint = 0x27u;\n-\n const tag_crate_hash: uint = 0x28u;\n \n const tag_mod_impl: uint = 0x30u;"}, {"sha": "ba87bcf9dab1dd35640f9485721292ad02874ca9", "filename": "src/comp/metadata/encoder.rs", "status": "modified", "additions": 12, "deletions": 24, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/dcd771cd4815e43558210ad1fcc7d6a219afafa5/src%2Fcomp%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcd771cd4815e43558210ad1fcc7d6a219afafa5/src%2Fcomp%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fencoder.rs?ref=dcd771cd4815e43558210ad1fcc7d6a219afafa5", "patch": "@@ -74,7 +74,7 @@ fn encode_module_item_paths(ebml_w: ebml::writer, module: _mod, path: [str],\n             encode_def_id(ebml_w, local_def(it.id));\n             ebml::end_tag(ebml_w);\n           }\n-          item_fn(_, tps) {\n+          item_fn(_, tps, _) {\n             add_to_index(ebml_w, path, index, it.ident);\n             ebml::start_tag(ebml_w, tag_paths_data_item);\n             encode_name(ebml_w, it.ident);\n@@ -105,7 +105,7 @@ fn encode_module_item_paths(ebml_w: ebml::writer, module: _mod, path: [str],\n             encode_def_id(ebml_w, local_def(it.id));\n             ebml::end_tag(ebml_w);\n           }\n-          item_res(_, _, tps, ctor_id) {\n+          item_res(_, tps, _, _, ctor_id) {\n             add_to_index(ebml_w, path, index, it.ident);\n             ebml::start_tag(ebml_w, tag_paths_data_item);\n             encode_name(ebml_w, it.ident);\n@@ -173,12 +173,6 @@ fn encode_family(ebml_w: ebml::writer, c: u8) {\n     ebml::end_tag(ebml_w);\n }\n \n-fn encode_inlineness(ebml_w: ebml::writer, c: u8) {\n-    ebml::start_tag(ebml_w, tag_items_data_item_inlineness);\n-    ebml_w.writer.write([c]);\n-    ebml::end_tag(ebml_w);\n-}\n-\n fn def_to_str(did: def_id) -> str { ret #fmt[\"%d:%d\", did.crate, did.node]; }\n \n fn encode_type_param_kinds(ebml_w: ebml::writer, tps: [ty_param]) {\n@@ -282,20 +276,15 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         encode_symbol(ecx, ebml_w, item.id);\n         ebml::end_tag(ebml_w);\n       }\n-      item_fn(fd, tps) {\n+      item_fn(decl, tps, _) {\n         ebml::start_tag(ebml_w, tag_items_data_item);\n         encode_def_id(ebml_w, local_def(item.id));\n         encode_family(ebml_w,\n-                      alt fd.decl.purity {\n+                      alt decl.purity {\n                         unsafe_fn. { 'u' }\n                         pure_fn. { 'p' }\n                         impure_fn. { 'f' }\n                       } as u8);\n-        encode_inlineness(ebml_w,\n-                          alt fd.decl.il {\n-                            il_normal. { 'n' }\n-                            il_inline. { 'i' }\n-                          } as u8);\n         encode_type_param_kinds(ebml_w, tps);\n         encode_type(ecx, ebml_w, node_id_to_monotype(ecx.ccx.tcx, item.id));\n         encode_symbol(ecx, ebml_w, item.id);\n@@ -333,7 +322,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         ebml::end_tag(ebml_w);\n         encode_tag_variant_info(ecx, ebml_w, item.id, variants, index, tps);\n       }\n-      item_res(_, _, tps, ctor_id) {\n+      item_res(_, tps, _, _, ctor_id) {\n         let fn_ty = node_id_to_monotype(ecx.ccx.tcx, ctor_id);\n \n         ebml::start_tag(ebml_w, tag_items_data_item);\n@@ -383,22 +372,21 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n         encode_name(ebml_w, item.ident);\n         for m in methods {\n             ebml::start_tag(ebml_w, tag_impl_method);\n-            ebml_w.writer.write(str::bytes(def_to_str(local_def(m.node.id))));\n+            ebml_w.writer.write(str::bytes(def_to_str(local_def(m.id))));\n             ebml::end_tag(ebml_w);\n         }\n         ebml::end_tag(ebml_w);\n \n         for m in methods {\n-            index += [{val: m.node.id, pos: ebml_w.writer.tell()}];\n+            index += [{val: m.id, pos: ebml_w.writer.tell()}];\n             ebml::start_tag(ebml_w, tag_items_data_item);\n-            encode_def_id(ebml_w, local_def(m.node.id));\n+            encode_def_id(ebml_w, local_def(m.id));\n             encode_family(ebml_w, 'f' as u8);\n-            encode_inlineness(ebml_w, 'n' as u8);\n-            encode_type_param_kinds(ebml_w, tps + m.node.tps);\n+            encode_type_param_kinds(ebml_w, tps + m.tps);\n             encode_type(ecx, ebml_w,\n-                        node_id_to_monotype(ecx.ccx.tcx, m.node.id));\n-            encode_name(ebml_w, m.node.ident);\n-            encode_symbol(ecx, ebml_w, m.node.id);\n+                        node_id_to_monotype(ecx.ccx.tcx, m.id));\n+            encode_name(ebml_w, m.ident);\n+            encode_symbol(ecx, ebml_w, m.id);\n             ebml::end_tag(ebml_w);\n         }\n       }"}, {"sha": "f1ecfb29e2ac9d42bf835a17e6d4e57f6ef41031", "filename": "src/comp/middle/ast_map.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dcd771cd4815e43558210ad1fcc7d6a219afafa5/src%2Fcomp%2Fmiddle%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcd771cd4815e43558210ad1fcc7d6a219afafa5/src%2Fcomp%2Fmiddle%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fast_map.rs?ref=dcd771cd4815e43558210ad1fcc7d6a219afafa5", "patch": "@@ -68,13 +68,13 @@ fn map_item(cx: ctx, i: @item) {\n       item_obj(ob, _, ctor_id) {\n         cx.map.insert(ctor_id, node_obj_ctor(i));\n         for m in ob.methods {\n-            cx.map.insert(m.node.id, node_obj_method(m));\n+            cx.map.insert(m.id, node_obj_method(m));\n         }\n       }\n       item_impl(_, _, ms) {\n-        for m in ms { cx.map.insert(m.node.id, node_method(m)); }\n+        for m in ms { cx.map.insert(m.id, node_method(m)); }\n       }\n-      item_res(_, dtor_id, _, ctor_id) {\n+      item_res(_, _, _, dtor_id, ctor_id) {\n         cx.map.insert(ctor_id, node_res_ctor(i));\n         cx.map.insert(dtor_id, node_item(i));\n       }"}, {"sha": "1ad7d743b63ea3d1cf971c0585facad129c6cf50", "filename": "src/comp/middle/debuginfo.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/dcd771cd4815e43558210ad1fcc7d6a219afafa5/src%2Fcomp%2Fmiddle%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcd771cd4815e43558210ad1fcc7d6a219afafa5/src%2Fcomp%2Fmiddle%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fdebuginfo.rs?ref=dcd771cd4815e43558210ad1fcc7d6a219afafa5", "patch": "@@ -721,23 +721,23 @@ fn create_function(fcx: @fn_ctxt) -> @metadata<subprogram_md> {\n     let (ident, ret_ty, id) = alt cx.ast_map.get(fcx.id) {\n       ast_map::node_item(item) {\n         alt item.node {\n-          ast::item_fn(f, _) | ast::item_res(f, _, _, _) {\n-            (item.ident, f.decl.output, item.id)\n+          ast::item_fn(decl, _, _) | ast::item_res(decl, _, _, _, _) {\n+            (item.ident, decl.output, item.id)\n           }\n         }\n       }\n       ast_map::node_obj_method(method) {\n-        (method.node.ident, method.node.meth.decl.output, method.node.id)\n+        (method.ident, method.decl.output, method.id)\n       }\n       ast_map::node_res_ctor(item) {\n-        alt item.node { ast::item_res(f, _, _, ctor_id) {\n-          (item.ident, f.decl.output, ctor_id)\n+        alt item.node { ast::item_res(decl, _, _, _, ctor_id) {\n+          (item.ident, decl.output, ctor_id)\n         }}\n       }\n       ast_map::node_expr(expr) {\n         alt expr.node {\n-          ast::expr_fn(f, _) {\n-            (dbg_cx.names.next(\"fn\"), f.decl.output, expr.id)\n+          ast::expr_fn(decl, _, _) {\n+            (dbg_cx.names.next(\"fn\"), decl.output, expr.id)\n           }\n           ast::expr_fn_block(decl, _) {\n             (dbg_cx.names.next(\"fn\"), decl.output, expr.id)"}, {"sha": "9490b9e9ac1a8a8dca1f90231c81fd97db34e85e", "filename": "src/comp/middle/freevars.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dcd771cd4815e43558210ad1fcc7d6a219afafa5/src%2Fcomp%2Fmiddle%2Ffreevars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcd771cd4815e43558210ad1fcc7d6a219afafa5/src%2Fcomp%2Fmiddle%2Ffreevars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ffreevars.rs?ref=dcd771cd4815e43558210ad1fcc7d6a219afafa5", "patch": "@@ -38,8 +38,8 @@ fn collect_freevars(def_map: resolve::def_map, blk: ast::blk)\n     let walk_expr =\n         lambda (expr: @ast::expr, &&depth: int, v: visit::vt<int>) {\n             alt expr.node {\n-              ast::expr_fn(f, captures) {\n-                if f.proto != ast::proto_bare {\n+              ast::expr_fn(decl, _, captures) {\n+                if decl.proto != ast::proto_bare {\n                     visit::visit_expr(expr, depth + 1, v);\n                 }\n               }"}, {"sha": "241ca951e24c3cf26010616dc412bff51c7c4387", "filename": "src/comp/middle/kind.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/dcd771cd4815e43558210ad1fcc7d6a219afafa5/src%2Fcomp%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcd771cd4815e43558210ad1fcc7d6a219afafa5/src%2Fcomp%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fkind.rs?ref=dcd771cd4815e43558210ad1fcc7d6a219afafa5", "patch": "@@ -178,8 +178,9 @@ fn check_expr(e: @expr, cx: ctx, v: visit::vt<ctx>) {\n         }\n       }\n       expr_ternary(_, a, b) { maybe_copy(cx, a); maybe_copy(cx, b); }\n-      expr_fn(_, cap_clause) { check_fn_cap_clause(cx, e.id, *cap_clause); }\n-\n+      expr_fn(_, _, cap_clause) {\n+        check_fn_cap_clause(cx, e.id, *cap_clause);\n+      }\n       _ { }\n     }\n     visit::visit_expr(e, cx, v);"}, {"sha": "3f5454700c1563261cb071b68a0dd94ecc99223c", "filename": "src/comp/middle/last_use.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dcd771cd4815e43558210ad1fcc7d6a219afafa5/src%2Fcomp%2Fmiddle%2Flast_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcd771cd4815e43558210ad1fcc7d6a219afafa5/src%2Fcomp%2Fmiddle%2Flast_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Flast_use.rs?ref=dcd771cd4815e43558210ad1fcc7d6a219afafa5", "patch": "@@ -136,7 +136,7 @@ fn visit_expr(ex: @expr, cx: ctx, v: visit::vt<ctx>) {\n         for arg in args {\n             alt arg.node {\n               //NDM--register captured as uses\n-              expr_fn(_, captured) { fns += [arg]; }\n+              expr_fn(_, _, captured) { fns += [arg]; }\n               expr_fn_block(_, _) { fns += [arg]; }\n               _ {\n                 alt arg_ts[i].mode {"}, {"sha": "68736bc744caef45ba75f47d3ea7873b3132bbe5", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/dcd771cd4815e43558210ad1fcc7d6a219afafa5/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcd771cd4815e43558210ad1fcc7d6a219afafa5/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=dcd771cd4815e43558210ad1fcc7d6a219afafa5", "patch": "@@ -337,7 +337,7 @@ fn resolve_names(e: @env, c: @ast::crate) {\n           visit_ty: bind walk_ty(e, _, _, _),\n           visit_constr: bind walk_constr(e, _, _, _, _, _),\n           visit_fn_proto:\n-              bind visit_fn_proto_with_scope(e, _, _, _, _, _, _, _),\n+              bind visit_fn_proto_with_scope(e, _, _, _, _, _, _, _, _),\n           visit_fn_block:\n               bind visit_fn_block_with_scope(e, _, _, _, _, _, _)\n           with *visit::default_visitor()};\n@@ -353,7 +353,7 @@ fn resolve_names(e: @env, c: @ast::crate) {\n                          lookup_path_strict(*e, sc, exp.span, p.node,\n                                             ns_value));\n           }\n-          ast::expr_fn(_, cap_clause) {\n+          ast::expr_fn(_, _, cap_clause) {\n             let rci = bind resolve_capture_item(e, sc, _);\n             vec::iter(cap_clause.copies, rci);\n             vec::iter(cap_clause.moves, rci);\n@@ -404,8 +404,8 @@ fn visit_item_with_scope(i: @ast::item, sc: scopes, v: vt<scopes>) {\n       ast::item_impl(tps, sty, methods) {\n         visit::visit_ty(sty, sc, v);\n         for m in methods {\n-            v.visit_fn_proto(m.node.meth, tps + m.node.tps, m.span,\n-                             some(m.node.ident), m.node.id, sc, v);\n+            v.visit_fn_proto(m.decl, tps + m.tps, m.body, m.span,\n+                             some(m.ident), m.id, sc, v);\n         }\n       }\n       _ { visit::visit_item(i, sc, v); }\n@@ -417,9 +417,9 @@ fn visit_native_item_with_scope(ni: @ast::native_item, sc: scopes,\n     visit::visit_native_item(ni, cons(scope_native_item(ni), @sc), v);\n }\n \n-fn visit_fn_proto_with_scope(e: @env, f: ast::_fn, tp: [ast::ty_param],\n-                             sp: span, name: fn_ident, id: node_id,\n-                             sc: scopes, v: vt<scopes>) {\n+fn visit_fn_proto_with_scope(e: @env, decl: ast::fn_decl, tp: [ast::ty_param],\n+                             body: ast::blk, sp: span, name: fn_ident,\n+                             id: node_id, sc: scopes, v: vt<scopes>) {\n     // is this a main fn declaration?\n     alt name {\n       some(nm) {\n@@ -434,13 +434,13 @@ fn visit_fn_proto_with_scope(e: @env, f: ast::_fn, tp: [ast::ty_param],\n \n     // here's where we need to set up the mapping\n     // for f's constrs in the table.\n-    for c: @ast::constr in f.decl.constraints { resolve_constr(e, c, sc, v); }\n-    let scope = alt f.proto {\n-      ast::proto_bare. { scope_bare_fn(f.decl, id, tp) }\n-      _ { scope_fn_expr(f.decl, id, tp) }\n+    for c: @ast::constr in decl.constraints { resolve_constr(e, c, sc, v); }\n+    let scope = alt decl.proto {\n+      ast::proto_bare. { scope_bare_fn(decl, id, tp) }\n+      _ { scope_fn_expr(decl, id, tp) }\n     };\n \n-    visit::visit_fn_proto(f, tp, sp, name, id, cons(scope, @sc), v);\n+    visit::visit_fn_proto(decl, tp, body, sp, name, id, cons(scope, @sc), v);\n }\n \n fn visit_fn_block_with_scope(_e: @env, decl: fn_decl, blk: ast::blk,\n@@ -1053,9 +1053,9 @@ fn found_def_item(i: @ast::item, ns: namespace) -> option::t<def> {\n       ast::item_const(_, _) {\n         if ns == ns_value { ret some(ast::def_const(local_def(i.id))); }\n       }\n-      ast::item_fn(f, _) {\n+      ast::item_fn(decl, _, _) {\n         if ns == ns_value {\n-            ret some(ast::def_fn(local_def(i.id), f.decl.purity));\n+            ret some(ast::def_fn(local_def(i.id), decl.purity));\n         }\n       }\n       ast::item_mod(_) {\n@@ -1067,7 +1067,7 @@ fn found_def_item(i: @ast::item, ns: namespace) -> option::t<def> {\n       ast::item_ty(_, _) {\n         if ns == ns_type { ret some(ast::def_ty(local_def(i.id))); }\n       }\n-      ast::item_res(_, _, _, ctor_id) {\n+      ast::item_res(_, _, _, _, ctor_id) {\n         alt ns {\n           ns_value. {\n             ret some(ast::def_fn(local_def(ctor_id), ast::impure_fn));\n@@ -1319,9 +1319,9 @@ fn index_mod(md: ast::_mod) -> mod_index {\n     }\n     for it: @ast::item in md.items {\n         alt it.node {\n-          ast::item_const(_, _) | ast::item_fn(_, _) | ast::item_mod(_) |\n+          ast::item_const(_, _) | ast::item_fn(_, _, _) | ast::item_mod(_) |\n           ast::item_native_mod(_) | ast::item_ty(_, _) |\n-          ast::item_res(_, _, _, _) | ast::item_obj(_, _, _) |\n+          ast::item_res(_, _, _, _, _) | ast::item_obj(_, _, _) |\n           ast::item_impl(_, _, _) {\n             add_to_index(index, it.ident, mie_item(it));\n           }\n@@ -1479,16 +1479,16 @@ fn check_item(e: @env, i: @ast::item, &&x: (), v: vt<()>) {\n     }\n     visit::visit_item(i, x, v);\n     alt i.node {\n-      ast::item_fn(f, ty_params) {\n-        check_fn(*e, i.span, f);\n+      ast::item_fn(decl, ty_params, _) {\n+        check_fn(*e, i.span, decl);\n         ensure_unique(*e, i.span, typaram_names(ty_params), ident_id,\n                       \"type parameter\");\n       }\n       ast::item_obj(ob, ty_params, _) {\n         fn field_name(field: ast::obj_field) -> ident { ret field.ident; }\n         ensure_unique(*e, i.span, ob.fields, field_name, \"object field\");\n         for m: @ast::method in ob.methods {\n-            check_fn(*e, m.span, m.node.meth);\n+            check_fn(*e, m.span, m.decl);\n         }\n         ensure_unique(*e, i.span, typaram_names(ty_params), ident_id,\n                       \"type parameter\");\n@@ -1568,11 +1568,11 @@ fn check_block(e: @env, b: ast::blk, &&x: (), v: vt<()>) {\n                   ast::item_mod(_) | ast::item_native_mod(_) {\n                     add_name(mods, it.span, it.ident);\n                   }\n-                  ast::item_const(_, _) | ast::item_fn(_, _) {\n+                  ast::item_const(_, _) | ast::item_fn(_, _, _) {\n                     add_name(values, it.span, it.ident);\n                   }\n                   ast::item_ty(_, _) { add_name(types, it.span, it.ident); }\n-                  ast::item_res(_, _, _, _) | ast::item_obj(_, _, _) {\n+                  ast::item_res(_, _, _, _, _) | ast::item_obj(_, _, _) {\n                     add_name(types, it.span, it.ident);\n                     add_name(values, it.span, it.ident);\n                   }\n@@ -1586,9 +1586,9 @@ fn check_block(e: @env, b: ast::blk, &&x: (), v: vt<()>) {\n     }\n }\n \n-fn check_fn(e: env, sp: span, f: ast::_fn) {\n+fn check_fn(e: env, sp: span, decl: ast::fn_decl) {\n     fn arg_name(a: ast::arg) -> ident { ret a.ident; }\n-    ensure_unique(e, sp, f.decl.inputs, arg_name, \"argument\");\n+    ensure_unique(e, sp, decl.inputs, arg_name, \"argument\");\n }\n \n fn check_expr(e: @env, ex: @ast::expr, &&x: (), v: vt<()>) {\n@@ -1775,9 +1775,9 @@ fn find_impls_in_item(i: @ast::item, &impls: [@_impl],\n             impls += [@{did: local_def(i.id),\n                         ident: i.ident,\n                         methods: vec::map(mthds, {|m|\n-                            @{did: local_def(m.node.id),\n-                              n_tps: vec::len(m.node.tps),\n-                              ident: m.node.ident}\n+                            @{did: local_def(m.id),\n+                              n_tps: vec::len(m.tps),\n+                              ident: m.ident}\n                         })}];\n         }\n       }"}, {"sha": "81d848460f920f9d74580b90a9cb8ffe48aaed9c", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 34, "deletions": 32, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/dcd771cd4815e43558210ad1fcc7d6a219afafa5/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcd771cd4815e43558210ad1fcc7d6a219afafa5/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=dcd771cd4815e43558210ad1fcc7d6a219afafa5", "patch": "@@ -3554,17 +3554,16 @@ fn trans_expr(bcx: @block_ctxt, e: @ast::expr, dest: dest) -> @block_ctxt {\n         assert op != ast::deref; // lvals are handled above\n         ret trans_unary(bcx, op, x, e.id, dest);\n       }\n-      ast::expr_fn(f, cap_clause) {\n+      ast::expr_fn(decl, body, cap_clause) {\n         ret trans_closure::trans_expr_fn(\n-            bcx, f, e.span, e.id, *cap_clause, dest);\n+            bcx, decl, body, e.span, e.id, *cap_clause, dest);\n       }\n       ast::expr_fn_block(decl, body) {\n         alt ty::struct(tcx, ty::expr_ty(tcx, e)) {\n           ty::ty_fn(proto, _, _, _, _) {\n-            let f: ast::_fn = { decl: decl, proto: proto, body: body };\n             let cap_clause = { copies: [], moves: [] };\n             ret trans_closure::trans_expr_fn(\n-                bcx, f, e.span, e.id, cap_clause, dest);\n+                bcx, decl, body, e.span, e.id, cap_clause, dest);\n           }\n           _ {\n             fail \"Type of fn block is not a function!\";\n@@ -4516,14 +4515,15 @@ tag self_arg { obj_self(ty::t); impl_self(ty::t); no_self; }\n // trans_closure: Builds an LLVM function out of a source function.\n // If the function closes over its environment a closure will be\n // returned.\n-fn trans_closure(cx: @local_ctxt, sp: span, f: ast::_fn, llfndecl: ValueRef,\n+fn trans_closure(cx: @local_ctxt, sp: span, decl: ast::fn_decl,\n+                 body: ast::blk, llfndecl: ValueRef,\n                  ty_self: self_arg, ty_params: [ast::ty_param],\n                  id: ast::node_id, maybe_load_env: block(@fn_ctxt)) {\n     set_uwtable(llfndecl);\n \n     // Set up arguments to the function.\n-    let fcx = new_fn_ctxt_w_id(cx, sp, llfndecl, id, f.decl.cf);\n-    create_llargs_for_fn_args(fcx, ty_self, f.decl.inputs, ty_params);\n+    let fcx = new_fn_ctxt_w_id(cx, sp, llfndecl, id, decl.cf);\n+    create_llargs_for_fn_args(fcx, ty_self, decl.inputs, ty_params);\n     alt ty_self {\n       obj_self(_) {\n           populate_fn_ctxt_from_llself(fcx, option::get(fcx.llself));\n@@ -4535,10 +4535,10 @@ fn trans_closure(cx: @local_ctxt, sp: span, f: ast::_fn, llfndecl: ValueRef,\n     //  pass to finish_fn later.\n     let bcx = new_top_block_ctxt(fcx);\n     let lltop = bcx.llbb;\n-    let block_ty = node_id_type(cx.ccx, f.body.node.id);\n+    let block_ty = node_id_type(cx.ccx, body.node.id);\n \n     let arg_tys = arg_tys_of_fn(fcx.lcx.ccx, id);\n-    bcx = copy_args_to_allocas(fcx, bcx, f.decl.inputs, arg_tys);\n+    bcx = copy_args_to_allocas(fcx, bcx, decl.inputs, arg_tys);\n \n     maybe_load_env(fcx);\n \n@@ -4548,14 +4548,14 @@ fn trans_closure(cx: @local_ctxt, sp: span, f: ast::_fn, llfndecl: ValueRef,\n     // (trans_block, trans_expr, et cetera).\n     if ty::type_is_bot(cx.ccx.tcx, block_ty) ||\n        ty::type_is_nil(cx.ccx.tcx, block_ty) ||\n-       option::is_none(f.body.node.expr) {\n-        bcx = trans_block_dps(bcx, f.body, ignore);\n+       option::is_none(body.node.expr) {\n+        bcx = trans_block_dps(bcx, body, ignore);\n     } else if ty::type_is_immediate(cx.ccx.tcx, block_ty) {\n         let cell = empty_dest_cell();\n-        bcx = trans_block_dps(bcx, f.body, by_val(cell));\n+        bcx = trans_block_dps(bcx, body, by_val(cell));\n         Store(bcx, *cell, fcx.llretptr);\n     } else {\n-        bcx = trans_block_dps(bcx, f.body, save_in(fcx.llretptr));\n+        bcx = trans_block_dps(bcx, body, save_in(fcx.llretptr));\n     }\n \n     // FIXME: until LLVM has a unit type, we are moving around\n@@ -4567,13 +4567,13 @@ fn trans_closure(cx: @local_ctxt, sp: span, f: ast::_fn, llfndecl: ValueRef,\n \n // trans_fn: creates an LLVM function corresponding to a source language\n // function.\n-fn trans_fn(cx: @local_ctxt, sp: span, f: ast::_fn, llfndecl: ValueRef,\n-            ty_self: self_arg, ty_params: [ast::ty_param],\n+fn trans_fn(cx: @local_ctxt, sp: span, decl: ast::fn_decl, body: ast::blk,\n+            llfndecl: ValueRef, ty_self: self_arg, ty_params: [ast::ty_param],\n             id: ast::node_id) {\n     let do_time = cx.ccx.sess.get_opts().stats;\n     let start = do_time ? time::get_time() : {sec: 0u32, usec: 0u32};\n     let fcx = option::none;\n-    trans_closure(cx, sp, f, llfndecl, ty_self, ty_params, id,\n+    trans_closure(cx, sp, decl, body, llfndecl, ty_self, ty_params, id,\n                   {|new_fcx| fcx = option::some(new_fcx);});\n     if cx.ccx.sess.get_opts().extra_debuginfo {\n         debuginfo::create_function(option::get(fcx));\n@@ -4584,7 +4584,7 @@ fn trans_fn(cx: @local_ctxt, sp: span, f: ast::_fn, llfndecl: ValueRef,\n     }\n }\n \n-fn trans_res_ctor(cx: @local_ctxt, sp: span, dtor: ast::_fn,\n+fn trans_res_ctor(cx: @local_ctxt, sp: span, dtor: ast::fn_decl,\n                   ctor_id: ast::node_id, ty_params: [ast::ty_param]) {\n     let ccx = cx.ccx;\n \n@@ -4596,12 +4596,12 @@ fn trans_res_ctor(cx: @local_ctxt, sp: span, dtor: ast::_fn,\n     }\n     let fcx = new_fn_ctxt(cx, sp, llctor_decl);\n     let ret_t = ty::ret_ty_of_fn(cx.ccx.tcx, ctor_id);\n-    create_llargs_for_fn_args(fcx, no_self, dtor.decl.inputs, ty_params);\n+    create_llargs_for_fn_args(fcx, no_self, dtor.inputs, ty_params);\n     let bcx = new_top_block_ctxt(fcx);\n     let lltop = bcx.llbb;\n     let arg_t = arg_tys_of_fn(ccx, ctor_id)[0].ty;\n     let tup_t = ty::mk_tup(ccx.tcx, [ty::mk_int(ccx.tcx), arg_t]);\n-    let arg = alt fcx.llargs.find(dtor.decl.inputs[0].id) {\n+    let arg = alt fcx.llargs.find(dtor.inputs[0].id) {\n       some(local_mem(x)) { x }\n     };\n     let llretptr = fcx.llretptr;\n@@ -4706,11 +4706,11 @@ fn trans_impl(cx: @local_ctxt, name: ast::ident, methods: [@ast::method],\n               id: ast::node_id, tps: [ast::ty_param]) {\n     let sub_cx = extend_path(cx, name);\n     for m in methods {\n-        alt cx.ccx.item_ids.find(m.node.id) {\n+        alt cx.ccx.item_ids.find(m.id) {\n           some(llfn) {\n-            trans_fn(extend_path(sub_cx, m.node.ident), m.span, m.node.meth,\n+            trans_fn(extend_path(sub_cx, m.ident), m.span, m.decl, m.body,\n                      llfn, impl_self(ty::node_id_to_monotype(cx.ccx.tcx, id)),\n-                     tps + m.node.tps, m.node.id);\n+                     tps + m.tps, m.id);\n           }\n         }\n     }\n@@ -4996,11 +4996,12 @@ fn trans_native_mod(lcx: @local_ctxt, native_mod: ast::native_mod,\n \n fn trans_item(cx: @local_ctxt, item: ast::item) {\n     alt item.node {\n-      ast::item_fn(f, tps) {\n+      ast::item_fn(decl, tps, body) {\n         let sub_cx = extend_path(cx, item.ident);\n         alt cx.ccx.item_ids.find(item.id) {\n           some(llfndecl) {\n-            trans_fn(sub_cx, item.span, f, llfndecl, no_self, tps, item.id);\n+            trans_fn(sub_cx, item.span, decl, body, llfndecl, no_self, tps,\n+                     item.id);\n           }\n           _ {\n             cx.ccx.sess.span_fatal(item.span,\n@@ -5017,13 +5018,14 @@ fn trans_item(cx: @local_ctxt, item: ast::item) {\n       ast::item_impl(tps, _, ms) {\n         trans_impl(cx, item.ident, ms, item.id, tps);\n       }\n-      ast::item_res(dtor, dtor_id, tps, ctor_id) {\n-        trans_res_ctor(cx, item.span, dtor, ctor_id, tps);\n+      ast::item_res(decl, tps, body, dtor_id, ctor_id) {\n+        trans_res_ctor(cx, item.span, decl, ctor_id, tps);\n \n         // Create a function for the destructor\n         alt cx.ccx.item_ids.find(item.id) {\n           some(lldtor_decl) {\n-            trans_fn(cx, item.span, dtor, lldtor_decl, no_self, tps, dtor_id);\n+            trans_fn(cx, item.span, decl, body, lldtor_decl, no_self,\n+                     tps, dtor_id);\n           }\n           _ {\n             cx.ccx.sess.span_fatal(item.span, \"unbound dtor in trans_item\");\n@@ -5329,25 +5331,25 @@ fn collect_item_2(ccx: @crate_ctxt, i: @ast::item, &&pt: [str],\n     let new_pt = pt + [i.ident];\n     visit::visit_item(i, new_pt, v);\n     alt i.node {\n-      ast::item_fn(f, tps) {\n+      ast::item_fn(_, tps, _) {\n         if !ccx.obj_methods.contains_key(i.id) {\n             register_fn(ccx, i.span, new_pt, \"fn\", tps, i.id);\n         }\n       }\n       ast::item_obj(ob, tps, ctor_id) {\n         register_fn(ccx, i.span, new_pt, \"obj_ctor\", tps, ctor_id);\n         for m: @ast::method in ob.methods {\n-            ccx.obj_methods.insert(m.node.id, ());\n+            ccx.obj_methods.insert(m.id, ());\n         }\n       }\n       ast::item_impl(tps, _, methods) {\n         let name = ccx.names.next(i.ident);\n         for m in methods {\n-            register_fn(ccx, i.span, pt + [name, m.node.ident],\n-                        \"impl_method\", tps + m.node.tps, m.node.id);\n+            register_fn(ccx, i.span, pt + [name, m.ident],\n+                        \"impl_method\", tps + m.tps, m.id);\n         }\n       }\n-      ast::item_res(_, dtor_id, tps, ctor_id) {\n+      ast::item_res(_, tps, _, dtor_id, ctor_id) {\n         register_fn(ccx, i.span, new_pt, \"res_ctor\", tps, ctor_id);\n         // Note that the destructor is associated with the item's id, not\n         // the dtor_id. This is a bit counter-intuitive, but simplifies"}, {"sha": "72315130022a42fa14365ac74009b52f6f2da86b", "filename": "src/comp/middle/trans_closure.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/dcd771cd4815e43558210ad1fcc7d6a219afafa5/src%2Fcomp%2Fmiddle%2Ftrans_closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcd771cd4815e43558210ad1fcc7d6a219afafa5/src%2Fcomp%2Fmiddle%2Ftrans_closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_closure.rs?ref=dcd771cd4815e43558210ad1fcc7d6a219afafa5", "patch": "@@ -372,7 +372,8 @@ fn load_environment(enclosing_cx: @block_ctxt,\n }\n \n fn trans_expr_fn(bcx: @block_ctxt,\n-                 f: ast::_fn,\n+                 decl: ast::fn_decl,\n+                 body: ast::blk,\n                  sp: span,\n                  id: ast::node_id,\n                  cap_clause: ast::capture_clause,\n@@ -389,21 +390,22 @@ fn trans_expr_fn(bcx: @block_ctxt,\n \n     let trans_closure_env = lambda(ck: ty::closure_kind) -> ValueRef {\n         let cap_vars = capture::compute_capture_vars(\n-            ccx.tcx, id, f.proto, cap_clause);\n+            ccx.tcx, id, decl.proto, cap_clause);\n         let {llbox, box_ty, bcx} = build_closure(bcx, cap_vars, ck);\n-        trans_closure(sub_cx, sp, f, llfn, no_self, [], id, {|fcx|\n+        trans_closure(sub_cx, sp, decl, body, llfn, no_self, [], id, {|fcx|\n             load_environment(bcx, fcx, box_ty, cap_vars, ck);\n         });\n         llbox\n     };\n \n-    let closure = alt f.proto {\n+    let closure = alt decl.proto {\n       ast::proto_block. { trans_closure_env(ty::closure_block) }\n       ast::proto_shared(_) { trans_closure_env(ty::closure_shared) }\n       ast::proto_send. { trans_closure_env(ty::closure_send) }\n       ast::proto_bare. {\n         let closure = C_null(T_opaque_boxed_closure_ptr(ccx));\n-        trans_closure(sub_cx, sp, f, llfn, no_self, [], id, {|_fcx|});\n+        trans_closure(sub_cx, sp, decl, body, llfn, no_self, [],\n+                      id, {|_fcx|});\n         closure\n       }\n     };"}, {"sha": "963ec8e67b2e292855cfb26c22a32698255c1466", "filename": "src/comp/middle/trans_objects.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/dcd771cd4815e43558210ad1fcc7d6a219afafa5/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcd771cd4815e43558210ad1fcc7d6a219afafa5/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_objects.rs?ref=dcd771cd4815e43558210ad1fcc7d6a219afafa5", "patch": "@@ -386,21 +386,21 @@ tag vtbl_mthd {\n \n // Alphabetize ast::methods by ident.  A helper for create_vtbl.\n fn ast_mthd_lteq(&&a: @ast::method, &&b: @ast::method) -> bool {\n-    ret str::lteq(a.node.ident, b.node.ident);\n+    ret str::lteq(a.ident, b.ident);\n }\n \n // Alphabetize vtbl_mthds by ident.  A helper for create_vtbl.\n fn vtbl_mthd_lteq(a: vtbl_mthd, b: vtbl_mthd) -> bool {\n     alt a {\n       normal_mthd(ma) {\n         alt b {\n-          normal_mthd(mb) { ret str::lteq(ma.node.ident, mb.node.ident); }\n-          fwding_mthd(mb) { ret str::lteq(ma.node.ident, mb.ident); }\n+          normal_mthd(mb) { ret str::lteq(ma.ident, mb.ident); }\n+          fwding_mthd(mb) { ret str::lteq(ma.ident, mb.ident); }\n         }\n       }\n       fwding_mthd(ma) {\n         alt b {\n-          normal_mthd(mb) { ret str::lteq(ma.ident, mb.node.ident); }\n+          normal_mthd(mb) { ret str::lteq(ma.ident, mb.ident); }\n           fwding_mthd(mb) { ret str::lteq(ma.ident, mb.ident); }\n         }\n       }\n@@ -420,7 +420,7 @@ fn filtering_fn(cx: @local_ctxt, m: vtbl_mthd, addtl_meths: [@ast::method]) ->\n     alt m {\n       fwding_mthd(fm) {\n         for am: @ast::method in addtl_meths {\n-            if str::eq(am.node.ident, fm.ident) { ret none; }\n+            if str::eq(am.ident, fm.ident) { ret none; }\n         }\n         ret some(fwding_mthd(fm));\n       }\n@@ -876,25 +876,25 @@ fn process_normal_mthd(cx: @local_ctxt, m: @ast::method, self_ty: ty::t,\n \n     let llfnty = T_nil();\n     let ccx = cx.ccx;\n-    alt ty::struct(cx.ccx.tcx, node_id_type(cx.ccx, m.node.id)) {\n+    alt ty::struct(cx.ccx.tcx, node_id_type(cx.ccx, m.id)) {\n       ty::ty_fn(_, inputs, output, rs, _) {\n         check non_ty_var(ccx, output);\n         llfnty = type_of_fn(ccx, m.span, true, inputs, output,\n                             vec::len(ty_params));\n       }\n     }\n     let mcx: @local_ctxt =\n-        @{path: cx.path + [\"method\", m.node.ident] with *cx};\n+        @{path: cx.path + [\"method\", m.ident] with *cx};\n     let s: str = mangle_internal_name_by_path(mcx.ccx, mcx.path);\n     let llfn: ValueRef = decl_internal_cdecl_fn(ccx.llmod, s, llfnty);\n \n     // Every method on an object gets its node_id inserted into the crate-wide\n     // item_ids map, together with the ValueRef that points to where that\n     // method's definition will be in the executable.\n-    ccx.item_ids.insert(m.node.id, llfn);\n-    ccx.item_symbols.insert(m.node.id, s);\n-    trans_fn(mcx, m.span, m.node.meth, llfn, obj_self(self_ty), ty_params,\n-             m.node.id);\n+    ccx.item_ids.insert(m.id, llfn);\n+    ccx.item_symbols.insert(m.id, s);\n+    trans_fn(mcx, m.span, m.decl, m.body, llfn, obj_self(self_ty), ty_params,\n+             m.id);\n \n     ret llfn;\n }"}, {"sha": "058b68fc92865407dd5c2c90705a40ad6bde1d72", "filename": "src/comp/middle/tstate/ck.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dcd771cd4815e43558210ad1fcc7d6a219afafa5/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcd771cd4815e43558210ad1fcc7d6a219afafa5/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs?ref=dcd771cd4815e43558210ad1fcc7d6a219afafa5", "patch": "@@ -1,8 +1,6 @@\n \n import syntax::ast;\n-import ast::{_fn, stmt,\n-             fn_ident, node_id, crate, return_val, noreturn,\n-             expr};\n+import ast::{stmt, fn_ident, node_id, crate, return_val, noreturn, expr};\n import syntax::{visit, print};\n import syntax::codemap::span;\n import middle::ty::{type_is_nil, ret_ty_of_fn};"}, {"sha": "6ac6daaa3fc45e863d70f6180811bf12f5dc5637", "filename": "src/comp/middle/tstate/pre_post_conditions.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/dcd771cd4815e43558210ad1fcc7d6a219afafa5/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcd771cd4815e43558210ad1fcc7d6a219afafa5/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs?ref=dcd771cd4815e43558210ad1fcc7d6a219afafa5", "patch": "@@ -27,13 +27,13 @@ fn find_pre_post_native_mod(_m: native_mod) -> native_mod {\n }\n \n fn find_pre_post_method(ccx: crate_ctxt, m: @method) {\n-    assert (ccx.fm.contains_key(m.node.id));\n+    assert (ccx.fm.contains_key(m.id));\n     let fcx: fn_ctxt =\n-        {enclosing: ccx.fm.get(m.node.id),\n-         id: m.node.id,\n-         name: m.node.ident,\n+        {enclosing: ccx.fm.get(m.id),\n+         id: m.id,\n+         name: m.ident,\n          ccx: ccx};\n-    find_pre_post_fn(fcx, m.node.meth.body);\n+    find_pre_post_fn(fcx, m.body);\n }\n \n fn find_pre_post_item(ccx: crate_ctxt, i: item) {\n@@ -56,23 +56,23 @@ fn find_pre_post_item(ccx: crate_ctxt, i: item) {\n              ccx: ccx};\n         find_pre_post_expr(fake_fcx, e);\n       }\n-      item_fn(f, _) {\n+      item_fn(_, _, body) {\n         assert (ccx.fm.contains_key(i.id));\n         let fcx =\n             {enclosing: ccx.fm.get(i.id), id: i.id, name: i.ident, ccx: ccx};\n-        find_pre_post_fn(fcx, f.body);\n+        find_pre_post_fn(fcx, body);\n       }\n       item_mod(m) { find_pre_post_mod(m); }\n       item_native_mod(nm) { find_pre_post_native_mod(nm); }\n       item_ty(_, _) { ret; }\n       item_tag(_, _) { ret; }\n-      item_res(dtor, dtor_id, _, _) {\n+      item_res(_, _, body, dtor_id, _) {\n         let fcx =\n             {enclosing: ccx.fm.get(dtor_id),\n              id: dtor_id,\n              name: i.ident,\n              ccx: ccx};\n-        find_pre_post_fn(fcx, dtor.body);\n+        find_pre_post_fn(fcx, body);\n       }\n       item_obj(o, _, _) {for m in o.methods { find_pre_post_method(ccx, m); }}\n       item_impl(_, _, ms) { for m in ms { find_pre_post_method(ccx, m); } }\n@@ -347,7 +347,7 @@ fn find_pre_post_expr(fcx: fn_ctxt, e: @expr) {\n       expr_log(_, lvl, arg) {\n         find_pre_post_exprs(fcx, [lvl, arg], e.id);\n       }\n-      expr_fn(f, cap_clause) {\n+      expr_fn(_, _, cap_clause) {\n         find_pre_post_expr_fn_upvars(fcx, e);\n \n         let use_cap_item = lambda(&&cap_item: @capture_item) {"}, {"sha": "e1f802954d11101ac7b580f619752fae3a779f5e", "filename": "src/comp/middle/tstate/states.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dcd771cd4815e43558210ad1fcc7d6a219afafa5/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcd771cd4815e43558210ad1fcc7d6a219afafa5/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs?ref=dcd771cd4815e43558210ad1fcc7d6a219afafa5", "patch": "@@ -371,7 +371,7 @@ fn find_pre_post_state_expr(fcx: fn_ctxt, pres: prestate, e: @expr) -> bool {\n       }\n       expr_mac(_) { fcx.ccx.tcx.sess.bug(\"unexpanded macro\"); }\n       expr_lit(l) { ret pure_exp(fcx.ccx, e.id, pres); }\n-      expr_fn(_, cap_clause) {\n+      expr_fn(_, _, cap_clause) {\n         ret find_pre_post_state_cap_clause(fcx, e.id, pres, *cap_clause);\n       }\n       expr_fn_block(_, _) { ret pure_exp(fcx.ccx, e.id, pres); }"}, {"sha": "22b55e7994ed723e18ae3e1e4bf6d750be64b6f5", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 49, "deletions": 60, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/dcd771cd4815e43558210ad1fcc7d6a219afafa5/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcd771cd4815e43558210ad1fcc7d6a219afafa5/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=dcd771cd4815e43558210ad1fcc7d6a219afafa5", "patch": "@@ -256,10 +256,10 @@ fn ast_ty_to_ty(tcx: ty::ctxt, mode: mode, &&ast_ty: @ast::ty) -> ty::t {\n           }\n         }\n     }\n-    fn ast_arg_to_arg(tcx: ty::ctxt, mode: mode, arg: ast::ty_arg)\n+    fn ast_arg_to_arg(tcx: ty::ctxt, mode: mode, arg: ast::arg)\n         -> {mode: ty::mode, ty: ty::t} {\n-        let ty = ast_ty_to_ty(tcx, mode, arg.node.ty);\n-        ret {mode: default_arg_mode_for_ty(tcx, arg.node.mode, ty), ty: ty};\n+        let ty = ast_ty_to_ty(tcx, mode, arg.ty);\n+        ret {mode: default_arg_mode_for_ty(tcx, arg.mode, ty), ty: ty};\n     }\n     alt tcx.ast_ty_to_ty_cache.find(ast_ty) {\n       some(some(ty)) { ret ty; }\n@@ -333,18 +333,8 @@ fn ast_ty_to_ty(tcx: ty::ctxt, mode: mode, &&ast_ty: @ast::ty) -> ty::t {\n         }\n         typ = ty::mk_rec(tcx, flds);\n       }\n-      ast::ty_fn(proto, inputs, output, cf, constrs) {\n-        let i = [];\n-        for ta: ast::ty_arg in inputs {\n-            i += [ast_arg_to_arg(tcx, mode, ta)];\n-        }\n-        let out_ty = ast_ty_to_ty(tcx, mode, output);\n-\n-        let out_constrs = [];\n-        for constr: @ast::constr in constrs {\n-            out_constrs += [ty::ast_constr_to_constr(tcx, constr)];\n-        }\n-        typ = ty::mk_fn(tcx, proto, i, out_ty, cf, out_constrs);\n+      ast::ty_fn(decl) {\n+        typ = ty_of_fn_decl(tcx, mode, decl);\n       }\n       ast::ty_path(path, id) {\n         alt tcx.def_map.find(id) {\n@@ -366,7 +356,7 @@ fn ast_ty_to_ty(tcx: ty::ctxt, mode: mode, &&ast_ty: @ast::ty) -> ty::t {\n         let tmeths: [ty::method] = [];\n         for m: ast::ty_method in meths {\n             let ins = [];\n-            for ta: ast::ty_arg in m.node.inputs {\n+            for ta: ast::arg in m.node.inputs {\n                 ins += [ast_arg_to_arg(tcx, mode, ta)];\n             }\n             let out = ast_ty_to_ty(tcx, mode, m.node.output);\n@@ -414,9 +404,8 @@ fn ty_of_item(tcx: ty::ctxt, mode: mode, it: @ast::item)\n         tcx.tcache.insert(local_def(it.id), tpt);\n         ret tpt;\n       }\n-      ast::item_fn(fn_info, tps) {\n-        ret ty_of_fn_decl(tcx, mode, fn_info.decl, fn_info.proto,\n-                          tps, some(local_def(it.id)));\n+      ast::item_fn(decl, tps, _) {\n+        ret ty_of_fn(tcx, mode, decl, tps, local_def(it.id));\n       }\n       ast::item_obj(ob, tps, _) {\n         let t_obj = ty_of_obj(tcx, mode, it.ident, ob, tps);\n@@ -435,8 +424,8 @@ fn ty_of_item(tcx: ty::ctxt, mode: mode, it: @ast::item)\n         tcx.tcache.insert(local_def(it.id), tpt);\n         ret tpt;\n       }\n-      ast::item_res(f, _, tps, _) {\n-        let t_arg = ty_of_arg(tcx, mode, f.decl.inputs[0]);\n+      ast::item_res(decl, tps, _, _, _) {\n+        let t_arg = ty_of_arg(tcx, mode, decl.inputs[0]);\n         let t = ty::mk_named(tcx, ty::mk_res(tcx, local_def(it.id), t_arg.ty,\n                                              mk_ty_params(tcx, tps)),\n                              @it.ident);\n@@ -480,9 +469,7 @@ fn ty_of_arg(tcx: ty::ctxt, mode: mode, a: ast::arg) -> ty::arg {\n     let ty = ast_ty_to_ty(tcx, mode, a.ty);\n     {mode: default_arg_mode_for_ty(tcx, a.mode, ty), ty: ty}\n }\n-fn ty_of_fn_decl(tcx: ty::ctxt, mode: mode, decl: ast::fn_decl,\n-           proto: ast::proto, ty_params: [ast::ty_param],\n-           def_id: option::t<ast::def_id>) -> ty::ty_param_kinds_and_ty {\n+fn ty_of_fn_decl(tcx: ty::ctxt, mode: mode, decl: ast::fn_decl) -> ty::t {\n     let input_tys = [];\n     for a: ast::arg in decl.inputs { input_tys += [ty_of_arg(tcx, mode, a)]; }\n     let output_ty = ast_ty_to_ty(tcx, mode, decl.output);\n@@ -491,10 +478,14 @@ fn ty_of_fn_decl(tcx: ty::ctxt, mode: mode, decl: ast::fn_decl,\n     for constr: @ast::constr in decl.constraints {\n         out_constrs += [ty::ast_constr_to_constr(tcx, constr)];\n     }\n-    let t_fn = ty::mk_fn(tcx, proto, input_tys, output_ty,\n-                         decl.cf, out_constrs);\n-    let tpt = {kinds: ty_param_kinds(ty_params), ty: t_fn};\n-    alt def_id { some(did) { tcx.tcache.insert(did, tpt); } _ { } }\n+    ty::mk_fn(tcx, decl.proto, input_tys, output_ty, decl.cf, out_constrs)\n+}\n+fn ty_of_fn(tcx: ty::ctxt, mode: mode, decl: ast::fn_decl,\n+            ty_params: [ast::ty_param], def_id: ast::def_id)\n+    -> ty::ty_param_kinds_and_ty {\n+    let tpt = {kinds: ty_param_kinds(ty_params),\n+               ty: ty_of_fn_decl(tcx, mode, decl)};\n+    tcx.tcache.insert(def_id, tpt);\n     ret tpt;\n }\n fn ty_of_native_fn_decl(tcx: ty::ctxt, mode: mode, decl: ast::fn_decl,\n@@ -510,19 +501,19 @@ fn ty_of_native_fn_decl(tcx: ty::ctxt, mode: mode, decl: ast::fn_decl,\n     ret tpt;\n }\n fn ty_of_method(tcx: ty::ctxt, mode: mode, m: @ast::method) -> ty::method {\n-    let inputs = vec::map(m.node.meth.decl.inputs,\n+    let inputs = vec::map(m.decl.inputs,\n                           {|i| ty_of_arg(tcx, mode, i)});\n-    let output = ast_ty_to_ty(tcx, mode, m.node.meth.decl.output);\n+    let output = ast_ty_to_ty(tcx, mode, m.decl.output);\n \n     let out_constrs = [];\n-    for constr: @ast::constr in m.node.meth.decl.constraints {\n+    for constr: @ast::constr in m.decl.constraints {\n         out_constrs += [ty::ast_constr_to_constr(tcx, constr)];\n     }\n-    ret {proto: m.node.meth.proto,\n-         ident: m.node.ident,\n+    ret {proto: m.decl.proto,\n+         ident: m.ident,\n          inputs: inputs,\n          output: output,\n-         cf: m.node.meth.decl.cf,\n+         cf: m.decl.cf,\n          constrs: out_constrs};\n }\n fn ty_of_obj(tcx: ty::ctxt, mode: mode, id: ast::ident, ob: ast::_obj,\n@@ -691,10 +682,10 @@ mod collect {\n             for m in ms {\n                 let ty = ty::method_ty_to_fn_ty(\n                     cx.tcx, ty_of_method(cx.tcx, m_collect, m));\n-                cx.tcx.tcache.insert(local_def(m.node.id),\n-                                     {kinds: ty_param_kinds(m.node.tps),\n+                cx.tcx.tcache.insert(local_def(m.id),\n+                                     {kinds: ty_param_kinds(m.tps),\n                                       ty: ty});\n-                write::ty_only(cx.tcx, m.node.id, ty);\n+                write::ty_only(cx.tcx, m.id, ty);\n             }\n             write::ty_only(cx.tcx, it.id, ast_ty_to_ty(cx.tcx, m_collect,\n                                                        selfty));\n@@ -714,7 +705,7 @@ mod collect {\n             let method_types = ty_of_obj_methods(cx.tcx, m_collect, object);\n             let i = 0u;\n             for m in object.methods {\n-                write::ty_only(cx.tcx, m.node.id,\n+                write::ty_only(cx.tcx, m.id,\n                                ty::method_ty_to_fn_ty(cx.tcx,\n                                                       method_types[i]));\n                 i += 1u;\n@@ -731,8 +722,8 @@ mod collect {\n                 i += 1u;\n             }\n           }\n-          ast::item_res(f, dtor_id, tps, ctor_id) {\n-            let t_arg = ty_of_arg(cx.tcx, m_collect, f.decl.inputs[0]);\n+          ast::item_res(decl, tps, _, dtor_id, ctor_id) {\n+            let t_arg = ty_of_arg(cx.tcx, m_collect, decl.inputs[0]);\n             let t_res =\n                 ty::mk_res(cx.tcx, local_def(it.id), t_arg.ty,\n                            mk_ty_params(cx.tcx, tps));\n@@ -1000,7 +991,7 @@ mod writeback {\n         if !wbcx.success { ret; }\n         resolve_type_vars_for_node(wbcx, e.span, e.id);\n         alt e.node {\n-          ast::expr_fn({decl: decl, _}, _) |\n+          ast::expr_fn(decl, _, _) |\n           ast::expr_fn_block(decl, _) {\n             for input in decl.inputs {\n                 resolve_type_vars_for_node(wbcx, e.span, input.id);\n@@ -1504,14 +1495,12 @@ fn lookup_method(fcx: @fn_ctxt, isc: resolve::iscopes,\n fn check_expr_fn_with_unifier(fcx: @fn_ctxt,\n                               expr: @ast::expr,\n                               decl: ast::fn_decl,\n-                              proto: ast::proto,\n                               body: ast::blk,\n                               unify: unifier,\n                               expected: ty::t) {\n     let tcx = fcx.ccx.tcx;\n \n-    let fty = ty_of_fn_decl(tcx, m_check_tyvar(fcx), decl,\n-                            proto, [], none).ty;\n+    let fty = ty_of_fn_decl(tcx, m_check_tyvar(fcx), decl);\n \n     log #fmt(\"check_expr_fn_with_unifier %s fty=%s\",\n              expr_to_str(expr),\n@@ -1525,7 +1514,7 @@ fn check_expr_fn_with_unifier(fcx: @fn_ctxt,\n     // record projection work on type inferred arguments.\n     unify(fcx, expr.span, expected, fty);\n \n-    check_fn1(fcx.ccx, decl, proto, body, expr.id, some(fcx));\n+    check_fn1(fcx.ccx, decl, body, expr.id, some(fcx));\n }\n \n fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n@@ -1960,11 +1949,10 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n         if !arm_non_bot { result_ty = ty::mk_bot(tcx); }\n         write::ty_only_fixup(fcx, id, result_ty);\n       }\n-      ast::expr_fn(f, captures) {\n-        check_expr_fn_with_unifier(fcx, expr, f.decl,\n-                                   f.proto, f.body,\n+      ast::expr_fn(decl, body, captures) {\n+        check_expr_fn_with_unifier(fcx, expr, decl, body,\n                                    unify, expected);\n-        capture::check_capture_clause(tcx, expr.id, f.proto, *captures);\n+        capture::check_capture_clause(tcx, expr.id, decl.proto, *captures);\n       }\n       ast::expr_fn_block(decl, body) {\n         // Take the prototype from the expected type, but default to block:\n@@ -1980,8 +1968,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n         log #fmt(\"checking expr_fn_block %s expected=%s\",\n                  expr_to_str(expr),\n                  ty_to_str(tcx, expected));\n-        check_expr_fn_with_unifier(fcx, expr, decl,\n-                                   proto, body,\n+        check_expr_fn_with_unifier(fcx, expr, {proto: proto with decl}, body,\n                                    unify, expected);\n         write::ty_only_fixup(fcx, id, expected);\n       }\n@@ -2322,7 +2309,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n                option::t<ty::method> {\n \n                 for om: @ast::method in outer_obj_methods {\n-                    if str::eq(om.node.ident, m.ident) {\n+                    if str::eq(om.ident, m.ident) {\n                         // We'd better be overriding with one of the same\n                         // type.  Check to make sure.\n                         let new_type = ty_of_method(ccx.tcx, m_check, om);\n@@ -2351,7 +2338,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n         // collect::convert for regular objects.)\n         let i = 0u;\n         while i < vec::len(ao.methods) {\n-            write::ty_only(tcx, ao.methods[i].node.id,\n+            write::ty_only(tcx, ao.methods[i].id,\n                            ty::method_ty_to_fn_ty(tcx, method_types[i]));\n             i += 1u;\n         }\n@@ -2604,15 +2591,15 @@ fn check_constraints(fcx: @fn_ctxt, cs: [@ast::constr], args: [ast::arg]) {\n }\n \n fn check_fn(ccx: @crate_ctxt,\n-            f: ast::_fn,\n+            decl: ast::fn_decl,\n+            body: ast::blk,\n             id: ast::node_id,\n             old_fcx: option::t<@fn_ctxt>) {\n-    check_fn1(ccx, f.decl, f.proto, f.body, id, old_fcx);\n+    check_fn1(ccx, decl, body, id, old_fcx);\n }\n \n fn check_fn1(ccx: @crate_ctxt,\n              decl: ast::fn_decl,\n-             proto: ast::proto,\n              body: ast::blk,\n              id: ast::node_id,\n              old_fcx: option::t<@fn_ctxt>) {\n@@ -2628,7 +2615,7 @@ fn check_fn1(ccx: @crate_ctxt,\n     let fcx: @fn_ctxt =\n         @{ret_ty: ty::ty_fn_ret(ccx.tcx, ty::node_id_to_type(ccx.tcx, id)),\n           purity: purity,\n-          proto: proto,\n+          proto: decl.proto,\n           var_bindings: gather_result.var_bindings,\n           locals: gather_result.locals,\n           next_var_id: gather_result.next_var_id,\n@@ -2665,14 +2652,16 @@ fn check_fn1(ccx: @crate_ctxt,\n }\n \n fn check_method(ccx: @crate_ctxt, method: @ast::method) {\n-    check_fn(ccx, method.node.meth, method.node.id, none);\n+    check_fn(ccx, method.decl, method.body, method.id, none);\n }\n \n fn check_item(ccx: @crate_ctxt, it: @ast::item) {\n     alt it.node {\n       ast::item_const(_, e) { check_const(ccx, it.span, e, it.id); }\n-      ast::item_fn(f, _) { check_fn(ccx, f, it.id, none); }\n-      ast::item_res(f, dtor_id, _, _) { check_fn(ccx, f, dtor_id, none); }\n+      ast::item_fn(decl, _, body) { check_fn(ccx, decl, body, it.id, none); }\n+      ast::item_res(decl, _, body, dtor_id, _) {\n+        check_fn(ccx, decl, body, dtor_id, none);\n+      }\n       ast::item_obj(ob, _, _) {\n         // We're entering an object, so gather up the info we need.\n         ccx.self_infos += [self_obj(ob.fields,"}, {"sha": "98dfb74ea7053dbf86d729ca8ada3a55e12f29bc", "filename": "src/comp/syntax/ast.rs", "status": "modified", "additions": 10, "deletions": 21, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/dcd771cd4815e43558210ad1fcc7d6a219afafa5/src%2Fcomp%2Fsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcd771cd4815e43558210ad1fcc7d6a219afafa5/src%2Fcomp%2Fsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast.rs?ref=dcd771cd4815e43558210ad1fcc7d6a219afafa5", "patch": "@@ -226,7 +226,7 @@ tag expr_ {\n     expr_for(@local, @expr, blk);\n     expr_do_while(blk, @expr);\n     expr_alt(@expr, [arm]);\n-    expr_fn(_fn, @capture_clause);\n+    expr_fn(fn_decl, blk, @capture_clause);\n     expr_fn_block(fn_decl, blk);\n     expr_block(blk);\n \n@@ -307,20 +307,16 @@ type mt = {ty: @ty, mut: mutability};\n \n type ty_field_ = {ident: ident, mt: mt};\n \n-type ty_arg_ = {mode: mode, ty: @ty};\n-\n type ty_method_ =\n     {proto: proto,\n      ident: ident,\n-     inputs: [ty_arg],\n+     inputs: [arg],\n      output: @ty,\n      cf: ret_style,\n      constrs: [@constr]};\n \n type ty_field = spanned<ty_field_>;\n \n-type ty_arg = spanned<ty_arg_>;\n-\n type ty_method = spanned<ty_method_>;\n \n tag int_ty { ty_i; ty_char; ty_i8; ty_i16; ty_i32; ty_i64; }\n@@ -353,7 +349,7 @@ tag ty_ {\n     ty_port(@ty);\n     ty_chan(@ty);\n     ty_rec([ty_field]);\n-    ty_fn(proto, [ty_arg], @ty, ret_style, [@constr]);\n+    ty_fn(fn_decl);\n     ty_obj([ty_method]);\n     ty_tup([@ty]);\n     ty_path(@path, node_id);\n@@ -403,13 +399,11 @@ type ty_constr = spanned<ty_constr_>;\n  corresponding to these. */\n type arg = {mode: mode, ty: @ty, ident: ident, id: node_id};\n \n-tag inlineness { il_normal; il_inline; }\n-\n type fn_decl =\n-    {inputs: [arg],\n+    {proto: proto,\n+     inputs: [arg],\n      output: @ty,\n      purity: purity,\n-     il: inlineness,\n      cf: ret_style,\n      constraints: [@constr]};\n \n@@ -425,11 +419,8 @@ tag ret_style {\n     return_val; // everything else\n }\n \n-type _fn = {decl: fn_decl, proto: proto, body: blk};\n-\n-type method_ = {ident: ident, meth: _fn, id: node_id, tps: [ty_param]};\n-\n-type method = spanned<method_>;\n+type method = {ident: ident, tps: [ty_param], decl: fn_decl, body: blk,\n+               id: node_id, span: span};\n \n type obj_field = {mut: mutability, ty: @ty, ident: ident, id: node_id};\n type anon_obj_field =\n@@ -499,16 +490,14 @@ type item =  // For objs and resources, this is the type def_id\n \n tag item_ {\n     item_const(@ty, @expr);\n-    item_fn(_fn, [ty_param]);\n+    item_fn(fn_decl, [ty_param], blk);\n     item_mod(_mod);\n     item_native_mod(native_mod);\n     item_ty(@ty, [ty_param]);\n     item_tag([variant], [ty_param]);\n     item_obj(_obj, [ty_param], /* constructor id */node_id);\n-    item_res(_fn /* dtor */,\n-             node_id /* dtor id */,\n-             [ty_param],\n-             node_id /* ctor id */);\n+    item_res(fn_decl /* dtor */, [ty_param], blk,\n+             node_id /* dtor id */, node_id /* ctor id */);\n     item_impl([ty_param], @ty /* self */, [@method]);\n }\n "}, {"sha": "0c136819ce99a5583fcb02152eb0cc41b8fa2c82", "filename": "src/comp/syntax/fold.rs", "status": "modified", "additions": 21, "deletions": 30, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/dcd771cd4815e43558210ad1fcc7d6a219afafa5/src%2Fcomp%2Fsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcd771cd4815e43558210ad1fcc7d6a219afafa5/src%2Fcomp%2Fsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Ffold.rs?ref=dcd771cd4815e43558210ad1fcc7d6a219afafa5", "patch": "@@ -26,7 +26,7 @@ type ast_fold_precursor =\n      fold_native_item: fn@(&&@native_item, ast_fold) -> @native_item,\n      fold_item: fn@(&&@item, ast_fold) -> @item,\n      fold_item_underscore: fn@(item_, ast_fold) -> item_,\n-     fold_method: fn@(method_, ast_fold) -> method_,\n+     fold_method: fn@(&&@method, ast_fold) -> @method,\n      fold_block: fn@(blk_, ast_fold) -> blk_,\n      fold_stmt: fn@(stmt_, ast_fold) -> stmt_,\n      fold_arm: fn@(arm, ast_fold) -> arm,\n@@ -35,7 +35,6 @@ type ast_fold_precursor =\n      fold_expr: fn@(expr_, ast_fold) -> expr_,\n      fold_ty: fn@(ty_, ast_fold) -> ty_,\n      fold_constr: fn@(ast::constr_, ast_fold) -> constr_,\n-     fold_fn: fn@(_fn, ast_fold) -> _fn,\n      fold_mod: fn@(_mod, ast_fold) -> _mod,\n      fold_native_mod: fn@(native_mod, ast_fold) -> native_mod,\n      fold_variant: fn@(variant_, ast_fold) -> variant_,\n@@ -62,7 +61,6 @@ type a_f =\n      fold_expr: fn@(&&@expr) -> @expr,\n      fold_ty: fn@(&&@ty) -> @ty,\n      fold_constr: fn@(&&@constr) -> @constr,\n-     fold_fn: fn@(_fn) -> _fn,\n      fold_mod: fn@(_mod) -> _mod,\n      fold_native_mod: fn@(native_mod) -> native_mod,\n      fold_variant: fn@(variant) -> variant,\n@@ -92,7 +90,6 @@ fn nf_decl_dummy(&&_d: @decl) -> @decl { fail; }\n fn nf_expr_dummy(&&_e: @expr) -> @expr { fail; }\n fn nf_ty_dummy(&&_t: @ty) -> @ty { fail; }\n fn nf_constr_dummy(&&_c: @constr) -> @constr { fail; }\n-fn nf_fn_dummy(_f: _fn) -> _fn { fail; }\n fn nf_mod_dummy(_m: _mod) -> _mod { fail; }\n fn nf_native_mod_dummy(_n: native_mod) -> native_mod { fail; }\n fn nf_variant_dummy(_v: variant) -> variant { fail; }\n@@ -124,7 +121,7 @@ fn fold_attribute_(at: attribute, fmi: fn@(&&@meta_item) -> @meta_item) ->\n     ret {node: {style: at.node.style, value: *fmi(@at.node.value)},\n          span: at.span};\n }\n-//used in noop_fold_native_item and noop_fold_fn\n+//used in noop_fold_native_item and noop_fold_fn_decl\n fn fold_arg_(a: arg, fld: ast_fold) -> arg {\n     ret {mode: a.mode,\n          ty: fld.fold_ty(a.ty),\n@@ -146,10 +143,10 @@ fn fold_mac_(m: mac, fld: ast_fold) -> mac {\n }\n \n fn fold_fn_decl(decl: ast::fn_decl, fld: ast_fold) -> ast::fn_decl {\n-    ret {inputs: vec::map(decl.inputs, bind fold_arg_(_, fld)),\n+    ret {proto: decl.proto,\n+         inputs: vec::map(decl.inputs, bind fold_arg_(_, fld)),\n          output: fld.fold_ty(decl.output),\n          purity: decl.purity,\n-         il: decl.il,\n          cf: decl.cf,\n          constraints: vec::map(decl.constraints, fld.fold_constr)}\n }\n@@ -195,10 +192,10 @@ fn noop_fold_native_item(&&ni: @native_item, fld: ast_fold) -> @native_item {\n               alt ni.node {\n                 native_item_ty. { native_item_ty }\n                 native_item_fn(fdec, typms) {\n-                  native_item_fn({inputs: vec::map(fdec.inputs, fold_arg),\n+                  native_item_fn({proto: fdec.proto,\n+                                  inputs: vec::map(fdec.inputs, fold_arg),\n                                   output: fld.fold_ty(fdec.output),\n                                   purity: fdec.purity,\n-                                  il: fdec.il,\n                                   cf: fdec.cf,\n                                   constraints:\n                                       vec::map(fdec.constraints,\n@@ -231,7 +228,10 @@ fn noop_fold_item_underscore(i: item_, fld: ast_fold) -> item_ {\n \n     ret alt i {\n           item_const(t, e) { item_const(fld.fold_ty(t), fld.fold_expr(e)) }\n-          item_fn(f, typms) { item_fn(fld.fold_fn(f), typms) }\n+          item_fn(decl, typms, body) {\n+              let body = fld.fold_block(body);\n+              item_fn(fold_fn_decl(decl, fld), typms, body)\n+          }\n           item_mod(m) { item_mod(fld.fold_mod(m)) }\n           item_native_mod(nm) { item_native_mod(fld.fold_native_mod(nm)) }\n           item_ty(t, typms) { item_ty(fld.fold_ty(t), typms) }\n@@ -247,15 +247,17 @@ fn noop_fold_item_underscore(i: item_, fld: ast_fold) -> item_ {\n             item_impl(tps, fld.fold_ty(ty),\n                       vec::map(methods, fld.fold_method))\n           }\n-          item_res(dtor, did, typms, cid) {\n-            item_res(fld.fold_fn(dtor), did, typms, cid)\n+          item_res(decl, typms, body, did, cid) {\n+            item_res(fold_fn_decl(decl, fld), typms, fld.fold_block(body),\n+                     did, cid)\n           }\n         };\n }\n \n-fn noop_fold_method(m: method_, fld: ast_fold) -> method_ {\n-    ret {ident: fld.fold_ident(m.ident), meth: fld.fold_fn(m.meth)\n-         with m};\n+fn noop_fold_method(&&m: @method, fld: ast_fold) -> @method {\n+    ret @{ident: fld.fold_ident(m.ident),\n+          decl: fold_fn_decl(m.decl, fld),\n+          body: fld.fold_block(m.body) with *m};\n }\n \n \n@@ -393,7 +395,9 @@ fn noop_fold_expr(e: expr_, fld: ast_fold) -> expr_ {\n           expr_alt(expr, arms) {\n             expr_alt(fld.fold_expr(expr), vec::map(arms, fld.fold_arm))\n           }\n-          expr_fn(f, captures) { expr_fn(fld.fold_fn(f), captures) }\n+          expr_fn(decl, body, captures) {\n+              expr_fn(fold_fn_decl(decl, fld), fld.fold_block(body), captures)\n+          }\n           expr_fn_block(decl, body) {\n             expr_fn_block(fold_fn_decl(decl, fld), fld.fold_block(body))\n           }\n@@ -446,13 +450,6 @@ fn noop_fold_constr(c: constr_, fld: ast_fold) -> constr_ {\n     {path: fld.fold_path(c.path), args: c.args, id: c.id}\n }\n \n-// functions just don't get spans, for some reason\n-fn noop_fold_fn(f: _fn, fld: ast_fold) -> _fn {\n-    ret {decl: fold_fn_decl(f.decl, fld),\n-         proto: f.proto,\n-         body: fld.fold_block(f.body)};\n-}\n-\n // ...nor do modules\n fn noop_fold_mod(m: _mod, fld: ast_fold) -> _mod {\n     ret {view_items: vec::map(m.view_items, fld.fold_view_item),\n@@ -521,7 +518,6 @@ fn default_ast_fold() -> @ast_fold_precursor {\n           fold_expr: noop_fold_expr,\n           fold_ty: noop_fold_ty,\n           fold_constr: noop_fold_constr,\n-          fold_fn: noop_fold_fn,\n           fold_mod: noop_fold_mod,\n           fold_native_mod: noop_fold_native_mod,\n           fold_variant: noop_fold_variant,\n@@ -552,7 +548,6 @@ fn make_fold(afp: ast_fold_precursor) -> ast_fold {\n                   fold_expr: bind nf_expr_dummy(_),\n                   fold_ty: bind nf_ty_dummy(_),\n                   fold_constr: bind nf_constr_dummy(_),\n-                  fold_fn: bind nf_fn_dummy(_),\n                   fold_mod: bind nf_mod_dummy(_),\n                   fold_native_mod: bind nf_native_mod_dummy(_),\n                   fold_variant: bind nf_variant_dummy(_),\n@@ -590,7 +585,7 @@ fn make_fold(afp: ast_fold_precursor) -> ast_fold {\n     }\n     fn f_method(afp: ast_fold_precursor, f: ast_fold, &&x: @method)\n         -> @method {\n-        ret @{node: afp.fold_method(x.node, f), span: afp.new_span(x.span)};\n+        ret afp.fold_method(x, f);\n     }\n     fn f_block(afp: ast_fold_precursor, f: ast_fold, x: blk) -> blk {\n         ret {node: afp.fold_block(x.node, f), span: afp.new_span(x.span)};\n@@ -621,9 +616,6 @@ fn make_fold(afp: ast_fold_precursor) -> ast_fold {\n        @ast::constr {\n         ret @{node: afp.fold_constr(x.node, f), span: afp.new_span(x.span)};\n     }\n-    fn f_fn(afp: ast_fold_precursor, f: ast_fold, x: _fn) -> _fn {\n-        ret afp.fold_fn(x, f);\n-    }\n     fn f_mod(afp: ast_fold_precursor, f: ast_fold, x: _mod) -> _mod {\n         ret afp.fold_mod(x, f);\n     }\n@@ -661,7 +653,6 @@ fn make_fold(afp: ast_fold_precursor) -> ast_fold {\n          fold_expr: bind f_expr(afp, result, _),\n          fold_ty: bind f_ty(afp, result, _),\n          fold_constr: bind f_constr(afp, result, _),\n-         fold_fn: bind f_fn(afp, result, _),\n          fold_mod: bind f_mod(afp, result, _),\n          fold_native_mod: bind f_native_mod(afp, result, _),\n          fold_variant: bind f_variant(afp, result, _),"}, {"sha": "f9034be4bf9df8b16406a266f5147229e297c332", "filename": "src/comp/syntax/parse/parser.rs", "status": "modified", "additions": 45, "deletions": 55, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/dcd771cd4815e43558210ad1fcc7d6a219afafa5/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcd771cd4815e43558210ad1fcc7d6a219afafa5/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs?ref=dcd771cd4815e43558210ad1fcc7d6a219afafa5", "patch": "@@ -265,16 +265,14 @@ fn check_bad_word(p: parser) {\n }\n \n fn parse_ty_fn(proto: ast::proto, p: parser) -> ast::ty_ {\n-    fn parse_fn_input_ty(p: parser) -> ast::ty_arg {\n-        let lo = p.get_lo_pos();\n+    fn parse_fn_input_ty(p: parser) -> ast::arg {\n         let mode = parse_arg_mode(p);\n-        // Ignore arg name, if present\n-        if is_plain_ident(p) && p.look_ahead(1u) == token::COLON {\n-            p.bump();\n+        let name = if is_plain_ident(p) && p.look_ahead(1u) == token::COLON {\n+            let name = parse_value_ident(p);\n             p.bump();\n-        }\n-        let t = parse_ty(p, false);\n-        ret spanned(lo, t.span.hi, {mode: mode, ty: t});\n+            name\n+        } else { \"\" };\n+        ret {mode: mode, ty: parse_ty(p, false), ident: name, id: p.get_id()};\n     }\n     let inputs =\n         parse_seq(token::LPAREN, token::RPAREN, seq_sep(token::COMMA),\n@@ -283,25 +281,28 @@ fn parse_ty_fn(proto: ast::proto, p: parser) -> ast::ty_ {\n     //  auto constrs = parse_constrs(~[], p);\n     let constrs: [@ast::constr] = [];\n     let (ret_style, ret_ty) = parse_ret_ty(p);\n-    ret ast::ty_fn(proto, inputs.node, ret_ty, ret_style, constrs);\n+    ret ast::ty_fn({proto: proto, inputs: inputs.node, output: ret_ty,\n+                    purity: ast::impure_fn, cf: ret_style,\n+                    constraints: constrs});\n }\n \n fn parse_ty_obj(p: parser) -> ast::ty_ {\n     fn parse_method_sig(p: parser) -> ast::ty_method {\n         let flo = p.get_lo_pos();\n         let proto: ast::proto = parse_method_proto(p);\n         let ident = parse_value_ident(p);\n-        let f = parse_ty_fn(proto, p);\n+        let f = parse_ty_fn(proto, p), fhi = p.get_last_hi_pos();\n         expect(p, token::SEMI);\n         alt f {\n-          ast::ty_fn(proto, inputs, output, cf, constrs) {\n-            ret spanned(flo, output.span.hi,\n-                        {proto: proto,\n+          ast::ty_fn(d) {\n+            // FIXME[fn_decl]\n+            ret spanned(flo, fhi,\n+                        {proto: d.proto,\n                          ident: ident,\n-                         inputs: inputs,\n-                         output: output,\n-                         cf: cf,\n-                         constrs: constrs});\n+                         inputs: d.inputs,\n+                         output: d.output,\n+                         cf: d.cf,\n+                         constrs: d.constraints});\n           }\n         }\n     }\n@@ -1325,10 +1326,10 @@ fn parse_capture_clause(p: parser) -> @ast::capture_clause {\n fn parse_fn_expr(p: parser, proto: ast::proto) -> @ast::expr {\n     let lo = p.get_last_lo_pos();\n     let capture_clause = parse_capture_clause(p);\n-    let decl = parse_fn_decl(p, ast::impure_fn, ast::il_normal);\n+    let decl = parse_fn_decl(p, proto, ast::impure_fn);\n     let body = parse_block(p);\n-    let _fn = {decl: decl, proto: proto, body: body};\n-    ret mk_expr(p, lo, body.span.hi, ast::expr_fn(_fn, capture_clause));\n+    ret mk_expr(p, lo, body.span.hi,\n+                ast::expr_fn(decl, body, capture_clause));\n }\n \n fn parse_fn_block_expr(p: parser) -> @ast::expr {\n@@ -1774,8 +1775,8 @@ fn parse_ty_params(p: parser) -> [ast::ty_param] {\n     ret ty_params;\n }\n \n-fn parse_fn_decl(p: parser, purity: ast::purity, il: ast::inlineness) ->\n-   ast::fn_decl {\n+fn parse_fn_decl(p: parser, proto: ast::proto, purity: ast::purity)\n+    -> ast::fn_decl {\n     let inputs: ast::spanned<[ast::arg]> =\n         parse_seq(token::LPAREN, token::RPAREN, seq_sep(token::COMMA),\n                   parse_arg, p);\n@@ -1788,10 +1789,10 @@ fn parse_fn_decl(p: parser, purity: ast::purity, il: ast::inlineness) ->\n         constrs = parse_constrs({|x| parse_ty_constr(inputs.node, x) }, p);\n     }\n     let (ret_style, ret_ty) = parse_ret_ty(p);\n-    ret {inputs: inputs.node,\n+    ret {proto: proto,\n+         inputs: inputs.node,\n          output: ret_ty,\n          purity: purity,\n-         il: il,\n          cf: ret_style,\n          constraints: constrs};\n }\n@@ -1802,21 +1803,14 @@ fn parse_fn_block_decl(p: parser) -> ast::fn_decl {\n                   seq_sep(token::COMMA), parse_fn_block_arg, p).node;\n     let output = eat(p, token::RARROW) ? parse_ty(p, false) :\n         @spanned(p.get_lo_pos(), p.get_hi_pos(), ast::ty_infer);\n-    ret {inputs: inputs,\n+    ret {proto: ast::proto_block,\n+         inputs: inputs,\n          output: output,\n          purity: ast::impure_fn,\n-         il: ast::il_normal,\n          cf: ast::return_val,\n          constraints: []};\n }\n \n-fn parse_fn(p: parser, proto: ast::proto, purity: ast::purity,\n-            il: ast::inlineness) -> ast::_fn {\n-    let decl = parse_fn_decl(p, purity, il);\n-    let body = parse_block(p);\n-    ret {decl: decl, proto: proto, body: body};\n-}\n-\n fn parse_fn_header(p: parser) -> {ident: ast::ident, tps: [ast::ty_param]} {\n     let id = parse_value_ident(p);\n     let ty_params = parse_ty_params(p);\n@@ -1833,13 +1827,13 @@ fn mk_item(p: parser, lo: uint, hi: uint, ident: ast::ident, node: ast::item_,\n }\n \n fn parse_item_fn(p: parser, purity: ast::purity, proto: ast::proto,\n-                         attrs: [ast::attribute], il: ast::inlineness) ->\n-   @ast::item {\n+                 attrs: [ast::attribute]) -> @ast::item {\n     let lo = p.get_last_lo_pos();\n     let t = parse_fn_header(p);\n-    let f = parse_fn(p, proto, purity, il);\n-    ret mk_item(p, lo, f.body.span.hi, t.ident, ast::item_fn(f, t.tps),\n-                attrs);\n+    let decl = parse_fn_decl(p, proto, purity);\n+    let body = parse_block(p);\n+    ret mk_item(p, lo, body.span.hi, t.ident,\n+                ast::item_fn(decl, t.tps, body), attrs);\n }\n \n fn parse_obj_field(p: parser) -> ast::obj_field {\n@@ -1865,9 +1859,10 @@ fn parse_method(p: parser, allow_tps: bool) -> @ast::method {\n     let proto = parse_method_proto(p);\n     let ident = parse_value_ident(p);\n     let tps = allow_tps ? parse_ty_params(p) : [];\n-    let f = parse_fn(p, proto, ast::impure_fn, ast::il_normal);\n-    let meth = {ident: ident, meth: f, id: p.get_id(), tps: tps};\n-    ret @spanned(lo, f.body.span.hi, meth);\n+    let decl = parse_fn_decl(p, proto, ast::impure_fn);\n+    let body = parse_block(p);\n+    @{ident: ident, tps: tps, decl: decl, body: body,\n+      id: p.get_id(), span: ast_util::mk_sp(lo, body.span.hi)}\n }\n \n fn parse_item_obj(p: parser, attrs: [ast::attribute]) -> @ast::item {\n@@ -1909,18 +1904,17 @@ fn parse_item_res(p: parser, attrs: [ast::attribute]) -> @ast::item {\n     expect(p, token::RPAREN);\n     let dtor = parse_block_no_value(p);\n     let decl =\n-        {inputs:\n+        {proto: ast::proto_bare,\n+         inputs:\n              [{mode: ast::by_ref, ty: t, ident: arg_ident,\n                id: p.get_id()}],\n          output: @spanned(lo, lo, ast::ty_nil),\n          purity: ast::impure_fn,\n-         il: ast::il_normal,\n          cf: ast::return_val,\n          constraints: []};\n-    let f = {decl: decl, proto: ast::proto_shared(ast::sugar_normal),\n-             body: dtor};\n     ret mk_item(p, lo, dtor.span.hi, ident,\n-                ast::item_res(f, p.get_id(), ty_params, p.get_id()), attrs);\n+                ast::item_res(decl, ty_params, dtor, p.get_id(), p.get_id()),\n+                attrs);\n }\n \n fn parse_mod_items(p: parser, term: token::token,\n@@ -1984,7 +1978,7 @@ fn parse_item_native_fn(p: parser, attrs: [ast::attribute],\n                         purity: ast::purity) -> @ast::native_item {\n     let lo = p.get_last_lo_pos();\n     let t = parse_fn_header(p);\n-    let decl = parse_fn_decl(p, purity, ast::il_normal);\n+    let decl = parse_fn_decl(p, ast::proto_bare, purity);\n     let hi = p.get_hi_pos();\n     expect(p, token::SEMI);\n     ret @{ident: t.ident,\n@@ -2142,24 +2136,20 @@ fn parse_item(p: parser, attrs: [ast::attribute]) -> option::t<@ast::item> {\n     } else if eat_word(p, \"inline\") {\n         expect_word(p, \"fn\");\n         let proto = parse_fn_item_proto(p);\n-        ret some(parse_item_fn(p, ast::impure_fn, proto,\n-                                       attrs, ast::il_inline));\n+        ret some(parse_item_fn(p, ast::impure_fn, proto, attrs));\n     } else if is_word(p, \"fn\") && p.look_ahead(1u) != token::LPAREN {\n         p.bump();\n         let proto = parse_fn_item_proto(p);\n-        ret some(parse_item_fn(p, ast::impure_fn, proto,\n-                               attrs, ast::il_normal));\n+        ret some(parse_item_fn(p, ast::impure_fn, proto, attrs));\n     } else if eat_word(p, \"pure\") {\n         expect_word(p, \"fn\");\n         let proto = parse_fn_item_proto(p);\n-        ret some(parse_item_fn(p, ast::pure_fn, proto, attrs,\n-                               ast::il_normal));\n+        ret some(parse_item_fn(p, ast::pure_fn, proto, attrs));\n     } else if is_word(p, \"unsafe\") && p.look_ahead(1u) != token::LBRACE {\n         p.bump();\n         expect_word(p, \"fn\");\n         let proto = parse_fn_item_proto(p);\n-        ret some(parse_item_fn(p, ast::unsafe_fn, proto,\n-                               attrs, ast::il_normal));\n+        ret some(parse_item_fn(p, ast::unsafe_fn, proto, attrs));\n     } else if eat_word(p, \"mod\") {\n         ret some(parse_item_mod(p, attrs));\n     } else if eat_word(p, \"native\") {"}, {"sha": "976fa3f1b9663581e544285f19ec29bd0f9a3609", "filename": "src/comp/syntax/print/pprust.rs", "status": "modified", "additions": 37, "deletions": 37, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/dcd771cd4815e43558210ad1fcc7d6a219afafa5/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcd771cd4815e43558210ad1fcc7d6a219afafa5/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs?ref=dcd771cd4815e43558210ad1fcc7d6a219afafa5", "patch": "@@ -91,10 +91,11 @@ fn path_to_str(&&p: @ast::path) -> str {\n     be to_str(p, bind print_path(_, _, false));\n }\n \n-fn fun_to_str(f: ast::_fn, name: ast::ident, params: [ast::ty_param]) -> str {\n+fn fun_to_str(decl: ast::fn_decl, name: ast::ident,\n+              params: [ast::ty_param]) -> str {\n     let writer = io::string_writer();\n     let s = rust_printer(writer.get_writer());\n-    print_fn(s, f.decl, f.proto, name, params, f.decl.constraints);\n+    print_fn(s, decl, name, params);\n     eof(s.s);\n     ret writer.get_str();\n }\n@@ -304,8 +305,9 @@ fn print_type(s: ps, &&ty: @ast::ty) {\n         commasep(s, inconsistent, elts, print_type);\n         pclose(s);\n       }\n-      ast::ty_fn(proto, inputs, output, cf, constrs) {\n-        print_ty_fn(s, proto, none::<str>, inputs, output, cf, constrs);\n+      ast::ty_fn(d) {\n+        print_ty_fn(s, d.proto, none::<str>, d.inputs, d.output, d.cf,\n+                    d.constraints);\n       }\n       ast::ty_obj(methods) {\n         head(s, \"obj\");\n@@ -348,8 +350,7 @@ fn print_native_item(s: ps, item: @ast::native_item) {\n \n       }\n       ast::native_item_fn(decl, typarams) {\n-        print_fn(s, decl, ast::proto_bare, item.ident, typarams,\n-                 decl.constraints);\n+        print_fn(s, decl, item.ident, typarams);\n         end(s); // end head-ibox\n         word(s.s, \";\");\n         end(s); // end the outer fn box\n@@ -377,11 +378,10 @@ fn print_item(s: ps, &&item: @ast::item) {\n         end(s); // end the outer cbox\n \n       }\n-      ast::item_fn(_fn, typarams) {\n-        print_fn(s, _fn.decl, _fn.proto, item.ident, typarams,\n-                 _fn.decl.constraints);\n+      ast::item_fn(decl, typarams, body) {\n+        print_fn(s, decl, item.ident, typarams);\n         word(s.s, \" \");\n-        print_block(s, _fn.body);\n+        print_block(s, body);\n       }\n       ast::item_mod(_mod) {\n         head(s, \"mod\");\n@@ -469,10 +469,9 @@ fn print_item(s: ps, &&item: @ast::item) {\n         for meth: @ast::method in _obj.methods {\n             hardbreak_if_not_bol(s);\n             maybe_print_comment(s, meth.span.lo);\n-            print_fn(s, meth.node.meth.decl, meth.node.meth.proto,\n-                     meth.node.ident, meth.node.tps, []);\n+            print_fn(s, meth.decl, meth.ident, meth.tps);\n             word(s.s, \" \");\n-            print_block(s, meth.node.meth.body);\n+            print_block(s, meth.body);\n         }\n         bclose(s, item.span);\n       }\n@@ -488,23 +487,22 @@ fn print_item(s: ps, &&item: @ast::item) {\n         for meth in methods {\n             hardbreak_if_not_bol(s);\n             maybe_print_comment(s, meth.span.lo);\n-            print_fn(s, meth.node.meth.decl, meth.node.meth.proto,\n-                     meth.node.ident, meth.node.tps, []);\n+            print_fn(s, meth.decl, meth.ident, meth.tps);\n             word(s.s, \" \");\n-            print_block(s, meth.node.meth.body);\n+            print_block(s, meth.body);\n         }\n         bclose(s, item.span);\n       }\n-      ast::item_res(dt, dt_id, tps, ct_id) {\n+      ast::item_res(decl, tps, body, dt_id, ct_id) {\n         head(s, \"resource\");\n         word(s.s, item.ident);\n         print_type_params(s, tps);\n         popen(s);\n-        word_space(s, dt.decl.inputs[0].ident + \":\");\n-        print_type(s, dt.decl.inputs[0].ty);\n+        word_space(s, decl.inputs[0].ident + \":\");\n+        print_type(s, decl.inputs[0].ty);\n         pclose(s);\n         space(s.s);\n-        print_block(s, dt.body);\n+        print_block(s, body);\n       }\n     }\n     s.ann.post(ann_node);\n@@ -826,11 +824,11 @@ fn print_expr(s: ps, &&expr: @ast::expr) {\n         }\n         bclose_(s, expr.span, alt_indent_unit);\n       }\n-      ast::expr_fn(f, captures) { // NDM captures\n-        head(s, proto_to_str(f.proto));\n-        print_fn_args_and_ret(s, f.decl, []);\n+      ast::expr_fn(decl, body, captures) { // NDM captures\n+        head(s, proto_to_str(decl.proto));\n+        print_fn_args_and_ret(s, decl);\n         space(s.s);\n-        print_block(s, f.body);\n+        print_block(s, body);\n       }\n       ast::expr_fn_block(decl, body) {\n         // containing cbox, will be closed by print-block at }\n@@ -976,10 +974,9 @@ fn print_expr(s: ps, &&expr: @ast::expr) {\n         for meth: @ast::method in anon_obj.methods {\n             hardbreak_if_not_bol(s);\n             maybe_print_comment(s, meth.span.lo);\n-            print_fn(s, meth.node.meth.decl, meth.node.meth.proto,\n-                     meth.node.ident, meth.node.tps, []);\n+            print_fn(s, meth.decl, meth.ident, meth.tps);\n             word(s.s, \" \");\n-            print_block(s, meth.node.meth.body);\n+            print_block(s, meth.body);\n         }\n \n         // With object\n@@ -1131,18 +1128,18 @@ fn print_pat(s: ps, &&pat: @ast::pat) {\n     s.ann.post(ann_node);\n }\n \n-fn print_fn(s: ps, decl: ast::fn_decl, proto: ast::proto, name: ast::ident,\n-            typarams: [ast::ty_param], constrs: [@ast::constr]) {\n+fn print_fn(s: ps, decl: ast::fn_decl, name: ast::ident,\n+            typarams: [ast::ty_param]) {\n     alt decl.purity {\n-      ast::impure_fn. { head(s, proto_to_str(proto)); }\n+      ast::impure_fn. { head(s, proto_to_str(decl.proto)); }\n       _ { head(s, \"pure fn\"); }\n     }\n     word(s.s, name);\n     print_type_params(s, typarams);\n-    print_fn_args_and_ret(s, decl, constrs);\n+    print_fn_args_and_ret(s, decl);\n }\n \n-fn print_fn_args_and_ret(s: ps, decl: ast::fn_decl, constrs: [@ast::constr]) {\n+fn print_fn_args_and_ret(s: ps, decl: ast::fn_decl) {\n     popen(s);\n     fn print_arg(s: ps, x: ast::arg) {\n         ibox(s, indent_unit);\n@@ -1153,7 +1150,7 @@ fn print_fn_args_and_ret(s: ps, decl: ast::fn_decl, constrs: [@ast::constr]) {\n     }\n     commasep(s, inconsistent, decl.inputs, print_arg);\n     pclose(s);\n-    word(s.s, ast_fn_constrs_str(decl, constrs));\n+    word(s.s, ast_fn_constrs_str(decl, decl.constraints));\n     maybe_print_comment(s, decl.output.span.lo);\n     if decl.output.node != ast::ty_nil {\n         space_if_not_bol(s);\n@@ -1342,16 +1339,19 @@ fn print_mt(s: ps, mt: ast::mt) {\n }\n \n fn print_ty_fn(s: ps, proto: ast::proto, id: option::t<ast::ident>,\n-               inputs: [ast::ty_arg], output: @ast::ty, cf: ast::ret_style,\n+               inputs: [ast::arg], output: @ast::ty, cf: ast::ret_style,\n                constrs: [@ast::constr]) {\n     ibox(s, indent_unit);\n     word(s.s, proto_to_str(proto));\n     alt id { some(id) { word(s.s, \" \"); word(s.s, id); } _ { } }\n     zerobreak(s.s);\n     popen(s);\n-    fn print_arg(s: ps, input: ast::ty_arg) {\n-        print_arg_mode(s, input.node.mode);\n-        print_type(s, input.node.ty);\n+    fn print_arg(s: ps, input: ast::arg) {\n+        print_arg_mode(s, input.mode);\n+        if str::byte_len(input.ident) > 0u {\n+            word_space(s, input.ident + \":\");\n+        }\n+        print_type(s, input.ty);\n     }\n     commasep(s, inconsistent, inputs, print_arg);\n     pclose(s);"}, {"sha": "ce1f67eb7b39b642f5220e3b780a1eac04e7db83", "filename": "src/comp/syntax/visit.rs", "status": "modified", "additions": 34, "deletions": 31, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/dcd771cd4815e43558210ad1fcc7d6a219afafa5/src%2Fcomp%2Fsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcd771cd4815e43558210ad1fcc7d6a219afafa5/src%2Fcomp%2Fsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fvisit.rs?ref=dcd771cd4815e43558210ad1fcc7d6a219afafa5", "patch": "@@ -33,7 +33,8 @@ type visitor<E> =\n       visit_constr: fn@(@path, span, node_id, E, vt<E>),\n \n       // A function with a fully specified prototype:\n-      visit_fn_proto: fn@(_fn, [ty_param], span, fn_ident, node_id, E, vt<E>),\n+      visit_fn_proto: fn@(fn_decl, [ty_param], blk, span, fn_ident, node_id,\n+                          E, vt<E>),\n \n       // Function sugar like { || ... }:\n       visit_fn_block: fn@(fn_decl, blk, span, node_id, E, vt<E>),\n@@ -56,7 +57,7 @@ fn default_visitor<E>() -> visitor<E> {\n           visit_expr: bind visit_expr::<E>(_, _, _),\n           visit_ty: bind skip_ty::<E>(_, _, _),\n           visit_constr: bind visit_constr::<E>(_, _, _, _, _),\n-          visit_fn_proto: bind visit_fn_proto::<E>(_, _, _, _, _, _, _),\n+          visit_fn_proto: bind visit_fn_proto::<E>(_, _, _, _, _, _, _, _),\n           visit_fn_block: bind visit_fn_block::<E>(_, _, _, _, _, _),\n           visit_fn_body: bind visit_fn_body::<E>(_, _, _, _, _, _, _)};\n }\n@@ -94,16 +95,18 @@ fn visit_local<E>(loc: @local, e: E, v: vt<E>) {\n fn visit_item<E>(i: @item, e: E, v: vt<E>) {\n     alt i.node {\n       item_const(t, ex) { v.visit_ty(t, e, v); v.visit_expr(ex, e, v); }\n-      item_fn(f, tp) { v.visit_fn_proto(f, tp, i.span,\n-                                        some(i.ident), i.id, e, v); }\n+      item_fn(decl, tp, body) {\n+        v.visit_fn_proto(decl, tp, body, i.span, some(i.ident), i.id, e, v);\n+      }\n       item_mod(m) { v.visit_mod(m, i.span, e, v); }\n       item_native_mod(nm) {\n         for vi: @view_item in nm.view_items { v.visit_view_item(vi, e, v); }\n         for ni: @native_item in nm.items { v.visit_native_item(ni, e, v); }\n       }\n       item_ty(t, _) { v.visit_ty(t, e, v); }\n-      item_res(f, dtor_id, tps, _) {\n-        v.visit_fn_proto(f, tps, i.span, some(i.ident), dtor_id, e, v);\n+      item_res(decl, tps, body, dtor_id, _) {\n+        v.visit_fn_proto(decl, tps, body, i.span, some(i.ident), dtor_id,\n+                         e, v);\n       }\n       item_tag(variants, _) {\n         for vr: variant in variants {\n@@ -113,15 +116,15 @@ fn visit_item<E>(i: @item, e: E, v: vt<E>) {\n       item_obj(ob, _, _) {\n         for f: obj_field in ob.fields { v.visit_ty(f.ty, e, v); }\n         for m: @method in ob.methods {\n-            v.visit_fn_proto(m.node.meth, m.node.tps, m.span,\n-                             some(m.node.ident), m.node.id, e, v);\n+            v.visit_fn_proto(m.decl, m.tps, m.body, m.span,\n+                             some(m.ident), m.id, e, v);\n         }\n       }\n       item_impl(_, ty, methods) {\n         visit_ty(ty, e, v);\n         for m in methods {\n-            v.visit_fn_proto(m.node.meth, m.node.tps, m.span,\n-                             some(m.node.ident), m.node.id, e, v);\n+            v.visit_fn_proto(m.decl, m.tps, m.body, m.span,\n+                             some(m.ident), m.id, e, v);\n         }\n       }\n     }\n@@ -139,16 +142,16 @@ fn visit_ty<E>(t: @ty, e: E, v: vt<E>) {\n         for f: ty_field in flds { v.visit_ty(f.node.mt.ty, e, v); }\n       }\n       ty_tup(ts) { for tt in ts { v.visit_ty(tt, e, v); } }\n-      ty_fn(_, args, out, _, constrs) {\n-        for a: ty_arg in args { v.visit_ty(a.node.ty, e, v); }\n-        for c: @constr in constrs {\n+      ty_fn(decl) {\n+        for a in decl.inputs { v.visit_ty(a.ty, e, v); }\n+        for c: @constr in decl.constraints {\n             v.visit_constr(c.node.path, c.span, c.node.id, e, v);\n         }\n-        v.visit_ty(out, e, v);\n+        v.visit_ty(decl.output, e, v);\n       }\n       ty_obj(tmeths) {\n         for m: ty_method in tmeths {\n-            for a: ty_arg in m.node.inputs { v.visit_ty(a.node.ty, e, v); }\n+            for a in m.node.inputs { v.visit_ty(a.ty, e, v); }\n             v.visit_ty(m.node.output, e, v);\n         }\n       }\n@@ -205,9 +208,9 @@ fn visit_fn_decl<E>(fd: fn_decl, e: E, v: vt<E>) {\n     v.visit_ty(fd.output, e, v);\n }\n \n-fn visit_fn_proto<E>(f: _fn, _tp: [ty_param], sp: span, i: fn_ident,\n-                     id: node_id, e: E, v: vt<E>) {\n-    v.visit_fn_body(f.decl, f.body, sp, i, id, e, v);\n+fn visit_fn_proto<E>(decl: fn_decl, _tp: [ty_param], body: blk, sp: span,\n+                     i: fn_ident, id: node_id, e: E, v: vt<E>) {\n+    v.visit_fn_body(decl, body, sp, i, id, e, v);\n }\n \n fn visit_fn_block<E>(decl: fn_decl, body: blk, sp: span, id: node_id,\n@@ -307,8 +310,8 @@ fn visit_expr<E>(ex: @expr, e: E, v: vt<E>) {\n         v.visit_expr(x, e, v);\n         for a: arm in arms { v.visit_arm(a, e, v); }\n       }\n-      expr_fn(f, captures) {\n-        v.visit_fn_proto(f, [], ex.span, none, ex.id, e, v);\n+      expr_fn(decl, body, _) {\n+        v.visit_fn_proto(decl, [], body, ex.span, none, ex.id, e, v);\n       }\n       expr_fn_block(decl, body) {\n         v.visit_fn_block(decl, body, ex.span, ex.id, e, v);\n@@ -354,8 +357,8 @@ fn visit_expr<E>(ex: @expr, e: E, v: vt<E>) {\n           some(ex) { v.visit_expr(ex, e, v); }\n         }\n         for m: @method in anon_obj.methods {\n-            v.visit_fn_proto(m.node.meth, m.node.tps, m.span,\n-                             some(m.node.ident), m.node.id, e, v);\n+            v.visit_fn_proto(m.decl, m.tps, m.body, m.span,\n+                             some(m.ident), m.id, e, v);\n         }\n       }\n       expr_mac(mac) { visit_mac(mac, e, v); }\n@@ -387,7 +390,7 @@ type simple_visitor =\n       visit_expr: fn@(@expr),\n       visit_ty: fn@(@ty),\n       visit_constr: fn@(@path, span, node_id),\n-      visit_fn_proto: fn@(_fn, [ty_param], span, fn_ident, node_id),\n+      visit_fn_proto: fn@(fn_decl, [ty_param], blk, span, fn_ident, node_id),\n       visit_fn_block: fn@(fn_decl, blk, span, node_id),\n       visit_fn_body: fn@(fn_decl, blk, span, fn_ident, node_id)};\n \n@@ -408,8 +411,8 @@ fn default_simple_visitor() -> simple_visitor {\n           visit_ty: simple_ignore_ty,\n           visit_constr: fn(_p: @path, _sp: span, _id: node_id) { },\n           visit_fn_proto:\n-              fn(_f: _fn, _tps: [ty_param], _sp: span, _ident: fn_ident,\n-                  _id: node_id) { },\n+              fn(_d: fn_decl, _tps: [ty_param], _b: blk, _sp: span,\n+                 _ident: fn_ident, _id: node_id) { },\n           visit_fn_block:\n               fn(_f: fn_decl, _b: blk, _sp: span, _node_id: node_id) { },\n           visit_fn_body:\n@@ -473,11 +476,11 @@ fn mk_simple_visitor(v: simple_visitor) -> vt<()> {\n         f(pt, sp, id);\n         visit_constr(pt, sp, id, e, v);\n     }\n-    fn v_fn(f: fn@(_fn, [ty_param], span, fn_ident, node_id), ff: _fn,\n-            tps: [ty_param], sp: span, ident: fn_ident, id: node_id, &&e: (),\n-            v: vt<()>) {\n-        f(ff, tps, sp, ident, id);\n-        visit_fn_proto(ff, tps, sp, ident, id, e, v);\n+    fn v_fn(f: fn@(fn_decl, [ty_param], blk, span, fn_ident, node_id),\n+            decl: fn_decl, tps: [ty_param], body: blk, sp: span,\n+            ident: fn_ident, id: node_id, &&e: (), v: vt<()>) {\n+        f(decl, tps, body, sp, ident, id);\n+        visit_fn_proto(decl, tps, body, sp, ident, id, e, v);\n     }\n     fn v_fn_block(f: fn@(fn_decl, blk, span, node_id),\n                   fn_decl: fn_decl, blk: blk,\n@@ -513,7 +516,7 @@ fn mk_simple_visitor(v: simple_visitor) -> vt<()> {\n                 visit_ty: visit_ty,\n                 visit_constr: bind v_constr(v.visit_constr, _, _, _, _, _),\n                 visit_fn_proto:\n-                    bind v_fn(v.visit_fn_proto, _, _, _, _, _, _, _),\n+                    bind v_fn(v.visit_fn_proto, _, _, _, _, _, _, _, _),\n                 visit_fn_block:\n                     bind v_fn_block(v.visit_fn_block, _, _, _, _, _, _),\n                 visit_fn_body:"}, {"sha": "0a1bcc8a9f1084f10821c6ac248365ac799239e2", "filename": "src/comp/util/common.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/dcd771cd4815e43558210ad1fcc7d6a219afafa5/src%2Fcomp%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcd771cd4815e43558210ad1fcc7d6a219afafa5/src%2Fcomp%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fcommon.rs?ref=dcd771cd4815e43558210ad1fcc7d6a219afafa5", "patch": "@@ -62,15 +62,6 @@ fn log_block_err(b: ast::blk) {\n fn log_item_err(i: @ast::item) {\n     log_full(core::error, print::pprust::item_to_str(i));\n }\n-\n-fn log_fn(f: ast::_fn, name: ast::ident, params: [ast::ty_param]) {\n-    log_full(core::debug, print::pprust::fun_to_str(f, name, params));\n-}\n-\n-fn log_fn_err(f: ast::_fn, name: ast::ident, params: [ast::ty_param]) {\n-    log_full(core::error, print::pprust::fun_to_str(f, name, params));\n-}\n-\n fn log_stmt(st: ast::stmt) {\n     log_full(core::debug, print::pprust::stmt_to_str(st));\n }"}, {"sha": "055f3e7749d632da9c43aa6fbb04088e3dc1707d", "filename": "src/rustdoc/rustdoc.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/dcd771cd4815e43558210ad1fcc7d6a219afafa5/src%2Frustdoc%2Frustdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcd771cd4815e43558210ad1fcc7d6a219afafa5/src%2Frustdoc%2Frustdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Frustdoc.rs?ref=dcd771cd4815e43558210ad1fcc7d6a219afafa5", "patch": "@@ -34,7 +34,7 @@ type fndoc = {\n        doc = \"Function docs extracted from attributes\",\n        _fn = \"AST object representing this function\")\n )]\n-fn doc_fn(rd: rustdoc, ident: str, doc: fndoc, _fn: ast::_fn) {\n+fn doc_fn(rd: rustdoc, ident: str, doc: fndoc, decl: ast::fn_decl) {\n     rd.w.write_line(\"## Function `\" + ident + \"`\");\n     rd.w.write_line(doc.brief);\n     alt doc.desc {\n@@ -45,7 +45,7 @@ fn doc_fn(rd: rustdoc, ident: str, doc: fndoc, _fn: ast::_fn) {\n         }\n         none. { }\n     }\n-    for arg: ast::arg in _fn.decl.inputs {\n+    for arg: ast::arg in decl.inputs {\n         rd.w.write_str(\"### Argument `\" + arg.ident + \"`: \");\n         rd.w.write_line(\"`\" + pprust::ty_to_str(arg.ty) + \"`\");\n         alt doc.args.find(arg.ident) {\n@@ -55,7 +55,7 @@ fn doc_fn(rd: rustdoc, ident: str, doc: fndoc, _fn: ast::_fn) {\n             none. { }\n         };\n     }\n-    rd.w.write_line(\"### Returns `\" + pprust::ty_to_str(_fn.decl.output) + \"`\");\n+    rd.w.write_line(\"### Returns `\" + pprust::ty_to_str(decl.output) + \"`\");\n     alt doc.return {\n         some(_r) { rd.w.write_line(_r); }\n         none. { }\n@@ -152,14 +152,14 @@ fn doc_item(rd: rustdoc, item: @ast::item) {\n \n     alt item.node {\n         ast::item_const(ty, expr) { }\n-        ast::item_fn(_fn, _) {\n-            doc_fn(rd, item.ident, _fndoc0, _fn);\n+        ast::item_fn(decl, _, _) {\n+            doc_fn(rd, item.ident, _fndoc0, decl);\n         }\n         ast::item_mod(_mod) { }\n         ast::item_ty(ty, typarams) { }\n         ast::item_tag(variant, typarams) { }\n         ast::item_obj(_obj, typarams, node_id) { }\n-        ast::item_res(dtor, dtorid, typarams, ctorid) { }\n+        ast::item_res(_, _, _, _, _) { }\n     };\n }\n "}]}