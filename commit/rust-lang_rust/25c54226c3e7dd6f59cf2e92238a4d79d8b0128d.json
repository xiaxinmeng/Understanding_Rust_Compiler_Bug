{"sha": "25c54226c3e7dd6f59cf2e92238a4d79d8b0128d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI1YzU0MjI2YzNlN2RkNmY1OWNmMmU5MjIzOGE0ZDc5ZDhiMDEyOGQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-05-16T18:41:30Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-05-16T18:41:30Z"}, "message": "auto merge of #13401 : cmr/rust/docs, r=brson\n\nAdds docs where previously there were no docs. Also adds windows support to libterm.", "tree": {"sha": "3625f520d90d08eeb4d5cf2e4e03b971fb09d954", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3625f520d90d08eeb4d5cf2e4e03b971fb09d954"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/25c54226c3e7dd6f59cf2e92238a4d79d8b0128d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/25c54226c3e7dd6f59cf2e92238a4d79d8b0128d", "html_url": "https://github.com/rust-lang/rust/commit/25c54226c3e7dd6f59cf2e92238a4d79d8b0128d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/25c54226c3e7dd6f59cf2e92238a4d79d8b0128d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bbd034c3a6e0325da0cb743cab007d69a736557a", "url": "https://api.github.com/repos/rust-lang/rust/commits/bbd034c3a6e0325da0cb743cab007d69a736557a", "html_url": "https://github.com/rust-lang/rust/commit/bbd034c3a6e0325da0cb743cab007d69a736557a"}, {"sha": "3da99c5d8a44f3d79eb02e76c30df2b20d2df38c", "url": "https://api.github.com/repos/rust-lang/rust/commits/3da99c5d8a44f3d79eb02e76c30df2b20d2df38c", "html_url": "https://github.com/rust-lang/rust/commit/3da99c5d8a44f3d79eb02e76c30df2b20d2df38c"}], "stats": {"total": 919, "additions": 615, "deletions": 304}, "files": [{"sha": "895819a5a50c0aae692a26c9e904a4155dac5908", "filename": "mk/crates.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/25c54226c3e7dd6f59cf2e92238a4d79d8b0128d/mk%2Fcrates.mk", "raw_url": "https://github.com/rust-lang/rust/raw/25c54226c3e7dd6f59cf2e92238a4d79d8b0128d/mk%2Fcrates.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcrates.mk?ref=25c54226c3e7dd6f59cf2e92238a4d79d8b0128d", "patch": "@@ -73,7 +73,7 @@ DEPS_arena := std collections\n DEPS_graphviz := std\n DEPS_glob := std\n DEPS_serialize := std collections log\n-DEPS_term := std collections\n+DEPS_term := std collections log\n DEPS_semver := std\n DEPS_uuid := std serialize rand\n DEPS_sync := std"}, {"sha": "f49bffe06d3930cc07f1aec9c87732b91f00771b", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 34, "deletions": 28, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/25c54226c3e7dd6f59cf2e92238a4d79d8b0128d/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25c54226c3e7dd6f59cf2e92238a4d79d8b0128d/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=25c54226c3e7dd6f59cf2e92238a4d79d8b0128d", "patch": "@@ -14,6 +14,10 @@\n //! once, once the arena itself is destroyed. They do not support deallocation\n //! of individual objects while the arena itself is still alive. The benefit\n //! of an arena is very fast allocation; just a pointer bump.\n+//!\n+//! This crate has two arenas implemented: TypedArena, which is a simpler\n+//! arena but can only hold objects of a single type, and Arena, which is a\n+//! more complex, slower Arena which can hold objects of any type.\n \n #![crate_id = \"arena#0.11.0-pre\"]\n #![crate_type = \"rlib\"]\n@@ -56,41 +60,42 @@ impl Chunk {\n     }\n }\n \n-// Arenas are used to quickly allocate objects that share a\n-// lifetime. The arena uses ~[u8] vectors as a backing store to\n-// allocate objects from. For each allocated object, the arena stores\n-// a pointer to the type descriptor followed by the\n-// object. (Potentially with alignment padding after each of them.)\n-// When the arena is destroyed, it iterates through all of its chunks,\n-// and uses the tydesc information to trace through the objects,\n-// calling the destructors on them.\n-// One subtle point that needs to be addressed is how to handle\n-// failures while running the user provided initializer function. It\n-// is important to not run the destructor on uninitialized objects, but\n-// how to detect them is somewhat subtle. Since alloc() can be invoked\n-// recursively, it is not sufficient to simply exclude the most recent\n-// object. To solve this without requiring extra space, we use the low\n-// order bit of the tydesc pointer to encode whether the object it\n-// describes has been fully initialized.\n-\n-// As an optimization, objects with destructors are stored in\n-// different chunks than objects without destructors. This reduces\n-// overhead when initializing plain-old-data and means we don't need\n-// to waste time running the destructors of POD.\n+/// A slower reflection-based arena that can allocate objects of any type.\n+///\n+/// This arena uses Vec<u8> as a backing store to allocate objects from.  For\n+/// each allocated object, the arena stores a pointer to the type descriptor\n+/// followed by the object. (Potentially with alignment padding after each\n+/// element.) When the arena is destroyed, it iterates through all of its\n+/// chunks, and uses the tydesc information to trace through the objects,\n+/// calling the destructors on them.  One subtle point that needs to be\n+/// addressed is how to handle failures while running the user provided\n+/// initializer function. It is important to not run the destructor on\n+/// uninitialized objects, but how to detect them is somewhat subtle. Since\n+/// alloc() can be invoked recursively, it is not sufficient to simply exclude\n+/// the most recent object. To solve this without requiring extra space, we\n+/// use the low order bit of the tydesc pointer to encode whether the object\n+/// it describes has been fully initialized.\n+///\n+/// As an optimization, objects with destructors are stored in\n+/// different chunks than objects without destructors. This reduces\n+/// overhead when initializing plain-old-data and means we don't need\n+/// to waste time running the destructors of POD.\n pub struct Arena {\n     // The head is separated out from the list as a unbenchmarked\n-    // microoptimization, to avoid needing to case on the list to\n-    // access the head.\n+    // microoptimization, to avoid needing to case on the list to access the\n+    // head.\n     head: Chunk,\n     copy_head: Chunk,\n     chunks: RefCell<Vec<Chunk>>,\n }\n \n impl Arena {\n+    /// Allocate a new Arena with 32 bytes preallocated.\n     pub fn new() -> Arena {\n         Arena::new_with_size(32u)\n     }\n \n+    /// Allocate a new Arena with `initial_size` bytes preallocated.\n     pub fn new_with_size(initial_size: uint) -> Arena {\n         Arena {\n             head: chunk(initial_size, false),\n@@ -265,7 +270,8 @@ impl Arena {\n         }\n     }\n \n-    // The external interface\n+    /// Allocate a new item in the arena, using `op` to initialize the value\n+    /// and returning a reference to it.\n     #[inline]\n     pub fn alloc<'a, T>(&'a self, op: || -> T) -> &'a T {\n         unsafe {\n@@ -313,7 +319,7 @@ fn test_arena_destructors_fail() {\n     });\n }\n \n-/// An arena that can hold objects of only one type.\n+/// A faster arena that can hold objects of only one type.\n ///\n /// Safety note: Modifying objects in the arena that have already had their\n /// `drop` destructors run can cause leaks, because the destructor will not\n@@ -405,13 +411,13 @@ impl<T> TypedArenaChunk<T> {\n }\n \n impl<T> TypedArena<T> {\n-    /// Creates a new arena with preallocated space for 8 objects.\n+    /// Creates a new TypedArena with preallocated space for 8 objects.\n     #[inline]\n     pub fn new() -> TypedArena<T> {\n         TypedArena::with_capacity(8)\n     }\n \n-    /// Creates a new arena with preallocated space for the given number of\n+    /// Creates a new TypedArena with preallocated space for the given number of\n     /// objects.\n     #[inline]\n     pub fn with_capacity(capacity: uint) -> TypedArena<T> {\n@@ -423,7 +429,7 @@ impl<T> TypedArena<T> {\n         }\n     }\n \n-    /// Allocates an object into this arena.\n+    /// Allocates an object in the TypedArena, returning a reference to it.\n     #[inline]\n     pub fn alloc<'a>(&'a self, object: T) -> &'a T {\n         unsafe {"}, {"sha": "03050794d212ce21400c88e165da7a3084f6ca3c", "filename": "src/libflate/lib.rs", "status": "modified", "additions": 26, "deletions": 20, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/25c54226c3e7dd6f59cf2e92238a4d79d8b0128d/src%2Flibflate%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25c54226c3e7dd6f59cf2e92238a4d79d8b0128d/src%2Flibflate%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibflate%2Flib.rs?ref=25c54226c3e7dd6f59cf2e92238a4d79d8b0128d", "patch": "@@ -10,7 +10,11 @@\n \n /*!\n \n-Simple compression\n+Simple [DEFLATE][def]-based compression. This is a wrapper around the\n+[`miniz`][mz] library, which is a one-file pure-C implementation of zlib.\n+\n+[def]: https://en.wikipedia.org/wiki/DEFLATE\n+[mz]: https://code.google.com/p/miniz/\n \n */\n \n@@ -31,23 +35,21 @@ extern crate libc;\n use std::c_vec::CVec;\n use libc::{c_void, size_t, c_int};\n \n-\n-pub mod rustrt {\n-    use libc::{c_void, size_t, c_int};\n-    #[link(name = \"miniz\", kind = \"static\")]\n-    extern {\n-        pub fn tdefl_compress_mem_to_heap(psrc_buf: *c_void,\n-                                          src_buf_len: size_t,\n-                                          pout_len: *mut size_t,\n-                                          flags: c_int)\n-                                          -> *mut c_void;\n-\n-        pub fn tinfl_decompress_mem_to_heap(psrc_buf: *c_void,\n-                                            src_buf_len: size_t,\n-                                            pout_len: *mut size_t,\n-                                            flags: c_int)\n-                                            -> *mut c_void;\n-    }\n+#[link(name = \"miniz\", kind = \"static\")]\n+extern {\n+    /// Raw miniz compression function.\n+    fn tdefl_compress_mem_to_heap(psrc_buf: *c_void,\n+                                      src_buf_len: size_t,\n+                                      pout_len: *mut size_t,\n+                                      flags: c_int)\n+                                      -> *mut c_void;\n+\n+    /// Raw miniz decompression function.\n+    fn tinfl_decompress_mem_to_heap(psrc_buf: *c_void,\n+                                        src_buf_len: size_t,\n+                                        pout_len: *mut size_t,\n+                                        flags: c_int)\n+                                        -> *mut c_void;\n }\n \n static LZ_NORM : c_int = 0x80;  // LZ with 128 probes, \"normal\"\n@@ -57,7 +59,7 @@ static TDEFL_WRITE_ZLIB_HEADER : c_int = 0x01000; // write zlib header and adler\n fn deflate_bytes_internal(bytes: &[u8], flags: c_int) -> Option<CVec<u8>> {\n     unsafe {\n         let mut outsz : size_t = 0;\n-        let res = rustrt::tdefl_compress_mem_to_heap(bytes.as_ptr() as *c_void,\n+        let res = tdefl_compress_mem_to_heap(bytes.as_ptr() as *c_void,\n                                                      bytes.len() as size_t,\n                                                      &mut outsz,\n                                                      flags);\n@@ -69,18 +71,20 @@ fn deflate_bytes_internal(bytes: &[u8], flags: c_int) -> Option<CVec<u8>> {\n     }\n }\n \n+/// Compress a buffer, without writing any sort of header on the output.\n pub fn deflate_bytes(bytes: &[u8]) -> Option<CVec<u8>> {\n     deflate_bytes_internal(bytes, LZ_NORM)\n }\n \n+/// Compress a buffer, using a header that zlib can understand.\n pub fn deflate_bytes_zlib(bytes: &[u8]) -> Option<CVec<u8>> {\n     deflate_bytes_internal(bytes, LZ_NORM | TDEFL_WRITE_ZLIB_HEADER)\n }\n \n fn inflate_bytes_internal(bytes: &[u8], flags: c_int) -> Option<CVec<u8>> {\n     unsafe {\n         let mut outsz : size_t = 0;\n-        let res = rustrt::tinfl_decompress_mem_to_heap(bytes.as_ptr() as *c_void,\n+        let res = tinfl_decompress_mem_to_heap(bytes.as_ptr() as *c_void,\n                                                        bytes.len() as size_t,\n                                                        &mut outsz,\n                                                        flags);\n@@ -92,10 +96,12 @@ fn inflate_bytes_internal(bytes: &[u8], flags: c_int) -> Option<CVec<u8>> {\n     }\n }\n \n+/// Decompress a buffer, without parsing any sort of header on the input.\n pub fn inflate_bytes(bytes: &[u8]) -> Option<CVec<u8>> {\n     inflate_bytes_internal(bytes, 0)\n }\n \n+/// Decompress a buffer that starts with a zlib header.\n pub fn inflate_bytes_zlib(bytes: &[u8]) -> Option<CVec<u8>> {\n     inflate_bytes_internal(bytes, TINFL_FLAG_PARSE_ZLIB_HEADER)\n }"}, {"sha": "85967d4d942be624d804a0325abe6629be16860a", "filename": "src/libnum/lib.rs", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/25c54226c3e7dd6f59cf2e92238a4d79d8b0128d/src%2Flibnum%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25c54226c3e7dd6f59cf2e92238a4d79d8b0128d/src%2Flibnum%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnum%2Flib.rs?ref=25c54226c3e7dd6f59cf2e92238a4d79d8b0128d", "patch": "@@ -8,6 +8,40 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+//! Simple numerics.\n+//!\n+//! This crate contains arbitrary-sized integer, rational, and complex types.\n+//!\n+//! ## Example\n+//!\n+//! This example uses the BigRational type and [Newton's method][newt] to\n+//! approximate a square root to arbitrary precision:\n+//!\n+//! ```\n+//! extern crate num;\n+//!\n+//! use num::bigint::BigInt;\n+//! use num::rational::{Ratio, BigRational};\n+//!\n+//! fn approx_sqrt(number: u64, iterations: uint) -> BigRational {\n+//!     let start: Ratio<BigInt> = Ratio::from_integer(FromPrimitive::from_u64(number).unwrap());\n+//!     let mut approx = start.clone();\n+//!\n+//!     for _ in range(0, iterations) {\n+//!         approx = (approx + (start / approx)) /\n+//!             Ratio::from_integer(FromPrimitive::from_u64(2).unwrap());\n+//!     }\n+//!\n+//!     approx\n+//! }\n+//!\n+//! fn main() {\n+//!     println!(\"{}\", approx_sqrt(10, 4)); // prints 4057691201/1283082416\n+//! }\n+//! ```\n+//!\n+//! [newt]: https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method\n+\n #![feature(macro_rules)]\n \n #![crate_id = \"num#0.11.0-pre\"]"}, {"sha": "1a07393f9fc80f3fce28a0ee88615ed1af4c1e5e", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/25c54226c3e7dd6f59cf2e92238a4d79d8b0128d/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25c54226c3e7dd6f59cf2e92238a4d79d8b0128d/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=25c54226c3e7dd6f59cf2e92238a4d79d8b0128d", "patch": "@@ -259,7 +259,7 @@ pub struct EmitterWriter {\n }\n \n enum Destination {\n-    Terminal(term::Terminal<io::stdio::StdWriter>),\n+    Terminal(Box<term::Terminal<Box<Writer:Send>>:Send>),\n     Raw(Box<Writer:Send>),\n }\n \n@@ -274,9 +274,9 @@ impl EmitterWriter {\n         };\n \n         if use_color {\n-            let dst = match term::Terminal::new(stderr.unwrap()) {\n-                Ok(t) => Terminal(t),\n-                Err(..) => Raw(box io::stderr()),\n+            let dst = match term::stderr() {\n+                Some(t) => Terminal(t),\n+                None    => Raw(box stderr),\n             };\n             EmitterWriter { dst: dst }\n         } else {"}, {"sha": "e6e8a1d4dc3843d836b1554c5b7a6c933af927d0", "filename": "src/libterm/lib.rs", "status": "modified", "additions": 107, "deletions": 179, "changes": 286, "blob_url": "https://github.com/rust-lang/rust/blob/25c54226c3e7dd6f59cf2e92238a4d79d8b0128d/src%2Flibterm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25c54226c3e7dd6f59cf2e92238a4d79d8b0128d/src%2Flibterm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Flib.rs?ref=25c54226c3e7dd6f59cf2e92238a4d79d8b0128d", "patch": "@@ -8,7 +8,32 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Simple ANSI color library\n+//! Terminal formatting library.\n+//!\n+//! This crate provides the `Terminal` trait, which abstracts over an [ANSI\n+//! Termina][ansi] to provide color printing, among other things. There are two implementations,\n+//! the `TerminfoTerminal`, which uses control characters from a\n+//! [terminfo][ti] database, and `WinConsole`, which uses the [Win32 Console\n+//! API][win].\n+//!\n+//! ## Example\n+//!\n+//! ```rust\n+//! extern crate term;\n+//!\n+//! fn main() {\n+//!     let mut t = term::stdout().unwrap();\n+//!     t.fg(term::color::GREEN).unwrap();\n+//!     println!(\"hello, \");\n+//!     t.fg(term::color::RED).unwrap();\n+//!     println!(\"world!\");\n+//!     t.reset().unwrap();\n+//! }\n+//! ```\n+//!\n+//! [ansi]: https://en.wikipedia.org/wiki/ANSI_escape_code\n+//! [win]: http://msdn.microsoft.com/en-us/library/windows/desktop/ms682010%28v=vs.85%29.aspx\n+//! [ti]: https://en.wikipedia.org/wiki/Terminfo\n \n #![crate_id = \"term#0.11.0-pre\"]\n #![comment = \"Simple ANSI color library\"]\n@@ -19,22 +44,76 @@\n        html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n        html_root_url = \"http://static.rust-lang.org/doc/master\")]\n \n-#![feature(macro_rules)]\n+#![feature(macro_rules, phase)]\n \n #![deny(missing_doc)]\n \n+#[phase(syntax, link)] extern crate log;\n extern crate collections;\n \n-use std::io;\n-use std::os;\n-use terminfo::TermInfo;\n-use terminfo::searcher::open;\n-use terminfo::parser::compiled::{parse, msys_terminfo};\n-use terminfo::parm::{expand, Number, Variables};\n+pub use terminfo::TerminfoTerminal;\n+#[cfg(windows)]\n+pub use win::WinConsole;\n+\n+use std::io::IoResult;\n \n pub mod terminfo;\n \n-// FIXME (#2807): Windows support.\n+#[cfg(windows)]\n+mod win;\n+\n+#[cfg(not(windows))]\n+/// Return a Terminal wrapping stdout, or None if a terminal couldn't be\n+/// opened.\n+pub fn stdout() -> Option<Box<Terminal<Box<Writer:Send>>:Send>> {\n+    let ti: Option<TerminfoTerminal<Box<Writer:Send>>>\n+        = Terminal::new(box std::io::stdout() as Box<Writer:Send>);\n+    ti.map(|t| box t as Box<Terminal<Box<Writer:Send>:Send>:Send>)\n+}\n+\n+#[cfg(windows)]\n+/// Return a Terminal wrapping stdout, or None if a terminal couldn't be\n+/// opened.\n+pub fn stdout() -> Option<Box<Terminal<Box<Writer:Send>:Send>:Send>> {\n+    let ti: Option<TerminfoTerminal<Box<Writer:Send>>>\n+        = Terminal::new(box std::io::stdout() as Box<Writer:Send>);\n+\n+    match ti {\n+        Some(t) => Some(box t as Box<Terminal<Box<Writer:Send>:Send>:Send>),\n+        None => {\n+            let wc: Option<WinConsole<Box<Writer:Send>>>\n+                = Terminal::new(box std::io::stdout() as Box<Writer:Send>);\n+            wc.map(|w| box w as Box<Terminal<Box<Writer:Send>:Send>:Send>)\n+        }\n+    }\n+}\n+\n+#[cfg(not(windows))]\n+/// Return a Terminal wrapping stderr, or None if a terminal couldn't be\n+/// opened.\n+pub fn stderr() -> Option<Box<Terminal<Box<Writer:Send>:Send>:Send>:Send> {\n+    let ti: Option<TerminfoTerminal<Box<Writer:Send>>>\n+        = Terminal::new(box std::io::stderr() as Box<Writer:Send>);\n+    ti.map(|t| box t as Box<Terminal<Box<Writer:Send>:Send>:Send>)\n+}\n+\n+#[cfg(windows)]\n+/// Return a Terminal wrapping stderr, or None if a terminal couldn't be\n+/// opened.\n+pub fn stderr() -> Option<Box<Terminal<Box<Writer:Send>:Send>:Send>> {\n+    let ti: Option<TerminfoTerminal<Box<Writer:Send>>>\n+        = Terminal::new(box std::io::stderr() as Box<Writer:Send>);\n+\n+    match ti {\n+        Some(t) => Some(box t as Box<Terminal<Box<Writer:Send>:Send>:Send>),\n+        None => {\n+            let wc: Option<WinConsole<Box<Writer:Send>>>\n+                = Terminal::new(box std::io::stderr() as Box<Writer:Send>);\n+            wc.map(|w| box w as Box<Terminal<Box<Writer:Send>:Send>:Send>)\n+        }\n+    }\n+}\n+\n \n /// Terminal color definitions\n pub mod color {\n@@ -91,200 +170,49 @@ pub mod attr {\n     }\n }\n \n-fn cap_for_attr(attr: attr::Attr) -> &'static str {\n-    match attr {\n-        attr::Bold               => \"bold\",\n-        attr::Dim                => \"dim\",\n-        attr::Italic(true)       => \"sitm\",\n-        attr::Italic(false)      => \"ritm\",\n-        attr::Underline(true)    => \"smul\",\n-        attr::Underline(false)   => \"rmul\",\n-        attr::Blink              => \"blink\",\n-        attr::Standout(true)     => \"smso\",\n-        attr::Standout(false)    => \"rmso\",\n-        attr::Reverse            => \"rev\",\n-        attr::Secure             => \"invis\",\n-        attr::ForegroundColor(_) => \"setaf\",\n-        attr::BackgroundColor(_) => \"setab\"\n-    }\n-}\n-\n-/// A Terminal that knows how many colors it supports, with a reference to its\n-/// parsed TermInfo database record.\n-pub struct Terminal<T> {\n-    num_colors: u16,\n-    out: T,\n-    ti: Box<TermInfo>,\n-}\n-\n-impl<T: Writer> Terminal<T> {\n-    /// Returns a wrapped output stream (`Terminal<T>`) as a `Result`.\n-    ///\n-    /// Returns `Err()` if the TERM environment variable is undefined.\n-    /// TERM should be set to something like `xterm-color` or `screen-256color`.\n-    ///\n-    /// Returns `Err()` on failure to open the terminfo database correctly.\n-    /// Also, in the event that the individual terminfo database entry can not\n-    /// be parsed.\n-    pub fn new(out: T) -> Result<Terminal<T>, StrBuf> {\n-        let term = match os::getenv(\"TERM\") {\n-            Some(t) => t,\n-            None => {\n-                return Err(\"TERM environment variable undefined\".to_strbuf())\n-            }\n-        };\n-\n-        let mut file = match open(term) {\n-            Ok(file) => file,\n-            Err(err) => {\n-                if \"cygwin\" == term { // msys terminal\n-                    return Ok(Terminal {\n-                        out: out,\n-                        ti: msys_terminfo(),\n-                        num_colors: 8\n-                    });\n-                }\n-                return Err(err);\n-            }\n-        };\n+/// A terminal with similar capabilities to an ANSI Terminal\n+/// (foreground/background colors etc).\n+pub trait Terminal<T: Writer>: Writer {\n+    /// Returns `None` whenever the terminal cannot be created for some\n+    /// reason.\n+    fn new(out: T) -> Option<Self>;\n \n-        let inf = try!(parse(&mut file, false));\n-\n-        let nc = if inf.strings.find_equiv(&(\"setaf\")).is_some()\n-                 && inf.strings.find_equiv(&(\"setab\")).is_some() {\n-                     inf.numbers.find_equiv(&(\"colors\")).map_or(0, |&n| n)\n-                 } else { 0 };\n-\n-        return Ok(Terminal {out: out, ti: inf, num_colors: nc});\n-    }\n     /// Sets the foreground color to the given color.\n     ///\n     /// If the color is a bright color, but the terminal only supports 8 colors,\n     /// the corresponding normal color will be used instead.\n     ///\n     /// Returns `Ok(true)` if the color was set, `Ok(false)` otherwise, and `Err(e)`\n     /// if there was an I/O error.\n-    pub fn fg(&mut self, color: color::Color) -> io::IoResult<bool> {\n-        let color = self.dim_if_necessary(color);\n-        if self.num_colors > color {\n-            let s = expand(self.ti\n-                               .strings\n-                               .find_equiv(&(\"setaf\"))\n-                               .unwrap()\n-                               .as_slice(),\n-                           [Number(color as int)], &mut Variables::new());\n-            if s.is_ok() {\n-                try!(self.out.write(s.unwrap().as_slice()));\n-                return Ok(true)\n-            }\n-        }\n-        Ok(false)\n-    }\n+    fn fg(&mut self, color: color::Color) -> IoResult<bool>;\n+\n     /// Sets the background color to the given color.\n     ///\n     /// If the color is a bright color, but the terminal only supports 8 colors,\n     /// the corresponding normal color will be used instead.\n     ///\n     /// Returns `Ok(true)` if the color was set, `Ok(false)` otherwise, and `Err(e)`\n     /// if there was an I/O error.\n-    pub fn bg(&mut self, color: color::Color) -> io::IoResult<bool> {\n-        let color = self.dim_if_necessary(color);\n-        if self.num_colors > color {\n-            let s = expand(self.ti\n-                               .strings\n-                               .find_equiv(&(\"setab\"))\n-                               .unwrap()\n-                               .as_slice(),\n-                           [Number(color as int)], &mut Variables::new());\n-            if s.is_ok() {\n-                try!(self.out.write(s.unwrap().as_slice()));\n-                return Ok(true)\n-            }\n-        }\n-        Ok(false)\n-    }\n+    fn bg(&mut self, color: color::Color) -> IoResult<bool>;\n \n-    /// Sets the given terminal attribute, if supported.\n-    /// Returns `Ok(true)` if the attribute was supported, `Ok(false)` otherwise,\n-    /// and `Err(e)` if there was an I/O error.\n-    pub fn attr(&mut self, attr: attr::Attr) -> io::IoResult<bool> {\n-        match attr {\n-            attr::ForegroundColor(c) => self.fg(c),\n-            attr::BackgroundColor(c) => self.bg(c),\n-            _ => {\n-                let cap = cap_for_attr(attr);\n-                let parm = self.ti.strings.find_equiv(&cap);\n-                if parm.is_some() {\n-                    let s = expand(parm.unwrap().as_slice(),\n-                                   [],\n-                                   &mut Variables::new());\n-                    if s.is_ok() {\n-                        try!(self.out.write(s.unwrap().as_slice()));\n-                        return Ok(true)\n-                    }\n-                }\n-                Ok(false)\n-            }\n-        }\n-    }\n+    /// Sets the given terminal attribute, if supported.  Returns `Ok(true)`\n+    /// if the attribute was supported, `Ok(false)` otherwise, and `Err(e)` if\n+    /// there was an I/O error.\n+    fn attr(&mut self, attr: attr::Attr) -> IoResult<bool>;\n \n     /// Returns whether the given terminal attribute is supported.\n-    pub fn supports_attr(&self, attr: attr::Attr) -> bool {\n-        match attr {\n-            attr::ForegroundColor(_) | attr::BackgroundColor(_) => {\n-                self.num_colors > 0\n-            }\n-            _ => {\n-                let cap = cap_for_attr(attr);\n-                self.ti.strings.find_equiv(&cap).is_some()\n-            }\n-        }\n-    }\n+    fn supports_attr(&self, attr: attr::Attr) -> bool;\n \n     /// Resets all terminal attributes and color to the default.\n     /// Returns `Ok()`.\n-    pub fn reset(&mut self) -> io::IoResult<()> {\n-        let mut cap = self.ti.strings.find_equiv(&(\"sgr0\"));\n-        if cap.is_none() {\n-            // are there any terminals that have color/attrs and not sgr0?\n-            // Try falling back to sgr, then op\n-            cap = self.ti.strings.find_equiv(&(\"sgr\"));\n-            if cap.is_none() {\n-                cap = self.ti.strings.find_equiv(&(\"op\"));\n-            }\n-        }\n-        let s = cap.map_or(Err(\"can't find terminfo capability \\\n-                                `sgr0`\".to_strbuf()), |op| {\n-            expand(op.as_slice(), [], &mut Variables::new())\n-        });\n-        if s.is_ok() {\n-            return self.out.write(s.unwrap().as_slice())\n-        }\n-        Ok(())\n-    }\n-\n-    fn dim_if_necessary(&self, color: color::Color) -> color::Color {\n-        if color >= self.num_colors && color >= 8 && color < 16 {\n-            color-8\n-        } else { color }\n-    }\n+    fn reset(&mut self) -> IoResult<()>;\n \n-    /// Returns the contained stream\n-    pub fn unwrap(self) -> T { self.out }\n+    /// Returns the contained stream, destroying the `Terminal`\n+    fn unwrap(self) -> T;\n \n     /// Gets an immutable reference to the stream inside\n-    pub fn get_ref<'a>(&'a self) -> &'a T { &self.out }\n+    fn get_ref<'a>(&'a self) -> &'a T;\n \n     /// Gets a mutable reference to the stream inside\n-    pub fn get_mut<'a>(&'a mut self) -> &'a mut T { &mut self.out }\n-}\n-\n-impl<T: Writer> Writer for Terminal<T> {\n-    fn write(&mut self, buf: &[u8]) -> io::IoResult<()> {\n-        self.out.write(buf)\n-    }\n-\n-    fn flush(&mut self) -> io::IoResult<()> {\n-        self.out.flush()\n-    }\n+    fn get_mut<'a>(&'a mut self) -> &'a mut T;\n }"}, {"sha": "36e5c1cf763a6459567402a26135b4d948a0d360", "filename": "src/libterm/terminfo/mod.rs", "status": "modified", "additions": 187, "deletions": 0, "changes": 187, "blob_url": "https://github.com/rust-lang/rust/blob/25c54226c3e7dd6f59cf2e92238a4d79d8b0128d/src%2Flibterm%2Fterminfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25c54226c3e7dd6f59cf2e92238a4d79d8b0128d/src%2Flibterm%2Fterminfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fmod.rs?ref=25c54226c3e7dd6f59cf2e92238a4d79d8b0128d", "patch": "@@ -11,8 +11,19 @@\n //! Terminfo database interface.\n \n use collections::HashMap;\n+use std::io::IoResult;\n+use std::os;\n+\n+use attr;\n+use color;\n+use Terminal;\n+use self::searcher::open;\n+use self::parser::compiled::{parse, msys_terminfo};\n+use self::parm::{expand, Number, Variables};\n+\n \n /// A parsed terminfo database entry.\n+#[deriving(Show)]\n pub struct TermInfo {\n     /// Names for the terminal\n     pub names: Vec<StrBuf> ,\n@@ -32,3 +43,179 @@ pub mod parser {\n     pub mod compiled;\n }\n pub mod parm;\n+\n+\n+fn cap_for_attr(attr: attr::Attr) -> &'static str {\n+    match attr {\n+        attr::Bold               => \"bold\",\n+        attr::Dim                => \"dim\",\n+        attr::Italic(true)       => \"sitm\",\n+        attr::Italic(false)      => \"ritm\",\n+        attr::Underline(true)    => \"smul\",\n+        attr::Underline(false)   => \"rmul\",\n+        attr::Blink              => \"blink\",\n+        attr::Standout(true)     => \"smso\",\n+        attr::Standout(false)    => \"rmso\",\n+        attr::Reverse            => \"rev\",\n+        attr::Secure             => \"invis\",\n+        attr::ForegroundColor(_) => \"setaf\",\n+        attr::BackgroundColor(_) => \"setab\"\n+    }\n+}\n+\n+/// A Terminal that knows how many colors it supports, with a reference to its\n+/// parsed Terminfo database record.\n+pub struct TerminfoTerminal<T> {\n+    num_colors: u16,\n+    out: T,\n+    ti: Box<TermInfo>\n+}\n+\n+impl<T: Writer> Terminal<T> for TerminfoTerminal<T> {\n+    fn new(out: T) -> Option<TerminfoTerminal<T>> {\n+        let term = match os::getenv(\"TERM\") {\n+            Some(t) => t,\n+            None => {\n+                debug!(\"TERM environment variable not defined\");\n+                return None;\n+            }\n+        };\n+\n+        let entry = open(term);\n+        if entry.is_err() {\n+            if os::getenv(\"MSYSCON\").map_or(false, |s| \"mintty.exe\" == s) {\n+                // msys terminal\n+                return Some(TerminfoTerminal {out: out, ti: msys_terminfo(), num_colors: 8});\n+            }\n+            debug!(\"error finding terminfo entry: {}\", entry.err().unwrap());\n+            return None;\n+        }\n+\n+        let mut file = entry.unwrap();\n+        let ti = parse(&mut file, false);\n+        if ti.is_err() {\n+            debug!(\"error parsing terminfo entry: {}\", ti.unwrap_err());\n+            return None;\n+        }\n+\n+        let inf = ti.unwrap();\n+        let nc = if inf.strings.find_equiv(&(\"setaf\")).is_some()\n+                 && inf.strings.find_equiv(&(\"setab\")).is_some() {\n+                     inf.numbers.find_equiv(&(\"colors\")).map_or(0, |&n| n)\n+                 } else { 0 };\n+\n+        return Some(TerminfoTerminal {out: out, ti: inf, num_colors: nc});\n+    }\n+\n+    fn fg(&mut self, color: color::Color) -> IoResult<bool> {\n+        let color = self.dim_if_necessary(color);\n+        if self.num_colors > color {\n+            let s = expand(self.ti\n+                               .strings\n+                               .find_equiv(&(\"setaf\"))\n+                               .unwrap()\n+                               .as_slice(),\n+                           [Number(color as int)], &mut Variables::new());\n+            if s.is_ok() {\n+                try!(self.out.write(s.unwrap().as_slice()));\n+                return Ok(true)\n+            }\n+        }\n+        Ok(false)\n+    }\n+\n+    fn bg(&mut self, color: color::Color) -> IoResult<bool> {\n+        let color = self.dim_if_necessary(color);\n+        if self.num_colors > color {\n+            let s = expand(self.ti\n+                               .strings\n+                               .find_equiv(&(\"setab\"))\n+                               .unwrap()\n+                               .as_slice(),\n+                           [Number(color as int)], &mut Variables::new());\n+            if s.is_ok() {\n+                try!(self.out.write(s.unwrap().as_slice()));\n+                return Ok(true)\n+            }\n+        }\n+        Ok(false)\n+    }\n+\n+    fn attr(&mut self, attr: attr::Attr) -> IoResult<bool> {\n+        match attr {\n+            attr::ForegroundColor(c) => self.fg(c),\n+            attr::BackgroundColor(c) => self.bg(c),\n+            _ => {\n+                let cap = cap_for_attr(attr);\n+                let parm = self.ti.strings.find_equiv(&cap);\n+                if parm.is_some() {\n+                    let s = expand(parm.unwrap().as_slice(),\n+                                   [],\n+                                   &mut Variables::new());\n+                    if s.is_ok() {\n+                        try!(self.out.write(s.unwrap().as_slice()));\n+                        return Ok(true)\n+                    }\n+                }\n+                Ok(false)\n+            }\n+        }\n+    }\n+\n+    fn supports_attr(&self, attr: attr::Attr) -> bool {\n+        match attr {\n+            attr::ForegroundColor(_) | attr::BackgroundColor(_) => {\n+                self.num_colors > 0\n+            }\n+            _ => {\n+                let cap = cap_for_attr(attr);\n+                self.ti.strings.find_equiv(&cap).is_some()\n+            }\n+        }\n+    }\n+\n+    fn reset(&mut self) -> IoResult<()> {\n+        let mut cap = self.ti.strings.find_equiv(&(\"sgr0\"));\n+        if cap.is_none() {\n+            // are there any terminals that have color/attrs and not sgr0?\n+            // Try falling back to sgr, then op\n+            cap = self.ti.strings.find_equiv(&(\"sgr\"));\n+            if cap.is_none() {\n+                cap = self.ti.strings.find_equiv(&(\"op\"));\n+            }\n+        }\n+        let s = cap.map_or(Err(\"can't find terminfo capability `sgr0`\".to_strbuf()), |op| {\n+            expand(op.as_slice(), [], &mut Variables::new())\n+        });\n+        if s.is_ok() {\n+            return self.out.write(s.unwrap().as_slice())\n+        }\n+        Ok(())\n+    }\n+\n+    fn unwrap(self) -> T { self.out }\n+\n+    fn get_ref<'a>(&'a self) -> &'a T { &self.out }\n+\n+    fn get_mut<'a>(&'a mut self) -> &'a mut T { &mut self.out }\n+}\n+\n+impl<T: Writer> TerminfoTerminal<T> {\n+    fn dim_if_necessary(&self, color: color::Color) -> color::Color {\n+        if color >= self.num_colors && color >= 8 && color < 16 {\n+            color-8\n+        } else { color }\n+    }\n+}\n+\n+\n+impl<T: Writer> Writer for TerminfoTerminal<T> {\n+    fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n+        self.out.write(buf)\n+    }\n+\n+    fn flush(&mut self) -> IoResult<()> {\n+        self.out.flush()\n+    }\n+}\n+"}, {"sha": "837ddf566ef45aabbc2b527f5a0daece7e5060ff", "filename": "src/libterm/win.rs", "status": "added", "additions": 148, "deletions": 0, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/25c54226c3e7dd6f59cf2e92238a4d79d8b0128d/src%2Flibterm%2Fwin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25c54226c3e7dd6f59cf2e92238a4d79d8b0128d/src%2Flibterm%2Fwin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fwin.rs?ref=25c54226c3e7dd6f59cf2e92238a4d79d8b0128d", "patch": "@@ -0,0 +1,148 @@\n+// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Windows console handling\n+\n+// FIXME (#13400): this is only a tiny fraction of the win32 console api\n+\n+extern crate libc;\n+\n+use std::io::IoResult;\n+\n+use attr;\n+use color;\n+use Terminal;\n+\n+/// A Terminal implementation which uses the Win32 Console API.\n+pub struct WinConsole<T> {\n+    buf: T,\n+    foreground: color::Color,\n+    background: color::Color,\n+}\n+\n+#[link(name = \"kernel32\")]\n+extern \"system\" {\n+    fn SetConsoleTextAttribute(handle: libc::HANDLE, attr: libc::WORD) -> libc::BOOL;\n+    fn GetStdHandle(which: libc::DWORD) -> libc::HANDLE;\n+}\n+\n+fn color_to_bits(color: color::Color) -> u16 {\n+    // magic numbers from mingw-w64's wincon.h\n+\n+    let bits = match color % 8 {\n+        color::BLACK   => 0,\n+        color::BLUE    => 0x1,\n+        color::GREEN   => 0x2,\n+        color::RED     => 0x4,\n+        color::YELLOW  => 0x2 | 0x4,\n+        color::MAGENTA => 0x1 | 0x4,\n+        color::CYAN    => 0x1 | 0x2,\n+        color::WHITE   => 0x1 | 0x2 | 0x4,\n+        _ => unreachable!()\n+    };\n+\n+    if color >= 8 {\n+        bits | 0x8\n+    } else {\n+        bits\n+    }\n+}\n+\n+impl<T: Writer> WinConsole<T> {\n+    fn apply(&mut self) {\n+        let _unused = self.buf.flush();\n+        let mut accum: libc::WORD = 0;\n+        accum |= color_to_bits(self.foreground);\n+        accum |= color_to_bits(self.background) << 4;\n+\n+        unsafe {\n+            // Magic -11 means stdout, from\n+            // http://msdn.microsoft.com/en-us/library/windows/desktop/ms683231%28v=vs.85%29.aspx\n+            //\n+            // You may be wondering, \"but what about stderr?\", and the answer\n+            // to that is that setting terminal attributes on the stdout\n+            // handle also sets them for stderr, since they go to the same\n+            // terminal! Admittedly, this is fragile, since stderr could be\n+            // redirected to a different console. This is good enough for\n+            // rustc though. See #13400.\n+            let out = GetStdHandle(-11);\n+            SetConsoleTextAttribute(out, accum);\n+        }\n+    }\n+}\n+\n+impl<T: Writer> Writer for WinConsole<T> {\n+    fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n+        self.buf.write(buf)\n+    }\n+\n+    fn flush(&mut self) -> IoResult<()> {\n+        self.buf.flush()\n+    }\n+}\n+\n+impl<T: Writer> Terminal<T> for WinConsole<T> {\n+    fn new(out: T) -> Option<WinConsole<T>> {\n+        Some(WinConsole { buf: out, foreground: color::WHITE, background: color::BLACK })\n+    }\n+\n+    fn fg(&mut self, color: color::Color) -> IoResult<bool> {\n+        self.foreground = color;\n+        self.apply();\n+\n+        Ok(true)\n+    }\n+\n+    fn bg(&mut self, color: color::Color) -> IoResult<bool> {\n+        self.background = color;\n+        self.apply();\n+\n+        Ok(true)\n+    }\n+\n+    fn attr(&mut self, attr: attr::Attr) -> IoResult<bool> {\n+        match attr {\n+            attr::ForegroundColor(f) => {\n+                self.foreground = f;\n+                self.apply();\n+                Ok(true)\n+            },\n+            attr::BackgroundColor(b) => {\n+                self.background = b;\n+                self.apply();\n+                Ok(true)\n+            },\n+            _ => Ok(false)\n+        }\n+    }\n+\n+    fn supports_attr(&self, attr: attr::Attr) -> bool {\n+        // it claims support for underscore and reverse video, but I can't get\n+        // it to do anything -cmr\n+        match attr {\n+            attr::ForegroundColor(_) | attr::BackgroundColor(_) => true,\n+            _ => false\n+        }\n+    }\n+\n+    fn reset(&mut self) -> IoResult<()> {\n+        self.foreground = color::WHITE;\n+        self.background = color::BLACK;\n+        self.apply();\n+\n+        Ok(())\n+    }\n+\n+    fn unwrap(self) -> T { self.buf }\n+\n+    fn get_ref<'a>(&'a self) -> &'a T { &self.buf }\n+\n+    fn get_mut<'a>(&'a mut self) -> &'a mut T { &mut self.buf }\n+}"}, {"sha": "39eee153184d75df7579cabeae357e6c69aea90d", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/25c54226c3e7dd6f59cf2e92238a4d79d8b0128d/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25c54226c3e7dd6f59cf2e92238a4d79d8b0128d/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=25c54226c3e7dd6f59cf2e92238a4d79d8b0128d", "patch": "@@ -447,7 +447,7 @@ pub enum TestResult {\n }\n \n enum OutputLocation<T> {\n-    Pretty(term::Terminal<T>),\n+    Pretty(Box<term::Terminal<Box<Writer:Send>>:Send>),\n     Raw(T),\n }\n \n@@ -472,10 +472,11 @@ impl<T: Writer> ConsoleTestState<T> {\n             Some(ref path) => Some(try!(File::create(path))),\n             None => None\n         };\n-        let out = match term::Terminal::new(io::stdio::stdout_raw()) {\n-            Err(_) => Raw(io::stdio::stdout_raw()),\n-            Ok(t) => Pretty(t)\n+        let out = match term::stdout() {\n+            None => Raw(io::stdio::stdout_raw()),\n+            Some(t) => Pretty(t)\n         };\n+\n         Ok(ConsoleTestState {\n             out: out,\n             log_out: log_out,"}, {"sha": "87a87641fc03b247587bcf64d6e4f030329cdd0b", "filename": "src/libtime/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/25c54226c3e7dd6f59cf2e92238a4d79d8b0128d/src%2Flibtime%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25c54226c3e7dd6f59cf2e92238a4d79d8b0128d/src%2Flibtime%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtime%2Flib.rs?ref=25c54226c3e7dd6f59cf2e92238a4d79d8b0128d", "patch": "@@ -8,7 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+//! Simple time handling.\n+\n #![crate_id = \"time#0.11.0-pre\"]\n+\n #![crate_type = \"rlib\"]\n #![crate_type = \"dylib\"]\n #![license = \"MIT/ASL2\"]"}, {"sha": "b7386a97b45167fa86e26710210b42d012579f1c", "filename": "src/libworkcache/lib.rs", "status": "modified", "additions": 66, "deletions": 68, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/25c54226c3e7dd6f59cf2e92238a4d79d8b0128d/src%2Flibworkcache%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25c54226c3e7dd6f59cf2e92238a4d79d8b0128d/src%2Flibworkcache%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibworkcache%2Flib.rs?ref=25c54226c3e7dd6f59cf2e92238a4d79d8b0128d", "patch": "@@ -8,6 +8,72 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+//! A simple function caching system.\n+//!\n+//! This is a loose clone of the [fbuild build system](https://github.com/felix-lang/fbuild),\n+//! made a touch more generic (not wired to special cases on files) and much\n+//! less metaprogram-y due to rust's comparative weakness there, relative to\n+//! python.\n+//!\n+//! It's based around _imperative builds_ that happen to have some function\n+//! calls cached. That is, it's _just_ a mechanism for describing cached\n+//! functions. This makes it much simpler and smaller than a \"build system\"\n+//! that produces an IR and evaluates it. The evaluation order is normal\n+//! function calls. Some of them just return really quickly.\n+//!\n+//! A cached function consumes and produces a set of _works_. A work has a\n+//! name, a kind (that determines how the value is to be checked for\n+//! freshness) and a value. Works must also be (de)serializable. Some\n+//! examples of works:\n+//!\n+//!    kind   name    value\n+//!   ------------------------\n+//!    cfg    os      linux\n+//!    file   foo.c   <sha1>\n+//!    url    foo.com <etag>\n+//!\n+//! Works are conceptually single units, but we store them most of the time\n+//! in maps of the form (type,name) => value. These are WorkMaps.\n+//!\n+//! A cached function divides the works it's interested in into inputs and\n+//! outputs, and subdivides those into declared (input) works and\n+//! discovered (input and output) works.\n+//!\n+//! A _declared_ input or is one that is given to the workcache before\n+//! any work actually happens, in the \"prep\" phase. Even when a function's\n+//! work-doing part (the \"exec\" phase) never gets called, it has declared\n+//! inputs, which can be checked for freshness (and potentially\n+//! used to determine that the function can be skipped).\n+//!\n+//! The workcache checks _all_ works for freshness, but uses the set of\n+//! discovered outputs from the _previous_ exec (which it will re-discover\n+//! and re-record each time the exec phase runs).\n+//!\n+//! Therefore the discovered works cached in the db might be a\n+//! mis-approximation of the current discoverable works, but this is ok for\n+//! the following reason: we assume that if an artifact A changed from\n+//! depending on B,C,D to depending on B,C,D,E, then A itself changed (as\n+//! part of the change-in-dependencies), so we will be ok.\n+//!\n+//! Each function has a single discriminated output work called its _result_.\n+//! This is only different from other works in that it is returned, by value,\n+//! from a call to the cacheable function; the other output works are used in\n+//! passing to invalidate dependencies elsewhere in the cache, but do not\n+//! otherwise escape from a function invocation. Most functions only have one\n+//! output work anyways.\n+//!\n+//! A database (the central store of a workcache) stores a mappings:\n+//!\n+//! (fn_name,{declared_input}) => ({discovered_input},\n+//!                                {discovered_output},result)\n+//!\n+//! (Note: fbuild, which workcache is based on, has the concept of a declared\n+//! output as separate from a discovered output. This distinction exists only\n+//! as an artifact of how fbuild works: via annotations on function types\n+//! and metaprogramming, with explicit dependency declaration as a fallback.\n+//! Workcache is more explicit about dependencies, and as such treats all\n+//! outputs the same, as discovered-during-the-last-run.)\n+\n #![crate_id = \"workcache#0.11.0-pre\"]\n #![crate_type = \"rlib\"]\n #![crate_type = \"dylib\"]\n@@ -33,74 +99,6 @@ use std::str;\n use std::io;\n use std::io::{File, MemWriter};\n \n-/**\n-*\n-* This is a loose clone of the [fbuild build system](https://github.com/felix-lang/fbuild),\n-* made a touch more generic (not wired to special cases on files) and much\n-* less metaprogram-y due to rust's comparative weakness there, relative to\n-* python.\n-*\n-* It's based around _imperative builds_ that happen to have some function\n-* calls cached. That is, it's _just_ a mechanism for describing cached\n-* functions. This makes it much simpler and smaller than a \"build system\"\n-* that produces an IR and evaluates it. The evaluation order is normal\n-* function calls. Some of them just return really quickly.\n-*\n-* A cached function consumes and produces a set of _works_. A work has a\n-* name, a kind (that determines how the value is to be checked for\n-* freshness) and a value. Works must also be (de)serializable. Some\n-* examples of works:\n-*\n-*    kind   name    value\n-*   ------------------------\n-*    cfg    os      linux\n-*    file   foo.c   <sha1>\n-*    url    foo.com <etag>\n-*\n-* Works are conceptually single units, but we store them most of the time\n-* in maps of the form (type,name) => value. These are WorkMaps.\n-*\n-* A cached function divides the works it's interested in into inputs and\n-* outputs, and subdivides those into declared (input) works and\n-* discovered (input and output) works.\n-*\n-* A _declared_ input or is one that is given to the workcache before\n-* any work actually happens, in the \"prep\" phase. Even when a function's\n-* work-doing part (the \"exec\" phase) never gets called, it has declared\n-* inputs, which can be checked for freshness (and potentially\n-* used to determine that the function can be skipped).\n-*\n-* The workcache checks _all_ works for freshness, but uses the set of\n-* discovered outputs from the _previous_ exec (which it will re-discover\n-* and re-record each time the exec phase runs).\n-*\n-* Therefore the discovered works cached in the db might be a\n-* mis-approximation of the current discoverable works, but this is ok for\n-* the following reason: we assume that if an artifact A changed from\n-* depending on B,C,D to depending on B,C,D,E, then A itself changed (as\n-* part of the change-in-dependencies), so we will be ok.\n-*\n-* Each function has a single discriminated output work called its _result_.\n-* This is only different from other works in that it is returned, by value,\n-* from a call to the cacheable function; the other output works are used in\n-* passing to invalidate dependencies elsewhere in the cache, but do not\n-* otherwise escape from a function invocation. Most functions only have one\n-* output work anyways.\n-*\n-* A database (the central store of a workcache) stores a mappings:\n-*\n-* (fn_name,{declared_input}) => ({discovered_input},\n-*                                {discovered_output},result)\n-*\n-* (Note: fbuild, which workcache is based on, has the concept of a declared\n-* output as separate from a discovered output. This distinction exists only\n-* as an artifact of how fbuild works: via annotations on function types\n-* and metaprogramming, with explicit dependency declaration as a fallback.\n-* Workcache is more explicit about dependencies, and as such treats all\n-* outputs the same, as discovered-during-the-last-run.)\n-*\n-*/\n-\n #[deriving(Clone, Eq, Encodable, Decodable, Ord, TotalOrd, TotalEq)]\n struct WorkKey {\n     kind: StrBuf,"}]}