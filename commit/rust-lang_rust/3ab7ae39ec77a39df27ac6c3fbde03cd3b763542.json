{"sha": "3ab7ae39ec77a39df27ac6c3fbde03cd3b763542", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNhYjdhZTM5ZWM3N2EzOWRmMjdhYzZjM2ZiZGUwM2NkM2I3NjM1NDI=", "commit": {"author": {"name": "Nathan West", "email": "Lucretiel@gmail.com", "date": "2020-05-20T03:26:49Z"}, "committer": {"name": "David Tolnay", "email": "dtolnay@gmail.com", "date": "2020-06-30T18:44:14Z"}, "message": "Bring net/parser.rs up to modern up to date with modern rust patterns\n\nMade the following changes throughout the IP address parser:\n- Replaced all uses of `is_some()` / `is_none()` with `?`.\n- \"Upgraded\" loops wherever possible; ie, replace `while` with `for`, etc.\n    - Removed all cases of manual index tracking / incrementing.\n- Renamed several single-character variables with more expressive names.\n- Replaced several manual control flow segments with equivalent adapters (such as `Option::filter`).\n- Removed `read_seq_3`; replaced with simple sequences of `?`.\n- Parser now reslices its state when consuming, rather than carrying a separate state and index variable.\n- `read_digit` now uses `char::to_digit`.\n- Removed unnecessary casts back and forth between u8 and u32\n- Added comments throughout, especially in the complex IPv6 parsing logic.\n- Added comprehensive local unit tests for the parser to validate these changes.", "tree": {"sha": "96b6bd843588e18b177378da94f1615d06960577", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/96b6bd843588e18b177378da94f1615d06960577"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3ab7ae39ec77a39df27ac6c3fbde03cd3b763542", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEERijF2Cz/ZdaBZKeK+boUO5X/bYIFAl77h/4ACgkQ+boUO5X/\nbYL+Cw/6A0vSKrjkEtDsnhyPYl3obcZZocnh+Yo8tMLeiMkDQ1w7/+n/xM5fiM2i\np/ePzg+IQmjhjRBBbgP5k/Wa7jm+V6JBZjxuQIeNm68KTOgYWH4gXJUr+MSnwhYu\nNIFqO4XX/+fp//7LPhrCqp5ShdKS5c2QmHiid6kty2/vDYnNGGtw4NIJpnN8ohbR\nIOXtrtScP7RMkNBN23axf/R0OLOC4CplMN1pEU2+euiOtsqIqOLZnlnFBufv5lZZ\nR7r3dkac1ywM6wL5c6hDeHw7oU8yel0Cr0TXYxaqx9+PLBBaKx8ZfLFrBAZzxFL9\nsFVLxh9lQ+IWd5eWOLNRsCztlUu4ZoSqRP1MPl6b9YRCHRuFAc7Q85mQ+N1Z9APU\nkYQLYZjH6nRdnJlSIP5PFr/O81i5MJmJcmCBlLVCxeJnPV09u1zjN86h6xinlYpt\nf3AYYZxTpKg7QHU2EnKs/P7nm3RCxaMmDoEaSqQ9KFsDvHhGMvi3vbT2NRvz4SyO\no/AfzzD15re5aXIfvw98CNHpJbjEgVsG4FJUQ/RgohE19rrRbId26SkhMEJNfybE\nXdng1F/yc86upcu4pPzdvrOJddNowDJ3L2tgIH7AteL4vlqRBMjttnJ/Bt9yxF7i\nrgcgovTwfoP9bactOfunOPhlie8lT/Pe1mI2XFlwFb0TSPZWU8k=\n=zAxh\n-----END PGP SIGNATURE-----", "payload": "tree 96b6bd843588e18b177378da94f1615d06960577\nparent 672b272077561ca7b5027a8aff9ea2957c7d4c21\nauthor Nathan West <Lucretiel@gmail.com> 1589945209 -0400\ncommitter David Tolnay <dtolnay@gmail.com> 1593542654 -0700\n\nBring net/parser.rs up to modern up to date with modern rust patterns\n\nMade the following changes throughout the IP address parser:\n- Replaced all uses of `is_some()` / `is_none()` with `?`.\n- \"Upgraded\" loops wherever possible; ie, replace `while` with `for`, etc.\n    - Removed all cases of manual index tracking / incrementing.\n- Renamed several single-character variables with more expressive names.\n- Replaced several manual control flow segments with equivalent adapters (such as `Option::filter`).\n- Removed `read_seq_3`; replaced with simple sequences of `?`.\n- Parser now reslices its state when consuming, rather than carrying a separate state and index variable.\n- `read_digit` now uses `char::to_digit`.\n- Removed unnecessary casts back and forth between u8 and u32\n- Added comments throughout, especially in the complex IPv6 parsing logic.\n- Added comprehensive local unit tests for the parser to validate these changes.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3ab7ae39ec77a39df27ac6c3fbde03cd3b763542", "html_url": "https://github.com/rust-lang/rust/commit/3ab7ae39ec77a39df27ac6c3fbde03cd3b763542", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3ab7ae39ec77a39df27ac6c3fbde03cd3b763542/comments", "author": {"login": "Lucretiel", "id": 1823405, "node_id": "MDQ6VXNlcjE4MjM0MDU=", "avatar_url": "https://avatars.githubusercontent.com/u/1823405?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Lucretiel", "html_url": "https://github.com/Lucretiel", "followers_url": "https://api.github.com/users/Lucretiel/followers", "following_url": "https://api.github.com/users/Lucretiel/following{/other_user}", "gists_url": "https://api.github.com/users/Lucretiel/gists{/gist_id}", "starred_url": "https://api.github.com/users/Lucretiel/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Lucretiel/subscriptions", "organizations_url": "https://api.github.com/users/Lucretiel/orgs", "repos_url": "https://api.github.com/users/Lucretiel/repos", "events_url": "https://api.github.com/users/Lucretiel/events{/privacy}", "received_events_url": "https://api.github.com/users/Lucretiel/received_events", "type": "User", "site_admin": false}, "committer": {"login": "dtolnay", "id": 1940490, "node_id": "MDQ6VXNlcjE5NDA0OTA=", "avatar_url": "https://avatars.githubusercontent.com/u/1940490?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dtolnay", "html_url": "https://github.com/dtolnay", "followers_url": "https://api.github.com/users/dtolnay/followers", "following_url": "https://api.github.com/users/dtolnay/following{/other_user}", "gists_url": "https://api.github.com/users/dtolnay/gists{/gist_id}", "starred_url": "https://api.github.com/users/dtolnay/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dtolnay/subscriptions", "organizations_url": "https://api.github.com/users/dtolnay/orgs", "repos_url": "https://api.github.com/users/dtolnay/repos", "events_url": "https://api.github.com/users/dtolnay/events{/privacy}", "received_events_url": "https://api.github.com/users/dtolnay/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "672b272077561ca7b5027a8aff9ea2957c7d4c21", "url": "https://api.github.com/repos/rust-lang/rust/commits/672b272077561ca7b5027a8aff9ea2957c7d4c21", "html_url": "https://github.com/rust-lang/rust/commit/672b272077561ca7b5027a8aff9ea2957c7d4c21"}], "stats": {"total": 482, "additions": 289, "deletions": 193}, "files": [{"sha": "12d3baf633362b55369139d1ba86c9cf27ddc2cf", "filename": "src/libstd/net/parser.rs", "status": "modified", "additions": 289, "deletions": 193, "changes": 482, "blob_url": "https://github.com/rust-lang/rust/blob/3ab7ae39ec77a39df27ac6c3fbde03cd3b763542/src%2Flibstd%2Fnet%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3ab7ae39ec77a39df27ac6c3fbde03cd3b763542/src%2Flibstd%2Fnet%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fparser.rs?ref=3ab7ae39ec77a39df27ac6c3fbde03cd3b763542", "patch": "@@ -10,163 +10,132 @@ use crate::str::FromStr;\n \n struct Parser<'a> {\n     // parsing as ASCII, so can use byte array\n-    s: &'a [u8],\n-    pos: usize,\n+    state: &'a [u8],\n }\n \n impl<'a> Parser<'a> {\n-    fn new(s: &'a str) -> Parser<'a> {\n-        Parser { s: s.as_bytes(), pos: 0 }\n+    fn new(input: &'a str) -> Parser<'a> {\n+        Parser { state: input.as_bytes() }\n     }\n \n     fn is_eof(&self) -> bool {\n-        self.pos == self.s.len()\n+        self.state.is_empty()\n     }\n \n-    // Commit only if parser returns Some\n-    fn read_atomically<T, F>(&mut self, cb: F) -> Option<T>\n+    /// Run a parser, and restore the pre-parse state if it fails\n+    fn read_atomically<T, F>(&mut self, inner: F) -> Option<T>\n     where\n         F: FnOnce(&mut Parser<'_>) -> Option<T>,\n     {\n-        let pos = self.pos;\n-        let r = cb(self);\n-        if r.is_none() {\n-            self.pos = pos;\n+        let state = self.state;\n+        let result = inner(self);\n+        if result.is_none() {\n+            self.state = state;\n         }\n-        r\n+        result\n     }\n \n-    // Commit only if parser read till EOF\n-    fn read_till_eof<T, F>(&mut self, cb: F) -> Option<T>\n+    /// Run a parser, but fail if the entire input wasn't consumed.\n+    /// Doesn't run atomically.\n+    fn read_till_eof<T, F>(&mut self, inner: F) -> Option<T>\n     where\n         F: FnOnce(&mut Parser<'_>) -> Option<T>,\n     {\n-        self.read_atomically(move |p| cb(p).filter(|_| p.is_eof()))\n+        inner(self).filter(|_| self.is_eof())\n     }\n \n-    // Apply 3 parsers sequentially\n-    fn read_seq_3<A, B, C, PA, PB, PC>(&mut self, pa: PA, pb: PB, pc: PC) -> Option<(A, B, C)>\n+    /// Same as read_till_eof, but returns a Result<AddrParseError> on failure\n+    fn parse_with<T, F>(&mut self, inner: F) -> Result<T, AddrParseError>\n     where\n-        PA: FnOnce(&mut Parser<'_>) -> Option<A>,\n-        PB: FnOnce(&mut Parser<'_>) -> Option<B>,\n-        PC: FnOnce(&mut Parser<'_>) -> Option<C>,\n+        F: FnOnce(&mut Parser<'_>) -> Option<T>,\n     {\n-        self.read_atomically(move |p| {\n-            let a = pa(p);\n-            let b = if a.is_some() { pb(p) } else { None };\n-            let c = if b.is_some() { pc(p) } else { None };\n-            match (a, b, c) {\n-                (Some(a), Some(b), Some(c)) => Some((a, b, c)),\n-                _ => None,\n-            }\n-        })\n+        self.read_till_eof(inner).ok_or(AddrParseError(()))\n     }\n \n-    // Read next char\n+    /// Read the next character from the input\n     fn read_char(&mut self) -> Option<char> {\n-        if self.is_eof() {\n-            None\n-        } else {\n-            let r = self.s[self.pos] as char;\n-            self.pos += 1;\n-            Some(r)\n-        }\n-    }\n-\n-    // Return char and advance iff next char is equal to requested\n-    fn read_given_char(&mut self, c: char) -> Option<char> {\n-        self.read_atomically(|p| match p.read_char() {\n-            Some(next) if next == c => Some(next),\n-            _ => None,\n+        self.state.split_first().map(|(&b, tail)| {\n+            self.state = tail;\n+            b as char\n         })\n     }\n \n-    // Read digit\n-    fn read_digit(&mut self, radix: u8) -> Option<u8> {\n-        fn parse_digit(c: char, radix: u8) -> Option<u8> {\n-            let c = c as u8;\n-            // assuming radix is either 10 or 16\n-            if c >= b'0' && c <= b'9' {\n-                Some(c - b'0')\n-            } else if radix > 10 && c >= b'a' && c < b'a' + (radix - 10) {\n-                Some(c - b'a' + 10)\n-            } else if radix > 10 && c >= b'A' && c < b'A' + (radix - 10) {\n-                Some(c - b'A' + 10)\n-            } else {\n-                None\n-            }\n-        }\n-\n-        self.read_atomically(|p| p.read_char().and_then(|c| parse_digit(c, radix)))\n+    /// Read the next character from the input if it matches the target\n+    fn read_given_char(&mut self, target: char) -> Option<char> {\n+        self.read_atomically(|p| p.read_char().filter(|&c| c == target))\n     }\n \n-    fn read_number_impl(&mut self, radix: u8, max_digits: u32, upto: u32) -> Option<u32> {\n-        let mut r = 0;\n-        let mut digit_count = 0;\n-        loop {\n-            match self.read_digit(radix) {\n-                Some(d) => {\n-                    r = r * (radix as u32) + (d as u32);\n-                    digit_count += 1;\n-                    if digit_count > max_digits || r >= upto {\n-                        return None;\n-                    }\n-                }\n-                None => {\n-                    if digit_count == 0 {\n-                        return None;\n-                    } else {\n-                        return Some(r);\n-                    }\n-                }\n-            };\n-        }\n+    /// Helper for reading separators in an indexed loop. Reads the separator\n+    /// character iff index > 0, then runs the parser. When used in a loop,\n+    /// the separator character will only be read on index > 0 (see\n+    /// read_ipv4_addr for an example)\n+    fn read_separator<T, F>(&mut self, sep: char, index: usize, inner: F) -> Option<T>\n+    where\n+        F: FnOnce(&mut Parser<'_>) -> Option<T>,\n+    {\n+        self.read_atomically(move |p| {\n+            if index > 0 {\n+                let _ = p.read_given_char(sep)?;\n+            }\n+            inner(p)\n+        })\n     }\n \n-    // Read number, failing if max_digits of number value exceeded\n-    fn read_number(&mut self, radix: u8, max_digits: u32, upto: u32) -> Option<u32> {\n-        self.read_atomically(|p| p.read_number_impl(radix, max_digits, upto))\n+    // Read a single digit in the given radix. For instance, 0-9 in radix 10;\n+    // 0-9A-F in radix 16.\n+    fn read_digit(&mut self, radix: u32) -> Option<u32> {\n+        self.read_atomically(move |p| p.read_char()?.to_digit(radix))\n     }\n \n-    fn read_ipv4_addr_impl(&mut self) -> Option<Ipv4Addr> {\n-        let mut bs = [0; 4];\n-        let mut i = 0;\n-        while i < 4 {\n-            if i != 0 && self.read_given_char('.').is_none() {\n-                return None;\n+    // Read a number off the front of the input in the given radix, stopping\n+    // at the first non-digit character or eof. Fails if the number has more\n+    // digits than max_digits, or the value is >= upto, or if there is no number.\n+    fn read_number(&mut self, radix: u32, max_digits: u32, upto: u32) -> Option<u32> {\n+        self.read_atomically(move |p| {\n+            let mut result = 0;\n+            let mut digit_count = 0;\n+\n+            while let Some(digit) = p.read_digit(radix) {\n+                result = (result * radix) + digit;\n+                digit_count += 1;\n+                if digit_count > max_digits || result >= upto {\n+                    return None;\n+                }\n             }\n \n-            bs[i] = self.read_number(10, 3, 0x100).map(|n| n as u8)?;\n-            i += 1;\n-        }\n-        Some(Ipv4Addr::new(bs[0], bs[1], bs[2], bs[3]))\n+            if digit_count == 0 { None } else { Some(result) }\n+        })\n     }\n \n-    // Read IPv4 address\n+    /// Read an IPv4 address\n     fn read_ipv4_addr(&mut self) -> Option<Ipv4Addr> {\n-        self.read_atomically(|p| p.read_ipv4_addr_impl())\n-    }\n+        self.read_atomically(|p| {\n+            let mut groups = [0; 4];\n \n-    fn read_ipv6_addr_impl(&mut self) -> Option<Ipv6Addr> {\n-        fn ipv6_addr_from_head_tail(head: &[u16], tail: &[u16]) -> Ipv6Addr {\n-            assert!(head.len() + tail.len() <= 8);\n-            let mut gs = [0; 8];\n-            gs[..head.len()].copy_from_slice(head);\n-            gs[(8 - tail.len())..8].copy_from_slice(tail);\n-            Ipv6Addr::new(gs[0], gs[1], gs[2], gs[3], gs[4], gs[5], gs[6], gs[7])\n-        }\n+            for (i, slot) in groups.iter_mut().enumerate() {\n+                *slot = p.read_separator('.', i, |p| p.read_number(10, 3, 0x100))? as u8;\n+            }\n+\n+            Some(groups.into())\n+        })\n+    }\n \n-        fn read_groups(p: &mut Parser<'_>, groups: &mut [u16; 8], limit: usize) -> (usize, bool) {\n-            let mut i = 0;\n-            while i < limit {\n+    /// Read an IPV6 Address\n+    fn read_ipv6_addr(&mut self) -> Option<Ipv6Addr> {\n+        /// Read a chunk of an ipv6 address into `groups`. Returns the number\n+        /// of groups read, along with a bool indicating if an embedded\n+        /// trailing ipv4 address was read. Specifically, read a series of\n+        /// colon-separated ipv6 groups (0x0000 - 0xFFFF), with an optional\n+        /// trailing embedded ipv4 address.\n+        fn read_groups(p: &mut Parser<'_>, groups: &mut [u16]) -> (usize, bool) {\n+            let limit = groups.len();\n+\n+            for (i, slot) in groups.iter_mut().enumerate() {\n+                // Try to read a trailing embedded ipv4 address. There must be\n+                // at least two groups left.\n                 if i < limit - 1 {\n-                    let ipv4 = p.read_atomically(|p| {\n-                        if i == 0 || p.read_given_char(':').is_some() {\n-                            p.read_ipv4_addr()\n-                        } else {\n-                            None\n-                        }\n-                    });\n+                    let ipv4 = p.read_separator(':', i, |p| p.read_ipv4_addr());\n+\n                     if let Some(v4_addr) = ipv4 {\n                         let octets = v4_addr.octets();\n                         groups[i + 0] = ((octets[0] as u16) << 8) | (octets[1] as u16);\n@@ -175,83 +144,85 @@ impl<'a> Parser<'a> {\n                     }\n                 }\n \n-                let group = p.read_atomically(|p| {\n-                    if i == 0 || p.read_given_char(':').is_some() {\n-                        p.read_number(16, 4, 0x10000).map(|n| n as u16)\n-                    } else {\n-                        None\n-                    }\n-                });\n+                let group = p.read_separator(':', i, |p| p.read_number(16, 4, 0x10000));\n+\n                 match group {\n-                    Some(g) => groups[i] = g,\n+                    Some(g) => *slot = g as u16,\n                     None => return (i, false),\n                 }\n-                i += 1;\n             }\n-            (i, false)\n+            (groups.len(), false)\n         }\n \n-        let mut head = [0; 8];\n-        let (head_size, head_ipv4) = read_groups(self, &mut head, 8);\n+        self.read_atomically(|p| {\n+            // Read the front part of the address; either the whole thing, or up\n+            // to the first ::\n+            let mut head = [0; 8];\n+            let (head_size, head_ipv4) = read_groups(p, &mut head);\n \n-        if head_size == 8 {\n-            return Some(Ipv6Addr::new(\n-                head[0], head[1], head[2], head[3], head[4], head[5], head[6], head[7],\n-            ));\n-        }\n+            if head_size == 8 {\n+                return Some(head.into());\n+            }\n \n-        // IPv4 part is not allowed before `::`\n-        if head_ipv4 {\n-            return None;\n-        }\n+            // IPv4 part is not allowed before `::`\n+            if head_ipv4 {\n+                return None;\n+            }\n \n-        // read `::` if previous code parsed less than 8 groups\n-        if self.read_given_char(':').is_none() || self.read_given_char(':').is_none() {\n-            return None;\n-        }\n+            // read `::` if previous code parsed less than 8 groups\n+            // `::` indicates one or more groups of 16 bits of zeros\n+            let _ = p.read_given_char(':')?;\n+            let _ = p.read_given_char(':')?;\n \n-        let mut tail = [0; 8];\n-        // `::` indicates one or more groups of 16 bits of zeros\n-        let limit = 8 - (head_size + 1);\n-        let (tail_size, _) = read_groups(self, &mut tail, limit);\n-        Some(ipv6_addr_from_head_tail(&head[..head_size], &tail[..tail_size]))\n-    }\n+            // Read the back part of the address. The :: must contain at least one\n+            // set of zeroes, so our max length is 7.\n+            let mut tail = [0; 7];\n+            let limit = 8 - (head_size + 1);\n+            let (tail_size, _) = read_groups(p, &mut tail[..limit]);\n \n-    fn read_ipv6_addr(&mut self) -> Option<Ipv6Addr> {\n-        self.read_atomically(|p| p.read_ipv6_addr_impl())\n+            // Concat the head and tail of the IP address\n+            head[(8 - tail_size)..8].copy_from_slice(&tail[..tail_size]);\n+\n+            Some(head.into())\n+        })\n     }\n \n+    /// Read an IP Address, either IPV4 or IPV6.\n     fn read_ip_addr(&mut self) -> Option<IpAddr> {\n-        self.read_ipv4_addr().map(IpAddr::V4).or_else(|| self.read_ipv6_addr().map(IpAddr::V6))\n+        self.read_ipv4_addr().map(IpAddr::V4).or_else(move || self.read_ipv6_addr().map(IpAddr::V6))\n     }\n \n-    fn read_socket_addr_v4(&mut self) -> Option<SocketAddrV4> {\n-        let ip_addr = |p: &mut Parser<'_>| p.read_ipv4_addr();\n-        let colon = |p: &mut Parser<'_>| p.read_given_char(':');\n-        let port = |p: &mut Parser<'_>| p.read_number(10, 5, 0x10000).map(|n| n as u16);\n+    /// Read a : followed by a port in base 10\n+    fn read_port(&mut self) -> Option<u16> {\n+        self.read_atomically(|p| {\n+            let _ = p.read_given_char(':')?;\n+            let port = p.read_number(10, 5, 0x10000)?;\n+            Some(port as u16)\n+        })\n+    }\n \n-        self.read_seq_3(ip_addr, colon, port).map(|t| {\n-            let (ip, _, port): (Ipv4Addr, char, u16) = t;\n-            SocketAddrV4::new(ip, port)\n+    /// Read an IPV4 address with a port\n+    fn read_socket_addr_v4(&mut self) -> Option<SocketAddrV4> {\n+        self.read_atomically(|p| {\n+            let ip = p.read_ipv4_addr()?;\n+            let port = p.read_port()?;\n+            Some(SocketAddrV4::new(ip, port))\n         })\n     }\n \n+    /// Read an IPV6 address with a port\n     fn read_socket_addr_v6(&mut self) -> Option<SocketAddrV6> {\n-        let ip_addr = |p: &mut Parser<'_>| {\n-            let open_br = |p: &mut Parser<'_>| p.read_given_char('[');\n-            let ip_addr = |p: &mut Parser<'_>| p.read_ipv6_addr();\n-            let clos_br = |p: &mut Parser<'_>| p.read_given_char(']');\n-            p.read_seq_3(open_br, ip_addr, clos_br).map(|t| t.1)\n-        };\n-        let colon = |p: &mut Parser<'_>| p.read_given_char(':');\n-        let port = |p: &mut Parser<'_>| p.read_number(10, 5, 0x10000).map(|n| n as u16);\n-\n-        self.read_seq_3(ip_addr, colon, port).map(|t| {\n-            let (ip, _, port): (Ipv6Addr, char, u16) = t;\n-            SocketAddrV6::new(ip, port, 0, 0)\n+        self.read_atomically(|p| {\n+            let _ = p.read_given_char('[')?;\n+            let ip = p.read_ipv6_addr()?;\n+            let _ = p.read_given_char(']')?;\n+\n+            let port = p.read_port()?;\n+            Some(SocketAddrV6::new(ip, port, 0, 0))\n         })\n     }\n \n+    /// Read an IP address with a port\n     fn read_socket_addr(&mut self) -> Option<SocketAddr> {\n         self.read_socket_addr_v4()\n             .map(SocketAddr::V4)\n@@ -263,65 +234,47 @@ impl<'a> Parser<'a> {\n impl FromStr for IpAddr {\n     type Err = AddrParseError;\n     fn from_str(s: &str) -> Result<IpAddr, AddrParseError> {\n-        match Parser::new(s).read_till_eof(|p| p.read_ip_addr()) {\n-            Some(s) => Ok(s),\n-            None => Err(AddrParseError(())),\n-        }\n+        Parser::new(s).parse_with(|p| p.read_ip_addr())\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl FromStr for Ipv4Addr {\n     type Err = AddrParseError;\n     fn from_str(s: &str) -> Result<Ipv4Addr, AddrParseError> {\n-        match Parser::new(s).read_till_eof(|p| p.read_ipv4_addr()) {\n-            Some(s) => Ok(s),\n-            None => Err(AddrParseError(())),\n-        }\n+        Parser::new(s).parse_with(|p| p.read_ipv4_addr())\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl FromStr for Ipv6Addr {\n     type Err = AddrParseError;\n     fn from_str(s: &str) -> Result<Ipv6Addr, AddrParseError> {\n-        match Parser::new(s).read_till_eof(|p| p.read_ipv6_addr()) {\n-            Some(s) => Ok(s),\n-            None => Err(AddrParseError(())),\n-        }\n+        Parser::new(s).parse_with(|p| p.read_ipv6_addr())\n     }\n }\n \n #[stable(feature = \"socket_addr_from_str\", since = \"1.5.0\")]\n impl FromStr for SocketAddrV4 {\n     type Err = AddrParseError;\n     fn from_str(s: &str) -> Result<SocketAddrV4, AddrParseError> {\n-        match Parser::new(s).read_till_eof(|p| p.read_socket_addr_v4()) {\n-            Some(s) => Ok(s),\n-            None => Err(AddrParseError(())),\n-        }\n+        Parser::new(s).parse_with(|p| p.read_socket_addr_v4())\n     }\n }\n \n #[stable(feature = \"socket_addr_from_str\", since = \"1.5.0\")]\n impl FromStr for SocketAddrV6 {\n     type Err = AddrParseError;\n     fn from_str(s: &str) -> Result<SocketAddrV6, AddrParseError> {\n-        match Parser::new(s).read_till_eof(|p| p.read_socket_addr_v6()) {\n-            Some(s) => Ok(s),\n-            None => Err(AddrParseError(())),\n-        }\n+        Parser::new(s).parse_with(|p| p.read_socket_addr_v6())\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl FromStr for SocketAddr {\n     type Err = AddrParseError;\n     fn from_str(s: &str) -> Result<SocketAddr, AddrParseError> {\n-        match Parser::new(s).read_till_eof(|p| p.read_socket_addr()) {\n-            Some(s) => Ok(s),\n-            None => Err(AddrParseError(())),\n-        }\n+        Parser::new(s).parse_with(|p| p.read_socket_addr())\n     }\n }\n \n@@ -376,3 +329,146 @@ impl Error for AddrParseError {\n         \"invalid IP address syntax\"\n     }\n }\n+\n+#[cfg(test)]\n+mod tests {\n+    // FIXME: These tests are all excellent candidates for AFL fuzz testing\n+    use crate::net::{IpAddr, Ipv4Addr, Ipv6Addr, SocketAddr, SocketAddrV4, SocketAddrV6};\n+    use crate::str::FromStr;\n+\n+    const PORT: u16 = 8080;\n+\n+    const IPV4: Ipv4Addr = Ipv4Addr::new(192, 168, 0, 1);\n+    const IPV4_STR: &str = \"192.168.0.1\";\n+    const IPV4_STR_PORT: &str = \"192.168.0.1:8080\";\n+\n+    const IPV6: Ipv6Addr = Ipv6Addr::new(0x2001, 0xdb8, 0, 0, 0, 0, 0xc0a8, 0x1);\n+    const IPV6_STR_FULL: &str = \"2001:db8:0:0:0:0:c0a8:1\";\n+    const IPV6_STR_COMPRESS: &str = \"2001:db8::c0a8:1\";\n+    const IPV6_STR_V4: &str = \"2001:db8::192.168.0.1\";\n+    const IPV6_STR_PORT: &str = \"[2001:db8::c0a8:1]:8080\";\n+\n+    #[test]\n+    fn parse_ipv4() {\n+        let result: Ipv4Addr = IPV4_STR.parse().unwrap();\n+        assert_eq!(result, IPV4);\n+\n+        assert!(Ipv4Addr::from_str(IPV4_STR_PORT).is_err());\n+        assert!(Ipv4Addr::from_str(IPV6_STR_FULL).is_err());\n+        assert!(Ipv4Addr::from_str(IPV6_STR_COMPRESS).is_err());\n+        assert!(Ipv4Addr::from_str(IPV6_STR_V4).is_err());\n+        assert!(Ipv4Addr::from_str(IPV6_STR_PORT).is_err());\n+    }\n+\n+    #[test]\n+    fn parse_ipv6() {\n+        let result: Ipv6Addr = IPV6_STR_FULL.parse().unwrap();\n+        assert_eq!(result, IPV6);\n+\n+        let result: Ipv6Addr = IPV6_STR_COMPRESS.parse().unwrap();\n+        assert_eq!(result, IPV6);\n+\n+        let result: Ipv6Addr = IPV6_STR_V4.parse().unwrap();\n+        assert_eq!(result, IPV6);\n+\n+        assert!(Ipv6Addr::from_str(IPV4_STR).is_err());\n+        assert!(Ipv6Addr::from_str(IPV4_STR_PORT).is_err());\n+        assert!(Ipv6Addr::from_str(IPV6_STR_PORT).is_err());\n+    }\n+\n+    #[test]\n+    fn parse_ip() {\n+        let result: IpAddr = IPV4_STR.parse().unwrap();\n+        assert_eq!(result, IpAddr::from(IPV4));\n+\n+        let result: IpAddr = IPV6_STR_FULL.parse().unwrap();\n+        assert_eq!(result, IpAddr::from(IPV6));\n+\n+        let result: IpAddr = IPV6_STR_COMPRESS.parse().unwrap();\n+        assert_eq!(result, IpAddr::from(IPV6));\n+\n+        let result: IpAddr = IPV6_STR_V4.parse().unwrap();\n+        assert_eq!(result, IpAddr::from(IPV6));\n+\n+        assert!(IpAddr::from_str(IPV4_STR_PORT).is_err());\n+        assert!(IpAddr::from_str(IPV6_STR_PORT).is_err());\n+    }\n+\n+    #[test]\n+    fn parse_socket_v4() {\n+        let result: SocketAddrV4 = IPV4_STR_PORT.parse().unwrap();\n+        assert_eq!(result, SocketAddrV4::new(IPV4, PORT));\n+\n+        assert!(SocketAddrV4::from_str(IPV4_STR).is_err());\n+        assert!(SocketAddrV4::from_str(IPV6_STR_FULL).is_err());\n+        assert!(SocketAddrV4::from_str(IPV6_STR_COMPRESS).is_err());\n+        assert!(SocketAddrV4::from_str(IPV6_STR_V4).is_err());\n+        assert!(SocketAddrV4::from_str(IPV6_STR_PORT).is_err());\n+    }\n+\n+    #[test]\n+    fn parse_socket_v6() {\n+        let result: SocketAddrV6 = IPV6_STR_PORT.parse().unwrap();\n+        assert_eq!(result, SocketAddrV6::new(IPV6, PORT, 0, 0));\n+\n+        assert!(SocketAddrV6::from_str(IPV4_STR).is_err());\n+        assert!(SocketAddrV6::from_str(IPV4_STR_PORT).is_err());\n+        assert!(SocketAddrV6::from_str(IPV6_STR_FULL).is_err());\n+        assert!(SocketAddrV6::from_str(IPV6_STR_COMPRESS).is_err());\n+        assert!(SocketAddrV6::from_str(IPV6_STR_V4).is_err());\n+    }\n+\n+    #[test]\n+    fn parse_socket() {\n+        let result: SocketAddr = IPV4_STR_PORT.parse().unwrap();\n+        assert_eq!(result, SocketAddr::from((IPV4, PORT)));\n+\n+        let result: SocketAddr = IPV6_STR_PORT.parse().unwrap();\n+        assert_eq!(result, SocketAddr::from((IPV6, PORT)));\n+\n+        assert!(SocketAddr::from_str(IPV4_STR).is_err());\n+        assert!(SocketAddr::from_str(IPV6_STR_FULL).is_err());\n+        assert!(SocketAddr::from_str(IPV6_STR_COMPRESS).is_err());\n+        assert!(SocketAddr::from_str(IPV6_STR_V4).is_err());\n+    }\n+\n+    #[test]\n+    fn ipv6_corner_cases() {\n+        let result: Ipv6Addr = \"1::\".parse().unwrap();\n+        assert_eq!(result, Ipv6Addr::new(1, 0, 0, 0, 0, 0, 0, 0));\n+\n+        let result: Ipv6Addr = \"1:1::\".parse().unwrap();\n+        assert_eq!(result, Ipv6Addr::new(1, 1, 0, 0, 0, 0, 0, 0));\n+\n+        let result: Ipv6Addr = \"::1\".parse().unwrap();\n+        assert_eq!(result, Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1));\n+\n+        let result: Ipv6Addr = \"::1:1\".parse().unwrap();\n+        assert_eq!(result, Ipv6Addr::new(0, 0, 0, 0, 0, 0, 1, 1));\n+\n+        let result: Ipv6Addr = \"::\".parse().unwrap();\n+        assert_eq!(result, Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 0));\n+\n+        let result: Ipv6Addr = \"::192.168.0.1\".parse().unwrap();\n+        assert_eq!(result, Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0xc0a8, 0x1));\n+\n+        let result: Ipv6Addr = \"::1:192.168.0.1\".parse().unwrap();\n+        assert_eq!(result, Ipv6Addr::new(0, 0, 0, 0, 0, 1, 0xc0a8, 0x1));\n+\n+        let result: Ipv6Addr = \"1:1:1:1:1:1:192.168.0.1\".parse().unwrap();\n+        assert_eq!(result, Ipv6Addr::new(1, 1, 1, 1, 1, 1, 0xc0a8, 0x1));\n+    }\n+\n+    // Things that might not seem like failures but are\n+    #[test]\n+    fn ipv6_corner_failures() {\n+        // No IP address before the ::\n+        assert!(Ipv6Addr::from_str(\"1:192.168.0.1::\").is_err());\n+\n+        // :: must have at least 1 set of zeroes\n+        assert!(Ipv6Addr::from_str(\"1:1:1:1::1:1:1:1\").is_err());\n+\n+        // Need brackets for a port\n+        assert!(SocketAddrV6::from_str(\"1:1:1:1:1:1:1:1:8080\").is_err());\n+    }\n+}"}]}