{"sha": "1464fc3a0cb2b8a92c54357fcff7c632b334cb29", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE0NjRmYzNhMGNiMmI4YTkyYzU0MzU3ZmNmZjdjNjMyYjMzNGNiMjk=", "commit": {"author": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2020-09-19T10:42:14Z"}, "committer": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2020-09-27T09:56:42Z"}, "message": "Move thread parker to a separate module.", "tree": {"sha": "502085e007d9538db4fc9a1004813887d7a532e6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/502085e007d9538db4fc9a1004813887d7a532e6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1464fc3a0cb2b8a92c54357fcff7c632b334cb29", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1464fc3a0cb2b8a92c54357fcff7c632b334cb29", "html_url": "https://github.com/rust-lang/rust/commit/1464fc3a0cb2b8a92c54357fcff7c632b334cb29", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1464fc3a0cb2b8a92c54357fcff7c632b334cb29/comments", "author": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "committer": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c9e5e6a53aef5cd1b939ecfa18f56bdf5bf0451c", "url": "https://api.github.com/repos/rust-lang/rust/commits/c9e5e6a53aef5cd1b939ecfa18f56bdf5bf0451c", "html_url": "https://github.com/rust-lang/rust/commit/c9e5e6a53aef5cd1b939ecfa18f56bdf5bf0451c"}], "stats": {"total": 254, "additions": 142, "deletions": 112}, "files": [{"sha": "a5a8d5c9fbbc52c04faa579a98bc9a123bf3b61a", "filename": "library/std/src/thread/mod.rs", "status": "modified", "additions": 17, "deletions": 112, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/1464fc3a0cb2b8a92c54357fcff7c632b334cb29/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1464fc3a0cb2b8a92c54357fcff7c632b334cb29/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fthread%2Fmod.rs?ref=1464fc3a0cb2b8a92c54357fcff7c632b334cb29", "patch": "@@ -149,6 +149,8 @@\n #[cfg(all(test, not(target_os = \"emscripten\")))]\n mod tests;\n \n+mod parker;\n+\n use crate::any::Any;\n use crate::cell::UnsafeCell;\n use crate::ffi::{CStr, CString};\n@@ -159,15 +161,14 @@ use crate::num::NonZeroU64;\n use crate::panic;\n use crate::panicking;\n use crate::str;\n-use crate::sync::atomic::AtomicUsize;\n-use crate::sync::atomic::Ordering::SeqCst;\n-use crate::sync::{Arc, Condvar, Mutex};\n+use crate::sync::Arc;\n use crate::sys::thread as imp;\n use crate::sys_common::mutex;\n use crate::sys_common::thread;\n use crate::sys_common::thread_info;\n use crate::sys_common::{AsInner, IntoInner};\n use crate::time::Duration;\n+use parker::Parker;\n \n ////////////////////////////////////////////////////////////////////////////////\n // Thread-local storage\n@@ -667,6 +668,8 @@ pub fn current() -> Thread {\n ///\n /// [`channel`]: crate::sync::mpsc\n /// [`join`]: JoinHandle::join\n+/// [`Condvar`]: crate::sync::Condvar\n+/// [`Mutex`]: crate::sync::Mutex\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn yield_now() {\n     imp::Thread::yield_now()\n@@ -712,6 +715,8 @@ pub fn yield_now() {\n ///     panic!()\n /// }\n /// ```\n+///\n+/// [Mutex]: crate::sync::Mutex\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn panicking() -> bool {\n@@ -779,11 +784,6 @@ pub fn sleep(dur: Duration) {\n     imp::Thread::sleep(dur)\n }\n \n-// constants for park/unpark\n-const EMPTY: usize = 0;\n-const PARKED: usize = 1;\n-const NOTIFIED: usize = 2;\n-\n /// Blocks unless or until the current thread's token is made available.\n ///\n /// A call to `park` does not guarantee that the thread will remain parked\n@@ -870,45 +870,11 @@ const NOTIFIED: usize = 2;\n ///\n /// [`unpark`]: Thread::unpark\n /// [`thread::park_timeout`]: park_timeout\n-//\n-// The implementation currently uses the trivial strategy of a Mutex+Condvar\n-// with wakeup flag, which does not actually allow spurious wakeups. In the\n-// future, this will be implemented in a more efficient way, perhaps along the lines of\n-//   http://cr.openjdk.java.net/~stefank/6989984.1/raw_files/new/src/os/linux/vm/os_linux.cpp\n-// or futuxes, and in either case may allow spurious wakeups.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn park() {\n-    let thread = current();\n-\n-    // If we were previously notified then we consume this notification and\n-    // return quickly.\n-    if thread.inner.state.compare_exchange(NOTIFIED, EMPTY, SeqCst, SeqCst).is_ok() {\n-        return;\n-    }\n-\n-    // Otherwise we need to coordinate going to sleep\n-    let mut m = thread.inner.lock.lock().unwrap();\n-    match thread.inner.state.compare_exchange(EMPTY, PARKED, SeqCst, SeqCst) {\n-        Ok(_) => {}\n-        Err(NOTIFIED) => {\n-            // We must read here, even though we know it will be `NOTIFIED`.\n-            // This is because `unpark` may have been called again since we read\n-            // `NOTIFIED` in the `compare_exchange` above. We must perform an\n-            // acquire operation that synchronizes with that `unpark` to observe\n-            // any writes it made before the call to unpark. To do that we must\n-            // read from the write it made to `state`.\n-            let old = thread.inner.state.swap(EMPTY, SeqCst);\n-            assert_eq!(old, NOTIFIED, \"park state changed unexpectedly\");\n-            return;\n-        } // should consume this notification, so prohibit spurious wakeups in next park.\n-        Err(_) => panic!(\"inconsistent park state\"),\n-    }\n-    loop {\n-        m = thread.inner.cvar.wait(m).unwrap();\n-        match thread.inner.state.compare_exchange(NOTIFIED, EMPTY, SeqCst, SeqCst) {\n-            Ok(_) => return, // got a notification\n-            Err(_) => {}     // spurious wakeup, go back to sleep\n-        }\n+    // SAFETY: park_timeout is called on the parker owned by this thread.\n+    unsafe {\n+        current().inner.parker.park();\n     }\n }\n \n@@ -970,35 +936,9 @@ pub fn park_timeout_ms(ms: u32) {\n /// ```\n #[stable(feature = \"park_timeout\", since = \"1.4.0\")]\n pub fn park_timeout(dur: Duration) {\n-    let thread = current();\n-\n-    // Like `park` above we have a fast path for an already-notified thread, and\n-    // afterwards we start coordinating for a sleep.\n-    // return quickly.\n-    if thread.inner.state.compare_exchange(NOTIFIED, EMPTY, SeqCst, SeqCst).is_ok() {\n-        return;\n-    }\n-    let m = thread.inner.lock.lock().unwrap();\n-    match thread.inner.state.compare_exchange(EMPTY, PARKED, SeqCst, SeqCst) {\n-        Ok(_) => {}\n-        Err(NOTIFIED) => {\n-            // We must read again here, see `park`.\n-            let old = thread.inner.state.swap(EMPTY, SeqCst);\n-            assert_eq!(old, NOTIFIED, \"park state changed unexpectedly\");\n-            return;\n-        } // should consume this notification, so prohibit spurious wakeups in next park.\n-        Err(_) => panic!(\"inconsistent park_timeout state\"),\n-    }\n-\n-    // Wait with a timeout, and if we spuriously wake up or otherwise wake up\n-    // from a notification we just want to unconditionally set the state back to\n-    // empty, either consuming a notification or un-flagging ourselves as\n-    // parked.\n-    let (_m, _result) = thread.inner.cvar.wait_timeout(m, dur).unwrap();\n-    match thread.inner.state.swap(EMPTY, SeqCst) {\n-        NOTIFIED => {} // got a notification, hurray!\n-        PARKED => {}   // no notification, alas\n-        n => panic!(\"inconsistent park_timeout state: {}\", n),\n+    // SAFETY: park_timeout is called on the parker owned by this thread.\n+    unsafe {\n+        current().inner.parker.park_timeout(dur);\n     }\n }\n \n@@ -1077,11 +1017,7 @@ impl ThreadId {\n struct Inner {\n     name: Option<CString>, // Guaranteed to be UTF-8\n     id: ThreadId,\n-\n-    // state for thread park/unpark\n-    state: AtomicUsize,\n-    lock: Mutex<()>,\n-    cvar: Condvar,\n+    parker: Parker,\n }\n \n #[derive(Clone)]\n@@ -1115,13 +1051,7 @@ impl Thread {\n         let cname =\n             name.map(|n| CString::new(n).expect(\"thread name may not contain interior null bytes\"));\n         Thread {\n-            inner: Arc::new(Inner {\n-                name: cname,\n-                id: ThreadId::new(),\n-                state: AtomicUsize::new(EMPTY),\n-                lock: Mutex::new(()),\n-                cvar: Condvar::new(),\n-            }),\n+            inner: Arc::new(Inner { name: cname, id: ThreadId::new(), parker: Parker::new() }),\n         }\n     }\n \n@@ -1157,32 +1087,7 @@ impl Thread {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn unpark(&self) {\n-        // To ensure the unparked thread will observe any writes we made\n-        // before this call, we must perform a release operation that `park`\n-        // can synchronize with. To do that we must write `NOTIFIED` even if\n-        // `state` is already `NOTIFIED`. That is why this must be a swap\n-        // rather than a compare-and-swap that returns if it reads `NOTIFIED`\n-        // on failure.\n-        match self.inner.state.swap(NOTIFIED, SeqCst) {\n-            EMPTY => return,    // no one was waiting\n-            NOTIFIED => return, // already unparked\n-            PARKED => {}        // gotta go wake someone up\n-            _ => panic!(\"inconsistent state in unpark\"),\n-        }\n-\n-        // There is a period between when the parked thread sets `state` to\n-        // `PARKED` (or last checked `state` in the case of a spurious wake\n-        // up) and when it actually waits on `cvar`. If we were to notify\n-        // during this period it would be ignored and then when the parked\n-        // thread went to sleep it would never wake up. Fortunately, it has\n-        // `lock` locked at this stage so we can acquire `lock` to wait until\n-        // it is ready to receive the notification.\n-        //\n-        // Releasing `lock` before the call to `notify_one` means that when the\n-        // parked thread wakes it doesn't get woken only to have to wait for us\n-        // to release `lock`.\n-        drop(self.inner.lock.lock().unwrap());\n-        self.inner.cvar.notify_one()\n+        self.inner.parker.unpark();\n     }\n \n     /// Gets the thread's unique identifier."}, {"sha": "c8b9b7b1c7938982e341db85e59079f481893091", "filename": "library/std/src/thread/parker/mod.rs", "status": "added", "additions": 125, "deletions": 0, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/1464fc3a0cb2b8a92c54357fcff7c632b334cb29/library%2Fstd%2Fsrc%2Fthread%2Fparker%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1464fc3a0cb2b8a92c54357fcff7c632b334cb29/library%2Fstd%2Fsrc%2Fthread%2Fparker%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fthread%2Fparker%2Fmod.rs?ref=1464fc3a0cb2b8a92c54357fcff7c632b334cb29", "patch": "@@ -0,0 +1,125 @@\n+//! Parker implementaiton based on a Mutex and Condvar.\n+//!\n+//! The implementation currently uses the trivial strategy of a Mutex+Condvar\n+//! with wakeup flag, which does not actually allow spurious wakeups. In the\n+//! future, this will be implemented in a more efficient way, perhaps along the lines of\n+//!   http://cr.openjdk.java.net/~stefank/6989984.1/raw_files/new/src/os/linux/vm/os_linux.cpp\n+//! or futuxes, and in either case may allow spurious wakeups.\n+\n+use crate::sync::atomic::AtomicUsize;\n+use crate::sync::atomic::Ordering::SeqCst;\n+use crate::sync::{Condvar, Mutex};\n+use crate::time::Duration;\n+\n+const EMPTY: usize = 0;\n+const PARKED: usize = 1;\n+const NOTIFIED: usize = 2;\n+\n+pub struct Parker {\n+    state: AtomicUsize,\n+    lock: Mutex<()>,\n+    cvar: Condvar,\n+}\n+\n+impl Parker {\n+    pub fn new() -> Self {\n+        Parker { state: AtomicUsize::new(EMPTY), lock: Mutex::new(()), cvar: Condvar::new() }\n+    }\n+\n+    // This implementaiton doesn't require `unsafe`, but other implementations\n+    // may assume this is only called by the thread that owns the Parker.\n+    pub unsafe fn park(&self) {\n+        // If we were previously notified then we consume this notification and\n+        // return quickly.\n+        if self.state.compare_exchange(NOTIFIED, EMPTY, SeqCst, SeqCst).is_ok() {\n+            return;\n+        }\n+\n+        // Otherwise we need to coordinate going to sleep\n+        let mut m = self.lock.lock().unwrap();\n+        match self.state.compare_exchange(EMPTY, PARKED, SeqCst, SeqCst) {\n+            Ok(_) => {}\n+            Err(NOTIFIED) => {\n+                // We must read here, even though we know it will be `NOTIFIED`.\n+                // This is because `unpark` may have been called again since we read\n+                // `NOTIFIED` in the `compare_exchange` above. We must perform an\n+                // acquire operation that synchronizes with that `unpark` to observe\n+                // any writes it made before the call to unpark. To do that we must\n+                // read from the write it made to `state`.\n+                let old = self.state.swap(EMPTY, SeqCst);\n+                assert_eq!(old, NOTIFIED, \"park state changed unexpectedly\");\n+                return;\n+            } // should consume this notification, so prohibit spurious wakeups in next park.\n+            Err(_) => panic!(\"inconsistent park state\"),\n+        }\n+        loop {\n+            m = self.cvar.wait(m).unwrap();\n+            match self.state.compare_exchange(NOTIFIED, EMPTY, SeqCst, SeqCst) {\n+                Ok(_) => return, // got a notification\n+                Err(_) => {}     // spurious wakeup, go back to sleep\n+            }\n+        }\n+    }\n+\n+    // This implementaiton doesn't require `unsafe`, but other implementations\n+    // may assume this is only called by the thread that owns the Parker.\n+    pub unsafe fn park_timeout(&self, dur: Duration) {\n+        // Like `park` above we have a fast path for an already-notified thread, and\n+        // afterwards we start coordinating for a sleep.\n+        // return quickly.\n+        if self.state.compare_exchange(NOTIFIED, EMPTY, SeqCst, SeqCst).is_ok() {\n+            return;\n+        }\n+        let m = self.lock.lock().unwrap();\n+        match self.state.compare_exchange(EMPTY, PARKED, SeqCst, SeqCst) {\n+            Ok(_) => {}\n+            Err(NOTIFIED) => {\n+                // We must read again here, see `park`.\n+                let old = self.state.swap(EMPTY, SeqCst);\n+                assert_eq!(old, NOTIFIED, \"park state changed unexpectedly\");\n+                return;\n+            } // should consume this notification, so prohibit spurious wakeups in next park.\n+            Err(_) => panic!(\"inconsistent park_timeout state\"),\n+        }\n+\n+        // Wait with a timeout, and if we spuriously wake up or otherwise wake up\n+        // from a notification we just want to unconditionally set the state back to\n+        // empty, either consuming a notification or un-flagging ourselves as\n+        // parked.\n+        let (_m, _result) = self.cvar.wait_timeout(m, dur).unwrap();\n+        match self.state.swap(EMPTY, SeqCst) {\n+            NOTIFIED => {} // got a notification, hurray!\n+            PARKED => {}   // no notification, alas\n+            n => panic!(\"inconsistent park_timeout state: {}\", n),\n+        }\n+    }\n+\n+    pub fn unpark(&self) {\n+        // To ensure the unparked thread will observe any writes we made\n+        // before this call, we must perform a release operation that `park`\n+        // can synchronize with. To do that we must write `NOTIFIED` even if\n+        // `state` is already `NOTIFIED`. That is why this must be a swap\n+        // rather than a compare-and-swap that returns if it reads `NOTIFIED`\n+        // on failure.\n+        match self.state.swap(NOTIFIED, SeqCst) {\n+            EMPTY => return,    // no one was waiting\n+            NOTIFIED => return, // already unparked\n+            PARKED => {}        // gotta go wake someone up\n+            _ => panic!(\"inconsistent state in unpark\"),\n+        }\n+\n+        // There is a period between when the parked thread sets `state` to\n+        // `PARKED` (or last checked `state` in the case of a spurious wake\n+        // up) and when it actually waits on `cvar`. If we were to notify\n+        // during this period it would be ignored and then when the parked\n+        // thread went to sleep it would never wake up. Fortunately, it has\n+        // `lock` locked at this stage so we can acquire `lock` to wait until\n+        // it is ready to receive the notification.\n+        //\n+        // Releasing `lock` before the call to `notify_one` means that when the\n+        // parked thread wakes it doesn't get woken only to have to wait for us\n+        // to release `lock`.\n+        drop(self.lock.lock().unwrap());\n+        self.cvar.notify_one()\n+    }\n+}"}]}