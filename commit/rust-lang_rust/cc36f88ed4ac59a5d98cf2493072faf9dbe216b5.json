{"sha": "cc36f88ed4ac59a5d98cf2493072faf9dbe216b5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNjMzZmODhlZDRhYzU5YTVkOThjZjI0OTMwNzJmYWY5ZGJlMjE2YjU=", "commit": {"author": {"name": "Shotaro Yamada", "email": "sinkuu@sinkuu.xyz", "date": "2017-11-10T14:06:06Z"}, "committer": {"name": "Shotaro Yamada", "email": "sinkuu@sinkuu.xyz", "date": "2017-11-14T08:12:08Z"}, "message": "Handle closures correctly in MIR inlining", "tree": {"sha": "b226e621c3f5aea1d06ba31fdd948f593fa58e04", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b226e621c3f5aea1d06ba31fdd948f593fa58e04"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cc36f88ed4ac59a5d98cf2493072faf9dbe216b5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cc36f88ed4ac59a5d98cf2493072faf9dbe216b5", "html_url": "https://github.com/rust-lang/rust/commit/cc36f88ed4ac59a5d98cf2493072faf9dbe216b5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cc36f88ed4ac59a5d98cf2493072faf9dbe216b5/comments", "author": {"login": "sinkuu", "id": 7091080, "node_id": "MDQ6VXNlcjcwOTEwODA=", "avatar_url": "https://avatars.githubusercontent.com/u/7091080?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sinkuu", "html_url": "https://github.com/sinkuu", "followers_url": "https://api.github.com/users/sinkuu/followers", "following_url": "https://api.github.com/users/sinkuu/following{/other_user}", "gists_url": "https://api.github.com/users/sinkuu/gists{/gist_id}", "starred_url": "https://api.github.com/users/sinkuu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sinkuu/subscriptions", "organizations_url": "https://api.github.com/users/sinkuu/orgs", "repos_url": "https://api.github.com/users/sinkuu/repos", "events_url": "https://api.github.com/users/sinkuu/events{/privacy}", "received_events_url": "https://api.github.com/users/sinkuu/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sinkuu", "id": 7091080, "node_id": "MDQ6VXNlcjcwOTEwODA=", "avatar_url": "https://avatars.githubusercontent.com/u/7091080?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sinkuu", "html_url": "https://github.com/sinkuu", "followers_url": "https://api.github.com/users/sinkuu/followers", "following_url": "https://api.github.com/users/sinkuu/following{/other_user}", "gists_url": "https://api.github.com/users/sinkuu/gists{/gist_id}", "starred_url": "https://api.github.com/users/sinkuu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sinkuu/subscriptions", "organizations_url": "https://api.github.com/users/sinkuu/orgs", "repos_url": "https://api.github.com/users/sinkuu/repos", "events_url": "https://api.github.com/users/sinkuu/events{/privacy}", "received_events_url": "https://api.github.com/users/sinkuu/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b5a3ab2e81c837df95a21758b00aeb4e88477b30", "url": "https://api.github.com/repos/rust-lang/rust/commits/b5a3ab2e81c837df95a21758b00aeb4e88477b30", "html_url": "https://github.com/rust-lang/rust/commit/b5a3ab2e81c837df95a21758b00aeb4e88477b30"}], "stats": {"total": 119, "additions": 109, "deletions": 10}, "files": [{"sha": "1e308ccdc945c6c86e8d977c3ef37513ad09947a", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 56, "deletions": 10, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/cc36f88ed4ac59a5d98cf2493072faf9dbe216b5/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc36f88ed4ac59a5d98cf2493072faf9dbe216b5/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=cc36f88ed4ac59a5d98cf2493072faf9dbe216b5", "patch": "@@ -20,6 +20,7 @@ use rustc::mir::transform::{MirPass, MirSource};\n use rustc::mir::visit::*;\n use rustc::ty::{self, Instance, Ty, TyCtxt, TypeFoldable};\n use rustc::ty::subst::{Subst,Substs};\n+use rustc::hir::map::definitions::DefPathData;\n \n use std::collections::VecDeque;\n use super::simplify::{remove_dead_blocks, CfgSimplifier};\n@@ -550,22 +551,31 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n         Operand::Consume(cast_tmp)\n     }\n \n-    fn make_call_args(&self, args: Vec<Operand<'tcx>>,\n-                      callsite: &CallSite<'tcx>, caller_mir: &mut Mir<'tcx>) -> Vec<Operand<'tcx>> {\n-        let tcx = self.tcx;\n+    fn make_call_args(\n+        &self,\n+        args: Vec<Operand<'tcx>>,\n+        callsite: &CallSite<'tcx>,\n+        caller_mir: &mut Mir<'tcx>,\n+    ) -> Vec<Operand<'tcx>> {\n         // FIXME: Analysis of the usage of the arguments to avoid\n         // unnecessary temporaries.\n-        args.into_iter().map(|a| {\n-            if let Operand::Consume(Lvalue::Local(local)) = a {\n+\n+        fn create_temp_if_necessary<'a, 'tcx: 'a>(\n+            arg: Operand<'tcx>,\n+            tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+            callsite: &CallSite<'tcx>,\n+            caller_mir: &mut Mir<'tcx>,\n+        ) -> Operand<'tcx> {\n+            if let Operand::Consume(Lvalue::Local(local)) = arg {\n                 if caller_mir.local_kind(local) == LocalKind::Temp {\n                     // Reuse the operand if it's a temporary already\n-                    return a;\n+                    return arg;\n                 }\n             }\n \n-            debug!(\"Creating temp for argument\");\n+            debug!(\"Creating temp for argument {:?}\", arg);\n             // Otherwise, create a temporary for the arg\n-            let arg = Rvalue::Use(a);\n+            let arg = Rvalue::Use(arg);\n \n             let ty = arg.ty(caller_mir, tcx);\n \n@@ -575,11 +585,47 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n \n             let stmt = Statement {\n                 source_info: callsite.location,\n-                kind: StatementKind::Assign(arg_tmp.clone(), arg)\n+                kind: StatementKind::Assign(arg_tmp.clone(), arg),\n             };\n             caller_mir[callsite.bb].statements.push(stmt);\n             Operand::Consume(arg_tmp)\n-        }).collect()\n+        }\n+\n+        let tcx = self.tcx;\n+\n+        // A closure is passed its self-type and a tuple like `(arg1, arg2, ...)`,\n+        // hence mappings to tuple fields are needed.\n+        if tcx.def_key(callsite.callee).disambiguated_data.data == DefPathData::ClosureExpr {\n+            let mut args = args.into_iter();\n+\n+            let self_ = create_temp_if_necessary(args.next().unwrap(), tcx, callsite, caller_mir);\n+\n+            let tuple = if let Operand::Consume(lvalue) =\n+                create_temp_if_necessary(args.next().unwrap(), tcx, callsite, caller_mir)\n+            {\n+                lvalue\n+            } else {\n+                unreachable!()\n+            };\n+            assert!(args.next().is_none());\n+\n+            let tuple_tys = if let ty::TyTuple(s, _) = tuple.ty(caller_mir, tcx).to_ty(tcx).sty {\n+                s\n+            } else {\n+                bug!(\"Closure arguments are not passed as a tuple\");\n+            };\n+\n+            let mut res = Vec::with_capacity(1 + tuple_tys.len());\n+            res.push(self_);\n+            res.extend(tuple_tys.iter().enumerate().map(|(i, ty)| {\n+                Operand::Consume(tuple.clone().field(Field::new(i), ty))\n+            }));\n+            res\n+        } else {\n+            args.into_iter()\n+                .map(|a| create_temp_if_necessary(a, tcx, callsite, caller_mir))\n+                .collect()\n+        }\n     }\n }\n "}, {"sha": "bf5761ba5b7ef603bc66b81bd18740c17764df17", "filename": "src/test/mir-opt/inline-closure.rs", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/cc36f88ed4ac59a5d98cf2493072faf9dbe216b5/src%2Ftest%2Fmir-opt%2Finline-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc36f88ed4ac59a5d98cf2493072faf9dbe216b5/src%2Ftest%2Fmir-opt%2Finline-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline-closure.rs?ref=cc36f88ed4ac59a5d98cf2493072faf9dbe216b5", "patch": "@@ -0,0 +1,53 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -Z span_free_formats\n+\n+// Tests that MIR inliner can handle closure arguments. (#45894)\n+\n+fn main() {\n+    println!(\"{}\", foo(0, 14));\n+}\n+\n+fn foo<T: Copy>(_t: T, q: i32) -> i32 {\n+    let x = |_t, _q| _t;\n+    x(q*2, q*3)\n+}\n+\n+// END RUST SOURCE\n+// START rustc.foo.Inline.after.mir\n+// ...\n+// bb0: {\n+//     StorageLive(_3);\n+//     _3 = [closure@NodeId(28)];\n+//     StorageLive(_4);\n+//     _4 = &_3;\n+//     StorageLive(_5);\n+//     StorageLive(_6);\n+//     StorageLive(_7);\n+//     _7 = _2;\n+//     _6 = Mul(_7, const 2i32);\n+//     StorageDead(_7);\n+//     StorageLive(_8);\n+//     StorageLive(_9);\n+//     _9 = _2;\n+//     _8 = Mul(_9, const 3i32);\n+//     StorageDead(_9);\n+//     _5 = (_6, _8);\n+//     _0 = (_5.0: i32);\n+//     StorageDead(_5);\n+//     StorageDead(_8);\n+//     StorageDead(_6);\n+//     StorageDead(_4);\n+//     StorageDead(_3);\n+//     return;\n+// }\n+// ...\n+// END rustc.foo.Inline.after.mir\n\\ No newline at end of file"}]}