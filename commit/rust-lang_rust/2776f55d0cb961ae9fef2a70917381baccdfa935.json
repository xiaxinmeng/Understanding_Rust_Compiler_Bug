{"sha": "2776f55d0cb961ae9fef2a70917381baccdfa935", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI3NzZmNTVkMGNiOTYxYWU5ZmVmMmE3MDkxNzM4MWJhY2NkZmE5MzU=", "commit": {"author": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-02-28T01:20:25Z"}, "committer": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-02-28T01:20:25Z"}, "message": "WIP: Switching to a new byte-based value representation.", "tree": {"sha": "ad871ecd3e37b70683b8461fecc8ce20b6f0046e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ad871ecd3e37b70683b8461fecc8ce20b6f0046e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2776f55d0cb961ae9fef2a70917381baccdfa935", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2776f55d0cb961ae9fef2a70917381baccdfa935", "html_url": "https://github.com/rust-lang/rust/commit/2776f55d0cb961ae9fef2a70917381baccdfa935", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2776f55d0cb961ae9fef2a70917381baccdfa935/comments", "author": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b26388659891322e5382e754dc211816e20a22ce", "url": "https://api.github.com/repos/rust-lang/rust/commits/b26388659891322e5382e754dc211816e20a22ce", "html_url": "https://github.com/rust-lang/rust/commit/b26388659891322e5382e754dc211816e20a22ce"}], "stats": {"total": 809, "additions": 561, "deletions": 248}, "files": [{"sha": "8fc715429970f1bc843dcce39866cdd04dd4245b", "filename": "Cargo.lock", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2776f55d0cb961ae9fef2a70917381baccdfa935/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/2776f55d0cb961ae9fef2a70917381baccdfa935/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=2776f55d0cb961ae9fef2a70917381baccdfa935", "patch": "@@ -1,4 +1,12 @@\n [root]\n name = \"miri\"\n version = \"0.1.0\"\n+dependencies = [\n+ \"byteorder 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n+[[package]]\n+name = \"byteorder\"\n+version = \"0.4.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n "}, {"sha": "a369f6070c86b4afed6ac8f322479e36bfe59c6f", "filename": "Cargo.toml", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/2776f55d0cb961ae9fef2a70917381baccdfa935/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/2776f55d0cb961ae9fef2a70917381baccdfa935/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=2776f55d0cb961ae9fef2a70917381baccdfa935", "patch": "@@ -1,11 +1,14 @@\n [package]\n-name = \"miri\"\n-version = \"0.1.0\"\n authors = [\"Scott Olson <scott@solson.me>\"]\n description = \"An experimental interpreter for Rust MIR.\"\n-repository = \"https://github.com/tsion/miri\"\n license = \"ISC\"\n+name = \"miri\"\n+repository = \"https://github.com/tsion/miri\"\n+version = \"0.1.0\"\n \n [[bin]]\n-name = \"miri\"\n doc = false\n+name = \"miri\"\n+\n+[dependencies]\n+byteorder = \"0.4.2\""}, {"sha": "01db533661ed3179669dcda901eb72aea0532afd", "filename": "src/interpreter.rs", "status": "modified", "additions": 369, "deletions": 244, "changes": 613, "blob_url": "https://github.com/rust-lang/rust/blob/2776f55d0cb961ae9fef2a70917381baccdfa935/src%2Finterpreter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2776f55d0cb961ae9fef2a70917381baccdfa935/src%2Finterpreter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter.rs?ref=2776f55d0cb961ae9fef2a70917381baccdfa935", "patch": "@@ -1,37 +1,127 @@\n+// TODO(tsion): Remove this.\n+#![allow(unused_imports, dead_code, unused_variables)]\n+\n+use byteorder;\n+use byteorder::ByteOrder;\n use rustc::middle::{const_eval, def_id, ty};\n use rustc::middle::cstore::CrateStore;\n use rustc::mir::repr::{self as mir, Mir};\n use rustc::mir::mir_map::MirMap;\n+use std::collections::HashMap;\n use syntax::ast::Attribute;\n use syntax::attr::AttrMetaMethods;\n \n use std::iter;\n \n-const TRACE_EXECUTION: bool = false;\n+const TRACE_EXECUTION: bool = true;\n \n-#[derive(Clone, Debug, PartialEq)]\n-enum Value {\n-    Uninit,\n-    Bool(bool),\n-    Int(i64), // FIXME(tsion): Should be bit-width aware.\n-    Pointer(Pointer),\n-    Adt { variant: usize, data_ptr: Pointer },\n-    Func(def_id::DefId),\n-}\n+mod memory {\n+    use byteorder;\n+    use byteorder::ByteOrder;\n+    use rustc::middle::ty;\n+    use std::collections::HashMap;\n+    use std::mem;\n \n-#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]\n-enum Pointer {\n-    Stack(usize),\n-    // TODO(tsion): Heap\n-}\n+    pub struct Memory {\n+        next_id: u64,\n+        alloc_map: HashMap<u64, Value>,\n+    }\n+\n+    #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n+    pub struct AllocId(u64);\n+\n+    // TODO(tsion): Remove this hack.\n+    pub fn alloc_id_hack(i: u64) -> AllocId {\n+        AllocId(i)\n+    }\n+\n+    // TODO(tsion): Shouldn't clone values.\n+    #[derive(Clone, Debug)]\n+    pub struct Value {\n+        pub bytes: Vec<u8>,\n+        // TODO(tsion): relocations\n+        // TODO(tsion): undef mask\n+    }\n+\n+    #[derive(Clone, Debug, PartialEq, Eq)]\n+    pub struct Pointer {\n+        pub alloc_id: AllocId,\n+        pub offset: usize,\n+        pub repr: Repr,\n+    }\n+\n+    #[derive(Clone, Debug, PartialEq, Eq)]\n+    pub enum Repr {\n+        Int,\n+\n+        StackFrame {\n+            locals: Vec<Repr>,\n+        }\n+    }\n+\n+    impl Memory {\n+        pub fn new() -> Self {\n+            Memory { next_id: 0, alloc_map: HashMap::new() }\n+        }\n+\n+        pub fn allocate(&mut self, size: usize) -> AllocId {\n+            let id = AllocId(self.next_id);\n+            let val = Value { bytes: vec![0; size] };\n+            self.alloc_map.insert(self.next_id, val);\n+            self.next_id += 1;\n+            id\n+        }\n+\n+        pub fn allocate_int(&mut self, n: i64) -> AllocId {\n+            let id = self.allocate(mem::size_of::<i64>());\n+            byteorder::NativeEndian::write_i64(&mut self.value_mut(id).unwrap().bytes, n);\n+            id\n+        }\n+\n+        pub fn value(&self, id: AllocId) -> Option<&Value> {\n+            self.alloc_map.get(&id.0)\n+        }\n+\n+        pub fn value_mut(&mut self, id: AllocId) -> Option<&mut Value> {\n+            self.alloc_map.get_mut(&id.0)\n+        }\n+    }\n+\n+    impl Pointer {\n+        pub fn offset(self, i: usize) -> Self {\n+            Pointer { offset: self.offset + i, ..self }\n+        }\n+    }\n+\n+    impl Repr {\n+        // TODO(tsion): Cache these outputs.\n+        pub fn from_ty(ty: ty::Ty) -> Self {\n+            match ty.sty {\n+                ty::TyInt(_) => Repr::Int,\n+                _ => unimplemented!(),\n+            }\n+        }\n \n-impl Pointer {\n-    fn offset(self, i: usize) -> Self {\n-        match self {\n-            Pointer::Stack(p) => Pointer::Stack(p + i),\n+        pub fn size(&self) -> usize {\n+            match *self {\n+                Repr::Int => 8,\n+                Repr::StackFrame { ref locals } =>\n+                    locals.iter().map(Repr::size).fold(0, |a, b| a + b)\n+            }\n         }\n     }\n }\n+use self::memory::{Pointer, Repr, Value};\n+\n+// #[derive(Clone, Debug, PartialEq)]\n+// enum Value {\n+//     Uninit,\n+//     Bool(bool),\n+//     Int(i64), // FIXME(tsion): Should be bit-width aware.\n+//     Pointer(Pointer),\n+//     Adt { variant: usize, data_ptr: Pointer },\n+//     Func(def_id::DefId),\n+// }\n \n /// A stack frame:\n ///\n@@ -55,90 +145,91 @@ impl Pointer {\n /// | Aggregates            | aggregates\n /// +-----------------------+\n /// ```\n-#[derive(Debug)]\n-struct Frame {\n-    /// A pointer to a stack cell to write the return value of the current call, if it's not a\n-    /// divering call.\n-    return_ptr: Option<Pointer>,\n-\n-    offset: usize,\n-    num_args: usize,\n-    num_vars: usize,\n-    num_temps: usize,\n-    num_aggregate_fields: usize,\n-}\n-\n-impl Frame {\n-    fn size(&self) -> usize {\n-        self.num_args + self.num_vars + self.num_temps + self.num_aggregate_fields\n-    }\n-\n-    fn arg_offset(&self, i: usize) -> usize {\n-        self.offset + i\n-    }\n-\n-    fn var_offset(&self, i: usize) -> usize {\n-        self.offset + self.num_args + i\n-    }\n-\n-    fn temp_offset(&self, i: usize) -> usize {\n-        self.offset + self.num_args + self.num_vars + i\n-    }\n-}\n+// #[derive(Debug)]\n+// struct Frame {\n+//     /// A pointer to a stack cell to write the return value of the current call, if it's not a\n+//     /// divering call.\n+//     return_ptr: Option<Pointer>,\n+\n+//     offset: usize,\n+//     num_args: usize,\n+//     num_vars: usize,\n+//     num_temps: usize,\n+//     num_aggregate_fields: usize,\n+// }\n+\n+// impl Frame {\n+//     fn size(&self) -> usize {\n+//         self.num_args + self.num_vars + self.num_temps + self.num_aggregate_fields\n+//     }\n+\n+//     fn arg_offset(&self, i: usize) -> usize {\n+//         self.offset + i\n+//     }\n+\n+//     fn var_offset(&self, i: usize) -> usize {\n+//         self.offset + self.num_args + i\n+//     }\n+\n+//     fn temp_offset(&self, i: usize) -> usize {\n+//         self.offset + self.num_args + self.num_vars + i\n+//     }\n+// }\n \n struct Interpreter<'a, 'tcx: 'a> {\n     tcx: &'a ty::ctxt<'tcx>,\n     mir_map: &'a MirMap<'tcx>,\n-    value_stack: Vec<Value>,\n-    call_stack: Vec<Frame>,\n+    // value_stack: Vec<Value>,\n+    // call_stack: Vec<Frame>,\n+    memory: memory::Memory,\n }\n \n impl<'a, 'tcx> Interpreter<'a, 'tcx> {\n     fn new(tcx: &'a ty::ctxt<'tcx>, mir_map: &'a MirMap<'tcx>) -> Self {\n         Interpreter {\n             tcx: tcx,\n             mir_map: mir_map,\n-            value_stack: vec![Value::Uninit], // Allocate a spot for the top-level return value.\n-            call_stack: Vec::new(),\n+            // value_stack: vec![Value::Uninit], // Allocate a spot for the top-level return value.\n+            // call_stack: Vec::new(),\n+            memory: memory::Memory::new(),\n         }\n     }\n \n-    fn push_stack_frame(&mut self, mir: &Mir, args: &[Value], return_ptr: Option<Pointer>) {\n-        let frame = Frame {\n-            return_ptr: return_ptr,\n-            offset: self.value_stack.len(),\n-            num_args: mir.arg_decls.len(),\n-            num_vars: mir.var_decls.len(),\n-            num_temps: mir.temp_decls.len(),\n-            num_aggregate_fields: 0,\n-        };\n+    // fn push_stack_frame(&mut self, mir: &Mir, args: &[Value], return_ptr: Option<Pointer>) {\n+    //     let frame = Frame {\n+    //         return_ptr: return_ptr,\n+    //         offset: self.value_stack.len(),\n+    //         num_args: mir.arg_decls.len(),\n+    //         num_vars: mir.var_decls.len(),\n+    //         num_temps: mir.temp_decls.len(),\n+    //         num_aggregate_fields: 0,\n+    //     };\n \n-        self.value_stack.extend(iter::repeat(Value::Uninit).take(frame.size()));\n-\n-        for (i, arg) in args.iter().enumerate() {\n-            self.value_stack[frame.arg_offset(i)] = arg.clone();\n-        }\n+    //     self.value_stack.extend(iter::repeat(Value::Uninit).take(frame.size()));\n \n-        self.call_stack.push(frame);\n+    //     for (i, arg) in args.iter().enumerate() {\n+    //         self.value_stack[frame.arg_offset(i)] = arg.clone();\n+    //     }\n \n-    }\n+    //     self.call_stack.push(frame);\n+    // }\n \n-    fn pop_stack_frame(&mut self) {\n-        let frame = self.call_stack.pop().expect(\"tried to pop stack frame, but there were none\");\n-        self.value_stack.truncate(frame.offset);\n-    }\n+    // fn pop_stack_frame(&mut self) {\n+    //     let frame = self.call_stack.pop().expect(\"tried to pop stack frame, but there were none\");\n+    //     self.value_stack.truncate(frame.offset);\n+    // }\n \n-    fn allocate_aggregate(&mut self, size: usize) -> Pointer {\n-        let frame = self.call_stack.last_mut().expect(\"missing call frame\");\n-        frame.num_aggregate_fields += size;\n+    // fn allocate_aggregate(&mut self, size: usize) -> Pointer {\n+    //     let frame = self.call_stack.last_mut().expect(\"missing call frame\");\n+    //     frame.num_aggregate_fields += size;\n \n-        let ptr = Pointer::Stack(self.value_stack.len());\n-        self.value_stack.extend(iter::repeat(Value::Uninit).take(size));\n-        ptr\n-    }\n+    //     let ptr = Pointer::Stack(self.value_stack.len());\n+    //     self.value_stack.extend(iter::repeat(Value::Uninit).take(size));\n+    //     ptr\n+    // }\n \n     fn call(&mut self, mir: &Mir, args: &[Value], return_ptr: Option<Pointer>) {\n-        self.push_stack_frame(mir, args, return_ptr);\n+        // self.push_stack_frame(mir, args, return_ptr);\n         let mut block = mir::START_BLOCK;\n \n         loop {\n@@ -150,9 +241,8 @@ impl<'a, 'tcx> Interpreter<'a, 'tcx> {\n \n                 match stmt.kind {\n                     mir::StatementKind::Assign(ref lvalue, ref rvalue) => {\n-                        let ptr = self.eval_lvalue(lvalue);\n-                        let value = self.eval_rvalue(rvalue);\n-                        self.write_pointer(ptr, value);\n+                        let ptr = self.lvalue_to_ptr(lvalue);\n+                        self.eval_rvalue_into(rvalue, ptr);\n                     }\n                 }\n             }\n@@ -163,215 +253,240 @@ impl<'a, 'tcx> Interpreter<'a, 'tcx> {\n                 mir::Terminator::Return => break,\n                 mir::Terminator::Goto { target } => block = target,\n \n-                mir::Terminator::Call { ref func, ref args, ref destination, .. } => {\n-                    let ptr = destination.as_ref().map(|&(ref lv, _)| self.eval_lvalue(lv));\n-                    let func_val = self.eval_operand(func);\n-\n-                    if let Value::Func(def_id) = func_val {\n-                        let mir_data;\n-                        let mir = match self.tcx.map.as_local_node_id(def_id) {\n-                            Some(node_id) => self.mir_map.map.get(&node_id).unwrap(),\n-                            None => {\n-                                let cstore = &self.tcx.sess.cstore;\n-                                mir_data = cstore.maybe_get_item_mir(self.tcx, def_id).unwrap();\n-                                &mir_data\n-                            }\n-                        };\n-\n-                        let arg_vals: Vec<Value> =\n-                            args.iter().map(|arg| self.eval_operand(arg)).collect();\n-\n-                        self.call(mir, &arg_vals, ptr);\n-\n-                        if let Some((_, target)) = *destination {\n-                            block = target;\n-                        }\n-                    } else {\n-                        panic!(\"tried to call a non-function value: {:?}\", func_val);\n-                    }\n-                }\n-\n-                mir::Terminator::If { ref cond, targets: (then_target, else_target) } => {\n-                    match self.eval_operand(cond) {\n-                        Value::Bool(true) => block = then_target,\n-                        Value::Bool(false) => block = else_target,\n-                        cond_val => panic!(\"Non-boolean `if` condition value: {:?}\", cond_val),\n-                    }\n-                }\n-\n-                mir::Terminator::SwitchInt { ref discr, ref values, ref targets, .. } => {\n-                    let discr_val = self.read_lvalue(discr);\n-\n-                    let index = values.iter().position(|v| discr_val == self.eval_constant(v))\n-                        .expect(\"discriminant matched no values\");\n-\n-                    block = targets[index];\n-                }\n-\n-                mir::Terminator::Switch { ref discr, ref targets, .. } => {\n-                    let discr_val = self.read_lvalue(discr);\n-\n-                    if let Value::Adt { variant, .. } = discr_val {\n-                        block = targets[variant];\n-                    } else {\n-                        panic!(\"Switch on non-Adt value: {:?}\", discr_val);\n-                    }\n-                }\n+                // mir::Terminator::Call { ref func, ref args, ref destination, .. } => {\n+                //     let ptr = destination.as_ref().map(|&(ref lv, _)| self.lvalue_to_ptr(lv));\n+                //     let func_val = self.operand_to_ptr(func);\n+\n+                //     if let Value::Func(def_id) = func_val {\n+                //         let mir_data;\n+                //         let mir = match self.tcx.map.as_local_node_id(def_id) {\n+                //             Some(node_id) => self.mir_map.map.get(&node_id).unwrap(),\n+                //             None => {\n+                //                 let cstore = &self.tcx.sess.cstore;\n+                //                 mir_data = cstore.maybe_get_item_mir(self.tcx, def_id).unwrap();\n+                //                 &mir_data\n+                //             }\n+                //         };\n+\n+                //         let arg_vals: Vec<Value> =\n+                //             args.iter().map(|arg| self.operand_to_ptr(arg)).collect();\n+\n+                //         self.call(mir, &arg_vals, ptr);\n+\n+                //         if let Some((_, target)) = *destination {\n+                //             block = target;\n+                //         }\n+                //     } else {\n+                //         panic!(\"tried to call a non-function value: {:?}\", func_val);\n+                //     }\n+                // }\n+\n+                // mir::Terminator::If { ref cond, targets: (then_target, else_target) } => {\n+                //     match self.operand_to_ptr(cond) {\n+                //         Value::Bool(true) => block = then_target,\n+                //         Value::Bool(false) => block = else_target,\n+                //         cond_val => panic!(\"Non-boolean `if` condition value: {:?}\", cond_val),\n+                //     }\n+                // }\n+\n+                // mir::Terminator::SwitchInt { ref discr, ref values, ref targets, .. } => {\n+                //     let discr_val = self.read_lvalue(discr);\n+\n+                //     let index = values.iter().position(|v| discr_val == self.eval_constant(v))\n+                //         .expect(\"discriminant matched no values\");\n+\n+                //     block = targets[index];\n+                // }\n+\n+                // mir::Terminator::Switch { ref discr, ref targets, .. } => {\n+                //     let discr_val = self.read_lvalue(discr);\n+\n+                //     if let Value::Adt { variant, .. } = discr_val {\n+                //         block = targets[variant];\n+                //     } else {\n+                //         panic!(\"Switch on non-Adt value: {:?}\", discr_val);\n+                //     }\n+                // }\n \n                 mir::Terminator::Drop { target, .. } => {\n                     // TODO: Handle destructors and dynamic drop.\n                     block = target;\n                 }\n \n                 mir::Terminator::Resume => unimplemented!(),\n+                _ => unimplemented!(),\n             }\n         }\n \n-        self.pop_stack_frame();\n+        // self.pop_stack_frame();\n     }\n \n-    fn eval_lvalue(&self, lvalue: &mir::Lvalue) -> Pointer {\n-        let frame = self.call_stack.last().expect(\"missing call frame\");\n-\n+    fn lvalue_to_ptr(&self, lvalue: &mir::Lvalue) -> Pointer {\n         match *lvalue {\n-            mir::Lvalue::ReturnPointer =>\n-                frame.return_ptr.expect(\"ReturnPointer used in a function with no return value\"),\n-            mir::Lvalue::Arg(i)  => Pointer::Stack(frame.arg_offset(i as usize)),\n-            mir::Lvalue::Var(i)  => Pointer::Stack(frame.var_offset(i as usize)),\n-            mir::Lvalue::Temp(i) => Pointer::Stack(frame.temp_offset(i as usize)),\n-\n-            mir::Lvalue::Projection(ref proj) => {\n-                let base_ptr = self.eval_lvalue(&proj.base);\n-\n-                match proj.elem {\n-                    mir::ProjectionElem::Field(field, _) => {\n-                        base_ptr.offset(field.index())\n-                    }\n-\n-                    mir::ProjectionElem::Downcast(_, variant) => {\n-                        let adt_val = self.read_pointer(base_ptr);\n-                        if let Value::Adt { variant: actual_variant, data_ptr } = adt_val {\n-                            debug_assert_eq!(variant, actual_variant);\n-                            data_ptr\n-                        } else {\n-                            panic!(\"Downcast attempted on non-ADT: {:?}\", adt_val)\n-                        }\n-                    }\n-\n-                    mir::ProjectionElem::Deref => {\n-                        let ptr_val = self.read_pointer(base_ptr);\n-                        if let Value::Pointer(ptr) = ptr_val {\n-                            ptr\n-                        } else {\n-                            panic!(\"Deref attempted on non-pointer: {:?}\", ptr_val)\n-                        }\n-                    }\n-\n-                    mir::ProjectionElem::Index(ref _operand) => unimplemented!(),\n-                    mir::ProjectionElem::ConstantIndex { .. } => unimplemented!(),\n-                }\n-            }\n+            mir::Lvalue::ReturnPointer => Pointer {\n+                alloc_id: self::memory::alloc_id_hack(0),\n+                offset: 0,\n+                repr: Repr::Int,\n+            },\n \n             _ => unimplemented!(),\n         }\n+\n+        // let frame = self.call_stack.last().expect(\"missing call frame\");\n+\n+        // match *lvalue {\n+        //     mir::Lvalue::ReturnPointer =>\n+        //         frame.return_ptr.expect(\"ReturnPointer used in a function with no return value\"),\n+        //     mir::Lvalue::Arg(i)  => Pointer::Stack(frame.arg_offset(i as usize)),\n+        //     mir::Lvalue::Var(i)  => Pointer::Stack(frame.var_offset(i as usize)),\n+        //     mir::Lvalue::Temp(i) => Pointer::Stack(frame.temp_offset(i as usize)),\n+\n+        //     mir::Lvalue::Projection(ref proj) => {\n+        //         let base_ptr = self.lvalue_to_ptr(&proj.base);\n+\n+        //         match proj.elem {\n+        //             mir::ProjectionElem::Field(field, _) => {\n+        //                 base_ptr.offset(field.index())\n+        //             }\n+\n+        //             mir::ProjectionElem::Downcast(_, variant) => {\n+        //                 let adt_val = self.read_pointer(base_ptr);\n+        //                 if let Value::Adt { variant: actual_variant, data_ptr } = adt_val {\n+        //                     debug_assert_eq!(variant, actual_variant);\n+        //                     data_ptr\n+        //                 } else {\n+        //                     panic!(\"Downcast attempted on non-ADT: {:?}\", adt_val)\n+        //                 }\n+        //             }\n+\n+        //             mir::ProjectionElem::Deref => {\n+        //                 let ptr_val = self.read_pointer(base_ptr);\n+        //                 if let Value::Pointer(ptr) = ptr_val {\n+        //                     ptr\n+        //                 } else {\n+        //                     panic!(\"Deref attempted on non-pointer: {:?}\", ptr_val)\n+        //                 }\n+        //             }\n+\n+        //             mir::ProjectionElem::Index(ref _operand) => unimplemented!(),\n+        //             mir::ProjectionElem::ConstantIndex { .. } => unimplemented!(),\n+        //         }\n+        //     }\n+\n+        //     _ => unimplemented!(),\n+        // }\n     }\n \n-    fn eval_binary_op(&mut self, bin_op: mir::BinOp, left: Value, right: Value) -> Value {\n-        match (left, right) {\n-            (Value::Int(l), Value::Int(r)) => {\n-                match bin_op {\n-                    mir::BinOp::Add    => Value::Int(l + r),\n-                    mir::BinOp::Sub    => Value::Int(l - r),\n-                    mir::BinOp::Mul    => Value::Int(l * r),\n-                    mir::BinOp::Div    => Value::Int(l / r),\n-                    mir::BinOp::Rem    => Value::Int(l % r),\n-                    mir::BinOp::BitXor => Value::Int(l ^ r),\n-                    mir::BinOp::BitAnd => Value::Int(l & r),\n-                    mir::BinOp::BitOr  => Value::Int(l | r),\n-                    mir::BinOp::Shl    => Value::Int(l << r),\n-                    mir::BinOp::Shr    => Value::Int(l >> r),\n-                    mir::BinOp::Eq     => Value::Bool(l == r),\n-                    mir::BinOp::Lt     => Value::Bool(l < r),\n-                    mir::BinOp::Le     => Value::Bool(l <= r),\n-                    mir::BinOp::Ne     => Value::Bool(l != r),\n-                    mir::BinOp::Ge     => Value::Bool(l >= r),\n-                    mir::BinOp::Gt     => Value::Bool(l > r),\n-                }\n+    fn eval_binary_op(&mut self, bin_op: mir::BinOp, left: Pointer, right: Pointer, out: Pointer) {\n+        match (left.repr, right.repr, out.repr) {\n+            (Repr::Int, Repr::Int, Repr::Int) => {\n+                let l = byteorder::NativeEndian::read_i64(&self.memory.value(left.alloc_id).unwrap().bytes);\n+                let r = byteorder::NativeEndian::read_i64(&self.memory.value(right.alloc_id).unwrap().bytes);\n+                let n = match bin_op {\n+                    mir::BinOp::Add    => l + r,\n+                    mir::BinOp::Sub    => l - r,\n+                    mir::BinOp::Mul    => l * r,\n+                    mir::BinOp::Div    => l / r,\n+                    mir::BinOp::Rem    => l % r,\n+                    mir::BinOp::BitXor => l ^ r,\n+                    mir::BinOp::BitAnd => l & r,\n+                    mir::BinOp::BitOr  => l | r,\n+                    mir::BinOp::Shl    => l << r,\n+                    mir::BinOp::Shr    => l >> r,\n+                    _                  => unimplemented!(),\n+                    // mir::BinOp::Eq     => Value::Bool(l == r),\n+                    // mir::BinOp::Lt     => Value::Bool(l < r),\n+                    // mir::BinOp::Le     => Value::Bool(l <= r),\n+                    // mir::BinOp::Ne     => Value::Bool(l != r),\n+                    // mir::BinOp::Ge     => Value::Bool(l >= r),\n+                    // mir::BinOp::Gt     => Value::Bool(l > r),\n+                };\n+                byteorder::NativeEndian::write_i64(&mut self.memory.value_mut(out.alloc_id).unwrap().bytes, n);\n             }\n \n             _ => unimplemented!(),\n         }\n     }\n \n-    fn eval_rvalue(&mut self, rvalue: &mir::Rvalue) -> Value {\n+    fn eval_rvalue_into(&mut self, rvalue: &mir::Rvalue, out: Pointer) {\n         match *rvalue {\n-            mir::Rvalue::Use(ref operand) => self.eval_operand(operand),\n+            mir::Rvalue::Use(ref operand) => {\n+                let ptr = self.operand_to_ptr(operand);\n+                let val = self.read_pointer(ptr);\n+                self.write_pointer(out, val);\n+            }\n \n             mir::Rvalue::BinaryOp(bin_op, ref left, ref right) => {\n-                let left_val = self.eval_operand(left);\n-                let right_val = self.eval_operand(right);\n-                self.eval_binary_op(bin_op, left_val, right_val)\n+                let left_ptr = self.operand_to_ptr(left);\n+                let right_ptr = self.operand_to_ptr(right);\n+                self.eval_binary_op(bin_op, left_ptr, right_ptr, out)\n             }\n \n             mir::Rvalue::UnaryOp(un_op, ref operand) => {\n-                match (un_op, self.eval_operand(operand)) {\n-                    (mir::UnOp::Not, Value::Int(n)) => Value::Int(!n),\n-                    (mir::UnOp::Neg, Value::Int(n)) => Value::Int(-n),\n-                    _ => unimplemented!(),\n-                }\n+                unimplemented!()\n+                // match (un_op, self.operand_to_ptr(operand)) {\n+                //     (mir::UnOp::Not, Value::Int(n)) => Value::Int(!n),\n+                //     (mir::UnOp::Neg, Value::Int(n)) => Value::Int(-n),\n+                //     _ => unimplemented!(),\n+                // }\n             }\n \n-            mir::Rvalue::Ref(_region, _kind, ref lvalue) => {\n-                Value::Pointer(self.eval_lvalue(lvalue))\n-            }\n+            // mir::Rvalue::Ref(_region, _kind, ref lvalue) => {\n+            //     Value::Pointer(self.lvalue_to_ptr(lvalue))\n+            // }\n \n-            mir::Rvalue::Aggregate(mir::AggregateKind::Adt(ref adt_def, variant, _substs),\n-                                   ref operands) => {\n-                let max_fields = adt_def.variants\n-                    .iter()\n-                    .map(|v| v.fields.len())\n-                    .max()\n-                    .unwrap_or(0);\n+            // mir::Rvalue::Aggregate(mir::AggregateKind::Adt(ref adt_def, variant, _substs),\n+            //                        ref operands) => {\n+            //     let max_fields = adt_def.variants\n+            //         .iter()\n+            //         .map(|v| v.fields.len())\n+            //         .max()\n+            //         .unwrap_or(0);\n \n-                let ptr = self.allocate_aggregate(max_fields);\n+            //     let ptr = self.allocate_aggregate(max_fields);\n \n-                for (i, operand) in operands.iter().enumerate() {\n-                    let val = self.eval_operand(operand);\n-                    self.write_pointer(ptr.offset(i), val);\n-                }\n+            //     for (i, operand) in operands.iter().enumerate() {\n+            //         let val = self.operand_to_ptr(operand);\n+            //         self.write_pointer(ptr.offset(i), val);\n+            //     }\n \n-                Value::Adt { variant: variant, data_ptr: ptr }\n-            }\n+            //     Value::Adt { variant: variant, data_ptr: ptr }\n+            // }\n \n             ref r => panic!(\"can't handle rvalue: {:?}\", r),\n         }\n     }\n \n-    fn eval_operand(&mut self, op: &mir::Operand) -> Value {\n+    fn operand_to_ptr(&mut self, op: &mir::Operand) -> Pointer {\n         match *op {\n-            mir::Operand::Consume(ref lvalue) => self.read_lvalue(lvalue),\n+            mir::Operand::Consume(ref lvalue) => self.lvalue_to_ptr(lvalue),\n \n             mir::Operand::Constant(ref constant) => {\n                 match constant.literal {\n                     mir::Literal::Value { ref value } => self.eval_constant(value),\n \n                     mir::Literal::Item { def_id, kind, .. } => match kind {\n-                        mir::ItemKind::Function | mir::ItemKind::Method => Value::Func(def_id),\n+                        // mir::ItemKind::Function | mir::ItemKind::Method => Value::Func(def_id),\n                         _ => panic!(\"can't handle item literal: {:?}\", constant.literal),\n                     },\n                 }\n             }\n         }\n     }\n \n-    fn eval_constant(&self, const_val: &const_eval::ConstVal) -> Value {\n+    fn eval_constant(&mut self, const_val: &const_eval::ConstVal) -> Pointer {\n         match *const_val {\n             const_eval::ConstVal::Float(_f)         => unimplemented!(),\n-            const_eval::ConstVal::Int(i)            => Value::Int(i),\n+            // const_eval::ConstVal::Int(i)            => Value::new_int(i),\n+            const_eval::ConstVal::Int(i)            => Pointer {\n+                alloc_id: self.memory.allocate_int(i),\n+                offset: 0,\n+                repr: Repr::Int,\n+            },\n             const_eval::ConstVal::Uint(_u)          => unimplemented!(),\n             const_eval::ConstVal::Str(ref _s)       => unimplemented!(),\n             const_eval::ConstVal::ByteStr(ref _bs)  => unimplemented!(),\n-            const_eval::ConstVal::Bool(b)           => Value::Bool(b),\n+            const_eval::ConstVal::Bool(b)           => unimplemented!(),\n             const_eval::ConstVal::Struct(_node_id)  => unimplemented!(),\n             const_eval::ConstVal::Tuple(_node_id)   => unimplemented!(),\n             const_eval::ConstVal::Function(_def_id) => unimplemented!(),\n@@ -380,19 +495,19 @@ impl<'a, 'tcx> Interpreter<'a, 'tcx> {\n         }\n     }\n \n-    fn read_lvalue(&self, lvalue: &mir::Lvalue) -> Value {\n-        self.read_pointer(self.eval_lvalue(lvalue))\n-    }\n+    // fn read_lvalue(&self, lvalue: &mir::Lvalue) -> Value {\n+    //     self.read_pointer(self.lvalue_to_ptr(lvalue))\n+    // }\n \n     fn read_pointer(&self, p: Pointer) -> Value {\n-        match p {\n-            Pointer::Stack(offset) => self.value_stack[offset].clone(),\n-        }\n+        self.memory.value(p.alloc_id).unwrap().clone()\n     }\n \n     fn write_pointer(&mut self, p: Pointer, val: Value) {\n-        match p {\n-            Pointer::Stack(offset) => self.value_stack[offset] = val,\n+        // TODO(tsion): Remove panics.\n+        let alloc = self.memory.value_mut(p.alloc_id).unwrap();\n+        for (i, byte) in val.bytes.into_iter().enumerate() {\n+            alloc.bytes[p.offset + i] = byte;\n         }\n     }\n }\n@@ -406,10 +521,20 @@ pub fn interpret_start_points<'tcx>(tcx: &ty::ctxt<'tcx>, mir_map: &MirMap<'tcx>\n                 println!(\"Interpreting: {}\", item.name);\n \n                 let mut interpreter = Interpreter::new(tcx, mir_map);\n-                let return_ptr = Pointer::Stack(0);\n-                interpreter.call(mir, &[], Some(return_ptr));\n+                let return_ptr = match mir.return_ty {\n+                    ty::FnOutput::FnConverging(ty) => {\n+                        let repr = Repr::from_ty(ty);\n+                        Some(Pointer {\n+                            alloc_id: interpreter.memory.allocate(repr.size()),\n+                            offset: 0,\n+                            repr: repr,\n+                        })\n+                    }\n+                    ty::FnOutput::FnDiverging => None,\n+                };\n+                interpreter.call(mir, &[], return_ptr.clone());\n \n-                let val_str = format!(\"{:?}\", interpreter.read_pointer(return_ptr));\n+                let val_str = format!(\"{:?}\", interpreter.read_pointer(return_ptr.unwrap()));\n                 if !check_expected(&val_str, attr) {\n                     println!(\"=> {}\\n\", val_str);\n                 }"}, {"sha": "c7be3a0340cb9eb6a960b49ff8191bd5fae1a007", "filename": "src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2776f55d0cb961ae9fef2a70917381baccdfa935/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2776f55d0cb961ae9fef2a70917381baccdfa935/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=2776f55d0cb961ae9fef2a70917381baccdfa935", "patch": "@@ -1,5 +1,6 @@\n #![feature(rustc_private)]\n \n+extern crate byteorder;\n extern crate rustc;\n extern crate rustc_mir;\n extern crate syntax;"}, {"sha": "228aec8ca9d756eddee806c47b59824eaa7100df", "filename": "test/new_values.rs", "status": "added", "additions": 176, "deletions": 0, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/2776f55d0cb961ae9fef2a70917381baccdfa935/test%2Fnew_values.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2776f55d0cb961ae9fef2a70917381baccdfa935/test%2Fnew_values.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/test%2Fnew_values.rs?ref=2776f55d0cb961ae9fef2a70917381baccdfa935", "patch": "@@ -0,0 +1,176 @@\n+#![feature(custom_attribute)]\n+#![allow(dead_code, unused_attributes)]\n+\n+#[miri_run(expected = \"Int(1)\")]\n+fn ret() -> i32 {\n+    1\n+}\n+\n+// #[miri_run(expected = \"Int(-1)\")]\n+// fn neg() -> i32 {\n+//     -1\n+// }\n+\n+#[miri_run(expected = \"Int(3)\")]\n+fn add() -> i32 {\n+    1 + 2\n+}\n+\n+// #[miri_run(expected = \"Int(3)\")]\n+// fn indirect_add() -> i32 {\n+//     let x = 1;\n+//     let y = 2;\n+//     x + y\n+// }\n+\n+// #[miri_run(expected = \"Int(25)\")]\n+// fn arith() -> i32 {\n+//     3*3 + 4*4\n+// }\n+\n+// #[miri_run(expected = \"Int(0)\")]\n+// fn if_false() -> i32 {\n+//     if false { 1 } else { 0 }\n+// }\n+\n+// #[miri_run(expected = \"Int(1)\")]\n+// fn if_true() -> i32 {\n+//     if true { 1 } else { 0 }\n+// }\n+\n+// #[miri_run(expected = \"Int(2)\")]\n+// fn call() -> i32 {\n+//     fn increment(x: i32) -> i32 {\n+//         x + 1\n+//     }\n+\n+//     increment(1)\n+// }\n+\n+// // #[miri_run(expected = \"Int(3628800)\")]\n+// // fn factorial_loop() -> i32 {\n+// //     let mut product = 1;\n+// //     let mut i = 1;\n+\n+// //     while i <= 10 {\n+// //         product *= i;\n+// //         i += 1;\n+// //     }\n+\n+// //     product\n+// // }\n+\n+// #[miri_run(expected = \"Int(3628800)\")]\n+// fn factorial_recursive() -> i32 {\n+//     fn fact(n: i32) -> i32 {\n+//         if n == 0 {\n+//             1\n+//         } else {\n+//             n * fact(n - 1)\n+//         }\n+//     }\n+\n+//     fact(10)\n+// }\n+\n+// #[miri_run(expected = \"Int(1)\")]\n+// fn match_bool() -> i32 {\n+//     let b = true;\n+//     match b {\n+//         true => 1,\n+//         false => 0,\n+//     }\n+// }\n+\n+// #[miri_run(expected = \"Int(20)\")]\n+// fn match_int() -> i32 {\n+//     let n = 2;\n+//     match n {\n+//         0 => 0,\n+//         1 => 10,\n+//         2 => 20,\n+//         3 => 30,\n+//         _ => 100,\n+//     }\n+// }\n+\n+// #[miri_run(expected = \"Int(1)\")]\n+// fn one_line_ref() -> i32 {\n+//     *&1\n+// }\n+\n+// #[miri_run(expected = \"Int(1)\")]\n+// fn basic_ref() -> i32 {\n+//     let x = &1;\n+//     *x\n+// }\n+\n+// #[miri_run(expected = \"Int(3)\")]\n+// fn basic_ref_mut() -> i32 {\n+//     let x = &mut 1;\n+//     *x += 2;\n+//     *x\n+// }\n+\n+// // #[miri_run(expected = \"Int(3)\")]\n+// // fn basic_ref_mut_var() -> i32 {\n+// //     let mut a = 1;\n+// //     {\n+// //         let x = &mut a;\n+// //         *x += 2;\n+// //     }\n+// //     a\n+// // }\n+\n+// #[miri_run(expected = \"Int(4)\")]\n+// fn match_int_range() -> i32 {\n+//     let n = 42;\n+//     match n {\n+//         0...9 => 0,\n+//         10...19 => 1,\n+//         20...29 => 2,\n+//         30...39 => 3,\n+//         40...49 => 4,\n+//         _ => 5,\n+//     }\n+// }\n+\n+// enum MyOption<T> {\n+//     Some { data: T },\n+//     None,\n+// }\n+\n+// #[miri_run(expected = \"Int(13)\")]\n+// fn match_my_opt_some() -> i32 {\n+//     let x = MyOption::Some { data: 13 };\n+//     match x {\n+//         MyOption::Some { data } => data,\n+//         MyOption::None => 42,\n+//     }\n+// }\n+\n+// #[miri_run(expected = \"Int(42)\")]\n+// fn match_my_opt_none() -> i32 {\n+//     let x = MyOption::None;\n+//     match x {\n+//         MyOption::Some { data } => data,\n+//         MyOption::None => 42,\n+//     }\n+// }\n+\n+// #[miri_run(expected = \"Int(13)\")]\n+// fn match_opt_some() -> i32 {\n+//     let x = Some(13);\n+//     match x {\n+//         Some(data)  => data,\n+//         None => 42,\n+//     }\n+// }\n+\n+// /// Test calling a very simple function from the standard library.\n+// #[miri_run(expected = \"Int(1)\")]\n+// fn cross_crate_fn_call() -> i32 {\n+//     if 1i32.is_positive() { 1 } else { 0 }\n+// }\n+\n+// fn main() {}"}]}