{"sha": "8dc8151b495b3237f06821a0b6fd6f0c89b5d438", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhkYzgxNTFiNDk1YjMyMzdmMDY4MjFhMGI2ZmQ2ZjBjODliNWQ0Mzg=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-08-14T22:27:57Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-08-17T19:21:44Z"}, "message": "pull out call to `record` for impl items", "tree": {"sha": "826daae90640d664022fa502d66fb1507e10bfd1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/826daae90640d664022fa502d66fb1507e10bfd1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8dc8151b495b3237f06821a0b6fd6f0c89b5d438", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8dc8151b495b3237f06821a0b6fd6f0c89b5d438", "html_url": "https://github.com/rust-lang/rust/commit/8dc8151b495b3237f06821a0b6fd6f0c89b5d438", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8dc8151b495b3237f06821a0b6fd6f0c89b5d438/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9afcd7724694e2078ffc9b6c6b73b178ebf3e379", "url": "https://api.github.com/repos/rust-lang/rust/commits/9afcd7724694e2078ffc9b6c6b73b178ebf3e379", "html_url": "https://github.com/rust-lang/rust/commit/9afcd7724694e2078ffc9b6c6b73b178ebf3e379"}], "stats": {"total": 202, "additions": 103, "deletions": 99}, "files": [{"sha": "e662c444413e78bfa762cadf664819435cdaf12f", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 103, "deletions": 99, "changes": 202, "blob_url": "https://github.com/rust-lang/rust/blob/8dc8151b495b3237f06821a0b6fd6f0c89b5d438/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8dc8151b495b3237f06821a0b6fd6f0c89b5d438/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=8dc8151b495b3237f06821a0b6fd6f0c89b5d438", "patch": "@@ -530,7 +530,31 @@ impl<'a, 'tcx, 'encoder> ItemContentBuilder<'a, 'tcx, 'encoder> {\n     }\n }\n \n-impl<'a, 'tcx, 'encoder> IndexBuilder<'a, 'tcx, 'encoder> {\n+impl<'a, 'tcx, 'encoder> ItemContentBuilder<'a, 'tcx, 'encoder> {\n+    fn encode_info_for_impl_item(&mut self,\n+                                 impl_id: NodeId,\n+                                 impl_item_def_id: DefId,\n+                                 ast_item: Option<&hir::ImplItem>) {\n+        match self.ecx.tcx.impl_or_trait_item(impl_item_def_id) {\n+            ty::ConstTraitItem(ref associated_const) => {\n+                self.encode_info_for_associated_const(&associated_const,\n+                                                      impl_id,\n+                                                      ast_item)\n+            }\n+            ty::MethodTraitItem(ref method_type) => {\n+                self.encode_info_for_method(&method_type,\n+                                            false,\n+                                            impl_id,\n+                                            ast_item)\n+            }\n+            ty::TypeTraitItem(ref associated_type) => {\n+                self.encode_info_for_associated_type(&associated_type,\n+                                                     impl_id,\n+                                                     ast_item)\n+            }\n+        }\n+    }\n+\n     fn encode_info_for_associated_const(&mut self,\n                                         associated_const: &ty::AssociatedConst,\n                                         parent_id: NodeId,\n@@ -540,32 +564,30 @@ impl<'a, 'tcx, 'encoder> IndexBuilder<'a, 'tcx, 'encoder> {\n                associated_const.def_id,\n                associated_const.name);\n \n-        self.record(associated_const.def_id, |this| {\n-            encode_def_id_and_key(ecx, this.rbml_w, associated_const.def_id);\n-            encode_name(this.rbml_w, associated_const.name);\n-            this.encode_visibility(associated_const.vis);\n-            encode_family(this.rbml_w, 'C');\n+        encode_def_id_and_key(ecx, self.rbml_w, associated_const.def_id);\n+        encode_name(self.rbml_w, associated_const.name);\n+        self.encode_visibility(associated_const.vis);\n+        encode_family(self.rbml_w, 'C');\n \n-            this.encode_parent_item(ecx.tcx.map.local_def_id(parent_id));\n-            encode_item_sort(this.rbml_w, 'C');\n-\n-            this.encode_bounds_and_type_for_item(ecx.local_id(associated_const.def_id));\n-\n-            let stab = ecx.tcx.lookup_stability(associated_const.def_id);\n-            let depr = ecx.tcx.lookup_deprecation(associated_const.def_id);\n-            encode_stability(this.rbml_w, stab);\n-            encode_deprecation(this.rbml_w, depr);\n-\n-            if let Some(ii) = impl_item_opt {\n-                encode_attributes(this.rbml_w, &ii.attrs);\n-                encode_defaultness(this.rbml_w, ii.defaultness);\n-                encode_inlined_item(ecx,\n-                                    this.rbml_w,\n-                                    InlinedItemRef::ImplItem(ecx.tcx.map.local_def_id(parent_id),\n-                                                             ii));\n-                this.encode_mir(ii.id);\n-            }\n-        });\n+        self.encode_parent_item(ecx.tcx.map.local_def_id(parent_id));\n+        encode_item_sort(self.rbml_w, 'C');\n+\n+        self.encode_bounds_and_type_for_item(ecx.local_id(associated_const.def_id));\n+\n+        let stab = ecx.tcx.lookup_stability(associated_const.def_id);\n+        let depr = ecx.tcx.lookup_deprecation(associated_const.def_id);\n+        encode_stability(self.rbml_w, stab);\n+        encode_deprecation(self.rbml_w, depr);\n+\n+        if let Some(ii) = impl_item_opt {\n+            encode_attributes(self.rbml_w, &ii.attrs);\n+            encode_defaultness(self.rbml_w, ii.defaultness);\n+            encode_inlined_item(ecx,\n+                                self.rbml_w,\n+                                InlinedItemRef::ImplItem(ecx.tcx.map.local_def_id(parent_id),\n+                                                         ii));\n+            self.encode_mir(ii.id);\n+        }\n     }\n \n     fn encode_info_for_method(&mut self,\n@@ -577,40 +599,38 @@ impl<'a, 'tcx, 'encoder> IndexBuilder<'a, 'tcx, 'encoder> {\n \n         debug!(\"encode_info_for_method: {:?} {:?}\", m.def_id,\n                m.name);\n-        self.record(m.def_id, |this| {\n-            this.encode_method_ty_fields(m);\n-            this.encode_parent_item(ecx.tcx.map.local_def_id(parent_id));\n-            encode_item_sort(this.rbml_w, 'r');\n-\n-            let stab = ecx.tcx.lookup_stability(m.def_id);\n-            let depr = ecx.tcx.lookup_deprecation(m.def_id);\n-            encode_stability(this.rbml_w, stab);\n-            encode_deprecation(this.rbml_w, depr);\n-\n-            let m_node_id = ecx.local_id(m.def_id);\n-            this.encode_bounds_and_type_for_item(m_node_id);\n-\n-            if let Some(impl_item) = impl_item_opt {\n-                if let hir::ImplItemKind::Method(ref sig, _) = impl_item.node {\n-                    encode_attributes(this.rbml_w, &impl_item.attrs);\n-                    let generics = ecx.tcx.lookup_generics(m.def_id);\n-                    let types = generics.parent_types as usize + generics.types.len();\n-                    let needs_inline = types > 0 || is_default_impl ||\n-                        attr::requests_inline(&impl_item.attrs);\n-                    if needs_inline || sig.constness == hir::Constness::Const {\n-                        encode_inlined_item(\n-                            ecx,\n-                            this.rbml_w,\n-                            InlinedItemRef::ImplItem(ecx.tcx.map.local_def_id(parent_id),\n-                                                     impl_item));\n-                        this.encode_mir(impl_item.id);\n-                    }\n-                    encode_constness(this.rbml_w, sig.constness);\n-                    encode_defaultness(this.rbml_w, impl_item.defaultness);\n-                    this.encode_method_argument_names(&sig.decl);\n+        self.encode_method_ty_fields(m);\n+        self.encode_parent_item(ecx.tcx.map.local_def_id(parent_id));\n+        encode_item_sort(self.rbml_w, 'r');\n+\n+        let stab = ecx.tcx.lookup_stability(m.def_id);\n+        let depr = ecx.tcx.lookup_deprecation(m.def_id);\n+        encode_stability(self.rbml_w, stab);\n+        encode_deprecation(self.rbml_w, depr);\n+\n+        let m_node_id = ecx.local_id(m.def_id);\n+        self.encode_bounds_and_type_for_item(m_node_id);\n+\n+        if let Some(impl_item) = impl_item_opt {\n+            if let hir::ImplItemKind::Method(ref sig, _) = impl_item.node {\n+                encode_attributes(self.rbml_w, &impl_item.attrs);\n+                let generics = ecx.tcx.lookup_generics(m.def_id);\n+                let types = generics.parent_types as usize + generics.types.len();\n+                let needs_inline = types > 0 || is_default_impl ||\n+                    attr::requests_inline(&impl_item.attrs);\n+                if needs_inline || sig.constness == hir::Constness::Const {\n+                    encode_inlined_item(\n+                        ecx,\n+                        self.rbml_w,\n+                        InlinedItemRef::ImplItem(ecx.tcx.map.local_def_id(parent_id),\n+                                                 impl_item));\n+                    self.encode_mir(impl_item.id);\n                 }\n+                encode_constness(self.rbml_w, sig.constness);\n+                encode_defaultness(self.rbml_w, impl_item.defaultness);\n+                self.encode_method_argument_names(&sig.decl);\n             }\n-        });\n+        }\n     }\n \n     fn encode_info_for_associated_type(&mut self,\n@@ -622,32 +642,30 @@ impl<'a, 'tcx, 'encoder> IndexBuilder<'a, 'tcx, 'encoder> {\n                associated_type.def_id,\n                associated_type.name);\n \n-        self.record(associated_type.def_id, |this| {\n-            encode_def_id_and_key(ecx, this.rbml_w, associated_type.def_id);\n-            encode_name(this.rbml_w, associated_type.name);\n-            this.encode_visibility(associated_type.vis);\n-            encode_family(this.rbml_w, 'y');\n-            this.encode_parent_item(ecx.tcx.map.local_def_id(parent_id));\n-            encode_item_sort(this.rbml_w, 't');\n+        encode_def_id_and_key(ecx, self.rbml_w, associated_type.def_id);\n+        encode_name(self.rbml_w, associated_type.name);\n+        self.encode_visibility(associated_type.vis);\n+        encode_family(self.rbml_w, 'y');\n+        self.encode_parent_item(ecx.tcx.map.local_def_id(parent_id));\n+        encode_item_sort(self.rbml_w, 't');\n \n-            let stab = ecx.tcx.lookup_stability(associated_type.def_id);\n-            let depr = ecx.tcx.lookup_deprecation(associated_type.def_id);\n-            encode_stability(this.rbml_w, stab);\n-            encode_deprecation(this.rbml_w, depr);\n+        let stab = ecx.tcx.lookup_stability(associated_type.def_id);\n+        let depr = ecx.tcx.lookup_deprecation(associated_type.def_id);\n+        encode_stability(self.rbml_w, stab);\n+        encode_deprecation(self.rbml_w, depr);\n \n-            if let Some(ii) = impl_item_opt {\n-                encode_attributes(this.rbml_w, &ii.attrs);\n-                encode_defaultness(this.rbml_w, ii.defaultness);\n-            } else {\n-                // TODO this looks bogus and unnecessary\n-                this.encode_predicates(&ecx.tcx.lookup_predicates(associated_type.def_id),\n-                                       tag_item_generics);\n-            }\n+        if let Some(ii) = impl_item_opt {\n+            encode_attributes(self.rbml_w, &ii.attrs);\n+            encode_defaultness(self.rbml_w, ii.defaultness);\n+        } else {\n+            // TODO this looks bogus and unnecessary\n+            self.encode_predicates(&ecx.tcx.lookup_predicates(associated_type.def_id),\n+                                   tag_item_generics);\n+        }\n \n-            if let Some(ty) = associated_type.ty {\n-                this.encode_type(ty);\n-            }\n-        });\n+        if let Some(ty) = associated_type.ty {\n+            self.encode_type(ty);\n+        }\n     }\n }\n \n@@ -1116,24 +1134,10 @@ impl<'a, 'tcx, 'encoder> IndexBuilder<'a, 'tcx, 'encoder> {\n                 None\n             };\n \n-            match self.ecx.tcx.impl_or_trait_item(trait_item_def_id.def_id()) {\n-                ty::ConstTraitItem(ref associated_const) => {\n-                    self.encode_info_for_associated_const(&associated_const,\n-                                                          impl_id,\n-                                                          ast_item)\n-                }\n-                ty::MethodTraitItem(ref method_type) => {\n-                    self.encode_info_for_method(&method_type,\n-                                                false,\n-                                                impl_id,\n-                                                ast_item)\n-                }\n-                ty::TypeTraitItem(ref associated_type) => {\n-                    self.encode_info_for_associated_type(&associated_type,\n-                                                         impl_id,\n-                                                         ast_item)\n-                }\n-            }\n+            let trait_item_def_id = trait_item_def_id.def_id();\n+            self.record(trait_item_def_id, |this| {\n+                this.encode_info_for_impl_item(impl_id, trait_item_def_id, ast_item)\n+            });\n         }\n     }\n "}]}