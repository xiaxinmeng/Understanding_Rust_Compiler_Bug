{"sha": "5a61d88fa11e649fbd231a523606f5a5c33ce916", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVhNjFkODhmYTExZTY0OWZiZDIzMWE1MjM2MDZmNWE1YzMzY2U5MTY=", "commit": {"author": {"name": "sinkuu", "email": "sinkuu@sinkuu.xyz", "date": "2017-10-11T03:10:10Z"}, "committer": {"name": "sinkuu", "email": "sinkuu@sinkuu.xyz", "date": "2017-10-11T13:17:00Z"}, "message": "Apply suggestions", "tree": {"sha": "5e0970720d2c048a7e0efd4bd6d8678116291807", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5e0970720d2c048a7e0efd4bd6d8678116291807"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5a61d88fa11e649fbd231a523606f5a5c33ce916", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5a61d88fa11e649fbd231a523606f5a5c33ce916", "html_url": "https://github.com/rust-lang/rust/commit/5a61d88fa11e649fbd231a523606f5a5c33ce916", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5a61d88fa11e649fbd231a523606f5a5c33ce916/comments", "author": {"login": "sinkuu", "id": 7091080, "node_id": "MDQ6VXNlcjcwOTEwODA=", "avatar_url": "https://avatars.githubusercontent.com/u/7091080?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sinkuu", "html_url": "https://github.com/sinkuu", "followers_url": "https://api.github.com/users/sinkuu/followers", "following_url": "https://api.github.com/users/sinkuu/following{/other_user}", "gists_url": "https://api.github.com/users/sinkuu/gists{/gist_id}", "starred_url": "https://api.github.com/users/sinkuu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sinkuu/subscriptions", "organizations_url": "https://api.github.com/users/sinkuu/orgs", "repos_url": "https://api.github.com/users/sinkuu/repos", "events_url": "https://api.github.com/users/sinkuu/events{/privacy}", "received_events_url": "https://api.github.com/users/sinkuu/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sinkuu", "id": 7091080, "node_id": "MDQ6VXNlcjcwOTEwODA=", "avatar_url": "https://avatars.githubusercontent.com/u/7091080?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sinkuu", "html_url": "https://github.com/sinkuu", "followers_url": "https://api.github.com/users/sinkuu/followers", "following_url": "https://api.github.com/users/sinkuu/following{/other_user}", "gists_url": "https://api.github.com/users/sinkuu/gists{/gist_id}", "starred_url": "https://api.github.com/users/sinkuu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sinkuu/subscriptions", "organizations_url": "https://api.github.com/users/sinkuu/orgs", "repos_url": "https://api.github.com/users/sinkuu/repos", "events_url": "https://api.github.com/users/sinkuu/events{/privacy}", "received_events_url": "https://api.github.com/users/sinkuu/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "159cc8413cf0f228a5e590a1d3a88f84c6e6cc4a", "url": "https://api.github.com/repos/rust-lang/rust/commits/159cc8413cf0f228a5e590a1d3a88f84c6e6cc4a", "html_url": "https://github.com/rust-lang/rust/commit/159cc8413cf0f228a5e590a1d3a88f84c6e6cc4a"}], "stats": {"total": 378, "additions": 197, "deletions": 181}, "files": [{"sha": "6d2fee6a8d968052778b60fe25143d7c598cb971", "filename": "clippy_lints/src/types.rs", "status": "modified", "additions": 111, "deletions": 122, "changes": 233, "blob_url": "https://github.com/rust-lang/rust/blob/5a61d88fa11e649fbd231a523606f5a5c33ce916/clippy_lints%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a61d88fa11e649fbd231a523606f5a5c33ce916/clippy_lints%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes.rs?ref=5a61d88fa11e649fbd231a523606f5a5c33ce916", "patch": "@@ -3,17 +3,18 @@ use rustc::hir;\n use rustc::hir::*;\n use rustc::hir::intravisit::{walk_body, walk_expr, walk_ty, FnKind, NestedVisitorMap, Visitor};\n use rustc::lint::*;\n-use rustc::ty::{self, Ty, TyCtxt};\n+use rustc::ty::{self, Ty, TyCtxt, TypeckTables};\n use rustc::ty::subst::Substs;\n use std::cmp::Ordering;\n use std::collections::BTreeMap;\n use std::borrow::Cow;\n use syntax::ast::{FloatTy, IntTy, UintTy};\n use syntax::attr::IntType;\n use syntax::codemap::Span;\n+use syntax::errors::DiagnosticBuilder;\n use utils::{comparisons, higher, in_external_macro, in_macro, last_path_segment, match_def_path, match_path,\n-            opt_def_id, same_tys, snippet, snippet_opt, span_help_and_lint, span_lint, span_lint_and_sugg,\n-            span_lint_and_then, type_size};\n+            multispan_sugg, opt_def_id, snippet, snippet_opt, span_help_and_lint, span_lint,\n+            span_lint_and_sugg, span_lint_and_then, type_size, same_tys};\n use utils::paths;\n \n /// Handles all the linting of funky types\n@@ -1484,140 +1485,129 @@ impl LintPass for ImplicitHasher {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ImplicitHasher {\n     #[allow(cast_possible_truncation)]\n     fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx Item) {\n-        if let ItemImpl(_, _, _, ref generics, _, ref ty, ref items) = item.node {\n-            let mut vis = ImplicitHasherTypeVisitor::new(cx);\n-            vis.visit_ty(ty);\n-\n-            for target in vis.found {\n-                let generics_snip = snippet(cx, generics.span, \"\");\n-                let generics_snip_trimmed = if generics_snip.len() == 0 {\n-                    \"\"\n-                } else {\n-                    // trim `<` `>`\n-                    &generics_snip[1..generics_snip.len() - 1]\n-                };\n-                let generics_span = generics.span.substitute_dummy({\n-                    let pos = snippet_opt(cx, item.span.until(target.span()))\n-                        .and_then(|snip| {\n-                            Some(item.span.lo() + ::syntax_pos::BytePos(snip.find(\"impl\")? as u32 + 4))\n-                        })\n-                        .expect(\"failed to create span for type arguments\");\n-                    Span::new(pos, pos, item.span.data().ctxt)\n-                });\n-\n-                let mut vis = ImplicitHasherConstructorVisitor::new(cx, target.clone());\n-                for item in items.iter().map(|item| cx.tcx.hir.impl_item(item.id)) {\n-                    vis.visit_impl_item(item);\n-                }\n+        use syntax_pos::BytePos;\n+\n+        fn suggestion<'a, 'tcx>(\n+            cx: &LateContext<'a, 'tcx>,\n+            db: &mut DiagnosticBuilder,\n+            generics_span: Span,\n+            generics_suggestion_span: Span,\n+            target: &ImplicitHasherType,\n+            vis: ImplicitHasherConstructorVisitor,\n+        ) {\n+            let generics_snip = snippet(cx, generics_span, \"\");\n+            // trim `<` `>`\n+            let generics_snip = if generics_snip.is_empty() {\n+                \"\"\n+            } else {\n+                &generics_snip[1..generics_snip.len() - 1]\n+            };\n \n-                span_lint_and_then(\n-                    cx,\n-                    IMPLICIT_HASHER,\n-                    target.span(),\n-                    &format!(\"impl for `{}` should be generarized over different hashers\", target.type_name()),\n-                    move |db| {\n-                        db.span_suggestion(\n-                            generics_span,\n-                            \"consider adding a type parameter\",\n-                            format!(\n-                                \"<{}{}S: ::std::hash::BuildHasher{}>\",\n-                                generics_snip_trimmed,\n-                                if generics_snip_trimmed.is_empty() {\n-                                    \"\"\n-                                } else {\n-                                    \", \"\n-                                },\n-                                if vis.suggestions.is_empty() {\n-                                    \"\"\n-                                } else {\n-                                    // request users to add `Default` bound so that generic constructors can be used\n-                                    \" + Default\"\n-                                },\n-                            ),\n-                        );\n+            db.span_suggestion(\n+                generics_suggestion_span,\n+                \"consider adding a type parameter\",\n+                format!(\n+                    \"<{}{}S: ::std::hash::BuildHasher{}>\",\n+                    generics_snip,\n+                    if generics_snip.is_empty() { \"\" } else { \", \" },\n+                    if vis.suggestions.is_empty() {\n+                        \"\"\n+                    } else {\n+                        // request users to add `Default` bound so that generic constructors can be used\n+                        \" + Default\"\n+                    },\n+                ),\n+            );\n \n-                        db.span_suggestion(\n-                            target.span(),\n-                            \"...and change the type to\",\n-                            format!(\"{}<{}, S>\", target.type_name(), target.type_arguments(),),\n-                        );\n+            db.span_suggestion(\n+                target.span(),\n+                \"...and change the type to\",\n+                format!(\"{}<{}, S>\", target.type_name(), target.type_arguments(),),\n+            );\n \n-                        for (span, sugg) in vis.suggestions {\n-                            db.span_suggestion(span, \"...and use generic constructor here\", sugg);\n-                        }\n-                    },\n-                );\n+            if !vis.suggestions.is_empty() {\n+                multispan_sugg(db, \"...and use generic constructor\".into(), vis.suggestions);\n             }\n+            // for (span, sugg) in vis.suggestions {\n+            //     db.span_suggestion(span, \"...and use generic constructor here\", sugg);\n+            // }\n         }\n \n-        if let ItemFn(ref decl, .., ref generics, body) = item.node {\n-            if item.vis != Public {\n-                return;\n-            }\n-\n-            for ty in &decl.inputs {\n+        match item.node {\n+            ItemImpl(_, _, _, ref generics, _, ref ty, ref items) => {\n                 let mut vis = ImplicitHasherTypeVisitor::new(cx);\n                 vis.visit_ty(ty);\n \n-                for target in vis.found {\n-                    let generics_snip = snippet(cx, generics.span, \"\");\n-                    let generics_snip_trimmed = if generics_snip.len() == 0 {\n-                        \"\"\n-                    } else {\n-                        // trim `<` `>`\n-                        &generics_snip[1..generics_snip.len() - 1]\n-                    };\n-                    let generics_span = generics.span.substitute_dummy({\n-                        let pos = snippet_opt(cx, item.span.until(ty.span))\n-                            .and_then(|snip| {\n-                                let i = snip.find(\"fn\")?;\n-                                Some(item.span.lo() + ::syntax_pos::BytePos(i as u32 + (&snip[i..]).find('(')? as u32))\n-                            })\n-                            .expect(\"failed to create span for type parameters\");\n+                for target in &vis.found {\n+                    let generics_suggestion_span = generics.span.substitute_dummy({\n+                        let pos = snippet_opt(cx, item.span.until(target.span()))\n+                            .and_then(|snip| Some(item.span.lo() + BytePos(snip.find(\"impl\")? as u32 + 4)))\n+                            .expect(\"failed to create span for type arguments\");\n                         Span::new(pos, pos, item.span.data().ctxt)\n                     });\n \n-                    let mut ctr_vis = ImplicitHasherConstructorVisitor::new(cx, target.clone());\n-                    ctr_vis.visit_body(cx.tcx.hir.body(body));\n-                    assert!(ctr_vis.suggestions.is_empty());\n+                    let mut ctr_vis = ImplicitHasherConstructorVisitor::new(cx, target);\n+                    for item in items.iter().map(|item| cx.tcx.hir.impl_item(item.id)) {\n+                        ctr_vis.visit_impl_item(item);\n+                    }\n \n                     span_lint_and_then(\n                         cx,\n                         IMPLICIT_HASHER,\n                         target.span(),\n-                        &format!(\n-                            \"parameter of type `{}` should be generarized over different hashers\",\n-                            target.type_name()\n-                        ),\n+                        &format!(\"impl for `{}` should be generarized over different hashers\", target.type_name()),\n                         move |db| {\n-                            db.span_suggestion(\n-                                generics_span,\n-                                \"consider adding a type parameter\",\n-                                format!(\n-                                    \"<{}{}S: ::std::hash::BuildHasher>\",\n-                                    generics_snip_trimmed,\n-                                    if generics_snip_trimmed.is_empty() {\n-                                        \"\"\n-                                    } else {\n-                                        \", \"\n-                                    },\n-                                ),\n-                            );\n-\n-                            db.span_suggestion(\n-                                target.span(),\n-                                \"...and change the type to\",\n-                                format!(\"{}<{}, S>\", target.type_name(), target.type_arguments(),),\n-                            );\n+                            suggestion(cx, db, generics.span, generics_suggestion_span, target, ctr_vis);\n                         },\n                     );\n                 }\n-            }\n+            },\n+            ItemFn(ref decl, .., ref generics, body_id) => {\n+                if item.vis != Public {\n+                    return;\n+                }\n+\n+                let body = cx.tcx.hir.body(body_id);\n+\n+                for ty in &decl.inputs {\n+                    let mut vis = ImplicitHasherTypeVisitor::new(cx);\n+                    vis.visit_ty(ty);\n+\n+                    for target in &vis.found {\n+                        let generics_suggestion_span = generics.span.substitute_dummy({\n+                            let pos = snippet_opt(cx, item.span.until(body.arguments[0].pat.span))\n+                                .and_then(|snip| {\n+                                    let i = snip.find(\"fn\")?;\n+                                    Some(item.span.lo() + BytePos((i + (&snip[i..]).find('(')?) as u32))\n+                                })\n+                                .expect(\"failed to create span for type parameters\");\n+                            Span::new(pos, pos, item.span.data().ctxt)\n+                        });\n+\n+                        let mut ctr_vis = ImplicitHasherConstructorVisitor::new(cx, target);\n+                        ctr_vis.visit_body(body);\n+                        assert!(ctr_vis.suggestions.is_empty());\n+\n+                        span_lint_and_then(\n+                            cx,\n+                            IMPLICIT_HASHER,\n+                            target.span(),\n+                            &format!(\n+                                \"parameter of type `{}` should be generarized over different hashers\",\n+                                target.type_name()\n+                            ),\n+                            move |db| {\n+                                suggestion(cx, db, generics.span, generics_suggestion_span, target, ctr_vis);\n+                            },\n+                        );\n+                    }\n+                }\n+            },\n+            _ => {},\n         }\n     }\n }\n \n-#[derive(Clone)]\n enum ImplicitHasherType<'tcx> {\n     HashMap(Span, Ty<'tcx>, Cow<'static, str>, Cow<'static, str>),\n     HashSet(Span, Ty<'tcx>, Cow<'static, str>),\n@@ -1702,38 +1692,37 @@ impl<'a, 'tcx: 'a> Visitor<'tcx> for ImplicitHasherTypeVisitor<'a, 'tcx> {\n }\n \n /// Looks for default-hasher-dependent constructors like `HashMap::new`.\n-struct ImplicitHasherConstructorVisitor<'a, 'tcx: 'a> {\n+struct ImplicitHasherConstructorVisitor<'a, 'b, 'tcx: 'a + 'b> {\n     cx: &'a LateContext<'a, 'tcx>,\n-    body: Option<BodyId>,\n-    target: ImplicitHasherType<'tcx>,\n+    body: &'a TypeckTables<'tcx>,\n+    target: &'b ImplicitHasherType<'tcx>,\n     suggestions: BTreeMap<Span, String>,\n }\n \n-impl<'a, 'tcx: 'a> ImplicitHasherConstructorVisitor<'a, 'tcx> {\n-    fn new(cx: &'a LateContext<'a, 'tcx>, target: ImplicitHasherType<'tcx>) -> Self {\n+impl<'a, 'b, 'tcx: 'a + 'b> ImplicitHasherConstructorVisitor<'a, 'b, 'tcx> {\n+    fn new(cx: &'a LateContext<'a, 'tcx>, target: &'b ImplicitHasherType<'tcx>) -> Self {\n         Self {\n             cx,\n-            body: None,\n+            body: cx.tables,\n             target,\n             suggestions: BTreeMap::new(),\n         }\n     }\n }\n \n-impl<'a, 'tcx: 'a> Visitor<'tcx> for ImplicitHasherConstructorVisitor<'a, 'tcx> {\n+impl<'a, 'b, 'tcx: 'a + 'b> Visitor<'tcx> for ImplicitHasherConstructorVisitor<'a, 'b, 'tcx> {\n     fn visit_body(&mut self, body: &'tcx Body) {\n-        self.body = Some(body.id());\n+        self.body = self.cx.tcx.body_tables(body.id());\n         walk_body(self, body);\n     }\n \n     fn visit_expr(&mut self, e: &'tcx Expr) {\n         if_let_chain!{[\n-            let Some(body) = self.body,\n             let ExprCall(ref fun, ref args) = e.node,\n             let ExprPath(QPath::TypeRelative(ref ty, ref method)) = fun.node,\n             let TyPath(QPath::Resolved(None, ref ty_path)) = ty.node,\n         ], {\n-            if same_tys(self.cx, self.cx.tcx.body_tables(body).expr_ty(e), self.target.ty()) {\n+            if !same_tys(self.cx, self.target.ty(), self.body.expr_ty(e)) {\n                 return;\n             }\n "}, {"sha": "239370d9811fdfc6c7f2152833956b13d6ba3794", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5a61d88fa11e649fbd231a523606f5a5c33ce916/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a61d88fa11e649fbd231a523606f5a5c33ce916/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=5a61d88fa11e649fbd231a523606f5a5c33ce916", "patch": "@@ -664,7 +664,10 @@ pub fn span_lint_and_sugg<'a, 'tcx: 'a, T: LintContext<'tcx>>(\n /// appear once per\n /// replacement. In human-readable format though, it only appears once before\n /// the whole suggestion.\n-pub fn multispan_sugg(db: &mut DiagnosticBuilder, help_msg: String, sugg: Vec<(Span, String)>) {\n+pub fn multispan_sugg<I>(db: &mut DiagnosticBuilder, help_msg: String, sugg: I)\n+where\n+    I: IntoIterator<Item=(Span, String)>,\n+{\n     let sugg = rustc_errors::CodeSuggestion {\n         substitution_parts: sugg.into_iter()\n             .map(|(span, sub)| {"}, {"sha": "b6a498692702d69ed2f9b80c8ffc4218ed6eaa0d", "filename": "tests/ui/implicit_hasher.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5a61d88fa11e649fbd231a523606f5a5c33ce916/tests%2Fui%2Fimplicit_hasher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a61d88fa11e649fbd231a523606f5a5c33ce916/tests%2Fui%2Fimplicit_hasher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimplicit_hasher.rs?ref=5a61d88fa11e649fbd231a523606f5a5c33ce916", "patch": "@@ -65,4 +65,22 @@ impl<S: BuildHasher + Default> Foo<i64> for HashSet<String, S> {\n pub fn foo(_map: &mut HashMap<i32, i32>, _set: &mut HashSet<i32>) {\n }\n \n+macro_rules! gen {\n+    (impl) => {\n+        impl<K: Hash + Eq, V> Foo<u8> for HashMap<K, V> {\n+            fn make() -> (Self, Self) {\n+                (HashMap::new(), HashMap::with_capacity(10))\n+            }\n+        }\n+    };\n+\n+    (fn $name:ident) => {\n+        pub fn $name(_map: &mut HashMap<i32, i32>, _set: &mut HashSet<i32>) {\n+        }\n+    }\n+}\n+\n+gen!(impl);\n+gen!(fn bar);\n+\n fn main() {}"}, {"sha": "33788624b92cdccbd417916a5a4288178ec18796", "filename": "tests/ui/implicit_hasher.stderr", "status": "modified", "additions": 64, "deletions": 58, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/5a61d88fa11e649fbd231a523606f5a5c33ce916/tests%2Fui%2Fimplicit_hasher.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5a61d88fa11e649fbd231a523606f5a5c33ce916/tests%2Fui%2Fimplicit_hasher.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimplicit_hasher.stderr?ref=5a61d88fa11e649fbd231a523606f5a5c33ce916", "patch": "@@ -7,28 +7,12 @@ error: impl for `HashMap` should be generarized over different hashers\n    = note: `-D implicit-hasher` implied by `-D warnings`\n help: consider adding a type parameter\n    |\n-11 | impl<K: Hash + Eq, V, S: ::std::hash::BuildHasher + Default> Foo<i8> for HashMap<K, V> {\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+11 | impl<K: Hash + Eq, V, S: ::std::hash::BuildHasher> Foo<i8> for HashMap<K, V> {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n help: ...and change the type to\n    |\n 11 | impl<K: Hash + Eq, V> Foo<i8> for HashMap<K, V, S> {\n    |                                   ^^^^^^^^^^^^^^^^\n-help: ...and use generic constructor here\n-   |\n-14 |         let _: HashMap<i32, i32> = HashMap::default();\n-   |                                    ^^^^^^^^^^^^^^^^^^\n-help: ...and use generic constructor here\n-   |\n-15 |         let _: HashSet<i32> = HashSet::default();\n-   |                               ^^^^^^^^^^^^^^^^^^\n-help: ...and use generic constructor here\n-   |\n-17 |         (HashMap::default(), HashMap::with_capacity(10))\n-   |          ^^^^^^^^^^^^^^^^^^\n-help: ...and use generic constructor here\n-   |\n-17 |         (HashMap::new(), HashMap::with_capacity_and_hasher(10, Default::default()))\n-   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: impl for `HashMap` should be generarized over different hashers\n   --> $DIR/implicit_hasher.rs:20:36\n@@ -38,20 +22,12 @@ error: impl for `HashMap` should be generarized over different hashers\n    |\n help: consider adding a type parameter\n    |\n-20 | impl<K: Hash + Eq, V, S: ::std::hash::BuildHasher + Default> Foo<i8> for (HashMap<K, V>,) {\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+20 | impl<K: Hash + Eq, V, S: ::std::hash::BuildHasher> Foo<i8> for (HashMap<K, V>,) {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n help: ...and change the type to\n    |\n 20 | impl<K: Hash + Eq, V> Foo<i8> for (HashMap<K, V, S>,) {\n    |                                    ^^^^^^^^^^^^^^^^\n-help: ...and use generic constructor here\n-   |\n-22 |         ((HashMap::default(),), (HashMap::with_capacity(10),))\n-   |           ^^^^^^^^^^^^^^^^^^\n-help: ...and use generic constructor here\n-   |\n-22 |         ((HashMap::new(),), (HashMap::with_capacity_and_hasher(10, Default::default()),))\n-   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: impl for `HashMap` should be generarized over different hashers\n   --> $DIR/implicit_hasher.rs:25:19\n@@ -61,20 +37,12 @@ error: impl for `HashMap` should be generarized over different hashers\n    |\n help: consider adding a type parameter\n    |\n-25 | impl<S: ::std::hash::BuildHasher + Default> Foo<i16> for HashMap<String, String> {\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+25 | impl<S: ::std::hash::BuildHasher> Foo<i16> for HashMap<String, String> {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n help: ...and change the type to\n    |\n 25 | impl Foo<i16> for HashMap<String, String, S> {\n    |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^\n-help: ...and use generic constructor here\n-   |\n-27 |         (HashMap::default(), HashMap::with_capacity(10))\n-   |          ^^^^^^^^^^^^^^^^^^\n-help: ...and use generic constructor here\n-   |\n-27 |         (HashMap::new(), HashMap::with_capacity_and_hasher(10, Default::default()))\n-   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: impl for `HashSet` should be generarized over different hashers\n   --> $DIR/implicit_hasher.rs:43:32\n@@ -84,20 +52,12 @@ error: impl for `HashSet` should be generarized over different hashers\n    |\n help: consider adding a type parameter\n    |\n-43 | impl<T: Hash + Eq, S: ::std::hash::BuildHasher + Default> Foo<i8> for HashSet<T> {\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+43 | impl<T: Hash + Eq, S: ::std::hash::BuildHasher> Foo<i8> for HashSet<T> {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n help: ...and change the type to\n    |\n 43 | impl<T: Hash + Eq> Foo<i8> for HashSet<T, S> {\n    |                                ^^^^^^^^^^^^^\n-help: ...and use generic constructor here\n-   |\n-45 |         (HashSet::default(), HashSet::with_capacity(10))\n-   |          ^^^^^^^^^^^^^^^^^^\n-help: ...and use generic constructor here\n-   |\n-45 |         (HashSet::new(), HashSet::with_capacity_and_hasher(10, Default::default()))\n-   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: impl for `HashSet` should be generarized over different hashers\n   --> $DIR/implicit_hasher.rs:48:19\n@@ -107,20 +67,12 @@ error: impl for `HashSet` should be generarized over different hashers\n    |\n help: consider adding a type parameter\n    |\n-48 | impl<S: ::std::hash::BuildHasher + Default> Foo<i16> for HashSet<String> {\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+48 | impl<S: ::std::hash::BuildHasher> Foo<i16> for HashSet<String> {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n help: ...and change the type to\n    |\n 48 | impl Foo<i16> for HashSet<String, S> {\n    |                   ^^^^^^^^^^^^^^^^^^\n-help: ...and use generic constructor here\n-   |\n-50 |         (HashSet::default(), HashSet::with_capacity(10))\n-   |          ^^^^^^^^^^^^^^^^^^\n-help: ...and use generic constructor here\n-   |\n-50 |         (HashSet::new(), HashSet::with_capacity_and_hasher(10, Default::default()))\n-   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: parameter of type `HashMap` should be generarized over different hashers\n   --> $DIR/implicit_hasher.rs:65:23\n@@ -152,3 +104,57 @@ help: ...and change the type to\n 65 | pub fn foo(_map: &mut HashMap<i32, i32>, _set: &mut HashSet<i32, S>) {\n    |                                                     ^^^^^^^^^^^^^^^\n \n+error: impl for `HashMap` should be generarized over different hashers\n+  --> $DIR/implicit_hasher.rs:70:43\n+   |\n+70 |         impl<K: Hash + Eq, V> Foo<u8> for HashMap<K, V> {\n+   |                                           ^^^^^^^^^^^^^\n+...\n+83 | gen!(impl);\n+   | ----------- in this macro invocation\n+   |\n+help: consider adding a type parameter\n+   |\n+70 |         impl<K: Hash + Eq, V, S: ::std::hash::BuildHasher> Foo<u8> for HashMap<K, V> {\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: ...and change the type to\n+   |\n+70 |         impl<K: Hash + Eq, V> Foo<u8> for HashMap<K, V, S> {\n+   |                                           ^^^^^^^^^^^^^^^^\n+\n+error: parameter of type `HashMap` should be generarized over different hashers\n+  --> $DIR/implicit_hasher.rs:78:33\n+   |\n+78 |         pub fn $name(_map: &mut HashMap<i32, i32>, _set: &mut HashSet<i32>) {\n+   |                                 ^^^^^^^^^^^^^^^^^\n+...\n+84 | gen!(fn bar);\n+   | ------------- in this macro invocation\n+   |\n+help: consider adding a type parameter\n+   |\n+78 |         pub fn $name<S: ::std::hash::BuildHasher>(_map: &mut HashMap<i32, i32>, _set: &mut HashSet<i32>) {\n+   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: ...and change the type to\n+   |\n+78 |         pub fn $name(_map: &mut HashMap<i32, i32, S>, _set: &mut HashSet<i32>) {\n+   |                                 ^^^^^^^^^^^^^^^^^^^^\n+\n+error: parameter of type `HashSet` should be generarized over different hashers\n+  --> $DIR/implicit_hasher.rs:78:63\n+   |\n+78 |         pub fn $name(_map: &mut HashMap<i32, i32>, _set: &mut HashSet<i32>) {\n+   |                                                               ^^^^^^^^^^^^\n+...\n+84 | gen!(fn bar);\n+   | ------------- in this macro invocation\n+   |\n+help: consider adding a type parameter\n+   |\n+78 |         pub fn $name<S: ::std::hash::BuildHasher>(_map: &mut HashMap<i32, i32>, _set: &mut HashSet<i32>) {\n+   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: ...and change the type to\n+   |\n+78 |         pub fn $name(_map: &mut HashMap<i32, i32>, _set: &mut HashSet<i32, S>) {\n+   |                                                               ^^^^^^^^^^^^^^^\n+"}]}