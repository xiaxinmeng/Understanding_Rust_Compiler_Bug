{"sha": "2b92962aa29b0116015f99c1666ecf6288303c65", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJiOTI5NjJhYTI5YjAxMTYwMTVmOTljMTY2NmVjZjYyODgzMDNjNjU=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-01-08T22:00:45Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-01-09T22:59:07Z"}, "message": "A collection of refactorings that I found it hard/tiresome to divide:\n\n- Make `extern fn()` assignable to any closure type, rather than\n  a subtype.\n- Remove unused int_ty_set and float_ty_set\n- Refactor variable unification and make it more DRY\n- Do fn sub/lub/glb on the level of fn_sig\n- Rename infer::to_str::ToStr to infer::to_str::InferStr\n- Capitalize names of various types\n- Correct hashing of FnMeta\n- Convert various records-of-fns into structs-of-fns.  This is both\n  eliminating use of deprecated features and more forwards compatible\n  with fn reform.\n\nr=pcwalton", "tree": {"sha": "b4d84abe1587cddd4db8fcece762f43a89f4bec7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b4d84abe1587cddd4db8fcece762f43a89f4bec7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2b92962aa29b0116015f99c1666ecf6288303c65", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2b92962aa29b0116015f99c1666ecf6288303c65", "html_url": "https://github.com/rust-lang/rust/commit/2b92962aa29b0116015f99c1666ecf6288303c65", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2b92962aa29b0116015f99c1666ecf6288303c65/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "11a307294a83c2651405137763c9d620ab3fc7e7", "url": "https://api.github.com/repos/rust-lang/rust/commits/11a307294a83c2651405137763c9d620ab3fc7e7", "html_url": "https://github.com/rust-lang/rust/commit/11a307294a83c2651405137763c9d620ab3fc7e7"}], "stats": {"total": 3303, "additions": 1642, "deletions": 1661}, "files": [{"sha": "ba6862039d44d4c0ee99c204eb14cdd903ee8b0c", "filename": "src/compiletest/compiletest.rc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Fcompiletest%2Fcompiletest.rc", "raw_url": "https://github.com/rust-lang/rust/raw/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Fcompiletest%2Fcompiletest.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rc?ref=2b92962aa29b0116015f99c1666ecf6288303c65", "patch": "@@ -211,7 +211,7 @@ fn is_test(config: config, testfile: &Path) -> bool {\n \n fn make_test(config: config, testfile: &Path) ->\n    test::TestDesc {\n-    {\n+    test::TestDesc {\n         name: make_test_name(config, testfile),\n         testfn: make_test_closure(config, testfile),\n         ignore: header::is_test_ignored(config, testfile),"}, {"sha": "ea67d0ea858d12f132ffe8216c603318b1348593", "filename": "src/libcargo/cargo.rc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibcargo%2Fcargo.rc", "raw_url": "https://github.com/rust-lang/rust/raw/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibcargo%2Fcargo.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcargo%2Fcargo.rc?ref=2b92962aa29b0116015f99c1666ecf6288303c65", "patch": "@@ -403,7 +403,7 @@ fn load_crate(filename: &Path) -> Option<Crate> {\n     let e = @{\n         mut deps: ~[]\n     };\n-    let v = visit::mk_simple_visitor(@{\n+    let v = visit::mk_simple_visitor(@visit::SimpleVisitor {\n         visit_view_item: |a| goto_view_item(sess, e, a),\n         visit_item: |a| goto_item(e, a),\n         .. *visit::default_simple_visitor()"}, {"sha": "f45f71104f42458498aef4b43f2919f86d3cc1d6", "filename": "src/libcore/stackwalk.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibcore%2Fstackwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibcore%2Fstackwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstackwalk.rs?ref=2b92962aa29b0116015f99c1666ecf6288303c65", "patch": "@@ -99,5 +99,5 @@ extern mod rustrt {\n #[abi = \"rust-intrinsic\"]\n extern mod rusti {\n     #[legacy_exports];\n-    fn frame_address(f: fn(++x: *u8));\n+    fn frame_address(f: &once fn(++x: *u8));\n }"}, {"sha": "fd36c1d770158581e1ba45d2a042584ba1fcf2f8", "filename": "src/libfuzzer/fuzzer.rc", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibfuzzer%2Ffuzzer.rc", "raw_url": "https://github.com/rust-lang/rust/raw/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibfuzzer%2Ffuzzer.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfuzzer%2Ffuzzer.rc?ref=2b92962aa29b0116015f99c1666ecf6288303c65", "patch": "@@ -167,7 +167,7 @@ type stolen_stuff = {exprs: ~[ast::expr], tys: ~[ast::Ty]};\n fn steal(crate: ast::crate, tm: test_mode) -> stolen_stuff {\n     let exprs = @mut ~[];\n     let tys = @mut ~[];\n-    let v = visit::mk_simple_visitor(@{\n+    let v = visit::mk_simple_visitor(@visit::SimpleVisitor {\n         visit_expr: |a| stash_expr_if(safe_to_steal_expr, exprs, a, tm),\n         visit_ty: |a| stash_ty_if(safe_to_steal_ty, tys, a, tm),\n         .. *visit::default_simple_visitor()\n@@ -216,7 +216,7 @@ fn replace_expr_in_crate(crate: ast::crate, i: uint,\n             fold::noop_fold_expr(original, fld)\n         }\n     }\n-    let afp = @{\n+    let afp = @fold::AstFoldFns {\n         fold_expr: fold::wrap(|a,b| {\n             fold_expr_rep(j, i, newexpr.node, a, b, tm)\n         }),\n@@ -241,7 +241,7 @@ fn replace_ty_in_crate(crate: ast::crate, i: uint, newty: ast::Ty,\n             newty_\n         } else { fold::noop_fold_ty(original, fld) }\n     }\n-    let afp = @{\n+    let afp = @fold::AstFoldFns {\n         fold_ty: fold::wrap(|a,b| fold_ty_rep(j, i, newty.node, a, b, tm) ),\n         .. *fold::default_ast_fold()\n     };\n@@ -486,8 +486,9 @@ fn has_raw_pointers(c: ast::crate) -> bool {\n         }\n     }\n     let v =\n-        visit::mk_simple_visitor(@{visit_ty: |a| visit_ty(has_rp, a),\n-                                      .. *visit::default_simple_visitor()});\n+        visit::mk_simple_visitor(@visit::SimpleVisitor {\n+            visit_ty: |a| visit_ty(has_rp, a),\n+            .. *visit::default_simple_visitor()});\n     visit::visit_crate(c, (), v);\n     return *has_rp;\n }"}, {"sha": "b4a9a83992d10c9d227787a824823882a0175f09", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=2b92962aa29b0116015f99c1666ecf6288303c65", "patch": "@@ -395,13 +395,16 @@ fn pretty_print_input(sess: Session, +cfg: ast::crate_cfg, input: input,\n \n     let ann = match ppm {\n       ppm_typed => {\n-        {pre: ann_paren_for_expr,\n-         post: |a| ann_typed_post(tcx.get(), a) }\n+          pprust::pp_ann {pre: ann_paren_for_expr,\n+                          post: |a| ann_typed_post(tcx.get(), a) }\n       }\n       ppm_identified | ppm_expanded_identified => {\n-        {pre: ann_paren_for_expr, post: ann_identified_post}\n+          pprust::pp_ann {pre: ann_paren_for_expr,\n+                          post: ann_identified_post}\n+      }\n+      ppm_expanded | ppm_normal => {\n+          pprust::no_ann()\n       }\n-      ppm_expanded | ppm_normal => pprust::no_ann()\n     };\n     let is_expanded = upto != cu_parse;\n     let src = sess.codemap.get_filemap(source_name(input)).src;"}, {"sha": "307698af03710eb6facf7ba2b4eaea456a7f7a09", "filename": "src/librustc/front/config.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibrustc%2Ffront%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibrustc%2Ffront%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fconfig.rs?ref=2b92962aa29b0116015f99c1666ecf6288303c65", "patch": "@@ -38,8 +38,8 @@ fn strip_items(crate: @ast::crate, in_cfg: in_cfg_pred)\n \n     let ctxt = @{in_cfg: in_cfg};\n \n-    let precursor =\n-        @{fold_mod: |a,b| fold_mod(ctxt, a, b),\n+    let precursor = @fold::AstFoldFns {\n+          fold_mod: |a,b| fold_mod(ctxt, a, b),\n           fold_block: fold::wrap(|a,b| fold_block(ctxt, a, b) ),\n           fold_foreign_mod: |a,b| fold_foreign_mod(ctxt, a, b),\n           fold_item_underscore: |a,b| {"}, {"sha": "045e60052a4d5ce5d9594ea7b4d66c9883e25a77", "filename": "src/librustc/front/core_inject.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibrustc%2Ffront%2Fcore_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibrustc%2Ffront%2Fcore_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fcore_inject.rs?ref=2b92962aa29b0116015f99c1666ecf6288303c65", "patch": "@@ -42,7 +42,7 @@ fn inject_libcore_ref(sess: Session,\n         ast::spanned { node: x, span: dummy_sp() }\n     }\n \n-    let precursor = @{\n+    let precursor = @fold::AstFoldFns {\n         fold_crate: |crate, span, fld| {\n             let n1 = sess.next_node_id();\n             let vi1 = @{node: ast::view_item_use(sess.ident_of(~\"core\"),"}, {"sha": "970f1a065a7e363f28811e25fe31c6c853f5991b", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=2b92962aa29b0116015f99c1666ecf6288303c65", "patch": "@@ -65,10 +65,10 @@ fn generate_test_harness(sess: session::Session,\n           mut path: ~[],\n           testfns: DVec()};\n \n-    let precursor =\n-        @{fold_crate: fold::wrap(|a,b| fold_crate(cx, a, b) ),\n-          fold_item: |a,b| fold_item(cx, a, b),\n-          fold_mod: |a,b| fold_mod(cx, a, b),.. *fold::default_ast_fold()};\n+    let precursor = @fold::AstFoldFns {\n+        fold_crate: fold::wrap(|a,b| fold_crate(cx, a, b) ),\n+        fold_item: |a,b| fold_item(cx, a, b),\n+        fold_mod: |a,b| fold_mod(cx, a, b),.. *fold::default_ast_fold()};\n \n     let fold = fold::make_fold(precursor);\n     let res = @fold.fold_crate(*crate);\n@@ -424,8 +424,14 @@ fn mk_test_desc_rec(cx: test_ctxt, test: test) -> @ast::expr {\n                 ident: cx.sess.ident_of(~\"should_fail\"),\n                 expr: @fail_expr});\n \n+    let test_desc_path =\n+        mk_path(cx, ~[cx.sess.ident_of(~\"test\"),\n+                      cx.sess.ident_of(~\"TestDesc\")]);\n+\n     let desc_rec_: ast::expr_ =\n-        ast::expr_rec(~[name_field, fn_field, ignore_field, fail_field],\n+        ast::expr_struct(\n+            test_desc_path,\n+            ~[name_field, fn_field, ignore_field, fail_field],\n             option::None);\n     let desc_rec: ast::expr =\n         {id: cx.sess.next_node_id(), callee_id: cx.sess.next_node_id(),"}, {"sha": "a731aa8db973846c74d059927f06c5da5476856e", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=2b92962aa29b0116015f99c1666ecf6288303c65", "patch": "@@ -52,10 +52,10 @@ fn read_crates(diag: span_handler,\n               mut next_crate_num: 1,\n               intr: intr};\n     let v =\n-        visit::mk_simple_visitor(@{visit_view_item:\n-                                       |a| visit_view_item(e, a),\n-                                   visit_item: |a| visit_item(e, a)\n-                                   ,.. *visit::default_simple_visitor()});\n+        visit::mk_simple_visitor(@visit::SimpleVisitor {\n+            visit_view_item: |a| visit_view_item(e, a),\n+            visit_item: |a| visit_item(e, a),\n+            .. *visit::default_simple_visitor()});\n     visit::visit_crate(crate, (), v);\n     dump_crates(e.crate_cache);\n     warn_if_multiple_versions(e, diag, e.crate_cache.get());"}, {"sha": "6d131a074eb1616fed6791d2f05ee7c6bb9a693f", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 25, "deletions": 23, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=2b92962aa29b0116015f99c1666ecf6288303c65", "patch": "@@ -180,11 +180,12 @@ fn def_to_str(did: def_id) -> ~str { fmt!(\"%d:%d\", did.crate, did.node) }\n \n fn encode_ty_type_param_bounds(ebml_w: writer::Encoder, ecx: @encode_ctxt,\n                                params: @~[ty::param_bounds]) {\n-    let ty_str_ctxt = @{diag: ecx.diag,\n-                        ds: def_to_str,\n-                        tcx: ecx.tcx,\n-                        reachable: |a| reachable(ecx, a),\n-                        abbrevs: tyencode::ac_use_abbrevs(ecx.type_abbrevs)};\n+    let ty_str_ctxt = @tyencode::ctxt {\n+        diag: ecx.diag,\n+        ds: def_to_str,\n+        tcx: ecx.tcx,\n+        reachable: |a| reachable(ecx, a),\n+        abbrevs: tyencode::ac_use_abbrevs(ecx.type_abbrevs)};\n     for params.each |param| {\n         ebml_w.start_tag(tag_items_data_item_ty_param_bounds);\n         tyencode::enc_bounds(ebml_w.writer, ty_str_ctxt, *param);\n@@ -207,23 +208,23 @@ fn encode_variant_id(ebml_w: writer::Encoder, vid: def_id) {\n }\n \n fn write_type(ecx: @encode_ctxt, ebml_w: writer::Encoder, typ: ty::t) {\n-    let ty_str_ctxt =\n-        @{diag: ecx.diag,\n-          ds: def_to_str,\n-          tcx: ecx.tcx,\n-          reachable: |a| reachable(ecx, a),\n-          abbrevs: tyencode::ac_use_abbrevs(ecx.type_abbrevs)};\n+    let ty_str_ctxt = @tyencode::ctxt {\n+        diag: ecx.diag,\n+        ds: def_to_str,\n+        tcx: ecx.tcx,\n+        reachable: |a| reachable(ecx, a),\n+        abbrevs: tyencode::ac_use_abbrevs(ecx.type_abbrevs)};\n     tyencode::enc_ty(ebml_w.writer, ty_str_ctxt, typ);\n }\n \n fn write_vstore(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n                 vstore: ty::vstore) {\n-    let ty_str_ctxt =\n-        @{diag: ecx.diag,\n-          ds: def_to_str,\n-          tcx: ecx.tcx,\n-          reachable: |a| reachable(ecx, a),\n-          abbrevs: tyencode::ac_use_abbrevs(ecx.type_abbrevs)};\n+    let ty_str_ctxt = @tyencode::ctxt {\n+        diag: ecx.diag,\n+        ds: def_to_str,\n+        tcx: ecx.tcx,\n+        reachable: |a| reachable(ecx, a),\n+        abbrevs: tyencode::ac_use_abbrevs(ecx.type_abbrevs)};\n     tyencode::enc_vstore(ebml_w.writer, ty_str_ctxt, vstore);\n }\n \n@@ -887,7 +888,7 @@ fn encode_info_for_items(ecx: @encode_ctxt, ebml_w: writer::Encoder,\n     encode_info_for_mod(ecx, ebml_w, crate.node.module,\n                         crate_node_id, ~[],\n                         syntax::parse::token::special_idents::invalid);\n-    visit::visit_crate(*crate, (), visit::mk_vt(@{\n+    visit::visit_crate(*crate, (), visit::mk_vt(@visit::Visitor {\n         visit_expr: |_e, _cx, _v| { },\n         visit_item: |i, cx, v, copy ebml_w| {\n             visit::visit_item(i, cx, v);\n@@ -1267,11 +1268,12 @@ fn encode_metadata(parms: encode_parms, crate: @crate) -> ~[u8] {\n \n // Get the encoded string for a type\n fn encoded_ty(tcx: ty::ctxt, t: ty::t) -> ~str {\n-    let cx = @{diag: tcx.diag,\n-               ds: def_to_str,\n-               tcx: tcx,\n-               reachable: |_id| false,\n-               abbrevs: tyencode::ac_no_abbrevs};\n+    let cx = @tyencode::ctxt {\n+        diag: tcx.diag,\n+        ds: def_to_str,\n+        tcx: tcx,\n+        reachable: |_id| false,\n+        abbrevs: tyencode::ac_no_abbrevs};\n     do io::with_str_writer |wr| {\n         tyencode::enc_ty(wr, cx, t);\n     }"}, {"sha": "154fb8d2de85a7346c9b87c4180196846eaa14b8", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=2b92962aa29b0116015f99c1666ecf6288303c65", "patch": "@@ -14,7 +14,7 @@\n use core::prelude::*;\n \n use middle::ty;\n-use middle::ty::vid;\n+use middle::ty::Vid;\n \n use core::io::WriterUtil;\n use core::io;\n@@ -24,6 +24,7 @@ use std::map::HashMap;\n use syntax::ast::*;\n use syntax::diagnostic::span_handler;\n use syntax::print::pprust::*;\n+use middle::ty::Vid;\n \n export ctxt;\n export ty_abbrev;\n@@ -35,15 +36,15 @@ export enc_mode;\n export enc_arg;\n export enc_vstore;\n \n-type ctxt = {\n+struct ctxt {\n     diag: span_handler,\n     // Def -> str Callback:\n     ds: fn@(def_id) -> ~str,\n     // The type context.\n     tcx: ty::ctxt,\n     reachable: fn@(node_id) -> bool,\n     abbrevs: abbrev_ctxt\n-};\n+}\n \n // Compact string representation for ty.t values. API ty_str & parse_from_str.\n // Extra parameters are for converting to/from def_ids in the string rep."}, {"sha": "eb9d4ae6a30ad29fab5396497ccaff000a45db05", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=2b92962aa29b0116015f99c1666ecf6288303c65", "patch": "@@ -271,7 +271,7 @@ fn simplify_ast(ii: ast::inlined_item) -> ast::inlined_item {\n         fold::noop_fold_block(blk_sans_items, fld)\n     }\n \n-    let fld = fold::make_fold(@{\n+    let fld = fold::make_fold(@fold::AstFoldFns {\n         fold_block: fold::wrap(drop_nested_items),\n         .. *fold::default_ast_fold()\n     });\n@@ -304,7 +304,7 @@ fn decode_ast(par_doc: ebml::Doc) -> ast::inlined_item {\n \n fn renumber_ast(xcx: extended_decode_ctxt, ii: ast::inlined_item)\n     -> ast::inlined_item {\n-    let fld = fold::make_fold(@{\n+    let fld = fold::make_fold(@fold::AstFoldFns{\n         new_id: |a| xcx.tr_id(a),\n         new_span: |a| xcx.tr_span(a),\n         .. *fold::default_ast_fold()\n@@ -643,11 +643,11 @@ trait get_ty_str_ctxt {\n \n impl @e::encode_ctxt: get_ty_str_ctxt {\n     fn ty_str_ctxt() -> @tyencode::ctxt {\n-        @{diag: self.tcx.sess.diagnostic(),\n-          ds: e::def_to_str,\n-          tcx: self.tcx,\n-          reachable: |a| encoder::reachable(self, a),\n-          abbrevs: tyencode::ac_use_abbrevs(self.type_abbrevs)}\n+        @tyencode::ctxt {diag: self.tcx.sess.diagnostic(),\n+                        ds: e::def_to_str,\n+                        tcx: self.tcx,\n+                        reachable: |a| encoder::reachable(self, a),\n+                        abbrevs: tyencode::ac_use_abbrevs(self.type_abbrevs)}\n     }\n }\n "}, {"sha": "3d5bdac596bc6be7ad16d6e0cedc4db2a7445230", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=2b92962aa29b0116015f99c1666ecf6288303c65", "patch": "@@ -92,11 +92,11 @@ fn check_loans(bccx: borrowck_ctxt,\n                                  reported: HashMap(),\n                                  mut declared_purity: ast::impure_fn,\n                                  mut fn_args: @~[]});\n-    let vt = visit::mk_vt(@{visit_expr: check_loans_in_expr,\n-                            visit_local: check_loans_in_local,\n-                            visit_block: check_loans_in_block,\n-                            visit_fn: check_loans_in_fn,\n-                            .. *visit::default_visitor()});\n+    let vt = visit::mk_vt(@visit::Visitor {visit_expr: check_loans_in_expr,\n+                                           visit_local: check_loans_in_local,\n+                                           visit_block: check_loans_in_block,\n+                                           visit_fn: check_loans_in_fn,\n+                                           .. *visit::default_visitor()});\n     visit::visit_crate(*crate, clcx, vt);\n }\n \n@@ -247,13 +247,13 @@ impl check_loan_ctxt {\n         let callee_ty = ty::node_id_to_type(tcx, callee_id);\n         match ty::get(callee_ty).sty {\n           ty::ty_fn(ref fn_ty) => {\n-            match (*fn_ty).meta.purity {\n+            match fn_ty.meta.purity {\n               ast::pure_fn => return, // case (c) above\n               ast::impure_fn | ast::unsafe_fn | ast::extern_fn => {\n                 self.report_purity_error(\n                     pc, callee_span,\n                     fmt!(\"access to %s function\",\n-                         pprust::purity_to_str((*fn_ty).meta.purity)));\n+                         fn_ty.meta.purity.to_str()));\n               }\n             }\n           }"}, {"sha": "52cbd1da10c9ddb9d42503303ba6dc5877cca6bb", "filename": "src/librustc/middle/borrowck/gather_loans.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs?ref=2b92962aa29b0116015f99c1666ecf6288303c65", "patch": "@@ -82,9 +82,9 @@ fn gather_loans(bccx: borrowck_ctxt, crate: @ast::crate) -> req_maps {\n                                   mut item_ub: 0,\n                                   mut root_ub: 0,\n                                   mut ignore_adjustments: LinearMap()});\n-    let v = visit::mk_vt(@{visit_expr: req_loans_in_expr,\n-                           visit_fn: req_loans_in_fn,\n-                           .. *visit::default_visitor()});\n+    let v = visit::mk_vt(@visit::Visitor {visit_expr: req_loans_in_expr,\n+                                          visit_fn: req_loans_in_fn,\n+                                          .. *visit::default_visitor()});\n     visit::visit_crate(*crate, glcx, v);\n     return glcx.req_maps;\n }"}, {"sha": "19fc9eb175d6017b167c64bf55c733f89cd862a7", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=2b92962aa29b0116015f99c1666ecf6288303c65", "patch": "@@ -231,7 +231,6 @@ use core::prelude::*;\n use middle::liveness;\n use middle::mem_categorization::*;\n use middle::region;\n-use middle::ty::to_str;\n use middle::ty;\n use util::common::indenter;\n use util::ppaux::{expr_repr, note_and_explain_region};"}, {"sha": "7986352cac28bf8fe6c809e2aa239462e538c49b", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=2b92962aa29b0116015f99c1666ecf6288303c65", "patch": "@@ -25,7 +25,7 @@ use syntax::{visit, ast_util, ast_map};\n fn check_crate(sess: Session, crate: @crate, ast_map: ast_map::map,\n                def_map: resolve::DefMap,\n                 method_map: typeck::method_map, tcx: ty::ctxt) {\n-    visit::visit_crate(*crate, false, visit::mk_vt(@{\n+    visit::visit_crate(*crate, false, visit::mk_vt(@visit::Visitor {\n         visit_item: |a,b,c| check_item(sess, ast_map, def_map, a, b, c),\n         visit_pat: check_pat,\n         visit_expr: |a,b,c|\n@@ -211,7 +211,7 @@ fn check_item_recursion(sess: Session, ast_map: ast_map::map,\n         idstack: @DVec()\n     };\n \n-    let visitor = visit::mk_vt(@{\n+    let visitor = visit::mk_vt(@visit::Visitor {\n         visit_item: visit_item,\n         visit_expr: visit_expr,\n         .. *visit::default_visitor()"}, {"sha": "0e260c54fe26b4a65cd452bc0d9e36b0816b204f", "filename": "src/librustc/middle/check_loop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs?ref=2b92962aa29b0116015f99c1666ecf6288303c65", "patch": "@@ -19,7 +19,7 @@ type ctx = {in_loop: bool, can_ret: bool};\n fn check_crate(tcx: ty::ctxt, crate: @crate) {\n     visit::visit_crate(*crate,\n                        {in_loop: false, can_ret: true},\n-                       visit::mk_vt(@{\n+                       visit::mk_vt(@visit::Visitor {\n         visit_item: |i, _cx, v| {\n             visit::visit_item(i, {in_loop: false, can_ret: true}, v);\n         },"}, {"sha": "c99b5757baaf2730fdace6c62306a8740977f95b", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=2b92962aa29b0116015f99c1666ecf6288303c65", "patch": "@@ -38,7 +38,7 @@ struct MatchCheckCtxt {\n \n fn check_crate(tcx: ty::ctxt, method_map: method_map, crate: @crate) {\n     let cx = @MatchCheckCtxt { tcx: tcx, method_map: method_map };\n-    visit::visit_crate(*crate, (), visit::mk_vt(@{\n+    visit::visit_crate(*crate, (), visit::mk_vt(@visit::Visitor {\n         visit_expr: |a,b,c| check_expr(cx, a, b, c),\n         visit_local: |a,b,c| check_local(cx, a, b, c),\n         visit_fn: |kind, decl, body, sp, id, e, v|\n@@ -797,7 +797,7 @@ fn check_legality_of_move_bindings(cx: @MatchCheckCtxt,\n \n         // Now check to ensure that any move binding is not behind an @ or &.\n         // This is always illegal.\n-        let vt = visit::mk_vt(@{\n+        let vt = visit::mk_vt(@visit::Visitor {\n             visit_pat: |pat, behind_bad_pointer, v| {\n                 let error_out = || {\n                     cx.tcx.sess.span_err(pat.span, ~\"by-move pattern \\"}, {"sha": "530e63acf5710fa59633aefaed356afd78c80770", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=2b92962aa29b0116015f99c1666ecf6288303c65", "patch": "@@ -207,7 +207,7 @@ fn lookup_constness(tcx: ty::ctxt, e: @expr) -> constness {\n fn process_crate(crate: @ast::crate,\n                  def_map: resolve::DefMap,\n                  tcx: ty::ctxt) {\n-    let v = visit::mk_simple_visitor(@{\n+    let v = visit::mk_simple_visitor(@visit::SimpleVisitor {\n         visit_expr_post: |e| { classify(e, def_map, tcx); },\n         .. *visit::default_simple_visitor()\n     });"}, {"sha": "3c1f261c1f8af56c51921b67c19d583e91f7d708", "filename": "src/librustc/middle/freevars.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffreevars.rs?ref=2b92962aa29b0116015f99c1666ecf6288303c65", "patch": "@@ -90,8 +90,9 @@ fn collect_freevars(def_map: resolve::DefMap, blk: ast::blk)\n             }\n         };\n \n-    let v = visit::mk_vt(@{visit_item: ignore_item, visit_expr: walk_expr,\n-                           .. *visit::default_visitor()});\n+    let v = visit::mk_vt(@visit::Visitor {visit_item: ignore_item,\n+                                          visit_expr: walk_expr,\n+                                          .. *visit::default_visitor()});\n     (v.visit_block)(blk, 1, v);\n     return @/*bad*/copy *refs;\n }\n@@ -112,8 +113,9 @@ fn annotate_freevars(def_map: resolve::DefMap, crate: @ast::crate) ->\n     };\n \n     let visitor =\n-        visit::mk_simple_visitor(@{visit_fn: walk_fn,\n-                                   .. *visit::default_simple_visitor()});\n+        visit::mk_simple_visitor(@visit::SimpleVisitor {\n+            visit_fn: walk_fn,\n+            .. *visit::default_simple_visitor()});\n     visit::visit_crate(*crate, (), visitor);\n \n     return freevars;"}, {"sha": "3af1d7ea35bdd2249d9fad6f1e63cb969c269df9", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=2b92962aa29b0116015f99c1666ecf6288303c65", "patch": "@@ -97,7 +97,7 @@ fn check_crate(tcx: ty::ctxt,\n                method_map: method_map,\n                last_use_map: last_use_map,\n                current_item: -1};\n-    let visit = visit::mk_vt(@{\n+    let visit = visit::mk_vt(@visit::Visitor {\n         visit_arm: check_arm,\n         visit_expr: check_expr,\n         visit_stmt: check_stmt,"}, {"sha": "6870082ffacbaa4758d70050ce500fae47c9a4a0", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=2b92962aa29b0116015f99c1666ecf6288303c65", "patch": "@@ -29,7 +29,7 @@ use metadata::decoder::{dl_def, dl_field, dl_impl};\n use syntax::ast::{crate, def_fn, def_id, def_ty, lit_str, meta_item};\n use syntax::ast::{meta_list, meta_name_value, meta_word};\n use syntax::ast_util::{local_def};\n-use syntax::visit::{default_simple_visitor, mk_simple_visitor};\n+use syntax::visit::{default_simple_visitor, mk_simple_visitor, SimpleVisitor};\n use syntax::visit::{visit_crate, visit_item};\n \n use core::ptr;\n@@ -333,7 +333,7 @@ impl LanguageItemCollector {\n \n     fn collect_local_language_items() {\n         let this = unsafe { ptr::addr_of(&self) };\n-        visit_crate(*self.crate, (), mk_simple_visitor(@{\n+        visit_crate(*self.crate, (), mk_simple_visitor(@SimpleVisitor {\n             visit_item: |item| {\n                 for item.attrs.each |attribute| {\n                     unsafe {"}, {"sha": "b2881abf53bcafb03a7655aa42f17d50e48b7207", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 68, "deletions": 61, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=2b92962aa29b0116015f99c1666ecf6288303c65", "patch": "@@ -430,7 +430,7 @@ fn build_settings_crate(sess: session::Session, crate: @ast::crate) {\n \n         let cx = ctxt_({is_default: true,.. *cx});\n \n-        let visit = visit::mk_vt(@{\n+        let visit = visit::mk_vt(@visit::Visitor {\n             visit_item: build_settings_item,\n             .. *visit::default_visitor()\n         });\n@@ -458,30 +458,33 @@ fn check_item(i: @ast::item, cx: ty::ctxt) {\n // not traverse into subitems, since that is handled by the outer\n // lint visitor.\n fn item_stopping_visitor<E>(v: visit::vt<E>) -> visit::vt<E> {\n-    visit::mk_vt(@{visit_item: |_i, _e, _v| { },.. **v})\n+    visit::mk_vt(@visit::Visitor {visit_item: |_i, _e, _v| { },.. **v})\n }\n \n fn check_item_while_true(cx: ty::ctxt, it: @ast::item) {\n-    let visit = item_stopping_visitor(visit::mk_simple_visitor(@{\n-        visit_expr: fn@(e: @ast::expr) {\n-           match e.node {\n-             ast::expr_while(cond, _) => {\n-                match cond.node {\n-                    ast::expr_lit(@ast::spanned { node: ast::lit_bool(true),\n-                                                  _}) => {\n-                            cx.sess.span_lint(\n-                                while_true, e.id, it.id,\n-                                e.span,\n-                                ~\"denote infinite loops with loop { ... }\");\n+    let visit = item_stopping_visitor(\n+        visit::mk_simple_visitor(@visit::SimpleVisitor {\n+            visit_expr: |e: @ast::expr| {\n+                match e.node {\n+                    ast::expr_while(cond, _) => {\n+                        match cond.node {\n+                            ast::expr_lit(@ast::spanned {\n+                                node: ast::lit_bool(true), _}) =>\n+                            {\n+                                cx.sess.span_lint(\n+                                    while_true, e.id, it.id,\n+                                    e.span,\n+                                    ~\"denote infinite loops \\\n+                                      with loop { ... }\");\n+                            }\n+                            _ => ()\n+                        }\n                     }\n                     _ => ()\n                 }\n-             }\n-             _ => ()\n-          }\n-        },\n-        .. *visit::default_simple_visitor()\n-    }));\n+            },\n+            .. *visit::default_simple_visitor()\n+        }));\n     visit::visit_item(it, (), visit);\n }\n \n@@ -596,10 +599,11 @@ fn check_item_type_limits(cx: ty::ctxt, it: @ast::item) {\n         }\n     };\n \n-    let visit = item_stopping_visitor(visit::mk_simple_visitor(@{\n-        visit_expr: visit_expr,\n-        .. *visit::default_simple_visitor()\n-    }));\n+    let visit = item_stopping_visitor(\n+        visit::mk_simple_visitor(@visit::SimpleVisitor {\n+            visit_expr: visit_expr,\n+            .. *visit::default_simple_visitor()\n+        }));\n     visit::visit_item(it, (), visit);\n }\n \n@@ -660,19 +664,20 @@ fn check_item_deprecated_self(cx: ty::ctxt, item: @ast::item) {\n }\n \n fn check_item_structural_records(cx: ty::ctxt, it: @ast::item) {\n-    let visit = item_stopping_visitor(visit::mk_simple_visitor(@{\n-        visit_expr: fn@(e: @ast::expr) {\n-           match e.node {\n-             ast::expr_rec(*) =>\n-                 cx.sess.span_lint(\n-                                structural_records, e.id, it.id,\n-                                e.span,\n-                                ~\"structural records are deprecated\"),\n-               _ => ()\n-           }\n-        },\n-        .. *visit::default_simple_visitor()\n-    }));\n+    let visit = item_stopping_visitor(\n+        visit::mk_simple_visitor(@visit::SimpleVisitor {\n+            visit_expr: |e: @ast::expr| {\n+                match e.node {\n+                    ast::expr_rec(*) =>\n+                    cx.sess.span_lint(\n+                        structural_records, e.id, it.id,\n+                        e.span,\n+                        ~\"structural records are deprecated\"),\n+                    _ => ()\n+                }\n+            },\n+            .. *visit::default_simple_visitor()\n+        }));\n     visit::visit_item(it, (), visit);\n }\n \n@@ -779,34 +784,36 @@ fn check_item_heap(cx: ty::ctxt, it: @ast::item) {\n       _ => ()\n     }\n \n-    let visit = item_stopping_visitor(visit::mk_simple_visitor(@{\n-        visit_expr: fn@(e: @ast::expr) {\n-            let ty = ty::expr_ty(cx, e);\n-            check_type(cx, e.id, it.id, e.span, ty);\n-        },\n-        .. *visit::default_simple_visitor()\n-    }));\n+    let visit = item_stopping_visitor(\n+        visit::mk_simple_visitor(@visit::SimpleVisitor {\n+            visit_expr: |e: @ast::expr| {\n+                let ty = ty::expr_ty(cx, e);\n+                check_type(cx, e.id, it.id, e.span, ty);\n+            },\n+            .. *visit::default_simple_visitor()\n+        }));\n     visit::visit_item(it, (), visit);\n }\n \n fn check_item_path_statement(cx: ty::ctxt, it: @ast::item) {\n-    let visit = item_stopping_visitor(visit::mk_simple_visitor(@{\n-        visit_stmt: fn@(s: @ast::stmt) {\n-            match s.node {\n-              ast::stmt_semi(@{id: id,\n-                               callee_id: _,\n-                               node: ast::expr_path(_),\n-                               span: _}, _) => {\n-                cx.sess.span_lint(\n-                    path_statement, id, it.id,\n-                    s.span,\n-                    ~\"path statement with no effect\");\n-              }\n-              _ => ()\n-            }\n-        },\n-        .. *visit::default_simple_visitor()\n-    }));\n+    let visit = item_stopping_visitor(\n+        visit::mk_simple_visitor(@visit::SimpleVisitor {\n+            visit_stmt: |s: @ast::stmt| {\n+                match s.node {\n+                    ast::stmt_semi(@{id: id,\n+                                     callee_id: _,\n+                                     node: ast::expr_path(_),\n+                                     span: _}, _) => {\n+                        cx.sess.span_lint(\n+                            path_statement, id, it.id,\n+                            s.span,\n+                            ~\"path statement with no effect\");\n+                    }\n+                    _ => ()\n+                }\n+            },\n+            .. *visit::default_simple_visitor()\n+        }));\n     visit::visit_item(it, (), visit);\n }\n \n@@ -975,7 +982,7 @@ fn check_item_deprecated_modes(tcx: ty::ctxt, it: @ast::item) {\n \n fn check_crate(tcx: ty::ctxt, crate: @ast::crate) {\n \n-    let v = visit::mk_simple_visitor(@{\n+    let v = visit::mk_simple_visitor(@visit::SimpleVisitor {\n         visit_item: |it|\n             check_item(it, tcx),\n         visit_fn: |fk, decl, body, span, id|"}, {"sha": "bfcd809594b2b635e42d7046a06f97ef699c350e", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=2b92962aa29b0116015f99c1666ecf6288303c65", "patch": "@@ -207,7 +207,7 @@ fn live_node_kind_to_str(lnk: LiveNodeKind, cx: ty::ctxt) -> ~str {\n fn check_crate(tcx: ty::ctxt,\n                method_map: typeck::method_map,\n                crate: @crate) -> last_use_map {\n-    let visitor = visit::mk_vt(@{\n+    let visitor = visit::mk_vt(@visit::Visitor {\n         visit_fn: visit_fn,\n         visit_local: visit_local,\n         visit_expr: visit_expr,\n@@ -489,7 +489,7 @@ fn visit_fn(fk: visit::fn_kind, decl: fn_decl, body: blk,\n     let entry_ln = (*lsets).compute(decl, body);\n \n     // check for various error conditions\n-    let check_vt = visit::mk_vt(@{\n+    let check_vt = visit::mk_vt(@visit::Visitor {\n         visit_fn: check_fn,\n         visit_local: check_local,\n         visit_expr: check_expr,"}, {"sha": "1e24ff9f5e489d8e71d4ab020dac381df3394c11", "filename": "src/librustc/middle/mode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibrustc%2Fmiddle%2Fmode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibrustc%2Fmiddle%2Fmode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmode.rs?ref=2b92962aa29b0116015f99c1666ecf6288303c65", "patch": "@@ -234,7 +234,7 @@ fn compute_modes_for_pat(pat: @pat,\n }\n \n pub fn compute_modes(tcx: ctxt, method_map: method_map, crate: @crate) {\n-    let visitor = visit::mk_vt(@{\n+    let visitor = visit::mk_vt(@visit::Visitor {\n         visit_expr: compute_modes_for_expr,\n         visit_pat: compute_modes_for_pat,\n         .. *visit::default_visitor()"}, {"sha": "745e3f6086f65afcbae312f6656190bd9087c365", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=2b92962aa29b0116015f99c1666ecf6288303c65", "patch": "@@ -190,7 +190,7 @@ fn check_crate(tcx: ty::ctxt, method_map: &method_map, crate: @ast::crate) {\n         }\n     };\n \n-    let visitor = visit::mk_vt(@{\n+    let visitor = visit::mk_vt(@visit::Visitor {\n         visit_mod: |the_module, span, node_id, method_map, visitor| {\n             let n_added = add_privileged_items(the_module.items);\n "}, {"sha": "ae6a6d67c1d4aa53114ad2e786fe009323313006", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=2b92962aa29b0116015f99c1666ecf6288303c65", "patch": "@@ -352,7 +352,7 @@ fn resolve_crate(sess: Session, def_map: resolve::DefMap,\n                          region_map: HashMap(),\n                          root_exprs: HashMap(),\n                          parent: None};\n-    let visitor = visit::mk_vt(@{\n+    let visitor = visit::mk_vt(@visit::Visitor {\n         visit_block: resolve_block,\n         visit_item: resolve_item,\n         visit_fn: resolve_fn,\n@@ -782,7 +782,7 @@ fn determine_rp_in_crate(sess: Session,\n                                   mut ambient_variance: rv_covariant});\n \n     // Gather up the base set, worklist and dep_map\n-    let visitor = visit::mk_vt(@{\n+    let visitor = visit::mk_vt(@visit::Visitor {\n         visit_fn: determine_rp_in_fn,\n         visit_item: determine_rp_in_item,\n         visit_ty: determine_rp_in_ty,"}, {"sha": "2fb922c3e5261a387d11b6f8cc271721b461bd84", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=2b92962aa29b0116015f99c1666ecf6288303c65", "patch": "@@ -64,7 +64,7 @@ use syntax::parse::token::ident_interner;\n use syntax::parse::token::special_idents;\n use syntax::print::pprust::{pat_to_str, path_to_str};\n use syntax::codemap::span;\n-use syntax::visit::{default_visitor, fk_method, mk_vt, visit_block};\n+use syntax::visit::{default_visitor, fk_method, mk_vt, Visitor, visit_block};\n use syntax::visit::{visit_crate, visit_expr, visit_expr_opt, visit_fn};\n use syntax::visit::{visit_foreign_item, visit_item, visit_method_helper};\n use syntax::visit::{visit_mod, visit_ty, vt};\n@@ -947,7 +947,7 @@ impl Resolver {\n     fn build_reduced_graph(this: @Resolver) {\n         let initial_parent =\n             ModuleReducedGraphParent((*self.graph_root).get_module());\n-        visit_crate(*self.crate, initial_parent, mk_vt(@{\n+        visit_crate(*self.crate, initial_parent, mk_vt(@Visitor {\n             visit_item: |item, context, visitor|\n                 (*this).build_reduced_graph_for_item(item, context, visitor),\n \n@@ -3719,7 +3719,7 @@ impl Resolver {\n     fn resolve_crate(@self) {\n         debug!(\"(resolving crate) starting\");\n \n-        visit_crate(*self.crate, (), mk_vt(@{\n+        visit_crate(*self.crate, (), mk_vt(@Visitor {\n             visit_item: |item, _context, visitor|\n                 self.resolve_item(item, visitor),\n             visit_arm: |arm, _context, visitor|"}, {"sha": "12a073e678b09e0a5078f4d1cc22bd8620b93bff", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=2b92962aa29b0116015f99c1666ecf6288303c65", "patch": "@@ -2372,10 +2372,12 @@ fn trans_constant(ccx: @crate_ctxt, it: @ast::item) {\n }\n \n fn trans_constants(ccx: @crate_ctxt, crate: @ast::crate) {\n-    visit::visit_crate(*crate, (), visit::mk_simple_visitor(@{\n-        visit_item: |a| trans_constant(ccx, a),\n-        ..*visit::default_simple_visitor()\n-    }));\n+    visit::visit_crate(\n+        *crate, (),\n+        visit::mk_simple_visitor(@visit::SimpleVisitor {\n+            visit_item: |a| trans_constant(ccx, a),\n+            ..*visit::default_simple_visitor()\n+        }));\n }\n \n fn vp2i(cx: block, v: ValueRef) -> ValueRef {"}, {"sha": "d90673b31bc9254ba5fb98ff0c553a3c738e86c0", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=2b92962aa29b0116015f99c1666ecf6288303c65", "patch": "@@ -390,7 +390,7 @@ fn trans_rtcall_or_lang_call_with_type_params(bcx: block,\n \n fn body_contains_ret(body: ast::blk) -> bool {\n     let cx = {mut found: false};\n-    visit::visit_block(body, cx, visit::mk_vt(@{\n+    visit::visit_block(body, cx, visit::mk_vt(@visit::Visitor {\n         visit_item: |_i, _cx, _v| { },\n         visit_expr: |e: @ast::expr, cx: {mut found: bool}, v| {\n             if !cx.found {"}, {"sha": "5de7ebadb2b315c823af2d4ac66641f8fd5d75f8", "filename": "src/librustc/middle/trans/reachable.rs", "status": "modified", "additions": 21, "deletions": 18, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs?ref=2b92962aa29b0116015f99c1666ecf6288303c65", "patch": "@@ -142,7 +142,8 @@ fn traverse_public_item(cx: ctx, item: @item) {\n }\n \n fn mk_ty_visitor() -> visit::vt<ctx> {\n-    visit::mk_vt(@{visit_ty: traverse_ty, ..*visit::default_visitor()})\n+    visit::mk_vt(@visit::Visitor {visit_ty: traverse_ty,\n+                                  ..*visit::default_visitor()})\n }\n \n fn traverse_ty(ty: @Ty, cx: ctx, v: visit::vt<ctx>) {\n@@ -209,29 +210,31 @@ fn traverse_inline_body(cx: ctx, body: blk) {\n     fn traverse_item(i: @item, cx: ctx, _v: visit::vt<ctx>) {\n       traverse_public_item(cx, i);\n     }\n-     visit::visit_block(body, cx, visit::mk_vt(@{\n+     visit::visit_block(body, cx, visit::mk_vt(@visit::Visitor {\n         visit_expr: traverse_expr,\n         visit_item: traverse_item,\n          ..*visit::default_visitor()\n     }));\n }\n \n fn traverse_all_resources_and_impls(cx: ctx, crate_mod: _mod) {\n-    visit::visit_mod(crate_mod, ast_util::dummy_sp(), 0, cx, visit::mk_vt(@{\n-        visit_expr: |_e, _cx, _v| { },\n-        visit_item: |i, cx, v| {\n-            visit::visit_item(i, cx, v);\n-            match i.node {\n-              item_struct(struct_def, _) if struct_def.dtor.is_some() => {\n-                traverse_public_item(cx, i);\n-              }\n-              item_impl(*) => {\n-                traverse_public_item(cx, i);\n-              }\n-              _ => ()\n-            }\n-        },\n-        ..*visit::default_visitor()\n-    }));\n+    visit::visit_mod(\n+        crate_mod, ast_util::dummy_sp(), 0, cx,\n+        visit::mk_vt(@visit::Visitor {\n+            visit_expr: |_e, _cx, _v| { },\n+            visit_item: |i, cx, v| {\n+                visit::visit_item(i, cx, v);\n+                match i.node {\n+                    item_struct(sdef, _) if sdef.dtor.is_some() => {\n+                        traverse_public_item(cx, i);\n+                    }\n+                    item_impl(*) => {\n+                        traverse_public_item(cx, i);\n+                    }\n+                    _ => ()\n+                }\n+            },\n+            ..*visit::default_visitor()\n+        }));\n }\n "}, {"sha": "e17a9c8c0ede77f68804239b2333d1fdc4e54ee3", "filename": "src/librustc/middle/trans/type_use.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=2b92962aa29b0116015f99c1666ecf6288303c65", "patch": "@@ -340,7 +340,7 @@ fn mark_for_expr(cx: ctx, e: @expr) {\n }\n \n fn handle_body(cx: ctx, body: blk) {\n-    let v = visit::mk_vt(@{\n+    let v = visit::mk_vt(@visit::Visitor {\n         visit_expr: |e, cx, v| {\n             visit::visit_expr(e, cx, v);\n             mark_for_expr(cx, e);"}, {"sha": "d29858e1fa4f702ac5baa366ddd159441748a283", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 95, "deletions": 109, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=2b92962aa29b0116015f99c1666ecf6288303c65", "patch": "@@ -47,15 +47,15 @@ use syntax::ast::*;\n use syntax::ast_util::{is_local, local_def};\n use syntax::ast_util;\n use syntax::codemap::span;\n-use syntax::print::pprust::*;\n+use syntax::print::pprust;\n use syntax::{ast, ast_map};\n use syntax;\n \n export ProvidedMethodSource;\n export ProvidedMethodInfo;\n export ProvidedMethodsMap;\n export InstantiatedTraitRef;\n-export TyVid, IntVid, FloatVid, FnVid, RegionVid, vid;\n+export TyVid, IntVid, FloatVid, FnVid, RegionVid, Vid;\n export br_hashmap;\n export is_instantiable;\n export node_id_to_type;\n@@ -118,7 +118,8 @@ export ty_opaque_closure_ptr, mk_opaque_closure_ptr;\n export ty_opaque_box, mk_opaque_box;\n export ty_float, mk_float, mk_mach_float, type_is_fp;\n export ty_fn, FnTy, FnTyBase, FnMeta, FnSig, mk_fn;\n-export ty_fn_proto, ty_fn_purity, ty_fn_ret, tys_in_fn_ty;\n+export ty_fn_proto, ty_fn_purity, ty_fn_ret, tys_in_fn_sig;\n+export replace_fn_return_type;\n export ty_int, mk_int, mk_mach_int, mk_char;\n export mk_i8, mk_u8, mk_i16, mk_u16, mk_i32, mk_u32, mk_i64, mk_u64;\n export mk_f32, mk_f64;\n@@ -139,7 +140,8 @@ export ty_tup, mk_tup;\n export ty_type, mk_type;\n export ty_uint, mk_uint, mk_mach_uint;\n export ty_uniq, mk_uniq, mk_imm_uniq, type_is_unique_box;\n-export ty_infer, mk_infer, type_is_ty_var, mk_var, mk_int_var, mk_float_var;\n+export ty_infer, mk_infer, type_is_ty_var, mk_var, mk_int_var;\n+export mk_float_var;\n export InferTy, TyVar, IntVar, FloatVar;\n export ValueMode, ReadValue, CopyValue, MoveValue;\n export ty_self, mk_self, type_has_self;\n@@ -222,7 +224,6 @@ export terr_regions_insufficiently_polymorphic;\n export terr_regions_overly_polymorphic;\n export terr_proto_mismatch;\n export terr_fn, terr_trait;\n-export purity_to_str;\n export onceness_to_str;\n export param_tys_in_type;\n export eval_repeat_count;\n@@ -519,6 +520,7 @@ pure fn type_id(t: t) -> uint { get(t).id }\n  *   times.\n  * - `region` is the region bound on the function's upvars (often &static).\n  * - `bounds` is the parameter bounds on the function's upvars. */\n+#[deriving_eq]\n struct FnMeta {\n     purity: ast::purity,\n     proto: ast::Proto,\n@@ -533,6 +535,7 @@ struct FnMeta {\n  *\n  * - `inputs` is the list of arguments and their modes.\n  * - `output` is the return type. */\n+#[deriving_eq]\n struct FnSig {\n     inputs: ~[arg],\n     output: t\n@@ -543,9 +546,16 @@ struct FnSig {\n  * type signature.  This particular type is parameterized\n  * by the meta information because, in some cases, the\n  * meta information is inferred. */\n+#[deriving_eq]\n struct FnTyBase<M: cmp::Eq> {\n-    meta: M,\n-    sig: FnSig\n+    meta: M,        // Either FnMeta or FnVid\n+    sig: FnSig      // Types of arguments/return type\n+}\n+\n+impl<M: to_bytes::IterBytes> FnTyBase<M> : to_bytes::IterBytes {\n+    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+        to_bytes::iter_bytes_2(&self.meta, &self.sig, lsb0, f)\n+    }\n }\n \n type FnTy = FnTyBase<FnMeta>;\n@@ -673,7 +683,7 @@ enum sty {\n     ty_param(param_ty), // type parameter\n     ty_self, // special, implicit `self` type parameter\n \n-    ty_infer(InferTy), // soething used only during inference/typeck\n+    ty_infer(InferTy), // something used only during inference/typeck\n     ty_err, // Also only used during inference/typeck, to represent\n             // the type of an erroneous expression (helps cut down\n             // on non-useful type error messages)\n@@ -742,6 +752,7 @@ enum FnVid = uint;\n #[auto_decode]\n enum RegionVid = uint;\n \n+#[deriving_eq]\n enum InferTy {\n     TyVar(TyVid),\n     IntVar(IntVid),\n@@ -753,7 +764,7 @@ impl InferTy : to_bytes::IterBytes {\n         match *self {\n           TyVar(ref tv) => to_bytes::iter_bytes_2(&0u8, tv, lsb0, f),\n           IntVar(ref iv) => to_bytes::iter_bytes_2(&1u8, iv, lsb0, f),\n-          FloatVar(ref fv) => to_bytes::iter_bytes_2(&2u8, fv, lsb0, f)\n+          FloatVar(ref fv) => to_bytes::iter_bytes_2(&2u8, fv, lsb0, f),\n         }\n     }\n }\n@@ -804,61 +815,64 @@ impl param_bound : to_bytes::IterBytes {\n     }\n }\n \n-trait vid {\n+trait Vid {\n     pure fn to_uint() -> uint;\n-    pure fn to_str() -> ~str;\n }\n \n-impl TyVid: vid {\n+impl TyVid: Vid {\n     pure fn to_uint() -> uint { *self }\n+}\n+\n+impl TyVid: ToStr {\n     pure fn to_str() -> ~str { fmt!(\"<V%u>\", self.to_uint()) }\n }\n \n-impl IntVid: vid {\n+impl IntVid: Vid {\n     pure fn to_uint() -> uint { *self }\n+}\n+\n+impl IntVid: ToStr {\n     pure fn to_str() -> ~str { fmt!(\"<VI%u>\", self.to_uint()) }\n }\n \n-impl FloatVid: vid {\n+impl FloatVid: Vid {\n     pure fn to_uint() -> uint { *self }\n+}\n+\n+impl FloatVid: ToStr {\n     pure fn to_str() -> ~str { fmt!(\"<VF%u>\", self.to_uint()) }\n }\n \n-impl FnVid: vid {\n+impl FnVid: Vid {\n     pure fn to_uint() -> uint { *self }\n+}\n+\n+impl FnVid: ToStr {\n     pure fn to_str() -> ~str { fmt!(\"<F%u>\", self.to_uint()) }\n }\n \n-impl RegionVid: vid {\n+impl RegionVid: Vid {\n     pure fn to_uint() -> uint { *self }\n-    pure fn to_str() -> ~str { fmt!(\"%?\", self) }\n }\n \n-impl InferTy {\n-    pure fn to_hash() -> uint {\n-        match self {\n-            TyVar(v) => v.to_uint() << 1,\n-            IntVar(v) => (v.to_uint() << 1) + 1,\n-            FloatVar(v) => (v.to_uint() << 1) + 2\n-        }\n-    }\n+impl RegionVid: ToStr {\n+    pure fn to_str() -> ~str { fmt!(\"%?\", self) }\n+}\n \n+impl FnSig : ToStr {\n     pure fn to_str() -> ~str {\n-        match self {\n-            TyVar(v) => v.to_str(),\n-            IntVar(v) => v.to_str(),\n-            FloatVar(v) => v.to_str()\n-        }\n+        // grr, without tcx not much we can do.\n+        return ~\"(...)\";\n     }\n }\n \n-trait purity_to_str {\n-    pure fn to_str() -> ~str;\n-}\n-\n-impl purity: purity_to_str {\n+impl InferTy: ToStr {\n     pure fn to_str() -> ~str {\n-        purity_to_str(self)\n+        match self {\n+            TyVar(ref v) => v.to_str(),\n+            IntVar(ref v) => v.to_str(),\n+            FloatVar(ref v) => v.to_str()\n+        }\n     }\n }\n \n@@ -1197,7 +1211,7 @@ fn mk_int_var(cx: ctxt, v: IntVid) -> t { mk_infer(cx, IntVar(v)) }\n \n fn mk_float_var(cx: ctxt, v: FloatVid) -> t { mk_infer(cx, FloatVar(v)) }\n \n-fn mk_infer(cx: ctxt, it: InferTy) -> t { mk_t(cx, ty_infer(it)) }\n+fn mk_infer(cx: ctxt, +it: InferTy) -> t { mk_t(cx, ty_infer(it)) }\n \n fn mk_self(cx: ctxt) -> t { mk_t(cx, ty_self) }\n \n@@ -1369,15 +1383,8 @@ fn fold_sty(sty: &sty, fldop: fn(t) -> t) -> sty {\n             ty_tup(new_ts)\n         }\n         ty_fn(ref f) => {\n-            let new_args = f.sig.inputs.map(|a| {\n-                let new_ty = fldop(a.ty);\n-                {mode: a.mode, ty: new_ty}\n-            });\n-            let new_output = fldop(f.sig.output);\n-            ty_fn(FnTyBase {\n-                meta: f.meta,\n-                sig: FnSig {inputs: new_args, output: new_output}\n-            })\n+            let sig = fold_sig(&f.sig, fldop);\n+            ty_fn(FnTyBase {meta: f.meta, sig: sig})\n         }\n         ty_rptr(r, tm) => {\n             ty_rptr(r, {ty: fldop(tm.ty), mutbl: tm.mutbl})\n@@ -1424,8 +1431,8 @@ fn fold_regions_and_ty(\n     fn fold_substs(\n         substs: &substs,\n         fldr: fn(r: Region) -> Region,\n-        fldt: fn(t: t) -> t) -> substs {\n-\n+        fldt: fn(t: t) -> t) -> substs\n+    {\n         {self_r: substs.self_r.map(|r| fldr(*r)),\n          self_ty: substs.self_ty.map(|t| fldt(*t)),\n          tps: substs.tps.map(|t| fldt(*t))}\n@@ -1457,18 +1464,9 @@ fn fold_regions_and_ty(\n         ty::mk_trait(cx, def_id, fold_substs(substs, fldr, fldt), vst)\n       }\n       ty_fn(ref f) => {\n-          let new_region = fldr(f.meta.region);\n-          let new_args = vec::map(f.sig.inputs, |a| {\n-              let new_ty = fldfnt(a.ty);\n-              {mode: a.mode, ty: new_ty}\n-          });\n-          let new_output = fldfnt(f.sig.output);\n-          ty::mk_fn(cx, FnTyBase {\n-              meta: FnMeta {region: new_region,\n-                            ..f.meta},\n-              sig: FnSig {inputs: new_args,\n-                          output: new_output}\n-          })\n+          ty::mk_fn(cx, FnTyBase {meta: FnMeta {region: fldr(f.meta.region),\n+                                                ..f.meta},\n+                                  sig: fold_sig(&f.sig, fldfnt)})\n       }\n       ref sty => {\n         fold_sty_to_ty(cx, sty, |t| fldt(t))\n@@ -1509,6 +1507,7 @@ fn fold_regions(\n {\n     fn do_fold(cx: ctxt, ty: t, in_fn: bool,\n                fldr: fn(Region, bool) -> Region) -> t {\n+        debug!(\"do_fold(ty=%s, in_fn=%b)\", ty_to_str(cx, ty), in_fn);\n         if !type_has_regions(ty) { return ty; }\n         fold_regions_and_ty(\n             cx, ty,\n@@ -2834,8 +2833,9 @@ impl arg : to_bytes::IterBytes {\n \n impl FnMeta : to_bytes::IterBytes {\n     pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n-        to_bytes::iter_bytes_4(&self.purity,\n+        to_bytes::iter_bytes_5(&self.purity,\n                                &self.proto,\n+                               &self.onceness,\n                                &self.region,\n                                &self.bounds,\n                                lsb0, f);\n@@ -2887,10 +2887,7 @@ impl sty : to_bytes::IterBytes {\n           to_bytes::iter_bytes_2(&11u8, fs, lsb0, f),\n \n           ty_fn(ref ft) =>\n-          to_bytes::iter_bytes_3(&12u8,\n-                                 &ft.meta,\n-                                 &ft.sig,\n-                                 lsb0, f),\n+          to_bytes::iter_bytes_2(&12u8, ft, lsb0, f),\n \n           ty_self => 13u8.iter_bytes(lsb0, f),\n \n@@ -2978,8 +2975,8 @@ fn ty_fn_purity(fty: t) -> ast::purity {\n \n pure fn ty_fn_ret(fty: t) -> t {\n     match get(fty).sty {\n-      ty_fn(ref f) => f.sig.output,\n-      _ => fail ~\"ty_fn_ret() called on non-fn type\"\n+        ty_fn(ref f) => f.sig.output,\n+        _ => fail ~\"ty_fn_ret() called on non-fn type\"\n     }\n }\n \n@@ -2997,9 +2994,30 @@ fn ty_region(ty: t) -> Region {\n     }\n }\n \n+fn replace_fn_return_type(tcx: ctxt, fn_type: t, ret_type: t) -> t {\n+    /*!\n+     *\n+     * Returns a new function type based on `fn_type` but returning a value of\n+     * type `ret_type` instead. */\n+\n+    match ty::get(fn_type).sty {\n+        ty::ty_fn(ref fty) => {\n+            ty::mk_fn(tcx, FnTyBase {\n+                meta: fty.meta,\n+                sig: FnSig {output: ret_type, ..copy fty.sig}\n+            })\n+        }\n+        _ => {\n+            tcx.sess.bug(fmt!(\n+                \"replace_fn_ret() invoked with non-fn-type: %s\",\n+                ty_to_str(tcx, fn_type)));\n+        }\n+    }\n+}\n+\n // Returns a vec of all the input and output types of fty.\n-fn tys_in_fn_ty(fty: &FnTy) -> ~[t] {\n-    vec::append_one(fty.sig.inputs.map(|a| a.ty), fty.sig.output)\n+fn tys_in_fn_sig(sig: &FnSig) -> ~[t] {\n+    vec::append_one(sig.inputs.map(|a| a.ty), sig.output)\n }\n \n // Just checks whether it's a fn that returns bool,\n@@ -3444,18 +3462,16 @@ fn type_err_to_str(cx: ctxt, err: &type_err) -> ~str {\n         terr_mismatch => ~\"types differ\",\n         terr_purity_mismatch(values) => {\n             fmt!(\"expected %s fn but found %s fn\",\n-                 purity_to_str(values.expected),\n-                 purity_to_str(values.found))\n+                 values.expected.to_str(), values.found.to_str())\n         }\n         terr_onceness_mismatch(values) => {\n             fmt!(\"expected %s fn but found %s fn\",\n-                 onceness_to_str(values.expected),\n-                 onceness_to_str(values.found))\n+                 values.expected.to_str(), values.found.to_str())\n         }\n         terr_proto_mismatch(values) => {\n             fmt!(\"expected %s closure, found %s closure\",\n-                 proto_ty_to_str(cx, values.expected),\n-                 proto_ty_to_str(cx, values.found))\n+                 proto_ty_to_str(cx, values.expected, false),\n+                 proto_ty_to_str(cx, values.found, false))\n         }\n         terr_mutability => ~\"values differ in mutability\",\n         terr_box_mutability => ~\"boxed values differ in mutability\",\n@@ -3489,7 +3505,8 @@ fn type_err_to_str(cx: ctxt, err: &type_err) -> ~str {\n         terr_arg_count => ~\"incorrect number of function parameters\",\n         terr_mode_mismatch(values) => {\n             fmt!(\"expected argument mode %s, but found %s\",\n-                 mode_to_str(values.expected), mode_to_str(values.found))\n+                 pprust::mode_to_str(values.expected),\n+                 pprust::mode_to_str(values.found))\n         }\n         terr_regions_does_not_outlive(*) => {\n             fmt!(\"lifetime mismatch\")\n@@ -4398,30 +4415,6 @@ impl vstore : cmp::Eq {\n     pure fn ne(&self, other: &vstore) -> bool { !(*self).eq(other) }\n }\n \n-impl FnMeta : cmp::Eq {\n-    pure fn eq(&self, other: &FnMeta) -> bool {\n-        (*self).purity == (*other).purity &&\n-        (*self).proto == (*other).proto &&\n-        (*self).bounds == (*other).bounds\n-    }\n-    pure fn ne(&self, other: &FnMeta) -> bool { !(*self).eq(other) }\n-}\n-\n-impl FnSig : cmp::Eq {\n-    pure fn eq(&self, other: &FnSig) -> bool {\n-        (*self).inputs == (*other).inputs &&\n-        (*self).output == (*other).output\n-    }\n-    pure fn ne(&self, other: &FnSig) -> bool { !(*self).eq(other) }\n-}\n-\n-impl<M: cmp::Eq> FnTyBase<M> : cmp::Eq {\n-    pure fn eq(&self, other: &FnTyBase<M>) -> bool {\n-        (*self).meta == (*other).meta && (*self).sig == (*other).sig\n-    }\n-    pure fn ne(&self, other: &FnTyBase<M>) -> bool { !(*self).eq(other) }\n-}\n-\n impl TyVid : cmp::Eq {\n     pure fn eq(&self, other: &TyVid) -> bool { *(*self) == *(*other) }\n     pure fn ne(&self, other: &TyVid) -> bool { *(*self) != *(*other) }\n@@ -4532,13 +4525,6 @@ impl substs : cmp::Eq {\n     pure fn ne(&self, other: &substs) -> bool { !(*self).eq(other) }\n }\n \n-impl InferTy : cmp::Eq {\n-    pure fn eq(&self, other: &InferTy) -> bool {\n-        (*self).to_hash() == (*other).to_hash()\n-    }\n-    pure fn ne(&self, other: &InferTy) -> bool { !(*self).eq(other) }\n-}\n-\n impl sty : cmp::Eq {\n     pure fn eq(&self, other: &sty) -> bool {\n         match (/*bad*/copy *self) {\n@@ -4651,9 +4637,9 @@ impl sty : cmp::Eq {\n                     _ => false\n                 }\n             }\n-            ty_infer(e0a) => {\n+            ty_infer(ref e0a) => {\n                 match (*other) {\n-                    ty_infer(e0b) => e0a == e0b,\n+                    ty_infer(ref e0b) => *e0a == *e0b,\n                     _ => false\n                 }\n             }"}, {"sha": "05061ccfa13ffc674d9d959b05db4094a767455b", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=2b92962aa29b0116015f99c1666ecf6288303c65", "patch": "@@ -1137,7 +1137,7 @@ impl LookupContext {\n                  ty::item_path_str(self.tcx(), did)));\n     }\n \n-    fn infcx(&self) -> infer::infer_ctxt {\n+    fn infcx(&self) -> @infer::InferCtxt {\n         self.fcx.inh.infcx\n     }\n "}, {"sha": "ff99ee8590a480001cc61222c770e8c627034744", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 40, "deletions": 51, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=2b92962aa29b0116015f99c1666ecf6288303c65", "patch": "@@ -82,15 +82,17 @@ use middle::capture;\n use middle::const_eval;\n use middle::pat_util::pat_id_map;\n use middle::pat_util;\n-use middle::ty::{TyVid, vid, FnTyBase, FnMeta, FnSig, VariantInfo_, field};\n+use middle::ty::{TyVid, Vid, FnTyBase, FnMeta, FnSig, VariantInfo_, field};\n use middle::ty::{ty_param_bounds_and_ty, ty_param_substs_and_ty};\n+use middle::ty::{re_bound, br_cap_avoid};\n use middle::ty;\n use middle::typeck::astconv::{ast_conv, ast_path_to_ty};\n use middle::typeck::astconv::{ast_region_to_region, ast_ty_to_ty};\n use middle::typeck::astconv;\n use middle::typeck::check::_match::pat_ctxt;\n use middle::typeck::check::method::TransformTypeNormally;\n use middle::typeck::check::regionmanip::replace_bound_regions_in_fn_ty;\n+use middle::typeck::check::regionmanip::replace_bound_regions_in_fn_sig;\n use middle::typeck::check::vtable::{LocationInfo, VtableContext};\n use middle::typeck::crate_ctxt;\n use middle::typeck::infer::{resolve_type, force_tvar};\n@@ -187,7 +189,7 @@ type self_info = {\n /// `bar()` will each have their own `fn_ctxt`, but they will\n /// share the inherited fields.\n struct inherited {\n-    infcx: infer::infer_ctxt,\n+    infcx: @infer::InferCtxt,\n     locals: HashMap<ast::node_id, TyVid>,\n     node_types: HashMap<ast::node_id, ty::t>,\n     node_type_substs: HashMap<ast::node_id, ty::substs>,\n@@ -265,15 +267,15 @@ fn blank_fn_ctxt(ccx: @crate_ctxt, rty: ty::t,\n }\n \n fn check_item_types(ccx: @crate_ctxt, crate: @ast::crate) {\n-    let visit = visit::mk_simple_visitor(@{\n+    let visit = visit::mk_simple_visitor(@visit::SimpleVisitor {\n         visit_item: |a| check_item(ccx, a),\n         .. *visit::default_simple_visitor()\n     });\n     visit::visit_crate(*crate, (), visit);\n }\n \n fn check_bare_fn(ccx: @crate_ctxt,\n-                 decl: ast::fn_decl,\n+                 decl: &ast::fn_decl,\n                  body: ast::blk,\n                  id: ast::node_id,\n                  self_info: Option<self_info>) {\n@@ -290,7 +292,7 @@ fn check_bare_fn(ccx: @crate_ctxt,\n fn check_fn(ccx: @crate_ctxt,\n             self_info: Option<self_info>,\n             fn_ty: &ty::FnTy,\n-            decl: ast::fn_decl,\n+            decl: &ast::fn_decl,\n             body: ast::blk,\n             fn_kind: FnKind,\n             old_fcx: Option<@fn_ctxt>) {\n@@ -305,15 +307,15 @@ fn check_fn(ccx: @crate_ctxt,\n     // types with free ones.  The free region references will be bound\n     // the node_id of the body block.\n \n-    let {isr: isr, self_info: self_info, fn_ty: fn_ty} = {\n+    let {isr, self_info, fn_sig} = {\n         let old_isr = option::map_default(&old_fcx, @Nil,\n-                                         |fcx| fcx.in_scope_regions);\n-        replace_bound_regions_in_fn_ty(tcx, old_isr, self_info, fn_ty,\n-                                       |br| ty::re_free(body.node.id, br))\n+                                          |fcx| fcx.in_scope_regions);\n+        replace_bound_regions_in_fn_sig(tcx, old_isr, self_info, &fn_ty.sig,\n+                                        |br| ty::re_free(body.node.id, br))\n     };\n \n-    let arg_tys = fn_ty.sig.inputs.map(|a| a.ty);\n-    let ret_ty = fn_ty.sig.output;\n+    let arg_tys = fn_sig.inputs.map(|a| a.ty);\n+    let ret_ty = fn_sig.output;\n \n     debug!(\"check_fn(arg_tys=%?, ret_ty=%?, self_info.self_ty=%?)\",\n            arg_tys.map(|a| ppaux::ty_to_str(tcx, *a)),\n@@ -406,12 +408,12 @@ fn check_fn(ccx: @crate_ctxt,\n     // resolved when the enclosing scope finishes up.\n     if old_fcx.is_none() {\n         vtable::resolve_in_block(fcx, body);\n-        regionck::regionck_fn(fcx, decl, body);\n+        regionck::regionck_fn(fcx, body);\n         writeback::resolve_type_vars_in_fn(fcx, decl, body, self_info);\n     }\n \n     fn gather_locals(fcx: @fn_ctxt,\n-                     decl: ast::fn_decl,\n+                     decl: &ast::fn_decl,\n                      body: ast::blk,\n                      arg_tys: ~[ty::t],\n                      self_info: Option<self_info>) {\n@@ -503,12 +505,13 @@ fn check_fn(ccx: @crate_ctxt,\n         }\n         fn visit_item(_i: @ast::item, &&_e: (), _v: visit::vt<()>) { }\n \n-        let visit = visit::mk_vt(@{visit_local: visit_local,\n-                                   visit_pat: visit_pat,\n-                                   visit_fn: visit_fn,\n-                                   visit_item: visit_item,\n-                                   visit_block: visit_block,\n-                                   .. *visit::default_visitor()});\n+        let visit = visit::mk_vt(\n+            @visit::Visitor {visit_local: visit_local,\n+                             visit_pat: visit_pat,\n+                             visit_fn: visit_fn,\n+                             visit_item: visit_item,\n+                             visit_block: visit_block,\n+                             ..*visit::default_visitor()});\n \n         (visit.visit_block)(body, (), visit);\n     }\n@@ -520,7 +523,7 @@ fn check_method(ccx: @crate_ctxt, method: @ast::method,\n                      self_id: method.self_id,\n                      def_id: self_impl_def_id,\n                      explicit_self: method.self_ty };\n-    check_bare_fn(ccx, method.decl, method.body, method.id, Some(self_info));\n+    check_bare_fn(ccx, &method.decl, method.body, method.id, Some(self_info));\n }\n \n fn check_no_duplicate_fields(tcx: ty::ctxt, fields:\n@@ -559,7 +562,8 @@ fn check_struct(ccx: @crate_ctxt, struct_def: @ast::struct_def,\n                             spanned { node: ast::sty_by_ref,\n                                       span: ast_util::dummy_sp() } };\n         // typecheck the dtor\n-        check_bare_fn(ccx, ast_util::dtor_dec(),\n+        let dtor_dec = ast_util::dtor_dec();\n+        check_bare_fn(ccx, &dtor_dec,\n                       dtor.node.body, dtor.node.id,\n                       Some(class_t));\n     };\n@@ -583,7 +587,7 @@ fn check_item(ccx: @crate_ctxt, it: @ast::item) {\n                             it.id);\n       }\n       ast::item_fn(ref decl, _, _, ref body) => {\n-        check_bare_fn(ccx, *decl, (*body), it.id, None);\n+        check_bare_fn(ccx, decl, (*body), it.id, None);\n       }\n       ast::item_impl(_, _, ty, ms) => {\n         let rp = ccx.tcx.region_paramd_items.find(it.id);\n@@ -657,7 +661,7 @@ impl @fn_ctxt: ast_conv {\n }\n \n impl @fn_ctxt {\n-    fn infcx() -> infer::infer_ctxt { self.inh.infcx }\n+    fn infcx() -> @infer::InferCtxt { self.inh.infcx }\n     fn search_in_scope_regions(br: ty::bound_region)\n         -> Result<ty::Region, ~str>\n     {\n@@ -1519,7 +1523,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n     fn check_expr_fn(fcx: @fn_ctxt,\n                      expr: @ast::expr,\n                      ast_proto_opt: Option<ast::Proto>,\n-                     decl: ast::fn_decl,\n+                     decl: &ast::fn_decl,\n                      body: ast::blk,\n                      fn_kind: FnKind,\n                      expected: Option<ty::t>) {\n@@ -1569,7 +1573,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n             fcx, fcx,\n             proto, purity, expected_onceness,\n             /*bounds:*/ @~[], /*opt_region:*/ None,\n-            decl, expected_tys, expr.span);\n+            *decl, expected_tys, expr.span);\n \n         // XXX: Bad copy.\n         let fty = ty::mk_fn(tcx, copy fn_ty);\n@@ -2157,12 +2161,12 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n       }\n       ast::expr_fn(proto, ref decl, ref body, cap_clause) => {\n         check_expr_fn(fcx, expr, Some(proto),\n-                      *decl, (*body), Vanilla, expected);\n+                      decl, (*body), Vanilla, expected);\n         capture::check_capture_clause(tcx, expr.id, cap_clause);\n       }\n       ast::expr_fn_block(ref decl, ref body, cap_clause) => {\n         check_expr_fn(fcx, expr, None,\n-                      *decl, (*body), Vanilla, expected);\n+                      decl, (*body), Vanilla, expected);\n         capture::check_capture_clause(tcx, expr.id, cap_clause);\n       }\n       ast::expr_loop_body(b) => {\n@@ -2218,7 +2222,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         match b.node {\n           ast::expr_fn_block(ref decl, ref body, cap_clause) => {\n             check_expr_fn(fcx, b, None,\n-                          *decl, (*body), ForLoop, Some(inner_ty));\n+                          decl, *body, ForLoop, Some(inner_ty));\n             demand::suptype(fcx, b.span, inner_ty, fcx.expr_ty(b));\n             capture::check_capture_clause(tcx, b.id, cap_clause);\n           }\n@@ -2227,20 +2231,12 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         }\n         let block_ty = structurally_resolved_type(\n             fcx, expr.span, fcx.node_ty(b.id));\n-        match ty::get(block_ty).sty {\n-          ty::ty_fn(ref fty) => {\n-              if !err_happened {\n-                  fcx.write_ty(expr.id, ty::mk_fn(tcx, FnTyBase {\n-                      meta: (*fty).meta,\n-                      sig: FnSig {output: ty::mk_bool(tcx),\n-                                  ../*bad*/copy (*fty).sig}\n-                  }));\n-              }\n-              else {\n-                  fcx.write_ty(expr.id, ty::mk_err(fcx.tcx()));\n-              }\n-          }\n-          _ => fail ~\"expected fn type\"\n+        if err_happened {\n+            fcx.write_ty(expr.id, ty::mk_err(fcx.tcx()));\n+        } else {\n+            let loop_body_ty = ty::replace_fn_return_type(tcx, block_ty,\n+                                                          ty::mk_bool(tcx));\n+            fcx.write_ty(expr.id, loop_body_ty);\n         }\n       }\n       ast::expr_do_body(b) => {\n@@ -2267,21 +2263,14 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         match b.node {\n           ast::expr_fn_block(ref decl, ref body, cap_clause) => {\n             check_expr_fn(fcx, b, None,\n-                          *decl, (*body), DoBlock, Some(inner_ty));\n+                          decl, *body, DoBlock, Some(inner_ty));\n             demand::suptype(fcx, b.span, inner_ty, fcx.expr_ty(b));\n             capture::check_capture_clause(tcx, b.id, cap_clause);\n           }\n           // argh\n           _ => fail ~\"expected fn ty\"\n         }\n-        let block_ty = structurally_resolved_type(\n-            fcx, expr.span, fcx.node_ty(b.id));\n-        match ty::get(block_ty).sty {\n-          ty::ty_fn(ref fty) => {\n-            fcx.write_ty(expr.id, ty::mk_fn(tcx, (/*bad*/copy *fty)));\n-          }\n-          _ => fail ~\"expected fn ty\"\n-        }\n+        fcx.write_ty(expr.id, fcx.node_ty(b.id));\n       }\n       ast::expr_block(ref b) => {\n         // If this is an unchecked block, turn off purity-checking"}, {"sha": "3901752ac6834ec147943cb15f2104e127bd5c6a", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=2b92962aa29b0116015f99c1666ecf6288303c65", "patch": "@@ -114,7 +114,6 @@ fn regionck_expr(fcx: @fn_ctxt, e: @ast::expr) {\n }\n \n fn regionck_fn(fcx: @fn_ctxt,\n-               _decl: ast::fn_decl,\n                blk: ast::blk) {\n     let rcx = rcx_({fcx:fcx, mut errors_reported: 0});\n     let v = regionck_visitor();\n@@ -123,12 +122,12 @@ fn regionck_fn(fcx: @fn_ctxt,\n }\n \n fn regionck_visitor() -> rvt {\n-    visit::mk_vt(@{visit_item: visit_item,\n-                   visit_stmt: visit_stmt,\n-                   visit_expr: visit_expr,\n-                   visit_block: visit_block,\n-                   visit_local: visit_local,\n-                   .. *visit::default_visitor()})\n+    visit::mk_vt(@visit::Visitor {visit_item: visit_item,\n+                                  visit_stmt: visit_stmt,\n+                                  visit_expr: visit_expr,\n+                                  visit_block: visit_block,\n+                                  visit_local: visit_local,\n+                                  .. *visit::default_visitor()})\n }\n \n fn visit_item(_item: @ast::item, &&_rcx: @rcx, _v: rvt) {"}, {"sha": "8097b0eca840e46d867c0d5ab387b74564478033", "filename": "src/librustc/middle/typeck/check/regionmanip.rs", "status": "modified", "additions": 35, "deletions": 22, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs?ref=2b92962aa29b0116015f99c1666ecf6288303c65", "patch": "@@ -12,6 +12,7 @@\n \n use core::prelude::*;\n \n+use middle::ty::{FnTyBase};\n use middle::ty;\n use middle::typeck::check::self_info;\n use middle::typeck::isr_alist;\n@@ -25,22 +26,37 @@ use syntax::print::pprust::{expr_to_str};\n \n // Helper functions related to manipulating region types.\n \n-fn replace_bound_regions_in_fn_ty(\n+pub fn replace_bound_regions_in_fn_ty(\n     tcx: ty::ctxt,\n     isr: isr_alist,\n     self_info: Option<self_info>,\n     fn_ty: &ty::FnTy,\n     mapf: fn(ty::bound_region) -> ty::Region) ->\n-    {isr: isr_alist, self_info: Option<self_info>, fn_ty: ty::FnTy} {\n+    {isr: isr_alist, self_info: Option<self_info>, fn_ty: ty::FnTy}\n+{\n+    let {isr, self_info, fn_sig} =\n+        replace_bound_regions_in_fn_sig(\n+            tcx, isr, self_info, &fn_ty.sig, mapf);\n+    {isr: isr,\n+     self_info: self_info,\n+     fn_ty: FnTyBase {meta: fn_ty.meta,\n+                      sig: fn_sig}}\n+}\n \n+pub fn replace_bound_regions_in_fn_sig(\n+    tcx: ty::ctxt,\n+    isr: isr_alist,\n+    self_info: Option<self_info>,\n+    fn_sig: &ty::FnSig,\n+    mapf: fn(ty::bound_region) -> ty::Region) ->\n+    {isr: isr_alist, self_info: Option<self_info>, fn_sig: ty::FnSig}\n+{\n     // Take self_info apart; the self_ty part is the only one we want\n     // to update here.\n-    let (self_ty, rebuild_self_info) = match self_info {\n-      Some(copy s) => (Some(s.self_ty), |t| Some({self_ty: t,.. s})),\n-      None => (None, |_t| None)\n-    };\n+    let self_ty = self_info.map(|s| s.self_ty);\n+    let rebuild_self_info = |t| self_info.map(|s| {self_ty: t, ..*s});\n \n-    let mut all_tys = ty::tys_in_fn_ty(fn_ty);\n+    let mut all_tys = ty::tys_in_fn_sig(fn_sig);\n \n     match self_info {\n       Some({explicit_self: ast::spanned { node: ast::sty_region(m),\n@@ -56,28 +72,26 @@ fn replace_bound_regions_in_fn_ty(\n \n     for self_ty.each |t| { all_tys.push(*t) }\n \n-    debug!(\"replace_bound_regions_in_fn_ty(self_info.self_ty=%?, fn_ty=%s, \\\n-                all_tys=%?)\",\n+    debug!(\"replace_bound_regions_in_fn_sig(self_info.self_ty=%?, fn_sig=%s, \\\n+            all_tys=%?)\",\n            self_ty.map(|t| ppaux::ty_to_str(tcx, *t)),\n-           ppaux::ty_to_str(tcx, ty::mk_fn(tcx, *fn_ty)),\n+           ppaux::fn_sig_to_str(tcx, fn_sig),\n            all_tys.map(|t| ppaux::ty_to_str(tcx, *t)));\n     let _i = indenter();\n \n     let isr = do create_bound_region_mapping(tcx, isr, all_tys) |br| {\n         debug!(\"br=%?\", br);\n         mapf(br)\n     };\n-    let ty_fn = ty::ty_fn(/*bad*/copy *fn_ty);\n-    let t_fn = ty::fold_sty_to_ty(tcx, &ty_fn, |t| {\n+    let new_fn_sig = ty::fold_sig(fn_sig, |t| {\n         replace_bound_regions(tcx, isr, t)\n     });\n     let t_self = self_ty.map(|t| replace_bound_regions(tcx, isr, *t));\n \n-    debug!(\"result of replace_bound_regions_in_fn_ty: self_info.self_ty=%?, \\\n-                fn_ty=%s\",\n+    debug!(\"result of replace_bound_regions_in_fn_sig: self_info.self_ty=%?, \\\n+                fn_sig=%s\",\n            t_self.map(|t| ppaux::ty_to_str(tcx, *t)),\n-           ppaux::ty_to_str(tcx, t_fn));\n-\n+           ppaux::fn_sig_to_str(tcx, &new_fn_sig));\n \n     // Glue updated self_ty back together with its original def_id.\n     let new_self_info: Option<self_info> = match t_self {\n@@ -86,10 +100,8 @@ fn replace_bound_regions_in_fn_ty(\n     };\n \n     return {isr: isr,\n-         self_info: new_self_info,\n-         fn_ty: match ty::get(t_fn).sty { ty::ty_fn(ref o) => /*bad*/copy *o,\n-          _ => tcx.sess.bug(~\"replace_bound_regions_in_fn_ty: impossible\")}};\n-\n+            self_info: new_self_info,\n+            fn_sig: new_fn_sig};\n \n     // Takes `isr`, a (possibly empty) mapping from in-scope region\n     // names (\"isr\"s) to their corresponding regions; `tys`, a list of\n@@ -158,7 +170,7 @@ fn replace_bound_regions_in_fn_ty(\n         ty: ty::t) -> ty::t {\n \n         do ty::fold_regions(tcx, ty) |r, in_fn| {\n-            match r {\n+            let r1 = match r {\n               // As long as we are not within a fn() type, `&T` is\n               // mapped to the free region anon_r.  But within a fn\n               // type, it remains bound.\n@@ -187,7 +199,8 @@ fn replace_bound_regions_in_fn_ty(\n               ty::re_scope(_) |\n               ty::re_free(_, _) |\n               ty::re_infer(_) => r\n-            }\n+            };\n+            r1\n         }\n     }\n }"}, {"sha": "9d309d4996bdd9ffaac0c24e902941f7513459a9", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=2b92962aa29b0116015f99c1666ecf6288303c65", "patch": "@@ -14,7 +14,7 @@ use middle::resolve;\n use middle::ty;\n use middle::typeck::check::{fn_ctxt, impl_self_ty};\n use middle::typeck::check::{structurally_resolved_type};\n-use middle::typeck::infer::{fixup_err_to_str, infer_ctxt};\n+use middle::typeck::infer::{fixup_err_to_str, InferCtxt};\n use middle::typeck::infer::{resolve_and_force_all_but_regions, resolve_type};\n use middle::typeck::infer;\n use middle::typeck::{crate_ctxt, vtable_origin, vtable_param, vtable_res};\n@@ -63,7 +63,7 @@ struct LocationInfo {\n /// callback function to call in case of type error.\n struct VtableContext {\n     ccx: @crate_ctxt,\n-    infcx: infer::infer_ctxt\n+    infcx: @infer::InferCtxt\n }\n \n impl VtableContext {\n@@ -685,8 +685,8 @@ fn early_resolve_expr(ex: @ast::expr, &&fcx: @fn_ctxt, is_early: bool) {\n                             ex.span,\n                             fmt!(\"failed to find an implementation of trait \\\n                                   %s for %s\",\n-                                 ppaux::ty_to_str(fcx.tcx(), target_ty),\n-                                 ppaux::ty_to_str(fcx.tcx(), ty)));\n+                                 fcx.infcx().ty_to_str(target_ty),\n+                                 fcx.infcx().ty_to_str(ty)));\n                     }\n                 }\n                 Some(vtable) => {\n@@ -714,7 +714,7 @@ fn resolve_expr(ex: @ast::expr, &&fcx: @fn_ctxt, v: visit::vt<@fn_ctxt>) {\n // Detect points where a trait-bounded type parameter is\n // instantiated, resolve the impls for the parameters.\n fn resolve_in_block(fcx: @fn_ctxt, bl: ast::blk) {\n-    visit::visit_block(bl, fcx, visit::mk_vt(@{\n+    visit::visit_block(bl, fcx, visit::mk_vt(@visit::Visitor {\n         visit_expr: resolve_expr,\n         visit_item: fn@(_i: @ast::item, &&_e: @fn_ctxt,\n                         _v: visit::vt<@fn_ctxt>) {},"}, {"sha": "b00a3306ceb03d7f84e18e1b9c314413c7a9cb0e", "filename": "src/librustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=2b92962aa29b0116015f99c1666ecf6288303c65", "patch": "@@ -161,9 +161,8 @@ fn visit_expr(e: @ast::expr, wbcx: wb_ctxt, v: wb_vt) {\n     resolve_type_vars_for_node(wbcx, e.span, e.id);\n     resolve_method_map_entry(wbcx.fcx, e.span, e.id);\n     resolve_method_map_entry(wbcx.fcx, e.span, e.callee_id);\n-    match /*bad*/copy e.node {\n-      ast::expr_fn(_, decl, _, _) |\n-      ast::expr_fn_block(decl, _, _) => {\n+    match e.node {\n+      ast::expr_fn_block(ref decl, _, _) => {\n           for vec::each(decl.inputs) |input| {\n               let r_ty = resolve_type_vars_for_node(wbcx, e.span, input.id);\n \n@@ -237,13 +236,13 @@ fn visit_item(_item: @ast::item, _wbcx: wb_ctxt, _v: wb_vt) {\n }\n \n fn mk_visitor() -> visit::vt<wb_ctxt> {\n-    visit::mk_vt(@{visit_item: visit_item,\n-                   visit_stmt: visit_stmt,\n-                   visit_expr: visit_expr,\n-                   visit_block: visit_block,\n-                   visit_pat: visit_pat,\n-                   visit_local: visit_local,\n-                   .. *visit::default_visitor()})\n+    visit::mk_vt(@visit::Visitor {visit_item: visit_item,\n+                                  visit_stmt: visit_stmt,\n+                                  visit_expr: visit_expr,\n+                                  visit_block: visit_block,\n+                                  visit_pat: visit_pat,\n+                                  visit_local: visit_local,\n+                                  .. *visit::default_visitor()})\n }\n \n fn resolve_type_vars_in_expr(fcx: @fn_ctxt, e: @ast::expr) -> bool {\n@@ -254,7 +253,7 @@ fn resolve_type_vars_in_expr(fcx: @fn_ctxt, e: @ast::expr) -> bool {\n }\n \n fn resolve_type_vars_in_fn(fcx: @fn_ctxt,\n-                           decl: ast::fn_decl,\n+                           decl: &ast::fn_decl,\n                            blk: ast::blk,\n                            self_info: Option<self_info>) -> bool {\n     let wbcx = {fcx: fcx, mut success: true};"}, {"sha": "9fa78f01265dfdaebfeb8fdaeaa7005cf38bbd4c", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=2b92962aa29b0116015f99c1666ecf6288303c65", "patch": "@@ -34,7 +34,7 @@ use middle::ty::{ty_opaque_closure_ptr, ty_unboxed_vec, type_kind_ext};\n use middle::ty::{type_is_ty_var};\n use middle::ty;\n use middle::typeck::crate_ctxt;\n-use middle::typeck::infer::{infer_ctxt, can_mk_subty};\n+use middle::typeck::infer::{InferCtxt, can_mk_subty};\n use middle::typeck::infer::{new_infer_ctxt, resolve_ivar};\n use middle::typeck::infer::{resolve_nested_tvar, resolve_type};\n use syntax::ast::{crate, def_id, def_mod, def_ty};\n@@ -51,6 +51,7 @@ use syntax::codemap::span;\n use syntax::parse;\n use syntax::visit::{default_simple_visitor, default_visitor};\n use syntax::visit::{mk_simple_visitor, mk_vt, visit_crate, visit_item};\n+use syntax::visit::{Visitor, SimpleVisitor};\n use syntax::visit::{visit_mod};\n use util::ppaux::ty_to_str;\n \n@@ -69,7 +70,7 @@ struct UniversalQuantificationResult {\n     bounds: @~[param_bounds]\n }\n \n-fn get_base_type(inference_context: infer_ctxt, span: span, original_type: t)\n+fn get_base_type(inference_context: @InferCtxt, span: span, original_type: t)\n               -> Option<t> {\n \n     let resolved_type;\n@@ -116,7 +117,7 @@ fn get_base_type(inference_context: infer_ctxt, span: span, original_type: t)\n }\n \n // Returns the def ID of the base type, if there is one.\n-fn get_base_type_def_id(inference_context: infer_ctxt,\n+fn get_base_type_def_id(inference_context: @InferCtxt,\n                         span: span,\n                         original_type: t)\n                      -> Option<def_id> {\n@@ -181,7 +182,7 @@ fn CoherenceChecker(crate_context: @crate_ctxt) -> CoherenceChecker {\n \n struct CoherenceChecker {\n     crate_context: @crate_ctxt,\n-    inference_context: infer_ctxt,\n+    inference_context: @InferCtxt,\n \n     // A mapping from implementations to the corresponding base type\n     // definition ID.\n@@ -199,7 +200,7 @@ impl CoherenceChecker {\n         // Check implementations and traits. This populates the tables\n         // containing the inherent methods and extension methods. It also\n         // builds up the trait inheritance table.\n-        visit_crate(*crate, (), mk_simple_visitor(@{\n+        visit_crate(*crate, (), mk_simple_visitor(@SimpleVisitor {\n             visit_item: |item| {\n                 debug!(\"(checking coherence) item '%s'\",\n                        self.crate_context.tcx.sess.str_of(item.ident));\n@@ -588,7 +589,7 @@ impl CoherenceChecker {\n \n     // Privileged scope checking\n     fn check_privileged_scopes(crate: @crate) {\n-        visit_crate(*crate, (), mk_vt(@{\n+        visit_crate(*crate, (), mk_vt(@Visitor {\n             visit_item: |item, _context, visitor| {\n                 match /*bad*/copy item.node {\n                     item_mod(module_) => {"}, {"sha": "db99689f0adf985b91e1b700c60db9c972a91449", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=2b92962aa29b0116015f99c1666ecf6288303c65", "patch": "@@ -100,11 +100,13 @@ fn collect_item_types(ccx: @crate_ctxt, crate: @ast::crate) {\n         }\n     }\n \n-    visit::visit_crate(*crate, (), visit::mk_simple_visitor(@{\n-        visit_item: |a|convert(ccx, a),\n-        visit_foreign_item: |a|convert_foreign(ccx, a),\n-        .. *visit::default_simple_visitor()\n-    }));\n+    visit::visit_crate(\n+        *crate, (),\n+        visit::mk_simple_visitor(@visit::SimpleVisitor {\n+            visit_item: |a|convert(ccx, a),\n+            visit_foreign_item: |a|convert_foreign(ccx, a),\n+            .. *visit::default_simple_visitor()\n+        }));\n }\n \n impl @crate_ctxt {"}, {"sha": "62080f4db35887f1fe029487e585228f10c5711b", "filename": "src/librustc/middle/typeck/infer/assignment.rs", "status": "modified", "additions": 26, "deletions": 16, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fassignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fassignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fassignment.rs?ref=2b92962aa29b0116015f99c1666ecf6288303c65", "patch": "@@ -63,16 +63,16 @@ use core::prelude::*;\n use middle::ty::TyVar;\n use middle::ty;\n use middle::typeck::infer::{ares, cres};\n-use middle::typeck::infer::combine::combine_fields;\n+use middle::typeck::infer::combine::CombineFields;\n use middle::typeck::infer::sub::Sub;\n-use middle::typeck::infer::to_str::ToStr;\n+use middle::typeck::infer::to_str::InferStr;\n use util::common::{indent, indenter};\n \n use core::option;\n use syntax::ast::{m_const, m_imm, m_mutbl};\n use syntax::ast;\n \n-fn to_ares(+c: cres<ty::t>) -> ares {\n+fn to_ares<T>(+c: cres<T>) -> ares {\n     match c {\n         Ok(_) => Ok(None),\n         Err(ref e) => Err((*e))\n@@ -82,13 +82,13 @@ fn to_ares(+c: cres<ty::t>) -> ares {\n // Note: Assign is not actually a combiner, in that it does not\n // conform to the same interface, though it performs a similar\n // function.\n-enum Assign = combine_fields;\n+enum Assign = CombineFields;\n \n impl Assign {\n     fn tys(a: ty::t, b: ty::t) -> ares {\n         debug!(\"Assign.tys(%s => %s)\",\n-               a.to_str(self.infcx),\n-               b.to_str(self.infcx));\n+               a.inf_str(self.infcx),\n+               b.inf_str(self.infcx));\n         let _r = indenter();\n \n         debug!(\"Assign.tys: copying first type\");\n@@ -146,8 +146,8 @@ priv impl Assign {\n         +a_bnd: Option<ty::t>, +b_bnd: Option<ty::t>) -> ares {\n \n         debug!(\"Assign.assign_tys_or_sub(%s => %s, %s => %s)\",\n-               a.to_str(self.infcx), b.to_str(self.infcx),\n-               a_bnd.to_str(self.infcx), b_bnd.to_str(self.infcx));\n+               a.inf_str(self.infcx), b.inf_str(self.infcx),\n+               a_bnd.inf_str(self.infcx), b_bnd.inf_str(self.infcx));\n         let _r = indenter();\n \n         fn is_borrowable(v: ty::vstore) -> bool {\n@@ -210,18 +210,28 @@ priv impl Assign {\n                         let nr_b = ty::mk_fn(self.infcx.tcx, ty::FnTyBase {\n                             meta: ty::FnMeta {proto: a_f.meta.proto,\n                                               ..b_f.meta},\n-                            sig: /*bad*/copy b_f.sig\n+                            sig: copy b_f.sig\n                         });\n                         self.try_assign(0, ty::AutoBorrowFn,\n                                         a, nr_b, m_imm, b_f.meta.region)\n                     }\n \n+                    (ty::ty_fn(ref a_f), ty::ty_fn(ref b_f))\n+                    if a_f.meta.proto == ast::ProtoBare => {\n+                        let b1_f = ty::FnTyBase {\n+                            meta: ty::FnMeta {proto: ast::ProtoBare,\n+                                              ..b_f.meta},\n+                            sig: copy b_f.sig\n+                        };\n+                        // Eventually we will need to add some sort of\n+                        // adjustment here so that trans can add an\n+                        // extra NULL env pointer:\n+                        to_ares(Sub(*self).fns(a_f, &b1_f))\n+                    }\n+\n                     // check for &T being assigned to *T:\n                     (ty::ty_rptr(_, ref a_t), ty::ty_ptr(ref b_t)) => {\n-                        match Sub(*self).mts(*a_t, *b_t) {\n-                            Ok(_) => Ok(None),\n-                            Err(ref e) => Err((*e))\n-                        }\n+                        to_ares(Sub(*self).mts(*a_t, *b_t))\n                     }\n \n                     // otherwise, assignment follows normal subtype rules:\n@@ -252,10 +262,10 @@ priv impl Assign {\n                   r_b: ty::Region) -> ares {\n \n         debug!(\"try_assign(a=%s, nr_b=%s, m=%?, r_b=%s)\",\n-               a.to_str(self.infcx),\n-               nr_b.to_str(self.infcx),\n+               a.inf_str(self.infcx),\n+               nr_b.inf_str(self.infcx),\n                m,\n-               r_b.to_str(self.infcx));\n+               r_b.inf_str(self.infcx));\n \n         do indent {\n             let sub = Sub(*self);"}, {"sha": "c5e99bc5c03623a0673cce0f5a0456fbfa9eb207", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 81, "deletions": 55, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=2b92962aa29b0116015f99c1666ecf6288303c65", "patch": "@@ -61,8 +61,8 @@ use middle::ty;\n use middle::typeck::infer::glb::Glb;\n use middle::typeck::infer::lub::Lub;\n use middle::typeck::infer::sub::Sub;\n-use middle::typeck::infer::to_str::ToStr;\n-use middle::typeck::infer::{cres, infer_ctxt, ures};\n+use middle::typeck::infer::to_str::InferStr;\n+use middle::typeck::infer::{cres, InferCtxt, ures, IntType, UintType};\n use util::common::indent;\n \n use core::result::{iter_vec2, map_vec2};\n@@ -73,8 +73,8 @@ use syntax::codemap::span;\n \n fn macros() { include!(\"macros.rs\"); } // FIXME(#3114): Macro import/export.\n \n-trait combine {\n-    fn infcx() -> infer_ctxt;\n+trait Combine {\n+    fn infcx() -> @InferCtxt;\n     fn tag() -> ~str;\n     fn a_is_expected() -> bool;\n     fn span() -> span;\n@@ -105,13 +105,13 @@ trait combine {\n                a: ty::vstore, b: ty::vstore) -> cres<ty::vstore>;\n }\n \n-pub struct combine_fields {\n-    infcx: infer_ctxt,\n+pub struct CombineFields {\n+    infcx: @InferCtxt,\n     a_is_expected: bool,\n     span: span,\n }\n \n-fn expected_found<C: combine,T>(\n+fn expected_found<C:Combine,T>(\n     self: &C, +a: T, +b: T) -> ty::expected_found<T> {\n \n     if self.a_is_expected() {\n@@ -121,7 +121,7 @@ fn expected_found<C: combine,T>(\n     }\n }\n \n-pub fn eq_tys<C: combine>(self: &C, a: ty::t, b: ty::t) -> ures {\n+pub fn eq_tys<C:Combine>(self: &C, a: ty::t, b: ty::t) -> ures {\n     let suber = self.sub();\n     do self.infcx().try {\n         do suber.tys(a, b).chain |_ok| {\n@@ -130,10 +130,10 @@ pub fn eq_tys<C: combine>(self: &C, a: ty::t, b: ty::t) -> ures {\n     }\n }\n \n-fn eq_regions<C: combine>(self: &C, a: ty::Region, b: ty::Region) -> ures {\n+fn eq_regions<C:Combine>(self: &C, a: ty::Region, b: ty::Region) -> ures {\n     debug!(\"eq_regions(%s, %s)\",\n-           a.to_str(self.infcx()),\n-           b.to_str(self.infcx()));\n+           a.inf_str(self.infcx()),\n+           b.inf_str(self.infcx()));\n     let sub = self.sub();\n     do indent {\n         self.infcx().try(|| {\n@@ -152,7 +152,7 @@ fn eq_regions<C: combine>(self: &C, a: ty::Region, b: ty::Region) -> ures {\n     }\n }\n \n-fn eq_opt_regions<C:combine>(\n+fn eq_opt_regions<C:Combine>(\n     self: &C,\n     a: Option<ty::Region>,\n     b: Option<ty::Region>) -> cres<Option<ty::Region>> {\n@@ -174,17 +174,17 @@ fn eq_opt_regions<C:combine>(\n         self.infcx().tcx.sess.bug(\n             fmt!(\"substitution a had opt_region %s and \\\n                   b had opt_region %s\",\n-                 a.to_str(self.infcx()),\n-                 b.to_str(self.infcx())));\n+                 a.inf_str(self.infcx()),\n+                 b.inf_str(self.infcx())));\n       }\n     }\n }\n \n-fn super_substs<C:combine>(\n+fn super_substs<C:Combine>(\n     self: &C, did: ast::def_id,\n     a: &ty::substs, b: &ty::substs) -> cres<ty::substs> {\n \n-    fn relate_region_param<C:combine>(\n+    fn relate_region_param<C:Combine>(\n         self: &C,\n         did: ast::def_id,\n         a: Option<ty::Region>,\n@@ -220,8 +220,8 @@ fn super_substs<C:combine>(\n             self.infcx().tcx.sess.bug(\n                 fmt!(\"substitution a had opt_region %s and \\\n                       b had opt_region %s with variance %?\",\n-                      a.to_str(self.infcx()),\n-                      b.to_str(self.infcx()),\n+                      a.inf_str(self.infcx()),\n+                      b.inf_str(self.infcx()),\n                       polyty.region_param));\n           }\n         }\n@@ -238,7 +238,7 @@ fn super_substs<C:combine>(\n     }\n }\n \n-fn super_tps<C:combine>(\n+fn super_tps<C:Combine>(\n     self: &C, as_: &[ty::t], bs: &[ty::t]) -> cres<~[ty::t]> {\n \n     // Note: type parameters are always treated as *invariant*\n@@ -256,7 +256,7 @@ fn super_tps<C:combine>(\n     }\n }\n \n-fn super_self_tys<C:combine>(\n+fn super_self_tys<C:Combine>(\n     self: &C, a: Option<ty::t>, b: Option<ty::t>) -> cres<Option<ty::t>> {\n \n     // Note: the self type parameter is (currently) always treated as\n@@ -279,7 +279,17 @@ fn super_self_tys<C:combine>(\n     }\n }\n \n-fn super_flds<C:combine>(\n+fn super_protos<C: Combine>(\n+    self: &C, p1: ast::Proto, p2: ast::Proto) -> cres<ast::Proto>\n+{\n+    if p1 == p2 {\n+        Ok(p1)\n+    } else {\n+        Err(ty::terr_proto_mismatch(expected_found(self, p1, p2)))\n+    }\n+}\n+\n+fn super_flds<C:Combine>(\n     self: &C, a: ty::field, b: ty::field) -> cres<ty::field> {\n \n     if a.ident == b.ident {\n@@ -292,15 +302,15 @@ fn super_flds<C:combine>(\n     }\n }\n \n-fn super_modes<C:combine>(\n+fn super_modes<C:Combine>(\n     self: &C, a: ast::mode, b: ast::mode)\n     -> cres<ast::mode> {\n \n     let tcx = self.infcx().tcx;\n     ty::unify_mode(tcx, expected_found(self, a, b))\n }\n \n-fn super_args<C:combine>(\n+fn super_args<C:Combine>(\n     self: &C, a: ty::arg, b: ty::arg)\n     -> cres<ty::arg> {\n \n@@ -311,7 +321,7 @@ fn super_args<C:combine>(\n     }\n }\n \n-fn super_vstores<C:combine>(\n+fn super_vstores<C:Combine>(\n     self: &C, vk: ty::terr_vstore_kind,\n     a: ty::vstore, b: ty::vstore) -> cres<ty::vstore>\n {\n@@ -334,7 +344,7 @@ fn super_vstores<C:combine>(\n     }\n }\n \n-fn super_fn_metas<C:combine>(\n+fn super_fn_metas<C:Combine>(\n     self: &C, a_f: &ty::FnMeta, b_f: &ty::FnMeta) -> cres<ty::FnMeta>\n {\n     let p = if_ok!(self.protos(a_f.proto, b_f.proto));\n@@ -343,17 +353,18 @@ fn super_fn_metas<C:combine>(\n     let onceness = if_ok!(self.oncenesses(a_f.onceness, b_f.onceness));\n     Ok(FnMeta {purity: purity,\n                proto: p,\n-               region: r,\n                onceness: onceness,\n+               region: r,\n                bounds: a_f.bounds}) // XXX: This is wrong!\n }\n \n-fn super_fn_sigs<C:combine>(\n-    self: &C, a_f: &ty::FnSig, b_f: &ty::FnSig) -> cres<ty::FnSig> {\n-    fn argvecs<C:combine>(self: &C,\n+fn super_fn_sigs<C:Combine>(\n+    self: &C, a_f: &ty::FnSig, b_f: &ty::FnSig) -> cres<ty::FnSig>\n+{\n+    fn argvecs<C:Combine>(self: &C,\n                           +a_args: ~[ty::arg],\n-                          +b_args: ~[ty::arg]) -> cres<~[ty::arg]> {\n-\n+                          +b_args: ~[ty::arg]) -> cres<~[ty::arg]>\n+    {\n         if vec::same_length(a_args, b_args) {\n             map_vec2(a_args, b_args, |a, b| self.args(*a, *b))\n         } else {\n@@ -369,19 +380,17 @@ fn super_fn_sigs<C:combine>(\n     }\n }\n \n-fn super_fns<C:combine>(\n+fn super_fns<C:Combine>(\n     self: &C, a_f: &ty::FnTy, b_f: &ty::FnTy) -> cres<ty::FnTy>\n {\n-    do self.fn_metas(&a_f.meta, &b_f.meta).chain |m| {\n-        do self.fn_sigs(&a_f.sig, &b_f.sig).chain |s| {\n-            Ok(FnTyBase {meta: m, sig: s})\n-        }\n-    }\n+    let m = if_ok!(self.fn_metas(&a_f.meta, &b_f.meta));\n+    let s = if_ok!(self.fn_sigs(&a_f.sig, &b_f.sig));\n+    Ok(FnTyBase {meta: m, sig: s})\n }\n \n-fn super_tys<C:combine>(\n-    self: &C, a: ty::t, b: ty::t) -> cres<ty::t> {\n-\n+fn super_tys<C:Combine>(\n+    self: &C, a: ty::t, b: ty::t) -> cres<ty::t>\n+{\n     let tcx = self.infcx().tcx;\n     match (/*bad*/copy ty::get(a).sty, /*bad*/copy ty::get(b).sty) {\n       // The \"subtype\" ought to be handling cases involving bot or var:\n@@ -392,32 +401,49 @@ fn super_tys<C:combine>(\n         tcx.sess.bug(\n             fmt!(\"%s: bot and var types should have been handled (%s,%s)\",\n                  self.tag(),\n-                 a.to_str(self.infcx()),\n-                 b.to_str(self.infcx())));\n+                 a.inf_str(self.infcx()),\n+                 b.inf_str(self.infcx())));\n       }\n \n       // Relate integral variables to other types\n       (ty::ty_infer(IntVar(a_id)), ty::ty_infer(IntVar(b_id))) => {\n-        self.infcx().int_vars(a_id, b_id).then(|| Ok(a) )\n+        if_ok!(self.infcx().simple_vars(&self.infcx().int_var_bindings,\n+                                        ty::terr_no_integral_type,\n+                                        a_id, b_id));\n+        Ok(a)\n       }\n-      (ty::ty_infer(IntVar(a_id)), ty::ty_int(_)) |\n-      (ty::ty_infer(IntVar(a_id)), ty::ty_uint(_)) => {\n-        self.infcx().int_var_sub_t(a_id, b).then(|| Ok(a) )\n+      (ty::ty_infer(IntVar(v_id)), ty::ty_int(v)) |\n+      (ty::ty_int(v), ty::ty_infer(IntVar(v_id))) => {\n+        if v == ast::ty_char {\n+            Err(ty::terr_integer_as_char)\n+        } else {\n+            if_ok!(self.infcx().simple_var_t(&self.infcx().int_var_bindings,\n+                                             ty::terr_no_integral_type,\n+                                             v_id, IntType(v)));\n+            Ok(ty::mk_mach_int(tcx, v))\n+        }\n       }\n-      (ty::ty_int(_), ty::ty_infer(IntVar(b_id))) |\n-      (ty::ty_uint(_), ty::ty_infer(IntVar(b_id))) => {\n-        self.infcx().t_sub_int_var(a, b_id).then(|| Ok(a) )\n+      (ty::ty_infer(IntVar(v_id)), ty::ty_uint(v)) |\n+      (ty::ty_uint(v), ty::ty_infer(IntVar(v_id))) => {\n+        if_ok!(self.infcx().simple_var_t(&self.infcx().int_var_bindings,\n+                                         ty::terr_no_integral_type,\n+                                         v_id, UintType(v)));\n+        Ok(ty::mk_mach_uint(tcx, v))\n       }\n \n       // Relate floating-point variables to other types\n       (ty::ty_infer(FloatVar(a_id)), ty::ty_infer(FloatVar(b_id))) => {\n-        self.infcx().float_vars(a_id, b_id).then(|| Ok(a) )\n-      }\n-      (ty::ty_infer(FloatVar(a_id)), ty::ty_float(_)) => {\n-        self.infcx().float_var_sub_t(a_id, b).then(|| Ok(a) )\n+        if_ok!(self.infcx().simple_vars(&self.infcx().float_var_bindings,\n+                                        ty::terr_no_floating_point_type,\n+                                        a_id, b_id));\n+        Ok(a)\n       }\n-      (ty::ty_float(_), ty::ty_infer(FloatVar(b_id))) => {\n-        self.infcx().t_sub_float_var(a, b_id).then(|| Ok(a) )\n+      (ty::ty_infer(FloatVar(v_id)), ty::ty_float(v)) |\n+      (ty::ty_float(v), ty::ty_infer(FloatVar(v_id))) => {\n+        if_ok!(self.infcx().simple_var_t(&self.infcx().float_var_bindings,\n+                                         ty::terr_no_floating_point_type,\n+                                         v_id, v));\n+        Ok(ty::mk_mach_float(tcx, v))\n       }\n \n       (ty::ty_int(_), _) |"}, {"sha": "68adeeb82db697022c6d91296e01793cbf557a1f", "filename": "src/librustc/middle/typeck/infer/floating.rs", "status": "removed", "additions": 0, "deletions": 64, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/11a307294a83c2651405137763c9d620ab3fc7e7/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ffloating.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11a307294a83c2651405137763c9d620ab3fc7e7/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ffloating.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ffloating.rs?ref=11a307294a83c2651405137763c9d620ab3fc7e7", "patch": "@@ -1,64 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/*!\n-\n-Code related to floating-point type inference.\n-\n-*/\n-\n-use core::prelude::*;\n-\n-use middle::ty::{get, ty_float};\n-use middle::ty;\n-use middle::typeck::infer::to_str::ToStr;\n-\n-use core::uint;\n-use syntax::ast;\n-\n-// Bitvector to represent sets of floating-point types.\n-pub enum float_ty_set = uint;\n-\n-// Constants representing singleton sets containing each of the floating-point\n-// types.\n-pub const FLOAT_TY_SET_EMPTY: uint = 0b000u;\n-pub const FLOAT_TY_SET_FLOAT: uint = 0b001u;\n-pub const FLOAT_TY_SET_F32:   uint = 0b010u;\n-pub const FLOAT_TY_SET_F64:   uint = 0b100u;\n-\n-pub fn float_ty_set_all() -> float_ty_set {\n-    float_ty_set(FLOAT_TY_SET_FLOAT | FLOAT_TY_SET_F32 | FLOAT_TY_SET_F64)\n-}\n-\n-pub fn intersection(a: float_ty_set, b: float_ty_set) -> float_ty_set {\n-    float_ty_set(*a & *b)\n-}\n-\n-pub fn single_type_contained_in(tcx: ty::ctxt, a: float_ty_set)\n-                             -> Option<ty::t> {\n-    debug!(\"single_type_contained_in(a=%s)\", uint::to_str(*a, 10));\n-\n-    if *a == FLOAT_TY_SET_FLOAT { return Some(ty::mk_float(tcx)); }\n-    if *a == FLOAT_TY_SET_F32   { return Some(ty::mk_f32(tcx));   }\n-    if *a == FLOAT_TY_SET_F64   { return Some(ty::mk_f64(tcx));   }\n-    return None;\n-}\n-\n-pub fn convert_floating_point_ty_to_float_ty_set(tcx: ty::ctxt, t: ty::t)\n-                                              -> float_ty_set {\n-    match get(t).sty {\n-        ty::ty_float(ast::ty_f)     => float_ty_set(FLOAT_TY_SET_FLOAT),\n-        ty::ty_float(ast::ty_f32)   => float_ty_set(FLOAT_TY_SET_F32),\n-        ty::ty_float(ast::ty_f64)   => float_ty_set(FLOAT_TY_SET_F64),\n-        _ => tcx.sess.bug(~\"non-floating-point type passed to \\\n-                            convert_floating_point_ty_to_float_ty_set()\")\n-    }\n-}\n-"}, {"sha": "4d697ad3433e86cfabb3babb96e278f503a85416", "filename": "src/librustc/middle/typeck/infer/glb.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs?ref=2b92962aa29b0116015f99c1666ecf6288303c65", "patch": "@@ -17,18 +17,18 @@ use middle::typeck::infer::glb::Glb;\n use middle::typeck::infer::lattice::*;\n use middle::typeck::infer::lub::Lub;\n use middle::typeck::infer::sub::Sub;\n-use middle::typeck::infer::to_str::ToStr;\n+use middle::typeck::infer::to_str::InferStr;\n use middle::typeck::isr_alist;\n use syntax::ast::{Many, Once, extern_fn, impure_fn, m_const, m_imm, m_mutbl};\n use syntax::ast::{noreturn, pure_fn, ret_style, return_val, unsafe_fn};\n use util::ppaux::mt_to_str;\n \n use std::list;\n \n-enum Glb = combine_fields;  // \"greatest lower bound\" (common subtype)\n+enum Glb = CombineFields;  // \"greatest lower bound\" (common subtype)\n \n-impl Glb: combine {\n-    fn infcx() -> infer_ctxt { self.infcx }\n+impl Glb: Combine {\n+    fn infcx() -> @InferCtxt { self.infcx }\n     fn tag() -> ~str { ~\"glb\" }\n     fn a_is_expected() -> bool { self.a_is_expected }\n     fn span() -> span { self.span }\n@@ -94,10 +94,6 @@ impl Glb: combine {\n         Lub(*self).tys(a, b)\n     }\n \n-    fn protos(p1: ast::Proto, p2: ast::Proto) -> cres<ast::Proto> {\n-        if p1 == p2 {Ok(p1)} else {Ok(ast::ProtoBare)}\n-    }\n-\n     fn purities(a: purity, b: purity) -> cres<purity> {\n         match (a, b) {\n           (pure_fn, _) | (_, pure_fn) => Ok(pure_fn),\n@@ -117,8 +113,8 @@ impl Glb: combine {\n     fn regions(a: ty::Region, b: ty::Region) -> cres<ty::Region> {\n         debug!(\"%s.regions(%?, %?)\",\n                self.tag(),\n-               a.to_str(self.infcx),\n-               b.to_str(self.infcx));\n+               a.inf_str(self.infcx),\n+               b.inf_str(self.infcx));\n \n         do indent {\n             self.infcx.region_vars.glb_regions(self.span, a, b)\n@@ -130,7 +126,7 @@ impl Glb: combine {\n     }\n \n     fn tys(a: ty::t, b: ty::t) -> cres<ty::t> {\n-        lattice_tys(&self, a, b)\n+        super_lattice_tys(&self, a, b)\n     }\n \n     // Traits please (FIXME: #2794):\n@@ -152,12 +148,12 @@ impl Glb: combine {\n         super_args(&self, a, b)\n     }\n \n-    fn fns(a: &ty::FnTy, b: &ty::FnTy) -> cres<ty::FnTy> {\n+    fn fn_sigs(a: &ty::FnSig, b: &ty::FnSig) -> cres<ty::FnSig> {\n         // Note: this is a subtle algorithm.  For a full explanation,\n         // please see the large comment in `region_inference.rs`.\n \n-        debug!(\"%s.fns(%?, %?)\",\n-               self.tag(), a.to_str(self.infcx), b.to_str(self.infcx));\n+        debug!(\"%s.fn_sigs(%?, %?)\",\n+               self.tag(), a.inf_str(self.infcx), b.inf_str(self.infcx));\n         let _indenter = indenter();\n \n         // Take a snapshot.  We'll never roll this back, but in later\n@@ -177,20 +173,20 @@ impl Glb: combine {\n         let b_vars = var_ids(&self, b_isr);\n \n         // Collect constraints.\n-        let fn_ty0 = if_ok!(super_fns(&self, &a_with_fresh, &b_with_fresh));\n-        debug!(\"fn_ty0 = %s\", fn_ty0.to_str(self.infcx));\n+        let sig0 = if_ok!(super_fn_sigs(&self, &a_with_fresh, &b_with_fresh));\n+        debug!(\"sig0 = %s\", sig0.inf_str(self.infcx));\n \n         // Generalize the regions appearing in fn_ty0 if possible\n         let new_vars =\n             self.infcx.region_vars.vars_created_since_snapshot(snapshot);\n-        let fn_ty1 =\n+        let sig1 =\n             self.infcx.fold_regions_in_sig(\n-                &fn_ty0,\n+                &sig0,\n                 |r, _in_fn| generalize_region(&self, snapshot,\n                                               new_vars, a_isr, a_vars, b_vars,\n                                               r));\n-        debug!(\"fn_ty1 = %s\", fn_ty1.to_str(self.infcx));\n-        return Ok(move fn_ty1);\n+        debug!(\"sig1 = %s\", sig1.inf_str(self.infcx));\n+        return Ok(move sig1);\n \n         fn generalize_region(self: &Glb,\n                              snapshot: uint,\n@@ -271,12 +267,16 @@ impl Glb: combine {\n         }\n     }\n \n-    fn fn_metas(a: &ty::FnMeta, b: &ty::FnMeta) -> cres<ty::FnMeta> {\n-        super_fn_metas(&self, a, b)\n+    fn protos(p1: ast::Proto, p2: ast::Proto) -> cres<ast::Proto> {\n+        super_protos(&self, p1, p2)\n     }\n \n-    fn fn_sigs(a: &ty::FnSig, b: &ty::FnSig) -> cres<ty::FnSig> {\n-        super_fn_sigs(&self, a, b)\n+    fn fns(a: &ty::FnTy, b: &ty::FnTy) -> cres<ty::FnTy> {\n+        super_fns(&self, a, b)\n+    }\n+\n+    fn fn_metas(a: &ty::FnMeta, b: &ty::FnMeta) -> cres<ty::FnMeta> {\n+        super_fn_metas(&self, a, b)\n     }\n \n     fn substs(did: ast::def_id,"}, {"sha": "aa67c1371f91771edc0e2513046528c16b5d01c1", "filename": "src/librustc/middle/typeck/infer/integral.rs", "status": "removed", "additions": 0, "deletions": 95, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/11a307294a83c2651405137763c9d620ab3fc7e7/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fintegral.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11a307294a83c2651405137763c9d620ab3fc7e7/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fintegral.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fintegral.rs?ref=11a307294a83c2651405137763c9d620ab3fc7e7", "patch": "@@ -1,95 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/*!\n-\n-Code related to integral type inference.\n-\n-*/\n-\n-use core::prelude::*;\n-\n-use middle::ty::{get, ty_int, ty_uint};\n-use middle::ty;\n-use middle::typeck::infer::to_str::ToStr;\n-\n-use core::uint;\n-use syntax::ast;\n-\n-// Bitvector to represent sets of integral types\n-enum int_ty_set = uint;\n-\n-// Constants representing singleton sets containing each of the\n-// integral types\n-const INT_TY_SET_EMPTY : uint = 0b00_0000_0000u;\n-const INT_TY_SET_i8    : uint = 0b00_0000_0001u;\n-const INT_TY_SET_u8    : uint = 0b00_0000_0010u;\n-const INT_TY_SET_i16   : uint = 0b00_0000_0100u;\n-const INT_TY_SET_u16   : uint = 0b00_0000_1000u;\n-const INT_TY_SET_i32   : uint = 0b00_0001_0000u;\n-const INT_TY_SET_u32   : uint = 0b00_0010_0000u;\n-const INT_TY_SET_i64   : uint = 0b00_0100_0000u;\n-const INT_TY_SET_u64   : uint = 0b00_1000_0000u;\n-const INT_TY_SET_i     : uint = 0b01_0000_0000u;\n-const INT_TY_SET_u     : uint = 0b10_0000_0000u;\n-\n-fn int_ty_set_all()  -> int_ty_set {\n-    int_ty_set(INT_TY_SET_i8  | INT_TY_SET_u8 |\n-               INT_TY_SET_i16 | INT_TY_SET_u16 |\n-               INT_TY_SET_i32 | INT_TY_SET_u32 |\n-               INT_TY_SET_i64 | INT_TY_SET_u64 |\n-               INT_TY_SET_i   | INT_TY_SET_u)\n-}\n-\n-fn intersection(a: int_ty_set, b: int_ty_set) -> int_ty_set {\n-    int_ty_set(*a & *b)\n-}\n-\n-fn single_type_contained_in(tcx: ty::ctxt, a: int_ty_set) ->\n-    Option<ty::t> {\n-    debug!(\"single_type_contained_in(a=%s)\", uint::to_str(*a, 10u));\n-\n-    if *a == INT_TY_SET_i8    { return Some(ty::mk_i8(tcx)); }\n-    if *a == INT_TY_SET_u8    { return Some(ty::mk_u8(tcx)); }\n-    if *a == INT_TY_SET_i16   { return Some(ty::mk_i16(tcx)); }\n-    if *a == INT_TY_SET_u16   { return Some(ty::mk_u16(tcx)); }\n-    if *a == INT_TY_SET_i32   { return Some(ty::mk_i32(tcx)); }\n-    if *a == INT_TY_SET_u32   { return Some(ty::mk_u32(tcx)); }\n-    if *a == INT_TY_SET_i64   { return Some(ty::mk_i64(tcx)); }\n-    if *a == INT_TY_SET_u64   { return Some(ty::mk_u64(tcx)); }\n-    if *a == INT_TY_SET_i     { return Some(ty::mk_int(tcx)); }\n-    if *a == INT_TY_SET_u     { return Some(ty::mk_uint(tcx)); }\n-    return None;\n-}\n-\n-fn convert_integral_ty_to_int_ty_set(tcx: ty::ctxt, t: ty::t)\n-    -> int_ty_set {\n-\n-    match get(t).sty {\n-      ty_int(int_ty) => match int_ty {\n-        ast::ty_i8   => int_ty_set(INT_TY_SET_i8),\n-        ast::ty_i16  => int_ty_set(INT_TY_SET_i16),\n-        ast::ty_i32  => int_ty_set(INT_TY_SET_i32),\n-        ast::ty_i64  => int_ty_set(INT_TY_SET_i64),\n-        ast::ty_i    => int_ty_set(INT_TY_SET_i),\n-        ast::ty_char => tcx.sess.bug(\n-            ~\"char type passed to convert_integral_ty_to_int_ty_set()\")\n-      },\n-      ty_uint(uint_ty) => match uint_ty {\n-        ast::ty_u8  => int_ty_set(INT_TY_SET_u8),\n-        ast::ty_u16 => int_ty_set(INT_TY_SET_u16),\n-        ast::ty_u32 => int_ty_set(INT_TY_SET_u32),\n-        ast::ty_u64 => int_ty_set(INT_TY_SET_u64),\n-        ast::ty_u   => int_ty_set(INT_TY_SET_u)\n-      },\n-      _ => tcx.sess.bug(~\"non-integral type passed to \\\n-                          convert_integral_ty_to_int_ty_set()\")\n-    }\n-}"}, {"sha": "9783aee0848c9213b46c9bd1e0a8604784412f28", "filename": "src/librustc/middle/typeck/infer/lattice.rs", "status": "modified", "additions": 425, "deletions": 84, "changes": 509, "blob_url": "https://github.com/rust-lang/rust/blob/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs?ref=2b92962aa29b0116015f99c1666ecf6288303c65", "patch": "@@ -8,170 +8,511 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+/*!\n+ *\n+ * # Lattice Variables\n+ *\n+ * This file contains generic code for operating on inference variables\n+ * that are characterized by an upper- and lower-bound.  The logic and\n+ * reasoning is explained in detail in the large comment in `infer.rs`.\n+ *\n+ * The code in here is defined quite generically so that it can be\n+ * applied both to type variables, which represent types being inferred,\n+ * and fn variables, which represent function types being inferred.\n+ * It may eventually be applied to ther types as well, who knows.\n+ * In some cases, the functions are also generic with respect to the\n+ * operation on the lattice (GLB vs LUB).\n+ *\n+ * Although all the functions are generic, we generally write the\n+ * comments in a way that is specific to type variables and the LUB\n+ * operation.  It's just easier that way.\n+ *\n+ * In general all of the functions are defined parametrically\n+ * over a `LatticeValue`, which is a value defined with respect to\n+ * a lattice.\n+ */\n+\n use core::prelude::*;\n \n use middle::ty::{RegionVid, TyVar};\n use middle::ty;\n+use middle::typeck::isr_alist;\n use middle::typeck::infer::*;\n use middle::typeck::infer::combine::*;\n use middle::typeck::infer::glb::Glb;\n use middle::typeck::infer::lub::Lub;\n use middle::typeck::infer::unify::*;\n-use middle::typeck::infer::to_str::ToStr;\n-use middle::typeck::isr_alist;\n+use middle::typeck::infer::sub::Sub;\n+use middle::typeck::infer::lub::Lub;\n+use middle::typeck::infer::glb::Glb;\n+use middle::typeck::infer::to_str::InferStr;\n \n use std::list;\n \n+trait LatticeValue {\n+    static fn sub(cf: &CombineFields, a: &self, b: &self) -> ures;\n+    static fn lub(cf: &CombineFields, a: &self, b: &self) -> cres<self>;\n+    static fn glb(cf: &CombineFields, a: &self, b: &self) -> cres<self>;\n+}\n+\n+type LatticeOp<T> = &fn(cf: &CombineFields, a: &T, b: &T) -> cres<T>;\n+\n+impl ty::t: LatticeValue {\n+    static fn sub(cf: &CombineFields, a: &ty::t, b: &ty::t) -> ures {\n+        Sub(*cf).tys(*a, *b).to_ures()\n+    }\n+\n+    static fn lub(cf: &CombineFields, a: &ty::t, b: &ty::t) -> cres<ty::t> {\n+        Lub(*cf).tys(*a, *b)\n+    }\n+\n+    static fn glb(cf: &CombineFields, a: &ty::t, b: &ty::t) -> cres<ty::t> {\n+        Glb(*cf).tys(*a, *b)\n+    }\n+}\n+\n+impl FnMeta: LatticeValue {\n+    static fn sub(cf: &CombineFields,\n+                  a: &FnMeta, b: &FnMeta) -> ures {\n+        Sub(*cf).fn_metas(a, b).to_ures()\n+    }\n+\n+    static fn lub(cf: &CombineFields,\n+                  a: &FnMeta, b: &FnMeta) -> cres<FnMeta> {\n+        Lub(*cf).fn_metas(a, b)\n+    }\n+\n+    static fn glb(cf: &CombineFields,\n+                  a: &FnMeta, b: &FnMeta) -> cres<FnMeta> {\n+        Glb(*cf).fn_metas(a, b)\n+    }\n+}\n+\n+impl CombineFields {\n+    fn var_sub_var<V:Copy Eq Vid ToStr, T:Copy InferStr LatticeValue>(\n+        &self,\n+        vb: &ValsAndBindings<V, Bounds<T>>,\n+        +a_id: V,\n+        +b_id: V) -> ures\n+    {\n+        /*!\n+         *\n+         * Make one variable a subtype of another variable.  This is a\n+         * subtle and tricky process, as described in detail at the\n+         * top of infer.rs*/\n+\n+        // Need to make sub_id a subtype of sup_id.\n+        let node_a = self.infcx.get(vb, a_id);\n+        let node_b = self.infcx.get(vb, b_id);\n+        let a_id = node_a.root;\n+        let b_id = node_b.root;\n+        let a_bounds = node_a.possible_types;\n+        let b_bounds = node_b.possible_types;\n+\n+        debug!(\"vars(%s=%s <: %s=%s)\",\n+               a_id.to_str(), a_bounds.inf_str(self.infcx),\n+               b_id.to_str(), b_bounds.inf_str(self.infcx));\n+\n+        if a_id == b_id { return uok(); }\n+\n+        // If both A's UB and B's LB have already been bound to types,\n+        // see if we can make those types subtypes.\n+        match (a_bounds.ub, b_bounds.lb) {\n+            (Some(ref a_ub), Some(ref b_lb)) => {\n+                let r = self.infcx.try(\n+                    || LatticeValue::sub(self, a_ub, b_lb));\n+                match r {\n+                    Ok(()) => {\n+                        return Ok(());\n+                    }\n+                    Err(_) => { /*fallthrough */ }\n+                }\n+            }\n+            _ => { /*fallthrough*/ }\n+        }\n+\n+        // Otherwise, we need to merge A and B so as to guarantee that\n+        // A remains a subtype of B.  Actually, there are other options,\n+        // but that's the route we choose to take.\n+\n+        self.infcx.unify(vb, &node_a, &node_b, |new_root, new_rank| {\n+            self.set_var_to_merged_bounds(vb, new_root,\n+                                          &a_bounds, &b_bounds,\n+                                          new_rank)\n+        })\n+    }\n+\n+    /// make variable a subtype of T\n+    fn var_sub_t<V:Copy Eq Vid ToStr, T:Copy InferStr LatticeValue>(\n+        &self,\n+        vb: &ValsAndBindings<V, Bounds<T>>,\n+        +a_id: V,\n+        +b: T) -> ures\n+    {\n+        /*!\n+         *\n+         * Make a variable (`a_id`) a subtype of the concrete type `b` */\n+\n+        let node_a = self.infcx.get(vb, a_id);\n+        let a_id = node_a.root;\n+        let a_bounds = &node_a.possible_types;\n+        let b_bounds = &{lb: None, ub: Some(b)};\n+\n+        debug!(\"var_sub_t(%s=%s <: %s)\",\n+               a_id.to_str(),\n+               a_bounds.inf_str(self.infcx),\n+               b.inf_str(self.infcx));\n+\n+        self.set_var_to_merged_bounds(\n+            vb, a_id, a_bounds, b_bounds, node_a.rank)\n+    }\n+\n+    fn t_sub_var<V:Copy Eq Vid ToStr, T:Copy InferStr LatticeValue>(\n+        &self,\n+        vb: &ValsAndBindings<V, Bounds<T>>,\n+        +a: T,\n+        +b_id: V) -> ures\n+    {\n+        /*!\n+         *\n+         * Make a concrete type (`a`) a subtype of the variable `b_id` */\n+\n+        let a_bounds = &{lb: Some(a), ub: None};\n+        let node_b = self.infcx.get(vb, b_id);\n+        let b_id = node_b.root;\n+        let b_bounds = &node_b.possible_types;\n+\n+        debug!(\"t_sub_var(%s <: %s=%s)\",\n+               a.inf_str(self.infcx),\n+               b_id.to_str(),\n+               b_bounds.inf_str(self.infcx));\n+\n+        self.set_var_to_merged_bounds(\n+            vb, b_id, a_bounds, b_bounds, node_b.rank)\n+    }\n+\n+    fn merge_bnd<T:Copy InferStr LatticeValue>(\n+        &self,\n+        a: &Bound<T>,\n+        b: &Bound<T>,\n+        lattice_op: LatticeOp<T>)\n+        -> cres<Bound<T>>\n+    {\n+        /*!\n+         *\n+         * Combines two bounds into a more general bound. */\n+\n+        debug!(\"merge_bnd(%s,%s)\",\n+               a.inf_str(self.infcx),\n+               b.inf_str(self.infcx));\n+        let _r = indenter();\n+\n+        match (*a, *b) {\n+            (None,          None) => Ok(None),\n+            (Some(_),       None) => Ok(*a),\n+            (None,          Some(_)) => Ok(*b),\n+            (Some(ref v_a), Some(ref v_b)) => {\n+                do lattice_op(self, v_a, v_b).chain |v| {\n+                    Ok(Some(v))\n+                }\n+            }\n+        }\n+    }\n+\n+    fn set_var_to_merged_bounds<V:Copy Eq Vid ToStr,\n+                                T:Copy InferStr LatticeValue>(\n+        &self,\n+        vb: &ValsAndBindings<V, Bounds<T>>,\n+        +v_id: V,\n+        a: &Bounds<T>,\n+        b: &Bounds<T>,\n+        rank: uint) -> ures\n+    {\n+        /*!\n+         *\n+         * Updates the bounds for the variable `v_id` to be the intersection\n+         * of `a` and `b`.  That is, the new bounds for `v_id` will be\n+         * a bounds c such that:\n+         *    c.ub <: a.ub\n+         *    c.ub <: b.ub\n+         *    a.lb <: c.lb\n+         *    b.lb <: c.lb\n+         * If this cannot be achieved, the result is failure. */\n+\n+        // Think of the two diamonds, we want to find the\n+        // intersection.  There are basically four possibilities (you\n+        // can swap A/B in these pictures):\n+        //\n+        //       A         A\n+        //      / \\       / \\\n+        //     / B \\     / B \\\n+        //    / / \\ \\   / / \\ \\\n+        //   * *   * * * /   * *\n+        //    \\ \\ / /   \\   / /\n+        //     \\ B /   / \\ / /\n+        //      \\ /   *   \\ /\n+        //       A     \\ / A\n+        //              B\n+\n+        debug!(\"merge(%s,%s,%s)\",\n+               v_id.to_str(),\n+               a.inf_str(self.infcx),\n+               b.inf_str(self.infcx));\n+        let _indent = indenter();\n+\n+        // First, relate the lower/upper bounds of A and B.\n+        // Note that these relations *must* hold for us to\n+        // to be able to merge A and B at all, and relating\n+        // them explicitly gives the type inferencer more\n+        // information and helps to produce tighter bounds\n+        // when necessary.\n+        let () = if_ok!(self.bnds(&a.lb, &b.ub));\n+        let () = if_ok!(self.bnds(&b.lb, &a.ub));\n+        let ub = if_ok!(self.merge_bnd(&a.ub, &b.ub, LatticeValue::glb));\n+        let lb = if_ok!(self.merge_bnd(&a.lb, &b.lb, LatticeValue::lub));\n+        let bounds = {lb: lb, ub: ub};\n+        debug!(\"merge(%s): bounds=%s\",\n+               v_id.to_str(),\n+               bounds.inf_str(self.infcx));\n+\n+        // the new bounds must themselves\n+        // be relatable:\n+        let () = if_ok!(self.bnds(&bounds.lb, &bounds.ub));\n+        self.infcx.set(vb, v_id, Root(bounds, rank));\n+        uok()\n+    }\n+\n+    fn bnds<T:Copy InferStr LatticeValue>(\n+        &self,\n+        a: &Bound<T>,\n+        b: &Bound<T>) -> ures\n+    {\n+        debug!(\"bnds(%s <: %s)\", a.inf_str(self.infcx),\n+               b.inf_str(self.infcx));\n+        let _r = indenter();\n+\n+        match (*a, *b) {\n+            (None, None) |\n+            (Some(_), None) |\n+            (None, Some(_)) => {\n+                uok()\n+            }\n+            (Some(ref t_a), Some(ref t_b)) => {\n+                LatticeValue::sub(self, t_a, t_b)\n+            }\n+        }\n+    }\n+}\n+\n // ______________________________________________________________________\n // Lattice operations on variables\n //\n // This is common code used by both LUB and GLB to compute the LUB/GLB\n // for pairs of variables or for variables and values.\n \n-trait lattice_ops {\n-    fn bnd(b: bounds<ty::t>) -> Option<ty::t>;\n-    fn with_bnd(b: bounds<ty::t>, t: ty::t) -> bounds<ty::t>;\n+trait LatticeDir {\n+    fn combine_fields() -> CombineFields;\n+    fn bnd<T:Copy>(b: &Bounds<T>) -> Option<T>;\n+    fn with_bnd<T:Copy>(b: &Bounds<T>, +t: T) -> Bounds<T>;\n+}\n+\n+trait TyLatticeDir {\n     fn ty_bot(t: ty::t) -> cres<ty::t>;\n }\n \n-impl Lub: lattice_ops {\n-    fn bnd(b: bounds<ty::t>) -> Option<ty::t> { b.ub }\n-    fn with_bnd(b: bounds<ty::t>, t: ty::t) -> bounds<ty::t> {\n-        {ub: Some(t),.. b}\n+impl Lub: LatticeDir {\n+    fn combine_fields() -> CombineFields { *self }\n+    fn bnd<T:Copy>(b: &Bounds<T>) -> Option<T> { b.ub }\n+    fn with_bnd<T:Copy>(b: &Bounds<T>, +t: T) -> Bounds<T> {\n+        {ub: Some(t), ..*b}\n     }\n+}\n+\n+impl Lub: TyLatticeDir {\n     fn ty_bot(t: ty::t) -> cres<ty::t> {\n         Ok(t)\n     }\n }\n \n-impl Glb: lattice_ops {\n-    fn bnd(b: bounds<ty::t>) -> Option<ty::t> { b.lb }\n-    fn with_bnd(b: bounds<ty::t>, t: ty::t) -> bounds<ty::t> {\n-        {lb: Some(t),.. b}\n+impl Glb: LatticeDir {\n+    fn combine_fields() -> CombineFields { *self }\n+    fn bnd<T:Copy>(b: &Bounds<T>) -> Option<T> { b.lb }\n+    fn with_bnd<T:Copy>(b: &Bounds<T>, +t: T) -> Bounds<T> {\n+        {lb: Some(t), ..*b}\n     }\n+}\n+\n+impl Glb: TyLatticeDir {\n     fn ty_bot(_t: ty::t) -> cres<ty::t> {\n         Ok(ty::mk_bot(self.infcx.tcx))\n     }\n }\n \n-fn lattice_tys<L:lattice_ops combine>(\n-    self: &L, a: ty::t, b: ty::t) -> cres<ty::t> {\n-\n+fn super_lattice_tys<L:LatticeDir TyLatticeDir Combine>(\n+    self: &L,\n+    a: ty::t,\n+    b: ty::t) -> cres<ty::t>\n+{\n     debug!(\"%s.lattice_tys(%s, %s)\", self.tag(),\n-           a.to_str(self.infcx()),\n-           b.to_str(self.infcx()));\n-    if a == b { return Ok(a); }\n-    do indent {\n-        match (ty::get(a).sty, ty::get(b).sty) {\n-          (ty::ty_bot, _) => self.ty_bot(b),\n-          (_, ty::ty_bot) => self.ty_bot(a),\n-\n-          (ty::ty_infer(TyVar(a_id)), ty::ty_infer(TyVar(b_id))) => {\n-            lattice_vars(self, a, a_id, b_id,\n-                         |x, y| self.tys(x, y) )\n-          }\n-\n-          (ty::ty_infer(TyVar(a_id)), _) => {\n-            lattice_var_and_t(self, a_id, b,\n-                              |x, y| self.tys(x, y) )\n-          }\n-\n-          (_, ty::ty_infer(TyVar(b_id))) => {\n-            lattice_var_and_t(self, b_id, a,\n-                              |x, y| self.tys(x, y) )\n-          }\n-          _ => {\n-            super_tys(self, a, b)\n-          }\n+           a.inf_str(self.infcx()),\n+           b.inf_str(self.infcx()));\n+    let _r = indenter();\n+\n+    if a == b {\n+        return Ok(a);\n+    }\n+\n+    let tcx = self.infcx().tcx;\n+\n+    match (ty::get(a).sty, ty::get(b).sty) {\n+        (ty::ty_bot, _) => { return self.ty_bot(b); }\n+        (_, ty::ty_bot) => { return self.ty_bot(a); }\n+\n+        (ty::ty_infer(TyVar(a_id)), ty::ty_infer(TyVar(b_id))) => {\n+            let r = if_ok!(lattice_vars(self, &self.infcx().ty_var_bindings,\n+                                        a_id, b_id,\n+                                        |x, y| self.tys(*x, *y)));\n+            return match r {\n+                VarResult(v) => Ok(ty::mk_var(tcx, v)),\n+                ValueResult(t) => Ok(t)\n+            };\n+        }\n+\n+        (ty::ty_infer(TyVar(a_id)), _) => {\n+            return lattice_var_and_t(self, &self.infcx().ty_var_bindings,\n+                                     a_id, &b,\n+                                     |x, y| self.tys(*x, *y));\n+        }\n+\n+        (_, ty::ty_infer(TyVar(b_id))) => {\n+            return lattice_var_and_t(self, &self.infcx().ty_var_bindings,\n+                                     b_id, &a,\n+                                     |x, y| self.tys(*x, *y));\n+        }\n+\n+        _ => {\n+            return super_tys(self, a, b);\n         }\n     }\n }\n \n-fn lattice_vars<L:lattice_ops combine>(\n-    self: &L, +a_t: ty::t, +a_vid: ty::TyVid, +b_vid: ty::TyVid,\n-    c_ts: fn(ty::t, ty::t) -> cres<ty::t>) -> cres<ty::t> {\n+type LatticeDirOp<T> = &fn(a: &T, b: &T) -> cres<T>;\n \n-    // The comments in this function are written for LUB and types,\n-    // but they apply equally well to GLB and regions if you inverse\n-    // upper/lower/sub/super/etc.\n+enum LatticeVarResult<V,T> {\n+    VarResult(V),\n+    ValueResult(T)\n+}\n \n-    // Need to find a type that is a supertype of both a and b:\n-    let vb = &self.infcx().ty_var_bindings;\n+/**\n+ * Computes the LUB or GLB of two bounded variables.  These could be any\n+ * sort of variables, but in the comments on this function I'll assume\n+ * we are doing an LUB on two type variables.\n+ *\n+ * This computation can be done in one of two ways:\n+ *\n+ * - If both variables have an upper bound, we may just compute the\n+ *   LUB of those bounds and return that, in which case we are\n+ *   returning a type.  This is indicated with a `ValueResult` return.\n+ *\n+ * - If the variables do not both have an upper bound, we will unify\n+ *   the variables and return the unified variable, in which case the\n+ *   result is a variable.  This is indicated with a `VarResult`\n+ *   return. */\n+fn lattice_vars<L:LatticeDir Combine,\n+                V:Copy Eq Vid ToStr,\n+                T:Copy InferStr LatticeValue>(\n+    self: &L,                           // defines whether we want LUB or GLB\n+    vb: &ValsAndBindings<V, Bounds<T>>, // relevant variable bindings\n+    +a_vid: V,                          // first variable\n+    +b_vid: V,                          // second variable\n+    lattice_dir_op: LatticeDirOp<T>)    // LUB or GLB operation on types\n+    -> cres<LatticeVarResult<V,T>>\n+{\n     let nde_a = self.infcx().get(vb, a_vid);\n     let nde_b = self.infcx().get(vb, b_vid);\n     let a_vid = nde_a.root;\n     let b_vid = nde_b.root;\n-    let a_bounds = nde_a.possible_types;\n-    let b_bounds = nde_b.possible_types;\n+    let a_bounds = &nde_a.possible_types;\n+    let b_bounds = &nde_b.possible_types;\n \n     debug!(\"%s.lattice_vars(%s=%s <: %s=%s)\",\n            self.tag(),\n-           a_vid.to_str(), a_bounds.to_str(self.infcx()),\n-           b_vid.to_str(), b_bounds.to_str(self.infcx()));\n+           a_vid.to_str(), a_bounds.inf_str(self.infcx()),\n+           b_vid.to_str(), b_bounds.inf_str(self.infcx()));\n \n+    // Same variable: the easy case.\n     if a_vid == b_vid {\n-        return Ok(a_t);\n+        return Ok(VarResult(a_vid));\n     }\n \n     // If both A and B have an UB type, then we can just compute the\n     // LUB of those types:\n     let a_bnd = self.bnd(a_bounds), b_bnd = self.bnd(b_bounds);\n     match (a_bnd, b_bnd) {\n-      (Some(a_ty), Some(b_ty)) => {\n-        match self.infcx().try(|| c_ts(a_ty, b_ty) ) {\n-            Ok(t) => return Ok(t),\n-            Err(_) => { /*fallthrough */ }\n+        (Some(ref a_ty), Some(ref b_ty)) => {\n+            match self.infcx().try(|| lattice_dir_op(a_ty, b_ty) ) {\n+                Ok(t) => return Ok(ValueResult(t)),\n+                Err(_) => { /*fallthrough */ }\n+            }\n         }\n-      }\n-      _ => {/*fallthrough*/}\n+        _ => {/*fallthrough*/}\n     }\n \n     // Otherwise, we need to merge A and B into one variable.  We can\n     // then use either variable as an upper bound:\n-    var_sub_var(self, a_vid, b_vid).then(|| Ok(a_t) )\n+    let cf = self.combine_fields();\n+    do cf.var_sub_var(vb, a_vid, b_vid).then {\n+        Ok(VarResult(a_vid))\n+    }\n }\n \n-fn lattice_var_and_t<L:lattice_ops combine>(\n-    self: &L, a_id: ty::TyVid, b: ty::t,\n-    c_ts: fn(ty::t, ty::t) -> cres<ty::t>) -> cres<ty::t> {\n-\n-    let vb = &self.infcx().ty_var_bindings;\n+fn lattice_var_and_t<L:LatticeDir Combine,\n+                     V:Copy Eq Vid ToStr,\n+                     T:Copy InferStr LatticeValue>(\n+    self: &L,\n+    vb: &ValsAndBindings<V, Bounds<T>>,\n+    +a_id: V,\n+    b: &T,\n+    lattice_dir_op: LatticeDirOp<T>)\n+    -> cres<T>\n+{\n     let nde_a = self.infcx().get(vb, a_id);\n     let a_id = nde_a.root;\n-    let a_bounds = nde_a.possible_types;\n+    let a_bounds = &nde_a.possible_types;\n \n     // The comments in this function are written for LUB, but they\n     // apply equally well to GLB if you inverse upper/lower/sub/super/etc.\n \n     debug!(\"%s.lattice_var_and_t(%s=%s <: %s)\",\n            self.tag(),\n-           a_id.to_str(), a_bounds.to_str(self.infcx()),\n-           b.to_str(self.infcx()));\n+           a_id.to_str(),\n+           a_bounds.inf_str(self.infcx()),\n+           b.inf_str(self.infcx()));\n \n     match self.bnd(a_bounds) {\n-      Some(a_bnd) => {\n-        // If a has an upper bound, return the LUB(a.ub, b)\n-        debug!(\"bnd=some(%s)\", a_bnd.to_str(self.infcx()));\n-        return c_ts(a_bnd, b);\n-      }\n-      None => {\n-        // If a does not have an upper bound, make b the upper bound of a\n-        // and then return b.\n-        debug!(\"bnd=none\");\n-        let a_bounds = self.with_bnd(a_bounds, b);\n-        do bnds(self, a_bounds.lb, a_bounds.ub).then {\n-            self.infcx().set(vb, a_id, root(a_bounds, nde_a.rank));\n-            Ok(b)\n+        Some(ref a_bnd) => {\n+            // If a has an upper bound, return the LUB(a.ub, b)\n+            debug!(\"bnd=some(%s)\", a_bnd.inf_str(self.infcx()));\n+            lattice_dir_op(a_bnd, b)\n+        }\n+        None => {\n+            // If a does not have an upper bound, make b the upper bound of a\n+            // and then return b.\n+            debug!(\"bnd=none\");\n+            let a_bounds = self.with_bnd(a_bounds, *b);\n+            do self.combine_fields().bnds(&a_bounds.lb, &a_bounds.ub).then {\n+                self.infcx().set(vb, a_id, Root(a_bounds, nde_a.rank));\n+                Ok(*b)\n+            }\n         }\n-      }\n     }\n }\n \n // ___________________________________________________________________________\n // Random utility functions used by LUB/GLB when computing LUB/GLB of\n // fn types\n \n-fn var_ids<T: combine>(self: &T, isr: isr_alist) -> ~[RegionVid] {\n+fn var_ids<T: Combine>(self: &T, isr: isr_alist) -> ~[RegionVid] {\n     let mut result = ~[];\n     for list::each(isr) |pair| {\n         match pair.second() {"}, {"sha": "ac6c4473999c3bb1773ce1f39e24965bf5f63b3f", "filename": "src/librustc/middle/typeck/infer/lub.rs", "status": "modified", "additions": 22, "deletions": 27, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs?ref=2b92962aa29b0116015f99c1666ecf6288303c65", "patch": "@@ -16,7 +16,7 @@ use middle::typeck::infer::combine::*;\n use middle::typeck::infer::glb::Glb;\n use middle::typeck::infer::lattice::*;\n use middle::typeck::infer::sub::Sub;\n-use middle::typeck::infer::to_str::ToStr;\n+use middle::typeck::infer::to_str::InferStr;\n use middle::typeck::isr_alist;\n use util::ppaux::mt_to_str;\n \n@@ -26,15 +26,15 @@ use syntax::ast::{pure_fn, ret_style, return_val, unsafe_fn};\n \n fn macros() { include!(\"macros.rs\"); } // FIXME(#3114): Macro import/export.\n \n-enum Lub = combine_fields;  // \"subtype\", \"subregion\" etc\n+enum Lub = CombineFields;  // least-upper-bound: common supertype\n \n impl Lub {\n     fn bot_ty(b: ty::t) -> cres<ty::t> { Ok(b) }\n     fn ty_bot(b: ty::t) -> cres<ty::t> { self.bot_ty(b) } // commutative\n }\n \n-impl Lub: combine {\n-    fn infcx() -> infer_ctxt { self.infcx }\n+impl Lub: Combine {\n+    fn infcx() -> @InferCtxt { self.infcx }\n     fn tag() -> ~str { ~\"lub\" }\n     fn a_is_expected() -> bool { self.a_is_expected }\n     fn span() -> span { self.span }\n@@ -80,15 +80,6 @@ impl Lub: combine {\n         Glb(*self).tys(a, b)\n     }\n \n-    fn protos(p1: ast::Proto, p2: ast::Proto) -> cres<ast::Proto> {\n-        match (p1, p2) {\n-            (ast::ProtoBare, _) => Ok(p2),\n-            (_, ast::ProtoBare) => Ok(p1),\n-            _ if p1 == p2 => Ok(p1),\n-            _ => Err(ty::terr_proto_mismatch(expected_found(&self, p1, p2)))\n-        }\n-    }\n-\n     fn purities(a: purity, b: purity) -> cres<purity> {\n         match (a, b) {\n           (unsafe_fn, _) | (_, unsafe_fn) => Ok(unsafe_fn),\n@@ -112,15 +103,15 @@ impl Lub: combine {\n     fn regions(a: ty::Region, b: ty::Region) -> cres<ty::Region> {\n         debug!(\"%s.regions(%?, %?)\",\n                self.tag(),\n-               a.to_str(self.infcx),\n-               b.to_str(self.infcx));\n+               a.inf_str(self.infcx),\n+               b.inf_str(self.infcx));\n \n         do indent {\n             self.infcx.region_vars.lub_regions(self.span, a, b)\n         }\n     }\n \n-    fn fns(a: &ty::FnTy, b: &ty::FnTy) -> cres<ty::FnTy> {\n+    fn fn_sigs(a: &ty::FnSig, b: &ty::FnSig) -> cres<ty::FnSig> {\n         // Note: this is a subtle algorithm.  For a full explanation,\n         // please see the large comment in `region_inference.rs`.\n \n@@ -139,18 +130,18 @@ impl Lub: combine {\n                 self.span, b);\n \n         // Collect constraints.\n-        let fn_ty0 = if_ok!(super_fns(&self, &a_with_fresh, &b_with_fresh));\n-        debug!(\"fn_ty0 = %s\", fn_ty0.to_str(self.infcx));\n+        let sig0 = if_ok!(super_fn_sigs(&self, &a_with_fresh, &b_with_fresh));\n+        debug!(\"sig0 = %s\", sig0.inf_str(self.infcx));\n \n-        // Generalize the regions appearing in fn_ty0 if possible\n+        // Generalize the regions appearing in sig0 if possible\n         let new_vars =\n             self.infcx.region_vars.vars_created_since_snapshot(snapshot);\n-        let fn_ty1 =\n+        let sig1 =\n             self.infcx.fold_regions_in_sig(\n-                &fn_ty0,\n+                &sig0,\n                 |r, _in_fn| generalize_region(&self, snapshot, new_vars,\n                                               a_isr, r));\n-        return Ok(move fn_ty1);\n+        return Ok(move sig1);\n \n         fn generalize_region(self: &Lub,\n                              snapshot: uint,\n@@ -197,18 +188,22 @@ impl Lub: combine {\n         }\n     }\n \n-    fn fn_metas(a: &ty::FnMeta, b: &ty::FnMeta) -> cres<ty::FnMeta> {\n-        super_fn_metas(&self, a, b)\n+    fn fns(a: &ty::FnTy, b: &ty::FnTy) -> cres<ty::FnTy> {\n+        super_fns(&self, a, b)\n     }\n \n-    fn fn_sigs(a: &ty::FnSig, b: &ty::FnSig) -> cres<ty::FnSig> {\n-        super_fn_sigs(&self, a, b)\n+    fn fn_metas(a: &ty::FnMeta, b: &ty::FnMeta) -> cres<ty::FnMeta> {\n+        super_fn_metas(&self, a, b)\n     }\n \n     // Traits please (FIXME: #2794):\n \n+    fn protos(p1: ast::Proto, p2: ast::Proto) -> cres<ast::Proto> {\n+        super_protos(&self, p1, p2)\n+    }\n+\n     fn tys(a: ty::t, b: ty::t) -> cres<ty::t> {\n-        lattice_tys(&self, a, b)\n+        super_lattice_tys(&self, a, b)\n     }\n \n     fn flds(a: ty::field, b: ty::field) -> cres<ty::field> {"}, {"sha": "40134c76dbd2445f76c62da12c91ce224405dbb7", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 98, "deletions": 105, "changes": 203, "blob_url": "https://github.com/rust-lang/rust/blob/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=2b92962aa29b0116015f99c1666ecf6288303c65", "patch": "@@ -197,29 +197,16 @@ is valid.  This basically corresponds to the block nesting structure:\n the regions for outer block scopes are superregions of those for inner\n block scopes.\n \n-## Integral type variables\n+## Integral and floating-point type variables\n \n There is a third variety of type variable that we use only for\n inferring the types of unsuffixed integer literals.  Integral type\n variables differ from general-purpose type variables in that there's\n no subtyping relationship among the various integral types, so instead\n-of associating each variable with an upper and lower bound, we\n-represent the set of possible integral types it can take on with an\n-`int_ty_set`, which is a bitvector with one bit for each integral\n-type.  Because intersecting these sets with each other is simpler than\n-merging bounds, we don't need to do so transactionally as we do for\n-general-purpose type variables.\n-\n-We could conceivably define a subtyping relationship among integral\n-types based on their ranges, but we choose not to open that particular\n-can of worms.  Our strategy is to treat integral type variables as\n-unknown until the typing context constrains them to a unique integral\n-type, at which point they take on that type.  If the typing context\n-overconstrains the type, it's a type error; if we reach the point at\n-which type variables must be resolved and an integral type variable is\n-still underconstrained, it defaults to `int` as a last resort.\n-\n-Floating point types are handled similarly to integral types.\n+of associating each variable with an upper and lower bound, we just\n+use simple unification.  Each integer variable is associated with at\n+most one integer type.  Floating point types are handled similarly to\n+integral types.\n \n ## GLB/LUB\n \n@@ -261,16 +248,14 @@ section on \"Type Combining\" below for details.\n \n use core::prelude::*;\n \n-use middle::ty::{TyVid, IntVid, FloatVid, RegionVid, vid};\n+use middle::ty::{TyVid, IntVid, FloatVid, RegionVid, Vid};\n use middle::ty::{mk_fn, type_is_bot};\n use middle::ty::{ty_int, ty_uint, get, terr_fn, TyVar, IntVar, FloatVar};\n use middle::ty;\n-use middle::typeck::check::regionmanip::{replace_bound_regions_in_fn_ty};\n+use middle::typeck::check::regionmanip::{replace_bound_regions_in_fn_sig};\n use middle::typeck::infer::assignment::Assign;\n-use middle::typeck::infer::combine::{combine_fields, eq_tys};\n-use middle::typeck::infer::floating::{float_ty_set, float_ty_set_all};\n+use middle::typeck::infer::combine::{CombineFields, eq_tys};\n use middle::typeck::infer::glb::Glb;\n-use middle::typeck::infer::integral::{int_ty_set, int_ty_set_all};\n use middle::typeck::infer::lub::Lub;\n use middle::typeck::infer::region_inference::{RegionVarBindings};\n use middle::typeck::infer::resolve::{force_all, not_regions};\n@@ -280,8 +265,8 @@ use middle::typeck::infer::resolve::{resolve_ivar, resolve_all};\n use middle::typeck::infer::resolve::{resolve_nested_tvar, resolve_rvar};\n use middle::typeck::infer::resolve::{resolver};\n use middle::typeck::infer::sub::Sub;\n-use middle::typeck::infer::to_str::ToStr;\n-use middle::typeck::infer::unify::{vals_and_bindings, root};\n+use middle::typeck::infer::to_str::InferStr;\n+use middle::typeck::infer::unify::{ValsAndBindings, Root};\n use middle::typeck::isr_alist;\n use util::common::{indent, indenter};\n use util::ppaux::{bound_region_to_str, ty_to_str, mt_to_str};\n@@ -302,7 +287,7 @@ use syntax::ast_util::dummy_sp;\n use syntax::ast_util;\n use syntax::codemap::span;\n \n-export infer_ctxt;\n+export InferCtxt;\n export new_infer_ctxt;\n export mk_subty, can_mk_subty;\n export mk_subr;\n@@ -313,15 +298,12 @@ export force_tvar, force_rvar, force_ivar, force_all;\n export resolve_and_force_all_but_regions, not_regions;\n export resolve_type, resolve_region;\n export resolve_borrowings;\n-export methods; // for infer_ctxt\n-export unify_methods; // for infer_ctxt\n export cres, fres, fixup_err, fixup_err_to_str;\n export assignment;\n export root, to_str;\n export int_ty_set_all;\n export assignment;\n export combine;\n-export floating;\n export glb;\n export integral;\n export lattice;\n@@ -333,11 +315,12 @@ export to_str;\n export unify;\n export uok;\n export cyclic_ty, unresolved_ty, region_var_bound_by_region_var;\n-export bound, bounds;\n+export Bound, Bounds;\n export ures;\n export ares;\n export infer_ctxt;\n export fixup_err;\n+export IntVarValue, IntType, UintType;\n \n #[legacy_exports]\n mod assignment;\n@@ -346,9 +329,6 @@ mod combine;\n #[legacy_exports]\n mod glb;\n #[legacy_exports]\n-mod integral;\n-mod floating;\n-#[legacy_exports]\n mod lattice;\n #[legacy_exports]\n mod lub;\n@@ -363,39 +343,48 @@ mod to_str;\n #[legacy_exports]\n mod unify;\n \n-type bound<T:Copy> = Option<T>;\n-type bounds<T:Copy> = {lb: bound<T>, ub: bound<T>};\n+type Bound<T> = Option<T>;\n+type Bounds<T> = {lb: Bound<T>, ub: Bound<T>};\n \n type cres<T> = Result<T,ty::type_err>; // \"combine result\"\n type ures = cres<()>; // \"unify result\"\n type fres<T> = Result<T, fixup_err>; // \"fixup result\"\n type ares = cres<Option<@ty::AutoAdjustment>>; // \"assignment result\"\n \n-enum infer_ctxt = @{\n+#[deriving_eq]\n+enum IntVarValue {\n+    IntType(ast::int_ty),\n+    UintType(ast::uint_ty),\n+}\n+\n+struct InferCtxt {\n     tcx: ty::ctxt,\n \n-    // We instantiate vals_and_bindings with bounds<ty::t> because the\n+    // We instantiate ValsAndBindings with bounds<ty::t> because the\n     // types that might instantiate a general type variable have an\n     // order, represented by its upper and lower bounds.\n-    ty_var_bindings: vals_and_bindings<ty::TyVid, bounds<ty::t>>,\n+    ty_var_bindings: ValsAndBindings<ty::TyVid, Bounds<ty::t>>,\n+\n+    // Number of type variables created thus far.\n+    mut ty_var_counter: uint,\n \n     // The types that might instantiate an integral type variable are\n     // represented by an int_ty_set.\n-    int_var_bindings: vals_and_bindings<ty::IntVid, int_ty_set>,\n+    int_var_bindings: ValsAndBindings<ty::IntVid, Option<IntVarValue>>,\n+\n+    // Number of integral variables created thus far.\n+    mut int_var_counter: uint,\n \n     // The types that might instantiate a floating-point type variable are\n     // represented by an float_ty_set.\n-    float_var_bindings: vals_and_bindings<ty::FloatVid, float_ty_set>,\n+    float_var_bindings: ValsAndBindings<ty::FloatVid, Option<ast::float_ty>>,\n+\n+    // Number of floating-point variables created thus far.\n+    mut float_var_counter: uint,\n \n     // For region variables.\n     region_vars: RegionVarBindings,\n-\n-    // For keeping track of existing type and region variables.\n-    ty_var_counter: @mut uint,\n-    int_var_counter: @mut uint,\n-    float_var_counter: @mut uint,\n-    region_var_counter: @mut uint\n-};\n+}\n \n enum fixup_err {\n     unresolved_int_ty(IntVid),\n@@ -418,56 +407,62 @@ fn fixup_err_to_str(f: fixup_err) -> ~str {\n     }\n }\n \n-fn new_vals_and_bindings<V:Copy, T:Copy>() -> vals_and_bindings<V, T> {\n-    vals_and_bindings {\n+fn new_ValsAndBindings<V:Copy, T:Copy>() -> ValsAndBindings<V, T> {\n+    ValsAndBindings {\n         vals: smallintmap::mk(),\n         mut bindings: ~[]\n     }\n }\n \n-fn new_infer_ctxt(tcx: ty::ctxt) -> infer_ctxt {\n-    infer_ctxt(@{tcx: tcx,\n-                 ty_var_bindings: new_vals_and_bindings(),\n-                 int_var_bindings: new_vals_and_bindings(),\n-                 float_var_bindings: new_vals_and_bindings(),\n-                 region_vars: RegionVarBindings(tcx),\n-                 ty_var_counter: @mut 0u,\n-                 int_var_counter: @mut 0u,\n-                 float_var_counter: @mut 0u,\n-                 region_var_counter: @mut 0u})}\n-\n-fn mk_subty(cx: infer_ctxt, a_is_expected: bool, span: span,\n+fn new_infer_ctxt(tcx: ty::ctxt) -> @InferCtxt {\n+    @InferCtxt {\n+        tcx: tcx,\n+\n+        ty_var_bindings: new_ValsAndBindings(),\n+        ty_var_counter: 0,\n+\n+        int_var_bindings: new_ValsAndBindings(),\n+        int_var_counter: 0,\n+\n+        float_var_bindings: new_ValsAndBindings(),\n+        float_var_counter: 0,\n+\n+        region_vars: RegionVarBindings(tcx),\n+    }\n+}\n+\n+fn mk_subty(cx: @InferCtxt, a_is_expected: bool, span: span,\n             a: ty::t, b: ty::t) -> ures {\n-    debug!(\"mk_subty(%s <: %s)\", a.to_str(cx), b.to_str(cx));\n+    debug!(\"mk_subty(%s <: %s)\", a.inf_str(cx), b.inf_str(cx));\n     do indent {\n         do cx.commit {\n             cx.sub(a_is_expected, span).tys(a, b)\n         }\n     }.to_ures()\n }\n \n-fn can_mk_subty(cx: infer_ctxt, a: ty::t, b: ty::t) -> ures {\n-    debug!(\"can_mk_subty(%s <: %s)\", a.to_str(cx), b.to_str(cx));\n+fn can_mk_subty(cx: @InferCtxt, a: ty::t, b: ty::t) -> ures {\n+    debug!(\"can_mk_subty(%s <: %s)\", a.inf_str(cx), b.inf_str(cx));\n     do indent {\n         do cx.probe {\n             cx.sub(true, ast_util::dummy_sp()).tys(a, b)\n         }\n     }.to_ures()\n }\n \n-fn mk_subr(cx: infer_ctxt, a_is_expected: bool, span: span,\n+fn mk_subr(cx: @InferCtxt, a_is_expected: bool, span: span,\n            a: ty::Region, b: ty::Region) -> ures {\n-    debug!(\"mk_subr(%s <: %s)\", a.to_str(cx), b.to_str(cx));\n+    debug!(\"mk_subr(%s <: %s)\", a.inf_str(cx), b.inf_str(cx));\n     do indent {\n         do cx.commit {\n             cx.sub(a_is_expected, span).regions(a, b)\n         }\n     }.to_ures()\n }\n \n-fn mk_eqty(cx: infer_ctxt, a_is_expected: bool, span: span,\n+fn mk_eqty(cx: @InferCtxt, a_is_expected: bool, span: span,\n            a: ty::t, b: ty::t) -> ures {\n-    debug!(\"mk_eqty(%s <: %s)\", a.to_str(cx), b.to_str(cx));\n+    debug!(\"mk_eqty(%s <: %s)\", a.inf_str(cx), b.inf_str(cx));\n     do indent {\n         do cx.commit {\n             let suber = cx.sub(a_is_expected, span);\n@@ -476,18 +471,18 @@ fn mk_eqty(cx: infer_ctxt, a_is_expected: bool, span: span,\n     }.to_ures()\n }\n \n-fn mk_assignty(cx: infer_ctxt, a_is_expected: bool, span: span,\n+fn mk_assignty(cx: @InferCtxt, a_is_expected: bool, span: span,\n                a: ty::t, b: ty::t) -> ares {\n-    debug!(\"mk_assignty(%s -> %s)\", a.to_str(cx), b.to_str(cx));\n+    debug!(\"mk_assignty(%s -> %s)\", a.inf_str(cx), b.inf_str(cx));\n     do indent {\n         do cx.commit {\n             Assign(cx.combine_fields(a_is_expected, span)).tys(a, b)\n         }\n     }\n }\n \n-fn can_mk_assignty(cx: infer_ctxt, a: ty::t, b: ty::t) -> ures {\n-    debug!(\"can_mk_assignty(%s -> %s)\", a.to_str(cx), b.to_str(cx));\n+fn can_mk_assignty(cx: @InferCtxt, a: ty::t, b: ty::t) -> ures {\n+    debug!(\"can_mk_assignty(%s -> %s)\", a.inf_str(cx), b.inf_str(cx));\n     do indent {\n         do cx.probe {\n             let span = ast_util::dummy_sp();\n@@ -497,18 +492,18 @@ fn can_mk_assignty(cx: infer_ctxt, a: ty::t, b: ty::t) -> ures {\n }\n \n // See comment on the type `resolve_state` below\n-fn resolve_type(cx: infer_ctxt, a: ty::t, modes: uint)\n+fn resolve_type(cx: @InferCtxt, a: ty::t, modes: uint)\n     -> fres<ty::t> {\n     resolver(cx, modes).resolve_type_chk(a)\n }\n \n-fn resolve_region(cx: infer_ctxt, r: ty::Region, modes: uint)\n+fn resolve_region(cx: @InferCtxt, r: ty::Region, modes: uint)\n     -> fres<ty::Region> {\n     resolver(cx, modes).resolve_region_chk(r)\n }\n \n /*\n-fn resolve_borrowings(cx: infer_ctxt) {\n+fn resolve_borrowings(cx: @InferCtxt) {\n     for cx.borrowings.each |item| {\n         match resolve_region(cx, item.scope, resolve_all|force_all) {\n           Ok(region) => {\n@@ -574,9 +569,10 @@ pub fn uok() -> ures {\n     Ok(())\n }\n \n-fn rollback_to<V:Copy vid, T:Copy>(\n-    vb: &vals_and_bindings<V, T>, len: uint) {\n-\n+fn rollback_to<V:Copy Vid, T:Copy>(\n+    vb: &ValsAndBindings<V, T>,\n+    len: uint)\n+{\n     while vb.bindings.len() != len {\n         let (vid, old_v) = vb.bindings.pop();\n         vb.vals.insert(vid.to_uint(), old_v);\n@@ -589,12 +585,12 @@ struct Snapshot {\n     region_vars_snapshot: uint,\n }\n \n-impl infer_ctxt {\n+impl @InferCtxt {\n     fn combine_fields(a_is_expected: bool,\n-                      span: span) -> combine_fields {\n-        combine_fields {infcx: self,\n-                        a_is_expected: a_is_expected,\n-                        span: span}\n+                      span: span) -> CombineFields {\n+        CombineFields {infcx: self,\n+                       a_is_expected: a_is_expected,\n+                       span: span}\n     }\n \n     fn sub(a_is_expected: bool, span: span) -> Sub {\n@@ -624,8 +620,7 @@ impl infer_ctxt {\n         //rollback_to(&self.int_var_bindings,\n         //            snapshot.int_var_bindings_len);\n \n-        self.region_vars.rollback_to(\n-            snapshot.region_vars_snapshot);\n+        self.region_vars.rollback_to(snapshot.region_vars_snapshot);\n     }\n \n     /// Execute `f` and commit the bindings if successful\n@@ -669,12 +664,12 @@ impl infer_ctxt {\n     }\n }\n \n-impl infer_ctxt {\n+impl @InferCtxt {\n     fn next_ty_var_id() -> TyVid {\n-        let id = *self.ty_var_counter;\n-        *self.ty_var_counter += 1u;\n+        let id = self.ty_var_counter;\n+        self.ty_var_counter += 1;\n         self.ty_var_bindings.vals.insert(id,\n-                                         root({lb: None, ub: None}, 0u));\n+                                         Root({lb: None, ub: None}, 0u));\n         return TyVid(id);\n     }\n \n@@ -687,11 +682,10 @@ impl infer_ctxt {\n     }\n \n     fn next_int_var_id() -> IntVid {\n-        let id = *self.int_var_counter;\n-        *self.int_var_counter += 1u;\n+        let id = self.int_var_counter;\n+        self.int_var_counter += 1;\n \n-        self.int_var_bindings.vals.insert(id,\n-                              root(int_ty_set_all(), 0u));\n+        self.int_var_bindings.vals.insert(id, Root(None, 0));\n         return IntVid(id);\n     }\n \n@@ -700,10 +694,10 @@ impl infer_ctxt {\n     }\n \n     fn next_float_var_id() -> FloatVid {\n-        let id = *self.float_var_counter;\n-        *self.float_var_counter += 1;\n+        let id = self.float_var_counter;\n+        self.float_var_counter += 1;\n \n-        self.float_var_bindings.vals.insert(id, root(float_ty_set_all(), 0));\n+        self.float_var_bindings.vals.insert(id, Root(None, 0));\n         return FloatVid(id);\n     }\n \n@@ -795,10 +789,10 @@ impl infer_ctxt {\n \n     fn replace_bound_regions_with_fresh_regions(\n         &self, span: span,\n-        fty: &ty::FnTy) -> (ty::FnTy, isr_alist)\n+        fsig: &ty::FnSig) -> (ty::FnSig, isr_alist)\n     {\n-        let {fn_ty: fn_ty, isr: isr, _} =\n-            replace_bound_regions_in_fn_ty(self.tcx, @Nil, None, fty, |br| {\n+        let {fn_sig: fn_sig, isr: isr, _} =\n+            replace_bound_regions_in_fn_sig(self.tcx, @Nil, None, fsig, |br| {\n                 // N.B.: The name of the bound region doesn't have anything to\n                 // do with the region variable that's created for it.  The\n                 // only thing we're doing with `br` here is using it in the\n@@ -809,18 +803,17 @@ impl infer_ctxt {\n                        rvar);\n                 rvar\n             });\n-        (fn_ty, isr)\n+        (fn_sig, isr)\n     }\n \n     fn fold_regions_in_sig(\n         &self,\n-        fn_ty: &ty::FnTy,\n-        fldr: &fn(r: ty::Region, in_fn: bool) -> ty::Region) -> ty::FnTy\n+        fn_sig: &ty::FnSig,\n+        fldr: &fn(r: ty::Region, in_fn: bool) -> ty::Region) -> ty::FnSig\n     {\n-        let sig = do ty::fold_sig(&fn_ty.sig) |t| {\n+        do ty::fold_sig(fn_sig) |t| {\n             ty::fold_regions(self.tcx, t, fldr)\n-        };\n-        ty::FnTyBase {meta: fn_ty.meta, sig: sig}\n+        }\n     }\n \n }"}, {"sha": "54854bed65e31e72c6152431cf5808110605b12f", "filename": "src/librustc/middle/typeck/infer/region_inference.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs?ref=2b92962aa29b0116015f99c1666ecf6288303c65", "patch": "@@ -544,10 +544,11 @@ use core::prelude::*;\n use middle::region::is_subregion_of;\n use middle::region;\n use middle::ty;\n-use middle::ty::{Region, RegionVid, br_fresh, re_bound, re_free, re_infer};\n-use middle::ty::{re_scope, re_static, ReVar, ReSkolemized};\n+use middle::ty::{Region, RegionVid, re_static, re_infer, re_free, re_bound};\n+use middle::ty::{re_scope, ReVar, ReSkolemized, br_fresh};\n+use middle::typeck::infer::to_str::InferStr;\n use middle::typeck::infer::cres;\n-use middle::typeck::infer::to_str::ToStr;\n+use syntax::codemap;\n use util::common::indenter;\n use util::ppaux::note_and_explain_region;\n "}, {"sha": "23be3b208271c55d0fac4884e2e6c3378503ced4", "filename": "src/librustc/middle/typeck/infer/resolve.rs", "status": "modified", "additions": 80, "deletions": 90, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs?ref=2b92962aa29b0116015f99c1666ecf6288303c65", "patch": "@@ -51,60 +51,61 @@ use core::prelude::*;\n use middle::ty::{FloatVar, FloatVid, IntVar, IntVid, RegionVid, TyVar, TyVid};\n use middle::ty::{type_is_bot};\n use middle::ty;\n-use middle::typeck::infer::{cyclic_ty, fixup_err, fres, infer_ctxt};\n+use middle::typeck::infer::{cyclic_ty, fixup_err, fres, InferCtxt};\n use middle::typeck::infer::{region_var_bound_by_region_var, unresolved_ty};\n-use middle::typeck::infer::floating::*;\n-use middle::typeck::infer::floating;\n-use middle::typeck::infer::integral::*;\n-use middle::typeck::infer::integral;\n-use middle::typeck::infer::to_str::ToStr;\n-use middle::typeck::infer::unify::root;\n-use util::common::indent;\n+use middle::typeck::infer::{IntType, UintType};\n+use middle::typeck::infer::to_str::InferStr;\n+use middle::typeck::infer::unify::Root;\n+use util::common::{indent, indenter};\n use util::ppaux::ty_to_str;\n \n+use syntax::ast;\n+\n use core::uint;\n use core::vec;\n \n-const resolve_nested_tvar: uint = 0b00000001;\n-const resolve_rvar: uint        = 0b00000010;\n-const resolve_ivar: uint        = 0b00000100;\n-const resolve_fvar: uint        = 0b00001000;\n-const resolve_all: uint         = 0b00001111;\n-const force_tvar: uint          = 0b00010000;\n-const force_rvar: uint          = 0b00100000;\n-const force_ivar: uint          = 0b01000000;\n-const force_fvar: uint          = 0b11000000;\n-const force_all: uint           = 0b11110000;\n+const resolve_nested_tvar: uint = 0b0000000001;\n+const resolve_rvar: uint        = 0b0000000010;\n+const resolve_ivar: uint        = 0b0000000100;\n+const resolve_fvar: uint        = 0b0000001000;\n+const resolve_fnvar: uint       = 0b0000010000;\n+const resolve_all: uint         = 0b0000011111;\n+const force_tvar: uint          = 0b0000100000;\n+const force_rvar: uint          = 0b0001000000;\n+const force_ivar: uint          = 0b0010000000;\n+const force_fvar: uint          = 0b0100000000;\n+const force_fnvar: uint         = 0b1000000000;\n+const force_all: uint           = 0b1111100000;\n \n const not_regions: uint         = !(force_rvar | resolve_rvar);\n \n const resolve_and_force_all_but_regions: uint =\n     (resolve_all | force_all) & not_regions;\n \n-type resolve_state_ = {\n-    infcx: infer_ctxt,\n+struct ResolveState {\n+    infcx: @InferCtxt,\n     modes: uint,\n     mut err: Option<fixup_err>,\n-    mut v_seen: ~[TyVid]\n-};\n-\n-enum resolve_state {\n-    resolve_state_(@resolve_state_)\n+    mut v_seen: ~[TyVid],\n+    mut type_depth: uint\n }\n \n-fn resolver(infcx: infer_ctxt, modes: uint) -> resolve_state {\n-    resolve_state_(@{infcx: infcx,\n-                     modes: modes,\n-                     mut err: None,\n-                     mut v_seen: ~[]})\n+fn resolver(infcx: @InferCtxt, modes: uint) -> ResolveState {\n+    ResolveState {\n+        infcx: infcx,\n+        modes: modes,\n+        err: None,\n+        v_seen: ~[],\n+        type_depth: 0\n+    }\n }\n \n-impl resolve_state {\n-    fn should(mode: uint) -> bool {\n+impl ResolveState {\n+    fn should(&self, mode: uint) -> bool {\n         (self.modes & mode) == mode\n     }\n \n-    fn resolve_type_chk(typ: ty::t) -> fres<ty::t> {\n+    fn resolve_type_chk(&self, typ: ty::t) -> fres<ty::t> {\n         self.err = None;\n \n         debug!(\"Resolving %s (modes=%x)\",\n@@ -129,7 +130,7 @@ impl resolve_state {\n         }\n     }\n \n-    fn resolve_region_chk(orig: ty::Region) -> fres<ty::Region> {\n+    fn resolve_region_chk(&self, orig: ty::Region) -> fres<ty::Region> {\n         self.err = None;\n         let resolved = indent(|| self.resolve_region(orig) );\n         match self.err {\n@@ -138,63 +139,64 @@ impl resolve_state {\n         }\n     }\n \n-    fn resolve_type(typ: ty::t) -> ty::t {\n-        debug!(\"resolve_type(%s)\", typ.to_str(self.infcx));\n-        indent(fn&() -> ty::t {\n-            if !ty::type_needs_infer(typ) { return typ; }\n+    fn resolve_type(&self, typ: ty::t) -> ty::t {\n+        debug!(\"resolve_type(%s)\", typ.inf_str(self.infcx));\n+        let _i = indenter();\n+\n+        if !ty::type_needs_infer(typ) {\n+            return typ;\n+        }\n+\n+        if self.type_depth > 0 && !self.should(resolve_nested_tvar) {\n+            return typ;\n+        }\n \n-            match copy ty::get(typ).sty {\n-              ty::ty_infer(TyVar(vid)) => {\n+        match /*bad*/ copy ty::get(typ).sty {\n+            ty::ty_infer(TyVar(vid)) => {\n                 self.resolve_ty_var(vid)\n-              }\n-              ty::ty_infer(IntVar(vid)) => {\n+            }\n+            ty::ty_infer(IntVar(vid)) => {\n                 self.resolve_int_var(vid)\n-              }\n-              ty::ty_infer(FloatVar(vid)) => {\n+            }\n+            ty::ty_infer(FloatVar(vid)) => {\n                 self.resolve_float_var(vid)\n-              }\n-              _ => {\n-                if !self.should(resolve_rvar) &&\n-                    !self.should(resolve_nested_tvar) {\n-                    // shortcircuit for efficiency\n+            }\n+            _ => {\n+                if self.modes & resolve_all == 0 {\n+                    // if we are only resolving top-level type\n+                    // variables, and this is not a top-level type\n+                    // variable, then shortcircuit for efficiency\n                     typ\n                 } else {\n-                    ty::fold_regions_and_ty(\n+                    self.type_depth += 1;\n+                    let result = ty::fold_regions_and_ty(\n                         self.infcx.tcx, typ,\n                         |r| self.resolve_region(r),\n-                        |t| self.resolve_nested_tvar(t),\n-                        |t| self.resolve_nested_tvar(t))\n+                        |t| self.resolve_type(t),\n+                        |t| self.resolve_type(t));\n+                    self.type_depth -= 1;\n+                    result\n                 }\n-              }\n             }\n-        })\n-    }\n-\n-    fn resolve_nested_tvar(typ: ty::t) -> ty::t {\n-        debug!(\"Resolve_if_deep(%s)\", typ.to_str(self.infcx));\n-        if !self.should(resolve_nested_tvar) {\n-            typ\n-        } else {\n-            self.resolve_type(typ)\n         }\n     }\n \n-    fn resolve_region(orig: ty::Region) -> ty::Region {\n-        debug!(\"Resolve_region(%s)\", orig.to_str(self.infcx));\n+    fn resolve_region(&self, orig: ty::Region) -> ty::Region {\n+        debug!(\"Resolve_region(%s)\", orig.inf_str(self.infcx));\n         match orig {\n           ty::re_infer(ty::ReVar(rid)) => self.resolve_region_var(rid),\n           _ => orig\n         }\n     }\n \n-    fn resolve_region_var(rid: RegionVid) -> ty::Region {\n+    fn resolve_region_var(&self, rid: RegionVid) -> ty::Region {\n         if !self.should(resolve_rvar) {\n             return ty::re_infer(ty::ReVar(rid));\n         }\n         self.infcx.region_vars.resolve_var(rid)\n     }\n \n-    fn assert_not_rvar(rid: RegionVid, r: ty::Region) {\n+    fn assert_not_rvar(&self, rid: RegionVid, r: ty::Region) {\n         match r {\n           ty::re_infer(ty::ReVar(rid2)) => {\n             self.err = Some(region_var_bound_by_region_var(rid, rid2));\n@@ -203,7 +205,7 @@ impl resolve_state {\n         }\n     }\n \n-    fn resolve_ty_var(vid: TyVid) -> ty::t {\n+    fn resolve_ty_var(&self, vid: TyVid) -> ty::t {\n         if vec::contains(self.v_seen, &vid) {\n             self.err = Some(cyclic_ty(vid));\n             return ty::mk_var(self.infcx.tcx, vid);\n@@ -236,27 +238,22 @@ impl resolve_state {\n         }\n     }\n \n-    fn resolve_int_var(vid: IntVid) -> ty::t {\n+    fn resolve_int_var(&self, vid: IntVid) -> ty::t {\n         if !self.should(resolve_ivar) {\n             return ty::mk_int_var(self.infcx.tcx, vid);\n         }\n \n-        let nde = self.infcx.get(&self.infcx.int_var_bindings, vid);\n-        let pt = nde.possible_types;\n-\n-        // If there's only one type in the set of possible types, then\n-        // that's the answer.\n-        match integral::single_type_contained_in(self.infcx.tcx, pt) {\n-          Some(t) => t,\n+        let node = self.infcx.get(&self.infcx.int_var_bindings, vid);\n+        match node.possible_types {\n+          Some(IntType(t)) => ty::mk_mach_int(self.infcx.tcx, t),\n+          Some(UintType(t)) => ty::mk_mach_uint(self.infcx.tcx, t),\n           None => {\n             if self.should(force_ivar) {\n                 // As a last resort, default to int.\n                 let ty = ty::mk_int(self.infcx.tcx);\n                 self.infcx.set(\n                     &self.infcx.int_var_bindings, vid,\n-                    root(convert_integral_ty_to_int_ty_set(self.infcx.tcx,\n-                                                           ty),\n-                        nde.rank));\n+                    Root(Some(IntType(ast::ty_i)), node.rank));\n                 ty\n             } else {\n                 ty::mk_int_var(self.infcx.tcx, vid)\n@@ -265,29 +262,22 @@ impl resolve_state {\n         }\n     }\n \n-    fn resolve_float_var(vid: FloatVid) -> ty::t {\n+    fn resolve_float_var(&self, vid: FloatVid) -> ty::t {\n         if !self.should(resolve_fvar) {\n             return ty::mk_float_var(self.infcx.tcx, vid);\n         }\n \n-        let nde = self.infcx.get(&self.infcx.float_var_bindings, vid);\n-        let pt = nde.possible_types;\n-\n-        // If there's only one type in the set of possible types, then\n-        // that's the answer.\n-        match floating::single_type_contained_in(self.infcx.tcx, pt) {\n-          Some(t) => t,\n+        let node = self.infcx.get(&self.infcx.float_var_bindings, vid);\n+        match node.possible_types {\n+          Some(t) => ty::mk_mach_float(self.infcx.tcx, t),\n           None => {\n             if self.should(force_fvar) {\n                 // As a last resort, default to float.\n                 let ty = ty::mk_float(self.infcx.tcx);\n                 self.infcx.set(\n                     &self.infcx.float_var_bindings,\n                     vid,\n-                    root(\n-                        convert_floating_point_ty_to_float_ty_set(\n-                            self.infcx.tcx, ty),\n-                        nde.rank));\n+                    Root(Some(ast::ty_f), node.rank));\n                 ty\n             } else {\n                 ty::mk_float_var(self.infcx.tcx, vid)"}, {"sha": "aa6721fb2298390811f731ef9af8d71a05e9bc73", "filename": "src/librustc/middle/typeck/infer/sub.rs", "status": "modified", "additions": 60, "deletions": 51, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs?ref=2b92962aa29b0116015f99c1666ecf6288303c65", "patch": "@@ -11,13 +11,13 @@\n use core::prelude::*;\n \n use middle::ty;\n-use middle::typeck::check::regionmanip::replace_bound_regions_in_fn_ty;\n+use middle::typeck::check::regionmanip::replace_bound_regions_in_fn_sig;\n use middle::typeck::infer::combine::*;\n use middle::typeck::infer::cres;\n use middle::typeck::infer::glb::Glb;\n-use middle::typeck::infer::infer_ctxt;\n+use middle::typeck::infer::InferCtxt;\n use middle::typeck::infer::lub::Lub;\n-use middle::typeck::infer::to_str::ToStr;\n+use middle::typeck::infer::to_str::InferStr;\n use middle::typeck::infer::unify::*;\n use util::ppaux::bound_region_to_str;\n \n@@ -27,10 +27,10 @@ use syntax::ast::{m_const, purity, ret_style};\n \n fn macros() { include!(\"macros.rs\"); } // FIXME(#3114): Macro import/export.\n \n-enum Sub = combine_fields;  // \"subtype\", \"subregion\" etc\n+enum Sub = CombineFields;  // \"subtype\", \"subregion\" etc\n \n-impl Sub: combine {\n-    fn infcx() -> infer_ctxt { self.infcx }\n+impl Sub: Combine {\n+    fn infcx() -> @InferCtxt { self.infcx }\n     fn tag() -> ~str { ~\"sub\" }\n     fn a_is_expected() -> bool { self.a_is_expected }\n     fn span() -> span { self.span }\n@@ -40,14 +40,14 @@ impl Sub: combine {\n     fn glb() -> Glb { Glb(*self) }\n \n     fn contratys(a: ty::t, b: ty::t) -> cres<ty::t> {\n-        let opp = combine_fields {\n+        let opp = CombineFields {\n             a_is_expected: !self.a_is_expected,.. *self\n         };\n         Sub(opp).tys(b, a)\n     }\n \n     fn contraregions(a: ty::Region, b: ty::Region) -> cres<ty::Region> {\n-        let opp = combine_fields {\n+        let opp = CombineFields {\n             a_is_expected: !self.a_is_expected,.. *self\n         };\n         Sub(opp).regions(b, a)\n@@ -56,8 +56,8 @@ impl Sub: combine {\n     fn regions(a: ty::Region, b: ty::Region) -> cres<ty::Region> {\n         debug!(\"%s.regions(%s, %s)\",\n                self.tag(),\n-               a.to_str(self.infcx),\n-               b.to_str(self.infcx));\n+               a.inf_str(self.infcx),\n+               b.inf_str(self.infcx));\n         do indent {\n             match self.infcx.region_vars.make_subregion(self.span, a, b) {\n               Ok(()) => Ok(a),\n@@ -67,7 +67,7 @@ impl Sub: combine {\n     }\n \n     fn mts(a: ty::mt, b: ty::mt) -> cres<ty::mt> {\n-        debug!(\"mts(%s <: %s)\", a.to_str(self.infcx), b.to_str(self.infcx));\n+        debug!(\"mts(%s <: %s)\", a.inf_str(self.infcx), b.inf_str(self.infcx));\n \n         if a.mutbl != b.mutbl && b.mutbl != m_const {\n             return Err(ty::terr_mutability);\n@@ -86,14 +86,6 @@ impl Sub: combine {\n         }\n     }\n \n-    fn protos(p1: ast::Proto, p2: ast::Proto) -> cres<ast::Proto> {\n-        match (p1, p2) {\n-            (ast::ProtoBare, _) => Ok(p1),\n-            _ if p1 == p2 => Ok(p1),\n-            _ => Err(ty::terr_proto_mismatch(expected_found(&self, p1, p2)))\n-        }\n-    }\n-\n     fn purities(a: purity, b: purity) -> cres<purity> {\n         self.lub().purities(a, b).compare(b, || {\n             ty::terr_purity_mismatch(expected_found(&self, a, b))\n@@ -108,34 +100,47 @@ impl Sub: combine {\n \n     fn tys(a: ty::t, b: ty::t) -> cres<ty::t> {\n         debug!(\"%s.tys(%s, %s)\", self.tag(),\n-               a.to_str(self.infcx), b.to_str(self.infcx));\n+               a.inf_str(self.infcx), b.inf_str(self.infcx));\n         if a == b { return Ok(a); }\n         do indent {\n             match (ty::get(a).sty, ty::get(b).sty) {\n-              (ty::ty_bot, _) => {\n-                Ok(a)\n-              }\n-              (ty::ty_infer(TyVar(a_id)), ty::ty_infer(TyVar(b_id))) => {\n-                var_sub_var(&self, a_id, b_id).then(|| Ok(a) )\n-              }\n-              (ty::ty_infer(TyVar(a_id)), _) => {\n-                var_sub_t(&self, a_id, b).then(|| Ok(a) )\n-              }\n-              (_, ty::ty_infer(TyVar(b_id))) => {\n-                t_sub_var(&self, a, b_id).then(|| Ok(a) )\n-              }\n-              (_, ty::ty_bot) => {\n-                Err(ty::terr_sorts(expected_found(&self, a, b)))\n-              }\n-              _ => {\n-                super_tys(&self, a, b)\n-              }\n+                (ty::ty_bot, _) => {\n+                    Ok(a)\n+                }\n+\n+                (ty::ty_infer(TyVar(a_id)), ty::ty_infer(TyVar(b_id))) => {\n+                    do self.var_sub_var(&self.infcx.ty_var_bindings,\n+                                        a_id, b_id).then {\n+                        Ok(a)\n+                    }\n+                }\n+                (ty::ty_infer(TyVar(a_id)), _) => {\n+                    do self.var_sub_t(&self.infcx.ty_var_bindings,\n+                                      a_id, b).then {\n+                        Ok(a)\n+                    }\n+                }\n+                (_, ty::ty_infer(TyVar(b_id))) => {\n+                    do self.t_sub_var(&self.infcx.ty_var_bindings,\n+                                      a, b_id).then {\n+                        Ok(a)\n+                    }\n+                }\n+\n+                (_, ty::ty_bot) => {\n+                    Err(ty::terr_sorts(expected_found(&self, a, b)))\n+                }\n+\n+                _ => {\n+                    super_tys(&self, a, b)\n+                }\n             }\n         }\n     }\n \n-    fn fns(a: &ty::FnTy, b: &ty::FnTy) -> cres<ty::FnTy> {\n-        debug!(\"fns(a=%s, b=%s)\", a.to_str(self.infcx), b.to_str(self.infcx));\n+    fn fn_sigs(a: &ty::FnSig, b: &ty::FnSig) -> cres<ty::FnSig> {\n+        debug!(\"fn_sigs(a=%s, b=%s)\",\n+               a.inf_str(self.infcx), b.inf_str(self.infcx));\n         let _indenter = indenter();\n \n         // Rather than checking the subtype relationship between `a` and `b`\n@@ -153,14 +158,14 @@ impl Sub: combine {\n \n         // First, we instantiate each bound region in the subtype with a fresh\n         // region variable.\n-        let (a_fn_ty, _) =\n+        let (a_sig, _) =\n             self.infcx.replace_bound_regions_with_fresh_regions(\n                 self.span, a);\n \n         // Second, we instantiate each bound region in the supertype with a\n         // fresh concrete region.\n-        let {fn_ty: b_fn_ty, isr: skol_isr, _} = {\n-            do replace_bound_regions_in_fn_ty(self.infcx.tcx, @Nil,\n+        let {fn_sig: b_sig, isr: skol_isr, _} = {\n+            do replace_bound_regions_in_fn_sig(self.infcx.tcx, @Nil,\n                                               None, b) |br| {\n                 let skol = self.infcx.region_vars.new_skolemized(br);\n                 debug!(\"Bound region %s skolemized to %?\",\n@@ -170,11 +175,11 @@ impl Sub: combine {\n             }\n         };\n \n-        debug!(\"a_fn_ty=%s\", a_fn_ty.to_str(self.infcx));\n-        debug!(\"b_fn_ty=%s\", b_fn_ty.to_str(self.infcx));\n+        debug!(\"a_sig=%s\", a_sig.inf_str(self.infcx));\n+        debug!(\"b_sig=%s\", b_sig.inf_str(self.infcx));\n \n         // Compare types now that bound regions have been replaced.\n-        let fn_ty = if_ok!(super_fns(&self, &a_fn_ty, &b_fn_ty));\n+        let sig = if_ok!(super_fn_sigs(&self, &a_sig, &b_sig));\n \n         // Presuming type comparison succeeds, we need to check\n         // that the skolemized regions do not \"leak\".\n@@ -206,21 +211,25 @@ impl Sub: combine {\n             }\n         }\n \n-        return Ok(fn_ty)\n+        return Ok(sig);\n     }\n \n     // Traits please (FIXME: #2794):\n \n+    fn protos(p1: ast::Proto, p2: ast::Proto) -> cres<ast::Proto> {\n+        super_protos(&self, p1, p2)\n+    }\n+\n     fn flds(a: ty::field, b: ty::field) -> cres<ty::field> {\n         super_flds(&self, a, b)\n     }\n \n-    fn fn_metas(a: &ty::FnMeta, b: &ty::FnMeta) -> cres<ty::FnMeta> {\n-        super_fn_metas(&self, a, b)\n+    fn fns(a: &ty::FnTy, b: &ty::FnTy) -> cres<ty::FnTy> {\n+        super_fns(&self, a, b)\n     }\n \n-    fn fn_sigs(a: &ty::FnSig, b: &ty::FnSig) -> cres<ty::FnSig> {\n-        super_fn_sigs(&self, a, b)\n+    fn fn_metas(a: &ty::FnMeta, b: &ty::FnMeta) -> cres<ty::FnMeta> {\n+        super_fn_metas(&self, a, b)\n     }\n \n     fn vstores(vk: ty::terr_vstore_kind,"}, {"sha": "42f516fe6d8803b0190ff08a0c20cd2fcfed288f", "filename": "src/librustc/middle/typeck/infer/to_str.rs", "status": "modified", "additions": 54, "deletions": 39, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fto_str.rs?ref=2b92962aa29b0116015f99c1666ecf6288303c65", "patch": "@@ -10,86 +10,101 @@\n \n use core::prelude::*;\n \n-use middle::ty::vid;\n+use middle::ty::{FnMeta, FnTyBase, FnSig, FnVid, Vid};\n use middle::ty;\n-use middle::typeck::infer::{bound, bounds};\n-use middle::typeck::infer::floating::float_ty_set;\n-use middle::typeck::infer::infer_ctxt;\n-use middle::typeck::infer::integral::int_ty_set;\n-use middle::typeck::infer::unify::{redirect, root, var_value};\n+use middle::typeck::infer::{Bound, Bounds};\n+use middle::typeck::infer::{IntVarValue, IntType, UintType};\n+use middle::typeck::infer::InferCtxt;\n+use middle::typeck::infer::unify::{Redirect, Root, VarValue};\n use util::ppaux::{mt_to_str, ty_to_str};\n use util::ppaux;\n \n+use syntax::{ast, ast_util};\n+\n use core::uint;\n+use core::str;\n \n-trait ToStr {\n-    fn to_str(cx: infer_ctxt) -> ~str;\n+pub trait InferStr {\n+    fn inf_str(cx: @InferCtxt) -> ~str;\n }\n \n-impl ty::t: ToStr {\n-    fn to_str(cx: infer_ctxt) -> ~str {\n+impl ty::t : InferStr {\n+    fn inf_str(cx: @InferCtxt) -> ~str {\n         ty_to_str(cx.tcx, self)\n     }\n }\n \n-impl ty::mt: ToStr {\n-    fn to_str(cx: infer_ctxt) -> ~str {\n-        mt_to_str(cx.tcx, self)\n+impl FnMeta : InferStr {\n+    fn inf_str(_cx: @InferCtxt) -> ~str {\n+        fmt!(\"%?\", self)\n     }\n }\n \n-impl ty::Region: ToStr {\n-    fn to_str(cx: infer_ctxt) -> ~str {\n-        ppaux::region_to_str(cx.tcx, self)\n+impl FnSig : InferStr {\n+    fn inf_str(cx: @InferCtxt) -> ~str {\n+        fmt!(\"(%s) -> %s\",\n+             str::connect(self.inputs.map(|a| a.ty.inf_str(cx)), \", \"),\n+             self.output.inf_str(cx))\n     }\n }\n \n-impl ty::FnTy: ToStr {\n-    fn to_str(cx: infer_ctxt) -> ~str {\n-        ty::mk_fn(cx.tcx, self).to_str(cx)\n+impl<M:InferStr> FnTyBase<M> : InferStr {\n+    fn inf_str(cx: @InferCtxt) -> ~str {\n+        fmt!(\"%s%s\", self.meta.inf_str(cx), self.sig.inf_str(cx))\n     }\n }\n \n-impl<V:Copy ToStr> bound<V>: ToStr {\n-    fn to_str(cx: infer_ctxt) -> ~str {\n+impl ty::mt : InferStr {\n+    fn inf_str(cx: @InferCtxt) -> ~str {\n+        mt_to_str(cx.tcx, self)\n+    }\n+}\n+\n+impl ty::Region : InferStr {\n+    fn inf_str(_cx: @InferCtxt) -> ~str {\n+        fmt!(\"%?\", self)\n+    }\n+}\n+\n+impl<V:InferStr> Bound<V> : InferStr {\n+    fn inf_str(cx: @InferCtxt) -> ~str {\n         match self {\n-          Some(ref v) => (*v).to_str(cx),\n+          Some(ref v) => v.inf_str(cx),\n           None => ~\"none\"\n         }\n     }\n }\n \n-impl<T:Copy ToStr> bounds<T>: ToStr {\n-    fn to_str(cx: infer_ctxt) -> ~str {\n+impl<T:InferStr> Bounds<T> : InferStr {\n+    fn inf_str(cx: @InferCtxt) -> ~str {\n         fmt!(\"{%s <: %s}\",\n-             self.lb.to_str(cx),\n-             self.ub.to_str(cx))\n+             self.lb.inf_str(cx),\n+             self.ub.inf_str(cx))\n     }\n }\n \n-impl int_ty_set: ToStr {\n-    fn to_str(_cx: infer_ctxt) -> ~str {\n+impl<V:Vid ToStr, T:InferStr> VarValue<V, T> : InferStr {\n+    fn inf_str(cx: @InferCtxt) -> ~str {\n         match self {\n-          int_ty_set(v) => uint::to_str(v, 10u)\n+          Redirect(ref vid) => fmt!(\"Redirect(%s)\", vid.to_str()),\n+          Root(ref pt, rk) => fmt!(\"Root(%s, %s)\", pt.inf_str(cx),\n+                               uint::to_str(rk, 10u))\n         }\n     }\n }\n \n-impl float_ty_set: ToStr {\n-    fn to_str(_cx: infer_ctxt) -> ~str {\n+impl IntVarValue : InferStr {\n+    fn inf_str(_cx: @InferCtxt) -> ~str {\n         match self {\n-          float_ty_set(v) => uint::to_str(v, 10u)\n+            IntType(t) => ast_util::int_ty_to_str(t),\n+            UintType(t) => ast_util::uint_ty_to_str(t)\n         }\n     }\n }\n \n-impl<V:Copy vid, T:Copy ToStr> var_value<V, T>: ToStr {\n-    fn to_str(cx: infer_ctxt) -> ~str {\n-        match self {\n-          redirect(ref vid) => fmt!(\"redirect(%s)\", (*vid).to_str()),\n-          root(ref pt, rk) => fmt!(\"root(%s, %s)\", (*pt).to_str(cx),\n-                               uint::to_str(rk, 10u))\n-        }\n+impl ast::float_ty : InferStr {\n+    fn inf_str(_cx: @InferCtxt) -> ~str {\n+        ast_util::float_ty_to_str(self)\n     }\n }\n "}, {"sha": "77bd46eea2dfd29eba5b79d556e0fec9514243e7", "filename": "src/librustc/middle/typeck/infer/unify.rs", "status": "modified", "additions": 120, "deletions": 409, "changes": 529, "blob_url": "https://github.com/rust-lang/rust/blob/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs?ref=2b92962aa29b0116015f99c1666ecf6288303c65", "patch": "@@ -10,40 +10,45 @@\n \n use core::prelude::*;\n \n-use middle::ty::vid;\n+use middle::ty::Vid;\n use middle::ty;\n-use middle::typeck::infer::{bound, bounds, cres, uok, ures};\n-use middle::typeck::infer::combine::combine;\n-use middle::typeck::infer::floating::*;\n-use middle::typeck::infer::floating;\n-use middle::typeck::infer::infer_ctxt;\n-use middle::typeck::infer::integral::*;\n-use middle::typeck::infer::integral;\n-use middle::typeck::infer::to_str::ToStr;\n+use middle::typeck::infer::{Bound, Bounds, cres, uok, ures};\n+use middle::typeck::infer::combine::Combine;\n+use middle::typeck::infer::InferCtxt;\n+use middle::typeck::infer::to_str::InferStr;\n use util::common::{indent, indenter};\n \n use core::result;\n use std::smallintmap::SmallIntMap;\n \n-enum var_value<V:Copy, T:Copy> {\n-    redirect(V),\n-    root(T, uint),\n+enum VarValue<V, T> {\n+    Redirect(V),\n+    Root(T, uint),\n }\n \n-struct vals_and_bindings<V:Copy, T:Copy> {\n-    vals: SmallIntMap<var_value<V, T>>,\n-    mut bindings: ~[(V, var_value<V, T>)],\n+struct ValsAndBindings<V:Copy, T:Copy> {\n+    vals: SmallIntMap<VarValue<V, T>>,\n+    mut bindings: ~[(V, VarValue<V, T>)],\n }\n \n-struct node<V:Copy, T:Copy> {\n+struct Node<V:Copy, T:Copy> {\n     root: V,\n     possible_types: T,\n     rank: uint,\n }\n \n-impl infer_ctxt {\n-    fn get<V:Copy vid Eq, T:Copy>(\n-        vb: &vals_and_bindings<V, T>, vid: V) -> node<V, T> {\n+impl @InferCtxt {\n+    fn get<V:Copy Eq Vid, T:Copy>(\n+        vb: &ValsAndBindings<V, T>,\n+        vid: V)\n+        -> Node<V, T>\n+    {\n+        /*!\n+         *\n+         * Find the root node for `vid`. This uses the standard\n+         * union-find algorithm with path compression:\n+         * http://en.wikipedia.org/wiki/Disjoint-set_data_structure\n+         */\n \n         let vid_u = vid.to_uint();\n         match vb.vals.find(vid_u) {\n@@ -52,435 +57,141 @@ impl infer_ctxt {\n           }\n           Some(ref var_val) => {\n             match (*var_val) {\n-              redirect(ref vid) => {\n+              Redirect(ref vid) => {\n                 let node = self.get(vb, (*vid));\n                 if node.root.ne(vid) {\n                     // Path compression\n-                    vb.vals.insert((*vid).to_uint(), redirect(node.root));\n+                    vb.vals.insert(vid.to_uint(), Redirect(node.root));\n                 }\n                 node\n               }\n-              root(ref pt, rk) => {\n-                node {root: vid, possible_types: (*pt), rank: rk}\n+              Root(ref pt, rk) => {\n+                Node {root: vid, possible_types: *pt, rank: rk}\n               }\n             }\n           }\n         }\n     }\n \n-    fn set<V:Copy vid, T:Copy ToStr>(\n-        vb: &vals_and_bindings<V, T>, vid: V,\n-        +new_v: var_value<V, T>) {\n+    fn set<V:Copy Vid ToStr, T:Copy InferStr>(\n+        vb: &ValsAndBindings<V, T>,\n+        vid: V,\n+        +new_v: VarValue<V, T>)\n+    {\n+        /*!\n+         *\n+         * Sets the value for `vid` to `new_v`.  `vid` MUST be a root node!\n+         */\n \n         let old_v = vb.vals.get(vid.to_uint());\n         vb.bindings.push((vid, old_v));\n         vb.vals.insert(vid.to_uint(), new_v);\n \n         debug!(\"Updating variable %s from %s to %s\",\n-               vid.to_str(), old_v.to_str(self), new_v.to_str(self));\n+               vid.to_str(), old_v.inf_str(self), new_v.inf_str(self));\n     }\n-}\n-\n-// Combines the two bounds into a more general bound.\n-fn merge_bnd<C: combine>(\n-    self: &C, a: bound<ty::t>, b: bound<ty::t>,\n-    merge_op: fn(ty::t,ty::t) -> cres<ty::t>) -> cres<bound<ty::t>> {\n-\n-    debug!(\"merge_bnd(%s,%s)\",\n-           a.to_str(self.infcx()),\n-           b.to_str(self.infcx()));\n-    let _r = indenter();\n-\n-    match (a, b) {\n-      (None, None) => Ok(None),\n-      (Some(_), None) => Ok(a),\n-      (None, Some(_)) => Ok(b),\n-      (Some(v_a), Some(v_b)) => {\n-        do merge_op(v_a, v_b).chain |v| {\n-            Ok(Some(v))\n-        }\n-      }\n-    }\n-}\n-\n-fn merge_bnds<C: combine>(\n-    self: &C, a: bounds<ty::t>, b: bounds<ty::t>,\n-    lub: fn(ty::t,ty::t) -> cres<ty::t>,\n-    glb: fn(ty::t,ty::t) -> cres<ty::t>) -> cres<bounds<ty::t>> {\n-\n-    let _r = indenter();\n-    do merge_bnd(self, a.ub, b.ub, glb).chain |ub| {\n-        debug!(\"glb of ubs %s and %s is %s\",\n-               a.ub.to_str(self.infcx()),\n-               b.ub.to_str(self.infcx()),\n-               ub.to_str(self.infcx()));\n-        do merge_bnd(self, a.lb, b.lb, lub).chain |lb| {\n-            debug!(\"lub of lbs %s and %s is %s\",\n-                   a.lb.to_str(self.infcx()),\n-                   b.lb.to_str(self.infcx()),\n-                   lb.to_str(self.infcx()));\n-            Ok({lb: lb, ub: ub})\n-        }\n-    }\n-}\n-\n-// Updates the bounds for the variable `v_id` to be the intersection\n-// of `a` and `b`.  That is, the new bounds for `v_id` will be\n-// a bounds c such that:\n-//    c.ub <: a.ub\n-//    c.ub <: b.ub\n-//    a.lb <: c.lb\n-//    b.lb <: c.lb\n-// If this cannot be achieved, the result is failure.\n-\n-fn set_var_to_merged_bounds<C: combine>(\n-    self: &C,\n-    v_id: ty::TyVid,\n-    a: bounds<ty::t>,\n-    b: bounds<ty::t>,\n-    rank: uint) -> ures {\n-\n-    let vb = &self.infcx().ty_var_bindings;\n-\n-    // Think of the two diamonds, we want to find the\n-    // intersection.  There are basically four possibilities (you\n-    // can swap A/B in these pictures):\n-    //\n-    //       A         A\n-    //      / \\       / \\\n-    //     / B \\     / B \\\n-    //    / / \\ \\   / / \\ \\\n-    //   * *   * * * /   * *\n-    //    \\ \\ / /   \\   / /\n-    //     \\ B /   / \\ / /\n-    //      \\ /   *   \\ /\n-    //       A     \\ / A\n-    //              B\n-\n-    debug!(\"merge(%s,%s,%s)\",\n-           v_id.to_str(),\n-           a.to_str(self.infcx()),\n-           b.to_str(self.infcx()));\n-\n-    // First, relate the lower/upper bounds of A and B.\n-    // Note that these relations *must* hold for us to\n-    // to be able to merge A and B at all, and relating\n-    // them explicitly gives the type inferencer more\n-    // information and helps to produce tighter bounds\n-    // when necessary.\n-    do indent {\n-        do bnds(self, a.lb, b.ub).then {\n-            do bnds(self, b.lb, a.ub).then {\n-                do merge_bnd(self, a.ub, b.ub,\n-                             |x, y| self.glb().tys(x, y)).chain |ub| {\n-                    do merge_bnd(self, a.lb, b.lb,\n-                                 |x, y| self.lub().tys(x, y)).chain |lb| {\n-                        let bounds = {lb: lb, ub: ub};\n-                        debug!(\"merge(%s): bounds=%s\",\n-                               v_id.to_str(),\n-                               bounds.to_str(self.infcx()));\n-\n-                        // the new bounds must themselves\n-                        // be relatable:\n-                        do bnds(self, bounds.lb, bounds.ub).then {\n-                            self.infcx().set(vb, v_id, root(bounds, rank));\n-                            uok()\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-/// Ensure that variable A is a subtype of variable B.  This is a\n-/// subtle and tricky process, as described in detail at the top\n-/// of infer.rs\n-fn var_sub_var<C: combine>(self: &C,\n-                           a_id: ty::TyVid,\n-                           b_id: ty::TyVid) -> ures {\n-    let vb = &self.infcx().ty_var_bindings;\n-\n-    // Need to make sub_id a subtype of sup_id.\n-    let nde_a = self.infcx().get(vb, a_id);\n-    let nde_b = self.infcx().get(vb, b_id);\n-    let a_id = nde_a.root;\n-    let b_id = nde_b.root;\n-    let a_bounds = nde_a.possible_types;\n-    let b_bounds = nde_b.possible_types;\n-\n-    debug!(\"vars(%s=%s <: %s=%s)\",\n-           a_id.to_str(), a_bounds.to_str(self.infcx()),\n-           b_id.to_str(), b_bounds.to_str(self.infcx()));\n-\n-    if a_id == b_id { return uok(); }\n-\n-    // If both A's UB and B's LB have already been bound to types,\n-    // see if we can make those types subtypes.\n-    match (a_bounds.ub, b_bounds.lb) {\n-      (Some(a_ub), Some(b_lb)) => {\n-        let r = self.infcx().try(|| self.sub().tys(a_ub, b_lb));\n-        match r {\n-          Ok(_ty) => return result::Ok(()),\n-          Err(_) => { /*fallthrough */ }\n-        }\n-      }\n-      _ => { /*fallthrough*/ }\n-    }\n-\n-    // Otherwise, we need to merge A and B so as to guarantee that\n-    // A remains a subtype of B.  Actually, there are other options,\n-    // but that's the route we choose to take.\n-\n-    // Rank optimization\n-\n-    // Make the node with greater rank the parent of the node with\n-    // smaller rank.\n-    if nde_a.rank > nde_b.rank {\n-        debug!(\"vars(): a has smaller rank\");\n-        // a has greater rank, so a should become b's parent,\n-        // i.e., b should redirect to a.\n-        self.infcx().set(vb, b_id, redirect(a_id));\n-        set_var_to_merged_bounds(\n-            self, a_id, a_bounds, b_bounds, nde_a.rank)\n-    } else if nde_a.rank < nde_b.rank {\n-        debug!(\"vars(): b has smaller rank\");\n-        // b has greater rank, so a should redirect to b.\n-        self.infcx().set(vb, a_id, redirect(b_id));\n-        set_var_to_merged_bounds(\n-            self, b_id, a_bounds, b_bounds, nde_b.rank)\n-    } else {\n-        debug!(\"vars(): a and b have equal rank\");\n-        assert nde_a.rank == nde_b.rank;\n-        // If equal, just redirect one to the other and increment\n-        // the other's rank.  We choose arbitrarily to redirect b\n-        // to a and increment a's rank.\n-        self.infcx().set(vb, b_id, redirect(a_id));\n-        set_var_to_merged_bounds(\n-            self, a_id, a_bounds, b_bounds, nde_a.rank + 1u\n-        )\n-    }\n-}\n-\n-/// make variable a subtype of T\n-fn var_sub_t<C: combine>(self: &C, a_id: ty::TyVid, b: ty::t) -> ures {\n-\n-    let vb = &self.infcx().ty_var_bindings;\n-    let nde_a = self.infcx().get(vb, a_id);\n-    let a_id = nde_a.root;\n-    let a_bounds = nde_a.possible_types;\n-\n-    debug!(\"var_sub_t(%s=%s <: %s)\",\n-           a_id.to_str(),\n-           a_bounds.to_str(self.infcx()),\n-           b.to_str(self.infcx()));\n-    let b_bounds = {lb: None, ub: Some(b)};\n-    set_var_to_merged_bounds(self, a_id, a_bounds, b_bounds, nde_a.rank)\n-}\n-\n-/// make T a subtype of variable\n-fn t_sub_var<C: combine>(self: &C, a: ty::t, b_id: ty::TyVid) -> ures {\n-\n-    let vb = &self.infcx().ty_var_bindings;\n-    let a_bounds = {lb: Some(a), ub: None};\n-    let nde_b = self.infcx().get(vb, b_id);\n-    let b_id = nde_b.root;\n-    let b_bounds = nde_b.possible_types;\n-\n-    debug!(\"t_sub_var(%s <: %s=%s)\",\n-           a.to_str(self.infcx()),\n-           b_id.to_str(),\n-           b_bounds.to_str(self.infcx()));\n-    set_var_to_merged_bounds(self, b_id, a_bounds, b_bounds, nde_b.rank)\n-}\n \n-fn bnds<C: combine>(\n-    self: &C, a: bound<ty::t>, b: bound<ty::t>) -> ures {\n-\n-    debug!(\"bnds(%s <: %s)\", a.to_str(self.infcx()), b.to_str(self.infcx()));\n-    do indent {\n-        match (a, b) {\n-          (None, None) |\n-          (Some(_), None) |\n-          (None, Some(_)) => {\n-            uok()\n-          }\n-          (Some(t_a), Some(t_b)) => {\n-            self.sub().tys(t_a, t_b).to_ures()\n-          }\n-        }\n-    }\n-}\n-\n-// ______________________________________________________________________\n-// Integral variables\n-\n-impl infer_ctxt {\n-    fn optimize_ranks<V:Copy vid Eq,T:Copy ToStr>(vb: &vals_and_bindings<V,T>,\n-                                                  nde_a: node<V,T>,\n-                                                  nde_b: node<V,T>,\n-                                                  a_id: V,\n-                                                  b_id: V,\n-                                                  intersection: T) {\n-        if nde_a.rank > nde_b.rank {\n-            debug!(\"int_vars(): a has smaller rank\");\n+    fn unify<V:Copy Vid ToStr, T:Copy InferStr, R>(\n+        vb: &ValsAndBindings<V, T>,\n+        node_a: &Node<V, T>,\n+        node_b: &Node<V, T>,\n+        op: &fn(new_root: V, new_rank: uint) -> R\n+    ) -> R {\n+        // Rank optimization: if you don't know what it is, check\n+        // out <http://en.wikipedia.org/wiki/Disjoint-set_data_structure>\n+\n+        debug!(\"unify(node_a(id=%?, rank=%?), \\\n+                node_b(id=%?, rank=%?))\",\n+               node_a.root, node_a.rank,\n+               node_b.root, node_b.rank);\n+\n+        if node_a.rank > node_b.rank {\n             // a has greater rank, so a should become b's parent,\n             // i.e., b should redirect to a.\n-            self.set(vb, a_id, root(intersection, nde_a.rank));\n-            self.set(vb, b_id, redirect(a_id));\n-        } else if nde_a.rank < nde_b.rank {\n-            debug!(\"int_vars(): b has smaller rank\");\n+            self.set(vb, node_b.root, Redirect(node_a.root));\n+            op(node_a.root, node_a.rank)\n+        } else if node_a.rank < node_b.rank {\n             // b has greater rank, so a should redirect to b.\n-            self.set(vb, b_id, root(intersection, nde_b.rank));\n-            self.set(vb, a_id, redirect(b_id));\n+            self.set(vb, node_a.root, Redirect(node_b.root));\n+            op(node_b.root, node_b.rank)\n         } else {\n-            debug!(\"int_vars(): a and b have equal rank\");\n-            assert nde_a.rank == nde_b.rank;\n-            // If equal, just redirect one to the other and increment\n-            // the other's rank.  We choose arbitrarily to redirect b\n-            // to a and increment a's rank.\n-            self.set(vb, a_id, root(intersection, nde_a.rank + 1u));\n-            self.set(vb, b_id, redirect(a_id));\n-        };\n-    }\n-\n-    fn int_vars(a_id: ty::IntVid, b_id: ty::IntVid) -> ures {\n-        let vb = &self.int_var_bindings;\n-\n-        let nde_a = self.get(vb, a_id);\n-        let nde_b = self.get(vb, b_id);\n-        let a_id = nde_a.root;\n-        let b_id = nde_b.root;\n-        let a_pt = nde_a.possible_types;\n-        let b_pt = nde_b.possible_types;\n-\n-        // If we're already dealing with the same two variables,\n-        // there's nothing to do.\n-        if a_id == b_id { return uok(); }\n-\n-        // Otherwise, take the intersection of the two sets of\n-        // possible types.\n-        let intersection = integral::intersection(a_pt, b_pt);\n-        if *intersection == INT_TY_SET_EMPTY {\n-            return Err(ty::terr_no_integral_type);\n+            // If equal, redirect one to the other and increment the\n+            // other's rank.\n+            assert node_a.rank == node_b.rank;\n+            self.set(vb, node_b.root, Redirect(node_a.root));\n+            op(node_a.root, node_a.rank + 1)\n         }\n-\n-        // Rank optimization\n-        self.optimize_ranks(vb, nde_a, nde_b, a_id, b_id, intersection);\n-\n-        uok()\n     }\n \n-    fn int_var_sub_t(a_id: ty::IntVid, b: ty::t) -> ures {\n-        if ty::type_is_char(b) {\n-            return Err(ty::terr_integer_as_char);\n-        }\n-\n-        assert ty::type_is_integral(b);\n-\n-        let vb = &self.int_var_bindings;\n-        let nde_a = self.get(vb, a_id);\n-        let a_id = nde_a.root;\n-        let a_pt = nde_a.possible_types;\n-\n-        let intersection =\n-            integral::intersection(a_pt,\n-                         convert_integral_ty_to_int_ty_set(self.tcx, b));\n-        if *intersection == INT_TY_SET_EMPTY {\n-            return Err(ty::terr_no_integral_type);\n-        }\n-        self.set(vb, a_id, root(intersection, nde_a.rank));\n-        uok()\n-    }\n-\n-    fn t_sub_int_var(a: ty::t, b_id: ty::IntVid) -> ures {\n-        assert ty::type_is_integral(a);\n-        let vb = &self.int_var_bindings;\n-\n-        let nde_b = self.get(vb, b_id);\n-        let b_id = nde_b.root;\n-        let b_pt = nde_b.possible_types;\n-\n-        let intersection =\n-            integral::intersection(b_pt,\n-                         convert_integral_ty_to_int_ty_set(self.tcx, a));\n-        if *intersection == INT_TY_SET_EMPTY {\n-            return Err(ty::terr_no_integral_type);\n-        }\n-        self.set(vb, b_id, root(intersection, nde_b.rank));\n-        uok()\n-    }\n-\n-\n }\n \n // ______________________________________________________________________\n-// Floating point variables\n-\n-impl infer_ctxt {\n-    fn float_vars(a_id: ty::FloatVid, b_id: ty::FloatVid) -> ures {\n-        let vb = &self.float_var_bindings;\n-\n-        let nde_a = self.get(vb, a_id);\n-        let nde_b = self.get(vb, b_id);\n-        let a_id = nde_a.root;\n-        let b_id = nde_b.root;\n-        let a_pt = nde_a.possible_types;\n-        let b_pt = nde_b.possible_types;\n+// Code to handle simple variables like ints, floats---anything that\n+// doesn't have a subtyping relationship we need to worry about.\n+\n+impl @InferCtxt {\n+    fn simple_vars<V:Copy Eq Vid ToStr, T:Copy Eq InferStr>(\n+        vb: &ValsAndBindings<V, Option<T>>,\n+        err: ty::type_err,\n+        a_id: V,\n+        b_id: V) -> ures\n+    {\n+        /*!\n+         *\n+         * Unifies two simple variables.  Because simple variables do\n+         * not have any subtyping relationships, if both variables\n+         * have already been associated with a value, then those two\n+         * values must be the same. */\n+\n+        let node_a = self.get(vb, a_id);\n+        let node_b = self.get(vb, b_id);\n+        let a_id = node_a.root;\n+        let b_id = node_b.root;\n \n-        // If we're already dealing with the same two variables,\n-        // there's nothing to do.\n         if a_id == b_id { return uok(); }\n \n-        // Otherwise, take the intersection of the two sets of\n-        // possible types.\n-        let intersection = floating::intersection(a_pt, b_pt);\n-        if *intersection == FLOAT_TY_SET_EMPTY {\n-            return Err(ty::terr_no_floating_point_type);\n-        }\n-\n-        // Rank optimization\n-        self.optimize_ranks(vb, nde_a, nde_b, a_id, b_id, intersection);\n+        let combined = match (&node_a.possible_types, &node_b.possible_types)\n+        {\n+            (&None, &None) => None,\n+            (&Some(ref v), &None) | (&None, &Some(ref v)) => Some(*v),\n+            (&Some(ref v1), &Some(ref v2)) => {\n+                if *v1 != *v2 { return Err(err); }\n+                Some(*v1)\n+            }\n+        };\n \n-        uok()\n+        self.unify(vb, &node_a, &node_b, |new_root, new_rank| {\n+            self.set(vb, new_root, Root(combined, new_rank));\n+        });\n+        return uok();\n     }\n \n-    fn float_var_sub_t(a_id: ty::FloatVid, b: ty::t) -> ures {\n-        assert ty::type_is_fp(b);\n-\n-        let vb = &self.float_var_bindings;\n-        let nde_a = self.get(vb, a_id);\n-        let a_id = nde_a.root;\n-        let a_pt = nde_a.possible_types;\n-\n-        let intersection =\n-            floating::intersection(\n-                a_pt,\n-                convert_floating_point_ty_to_float_ty_set(self.tcx, b));\n-        if *intersection == FLOAT_TY_SET_EMPTY {\n-            return Err(ty::terr_no_floating_point_type);\n+    fn simple_var_t<V:Copy Eq Vid ToStr, T:Copy Eq InferStr>(\n+        vb: &ValsAndBindings<V, Option<T>>,\n+        err: ty::type_err,\n+        a_id: V,\n+        b: T) -> ures\n+    {\n+        /*!\n+         *\n+         * Sets the value of the variable `a_id` to `b`.  Because\n+         * simple variables do not have any subtyping relationships,\n+         * if `a_id` already has a value, it must be the same as\n+         * `b`. */\n+\n+        let node_a = self.get(vb, a_id);\n+        let a_id = node_a.root;\n+\n+        if node_a.possible_types.is_none() {\n+            self.set(vb, a_id, Root(Some(b), node_a.rank));\n+            return uok();\n         }\n-        self.set(vb, a_id, root(intersection, nde_a.rank));\n-        uok()\n-    }\n-\n-    fn t_sub_float_var(a: ty::t, b_id: ty::FloatVid) -> ures {\n-        assert ty::type_is_fp(a);\n-        let vb = &self.float_var_bindings;\n \n-        let nde_b = self.get(vb, b_id);\n-        let b_id = nde_b.root;\n-        let b_pt = nde_b.possible_types;\n-\n-        let intersection =\n-            floating::intersection(\n-                b_pt,\n-                convert_floating_point_ty_to_float_ty_set(self.tcx, a));\n-        if *intersection == FLOAT_TY_SET_EMPTY {\n-            return Err(ty::terr_no_floating_point_type);\n+        if node_a.possible_types == Some(b) {\n+            return uok();\n         }\n-        self.set(vb, b_id, root(intersection, nde_b.rank));\n-        uok()\n+\n+        return Err(err);\n     }\n }\n "}, {"sha": "509fe96508b2c69e85937f758b3e35600ad7d1e7", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=2b92962aa29b0116015f99c1666ecf6288303c65", "patch": "@@ -271,7 +271,7 @@ fn no_params(t: ty::t) -> ty::ty_param_bounds_and_ty {\n \n fn require_same_types(\n     tcx: ty::ctxt,\n-    maybe_infcx: Option<infer::infer_ctxt>,\n+    maybe_infcx: Option<@infer::InferCtxt>,\n     t1_is_expected: bool,\n     span: span,\n     t1: ty::t,"}, {"sha": "528b997c8e6c8e9b6044f0b79b5ba78f2104dae2", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=2b92962aa29b0116015f99c1666ecf6288303c65", "patch": "@@ -69,8 +69,9 @@ fn loop_query(b: ast::blk, p: fn@(ast::expr_) -> bool) -> bool {\n           _ => visit::visit_expr(e, flag, v)\n         }\n     };\n-    let v = visit::mk_vt(@{visit_expr: visit_expr\n-                           ,.. *visit::default_visitor()});\n+    let v = visit::mk_vt(@visit::Visitor {\n+        visit_expr: visit_expr,\n+        .. *visit::default_visitor()});\n     visit::visit_block(b, rs, v);\n     return *rs;\n }\n@@ -84,8 +85,9 @@ fn block_query(b: ast::blk, p: fn@(@ast::expr) -> bool) -> bool {\n         *flag |= p(e);\n         visit::visit_expr(e, flag, v)\n     };\n-    let v = visit::mk_vt(@{visit_expr: visit_expr\n-                           ,.. *visit::default_visitor()});\n+    let v = visit::mk_vt(@visit::Visitor{\n+        visit_expr: visit_expr,\n+        .. *visit::default_visitor()});\n     visit::visit_block(b, rs, v);\n     return *rs;\n }"}, {"sha": "3cd38d67a297dbeda417ffbbabcb6b353a7ff5c3", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 16, "deletions": 10, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=2b92962aa29b0116015f99c1666ecf6288303c65", "patch": "@@ -25,14 +25,12 @@ use middle::ty::{ty_err, ty_estr, ty_evec, ty_float, ty_fn, ty_trait, ty_int};\n use middle::ty::{ty_nil, ty_opaque_box, ty_opaque_closure_ptr, ty_param};\n use middle::ty::{ty_ptr, ty_rec, ty_rptr, ty_self, ty_tup};\n use middle::ty::{ty_type, ty_uniq, ty_uint, ty_infer};\n-use middle::ty::{ty_unboxed_vec, vid};\n+use middle::ty::{ty_unboxed_vec};\n use metadata::encoder;\n use syntax::codemap;\n use syntax::codemap::span;\n use syntax::print::pprust;\n-use syntax::print::pprust::{path_to_str, proto_to_str,\n-                            mode_to_str, purity_to_str,\n-                            onceness_to_str};\n+use syntax::print::pprust::{path_to_str, proto_to_str, mode_to_str};\n use syntax::{ast, ast_util};\n use syntax::ast_map;\n \n@@ -248,9 +246,11 @@ fn vstore_ty_to_str(cx: ctxt, ty: ~str, vs: ty::vstore) -> ~str {\n     }\n }\n \n-fn proto_ty_to_str(_cx: ctxt, proto: ast::Proto) -> &static/str {\n+fn proto_ty_to_str(_cx: ctxt, proto: ast::Proto,\n+                   followed_by_word: bool) -> &static/str {\n     match proto {\n-        ast::ProtoBare => \"\",\n+        ast::ProtoBare if followed_by_word => \"extern \",\n+        ast::ProtoBare => \"extern\",\n         ast::ProtoBox => \"@\",\n         ast::ProtoBorrowed => \"&\",\n         ast::ProtoUniq => \"~\",\n@@ -265,13 +265,19 @@ fn expr_repr(cx: ctxt, expr: @ast::expr) -> ~str {\n \n fn tys_to_str(cx: ctxt, ts: &[t]) -> ~str {\n     let tstrs = ts.map(|t| ty_to_str(cx, *t));\n-    fmt!(\"[%s]\", str::connect(tstrs, \", \"))\n+    fmt!(\"(%s)\", str::connect(tstrs, \", \"))\n }\n \n fn bound_to_str(cx: ctxt, b: param_bound) -> ~str {\n     ty::param_bound_to_str(cx, &b)\n }\n \n+fn fn_sig_to_str(cx: ctxt, typ: &ty::FnSig) -> ~str {\n+    fmt!(\"fn%s -> %s\",\n+         tys_to_str(cx, typ.inputs.map(|a| a.ty)),\n+         ty_to_str(cx, typ.output))\n+}\n+\n fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n     fn fn_input_to_str(cx: ctxt, input: {mode: ast::mode, ty: t}) ->\n        ~str {\n@@ -301,15 +307,15 @@ fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n \n         s = match purity {\n             ast::impure_fn => ~\"\",\n-            _ => purity_to_str(purity) + ~\" \"\n+            _ => purity.to_str() + ~\" \"\n         };\n \n         s += match onceness {\n             ast::Many => ~\"\",\n-            ast::Once => onceness_to_str(onceness) + ~\" \"\n+            ast::Once => onceness.to_str() + ~\" \"\n         };\n \n-        s += proto_ty_to_str(cx, proto);\n+        s += proto_ty_to_str(cx, proto, true);\n \n         match (proto, region) {\n             (ast::ProtoBox, ty::re_static) |"}, {"sha": "165b5e257b2287665d4c15dd8511f00c56df301b", "filename": "src/librustdoc/attr_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibrustdoc%2Fattr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibrustdoc%2Fattr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fattr_pass.rs?ref=2b92962aa29b0116015f99c1666ecf6288303c65", "patch": "@@ -35,7 +35,7 @@ use std::map::HashMap;\n use std::par;\n \n pub fn mk_pass() -> Pass {\n-    {\n+    Pass {\n         name: ~\"attr\",\n         f: run\n     }"}, {"sha": "4074d9aa691167e3c3153c666ba7b4673556dedf", "filename": "src/librustdoc/desc_to_brief_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibrustdoc%2Fdesc_to_brief_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibrustdoc%2Fdesc_to_brief_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdesc_to_brief_pass.rs?ref=2b92962aa29b0116015f99c1666ecf6288303c65", "patch": "@@ -29,7 +29,7 @@ use core::vec;\n use std::par;\n \n pub fn mk_pass() -> Pass {\n-    {\n+    Pass {\n         name: ~\"desc_to_brief\",\n         f: run\n     }"}, {"sha": "1f4e1be62fc3be931c3dd7c9ad8cd5773ad46cf5", "filename": "src/librustdoc/markdown_index_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibrustdoc%2Fmarkdown_index_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibrustdoc%2Fmarkdown_index_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown_index_pass.rs?ref=2b92962aa29b0116015f99c1666ecf6288303c65", "patch": "@@ -26,7 +26,7 @@ use core::str;\n use std::par;\n \n pub fn mk_pass(+config: config::Config) -> Pass {\n-    {\n+    Pass {\n         name: ~\"markdown_index\",\n         f: fn~(srv: astsrv::Srv, +doc: doc::Doc) -> doc::Doc {\n             run(srv, doc, config)"}, {"sha": "1ec30bc74ab66f59df569ccd663ca08dbf24a851", "filename": "src/librustdoc/markdown_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibrustdoc%2Fmarkdown_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibrustdoc%2Fmarkdown_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown_pass.rs?ref=2b92962aa29b0116015f99c1666ecf6288303c65", "patch": "@@ -47,7 +47,7 @@ pub fn mk_pass(+writer_factory: WriterFactory) -> Pass {\n         run(srv, doc, copy writer_factory)\n     };\n \n-    {\n+    Pass {\n         name: ~\"markdown\",\n         f: move f\n     }"}, {"sha": "2629d45635e0ba65a9674d0f29052b5403a50af1", "filename": "src/librustdoc/page_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibrustdoc%2Fpage_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibrustdoc%2Fpage_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpage_pass.rs?ref=2b92962aa29b0116015f99c1666ecf6288303c65", "patch": "@@ -34,7 +34,7 @@ use core::vec;\n use syntax::ast;\n \n pub fn mk_pass(output_style: config::OutputStyle) -> Pass {\n-    {\n+    Pass {\n         name: ~\"page\",\n         f: fn~(srv: astsrv::Srv, +doc: doc::Doc) -> doc::Doc {\n             run(srv, doc, output_style)"}, {"sha": "1e5d5542963af6ede30b6b19970ef138b531cc30", "filename": "src/librustdoc/pass.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibrustdoc%2Fpass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibrustdoc%2Fpass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpass.rs?ref=2b92962aa29b0116015f99c1666ecf6288303c65", "patch": "@@ -18,10 +18,10 @@ use time;\n use core::vec;\n \n /// A single operation on the document model\n-pub type Pass = {\n+pub struct Pass {\n     name: ~str,\n     f: fn~(srv: astsrv::Srv, +doc: doc::Doc) -> doc::Doc\n-};\n+}\n \n pub fn run_passes(\n     srv: astsrv::Srv,\n@@ -82,11 +82,11 @@ fn test_run_passes() {\n     let source = ~\"\";\n     do astsrv::from_str(source) |srv| {\n         let passes = ~[\n-            {\n+            Pass {\n                 name: ~\"\",\n                 f: pass1\n             },\n-            {\n+            Pass {\n                 name: ~\"\",\n                 f: pass2\n             }"}, {"sha": "48ed1878771261c18010a704b7ec0f8d5b81a5a8", "filename": "src/librustdoc/path_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibrustdoc%2Fpath_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibrustdoc%2Fpath_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpath_pass.rs?ref=2b92962aa29b0116015f99c1666ecf6288303c65", "patch": "@@ -23,7 +23,7 @@ use pass::Pass;\n use syntax::ast;\n \n pub fn mk_pass() -> Pass {\n-    {\n+    Pass {\n         name: ~\"path\",\n         f: run\n     }"}, {"sha": "3a924e3bddf699c5b0294219ef337972a04c92ff", "filename": "src/librustdoc/prune_hidden_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibrustdoc%2Fprune_hidden_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibrustdoc%2Fprune_hidden_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fprune_hidden_pass.rs?ref=2b92962aa29b0116015f99c1666ecf6288303c65", "patch": "@@ -22,7 +22,7 @@ use core::vec;\n use std::map::HashMap;\n \n pub fn mk_pass() -> Pass {\n-    {\n+    Pass {\n         name: ~\"prune_hidden\",\n         f: run\n     }"}, {"sha": "615bd07ca85b85a23723ddfdd9697c773a0d89de", "filename": "src/librustdoc/prune_private_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibrustdoc%2Fprune_private_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibrustdoc%2Fprune_private_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fprune_private_pass.rs?ref=2b92962aa29b0116015f99c1666ecf6288303c65", "patch": "@@ -28,7 +28,7 @@ export mk_pass;\n export run;\n \n fn mk_pass() -> Pass {\n-    {\n+    Pass {\n         name: ~\"prune_private\",\n         f: run\n     }"}, {"sha": "eeadd82371fd9d7a4f2079d1fb6e417fedf8c163", "filename": "src/librustdoc/sectionalize_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibrustdoc%2Fsectionalize_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibrustdoc%2Fsectionalize_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fsectionalize_pass.rs?ref=2b92962aa29b0116015f99c1666ecf6288303c65", "patch": "@@ -26,7 +26,7 @@ use core::vec;\n use std::par;\n \n pub fn mk_pass() -> Pass {\n-    {\n+    Pass {\n         name: ~\"sectionalize\",\n         f: run\n     }"}, {"sha": "b3ecb8173fee795a7084cacfb6a17f93678e1191", "filename": "src/librustdoc/sort_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibrustdoc%2Fsort_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibrustdoc%2Fsort_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fsort_pass.rs?ref=2b92962aa29b0116015f99c1666ecf6288303c65", "patch": "@@ -28,7 +28,7 @@ pub type ItemLtEqOp = pure fn~(v1: &doc::ItemTag, v2:  &doc::ItemTag) -> bool;\n type ItemLtEq = NominalOp<ItemLtEqOp>;\n \n pub fn mk_pass(name: ~str, +lteq: ItemLtEqOp) -> Pass {\n-    {\n+    Pass {\n         name: name,\n         f: fn~(move lteq, srv: astsrv::Srv, +doc: doc::Doc) -> doc::Doc {\n             run(srv, doc, NominalOp { op: copy lteq })"}, {"sha": "5627bfead9f451dc93c228528f720ca485bace91", "filename": "src/librustdoc/text_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibrustdoc%2Ftext_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibrustdoc%2Ftext_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftext_pass.rs?ref=2b92962aa29b0116015f99c1666ecf6288303c65", "patch": "@@ -23,7 +23,7 @@ use util::NominalOp;\n use std::par;\n \n pub fn mk_pass(name: ~str, +op: fn~(~str) -> ~str) -> Pass {\n-    {\n+    Pass {\n         name: name,\n         f: fn~(move op, srv: astsrv::Srv, +doc: doc::Doc) -> doc::Doc {\n             run(srv, doc, copy op)"}, {"sha": "ae1b7577ad83bc64f8c28c839611ebfce3087679", "filename": "src/librustdoc/tystr_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibrustdoc%2Ftystr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibrustdoc%2Ftystr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftystr_pass.rs?ref=2b92962aa29b0116015f99c1666ecf6288303c65", "patch": "@@ -29,7 +29,7 @@ use syntax::print::pprust;\n use syntax::ast_map;\n \n pub fn mk_pass() -> Pass {\n-    {\n+    Pass {\n         name: ~\"tystr\",\n         f: run\n     }"}, {"sha": "12064e56bedbdd90173aba4f7eb58abf5b3756d7", "filename": "src/libstd/test.rs", "status": "modified", "additions": 22, "deletions": 19, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibstd%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibstd%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftest.rs?ref=2b92962aa29b0116015f99c1666ecf6288303c65", "patch": "@@ -56,12 +56,12 @@ pub type TestFn = fn~();\n \n // The definition of a single test. A test runner will run a list of\n // these.\n-pub type TestDesc = {\n+pub struct TestDesc {\n     name: TestName,\n     testfn: TestFn,\n     ignore: bool,\n     should_fail: bool\n-};\n+}\n \n // The default console test runner. It accepts the command line\n // arguments and a vector of test_descs (generated at compile time).\n@@ -242,14 +242,14 @@ fn print_failures(st: ConsoleTestState) {\n #[test]\n fn should_sort_failures_before_printing_them() {\n     let s = do io::with_str_writer |wr| {\n-        let test_a = {\n+        let test_a = TestDesc {\n             name: ~\"a\",\n             testfn: fn~() { },\n             ignore: false,\n             should_fail: false\n         };\n \n-        let test_b = {\n+        let test_b = TestDesc {\n             name: ~\"b\",\n             testfn: fn~() { },\n             ignore: false,\n@@ -372,10 +372,11 @@ pub fn filter_tests(opts: &TestOpts,\n     } else {\n         fn filter(test: &TestDesc) -> Option<TestDesc> {\n             if test.ignore {\n-                return option::Some({name: test.name,\n-                                  testfn: copy test.testfn,\n-                                  ignore: false,\n-                                  should_fail: test.should_fail});\n+                return option::Some(TestDesc {\n+                    name: test.name,\n+                    testfn: copy test.testfn,\n+                    ignore: false,\n+                    should_fail: test.should_fail});\n             } else { return option::None; }\n         };\n \n@@ -427,7 +428,8 @@ fn calc_result(test: &TestDesc, task_succeeded: bool) -> TestResult {\n mod tests {\n     #[legacy_exports];\n \n-    use test::{TrFailed, TrIgnored, TrOk, filter_tests, parse_opts, run_test};\n+    use test::{TrFailed, TrIgnored, TrOk, filter_tests, parse_opts, TestDesc};\n+    use test::{run_test};\n \n     use core::either;\n     use core::oldcomm;\n@@ -437,7 +439,7 @@ mod tests {\n     #[test]\n     fn do_not_run_ignored_tests() {\n         fn f() { fail; }\n-        let desc = {\n+        let desc = TestDesc {\n             name: ~\"whatever\",\n             testfn: f,\n             ignore: true,\n@@ -453,7 +455,7 @@ mod tests {\n     #[test]\n     fn ignored_tests_result_in_ignored() {\n         fn f() { }\n-        let desc = {\n+        let desc = TestDesc {\n             name: ~\"whatever\",\n             testfn: f,\n             ignore: true,\n@@ -470,7 +472,7 @@ mod tests {\n     #[ignore(cfg(windows))]\n     fn test_should_fail() {\n         fn f() { fail; }\n-        let desc = {\n+        let desc = TestDesc {\n             name: ~\"whatever\",\n             testfn: f,\n             ignore: false,\n@@ -486,7 +488,7 @@ mod tests {\n     #[test]\n     fn test_should_fail_but_succeeds() {\n         fn f() { }\n-        let desc = {\n+        let desc = TestDesc {\n             name: ~\"whatever\",\n             testfn: f,\n             ignore: false,\n@@ -527,10 +529,10 @@ mod tests {\n         let opts = {filter: option::None, run_ignored: true,\n             logfile: option::None};\n         let tests =\n-            ~[{name: ~\"1\", testfn: fn~() { },\n-               ignore: true, should_fail: false},\n-             {name: ~\"2\", testfn: fn~() { },\n-              ignore: false, should_fail: false}];\n+            ~[TestDesc {name: ~\"1\", testfn: fn~() { },\n+                        ignore: true, should_fail: false},\n+              TestDesc {name: ~\"2\", testfn: fn~() { },\n+                        ignore: false, should_fail: false}];\n         let filtered = filter_tests(&opts, tests);\n \n         assert (vec::len(filtered) == 1u);\n@@ -555,8 +557,9 @@ mod tests {\n             let testfn = fn~() { };\n             let mut tests = ~[];\n             for vec::each(names) |name| {\n-                let test = {name: *name, testfn: copy testfn, ignore: false,\n-                            should_fail: false};\n+                let test = TestDesc {\n+                    name: *name, testfn: copy testfn, ignore: false,\n+                    should_fail: false};\n                 tests.push(move test);\n             }\n             move tests"}, {"sha": "072a7e94fe9ba78c362d90d076667eb0e2c47453", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 24, "deletions": 14, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=2b92962aa29b0116015f99c1666ecf6288303c65", "patch": "@@ -19,6 +19,7 @@ use core::option::{None, Option, Some};\n use core::ptr;\n use core::task;\n use core::to_bytes;\n+use core::to_str::ToStr;\n use std::serialize::{Encodable, Decodable, Encoder, Decoder};\n \n #[auto_encode]\n@@ -415,20 +416,14 @@ impl mutability : cmp::Eq {\n \n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n pub enum Proto {\n     ProtoBare,     // bare functions (deprecated)\n     ProtoUniq,     // ~fn\n     ProtoBox,      // @fn\n     ProtoBorrowed, // &fn\n }\n \n-impl Proto : cmp::Eq {\n-    pure fn eq(&self, other: &Proto) -> bool {\n-        ((*self) as uint) == ((*other) as uint)\n-    }\n-    pure fn ne(&self, other: &Proto) -> bool { !(*self).eq(other) }\n-}\n-\n impl Proto : to_bytes::IterBytes {\n     pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         (*self as uint).iter_bytes(lsb0, f);\n@@ -1068,20 +1063,24 @@ enum region_ {\n \n #[auto_encode]\n #[auto_decode]\n+#[deriving_eq]\n enum Onceness {\n     Once,\n     Many\n }\n \n-impl Onceness : cmp::Eq {\n-    pure fn eq(&self, other: &Onceness) -> bool {\n-        match ((*self), *other) {\n-            (Once, Once) | (Many, Many) => true,\n-            _ => false\n+impl Onceness : ToStr {\n+    pure fn to_str() -> ~str {\n+        match self {\n+            ast::Once => ~\"once\",\n+            ast::Many => ~\"many\"\n         }\n     }\n-    pure fn ne(&self, other: &Onceness) -> bool {\n-        !(*self).eq(other)\n+}\n+\n+impl Onceness : to_bytes::IterBytes {\n+    pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+        (*self as uint).iter_bytes(lsb0, f);\n     }\n }\n \n@@ -1156,6 +1155,17 @@ pub enum purity {\n     extern_fn, // declared with \"extern fn\"\n }\n \n+impl purity : ToStr {\n+    pure fn to_str() -> ~str {\n+        match self {\n+            impure_fn => ~\"impure\",\n+            unsafe_fn => ~\"unsafe\",\n+            pure_fn => ~\"pure\",\n+            extern_fn => ~\"extern\"\n+        }\n+    }\n+}\n+\n impl purity : to_bytes::IterBytes {\n     pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         (*self as u8).iter_bytes(lsb0, f)"}, {"sha": "9ddf1b24040c80510154d25b5e86b38022f0ac6c", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=2b92962aa29b0116015f99c1666ecf6288303c65", "patch": "@@ -110,7 +110,7 @@ fn extend(cx: ctx, +elt: ident) -> @path {\n }\n \n fn mk_ast_map_visitor() -> vt {\n-    return visit::mk_vt(@{\n+    return visit::mk_vt(@visit::Visitor {\n         visit_item: map_item,\n         visit_expr: map_expr,\n         visit_stmt: map_stmt,"}, {"sha": "1a34fe29a71440aefac2b409351d3b6b40c7c2dc", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=2b92962aa29b0116015f99c1666ecf6288303c65", "patch": "@@ -440,10 +440,8 @@ fn empty(range: id_range) -> bool {\n }\n \n fn id_visitor(vfn: fn@(node_id)) -> visit::vt<()> {\n-    visit::mk_simple_visitor(@{\n-        visit_mod: fn@(_m: _mod, _sp: span, id: node_id) {\n-            vfn(id)\n-        },\n+    visit::mk_simple_visitor(@visit::SimpleVisitor {\n+        visit_mod: |_m, _sp, id| vfn(id),\n \n         visit_view_item: fn@(vi: @view_item) {\n             match vi.node {"}, {"sha": "e3fb7a289c186684a43d714018ba5d782312b08b", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=2b92962aa29b0116015f99c1666ecf6288303c65", "patch": "@@ -322,13 +322,13 @@ fn expand_crate(parse_sess: parse::parse_sess,\n     let exts = syntax_expander_table();\n     let afp = default_ast_fold();\n     let cx: ext_ctxt = mk_ctxt(parse_sess, cfg);\n-    let f_pre =\n-        @{fold_expr: |a,b,c| expand_expr(exts, cx, a, b, c, afp.fold_expr),\n-          fold_mod: |a,b| expand_mod_items(exts, cx, a, b, afp.fold_mod),\n-          fold_item: |a,b| expand_item(exts, cx, a, b, afp.fold_item),\n-          fold_stmt: |a,b,c| expand_stmt(exts, cx, a, b, c, afp.fold_stmt),\n-          new_span: |a| new_span(cx, a),\n-          .. *afp};\n+    let f_pre = @AstFoldFns {\n+        fold_expr: |a,b,c| expand_expr(exts, cx, a, b, c, afp.fold_expr),\n+        fold_mod: |a,b| expand_mod_items(exts, cx, a, b, afp.fold_mod),\n+        fold_item: |a,b| expand_item(exts, cx, a, b, afp.fold_item),\n+        fold_stmt: |a,b,c| expand_stmt(exts, cx, a, b, c, afp.fold_stmt),\n+        new_span: |a| new_span(cx, a),\n+        .. *afp};\n     let f = make_fold(f_pre);\n     let cm = parse_expr_from_source_str(~\"<core-macros>\",\n                                         @core_macros(),"}, {"sha": "272ad3456e5778c726870af11195d686807ebe6f", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=2b92962aa29b0116015f99c1666ecf6288303c65", "patch": "@@ -17,7 +17,7 @@ use codemap::span;\n use core::option;\n use core::vec;\n \n-export ast_fold_precursor;\n+export ast_fold_fns;\n export ast_fold;\n export default_ast_fold;\n export make_fold;\n@@ -34,6 +34,7 @@ export fold_ty_param;\n export fold_ty_params;\n export fold_fn_decl;\n export extensions;\n+export AstFoldFns;\n \n trait ast_fold {\n     fn fold_crate(crate) -> crate;\n@@ -63,7 +64,7 @@ trait ast_fold {\n \n // We may eventually want to be able to fold over type parameters, too\n \n-type ast_fold_precursor = @{\n+struct AstFoldFns {\n     //unlike the others, item_ is non-trivial\n     fold_crate: fn@(crate_, span, ast_fold) -> (crate_, span),\n     fold_view_item: fn@(view_item_, ast_fold) -> view_item_,\n@@ -87,7 +88,10 @@ type ast_fold_precursor = @{\n     fold_local: fn@(local_, span, ast_fold) -> (local_, span),\n     map_exprs: fn@(fn@(&&v: @expr) -> @expr, ~[@expr]) -> ~[@expr],\n     new_id: fn@(node_id) -> node_id,\n-    new_span: fn@(span) -> span};\n+    new_span: fn@(span) -> span\n+}\n+\n+type ast_fold_fns = @AstFoldFns;\n \n /* some little folds that probably aren't useful to have in ast_fold itself*/\n \n@@ -631,8 +635,8 @@ fn noop_id(i: node_id) -> node_id { return i; }\n \n fn noop_span(sp: span) -> span { return sp; }\n \n-fn default_ast_fold() -> ast_fold_precursor {\n-    return @{fold_crate: wrap(noop_fold_crate),\n+fn default_ast_fold() -> ast_fold_fns {\n+    return @AstFoldFns {fold_crate: wrap(noop_fold_crate),\n           fold_view_item: noop_fold_view_item,\n           fold_foreign_item: noop_fold_foreign_item,\n           fold_item: noop_fold_item,\n@@ -657,7 +661,7 @@ fn default_ast_fold() -> ast_fold_precursor {\n           new_span: noop_span};\n }\n \n-impl ast_fold_precursor: ast_fold {\n+impl ast_fold_fns: ast_fold {\n     /* naturally, a macro to write these would be nice */\n     fn fold_crate(c: crate) -> crate {\n         let (n, s) = (self.fold_crate)(c.node, c.span, self as ast_fold);\n@@ -763,7 +767,7 @@ impl ast_fold {\n     }\n }\n \n-fn make_fold(afp: ast_fold_precursor) -> ast_fold {\n+fn make_fold(afp: ast_fold_fns) -> ast_fold {\n     afp as ast_fold\n }\n "}, {"sha": "272c35152bbf26984f1ede48cfb34dd553d1839a", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=2b92962aa29b0116015f99c1666ecf6288303c65", "patch": "@@ -44,11 +44,14 @@ enum ann_node {\n     node_expr(ps, @ast::expr),\n     node_pat(ps, @ast::pat),\n }\n-type pp_ann = {pre: fn@(ann_node), post: fn@(ann_node)};\n+struct pp_ann {\n+    pre: fn@(ann_node),\n+    post: fn@(ann_node)\n+}\n \n fn no_ann() -> pp_ann {\n     fn ignore(_node: ann_node) { }\n-    return {pre: ignore, post: ignore};\n+    return pp_ann {pre: ignore, post: ignore};\n }\n \n type ps ="}, {"sha": "0da6396253eb71cb52bc98cf6af3b171452baa49", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 116, "deletions": 108, "changes": 224, "blob_url": "https://github.com/rust-lang/rust/blob/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=2b92962aa29b0116015f99c1666ecf6288303c65", "patch": "@@ -59,51 +59,56 @@ fn tps_of_fn(fk: fn_kind) -> ~[ty_param] {\n     }\n }\n \n-type visitor<E> =\n-    @{visit_mod: fn@(_mod, span, node_id, E, vt<E>),\n-      visit_view_item: fn@(@view_item, E, vt<E>),\n-      visit_foreign_item: fn@(@foreign_item, E, vt<E>),\n-      visit_item: fn@(@item, E, vt<E>),\n-      visit_local: fn@(@local, E, vt<E>),\n-      visit_block: fn@(ast::blk, E, vt<E>),\n-      visit_stmt: fn@(@stmt, E, vt<E>),\n-      visit_arm: fn@(arm, E, vt<E>),\n-      visit_pat: fn@(@pat, E, vt<E>),\n-      visit_decl: fn@(@decl, E, vt<E>),\n-      visit_expr: fn@(@expr, E, vt<E>),\n-      visit_expr_post: fn@(@expr, E, vt<E>),\n-      visit_ty: fn@(@Ty, E, vt<E>),\n-      visit_ty_params: fn@(~[ty_param], E, vt<E>),\n-      visit_fn: fn@(fn_kind, fn_decl, blk, span, node_id, E, vt<E>),\n-      visit_ty_method: fn@(ty_method, E, vt<E>),\n-      visit_trait_method: fn@(trait_method, E, vt<E>),\n-      visit_struct_def: fn@(@struct_def, ident, ~[ty_param], node_id, E,\n-                            vt<E>),\n-      visit_struct_field: fn@(@struct_field, E, vt<E>),\n-      visit_struct_method: fn@(@method, E, vt<E>)};\n+struct Visitor<E> {\n+    visit_mod: fn@(_mod, span, node_id, E, vt<E>),\n+    visit_view_item: fn@(@view_item, E, vt<E>),\n+    visit_foreign_item: fn@(@foreign_item, E, vt<E>),\n+    visit_item: fn@(@item, E, vt<E>),\n+    visit_local: fn@(@local, E, vt<E>),\n+    visit_block: fn@(ast::blk, E, vt<E>),\n+    visit_stmt: fn@(@stmt, E, vt<E>),\n+    visit_arm: fn@(arm, E, vt<E>),\n+    visit_pat: fn@(@pat, E, vt<E>),\n+    visit_decl: fn@(@decl, E, vt<E>),\n+    visit_expr: fn@(@expr, E, vt<E>),\n+    visit_expr_post: fn@(@expr, E, vt<E>),\n+    visit_ty: fn@(@Ty, E, vt<E>),\n+    visit_ty_params: fn@(~[ty_param], E, vt<E>),\n+    visit_fn: fn@(fn_kind, fn_decl, blk, span, node_id, E, vt<E>),\n+    visit_ty_method: fn@(ty_method, E, vt<E>),\n+    visit_trait_method: fn@(trait_method, E, vt<E>),\n+    visit_struct_def: fn@(@struct_def, ident, ~[ty_param], node_id, E,\n+                          vt<E>),\n+    visit_struct_field: fn@(@struct_field, E, vt<E>),\n+    visit_struct_method: fn@(@method, E, vt<E>)\n+}\n+\n+type visitor<E> = @Visitor<E>;\n \n fn default_visitor<E>() -> visitor<E> {\n-    return @{visit_mod: |a,b,c,d,e|visit_mod::<E>(a, b, c, d, e),\n-          visit_view_item: |a,b,c|visit_view_item::<E>(a, b, c),\n-          visit_foreign_item: |a,b,c|visit_foreign_item::<E>(a, b, c),\n-          visit_item: |a,b,c|visit_item::<E>(a, b, c),\n-          visit_local: |a,b,c|visit_local::<E>(a, b, c),\n-          visit_block: |a,b,c|visit_block::<E>(a, b, c),\n-          visit_stmt: |a,b,c|visit_stmt::<E>(a, b, c),\n-          visit_arm: |a,b,c|visit_arm::<E>(a, b, c),\n-          visit_pat: |a,b,c|visit_pat::<E>(a, b, c),\n-          visit_decl: |a,b,c|visit_decl::<E>(a, b, c),\n-          visit_expr: |a,b,c|visit_expr::<E>(a, b, c),\n-          visit_expr_post: |_a,_b,_c| (),\n-          visit_ty: |a,b,c|skip_ty::<E>(a, b, c),\n-          visit_ty_params: |a,b,c|visit_ty_params::<E>(a, b, c),\n-          visit_fn: |a,b,c,d,e,f,g|visit_fn::<E>(a, b, c, d, e, f, g),\n-          visit_ty_method: |a,b,c|visit_ty_method::<E>(a, b, c),\n-          visit_trait_method: |a,b,c|visit_trait_method::<E>(a, b, c),\n-          visit_struct_def: |a,b,c,d,e,f|visit_struct_def::<E>(a, b, c,\n-                                                               d, e, f),\n-          visit_struct_field: |a,b,c|visit_struct_field::<E>(a, b, c),\n-          visit_struct_method: |a,b,c|visit_struct_method::<E>(a, b, c)};\n+    return @Visitor {\n+        visit_mod: |a,b,c,d,e|visit_mod::<E>(a, b, c, d, e),\n+        visit_view_item: |a,b,c|visit_view_item::<E>(a, b, c),\n+        visit_foreign_item: |a,b,c|visit_foreign_item::<E>(a, b, c),\n+        visit_item: |a,b,c|visit_item::<E>(a, b, c),\n+        visit_local: |a,b,c|visit_local::<E>(a, b, c),\n+        visit_block: |a,b,c|visit_block::<E>(a, b, c),\n+        visit_stmt: |a,b,c|visit_stmt::<E>(a, b, c),\n+        visit_arm: |a,b,c|visit_arm::<E>(a, b, c),\n+        visit_pat: |a,b,c|visit_pat::<E>(a, b, c),\n+        visit_decl: |a,b,c|visit_decl::<E>(a, b, c),\n+        visit_expr: |a,b,c|visit_expr::<E>(a, b, c),\n+        visit_expr_post: |_a,_b,_c| (),\n+        visit_ty: |a,b,c|skip_ty::<E>(a, b, c),\n+        visit_ty_params: |a,b,c|visit_ty_params::<E>(a, b, c),\n+        visit_fn: |a,b,c,d,e,f,g|visit_fn::<E>(a, b, c, d, e, f, g),\n+        visit_ty_method: |a,b,c|visit_ty_method::<E>(a, b, c),\n+        visit_trait_method: |a,b,c|visit_trait_method::<E>(a, b, c),\n+        visit_struct_def: |a,b,c,d,e,f|visit_struct_def::<E>(a, b, c,\n+                                                             d, e, f),\n+        visit_struct_field: |a,b,c|visit_struct_field::<E>(a, b, c),\n+        visit_struct_method: |a,b,c|visit_struct_method::<E>(a, b, c)\n+    };\n }\n \n fn visit_crate<E>(c: crate, e: E, v: vt<E>) {\n@@ -499,43 +504,46 @@ fn visit_arm<E>(a: arm, e: E, v: vt<E>) {\n // Simpler, non-context passing interface. Always walks the whole tree, simply\n // calls the given functions on the nodes.\n \n-type simple_visitor =\n-    @{visit_mod: fn@(_mod, span, node_id),\n-      visit_view_item: fn@(@view_item),\n-      visit_foreign_item: fn@(@foreign_item),\n-      visit_item: fn@(@item),\n-      visit_local: fn@(@local),\n-      visit_block: fn@(ast::blk),\n-      visit_stmt: fn@(@stmt),\n-      visit_arm: fn@(arm),\n-      visit_pat: fn@(@pat),\n-      visit_decl: fn@(@decl),\n-      visit_expr: fn@(@expr),\n-      visit_expr_post: fn@(@expr),\n-      visit_ty: fn@(@Ty),\n-      visit_ty_params: fn@(~[ty_param]),\n-      visit_fn: fn@(fn_kind, fn_decl, blk, span, node_id),\n-      visit_ty_method: fn@(ty_method),\n-      visit_trait_method: fn@(trait_method),\n-      visit_struct_def: fn@(@struct_def, ident, ~[ty_param], node_id),\n-      visit_struct_field: fn@(@struct_field),\n-      visit_struct_method: fn@(@method)};\n+struct SimpleVisitor {\n+    visit_mod: fn@(_mod, span, node_id),\n+    visit_view_item: fn@(@view_item),\n+    visit_foreign_item: fn@(@foreign_item),\n+    visit_item: fn@(@item),\n+    visit_local: fn@(@local),\n+    visit_block: fn@(ast::blk),\n+    visit_stmt: fn@(@stmt),\n+    visit_arm: fn@(arm),\n+    visit_pat: fn@(@pat),\n+    visit_decl: fn@(@decl),\n+    visit_expr: fn@(@expr),\n+    visit_expr_post: fn@(@expr),\n+    visit_ty: fn@(@Ty),\n+    visit_ty_params: fn@(~[ty_param]),\n+    visit_fn: fn@(fn_kind, fn_decl, blk, span, node_id),\n+    visit_ty_method: fn@(ty_method),\n+    visit_trait_method: fn@(trait_method),\n+    visit_struct_def: fn@(@struct_def, ident, ~[ty_param], node_id),\n+    visit_struct_field: fn@(@struct_field),\n+    visit_struct_method: fn@(@method)\n+}\n+\n+type simple_visitor = @SimpleVisitor;\n \n fn simple_ignore_ty(_t: @Ty) {}\n \n-fn default_simple_visitor() -> simple_visitor {\n-    return @{visit_mod: fn@(_m: _mod, _sp: span, _id: node_id) { },\n-          visit_view_item: fn@(_vi: @view_item) { },\n-          visit_foreign_item: fn@(_ni: @foreign_item) { },\n-          visit_item: fn@(_i: @item) { },\n-          visit_local: fn@(_l: @local) { },\n-          visit_block: fn@(_b: ast::blk) { },\n-          visit_stmt: fn@(_s: @stmt) { },\n-          visit_arm: fn@(_a: arm) { },\n-          visit_pat: fn@(_p: @pat) { },\n-          visit_decl: fn@(_d: @decl) { },\n-          visit_expr: fn@(_e: @expr) { },\n-          visit_expr_post: fn@(_e: @expr) { },\n+fn default_simple_visitor() -> @SimpleVisitor {\n+    return @SimpleVisitor {visit_mod: |_m: _mod, _sp: span, _id: node_id| { },\n+          visit_view_item: |_vi: @view_item| { },\n+          visit_foreign_item: |_ni: @foreign_item| { },\n+          visit_item: |_i: @item| { },\n+          visit_local: |_l: @local| { },\n+          visit_block: |_b: ast::blk| { },\n+          visit_stmt: |_s: @stmt| { },\n+          visit_arm: |_a: arm| { },\n+          visit_pat: |_p: @pat| { },\n+          visit_decl: |_d: @decl| { },\n+          visit_expr: |_e: @expr| { },\n+          visit_expr_post: |_e: @expr| { },\n           visit_ty: simple_ignore_ty,\n           visit_ty_params: fn@(_ps: ~[ty_param]) {},\n           visit_fn: fn@(_fk: fn_kind, _d: fn_decl, _b: blk, _sp: span,\n@@ -640,37 +648,37 @@ fn mk_simple_visitor(v: simple_visitor) -> vt<()> {\n         f(m);\n         visit_struct_method(m, e, v);\n     }\n-    return mk_vt(@{visit_mod: |a,b,c,d,e|v_mod(v.visit_mod, a, b, c, d, e),\n-                visit_view_item: |a,b,c|\n-                    v_view_item(v.visit_view_item, a, b, c),\n-                visit_foreign_item:\n-                    |a,b,c|v_foreign_item(v.visit_foreign_item, a, b, c),\n-                visit_item: |a,b,c|v_item(v.visit_item, a, b, c),\n-                visit_local: |a,b,c|v_local(v.visit_local, a, b, c),\n-                visit_block: |a,b,c|v_block(v.visit_block, a, b, c),\n-                visit_stmt: |a,b,c|v_stmt(v.visit_stmt, a, b, c),\n-                visit_arm: |a,b,c|v_arm(v.visit_arm, a, b, c),\n-                visit_pat: |a,b,c|v_pat(v.visit_pat, a, b, c),\n-                visit_decl: |a,b,c|v_decl(v.visit_decl, a, b, c),\n-                visit_expr: |a,b,c|v_expr(v.visit_expr, a, b, c),\n-                visit_expr_post: |a,b,c| v_expr_post(v.visit_expr_post,\n-                                                     a, b, c),\n-                visit_ty: visit_ty,\n-                visit_ty_params: |a,b,c|\n-                    v_ty_params(v.visit_ty_params, a, b, c),\n-                visit_fn: |a,b,c,d,e,f,g|\n-                    v_fn(v.visit_fn, a, b, c, d, e, f, g),\n-                visit_ty_method: |a,b,c|\n-                    v_ty_method(v.visit_ty_method, a, b, c),\n-                visit_trait_method: |a,b,c|\n-                    v_trait_method(v.visit_trait_method, a, b, c),\n-                visit_struct_def: |a,b,c,d,e,f|\n-                    v_struct_def(v.visit_struct_def, a, b, c, d, e, f),\n-                visit_struct_field: |a,b,c|\n-                    v_struct_field(v.visit_struct_field, a, b, c),\n-                visit_struct_method: |a,b,c|\n-                    v_struct_method(v.visit_struct_method, a, b, c)\n-               });\n+    return mk_vt(@Visitor {\n+        visit_mod: |a,b,c,d,e|v_mod(v.visit_mod, a, b, c, d, e),\n+        visit_view_item: |a,b,c| v_view_item(v.visit_view_item, a, b, c),\n+        visit_foreign_item:\n+            |a,b,c|v_foreign_item(v.visit_foreign_item, a, b, c),\n+        visit_item: |a,b,c|v_item(v.visit_item, a, b, c),\n+        visit_local: |a,b,c|v_local(v.visit_local, a, b, c),\n+        visit_block: |a,b,c|v_block(v.visit_block, a, b, c),\n+        visit_stmt: |a,b,c|v_stmt(v.visit_stmt, a, b, c),\n+        visit_arm: |a,b,c|v_arm(v.visit_arm, a, b, c),\n+        visit_pat: |a,b,c|v_pat(v.visit_pat, a, b, c),\n+        visit_decl: |a,b,c|v_decl(v.visit_decl, a, b, c),\n+        visit_expr: |a,b,c|v_expr(v.visit_expr, a, b, c),\n+        visit_expr_post: |a,b,c| v_expr_post(v.visit_expr_post,\n+                                             a, b, c),\n+        visit_ty: visit_ty,\n+        visit_ty_params: |a,b,c|\n+            v_ty_params(v.visit_ty_params, a, b, c),\n+        visit_fn: |a,b,c,d,e,f,g|\n+            v_fn(v.visit_fn, a, b, c, d, e, f, g),\n+        visit_ty_method: |a,b,c|\n+            v_ty_method(v.visit_ty_method, a, b, c),\n+        visit_trait_method: |a,b,c|\n+            v_trait_method(v.visit_trait_method, a, b, c),\n+        visit_struct_def: |a,b,c,d,e,f|\n+            v_struct_def(v.visit_struct_def, a, b, c, d, e, f),\n+        visit_struct_field: |a,b,c|\n+            v_struct_field(v.visit_struct_field, a, b, c),\n+        visit_struct_method: |a,b,c|\n+            v_struct_method(v.visit_struct_method, a, b, c)\n+    });\n }\n \n // Local Variables:"}, {"sha": "291a506c4ebb05e41df3394c89a1a8787b93dc85", "filename": "src/test/auxiliary/cci_nested_lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Ftest%2Fauxiliary%2Fcci_nested_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Ftest%2Fauxiliary%2Fcci_nested_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_nested_lib.rs?ref=2b92962aa29b0116015f99c1666ecf6288303c65", "patch": "@@ -14,7 +14,7 @@\n use dvec::DVec;\n \n type entry<A,B> = {key: A, value: B};\n-type alist<A,B> = { eq_fn: fn@(A,A) -> bool, data: DVec<entry<A,B>> };\n+struct alist<A,B> { eq_fn: fn@(A,A) -> bool, data: DVec<entry<A,B>> }\n \n fn alist_add<A: Copy, B: Copy>(lst: alist<A,B>, k: A, v: B) {\n     lst.data.push({key:k, value:v});\n@@ -31,12 +31,12 @@ fn alist_get<A: Copy, B: Copy>(lst: alist<A,B>, k: A) -> B {\n #[inline]\n fn new_int_alist<B: Copy>() -> alist<int, B> {\n     fn eq_int(&&a: int, &&b: int) -> bool { a == b }\n-    return {eq_fn: eq_int, data: DVec()};\n+    return alist {eq_fn: eq_int, data: DVec()};\n }\n \n #[inline]\n fn new_int_alist_2<B: Copy>() -> alist<int, B> {\n     #[inline]\n     fn eq_int(&&a: int, &&b: int) -> bool { a == b }\n-    return {eq_fn: eq_int, data: DVec()};\n+    return alist {eq_fn: eq_int, data: DVec()};\n }"}, {"sha": "b2265f5e959a0b7af49b3d8a4cf25091211b0589", "filename": "src/test/compile-fail/block-coerce-no-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Ftest%2Fcompile-fail%2Fblock-coerce-no-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Ftest%2Fcompile-fail%2Fblock-coerce-no-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fblock-coerce-no-2.rs?ref=2b92962aa29b0116015f99c1666ecf6288303c65", "patch": "@@ -19,5 +19,5 @@ fn main() {\n     }\n \n     f(g);\n-    //~^ ERROR mismatched types: expected `fn(fn(fn()))`\n+    //~^ ERROR mismatched types: expected `extern fn(extern fn(extern fn()))`\n }"}, {"sha": "457cdd2344737a3ec142f1cbca976baceb910e1e", "filename": "src/test/compile-fail/borrowck-autoref-3261.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Ftest%2Fcompile-fail%2Fborrowck-autoref-3261.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Ftest%2Fcompile-fail%2Fborrowck-autoref-3261.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-autoref-3261.rs?ref=2b92962aa29b0116015f99c1666ecf6288303c65", "patch": "@@ -9,9 +9,9 @@\n // except according to those terms.\n \n use core::either::*;\n-enum X = Either<(uint,uint),fn()>;\n+enum X = Either<(uint,uint),extern fn()>;\n impl &X {\n-    fn with(blk: fn(x: &Either<(uint,uint),fn()>)) {\n+    fn with(blk: fn(x: &Either<(uint,uint),extern fn()>)) {\n         blk(&**self)\n     }\n }"}, {"sha": "bb6633ecdc1fd47fc2fa87b3acb84a54363041b3", "filename": "src/test/compile-fail/main-wrong-type-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Ftest%2Fcompile-fail%2Fmain-wrong-type-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Ftest%2Fcompile-fail%2Fmain-wrong-type-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmain-wrong-type-2.rs?ref=2b92962aa29b0116015f99c1666ecf6288303c65", "patch": "@@ -9,5 +9,5 @@\n // except according to those terms.\n \n fn main() -> char {\n-//~^ ERROR Wrong type in main function: found `fn() -> char`\n+//~^ ERROR Wrong type in main function: found `extern fn() -> char`\n }"}, {"sha": "33d7b913dafb5f6c4bdb99e8c4f9b4058310814a", "filename": "src/test/compile-fail/main-wrong-type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Ftest%2Fcompile-fail%2Fmain-wrong-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Ftest%2Fcompile-fail%2Fmain-wrong-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmain-wrong-type.rs?ref=2b92962aa29b0116015f99c1666ecf6288303c65", "patch": "@@ -9,5 +9,5 @@\n // except according to those terms.\n \n fn main(foo: {x: int, y: int}) {\n-//~^ ERROR Wrong type in main function: found `fn({x: int,y: int})`\n+//~^ ERROR Wrong type in main function: found `extern fn({x: int,y: int})`\n }"}, {"sha": "916008373c875d65f2e9308d52a0761ab7960b58", "filename": "src/test/compile-fail/missing-do.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Ftest%2Fcompile-fail%2Fmissing-do.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Ftest%2Fcompile-fail%2Fmissing-do.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmissing-do.rs?ref=2b92962aa29b0116015f99c1666ecf6288303c65", "patch": "@@ -14,6 +14,6 @@ fn foo(f: fn()) { f() }\n \n fn main() {\n     ~\"\" || 42; //~ ERROR binary operation || cannot be applied to type `~str`\n-    foo || {}; //~ ERROR binary operation || cannot be applied to type `fn(&fn())`\n+    foo || {}; //~ ERROR binary operation || cannot be applied to type `extern fn(&fn())`\n     //~^ NOTE did you forget the 'do' keyword for the call?\n }"}, {"sha": "0e7d90e2fd81f4b684d07724dcdb12461e18a667", "filename": "src/test/run-pass/fn-coerce-field.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Ftest%2Frun-pass%2Ffn-coerce-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Ftest%2Frun-pass%2Ffn-coerce-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffn-coerce-field.rs?ref=2b92962aa29b0116015f99c1666ecf6288303c65", "patch": "@@ -8,11 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-type r = {\n+struct r {\n     field: fn@()\n-};\n+}\n \n fn main() {\n     fn f() {}\n-    let i: r = {field: f};\n+    let i: r = r {field: f};\n }\n\\ No newline at end of file"}, {"sha": "4b48e9a49c2ac6858890d02ed2e54b6d0a200650", "filename": "src/test/run-pass/intrinsic-frame-address.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Ftest%2Frun-pass%2Fintrinsic-frame-address.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Ftest%2Frun-pass%2Fintrinsic-frame-address.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fintrinsic-frame-address.rs?ref=2b92962aa29b0116015f99c1666ecf6288303c65", "patch": "@@ -13,7 +13,7 @@\n #[abi = \"rust-intrinsic\"]\n extern mod rusti {\n     #[legacy_exports];\n-    fn frame_address(f: fn(*u8));\n+    fn frame_address(f: &once fn(*u8));\n }\n \n fn main() {"}, {"sha": "15d809e8208b35339dd9416642753efae2e582df", "filename": "src/test/run-pass/issue-1458.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Ftest%2Frun-pass%2Fissue-1458.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b92962aa29b0116015f99c1666ecf6288303c65/src%2Ftest%2Frun-pass%2Fissue-1458.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-1458.rs?ref=2b92962aa29b0116015f99c1666ecf6288303c65", "patch": "@@ -12,7 +12,7 @@ fn plus_one(f: fn() -> int) -> int {\n   return f() + 1;\n }\n \n-fn ret_plus_one() -> fn(fn() -> int) -> int {\n+fn ret_plus_one() -> extern fn(fn() -> int) -> int {\n   return plus_one;\n }\n "}]}