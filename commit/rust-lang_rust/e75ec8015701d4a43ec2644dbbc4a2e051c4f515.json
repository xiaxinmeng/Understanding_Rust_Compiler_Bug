{"sha": "e75ec8015701d4a43ec2644dbbc4a2e051c4f515", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU3NWVjODAxNTcwMWQ0YTQzZWMyNjQ0ZGJiYzRhMmUwNTFjNGY1MTU=", "commit": {"author": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2013-07-24T00:01:43Z"}, "committer": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2013-07-24T00:06:32Z"}, "message": "Improve vtable resolution.\n\nImprove vtable resolution in a handful of ways.  First, if we don't\nfind a vtable for a self/param type, do a regular vtable search.  This\ncould find impls of the form \"impl for A\". Second, we don't require\nthat types be fully resolved before looking up subtables, and we\nprocess tables in reverse order. This allows us to gain more\ninformation about early type parameters based on how they are used by\nthe impls used to resolve later params.\n\nCloses #6967, I believe.", "tree": {"sha": "6daa4fc861d92567f8c30b8f2e67acc7243960d4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6daa4fc861d92567f8c30b8f2e67acc7243960d4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e75ec8015701d4a43ec2644dbbc4a2e051c4f515", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e75ec8015701d4a43ec2644dbbc4a2e051c4f515", "html_url": "https://github.com/rust-lang/rust/commit/e75ec8015701d4a43ec2644dbbc4a2e051c4f515", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e75ec8015701d4a43ec2644dbbc4a2e051c4f515/comments", "author": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fbbbc98ea4aaa59c7266ab4b60f18050a046634e", "url": "https://api.github.com/repos/rust-lang/rust/commits/fbbbc98ea4aaa59c7266ab4b60f18050a046634e", "html_url": "https://github.com/rust-lang/rust/commit/fbbbc98ea4aaa59c7266ab4b60f18050a046634e"}], "stats": {"total": 70, "additions": 46, "deletions": 24}, "files": [{"sha": "9143563a68fd6c961477f0269a8c2ec0527c206c", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 46, "deletions": 24, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/e75ec8015701d4a43ec2644dbbc4a2e051c4f515/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e75ec8015701d4a43ec2644dbbc4a2e051c4f515/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=e75ec8015701d4a43ec2644dbbc4a2e051c4f515", "patch": "@@ -45,6 +45,16 @@ use syntax::visit;\n // *fully* resolved. (We could be less restrictive than that, but it\n // would require much more care, and this seems to work decently in\n // practice.)\n+//\n+// While resolution on a single type requires the type to be fully\n+// resolved, when resolving a substitution against a list of bounds,\n+// we do not require all of the types to be resolved in advance.\n+// Furthermore, we process substitutions in reverse order, which\n+// allows resolution on later parameters to give information on\n+// earlier params referenced by the typeclass bounds.\n+// It may be better to do something more clever, like processing fully\n+// resolved types first.\n+\n \n /// Location info records the span and ID of the expression or item that is\n /// responsible for this vtable instantiation. (This may not be an expression\n@@ -83,11 +93,19 @@ fn lookup_vtables(vcx: &VtableContext,\n            substs.repr(vcx.tcx()));\n     let _i = indenter();\n \n-    let mut result = ~[];\n-    for substs.tps.iter().zip(type_param_defs.iter()).advance |(ty, def)| {\n-        result.push(lookup_vtables_for_param(vcx, location_info, Some(substs),\n-                                             &*def.bounds, *ty, is_early));\n-    }\n+\n+    // We do this backwards for reasons discussed above.\n+    assert_eq!(substs.tps.len(), type_param_defs.len());\n+    let mut result =\n+        substs.tps.rev_iter()\n+        .zip(type_param_defs.rev_iter())\n+        .transform(|(ty, def)|\n+                   lookup_vtables_for_param(vcx, location_info, Some(substs),\n+                                            &*def.bounds, *ty, is_early))\n+        .to_owned_vec();\n+    result.reverse();\n+\n+    assert_eq!(substs.tps.len(), result.len());\n     debug!(\"lookup_vtables result(\\\n             location_info=%?, \\\n             type_param_defs=%s, \\\n@@ -198,8 +216,7 @@ fn relate_trait_refs(vcx: &VtableContext,\n     }\n }\n \n-// Look up the vtable to use when treating an item of type `t` as if it has\n-// type `trait_ty`\n+// Look up the vtable implementing the trait `trait_ref` at type `t`\n fn lookup_vtable(vcx: &VtableContext,\n                  location_info: &LocationInfo,\n                  ty: ty::t,\n@@ -261,13 +278,14 @@ fn lookup_vtable(vcx: &VtableContext,\n             }\n         }\n \n-        _ => {\n-            return search_for_vtable(vcx, location_info,\n-                                     ty, trait_ref, is_early)\n-        }\n+        // Default case just falls through\n+        _ => { }\n     }\n \n-    return None;\n+    // If we aren't a self type or param, or it was, but we didn't find it,\n+    // do a search.\n+    return search_for_vtable(vcx, location_info,\n+                             ty, trait_ref, is_early)\n }\n \n fn search_for_vtable(vcx: &VtableContext,\n@@ -359,16 +377,23 @@ fn search_for_vtable(vcx: &VtableContext,\n         let of_trait_ref = of_trait_ref.subst(tcx, &substs);\n         relate_trait_refs(vcx, location_info, of_trait_ref, trait_ref);\n \n+\n         // Recall that trait_ref -- the trait type we're casting to --\n         // is the trait with id trait_ref.def_id applied to the substs\n-        // trait_ref.substs. Now we extract out the types themselves\n-        // from trait_ref.substs.\n+        // trait_ref.substs.\n+\n+        // Resolve any sub bounds. Note that there still may be free\n+        // type variables in substs. This might still be OK: the\n+        // process of looking up bounds might constrain some of them.\n+        let im_generics =\n+            ty::lookup_item_type(tcx, im.did).generics;\n+        let subres = lookup_vtables(vcx, location_info,\n+                                    *im_generics.type_param_defs, &substs,\n+                                    is_early);\n \n-        // Recall that substs is the impl self type's list of\n-        // substitutions. That is, if this is an impl of some trait\n-        // for foo<T, U>, then substs is [T, U]. substs might contain\n-        // type variables, so we call fixup_substs to resolve them.\n \n+        // substs might contain type variables, so we call\n+        // fixup_substs to resolve them.\n         let substs_f = match fixup_substs(vcx,\n                                           location_info,\n                                           trait_ref.def_id,\n@@ -392,13 +417,10 @@ fn search_for_vtable(vcx: &VtableContext,\n         // ty with the substitutions from the trait type that we're\n         // trying to cast to. connect_trait_tps requires these lists\n         // of types to unify pairwise.\n-\n-        let im_generics =\n-            ty::lookup_item_type(tcx, im.did).generics;\n+        // I am a little confused about this, since it seems to be\n+        // very similar to the relate_trait_refs we already do,\n+        // but problems crop up if it is removed, so... -sully\n         connect_trait_tps(vcx, location_info, &substs_f, trait_ref, im.did);\n-        let subres = lookup_vtables(vcx, location_info,\n-                                    *im_generics.type_param_defs, &substs_f,\n-                                    is_early);\n \n         // Finally, we register that we found a matching impl, and\n         // record the def ID of the impl as well as the resolved list"}]}