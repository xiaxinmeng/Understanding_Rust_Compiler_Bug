{"sha": "f55ac6944a88d4da62b30a16cc95893ca050c328", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY1NWFjNjk0NGE4OGQ0ZGE2MmIzMGExNmNjOTU4OTNjYTA1MGMzMjg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-08-12T08:26:12Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-08-12T08:26:12Z"}, "message": "Auto merge of #35091 - eddyb:impl-trait, r=nikomatsakis\n\nImplement `impl Trait` in return type position by anonymization.\n\nThis is the first step towards implementing `impl Trait` (cc #34511).\n`impl Trait` types are only allowed in function and inherent method return types, and capture all named lifetime and type parameters, being invariant over them.\nNo lifetimes that are not explicitly named lifetime parameters are allowed to escape from the function body.\nThe exposed traits are only those listed explicitly, i.e. `Foo` and `Clone` in `impl Foo + Clone`, with the exception of \"auto traits\" (like `Send` or `Sync`) which \"leak\" the actual contents.\n\nThe implementation strategy is anonymization, i.e.:\n```rust\nfn foo<T>(xs: Vec<T>) -> impl Iterator<Item=impl FnOnce() -> T> {\n    xs.into_iter().map(|x| || x)\n}\n\n// is represented as:\ntype A</*invariant over*/ T> where A<T>: Iterator<Item=B<T>>;\ntype B</*invariant over*/ T> where B<T>: FnOnce() -> T;\nfn foo<T>(xs: Vec<T>) -> A<T> {\n    xs.into_iter().map(|x| || x): $0 where $0: Iterator<Item=$1>, $1: FnOnce() -> T\n}\n```\n`$0` and `$1` are resolved (to `iter::Map<vec::Iter<T>, closure>` and the closure, respectively) and assigned to `A` and `B`, after checking the body of `foo`. `A` and `B` are *never* resolved for user-facing type equality (typeck), but always for the low-level representation and specialization (trans).\n\nThe \"auto traits\" exception is implemented by collecting bounds like `impl Trait: Send` that have failed for the obscure `impl Trait` type (i.e. `A` or `B` above), pretending they succeeded within the function and trying them again after type-checking the whole crate, by replacing `impl Trait` with the real type.\n\nWhile passing around values which have explicit lifetime parameters (of the function with `-> impl Trait`) in their type *should* work, regionck appears to assign inference variables in *way* too many cases, and never properly resolving them to either explicit lifetime parameters, or `'static`.\nWe might not be able to handle lifetime parameters in `impl Trait` without changes to lifetime inference, but type parameters can have arbitrary lifetimes in them from the caller, so most type-generic usecases (or not generic at all) should not run into this problem.\n\ncc @rust-lang/lang", "tree": {"sha": "b7ed97b0e92a0f082df1349fd7b8d32c30053ded", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b7ed97b0e92a0f082df1349fd7b8d32c30053ded"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f55ac6944a88d4da62b30a16cc95893ca050c328", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f55ac6944a88d4da62b30a16cc95893ca050c328", "html_url": "https://github.com/rust-lang/rust/commit/f55ac6944a88d4da62b30a16cc95893ca050c328", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f55ac6944a88d4da62b30a16cc95893ca050c328/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "68d9284a9b7570ec32178e544f6f8ca7ac0be0f9", "url": "https://api.github.com/repos/rust-lang/rust/commits/68d9284a9b7570ec32178e544f6f8ca7ac0be0f9", "html_url": "https://github.com/rust-lang/rust/commit/68d9284a9b7570ec32178e544f6f8ca7ac0be0f9"}, {"sha": "23f0494114a39e503a369a345847b8bc9577c216", "url": "https://api.github.com/repos/rust-lang/rust/commits/23f0494114a39e503a369a345847b8bc9577c216", "html_url": "https://github.com/rust-lang/rust/commit/23f0494114a39e503a369a345847b8bc9577c216"}], "stats": {"total": 3320, "additions": 2788, "deletions": 532}, "files": [{"sha": "dd79e14f077e831c5949797dd4b62c4fc08c7bef", "filename": "src/librustc/hir/fold.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc%2Fhir%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc%2Fhir%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Ffold.rs?ref=f55ac6944a88d4da62b30a16cc95893ca050c328", "patch": "@@ -375,6 +375,9 @@ pub fn noop_fold_ty<T: Folder>(t: P<Ty>, fld: &mut T) -> P<Ty> {\n                 TyPolyTraitRef(bounds) => {\n                     TyPolyTraitRef(bounds.move_map(|b| fld.fold_ty_param_bound(b)))\n                 }\n+                TyImplTrait(bounds) => {\n+                    TyImplTrait(bounds.move_map(|b| fld.fold_ty_param_bound(b)))\n+                }\n             },\n             span: fld.new_span(span),\n         }"}, {"sha": "1162c290f9cfca675f63b14bb52fef53e050e59e", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=f55ac6944a88d4da62b30a16cc95893ca050c328", "patch": "@@ -427,6 +427,9 @@ pub fn walk_ty<'v, V: Visitor<'v>>(visitor: &mut V, typ: &'v Ty) {\n         TyPolyTraitRef(ref bounds) => {\n             walk_list!(visitor, visit_ty_param_bound, bounds);\n         }\n+        TyImplTrait(ref bounds) => {\n+            walk_list!(visitor, visit_ty_param_bound, bounds);\n+        }\n         TyTypeof(ref expression) => {\n             visitor.visit_expr(expression)\n         }"}, {"sha": "eb98ed77da703df241719e57999b9c37a460930d", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=f55ac6944a88d4da62b30a16cc95893ca050c328", "patch": "@@ -293,8 +293,10 @@ impl<'a> LoweringContext<'a> {\n                     hir::TyTypeof(self.lower_expr(expr))\n                 }\n                 PolyTraitRef(ref bounds) => {\n-                    let bounds = bounds.iter().map(|b| self.lower_ty_param_bound(b)).collect();\n-                    hir::TyPolyTraitRef(bounds)\n+                    hir::TyPolyTraitRef(self.lower_bounds(bounds))\n+                }\n+                ImplTrait(ref bounds) => {\n+                    hir::TyImplTrait(self.lower_bounds(bounds))\n                 }\n                 Mac(_) => panic!(\"TyMac should have been expanded by now.\"),\n             },"}, {"sha": "b70190181af8fcf80123a70d575af4cc1bda43e9", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=f55ac6944a88d4da62b30a16cc95893ca050c328", "patch": "@@ -194,6 +194,14 @@ impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n         });\n     }\n \n+    fn visit_ty(&mut self, ty: &'ast Ty) {\n+        self.insert(ty.id, NodeTy(ty));\n+\n+        self.with_parent(ty.id, |this| {\n+            intravisit::walk_ty(this, ty);\n+        });\n+    }\n+\n     fn visit_fn(&mut self, fk: intravisit::FnKind<'ast>, fd: &'ast FnDecl,\n                 b: &'ast Block, s: Span, id: NodeId) {\n         assert_eq!(self.parent_node, id);"}, {"sha": "752b0e9a253dd9a7ee1cf41cd922c1f8467ce1c2", "filename": "src/librustc/hir/map/def_collector.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs?ref=f55ac6944a88d4da62b30a16cc95893ca050c328", "patch": "@@ -268,6 +268,9 @@ impl<'ast> visit::Visitor for DefCollector<'ast> {\n         if let TyKind::FixedLengthVec(_, ref length) = ty.node {\n             self.visit_ast_const_integer(length);\n         }\n+        if let TyKind::ImplTrait(..) = ty.node {\n+            self.create_def(ty.id, DefPathData::ImplTrait);\n+        }\n         visit::walk_ty(self, ty);\n     }\n \n@@ -428,6 +431,9 @@ impl<'ast> intravisit::Visitor<'ast> for DefCollector<'ast> {\n         if let hir::TyFixedLengthVec(_, ref length) = ty.node {\n             self.visit_hir_const_integer(length);\n         }\n+        if let hir::TyImplTrait(..) = ty.node {\n+            self.create_def(ty.id, DefPathData::ImplTrait);\n+        }\n         intravisit::walk_ty(self, ty);\n     }\n "}, {"sha": "901a489728eeca0aca5c4ff7d9e26b23985047af", "filename": "src/librustc/hir/map/definitions.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs?ref=f55ac6944a88d4da62b30a16cc95893ca050c328", "patch": "@@ -215,6 +215,8 @@ pub enum DefPathData {\n     Initializer,\n     /// Pattern binding\n     Binding(InternedString),\n+    /// An `impl Trait` type node.\n+    ImplTrait\n }\n \n impl Definitions {\n@@ -369,6 +371,10 @@ impl DefPathData {\n             Initializer => {\n                 InternedString::new(\"{{initializer}}\")\n             }\n+\n+            ImplTrait => {\n+                InternedString::new(\"{{impl-Trait}}\")\n+            }\n         }\n     }\n "}, {"sha": "7e82a4a05a76461216731761e4ed6b1c9b33284e", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=f55ac6944a88d4da62b30a16cc95893ca050c328", "patch": "@@ -50,6 +50,7 @@ pub enum Node<'ast> {\n     NodeVariant(&'ast Variant),\n     NodeExpr(&'ast Expr),\n     NodeStmt(&'ast Stmt),\n+    NodeTy(&'ast Ty),\n     NodeLocal(&'ast Pat),\n     NodePat(&'ast Pat),\n     NodeBlock(&'ast Block),\n@@ -76,6 +77,7 @@ pub enum MapEntry<'ast> {\n     EntryVariant(NodeId, &'ast Variant),\n     EntryExpr(NodeId, &'ast Expr),\n     EntryStmt(NodeId, &'ast Stmt),\n+    EntryTy(NodeId, &'ast Ty),\n     EntryLocal(NodeId, &'ast Pat),\n     EntryPat(NodeId, &'ast Pat),\n     EntryBlock(NodeId, &'ast Block),\n@@ -104,6 +106,7 @@ impl<'ast> MapEntry<'ast> {\n             NodeVariant(n) => EntryVariant(p, n),\n             NodeExpr(n) => EntryExpr(p, n),\n             NodeStmt(n) => EntryStmt(p, n),\n+            NodeTy(n) => EntryTy(p, n),\n             NodeLocal(n) => EntryLocal(p, n),\n             NodePat(n) => EntryPat(p, n),\n             NodeBlock(n) => EntryBlock(p, n),\n@@ -122,6 +125,7 @@ impl<'ast> MapEntry<'ast> {\n             EntryVariant(id, _) => id,\n             EntryExpr(id, _) => id,\n             EntryStmt(id, _) => id,\n+            EntryTy(id, _) => id,\n             EntryLocal(id, _) => id,\n             EntryPat(id, _) => id,\n             EntryBlock(id, _) => id,\n@@ -144,6 +148,7 @@ impl<'ast> MapEntry<'ast> {\n             EntryVariant(_, n) => NodeVariant(n),\n             EntryExpr(_, n) => NodeExpr(n),\n             EntryStmt(_, n) => NodeStmt(n),\n+            EntryTy(_, n) => NodeTy(n),\n             EntryLocal(_, n) => NodeLocal(n),\n             EntryPat(_, n) => NodePat(n),\n             EntryBlock(_, n) => NodeBlock(n),\n@@ -257,6 +262,7 @@ impl<'ast> Map<'ast> {\n                     EntryVariant(p, _) |\n                     EntryExpr(p, _) |\n                     EntryStmt(p, _) |\n+                EntryTy(p, _) |\n                     EntryLocal(p, _) |\n                     EntryPat(p, _) |\n                     EntryBlock(p, _) |\n@@ -297,6 +303,7 @@ impl<'ast> Map<'ast> {\n                     EntryVariant(p, _) |\n                     EntryExpr(p, _) |\n                     EntryStmt(p, _) |\n+                    EntryTy(p, _) |\n                     EntryLocal(p, _) |\n                     EntryPat(p, _) |\n                     EntryBlock(p, _) |\n@@ -680,6 +687,7 @@ impl<'ast> Map<'ast> {\n             Some(NodeVariant(variant)) => variant.span,\n             Some(NodeExpr(expr)) => expr.span,\n             Some(NodeStmt(stmt)) => stmt.span,\n+            Some(NodeTy(ty)) => ty.span,\n             Some(NodeLocal(pat)) => pat.span,\n             Some(NodePat(pat)) => pat.span,\n             Some(NodeBlock(block)) => block.span,\n@@ -971,6 +979,7 @@ impl<'a> NodePrinter for pprust::State<'a> {\n             NodeVariant(a)     => self.print_variant(&a),\n             NodeExpr(a)        => self.print_expr(&a),\n             NodeStmt(a)        => self.print_stmt(&a),\n+            NodeTy(a)          => self.print_type(&a),\n             NodePat(a)         => self.print_pat(&a),\n             NodeBlock(a)       => self.print_block(&a),\n             NodeLifetime(a)    => self.print_lifetime(&a),\n@@ -1059,6 +1068,9 @@ fn node_id_to_string(map: &Map, id: NodeId, include_id: bool) -> String {\n         Some(NodeStmt(ref stmt)) => {\n             format!(\"stmt {}{}\", pprust::stmt_to_string(&stmt), id_str)\n         }\n+        Some(NodeTy(ref ty)) => {\n+            format!(\"type {}{}\", pprust::ty_to_string(&ty), id_str)\n+        }\n         Some(NodeLocal(ref pat)) => {\n             format!(\"local {}{}\", pprust::pat_to_string(&pat), id_str)\n         }"}, {"sha": "707ef987c2c06e1518c466bccad774f5a9765732", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=f55ac6944a88d4da62b30a16cc95893ca050c328", "patch": "@@ -1132,6 +1132,8 @@ pub enum Ty_ {\n     TyObjectSum(P<Ty>, TyParamBounds),\n     /// A type like `for<'a> Foo<&'a Bar>`\n     TyPolyTraitRef(TyParamBounds),\n+    /// An `impl TraitA+TraitB` type.\n+    TyImplTrait(TyParamBounds),\n     /// Unused for now\n     TyTypeof(P<Expr>),\n     /// TyInfer means the type should be inferred instead of it having been"}, {"sha": "6dedae5ccd75d2761321976ae5a260c343ab7315", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=f55ac6944a88d4da62b30a16cc95893ca050c328", "patch": "@@ -536,6 +536,9 @@ impl<'a> State<'a> {\n             hir::TyPolyTraitRef(ref bounds) => {\n                 self.print_bounds(\"\", &bounds[..])?;\n             }\n+            hir::TyImplTrait(ref bounds) => {\n+                self.print_bounds(\"impl \", &bounds[..])?;\n+            }\n             hir::TyFixedLengthVec(ref ty, ref v) => {\n                 word(&mut self.s, \"[\")?;\n                 self.print_type(&ty)?;"}, {"sha": "1fb4e59e13189ff07fc14de61e81f58142d9ecff", "filename": "src/librustc/infer/freshen.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ffreshen.rs?ref=f55ac6944a88d4da62b30a16cc95893ca050c328", "patch": "@@ -170,7 +170,8 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for TypeFreshener<'a, 'gcx, 'tcx> {\n             ty::TyClosure(..) |\n             ty::TyTuple(..) |\n             ty::TyProjection(..) |\n-            ty::TyParam(..) => {\n+            ty::TyParam(..) |\n+            ty::TyAnon(..) => {\n                 t.super_fold_with(self)\n             }\n         }"}, {"sha": "697478015cb7b65a496d0b88ec48555f25fa7e37", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=f55ac6944a88d4da62b30a16cc95893ca050c328", "patch": "@@ -34,7 +34,7 @@ use ty::{self, Ty, TyCtxt};\n use ty::error::{ExpectedFound, TypeError, UnconstrainedNumeric};\n use ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n use ty::relate::{Relate, RelateResult, TypeRelation};\n-use traits::{self, PredicateObligations, ProjectionMode};\n+use traits::{self, PredicateObligations, Reveal};\n use rustc_data_structures::unify::{self, UnificationTable};\n use std::cell::{Cell, RefCell, Ref, RefMut};\n use std::fmt;\n@@ -147,8 +147,8 @@ pub struct InferCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n \n     // Sadly, the behavior of projection varies a bit depending on the\n     // stage of compilation. The specifics are given in the\n-    // documentation for `ProjectionMode`.\n-    projection_mode: ProjectionMode,\n+    // documentation for `Reveal`.\n+    projection_mode: Reveal,\n \n     // When an error occurs, we want to avoid reporting \"derived\"\n     // errors that are due to this original failure. Normally, we\n@@ -459,15 +459,15 @@ pub struct InferCtxtBuilder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     arenas: ty::CtxtArenas<'tcx>,\n     tables: Option<RefCell<ty::Tables<'tcx>>>,\n     param_env: Option<ty::ParameterEnvironment<'gcx>>,\n-    projection_mode: ProjectionMode,\n+    projection_mode: Reveal,\n     normalize: bool\n }\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'gcx> {\n     pub fn infer_ctxt(self,\n                       tables: Option<ty::Tables<'tcx>>,\n                       param_env: Option<ty::ParameterEnvironment<'gcx>>,\n-                      projection_mode: ProjectionMode)\n+                      projection_mode: Reveal)\n                       -> InferCtxtBuilder<'a, 'gcx, 'tcx> {\n         InferCtxtBuilder {\n             global_tcx: self,\n@@ -479,7 +479,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'gcx> {\n         }\n     }\n \n-    pub fn normalizing_infer_ctxt(self, projection_mode: ProjectionMode)\n+    pub fn normalizing_infer_ctxt(self, projection_mode: Reveal)\n                                   -> InferCtxtBuilder<'a, 'gcx, 'tcx> {\n         InferCtxtBuilder {\n             global_tcx: self,\n@@ -509,7 +509,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'gcx> {\n             projection_cache: RefCell::new(traits::ProjectionCache::new()),\n             reported_trait_errors: RefCell::new(FnvHashSet()),\n             normalize: false,\n-            projection_mode: ProjectionMode::AnyFinal,\n+            projection_mode: Reveal::NotSpecializable,\n             tainted_by_errors_flag: Cell::new(false),\n             err_count_on_creation: self.sess.err_count(),\n             obligations_in_snapshot: Cell::new(false),\n@@ -641,7 +641,7 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n             return value;\n         }\n \n-        self.infer_ctxt(None, None, ProjectionMode::Any).enter(|infcx| {\n+        self.infer_ctxt(None, None, Reveal::All).enter(|infcx| {\n             value.trans_normalize(&infcx)\n         })\n     }\n@@ -659,7 +659,7 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n             return value;\n         }\n \n-        self.infer_ctxt(None, Some(env.clone()), ProjectionMode::Any).enter(|infcx| {\n+        self.infer_ctxt(None, Some(env.clone()), Reveal::All).enter(|infcx| {\n             value.trans_normalize(&infcx)\n        })\n     }\n@@ -736,7 +736,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         Ok(self.tcx.erase_regions(&result))\n     }\n \n-    pub fn projection_mode(&self) -> ProjectionMode {\n+    pub fn projection_mode(&self) -> Reveal {\n         self.projection_mode\n     }\n "}, {"sha": "15f2f21ef25291b2c4df292dada02a9bcd701d19", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=f55ac6944a88d4da62b30a16cc95893ca050c328", "patch": "@@ -12,7 +12,7 @@ use dep_graph::DepNode;\n use hir::def::Def;\n use hir::def_id::DefId;\n use infer::InferCtxt;\n-use traits::ProjectionMode;\n+use traits::Reveal;\n use ty::{self, Ty, TyCtxt};\n use ty::layout::{LayoutError, Pointer, SizeSkeleton};\n \n@@ -36,7 +36,7 @@ struct ItemVisitor<'a, 'tcx: 'a> {\n impl<'a, 'tcx> ItemVisitor<'a, 'tcx> {\n     fn visit_const(&mut self, item_id: ast::NodeId, expr: &hir::Expr) {\n         let param_env = ty::ParameterEnvironment::for_item(self.tcx, item_id);\n-        self.tcx.infer_ctxt(None, Some(param_env), ProjectionMode::Any).enter(|infcx| {\n+        self.tcx.infer_ctxt(None, Some(param_env), Reveal::All).enter(|infcx| {\n             let mut visitor = ExprVisitor {\n                 infcx: &infcx\n             };\n@@ -114,7 +114,7 @@ impl<'a, 'gcx, 'tcx> ExprVisitor<'a, 'gcx, 'tcx> {\n impl<'a, 'tcx, 'v> Visitor<'v> for ItemVisitor<'a, 'tcx> {\n     // const, static and N in [T; N].\n     fn visit_expr(&mut self, expr: &hir::Expr) {\n-        self.tcx.infer_ctxt(None, None, ProjectionMode::Any).enter(|infcx| {\n+        self.tcx.infer_ctxt(None, None, Reveal::All).enter(|infcx| {\n             let mut visitor = ExprVisitor {\n                 infcx: &infcx\n             };\n@@ -144,7 +144,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ItemVisitor<'a, 'tcx> {\n             span_bug!(s, \"intrinsicck: closure outside of function\")\n         }\n         let param_env = ty::ParameterEnvironment::for_item(self.tcx, id);\n-        self.tcx.infer_ctxt(None, Some(param_env), ProjectionMode::Any).enter(|infcx| {\n+        self.tcx.infer_ctxt(None, Some(param_env), Reveal::All).enter(|infcx| {\n             let mut visitor = ExprVisitor {\n                 infcx: &infcx\n             };"}, {"sha": "f62c9a5d8823e7586b9d90b77aa420e62f80549c", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=f55ac6944a88d4da62b30a16cc95893ca050c328", "patch": "@@ -113,7 +113,7 @@ use dep_graph::DepNode;\n use hir::def::*;\n use hir::pat_util;\n use ty::{self, TyCtxt, ParameterEnvironment};\n-use traits::{self, ProjectionMode};\n+use traits::{self, Reveal};\n use ty::subst::Subst;\n use lint;\n use util::nodemap::NodeMap;\n@@ -1484,7 +1484,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                 let param_env = ParameterEnvironment::for_item(self.ir.tcx, id);\n                 let t_ret_subst = t_ret.subst(self.ir.tcx, &param_env.free_substs);\n                 let is_nil = self.ir.tcx.infer_ctxt(None, Some(param_env),\n-                                                    ProjectionMode::Any).enter(|infcx| {\n+                                                    Reveal::All).enter(|infcx| {\n                     let cause = traits::ObligationCause::dummy();\n                     traits::fully_normalize(&infcx, cause, &t_ret_subst).unwrap().is_nil()\n                 });"}, {"sha": "76c73f12f4ebe28c485b3e4c9257d4e9c4cb4073", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=f55ac6944a88d4da62b30a16cc95893ca050c328", "patch": "@@ -832,7 +832,10 @@ fn insert_late_bound_lifetimes(map: &mut NamedRegionMap,\n         constrained_by_input.visit_ty(&arg.ty);\n     }\n \n-    let mut appears_in_output = AllCollector { regions: FnvHashSet() };\n+    let mut appears_in_output = AllCollector {\n+        regions: FnvHashSet(),\n+        impl_trait: false\n+    };\n     intravisit::walk_fn_ret_ty(&mut appears_in_output, &decl.output);\n \n     debug!(\"insert_late_bound_lifetimes: constrained_by_input={:?}\",\n@@ -842,7 +845,10 @@ fn insert_late_bound_lifetimes(map: &mut NamedRegionMap,\n     //\n     // Subtle point: because we disallow nested bindings, we can just\n     // ignore binders here and scrape up all names we see.\n-    let mut appears_in_where_clause = AllCollector { regions: FnvHashSet() };\n+    let mut appears_in_where_clause = AllCollector {\n+        regions: FnvHashSet(),\n+        impl_trait: false\n+    };\n     for ty_param in generics.ty_params.iter() {\n         walk_list!(&mut appears_in_where_clause,\n                    visit_ty_param_bound,\n@@ -864,12 +870,16 @@ fn insert_late_bound_lifetimes(map: &mut NamedRegionMap,\n     // Late bound regions are those that:\n     // - appear in the inputs\n     // - do not appear in the where-clauses\n+    // - are not implicitly captured by `impl Trait`\n     for lifetime in &generics.lifetimes {\n         let name = lifetime.lifetime.name;\n \n         // appears in the where clauses? early-bound.\n         if appears_in_where_clause.regions.contains(&name) { continue; }\n \n+        // any `impl Trait` in the return type? early-bound.\n+        if appears_in_output.impl_trait { continue; }\n+\n         // does not appear in the inputs, but appears in the return\n         // type? eventually this will be early-bound, but for now we\n         // just mark it so we can issue warnings.\n@@ -932,12 +942,20 @@ fn insert_late_bound_lifetimes(map: &mut NamedRegionMap,\n \n     struct AllCollector {\n         regions: FnvHashSet<ast::Name>,\n+        impl_trait: bool\n     }\n \n     impl<'v> Visitor<'v> for AllCollector {\n         fn visit_lifetime(&mut self, lifetime_ref: &'v hir::Lifetime) {\n             self.regions.insert(lifetime_ref.name);\n         }\n+\n+        fn visit_ty(&mut self, ty: &hir::Ty) {\n+            if let hir::TyImplTrait(_) = ty.node {\n+                self.impl_trait = true;\n+            }\n+            intravisit::walk_ty(self, ty);\n+        }\n     }\n }\n "}, {"sha": "37193d45e68852245a523c298b94e01689ce8164", "filename": "src/librustc/traits/coherence.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fcoherence.rs?ref=f55ac6944a88d4da62b30a16cc95893ca050c328", "patch": "@@ -281,7 +281,7 @@ fn ty_is_local_constructor(tcx: TyCtxt, ty: Ty, infer_is_local: InferIsLocal)->\n             true\n         }\n \n-        ty::TyClosure(..) => {\n+        ty::TyClosure(..) | ty::TyAnon(..) => {\n             bug!(\"ty_is_local invoked on unexpected type: {:?}\", ty)\n         }\n     }"}, {"sha": "09b5a34fdf33722cb048348fe8e70b16d6c13a3b", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=f55ac6944a88d4da62b30a16cc95893ca050c328", "patch": "@@ -211,6 +211,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 ty::TyTuple(..) => Some(12),\n                 ty::TyProjection(..) => Some(13),\n                 ty::TyParam(..) => Some(14),\n+                ty::TyAnon(..) => Some(15),\n                 ty::TyInfer(..) | ty::TyError => None\n             }\n         }"}, {"sha": "5ba7b914d6591ba57c6cf42452c853165e477dcd", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 137, "deletions": 12, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=f55ac6944a88d4da62b30a16cc95893ca050c328", "patch": "@@ -10,7 +10,8 @@\n \n use dep_graph::DepGraph;\n use infer::{InferCtxt, InferOk};\n-use ty::{self, Ty, TypeFoldable, ToPolyTraitRef, TyCtxt};\n+use ty::{self, Ty, TypeFoldable, ToPolyTraitRef, TyCtxt, ToPredicate};\n+use ty::subst::{Substs, Subst};\n use rustc_data_structures::obligation_forest::{ObligationForest, Error};\n use rustc_data_structures::obligation_forest::{ForestObligation, ObligationProcessor};\n use std::marker::PhantomData;\n@@ -22,10 +23,9 @@ use util::nodemap::{FnvHashSet, NodeMap};\n use super::CodeAmbiguity;\n use super::CodeProjectionError;\n use super::CodeSelectionError;\n-use super::FulfillmentError;\n-use super::FulfillmentErrorCode;\n-use super::ObligationCause;\n-use super::PredicateObligation;\n+use super::{FulfillmentError, FulfillmentErrorCode, SelectionError};\n+use super::{ObligationCause, BuiltinDerivedObligation};\n+use super::{PredicateObligation, TraitObligation, Obligation};\n use super::project;\n use super::select::SelectionContext;\n use super::Unimplemented;\n@@ -51,6 +51,7 @@ pub struct GlobalFulfilledPredicates<'tcx> {\n /// along. Once all type inference constraints have been generated, the\n /// method `select_all_or_error` can be used to report any remaining\n /// ambiguous cases as errors.\n+\n pub struct FulfillmentContext<'tcx> {\n     // A list of all obligations that have been registered with this\n     // fulfillment context.\n@@ -84,6 +85,10 @@ pub struct FulfillmentContext<'tcx> {\n     // obligations (otherwise, it's easy to fail to walk to a\n     // particular node-id).\n     region_obligations: NodeMap<Vec<RegionObligation<'tcx>>>,\n+\n+    // A list of obligations that need to be deferred to\n+    // a later time for them to be properly fulfilled.\n+    deferred_obligations: Vec<DeferredObligation<'tcx>>,\n }\n \n #[derive(Clone)]\n@@ -99,13 +104,98 @@ pub struct PendingPredicateObligation<'tcx> {\n     pub stalled_on: Vec<Ty<'tcx>>,\n }\n \n+/// An obligation which cannot be fulfilled in the context\n+/// it was registered in, such as auto trait obligations on\n+/// `impl Trait`, which require the concrete type to be\n+/// available, only guaranteed after finishing type-checking.\n+#[derive(Clone, Debug)]\n+pub struct DeferredObligation<'tcx> {\n+    pub predicate: ty::PolyTraitPredicate<'tcx>,\n+    pub cause: ObligationCause<'tcx>\n+}\n+\n+impl<'a, 'gcx, 'tcx> DeferredObligation<'tcx> {\n+    /// If possible, create a `DeferredObligation` from\n+    /// a trait predicate which had failed selection,\n+    /// but could succeed later.\n+    pub fn from_select_error(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                             obligation: &TraitObligation<'tcx>,\n+                             selection_err: &SelectionError<'tcx>)\n+                             -> Option<DeferredObligation<'tcx>> {\n+        if let Unimplemented = *selection_err {\n+            if DeferredObligation::must_defer(tcx, &obligation.predicate) {\n+                return Some(DeferredObligation {\n+                    predicate: obligation.predicate.clone(),\n+                    cause: obligation.cause.clone()\n+                });\n+            }\n+        }\n+\n+        None\n+    }\n+\n+    /// Returns true if the given trait predicate can be\n+    /// fulfilled at a later time.\n+    pub fn must_defer(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                      predicate: &ty::PolyTraitPredicate<'tcx>)\n+                      -> bool {\n+        // Auto trait obligations on `impl Trait`.\n+        if tcx.trait_has_default_impl(predicate.def_id()) {\n+            let substs = predicate.skip_binder().trait_ref.substs;\n+            if substs.types.as_slice().len() == 1 && substs.regions.is_empty() {\n+                if let ty::TyAnon(..) = predicate.skip_binder().self_ty().sty {\n+                    return true;\n+                }\n+            }\n+        }\n+\n+        false\n+    }\n+\n+    /// If possible, return the nested obligations required\n+    /// to fulfill this obligation.\n+    pub fn try_select(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>)\n+                      -> Option<Vec<PredicateObligation<'tcx>>> {\n+        if let ty::TyAnon(def_id, substs) = self.predicate.skip_binder().self_ty().sty {\n+            // We can resolve the `impl Trait` to its concrete type.\n+            if let Some(ty_scheme) = tcx.opt_lookup_item_type(def_id) {\n+                let concrete_ty = ty_scheme.ty.subst(tcx, substs);\n+                let concrete_substs = Substs::new_trait(vec![], vec![], concrete_ty);\n+                let predicate = ty::TraitRef {\n+                    def_id: self.predicate.def_id(),\n+                    substs: tcx.mk_substs(concrete_substs)\n+                }.to_predicate();\n+\n+                let original_obligation = Obligation::new(self.cause.clone(),\n+                                                          self.predicate.clone());\n+                let cause = original_obligation.derived_cause(BuiltinDerivedObligation);\n+                return Some(vec![Obligation::new(cause, predicate)]);\n+            }\n+        }\n+\n+        None\n+    }\n+\n+    /// Return the `PredicateObligation` this was created from.\n+    pub fn to_obligation(&self) -> PredicateObligation<'tcx> {\n+        let predicate = ty::Predicate::Trait(self.predicate.clone());\n+        Obligation::new(self.cause.clone(), predicate)\n+    }\n+\n+    /// Return an error as if this obligation had failed.\n+    pub fn to_error(&self) -> FulfillmentError<'tcx> {\n+        FulfillmentError::new(self.to_obligation(), CodeSelectionError(Unimplemented))\n+    }\n+}\n+\n impl<'a, 'gcx, 'tcx> FulfillmentContext<'tcx> {\n     /// Creates a new fulfillment context.\n     pub fn new() -> FulfillmentContext<'tcx> {\n         FulfillmentContext {\n             predicates: ObligationForest::new(),\n             rfc1592_obligations: Vec::new(),\n             region_obligations: NodeMap(),\n+            deferred_obligations: vec![],\n         }\n     }\n \n@@ -224,10 +314,16 @@ impl<'a, 'gcx, 'tcx> FulfillmentContext<'tcx> {\n     {\n         self.select_where_possible(infcx)?;\n \n+        // Fail all of the deferred obligations that haven't\n+        // been otherwise removed from the context.\n+        let deferred_errors = self.deferred_obligations.iter()\n+                                  .map(|d| d.to_error());\n+\n         let errors: Vec<_> =\n             self.predicates.to_errors(CodeAmbiguity)\n                            .into_iter()\n                            .map(|e| to_fulfillment_error(e))\n+                           .chain(deferred_errors)\n                            .collect();\n         if errors.is_empty() {\n             Ok(())\n@@ -248,6 +344,10 @@ impl<'a, 'gcx, 'tcx> FulfillmentContext<'tcx> {\n         self.predicates.pending_obligations()\n     }\n \n+    pub fn take_deferred_obligations(&mut self) -> Vec<DeferredObligation<'tcx>> {\n+        mem::replace(&mut self.deferred_obligations, vec![])\n+    }\n+\n     /// Attempts to select obligations using `selcx`. If `only_new_obligations` is true, then it\n     /// only attempts to select obligations that haven't been seen before.\n     fn select(&mut self, selcx: &mut SelectionContext<'a, 'gcx, 'tcx>)\n@@ -261,9 +361,10 @@ impl<'a, 'gcx, 'tcx> FulfillmentContext<'tcx> {\n \n             // Process pending obligations.\n             let outcome = self.predicates.process_obligations(&mut FulfillProcessor {\n-                    selcx: selcx,\n-                    region_obligations: &mut self.region_obligations,\n-                    rfc1592_obligations: &mut self.rfc1592_obligations\n+                selcx: selcx,\n+                region_obligations: &mut self.region_obligations,\n+                rfc1592_obligations: &mut self.rfc1592_obligations,\n+                deferred_obligations: &mut self.deferred_obligations\n             });\n             debug!(\"select: outcome={:?}\", outcome);\n \n@@ -298,7 +399,8 @@ impl<'a, 'gcx, 'tcx> FulfillmentContext<'tcx> {\n struct FulfillProcessor<'a, 'b: 'a, 'gcx: 'tcx, 'tcx: 'b> {\n     selcx: &'a mut SelectionContext<'b, 'gcx, 'tcx>,\n     region_obligations: &'a mut NodeMap<Vec<RegionObligation<'tcx>>>,\n-    rfc1592_obligations: &'a mut Vec<PredicateObligation<'tcx>>\n+    rfc1592_obligations: &'a mut Vec<PredicateObligation<'tcx>>,\n+    deferred_obligations: &'a mut Vec<DeferredObligation<'tcx>>\n }\n \n impl<'a, 'b, 'gcx, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'gcx, 'tcx> {\n@@ -312,7 +414,8 @@ impl<'a, 'b, 'gcx, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'gcx,\n         process_predicate(self.selcx,\n                           obligation,\n                           self.region_obligations,\n-                          self.rfc1592_obligations)\n+                          self.rfc1592_obligations,\n+                          self.deferred_obligations)\n             .map(|os| os.map(|os| os.into_iter().map(|o| PendingPredicateObligation {\n                 obligation: o,\n                 stalled_on: vec![]\n@@ -354,7 +457,8 @@ fn process_predicate<'a, 'gcx, 'tcx>(\n     selcx: &mut SelectionContext<'a, 'gcx, 'tcx>,\n     pending_obligation: &mut PendingPredicateObligation<'tcx>,\n     region_obligations: &mut NodeMap<Vec<RegionObligation<'tcx>>>,\n-    rfc1592_obligations: &mut Vec<PredicateObligation<'tcx>>)\n+    rfc1592_obligations: &mut Vec<PredicateObligation<'tcx>>,\n+    deferred_obligations: &mut Vec<DeferredObligation<'tcx>>)\n     -> Result<Option<Vec<PredicateObligation<'tcx>>>,\n               FulfillmentErrorCode<'tcx>>\n {\n@@ -422,7 +526,22 @@ fn process_predicate<'a, 'gcx, 'tcx>(\n                 Err(selection_err) => {\n                     info!(\"selecting trait `{:?}` at depth {} yielded Err\",\n                           data, obligation.recursion_depth);\n-                    Err(CodeSelectionError(selection_err))\n+\n+                    let defer = DeferredObligation::from_select_error(selcx.tcx(),\n+                                                                      &trait_obligation,\n+                                                                      &selection_err);\n+                    if let Some(deferred_obligation) = defer {\n+                        if let Some(nested) = deferred_obligation.try_select(selcx.tcx()) {\n+                            Ok(Some(nested))\n+                        } else {\n+                            // Pretend that the obligation succeeded,\n+                            // but record it for later.\n+                            deferred_obligations.push(deferred_obligation);\n+                            Ok(Some(vec![]))\n+                        }\n+                    } else {\n+                        Err(CodeSelectionError(selection_err))\n+                    }\n                 }\n             }\n         }\n@@ -629,6 +748,12 @@ impl<'a, 'gcx, 'tcx> GlobalFulfilledPredicates<'gcx> {\n             // already has the required read edges, so we don't need\n             // to add any more edges here.\n             if data.is_global() {\n+                // Don't cache predicates which were fulfilled\n+                // by deferring them for later fulfillment.\n+                if DeferredObligation::must_defer(tcx, data) {\n+                    return;\n+                }\n+\n                 if let Some(data) = tcx.lift_to_global(data) {\n                     if self.set.insert(data.clone()) {\n                         debug!(\"add_if_global: global predicate `{:?}` added\", data);"}, {"sha": "dc0807ba38faea39962ab3f576f55087a11f9223", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=f55ac6944a88d4da62b30a16cc95893ca050c328", "patch": "@@ -30,9 +30,10 @@ pub use self::coherence::orphan_check;\n pub use self::coherence::overlapping_impls;\n pub use self::coherence::OrphanCheckErr;\n pub use self::fulfill::{FulfillmentContext, GlobalFulfilledPredicates, RegionObligation};\n+pub use self::fulfill::DeferredObligation;\n pub use self::project::MismatchedProjectionTypes;\n pub use self::project::{normalize, normalize_projection_type, Normalized};\n-pub use self::project::{ProjectionCache, ProjectionCacheSnapshot, ProjectionMode};\n+pub use self::project::{ProjectionCache, ProjectionCacheSnapshot, Reveal};\n pub use self::object_safety::ObjectSafetyViolation;\n pub use self::object_safety::MethodViolationCode;\n pub use self::select::{EvaluationCache, SelectionContext, SelectionCache};\n@@ -435,7 +436,7 @@ pub fn normalize_param_env_or_error<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     let elaborated_env = unnormalized_env.with_caller_bounds(predicates);\n \n-    tcx.infer_ctxt(None, Some(elaborated_env), ProjectionMode::AnyFinal).enter(|infcx| {\n+    tcx.infer_ctxt(None, Some(elaborated_env), Reveal::NotSpecializable).enter(|infcx| {\n         let predicates = match fully_normalize(&infcx, cause,\n                                                &infcx.parameter_environment.caller_bounds) {\n             Ok(predicates) => predicates,"}, {"sha": "aed4f4393241191d1f2d655f2ba594a709d67b10", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 70, "deletions": 69, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=f55ac6944a88d4da62b30a16cc95893ca050c328", "patch": "@@ -38,7 +38,7 @@ use std::rc::Rc;\n /// Depending on the stage of compilation, we want projection to be\n /// more or less conservative.\n #[derive(Debug, Copy, Clone, PartialEq, Eq)]\n-pub enum ProjectionMode {\n+pub enum Reveal {\n     /// FIXME (#32205)\n     /// At coherence-checking time, we're still constructing the\n     /// specialization graph, and thus we only project\n@@ -67,7 +67,7 @@ pub enum ProjectionMode {\n     ///\n     /// The projection would succeed if `Output` had been defined\n     /// directly in the impl for `u8`.\n-    Topmost,\n+    ExactMatch,\n \n     /// At type-checking time, we refuse to project any associated\n     /// type that is marked `default`. Non-`default` (\"final\") types\n@@ -91,36 +91,22 @@ pub enum ProjectionMode {\n     /// fn main() {\n     ///     let <() as Assoc>::Output = true;\n     /// }\n-    AnyFinal,\n+    NotSpecializable,\n \n-    /// At trans time, all projections will succeed.\n-    Any,\n-}\n-\n-impl ProjectionMode {\n-    pub fn is_topmost(&self) -> bool {\n-        match *self {\n-            ProjectionMode::Topmost => true,\n-            _ => false,\n-        }\n-    }\n-\n-    pub fn is_any_final(&self) -> bool {\n-        match *self {\n-            ProjectionMode::AnyFinal => true,\n-            _ => false,\n-        }\n-    }\n-\n-    pub fn is_any(&self) -> bool {\n-        match *self {\n-            ProjectionMode::Any => true,\n-            _ => false,\n-        }\n-    }\n+    /// At trans time, all monomorphic projections will succeed.\n+    /// Also, `impl Trait` is normalized to the concrete type,\n+    /// which has to be already collected by type-checking.\n+    ///\n+    /// NOTE: As `impl Trait`'s concrete type should *never*\n+    /// be observable directly by the user, `Reveal::All`\n+    /// should not be used by checks which may expose\n+    /// type equality or type contents to the user.\n+    /// There are some exceptions, e.g. around OIBITS and\n+    /// transmute-checking, which expose some details, but\n+    /// not the whole concrete type of the `impl Trait`.\n+    All,\n }\n \n-\n pub type PolyProjectionObligation<'tcx> =\n     Obligation<'tcx, ty::PolyProjectionPredicate<'tcx>>;\n \n@@ -322,6 +308,17 @@ impl<'a, 'b, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for AssociatedTypeNormalizer<'a,\n \n         let ty = ty.super_fold_with(self);\n         match ty.sty {\n+            ty::TyAnon(def_id, substs) if !substs.has_escaping_regions() => { // (*)\n+                // Only normalize `impl Trait` after type-checking, usually in trans.\n+                if self.selcx.projection_mode() == Reveal::All {\n+                    let generic_ty = self.tcx().lookup_item_type(def_id).ty;\n+                    let concrete_ty = generic_ty.subst(self.tcx(), substs);\n+                    self.fold_ty(concrete_ty)\n+                } else {\n+                    ty\n+                }\n+            }\n+\n             ty::TyProjection(ref data) if !data.has_escaping_regions() => { // (*)\n \n                 // (*) This is kind of hacky -- we need to be able to\n@@ -797,8 +794,11 @@ fn assemble_candidates_from_trait_def<'cx, 'gcx, 'tcx>(\n     debug!(\"assemble_candidates_from_trait_def(..)\");\n \n     // Check whether the self-type is itself a projection.\n-    let trait_ref = match obligation_trait_ref.self_ty().sty {\n-        ty::TyProjection(ref data) => data.trait_ref.clone(),\n+    let (def_id, substs) = match obligation_trait_ref.self_ty().sty {\n+        ty::TyProjection(ref data) => {\n+            (data.trait_ref.def_id, data.trait_ref.substs)\n+        }\n+        ty::TyAnon(def_id, substs) => (def_id, substs),\n         ty::TyInfer(ty::TyVar(_)) => {\n             // If the self-type is an inference variable, then it MAY wind up\n             // being a projected type, so induce an ambiguity.\n@@ -809,8 +809,8 @@ fn assemble_candidates_from_trait_def<'cx, 'gcx, 'tcx>(\n     };\n \n     // If so, extract what we know from the trait and try to come up with a good answer.\n-    let trait_predicates = selcx.tcx().lookup_predicates(trait_ref.def_id);\n-    let bounds = trait_predicates.instantiate(selcx.tcx(), trait_ref.substs);\n+    let trait_predicates = selcx.tcx().lookup_predicates(def_id);\n+    let bounds = trait_predicates.instantiate(selcx.tcx(), substs);\n     let bounds = elaborate_predicates(selcx.tcx(), bounds.predicates.into_vec());\n     assemble_candidates_from_predicates(selcx,\n                                         obligation,\n@@ -902,7 +902,7 @@ fn assemble_candidates_from_impls<'cx, 'gcx, 'tcx>(\n \n                 candidate_set.vec.push(ProjectionTyCandidate::Select);\n             }\n-            super::VtableImpl(ref impl_data) if !selcx.projection_mode().is_any() => {\n+            super::VtableImpl(ref impl_data) => {\n                 // We have to be careful when projecting out of an\n                 // impl because of specialization. If we are not in\n                 // trans (i.e., projection mode is not \"any\"), and the\n@@ -926,37 +926,43 @@ fn assemble_candidates_from_impls<'cx, 'gcx, 'tcx>(\n                                                  impl_data.impl_def_id,\n                                                  obligation.predicate.item_name);\n                 let new_candidate = if let Some(node_item) = opt_node_item {\n-                    if node_item.node.is_from_trait() {\n-                        if node_item.item.ty.is_some() {\n-                            // The impl inherited a `type Foo =\n-                            // Bar` given in the trait, which is\n-                            // implicitly default. No candidate.\n-                            None\n-                        } else {\n-                            // The impl did not specify `type` and neither\n-                            // did the trait:\n-                            //\n-                            // ```rust\n-                            // trait Foo { type T; }\n-                            // impl Foo for Bar { }\n-                            // ```\n-                            //\n-                            // This is an error, but it will be\n-                            // reported in `check_impl_items_against_trait`.\n-                            // We accept it here but will flag it as\n-                            // an error when we confirm the candidate\n-                            // (which will ultimately lead to `normalize_to_error`\n-                            // being invoked).\n+                    let is_default = if node_item.node.is_from_trait() {\n+                        // If true, the impl inherited a `type Foo = Bar`\n+                        // given in the trait, which is implicitly default.\n+                        // Otherwise, the impl did not specify `type` and\n+                        // neither did the trait:\n+                        //\n+                        // ```rust\n+                        // trait Foo { type T; }\n+                        // impl Foo for Bar { }\n+                        // ```\n+                        //\n+                        // This is an error, but it will be\n+                        // reported in `check_impl_items_against_trait`.\n+                        // We accept it here but will flag it as\n+                        // an error when we confirm the candidate\n+                        // (which will ultimately lead to `normalize_to_error`\n+                        // being invoked).\n+                        node_item.item.ty.is_some()\n+                    } else {\n+                        node_item.item.defaultness.is_default()\n+                    };\n+\n+                    // Only reveal a specializable default if we're past type-checking\n+                    // and the obligations is monomorphic, otherwise passes such as\n+                    // transmute checking and polymorphic MIR optimizations could\n+                    // get a result which isn't correct for all monomorphizations.\n+                    if !is_default {\n+                        Some(ProjectionTyCandidate::Select)\n+                    } else if selcx.projection_mode() == Reveal::All {\n+                        assert!(!poly_trait_ref.needs_infer());\n+                        if !poly_trait_ref.needs_subst() {\n                             Some(ProjectionTyCandidate::Select)\n+                        } else {\n+                            None\n                         }\n-                    } else if node_item.item.defaultness.is_default() {\n-                        // The impl specified `default type Foo =\n-                        // Bar`. No candidate.\n-                        None\n                     } else {\n-                        // The impl specified `type Foo = Bar`\n-                        // with no default. Add a candidate.\n-                        Some(ProjectionTyCandidate::Select)\n+                        None\n                     }\n                 } else {\n                     // This is saying that neither the trait nor\n@@ -1006,11 +1012,6 @@ fn assemble_candidates_from_impls<'cx, 'gcx, 'tcx>(\n                 };\n                 candidate_set.vec.extend(new_candidate);\n             }\n-            super::VtableImpl(_) => {\n-                // In trans mode, we can just project out of impls, no prob.\n-                assert!(selcx.projection_mode().is_any());\n-                candidate_set.vec.push(ProjectionTyCandidate::Select);\n-            }\n             super::VtableParam(..) => {\n                 // This case tell us nothing about the value of an\n                 // associated type. Consider:\n@@ -1332,7 +1333,7 @@ fn confirm_impl_candidate<'cx, 'gcx, 'tcx>(\n /// starting from the given impl.\n ///\n /// Based on the \"projection mode\", this lookup may in fact only examine the\n-/// topmost impl. See the comments for `ProjectionMode` for more details.\n+/// topmost impl. See the comments for `Reveal` for more details.\n fn assoc_ty_def<'cx, 'gcx, 'tcx>(\n     selcx: &SelectionContext<'cx, 'gcx, 'tcx>,\n     impl_def_id: DefId,\n@@ -1341,7 +1342,7 @@ fn assoc_ty_def<'cx, 'gcx, 'tcx>(\n {\n     let trait_def_id = selcx.tcx().impl_trait_ref(impl_def_id).unwrap().def_id;\n \n-    if selcx.projection_mode().is_topmost() {\n+    if selcx.projection_mode() == Reveal::ExactMatch {\n         let impl_node = specialization_graph::Node::Impl(impl_def_id);\n         for item in impl_node.items(selcx.tcx()) {\n             if let ty::TypeTraitItem(assoc_ty) = item {"}, {"sha": "2df492e507bdcd5ea0b7757370201b18a997206c", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 38, "deletions": 34, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=f55ac6944a88d4da62b30a16cc95893ca050c328", "patch": "@@ -23,7 +23,7 @@ use super::{PredicateObligation, TraitObligation, ObligationCause};\n use super::{ObligationCauseCode, BuiltinDerivedObligation, ImplDerivedObligation};\n use super::{SelectionError, Unimplemented, OutputTypeParameterMismatch};\n use super::{ObjectCastObligation, Obligation};\n-use super::ProjectionMode;\n+use super::Reveal;\n use super::TraitNotObjectSafe;\n use super::Selection;\n use super::SelectionResult;\n@@ -343,7 +343,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         self.infcx\n     }\n \n-    pub fn projection_mode(&self) -> ProjectionMode {\n+    pub fn projection_mode(&self) -> Reveal {\n         self.infcx.projection_mode()\n     }\n \n@@ -1158,20 +1158,17 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n \n         // before we go into the whole skolemization thing, just\n         // quickly check if the self-type is a projection at all.\n-        let trait_def_id = match obligation.predicate.0.trait_ref.self_ty().sty {\n-            ty::TyProjection(ref data) => data.trait_ref.def_id,\n+        match obligation.predicate.0.trait_ref.self_ty().sty {\n+            ty::TyProjection(_) | ty::TyAnon(..) => {}\n             ty::TyInfer(ty::TyVar(_)) => {\n                 span_bug!(obligation.cause.span,\n                     \"Self=_ should have been handled by assemble_candidates\");\n             }\n-            _ => { return; }\n-        };\n-\n-        debug!(\"assemble_candidates_for_projected_tys: trait_def_id={:?}\",\n-               trait_def_id);\n+            _ => return\n+        }\n \n         let result = self.probe(|this, snapshot| {\n-            this.match_projection_obligation_against_bounds_from_trait(obligation,\n+            this.match_projection_obligation_against_definition_bounds(obligation,\n                                                                        snapshot)\n         });\n \n@@ -1180,7 +1177,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn match_projection_obligation_against_bounds_from_trait(\n+    fn match_projection_obligation_against_definition_bounds(\n         &mut self,\n         obligation: &TraitObligation<'tcx>,\n         snapshot: &infer::CombinedSnapshot)\n@@ -1190,28 +1187,29 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             self.infcx().resolve_type_vars_if_possible(&obligation.predicate);\n         let (skol_trait_predicate, skol_map) =\n             self.infcx().skolemize_late_bound_regions(&poly_trait_predicate, snapshot);\n-        debug!(\"match_projection_obligation_against_bounds_from_trait: \\\n+        debug!(\"match_projection_obligation_against_definition_bounds: \\\n                 skol_trait_predicate={:?} skol_map={:?}\",\n                skol_trait_predicate,\n                skol_map);\n \n-        let projection_trait_ref = match skol_trait_predicate.trait_ref.self_ty().sty {\n-            ty::TyProjection(ref data) => &data.trait_ref,\n+        let (def_id, substs) = match skol_trait_predicate.trait_ref.self_ty().sty {\n+            ty::TyProjection(ref data) => (data.trait_ref.def_id, data.trait_ref.substs),\n+            ty::TyAnon(def_id, substs) => (def_id, substs),\n             _ => {\n                 span_bug!(\n                     obligation.cause.span,\n-                    \"match_projection_obligation_against_bounds_from_trait() called \\\n+                    \"match_projection_obligation_against_definition_bounds() called \\\n                      but self-ty not a projection: {:?}\",\n                     skol_trait_predicate.trait_ref.self_ty());\n             }\n         };\n-        debug!(\"match_projection_obligation_against_bounds_from_trait: \\\n-                projection_trait_ref={:?}\",\n-               projection_trait_ref);\n+        debug!(\"match_projection_obligation_against_definition_bounds: \\\n+                def_id={:?}, substs={:?}\",\n+               def_id, substs);\n \n-        let trait_predicates = self.tcx().lookup_predicates(projection_trait_ref.def_id);\n-        let bounds = trait_predicates.instantiate(self.tcx(), projection_trait_ref.substs);\n-        debug!(\"match_projection_obligation_against_bounds_from_trait: \\\n+        let item_predicates = self.tcx().lookup_predicates(def_id);\n+        let bounds = item_predicates.instantiate(self.tcx(), substs);\n+        debug!(\"match_projection_obligation_against_definition_bounds: \\\n                 bounds={:?}\",\n                bounds);\n \n@@ -1226,7 +1224,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                                                     &skol_map,\n                                                     snapshot)));\n \n-        debug!(\"match_projection_obligation_against_bounds_from_trait: \\\n+        debug!(\"match_projection_obligation_against_definition_bounds: \\\n                 matching_bound={:?}\",\n                matching_bound);\n         match matching_bound {\n@@ -1472,7 +1470,8 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                     }\n                 }\n                 ty::TyParam(..) |\n-                ty::TyProjection(..) => {\n+                ty::TyProjection(..) |\n+                ty::TyAnon(..) => {\n                     // In these cases, we don't know what the actual\n                     // type is.  Therefore, we cannot break it down\n                     // into its constituent types. So we don't\n@@ -1796,7 +1795,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 }))\n             }\n \n-            ty::TyProjection(_) | ty::TyParam(_) => None,\n+            ty::TyProjection(_) | ty::TyParam(_) | ty::TyAnon(..) => None,\n             ty::TyInfer(ty::TyVar(_)) => Ambiguous,\n \n             ty::TyInfer(ty::FreshTy(_))\n@@ -1842,7 +1841,8 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 Where(ty::Binder(tys.to_vec()))\n             }\n \n-            ty::TyStruct(..) | ty::TyEnum(..) | ty::TyProjection(..) | ty::TyParam(..) => {\n+            ty::TyStruct(..) | ty::TyEnum(..) |\n+            ty::TyProjection(..) | ty::TyParam(..) | ty::TyAnon(..) => {\n                 // Fallback to whatever user-defined impls exist in this case.\n                 None\n             }\n@@ -1893,6 +1893,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             ty::TyTrait(..) |\n             ty::TyParam(..) |\n             ty::TyProjection(..) |\n+            ty::TyAnon(..) |\n             ty::TyInfer(ty::TyVar(_)) |\n             ty::TyInfer(ty::FreshTy(_)) |\n             ty::TyInfer(ty::FreshIntTy(_)) |\n@@ -2073,7 +2074,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     {\n         self.in_snapshot(|this, snapshot| {\n             let result =\n-                this.match_projection_obligation_against_bounds_from_trait(obligation,\n+                this.match_projection_obligation_against_definition_bounds(obligation,\n                                                                            snapshot);\n             assert!(result);\n         })\n@@ -2127,7 +2128,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                           obligation)\n             };\n \n-            let cause = self.derived_cause(obligation, BuiltinDerivedObligation);\n+            let cause = obligation.derived_cause(BuiltinDerivedObligation);\n             self.collect_predicates_for_types(cause,\n                                               obligation.recursion_depth+1,\n                                               trait_def,\n@@ -2207,7 +2208,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n     {\n         debug!(\"vtable_default_impl: nested={:?}\", nested);\n \n-        let cause = self.derived_cause(obligation, BuiltinDerivedObligation);\n+        let cause = obligation.derived_cause(BuiltinDerivedObligation);\n         let mut obligations = self.collect_predicates_for_types(\n             cause,\n             obligation.recursion_depth+1,\n@@ -2218,7 +2219,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             let poly_trait_ref = obligation.predicate.to_poly_trait_ref();\n             let (trait_ref, skol_map) =\n                 this.infcx().skolemize_late_bound_regions(&poly_trait_ref, snapshot);\n-            let cause = this.derived_cause(obligation, ImplDerivedObligation);\n+            let cause = obligation.derived_cause(ImplDerivedObligation);\n             this.impl_or_trait_obligations(cause,\n                                            obligation.recursion_depth + 1,\n                                            trait_def_id,\n@@ -2253,7 +2254,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 this.rematch_impl(impl_def_id, obligation,\n                                   snapshot);\n             debug!(\"confirm_impl_candidate substs={:?}\", substs);\n-            let cause = this.derived_cause(obligation, ImplDerivedObligation);\n+            let cause = obligation.derived_cause(ImplDerivedObligation);\n             this.vtable_impl(impl_def_id, substs, cause,\n                              obligation.recursion_depth + 1,\n                              skol_map, snapshot)\n@@ -2906,12 +2907,13 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             }).collect();\n         self.infcx().plug_leaks(skol_map, snapshot, &predicates)\n     }\n+}\n \n+impl<'tcx> TraitObligation<'tcx> {\n     #[allow(unused_comparisons)]\n-    fn derived_cause(&self,\n-                     obligation: &TraitObligation<'tcx>,\n-                     variant: fn(DerivedObligationCause<'tcx>) -> ObligationCauseCode<'tcx>)\n-                     -> ObligationCause<'tcx>\n+    pub fn derived_cause(&self,\n+                        variant: fn(DerivedObligationCause<'tcx>) -> ObligationCauseCode<'tcx>)\n+                        -> ObligationCause<'tcx>\n     {\n         /*!\n          * Creates a cause for obligations that are derived from\n@@ -2923,6 +2925,8 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n          * reporting.\n          */\n \n+        let obligation = self;\n+\n         // NOTE(flaper87): As of now, it keeps track of the whole error\n         // chain. Ideally, we should have a way to configure this either\n         // by using -Z verbose or just a CLI argument."}, {"sha": "38cccb9753df60ba69e80e83586a84656c06a534", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=f55ac6944a88d4da62b30a16cc95893ca050c328", "patch": "@@ -25,7 +25,7 @@ use hir::def_id::DefId;\n use infer::{InferCtxt, TypeOrigin};\n use middle::region;\n use ty::subst::{Subst, Substs};\n-use traits::{self, ProjectionMode, ObligationCause, Normalized};\n+use traits::{self, Reveal, ObligationCause, Normalized};\n use ty::{self, TyCtxt};\n use syntax_pos::DUMMY_SP;\n \n@@ -151,7 +151,7 @@ pub fn specializes<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                              .unwrap()\n                              .subst(tcx, &penv.free_substs);\n \n-    let result = tcx.normalizing_infer_ctxt(ProjectionMode::Topmost).enter(|mut infcx| {\n+    let result = tcx.normalizing_infer_ctxt(Reveal::ExactMatch).enter(|mut infcx| {\n         // Normalize the trait reference, adding any obligations\n         // that arise into the impl1 assumptions.\n         let Normalized { value: impl1_trait_ref, obligations: normalization_obligations } = {"}, {"sha": "a47cd23c64aa6f7145868c142a50f6af542b8a8f", "filename": "src/librustc/traits/specialize/specialization_graph.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=f55ac6944a88d4da62b30a16cc95893ca050c328", "patch": "@@ -14,7 +14,7 @@ use std::rc::Rc;\n use super::{OverlapError, specializes};\n \n use hir::def_id::DefId;\n-use traits::{self, ProjectionMode};\n+use traits::{self, Reveal};\n use ty::{self, TyCtxt, ImplOrTraitItem, TraitDef, TypeFoldable};\n use ty::fast_reject::{self, SimplifiedType};\n use syntax::ast::Name;\n@@ -111,8 +111,7 @@ impl<'a, 'gcx, 'tcx> Children {\n             let possible_sibling = *slot;\n \n             let tcx = tcx.global_tcx();\n-            let (le, ge) = tcx.infer_ctxt(None, None,\n-                                          ProjectionMode::Topmost).enter(|infcx| {\n+            let (le, ge) = tcx.infer_ctxt(None, None, Reveal::ExactMatch).enter(|infcx| {\n                 let overlap = traits::overlapping_impls(&infcx,\n                                                         possible_sibling,\n                                                         impl_def_id);"}, {"sha": "022566642f646720f467a417e9349fc43a6d010c", "filename": "src/librustc/traits/structural_impls.rs", "status": "modified", "additions": 181, "deletions": 0, "changes": 181, "blob_url": "https://github.com/rust-lang/rust/blob/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs?ref=f55ac6944a88d4da62b30a16cc95893ca050c328", "patch": "@@ -14,6 +14,7 @@ use ty::{Lift, TyCtxt};\n use ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n \n use std::fmt;\n+use std::rc::Rc;\n \n // structural impls for the structs in traits\n \n@@ -162,6 +163,86 @@ impl<'a, 'tcx> Lift<'tcx> for traits::SelectionError<'a> {\n     }\n }\n \n+impl<'a, 'tcx> Lift<'tcx> for traits::ObligationCauseCode<'a> {\n+    type Lifted = traits::ObligationCauseCode<'tcx>;\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+        match *self {\n+            super::MiscObligation => Some(super::MiscObligation),\n+            super::SliceOrArrayElem => Some(super::SliceOrArrayElem),\n+            super::TupleElem => Some(super::TupleElem),\n+            super::ProjectionWf(proj) => tcx.lift(&proj).map(super::ProjectionWf),\n+            super::ItemObligation(def_id) => Some(super::ItemObligation(def_id)),\n+            super::ReferenceOutlivesReferent(ty) => {\n+                tcx.lift(&ty).map(super::ReferenceOutlivesReferent)\n+            }\n+            super::ObjectCastObligation(ty) => {\n+                tcx.lift(&ty).map(super::ObjectCastObligation)\n+            }\n+            super::AssignmentLhsSized => Some(super::AssignmentLhsSized),\n+            super::StructInitializerSized => Some(super::StructInitializerSized),\n+            super::VariableType(id) => Some(super::VariableType(id)),\n+            super::ReturnType => Some(super::ReturnType),\n+            super::RepeatVec => Some(super::RepeatVec),\n+            super::ClosureCapture(node_id, span, bound) => {\n+                Some(super::ClosureCapture(node_id, span, bound))\n+            }\n+            super::FieldSized => Some(super::FieldSized),\n+            super::ConstSized => Some(super::ConstSized),\n+            super::SharedStatic => Some(super::SharedStatic),\n+            super::BuiltinDerivedObligation(ref cause) => {\n+                tcx.lift(cause).map(super::BuiltinDerivedObligation)\n+            }\n+            super::ImplDerivedObligation(ref cause) => {\n+                tcx.lift(cause).map(super::ImplDerivedObligation)\n+            }\n+            super::CompareImplMethodObligation => {\n+                Some(super::CompareImplMethodObligation)\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> Lift<'tcx> for traits::DerivedObligationCause<'a> {\n+    type Lifted = traits::DerivedObligationCause<'tcx>;\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+        tcx.lift(&self.parent_trait_ref).and_then(|trait_ref| {\n+            tcx.lift(&*self.parent_code).map(|code| {\n+                traits::DerivedObligationCause {\n+                    parent_trait_ref: trait_ref,\n+                    parent_code: Rc::new(code)\n+                }\n+            })\n+        })\n+    }\n+}\n+\n+impl<'a, 'tcx> Lift<'tcx> for traits::ObligationCause<'a> {\n+    type Lifted = traits::ObligationCause<'tcx>;\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+        tcx.lift(&self.code).map(|code| {\n+            traits::ObligationCause {\n+                span: self.span,\n+                body_id: self.body_id,\n+                code: code,\n+            }\n+        })\n+    }\n+}\n+\n+impl<'a, 'tcx> Lift<'tcx> for traits::DeferredObligation<'a> {\n+    type Lifted = traits::DeferredObligation<'tcx>;\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+        tcx.lift(&self.predicate).and_then(|predicate| {\n+            tcx.lift(&self.cause).map(|cause| {\n+                traits::DeferredObligation {\n+                    predicate: predicate,\n+                    cause: cause\n+                }\n+            })\n+        })\n+    }\n+}\n+\n // For trans only.\n impl<'a, 'tcx> Lift<'tcx> for traits::Vtable<'a, ()> {\n     type Lifted = traits::Vtable<'tcx, ()>;\n@@ -361,3 +442,103 @@ impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Normalized<'tcx, T> {\n         self.value.visit_with(visitor) || self.obligations.visit_with(visitor)\n     }\n }\n+\n+impl<'tcx> TypeFoldable<'tcx> for traits::ObligationCauseCode<'tcx> {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+        match *self {\n+            super::MiscObligation |\n+            super::SliceOrArrayElem |\n+            super::TupleElem |\n+            super::ItemObligation(_) |\n+            super::AssignmentLhsSized |\n+            super::StructInitializerSized |\n+            super::VariableType(_) |\n+            super::ReturnType |\n+            super::RepeatVec |\n+            super::ClosureCapture(..) |\n+            super::FieldSized |\n+            super::ConstSized |\n+            super::SharedStatic |\n+            super::CompareImplMethodObligation => self.clone(),\n+\n+            super::ProjectionWf(proj) => super::ProjectionWf(proj.fold_with(folder)),\n+            super::ReferenceOutlivesReferent(ty) => {\n+                super::ReferenceOutlivesReferent(ty.fold_with(folder))\n+            }\n+            super::ObjectCastObligation(ty) => {\n+                super::ObjectCastObligation(ty.fold_with(folder))\n+            }\n+            super::BuiltinDerivedObligation(ref cause) => {\n+                super::BuiltinDerivedObligation(cause.fold_with(folder))\n+            }\n+            super::ImplDerivedObligation(ref cause) => {\n+                super::ImplDerivedObligation(cause.fold_with(folder))\n+            }\n+        }\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        match *self {\n+            super::MiscObligation |\n+            super::SliceOrArrayElem |\n+            super::TupleElem |\n+            super::ItemObligation(_) |\n+            super::AssignmentLhsSized |\n+            super::StructInitializerSized |\n+            super::VariableType(_) |\n+            super::ReturnType |\n+            super::RepeatVec |\n+            super::ClosureCapture(..) |\n+            super::FieldSized |\n+            super::ConstSized |\n+            super::SharedStatic |\n+            super::CompareImplMethodObligation => false,\n+\n+            super::ProjectionWf(proj) => proj.visit_with(visitor),\n+            super::ReferenceOutlivesReferent(ty) => ty.visit_with(visitor),\n+            super::ObjectCastObligation(ty) => ty.visit_with(visitor),\n+            super::BuiltinDerivedObligation(ref cause) => cause.visit_with(visitor),\n+            super::ImplDerivedObligation(ref cause) => cause.visit_with(visitor)\n+        }\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for traits::DerivedObligationCause<'tcx> {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+        traits::DerivedObligationCause {\n+            parent_trait_ref: self.parent_trait_ref.fold_with(folder),\n+            parent_code: self.parent_code.fold_with(folder)\n+        }\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        self.parent_trait_ref.visit_with(visitor) || self.parent_code.visit_with(visitor)\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for traits::ObligationCause<'tcx> {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+        traits::ObligationCause {\n+            span: self.span,\n+            body_id: self.body_id,\n+            code: self.code.fold_with(folder),\n+        }\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        self.code.visit_with(visitor)\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for traits::DeferredObligation<'tcx> {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+        traits::DeferredObligation {\n+            predicate: self.predicate.fold_with(folder),\n+            cause: self.cause.fold_with(folder)\n+        }\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        self.predicate.visit_with(visitor) || self.cause.visit_with(visitor)\n+    }\n+}"}, {"sha": "8da7568c558a70b6d16b7fbcc8854122fd02c983", "filename": "src/librustc/ty/contents.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc%2Fty%2Fcontents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc%2Fty%2Fcontents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontents.rs?ref=f55ac6944a88d4da62b30a16cc95893ca050c328", "patch": "@@ -240,7 +240,8 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n                 }\n \n                 ty::TyProjection(..) |\n-                ty::TyParam(_) => {\n+                ty::TyParam(_) |\n+                ty::TyAnon(..) => {\n                     TC::All\n                 }\n "}, {"sha": "13401e91265eb9ac8db3f4ae39490b01ec67d0fd", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=f55ac6944a88d4da62b30a16cc95893ca050c328", "patch": "@@ -1016,7 +1016,7 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n         sty_debug_print!(\n             self,\n             TyEnum, TyBox, TyArray, TySlice, TyRawPtr, TyRef, TyFnDef, TyFnPtr,\n-            TyTrait, TyStruct, TyClosure, TyTuple, TyParam, TyInfer, TyProjection);\n+            TyTrait, TyStruct, TyClosure, TyTuple, TyParam, TyInfer, TyProjection, TyAnon);\n \n         println!(\"Substs interner: #{}\", self.interners.substs.borrow().len());\n         println!(\"BareFnTy interner: #{}\", self.interners.bare_fn.borrow().len());\n@@ -1355,6 +1355,10 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.mk_param(def.space, def.index, def.name)\n     }\n \n+    pub fn mk_anon(self, def_id: DefId, substs: &'tcx Substs<'tcx>) -> Ty<'tcx> {\n+        self.mk_ty(TyAnon(def_id, substs))\n+    }\n+\n     pub fn trait_items(self, trait_did: DefId) -> Rc<Vec<ty::ImplOrTraitItem<'gcx>>> {\n         self.trait_items_cache.memoize(trait_did, || {\n             let def_ids = self.trait_item_def_ids(trait_did);"}, {"sha": "66165ec6ff7d06aa179c4c7c5279aa4daadd51ae", "filename": "src/librustc/ty/error.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ferror.rs?ref=f55ac6944a88d4da62b30a16cc95893ca050c328", "patch": "@@ -247,6 +247,7 @@ impl<'a, 'gcx, 'lcx, 'tcx> ty::TyS<'tcx> {\n                     \"type parameter\".to_string()\n                 }\n             }\n+            ty::TyAnon(..) => \"anonymized type\".to_string(),\n             ty::TyError => \"type error\".to_string(),\n         }\n     }"}, {"sha": "e6f2ba8b650f1c77851ceb6c3eeaaeee93489295", "filename": "src/librustc/ty/fast_reject.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc%2Fty%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc%2Fty%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffast_reject.rs?ref=f55ac6944a88d4da62b30a16cc95893ca050c328", "patch": "@@ -30,6 +30,7 @@ pub enum SimplifiedType {\n     TraitSimplifiedType(DefId),\n     StructSimplifiedType(DefId),\n     ClosureSimplifiedType(DefId),\n+    AnonSimplifiedType(DefId),\n     FunctionSimplifiedType(usize),\n     ParameterSimplifiedType,\n }\n@@ -98,6 +99,9 @@ pub fn simplify_type<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                 None\n             }\n         }\n+        ty::TyAnon(def_id, _) => {\n+            Some(AnonSimplifiedType(def_id))\n+        }\n         ty::TyInfer(_) | ty::TyError => None,\n     }\n }"}, {"sha": "85b7d66a2eb085e8a1740d66d87387479277f602", "filename": "src/librustc/ty/flags.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fflags.rs?ref=f55ac6944a88d4da62b30a16cc95893ca050c328", "patch": "@@ -110,6 +110,11 @@ impl FlagComputation {\n                 self.add_projection_ty(data);\n             }\n \n+            &ty::TyAnon(_, substs) => {\n+                self.add_flags(TypeFlags::HAS_PROJECTION);\n+                self.add_substs(substs);\n+            }\n+\n             &ty::TyTrait(box ty::TraitTy { ref principal, ref bounds }) => {\n                 let mut computation = FlagComputation::new();\n                 computation.add_substs(principal.0.substs);"}, {"sha": "3580013c2a9129aa973bf308a31b5bded98fb2a2", "filename": "src/librustc/ty/fold.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffold.rs?ref=f55ac6944a88d4da62b30a16cc95893ca050c328", "patch": "@@ -695,7 +695,7 @@ impl<'tcx> TypeVisitor<'tcx> for LateBoundRegionsCollector {\n         // in the normalized form\n         if self.just_constrained {\n             match t.sty {\n-                ty::TyProjection(..) => { return false; }\n+                ty::TyProjection(..) | ty::TyAnon(..) => { return false; }\n                 _ => { }\n             }\n         }"}, {"sha": "bfe6303d8a328a7bf8793d78a0c9a95853475a72", "filename": "src/librustc/ty/item_path.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc%2Fty%2Fitem_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc%2Fty%2Fitem_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fitem_path.rs?ref=f55ac6944a88d4da62b30a16cc95893ca050c328", "patch": "@@ -188,7 +188,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             data @ DefPathData::Initializer |\n             data @ DefPathData::MacroDef(..) |\n             data @ DefPathData::ClosureExpr |\n-            data @ DefPathData::Binding(..) => {\n+            data @ DefPathData::Binding(..) |\n+            data @ DefPathData::ImplTrait => {\n                 let parent_def_id = self.parent_def_id(def_id).unwrap();\n                 self.push_item_path(buffer, parent_def_id);\n                 buffer.push(&data.as_interned_str());\n@@ -345,6 +346,7 @@ pub fn characteristic_def_id_of_type(ty: Ty) -> Option<DefId> {\n         ty::TyFnPtr(_) |\n         ty::TyProjection(_) |\n         ty::TyParam(_) |\n+        ty::TyAnon(..) |\n         ty::TyInfer(_) |\n         ty::TyError |\n         ty::TyFloat(_) => None,"}, {"sha": "d73e412f55f267c7b1e40d5c18ccb5890aa209ff", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 42, "deletions": 24, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=f55ac6944a88d4da62b30a16cc95893ca050c328", "patch": "@@ -558,8 +558,7 @@ impl<'a, 'gcx, 'tcx> Struct {\n             (&Univariant { non_zero: true, .. }, &ty::TyStruct(def, substs)) => {\n                 let fields = &def.struct_variant().fields;\n                 assert_eq!(fields.len(), 1);\n-                let ty = normalize_associated_type(infcx, fields[0].ty(tcx, substs));\n-                match *ty.layout(infcx)? {\n+                match *fields[0].ty(tcx, substs).layout(infcx)? {\n                     // FIXME(eddyb) also allow floating-point types here.\n                     Scalar { value: Int(_), non_zero: false } |\n                     Scalar { value: Pointer, non_zero: false } => {\n@@ -577,7 +576,7 @@ impl<'a, 'gcx, 'tcx> Struct {\n             (_, &ty::TyStruct(def, substs)) => {\n                 Struct::non_zero_field_path(infcx, def.struct_variant().fields\n                                                       .iter().map(|field| {\n-                    normalize_associated_type(infcx, field.ty(tcx, substs))\n+                    field.ty(tcx, substs)\n                 }))\n             }\n \n@@ -595,6 +594,14 @@ impl<'a, 'gcx, 'tcx> Struct {\n                 Struct::non_zero_field_path(infcx, Some(ety).into_iter())\n             }\n \n+            (_, &ty::TyProjection(_)) | (_, &ty::TyAnon(..)) => {\n+                let normalized = normalize_associated_type(infcx, ty);\n+                if ty == normalized {\n+                    return Ok(None);\n+                }\n+                return Struct::non_zero_field_in_type(infcx, normalized);\n+            }\n+\n             // Anything else is not a non-zero type.\n             _ => Ok(None)\n         }\n@@ -762,8 +769,9 @@ fn normalize_associated_type<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n impl<'a, 'gcx, 'tcx> Layout {\n     pub fn compute_uncached(ty: Ty<'gcx>,\n                             infcx: &InferCtxt<'a, 'gcx, 'tcx>)\n-                            -> Result<Layout, LayoutError<'gcx>> {\n+                            -> Result<&'gcx Layout, LayoutError<'gcx>> {\n         let tcx = infcx.tcx.global_tcx();\n+        let success = |layout| Ok(tcx.intern_layout(layout));\n         let dl = &tcx.data_layout;\n         assert!(!ty.has_infer_types());\n \n@@ -795,6 +803,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n                 if pointee.is_sized(tcx, &infcx.parameter_environment, DUMMY_SP) {\n                     Scalar { value: Pointer, non_zero: non_zero }\n                 } else {\n+                    let pointee = normalize_associated_type(infcx, pointee);\n                     let unsized_part = tcx.struct_tail(pointee);\n                     let meta = match unsized_part.sty {\n                         ty::TySlice(_) | ty::TyStr => {\n@@ -860,7 +869,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n                     let element = ty.simd_type(tcx);\n                     match *element.layout(infcx)? {\n                         Scalar { value, .. } => {\n-                            return Ok(Vector {\n+                            return success(Vector {\n                                 element: value,\n                                 count: ty.simd_size(tcx) as u64\n                             });\n@@ -873,8 +882,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n                     }\n                 }\n                 let fields = def.struct_variant().fields.iter().map(|field| {\n-                    normalize_associated_type(infcx, field.ty(tcx, substs))\n-                        .layout(infcx)\n+                    field.ty(tcx, substs).layout(infcx)\n                 });\n                 let packed = tcx.lookup_packed(def.did);\n                 let mut st = Struct::new(dl, packed);\n@@ -914,7 +922,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n \n                     let mut st = Struct::new(dl, false);\n                     st.extend(dl, drop_flag.iter().map(Ok), ty)?;\n-                    return Ok(Univariant { variant: st, non_zero: false });\n+                    return success(Univariant { variant: st, non_zero: false });\n                 }\n \n                 if !dtor && def.variants.iter().all(|v| v.fields.is_empty()) {\n@@ -927,7 +935,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n                     }\n \n                     let (discr, signed) = Integer::repr_discr(tcx, hint, min, max);\n-                    return Ok(CEnum {\n+                    return success(CEnum {\n                         discr: discr,\n                         signed: signed,\n                         min: min as u64,\n@@ -950,19 +958,16 @@ impl<'a, 'gcx, 'tcx> Layout {\n                     // (Typechecking will reject discriminant-sizing attrs.)\n                     assert_eq!(hint, attr::ReprAny);\n                     let fields = def.variants[0].fields.iter().map(|field| {\n-                        normalize_associated_type(infcx, field.ty(tcx, substs))\n-                            .layout(infcx)\n+                        field.ty(tcx, substs).layout(infcx)\n                     });\n                     let mut st = Struct::new(dl, false);\n                     st.extend(dl, fields.chain(drop_flag.iter().map(Ok)), ty)?;\n-                    return Ok(Univariant { variant: st, non_zero: false });\n+                    return success(Univariant { variant: st, non_zero: false });\n                 }\n \n                 // Cache the substituted and normalized variant field types.\n                 let variants = def.variants.iter().map(|v| {\n-                    v.fields.iter().map(|field| {\n-                        normalize_associated_type(infcx, field.ty(tcx, substs))\n-                    }).collect::<Vec<_>>()\n+                    v.fields.iter().map(|field| field.ty(tcx, substs)).collect::<Vec<_>>()\n                 }).collect::<Vec<_>>();\n \n                 if !dtor && variants.len() == 2 && hint == attr::ReprAny {\n@@ -982,7 +987,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n                         if path == &[0] && variants[discr].len() == 1 {\n                             match *variants[discr][0].layout(infcx)? {\n                                 Scalar { value, .. } => {\n-                                    return Ok(RawNullablePointer {\n+                                    return success(RawNullablePointer {\n                                         nndiscr: discr as u64,\n                                         value: value\n                                     });\n@@ -998,10 +1003,8 @@ impl<'a, 'gcx, 'tcx> Layout {\n                         path.push(0); // For GEP through a pointer.\n                         path.reverse();\n                         let mut st = Struct::new(dl, false);\n-                        st.extend(dl, variants[discr].iter().map(|ty| {\n-                            ty.layout(infcx)\n-                        }), ty)?;\n-                        return Ok(StructWrappedNullablePointer {\n+                        st.extend(dl, variants[discr].iter().map(|ty| ty.layout(infcx)), ty)?;\n+                        return success(StructWrappedNullablePointer {\n                             nndiscr: discr as u64,\n                             nonnull: st,\n                             discrfield: path\n@@ -1105,15 +1108,22 @@ impl<'a, 'gcx, 'tcx> Layout {\n             }\n \n             // Types with no meaningful known layout.\n-            ty::TyProjection(_) | ty::TyParam(_) => {\n+            ty::TyProjection(_) | ty::TyAnon(..) => {\n+                let normalized = normalize_associated_type(infcx, ty);\n+                if ty == normalized {\n+                    return Err(LayoutError::Unknown(ty));\n+                }\n+                return normalized.layout(infcx);\n+            }\n+            ty::TyParam(_) => {\n                 return Err(LayoutError::Unknown(ty));\n             }\n             ty::TyInfer(_) | ty::TyError => {\n                 bug!(\"Layout::compute: unexpected type `{}`\", ty)\n             }\n         };\n \n-        Ok(layout)\n+        success(layout)\n     }\n \n     /// Returns true if the layout corresponds to an unsized type.\n@@ -1272,8 +1282,7 @@ impl<'a, 'gcx, 'tcx> SizeSkeleton<'gcx> {\n                 // Get a zero-sized variant or a pointer newtype.\n                 let zero_or_ptr_variant = |i: usize| {\n                     let fields = def.variants[i].fields.iter().map(|field| {\n-                        let ty = normalize_associated_type(infcx, &field.ty(tcx, substs));\n-                        SizeSkeleton::compute(ty, infcx)\n+                        SizeSkeleton::compute(field.ty(tcx, substs), infcx)\n                     });\n                     let mut ptr = None;\n                     for field in fields {\n@@ -1323,6 +1332,15 @@ impl<'a, 'gcx, 'tcx> SizeSkeleton<'gcx> {\n                 }\n             }\n \n+            ty::TyProjection(_) | ty::TyAnon(..) => {\n+                let normalized = normalize_associated_type(infcx, ty);\n+                if ty == normalized {\n+                    Err(err)\n+                } else {\n+                    SizeSkeleton::compute(normalized, infcx)\n+                }\n+            }\n+\n             _ => Err(err)\n         }\n     }"}, {"sha": "8e89b3c60879f4555d8f95d57493e61b44d2d38a", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=f55ac6944a88d4da62b30a16cc95893ca050c328", "patch": "@@ -1404,9 +1404,13 @@ impl<'a, 'tcx> ParameterEnvironment<'tcx> {\n                     }\n                 }\n             }\n-            Some(ast_map::NodeExpr(..)) => {\n+            Some(ast_map::NodeExpr(expr)) => {\n                 // This is a convenience to allow closures to work.\n-                ParameterEnvironment::for_item(tcx, tcx.map.get_parent(id))\n+                if let hir::ExprClosure(..) = expr.node {\n+                    ParameterEnvironment::for_item(tcx, tcx.map.get_parent(id))\n+                } else {\n+                    tcx.empty_parameter_environment()\n+                }\n             }\n             Some(ast_map::NodeForeignItem(item)) => {\n                 let def_id = tcx.map.local_def_id(id);\n@@ -1885,7 +1889,7 @@ impl<'a, 'tcx> AdtDefData<'tcx, 'tcx> {\n                 }\n             }\n \n-            TyProjection(..) => {\n+            TyProjection(..) | TyAnon(..) => {\n                 // must calculate explicitly.\n                 // FIXME: consider special-casing always-Sized projections\n                 vec![ty]"}, {"sha": "df907c26f71420b3e091c36ab02c96d5e5df394a", "filename": "src/librustc/ty/outlives.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc%2Fty%2Foutlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc%2Fty%2Foutlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Foutlives.rs?ref=f55ac6944a88d4da62b30a16cc95893ca050c328", "patch": "@@ -174,6 +174,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             ty::TyEnum(..) |        // OutlivesNominalType\n             ty::TyStruct(..) |      // OutlivesNominalType\n             ty::TyBox(..) |         // OutlivesNominalType (ish)\n+            ty::TyAnon(..) |        // OutlivesNominalType (ish)\n             ty::TyStr |             // OutlivesScalar (ish)\n             ty::TyArray(..) |       // ...\n             ty::TySlice(..) |       // ..."}, {"sha": "f9263947c0379c099562fc55c35046ffc025dd0e", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=f55ac6944a88d4da62b30a16cc95893ca050c328", "patch": "@@ -582,6 +582,13 @@ pub fn super_relate_tys<'a, 'gcx, 'tcx, R>(relation: &mut R,\n             Ok(tcx.mk_projection(projection_ty.trait_ref, projection_ty.item_name))\n         }\n \n+        (&ty::TyAnon(a_def_id, a_substs), &ty::TyAnon(b_def_id, b_substs))\n+            if a_def_id == b_def_id =>\n+        {\n+            let substs = relate_substs(relation, None, a_substs, b_substs)?;\n+            Ok(tcx.mk_anon(a_def_id, substs))\n+        }\n+\n         _ =>\n         {\n             Err(TypeError::Sorts(expected_found(relation, &a, &b)))"}, {"sha": "8c10806fda768a46c0e31a9103470d5273f939e5", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=f55ac6944a88d4da62b30a16cc95893ca050c328", "patch": "@@ -115,16 +115,26 @@ impl<'tcx, A: Copy+Lift<'tcx>, B: Copy+Lift<'tcx>> Lift<'tcx> for ty::OutlivesPr\n     }\n }\n \n+impl<'a, 'tcx> Lift<'tcx> for ty::ProjectionTy<'a> {\n+    type Lifted = ty::ProjectionTy<'tcx>;\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>)\n+                             -> Option<ty::ProjectionTy<'tcx>> {\n+        tcx.lift(&self.trait_ref).map(|trait_ref| {\n+            ty::ProjectionTy {\n+                trait_ref: trait_ref,\n+                item_name: self.item_name\n+            }\n+        })\n+    }\n+}\n+\n impl<'a, 'tcx> Lift<'tcx> for ty::ProjectionPredicate<'a> {\n     type Lifted = ty::ProjectionPredicate<'tcx>;\n     fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>)\n                              -> Option<ty::ProjectionPredicate<'tcx>> {\n-        tcx.lift(&(self.projection_ty.trait_ref, self.ty)).map(|(trait_ref, ty)| {\n+        tcx.lift(&(self.projection_ty, self.ty)).map(|(projection_ty, ty)| {\n             ty::ProjectionPredicate {\n-                projection_ty: ty::ProjectionTy {\n-                    trait_ref: trait_ref,\n-                    item_name: self.projection_ty.item_name\n-                },\n+                projection_ty: projection_ty,\n                 ty: ty\n             }\n         })\n@@ -485,6 +495,7 @@ impl<'tcx> TypeFoldable<'tcx> for Ty<'tcx> {\n             ty::TyStruct(did, substs) => ty::TyStruct(did, substs.fold_with(folder)),\n             ty::TyClosure(did, substs) => ty::TyClosure(did, substs.fold_with(folder)),\n             ty::TyProjection(ref data) => ty::TyProjection(data.fold_with(folder)),\n+            ty::TyAnon(did, substs) => ty::TyAnon(did, substs.fold_with(folder)),\n             ty::TyBool | ty::TyChar | ty::TyStr | ty::TyInt(_) |\n             ty::TyUint(_) | ty::TyFloat(_) | ty::TyError | ty::TyInfer(_) |\n             ty::TyParam(..) => self.sty.clone(),\n@@ -513,6 +524,7 @@ impl<'tcx> TypeFoldable<'tcx> for Ty<'tcx> {\n             ty::TyStruct(_did, ref substs) => substs.visit_with(visitor),\n             ty::TyClosure(_did, ref substs) => substs.visit_with(visitor),\n             ty::TyProjection(ref data) => data.visit_with(visitor),\n+            ty::TyAnon(_, ref substs) => substs.visit_with(visitor),\n             ty::TyBool | ty::TyChar | ty::TyStr | ty::TyInt(_) |\n             ty::TyUint(_) | ty::TyFloat(_) | ty::TyError | ty::TyInfer(_) |\n             ty::TyParam(..) => false,"}, {"sha": "912cb39face0a6d9ec910ce33194618826999551", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=f55ac6944a88d4da62b30a16cc95893ca050c328", "patch": "@@ -166,6 +166,12 @@ pub enum TypeVariants<'tcx> {\n     /// `<T as Trait<..>>::N`.\n     TyProjection(ProjectionTy<'tcx>),\n \n+    /// Anonymized (`impl Trait`) type found in a return type.\n+    /// The DefId comes from the `impl Trait` ast::Ty node, and the\n+    /// substitutions are for the generics of the function in question.\n+    /// After typeck, the concrete type can be found in the `tcache` map.\n+    TyAnon(DefId, &'tcx Substs<'tcx>),\n+\n     /// A type parameter; for example, `T` in `fn f<T>(x: T) {}\n     TyParam(ParamTy),\n \n@@ -1232,7 +1238,8 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n                 v\n             }\n             TyEnum(_, substs) |\n-            TyStruct(_, substs) => {\n+            TyStruct(_, substs) |\n+            TyAnon(_, substs) => {\n                 substs.regions.as_slice().to_vec()\n             }\n             TyClosure(_, ref substs) => {"}, {"sha": "e7bcfbfd823453dd2893fae3044744e7a8ee4b5c", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=f55ac6944a88d4da62b30a16cc95893ca050c328", "patch": "@@ -14,7 +14,7 @@ use hir::def_id::DefId;\n use ty::subst;\n use infer::InferCtxt;\n use hir::pat_util;\n-use traits::{self, ProjectionMode};\n+use traits::{self, Reveal};\n use ty::{self, Ty, TyCtxt, TypeAndMut, TypeFlags, TypeFoldable};\n use ty::{Disr, ParameterEnvironment};\n use ty::fold::TypeVisitor;\n@@ -137,8 +137,7 @@ impl<'tcx> ParameterEnvironment<'tcx> {\n                                        self_type: Ty<'tcx>, span: Span)\n                                        -> Result<(),CopyImplementationError> {\n         // FIXME: (@jroesch) float this code up\n-        tcx.infer_ctxt(None, Some(self.clone()),\n-                       ProjectionMode::Topmost).enter(|infcx| {\n+        tcx.infer_ctxt(None, Some(self.clone()), Reveal::ExactMatch).enter(|infcx| {\n             let adt = match self_type.sty {\n                 ty::TyStruct(struct_def, substs) => {\n                     for field in struct_def.all_fields() {\n@@ -438,6 +437,7 @@ impl<'a, 'gcx, 'tcx> TypeVisitor<'tcx> for TypeIdHasher<'a, 'gcx, 'tcx> {\n             TyRawPtr(m) |\n             TyRef(_, m) => self.hash(m.mutbl),\n             TyClosure(def_id, _) |\n+            TyAnon(def_id, _) |\n             TyFnDef(def_id, _, _) => self.def_id(def_id),\n             TyFnPtr(f) => {\n                 self.hash(f.unsafety);\n@@ -533,7 +533,7 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n                    param_env: &ParameterEnvironment<'tcx>,\n                    bound: ty::BuiltinBound, span: Span) -> bool\n     {\n-        tcx.infer_ctxt(None, Some(param_env.clone()), ProjectionMode::Topmost).enter(|infcx| {\n+        tcx.infer_ctxt(None, Some(param_env.clone()), Reveal::ExactMatch).enter(|infcx| {\n             traits::type_known_to_meet_builtin_bound(&infcx, self, bound, span)\n         })\n     }\n@@ -560,7 +560,7 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n             }) => Some(true),\n \n             TyArray(..) | TySlice(_) | TyTrait(..) | TyTuple(..) |\n-            TyClosure(..) | TyEnum(..) | TyStruct(..) |\n+            TyClosure(..) | TyEnum(..) | TyStruct(..) | TyAnon(..) |\n             TyProjection(..) | TyParam(..) | TyInfer(..) | TyError => None\n         }.unwrap_or_else(|| !self.impls_bound(tcx, param_env, ty::BoundCopy, span));\n \n@@ -601,7 +601,7 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n             TyStr | TyTrait(..) | TySlice(_) => Some(false),\n \n             TyEnum(..) | TyStruct(..) | TyProjection(..) | TyParam(..) |\n-            TyInfer(..) | TyError => None\n+            TyInfer(..) | TyAnon(..) | TyError => None\n         }.unwrap_or_else(|| self.impls_bound(tcx, param_env, ty::BoundSized, span));\n \n         if !self.has_param_types() && !self.has_self_ty() {\n@@ -627,7 +627,6 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n         }\n \n         let layout = Layout::compute_uncached(self, infcx)?;\n-        let layout = tcx.intern_layout(layout);\n         if can_cache {\n             tcx.layout_cache.borrow_mut().insert(self, layout);\n         }"}, {"sha": "ebc2642678bfd80bb3b9d0a794dd0704dc88c263", "filename": "src/librustc/ty/walk.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc%2Fty%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc%2Fty%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwalk.rs?ref=f55ac6944a88d4da62b30a16cc95893ca050c328", "patch": "@@ -88,7 +88,8 @@ fn push_subtypes<'tcx>(stack: &mut Vec<Ty<'tcx>>, parent_ty: Ty<'tcx>) {\n             }).collect::<Vec<_>>());\n         }\n         ty::TyEnum(_, ref substs) |\n-        ty::TyStruct(_, ref substs) => {\n+        ty::TyStruct(_, ref substs) |\n+        ty::TyAnon(_, ref substs) => {\n             push_reversed(stack, substs.types.as_slice());\n         }\n         ty::TyClosure(_, ref substs) => {"}, {"sha": "f6ddfe60d40e6804c7ffee6f72b0276a303bcbe6", "filename": "src/librustc/ty/wf.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc%2Fty%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc%2Fty%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwf.rs?ref=f55ac6944a88d4da62b30a16cc95893ca050c328", "patch": "@@ -383,6 +383,12 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n                     // types appearing in the fn signature\n                 }\n \n+                ty::TyAnon(..) => {\n+                    // all of the requirements on type parameters\n+                    // should've been checked by the instantiation\n+                    // of whatever returned this exact `impl Trait`.\n+                }\n+\n                 ty::TyTrait(ref data) => {\n                     // WfObject\n                     //"}, {"sha": "a17c01068139a376cd6c5b1aaa83d1a16e1fb57a", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=f55ac6944a88d4da62b30a16cc95893ca050c328", "patch": "@@ -907,6 +907,37 @@ impl<'tcx> fmt::Display for ty::TypeVariants<'tcx> {\n             }\n             TyTrait(ref data) => write!(f, \"{}\", data),\n             ty::TyProjection(ref data) => write!(f, \"{}\", data),\n+            ty::TyAnon(def_id, substs) => {\n+                ty::tls::with(|tcx| {\n+                    // Grab the \"TraitA + TraitB\" from `impl TraitA + TraitB`,\n+                    // by looking up the projections associated with the def_id.\n+                    let item_predicates = tcx.lookup_predicates(def_id);\n+                    let substs = tcx.lift(&substs).unwrap_or_else(|| {\n+                        tcx.mk_substs(subst::Substs::empty())\n+                    });\n+                    let bounds = item_predicates.instantiate(tcx, substs);\n+\n+                    let mut first = true;\n+                    let mut is_sized = false;\n+                    write!(f, \"impl\")?;\n+                    for predicate in bounds.predicates.into_vec() {\n+                        if let Some(trait_ref) = predicate.to_opt_poly_trait_ref() {\n+                            // Don't print +Sized, but rather +?Sized if absent.\n+                            if Some(trait_ref.def_id()) == tcx.lang_items.sized_trait() {\n+                                is_sized = true;\n+                                continue;\n+                            }\n+\n+                            write!(f, \"{}{}\", if first { \" \" } else { \"+\" }, trait_ref)?;\n+                            first = false;\n+                        }\n+                    }\n+                    if !is_sized {\n+                        write!(f, \"{}?Sized\", if first { \" \" } else { \"+\" })?;\n+                    }\n+                    Ok(())\n+                })\n+            }\n             TyStr => write!(f, \"str\"),\n             TyClosure(did, substs) => ty::tls::with(|tcx| {\n                 write!(f, \"[closure\")?;"}, {"sha": "3e88dec8cb27a0c31e8aec233937be99ead96c62", "filename": "src/librustc_const_eval/check_match.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=f55ac6944a88d4da62b30a16cc95893ca050c328", "patch": "@@ -25,7 +25,7 @@ use rustc::middle::expr_use_visitor::{LoanCause, MutateMode};\n use rustc::middle::expr_use_visitor as euv;\n use rustc::middle::mem_categorization::{cmt};\n use rustc::hir::pat_util::*;\n-use rustc::traits::ProjectionMode;\n+use rustc::traits::Reveal;\n use rustc::ty::*;\n use rustc::ty;\n use std::cmp::Ordering;\n@@ -1133,7 +1133,7 @@ fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n                 let pat_ty = cx.tcx.node_id_to_type(p.id);\n                 //FIXME: (@jroesch) this code should be floated up as well\n                 cx.tcx.infer_ctxt(None, Some(cx.param_env.clone()),\n-                                  ProjectionMode::AnyFinal).enter(|infcx| {\n+                                  Reveal::NotSpecializable).enter(|infcx| {\n                     if infcx.type_moves_by_default(pat_ty, pat.span) {\n                         check_move(p, sub.as_ref().map(|p| &**p));\n                     }\n@@ -1149,7 +1149,7 @@ fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n fn check_for_mutation_in_guard<'a, 'tcx>(cx: &'a MatchCheckCtxt<'a, 'tcx>,\n                                          guard: &hir::Expr) {\n     cx.tcx.infer_ctxt(None, Some(cx.param_env.clone()),\n-                      ProjectionMode::AnyFinal).enter(|infcx| {\n+                      Reveal::NotSpecializable).enter(|infcx| {\n         let mut checker = MutationChecker {\n             cx: cx,\n         };"}, {"sha": "73b54c4374ffb65dce75dcf20a6a0bbe29545af5", "filename": "src/librustc_const_eval/eval.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc_const_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc_const_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Feval.rs?ref=f55ac6944a88d4da62b30a16cc95893ca050c328", "patch": "@@ -24,7 +24,7 @@ use rustc::hir::def_id::DefId;\n use rustc::hir::pat_util::def_to_path;\n use rustc::ty::{self, Ty, TyCtxt, subst};\n use rustc::ty::util::IntTypeExt;\n-use rustc::traits::ProjectionMode;\n+use rustc::traits::Reveal;\n use rustc::util::common::ErrorReported;\n use rustc::util::nodemap::NodeMap;\n use rustc::lint;\n@@ -1055,7 +1055,7 @@ fn resolve_trait_associated_const<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n            trait_ref);\n \n     tcx.populate_implementations_for_trait_if_necessary(trait_ref.def_id());\n-    tcx.infer_ctxt(None, None, ProjectionMode::AnyFinal).enter(|infcx| {\n+    tcx.infer_ctxt(None, None, Reveal::NotSpecializable).enter(|infcx| {\n         let mut selcx = traits::SelectionContext::new(&infcx);\n         let obligation = traits::Obligation::new(traits::ObligationCause::dummy(),\n                                                  trait_ref.to_poly_trait_predicate());\n@@ -1073,9 +1073,9 @@ fn resolve_trait_associated_const<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         };\n \n         // NOTE: this code does not currently account for specialization, but when\n-        // it does so, it should hook into the ProjectionMode to determine when the\n+        // it does so, it should hook into the Reveal to determine when the\n         // constant should resolve; this will also require plumbing through to this\n-        // function whether we are in \"trans mode\" to pick the right ProjectionMode\n+        // function whether we are in \"trans mode\" to pick the right Reveal\n         // when constructing the inference context above.\n         match selection {\n             traits::VtableImpl(ref impl_data) => {"}, {"sha": "30fe38a0603a563f71791bc8ac58fa7124d80c5e", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=f55ac6944a88d4da62b30a16cc95893ca050c328", "patch": "@@ -22,7 +22,7 @@ use rustc::middle::resolve_lifetime;\n use rustc::middle::stability;\n use rustc::ty::subst;\n use rustc::ty::subst::Subst;\n-use rustc::traits::ProjectionMode;\n+use rustc::traits::Reveal;\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n use rustc::infer::{self, InferOk, InferResult, TypeOrigin};\n use rustc_metadata::cstore::CStore;\n@@ -141,7 +141,7 @@ fn test_env<F>(source_string: &str,\n                              index,\n                              \"test_crate\",\n                              |tcx| {\n-        tcx.infer_ctxt(None, None, ProjectionMode::AnyFinal).enter(|infcx| {\n+        tcx.infer_ctxt(None, None, Reveal::NotSpecializable).enter(|infcx| {\n \n             body(Env { infcx: &infcx });\n             let free_regions = FreeRegionMap::new();"}, {"sha": "d8ec79fb0609680de5be956ab554eadc2335d468", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=f55ac6944a88d4da62b30a16cc95893ca050c328", "patch": "@@ -35,7 +35,7 @@ use rustc::cfg;\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::adjustment;\n-use rustc::traits::{self, ProjectionMode};\n+use rustc::traits::{self, Reveal};\n use rustc::hir::map as hir_map;\n use util::nodemap::{NodeSet};\n use lint::{Level, LateContext, LintContext, LintArray, Lint};\n@@ -911,7 +911,7 @@ impl LateLintPass for UnconditionalRecursion {\n                     let node_id = tcx.map.as_local_node_id(method.def_id).unwrap();\n \n                     let param_env = Some(ty::ParameterEnvironment::for_item(tcx, node_id));\n-                    tcx.infer_ctxt(None, param_env, ProjectionMode::AnyFinal).enter(|infcx| {\n+                    tcx.infer_ctxt(None, param_env, Reveal::NotSpecializable).enter(|infcx| {\n                         let mut selcx = traits::SelectionContext::new(&infcx);\n                         match selcx.select(&obligation) {\n                             // The method comes from a `T: Trait` bound."}, {"sha": "b9861c309dbec985d3e467eb9c9032219ecbf336", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=f55ac6944a88d4da62b30a16cc95893ca050c328", "patch": "@@ -14,7 +14,7 @@ use rustc::hir::def_id::DefId;\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::layout::{Layout, Primitive};\n-use rustc::traits::ProjectionMode;\n+use rustc::traits::Reveal;\n use middle::const_val::ConstVal;\n use rustc_const_eval::eval_const_expr_partial;\n use rustc_const_eval::EvalHint::ExprTypeChecked;\n@@ -596,7 +596,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n             }\n \n             ty::TyParam(..) | ty::TyInfer(..) | ty::TyError |\n-            ty::TyClosure(..) | ty::TyProjection(..) |\n+            ty::TyClosure(..) | ty::TyProjection(..) | ty::TyAnon(..) |\n             ty::TyFnDef(..) => {\n                 bug!(\"Unexpected type in foreign function\")\n             }\n@@ -697,7 +697,7 @@ impl LateLintPass for VariantSizeDifferences {\n         if let hir::ItemEnum(ref enum_definition, ref gens) = it.node {\n             if gens.ty_params.is_empty() {  // sizes only make sense for non-generic types\n                 let t = cx.tcx.node_id_to_type(it.id);\n-                let layout = cx.tcx.normalizing_infer_ctxt(ProjectionMode::Any).enter(|infcx| {\n+                let layout = cx.tcx.normalizing_infer_ctxt(Reveal::All).enter(|infcx| {\n                     let ty = cx.tcx.erase_regions(&t);\n                     ty.layout(&infcx).unwrap_or_else(|e| {\n                         bug!(\"failed to get layout for `{}`: {}\", t, e)"}, {"sha": "285ca2e4d4d4de2367259410dd9f09a3e291e73c", "filename": "src/librustc_metadata/def_key.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc_metadata%2Fdef_key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc_metadata%2Fdef_key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdef_key.rs?ref=f55ac6944a88d4da62b30a16cc95893ca050c328", "patch": "@@ -41,6 +41,7 @@ pub enum DefPathData {\n     StructCtor,\n     Initializer,\n     Binding,\n+    ImplTrait,\n }\n \n pub fn simplify_def_key(key: hir_map::DefKey) -> DefKey {\n@@ -72,6 +73,7 @@ fn simplify_def_path_data(data: hir_map::DefPathData) -> DefPathData {\n         hir_map::DefPathData::StructCtor => DefPathData::StructCtor,\n         hir_map::DefPathData::Initializer => DefPathData::Initializer,\n         hir_map::DefPathData::Binding(_) => DefPathData::Binding,\n+        hir_map::DefPathData::ImplTrait => DefPathData::ImplTrait,\n     }\n }\n \n@@ -103,5 +105,6 @@ fn recover_def_path_data(data: DefPathData, name: Option<InternedString>) -> hir\n         DefPathData::StructCtor => hir_map::DefPathData::StructCtor,\n         DefPathData::Initializer => hir_map::DefPathData::Initializer,\n         DefPathData::Binding => hir_map::DefPathData::Binding(name.unwrap()),\n+        DefPathData::ImplTrait => hir_map::DefPathData::ImplTrait,\n     }\n }"}, {"sha": "cc1d07b33c7e830b6840e2d4b79045210db44f99", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=f55ac6944a88d4da62b30a16cc95893ca050c328", "patch": "@@ -1390,6 +1390,20 @@ impl<'a, 'b, 'c, 'tcx> Visitor<'tcx> for EncodeVisitor<'a, 'b, 'c, 'tcx> {\n         intravisit::walk_foreign_item(self, ni);\n         encode_info_for_foreign_item(self.ecx, self.rbml_w_for_visit_item, ni, self.index);\n     }\n+    fn visit_ty(&mut self, ty: &'tcx hir::Ty) {\n+        intravisit::walk_ty(self, ty);\n+\n+        if let hir::TyImplTrait(_) = ty.node {\n+            let rbml_w = &mut *self.rbml_w_for_visit_item;\n+            let def_id = self.ecx.tcx.map.local_def_id(ty.id);\n+            let _task = self.index.record(def_id, rbml_w);\n+            rbml_w.start_tag(tag_items_data_item);\n+            encode_def_id_and_key(self.ecx, rbml_w, def_id);\n+            encode_family(rbml_w, 'y');\n+            encode_bounds_and_type_for_item(rbml_w, self.ecx, self.index, ty.id);\n+            rbml_w.end_tag();\n+        }\n+    }\n }\n \n fn encode_info_for_items<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,"}, {"sha": "1dcec35adb285554642a41712abcc6265d736166", "filename": "src/librustc_metadata/tydecode.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc_metadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc_metadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Ftydecode.rs?ref=f55ac6944a88d4da62b30a16cc95893ca050c328", "patch": "@@ -445,6 +445,13 @@ impl<'a,'tcx> TyDecoder<'a,'tcx> {\n                 let name = token::intern(&self.parse_str(']'));\n                 return tcx.mk_projection(trait_ref, name);\n             }\n+            'A' => {\n+                assert_eq!(self.next(), '[');\n+                let def_id = self.parse_def();\n+                let substs = self.parse_substs();\n+                assert_eq!(self.next(), ']');\n+                return self.tcx.mk_anon(def_id, self.tcx.mk_substs(substs));\n+            }\n             'e' => {\n                 return tcx.types.err;\n             }"}, {"sha": "c2e91eba0d2523a600d322ccf35f1d548375958a", "filename": "src/librustc_metadata/tyencode.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc_metadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc_metadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Ftyencode.rs?ref=f55ac6944a88d4da62b30a16cc95893ca050c328", "patch": "@@ -170,6 +170,11 @@ pub fn enc_ty<'a, 'tcx>(w: &mut Cursor<Vec<u8>>, cx: &ctxt<'a, 'tcx>, t: Ty<'tcx\n             enc_trait_ref(w, cx, data.trait_ref);\n             write!(w, \"{}]\", data.item_name);\n         }\n+        ty::TyAnon(def_id, substs) => {\n+            write!(w, \"A[{}|\", (cx.ds)(cx.tcx, def_id));\n+            enc_substs(w, cx, substs);\n+            write!(w, \"]\");\n+        }\n         ty::TyError => {\n             write!(w, \"e\");\n         }"}, {"sha": "5e92a057da38280a46c8ca1ef21353e1bad1ef64", "filename": "src/librustc_mir/mir_map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc_mir%2Fmir_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc_mir%2Fmir_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmir_map.rs?ref=f55ac6944a88d4da62b30a16cc95893ca050c328", "patch": "@@ -27,7 +27,7 @@ use hair::cx::Cx;\n \n use rustc::mir::mir_map::MirMap;\n use rustc::infer::InferCtxtBuilder;\n-use rustc::traits::ProjectionMode;\n+use rustc::traits::Reveal;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::subst::Substs;\n use rustc::hir;\n@@ -103,7 +103,7 @@ impl<'a, 'gcx, 'tcx> BuildMir<'a, 'gcx> {\n         let def_id = self.tcx.map.local_def_id(src.item_id());\n         CxBuilder {\n             src: src,\n-            infcx: self.tcx.infer_ctxt(None, Some(param_env), ProjectionMode::AnyFinal),\n+            infcx: self.tcx.infer_ctxt(None, Some(param_env), Reveal::NotSpecializable),\n             def_id: def_id,\n             map: self.map\n         }"}, {"sha": "7ebc72bcc5fca36875d7dc631774151219194300", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=f55ac6944a88d4da62b30a16cc95893ca050c328", "patch": "@@ -21,7 +21,7 @@ use rustc::hir;\n use rustc::hir::def_id::DefId;\n use rustc::hir::intravisit::FnKind;\n use rustc::hir::map::blocks::FnLikeNode;\n-use rustc::traits::{self, ProjectionMode};\n+use rustc::traits::{self, Reveal};\n use rustc::ty::{self, TyCtxt, Ty};\n use rustc::ty::cast::CastTy;\n use rustc::mir::repr::*;\n@@ -992,7 +992,7 @@ impl<'tcx> MirMapPass<'tcx> for QualifyAndPromoteConstants {\n             // Statics must be Sync.\n             if mode == Mode::Static {\n                 let ty = mir.return_ty.unwrap();\n-                tcx.infer_ctxt(None, None, ProjectionMode::AnyFinal).enter(|infcx| {\n+                tcx.infer_ctxt(None, None, Reveal::NotSpecializable).enter(|infcx| {\n                     let cause = traits::ObligationCause::new(mir.span, id, traits::SharedStatic);\n                     let mut fulfillment_cx = traits::FulfillmentContext::new();\n                     fulfillment_cx.register_builtin_bound(&infcx, ty, ty::BoundSync, cause);"}, {"sha": "52f41741b08d69c6975ca1049ddafb3e91ecae6a", "filename": "src/librustc_mir/transform/type_check.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs?ref=f55ac6944a88d4da62b30a16cc95893ca050c328", "patch": "@@ -12,7 +12,7 @@\n #![allow(unreachable_code)]\n \n use rustc::infer::{self, InferCtxt, InferOk};\n-use rustc::traits::{self, ProjectionMode};\n+use rustc::traits::{self, Reveal};\n use rustc::ty::fold::TypeFoldable;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::mir::repr::*;\n@@ -695,7 +695,7 @@ impl<'tcx> MirPass<'tcx> for TypeckMir {\n             return;\n         }\n         let param_env = ty::ParameterEnvironment::for_item(tcx, src.item_id());\n-        tcx.infer_ctxt(None, Some(param_env), ProjectionMode::AnyFinal).enter(|infcx| {\n+        tcx.infer_ctxt(None, Some(param_env), Reveal::NotSpecializable).enter(|infcx| {\n             let mut checker = TypeChecker::new(&infcx);\n             {\n                 let mut verifier = TypeVerifier::new(&mut checker, mir);"}, {"sha": "37e42cdea1bf84b6f6b690efeb9bd92b28a4afa4", "filename": "src/librustc_passes/consts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc_passes%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc_passes%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fconsts.rs?ref=f55ac6944a88d4da62b30a16cc95893ca050c328", "patch": "@@ -39,7 +39,7 @@ use rustc::middle::expr_use_visitor as euv;\n use rustc::middle::mem_categorization as mc;\n use rustc::middle::mem_categorization::Categorization;\n use rustc::ty::{self, Ty, TyCtxt};\n-use rustc::traits::ProjectionMode;\n+use rustc::traits::Reveal;\n use rustc::util::common::ErrorReported;\n use rustc::util::nodemap::NodeMap;\n use rustc::middle::const_qualif::ConstQualif;\n@@ -96,7 +96,7 @@ impl<'a, 'gcx> CheckCrateVisitor<'a, 'gcx> {\n         };\n \n         self.tcx\n-            .infer_ctxt(None, Some(param_env), ProjectionMode::AnyFinal)\n+            .infer_ctxt(None, Some(param_env), Reveal::NotSpecializable)\n             .enter(|infcx| f(&mut euv::ExprUseVisitor::new(self, &infcx)))\n     }\n "}, {"sha": "782ee34edd4f98ec90c45b2716b332bd2e19b79f", "filename": "src/librustc_passes/rvalues.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc_passes%2Frvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc_passes%2Frvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Frvalues.rs?ref=f55ac6944a88d4da62b30a16cc95893ca050c328", "patch": "@@ -15,7 +15,7 @@ use rustc::dep_graph::DepNode;\n use rustc::middle::expr_use_visitor as euv;\n use rustc::middle::mem_categorization as mc;\n use rustc::ty::{self, TyCtxt, ParameterEnvironment};\n-use rustc::traits::ProjectionMode;\n+use rustc::traits::Reveal;\n \n use rustc::hir;\n use rustc::hir::intravisit;\n@@ -41,7 +41,7 @@ impl<'a, 'tcx, 'v> intravisit::Visitor<'v> for RvalueContext<'a, 'tcx> {\n         // FIXME (@jroesch) change this to be an inference context\n         let param_env = ParameterEnvironment::for_item(self.tcx, fn_id);\n         self.tcx.infer_ctxt(None, Some(param_env.clone()),\n-                            ProjectionMode::AnyFinal).enter(|infcx| {\n+                            Reveal::NotSpecializable).enter(|infcx| {\n             let mut delegate = RvalueContextDelegate {\n                 tcx: infcx.tcx,\n                 param_env: &param_env"}, {"sha": "29b3f6ce52fb2b8368f17d2fcbea1193273aac20", "filename": "src/librustc_trans/_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc_trans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc_trans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2F_match.rs?ref=f55ac6944a88d4da62b30a16cc95893ca050c328", "patch": "@@ -217,7 +217,7 @@ use type_of;\n use Disr;\n use value::Value;\n use rustc::ty::{self, Ty, TyCtxt};\n-use rustc::traits::ProjectionMode;\n+use rustc::traits::Reveal;\n use session::config::NoDebugInfo;\n use util::common::indenter;\n use util::nodemap::FnvHashMap;\n@@ -1471,7 +1471,7 @@ fn is_discr_reassigned(bcx: Block, discr: &hir::Expr, body: &hir::Expr) -> bool\n         field: field,\n         reassigned: false\n     };\n-    bcx.tcx().normalizing_infer_ctxt(ProjectionMode::Any).enter(|infcx| {\n+    bcx.tcx().normalizing_infer_ctxt(Reveal::All).enter(|infcx| {\n         let mut visitor = euv::ExprUseVisitor::new(&mut rc, &infcx);\n         visitor.walk_expr(body);\n     });"}, {"sha": "4a6dbb2bdae56d746926987e2a7921357e1eadbb", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=f55ac6944a88d4da62b30a16cc95893ca050c328", "patch": "@@ -796,6 +796,7 @@ fn find_drop_glue_neighbors<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n         ty::TyProjection(_) |\n         ty::TyParam(_)      |\n         ty::TyInfer(_)      |\n+        ty::TyAnon(..)      |\n         ty::TyError         => {\n             bug!(\"encountered unexpected type\");\n         }"}, {"sha": "dea5a1560e15b0564f94aaf8b29bb16a5cdc80fc", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=f55ac6944a88d4da62b30a16cc95893ca050c328", "patch": "@@ -40,7 +40,7 @@ use type_::Type;\n use value::Value;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::layout::Layout;\n-use rustc::traits::{self, SelectionContext, ProjectionMode};\n+use rustc::traits::{self, SelectionContext, Reveal};\n use rustc::ty::fold::TypeFoldable;\n use rustc::hir;\n use util::nodemap::NodeMap;\n@@ -128,7 +128,7 @@ pub fn type_pair_fields<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>)\n pub fn type_is_imm_pair<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>)\n                                   -> bool {\n     let tcx = ccx.tcx();\n-    let layout = tcx.normalizing_infer_ctxt(ProjectionMode::Any).enter(|infcx| {\n+    let layout = tcx.normalizing_infer_ctxt(Reveal::All).enter(|infcx| {\n         match ty.layout(&infcx) {\n             Ok(layout) => layout,\n             Err(err) => {\n@@ -1136,7 +1136,7 @@ pub fn fulfill_obligation<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n \n         // Do the initial selection for the obligation. This yields the\n         // shallow result we are looking for -- that is, what specific impl.\n-        tcx.normalizing_infer_ctxt(ProjectionMode::Any).enter(|infcx| {\n+        tcx.normalizing_infer_ctxt(Reveal::All).enter(|infcx| {\n             let mut selcx = SelectionContext::new(&infcx);\n \n             let obligation_cause = traits::ObligationCause::misc(span,\n@@ -1195,7 +1195,7 @@ pub fn normalize_and_test_predicates<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     debug!(\"normalize_and_test_predicates(predicates={:?})\",\n            predicates);\n \n-    tcx.normalizing_infer_ctxt(ProjectionMode::Any).enter(|infcx| {\n+    tcx.normalizing_infer_ctxt(Reveal::All).enter(|infcx| {\n         let mut selcx = SelectionContext::new(&infcx);\n         let mut fulfill_cx = traits::FulfillmentContext::new();\n         let cause = traits::ObligationCause::dummy();"}, {"sha": "bee2667c71f9db974660ff39bde162776e9379b3", "filename": "src/librustc_trans/debuginfo/type_names.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs?ref=f55ac6944a88d4da62b30a16cc95893ca050c328", "patch": "@@ -150,6 +150,7 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         ty::TyError |\n         ty::TyInfer(_) |\n         ty::TyProjection(..) |\n+        ty::TyAnon(..) |\n         ty::TyParam(_) => {\n             bug!(\"debuginfo: Trying to create type name for \\\n                 unexpected type: {:?}\", t);"}, {"sha": "93e5f4ba1e205cec5dfd64577a54ea7564065a8f", "filename": "src/librustc_trans/glue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc_trans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc_trans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fglue.rs?ref=f55ac6944a88d4da62b30a16cc95893ca050c328", "patch": "@@ -115,7 +115,7 @@ pub fn get_drop_glue_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     match t.sty {\n         ty::TyBox(typ) if !type_needs_drop(tcx, typ)\n                          && type_is_sized(tcx, typ) => {\n-            tcx.normalizing_infer_ctxt(traits::ProjectionMode::Any).enter(|infcx| {\n+            tcx.normalizing_infer_ctxt(traits::Reveal::All).enter(|infcx| {\n                 let layout = t.layout(&infcx).unwrap();\n                 if layout.size(&tcx.data_layout).bytes() == 0 {\n                     // `Box<ZeroSizeType>` does not allocate."}, {"sha": "3d6093d4d6960f16aeeab3e697a71564414bc823", "filename": "src/librustc_trans/meth.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc_trans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc_trans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmeth.rs?ref=f55ac6944a88d4da62b30a16cc95893ca050c328", "patch": "@@ -17,7 +17,7 @@ use llvm::{ValueRef, get_params};\n use rustc::hir::def_id::DefId;\n use rustc::ty::subst::{FnSpace, Subst, Substs};\n use rustc::ty::subst;\n-use rustc::traits::{self, ProjectionMode};\n+use rustc::traits::{self, Reveal};\n use abi::FnType;\n use base::*;\n use build::*;\n@@ -321,7 +321,7 @@ pub fn get_impl_method<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     match trait_def.ancestors(impl_def_id).fn_defs(tcx, name).next() {\n         Some(node_item) => {\n-            let substs = tcx.normalizing_infer_ctxt(ProjectionMode::Any).enter(|infcx| {\n+            let substs = tcx.normalizing_infer_ctxt(Reveal::All).enter(|infcx| {\n                 let substs = traits::translate_substs(&infcx, impl_def_id,\n                                                       substs, node_item.node);\n                 tcx.lift(&substs).unwrap_or_else(|| {"}, {"sha": "187ffe353fdcb5f596bd87dbfb0994feaa8e8c79", "filename": "src/librustc_trans/trans_item.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc_trans%2Ftrans_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc_trans%2Ftrans_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans_item.rs?ref=f55ac6944a88d4da62b30a16cc95893ca050c328", "patch": "@@ -536,7 +536,8 @@ pub fn push_unique_type_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         ty::TyError |\n         ty::TyInfer(_) |\n         ty::TyProjection(..) |\n-        ty::TyParam(_) => {\n+        ty::TyParam(_) |\n+        ty::TyAnon(..) => {\n             bug!(\"debuginfo: Trying to create type name for \\\n                   unexpected type: {:?}\", t);\n         }"}, {"sha": "cde53f6fa899cb9c89a33977e8e42070764b6f19", "filename": "src/librustc_trans/type_of.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc_trans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc_trans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftype_of.rs?ref=f55ac6944a88d4da62b30a16cc95893ca050c328", "patch": "@@ -16,7 +16,7 @@ use abi::FnType;\n use adt;\n use common::*;\n use machine;\n-use rustc::traits::ProjectionMode;\n+use rustc::traits::Reveal;\n use rustc::ty::{self, Ty, TypeFoldable};\n \n use type_::Type;\n@@ -112,7 +112,8 @@ pub fn sizing_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Typ\n             }\n         }\n \n-        ty::TyProjection(..) | ty::TyInfer(..) | ty::TyParam(..) | ty::TyError => {\n+        ty::TyProjection(..) | ty::TyInfer(..) | ty::TyParam(..) |\n+        ty::TyAnon(..) | ty::TyError => {\n             bug!(\"fictitious type {:?} in sizing_type_of()\", t)\n         }\n         ty::TySlice(_) | ty::TyTrait(..) | ty::TyStr => bug!()\n@@ -123,7 +124,7 @@ pub fn sizing_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Typ\n     cx.llsizingtypes().borrow_mut().insert(t, llsizingty);\n \n     // FIXME(eddyb) Temporary sanity check for ty::layout.\n-    let layout = cx.tcx().normalizing_infer_ctxt(ProjectionMode::Any).enter(|infcx| {\n+    let layout = cx.tcx().normalizing_infer_ctxt(Reveal::All).enter(|infcx| {\n         t.layout(&infcx)\n     });\n     match layout {\n@@ -339,10 +340,11 @@ pub fn in_memory_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) ->\n           }\n       }\n \n-      ty::TyInfer(..) => bug!(\"type_of with TyInfer\"),\n-      ty::TyProjection(..) => bug!(\"type_of with TyProjection\"),\n-      ty::TyParam(..) => bug!(\"type_of with ty_param\"),\n-      ty::TyError => bug!(\"type_of with TyError\"),\n+      ty::TyInfer(..) |\n+      ty::TyProjection(..) |\n+      ty::TyParam(..) |\n+      ty::TyAnon(..) |\n+      ty::TyError => bug!(\"type_of with {:?}\", t),\n     };\n \n     debug!(\"--> mapped t={:?} to llty={:?}\", t, llty);"}, {"sha": "ad61b5b0b513eb355d664e7e4695e1c40de36cf2", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 69, "deletions": 23, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=f55ac6944a88d4da62b30a16cc95893ca050c328", "patch": "@@ -56,6 +56,7 @@ use hir::print as pprust;\n use middle::resolve_lifetime as rl;\n use rustc::lint;\n use rustc::ty::subst::{FnSpace, TypeSpace, SelfSpace, Subst, Substs, ParamSpace};\n+use rustc::ty::subst::VecPerParamSpace;\n use rustc::traits;\n use rustc::ty::{self, Ty, TyCtxt, ToPredicate, TypeFoldable};\n use rustc::ty::wf::object_region_bounds;\n@@ -64,6 +65,7 @@ use require_c_abi_if_variadic;\n use rscope::{self, UnelidableRscope, RegionScope, ElidableRscope,\n              ObjectLifetimeDefaultRscope, ShiftedRscope, BindingRscope,\n              ElisionFailureInfo, ElidedLifetime};\n+use rscope::{AnonTypeScope, MaybeWithAnonTypes};\n use util::common::{ErrorReported, FN_OUTPUT_NAME};\n use util::nodemap::{NodeMap, FnvHashSet};\n \n@@ -634,20 +636,21 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n \n     fn convert_ty_with_lifetime_elision(&self,\n                                         elided_lifetime: ElidedLifetime,\n-                                        ty: &hir::Ty)\n+                                        ty: &hir::Ty,\n+                                        anon_scope: Option<AnonTypeScope>)\n                                         -> Ty<'tcx>\n     {\n         match elided_lifetime {\n             Ok(implied_output_region) => {\n                 let rb = ElidableRscope::new(implied_output_region);\n-                self.ast_ty_to_ty(&rb, ty)\n+                self.ast_ty_to_ty(&MaybeWithAnonTypes::new(rb, anon_scope), ty)\n             }\n             Err(param_lifetimes) => {\n                 // All regions must be explicitly specified in the output\n                 // if the lifetime elision rules do not apply. This saves\n                 // the user from potentially-confusing errors.\n                 let rb = UnelidableRscope::new(param_lifetimes);\n-                self.ast_ty_to_ty(&rb, ty)\n+                self.ast_ty_to_ty(&MaybeWithAnonTypes::new(rb, anon_scope), ty)\n             }\n         }\n     }\n@@ -664,7 +667,8 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         let region_substs =\n             self.create_region_substs(rscope, span, decl_generics, Vec::new());\n \n-        let binding_rscope = BindingRscope::new();\n+        let anon_scope = rscope.anon_type_scope();\n+        let binding_rscope = MaybeWithAnonTypes::new(BindingRscope::new(), anon_scope);\n         let inputs =\n             data.inputs.iter()\n                        .map(|a_t| self.ast_ty_arg_to_ty(&binding_rscope, decl_generics,\n@@ -678,7 +682,9 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n \n         let (output, output_span) = match data.output {\n             Some(ref output_ty) => {\n-                (self.convert_ty_with_lifetime_elision(implied_output_region, &output_ty),\n+                (self.convert_ty_with_lifetime_elision(implied_output_region,\n+                                                       &output_ty,\n+                                                       anon_scope),\n                  output_ty.span)\n             }\n             None => {\n@@ -1702,7 +1708,14 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             }\n             hir::TyBareFn(ref bf) => {\n                 require_c_abi_if_variadic(tcx, &bf.decl, bf.abi, ast_ty.span);\n-                let bare_fn_ty = self.ty_of_bare_fn(bf.unsafety, bf.abi, &bf.decl);\n+                let anon_scope = rscope.anon_type_scope();\n+                let (bare_fn_ty, _) =\n+                    self.ty_of_method_or_bare_fn(bf.unsafety,\n+                                                 bf.abi,\n+                                                 None,\n+                                                 &bf.decl,\n+                                                 anon_scope,\n+                                                 anon_scope);\n \n                 // Find any late-bound regions declared in return type that do\n                 // not appear in the arguments. These are not wellformed.\n@@ -1745,6 +1758,34 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             hir::TyPolyTraitRef(ref bounds) => {\n                 self.conv_ty_poly_trait_ref(rscope, ast_ty.span, bounds)\n             }\n+            hir::TyImplTrait(ref bounds) => {\n+                use collect::{compute_bounds, SizedByDefault};\n+\n+                // Create the anonymized type.\n+                let def_id = tcx.map.local_def_id(ast_ty.id);\n+                if let Some(anon_scope) = rscope.anon_type_scope() {\n+                    let substs = anon_scope.fresh_substs(tcx);\n+                    let ty = tcx.mk_anon(tcx.map.local_def_id(ast_ty.id), substs);\n+\n+                    // Collect the bounds, i.e. the `A+B+'c` in `impl A+B+'c`.\n+                    let bounds = compute_bounds(self, ty, bounds,\n+                                                SizedByDefault::Yes,\n+                                                Some(anon_scope),\n+                                                ast_ty.span);\n+                    let predicates = bounds.predicates(tcx, ty);\n+                    let predicates = tcx.lift_to_global(&predicates).unwrap();\n+                    tcx.predicates.borrow_mut().insert(def_id, ty::GenericPredicates {\n+                        predicates: VecPerParamSpace::new(vec![], vec![], predicates)\n+                    });\n+\n+                    ty\n+                } else {\n+                    span_err!(tcx.sess, ast_ty.span, E0562,\n+                              \"`impl Trait` not allowed outside of function \\\n+                               and inherent method return types\");\n+                    tcx.types.err\n+                }\n+            }\n             hir::TyPath(ref maybe_qself, ref path) => {\n                 debug!(\"ast_ty_to_ty: maybe_qself={:?} path={:?}\", maybe_qself, path);\n                 let path_res = tcx.expect_resolution(ast_ty.id);\n@@ -1809,36 +1850,40 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n \n     pub fn ty_of_method(&self,\n                         sig: &hir::MethodSig,\n-                        untransformed_self_ty: Ty<'tcx>)\n+                        untransformed_self_ty: Ty<'tcx>,\n+                        anon_scope: Option<AnonTypeScope>)\n                         -> (&'tcx ty::BareFnTy<'tcx>, ty::ExplicitSelfCategory) {\n-        let (bare_fn_ty, optional_explicit_self_category) =\n-            self.ty_of_method_or_bare_fn(sig.unsafety,\n-                                         sig.abi,\n-                                         Some(untransformed_self_ty),\n-                                         &sig.decl);\n-        (bare_fn_ty, optional_explicit_self_category)\n+        self.ty_of_method_or_bare_fn(sig.unsafety,\n+                                     sig.abi,\n+                                     Some(untransformed_self_ty),\n+                                     &sig.decl,\n+                                     None,\n+                                     anon_scope)\n     }\n \n     pub fn ty_of_bare_fn(&self,\n                          unsafety: hir::Unsafety,\n                          abi: abi::Abi,\n-                         decl: &hir::FnDecl)\n+                         decl: &hir::FnDecl,\n+                         anon_scope: Option<AnonTypeScope>)\n                          -> &'tcx ty::BareFnTy<'tcx> {\n-        self.ty_of_method_or_bare_fn(unsafety, abi, None, decl).0\n+        self.ty_of_method_or_bare_fn(unsafety, abi, None, decl, None, anon_scope).0\n     }\n \n-    fn ty_of_method_or_bare_fn<'a>(&self,\n-                                   unsafety: hir::Unsafety,\n-                                   abi: abi::Abi,\n-                                   opt_untransformed_self_ty: Option<Ty<'tcx>>,\n-                                   decl: &hir::FnDecl)\n-                                   -> (&'tcx ty::BareFnTy<'tcx>, ty::ExplicitSelfCategory)\n+    fn ty_of_method_or_bare_fn(&self,\n+                               unsafety: hir::Unsafety,\n+                               abi: abi::Abi,\n+                               opt_untransformed_self_ty: Option<Ty<'tcx>>,\n+                               decl: &hir::FnDecl,\n+                               arg_anon_scope: Option<AnonTypeScope>,\n+                               ret_anon_scope: Option<AnonTypeScope>)\n+                               -> (&'tcx ty::BareFnTy<'tcx>, ty::ExplicitSelfCategory)\n     {\n         debug!(\"ty_of_method_or_bare_fn\");\n \n         // New region names that appear inside of the arguments of the function\n         // declaration are bound to that function type.\n-        let rb = rscope::BindingRscope::new();\n+        let rb = MaybeWithAnonTypes::new(BindingRscope::new(), arg_anon_scope);\n \n         // `implied_output_region` is the region that will be assumed for any\n         // region parameters in the return type. In accordance with the rules for\n@@ -1876,7 +1921,8 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         let output_ty = match decl.output {\n             hir::Return(ref output) =>\n                 ty::FnConverging(self.convert_ty_with_lifetime_elision(implied_output_region,\n-                                                                       &output)),\n+                                                                       &output,\n+                                                                       ret_anon_scope)),\n             hir::DefaultReturn(..) => ty::FnConverging(self.tcx().mk_nil()),\n             hir::NoReturn(..) => ty::FnDiverging\n         };"}, {"sha": "e6ddc6ad69379922d7f94282c66389683edb8c50", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=f55ac6944a88d4da62b30a16cc95893ca050c328", "patch": "@@ -11,7 +11,7 @@\n use middle::free_region::FreeRegionMap;\n use rustc::infer::{self, InferOk, TypeOrigin};\n use rustc::ty;\n-use rustc::traits::{self, ProjectionMode};\n+use rustc::traits::{self, Reveal};\n use rustc::ty::error::ExpectedFound;\n use rustc::ty::subst::{self, Subst, Substs, VecPerParamSpace};\n use rustc::hir::map::Node;\n@@ -213,7 +213,7 @@ pub fn compare_impl_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         return;\n     }\n \n-    tcx.infer_ctxt(None, None, ProjectionMode::AnyFinal).enter(|mut infcx| {\n+    tcx.infer_ctxt(None, None, Reveal::NotSpecializable).enter(|mut infcx| {\n         let mut fulfillment_cx = traits::FulfillmentContext::new();\n \n         // Normalize the associated types in the trait_bounds.\n@@ -433,7 +433,7 @@ pub fn compare_const_impl<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n            impl_trait_ref);\n \n     let tcx = ccx.tcx;\n-    tcx.infer_ctxt(None, None, ProjectionMode::AnyFinal).enter(|infcx| {\n+    tcx.infer_ctxt(None, None, Reveal::NotSpecializable).enter(|infcx| {\n         let mut fulfillment_cx = traits::FulfillmentContext::new();\n \n         // The below is for the most part highly similar to the procedure"}, {"sha": "f65e15430daf75c7de17357c61f1bab01cc2d49a", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=f55ac6944a88d4da62b30a16cc95893ca050c328", "patch": "@@ -17,7 +17,7 @@ use rustc::infer;\n use middle::region;\n use rustc::ty::subst::{self, Subst};\n use rustc::ty::{self, Ty, TyCtxt};\n-use rustc::traits::{self, ProjectionMode};\n+use rustc::traits::{self, Reveal};\n use util::nodemap::FnvHashSet;\n \n use syntax::ast;\n@@ -84,7 +84,7 @@ fn ensure_drop_params_and_item_params_correspond<'a, 'tcx>(\n     // check that the impl type can be made to match the trait type.\n \n     let impl_param_env = ty::ParameterEnvironment::for_item(tcx, self_type_node_id);\n-    tcx.infer_ctxt(None, Some(impl_param_env), ProjectionMode::AnyFinal).enter(|infcx| {\n+    tcx.infer_ctxt(None, Some(impl_param_env), Reveal::NotSpecializable).enter(|infcx| {\n         let tcx = infcx.tcx;\n         let mut fulfillment_cx = traits::FulfillmentContext::new();\n \n@@ -499,7 +499,7 @@ fn iterate_over_potentially_unsafe_regions_in_type<'a, 'b, 'gcx, 'tcx>(\n         }\n \n         // these are always dtorck\n-        ty::TyTrait(..) | ty::TyProjection(_) => bug!(),\n+        ty::TyTrait(..) | ty::TyProjection(_) | ty::TyAnon(..) => bug!(),\n     }\n }\n \n@@ -509,7 +509,7 @@ fn has_dtor_of_interest<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n         ty::TyEnum(def, _) | ty::TyStruct(def, _) => {\n             def.is_dtorck(tcx)\n         }\n-        ty::TyTrait(..) | ty::TyProjection(..) => {\n+        ty::TyTrait(..) | ty::TyProjection(..) | ty::TyAnon(..) => {\n             debug!(\"ty: {:?} isn't known, and therefore is a dropck type\", ty);\n             true\n         },"}, {"sha": "99f1b13d4e4ab422a6c218dd0c202da6812b037e", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=f55ac6944a88d4da62b30a16cc95893ca050c328", "patch": "@@ -786,16 +786,19 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n             debug!(\"assemble_projection_candidates: step={:?}\",\n                    step);\n \n-            let projection_trait_ref = match step.self_ty.sty {\n-                ty::TyProjection(ref data) => &data.trait_ref,\n+            let (def_id, substs) = match step.self_ty.sty {\n+                ty::TyProjection(ref data) => {\n+                    (data.trait_ref.def_id, data.trait_ref.substs)\n+                }\n+                ty::TyAnon(def_id, substs) => (def_id, substs),\n                 _ => continue,\n             };\n \n-            debug!(\"assemble_projection_candidates: projection_trait_ref={:?}\",\n-                   projection_trait_ref);\n+            debug!(\"assemble_projection_candidates: def_id={:?} substs={:?}\",\n+                   def_id, substs);\n \n-            let trait_predicates = self.tcx.lookup_predicates(projection_trait_ref.def_id);\n-            let bounds = trait_predicates.instantiate(self.tcx, projection_trait_ref.substs);\n+            let trait_predicates = self.tcx.lookup_predicates(def_id);\n+            let bounds = trait_predicates.instantiate(self.tcx, substs);\n             let predicates = bounds.predicates.into_vec();\n             debug!(\"assemble_projection_candidates: predicates={:?}\",\n                    predicates);\n@@ -806,9 +809,8 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n             {\n                 let bound = self.erase_late_bound_regions(&poly_bound);\n \n-                debug!(\"assemble_projection_candidates: projection_trait_ref={:?} bound={:?}\",\n-                       projection_trait_ref,\n-                       bound);\n+                debug!(\"assemble_projection_candidates: def_id={:?} substs={:?} bound={:?}\",\n+                       def_id, substs, bound);\n \n                 if self.can_equate(&step.self_ty, &bound.self_ty()).is_ok() {\n                     let xform_self_ty = self.xform_self_ty(&item,"}, {"sha": "c2c93161ce703473e02f90bb0928809b7cb03aed", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 172, "deletions": 149, "changes": 321, "blob_url": "https://github.com/rust-lang/rust/blob/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=f55ac6944a88d4da62b30a16cc95893ca050c328", "patch": "@@ -89,14 +89,14 @@ use hir::def_id::DefId;\n use hir::pat_util;\n use rustc::infer::{self, InferCtxt, InferOk, TypeOrigin, TypeTrace, type_variable};\n use rustc::ty::subst::{self, Subst, Substs, VecPerParamSpace, ParamSpace};\n-use rustc::traits::{self, ProjectionMode};\n+use rustc::traits::{self, Reveal};\n use rustc::ty::{GenericPredicates, TypeScheme};\n use rustc::ty::{ParamTy, ParameterEnvironment};\n use rustc::ty::{LvaluePreference, NoPreference, PreferMutLvalue};\n use rustc::ty::{self, ToPolyTraitRef, Ty, TyCtxt, Visibility};\n use rustc::ty::{MethodCall, MethodCallee};\n use rustc::ty::adjustment;\n-use rustc::ty::fold::TypeFoldable;\n+use rustc::ty::fold::{BottomUpFolder, TypeFoldable};\n use rustc::ty::util::{Representability, IntTypeExt};\n use require_c_abi_if_variadic;\n use rscope::{ElisionFailureInfo, RegionScope};\n@@ -172,6 +172,16 @@ pub struct Inherited<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     deferred_call_resolutions: RefCell<DefIdMap<Vec<DeferredCallResolutionHandler<'gcx, 'tcx>>>>,\n \n     deferred_cast_checks: RefCell<Vec<cast::CastCheck<'tcx>>>,\n+\n+    // Anonymized types found in explicit return types and their\n+    // associated fresh inference variable. Writeback resolves these\n+    // variables to get the concrete type, which can be used to\n+    // deanonymize TyAnon, after typeck is done with all functions.\n+    anon_types: RefCell<DefIdMap<Ty<'tcx>>>,\n+\n+    // Obligations which will have to be checked at the end of\n+    // type-checking, after all functions have been inferred.\n+    deferred_obligations: RefCell<Vec<traits::DeferredObligation<'tcx>>>,\n }\n \n impl<'a, 'gcx, 'tcx> Deref for Inherited<'a, 'gcx, 'tcx> {\n@@ -384,13 +394,14 @@ pub struct InheritedBuilder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n }\n \n impl<'a, 'gcx, 'tcx> CrateCtxt<'a, 'gcx> {\n-    pub fn inherited(&'a self, param_env: Option<ty::ParameterEnvironment<'gcx>>)\n+    pub fn inherited(&'a self, id: ast::NodeId)\n                      -> InheritedBuilder<'a, 'gcx, 'tcx> {\n+        let param_env = ParameterEnvironment::for_item(self.tcx, id);\n         InheritedBuilder {\n             ccx: self,\n             infcx: self.tcx.infer_ctxt(Some(ty::Tables::empty()),\n-                                       param_env,\n-                                       ProjectionMode::AnyFinal)\n+                                       Some(param_env),\n+                                       Reveal::NotSpecializable)\n         }\n     }\n }\n@@ -408,6 +419,8 @@ impl<'a, 'gcx, 'tcx> InheritedBuilder<'a, 'gcx, 'tcx> {\n                 locals: RefCell::new(NodeMap()),\n                 deferred_call_resolutions: RefCell::new(DefIdMap()),\n                 deferred_cast_checks: RefCell::new(Vec::new()),\n+                anon_types: RefCell::new(DefIdMap()),\n+                deferred_obligations: RefCell::new(Vec::new()),\n             })\n         })\n     }\n@@ -442,7 +455,7 @@ impl<'a, 'tcx> Visitor<'tcx> for CheckItemTypesVisitor<'a, 'tcx> {\n     fn visit_ty(&mut self, t: &'tcx hir::Ty) {\n         match t.node {\n             hir::TyFixedLengthVec(_, ref expr) => {\n-                check_const_in_type(self.ccx, &expr, self.ccx.tcx.types.usize);\n+                check_const_with_type(self.ccx, &expr, self.ccx.tcx.types.usize, expr.id);\n             }\n             _ => {}\n         }\n@@ -475,6 +488,31 @@ pub fn check_item_bodies(ccx: &CrateCtxt) -> CompileResult {\n     ccx.tcx.sess.track_errors(|| {\n         let mut visit = CheckItemBodiesVisitor { ccx: ccx };\n         ccx.tcx.visit_all_items_in_krate(DepNode::TypeckItemBody, &mut visit);\n+\n+        // Process deferred obligations, now that all functions\n+        // bodies have been fully inferred.\n+        for (&item_id, obligations) in ccx.deferred_obligations.borrow().iter() {\n+            // Use the same DepNode as for the body of the original function/item.\n+            let def_id = ccx.tcx.map.local_def_id(item_id);\n+            let _task = ccx.tcx.dep_graph.in_task(DepNode::TypeckItemBody(def_id));\n+\n+            let param_env = ParameterEnvironment::for_item(ccx.tcx, item_id);\n+            ccx.tcx.infer_ctxt(None, Some(param_env),\n+                               Reveal::NotSpecializable).enter(|infcx| {\n+                let mut fulfillment_cx = traits::FulfillmentContext::new();\n+                for obligation in obligations.iter().map(|o| o.to_obligation()) {\n+                    fulfillment_cx.register_predicate_obligation(&infcx, obligation);\n+                }\n+\n+                if let Err(errors) = fulfillment_cx.select_all_or_error(&infcx) {\n+                    infcx.report_fulfillment_errors(&errors);\n+                }\n+\n+                if let Err(errors) = fulfillment_cx.select_rfc1592_obligations(&infcx) {\n+                    infcx.report_fulfillment_errors_as_warnings(&errors, item_id);\n+                }\n+            });\n+        }\n     })\n }\n \n@@ -501,17 +539,14 @@ pub fn check_drop_impls(ccx: &CrateCtxt) -> CompileResult {\n fn check_bare_fn<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                            decl: &'tcx hir::FnDecl,\n                            body: &'tcx hir::Block,\n-                           fn_id: ast::NodeId,\n-                           fn_span: Span,\n-                           raw_fty: Ty<'tcx>,\n-                           param_env: ty::ParameterEnvironment<'tcx>)\n-{\n+                           fn_id: ast::NodeId) {\n+    let raw_fty = ccx.tcx.lookup_item_type(ccx.tcx.map.local_def_id(fn_id)).ty;\n     let fn_ty = match raw_fty.sty {\n         ty::TyFnDef(_, _, f) => f,\n         _ => span_bug!(body.span, \"check_bare_fn: function type expected\")\n     };\n \n-    ccx.inherited(Some(param_env)).enter(|inh| {\n+    ccx.inherited(fn_id).enter(|inh| {\n         // Compute the fty from point of view of inside fn.\n         let fn_scope = inh.tcx.region_maps.call_site_extent(fn_id, body.id);\n         let fn_sig =\n@@ -529,8 +564,8 @@ fn check_bare_fn<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         fcx.check_casts();\n         fcx.select_all_obligations_or_error(); // Casts can introduce new obligations.\n \n-        fcx.regionck_fn(fn_id, fn_span, decl, body);\n-        fcx.resolve_type_vars_in_fn(decl, body);\n+        fcx.regionck_fn(fn_id, decl, body);\n+        fcx.resolve_type_vars_in_fn(decl, body, fn_id);\n     });\n }\n \n@@ -631,32 +666,29 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n                             body: &'gcx hir::Block)\n                             -> FnCtxt<'a, 'gcx, 'tcx>\n {\n-    let arg_tys = &fn_sig.inputs;\n-    let ret_ty = fn_sig.output;\n+    let mut fn_sig = fn_sig.clone();\n \n-    debug!(\"check_fn(arg_tys={:?}, ret_ty={:?}, fn_id={})\",\n-           arg_tys,\n-           ret_ty,\n-           fn_id);\n+    debug!(\"check_fn(sig={:?}, fn_id={})\", fn_sig, fn_id);\n \n     // Create the function context.  This is either derived from scratch or,\n     // in the case of function expressions, based on the outer context.\n-    let fcx = FnCtxt::new(inherited, ret_ty, body.id);\n+    let mut fcx = FnCtxt::new(inherited, fn_sig.output, body.id);\n     *fcx.ps.borrow_mut() = UnsafetyState::function(unsafety, unsafety_id);\n \n-    if let ty::FnConverging(ret_ty) = ret_ty {\n-        fcx.require_type_is_sized(ret_ty, decl.output.span(), traits::ReturnType);\n-    }\n-\n-    debug!(\"fn-sig-map: fn_id={} fn_sig={:?}\", fn_id, fn_sig);\n-\n-    inherited.tables.borrow_mut().liberated_fn_sigs.insert(fn_id, fn_sig.clone());\n+    fn_sig.output = match fcx.ret_ty {\n+        ty::FnConverging(orig_ret_ty) => {\n+            fcx.require_type_is_sized(orig_ret_ty, decl.output.span(), traits::ReturnType);\n+            ty::FnConverging(fcx.instantiate_anon_types(&orig_ret_ty))\n+        }\n+        ty::FnDiverging => ty::FnDiverging\n+    };\n+    fcx.ret_ty = fn_sig.output;\n \n     {\n         let mut visit = GatherLocalsVisitor { fcx: &fcx, };\n \n         // Add formal parameters.\n-        for (arg_ty, input) in arg_tys.iter().zip(&decl.inputs) {\n+        for (arg_ty, input) in fn_sig.inputs.iter().zip(&decl.inputs) {\n             // The type of the argument must be well-formed.\n             //\n             // NB -- this is now checked in wfcheck, but that\n@@ -672,21 +704,20 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n             });\n \n             // Check the pattern.\n-            fcx.check_pat(&input.pat, *arg_ty);\n+            fcx.check_pat(&input.pat, arg_ty);\n+            fcx.write_ty(input.id, arg_ty);\n         }\n \n         visit.visit_block(body);\n     }\n \n-    fcx.check_block_with_expected(body, match ret_ty {\n+    inherited.tables.borrow_mut().liberated_fn_sigs.insert(fn_id, fn_sig);\n+\n+    fcx.check_block_with_expected(body, match fcx.ret_ty {\n         ty::FnConverging(result_type) => ExpectHasType(result_type),\n         ty::FnDiverging => NoExpectation\n     });\n \n-    for (input, arg) in decl.inputs.iter().zip(arg_tys) {\n-        fcx.write_ty(input.id, arg);\n-    }\n-\n     fcx\n }\n \n@@ -708,7 +739,7 @@ pub fn check_item_type<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx hir::Item) {\n     match it.node {\n       // Consts can play a role in type-checking, so they are included here.\n       hir::ItemStatic(_, _, ref e) |\n-      hir::ItemConst(_, ref e) => check_const(ccx, it.span, &e, it.id),\n+      hir::ItemConst(_, ref e) => check_const(ccx, &e, it.id),\n       hir::ItemEnum(ref enum_definition, _) => {\n         check_enum_variants(ccx,\n                             it.span,\n@@ -787,23 +818,18 @@ pub fn check_item_body<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx hir::Item) {\n     let _indenter = indenter();\n     match it.node {\n       hir::ItemFn(ref decl, _, _, _, _, ref body) => {\n-        let fn_pty = ccx.tcx.lookup_item_type(ccx.tcx.map.local_def_id(it.id));\n-        let param_env = ParameterEnvironment::for_item(ccx.tcx, it.id);\n-        check_bare_fn(ccx, &decl, &body, it.id, it.span, fn_pty.ty, param_env);\n+        check_bare_fn(ccx, &decl, &body, it.id);\n       }\n       hir::ItemImpl(_, _, _, _, _, ref impl_items) => {\n         debug!(\"ItemImpl {} with id {}\", it.name, it.id);\n \n-        let impl_pty = ccx.tcx.lookup_item_type(ccx.tcx.map.local_def_id(it.id));\n-\n         for impl_item in impl_items {\n             match impl_item.node {\n                 hir::ImplItemKind::Const(_, ref expr) => {\n-                    check_const(ccx, impl_item.span, &expr, impl_item.id)\n+                    check_const(ccx, &expr, impl_item.id)\n                 }\n                 hir::ImplItemKind::Method(ref sig, ref body) => {\n-                    check_method_body(ccx, &impl_pty.generics, sig, body,\n-                                      impl_item.id, impl_item.span);\n+                    check_bare_fn(ccx, &sig.decl, body, impl_item.id);\n                 }\n                 hir::ImplItemKind::Type(_) => {\n                     // Nothing to do here.\n@@ -812,17 +838,15 @@ pub fn check_item_body<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx hir::Item) {\n         }\n       }\n       hir::ItemTrait(_, _, _, ref trait_items) => {\n-        let trait_def = ccx.tcx.lookup_trait_def(ccx.tcx.map.local_def_id(it.id));\n         for trait_item in trait_items {\n             match trait_item.node {\n                 hir::ConstTraitItem(_, Some(ref expr)) => {\n-                    check_const(ccx, trait_item.span, &expr, trait_item.id)\n+                    check_const(ccx, &expr, trait_item.id)\n                 }\n                 hir::MethodTraitItem(ref sig, Some(ref body)) => {\n                     check_trait_fn_not_const(ccx, trait_item.span, sig.constness);\n \n-                    check_method_body(ccx, &trait_def.generics, sig, body,\n-                                      trait_item.id, trait_item.span);\n+                    check_bare_fn(ccx, &sig.decl, body, trait_item.id);\n                 }\n                 hir::MethodTraitItem(ref sig, None) => {\n                     check_trait_fn_not_const(ccx, trait_item.span, sig.constness);\n@@ -899,29 +923,6 @@ fn check_on_unimplemented<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     }\n }\n \n-/// Type checks a method body.\n-///\n-/// # Parameters\n-///\n-/// * `item_generics`: generics defined on the impl/trait that contains\n-///   the method\n-/// * `self_bound`: bound for the `Self` type parameter, if any\n-/// * `method`: the method definition\n-fn check_method_body<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n-                               item_generics: &ty::Generics<'tcx>,\n-                               sig: &'tcx hir::MethodSig,\n-                               body: &'tcx hir::Block,\n-                               id: ast::NodeId, span: Span) {\n-    debug!(\"check_method_body(item_generics={:?}, id={})\",\n-            item_generics, id);\n-    let param_env = ParameterEnvironment::for_item(ccx.tcx, id);\n-\n-    let fty = ccx.tcx.node_id_to_type(id);\n-    debug!(\"check_method_body: fty={:?}\", fty);\n-\n-    check_bare_fn(ccx, &sig.decl, body, id, span, fty, param_env);\n-}\n-\n fn report_forbidden_specialization<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                              impl_item: &hir::ImplItem,\n                                              parent_impl: DefId)\n@@ -1160,30 +1161,39 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     }\n }\n \n-/// Checks a constant appearing in a type. At the moment this is just the\n-/// length expression in a fixed-length vector, but someday it might be\n-/// extended to type-level numeric literals.\n-fn check_const_in_type<'a,'tcx>(ccx: &'a CrateCtxt<'a,'tcx>,\n-                                expr: &'tcx hir::Expr,\n-                                expected_type: Ty<'tcx>) {\n-    ccx.inherited(None).enter(|inh| {\n+/// Checks a constant with a given type.\n+fn check_const_with_type<'a, 'tcx>(ccx: &'a CrateCtxt<'a, 'tcx>,\n+                                   expr: &'tcx hir::Expr,\n+                                   expected_type: Ty<'tcx>,\n+                                   id: ast::NodeId) {\n+    ccx.inherited(id).enter(|inh| {\n         let fcx = FnCtxt::new(&inh, ty::FnConverging(expected_type), expr.id);\n-        fcx.check_const_with_ty(expr.span, expr, expected_type);\n+        fcx.require_type_is_sized(expected_type, expr.span, traits::ConstSized);\n+\n+        // Gather locals in statics (because of block expressions).\n+        // This is technically unnecessary because locals in static items are forbidden,\n+        // but prevents type checking from blowing up before const checking can properly\n+        // emit an error.\n+        GatherLocalsVisitor { fcx: &fcx }.visit_expr(expr);\n+\n+        fcx.check_expr_coercable_to_type(expr, expected_type);\n+\n+        fcx.select_all_obligations_and_apply_defaults();\n+        fcx.closure_analyze_const(expr);\n+        fcx.select_obligations_where_possible();\n+        fcx.check_casts();\n+        fcx.select_all_obligations_or_error();\n+\n+        fcx.regionck_expr(expr);\n+        fcx.resolve_type_vars_in_expr(expr, id);\n     });\n }\n \n-fn check_const<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n-                        sp: Span,\n-                        e: &'tcx hir::Expr,\n-                        id: ast::NodeId) {\n-    let param_env = ParameterEnvironment::for_item(ccx.tcx, id);\n-    ccx.inherited(Some(param_env)).enter(|inh| {\n-        let rty = ccx.tcx.node_id_to_type(id);\n-        let fcx = FnCtxt::new(&inh, ty::FnConverging(rty), e.id);\n-        let declty = fcx.tcx.lookup_item_type(ccx.tcx.map.local_def_id(id)).ty;\n-        fcx.require_type_is_sized(declty, e.span, traits::ConstSized);\n-        fcx.check_const_with_ty(sp, e, declty);\n-    });\n+fn check_const<'a, 'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n+                         expr: &'tcx hir::Expr,\n+                         id: ast::NodeId) {\n+    let decl_ty = ccx.tcx.lookup_item_type(ccx.tcx.map.local_def_id(id)).ty;\n+    check_const_with_type(ccx, expr, decl_ty, id);\n }\n \n /// Checks whether a type can be represented in memory. In particular, it\n@@ -1252,45 +1262,40 @@ pub fn check_enum_variants<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n             \"unsupported representation for zero-variant enum\");\n     }\n \n-    ccx.inherited(None).enter(|inh| {\n-        let rty = ccx.tcx.node_id_to_type(id);\n-        let fcx = FnCtxt::new(&inh, ty::FnConverging(rty), id);\n-\n-        let repr_type_ty = ccx.tcx.enum_repr_type(Some(&hint)).to_ty(ccx.tcx);\n-        for v in vs {\n-            if let Some(ref e) = v.node.disr_expr {\n-                fcx.check_const_with_ty(e.span, e, repr_type_ty);\n-            }\n+    let repr_type_ty = ccx.tcx.enum_repr_type(Some(&hint)).to_ty(ccx.tcx);\n+    for v in vs {\n+        if let Some(ref e) = v.node.disr_expr {\n+            check_const_with_type(ccx, e, repr_type_ty, e.id);\n         }\n+    }\n \n-        let def_id = ccx.tcx.map.local_def_id(id);\n-\n-        let variants = &ccx.tcx.lookup_adt_def(def_id).variants;\n-        let mut disr_vals: Vec<ty::Disr> = Vec::new();\n-        for (v, variant) in vs.iter().zip(variants.iter()) {\n-            let current_disr_val = variant.disr_val;\n+    let def_id = ccx.tcx.map.local_def_id(id);\n \n-            // Check for duplicate discriminant values\n-            if let Some(i) = disr_vals.iter().position(|&x| x == current_disr_val) {\n-                let variant_i_node_id = ccx.tcx.map.as_local_node_id(variants[i].did).unwrap();\n-                let variant_i = ccx.tcx.map.expect_variant(variant_i_node_id);\n-                let i_span = match variant_i.node.disr_expr {\n-                    Some(ref expr) => expr.span,\n-                    None => ccx.tcx.map.span(variant_i_node_id)\n-                };\n-                let span = match v.node.disr_expr {\n-                    Some(ref expr) => expr.span,\n-                    None => v.span\n-                };\n-                struct_span_err!(ccx.tcx.sess, span, E0081,\n-                                 \"discriminant value `{}` already exists\", disr_vals[i])\n-                    .span_label(i_span, &format!(\"first use of `{}`\", disr_vals[i]))\n-                    .span_label(span , &format!(\"enum already has `{}`\", disr_vals[i]))\n-                    .emit();\n-            }\n-            disr_vals.push(current_disr_val);\n+    let variants = &ccx.tcx.lookup_adt_def(def_id).variants;\n+    let mut disr_vals: Vec<ty::Disr> = Vec::new();\n+    for (v, variant) in vs.iter().zip(variants.iter()) {\n+        let current_disr_val = variant.disr_val;\n+\n+        // Check for duplicate discriminant values\n+        if let Some(i) = disr_vals.iter().position(|&x| x == current_disr_val) {\n+            let variant_i_node_id = ccx.tcx.map.as_local_node_id(variants[i].did).unwrap();\n+            let variant_i = ccx.tcx.map.expect_variant(variant_i_node_id);\n+            let i_span = match variant_i.node.disr_expr {\n+                Some(ref expr) => expr.span,\n+                None => ccx.tcx.map.span(variant_i_node_id)\n+            };\n+            let span = match v.node.disr_expr {\n+                Some(ref expr) => expr.span,\n+                None => v.span\n+            };\n+            struct_span_err!(ccx.tcx.sess, span, E0081,\n+                             \"discriminant value `{}` already exists\", disr_vals[i])\n+                .span_label(i_span, &format!(\"first use of `{}`\", disr_vals[i]))\n+                .span_label(span , &format!(\"enum already has `{}`\", disr_vals[i]))\n+                .emit();\n         }\n-    });\n+        disr_vals.push(current_disr_val);\n+    }\n \n     check_representable(ccx.tcx, sp, id, \"enum\");\n }\n@@ -1623,6 +1628,41 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n+    /// Replace all anonymized types with fresh inference variables\n+    /// and record them for writeback.\n+    fn instantiate_anon_types<T: TypeFoldable<'tcx>>(&self, value: &T) -> T {\n+        value.fold_with(&mut BottomUpFolder { tcx: self.tcx, fldop: |ty| {\n+            if let ty::TyAnon(def_id, substs) = ty.sty {\n+                // Use the same type variable if the exact same TyAnon appears more\n+                // than once in the return type (e.g. if it's pased to a type alias).\n+                if let Some(ty_var) = self.anon_types.borrow().get(&def_id) {\n+                    return ty_var;\n+                }\n+                let ty_var = self.next_ty_var();\n+                self.anon_types.borrow_mut().insert(def_id, ty_var);\n+\n+                let item_predicates = self.tcx.lookup_predicates(def_id);\n+                let bounds = item_predicates.instantiate(self.tcx, substs);\n+\n+                let span = self.tcx.map.def_id_span(def_id, codemap::DUMMY_SP);\n+                for predicate in bounds.predicates {\n+                    // Change the predicate to refer to the type variable,\n+                    // which will be the concrete type, instead of the TyAnon.\n+                    // This also instantiates nested `impl Trait`.\n+                    let predicate = self.instantiate_anon_types(&predicate);\n+\n+                    // Require that the predicate holds for the concrete type.\n+                    let cause = traits::ObligationCause::new(span, self.body_id,\n+                                                             traits::ReturnType);\n+                    self.register_predicate(traits::Obligation::new(cause, predicate));\n+                }\n+\n+                ty_var\n+            } else {\n+                ty\n+            }\n+        }})\n+    }\n \n     fn normalize_associated_types_in<T>(&self, span: Span, value: &T) -> T\n         where T : TypeFoldable<'tcx>\n@@ -2190,6 +2230,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         self.select_all_obligations_and_apply_defaults();\n \n         let mut fulfillment_cx = self.fulfillment_cx.borrow_mut();\n+\n+        // Steal the deferred obligations before the fulfillment\n+        // context can turn all of them into errors.\n+        let obligations = fulfillment_cx.take_deferred_obligations();\n+        self.deferred_obligations.borrow_mut().extend(obligations);\n+\n         match fulfillment_cx.select_all_or_error(self) {\n             Ok(()) => { }\n             Err(errors) => { self.report_fulfillment_errors(&errors); }\n@@ -3998,29 +4044,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         *self.ps.borrow_mut() = prev;\n     }\n \n-\n-    fn check_const_with_ty(&self,\n-                           _: Span,\n-                           e: &'gcx hir::Expr,\n-                           declty: Ty<'tcx>) {\n-        // Gather locals in statics (because of block expressions).\n-        // This is technically unnecessary because locals in static items are forbidden,\n-        // but prevents type checking from blowing up before const checking can properly\n-        // emit an error.\n-        GatherLocalsVisitor { fcx: self }.visit_expr(e);\n-\n-        self.check_expr_coercable_to_type(e, declty);\n-\n-        self.select_all_obligations_and_apply_defaults();\n-        self.closure_analyze_const(e);\n-        self.select_obligations_where_possible();\n-        self.check_casts();\n-        self.select_all_obligations_or_error();\n-\n-        self.regionck_expr(e);\n-        self.resolve_type_vars_in_expr(e);\n-    }\n-\n     // Returns the type parameter count and the type for the given definition.\n     fn type_scheme_and_predicates_for_def(&self,\n                                           sp: Span,"}, {"sha": "f3a6442f35d1127721bf424710b864d8e4d26847", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=f55ac6944a88d4da62b30a16cc95893ca050c328", "patch": "@@ -141,15 +141,14 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n     pub fn regionck_fn(&self,\n                        fn_id: ast::NodeId,\n-                       fn_span: Span,\n                        decl: &hir::FnDecl,\n                        blk: &hir::Block) {\n         debug!(\"regionck_fn(id={})\", fn_id);\n         let mut rcx = RegionCtxt::new(self, RepeatingScope(blk.id), blk.id, Subject(fn_id));\n \n         if self.err_count_since_creation() == 0 {\n             // regionck assumes typeck succeeded\n-            rcx.visit_fn_body(fn_id, decl, blk, fn_span);\n+            rcx.visit_fn_body(fn_id, decl, blk, self.tcx.map.span(fn_id));\n         }\n \n         rcx.free_region_map.relate_free_regions_from_predicates("}, {"sha": "e2080906ca24294c9f029cdbcfbe7a6bf1e08c8a", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=f55ac6944a88d4da62b30a16cc95893ca050c328", "patch": "@@ -209,9 +209,8 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n \n     fn for_id<'tcx>(&self, id: ast::NodeId, span: Span)\n                     -> CheckWfFcxBuilder<'ccx, 'gcx, 'tcx> {\n-        let param_env = ty::ParameterEnvironment::for_item(self.ccx.tcx, id);\n         CheckWfFcxBuilder {\n-            inherited: self.ccx.inherited(Some(param_env)),\n+            inherited: self.ccx.inherited(id),\n             code: self.code.clone(),\n             id: id,\n             span: span"}, {"sha": "9026920e7f48abb0936f7e02165516c39bc5e72a", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 132, "deletions": 13, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=f55ac6944a88d4da62b30a16cc95893ca050c328", "patch": "@@ -18,7 +18,9 @@ use hir::def_id::DefId;\n use rustc::ty::{self, Ty, TyCtxt, MethodCall, MethodCallee};\n use rustc::ty::adjustment;\n use rustc::ty::fold::{TypeFolder,TypeFoldable};\n+use rustc::ty::subst::ParamSpace;\n use rustc::infer::{InferCtxt, FixupError};\n+use rustc::util::nodemap::DefIdMap;\n use write_substs_to_tcx;\n use write_ty_to_tcx;\n \n@@ -35,17 +37,21 @@ use rustc::hir::{self, PatKind};\n // Entry point functions\n \n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n-    pub fn resolve_type_vars_in_expr(&self, e: &hir::Expr) {\n+    pub fn resolve_type_vars_in_expr(&self, e: &hir::Expr, item_id: ast::NodeId) {\n         assert_eq!(self.writeback_errors.get(), false);\n         let mut wbcx = WritebackCx::new(self);\n         wbcx.visit_expr(e);\n         wbcx.visit_upvar_borrow_map();\n         wbcx.visit_closures();\n         wbcx.visit_liberated_fn_sigs();\n         wbcx.visit_fru_field_types();\n+        wbcx.visit_deferred_obligations(item_id);\n     }\n \n-    pub fn resolve_type_vars_in_fn(&self, decl: &hir::FnDecl, blk: &hir::Block) {\n+    pub fn resolve_type_vars_in_fn(&self,\n+                                   decl: &hir::FnDecl,\n+                                   blk: &hir::Block,\n+                                   item_id: ast::NodeId) {\n         assert_eq!(self.writeback_errors.get(), false);\n         let mut wbcx = WritebackCx::new(self);\n         wbcx.visit_block(blk);\n@@ -62,6 +68,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         wbcx.visit_closures();\n         wbcx.visit_liberated_fn_sigs();\n         wbcx.visit_fru_field_types();\n+        wbcx.visit_anon_types();\n+        wbcx.visit_deferred_obligations(item_id);\n     }\n }\n \n@@ -75,11 +83,48 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n struct WritebackCx<'cx, 'gcx: 'cx+'tcx, 'tcx: 'cx> {\n     fcx: &'cx FnCtxt<'cx, 'gcx, 'tcx>,\n+\n+    // Mapping from free regions of the function to the\n+    // early-bound versions of them, visible from the\n+    // outside of the function. This is needed by, and\n+    // only populated if there are any `impl Trait`.\n+    free_to_bound_regions: DefIdMap<ty::Region>\n }\n \n impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n     fn new(fcx: &'cx FnCtxt<'cx, 'gcx, 'tcx>) -> WritebackCx<'cx, 'gcx, 'tcx> {\n-        WritebackCx { fcx: fcx }\n+        let mut wbcx = WritebackCx {\n+            fcx: fcx,\n+            free_to_bound_regions: DefIdMap()\n+        };\n+\n+        // Only build the reverse mapping if `impl Trait` is used.\n+        if fcx.anon_types.borrow().is_empty() {\n+            return wbcx;\n+        }\n+\n+        let free_substs = fcx.parameter_environment.free_substs;\n+        for &space in &ParamSpace::all() {\n+            for (i, r) in free_substs.regions.get_slice(space).iter().enumerate() {\n+                match *r {\n+                    ty::ReFree(ty::FreeRegion {\n+                        bound_region: ty::BoundRegion::BrNamed(def_id, name, _), ..\n+                    }) => {\n+                        let bound_region = ty::ReEarlyBound(ty::EarlyBoundRegion {\n+                            space: space,\n+                            index: i as u32,\n+                            name: name,\n+                        });\n+                        wbcx.free_to_bound_regions.insert(def_id, bound_region);\n+                    }\n+                    _ => {\n+                        bug!(\"{:?} is not a free region for an early-bound lifetime\", r);\n+                    }\n+                }\n+            }\n+        }\n+\n+        wbcx\n     }\n \n     fn tcx(&self) -> TyCtxt<'cx, 'gcx, 'tcx> {\n@@ -255,6 +300,58 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n         }\n     }\n \n+    fn visit_anon_types(&self) {\n+        if self.fcx.writeback_errors.get() {\n+            return\n+        }\n+\n+        let gcx = self.tcx().global_tcx();\n+        for (&def_id, &concrete_ty) in self.fcx.anon_types.borrow().iter() {\n+            let reason = ResolvingAnonTy(def_id);\n+            let inside_ty = self.resolve(&concrete_ty, reason);\n+\n+            // Convert the type from the function into a type valid outside\n+            // the function, by replacing free regions with early-bound ones.\n+            let outside_ty = gcx.fold_regions(&inside_ty, &mut false, |r, _| {\n+                match r {\n+                    // 'static is valid everywhere.\n+                    ty::ReStatic => ty::ReStatic,\n+\n+                    // Free regions that come from early-bound regions are valid.\n+                    ty::ReFree(ty::FreeRegion {\n+                        bound_region: ty::BoundRegion::BrNamed(def_id, _, _), ..\n+                    }) if self.free_to_bound_regions.contains_key(&def_id) => {\n+                        self.free_to_bound_regions[&def_id]\n+                    }\n+\n+                    ty::ReFree(_) |\n+                    ty::ReEarlyBound(_) |\n+                    ty::ReLateBound(..) |\n+                    ty::ReScope(_) |\n+                    ty::ReSkolemized(..) => {\n+                        let span = reason.span(self.tcx());\n+                        span_err!(self.tcx().sess, span, E0564,\n+                                  \"only named lifetimes are allowed in `impl Trait`, \\\n+                                   but `{}` was found in the type `{}`\", r, inside_ty);\n+                        ty::ReStatic\n+                    }\n+\n+                    ty::ReVar(_) |\n+                    ty::ReEmpty |\n+                    ty::ReErased => {\n+                        let span = reason.span(self.tcx());\n+                        span_bug!(span, \"invalid region in impl Trait: {:?}\", r);\n+                    }\n+                }\n+            });\n+\n+            gcx.tcache.borrow_mut().insert(def_id, ty::TypeScheme {\n+                ty: outside_ty,\n+                generics: ty::Generics::empty()\n+            });\n+        }\n+    }\n+\n     fn visit_node_id(&self, reason: ResolveReason, id: ast::NodeId) {\n         // Resolve any borrowings for the node with id `id`\n         self.visit_adjustments(reason, id);\n@@ -353,6 +450,19 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n         }\n     }\n \n+    fn visit_deferred_obligations(&self, item_id: ast::NodeId) {\n+        let deferred_obligations = self.fcx.deferred_obligations.borrow();\n+        let obligations: Vec<_> = deferred_obligations.iter().map(|obligation| {\n+            let reason = ResolvingDeferredObligation(obligation.cause.span);\n+            self.resolve(obligation, reason)\n+        }).collect();\n+\n+        if !obligations.is_empty() {\n+            assert!(self.fcx.ccx.deferred_obligations.borrow_mut()\n+                                .insert(item_id, obligations).is_none());\n+        }\n+    }\n+\n     fn resolve<T>(&self, x: &T, reason: ResolveReason) -> T::Lifted\n         where T: TypeFoldable<'tcx> + ty::Lift<'gcx>\n     {\n@@ -369,15 +479,17 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n ///////////////////////////////////////////////////////////////////////////\n // Resolution reason.\n \n-#[derive(Copy, Clone)]\n+#[derive(Copy, Clone, Debug)]\n enum ResolveReason {\n     ResolvingExpr(Span),\n     ResolvingLocal(Span),\n     ResolvingPattern(Span),\n     ResolvingUpvar(ty::UpvarId),\n     ResolvingClosure(DefId),\n     ResolvingFnSig(ast::NodeId),\n-    ResolvingFieldTypes(ast::NodeId)\n+    ResolvingFieldTypes(ast::NodeId),\n+    ResolvingAnonTy(DefId),\n+    ResolvingDeferredObligation(Span),\n }\n \n impl<'a, 'gcx, 'tcx> ResolveReason {\n@@ -395,13 +507,11 @@ impl<'a, 'gcx, 'tcx> ResolveReason {\n             ResolvingFieldTypes(id) => {\n                 tcx.map.span(id)\n             }\n-            ResolvingClosure(did) => {\n-                if let Some(node_id) = tcx.map.as_local_node_id(did) {\n-                    tcx.expr_span(node_id)\n-                } else {\n-                    DUMMY_SP\n-                }\n+            ResolvingClosure(did) |\n+            ResolvingAnonTy(did) => {\n+                tcx.map.def_id_span(did, DUMMY_SP)\n             }\n+            ResolvingDeferredObligation(span) => span\n         }\n     }\n }\n@@ -474,14 +584,23 @@ impl<'cx, 'gcx, 'tcx> Resolver<'cx, 'gcx, 'tcx> {\n                               \"cannot determine a type for this closure\")\n                 }\n \n-                ResolvingFnSig(id) | ResolvingFieldTypes(id) => {\n+                ResolvingFnSig(_) |\n+                ResolvingFieldTypes(_) |\n+                ResolvingDeferredObligation(_) => {\n                     // any failures here should also fail when\n                     // resolving the patterns, closure types, or\n                     // something else.\n                     let span = self.reason.span(self.tcx);\n                     self.tcx.sess.delay_span_bug(\n                         span,\n-                        &format!(\"cannot resolve some aspect of data for {:?}\", id));\n+                        &format!(\"cannot resolve some aspect of data for {:?}: {}\",\n+                                 self.reason, e));\n+                }\n+\n+                ResolvingAnonTy(_) => {\n+                    let span = self.reason.span(self.tcx);\n+                    span_err!(self.tcx.sess, span, E0563,\n+                              \"cannot determine a type for this `impl Trait`: {}\", e)\n                 }\n             }\n         }"}, {"sha": "13deac57330e3b28e5c44914b07b439d29d905cc", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=f55ac6944a88d4da62b30a16cc95893ca050c328", "patch": "@@ -19,15 +19,15 @@ use hir::def_id::DefId;\n use middle::lang_items::UnsizeTraitLangItem;\n use rustc::ty::subst::{self, Subst};\n use rustc::ty::{self, TyCtxt, TypeFoldable};\n-use rustc::traits::{self, ProjectionMode};\n+use rustc::traits::{self, Reveal};\n use rustc::ty::{ImplOrTraitItemId, ConstTraitItemId};\n use rustc::ty::{MethodTraitItemId, TypeTraitItemId, ParameterEnvironment};\n use rustc::ty::{Ty, TyBool, TyChar, TyEnum, TyError};\n use rustc::ty::{TyParam, TyRawPtr};\n use rustc::ty::{TyRef, TyStruct, TyTrait, TyTuple};\n use rustc::ty::{TyStr, TyArray, TySlice, TyFloat, TyInfer, TyInt};\n use rustc::ty::{TyUint, TyClosure, TyBox, TyFnDef, TyFnPtr};\n-use rustc::ty::TyProjection;\n+use rustc::ty::{TyProjection, TyAnon};\n use rustc::ty::util::CopyImplementationError;\n use middle::free_region::FreeRegionMap;\n use CrateCtxt;\n@@ -89,7 +89,7 @@ impl<'a, 'gcx, 'tcx> CoherenceChecker<'a, 'gcx, 'tcx> {\n                 None\n             }\n \n-            TyInfer(..) | TyClosure(..) => {\n+            TyInfer(..) | TyClosure(..) | TyAnon(..) => {\n                 // `ty` comes from a user declaration so we should only expect types\n                 // that the user can type\n                 span_bug!(\n@@ -399,7 +399,7 @@ impl<'a, 'gcx, 'tcx> CoherenceChecker<'a, 'gcx, 'tcx> {\n             debug!(\"check_implementations_of_coerce_unsized: {:?} -> {:?} (free)\",\n                    source, target);\n \n-            tcx.infer_ctxt(None, Some(param_env), ProjectionMode::Topmost).enter(|infcx| {\n+            tcx.infer_ctxt(None, Some(param_env), Reveal::ExactMatch).enter(|infcx| {\n                 let origin = TypeOrigin::Misc(span);\n                 let check_mutbl = |mt_a: ty::TypeAndMut<'gcx>, mt_b: ty::TypeAndMut<'gcx>,\n                                    mk_ptr: &Fn(Ty<'gcx>) -> Ty<'gcx>| {\n@@ -536,7 +536,7 @@ fn enforce_trait_manually_implementable(tcx: TyCtxt, sp: Span, trait_def_id: Def\n \n pub fn check_coherence(ccx: &CrateCtxt) {\n     let _task = ccx.tcx.dep_graph.in_task(DepNode::Coherence);\n-    ccx.tcx.infer_ctxt(None, None, ProjectionMode::Topmost).enter(|infcx| {\n+    ccx.tcx.infer_ctxt(None, None, Reveal::ExactMatch).enter(|infcx| {\n         CoherenceChecker {\n             crate_context: ccx,\n             inference_context: infcx,"}, {"sha": "46a9ef8d5babb0edcc4fe4de4e44894e41910425", "filename": "src/librustc_typeck/coherence/overlap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs?ref=f55ac6944a88d4da62b30a16cc95893ca050c328", "patch": "@@ -13,7 +13,7 @@\n //! constructor provide a method with the same name.\n \n use hir::def_id::DefId;\n-use rustc::traits::{self, ProjectionMode};\n+use rustc::traits::{self, Reveal};\n use rustc::ty::{self, TyCtxt};\n use syntax::ast;\n use rustc::dep_graph::DepNode;\n@@ -84,7 +84,7 @@ impl<'cx, 'tcx> OverlapChecker<'cx, 'tcx> {\n \n         for (i, &impl1_def_id) in impls.iter().enumerate() {\n             for &impl2_def_id in &impls[(i+1)..] {\n-                self.tcx.infer_ctxt(None, None, ProjectionMode::Topmost).enter(|infcx| {\n+                self.tcx.infer_ctxt(None, None, Reveal::ExactMatch).enter(|infcx| {\n                     if traits::overlapping_impls(&infcx, impl1_def_id, impl2_def_id).is_some() {\n                         self.check_for_common_items_in_impls(impl1_def_id, impl2_def_id)\n                     }"}, {"sha": "75bfad053a32855c9d6f079b67bcf3465429c019", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 72, "deletions": 82, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=f55ac6944a88d4da62b30a16cc95893ca050c328", "patch": "@@ -564,13 +564,17 @@ fn convert_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     let ty_generic_predicates =\n         ty_generic_predicates_for_fn(ccx, &sig.generics, rcvr_ty_predicates);\n \n-    let (fty, explicit_self_category) =\n+    let (fty, explicit_self_category) = {\n+        let anon_scope = match container {\n+            ImplContainer(_) => Some(AnonTypeScope::new(&ty_generics)),\n+            TraitContainer(_) => None\n+        };\n         AstConv::ty_of_method(&ccx.icx(&(rcvr_ty_predicates, &sig.generics)),\n-                              sig,\n-                              untransformed_rcvr_ty);\n+                              sig, untransformed_rcvr_ty, anon_scope)\n+    };\n \n     let def_id = ccx.tcx.map.local_def_id(id);\n-    let substs = mk_item_substs(ccx, &ty_generics);\n+    let substs = mk_item_substs(ccx.tcx, &ty_generics);\n \n     let ty_method = ty::Method::new(name,\n                                     ty_generics,\n@@ -961,7 +965,7 @@ fn convert_variant_ctor<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                 .map(|field| field.unsubst_ty())\n                 .collect();\n             let def_id = tcx.map.local_def_id(ctor_id);\n-            let substs = mk_item_substs(ccx, &scheme.generics);\n+            let substs = mk_item_substs(tcx, &scheme.generics);\n             tcx.mk_fn_def(def_id, substs, tcx.mk_bare_fn(ty::BareFnTy {\n                 unsafety: hir::Unsafety::Normal,\n                 abi: abi::Abi::Rust,\n@@ -1190,10 +1194,11 @@ fn ensure_super_predicates_step(ccx: &CrateCtxt,\n         // Convert the bounds that follow the colon, e.g. `Bar+Zed` in `trait Foo : Bar+Zed`.\n         let self_param_ty = tcx.mk_self_type();\n         let superbounds1 = compute_bounds(&ccx.icx(scope),\n-                                    self_param_ty,\n-                                    bounds,\n-                                    SizedByDefault::No,\n-                                    item.span);\n+                                          self_param_ty,\n+                                          bounds,\n+                                          SizedByDefault::No,\n+                                          None,\n+                                          item.span);\n \n         let superbounds1 = superbounds1.predicates(tcx, self_param_ty);\n \n@@ -1403,6 +1408,7 @@ fn convert_trait_predicates<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, it: &hir::Item)\n                                         assoc_ty,\n                                         bounds,\n                                         SizedByDefault::Yes,\n+                                        None,\n                                         trait_item.span);\n \n             bounds.predicates(ccx.tcx, assoc_ty).into_iter()\n@@ -1460,9 +1466,10 @@ fn compute_type_scheme_of_item<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n         }\n         hir::ItemFn(ref decl, unsafety, _, abi, ref generics, _) => {\n             let ty_generics = ty_generics_for_fn(ccx, generics, &ty::Generics::empty());\n-            let tofd = AstConv::ty_of_bare_fn(&ccx.icx(generics), unsafety, abi, &decl);\n+            let tofd = AstConv::ty_of_bare_fn(&ccx.icx(generics), unsafety, abi, &decl,\n+                                              Some(AnonTypeScope::new(&ty_generics)));\n             let def_id = ccx.tcx.map.local_def_id(it.id);\n-            let substs = mk_item_substs(ccx, &ty_generics);\n+            let substs = mk_item_substs(tcx, &ty_generics);\n             let ty = tcx.mk_fn_def(def_id, substs, tofd);\n             ty::TypeScheme { ty: ty, generics: ty_generics }\n         }\n@@ -1474,14 +1481,14 @@ fn compute_type_scheme_of_item<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n         hir::ItemEnum(ref ei, ref generics) => {\n             let def = convert_enum_def(ccx, it, ei);\n             let ty_generics = ty_generics_for_type(ccx, generics);\n-            let substs = mk_item_substs(ccx, &ty_generics);\n+            let substs = mk_item_substs(tcx, &ty_generics);\n             let t = tcx.mk_enum(def, substs);\n             ty::TypeScheme { ty: t, generics: ty_generics }\n         }\n         hir::ItemStruct(ref si, ref generics) => {\n             let def = convert_struct_def(ccx, it, si);\n             let ty_generics = ty_generics_for_type(ccx, generics);\n-            let substs = mk_item_substs(ccx, &ty_generics);\n+            let substs = mk_item_substs(tcx, &ty_generics);\n             let t = tcx.mk_struct(def, substs);\n             ty::TypeScheme { ty: t, generics: ty_generics }\n         }\n@@ -1694,10 +1701,10 @@ fn ty_generic_predicates_for_fn<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n }\n \n // Add the Sized bound, unless the type parameter is marked as `?Sized`.\n-fn add_unsized_bound<'tcx>(astconv: &AstConv<'tcx, 'tcx>,\n-                           bounds: &mut ty::BuiltinBounds,\n-                           ast_bounds: &[hir::TyParamBound],\n-                           span: Span)\n+fn add_unsized_bound<'gcx: 'tcx, 'tcx>(astconv: &AstConv<'gcx, 'tcx>,\n+                                       bounds: &mut ty::BuiltinBounds,\n+                                       ast_bounds: &[hir::TyParamBound],\n+                                       span: Span)\n {\n     let tcx = astconv.tcx();\n \n@@ -1775,6 +1782,7 @@ fn ty_generic_predicates<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n                                     param_ty,\n                                     &param.bounds,\n                                     SizedByDefault::Yes,\n+                                    None,\n                                     param.span);\n         let predicates = bounds.predicates(ccx.tcx, param_ty);\n         result.predicates.extend(space, predicates.into_iter());\n@@ -2038,34 +2046,52 @@ fn compute_object_lifetime_default<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n     }\n }\n \n-enum SizedByDefault { Yes, No, }\n+pub enum SizedByDefault { Yes, No, }\n \n /// Translate the AST's notion of ty param bounds (which are an enum consisting of a newtyped Ty or\n /// a region) to ty's notion of ty param bounds, which can either be user-defined traits, or the\n /// built-in trait (formerly known as kind): Send.\n-fn compute_bounds<'tcx>(astconv: &AstConv<'tcx, 'tcx>,\n-                        param_ty: ty::Ty<'tcx>,\n-                        ast_bounds: &[hir::TyParamBound],\n-                        sized_by_default: SizedByDefault,\n-                        span: Span)\n-                        -> Bounds<'tcx>\n+pub fn compute_bounds<'gcx: 'tcx, 'tcx>(astconv: &AstConv<'gcx, 'tcx>,\n+                                        param_ty: ty::Ty<'tcx>,\n+                                        ast_bounds: &[hir::TyParamBound],\n+                                        sized_by_default: SizedByDefault,\n+                                        anon_scope: Option<AnonTypeScope>,\n+                                        span: Span)\n+                                        -> Bounds<'tcx>\n {\n-    let mut bounds =\n-        conv_param_bounds(astconv,\n-                          span,\n-                          param_ty,\n-                          ast_bounds);\n+    let tcx = astconv.tcx();\n+    let PartitionedBounds {\n+        mut builtin_bounds,\n+        trait_bounds,\n+        region_bounds\n+    } = partition_bounds(tcx, span, &ast_bounds);\n \n     if let SizedByDefault::Yes = sized_by_default {\n-        add_unsized_bound(astconv,\n-                          &mut bounds.builtin_bounds,\n-                          ast_bounds,\n-                          span);\n+        add_unsized_bound(astconv, &mut builtin_bounds, ast_bounds, span);\n     }\n \n-    bounds.trait_bounds.sort_by(|a,b| a.def_id().cmp(&b.def_id()));\n+    let mut projection_bounds = vec![];\n \n-    bounds\n+    let rscope = MaybeWithAnonTypes::new(ExplicitRscope, anon_scope);\n+    let mut trait_bounds: Vec<_> = trait_bounds.iter().map(|&bound| {\n+        astconv.instantiate_poly_trait_ref(&rscope,\n+                                           bound,\n+                                           Some(param_ty),\n+                                           &mut projection_bounds)\n+    }).collect();\n+\n+    let region_bounds = region_bounds.into_iter().map(|r| {\n+        ast_region_to_region(tcx, r)\n+    }).collect();\n+\n+    trait_bounds.sort_by(|a,b| a.def_id().cmp(&b.def_id()));\n+\n+    Bounds {\n+        region_bounds: region_bounds,\n+        builtin_bounds: builtin_bounds,\n+        trait_bounds: trait_bounds,\n+        projection_bounds: projection_bounds,\n+    }\n }\n \n /// Converts a specific TyParamBound from the AST into a set of\n@@ -2098,11 +2124,11 @@ fn predicates_from_bound<'tcx>(astconv: &AstConv<'tcx, 'tcx>,\n     }\n }\n \n-fn conv_poly_trait_ref<'tcx>(astconv: &AstConv<'tcx, 'tcx>,\n-                             param_ty: Ty<'tcx>,\n-                             trait_ref: &hir::PolyTraitRef,\n-                             projections: &mut Vec<ty::PolyProjectionPredicate<'tcx>>)\n-                             -> ty::PolyTraitRef<'tcx>\n+fn conv_poly_trait_ref<'gcx: 'tcx, 'tcx>(astconv: &AstConv<'gcx, 'tcx>,\n+                                         param_ty: Ty<'tcx>,\n+                                         trait_ref: &hir::PolyTraitRef,\n+                                         projections: &mut Vec<ty::PolyProjectionPredicate<'tcx>>)\n+                                         -> ty::PolyTraitRef<'tcx>\n {\n     AstConv::instantiate_poly_trait_ref(astconv,\n                                         &ExplicitRscope,\n@@ -2111,42 +2137,6 @@ fn conv_poly_trait_ref<'tcx>(astconv: &AstConv<'tcx, 'tcx>,\n                                         projections)\n }\n \n-fn conv_param_bounds<'a,'tcx>(astconv: &AstConv<'tcx, 'tcx>,\n-                              span: Span,\n-                              param_ty: ty::Ty<'tcx>,\n-                              ast_bounds: &[hir::TyParamBound])\n-                              -> Bounds<'tcx>\n-{\n-    let tcx = astconv.tcx();\n-    let PartitionedBounds {\n-        builtin_bounds,\n-        trait_bounds,\n-        region_bounds\n-    } = partition_bounds(tcx, span, &ast_bounds);\n-\n-    let mut projection_bounds = Vec::new();\n-\n-    let trait_bounds: Vec<ty::PolyTraitRef> =\n-        trait_bounds.iter()\n-                    .map(|bound| conv_poly_trait_ref(astconv,\n-                                                     param_ty,\n-                                                     *bound,\n-                                                     &mut projection_bounds))\n-                    .collect();\n-\n-    let region_bounds: Vec<ty::Region> =\n-        region_bounds.into_iter()\n-                     .map(|r| ast_region_to_region(tcx, r))\n-                     .collect();\n-\n-    Bounds {\n-        region_bounds: region_bounds,\n-        builtin_bounds: builtin_bounds,\n-        trait_bounds: trait_bounds,\n-        projection_bounds: projection_bounds,\n-    }\n-}\n-\n fn compute_type_scheme_of_foreign_fn_decl<'a, 'tcx>(\n     ccx: &CrateCtxt<'a, 'tcx>,\n     id: DefId,\n@@ -2194,7 +2184,7 @@ fn compute_type_scheme_of_foreign_fn_decl<'a, 'tcx>(\n         }\n     }\n \n-    let substs = mk_item_substs(ccx, &ty_generics);\n+    let substs = mk_item_substs(ccx.tcx, &ty_generics);\n     let t_fn = ccx.tcx.mk_fn_def(id, substs, ccx.tcx.mk_bare_fn(ty::BareFnTy {\n         abi: abi,\n         unsafety: hir::Unsafety::Unsafe,\n@@ -2209,19 +2199,19 @@ fn compute_type_scheme_of_foreign_fn_decl<'a, 'tcx>(\n     }\n }\n \n-fn mk_item_substs<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n-                            ty_generics: &ty::Generics<'tcx>)\n-                            -> &'tcx Substs<'tcx>\n+pub fn mk_item_substs<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                                      ty_generics: &ty::Generics)\n+                                      -> &'tcx Substs<'tcx>\n {\n     let types =\n         ty_generics.types.map(\n-            |def| ccx.tcx.mk_param_from_def(def));\n+            |def| tcx.mk_param_from_def(def));\n \n     let regions =\n         ty_generics.regions.map(\n             |def| def.to_early_bound_region());\n \n-    ccx.tcx.mk_substs(Substs::new(types, regions))\n+    tcx.mk_substs(Substs::new(types, regions))\n }\n \n /// Checks that all the type parameters on an impl"}, {"sha": "7d3bd095a3a888c930b813f17654334ae4e92ded", "filename": "src/librustc_typeck/constrained_type_params.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc_typeck%2Fconstrained_type_params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc_typeck%2Fconstrained_type_params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fconstrained_type_params.rs?ref=f55ac6944a88d4da62b30a16cc95893ca050c328", "patch": "@@ -45,7 +45,7 @@ struct ParameterCollector {\n impl<'tcx> TypeVisitor<'tcx> for ParameterCollector {\n     fn visit_ty(&mut self, t: Ty<'tcx>) -> bool {\n         match t.sty {\n-            ty::TyProjection(..) if !self.include_nonconstraining => {\n+            ty::TyProjection(..) | ty::TyAnon(..) if !self.include_nonconstraining => {\n                 // projections are not injective\n                 return false;\n             }"}, {"sha": "7b78e83b8012012a14cf90be9a0971c3e72fef8d", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=f55ac6944a88d4da62b30a16cc95893ca050c328", "patch": "@@ -4084,4 +4084,9 @@ register_diagnostics! {\n     E0513, // no type for local variable ..\n     E0521, // redundant default implementations of trait\n     E0533, // `{}` does not name a unit variant, unit struct or a constant\n+    E0562, // `impl Trait` not allowed outside of function\n+           // and inherent method return types\n+    E0563, // cannot determine a type for this `impl Trait`: {}\n+    E0564, // only named lifetimes are allowed in `impl Trait`,\n+           // but `{}` was found in the type `{}`\n }"}, {"sha": "0dd4bc4143927ce6dd0081a4e8767d3c727cb30d", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=f55ac6944a88d4da62b30a16cc95893ca050c328", "patch": "@@ -107,7 +107,7 @@ use hir::map as hir_map;\n use rustc::infer::TypeOrigin;\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n-use rustc::traits::ProjectionMode;\n+use rustc::traits::{self, Reveal};\n use session::{config, CompileResult};\n use util::common::time;\n \n@@ -150,6 +150,11 @@ pub struct CrateCtxt<'a, 'tcx: 'a> {\n     pub stack: RefCell<Vec<collect::AstConvRequest>>,\n \n     pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+\n+    /// Obligations which will have to be checked at the end of\n+    /// type-checking, after all functions have been inferred.\n+    /// The key is the NodeId of the item the obligations were from.\n+    pub deferred_obligations: RefCell<NodeMap<Vec<traits::DeferredObligation<'tcx>>>>,\n }\n \n // Functions that write types into the node type table\n@@ -190,7 +195,7 @@ fn require_same_types<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                 t1: Ty<'tcx>,\n                                 t2: Ty<'tcx>)\n                                 -> bool {\n-    ccx.tcx.infer_ctxt(None, None, ProjectionMode::AnyFinal).enter(|infcx| {\n+    ccx.tcx.infer_ctxt(None, None, Reveal::NotSpecializable).enter(|infcx| {\n         if let Err(err) = infcx.eq_types(false, origin.clone(), t1, t2) {\n             infcx.report_mismatched_types(origin, t1, t2, err);\n             false\n@@ -328,7 +333,8 @@ pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>)\n         ast_ty_to_ty_cache: RefCell::new(NodeMap()),\n         all_traits: RefCell::new(None),\n         stack: RefCell::new(Vec::new()),\n-        tcx: tcx\n+        tcx: tcx,\n+        deferred_obligations: RefCell::new(NodeMap()),\n     };\n \n     // this ensures that later parts of type checking can assume that items"}, {"sha": "58d1ec9d02a954d32047024e8b23b6919a03f9b8", "filename": "src/librustc_typeck/rscope.rs", "status": "modified", "additions": 83, "deletions": 1, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc_typeck%2Frscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc_typeck%2Frscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Frscope.rs?ref=f55ac6944a88d4da62b30a16cc95893ca050c328", "patch": "@@ -9,7 +9,8 @@\n // except according to those terms.\n \n \n-use rustc::ty;\n+use rustc::ty::{self, TyCtxt};\n+use rustc::ty::subst::Substs;\n \n use std::cell::Cell;\n use syntax_pos::Span;\n@@ -50,6 +51,79 @@ pub trait RegionScope {\n     /// computing `object_lifetime_default` (in particular, in legacy\n     /// modes, it may not be relevant).\n     fn base_object_lifetime_default(&self, span: Span) -> ty::Region;\n+\n+    /// If this scope allows anonymized types, return the generics in\n+    /// scope, that anonymized types will close over. For example,\n+    /// if you have a function like:\n+    ///\n+    ///     fn foo<'a, T>() -> impl Trait { ... }\n+    ///\n+    /// then, for the rscope that is used when handling the return type,\n+    /// `anon_type_scope()` would return a `Some(AnonTypeScope {...})`,\n+    /// on which `.fresh_substs(...)` can be used to obtain identity\n+    /// Substs for `'a` and `T`, to track them in `TyAnon`. This property\n+    /// is controlled by the region scope because it's fine-grained enough\n+    /// to allow restriction of anonymized types to the syntactical extent\n+    /// of a function's return type.\n+    fn anon_type_scope(&self) -> Option<AnonTypeScope> {\n+        None\n+    }\n+}\n+\n+#[derive(Copy, Clone)]\n+pub struct AnonTypeScope<'a> {\n+    generics: &'a ty::Generics<'a>\n+}\n+\n+impl<'a, 'b, 'gcx, 'tcx> AnonTypeScope<'a> {\n+    pub fn new(generics: &'a ty::Generics<'a>) -> AnonTypeScope<'a> {\n+        AnonTypeScope {\n+            generics: generics\n+        }\n+    }\n+\n+    pub fn fresh_substs(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> &'tcx Substs<'tcx> {\n+        use collect::mk_item_substs;\n+\n+        mk_item_substs(tcx, self.generics)\n+    }\n+}\n+\n+/// A scope wrapper which optionally allows anonymized types.\n+#[derive(Copy, Clone)]\n+pub struct MaybeWithAnonTypes<'a, R> {\n+    base_scope: R,\n+    anon_scope: Option<AnonTypeScope<'a>>\n+}\n+\n+impl<'a, R: RegionScope> MaybeWithAnonTypes<'a, R>  {\n+    pub fn new(base_scope: R, anon_scope: Option<AnonTypeScope<'a>>) -> Self {\n+        MaybeWithAnonTypes {\n+            base_scope: base_scope,\n+            anon_scope: anon_scope\n+        }\n+    }\n+}\n+\n+impl<'a, R: RegionScope> RegionScope for MaybeWithAnonTypes<'a, R> {\n+    fn object_lifetime_default(&self, span: Span) -> Option<ty::Region> {\n+        self.base_scope.object_lifetime_default(span)\n+    }\n+\n+    fn anon_regions(&self,\n+                    span: Span,\n+                    count: usize)\n+                    -> Result<Vec<ty::Region>, Option<Vec<ElisionFailureInfo>>> {\n+        self.base_scope.anon_regions(span, count)\n+    }\n+\n+    fn base_object_lifetime_default(&self, span: Span) -> ty::Region {\n+        self.base_scope.base_object_lifetime_default(span)\n+    }\n+\n+    fn anon_type_scope(&self) -> Option<AnonTypeScope> {\n+        self.anon_scope\n+    }\n }\n \n // A scope in which all regions must be explicitly named. This is used\n@@ -221,6 +295,10 @@ impl<'r> RegionScope for ObjectLifetimeDefaultRscope<'r> {\n     {\n         self.base_scope.anon_regions(span, count)\n     }\n+\n+    fn anon_type_scope(&self) -> Option<AnonTypeScope> {\n+        self.base_scope.anon_type_scope()\n+    }\n }\n \n /// A scope which simply shifts the Debruijn index of other scopes\n@@ -262,4 +340,8 @@ impl<'r> RegionScope for ShiftedRscope<'r> {\n             }\n         }\n     }\n+\n+    fn anon_type_scope(&self) -> Option<AnonTypeScope> {\n+        self.base_scope.anon_type_scope()\n+    }\n }"}, {"sha": "b9e0b4a10ea45ec9396a186cd103800ac0b085c1", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=f55ac6944a88d4da62b30a16cc95893ca050c328", "patch": "@@ -326,7 +326,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                 /* leaf type -- noop */\n             }\n \n-            ty::TyClosure(..) => {\n+            ty::TyClosure(..) | ty::TyAnon(..) => {\n                 bug!(\"Unexpected closure type in variance computation\");\n             }\n "}, {"sha": "73bc647fa9ffbcf63d8129fb30d8f66e452a5502", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=f55ac6944a88d4da62b30a16cc95893ca050c328", "patch": "@@ -1492,6 +1492,9 @@ pub enum Type {\n \n     // for<'a> Foo(&'a)\n     PolyTraitRef(Vec<TyParamBound>),\n+\n+    // impl TraitA+TraitB\n+    ImplTrait(Vec<TyParamBound>),\n }\n \n #[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Hash, Copy, Debug)]\n@@ -1777,6 +1780,7 @@ impl Clean<Type> for hir::Ty {\n             }\n             TyBareFn(ref barefn) => BareFunction(box barefn.clean(cx)),\n             TyPolyTraitRef(ref bounds) => PolyTraitRef(bounds.clean(cx)),\n+            TyImplTrait(ref bounds) => ImplTrait(bounds.clean(cx)),\n             TyInfer => Infer,\n             TyTypeof(..) => panic!(\"Unimplemented type {:?}\", self.node),\n         }\n@@ -1863,6 +1867,18 @@ impl<'tcx> Clean<Type> for ty::Ty<'tcx> {\n \n             ty::TyParam(ref p) => Generic(p.name.to_string()),\n \n+            ty::TyAnon(def_id, substs) => {\n+                // Grab the \"TraitA + TraitB\" from `impl TraitA + TraitB`,\n+                // by looking up the projections associated with the def_id.\n+                let item_predicates = cx.tcx().lookup_predicates(def_id);\n+                let substs = cx.tcx().lift(&substs).unwrap();\n+                let bounds = item_predicates.instantiate(cx.tcx(), substs);\n+                let predicates = bounds.predicates.into_vec();\n+                ImplTrait(predicates.into_iter().filter_map(|predicate| {\n+                    predicate.to_opt_poly_trait_ref().clean(cx)\n+                }).collect())\n+            }\n+\n             ty::TyClosure(..) => Tuple(vec![]), // FIXME(pcwalton)\n \n             ty::TyInfer(..) => panic!(\"TyInfer\"),"}, {"sha": "854ca57e8556c72a606a0f4e49c2de298c3e9c22", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=f55ac6944a88d4da62b30a16cc95893ca050c328", "patch": "@@ -539,6 +539,16 @@ impl fmt::Display for clean::Type {\n                 }\n                 Ok(())\n             }\n+            clean::ImplTrait(ref bounds) => {\n+                write!(f, \"impl \")?;\n+                for (i, bound) in bounds.iter().enumerate() {\n+                    if i != 0 {\n+                        write!(f, \" + \")?;\n+                    }\n+                    write!(f, \"{}\", *bound)?;\n+                }\n+                Ok(())\n+            }\n             // It's pretty unsightly to look at `<A as B>::C` in output, and\n             // we've got hyperlinking on our side, so try to avoid longer\n             // notation as much as possible by making `C` a hyperlink to trait"}, {"sha": "3f929e6d23aea0cedcd5eda3d8aa9256e7a3ae5e", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=f55ac6944a88d4da62b30a16cc95893ca050c328", "patch": "@@ -1368,6 +1368,8 @@ pub enum TyKind {\n     ObjectSum(P<Ty>, TyParamBounds),\n     /// A type like `for<'a> Foo<&'a Bar>`\n     PolyTraitRef(TyParamBounds),\n+    /// An `impl TraitA+TraitB` type.\n+    ImplTrait(TyParamBounds),\n     /// No-op; kept solely so that we can pretty-print faithfully\n     Paren(P<Ty>),\n     /// Unused for now"}, {"sha": "f550e7d2a0515e1f2da1f7599a1746d9a0bebd93", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=f55ac6944a88d4da62b30a16cc95893ca050c328", "patch": "@@ -277,7 +277,10 @@ declare_features! (\n     (active, cfg_target_has_atomic, \"1.9.0\", Some(32976)),\n \n     // Allows `..` in tuple (struct) patterns\n-    (active, dotdot_in_tuple_patterns, \"1.10.0\", Some(33627))\n+    (active, dotdot_in_tuple_patterns, \"1.10.0\", Some(33627)),\n+\n+    // Allows `impl Trait` in function return types.\n+    (active, conservative_impl_trait, \"1.12.0\", Some(34511))\n );\n \n declare_features! (\n@@ -952,6 +955,10 @@ impl<'a> Visitor for PostExpansionVisitor<'a> {\n             ast::TyKind::BareFn(ref bare_fn_ty) => {\n                 self.check_abi(bare_fn_ty.abi, ty.span);\n             }\n+            ast::TyKind::ImplTrait(..) => {\n+                gate_feature_post!(&self, conservative_impl_trait, ty.span,\n+                                   \"`impl Trait` is experimental\");\n+            }\n             _ => {}\n         }\n         visit::walk_ty(self, ty)"}, {"sha": "afc990f498e6f824d5502292a77a80f1ec18f778", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=f55ac6944a88d4da62b30a16cc95893ca050c328", "patch": "@@ -397,6 +397,9 @@ pub fn noop_fold_ty<T: Folder>(t: P<Ty>, fld: &mut T) -> P<Ty> {\n             TyKind::PolyTraitRef(bounds) => {\n                 TyKind::PolyTraitRef(bounds.move_map(|b| fld.fold_ty_param_bound(b)))\n             }\n+            TyKind::ImplTrait(bounds) => {\n+                TyKind::ImplTrait(bounds.move_map(|b| fld.fold_ty_param_bound(b)))\n+            }\n             TyKind::Mac(mac) => {\n                 TyKind::Mac(fld.fold_mac(mac))\n             }"}, {"sha": "1b32632a06f4e2b2997df194f7029387231fffa0", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=f55ac6944a88d4da62b30a16cc95893ca050c328", "patch": "@@ -1051,7 +1051,7 @@ impl<'a> Parser<'a> {\n     pub fn parse_for_in_type(&mut self) -> PResult<'a, TyKind> {\n         /*\n         Parses whatever can come after a `for` keyword in a type.\n-        The `for` has already been consumed.\n+        The `for` hasn't been consumed.\n \n         Deprecated:\n \n@@ -1091,6 +1091,23 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n+    pub fn parse_impl_trait_type(&mut self) -> PResult<'a, TyKind> {\n+        /*\n+        Parses whatever can come after a `impl` keyword in a type.\n+        The `impl` has already been consumed.\n+        */\n+\n+        let bounds = self.parse_ty_param_bounds(BoundParsingMode::Modified)?;\n+\n+        if !bounds.iter().any(|b| if let TraitTyParamBound(..) = *b { true } else { false }) {\n+            let last_span = self.last_span;\n+            self.span_err(last_span, \"at least one trait must be specified\");\n+        }\n+\n+        Ok(ast::TyKind::ImplTrait(bounds))\n+    }\n+\n+\n     pub fn parse_ty_path(&mut self) -> PResult<'a, TyKind> {\n         Ok(TyKind::Path(None, self.parse_path(PathStyle::Type)?))\n     }\n@@ -1406,6 +1423,8 @@ impl<'a> Parser<'a> {\n             self.parse_borrowed_pointee()?\n         } else if self.check_keyword(keywords::For) {\n             self.parse_for_in_type()?\n+        } else if self.eat_keyword(keywords::Impl) {\n+            self.parse_impl_trait_type()?\n         } else if self.token_is_bare_fn_keyword() {\n             // BARE FUNCTION\n             self.parse_ty_bare_fn(Vec::new())?"}, {"sha": "62e55eb78b72383eda8accaa5bbbec407af72564", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=f55ac6944a88d4da62b30a16cc95893ca050c328", "patch": "@@ -1018,6 +1018,9 @@ impl<'a> State<'a> {\n             ast::TyKind::PolyTraitRef(ref bounds) => {\n                 try!(self.print_bounds(\"\", &bounds[..]));\n             }\n+            ast::TyKind::ImplTrait(ref bounds) => {\n+                try!(self.print_bounds(\"impl \", &bounds[..]));\n+            }\n             ast::TyKind::FixedLengthVec(ref ty, ref v) => {\n                 try!(word(&mut self.s, \"[\"));\n                 try!(self.print_type(&ty));"}, {"sha": "6d3cdbdc6da7cc414e63de5ef5bcf4f0023ee849", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=f55ac6944a88d4da62b30a16cc95893ca050c328", "patch": "@@ -343,6 +343,9 @@ pub fn walk_ty<V: Visitor>(visitor: &mut V, typ: &Ty) {\n         TyKind::PolyTraitRef(ref bounds) => {\n             walk_list!(visitor, visit_ty_param_bound, bounds);\n         }\n+        TyKind::ImplTrait(ref bounds) => {\n+            walk_list!(visitor, visit_ty_param_bound, bounds);\n+        }\n         TyKind::Typeof(ref expression) => {\n             visitor.visit_expr(expression)\n         }"}, {"sha": "2c78ce2db29afe76ebf64ff08ea381c4e4f45e47", "filename": "src/test/compile-fail/impl-trait/auto-trait-leak.rs", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Ftest%2Fcompile-fail%2Fimpl-trait%2Fauto-trait-leak.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Ftest%2Fcompile-fail%2Fimpl-trait%2Fauto-trait-leak.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimpl-trait%2Fauto-trait-leak.rs?ref=f55ac6944a88d4da62b30a16cc95893ca050c328", "patch": "@@ -0,0 +1,70 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-tidy-linelength\n+\n+#![feature(conservative_impl_trait)]\n+\n+use std::cell::Cell;\n+use std::rc::Rc;\n+\n+// Fast path, main can see the concrete type returned.\n+fn before() -> impl Fn(i32) {\n+    let p = Rc::new(Cell::new(0));\n+    move |x| p.set(x)\n+}\n+\n+fn send<T: Send>(_: T) {}\n+\n+fn main() {\n+    send(before());\n+    //~^ ERROR the trait bound `std::rc::Rc<std::cell::Cell<i32>>: std::marker::Send` is not satisfied\n+    //~| NOTE `std::rc::Rc<std::cell::Cell<i32>>` cannot be sent between threads safely\n+    //~| NOTE required because it appears within the type `[closure\n+    //~| NOTE required because it appears within the type `impl std::ops::Fn<(i32,)>`\n+    //~| NOTE required by `send`\n+\n+    send(after());\n+    //~^ ERROR the trait bound `std::rc::Rc<std::cell::Cell<i32>>: std::marker::Send` is not satisfied\n+    //~| NOTE `std::rc::Rc<std::cell::Cell<i32>>` cannot be sent between threads safely\n+    //~| NOTE required because it appears within the type `[closure\n+    //~| NOTE required because it appears within the type `impl std::ops::Fn<(i32,)>`\n+    //~| NOTE required by `send`\n+}\n+\n+// Deferred path, main has to wait until typeck finishes,\n+// to check if the return type of after is Send.\n+fn after() -> impl Fn(i32) {\n+    let p = Rc::new(Cell::new(0));\n+    move |x| p.set(x)\n+}\n+\n+// Cycles should work as the deferred obligations are\n+// independently resolved and only require the concrete\n+// return type, which can't depend on the obligation.\n+fn cycle1() -> impl Clone {\n+    send(cycle2().clone());\n+    //~^ ERROR the trait bound `std::rc::Rc<std::string::String>: std::marker::Send` is not satisfied\n+    //~| NOTE `std::rc::Rc<std::string::String>` cannot be sent between threads safely\n+    //~| NOTE required because it appears within the type `impl std::clone::Clone`\n+    //~| NOTE required by `send`\n+\n+    Rc::new(Cell::new(5))\n+}\n+\n+fn cycle2() -> impl Clone {\n+    send(cycle1().clone());\n+    //~^ ERROR the trait bound `std::rc::Rc<std::cell::Cell<i32>>: std::marker::Send` is not satisfied\n+    //~| NOTE `std::rc::Rc<std::cell::Cell<i32>>` cannot be sent between threads safely\n+    //~| NOTE required because it appears within the type `impl std::clone::Clone`\n+    //~| NOTE required by `send`\n+\n+    Rc::new(String::from(\"foo\"))\n+}"}, {"sha": "46b3106ab8d6e19de3a220f426acd0889c109294", "filename": "src/test/compile-fail/impl-trait/disallowed-2.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Ftest%2Fcompile-fail%2Fimpl-trait%2Fdisallowed-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Ftest%2Fcompile-fail%2Fimpl-trait%2Fdisallowed-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimpl-trait%2Fdisallowed-2.rs?ref=f55ac6944a88d4da62b30a16cc95893ca050c328", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(conservative_impl_trait)]\n+\n+fn main() {\n+    let _: impl Fn() = || {};\n+    //~^ ERROR `impl Trait` not allowed outside of function and inherent method return types\n+    let _ = || -> impl Fn() { || {} };\n+    //~^ ERROR `impl Trait` not allowed outside of function and inherent method return types\n+}"}, {"sha": "09aba5d8c9168db1d16dfaf88b16688b0438049f", "filename": "src/test/compile-fail/impl-trait/disallowed.rs", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Ftest%2Fcompile-fail%2Fimpl-trait%2Fdisallowed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Ftest%2Fcompile-fail%2Fimpl-trait%2Fdisallowed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimpl-trait%2Fdisallowed.rs?ref=f55ac6944a88d4da62b30a16cc95893ca050c328", "patch": "@@ -0,0 +1,61 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(conservative_impl_trait)]\n+\n+fn arguments(_: impl Fn(),\n+//~^ ERROR `impl Trait` not allowed outside of function and inherent method return types\n+             _: Vec<impl Clone>) {}\n+//~^ ERROR `impl Trait` not allowed outside of function and inherent method return types\n+\n+type Factory<R> = impl Fn() -> R;\n+//~^ ERROR `impl Trait` not allowed outside of function and inherent method return types\n+\n+type GlobalFactory<R> = fn() -> impl FnOnce() -> R;\n+//~^ ERROR `impl Trait` not allowed outside of function and inherent method return types\n+\n+trait LazyToString {\n+    fn lazy_to_string<'a>(&'a self) -> impl Fn() -> String;\n+    //~^ ERROR `impl Trait` not allowed outside of function and inherent method return types\n+}\n+\n+// Note that the following impl doesn't error, because the trait is invalid.\n+impl LazyToString for String {\n+    fn lazy_to_string<'a>(&'a self) -> impl Fn() -> String {\n+        || self.clone()\n+    }\n+}\n+\n+#[derive(Copy, Clone)]\n+struct Lazy<T>(T);\n+\n+impl std::ops::Add<Lazy<i32>> for Lazy<i32> {\n+    type Output = impl Fn() -> Lazy<i32>;\n+    //~^ ERROR `impl Trait` not allowed outside of function and inherent method return types\n+\n+    fn add(self, other: Lazy<i32>) -> Self::Output {\n+        move || Lazy(self.0 + other.0)\n+    }\n+}\n+\n+impl<F> std::ops::Add<F>\n+for impl Fn() -> Lazy<i32>\n+//~^ ERROR `impl Trait` not allowed outside of function and inherent method return types\n+where F: Fn() -> impl FnOnce() -> i32\n+//~^ ERROR `impl Trait` not allowed outside of function and inherent method return types\n+{\n+    type Output = Self;\n+\n+    fn add(self, other: F) -> Self::Output {\n+        move || Lazy(self().0 + other()())\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "59ad1132b3501bdfae21910a24a0b6ba831c4bb9", "filename": "src/test/compile-fail/impl-trait/equality.rs", "status": "added", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Ftest%2Fcompile-fail%2Fimpl-trait%2Fequality.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Ftest%2Fcompile-fail%2Fimpl-trait%2Fequality.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimpl-trait%2Fequality.rs?ref=f55ac6944a88d4da62b30a16cc95893ca050c328", "patch": "@@ -0,0 +1,89 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(conservative_impl_trait, specialization)]\n+\n+trait Foo: Copy + ToString {}\n+\n+impl<T: Copy + ToString> Foo for T {}\n+\n+fn hide<T: Foo>(x: T) -> impl Foo {\n+    x\n+}\n+\n+fn two(x: bool) -> impl Foo {\n+    if x {\n+        return 1_i32;\n+    }\n+    0_u32\n+    //~^ ERROR mismatched types\n+    //~| expected i32, found u32\n+}\n+\n+fn sum_to(n: u32) -> impl Foo {\n+    if n == 0 {\n+        0\n+    } else {\n+        n + sum_to(n - 1)\n+        //~^ ERROR the trait bound `u32: std::ops::Add<impl Foo>` is not satisfied\n+    }\n+}\n+\n+trait Leak: Sized {\n+    type T;\n+    fn leak(self) -> Self::T;\n+}\n+impl<T> Leak for T {\n+    default type T = ();\n+    default fn leak(self) -> Self::T { panic!() }\n+}\n+impl Leak for i32 {\n+    type T = i32;\n+    fn leak(self) -> i32 { self }\n+}\n+\n+trait CheckIfSend: Sized {\n+    type T: Default;\n+    fn check(self) -> Self::T { Default::default() }\n+}\n+impl<T> CheckIfSend for T {\n+    default type T = ();\n+}\n+impl<T: Send> CheckIfSend for T {\n+    type T = bool;\n+}\n+\n+fn main() {\n+    let _: u32 = hide(0_u32);\n+    //~^ ERROR mismatched types\n+    //~| expected type `u32`\n+    //~| found type `impl Foo`\n+    //~| expected u32, found anonymized type\n+\n+    let _: i32 = Leak::leak(hide(0_i32));\n+    //~^ ERROR mismatched types\n+    //~| expected type `i32`\n+    //~| found type `<impl Foo as Leak>::T`\n+    //~| expected i32, found associated type\n+\n+    let _: bool = CheckIfSend::check(hide(0_i32));\n+    //~^ ERROR mismatched types\n+    //~| expected type `bool`\n+    //~| found type `<impl Foo as CheckIfSend>::T`\n+    //~| expected bool, found associated type\n+\n+    let mut x = (hide(0_u32), hide(0_i32));\n+    x = (x.1,\n+    //~^ ERROR mismatched types\n+    //~| expected u32, found i32\n+         x.0);\n+    //~^ ERROR mismatched types\n+    //~| expected i32, found u32\n+}"}, {"sha": "8239b06f2b4a358ec39dde33169720ddf4d24014", "filename": "src/test/compile-fail/impl-trait/feature-gate.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Ftest%2Fcompile-fail%2Fimpl-trait%2Ffeature-gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Ftest%2Fcompile-fail%2Fimpl-trait%2Ffeature-gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimpl-trait%2Ffeature-gate.rs?ref=f55ac6944a88d4da62b30a16cc95893ca050c328", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn foo() -> impl Fn() { || {} }\n+//~^ ERROR `impl Trait` is experimental\n+\n+fn main() {}"}, {"sha": "9d9f6bf72974abf815e3b259df0a17f81d69b104", "filename": "src/test/compile-fail/impl-trait/lifetimes.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Ftest%2Fcompile-fail%2Fimpl-trait%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Ftest%2Fcompile-fail%2Fimpl-trait%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimpl-trait%2Flifetimes.rs?ref=f55ac6944a88d4da62b30a16cc95893ca050c328", "patch": "@@ -0,0 +1,43 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(conservative_impl_trait)]\n+\n+// Helper creating a fake borrow, captured by the impl Trait.\n+fn borrow<'a, T>(_: &'a mut T) -> impl Copy { () }\n+\n+fn stack() -> impl Copy {\n+    //~^ ERROR only named lifetimes are allowed in `impl Trait`\n+    let x = 0;\n+    &x\n+}\n+\n+fn late_bound(x: &i32) -> impl Copy {\n+    //~^ ERROR only named lifetimes are allowed in `impl Trait`\n+    x\n+}\n+\n+// FIXME(#34511) Should work but doesn't at the moment,\n+// region-checking needs an overhault to support this.\n+fn early_bound<'a>(x: &'a i32) -> impl Copy {\n+    //~^ ERROR only named lifetimes are allowed in `impl Trait`\n+    x\n+}\n+\n+fn ambiguous<'a, 'b>(x: &'a [u32], y: &'b [u32]) -> impl Iterator<Item=u32> {\n+    //~^ ERROR only named lifetimes are allowed in `impl Trait`\n+    if x.len() < y.len() {\n+        x.iter().cloned()\n+    } else {\n+        y.iter().cloned()\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "ceaa8f4eed72348dfa1e34e2db89c42b261c22eb", "filename": "src/test/compile-fail/impl-trait/loan-extend.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Ftest%2Fcompile-fail%2Fimpl-trait%2Floan-extend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Ftest%2Fcompile-fail%2Fimpl-trait%2Floan-extend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimpl-trait%2Floan-extend.rs?ref=f55ac6944a88d4da62b30a16cc95893ca050c328", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(conservative_impl_trait)]\n+\n+// Helper creating a fake borrow, captured by the impl Trait.\n+fn borrow<'a, T>(_: &'a mut T) -> impl Copy { () }\n+\n+fn main() {\n+    //~^ NOTE reference must be valid for the block\n+    let long;\n+    let mut short = 0;\n+    //~^ NOTE but borrowed value is only valid for the block suffix following statement 1\n+    long = borrow(&mut short);\n+    //~^ ERROR `short` does not live long enough\n+}"}, {"sha": "5fab271efce64cb72905e943b8b029531b75dff3", "filename": "src/test/compile-fail/transmute-different-sizes.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Ftest%2Fcompile-fail%2Ftransmute-different-sizes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Ftest%2Fcompile-fail%2Ftransmute-different-sizes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftransmute-different-sizes.rs?ref=f55ac6944a88d4da62b30a16cc95893ca050c328", "patch": "@@ -11,6 +11,7 @@\n // Tests that `transmute` cannot be called on types of different size.\n \n #![allow(warnings)]\n+#![feature(specialization)]\n \n use std::mem::transmute;\n \n@@ -24,4 +25,15 @@ unsafe fn g<T>(x: &T) {\n     //~^ ERROR transmute called with differently sized types\n }\n \n+trait Specializable { type Output; }\n+\n+impl<T> Specializable for T {\n+    default type Output = u16;\n+}\n+\n+unsafe fn specializable<T>(x: u16) -> <T as Specializable>::Output {\n+    transmute(x)\n+    //~^ ERROR transmute called with differently sized types\n+}\n+\n fn main() {}"}, {"sha": "c1201e7fa4f4c589c21f875aa26ef3d659defa71", "filename": "src/test/run-pass/impl-trait/auto-trait-leak.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Ftest%2Frun-pass%2Fimpl-trait%2Fauto-trait-leak.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Ftest%2Frun-pass%2Fimpl-trait%2Fauto-trait-leak.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fimpl-trait%2Fauto-trait-leak.rs?ref=f55ac6944a88d4da62b30a16cc95893ca050c328", "patch": "@@ -0,0 +1,44 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(conservative_impl_trait)]\n+\n+// Fast path, main can see the concrete type returned.\n+fn before() -> impl FnMut(i32) {\n+    let mut p = Box::new(0);\n+    move |x| *p = x\n+}\n+\n+fn send<T: Send>(_: T) {}\n+\n+fn main() {\n+    send(before());\n+    send(after());\n+}\n+\n+// Deferred path, main has to wait until typeck finishes,\n+// to check if the return type of after is Send.\n+fn after() -> impl FnMut(i32) {\n+    let mut p = Box::new(0);\n+    move |x| *p = x\n+}\n+\n+// Cycles should work as the deferred obligations are\n+// independently resolved and only require the concrete\n+// return type, which can't depend on the obligation.\n+fn cycle1() -> impl Clone {\n+    send(cycle2().clone());\n+    5\n+}\n+\n+fn cycle2() -> impl Clone {\n+    send(cycle1().clone());\n+    String::from(\"foo\")\n+}"}, {"sha": "72b0e588ff483b3c8a292325074147bb5b404184", "filename": "src/test/run-pass/impl-trait/equality.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Ftest%2Frun-pass%2Fimpl-trait%2Fequality.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Ftest%2Frun-pass%2Fimpl-trait%2Fequality.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fimpl-trait%2Fequality.rs?ref=f55ac6944a88d4da62b30a16cc95893ca050c328", "patch": "@@ -0,0 +1,43 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(conservative_impl_trait, specialization)]\n+\n+trait Foo: std::fmt::Debug + Eq {}\n+\n+impl<T: std::fmt::Debug + Eq> Foo for T {}\n+\n+fn hide<T: Foo>(x: T) -> impl Foo {\n+    x\n+}\n+\n+trait Leak<T>: Sized {\n+    fn leak(self) -> T;\n+}\n+impl<T, U> Leak<T> for U {\n+    default fn leak(self) -> T { panic!(\"type mismatch\") }\n+}\n+impl<T> Leak<T> for T {\n+    fn leak(self) -> T { self }\n+}\n+\n+fn lucky_seven() -> impl Fn(usize) -> u8 {\n+    let a = [1, 2, 3, 4, 5, 6, 7];\n+    move |i| a[i]\n+}\n+\n+fn main() {\n+    assert_eq!(hide(42), hide(42));\n+\n+    assert_eq!(std::mem::size_of_val(&hide([0_u8; 5])), 5);\n+    assert_eq!(std::mem::size_of_val(&lucky_seven()), 7);\n+\n+    assert_eq!(Leak::<i32>::leak(hide(5_i32)), 5_i32);\n+}"}, {"sha": "2a9af26881c77ba77ca71f01f8d83abfbf4696f7", "filename": "src/test/run-pass/impl-trait/example-calendar.rs", "status": "added", "additions": 929, "deletions": 0, "changes": 929, "blob_url": "https://github.com/rust-lang/rust/blob/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Ftest%2Frun-pass%2Fimpl-trait%2Fexample-calendar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Ftest%2Frun-pass%2Fimpl-trait%2Fexample-calendar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fimpl-trait%2Fexample-calendar.rs?ref=f55ac6944a88d4da62b30a16cc95893ca050c328", "patch": "@@ -0,0 +1,929 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(conservative_impl_trait, fn_traits, step_trait, unboxed_closures)]\n+\n+//! Derived from: <https://raw.githubusercontent.com/quickfur/dcal/master/dcal.d>.\n+//!\n+//! Originally converted to Rust by [Daniel Keep](https://github.com/DanielKeep).\n+\n+use std::fmt::Write;\n+use std::mem;\n+\n+/// Date representation.\n+#[derive(Copy, Clone, Debug, Eq, Ord, PartialEq, PartialOrd)]\n+struct NaiveDate(i32, u32, u32);\n+\n+impl NaiveDate {\n+    pub fn from_ymd(y: i32, m: u32, d: u32) -> NaiveDate {\n+        assert!(1 <= m && m <= 12, \"m = {:?}\", m);\n+        assert!(1 <= d && d <= NaiveDate(y, m, 1).days_in_month(), \"d = {:?}\", d);\n+        NaiveDate(y, m, d)\n+    }\n+\n+    pub fn year(&self) -> i32 {\n+        self.0\n+    }\n+\n+    pub fn month(&self) -> u32 {\n+        self.1\n+    }\n+\n+    pub fn day(&self) -> u32 {\n+        self.2\n+    }\n+\n+    pub fn succ(&self) -> NaiveDate {\n+        let (mut y, mut m, mut d, n) = (\n+            self.year(), self.month(), self.day()+1, self.days_in_month());\n+        if d > n {\n+            d = 1;\n+            m += 1;\n+        }\n+        if m > 12 {\n+            m = 1;\n+            y += 1;\n+        }\n+        NaiveDate::from_ymd(y, m, d)\n+    }\n+\n+    pub fn weekday(&self) -> Weekday {\n+        use Weekday::*;\n+\n+        // 0 = Sunday\n+        let year = self.year();\n+        let dow_jan_1 = (year*365 + ((year-1) / 4) - ((year-1) / 100) + ((year-1) / 400)) % 7;\n+        let dow = (dow_jan_1 + (self.day_of_year() as i32 - 1)) % 7;\n+        [Sun, Mon, Tue, Wed, Thu, Fri, Sat][dow as usize]\n+    }\n+\n+    pub fn isoweekdate(&self) -> (i32, u32, Weekday) {\n+        let first_dow_mon_0 = self.year_first_day_of_week().num_days_from_monday();\n+\n+        // Work out this date's DOtY and week number, not including year adjustment.\n+        let doy_0 = self.day_of_year() - 1;\n+        let mut week_mon_0: i32 = ((first_dow_mon_0 + doy_0) / 7) as i32;\n+\n+        if self.first_week_in_prev_year() {\n+            week_mon_0 -= 1;\n+        }\n+\n+        let weeks_in_year = self.last_week_number();\n+\n+        // Work out the final result.\n+        // If the week is -1 or >= weeks_in_year, we will need to adjust the year.\n+        let year = self.year();\n+        let wd = self.weekday();\n+\n+        if week_mon_0 < 0 {\n+            (year - 1, NaiveDate::from_ymd(year - 1, 1, 1).last_week_number(), wd)\n+        } else if week_mon_0 >= weeks_in_year as i32 {\n+            (year + 1, (week_mon_0 + 1 - weeks_in_year as i32) as u32, wd)\n+        } else {\n+            (year, (week_mon_0 + 1) as u32, wd)\n+        }\n+    }\n+\n+    fn first_week_in_prev_year(&self) -> bool {\n+        let first_dow_mon_0 = self.year_first_day_of_week().num_days_from_monday();\n+\n+        // Any day in the year *before* the first Monday of that year\n+        // is considered to be in the last week of the previous year,\n+        // assuming the first week has *less* than four days in it.\n+        // Adjust the week appropriately.\n+        ((7 - first_dow_mon_0) % 7) < 4\n+    }\n+\n+    fn year_first_day_of_week(&self) -> Weekday {\n+        NaiveDate::from_ymd(self.year(), 1, 1).weekday()\n+    }\n+\n+    fn weeks_in_year(&self) -> u32 {\n+        let days_in_last_week = self.year_first_day_of_week().num_days_from_monday() + 1;\n+        if days_in_last_week >= 4 { 53 } else { 52 }\n+    }\n+\n+    fn last_week_number(&self) -> u32 {\n+        let wiy = self.weeks_in_year();\n+        if self.first_week_in_prev_year() { wiy - 1 } else { wiy }\n+    }\n+\n+    fn day_of_year(&self) -> u32 {\n+        (1..self.1).map(|m| NaiveDate::from_ymd(self.year(), m, 1).days_in_month())\n+            .fold(0, |a,b| a+b) + self.day()\n+    }\n+\n+    fn is_leap_year(&self) -> bool {\n+        let year = self.year();\n+        if year % 4 != 0 {\n+            return false\n+        } else if year % 100 != 0 {\n+            return true\n+        } else if year % 400 != 0 {\n+            return false\n+        } else {\n+            return true\n+        }\n+    }\n+\n+    fn days_in_month(&self) -> u32 {\n+        match self.month() {\n+            /* Jan */ 1 => 31,\n+            /* Feb */ 2 => if self.is_leap_year() { 29 } else { 28 },\n+            /* Mar */ 3 => 31,\n+            /* Apr */ 4 => 30,\n+            /* May */ 5 => 31,\n+            /* Jun */ 6 => 30,\n+            /* Jul */ 7 => 31,\n+            /* Aug */ 8 => 31,\n+            /* Sep */ 9 => 30,\n+            /* Oct */ 10 => 31,\n+            /* Nov */ 11 => 30,\n+            /* Dec */ 12 => 31,\n+            _ => unreachable!()\n+        }\n+    }\n+}\n+\n+impl<'a, 'b> std::ops::Add<&'b NaiveDate> for &'a NaiveDate {\n+    type Output = NaiveDate;\n+\n+    fn add(self, other: &'b NaiveDate) -> NaiveDate {\n+        assert_eq!(*other, NaiveDate(0, 0, 1));\n+        self.succ()\n+    }\n+}\n+\n+impl std::iter::Step for NaiveDate {\n+    fn step(&self, by: &Self) -> Option<Self> {\n+        Some(self + by)\n+    }\n+\n+    fn steps_between(_: &Self, _: &Self, _: &Self) -> Option<usize> {\n+        unimplemented!()\n+    }\n+\n+    fn steps_between_by_one(_: &Self, _: &Self) -> Option<usize> {\n+        unimplemented!()\n+    }\n+\n+    fn is_negative(&self) -> bool {\n+        false\n+    }\n+\n+    fn replace_one(&mut self) -> Self {\n+        mem::replace(self, NaiveDate(0, 0, 1))\n+    }\n+\n+    fn replace_zero(&mut self) -> Self {\n+        mem::replace(self, NaiveDate(0, 0, 0))\n+    }\n+\n+    fn add_one(&self) -> Self {\n+        self.succ()\n+    }\n+\n+    fn sub_one(&self) -> Self {\n+        unimplemented!()\n+    }\n+}\n+\n+#[derive(Copy, Clone, Debug, Eq, Ord, PartialEq, PartialOrd)]\n+pub enum Weekday {\n+    Mon,\n+    Tue,\n+    Wed,\n+    Thu,\n+    Fri,\n+    Sat,\n+    Sun,\n+}\n+\n+impl Weekday {\n+    pub fn num_days_from_monday(&self) -> u32 {\n+        use Weekday::*;\n+        match *self {\n+            Mon => 0,\n+            Tue => 1,\n+            Wed => 2,\n+            Thu => 3,\n+            Fri => 4,\n+            Sat => 5,\n+            Sun => 6,\n+        }\n+    }\n+\n+    pub fn num_days_from_sunday(&self) -> u32 {\n+        use Weekday::*;\n+        match *self {\n+            Sun => 0,\n+            Mon => 1,\n+            Tue => 2,\n+            Wed => 3,\n+            Thu => 4,\n+            Fri => 5,\n+            Sat => 6,\n+        }\n+    }\n+}\n+\n+/// Wrapper for zero-sized closures.\n+// HACK(eddyb) Only needed because closures can't implement Copy.\n+struct Fn0<F>(std::marker::PhantomData<F>);\n+\n+impl<F> Copy for Fn0<F> {}\n+impl<F> Clone for Fn0<F> {\n+    fn clone(&self) -> Self { *self }\n+}\n+\n+impl<F: FnOnce<A>, A> FnOnce<A> for Fn0<F> {\n+    type Output = F::Output;\n+\n+    extern \"rust-call\" fn call_once(self, args: A) -> Self::Output {\n+        let f = unsafe { std::mem::uninitialized::<F>() };\n+        f.call_once(args)\n+    }\n+}\n+\n+impl<F: FnMut<A>, A> FnMut<A> for Fn0<F> {\n+    extern \"rust-call\" fn call_mut(&mut self, args: A) -> Self::Output {\n+        let mut f = unsafe { std::mem::uninitialized::<F>() };\n+        f.call_mut(args)\n+    }\n+}\n+\n+trait AsFn0<A>: Sized {\n+    fn copyable(self) -> Fn0<Self>;\n+}\n+\n+impl<F: FnMut<A>, A> AsFn0<A> for F {\n+    fn copyable(self) -> Fn0<Self> {\n+        assert_eq!(std::mem::size_of::<F>(), 0);\n+        Fn0(std::marker::PhantomData)\n+    }\n+}\n+\n+/// GroupBy implementation.\n+struct GroupBy<It: Iterator, F> {\n+    it: std::iter::Peekable<It>,\n+    f: F,\n+}\n+\n+impl<It, F> Clone for GroupBy<It, F>\n+where It: Iterator + Clone, It::Item: Clone, F: Clone {\n+    fn clone(&self) -> GroupBy<It, F> {\n+        GroupBy {\n+            it: self.it.clone(),\n+            f: self.f.clone()\n+        }\n+    }\n+}\n+\n+impl<'a, G, It: 'a, F: 'a> Iterator for GroupBy<It, F>\n+where It: Iterator + Clone,\n+      It::Item: Clone,\n+      F: Clone + FnMut(&It::Item) -> G,\n+      G: Eq + Clone\n+{\n+    type Item = (G, InGroup<std::iter::Peekable<It>, F, G>);\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        self.it.peek().map(&mut self.f).map(|key| {\n+            let start = self.it.clone();\n+            while let Some(k) = self.it.peek().map(&mut self.f) {\n+                if key != k {\n+                    break;\n+                }\n+                self.it.next();\n+            }\n+\n+            (key.clone(), InGroup {\n+                it: start,\n+                f: self.f.clone(),\n+                g: key\n+            })\n+        })\n+    }\n+}\n+\n+#[derive(Copy, Clone)]\n+struct InGroup<It, F, G> {\n+    it: It,\n+    f: F,\n+    g: G\n+}\n+\n+impl<It: Iterator, F: FnMut(&It::Item) -> G, G: Eq> Iterator for InGroup<It, F, G> {\n+    type Item = It::Item;\n+\n+    fn next(&mut self) -> Option<It::Item> {\n+        self.it.next().and_then(|x| {\n+            if (self.f)(&x) == self.g { Some(x) } else { None }\n+        })\n+    }\n+}\n+\n+trait IteratorExt: Iterator + Sized {\n+    fn group_by<G, F>(self, f: F) -> GroupBy<Self, Fn0<F>>\n+    where F: FnMut(&Self::Item) -> G,\n+          G: Eq\n+    {\n+        GroupBy {\n+            it: self.peekable(),\n+            f: f.copyable(),\n+        }\n+    }\n+\n+    fn join(mut self, sep: &str) -> String\n+    where Self::Item: std::fmt::Display {\n+        let mut s = String::new();\n+        if let Some(e) = self.next() {\n+            write!(s, \"{}\", e);\n+            for e in self {\n+                s.push_str(sep);\n+                write!(s, \"{}\", e);\n+            }\n+        }\n+        s\n+    }\n+\n+    // HACK(eddyb) Only needed because `impl Trait` can't be\n+    // used with trait methods: `.foo()` becomes `.__(foo)`.\n+    fn __<F, R>(self, f: F) -> R\n+    where F: FnOnce(Self) -> R {\n+        f(self)\n+    }\n+}\n+\n+impl<It> IteratorExt for It where It: Iterator {}\n+\n+///\n+/// Generates an iterator that yields exactly n spaces.\n+///\n+fn spaces(n: usize) -> std::iter::Take<std::iter::Repeat<char>> {\n+    std::iter::repeat(' ').take(n)\n+}\n+\n+fn test_spaces() {\n+    assert_eq!(spaces(0).collect::<String>(), \"\");\n+    assert_eq!(spaces(10).collect::<String>(), \"          \")\n+}\n+\n+///\n+/// Returns an iterator of dates in a given year.\n+///\n+fn dates_in_year(year: i32) -> impl Iterator<Item=NaiveDate>+Clone {\n+    InGroup {\n+        it: NaiveDate::from_ymd(year, 1, 1)..,\n+        f: (|d: &NaiveDate| d.year()).copyable(),\n+        g: year\n+    }\n+}\n+\n+fn test_dates_in_year() {\n+    {\n+        let mut dates = dates_in_year(2013);\n+        assert_eq!(dates.next(), Some(NaiveDate::from_ymd(2013, 1, 1)));\n+\n+        // Check increment\n+        assert_eq!(dates.next(), Some(NaiveDate::from_ymd(2013, 1, 2)));\n+\n+        // Check monthly rollover\n+        for _ in 3..31 {\n+            assert!(dates.next() != None);\n+        }\n+\n+        assert_eq!(dates.next(), Some(NaiveDate::from_ymd(2013, 1, 31)));\n+        assert_eq!(dates.next(), Some(NaiveDate::from_ymd(2013, 2, 1)));\n+    }\n+\n+    {\n+        // Check length of year\n+        let mut dates = dates_in_year(2013);\n+        for _ in 0..365 {\n+            assert!(dates.next() != None);\n+        }\n+        assert_eq!(dates.next(), None);\n+    }\n+\n+    {\n+        // Check length of leap year\n+        let mut dates = dates_in_year(1984);\n+        for _ in 0..366 {\n+            assert!(dates.next() != None);\n+        }\n+        assert_eq!(dates.next(), None);\n+    }\n+}\n+\n+///\n+/// Convenience trait for verifying that a given type iterates over\n+/// `NaiveDate`s.\n+///\n+trait DateIterator: Iterator<Item=NaiveDate> + Clone {}\n+impl<It> DateIterator for It where It: Iterator<Item=NaiveDate> + Clone {}\n+\n+fn test_group_by() {\n+    let input = [\n+        [1, 1],\n+        [1, 1],\n+        [1, 2],\n+        [2, 2],\n+        [2, 3],\n+        [2, 3],\n+        [3, 3]\n+    ];\n+\n+    let by_x = input.iter().cloned().group_by(|a| a[0]);\n+    let expected_1: &[&[[i32; 2]]] = &[\n+        &[[1, 1], [1, 1], [1, 2]],\n+        &[[2, 2], [2, 3], [2, 3]],\n+        &[[3, 3]]\n+    ];\n+    for ((_, a), b) in by_x.zip(expected_1.iter().cloned()) {\n+        assert_eq!(&a.collect::<Vec<_>>()[..], b);\n+    }\n+\n+    let by_y = input.iter().cloned().group_by(|a| a[1]);\n+    let expected_2: &[&[[i32; 2]]] = &[\n+        &[[1, 1], [1, 1]],\n+        &[[1, 2], [2, 2]],\n+        &[[2, 3], [2, 3], [3, 3]]\n+    ];\n+    for ((_, a), b) in by_y.zip(expected_2.iter().cloned()) {\n+        assert_eq!(&a.collect::<Vec<_>>()[..], b);\n+    }\n+}\n+\n+///\n+/// Groups an iterator of dates by month.\n+///\n+fn by_month<It>(it: It)\n+                ->  impl Iterator<Item=(u32, impl Iterator<Item=NaiveDate> + Clone)> + Clone\n+where It: Iterator<Item=NaiveDate> + Clone {\n+    it.group_by(|d| d.month())\n+}\n+\n+fn test_by_month() {\n+    let mut months = dates_in_year(2013).__(by_month);\n+    for (month, (_, mut date)) in (1..13).zip(&mut months) {\n+        assert_eq!(date.nth(0).unwrap(), NaiveDate::from_ymd(2013, month, 1));\n+    }\n+    assert!(months.next().is_none());\n+}\n+\n+///\n+/// Groups an iterator of dates by week.\n+///\n+fn by_week<It>(it: It)\n+               -> impl Iterator<Item=(u32, impl DateIterator)> + Clone\n+where It: DateIterator {\n+    // We go forward one day because `isoweekdate` considers the week to start on a Monday.\n+    it.group_by(|d| d.succ().isoweekdate().1)\n+}\n+\n+fn test_isoweekdate() {\n+    fn weeks_uniq(year: i32) -> Vec<((i32, u32), u32)> {\n+        let mut weeks = dates_in_year(year).map(|d| d.isoweekdate())\n+            .map(|(y,w,_)| (y,w));\n+        let mut result = vec![];\n+        let mut accum = (weeks.next().unwrap(), 1);\n+        for yw in weeks {\n+            if accum.0 == yw {\n+                accum.1 += 1;\n+            } else {\n+                result.push(accum);\n+                accum = (yw, 1);\n+            }\n+        }\n+        result.push(accum);\n+        result\n+    }\n+\n+    let wu_1984 = weeks_uniq(1984);\n+    assert_eq!(&wu_1984[..2], &[((1983, 52), 1), ((1984, 1), 7)]);\n+    assert_eq!(&wu_1984[wu_1984.len()-2..], &[((1984, 52), 7), ((1985, 1), 1)]);\n+\n+    let wu_2013 = weeks_uniq(2013);\n+    assert_eq!(&wu_2013[..2], &[((2013, 1), 6), ((2013, 2), 7)]);\n+    assert_eq!(&wu_2013[wu_2013.len()-2..], &[((2013, 52), 7), ((2014, 1), 2)]);\n+\n+    let wu_2015 = weeks_uniq(2015);\n+    assert_eq!(&wu_2015[..2], &[((2015, 1), 4), ((2015, 2), 7)]);\n+    assert_eq!(&wu_2015[wu_2015.len()-2..], &[((2015, 52), 7), ((2015, 53), 4)]);\n+}\n+\n+fn test_by_week() {\n+    let mut weeks = dates_in_year(2013).__(by_week);\n+    assert_eq!(\n+        &*weeks.next().unwrap().1.collect::<Vec<_>>(),\n+        &[\n+            NaiveDate::from_ymd(2013, 1, 1),\n+            NaiveDate::from_ymd(2013, 1, 2),\n+            NaiveDate::from_ymd(2013, 1, 3),\n+            NaiveDate::from_ymd(2013, 1, 4),\n+            NaiveDate::from_ymd(2013, 1, 5),\n+        ]\n+    );\n+    assert_eq!(\n+        &*weeks.next().unwrap().1.collect::<Vec<_>>(),\n+        &[\n+            NaiveDate::from_ymd(2013, 1, 6),\n+            NaiveDate::from_ymd(2013, 1, 7),\n+            NaiveDate::from_ymd(2013, 1, 8),\n+            NaiveDate::from_ymd(2013, 1, 9),\n+            NaiveDate::from_ymd(2013, 1, 10),\n+            NaiveDate::from_ymd(2013, 1, 11),\n+            NaiveDate::from_ymd(2013, 1, 12),\n+        ]\n+    );\n+    assert_eq!(weeks.next().unwrap().1.nth(0).unwrap(), NaiveDate::from_ymd(2013, 1, 13));\n+}\n+\n+/// The number of columns per day in the formatted output.\n+const COLS_PER_DAY: u32 = 3;\n+\n+/// The number of columns per week in the formatted output.\n+const COLS_PER_WEEK: u32 = 7 * COLS_PER_DAY;\n+\n+///\n+/// Formats an iterator of weeks into an iterator of strings.\n+///\n+fn format_weeks<It>(it: It) -> impl Iterator<Item=String>\n+where It: Iterator, It::Item: DateIterator {\n+    it.map(|week| {\n+        let mut buf = String::with_capacity((COLS_PER_DAY * COLS_PER_WEEK + 2) as usize);\n+\n+        // Format each day into its own cell and append to target string.\n+        let mut last_day = 0;\n+        let mut first = true;\n+        for d in week {\n+            last_day = d.weekday().num_days_from_sunday();\n+\n+            // Insert enough filler to align the first day with its respective day-of-week.\n+            if first {\n+                buf.extend(spaces((COLS_PER_DAY * last_day) as usize));\n+                first = false;\n+            }\n+\n+            write!(buf, \" {:>2}\", d.day());\n+        }\n+\n+        // Insert more filler at the end to fill up the remainder of the week,\n+        // if its a short week (e.g. at the end of the month).\n+        buf.extend(spaces((COLS_PER_DAY * (6 - last_day)) as usize));\n+        buf\n+    })\n+}\n+\n+fn test_format_weeks() {\n+    let jan_2013 = dates_in_year(2013)\n+        .__(by_month).next() // pick January 2013 for testing purposes\n+        // NOTE: This `map` is because `next` returns an `Option<_>`.\n+        .map(|(_, month)|\n+            month.__(by_week)\n+                 .map(|(_, weeks)| weeks)\n+                 .__(format_weeks)\n+                 .join(\"\\n\"));\n+\n+    assert_eq!(\n+        jan_2013.as_ref().map(|s| &**s),\n+        Some(\"        1  2  3  4  5\\n\\\n+           \\x20 6  7  8  9 10 11 12\\n\\\n+           \\x2013 14 15 16 17 18 19\\n\\\n+           \\x2020 21 22 23 24 25 26\\n\\\n+           \\x2027 28 29 30 31      \")\n+    );\n+}\n+\n+///\n+/// Formats the name of a month, centered on COLS_PER_WEEK.\n+///\n+fn month_title(month: u32) -> String {\n+    const MONTH_NAMES: &'static [&'static str] = &[\n+        \"January\", \"February\", \"March\", \"April\", \"May\", \"June\",\n+        \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"\n+    ];\n+    assert_eq!(MONTH_NAMES.len(), 12);\n+\n+    // Determine how many spaces before and after the month name\n+    // we need to center it over the formatted weeks in the month.\n+    let name = MONTH_NAMES[(month - 1) as usize];\n+    assert!(name.len() < COLS_PER_WEEK as usize);\n+    let before = (COLS_PER_WEEK as usize - name.len()) / 2;\n+    let after = COLS_PER_WEEK as usize - name.len() - before;\n+\n+    // NOTE: Being slightly more verbose to avoid extra allocations.\n+    let mut result = String::with_capacity(COLS_PER_WEEK as usize);\n+    result.extend(spaces(before));\n+    result.push_str(name);\n+    result.extend(spaces(after));\n+    result\n+}\n+\n+fn test_month_title() {\n+    assert_eq!(month_title(1).len(), COLS_PER_WEEK as usize);\n+}\n+\n+///\n+/// Formats a month.\n+///\n+fn format_month<It: DateIterator>(it: It) -> impl Iterator<Item=String> {\n+    let mut month_days = it.peekable();\n+    let title = month_title(month_days.peek().unwrap().month());\n+\n+    Some(title).into_iter()\n+        .chain(month_days.__(by_week)\n+            .map(|(_, week)| week)\n+            .__(format_weeks))\n+}\n+\n+fn test_format_month() {\n+    let month_fmt = dates_in_year(2013)\n+        .__(by_month).next() // Pick January as a test case\n+        .map(|(_, days)| days.into_iter()\n+            .__(format_month)\n+            .join(\"\\n\"));\n+\n+    assert_eq!(\n+        month_fmt.as_ref().map(|s| &**s),\n+        Some(\"       January       \\n\\\n+           \\x20       1  2  3  4  5\\n\\\n+           \\x20 6  7  8  9 10 11 12\\n\\\n+           \\x2013 14 15 16 17 18 19\\n\\\n+           \\x2020 21 22 23 24 25 26\\n\\\n+           \\x2027 28 29 30 31      \")\n+    );\n+}\n+\n+\n+///\n+/// Formats an iterator of months.\n+///\n+fn format_months<It>(it: It) -> impl Iterator<Item=impl Iterator<Item=String>>\n+where It: Iterator, It::Item: DateIterator {\n+    it.map(format_month)\n+}\n+\n+///\n+/// Takes an iterator of iterators of strings; the sub-iterators are consumed\n+/// in lock-step, with their elements joined together.\n+///\n+trait PasteBlocks: Iterator + Sized\n+where Self::Item: Iterator<Item=String> {\n+    fn paste_blocks(self, sep_width: usize) -> PasteBlocksIter<Self::Item> {\n+        PasteBlocksIter {\n+            iters: self.collect(),\n+            cache: vec![],\n+            col_widths: None,\n+            sep_width: sep_width,\n+        }\n+    }\n+}\n+\n+impl<It> PasteBlocks for It where It: Iterator, It::Item: Iterator<Item=String> {}\n+\n+struct PasteBlocksIter<StrIt>\n+where StrIt: Iterator<Item=String> {\n+    iters: Vec<StrIt>,\n+    cache: Vec<Option<String>>,\n+    col_widths: Option<Vec<usize>>,\n+    sep_width: usize,\n+}\n+\n+impl<StrIt> Iterator for PasteBlocksIter<StrIt>\n+where StrIt: Iterator<Item=String> {\n+    type Item = String;\n+\n+    fn next(&mut self) -> Option<String> {\n+        self.cache.clear();\n+\n+        // `cache` is now the next line from each iterator.\n+        self.cache.extend(self.iters.iter_mut().map(|it| it.next()));\n+\n+        // If every line in `cache` is `None`, we have nothing further to do.\n+        if self.cache.iter().all(|e| e.is_none()) { return None }\n+\n+        // Get the column widths if we haven't already.\n+        let col_widths = match self.col_widths {\n+            Some(ref v) => &**v,\n+            None => {\n+                self.col_widths = Some(self.cache.iter()\n+                    .map(|ms| ms.as_ref().map(|s| s.len()).unwrap_or(0))\n+                    .collect());\n+                &**self.col_widths.as_ref().unwrap()\n+            }\n+        };\n+\n+        // Fill in any `None`s with spaces.\n+        let mut parts = col_widths.iter().cloned().zip(self.cache.iter_mut())\n+            .map(|(w,ms)| ms.take().unwrap_or_else(|| spaces(w).collect()));\n+\n+        // Join them all together.\n+        let first = parts.next().unwrap_or(String::new());\n+        let sep_width = self.sep_width;\n+        Some(parts.fold(first, |mut accum, next| {\n+            accum.extend(spaces(sep_width));\n+            accum.push_str(&next);\n+            accum\n+        }))\n+    }\n+}\n+\n+fn test_paste_blocks() {\n+    let row = dates_in_year(2013)\n+        .__(by_month).map(|(_, days)| days)\n+        .take(3)\n+        .__(format_months)\n+        .paste_blocks(1)\n+        .join(\"\\n\");\n+    assert_eq!(\n+        &*row,\n+        \"       January              February                March        \\n\\\n+      \\x20       1  2  3  4  5                  1  2                  1  2\\n\\\n+      \\x20 6  7  8  9 10 11 12   3  4  5  6  7  8  9   3  4  5  6  7  8  9\\n\\\n+      \\x2013 14 15 16 17 18 19  10 11 12 13 14 15 16  10 11 12 13 14 15 16\\n\\\n+      \\x2020 21 22 23 24 25 26  17 18 19 20 21 22 23  17 18 19 20 21 22 23\\n\\\n+      \\x2027 28 29 30 31        24 25 26 27 28        24 25 26 27 28 29 30\\n\\\n+      \\x20                                            31                  \"\n+    );\n+}\n+\n+///\n+/// Produces an iterator that yields `n` elements at a time.\n+///\n+trait Chunks: Iterator + Sized {\n+    fn chunks(self, n: usize) -> ChunksIter<Self> {\n+        assert!(n > 0);\n+        ChunksIter {\n+            it: self,\n+            n: n,\n+        }\n+    }\n+}\n+\n+impl<It> Chunks for It where It: Iterator {}\n+\n+struct ChunksIter<It>\n+where It: Iterator {\n+    it: It,\n+    n: usize,\n+}\n+\n+// NOTE: `chunks` in Rust is more-or-less impossible without overhead of some kind.\n+// Aliasing rules mean you need to add dynamic borrow checking, and the design of\n+// `Iterator` means that you need to have the iterator's state kept in an allocation\n+// that is jointly owned by the iterator itself and the sub-iterator.\n+// As such, I've chosen to cop-out and just heap-allocate each chunk.\n+\n+impl<It> Iterator for ChunksIter<It>\n+where It: Iterator {\n+    type Item = Vec<It::Item>;\n+\n+    fn next(&mut self) -> Option<Vec<It::Item>> {\n+        let first = match self.it.next() {\n+            Some(e) => e,\n+            None => return None\n+        };\n+\n+        let mut result = Vec::with_capacity(self.n);\n+        result.push(first);\n+\n+        Some((&mut self.it).take(self.n-1)\n+            .fold(result, |mut acc, next| { acc.push(next); acc }))\n+    }\n+}\n+\n+fn test_chunks() {\n+    let r = &[1, 2, 3, 4, 5, 6, 7];\n+    let c = r.iter().cloned().chunks(3).collect::<Vec<_>>();\n+    assert_eq!(&*c, &[vec![1, 2, 3], vec![4, 5, 6], vec![7]]);\n+}\n+\n+///\n+/// Formats a year.\n+///\n+fn format_year(year: i32, months_per_row: usize) -> String {\n+    const COL_SPACING: usize = 1;\n+\n+    // Start by generating all dates for the given year.\n+    dates_in_year(year)\n+\n+        // Group them by month and throw away month number.\n+        .__(by_month).map(|(_, days)| days)\n+\n+        // Group the months into horizontal rows.\n+        .chunks(months_per_row)\n+\n+        // Format each row\n+        .map(|r| r.into_iter()\n+            // By formatting each month\n+            .__(format_months)\n+\n+            // Horizontally pasting each respective month's lines together.\n+            .paste_blocks(COL_SPACING)\n+            .join(\"\\n\")\n+        )\n+\n+        // Insert a blank line between each row\n+        .join(\"\\n\\n\")\n+}\n+\n+fn test_format_year() {\n+    const MONTHS_PER_ROW: usize = 3;\n+\n+    macro_rules! assert_eq_cal {\n+        ($lhs:expr, $rhs:expr) => {\n+            if $lhs != $rhs {\n+                println!(\"got:\\n```\\n{}\\n```\\n\", $lhs.replace(\" \", \".\"));\n+                println!(\"expected:\\n```\\n{}\\n```\", $rhs.replace(\" \", \".\"));\n+                panic!(\"calendars didn't match!\");\n+            }\n+        }\n+    }\n+\n+    assert_eq_cal!(&format_year(1984, MONTHS_PER_ROW), \"\\\n+\\x20      January              February                March        \\n\\\n+\\x20 1  2  3  4  5  6  7            1  2  3  4               1  2  3\\n\\\n+\\x20 8  9 10 11 12 13 14   5  6  7  8  9 10 11   4  5  6  7  8  9 10\\n\\\n+\\x2015 16 17 18 19 20 21  12 13 14 15 16 17 18  11 12 13 14 15 16 17\\n\\\n+\\x2022 23 24 25 26 27 28  19 20 21 22 23 24 25  18 19 20 21 22 23 24\\n\\\n+\\x2029 30 31              26 27 28 29           25 26 27 28 29 30 31\\n\\\n+\\n\\\n+\\x20       April                  May                  June         \\n\\\n+\\x20 1  2  3  4  5  6  7         1  2  3  4  5                  1  2\\n\\\n+\\x20 8  9 10 11 12 13 14   6  7  8  9 10 11 12   3  4  5  6  7  8  9\\n\\\n+\\x2015 16 17 18 19 20 21  13 14 15 16 17 18 19  10 11 12 13 14 15 16\\n\\\n+\\x2022 23 24 25 26 27 28  20 21 22 23 24 25 26  17 18 19 20 21 22 23\\n\\\n+\\x2029 30                 27 28 29 30 31        24 25 26 27 28 29 30\\n\\\n+\\n\\\n+\\x20       July                 August               September      \\n\\\n+\\x20 1  2  3  4  5  6  7            1  2  3  4                     1\\n\\\n+\\x20 8  9 10 11 12 13 14   5  6  7  8  9 10 11   2  3  4  5  6  7  8\\n\\\n+\\x2015 16 17 18 19 20 21  12 13 14 15 16 17 18   9 10 11 12 13 14 15\\n\\\n+\\x2022 23 24 25 26 27 28  19 20 21 22 23 24 25  16 17 18 19 20 21 22\\n\\\n+\\x2029 30 31              26 27 28 29 30 31     23 24 25 26 27 28 29\\n\\\n+\\x20                                            30                  \\n\\\n+\\n\\\n+\\x20      October              November              December       \\n\\\n+\\x20    1  2  3  4  5  6               1  2  3                     1\\n\\\n+\\x20 7  8  9 10 11 12 13   4  5  6  7  8  9 10   2  3  4  5  6  7  8\\n\\\n+\\x2014 15 16 17 18 19 20  11 12 13 14 15 16 17   9 10 11 12 13 14 15\\n\\\n+\\x2021 22 23 24 25 26 27  18 19 20 21 22 23 24  16 17 18 19 20 21 22\\n\\\n+\\x2028 29 30 31           25 26 27 28 29 30     23 24 25 26 27 28 29\\n\\\n+\\x20                                            30 31               \");\n+\n+    assert_eq_cal!(&format_year(2015, MONTHS_PER_ROW), \"\\\n+\\x20      January              February                March        \\n\\\n+\\x20             1  2  3   1  2  3  4  5  6  7   1  2  3  4  5  6  7\\n\\\n+\\x20 4  5  6  7  8  9 10   8  9 10 11 12 13 14   8  9 10 11 12 13 14\\n\\\n+\\x2011 12 13 14 15 16 17  15 16 17 18 19 20 21  15 16 17 18 19 20 21\\n\\\n+\\x2018 19 20 21 22 23 24  22 23 24 25 26 27 28  22 23 24 25 26 27 28\\n\\\n+\\x2025 26 27 28 29 30 31                        29 30 31            \\n\\\n+\\n\\\n+\\x20       April                  May                  June         \\n\\\n+\\x20          1  2  3  4                  1  2      1  2  3  4  5  6\\n\\\n+\\x20 5  6  7  8  9 10 11   3  4  5  6  7  8  9   7  8  9 10 11 12 13\\n\\\n+\\x2012 13 14 15 16 17 18  10 11 12 13 14 15 16  14 15 16 17 18 19 20\\n\\\n+\\x2019 20 21 22 23 24 25  17 18 19 20 21 22 23  21 22 23 24 25 26 27\\n\\\n+\\x2026 27 28 29 30        24 25 26 27 28 29 30  28 29 30            \\n\\\n+\\x20                      31                                        \\n\\\n+\\n\\\n+\\x20       July                 August               September      \\n\\\n+\\x20          1  2  3  4                     1         1  2  3  4  5\\n\\\n+\\x20 5  6  7  8  9 10 11   2  3  4  5  6  7  8   6  7  8  9 10 11 12\\n\\\n+\\x2012 13 14 15 16 17 18   9 10 11 12 13 14 15  13 14 15 16 17 18 19\\n\\\n+\\x2019 20 21 22 23 24 25  16 17 18 19 20 21 22  20 21 22 23 24 25 26\\n\\\n+\\x2026 27 28 29 30 31     23 24 25 26 27 28 29  27 28 29 30         \\n\\\n+\\x20                      30 31                                     \\n\\\n+\\n\\\n+\\x20      October              November              December       \\n\\\n+\\x20             1  2  3   1  2  3  4  5  6  7         1  2  3  4  5\\n\\\n+\\x20 4  5  6  7  8  9 10   8  9 10 11 12 13 14   6  7  8  9 10 11 12\\n\\\n+\\x2011 12 13 14 15 16 17  15 16 17 18 19 20 21  13 14 15 16 17 18 19\\n\\\n+\\x2018 19 20 21 22 23 24  22 23 24 25 26 27 28  20 21 22 23 24 25 26\\n\\\n+\\x2025 26 27 28 29 30 31  29 30                 27 28 29 30 31      \");\n+}\n+\n+fn main() {\n+    // Run tests.\n+    test_spaces();\n+    test_dates_in_year();\n+    test_group_by();\n+    test_by_month();\n+    test_isoweekdate();\n+    test_by_week();\n+    test_format_weeks();\n+    test_month_title();\n+    test_format_month();\n+    test_paste_blocks();\n+    test_chunks();\n+    test_format_year();\n+}"}, {"sha": "461d4cf4ff053bc0feea5dc3923503704e4aa72f", "filename": "src/test/run-pass/impl-trait/example-st.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Ftest%2Frun-pass%2Fimpl-trait%2Fexample-st.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Ftest%2Frun-pass%2Fimpl-trait%2Fexample-st.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fimpl-trait%2Fexample-st.rs?ref=f55ac6944a88d4da62b30a16cc95893ca050c328", "patch": "@@ -0,0 +1,40 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(conservative_impl_trait, question_mark)]\n+\n+struct State;\n+type Error = ();\n+\n+trait Bind<F> {\n+    type Output;\n+    fn bind(self, f: F) -> Self::Output;\n+}\n+\n+fn bind<T, U, A, B, F>(mut a: A, mut f: F)\n+                       -> impl FnMut(&mut State) -> Result<U, Error>\n+where F: FnMut(T) -> B,\n+      A: FnMut(&mut State) -> Result<T, Error>,\n+      B: FnMut(&mut State) -> Result<U, Error>\n+{\n+    move |state | {\n+        let r = a(state)?;\n+        f(r)(state)\n+    }\n+}\n+\n+fn atom<T>(x: T) -> impl FnMut(&mut State) -> Result<T, Error> {\n+    let mut x = Some(x);\n+    move |_| x.take().map_or(Err(()), Ok)\n+}\n+\n+fn main() {\n+    assert_eq!(bind(atom(5), |x| atom(x > 4))(&mut State), Ok(true));\n+}"}, {"sha": "823def32270445314d2cb425ac56c981ca674721", "filename": "src/test/run-pass/transmute-specialization.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Ftest%2Frun-pass%2Ftransmute-specialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f55ac6944a88d4da62b30a16cc95893ca050c328/src%2Ftest%2Frun-pass%2Ftransmute-specialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftransmute-specialization.rs?ref=f55ac6944a88d4da62b30a16cc95893ca050c328", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(specialization)]\n+\n+trait Specializable { type Output; }\n+\n+impl<T> Specializable for T {\n+    default type Output = u16;\n+}\n+\n+fn main() {\n+    unsafe {\n+        std::mem::transmute::<u16, <() as Specializable>::Output>(0);\n+    }\n+}"}]}