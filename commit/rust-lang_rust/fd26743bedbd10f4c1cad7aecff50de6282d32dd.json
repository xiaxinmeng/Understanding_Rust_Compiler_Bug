{"sha": "fd26743bedbd10f4c1cad7aecff50de6282d32dd", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZkMjY3NDNiZWRiZDEwZjRjMWNhZDdhZWNmZjUwZGU2MjgyZDMyZGQ=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-04-10T17:52:06Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-04-10T18:01:36Z"}, "message": "Generic classes and generic class methods work cross-crate\n\nClasses can have ty params now. So can methods inside classes.\nThat was probably true before, but now it should still work if you\ncall methods in a class that's defined in a different crate. Yay!", "tree": {"sha": "3ce0e7a34633a86f91f177ae84683232fcf971de", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3ce0e7a34633a86f91f177ae84683232fcf971de"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fd26743bedbd10f4c1cad7aecff50de6282d32dd", "comment_count": 1, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fd26743bedbd10f4c1cad7aecff50de6282d32dd", "html_url": "https://github.com/rust-lang/rust/commit/fd26743bedbd10f4c1cad7aecff50de6282d32dd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fd26743bedbd10f4c1cad7aecff50de6282d32dd/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b2ec26c15283def5d5d8bcdd74bfdd84e918c46e", "url": "https://api.github.com/repos/rust-lang/rust/commits/b2ec26c15283def5d5d8bcdd74bfdd84e918c46e", "html_url": "https://github.com/rust-lang/rust/commit/b2ec26c15283def5d5d8bcdd74bfdd84e918c46e"}], "stats": {"total": 298, "additions": 216, "deletions": 82}, "files": [{"sha": "44a37066a56edf72abe589890fa79e61995afc66", "filename": "src/librustsyntax/ast.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fd26743bedbd10f4c1cad7aecff50de6282d32dd/src%2Flibrustsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd26743bedbd10f4c1cad7aecff50de6282d32dd/src%2Flibrustsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fast.rs?ref=fd26743bedbd10f4c1cad7aecff50de6282d32dd", "patch": "@@ -643,7 +643,7 @@ enum item_ {\n     item_native_mod(native_mod),\n     item_ty(@ty, [ty_param]),\n     item_enum([variant], [ty_param]),\n-    item_res(fn_decl /* dtor */, [ty_param], blk,\n+    item_res(fn_decl /* dtor */, [ty_param], blk /* dtor body */,\n              node_id /* dtor id */, node_id /* ctor id */),\n     item_class([ty_param], /* ty params for class */\n                [@class_member], /* methods, etc. */\n@@ -703,6 +703,7 @@ enum inlined_item {\n     ii_item(@item),\n     ii_method(def_id /* impl id */, @method),\n     ii_native(@native_item),\n+    ii_ctor(class_ctor, ident, [ty_param], def_id /* parent id */)\n }\n \n //"}, {"sha": "f81f09b2c52f1aa399528d7615cd62f6fc414c86", "filename": "src/librustsyntax/ast_util.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fd26743bedbd10f4c1cad7aecff50de6282d32dd/src%2Flibrustsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd26743bedbd10f4c1cad7aecff50de6282d32dd/src%2Flibrustsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fast_util.rs?ref=fd26743bedbd10f4c1cad7aecff50de6282d32dd", "patch": "@@ -302,6 +302,7 @@ impl inlined_item_methods for inlined_item {\n           ii_item(i) { i.ident }\n           ii_native(i) { i.ident }\n           ii_method(_, m) { m.ident }\n+          ii_ctor(_, nm, _, _) { nm }\n         }\n     }\n \n@@ -310,6 +311,7 @@ impl inlined_item_methods for inlined_item {\n           ii_item(i) { i.id }\n           ii_native(i) { i.id }\n           ii_method(_, m) { m.id }\n+          ii_ctor(ctor, _, _, _) { ctor.node.id }\n         }\n     }\n \n@@ -318,6 +320,9 @@ impl inlined_item_methods for inlined_item {\n           ii_item(i) { v.visit_item(i, e, v) }\n           ii_native(i) { v.visit_native_item(i, e, v) }\n           ii_method(_, m) { visit::visit_method_helper(m, e, v) }\n+          ii_ctor(ctor, nm, tps, parent_id) {\n+              visit::visit_class_ctor_helper(ctor, nm, tps, parent_id, e, v);\n+          }\n         }\n     }\n }"}, {"sha": "ec6d871472bcdf312e2d22f50bea7a8255e53815", "filename": "src/librustsyntax/fold.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fd26743bedbd10f4c1cad7aecff50de6282d32dd/src%2Flibrustsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd26743bedbd10f4c1cad7aecff50de6282d32dd/src%2Flibrustsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Ffold.rs?ref=fd26743bedbd10f4c1cad7aecff50de6282d32dd", "patch": "@@ -14,6 +14,8 @@ export noop_fold_ty;\n export noop_fold_block;\n export wrap;\n export fold_ty_param;\n+export fold_ty_params;\n+export fold_fn_decl;\n \n type ast_fold = @mut a_f;\n \n@@ -270,10 +272,12 @@ fn noop_fold_item_underscore(i: item_, fld: ast_fold) -> item_ {\n           item_class(typms, items, ctor) {\n               let ctor_body = fld.fold_block(ctor.node.body);\n               let ctor_decl = fold_fn_decl(ctor.node.dec, fld);\n+              let ctor_id   = fld.new_id(ctor.node.id);\n               item_class(typms,\n                          vec::map(items, fld.fold_class_item),\n                          {node: {body: ctor_body,\n-                                     dec: ctor_decl with ctor.node}\n+                                 dec: ctor_decl,\n+                                 id: ctor_id with ctor.node}\n                              with ctor})\n           }\n           item_impl(tps, ifce, ty, methods) {"}, {"sha": "b4ffce0730df82330f28e2c8937d43780337e2f2", "filename": "src/librustsyntax/visit.rs", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/fd26743bedbd10f4c1cad7aecff50de6282d32dd/src%2Flibrustsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd26743bedbd10f4c1cad7aecff50de6282d32dd/src%2Flibrustsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fvisit.rs?ref=fd26743bedbd10f4c1cad7aecff50de6282d32dd", "patch": "@@ -18,21 +18,22 @@ enum fn_kind {\n     fk_res(ident, [ty_param]),\n     fk_anon(proto),  //< an anonymous function like fn@(...)\n     fk_fn_block,     //< a block {||...}\n-    fk_ctor(ident, [ty_param]) // class constructor\n+    fk_ctor(ident, [ty_param], node_id /* self id */,\n+            def_id /* parent class id */) // class constructor\n }\n \n fn name_of_fn(fk: fn_kind) -> ident {\n     alt fk {\n       fk_item_fn(name, _) | fk_method(name, _, _) | fk_res(name, _)\n-          | fk_ctor(name, _) { name }\n+          | fk_ctor(name, _, _, _) { name }\n       fk_anon(_) | fk_fn_block { \"anon\" }\n     }\n }\n \n fn tps_of_fn(fk: fn_kind) -> [ty_param] {\n     alt fk {\n       fk_item_fn(_, tps) | fk_method(_, tps, _) | fk_res(_, tps)\n-          | fk_ctor(_, tps) { tps }\n+          | fk_ctor(_, tps, _, _) { tps }\n       fk_anon(_) | fk_fn_block { [] }\n     }\n }\n@@ -141,9 +142,8 @@ fn visit_item<E>(i: @item, e: E, v: vt<E>) {\n           for members.each {|m|\n              v.visit_class_item(m, e, v);\n           }\n-          // make up a fake fn so as to call visit_fn on the ctor\n-          v.visit_fn(fk_ctor(i.ident, tps), ctor.node.dec,\n-                     ctor.node.body, ctor.span, ctor.node.id, e, v);\n+          visit_class_ctor_helper(ctor, i.ident, tps,\n+                                  ast_util::local_def(i.id), e, v);\n       }\n       item_iface(tps, methods) {\n         v.visit_ty_params(tps, e, v);\n@@ -270,6 +270,15 @@ fn visit_method_helper<E>(m: @method, e: E, v: vt<E>) {\n                m.id, e, v);\n }\n \n+// Similar logic to the comment on visit_method_helper - Tim\n+fn visit_class_ctor_helper<E>(ctor: class_ctor, nm: ident, tps: [ty_param],\n+                              parent_id: def_id, e: E, v: vt<E>) {\n+    v.visit_fn(visit::fk_ctor(nm, tps, ctor.node.self_id,\n+                              parent_id), ctor.node.dec,\n+               ctor.node.body, ctor.span, ctor.node.id, e, v)\n+\n+}\n+\n fn visit_fn<E>(fk: fn_kind, decl: fn_decl, body: blk, _sp: span,\n                _id: node_id, e: E, v: vt<E>) {\n     visit_fn_decl(decl, e, v);"}, {"sha": "1b007b348afac5606d47e87ca3b303ebcf130b6d", "filename": "src/rustc/metadata/astencode.rs", "status": "modified", "additions": 27, "deletions": 2, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/fd26743bedbd10f4c1cad7aecff50de6282d32dd/src%2Frustc%2Fmetadata%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd26743bedbd10f4c1cad7aecff50de6282d32dd/src%2Frustc%2Fmetadata%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fastencode.rs?ref=fd26743bedbd10f4c1cad7aecff50de6282d32dd", "patch": "@@ -1,3 +1,5 @@\n+import util::ppaux::ty_to_str;\n+\n import syntax::ast;\n import syntax::fold;\n import syntax::visit;\n@@ -200,8 +202,14 @@ fn visit_ids(item: ast::inlined_item, vfn: fn@(ast::node_id)) {\n             vfn(id);\n \n             alt fk {\n+              visit::fk_ctor(nm, tps, self_id, parent_id) {\n+                vec::iter(tps) {|tp| vfn(tp.id)}\n+                vfn(id);\n+                vfn(self_id);\n+                vfn(parent_id.node);\n+              }\n               visit::fk_item_fn(_, tps) |\n-              visit::fk_res(_, tps) | visit::fk_ctor(_, tps) {\n+              visit::fk_res(_, tps) {\n                 vec::iter(tps) {|tp| vfn(tp.id)}\n               }\n               visit::fk_method(_, tps, m) {\n@@ -376,6 +384,13 @@ fn simplify_ast(ii: ast::inlined_item) -> ast::inlined_item {\n       ast::ii_native(i) {\n         ast::ii_native(fld.fold_native_item(i))\n       }\n+      ast::ii_ctor(ctor, nm, tps, parent_id) {\n+        let ctor_body = fld.fold_block(ctor.node.body);\n+        let ctor_decl = fold::fold_fn_decl(ctor.node.dec, fld);\n+        ast::ii_ctor({node: {body: ctor_body, dec: ctor_decl\n+                              with ctor.node}\n+            with ctor}, nm, tps, parent_id)\n+      }\n     }\n }\n \n@@ -403,7 +418,17 @@ fn renumber_ast(xcx: extended_decode_ctxt, ii: ast::inlined_item)\n       ast::ii_native(i) {\n         ast::ii_native(fld.fold_native_item(i))\n       }\n-    }\n+      ast::ii_ctor(ctor, nm, tps, parent_id) {\n+        let ctor_body = fld.fold_block(ctor.node.body);\n+        let ctor_decl = fold::fold_fn_decl(ctor.node.dec, fld);\n+        let new_params = fold::fold_ty_params(tps, fld);\n+        let ctor_id = fld.new_id(ctor.node.id);\n+        let new_parent = xcx.tr_def_id(parent_id);\n+        ast::ii_ctor({node: {body: ctor_body, dec: ctor_decl, id: ctor_id\n+                              with ctor.node}\n+            with ctor}, nm, new_params, new_parent)\n+      }\n+     }\n }\n \n // ______________________________________________________________________"}, {"sha": "4587c1c740df29ef2907ac978a7f1fd939838945", "filename": "src/rustc/metadata/encoder.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/fd26743bedbd10f4c1cad7aecff50de6282d32dd/src%2Frustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd26743bedbd10f4c1cad7aecff50de6282d32dd/src%2Frustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fencoder.rs?ref=fd26743bedbd10f4c1cad7aecff50de6282d32dd", "patch": "@@ -368,6 +368,7 @@ fn encode_privacy(ebml_w: ebml::writer, privacy: privacy) {\n /* Returns an index of items in this class */\n fn encode_info_for_class(ecx: @encode_ctxt, ebml_w: ebml::writer,\n                          id: node_id, path: ast_map::path,\n+                         class_tps: [ty_param],\n                          items: [@class_member],\n                          global_index: @mut[entry<int>])\n  -> [entry<int>] {\n@@ -397,13 +398,10 @@ fn encode_info_for_class(ecx: @encode_ctxt, ebml_w: ebml::writer,\n                    but it works for now -- tjc */\n                 *global_index += [{val: m.id, pos: ebml_w.writer.tell()}];\n                 let impl_path = path + [ast_map::path_name(m.ident)];\n-                /*\n-                  Recall methods are (currently) monomorphic, and we don't\n-                  repeat the class's ty params in the method decl\n-                */\n                 #debug(\"encode_info_for_class: doing %s %d\", m.ident, m.id);\n                 encode_info_for_method(ecx, ebml_w, impl_path,\n-                                       should_inline(m.attrs), id, m, []);\n+                                       should_inline(m.attrs), id, m,\n+                                       class_tps + m.tps);\n             }\n             _ { /* don't encode private methods */ }\n           }\n@@ -415,7 +413,8 @@ fn encode_info_for_class(ecx: @encode_ctxt, ebml_w: ebml::writer,\n \n fn encode_info_for_fn(ecx: @encode_ctxt, ebml_w: ebml::writer,\n                       id: node_id, ident: ident, path: ast_map::path,\n-                      item: option<@item>, tps: [ty_param], decl: fn_decl) {\n+                      item: option<inlined_item>, tps: [ty_param],\n+                      decl: fn_decl) {\n         ebml_w.start_tag(tag_items_data_item);\n         encode_name(ebml_w, ident);\n         encode_def_id(ebml_w, local_def(id));\n@@ -428,7 +427,7 @@ fn encode_info_for_fn(ecx: @encode_ctxt, ebml_w: ebml::writer,\n         encode_path(ebml_w, path, ast_map::path_name(ident));\n         alt item {\n            some(it) {\n-             astencode::encode_inlined_item(ecx, ebml_w, path, ii_item(it));\n+             astencode::encode_inlined_item(ecx, ebml_w, path, it);\n            }\n            none {\n              encode_symbol(ecx, ebml_w, id);\n@@ -441,7 +440,7 @@ fn encode_info_for_method(ecx: @encode_ctxt, ebml_w: ebml::writer,\n                           impl_path: ast_map::path, should_inline: bool,\n                           parent_id: node_id,\n                           m: @method, all_tps: [ty_param]) {\n-    #debug(\"encode_info_for_method: %d %s\", m.id, m.ident);\n+    #debug(\"encode_info_for_method: %d %s %u\", m.id, m.ident, all_tps.len());\n     ebml_w.start_tag(tag_items_data_item);\n     encode_def_id(ebml_w, local_def(m.id));\n     encode_family(ebml_w, purity_fn_family(m.decl.purity));\n@@ -562,8 +561,8 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n            These come first because we need to write them to make\n            the index, and the index needs to be in the item for the\n            class itself */\n-        let idx = encode_info_for_class(ecx, ebml_w, item.id, path, items,\n-                                          index);\n+        let idx = encode_info_for_class(ecx, ebml_w, item.id, path, tps,\n+                                          items, index);\n         /* Index the class*/\n         add_to_index();\n         /* Now, make an item for the class itself */\n@@ -594,6 +593,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: ebml::writer, item: @item,\n                 #debug(\"Writing %s %d\", m.ident, m.id);\n                 encode_family(ebml_w, purity_fn_family(m.decl.purity));\n                 encode_name(ebml_w, m.ident);\n+                encode_type_param_bounds(ebml_w, ecx, tps + m.tps);\n                 encode_type(ecx, ebml_w, node_id_to_type(tcx, m.id));\n                 encode_def_id(ebml_w, local_def(m.id));\n                 ebml_w.end_tag();\n@@ -727,7 +727,6 @@ fn encode_info_for_items(ecx: @encode_ctxt, ebml_w: ebml::writer,\n             alt check ecx.ccx.tcx.items.get(i.id) {\n               ast_map::node_item(_, pt) {\n                 encode_info_for_item(ecx, ebml_w, i, index, *pt);\n-                /* TODO: encode info for class items! */\n                 /* encode ctor, then encode items */\n                 alt i.node {\n                   item_class(tps,_,ctor) {\n@@ -737,7 +736,10 @@ fn encode_info_for_items(ecx: @encode_ctxt, ebml_w: ebml::writer,\n                           ctor.node.id);\n                    *index += [{val: ctor.node.id, pos: ebml_w.writer.tell()}];\n                    encode_info_for_fn(ecx, ebml_w, ctor.node.id, i.ident,\n-                                      *pt, none, tps, ctor.node.dec)\n+                      *pt, if tps.len() > 0u {\n+                             some(ii_ctor(ctor, i.ident, tps,\n+                                          local_def(i.id))) }\n+                           else { none }, tps, ctor.node.dec)\n                   }\n                   _ {}\n                 }"}, {"sha": "b4a6e194b38c89a4dd8ba106955e575b6ec33f11", "filename": "src/rustc/middle/ast_map.rs", "status": "modified", "additions": 23, "deletions": 6, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/fd26743bedbd10f4c1cad7aecff50de6282d32dd/src%2Frustc%2Fmiddle%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd26743bedbd10f4c1cad7aecff50de6282d32dd/src%2Frustc%2Fmiddle%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fast_map.rs?ref=fd26743bedbd10f4c1cad7aecff50de6282d32dd", "patch": "@@ -44,10 +44,16 @@ enum ast_node {\n     // order they are introduced.\n     node_arg(arg, uint),\n     node_local(uint),\n-    node_ctor(@item, @path),\n+    // Constructor for either a resource or a class\n+    node_ctor(ident, [ty_param], a_ctor, @path),\n     node_block(blk),\n }\n \n+enum a_ctor {\n+  res_ctor(fn_decl, node_id, codemap::span),\n+  class_ctor(@class_ctor, def_id /* ID for parent class */),\n+}\n+\n type map = std::map::hashmap<node_id, ast_node>;\n type ctx = {map: map, mut path: path,\n             mut local_id: uint, sess: session};\n@@ -99,7 +105,7 @@ fn map_decoded_item(sess: session, map: map, path: path, ii: inlined_item) {\n     // don't decode and instantiate the impl, but just the method, we have to\n     // add it to the table now:\n     alt ii {\n-      ii_item(i) { /* fallthrough */ }\n+      ii_item(_) | ii_ctor(_,_,_,_) { /* fallthrough */ }\n       ii_native(i) {\n         cx.map.insert(i.id, node_native_item(i, native_abi_rust_intrinsic,\n                                              @path));\n@@ -119,6 +125,16 @@ fn map_fn(fk: visit::fn_kind, decl: fn_decl, body: blk,\n         cx.map.insert(a.id, node_arg(a, cx.local_id));\n         cx.local_id += 1u;\n     }\n+    alt fk {\n+      visit::fk_ctor(nm, tps, self_id, parent_id) {\n+          let ct = @{node: {id: id, self_id: self_id,\n+                           dec: decl, body: body},\n+                    span: sp};\n+          cx.map.insert(id, node_ctor(nm, tps, class_ctor(ct, parent_id),\n+                                      @cx.path));\n+       }\n+       _ {}\n+    }\n     visit::visit_fn(fk, decl, body, sp, id, cx, v);\n }\n \n@@ -166,8 +182,10 @@ fn map_item(i: @item, cx: ctx, v: vt) {\n             map_method(impl_did, extend(cx, i.ident), m, cx);\n         }\n       }\n-      item_res(_, _, _, dtor_id, ctor_id) {\n-        cx.map.insert(ctor_id, node_ctor(i, item_path));\n+      item_res(decl, tps, _, dtor_id, ctor_id) {\n+        cx.map.insert(ctor_id, node_ctor(i.ident, tps,\n+                                         res_ctor(decl, ctor_id, i.span),\n+                                         item_path));\n         cx.map.insert(dtor_id, node_item(i, item_path));\n       }\n       item_enum(vs, _) {\n@@ -186,7 +204,6 @@ fn map_item(i: @item, cx: ctx, v: vt) {\n         }\n       }\n       item_class(_, items, ctor) {\n-          cx.map.insert(ctor.node.id, node_ctor(i, item_path));\n           let d_id = ast_util::local_def(i.id);\n           let p = extend(cx, i.ident);\n           for items.each {|ci|\n@@ -267,7 +284,7 @@ fn node_id_to_str(map: map, id: node_id) -> str {\n       some(node_local(_)) { // FIXME: add more info here\n         #fmt[\"local (id=%?)\", id]\n       }\n-      some(node_ctor(_, _)) { // FIXME: add more info here\n+      some(node_ctor(_, _, _, _)) { // FIXME: add more info here\n         #fmt[\"node_ctor (id=%?)\", id]\n       }\n       some(node_block(_)) {"}, {"sha": "d6488334311e82f9f7da7581cb26213780974973", "filename": "src/rustc/middle/mutbl.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fd26743bedbd10f4c1cad7aecff50de6282d32dd/src%2Frustc%2Fmiddle%2Fmutbl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd26743bedbd10f4c1cad7aecff50de6282d32dd/src%2Frustc%2Fmiddle%2Fmutbl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fmutbl.rs?ref=fd26743bedbd10f4c1cad7aecff50de6282d32dd", "patch": "@@ -214,15 +214,15 @@ fn visit_expr(ex: @expr, &&cx: @ctx, v: visit::vt<@ctx>) {\n \n fn visit_item(item: @item, &&cx: @ctx, v: visit::vt<@ctx>) {\n     alt item.node {\n-            item_class(tps, items, ctor) {\n-                v.visit_ty_params(tps, cx, v);\n-                vec::map::<@class_member, ()>(items,\n-                    {|i| v.visit_class_item(i, cx, v); });\n-                v.visit_fn(visit::fk_ctor(item.ident, tps), ctor.node.dec,\n-                           ctor.node.body, ctor.span, ctor.node.id,\n-                           @{in_ctor: some(ctor.node.self_id) with *cx}, v);\n-            }\n-            _ { visit::visit_item(item, cx, v); }\n+      item_class(tps, items, ctor) {\n+         v.visit_ty_params(tps, cx, v);\n+         vec::map::<@class_member, ()>(items,\n+             {|i| v.visit_class_item(i, cx, v); });\n+         visit::visit_class_ctor_helper(ctor, item.ident, tps,\n+                                        ast_util::local_def(item.id),\n+                    @{in_ctor: some(ctor.node.self_id) with *cx}, v);\n+      }\n+      _ { visit::visit_item(item, cx, v); }\n     }\n }\n "}, {"sha": "611a3e36d051ce7a01a1c9d5970af7d1711ccff6", "filename": "src/rustc/middle/resolve.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd26743bedbd10f4c1cad7aecff50de6282d32dd/src%2Frustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd26743bedbd10f4c1cad7aecff50de6282d32dd/src%2Frustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fresolve.rs?ref=fd26743bedbd10f4c1cad7aecff50de6282d32dd", "patch": "@@ -572,7 +572,7 @@ fn visit_fn_with_scope(e: @env, fk: visit::fn_kind, decl: ast::fn_decl,\n     for decl.constraints.each {|c| resolve_constr(e, c, sc, v); }\n     let scope = alt fk {\n       visit::fk_item_fn(_, tps) | visit::fk_res(_, tps) |\n-      visit::fk_method(_, tps, _) | visit::fk_ctor(_, tps)\n+      visit::fk_method(_, tps, _) | visit::fk_ctor(_, tps, _, _)\n          { scope_bare_fn(decl, id, tps) }\n       visit::fk_anon(ast::proto_bare) { scope_bare_fn(decl, id, []) }\n       visit::fk_anon(_) | visit::fk_fn_block { scope_fn_expr(decl, id, []) }"}, {"sha": "fcb983a7291fcff8ff63dcd915ff303a1c57eedd", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 26, "deletions": 25, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/fd26743bedbd10f4c1cad7aecff50de6282d32dd/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd26743bedbd10f4c1cad7aecff50de6282d32dd/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=fd26743bedbd10f4c1cad7aecff50de6282d32dd", "patch": "@@ -1906,11 +1906,7 @@ fn monomorphic_fn(ccx: @crate_ctxt, fn_id: ast::def_id, real_substs: [ty::t],\n         ret {val: get_item_val(ccx, fn_id.node),\n              must_cast: true};\n       }\n-      ast_map::node_ctor(i, _) {\n-        alt check ccx.tcx.items.get(i.id) {\n-          ast_map::node_item(i, pt) { (pt, i.ident) }\n-        }\n-      }\n+      ast_map::node_ctor(nm, _, _, pt) { (pt, nm) }\n       _ { fail \"unexpected node type\"; }\n     };\n     let mono_ty = ty::substitute_type_params(ccx.tcx, substs, item_ty);\n@@ -1950,19 +1946,19 @@ fn monomorphic_fn(ccx: @crate_ctxt, fn_id: ast::def_id, real_substs: [ty::t],\n         trans_fn(ccx, pt, mth.decl, mth.body, lldecl,\n                  impl_self(selfty), psubsts, fn_id.node);\n       }\n-      ast_map::node_ctor(i, _) {\n-        alt check i.node {\n-          ast::item_res(decl, _, _, _, _) {\n+      ast_map::node_ctor(nm, tps, ct, _) {\n+        alt ct {\n+          ast_map::res_ctor(decl,_, _) {\n             set_inline_hint(lldecl);\n             trans_res_ctor(ccx, pt, decl, fn_id.node, psubsts, lldecl);\n           }\n-          ast::item_class(tps, _, ctor) {\n-            set_inline_hint_if_appr(i.attrs, lldecl);\n+          ast_map::class_ctor(ctor, parent_id) {\n+            // ctors don't have attrs, at least not right now\n             let tp_tys: [ty::t] = ty::ty_params_to_tys(ccx.tcx, tps);\n             trans_class_ctor(ccx, pt, ctor.node.dec, ctor.node.body, lldecl,\n                  option::get_or_default(psubsts,\n                    {tys:tp_tys, vtables: none, bounds: @[]}),\n-              fn_id.node, i.id, ctor.span);\n+              fn_id.node, parent_id, ctor.span);\n           }\n         }\n       }\n@@ -1992,6 +1988,10 @@ fn maybe_instantiate_inline(ccx: @crate_ctxt, fn_id: ast::def_id)\n             trans_item(ccx, *item);\n             local_def(item.id)\n           }\n+          csearch::found(ast::ii_ctor(ctor, nm, tps, parent_id)) {\n+            ccx.external.insert(fn_id, some(ctor.node.id));\n+            local_def(ctor.node.id)\n+          }\n           csearch::found(ast::ii_native(item)) {\n             ccx.external.insert(fn_id, some(item.id));\n             local_def(item.id)\n@@ -4256,17 +4256,17 @@ fn trans_const(ccx: @crate_ctxt, e: @ast::expr, id: ast::node_id) {\n fn trans_class_ctor(ccx: @crate_ctxt, path: path, decl: ast::fn_decl,\n                     body: ast::blk, llctor_decl: ValueRef,\n                     psubsts: param_substs, ctor_id: ast::node_id,\n-                    parent_id: ast::node_id, sp: span) {\n+                    parent_id: ast::def_id, sp: span) {\n   // Add ctor to the ctor map\n   ccx.class_ctors.insert(ctor_id, parent_id);\n+\n   // Translate the ctor\n \n   // Set up the type for the result of the ctor\n   // kludgy -- this wouldn't be necessary if the typechecker\n   // special-cased constructors, then we could just look up\n   // the ctor's return type.\n-  let rslt_ty =  ty::mk_class(ccx.tcx, local_def(parent_id),\n-                                    psubsts.tys);\n+  let rslt_ty =  ty::mk_class(ccx.tcx, parent_id, psubsts.tys);\n   // Make the fn context\n   let fcx = new_fn_ctxt_w_id(ccx, path, llctor_decl, ctor_id,\n                                    some(psubsts), some(sp));\n@@ -4280,10 +4280,10 @@ fn trans_class_ctor(ccx: @crate_ctxt, path: path, decl: ast::fn_decl,\n   // We *don't* want self to be passed to the ctor -- that\n   // wouldn't make sense\n   // So we initialize it here\n+\n   let selfptr = alloc_ty(bcx_top, rslt_ty);\n   // initialize fields to zero\n-  let fields = ty::class_items_as_fields(bcx_top.tcx(),\n-                                         local_def(parent_id),\n+  let fields = ty::class_items_as_fields(bcx_top.tcx(), parent_id,\n                                          psubsts.tys);\n   let mut bcx = bcx_top;\n   // Initialize fields to zero so init assignments can validly\n@@ -4381,7 +4381,7 @@ fn trans_item(ccx: @crate_ctxt, item: ast::item) {\n                          bounds: @[]};\n           trans_class_ctor(ccx, *path, ctor.node.dec, ctor.node.body,\n                          get_item_val(ccx, ctor.node.id), psubsts,\n-                         ctor.node.id, item.id, ctor.span);\n+                           ctor.node.id, local_def(item.id), ctor.span);\n         }\n         // If there are ty params, the ctor will get monomorphized\n \n@@ -4542,6 +4542,7 @@ fn item_path(ccx: @crate_ctxt, i: @ast::item) -> path {\n }\n \n fn get_item_val(ccx: @crate_ctxt, id: ast::node_id) -> ValueRef {\n+    #debug(\"get_item_val: %d\", id);\n     alt ccx.item_vals.find(id) {\n       some(v) { v }\n       none {\n@@ -4593,16 +4594,16 @@ fn get_item_val(ccx: @crate_ctxt, id: ast::node_id) -> ValueRef {\n             exprt = true;\n             register_fn(ccx, ni.span, *pth + [path_name(ni.ident)], ni.id)\n           }\n-          ast_map::node_ctor(i, _) {\n-            alt check i.node {\n-              ast::item_res(_, _, _, _, _) {\n-                let my_path = item_path(ccx, i);\n-                let llctor = register_fn(ccx, i.span, my_path, id);\n+          ast_map::node_ctor(nm, tps, ct, pt) {\n+            let my_path = *pt + [path_name(nm)];\n+            alt ct {\n+              ast_map::res_ctor(_,_,sp) {\n+                let llctor = register_fn(ccx, sp, my_path, id);\n                 set_inline_hint(llctor);\n                 llctor\n               }\n-              ast::item_class(_, _, ctor) {\n-                register_fn(ccx, i.span, item_path(ccx, i), id)\n+              ast_map::class_ctor(ctor, _) {\n+                register_fn(ccx, ctor.span, my_path, ctor.node.id)\n               }\n             }\n           }\n@@ -4923,7 +4924,7 @@ fn trans_crate(sess: session::session, crate: @ast::crate, tcx: ty::ctxt,\n           shape_cx: mk_ctxt(llmod),\n           crate_map: crate_map,\n           dbg_cx: dbg_cx,\n-          class_ctors: int_hash::<int>(),\n+          class_ctors: int_hash::<ast::def_id>(),\n           mut do_not_commit_warning_issued: false};\n \n "}, {"sha": "36c75398b9943eeb9f525639428eeb158085a659", "filename": "src/rustc/middle/trans/common.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fd26743bedbd10f4c1cad7aecff50de6282d32dd/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd26743bedbd10f4c1cad7aecff50de6282d32dd/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=fd26743bedbd10f4c1cad7aecff50de6282d32dd", "patch": "@@ -121,7 +121,9 @@ type crate_ctxt = {\n      dbg_cx: option<debuginfo::debug_ctxt>,\n      // Mapping from class constructors to parent class --\n      // used in base::trans_closure\n-     class_ctors: hashmap<ast::node_id, ast::node_id>,\n+     // parent_class must be a def_id because ctors can be\n+     // inlined, so the parent may be in a different crate\n+     class_ctors: hashmap<ast::node_id, ast::def_id>,\n      mut do_not_commit_warning_issued: bool};\n \n // Types used for llself."}, {"sha": "5406ec7ce98a1ec0db75498c7dfebc0da9f4b428", "filename": "src/rustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/fd26743bedbd10f4c1cad7aecff50de6282d32dd/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd26743bedbd10f4c1cad7aecff50de6282d32dd/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=fd26743bedbd10f4c1cad7aecff50de6282d32dd", "patch": "@@ -757,13 +757,14 @@ fn create_function(fcx: fn_ctxt) -> @metadata<subprogram_md> {\n       ast_map::node_method(method, _, _) {\n           (method.ident, method.decl.output, method.id)\n       }\n-      ast_map::node_ctor(item, _) {\n-        alt item.node {\n-            ast::item_res(decl, _, _, _, ctor_id) {\n-              (item.ident, decl.output, ctor_id)\n-            }\n-            _ { fcx.ccx.sess.span_bug(item.span, \"create_function: \\\n-                  expected an item_res here\"); }\n+      ast_map::node_ctor(nm, _, ct, _) {\n+        alt ct {\n+          ast_map::res_ctor(decl, ctor_id, _) {\n+            (nm, decl.output, ctor_id)\n+          }\n+          ast_map::class_ctor(ctor,_) {\n+            fcx.ccx.sess.span_bug(ctor.span, \"create_function: \\\n+                  expected a resource ctor here\"); }\n           }\n       }\n       ast_map::node_expr(expr) {"}, {"sha": "cbed8a0dbc553d7a0ea2e324e5a207530912546d", "filename": "src/rustc/middle/trans/type_use.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fd26743bedbd10f4c1cad7aecff50de6282d32dd/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd26743bedbd10f4c1cad7aecff50de6282d32dd/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=fd26743bedbd10f4c1cad7aecff50de6282d32dd", "patch": "@@ -58,13 +58,18 @@ fn type_uses_for(ccx: @crate_ctxt, fn_id: def_id, n_tps: uint)\n         ccx.type_use_cache.insert(fn_id, uses);\n         ret uses;\n     }\n-    alt check ccx.tcx.items.get(fn_id_loc.node) {\n+    let map_node = alt ccx.tcx.items.find(fn_id_loc.node) {\n+        some(x) { x }\n+        none    { ccx.sess.bug(#fmt(\"type_uses_for: unbound item ID %?\",\n+                                    fn_id_loc)); }\n+    };\n+    alt check map_node {\n       ast_map::node_item(@{node: item_fn(_, _, body), _}, _) |\n       ast_map::node_item(@{node: item_res(_, _, body, _, _), _}, _) |\n       ast_map::node_method(@{body, _}, _, _) {\n         handle_body(cx, body);\n       }\n-      ast_map::node_ctor(@{node: item_res(_, _, _, _, _), _},_) |\n+      ast_map::node_ctor(_, _, ast_map::res_ctor(_, _, _), _) |\n       ast_map::node_variant(_, _, _) {\n         uint::range(0u, n_tps) {|n| cx.uses[n] |= use_repr;}\n       }\n@@ -79,7 +84,7 @@ fn type_uses_for(ccx: @crate_ctxt, fn_id: def_id, n_tps: uint)\n             uint::range(0u, n_tps) {|n| cx.uses[n] |= flags;}\n         }\n       }\n-      ast_map::node_ctor(@{node: item_class(_, _, ctor), _}, _) {\n+      ast_map::node_ctor(_, _, ast_map::class_ctor(ctor, _), _){\n         handle_body(cx, ctor.node.body);\n       }\n     }"}, {"sha": "c04d9ad1e75823a961b66421f27847c8a7e31fcf", "filename": "src/rustc/middle/tstate/ck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd26743bedbd10f4c1cad7aecff50de6282d32dd/src%2Frustc%2Fmiddle%2Ftstate%2Fck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd26743bedbd10f4c1cad7aecff50de6282d32dd/src%2Frustc%2Fmiddle%2Ftstate%2Fck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fck.rs?ref=fd26743bedbd10f4c1cad7aecff50de6282d32dd", "patch": "@@ -111,7 +111,7 @@ fn check_states_against_conditions(fcx: fn_ctxt,\n \n     /* Check that the return value is initialized */\n     let post = aux::block_poststate(fcx.ccx, f_body);\n-    let is_ctor = alt fk { visit::fk_ctor(_,_) { true } _ { false } };\n+    let is_ctor = alt fk { visit::fk_ctor(_,_,_,_) { true } _ { false } };\n     if !is_ctor && !promises(fcx, post, fcx.enclosing.i_return) &&\n        !ty::type_is_nil(ty::ty_fn_ret(ty::node_id_to_type(\n            fcx.ccx.tcx, id))) &&"}, {"sha": "f4d134459be025e518d92bafc8c0301742fe5398", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fd26743bedbd10f4c1cad7aecff50de6282d32dd/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd26743bedbd10f4c1cad7aecff50de6282d32dd/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=fd26743bedbd10f4c1cad7aecff50de6282d32dd", "patch": "@@ -2043,8 +2043,8 @@ fn item_path(cx: ctxt, id: ast::def_id) -> ast_map::path {\n             vec::init(*path) + [ast_map::path_name(variant.node.name)]\n           }\n \n-          ast_map::node_ctor(i, path) {\n-              *path + [ast_map::path_name(i.ident)]\n+          ast_map::node_ctor(nm, _, _, path) {\n+              *path + [ast_map::path_name(nm)]\n           }\n \n           ast_map::node_expr(_) | ast_map::node_arg(_, _) |\n@@ -2121,7 +2121,6 @@ fn lookup_item_type(cx: ctxt, did: ast::def_id) -> ty_param_bounds_and_ty {\n     alt cx.tcache.find(did) {\n       some(tpt) { ret tpt; }\n       none {\n-          #debug(\"lookup_item_type: looking up %?\", did);\n         // The item is in this crate. The caller should have added it to the\n         // type cache already\n         assert did.crate != ast::local_crate;\n@@ -2168,7 +2167,10 @@ fn lookup_class_fields(cx: ctxt, did: ast::def_id) -> [field_ty] {\n            _ { cx.sess.bug(\"class ID bound to non-class\"); }\n          }\n        }\n-       _ { cx.sess.bug(\"class ID not bound to an item\"); }\n+       _ {\n+           cx.sess.bug(#fmt(\"class ID not bound to an item: %s\",\n+                            ast_map::node_id_to_str(cx.items, did.node)));\n+       }\n     }\n         }\n   else {"}, {"sha": "f89a34e668ffe6a152747c7cb0059bc817d9ac02", "filename": "src/rustc/middle/typeck.rs", "status": "modified", "additions": 27, "deletions": 1, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/fd26743bedbd10f4c1cad7aecff50de6282d32dd/src%2Frustc%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd26743bedbd10f4c1cad7aecff50de6282d32dd/src%2Frustc%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck.rs?ref=fd26743bedbd10f4c1cad7aecff50de6282d32dd", "patch": "@@ -2149,6 +2149,20 @@ fn impl_self_ty(tcx: ty::ctxt, did: ast::def_id) -> {n_tps: uint, ty: ty::t} {\n     }\n }\n \n+/*\n+  Takes arguments describing a method, and returns either its origin,\n+  or <none> if it's unbound.\n+\n+  expr: the entire method reference\n+  node_id: the method's ID\n+  name: the method's name\n+  ty: the type of the base expression\n+  tps: the ty substitutions that are part of the field expr\n+    (for example: in foo.bar<int,char>(), tps would be\n+     [int, char])\n+  include_private: true if we're inside the same class and should\n+     search private methods\n+ */\n fn lookup_method(fcx: @fn_ctxt, expr: @ast::expr, node_id: ast::node_id,\n                  name: ast::ident, ty: ty::t, tps: [ty::t],\n                  include_private: bool)\n@@ -2159,20 +2173,31 @@ fn lookup_method(fcx: @fn_ctxt, expr: @ast::expr, node_id: ast::node_id,\n         let mut substs = substs;\n         let n_tps = vec::len(substs), n_tys = vec::len(tps);\n         let has_self = ty::type_has_vars(fty);\n+        /* If either the method was declared to have ty params,\n+         or ty arguments were provided, or both... */\n         if method_n_tps + n_tps > 0u {\n+          /* If no type arguments were given,\n+             or a different number of them were given than the\n+             method's declared types... */\n             if n_tys == 0u || n_tys != method_n_tps {\n                 if n_tys != 0u {\n                     tcx.sess.span_err\n                         (expr.span, \"incorrect number of type \\\n                                      parameters given for this method\");\n \n                 }\n+                /* If not enough types were given, make some ty vars */\n                 substs += vec::from_fn(method_n_tps, {|_i|\n                     ty::mk_var(tcx, next_ty_var_id(fcx))\n                 });\n             } else {\n+             /* If the right number of types were given, just add them on */\n                 substs += tps;\n             }\n+            /*\n+              For a class method, \"substs\" here begins with the class ty\n+              params\n+             */\n             fcx.write_ty_substs(node_id, fty, substs);\n         } else {\n             if n_tys > 0u {\n@@ -2209,7 +2234,6 @@ fn lookup_method_inner_(tcx: ty::ctxt, ms: [ty::method],\n                         include_private: bool)\n     -> option<{method_ty: ty::t, n_tps: uint, substs: [ty::t],\n         origin: method_origin, self_sub: option<self_subst>}> {\n-    #debug(\"lookup_method_inner_: %? %? %s\", ms, parent, name);\n     let mut i = 0u;\n     for ms.each {|m|\n        if m.ident == name {\n@@ -2228,6 +2252,8 @@ fn lookup_method_inner_(tcx: ty::ctxt, ms: [ty::method],\n                         sp, \"Call to private method not allowed outside \\\n                           its defining class\");\n           }\n+          #debug(\"lookup_method_inner_: %s has %u ty params, by its \\\n+            declaration\", name, vec::len(*m.tps));\n           ret some({method_ty: fty,\n                     n_tps: vec::len(*m.tps),\n                     substs: tps,"}, {"sha": "15fa3e3e7855ad8267031d9205ea95beb2069e7e", "filename": "src/test/auxiliary/cci_class_6.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/fd26743bedbd10f4c1cad7aecff50de6282d32dd/src%2Ftest%2Fauxiliary%2Fcci_class_6.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd26743bedbd10f4c1cad7aecff50de6282d32dd/src%2Ftest%2Fauxiliary%2Fcci_class_6.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_class_6.rs?ref=fd26743bedbd10f4c1cad7aecff50de6282d32dd", "patch": "@@ -0,0 +1,21 @@\n+mod kitties {\n+\n+class cat<U> {\n+  priv {\n+    let mut info : [U];\n+    let mut meows : uint;\n+  }\n+\n+  let how_hungry : int;\n+\n+  new(in_x : uint, in_y : int, -in_info: [U])\n+    { self.meows = in_x; self.how_hungry = in_y;\n+      self.info <- in_info; }\n+\n+  fn speak<T>(stuff: [T]) {\n+    self.meows += stuff.len();\n+  }\n+  fn meow_count() -> uint { self.meows }\n+}\n+\n+}"}, {"sha": "28ddbfdd1e2fb8738fed844201e8c0b506058353", "filename": "src/test/run-pass/class-poly-methods-cross-crate.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/fd26743bedbd10f4c1cad7aecff50de6282d32dd/src%2Ftest%2Frun-pass%2Fclass-poly-methods-cross-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd26743bedbd10f4c1cad7aecff50de6282d32dd/src%2Ftest%2Frun-pass%2Fclass-poly-methods-cross-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-poly-methods-cross-crate.rs?ref=fd26743bedbd10f4c1cad7aecff50de6282d32dd", "patch": "@@ -0,0 +1,15 @@\n+// xfail-fast\n+// aux-build:cci_class_6.rs\n+use cci_class_6;\n+import cci_class_6::kitties::*;\n+\n+fn main() {\n+  let nyan : cat<char> = cat::<char>(52u, 99, ['p']);\n+  let kitty = cat(1000u, 2, [\"tabby\"]);\n+  assert(nyan.how_hungry == 99);\n+  assert(kitty.how_hungry == 2);\n+  nyan.speak([1u,2u,3u]);\n+  assert(nyan.meow_count() == 55u);\n+  kitty.speak([\"meow\", \"mew\", \"purr\", \"chirp\"]);\n+  assert(kitty.meow_count() == 1004u);\n+}"}, {"sha": "0d738913ee56dcaefdf9e6c99484bb12757b9797", "filename": "src/test/run-pass/class-poly-methods.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd26743bedbd10f4c1cad7aecff50de6282d32dd/src%2Ftest%2Frun-pass%2Fclass-poly-methods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd26743bedbd10f4c1cad7aecff50de6282d32dd/src%2Ftest%2Frun-pass%2Fclass-poly-methods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-poly-methods.rs?ref=fd26743bedbd10f4c1cad7aecff50de6282d32dd", "patch": "@@ -1,5 +1,3 @@\n-// xfail-test\n-// needs metadata encoding on Windows\n class cat<U> {\n   priv {\n     let mut info : [U];"}]}