{"sha": "173315e353a9c3c3b8ba2301eaac14fada41f84f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE3MzMxNWUzNTNhOWMzYzNiOGJhMjMwMWVhYWMxNGZhZGE0MWY4NGY=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2018-05-04T10:05:10Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2018-05-29T21:02:39Z"}, "message": "rust-lang/rust#27282: emit `ReadForMatch` on each match arm.\n\nAlso, turn on ReadForMatch emission by default (when using NLL).", "tree": {"sha": "ff3168b54d4ec1d39b2a99cdfbba692b8cb594c3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ff3168b54d4ec1d39b2a99cdfbba692b8cb594c3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/173315e353a9c3c3b8ba2301eaac14fada41f84f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/173315e353a9c3c3b8ba2301eaac14fada41f84f", "html_url": "https://github.com/rust-lang/rust/commit/173315e353a9c3c3b8ba2301eaac14fada41f84f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/173315e353a9c3c3b8ba2301eaac14fada41f84f/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "24abe6f363cd47d444e4cff1123da93817b980f8", "url": "https://api.github.com/repos/rust-lang/rust/commits/24abe6f363cd47d444e4cff1123da93817b980f8", "html_url": "https://github.com/rust-lang/rust/commit/24abe6f363cd47d444e4cff1123da93817b980f8"}], "stats": {"total": 111, "additions": 107, "deletions": 4}, "files": [{"sha": "35538e5d02a23b9cc390da69e33983cf32051933", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/173315e353a9c3c3b8ba2301eaac14fada41f84f/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/173315e353a9c3c3b8ba2301eaac14fada41f84f/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=173315e353a9c3c3b8ba2301eaac14fada41f84f", "patch": "@@ -1298,10 +1298,14 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n                        \"dump facts from NLL analysis into side files\"),\n     disable_nll_user_type_assert: bool = (false, parse_bool, [UNTRACKED],\n         \"disable user provided type assertion in NLL\"),\n+    nll_dont_emit_read_for_match: bool = (false, parse_bool, [UNTRACKED],\n+        \"in match codegen, do not include ReadForMatch statements (used by mir-borrowck)\"),\n     polonius: bool = (false, parse_bool, [UNTRACKED],\n         \"enable polonius-based borrow-checker\"),\n     codegen_time_graph: bool = (false, parse_bool, [UNTRACKED],\n         \"generate a graphical HTML report of time spent in codegen and LLVM\"),\n+    trans_time_graph: bool = (false, parse_bool, [UNTRACKED],\n+        \"generate a graphical HTML report of time spent in trans and LLVM\"),\n     thinlto: Option<bool> = (None, parse_opt_bool, [TRACKED],\n         \"enable ThinLTO when possible\"),\n     inline_in_all_cgus: Option<bool> = (None, parse_opt_bool, [TRACKED],"}, {"sha": "68f55b4993301fed0391b2246730d29878916c76", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/173315e353a9c3c3b8ba2301eaac14fada41f84f/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/173315e353a9c3c3b8ba2301eaac14fada41f84f/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=173315e353a9c3c3b8ba2301eaac14fada41f84f", "patch": "@@ -1356,6 +1356,19 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.borrowck_mode().use_mir()\n     }\n \n+    /// If true, make MIR codegen for `match` emit a temp that holds a\n+    /// borrow of the input to the match expression.\n+    pub fn generate_borrow_of_any_match_input(&self) -> bool {\n+        self.emit_read_for_match()\n+    }\n+\n+    /// If true, make MIR codegen for `match` emit ReadForMatch\n+    /// statements (which simulate the maximal effect of executing the\n+    /// patterns in a match arm).\n+    pub fn emit_read_for_match(&self) -> bool {\n+        self.use_mir_borrowck() && !self.sess.opts.debugging_opts.nll_dont_emit_read_for_match\n+    }\n+\n     /// If true, pattern variables for use in guards on match arms\n     /// will be bound as references to the data, and occurrences of\n     /// those variables in the guard expression will implicitly"}, {"sha": "67c9db1bf9ee2d6c550854e9cad76baa171581ed", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 90, "deletions": 4, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/173315e353a9c3c3b8ba2301eaac14fada41f84f/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/173315e353a9c3c3b8ba2301eaac14fada41f84f/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=173315e353a9c3c3b8ba2301eaac14fada41f84f", "patch": "@@ -30,6 +30,16 @@ mod simplify;\n mod test;\n mod util;\n \n+/// Injects a borrow of `place`. The region is unknown at this point; we rely on NLL\n+/// inference to find an appropriate one. Therefore you can only call this when NLL\n+/// is turned on.\n+fn inject_borrow<'a, 'gcx, 'tcx>(tcx: ty::TyCtxt<'a, 'gcx, 'tcx>,\n+                                 place: Place<'tcx>)\n+                                 -> Rvalue<'tcx> {\n+    assert!(tcx.use_mir_borrowck());\n+    Rvalue::Ref(tcx.types.re_empty, BorrowKind::Shared, place)\n+}\n+\n /// ArmHasGuard is isomorphic to a boolean flag. It indicates whether\n /// a match arm has a guard expression attached to it.\n #[derive(Copy, Clone, Debug)]\n@@ -43,6 +53,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                       discriminant: ExprRef<'tcx>,\n                       arms: Vec<Arm<'tcx>>)\n                       -> BlockAnd<()> {\n+        let tcx = self.hir.tcx();\n         let discriminant_place = unpack!(block = self.as_place(block, discriminant));\n \n         // Matching on a `discriminant_place` with an uninhabited type doesn't\n@@ -55,16 +66,34 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         // HACK(eddyb) Work around the above issue by adding a dummy inspection\n         // of `discriminant_place`, specifically by applying `Rvalue::Discriminant`\n         // (which will work regardless of type) and storing the result in a temp.\n+        //\n+        // FIXME: would just the borrow into `borrowed_input_temp`\n+        // also achieve the desired effect here? TBD.\n         let dummy_source_info = self.source_info(span);\n         let dummy_access = Rvalue::Discriminant(discriminant_place.clone());\n-        let dummy_ty = dummy_access.ty(&self.local_decls, self.hir.tcx());\n+        let dummy_ty = dummy_access.ty(&self.local_decls, tcx);\n         let dummy_temp = self.temp(dummy_ty, dummy_source_info.span);\n         self.cfg.push_assign(block, dummy_source_info, &dummy_temp, dummy_access);\n \n+        let source_info = self.source_info(span);\n+        let borrowed_input_temp = if tcx.generate_borrow_of_any_match_input() {\n+            let borrowed_input = inject_borrow(tcx, discriminant_place.clone());\n+            let borrowed_input_ty = borrowed_input.ty(&self.local_decls, tcx);\n+            let borrowed_input_temp = self.temp(borrowed_input_ty, span);\n+            self.cfg.push_assign(block, source_info, &borrowed_input_temp, borrowed_input);\n+            Some(borrowed_input_temp)\n+        } else {\n+            None\n+        };\n+\n         let mut arm_blocks = ArmBlocks {\n             blocks: arms.iter()\n-                        .map(|_| self.cfg.start_new_block())\n-                        .collect(),\n+                .map(|_| {\n+                    let arm_block = self.cfg.start_new_block();\n+                    arm_block\n+                })\n+                .collect(),\n+\n         };\n \n         // Get the arm bodies and their scopes, while declaring bindings.\n@@ -81,7 +110,9 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         // create binding start block for link them by false edges\n         let candidate_count = arms.iter().fold(0, |ac, c| ac + c.patterns.len());\n         let pre_binding_blocks: Vec<_> = (0..candidate_count + 1)\n-            .map(|_| self.cfg.start_new_block()).collect();\n+            .map(|_| self.cfg.start_new_block())\n+\n+            .collect();\n \n         // assemble a list of candidates: there is one candidate per\n         // pattern, which means there may be more than one candidate\n@@ -99,6 +130,61 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 .zip(pre_binding_blocks.iter().zip(pre_binding_blocks.iter().skip(1)))\n                 .map(|((arm_index, pattern, guard),\n                        (pre_binding_block, next_candidate_pre_binding_block))| {\n+\n+                    if let (true, Some(borrow_temp)) = (tcx.emit_read_for_match(),\n+                                                        borrowed_input_temp.clone()) {\n+                        // inject a fake read of the borrowed input at\n+                        // the start of each arm's pattern testing\n+                        // code.\n+                        //\n+                        // This should ensure that you cannot change\n+                        // the variant for an enum while you are in\n+                        // the midst of matching on it.\n+                        //\n+                        // FIXME: I originally had put this at the\n+                        // start of each elem of arm_blocks (see\n+                        // ArmBlocks construction above). But this was\n+                        // broken; for example, when you had a trivial\n+                        // match like `match \"foo\".to_string() { _s =>\n+                        // {} }`, it would inject a ReadForMatch\n+                        // *after* the move of the input into `_s`,\n+                        // and that then does not pass the borrow\n+                        // check.\n+                        //\n+                        // * So: I need to fine tune exactly *where*\n+                        //   the ReadForMatch belongs. Should it come\n+                        //   at the beginning of each pattern match,\n+                        //   or the end? And, should there be one\n+                        //   ReadForMatch per arm, or one per\n+                        //   candidate (aka pattern)?\n+\n+                        self.cfg.push(*pre_binding_block, Statement {\n+                            source_info,\n+                            kind: StatementKind::ReadForMatch(borrow_temp.clone()),\n+                        });\n+                    }\n+\n+                    // One might ask: why not build up the match pair such that it\n+                    // matches via `borrowed_input_temp.deref()` instead of\n+                    // using the `discriminant_place` directly, as it is doing here?\n+                    //\n+                    // The basic answer is that if you do that, then you end up with\n+                    // accceses to a shared borrow of the input and that conflicts with\n+                    // any arms that look like e.g.\n+                    //\n+                    // match Some(&4) {\n+                    //     ref mut foo => {\n+                    //         ... /* mutate `foo` in arm body */ ...\n+                    //     }\n+                    // }\n+                    //\n+                    // (Perhaps we could further revise the MIR\n+                    //  construction here so that it only does a\n+                    //  shared borrow at the outset and delays doing\n+                    //  the mutable borrow until after the pattern is\n+                    //  matched *and* the guard (if any) for the arm\n+                    //  has been run.)\n+\n                     Candidate {\n                         span: pattern.span,\n                         match_pairs: vec![MatchPair::new(discriminant_place.clone(), pattern)],"}]}