{"sha": "2f376f74750d054a69e6f633647d5a7d65dd2e94", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJmMzc2Zjc0NzUwZDA1NGE2OWU2ZjYzMzY0N2Q1YTdkNjVkZDJlOTQ=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-06-07T17:37:48Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-06-07T17:37:48Z"}, "message": "Merge #9169\n\n9169: internal: steps towards attribute macro token mapping r=jonas-schievink a=jonas-schievink\n\nThis doesn't work yet, but we seem to be getting a bit further along (for example, we now stop highlighting `use` items inside item with attribute macros as if they were written verbatim).\r\n\r\nbors r+\n\nCo-authored-by: Jonas Schievink <jonasschievink@gmail.com>", "tree": {"sha": "968a9caa232b0f31a1711f89d9b689402b6d8df4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/968a9caa232b0f31a1711f89d9b689402b6d8df4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2f376f74750d054a69e6f633647d5a7d65dd2e94", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgvllsCRBK7hj4Ov3rIwAAvmEIAKKZdIfdds9oQ1d9sxnt89XF\nF5CgWfrqi9SxisFmUASgld2VSSjvUXb8lDxvc5VWwGpDnDWTPDDyQ2ASbH8P6u4G\nR/S85oANqWJ3QZYmGz3heKuOYDJR7MgULOXsL4/dtBN9InGr0k3fSFdWfklSnKX0\nXx3XXTMKBi+I6q4WZSXcVX6NWKINxpuyDWv53VuVlrSg0B+dnuR773Q+ERUAl8Ps\nqvlfADWA1IuSuPljgFWgcQh7wfyUy0DtfaNg3IHA0GMIRlzCTs4n0/xcverGss8i\noh6eyER5t7lbNpZTf8xuqmeJoT02TXs8/Y7nVmc3kzJObvNzcUCCq95cglNrrFg=\n=yzuj\n-----END PGP SIGNATURE-----\n", "payload": "tree 968a9caa232b0f31a1711f89d9b689402b6d8df4\nparent 1aff3b4dfc9c8fd2621c9e6fc6fa3a8a870d7c16\nparent 33be5762e579a9e03288ba27821951ca7db3a68e\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1623087468 +0000\ncommitter GitHub <noreply@github.com> 1623087468 +0000\n\nMerge #9169\n\n9169: internal: steps towards attribute macro token mapping r=jonas-schievink a=jonas-schievink\n\nThis doesn't work yet, but we seem to be getting a bit further along (for example, we now stop highlighting `use` items inside item with attribute macros as if they were written verbatim).\r\n\r\nbors r+\n\nCo-authored-by: Jonas Schievink <jonasschievink@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2f376f74750d054a69e6f633647d5a7d65dd2e94", "html_url": "https://github.com/rust-lang/rust/commit/2f376f74750d054a69e6f633647d5a7d65dd2e94", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2f376f74750d054a69e6f633647d5a7d65dd2e94/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1aff3b4dfc9c8fd2621c9e6fc6fa3a8a870d7c16", "url": "https://api.github.com/repos/rust-lang/rust/commits/1aff3b4dfc9c8fd2621c9e6fc6fa3a8a870d7c16", "html_url": "https://github.com/rust-lang/rust/commit/1aff3b4dfc9c8fd2621c9e6fc6fa3a8a870d7c16"}, {"sha": "33be5762e579a9e03288ba27821951ca7db3a68e", "url": "https://api.github.com/repos/rust-lang/rust/commits/33be5762e579a9e03288ba27821951ca7db3a68e", "html_url": "https://github.com/rust-lang/rust/commit/33be5762e579a9e03288ba27821951ca7db3a68e"}], "stats": {"total": 200, "additions": 170, "deletions": 30}, "files": [{"sha": "2d08a7704fa5430a6f36a18483e0dda968bcfb3a", "filename": "crates/hir/src/semantics.rs", "status": "modified", "additions": 75, "deletions": 17, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/2f376f74750d054a69e6f633647d5a7d65dd2e94/crates%2Fhir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f376f74750d054a69e6f633647d5a7d65dd2e94/crates%2Fhir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsemantics.rs?ref=2f376f74750d054a69e6f633647d5a7d65dd2e94", "patch": "@@ -117,6 +117,16 @@ impl<'db, DB: HirDatabase> Semantics<'db, DB> {\n     pub fn expand(&self, macro_call: &ast::MacroCall) -> Option<SyntaxNode> {\n         self.imp.expand(macro_call)\n     }\n+\n+    /// If `item` has an attribute macro attached to it, expands it.\n+    pub fn expand_attr_macro(&self, item: &ast::Item) -> Option<SyntaxNode> {\n+        self.imp.expand_attr_macro(item)\n+    }\n+\n+    pub fn is_attr_macro_call(&self, item: &ast::Item) -> bool {\n+        self.imp.is_attr_macro_call(item)\n+    }\n+\n     pub fn speculative_expand(\n         &self,\n         actual_macro_call: &ast::MacroCall,\n@@ -332,6 +342,22 @@ impl<'db> SemanticsImpl<'db> {\n         Some(node)\n     }\n \n+    fn expand_attr_macro(&self, item: &ast::Item) -> Option<SyntaxNode> {\n+        let sa = self.analyze(item.syntax());\n+        let src = InFile::new(sa.file_id, item.clone());\n+        let macro_call_id = self.with_ctx(|ctx| ctx.item_to_macro_call(src))?;\n+        let file_id = macro_call_id.as_file();\n+        let node = self.db.parse_or_expand(file_id)?;\n+        self.cache(node.clone(), file_id);\n+        Some(node)\n+    }\n+\n+    fn is_attr_macro_call(&self, item: &ast::Item) -> bool {\n+        let sa = self.analyze(item.syntax());\n+        let src = InFile::new(sa.file_id, item.clone());\n+        self.with_ctx(|ctx| ctx.item_to_macro_call(src).is_some())\n+    }\n+\n     fn speculative_expand(\n         &self,\n         actual_macro_call: &ast::MacroCall,\n@@ -362,25 +388,57 @@ impl<'db> SemanticsImpl<'db> {\n \n         let token = successors(Some(InFile::new(sa.file_id, token)), |token| {\n             self.db.unwind_if_cancelled();\n-            let macro_call = token.value.ancestors().find_map(ast::MacroCall::cast)?;\n-            let tt = macro_call.token_tree()?;\n-            if !tt.syntax().text_range().contains_range(token.value.text_range()) {\n-                return None;\n-            }\n-            let file_id = sa.expand(self.db, token.with_value(&macro_call))?;\n-            let token = self\n-                .expansion_info_cache\n-                .borrow_mut()\n-                .entry(file_id)\n-                .or_insert_with(|| file_id.expansion_info(self.db.upcast()))\n-                .as_ref()?\n-                .map_token_down(token.as_ref())?;\n-\n-            if let Some(parent) = token.value.parent() {\n-                self.cache(find_root(&parent), token.file_id);\n+\n+            for node in token.value.ancestors() {\n+                match_ast! {\n+                    match node {\n+                        ast::MacroCall(macro_call) => {\n+                            let tt = macro_call.token_tree()?;\n+                            if !tt.syntax().text_range().contains_range(token.value.text_range()) {\n+                                return None;\n+                            }\n+                            let file_id = sa.expand(self.db, token.with_value(&macro_call))?;\n+                            let token = self\n+                                .expansion_info_cache\n+                                .borrow_mut()\n+                                .entry(file_id)\n+                                .or_insert_with(|| file_id.expansion_info(self.db.upcast()))\n+                                .as_ref()?\n+                                .map_token_down(token.as_ref())?;\n+\n+                            if let Some(parent) = token.value.parent() {\n+                                self.cache(find_root(&parent), token.file_id);\n+                            }\n+\n+                            return Some(token);\n+                        },\n+                        ast::Item(item) => {\n+                            match self.with_ctx(|ctx| ctx.item_to_macro_call(token.with_value(item))) {\n+                                Some(call_id) => {\n+                                    let file_id = call_id.as_file();\n+                                    let token = self\n+                                        .expansion_info_cache\n+                                        .borrow_mut()\n+                                        .entry(file_id)\n+                                        .or_insert_with(|| file_id.expansion_info(self.db.upcast()))\n+                                        .as_ref()?\n+                                        .map_token_down(token.as_ref())?;\n+\n+                                    if let Some(parent) = token.value.parent() {\n+                                        self.cache(find_root(&parent), token.file_id);\n+                                    }\n+\n+                                    return Some(token);\n+                                }\n+                                None => {}\n+                            }\n+                        },\n+                        _ => {}\n+                    }\n+                }\n             }\n \n-            Some(token)\n+            None\n         })\n         .last()\n         .unwrap();"}, {"sha": "22e196196ded02fc80bff4367e9cfb5b41506286", "filename": "crates/hir/src/semantics/source_to_def.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/2f376f74750d054a69e6f633647d5a7d65dd2e94/crates%2Fhir%2Fsrc%2Fsemantics%2Fsource_to_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f376f74750d054a69e6f633647d5a7d65dd2e94/crates%2Fhir%2Fsrc%2Fsemantics%2Fsource_to_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsemantics%2Fsource_to_def.rs?ref=2f376f74750d054a69e6f633647d5a7d65dd2e94", "patch": "@@ -10,7 +10,7 @@ use hir_def::{\n     ImplId, LifetimeParamId, ModuleId, StaticId, StructId, TraitId, TypeAliasId, TypeParamId,\n     UnionId, VariantId,\n };\n-use hir_expand::{name::AsName, AstId, MacroDefKind};\n+use hir_expand::{name::AsName, AstId, MacroCallId, MacroDefKind};\n use rustc_hash::FxHashMap;\n use smallvec::SmallVec;\n use stdx::impl_from;\n@@ -145,16 +145,25 @@ impl SourceToDefCtx<'_, '_> {\n         Some((container, label_id))\n     }\n \n+    pub(super) fn item_to_macro_call(&mut self, src: InFile<ast::Item>) -> Option<MacroCallId> {\n+        let map = self.dyn_map(src.as_ref())?;\n+        map[keys::ATTR_MACRO].get(&src).copied()\n+    }\n+\n     fn to_def<Ast: AstNode + 'static, ID: Copy + 'static>(\n         &mut self,\n         src: InFile<Ast>,\n         key: Key<Ast, ID>,\n     ) -> Option<ID> {\n-        let container = self.find_container(src.as_ref().map(|it| it.syntax()))?;\n+        self.dyn_map(src.as_ref())?[key].get(&src).copied()\n+    }\n+\n+    fn dyn_map<Ast: AstNode + 'static>(&mut self, src: InFile<&Ast>) -> Option<&DynMap> {\n+        let container = self.find_container(src.map(|it| it.syntax()))?;\n         let db = self.db;\n         let dyn_map =\n             &*self.cache.entry(container).or_insert_with(|| container.child_by_source(db));\n-        dyn_map[key].get(&src).copied()\n+        Some(dyn_map)\n     }\n \n     pub(super) fn type_param_to_def(&mut self, src: InFile<ast::TypeParam>) -> Option<TypeParamId> {"}, {"sha": "f22383e221d9bb8abcfbbc4862842c2da00223cb", "filename": "crates/hir_def/src/child_by_source.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2f376f74750d054a69e6f633647d5a7d65dd2e94/crates%2Fhir_def%2Fsrc%2Fchild_by_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f376f74750d054a69e6f633647d5a7d65dd2e94/crates%2Fhir_def%2Fsrc%2Fchild_by_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fchild_by_source.rs?ref=2f376f74750d054a69e6f633647d5a7d65dd2e94", "patch": "@@ -85,6 +85,10 @@ impl ChildBySource for ItemScope {\n             res[keys::CONST].insert(src, konst);\n         });\n         self.impls().for_each(|imp| add_impl(db, res, imp));\n+        self.attr_macro_invocs().for_each(|(ast_id, call_id)| {\n+            let item = ast_id.with_value(ast_id.to_node(db.upcast()));\n+            res[keys::ATTR_MACRO].insert(item, call_id);\n+        });\n \n         fn add_module_def(db: &dyn DefDatabase, map: &mut DynMap, item: ModuleDefId) {\n             match item {"}, {"sha": "0f74f050da627251bd0063fb0015a91509e6ddec", "filename": "crates/hir_def/src/item_scope.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/2f376f74750d054a69e6f633647d5a7d65dd2e94/crates%2Fhir_def%2Fsrc%2Fitem_scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f376f74750d054a69e6f633647d5a7d65dd2e94/crates%2Fhir_def%2Fsrc%2Fitem_scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fitem_scope.rs?ref=2f376f74750d054a69e6f633647d5a7d65dd2e94", "patch": "@@ -4,11 +4,11 @@\n use std::collections::hash_map::Entry;\n \n use base_db::CrateId;\n-use hir_expand::name::Name;\n-use hir_expand::MacroDefKind;\n+use hir_expand::{name::Name, AstId, MacroCallId, MacroDefKind};\n use once_cell::sync::Lazy;\n use rustc_hash::{FxHashMap, FxHashSet};\n use stdx::format_to;\n+use syntax::ast;\n \n use crate::{\n     db::DefDatabase, per_ns::PerNs, visibility::Visibility, AdtId, BuiltinType, ConstId, ImplId,\n@@ -53,6 +53,7 @@ pub struct ItemScope {\n     // FIXME: Macro shadowing in one module is not properly handled. Non-item place macros will\n     // be all resolved to the last one defined if shadowing happens.\n     legacy_macros: FxHashMap<Name, MacroDefId>,\n+    attr_macros: FxHashMap<AstId<ast::Item>, MacroCallId>,\n }\n \n pub(crate) static BUILTIN_SCOPE: Lazy<FxHashMap<Name, PerNs>> = Lazy::new(|| {\n@@ -169,6 +170,16 @@ impl ItemScope {\n         self.legacy_macros.insert(name, mac);\n     }\n \n+    pub(crate) fn add_attr_macro_invoc(&mut self, item: AstId<ast::Item>, call: MacroCallId) {\n+        self.attr_macros.insert(item, call);\n+    }\n+\n+    pub(crate) fn attr_macro_invocs(\n+        &self,\n+    ) -> impl Iterator<Item = (AstId<ast::Item>, MacroCallId)> + '_ {\n+        self.attr_macros.iter().map(|(k, v)| (*k, *v))\n+    }\n+\n     pub(crate) fn unnamed_trait_vis(&self, tr: TraitId) -> Option<Visibility> {\n         self.unnamed_trait_imports.get(&tr).copied()\n     }\n@@ -307,6 +318,7 @@ impl ItemScope {\n             unnamed_consts,\n             unnamed_trait_imports,\n             legacy_macros,\n+            attr_macros,\n         } = self;\n         types.shrink_to_fit();\n         values.shrink_to_fit();\n@@ -317,6 +329,7 @@ impl ItemScope {\n         unnamed_consts.shrink_to_fit();\n         unnamed_trait_imports.shrink_to_fit();\n         legacy_macros.shrink_to_fit();\n+        attr_macros.shrink_to_fit();\n     }\n }\n "}, {"sha": "688cd9fcff6a55cf2be3a2ae6b4ff685267b10c2", "filename": "crates/hir_def/src/keys.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2f376f74750d054a69e6f633647d5a7d65dd2e94/crates%2Fhir_def%2Fsrc%2Fkeys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f376f74750d054a69e6f633647d5a7d65dd2e94/crates%2Fhir_def%2Fsrc%2Fkeys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fkeys.rs?ref=2f376f74750d054a69e6f633647d5a7d65dd2e94", "patch": "@@ -2,7 +2,7 @@\n \n use std::marker::PhantomData;\n \n-use hir_expand::{InFile, MacroDefId};\n+use hir_expand::{InFile, MacroCallId, MacroDefId};\n use rustc_hash::FxHashMap;\n use syntax::{ast, AstNode, AstPtr};\n \n@@ -32,6 +32,7 @@ pub const LIFETIME_PARAM: Key<ast::LifetimeParam, LifetimeParamId> = Key::new();\n pub const CONST_PARAM: Key<ast::ConstParam, ConstParamId> = Key::new();\n \n pub const MACRO: Key<ast::MacroCall, MacroDefId> = Key::new();\n+pub const ATTR_MACRO: Key<ast::Item, MacroCallId> = Key::new();\n \n /// XXX: AST Nodes and SyntaxNodes have identity equality semantics: nodes are\n /// equal if they point to exactly the same object."}, {"sha": "d019ba3a9626c45afbe7f46e8c5d32ed727440d5", "filename": "crates/hir_def/src/nameres/collector.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2f376f74750d054a69e6f633647d5a7d65dd2e94/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f376f74750d054a69e6f633647d5a7d65dd2e94/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs?ref=2f376f74750d054a69e6f633647d5a7d65dd2e94", "patch": "@@ -1112,6 +1112,11 @@ impl DefCollector<'_> {\n                                     return false;\n                                 }\n                             }\n+\n+                            self.def_map.modules[directive.module_id]\n+                                .scope\n+                                .add_attr_macro_invoc(ast_id.ast_id, call_id);\n+\n                             resolved.push((directive.module_id, call_id, directive.depth));\n                             res = ReachedFixedPoint::No;\n                             return false;"}, {"sha": "3f38e2145edfe025899f30c6eca7661c1538ef84", "filename": "crates/ide/src/expand_macro.rs", "status": "modified", "additions": 27, "deletions": 7, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/2f376f74750d054a69e6f633647d5a7d65dd2e94/crates%2Fide%2Fsrc%2Fexpand_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f376f74750d054a69e6f633647d5a7d65dd2e94/crates%2Fide%2Fsrc%2Fexpand_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fexpand_macro.rs?ref=2f376f74750d054a69e6f633647d5a7d65dd2e94", "patch": "@@ -3,8 +3,7 @@ use std::iter;\n use hir::Semantics;\n use ide_db::RootDatabase;\n use syntax::{\n-    algo::find_node_at_offset, ast, ted, AstNode, NodeOrToken, SyntaxKind, SyntaxKind::*,\n-    SyntaxNode, WalkEvent, T,\n+    ast, match_ast, ted, AstNode, NodeOrToken, SyntaxKind, SyntaxKind::*, SyntaxNode, WalkEvent, T,\n };\n \n use crate::FilePosition;\n@@ -28,16 +27,37 @@ pub struct ExpandedMacro {\n pub(crate) fn expand_macro(db: &RootDatabase, position: FilePosition) -> Option<ExpandedMacro> {\n     let sema = Semantics::new(db);\n     let file = sema.parse(position.file_id);\n-    let mac = find_node_at_offset::<ast::MacroCall>(file.syntax(), position.offset)?;\n-    let name = mac.path()?.segment()?.name_ref()?;\n \n-    let expanded = expand_macro_recur(&sema, &mac)?;\n+    let tok = file.syntax().token_at_offset(position.offset).left_biased()?;\n+    let mut expanded = None;\n+    let mut name = None;\n+    for node in tok.ancestors() {\n+        match_ast! {\n+            match node {\n+                ast::MacroCall(mac) => {\n+                    name = Some(mac.path()?.segment()?.name_ref()?.to_string());\n+                    expanded = expand_macro_recur(&sema, &mac);\n+                    break;\n+                },\n+                ast::Item(item) => {\n+                    // FIXME: add the macro name\n+                    // FIXME: make this recursive too\n+                    name = Some(\"?\".to_string());\n+                    expanded = sema.expand_attr_macro(&item);\n+                    if expanded.is_some() {\n+                        break;\n+                    }\n+                },\n+                _ => {}\n+            }\n+        }\n+    }\n \n     // FIXME:\n     // macro expansion may lose all white space information\n     // But we hope someday we can use ra_fmt for that\n-    let expansion = insert_whitespaces(expanded);\n-    Some(ExpandedMacro { name: name.to_string(), expansion })\n+    let expansion = insert_whitespaces(expanded?);\n+    Some(ExpandedMacro { name: name?, expansion })\n }\n \n fn expand_macro_recur("}, {"sha": "b03f1c71f170303413adae3fd5c5fdf93aa13d43", "filename": "crates/ide/src/syntax_highlighting.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/2f376f74750d054a69e6f633647d5a7d65dd2e94/crates%2Fide%2Fsrc%2Fsyntax_highlighting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f376f74750d054a69e6f633647d5a7d65dd2e94/crates%2Fide%2Fsrc%2Fsyntax_highlighting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting.rs?ref=2f376f74750d054a69e6f633647d5a7d65dd2e94", "patch": "@@ -192,6 +192,7 @@ fn traverse(\n     let mut bindings_shadow_count: FxHashMap<Name, u32> = FxHashMap::default();\n \n     let mut current_macro_call: Option<ast::MacroCall> = None;\n+    let mut current_attr_macro_call = None;\n     let mut current_macro: Option<ast::Macro> = None;\n     let mut macro_highlighter = MacroHighlighter::default();\n     let mut inside_attribute = false;\n@@ -227,6 +228,19 @@ fn traverse(\n             }\n             _ => (),\n         }\n+        match event.clone().map(|it| it.into_node().and_then(ast::Item::cast)) {\n+            WalkEvent::Enter(Some(item)) => {\n+                if sema.is_attr_macro_call(&item) {\n+                    current_attr_macro_call = Some(item);\n+                }\n+            }\n+            WalkEvent::Leave(Some(item)) => {\n+                if current_attr_macro_call == Some(item) {\n+                    current_attr_macro_call = None;\n+                }\n+            }\n+            _ => (),\n+        }\n \n         match event.clone().map(|it| it.into_node().and_then(ast::Macro::cast)) {\n             WalkEvent::Enter(Some(mac)) => {\n@@ -286,6 +300,22 @@ fn traverse(\n                 }\n                 None => token.into(),\n             }\n+        } else if current_attr_macro_call.is_some() {\n+            let token = match element.clone().into_token() {\n+                Some(it) => it,\n+                _ => continue,\n+            };\n+            let token = sema.descend_into_macros(token.clone());\n+            match token.parent() {\n+                Some(parent) => {\n+                    // We only care Name and Name_ref\n+                    match (token.kind(), parent.kind()) {\n+                        (IDENT, NAME) | (IDENT, NAME_REF) => parent.into(),\n+                        _ => token.into(),\n+                    }\n+                }\n+                None => token.into(),\n+            }\n         } else {\n             element.clone()\n         };"}]}