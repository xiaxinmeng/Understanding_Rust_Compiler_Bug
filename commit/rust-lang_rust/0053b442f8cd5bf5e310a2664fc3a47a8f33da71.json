{"sha": "0053b442f8cd5bf5e310a2664fc3a47a8f33da71", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAwNTNiNDQyZjhjZDViZjVlMzEwYTI2NjRmYzNhNDdhOGYzM2RhNzE=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-03-24T16:49:04Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-05-11T01:14:58Z"}, "message": "rustc_typeck: Use Deref for FnCtxt, Inherited and InferCtxt fields and methods.", "tree": {"sha": "086be6236e61e4663b9bd57ff0a61059779bb480", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/086be6236e61e4663b9bd57ff0a61059779bb480"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0053b442f8cd5bf5e310a2664fc3a47a8f33da71", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0053b442f8cd5bf5e310a2664fc3a47a8f33da71", "html_url": "https://github.com/rust-lang/rust/commit/0053b442f8cd5bf5e310a2664fc3a47a8f33da71", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0053b442f8cd5bf5e310a2664fc3a47a8f33da71/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "url": "https://api.github.com/repos/rust-lang/rust/commits/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4", "html_url": "https://github.com/rust-lang/rust/commit/76affa5d6f5d1b8c3afcd4e0c6bbaee1fb0daeb4"}], "stats": {"total": 1659, "additions": 804, "deletions": 855}, "files": [{"sha": "1dab0c97b8a536c275e7db45fa894cfbcf0fb79e", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 31, "deletions": 32, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/0053b442f8cd5bf5e310a2664fc3a47a8f33da71/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0053b442f8cd5bf5e310a2664fc3a47a8f33da71/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=0053b442f8cd5bf5e310a2664fc3a47a8f33da71", "patch": "@@ -58,7 +58,7 @@ fn bad_struct_kind_err(sess: &Session, pat: &hir::Pat, path: &hir::Path, lint: b\n \n impl<'a, 'tcx> PatCtxt<'a, 'tcx, 'tcx> {\n pub fn check_pat(&self, pat: &'tcx hir::Pat, expected: Ty<'tcx>) {\n-    let tcx = self.tcx();\n+    let tcx = self.tcx;\n \n     debug!(\"check_pat(pat={:?},expected={:?})\", pat, expected);\n \n@@ -126,15 +126,15 @@ pub fn check_pat(&self, pat: &'tcx hir::Pat, expected: Ty<'tcx>) {\n                 span_err!(tcx.sess, span, E0029,\n                           \"only char and numeric types are allowed in range patterns\\n \\\n                            start type: {}\\n end type: {}\",\n-                          self.infcx().ty_to_string(lhs_ty),\n-                          self.infcx().ty_to_string(rhs_ty)\n+                          self.ty_to_string(lhs_ty),\n+                          self.ty_to_string(rhs_ty)\n                 );\n                 return;\n             }\n \n             // Check that the types of the end-points can be unified.\n             let types_unify = require_same_types(\n-                self.ccx, Some(self.infcx()), pat.span, rhs_ty, lhs_ty,\n+                self.ccx, Some(self), pat.span, rhs_ty, lhs_ty,\n                 \"mismatched types in range\",\n             );\n \n@@ -145,7 +145,7 @@ pub fn check_pat(&self, pat: &'tcx hir::Pat, expected: Ty<'tcx>) {\n \n             // Now that we know the types can be unified we find the unified type and use\n             // it to type the entire expression.\n-            let common_type = self.infcx().resolve_type_vars_if_possible(&lhs_ty);\n+            let common_type = self.resolve_type_vars_if_possible(&lhs_ty);\n \n             self.write_ty(pat.id, common_type);\n \n@@ -181,7 +181,7 @@ pub fn check_pat(&self, pat: &'tcx hir::Pat, expected: Ty<'tcx>) {\n                     //    ref x | ref const x | ref mut x\n                     // then `x` is assigned a value of type `&M T` where M is the mutability\n                     // and T is the expected type.\n-                    let region_var = self.infcx().next_region_var(infer::PatternRegion(pat.span));\n+                    let region_var = self.next_region_var(infer::PatternRegion(pat.span));\n                     let mt = ty::TypeAndMut { ty: expected, mutbl: mutbl };\n                     let region_ty = tcx.mk_ref(tcx.mk_region(region_var), mt);\n \n@@ -227,14 +227,14 @@ pub fn check_pat(&self, pat: &'tcx hir::Pat, expected: Ty<'tcx>) {\n             let self_ty = self.to_ty(&qself.ty);\n             let path_res = if let Some(&d) = tcx.def_map.borrow().get(&pat.id) {\n                 if d.base_def == Def::Err {\n-                    self.infcx().set_tainted_by_errors();\n+                    self.set_tainted_by_errors();\n                     self.write_error(pat.id);\n                     return;\n                 }\n                 d\n             } else if qself.position == 0 {\n                 // This is just a sentinel for finish_resolving_def_to_ty.\n-                let sentinel = self.tcx().map.local_def_id(ast::CRATE_NODE_ID);\n+                let sentinel = self.tcx.map.local_def_id(ast::CRATE_NODE_ID);\n                 def::PathResolution {\n                     base_def: Def::Mod(sentinel),\n                     depth: path.segments.len()\n@@ -264,8 +264,7 @@ pub fn check_pat(&self, pat: &'tcx hir::Pat, expected: Ty<'tcx>) {\n         }\n         PatKind::Tup(ref elements) => {\n             let element_tys: Vec<_> =\n-                (0..elements.len()).map(|_| self.infcx().next_ty_var())\n-                                        .collect();\n+                (0..elements.len()).map(|_| self.next_ty_var()).collect();\n             let pat_ty = tcx.mk_tup(element_tys.clone());\n             self.write_ty(pat.id, pat_ty);\n             self.demand_eqtype(pat.span, expected, pat_ty);\n@@ -274,7 +273,7 @@ pub fn check_pat(&self, pat: &'tcx hir::Pat, expected: Ty<'tcx>) {\n             }\n         }\n         PatKind::Box(ref inner) => {\n-            let inner_ty = self.infcx().next_ty_var();\n+            let inner_ty = self.next_ty_var();\n             let uniq_ty = tcx.mk_box(inner_ty);\n \n             if self.check_dereferencable(pat.span, expected, &inner) {\n@@ -290,7 +289,7 @@ pub fn check_pat(&self, pat: &'tcx hir::Pat, expected: Ty<'tcx>) {\n             }\n         }\n         PatKind::Ref(ref inner, mutbl) => {\n-            let expected = self.infcx().shallow_resolve(expected);\n+            let expected = self.shallow_resolve(expected);\n             if self.check_dereferencable(pat.span, expected, &inner) {\n                 // `demand::subtype` would be good enough, but using\n                 // `eqtype` turns out to be equally general. See (*)\n@@ -305,9 +304,9 @@ pub fn check_pat(&self, pat: &'tcx hir::Pat, expected: Ty<'tcx>) {\n                         (expected, mt.ty)\n                     }\n                     _ => {\n-                        let inner_ty = self.infcx().next_ty_var();\n+                        let inner_ty = self.next_ty_var();\n                         let mt = ty::TypeAndMut { ty: inner_ty, mutbl: mutbl };\n-                        let region = self.infcx().next_region_var(infer::PatternRegion(pat.span));\n+                        let region = self.next_region_var(infer::PatternRegion(pat.span));\n                         let rptr_ty = tcx.mk_ref(tcx.mk_region(region), mt);\n                         self.demand_eqtype(pat.span, expected, rptr_ty);\n                         (rptr_ty, inner_ty)\n@@ -323,7 +322,7 @@ pub fn check_pat(&self, pat: &'tcx hir::Pat, expected: Ty<'tcx>) {\n         }\n         PatKind::Vec(ref before, ref slice, ref after) => {\n             let expected_ty = self.structurally_resolved_type(pat.span, expected);\n-            let inner_ty = self.infcx().next_ty_var();\n+            let inner_ty = self.next_ty_var();\n             let pat_ty = match expected_ty.sty {\n                 ty::TyArray(_, size) => tcx.mk_array(inner_ty, {\n                     let min_len = before.len() + after.len();\n@@ -333,7 +332,7 @@ pub fn check_pat(&self, pat: &'tcx hir::Pat, expected: Ty<'tcx>) {\n                     }\n                 }),\n                 _ => {\n-                    let region = self.infcx().next_region_var(infer::PatternRegion(pat.span));\n+                    let region = self.next_region_var(infer::PatternRegion(pat.span));\n                     tcx.mk_ref(tcx.mk_region(region), ty::TypeAndMut {\n                         ty: tcx.mk_slice(inner_ty),\n                         mutbl: expected_ty.builtin_deref(true, ty::NoPreference).map(|mt| mt.mutbl)\n@@ -353,7 +352,7 @@ pub fn check_pat(&self, pat: &'tcx hir::Pat, expected: Ty<'tcx>) {\n                 self.check_pat(&elt, inner_ty);\n             }\n             if let Some(ref slice) = *slice {\n-                let region = self.infcx().next_region_var(infer::PatternRegion(pat.span));\n+                let region = self.next_region_var(infer::PatternRegion(pat.span));\n                 let mutbl = expected_ty.builtin_deref(true, ty::NoPreference)\n                     .map_or(hir::MutImmutable, |mt| mt.mutbl);\n \n@@ -425,7 +424,7 @@ fn check_assoc_item_is_const(&self, def: Def, span: Span) -> bool {\n     match def {\n         Def::AssociatedConst(..) => true,\n         Def::Method(..) => {\n-            span_err!(self.tcx().sess, span, E0327,\n+            span_err!(self.tcx.sess, span, E0327,\n                       \"associated items in match patterns must be constants\");\n             false\n         }\n@@ -436,16 +435,16 @@ fn check_assoc_item_is_const(&self, def: Def, span: Span) -> bool {\n }\n \n pub fn check_dereferencable(&self, span: Span, expected: Ty<'tcx>, inner: &hir::Pat) -> bool {\n-    let tcx = self.tcx();\n+    let tcx = self.tcx;\n     if pat_is_binding(&tcx.def_map.borrow(), inner) {\n-        let expected = self.infcx().shallow_resolve(expected);\n+        let expected = self.shallow_resolve(expected);\n         expected.builtin_deref(true, ty::NoPreference).map_or(true, |mt| match mt.ty.sty {\n             ty::TyTrait(_) => {\n                 // This is \"x = SomeTrait\" being reduced from\n                 // \"let &x = &SomeTrait\" or \"let box x = Box<SomeTrait>\", an error.\n                 span_err!(tcx.sess, span, E0033,\n                           \"type `{}` cannot be dereferenced\",\n-                          self.infcx().ty_to_string(expected));\n+                          self.ty_to_string(expected));\n                 false\n             }\n             _ => true\n@@ -463,7 +462,7 @@ pub fn check_match(&self,\n                    arms: &'tcx [hir::Arm],\n                    expected: Expectation<'tcx>,\n                    match_src: hir::MatchSource) {\n-    let tcx = self.tcx();\n+    let tcx = self.tcx;\n \n     // Not entirely obvious: if matches may create ref bindings, we\n     // want to use the *precise* type of the discriminant, *not* some\n@@ -482,7 +481,7 @@ pub fn check_match(&self,\n         // ...but otherwise we want to use any supertype of the\n         // discriminant. This is sort of a workaround, see note (*) in\n         // `check_pat` for some details.\n-        discrim_ty = self.infcx().next_ty_var();\n+        discrim_ty = self.next_ty_var();\n         self.check_expr_has_type(discrim, discrim_ty);\n     };\n \n@@ -508,14 +507,14 @@ pub fn check_match(&self,\n     // of execution reach it, we will panic, so bottom is an appropriate\n     // type in that case)\n     let expected = expected.adjust_for_branches(self);\n-    let mut result_ty = self.infcx().next_diverging_ty_var();\n+    let mut result_ty = self.next_diverging_ty_var();\n     let coerce_first = match expected {\n         // We don't coerce to `()` so that if the match expression is a\n         // statement it's branches can have any consistent type. That allows\n         // us to give better error messages (pointing to a usually better\n         // arm for inconsistent arms or to the whole match when a `()` type\n         // is required).\n-        Expectation::ExpectHasType(ety) if ety != self.tcx().mk_nil() => {\n+        Expectation::ExpectHasType(ety) if ety != self.tcx.mk_nil() => {\n             ety\n         }\n         _ => result_ty\n@@ -547,7 +546,7 @@ pub fn check_match(&self,\n         };\n \n         let result = if is_if_let_fallback {\n-            self.infcx().eq_types(true, origin, arm_ty, result_ty)\n+            self.eq_types(true, origin, arm_ty, result_ty)\n                 .map(|InferOk { obligations, .. }| {\n                     // FIXME(#32730) propagate obligations\n                     assert!(obligations.is_empty());\n@@ -569,8 +568,8 @@ pub fn check_match(&self,\n                 } else {\n                     (result_ty, arm_ty)\n                 };\n-                self.infcx().report_mismatched_types(origin, expected, found, e);\n-                self.tcx().types.err\n+                self.report_mismatched_types(origin, expected, found, e);\n+                self.tcx.types.err\n             }\n         };\n     }\n@@ -583,7 +582,7 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx, 'tcx> {\n pub fn check_pat_struct(&self, pat: &'tcx hir::Pat,\n                         path: &hir::Path, fields: &'tcx [Spanned<hir::FieldPat>],\n                         etc: bool, expected: Ty<'tcx>) {\n-    let tcx = self.tcx();\n+    let tcx = self.tcx;\n \n     let def = tcx.def_map.borrow().get(&pat.id).unwrap().full_def();\n     let variant = match self.def_struct_variant(def, path.span) {\n@@ -621,12 +620,12 @@ fn check_pat_enum(&self,\n                   is_tuple_struct_pat: bool)\n {\n     // Typecheck the path.\n-    let tcx = self.tcx();\n+    let tcx = self.tcx;\n \n     let path_res = match tcx.def_map.borrow().get(&pat.id) {\n         Some(&path_res) if path_res.base_def != Def::Err => path_res,\n         _ => {\n-            self.infcx().set_tainted_by_errors();\n+            self.set_tainted_by_errors();\n             self.write_error(pat.id);\n \n             if let Some(subpats) = subpats {\n@@ -767,7 +766,7 @@ pub fn check_struct_pat_fields(&self,\n                                variant: ty::VariantDef<'tcx>,\n                                substs: &Substs<'tcx>,\n                                etc: bool) {\n-    let tcx = self.tcx();\n+    let tcx = self.tcx;\n \n     // Index the struct fields' types.\n     let field_map = variant.fields"}, {"sha": "e1d64c2253dac9358d435c6302573299fdb69c75", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/0053b442f8cd5bf5e310a2664fc3a47a8f33da71/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0053b442f8cd5bf5e310a2664fc3a47a8f33da71/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=0053b442f8cd5bf5e310a2664fc3a47a8f33da71", "patch": "@@ -128,13 +128,13 @@ fn try_overloaded_call_step(&self,\n             // Check whether this is a call to a closure where we\n             // haven't yet decided on whether the closure is fn vs\n             // fnmut vs fnonce. If so, we have to defer further processing.\n-            if self.infcx().closure_kind(def_id).is_none() {\n+            if self.closure_kind(def_id).is_none() {\n                 let closure_ty =\n-                    self.infcx().closure_type(def_id, substs);\n+                    self.closure_type(def_id, substs);\n                 let fn_sig =\n-                    self.infcx().replace_late_bound_regions_with_fresh_var(call_expr.span,\n-                                                                           infer::FnCall,\n-                                                                           &closure_ty.sig).0;\n+                    self.replace_late_bound_regions_with_fresh_var(call_expr.span,\n+                                                                   infer::FnCall,\n+                                                                   &closure_ty.sig).0;\n                 self.record_deferred_call_resolution(def_id, Box::new(CallResolution {\n                     call_expr: call_expr,\n                     callee_expr: callee_expr,\n@@ -175,9 +175,9 @@ fn try_overloaded_call_traits(&self,\n {\n     // Try the options that are least restrictive on the caller first.\n     for &(opt_trait_def_id, method_name) in &[\n-        (self.tcx().lang_items.fn_trait(), token::intern(\"call\")),\n-        (self.tcx().lang_items.fn_mut_trait(), token::intern(\"call_mut\")),\n-        (self.tcx().lang_items.fn_once_trait(), token::intern(\"call_once\")),\n+        (self.tcx.lang_items.fn_trait(), token::intern(\"call\")),\n+        (self.tcx.lang_items.fn_mut_trait(), token::intern(\"call_mut\")),\n+        (self.tcx.lang_items.fn_once_trait(), token::intern(\"call_once\")),\n     ] {\n         let trait_def_id = match opt_trait_def_id {\n             Some(def_id) => def_id,\n@@ -221,7 +221,7 @@ fn confirm_builtin_call(&self,\n             }, callee_ty, None);\n \n             if let hir::ExprCall(ref expr, _) = call_expr.node {\n-                let tcx = self.tcx();\n+                let tcx = self.tcx;\n                 if let Some(pr) = tcx.def_map.borrow().get(&expr.id) {\n                     if pr.depth == 0 && pr.base_def != Def::Err {\n                         if let Some(span) = tcx.map.span_if_local(pr.def_id()) {\n@@ -238,7 +238,7 @@ fn confirm_builtin_call(&self,\n             // set up all the node type bindings.\n             error_fn_sig = ty::Binder(ty::FnSig {\n                 inputs: self.err_args(arg_exprs.len()),\n-                output: ty::FnConverging(self.tcx().types.err),\n+                output: ty::FnConverging(self.tcx.types.err),\n                 variadic: false\n             });\n \n@@ -252,9 +252,9 @@ fn confirm_builtin_call(&self,\n     // previously appeared within a `Binder<>` and hence would not\n     // have been normalized before.\n     let fn_sig =\n-        self.infcx().replace_late_bound_regions_with_fresh_var(call_expr.span,\n-                                                               infer::FnCall,\n-                                                               fn_sig).0;\n+        self.replace_late_bound_regions_with_fresh_var(call_expr.span,\n+                                                       infer::FnCall,\n+                                                       fn_sig).0;\n     let fn_sig =\n         self.normalize_associated_types_in(call_expr.span, &fn_sig);\n \n@@ -323,7 +323,7 @@ fn write_overloaded_call_method_map(&self,\n                                     call_expr: &hir::Expr,\n                                     method_callee: ty::MethodCallee<'tcx>) {\n     let method_call = ty::MethodCall::expr(call_expr.id);\n-    self.inh.tables.borrow_mut().method_map.insert(method_call, method_callee);\n+    self.tables.borrow_mut().method_map.insert(method_call, method_callee);\n }\n }\n \n@@ -344,7 +344,7 @@ impl<'tcx> DeferredCallResolution<'tcx> for CallResolution<'tcx> {\n \n         // we should not be invoked until the closure kind has been\n         // determined by upvar inference\n-        assert!(fcx.infcx().closure_kind(self.closure_def_id).is_some());\n+        assert!(fcx.closure_kind(self.closure_def_id).is_some());\n \n         // We may now know enough to figure out fn vs fnmut etc.\n         match fcx.try_overloaded_call_traits(self.call_expr, self.callee_expr,\n@@ -358,8 +358,8 @@ impl<'tcx> DeferredCallResolution<'tcx> for CallResolution<'tcx> {\n                 // can't because of the annoying need for a TypeTrace.\n                 // (This always bites me, should find a way to\n                 // refactor it.)\n-                let method_sig = fcx.tcx().no_late_bound_regions(method_callee.ty.fn_sig())\n-                                          .unwrap();\n+                let method_sig = fcx.tcx.no_late_bound_regions(method_callee.ty.fn_sig())\n+                                        .unwrap();\n \n                 debug!(\"attempt_resolution: method_callee={:?}\",\n                        method_callee);\n@@ -370,7 +370,7 @@ impl<'tcx> DeferredCallResolution<'tcx> for CallResolution<'tcx> {\n                     fcx.demand_eqtype(self.call_expr.span, self_arg_ty, method_arg_ty);\n                 }\n \n-                let nilty = fcx.tcx().mk_nil();\n+                let nilty = fcx.tcx.mk_nil();\n                 fcx.demand_eqtype(self.call_expr.span,\n                                   method_sig.output.unwrap_or(nilty),\n                                   self.fn_sig.output.unwrap_or(nilty));"}, {"sha": "158867eebf6b5abf5e295f36acd9fd7a54928d8a", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 31, "deletions": 34, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/0053b442f8cd5bf5e310a2664fc3a47a8f33da71/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0053b442f8cd5bf5e310a2664fc3a47a8f33da71/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=0053b442f8cd5bf5e310a2664fc3a47a8f33da71", "patch": "@@ -83,7 +83,7 @@ fn unsize_kind(&self, t: Ty<'tcx>) -> Option<UnsizeKind<'tcx>> {\n             // FIXME(arielb1): do some kind of normalization\n             match def.struct_variant().fields.last() {\n                 None => None,\n-                Some(f) => self.unsize_kind(f.ty(self.tcx(), substs))\n+                Some(f) => self.unsize_kind(f.ty(self.tcx, substs))\n             }\n         }\n         // We should really try to normalize here.\n@@ -148,7 +148,7 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n                 fcx.type_error_struct(self.span, |actual| {\n                     format!(\"casting `{}` as `{}` is invalid\",\n                             actual,\n-                            fcx.infcx().ty_to_string(self.cast_ty))\n+                            fcx.ty_to_string(self.cast_ty))\n                 }, self.expr_ty, None)\n                     .help(&format!(\"cast through {} first\", match e {\n                             CastError::NeedViaPtr => \"a raw pointer\",\n@@ -160,7 +160,7 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n                     .emit();\n             }\n             CastError::CastToBool => {\n-                struct_span_err!(fcx.tcx().sess, self.span, E0054, \"cannot cast as `bool`\")\n+                struct_span_err!(fcx.tcx.sess, self.span, E0054, \"cannot cast as `bool`\")\n                     .help(\"compare with zero instead\")\n                     .emit();\n             }\n@@ -173,28 +173,28 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n                 fcx.type_error_message(self.span, |actual| {\n                     format!(\"non-scalar cast: `{}` as `{}`\",\n                             actual,\n-                            fcx.infcx().ty_to_string(self.cast_ty))\n+                            fcx.ty_to_string(self.cast_ty))\n                 }, self.expr_ty, None);\n             }\n             CastError::IllegalCast => {\n                 fcx.type_error_message(self.span, |actual| {\n                     format!(\"casting `{}` as `{}` is invalid\",\n                             actual,\n-                            fcx.infcx().ty_to_string(self.cast_ty))\n+                            fcx.ty_to_string(self.cast_ty))\n                 }, self.expr_ty, None);\n             }\n             CastError::SizedUnsizedCast => {\n                 fcx.type_error_message(self.span, |actual| {\n                     format!(\"cannot cast thin pointer `{}` to fat pointer `{}`\",\n                             actual,\n-                            fcx.infcx().ty_to_string(self.cast_ty))\n+                            fcx.ty_to_string(self.cast_ty))\n                 }, self.expr_ty, None)\n             }\n             CastError::DifferingKinds => {\n                 fcx.type_error_struct(self.span, |actual| {\n                     format!(\"casting `{}` as `{}` is invalid\",\n                             actual,\n-                            fcx.infcx().ty_to_string(self.cast_ty))\n+                            fcx.ty_to_string(self.cast_ty))\n                 }, self.expr_ty, None)\n                     .note(\"vtable kinds may not match\")\n                     .emit();\n@@ -210,7 +210,7 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n             return;\n         }\n \n-        let tstr = fcx.infcx().ty_to_string(self.cast_ty);\n+        let tstr = fcx.ty_to_string(self.cast_ty);\n         let mut err = fcx.type_error_struct(self.span, |actual| {\n             format!(\"cast to unsized type: `{}` as `{}`\", actual, tstr)\n         }, self.expr_ty, None);\n@@ -221,7 +221,7 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n                     hir::MutImmutable => \"\"\n                 };\n                 if self.cast_ty.is_trait() {\n-                    match fcx.tcx().sess.codemap().span_to_snippet(self.cast_span) {\n+                    match fcx.tcx.sess.codemap().span_to_snippet(self.cast_span) {\n                         Ok(s) => {\n                             err.span_suggestion(self.cast_span,\n                                                 \"try casting to a reference instead:\",\n@@ -238,7 +238,7 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n                 }\n             }\n             ty::TyBox(..) => {\n-                match fcx.tcx().sess.codemap().span_to_snippet(self.cast_span) {\n+                match fcx.tcx.sess.codemap().span_to_snippet(self.cast_span) {\n                     Ok(s) => {\n                         err.span_suggestion(self.cast_span,\n                                             \"try casting to a `Box` instead:\",\n@@ -260,23 +260,23 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n         let t_cast = self.cast_ty;\n         let t_expr = self.expr_ty;\n         if t_cast.is_numeric() && t_expr.is_numeric() {\n-            fcx.tcx().sess.add_lint(lint::builtin::TRIVIAL_NUMERIC_CASTS,\n-                                    self.expr.id,\n-                                    self.span,\n-                                    format!(\"trivial numeric cast: `{}` as `{}`. Cast can be \\\n-                                             replaced by coercion, this might require type \\\n-                                             ascription or a temporary variable\",\n-                                            fcx.infcx().ty_to_string(t_expr),\n-                                            fcx.infcx().ty_to_string(t_cast)));\n+            fcx.tcx.sess.add_lint(lint::builtin::TRIVIAL_NUMERIC_CASTS,\n+                                  self.expr.id,\n+                                  self.span,\n+                                  format!(\"trivial numeric cast: `{}` as `{}`. Cast can be \\\n+                                           replaced by coercion, this might require type \\\n+                                           ascription or a temporary variable\",\n+                                          fcx.ty_to_string(t_expr),\n+                                          fcx.ty_to_string(t_cast)));\n         } else {\n-            fcx.tcx().sess.add_lint(lint::builtin::TRIVIAL_CASTS,\n-                                    self.expr.id,\n-                                    self.span,\n-                                    format!(\"trivial cast: `{}` as `{}`. Cast can be \\\n-                                             replaced by coercion, this might require type \\\n-                                             ascription or a temporary variable\",\n-                                            fcx.infcx().ty_to_string(t_expr),\n-                                            fcx.infcx().ty_to_string(t_cast)));\n+            fcx.tcx.sess.add_lint(lint::builtin::TRIVIAL_CASTS,\n+                                  self.expr.id,\n+                                  self.span,\n+                                  format!(\"trivial cast: `{}` as `{}`. Cast can be \\\n+                                           replaced by coercion, this might require type \\\n+                                           ascription or a temporary variable\",\n+                                          fcx.ty_to_string(t_expr),\n+                                          fcx.ty_to_string(t_cast)));\n         }\n \n     }\n@@ -295,12 +295,12 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n         } else if self.try_coercion_cast(fcx) {\n             self.trivial_cast_lint(fcx);\n             debug!(\" -> CoercionCast\");\n-            fcx.tcx().cast_kinds.borrow_mut().insert(self.expr.id,\n-                                                     CastKind::CoercionCast);\n+            fcx.tcx.cast_kinds.borrow_mut().insert(self.expr.id,\n+                                                   CastKind::CoercionCast);\n         } else { match self.do_check(fcx) {\n             Ok(k) => {\n                 debug!(\" -> {:?}\", k);\n-                fcx.tcx().cast_kinds.borrow_mut().insert(self.expr.id, k);\n+                fcx.tcx.cast_kinds.borrow_mut().insert(self.expr.id, k);\n             }\n             Err(e) => self.report_cast_error(fcx, e)\n         };}\n@@ -321,7 +321,7 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n                 if let ty::TyFnDef(_, _, f) = self.expr_ty.sty {\n                     // Attempt a coercion to a fn pointer type.\n                     let res = fcx.try_coerce(self.expr,\n-                                             fcx.tcx().mk_ty(ty::TyFnPtr(f)));\n+                                             fcx.tcx.mk_ty(ty::TyFnPtr(f)));\n                     if !res.is_ok() {\n                         return Err(CastError::NonScalar);\n                     }\n@@ -482,10 +482,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx, 'tcx> {\n                                  span: Span)\n                                  -> bool\n     {\n-        traits::type_known_to_meet_builtin_bound(self.infcx(),\n-                                                 ty,\n-                                                 ty::BoundSized,\n-                                                 span)\n+        traits::type_known_to_meet_builtin_bound(self, ty, ty::BoundSized, span)\n     }\n }\n "}, {"sha": "7e0376c1683aee1f4a9d9964ade7b80b98f776f0", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/0053b442f8cd5bf5e310a2664fc3a47a8f33da71/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0053b442f8cd5bf5e310a2664fc3a47a8f33da71/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=0053b442f8cd5bf5e310a2664fc3a47a8f33da71", "patch": "@@ -46,7 +46,7 @@ fn check_closure(&self,\n                  decl: &'tcx hir::FnDecl,\n                  body: &'tcx hir::Block,\n                  expected_sig: Option<ty::FnSig<'tcx>>) {\n-    let expr_def_id = self.tcx().map.local_def_id(expr.id);\n+    let expr_def_id = self.tcx.map.local_def_id(expr.id);\n \n     debug!(\"check_closure opt_kind={:?} expected_sig={:?}\",\n            opt_kind,\n@@ -61,20 +61,20 @@ fn check_closure(&self,\n     // Create type variables (for now) to represent the transformed\n     // types of upvars. These will be unified during the upvar\n     // inference phase (`upvar.rs`).\n-    let num_upvars = self.tcx().with_freevars(expr.id, |fv| fv.len());\n-    let upvar_tys = self.infcx().next_ty_vars(num_upvars);\n+    let num_upvars = self.tcx.with_freevars(expr.id, |fv| fv.len());\n+    let upvar_tys = self.next_ty_vars(num_upvars);\n \n     debug!(\"check_closure: expr.id={:?} upvar_tys={:?}\",\n            expr.id, upvar_tys);\n \n-    let closure_type = self.tcx().mk_closure(expr_def_id,\n-        self.tcx().mk_substs(self.inh.infcx.parameter_environment.free_substs.clone()),\n+    let closure_type = self.tcx.mk_closure(expr_def_id,\n+        self.tcx.mk_substs(self.parameter_environment.free_substs.clone()),\n         upvar_tys);\n \n     self.write_ty(expr.id, closure_type);\n \n-    let fn_sig = self.tcx().liberate_late_bound_regions(\n-        self.tcx().region_maps.call_site_extent(expr.id, body.id), &fn_ty.sig);\n+    let fn_sig = self.tcx.liberate_late_bound_regions(\n+        self.tcx.region_maps.call_site_extent(expr.id, body.id), &fn_ty.sig);\n \n     check_fn(self.ccx,\n              hir::Unsafety::Normal,\n@@ -83,20 +83,20 @@ fn check_closure(&self,\n              decl,\n              expr.id,\n              &body,\n-             self.inh);\n+             self);\n \n     // Tuple up the arguments and insert the resulting function type into\n     // the `closures` table.\n-    fn_ty.sig.0.inputs = vec![self.tcx().mk_tup(fn_ty.sig.0.inputs)];\n+    fn_ty.sig.0.inputs = vec![self.tcx.mk_tup(fn_ty.sig.0.inputs)];\n \n     debug!(\"closure for {:?} --> sig={:?} opt_kind={:?}\",\n            expr_def_id,\n            fn_ty.sig,\n            opt_kind);\n \n-    self.inh.tables.borrow_mut().closure_tys.insert(expr_def_id, fn_ty);\n+    self.tables.borrow_mut().closure_tys.insert(expr_def_id, fn_ty);\n     match opt_kind {\n-        Some(kind) => { self.inh.tables.borrow_mut().closure_kinds.insert(expr_def_id, kind); }\n+        Some(kind) => { self.tables.borrow_mut().closure_kinds.insert(expr_def_id, kind); }\n         None => { }\n     }\n }\n@@ -109,12 +109,12 @@ fn deduce_expectations_from_expected_type(&self, expected_ty: Ty<'tcx>)\n \n     match expected_ty.sty {\n         ty::TyTrait(ref object_type) => {\n-            let proj_bounds = object_type.projection_bounds_with_self_ty(self.tcx(),\n-                                                                         self.tcx().types.err);\n+            let proj_bounds = object_type.projection_bounds_with_self_ty(self.tcx,\n+                                                                         self.tcx.types.err);\n             let sig = proj_bounds.iter()\n                                  .filter_map(|pb| self.deduce_sig_from_projection(pb))\n                                  .next();\n-            let kind = self.tcx().lang_items.fn_trait_kind(object_type.principal_def_id());\n+            let kind = self.tcx.lang_items.fn_trait_kind(object_type.principal_def_id());\n             (sig, kind)\n         }\n         ty::TyInfer(ty::TyVar(vid)) => {\n@@ -129,7 +129,7 @@ fn deduce_expectations_from_expected_type(&self, expected_ty: Ty<'tcx>)\n fn deduce_expectations_from_obligations(&self, expected_vid: ty::TyVid)\n     -> (Option<ty::FnSig<'tcx>>, Option<ty::ClosureKind>)\n {\n-    let fulfillment_cx = self.inh.fulfillment_cx.borrow();\n+    let fulfillment_cx = self.fulfillment_cx.borrow();\n     // Here `expected_ty` is known to be a type inference variable.\n \n     let expected_sig =\n@@ -188,7 +188,7 @@ fn deduce_expectations_from_obligations(&self, expected_vid: ty::TyVid)\n             };\n             opt_trait_ref\n                 .and_then(|trait_ref| self.self_type_matches_expected_vid(trait_ref, expected_vid))\n-                .and_then(|trait_ref| self.tcx().lang_items.fn_trait_kind(trait_ref.def_id()))\n+                .and_then(|trait_ref| self.tcx.lang_items.fn_trait_kind(trait_ref.def_id()))\n         })\n         .fold(None, |best, cur| Some(best.map_or(cur, |best| cmp::min(best, cur))));\n \n@@ -201,7 +201,7 @@ fn deduce_sig_from_projection(&self,\n     projection: &ty::PolyProjectionPredicate<'tcx>)\n     -> Option<ty::FnSig<'tcx>>\n {\n-    let tcx = self.tcx();\n+    let tcx = self.tcx;\n \n     debug!(\"deduce_sig_from_projection({:?})\",\n            projection);\n@@ -213,7 +213,7 @@ fn deduce_sig_from_projection(&self,\n     }\n \n     let arg_param_ty = *trait_ref.substs().types.get(subst::TypeSpace, 0);\n-    let arg_param_ty = self.infcx().resolve_type_vars_if_possible(&arg_param_ty);\n+    let arg_param_ty = self.resolve_type_vars_if_possible(&arg_param_ty);\n     debug!(\"deduce_sig_from_projection: arg_param_ty {:?}\", arg_param_ty);\n \n     let input_tys = match arg_param_ty.sty {\n@@ -223,7 +223,7 @@ fn deduce_sig_from_projection(&self,\n     debug!(\"deduce_sig_from_projection: input_tys {:?}\", input_tys);\n \n     let ret_param_ty = projection.0.ty;\n-    let ret_param_ty = self.infcx().resolve_type_vars_if_possible(&ret_param_ty);\n+    let ret_param_ty = self.resolve_type_vars_if_possible(&ret_param_ty);\n     debug!(\"deduce_sig_from_projection: ret_param_ty {:?}\", ret_param_ty);\n \n     let fn_sig = ty::FnSig {\n@@ -241,7 +241,7 @@ fn self_type_matches_expected_vid(&self,\n     expected_vid: ty::TyVid)\n     -> Option<ty::PolyTraitRef<'tcx>>\n {\n-    let self_ty = self.infcx().shallow_resolve(trait_ref.self_ty());\n+    let self_ty = self.shallow_resolve(trait_ref.self_ty());\n     debug!(\"self_type_matches_expected_vid(trait_ref={:?}, self_ty={:?})\",\n            trait_ref,\n            self_ty);"}, {"sha": "d471ab3c99ca8b58e52553031f5654f62bd95aa6", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 59, "deletions": 56, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/0053b442f8cd5bf5e310a2664fc3a47a8f33da71/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0053b442f8cd5bf5e310a2664fc3a47a8f33da71/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=0053b442f8cd5bf5e310a2664fc3a47a8f33da71", "patch": "@@ -62,20 +62,21 @@\n \n use check::{FnCtxt, UnresolvedTypeAction};\n \n+use rustc::hir;\n use rustc::infer::{Coercion, InferOk, TypeOrigin, TypeTrace};\n use rustc::traits::{self, ObligationCause};\n use rustc::ty::adjustment::{AutoAdjustment, AutoDerefRef, AdjustDerefRef};\n use rustc::ty::adjustment::{AutoPtr, AutoUnsafe, AdjustReifyFnPointer};\n use rustc::ty::adjustment::{AdjustUnsafeFnPointer, AdjustMutToConstPointer};\n-use rustc::ty::{self, LvaluePreference, TypeAndMut, Ty, TyCtxt};\n+use rustc::ty::{self, LvaluePreference, TypeAndMut, Ty};\n use rustc::ty::fold::TypeFoldable;\n use rustc::ty::error::TypeError;\n use rustc::ty::relate::RelateResult;\n use util::common::indent;\n \n use std::cell::RefCell;\n use std::collections::VecDeque;\n-use rustc::hir;\n+use std::ops::Deref;\n \n struct Coerce<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     fcx: &'a FnCtxt<'a, 'gcx, 'tcx>,\n@@ -84,6 +85,13 @@ struct Coerce<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     unsizing_obligations: RefCell<Vec<traits::PredicateObligation<'tcx>>>,\n }\n \n+impl<'a, 'gcx, 'tcx> Deref for Coerce<'a, 'gcx, 'tcx> {\n+    type Target = FnCtxt<'a, 'gcx, 'tcx>;\n+    fn deref(&self) -> &Self::Target {\n+        &self.fcx\n+    }\n+}\n+\n type CoerceResult<'tcx> = RelateResult<'tcx, (Ty<'tcx>, AutoAdjustment<'tcx>)>;\n \n fn coerce_mutbls<'tcx>(from_mutbl: hir::Mutability,\n@@ -107,23 +115,18 @@ impl<'f, 'tcx> Coerce<'f, 'tcx, 'tcx> {\n         }\n     }\n \n-    fn tcx(&self) -> TyCtxt<'f, 'tcx, 'tcx> {\n-        self.fcx.tcx()\n-    }\n-\n     fn unify(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n-        let infcx = self.fcx.infcx();\n-        infcx.commit_if_ok(|_| {\n+        self.commit_if_ok(|_| {\n             let trace = TypeTrace::types(self.origin, false, a, b);\n             if self.use_lub {\n-                infcx.lub(false, trace, &a, &b)\n+                self.lub(false, trace, &a, &b)\n                     .map(|InferOk { value, obligations }| {\n                         // FIXME(#32730) propagate obligations\n                         assert!(obligations.is_empty());\n                         value\n                     })\n             } else {\n-                infcx.sub(false, trace, &a, &b)\n+                self.sub(false, trace, &a, &b)\n                     .map(|InferOk { value, obligations }| {\n                         // FIXME(#32730) propagate obligations\n                         assert!(obligations.is_empty());\n@@ -156,7 +159,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx, 'tcx> {\n         where E: Fn() -> I,\n               I: IntoIterator<Item=&'a hir::Expr> {\n \n-        let a = self.fcx.infcx().shallow_resolve(a);\n+        let a = self.shallow_resolve(a);\n         debug!(\"Coerce.tys({:?} => {:?})\", a, b);\n \n         // Just ignore error types.\n@@ -240,10 +243,10 @@ impl<'f, 'tcx> Coerce<'f, 'tcx, 'tcx> {\n         let lvalue_pref = LvaluePreference::from_mutbl(mt_b.mutbl);\n         let mut first_error = None;\n         let mut r_borrow_var = None;\n-        let (_, autoderefs, success) = self.fcx.autoderef(span, a, exprs,\n-                                                          UnresolvedTypeAction::Ignore,\n-                                                          lvalue_pref,\n-                                                          |referent_ty, autoderef|\n+        let (_, autoderefs, success) = self.autoderef(span, a, exprs,\n+                                                      UnresolvedTypeAction::Ignore,\n+                                                      lvalue_pref,\n+                                                      |referent_ty, autoderef|\n         {\n             if autoderef == 0 {\n                 // Don't let this pass, otherwise it would cause\n@@ -328,12 +331,12 @@ impl<'f, 'tcx> Coerce<'f, 'tcx, 'tcx> {\n             } else {\n                 if r_borrow_var.is_none() { // create var lazilly, at most once\n                     let coercion = Coercion(span);\n-                    let r = self.fcx.infcx().next_region_var(coercion);\n-                    r_borrow_var = Some(self.tcx().mk_region(r)); // [4] above\n+                    let r = self.next_region_var(coercion);\n+                    r_borrow_var = Some(self.tcx.mk_region(r)); // [4] above\n                 }\n                 r_borrow_var.unwrap()\n             };\n-            let derefd_ty_a = self.tcx().mk_ref(r, TypeAndMut {\n+            let derefd_ty_a = self.tcx.mk_ref(r, TypeAndMut {\n                 ty: referent_ty,\n                 mutbl: mt_b.mutbl // [1] above\n             });\n@@ -405,8 +408,8 @@ impl<'f, 'tcx> Coerce<'f, 'tcx, 'tcx> {\n                source,\n                target);\n \n-        let traits = (self.tcx().lang_items.unsize_trait(),\n-                      self.tcx().lang_items.coerce_unsized_trait());\n+        let traits = (self.tcx.lang_items.unsize_trait(),\n+                      self.tcx.lang_items.coerce_unsized_trait());\n         let (unsize_did, coerce_unsized_did) = if let (Some(u), Some(cu)) = traits {\n             (u, cu)\n         } else {\n@@ -425,8 +428,8 @@ impl<'f, 'tcx> Coerce<'f, 'tcx, 'tcx> {\n                 coerce_mutbls(mt_a.mutbl, mt_b.mutbl)?;\n \n                 let coercion = Coercion(self.origin.span());\n-                let r_borrow = self.fcx.infcx().next_region_var(coercion);\n-                let region = self.tcx().mk_region(r_borrow);\n+                let r_borrow = self.next_region_var(coercion);\n+                let region = self.tcx.mk_region(r_borrow);\n                 (mt_a.ty, Some(AutoPtr(region, mt_b.mutbl)))\n             }\n             (&ty::TyRef(_, mt_a), &ty::TyRawPtr(mt_b)) => {\n@@ -435,21 +438,21 @@ impl<'f, 'tcx> Coerce<'f, 'tcx, 'tcx> {\n             }\n             _ => (source, None)\n         };\n-        let source = source.adjust_for_autoref(self.tcx(), reborrow);\n+        let source = source.adjust_for_autoref(self.tcx, reborrow);\n \n-        let mut selcx = traits::SelectionContext::new(self.fcx.infcx());\n+        let mut selcx = traits::SelectionContext::new(self);\n \n         // Use a FIFO queue for this custom fulfillment procedure.\n         let mut queue = VecDeque::new();\n         let mut leftover_predicates = vec![];\n \n         // Create an obligation for `Source: CoerceUnsized<Target>`.\n-        let cause = ObligationCause::misc(self.origin.span(), self.fcx.body_id);\n-        queue.push_back(self.tcx().predicate_for_trait_def(cause,\n-                                                           coerce_unsized_did,\n-                                                           0,\n-                                                           source,\n-                                                           vec![target]));\n+        let cause = ObligationCause::misc(self.origin.span(), self.body_id);\n+        queue.push_back(self.tcx.predicate_for_trait_def(cause,\n+                                                         coerce_unsized_did,\n+                                                         0,\n+                                                         source,\n+                                                         vec![target]));\n \n         // Keep resolving `CoerceUnsized` and `Unsize` predicates to avoid\n         // emitting a coercion in cases like `Foo<$1>` -> `Foo<$2>`, where\n@@ -475,7 +478,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx, 'tcx> {\n \n                 // Object safety violations or miscellaneous.\n                 Err(err) => {\n-                    self.fcx.infcx().report_selection_error(&obligation, &err, None);\n+                    self.report_selection_error(&obligation, &err, None);\n                     // Treat this like an obligation and follow through\n                     // with the unsizing - the lack of a coercion should\n                     // be silent, as it causes a type mismatch later.\n@@ -511,13 +514,13 @@ impl<'f, 'tcx> Coerce<'f, 'tcx, 'tcx> {\n          * into a closure or a `proc`.\n          */\n \n-        let b = self.fcx.infcx().shallow_resolve(b);\n+        let b = self.shallow_resolve(b);\n         debug!(\"coerce_from_fn_pointer(a={:?}, b={:?})\", a, b);\n \n         if let ty::TyFnPtr(fn_ty_b) = b.sty {\n             match (fn_ty_a.unsafety, fn_ty_b.unsafety) {\n                 (hir::Unsafety::Normal, hir::Unsafety::Unsafe) => {\n-                    let unsafe_a = self.tcx().safe_to_unsafe_fn_ty(fn_ty_a);\n+                    let unsafe_a = self.tcx.safe_to_unsafe_fn_ty(fn_ty_a);\n                     return self.unify_and_identity(unsafe_a, b).map(|(ty, _)| {\n                         (ty, AdjustUnsafeFnPointer)\n                     });\n@@ -538,12 +541,12 @@ impl<'f, 'tcx> Coerce<'f, 'tcx, 'tcx> {\n          * into a closure or a `proc`.\n          */\n \n-        let b = self.fcx.infcx().shallow_resolve(b);\n+        let b = self.shallow_resolve(b);\n         debug!(\"coerce_from_fn_item(a={:?}, b={:?})\", a, b);\n \n         match b.sty {\n             ty::TyFnPtr(_) => {\n-                let a_fn_pointer = self.tcx().mk_ty(ty::TyFnPtr(fn_ty_a));\n+                let a_fn_pointer = self.tcx.mk_ty(ty::TyFnPtr(fn_ty_a));\n                 self.unify_and_identity(a_fn_pointer, b).map(|(ty, _)| {\n                     (ty, AdjustReifyFnPointer)\n                 })\n@@ -570,7 +573,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx, 'tcx> {\n         };\n \n         // Check that the types which they point at are compatible.\n-        let a_unsafe = self.tcx().mk_ptr(ty::TypeAndMut{ mutbl: mutbl_b, ty: mt_a.ty });\n+        let a_unsafe = self.tcx.mk_ptr(ty::TypeAndMut{ mutbl: mutbl_b, ty: mt_a.ty });\n         let (ty, noop) = self.unify_and_identity(a_unsafe, b)?;\n         coerce_mutbls(mt_a.mutbl, mutbl_b)?;\n \n@@ -623,16 +626,16 @@ pub fn try_coerce(&self,\n                   expr: &hir::Expr,\n                   target: Ty<'tcx>)\n                   -> RelateResult<'tcx, Ty<'tcx>> {\n-    let source = self.resolve_type_vars_if_possible(self.expr_ty(expr));\n+    let source = self.resolve_type_vars_with_obligations(self.expr_ty(expr));\n     debug!(\"coercion::try({:?}: {:?} -> {:?})\", expr, source, target);\n \n     let mut coerce = Coerce::new(self, TypeOrigin::ExprAssignable(expr.span));\n-    self.infcx().commit_if_ok(|_| {\n+    self.commit_if_ok(|_| {\n         let (ty, adjustment) =\n             apply(&mut coerce, &|| Some(expr), source, target)?;\n         if !adjustment.is_identity() {\n             debug!(\"Success, coerced with {:?}\", adjustment);\n-            assert!(!self.inh.tables.borrow().adjustments.contains_key(&expr.id));\n+            assert!(!self.tables.borrow().adjustments.contains_key(&expr.id));\n             self.write_adjustment(expr.id, adjustment);\n         }\n         Ok(ty)\n@@ -652,8 +655,8 @@ pub fn try_find_coercion_lub<'b, E, I>(&self,\n     where E: Fn() -> I,\n           I: IntoIterator<Item=&'b hir::Expr> {\n \n-    let prev_ty = self.resolve_type_vars_if_possible(prev_ty);\n-    let new_ty = self.resolve_type_vars_if_possible(self.expr_ty(new));\n+    let prev_ty = self.resolve_type_vars_with_obligations(prev_ty);\n+    let new_ty = self.resolve_type_vars_with_obligations(self.expr_ty(new));\n     debug!(\"coercion::try_find_lub({:?}, {:?})\", prev_ty, new_ty);\n \n     let trace = TypeTrace::types(origin, true, prev_ty, new_ty);\n@@ -664,7 +667,7 @@ pub fn try_find_coercion_lub<'b, E, I>(&self,\n         (&ty::TyFnDef(a_def_id, a_substs, a_fty),\n          &ty::TyFnDef(b_def_id, b_substs, b_fty)) => {\n             // The signature must always match.\n-            let fty = self.infcx().lub(true, trace.clone(), a_fty, b_fty)\n+            let fty = self.lub(true, trace.clone(), a_fty, b_fty)\n                 .map(|InferOk { value, obligations }| {\n                     // FIXME(#32730) propagate obligations\n                     assert!(obligations.is_empty());\n@@ -673,28 +676,28 @@ pub fn try_find_coercion_lub<'b, E, I>(&self,\n \n             if a_def_id == b_def_id {\n                 // Same function, maybe the parameters match.\n-                let substs = self.infcx().commit_if_ok(|_| {\n-                    self.infcx().lub(true, trace.clone(), a_substs, b_substs)\n+                let substs = self.commit_if_ok(|_| {\n+                    self.lub(true, trace.clone(), a_substs, b_substs)\n                         .map(|InferOk { value, obligations }| {\n                             // FIXME(#32730) propagate obligations\n                             assert!(obligations.is_empty());\n                             value\n                         })\n-                }).map(|s| self.tcx().mk_substs(s));\n+                }).map(|s| self.tcx.mk_substs(s));\n \n                 if let Ok(substs) = substs {\n                     // We have a LUB of prev_ty and new_ty, just return it.\n-                    return Ok(self.tcx().mk_fn_def(a_def_id, substs, fty));\n+                    return Ok(self.tcx.mk_fn_def(a_def_id, substs, fty));\n                 }\n             }\n \n             // Reify both sides and return the reified fn pointer type.\n             for expr in exprs().into_iter().chain(Some(new)) {\n                 // No adjustments can produce a fn item, so this should never trip.\n-                assert!(!self.inh.tables.borrow().adjustments.contains_key(&expr.id));\n+                assert!(!self.tables.borrow().adjustments.contains_key(&expr.id));\n                 self.write_adjustment(expr.id, AdjustReifyFnPointer);\n             }\n-            return Ok(self.tcx().mk_fn_ptr(fty));\n+            return Ok(self.tcx.mk_fn_ptr(fty));\n         }\n         _ => {}\n     }\n@@ -705,8 +708,8 @@ pub fn try_find_coercion_lub<'b, E, I>(&self,\n     // First try to coerce the new expression to the type of the previous ones,\n     // but only if the new expression has no coercion already applied to it.\n     let mut first_error = None;\n-    if !self.inh.tables.borrow().adjustments.contains_key(&new.id) {\n-        let result = self.infcx().commit_if_ok(|_| {\n+    if !self.tables.borrow().adjustments.contains_key(&new.id) {\n+        let result = self.commit_if_ok(|_| {\n             apply(&mut coerce, &|| Some(new), new_ty, prev_ty)\n         });\n         match result {\n@@ -724,7 +727,7 @@ pub fn try_find_coercion_lub<'b, E, I>(&self,\n     // This requires ensuring there are no coercions applied to *any* of the\n     // previous expressions, other than noop reborrows (ignoring lifetimes).\n     for expr in exprs() {\n-        let noop = match self.inh.tables.borrow().adjustments.get(&expr.id) {\n+        let noop = match self.tables.borrow().adjustments.get(&expr.id) {\n             Some(&AdjustDerefRef(AutoDerefRef {\n                 autoderefs: 1,\n                 autoref: Some(AutoPtr(_, mutbl_adj)),\n@@ -741,8 +744,8 @@ pub fn try_find_coercion_lub<'b, E, I>(&self,\n         };\n \n         if !noop {\n-            return self.infcx().commit_if_ok(|_| {\n-                self.infcx().lub(true, trace.clone(), &prev_ty, &new_ty)\n+            return self.commit_if_ok(|_| {\n+                self.lub(true, trace.clone(), &prev_ty, &new_ty)\n                     .map(|InferOk { value, obligations }| {\n                         // FIXME(#32730) propagate obligations\n                         assert!(obligations.is_empty());\n@@ -752,14 +755,14 @@ pub fn try_find_coercion_lub<'b, E, I>(&self,\n         }\n     }\n \n-    match self.infcx().commit_if_ok(|_| apply(&mut coerce, &exprs, prev_ty, new_ty)) {\n+    match self.commit_if_ok(|_| apply(&mut coerce, &exprs, prev_ty, new_ty)) {\n         Err(_) => {\n             // Avoid giving strange errors on failed attempts.\n             if let Some(e) = first_error {\n                 Err(e)\n             } else {\n-                self.infcx().commit_if_ok(|_| {\n-                    self.infcx().lub(true, trace, &prev_ty, &new_ty)\n+                self.commit_if_ok(|_| {\n+                    self.lub(true, trace, &prev_ty, &new_ty)\n                         .map(|InferOk { value, obligations }| {\n                             // FIXME(#32730) propagate obligations\n                             assert!(obligations.is_empty());"}, {"sha": "4f4b7fa9ef75d7d111180935d157c492d47e9668", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0053b442f8cd5bf5e310a2664fc3a47a8f33da71/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0053b442f8cd5bf5e310a2664fc3a47a8f33da71/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=0053b442f8cd5bf5e310a2664fc3a47a8f33da71", "patch": "@@ -21,37 +21,37 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx, 'tcx> {\n // they don't.\n pub fn demand_suptype(&self, sp: Span, expected: Ty<'tcx>, actual: Ty<'tcx>) {\n     let origin = TypeOrigin::Misc(sp);\n-    match self.infcx().sub_types(false, origin, actual, expected) {\n+    match self.sub_types(false, origin, actual, expected) {\n         Ok(InferOk { obligations, .. }) => {\n             // FIXME(#32730) propagate obligations\n             assert!(obligations.is_empty());\n         },\n         Err(e) => {\n-            self.infcx().report_mismatched_types(origin, expected, actual, e);\n+            self.report_mismatched_types(origin, expected, actual, e);\n         }\n     }\n }\n \n pub fn demand_eqtype(&self, sp: Span, expected: Ty<'tcx>, actual: Ty<'tcx>) {\n     let origin = TypeOrigin::Misc(sp);\n-    match self.infcx().eq_types(false, origin, actual, expected) {\n+    match self.eq_types(false, origin, actual, expected) {\n         Ok(InferOk { obligations, .. }) => {\n             // FIXME(#32730) propagate obligations\n             assert!(obligations.is_empty());\n         },\n         Err(e) => {\n-            self.infcx().report_mismatched_types(origin, expected, actual, e);\n+            self.report_mismatched_types(origin, expected, actual, e);\n         }\n     }\n }\n \n // Checks that the type of `expr` can be coerced to `expected`.\n pub fn demand_coerce(&self, expr: &hir::Expr, expected: Ty<'tcx>) {\n-    let expected = self.resolve_type_vars_if_possible(expected);\n+    let expected = self.resolve_type_vars_with_obligations(expected);\n     if let Err(e) = self.try_coerce(expr, expected) {\n         let origin = TypeOrigin::Misc(expr.span);\n-        let expr_ty = self.resolve_type_vars_if_possible(self.expr_ty(expr));\n-        self.infcx().report_mismatched_types(origin, expected, expr_ty, e);\n+        let expr_ty = self.resolve_type_vars_with_obligations(self.expr_ty(expr));\n+        self.report_mismatched_types(origin, expected, expr_ty, e);\n     }\n }\n }"}, {"sha": "b705dee4ae8654691d9357ed976407c2645911ac", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0053b442f8cd5bf5e310a2664fc3a47a8f33da71/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0053b442f8cd5bf5e310a2664fc3a47a8f33da71/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=0053b442f8cd5bf5e310a2664fc3a47a8f33da71", "patch": "@@ -281,7 +281,7 @@ pub fn check_safety_of_destructor_if_necessary<'a, 'tcx>(rcx: &mut RegionCtxt<'a\n     debug!(\"check_safety_of_destructor_if_necessary typ: {:?} scope: {:?}\",\n            typ, scope);\n \n-    let parent_scope = rcx.tcx().region_maps.opt_encl_scope(scope).unwrap_or_else(|| {\n+    let parent_scope = rcx.tcx.region_maps.opt_encl_scope(scope).unwrap_or_else(|| {\n         span_bug!(span, \"no enclosing scope found for scope: {:?}\", scope)\n     });\n \n@@ -298,7 +298,7 @@ pub fn check_safety_of_destructor_if_necessary<'a, 'tcx>(rcx: &mut RegionCtxt<'a\n     match result {\n         Ok(()) => {}\n         Err(Error::Overflow(ref ctxt, ref detected_on_typ)) => {\n-            let tcx = rcx.tcx();\n+            let tcx = rcx.tcx;\n             let mut err = struct_span_err!(tcx.sess, span, E0320,\n                                            \"overflow while adding drop-check rules for {}\", typ);\n             match *ctxt {\n@@ -360,7 +360,7 @@ fn iterate_over_potentially_unsafe_regions_in_type<'a, 'b, 'tcx>(\n     ty: Ty<'tcx>,\n     depth: usize) -> Result<(), Error<'tcx>>\n {\n-    let tcx = cx.rcx.tcx();\n+    let tcx = cx.rcx.tcx;\n     // Issue #22443: Watch out for overflow. While we are careful to\n     // handle regular types properly, non-regular ones cause problems.\n     let recursion_limit = tcx.sess.recursion_limit.get();\n@@ -373,7 +373,7 @@ fn iterate_over_potentially_unsafe_regions_in_type<'a, 'b, 'tcx>(\n \n     // canoncialize the regions in `ty` before inserting - infinitely many\n     // region variables can refer to the same region.\n-    let ty = cx.rcx.infcx().resolve_type_and_region_vars_if_possible(&ty);\n+    let ty = cx.rcx.resolve_type_and_region_vars_if_possible(&ty);\n \n     if !cx.breadcrumbs.insert(ty) {\n         debug!(\"iterate_over_potentially_unsafe_regions_in_type \\\n@@ -453,7 +453,7 @@ fn iterate_over_potentially_unsafe_regions_in_type<'a, 'b, 'tcx>(\n             for variant in &def.variants {\n                 for field in variant.fields.iter() {\n                     let fty = field.ty(tcx, substs);\n-                    let fty = cx.rcx.fcx.resolve_type_vars_if_possible(\n+                    let fty = cx.rcx.fcx.resolve_type_vars_with_obligations(\n                         cx.rcx.fcx.normalize_associated_types_in(cx.span, &fty));\n                     iterate_over_potentially_unsafe_regions_in_type(\n                         cx,\n@@ -504,7 +504,7 @@ fn has_dtor_of_interest<'a, 'b, 'tcx>(cx: &DropckContext<'a, 'b, 'tcx, 'tcx>,\n                                       ty: ty::Ty<'tcx>) -> bool {\n     match ty.sty {\n         ty::TyEnum(def, _) | ty::TyStruct(def, _) => {\n-            def.is_dtorck(cx.rcx.tcx())\n+            def.is_dtorck(cx.rcx.tcx)\n         }\n         ty::TyTrait(..) | ty::TyProjection(..) => {\n             debug!(\"ty: {:?} isn't known, and therefore is a dropck type\", ty);"}, {"sha": "ca17f4bd3a8b52f8f52ffc9dd0c0426d030ea90e", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 72, "deletions": 78, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/0053b442f8cd5bf5e310a2664fc3a47a8f33da71/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0053b442f8cd5bf5e310a2664fc3a47a8f33da71/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=0053b442f8cd5bf5e310a2664fc3a47a8f33da71", "patch": "@@ -15,21 +15,29 @@ use check::UnresolvedTypeAction;\n use hir::def_id::DefId;\n use rustc::ty::subst::{self};\n use rustc::traits;\n-use rustc::ty::{self, NoPreference, PreferMutLvalue, Ty, TyCtxt};\n+use rustc::ty::{self, NoPreference, PreferMutLvalue, Ty};\n use rustc::ty::adjustment::{AdjustDerefRef, AutoDerefRef, AutoPtr};\n use rustc::ty::fold::TypeFoldable;\n-use rustc::infer;\n-use rustc::infer::{InferCtxt, InferOk, TypeOrigin};\n+use rustc::infer::{self, InferOk, TypeOrigin};\n use syntax::codemap::Span;\n use rustc::hir;\n \n+use std::ops::Deref;\n+\n struct ConfirmContext<'a, 'gcx: 'a+'tcx, 'tcx: 'a>{\n     fcx: &'a FnCtxt<'a, 'gcx, 'tcx>,\n     span: Span,\n     self_expr: &'gcx hir::Expr,\n     call_expr: &'gcx hir::Expr,\n }\n \n+impl<'a, 'gcx, 'tcx> Deref for ConfirmContext<'a, 'gcx, 'tcx> {\n+    type Target = FnCtxt<'a, 'gcx, 'tcx>;\n+    fn deref(&self) -> &Self::Target {\n+        &self.fcx\n+    }\n+}\n+\n struct InstantiatedMethodSig<'tcx> {\n     /// Function signature of the method being invoked. The 0th\n     /// argument is the receiver.\n@@ -100,7 +108,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx, 'tcx> {\n         let InstantiatedMethodSig {\n             method_sig, all_substs, method_predicates\n         } = self.instantiate_method_sig(&pick, all_substs);\n-        let all_substs = self.tcx().mk_substs(all_substs);\n+        let all_substs = self.tcx.mk_substs(all_substs);\n         let method_self_ty = method_sig.inputs[0];\n \n         // Unify the (adjusted) self type with what the method expects.\n@@ -109,7 +117,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx, 'tcx> {\n         // Create the method type\n         let def_id = pick.item.def_id();\n         let method_ty = pick.item.as_opt_method().unwrap();\n-        let fty = self.tcx().mk_fn_def(def_id, all_substs, ty::BareFnTy {\n+        let fty = self.tcx.mk_fn_def(def_id, all_substs, ty::BareFnTy {\n             sig: ty::Binder(method_sig),\n             unsafety: method_ty.fty.unsafety,\n             abi: method_ty.fty.abi.clone(),\n@@ -141,10 +149,10 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx, 'tcx> {\n                       -> Ty<'tcx>\n     {\n         let (autoref, unsize) = if let Some(mutbl) = pick.autoref {\n-            let region = self.infcx().next_region_var(infer::Autoref(self.span));\n-            let autoref = AutoPtr(self.tcx().mk_region(region), mutbl);\n+            let region = self.next_region_var(infer::Autoref(self.span));\n+            let autoref = AutoPtr(self.tcx.mk_region(region), mutbl);\n             (Some(autoref), pick.unsize.map(|target| {\n-                target.adjust_for_autoref(self.tcx(), Some(autoref))\n+                target.adjust_for_autoref(self.tcx, Some(autoref))\n             }))\n         } else {\n             // No unsizing should be performed without autoref (at\n@@ -157,12 +165,12 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx, 'tcx> {\n \n         // Commit the autoderefs by calling `autoderef again, but this\n         // time writing the results into the various tables.\n-        let (autoderefd_ty, n, result) = self.fcx.autoderef(self.span,\n-                                                            unadjusted_self_ty,\n-                                                            || Some(self.self_expr),\n-                                                            UnresolvedTypeAction::Error,\n-                                                            NoPreference,\n-                                                            |_, n| {\n+        let (autoderefd_ty, n, result) = self.autoderef(self.span,\n+                                                        unadjusted_self_ty,\n+                                                        || Some(self.self_expr),\n+                                                        UnresolvedTypeAction::Error,\n+                                                        NoPreference,\n+                                                        |_, n| {\n             if n == pick.autoderefs {\n                 Some(())\n             } else {\n@@ -173,8 +181,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx, 'tcx> {\n         assert_eq!(result, Some(()));\n \n         // Write out the final adjustment.\n-        self.fcx.write_adjustment(self.self_expr.id,\n-                                  AdjustDerefRef(AutoDerefRef {\n+        self.write_adjustment(self.self_expr.id, AdjustDerefRef(AutoDerefRef {\n             autoderefs: pick.autoderefs,\n             autoref: autoref,\n             unsize: unsize\n@@ -183,7 +190,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx, 'tcx> {\n         if let Some(target) = unsize {\n             target\n         } else {\n-            autoderefd_ty.adjust_for_autoref(self.tcx(), autoref)\n+            autoderefd_ty.adjust_for_autoref(self.tcx, autoref)\n         }\n     }\n \n@@ -204,9 +211,9 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx, 'tcx> {\n         match pick.kind {\n             probe::InherentImplPick => {\n                 let impl_def_id = pick.item.container().id();\n-                assert!(self.tcx().impl_trait_ref(impl_def_id).is_none(),\n+                assert!(self.tcx.impl_trait_ref(impl_def_id).is_none(),\n                         \"impl {:?} is not an inherent impl\", impl_def_id);\n-                self.fcx.impl_self_ty(self.span, impl_def_id).substs\n+                self.impl_self_ty(self.span, impl_def_id).substs\n             }\n \n             probe::ObjectPick => {\n@@ -223,7 +230,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx, 'tcx> {\n                     // been ruled out when we deemed the trait to be\n                     // \"object safe\".\n                     let original_poly_trait_ref =\n-                        data.principal_trait_ref_with_self_ty(this.tcx(), object_ty);\n+                        data.principal_trait_ref_with_self_ty(this.tcx, object_ty);\n                     let upcast_poly_trait_ref =\n                         this.upcast(original_poly_trait_ref.clone(), trait_def_id);\n                     let upcast_trait_ref =\n@@ -246,27 +253,27 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx, 'tcx> {\n                 // respectively, then we want to return the type\n                 // parameters from the trait ([$A,$B]), not those from\n                 // the impl ([$A,$B,$C]) not the receiver type ([$C]).\n-                let impl_polytype = self.fcx.impl_self_ty(self.span, impl_def_id);\n+                let impl_polytype = self.impl_self_ty(self.span, impl_def_id);\n                 let impl_trait_ref =\n-                    self.fcx.instantiate_type_scheme(\n+                    self.instantiate_type_scheme(\n                         self.span,\n                         &impl_polytype.substs,\n-                        &self.tcx().impl_trait_ref(impl_def_id).unwrap());\n+                        &self.tcx.impl_trait_ref(impl_def_id).unwrap());\n                 impl_trait_ref.substs.clone()\n             }\n \n             probe::TraitPick => {\n                 let trait_def_id = pick.item.container().id();\n-                let trait_def = self.tcx().lookup_trait_def(trait_def_id);\n+                let trait_def = self.tcx.lookup_trait_def(trait_def_id);\n \n                 // Make a trait reference `$0 : Trait<$1...$n>`\n                 // consisting entirely of type variables. Later on in\n                 // the process we will unify the transformed-self-type\n                 // of the method with the actual type in order to\n                 // unify some of these variables.\n-                self.infcx().fresh_substs_for_trait(self.span,\n-                                                    &trait_def.generics,\n-                                                    self.infcx().next_ty_var())\n+                self.fresh_substs_for_trait(self.span,\n+                                            &trait_def.generics,\n+                                            self.next_ty_var())\n             }\n \n             probe::WhereClausePick(ref poly_trait_ref) => {\n@@ -328,7 +335,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx, 'tcx> {\n         //\n         // FIXME -- permit users to manually specify lifetimes\n         let method_regions =\n-            self.fcx.infcx().region_vars_for_defs(\n+            self.region_vars_for_defs(\n                 self.span,\n                 pick.item.as_opt_method().unwrap()\n                     .generics.regions.get_slice(subst::FnSpace));\n@@ -338,26 +345,26 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx, 'tcx> {\n         let mut final_substs = subst::Substs { types: types, regions: regions };\n \n         if num_supplied_types == 0 {\n-            self.fcx.infcx().type_vars_for_defs(\n+            self.type_vars_for_defs(\n                 self.span,\n                 subst::FnSpace,\n                 &mut final_substs,\n                 method_types);\n         } else if num_method_types == 0 {\n-            span_err!(self.tcx().sess, self.span, E0035,\n+            span_err!(self.tcx.sess, self.span, E0035,\n                 \"does not take type parameters\");\n-            self.fcx.infcx().type_vars_for_defs(\n+            self.type_vars_for_defs(\n                 self.span,\n                 subst::FnSpace,\n                 &mut final_substs,\n                 method_types);\n         } else if num_supplied_types != num_method_types {\n-            span_err!(self.tcx().sess, self.span, E0036,\n+            span_err!(self.tcx.sess, self.span, E0036,\n                 \"incorrect number of type parameters given for this method: expected {}, found {}\",\n                 num_method_types, num_supplied_types);\n             final_substs.types.replace(\n                 subst::FnSpace,\n-                vec![self.tcx().types.err; num_method_types]);\n+                vec![self.tcx.types.err; num_method_types]);\n         } else {\n             final_substs.types.replace(subst::FnSpace, supplied_method_types);\n         }\n@@ -369,8 +376,8 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx, 'tcx> {\n                        self_ty: Ty<'tcx>,\n                        method_self_ty: Ty<'tcx>)\n     {\n-        match self.fcx.infcx().sub_types(false, TypeOrigin::Misc(self.span),\n-                                         self_ty, method_self_ty) {\n+        match self.sub_types(false, TypeOrigin::Misc(self.span),\n+                             self_ty, method_self_ty) {\n             Ok(InferOk { obligations, .. }) => {\n                 // FIXME(#32730) propagate obligations\n                 assert!(obligations.is_empty());\n@@ -400,9 +407,9 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx, 'tcx> {\n         // type/early-bound-regions substitutions performed. There can\n         // be no late-bound regions appearing here.\n         let method_predicates = pick.item.as_opt_method().unwrap()\n-                                    .predicates.instantiate(self.tcx(), &all_substs);\n-        let method_predicates = self.fcx.normalize_associated_types_in(self.span,\n-                                                                       &method_predicates);\n+                                    .predicates.instantiate(self.tcx, &all_substs);\n+        let method_predicates = self.normalize_associated_types_in(self.span,\n+                                                                   &method_predicates);\n \n         debug!(\"method_predicates after subst = {:?}\",\n                method_predicates);\n@@ -418,7 +425,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx, 'tcx> {\n         debug!(\"late-bound lifetimes from method instantiated, method_sig={:?}\",\n                method_sig);\n \n-        let method_sig = self.fcx.instantiate_type_scheme(self.span, &all_substs, &method_sig);\n+        let method_sig = self.instantiate_type_scheme(self.span, &all_substs, &method_sig);\n         debug!(\"type scheme substituted, method_sig={:?}\",\n                method_sig);\n \n@@ -438,20 +445,18 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx, 'tcx> {\n                all_substs,\n                method_predicates);\n \n-        self.fcx.add_obligations_for_parameters(\n-            traits::ObligationCause::misc(self.span, self.fcx.body_id),\n+        self.add_obligations_for_parameters(\n+            traits::ObligationCause::misc(self.span, self.body_id),\n             method_predicates);\n \n         // this is a projection from a trait reference, so we have to\n         // make sure that the trait reference inputs are well-formed.\n-        self.fcx.add_wf_bounds(\n-            all_substs,\n-            self.call_expr);\n+        self.add_wf_bounds(all_substs, self.call_expr);\n \n         // the function type must also be well-formed (this is not\n         // implied by the substs being well-formed because of inherent\n         // impls and late-bound regions - see issue #28609).\n-        self.fcx.register_wf_obligation(fty, self.span, traits::MiscObligation);\n+        self.register_wf_obligation(fty, self.span, traits::MiscObligation);\n     }\n \n     ///////////////////////////////////////////////////////////////////////////\n@@ -495,9 +500,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx, 'tcx> {\n         // Fix up autoderefs and derefs.\n         for (i, &expr) in exprs.iter().rev().enumerate() {\n             // Count autoderefs.\n-            let autoderef_count = match self.fcx\n-                                            .inh\n-                                            .tables\n+            let autoderef_count = match self.tables\n                                             .borrow()\n                                             .adjustments\n                                             .get(&expr.id) {\n@@ -510,12 +513,12 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx, 'tcx> {\n                    i, expr, autoderef_count);\n \n             if autoderef_count > 0 {\n-                self.fcx.autoderef(expr.span,\n-                                   self.fcx.expr_ty(expr),\n-                                   || Some(expr),\n-                                   UnresolvedTypeAction::Error,\n-                                   PreferMutLvalue,\n-                                   |_, autoderefs| {\n+                self.autoderef(expr.span,\n+                               self.expr_ty(expr),\n+                               || Some(expr),\n+                               UnresolvedTypeAction::Error,\n+                               PreferMutLvalue,\n+                               |_, autoderefs| {\n                     if autoderefs == autoderef_count + 1 {\n                         Some(())\n                     } else {\n@@ -538,8 +541,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx, 'tcx> {\n                     // expects. This is annoying and horrible. We\n                     // ought to recode this routine so it doesn't\n                     // (ab)use the normal type checking paths.\n-                    let adj = self.fcx.inh.tables.borrow().adjustments.get(&base_expr.id)\n-                                                                        .cloned();\n+                    let adj = self.tables.borrow().adjustments.get(&base_expr.id).cloned();\n                     let (autoderefs, unsize) = match adj {\n                         Some(AdjustDerefRef(adr)) => match adr.autoref {\n                             None => {\n@@ -570,16 +572,16 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx, 'tcx> {\n                     let (adjusted_base_ty, unsize) = if let Some(target) = unsize {\n                         (target, true)\n                     } else {\n-                        (self.fcx.adjust_expr_ty(base_expr,\n+                        (self.adjust_expr_ty(base_expr,\n                             Some(&AdjustDerefRef(AutoDerefRef {\n                                 autoderefs: autoderefs,\n                                 autoref: None,\n                                 unsize: None\n                             }))), false)\n                     };\n-                    let index_expr_ty = self.fcx.expr_ty(&index_expr);\n+                    let index_expr_ty = self.expr_ty(&index_expr);\n \n-                    let result = self.fcx.try_index_step(\n+                    let result = self.try_index_step(\n                         ty::MethodCall::expr(expr.id),\n                         expr,\n                         &base_expr,\n@@ -590,23 +592,23 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx, 'tcx> {\n                         index_expr_ty);\n \n                     if let Some((input_ty, return_ty)) = result {\n-                        self.fcx.demand_suptype(index_expr.span, input_ty, index_expr_ty);\n+                        self.demand_suptype(index_expr.span, input_ty, index_expr_ty);\n \n-                        let expr_ty = self.fcx.expr_ty(&expr);\n-                        self.fcx.demand_suptype(expr.span, expr_ty, return_ty);\n+                        let expr_ty = self.expr_ty(&expr);\n+                        self.demand_suptype(expr.span, expr_ty, return_ty);\n                     }\n                 }\n                 hir::ExprUnary(hir::UnDeref, ref base_expr) => {\n                     // if this is an overloaded deref, then re-evaluate with\n                     // a preference for mut\n                     let method_call = ty::MethodCall::expr(expr.id);\n-                    if self.fcx.inh.tables.borrow().method_map.contains_key(&method_call) {\n-                        let method = self.fcx.try_overloaded_deref(expr.span,\n+                    if self.tables.borrow().method_map.contains_key(&method_call) {\n+                        let method = self.try_overloaded_deref(expr.span,\n                             Some(&base_expr),\n-                            self.fcx.expr_ty(&base_expr),\n+                            self.expr_ty(&base_expr),\n                             PreferMutLvalue);\n                         let method = method.expect(\"re-trying deref failed\");\n-                        self.fcx.inh.tables.borrow_mut().method_map.insert(method_call, method);\n+                        self.tables.borrow_mut().method_map.insert(method_call, method);\n                     }\n                 }\n                 _ => {}\n@@ -617,19 +619,11 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx, 'tcx> {\n     ///////////////////////////////////////////////////////////////////////////\n     // MISCELLANY\n \n-    fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx> {\n-        self.fcx.tcx()\n-    }\n-\n-    fn infcx(&self) -> &'a InferCtxt<'a, 'tcx, 'tcx> {\n-        self.fcx.infcx()\n-    }\n-\n     fn enforce_illegal_method_limitations(&self, pick: &probe::Pick) {\n         // Disallow calls to the method `drop` defined in the `Drop` trait.\n         match pick.item.container() {\n             ty::TraitContainer(trait_def_id) => {\n-                callee::check_legal_trait_for_method_call(self.fcx.ccx, self.span, trait_def_id)\n+                callee::check_legal_trait_for_method_call(self.ccx, self.span, trait_def_id)\n             }\n             ty::ImplContainer(..) => {}\n         }\n@@ -640,8 +634,8 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx, 'tcx> {\n               target_trait_def_id: DefId)\n               -> ty::PolyTraitRef<'tcx>\n     {\n-        let upcast_trait_refs = self.tcx().upcast_choices(source_trait_ref.clone(),\n-                                                          target_trait_def_id);\n+        let upcast_trait_refs = self.tcx.upcast_choices(source_trait_ref.clone(),\n+                                                        target_trait_def_id);\n \n         // must be exactly one trait ref or we'd get an ambig error etc\n         if upcast_trait_refs.len() != 1 {\n@@ -659,7 +653,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx, 'tcx> {\n     fn replace_late_bound_regions_with_fresh_var<T>(&self, value: &ty::Binder<T>) -> T\n         where T : TypeFoldable<'tcx>\n     {\n-        self.infcx().replace_late_bound_regions_with_fresh_var(\n+        self.fcx.replace_late_bound_regions_with_fresh_var(\n             self.span, infer::FnCall, value).0\n     }\n }"}, {"sha": "f63f9870977c74d0361517837cab19495f4b6eba", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/0053b442f8cd5bf5e310a2664fc3a47a8f33da71/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0053b442f8cd5bf5e310a2664fc3a47a8f33da71/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=0053b442f8cd5bf5e310a2664fc3a47a8f33da71", "patch": "@@ -127,11 +127,11 @@ pub fn lookup_method(&self,\n            self_expr);\n \n     let mode = probe::Mode::MethodCall;\n-    let self_ty = self.infcx().resolve_type_vars_if_possible(&self_ty);\n+    let self_ty = self.resolve_type_vars_if_possible(&self_ty);\n     let pick = self.probe_method(span, mode, method_name, self_ty, call_expr.id)?;\n \n     if let Some(import_id) = pick.import_id {\n-        self.tcx().used_trait_imports.borrow_mut().insert(import_id);\n+        self.tcx.used_trait_imports.borrow_mut().insert(import_id);\n     }\n \n     Ok(self.confirm_method(span, self_expr, call_expr, self_ty, pick, supplied_method_types))\n@@ -176,7 +176,7 @@ pub fn lookup_method_in_trait_adjusted(&self,\n            m_name,\n            trait_def_id);\n \n-    let trait_def = self.tcx().lookup_trait_def(trait_def_id);\n+    let trait_def = self.tcx.lookup_trait_def(trait_def_id);\n \n     let type_parameter_defs = trait_def.generics.types.get_slice(subst::TypeSpace);\n     let expected_number_of_input_types = type_parameter_defs.len();\n@@ -194,15 +194,15 @@ pub fn lookup_method_in_trait_adjusted(&self,\n         }\n \n         None => {\n-            self.inh.infcx.type_vars_for_defs(\n+            self.type_vars_for_defs(\n                 span,\n                 subst::ParamSpace::TypeSpace,\n                 &mut substs,\n                 type_parameter_defs);\n         }\n     }\n \n-    let trait_ref = ty::TraitRef::new(trait_def_id, self.tcx().mk_substs(substs));\n+    let trait_ref = ty::TraitRef::new(trait_def_id, self.tcx.mk_substs(substs));\n \n     // Construct an obligation\n     let poly_trait_ref = trait_ref.to_poly_trait_ref();\n@@ -211,15 +211,15 @@ pub fn lookup_method_in_trait_adjusted(&self,\n                                               poly_trait_ref.to_predicate());\n \n     // Now we want to know if this can be matched\n-    let mut selcx = traits::SelectionContext::new(self.infcx());\n+    let mut selcx = traits::SelectionContext::new(self);\n     if !selcx.evaluate_obligation(&obligation) {\n         debug!(\"--> Cannot match obligation\");\n         return None; // Cannot be matched, no such method resolution is possible.\n     }\n \n     // Trait must have a method named `m_name` and it should not have\n     // type parameters or early-bound regions.\n-    let tcx = self.tcx();\n+    let tcx = self.tcx;\n     let method_item = self.trait_item(trait_def_id, m_name).unwrap();\n     let method_ty = method_item.as_opt_method().unwrap();\n     assert_eq!(method_ty.generics.types.len(subst::FnSpace), 0);\n@@ -234,9 +234,9 @@ pub fn lookup_method_in_trait_adjusted(&self,\n     // NB: Instantiate late-bound regions first so that\n     // `instantiate_type_scheme` can normalize associated types that\n     // may reference those regions.\n-    let fn_sig = self.infcx().replace_late_bound_regions_with_fresh_var(span,\n-                                                                        infer::FnCall,\n-                                                                        &method_ty.fty.sig).0;\n+    let fn_sig = self.replace_late_bound_regions_with_fresh_var(span,\n+                                                                infer::FnCall,\n+                                                                &method_ty.fty.sig).0;\n     let fn_sig = self.instantiate_type_scheme(span, trait_ref.substs, &fn_sig);\n     let transformed_self_ty = fn_sig.inputs[0];\n     let def_id = method_item.def_id();\n@@ -347,14 +347,14 @@ pub fn resolve_ufcs(&self,\n     let pick = self.probe_method(span, mode, method_name, self_ty, expr_id)?;\n \n     if let Some(import_id) = pick.import_id {\n-        self.tcx().used_trait_imports.borrow_mut().insert(import_id);\n+        self.tcx.used_trait_imports.borrow_mut().insert(import_id);\n     }\n \n     let def = pick.item.def();\n     if let probe::InherentImplPick = pick.kind {\n-        if !pick.item.vis().is_accessible_from(self.body_id, &self.tcx().map) {\n+        if !pick.item.vis().is_accessible_from(self.body_id, &self.tcx.map) {\n             let msg = format!(\"{} `{}` is private\", def.kind_name(), &method_name.as_str());\n-            self.tcx().sess.span_err(span, &msg);\n+            self.tcx.sess.span_err(span, &msg);\n         }\n     }\n     Ok(def)\n@@ -367,7 +367,7 @@ pub fn trait_item(&self,\n                   item_name: ast::Name)\n                   -> Option<ty::ImplOrTraitItem<'tcx>>\n {\n-    let trait_items = self.tcx().trait_items(trait_def_id);\n+    let trait_items = self.tcx.trait_items(trait_def_id);\n     trait_items.iter()\n                .find(|item| item.name() == item_name)\n                .cloned()\n@@ -378,11 +378,11 @@ pub fn impl_item(&self,\n                  item_name: ast::Name)\n                  -> Option<ty::ImplOrTraitItem<'tcx>>\n {\n-    let impl_items = self.tcx().impl_items.borrow();\n+    let impl_items = self.tcx.impl_items.borrow();\n     let impl_items = impl_items.get(&impl_def_id).unwrap();\n     impl_items\n         .iter()\n-        .map(|&did| self.tcx().impl_or_trait_item(did.def_id()))\n+        .map(|&did| self.tcx.impl_or_trait_item(did.def_id()))\n         .find(|m| m.name() == item_name)\n }\n }"}, {"sha": "6ee309516a0fdbfaad179c428ec946f5de3df263", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 84, "deletions": 87, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/0053b442f8cd5bf5e310a2664fc3a47a8f33da71/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0053b442f8cd5bf5e310a2664fc3a47a8f33da71/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=0053b442f8cd5bf5e310a2664fc3a47a8f33da71", "patch": "@@ -19,13 +19,14 @@ use hir::def::Def;\n use rustc::ty::subst;\n use rustc::ty::subst::Subst;\n use rustc::traits;\n-use rustc::ty::{self, NoPreference, Ty, TyCtxt, ToPolyTraitRef, TraitRef, TypeFoldable};\n-use rustc::infer::{self, InferCtxt, InferOk, TypeOrigin};\n+use rustc::ty::{self, NoPreference, Ty, ToPolyTraitRef, TraitRef, TypeFoldable};\n+use rustc::infer::{InferOk, TypeOrigin};\n use syntax::ast;\n use syntax::codemap::{Span, DUMMY_SP};\n use rustc::hir;\n use std::collections::HashSet;\n use std::mem;\n+use std::ops::Deref;\n use std::rc::Rc;\n \n use self::CandidateKind::*;\n@@ -55,6 +56,13 @@ struct ProbeContext<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     unsatisfied_predicates: Vec<TraitRef<'tcx>>\n }\n \n+impl<'a, 'gcx, 'tcx> Deref for ProbeContext<'a, 'gcx, 'tcx> {\n+    type Target = FnCtxt<'a, 'gcx, 'tcx>;\n+    fn deref(&self) -> &Self::Target {\n+        &self.fcx\n+    }\n+}\n+\n #[derive(Debug)]\n struct CandidateStep<'tcx> {\n     self_ty: Ty<'tcx>,\n@@ -148,7 +156,7 @@ pub fn probe_method(&self,\n     // side-effects. This is a bit of a pain to refactor. So just let\n     // it ride, although it's really not great, and in fact could I\n     // think cause spurious errors. Really though this part should\n-    // take place in the `self.infcx().probe` below.\n+    // take place in the `self.probe` below.\n     let steps = if mode == Mode::MethodCall {\n         match self.create_steps(span, self_ty) {\n             Some(steps) => steps,\n@@ -166,7 +174,7 @@ pub fn probe_method(&self,\n     // Create a list of simplified self types, if we can.\n     let mut simplified_steps = Vec::new();\n     for step in &steps {\n-        match ty::fast_reject::simplify_type(self.tcx(), step.self_ty, true) {\n+        match ty::fast_reject::simplify_type(self.tcx, step.self_ty, true) {\n             None => { break; }\n             Some(simplified_type) => { simplified_steps.push(simplified_type); }\n         }\n@@ -184,7 +192,7 @@ pub fn probe_method(&self,\n \n     // this creates one big transaction so that all type variables etc\n     // that we create during the probe process are removed later\n-    self.infcx().probe(|_| {\n+    self.probe(|_| {\n         let mut probe_cx = ProbeContext::new(self,\n                                              span,\n                                              mode,\n@@ -220,7 +228,7 @@ fn create_steps(&self,\n     match final_ty.sty {\n         ty::TyArray(elem_ty, _) => {\n             steps.push(CandidateStep {\n-                self_ty: self.tcx().mk_slice(elem_ty),\n+                self_ty: self.tcx.mk_slice(elem_ty),\n                 autoderefs: dereferences,\n                 unsize: true\n             });\n@@ -267,14 +275,6 @@ impl<'a,'tcx> ProbeContext<'a,'tcx, 'tcx> {\n         self.private_candidate = None;\n     }\n \n-    fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx> {\n-        self.fcx.tcx()\n-    }\n-\n-    fn infcx(&self) -> &'a InferCtxt<'a, 'tcx, 'tcx> {\n-        self.fcx.infcx()\n-    }\n-\n     ///////////////////////////////////////////////////////////////////////////\n     // CANDIDATE ASSEMBLY\n \n@@ -299,79 +299,79 @@ impl<'a,'tcx> ProbeContext<'a,'tcx, 'tcx> {\n                 self.assemble_inherent_impl_candidates_for_type(def.did);\n             }\n             ty::TyBox(_) => {\n-                if let Some(box_did) = self.tcx().lang_items.owned_box() {\n+                if let Some(box_did) = self.tcx.lang_items.owned_box() {\n                     self.assemble_inherent_impl_candidates_for_type(box_did);\n                 }\n             }\n             ty::TyParam(p) => {\n                 self.assemble_inherent_candidates_from_param(self_ty, p);\n             }\n             ty::TyChar => {\n-                let lang_def_id = self.tcx().lang_items.char_impl();\n+                let lang_def_id = self.tcx.lang_items.char_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n             ty::TyStr => {\n-                let lang_def_id = self.tcx().lang_items.str_impl();\n+                let lang_def_id = self.tcx.lang_items.str_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n             ty::TySlice(_) => {\n-                let lang_def_id = self.tcx().lang_items.slice_impl();\n+                let lang_def_id = self.tcx.lang_items.slice_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n             ty::TyRawPtr(ty::TypeAndMut { ty: _, mutbl: hir::MutImmutable }) => {\n-                let lang_def_id = self.tcx().lang_items.const_ptr_impl();\n+                let lang_def_id = self.tcx.lang_items.const_ptr_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n             ty::TyRawPtr(ty::TypeAndMut { ty: _, mutbl: hir::MutMutable }) => {\n-                let lang_def_id = self.tcx().lang_items.mut_ptr_impl();\n+                let lang_def_id = self.tcx.lang_items.mut_ptr_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n             ty::TyInt(ast::IntTy::I8) => {\n-                let lang_def_id = self.tcx().lang_items.i8_impl();\n+                let lang_def_id = self.tcx.lang_items.i8_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n             ty::TyInt(ast::IntTy::I16) => {\n-                let lang_def_id = self.tcx().lang_items.i16_impl();\n+                let lang_def_id = self.tcx.lang_items.i16_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n             ty::TyInt(ast::IntTy::I32) => {\n-                let lang_def_id = self.tcx().lang_items.i32_impl();\n+                let lang_def_id = self.tcx.lang_items.i32_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n             ty::TyInt(ast::IntTy::I64) => {\n-                let lang_def_id = self.tcx().lang_items.i64_impl();\n+                let lang_def_id = self.tcx.lang_items.i64_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n             ty::TyInt(ast::IntTy::Is) => {\n-                let lang_def_id = self.tcx().lang_items.isize_impl();\n+                let lang_def_id = self.tcx.lang_items.isize_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n             ty::TyUint(ast::UintTy::U8) => {\n-                let lang_def_id = self.tcx().lang_items.u8_impl();\n+                let lang_def_id = self.tcx.lang_items.u8_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n             ty::TyUint(ast::UintTy::U16) => {\n-                let lang_def_id = self.tcx().lang_items.u16_impl();\n+                let lang_def_id = self.tcx.lang_items.u16_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n             ty::TyUint(ast::UintTy::U32) => {\n-                let lang_def_id = self.tcx().lang_items.u32_impl();\n+                let lang_def_id = self.tcx.lang_items.u32_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n             ty::TyUint(ast::UintTy::U64) => {\n-                let lang_def_id = self.tcx().lang_items.u64_impl();\n+                let lang_def_id = self.tcx.lang_items.u64_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n             ty::TyUint(ast::UintTy::Us) => {\n-                let lang_def_id = self.tcx().lang_items.usize_impl();\n+                let lang_def_id = self.tcx.lang_items.usize_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n             ty::TyFloat(ast::FloatTy::F32) => {\n-                let lang_def_id = self.tcx().lang_items.f32_impl();\n+                let lang_def_id = self.tcx.lang_items.f32_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n             ty::TyFloat(ast::FloatTy::F64) => {\n-                let lang_def_id = self.tcx().lang_items.f64_impl();\n+                let lang_def_id = self.tcx.lang_items.f64_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n             _ => {\n@@ -381,7 +381,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx, 'tcx> {\n \n     fn assemble_inherent_impl_for_primitive(&mut self, lang_def_id: Option<DefId>) {\n         if let Some(impl_def_id) = lang_def_id {\n-            self.tcx().populate_implementations_for_primitive_if_necessary(impl_def_id);\n+            self.tcx.populate_implementations_for_primitive_if_necessary(impl_def_id);\n \n             self.assemble_inherent_impl_probe(impl_def_id);\n         }\n@@ -390,9 +390,9 @@ impl<'a,'tcx> ProbeContext<'a,'tcx, 'tcx> {\n     fn assemble_inherent_impl_candidates_for_type(&mut self, def_id: DefId) {\n         // Read the inherent implementation candidates for this type from the\n         // metadata if necessary.\n-        self.tcx().populate_inherent_implementations_for_type_if_necessary(def_id);\n+        self.tcx.populate_inherent_implementations_for_type_if_necessary(def_id);\n \n-        if let Some(impl_infos) = self.tcx().inherent_impls.borrow().get(&def_id) {\n+        if let Some(impl_infos) = self.tcx.inherent_impls.borrow().get(&def_id) {\n             for &impl_def_id in impl_infos.iter() {\n                 self.assemble_inherent_impl_probe(impl_def_id);\n             }\n@@ -416,21 +416,21 @@ impl<'a,'tcx> ProbeContext<'a,'tcx, 'tcx> {\n             return self.record_static_candidate(ImplSource(impl_def_id));\n         }\n \n-        if !item.vis().is_accessible_from(self.fcx.body_id, &self.tcx().map) {\n+        if !item.vis().is_accessible_from(self.body_id, &self.tcx.map) {\n             self.private_candidate = Some(item.def());\n             return\n         }\n \n         let (impl_ty, impl_substs) = self.impl_ty_and_substs(impl_def_id);\n-        let impl_ty = impl_ty.subst(self.tcx(), &impl_substs);\n+        let impl_ty = impl_ty.subst(self.tcx, &impl_substs);\n \n         // Determine the receiver type that the method itself expects.\n         let xform_self_ty = self.xform_self_ty(&item, impl_ty, &impl_substs);\n \n         // We can't use normalize_associated_types_in as it will pollute the\n         // fcx's fulfillment context after this probe is over.\n-        let cause = traits::ObligationCause::misc(self.span, self.fcx.body_id);\n-        let mut selcx = &mut traits::SelectionContext::new(self.fcx.infcx());\n+        let cause = traits::ObligationCause::misc(self.span, self.body_id);\n+        let mut selcx = &mut traits::SelectionContext::new(self.fcx);\n         let traits::Normalized { value: xform_self_ty, obligations } =\n             traits::normalize(selcx, cause, &xform_self_ty);\n         debug!(\"assemble_inherent_impl_probe: xform_self_ty = {:?}\",\n@@ -457,7 +457,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx, 'tcx> {\n         // a substitution that replaces `Self` with the object type\n         // itself. Hence, a `&self` method will wind up with an\n         // argument type like `&Trait`.\n-        let trait_ref = data.principal_trait_ref_with_self_ty(self.tcx(), self_ty);\n+        let trait_ref = data.principal_trait_ref_with_self_ty(self.tcx, self_ty);\n         self.elaborate_bounds(&[trait_ref], |this, new_trait_ref, item| {\n             let new_trait_ref = this.erase_late_bound_regions(&new_trait_ref);\n \n@@ -480,7 +480,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx, 'tcx> {\n         // FIXME -- Do we want to commit to this behavior for param bounds?\n \n         let bounds: Vec<_> =\n-            self.fcx.inh.infcx.parameter_environment.caller_bounds\n+            self.parameter_environment.caller_bounds\n             .iter()\n             .filter_map(|predicate| {\n                 match *predicate {\n@@ -561,7 +561,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx, 'tcx> {\n     {\n         debug!(\"elaborate_bounds(bounds={:?})\", bounds);\n \n-        let tcx = self.tcx();\n+        let tcx = self.tcx;\n         for bound_trait_ref in traits::transitive_bounds(tcx, bounds) {\n             let item = match self.trait_item(bound_trait_ref.def_id()) {\n                 Some(v) => v,\n@@ -581,7 +581,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx, 'tcx> {\n                                                          -> Result<(), MethodError<'tcx>>\n     {\n         let mut duplicates = HashSet::new();\n-        let opt_applicable_traits = self.fcx.ccx.trait_map.get(&expr_id);\n+        let opt_applicable_traits = self.ccx.trait_map.get(&expr_id);\n         if let Some(applicable_traits) = opt_applicable_traits {\n             for trait_candidate in applicable_traits {\n                 let trait_did = trait_candidate.def_id;\n@@ -598,7 +598,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx, 'tcx> {\n \n     fn assemble_extension_candidates_for_all_traits(&mut self) -> Result<(), MethodError<'tcx>> {\n         let mut duplicates = HashSet::new();\n-        for trait_info in suggest::all_traits(self.fcx.ccx) {\n+        for trait_info in suggest::all_traits(self.ccx) {\n             if duplicates.insert(trait_info.def_id) {\n                 self.assemble_extension_candidates_for_trait(trait_info.def_id)?;\n             }\n@@ -615,7 +615,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx, 'tcx> {\n \n         // Check whether `trait_def_id` defines a method with suitable name:\n         let trait_items =\n-            self.tcx().trait_items(trait_def_id);\n+            self.tcx.trait_items(trait_def_id);\n         let maybe_item =\n             trait_items.iter()\n                        .find(|item| item.name() == self.item_name);\n@@ -646,10 +646,10 @@ impl<'a,'tcx> ProbeContext<'a,'tcx, 'tcx> {\n                                                      trait_def_id: DefId,\n                                                      item: ty::ImplOrTraitItem<'tcx>)\n     {\n-        let trait_def = self.tcx().lookup_trait_def(trait_def_id);\n+        let trait_def = self.tcx.lookup_trait_def(trait_def_id);\n \n         // FIXME(arielb1): can we use for_each_relevant_impl here?\n-        trait_def.for_each_impl(self.tcx(), |impl_def_id| {\n+        trait_def.for_each_impl(self.tcx, |impl_def_id| {\n             debug!(\"assemble_extension_candidates_for_trait_impl: trait_def_id={:?} \\\n                                                                   impl_def_id={:?}\",\n                    trait_def_id,\n@@ -664,9 +664,9 @@ impl<'a,'tcx> ProbeContext<'a,'tcx, 'tcx> {\n             debug!(\"impl_substs={:?}\", impl_substs);\n \n             let impl_trait_ref =\n-                self.tcx().impl_trait_ref(impl_def_id)\n+                self.tcx.impl_trait_ref(impl_def_id)\n                 .unwrap() // we know this is a trait impl\n-                .subst(self.tcx(), &impl_substs);\n+                .subst(self.tcx, &impl_substs);\n \n             debug!(\"impl_trait_ref={:?}\", impl_trait_ref);\n \n@@ -679,8 +679,8 @@ impl<'a,'tcx> ProbeContext<'a,'tcx, 'tcx> {\n             // Normalize the receiver. We can't use normalize_associated_types_in\n             // as it will pollute the fcx's fulfillment context after this probe\n             // is over.\n-            let cause = traits::ObligationCause::misc(self.span, self.fcx.body_id);\n-            let mut selcx = &mut traits::SelectionContext::new(self.fcx.infcx());\n+            let cause = traits::ObligationCause::misc(self.span, self.body_id);\n+            let mut selcx = &mut traits::SelectionContext::new(self.fcx);\n             let traits::Normalized { value: xform_self_ty, obligations } =\n                 traits::normalize(selcx, cause, &xform_self_ty);\n \n@@ -701,9 +701,9 @@ impl<'a,'tcx> ProbeContext<'a,'tcx, 'tcx> {\n             None => { return true; }\n         };\n \n-        let impl_type = self.tcx().lookup_item_type(impl_def_id);\n+        let impl_type = self.tcx.lookup_item_type(impl_def_id);\n         let impl_simplified_type =\n-            match ty::fast_reject::simplify_type(self.tcx(), impl_type.ty, false) {\n+            match ty::fast_reject::simplify_type(self.tcx, impl_type.ty, false) {\n                 Some(simplified_type) => simplified_type,\n                 None => { return true; }\n             };\n@@ -717,7 +717,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx, 'tcx> {\n                                    -> Result<(), MethodError<'tcx>>\n     {\n         // Check if this is one of the Fn,FnMut,FnOnce traits.\n-        let tcx = self.tcx();\n+        let tcx = self.tcx;\n         let kind = if Some(trait_def_id) == tcx.lang_items.fn_trait() {\n             ty::ClosureKind::Fn\n         } else if Some(trait_def_id) == tcx.lang_items.fn_mut_trait() {\n@@ -737,7 +737,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx, 'tcx> {\n                 _ => continue,\n             };\n \n-            let closure_kinds = &self.fcx.inh.tables.borrow().closure_kinds;\n+            let closure_kinds = &self.tables.borrow().closure_kinds;\n             let closure_kind = match closure_kinds.get(&closure_def_id) {\n                 Some(&k) => k,\n                 None => {\n@@ -754,10 +754,10 @@ impl<'a,'tcx> ProbeContext<'a,'tcx, 'tcx> {\n             // for the purposes of our method lookup, we only take\n             // receiver type into account, so we can just substitute\n             // fresh types here to use during substitution and subtyping.\n-            let trait_def = self.tcx().lookup_trait_def(trait_def_id);\n-            let substs = self.infcx().fresh_substs_for_trait(self.span,\n-                                                             &trait_def.generics,\n-                                                             step.self_ty);\n+            let trait_def = self.tcx.lookup_trait_def(trait_def_id);\n+            let substs = self.fresh_substs_for_trait(self.span,\n+                                                     &trait_def.generics,\n+                                                     step.self_ty);\n \n             let xform_self_ty = self.xform_self_ty(&item,\n                                                    step.self_ty,\n@@ -795,13 +795,13 @@ impl<'a,'tcx> ProbeContext<'a,'tcx, 'tcx> {\n             debug!(\"assemble_projection_candidates: projection_trait_ref={:?}\",\n                    projection_trait_ref);\n \n-            let trait_predicates = self.tcx().lookup_predicates(projection_trait_ref.def_id);\n-            let bounds = trait_predicates.instantiate(self.tcx(), projection_trait_ref.substs);\n+            let trait_predicates = self.tcx.lookup_predicates(projection_trait_ref.def_id);\n+            let bounds = trait_predicates.instantiate(self.tcx, projection_trait_ref.substs);\n             let predicates = bounds.predicates.into_vec();\n             debug!(\"assemble_projection_candidates: predicates={:?}\",\n                    predicates);\n             for poly_bound in\n-                traits::elaborate_predicates(self.tcx(), predicates)\n+                traits::elaborate_predicates(self.tcx, predicates)\n                 .filter_map(|p| p.to_opt_poly_trait_ref())\n                 .filter(|b| b.def_id() == trait_def_id)\n             {\n@@ -811,7 +811,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx, 'tcx> {\n                        projection_trait_ref,\n                        bound);\n \n-                if self.infcx().can_equate(&step.self_ty, &bound.self_ty()).is_ok() {\n+                if self.can_equate(&step.self_ty, &bound.self_ty()).is_ok() {\n                     let xform_self_ty = self.xform_self_ty(&item,\n                                                            bound.self_ty(),\n                                                            bound.substs);\n@@ -838,8 +838,8 @@ impl<'a,'tcx> ProbeContext<'a,'tcx, 'tcx> {\n         debug!(\"assemble_where_clause_candidates(trait_def_id={:?})\",\n                trait_def_id);\n \n-        let caller_predicates = self.fcx.inh.infcx.parameter_environment.caller_bounds.clone();\n-        for poly_bound in traits::elaborate_predicates(self.tcx(), caller_predicates)\n+        let caller_predicates = self.parameter_environment.caller_bounds.clone();\n+        for poly_bound in traits::elaborate_predicates(self.tcx, caller_predicates)\n                           .filter_map(|p| p.to_opt_poly_trait_ref())\n                           .filter(|b| b.def_id() == trait_def_id)\n         {\n@@ -878,7 +878,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx, 'tcx> {\n         self.reset();\n \n         let span = self.span;\n-        let tcx = self.tcx();\n+        let tcx = self.tcx;\n \n         self.assemble_extension_candidates_for_all_traits()?;\n \n@@ -973,7 +973,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx, 'tcx> {\n                             step: &CandidateStep<'tcx>)\n                             -> Option<PickResult<'tcx>>\n     {\n-        let tcx = self.tcx();\n+        let tcx = self.tcx;\n \n         // In general, during probing we erase regions. See\n         // `impl_self_ty()` for an explanation.\n@@ -999,7 +999,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx, 'tcx> {\n     }\n \n     fn pick_method(&mut self, self_ty: Ty<'tcx>) -> Option<PickResult<'tcx>> {\n-        debug!(\"pick_method(self_ty={})\", self.infcx().ty_to_string(self_ty));\n+        debug!(\"pick_method(self_ty={})\", self.ty_to_string(self_ty));\n \n         let mut possibly_unsatisfied_predicates = Vec::new();\n \n@@ -1057,10 +1057,14 @@ impl<'a,'tcx> ProbeContext<'a,'tcx, 'tcx> {\n                self_ty,\n                probe);\n \n-        self.infcx().probe(|_| {\n+        self.probe(|_| {\n             // First check that the self type can be related.\n-            match self.make_sub_ty(self_ty, probe.xform_self_ty) {\n-                Ok(()) => { }\n+            match self.sub_types(false, TypeOrigin::Misc(DUMMY_SP),\n+                                 self_ty, probe.xform_self_ty) {\n+                Ok(InferOk { obligations, .. }) => {\n+                    // FIXME(#32730) propagate obligations\n+                    assert!(obligations.is_empty())\n+                }\n                 Err(_) => {\n                     debug!(\"--> cannot relate self-types\");\n                     return false;\n@@ -1088,12 +1092,12 @@ impl<'a,'tcx> ProbeContext<'a,'tcx, 'tcx> {\n                 }\n             };\n \n-            let selcx = &mut traits::SelectionContext::new(self.infcx());\n-            let cause = traits::ObligationCause::misc(self.span, self.fcx.body_id);\n+            let selcx = &mut traits::SelectionContext::new(self);\n+            let cause = traits::ObligationCause::misc(self.span, self.body_id);\n \n             // Check whether the impl imposes obligations we have to worry about.\n-            let impl_bounds = self.tcx().lookup_predicates(impl_def_id);\n-            let impl_bounds = impl_bounds.instantiate(self.tcx(), substs);\n+            let impl_bounds = self.tcx.lookup_predicates(impl_def_id);\n+            let impl_bounds = impl_bounds.instantiate(self.tcx, substs);\n             let traits::Normalized { value: impl_bounds,\n                                         obligations: norm_obligations } =\n                 traits::normalize(selcx, cause.clone(), &impl_bounds);\n@@ -1163,13 +1167,6 @@ impl<'a,'tcx> ProbeContext<'a,'tcx, 'tcx> {\n \n     ///////////////////////////////////////////////////////////////////////////\n     // MISCELLANY\n-\n-    fn make_sub_ty(&self, sub: Ty<'tcx>, sup: Ty<'tcx>) -> infer::UnitResult<'tcx> {\n-        self.infcx().sub_types(false, TypeOrigin::Misc(DUMMY_SP), sub, sup)\n-            // FIXME(#32730) propagate obligations\n-            .map(|InferOk { obligations, .. }| assert!(obligations.is_empty()))\n-    }\n-\n     fn has_applicable_self(&self, item: &ty::ImplOrTraitItem) -> bool {\n         // \"fast track\" -- check for usage of sugar\n         match *item {\n@@ -1249,7 +1246,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx, 'tcx> {\n \n             placeholder = (*substs).clone().with_method(Vec::new(), method_regions);\n \n-            self.infcx().type_vars_for_defs(\n+            self.type_vars_for_defs(\n                 self.span,\n                 subst::FnSpace,\n                 &mut placeholder,\n@@ -1262,7 +1259,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx, 'tcx> {\n         // in the values from the substitution.\n         let xform_self_ty = method.fty.sig.input(0);\n         let xform_self_ty = self.erase_late_bound_regions(&xform_self_ty);\n-        let xform_self_ty = xform_self_ty.subst(self.tcx(), substs);\n+        let xform_self_ty = xform_self_ty.subst(self.tcx, substs);\n \n         xform_self_ty\n     }\n@@ -1272,11 +1269,11 @@ impl<'a,'tcx> ProbeContext<'a,'tcx, 'tcx> {\n                           impl_def_id: DefId)\n                           -> (Ty<'tcx>, subst::Substs<'tcx>)\n     {\n-        let impl_pty = self.tcx().lookup_item_type(impl_def_id);\n+        let impl_pty = self.tcx.lookup_item_type(impl_def_id);\n \n         let type_vars =\n             impl_pty.generics.types.map(\n-                |_| self.infcx().next_ty_var());\n+                |_| self.next_ty_var());\n \n         let region_placeholders =\n             impl_pty.generics.regions.map(\n@@ -1307,7 +1304,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx, 'tcx> {\n     fn erase_late_bound_regions<T>(&self, value: &ty::Binder<T>) -> T\n         where T : TypeFoldable<'tcx>\n     {\n-        self.tcx().erase_late_bound_regions(value)\n+        self.tcx.erase_late_bound_regions(value)\n     }\n \n     fn impl_item(&self, impl_def_id: DefId)"}, {"sha": "897a588bb62090f28d5b63b53bf0db1d3e6ff278", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 17, "deletions": 18, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/0053b442f8cd5bf5e310a2664fc3a47a8f33da71/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0053b442f8cd5bf5e310a2664fc3a47a8f33da71/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=0053b442f8cd5bf5e310a2664fc3a47a8f33da71", "patch": "@@ -41,7 +41,7 @@ use super::probe::Mode;\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx, 'tcx> {\n fn is_fn_ty(&self, ty: &Ty<'tcx>, span: Span) -> bool {\n-    let tcx = self.tcx();\n+    let tcx = self.tcx;\n     match ty.sty {\n         // Not all of these (e.g. unsafe fns) implement FnOnce\n         // so we look for these beforehand\n@@ -50,16 +50,15 @@ fn is_fn_ty(&self, ty: &Ty<'tcx>, span: Span) -> bool {\n         _ => {\n             if let Ok(fn_once_trait_did) =\n                     tcx.lang_items.require(FnOnceTraitLangItem) {\n-                let infcx = self.infcx();\n                 let (_, _, opt_is_fn) = self.autoderef(span,\n                                                        ty,\n                                                        || None,\n                                                        UnresolvedTypeAction::Ignore,\n                                                        LvaluePreference::NoPreference,\n                                                        |ty, _| {\n-                    infcx.probe(|_| {\n+                    self.probe(|_| {\n                         let fn_once_substs =\n-                            Substs::new_trait(vec![infcx.next_ty_var()], vec![], ty);\n+                            Substs::new_trait(vec![self.next_ty_var()], vec![], ty);\n                         let trait_ref =\n                             ty::TraitRef::new(fn_once_trait_did,\n                                               tcx.mk_substs(fn_once_substs));\n@@ -68,7 +67,7 @@ fn is_fn_ty(&self, ty: &Ty<'tcx>, span: Span) -> bool {\n                                                           self.body_id,\n                                                           poly_trait_ref\n                                                              .to_predicate());\n-                        let mut selcx = SelectionContext::new(infcx);\n+                        let mut selcx = SelectionContext::new(self);\n \n                         if selcx.evaluate_obligation(&obligation) {\n                             Some(())\n@@ -111,22 +110,22 @@ pub fn report_method_error(&self,\n                     let item = self.impl_item(impl_did, item_name)\n                         .or_else(|| {\n                             self.trait_item(\n-                                self.tcx().impl_trait_ref(impl_did).unwrap().def_id,\n+                                self.tcx.impl_trait_ref(impl_did).unwrap().def_id,\n \n                                 item_name\n                             )\n                         }).unwrap();\n-                    let note_span = self.tcx().map.span_if_local(item.def_id()).or_else(|| {\n-                        self.tcx().map.span_if_local(impl_did)\n+                    let note_span = self.tcx.map.span_if_local(item.def_id()).or_else(|| {\n+                        self.tcx.map.span_if_local(impl_did)\n                     });\n \n                     let impl_ty = self.impl_self_ty(span, impl_did).ty;\n \n-                    let insertion = match self.tcx().impl_trait_ref(impl_did) {\n+                    let insertion = match self.tcx.impl_trait_ref(impl_did) {\n                         None => format!(\"\"),\n                         Some(trait_ref) => {\n                             format!(\" of the trait `{}`\",\n-                                    self.tcx().item_path_str(trait_ref.def_id))\n+                                    self.tcx.item_path_str(trait_ref.def_id))\n                         }\n                     };\n \n@@ -144,11 +143,11 @@ pub fn report_method_error(&self,\n                 }\n                 CandidateSource::TraitSource(trait_did) => {\n                     let item = self.trait_item(trait_did, item_name).unwrap();\n-                    let item_span = self.tcx().map.def_id_span(item.def_id(), span);\n+                    let item_span = self.tcx.map.def_id_span(item.def_id(), span);\n                     span_note!(err, item_span,\n                                \"candidate #{} is defined in the trait `{}`\",\n                                idx + 1,\n-                               self.tcx().item_path_str(trait_did));\n+                               self.tcx.item_path_str(trait_did));\n                 }\n             }\n         }\n@@ -159,7 +158,7 @@ pub fn report_method_error(&self,\n                                            unsatisfied_predicates,\n                                            out_of_scope_traits,\n                                            mode, .. }) => {\n-            let tcx = self.tcx();\n+            let tcx = self.tcx;\n \n             let mut err = self.type_error_struct(\n                 span,\n@@ -258,7 +257,7 @@ pub fn report_method_error(&self,\n                                invoked on this closure as we have not yet inferred what \\\n                                kind of closure it is\",\n                                item_name,\n-                               self.tcx().item_path_str(trait_def_id));\n+                               self.tcx.item_path_str(trait_def_id));\n             let msg = if let Some(callee) = rcvr_expr {\n                 format!(\"{}; use overloaded call notation instead (e.g., `{}()`)\",\n                         msg, pprust::expr_to_string(callee))\n@@ -270,7 +269,7 @@ pub fn report_method_error(&self,\n \n         MethodError::PrivateMatch(def) => {\n             let msg = format!(\"{} `{}` is private\", def.kind_name(), item_name);\n-            self.tcx().sess.span_err(span, &msg);\n+            self.tcx.sess.span_err(span, &msg);\n         }\n     }\n }\n@@ -299,7 +298,7 @@ fn suggest_traits_to_import(&self,\n         for (i, trait_did) in candidates.iter().enumerate() {\n             err.help(&format!(\"candidate #{}: `use {}`\",\n                               i + 1,\n-                              self.tcx().item_path_str(*trait_did)));\n+                              self.tcx.item_path_str(*trait_did)));\n         }\n         return\n     }\n@@ -343,7 +342,7 @@ fn suggest_traits_to_import(&self,\n         for (i, trait_info) in candidates.iter().enumerate() {\n             err.help(&format!(\"candidate #{}: `{}`\",\n                               i + 1,\n-                              self.tcx().item_path_str(trait_info.def_id)));\n+                              self.tcx.item_path_str(trait_info.def_id)));\n         }\n     }\n }\n@@ -373,7 +372,7 @@ fn type_derefs_to_local(&self,\n     // This occurs for UFCS desugaring of `T::method`, where there is no\n     // receiver expression for the method call, and thus no autoderef.\n     if rcvr_expr.is_none() {\n-        return is_local(self.resolve_type_vars_if_possible(rcvr_ty));\n+        return is_local(self.resolve_type_vars_with_obligations(rcvr_ty));\n     }\n \n     self.autoderef(span, rcvr_ty, || None,"}, {"sha": "0379fe13b1859337198617a3b2119d1cb5f800e5", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 261, "deletions": 283, "changes": 544, "blob_url": "https://github.com/rust-lang/rust/blob/0053b442f8cd5bf5e310a2664fc3a47a8f33da71/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0053b442f8cd5bf5e310a2664fc3a47a8f33da71/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=0053b442f8cd5bf5e310a2664fc3a47a8f33da71", "patch": "@@ -97,7 +97,6 @@ use rustc::ty::{LvaluePreference, NoPreference, PreferMutLvalue};\n use rustc::ty::{self, ToPolyTraitRef, Ty, TyCtxt, Visibility};\n use rustc::ty::{MethodCall, MethodCallee};\n use rustc::ty::adjustment;\n-use rustc::ty::error::TypeError;\n use rustc::ty::fold::TypeFoldable;\n use rustc::ty::util::{Representability, IntTypeExt};\n use require_c_abi_if_variadic;\n@@ -112,6 +111,7 @@ use util::nodemap::{DefIdMap, FnvHashMap, NodeMap};\n use std::cell::{Cell, Ref, RefCell};\n use std::collections::{HashSet};\n use std::mem::replace;\n+use std::ops::Deref;\n use syntax::abi::Abi;\n use syntax::ast;\n use syntax::attr;\n@@ -155,13 +155,12 @@ mod op;\n /// `bar()` will each have their own `FnCtxt`, but they will\n /// share the inherited fields.\n pub struct Inherited<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+    ccx: &'a CrateCtxt<'a, 'gcx>,\n     infcx: InferCtxt<'a, 'gcx, 'tcx>,\n     locals: RefCell<NodeMap<Ty<'tcx>>>,\n \n     fulfillment_cx: RefCell<traits::FulfillmentContext<'tcx>>,\n \n-    tables: &'a RefCell<ty::Tables<'tcx>>,\n-\n     // When we process a call like `c()` where `c` is a closure type,\n     // we may not have decided yet whether `c` is a `Fn`, `FnMut`, or\n     // `FnOnce` closure. In that case, we defer full resolution of the\n@@ -174,6 +173,13 @@ pub struct Inherited<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     deferred_cast_checks: RefCell<Vec<cast::CastCheck<'tcx>>>,\n }\n \n+impl<'a, 'gcx, 'tcx> Deref for Inherited<'a, 'gcx, 'tcx> {\n+    type Target = InferCtxt<'a, 'gcx, 'tcx>;\n+    fn deref(&self) -> &Self::Target {\n+        &self.infcx\n+    }\n+}\n+\n trait DeferredCallResolution<'tcx> {\n     fn resolve<'a>(&mut self, fcx: &FnCtxt<'a,'tcx, 'tcx>);\n }\n@@ -218,7 +224,7 @@ impl<'a, 'tcx> Expectation<'tcx> {\n     fn adjust_for_branches(&self, fcx: &FnCtxt<'a, 'tcx, 'tcx>) -> Expectation<'tcx> {\n         match *self {\n             ExpectHasType(ety) => {\n-                let ety = fcx.infcx().shallow_resolve(ety);\n+                let ety = fcx.shallow_resolve(ety);\n                 if !ety.is_ty_var() {\n                     ExpectHasType(ety)\n                 } else {\n@@ -252,7 +258,7 @@ impl<'a, 'tcx> Expectation<'tcx> {\n     /// See the test case `test/run-pass/coerce-expect-unsized.rs` and #20169\n     /// for examples of where this comes up,.\n     fn rvalue_hint(fcx: &FnCtxt<'a, 'tcx, 'tcx>, ty: Ty<'tcx>) -> Expectation<'tcx> {\n-        match fcx.tcx().struct_tail(ty).sty {\n+        match fcx.tcx.struct_tail(ty).sty {\n             ty::TySlice(_) | ty::TyStr | ty::TyTrait(..) => {\n                 ExpectRvalueLikeUnsized(ty)\n             }\n@@ -269,16 +275,13 @@ impl<'a, 'tcx> Expectation<'tcx> {\n                 NoExpectation\n             }\n             ExpectCastableToType(t) => {\n-                ExpectCastableToType(\n-                    fcx.infcx().resolve_type_vars_if_possible(&t))\n+                ExpectCastableToType(fcx.resolve_type_vars_if_possible(&t))\n             }\n             ExpectHasType(t) => {\n-                ExpectHasType(\n-                    fcx.infcx().resolve_type_vars_if_possible(&t))\n+                ExpectHasType(fcx.resolve_type_vars_if_possible(&t))\n             }\n             ExpectRvalueLikeUnsized(t) => {\n-                ExpectRvalueLikeUnsized(\n-                    fcx.infcx().resolve_type_vars_if_possible(&t))\n+                ExpectRvalueLikeUnsized(fcx.resolve_type_vars_if_possible(&t))\n             }\n         }\n     }\n@@ -360,21 +363,29 @@ pub struct FnCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     ps: RefCell<UnsafetyState>,\n \n     inh: &'a Inherited<'a, 'gcx, 'tcx>,\n+}\n \n-    ccx: &'a CrateCtxt<'a, 'gcx>,\n+impl<'a, 'gcx, 'tcx> Deref for FnCtxt<'a, 'gcx, 'tcx> {\n+    type Target = Inherited<'a, 'gcx, 'tcx>;\n+    fn deref(&self) -> &Self::Target {\n+        &self.inh\n+    }\n }\n \n impl<'a, 'tcx> Inherited<'a, 'tcx, 'tcx> {\n-    fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    fn new(ccx: &'a CrateCtxt<'a, 'tcx>,\n            tables: &'a RefCell<ty::Tables<'tcx>>,\n            param_env: ty::ParameterEnvironment<'a, 'tcx>)\n            -> Inherited<'a, 'tcx, 'tcx> {\n \n         Inherited {\n-            infcx: InferCtxt::new(tcx, tables, Some(param_env), ProjectionMode::AnyFinal),\n+            ccx: ccx,\n+            infcx: InferCtxt::new(ccx.tcx,\n+                                  tables,\n+                                  Some(param_env),\n+                                  ProjectionMode::AnyFinal),\n             fulfillment_cx: RefCell::new(traits::FulfillmentContext::new()),\n             locals: RefCell::new(NodeMap()),\n-            tables: tables,\n             deferred_call_resolutions: RefCell::new(DefIdMap()),\n             deferred_cast_checks: RefCell::new(Vec::new()),\n         }\n@@ -387,7 +398,7 @@ impl<'a, 'tcx> Inherited<'a, 'tcx, 'tcx> {\n                                         -> T\n         where T : TypeFoldable<'tcx>\n     {\n-        assoc::normalize_associated_types_in(&self.infcx,\n+        assoc::normalize_associated_types_in(self,\n                                              &mut self.fulfillment_cx.borrow_mut(),\n                                              span,\n                                              body_id,\n@@ -402,7 +413,7 @@ fn static_inherited_fields<'a, 'tcx>(ccx: &'a CrateCtxt<'a, 'tcx>,\n     // It's kind of a kludge to manufacture a fake function context\n     // and statement context, but we might as well do write the code only once\n     let param_env = ccx.tcx.empty_parameter_environment();\n-    Inherited::new(ccx.tcx, &tables, param_env)\n+    Inherited::new(ccx, &tables, param_env)\n }\n \n struct CheckItemTypesVisitor<'a, 'tcx: 'a> { ccx: &'a CrateCtxt<'a, 'tcx> }\n@@ -484,12 +495,12 @@ fn check_bare_fn<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     match raw_fty.sty {\n         ty::TyFnDef(_, _, ref fn_ty) => {\n             let tables = RefCell::new(ty::Tables::empty());\n-            let inh = Inherited::new(ccx.tcx, &tables, param_env);\n+            let inh = Inherited::new(ccx, &tables, param_env);\n \n             // Compute the fty from point of view of inside fn.\n             let fn_scope = ccx.tcx.region_maps.call_site_extent(fn_id, body.id);\n             let fn_sig =\n-                fn_ty.sig.subst(ccx.tcx, &inh.infcx.parameter_environment.free_substs);\n+                fn_ty.sig.subst(ccx.tcx, &inh.parameter_environment.free_substs);\n             let fn_sig =\n                 ccx.tcx.liberate_late_bound_regions(fn_scope, &fn_sig);\n             let fn_sig =\n@@ -522,13 +533,13 @@ impl<'a, 'tcx> GatherLocalsVisitor<'a, 'tcx, 'tcx> {\n         match ty_opt {\n             None => {\n                 // infer the variable's type\n-                let var_ty = self.fcx.infcx().next_ty_var();\n-                self.fcx.inh.locals.borrow_mut().insert(nid, var_ty);\n+                let var_ty = self.fcx.next_ty_var();\n+                self.fcx.locals.borrow_mut().insert(nid, var_ty);\n                 var_ty\n             }\n             Some(typ) => {\n                 // take type that the user specified\n-                self.fcx.inh.locals.borrow_mut().insert(nid, typ);\n+                self.fcx.locals.borrow_mut().insert(nid, typ);\n                 typ\n             }\n         }\n@@ -545,24 +556,24 @@ impl<'a, 'tcx> Visitor<'tcx> for GatherLocalsVisitor<'a, 'tcx, 'tcx> {\n         self.assign(local.span, local.id, o_ty);\n         debug!(\"Local variable {:?} is assigned type {}\",\n                local.pat,\n-               self.fcx.infcx().ty_to_string(\n-                   self.fcx.inh.locals.borrow().get(&local.id).unwrap().clone()));\n+               self.fcx.ty_to_string(\n+                   self.fcx.locals.borrow().get(&local.id).unwrap().clone()));\n         intravisit::walk_local(self, local);\n     }\n \n     // Add pattern bindings.\n     fn visit_pat(&mut self, p: &'tcx hir::Pat) {\n         if let PatKind::Ident(_, ref path1, _) = p.node {\n-            if pat_util::pat_is_binding(&self.fcx.tcx().def_map.borrow(), p) {\n+            if pat_util::pat_is_binding(&self.fcx.tcx.def_map.borrow(), p) {\n                 let var_ty = self.assign(p.span, p.id, None);\n \n                 self.fcx.require_type_is_sized(var_ty, p.span,\n                                                traits::VariableType(p.id));\n \n                 debug!(\"Pattern binding {} is assigned to {} with type {:?}\",\n                        path1.node,\n-                       self.fcx.infcx().ty_to_string(\n-                           self.fcx.inh.locals.borrow().get(&p.id).unwrap().clone()),\n+                       self.fcx.ty_to_string(\n+                           self.fcx.locals.borrow().get(&p.id).unwrap().clone()),\n                        var_ty);\n             }\n         }\n@@ -582,7 +593,7 @@ impl<'a, 'tcx> Visitor<'tcx> for GatherLocalsVisitor<'a, 'tcx, 'tcx> {\n         match t.node {\n             hir::TyFixedLengthVec(ref ty, ref count_expr) => {\n                 self.visit_ty(&ty);\n-                self.fcx.check_expr_with_hint(&count_expr, self.fcx.tcx().types.usize);\n+                self.fcx.check_expr_with_hint(&count_expr, self.fcx.tcx.types.usize);\n             }\n             hir::TyBareFn(ref function_declaration) => {\n                 intravisit::walk_fn_decl_nopat(self, &function_declaration.decl);\n@@ -625,7 +636,7 @@ fn check_fn<'a, 'tcx>(ccx: &'a CrateCtxt<'a, 'tcx>,\n \n     // Create the function context.  This is either derived from scratch or,\n     // in the case of function expressions, based on the outer context.\n-    let fcx = FnCtxt::new(ccx, inherited, ret_ty, body.id);\n+    let fcx = FnCtxt::new(inherited, ret_ty, body.id);\n     *fcx.ps.borrow_mut() = UnsafetyState::function(unsafety, unsafety_id);\n \n     if let ty::FnConverging(ret_ty) = ret_ty {\n@@ -1126,7 +1137,7 @@ fn check_const_in_type<'a,'tcx>(ccx: &'a CrateCtxt<'a,'tcx>,\n                                 expected_type: Ty<'tcx>) {\n     let tables = RefCell::new(ty::Tables::empty());\n     let inh = static_inherited_fields(ccx, &tables);\n-    let fcx = FnCtxt::new(ccx, &inh, ty::FnConverging(expected_type), expr.id);\n+    let fcx = FnCtxt::new(&inh, ty::FnConverging(expected_type), expr.id);\n     fcx.check_const_with_ty(expr.span, expr, expected_type);\n }\n \n@@ -1137,8 +1148,8 @@ fn check_const<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n     let tables = RefCell::new(ty::Tables::empty());\n     let inh = static_inherited_fields(ccx, &tables);\n     let rty = ccx.tcx.node_id_to_type(id);\n-    let fcx = FnCtxt::new(ccx, &inh, ty::FnConverging(rty), e.id);\n-    let declty = fcx.tcx().lookup_item_type(ccx.tcx.map.local_def_id(id)).ty;\n+    let fcx = FnCtxt::new(&inh, ty::FnConverging(rty), e.id);\n+    let declty = fcx.tcx.lookup_item_type(ccx.tcx.map.local_def_id(id)).ty;\n     fcx.check_const_with_ty(sp, e, declty);\n }\n \n@@ -1210,7 +1221,7 @@ pub fn check_enum_variants<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n \n         let tables = RefCell::new(ty::Tables::empty());\n         let inh = static_inherited_fields(ccx, &tables);\n-        let fcx = FnCtxt::new(ccx, &inh, ty::FnConverging(rty), id);\n+        let fcx = FnCtxt::new(&inh, ty::FnConverging(rty), id);\n \n         let repr_type_ty = ccx.tcx.enum_repr_type(Some(&hint)).to_ty(ccx.tcx);\n         for v in vs {\n@@ -1255,7 +1266,7 @@ pub fn check_enum_variants<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n }\n \n impl<'a, 'tcx> AstConv<'tcx, 'tcx> for FnCtxt<'a, 'tcx, 'tcx> {\n-    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'tcx, 'tcx> { self.infcx().tcx }\n+    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'tcx, 'tcx> { self.tcx }\n \n     fn get_item_type_scheme(&self, _: Span, id: DefId)\n                             -> Result<ty::TypeScheme<'tcx>, ErrorReported>\n@@ -1275,16 +1286,16 @@ impl<'a, 'tcx> AstConv<'tcx, 'tcx> for FnCtxt<'a, 'tcx, 'tcx> {\n     }\n \n     fn get_free_substs(&self) -> Option<&Substs<'tcx>> {\n-        Some(&self.inh.infcx.parameter_environment.free_substs)\n+        Some(&self.parameter_environment.free_substs)\n     }\n \n     fn get_type_parameter_bounds(&self,\n                                  _: Span,\n                                  node_id: ast::NodeId)\n                                  -> Result<Vec<ty::PolyTraitRef<'tcx>>, ErrorReported>\n     {\n-        let def = self.tcx().type_parameter_def(node_id);\n-        let r = self.inh.infcx.parameter_environment\n+        let def = self.tcx.type_parameter_def(node_id);\n+        let r = self.parameter_environment\n                                   .caller_bounds\n                                   .iter()\n                                   .filter_map(|predicate| {\n@@ -1328,7 +1339,7 @@ impl<'a, 'tcx> AstConv<'tcx, 'tcx> for FnCtxt<'a, 'tcx, 'tcx> {\n             })\n         });\n \n-        let ty_var = self.infcx().next_ty_var_with_default(default);\n+        let ty_var = self.next_ty_var_with_default(default);\n \n         // Finally we add the type variable to the substs\n         match substs {\n@@ -1344,7 +1355,7 @@ impl<'a, 'tcx> AstConv<'tcx, 'tcx> for FnCtxt<'a, 'tcx, 'tcx> {\n                                         -> Ty<'tcx>\n     {\n         let (trait_ref, _) =\n-            self.infcx().replace_late_bound_regions_with_fresh_var(\n+            self.replace_late_bound_regions_with_fresh_var(\n                 span,\n                 infer::LateBoundRegionConversionTime::AssocTypeProjection(item_name),\n                 &poly_trait_ref);\n@@ -1362,7 +1373,7 @@ impl<'a, 'tcx> AstConv<'tcx, 'tcx> for FnCtxt<'a, 'tcx, 'tcx> {\n     }\n \n     fn set_tainted_by_errors(&self) {\n-        self.infcx().set_tainted_by_errors()\n+        self.infcx.set_tainted_by_errors()\n     }\n }\n \n@@ -1379,13 +1390,13 @@ impl<'a, 'tcx> RegionScope for FnCtxt<'a, 'tcx, 'tcx> {\n         // (and anyway, within a fn body the right region may not even\n         // be something the user can write explicitly, since it might\n         // be some expression).\n-        self.infcx().next_region_var(infer::MiscVariable(span))\n+        self.next_region_var(infer::MiscVariable(span))\n     }\n \n     fn anon_regions(&self, span: Span, count: usize)\n                     -> Result<Vec<ty::Region>, Option<Vec<ElisionFailureInfo>>> {\n         Ok((0..count).map(|_| {\n-            self.infcx().next_region_var(infer::MiscVariable(span))\n+            self.next_region_var(infer::MiscVariable(span))\n         }).collect())\n     }\n }\n@@ -1424,56 +1435,49 @@ enum TupleArgumentsFlag {\n }\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx, 'tcx> {\n-    pub fn new(ccx: &'a CrateCtxt<'a, 'tcx>,\n-               inh: &'a Inherited<'a, 'tcx, 'tcx>,\n+    pub fn new(inh: &'a Inherited<'a, 'tcx, 'tcx>,\n                rty: ty::FnOutput<'tcx>,\n                body_id: ast::NodeId)\n                -> FnCtxt<'a, 'tcx, 'tcx> {\n         FnCtxt {\n             body_id: body_id,\n             writeback_errors: Cell::new(false),\n-            err_count_on_creation: ccx.tcx.sess.err_count(),\n+            err_count_on_creation: inh.tcx.sess.err_count(),\n             ret_ty: rty,\n             ps: RefCell::new(UnsafetyState::function(hir::Unsafety::Normal, 0)),\n             inh: inh,\n-            ccx: ccx\n         }\n     }\n \n-    pub fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx> { self.infcx().tcx }\n-\n-    pub fn infcx(&self) -> &InferCtxt<'a,'tcx, 'tcx> {\n-        &self.inh.infcx\n-    }\n-\n     pub fn param_env(&self) -> &ty::ParameterEnvironment<'a,'tcx> {\n-        &self.inh.infcx.parameter_environment\n+        &self.parameter_environment\n     }\n \n     pub fn sess(&self) -> &Session {\n-        &self.tcx().sess\n+        &self.tcx.sess\n     }\n \n     pub fn err_count_since_creation(&self) -> usize {\n-        self.tcx().sess.err_count() - self.err_count_on_creation\n+        self.tcx.sess.err_count() - self.err_count_on_creation\n     }\n \n     /// Resolves type variables in `ty` if possible. Unlike the infcx\n-    /// version, this version will also select obligations if it seems\n-    /// useful, in an effort to get more type information.\n-    fn resolve_type_vars_if_possible(&self, mut ty: Ty<'tcx>) -> Ty<'tcx> {\n-        debug!(\"resolve_type_vars_if_possible(ty={:?})\", ty);\n+    /// version (resolve_type_vars_if_possible), this version will\n+    /// also select obligations if it seems useful, in an effort\n+    /// to get more type information.\n+    fn resolve_type_vars_with_obligations(&self, mut ty: Ty<'tcx>) -> Ty<'tcx> {\n+        debug!(\"resolve_type_vars_with_obligations(ty={:?})\", ty);\n \n         // No TyInfer()? Nothing needs doing.\n         if !ty.has_infer_types() {\n-            debug!(\"resolve_type_vars_if_possible: ty={:?}\", ty);\n+            debug!(\"resolve_type_vars_with_obligations: ty={:?}\", ty);\n             return ty;\n         }\n \n         // If `ty` is a type variable, see whether we already know what it is.\n-        ty = self.infcx().resolve_type_vars_if_possible(&ty);\n+        ty = self.resolve_type_vars_if_possible(&ty);\n         if !ty.has_infer_types() {\n-            debug!(\"resolve_type_vars_if_possible: ty={:?}\", ty);\n+            debug!(\"resolve_type_vars_with_obligations: ty={:?}\", ty);\n             return ty;\n         }\n \n@@ -1482,24 +1486,24 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx, 'tcx> {\n         // indirect dependencies that don't seem worth tracking\n         // precisely.\n         self.select_obligations_where_possible();\n-        ty = self.infcx().resolve_type_vars_if_possible(&ty);\n+        ty = self.resolve_type_vars_if_possible(&ty);\n \n-        debug!(\"resolve_type_vars_if_possible: ty={:?}\", ty);\n+        debug!(\"resolve_type_vars_with_obligations: ty={:?}\", ty);\n         ty\n     }\n \n     fn record_deferred_call_resolution(&self,\n                                        closure_def_id: DefId,\n                                        r: DeferredCallResolutionHandler<'tcx>) {\n-        let mut deferred_call_resolutions = self.inh.deferred_call_resolutions.borrow_mut();\n+        let mut deferred_call_resolutions = self.deferred_call_resolutions.borrow_mut();\n         deferred_call_resolutions.entry(closure_def_id).or_insert(vec![]).push(r);\n     }\n \n     fn remove_deferred_call_resolutions(&self,\n                                         closure_def_id: DefId)\n                                         -> Vec<DeferredCallResolutionHandler<'tcx>>\n     {\n-        let mut deferred_call_resolutions = self.inh.deferred_call_resolutions.borrow_mut();\n+        let mut deferred_call_resolutions = self.deferred_call_resolutions.borrow_mut();\n         deferred_call_resolutions.remove(&closure_def_id).unwrap_or(Vec::new())\n     }\n \n@@ -1509,13 +1513,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx, 'tcx> {\n     }\n \n     pub fn local_ty(&self, span: Span, nid: ast::NodeId) -> Ty<'tcx> {\n-        match self.inh.locals.borrow().get(&nid) {\n+        match self.locals.borrow().get(&nid) {\n             Some(&t) => t,\n             None => {\n-                span_err!(self.tcx().sess, span, E0513,\n+                span_err!(self.tcx.sess, span, E0513,\n                           \"no type for local variable {}\",\n                           nid);\n-                self.tcx().types.err\n+                self.tcx.types.err\n             }\n         }\n     }\n@@ -1524,7 +1528,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx, 'tcx> {\n     pub fn write_ty(&self, node_id: ast::NodeId, ty: Ty<'tcx>) {\n         debug!(\"write_ty({}, {:?}) in fcx {}\",\n                node_id, ty, self.tag());\n-        self.inh.tables.borrow_mut().node_types.insert(node_id, ty);\n+        self.tables.borrow_mut().node_types.insert(node_id, ty);\n     }\n \n     pub fn write_substs(&self, node_id: ast::NodeId, substs: ty::ItemSubsts<'tcx>) {\n@@ -1534,7 +1538,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx, 'tcx> {\n                    substs,\n                    self.tag());\n \n-            self.inh.tables.borrow_mut().item_substs.insert(node_id, substs);\n+            self.tables.borrow_mut().item_substs.insert(node_id, substs);\n         }\n     }\n \n@@ -1560,7 +1564,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx, 'tcx> {\n             return;\n         }\n \n-        self.inh.tables.borrow_mut().adjustments.insert(node_id, adj);\n+        self.tables.borrow_mut().adjustments.insert(node_id, adj);\n     }\n \n     /// Basically whenever we are converting from a type scheme into\n@@ -1573,7 +1577,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx, 'tcx> {\n                                   -> T\n         where T : TypeFoldable<'tcx>\n     {\n-        let value = value.subst(self.tcx(), substs);\n+        let value = value.subst(self.tcx, substs);\n         let result = self.normalize_associated_types_in(span, &value);\n         debug!(\"instantiate_type_scheme(value={:?}, substs={:?}) = {:?}\",\n                value,\n@@ -1611,10 +1615,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx, 'tcx> {\n         let cause = traits::ObligationCause::new(span,\n                                                  self.body_id,\n                                                  traits::ObligationCauseCode::MiscObligation);\n-        self.inh\n-            .fulfillment_cx\n+        self.fulfillment_cx\n             .borrow_mut()\n-            .normalize_projection_type(self.infcx(),\n+            .normalize_projection_type(self,\n                                        ty::ProjectionTy {\n                                            trait_ref: trait_ref,\n                                            item_name: item_name,\n@@ -1634,9 +1637,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx, 'tcx> {\n     {\n         debug!(\"instantiate_type(did={:?}, path={:?})\", did, path);\n         let type_scheme =\n-            self.tcx().lookup_item_type(did);\n+            self.tcx.lookup_item_type(did);\n         let type_predicates =\n-            self.tcx().lookup_predicates(did);\n+            self.tcx.lookup_predicates(did);\n         let substs = astconv::ast_path_substs_for_ty(self, self,\n                                                      path.span,\n                                                      PathParamMode::Optional,\n@@ -1663,11 +1666,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx, 'tcx> {\n     {\n         let (adt, variant) = match def {\n             Def::Variant(enum_id, variant_id) => {\n-                let adt = self.tcx().lookup_adt_def(enum_id);\n+                let adt = self.tcx.lookup_adt_def(enum_id);\n                 (adt, adt.variant_with_id(variant_id))\n             }\n             Def::Struct(did) | Def::TyAlias(did) => {\n-                let typ = self.tcx().lookup_item_type(did);\n+                let typ = self.tcx.lookup_item_type(did);\n                 if let ty::TyStruct(adt, _) = typ.ty.sty {\n                     (adt, adt.struct_variant())\n                 } else {\n@@ -1688,10 +1691,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx, 'tcx> {\n     }\n \n     pub fn write_nil(&self, node_id: ast::NodeId) {\n-        self.write_ty(node_id, self.tcx().mk_nil());\n+        self.write_ty(node_id, self.tcx.mk_nil());\n     }\n     pub fn write_error(&self, node_id: ast::NodeId) {\n-        self.write_ty(node_id, self.tcx().types.err);\n+        self.write_ty(node_id, self.tcx.types.err);\n     }\n \n     pub fn require_type_meets(&self,\n@@ -1726,18 +1729,18 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx, 'tcx> {\n                                   builtin_bound: ty::BuiltinBound,\n                                   cause: traits::ObligationCause<'tcx>)\n     {\n-        self.inh.fulfillment_cx.borrow_mut()\n-            .register_builtin_bound(self.infcx(), ty, builtin_bound, cause);\n+        self.fulfillment_cx.borrow_mut()\n+            .register_builtin_bound(self, ty, builtin_bound, cause);\n     }\n \n     pub fn register_predicate(&self,\n                               obligation: traits::PredicateObligation<'tcx>)\n     {\n         debug!(\"register_predicate({:?})\",\n                obligation);\n-        self.inh.fulfillment_cx\n+        self.fulfillment_cx\n             .borrow_mut()\n-            .register_predicate_obligation(self.infcx(), obligation);\n+            .register_predicate_obligation(self, obligation);\n     }\n \n     pub fn to_ty(&self, ast_t: &hir::Ty) -> Ty<'tcx> {\n@@ -1747,7 +1750,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx, 'tcx> {\n     }\n \n     pub fn expr_ty(&self, ex: &hir::Expr) -> Ty<'tcx> {\n-        match self.inh.tables.borrow().node_types.get(&ex.id) {\n+        match self.tables.borrow().node_types.get(&ex.id) {\n             Some(&t) => t,\n             None => {\n                 bug!(\"no type for expr in fcx {}\", self.tag());\n@@ -1762,21 +1765,21 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx, 'tcx> {\n                           -> Ty<'tcx>\n     {\n         let raw_ty = self.expr_ty(expr);\n-        let raw_ty = self.infcx().shallow_resolve(raw_ty);\n-        let resolve_ty = |ty: Ty<'tcx>| self.infcx().resolve_type_vars_if_possible(&ty);\n-        raw_ty.adjust(self.tcx(), expr.span, expr.id, adjustment, |method_call| {\n-            self.inh.tables.borrow().method_map.get(&method_call)\n+        let raw_ty = self.shallow_resolve(raw_ty);\n+        let resolve_ty = |ty: Ty<'tcx>| self.resolve_type_vars_if_possible(&ty);\n+        raw_ty.adjust(self.tcx, expr.span, expr.id, adjustment, |method_call| {\n+            self.tables.borrow().method_map.get(&method_call)\n                                         .map(|method| resolve_ty(method.ty))\n         })\n     }\n \n     pub fn node_ty(&self, id: ast::NodeId) -> Ty<'tcx> {\n-        match self.inh.tables.borrow().node_types.get(&id) {\n+        match self.tables.borrow().node_types.get(&id) {\n             Some(&t) => t,\n-            None if self.err_count_since_creation() != 0 => self.tcx().types.err,\n+            None if self.err_count_since_creation() != 0 => self.tcx.types.err,\n             None => {\n                 bug!(\"no type for node {}: {} in fcx {}\",\n-                     id, self.tcx().map.node_to_string(id),\n+                     id, self.tcx.map.node_to_string(id),\n                      self.tag());\n             }\n         }\n@@ -1790,49 +1793,28 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx, 'tcx> {\n             &tables.item_substs\n         }\n \n-        Ref::map(self.inh.tables.borrow(), project_item_susbts)\n+        Ref::map(self.tables.borrow(), project_item_susbts)\n     }\n \n     pub fn opt_node_ty_substs<F>(&self,\n                                  id: ast::NodeId,\n                                  f: F) where\n         F: FnOnce(&ty::ItemSubsts<'tcx>),\n     {\n-        match self.inh.tables.borrow().item_substs.get(&id) {\n+        match self.tables.borrow().item_substs.get(&id) {\n             Some(s) => { f(s) }\n             None => { }\n         }\n     }\n \n-    pub fn type_error_message<M>(&self,\n-                                 sp: Span,\n-                                 mk_msg: M,\n-                                 actual_ty: Ty<'tcx>,\n-                                 err: Option<&TypeError<'tcx>>)\n-        where M: FnOnce(String) -> String,\n-    {\n-        self.infcx().type_error_message(sp, mk_msg, actual_ty, err);\n-    }\n-\n-    pub fn type_error_struct<M>(&self,\n-                                sp: Span,\n-                                mk_msg: M,\n-                                actual_ty: Ty<'tcx>,\n-                                err: Option<&TypeError<'tcx>>)\n-                                -> DiagnosticBuilder<'tcx>\n-        where M: FnOnce(String) -> String,\n-    {\n-        self.infcx().type_error_struct(sp, mk_msg, actual_ty, err)\n-    }\n-\n     /// Registers an obligation for checking later, during regionck, that the type `ty` must\n     /// outlive the region `r`.\n     pub fn register_region_obligation(&self,\n                                       ty: Ty<'tcx>,\n                                       region: ty::Region,\n                                       cause: traits::ObligationCause<'tcx>)\n     {\n-        let mut fulfillment_cx = self.inh.fulfillment_cx.borrow_mut();\n+        let mut fulfillment_cx = self.fulfillment_cx.borrow_mut();\n         fulfillment_cx.register_region_obligation(ty, region, cause);\n     }\n \n@@ -1913,11 +1895,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx, 'tcx> {\n                     -> Ty<'tcx>\n     {\n         self.normalize_associated_types_in(span,\n-                                           &field.ty(self.tcx(), substs))\n+                                           &field.ty(self.tcx, substs))\n     }\n \n     fn check_casts(&self) {\n-        let mut deferred_cast_checks = self.inh.deferred_cast_checks.borrow_mut();\n+        let mut deferred_cast_checks = self.deferred_cast_checks.borrow_mut();\n         for cast in deferred_cast_checks.drain(..) {\n             cast.check(self);\n         }\n@@ -1933,33 +1915,33 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx, 'tcx> {\n         // encountered type-checking errors. Therefore, if we think we saw\n         // some errors in this function, just resolve all uninstanted type\n         // varibles to TyError.\n-        if self.infcx().is_tainted_by_errors() {\n-            for ty in &self.infcx().unsolved_variables() {\n-                if let ty::TyInfer(_) = self.infcx().shallow_resolve(ty).sty {\n+        if self.is_tainted_by_errors() {\n+            for ty in &self.unsolved_variables() {\n+                if let ty::TyInfer(_) = self.shallow_resolve(ty).sty {\n                     debug!(\"default_type_parameters: defaulting `{:?}` to error\", ty);\n                     self.demand_eqtype(codemap::DUMMY_SP, *ty, self.tcx().types.err);\n                 }\n             }\n             return;\n         }\n \n-        for ty in &self.infcx().unsolved_variables() {\n-            let resolved = self.infcx().resolve_type_vars_if_possible(ty);\n-            if self.infcx().type_var_diverges(resolved) {\n+        for ty in &self.unsolved_variables() {\n+            let resolved = self.resolve_type_vars_if_possible(ty);\n+            if self.type_var_diverges(resolved) {\n                 debug!(\"default_type_parameters: defaulting `{:?}` to `()` because it diverges\",\n                        resolved);\n-                self.demand_eqtype(codemap::DUMMY_SP, *ty, self.tcx().mk_nil());\n+                self.demand_eqtype(codemap::DUMMY_SP, *ty, self.tcx.mk_nil());\n             } else {\n-                match self.infcx().type_is_unconstrained_numeric(resolved) {\n+                match self.type_is_unconstrained_numeric(resolved) {\n                     UnconstrainedInt => {\n                         debug!(\"default_type_parameters: defaulting `{:?}` to `i32`\",\n                                resolved);\n-                        self.demand_eqtype(codemap::DUMMY_SP, *ty, self.tcx().types.i32)\n+                        self.demand_eqtype(codemap::DUMMY_SP, *ty, self.tcx.types.i32)\n                     },\n                     UnconstrainedFloat => {\n                         debug!(\"default_type_parameters: defaulting `{:?}` to `f32`\",\n                                resolved);\n-                        self.demand_eqtype(codemap::DUMMY_SP, *ty, self.tcx().types.f64)\n+                        self.demand_eqtype(codemap::DUMMY_SP, *ty, self.tcx.types.f64)\n                     }\n                     Neither => { }\n                 }\n@@ -1968,7 +1950,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx, 'tcx> {\n     }\n \n     fn select_all_obligations_and_apply_defaults(&self) {\n-        if self.tcx().sess.features.borrow().default_type_parameter_fallback {\n+        if self.tcx.sess.features.borrow().default_type_parameter_fallback {\n             self.new_select_all_obligations_and_apply_defaults();\n         } else {\n             self.old_select_all_obligations_and_apply_defaults();\n@@ -1988,27 +1970,27 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx, 'tcx> {\n \n         // For the time being this errs on the side of being memory wasteful but provides better\n         // error reporting.\n-        // let type_variables = self.infcx().type_variables.clone();\n+        // let type_variables = self.type_variables.clone();\n \n         // There is a possibility that this algorithm will have to run an arbitrary number of times\n         // to terminate so we bound it by the compiler's recursion limit.\n-        for _ in 0..self.tcx().sess.recursion_limit.get() {\n+        for _ in 0..self.tcx.sess.recursion_limit.get() {\n             // First we try to solve all obligations, it is possible that the last iteration\n             // has made it possible to make more progress.\n             self.select_obligations_where_possible();\n \n             let mut conflicts = Vec::new();\n \n             // Collect all unsolved type, integral and floating point variables.\n-            let unsolved_variables = self.inh.infcx.unsolved_variables();\n+            let unsolved_variables = self.unsolved_variables();\n \n             // We must collect the defaults *before* we do any unification. Because we have\n             // directly attached defaults to the type variables any unification that occurs\n             // will erase defaults causing conflicting defaults to be completely ignored.\n             let default_map: FnvHashMap<_, _> =\n                 unsolved_variables\n                     .iter()\n-                    .filter_map(|t| self.infcx().default(t).map(|d| (t, d)))\n+                    .filter_map(|t| self.default(t).map(|d| (t, d)))\n                     .collect();\n \n             let mut unbound_tyvars = HashSet::new();\n@@ -2020,11 +2002,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx, 'tcx> {\n             // variables. We do this so we only apply literal fallback to type\n             // variables without defaults.\n             for ty in &unsolved_variables {\n-                let resolved = self.infcx().resolve_type_vars_if_possible(ty);\n-                if self.infcx().type_var_diverges(resolved) {\n-                    self.demand_eqtype(codemap::DUMMY_SP, *ty, self.tcx().mk_nil());\n+                let resolved = self.resolve_type_vars_if_possible(ty);\n+                if self.type_var_diverges(resolved) {\n+                    self.demand_eqtype(codemap::DUMMY_SP, *ty, self.tcx.mk_nil());\n                 } else {\n-                    match self.infcx().type_is_unconstrained_numeric(resolved) {\n+                    match self.type_is_unconstrained_numeric(resolved) {\n                         UnconstrainedInt | UnconstrainedFloat => {\n                             unbound_tyvars.insert(resolved);\n                         },\n@@ -2037,7 +2019,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx, 'tcx> {\n             // the type variable with a defined fallback.\n             for ty in &unsolved_variables {\n                 if let Some(_default) = default_map.get(ty) {\n-                    let resolved = self.infcx().resolve_type_vars_if_possible(ty);\n+                    let resolved = self.resolve_type_vars_if_possible(ty);\n \n                     debug!(\"select_all_obligations_and_apply_defaults: ty: {:?} with default: {:?}\",\n                              ty, _default);\n@@ -2076,22 +2058,22 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx, 'tcx> {\n             // for conflicts and correctly report them.\n \n \n-            let _ = self.infcx().commit_if_ok(|_: &infer::CombinedSnapshot| {\n+            let _ = self.commit_if_ok(|_: &infer::CombinedSnapshot| {\n                 for ty in &unbound_tyvars {\n-                    if self.infcx().type_var_diverges(ty) {\n-                        self.demand_eqtype(codemap::DUMMY_SP, *ty, self.tcx().mk_nil());\n+                    if self.type_var_diverges(ty) {\n+                        self.demand_eqtype(codemap::DUMMY_SP, *ty, self.tcx.mk_nil());\n                     } else {\n-                        match self.infcx().type_is_unconstrained_numeric(ty) {\n+                        match self.type_is_unconstrained_numeric(ty) {\n                             UnconstrainedInt => {\n-                                self.demand_eqtype(codemap::DUMMY_SP, *ty, self.tcx().types.i32)\n+                                self.demand_eqtype(codemap::DUMMY_SP, *ty, self.tcx.types.i32)\n                             },\n                             UnconstrainedFloat => {\n-                                self.demand_eqtype(codemap::DUMMY_SP, *ty, self.tcx().types.f64)\n+                                self.demand_eqtype(codemap::DUMMY_SP, *ty, self.tcx.types.f64)\n                             }\n                             Neither => {\n                                 if let Some(default) = default_map.get(ty) {\n                                     let default = default.clone();\n-                                    match self.infcx().eq_types(false,\n+                                    match self.eq_types(false,\n                                             TypeOrigin::Misc(default.origin_span),\n                                             ty, default.ty) {\n                                         Ok(InferOk { obligations, .. }) => {\n@@ -2123,9 +2105,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx, 'tcx> {\n                     let conflicting_default =\n                         self.find_conflicting_default(&unbound_tyvars, &default_map, conflict)\n                             .unwrap_or(type_variable::Default {\n-                                ty: self.infcx().next_ty_var(),\n+                                ty: self.next_ty_var(),\n                                 origin_span: codemap::DUMMY_SP,\n-                                def_id: self.tcx().map.local_def_id(0) // what do I put here?\n+                                def_id: self.tcx.map.local_def_id(0) // what do I put here?\n                             });\n \n                     // This is to ensure that we elimnate any non-determinism from the error\n@@ -2139,7 +2121,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx, 'tcx> {\n                         };\n \n \n-                    self.infcx().report_conflicting_default_types(\n+                    self.report_conflicting_default_types(\n                         first_default.origin_span,\n                         first_default,\n                         second_default)\n@@ -2174,20 +2156,20 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx, 'tcx> {\n         // We also run this inside snapshot that never commits so we can do error\n         // reporting for more then one conflict.\n         for ty in &unbound_tyvars {\n-            if self.infcx().type_var_diverges(ty) {\n-                self.demand_eqtype(codemap::DUMMY_SP, *ty, self.tcx().mk_nil());\n+            if self.type_var_diverges(ty) {\n+                self.demand_eqtype(codemap::DUMMY_SP, *ty, self.tcx.mk_nil());\n             } else {\n-                match self.infcx().type_is_unconstrained_numeric(ty) {\n+                match self.type_is_unconstrained_numeric(ty) {\n                     UnconstrainedInt => {\n-                        self.demand_eqtype(codemap::DUMMY_SP, *ty, self.tcx().types.i32)\n+                        self.demand_eqtype(codemap::DUMMY_SP, *ty, self.tcx.types.i32)\n                     },\n                     UnconstrainedFloat => {\n-                        self.demand_eqtype(codemap::DUMMY_SP, *ty, self.tcx().types.f64)\n+                        self.demand_eqtype(codemap::DUMMY_SP, *ty, self.tcx.types.f64)\n                     },\n                     Neither => {\n                         if let Some(default) = default_map.get(ty) {\n                             let default = default.clone();\n-                            match self.infcx().eq_types(false,\n+                            match self.eq_types(false,\n                                     TypeOrigin::Misc(default.origin_span),\n                                     ty, default.ty) {\n                                 // FIXME(#32730) propagate obligations\n@@ -2210,30 +2192,26 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx, 'tcx> {\n \n         // upvar inference should have ensured that all deferred call\n         // resolutions are handled by now.\n-        assert!(self.inh.deferred_call_resolutions.borrow().is_empty());\n+        assert!(self.deferred_call_resolutions.borrow().is_empty());\n \n         self.select_all_obligations_and_apply_defaults();\n \n-        let mut fulfillment_cx = self.inh.fulfillment_cx.borrow_mut();\n-        match fulfillment_cx.select_all_or_error(self.infcx()) {\n+        let mut fulfillment_cx = self.fulfillment_cx.borrow_mut();\n+        match fulfillment_cx.select_all_or_error(self) {\n             Ok(()) => { }\n-            Err(errors) => { self.infcx().report_fulfillment_errors(&errors); }\n+            Err(errors) => { self.report_fulfillment_errors(&errors); }\n         }\n \n-        if let Err(ref errors) = fulfillment_cx.select_rfc1592_obligations(self.infcx()) {\n-            self.infcx().report_fulfillment_errors_as_warnings(errors, self.body_id);\n+        if let Err(ref errors) = fulfillment_cx.select_rfc1592_obligations(self) {\n+            self.report_fulfillment_errors_as_warnings(errors, self.body_id);\n         }\n     }\n \n     /// Select as many obligations as we can at present.\n     fn select_obligations_where_possible(&self) {\n-        match\n-            self.inh.fulfillment_cx\n-            .borrow_mut()\n-            .select_where_possible(self.infcx())\n-        {\n+        match self.fulfillment_cx.borrow_mut().select_where_possible(self) {\n             Ok(()) => { }\n-            Err(errors) => { self.infcx().report_fulfillment_errors(&errors); }\n+            Err(errors) => { self.report_fulfillment_errors(&errors); }\n         }\n     }\n \n@@ -2259,7 +2237,7 @@ pub fn autoderef<'b, E, I, T, F>(&self,\n            base_ty, lvalue_pref);\n \n     let mut t = base_ty;\n-    for autoderefs in 0..self.tcx().sess.recursion_limit.get() {\n+    for autoderefs in 0..self.tcx.sess.recursion_limit.get() {\n         let resolved_t = match unresolved_type_action {\n             UnresolvedTypeAction::Error => {\n                 self.structurally_resolved_type(sp, t)\n@@ -2269,7 +2247,7 @@ pub fn autoderef<'b, E, I, T, F>(&self,\n                 // (i.e. it is an inference variable) because `Ty::builtin_deref`\n                 // and `try_overloaded_deref` both simply return `None`\n                 // in such a case without producing spurious errors.\n-                self.infcx().resolve_type_vars_if_possible(&t)\n+                self.resolve_type_vars_if_possible(&t)\n             }\n         };\n         if resolved_t.references_error() {\n@@ -2300,7 +2278,7 @@ pub fn autoderef<'b, E, I, T, F>(&self,\n                                                                resolved_t, lvalue_pref) {\n             for expr in maybe_exprs() {\n                 let method_call = MethodCall::autoderef(expr.id, autoderefs as u32);\n-                self.inh.tables.borrow_mut().method_map.insert(method_call, method);\n+                self.tables.borrow_mut().method_map.insert(method_call, method);\n             }\n             self.make_overloaded_lvalue_return_type(method)\n         } else {\n@@ -2314,10 +2292,10 @@ pub fn autoderef<'b, E, I, T, F>(&self,\n     }\n \n     // We've reached the recursion limit, error gracefully.\n-    span_err!(self.tcx().sess, sp, E0055,\n+    span_err!(self.tcx.sess, sp, E0055,\n         \"reached the recursion limit while auto-dereferencing {:?}\",\n         base_ty);\n-    (self.tcx().types.err, 0, None)\n+    (self.tcx.types.err, 0, None)\n }\n \n fn try_overloaded_deref(&self,\n@@ -2328,7 +2306,7 @@ fn try_overloaded_deref(&self,\n                         -> Option<MethodCallee<'tcx>>\n {\n     // Try DerefMut first, if preferred.\n-    let method = match (lvalue_pref, self.tcx().lang_items.deref_mut_trait()) {\n+    let method = match (lvalue_pref, self.tcx.lang_items.deref_mut_trait()) {\n         (PreferMutLvalue, Some(trait_did)) => {\n             self.lookup_method_in_trait(span, base_expr,\n                                         token::intern(\"deref_mut\"), trait_did,\n@@ -2338,7 +2316,7 @@ fn try_overloaded_deref(&self,\n     };\n \n     // Otherwise, fall back to Deref.\n-    let method = match (method, self.tcx().lang_items.deref_trait()) {\n+    let method = match (method, self.tcx.lang_items.deref_trait()) {\n         (None, Some(trait_did)) => {\n             self.lookup_method_in_trait(span, base_expr,\n                                         token::intern(\"deref\"), trait_did,\n@@ -2360,7 +2338,7 @@ fn make_overloaded_lvalue_return_type(&self,\n     // extract method return type, which will be &T;\n     // all LB regions should have been instantiated during method lookup\n     let ret_ty = method.ty.fn_ret();\n-    let ret_ty = self.tcx().no_late_bound_regions(&ret_ty).unwrap().unwrap();\n+    let ret_ty = self.tcx.no_late_bound_regions(&ret_ty).unwrap().unwrap();\n \n     // method returns &T, but the type as visible to user is T, so deref\n     ret_ty.builtin_deref(true, NoPreference).unwrap()\n@@ -2395,7 +2373,7 @@ fn lookup_indexing(&self,\n     // After we have fully autoderef'd, if the resulting type is [T; n], then\n     // do a final unsized coercion to yield [T].\n     if let ty::TyArray(element_ty, _) = ty.sty {\n-        let adjusted_ty = self.tcx().mk_slice(element_ty);\n+        let adjusted_ty = self.tcx.mk_slice(element_ty);\n         self.try_index_step(MethodCall::expr(expr.id), expr, base_expr,\n                             adjusted_ty, autoderefs, true, lvalue_pref, idx_ty)\n     } else {\n@@ -2418,7 +2396,7 @@ fn try_index_step(&self,\n                   index_ty: Ty<'tcx>)\n                   -> Option<(/*index type*/ Ty<'tcx>, /*element type*/ Ty<'tcx>)>\n {\n-    let tcx = self.tcx();\n+    let tcx = self.tcx;\n     debug!(\"try_index_step(expr={:?}, base_expr.id={:?}, adjusted_ty={:?}, \\\n                            autoderefs={}, unsize={}, index_ty={:?})\",\n            expr,\n@@ -2428,7 +2406,7 @@ fn try_index_step(&self,\n            unsize,\n            index_ty);\n \n-    let input_ty = self.infcx().next_ty_var();\n+    let input_ty = self.next_ty_var();\n \n     // First, try built-in indexing.\n     match (adjusted_ty.builtin_index(), &index_ty.sty) {\n@@ -2477,7 +2455,7 @@ fn try_index_step(&self,\n     // If some lookup succeeded, install method in table\n     method.map(|method| {\n         debug!(\"try_index_step: success, using overloaded indexing\");\n-        self.inh.tables.borrow_mut().method_map.insert(method_call, method);\n+        self.tables.borrow_mut().method_map.insert(method_call, method);\n         (input_ty, self.make_overloaded_lvalue_return_type(method).ty)\n     })\n }\n@@ -2495,12 +2473,12 @@ fn check_method_argument_types(&self,\n \n         let err_inputs = match tuple_arguments {\n             DontTupleArguments => err_inputs,\n-            TupleArguments => vec![self.tcx().mk_tup(err_inputs)],\n+            TupleArguments => vec![self.tcx.mk_tup(err_inputs)],\n         };\n \n         self.check_argument_types(sp, &err_inputs[..], &[], args_no_rcvr,\n                                   false, tuple_arguments);\n-        ty::FnConverging(self.tcx().types.err)\n+        ty::FnConverging(self.tcx.types.err)\n     } else {\n         match method_fn_ty.sty {\n             ty::TyFnDef(_, _, ref fty) => {\n@@ -2528,7 +2506,7 @@ fn check_argument_types(&self,\n                         args: &'tcx [P<hir::Expr>],\n                         variadic: bool,\n                         tuple_arguments: TupleArgumentsFlag) {\n-    let tcx = self.tcx();\n+    let tcx = self.tcx;\n \n     // Grab the argument types, supplying fresh type variables\n     // if the wrong number of arguments were supplied\n@@ -2606,7 +2584,7 @@ fn check_argument_types(&self,\n     };\n \n     debug!(\"check_argument_types: formal_tys={:?}\",\n-           formal_tys.iter().map(|t| self.infcx().ty_to_string(*t)).collect::<Vec<String>>());\n+           formal_tys.iter().map(|t| self.ty_to_string(*t)).collect::<Vec<String>>());\n \n     // Check the arguments.\n     // We do this in a pretty awful way: first we typecheck any arguments\n@@ -2640,7 +2618,7 @@ fn check_argument_types(&self,\n         };\n         for (i, arg) in args.iter().take(t).enumerate() {\n             if any_diverges && !warned {\n-                self.tcx()\n+                self.tcx\n                     .sess\n                     .add_lint(lint::builtin::UNREACHABLE_CODE,\n                               arg.id,\n@@ -2676,13 +2654,13 @@ fn check_argument_types(&self,\n                 coerce_ty.map(|ty| self.demand_suptype(arg.span, formal_ty, ty));\n             }\n \n-            if let Some(&arg_ty) = self.inh.tables.borrow().node_types.get(&arg.id) {\n-                any_diverges = any_diverges || self.infcx().type_var_diverges(arg_ty);\n+            if let Some(&arg_ty) = self.tables.borrow().node_types.get(&arg.id) {\n+                any_diverges = any_diverges || self.type_var_diverges(arg_ty);\n             }\n         }\n         if any_diverges && !warned {\n-            let parent = self.tcx().map.get_parent_node(args[0].id);\n-            self.tcx()\n+            let parent = self.tcx.map.get_parent_node(args[0].id);\n+            self.tcx\n                 .sess\n                 .add_lint(lint::builtin::UNREACHABLE_CODE,\n                           parent,\n@@ -2725,8 +2703,8 @@ fn check_argument_types(&self,\n                     }, arg_ty, None);\n                 }\n                 ty::TyFnDef(_, _, f) => {\n-                    let ptr_ty = self.tcx().mk_ty(ty::TyFnPtr(f));\n-                    let ptr_ty = self.infcx().resolve_type_vars_if_possible(&ptr_ty);\n+                    let ptr_ty = self.tcx.mk_ty(ty::TyFnPtr(f));\n+                    let ptr_ty = self.resolve_type_vars_if_possible(&ptr_ty);\n                     self.type_error_message(arg.span,\n                                             |t| {\n                         format!(\"can't pass `{}` to variadic \\\n@@ -2740,15 +2718,15 @@ fn check_argument_types(&self,\n }\n \n fn err_args(&self, len: usize) -> Vec<Ty<'tcx>> {\n-    (0..len).map(|_| self.tcx().types.err).collect()\n+    (0..len).map(|_| self.tcx.types.err).collect()\n }\n \n fn write_call(&self,\n               call_expr: &hir::Expr,\n               output: ty::FnOutput<'tcx>) {\n     self.write_ty(call_expr.id, match output {\n         ty::FnConverging(output_ty) => output_ty,\n-        ty::FnDiverging => self.infcx().next_diverging_ty_var()\n+        ty::FnDiverging => self.next_diverging_ty_var()\n     });\n }\n \n@@ -2758,7 +2736,7 @@ fn check_lit(&self,\n              expected: Expectation<'tcx>)\n              -> Ty<'tcx>\n {\n-    let tcx = self.tcx();\n+    let tcx = self.tcx;\n \n     match lit.node {\n         ast::LitKind::Str(..) => tcx.mk_static_str(),\n@@ -2781,7 +2759,7 @@ fn check_lit(&self,\n                 }\n             });\n             opt_ty.unwrap_or_else(\n-                || tcx.mk_int_var(self.infcx().next_int_var_id()))\n+                || tcx.mk_int_var(self.next_int_var_id()))\n         }\n         ast::LitKind::Float(_, t) => tcx.mk_mach_float(t),\n         ast::LitKind::FloatUnsuffixed(_) => {\n@@ -2792,7 +2770,7 @@ fn check_lit(&self,\n                 }\n             });\n             opt_ty.unwrap_or_else(\n-                || tcx.mk_float_var(self.infcx().next_float_var_id()))\n+                || tcx.mk_float_var(self.next_float_var_id()))\n         }\n         ast::LitKind::Bool(_) => tcx.types.bool\n     }\n@@ -2847,7 +2825,7 @@ pub fn impl_self_ty(&self,\n                     span: Span, // (potential) receiver for this impl\n                     did: DefId)\n                     -> TypeAndSubsts<'tcx> {\n-    let tcx = self.tcx();\n+    let tcx = self.tcx;\n \n     let ity = tcx.lookup_item_type(did);\n     let (tps, rps, raw_ty) =\n@@ -2857,11 +2835,11 @@ pub fn impl_self_ty(&self,\n \n     debug!(\"impl_self_ty: tps={:?} rps={:?} raw_ty={:?}\", tps, rps, raw_ty);\n \n-    let rps = self.inh.infcx.region_vars_for_defs(span, rps);\n+    let rps = self.region_vars_for_defs(span, rps);\n     let mut substs = subst::Substs::new(\n         VecPerParamSpace::empty(),\n         VecPerParamSpace::new(rps, Vec::new(), Vec::new()));\n-    self.inh.infcx.type_vars_for_defs(span, ParamSpace::TypeSpace, &mut substs, tps);\n+    self.type_vars_for_defs(span, ParamSpace::TypeSpace, &mut substs, tps);\n     let substd_ty = self.instantiate_type_scheme(span, &substs, &raw_ty);\n \n     TypeAndSubsts { substs: substs, ty: substd_ty }\n@@ -2877,13 +2855,13 @@ fn expected_types_for_fn_args(&self,\n                               -> Vec<Ty<'tcx>> {\n     let expected_args = expected_ret.only_has_type(self).and_then(|ret_ty| {\n         if let ty::FnConverging(formal_ret_ty) = formal_ret {\n-            self.infcx().commit_regions_if_ok(|| {\n+            self.commit_regions_if_ok(|| {\n                 // Attempt to apply a subtyping relationship between the formal\n                 // return type (likely containing type variables if the function\n                 // is polymorphic) and the expected return type.\n                 // No argument expectations are produced if unification fails.\n                 let origin = TypeOrigin::Misc(call_span);\n-                let ures = self.infcx().sub_types(false, origin, formal_ret_ty, ret_ty);\n+                let ures = self.sub_types(false, origin, formal_ret_ty, ret_ty);\n                 // FIXME(#15760) can't use try! here, FromError doesn't default\n                 // to identity so the resulting type is not constrained.\n                 match ures {\n@@ -2895,7 +2873,7 @@ fn expected_types_for_fn_args(&self,\n                 // Record all the argument types, with the substitutions\n                 // produced from the above subtyping unification.\n                 Ok(formal_args.iter().map(|ty| {\n-                    self.infcx().resolve_type_vars_if_possible(ty)\n+                    self.resolve_type_vars_if_possible(ty)\n                 }).collect())\n             }).ok()\n         } else {\n@@ -2932,7 +2910,7 @@ fn expected_types_for_fn_args(&self,\n             Ok(method) => {\n                 let method_ty = method.ty;\n                 let method_call = MethodCall::expr(expr.id);\n-                self.inh.tables.borrow_mut().method_map.insert(method_call, method);\n+                self.tables.borrow_mut().method_map.insert(method_call, method);\n                 method_ty\n             }\n             Err(error) => {\n@@ -2941,7 +2919,7 @@ fn expected_types_for_fn_args(&self,\n                                              method_name.node, Some(rcvr), error);\n                 }\n                 self.write_error(expr.id);\n-                self.tcx().types.err\n+                self.tcx.types.err\n             }\n         };\n \n@@ -2963,13 +2941,13 @@ fn expected_types_for_fn_args(&self,\n                        id: ast::NodeId,\n                        sp: Span,\n                        expected: Expectation<'tcx>) {\n-        self.check_expr_has_type(cond_expr, self.tcx().types.bool);\n+        self.check_expr_has_type(cond_expr, self.tcx.types.bool);\n \n         let expected = expected.adjust_for_branches(self);\n         self.check_block_with_expected(then_blk, expected);\n         let then_ty = self.node_ty(then_blk.id);\n \n-        let unit = self.tcx().mk_nil();\n+        let unit = self.tcx.mk_nil();\n         let (origin, expected, found, result) =\n         if let Some(else_expr) = opt_else_expr {\n             self.check_expr_with_expectation(else_expr, expected);\n@@ -2984,16 +2962,16 @@ fn expected_types_for_fn_args(&self,\n \n                 // In case we did perform an adjustment, we have to update\n                 // the type of the block, because old trans still uses it.\n-                let adj = self.inh.tables.borrow().adjustments.get(&then.id).cloned();\n+                let adj = self.tables.borrow().adjustments.get(&then.id).cloned();\n                 if res.is_ok() && adj.is_some() {\n                     self.write_ty(then_blk.id, self.adjust_expr_ty(then, adj.as_ref()));\n                 }\n \n                 res\n             } else {\n-                self.infcx().commit_if_ok(|_| {\n+                self.commit_if_ok(|_| {\n                     let trace = TypeTrace::types(origin, true, then_ty, else_ty);\n-                    self.infcx().lub(true, trace, &then_ty, &else_ty)\n+                    self.lub(true, trace, &then_ty, &else_ty)\n                         .map(|InferOk { value, obligations }| {\n                             // FIXME(#32730) propagate obligations\n                             assert!(obligations.is_empty());\n@@ -3005,7 +2983,7 @@ fn expected_types_for_fn_args(&self,\n         } else {\n             let origin = TypeOrigin::IfExpressionWithNoElse(sp);\n             (origin, unit, then_ty,\n-             self.infcx().eq_types(true, origin, unit, then_ty)\n+             self.eq_types(true, origin, unit, then_ty)\n                  .map(|InferOk { obligations, .. }| {\n                      // FIXME(#32730) propagate obligations\n                      assert!(obligations.is_empty());\n@@ -3016,14 +2994,14 @@ fn expected_types_for_fn_args(&self,\n         let if_ty = match result {\n             Ok(ty) => {\n                 if self.expr_ty(cond_expr).references_error() {\n-                    self.tcx().types.err\n+                    self.tcx.types.err\n                 } else {\n                     ty\n                 }\n             }\n             Err(e) => {\n-                self.infcx().report_mismatched_types(origin, expected, found, e);\n-                self.tcx().types.err\n+                self.report_mismatched_types(origin, expected, found, e);\n+                self.tcx.types.err\n             }\n         };\n \n@@ -3225,7 +3203,7 @@ fn expected_types_for_fn_args(&self,\n                                 variant: ty::VariantDef<'tcx>,\n                                 ast_fields: &'tcx [hir::Field],\n                                 check_completeness: bool) {\n-        let tcx = self.tcx();\n+        let tcx = self.tcx;\n         let substs = match adt_ty.sty {\n             ty::TyStruct(_, substs) | ty::TyEnum(_, substs) => substs,\n             _ => span_bug!(span, \"non-ADT passed to check_expr_struct_fields\")\n@@ -3248,7 +3226,7 @@ fn expected_types_for_fn_args(&self,\n                 error_happened = true;\n                 expected_field_type = tcx.types.err;\n                 if let Some(_) = variant.find_field_named(field.name.node) {\n-                    span_err!(self.tcx().sess, field.name.span, E0062,\n+                    span_err!(self.tcx.sess, field.name.span, E0062,\n                         \"field `{}` specified more than once\",\n                         field.name.node);\n                 } else {\n@@ -3300,19 +3278,19 @@ fn expected_types_for_fn_args(&self,\n                          fields: &'tcx [hir::Field],\n                          base_expr: &'tcx Option<P<hir::Expr>>)\n     {\n-        let tcx = self.tcx();\n+        let tcx = self.tcx;\n \n         // Find the relevant variant\n         let def = lookup_full_def(tcx, path.span, expr.id);\n         if def == Def::Err {\n-            self.infcx().set_tainted_by_errors();\n+            self.set_tainted_by_errors();\n             self.check_struct_fields_on_error(expr.id, fields, base_expr);\n             return;\n         }\n         let variant = match self.def_struct_variant(def, path.span) {\n             Some((_, variant)) => variant,\n             None => {\n-                span_err!(self.tcx().sess, path.span, E0071,\n+                span_err!(self.tcx.sess, path.span, E0071,\n                           \"`{}` does not name a structure\",\n                           pprust::path_to_string(path));\n                 self.check_struct_fields_on_error(expr.id, fields, base_expr);\n@@ -3329,7 +3307,7 @@ fn expected_types_for_fn_args(&self,\n             self.check_expr_has_type(base_expr, expr_ty);\n             match expr_ty.sty {\n                 ty::TyStruct(adt, substs) => {\n-                    self.inh.tables.borrow_mut().fru_field_types.insert(\n+                    self.tables.borrow_mut().fru_field_types.insert(\n                         expr.id,\n                         adt.struct_variant().fields.iter().map(|f| {\n                             self.normalize_associated_types_in(\n@@ -3364,7 +3342,7 @@ fn check_expr_with_expectation_and_lvalue_pref(&self,\n     debug!(\">> typechecking: expr={:?} expected={:?}\",\n            expr, expected);\n \n-    let tcx = self.tcx();\n+    let tcx = self.tcx;\n     let id = expr.id;\n     match expr.node {\n       hir::ExprBox(ref subexpr) => {\n@@ -3417,7 +3395,7 @@ fn check_expr_with_expectation_and_lvalue_pref(&self,\n                     } else if let Some(method) = self.try_overloaded_deref(\n                             expr.span, Some(&oprnd), oprnd_t, lvalue_pref) {\n                         oprnd_t = self.make_overloaded_lvalue_return_type(method).ty;\n-                        self.inh.tables.borrow_mut().method_map.insert(MethodCall::expr(expr.id),\n+                        self.tables.borrow_mut().method_map.insert(MethodCall::expr(expr.id),\n                                                                        method);\n                     } else {\n                         self.type_error_message(expr.span, |actual| {\n@@ -3453,7 +3431,7 @@ fn check_expr_with_expectation_and_lvalue_pref(&self,\n         let hint = expected.only_has_type(self).map_or(NoExpectation, |ty| {\n             match ty.sty {\n                 ty::TyRef(_, ref mt) | ty::TyRawPtr(ref mt) => {\n-                    if self.tcx().expr_is_lval(&oprnd) {\n+                    if self.tcx.expr_is_lval(&oprnd) {\n                         // Lvalues may legitimately have unsized types.\n                         // For example, dereferences of a fat pointer and\n                         // the last field of a struct can be unsized.\n@@ -3485,7 +3463,7 @@ fn check_expr_with_expectation_and_lvalue_pref(&self,\n             // Finally, borrowck is charged with guaranteeing that the\n             // value whose address was taken can actually be made to live\n             // as long as it needs to live.\n-            let region = self.infcx().next_region_var(infer::AddrOfRegion(expr.span));\n+            let region = self.next_region_var(infer::AddrOfRegion(expr.span));\n             tcx.mk_ref(tcx.mk_region(region), tm)\n         };\n         self.write_ty(id, oprnd_t);\n@@ -3516,8 +3494,8 @@ fn check_expr_with_expectation_and_lvalue_pref(&self,\n                   self.instantiate_path(segments, scheme, &predicates,\n                                         opt_ty, def, expr.span, id);\n               } else {\n-                  self.infcx().set_tainted_by_errors();\n-                  self.write_ty(id, self.tcx().types.err);\n+                  self.set_tainted_by_errors();\n+                  self.write_ty(id, self.tcx.types.err);\n               }\n           }\n \n@@ -3536,18 +3514,18 @@ fn check_expr_with_expectation_and_lvalue_pref(&self,\n           }\n           self.write_nil(id);\n       }\n-      hir::ExprBreak(_) => { self.write_ty(id, self.infcx().next_diverging_ty_var()); }\n-      hir::ExprAgain(_) => { self.write_ty(id, self.infcx().next_diverging_ty_var()); }\n+      hir::ExprBreak(_) => { self.write_ty(id, self.next_diverging_ty_var()); }\n+      hir::ExprAgain(_) => { self.write_ty(id, self.next_diverging_ty_var()); }\n       hir::ExprRet(ref expr_opt) => {\n         match self.ret_ty {\n             ty::FnConverging(result_type) => {\n                 if let Some(ref e) = *expr_opt {\n                     self.check_expr_coercable_to_type(&e, result_type);\n                 } else {\n-                    let eq_result = self.infcx().eq_types(false,\n-                                                          TypeOrigin::Misc(expr.span),\n-                                                          result_type,\n-                                                          self.tcx().mk_nil())\n+                    let eq_result = self.eq_types(false,\n+                                                  TypeOrigin::Misc(expr.span),\n+                                                  result_type,\n+                                                  tcx.mk_nil())\n                         // FIXME(#32730) propagate obligations\n                         .map(|InferOk { obligations, .. }| assert!(obligations.is_empty()));\n                     if eq_result.is_err() {\n@@ -3564,12 +3542,12 @@ fn check_expr_with_expectation_and_lvalue_pref(&self,\n                     \"`return` in a function declared as diverging\");\n             }\n         }\n-        self.write_ty(id, self.infcx().next_diverging_ty_var());\n+        self.write_ty(id, self.next_diverging_ty_var());\n       }\n       hir::ExprAssign(ref lhs, ref rhs) => {\n         self.check_expr_with_lvalue_pref(&lhs, PreferMutLvalue);\n \n-        let tcx = self.tcx();\n+        let tcx = self.tcx;\n         if !tcx.expr_is_lval(&lhs) {\n             span_err!(tcx.sess, expr.span, E0070,\n                 \"invalid left-hand side expression\");\n@@ -3606,7 +3584,7 @@ fn check_expr_with_expectation_and_lvalue_pref(&self,\n       hir::ExprLoop(ref body, _) => {\n         self.check_block_no_value(&body);\n         if !may_break(tcx, expr.id, &body) {\n-            self.write_ty(id, self.infcx().next_diverging_ty_var());\n+            self.write_ty(id, self.next_diverging_ty_var());\n         } else {\n             self.write_nil(id);\n         }\n@@ -3644,10 +3622,10 @@ fn check_expr_with_expectation_and_lvalue_pref(&self,\n         // Find the type of `e`. Supply hints based on the type we are casting to,\n         // if appropriate.\n         let t_cast = self.to_ty(t);\n-        let t_cast = self.infcx().resolve_type_vars_if_possible(&t_cast);\n+        let t_cast = self.resolve_type_vars_if_possible(&t_cast);\n         self.check_expr_with_expectation(e, ExpectCastableToType(t_cast));\n         let t_expr = self.expr_ty(e);\n-        let t_cast = self.infcx().resolve_type_vars_if_possible(&t_cast);\n+        let t_cast = self.resolve_type_vars_if_possible(&t_cast);\n \n         // Eagerly check for some obvious errors.\n         if t_expr.references_error() || t_cast.references_error() {\n@@ -3658,7 +3636,7 @@ fn check_expr_with_expectation_and_lvalue_pref(&self,\n             self.write_ty(id, t_cast);\n \n             // Defer other checks until we're done type checking.\n-            let mut deferred_cast_checks = self.inh.deferred_cast_checks.borrow_mut();\n+            let mut deferred_cast_checks = self.deferred_cast_checks.borrow_mut();\n             match cast::CastCheck::new(self, e, t_expr, t_cast, t.span, expr.span) {\n                 Ok(cast_check) => {\n                     deferred_cast_checks.push(cast_check);\n@@ -3682,7 +3660,7 @@ fn check_expr_with_expectation_and_lvalue_pref(&self,\n             }\n         });\n \n-        let mut unified = self.infcx().next_ty_var();\n+        let mut unified = self.next_ty_var();\n         let coerce_to = uty.unwrap_or(unified);\n \n         for (i, e) in args.iter().enumerate() {\n@@ -3701,15 +3679,15 @@ fn check_expr_with_expectation_and_lvalue_pref(&self,\n             match result {\n                 Ok(ty) => unified = ty,\n                 Err(e) => {\n-                    self.infcx().report_mismatched_types(origin, unified, e_ty, e);\n+                    self.report_mismatched_types(origin, unified, e_ty, e);\n                 }\n             }\n         }\n         self.write_ty(id, tcx.mk_array(unified, args.len()));\n       }\n       hir::ExprRepeat(ref element, ref count_expr) => {\n         self.check_expr_has_type(&count_expr, tcx.types.usize);\n-        let count = eval_repeat_count(self.tcx(), &count_expr);\n+        let count = eval_repeat_count(self.tcx, &count_expr);\n \n         let uty = match expected {\n             ExpectHasType(uty) => {\n@@ -3727,7 +3705,7 @@ fn check_expr_with_expectation_and_lvalue_pref(&self,\n                 (uty, uty)\n             }\n             None => {\n-                let t: Ty = self.infcx().next_ty_var();\n+                let t: Ty = self.next_ty_var();\n                 self.check_expr_has_type(&element, t);\n                 (self.expr_ty(&element), t)\n             }\n@@ -3808,7 +3786,7 @@ fn check_expr_with_expectation_and_lvalue_pref(&self,\n                       self.write_ty(id, element_ty);\n                   }\n                   None => {\n-                      self.check_expr_has_type(&idx, self.tcx().types.err);\n+                      self.check_expr_has_type(&idx, self.tcx.types.err);\n                       let mut err = self.type_error_struct(\n                           expr.span,\n                           |actual| {\n@@ -3910,7 +3888,7 @@ pub fn check_decl_initializer(&self,\n                               local: &'tcx hir::Local,\n                               init: &'tcx hir::Expr)\n {\n-    let ref_bindings = self.tcx().pat_contains_ref_binding(&local.pat);\n+    let ref_bindings = self.tcx.pat_contains_ref_binding(&local.pat);\n \n     let local_ty = self.local_ty(init.span, local.id);\n     if let Some(m) = ref_bindings {\n@@ -3931,7 +3909,7 @@ pub fn check_decl_initializer(&self,\n }\n \n pub fn check_decl_local(&self, local: &'tcx hir::Local)  {\n-    let tcx = self.tcx();\n+    let tcx = self.tcx;\n \n     let t = self.local_ty(local.span, local.id);\n     self.write_ty(local.id, t);\n@@ -3966,7 +3944,7 @@ pub fn check_stmt(&self, stmt: &'tcx hir::Stmt)  {\n           hir::DeclLocal(ref l) => {\n               self.check_decl_local(&l);\n               let l_t = self.node_ty(l.id);\n-              saw_bot = saw_bot || self.infcx().type_var_diverges(l_t);\n+              saw_bot = saw_bot || self.type_var_diverges(l_t);\n               saw_err = saw_err || l_t.references_error();\n           }\n           hir::DeclItem(_) => {/* ignore for now */ }\n@@ -3975,21 +3953,21 @@ pub fn check_stmt(&self, stmt: &'tcx hir::Stmt)  {\n       hir::StmtExpr(ref expr, id) => {\n         node_id = id;\n         // Check with expected type of ()\n-        self.check_expr_has_type(&expr, self.tcx().mk_nil());\n+        self.check_expr_has_type(&expr, self.tcx.mk_nil());\n         let expr_ty = self.expr_ty(&expr);\n-        saw_bot = saw_bot || self.infcx().type_var_diverges(expr_ty);\n+        saw_bot = saw_bot || self.type_var_diverges(expr_ty);\n         saw_err = saw_err || expr_ty.references_error();\n       }\n       hir::StmtSemi(ref expr, id) => {\n         node_id = id;\n         self.check_expr(&expr);\n         let expr_ty = self.expr_ty(&expr);\n-        saw_bot |= self.infcx().type_var_diverges(expr_ty);\n+        saw_bot |= self.type_var_diverges(expr_ty);\n         saw_err |= expr_ty.references_error();\n       }\n     }\n     if saw_bot {\n-        self.write_ty(node_id, self.infcx().next_diverging_ty_var());\n+        self.write_ty(node_id, self.next_diverging_ty_var());\n     }\n     else if saw_err {\n         self.write_error(node_id);\n@@ -4000,12 +3978,12 @@ pub fn check_stmt(&self, stmt: &'tcx hir::Stmt)  {\n }\n \n pub fn check_block_no_value(&self, blk: &'tcx hir::Block)  {\n-    self.check_block_with_expected(blk, ExpectHasType(self.tcx().mk_nil()));\n+    self.check_block_with_expected(blk, ExpectHasType(self.tcx.mk_nil()));\n     let blkty = self.node_ty(blk.id);\n     if blkty.references_error() {\n         self.write_error(blk.id);\n     } else {\n-        let nilty = self.tcx().mk_nil();\n+        let nilty = self.tcx.mk_nil();\n         self.demand_suptype(blk.span, nilty, blkty);\n     }\n }\n@@ -4035,28 +4013,28 @@ fn check_block_with_expected(&self,\n             }\n             hir::StmtExpr(_, _) | hir::StmtSemi(_, _) => true,\n         } {\n-            self.tcx()\n+            self.tcx\n                 .sess\n                 .add_lint(lint::builtin::UNREACHABLE_CODE,\n                           s_id,\n                           s.span,\n                           \"unreachable statement\".to_string());\n             warned = true;\n         }\n-        any_diverges = any_diverges || self.infcx().type_var_diverges(s_ty);\n+        any_diverges = any_diverges || self.type_var_diverges(s_ty);\n         any_err = any_err || s_ty.references_error();\n     }\n     match blk.expr {\n         None => if any_err {\n             self.write_error(blk.id);\n         } else if any_diverges {\n-            self.write_ty(blk.id, self.infcx().next_diverging_ty_var());\n+            self.write_ty(blk.id, self.next_diverging_ty_var());\n         } else {\n             self.write_nil(blk.id);\n         },\n         Some(ref e) => {\n             if any_diverges && !warned {\n-                self.tcx()\n+                self.tcx\n                     .sess\n                     .add_lint(lint::builtin::UNREACHABLE_CODE,\n                               e.id,\n@@ -4077,7 +4055,7 @@ fn check_block_with_expected(&self,\n             if any_err {\n                 self.write_error(blk.id);\n             } else if any_diverges {\n-                self.write_ty(blk.id, self.infcx().next_diverging_ty_var());\n+                self.write_ty(blk.id, self.next_diverging_ty_var());\n             } else {\n                 self.write_ty(blk.id, ety);\n             }\n@@ -4124,7 +4102,7 @@ fn type_scheme_and_predicates_for_def(&self,\n         Def::Fn(id) | Def::Method(id) |\n         Def::Static(id, _) | Def::Variant(_, id) |\n         Def::Struct(id) | Def::Const(id) | Def::AssociatedConst(id) => {\n-            (self.tcx().lookup_item_type(id), self.tcx().lookup_predicates(id))\n+            (self.tcx.lookup_item_type(id), self.tcx.lookup_predicates(id))\n         }\n         Def::Trait(_) |\n         Def::Enum(..) |\n@@ -4258,7 +4236,7 @@ pub fn instantiate_path(&self,\n \n         // Case 3. Reference to a method.\n         Def::Method(def_id) => {\n-            let container = self.tcx().impl_or_trait_item(def_id).container();\n+            let container = self.tcx.impl_or_trait_item(def_id).container();\n             match container {\n                 ty::TraitContainer(trait_did) => {\n                     callee::check_legal_trait_for_method_call(self.ccx, span, trait_did)\n@@ -4279,7 +4257,7 @@ pub fn instantiate_path(&self,\n         }\n \n         Def::AssociatedConst(def_id) => {\n-            let container = self.tcx().impl_or_trait_item(def_id).container();\n+            let container = self.tcx.impl_or_trait_item(def_id).container();\n             match container {\n                 ty::TraitContainer(trait_did) => {\n                     callee::check_legal_trait_for_method_call(self.ccx, span, trait_did)\n@@ -4311,7 +4289,7 @@ pub fn instantiate_path(&self,\n         }\n \n         Def::Err => {\n-            self.infcx().set_tainted_by_errors();\n+            self.set_tainted_by_errors();\n             segment_spaces = vec![None; segments.len()];\n         }\n     }\n@@ -4343,7 +4321,7 @@ pub fn instantiate_path(&self,\n                                                                  segment,\n                                                                  &mut substs);\n         } else {\n-            self.tcx().prohibit_type_params(slice::ref_slice(segment));\n+            self.tcx.prohibit_type_params(slice::ref_slice(segment));\n         }\n     }\n     if let Some(self_ty) = opt_self_ty {\n@@ -4389,14 +4367,14 @@ pub fn instantiate_path(&self,\n         // is inherent, there is no `Self` parameter, instead, the impl needs\n         // type parameters, which we can infer by unifying the provided `Self`\n         // with the substituted impl type.\n-        let impl_scheme = self.tcx().lookup_item_type(impl_def_id);\n+        let impl_scheme = self.tcx.lookup_item_type(impl_def_id);\n         assert_eq!(substs.types.len(subst::TypeSpace),\n                    impl_scheme.generics.types.len(subst::TypeSpace));\n         assert_eq!(substs.regions.len(subst::TypeSpace),\n                    impl_scheme.generics.regions.len(subst::TypeSpace));\n \n         let impl_ty = self.instantiate_type_scheme(span, &substs, &impl_scheme.ty);\n-        match self.infcx().sub_types(false, TypeOrigin::Misc(span), self_ty, impl_ty) {\n+        match self.sub_types(false, TypeOrigin::Misc(span), self_ty, impl_ty) {\n             Ok(InferOk { obligations, .. }) => {\n                 // FIXME(#32730) propagate obligations\n                 assert!(obligations.is_empty());\n@@ -4441,7 +4419,7 @@ pub fn instantiate_path(&self,\n             }\n \n             hir::ParenthesizedParameters(ref data) => {\n-                span_err!(self.tcx().sess, span, E0238,\n+                span_err!(self.tcx.sess, span, E0238,\n                     \"parenthesized parameters may only be used with a trait\");\n                 self.push_explicit_parenthesized_parameters_from_segment_to_substs(\n                     space, span, type_defs, data, substs);\n@@ -4464,7 +4442,7 @@ pub fn instantiate_path(&self,\n                 if i < type_count {\n                     substs.types.push(space, t);\n                 } else if i == type_count {\n-                    span_err!(self.tcx().sess, typ.span, E0087,\n+                    span_err!(self.tcx.sess, typ.span, E0087,\n                         \"too many type parameters provided: \\\n                          expected at most {} parameter{}, \\\n                          found {} parameter{}\",\n@@ -4479,7 +4457,7 @@ pub fn instantiate_path(&self,\n         }\n \n         if !data.bindings.is_empty() {\n-            span_err!(self.tcx().sess, data.bindings[0].span, E0182,\n+            span_err!(self.tcx.sess, data.bindings[0].span, E0182,\n                       \"unexpected binding of associated item in expression path \\\n                        (only allowed in type paths)\");\n         }\n@@ -4488,11 +4466,11 @@ pub fn instantiate_path(&self,\n             let region_count = region_defs.len(space);\n             assert_eq!(substs.regions.len(space), 0);\n             for (i, lifetime) in data.lifetimes.iter().enumerate() {\n-                let r = ast_region_to_region(self.tcx(), lifetime);\n+                let r = ast_region_to_region(self.tcx, lifetime);\n                 if i < region_count {\n                     substs.regions.push(space, r);\n                 } else if i == region_count {\n-                    span_err!(self.tcx().sess, lifetime.span, E0088,\n+                    span_err!(self.tcx.sess, lifetime.span, E0088,\n                         \"too many lifetime parameters provided: \\\n                          expected {} parameter{}, found {} parameter{}\",\n                         region_count,\n@@ -4521,7 +4499,7 @@ pub fn instantiate_path(&self,\n     {\n         let type_count = type_defs.len(space);\n         if type_count < 2 {\n-            span_err!(self.tcx().sess, span, E0167,\n+            span_err!(self.tcx.sess, span, E0167,\n                       \"parenthesized form always supplies 2 type parameters, \\\n                       but only {} parameter(s) were expected\",\n                       type_count);\n@@ -4530,7 +4508,7 @@ pub fn instantiate_path(&self,\n         let input_tys: Vec<Ty> =\n             data.inputs.iter().map(|ty| self.to_ty(&ty)).collect();\n \n-        let tuple_ty = self.tcx().mk_tup(input_tys);\n+        let tuple_ty = self.tcx.mk_tup(input_tys);\n \n         if type_count >= 1 {\n             substs.types.push(space, tuple_ty);\n@@ -4540,7 +4518,7 @@ pub fn instantiate_path(&self,\n             data.output.as_ref().map(|ty| self.to_ty(&ty));\n \n         let output_ty =\n-            output_ty.unwrap_or(self.tcx().mk_nil());\n+            output_ty.unwrap_or(self.tcx.mk_nil());\n \n         if type_count >= 2 {\n             substs.types.push(space, output_ty);\n@@ -4576,7 +4554,7 @@ pub fn instantiate_path(&self,\n         // everything.\n         if provided_len == 0 && !(require_type_space && space == subst::TypeSpace) {\n             substs.types.replace(space, Vec::new());\n-            self.infcx().type_vars_for_defs(span, space, substs, &desired[..]);\n+            self.type_vars_for_defs(span, space, substs, &desired[..]);\n             return;\n         }\n \n@@ -4585,14 +4563,14 @@ pub fn instantiate_path(&self,\n         if provided_len < required_len {\n             let qualifier =\n                 if desired.len() != required_len { \"at least \" } else { \"\" };\n-            span_err!(self.tcx().sess, span, E0089,\n+            span_err!(self.tcx.sess, span, E0089,\n                 \"too few type parameters provided: expected {}{} parameter{}, \\\n                  found {} parameter{}\",\n                 qualifier, required_len,\n                 if required_len == 1 {\"\"} else {\"s\"},\n                 provided_len,\n                 if provided_len == 1 {\"\"} else {\"s\"});\n-            substs.types.replace(space, vec![self.tcx().types.err; desired.len()]);\n+            substs.types.replace(space, vec![self.tcx.types.err; desired.len()]);\n             return;\n         }\n \n@@ -4605,7 +4583,7 @@ pub fn instantiate_path(&self,\n         // partial substitution that we have built up.\n         for i in provided_len..desired.len() {\n             let default = desired[i].default.unwrap();\n-            let default = default.subst_spanned(self.tcx(), substs, Some(span));\n+            let default = default.subst_spanned(self.tcx, substs, Some(span));\n             substs.types.push(space, default);\n         }\n         assert_eq!(substs.types.len(space), desired.len());\n@@ -4629,7 +4607,7 @@ pub fn instantiate_path(&self,\n         if provided_len == 0 {\n             substs.regions.replace(\n                 space,\n-                self.infcx().region_vars_for_defs(span, desired));\n+                self.region_vars_for_defs(span, desired));\n             return;\n         }\n \n@@ -4640,7 +4618,7 @@ pub fn instantiate_path(&self,\n \n         // Otherwise, too few were provided. Report an error and then\n         // use inference variables.\n-        span_err!(self.tcx().sess, span, E0090,\n+        span_err!(self.tcx.sess, span, E0090,\n             \"too few lifetime parameters provided: expected {} parameter{}, \\\n              found {} parameter{}\",\n             desired.len(),\n@@ -4650,27 +4628,27 @@ pub fn instantiate_path(&self,\n \n         substs.regions.replace(\n             space,\n-            self.infcx().region_vars_for_defs(span, desired));\n+            self.region_vars_for_defs(span, desired));\n     }\n \n fn structurally_resolve_type_or_else<F>(&self, sp: Span, ty: Ty<'tcx>, f: F)\n                                         -> Ty<'tcx>\n     where F: Fn() -> Ty<'tcx>\n {\n-    let mut ty = self.resolve_type_vars_if_possible(ty);\n+    let mut ty = self.resolve_type_vars_with_obligations(ty);\n \n     if ty.is_ty_var() {\n         let alternative = f();\n \n         // If not, error.\n         if alternative.is_ty_var() || alternative.references_error() {\n-            if !self.infcx().is_tainted_by_errors() {\n+            if !self.is_tainted_by_errors() {\n                 self.type_error_message(sp, |_actual| {\n                     \"the type of this value must be known in this context\".to_string()\n                 }, ty, None);\n             }\n-            self.demand_suptype(sp, self.tcx().types.err, ty);\n-            ty = self.tcx().types.err;\n+            self.demand_suptype(sp, self.tcx.types.err, ty);\n+            ty = self.tcx.types.err;\n         } else {\n             self.demand_suptype(sp, alternative, ty);\n             ty = alternative;\n@@ -4684,7 +4662,7 @@ fn structurally_resolve_type_or_else<F>(&self, sp: Span, ty: Ty<'tcx>, f: F)\n // resolution is possible, then an error is reported.\n pub fn structurally_resolved_type(&self, sp: Span, ty: Ty<'tcx>) -> Ty<'tcx> {\n     self.structurally_resolve_type_or_else(sp, ty, || {\n-        self.tcx().types.err\n+        self.tcx.types.err\n     })\n }\n }"}, {"sha": "9b3823774f79c9c12b4ccabdf96f3419160e1bec", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/0053b442f8cd5bf5e310a2664fc3a47a8f33da71/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0053b442f8cd5bf5e310a2664fc3a47a8f33da71/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=0053b442f8cd5bf5e310a2664fc3a47a8f33da71", "patch": "@@ -27,10 +27,10 @@ pub fn check_binop_assign(&self,\n {\n     self.check_expr_with_lvalue_pref(lhs_expr, PreferMutLvalue);\n \n-    let lhs_ty = self.resolve_type_vars_if_possible(self.expr_ty(lhs_expr));\n+    let lhs_ty = self.resolve_type_vars_with_obligations(self.expr_ty(lhs_expr));\n     let (rhs_ty, return_ty) =\n         self.check_overloaded_binop(expr, lhs_expr, lhs_ty, rhs_expr, op, IsAssign::Yes);\n-    let rhs_ty = self.resolve_type_vars_if_possible(rhs_ty);\n+    let rhs_ty = self.resolve_type_vars_with_obligations(rhs_ty);\n \n     if !lhs_ty.is_ty_var() && !rhs_ty.is_ty_var() && is_builtin_binop(lhs_ty, rhs_ty, op) {\n         self.enforce_builtin_binop_types(lhs_expr, lhs_ty, rhs_expr, rhs_ty, op);\n@@ -39,7 +39,7 @@ pub fn check_binop_assign(&self,\n         self.write_ty(expr.id, return_ty);\n     }\n \n-    let tcx = self.tcx();\n+    let tcx = self.tcx;\n     if !tcx.expr_is_lval(lhs_expr) {\n         span_err!(tcx.sess, lhs_expr.span, E0067, \"invalid left-hand side expression\");\n     }\n@@ -52,7 +52,7 @@ pub fn check_binop(&self,\n                    lhs_expr: &'tcx hir::Expr,\n                    rhs_expr: &'tcx hir::Expr)\n {\n-    let tcx = self.tcx();\n+    let tcx = self.tcx;\n \n     debug!(\"check_binop(expr.id={}, expr={:?}, op={:?}, lhs_expr={:?}, rhs_expr={:?})\",\n            expr.id,\n@@ -62,7 +62,7 @@ pub fn check_binop(&self,\n            rhs_expr);\n \n     self.check_expr(lhs_expr);\n-    let lhs_ty = self.resolve_type_vars_if_possible(self.expr_ty(lhs_expr));\n+    let lhs_ty = self.resolve_type_vars_with_obligations(self.expr_ty(lhs_expr));\n \n     match BinOpCategory::from(op) {\n         BinOpCategory::Shortcircuit => {\n@@ -90,7 +90,7 @@ pub fn check_binop(&self,\n             // deduce that the result type should be `u32`, even\n             // though we don't know yet what type 2 has and hence\n             // can't pin this down to a specific impl.\n-            let rhs_ty = self.resolve_type_vars_if_possible(rhs_ty);\n+            let rhs_ty = self.resolve_type_vars_with_obligations(rhs_ty);\n             if\n                 !lhs_ty.is_ty_var() && !rhs_ty.is_ty_var() &&\n                 is_builtin_binop(lhs_ty, rhs_ty, op)\n@@ -115,7 +115,7 @@ fn enforce_builtin_binop_types(&self,\n {\n     debug_assert!(is_builtin_binop(lhs_ty, rhs_ty, op));\n \n-    let tcx = self.tcx();\n+    let tcx = self.tcx;\n     match BinOpCategory::from(op) {\n         BinOpCategory::Shortcircuit => {\n             self.demand_suptype(lhs_expr.span, tcx.mk_bool(), lhs_ty);\n@@ -165,7 +165,7 @@ fn check_overloaded_binop(&self,\n     // using this variable as the expected type, which sometimes lets\n     // us do better coercions than we would be able to do otherwise,\n     // particularly for things like `String + &String`.\n-    let rhs_ty_var = self.infcx().next_ty_var();\n+    let rhs_ty_var = self.next_ty_var();\n \n     let return_ty = match self.lookup_op_method(expr, lhs_ty, vec![rhs_ty_var],\n                                                 token::intern(name), trait_def_id,\n@@ -175,12 +175,12 @@ fn check_overloaded_binop(&self,\n             // error types are considered \"builtin\"\n             if !lhs_ty.references_error() {\n                 if let IsAssign::Yes = is_assign {\n-                    span_err!(self.tcx().sess, lhs_expr.span, E0368,\n+                    span_err!(self.tcx.sess, lhs_expr.span, E0368,\n                               \"binary assignment operation `{}=` cannot be applied to type `{}`\",\n                               op.node.as_str(),\n                               lhs_ty);\n                 } else {\n-                    let mut err = struct_span_err!(self.tcx().sess, lhs_expr.span, E0369,\n+                    let mut err = struct_span_err!(self.tcx.sess, lhs_expr.span, E0369,\n                         \"binary operation `{}` cannot be applied to type `{}`\",\n                         op.node.as_str(),\n                         lhs_ty);\n@@ -208,7 +208,7 @@ fn check_overloaded_binop(&self,\n                     err.emit();\n                 }\n             }\n-            self.tcx().types.err\n+            self.tcx.types.err\n         }\n     };\n \n@@ -238,7 +238,7 @@ pub fn check_user_unop(&self,\n                 format!(\"cannot apply unary operator `{}` to type `{}`\",\n                         op_str, actual)\n             }, operand_ty, None);\n-            self.tcx().types.err\n+            self.tcx.types.err\n         }\n     }\n }\n@@ -247,7 +247,7 @@ fn name_and_trait_def_id(&self,\n                          op: hir::BinOp,\n                          is_assign: IsAssign)\n                          -> (&'static str, Option<DefId>) {\n-    let lang = &self.tcx().lang_items;\n+    let lang = &self.tcx.lang_items;\n \n     if let IsAssign::Yes = is_assign {\n         match op.node {\n@@ -329,12 +329,12 @@ fn lookup_op_method(&self,\n \n             // HACK(eddyb) Fully qualified path to work around a resolve bug.\n             let method_call = ::rustc::ty::MethodCall::expr(expr.id);\n-            self.inh.tables.borrow_mut().method_map.insert(method_call, method);\n+            self.tables.borrow_mut().method_map.insert(method_call, method);\n \n             // extract return type for method; all late bound regions\n             // should have been instantiated by now\n             let ret_ty = method_ty.fn_ret();\n-            Ok(self.tcx().no_late_bound_regions(&ret_ty).unwrap().unwrap())\n+            Ok(self.tcx.no_late_bound_regions(&ret_ty).unwrap().unwrap())\n         }\n         None => {\n             Err(())"}, {"sha": "b65fcbac8d4dfc39d0ba5ca439ef936ff9a27be1", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 86, "deletions": 93, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/0053b442f8cd5bf5e310a2664fc3a47a8f33da71/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0053b442f8cd5bf5e310a2664fc3a47a8f33da71/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=0053b442f8cd5bf5e310a2664fc3a47a8f33da71", "patch": "@@ -90,13 +90,14 @@ use middle::mem_categorization::Categorization;\n use middle::region::{self, CodeExtent};\n use rustc::ty::subst::Substs;\n use rustc::traits;\n-use rustc::ty::{self, Ty, TyCtxt, MethodCall, TypeFoldable};\n-use rustc::infer::{self, GenericKind, InferCtxt, InferOk, SubregionOrigin, TypeOrigin, VerifyBound};\n+use rustc::ty::{self, Ty, MethodCall, TypeFoldable};\n+use rustc::infer::{self, GenericKind, InferOk, SubregionOrigin, TypeOrigin, VerifyBound};\n use hir::pat_util;\n use rustc::ty::adjustment;\n use rustc::ty::wf::ImpliedBound;\n \n use std::mem;\n+use std::ops::Deref;\n use syntax::ast;\n use syntax::codemap::Span;\n use rustc::hir::intravisit::{self, Visitor};\n@@ -132,7 +133,7 @@ pub fn regionck_item(&self,\n     debug!(\"regionck_item(item.id={:?}, wf_tys={:?}\", item_id, wf_tys);\n     let mut rcx = RegionCtxt::new(self, RepeatingScope(item_id), item_id, Subject(item_id));\n     rcx.free_region_map.relate_free_regions_from_predicates(\n-        &self.infcx().parameter_environment.caller_bounds);\n+        &self.parameter_environment.caller_bounds);\n     rcx.relate_free_regions(wf_tys, item_id, span);\n     rcx.visit_region_obligations(item_id);\n     rcx.resolve_regions_and_report_errors();\n@@ -152,14 +153,14 @@ pub fn regionck_fn(&self,\n     }\n \n     rcx.free_region_map.relate_free_regions_from_predicates(\n-        &self.infcx().parameter_environment.caller_bounds);\n+        &self.parameter_environment.caller_bounds);\n \n     rcx.resolve_regions_and_report_errors();\n \n     // For the top-level fn, store the free-region-map. We don't store\n     // any map for closures; they just share the same map as the\n     // function that created them.\n-    self.tcx().store_free_region_map(fn_id, rcx.free_region_map);\n+    self.tcx.store_free_region_map(fn_id, rcx.free_region_map);\n }\n }\n \n@@ -187,6 +188,13 @@ pub struct RegionCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n \n }\n \n+impl<'a, 'gcx, 'tcx> Deref for RegionCtxt<'a, 'gcx, 'tcx> {\n+    type Target = FnCtxt<'a, 'gcx, 'tcx>;\n+    fn deref(&self) -> &Self::Target {\n+        &self.fcx\n+    }\n+}\n+\n pub struct RepeatingScope(ast::NodeId);\n pub enum SubjectNode { Subject(ast::NodeId), None }\n \n@@ -207,14 +215,6 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx, 'tcx> {\n         }\n     }\n \n-    pub fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx> {\n-        self.fcx.tcx()\n-    }\n-\n-    pub fn infcx(&self) -> &InferCtxt<'a,'tcx, 'tcx> {\n-        self.fcx.infcx()\n-    }\n-\n     fn set_call_site_scope(&mut self, call_site_scope: Option<CodeExtent>) -> Option<CodeExtent> {\n         mem::replace(&mut self.call_site_scope, call_site_scope)\n     }\n@@ -251,17 +251,17 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx, 'tcx> {\n     /// of b will be `&<R0>.i32` and then `*b` will require that `<R0>` be bigger than the let and\n     /// the `*b` expression, so we will effectively resolve `<R0>` to be the block B.\n     pub fn resolve_type(&self, unresolved_ty: Ty<'tcx>) -> Ty<'tcx> {\n-        self.fcx.infcx().resolve_type_vars_if_possible(&unresolved_ty)\n+        self.resolve_type_vars_if_possible(&unresolved_ty)\n     }\n \n     /// Try to resolve the type for the given node.\n     fn resolve_node_type(&self, id: ast::NodeId) -> Ty<'tcx> {\n-        let t = self.fcx.node_ty(id);\n+        let t = self.node_ty(id);\n         self.resolve_type(t)\n     }\n \n     fn resolve_method_type(&self, method_call: MethodCall) -> Option<Ty<'tcx>> {\n-        let method_ty = self.fcx.inh.tables.borrow().method_map\n+        let method_ty = self.tables.borrow().method_map\n                             .get(&method_call).map(|method| method.ty);\n         method_ty.map(|method_ty| self.resolve_type(method_ty))\n     }\n@@ -273,8 +273,8 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx, 'tcx> {\n             ty_unadjusted\n         } else {\n             ty_unadjusted.adjust(\n-                self.fcx.tcx(), expr.span, expr.id,\n-                self.fcx.inh.tables.borrow().adjustments.get(&expr.id),\n+                self.tcx, expr.span, expr.id,\n+                self.tables.borrow().adjustments.get(&expr.id),\n                 |method_call| self.resolve_method_type(method_call))\n         }\n     }\n@@ -288,12 +288,12 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx, 'tcx> {\n         // When we enter a function, we can derive\n         debug!(\"visit_fn_body(id={})\", id);\n \n-        let call_site = self.fcx.tcx().region_maps.lookup_code_extent(\n+        let call_site = self.tcx.region_maps.lookup_code_extent(\n             region::CodeExtentData::CallSiteScope { fn_id: id, body_id: body.id });\n         let old_call_site_scope = self.set_call_site_scope(Some(call_site));\n \n         let fn_sig = {\n-            let fn_sig_map = &self.infcx().tables.borrow().liberated_fn_sigs;\n+            let fn_sig_map = &self.tables.borrow().liberated_fn_sigs;\n             match fn_sig_map.get(&id) {\n                 Some(f) => f.clone(),\n                 None => {\n@@ -312,12 +312,12 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx, 'tcx> {\n         let fn_sig_tys: Vec<_> =\n             fn_sig.inputs.iter()\n                          .cloned()\n-                         .chain(Some(fn_sig.output.unwrap_or(self.tcx().types.bool)))\n+                         .chain(Some(fn_sig.output.unwrap_or(self.tcx.types.bool)))\n                          .collect();\n \n         let old_body_id = self.set_body_id(body.id);\n         self.relate_free_regions(&fn_sig_tys[..], body.id, span);\n-        self.link_fn_args(self.tcx().region_maps.node_extent(body.id),\n+        self.link_fn_args(self.tcx.region_maps.node_extent(body.id),\n                           &fn_decl.inputs[..]);\n         self.visit_block(body);\n         self.visit_region_obligations(body.id);\n@@ -342,14 +342,12 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx, 'tcx> {\n         // region checking can introduce new pending obligations\n         // which, when processed, might generate new region\n         // obligations. So make sure we process those.\n-        self.fcx.select_all_obligations_or_error();\n+        self.select_all_obligations_or_error();\n \n         // Make a copy of the region obligations vec because we'll need\n         // to be able to borrow the fulfillment-cx below when projecting.\n         let region_obligations =\n-            self.fcx\n-                .inh\n-                .fulfillment_cx\n+            self.fulfillment_cx\n                 .borrow()\n                 .region_obligations(node_id)\n                 .to_vec();\n@@ -364,7 +362,7 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx, 'tcx> {\n \n         // Processing the region obligations should not cause the list to grow further:\n         assert_eq!(region_obligations.len(),\n-                   self.fcx.inh.fulfillment_cx.borrow().region_obligations(node_id).len());\n+                   self.fulfillment_cx.borrow().region_obligations(node_id).len());\n     }\n \n     fn code_to_origin(&self,\n@@ -399,7 +397,7 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx, 'tcx> {\n         for &ty in fn_sig_tys {\n             let ty = self.resolve_type(ty);\n             debug!(\"relate_free_regions(t={:?})\", ty);\n-            let implied_bounds = ty::wf::implied_bounds(self.fcx.infcx(), body_id, ty, span);\n+            let implied_bounds = ty::wf::implied_bounds(self, body_id, ty, span);\n \n             // Record any relations between free regions that we observe into the free-region-map.\n             self.free_region_map.relate_free_regions_from_implied_bounds(&implied_bounds);\n@@ -412,7 +410,7 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx, 'tcx> {\n                 match implication {\n                     ImpliedBound::RegionSubRegion(ty::ReFree(free_a),\n                                                   ty::ReVar(vid_b)) => {\n-                        self.fcx.inh.infcx.add_given(free_a, vid_b);\n+                        self.add_given(free_a, vid_b);\n                     }\n                     ImpliedBound::RegionSubParam(r_a, param_b) => {\n                         self.region_bound_pairs.push((r_a, GenericKind::Param(param_b)));\n@@ -447,12 +445,12 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx, 'tcx> {\n             }\n         };\n \n-        self.fcx.infcx().resolve_regions_and_report_errors(&self.free_region_map,\n-                                                           subject_node_id);\n+        self.fcx.resolve_regions_and_report_errors(&self.free_region_map,\n+                                                   subject_node_id);\n     }\n \n fn constrain_bindings_in_pat(&mut self, pat: &hir::Pat) {\n-    let tcx = self.fcx.tcx();\n+    let tcx = self.tcx;\n     debug!(\"regionck::visit_pat(pat={:?})\", pat);\n     pat_util::pat_bindings(&tcx.def_map, pat, |_, id, span, _| {\n         // If we have a variable that contains region'd data, that\n@@ -528,12 +526,12 @@ fn visit_expr(&mut self, expr: &hir::Expr) {\n     // scope of that expression. This also guarantees basic WF.\n     let expr_ty = self.resolve_node_type(expr.id);\n     // the region corresponding to this expression\n-    let expr_region = ty::ReScope(self.tcx().region_maps.node_extent(expr.id));\n+    let expr_region = ty::ReScope(self.tcx.region_maps.node_extent(expr.id));\n     self.type_must_outlive(infer::ExprTypeIsNotInScope(expr_ty, expr.span),\n                            expr_ty, expr_region);\n \n     let method_call = MethodCall::expr(expr.id);\n-    let opt_method_callee = self.fcx.inh.tables.borrow().method_map.get(&method_call).cloned();\n+    let opt_method_callee = self.tables.borrow().method_map.get(&method_call).cloned();\n     let has_method_map = opt_method_callee.is_some();\n \n     // If we are calling a method (either explicitly or via an\n@@ -556,7 +554,7 @@ fn visit_expr(&mut self, expr: &hir::Expr) {\n     }\n \n     // Check any autoderefs or autorefs that appear.\n-    let adjustment = self.fcx.inh.tables.borrow().adjustments.get(&expr.id).map(|a| a.clone());\n+    let adjustment = self.tables.borrow().adjustments.get(&expr.id).map(|a| a.clone());\n     if let Some(adjustment) = adjustment {\n         debug!(\"adjustment={:?}\", adjustment);\n         match adjustment {\n@@ -592,7 +590,7 @@ fn visit_expr(&mut self, expr: &hir::Expr) {\n         // If necessary, constrain destructors in the unadjusted form of this\n         // expression.\n         let cmt_result = {\n-            let mc = mc::MemCategorizationContext::new(self.fcx.infcx());\n+            let mc = mc::MemCategorizationContext::new(self);\n             mc.cat_expr_unadjusted(expr)\n         };\n         match cmt_result {\n@@ -601,25 +599,23 @@ fn visit_expr(&mut self, expr: &hir::Expr) {\n                                                                     expr.span);\n             }\n             Err(..) => {\n-                let tcx = self.fcx.tcx();\n-                tcx.sess.delay_span_bug(expr.span, \"cat_expr_unadjusted Errd\");\n+                self.tcx.sess.delay_span_bug(expr.span, \"cat_expr_unadjusted Errd\");\n             }\n         }\n     }\n \n     // If necessary, constrain destructors in this expression. This will be\n     // the adjusted form if there is an adjustment.\n     let cmt_result = {\n-        let mc = mc::MemCategorizationContext::new(self.fcx.infcx());\n+        let mc = mc::MemCategorizationContext::new(self);\n         mc.cat_expr(expr)\n     };\n     match cmt_result {\n         Ok(head_cmt) => {\n             self.check_safety_of_rvalue_destructor_if_necessary(head_cmt, expr.span);\n         }\n         Err(..) => {\n-            let tcx = self.fcx.tcx();\n-            tcx.sess.delay_span_bug(expr.span, \"cat_expr Errd\");\n+            self.tcx.sess.delay_span_bug(expr.span, \"cat_expr Errd\");\n         }\n     }\n \n@@ -707,12 +703,12 @@ fn visit_expr(&mut self, expr: &hir::Expr) {\n         hir::ExprUnary(hir::UnDeref, ref base) => {\n             // For *a, the lifetime of a must enclose the deref\n             let method_call = MethodCall::expr(expr.id);\n-            let base_ty = match self.fcx.inh.tables.borrow().method_map.get(&method_call) {\n+            let base_ty = match self.tables.borrow().method_map.get(&method_call) {\n                 Some(method) => {\n                     self.constrain_call(expr, Some(&base),\n                                         None::<hir::Expr>.iter(), true);\n                     let fn_ret = // late-bound regions in overloaded method calls are instantiated\n-                        self.tcx().no_late_bound_regions(&method.ty.fn_ret()).unwrap();\n+                        self.tcx.no_late_bound_regions(&method.ty.fn_ret()).unwrap();\n                     fn_ret.unwrap()\n                 }\n                 None => self.resolve_node_type(base.id)\n@@ -824,7 +820,7 @@ fn constrain_cast(&mut self,\n             /*From:*/ (&ty::TyRef(from_r, ref from_mt),\n             /*To:  */  &ty::TyRef(to_r, ref to_mt)) => {\n                 // Target cannot outlive source, naturally.\n-                self.fcx.infcx().sub_regions(infer::Reborrow(cast_expr.span), *to_r, *from_r);\n+                self.sub_regions(infer::Reborrow(cast_expr.span), *to_r, *from_r);\n                 self.walk_cast(cast_expr, from_mt.ty, to_mt.ty);\n             }\n \n@@ -893,7 +889,7 @@ fn constrain_call<'b, I: Iterator<Item=&'b hir::Expr>>(&mut self,\n     // call occurs.\n     //\n     // FIXME(#6268) to support nested method calls, should be callee_id\n-    let callee_scope = self.tcx().region_maps.node_extent(call_expr.id);\n+    let callee_scope = self.tcx.region_maps.node_extent(call_expr.id);\n     let callee_region = ty::ReScope(callee_scope);\n \n     debug!(\"callee_region={:?}\", callee_region);\n@@ -938,13 +934,13 @@ fn constrain_autoderefs(&mut self,\n            derefs,\n            derefd_ty);\n \n-    let s_deref_expr = self.tcx().region_maps.node_extent(deref_expr.id);\n+    let s_deref_expr = self.tcx.region_maps.node_extent(deref_expr.id);\n     let r_deref_expr = ty::ReScope(s_deref_expr);\n     for i in 0..derefs {\n         let method_call = MethodCall::autoderef(deref_expr.id, i as u32);\n         debug!(\"constrain_autoderefs: method_call={:?} (of {:?} total)\", method_call, derefs);\n \n-        let method = self.fcx.inh.tables.borrow().method_map.get(&method_call).map(|m| m.clone());\n+        let method = self.tables.borrow().method_map.get(&method_call).map(|m| m.clone());\n \n         derefd_ty = match method {\n             Some(method) => {\n@@ -958,7 +954,7 @@ fn constrain_autoderefs(&mut self,\n                 // was applied on the base type, as that is always the case.\n                 let fn_sig = method.ty.fn_sig();\n                 let fn_sig = // late-bound regions should have been instantiated\n-                    self.tcx().no_late_bound_regions(fn_sig).unwrap();\n+                    self.tcx.no_late_bound_regions(fn_sig).unwrap();\n                 let self_ty = fn_sig.inputs[0];\n                 let (m, r) = match self_ty.sty {\n                     ty::TyRef(r, ref m) => (m.mutbl, r),\n@@ -974,7 +970,7 @@ fn constrain_autoderefs(&mut self,\n                        r, m);\n \n                 {\n-                    let mc = mc::MemCategorizationContext::new(self.fcx.infcx());\n+                    let mc = mc::MemCategorizationContext::new(self);\n                     let self_cmt = ignore_err!(mc.cat_expr_autoderefd(deref_expr, i));\n                     debug!(\"constrain_autoderefs: self_cmt={:?}\",\n                            self_cmt);\n@@ -1015,8 +1011,8 @@ pub fn mk_subregion_due_to_dereference(&mut self,\n                                        deref_span: Span,\n                                        minimum_lifetime: ty::Region,\n                                        maximum_lifetime: ty::Region) {\n-    self.fcx.infcx().sub_regions(infer::DerefPointer(deref_span),\n-                                 minimum_lifetime, maximum_lifetime)\n+    self.sub_regions(infer::DerefPointer(deref_span),\n+                     minimum_lifetime, maximum_lifetime)\n }\n \n fn check_safety_of_rvalue_destructor_if_necessary(&mut self,\n@@ -1052,14 +1048,14 @@ fn constrain_index(&mut self,\n                    indexed_ty: Ty<'tcx>)\n {\n     debug!(\"constrain_index(index_expr=?, indexed_ty={}\",\n-           self.fcx.infcx().ty_to_string(indexed_ty));\n+           self.ty_to_string(indexed_ty));\n \n-    let r_index_expr = ty::ReScope(self.tcx().region_maps.node_extent(index_expr.id));\n+    let r_index_expr = ty::ReScope(self.tcx.region_maps.node_extent(index_expr.id));\n     if let ty::TyRef(r_ptr, mt) = indexed_ty.sty {\n         match mt.ty.sty {\n             ty::TySlice(_) | ty::TyStr => {\n-                self.fcx.infcx().sub_regions(infer::IndexSlice(index_expr.span),\n-                                             r_index_expr, *r_ptr);\n+                self.sub_regions(infer::IndexSlice(index_expr.span),\n+                                 r_index_expr, *r_ptr);\n             }\n             _ => {}\n         }\n@@ -1073,14 +1069,14 @@ fn type_of_node_must_outlive(&mut self,\n     id: ast::NodeId,\n     minimum_lifetime: ty::Region)\n {\n-    let tcx = self.fcx.tcx();\n+    let tcx = self.tcx;\n \n     // Try to resolve the type.  If we encounter an error, then typeck\n     // is going to fail anyway, so just stop here and let typeck\n     // report errors later on in the writeback phase.\n     let ty0 = self.resolve_node_type(id);\n     let ty = ty0.adjust(tcx, origin.span(), id,\n-                        self.fcx.inh.tables.borrow().adjustments.get(&id),\n+                        self.tables.borrow().adjustments.get(&id),\n                         |method_call| self.resolve_method_type(method_call));\n     debug!(\"constrain_regions_in_type_of_node(\\\n             ty={}, ty0={}, id={}, minimum_lifetime={:?})\",\n@@ -1096,7 +1092,7 @@ fn link_addr_of(&mut self, expr: &hir::Expr,\n     debug!(\"link_addr_of(expr={:?}, base={:?})\", expr, base);\n \n     let cmt = {\n-        let mc = mc::MemCategorizationContext::new(self.fcx.infcx());\n+        let mc = mc::MemCategorizationContext::new(self);\n         ignore_err!(mc.cat_expr(base))\n     };\n \n@@ -1114,7 +1110,7 @@ fn link_local(&self, local: &hir::Local) {\n         None => { return; }\n         Some(ref expr) => &**expr,\n     };\n-    let mc = mc::MemCategorizationContext::new(self.fcx.infcx());\n+    let mc = mc::MemCategorizationContext::new(self);\n     let discr_cmt = ignore_err!(mc.cat_expr(init_expr));\n     self.link_pattern(mc, discr_cmt, &local.pat);\n }\n@@ -1124,7 +1120,7 @@ fn link_local(&self, local: &hir::Local) {\n /// linked to the lifetime of its guarantor (if any).\n fn link_match(&self, discr: &hir::Expr, arms: &[hir::Arm]) {\n     debug!(\"regionck::for_match()\");\n-    let mc = mc::MemCategorizationContext::new(self.fcx.infcx());\n+    let mc = mc::MemCategorizationContext::new(self);\n     let discr_cmt = ignore_err!(mc.cat_expr(discr));\n     debug!(\"discr_cmt={:?}\", discr_cmt);\n     for arm in arms {\n@@ -1139,9 +1135,9 @@ fn link_match(&self, discr: &hir::Expr, arms: &[hir::Arm]) {\n /// linked to the lifetime of its guarantor (if any).\n fn link_fn_args(&self, body_scope: CodeExtent, args: &[hir::Arg]) {\n     debug!(\"regionck::link_fn_args(body_scope={:?})\", body_scope);\n-    let mc = mc::MemCategorizationContext::new(self.fcx.infcx());\n+    let mc = mc::MemCategorizationContext::new(self);\n     for arg in args {\n-        let arg_ty = self.fcx.node_ty(arg.id);\n+        let arg_ty = self.node_ty(arg.id);\n         let re_scope = ty::ReScope(body_scope);\n         let arg_cmt = mc.cat_rvalue(arg.id, arg.ty.span, re_scope, arg_ty);\n         debug!(\"arg_ty={:?} arg_cmt={:?} arg={:?}\",\n@@ -1193,7 +1189,7 @@ fn link_autoref(&self,\n                 autoref: &adjustment::AutoRef)\n {\n     debug!(\"link_autoref(autoref={:?})\", autoref);\n-    let mc = mc::MemCategorizationContext::new(self.fcx.infcx());\n+    let mc = mc::MemCategorizationContext::new(self);\n     let expr_cmt = ignore_err!(mc.cat_expr_autoderefd(expr, autoderefs));\n     debug!(\"expr_cmt={:?}\", expr_cmt);\n \n@@ -1204,7 +1200,7 @@ fn link_autoref(&self,\n         }\n \n         adjustment::AutoUnsafe(m) => {\n-            let r = ty::ReScope(self.tcx().region_maps.node_extent(expr.id));\n+            let r = ty::ReScope(self.tcx.region_maps.node_extent(expr.id));\n             self.link_region(expr.span, &r, ty::BorrowKind::from_mutbl(m), expr_cmt);\n         }\n     }\n@@ -1217,7 +1213,7 @@ fn link_by_ref(&self,\n                callee_scope: CodeExtent) {\n     debug!(\"link_by_ref(expr={:?}, callee_scope={:?})\",\n            expr, callee_scope);\n-    let mc = mc::MemCategorizationContext::new(self.fcx.infcx());\n+    let mc = mc::MemCategorizationContext::new(self);\n     let expr_cmt = ignore_err!(mc.cat_expr(expr));\n     let borrow_region = ty::ReScope(callee_scope);\n     self.link_region(expr.span, &borrow_region, ty::ImmBorrow, expr_cmt);\n@@ -1357,7 +1353,7 @@ fn link_reborrowed_region(&self,\n     // Detect by-ref upvar `x`:\n     let cause = match note {\n         mc::NoteUpvarRef(ref upvar_id) => {\n-            let upvar_capture_map = &self.fcx.inh.tables.borrow_mut().upvar_capture_map;\n+            let upvar_capture_map = &self.tables.borrow_mut().upvar_capture_map;\n             match upvar_capture_map.get(upvar_id) {\n                 Some(&ty::UpvarCapture::ByRef(ref upvar_borrow)) => {\n                     // The mutability of the upvar may have been modified\n@@ -1385,7 +1381,7 @@ fn link_reborrowed_region(&self,\n     debug!(\"link_reborrowed_region: {:?} <= {:?}\",\n            borrow_region,\n            ref_region);\n-    self.fcx.infcx().sub_regions(cause, *borrow_region, ref_region);\n+    self.sub_regions(cause, *borrow_region, ref_region);\n \n     // If we end up needing to recurse and establish a region link\n     // with `ref_cmt`, calculate what borrow kind we will end up\n@@ -1467,7 +1463,7 @@ fn substs_wf_in_scope(&mut self,\n     let origin = infer::ParameterInScope(origin, expr_span);\n \n     for &region in &substs.regions {\n-        self.fcx.infcx().sub_regions(origin.clone(), expr_region, region);\n+        self.sub_regions(origin.clone(), expr_region, region);\n     }\n \n     for &ty in &substs.types {\n@@ -1493,7 +1489,7 @@ pub fn type_must_outlive(&self,\n \n     assert!(!ty.has_escaping_regions());\n \n-    let components = self.infcx().outlives_components(ty);\n+    let components = self.outlives_components(ty);\n     self.components_must_outlive(origin, components, region);\n }\n \n@@ -1506,7 +1502,7 @@ fn components_must_outlive(&self,\n         let origin = origin.clone();\n         match component {\n             ty::outlives::Component::Region(region1) => {\n-                self.fcx.infcx().sub_regions(origin, region, region1);\n+                self.sub_regions(origin, region, region1);\n             }\n             ty::outlives::Component::Param(param_ty) => {\n                 self.param_ty_must_outlive(origin, region, param_ty);\n@@ -1521,7 +1517,7 @@ fn components_must_outlive(&self,\n                 // ignore this, we presume it will yield an error\n                 // later, since if a type variable is not resolved by\n                 // this point it never will be\n-                self.tcx().sess.delay_span_bug(\n+                self.tcx.sess.delay_span_bug(\n                     origin.span(),\n                     &format!(\"unresolved inference variable in outlives: {:?}\", v));\n             }\n@@ -1538,7 +1534,7 @@ fn param_ty_must_outlive(&self,\n \n     let verify_bound = self.param_bound(param_ty);\n     let generic = GenericKind::Param(param_ty);\n-    self.fcx.infcx().verify_generic_bound(origin, generic, region, verify_bound);\n+    self.verify_generic_bound(origin, generic, region, verify_bound);\n }\n \n fn projection_must_outlive(&self,\n@@ -1604,7 +1600,7 @@ fn projection_must_outlive(&self,\n         }\n \n         for &r in &projection_ty.trait_ref.substs.regions {\n-            self.fcx.infcx().sub_regions(origin.clone(), region, r);\n+            self.sub_regions(origin.clone(), region, r);\n         }\n \n         return;\n@@ -1625,7 +1621,7 @@ fn projection_must_outlive(&self,\n                                          .any(|r| env_bounds.contains(r))\n         {\n             debug!(\"projection_must_outlive: unique declared bound appears in trait ref\");\n-            self.fcx.infcx().sub_regions(origin.clone(), region, unique_bound);\n+            self.sub_regions(origin.clone(), region, unique_bound);\n             return;\n         }\n     }\n@@ -1637,7 +1633,7 @@ fn projection_must_outlive(&self,\n     // even though a satisfactory solution exists.\n     let verify_bound = self.projection_bound(origin.span(), env_bounds, projection_ty);\n     let generic = GenericKind::Projection(projection_ty);\n-    self.fcx.infcx().verify_generic_bound(origin, generic.clone(), region, verify_bound);\n+    self.verify_generic_bound(origin, generic.clone(), region, verify_bound);\n }\n \n fn type_bound(&self, span: Span, ty: Ty<'tcx>) -> VerifyBound {\n@@ -1656,7 +1652,7 @@ fn type_bound(&self, span: Span, ty: Ty<'tcx>) -> VerifyBound {\n }\n \n fn param_bound(&self, param_ty: ty::ParamTy) -> VerifyBound {\n-    let param_env = &self.infcx().parameter_environment;\n+    let param_env = &self.parameter_environment;\n \n     debug!(\"param_bound(param_ty={:?})\",\n            param_ty);\n@@ -1696,7 +1692,7 @@ fn projection_bound(&self,\n \n     // see the extensive comment in projection_must_outlive\n \n-    let ty = self.tcx().mk_projection(projection_ty.trait_ref, projection_ty.item_name);\n+    let ty = self.tcx.mk_projection(projection_ty.trait_ref, projection_ty.item_name);\n     let recursive_bound = self.recursive_type_bound(span, ty);\n \n     VerifyBound::AnyRegion(declared_bounds).or(recursive_bound)\n@@ -1726,11 +1722,11 @@ fn recursive_type_bound(&self, span: Span, ty: Ty<'tcx>) -> VerifyBound {\n fn declared_generic_bounds_from_env(&self, generic: GenericKind<'tcx>)\n                                     -> Vec<ty::Region>\n {\n-    let param_env = &self.infcx().parameter_environment;\n+    let param_env = &self.parameter_environment;\n \n     // To start, collect bounds from user:\n-    let mut param_bounds = self.tcx().required_region_bounds(generic.to_ty(self.tcx()),\n-                                                             param_env.caller_bounds.clone());\n+    let mut param_bounds = self.tcx.required_region_bounds(generic.to_ty(self.tcx),\n+                                                           param_env.caller_bounds.clone());\n \n     // Next, collect regions we scraped from the well-formedness\n     // constraints in the fn signature. To do that, we walk the list\n@@ -1760,14 +1756,11 @@ fn declared_projection_bounds_from_trait(&self,\n                                          projection_ty: ty::ProjectionTy<'tcx>)\n                                          -> Vec<ty::Region>\n {\n-    let fcx = self.fcx;\n-    let tcx = fcx.tcx();\n-    let infcx = fcx.infcx();\n-\n     debug!(\"projection_bounds(projection_ty={:?})\",\n            projection_ty);\n \n-    let ty = tcx.mk_projection(projection_ty.trait_ref.clone(), projection_ty.item_name);\n+    let ty = self.tcx.mk_projection(projection_ty.trait_ref.clone(),\n+                                    projection_ty.item_name);\n \n     // Say we have a projection `<T as SomeTrait<'a>>::SomeType`. We are interested\n     // in looking for a trait definition like:\n@@ -1779,9 +1772,9 @@ fn declared_projection_bounds_from_trait(&self,\n     // ```\n     //\n     // we can thus deduce that `<T as SomeTrait<'a>>::SomeType : 'a`.\n-    let trait_predicates = tcx.lookup_predicates(projection_ty.trait_ref.def_id);\n+    let trait_predicates = self.tcx.lookup_predicates(projection_ty.trait_ref.def_id);\n     let predicates = trait_predicates.predicates.as_slice().to_vec();\n-    traits::elaborate_predicates(tcx, predicates)\n+    traits::elaborate_predicates(self.tcx, predicates)\n         .filter_map(|predicate| {\n             // we're only interesting in `T : 'a` style predicates:\n             let outlives = match predicate {\n@@ -1793,16 +1786,16 @@ fn declared_projection_bounds_from_trait(&self,\n                    outlives);\n \n             // apply the substitutions (and normalize any projected types)\n-            let outlives = fcx.instantiate_type_scheme(span,\n-                                                       projection_ty.trait_ref.substs,\n-                                                       &outlives);\n+            let outlives = self.instantiate_type_scheme(span,\n+                                                        projection_ty.trait_ref.substs,\n+                                                        &outlives);\n \n             debug!(\"projection_bounds: outlives={:?} (2)\",\n                    outlives);\n \n-            let region_result = infcx.commit_if_ok(|_| {\n+            let region_result = self.commit_if_ok(|_| {\n                 let (outlives, _) =\n-                    infcx.replace_late_bound_regions_with_fresh_var(\n+                    self.replace_late_bound_regions_with_fresh_var(\n                         span,\n                         infer::AssocTypeProjection(projection_ty.item_name),\n                         &outlives);\n@@ -1811,7 +1804,7 @@ fn declared_projection_bounds_from_trait(&self,\n                        outlives);\n \n                 // check whether this predicate applies to our current projection\n-                match infcx.eq_types(false, TypeOrigin::Misc(span), ty, outlives.0) {\n+                match self.eq_types(false, TypeOrigin::Misc(span), ty, outlives.0) {\n                     Ok(InferOk { obligations, .. }) => {\n                         // FIXME(#32730) propagate obligations\n                         assert!(obligations.is_empty());"}, {"sha": "175171e2f2ad90f8e01cfb00f995891addb1a6ef", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 19, "deletions": 27, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/0053b442f8cd5bf5e310a2664fc3a47a8f33da71/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0053b442f8cd5bf5e310a2664fc3a47a8f33da71/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=0053b442f8cd5bf5e310a2664fc3a47a8f33da71", "patch": "@@ -45,8 +45,8 @@ use super::FnCtxt;\n use middle::expr_use_visitor as euv;\n use middle::mem_categorization as mc;\n use middle::mem_categorization::Categorization;\n-use rustc::ty::{self, Ty, TyCtxt};\n-use rustc::infer::{InferCtxt, UpvarRegion};\n+use rustc::ty::{self, Ty};\n+use rustc::infer::UpvarRegion;\n use std::collections::HashSet;\n use syntax::ast;\n use syntax::codemap::Span;\n@@ -66,7 +66,7 @@ pub fn closure_analyze_fn(&self, body: &hir::Block) {\n     adjust.visit_block(body);\n \n     // it's our job to process these.\n-    assert!(self.inh.deferred_call_resolutions.borrow().is_empty());\n+    assert!(self.deferred_call_resolutions.borrow().is_empty());\n }\n \n pub fn closure_analyze_const(&self, body: &hir::Expr) {\n@@ -78,7 +78,7 @@ pub fn closure_analyze_const(&self, body: &hir::Expr) {\n     adjust.visit_expr(body);\n \n     // it's our job to process these.\n-    assert!(self.inh.deferred_call_resolutions.borrow().is_empty());\n+    assert!(self.deferred_call_resolutions.borrow().is_empty());\n }\n }\n \n@@ -109,29 +109,21 @@ impl<'a,'tcx> SeedBorrowKind<'a,'tcx, 'tcx> {\n         SeedBorrowKind { fcx: fcx, closures_with_inferred_kinds: HashSet::new() }\n     }\n \n-    fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx> {\n-        self.fcx.tcx()\n-    }\n-\n-    fn infcx(&self) -> &'a InferCtxt<'a,'tcx, 'tcx> {\n-        self.fcx.infcx()\n-    }\n-\n     fn check_closure(&mut self,\n                      expr: &hir::Expr,\n                      capture_clause: hir::CaptureClause,\n                      _body: &hir::Block)\n     {\n-        let closure_def_id = self.tcx().map.local_def_id(expr.id);\n-        if !self.fcx.inh.tables.borrow().closure_kinds.contains_key(&closure_def_id) {\n+        let closure_def_id = self.fcx.tcx.map.local_def_id(expr.id);\n+        if !self.fcx.tables.borrow().closure_kinds.contains_key(&closure_def_id) {\n             self.closures_with_inferred_kinds.insert(expr.id);\n-            self.fcx.inh.tables.borrow_mut().closure_kinds\n-                                            .insert(closure_def_id, ty::ClosureKind::Fn);\n+            self.fcx.tables.borrow_mut().closure_kinds\n+                                        .insert(closure_def_id, ty::ClosureKind::Fn);\n             debug!(\"check_closure: adding closure_id={:?} to closures_with_inferred_kinds\",\n                    closure_def_id);\n         }\n \n-        self.tcx().with_freevars(expr.id, |freevars| {\n+        self.fcx.tcx.with_freevars(expr.id, |freevars| {\n             for freevar in freevars {\n                 let var_node_id = freevar.def.var_id();\n                 let upvar_id = ty::UpvarId { var_id: var_node_id,\n@@ -144,14 +136,14 @@ impl<'a,'tcx> SeedBorrowKind<'a,'tcx, 'tcx> {\n                     }\n                     hir::CaptureByRef => {\n                         let origin = UpvarRegion(upvar_id, expr.span);\n-                        let freevar_region = self.infcx().next_region_var(origin);\n+                        let freevar_region = self.fcx.next_region_var(origin);\n                         let upvar_borrow = ty::UpvarBorrow { kind: ty::ImmBorrow,\n                                                              region: freevar_region };\n                         ty::UpvarCapture::ByRef(upvar_borrow)\n                     }\n                 };\n \n-                self.fcx.inh.tables.borrow_mut().upvar_capture_map.insert(upvar_id, capture_kind);\n+                self.fcx.tables.borrow_mut().upvar_capture_map.insert(upvar_id, capture_kind);\n             }\n         });\n     }\n@@ -184,7 +176,7 @@ impl<'a,'tcx> AdjustBorrowKind<'a,'tcx, 'tcx> {\n         debug!(\"analyze_closure(id={:?}, body.id={:?})\", id, body.id);\n \n         {\n-            let mut euv = euv::ExprUseVisitor::new(self, self.fcx.infcx());\n+            let mut euv = euv::ExprUseVisitor::new(self, self.fcx);\n             euv.walk_fn(decl, body);\n         }\n \n@@ -221,7 +213,7 @@ impl<'a,'tcx> AdjustBorrowKind<'a,'tcx, 'tcx> {\n \n         // Now we must process and remove any deferred resolutions,\n         // since we have a concrete closure kind.\n-        let closure_def_id = self.fcx.tcx().map.local_def_id(id);\n+        let closure_def_id = self.fcx.tcx.map.local_def_id(id);\n         if self.closures_with_inferred_kinds.contains(&id) {\n             let mut deferred_call_resolutions =\n                 self.fcx.remove_deferred_call_resolutions(closure_def_id);\n@@ -238,7 +230,7 @@ impl<'a,'tcx> AdjustBorrowKind<'a,'tcx, 'tcx> {\n         // local crate or were inlined into it along with some function.\n         // This may change if abstract return types of some sort are\n         // implemented.\n-        let tcx = self.fcx.tcx();\n+        let tcx = self.fcx.tcx;\n         tcx.with_freevars(closure_id, |freevars| {\n             freevars.iter()\n                     .map(|freevar| {\n@@ -248,7 +240,7 @@ impl<'a,'tcx> AdjustBorrowKind<'a,'tcx, 'tcx> {\n                             var_id: freevar_node_id,\n                             closure_expr_id: closure_id\n                         };\n-                        let capture = self.fcx.infcx().upvar_capture(upvar_id).unwrap();\n+                        let capture = self.fcx.upvar_capture(upvar_id).unwrap();\n \n                         debug!(\"freevar_node_id={:?} freevar_ty={:?} capture={:?}\",\n                                freevar_node_id, freevar_ty, capture);\n@@ -299,7 +291,7 @@ impl<'a,'tcx> AdjustBorrowKind<'a,'tcx, 'tcx> {\n                         self.adjust_closure_kind(upvar_id.closure_expr_id, ty::ClosureKind::FnOnce);\n \n                         let upvar_capture_map =\n-                            &mut self.fcx.inh.tables.borrow_mut().upvar_capture_map;\n+                            &mut self.fcx.tables.borrow_mut().upvar_capture_map;\n                         upvar_capture_map.insert(upvar_id, ty::UpvarCapture::ByValue);\n                     }\n                     mc::NoteClosureEnv(upvar_id) => {\n@@ -407,7 +399,7 @@ impl<'a,'tcx> AdjustBorrowKind<'a,'tcx, 'tcx> {\n                 // borrow_kind of the upvar to make sure it\n                 // is inferred to mutable if necessary\n                 {\n-                    let upvar_capture_map = &mut self.fcx.inh.tables.borrow_mut().upvar_capture_map;\n+                    let upvar_capture_map = &mut self.fcx.tables.borrow_mut().upvar_capture_map;\n                     let ub = upvar_capture_map.get_mut(&upvar_id).unwrap();\n                     self.adjust_upvar_borrow_kind(upvar_id, ub, borrow_kind);\n                 }\n@@ -475,8 +467,8 @@ impl<'a,'tcx> AdjustBorrowKind<'a,'tcx, 'tcx> {\n             return;\n         }\n \n-        let closure_def_id = self.fcx.tcx().map.local_def_id(closure_id);\n-        let closure_kinds = &mut self.fcx.inh.tables.borrow_mut().closure_kinds;\n+        let closure_def_id = self.fcx.tcx.map.local_def_id(closure_id);\n+        let closure_kinds = &mut self.fcx.tables.borrow_mut().closure_kinds;\n         let existing_kind = *closure_kinds.get(&closure_def_id).unwrap();\n \n         debug!(\"adjust_closure_kind: closure_id={}, existing_kind={:?}, new_kind={:?}\","}, {"sha": "7ac4e1913ab81bc41b080ff0f13e779812dcd6cf", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 40, "deletions": 43, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/0053b442f8cd5bf5e310a2664fc3a47a8f33da71/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0053b442f8cd5bf5e310a2664fc3a47a8f33da71/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=0053b442f8cd5bf5e310a2664fc3a47a8f33da71", "patch": "@@ -130,15 +130,15 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n     fn check_trait_or_impl_item(&mut self, item_id: ast::NodeId, span: Span) {\n         let code = self.code.clone();\n         self.with_fcx(item_id, span, |fcx, this| {\n-            let free_substs = &fcx.inh.infcx.parameter_environment.free_substs;\n-            let free_id_outlive = fcx.inh.infcx.parameter_environment.free_id_outlive;\n+            let free_substs = &fcx.parameter_environment.free_substs;\n+            let free_id_outlive = fcx.parameter_environment.free_id_outlive;\n \n-            let item = fcx.tcx().impl_or_trait_item(fcx.tcx().map.local_def_id(item_id));\n+            let item = fcx.tcx.impl_or_trait_item(fcx.tcx.map.local_def_id(item_id));\n \n             let (mut implied_bounds, self_ty) = match item.container() {\n-                ty::TraitContainer(_) => (vec![], fcx.tcx().mk_self_type()),\n+                ty::TraitContainer(_) => (vec![], fcx.tcx.mk_self_type()),\n                 ty::ImplContainer(def_id) => (fcx.impl_implied_bounds(def_id, span),\n-                                              fcx.tcx().lookup_item_type(def_id).ty)\n+                                              fcx.tcx.lookup_item_type(def_id).ty)\n             };\n \n             match item {\n@@ -147,7 +147,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n                     fcx.register_wf_obligation(ty, span, code.clone());\n                 }\n                 ty::MethodTraitItem(method) => {\n-                    reject_shadowing_type_parameters(fcx.tcx(), span, &method.generics);\n+                    reject_shadowing_type_parameters(fcx.tcx, span, &method.generics);\n                     let method_ty = fcx.instantiate_type_scheme(span, free_substs, &method.fty);\n                     let predicates = fcx.instantiate_bounds(span, free_substs, &method.predicates);\n                     this.check_fn_or_method(fcx, span, &method_ty, &predicates,\n@@ -181,8 +181,8 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n         let ccx = self.ccx;\n         let param_env = ty::ParameterEnvironment::for_item(ccx.tcx, id);\n         let tables = RefCell::new(ty::Tables::empty());\n-        let inh = Inherited::new(ccx.tcx, &tables, param_env);\n-        let fcx = FnCtxt::new(ccx, &inh, ty::FnDiverging, id);\n+        let inh = Inherited::new(ccx, &tables, param_env);\n+        let fcx = FnCtxt::new(&inh, ty::FnDiverging, id);\n         let wf_tys = f(&fcx, self);\n         fcx.select_all_obligations_or_error();\n         fcx.regionck_item(id, span, &wf_tys);\n@@ -214,8 +214,8 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n                 }\n             }\n \n-            let free_substs = &fcx.inh.infcx.parameter_environment.free_substs;\n-            let predicates = fcx.tcx().lookup_predicates(fcx.tcx().map.local_def_id(item.id));\n+            let free_substs = &fcx.parameter_environment.free_substs;\n+            let predicates = fcx.tcx.lookup_predicates(fcx.tcx.map.local_def_id(item.id));\n             let predicates = fcx.instantiate_bounds(item.span, free_substs, &predicates);\n             this.check_where_clauses(fcx, item.span, &predicates);\n \n@@ -236,8 +236,8 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n         }\n \n         self.with_item_fcx(item, |fcx, this| {\n-            let free_substs = &fcx.inh.infcx.parameter_environment.free_substs;\n-            let predicates = fcx.tcx().lookup_predicates(trait_def_id);\n+            let free_substs = &fcx.parameter_environment.free_substs;\n+            let predicates = fcx.tcx.lookup_predicates(trait_def_id);\n             let predicates = fcx.instantiate_bounds(item.span, free_substs, &predicates);\n             this.check_where_clauses(fcx, item.span, &predicates);\n             vec![]\n@@ -249,8 +249,8 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n                      body: &hir::Block)\n     {\n         self.with_item_fcx(item, |fcx, this| {\n-            let free_substs = &fcx.inh.infcx.parameter_environment.free_substs;\n-            let type_scheme = fcx.tcx().lookup_item_type(fcx.tcx().map.local_def_id(item.id));\n+            let free_substs = &fcx.parameter_environment.free_substs;\n+            let type_scheme = fcx.tcx.lookup_item_type(fcx.tcx.map.local_def_id(item.id));\n             let item_ty = fcx.instantiate_type_scheme(item.span, free_substs, &type_scheme.ty);\n             let bare_fn_ty = match item_ty.sty {\n                 ty::TyFnDef(_, _, ref bare_fn_ty) => bare_fn_ty,\n@@ -259,11 +259,11 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n                 }\n             };\n \n-            let predicates = fcx.tcx().lookup_predicates(fcx.tcx().map.local_def_id(item.id));\n+            let predicates = fcx.tcx.lookup_predicates(fcx.tcx.map.local_def_id(item.id));\n             let predicates = fcx.instantiate_bounds(item.span, free_substs, &predicates);\n \n             let mut implied_bounds = vec![];\n-            let free_id_outlive = fcx.tcx().region_maps.call_site_extent(item.id, body.id);\n+            let free_id_outlive = fcx.tcx.region_maps.call_site_extent(item.id, body.id);\n             this.check_fn_or_method(fcx, item.span, bare_fn_ty, &predicates,\n                                     free_id_outlive, &mut implied_bounds);\n             implied_bounds\n@@ -276,11 +276,9 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n         debug!(\"check_item_type: {:?}\", item);\n \n         self.with_item_fcx(item, |fcx, this| {\n-            let type_scheme = fcx.tcx().lookup_item_type(fcx.tcx().map.local_def_id(item.id));\n+            let type_scheme = fcx.tcx.lookup_item_type(fcx.tcx.map.local_def_id(item.id));\n             let item_ty = fcx.instantiate_type_scheme(item.span,\n-                                                      &fcx.inh\n-                                                          .infcx\n-                                                          .parameter_environment\n+                                                      &fcx.parameter_environment\n                                                           .free_substs,\n                                                       &type_scheme.ty);\n \n@@ -298,17 +296,17 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n         debug!(\"check_impl: {:?}\", item);\n \n         self.with_item_fcx(item, |fcx, this| {\n-            let free_substs = &fcx.inh.infcx.parameter_environment.free_substs;\n-            let item_def_id = fcx.tcx().map.local_def_id(item.id);\n+            let free_substs = &fcx.parameter_environment.free_substs;\n+            let item_def_id = fcx.tcx.map.local_def_id(item.id);\n \n             match *ast_trait_ref {\n                 Some(ref ast_trait_ref) => {\n-                    let trait_ref = fcx.tcx().impl_trait_ref(item_def_id).unwrap();\n+                    let trait_ref = fcx.tcx.impl_trait_ref(item_def_id).unwrap();\n                     let trait_ref =\n                         fcx.instantiate_type_scheme(\n                             ast_trait_ref.path.span, free_substs, &trait_ref);\n                     let obligations =\n-                        ty::wf::trait_obligations(fcx.infcx(),\n+                        ty::wf::trait_obligations(fcx,\n                                                   fcx.body_id,\n                                                   &trait_ref,\n                                                   ast_trait_ref.path.span);\n@@ -317,17 +315,17 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n                     }\n                 }\n                 None => {\n-                    let self_ty = fcx.tcx().node_id_to_type(item.id);\n+                    let self_ty = fcx.tcx.node_id_to_type(item.id);\n                     let self_ty = fcx.instantiate_type_scheme(item.span, free_substs, &self_ty);\n                     fcx.register_wf_obligation(self_ty, ast_self_ty.span, this.code.clone());\n                 }\n             }\n \n-            let predicates = fcx.tcx().lookup_predicates(item_def_id);\n+            let predicates = fcx.tcx.lookup_predicates(item_def_id);\n             let predicates = fcx.instantiate_bounds(item.span, free_substs, &predicates);\n             this.check_where_clauses(fcx, item.span, &predicates);\n \n-            fcx.impl_implied_bounds(fcx.tcx().map.local_def_id(item.id), item.span)\n+            fcx.impl_implied_bounds(fcx.tcx.map.local_def_id(item.id), item.span)\n         });\n     }\n \n@@ -339,7 +337,7 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n         let obligations =\n             predicates.predicates\n                       .iter()\n-                      .flat_map(|p| ty::wf::predicate_obligations(fcx.infcx(),\n+                      .flat_map(|p| ty::wf::predicate_obligations(fcx,\n                                                                   fcx.body_id,\n                                                                   p,\n                                                                   span));\n@@ -357,9 +355,9 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n                                 free_id_outlive: CodeExtent,\n                                 implied_bounds: &mut Vec<Ty<'tcx>>)\n     {\n-        let free_substs = &fcx.inh.infcx.parameter_environment.free_substs;\n+        let free_substs = &fcx.parameter_environment.free_substs;\n         let fty = fcx.instantiate_type_scheme(span, free_substs, fty);\n-        let sig = fcx.tcx().liberate_late_bound_regions(free_id_outlive, &fty.sig);\n+        let sig = fcx.tcx.liberate_late_bound_regions(free_id_outlive, &fty.sig);\n \n         for &input_ty in &sig.inputs {\n             fcx.register_wf_obligation(input_ty, span, self.code.clone());\n@@ -389,9 +387,9 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n         // check that the type of the method's receiver matches the\n         // method's first parameter.\n \n-        let free_substs = &fcx.inh.infcx.parameter_environment.free_substs;\n+        let free_substs = &fcx.parameter_environment.free_substs;\n         let fty = fcx.instantiate_type_scheme(span, free_substs, &method.fty);\n-        let sig = fcx.tcx().liberate_late_bound_regions(free_id_outlive, &fty.sig);\n+        let sig = fcx.tcx.liberate_late_bound_regions(free_id_outlive, &fty.sig);\n \n         debug!(\"check_method_receiver({:?},cat={:?},self_ty={:?},sig={:?})\",\n                method.name, method.explicit_self, self_ty, sig);\n@@ -400,21 +398,21 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n             ty::ExplicitSelfCategory::Static => return,\n             ty::ExplicitSelfCategory::ByValue => self_ty,\n             ty::ExplicitSelfCategory::ByReference(region, mutability) => {\n-                fcx.tcx().mk_ref(fcx.tcx().mk_region(region), ty::TypeAndMut {\n+                fcx.tcx.mk_ref(fcx.tcx.mk_region(region), ty::TypeAndMut {\n                     ty: self_ty,\n                     mutbl: mutability\n                 })\n             }\n-            ty::ExplicitSelfCategory::ByBox => fcx.tcx().mk_box(self_ty)\n+            ty::ExplicitSelfCategory::ByBox => fcx.tcx.mk_box(self_ty)\n         };\n         let rcvr_ty = fcx.instantiate_type_scheme(span, free_substs, &rcvr_ty);\n-        let rcvr_ty = fcx.tcx().liberate_late_bound_regions(free_id_outlive,\n-                                                            &ty::Binder(rcvr_ty));\n+        let rcvr_ty = fcx.tcx.liberate_late_bound_regions(free_id_outlive,\n+                                                          &ty::Binder(rcvr_ty));\n \n         debug!(\"check_method_receiver: receiver ty = {:?}\", rcvr_ty);\n \n         let _ = ::require_same_types(\n-            fcx.ccx, Some(fcx.infcx()), span,\n+            fcx.ccx, Some(fcx), span,\n             sig.inputs[0], rcvr_ty,\n             \"mismatched method receiver\");\n     }\n@@ -559,10 +557,9 @@ fn struct_variant(&self, struct_def: &hir::VariantData) -> AdtVariant<'tcx> {\n     let fields =\n         struct_def.fields().iter()\n         .map(|field| {\n-            let field_ty = self.tcx().node_id_to_type(field.id);\n+            let field_ty = self.tcx.node_id_to_type(field.id);\n             let field_ty = self.instantiate_type_scheme(field.span,\n-                                                        &self.infcx()\n-                                                             .parameter_environment\n+                                                        &self.parameter_environment\n                                                              .free_substs,\n                                                         &field_ty);\n             AdtField { ty: field_ty, span: field.span }\n@@ -578,8 +575,8 @@ fn enum_variants(&self, enum_def: &hir::EnumDef) -> Vec<AdtVariant<'tcx>> {\n }\n \n fn impl_implied_bounds(&self, impl_def_id: DefId, span: Span) -> Vec<Ty<'tcx>> {\n-    let free_substs = &self.inh.infcx.parameter_environment.free_substs;\n-    match self.tcx().impl_trait_ref(impl_def_id) {\n+    let free_substs = &self.parameter_environment.free_substs;\n+    match self.tcx.impl_trait_ref(impl_def_id) {\n         Some(ref trait_ref) => {\n             // Trait impl: take implied bounds from all types that\n             // appear in the trait reference.\n@@ -589,7 +586,7 @@ fn impl_implied_bounds(&self, impl_def_id: DefId, span: Span) -> Vec<Ty<'tcx>> {\n \n         None => {\n             // Inherent impl: take implied bounds from the self type.\n-            let self_ty = self.tcx().lookup_item_type(impl_def_id).ty;\n+            let self_ty = self.tcx.lookup_item_type(impl_def_id).ty;\n             let self_ty = self.instantiate_type_scheme(span, free_substs, &self_ty);\n             vec![self_ty]\n         }"}, {"sha": "b39decff683f27503f7d8d3fec1efa7797f93961", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/0053b442f8cd5bf5e310a2664fc3a47a8f33da71/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0053b442f8cd5bf5e310a2664fc3a47a8f33da71/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=0053b442f8cd5bf5e310a2664fc3a47a8f33da71", "patch": "@@ -54,7 +54,7 @@ pub fn resolve_type_vars_in_fn(&self, decl: &hir::FnDecl, blk: &hir::Block) {\n         wbcx.visit_pat(&arg.pat);\n \n         // Privacy needs the type for the whole pattern, not just each binding\n-        if !pat_util::pat_is_binding(&self.tcx().def_map.borrow(), &arg.pat) {\n+        if !pat_util::pat_is_binding(&self.tcx.def_map.borrow(), &arg.pat) {\n             wbcx.visit_node_id(ResolvingPattern(arg.pat.span),\n                                arg.pat.id);\n         }\n@@ -84,7 +84,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx, 'tcx> {\n     }\n \n     fn tcx(&self) -> TyCtxt<'cx, 'tcx, 'tcx> {\n-        self.fcx.tcx()\n+        self.fcx.tcx\n     }\n \n     // Hacky hack: During type-checking, we treat *all* operators\n@@ -96,13 +96,13 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx, 'tcx> {\n             hir::ExprBinary(ref op, ref lhs, ref rhs) |\n             hir::ExprAssignOp(ref op, ref lhs, ref rhs) => {\n                 let lhs_ty = self.fcx.node_ty(lhs.id);\n-                let lhs_ty = self.fcx.infcx().resolve_type_vars_if_possible(&lhs_ty);\n+                let lhs_ty = self.fcx.resolve_type_vars_if_possible(&lhs_ty);\n \n                 let rhs_ty = self.fcx.node_ty(rhs.id);\n-                let rhs_ty = self.fcx.infcx().resolve_type_vars_if_possible(&rhs_ty);\n+                let rhs_ty = self.fcx.resolve_type_vars_if_possible(&rhs_ty);\n \n                 if lhs_ty.is_scalar() && rhs_ty.is_scalar() {\n-                    self.fcx.inh.tables.borrow_mut().method_map.remove(&MethodCall::expr(e.id));\n+                    self.fcx.tables.borrow_mut().method_map.remove(&MethodCall::expr(e.id));\n \n                     // weird but true: the by-ref binops put an\n                     // adjustment on the lhs but not the rhs; the\n@@ -111,11 +111,11 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx, 'tcx> {\n                     match e.node {\n                         hir::ExprBinary(..) => {\n                             if !op.node.is_by_value() {\n-                                self.fcx.inh.tables.borrow_mut().adjustments.remove(&lhs.id);\n+                                self.fcx.tables.borrow_mut().adjustments.remove(&lhs.id);\n                             }\n                         },\n                         hir::ExprAssignOp(..) => {\n-                            self.fcx.inh.tables.borrow_mut().adjustments.remove(&lhs.id);\n+                            self.fcx.tables.borrow_mut().adjustments.remove(&lhs.id);\n                         },\n                         _ => {},\n                     }\n@@ -220,7 +220,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx, 'tcx> {\n             return;\n         }\n \n-        for (upvar_id, upvar_capture) in self.fcx.inh.tables.borrow().upvar_capture_map.iter() {\n+        for (upvar_id, upvar_capture) in self.fcx.tables.borrow().upvar_capture_map.iter() {\n             let new_upvar_capture = match *upvar_capture {\n                 ty::UpvarCapture::ByValue => ty::UpvarCapture::ByValue,\n                 ty::UpvarCapture::ByRef(ref upvar_borrow) => {\n@@ -233,11 +233,11 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx, 'tcx> {\n             debug!(\"Upvar capture for {:?} resolved to {:?}\",\n                    upvar_id,\n                    new_upvar_capture);\n-            self.fcx.tcx()\n-                    .tables\n-                    .borrow_mut()\n-                    .upvar_capture_map\n-                    .insert(*upvar_id, new_upvar_capture);\n+            self.tcx()\n+                .tables\n+                .borrow_mut()\n+                .upvar_capture_map\n+                .insert(*upvar_id, new_upvar_capture);\n         }\n     }\n \n@@ -246,13 +246,13 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx, 'tcx> {\n             return\n         }\n \n-        for (def_id, closure_ty) in self.fcx.inh.tables.borrow().closure_tys.iter() {\n+        for (def_id, closure_ty) in self.fcx.tables.borrow().closure_tys.iter() {\n             let closure_ty = self.resolve(closure_ty, ResolvingClosure(*def_id));\n-            self.fcx.tcx().tables.borrow_mut().closure_tys.insert(*def_id, closure_ty);\n+            self.tcx().tables.borrow_mut().closure_tys.insert(*def_id, closure_ty);\n         }\n \n-        for (def_id, &closure_kind) in self.fcx.inh.tables.borrow().closure_kinds.iter() {\n-            self.fcx.tcx().tables.borrow_mut().closure_kinds.insert(*def_id, closure_kind);\n+        for (def_id, &closure_kind) in self.fcx.tables.borrow().closure_kinds.iter() {\n+            self.tcx().tables.borrow_mut().closure_kinds.insert(*def_id, closure_kind);\n         }\n     }\n \n@@ -274,7 +274,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx, 'tcx> {\n     }\n \n     fn visit_adjustments(&self, reason: ResolveReason, id: ast::NodeId) {\n-        let adjustments = self.fcx.inh.tables.borrow_mut().adjustments.remove(&id);\n+        let adjustments = self.fcx.tables.borrow_mut().adjustments.remove(&id);\n         match adjustments {\n             None => {\n                 debug!(\"No adjustments for node {}\", id);\n@@ -318,7 +318,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx, 'tcx> {\n                               reason: ResolveReason,\n                               method_call: MethodCall) {\n         // Resolve any method map entry\n-        let new_method = match self.fcx.inh.tables.borrow_mut().method_map.remove(&method_call) {\n+        let new_method = match self.fcx.tables.borrow_mut().method_map.remove(&method_call) {\n             Some(method) => {\n                 debug!(\"writeback::resolve_method_map_entry(call={:?}, entry={:?})\",\n                        method_call,\n@@ -346,14 +346,14 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx, 'tcx> {\n     }\n \n     fn visit_liberated_fn_sigs(&self) {\n-        for (&node_id, fn_sig) in self.fcx.inh.tables.borrow().liberated_fn_sigs.iter() {\n+        for (&node_id, fn_sig) in self.fcx.tables.borrow().liberated_fn_sigs.iter() {\n             let fn_sig = self.resolve(fn_sig, ResolvingFnSig(node_id));\n             self.tcx().tables.borrow_mut().liberated_fn_sigs.insert(node_id, fn_sig.clone());\n         }\n     }\n \n     fn visit_fru_field_types(&self) {\n-        for (&node_id, ftys) in self.fcx.inh.tables.borrow().fru_field_types.iter() {\n+        for (&node_id, ftys) in self.fcx.tables.borrow().fru_field_types.iter() {\n             let ftys = self.resolve(ftys, ResolvingFieldTypes(node_id));\n             self.tcx().tables.borrow_mut().fru_field_types.insert(node_id, ftys);\n         }\n@@ -420,7 +420,7 @@ impl<'cx, 'tcx> Resolver<'cx, 'tcx, 'tcx> {\n            reason: ResolveReason)\n            -> Resolver<'cx, 'tcx, 'tcx>\n     {\n-        Resolver::from_infcx(fcx.infcx(), &fcx.writeback_errors, reason)\n+        Resolver::from_infcx(fcx, &fcx.writeback_errors, reason)\n     }\n \n     fn from_infcx(infcx: &'cx InferCtxt<'cx, 'tcx, 'tcx>,"}]}