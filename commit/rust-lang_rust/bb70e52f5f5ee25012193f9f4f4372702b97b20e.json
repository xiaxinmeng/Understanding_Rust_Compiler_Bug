{"sha": "bb70e52f5f5ee25012193f9f4f4372702b97b20e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJiNzBlNTJmNWY1ZWUyNTAxMjE5M2Y5ZjRmNDM3MjcwMmI5N2IyMGU=", "commit": {"author": {"name": "dylni", "email": "46035563+dylni@users.noreply.github.com", "date": "2020-08-06T02:32:45Z"}, "committer": {"name": "dylni", "email": "46035563+dylni@users.noreply.github.com", "date": "2020-08-06T02:32:45Z"}, "message": "Add `slice::check_range`", "tree": {"sha": "09f84a37b8039b408bf8e00a1ad74f3d84e41438", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/09f84a37b8039b408bf8e00a1ad74f3d84e41438"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bb70e52f5f5ee25012193f9f4f4372702b97b20e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bb70e52f5f5ee25012193f9f4f4372702b97b20e", "html_url": "https://github.com/rust-lang/rust/commit/bb70e52f5f5ee25012193f9f4f4372702b97b20e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bb70e52f5f5ee25012193f9f4f4372702b97b20e/comments", "author": {"login": "dylni", "id": 46035563, "node_id": "MDQ6VXNlcjQ2MDM1NTYz", "avatar_url": "https://avatars.githubusercontent.com/u/46035563?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dylni", "html_url": "https://github.com/dylni", "followers_url": "https://api.github.com/users/dylni/followers", "following_url": "https://api.github.com/users/dylni/following{/other_user}", "gists_url": "https://api.github.com/users/dylni/gists{/gist_id}", "starred_url": "https://api.github.com/users/dylni/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dylni/subscriptions", "organizations_url": "https://api.github.com/users/dylni/orgs", "repos_url": "https://api.github.com/users/dylni/repos", "events_url": "https://api.github.com/users/dylni/events{/privacy}", "received_events_url": "https://api.github.com/users/dylni/received_events", "type": "User", "site_admin": false}, "committer": {"login": "dylni", "id": 46035563, "node_id": "MDQ6VXNlcjQ2MDM1NTYz", "avatar_url": "https://avatars.githubusercontent.com/u/46035563?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dylni", "html_url": "https://github.com/dylni", "followers_url": "https://api.github.com/users/dylni/followers", "following_url": "https://api.github.com/users/dylni/following{/other_user}", "gists_url": "https://api.github.com/users/dylni/gists{/gist_id}", "starred_url": "https://api.github.com/users/dylni/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dylni/subscriptions", "organizations_url": "https://api.github.com/users/dylni/orgs", "repos_url": "https://api.github.com/users/dylni/repos", "events_url": "https://api.github.com/users/dylni/events{/privacy}", "received_events_url": "https://api.github.com/users/dylni/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "22ee68dc586440f96b76b32fbd6087507c6afdb9", "url": "https://api.github.com/repos/rust-lang/rust/commits/22ee68dc586440f96b76b32fbd6087507c6afdb9", "html_url": "https://github.com/rust-lang/rust/commit/22ee68dc586440f96b76b32fbd6087507c6afdb9"}], "stats": {"total": 93, "additions": 87, "deletions": 6}, "files": [{"sha": "d5e07629a52cb017b49a9198b0c294be8eeb5774", "filename": "library/core/src/slice/mod.rs", "status": "modified", "additions": 87, "deletions": 6, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/bb70e52f5f5ee25012193f9f4f4372702b97b20e/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb70e52f5f5ee25012193f9f4f4372702b97b20e/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs?ref=bb70e52f5f5ee25012193f9f4f4372702b97b20e", "patch": "@@ -30,7 +30,7 @@ use crate::intrinsics::{assume, exact_div, is_aligned_and_not_null, unchecked_su\n use crate::iter::*;\n use crate::marker::{self, Copy, Send, Sized, Sync};\n use crate::mem;\n-use crate::ops::{self, FnMut, Range};\n+use crate::ops::{self, Bound, FnMut, Range, RangeBounds};\n use crate::option::Option;\n use crate::option::Option::{None, Some};\n use crate::ptr::{self, NonNull};\n@@ -350,6 +350,80 @@ impl<T> [T] {\n         unsafe { &mut *index.get_unchecked_mut(self) }\n     }\n \n+    /// Converts a range over this slice to [`Range`].\n+    ///\n+    /// The returned range is safe to pass to [`get_unchecked`] and [`get_unchecked_mut`].\n+    ///\n+    /// [`get_unchecked`]: #method.get_unchecked\n+    /// [`get_unchecked_mut`]: #method.get_unchecked_mut\n+    /// [`Range`]: ../ops/struct.Range.html\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if the range is out of bounds.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(slice_check_range)]\n+    ///\n+    /// let v = [10, 40, 30];\n+    /// assert_eq!(1..2, v.check_range(1..2));\n+    /// assert_eq!(0..2, v.check_range(..2));\n+    /// assert_eq!(1..3, v.check_range(1..));\n+    /// ```\n+    ///\n+    /// Panics when [`Index::index`] would panic:\n+    ///\n+    /// ```should_panic\n+    /// #![feature(slice_check_range)]\n+    ///\n+    /// [10, 40, 30].check_range(2..1);\n+    /// ```\n+    ///\n+    /// ```should_panic\n+    /// #![feature(slice_check_range)]\n+    ///\n+    /// [10, 40, 30].check_range(1..4);\n+    /// ```\n+    ///\n+    /// ```should_panic\n+    /// #![feature(slice_check_range)]\n+    ///\n+    /// [10, 40, 30].check_range(1..=usize::MAX);\n+    /// ```\n+    ///\n+    /// [`Index::index`]: ../ops/trait.Index.html#tymethod.index\n+    #[track_caller]\n+    #[unstable(feature = \"slice_check_range\", issue = \"none\")]\n+    pub fn check_range<R: RangeBounds<usize>>(&self, range: R) -> Range<usize> {\n+        let start = match range.start_bound() {\n+            Bound::Included(&start) => start,\n+            Bound::Excluded(start) => {\n+                start.checked_add(1).unwrap_or_else(|| slice_start_index_overflow_fail())\n+            }\n+            Bound::Unbounded => 0,\n+        };\n+\n+        let len = self.len();\n+        let end = match range.end_bound() {\n+            Bound::Included(end) => {\n+                end.checked_add(1).unwrap_or_else(|| slice_end_index_overflow_fail())\n+            }\n+            Bound::Excluded(&end) => end,\n+            Bound::Unbounded => len,\n+        };\n+\n+        if start > end {\n+            slice_index_order_fail(start, end);\n+        }\n+        if end > len {\n+            slice_end_index_len_fail(end, len);\n+        }\n+\n+        Range { start, end }\n+    }\n+\n     /// Returns a raw pointer to the slice's buffer.\n     ///\n     /// The caller must ensure that the slice outlives the pointer this\n@@ -2445,13 +2519,13 @@ impl<T> [T] {\n         let src_start = match src.start_bound() {\n             ops::Bound::Included(&n) => n,\n             ops::Bound::Excluded(&n) => {\n-                n.checked_add(1).unwrap_or_else(|| slice_index_overflow_fail())\n+                n.checked_add(1).unwrap_or_else(|| slice_start_index_overflow_fail())\n             }\n             ops::Bound::Unbounded => 0,\n         };\n         let src_end = match src.end_bound() {\n             ops::Bound::Included(&n) => {\n-                n.checked_add(1).unwrap_or_else(|| slice_index_overflow_fail())\n+                n.checked_add(1).unwrap_or_else(|| slice_end_index_overflow_fail())\n             }\n             ops::Bound::Excluded(&n) => n,\n             ops::Bound::Unbounded => self.len(),\n@@ -3034,7 +3108,14 @@ fn slice_index_order_fail(index: usize, end: usize) -> ! {\n #[inline(never)]\n #[cold]\n #[track_caller]\n-fn slice_index_overflow_fail() -> ! {\n+fn slice_start_index_overflow_fail() -> ! {\n+    panic!(\"attempted to index slice from after maximum usize\");\n+}\n+\n+#[inline(never)]\n+#[cold]\n+#[track_caller]\n+fn slice_end_index_overflow_fail() -> ! {\n     panic!(\"attempted to index slice up to maximum usize\");\n }\n \n@@ -3370,15 +3451,15 @@ unsafe impl<T> SliceIndex<[T]> for ops::RangeInclusive<usize> {\n     #[inline]\n     fn index(self, slice: &[T]) -> &[T] {\n         if *self.end() == usize::MAX {\n-            slice_index_overflow_fail();\n+            slice_end_index_overflow_fail();\n         }\n         (*self.start()..self.end() + 1).index(slice)\n     }\n \n     #[inline]\n     fn index_mut(self, slice: &mut [T]) -> &mut [T] {\n         if *self.end() == usize::MAX {\n-            slice_index_overflow_fail();\n+            slice_end_index_overflow_fail();\n         }\n         (*self.start()..self.end() + 1).index_mut(slice)\n     }"}]}