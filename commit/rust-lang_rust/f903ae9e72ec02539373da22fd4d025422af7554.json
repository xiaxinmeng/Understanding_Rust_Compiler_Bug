{"sha": "f903ae9e72ec02539373da22fd4d025422af7554", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY5MDNhZTllNzJlYzAyNTM5MzczZGEyMmZkNGQwMjU0MjJhZjc1NTQ=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-03-29T23:55:04Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-04-19T18:53:31Z"}, "message": "librustc: Implement fast-ffi and use it in various places", "tree": {"sha": "ccaf3a5daf113fc468c2e2a00ee10e6034a8ceb5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ccaf3a5daf113fc468c2e2a00ee10e6034a8ceb5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f903ae9e72ec02539373da22fd4d025422af7554", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f903ae9e72ec02539373da22fd4d025422af7554", "html_url": "https://github.com/rust-lang/rust/commit/f903ae9e72ec02539373da22fd4d025422af7554", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f903ae9e72ec02539373da22fd4d025422af7554/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1a36b0f17ef0b59411981fdd25ac9ce4ba7e20e0", "url": "https://api.github.com/repos/rust-lang/rust/commits/1a36b0f17ef0b59411981fdd25ac9ce4ba7e20e0", "html_url": "https://github.com/rust-lang/rust/commit/1a36b0f17ef0b59411981fdd25ac9ce4ba7e20e0"}], "stats": {"total": 687, "additions": 618, "deletions": 69}, "files": [{"sha": "9d100d1d352dd374e94e08b6424867a62c6f2d01", "filename": "src/libcore/libc.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f903ae9e72ec02539373da22fd4d025422af7554/src%2Flibcore%2Flibc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f903ae9e72ec02539373da22fd4d025422af7554/src%2Flibcore%2Flibc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flibc.rs?ref=f903ae9e72ec02539373da22fd4d025422af7554", "patch": "@@ -1109,8 +1109,10 @@ pub mod funcs {\n                 // Omitted: putc, putchar (might be macros).\n                 unsafe fn puts(s: *c_char) -> c_int;\n                 unsafe fn ungetc(c: c_int, stream: *FILE) -> c_int;\n+                #[fast_ffi]\n                 unsafe fn fread(ptr: *mut c_void, size: size_t,\n                          nobj: size_t, stream: *FILE) -> size_t;\n+                #[fast_ffi]\n                 unsafe fn fwrite(ptr: *c_void, size: size_t,\n                           nobj: size_t, stream: *FILE) -> size_t;\n                 unsafe fn fseek(stream: *FILE, offset: c_long,\n@@ -1144,9 +1146,13 @@ pub mod funcs {\n                               -> c_long;\n                 unsafe fn strtoul(s: *c_char, endp: **c_char, base: c_int)\n                                -> c_ulong;\n+                #[fast_ffi]\n                 unsafe fn calloc(nobj: size_t, size: size_t) -> *c_void;\n+                #[fast_ffi]\n                 unsafe fn malloc(size: size_t) -> *c_void;\n+                #[fast_ffi]\n                 unsafe fn realloc(p: *c_void, size: size_t) -> *c_void;\n+                #[fast_ffi]\n                 unsafe fn free(p: *c_void);\n                 unsafe fn abort() -> !;\n                 unsafe fn exit(status: c_int) -> !;\n@@ -1340,6 +1346,7 @@ pub mod funcs {\n                         textmode: c_int) -> c_int;\n \n                 #[link_name = \"_read\"]\n+                #[fast_ffi]\n                 unsafe fn read(fd: c_int, buf: *mut c_void, count: c_uint)\n                             -> c_int;\n \n@@ -1350,6 +1357,7 @@ pub mod funcs {\n                 unsafe fn unlink(c: *c_char) -> c_int;\n \n                 #[link_name = \"_write\"]\n+                #[fast_ffi]\n                 unsafe fn write(fd: c_int, buf: *c_void, count: c_uint)\n                              -> c_int;\n             }\n@@ -1502,6 +1510,7 @@ pub mod funcs {\n                 unsafe fn pathconf(path: *c_char, name: c_int) -> c_long;\n                 unsafe fn pause() -> c_int;\n                 unsafe fn pipe(fds: *mut c_int) -> c_int;\n+                #[fast_ffi]\n                 unsafe fn read(fd: c_int, buf: *mut c_void,\n                         count: size_t) -> ssize_t;\n                 unsafe fn rmdir(path: *c_char) -> c_int;\n@@ -1514,6 +1523,7 @@ pub mod funcs {\n                 unsafe fn tcgetpgrp(fd: c_int) -> pid_t;\n                 unsafe fn ttyname(fd: c_int) -> *c_char;\n                 unsafe fn unlink(c: *c_char) -> c_int;\n+                #[fast_ffi]\n                 unsafe fn write(fd: c_int, buf: *c_void, count: size_t)\n                              -> ssize_t;\n             }"}, {"sha": "611862a79e7e0bb7a4a89f5aa58a9fc0aece3e80", "filename": "src/libcore/unstable/lang.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f903ae9e72ec02539373da22fd4d025422af7554/src%2Flibcore%2Funstable%2Flang.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f903ae9e72ec02539373da22fd4d025422af7554/src%2Flibcore%2Funstable%2Flang.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable%2Flang.rs?ref=f903ae9e72ec02539373da22fd4d025422af7554", "patch": "@@ -35,6 +35,14 @@ pub mod rustrt {\n \n         #[rust_stack]\n         unsafe fn rust_upcall_free(ptr: *c_char);\n+\n+        #[fast_ffi]\n+        unsafe fn rust_upcall_malloc_noswitch(td: *c_char,\n+                                              size: uintptr_t)\n+                                           -> *c_char;\n+\n+        #[fast_ffi]\n+        unsafe fn rust_upcall_free_noswitch(ptr: *c_char);\n     }\n }\n \n@@ -81,7 +89,7 @@ pub unsafe fn exchange_free(ptr: *c_char) {\n #[lang=\"malloc\"]\n #[inline(always)]\n pub unsafe fn local_malloc(td: *c_char, size: uintptr_t) -> *c_char {\n-    return rustrt::rust_upcall_malloc(td, size);\n+    return rustrt::rust_upcall_malloc_noswitch(td, size);\n }\n \n // NB: Calls to free CANNOT be allowed to fail, as throwing an exception from\n@@ -90,7 +98,7 @@ pub unsafe fn local_malloc(td: *c_char, size: uintptr_t) -> *c_char {\n #[lang=\"free\"]\n #[inline(always)]\n pub unsafe fn local_free(ptr: *c_char) {\n-    rustrt::rust_upcall_free(ptr);\n+    rustrt::rust_upcall_free_noswitch(ptr);\n }\n \n #[lang=\"borrow_as_imm\"]"}, {"sha": "f6492ede9f9cac71f1e1d7c766d83901af3cfd98", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f903ae9e72ec02539373da22fd4d025422af7554/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f903ae9e72ec02539373da22fd4d025422af7554/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=f903ae9e72ec02539373da22fd4d025422af7554", "patch": "@@ -43,9 +43,11 @@ pub mod rustrt {\n     pub extern {\n         // These names are terrible. reserve_shared applies\n         // to ~[] and reserve_shared_actual applies to @[].\n+        #[fast_ffi]\n         unsafe fn vec_reserve_shared(++t: *sys::TypeDesc,\n                                      ++v: **raw::VecRepr,\n                                      ++n: libc::size_t);\n+        #[fast_ffi]\n         unsafe fn vec_reserve_shared_actual(++t: *sys::TypeDesc,\n                                             ++v: **raw::VecRepr,\n                                             ++n: libc::size_t);"}, {"sha": "7ea1fe8015825e88fa4a41eaa51a03c0f3db062e", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f903ae9e72ec02539373da22fd4d025422af7554/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f903ae9e72ec02539373da22fd4d025422af7554/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=f903ae9e72ec02539373da22fd4d025422af7554", "patch": "@@ -172,10 +172,13 @@ pub enum compile_upto {\n \n // For continuing compilation after a parsed crate has been\n // modified\n-pub fn compile_rest(sess: Session, cfg: ast::crate_cfg,\n-                    upto: compile_upto, outputs: Option<@OutputFilenames>,\n+#[fixed_stack_segment]\n+pub fn compile_rest(sess: Session,\n+                    cfg: ast::crate_cfg,\n+                    upto: compile_upto,\n+                    outputs: Option<@OutputFilenames>,\n                     curr: Option<@ast::crate>)\n-    -> (@ast::crate, Option<ty::ctxt>) {\n+                 -> (@ast::crate, Option<ty::ctxt>) {\n     let time_passes = sess.time_passes();\n     let mut crate = curr.get();\n "}, {"sha": "0ab883d330d9d3f1d0da6924c8f31bd81acc544e", "filename": "src/librustc/lib/llvm.rs", "status": "modified", "additions": 438, "deletions": 2, "changes": 440, "blob_url": "https://github.com/rust-lang/rust/blob/f903ae9e72ec02539373da22fd4d025422af7554/src%2Flibrustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f903ae9e72ec02539373da22fd4d025422af7554/src%2Flibrustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib%2Fllvm.rs?ref=f903ae9e72ec02539373da22fd4d025422af7554", "patch": "@@ -234,983 +234,1333 @@ pub mod llvm {\n     #[abi = \"cdecl\"]\n     pub extern {\n         /* Create and destroy contexts. */\n+        #[fast_ffi]\n         pub unsafe fn LLVMContextCreate() -> ContextRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetGlobalContext() -> ContextRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMContextDispose(C: ContextRef);\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetMDKindIDInContext(C: ContextRef,\n                                            Name: *c_char,\n                                            SLen: c_uint)\n                                         -> c_uint;\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetMDKindID(Name: *c_char, SLen: c_uint) -> c_uint;\n \n         /* Create and destroy modules. */\n+        #[fast_ffi]\n         pub unsafe fn LLVMModuleCreateWithNameInContext(ModuleID: *c_char,\n                                                     C: ContextRef)\n                                                  -> ModuleRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMDisposeModule(M: ModuleRef);\n \n         /** Data layout. See Module::getDataLayout. */\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetDataLayout(M: ModuleRef) -> *c_char;\n+        #[fast_ffi]\n         pub unsafe fn LLVMSetDataLayout(M: ModuleRef, Triple: *c_char);\n \n         /** Target triple. See Module::getTargetTriple. */\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetTarget(M: ModuleRef) -> *c_char;\n+        #[fast_ffi]\n         pub unsafe fn LLVMSetTarget(M: ModuleRef, Triple: *c_char);\n \n         /** See Module::dump. */\n+        #[fast_ffi]\n         pub unsafe fn LLVMDumpModule(M: ModuleRef);\n \n         /** See Module::setModuleInlineAsm. */\n+        #[fast_ffi]\n         pub unsafe fn LLVMSetModuleInlineAsm(M: ModuleRef, Asm: *c_char);\n \n         /** See llvm::LLVMTypeKind::getTypeID. */\n         pub unsafe fn LLVMGetTypeKind(Ty: TypeRef) -> TypeKind;\n \n         /** See llvm::LLVMType::getContext. */\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetTypeContext(Ty: TypeRef) -> ContextRef;\n \n         /* Operations on integer types */\n+        #[fast_ffi]\n         pub unsafe fn LLVMInt1TypeInContext(C: ContextRef) -> TypeRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMInt8TypeInContext(C: ContextRef) -> TypeRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMInt16TypeInContext(C: ContextRef) -> TypeRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMInt32TypeInContext(C: ContextRef) -> TypeRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMInt64TypeInContext(C: ContextRef) -> TypeRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMIntTypeInContext(C: ContextRef,\n                                            NumBits: c_uint) -> TypeRef;\n \n+        #[fast_ffi]\n         pub unsafe fn LLVMInt1Type() -> TypeRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMInt8Type() -> TypeRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMInt16Type() -> TypeRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMInt32Type() -> TypeRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMInt64Type() -> TypeRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMIntType(NumBits: c_uint) -> TypeRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetIntTypeWidth(IntegerTy: TypeRef) -> c_uint;\n \n         /* Operations on real types */\n+        #[fast_ffi]\n         pub unsafe fn LLVMFloatTypeInContext(C: ContextRef) -> TypeRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMDoubleTypeInContext(C: ContextRef) -> TypeRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMX86FP80TypeInContext(C: ContextRef) -> TypeRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMFP128TypeInContext(C: ContextRef) -> TypeRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMPPCFP128TypeInContext(C: ContextRef) -> TypeRef;\n \n+        #[fast_ffi]\n         pub unsafe fn LLVMFloatType() -> TypeRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMDoubleType() -> TypeRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMX86FP80Type() -> TypeRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMFP128Type() -> TypeRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMPPCFP128Type() -> TypeRef;\n \n         /* Operations on function types */\n+        #[fast_ffi]\n         pub unsafe fn LLVMFunctionType(ReturnType: TypeRef,\n                                        ParamTypes: *TypeRef,\n                                        ParamCount: c_uint,\n                                        IsVarArg: Bool)\n                                     -> TypeRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMIsFunctionVarArg(FunctionTy: TypeRef) -> Bool;\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetReturnType(FunctionTy: TypeRef) -> TypeRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMCountParamTypes(FunctionTy: TypeRef) -> c_uint;\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetParamTypes(FunctionTy: TypeRef, Dest: *TypeRef);\n \n         /* Operations on struct types */\n+        #[fast_ffi]\n         pub unsafe fn LLVMStructTypeInContext(C: ContextRef,\n                                               ElementTypes: *TypeRef,\n                                               ElementCount: c_uint,\n                                               Packed: Bool) -> TypeRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMStructType(ElementTypes: *TypeRef,\n                                      ElementCount: c_uint,\n                                      Packed: Bool)\n                                   -> TypeRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMCountStructElementTypes(StructTy: TypeRef)\n                                                -> c_uint;\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetStructElementTypes(StructTy: TypeRef,\n                                             Dest: *mut TypeRef);\n+        #[fast_ffi]\n         pub unsafe fn LLVMIsPackedStruct(StructTy: TypeRef) -> Bool;\n \n         /* Operations on array, pointer, and vector types (sequence types) */\n+        #[fast_ffi]\n         pub unsafe fn LLVMArrayType(ElementType: TypeRef,\n                          ElementCount: c_uint) -> TypeRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMPointerType(ElementType: TypeRef,\n                            AddressSpace: c_uint) -> TypeRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMVectorType(ElementType: TypeRef,\n                           ElementCount: c_uint) -> TypeRef;\n \n+        #[fast_ffi]\n         pub unsafe fn LLVMGetElementType(Ty: TypeRef) -> TypeRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetArrayLength(ArrayTy: TypeRef) -> c_uint;\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetPointerAddressSpace(PointerTy: TypeRef)\n                                               -> c_uint;\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetVectorSize(VectorTy: TypeRef) -> c_uint;\n \n         /* Operations on other types */\n+        #[fast_ffi]\n         pub unsafe fn LLVMVoidTypeInContext(C: ContextRef) -> TypeRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMLabelTypeInContext(C: ContextRef) -> TypeRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMMetadataTypeInContext(C: ContextRef) -> TypeRef;\n \n+        #[fast_ffi]\n         pub unsafe fn LLVMVoidType() -> TypeRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMLabelType() -> TypeRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMMetadataType() -> TypeRef;\n \n         /* Operations on all values */\n+        #[fast_ffi]\n         pub unsafe fn LLVMTypeOf(Val: ValueRef) -> TypeRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetValueName(Val: ValueRef) -> *c_char;\n+        #[fast_ffi]\n         pub unsafe fn LLVMSetValueName(Val: ValueRef, Name: *c_char);\n+        #[fast_ffi]\n         pub unsafe fn LLVMDumpValue(Val: ValueRef);\n+        #[fast_ffi]\n         pub unsafe fn LLVMReplaceAllUsesWith(OldVal: ValueRef,\n                                              NewVal: ValueRef);\n+        #[fast_ffi]\n         pub unsafe fn LLVMHasMetadata(Val: ValueRef) -> c_int;\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetMetadata(Val: ValueRef, KindID: c_uint)\n                                    -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMSetMetadata(Val: ValueRef,\n                                       KindID: c_uint,\n                                       Node: ValueRef);\n \n         /* Operations on Uses */\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetFirstUse(Val: ValueRef) -> UseRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetNextUse(U: UseRef) -> UseRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetUser(U: UseRef) -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetUsedValue(U: UseRef) -> ValueRef;\n \n         /* Operations on Users */\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetNumOperands(Val: ValueRef) -> c_int;\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetOperand(Val: ValueRef, Index: c_uint)\n                                   -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMSetOperand(Val: ValueRef,\n                                      Index: c_uint,\n                                      Op: ValueRef);\n \n         /* Operations on constants of any type */\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstNull(Ty: TypeRef) -> ValueRef;\n         /* all zeroes */\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstAllOnes(Ty: TypeRef) -> ValueRef;\n         /* only for int/vector */\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetUndef(Ty: TypeRef) -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMIsConstant(Val: ValueRef) -> Bool;\n+        #[fast_ffi]\n         pub unsafe fn LLVMIsNull(Val: ValueRef) -> Bool;\n+        #[fast_ffi]\n         pub unsafe fn LLVMIsUndef(Val: ValueRef) -> Bool;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstPointerNull(Ty: TypeRef) -> ValueRef;\n \n         /* Operations on metadata */\n+        #[fast_ffi]\n         pub unsafe fn LLVMMDStringInContext(C: ContextRef,\n                                         Str: *c_char,\n                                         SLen: c_uint)\n                                      -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMMDString(Str: *c_char, SLen: c_uint) -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMMDNodeInContext(C: ContextRef,\n                                       Vals: *ValueRef,\n                                       Count: c_uint)\n                                    -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMMDNode(Vals: *ValueRef, Count: c_uint) -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMAddNamedMetadataOperand(M: ModuleRef, Str: *c_char,\n                                        Val: ValueRef);\n \n         /* Operations on scalar constants */\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstInt(IntTy: TypeRef,\n                                N: c_ulonglong,\n                                SignExtend: Bool)\n                             -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstIntOfString(IntTy: TypeRef,\n                                        Text: *c_char,\n                                        Radix: u8)\n                                     -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstIntOfStringAndSize(IntTy: TypeRef,\n                                                   Text: *c_char,\n                                                   SLen: c_uint,\n                                                   Radix: u8)\n                                                -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstReal(RealTy: TypeRef, N: f64) -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstRealOfString(RealTy: TypeRef,\n                                         Text: *c_char)\n                                      -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstRealOfStringAndSize(RealTy: TypeRef,\n                                                    Text: *c_char,\n                                                    SLen: c_uint)\n                                                 -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstIntGetZExtValue(ConstantVal: ValueRef)\n                                             -> c_ulonglong;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstIntGetSExtValue(ConstantVal: ValueRef)\n                                             -> c_longlong;\n \n \n         /* Operations on composite constants */\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstStringInContext(C: ContextRef,\n                                            Str: *c_char,\n                                            Length: c_uint,\n                                            DontNullTerminate: Bool)\n                                         -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstStructInContext(C: ContextRef,\n                                                ConstantVals: *ValueRef,\n                                                Count: c_uint,\n                                                Packed: Bool) -> ValueRef;\n \n+        #[fast_ffi]\n         pub unsafe fn LLVMConstString(Str: *c_char,\n                                       Length: c_uint,\n                                       DontNullTerminate: Bool)\n                                    -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstArray(ElementTy: TypeRef,\n                                      ConstantVals: *ValueRef,\n                                      Length: c_uint)\n                                   -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstStruct(ConstantVals: *ValueRef,\n                                       Count: c_uint,\n                                       Packed: Bool) -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstVector(ScalarConstantVals: *ValueRef,\n                                       Size: c_uint) -> ValueRef;\n \n         /* Constant expressions */\n+        #[fast_ffi]\n         pub unsafe fn LLVMAlignOf(Ty: TypeRef) -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMSizeOf(Ty: TypeRef) -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstNeg(ConstantVal: ValueRef) -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstNSWNeg(ConstantVal: ValueRef) -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstNUWNeg(ConstantVal: ValueRef) -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstFNeg(ConstantVal: ValueRef) -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstNot(ConstantVal: ValueRef) -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstAdd(LHSConstant: ValueRef,\n                                    RHSConstant: ValueRef)\n                                 -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstNSWAdd(LHSConstant: ValueRef,\n                                   RHSConstant: ValueRef)\n                                -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstNUWAdd(LHSConstant: ValueRef,\n                                   RHSConstant: ValueRef)\n                                -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstFAdd(LHSConstant: ValueRef,\n                                 RHSConstant: ValueRef)\n                              -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstSub(LHSConstant: ValueRef,\n                                    RHSConstant: ValueRef)\n                                 -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstNSWSub(LHSConstant: ValueRef,\n                                       RHSConstant: ValueRef)\n                                    -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstNUWSub(LHSConstant: ValueRef,\n                                       RHSConstant: ValueRef)\n                                    -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstFSub(LHSConstant: ValueRef,\n                                     RHSConstant: ValueRef)\n                                  -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstMul(LHSConstant: ValueRef,\n                                RHSConstant: ValueRef)\n                             -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstNSWMul(LHSConstant: ValueRef,\n                                   RHSConstant: ValueRef)\n                                -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstNUWMul(LHSConstant: ValueRef,\n                                   RHSConstant: ValueRef)\n                                -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstFMul(LHSConstant: ValueRef,\n                                 RHSConstant: ValueRef)\n                              -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstUDiv(LHSConstant: ValueRef,\n                                 RHSConstant: ValueRef)\n                              -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstSDiv(LHSConstant: ValueRef,\n                                 RHSConstant: ValueRef)\n                              -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstExactSDiv(LHSConstant: ValueRef,\n                                      RHSConstant: ValueRef)\n                                   -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstFDiv(LHSConstant: ValueRef,\n                                 RHSConstant: ValueRef)\n                              -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstURem(LHSConstant: ValueRef,\n                                 RHSConstant: ValueRef)\n                              -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstSRem(LHSConstant: ValueRef,\n                                 RHSConstant: ValueRef)\n                              -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstFRem(LHSConstant: ValueRef,\n                                 RHSConstant: ValueRef)\n                              -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstAnd(LHSConstant: ValueRef,\n                                RHSConstant: ValueRef)\n                             -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstOr(LHSConstant: ValueRef,\n                               RHSConstant: ValueRef)\n                            -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstXor(LHSConstant: ValueRef,\n                                RHSConstant: ValueRef)\n                             -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstShl(LHSConstant: ValueRef,\n                                RHSConstant: ValueRef)\n                             -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstLShr(LHSConstant: ValueRef,\n                                     RHSConstant: ValueRef) -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstAShr(LHSConstant: ValueRef,\n                                     RHSConstant: ValueRef) -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstGEP(ConstantVal: ValueRef,\n                         ConstantIndices: *ValueRef,\n                         NumIndices: c_uint) -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstInBoundsGEP(ConstantVal: ValueRef,\n                                        ConstantIndices: *ValueRef,\n                                        NumIndices: c_uint)\n                                     -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstTrunc(ConstantVal: ValueRef,\n                                  ToType: TypeRef)\n                               -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstSExt(ConstantVal: ValueRef,\n                                 ToType: TypeRef)\n                              -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstZExt(ConstantVal: ValueRef,\n                                 ToType: TypeRef)\n                              -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstFPTrunc(ConstantVal: ValueRef,\n                                    ToType: TypeRef)\n                                 -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstFPExt(ConstantVal: ValueRef,\n                                  ToType: TypeRef)\n                               -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstUIToFP(ConstantVal: ValueRef,\n                                   ToType: TypeRef)\n                                -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstSIToFP(ConstantVal: ValueRef,\n                                   ToType: TypeRef)\n                                -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstFPToUI(ConstantVal: ValueRef,\n                                   ToType: TypeRef)\n                                -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstFPToSI(ConstantVal: ValueRef,\n                                   ToType: TypeRef)\n                                -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstPtrToInt(ConstantVal: ValueRef,\n                                     ToType: TypeRef)\n                                  -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstIntToPtr(ConstantVal: ValueRef,\n                                     ToType: TypeRef)\n                                  -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstBitCast(ConstantVal: ValueRef,\n                                    ToType: TypeRef)\n                                 -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstZExtOrBitCast(ConstantVal: ValueRef,\n                                          ToType: TypeRef)\n                                       -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstSExtOrBitCast(ConstantVal: ValueRef,\n                                          ToType: TypeRef)\n                                       -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstTruncOrBitCast(ConstantVal: ValueRef,\n                                           ToType: TypeRef)\n                                        -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstPointerCast(ConstantVal: ValueRef,\n                                        ToType: TypeRef)\n                                     -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstIntCast(ConstantVal: ValueRef,\n                                        ToType: TypeRef,\n                                        isSigned: Bool)\n                                     -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstFPCast(ConstantVal: ValueRef,\n                                   ToType: TypeRef)\n                                -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstSelect(ConstantCondition: ValueRef,\n                                       ConstantIfTrue: ValueRef,\n                                       ConstantIfFalse: ValueRef)\n                                    -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstExtractElement(VectorConstant: ValueRef,\n                                    IndexConstant: ValueRef) -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstInsertElement(VectorConstant: ValueRef,\n                                   ElementValueConstant: ValueRef,\n                                   IndexConstant: ValueRef) -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstShuffleVector(VectorAConstant: ValueRef,\n                                   VectorBConstant: ValueRef,\n                                   MaskConstant: ValueRef) -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstExtractValue(AggConstant: ValueRef,\n                                             IdxList: *c_uint,\n                                             NumIdx: c_uint) -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstInsertValue(AggConstant: ValueRef,\n                                            ElementValueConstant: ValueRef,\n                                            IdxList: *c_uint,\n                                            NumIdx: c_uint)\n                                         -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMConstInlineAsm(Ty: TypeRef, AsmString: *c_char,\n                               Constraints: *c_char, HasSideEffects: Bool,\n                               IsAlignStack: Bool) -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBlockAddress(F: ValueRef, BB: BasicBlockRef)\n                                     -> ValueRef;\n \n \n \n         /* Operations on global variables, functions, and aliases (globals) */\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetGlobalParent(Global: ValueRef) -> ModuleRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMIsDeclaration(Global: ValueRef) -> Bool;\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetLinkage(Global: ValueRef) -> c_uint;\n+        #[fast_ffi]\n         pub unsafe fn LLVMSetLinkage(Global: ValueRef, Link: c_uint);\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetSection(Global: ValueRef) -> *c_char;\n+        #[fast_ffi]\n         pub unsafe fn LLVMSetSection(Global: ValueRef, Section: *c_char);\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetVisibility(Global: ValueRef) -> c_uint;\n+        #[fast_ffi]\n         pub unsafe fn LLVMSetVisibility(Global: ValueRef, Viz: c_uint);\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetAlignment(Global: ValueRef) -> c_uint;\n+        #[fast_ffi]\n         pub unsafe fn LLVMSetAlignment(Global: ValueRef, Bytes: c_uint);\n \n \n         /* Operations on global variables */\n+        #[fast_ffi]\n         pub unsafe fn LLVMAddGlobal(M: ModuleRef,\n                                 Ty: TypeRef,\n                                 Name: *c_char)\n                              -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMAddGlobalInAddressSpace(M: ModuleRef,\n                                               Ty: TypeRef,\n                                               Name: *c_char,\n                                               AddressSpace: c_uint)\n                                            -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetNamedGlobal(M: ModuleRef, Name: *c_char)\n                                       -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetFirstGlobal(M: ModuleRef) -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetLastGlobal(M: ModuleRef) -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetNextGlobal(GlobalVar: ValueRef) -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetPreviousGlobal(GlobalVar: ValueRef) -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMDeleteGlobal(GlobalVar: ValueRef);\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetInitializer(GlobalVar: ValueRef) -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMSetInitializer(GlobalVar: ValueRef,\n                                          ConstantVal: ValueRef);\n+        #[fast_ffi]\n         pub unsafe fn LLVMIsThreadLocal(GlobalVar: ValueRef) -> Bool;\n+        #[fast_ffi]\n         pub unsafe fn LLVMSetThreadLocal(GlobalVar: ValueRef,\n                                          IsThreadLocal: Bool);\n+        #[fast_ffi]\n         pub unsafe fn LLVMIsGlobalConstant(GlobalVar: ValueRef) -> Bool;\n+        #[fast_ffi]\n         pub unsafe fn LLVMSetGlobalConstant(GlobalVar: ValueRef,\n                                             IsConstant: Bool);\n \n         /* Operations on aliases */\n+        #[fast_ffi]\n         pub unsafe fn LLVMAddAlias(M: ModuleRef,\n                                    Ty: TypeRef,\n                                    Aliasee: ValueRef,\n                                    Name: *c_char)\n                                 -> ValueRef;\n \n         /* Operations on functions */\n+        #[fast_ffi]\n         pub unsafe fn LLVMAddFunction(M: ModuleRef,\n                                   Name: *c_char,\n                                   FunctionTy: TypeRef)\n                                -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetNamedFunction(M: ModuleRef,\n                                            Name: *c_char) -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetFirstFunction(M: ModuleRef) -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetLastFunction(M: ModuleRef) -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetNextFunction(Fn: ValueRef) -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetPreviousFunction(Fn: ValueRef) -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMDeleteFunction(Fn: ValueRef);\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetOrInsertFunction(M: ModuleRef, Name: *c_char,\n                                    FunctionTy: TypeRef) -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetIntrinsicID(Fn: ValueRef) -> c_uint;\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetFunctionCallConv(Fn: ValueRef) -> c_uint;\n+        #[fast_ffi]\n         pub unsafe fn LLVMSetFunctionCallConv(Fn: ValueRef, CC: c_uint);\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetGC(Fn: ValueRef) -> *c_char;\n+        #[fast_ffi]\n         pub unsafe fn LLVMSetGC(Fn: ValueRef, Name: *c_char);\n+        #[fast_ffi]\n         pub unsafe fn LLVMAddFunctionAttr(Fn: ValueRef,\n-                                          PA: c_ulonglong,\n-                                          HighPA: c_ulonglong);\n+                                          PA: c_uint,\n+                                          HighPA: c_uint);\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetFunctionAttr(Fn: ValueRef) -> c_ulonglong;\n+        #[fast_ffi]\n         pub unsafe fn LLVMRemoveFunctionAttr(Fn: ValueRef,\n                                              PA: c_ulonglong,\n                                              HighPA: c_ulonglong);\n \n         /* Operations on parameters */\n+        #[fast_ffi]\n         pub unsafe fn LLVMCountParams(Fn: ValueRef) -> c_uint;\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetParams(Fn: ValueRef, Params: *ValueRef);\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetParam(Fn: ValueRef, Index: c_uint) -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetParamParent(Inst: ValueRef) -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetFirstParam(Fn: ValueRef) -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetLastParam(Fn: ValueRef) -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetNextParam(Arg: ValueRef) -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetPreviousParam(Arg: ValueRef) -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMAddAttribute(Arg: ValueRef, PA: c_uint);\n+        #[fast_ffi]\n         pub unsafe fn LLVMRemoveAttribute(Arg: ValueRef, PA: c_uint);\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetAttribute(Arg: ValueRef) -> c_uint;\n+        #[fast_ffi]\n         pub unsafe fn LLVMSetParamAlignment(Arg: ValueRef, align: c_uint);\n \n         /* Operations on basic blocks */\n+        #[fast_ffi]\n         pub unsafe fn LLVMBasicBlockAsValue(BB: BasicBlockRef) -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMValueIsBasicBlock(Val: ValueRef) -> Bool;\n+        #[fast_ffi]\n         pub unsafe fn LLVMValueAsBasicBlock(Val: ValueRef) -> BasicBlockRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetBasicBlockParent(BB: BasicBlockRef) -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMCountBasicBlocks(Fn: ValueRef) -> c_uint;\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetBasicBlocks(Fn: ValueRef,\n                                          BasicBlocks: *ValueRef);\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetFirstBasicBlock(Fn: ValueRef) -> BasicBlockRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetLastBasicBlock(Fn: ValueRef) -> BasicBlockRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetNextBasicBlock(BB: BasicBlockRef)\n                                          -> BasicBlockRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetPreviousBasicBlock(BB: BasicBlockRef)\n                                              -> BasicBlockRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetEntryBasicBlock(Fn: ValueRef) -> BasicBlockRef;\n \n+        #[fast_ffi]\n         pub unsafe fn LLVMAppendBasicBlockInContext(C: ContextRef,\n                                                     Fn: ValueRef,\n                                                     Name: *c_char)\n                                                  -> BasicBlockRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMInsertBasicBlockInContext(C: ContextRef,\n                                                     BB: BasicBlockRef,\n                                                     Name: *c_char)\n                                                  -> BasicBlockRef;\n \n+        #[fast_ffi]\n         pub unsafe fn LLVMAppendBasicBlock(Fn: ValueRef,\n                                        Name: *c_char)\n                                     -> BasicBlockRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMInsertBasicBlock(InsertBeforeBB: BasicBlockRef,\n                                        Name: *c_char)\n                                     -> BasicBlockRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMDeleteBasicBlock(BB: BasicBlockRef);\n \n         /* Operations on instructions */\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetInstructionParent(Inst: ValueRef)\n                                             -> BasicBlockRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetFirstInstruction(BB: BasicBlockRef) -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetLastInstruction(BB: BasicBlockRef) -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetNextInstruction(Inst: ValueRef) -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetPreviousInstruction(Inst: ValueRef) -> ValueRef;\n \n         /* Operations on call sites */\n+        #[fast_ffi]\n         pub unsafe fn LLVMSetInstructionCallConv(Instr: ValueRef, CC: c_uint);\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetInstructionCallConv(Instr: ValueRef) -> c_uint;\n+        #[fast_ffi]\n         pub unsafe fn LLVMAddInstrAttribute(Instr: ValueRef,\n                                             index: c_uint,\n                                             IA: c_uint);\n+        #[fast_ffi]\n         pub unsafe fn LLVMRemoveInstrAttribute(Instr: ValueRef,\n                                                index: c_uint,\n                                                IA: c_uint);\n+        #[fast_ffi]\n         pub unsafe fn LLVMSetInstrParamAlignment(Instr: ValueRef,\n                                                  index: c_uint,\n                                                  align: c_uint);\n \n         /* Operations on call instructions (only) */\n+        #[fast_ffi]\n         pub unsafe fn LLVMIsTailCall(CallInst: ValueRef) -> Bool;\n+        #[fast_ffi]\n         pub unsafe fn LLVMSetTailCall(CallInst: ValueRef, IsTailCall: Bool);\n \n         /* Operations on phi nodes */\n+        #[fast_ffi]\n         pub unsafe fn LLVMAddIncoming(PhiNode: ValueRef,\n                                       IncomingValues: *ValueRef,\n                                       IncomingBlocks: *BasicBlockRef,\n                                       Count: c_uint);\n+        #[fast_ffi]\n         pub unsafe fn LLVMCountIncoming(PhiNode: ValueRef) -> c_uint;\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetIncomingValue(PhiNode: ValueRef,\n                                        Index: c_uint)\n                                     -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetIncomingBlock(PhiNode: ValueRef,\n                                 Index: c_uint) -> BasicBlockRef;\n \n         /* Instruction builders */\n+        #[fast_ffi]\n         pub unsafe fn LLVMCreateBuilderInContext(C: ContextRef) -> BuilderRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMCreateBuilder() -> BuilderRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMPositionBuilder(Builder: BuilderRef,\n                                           Block: BasicBlockRef,\n                                           Instr: ValueRef);\n+        #[fast_ffi]\n         pub unsafe fn LLVMPositionBuilderBefore(Builder: BuilderRef,\n                                                 Instr: ValueRef);\n+        #[fast_ffi]\n         pub unsafe fn LLVMPositionBuilderAtEnd(Builder: BuilderRef,\n                                                Block: BasicBlockRef);\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetInsertBlock(Builder: BuilderRef)\n                                       -> BasicBlockRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMClearInsertionPosition(Builder: BuilderRef);\n+        #[fast_ffi]\n         pub unsafe fn LLVMInsertIntoBuilder(Builder: BuilderRef,\n                                             Instr: ValueRef);\n+        #[fast_ffi]\n         pub unsafe fn LLVMInsertIntoBuilderWithName(Builder: BuilderRef,\n                                                 Instr: ValueRef,\n                                                 Name: *c_char);\n+        #[fast_ffi]\n         pub unsafe fn LLVMDisposeBuilder(Builder: BuilderRef);\n \n         /* Metadata */\n+        #[fast_ffi]\n         pub unsafe fn LLVMSetCurrentDebugLocation(Builder: BuilderRef,\n                                                   L: ValueRef);\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetCurrentDebugLocation(Builder: BuilderRef)\n                                                -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMSetInstDebugLocation(Builder: BuilderRef,\n                                                Inst: ValueRef);\n \n         /* Terminators */\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildRetVoid(B: BuilderRef) -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildRet(B: BuilderRef, V: ValueRef) -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildAggregateRet(B: BuilderRef, RetVals: *ValueRef,\n                                  N: c_uint) -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildBr(B: BuilderRef, Dest: BasicBlockRef)\n                                -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildCondBr(B: BuilderRef,\n                                   If: ValueRef,\n                                   Then: BasicBlockRef,\n                                   Else: BasicBlockRef)\n                                -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildSwitch(B: BuilderRef, V: ValueRef,\n                                       Else: BasicBlockRef, NumCases: c_uint)\n                                    -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildIndirectBr(B: BuilderRef, Addr: ValueRef,\n                                NumDests: c_uint) -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildInvoke(B: BuilderRef,\n                                       Fn: ValueRef,\n                                       Args: *ValueRef,\n                                       NumArgs: c_uint,\n                                       Then: BasicBlockRef,\n                                       Catch: BasicBlockRef,\n                                       Name: *c_char) -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildLandingPad(B: BuilderRef,\n                                       Ty: TypeRef,\n                                       PersFn: ValueRef,\n                                       NumClauses: c_uint,\n                                       Name: *c_char)\n                                    -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildResume(B: BuilderRef, Exn: ValueRef)\n                                    -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildUnreachable(B: BuilderRef) -> ValueRef;\n \n         /* Add a case to the switch instruction */\n+        #[fast_ffi]\n         pub unsafe fn LLVMAddCase(Switch: ValueRef,\n                               OnVal: ValueRef,\n                               Dest: BasicBlockRef);\n \n         /* Add a destination to the indirectbr instruction */\n+        #[fast_ffi]\n         pub unsafe fn LLVMAddDestination(IndirectBr: ValueRef,\n                                          Dest: BasicBlockRef);\n \n         /* Add a clause to the landing pad instruction */\n+        #[fast_ffi]\n         pub unsafe fn LLVMAddClause(LandingPad: ValueRef,\n                                     ClauseVal: ValueRef);\n \n         /* Set the cleanup on a landing pad instruction */\n+        #[fast_ffi]\n         pub unsafe fn LLVMSetCleanup(LandingPad: ValueRef, Val: Bool);\n \n         /* Arithmetic */\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildAdd(B: BuilderRef,\n                                    LHS: ValueRef,\n                                    RHS: ValueRef,\n                                    Name: *c_char)\n                                 -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildNSWAdd(B: BuilderRef,\n                                       LHS: ValueRef,\n                                       RHS: ValueRef,\n                                       Name: *c_char)\n                                    -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildNUWAdd(B: BuilderRef,\n                                       LHS: ValueRef,\n                                       RHS: ValueRef,\n                                       Name: *c_char)\n                                    -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildFAdd(B: BuilderRef,\n                                     LHS: ValueRef,\n                                     RHS: ValueRef,\n                                     Name: *c_char)\n                                  -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildSub(B: BuilderRef,\n                                    LHS: ValueRef,\n                                    RHS: ValueRef,\n                                    Name: *c_char)\n                                 -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildNSWSub(B: BuilderRef,\n                                       LHS: ValueRef,\n                                       RHS: ValueRef,\n                                       Name: *c_char)\n                                    -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildNUWSub(B: BuilderRef,\n                                       LHS: ValueRef,\n                                       RHS: ValueRef,\n                                       Name: *c_char)\n                                    -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildFSub(B: BuilderRef,\n                                     LHS: ValueRef,\n                                     RHS: ValueRef,\n                                     Name: *c_char)\n                                  -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildMul(B: BuilderRef,\n                                    LHS: ValueRef,\n                                    RHS: ValueRef,\n                                    Name: *c_char)\n                                 -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildNSWMul(B: BuilderRef,\n                                       LHS: ValueRef,\n                                       RHS: ValueRef,\n                                       Name: *c_char)\n                                    -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildNUWMul(B: BuilderRef,\n                                       LHS: ValueRef,\n                                       RHS: ValueRef,\n                                       Name: *c_char)\n                                    -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildFMul(B: BuilderRef,\n                                     LHS: ValueRef,\n                                     RHS: ValueRef,\n                                     Name: *c_char)\n                                  -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildUDiv(B: BuilderRef,\n                                     LHS: ValueRef,\n                                     RHS: ValueRef,\n                                     Name: *c_char)\n                                  -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildSDiv(B: BuilderRef,\n                                     LHS: ValueRef,\n                                     RHS: ValueRef,\n                                     Name: *c_char)\n                                  -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildExactSDiv(B: BuilderRef,\n                                          LHS: ValueRef,\n                                          RHS: ValueRef,\n                                          Name: *c_char)\n                                       -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildFDiv(B: BuilderRef,\n                                     LHS: ValueRef,\n                                     RHS: ValueRef,\n                                     Name: *c_char)\n                                  -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildURem(B: BuilderRef,\n                                     LHS: ValueRef,\n                                     RHS: ValueRef,\n                                     Name: *c_char)\n                                  -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildSRem(B: BuilderRef,\n                                     LHS: ValueRef,\n                                     RHS: ValueRef,\n                                     Name: *c_char)\n                                  -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildFRem(B: BuilderRef,\n                                     LHS: ValueRef,\n                                     RHS: ValueRef,\n                                     Name: *c_char)\n                                  -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildShl(B: BuilderRef,\n                                    LHS: ValueRef,\n                                    RHS: ValueRef,\n                                    Name: *c_char)\n                                 -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildLShr(B: BuilderRef,\n                                     LHS: ValueRef,\n                                     RHS: ValueRef,\n                                     Name: *c_char)\n                                  -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildAShr(B: BuilderRef,\n                                     LHS: ValueRef,\n                                     RHS: ValueRef,\n                                     Name: *c_char)\n                                  -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildAnd(B: BuilderRef,\n                                    LHS: ValueRef,\n                                    RHS: ValueRef,\n                                    Name: *c_char)\n                                 -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildOr(B: BuilderRef,\n                                   LHS: ValueRef,\n                                   RHS: ValueRef,\n                                   Name: *c_char)\n                                -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildXor(B: BuilderRef,\n                                    LHS: ValueRef,\n                                    RHS: ValueRef,\n                                    Name: *c_char)\n                                 -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildBinOp(B: BuilderRef,\n                                  Op: Opcode,\n                                  LHS: ValueRef,\n                                  RHS: ValueRef,\n                                  Name: *c_char)\n                               -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildNeg(B: BuilderRef,\n                                V: ValueRef,\n                                Name: *c_char)\n                             -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildNSWNeg(B: BuilderRef,\n                                   V: ValueRef,\n                                   Name: *c_char)\n                                -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildNUWNeg(B: BuilderRef,\n                                   V: ValueRef,\n                                   Name: *c_char)\n                                -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildFNeg(B: BuilderRef,\n                                 V: ValueRef,\n                                 Name: *c_char)\n                              -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildNot(B: BuilderRef,\n                                V: ValueRef,\n                                Name: *c_char)\n                             -> ValueRef;\n \n         /* Memory */\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildMalloc(B: BuilderRef,\n                                       Ty: TypeRef,\n                                       Name: *c_char)\n                                    -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildArrayMalloc(B: BuilderRef,\n                                            Ty: TypeRef,\n                                            Val: ValueRef,\n                                            Name: *c_char) -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildAlloca(B: BuilderRef,\n                                   Ty: TypeRef,\n                                   Name: *c_char)\n                                -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildArrayAlloca(B: BuilderRef,\n                                            Ty: TypeRef,\n                                            Val: ValueRef,\n                                            Name: *c_char) -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildFree(B: BuilderRef,\n                                     PointerVal: ValueRef) -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildLoad(B: BuilderRef,\n                                 PointerVal: ValueRef,\n                                 Name: *c_char)\n                              -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildStore(B: BuilderRef,\n                                      Val: ValueRef,\n                                      Ptr: ValueRef) -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildGEP(B: BuilderRef,\n                                Pointer: ValueRef,\n                                Indices: *ValueRef,\n                                NumIndices: c_uint,\n                                Name: *c_char)\n                             -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildInBoundsGEP(B: BuilderRef, Pointer: ValueRef,\n                                 Indices: *ValueRef, NumIndices: c_uint,\n                                 Name: *c_char)\n            -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildStructGEP(B: BuilderRef,\n                                      Pointer: ValueRef,\n                                      Idx: c_uint,\n                                      Name: *c_char)\n                                   -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildGlobalString(B: BuilderRef,\n                                         Str: *c_char,\n                                         Name: *c_char)\n                                      -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildGlobalStringPtr(B: BuilderRef,\n                                            Str: *c_char,\n                                            Name: *c_char)\n                                         -> ValueRef;\n \n         /* Casts */\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildTrunc(B: BuilderRef,\n                                      Val: ValueRef,\n                                      DestTy: TypeRef,\n                                      Name: *c_char) -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildZExt(B: BuilderRef,\n                                     Val: ValueRef,\n                                     DestTy: TypeRef,\n                                     Name: *c_char)\n                                  -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildSExt(B: BuilderRef,\n                                     Val: ValueRef,\n                                     DestTy: TypeRef,\n                                     Name: *c_char)\n                                  -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildFPToUI(B: BuilderRef,\n                                       Val: ValueRef,\n                                       DestTy: TypeRef,\n                                       Name: *c_char) -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildFPToSI(B: BuilderRef,\n                                       Val: ValueRef,\n                                       DestTy: TypeRef,\n                                       Name: *c_char) -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildUIToFP(B: BuilderRef,\n                                       Val: ValueRef,\n                                       DestTy: TypeRef,\n                                       Name: *c_char) -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildSIToFP(B: BuilderRef,\n                                       Val: ValueRef,\n                                       DestTy: TypeRef,\n                                       Name: *c_char) -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildFPTrunc(B: BuilderRef,\n                                        Val: ValueRef,\n                                        DestTy: TypeRef,\n                                        Name: *c_char) -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildFPExt(B: BuilderRef,\n                                      Val: ValueRef,\n                                      DestTy: TypeRef,\n                                      Name: *c_char) -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildPtrToInt(B: BuilderRef,\n                                         Val: ValueRef,\n                                         DestTy: TypeRef,\n                                         Name: *c_char) -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildIntToPtr(B: BuilderRef,\n                                         Val: ValueRef,\n                                         DestTy: TypeRef,\n                                         Name: *c_char) -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildBitCast(B: BuilderRef,\n                                        Val: ValueRef,\n                                        DestTy: TypeRef,\n                                        Name: *c_char) -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildZExtOrBitCast(B: BuilderRef,\n                                          Val: ValueRef,\n                                          DestTy: TypeRef,\n                                          Name: *c_char)\n                                       -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildSExtOrBitCast(B: BuilderRef,\n                                          Val: ValueRef,\n                                          DestTy: TypeRef,\n                                          Name: *c_char)\n                                       -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildTruncOrBitCast(B: BuilderRef,\n                                           Val: ValueRef,\n                                           DestTy: TypeRef,\n                                           Name: *c_char)\n                                        -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildCast(B: BuilderRef, Op: Opcode, Val: ValueRef,\n                          DestTy: TypeRef, Name: *c_char) -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildPointerCast(B: BuilderRef,\n                                        Val: ValueRef,\n                                        DestTy: TypeRef,\n                                        Name: *c_char)\n                                     -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildIntCast(B: BuilderRef,\n                                        Val: ValueRef,\n                                        DestTy: TypeRef,\n                                        Name: *c_char) -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildFPCast(B: BuilderRef,\n                                       Val: ValueRef,\n                                       DestTy: TypeRef,\n                                       Name: *c_char) -> ValueRef;\n \n         /* Comparisons */\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildICmp(B: BuilderRef, Op: c_uint, LHS: ValueRef,\n                          RHS: ValueRef, Name: *c_char) -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildFCmp(B: BuilderRef, Op: c_uint, LHS: ValueRef,\n                          RHS: ValueRef, Name: *c_char) -> ValueRef;\n \n         /* Miscellaneous instructions */\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildPhi(B: BuilderRef,\n                                    Ty: TypeRef,\n                                    Name: *c_char)\n                                 -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildCall(B: BuilderRef,\n                                     Fn: ValueRef,\n                                     Args: *ValueRef,\n                                     NumArgs: c_uint,\n                                     Name: *c_char)\n                                  -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildSelect(B: BuilderRef,\n                                       If: ValueRef,\n                                       Then: ValueRef,\n                                       Else: ValueRef,\n                                       Name: *c_char)\n                                    -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildVAArg(B: BuilderRef,\n                                      list: ValueRef,\n                                      Ty: TypeRef,\n                                      Name: *c_char)\n                                   -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildExtractElement(B: BuilderRef,\n                                           VecVal: ValueRef,\n                                           Index: ValueRef,\n                                           Name: *c_char)\n                                        -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildInsertElement(B: BuilderRef,\n                                          VecVal: ValueRef,\n                                          EltVal: ValueRef,\n                                          Index: ValueRef,\n                                          Name: *c_char)\n                                       -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildShuffleVector(B: BuilderRef,\n                                          V1: ValueRef,\n                                          V2: ValueRef,\n                                          Mask: ValueRef,\n                                          Name: *c_char)\n                                       -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildExtractValue(B: BuilderRef,\n                                         AggVal: ValueRef,\n                                         Index: c_uint,\n                                         Name: *c_char)\n                                      -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildInsertValue(B: BuilderRef,\n                                        AggVal: ValueRef,\n                                        EltVal: ValueRef,\n                                        Index: c_uint,\n                                        Name: *c_char)\n                                     -> ValueRef;\n \n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildIsNull(B: BuilderRef,\n                                       Val: ValueRef,\n                                       Name: *c_char)\n                                    -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildIsNotNull(B: BuilderRef,\n                                          Val: ValueRef,\n                                          Name: *c_char)\n                                       -> ValueRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMBuildPtrDiff(B: BuilderRef,\n                                        LHS: ValueRef,\n                                        RHS: ValueRef,\n@@ -1225,155 +1575,227 @@ pub mod llvm {\n                               ++Order: AtomicOrdering) -> ValueRef;\n \n         /* Selected entries from the downcasts. */\n+        #[fast_ffi]\n         pub unsafe fn LLVMIsATerminatorInst(Inst: ValueRef) -> ValueRef;\n \n         /** Writes a module to the specified path. Returns 0 on success. */\n+        #[fast_ffi]\n         pub unsafe fn LLVMWriteBitcodeToFile(M: ModuleRef,\n                                              Path: *c_char) -> c_int;\n \n         /** Creates target data from a target layout string. */\n+        #[fast_ffi]\n         pub unsafe fn LLVMCreateTargetData(StringRep: *c_char)\n                                         -> TargetDataRef;\n         /** Adds the target data to the given pass manager. The pass manager\n             references the target data only weakly. */\n+        #[fast_ffi]\n         pub unsafe fn LLVMAddTargetData(TD: TargetDataRef,\n                                         PM: PassManagerRef);\n         /** Number of bytes clobbered when doing a Store to *T. */\n+        #[fast_ffi]\n         pub unsafe fn LLVMStoreSizeOfType(TD: TargetDataRef, Ty: TypeRef)\n             -> c_ulonglong;\n \n         /** Number of bytes clobbered when doing a Store to *T. */\n+        #[fast_ffi]\n         pub unsafe fn LLVMSizeOfTypeInBits(TD: TargetDataRef, Ty: TypeRef)\n             -> c_ulonglong;\n \n         /** Distance between successive elements in an array of T.\n         Includes ABI padding. */\n+        #[fast_ffi]\n         pub unsafe fn LLVMABISizeOfType(TD: TargetDataRef, Ty: TypeRef)\n                                      -> c_uint;\n \n         /** Returns the preferred alignment of a type. */\n+        #[fast_ffi]\n         pub unsafe fn LLVMPreferredAlignmentOfType(TD: TargetDataRef,\n                                         Ty: TypeRef) -> c_uint;\n         /** Returns the minimum alignment of a type. */\n+        #[fast_ffi]\n         pub unsafe fn LLVMABIAlignmentOfType(TD: TargetDataRef,\n                                   Ty: TypeRef) -> c_uint;\n         /**\n          * Returns the minimum alignment of a type when part of a call frame.\n          */\n+        #[fast_ffi]\n         pub unsafe fn LLVMCallFrameAlignmentOfType(TD: TargetDataRef,\n                                                    Ty: TypeRef)\n                                                 -> c_uint;\n \n         /** Disposes target data. */\n+        #[fast_ffi]\n         pub unsafe fn LLVMDisposeTargetData(TD: TargetDataRef);\n \n         /** Creates a pass manager. */\n+        #[fast_ffi]\n         pub unsafe fn LLVMCreatePassManager() -> PassManagerRef;\n         /** Disposes a pass manager. */\n+        #[fast_ffi]\n         pub unsafe fn LLVMDisposePassManager(PM: PassManagerRef);\n         /** Runs a pass manager on a module. */\n+        #[fast_ffi]\n         pub unsafe fn LLVMRunPassManager(PM: PassManagerRef,\n                                          M: ModuleRef) -> Bool;\n \n         /** Adds a verification pass. */\n+        #[fast_ffi]\n         pub unsafe fn LLVMAddVerifierPass(PM: PassManagerRef);\n \n+        #[fast_ffi]\n         pub unsafe fn LLVMAddGlobalOptimizerPass(PM: PassManagerRef);\n+        #[fast_ffi]\n         pub unsafe fn LLVMAddIPSCCPPass(PM: PassManagerRef);\n+        #[fast_ffi]\n         pub unsafe fn LLVMAddDeadArgEliminationPass(PM: PassManagerRef);\n+        #[fast_ffi]\n         pub unsafe fn LLVMAddInstructionCombiningPass(PM: PassManagerRef);\n+        #[fast_ffi]\n         pub unsafe fn LLVMAddCFGSimplificationPass(PM: PassManagerRef);\n+        #[fast_ffi]\n         pub unsafe fn LLVMAddFunctionInliningPass(PM: PassManagerRef);\n+        #[fast_ffi]\n         pub unsafe fn LLVMAddFunctionAttrsPass(PM: PassManagerRef);\n+        #[fast_ffi]\n         pub unsafe fn LLVMAddScalarReplAggregatesPass(PM: PassManagerRef);\n+        #[fast_ffi]\n         pub unsafe fn LLVMAddScalarReplAggregatesPassSSA(PM: PassManagerRef);\n+        #[fast_ffi]\n         pub unsafe fn LLVMAddJumpThreadingPass(PM: PassManagerRef);\n+        #[fast_ffi]\n         pub unsafe fn LLVMAddConstantPropagationPass(PM: PassManagerRef);\n+        #[fast_ffi]\n         pub unsafe fn LLVMAddReassociatePass(PM: PassManagerRef);\n+        #[fast_ffi]\n         pub unsafe fn LLVMAddLoopRotatePass(PM: PassManagerRef);\n+        #[fast_ffi]\n         pub unsafe fn LLVMAddLICMPass(PM: PassManagerRef);\n+        #[fast_ffi]\n         pub unsafe fn LLVMAddLoopUnswitchPass(PM: PassManagerRef);\n+        #[fast_ffi]\n         pub unsafe fn LLVMAddLoopDeletionPass(PM: PassManagerRef);\n+        #[fast_ffi]\n         pub unsafe fn LLVMAddLoopUnrollPass(PM: PassManagerRef);\n+        #[fast_ffi]\n         pub unsafe fn LLVMAddGVNPass(PM: PassManagerRef);\n+        #[fast_ffi]\n         pub unsafe fn LLVMAddMemCpyOptPass(PM: PassManagerRef);\n+        #[fast_ffi]\n         pub unsafe fn LLVMAddSCCPPass(PM: PassManagerRef);\n+        #[fast_ffi]\n         pub unsafe fn LLVMAddDeadStoreEliminationPass(PM: PassManagerRef);\n+        #[fast_ffi]\n         pub unsafe fn LLVMAddStripDeadPrototypesPass(PM: PassManagerRef);\n+        #[fast_ffi]\n         pub unsafe fn LLVMAddConstantMergePass(PM: PassManagerRef);\n+        #[fast_ffi]\n         pub unsafe fn LLVMAddArgumentPromotionPass(PM: PassManagerRef);\n+        #[fast_ffi]\n         pub unsafe fn LLVMAddTailCallEliminationPass(PM: PassManagerRef);\n+        #[fast_ffi]\n         pub unsafe fn LLVMAddIndVarSimplifyPass(PM: PassManagerRef);\n+        #[fast_ffi]\n         pub unsafe fn LLVMAddAggressiveDCEPass(PM: PassManagerRef);\n+        #[fast_ffi]\n         pub unsafe fn LLVMAddGlobalDCEPass(PM: PassManagerRef);\n+        #[fast_ffi]\n         pub unsafe fn LLVMAddCorrelatedValuePropagationPass(PM:\n                                                             PassManagerRef);\n+        #[fast_ffi]\n         pub unsafe fn LLVMAddPruneEHPass(PM: PassManagerRef);\n+        #[fast_ffi]\n         pub unsafe fn LLVMAddSimplifyLibCallsPass(PM: PassManagerRef);\n+        #[fast_ffi]\n         pub unsafe fn LLVMAddLoopIdiomPass(PM: PassManagerRef);\n+        #[fast_ffi]\n         pub unsafe fn LLVMAddEarlyCSEPass(PM: PassManagerRef);\n+        #[fast_ffi]\n         pub unsafe fn LLVMAddTypeBasedAliasAnalysisPass(PM: PassManagerRef);\n+        #[fast_ffi]\n         pub unsafe fn LLVMAddBasicAliasAnalysisPass(PM: PassManagerRef);\n \n+        #[fast_ffi]\n         pub unsafe fn LLVMPassManagerBuilderCreate() -> PassManagerBuilderRef;\n+        #[fast_ffi]\n         pub unsafe fn LLVMPassManagerBuilderDispose(PMB:\n                                                     PassManagerBuilderRef);\n+        #[fast_ffi]\n         pub unsafe fn LLVMPassManagerBuilderSetOptLevel(\n             PMB: PassManagerBuilderRef, OptimizationLevel: c_uint);\n+        #[fast_ffi]\n         pub unsafe fn LLVMPassManagerBuilderSetSizeLevel(\n             PMB: PassManagerBuilderRef, Value: Bool);\n+        #[fast_ffi]\n         pub unsafe fn LLVMPassManagerBuilderSetDisableUnitAtATime(\n             PMB: PassManagerBuilderRef, Value: Bool);\n+        #[fast_ffi]\n         pub unsafe fn LLVMPassManagerBuilderSetDisableUnrollLoops(\n             PMB: PassManagerBuilderRef, Value: Bool);\n+        #[fast_ffi]\n         pub unsafe fn LLVMPassManagerBuilderSetDisableSimplifyLibCalls\n             (PMB: PassManagerBuilderRef, Value: Bool);\n+        #[fast_ffi]\n         pub unsafe fn LLVMPassManagerBuilderUseInlinerWithThreshold\n             (PMB: PassManagerBuilderRef, threshold: c_uint);\n+        #[fast_ffi]\n         pub unsafe fn LLVMPassManagerBuilderPopulateModulePassManager\n             (PMB: PassManagerBuilderRef, PM: PassManagerRef);\n \n+        #[fast_ffi]\n         pub unsafe fn LLVMPassManagerBuilderPopulateFunctionPassManager\n             (PMB: PassManagerBuilderRef, PM: PassManagerRef);\n \n         /** Destroys a memory buffer. */\n+        #[fast_ffi]\n         pub unsafe fn LLVMDisposeMemoryBuffer(MemBuf: MemoryBufferRef);\n \n \n         /* Stuff that's in rustllvm/ because it's not upstream yet. */\n \n         /** Opens an object file. */\n+        #[fast_ffi]\n         pub unsafe fn LLVMCreateObjectFile(MemBuf: MemoryBufferRef)\n                                         -> ObjectFileRef;\n         /** Closes an object file. */\n+        #[fast_ffi]\n         pub unsafe fn LLVMDisposeObjectFile(ObjFile: ObjectFileRef);\n \n         /** Enumerates the sections in an object file. */\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetSections(ObjFile: ObjectFileRef)\n                                    -> SectionIteratorRef;\n         /** Destroys a section iterator. */\n+        #[fast_ffi]\n         pub unsafe fn LLVMDisposeSectionIterator(SI: SectionIteratorRef);\n         /** Returns true if the section iterator is at the end of the section\n             list: */\n+        #[fast_ffi]\n         pub unsafe fn LLVMIsSectionIteratorAtEnd(ObjFile: ObjectFileRef,\n                                       SI: SectionIteratorRef) -> Bool;\n         /** Moves the section iterator to point to the next section. */\n+        #[fast_ffi]\n         pub unsafe fn LLVMMoveToNextSection(SI: SectionIteratorRef);\n         /** Returns the current section name. */\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetSectionName(SI: SectionIteratorRef) -> *c_char;\n         /** Returns the current section size. */\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetSectionSize(SI: SectionIteratorRef)\n                                       -> c_ulonglong;\n         /** Returns the current section contents as a string buffer. */\n+        #[fast_ffi]\n         pub unsafe fn LLVMGetSectionContents(SI: SectionIteratorRef)\n                                           -> *c_char;\n \n         /** Reads the given file and returns it as a memory buffer. Use\n             LLVMDisposeMemoryBuffer() to get rid of it. */\n+        #[fast_ffi]\n         pub unsafe fn LLVMRustCreateMemoryBufferWithContentsOfFile(\n                 Path: *c_char)\n              -> MemoryBufferRef;\n \n+        #[fast_ffi]\n         pub unsafe fn LLVMRustWriteOutputFile(PM: PassManagerRef,\n                                               M: ModuleRef,\n                                               Triple: *c_char,\n@@ -1387,58 +1809,72 @@ pub mod llvm {\n \n         /** Returns a string describing the last error caused by an LLVMRust*\n             call. */\n+        #[fast_ffi]\n         pub unsafe fn LLVMRustGetLastError() -> *c_char;\n \n         /** Prepare the JIT. Returns a memory manager that can load crates. */\n+        #[fast_ffi]\n         pub unsafe fn LLVMRustPrepareJIT(__morestack: *()) -> *();\n \n         /** Load a crate into the memory manager. */\n+        #[fast_ffi]\n         pub unsafe fn LLVMRustLoadCrate(MM: *(),\n                                         Filename: *c_char)\n                                      -> bool;\n \n         /** Execute the JIT engine. */\n+        #[fast_ffi]\n         pub unsafe fn LLVMRustExecuteJIT(MM: *(),\n                               PM: PassManagerRef,\n                               M: ModuleRef,\n                               OptLevel: c_int,\n                               EnableSegmentedStacks: bool) -> *();\n \n         /** Parses the bitcode in the given memory buffer. */\n+        #[fast_ffi]\n         pub unsafe fn LLVMRustParseBitcode(MemBuf: MemoryBufferRef)\n                                         -> ModuleRef;\n \n         /** Parses LLVM asm in the given file */\n+        #[fast_ffi]\n         pub unsafe fn LLVMRustParseAssemblyFile(Filename: *c_char)\n                                              -> ModuleRef;\n \n+        #[fast_ffi]\n         pub unsafe fn LLVMRustAddPrintModulePass(PM: PassManagerRef,\n                                                  M: ModuleRef,\n                                                  Output: *c_char);\n \n         /** Turn on LLVM pass-timing. */\n+        #[fast_ffi]\n         pub unsafe fn LLVMRustEnableTimePasses();\n \n         /// Print the pass timings since static dtors aren't picking them up.\n+        #[fast_ffi]\n         pub unsafe fn LLVMRustPrintPassTimings();\n \n+        #[fast_ffi]\n         pub unsafe fn LLVMStructCreateNamed(C: ContextRef, Name: *c_char)\n                                          -> TypeRef;\n \n+        #[fast_ffi]\n         pub unsafe fn LLVMStructSetBody(StructTy: TypeRef,\n                                         ElementTypes: *TypeRef,\n                                         ElementCount: c_uint,\n                                         Packed: Bool);\n \n+        #[fast_ffi]\n         pub unsafe fn LLVMConstNamedStruct(S: TypeRef,\n                                            ConstantVals: *ValueRef,\n                                            Count: c_uint)\n                                         -> ValueRef;\n \n         /** Enables LLVM debug output. */\n+        #[fast_ffi]\n         pub unsafe fn LLVMSetDebug(Enabled: c_int);\n \n         /** Prepares inline assembly. */\n+        #[fast_ffi]\n         pub unsafe fn LLVMInlineAsm(Ty: TypeRef, AsmString: *c_char,\n                                     Constraints: *c_char, SideEffects: Bool,\n                                     AlignStack: Bool, Dialect: c_uint)"}, {"sha": "a67be995171ffab8c8b6e279fe6785e8511735f4", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f903ae9e72ec02539373da22fd4d025422af7554/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f903ae9e72ec02539373da22fd4d025422af7554/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=f903ae9e72ec02539373da22fd4d025422af7554", "patch": "@@ -1336,17 +1336,7 @@ fn roundtrip(in_item: Option<@ast::item>) {\n     let ebml_doc = reader::Doc(@bytes);\n     let out_item = decode_item_ast(ebml_doc);\n \n-    let exp_str = do io::with_str_writer |w| {\n-        in_item.encode(&prettyprint::Serializer(w))\n-    };\n-    let out_str = do io::with_str_writer |w| {\n-        out_item.encode(&prettyprint::Serializer(w))\n-    };\n-\n-    debug!(\"expected string: %s\", exp_str);\n-    debug!(\"actual string  : %s\", out_str);\n-\n-    assert!(exp_str == out_str);\n+    assert_eq!(in_item, out_item);\n }\n \n #[test]"}, {"sha": "46813974af1663cef4e9a60efa8cf3f3532a523b", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 61, "deletions": 24, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/f903ae9e72ec02539373da22fd4d025422af7554/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f903ae9e72ec02539373da22fd4d025422af7554/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=f903ae9e72ec02539373da22fd4d025422af7554", "patch": "@@ -399,24 +399,24 @@ pub fn set_optimize_for_size(f: ValueRef) {\n     unsafe {\n         llvm::LLVMAddFunctionAttr(f,\n                                   lib::llvm::OptimizeForSizeAttribute\n-                                  as c_ulonglong,\n-                                  0u as c_ulonglong);\n+                                    as c_uint,\n+                                  0);\n     }\n }\n \n pub fn set_no_inline(f: ValueRef) {\n     unsafe {\n         llvm::LLVMAddFunctionAttr(f,\n-                                  lib::llvm::NoInlineAttribute as c_ulonglong,\n-                                  0u as c_ulonglong);\n+                                  lib::llvm::NoInlineAttribute as c_uint,\n+                                  0);\n     }\n }\n \n pub fn set_no_unwind(f: ValueRef) {\n     unsafe {\n         llvm::LLVMAddFunctionAttr(f,\n-                                  lib::llvm::NoUnwindAttribute as c_ulonglong,\n-                                  0u as c_ulonglong);\n+                                  lib::llvm::NoUnwindAttribute as c_uint,\n+                                  0);\n     }\n }\n \n@@ -425,15 +425,16 @@ pub fn set_no_unwind(f: ValueRef) {\n pub fn set_uwtable(f: ValueRef) {\n     unsafe {\n         llvm::LLVMAddFunctionAttr(f,\n-                                  lib::llvm::UWTableAttribute as c_ulonglong,\n-                                  0u as c_ulonglong);\n+                                  lib::llvm::UWTableAttribute as c_uint,\n+                                  0);\n     }\n }\n \n pub fn set_inline_hint(f: ValueRef) {\n     unsafe {\n-        llvm::LLVMAddFunctionAttr(f, lib::llvm::InlineHintAttribute\n-                                  as c_ulonglong, 0u as c_ulonglong);\n+        llvm::LLVMAddFunctionAttr(f,\n+                                  lib::llvm::InlineHintAttribute as c_uint,\n+                                  0);\n     }\n }\n \n@@ -449,14 +450,15 @@ pub fn set_inline_hint_if_appr(attrs: &[ast::attribute],\n \n pub fn set_always_inline(f: ValueRef) {\n     unsafe {\n-        llvm::LLVMAddFunctionAttr(f, lib::llvm::AlwaysInlineAttribute\n-                                  as c_ulonglong, 0u as c_ulonglong);\n+        llvm::LLVMAddFunctionAttr(f,\n+                                  lib::llvm::AlwaysInlineAttribute as c_uint,\n+                                  0);\n     }\n }\n \n-pub fn set_custom_stack_growth_fn(f: ValueRef) {\n+pub fn set_fixed_stack_segment(f: ValueRef) {\n     unsafe {\n-        llvm::LLVMAddFunctionAttr(f, 0u as c_ulonglong, 1u as c_ulonglong);\n+        llvm::LLVMAddFunctionAttr(f, 0, 1 << (39 - 32));\n     }\n }\n \n@@ -1774,6 +1776,7 @@ pub fn trans_closure(ccx: @CrateContext,\n                      param_substs: Option<@param_substs>,\n                      id: ast::node_id,\n                      impl_id: Option<ast::def_id>,\n+                     attributes: &[ast::attribute],\n                      maybe_load_env: &fn(fn_ctxt),\n                      finish: &fn(block)) {\n     ccx.stats.n_closures += 1;\n@@ -1784,10 +1787,20 @@ pub fn trans_closure(ccx: @CrateContext,\n            param_substs.repr(ccx.tcx));\n \n     // Set up arguments to the function.\n-    let fcx = new_fn_ctxt_w_id(ccx, path, llfndecl, id, impl_id, param_substs,\n-                                  Some(body.span));\n-    let raw_llargs = create_llargs_for_fn_args(fcx, ty_self,\n-                                               decl.inputs);\n+    let fcx = new_fn_ctxt_w_id(ccx,\n+                               path,\n+                               llfndecl,\n+                               id,\n+                               impl_id,\n+                               param_substs,\n+                               Some(body.span));\n+    let raw_llargs = create_llargs_for_fn_args(fcx, ty_self, decl.inputs);\n+\n+    // Set the fixed stack segment flag if necessary.\n+    if attr::attrs_contains_name(attributes, \"fixed_stack_segment\") {\n+        set_no_inline(fcx.llfn);\n+        set_fixed_stack_segment(fcx.llfn);\n+    }\n \n     // Set GC for function.\n     if ccx.sess.opts.gc {\n@@ -1840,7 +1853,8 @@ pub fn trans_fn(ccx: @CrateContext,\n                 ty_self: self_arg,\n                 param_substs: Option<@param_substs>,\n                 id: ast::node_id,\n-                impl_id: Option<ast::def_id>) {\n+                impl_id: Option<ast::def_id>,\n+                attrs: &[ast::attribute]) {\n     let do_time = ccx.sess.trans_stats();\n     let start = if do_time { time::get_time() }\n                 else { time::Timespec::new(0, 0) };\n@@ -1850,8 +1864,16 @@ pub fn trans_fn(ccx: @CrateContext,\n     let _icx = ccx.insn_ctxt(\"trans_fn\");\n     ccx.stats.n_fns += 1;\n     let the_path_str = path_str(ccx.sess, path);\n-    trans_closure(ccx, path, decl, body, llfndecl, ty_self,\n-                  param_substs, id, impl_id,\n+    trans_closure(ccx,\n+                  path,\n+                  decl,\n+                  body,\n+                  llfndecl,\n+                  ty_self,\n+                  param_substs,\n+                  id,\n+                  impl_id,\n+                  attrs,\n                   |fcx| {\n                       if ccx.sess.opts.extra_debuginfo {\n                           debuginfo::create_function(fcx);\n@@ -2023,8 +2045,16 @@ pub fn trans_struct_dtor(ccx: @CrateContext,\n   }\n   /* Translate the dtor body */\n   let decl = ast_util::dtor_dec();\n-  trans_fn(ccx, path, &decl, body, lldecl,\n-           impl_self(class_ty), psubsts, dtor_id, None);\n+  trans_fn(ccx,\n+           path,\n+           &decl,\n+           body,\n+           lldecl,\n+           impl_self(class_ty),\n+           psubsts,\n+           dtor_id,\n+           None,\n+           []);\n   lldecl\n }\n \n@@ -2073,7 +2103,14 @@ pub fn trans_item(ccx: @CrateContext, item: ast::item) {\n             let llfndecl = get_item_val(ccx, item.id);\n             trans_fn(ccx,\n                      vec::append(/*bad*/copy *path, ~[path_name(item.ident)]),\n-                     decl, body, llfndecl, no_self, None, item.id, None);\n+                     decl,\n+                     body,\n+                     llfndecl,\n+                     no_self,\n+                     None,\n+                     item.id,\n+                     None,\n+                     item.attrs);\n         } else {\n             for body.node.stmts.each |stmt| {\n                 match stmt.node {"}, {"sha": "380a512d17b23290a1dd31785504caa975ff5747", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f903ae9e72ec02539373da22fd4d025422af7554/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f903ae9e72ec02539373da22fd4d025422af7554/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=f903ae9e72ec02539373da22fd4d025422af7554", "patch": "@@ -416,9 +416,16 @@ pub fn trans_expr_fn(bcx: block,\n                                                  None => None};\n             let ClosureResult {llbox, cdata_ty, bcx}\n                 = build_closure(bcx, cap_vars, sigil, ret_handle);\n-            trans_closure(ccx, sub_path, decl,\n-                          body, llfn, no_self,\n-                          /*bad*/ copy bcx.fcx.param_substs, user_id, None,\n+            trans_closure(ccx,\n+                          sub_path,\n+                          decl,\n+                          body,\n+                          llfn,\n+                          no_self,\n+                          /*bad*/ copy bcx.fcx.param_substs,\n+                          user_id,\n+                          None,\n+                          [],\n                           |fcx| load_environment(fcx, cdata_ty, cap_vars,\n                                                  ret_handle.is_some(), sigil),\n                           |bcx| {"}, {"sha": "8c308bfa8894bed9b8f976f28840de813fde09be", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 45, "deletions": 5, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/f903ae9e72ec02539373da22fd4d025422af7554/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f903ae9e72ec02539373da22fd4d025422af7554/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=f903ae9e72ec02539373da22fd4d025422af7554", "patch": "@@ -316,11 +316,11 @@ pub fn trans_foreign_mod(ccx: @CrateContext,\n     {\n         let llwrapfn = get_item_val(ccx, id);\n         let tys = shim_types(ccx, id);\n-        if attr::attrs_contains_name(\n-            foreign_item.attrs, \"rust_stack\")\n-        {\n+        if attr::attrs_contains_name(foreign_item.attrs, \"rust_stack\") {\n             build_direct_fn(ccx, llwrapfn, foreign_item,\n                             &tys, cc);\n+        } else if attr::attrs_contains_name(foreign_item.attrs, \"fast_ffi\") {\n+            build_fast_ffi_fn(ccx, llwrapfn, foreign_item, &tys, cc);\n         } else {\n             let llshimfn = build_shim_fn(ccx, foreign_item,\n                                          &tys, cc);\n@@ -380,16 +380,47 @@ pub fn trans_foreign_mod(ccx: @CrateContext,\n     fn build_direct_fn(ccx: @CrateContext, decl: ValueRef,\n                        item: @ast::foreign_item, tys: &ShimTypes,\n                        cc: lib::llvm::CallConv) {\n+        debug!(\"build_direct_fn(%s)\", *link_name(ccx, item));\n+\n+        let fcx = new_fn_ctxt(ccx, ~[], decl, None);\n+        let bcx = top_scope_block(fcx, None), lltop = bcx.llbb;\n+        let llbasefn = base_fn(ccx, *link_name(ccx, item), tys, cc);\n+        let ty = ty::lookup_item_type(ccx.tcx,\n+                                      ast_util::local_def(item.id)).ty;\n+        let args = vec::from_fn(ty::ty_fn_args(ty).len(), |i| {\n+            get_param(decl, i + first_real_arg)\n+        });\n+        let retval = Call(bcx, llbasefn, args);\n+        let ret_ty = ty::ty_fn_ret(ty);\n+        if !ty::type_is_nil(ret_ty) && !ty::type_is_bot(ret_ty) {\n+            Store(bcx, retval, fcx.llretptr);\n+        }\n+        build_return(bcx);\n+        finish_fn(fcx, lltop);\n+    }\n+\n+    // FIXME (#2535): this is very shaky and probably gets ABIs wrong all\n+    // over the place\n+    fn build_fast_ffi_fn(ccx: @CrateContext,\n+                         decl: ValueRef,\n+                         item: @ast::foreign_item,\n+                         tys: &ShimTypes,\n+                         cc: lib::llvm::CallConv) {\n+        debug!(\"build_fast_ffi_fn(%s)\", *link_name(ccx, item));\n+\n         let fcx = new_fn_ctxt(ccx, ~[], decl, None);\n         let bcx = top_scope_block(fcx, None), lltop = bcx.llbb;\n         let llbasefn = base_fn(ccx, *link_name(ccx, item), tys, cc);\n+        set_no_inline(fcx.llfn);\n+        set_fixed_stack_segment(fcx.llfn);\n         let ty = ty::lookup_item_type(ccx.tcx,\n                                       ast_util::local_def(item.id)).ty;\n         let args = vec::from_fn(ty::ty_fn_args(ty).len(), |i| {\n             get_param(decl, i + first_real_arg)\n         });\n         let retval = Call(bcx, llbasefn, args);\n-        if !ty::type_is_nil(ty::ty_fn_ret(ty)) {\n+        let ret_ty = ty::ty_fn_ret(ty);\n+        if !ty::type_is_nil(ret_ty) && !ty::type_is_bot(ret_ty) {\n             Store(bcx, retval, fcx.llretptr);\n         }\n         build_return(bcx);\n@@ -1006,7 +1037,16 @@ pub fn trans_foreign_fn(ccx: @CrateContext,\n             )));\n         let llty = type_of_fn_from_ty(ccx, t);\n         let llfndecl = decl_internal_cdecl_fn(ccx.llmod, ps, llty);\n-        trans_fn(ccx, path, decl, body, llfndecl, no_self, None, id, None);\n+        trans_fn(ccx,\n+                 path,\n+                 decl,\n+                 body,\n+                 llfndecl,\n+                 no_self,\n+                 None,\n+                 id,\n+                 None,\n+                 []);\n         return llfndecl;\n     }\n "}, {"sha": "3f2fb95513a39c88c5064b967470c5fc6ce3c014", "filename": "src/librustc/middle/trans/inline.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f903ae9e72ec02539373da22fd4d025422af7554/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f903ae9e72ec02539373da22fd4d025422af7554/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs?ref=f903ae9e72ec02539373da22fd4d025422af7554", "patch": "@@ -116,7 +116,8 @@ pub fn maybe_instantiate_inline(ccx: @CrateContext, fn_id: ast::def_id,\n                          self_kind,\n                          None,\n                          mth.id,\n-                         Some(impl_did));\n+                         Some(impl_did),\n+                         []);\n             }\n             local_def(mth.id)\n           }"}, {"sha": "d3a15cbbfe1504247a4f7d1fd103dc17c7a53fa9", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f903ae9e72ec02539373da22fd4d025422af7554/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f903ae9e72ec02539373da22fd4d025422af7554/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=f903ae9e72ec02539373da22fd4d025422af7554", "patch": "@@ -137,7 +137,8 @@ pub fn trans_method(ccx: @CrateContext,\n              self_arg,\n              param_substs,\n              method.id,\n-             Some(impl_id));\n+             Some(impl_id),\n+             []);\n }\n \n pub fn trans_self_arg(bcx: block,"}, {"sha": "a6930b339ae72ed39f8df8bf17fd07dff5c5d4e4", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f903ae9e72ec02539373da22fd4d025422af7554/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f903ae9e72ec02539373da22fd4d025422af7554/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=f903ae9e72ec02539373da22fd4d025422af7554", "patch": "@@ -195,7 +195,16 @@ pub fn monomorphic_fn(ccx: @CrateContext,\n             }, _) => {\n         let d = mk_lldecl();\n         set_inline_hint_if_appr(/*bad*/copy i.attrs, d);\n-        trans_fn(ccx, pt, decl, body, d, no_self, psubsts, fn_id.node, None);\n+        trans_fn(ccx,\n+                 pt,\n+                 decl,\n+                 body,\n+                 d,\n+                 no_self,\n+                 psubsts,\n+                 fn_id.node,\n+                 None,\n+                 []);\n         d\n       }\n       ast_map::node_item(*) => {"}, {"sha": "021811ffa7624023d5d2766610531c1959f8789a", "filename": "src/rt/rust_task.cpp", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f903ae9e72ec02539373da22fd4d025422af7554/src%2Frt%2Frust_task.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/f903ae9e72ec02539373da22fd4d025422af7554/src%2Frt%2Frust_task.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task.cpp?ref=f903ae9e72ec02539373da22fd4d025422af7554", "patch": "@@ -457,8 +457,9 @@ rust_task::get_next_stack_size(size_t min, size_t current, size_t requested) {\n         \"min: %\" PRIdPTR \" current: %\" PRIdPTR \" requested: %\" PRIdPTR,\n         min, current, requested);\n \n-    // Allocate at least enough to accomodate the next frame\n-    size_t sz = std::max(min, requested);\n+    // Allocate at least enough to accomodate the next frame, plus a little\n+    // slack to avoid thrashing\n+    size_t sz = std::max(min, requested + (requested / 2));\n \n     // And double the stack size each allocation\n     const size_t max = 1024 * 1024;"}, {"sha": "e524e6de859c84b463c1d73aa4f89e7f4aed3b63", "filename": "src/rt/rust_upcall.cpp", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f903ae9e72ec02539373da22fd4d025422af7554/src%2Frt%2Frust_upcall.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/f903ae9e72ec02539373da22fd4d025422af7554/src%2Frt%2Frust_upcall.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_upcall.cpp?ref=f903ae9e72ec02539373da22fd4d025422af7554", "patch": "@@ -191,6 +191,14 @@ rust_upcall_malloc(type_desc *td, uintptr_t size) {\n     return upcall_malloc(td, size);\n }\n \n+extern \"C\" CDECL uintptr_t\n+rust_upcall_malloc_noswitch(type_desc *td, uintptr_t size) {\n+    rust_task *task = rust_get_current_task();\n+    s_malloc_args args = {task, 0, td, size};\n+    upcall_s_malloc(&args);\n+    return args.retval;\n+}\n+\n /**********************************************************************\n  * Called whenever an object in the task-local heap is freed.\n  */\n@@ -231,6 +239,13 @@ rust_upcall_free(void* ptr) {\n     upcall_free(ptr);\n }\n \n+extern \"C\" CDECL void\n+rust_upcall_free_noswitch(void* ptr) {\n+    rust_task *task = rust_get_current_task();\n+    s_free_args args = {task,ptr};\n+    upcall_s_free(&args);\n+}\n+\n /**********************************************************************/\n \n extern \"C\" _Unwind_Reason_Code"}, {"sha": "4a79b2e4ae6435a54100a8e11a6c6b70d0d09ba2", "filename": "src/rt/rustrt.def.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f903ae9e72ec02539373da22fd4d025422af7554/src%2Frt%2Frustrt.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/f903ae9e72ec02539373da22fd4d025422af7554/src%2Frt%2Frustrt.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frustrt.def.in?ref=f903ae9e72ec02539373da22fd4d025422af7554", "patch": "@@ -66,7 +66,9 @@ upcall_del_stack\n upcall_reset_stack_limit\n rust_upcall_fail\n rust_upcall_free\n+rust_upcall_free_noswitch\n rust_upcall_malloc\n+rust_upcall_malloc_noswitch\n rust_uv_loop_new\n rust_uv_loop_delete\n rust_uv_walk"}, {"sha": "1612fec402974f94ae98a4ae4821fedf0ca266d9", "filename": "src/rustllvm/RustWrapper.cpp", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f903ae9e72ec02539373da22fd4d025422af7554/src%2Frustllvm%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/f903ae9e72ec02539373da22fd4d025422af7554/src%2Frustllvm%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FRustWrapper.cpp?ref=f903ae9e72ec02539373da22fd4d025422af7554", "patch": "@@ -451,6 +451,7 @@ LLVMRustWriteOutputFile(LLVMPassManagerRef PMR,\n   TargetOptions Options;\n   Options.NoFramePointerElim = true;\n   Options.EnableSegmentedStacks = EnableSegmentedStacks;\n+  Options.FixedStackSegmentSize = 2 * 1024 * 1024;  // XXX: This is too big.\n \n   PassManager *PM = unwrap<PassManager>(PMR);\n "}, {"sha": "bfc15acaa763c52ec9b24c41984f065cb19dd1d2", "filename": "src/test/run-pass/auto-encode.rs", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f903ae9e72ec02539373da22fd4d025422af7554/src%2Ftest%2Frun-pass%2Fauto-encode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f903ae9e72ec02539373da22fd4d025422af7554/src%2Ftest%2Frun-pass%2Fauto-encode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauto-encode.rs?ref=f903ae9e72ec02539373da22fd4d025422af7554", "patch": "@@ -25,20 +25,6 @@ use std::ebml;\n use std::serialize::{Decodable, Encodable};\n use std::time;\n \n-<<<<<<< HEAD\n-=======\n-fn test_prettyprint<A:Encodable<prettyprint::Serializer>>(\n-    a: &A,\n-    expected: &~str\n-) {\n-    let s = do io::with_str_writer |w| {\n-        a.encode(&prettyprint::Serializer(w))\n-    };\n-    debug!(\"s == %?\", s);\n-    assert!(s == *expected);\n-}\n-\n->>>>>>> librustc: Remove `fail_unless!`\n fn test_ebml<A:\n     Eq +\n     Encodable<EBWriter::Encoder> +"}]}