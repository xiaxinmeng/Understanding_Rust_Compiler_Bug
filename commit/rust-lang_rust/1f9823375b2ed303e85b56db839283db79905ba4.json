{"sha": "1f9823375b2ed303e85b56db839283db79905ba4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFmOTgyMzM3NWIyZWQzMDNlODViNTZkYjgzOTI4M2RiNzk5MDViYTQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-04-28T19:51:35Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-04-28T19:51:35Z"}, "message": "auto merge of #6092 : gifnksm/rust/impl-integer-bigint, r=graydon\n\nThis is a follow-up commit for #6041 (and depending on #6048).\r\nAlso adding `#[inline(always)]` for almost every methods in `std::bigint`.", "tree": {"sha": "10e7eccec6448892c04a76467dd3ff1f24d86715", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/10e7eccec6448892c04a76467dd3ff1f24d86715"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1f9823375b2ed303e85b56db839283db79905ba4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1f9823375b2ed303e85b56db839283db79905ba4", "html_url": "https://github.com/rust-lang/rust/commit/1f9823375b2ed303e85b56db839283db79905ba4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1f9823375b2ed303e85b56db839283db79905ba4/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cdd342bd34a7036cf1ddf3f6832c73fa018f305b", "url": "https://api.github.com/repos/rust-lang/rust/commits/cdd342bd34a7036cf1ddf3f6832c73fa018f305b", "html_url": "https://github.com/rust-lang/rust/commit/cdd342bd34a7036cf1ddf3f6832c73fa018f305b"}, {"sha": "92f0dc6b4bbab3bcfc96c0588776032d5f8e4966", "url": "https://api.github.com/repos/rust-lang/rust/commits/92f0dc6b4bbab3bcfc96c0588776032d5f8e4966", "html_url": "https://github.com/rust-lang/rust/commit/92f0dc6b4bbab3bcfc96c0588776032d5f8e4966"}], "stats": {"total": 527, "additions": 383, "deletions": 144}, "files": [{"sha": "3ea94eababb42b6f250ebae1e88e3a3bd50b936f", "filename": "src/libstd/num/bigint.rs", "status": "modified", "additions": 383, "deletions": 144, "changes": 527, "blob_url": "https://github.com/rust-lang/rust/blob/1f9823375b2ed303e85b56db839283db79905ba4/src%2Flibstd%2Fnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f9823375b2ed303e85b56db839283db79905ba4/src%2Flibstd%2Fnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fbigint.rs?ref=1f9823375b2ed303e85b56db839283db79905ba4", "patch": "@@ -53,15 +53,19 @@ pub mod BigDigit {\n     priv static hi_mask: uint = (-1 as uint) << bits;\n     priv static lo_mask: uint = (-1 as uint) >> bits;\n \n+    #[inline(always)]\n     priv fn get_hi(n: uint) -> BigDigit { (n >> bits) as BigDigit }\n+    #[inline(always)]\n     priv fn get_lo(n: uint) -> BigDigit { (n & lo_mask) as BigDigit }\n \n     /// Split one machine sized unsigned integer into two BigDigits.\n+    #[inline(always)]\n     pub fn from_uint(n: uint) -> (BigDigit, BigDigit) {\n         (get_hi(n), get_lo(n))\n     }\n \n     /// Join two BigDigits into one machine sized unsigned integer\n+    #[inline(always)]\n     pub fn to_uint(hi: BigDigit, lo: BigDigit) -> uint {\n         (lo as uint) | ((hi as uint) << bits)\n     }\n@@ -78,32 +82,40 @@ pub struct BigUint {\n }\n \n impl Eq for BigUint {\n+    #[inline(always)]\n     fn eq(&self, other: &BigUint) -> bool { self.equals(other) }\n+    #[inline(always)]\n     fn ne(&self, other: &BigUint) -> bool { !self.equals(other) }\n }\n \n impl TotalEq for BigUint {\n+    #[inline(always)]\n     fn equals(&self, other: &BigUint) -> bool {\n         match self.cmp(other) { Equal => true, _ => false }\n     }\n }\n \n impl Ord for BigUint {\n+    #[inline(always)]\n     fn lt(&self, other: &BigUint) -> bool {\n         match self.cmp(other) { Less => true, _ => false}\n     }\n+    #[inline(always)]\n     fn le(&self, other: &BigUint) -> bool {\n         match self.cmp(other) { Less | Equal => true, _ => false }\n     }\n+    #[inline(always)]\n     fn ge(&self, other: &BigUint) -> bool {\n         match self.cmp(other) { Greater | Equal => true, _ => false }\n     }\n+    #[inline(always)]\n     fn gt(&self, other: &BigUint) -> bool {\n         match self.cmp(other) { Greater => true, _ => false }\n     }\n }\n \n impl TotalOrd for BigUint {\n+    #[inline(always)]\n     fn cmp(&self, other: &BigUint) -> Ordering {\n         let s_len = self.data.len(), o_len = other.data.len();\n         if s_len < o_len { return Less; }\n@@ -121,16 +133,19 @@ impl TotalOrd for BigUint {\n }\n \n impl ToStr for BigUint {\n+    #[inline(always)]\n     fn to_str(&self) -> ~str { self.to_str_radix(10) }\n }\n \n impl from_str::FromStr for BigUint {\n+    #[inline(always)]\n     fn from_str(s: &str) -> Option<BigUint> {\n         FromStrRadix::from_str_radix(s, 10)\n     }\n }\n \n impl Shl<uint, BigUint> for BigUint {\n+    #[inline(always)]\n     fn shl(&self, rhs: &uint) -> BigUint {\n         let n_unit = *rhs / BigDigit::bits;\n         let n_bits = *rhs % BigDigit::bits;\n@@ -139,6 +154,7 @@ impl Shl<uint, BigUint> for BigUint {\n }\n \n impl Shr<uint, BigUint> for BigUint {\n+    #[inline(always)]\n     fn shr(&self, rhs: &uint) -> BigUint {\n         let n_unit = *rhs / BigDigit::bits;\n         let n_bits = *rhs % BigDigit::bits;\n@@ -147,18 +163,22 @@ impl Shr<uint, BigUint> for BigUint {\n }\n \n impl Zero for BigUint {\n+    #[inline(always)]\n     fn zero() -> BigUint { BigUint::new(~[]) }\n \n+    #[inline(always)]\n     fn is_zero(&self) -> bool { self.data.is_empty() }\n }\n \n impl One for BigUint {\n+    #[inline(always)]\n     fn one() -> BigUint { BigUint::new(~[1]) }\n }\n \n impl Unsigned for BigUint {}\n \n impl Add<BigUint, BigUint> for BigUint {\n+    #[inline(always)]\n     fn add(&self, other: &BigUint) -> BigUint {\n         let new_len = uint::max(self.data.len(), other.data.len());\n \n@@ -178,6 +198,7 @@ impl Add<BigUint, BigUint> for BigUint {\n }\n \n impl Sub<BigUint, BigUint> for BigUint {\n+    #[inline(always)]\n     fn sub(&self, other: &BigUint) -> BigUint {\n         let new_len = uint::max(self.data.len(), other.data.len());\n \n@@ -233,6 +254,7 @@ impl Mul<BigUint, BigUint> for BigUint {\n \n         return ll + mm.shl_unit(half_len) + hh.shl_unit(half_len * 2);\n \n+        #[inline(always)]\n         fn mul_digit(a: &BigUint, n: BigDigit) -> BigUint {\n             if n == 0 { return Zero::zero(); }\n             if n == 1 { return copy *a; }\n@@ -249,13 +271,15 @@ impl Mul<BigUint, BigUint> for BigUint {\n             return BigUint::new(prod + [carry]);\n         }\n \n+        #[inline(always)]\n         fn cut_at(a: &BigUint, n: uint) -> (BigUint, BigUint) {\n             let mid = uint::min(a.data.len(), n);\n             return (BigUint::from_slice(vec::slice(a.data, mid,\n                                                    a.data.len())),\n                     BigUint::from_slice(vec::slice(a.data, 0, mid)));\n         }\n \n+        #[inline(always)]\n         fn sub_sign(a: BigUint, b: BigUint) -> (Ordering, BigUint) {\n             match a.cmp(&b) {\n                 Less    => (Less,    b - a),\n@@ -267,34 +291,175 @@ impl Mul<BigUint, BigUint> for BigUint {\n }\n \n impl Quot<BigUint, BigUint> for BigUint {\n+    #[inline(always)]\n     fn quot(&self, other: &BigUint) -> BigUint {\n         let (q, _) = self.quot_rem(other);\n         return q;\n     }\n }\n \n impl Rem<BigUint, BigUint> for BigUint {\n+    #[inline(always)]\n     fn rem(&self, other: &BigUint) -> BigUint {\n         let (_, r) = self.quot_rem(other);\n         return r;\n     }\n }\n \n impl Neg<BigUint> for BigUint {\n+    #[inline(always)]\n     fn neg(&self) -> BigUint { fail!() }\n }\n \n+impl Integer for BigUint {\n+    #[inline(always)]\n+    fn div(&self, other: &BigUint) -> BigUint {\n+        let (d, _) = self.div_mod(other);\n+        return d;\n+    }\n+\n+    #[inline(always)]\n+    fn modulo(&self, other: &BigUint) -> BigUint {\n+        let (_, m) = self.div_mod(other);\n+        return m;\n+    }\n+\n+    #[inline(always)]\n+    fn div_mod(&self, other: &BigUint) -> (BigUint, BigUint) {\n+        if other.is_zero() { fail!() }\n+        if self.is_zero() { return (Zero::zero(), Zero::zero()); }\n+        if *other == One::one() { return (copy *self, Zero::zero()); }\n+\n+        match self.cmp(other) {\n+            Less    => return (Zero::zero(), copy *self),\n+            Equal   => return (One::one(), Zero::zero()),\n+            Greater => {} // Do nothing\n+        }\n+\n+        let mut shift = 0;\n+        let mut n = *other.data.last();\n+        while n < (1 << BigDigit::bits - 2) {\n+            n <<= 1;\n+            shift += 1;\n+        }\n+        assert!(shift < BigDigit::bits);\n+        let (d, m) = div_mod_inner(self << shift, other << shift);\n+        return (d, m >> shift);\n+\n+        #[inline(always)]\n+        fn div_mod_inner(a: BigUint, b: BigUint) -> (BigUint, BigUint) {\n+            let mut m = a;\n+            let mut d = Zero::zero::<BigUint>();\n+            let mut n = 1;\n+            while m >= b {\n+                let mut (d0, d_unit, b_unit) = div_estimate(&m, &b, n);\n+                let mut prod = b * d0;\n+                while prod > m {\n+                    d0   -= d_unit;\n+                    prod -= b_unit;\n+                }\n+                if d0.is_zero() {\n+                    n = 2;\n+                    loop;\n+                }\n+                n = 1;\n+                d += d0;\n+                m -= prod;\n+            }\n+            return (d, m);\n+        }\n+\n+        #[inline(always)]\n+        fn div_estimate(a: &BigUint, b: &BigUint, n: uint)\n+            -> (BigUint, BigUint, BigUint) {\n+            if a.data.len() < n {\n+                return (Zero::zero(), Zero::zero(), copy *a);\n+            }\n+\n+            let an = vec::slice(a.data, a.data.len() - n, a.data.len());\n+            let bn = *b.data.last();\n+            let mut d = ~[];\n+            let mut carry = 0;\n+            for an.each_reverse |elt| {\n+                let ai = BigDigit::to_uint(carry, *elt);\n+                let di = ai / (bn as uint);\n+                assert!(di < BigDigit::base);\n+                carry = (ai % (bn as uint)) as BigDigit;\n+                d = ~[di as BigDigit] + d;\n+            }\n+\n+            let shift = (a.data.len() - an.len()) - (b.data.len() - 1);\n+            if shift == 0 {\n+                return (BigUint::new(d), One::one(), copy *b);\n+            }\n+            return (BigUint::from_slice(d).shl_unit(shift),\n+                    One::one::<BigUint>().shl_unit(shift),\n+                    b.shl_unit(shift));\n+        }\n+    }\n+\n+    #[inline(always)]\n+    fn quot_rem(&self, other: &BigUint) -> (BigUint, BigUint) {\n+        self.div_mod(other)\n+    }\n+\n+    /**\n+     * Calculates the Greatest Common Divisor (GCD) of the number and `other`\n+     *\n+     * The result is always positive\n+     */\n+    #[inline(always)]\n+    fn gcd(&self, other: &BigUint) -> BigUint {\n+        // Use Euclid's algorithm\n+        let mut m = *self, n = *other;\n+        while !m.is_zero() {\n+            let temp = m;\n+            m = n % temp;\n+            n = temp;\n+        }\n+        return n;\n+    }\n+\n+    /**\n+     * Calculates the Lowest Common Multiple (LCM) of the number and `other`\n+     */\n+    #[inline(always)]\n+    fn lcm(&self, other: &BigUint) -> BigUint { ((*self * *other) / self.gcd(other)) }\n+\n+    /// Returns `true` if the number can be divided by `other` without leaving a remainder\n+    #[inline(always)]\n+    fn divisible_by(&self, other: &BigUint) -> bool { (*self % *other).is_zero() }\n+\n+    /// Returns `true` if the number is divisible by `2`\n+    #[inline(always)]\n+    fn is_even(&self) -> bool {\n+        // Considering only the last digit.\n+        if self.data.is_empty() {\n+            true\n+        } else {\n+            self.data.last().is_even()\n+        }\n+    }\n+\n+    /// Returns `true` if the number is not divisible by `2`\n+    #[inline(always)]\n+    fn is_odd(&self) -> bool { !self.is_even() }\n+}\n+\n impl IntConvertible for BigUint {\n+    #[inline(always)]\n     fn to_int(&self) -> int {\n         uint::min(self.to_uint(), int::max_value as uint) as int\n     }\n \n+    #[inline(always)]\n     fn from_int(n: int) -> BigUint {\n         if (n < 0) { Zero::zero() } else { BigUint::from_uint(n as uint) }\n     }\n }\n \n impl ToStrRadix for BigUint {\n+    #[inline(always)]\n     fn to_str_radix(&self, radix: uint) -> ~str {\n         assert!(1 < radix && radix <= 16);\n         let (base, max_len) = get_radix_base(radix);\n@@ -303,6 +468,7 @@ impl ToStrRadix for BigUint {\n         }\n         return fill_concat(convert_base(copy *self, base), radix, max_len);\n \n+        #[inline(always)]\n         fn convert_base(n: BigUint, base: uint) -> ~[BigDigit] {\n             let divider    = BigUint::from_uint(base);\n             let mut result = ~[];\n@@ -318,6 +484,7 @@ impl ToStrRadix for BigUint {\n             return result;\n         }\n \n+        #[inline(always)]\n         fn fill_concat(v: &[BigDigit], radix: uint, l: uint) -> ~str {\n             if v.is_empty() { return ~\"0\" }\n             let s = str::concat(vec::reversed(v).map(|n| {\n@@ -331,14 +498,16 @@ impl ToStrRadix for BigUint {\n \n impl FromStrRadix for BigUint {\n     /// Creates and initializes an BigUint.\n+    #[inline(always)]\n     pub fn from_str_radix(s: &str, radix: uint)\n         -> Option<BigUint> {\n         BigUint::parse_bytes(str::to_bytes(s), radix)\n     }\n }\n \n-pub impl BigUint {\n+impl BigUint {\n     /// Creates and initializes an BigUint.\n+    #[inline(always)]\n     pub fn new(v: ~[BigDigit]) -> BigUint {\n         // omit trailing zeros\n         let new_len = v.rposition(|n| *n != 0).map_default(0, |p| *p + 1);\n@@ -350,6 +519,7 @@ pub impl BigUint {\n     }\n \n     /// Creates and initializes an BigUint.\n+    #[inline(always)]\n     pub fn from_uint(n: uint) -> BigUint {\n         match BigDigit::from_uint(n) {\n             (0,  0)  => Zero::zero(),\n@@ -359,11 +529,13 @@ pub impl BigUint {\n     }\n \n     /// Creates and initializes an BigUint.\n+    #[inline(always)]\n     pub fn from_slice(slice: &[BigDigit]) -> BigUint {\n         return BigUint::new(vec::from_slice(slice));\n     }\n \n     /// Creates and initializes an BigUint.\n+    #[inline(always)]\n     pub fn parse_bytes(buf: &[u8], radix: uint)\n         -> Option<BigUint> {\n         let (base, unit_len) = get_radix_base(radix);\n@@ -386,93 +558,8 @@ pub impl BigUint {\n         }\n     }\n \n-    fn abs(&self) -> BigUint { copy *self }\n-\n-    fn div(&self, other: &BigUint) -> BigUint {\n-        let (d, _) = self.div_mod(other);\n-        return d;\n-    }\n-    fn modulo(&self, other: &BigUint) -> BigUint {\n-        let (_, m) = self.div_mod(other);\n-        return m;\n-    }\n-\n-    fn div_mod(&self, other: &BigUint) -> (BigUint, BigUint) {\n-        if other.is_zero() { fail!() }\n-        if self.is_zero() { return (Zero::zero(), Zero::zero()); }\n-        if *other == One::one() { return (copy *self, Zero::zero()); }\n-\n-        match self.cmp(other) {\n-            Less    => return (Zero::zero(), copy *self),\n-            Equal   => return (One::one(), Zero::zero()),\n-            Greater => {} // Do nothing\n-        }\n-\n-        let mut shift = 0;\n-        let mut n = *other.data.last();\n-        while n < (1 << BigDigit::bits - 2) {\n-            n <<= 1;\n-            shift += 1;\n-        }\n-        assert!(shift < BigDigit::bits);\n-        let (d, m) = div_mod_inner(self << shift, other << shift);\n-        return (d, m >> shift);\n-\n-        fn div_mod_inner(a: BigUint, b: BigUint) -> (BigUint, BigUint) {\n-            let mut m = a;\n-            let mut d = Zero::zero::<BigUint>();\n-            let mut n = 1;\n-            while m >= b {\n-                let mut (d0, d_unit, b_unit) = div_estimate(&m, &b, n);\n-                let mut prod = b * d0;\n-                while prod > m {\n-                    d0   -= d_unit;\n-                    prod -= b_unit;\n-                }\n-                if d0.is_zero() {\n-                    n = 2;\n-                    loop;\n-                }\n-                n = 1;\n-                d += d0;\n-                m -= prod;\n-            }\n-            return (d, m);\n-        }\n-\n-        fn div_estimate(a: &BigUint, b: &BigUint, n: uint)\n-            -> (BigUint, BigUint, BigUint) {\n-            if a.data.len() < n {\n-                return (Zero::zero(), Zero::zero(), copy *a);\n-            }\n-\n-            let an = vec::slice(a.data, a.data.len() - n, a.data.len());\n-            let bn = *b.data.last();\n-            let mut d = ~[];\n-            let mut carry = 0;\n-            for an.each_reverse |elt| {\n-                let ai = BigDigit::to_uint(carry, *elt);\n-                let di = ai / (bn as uint);\n-                assert!(di < BigDigit::base);\n-                carry = (ai % (bn as uint)) as BigDigit;\n-                d = ~[di as BigDigit] + d;\n-            }\n-\n-            let shift = (a.data.len() - an.len()) - (b.data.len() - 1);\n-            if shift == 0 {\n-                return (BigUint::new(d), One::one(), copy *b);\n-            }\n-            return (BigUint::from_slice(d).shl_unit(shift),\n-                    One::one::<BigUint>().shl_unit(shift),\n-                    b.shl_unit(shift));\n-        }\n-    }\n-\n-    fn quot_rem(&self, other: &BigUint) -> (BigUint, BigUint) {\n-        self.div_mod(other)\n-    }\n-\n-    fn to_uint(&self) -> uint {\n+    #[inline(always)]\n+    pub fn to_uint(&self) -> uint {\n         match self.data.len() {\n             0 => 0,\n             1 => self.data[0] as uint,\n@@ -481,12 +568,14 @@ pub impl BigUint {\n         }\n     }\n \n+    #[inline(always)]\n     priv fn shl_unit(self, n_unit: uint) -> BigUint {\n         if n_unit == 0 || self.is_zero() { return self; }\n \n         return BigUint::new(vec::from_elem(n_unit, 0) + self.data);\n     }\n \n+    #[inline(always)]\n     priv fn shl_bits(self, n_bits: uint) -> BigUint {\n         if n_bits == 0 || self.is_zero() { return self; }\n \n@@ -502,6 +591,7 @@ pub impl BigUint {\n         return BigUint::new(shifted + [carry]);\n     }\n \n+    #[inline(always)]\n     priv fn shr_unit(self, n_unit: uint) -> BigUint {\n         if n_unit == 0 { return self; }\n         if self.data.len() < n_unit { return Zero::zero(); }\n@@ -510,6 +600,7 @@ pub impl BigUint {\n         );\n     }\n \n+    #[inline(always)]\n     priv fn shr_bits(self, n_bits: uint) -> BigUint {\n         if n_bits == 0 || self.data.is_empty() { return self; }\n \n@@ -524,6 +615,7 @@ pub impl BigUint {\n }\n \n #[cfg(target_arch = \"x86_64\")]\n+#[inline(always)]\n priv fn get_radix_base(radix: uint) -> (uint, uint) {\n     assert!(1 < radix && radix <= 16);\n     match radix {\n@@ -549,6 +641,7 @@ priv fn get_radix_base(radix: uint) -> (uint, uint) {\n #[cfg(target_arch = \"arm\")]\n #[cfg(target_arch = \"x86\")]\n #[cfg(target_arch = \"mips\")]\n+#[inline(always)]\n priv fn get_radix_base(radix: uint) -> (uint, uint) {\n     assert!(1 < radix && radix <= 16);\n     match radix {\n@@ -576,21 +669,26 @@ priv fn get_radix_base(radix: uint) -> (uint, uint) {\n pub enum Sign { Minus, Zero, Plus }\n \n impl Ord for Sign {\n+    #[inline(always)]\n     fn lt(&self, other: &Sign) -> bool {\n         match self.cmp(other) { Less => true, _ => false}\n     }\n+    #[inline(always)]\n     fn le(&self, other: &Sign) -> bool {\n         match self.cmp(other) { Less | Equal => true, _ => false }\n     }\n+    #[inline(always)]\n     fn ge(&self, other: &Sign) -> bool {\n         match self.cmp(other) { Greater | Equal => true, _ => false }\n     }\n+    #[inline(always)]\n     fn gt(&self, other: &Sign) -> bool {\n         match self.cmp(other) { Greater => true, _ => false }\n     }\n }\n \n impl TotalOrd for Sign {\n+    #[inline(always)]\n     fn cmp(&self, other: &Sign) -> Ordering {\n         match (*self, *other) {\n           (Minus, Minus) | (Zero,  Zero) | (Plus, Plus) => Equal,\n@@ -602,6 +700,7 @@ impl TotalOrd for Sign {\n \n impl Neg<Sign> for Sign {\n     /// Negate Sign value.\n+    #[inline(always)]\n     fn neg(&self) -> Sign {\n         match *self {\n           Minus => Plus,\n@@ -618,32 +717,40 @@ pub struct BigInt {\n }\n \n impl Eq for BigInt {\n+    #[inline(always)]\n     fn eq(&self, other: &BigInt) -> bool { self.equals(other) }\n+    #[inline(always)]\n     fn ne(&self, other: &BigInt) -> bool { !self.equals(other) }\n }\n \n impl TotalEq for BigInt {\n+    #[inline(always)]\n     fn equals(&self, other: &BigInt) -> bool {\n         match self.cmp(other) { Equal => true, _ => false }\n     }\n }\n \n impl Ord for BigInt {\n+    #[inline(always)]\n     fn lt(&self, other: &BigInt) -> bool {\n         match self.cmp(other) { Less => true, _ => false}\n     }\n+    #[inline(always)]\n     fn le(&self, other: &BigInt) -> bool {\n         match self.cmp(other) { Less | Equal => true, _ => false }\n     }\n+    #[inline(always)]\n     fn ge(&self, other: &BigInt) -> bool {\n         match self.cmp(other) { Greater | Equal => true, _ => false }\n     }\n+    #[inline(always)]\n     fn gt(&self, other: &BigInt) -> bool {\n         match self.cmp(other) { Greater => true, _ => false }\n     }\n }\n \n impl TotalOrd for BigInt {\n+    #[inline(always)]\n     fn cmp(&self, other: &BigInt) -> Ordering {\n         let scmp = self.sign.cmp(&other.sign);\n         if scmp != Equal { return scmp; }\n@@ -657,49 +764,58 @@ impl TotalOrd for BigInt {\n }\n \n impl ToStr for BigInt {\n+    #[inline(always)]\n     fn to_str(&self) -> ~str { self.to_str_radix(10) }\n }\n \n impl from_str::FromStr for BigInt {\n+    #[inline(always)]\n     fn from_str(s: &str) -> Option<BigInt> {\n         FromStrRadix::from_str_radix(s, 10)\n     }\n }\n \n impl Shl<uint, BigInt> for BigInt {\n+    #[inline(always)]\n     fn shl(&self, rhs: &uint) -> BigInt {\n         BigInt::from_biguint(self.sign, self.data << *rhs)\n     }\n }\n \n impl Shr<uint, BigInt> for BigInt {\n+    #[inline(always)]\n     fn shr(&self, rhs: &uint) -> BigInt {\n         BigInt::from_biguint(self.sign, self.data >> *rhs)\n     }\n }\n \n impl Zero for BigInt {\n-    pub fn zero() -> BigInt {\n+    #[inline(always)]\n+    fn zero() -> BigInt {\n         BigInt::from_biguint(Zero, Zero::zero())\n     }\n \n+    #[inline(always)]\n     fn is_zero(&self) -> bool { self.sign == Zero }\n }\n \n impl One for BigInt {\n-    pub fn one() -> BigInt {\n+    #[inline(always)]\n+    fn one() -> BigInt {\n         BigInt::from_biguint(Plus, One::one())\n     }\n }\n \n impl Signed for BigInt {\n+    #[inline(always)]\n     fn abs(&self) -> BigInt {\n         match self.sign {\n             Plus | Zero => copy *self,\n             Minus => BigInt::from_biguint(Plus, copy self.data)\n         }\n     }\n \n+    #[inline(always)]\n     fn signum(&self) -> BigInt {\n         match self.sign {\n             Plus  => BigInt::from_biguint(Plus, One::one()),\n@@ -708,12 +824,15 @@ impl Signed for BigInt {\n         }\n     }\n \n+    #[inline(always)]\n     fn is_positive(&self) -> bool { self.sign == Plus }\n \n+    #[inline(always)]\n     fn is_negative(&self) -> bool { self.sign == Minus }\n }\n \n impl Add<BigInt, BigInt> for BigInt {\n+    #[inline(always)]\n     fn add(&self, other: &BigInt) -> BigInt {\n         match (self.sign, other.sign) {\n             (Zero, _)      => copy *other,\n@@ -728,6 +847,7 @@ impl Add<BigInt, BigInt> for BigInt {\n }\n \n impl Sub<BigInt, BigInt> for BigInt {\n+    #[inline(always)]\n     fn sub(&self, other: &BigInt) -> BigInt {\n         match (self.sign, other.sign) {\n             (Zero, _)    => -other,\n@@ -745,6 +865,7 @@ impl Sub<BigInt, BigInt> for BigInt {\n }\n \n impl Mul<BigInt, BigInt> for BigInt {\n+    #[inline(always)]\n     fn mul(&self, other: &BigInt) -> BigInt {\n         match (self.sign, other.sign) {\n             (Zero, _)     | (_,     Zero)  => Zero::zero(),\n@@ -759,26 +880,112 @@ impl Mul<BigInt, BigInt> for BigInt {\n }\n \n impl Quot<BigInt, BigInt> for BigInt {\n+    #[inline(always)]\n     fn quot(&self, other: &BigInt) -> BigInt {\n         let (q, _) = self.quot_rem(other);\n         return q;\n     }\n }\n \n impl Rem<BigInt, BigInt> for BigInt {\n+    #[inline(always)]\n     fn rem(&self, other: &BigInt) -> BigInt {\n         let (_, r) = self.quot_rem(other);\n         return r;\n     }\n }\n \n impl Neg<BigInt> for BigInt {\n+    #[inline(always)]\n     fn neg(&self) -> BigInt {\n         BigInt::from_biguint(self.sign.neg(), copy self.data)\n     }\n }\n \n+impl Integer for BigInt {\n+    #[inline(always)]\n+    fn div(&self, other: &BigInt) -> BigInt {\n+        let (d, _) = self.div_mod(other);\n+        return d;\n+    }\n+\n+    #[inline(always)]\n+    fn modulo(&self, other: &BigInt) -> BigInt {\n+        let (_, m) = self.div_mod(other);\n+        return m;\n+    }\n+\n+    #[inline(always)]\n+    fn div_mod(&self, other: &BigInt) -> (BigInt, BigInt) {\n+        // m.sign == other.sign\n+        let (d_ui, m_ui) = self.data.quot_rem(&other.data);\n+        let d = BigInt::from_biguint(Plus, d_ui),\n+            m = BigInt::from_biguint(Plus, m_ui);\n+        match (self.sign, other.sign) {\n+            (_,    Zero)   => fail!(),\n+            (Plus, Plus)  | (Zero, Plus)  => (d, m),\n+            (Plus, Minus) | (Zero, Minus) => if m.is_zero() {\n+                (-d, Zero::zero())\n+            } else {\n+                (-d - One::one(), m + *other)\n+            },\n+            (Minus, Plus) => if m.is_zero() {\n+                (-d, Zero::zero())\n+            } else {\n+                (-d - One::one(), other - m)\n+            },\n+            (Minus, Minus) => (d, -m)\n+        }\n+    }\n+\n+    #[inline(always)]\n+    fn quot_rem(&self, other: &BigInt) -> (BigInt, BigInt) {\n+        // r.sign == self.sign\n+        let (q_ui, r_ui) = self.data.div_mod(&other.data);\n+        let q = BigInt::from_biguint(Plus, q_ui);\n+        let r = BigInt::from_biguint(Plus, r_ui);\n+        match (self.sign, other.sign) {\n+            (_,    Zero)   => fail!(),\n+            (Plus, Plus)  | (Zero, Plus)  => ( q,  r),\n+            (Plus, Minus) | (Zero, Minus) => (-q,  r),\n+            (Minus, Plus)                 => (-q, -r),\n+            (Minus, Minus)                => ( q, -r)\n+        }\n+    }\n+\n+    /**\n+     * Calculates the Greatest Common Divisor (GCD) of the number and `other`\n+     *\n+     * The result is always positive\n+     */\n+    #[inline(always)]\n+    fn gcd(&self, other: &BigInt) -> BigInt {\n+        BigInt::from_biguint(Plus, self.data.gcd(&other.data))\n+    }\n+\n+    /**\n+     * Calculates the Lowest Common Multiple (LCM) of the number and `other`\n+     */\n+    #[inline(always)]\n+    fn lcm(&self, other: &BigInt) -> BigInt {\n+        BigInt::from_biguint(Plus, self.data.lcm(&other.data))\n+    }\n+\n+    /// Returns `true` if the number can be divided by `other` without leaving a remainder\n+    #[inline(always)]\n+    fn divisible_by(&self, other: &BigInt) -> bool { self.data.divisible_by(&other.data) }\n+\n+    /// Returns `true` if the number is divisible by `2`\n+    #[inline(always)]\n+    fn is_even(&self) -> bool { self.data.is_even() }\n+\n+    /// Returns `true` if the number is not divisible by `2`\n+    #[inline(always)]\n+    fn is_odd(&self) -> bool { self.data.is_odd() }\n+}\n+\n impl IntConvertible for BigInt {\n+    #[inline(always)]\n     fn to_int(&self) -> int {\n         match self.sign {\n             Plus  => uint::min(self.to_uint(), int::max_value as uint) as int,\n@@ -788,6 +995,7 @@ impl IntConvertible for BigInt {\n         }\n     }\n \n+    #[inline(always)]\n     fn from_int(n: int) -> BigInt {\n         if n > 0 {\n            return BigInt::from_biguint(Plus,  BigUint::from_uint(n as uint));\n@@ -802,6 +1010,7 @@ impl IntConvertible for BigInt {\n }\n \n impl ToStrRadix for BigInt {\n+    #[inline(always)]\n     fn to_str_radix(&self, radix: uint) -> ~str {\n         match self.sign {\n             Plus  => self.data.to_str_radix(radix),\n@@ -813,19 +1022,22 @@ impl ToStrRadix for BigInt {\n \n impl FromStrRadix for BigInt {\n     /// Creates and initializes an BigInt.\n-    pub fn from_str_radix(s: &str, radix: uint)\n+    #[inline(always)]\n+    fn from_str_radix(s: &str, radix: uint)\n         -> Option<BigInt> {\n         BigInt::parse_bytes(str::to_bytes(s), radix)\n     }\n }\n \n pub impl BigInt {\n     /// Creates and initializes an BigInt.\n+    #[inline(always)]\n     pub fn new(sign: Sign, v: ~[BigDigit]) -> BigInt {\n         BigInt::from_biguint(sign, BigUint::new(v))\n     }\n \n     /// Creates and initializes an BigInt.\n+    #[inline(always)]\n     pub fn from_biguint(sign: Sign, data: BigUint) -> BigInt {\n         if sign == Zero || data.is_zero() {\n             return BigInt { sign: Zero, data: Zero::zero() };\n@@ -834,17 +1046,20 @@ pub impl BigInt {\n     }\n \n     /// Creates and initializes an BigInt.\n+    #[inline(always)]\n     pub fn from_uint(n: uint) -> BigInt {\n         if n == 0 { return Zero::zero(); }\n         return BigInt::from_biguint(Plus, BigUint::from_uint(n));\n     }\n \n     /// Creates and initializes an BigInt.\n+    #[inline(always)]\n     pub fn from_slice(sign: Sign, slice: &[BigDigit]) -> BigInt {\n         BigInt::from_biguint(sign, BigUint::from_slice(slice))\n     }\n \n     /// Creates and initializes an BigInt.\n+    #[inline(always)]\n     pub fn parse_bytes(buf: &[u8], radix: uint)\n         -> Option<BigInt> {\n         if buf.is_empty() { return None; }\n@@ -858,57 +1073,7 @@ pub impl BigInt {\n             .map(|bu| BigInt::from_biguint(sign, *bu));\n     }\n \n-    fn abs(&self) -> BigInt {\n-        BigInt::from_biguint(Plus, copy self.data)\n-    }\n-\n-    fn div(&self, other: &BigInt) -> BigInt {\n-        let (d, _) = self.div_mod(other);\n-        return d;\n-    }\n-    fn modulo(&self, other: &BigInt) -> BigInt {\n-        let (_, m) = self.div_mod(other);\n-        return m;\n-    }\n-\n-    fn div_mod(&self, other: &BigInt) -> (BigInt, BigInt) {\n-        // m.sign == other.sign\n-        let (d_ui, m_ui) = self.data.quot_rem(&other.data);\n-        let d = BigInt::from_biguint(Plus, d_ui),\n-            m = BigInt::from_biguint(Plus, m_ui);\n-        match (self.sign, other.sign) {\n-            (_,    Zero)   => fail!(),\n-            (Plus, Plus)  | (Zero, Plus)  => (d, m),\n-            (Plus, Minus) | (Zero, Minus) => if m.is_zero() {\n-                (-d, Zero::zero())\n-            } else {\n-                (-d - One::one(), m + *other)\n-            },\n-            (Minus, Plus) => if m.is_zero() {\n-                (-d, Zero::zero())\n-            } else {\n-                (-d - One::one(), other - m)\n-            },\n-            (Minus, Minus) => (d, -m)\n-        }\n-    }\n-\n-    fn quot_rem(&self, other: &BigInt) -> (BigInt, BigInt) {\n-        // r.sign == self.sign\n-        let (q_ui, r_ui) = self.data.div_mod(&other.data);\n-        let q = BigInt::from_biguint(Plus, q_ui);\n-        let r = BigInt::from_biguint(Plus, r_ui);\n-        match (self.sign, other.sign) {\n-            (_,    Zero)   => fail!(),\n-            (Plus, Plus)  | (Zero, Plus)  => ( q,  r),\n-            (Plus, Minus) | (Zero, Minus) => (-q,  r),\n-            (Minus, Plus)                 => (-q, -r),\n-            (Minus, Minus)                => ( q, -r)\n-        }\n-    }\n-\n-    fn is_zero(&self) -> bool { self.sign == Zero }\n-\n+    #[inline(always)]\n     fn to_uint(&self) -> uint {\n         match self.sign {\n             Plus  => self.data.to_uint(),\n@@ -1229,6 +1394,41 @@ mod biguint_tests {\n         }\n     }\n \n+    #[test]\n+    fn test_gcd() {\n+        fn check(a: uint, b: uint, c: uint) {\n+            let big_a = BigUint::from_uint(a);\n+            let big_b = BigUint::from_uint(b);\n+            let big_c = BigUint::from_uint(c);\n+\n+            assert_eq!(big_a.gcd(&big_b), big_c);\n+        }\n+\n+        check(10, 2, 2);\n+        check(10, 3, 1);\n+        check(0, 3, 3);\n+        check(3, 3, 3);\n+        check(56, 42, 14);\n+    }\n+\n+    #[test]\n+    fn test_lcm() {\n+        fn check(a: uint, b: uint, c: uint) {\n+            let big_a = BigUint::from_uint(a);\n+            let big_b = BigUint::from_uint(b);\n+            let big_c = BigUint::from_uint(c);\n+\n+            assert_eq!(big_a.lcm(&big_b), big_c);\n+        }\n+\n+        check(1, 0, 0);\n+        check(0, 1, 0);\n+        check(1, 1, 1);\n+        check(8, 9, 72);\n+        check(11, 5, 55);\n+        check(99, 17, 1683);\n+    }\n+\n     fn to_str_pairs() -> ~[ (BigUint, ~[(uint, ~str)]) ] {\n         let bits = BigDigit::bits;\n         ~[( Zero::zero(), ~[\n@@ -1664,11 +1864,50 @@ mod bigint_tests {\n         }\n     }\n \n+    #[test]\n+    fn test_gcd() {\n+        fn check(a: int, b: int, c: int) {\n+            let big_a: BigInt = IntConvertible::from_int(a);\n+            let big_b: BigInt = IntConvertible::from_int(b);\n+            let big_c: BigInt = IntConvertible::from_int(c);\n+\n+            assert_eq!(big_a.gcd(&big_b), big_c);\n+        }\n+\n+        check(10, 2, 2);\n+        check(10, 3, 1);\n+        check(0, 3, 3);\n+        check(3, 3, 3);\n+        check(56, 42, 14);\n+        check(3, -3, 3);\n+        check(-6, 3, 3);\n+        check(-4, -2, 2);\n+    }\n+\n+    #[test]\n+    fn test_lcm() {\n+        fn check(a: int, b: int, c: int) {\n+            let big_a: BigInt = IntConvertible::from_int(a);\n+            let big_b: BigInt = IntConvertible::from_int(b);\n+            let big_c: BigInt = IntConvertible::from_int(c);\n+\n+            assert_eq!(big_a.lcm(&big_b), big_c);\n+        }\n+\n+        check(1, 0, 0);\n+        check(0, 1, 0);\n+        check(1, 1, 1);\n+        check(-1, 1, 1);\n+        check(1, -1, 1);\n+        check(-1, -1, 1);\n+        check(8, 9, 72);\n+        check(11, 5, 55);\n+    }\n+\n     #[test]\n     fn test_to_str_radix() {\n         fn check(n: int, ans: &str) {\n-            assert!(ans == IntConvertible::from_int::<BigInt>(\n-                n).to_str_radix(10));\n+            assert!(ans == IntConvertible::from_int::<BigInt>(n).to_str_radix(10));\n         }\n         check(10, \"10\");\n         check(1, \"1\");"}]}