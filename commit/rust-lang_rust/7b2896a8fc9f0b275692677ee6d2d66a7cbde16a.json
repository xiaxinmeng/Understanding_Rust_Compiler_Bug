{"sha": "7b2896a8fc9f0b275692677ee6d2d66a7cbde16a", "node_id": "C_kwDOAAsO6NoAKDdiMjg5NmE4ZmM5ZjBiMjc1NjkyNjc3ZWU2ZDJkNjZhN2NiZGUxNmE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-02-24T18:37:57Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-02-24T18:37:57Z"}, "message": "Auto merge of #8468 - flip1995:rustup, r=flip1995\n\nRustup\n\nr? `@ghost`\n\nchangelog: none", "tree": {"sha": "c1f3a6397af344960b94485c37224e7d3ab011e1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c1f3a6397af344960b94485c37224e7d3ab011e1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7b2896a8fc9f0b275692677ee6d2d66a7cbde16a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7b2896a8fc9f0b275692677ee6d2d66a7cbde16a", "html_url": "https://github.com/rust-lang/rust/commit/7b2896a8fc9f0b275692677ee6d2d66a7cbde16a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7b2896a8fc9f0b275692677ee6d2d66a7cbde16a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "042892a0815fe0fec72ea1a07348d99ca08bf944", "url": "https://api.github.com/repos/rust-lang/rust/commits/042892a0815fe0fec72ea1a07348d99ca08bf944", "html_url": "https://github.com/rust-lang/rust/commit/042892a0815fe0fec72ea1a07348d99ca08bf944"}, {"sha": "ce1904f6cf90bf16f51d226e1870abc643e5bfa2", "url": "https://api.github.com/repos/rust-lang/rust/commits/ce1904f6cf90bf16f51d226e1870abc643e5bfa2", "html_url": "https://github.com/rust-lang/rust/commit/ce1904f6cf90bf16f51d226e1870abc643e5bfa2"}], "stats": {"total": 280, "additions": 143, "deletions": 137}, "files": [{"sha": "5cc5530f874dd63e275f54d8832bf33ffd003e44", "filename": "Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7b2896a8fc9f0b275692677ee6d2d66a7cbde16a/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7b2896a8fc9f0b275692677ee6d2d66a7cbde16a/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=7b2896a8fc9f0b275692677ee6d2d66a7cbde16a", "patch": "@@ -1,6 +1,6 @@\n [package]\n name = \"clippy\"\n-version = \"0.1.60\"\n+version = \"0.1.61\"\n description = \"A bunch of helpful lints to avoid common pitfalls in Rust\"\n repository = \"https://github.com/rust-lang/rust-clippy\"\n readme = \"README.md\""}, {"sha": "40d7dd702628f77c47475290ad312c3e5b0160d1", "filename": "clippy_lints/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7b2896a8fc9f0b275692677ee6d2d66a7cbde16a/clippy_lints%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7b2896a8fc9f0b275692677ee6d2d66a7cbde16a/clippy_lints%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2FCargo.toml?ref=7b2896a8fc9f0b275692677ee6d2d66a7cbde16a", "patch": "@@ -1,6 +1,6 @@\n [package]\n name = \"clippy_lints\"\n-version = \"0.1.60\"\n+version = \"0.1.61\"\n description = \"A bunch of helpful lints to avoid common pitfalls in Rust\"\n repository = \"https://github.com/rust-lang/rust-clippy\"\n readme = \"README.md\""}, {"sha": "7637666d059ef319be896210e2e7e0c6cb0feca5", "filename": "clippy_lints/src/case_sensitive_file_extension_comparisons.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7b2896a8fc9f0b275692677ee6d2d66a7cbde16a/clippy_lints%2Fsrc%2Fcase_sensitive_file_extension_comparisons.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b2896a8fc9f0b275692677ee6d2d66a7cbde16a/clippy_lints%2Fsrc%2Fcase_sensitive_file_extension_comparisons.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcase_sensitive_file_extension_comparisons.rs?ref=7b2896a8fc9f0b275692677ee6d2d66a7cbde16a", "patch": "@@ -47,7 +47,7 @@ fn check_case_sensitive_file_extension_comparison(ctx: &LateContext<'_>, expr: &\n         then {\n             let mut ty = ctx.typeck_results().expr_ty(obj);\n             ty = match ty.kind() {\n-                ty::Ref(_, ty, ..) => ty,\n+                ty::Ref(_, ty, ..) => *ty,\n                 _ => ty\n             };\n "}, {"sha": "b80d55dd192a10201dc0fa67c4c49fd7cbdbdbea", "filename": "clippy_lints/src/default_numeric_fallback.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7b2896a8fc9f0b275692677ee6d2d66a7cbde16a/clippy_lints%2Fsrc%2Fdefault_numeric_fallback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b2896a8fc9f0b275692677ee6d2d66a7cbde16a/clippy_lints%2Fsrc%2Fdefault_numeric_fallback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdefault_numeric_fallback.rs?ref=7b2896a8fc9f0b275692677ee6d2d66a7cbde16a", "patch": "@@ -123,7 +123,7 @@ impl<'a, 'tcx> Visitor<'tcx> for NumericFallbackVisitor<'a, 'tcx> {\n                 if let Some(fn_sig) = fn_sig_opt(self.cx, func.hir_id) {\n                     for (expr, bound) in iter::zip(*args, fn_sig.skip_binder().inputs()) {\n                         // Push found arg type, then visit arg.\n-                        self.ty_bounds.push(TyBound::Ty(bound));\n+                        self.ty_bounds.push(TyBound::Ty(*bound));\n                         self.visit_expr(expr);\n                         self.ty_bounds.pop();\n                     }\n@@ -135,7 +135,7 @@ impl<'a, 'tcx> Visitor<'tcx> for NumericFallbackVisitor<'a, 'tcx> {\n                 if let Some(def_id) = self.cx.typeck_results().type_dependent_def_id(expr.hir_id) {\n                     let fn_sig = self.cx.tcx.fn_sig(def_id).skip_binder();\n                     for (expr, bound) in iter::zip(*args, fn_sig.inputs()) {\n-                        self.ty_bounds.push(TyBound::Ty(bound));\n+                        self.ty_bounds.push(TyBound::Ty(*bound));\n                         self.visit_expr(expr);\n                         self.ty_bounds.pop();\n                     }\n@@ -210,7 +210,7 @@ impl<'a, 'tcx> Visitor<'tcx> for NumericFallbackVisitor<'a, 'tcx> {\n \n fn fn_sig_opt<'tcx>(cx: &LateContext<'tcx>, hir_id: HirId) -> Option<PolyFnSig<'tcx>> {\n     let node_ty = cx.typeck_results().node_type_opt(hir_id)?;\n-    // We can't use `TyS::fn_sig` because it automatically performs substs, this may result in FNs.\n+    // We can't use `Ty::fn_sig` because it automatically performs substs, this may result in FNs.\n     match node_ty.kind() {\n         ty::FnDef(def_id, _) => Some(cx.tcx.fn_sig(*def_id)),\n         ty::FnPtr(fn_sig) => Some(*fn_sig),"}, {"sha": "6490231fed8a7195ee6c1b9cd62ed1554d43cac0", "filename": "clippy_lints/src/eq_op.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7b2896a8fc9f0b275692677ee6d2d66a7cbde16a/clippy_lints%2Fsrc%2Feq_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b2896a8fc9f0b275692677ee6d2d66a7cbde16a/clippy_lints%2Fsrc%2Feq_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feq_op.rs?ref=7b2896a8fc9f0b275692677ee6d2d66a7cbde16a", "patch": "@@ -6,11 +6,9 @@ use clippy_utils::ty::{implements_trait, is_copy};\n use clippy_utils::{ast_utils::is_useless_with_eq_exprs, eq_expr_value, is_in_test_function};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n-use rustc_hir::{\n-    def::Res, def_id::DefId, BinOpKind, BorrowKind, Expr, ExprKind, GenericArg, ItemKind, QPath, Ty, TyKind,\n-};\n+use rustc_hir::{def::Res, def_id::DefId, BinOpKind, BorrowKind, Expr, ExprKind, GenericArg, ItemKind, QPath, TyKind};\n use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::ty::{self, TyS};\n+use rustc_middle::ty::{self, Ty};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n \n declare_clippy_lint! {\n@@ -279,7 +277,11 @@ impl<'tcx> LateLintPass<'tcx> for EqOp {\n     }\n }\n \n-fn in_impl<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>, bin_op: DefId) -> Option<(&'tcx Ty<'tcx>, &'tcx Ty<'tcx>)> {\n+fn in_impl<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    e: &'tcx Expr<'_>,\n+    bin_op: DefId,\n+) -> Option<(&'tcx rustc_hir::Ty<'tcx>, &'tcx rustc_hir::Ty<'tcx>)> {\n     if_chain! {\n         if let Some(block) = get_enclosing_block(cx, e.hir_id);\n         if let Some(impl_def_id) = cx.tcx.impl_of_method(block.hir_id.owner.to_def_id());\n@@ -301,7 +303,7 @@ fn in_impl<'tcx>(cx: &LateContext<'tcx>, e: &'tcx Expr<'_>, bin_op: DefId) -> Op\n     }\n }\n \n-fn are_equal<'tcx>(cx: &LateContext<'tcx>, middle_ty: &TyS<'_>, hir_ty: &Ty<'_>) -> bool {\n+fn are_equal<'tcx>(cx: &LateContext<'tcx>, middle_ty: Ty<'_>, hir_ty: &rustc_hir::Ty<'_>) -> bool {\n     if_chain! {\n         if let ty::Adt(adt_def, _) = middle_ty.kind();\n         if let Some(local_did) = adt_def.did.as_local();"}, {"sha": "1e6feaac26c3ab77e604572bd461efcc27803ca3", "filename": "clippy_lints/src/format_args.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7b2896a8fc9f0b275692677ee6d2d66a7cbde16a/clippy_lints%2Fsrc%2Fformat_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b2896a8fc9f0b275692677ee6d2d66a7cbde16a/clippy_lints%2Fsrc%2Fformat_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fformat_args.rs?ref=7b2896a8fc9f0b275692677ee6d2d66a7cbde16a", "patch": "@@ -191,7 +191,7 @@ where\n             if overloaded_deref.is_some() {\n                 n_needed = n_total;\n             }\n-            ty = target;\n+            ty = *target;\n         } else {\n             return (n_needed, ty);\n         }"}, {"sha": "ea9b68d1a40e3982a01dfa16b56541b940691cd3", "filename": "clippy_lints/src/functions/must_use.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7b2896a8fc9f0b275692677ee6d2d66a7cbde16a/clippy_lints%2Fsrc%2Ffunctions%2Fmust_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b2896a8fc9f0b275692677ee6d2d66a7cbde16a/clippy_lints%2Fsrc%2Ffunctions%2Fmust_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffunctions%2Fmust_use.rs?ref=7b2896a8fc9f0b275692677ee6d2d66a7cbde16a", "patch": "@@ -193,7 +193,7 @@ fn is_mutable_ty<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, span: Span, tys: &m\n                 || KNOWN_WRAPPER_TYS.iter().any(|path| match_def_path(cx, adt.did, path))\n                     && substs.types().any(|ty| is_mutable_ty(cx, ty, span, tys))\n         },\n-        ty::Tuple(substs) => substs.types().any(|ty| is_mutable_ty(cx, ty, span, tys)),\n+        ty::Tuple(substs) => substs.iter().any(|ty| is_mutable_ty(cx, ty, span, tys)),\n         ty::Array(ty, _) | ty::Slice(ty) => is_mutable_ty(cx, ty, span, tys),\n         ty::RawPtr(ty::TypeAndMut { ty, mutbl }) | ty::Ref(_, ty, mutbl) => {\n             mutbl == hir::Mutability::Mut || is_mutable_ty(cx, ty, span, tys)"}, {"sha": "6b62748ffef2e2812195961768e5d416197d6a26", "filename": "clippy_lints/src/index_refutable_slice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7b2896a8fc9f0b275692677ee6d2d66a7cbde16a/clippy_lints%2Fsrc%2Findex_refutable_slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b2896a8fc9f0b275692677ee6d2d66a7cbde16a/clippy_lints%2Fsrc%2Findex_refutable_slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Findex_refutable_slice.rs?ref=7b2896a8fc9f0b275692677ee6d2d66a7cbde16a", "patch": "@@ -118,7 +118,7 @@ fn find_slice_values(cx: &LateContext<'_>, pat: &hir::Pat<'_>) -> FxIndexMap<hir\n                 // The values need to use the `ref` keyword if they can't be copied.\n                 // This will need to be adjusted if the lint want to support multable access in the future\n                 let src_is_ref = bound_ty.is_ref() && binding != hir::BindingAnnotation::Ref;\n-                let needs_ref = !(src_is_ref || is_copy(cx, inner_ty));\n+                let needs_ref = !(src_is_ref || is_copy(cx, *inner_ty));\n \n                 let slice_info = slices\n                     .entry(value_hir_id)"}, {"sha": "27db6388136139e1789e570826078a7ddaeba901", "filename": "clippy_lints/src/large_const_arrays.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7b2896a8fc9f0b275692677ee6d2d66a7cbde16a/clippy_lints%2Fsrc%2Flarge_const_arrays.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b2896a8fc9f0b275692677ee6d2d66a7cbde16a/clippy_lints%2Fsrc%2Flarge_const_arrays.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flarge_const_arrays.rs?ref=7b2896a8fc9f0b275692677ee6d2d66a7cbde16a", "patch": "@@ -53,9 +53,9 @@ impl<'tcx> LateLintPass<'tcx> for LargeConstArrays {\n             if let ItemKind::Const(hir_ty, _) = &item.kind;\n             let ty = hir_ty_to_ty(cx.tcx, hir_ty);\n             if let ty::Array(element_type, cst) = ty.kind();\n-            if let ConstKind::Value(ConstValue::Scalar(element_count)) = cst.val;\n+            if let ConstKind::Value(ConstValue::Scalar(element_count)) = cst.val();\n             if let Ok(element_count) = element_count.to_machine_usize(&cx.tcx);\n-            if let Ok(element_size) = cx.layout_of(element_type).map(|l| l.size.bytes());\n+            if let Ok(element_size) = cx.layout_of(*element_type).map(|l| l.size.bytes());\n             if self.maximum_allowed_size < element_count * element_size;\n \n             then {"}, {"sha": "57b0d709acd4de9dcc4efef8062a037ddac23396", "filename": "clippy_lints/src/large_stack_arrays.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7b2896a8fc9f0b275692677ee6d2d66a7cbde16a/clippy_lints%2Fsrc%2Flarge_stack_arrays.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b2896a8fc9f0b275692677ee6d2d66a7cbde16a/clippy_lints%2Fsrc%2Flarge_stack_arrays.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flarge_stack_arrays.rs?ref=7b2896a8fc9f0b275692677ee6d2d66a7cbde16a", "patch": "@@ -43,9 +43,9 @@ impl<'tcx> LateLintPass<'tcx> for LargeStackArrays {\n         if_chain! {\n             if let ExprKind::Repeat(_, _) = expr.kind;\n             if let ty::Array(element_type, cst) = cx.typeck_results().expr_ty(expr).kind();\n-            if let ConstKind::Value(ConstValue::Scalar(element_count)) = cst.val;\n+            if let ConstKind::Value(ConstValue::Scalar(element_count)) = cst.val();\n             if let Ok(element_count) = element_count.to_machine_usize(&cx.tcx);\n-            if let Ok(element_size) = cx.layout_of(element_type).map(|l| l.size.bytes());\n+            if let Ok(element_size) = cx.layout_of(*element_type).map(|l| l.size.bytes());\n             if self.maximum_allowed_size < element_count * element_size;\n             then {\n                 span_lint_and_help("}, {"sha": "35d10d53112ec6c3591555833dcace76f3c9ed6c", "filename": "clippy_lints/src/len_zero.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7b2896a8fc9f0b275692677ee6d2d66a7cbde16a/clippy_lints%2Fsrc%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b2896a8fc9f0b275692677ee6d2d66a7cbde16a/clippy_lints%2Fsrc%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flen_zero.rs?ref=7b2896a8fc9f0b275692677ee6d2d66a7cbde16a", "patch": "@@ -294,7 +294,7 @@ impl LenOutput<'_> {\n /// Checks if the given signature matches the expectations for `is_empty`\n fn check_is_empty_sig(sig: FnSig<'_>, self_kind: ImplicitSelfKind, len_output: LenOutput<'_>) -> bool {\n     match &**sig.inputs_and_output {\n-        [arg, res] if len_output.matches_is_empty_output(res) => {\n+        [arg, res] if len_output.matches_is_empty_output(*res) => {\n             matches!(\n                 (arg.kind(), self_kind),\n                 (ty::Ref(_, _, Mutability::Not), ImplicitSelfKind::ImmRef)"}, {"sha": "fc50e8addccec8f84e87c03fffedd10a92daa3dd", "filename": "clippy_lints/src/loops/explicit_counter_loop.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7b2896a8fc9f0b275692677ee6d2d66a7cbde16a/clippy_lints%2Fsrc%2Floops%2Fexplicit_counter_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b2896a8fc9f0b275692677ee6d2d66a7cbde16a/clippy_lints%2Fsrc%2Floops%2Fexplicit_counter_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fexplicit_counter_loop.rs?ref=7b2896a8fc9f0b275692677ee6d2d66a7cbde16a", "patch": "@@ -7,7 +7,7 @@ use rustc_errors::Applicability;\n use rustc_hir::intravisit::{walk_block, walk_expr};\n use rustc_hir::{Expr, Pat};\n use rustc_lint::LateContext;\n-use rustc_middle::ty::{self, UintTy};\n+use rustc_middle::ty::{self, Ty, UintTy};\n \n // To trigger the EXPLICIT_COUNTER_LOOP lint, a variable must be\n // incremented exactly once in the loop body, and initialized to zero\n@@ -36,7 +36,7 @@ pub(super) fn check<'tcx>(\n                 then {\n                     let mut applicability = Applicability::MachineApplicable;\n \n-                    let int_name = match ty.map(ty::TyS::kind) {\n+                    let int_name = match ty.map(Ty::kind) {\n                         // usize or inferred\n                         Some(ty::Uint(UintTy::Usize)) | None => {\n                             span_lint_and_sugg("}, {"sha": "f6ef87264c0a6f3b8f2a70cf3f3e3a44164c3f85", "filename": "clippy_lints/src/loops/manual_memcpy.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7b2896a8fc9f0b275692677ee6d2d66a7cbde16a/clippy_lints%2Fsrc%2Floops%2Fmanual_memcpy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b2896a8fc9f0b275692677ee6d2d66a7cbde16a/clippy_lints%2Fsrc%2Floops%2Fmanual_memcpy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fmanual_memcpy.rs?ref=7b2896a8fc9f0b275692677ee6d2d66a7cbde16a", "patch": "@@ -335,8 +335,8 @@ struct Start<'hir> {\n fn get_slice_like_element_ty<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> Option<Ty<'tcx>> {\n     match ty.kind() {\n         ty::Adt(adt, subs) if cx.tcx.is_diagnostic_item(sym::Vec, adt.did) => Some(subs.type_at(0)),\n-        ty::Ref(_, subty, _) => get_slice_like_element_ty(cx, subty),\n-        ty::Slice(ty) | ty::Array(ty, _) => Some(ty),\n+        ty::Ref(_, subty, _) => get_slice_like_element_ty(cx, *subty),\n+        ty::Slice(ty) | ty::Array(ty, _) => Some(*ty),\n         _ => None,\n     }\n }"}, {"sha": "06190850bb003ebe1ef2d772e462dd35289e7a12", "filename": "clippy_lints/src/loops/needless_collect.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7b2896a8fc9f0b275692677ee6d2d66a7cbde16a/clippy_lints%2Fsrc%2Floops%2Fneedless_collect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b2896a8fc9f0b275692677ee6d2d66a7cbde16a/clippy_lints%2Fsrc%2Floops%2Fneedless_collect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fneedless_collect.rs?ref=7b2896a8fc9f0b275692677ee6d2d66a7cbde16a", "patch": "@@ -12,7 +12,7 @@ use rustc_hir::{Block, Expr, ExprKind, HirId, HirIdSet, Local, Mutability, Node,\n use rustc_lint::LateContext;\n use rustc_middle::hir::nested_filter;\n use rustc_middle::ty::subst::GenericArgKind;\n-use rustc_middle::ty::{self, TyS};\n+use rustc_middle::ty::{self, Ty};\n use rustc_span::sym;\n use rustc_span::{MultiSpan, Span};\n \n@@ -334,8 +334,8 @@ fn detect_iter_and_into_iters<'tcx: 'a, 'a>(\n     }\n }\n \n-fn get_captured_ids(cx: &LateContext<'_>, ty: &'_ TyS<'_>) -> HirIdSet {\n-    fn get_captured_ids_recursive(cx: &LateContext<'_>, ty: &'_ TyS<'_>, set: &mut HirIdSet) {\n+fn get_captured_ids(cx: &LateContext<'_>, ty: Ty<'_>) -> HirIdSet {\n+    fn get_captured_ids_recursive(cx: &LateContext<'_>, ty: Ty<'_>, set: &mut HirIdSet) {\n         match ty.kind() {\n             ty::Adt(_, generics) => {\n                 for generic in *generics {"}, {"sha": "772d251b620a80f45a96ef89b3972a2f16572727", "filename": "clippy_lints/src/loops/utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7b2896a8fc9f0b275692677ee6d2d66a7cbde16a/clippy_lints%2Fsrc%2Floops%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b2896a8fc9f0b275692677ee6d2d66a7cbde16a/clippy_lints%2Fsrc%2Floops%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Futils.rs?ref=7b2896a8fc9f0b275692677ee6d2d66a7cbde16a", "patch": "@@ -334,7 +334,7 @@ pub(super) fn make_iterator_snippet(cx: &LateContext<'_>, arg: &Expr<'_>, applic\n         // (&mut x).into_iter() ==> x.iter_mut()\n         let arg_ty = cx.typeck_results().expr_ty_adjusted(arg);\n         match &arg_ty.kind() {\n-            ty::Ref(_, inner_ty, mutbl) if has_iter_method(cx, inner_ty).is_some() => {\n+            ty::Ref(_, inner_ty, mutbl) if has_iter_method(cx, *inner_ty).is_some() => {\n                 let method_name = match mutbl {\n                     Mutability::Mut => \"iter_mut\",\n                     Mutability::Not => \"iter\","}, {"sha": "e233300e26ab898e94efcdbd13b5bee37b6dbcf7", "filename": "clippy_lints/src/map_clone.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7b2896a8fc9f0b275692677ee6d2d66a7cbde16a/clippy_lints%2Fsrc%2Fmap_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b2896a8fc9f0b275692677ee6d2d66a7cbde16a/clippy_lints%2Fsrc%2Fmap_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmap_clone.rs?ref=7b2896a8fc9f0b275692677ee6d2d66a7cbde16a", "patch": "@@ -100,7 +100,7 @@ impl<'tcx> LateLintPass<'tcx> for MapClone {\n                                     let obj_ty = cx.typeck_results().expr_ty(obj);\n                                     if let ty::Ref(_, ty, mutability) = obj_ty.kind() {\n                                         if matches!(mutability, Mutability::Not) {\n-                                            let copy = is_copy(cx, ty);\n+                                            let copy = is_copy(cx, *ty);\n                                             self.lint_explicit_closure(cx, e.span, args[0].span, copy);\n                                         }\n                                     } else {"}, {"sha": "777ec9b75bc24705494bf68c10fe2be018f83401", "filename": "clippy_lints/src/matches/redundant_pattern_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7b2896a8fc9f0b275692677ee6d2d66a7cbde16a/clippy_lints%2Fsrc%2Fmatches%2Fredundant_pattern_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b2896a8fc9f0b275692677ee6d2d66a7cbde16a/clippy_lints%2Fsrc%2Fmatches%2Fredundant_pattern_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fredundant_pattern_match.rs?ref=7b2896a8fc9f0b275692677ee6d2d66a7cbde16a", "patch": "@@ -54,8 +54,8 @@ fn type_needs_ordered_drop_inner<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, see\n         // This type doesn't implement drop, so no side effects here.\n         // Check if any component type has any.\n         match ty.kind() {\n-            ty::Tuple(_) => ty.tuple_fields().any(|ty| type_needs_ordered_drop_inner(cx, ty, seen)),\n-            ty::Array(ty, _) => type_needs_ordered_drop_inner(cx, ty, seen),\n+            ty::Tuple(fields) => fields.iter().any(|ty| type_needs_ordered_drop_inner(cx, ty, seen)),\n+            ty::Array(ty, _) => type_needs_ordered_drop_inner(cx, *ty, seen),\n             ty::Adt(adt, subs) => adt\n                 .all_fields()\n                 .map(|f| f.ty(cx.tcx, subs))"}, {"sha": "0c4cb45d147cae84cd16e949c6e783e436a842f8", "filename": "clippy_lints/src/matches/single_match.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7b2896a8fc9f0b275692677ee6d2d66a7cbde16a/clippy_lints%2Fsrc%2Fmatches%2Fsingle_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b2896a8fc9f0b275692677ee6d2d66a7cbde16a/clippy_lints%2Fsrc%2Fmatches%2Fsingle_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fsingle_match.rs?ref=7b2896a8fc9f0b275692677ee6d2d66a7cbde16a", "patch": "@@ -8,7 +8,7 @@ use core::cmp::max;\n use rustc_errors::Applicability;\n use rustc_hir::{Arm, BindingAnnotation, Block, Expr, ExprKind, Pat, PatKind};\n use rustc_lint::LateContext;\n-use rustc_middle::ty::{self, Ty, TyS};\n+use rustc_middle::ty::{self, Ty};\n \n use super::{MATCH_BOOL, SINGLE_MATCH, SINGLE_MATCH_ELSE};\n \n@@ -162,10 +162,10 @@ fn check_opt_like<'a>(\n         return;\n     }\n \n-    let in_candidate_enum = |path_info: &(String, &TyS<'_>)| -> bool {\n+    let in_candidate_enum = |path_info: &(String, Ty<'_>)| -> bool {\n         let (path, ty) = path_info;\n         for &(ty_path, pat_path) in candidates {\n-            if path == pat_path && match_type(cx, ty, ty_path) {\n+            if path == pat_path && match_type(cx, *ty, ty_path) {\n                 return true;\n             }\n         }"}, {"sha": "67a585edc2550615aa610d2c958f0a2591582c14", "filename": "clippy_lints/src/methods/cloned_instead_of_copied.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7b2896a8fc9f0b275692677ee6d2d66a7cbde16a/clippy_lints%2Fsrc%2Fmethods%2Fcloned_instead_of_copied.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b2896a8fc9f0b275692677ee6d2d66a7cbde16a/clippy_lints%2Fsrc%2Fmethods%2Fcloned_instead_of_copied.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fcloned_instead_of_copied.rs?ref=7b2896a8fc9f0b275692677ee6d2d66a7cbde16a", "patch": "@@ -30,7 +30,7 @@ pub fn check(cx: &LateContext<'_>, expr: &Expr<'_>, recv: &Expr<'_>, span: Span,\n     };\n     match inner_ty.kind() {\n         // &T where T: Copy\n-        ty::Ref(_, ty, _) if is_copy(cx, ty) => {},\n+        ty::Ref(_, ty, _) if is_copy(cx, *ty) => {},\n         _ => return,\n     };\n     span_lint_and_sugg("}, {"sha": "c3cb02329a11c7c3b944ae1be9de30170de4c80d", "filename": "clippy_lints/src/methods/expect_fun_call.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7b2896a8fc9f0b275692677ee6d2d66a7cbde16a/clippy_lints%2Fsrc%2Fmethods%2Fexpect_fun_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b2896a8fc9f0b275692677ee6d2d66a7cbde16a/clippy_lints%2Fsrc%2Fmethods%2Fexpect_fun_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fexpect_fun_call.rs?ref=7b2896a8fc9f0b275692677ee6d2d66a7cbde16a", "patch": "@@ -73,7 +73,7 @@ pub(super) fn check<'tcx>(\n                     match cx.qpath_res(p, fun.hir_id) {\n                         hir::def::Res::Def(hir::def::DefKind::Fn | hir::def::DefKind::AssocFn, def_id) => matches!(\n                             cx.tcx.fn_sig(def_id).output().skip_binder().kind(),\n-                            ty::Ref(ty::ReStatic, ..)\n+                            ty::Ref(re, ..) if re.is_static(),\n                         ),\n                         _ => false,\n                     }\n@@ -87,7 +87,7 @@ pub(super) fn check<'tcx>(\n                     .map_or(false, |method_id| {\n                         matches!(\n                             cx.tcx.fn_sig(method_id).output().skip_binder().kind(),\n-                            ty::Ref(ty::ReStatic, ..)\n+                            ty::Ref(re, ..) if re.is_static()\n                         )\n                     })\n             },"}, {"sha": "b93f1399eaeed8e9c13692355049678cf450cb42", "filename": "clippy_lints/src/methods/iter_overeager_cloned.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7b2896a8fc9f0b275692677ee6d2d66a7cbde16a/clippy_lints%2Fsrc%2Fmethods%2Fiter_overeager_cloned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b2896a8fc9f0b275692677ee6d2d66a7cbde16a/clippy_lints%2Fsrc%2Fmethods%2Fiter_overeager_cloned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fiter_overeager_cloned.rs?ref=7b2896a8fc9f0b275692677ee6d2d66a7cbde16a", "patch": "@@ -26,7 +26,7 @@ pub(super) fn check<'tcx>(\n     };\n \n     match inner_ty.kind() {\n-        ty::Ref(_, ty, _) if !is_copy(cx, ty) => {},\n+        ty::Ref(_, ty, _) if !is_copy(cx, *ty) => {},\n         _ => return,\n     };\n "}, {"sha": "68a75667914aa0f8f6ab34c80d408ba3a812741a", "filename": "clippy_lints/src/methods/manual_str_repeat.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7b2896a8fc9f0b275692677ee6d2d66a7cbde16a/clippy_lints%2Fsrc%2Fmethods%2Fmanual_str_repeat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b2896a8fc9f0b275692677ee6d2d66a7cbde16a/clippy_lints%2Fsrc%2Fmethods%2Fmanual_str_repeat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmanual_str_repeat.rs?ref=7b2896a8fc9f0b275692677ee6d2d66a7cbde16a", "patch": "@@ -8,7 +8,7 @@ use rustc_ast::LitKind;\n use rustc_errors::Applicability;\n use rustc_hir::{Expr, ExprKind, LangItem};\n use rustc_lint::LateContext;\n-use rustc_middle::ty::{self, Ty, TyS};\n+use rustc_middle::ty::{self, Ty};\n use rustc_span::symbol::sym;\n use std::borrow::Cow;\n \n@@ -37,8 +37,8 @@ fn parse_repeat_arg(cx: &LateContext<'_>, e: &Expr<'_>) -> Option<RepeatKind> {\n     } else {\n         let ty = cx.typeck_results().expr_ty(e);\n         if is_type_diagnostic_item(cx, ty, sym::String)\n-            || (is_type_lang_item(cx, ty, LangItem::OwnedBox) && get_ty_param(ty).map_or(false, TyS::is_str))\n-            || (match_type(cx, ty, &paths::COW) && get_ty_param(ty).map_or(false, TyS::is_str))\n+            || (is_type_lang_item(cx, ty, LangItem::OwnedBox) && get_ty_param(ty).map_or(false, Ty::is_str))\n+            || (match_type(cx, ty, &paths::COW) && get_ty_param(ty).map_or(false, Ty::is_str))\n         {\n             Some(RepeatKind::String)\n         } else {"}, {"sha": "3021a40fae142a03bfd4d3cdea0a83810f1c8387", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7b2896a8fc9f0b275692677ee6d2d66a7cbde16a/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b2896a8fc9f0b275692677ee6d2d66a7cbde16a/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=7b2896a8fc9f0b275692677ee6d2d66a7cbde16a", "patch": "@@ -2106,7 +2106,7 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n             let method_sig = cx.tcx.fn_sig(impl_item.def_id);\n             let method_sig = cx.tcx.erase_late_bound_regions(method_sig);\n \n-            let first_arg_ty = &method_sig.inputs().iter().next();\n+            let first_arg_ty = method_sig.inputs().iter().next();\n \n             // check conventions w.r.t. conversion method names and predicates\n             if let Some(first_arg_ty) = first_arg_ty;\n@@ -2119,7 +2119,7 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n                         if name == method_config.method_name &&\n                             sig.decl.inputs.len() == method_config.param_count &&\n                             method_config.output_type.matches(&sig.decl.output) &&\n-                            method_config.self_kind.matches(cx, self_ty, first_arg_ty) &&\n+                            method_config.self_kind.matches(cx, self_ty, *first_arg_ty) &&\n                             fn_header_equals(method_config.fn_header, sig.header) &&\n                             method_config.lifetime_param_cond(impl_item)\n                         {\n@@ -2151,7 +2151,7 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n                         cx,\n                         name,\n                         self_ty,\n-                        first_arg_ty,\n+                        *first_arg_ty,\n                         first_arg.pat.span,\n                         implements_trait,\n                         false"}, {"sha": "7916fb8e3b45ca2739f6efc35a6c079bfd864ed7", "filename": "clippy_lints/src/methods/unnecessary_to_owned.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7b2896a8fc9f0b275692677ee6d2d66a7cbde16a/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_to_owned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b2896a8fc9f0b275692677ee6d2d66a7cbde16a/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_to_owned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_to_owned.rs?ref=7b2896a8fc9f0b275692677ee6d2d66a7cbde16a", "patch": "@@ -105,7 +105,7 @@ fn check_addr_of_expr(\n         if is_copy(cx, receiver_ty) || is_cow_into_owned(cx, method_name, method_def_id);\n         if let Some(receiver_snippet) = snippet_opt(cx, receiver.span);\n         then {\n-            let (target_ty, n_target_refs) = peel_mid_ty_refs(target_ty);\n+            let (target_ty, n_target_refs) = peel_mid_ty_refs(*target_ty);\n             let (receiver_ty, n_receiver_refs) = peel_mid_ty_refs(receiver_ty);\n             if receiver_ty == target_ty && n_target_refs >= n_receiver_refs {\n                 span_lint_and_sugg(\n@@ -228,7 +228,7 @@ fn check_other_call_arg<'tcx>(\n         let fn_sig = cx.tcx.fn_sig(callee_def_id).skip_binder();\n         if let Some(i) = call_args.iter().position(|arg| arg.hir_id == maybe_arg.hir_id);\n         if let Some(input) = fn_sig.inputs().get(i);\n-        let (input, n_refs) = peel_mid_ty_refs(input);\n+        let (input, n_refs) = peel_mid_ty_refs(*input);\n         if let (trait_predicates, projection_predicates) = get_input_traits_and_projections(cx, callee_def_id, input);\n         if let Some(sized_def_id) = cx.tcx.lang_items().sized_trait();\n         if let [trait_predicate] = trait_predicates"}, {"sha": "63c3273bd6816c1e27e237f5a31854967ad7920e", "filename": "clippy_lints/src/methods/utils.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7b2896a8fc9f0b275692677ee6d2d66a7cbde16a/clippy_lints%2Fsrc%2Fmethods%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b2896a8fc9f0b275692677ee6d2d66a7cbde16a/clippy_lints%2Fsrc%2Fmethods%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Futils.rs?ref=7b2896a8fc9f0b275692677ee6d2d66a7cbde16a", "patch": "@@ -19,7 +19,7 @@ pub(super) fn derefs_to_slice<'tcx>(\n             ty::Adt(def, _) if def.is_box() => may_slice(cx, ty.boxed_ty()),\n             ty::Adt(..) => is_type_diagnostic_item(cx, ty, sym::Vec),\n             ty::Array(_, size) => size.try_eval_usize(cx.tcx, cx.param_env).is_some(),\n-            ty::Ref(_, inner, _) => may_slice(cx, inner),\n+            ty::Ref(_, inner, _) => may_slice(cx, *inner),\n             _ => false,\n         }\n     }\n@@ -35,7 +35,7 @@ pub(super) fn derefs_to_slice<'tcx>(\n             ty::Slice(_) => Some(expr),\n             ty::Adt(def, _) if def.is_box() && may_slice(cx, ty.boxed_ty()) => Some(expr),\n             ty::Ref(_, inner, _) => {\n-                if may_slice(cx, inner) {\n+                if may_slice(cx, *inner) {\n                     Some(expr)\n                 } else {\n                     None"}, {"sha": "aecfea9c141cfad801b75fedc45472f76d0be272", "filename": "clippy_lints/src/methods/wrong_self_convention.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7b2896a8fc9f0b275692677ee6d2d66a7cbde16a/clippy_lints%2Fsrc%2Fmethods%2Fwrong_self_convention.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b2896a8fc9f0b275692677ee6d2d66a7cbde16a/clippy_lints%2Fsrc%2Fmethods%2Fwrong_self_convention.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fwrong_self_convention.rs?ref=7b2896a8fc9f0b275692677ee6d2d66a7cbde16a", "patch": "@@ -2,7 +2,7 @@ use crate::methods::SelfKind;\n use clippy_utils::diagnostics::span_lint_and_help;\n use clippy_utils::ty::is_copy;\n use rustc_lint::LateContext;\n-use rustc_middle::ty::TyS;\n+use rustc_middle::ty::Ty;\n use rustc_span::source_map::Span;\n use std::fmt;\n \n@@ -41,7 +41,7 @@ impl Convention {\n     fn check<'tcx>(\n         &self,\n         cx: &LateContext<'tcx>,\n-        self_ty: &'tcx TyS<'tcx>,\n+        self_ty: Ty<'tcx>,\n         other: &str,\n         implements_trait: bool,\n         is_trait_item: bool,\n@@ -84,8 +84,8 @@ impl fmt::Display for Convention {\n pub(super) fn check<'tcx>(\n     cx: &LateContext<'tcx>,\n     item_name: &str,\n-    self_ty: &'tcx TyS<'tcx>,\n-    first_arg_ty: &'tcx TyS<'tcx>,\n+    self_ty: Ty<'tcx>,\n+    first_arg_ty: Ty<'tcx>,\n     first_arg_span: Span,\n     implements_trait: bool,\n     is_trait_item: bool,"}, {"sha": "e9f268da691565c926ce31e9ab98ce5486a5ed08", "filename": "clippy_lints/src/methods/zst_offset.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7b2896a8fc9f0b275692677ee6d2d66a7cbde16a/clippy_lints%2Fsrc%2Fmethods%2Fzst_offset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b2896a8fc9f0b275692677ee6d2d66a7cbde16a/clippy_lints%2Fsrc%2Fmethods%2Fzst_offset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fzst_offset.rs?ref=7b2896a8fc9f0b275692677ee6d2d66a7cbde16a", "patch": "@@ -9,7 +9,7 @@ use super::ZST_OFFSET;\n pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, recv: &hir::Expr<'_>) {\n     if_chain! {\n         if let ty::RawPtr(ty::TypeAndMut { ty, .. }) = cx.typeck_results().expr_ty(recv).kind();\n-        if let Ok(layout) = cx.tcx.layout_of(cx.param_env.and(ty));\n+        if let Ok(layout) = cx.tcx.layout_of(cx.param_env.and(*ty));\n         if layout.is_zst();\n         then {\n             span_lint(cx, ZST_OFFSET, expr.span, \"offset calculation on zero-sized value\");"}, {"sha": "195b2e5c2ee0a0ff722e1f39bbccadc1ed649b17", "filename": "clippy_lints/src/modulo_arithmetic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7b2896a8fc9f0b275692677ee6d2d66a7cbde16a/clippy_lints%2Fsrc%2Fmodulo_arithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b2896a8fc9f0b275692677ee6d2d66a7cbde16a/clippy_lints%2Fsrc%2Fmodulo_arithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmodulo_arithmetic.rs?ref=7b2896a8fc9f0b275692677ee6d2d66a7cbde16a", "patch": "@@ -4,7 +4,7 @@ use clippy_utils::sext;\n use if_chain::if_chain;\n use rustc_hir::{BinOpKind, Expr, ExprKind};\n use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::ty;\n+use rustc_middle::ty::{self, Ty};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use std::fmt::Display;\n \n@@ -77,7 +77,7 @@ fn floating_point_operand_info<T: Display + PartialOrd + From<f32>>(f: &T) -> Op\n     }\n }\n \n-fn might_have_negative_value(t: &ty::TyS<'_>) -> bool {\n+fn might_have_negative_value(t: Ty<'_>) -> bool {\n     t.is_signed() || t.is_floating_point()\n }\n "}, {"sha": "ce9ca15430e421cd16455c52b80508ebda522b59", "filename": "clippy_lints/src/mut_key.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7b2896a8fc9f0b275692677ee6d2d66a7cbde16a/clippy_lints%2Fsrc%2Fmut_key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b2896a8fc9f0b275692677ee6d2d66a7cbde16a/clippy_lints%2Fsrc%2Fmut_key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmut_key.rs?ref=7b2896a8fc9f0b275692677ee6d2d66a7cbde16a", "patch": "@@ -113,7 +113,7 @@ fn check_sig<'tcx>(cx: &LateContext<'tcx>, item_hir_id: hir::HirId, decl: &hir::\n     let fn_def_id = cx.tcx.hir().local_def_id(item_hir_id);\n     let fn_sig = cx.tcx.fn_sig(fn_def_id);\n     for (hir_ty, ty) in iter::zip(decl.inputs, fn_sig.inputs().skip_binder()) {\n-        check_ty(cx, hir_ty.span, ty);\n+        check_ty(cx, hir_ty.span, *ty);\n     }\n     check_ty(cx, decl.output.span(), cx.tcx.erase_late_bound_regions(fn_sig.output()));\n }\n@@ -142,7 +142,7 @@ fn is_interior_mutable_type<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, span: Sp\n             size.try_eval_usize(cx.tcx, cx.param_env).map_or(true, |u| u != 0)\n                 && is_interior_mutable_type(cx, inner_ty, span)\n         },\n-        Tuple(..) => ty.tuple_fields().any(|ty| is_interior_mutable_type(cx, ty, span)),\n+        Tuple(fields) => fields.iter().any(|ty| is_interior_mutable_type(cx, ty, span)),\n         Adt(def, substs) => {\n             // Special case for collections in `std` who's impl of `Hash` or `Ord` delegates to\n             // that of their type parameters.  Note: we don't include `HashSet` and `HashMap`"}, {"sha": "b7f981faa2d42c6491d8745fc9b76168bd4a2fe6", "filename": "clippy_lints/src/mut_mutex_lock.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7b2896a8fc9f0b275692677ee6d2d66a7cbde16a/clippy_lints%2Fsrc%2Fmut_mutex_lock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b2896a8fc9f0b275692677ee6d2d66a7cbde16a/clippy_lints%2Fsrc%2Fmut_mutex_lock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmut_mutex_lock.rs?ref=7b2896a8fc9f0b275692677ee6d2d66a7cbde16a", "patch": "@@ -53,7 +53,7 @@ impl<'tcx> LateLintPass<'tcx> for MutMutexLock {\n             if path.ident.name == sym!(lock);\n             let ty = cx.typeck_results().expr_ty(self_arg);\n             if let ty::Ref(_, inner_ty, Mutability::Mut) = ty.kind();\n-            if is_type_diagnostic_item(cx, inner_ty, sym::Mutex);\n+            if is_type_diagnostic_item(cx, *inner_ty, sym::Mutex);\n             then {\n                 span_lint_and_sugg(\n                     cx,"}, {"sha": "3ba99403f06d005645138f6511fd9e1c3d5418e9", "filename": "clippy_lints/src/non_copy_const.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7b2896a8fc9f0b275692677ee6d2d66a7cbde16a/clippy_lints%2Fsrc%2Fnon_copy_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b2896a8fc9f0b275692677ee6d2d66a7cbde16a/clippy_lints%2Fsrc%2Fnon_copy_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnon_copy_const.rs?ref=7b2896a8fc9f0b275692677ee6d2d66a7cbde16a", "patch": "@@ -136,14 +136,14 @@ fn is_value_unfrozen_raw<'tcx>(\n     result: Result<ConstValue<'tcx>, ErrorHandled>,\n     ty: Ty<'tcx>,\n ) -> bool {\n-    fn inner<'tcx>(cx: &LateContext<'tcx>, val: &'tcx Const<'tcx>) -> bool {\n-        match val.ty.kind() {\n+    fn inner<'tcx>(cx: &LateContext<'tcx>, val: Const<'tcx>) -> bool {\n+        match val.ty().kind() {\n             // the fact that we have to dig into every structs to search enums\n             // leads us to the point checking `UnsafeCell` directly is the only option.\n             ty::Adt(ty_def, ..) if Some(ty_def.did) == cx.tcx.lang_items().unsafe_cell_type() => true,\n             ty::Array(..) | ty::Adt(..) | ty::Tuple(..) => {\n                 let val = cx.tcx.destructure_const(cx.param_env.and(val));\n-                val.fields.iter().any(|field| inner(cx, field))\n+                val.fields.iter().any(|field| inner(cx, *field))\n             },\n             _ => false,\n         }"}, {"sha": "5168ca67b6abb86c135264f6bb7b273474e2db20", "filename": "clippy_lints/src/non_send_fields_in_send_ty.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7b2896a8fc9f0b275692677ee6d2d66a7cbde16a/clippy_lints%2Fsrc%2Fnon_send_fields_in_send_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b2896a8fc9f0b275692677ee6d2d66a7cbde16a/clippy_lints%2Fsrc%2Fnon_send_fields_in_send_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnon_send_fields_in_send_ty.rs?ref=7b2896a8fc9f0b275692677ee6d2d66a7cbde16a", "patch": "@@ -202,10 +202,10 @@ fn ty_allowed_with_raw_pointer_heuristic<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'t\n \n     // The type is known to be `!Send` and `!Copy`\n     match ty.kind() {\n-        ty::Tuple(_) => ty\n-            .tuple_fields()\n+        ty::Tuple(fields) => fields\n+            .iter()\n             .all(|ty| ty_allowed_with_raw_pointer_heuristic(cx, ty, send_trait)),\n-        ty::Array(ty, _) | ty::Slice(ty) => ty_allowed_with_raw_pointer_heuristic(cx, ty, send_trait),\n+        ty::Array(ty, _) | ty::Slice(ty) => ty_allowed_with_raw_pointer_heuristic(cx, *ty, send_trait),\n         ty::Adt(_, substs) => {\n             if contains_pointer_like(cx, ty) {\n                 // descends only if ADT contains any raw pointers"}, {"sha": "d59249d7f13d32343bcb237ae44bb5afd860e0a1", "filename": "clippy_lints/src/pass_by_ref_or_value.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7b2896a8fc9f0b275692677ee6d2d66a7cbde16a/clippy_lints%2Fsrc%2Fpass_by_ref_or_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b2896a8fc9f0b275692677ee6d2d66a7cbde16a/clippy_lints%2Fsrc%2Fpass_by_ref_or_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fpass_by_ref_or_value.rs?ref=7b2896a8fc9f0b275692677ee6d2d66a7cbde16a", "patch": "@@ -167,8 +167,8 @@ impl<'tcx> PassByRefOrValue {\n \n                     if_chain! {\n                         if !output_lts.contains(input_lt);\n-                        if is_copy(cx, ty);\n-                        if let Some(size) = cx.layout_of(ty).ok().map(|l| l.size.bytes());\n+                        if is_copy(cx, *ty);\n+                        if let Some(size) = cx.layout_of(*ty).ok().map(|l| l.size.bytes());\n                         if size <= self.ref_min_size;\n                         if let hir::TyKind::Rptr(_, MutTy { ty: decl_ty, .. }) = input.kind;\n                         then {"}, {"sha": "f3515ea3c2dde19addc39a4519dbbcc8990b5833", "filename": "clippy_lints/src/size_of_in_element_count.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7b2896a8fc9f0b275692677ee6d2d66a7cbde16a/clippy_lints%2Fsrc%2Fsize_of_in_element_count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b2896a8fc9f0b275692677ee6d2d66a7cbde16a/clippy_lints%2Fsrc%2Fsize_of_in_element_count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fsize_of_in_element_count.rs?ref=7b2896a8fc9f0b275692677ee6d2d66a7cbde16a", "patch": "@@ -116,7 +116,7 @@ fn get_pointee_ty_and_count_expr<'tcx>(\n         if let ty::RawPtr(TypeAndMut { ty: pointee_ty, .. }) =\n             cx.typeck_results().expr_ty(ptr_self).kind();\n         then {\n-            return Some((pointee_ty, count));\n+            return Some((*pointee_ty, count));\n         }\n     };\n     None"}, {"sha": "be9d538c36267cf8fd3243dc9283b5724f18f64c", "filename": "clippy_lints/src/trait_bounds.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7b2896a8fc9f0b275692677ee6d2d66a7cbde16a/clippy_lints%2Fsrc%2Ftrait_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b2896a8fc9f0b275692677ee6d2d66a7cbde16a/clippy_lints%2Fsrc%2Ftrait_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftrait_bounds.rs?ref=7b2896a8fc9f0b275692677ee6d2d66a7cbde16a", "patch": "@@ -98,8 +98,9 @@ impl<'tcx> LateLintPass<'tcx> for TraitBounds {\n                 if let WherePredicate::BoundPredicate(ref bound_predicate) = predicate;\n                 if !bound_predicate.span.from_expansion();\n                 if let TyKind::Path(QPath::Resolved(_, Path { segments, .. })) = bound_predicate.bounded_ty.kind;\n-                if let Some(PathSegment { res: Some(Res::SelfTy(Some(def_id), _)), .. }) = segments.first();\n-\n+                if let Some(PathSegment {\n+                    res: Some(Res::SelfTy{ trait_: Some(def_id), alias_to: _ }), ..\n+                }) = segments.first();\n                 if let Some(\n                     Node::Item(\n                         Item {"}, {"sha": "f3653199b3758b2ecf4d68ef22832da4c298e8c6", "filename": "clippy_lints/src/transmute/transmute_ptr_to_ref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7b2896a8fc9f0b275692677ee6d2d66a7cbde16a/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_ptr_to_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b2896a8fc9f0b275692677ee6d2d66a7cbde16a/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_ptr_to_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_ptr_to_ref.rs?ref=7b2896a8fc9f0b275692677ee6d2d66a7cbde16a", "patch": "@@ -38,7 +38,7 @@ pub(super) fn check<'tcx>(\n                     let arg = if from_ptr_ty.ty == *to_ref_ty {\n                         arg\n                     } else {\n-                        arg.as_ty(&format!(\"{} {}\", cast, get_type_snippet(cx, qpath, to_ref_ty)))\n+                        arg.as_ty(&format!(\"{} {}\", cast, get_type_snippet(cx, qpath, *to_ref_ty)))\n                     };\n \n                     diag.span_suggestion("}, {"sha": "7570bc2a7a8f0d8195e2f8d560f29f36a06c97b3", "filename": "clippy_lints/src/transmute/transmute_ref_to_ref.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7b2896a8fc9f0b275692677ee6d2d66a7cbde16a/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_ref_to_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b2896a8fc9f0b275692677ee6d2d66a7cbde16a/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_ref_to_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_ref_to_ref.rs?ref=7b2896a8fc9f0b275692677ee6d2d66a7cbde16a", "patch": "@@ -56,10 +56,10 @@ pub(super) fn check<'tcx>(\n                         \"transmute from a reference to a reference\",\n                         |diag| if let Some(arg) = sugg::Sugg::hir_opt(cx, arg) {\n                             let ty_from_and_mut = ty::TypeAndMut {\n-                                ty: ty_from,\n+                                ty: *ty_from,\n                                 mutbl: *from_mutbl\n                             };\n-                            let ty_to_and_mut = ty::TypeAndMut { ty: ty_to, mutbl: *to_mutbl };\n+                            let ty_to_and_mut = ty::TypeAndMut { ty: *ty_to, mutbl: *to_mutbl };\n                             let sugg_paren = arg\n                                 .as_ty(cx.tcx.mk_ptr(ty_from_and_mut))\n                                 .as_ty(cx.tcx.mk_ptr(ty_to_and_mut));"}, {"sha": "05eadab3e6ccdcc500f881b62668bbc1a53a2a08", "filename": "clippy_lints/src/transmute/transmute_undefined_repr.rs", "status": "modified", "additions": 33, "deletions": 30, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/7b2896a8fc9f0b275692677ee6d2d66a7cbde16a/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_undefined_repr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b2896a8fc9f0b275692677ee6d2d66a7cbde16a/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_undefined_repr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_undefined_repr.rs?ref=7b2896a8fc9f0b275692677ee6d2d66a7cbde16a", "patch": "@@ -3,7 +3,7 @@ use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::ty::is_c_void;\n use rustc_hir::Expr;\n use rustc_lint::LateContext;\n-use rustc_middle::ty::subst::{GenericArg, Subst};\n+use rustc_middle::ty::subst::Subst;\n use rustc_middle::ty::{self, Ty, TypeAndMut};\n use rustc_span::Span;\n \n@@ -135,19 +135,21 @@ pub(super) fn check<'tcx>(\n                             from_ty_orig, to_ty_orig\n                         ),\n                         |diag| {\n-                            if let (Some(from_def), Some(to_def)) = (from_ty.ty_adt_def(), to_ty.ty_adt_def())\n-                                && from_def == to_def\n-                            {\n-                                diag.note(&format!(\n-                                    \"two instances of the same generic type (`{}`) may have different layouts\",\n-                                    cx.tcx.item_name(from_def.did)\n-                                ));\n-                            } else {\n-                                if from_ty_orig.peel_refs() != from_ty {\n-                                    diag.note(&format!(\"the contained type `{}` has an undefined layout\", from_ty));\n-                                }\n-                                if to_ty_orig.peel_refs() != to_ty {\n-                                    diag.note(&format!(\"the contained type `{}` has an undefined layout\", to_ty));\n+                            if_chain! {\n+                                if let (Some(from_def), Some(to_def)) = (from_ty.ty_adt_def(), to_ty.ty_adt_def());\n+                                if from_def == to_def;\n+                                then {\n+                                    diag.note(&format!(\n+                                        \"two instances of the same generic type (`{}`) may have different layouts\",\n+                                        cx.tcx.item_name(from_def.did)\n+                                    ));\n+                                } else {\n+                                    if from_ty_orig.peel_refs() != from_ty {\n+                                        diag.note(&format!(\"the contained type `{}` has an undefined layout\", from_ty));\n+                                    }\n+                                    if to_ty_orig.peel_refs() != to_ty {\n+                                        diag.note(&format!(\"the contained type `{}` has an undefined layout\", to_ty));\n+                                    }\n                                 }\n                             }\n                         },\n@@ -223,27 +225,27 @@ fn reduce_refs<'tcx>(\n     loop {\n         return match (from_ty.kind(), to_ty.kind()) {\n             (\n-                ty::Ref(_, from_sub_ty, _) | ty::RawPtr(TypeAndMut { ty: from_sub_ty, .. }),\n-                ty::Ref(_, to_sub_ty, _) | ty::RawPtr(TypeAndMut { ty: to_sub_ty, .. }),\n+                &(ty::Ref(_, from_sub_ty, _) | ty::RawPtr(TypeAndMut { ty: from_sub_ty, .. })),\n+                &(ty::Ref(_, to_sub_ty, _) | ty::RawPtr(TypeAndMut { ty: to_sub_ty, .. })),\n             ) => {\n                 from_ty = from_sub_ty;\n                 to_ty = to_sub_ty;\n                 continue;\n             },\n-            (ty::Ref(_, unsized_ty, _) | ty::RawPtr(TypeAndMut { ty: unsized_ty, .. }), _)\n+            (&(ty::Ref(_, unsized_ty, _) | ty::RawPtr(TypeAndMut { ty: unsized_ty, .. })), _)\n                 if !unsized_ty.is_sized(cx.tcx.at(span), cx.param_env) =>\n             {\n                 ReducedTys::FromFatPtr { unsized_ty, to_ty }\n             },\n-            (_, ty::Ref(_, unsized_ty, _) | ty::RawPtr(TypeAndMut { ty: unsized_ty, .. }))\n+            (_, &(ty::Ref(_, unsized_ty, _) | ty::RawPtr(TypeAndMut { ty: unsized_ty, .. })))\n                 if !unsized_ty.is_sized(cx.tcx.at(span), cx.param_env) =>\n             {\n                 ReducedTys::ToFatPtr { unsized_ty, from_ty }\n             },\n-            (ty::Ref(_, from_ty, _) | ty::RawPtr(TypeAndMut { ty: from_ty, .. }), _) => {\n+            (&(ty::Ref(_, from_ty, _) | ty::RawPtr(TypeAndMut { ty: from_ty, .. })), _) => {\n                 ReducedTys::FromPtr { from_ty, to_ty }\n             },\n-            (_, ty::Ref(_, to_ty, _) | ty::RawPtr(TypeAndMut { ty: to_ty, .. })) => {\n+            (_, &(ty::Ref(_, to_ty, _) | ty::RawPtr(TypeAndMut { ty: to_ty, .. }))) => {\n                 ReducedTys::ToPtr { from_ty, to_ty }\n             },\n             _ => ReducedTys::Other { from_ty, to_ty },\n@@ -280,11 +282,10 @@ fn reduce_ty<'tcx>(cx: &LateContext<'tcx>, mut ty: Ty<'tcx>) -> ReducedTy<'tcx>\n             },\n             ty::Tuple(args) if args.is_empty() => ReducedTy::TypeErasure,\n             ty::Tuple(args) => {\n-                let mut iter = args.iter().map(GenericArg::expect_ty);\n-                let Some(sized_ty) = iter.find(|ty| !is_zero_sized_ty(cx, ty)) else {\n+                let Some(sized_ty) = args.iter().find(|&ty| !is_zero_sized_ty(cx, ty)) else {\n                     return ReducedTy::OrderedFields(ty);\n                 };\n-                if iter.all(|ty| is_zero_sized_ty(cx, ty)) {\n+                if args.iter().all(|ty| is_zero_sized_ty(cx, ty)) {\n                     ty = sized_ty;\n                     continue;\n                 }\n@@ -296,7 +297,7 @@ fn reduce_ty<'tcx>(cx: &LateContext<'tcx>, mut ty: Ty<'tcx>) -> ReducedTy<'tcx>\n                     .fields\n                     .iter()\n                     .map(|f| cx.tcx.type_of(f.did).subst(cx.tcx, substs));\n-                let Some(sized_ty) = iter.find(|ty| !is_zero_sized_ty(cx, ty)) else {\n+                let Some(sized_ty) = iter.find(|&ty| !is_zero_sized_ty(cx, ty)) else {\n                     return ReducedTy::TypeErasure;\n                 };\n                 if iter.all(|ty| is_zero_sized_ty(cx, ty)) {\n@@ -321,11 +322,13 @@ fn reduce_ty<'tcx>(cx: &LateContext<'tcx>, mut ty: Ty<'tcx>) -> ReducedTy<'tcx>\n }\n \n fn is_zero_sized_ty<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n-    if let Ok(ty) = cx.tcx.try_normalize_erasing_regions(cx.param_env, ty)\n-        && let Ok(layout) = cx.tcx.layout_of(cx.param_env.and(ty))\n-    {\n-        layout.layout.size.bytes() == 0\n-    } else {\n-        false\n+    if_chain! {\n+        if let Ok(ty) = cx.tcx.try_normalize_erasing_regions(cx.param_env, ty);\n+        if let Ok(layout) = cx.tcx.layout_of(cx.param_env.and(ty));\n+        then {\n+            layout.layout.size.bytes() == 0\n+        } else {\n+            false\n+        }\n     }\n }"}, {"sha": "3cc3d40a143dc1c96ca8d535e866968187b0eb48", "filename": "clippy_lints/src/transmute/useless_transmute.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7b2896a8fc9f0b275692677ee6d2d66a7cbde16a/clippy_lints%2Fsrc%2Ftransmute%2Fuseless_transmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b2896a8fc9f0b275692677ee6d2d66a7cbde16a/clippy_lints%2Fsrc%2Ftransmute%2Fuseless_transmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute%2Fuseless_transmute.rs?ref=7b2896a8fc9f0b275692677ee6d2d66a7cbde16a", "patch": "@@ -34,7 +34,7 @@ pub(super) fn check<'tcx>(\n                 |diag| {\n                     if let Some(arg) = sugg::Sugg::hir_opt(cx, arg) {\n                         let rty_and_mut = ty::TypeAndMut {\n-                            ty: rty,\n+                            ty: *rty,\n                             mutbl: *rty_mutbl,\n                         };\n "}, {"sha": "7c39a08a336b6565c984e7cfb37c07d35a94e343", "filename": "clippy_lints/src/unit_return_expecting_ord.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7b2896a8fc9f0b275692677ee6d2d66a7cbde16a/clippy_lints%2Fsrc%2Funit_return_expecting_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b2896a8fc9f0b275692677ee6d2d66a7cbde16a/clippy_lints%2Fsrc%2Funit_return_expecting_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funit_return_expecting_ord.rs?ref=7b2896a8fc9f0b275692677ee6d2d66a7cbde16a", "patch": "@@ -84,7 +84,8 @@ fn get_args_to_check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) -> Ve\n         let partial_ord_preds =\n             get_trait_predicates_for_trait_id(cx, generics, cx.tcx.lang_items().partial_ord_trait());\n         // Trying to call erase_late_bound_regions on fn_sig.inputs() gives the following error\n-        // The trait `rustc::ty::TypeFoldable<'_>` is not implemented for `&[&rustc::ty::TyS<'_>]`\n+        // The trait `rustc::ty::TypeFoldable<'_>` is not implemented for\n+        // `&[rustc_middle::ty::Ty<'_>]`\n         let inputs_output = cx.tcx.erase_late_bound_regions(fn_sig.inputs_and_output());\n         inputs_output\n             .iter()"}, {"sha": "80164c59ba74c3e570d82fb46985d25f6e47255a", "filename": "clippy_lints/src/use_self.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7b2896a8fc9f0b275692677ee6d2d66a7cbde16a/clippy_lints%2Fsrc%2Fuse_self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b2896a8fc9f0b275692677ee6d2d66a7cbde16a/clippy_lints%2Fsrc%2Fuse_self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fuse_self.rs?ref=7b2896a8fc9f0b275692677ee6d2d66a7cbde16a", "patch": "@@ -204,7 +204,7 @@ impl<'tcx> LateLintPass<'tcx> for UseSelf {\n                 ref types_to_skip,\n             }) = self.stack.last();\n             if let TyKind::Path(QPath::Resolved(_, path)) = hir_ty.kind;\n-            if !matches!(path.res, Res::SelfTy(..) | Res::Def(DefKind::TyParam, _));\n+            if !matches!(path.res, Res::SelfTy { .. } | Res::Def(DefKind::TyParam, _));\n             if !types_to_skip.contains(&hir_ty.hir_id);\n             let ty = if in_body > 0 {\n                 cx.typeck_results().node_type(hir_ty.hir_id)\n@@ -231,7 +231,7 @@ impl<'tcx> LateLintPass<'tcx> for UseSelf {\n         }\n         match expr.kind {\n             ExprKind::Struct(QPath::Resolved(_, path), ..) => match path.res {\n-                Res::SelfTy(..) => (),\n+                Res::SelfTy { .. } => (),\n                 Res::Def(DefKind::Variant, _) => lint_path_to_variant(cx, path),\n                 _ => span_lint(cx, path.span),\n             },"}, {"sha": "4433d5f5bf1463046f27e0feafc039fcc10dd8ea", "filename": "clippy_lints/src/utils/internal_lints.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7b2896a8fc9f0b275692677ee6d2d66a7cbde16a/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b2896a8fc9f0b275692677ee6d2d66a7cbde16a/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs?ref=7b2896a8fc9f0b275692677ee6d2d66a7cbde16a", "patch": "@@ -1305,7 +1305,7 @@ fn if_chain_local_span(cx: &LateContext<'_>, local: &Local<'_>, if_chain_span: S\n     }\n     span.adjust(if_chain_span.ctxt().outer_expn());\n     let sm = cx.sess().source_map();\n-    let span = sm.span_extend_to_prev_str(span, \"let\", false);\n+    let span = sm.span_extend_to_prev_str(span, \"let\", false, true).unwrap_or(span);\n     let span = sm.span_extend_to_next_char(span, ';', false);\n     Span::new(\n         span.lo() - BytePos(3),"}, {"sha": "1fa6301ebd73dfcc04f1e555fda3b93ab03204ad", "filename": "clippy_lints/src/write.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7b2896a8fc9f0b275692677ee6d2d66a7cbde16a/clippy_lints%2Fsrc%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b2896a8fc9f0b275692677ee6d2d66a7cbde16a/clippy_lints%2Fsrc%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fwrite.rs?ref=7b2896a8fc9f0b275692677ee6d2d66a7cbde16a", "patch": "@@ -453,7 +453,7 @@ impl SimpleFormatArgs {\n                     }\n                 }\n             },\n-            ArgumentNamed(n) => {\n+            ArgumentNamed(n, _) => {\n                 if let Some(x) = self.named.iter_mut().find(|x| x.0 == n) {\n                     match x.1.as_slice() {\n                         // A non-empty format string has been seen already."}, {"sha": "d3ed8da4499f88ee3aec2578e4983ffb1516dc51", "filename": "clippy_utils/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7b2896a8fc9f0b275692677ee6d2d66a7cbde16a/clippy_utils%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7b2896a8fc9f0b275692677ee6d2d66a7cbde16a/clippy_utils%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2FCargo.toml?ref=7b2896a8fc9f0b275692677ee6d2d66a7cbde16a", "patch": "@@ -1,6 +1,6 @@\n [package]\n name = \"clippy_utils\"\n-version = \"0.1.60\"\n+version = \"0.1.61\"\n edition = \"2021\"\n publish = false\n "}, {"sha": "d40583c47dd7074a8c069c0656652fdcf4652509", "filename": "clippy_utils/src/consts.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7b2896a8fc9f0b275692677ee6d2d66a7cbde16a/clippy_utils%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b2896a8fc9f0b275692677ee6d2d66a7cbde16a/clippy_utils%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fconsts.rs?ref=7b2896a8fc9f0b275692677ee6d2d66a7cbde16a", "patch": "@@ -567,11 +567,11 @@ impl<'a, 'tcx> ConstEvalLateContext<'a, 'tcx> {\n     }\n }\n \n-pub fn miri_to_const(result: &ty::Const<'_>) -> Option<Constant> {\n+pub fn miri_to_const(result: ty::Const<'_>) -> Option<Constant> {\n     use rustc_middle::mir::interpret::ConstValue;\n-    match result.val {\n+    match result.val() {\n         ty::ConstKind::Value(ConstValue::Scalar(Scalar::Int(int))) => {\n-            match result.ty.kind() {\n+            match result.ty().kind() {\n                 ty::Bool => Some(Constant::Bool(int == ScalarInt::TRUE)),\n                 ty::Uint(_) | ty::Int(_) => Some(Constant::Int(int.assert_bits(int.size()))),\n                 ty::Float(FloatTy::F32) => Some(Constant::F32(f32::from_bits(\n@@ -590,7 +590,7 @@ pub fn miri_to_const(result: &ty::Const<'_>) -> Option<Constant> {\n                 _ => None,\n             }\n         },\n-        ty::ConstKind::Value(ConstValue::Slice { data, start, end }) => match result.ty.kind() {\n+        ty::ConstKind::Value(ConstValue::Slice { data, start, end }) => match result.ty().kind() {\n             ty::Ref(_, tam, _) => match tam.kind() {\n                 ty::Str => String::from_utf8(\n                     data.inspect_with_uninit_and_ptr_outside_interpreter(start..end)\n@@ -602,9 +602,9 @@ pub fn miri_to_const(result: &ty::Const<'_>) -> Option<Constant> {\n             },\n             _ => None,\n         },\n-        ty::ConstKind::Value(ConstValue::ByRef { alloc, offset: _ }) => match result.ty.kind() {\n+        ty::ConstKind::Value(ConstValue::ByRef { alloc, offset: _ }) => match result.ty().kind() {\n             ty::Array(sub_type, len) => match sub_type.kind() {\n-                ty::Float(FloatTy::F32) => match miri_to_const(len) {\n+                ty::Float(FloatTy::F32) => match miri_to_const(*len) {\n                     Some(Constant::Int(len)) => alloc\n                         .inspect_with_uninit_and_ptr_outside_interpreter(0..(4 * len as usize))\n                         .to_owned()\n@@ -618,7 +618,7 @@ pub fn miri_to_const(result: &ty::Const<'_>) -> Option<Constant> {\n                         .map(Constant::Vec),\n                     _ => None,\n                 },\n-                ty::Float(FloatTy::F64) => match miri_to_const(len) {\n+                ty::Float(FloatTy::F64) => match miri_to_const(*len) {\n                     Some(Constant::Int(len)) => alloc\n                         .inspect_with_uninit_and_ptr_outside_interpreter(0..(8 * len as usize))\n                         .to_owned()"}, {"sha": "397783e309e85b135e5c1d4c25b25e86e1b34219", "filename": "clippy_utils/src/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7b2896a8fc9f0b275692677ee6d2d66a7cbde16a/clippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b2896a8fc9f0b275692677ee6d2d66a7cbde16a/clippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Flib.rs?ref=7b2896a8fc9f0b275692677ee6d2d66a7cbde16a", "patch": "@@ -1461,7 +1461,7 @@ pub fn is_self(slf: &Param<'_>) -> bool {\n \n pub fn is_self_ty(slf: &hir::Ty<'_>) -> bool {\n     if let TyKind::Path(QPath::Resolved(None, path)) = slf.kind {\n-        if let Res::SelfTy(..) = path.res {\n+        if let Res::SelfTy { .. } = path.res {\n             return true;\n         }\n     }\n@@ -1912,10 +1912,10 @@ pub fn is_slice_of_primitives(cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<S\n     let expr_type = cx.typeck_results().expr_ty_adjusted(expr);\n     let expr_kind = expr_type.kind();\n     let is_primitive = match expr_kind {\n-        rustc_ty::Slice(element_type) => is_recursively_primitive_type(element_type),\n+        rustc_ty::Slice(element_type) => is_recursively_primitive_type(*element_type),\n         rustc_ty::Ref(_, inner_ty, _) if matches!(inner_ty.kind(), &rustc_ty::Slice(_)) => {\n             if let rustc_ty::Slice(element_type) = inner_ty.kind() {\n-                is_recursively_primitive_type(element_type)\n+                is_recursively_primitive_type(*element_type)\n             } else {\n                 unreachable!()\n             }"}, {"sha": "c039fec955db9d2641fc86e43ce772da69f04021", "filename": "clippy_utils/src/qualify_min_const_fn.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7b2896a8fc9f0b275692677ee6d2d66a7cbde16a/clippy_utils%2Fsrc%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b2896a8fc9f0b275692677ee6d2d66a7cbde16a/clippy_utils%2Fsrc%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fqualify_min_const_fn.rs?ref=7b2896a8fc9f0b275692677ee6d2d66a7cbde16a", "patch": "@@ -32,7 +32,6 @@ pub fn is_min_const_fn<'a, 'tcx>(tcx: TyCtxt<'tcx>, body: &'a Body<'tcx>, msrv:\n                 | ty::PredicateKind::Projection(_)\n                 | ty::PredicateKind::ConstEvaluatable(..)\n                 | ty::PredicateKind::ConstEquate(..)\n-                | ty::PredicateKind::OpaqueType(..)\n                 | ty::PredicateKind::TypeWellFormedFromEnv(..) => continue,\n                 ty::PredicateKind::ObjectSafe(_) => panic!(\"object safe predicate on function: {:#?}\", predicate),\n                 ty::PredicateKind::ClosureKind(..) => panic!(\"closure kind predicate on function: {:#?}\", predicate),\n@@ -150,7 +149,7 @@ fn check_rvalue<'tcx>(\n         Rvalue::Cast(CastKind::Misc, operand, cast_ty) => {\n             use rustc_middle::ty::cast::CastTy;\n             let cast_in = CastTy::from_ty(operand.ty(body, tcx)).expect(\"bad input type for cast\");\n-            let cast_out = CastTy::from_ty(cast_ty).expect(\"bad output type for cast\");\n+            let cast_out = CastTy::from_ty(*cast_ty).expect(\"bad output type for cast\");\n             match (cast_in, cast_out) {\n                 (CastTy::Ptr(_) | CastTy::FnPtr, CastTy::Int(_)) => {\n                     Err((span, \"casting pointers to ints is unstable in const fn\".into()))"}, {"sha": "0646d1524a767310ee26d879649a16a441d8ee5e", "filename": "clippy_utils/src/ty.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/7b2896a8fc9f0b275692677ee6d2d66a7cbde16a/clippy_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b2896a8fc9f0b275692677ee6d2d66a7cbde16a/clippy_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fty.rs?ref=7b2896a8fc9f0b275692677ee6d2d66a7cbde16a", "patch": "@@ -105,7 +105,7 @@ pub fn has_iter_method(cx: &LateContext<'_>, probably_ref_ty: Ty<'_>) -> Option<\n     ];\n \n     let ty_to_check = match probably_ref_ty.kind() {\n-        ty::Ref(_, ty_to_check, _) => ty_to_check,\n+        ty::Ref(_, ty_to_check, _) => *ty_to_check,\n         _ => probably_ref_ty,\n     };\n \n@@ -171,7 +171,7 @@ pub fn is_must_use_ty<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n             // because we don't want to lint functions returning empty arrays\n             is_must_use_ty(cx, *ty)\n         },\n-        ty::Tuple(substs) => substs.types().any(|ty| is_must_use_ty(cx, ty)),\n+        ty::Tuple(substs) => substs.iter().any(|ty| is_must_use_ty(cx, ty)),\n         ty::Opaque(ref def_id, _) => {\n             for (predicate, _) in cx.tcx.explicit_item_bounds(*def_id) {\n                 if let ty::PredicateKind::Trait(trait_predicate) = predicate.kind().skip_binder() {\n@@ -211,7 +211,7 @@ fn is_normalizable_helper<'tcx>(\n     ty: Ty<'tcx>,\n     cache: &mut FxHashMap<Ty<'tcx>, bool>,\n ) -> bool {\n-    if let Some(&cached_result) = cache.get(ty) {\n+    if let Some(&cached_result) = cache.get(&ty) {\n         return cached_result;\n     }\n     // prevent recursive loops, false-negative is better than endless loop leading to stack overflow\n@@ -251,11 +251,11 @@ pub fn is_non_aggregate_primitive_type(ty: Ty<'_>) -> bool {\n /// Returns `true` if the given type is a primitive (a `bool` or `char`, any integer or\n /// floating-point number type, a `str`, or an array, slice, or tuple of those types).\n pub fn is_recursively_primitive_type(ty: Ty<'_>) -> bool {\n-    match ty.kind() {\n+    match *ty.kind() {\n         ty::Bool | ty::Char | ty::Int(_) | ty::Uint(_) | ty::Float(_) | ty::Str => true,\n         ty::Ref(_, inner, _) if *inner.kind() == ty::Str => true,\n         ty::Array(inner_type, _) | ty::Slice(inner_type) => is_recursively_primitive_type(inner_type),\n-        ty::Tuple(inner_types) => inner_types.types().all(is_recursively_primitive_type),\n+        ty::Tuple(inner_types) => inner_types.iter().all(is_recursively_primitive_type),\n         _ => false,\n     }\n }\n@@ -320,7 +320,7 @@ pub fn match_type(cx: &LateContext<'_>, ty: Ty<'_>, path: &[&str]) -> bool {\n pub fn peel_mid_ty_refs(ty: Ty<'_>) -> (Ty<'_>, usize) {\n     fn peel(ty: Ty<'_>, count: usize) -> (Ty<'_>, usize) {\n         if let ty::Ref(_, ty, _) = ty.kind() {\n-            peel(ty, count + 1)\n+            peel(*ty, count + 1)\n         } else {\n             (ty, count)\n         }\n@@ -333,8 +333,8 @@ pub fn peel_mid_ty_refs(ty: Ty<'_>) -> (Ty<'_>, usize) {\n pub fn peel_mid_ty_refs_is_mutable(ty: Ty<'_>) -> (Ty<'_>, usize, Mutability) {\n     fn f(ty: Ty<'_>, count: usize, mutability: Mutability) -> (Ty<'_>, usize, Mutability) {\n         match ty.kind() {\n-            ty::Ref(_, ty, Mutability::Mut) => f(ty, count + 1, mutability),\n-            ty::Ref(_, ty, Mutability::Not) => f(ty, count + 1, Mutability::Not),\n+            ty::Ref(_, ty, Mutability::Mut) => f(*ty, count + 1, mutability),\n+            ty::Ref(_, ty, Mutability::Not) => f(*ty, count + 1, Mutability::Not),\n             _ => (ty, count, mutability),\n         }\n     }\n@@ -362,7 +362,7 @@ pub fn walk_ptrs_hir_ty<'tcx>(ty: &'tcx hir::Ty<'tcx>) -> &'tcx hir::Ty<'tcx> {\n pub fn walk_ptrs_ty_depth(ty: Ty<'_>) -> (Ty<'_>, usize) {\n     fn inner(ty: Ty<'_>, depth: usize) -> (Ty<'_>, usize) {\n         match ty.kind() {\n-            ty::Ref(_, ty, _) => inner(ty, depth + 1),\n+            ty::Ref(_, ty, _) => inner(*ty, depth + 1),\n             _ => (ty, depth),\n         }\n     }\n@@ -395,9 +395,9 @@ pub fn same_type_and_consts<'tcx>(a: Ty<'tcx>, b: Ty<'tcx>) -> bool {\n \n /// Checks if a given type looks safe to be uninitialized.\n pub fn is_uninit_value_valid_for_ty(cx: &LateContext<'_>, ty: Ty<'_>) -> bool {\n-    match ty.kind() {\n+    match *ty.kind() {\n         ty::Array(component, _) => is_uninit_value_valid_for_ty(cx, component),\n-        ty::Tuple(types) => types.types().all(|ty| is_uninit_value_valid_for_ty(cx, ty)),\n+        ty::Tuple(types) => types.iter().all(|ty| is_uninit_value_valid_for_ty(cx, ty)),\n         ty::Adt(adt, _) => cx.tcx.lang_items().maybe_uninit() == Some(adt.did),\n         _ => false,\n     }\n@@ -428,8 +428,8 @@ impl<'tcx> ExprFnSig<'tcx> {\n     pub fn input(self, i: usize) -> Binder<'tcx, Ty<'tcx>> {\n         match self {\n             Self::Sig(sig) => sig.input(i),\n-            Self::Closure(sig) => sig.input(0).map_bound(|ty| ty.tuple_element_ty(i).unwrap()),\n-            Self::Trait(inputs, _) => inputs.map_bound(|ty| ty.tuple_element_ty(i).unwrap()),\n+            Self::Closure(sig) => sig.input(0).map_bound(|ty| ty.tuple_fields()[i]),\n+            Self::Trait(inputs, _) => inputs.map_bound(|ty| ty.tuple_fields()[i]),\n         }\n     }\n "}, {"sha": "828bf4cbef9481526edc8840762be8421397dbe7", "filename": "doc/common_tools_writing_lints.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7b2896a8fc9f0b275692677ee6d2d66a7cbde16a/doc%2Fcommon_tools_writing_lints.md", "raw_url": "https://github.com/rust-lang/rust/raw/7b2896a8fc9f0b275692677ee6d2d66a7cbde16a/doc%2Fcommon_tools_writing_lints.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fcommon_tools_writing_lints.md?ref=7b2896a8fc9f0b275692677ee6d2d66a7cbde16a", "patch": "@@ -26,7 +26,7 @@ Sometimes you may want to retrieve the type `Ty` of an expression `Expr`, for ex\n - does it implement a trait?\n \n This operation is performed using the [`expr_ty()`][expr_ty] method from the [`TypeckResults`][TypeckResults] struct,\n-that gives you access to the underlying structure [`TyS`][TyS].\n+that gives you access to the underlying structure [`Ty`][Ty].\n \n Example of use:\n ```rust\n@@ -259,7 +259,7 @@ expression with a different context from `a`.\n    assert_eq!(x_is_some_span.ctxt(), x_unwrap_span.ctxt());\n    ```\n \n-[TyS]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/struct.TyS.html\n+[Ty]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/struct.Ty.html\n [TyKind]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/enum.TyKind.html\n [TypeckResults]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/struct.TypeckResults.html\n [expr_ty]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/struct.TypeckResults.html#method.expr_ty"}, {"sha": "4d2c57619912f024722c427fb5ca9c4fa000be01", "filename": "rust-toolchain", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7b2896a8fc9f0b275692677ee6d2d66a7cbde16a/rust-toolchain", "raw_url": "https://github.com/rust-lang/rust/raw/7b2896a8fc9f0b275692677ee6d2d66a7cbde16a/rust-toolchain", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rust-toolchain?ref=7b2896a8fc9f0b275692677ee6d2d66a7cbde16a", "patch": "@@ -1,3 +1,3 @@\n [toolchain]\n-channel = \"nightly-2022-02-10\"\n+channel = \"nightly-2022-02-24\"\n components = [\"cargo\", \"llvm-tools-preview\", \"rust-src\", \"rust-std\", \"rustc\", \"rustc-dev\", \"rustfmt\"]"}]}