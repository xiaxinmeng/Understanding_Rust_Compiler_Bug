{"sha": "b1d4d2bfeaf45c9f3132b863867888ec89d1d40e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIxZDRkMmJmZWFmNDVjOWYzMTMyYjg2Mzg2Nzg4OGVjODlkMWQ0MGU=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-08-27T19:15:55Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-09-15T12:25:29Z"}, "message": "relocations -> allocations", "tree": {"sha": "5a7c5755bf8f4dfb69806979b75915c98b74ff3d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5a7c5755bf8f4dfb69806979b75915c98b74ff3d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b1d4d2bfeaf45c9f3132b863867888ec89d1d40e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b1d4d2bfeaf45c9f3132b863867888ec89d1d40e", "html_url": "https://github.com/rust-lang/rust/commit/b1d4d2bfeaf45c9f3132b863867888ec89d1d40e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b1d4d2bfeaf45c9f3132b863867888ec89d1d40e/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "75c82b4dd8152562ff2056f2172b20aa9c46def2", "url": "https://api.github.com/repos/rust-lang/rust/commits/75c82b4dd8152562ff2056f2172b20aa9c46def2", "html_url": "https://github.com/rust-lang/rust/commit/75c82b4dd8152562ff2056f2172b20aa9c46def2"}], "stats": {"total": 31, "additions": 18, "deletions": 13}, "files": [{"sha": "85bc88c86c277e0a9880698c6d7f85006a1f3d97", "filename": "src/librustc_mir/interpret/intern.rs", "status": "modified", "additions": 18, "deletions": 13, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/b1d4d2bfeaf45c9f3132b863867888ec89d1d40e/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1d4d2bfeaf45c9f3132b863867888ec89d1d40e/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintern.rs?ref=b1d4d2bfeaf45c9f3132b863867888ec89d1d40e", "patch": "@@ -22,6 +22,9 @@ struct InternVisitor<'rt, 'mir, 'tcx> {\n     ecx: &'rt mut CompileTimeEvalContext<'mir, 'tcx>,\n     /// Previously encountered safe references.\n     ref_tracking: &'rt mut RefTracking<(MPlaceTy<'tcx>, Mutability, InternMode)>,\n+    /// A list of all encountered allocations. After type-based interning, we traverse this list to\n+    /// also intern allocations that are only referenced by a raw pointer or inside a union.\n+    leftover_allocations: &'rt mut FxHashSet<AllocId>,\n     /// The root node of the value that we're looking at. This field is never mutated and only used\n     /// for sanity assertions that will ICE when `const_qualif` screws up.\n     mode: InternMode,\n@@ -31,9 +34,6 @@ struct InternVisitor<'rt, 'mir, 'tcx> {\n     /// despite the nested mutable reference!\n     /// The field gets updated when an `UnsafeCell` is encountered.\n     mutability: Mutability,\n-    /// A list of all encountered relocations. After type-based interning, we traverse this list to\n-    /// also intern allocations that are only referenced by a raw pointer or inside a union.\n-    leftover_relocations: &'rt mut FxHashSet<AllocId>,\n }\n \n #[derive(Copy, Clone, Debug, PartialEq, Hash, Eq)]\n@@ -59,7 +59,7 @@ struct IsStaticOrFn;\n /// `immutable` things might become mutable if `ty` is not frozen.\n fn intern_shallow<'rt, 'mir, 'tcx>(\n     ecx: &'rt mut CompileTimeEvalContext<'mir, 'tcx>,\n-    leftover_relocations: &'rt mut FxHashSet<AllocId>,\n+    leftover_allocations: &'rt mut FxHashSet<AllocId>,\n     mode: InternMode,\n     alloc_id: AllocId,\n     mutability: Mutability,\n@@ -120,7 +120,7 @@ fn intern_shallow<'rt, 'mir, 'tcx>(\n     };\n     // link the alloc id to the actual allocation\n     let alloc = tcx.intern_const_alloc(alloc);\n-    leftover_relocations.extend(alloc.relocations().iter().map(|&(_, ((), reloc))| reloc));\n+    leftover_allocations.extend(alloc.relocations().iter().map(|&(_, ((), reloc))| reloc));\n     tcx.alloc_map.lock().set_alloc_id_memory(alloc_id, alloc);\n     Ok(None)\n }\n@@ -134,7 +134,7 @@ impl<'rt, 'mir, 'tcx> InternVisitor<'rt, 'mir, 'tcx> {\n     ) -> InterpResult<'tcx, Option<IsStaticOrFn>> {\n         intern_shallow(\n             self.ecx,\n-            self.leftover_relocations,\n+            self.leftover_allocations,\n             self.mode,\n             alloc_id,\n             mutability,\n@@ -276,14 +276,18 @@ pub fn intern_const_alloc_recursive(\n         Some(hir::Mutability::MutMutable) => (Mutability::Mutable, InternMode::Static),\n     };\n \n-    // type based interning\n+    // Type based interning.\n+    // `ref_tracking` tracks typed references we have seen and still need to crawl for\n+    // more typed information inside them.\n+    // `leftover_allocations` collects *all* allocations we see, because some might not\n+    // be available in a typed way. They get interned at the end.\n     let mut ref_tracking = RefTracking::new((ret, base_mutability, base_intern_mode));\n-    let leftover_relocations = &mut FxHashSet::default();\n+    let leftover_allocations = &mut FxHashSet::default();\n \n     // start with the outermost allocation\n     intern_shallow(\n         ecx,\n-        leftover_relocations,\n+        leftover_allocations,\n         base_intern_mode,\n         ret.ptr.to_ptr()?.alloc_id,\n         base_mutability,\n@@ -295,7 +299,7 @@ pub fn intern_const_alloc_recursive(\n             ref_tracking: &mut ref_tracking,\n             ecx,\n             mode,\n-            leftover_relocations,\n+            leftover_allocations,\n             mutability,\n         }.visit_value(mplace);\n         if let Err(error) = interned {\n@@ -318,11 +322,12 @@ pub fn intern_const_alloc_recursive(\n     // Intern the rest of the allocations as mutable. These might be inside unions, padding, raw\n     // pointers, ... So we can't intern them according to their type rules\n \n-    let mut todo: Vec<_> = leftover_relocations.iter().cloned().collect();\n+    let mut todo: Vec<_> = leftover_allocations.iter().cloned().collect();\n     while let Some(alloc_id) = todo.pop() {\n         if let Some((_, mut alloc)) = ecx.memory_mut().alloc_map.remove(&alloc_id) {\n             // We can't call the `intern_shallow` method here, as its logic is tailored to safe\n-            // references. So we hand-roll the interning logic here again.\n+            // references and a `leftover_allocations` set (where we only have a todo-list here).\n+            // So we hand-roll the interning logic here again.\n             if base_intern_mode != InternMode::Static {\n                 // If it's not a static, it *must* be immutable.\n                 // We cannot have mutable memory inside a constant.\n@@ -331,7 +336,7 @@ pub fn intern_const_alloc_recursive(\n             let alloc = tcx.intern_const_alloc(alloc);\n             tcx.alloc_map.lock().set_alloc_id_memory(alloc_id, alloc);\n             for &(_, ((), reloc)) in alloc.relocations().iter() {\n-                if leftover_relocations.insert(reloc) {\n+                if leftover_allocations.insert(reloc) {\n                     todo.push(reloc);\n                 }\n             }"}]}