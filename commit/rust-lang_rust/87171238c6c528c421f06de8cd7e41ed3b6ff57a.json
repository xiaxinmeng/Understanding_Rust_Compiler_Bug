{"sha": "87171238c6c528c421f06de8cd7e41ed3b6ff57a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg3MTcxMjM4YzZjNTI4YzQyMWYwNmRlOGNkN2U0MWVkM2I2ZmY1N2E=", "commit": {"author": {"name": "oxalica", "email": "oxalicc@pm.me", "date": "2021-03-15T16:05:03Z"}, "committer": {"name": "oxalica", "email": "oxalicc@pm.me", "date": "2021-03-15T17:04:33Z"}, "message": "Use hir formatter more", "tree": {"sha": "b7abccc6adf5df6baae0d97146b9e9b6c5ef7c32", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b7abccc6adf5df6baae0d97146b9e9b6c5ef7c32"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/87171238c6c528c421f06de8cd7e41ed3b6ff57a", "comment_count": 0, "verification": {"verified": false, "reason": "unknown_key", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEXLDp5dXVcfV/VA/qztOS3gxIPQAFAmBPk6EACgkQztOS3gxI\nPQBP8BAAle3S0Zdnl2YTegmhiaDbalyJgbgUbfPkK/j5055cwINKef0P7TjJceht\ng804z7qHIZyGLipjRw5M91btK+Pg/sr7TCPbTQVfIRv8ZK8l29IuKS9V79j6243w\n2UVJOPi/vkdvkpEY9cRGmd9vi0UMMRVT5lp/snj29Un6LTWgLU85pSyyQ3f3Wm9t\npB5W89wSwhE2tsC0i4luGhbBqLew+fTTiEBdW8DDWvM97N46gBSE/61XNwHWoWmV\n+7sfNTLSsO0lWthjr/ZTrSG5/SnA3KeUBJIXG/MQ3tKe4FY7/bayQxXNrKrgDyNh\nArrxzSrqKvs240AfJe9rnEeAXGYzTOnffECMguR0m/Jt0jucgkji96DDrq5lsXiE\nJCD3p1p4WEb+YwJGagaxeJtdWQ/q9jHQrZt4y9CL7yJXd++AKk/gczw8Tlkoy15A\n6J7KuDKK5wWt9YIFr6Xm5S78seNDzEquRmWf3uBf85UXoW/R+1N1jEnzt0eNIDw4\ndvTfZJaYL0t9IPgPoBgNrkERGXQ9TuzCNVIjbCwz02oHM9GO+iaft9ob+/mDn3K/\n+VaVrE5OAG25GyyNB2SEJNPUE8FsouL/StqIPgUNcF+MvKodo+jt7cdzJMOtbRdz\nRci0EpHzntOYs0oXGOYuz4TYAZ26R3r43NpWb7lEVHWtE7Y4Bdw=\n=u3JO\n-----END PGP SIGNATURE-----", "payload": "tree b7abccc6adf5df6baae0d97146b9e9b6c5ef7c32\nparent ef416e0154767619fcbfa0d1682b28bd338a8ce9\nauthor oxalica <oxalicc@pm.me> 1615824303 +0800\ncommitter oxalica <oxalicc@pm.me> 1615827873 +0800\n\nUse hir formatter more\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/87171238c6c528c421f06de8cd7e41ed3b6ff57a", "html_url": "https://github.com/rust-lang/rust/commit/87171238c6c528c421f06de8cd7e41ed3b6ff57a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/87171238c6c528c421f06de8cd7e41ed3b6ff57a/comments", "author": {"login": "oxalica", "id": 14816024, "node_id": "MDQ6VXNlcjE0ODE2MDI0", "avatar_url": "https://avatars.githubusercontent.com/u/14816024?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oxalica", "html_url": "https://github.com/oxalica", "followers_url": "https://api.github.com/users/oxalica/followers", "following_url": "https://api.github.com/users/oxalica/following{/other_user}", "gists_url": "https://api.github.com/users/oxalica/gists{/gist_id}", "starred_url": "https://api.github.com/users/oxalica/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oxalica/subscriptions", "organizations_url": "https://api.github.com/users/oxalica/orgs", "repos_url": "https://api.github.com/users/oxalica/repos", "events_url": "https://api.github.com/users/oxalica/events{/privacy}", "received_events_url": "https://api.github.com/users/oxalica/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oxalica", "id": 14816024, "node_id": "MDQ6VXNlcjE0ODE2MDI0", "avatar_url": "https://avatars.githubusercontent.com/u/14816024?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oxalica", "html_url": "https://github.com/oxalica", "followers_url": "https://api.github.com/users/oxalica/followers", "following_url": "https://api.github.com/users/oxalica/following{/other_user}", "gists_url": "https://api.github.com/users/oxalica/gists{/gist_id}", "starred_url": "https://api.github.com/users/oxalica/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oxalica/subscriptions", "organizations_url": "https://api.github.com/users/oxalica/orgs", "repos_url": "https://api.github.com/users/oxalica/repos", "events_url": "https://api.github.com/users/oxalica/events{/privacy}", "received_events_url": "https://api.github.com/users/oxalica/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ef416e0154767619fcbfa0d1682b28bd338a8ce9", "url": "https://api.github.com/repos/rust-lang/rust/commits/ef416e0154767619fcbfa0d1682b28bd338a8ce9", "html_url": "https://github.com/rust-lang/rust/commit/ef416e0154767619fcbfa0d1682b28bd338a8ce9"}], "stats": {"total": 311, "additions": 258, "deletions": 53}, "files": [{"sha": "0640712de72905c5c4c4133aad8e206a1eaa672a", "filename": "crates/hir/src/display.rs", "status": "modified", "additions": 178, "deletions": 2, "changes": 180, "blob_url": "https://github.com/rust-lang/rust/blob/87171238c6c528c421f06de8cd7e41ed3b6ff57a/crates%2Fhir%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87171238c6c528c421f06de8cd7e41ed3b6ff57a/crates%2Fhir%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fdisplay.rs?ref=87171238c6c528c421f06de8cd7e41ed3b6ff57a", "patch": "@@ -1,16 +1,20 @@\n //! HirDisplay implementations for various hir types.\n use hir_def::{\n+    adt::VariantData,\n     generics::{TypeParamProvenance, WherePredicate, WherePredicateTypeTarget},\n     type_ref::{TypeBound, TypeRef},\n-    GenericDefId,\n+    AdtId, GenericDefId,\n };\n use hir_ty::display::{\n     write_bounds_like_dyn_trait_with_prefix, write_visibility, HirDisplay, HirDisplayError,\n     HirFormatter,\n };\n use syntax::ast::{self, NameOwner};\n \n-use crate::{Function, HasVisibility, Substs, Type, TypeParam};\n+use crate::{\n+    Const, ConstParam, Enum, Field, Function, HasVisibility, Module, Static, Struct, Substs, Trait,\n+    Type, TypeAlias, TypeParam, Union, Variant,\n+};\n \n impl HirDisplay for Function {\n     fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n@@ -116,6 +120,91 @@ impl HirDisplay for Function {\n     }\n }\n \n+impl HirDisplay for Struct {\n+    fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n+        write_visibility(self.module(f.db).id, self.visibility(f.db), f)?;\n+        write!(f, \"struct \")?;\n+        write!(f, \"{}\", self.name(f.db))?;\n+        let def_id = GenericDefId::AdtId(AdtId::StructId(self.id));\n+        write_generic_params(def_id, f)?;\n+        write_where_clause(def_id, f)?;\n+        Ok(())\n+    }\n+}\n+\n+impl HirDisplay for Enum {\n+    fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n+        write_visibility(self.module(f.db).id, self.visibility(f.db), f)?;\n+        write!(f, \"enum \")?;\n+        write!(f, \"{}\", self.name(f.db))?;\n+        let def_id = GenericDefId::AdtId(AdtId::EnumId(self.id));\n+        write_generic_params(def_id, f)?;\n+        write_where_clause(def_id, f)?;\n+        Ok(())\n+    }\n+}\n+\n+impl HirDisplay for Union {\n+    fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n+        write_visibility(self.module(f.db).id, self.visibility(f.db), f)?;\n+        write!(f, \"union \")?;\n+        write!(f, \"{}\", self.name(f.db))?;\n+        let def_id = GenericDefId::AdtId(AdtId::UnionId(self.id));\n+        write_generic_params(def_id, f)?;\n+        write_where_clause(def_id, f)?;\n+        Ok(())\n+    }\n+}\n+\n+impl HirDisplay for Field {\n+    fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n+        write_visibility(self.parent.module(f.db).id, self.visibility(f.db), f)?;\n+        write!(f, \"{}: \", self.name(f.db))?;\n+        self.signature_ty(f.db).hir_fmt(f)\n+    }\n+}\n+\n+impl HirDisplay for Variant {\n+    fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n+        write!(f, \"{}\", self.name(f.db))?;\n+        let data = self.variant_data(f.db);\n+        match &*data {\n+            VariantData::Unit => {}\n+            VariantData::Tuple(fields) => {\n+                write!(f, \"(\")?;\n+                let mut first = true;\n+                for (_, field) in fields.iter() {\n+                    if first {\n+                        first = false;\n+                    } else {\n+                        write!(f, \", \")?;\n+                    }\n+                    // Enum variant fields must be pub.\n+                    field.type_ref.hir_fmt(f)?;\n+                }\n+                write!(f, \")\")?;\n+            }\n+            VariantData::Record(fields) => {\n+                write!(f, \" {{\")?;\n+                let mut first = true;\n+                for (_, field) in fields.iter() {\n+                    if first {\n+                        first = false;\n+                        write!(f, \" \")?;\n+                    } else {\n+                        write!(f, \", \")?;\n+                    }\n+                    // Enum variant fields must be pub.\n+                    write!(f, \"{}: \", field.name)?;\n+                    field.type_ref.hir_fmt(f)?;\n+                }\n+                write!(f, \" }}\")?;\n+            }\n+        }\n+        Ok(())\n+    }\n+}\n+\n impl HirDisplay for Type {\n     fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n         self.ty.value.hir_fmt(f)\n@@ -135,6 +224,13 @@ impl HirDisplay for TypeParam {\n     }\n }\n \n+impl HirDisplay for ConstParam {\n+    fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n+        write!(f, \"const {}: \", self.name(f.db))?;\n+        self.ty(f.db).hir_fmt(f)\n+    }\n+}\n+\n fn write_generic_params(def: GenericDefId, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n     let params = f.db.generic_params(def);\n     if params.lifetimes.is_empty() && params.types.is_empty() && params.consts.is_empty() {\n@@ -253,3 +349,83 @@ fn write_where_clause(def: GenericDefId, f: &mut HirFormatter) -> Result<(), Hir\n \n     Ok(())\n }\n+\n+impl HirDisplay for Const {\n+    fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n+        write_visibility(self.module(f.db).id, self.visibility(f.db), f)?;\n+        let data = f.db.const_data(self.id);\n+        write!(f, \"const \")?;\n+        match &data.name {\n+            Some(name) => write!(f, \"{}: \", name)?,\n+            None => write!(f, \"_: \")?,\n+        }\n+        data.type_ref.hir_fmt(f)?;\n+        Ok(())\n+    }\n+}\n+\n+impl HirDisplay for Static {\n+    fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n+        write_visibility(self.module(f.db).id, self.visibility(f.db), f)?;\n+        let data = f.db.static_data(self.id);\n+        write!(f, \"static \")?;\n+        if data.mutable {\n+            write!(f, \"mut \")?;\n+        }\n+        match &data.name {\n+            Some(name) => write!(f, \"{}: \", name)?,\n+            None => write!(f, \"_: \")?,\n+        }\n+        data.type_ref.hir_fmt(f)?;\n+        Ok(())\n+    }\n+}\n+\n+impl HirDisplay for Trait {\n+    fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n+        write_visibility(self.module(f.db).id, self.visibility(f.db), f)?;\n+        let data = f.db.trait_data(self.id);\n+        if data.is_unsafe {\n+            write!(f, \"unsafe \")?;\n+        }\n+        if data.is_auto {\n+            write!(f, \"auto \")?;\n+        }\n+        write!(f, \"trait {}\", data.name)?;\n+        let def_id = GenericDefId::TraitId(self.id);\n+        write_generic_params(def_id, f)?;\n+        if !data.bounds.is_empty() {\n+            write!(f, \": \")?;\n+            f.write_joined(&*data.bounds, \" + \")?;\n+        }\n+        write_where_clause(def_id, f)?;\n+        Ok(())\n+    }\n+}\n+\n+impl HirDisplay for TypeAlias {\n+    fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n+        write_visibility(self.module(f.db).id, self.visibility(f.db), f)?;\n+        let data = f.db.type_alias_data(self.id);\n+        write!(f, \"type {}\", data.name)?;\n+        if !data.bounds.is_empty() {\n+            write!(f, \": \")?;\n+            f.write_joined(&data.bounds, \" + \")?;\n+        }\n+        if let Some(ty) = &data.type_ref {\n+            write!(f, \" = \")?;\n+            ty.hir_fmt(f)?;\n+        }\n+        Ok(())\n+    }\n+}\n+\n+impl HirDisplay for Module {\n+    fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n+        // FIXME: Module doesn't have visibility saved in data.\n+        match self.name(f.db) {\n+            Some(name) => write!(f, \"mod {}\", name),\n+            None => write!(f, \"mod {{unnamed}}\"),\n+        }\n+    }\n+}"}, {"sha": "98135602a5367539b8bcef5b05b7b5f13207289d", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 35, "deletions": 1, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/87171238c6c528c421f06de8cd7e41ed3b6ff57a/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87171238c6c528c421f06de8cd7e41ed3b6ff57a/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=87171238c6c528c421f06de8cd7e41ed3b6ff57a", "patch": "@@ -572,6 +572,12 @@ impl Struct {\n     }\n }\n \n+impl HasVisibility for Struct {\n+    fn visibility(&self, db: &dyn HirDatabase) -> Visibility {\n+        db.struct_data(self.id).visibility.resolve(db.upcast(), &self.id.resolver(db.upcast()))\n+    }\n+}\n+\n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct Union {\n     pub(crate) id: UnionId,\n@@ -604,6 +610,12 @@ impl Union {\n     }\n }\n \n+impl HasVisibility for Union {\n+    fn visibility(&self, db: &dyn HirDatabase) -> Visibility {\n+        db.union_data(self.id).visibility.resolve(db.upcast(), &self.id.resolver(db.upcast()))\n+    }\n+}\n+\n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct Enum {\n     pub(crate) id: EnumId,\n@@ -631,6 +643,12 @@ impl Enum {\n     }\n }\n \n+impl HasVisibility for Enum {\n+    fn visibility(&self, db: &dyn HirDatabase) -> Visibility {\n+        db.enum_data(self.id).visibility.resolve(db.upcast(), &self.id.resolver(db.upcast()))\n+    }\n+}\n+\n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct Variant {\n     pub(crate) parent: Enum,\n@@ -962,6 +980,10 @@ impl Const {\n     pub fn name(self, db: &dyn HirDatabase) -> Option<Name> {\n         db.const_data(self.id).name.clone()\n     }\n+\n+    pub fn type_ref(self, db: &dyn HirDatabase) -> TypeRef {\n+        db.const_data(self.id).type_ref.clone()\n+    }\n }\n \n impl HasVisibility for Const {\n@@ -995,6 +1017,12 @@ impl Static {\n     }\n }\n \n+impl HasVisibility for Static {\n+    fn visibility(&self, db: &dyn HirDatabase) -> Visibility {\n+        db.static_data(self.id).visibility.resolve(db.upcast(), &self.id.resolver(db.upcast()))\n+    }\n+}\n+\n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct Trait {\n     pub(crate) id: TraitId,\n@@ -1014,7 +1042,13 @@ impl Trait {\n     }\n \n     pub fn is_auto(self, db: &dyn HirDatabase) -> bool {\n-        db.trait_data(self.id).auto\n+        db.trait_data(self.id).is_auto\n+    }\n+}\n+\n+impl HasVisibility for Trait {\n+    fn visibility(&self, db: &dyn HirDatabase) -> Visibility {\n+        db.trait_data(self.id).visibility.resolve(db.upcast(), &self.id.resolver(db.upcast()))\n     }\n }\n "}, {"sha": "1b9bb8235f214a3adc54c06812298ce6b86b146f", "filename": "crates/hir_def/src/adt.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/87171238c6c528c421f06de8cd7e41ed3b6ff57a/crates%2Fhir_def%2Fsrc%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87171238c6c528c421f06de8cd7e41ed3b6ff57a/crates%2Fhir_def%2Fsrc%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fadt.rs?ref=87171238c6c528c421f06de8cd7e41ed3b6ff57a", "patch": "@@ -31,12 +31,14 @@ pub struct StructData {\n     pub name: Name,\n     pub variant_data: Arc<VariantData>,\n     pub repr: Option<ReprKind>,\n+    pub visibility: RawVisibility,\n }\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n pub struct EnumData {\n     pub name: Name,\n     pub variants: Arena<EnumVariantData>,\n+    pub visibility: RawVisibility,\n }\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n@@ -102,6 +104,7 @@ impl StructData {\n             name: strukt.name.clone(),\n             variant_data: Arc::new(variant_data),\n             repr,\n+            visibility: item_tree[strukt.visibility].clone(),\n         })\n     }\n     pub(crate) fn union_data_query(db: &dyn DefDatabase, id: UnionId) -> Arc<StructData> {\n@@ -118,6 +121,7 @@ impl StructData {\n             name: union.name.clone(),\n             variant_data: Arc::new(variant_data),\n             repr,\n+            visibility: item_tree[union.visibility].clone(),\n         })\n     }\n }\n@@ -150,7 +154,11 @@ impl EnumData {\n             }\n         }\n \n-        Arc::new(EnumData { name: enum_.name.clone(), variants })\n+        Arc::new(EnumData {\n+            name: enum_.name.clone(),\n+            variants,\n+            visibility: item_tree[enum_.visibility].clone(),\n+        })\n     }\n \n     pub fn variant(&self, name: &Name) -> Option<LocalEnumVariantId> {"}, {"sha": "74a2194e5e7bf339b7ea216464262b185238c22f", "filename": "crates/hir_def/src/data.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/87171238c6c528c421f06de8cd7e41ed3b6ff57a/crates%2Fhir_def%2Fsrc%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87171238c6c528c421f06de8cd7e41ed3b6ff57a/crates%2Fhir_def%2Fsrc%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fdata.rs?ref=87171238c6c528c421f06de8cd7e41ed3b6ff57a", "patch": "@@ -87,7 +87,10 @@ impl TypeAliasData {\n pub struct TraitData {\n     pub name: Name,\n     pub items: Vec<(Name, AssocItemId)>,\n-    pub auto: bool,\n+    pub is_auto: bool,\n+    pub is_unsafe: bool,\n+    pub visibility: RawVisibility,\n+    pub bounds: Box<[TypeBound]>,\n }\n \n impl TraitData {\n@@ -96,10 +99,13 @@ impl TraitData {\n         let item_tree = db.item_tree(tr_loc.id.file_id);\n         let tr_def = &item_tree[tr_loc.id.value];\n         let name = tr_def.name.clone();\n-        let auto = tr_def.auto;\n+        let is_auto = tr_def.is_auto;\n+        let is_unsafe = tr_def.is_unsafe;\n         let module_id = tr_loc.container;\n         let container = AssocContainerId::TraitId(tr);\n         let mut expander = Expander::new(db, tr_loc.id.file_id, module_id);\n+        let visibility = item_tree[tr_def.visibility].clone();\n+        let bounds = tr_def.bounds.clone();\n \n         let items = collect_items(\n             db,\n@@ -111,7 +117,7 @@ impl TraitData {\n             100,\n         );\n \n-        Arc::new(TraitData { name, items, auto })\n+        Arc::new(TraitData { name, items, is_auto, is_unsafe, visibility, bounds })\n     }\n \n     pub fn associated_types(&self) -> impl Iterator<Item = TypeAliasId> + '_ {"}, {"sha": "d63ac3df342638c1c15a1f08573479435afd45ed", "filename": "crates/hir_def/src/item_tree.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/87171238c6c528c421f06de8cd7e41ed3b6ff57a/crates%2Fhir_def%2Fsrc%2Fitem_tree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87171238c6c528c421f06de8cd7e41ed3b6ff57a/crates%2Fhir_def%2Fsrc%2Fitem_tree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fitem_tree.rs?ref=87171238c6c528c421f06de8cd7e41ed3b6ff57a", "patch": "@@ -633,7 +633,9 @@ pub struct Trait {\n     pub name: Name,\n     pub visibility: RawVisibilityId,\n     pub generic_params: GenericParamsId,\n-    pub auto: bool,\n+    pub is_auto: bool,\n+    pub is_unsafe: bool,\n+    pub bounds: Box<[TypeBound]>,\n     pub items: Box<[AssocItem]>,\n     pub ast_id: FileAstId<ast::Trait>,\n }"}, {"sha": "7e91b991d2cf60d36340b996c281d37453c67b0a", "filename": "crates/hir_def/src/item_tree/lower.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/87171238c6c528c421f06de8cd7e41ed3b6ff57a/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87171238c6c528c421f06de8cd7e41ed3b6ff57a/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Flower.rs?ref=87171238c6c528c421f06de8cd7e41ed3b6ff57a", "patch": "@@ -500,7 +500,9 @@ impl Ctx {\n         let visibility = self.lower_visibility(trait_def);\n         let generic_params =\n             self.lower_generic_params_and_inner_items(GenericsOwner::Trait(trait_def), trait_def);\n-        let auto = trait_def.auto_token().is_some();\n+        let is_auto = trait_def.auto_token().is_some();\n+        let is_unsafe = trait_def.unsafe_token().is_some();\n+        let bounds = self.lower_type_bounds(trait_def);\n         let items = trait_def.assoc_item_list().map(|list| {\n             self.with_inherited_visibility(visibility, |this| {\n                 list.assoc_items()\n@@ -520,7 +522,9 @@ impl Ctx {\n             name,\n             visibility,\n             generic_params,\n-            auto,\n+            is_auto,\n+            is_unsafe,\n+            bounds: bounds.into(),\n             items: items.unwrap_or_default(),\n             ast_id,\n         };"}, {"sha": "4bd8ba3031563afb00e874e9f73400c8696d2d4a", "filename": "crates/hir_ty/src/traits/chalk.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/87171238c6c528c421f06de8cd7e41ed3b6ff57a/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87171238c6c528c421f06de8cd7e41ed3b6ff57a/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk.rs?ref=87171238c6c528c421f06de8cd7e41ed3b6ff57a", "patch": "@@ -429,7 +429,7 @@ pub(crate) fn trait_datum_query(\n     let generic_params = generics(db.upcast(), trait_.into());\n     let bound_vars = Substs::bound_vars(&generic_params, DebruijnIndex::INNERMOST);\n     let flags = rust_ir::TraitFlags {\n-        auto: trait_data.auto,\n+        auto: trait_data.is_auto,\n         upstream: trait_.lookup(db.upcast()).container.krate() != krate,\n         non_enumerable: true,\n         coinductive: false, // only relevant for Chalk testing"}, {"sha": "7328f410a531db306d6f2e1a598226985146787e", "filename": "crates/ide/src/hover.rs", "status": "modified", "additions": 17, "deletions": 42, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/87171238c6c528c421f06de8cd7e41ed3b6ff57a/crates%2Fide%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87171238c6c528c421f06de8cd7e41ed3b6ff57a/crates%2Fide%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhover.rs?ref=87171238c6c528c421f06de8cd7e41ed3b6ff57a", "patch": "@@ -1,7 +1,7 @@\n use either::Either;\n use hir::{\n-    Adt, AsAssocItem, AssocItemContainer, FieldSource, GenericParam, HasAttrs, HasSource,\n-    HirDisplay, Module, ModuleDef, ModuleSource, Semantics,\n+    Adt, AsAssocItem, AssocItemContainer, GenericParam, HasAttrs, HasSource, HirDisplay, Module,\n+    ModuleDef, Semantics,\n };\n use ide_db::{\n     base_db::SourceDatabase,\n@@ -14,7 +14,7 @@ use stdx::format_to;\n use syntax::{ast, match_ast, AstNode, SyntaxKind::*, SyntaxToken, TokenAtOffset, T};\n \n use crate::{\n-    display::{macro_label, ShortLabel, TryToNav},\n+    display::{macro_label, TryToNav},\n     doc_links::{remove_links, rewrite_links},\n     markdown_remove::remove_markdown,\n     markup::Markup,\n@@ -335,51 +335,35 @@ fn hover_for_definition(\n             let label = macro_label(&it.source(db)?.value);\n             from_def_source_labeled(db, it, Some(label), mod_path)\n         }\n-        Definition::Field(def) => {\n-            let src = def.source(db)?.value;\n-            if let FieldSource::Named(it) = src {\n-                from_def_source_labeled(db, def, it.short_label(), mod_path)\n-            } else {\n-                None\n-            }\n-        }\n+        Definition::Field(def) => from_hir_fmt(db, def, mod_path),\n         Definition::ModuleDef(it) => match it {\n-            ModuleDef::Module(it) => from_def_source_labeled(\n-                db,\n-                it,\n-                match it.definition_source(db).value {\n-                    ModuleSource::Module(it) => it.short_label(),\n-                    ModuleSource::SourceFile(it) => it.short_label(),\n-                    ModuleSource::BlockExpr(it) => it.short_label(),\n-                },\n-                mod_path,\n-            ),\n+            ModuleDef::Module(it) => from_hir_fmt(db, it, mod_path),\n             ModuleDef::Function(it) => from_hir_fmt(db, it, mod_path),\n-            ModuleDef::Adt(Adt::Struct(it)) => from_def_source(db, it, mod_path),\n-            ModuleDef::Adt(Adt::Union(it)) => from_def_source(db, it, mod_path),\n-            ModuleDef::Adt(Adt::Enum(it)) => from_def_source(db, it, mod_path),\n-            ModuleDef::Variant(it) => from_def_source(db, it, mod_path),\n-            ModuleDef::Const(it) => from_def_source(db, it, mod_path),\n-            ModuleDef::Static(it) => from_def_source(db, it, mod_path),\n-            ModuleDef::Trait(it) => from_def_source(db, it, mod_path),\n-            ModuleDef::TypeAlias(it) => from_def_source(db, it, mod_path),\n+            ModuleDef::Adt(Adt::Struct(it)) => from_hir_fmt(db, it, mod_path),\n+            ModuleDef::Adt(Adt::Union(it)) => from_hir_fmt(db, it, mod_path),\n+            ModuleDef::Adt(Adt::Enum(it)) => from_hir_fmt(db, it, mod_path),\n+            ModuleDef::Variant(it) => from_hir_fmt(db, it, mod_path),\n+            ModuleDef::Const(it) => from_hir_fmt(db, it, mod_path),\n+            ModuleDef::Static(it) => from_hir_fmt(db, it, mod_path),\n+            ModuleDef::Trait(it) => from_hir_fmt(db, it, mod_path),\n+            ModuleDef::TypeAlias(it) => from_hir_fmt(db, it, mod_path),\n             ModuleDef::BuiltinType(it) => famous_defs\n                 .and_then(|fd| hover_for_builtin(fd, it))\n                 .or_else(|| Some(Markup::fenced_block(&it.name()))),\n         },\n         Definition::Local(it) => hover_for_local(it, db),\n         Definition::SelfType(impl_def) => {\n             impl_def.target_ty(db).as_adt().and_then(|adt| match adt {\n-                Adt::Struct(it) => from_def_source(db, it, mod_path),\n-                Adt::Union(it) => from_def_source(db, it, mod_path),\n-                Adt::Enum(it) => from_def_source(db, it, mod_path),\n+                Adt::Struct(it) => from_hir_fmt(db, it, mod_path),\n+                Adt::Union(it) => from_hir_fmt(db, it, mod_path),\n+                Adt::Enum(it) => from_hir_fmt(db, it, mod_path),\n             })\n         }\n         Definition::Label(it) => Some(Markup::fenced_block(&it.name(db))),\n         Definition::GenericParam(it) => match it {\n             GenericParam::TypeParam(it) => Some(Markup::fenced_block(&it.display(db))),\n             GenericParam::LifetimeParam(it) => Some(Markup::fenced_block(&it.name(db))),\n-            GenericParam::ConstParam(it) => from_def_source(db, it, None),\n+            GenericParam::ConstParam(it) => Some(Markup::fenced_block(&it.display(db))),\n         },\n     };\n \n@@ -391,15 +375,6 @@ fn hover_for_definition(\n         from_def_source_labeled(db, def, Some(label), mod_path)\n     }\n \n-    fn from_def_source<A, D>(db: &RootDatabase, def: D, mod_path: Option<String>) -> Option<Markup>\n-    where\n-        D: HasSource<Ast = A> + HasAttrs + Copy,\n-        A: ShortLabel,\n-    {\n-        let short_label = def.source(db)?.value.short_label();\n-        from_def_source_labeled(db, def, short_label, mod_path)\n-    }\n-\n     fn from_def_source_labeled<D>(\n         db: &RootDatabase,\n         def: D,"}]}