{"sha": "85a78793412c7cf6bdde982f7de2fc3de204817c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg1YTc4NzkzNDEyYzdjZjZiZGRlOTgyZjdkZTJmYzNkZTIwNDgxN2M=", "commit": {"author": {"name": "Stein Somers", "email": "git@steinsomers.be", "date": "2020-08-05T08:36:12Z"}, "committer": {"name": "Stein Somers", "email": "git@steinsomers.be", "date": "2020-08-07T13:02:56Z"}, "message": "BTreeMap: better way to postpone root access in DrainFilter", "tree": {"sha": "e0a106ca91352463162a34f73fc2192359c2f213", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e0a106ca91352463162a34f73fc2192359c2f213"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/85a78793412c7cf6bdde982f7de2fc3de204817c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/85a78793412c7cf6bdde982f7de2fc3de204817c", "html_url": "https://github.com/rust-lang/rust/commit/85a78793412c7cf6bdde982f7de2fc3de204817c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/85a78793412c7cf6bdde982f7de2fc3de204817c/comments", "author": {"login": "ssomers", "id": 10174877, "node_id": "MDQ6VXNlcjEwMTc0ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/10174877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ssomers", "html_url": "https://github.com/ssomers", "followers_url": "https://api.github.com/users/ssomers/followers", "following_url": "https://api.github.com/users/ssomers/following{/other_user}", "gists_url": "https://api.github.com/users/ssomers/gists{/gist_id}", "starred_url": "https://api.github.com/users/ssomers/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ssomers/subscriptions", "organizations_url": "https://api.github.com/users/ssomers/orgs", "repos_url": "https://api.github.com/users/ssomers/repos", "events_url": "https://api.github.com/users/ssomers/events{/privacy}", "received_events_url": "https://api.github.com/users/ssomers/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ssomers", "id": 10174877, "node_id": "MDQ6VXNlcjEwMTc0ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/10174877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ssomers", "html_url": "https://github.com/ssomers", "followers_url": "https://api.github.com/users/ssomers/followers", "following_url": "https://api.github.com/users/ssomers/following{/other_user}", "gists_url": "https://api.github.com/users/ssomers/gists{/gist_id}", "starred_url": "https://api.github.com/users/ssomers/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ssomers/subscriptions", "organizations_url": "https://api.github.com/users/ssomers/orgs", "repos_url": "https://api.github.com/users/ssomers/repos", "events_url": "https://api.github.com/users/ssomers/events{/privacy}", "received_events_url": "https://api.github.com/users/ssomers/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "119d2a1a98fe87d4ae6cabf12134a0ef2fb95851", "url": "https://api.github.com/repos/rust-lang/rust/commits/119d2a1a98fe87d4ae6cabf12134a0ef2fb95851", "html_url": "https://github.com/rust-lang/rust/commit/119d2a1a98fe87d4ae6cabf12134a0ef2fb95851"}], "stats": {"total": 57, "additions": 25, "deletions": 32}, "files": [{"sha": "75315ceb544e05d1e011773ba001df4c5a19da31", "filename": "library/alloc/src/collections/btree/map.rs", "status": "modified", "additions": 23, "deletions": 30, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/85a78793412c7cf6bdde982f7de2fc3de204817c/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85a78793412c7cf6bdde982f7de2fc3de204817c/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs?ref=85a78793412c7cf6bdde982f7de2fc3de204817c", "patch": "@@ -1697,10 +1697,9 @@ impl<'a, K: 'a, V: 'a> DrainFilterInner<'a, K, V> {\n             let (k, v) = kv.kv_mut();\n             if pred(k, v) {\n                 *self.length -= 1;\n-                let RemoveResult { old_kv, pos, emptied_internal_root } = kv.remove_kv_tracking();\n+                let (kv, pos) = kv.remove_kv_tracking(|_| self.emptied_internal_root = true);\n                 self.cur_leaf_edge = Some(pos);\n-                self.emptied_internal_root |= emptied_internal_root;\n-                return Some(old_kv);\n+                return Some(kv);\n             }\n             self.cur_leaf_edge = Some(kv.next_leaf_edge());\n         }\n@@ -2645,35 +2644,28 @@ impl<'a, K: Ord, V> OccupiedEntry<'a, K, V> {\n     fn remove_kv(self) -> (K, V) {\n         *self.length -= 1;\n \n-        let RemoveResult { old_kv, pos, emptied_internal_root } = self.handle.remove_kv_tracking();\n-        let root = pos.into_node().into_root_mut();\n-        if emptied_internal_root {\n-            root.pop_internal_level();\n-        }\n+        let (old_kv, _) =\n+            self.handle.remove_kv_tracking(|root| root.into_root_mut().pop_internal_level());\n         old_kv\n     }\n }\n \n-struct RemoveResult<'a, K, V> {\n-    // Key and value removed.\n-    old_kv: (K, V),\n-    // Unique location at the leaf level that the removed KV lopgically collapsed into.\n-    pos: Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>,\n-    // Whether the remove left behind and empty internal root node, that should be removed\n-    // using `pop_internal_level`.\n-    emptied_internal_root: bool,\n-}\n-\n impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>, marker::KV> {\n     /// Removes a key/value-pair from the tree, and returns that pair, as well as\n     /// the leaf edge corresponding to that former pair. It's possible this leaves\n     /// an empty internal root node, which the caller should subsequently pop from\n     /// the map holding the tree. The caller should also decrement the map's length.\n-    fn remove_kv_tracking(self) -> RemoveResult<'a, K, V> {\n-        let (mut pos, old_key, old_val, was_internal) = match self.force() {\n+    fn remove_kv_tracking<F>(\n+        self,\n+        handle_emptied_internal_root: F,\n+    ) -> ((K, V), Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>)\n+    where\n+        F: FnOnce(NodeRef<marker::Mut<'a>, K, V, marker::Internal>),\n+    {\n+        let (old_kv, mut pos, was_internal) = match self.force() {\n             Leaf(leaf) => {\n-                let (hole, old_key, old_val) = leaf.remove();\n-                (hole, old_key, old_val, false)\n+                let (old_kv, pos) = leaf.remove();\n+                (old_kv, pos, false)\n             }\n             Internal(mut internal) => {\n                 // Replace the location freed in the internal node with the next KV,\n@@ -2688,17 +2680,16 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInter\n                 let to_remove = internal.left_edge().descend().last_leaf_edge().left_kv().ok();\n                 let to_remove = unsafe { unwrap_unchecked(to_remove) };\n \n-                let (hole, key, val) = to_remove.remove();\n+                let (kv, pos) = to_remove.remove();\n \n-                let old_key = unsafe { mem::replace(&mut *key_loc, key) };\n-                let old_val = unsafe { mem::replace(&mut *val_loc, val) };\n+                let old_key = unsafe { mem::replace(&mut *key_loc, kv.0) };\n+                let old_val = unsafe { mem::replace(&mut *val_loc, kv.1) };\n \n-                (hole, old_key, old_val, true)\n+                ((old_key, old_val), pos, true)\n             }\n         };\n \n         // Handle underflow\n-        let mut emptied_internal_root = false;\n         let mut cur_node = unsafe { ptr::read(&pos).into_node().forget_type() };\n         let mut at_leaf = true;\n         while cur_node.len() < node::MIN_LEN {\n@@ -2719,8 +2710,10 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInter\n \n                     let parent = edge.into_node();\n                     if parent.len() == 0 {\n-                        // This empty parent must be the root, and should be popped off the tree.\n-                        emptied_internal_root = true;\n+                        // The parent that was just emptied must be the root,\n+                        // because nodes on a lower level would not have been\n+                        // left underfull. It has to be popped off the tree soon.\n+                        handle_emptied_internal_root(parent);\n                         break;\n                     } else {\n                         cur_node = parent.forget_type();\n@@ -2747,7 +2740,7 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInter\n             pos = unsafe { unwrap_unchecked(pos.next_kv().ok()).next_leaf_edge() };\n         }\n \n-        RemoveResult { old_kv: (old_key, old_val), pos, emptied_internal_root }\n+        (old_kv, pos)\n     }\n }\n "}, {"sha": "4e52c16d20d20d81fc2cbd424124fb98eb71d226", "filename": "library/alloc/src/collections/btree/node.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/85a78793412c7cf6bdde982f7de2fc3de204817c/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85a78793412c7cf6bdde982f7de2fc3de204817c/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs?ref=85a78793412c7cf6bdde982f7de2fc3de204817c", "patch": "@@ -1083,12 +1083,12 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::KV>\n     /// between the now adjacent key/value pairs (if any) to the left and right of this handle.\n     pub fn remove(\n         mut self,\n-    ) -> (Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>, K, V) {\n+    ) -> ((K, V), Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>) {\n         unsafe {\n             let k = slice_remove(self.node.keys_mut(), self.idx);\n             let v = slice_remove(self.node.vals_mut(), self.idx);\n             (*self.node.as_leaf_mut()).len -= 1;\n-            (self.left_edge(), k, v)\n+            ((k, v), self.left_edge())\n         }\n     }\n }"}]}