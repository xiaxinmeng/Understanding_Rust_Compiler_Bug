{"sha": "8c4641b37f84f5491d07789d87aa31d835353e60", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhjNDY0MWIzN2Y4NGY1NDkxZDA3Nzg5ZDg3YWEzMWQ4MzUzNTNlNjA=", "commit": {"author": {"name": "Stein Somers", "email": "git@steinsomers.be", "date": "2020-08-18T10:01:43Z"}, "committer": {"name": "Stein Somers", "email": "git@steinsomers.be", "date": "2020-08-18T11:00:10Z"}, "message": "BTreeMap: check some invariants, avoid recursion in depth first search", "tree": {"sha": "858a05901998f59e966ba52125a652b09be3c006", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/858a05901998f59e966ba52125a652b09be3c006"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8c4641b37f84f5491d07789d87aa31d835353e60", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8c4641b37f84f5491d07789d87aa31d835353e60", "html_url": "https://github.com/rust-lang/rust/commit/8c4641b37f84f5491d07789d87aa31d835353e60", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8c4641b37f84f5491d07789d87aa31d835353e60/comments", "author": {"login": "ssomers", "id": 10174877, "node_id": "MDQ6VXNlcjEwMTc0ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/10174877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ssomers", "html_url": "https://github.com/ssomers", "followers_url": "https://api.github.com/users/ssomers/followers", "following_url": "https://api.github.com/users/ssomers/following{/other_user}", "gists_url": "https://api.github.com/users/ssomers/gists{/gist_id}", "starred_url": "https://api.github.com/users/ssomers/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ssomers/subscriptions", "organizations_url": "https://api.github.com/users/ssomers/orgs", "repos_url": "https://api.github.com/users/ssomers/repos", "events_url": "https://api.github.com/users/ssomers/events{/privacy}", "received_events_url": "https://api.github.com/users/ssomers/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ssomers", "id": 10174877, "node_id": "MDQ6VXNlcjEwMTc0ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/10174877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ssomers", "html_url": "https://github.com/ssomers", "followers_url": "https://api.github.com/users/ssomers/followers", "following_url": "https://api.github.com/users/ssomers/following{/other_user}", "gists_url": "https://api.github.com/users/ssomers/gists{/gist_id}", "starred_url": "https://api.github.com/users/ssomers/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ssomers/subscriptions", "organizations_url": "https://api.github.com/users/ssomers/orgs", "repos_url": "https://api.github.com/users/ssomers/repos", "events_url": "https://api.github.com/users/ssomers/events{/privacy}", "received_events_url": "https://api.github.com/users/ssomers/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f7aac25850b68ead13831e7c4605dcc7d07e4e9b", "url": "https://api.github.com/repos/rust-lang/rust/commits/f7aac25850b68ead13831e7c4605dcc7d07e4e9b", "html_url": "https://github.com/rust-lang/rust/commit/f7aac25850b68ead13831e7c4605dcc7d07e4e9b"}], "stats": {"total": 343, "additions": 302, "deletions": 41}, "files": [{"sha": "f8729c33c6713ab64c045e21bae96465bce8212f", "filename": "library/alloc/src/collections/btree/map.rs", "status": "modified", "additions": 3, "deletions": 32, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/8c4641b37f84f5491d07789d87aa31d835353e60/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4641b37f84f5491d07789d87aa31d835353e60/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs?ref=8c4641b37f84f5491d07789d87aa31d835353e60", "patch": "@@ -1236,10 +1236,10 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         right_root.fix_left_border();\n \n         if left_root.height() < right_root.height() {\n-            self.recalc_length();\n+            self.length = left_root.node_as_ref().calc_length();\n             right.length = total_num - self.len();\n         } else {\n-            right.recalc_length();\n+            right.length = right_root.node_as_ref().calc_length();\n             self.length = total_num - right.len();\n         }\n \n@@ -1283,42 +1283,13 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     {\n         DrainFilter { pred, inner: self.drain_filter_inner() }\n     }\n+\n     pub(super) fn drain_filter_inner(&mut self) -> DrainFilterInner<'_, K, V> {\n         let root_node = self.root.as_mut().map(|r| r.node_as_mut());\n         let front = root_node.map(|rn| rn.first_leaf_edge());\n         DrainFilterInner { length: &mut self.length, cur_leaf_edge: front }\n     }\n \n-    /// Calculates the number of elements if it is incorrect.\n-    fn recalc_length(&mut self) {\n-        fn dfs<'a, K, V>(node: NodeRef<marker::Immut<'a>, K, V, marker::LeafOrInternal>) -> usize\n-        where\n-            K: 'a,\n-            V: 'a,\n-        {\n-            let mut res = node.len();\n-\n-            if let Internal(node) = node.force() {\n-                let mut edge = node.first_edge();\n-                loop {\n-                    res += dfs(edge.reborrow().descend());\n-                    match edge.right_kv() {\n-                        Ok(right_kv) => {\n-                            edge = right_kv.right_edge();\n-                        }\n-                        Err(_) => {\n-                            break;\n-                        }\n-                    }\n-                }\n-            }\n-\n-            res\n-        }\n-\n-        self.length = dfs(self.root.as_ref().unwrap().node_as_ref());\n-    }\n-\n     /// Creates a consuming iterator visiting all the keys, in sorted order.\n     /// The map cannot be used after calling this.\n     /// The iterator element type is `K`."}, {"sha": "eb8d86b9693fdc84eca98a6f1e00e43d90176bb9", "filename": "library/alloc/src/collections/btree/map/tests.rs", "status": "modified", "additions": 223, "deletions": 9, "changes": 232, "blob_url": "https://github.com/rust-lang/rust/blob/8c4641b37f84f5491d07789d87aa31d835353e60/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4641b37f84f5491d07789d87aa31d835353e60/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs?ref=8c4641b37f84f5491d07789d87aa31d835353e60", "patch": "@@ -1,4 +1,6 @@\n use crate::boxed::Box;\n+use crate::collections::btree::navigate::Position;\n+use crate::collections::btree::node;\n use crate::collections::btree_map::Entry::{Occupied, Vacant};\n use crate::collections::BTreeMap;\n use crate::fmt::Debug;\n@@ -16,19 +18,19 @@ use std::sync::atomic::{AtomicUsize, Ordering};\n \n use super::super::DeterministicRng;\n \n-// Value of node::CAPACITY, thus capacity of a tree with a single level,\n+// Capacity of a tree with a single level,\n // i.e. a tree who's root is a leaf node at height 0.\n-const NODE_CAPACITY: usize = 11;\n+const NODE_CAPACITY: usize = node::CAPACITY;\n \n-// Minimum number of elements to insert in order to guarantee a tree with 2 levels,\n+// Minimum number of elements to insert, to guarantee a tree with 2 levels,\n // i.e. a tree who's root is an internal node at height 1, with edges to leaf nodes.\n // It's not the minimum size: removing an element from such a tree does not always reduce height.\n const MIN_INSERTS_HEIGHT_1: usize = NODE_CAPACITY + 1;\n \n-// Minimum number of elements to insert in order to guarantee a tree with 3 levels,\n+// Minimum number of elements to insert in ascending order, to guarantee a tree with 3 levels,\n // i.e. a tree who's root is an internal node at height 2, with edges to more internal nodes.\n // It's not the minimum size: removing an element from such a tree does not always reduce height.\n-const MIN_INSERTS_HEIGHT_2: usize = NODE_CAPACITY + (NODE_CAPACITY + 1) * NODE_CAPACITY + 1;\n+const MIN_INSERTS_HEIGHT_2: usize = 89;\n \n // Gather all references from a mutable iterator and make sure Miri notices if\n // using them is dangerous.\n@@ -44,11 +46,141 @@ fn test_all_refs<'a, T: 'a>(dummy: &mut T, iter: impl Iterator<Item = &'a mut T>\n     }\n }\n \n+struct SeriesChecker<T> {\n+    previous: Option<T>,\n+}\n+\n+impl<T: Copy + Debug + Ord> SeriesChecker<T> {\n+    fn is_ascending(&mut self, next: T) {\n+        if let Some(previous) = self.previous {\n+            assert!(previous < next, \"{:?} >= {:?}\", previous, next);\n+        }\n+        self.previous = Some(next);\n+    }\n+}\n+\n+impl<'a, K: 'a, V: 'a> BTreeMap<K, V> {\n+    /// Panics if the map (or the code navigating it) is corrupted.\n+    fn check(&self)\n+    where\n+        K: Copy + Debug + Ord,\n+    {\n+        if let Some(root) = &self.root {\n+            let root_node = root.node_as_ref();\n+            let mut checker = SeriesChecker { previous: None };\n+            let mut internal_length = 0;\n+            let mut internal_kv_count = 0;\n+            let mut leaf_length = 0;\n+            root_node.visit_nodes_in_order(|pos| match pos {\n+                Position::Leaf(node) => {\n+                    let is_root = root_node.height() == 0;\n+                    let min_len = if is_root { 0 } else { node::MIN_LEN };\n+                    assert!(node.len() >= min_len, \"{} < {}\", node.len(), min_len);\n+\n+                    for &key in node.keys() {\n+                        checker.is_ascending(key);\n+                    }\n+                    leaf_length += node.len();\n+                }\n+                Position::Internal(node) => {\n+                    let is_root = root_node.height() == node.height();\n+                    let min_len = if is_root { 1 } else { node::MIN_LEN };\n+                    assert!(node.len() >= min_len, \"{} < {}\", node.len(), min_len);\n+\n+                    internal_length += node.len();\n+                }\n+                Position::InternalKV(kv) => {\n+                    let key = *kv.into_kv().0;\n+                    checker.is_ascending(key);\n+\n+                    internal_kv_count += 1;\n+                }\n+            });\n+            assert_eq!(internal_length, internal_kv_count);\n+            assert_eq!(root_node.calc_length(), internal_length + leaf_length);\n+            assert_eq!(self.length, internal_length + leaf_length);\n+        } else {\n+            assert_eq!(self.length, 0);\n+        }\n+    }\n+\n+    /// Returns the height of the root, if any.\n+    fn height(&self) -> Option<usize> {\n+        self.root.as_ref().map(node::Root::height)\n+    }\n+\n+    fn dump_keys(&self) -> String\n+    where\n+        K: Debug,\n+    {\n+        if let Some(root) = self.root.as_ref() {\n+            let mut result = String::new();\n+            let root_node = root.node_as_ref();\n+            root_node.visit_nodes_in_order(|pos| match pos {\n+                Position::Leaf(leaf) => {\n+                    let depth = root_node.height();\n+                    let indent = \"  \".repeat(depth);\n+                    result += &format!(\"\\n{}{:?}\", indent, leaf.keys())\n+                }\n+                Position::Internal(_) => {}\n+                Position::InternalKV(kv) => {\n+                    let depth = root_node.height() - kv.into_node().height();\n+                    let indent = \"  \".repeat(depth);\n+                    result += &format!(\"\\n{}{:?}\", indent, kv.into_kv().0);\n+                }\n+            });\n+            result\n+        } else {\n+            String::from(\"not yet allocated\")\n+        }\n+    }\n+}\n+\n+// Test our value of MIN_INSERTS_HEIGHT_2. It may change according to the\n+// implementation of insertion, but it's best to be aware of when it does.\n+#[test]\n+fn test_levels() {\n+    let mut map = BTreeMap::new();\n+    map.check();\n+    assert_eq!(map.height(), None);\n+    assert_eq!(map.len(), 0);\n+\n+    map.insert(0, ());\n+    while map.height() == Some(0) {\n+        let last_key = *map.last_key_value().unwrap().0;\n+        map.insert(last_key + 1, ());\n+    }\n+    map.check();\n+    // Structure:\n+    // - 1 element in internal root node with 2 children\n+    // - 6 elements in left leaf child\n+    // - 5 elements in right leaf child\n+    assert_eq!(map.height(), Some(1));\n+    assert_eq!(map.len(), MIN_INSERTS_HEIGHT_1, \"{}\", map.dump_keys());\n+\n+    while map.height() == Some(1) {\n+        let last_key = *map.last_key_value().unwrap().0;\n+        map.insert(last_key + 1, ());\n+    }\n+    println!(\"{}\", map.dump_keys());\n+    map.check();\n+    // Structure:\n+    // - 1 element in internal root node with 2 children\n+    // - 6 elements in left internal child with 7 grandchildren\n+    // - 42 elements in left child's 7 grandchildren with 6 elements each\n+    // - 5 elements in right internal child with 6 grandchildren\n+    // - 30 elements in right child's 5 first grandchildren with 6 elements each\n+    // - 5 elements in right child's last grandchild\n+    assert_eq!(map.height(), Some(2));\n+    assert_eq!(map.len(), MIN_INSERTS_HEIGHT_2, \"{}\", map.dump_keys());\n+}\n+\n #[test]\n fn test_basic_large() {\n     let mut map = BTreeMap::new();\n     // Miri is too slow\n     let size = if cfg!(miri) { MIN_INSERTS_HEIGHT_2 } else { 10000 };\n+    let size = size + (size % 2); // round up to even number\n     assert_eq!(map.len(), 0);\n \n     for i in 0..size {\n@@ -93,6 +225,7 @@ fn test_basic_large() {\n         assert_eq!(map.remove(&(2 * i + 1)), Some(i * 200 + 100));\n         assert_eq!(map.len(), size / 2 - i - 1);\n     }\n+    map.check();\n }\n \n #[test]\n@@ -112,7 +245,10 @@ fn test_basic_small() {\n     assert_eq!(map.range(1..).next(), None);\n     assert_eq!(map.range(1..=1).next(), None);\n     assert_eq!(map.range(1..2).next(), None);\n+    assert_eq!(map.height(), None);\n     assert_eq!(map.insert(1, 1), None);\n+    assert_eq!(map.height(), Some(0));\n+    map.check();\n \n     // 1 key-value pair:\n     assert_eq!(map.len(), 1);\n@@ -131,6 +267,8 @@ fn test_basic_small() {\n     assert_eq!(map.keys().collect::<Vec<_>>(), vec![&1]);\n     assert_eq!(map.values().collect::<Vec<_>>(), vec![&2]);\n     assert_eq!(map.insert(2, 4), None);\n+    assert_eq!(map.height(), Some(0));\n+    map.check();\n \n     // 2 key-value pairs:\n     assert_eq!(map.len(), 2);\n@@ -141,6 +279,8 @@ fn test_basic_small() {\n     assert_eq!(map.keys().collect::<Vec<_>>(), vec![&1, &2]);\n     assert_eq!(map.values().collect::<Vec<_>>(), vec![&2, &4]);\n     assert_eq!(map.remove(&1), Some(2));\n+    assert_eq!(map.height(), Some(0));\n+    map.check();\n \n     // 1 key-value pair:\n     assert_eq!(map.len(), 1);\n@@ -153,6 +293,8 @@ fn test_basic_small() {\n     assert_eq!(map.keys().collect::<Vec<_>>(), vec![&2]);\n     assert_eq!(map.values().collect::<Vec<_>>(), vec![&4]);\n     assert_eq!(map.remove(&2), Some(4));\n+    assert_eq!(map.height(), Some(0));\n+    map.check();\n \n     // Empty but root is owned (Some(...)):\n     assert_eq!(map.len(), 0);\n@@ -168,6 +310,8 @@ fn test_basic_small() {\n     assert_eq!(map.range(1..=1).next(), None);\n     assert_eq!(map.range(1..2).next(), None);\n     assert_eq!(map.remove(&1), None);\n+    assert_eq!(map.height(), Some(0));\n+    map.check();\n }\n \n #[test]\n@@ -248,6 +392,7 @@ where\n         assert_eq!(*k, T::try_from(i).unwrap());\n         assert_eq!(*v, T::try_from(size + i + 1).unwrap());\n     }\n+    map.check();\n }\n \n #[derive(Clone, Copy, Debug, Eq, PartialEq, PartialOrd, Ord)]\n@@ -268,7 +413,7 @@ fn test_iter_mut_mutation() {\n     do_test_iter_mut_mutation::<u8>(0);\n     do_test_iter_mut_mutation::<u8>(1);\n     do_test_iter_mut_mutation::<u8>(MIN_INSERTS_HEIGHT_1);\n-    do_test_iter_mut_mutation::<u8>(127); // not enough unique values to test MIN_INSERTS_HEIGHT_2\n+    do_test_iter_mut_mutation::<u8>(MIN_INSERTS_HEIGHT_2);\n     do_test_iter_mut_mutation::<u16>(1);\n     do_test_iter_mut_mutation::<u16>(MIN_INSERTS_HEIGHT_1);\n     do_test_iter_mut_mutation::<u16>(MIN_INSERTS_HEIGHT_2);\n@@ -291,6 +436,7 @@ fn test_iter_mut_mutation() {\n fn test_values_mut() {\n     let mut a: BTreeMap<_, _> = (0..MIN_INSERTS_HEIGHT_2).map(|i| (i, i)).collect();\n     test_all_refs(&mut 13, a.values_mut());\n+    a.check();\n }\n \n #[test]\n@@ -305,6 +451,7 @@ fn test_values_mut_mutation() {\n \n     let values: Vec<String> = a.values().cloned().collect();\n     assert_eq!(values, [String::from(\"hello!\"), String::from(\"goodbye!\")]);\n+    a.check();\n }\n \n #[test]\n@@ -320,6 +467,7 @@ fn test_iter_entering_root_twice() {\n     *back.1 = 42;\n     assert_eq!(front, (&0, &mut 24));\n     assert_eq!(back, (&1, &mut 42));\n+    map.check();\n }\n \n #[test]\n@@ -335,6 +483,7 @@ fn test_iter_descending_to_same_node_twice() {\n     assert_eq!(front, (&0, &mut 0));\n     // Perform mutable access.\n     *front.1 = 42;\n+    map.check();\n }\n \n #[test]\n@@ -399,6 +548,7 @@ fn test_iter_min_max() {\n     assert_eq!(a.values().max(), Some(&42));\n     assert_eq!(a.values_mut().min(), Some(&mut 24));\n     assert_eq!(a.values_mut().max(), Some(&mut 42));\n+    a.check();\n }\n \n fn range_keys(map: &BTreeMap<i32, i32>, range: impl RangeBounds<i32>) -> Vec<i32> {\n@@ -685,6 +835,7 @@ fn test_range_mut() {\n             assert_eq!(pairs.next(), None);\n         }\n     }\n+    map.check();\n }\n \n mod test_drain_filter {\n@@ -695,20 +846,23 @@ mod test_drain_filter {\n         let mut map: BTreeMap<i32, i32> = BTreeMap::new();\n         map.drain_filter(|_, _| unreachable!(\"there's nothing to decide on\"));\n         assert!(map.is_empty());\n+        map.check();\n     }\n \n     #[test]\n     fn consuming_nothing() {\n         let pairs = (0..3).map(|i| (i, i));\n         let mut map: BTreeMap<_, _> = pairs.collect();\n         assert!(map.drain_filter(|_, _| false).eq(std::iter::empty()));\n+        map.check();\n     }\n \n     #[test]\n     fn consuming_all() {\n         let pairs = (0..3).map(|i| (i, i));\n         let mut map: BTreeMap<_, _> = pairs.clone().collect();\n         assert!(map.drain_filter(|_, _| true).eq(pairs));\n+        map.check();\n     }\n \n     #[test]\n@@ -724,6 +878,7 @@ mod test_drain_filter {\n         );\n         assert!(map.keys().copied().eq(0..3));\n         assert!(map.values().copied().eq(6..9));\n+        map.check();\n     }\n \n     #[test]\n@@ -738,6 +893,7 @@ mod test_drain_filter {\n             .eq((0..3).map(|i| (i, i + 6)))\n         );\n         assert!(map.is_empty());\n+        map.check();\n     }\n \n     #[test]\n@@ -746,6 +902,7 @@ mod test_drain_filter {\n         let mut map: BTreeMap<_, _> = pairs.collect();\n         map.drain_filter(|_, _| false);\n         assert!(map.keys().copied().eq(0..3));\n+        map.check();\n     }\n \n     #[test]\n@@ -755,6 +912,7 @@ mod test_drain_filter {\n             let mut map: BTreeMap<_, _> = pairs.clone().collect();\n             map.drain_filter(|i, _| *i == doomed);\n             assert_eq!(map.len(), 2);\n+            map.check();\n         }\n     }\n \n@@ -765,6 +923,7 @@ mod test_drain_filter {\n             let mut map: BTreeMap<_, _> = pairs.clone().collect();\n             map.drain_filter(|i, _| *i != sacred);\n             assert!(map.keys().copied().eq(sacred..=sacred));\n+            map.check();\n         }\n     }\n \n@@ -774,6 +933,7 @@ mod test_drain_filter {\n         let mut map: BTreeMap<_, _> = pairs.collect();\n         map.drain_filter(|_, _| true);\n         assert!(map.is_empty());\n+        map.check();\n     }\n \n     #[test]\n@@ -782,6 +942,7 @@ mod test_drain_filter {\n         let mut map: BTreeMap<_, _> = pairs.collect();\n         map.drain_filter(|_, _| false);\n         assert!(map.keys().copied().eq(0..NODE_CAPACITY));\n+        map.check();\n     }\n \n     #[test]\n@@ -791,6 +952,7 @@ mod test_drain_filter {\n             let mut map: BTreeMap<_, _> = pairs.clone().collect();\n             map.drain_filter(|i, _| *i == doomed);\n             assert_eq!(map.len(), NODE_CAPACITY - 1);\n+            map.check();\n         }\n     }\n \n@@ -801,6 +963,7 @@ mod test_drain_filter {\n             let mut map: BTreeMap<_, _> = pairs.clone().collect();\n             map.drain_filter(|i, _| *i != sacred);\n             assert!(map.keys().copied().eq(sacred..=sacred));\n+            map.check();\n         }\n     }\n \n@@ -810,13 +973,15 @@ mod test_drain_filter {\n         let mut map: BTreeMap<_, _> = pairs.collect();\n         map.drain_filter(|_, _| true);\n         assert!(map.is_empty());\n+        map.check();\n     }\n \n     #[test]\n     fn height_0_keeping_half() {\n         let mut map: BTreeMap<_, _> = (0..16).map(|i| (i, i)).collect();\n         assert_eq!(map.drain_filter(|i, _| *i % 2 == 0).count(), 8);\n         assert_eq!(map.len(), 8);\n+        map.check();\n     }\n \n     #[test]\n@@ -825,6 +990,7 @@ mod test_drain_filter {\n         let mut map: BTreeMap<_, _> = pairs.collect();\n         map.drain_filter(|_, _| true);\n         assert!(map.is_empty());\n+        map.check();\n     }\n \n     #[test]\n@@ -834,6 +1000,7 @@ mod test_drain_filter {\n             let mut map: BTreeMap<_, _> = pairs.clone().collect();\n             map.drain_filter(|i, _| *i == doomed);\n             assert_eq!(map.len(), MIN_INSERTS_HEIGHT_1 - 1);\n+            map.check();\n         }\n     }\n \n@@ -844,28 +1011,29 @@ mod test_drain_filter {\n             let mut map: BTreeMap<_, _> = pairs.clone().collect();\n             map.drain_filter(|i, _| *i != sacred);\n             assert!(map.keys().copied().eq(sacred..=sacred));\n+            map.check();\n         }\n     }\n \n-    #[cfg(not(miri))] // Miri is too slow\n     #[test]\n     fn height_2_removing_one() {\n         let pairs = (0..MIN_INSERTS_HEIGHT_2).map(|i| (i, i));\n         for doomed in (0..MIN_INSERTS_HEIGHT_2).step_by(12) {\n             let mut map: BTreeMap<_, _> = pairs.clone().collect();\n             map.drain_filter(|i, _| *i == doomed);\n             assert_eq!(map.len(), MIN_INSERTS_HEIGHT_2 - 1);\n+            map.check();\n         }\n     }\n \n-    #[cfg(not(miri))] // Miri is too slow\n     #[test]\n     fn height_2_keeping_one() {\n         let pairs = (0..MIN_INSERTS_HEIGHT_2).map(|i| (i, i));\n         for sacred in (0..MIN_INSERTS_HEIGHT_2).step_by(12) {\n             let mut map: BTreeMap<_, _> = pairs.clone().collect();\n             map.drain_filter(|i, _| *i != sacred);\n             assert!(map.keys().copied().eq(sacred..=sacred));\n+            map.check();\n         }\n     }\n \n@@ -875,6 +1043,7 @@ mod test_drain_filter {\n         let mut map: BTreeMap<_, _> = pairs.collect();\n         map.drain_filter(|_, _| true);\n         assert!(map.is_empty());\n+        map.check();\n     }\n \n     #[test]\n@@ -937,6 +1106,7 @@ mod test_drain_filter {\n         assert_eq!(map.len(), 2);\n         assert_eq!(map.first_entry().unwrap().key(), &4);\n         assert_eq!(map.last_entry().unwrap().key(), &8);\n+        map.check();\n     }\n \n     // Same as above, but attempt to use the iterator again after the panic in the predicate\n@@ -975,6 +1145,7 @@ mod test_drain_filter {\n         assert_eq!(map.len(), 2);\n         assert_eq!(map.first_entry().unwrap().key(), &4);\n         assert_eq!(map.last_entry().unwrap().key(), &8);\n+        map.check();\n     }\n }\n \n@@ -1033,6 +1204,7 @@ fn test_entry() {\n     }\n     assert_eq!(map.get(&2).unwrap(), &200);\n     assert_eq!(map.len(), 6);\n+    map.check();\n \n     // Existing key (take)\n     match map.entry(3) {\n@@ -1043,6 +1215,7 @@ fn test_entry() {\n     }\n     assert_eq!(map.get(&3), None);\n     assert_eq!(map.len(), 5);\n+    map.check();\n \n     // Inexistent key (insert)\n     match map.entry(10) {\n@@ -1053,6 +1226,7 @@ fn test_entry() {\n     }\n     assert_eq!(map.get(&10).unwrap(), &1000);\n     assert_eq!(map.len(), 6);\n+    map.check();\n }\n \n #[test]\n@@ -1069,6 +1243,7 @@ fn test_extend_ref() {\n     assert_eq!(a[&1], \"one\");\n     assert_eq!(a[&2], \"two\");\n     assert_eq!(a[&3], \"three\");\n+    a.check();\n }\n \n #[test]\n@@ -1092,6 +1267,7 @@ fn test_zst() {\n \n     assert_eq!(m.len(), 1);\n     assert_eq!(m.iter().count(), 1);\n+    m.check();\n }\n \n // This test's only purpose is to ensure that zero-sized keys with nonsensical orderings\n@@ -1101,6 +1277,7 @@ fn test_zst() {\n fn test_bad_zst() {\n     use std::cmp::Ordering;\n \n+    #[derive(Clone, Copy, Debug)]\n     struct Bad;\n \n     impl PartialEq for Bad {\n@@ -1128,6 +1305,7 @@ fn test_bad_zst() {\n     for _ in 0..100 {\n         m.insert(Bad, Bad);\n     }\n+    m.check();\n }\n \n #[test]\n@@ -1139,35 +1317,40 @@ fn test_clone() {\n     for i in 0..size {\n         assert_eq!(map.insert(i, 10 * i), None);\n         assert_eq!(map.len(), i + 1);\n+        map.check();\n         assert_eq!(map, map.clone());\n     }\n \n     for i in 0..size {\n         assert_eq!(map.insert(i, 100 * i), Some(10 * i));\n         assert_eq!(map.len(), size);\n+        map.check();\n         assert_eq!(map, map.clone());\n     }\n \n     for i in 0..size / 2 {\n         assert_eq!(map.remove(&(i * 2)), Some(i * 200));\n         assert_eq!(map.len(), size - i - 1);\n+        map.check();\n         assert_eq!(map, map.clone());\n     }\n \n     for i in 0..size / 2 {\n         assert_eq!(map.remove(&(2 * i)), None);\n         assert_eq!(map.remove(&(2 * i + 1)), Some(i * 200 + 100));\n         assert_eq!(map.len(), size / 2 - i - 1);\n+        map.check();\n         assert_eq!(map, map.clone());\n     }\n \n-    // Test a tree with 2 chock-full levels and a tree with 3 levels.\n+    // Test a tree with 2 semi-full levels and a tree with 3 levels.\n     map = (1..MIN_INSERTS_HEIGHT_2).map(|i| (i, i)).collect();\n     assert_eq!(map.len(), MIN_INSERTS_HEIGHT_2 - 1);\n     assert_eq!(map, map.clone());\n     map.insert(0, 0);\n     assert_eq!(map.len(), MIN_INSERTS_HEIGHT_2);\n     assert_eq!(map, map.clone());\n+    map.check();\n }\n \n #[test]\n@@ -1188,8 +1371,10 @@ fn test_clone_from() {\n             map2.insert(100 * j + 1, 2 * j + 1);\n         }\n         map2.clone_from(&map1); // same length\n+        map2.check();\n         assert_eq!(map2, map1);\n         map1.insert(i, 10 * i);\n+        map1.check();\n     }\n }\n \n@@ -1246,6 +1431,7 @@ fn test_occupied_entry_key() {\n     }\n     assert_eq!(a.len(), 1);\n     assert_eq!(a[key], value);\n+    a.check();\n }\n \n #[test]\n@@ -1264,6 +1450,7 @@ fn test_vacant_entry_key() {\n     }\n     assert_eq!(a.len(), 1);\n     assert_eq!(a[key], value);\n+    a.check();\n }\n \n #[test]\n@@ -1288,6 +1475,21 @@ fn test_first_last_entry() {\n     assert_eq!(v2, 24);\n     assert_eq!(a.first_entry().unwrap().key(), &1);\n     assert_eq!(a.last_entry().unwrap().key(), &1);\n+    a.check();\n+}\n+\n+#[test]\n+fn test_insert_into_full_left() {\n+    let mut map: BTreeMap<_, _> = (0..NODE_CAPACITY).map(|i| (i * 2, ())).collect();\n+    assert!(map.insert(NODE_CAPACITY, ()).is_none());\n+    map.check();\n+}\n+\n+#[test]\n+fn test_insert_into_full_right() {\n+    let mut map: BTreeMap<_, _> = (0..NODE_CAPACITY).map(|i| (i * 2, ())).collect();\n+    assert!(map.insert(NODE_CAPACITY + 2, ()).is_none());\n+    map.check();\n }\n \n macro_rules! create_append_test {\n@@ -1317,8 +1519,10 @@ macro_rules! create_append_test {\n                 }\n             }\n \n+            a.check();\n             assert_eq!(a.remove(&($len - 1)), Some(2 * ($len - 1)));\n             assert_eq!(a.insert($len - 1, 20), None);\n+            a.check();\n         }\n     };\n }\n@@ -1355,6 +1559,8 @@ fn test_split_off_empty_right() {\n \n     let mut map = BTreeMap::from_iter(data.clone());\n     let right = map.split_off(&(data.iter().max().unwrap().0 + 1));\n+    map.check();\n+    right.check();\n \n     data.sort();\n     assert!(map.into_iter().eq(data));\n@@ -1367,6 +1573,8 @@ fn test_split_off_empty_left() {\n \n     let mut map = BTreeMap::from_iter(data.clone());\n     let right = map.split_off(&data.iter().min().unwrap().0);\n+    map.check();\n+    right.check();\n \n     data.sort();\n     assert!(map.into_iter().eq(None));\n@@ -1380,6 +1588,8 @@ fn test_split_off_tiny_left_height_2() {\n     let pairs = (0..MIN_INSERTS_HEIGHT_2).map(|i| (i, i));\n     let mut left: BTreeMap<_, _> = pairs.clone().collect();\n     let right = left.split_off(&1);\n+    left.check();\n+    right.check();\n     assert_eq!(left.len(), 1);\n     assert_eq!(right.len(), MIN_INSERTS_HEIGHT_2 - 1);\n     assert_eq!(*left.first_key_value().unwrap().0, 0);\n@@ -1395,6 +1605,8 @@ fn test_split_off_tiny_right_height_2() {\n     let mut left: BTreeMap<_, _> = pairs.clone().collect();\n     assert_eq!(*left.last_key_value().unwrap().0, last);\n     let right = left.split_off(&last);\n+    left.check();\n+    right.check();\n     assert_eq!(left.len(), MIN_INSERTS_HEIGHT_2 - 1);\n     assert_eq!(right.len(), 1);\n     assert_eq!(*left.last_key_value().unwrap().0, last - 1);\n@@ -1411,6 +1623,8 @@ fn test_split_off_large_random_sorted() {\n     let mut map = BTreeMap::from_iter(data.clone());\n     let key = data[data.len() / 2].0;\n     let right = map.split_off(&key);\n+    map.check();\n+    right.check();\n \n     assert!(map.into_iter().eq(data.clone().into_iter().filter(|x| x.0 < key)));\n     assert!(right.into_iter().eq(data.into_iter().filter(|x| x.0 >= key)));"}, {"sha": "b7b66ac7ceccd0f27a5699d8fdb4160190a0b5e9", "filename": "library/alloc/src/collections/btree/navigate.rs", "status": "modified", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/8c4641b37f84f5491d07789d87aa31d835353e60/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnavigate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c4641b37f84f5491d07789d87aa31d835353e60/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnavigate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnavigate.rs?ref=8c4641b37f84f5491d07789d87aa31d835353e60", "patch": "@@ -49,6 +49,29 @@ impl<BorrowType, K, V> Handle<NodeRef<BorrowType, K, V, marker::Leaf>, marker::E\n     }\n }\n \n+impl<BorrowType, K, V> Handle<NodeRef<BorrowType, K, V, marker::Internal>, marker::Edge> {\n+    /// Given an internal edge handle, returns [`Result::Ok`] with a handle to the neighboring KV\n+    /// on the right side, which is either in the same internal node or in an ancestor node.\n+    /// If the internal edge is the last one in the tree, returns [`Result::Err`] with the root node.\n+    pub fn next_kv(\n+        self,\n+    ) -> Result<\n+        Handle<NodeRef<BorrowType, K, V, marker::Internal>, marker::KV>,\n+        NodeRef<BorrowType, K, V, marker::Internal>,\n+    > {\n+        let mut edge = self;\n+        loop {\n+            edge = match edge.right_kv() {\n+                Ok(internal_kv) => return Ok(internal_kv),\n+                Err(last_edge) => match last_edge.into_node().ascend() {\n+                    Ok(parent_edge) => parent_edge,\n+                    Err(root) => return Err(root),\n+                },\n+            }\n+        }\n+    }\n+}\n+\n macro_rules! def_next_kv_uncheched_dealloc {\n     { unsafe fn $name:ident : $adjacent_kv:ident } => {\n         /// Given a leaf edge handle into an owned tree, returns a handle to the next KV,\n@@ -232,6 +255,59 @@ impl<BorrowType, K, V> NodeRef<BorrowType, K, V, marker::LeafOrInternal> {\n     }\n }\n \n+pub enum Position<BorrowType, K, V> {\n+    Leaf(NodeRef<BorrowType, K, V, marker::Leaf>),\n+    Internal(NodeRef<BorrowType, K, V, marker::Internal>),\n+    InternalKV(Handle<NodeRef<BorrowType, K, V, marker::Internal>, marker::KV>),\n+}\n+\n+impl<'a, K: 'a, V: 'a> NodeRef<marker::Immut<'a>, K, V, marker::LeafOrInternal> {\n+    /// Visits leaf nodes and internal KVs in order of ascending keys, and also\n+    /// visits internal nodes as a whole in a depth first order, meaning that\n+    /// internal nodes precede their individual KVs and their child nodes.\n+    pub fn visit_nodes_in_order<F>(self, mut visit: F)\n+    where\n+        F: FnMut(Position<marker::Immut<'a>, K, V>),\n+    {\n+        match self.force() {\n+            Leaf(leaf) => visit(Position::Leaf(leaf)),\n+            Internal(internal) => {\n+                visit(Position::Internal(internal));\n+                let mut edge = internal.first_edge();\n+                loop {\n+                    edge = match edge.descend().force() {\n+                        Leaf(leaf) => {\n+                            visit(Position::Leaf(leaf));\n+                            match edge.next_kv() {\n+                                Ok(kv) => {\n+                                    visit(Position::InternalKV(kv));\n+                                    kv.right_edge()\n+                                }\n+                                Err(_) => return,\n+                            }\n+                        }\n+                        Internal(internal) => {\n+                            visit(Position::Internal(internal));\n+                            internal.first_edge()\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /// Calculates the number of elements in a (sub)tree.\n+    pub fn calc_length(self) -> usize {\n+        let mut result = 0;\n+        self.visit_nodes_in_order(|pos| match pos {\n+            Position::Leaf(node) => result += node.len(),\n+            Position::Internal(node) => result += node.len(),\n+            Position::InternalKV(_) => (),\n+        });\n+        result\n+    }\n+}\n+\n impl<BorrowType, K, V> Handle<NodeRef<BorrowType, K, V, marker::LeafOrInternal>, marker::KV> {\n     /// Returns the leaf edge closest to a KV for forward navigation.\n     pub fn next_leaf_edge(self) -> Handle<NodeRef<BorrowType, K, V, marker::Leaf>, marker::Edge> {"}]}