{"sha": "4b34c7b766a3d64d3f2a9bff06d0e53648a11013", "node_id": "C_kwDOAAsO6NoAKDRiMzRjN2I3NjZhM2Q2NGQzZjJhOWJmZjA2ZDBlNTM2NDhhMTEwMTM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-16T07:15:13Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-16T07:15:13Z"}, "message": "Auto merge of #108116 - Dylan-DPC:rollup-h3n2vxl, r=Dylan-DPC\n\nRollup of 6 pull requests\n\nSuccessful merges:\n\n - #106372 (Use id-based thread parking on SOLID)\n - #108050 (Fix index out of bounds ICE in `point_at_expr_source_of_inferred_type`)\n - #108084 (Constify `RangeBounds`, `RangeX::contains` and `RangeX::is_empty` (where applicable).)\n - #108101 (don't clone types that are copy)\n - #108102 (simplify some refs)\n - #108103 (be nice and don't slice)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "72039eb3b08ba4ce8048c09ff53f0f4139eb1a76", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/72039eb3b08ba4ce8048c09ff53f0f4139eb1a76"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4b34c7b766a3d64d3f2a9bff06d0e53648a11013", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4b34c7b766a3d64d3f2a9bff06d0e53648a11013", "html_url": "https://github.com/rust-lang/rust/commit/4b34c7b766a3d64d3f2a9bff06d0e53648a11013", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4b34c7b766a3d64d3f2a9bff06d0e53648a11013/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "639377ed737b25830ec44dc6acf93467c980316a", "url": "https://api.github.com/repos/rust-lang/rust/commits/639377ed737b25830ec44dc6acf93467c980316a", "html_url": "https://github.com/rust-lang/rust/commit/639377ed737b25830ec44dc6acf93467c980316a"}, {"sha": "bb1e9846b26663e5a504d1293a6c14b1aef9b487", "url": "https://api.github.com/repos/rust-lang/rust/commits/bb1e9846b26663e5a504d1293a6c14b1aef9b487", "html_url": "https://github.com/rust-lang/rust/commit/bb1e9846b26663e5a504d1293a6c14b1aef9b487"}], "stats": {"total": 408, "additions": 174, "deletions": 234}, "files": [{"sha": "46dc4141e66193956d9c7ac1daa9d08bc0b9be04", "filename": "compiler/rustc_hir_analysis/src/astconv/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4b34c7b766a3d64d3f2a9bff06d0e53648a11013/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b34c7b766a3d64d3f2a9bff06d0e53648a11013/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs?ref=4b34c7b766a3d64d3f2a9bff06d0e53648a11013", "patch": "@@ -1970,7 +1970,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                             ) = &qself.kind {\n                                 // If the path segment already has type params, we want to overwrite\n                                 // them.\n-                                match &path.segments[..] {\n+                                match &path.segments {\n                                     // `segment` is the previous to last element on the path,\n                                     // which would normally be the `enum` itself, while the last\n                                     // `_` `PathSegment` corresponds to the variant.\n@@ -2670,7 +2670,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 // `Self` in trait or type alias.\n                 assert_eq!(opt_self_ty, None);\n                 self.prohibit_generics(path.segments.iter(), |err| {\n-                    if let [hir::PathSegment { args: Some(args), ident, .. }] = &path.segments[..] {\n+                    if let [hir::PathSegment { args: Some(args), ident, .. }] = &path.segments {\n                         err.span_suggestion_verbose(\n                             ident.span.shrink_to_hi().to(args.span_ext),\n                             \"the `Self` type doesn't accept type parameters\","}, {"sha": "76e87a9e566295dcd978a36df4f3f16650f40152", "filename": "compiler/rustc_hir_typeck/src/demand.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4b34c7b766a3d64d3f2a9bff06d0e53648a11013/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b34c7b766a3d64d3f2a9bff06d0e53648a11013/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs?ref=4b34c7b766a3d64d3f2a9bff06d0e53648a11013", "patch": "@@ -298,6 +298,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // call's arguments and we can provide a more explicit span.\n                 let sig = self.tcx.fn_sig(def_id).subst_identity();\n                 let def_self_ty = sig.input(0).skip_binder();\n+                let param_tys = sig.inputs().skip_binder().iter().skip(1);\n+                // If there's an arity mismatch, pointing out the call as the source of an inference\n+                // can be misleading, so we skip it.\n+                if param_tys.len() != args.len() {\n+                    continue;\n+                }\n                 let rcvr_ty = self.node_ty(rcvr.hir_id);\n                 // Get the evaluated type *after* calling the method call, so that the influence\n                 // of the arguments can be reflected in the receiver type. The receiver\n@@ -323,13 +329,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 let mut param_found = FxHashMap::default();\n                 if self.can_eq(self.param_env, ty, found) {\n                     // We only point at the first place where the found type was inferred.\n-                    for (i, param_ty) in sig.inputs().skip_binder().iter().skip(1).enumerate() {\n+                    for (param_ty, arg) in param_tys.zip(args) {\n                         if def_self_ty.contains(*param_ty) && let ty::Param(_) = param_ty.kind() {\n                             // We found an argument that references a type parameter in `Self`,\n                             // so we assume that this is the argument that caused the found\n                             // type, which we know already because of `can_eq` above was first\n                             // inferred in this method call.\n-                            let arg = &args[i];\n                             let arg_ty = self.node_ty(arg.hir_id);\n                             if !arg.span.overlaps(mismatch_span) {\n                                 err.span_label("}, {"sha": "a35fa008a9557793c9e88de163f94dc25efb1247", "filename": "compiler/rustc_hir_typeck/src/method/probe.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4b34c7b766a3d64d3f2a9bff06d0e53648a11013/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b34c7b766a3d64d3f2a9bff06d0e53648a11013/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs?ref=4b34c7b766a3d64d3f2a9bff06d0e53648a11013", "patch": "@@ -517,8 +517,7 @@ fn method_autoderef_steps<'tcx>(\n         .by_ref()\n         .map(|(ty, d)| {\n             let step = CandidateStep {\n-                self_ty: infcx\n-                    .make_query_response_ignoring_pending_obligations(inference_vars.clone(), ty),\n+                self_ty: infcx.make_query_response_ignoring_pending_obligations(inference_vars, ty),\n                 autoderefs: d,\n                 from_unsafe_deref: reached_raw_pointer,\n                 unsize: false,"}, {"sha": "c9aa0ec66d5614d233d6bb89aae76d60bb7a9ff5", "filename": "compiler/rustc_middle/src/ty/flags.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b34c7b766a3d64d3f2a9bff06d0e53648a11013/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b34c7b766a3d64d3f2a9bff06d0e53648a11013/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs?ref=4b34c7b766a3d64d3f2a9bff06d0e53648a11013", "patch": "@@ -125,7 +125,7 @@ impl FlagComputation {\n                 self.bound_computation(ts, |flags, ts| flags.add_tys(ts));\n             }\n \n-            &ty::GeneratorWitnessMIR(_, ref substs) => {\n+            ty::GeneratorWitnessMIR(_, substs) => {\n                 let should_remove_further_specializable =\n                     !self.flags.contains(TypeFlags::STILL_FURTHER_SPECIALIZABLE);\n                 self.add_substs(substs);"}, {"sha": "81c7e4673d41b7e11e950cfd2eba1363a4cbf11a", "filename": "compiler/rustc_query_system/src/query/caches.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4b34c7b766a3d64d3f2a9bff06d0e53648a11013/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fcaches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b34c7b766a3d64d3f2a9bff06d0e53648a11013/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fcaches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fcaches.rs?ref=4b34c7b766a3d64d3f2a9bff06d0e53648a11013", "patch": "@@ -92,7 +92,7 @@ where\n         let mut lock = self.cache.lock();\n         // We may be overwriting another value. This is all right, since the dep-graph\n         // will check that the fingerprint matches.\n-        lock.insert(key, (value.clone(), index));\n+        lock.insert(key, (value, index));\n         value\n     }\n \n@@ -153,7 +153,7 @@ where\n \n     #[inline]\n     fn complete(&self, _key: (), value: V, index: DepNodeIndex) -> Self::Stored {\n-        *self.cache.lock() = Some((value.clone(), index));\n+        *self.cache.lock() = Some((value, index));\n         value\n     }\n \n@@ -283,7 +283,7 @@ where\n         let mut lock = self.cache.get_shard_by_hash(key.index() as u64).lock();\n         #[cfg(not(parallel_compiler))]\n         let mut lock = self.cache.lock();\n-        lock.insert(key, (value.clone(), index));\n+        lock.insert(key, (value, index));\n         value\n     }\n "}, {"sha": "28aa3d5270590f2c6c15d7faf54619bf77b84e51", "filename": "compiler/rustc_trait_selection/src/solve/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b34c7b766a3d64d3f2a9bff06d0e53648a11013/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b34c7b766a3d64d3f2a9bff06d0e53648a11013/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs?ref=4b34c7b766a3d64d3f2a9bff06d0e53648a11013", "patch": "@@ -547,7 +547,7 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n             response.value.certainty == Certainty::Yes\n                 && response.has_no_inference_or_external_constraints()\n         }) {\n-            return Ok(response.clone());\n+            return Ok(*response);\n         }\n \n         let certainty = candidates.iter().fold(Certainty::AMBIGUOUS, |certainty, response| {"}, {"sha": "7ef39b20107438e0266f8a06b7eba2cf9aecf4b3", "filename": "compiler/rustc_trait_selection/src/traits/object_safety.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b34c7b766a3d64d3f2a9bff06d0e53648a11013/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b34c7b766a3d64d3f2a9bff06d0e53648a11013/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs?ref=4b34c7b766a3d64d3f2a9bff06d0e53648a11013", "patch": "@@ -599,7 +599,7 @@ fn virtual_call_violation_for_method<'tcx>(\n             return false;\n         }\n \n-        contains_illegal_self_type_reference(tcx, trait_def_id, pred.clone())\n+        contains_illegal_self_type_reference(tcx, trait_def_id, pred)\n     }) {\n         return Some(MethodViolationCode::WhereClauseReferencesSelf);\n     }"}, {"sha": "e080726d91d589bb2ca323c9e2f16158ee96146d", "filename": "compiler/rustc_type_ir/src/sty.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4b34c7b766a3d64d3f2a9bff06d0e53648a11013/compiler%2Frustc_type_ir%2Fsrc%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b34c7b766a3d64d3f2a9bff06d0e53648a11013/compiler%2Frustc_type_ir%2Fsrc%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_type_ir%2Fsrc%2Fsty.rs?ref=4b34c7b766a3d64d3f2a9bff06d0e53648a11013", "patch": "@@ -336,7 +336,7 @@ impl<I: Interner> PartialEq for TyKind<I> {\n                 a_d == b_d && a_s == b_s && a_m == b_m\n             }\n             (GeneratorWitness(a_g), GeneratorWitness(b_g)) => a_g == b_g,\n-            (&GeneratorWitnessMIR(ref a_d, ref a_s), &GeneratorWitnessMIR(ref b_d, ref b_s)) => {\n+            (GeneratorWitnessMIR(a_d, a_s), GeneratorWitnessMIR(b_d, b_s)) => {\n                 a_d == b_d && a_s == b_s\n             }\n             (Tuple(a_t), Tuple(b_t)) => a_t == b_t,\n@@ -397,8 +397,8 @@ impl<I: Interner> Ord for TyKind<I> {\n                 }\n                 (GeneratorWitness(a_g), GeneratorWitness(b_g)) => a_g.cmp(b_g),\n                 (\n-                    &GeneratorWitnessMIR(ref a_d, ref a_s),\n-                    &GeneratorWitnessMIR(ref b_d, ref b_s),\n+                    GeneratorWitnessMIR(a_d, a_s),\n+                    GeneratorWitnessMIR(b_d, b_s),\n                 ) => match Ord::cmp(a_d, b_d) {\n                     Ordering::Equal => Ord::cmp(a_s, b_s),\n                     cmp => cmp,"}, {"sha": "b4d58376aea5d363fa8b708b2ebbf470eeb785d0", "filename": "library/core/src/cmp.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4b34c7b766a3d64d3f2a9bff06d0e53648a11013/library%2Fcore%2Fsrc%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b34c7b766a3d64d3f2a9bff06d0e53648a11013/library%2Fcore%2Fsrc%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fcmp.rs?ref=4b34c7b766a3d64d3f2a9bff06d0e53648a11013", "patch": "@@ -1491,9 +1491,10 @@ mod impls {\n         }\n     }\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    impl<A: ?Sized, B: ?Sized> PartialOrd<&B> for &A\n+    #[rustc_const_unstable(feature = \"const_cmp\", issue = \"92391\")]\n+    impl<A: ?Sized, B: ?Sized> const PartialOrd<&B> for &A\n     where\n-        A: PartialOrd<B>,\n+        A: ~const PartialOrd<B>,\n     {\n         #[inline]\n         fn partial_cmp(&self, other: &&B) -> Option<Ordering> {"}, {"sha": "b8ab2656473df7007ffc2b13993180c280218020", "filename": "library/core/src/ops/range.rs", "status": "modified", "additions": 60, "deletions": 38, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/4b34c7b766a3d64d3f2a9bff06d0e53648a11013/library%2Fcore%2Fsrc%2Fops%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b34c7b766a3d64d3f2a9bff06d0e53648a11013/library%2Fcore%2Fsrc%2Fops%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fops%2Frange.rs?ref=4b34c7b766a3d64d3f2a9bff06d0e53648a11013", "patch": "@@ -96,7 +96,7 @@ impl<Idx: fmt::Debug> fmt::Debug for Range<Idx> {\n     }\n }\n \n-impl<Idx: PartialOrd<Idx>> Range<Idx> {\n+impl<Idx: ~const PartialOrd<Idx>> Range<Idx> {\n     /// Returns `true` if `item` is contained in the range.\n     ///\n     /// # Examples\n@@ -116,10 +116,11 @@ impl<Idx: PartialOrd<Idx>> Range<Idx> {\n     /// assert!(!(f32::NAN..1.0).contains(&0.5));\n     /// ```\n     #[stable(feature = \"range_contains\", since = \"1.35.0\")]\n-    pub fn contains<U>(&self, item: &U) -> bool\n+    #[rustc_const_unstable(feature = \"const_range_bounds\", issue = \"108082\")]\n+    pub const fn contains<U>(&self, item: &U) -> bool\n     where\n-        Idx: PartialOrd<U>,\n-        U: ?Sized + PartialOrd<Idx>,\n+        Idx: ~const PartialOrd<U>,\n+        U: ?Sized + ~const PartialOrd<Idx>,\n     {\n         <Self as RangeBounds<Idx>>::contains(self, item)\n     }\n@@ -142,7 +143,8 @@ impl<Idx: PartialOrd<Idx>> Range<Idx> {\n     /// assert!( (f32::NAN..5.0).is_empty());\n     /// ```\n     #[stable(feature = \"range_is_empty\", since = \"1.47.0\")]\n-    pub fn is_empty(&self) -> bool {\n+    #[rustc_const_unstable(feature = \"const_range_bounds\", issue = \"108082\")]\n+    pub const fn is_empty(&self) -> bool {\n         !(self.start < self.end)\n     }\n }\n@@ -199,7 +201,7 @@ impl<Idx: fmt::Debug> fmt::Debug for RangeFrom<Idx> {\n     }\n }\n \n-impl<Idx: PartialOrd<Idx>> RangeFrom<Idx> {\n+impl<Idx: ~const PartialOrd<Idx>> RangeFrom<Idx> {\n     /// Returns `true` if `item` is contained in the range.\n     ///\n     /// # Examples\n@@ -214,10 +216,11 @@ impl<Idx: PartialOrd<Idx>> RangeFrom<Idx> {\n     /// assert!(!(f32::NAN..).contains(&0.5));\n     /// ```\n     #[stable(feature = \"range_contains\", since = \"1.35.0\")]\n-    pub fn contains<U>(&self, item: &U) -> bool\n+    #[rustc_const_unstable(feature = \"const_range_bounds\", issue = \"108082\")]\n+    pub const fn contains<U>(&self, item: &U) -> bool\n     where\n-        Idx: PartialOrd<U>,\n-        U: ?Sized + PartialOrd<Idx>,\n+        Idx: ~const PartialOrd<U>,\n+        U: ?Sized + ~const PartialOrd<Idx>,\n     {\n         <Self as RangeBounds<Idx>>::contains(self, item)\n     }\n@@ -280,7 +283,7 @@ impl<Idx: fmt::Debug> fmt::Debug for RangeTo<Idx> {\n     }\n }\n \n-impl<Idx: PartialOrd<Idx>> RangeTo<Idx> {\n+impl<Idx: ~const PartialOrd<Idx>> RangeTo<Idx> {\n     /// Returns `true` if `item` is contained in the range.\n     ///\n     /// # Examples\n@@ -295,10 +298,11 @@ impl<Idx: PartialOrd<Idx>> RangeTo<Idx> {\n     /// assert!(!(..f32::NAN).contains(&0.5));\n     /// ```\n     #[stable(feature = \"range_contains\", since = \"1.35.0\")]\n-    pub fn contains<U>(&self, item: &U) -> bool\n+    #[rustc_const_unstable(feature = \"const_range_bounds\", issue = \"108082\")]\n+    pub const fn contains<U>(&self, item: &U) -> bool\n     where\n-        Idx: PartialOrd<U>,\n-        U: ?Sized + PartialOrd<Idx>,\n+        Idx: ~const PartialOrd<U>,\n+        U: ?Sized + ~const PartialOrd<Idx>,\n     {\n         <Self as RangeBounds<Idx>>::contains(self, item)\n     }\n@@ -437,7 +441,8 @@ impl<Idx> RangeInclusive<Idx> {\n     /// ```\n     #[stable(feature = \"inclusive_range_methods\", since = \"1.27.0\")]\n     #[inline]\n-    pub fn into_inner(self) -> (Idx, Idx) {\n+    #[rustc_const_unstable(feature = \"const_range_bounds\", issue = \"108082\")]\n+    pub const fn into_inner(self) -> (Idx, Idx) {\n         (self.start, self.end)\n     }\n }\n@@ -469,7 +474,7 @@ impl<Idx: fmt::Debug> fmt::Debug for RangeInclusive<Idx> {\n     }\n }\n \n-impl<Idx: PartialOrd<Idx>> RangeInclusive<Idx> {\n+impl<Idx: ~const PartialOrd<Idx>> RangeInclusive<Idx> {\n     /// Returns `true` if `item` is contained in the range.\n     ///\n     /// # Examples\n@@ -500,10 +505,11 @@ impl<Idx: PartialOrd<Idx>> RangeInclusive<Idx> {\n     /// assert!(!r.contains(&3) && !r.contains(&5));\n     /// ```\n     #[stable(feature = \"range_contains\", since = \"1.35.0\")]\n-    pub fn contains<U>(&self, item: &U) -> bool\n+    #[rustc_const_unstable(feature = \"const_range_bounds\", issue = \"108082\")]\n+    pub const fn contains<U>(&self, item: &U) -> bool\n     where\n-        Idx: PartialOrd<U>,\n-        U: ?Sized + PartialOrd<Idx>,\n+        Idx: ~const PartialOrd<U>,\n+        U: ?Sized + ~const PartialOrd<Idx>,\n     {\n         <Self as RangeBounds<Idx>>::contains(self, item)\n     }\n@@ -535,8 +541,9 @@ impl<Idx: PartialOrd<Idx>> RangeInclusive<Idx> {\n     /// assert!(r.is_empty());\n     /// ```\n     #[stable(feature = \"range_is_empty\", since = \"1.47.0\")]\n+    #[rustc_const_unstable(feature = \"const_range_bounds\", issue = \"108082\")]\n     #[inline]\n-    pub fn is_empty(&self) -> bool {\n+    pub const fn is_empty(&self) -> bool {\n         self.exhausted || !(self.start <= self.end)\n     }\n }\n@@ -598,7 +605,7 @@ impl<Idx: fmt::Debug> fmt::Debug for RangeToInclusive<Idx> {\n     }\n }\n \n-impl<Idx: PartialOrd<Idx>> RangeToInclusive<Idx> {\n+impl<Idx: ~const PartialOrd<Idx>> RangeToInclusive<Idx> {\n     /// Returns `true` if `item` is contained in the range.\n     ///\n     /// # Examples\n@@ -613,10 +620,11 @@ impl<Idx: PartialOrd<Idx>> RangeToInclusive<Idx> {\n     /// assert!(!(..=f32::NAN).contains(&0.5));\n     /// ```\n     #[stable(feature = \"range_contains\", since = \"1.35.0\")]\n-    pub fn contains<U>(&self, item: &U) -> bool\n+    #[rustc_const_unstable(feature = \"const_range_bounds\", issue = \"108082\")]\n+    pub const fn contains<U>(&self, item: &U) -> bool\n     where\n-        Idx: PartialOrd<U>,\n-        U: ?Sized + PartialOrd<Idx>,\n+        Idx: ~const PartialOrd<U>,\n+        U: ?Sized + ~const PartialOrd<Idx>,\n     {\n         <Self as RangeBounds<Idx>>::contains(self, item)\n     }\n@@ -757,6 +765,7 @@ impl<T: Clone> Bound<&T> {\n /// `RangeBounds` is implemented by Rust's built-in range types, produced\n /// by range syntax like `..`, `a..`, `..b`, `..=c`, `d..e`, or `f..=g`.\n #[stable(feature = \"collections_range\", since = \"1.28.0\")]\n+#[const_trait]\n pub trait RangeBounds<T: ?Sized> {\n     /// Start index bound.\n     ///\n@@ -809,8 +818,8 @@ pub trait RangeBounds<T: ?Sized> {\n     #[stable(feature = \"range_contains\", since = \"1.35.0\")]\n     fn contains<U>(&self, item: &U) -> bool\n     where\n-        T: PartialOrd<U>,\n-        U: ?Sized + PartialOrd<T>,\n+        T: ~const PartialOrd<U>,\n+        U: ?Sized + ~const PartialOrd<T>,\n     {\n         (match self.start_bound() {\n             Included(start) => start <= item,\n@@ -827,7 +836,8 @@ pub trait RangeBounds<T: ?Sized> {\n use self::Bound::{Excluded, Included, Unbounded};\n \n #[stable(feature = \"collections_range\", since = \"1.28.0\")]\n-impl<T: ?Sized> RangeBounds<T> for RangeFull {\n+#[rustc_const_unstable(feature = \"const_range_bounds\", issue = \"108082\")]\n+impl<T: ?Sized> const RangeBounds<T> for RangeFull {\n     fn start_bound(&self) -> Bound<&T> {\n         Unbounded\n     }\n@@ -837,7 +847,8 @@ impl<T: ?Sized> RangeBounds<T> for RangeFull {\n }\n \n #[stable(feature = \"collections_range\", since = \"1.28.0\")]\n-impl<T> RangeBounds<T> for RangeFrom<T> {\n+#[rustc_const_unstable(feature = \"const_range_bounds\", issue = \"108082\")]\n+impl<T> const RangeBounds<T> for RangeFrom<T> {\n     fn start_bound(&self) -> Bound<&T> {\n         Included(&self.start)\n     }\n@@ -847,7 +858,8 @@ impl<T> RangeBounds<T> for RangeFrom<T> {\n }\n \n #[stable(feature = \"collections_range\", since = \"1.28.0\")]\n-impl<T> RangeBounds<T> for RangeTo<T> {\n+#[rustc_const_unstable(feature = \"const_range_bounds\", issue = \"108082\")]\n+impl<T> const RangeBounds<T> for RangeTo<T> {\n     fn start_bound(&self) -> Bound<&T> {\n         Unbounded\n     }\n@@ -857,7 +869,8 @@ impl<T> RangeBounds<T> for RangeTo<T> {\n }\n \n #[stable(feature = \"collections_range\", since = \"1.28.0\")]\n-impl<T> RangeBounds<T> for Range<T> {\n+#[rustc_const_unstable(feature = \"const_range_bounds\", issue = \"108082\")]\n+impl<T> const RangeBounds<T> for Range<T> {\n     fn start_bound(&self) -> Bound<&T> {\n         Included(&self.start)\n     }\n@@ -867,7 +880,8 @@ impl<T> RangeBounds<T> for Range<T> {\n }\n \n #[stable(feature = \"collections_range\", since = \"1.28.0\")]\n-impl<T> RangeBounds<T> for RangeInclusive<T> {\n+#[rustc_const_unstable(feature = \"const_range_bounds\", issue = \"108082\")]\n+impl<T> const RangeBounds<T> for RangeInclusive<T> {\n     fn start_bound(&self) -> Bound<&T> {\n         Included(&self.start)\n     }\n@@ -883,7 +897,8 @@ impl<T> RangeBounds<T> for RangeInclusive<T> {\n }\n \n #[stable(feature = \"collections_range\", since = \"1.28.0\")]\n-impl<T> RangeBounds<T> for RangeToInclusive<T> {\n+#[rustc_const_unstable(feature = \"const_range_bounds\", issue = \"108082\")]\n+impl<T> const RangeBounds<T> for RangeToInclusive<T> {\n     fn start_bound(&self) -> Bound<&T> {\n         Unbounded\n     }\n@@ -893,7 +908,8 @@ impl<T> RangeBounds<T> for RangeToInclusive<T> {\n }\n \n #[stable(feature = \"collections_range\", since = \"1.28.0\")]\n-impl<T> RangeBounds<T> for (Bound<T>, Bound<T>) {\n+#[rustc_const_unstable(feature = \"const_range_bounds\", issue = \"108082\")]\n+impl<T> const RangeBounds<T> for (Bound<T>, Bound<T>) {\n     fn start_bound(&self) -> Bound<&T> {\n         match *self {\n             (Included(ref start), _) => Included(start),\n@@ -912,7 +928,8 @@ impl<T> RangeBounds<T> for (Bound<T>, Bound<T>) {\n }\n \n #[stable(feature = \"collections_range\", since = \"1.28.0\")]\n-impl<'a, T: ?Sized + 'a> RangeBounds<T> for (Bound<&'a T>, Bound<&'a T>) {\n+#[rustc_const_unstable(feature = \"const_range_bounds\", issue = \"108082\")]\n+impl<'a, T: ?Sized + 'a> const RangeBounds<T> for (Bound<&'a T>, Bound<&'a T>) {\n     fn start_bound(&self) -> Bound<&T> {\n         self.0\n     }\n@@ -923,7 +940,8 @@ impl<'a, T: ?Sized + 'a> RangeBounds<T> for (Bound<&'a T>, Bound<&'a T>) {\n }\n \n #[stable(feature = \"collections_range\", since = \"1.28.0\")]\n-impl<T> RangeBounds<T> for RangeFrom<&T> {\n+#[rustc_const_unstable(feature = \"const_range_bounds\", issue = \"108082\")]\n+impl<T> const RangeBounds<T> for RangeFrom<&T> {\n     fn start_bound(&self) -> Bound<&T> {\n         Included(self.start)\n     }\n@@ -933,7 +951,8 @@ impl<T> RangeBounds<T> for RangeFrom<&T> {\n }\n \n #[stable(feature = \"collections_range\", since = \"1.28.0\")]\n-impl<T> RangeBounds<T> for RangeTo<&T> {\n+#[rustc_const_unstable(feature = \"const_range_bounds\", issue = \"108082\")]\n+impl<T> const RangeBounds<T> for RangeTo<&T> {\n     fn start_bound(&self) -> Bound<&T> {\n         Unbounded\n     }\n@@ -943,7 +962,8 @@ impl<T> RangeBounds<T> for RangeTo<&T> {\n }\n \n #[stable(feature = \"collections_range\", since = \"1.28.0\")]\n-impl<T> RangeBounds<T> for Range<&T> {\n+#[rustc_const_unstable(feature = \"const_range_bounds\", issue = \"108082\")]\n+impl<T> const RangeBounds<T> for Range<&T> {\n     fn start_bound(&self) -> Bound<&T> {\n         Included(self.start)\n     }\n@@ -953,7 +973,8 @@ impl<T> RangeBounds<T> for Range<&T> {\n }\n \n #[stable(feature = \"collections_range\", since = \"1.28.0\")]\n-impl<T> RangeBounds<T> for RangeInclusive<&T> {\n+#[rustc_const_unstable(feature = \"const_range_bounds\", issue = \"108082\")]\n+impl<T> const RangeBounds<T> for RangeInclusive<&T> {\n     fn start_bound(&self) -> Bound<&T> {\n         Included(self.start)\n     }\n@@ -963,7 +984,8 @@ impl<T> RangeBounds<T> for RangeInclusive<&T> {\n }\n \n #[stable(feature = \"collections_range\", since = \"1.28.0\")]\n-impl<T> RangeBounds<T> for RangeToInclusive<&T> {\n+#[rustc_const_unstable(feature = \"const_range_bounds\", issue = \"108082\")]\n+impl<T> const RangeBounds<T> for RangeToInclusive<&T> {\n     fn start_bound(&self) -> Bound<&T> {\n         Unbounded\n     }"}, {"sha": "fe9934439d152fddbfa0c417abae9c8a465a7cf6", "filename": "library/std/src/sys/itron/thread_parking.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/4b34c7b766a3d64d3f2a9bff06d0e53648a11013/library%2Fstd%2Fsrc%2Fsys%2Fitron%2Fthread_parking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b34c7b766a3d64d3f2a9bff06d0e53648a11013/library%2Fstd%2Fsrc%2Fsys%2Fitron%2Fthread_parking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fitron%2Fthread_parking.rs?ref=4b34c7b766a3d64d3f2a9bff06d0e53648a11013", "patch": "@@ -0,0 +1,37 @@\n+use super::abi;\n+use super::error::expect_success_aborting;\n+use super::time::with_tmos;\n+use crate::time::Duration;\n+\n+pub type ThreadId = abi::ID;\n+\n+pub use super::task::current_task_id_aborting as current;\n+\n+pub fn park(_hint: usize) {\n+    match unsafe { abi::slp_tsk() } {\n+        abi::E_OK | abi::E_RLWAI => {}\n+        err => {\n+            expect_success_aborting(err, &\"slp_tsk\");\n+        }\n+    }\n+}\n+\n+pub fn park_timeout(dur: Duration, _hint: usize) {\n+    match with_tmos(dur, |tmo| unsafe { abi::tslp_tsk(tmo) }) {\n+        abi::E_OK | abi::E_RLWAI | abi::E_TMOUT => {}\n+        err => {\n+            expect_success_aborting(err, &\"tslp_tsk\");\n+        }\n+    }\n+}\n+\n+pub fn unpark(id: ThreadId, _hint: usize) {\n+    match unsafe { abi::wup_tsk(id) } {\n+        // It is allowed to try to wake up a destroyed or unrelated task, so we ignore all\n+        // errors that could result from that situation.\n+        abi::E_OK | abi::E_NOEXS | abi::E_OBJ | abi::E_QOVR => {}\n+        err => {\n+            expect_success_aborting(err, &\"wup_tsk\");\n+        }\n+    }\n+}"}, {"sha": "e432edd207754e5151252c136a0946d0821d1a6a", "filename": "library/std/src/sys/itron/wait_flag.rs", "status": "removed", "additions": 0, "deletions": 72, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/639377ed737b25830ec44dc6acf93467c980316a/library%2Fstd%2Fsrc%2Fsys%2Fitron%2Fwait_flag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/639377ed737b25830ec44dc6acf93467c980316a/library%2Fstd%2Fsrc%2Fsys%2Fitron%2Fwait_flag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fitron%2Fwait_flag.rs?ref=639377ed737b25830ec44dc6acf93467c980316a", "patch": "@@ -1,72 +0,0 @@\n-use crate::mem::MaybeUninit;\n-use crate::time::Duration;\n-\n-use super::{\n-    abi,\n-    error::{expect_success, fail},\n-    time::with_tmos,\n-};\n-\n-const CLEAR: abi::FLGPTN = 0;\n-const RAISED: abi::FLGPTN = 1;\n-\n-/// A thread parking primitive that is not susceptible to race conditions,\n-/// but provides no atomic ordering guarantees and allows only one `raise` per wait.\n-pub struct WaitFlag {\n-    flag: abi::ID,\n-}\n-\n-impl WaitFlag {\n-    /// Creates a new wait flag.\n-    pub fn new() -> WaitFlag {\n-        let flag = expect_success(\n-            unsafe {\n-                abi::acre_flg(&abi::T_CFLG {\n-                    flgatr: abi::TA_FIFO | abi::TA_WSGL | abi::TA_CLR,\n-                    iflgptn: CLEAR,\n-                })\n-            },\n-            &\"acre_flg\",\n-        );\n-\n-        WaitFlag { flag }\n-    }\n-\n-    /// Wait for the wait flag to be raised.\n-    pub fn wait(&self) {\n-        let mut token = MaybeUninit::uninit();\n-        expect_success(\n-            unsafe { abi::wai_flg(self.flag, RAISED, abi::TWF_ORW, token.as_mut_ptr()) },\n-            &\"wai_flg\",\n-        );\n-    }\n-\n-    /// Wait for the wait flag to be raised or the timeout to occur.\n-    ///\n-    /// Returns whether the flag was raised (`true`) or the operation timed out (`false`).\n-    pub fn wait_timeout(&self, dur: Duration) -> bool {\n-        let mut token = MaybeUninit::uninit();\n-        let res = with_tmos(dur, |tmout| unsafe {\n-            abi::twai_flg(self.flag, RAISED, abi::TWF_ORW, token.as_mut_ptr(), tmout)\n-        });\n-\n-        match res {\n-            abi::E_OK => true,\n-            abi::E_TMOUT => false,\n-            error => fail(error, &\"twai_flg\"),\n-        }\n-    }\n-\n-    /// Raise the wait flag.\n-    ///\n-    /// Calls to this function should be balanced with the number of successful waits.\n-    pub fn raise(&self) {\n-        expect_success(unsafe { abi::set_flg(self.flag, RAISED) }, &\"set_flg\");\n-    }\n-}\n-\n-impl Drop for WaitFlag {\n-    fn drop(&mut self) {\n-        expect_success(unsafe { abi::del_flg(self.flag) }, &\"del_flg\");\n-    }\n-}"}, {"sha": "923d27fd9369d40219d1777cfef77e5e1332909f", "filename": "library/std/src/sys/solid/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4b34c7b766a3d64d3f2a9bff06d0e53648a11013/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b34c7b766a3d64d3f2a9bff06d0e53648a11013/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsolid%2Fmod.rs?ref=4b34c7b766a3d64d3f2a9bff06d0e53648a11013", "patch": "@@ -13,9 +13,9 @@ mod itron {\n     pub(super) mod spin;\n     pub(super) mod task;\n     pub mod thread;\n+    pub mod thread_parking;\n     pub(super) mod time;\n     use super::unsupported;\n-    pub mod wait_flag;\n }\n \n pub mod alloc;\n@@ -43,8 +43,8 @@ pub use self::itron::thread;\n pub mod memchr;\n pub mod thread_local_dtor;\n pub mod thread_local_key;\n+pub use self::itron::thread_parking;\n pub mod time;\n-pub use self::itron::wait_flag;\n \n mod rwlock;\n "}, {"sha": "e8e028bb3308f1c480b2ced3e33d6ebda6d370ab", "filename": "library/std/src/sys_common/thread_parking/mod.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4b34c7b766a3d64d3f2a9bff06d0e53648a11013/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parking%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b34c7b766a3d64d3f2a9bff06d0e53648a11013/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parking%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parking%2Fmod.rs?ref=4b34c7b766a3d64d3f2a9bff06d0e53648a11013", "patch": "@@ -14,12 +14,10 @@ cfg_if::cfg_if! {\n     } else if #[cfg(any(\n         target_os = \"netbsd\",\n         all(target_vendor = \"fortanix\", target_env = \"sgx\"),\n+        target_os = \"solid_asp3\",\n     ))] {\n         mod id;\n         pub use id::Parker;\n-    } else if #[cfg(target_os = \"solid_asp3\")] {\n-        mod wait_flag;\n-        pub use wait_flag::Parker;\n     } else if #[cfg(any(windows, target_family = \"unix\"))] {\n         pub use crate::sys::thread_parking::Parker;\n     } else {"}, {"sha": "d0f8899a94eb8507ff233f5d8321bf576fc8827e", "filename": "library/std/src/sys_common/thread_parking/wait_flag.rs", "status": "removed", "additions": 0, "deletions": 102, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/639377ed737b25830ec44dc6acf93467c980316a/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parking%2Fwait_flag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/639377ed737b25830ec44dc6acf93467c980316a/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parking%2Fwait_flag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fthread_parking%2Fwait_flag.rs?ref=639377ed737b25830ec44dc6acf93467c980316a", "patch": "@@ -1,102 +0,0 @@\n-//! A wait-flag-based thread parker.\n-//!\n-//! Some operating systems provide low-level parking primitives like wait counts,\n-//! event flags or semaphores which are not susceptible to race conditions (meaning\n-//! the wakeup can occur before the wait operation). To implement the `std` thread\n-//! parker on top of these primitives, we only have to ensure that parking is fast\n-//! when the thread token is available, the atomic ordering guarantees are maintained\n-//! and spurious wakeups are minimized.\n-//!\n-//! To achieve this, this parker uses an atomic variable with three states: `EMPTY`,\n-//! `PARKED` and `NOTIFIED`:\n-//! * `EMPTY` means the token has not been made available, but the thread is not\n-//!    currently waiting on it.\n-//! * `PARKED` means the token is not available and the thread is parked.\n-//! * `NOTIFIED` means the token is available.\n-//!\n-//! `park` and `park_timeout` change the state from `EMPTY` to `PARKED` and from\n-//! `NOTIFIED` to `EMPTY`. If the state was `NOTIFIED`, the thread was unparked and\n-//! execution can continue without calling into the OS. If the state was `EMPTY`,\n-//! the token is not available and the thread waits on the primitive (here called\n-//! \"wait flag\").\n-//!\n-//! `unpark` changes the state to `NOTIFIED`. If the state was `PARKED`, the thread\n-//! is or will be sleeping on the wait flag, so we raise it.\n-\n-use crate::pin::Pin;\n-use crate::sync::atomic::AtomicI8;\n-use crate::sync::atomic::Ordering::{Acquire, Relaxed, Release};\n-use crate::sys::wait_flag::WaitFlag;\n-use crate::time::Duration;\n-\n-const EMPTY: i8 = 0;\n-const PARKED: i8 = -1;\n-const NOTIFIED: i8 = 1;\n-\n-pub struct Parker {\n-    state: AtomicI8,\n-    wait_flag: WaitFlag,\n-}\n-\n-impl Parker {\n-    /// Construct a parker for the current thread. The UNIX parker\n-    /// implementation requires this to happen in-place.\n-    pub unsafe fn new_in_place(parker: *mut Parker) {\n-        parker.write(Parker { state: AtomicI8::new(EMPTY), wait_flag: WaitFlag::new() })\n-    }\n-\n-    // This implementation doesn't require `unsafe` and `Pin`, but other implementations do.\n-    pub unsafe fn park(self: Pin<&Self>) {\n-        match self.state.fetch_sub(1, Acquire) {\n-            // NOTIFIED => EMPTY\n-            NOTIFIED => return,\n-            // EMPTY => PARKED\n-            EMPTY => (),\n-            _ => panic!(\"inconsistent park state\"),\n-        }\n-\n-        // Avoid waking up from spurious wakeups (these are quite likely, see below).\n-        loop {\n-            self.wait_flag.wait();\n-\n-            match self.state.compare_exchange(NOTIFIED, EMPTY, Acquire, Relaxed) {\n-                Ok(_) => return,\n-                Err(PARKED) => (),\n-                Err(_) => panic!(\"inconsistent park state\"),\n-            }\n-        }\n-    }\n-\n-    // This implementation doesn't require `unsafe` and `Pin`, but other implementations do.\n-    pub unsafe fn park_timeout(self: Pin<&Self>, dur: Duration) {\n-        match self.state.fetch_sub(1, Acquire) {\n-            NOTIFIED => return,\n-            EMPTY => (),\n-            _ => panic!(\"inconsistent park state\"),\n-        }\n-\n-        self.wait_flag.wait_timeout(dur);\n-\n-        // Either a wakeup or a timeout occurred. Wakeups may be spurious, as there can be\n-        // a race condition when `unpark` is performed between receiving the timeout and\n-        // resetting the state, resulting in the eventflag being set unnecessarily. `park`\n-        // is protected against this by looping until the token is actually given, but\n-        // here we cannot easily tell.\n-\n-        // Use `swap` to provide acquire ordering.\n-        match self.state.swap(EMPTY, Acquire) {\n-            NOTIFIED => (),\n-            PARKED => (),\n-            _ => panic!(\"inconsistent park state\"),\n-        }\n-    }\n-\n-    // This implementation doesn't require `Pin`, but other implementations do.\n-    pub fn unpark(self: Pin<&Self>) {\n-        let state = self.state.swap(NOTIFIED, Release);\n-\n-        if state == PARKED {\n-            self.wait_flag.raise();\n-        }\n-    }\n-}"}, {"sha": "7903e9e83cfb3e001865b0e8d5298fca155a1bd0", "filename": "tests/ui/type/type-check/point-at-inference-4.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/4b34c7b766a3d64d3f2a9bff06d0e53648a11013/tests%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b34c7b766a3d64d3f2a9bff06d0e53648a11013/tests%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference-4.rs?ref=4b34c7b766a3d64d3f2a9bff06d0e53648a11013", "patch": "@@ -0,0 +1,21 @@\n+struct S<A, B>(Option<(A, B)>);\n+\n+impl<A, B> S<A, B> {\n+    fn infer(&self, a: A, b: B) {}\n+    //~^ NOTE associated function defined here\n+    //~| NOTE\n+    //~| NOTE\n+}\n+\n+fn main() {\n+    let s = S(None);\n+    s.infer(0i32);\n+    //~^ ERROR this method takes 2 arguments but 1 argument was supplied\n+    //~| NOTE an argument is missing\n+    //~| HELP provide the argument\n+    let t: S<u32, _> = s;\n+    //~^ ERROR mismatched types\n+    //~| NOTE expected `S<u32, _>`, found `S<i32, _>`\n+    //~| NOTE expected due to this\n+    //~| NOTE expected struct `S<u32, _>`\n+}"}, {"sha": "fac9701e4a11e87e4e09247987a96449a4d1ce1a", "filename": "tests/ui/type/type-check/point-at-inference-4.stderr", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/4b34c7b766a3d64d3f2a9bff06d0e53648a11013/tests%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference-4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4b34c7b766a3d64d3f2a9bff06d0e53648a11013/tests%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference-4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype%2Ftype-check%2Fpoint-at-inference-4.stderr?ref=4b34c7b766a3d64d3f2a9bff06d0e53648a11013", "patch": "@@ -0,0 +1,31 @@\n+error[E0061]: this method takes 2 arguments but 1 argument was supplied\n+  --> $DIR/point-at-inference-4.rs:12:7\n+   |\n+LL |     s.infer(0i32);\n+   |       ^^^^^------ an argument is missing\n+   |\n+note: associated function defined here\n+  --> $DIR/point-at-inference-4.rs:4:8\n+   |\n+LL |     fn infer(&self, a: A, b: B) {}\n+   |        ^^^^^        ----  ----\n+help: provide the argument\n+   |\n+LL |     s.infer(0i32, /* b */);\n+   |            ~~~~~~~~~~~~~~~\n+\n+error[E0308]: mismatched types\n+  --> $DIR/point-at-inference-4.rs:16:24\n+   |\n+LL |     let t: S<u32, _> = s;\n+   |            ---------   ^ expected `S<u32, _>`, found `S<i32, _>`\n+   |            |\n+   |            expected due to this\n+   |\n+   = note: expected struct `S<u32, _>`\n+              found struct `S<i32, _>`\n+\n+error: aborting due to 2 previous errors\n+\n+Some errors have detailed explanations: E0061, E0308.\n+For more information about an error, try `rustc --explain E0061`."}]}