{"sha": "212d6a2f61bbd3d0dae6e8768a9c0ea6c17de7a9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIxMmQ2YTJmNjFiYmQzZDBkYWU2ZTg3NjhhOWMwZWE2YzE3ZGU3YTk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-05-24T05:04:40Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-05-24T05:04:40Z"}, "message": "auto merge of #6710 : thestinger/rust/swap, r=catamorphism", "tree": {"sha": "60e419ffb5c3922a58dc201842f81fdab2abad6d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/60e419ffb5c3922a58dc201842f81fdab2abad6d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/212d6a2f61bbd3d0dae6e8768a9c0ea6c17de7a9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/212d6a2f61bbd3d0dae6e8768a9c0ea6c17de7a9", "html_url": "https://github.com/rust-lang/rust/commit/212d6a2f61bbd3d0dae6e8768a9c0ea6c17de7a9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/212d6a2f61bbd3d0dae6e8768a9c0ea6c17de7a9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7c0cc9c47a3d95e058b3684c7ed14924f64ff808", "url": "https://api.github.com/repos/rust-lang/rust/commits/7c0cc9c47a3d95e058b3684c7ed14924f64ff808", "html_url": "https://github.com/rust-lang/rust/commit/7c0cc9c47a3d95e058b3684c7ed14924f64ff808"}, {"sha": "7bff0281c72d64ec5129871354a55d6a2070dd51", "url": "https://api.github.com/repos/rust-lang/rust/commits/7bff0281c72d64ec5129871354a55d6a2070dd51", "html_url": "https://github.com/rust-lang/rust/commit/7bff0281c72d64ec5129871354a55d6a2070dd51"}], "stats": {"total": 332, "additions": 210, "deletions": 122}, "files": [{"sha": "58c77f037ded3b0b1f7b67c98d6f2d629d9bf761", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/212d6a2f61bbd3d0dae6e8768a9c0ea6c17de7a9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/212d6a2f61bbd3d0dae6e8768a9c0ea6c17de7a9/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=212d6a2f61bbd3d0dae6e8768a9c0ea6c17de7a9", "patch": "@@ -845,6 +845,26 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n                                              T_ptr(T_nil()));\n             Store(bcx, morestack_addr, fcx.llretptr.get());\n         }\n+        ~\"memcpy32\" => {\n+            let dst_ptr = get_param(decl, first_real_arg);\n+            let src_ptr = get_param(decl, first_real_arg + 1);\n+            let size = get_param(decl, first_real_arg + 2);\n+            let align = C_i32(1);\n+            let volatile = C_i1(false);\n+            let llfn = *bcx.ccx().intrinsics.get(\n+                &~\"llvm.memcpy.p0i8.p0i8.i32\");\n+            Call(bcx, llfn, [dst_ptr, src_ptr, size, align, volatile]);\n+        }\n+        ~\"memcpy64\" => {\n+            let dst_ptr = get_param(decl, first_real_arg);\n+            let src_ptr = get_param(decl, first_real_arg + 1);\n+            let size = get_param(decl, first_real_arg + 2);\n+            let align = C_i32(1);\n+            let volatile = C_i1(false);\n+            let llfn = *bcx.ccx().intrinsics.get(\n+                &~\"llvm.memcpy.p0i8.p0i8.i64\");\n+            Call(bcx, llfn, [dst_ptr, src_ptr, size, align, volatile]);\n+        }\n         ~\"memmove32\" => {\n             let dst_ptr = get_param(decl, first_real_arg);\n             let src_ptr = get_param(decl, first_real_arg + 1);"}, {"sha": "d4c34a3ace53ba67919cfa70f109da2372d9a4ed", "filename": "src/librustc/middle/trans/type_use.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/212d6a2f61bbd3d0dae6e8768a9c0ea6c17de7a9/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/212d6a2f61bbd3d0dae6e8768a9c0ea6c17de7a9/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=212d6a2f61bbd3d0dae6e8768a9c0ea6c17de7a9", "patch": "@@ -135,7 +135,7 @@ pub fn type_uses_for(ccx: @CrateContext, fn_id: def_id, n_tps: uint)\n                 ~\"visit_tydesc\"  | ~\"forget\" | ~\"frame_address\" |\n                 ~\"morestack_addr\" => 0,\n \n-                ~\"memmove32\" | ~\"memmove64\" => 0,\n+                ~\"memcpy32\" | ~\"memcpy64\" | ~\"memmove32\" | ~\"memmove64\" => 0,\n \n                 ~\"sqrtf32\" | ~\"sqrtf64\" | ~\"powif32\" | ~\"powif64\" |\n                 ~\"sinf32\"  | ~\"sinf64\"  | ~\"cosf32\"  | ~\"cosf64\"  |"}, {"sha": "6ae03ee45062df7b018ac2cd4922bd7bf0ae5def", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 145, "deletions": 115, "changes": 260, "blob_url": "https://github.com/rust-lang/rust/blob/212d6a2f61bbd3d0dae6e8768a9c0ea6c17de7a9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/212d6a2f61bbd3d0dae6e8768a9c0ea6c17de7a9/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=212d6a2f61bbd3d0dae6e8768a9c0ea6c17de7a9", "patch": "@@ -3451,122 +3451,152 @@ pub fn check_intrinsic_type(ccx: @mut CrateCtxt, it: @ast::foreign_item) {\n \n     let tcx = ccx.tcx;\n     let (n_tps, inputs, output) = match *ccx.tcx.sess.str_of(it.ident) {\n-      ~\"size_of\" |\n-      ~\"pref_align_of\" | ~\"min_align_of\" => (1u, ~[], ty::mk_uint()),\n-      ~\"init\" => (1u, ~[], param(ccx, 0u)),\n-      ~\"uninit\" => (1u, ~[], param(ccx, 0u)),\n-      ~\"forget\" => (1u, ~[ param(ccx, 0) ], ty::mk_nil()),\n-      ~\"transmute\" => (2, ~[ param(ccx, 0) ], param(ccx, 1)),\n-      ~\"move_val\" | ~\"move_val_init\" => {\n-          (1u,\n+        ~\"size_of\" |\n+        ~\"pref_align_of\" | ~\"min_align_of\" => (1u, ~[], ty::mk_uint()),\n+        ~\"init\" => (1u, ~[], param(ccx, 0u)),\n+        ~\"uninit\" => (1u, ~[], param(ccx, 0u)),\n+        ~\"forget\" => (1u, ~[ param(ccx, 0) ], ty::mk_nil()),\n+        ~\"transmute\" => (2, ~[ param(ccx, 0) ], param(ccx, 1)),\n+        ~\"move_val\" | ~\"move_val_init\" => {\n+            (1u,\n+             ~[\n+                ty::mk_mut_rptr(tcx, ty::re_bound(ty::br_anon(0)), param(ccx, 0)),\n+                param(ccx, 0u)\n+              ],\n+           ty::mk_nil())\n+        }\n+        ~\"needs_drop\" => (1u, ~[], ty::mk_bool()),\n+\n+        ~\"atomic_cxchg\"    | ~\"atomic_cxchg_acq\"| ~\"atomic_cxchg_rel\" => {\n+          (0,\n            ~[\n-              ty::mk_mut_rptr(tcx, ty::re_bound(ty::br_anon(0)), param(ccx, 0)),\n-              param(ccx, 0u)\n-            ],\n-         ty::mk_nil())\n-      }\n-      ~\"needs_drop\" => (1u, ~[], ty::mk_bool()),\n-\n-      ~\"atomic_cxchg\"    | ~\"atomic_cxchg_acq\"| ~\"atomic_cxchg_rel\" => {\n-        (0,\n-         ~[\n-            ty::mk_mut_rptr(tcx,\n-                            ty::re_bound(ty::br_anon(0)),\n-                            ty::mk_int()),\n-            ty::mk_int(),\n-            ty::mk_int()\n-         ],\n-         ty::mk_int())\n-      }\n-      ~\"atomic_load\"     | ~\"atomic_load_acq\" => {\n-        (0,\n-         ~[\n-            ty::mk_imm_rptr(tcx, ty::re_bound(ty::br_anon(0)), ty::mk_int())\n-         ],\n-        ty::mk_int())\n-      }\n-      ~\"atomic_store\"    | ~\"atomic_store_rel\" => {\n-        (0,\n-         ~[\n-            ty::mk_mut_rptr(tcx, ty::re_bound(ty::br_anon(0)), ty::mk_int()),\n-            ty::mk_int()\n-         ],\n-         ty::mk_nil())\n-      }\n-      ~\"atomic_xchg\"     | ~\"atomic_xadd\"     | ~\"atomic_xsub\"     |\n-      ~\"atomic_xchg_acq\" | ~\"atomic_xadd_acq\" | ~\"atomic_xsub_acq\" |\n-      ~\"atomic_xchg_rel\" | ~\"atomic_xadd_rel\" | ~\"atomic_xsub_rel\" => {\n-        (0,\n-         ~[\n-            ty::mk_mut_rptr(tcx, ty::re_bound(ty::br_anon(0)), ty::mk_int()),\n-            ty::mk_int()\n-         ],\n-         ty::mk_int())\n-      }\n-\n-      ~\"get_tydesc\" => {\n-        // FIXME (#3730): return *intrinsic::tydesc, not *()\n-        (1u, ~[], ty::mk_nil_ptr(ccx.tcx))\n-      }\n-      ~\"visit_tydesc\" => {\n-        let tydesc_name = special_idents::tydesc;\n-        assert!(tcx.intrinsic_defs.contains_key(&tydesc_name));\n-        let (_, tydesc_ty) = tcx.intrinsic_defs.get_copy(&tydesc_name);\n-        let (_, visitor_object_ty) = ty::visitor_object_ty(tcx);\n-        let td_ptr = ty::mk_ptr(ccx.tcx, ty::mt {\n-            ty: tydesc_ty,\n-            mutbl: ast::m_imm\n-        });\n-        (0, ~[ td_ptr, visitor_object_ty ], ty::mk_nil())\n-      }\n-      ~\"frame_address\" => {\n-        let fty = ty::mk_closure(ccx.tcx, ty::ClosureTy {\n-            purity: ast::impure_fn,\n-            sigil: ast::BorrowedSigil,\n-            onceness: ast::Once,\n-            region: ty::re_bound(ty::br_anon(0)),\n-            bounds: ty::EmptyBuiltinBounds(),\n-            sig: ty::FnSig {\n-                bound_lifetime_names: opt_vec::Empty,\n-                inputs: ~[ty::mk_imm_ptr(ccx.tcx, ty::mk_mach_uint(ast::ty_u8))],\n-                output: ty::mk_nil()\n-            }\n-        });\n-        (0u, ~[fty], ty::mk_nil())\n-      }\n-      ~\"morestack_addr\" => {\n-        (0u, ~[], ty::mk_nil_ptr(ccx.tcx))\n-      }\n-      ~\"memmove32\" => {\n-        (0,\n-         ~[\n-            ty::mk_ptr(tcx, ty::mt {\n-                ty: ty::mk_u8(),\n-                mutbl: ast::m_mutbl\n-            }),\n-            ty::mk_ptr(tcx, ty::mt {\n-                ty: ty::mk_u8(),\n-                mutbl: ast::m_imm\n-            }),\n-            ty::mk_u32()\n-         ],\n-         ty::mk_nil())\n-      }\n-      ~\"memmove64\" => {\n-        (0,\n-         ~[\n-            ty::mk_ptr(tcx, ty::mt {\n-                ty: ty::mk_u8(),\n-                mutbl: ast::m_mutbl\n-            }),\n-            ty::mk_ptr(tcx, ty::mt {\n-                ty: ty::mk_u8(),\n-                mutbl: ast::m_imm\n-            }),\n-            ty::mk_u64()\n-         ],\n-         ty::mk_nil())\n-      }\n+              ty::mk_mut_rptr(tcx,\n+                              ty::re_bound(ty::br_anon(0)),\n+                              ty::mk_int()),\n+              ty::mk_int(),\n+              ty::mk_int()\n+           ],\n+           ty::mk_int())\n+        }\n+        ~\"atomic_load\"     | ~\"atomic_load_acq\" => {\n+          (0,\n+           ~[\n+              ty::mk_imm_rptr(tcx, ty::re_bound(ty::br_anon(0)), ty::mk_int())\n+           ],\n+          ty::mk_int())\n+        }\n+        ~\"atomic_store\"    | ~\"atomic_store_rel\" => {\n+          (0,\n+           ~[\n+              ty::mk_mut_rptr(tcx, ty::re_bound(ty::br_anon(0)), ty::mk_int()),\n+              ty::mk_int()\n+           ],\n+           ty::mk_nil())\n+        }\n+        ~\"atomic_xchg\"     | ~\"atomic_xadd\"     | ~\"atomic_xsub\"     |\n+        ~\"atomic_xchg_acq\" | ~\"atomic_xadd_acq\" | ~\"atomic_xsub_acq\" |\n+        ~\"atomic_xchg_rel\" | ~\"atomic_xadd_rel\" | ~\"atomic_xsub_rel\" => {\n+          (0,\n+           ~[\n+              ty::mk_mut_rptr(tcx, ty::re_bound(ty::br_anon(0)), ty::mk_int()),\n+              ty::mk_int()\n+           ],\n+           ty::mk_int())\n+        }\n+\n+        ~\"get_tydesc\" => {\n+          // FIXME (#3730): return *intrinsic::tydesc, not *()\n+          (1u, ~[], ty::mk_nil_ptr(ccx.tcx))\n+        }\n+        ~\"visit_tydesc\" => {\n+          let tydesc_name = special_idents::tydesc;\n+          assert!(tcx.intrinsic_defs.contains_key(&tydesc_name));\n+          let (_, tydesc_ty) = tcx.intrinsic_defs.get_copy(&tydesc_name);\n+          let (_, visitor_object_ty) = ty::visitor_object_ty(tcx);\n+          let td_ptr = ty::mk_ptr(ccx.tcx, ty::mt {\n+              ty: tydesc_ty,\n+              mutbl: ast::m_imm\n+          });\n+          (0, ~[ td_ptr, visitor_object_ty ], ty::mk_nil())\n+        }\n+        ~\"frame_address\" => {\n+          let fty = ty::mk_closure(ccx.tcx, ty::ClosureTy {\n+              purity: ast::impure_fn,\n+              sigil: ast::BorrowedSigil,\n+              onceness: ast::Once,\n+              region: ty::re_bound(ty::br_anon(0)),\n+              bounds: ty::EmptyBuiltinBounds(),\n+              sig: ty::FnSig {\n+                  bound_lifetime_names: opt_vec::Empty,\n+                  inputs: ~[ty::mk_imm_ptr(ccx.tcx, ty::mk_mach_uint(ast::ty_u8))],\n+                  output: ty::mk_nil()\n+              }\n+          });\n+          (0u, ~[fty], ty::mk_nil())\n+        }\n+        ~\"morestack_addr\" => {\n+          (0u, ~[], ty::mk_nil_ptr(ccx.tcx))\n+        }\n+        ~\"memcpy32\" => {\n+          (0,\n+           ~[\n+              ty::mk_ptr(tcx, ty::mt {\n+                  ty: ty::mk_u8(),\n+                  mutbl: ast::m_mutbl\n+              }),\n+              ty::mk_ptr(tcx, ty::mt {\n+                  ty: ty::mk_u8(),\n+                  mutbl: ast::m_imm\n+              }),\n+              ty::mk_u32()\n+           ],\n+           ty::mk_nil())\n+        }\n+        ~\"memcpy64\" => {\n+          (0,\n+           ~[\n+              ty::mk_ptr(tcx, ty::mt {\n+                  ty: ty::mk_u8(),\n+                  mutbl: ast::m_mutbl\n+              }),\n+              ty::mk_ptr(tcx, ty::mt {\n+                  ty: ty::mk_u8(),\n+                  mutbl: ast::m_imm\n+              }),\n+              ty::mk_u64()\n+           ],\n+           ty::mk_nil())\n+        }\n+        ~\"memmove32\" => {\n+          (0,\n+           ~[\n+              ty::mk_ptr(tcx, ty::mt {\n+                  ty: ty::mk_u8(),\n+                  mutbl: ast::m_mutbl\n+              }),\n+              ty::mk_ptr(tcx, ty::mt {\n+                  ty: ty::mk_u8(),\n+                  mutbl: ast::m_imm\n+              }),\n+              ty::mk_u32()\n+           ],\n+           ty::mk_nil())\n+        }\n+        ~\"memmove64\" => {\n+          (0,\n+           ~[\n+              ty::mk_ptr(tcx, ty::mt {\n+                  ty: ty::mk_u8(),\n+                  mutbl: ast::m_mutbl\n+              }),\n+              ty::mk_ptr(tcx, ty::mt {\n+                  ty: ty::mk_u8(),\n+                  mutbl: ast::m_imm\n+              }),\n+              ty::mk_u64()\n+           ],\n+           ty::mk_nil())\n+        }\n         ~\"sqrtf32\" => (0, ~[ ty::mk_f32() ], ty::mk_f32()),\n         ~\"sqrtf64\" => (0, ~[ ty::mk_f64() ], ty::mk_f64()),\n         ~\"powif32\" => {"}, {"sha": "d1c0ffe79531118394508c9e8f524f79a86ef7e9", "filename": "src/libstd/ptr.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/212d6a2f61bbd3d0dae6e8768a9c0ea6c17de7a9/src%2Flibstd%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/212d6a2f61bbd3d0dae6e8768a9c0ea6c17de7a9/src%2Flibstd%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fptr.rs?ref=212d6a2f61bbd3d0dae6e8768a9c0ea6c17de7a9", "patch": "@@ -103,6 +103,7 @@ pub unsafe fn copy_memory<T>(dst: *mut T, src: *const T, count: uint) {\n     let n = count * sys::size_of::<T>();\n     memmove32(dst as *mut u8, src as *u8, n as u32);\n }\n+\n #[inline(always)]\n #[cfg(target_word_size = \"64\")]\n pub unsafe fn copy_memory<T>(dst: *mut T, src: *const T, count: uint) {\n@@ -111,6 +112,28 @@ pub unsafe fn copy_memory<T>(dst: *mut T, src: *const T, count: uint) {\n     memmove64(dst as *mut u8, src as *u8, n as u64);\n }\n \n+#[inline(always)]\n+#[cfg(target_word_size = \"32\")]\n+pub unsafe fn copy_nonoverlapping_memory<T>(dst: *mut T, src: *const T, count: uint) {\n+    #[cfg(stage0)]\n+    use memcpy32 = unstable::intrinsics::memmove32;\n+    #[cfg(not(stage0))]\n+    use unstable::intrinsics::memcpy32;\n+    let n = count * sys::size_of::<T>();\n+    memcpy32(dst as *mut u8, src as *u8, n as u32);\n+}\n+\n+#[inline(always)]\n+#[cfg(target_word_size = \"64\")]\n+pub unsafe fn copy_nonoverlapping_memory<T>(dst: *mut T, src: *const T, count: uint) {\n+    #[cfg(stage0)]\n+    use memcpy64 = unstable::intrinsics::memmove64;\n+    #[cfg(not(stage0))]\n+    use unstable::intrinsics::memcpy64;\n+    let n = count * sys::size_of::<T>();\n+    memcpy64(dst as *mut u8, src as *u8, n as u64);\n+}\n+\n #[inline(always)]\n pub unsafe fn set_memory<T>(dst: *mut T, c: int, count: uint) {\n     let n = count * sys::size_of::<T>();"}, {"sha": "521708621fc8934a512613f9b7dd6d1b13017bf8", "filename": "src/libstd/unstable/intrinsics.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/212d6a2f61bbd3d0dae6e8768a9c0ea6c17de7a9/src%2Flibstd%2Funstable%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/212d6a2f61bbd3d0dae6e8768a9c0ea6c17de7a9/src%2Flibstd%2Funstable%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fintrinsics.rs?ref=212d6a2f61bbd3d0dae6e8768a9c0ea6c17de7a9", "patch": "@@ -31,7 +31,6 @@ A quick refresher on memory ordering:\n   with atomic types and is equivalent to Java's `volatile`.\n \n */\n-\n #[abi = \"rust-intrinsic\"]\n pub extern \"rust-intrinsic\" {\n \n@@ -128,6 +127,13 @@ pub extern \"rust-intrinsic\" {\n     /// Get the address of the `__morestack` stack growth function.\n     pub fn morestack_addr() -> *();\n \n+    /// Equivalent to the `llvm.memcpy.p0i8.0i8.i32` intrinsic.\n+    #[cfg(not(stage0))]\n+    pub fn memcpy32(dst: *mut u8, src: *u8, size: u32);\n+    /// Equivalent to the `llvm.memcpy.p0i8.0i8.i64` intrinsic.\n+    #[cfg(not(stage0))]\n+    pub fn memcpy64(dst: *mut u8, src: *u8, size: u64);\n+\n     /// Equivalent to the `llvm.memmove.p0i8.0i8.i32` intrinsic.\n     pub fn memmove32(dst: *mut u8, src: *u8, size: u32);\n     /// Equivalent to the `llvm.memmove.p0i8.0i8.i64` intrinsic."}, {"sha": "400a13896be8c9aea4af6f096951db4a889cf3bb", "filename": "src/libstd/util.rs", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/212d6a2f61bbd3d0dae6e8768a9c0ea6c17de7a9/src%2Flibstd%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/212d6a2f61bbd3d0dae6e8768a9c0ea6c17de7a9/src%2Flibstd%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Futil.rs?ref=212d6a2f61bbd3d0dae6e8768a9c0ea6c17de7a9", "patch": "@@ -51,7 +51,18 @@ pub fn with<T,R>(\n #[inline(always)]\n pub fn swap<T>(x: &mut T, y: &mut T) {\n     unsafe {\n-        swap_ptr(ptr::to_mut_unsafe_ptr(x), ptr::to_mut_unsafe_ptr(y));\n+        // Give ourselves some scratch space to work with\n+        let mut tmp: T = intrinsics::uninit();\n+        let t: *mut T = &mut tmp;\n+\n+        // Perform the swap, `&mut` pointers never alias\n+        ptr::copy_nonoverlapping_memory(t, x, 1);\n+        ptr::copy_nonoverlapping_memory(x, y, 1);\n+        ptr::copy_nonoverlapping_memory(y, t, 1);\n+\n+        // y and t now point to the same thing, but we need to completely forget `tmp`\n+        // because it's no longer relevant.\n+        cast::forget(tmp);\n     }\n }\n \n@@ -61,18 +72,16 @@ pub fn swap<T>(x: &mut T, y: &mut T) {\n  */\n #[inline]\n pub unsafe fn swap_ptr<T>(x: *mut T, y: *mut T) {\n-    if x == y { return }\n-\n     // Give ourselves some scratch space to work with\n     let mut tmp: T = intrinsics::uninit();\n-    let t = ptr::to_mut_unsafe_ptr(&mut tmp);\n+    let t: *mut T = &mut tmp;\n \n     // Perform the swap\n     ptr::copy_memory(t, x, 1);\n     ptr::copy_memory(x, y, 1);\n     ptr::copy_memory(y, t, 1);\n \n-    // y and t now point to the same thing, but we need to completely forget t\n+    // y and t now point to the same thing, but we need to completely forget `tmp`\n     // because it's no longer relevant.\n     cast::forget(tmp);\n }"}]}