{"sha": "fbd8eae26de23cf00081229176fd7efd80943905", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZiZDhlYWUyNmRlMjNjZjAwMDgxMjI5MTc2ZmQ3ZWZkODA5NDM5MDU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-03-30T01:39:41Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-03-30T01:39:41Z"}, "message": "auto merge of #5631 : brson/rust/abiset, r=brson,brson\n\nContinuing #5421", "tree": {"sha": "d95089f050cd67db2a5171a799763faa09f5b0a8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d95089f050cd67db2a5171a799763faa09f5b0a8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fbd8eae26de23cf00081229176fd7efd80943905", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fbd8eae26de23cf00081229176fd7efd80943905", "html_url": "https://github.com/rust-lang/rust/commit/fbd8eae26de23cf00081229176fd7efd80943905", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fbd8eae26de23cf00081229176fd7efd80943905/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f864934f548be9f03d2c0512de8d7e908469e2ae", "url": "https://api.github.com/repos/rust-lang/rust/commits/f864934f548be9f03d2c0512de8d7e908469e2ae", "html_url": "https://github.com/rust-lang/rust/commit/f864934f548be9f03d2c0512de8d7e908469e2ae"}, {"sha": "6965fe4bceea836586bd8e7aa01a92a35b467f78", "url": "https://api.github.com/repos/rust-lang/rust/commits/6965fe4bceea836586bd8e7aa01a92a35b467f78", "html_url": "https://github.com/rust-lang/rust/commit/6965fe4bceea836586bd8e7aa01a92a35b467f78"}], "stats": {"total": 1231, "additions": 879, "deletions": 352}, "files": [{"sha": "42464c848efb3295ec996add3f3004eef5d18e07", "filename": "src/libcore/cast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fbd8eae26de23cf00081229176fd7efd80943905/src%2Flibcore%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd8eae26de23cf00081229176fd7efd80943905/src%2Flibcore%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcast.rs?ref=fbd8eae26de23cf00081229176fd7efd80943905", "patch": "@@ -13,7 +13,7 @@\n pub mod rusti {\n     #[abi = \"rust-intrinsic\"]\n     #[link_name = \"rusti\"]\n-    pub extern {\n+    pub extern \"rust-intrinsic\" {\n         fn forget<T>(+x: T);\n         fn reinterpret_cast<T, U>(&&e: T) -> U;\n     }"}, {"sha": "79bb375d360c02df095129dee962acfcaa312836", "filename": "src/libcore/libc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fbd8eae26de23cf00081229176fd7efd80943905/src%2Flibcore%2Flibc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd8eae26de23cf00081229176fd7efd80943905/src%2Flibcore%2Flibc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flibc.rs?ref=fbd8eae26de23cf00081229176fd7efd80943905", "patch": "@@ -1617,7 +1617,7 @@ pub mod funcs {\n             use libc::types::os::arch::extra::{HANDLE};\n \n             #[abi = \"stdcall\"]\n-            pub extern {\n+            pub extern \"stdcall\" {\n                 unsafe fn GetEnvironmentVariableW(n: LPCWSTR,\n                                                   v: LPWSTR,\n                                                   nsize: DWORD)"}, {"sha": "4f1edf34494122b222a572c959e42681d45cf25c", "filename": "src/libcore/os.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fbd8eae26de23cf00081229176fd7efd80943905/src%2Flibcore%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd8eae26de23cf00081229176fd7efd80943905/src%2Flibcore%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fos.rs?ref=fbd8eae26de23cf00081229176fd7efd80943905", "patch": "@@ -942,7 +942,7 @@ pub fn errno() -> uint {\n \n     #[link_name = \"kernel32\"]\n     #[abi = \"stdcall\"]\n-    extern {\n+    extern \"stdcall\" {\n         unsafe fn GetLastError() -> DWORD;\n     }\n \n@@ -1004,7 +1004,7 @@ pub fn last_os_error() -> ~str {\n \n         #[link_name = \"kernel32\"]\n         #[abi = \"stdcall\"]\n-        extern {\n+        extern \"stdcall\" {\n             unsafe fn FormatMessageA(flags: DWORD, lpSrc: LPVOID,\n                                      msgId: DWORD, langId: DWORD,\n                                      buf: LPSTR, nsize: DWORD,\n@@ -1118,15 +1118,15 @@ type LPCWSTR = *u16;\n #[cfg(windows)]\n #[link_name=\"kernel32\"]\n #[abi=\"stdcall\"]\n-extern {\n+extern \"stdcall\" {\n     fn GetCommandLineW() -> LPCWSTR;\n     fn LocalFree(ptr: *c_void);\n }\n \n #[cfg(windows)]\n #[link_name=\"shell32\"]\n #[abi=\"stdcall\"]\n-extern {\n+extern \"stdcall\" {\n     fn CommandLineToArgvW(lpCmdLine: LPCWSTR, pNumArgs: *mut c_int) -> **u16;\n }\n "}, {"sha": "70bdb6f41d8baf54f65b078ed439898db145ee1f", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fbd8eae26de23cf00081229176fd7efd80943905/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd8eae26de23cf00081229176fd7efd80943905/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=fbd8eae26de23cf00081229176fd7efd80943905", "patch": "@@ -43,7 +43,7 @@ pub mod libc_ {\n \n pub mod rusti {\n     #[abi = \"rust-intrinsic\"]\n-    pub extern {\n+    pub extern \"rust-intrinsic\" {\n         fn addr_of<T>(&&val: T) -> *T;\n     }\n }"}, {"sha": "c8a9689bbc67a19f848a93f8f27826667ceaa6f7", "filename": "src/libcore/rt/thread_local_storage.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fbd8eae26de23cf00081229176fd7efd80943905/src%2Flibcore%2Frt%2Fthread_local_storage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd8eae26de23cf00081229176fd7efd80943905/src%2Flibcore%2Frt%2Fthread_local_storage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fthread_local_storage.rs?ref=fbd8eae26de23cf00081229176fd7efd80943905", "patch": "@@ -73,7 +73,7 @@ pub unsafe fn get(key: Key) -> *mut c_void {\n \n #[cfg(windows)]\n #[abi = \"stdcall\"]\n-extern {\n+extern \"stdcall\" {\n        fn TlsAlloc() -> DWORD;\n        fn TlsSetValue(dwTlsIndex: DWORD, lpTlsvalue: LPVOID) -> BOOL;\n        fn TlsGetValue(dwTlsIndex: DWORD) -> LPVOID;"}, {"sha": "99bbc93056bbbf9c8c1a71ec00322f50f411e728", "filename": "src/libcore/stackwalk.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fbd8eae26de23cf00081229176fd7efd80943905/src%2Flibcore%2Fstackwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd8eae26de23cf00081229176fd7efd80943905/src%2Flibcore%2Fstackwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstackwalk.rs?ref=fbd8eae26de23cf00081229176fd7efd80943905", "patch": "@@ -94,7 +94,7 @@ pub mod rustrt {\n \n pub mod rusti {\n     #[abi = \"rust-intrinsic\"]\n-    pub extern {\n+    pub extern \"rust-intrinsic\" {\n         pub fn frame_address(f: &once fn(x: *u8));\n     }\n }"}, {"sha": "52ca0204126769b95ec0f5a1ee8c1442fab10e9f", "filename": "src/libcore/sys.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fbd8eae26de23cf00081229176fd7efd80943905/src%2Flibcore%2Fsys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd8eae26de23cf00081229176fd7efd80943905/src%2Flibcore%2Fsys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsys.rs?ref=fbd8eae26de23cf00081229176fd7efd80943905", "patch": "@@ -39,7 +39,7 @@ pub struct Closure {\n \n pub mod rusti {\n     #[abi = \"rust-intrinsic\"]\n-    pub extern {\n+    pub extern \"rust-intrinsic\" {\n         fn get_tydesc<T>() -> *();\n         fn size_of<T>() -> uint;\n         fn pref_align_of<T>() -> uint;"}, {"sha": "ba96c6e5d3036df70b0f859496c207243c23384a", "filename": "src/libcore/unstable/intrinsics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fbd8eae26de23cf00081229176fd7efd80943905/src%2Flibcore%2Funstable%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd8eae26de23cf00081229176fd7efd80943905/src%2Flibcore%2Funstable%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable%2Fintrinsics.rs?ref=fbd8eae26de23cf00081229176fd7efd80943905", "patch": "@@ -15,7 +15,7 @@ The intrinsics are defined in librustc/middle/trans/foreign.rs.\n */\n \n #[abi = \"rust-intrinsic\"]\n-pub extern {\n+pub extern \"rust-intrinsic\" {\n     pub fn atomic_cxchg(dst: &mut int, old: int, src: int) -> int;\n     pub fn atomic_cxchg_acq(dst: &mut int, old: int, src: int) -> int;\n     pub fn atomic_cxchg_rel(dst: &mut int, old: int, src: int) -> int;"}, {"sha": "fae56aac38f3cd4cfb717b6acb7e3602751630c0", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fbd8eae26de23cf00081229176fd7efd80943905/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd8eae26de23cf00081229176fd7efd80943905/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=fbd8eae26de23cf00081229176fd7efd80943905", "patch": "@@ -97,7 +97,7 @@ pub mod jit {\n     pub mod rusti {\n         #[nolink]\n         #[abi = \"rust-intrinsic\"]\n-        pub extern {\n+        pub extern \"rust-intrinsic\" {\n             pub fn morestack_addr() -> *();\n         }\n     }"}, {"sha": "5d0ba4bb911f2bd233b2d3143f3132363b71212c", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 19, "deletions": 18, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/fbd8eae26de23cf00081229176fd7efd80943905/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd8eae26de23cf00081229176fd7efd80943905/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=fbd8eae26de23cf00081229176fd7efd80943905", "patch": "@@ -33,6 +33,7 @@ use std::getopts::groups::{optopt, optmulti, optflag, optflagopt, getopts};\n use std::getopts::{opt_present};\n use std::getopts;\n use syntax::ast;\n+use syntax::abi;\n use syntax::attr;\n use syntax::codemap;\n use syntax::diagnostic;\n@@ -85,10 +86,10 @@ pub fn default_configuration(sess: Session, +argv0: ~str, input: input) ->\n     // ARM is bi-endian, however using NDK seems to default\n     // to little-endian unless a flag is provided.\n     let (end,arch,wordsz) = match sess.targ_cfg.arch {\n-      session::arch_x86 => (~\"little\",~\"x86\",~\"32\"),\n-      session::arch_x86_64 => (~\"little\",~\"x86_64\",~\"64\"),\n-      session::arch_arm => (~\"little\",~\"arm\",~\"32\"),\n-      session::arch_mips => (~\"little\",~\"arm\",~\"32\")\n+        abi::X86 => (~\"little\",~\"x86\",~\"32\"),\n+        abi::X86_64 => (~\"little\",~\"x86_64\",~\"64\"),\n+        abi::Arm => (~\"little\",~\"arm\",~\"32\"),\n+        abi::Mips => (~\"little\",~\"arm\",~\"32\")\n     };\n \n     return ~[ // Target bindings.\n@@ -308,7 +309,7 @@ pub fn compile_rest(sess: Session, cfg: ast::crate_cfg,\n     };\n \n     // NOTE: Android hack\n-    if sess.targ_cfg.arch == session::arch_arm &&\n+    if sess.targ_cfg.arch == abi::Arm &&\n             (sess.opts.output_type == link::output_type_object ||\n              sess.opts.output_type == link::output_type_exe) {\n         let output_type = link::output_type_assembly;\n@@ -453,20 +454,20 @@ pub fn get_os(triple: &str) -> Option<session::os> {\n         } else { None }\n }\n \n-pub fn get_arch(triple: &str) -> Option<session::arch> {\n+pub fn get_arch(triple: &str) -> Option<abi::Architecture> {\n     if str::contains(triple, ~\"i386\") ||\n         str::contains(triple, ~\"i486\") ||\n                str::contains(triple, ~\"i586\") ||\n                str::contains(triple, ~\"i686\") ||\n                str::contains(triple, ~\"i786\") {\n-            Some(session::arch_x86)\n+            Some(abi::X86)\n         } else if str::contains(triple, ~\"x86_64\") {\n-            Some(session::arch_x86_64)\n+            Some(abi::X86_64)\n         } else if str::contains(triple, ~\"arm\") ||\n                       str::contains(triple, ~\"xscale\") {\n-            Some(session::arch_arm)\n+            Some(abi::Arm)\n         } else if str::contains(triple, ~\"mips\") {\n-            Some(session::arch_mips)\n+            Some(abi::Mips)\n         } else { None }\n }\n \n@@ -483,16 +484,16 @@ pub fn build_target_config(sopts: @session::options,\n                           ~\"unknown architecture: \" + sopts.target_triple)\n     };\n     let (int_type, uint_type, float_type) = match arch {\n-      session::arch_x86 => (ast::ty_i32, ast::ty_u32, ast::ty_f64),\n-      session::arch_x86_64 => (ast::ty_i64, ast::ty_u64, ast::ty_f64),\n-      session::arch_arm => (ast::ty_i32, ast::ty_u32, ast::ty_f64),\n-      session::arch_mips => (ast::ty_i32, ast::ty_u32, ast::ty_f64)\n+      abi::X86 => (ast::ty_i32, ast::ty_u32, ast::ty_f64),\n+      abi::X86_64 => (ast::ty_i64, ast::ty_u64, ast::ty_f64),\n+      abi::Arm => (ast::ty_i32, ast::ty_u32, ast::ty_f64),\n+      abi::Mips => (ast::ty_i32, ast::ty_u32, ast::ty_f64)\n     };\n     let target_strs = match arch {\n-      session::arch_x86 => x86::get_target_strs(os),\n-      session::arch_x86_64 => x86_64::get_target_strs(os),\n-      session::arch_arm => arm::get_target_strs(os),\n-      session::arch_mips => mips::get_target_strs(os)\n+      abi::X86 => x86::get_target_strs(os),\n+      abi::X86_64 => x86_64::get_target_strs(os),\n+      abi::Arm => arm::get_target_strs(os),\n+      abi::Mips => mips::get_target_strs(os)\n     };\n     let target_cfg = @session::config {\n         os: os,"}, {"sha": "95740e0f8375085138c41b3e46951cc1f4b29967", "filename": "src/librustc/driver/session.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fbd8eae26de23cf00081229176fd7efd80943905/src%2Flibrustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd8eae26de23cf00081229176fd7efd80943905/src%2Flibrustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fsession.rs?ref=fbd8eae26de23cf00081229176fd7efd80943905", "patch": "@@ -25,19 +25,17 @@ use syntax::codemap::span;\n use syntax::diagnostic;\n use syntax::parse::ParseSess;\n use syntax::{ast, codemap};\n+use syntax::abi;\n use syntax;\n \n #[deriving(Eq)]\n pub enum os { os_win32, os_macos, os_linux, os_android, os_freebsd, }\n \n-#[deriving(Eq)]\n-pub enum arch { arch_x86, arch_x86_64, arch_arm, arch_mips, }\n-\n pub enum crate_type { bin_crate, lib_crate, unknown_crate, }\n \n pub struct config {\n     os: os,\n-    arch: arch,\n+    arch: abi::Architecture,\n     target_strs: target_strs::t,\n     int_type: int_ty,\n     uint_type: uint_ty,"}, {"sha": "b92acb111e1637b18c56f1ea51c440d701ae6f6e", "filename": "src/librustc/front/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fbd8eae26de23cf00081229176fd7efd80943905/src%2Flibrustc%2Ffront%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd8eae26de23cf00081229176fd7efd80943905/src%2Flibrustc%2Ffront%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fconfig.rs?ref=fbd8eae26de23cf00081229176fd7efd80943905", "patch": "@@ -92,7 +92,7 @@ fn fold_foreign_mod(\n         nm.view_items.filter_mapped(|a| filter_view_item(cx, *a));\n     ast::foreign_mod {\n         sort: nm.sort,\n-        abi: nm.abi,\n+        abis: nm.abis,\n         view_items: vec::map(filtered_view_items, |x| fld.fold_view_item(*x)),\n         items: filtered_items\n     }"}, {"sha": "7d5177a6dfb5d8fa292509cfc9a4e2972850b4f3", "filename": "src/librustc/front/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fbd8eae26de23cf00081229176fd7efd80943905/src%2Flibrustc%2Ffront%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd8eae26de23cf00081229176fd7efd80943905/src%2Flibrustc%2Ffront%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fintrinsic.rs?ref=fbd8eae26de23cf00081229176fd7efd80943905", "patch": "@@ -126,7 +126,7 @@ pub mod intrinsic {\n         use super::{TyDesc, TyVisitor};\n \n         #[abi = \"rust-intrinsic\"]\n-        pub extern {\n+        pub extern \"rust-intrinsic\" {\n             pub fn get_tydesc<T>() -> *();\n             pub fn visit_tydesc(++td: *TyDesc, &&tv: @TyVisitor);\n         }"}, {"sha": "dbedeeaa5cc80b0f665936aaee6418b5a7a818f2", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fbd8eae26de23cf00081229176fd7efd80943905/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd8eae26de23cf00081229176fd7efd80943905/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=fbd8eae26de23cf00081229176fd7efd80943905", "patch": "@@ -146,7 +146,7 @@ fn fold_item(cx: @mut TestCtxt, &&i: @ast::item, fld: @fold::ast_fold)\n \n     if is_test_fn(i) || is_bench_fn(i) {\n         match i.node {\n-          ast::item_fn(_, purity, _, _) if purity == ast::unsafe_fn => {\n+          ast::item_fn(_, purity, _, _, _) if purity == ast::unsafe_fn => {\n             let sess = cx.sess;\n             sess.span_fatal(\n                 i.span,\n@@ -178,7 +178,7 @@ fn is_test_fn(i: @ast::item) -> bool {\n \n     fn has_test_signature(i: @ast::item) -> bool {\n         match &i.node {\n-          &ast::item_fn(ref decl, _, ref generics, _) => {\n+          &ast::item_fn(ref decl, _, _, ref generics, _) => {\n             let no_output = match decl.output.node {\n                 ast::ty_nil => true,\n                 _ => false\n@@ -200,7 +200,7 @@ fn is_bench_fn(i: @ast::item) -> bool {\n \n     fn has_test_signature(i: @ast::item) -> bool {\n         match i.node {\n-            ast::item_fn(ref decl, _, ref generics, _) => {\n+            ast::item_fn(ref decl, _, _, ref generics, _) => {\n                 let input_cnt = vec::len(decl.inputs);\n                 let no_output = match decl.output.node {\n                     ast::ty_nil => true,"}, {"sha": "5e2ba4156bd8d40c2d6712001ad75ca5e10822b3", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fbd8eae26de23cf00081229176fd7efd80943905/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd8eae26de23cf00081229176fd7efd80943905/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=fbd8eae26de23cf00081229176fd7efd80943905", "patch": "@@ -156,12 +156,8 @@ fn visit_view_item(e: @mut Env, i: @ast::view_item) {\n fn visit_item(e: @mut Env, i: @ast::item) {\n     match i.node {\n       ast::item_foreign_mod(ref fm) => {\n-        match attr::foreign_abi(i.attrs) {\n-          either::Right(abi) => {\n-            if abi != ast::foreign_abi_cdecl &&\n-               abi != ast::foreign_abi_stdcall { return; }\n-          }\n-          either::Left(ref msg) => e.diag.span_fatal(i.span, (*msg))\n+        if fm.abis.is_rust() || fm.abis.is_intrinsic() {\n+            return;\n         }\n \n         let cstore = e.cstore;"}, {"sha": "340ad443b5888845f369655c95a51791043a648a", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fbd8eae26de23cf00081229176fd7efd80943905/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd8eae26de23cf00081229176fd7efd80943905/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=fbd8eae26de23cf00081229176fd7efd80943905", "patch": "@@ -35,6 +35,7 @@ use core::uint;\n use core::vec;\n use std::serialize::Encodable;\n use std;\n+use syntax::abi::AbiSet;\n use syntax::ast::*;\n use syntax::ast;\n use syntax::ast_map;\n@@ -653,7 +654,7 @@ fn encode_info_for_item(ecx: @EncodeContext, ebml_w: writer::Encoder,\n         (ecx.encode_inlined_item)(ecx, ebml_w, path, ii_item(item));\n         ebml_w.end_tag();\n       }\n-      item_fn(_, purity, ref generics, _) => {\n+      item_fn(_, purity, _, ref generics, _) => {\n         add_to_index();\n         ebml_w.start_tag(tag_items_data_item);\n         encode_def_id(ebml_w, local_def(item.id));\n@@ -979,7 +980,7 @@ fn encode_info_for_foreign_item(ecx: @EncodeContext,\n                                 nitem: @foreign_item,\n                                 index: @mut ~[entry<int>],\n                                 +path: ast_map::path,\n-                                abi: foreign_abi) {\n+                                abi: AbiSet) {\n     if !reachable(ecx, nitem.id) { return; }\n     index.push(entry { val: nitem.id, pos: ebml_w.writer.tell() });\n \n@@ -990,7 +991,7 @@ fn encode_info_for_foreign_item(ecx: @EncodeContext,\n         encode_family(ebml_w, purity_fn_family(purity));\n         encode_type_param_bounds(ebml_w, ecx, &generics.ty_params);\n         encode_type(ecx, ebml_w, node_id_to_type(ecx.tcx, nitem.id));\n-        if abi == foreign_abi_rust_intrinsic {\n+        if abi.is_intrinsic() {\n             (ecx.encode_inlined_item)(ecx, ebml_w, path, ii_foreign(nitem));\n         } else {\n             encode_symbol(ecx, ebml_w, nitem.id);"}, {"sha": "111bc307ed3081be1f7ba108f7179b19cc0b8db1", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 29, "deletions": 10, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/fbd8eae26de23cf00081229176fd7efd80943905/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd8eae26de23cf00081229176fd7efd80943905/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=fbd8eae26de23cf00081229176fd7efd80943905", "patch": "@@ -21,6 +21,8 @@ use middle::ty;\n use core::str;\n use core::uint;\n use core::vec;\n+use syntax::abi::AbiSet;\n+use syntax::abi;\n use syntax::ast;\n use syntax::ast::*;\n use syntax::codemap::dummy_sp;\n@@ -76,17 +78,28 @@ fn next_byte(st: @mut PState) -> u8 {\n     return b;\n }\n \n+fn scan<R>(st: &mut PState, is_last: &fn(char) -> bool,\n+           op: &fn(&[u8]) -> R) -> R\n+{\n+    let start_pos = st.pos;\n+    debug!(\"scan: '%c' (start)\", st.data[st.pos] as char);\n+    while !is_last(st.data[st.pos] as char) {\n+        st.pos += 1;\n+        debug!(\"scan: '%c'\", st.data[st.pos] as char);\n+    }\n+    let end_pos = st.pos;\n+    st.pos += 1;\n+    return op(st.data.slice(start_pos, end_pos));\n+}\n+\n pub fn parse_ident(st: @mut PState, last: char) -> ast::ident {\n     fn is_last(b: char, c: char) -> bool { return c == b; }\n     return parse_ident_(st, |a| is_last(last, a) );\n }\n \n fn parse_ident_(st: @mut PState, is_last: @fn(char) -> bool) ->\n    ast::ident {\n-    let mut rslt = ~\"\";\n-    while !is_last(peek(st)) {\n-        rslt += str::from_byte(next_byte(st));\n-    }\n+    let rslt = scan(st, is_last, str::from_bytes);\n     return st.tcx.sess.ident_of(rslt);\n }\n \n@@ -417,11 +430,17 @@ fn parse_purity(c: char) -> purity {\n     }\n }\n \n-fn parse_abi(c: char) -> Abi {\n-    match c {\n-      'r' => ast::RustAbi,\n-      _ => fail!(fmt!(\"parse_abi: bad ABI '%c'\", c))\n+fn parse_abi_set(st: @mut PState) -> AbiSet {\n+    assert!(next(st) == '[');\n+    let mut abis = AbiSet::empty();\n+    while peek(st) != ']' {\n+        // FIXME(#5422) str API should not force this copy\n+        let abi_str = scan(st, |c| c == ',', str::from_bytes);\n+        let abi = abi::lookup(abi_str).expect(abi_str);\n+        abis.add(abi);\n     }\n+    assert!(next(st) == ']');\n+    return abis;\n }\n \n fn parse_onceness(c: char) -> ast::Onceness {\n@@ -462,11 +481,11 @@ fn parse_closure_ty(st: @mut PState, conv: conv_did) -> ty::ClosureTy {\n \n fn parse_bare_fn_ty(st: @mut PState, conv: conv_did) -> ty::BareFnTy {\n     let purity = parse_purity(next(st));\n-    let abi = parse_abi(next(st));\n+    let abi = parse_abi_set(st);\n     let sig = parse_sig(st, conv);\n     ty::BareFnTy {\n         purity: purity,\n-        abi: abi,\n+        abis: abi,\n         sig: sig\n     }\n }"}, {"sha": "9b777332c27c318b09c93e91e0eb76925b6dfe72", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fbd8eae26de23cf00081229176fd7efd80943905/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd8eae26de23cf00081229176fd7efd80943905/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=fbd8eae26de23cf00081229176fd7efd80943905", "patch": "@@ -21,6 +21,7 @@ use core::io::WriterUtil;\n use core::io;\n use core::uint;\n use core::vec;\n+use syntax::abi::AbiSet;\n use syntax::ast::*;\n use syntax::diagnostic::span_handler;\n use syntax::print::pprust::*;\n@@ -367,10 +368,13 @@ fn enc_purity(w: @io::Writer, p: purity) {\n     }\n }\n \n-fn enc_abi(w: @io::Writer, a: Abi) {\n-    match a {\n-        RustAbi => w.write_char('r'),\n+fn enc_abi_set(w: @io::Writer, abis: AbiSet) {\n+    w.write_char('[');\n+    for abis.each |abi| {\n+        w.write_str(abi.name());\n+        w.write_char(',');\n     }\n+    w.write_char(']')\n }\n \n fn enc_onceness(w: @io::Writer, o: Onceness) {\n@@ -382,7 +386,7 @@ fn enc_onceness(w: @io::Writer, o: Onceness) {\n \n fn enc_bare_fn_ty(w: @io::Writer, cx: @ctxt, ft: &ty::BareFnTy) {\n     enc_purity(w, ft.purity);\n-    enc_abi(w, ft.abi);\n+    enc_abi_set(w, ft.abis);\n     enc_fn_sig(w, cx, &ft.sig);\n }\n "}, {"sha": "64c6c3391797a5518f2a01bc51e414644e96d414", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fbd8eae26de23cf00081229176fd7efd80943905/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd8eae26de23cf00081229176fd7efd80943905/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=fbd8eae26de23cf00081229176fd7efd80943905", "patch": "@@ -762,9 +762,7 @@ fn check_item_ctypes(cx: ty::ctxt, it: @ast::item) {\n     }\n \n     match it.node {\n-      ast::item_foreign_mod(ref nmod)\n-      if attr::foreign_abi(it.attrs) !=\n-            either::Right(ast::foreign_abi_rust_intrinsic) => {\n+      ast::item_foreign_mod(ref nmod) if !nmod.abis.is_intrinsic() => {\n         for nmod.items.each |ni| {\n             match ni.node {\n               ast::foreign_item_fn(ref decl, _, _) => {"}, {"sha": "5bad8d1d6ca097f0d0250e1efa9e519d3d95d752", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fbd8eae26de23cf00081229176fd7efd80943905/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd8eae26de23cf00081229176fd7efd80943905/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=fbd8eae26de23cf00081229176fd7efd80943905", "patch": "@@ -1139,7 +1139,7 @@ pub impl Resolver {\n                 name_bindings.define_value\n                     (privacy, def_const(local_def(item.id)), sp);\n             }\n-            item_fn(_, purity, _, _) => {\n+            item_fn(_, purity, _, _, _) => {\n               let (name_bindings, new_parent) =\n                 self.add_child(ident, parent, ForbidDuplicateValues, sp);\n \n@@ -3530,7 +3530,7 @@ pub impl Resolver {\n                 }\n             }\n \n-            item_fn(ref fn_decl, _, ref generics, ref block) => {\n+            item_fn(ref fn_decl, _, _, ref generics, ref block) => {\n                 // If this is the main function, we must record it in the\n                 // session.\n                 // FIXME #4404 android JNI hacks"}, {"sha": "0947dfa93fee2525d764d67d992515ceb0fbe32b", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 12, "deletions": 15, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/fbd8eae26de23cf00081229176fd7efd80943905/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd8eae26de23cf00081229176fd7efd80943905/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=fbd8eae26de23cf00081229176fd7efd80943905", "patch": "@@ -82,6 +82,7 @@ use syntax::parse::token::special_idents;\n use syntax::print::pprust::stmt_to_str;\n use syntax::visit;\n use syntax::{ast, ast_util, codemap, ast_map};\n+use syntax::abi::{X86, X86_64, Arm, Mips};\n \n pub struct icx_popper {\n     ccx: @CrateContext,\n@@ -1455,10 +1456,12 @@ pub fn call_memcpy(cx: block, dst: ValueRef, src: ValueRef,\n     let _icx = cx.insn_ctxt(\"call_memcpy\");\n     let ccx = cx.ccx();\n     let key = match ccx.sess.targ_cfg.arch {\n-      session::arch_x86\n-      | session::arch_arm\n-      | session::arch_mips => ~\"llvm.memcpy.p0i8.p0i8.i32\",\n-      session::arch_x86_64 => ~\"llvm.memcpy.p0i8.p0i8.i64\"\n+        X86 | Arm | Mips => {\n+            ~\"llvm.memcpy.p0i8.p0i8.i32\"\n+        }\n+        X86_64 => {\n+            ~\"llvm.memcpy.p0i8.p0i8.i64\"\n+        }\n     };\n     let memcpy = *ccx.intrinsics.get(&key);\n     let src_ptr = PointerCast(cx, src, T_ptr(T_i8()));\n@@ -1499,12 +1502,10 @@ pub fn memzero(cx: block, llptr: ValueRef, llty: TypeRef) {\n \n     let intrinsic_key;\n     match ccx.sess.targ_cfg.arch {\n-        session::arch_x86\n-        | session::arch_arm\n-        | session::arch_mips => {\n+        X86 | Arm | Mips => {\n             intrinsic_key = ~\"llvm.memset.p0i8.i32\";\n         }\n-        session::arch_x86_64 => {\n+        X86_64 => {\n             intrinsic_key = ~\"llvm.memset.p0i8.i64\";\n         }\n     }\n@@ -2063,7 +2064,7 @@ pub fn trans_item(ccx: @CrateContext, item: ast::item) {\n         _ => fail!(~\"trans_item\"),\n     };\n     match item.node {\n-      ast::item_fn(ref decl, purity, ref generics, ref body) => {\n+      ast::item_fn(ref decl, purity, _abis, ref generics, ref body) => {\n         if purity == ast::extern_fn  {\n             let llfndecl = get_item_val(ccx, item.id);\n             foreign::trans_foreign_fn(ccx,\n@@ -2105,11 +2106,7 @@ pub fn trans_item(ccx: @CrateContext, item: ast::item) {\n       }\n       ast::item_const(_, expr) => consts::trans_const(ccx, expr, item.id),\n       ast::item_foreign_mod(ref foreign_mod) => {\n-        let abi = match attr::foreign_abi(item.attrs) {\n-            Right(abi_) => abi_,\n-            Left(msg) => ccx.sess.span_fatal(item.span, msg)\n-        };\n-        foreign::trans_foreign_mod(ccx, foreign_mod, abi);\n+        foreign::trans_foreign_mod(ccx, path, foreign_mod);\n       }\n       ast::item_struct(struct_def, ref generics) => {\n         if !generics.is_type_parameterized() {\n@@ -2405,7 +2402,7 @@ pub fn get_item_val(ccx: @CrateContext, id: ast::node_id) -> ValueRef {\n                     g\n                 }\n               }\n-              ast::item_fn(_, purity, _, _) => {\n+              ast::item_fn(_, purity, _, _, _) => {\n                 let llfn = if purity != ast::extern_fn {\n                     register_fn(ccx, i.span, my_path, i.id, i.attrs)\n                 } else {"}, {"sha": "ec67c68f93cda5a4a93bba0571d58e0cc2d46dd4", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fbd8eae26de23cf00081229176fd7efd80943905/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd8eae26de23cf00081229176fd7efd80943905/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=fbd8eae26de23cf00081229176fd7efd80943905", "patch": "@@ -269,11 +269,8 @@ pub fn trans_fn_ref_with_vtables(\n             || fmt!(\"local item should be in ast map\"));\n \n         match *map_node {\n-            ast_map::node_foreign_item(_,\n-                                       ast::foreign_abi_rust_intrinsic,\n-                                       _,\n-                                       _) => {\n-                must_monomorphise = true;\n+            ast_map::node_foreign_item(_, abis, _, _) => {\n+                must_monomorphise = abis.is_intrinsic()\n             }\n             _ => {\n                 must_monomorphise = false;"}, {"sha": "6bb30a5d5b51b1e50f16601842fcd8625306b362", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/fbd8eae26de23cf00081229176fd7efd80943905/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd8eae26de23cf00081229176fd7efd80943905/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=fbd8eae26de23cf00081229176fd7efd80943905", "patch": "@@ -57,6 +57,7 @@ use syntax::ast_map::{path, path_elt};\n use syntax::codemap::span;\n use syntax::parse::token::ident_interner;\n use syntax::{ast, ast_map};\n+use syntax::abi::{X86, X86_64, Arm, Mips};\n \n pub type namegen = @fn(+s: ~str) -> ident;\n pub fn new_namegen(intr: @ident_interner) -> namegen {\n@@ -777,10 +778,10 @@ pub fn T_bool() -> TypeRef { return T_i8(); }\n \n pub fn T_int(targ_cfg: @session::config) -> TypeRef {\n     return match targ_cfg.arch {\n-      session::arch_x86 => T_i32(),\n-      session::arch_x86_64 => T_i64(),\n-      session::arch_arm => T_i32(),\n-      session::arch_mips => T_i32()\n+        X86 => T_i32(),\n+        X86_64 => T_i64(),\n+        Arm => T_i32(),\n+        Mips => T_i32()\n     };\n }\n \n@@ -815,10 +816,10 @@ pub fn T_float_ty(cx: @CrateContext, t: ast::float_ty) -> TypeRef {\n \n pub fn T_float(targ_cfg: @session::config) -> TypeRef {\n     return match targ_cfg.arch {\n-      session::arch_x86 => T_f64(),\n-      session::arch_x86_64 => T_f64(),\n-      session::arch_arm => T_f64(),\n-      session::arch_mips => T_f64()\n+        X86 => T_f64(),\n+        X86_64 => T_f64(),\n+        Arm => T_f64(),\n+        Mips => T_f64()\n     };\n }\n "}, {"sha": "d290a8ffa5c940b6041d8aabe4b2ada716f6468e", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fbd8eae26de23cf00081229176fd7efd80943905/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd8eae26de23cf00081229176fd7efd80943905/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=fbd8eae26de23cf00081229176fd7efd80943905", "patch": "@@ -852,7 +852,7 @@ pub fn create_function(fcx: fn_ctxt) -> @Metadata<SubProgramMetadata> {\n     let (ident, ret_ty, id) = match *cx.tcx.items.get(&fcx.id) {\n       ast_map::node_item(item, _) => {\n         match item.node {\n-          ast::item_fn(ref decl, _, _, _) => {\n+          ast::item_fn(ref decl, _, _, _, _) => {\n             (item.ident, decl.output, item.id)\n           }\n           _ => fcx.ccx.sess.span_bug(item.span, ~\"create_function: item \\"}, {"sha": "6a040e81186ffb971bbd39adc770f2eac09a51fb", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 77, "deletions": 46, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/fbd8eae26de23cf00081229176fd7efd80943905/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd8eae26de23cf00081229176fd7efd80943905/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=fbd8eae26de23cf00081229176fd7efd80943905", "patch": "@@ -12,9 +12,6 @@ use core::prelude::*;\n \n use back::{link, abi};\n use driver::session;\n-use driver::session::arch_x86_64;\n-use driver::session::arch_arm;\n-use driver::session::arch_mips;\n use lib::llvm::{SequentiallyConsistent, Acquire, Release, Xchg};\n use lib::llvm::{TypeRef, ValueRef};\n use lib;\n@@ -42,13 +39,16 @@ use syntax::{ast, ast_util};\n use syntax::{attr, ast_map};\n use syntax::opt_vec;\n use syntax::parse::token::special_idents;\n+use syntax::abi::{Architecture, X86, X86_64, Arm, Mips};\n+use syntax::abi::{RustIntrinsic, Rust, Stdcall, Fastcall,\n+                  Cdecl, Aapcs, C};\n \n-fn abi_info(arch: session::arch) -> @cabi::ABIInfo {\n+fn abi_info(arch: Architecture) -> @cabi::ABIInfo {\n     return match arch {\n-        arch_x86_64 => x86_64_abi_info(),\n-        arch_arm => cabi_arm::abi_info(),\n-        arch_mips => mips_abi_info(),\n-        _ => cabi::llvm_abi_info()\n+        X86_64 => x86_64_abi_info(),\n+        Arm => cabi_arm::abi_info(),\n+        Mips => mips_abi_info(),\n+        X86 => cabi::llvm_abi_info()\n     }\n }\n \n@@ -239,36 +239,65 @@ fn build_wrap_fn_(ccx: @CrateContext,\n // unnecessary). We used to do this, in fact, and will perhaps do so\n // in the future.\n pub fn trans_foreign_mod(ccx: @CrateContext,\n-                         foreign_mod: &ast::foreign_mod,\n-                         abi: ast::foreign_abi)\n+                         path: &ast_map::path,\n+                         foreign_mod: &ast::foreign_mod)\n {\n     let _icx = ccx.insn_ctxt(\"foreign::trans_foreign_mod\");\n \n-    let mut cc = match abi {\n-        ast::foreign_abi_rust_intrinsic |\n-        ast::foreign_abi_cdecl => lib::llvm::CCallConv,\n-        ast::foreign_abi_stdcall => lib::llvm::X86StdcallCallConv\n+    let arch = ccx.sess.targ_cfg.arch;\n+    let abi = match foreign_mod.abis.for_arch(arch) {\n+        None => {\n+            ccx.sess.fatal(\n+                fmt!(\"No suitable ABI for target architecture \\\n+                      in module %s\",\n+                     ast_map::path_to_str(*path,\n+                                          ccx.sess.intr())));\n+        }\n+\n+        Some(abi) => abi,\n     };\n \n-    for vec::each(foreign_mod.items) |foreign_item| {\n+    for vec::each(foreign_mod.items) |&foreign_item| {\n         match foreign_item.node {\n             ast::foreign_item_fn(*) => {\n                 let id = foreign_item.id;\n-                if abi != ast::foreign_abi_rust_intrinsic {\n-                    let llwrapfn = get_item_val(ccx, id);\n-                    let tys = shim_types(ccx, id);\n-                    if attr::attrs_contains_name(\n-                        foreign_item.attrs, \"rust_stack\")\n-                    {\n-                        build_direct_fn(ccx, llwrapfn, *foreign_item,\n-                                        &tys, cc);\n-                    } else {\n-                        let llshimfn = build_shim_fn(ccx, *foreign_item,\n-                                                     &tys, cc);\n-                        build_wrap_fn(ccx, &tys, llshimfn, llwrapfn);\n+                match abi {\n+                    RustIntrinsic => {\n+                        // Intrinsics are emitted by monomorphic fn\n+                    }\n+\n+                    Rust => {\n+                        // FIXME(#3678) Implement linking to foreign fns with Rust ABI\n+                        ccx.sess.unimpl(\n+                            fmt!(\"Foreign functions with Rust ABI\"));\n+                    }\n+\n+                    Stdcall => {\n+                        build_foreign_fn(ccx, id, foreign_item,\n+                                         lib::llvm::X86StdcallCallConv);\n+                    }\n+\n+                    Fastcall => {\n+                        build_foreign_fn(ccx, id, foreign_item,\n+                                         lib::llvm::X86FastcallCallConv);\n+                    }\n+\n+                    Cdecl => {\n+                        // FIXME(#3678) should really be more specific\n+                        build_foreign_fn(ccx, id, foreign_item,\n+                                         lib::llvm::CCallConv);\n+                    }\n+\n+                    Aapcs => {\n+                        // FIXME(#3678) should really be more specific\n+                        build_foreign_fn(ccx, id, foreign_item,\n+                                         lib::llvm::CCallConv);\n+                    }\n+\n+                    C => {\n+                        build_foreign_fn(ccx, id, foreign_item,\n+                                         lib::llvm::CCallConv);\n                     }\n-                } else {\n-                    // Intrinsics are emitted by monomorphic fn\n                 }\n             }\n             ast::foreign_item_const(*) => {\n@@ -279,6 +308,25 @@ pub fn trans_foreign_mod(ccx: @CrateContext,\n         }\n     }\n \n+    fn build_foreign_fn(ccx: @CrateContext,\n+                        id: ast::node_id,\n+                        foreign_item: @ast::foreign_item,\n+                        cc: lib::llvm::CallConv)\n+    {\n+        let llwrapfn = get_item_val(ccx, id);\n+        let tys = shim_types(ccx, id);\n+        if attr::attrs_contains_name(\n+            foreign_item.attrs, \"rust_stack\")\n+        {\n+            build_direct_fn(ccx, llwrapfn, foreign_item,\n+                            &tys, cc);\n+        } else {\n+            let llshimfn = build_shim_fn(ccx, foreign_item,\n+                                         &tys, cc);\n+            build_wrap_fn(ccx, &tys, llshimfn, llwrapfn);\n+        }\n+    }\n+\n     fn build_shim_fn(ccx: @CrateContext,\n                      foreign_item: @ast::foreign_item,\n                      tys: &ShimTypes,\n@@ -1080,20 +1128,3 @@ pub fn register_foreign_fn(ccx: @CrateContext,\n                            t, lib::llvm::CCallConv, fnty)\n     }\n }\n-\n-fn abi_of_foreign_fn(ccx: @CrateContext, i: @ast::foreign_item)\n-    -> ast::foreign_abi {\n-    match attr::first_attr_value_str_by_name(i.attrs, ~\"abi\") {\n-      None => match *ccx.tcx.items.get(&i.id) {\n-        ast_map::node_foreign_item(_, abi, _, _) => abi,\n-        // ??\n-        _ => fail!(~\"abi_of_foreign_fn: not foreign\")\n-      },\n-      Some(_) => match attr::foreign_abi(i.attrs) {\n-        either::Right(abi) => abi,\n-        either::Left(ref msg) => {\n-            ccx.sess.span_fatal(i.span, (/*bad*/copy *msg))\n-        }\n-      }\n-    }\n-}"}, {"sha": "89617ac5eb8c35a15486eb43e73811db382c5883", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fbd8eae26de23cf00081229176fd7efd80943905/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd8eae26de23cf00081229176fd7efd80943905/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=fbd8eae26de23cf00081229176fd7efd80943905", "patch": "@@ -39,6 +39,7 @@ use syntax::ast_map::path_name;\n use syntax::ast_util::local_def;\n use syntax::opt_vec;\n use syntax::parse::token::special_idents;\n+use syntax::abi::AbiSet;\n \n pub fn monomorphic_fn(ccx: @CrateContext,\n                       fn_id: ast::def_id,\n@@ -97,7 +98,7 @@ pub fn monomorphic_fn(ccx: @CrateContext,\n       ast_map::node_item(i, pt) => (pt, i.ident, i.span),\n       ast_map::node_variant(ref v, enm, pt) => (pt, (*v).node.name, enm.span),\n       ast_map::node_method(m, _, pt) => (pt, m.ident, m.span),\n-      ast_map::node_foreign_item(i, ast::foreign_abi_rust_intrinsic, _, pt)\n+      ast_map::node_foreign_item(i, abis, _, pt) if abis.is_intrinsic()\n       => (pt, i.ident, i.span),\n       ast_map::node_foreign_item(*) => {\n         // Foreign externs don't have to be monomorphized.\n@@ -174,8 +175,7 @@ pub fn monomorphic_fn(ccx: @CrateContext,\n \n     let lldecl = match *map_node {\n       ast_map::node_item(i@@ast::item {\n-                // XXX: Bad copy.\n-                node: ast::item_fn(ref decl, _, _, ref body),\n+                node: ast::item_fn(ref decl, _, _, _, ref body),\n                 _\n             }, _) => {\n         let d = mk_lldecl();\n@@ -280,7 +280,7 @@ pub fn normalize_for_monomorphization(tcx: ty::ctxt,\n                 tcx,\n                 ty::BareFnTy {\n                     purity: ast::impure_fn,\n-                    abi: ast::RustAbi,\n+                    abis: AbiSet::Rust(),\n                     sig: FnSig {bound_lifetime_names: opt_vec::Empty,\n                                 inputs: ~[],\n                                 output: ty::mk_nil(tcx)}}))"}, {"sha": "8824e0b7829090e7841f55c1fdeeef39fc8764cc", "filename": "src/librustc/middle/trans/reachable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fbd8eae26de23cf00081229176fd7efd80943905/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd8eae26de23cf00081229176fd7efd80943905/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs?ref=fbd8eae26de23cf00081229176fd7efd80943905", "patch": "@@ -108,7 +108,7 @@ fn traverse_public_item(cx: ctx, item: @item) {\n               }\n           }\n       }\n-      item_fn(_, _, ref generics, ref blk) => {\n+      item_fn(_, _, _, ref generics, ref blk) => {\n         if generics.ty_params.len() > 0u ||\n            attr::find_inline_attr(item.attrs) != attr::ia_none {\n             traverse_inline_body(cx, blk);"}, {"sha": "572e9348f63f05c40687608a7109fe35cadfc2d6", "filename": "src/librustc/middle/trans/type_use.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fbd8eae26de23cf00081229176fd7efd80943905/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd8eae26de23cf00081229176fd7efd80943905/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=fbd8eae26de23cf00081229176fd7efd80943905", "patch": "@@ -102,7 +102,7 @@ pub fn type_uses_for(ccx: @CrateContext, fn_id: def_id, n_tps: uint)\n                                      fn_id_loc))\n     };\n     match map_node {\n-      ast_map::node_item(@ast::item { node: item_fn(_, _, _, ref body),\n+      ast_map::node_item(@ast::item { node: item_fn(_, _, _, _, ref body),\n                                       _ }, _) |\n       ast_map::node_method(@ast::method {body: ref body, _}, _, _) => {\n         handle_body(cx, body);\n@@ -121,7 +121,7 @@ pub fn type_uses_for(ccx: @CrateContext, fn_id: def_id, n_tps: uint)\n                                  abi,\n                                  _,\n                                  _) => {\n-        if abi == foreign_abi_rust_intrinsic {\n+        if abi.is_intrinsic() {\n             let flags = match *cx.ccx.sess.str_of(i.ident) {\n                 ~\"size_of\"  | ~\"pref_align_of\"    | ~\"min_align_of\" |\n                 ~\"init\"     | ~\"reinterpret_cast\" |"}, {"sha": "fddcce523f4470e6e652c1a481993ebfc9d111e8", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fbd8eae26de23cf00081229176fd7efd80943905/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd8eae26de23cf00081229176fd7efd80943905/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=fbd8eae26de23cf00081229176fd7efd80943905", "patch": "@@ -47,6 +47,7 @@ use syntax::print::pprust;\n use syntax::{ast, ast_map};\n use syntax::opt_vec::OptVec;\n use syntax::opt_vec;\n+use syntax::abi::AbiSet;\n use syntax;\n \n // Data types\n@@ -349,7 +350,7 @@ pub fn type_id(t: t) -> uint { get(t).id }\n #[deriving(Eq)]\n pub struct BareFnTy {\n     purity: ast::purity,\n-    abi: Abi,\n+    abis: AbiSet,\n     sig: FnSig\n }\n \n@@ -378,7 +379,7 @@ pub struct FnSig {\n \n impl to_bytes::IterBytes for BareFnTy {\n     fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n-        to_bytes::iter_bytes_3(&self.purity, &self.abi, &self.sig, lsb0, f)\n+        to_bytes::iter_bytes_3(&self.purity, &self.abis, &self.sig, lsb0, f)\n     }\n }\n \n@@ -546,7 +547,7 @@ pub enum type_err {\n     terr_mismatch,\n     terr_purity_mismatch(expected_found<purity>),\n     terr_onceness_mismatch(expected_found<Onceness>),\n-    terr_abi_mismatch(expected_found<ast::Abi>),\n+    terr_abi_mismatch(expected_found<AbiSet>),\n     terr_mutability,\n     terr_sigil_mismatch(expected_found<ast::Sigil>),\n     terr_box_mutability,\n@@ -1056,7 +1057,7 @@ pub fn mk_ctor_fn(cx: ctxt, input_tys: &[ty::t], output: ty::t) -> t {\n     mk_bare_fn(cx,\n                BareFnTy {\n                    purity: ast::pure_fn,\n-                   abi: ast::RustAbi,\n+                   abis: AbiSet::Rust(),\n                    sig: FnSig {bound_lifetime_names: opt_vec::Empty,\n                                inputs: input_args,\n                                output: output}})\n@@ -1240,7 +1241,7 @@ fn fold_sty(sty: &sty, fldop: &fn(t) -> t) -> sty {\n         }\n         ty_bare_fn(ref f) => {\n             let sig = fold_sig(&f.sig, fldop);\n-            ty_bare_fn(BareFnTy {sig: sig, abi: f.abi, purity: f.purity})\n+            ty_bare_fn(BareFnTy {sig: sig, abis: f.abis, purity: f.purity})\n         }\n         ty_closure(ref f) => {\n             let sig = fold_sig(&f.sig, fldop);"}, {"sha": "4b4cb8572529cd8cfccdac86bc3039c13cb074a7", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fbd8eae26de23cf00081229176fd7efd80943905/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd8eae26de23cf00081229176fd7efd80943905/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=fbd8eae26de23cf00081229176fd7efd80943905", "patch": "@@ -64,6 +64,7 @@ use middle::typeck::rscope::RegionParamNames;\n \n use core::result;\n use core::vec;\n+use syntax::abi::AbiSet;\n use syntax::{ast, ast_util};\n use syntax::codemap::span;\n use syntax::opt_vec::OptVec;\n@@ -348,7 +349,7 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:region_scope + Copy + Durable>(\n       }\n       ast::ty_bare_fn(ref bf) => {\n           ty::mk_bare_fn(tcx, ty_of_bare_fn(self, rscope, bf.purity,\n-                                            bf.abi, &bf.lifetimes, &bf.decl))\n+                                            bf.abis, &bf.lifetimes, &bf.decl))\n       }\n       ast::ty_closure(ref f) => {\n           let fn_decl = ty_of_closure(self,\n@@ -543,7 +544,7 @@ pub fn ty_of_bare_fn<AC:AstConv,RS:region_scope + Copy + Durable>(\n     self: &AC,\n     rscope: &RS,\n     purity: ast::purity,\n-    abi: ast::Abi,\n+    abi: AbiSet,\n     lifetimes: &OptVec<ast::Lifetime>,\n     decl: &ast::fn_decl) -> ty::BareFnTy\n {\n@@ -562,7 +563,7 @@ pub fn ty_of_bare_fn<AC:AstConv,RS:region_scope + Copy + Durable>(\n \n     ty::BareFnTy {\n         purity: purity,\n-        abi: abi,\n+        abis: abi,\n         sig: ty::FnSig {bound_lifetime_names: bound_lifetime_names,\n                         inputs: input_tys,\n                         output: output_ty}"}, {"sha": "41877017685d6b2c3075ec70542a08f0485b6d21", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 18, "deletions": 5, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/fbd8eae26de23cf00081229176fd7efd80943905/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd8eae26de23cf00081229176fd7efd80943905/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=fbd8eae26de23cf00081229176fd7efd80943905", "patch": "@@ -118,7 +118,8 @@ use core::result;\n use core::str;\n use core::vec;\n use std::list::Nil;\n-use syntax::ast::{provided, required};\n+use syntax::abi::AbiSet;\n+use syntax::ast::{provided, required, ty_i};\n use syntax::ast;\n use syntax::ast_map;\n use syntax::ast_util::local_def;\n@@ -567,7 +568,7 @@ pub fn check_item(ccx: @mut CrateCtxt, it: @ast::item) {\n                             enum_definition.variants,\n                             it.id);\n       }\n-      ast::item_fn(ref decl, _, _, ref body) => {\n+      ast::item_fn(ref decl, _, _, _, ref body) => {\n         check_bare_fn(ccx, decl, body, it.id, None);\n       }\n       ast::item_impl(ref generics, _, ty, ref ms) => {\n@@ -603,8 +604,7 @@ pub fn check_item(ccx: @mut CrateCtxt, it: @ast::item) {\n         check_bounds_are_used(ccx, t.span, &generics.ty_params, tpt_ty);\n       }\n       ast::item_foreign_mod(ref m) => {\n-        if syntax::attr::foreign_abi(it.attrs) ==\n-            either::Right(ast::foreign_abi_rust_intrinsic) {\n+        if m.abis.is_intrinsic() {\n             for m.items.each |item| {\n                 check_intrinsic_type(ccx, *item);\n             }\n@@ -1145,6 +1145,19 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n \n         let formal_tys;\n \n+        // FIXME(#3678) For now, do not permit calls to C abi functions.\n+        match structure_of(fcx, sp, in_fty) {\n+            ty::ty_bare_fn(ty::BareFnTy {abis, _}) => {\n+                if !abis.is_rust() {\n+                    tcx.sess.span_err(\n+                        sp,\n+                        fmt!(\"Calls to C ABI functions are not (yet) \\\n+                              supported; be patient, dear user\"));\n+                }\n+            }\n+            _ => {}\n+        }\n+\n         // This is subtle: we expect `fty` to be a function type, which\n         // normally introduce a level of binding.  In this case, we want to\n         // process the types bound by the function but not by any nested\n@@ -3672,7 +3685,7 @@ pub fn check_intrinsic_type(ccx: @mut CrateCtxt, it: @ast::foreign_item) {\n     };\n     let fty = ty::mk_bare_fn(tcx, ty::BareFnTy {\n         purity: ast::unsafe_fn,\n-        abi: ast::RustAbi,\n+        abis: AbiSet::Rust(),\n         sig: FnSig {bound_lifetime_names: opt_vec::Empty,\n                     inputs: inputs,\n                     output: output}"}, {"sha": "0ef65d5932cbe4f58f49bfa8215a476b31cd9192", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/fbd8eae26de23cf00081229176fd7efd80943905/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd8eae26de23cf00081229176fd7efd80943905/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=fbd8eae26de23cf00081229176fd7efd80943905", "patch": "@@ -33,7 +33,7 @@ are represented as `ty_param()` instances.\n use core::prelude::*;\n \n use metadata::csearch;\n-use middle::ty::InstantiatedTraitRef;\n+use middle::ty::{InstantiatedTraitRef, arg};\n use middle::ty::{substs, ty_param_bounds_and_ty, ty_param_substs_and_ty};\n use middle::ty;\n use middle::typeck::astconv::{AstConv, ty_of_arg};\n@@ -48,6 +48,7 @@ use util::common::{indenter, pluralize};\n use util::ppaux;\n \n use core::vec;\n+use syntax::abi::AbiSet;\n use syntax::ast::{RegionTyParamBound, TraitTyParamBound};\n use syntax::ast;\n use syntax::ast_map;\n@@ -707,7 +708,7 @@ pub fn convert_struct(ccx: &CrateCtxt,\n                 ccx,\n                 &type_rscope(region_parameterization),\n                 ast::impure_fn,\n-                ast::RustAbi,\n+                AbiSet::Rust(),\n                 &opt_vec::Empty,\n                 &ast_util::dtor_dec()));\n         write_ty_to_tcx(tcx, dtor.node.id, t_dtor);\n@@ -776,7 +777,7 @@ pub fn ty_of_method(ccx: &CrateCtxt,\n         fty: astconv::ty_of_bare_fn(ccx,\n                                     &rscope,\n                                     m.purity,\n-                                    ast::RustAbi,\n+                                    AbiSet::Rust(),\n                                     &method_generics.lifetimes,\n                                     &m.decl),\n         self_ty: m.self_ty.node,\n@@ -798,7 +799,7 @@ pub fn ty_of_ty_method(self: &CrateCtxt,\n         fty: astconv::ty_of_bare_fn(self,\n                                     &rscope,\n                                     m.purity,\n-                                    ast::RustAbi,\n+                                    AbiSet::Rust(),\n                                     &m.generics.lifetimes,\n                                     &m.decl),\n         // assume public, because this is only invoked on trait methods\n@@ -859,12 +860,12 @@ pub fn ty_of_item(ccx: &CrateCtxt, it: @ast::item)\n         tcx.tcache.insert(local_def(it.id), tpt);\n         return tpt;\n       }\n-      ast::item_fn(ref decl, purity, ref generics, _) => {\n+      ast::item_fn(ref decl, purity, abi, ref generics, _) => {\n         let bounds = ty_param_bounds(ccx, generics);\n         let tofd = astconv::ty_of_bare_fn(ccx,\n                                           &empty_rscope,\n                                           purity,\n-                                          ast::RustAbi,\n+                                          AbiSet::Rust(),\n                                           &generics.lifetimes,\n                                           decl);\n         let tpt = ty_param_bounds_and_ty {\n@@ -1040,7 +1041,7 @@ pub fn ty_of_foreign_fn_decl(ccx: &CrateCtxt,\n     let t_fn = ty::mk_bare_fn(\n         ccx.tcx,\n         ty::BareFnTy {\n-            abi: ast::RustAbi,\n+            abis: AbiSet::Rust(),\n             purity: ast::unsafe_fn,\n             sig: ty::FnSig {bound_lifetime_names: opt_vec::Empty,\n                             inputs: input_tys,"}, {"sha": "95ff552eb51b77e7f596c8adb9eb55567e52e1fb", "filename": "src/librustc/middle/typeck/infer/coercion.rs", "status": "modified", "additions": 16, "deletions": 7, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/fbd8eae26de23cf00081229176fd7efd80943905/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd8eae26de23cf00081229176fd7efd80943905/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs?ref=fbd8eae26de23cf00081229176fd7efd80943905", "patch": "@@ -66,19 +66,20 @@ we may want to adjust precisely when coercions occur.\n \n use core::prelude::*;\n \n-use middle::ty::{AutoPtr, AutoBorrowVec, AutoBorrowFn};\n-use middle::ty::{AutoDerefRef, AutoRef};\n-use middle::ty::{vstore_slice, vstore_box, vstore_uniq};\n+use middle::ty::{TyVar, AutoPtr, AutoBorrowVec, AutoBorrowFn};\n+use middle::ty::{AutoAdjustment, AutoDerefRef, AutoRef};\n+use middle::ty::{vstore_slice, vstore_box, vstore_uniq, vstore_fixed};\n use middle::ty::{mt};\n use middle::ty;\n use middle::typeck::infer::{CoerceResult, resolve_type};\n use middle::typeck::infer::combine::CombineFields;\n use middle::typeck::infer::sub::Sub;\n use middle::typeck::infer::to_str::InferStr;\n use middle::typeck::infer::resolve::try_resolve_tvar_shallow;\n-use util::common::indenter;\n+use util::common::{indent, indenter};\n \n-use syntax::ast::m_imm;\n+use syntax::abi::AbiSet;\n+use syntax::ast::{m_const, m_imm, m_mutbl};\n use syntax::ast;\n \n // Note: Coerce is not actually a combiner, in that it does not\n@@ -334,18 +335,26 @@ pub impl Coerce {\n                                        b: ty::t,\n                                        sty_b: &ty::sty) -> CoerceResult\n     {\n+        /*!\n+         *\n+         * Attempts to coerce from a bare Rust function (`extern\n+         * \"rust\" fn`) into a closure.\n+         */\n+\n         debug!(\"coerce_from_bare_fn(a=%s, b=%s)\",\n                a.inf_str(self.infcx), b.inf_str(self.infcx));\n \n+        if !fn_ty_a.abis.is_rust() {\n+            return self.subtype(a, b);\n+        }\n+\n         let fn_ty_b = match *sty_b {\n             ty::ty_closure(ref f) => {copy *f}\n             _ => {\n                 return self.subtype(a, b);\n             }\n         };\n \n-        // for now, bare fn and closures have the same\n-        // representation\n         let adj = @ty::AutoAddEnv(fn_ty_b.region, fn_ty_b.sigil);\n         let a_closure = ty::mk_closure(\n             self.infcx.tcx,"}, {"sha": "add70b21e39a43bbbc4f28107dd0888aad53fccb", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fbd8eae26de23cf00081229176fd7efd80943905/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd8eae26de23cf00081229176fd7efd80943905/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=fbd8eae26de23cf00081229176fd7efd80943905", "patch": "@@ -72,6 +72,7 @@ use syntax::ast::{Onceness, purity};\n use syntax::ast;\n use syntax::opt_vec;\n use syntax::codemap::span;\n+use syntax::abi::AbiSet;\n \n pub trait Combine {\n     fn infcx(&self) -> @mut InferCtxt;\n@@ -101,7 +102,7 @@ pub trait Combine {\n     fn args(&self, a: ty::arg, b: ty::arg) -> cres<ty::arg>;\n     fn sigils(&self, p1: ast::Sigil, p2: ast::Sigil) -> cres<ast::Sigil>;\n     fn purities(&self, a: purity, b: purity) -> cres<purity>;\n-    fn abis(&self, a: ast::Abi, b: ast::Abi) -> cres<ast::Abi>;\n+    fn abis(&self, a: AbiSet, b: AbiSet) -> cres<AbiSet>;\n     fn oncenesses(&self, a: Onceness, b: Onceness) -> cres<Onceness>;\n     fn contraregions(&self, a: ty::Region, b: ty::Region)\n                   -> cres<ty::Region>;\n@@ -396,7 +397,7 @@ pub fn super_closure_tys<C:Combine>(\n }\n \n pub fn super_abis<C:Combine>(\n-    self: &C, a: ast::Abi, b: ast::Abi) -> cres<ast::Abi>\n+    self: &C, a: AbiSet, b: AbiSet) -> cres<AbiSet>\n {\n     if a == b {\n         Ok(a)\n@@ -409,10 +410,10 @@ pub fn super_bare_fn_tys<C:Combine>(\n     self: &C, a_f: &ty::BareFnTy, b_f: &ty::BareFnTy) -> cres<ty::BareFnTy>\n {\n     let purity = if_ok!(self.purities(a_f.purity, b_f.purity));\n-    let abi = if_ok!(self.abis(a_f.abi, b_f.abi));\n+    let abi = if_ok!(self.abis(a_f.abis, b_f.abis));\n     let sig = if_ok!(self.fn_sigs(&a_f.sig, &b_f.sig));\n     Ok(ty::BareFnTy {purity: purity,\n-                     abi: abi,\n+                     abis: abi,\n                      sig: sig})\n }\n "}, {"sha": "d521d005aba4ada1c0b525bef76291c78c26351a", "filename": "src/librustc/middle/typeck/infer/glb.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fbd8eae26de23cf00081229176fd7efd80943905/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd8eae26de23cf00081229176fd7efd80943905/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs?ref=fbd8eae26de23cf00081229176fd7efd80943905", "patch": "@@ -21,7 +21,9 @@ use middle::typeck::infer::{cres, InferCtxt};\n use middle::typeck::isr_alist;\n use syntax::ast;\n use syntax::ast::{Many, Once, extern_fn, impure_fn, m_const, m_imm, m_mutbl};\n-use syntax::ast::{pure_fn, unsafe_fn, Onceness, purity};\n+use syntax::ast::{noreturn, pure_fn, ret_style, return_val, unsafe_fn};\n+use syntax::ast::{Onceness, purity};\n+use syntax::abi::AbiSet;\n use syntax::codemap::span;\n use util::common::{indent, indenter};\n use util::ppaux::mt_to_str;\n@@ -283,7 +285,7 @@ impl Combine for Glb {\n         super_sigils(self, p1, p2)\n     }\n \n-    fn abis(&self, p1: ast::Abi, p2: ast::Abi) -> cres<ast::Abi> {\n+    fn abis(&self, p1: AbiSet, p2: AbiSet) -> cres<AbiSet> {\n         super_abis(self, p1, p2)\n     }\n "}, {"sha": "5a705c31c123915c2277e4c10e68c4829a12ef76", "filename": "src/librustc/middle/typeck/infer/lub.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fbd8eae26de23cf00081229176fd7efd80943905/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd8eae26de23cf00081229176fd7efd80943905/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs?ref=fbd8eae26de23cf00081229176fd7efd80943905", "patch": "@@ -23,6 +23,7 @@ use util::common::indent;\n use util::ppaux::mt_to_str;\n \n use std::list;\n+use syntax::abi::AbiSet;\n use syntax::ast;\n use syntax::ast::{Many, Once, extern_fn, m_const, impure_fn};\n use syntax::ast::{pure_fn, unsafe_fn};\n@@ -210,7 +211,7 @@ impl Combine for Lub {\n         super_sigils(self, p1, p2)\n     }\n \n-    fn abis(&self, p1: ast::Abi, p2: ast::Abi) -> cres<ast::Abi> {\n+    fn abis(&self, p1: AbiSet, p2: AbiSet) -> cres<AbiSet> {\n         super_abis(self, p1, p2)\n     }\n "}, {"sha": "161905c12e5ddd8b683932dad7ac3b57901c6503", "filename": "src/librustc/middle/typeck/infer/sub.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fbd8eae26de23cf00081229176fd7efd80943905/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd8eae26de23cf00081229176fd7efd80943905/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs?ref=fbd8eae26de23cf00081229176fd7efd80943905", "patch": "@@ -24,6 +24,7 @@ use util::ppaux::bound_region_to_str;\n \n use std::list::Nil;\n use std::list;\n+use syntax::abi::AbiSet;\n use syntax::ast;\n use syntax::ast::{Onceness, m_const, purity};\n use syntax::codemap::span;\n@@ -216,7 +217,7 @@ impl Combine for Sub {\n         super_sigils(self, p1, p2)\n     }\n \n-    fn abis(&self, p1: ast::Abi, p2: ast::Abi) -> cres<ast::Abi> {\n+    fn abis(&self, p1: AbiSet, p2: AbiSet) -> cres<AbiSet> {\n         super_abis(self, p1, p2)\n     }\n "}, {"sha": "2b5a47c18c6d98f006bc786487151b7670568dd8", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fbd8eae26de23cf00081229176fd7efd80943905/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd8eae26de23cf00081229176fd7efd80943905/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=fbd8eae26de23cf00081229176fd7efd80943905", "patch": "@@ -293,7 +293,7 @@ fn check_main_fn_ty(ccx: @mut CrateCtxt,\n             match tcx.items.find(&main_id) {\n                 Some(&ast_map::node_item(it,_)) => {\n                     match it.node {\n-                        ast::item_fn(_, _, ref ps, _)\n+                        ast::item_fn(_, _, _, ref ps, _)\n                         if ps.is_parameterized() => {\n                             tcx.sess.span_err(\n                                 main_span,"}, {"sha": "afbf3f485d0ae97890603b724a4adc53cb32f9bf", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fbd8eae26de23cf00081229176fd7efd80943905/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd8eae26de23cf00081229176fd7efd80943905/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=fbd8eae26de23cf00081229176fd7efd80943905", "patch": "@@ -30,6 +30,7 @@ use syntax::print::pprust;\n use syntax::print::pprust::mode_to_str;\n use syntax::{ast, ast_util};\n use syntax::ast_map;\n+use syntax::abi::AbiSet;\n \n use core::str;\n use core::vec;\n@@ -302,15 +303,14 @@ pub fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n     }\n     fn bare_fn_to_str(cx: ctxt,\n                       purity: ast::purity,\n-                      abi: ast::Abi,\n+                      abis: AbiSet,\n                       ident: Option<ast::ident>,\n                       sig: &ty::FnSig) -> ~str\n     {\n         let mut s = ~\"extern \";\n \n-        match abi {\n-            ast::RustAbi => {}\n-        }\n+        s.push_str(abis.to_str());\n+        s.push_char(' ');\n \n         match purity {\n             ast::impure_fn => {}\n@@ -386,7 +386,7 @@ pub fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n     fn method_to_str(cx: ctxt, m: method) -> ~str {\n         bare_fn_to_str(cx,\n                        m.fty.purity,\n-                       m.fty.abi,\n+                       m.fty.abis,\n                        Some(m.ident),\n                        &m.fty.sig) + ~\";\"\n     }\n@@ -429,7 +429,7 @@ pub fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n           closure_to_str(cx, f)\n       }\n       ty_bare_fn(ref f) => {\n-          bare_fn_to_str(cx, f.purity, f.abi, None, &f.sig)\n+          bare_fn_to_str(cx, f.purity, f.abis, None, &f.sig)\n       }\n       ty_infer(infer_ty) => infer_ty.to_str(),\n       ty_err => ~\"[type error]\","}, {"sha": "6ccfb1bb8c4b9c9e85040d9f69d2506146523171", "filename": "src/librustdoc/tystr_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fbd8eae26de23cf00081229176fd7efd80943905/src%2Flibrustdoc%2Ftystr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd8eae26de23cf00081229176fd7efd80943905/src%2Flibrustdoc%2Ftystr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftystr_pass.rs?ref=fbd8eae26de23cf00081229176fd7efd80943905", "patch": "@@ -69,7 +69,7 @@ fn get_fn_sig(srv: astsrv::Srv, fn_id: doc::AstId) -> Option<~str> {\n         match *ctxt.ast_map.get(&fn_id) {\n           ast_map::node_item(@ast::item {\n             ident: ident,\n-            node: ast::item_fn(ref decl, purity, ref tys, _), _\n+            node: ast::item_fn(ref decl, purity, _, ref tys, _), _\n           }, _) |\n           ast_map::node_foreign_item(@ast::foreign_item {\n             ident: ident,"}, {"sha": "6b91377b674853f0b5cc217a005852fa457383da", "filename": "src/librusti/rusti.rc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fbd8eae26de23cf00081229176fd7efd80943905/src%2Flibrusti%2Frusti.rc", "raw_url": "https://github.com/rust-lang/rust/raw/fbd8eae26de23cf00081229176fd7efd80943905/src%2Flibrusti%2Frusti.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrusti%2Frusti.rc?ref=fbd8eae26de23cf00081229176fd7efd80943905", "patch": "@@ -159,7 +159,7 @@ fn run(repl: Repl, input: ~str) -> Repl {\n \n     for crate.node.module.items.each |item| {\n         match item.node {\n-            ast::item_fn(_, _, _, blk) => {\n+            ast::item_fn(_, _, _, _, blk) => {\n                 if item.ident == sess.ident_of(~\"main\") {\n                     opt = blk.node.expr;\n                 }"}, {"sha": "ff549ad2c2261233aa3a3a5ddda4a19df7d2d4fb", "filename": "src/librustpkg/rustpkg.rc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fbd8eae26de23cf00081229176fd7efd80943905/src%2Flibrustpkg%2Frustpkg.rc", "raw_url": "https://github.com/rust-lang/rust/raw/fbd8eae26de23cf00081229176fd7efd80943905/src%2Flibrustpkg%2Frustpkg.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Frustpkg.rc?ref=fbd8eae26de23cf00081229176fd7efd80943905", "patch": "@@ -185,7 +185,7 @@ impl PackageScript {\n         // the build API.\n         for crate.node.module.items.each |i| {\n             match i.node {\n-                ast::item_fn(_, _, _, _) => {\n+                ast::item_fn(*) => {\n                     custom = true;\n \n                     break;"}, {"sha": "81c28f94d9f2763274486d723390f7c6a2300180", "filename": "src/libstd/arena.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fbd8eae26de23cf00081229176fd7efd80943905/src%2Flibstd%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd8eae26de23cf00081229176fd7efd80943905/src%2Flibstd%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Farena.rs?ref=fbd8eae26de23cf00081229176fd7efd80943905", "patch": "@@ -48,7 +48,7 @@ use core::vec;\n \n pub mod rusti {\n     #[abi = \"rust-intrinsic\"]\n-    pub extern {\n+    pub extern \"rust-intrinsic\" {\n         fn move_val_init<T>(dst: &mut T, +src: T);\n         fn needs_drop<T>() -> bool;\n     }"}, {"sha": "dd56e41359582566405936169944d894b8e95f07", "filename": "src/libstd/priority_queue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fbd8eae26de23cf00081229176fd7efd80943905/src%2Flibstd%2Fpriority_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd8eae26de23cf00081229176fd7efd80943905/src%2Flibstd%2Fpriority_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpriority_queue.rs?ref=fbd8eae26de23cf00081229176fd7efd80943905", "patch": "@@ -18,7 +18,7 @@ use core::ptr::addr_of;\n use core::vec;\n \n #[abi = \"rust-intrinsic\"]\n-extern \"C\" mod rusti {\n+extern \"rust-intrinsic\" mod rusti {\n     fn move_val_init<T>(dst: &mut T, +src: T);\n     fn init<T>() -> T;\n }"}, {"sha": "076c09e446d444498e43bf1b50b41fbc25314895", "filename": "src/libsyntax/abi.rs", "status": "added", "additions": 427, "deletions": 0, "changes": 427, "blob_url": "https://github.com/rust-lang/rust/blob/fbd8eae26de23cf00081229176fd7efd80943905/src%2Flibsyntax%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd8eae26de23cf00081229176fd7efd80943905/src%2Flibsyntax%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fabi.rs?ref=fbd8eae26de23cf00081229176fd7efd80943905", "patch": "@@ -0,0 +1,427 @@\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use core::prelude::*;\n+use core::to_bytes;\n+use core::to_str::ToStr;\n+\n+#[deriving(Eq)]\n+pub enum Abi {\n+    // NB: This ordering MUST match the AbiDatas array below.\n+    // (This is ensured by the test indices_are_correct().)\n+\n+    // Single platform ABIs come first (`for_arch()` relies on this)\n+    Cdecl,\n+    Stdcall,\n+    Fastcall,\n+    Aapcs,\n+\n+    // Multiplatform ABIs second\n+    Rust,\n+    C,\n+    RustIntrinsic,\n+}\n+\n+#[deriving(Eq)]\n+pub enum Architecture {\n+    // NB. You cannot change the ordering of these\n+    // constants without adjusting IntelBits below.\n+    // (This is ensured by the test indices_are_correct().)\n+    X86,\n+    X86_64,\n+    Arm,\n+    Mips\n+}\n+\n+// FIXME(#5423) After a snapshot, we can change these constants:\n+// const IntelBits: u32 = (1 << (X86 as uint)) | (1 << X86_64 as uint));\n+// const ArmBits: u32 = (1 << (Arm as uint));\n+static IntelBits: u32 = 1 | 2;\n+static ArmBits: u32 = 4;\n+\n+struct AbiData {\n+    abi: Abi,\n+\n+    // Name of this ABI as we like it called.\n+    name: &'static str,\n+\n+    // Is it specific to a platform? If so, which one?  Also, what is\n+    // the name that LLVM gives it (in case we disagree)\n+    abi_arch: AbiArchitecture\n+}\n+\n+enum AbiArchitecture {\n+    RustArch,   // Not a real ABI (e.g., intrinsic)\n+    AllArch,    // An ABI that specifies cross-platform defaults (e.g., \"C\")\n+    Archs(u32)  // Multiple architectures (bitset)\n+}\n+\n+#[auto_encode]\n+#[auto_decode]\n+#[deriving(Eq)]\n+pub struct AbiSet {\n+    priv bits: u32   // each bit represents one of the abis below\n+}\n+\n+static AbiDatas: &'static [AbiData] = &[\n+    // Platform-specific ABIs\n+    AbiData {abi: Cdecl, name: \"cdecl\", abi_arch: Archs(IntelBits)},\n+    AbiData {abi: Stdcall, name: \"stdcall\", abi_arch: Archs(IntelBits)},\n+    AbiData {abi: Fastcall, name:\"fastcall\", abi_arch: Archs(IntelBits)},\n+    AbiData {abi: Aapcs, name: \"aapcs\", abi_arch: Archs(ArmBits)},\n+\n+    // Cross-platform ABIs\n+    //\n+    // NB: Do not adjust this ordering without\n+    // adjusting the indices below.\n+    AbiData {abi: Rust, name: \"Rust\", abi_arch: RustArch},\n+    AbiData {abi: C, name: \"C\", abi_arch: AllArch},\n+    AbiData {abi: RustIntrinsic, name: \"rust-intrinsic\", abi_arch: RustArch},\n+];\n+\n+fn each_abi(op: &fn(abi: Abi) -> bool) {\n+    /*!\n+     *\n+     * Iterates through each of the defined ABIs.\n+     */\n+\n+    for AbiDatas.each |abi_data| {\n+        if !op(abi_data.abi) {\n+            return;\n+        }\n+    }\n+}\n+\n+pub fn lookup(name: &str) -> Option<Abi> {\n+    /*!\n+     *\n+     * Returns the ABI with the given name (if any).\n+     */\n+\n+    for each_abi |abi| {\n+        if name == abi.data().name {\n+            return Some(abi);\n+        }\n+    }\n+    return None;\n+}\n+\n+pub fn all_names() -> ~[&'static str] {\n+    AbiDatas.map(|d| d.name)\n+}\n+\n+pub impl Abi {\n+    #[inline]\n+    fn index(&self) -> uint {\n+        *self as uint\n+    }\n+\n+    #[inline]\n+    fn data(&self) -> &'static AbiData {\n+        &AbiDatas[self.index()]\n+    }\n+\n+    fn name(&self) -> &'static str {\n+        self.data().name\n+    }\n+}\n+\n+impl Architecture {\n+    fn bit(&self) -> u32 {\n+        1 << (*self as u32)\n+    }\n+}\n+\n+pub impl AbiSet {\n+    fn from(abi: Abi) -> AbiSet {\n+        AbiSet { bits: (1 << abi.index()) }\n+    }\n+\n+    #[inline]\n+    fn Rust() -> AbiSet {\n+        AbiSet::from(Rust)\n+    }\n+\n+    #[inline]\n+    fn C() -> AbiSet {\n+        AbiSet::from(C)\n+    }\n+\n+    #[inline]\n+    fn Intrinsic() -> AbiSet {\n+        AbiSet::from(RustIntrinsic)\n+    }\n+\n+    fn default() -> AbiSet {\n+        AbiSet::C()\n+    }\n+\n+    fn empty() -> AbiSet {\n+        AbiSet { bits: 0 }\n+    }\n+\n+    #[inline]\n+    fn is_rust(&self) -> bool {\n+        self.bits == 1 << Rust.index()\n+    }\n+\n+    #[inline]\n+    fn is_c(&self) -> bool {\n+        self.bits == 1 << C.index()\n+    }\n+\n+    #[inline]\n+    fn is_intrinsic(&self) -> bool {\n+        self.bits == 1 << RustIntrinsic.index()\n+    }\n+\n+    fn contains(&self, abi: Abi) -> bool {\n+        (self.bits & (1 << abi.index())) != 0\n+    }\n+\n+    fn subset_of(&self, other_abi_set: AbiSet) -> bool {\n+        (self.bits & other_abi_set.bits) == self.bits\n+    }\n+\n+    fn add(&mut self, abi: Abi) {\n+        self.bits |= (1 << abi.index());\n+    }\n+\n+    fn each(&self, op: &fn(abi: Abi) -> bool) {\n+        for each_abi |abi| {\n+            if self.contains(abi) {\n+                if !op(abi) {\n+                    return;\n+                }\n+            }\n+        }\n+    }\n+\n+    fn is_empty(&self) -> bool {\n+        self.bits == 0\n+    }\n+\n+    fn for_arch(&self, arch: Architecture) -> Option<Abi> {\n+        // NB---Single platform ABIs come first\n+        for self.each |abi| {\n+            let data = abi.data();\n+            match data.abi_arch {\n+                Archs(a) if (a & arch.bit()) != 0 => { return Some(abi); }\n+                Archs(_) => { }\n+                RustArch | AllArch => { return Some(abi); }\n+            }\n+        }\n+\n+        None\n+    }\n+\n+    fn check_valid(&self) -> Option<(Abi, Abi)> {\n+        let mut abis = ~[];\n+        for self.each |abi| { abis.push(abi); }\n+\n+        for abis.eachi |i, abi| {\n+            let data = abi.data();\n+            for abis.slice(0, i).each |other_abi| {\n+                let other_data = other_abi.data();\n+                debug!(\"abis=(%?,%?) datas=(%?,%?)\",\n+                       abi, data.abi_arch,\n+                       other_abi, other_data.abi_arch);\n+                match (&data.abi_arch, &other_data.abi_arch) {\n+                    (&AllArch, &AllArch) => {\n+                        // Two cross-architecture ABIs\n+                        return Some((*abi, *other_abi));\n+                    }\n+                    (_, &RustArch) |\n+                    (&RustArch, _) => {\n+                        // Cannot combine Rust or Rust-Intrinsic with\n+                        // anything else.\n+                        return Some((*abi, *other_abi));\n+                    }\n+                    (&Archs(is), &Archs(js)) if (is & js) != 0 => {\n+                        // Two ABIs for same architecture\n+                        return Some((*abi, *other_abi));\n+                    }\n+                    _ => {}\n+                }\n+            }\n+        }\n+\n+        return None;\n+    }\n+}\n+\n+impl to_bytes::IterBytes for Abi {\n+    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+        self.index().iter_bytes(lsb0, f)\n+    }\n+}\n+\n+impl to_bytes::IterBytes for AbiSet {\n+    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n+        self.bits.iter_bytes(lsb0, f)\n+    }\n+}\n+\n+impl ToStr for Abi {\n+    fn to_str(&self) -> ~str {\n+        self.data().name.to_str()\n+    }\n+}\n+\n+impl ToStr for AbiSet {\n+    fn to_str(&self) -> ~str {\n+        unsafe { // so we can push to strs.\n+            let mut strs = ~[];\n+            for self.each |abi| {\n+                strs.push(abi.data().name);\n+            }\n+            fmt!(\"\\\"%s\\\"\", str::connect_slices(strs, \" \"))\n+        }\n+    }\n+}\n+\n+#[test]\n+fn lookup_Rust() {\n+    let abi = lookup(\"Rust\");\n+    assert!(abi.is_some() && abi.get().data().name == \"Rust\");\n+}\n+\n+#[test]\n+fn lookup_cdecl() {\n+    let abi = lookup(\"cdecl\");\n+    assert!(abi.is_some() && abi.get().data().name == \"cdecl\");\n+}\n+\n+#[test]\n+fn lookup_baz() {\n+    let abi = lookup(\"baz\");\n+    assert!(abi.is_none());\n+}\n+\n+#[cfg(test)]\n+fn cannot_combine(n: Abi, m: Abi) {\n+    let mut set = AbiSet::empty();\n+    set.add(n);\n+    set.add(m);\n+    match set.check_valid() {\n+        Some((a, b)) => {\n+            assert!((n == a && m == b) ||\n+                         (m == a && n == b));\n+        }\n+        None => {\n+            fail!(~\"Invalid match not detected\");\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+fn can_combine(n: Abi, m: Abi) {\n+    let mut set = AbiSet::empty();\n+    set.add(n);\n+    set.add(m);\n+    match set.check_valid() {\n+        Some((_, _)) => {\n+            fail!(~\"Valid match declared invalid\");\n+        }\n+        None => {}\n+    }\n+}\n+\n+#[test]\n+fn cannot_combine_cdecl_and_stdcall() {\n+    cannot_combine(Cdecl, Stdcall);\n+}\n+\n+#[test]\n+fn cannot_combine_c_and_rust() {\n+    cannot_combine(C, Rust);\n+}\n+\n+#[test]\n+fn cannot_combine_rust_and_cdecl() {\n+    cannot_combine(Rust, Cdecl);\n+}\n+\n+#[test]\n+fn cannot_combine_rust_intrinsic_and_cdecl() {\n+    cannot_combine(RustIntrinsic, Cdecl);\n+}\n+\n+#[test]\n+fn can_combine_c_and_stdcall() {\n+    can_combine(C, Stdcall);\n+}\n+\n+#[test]\n+fn can_combine_aapcs_and_stdcall() {\n+    can_combine(Aapcs, Stdcall);\n+}\n+\n+#[test]\n+fn abi_to_str_stdcall_aaps() {\n+    let mut set = AbiSet::empty();\n+    set.add(Aapcs);\n+    set.add(Stdcall);\n+    assert!(set.to_str() == ~\"\\\"stdcall aapcs\\\"\");\n+}\n+\n+#[test]\n+fn abi_to_str_c_aaps() {\n+    let mut set = AbiSet::empty();\n+    set.add(Aapcs);\n+    set.add(C);\n+    debug!(\"set = %s\", set.to_str());\n+    assert!(set.to_str() == ~\"\\\"aapcs C\\\"\");\n+}\n+\n+#[test]\n+fn abi_to_str_rust() {\n+    let mut set = AbiSet::empty();\n+    set.add(Rust);\n+    debug!(\"set = %s\", set.to_str());\n+    assert!(set.to_str() == ~\"\\\"Rust\\\"\");\n+}\n+\n+#[test]\n+fn indices_are_correct() {\n+    for AbiDatas.eachi |i, abi_data| {\n+        assert!(i == abi_data.abi.index());\n+    }\n+\n+    let bits = 1 << (X86 as u32);\n+    let bits = bits | 1 << (X86_64 as u32);\n+    assert!(IntelBits == bits);\n+\n+    let bits = 1 << (Arm as u32);\n+    assert!(ArmBits == bits);\n+}\n+\n+#[cfg(test)]\n+fn check_arch(abis: &[Abi], arch: Architecture, expect: Option<Abi>) {\n+    let mut set = AbiSet::empty();\n+    for abis.each |&abi| {\n+        set.add(abi);\n+    }\n+    let r = set.for_arch(arch);\n+    assert!(r == expect);\n+}\n+\n+#[test]\n+fn pick_multiplatform() {\n+    check_arch([C, Cdecl], X86, Some(Cdecl));\n+    check_arch([C, Cdecl], X86_64, Some(Cdecl));\n+    check_arch([C, Cdecl], Arm, Some(C));\n+}\n+\n+#[test]\n+fn pick_uniplatform() {\n+    check_arch([Stdcall], X86, Some(Stdcall));\n+    check_arch([Stdcall], Arm, None);\n+}"}, {"sha": "db04c46ea5988c3fa764f32fba245bc1804833c9", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 6, "deletions": 35, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/fbd8eae26de23cf00081229176fd7efd80943905/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd8eae26de23cf00081229176fd7efd80943905/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=fbd8eae26de23cf00081229176fd7efd80943905", "patch": "@@ -10,7 +10,9 @@\n \n // The Rust abstract syntax tree.\n \n-use codemap::{span, spanned};\n+use codemap::{span, FileName, spanned};\n+use abi::AbiSet;\n+use opt_vec::OptVec;\n \n use core::cast;\n use core::option::{None, Option, Some};\n@@ -19,7 +21,6 @@ use core::to_bytes;\n use core::to_str::ToStr;\n use std::serialize::{Encodable, Decodable, Encoder, Decoder};\n \n-use opt_vec::OptVec;\n \n /* can't import macros yet, so this is copied from token.rs. See its comment\n  * there. */\n@@ -325,27 +326,6 @@ impl to_bytes::IterBytes for mutability {\n     }\n }\n \n-#[auto_encode]\n-#[auto_decode]\n-#[deriving(Eq)]\n-pub enum Abi {\n-    RustAbi\n-}\n-\n-impl to_bytes::IterBytes for Abi {\n-    fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n-        (*self as uint).iter_bytes(lsb0, f)\n-    }\n-}\n-\n-impl ToStr for Abi {\n-    fn to_str(&self) -> ~str {\n-        match *self {\n-            RustAbi => ~\"\\\"rust\\\"\"\n-        }\n-    }\n-}\n-\n #[auto_encode]\n #[auto_decode]\n #[deriving(Eq)]\n@@ -893,7 +873,7 @@ pub struct TyClosure {\n #[deriving(Eq)]\n pub struct TyBareFn {\n     purity: purity,\n-    abi: Abi,\n+    abis: AbiSet,\n     lifetimes: OptVec<Lifetime>,\n     decl: fn_decl\n }\n@@ -1057,15 +1037,6 @@ pub struct _mod {\n     items: ~[@item],\n }\n \n-#[auto_encode]\n-#[auto_decode]\n-#[deriving(Eq)]\n-pub enum foreign_abi {\n-    foreign_abi_rust_intrinsic,\n-    foreign_abi_cdecl,\n-    foreign_abi_stdcall,\n-}\n-\n // Foreign mods can be named or anonymous\n #[auto_encode]\n #[auto_decode]\n@@ -1077,7 +1048,7 @@ pub enum foreign_mod_sort { named, anonymous }\n #[deriving(Eq)]\n pub struct foreign_mod {\n     sort: foreign_mod_sort,\n-    abi: ident,\n+    abis: AbiSet,\n     view_items: ~[@view_item],\n     items: ~[@foreign_item],\n }\n@@ -1267,7 +1238,7 @@ pub struct item {\n #[deriving(Eq)]\n pub enum item_ {\n     item_const(@Ty, @expr),\n-    item_fn(fn_decl, purity, Generics, blk),\n+    item_fn(fn_decl, purity, AbiSet, Generics, blk),\n     item_mod(_mod),\n     item_foreign_mod(foreign_mod),\n     item_ty(@Ty, Generics),"}, {"sha": "ff5cbbe9f235052c34861d4df7ca833bd433e183", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fbd8eae26de23cf00081229176fd7efd80943905/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd8eae26de23cf00081229176fd7efd80943905/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=fbd8eae26de23cf00081229176fd7efd80943905", "patch": "@@ -10,6 +10,7 @@\n \n use core::prelude::*;\n \n+use abi::AbiSet;\n use ast::*;\n use ast;\n use ast_util::{inlined_item_utils, stmt_id};\n@@ -87,7 +88,7 @@ pub fn path_elt_to_str(pe: path_elt, itr: @ident_interner) -> ~str {\n \n pub enum ast_node {\n     node_item(@item, @path),\n-    node_foreign_item(@foreign_item, foreign_abi, visibility, @path),\n+    node_foreign_item(@foreign_item, AbiSet, visibility, @path),\n     node_trait_method(@trait_method, def_id /* trait did */,\n                       @path /* path to the trait */),\n     node_method(@method, def_id /* impl did */, @path /* path to the impl */),\n@@ -171,7 +172,7 @@ pub fn map_decoded_item(diag: @span_handler,\n       ii_item(*) | ii_dtor(*) => { /* fallthrough */ }\n       ii_foreign(i) => {\n         cx.map.insert(i.id, node_foreign_item(i,\n-                                              foreign_abi_rust_intrinsic,\n+                                              AbiSet::Intrinsic(),\n                                               i.vis,    // Wrong but OK\n                                               @path));\n       }\n@@ -274,10 +275,6 @@ pub fn map_item(i: @item, &&cx: @mut Ctx, v: visit::vt<@mut Ctx>) {\n             }\n         }\n         item_foreign_mod(ref nm) => {\n-            let abi = match attr::foreign_abi(i.attrs) {\n-                Left(ref msg) => cx.diag.span_fatal(i.span, (*msg)),\n-                Right(abi) => abi\n-            };\n             for nm.items.each |nitem| {\n                 // Compute the visibility for this native item.\n                 let visibility = match nitem.vis {\n@@ -289,7 +286,7 @@ pub fn map_item(i: @item, &&cx: @mut Ctx, v: visit::vt<@mut Ctx>) {\n                 cx.map.insert(nitem.id,\n                     node_foreign_item(\n                         *nitem,\n-                        abi,\n+                        nm.abis,\n                         visibility,\n                         // FIXME (#2543)\n                         if nm.sort == ast::named {"}, {"sha": "208ed1e35fe1a0d99d216388fc7a0b4dde6733cb", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fbd8eae26de23cf00081229176fd7efd80943905/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd8eae26de23cf00081229176fd7efd80943905/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=fbd8eae26de23cf00081229176fd7efd80943905", "patch": "@@ -465,7 +465,7 @@ pub fn id_visitor(vfn: @fn(node_id)) -> visit::vt<()> {\n                     vfn(self_id);\n                     vfn(parent_id.node);\n                 }\n-                visit::fk_item_fn(_, generics, _) => {\n+                visit::fk_item_fn(_, generics, _, _) => {\n                     visit_generics(generics);\n                 }\n                 visit::fk_method(_, generics, m) => {"}, {"sha": "72355d0445620176a83c226c79d502c359af402f", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/fbd8eae26de23cf00081229176fd7efd80943905/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd8eae26de23cf00081229176fd7efd80943905/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=fbd8eae26de23cf00081229176fd7efd80943905", "patch": "@@ -303,27 +303,6 @@ pub fn find_linkage_metas(attrs: &[ast::attribute]) -> ~[@ast::meta_item] {\n     }\n }\n \n-pub fn foreign_abi(attrs: &[ast::attribute])\n-                -> Either<~str, ast::foreign_abi> {\n-    return match attr::first_attr_value_str_by_name(attrs, ~\"abi\") {\n-        None => {\n-            Right(ast::foreign_abi_cdecl)\n-        }\n-        Some(@~\"rust-intrinsic\") => {\n-            Right(ast::foreign_abi_rust_intrinsic)\n-        }\n-        Some(@~\"cdecl\") => {\n-            Right(ast::foreign_abi_cdecl)\n-        }\n-        Some(@~\"stdcall\") => {\n-            Right(ast::foreign_abi_stdcall)\n-        }\n-        Some(t) => {\n-            Left(~\"unsupported abi: \" + *t)\n-        }\n-    };\n-}\n-\n #[deriving(Eq)]\n pub enum inline_attr {\n     ia_none,"}, {"sha": "72e6c22dbc8823752ac56fe1266b73c88aee258c", "filename": "src/libsyntax/ext/pipes/ast_builder.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fbd8eae26de23cf00081229176fd7efd80943905/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd8eae26de23cf00081229176fd7efd80943905/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs?ref=fbd8eae26de23cf00081229176fd7efd80943905", "patch": "@@ -15,7 +15,8 @@\n \n use core::prelude::*;\n \n-use ast::ident;\n+use abi::AbiSet;\n+use ast::{ident, node_id};\n use ast;\n use ast_util;\n use codemap::{span, respan, dummy_sp, spanned};\n@@ -272,6 +273,7 @@ impl ext_ctxt_ast_builder for @ext_ctxt {\n                   dummy_sp(),\n                   ast::item_fn(self.fn_decl(inputs, output),\n                                ast::impure_fn,\n+                               AbiSet::Rust(),\n                                generics,\n                                body))\n     }"}, {"sha": "0a473b1cebeafa6f42520c0668180768be11043d", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fbd8eae26de23cf00081229176fd7efd80943905/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd8eae26de23cf00081229176fd7efd80943905/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=fbd8eae26de23cf00081229176fd7efd80943905", "patch": "@@ -236,10 +236,11 @@ fn noop_fold_struct_field(sf: @struct_field, fld: @ast_fold)\n pub fn noop_fold_item_underscore(i: &item_, fld: @ast_fold) -> item_ {\n     match *i {\n         item_const(t, e) => item_const(fld.fold_ty(t), fld.fold_expr(e)),\n-        item_fn(ref decl, purity, ref generics, ref body) => {\n+        item_fn(ref decl, purity, abi, ref generics, ref body) => {\n             item_fn(\n                 fold_fn_decl(decl, fld),\n                 purity,\n+                abi,\n                 fold_generics(generics, fld),\n                 fld.fold_block(body)\n             )\n@@ -612,7 +613,7 @@ pub fn noop_fold_ty(t: &ty_, fld: @ast_fold) -> ty_ {\n             ty_bare_fn(@TyBareFn {\n                 lifetimes: f.lifetimes,\n                 purity: f.purity,\n-                abi: f.abi,\n+                abis: f.abis,\n                 decl: fold_fn_decl(&f.decl, fld)\n             })\n         }\n@@ -639,7 +640,7 @@ pub fn noop_fold_mod(m: &_mod, fld: @ast_fold) -> _mod {\n fn noop_fold_foreign_mod(nm: &foreign_mod, fld: @ast_fold) -> foreign_mod {\n     ast::foreign_mod {\n         sort: nm.sort,\n-        abi: nm.abi,\n+        abis: nm.abis,\n         view_items: vec::map(nm.view_items, |x| fld.fold_view_item(*x)),\n         items: vec::map(nm.items, |x| fld.fold_foreign_item(*x)),\n     }"}, {"sha": "353e3014cf7ba7b751095aa0acdc935da299d611", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 75, "deletions": 38, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/fbd8eae26de23cf00081229176fd7efd80943905/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd8eae26de23cf00081229176fd7efd80943905/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=fbd8eae26de23cf00081229176fd7efd80943905", "patch": "@@ -10,7 +10,9 @@\n \n use core::prelude::*;\n \n-use ast::{Sigil, BorrowedSigil, ManagedSigil, OwnedSigil, RustAbi};\n+use abi;\n+use abi::AbiSet;\n+use ast::{Sigil, BorrowedSigil, ManagedSigil, OwnedSigil};\n use ast::{CallSugar, NoSugar, DoSugar, ForSugar};\n use ast::{TyBareFn, TyClosure};\n use ast::{RegionTyParamBound, TraitTyParamBound};\n@@ -361,11 +363,13 @@ pub impl Parser {\n \n         */\n \n+        let opt_abis = self.parse_opt_abis();\n+        let abis = opt_abis.get_or_default(AbiSet::Rust());\n         let purity = self.parse_purity();\n         self.expect_keyword(&~\"fn\");\n         let (decl, lifetimes) = self.parse_ty_fn_decl();\n         return ty_bare_fn(@TyBareFn {\n-            abi: RustAbi,\n+            abis: abis,\n             purity: purity,\n             lifetimes: lifetimes,\n             decl: decl\n@@ -3041,11 +3045,13 @@ pub impl Parser {\n                      span: mk_sp(lo, hi) }\n     }\n \n-    fn parse_item_fn(&self, purity: purity) -> item_info {\n+    fn parse_item_fn(&self, purity: purity, abis: AbiSet) -> item_info {\n         let (ident, generics) = self.parse_fn_header();\n         let decl = self.parse_fn_decl(|p| p.parse_arg());\n         let (inner_attrs, body) = self.parse_inner_attrs_and_block(true);\n-        (ident, item_fn(decl, purity, generics, body), Some(inner_attrs))\n+        (ident,\n+         item_fn(decl, purity, abis, generics, body),\n+         Some(inner_attrs))\n     }\n \n     fn parse_method(&self) -> @method {\n@@ -3607,7 +3613,7 @@ pub impl Parser {\n     }\n \n     fn parse_foreign_mod_items(&self, sort: ast::foreign_mod_sort,\n-                               +abi: ast::ident,\n+                               +abis: AbiSet,\n                                +first_item_attrs: ~[attribute])\n                             -> foreign_mod {\n         // Shouldn't be any view items since we've already parsed an item attr\n@@ -3630,30 +3636,20 @@ pub impl Parser {\n         }\n         ast::foreign_mod {\n             sort: sort,\n-            abi: abi,\n+            abis: abis,\n             view_items: view_items,\n             items: items\n         }\n     }\n \n-    fn parse_item_foreign_mod(&self, lo: BytePos,\n+    fn parse_item_foreign_mod(&self,\n+                              lo: BytePos,\n+                              opt_abis: Option<AbiSet>,\n                               visibility: visibility,\n                               attrs: ~[attribute],\n                               items_allowed: bool)\n-                           -> item_or_view_item {\n-\n-        // Parse the ABI.\n-        let abi_opt;\n-        match *self.token {\n-            token::LIT_STR(copy found_abi) => {\n-                self.bump();\n-                abi_opt = Some(found_abi);\n-            }\n-            _ => {\n-                abi_opt = None;\n-            }\n-        }\n-\n+                           -> item_or_view_item\n+    {\n         let mut must_be_named_mod = false;\n         if self.is_keyword(&~\"mod\") {\n             must_be_named_mod = true;\n@@ -3688,14 +3684,10 @@ pub impl Parser {\n \n         // extern mod { ... }\n         if items_allowed && self.eat(&token::LBRACE) {\n-            let abi;\n-            match abi_opt {\n-                Some(found_abi) => abi = found_abi,\n-                None => abi = special_idents::c_abi,\n-            }\n+            let abis = opt_abis.get_or_default(AbiSet::C());\n \n             let (inner, next) = self.parse_inner_attrs_and_next();\n-            let m = self.parse_foreign_mod_items(sort, abi, next);\n+            let m = self.parse_foreign_mod_items(sort, abis, next);\n             self.expect(&token::RBRACE);\n \n             return iovi_item(self.mk_item(lo, self.last_span.hi, ident,\n@@ -3704,12 +3696,8 @@ pub impl Parser {\n                                                        Some(inner))));\n         }\n \n-        match abi_opt {\n-            None => {}  // OK.\n-            Some(_) => {\n-                self.span_err(*self.span, ~\"an ABI may not be specified \\\n-                                                here\");\n-            }\n+        if opt_abis.is_some() {\n+            self.span_err(*self.span, ~\"an ABI may not be specified here\");\n         }\n \n         // extern mod foo;\n@@ -3913,6 +3901,49 @@ pub impl Parser {\n         }\n     }\n \n+    fn parse_opt_abis(&self) -> Option<AbiSet> {\n+        match *self.token {\n+            token::LIT_STR(s) => {\n+                self.bump();\n+                let the_string = self.id_to_str(s);\n+                let mut words = ~[];\n+                for str::each_word(*the_string) |s| { words.push(s) }\n+                let mut abis = AbiSet::empty();\n+                for words.each |word| {\n+                    match abi::lookup(*word) {\n+                        Some(abi) => {\n+                            if abis.contains(abi) {\n+                                self.span_err(\n+                                    *self.span,\n+                                    fmt!(\"ABI `%s` appears twice\",\n+                                         *word));\n+                            } else {\n+                                abis.add(abi);\n+                            }\n+                        }\n+\n+                        None => {\n+                            self.span_err(\n+                                *self.span,\n+                                fmt!(\"illegal ABI: \\\n+                                      expected one of [%s], \\\n+                                      found `%s`\",\n+                                     str::connect_slices(\n+                                         abi::all_names(),\n+                                         \", \"),\n+                                     *word));\n+                        }\n+                    }\n+                }\n+                Some(abis)\n+            }\n+\n+            _ => {\n+                None\n+            }\n+        }\n+    }\n+\n     // parse one of the items or view items allowed by the\n     // flags; on failure, return iovi_none.\n     fn parse_item_or_view_item(\n@@ -3961,7 +3992,8 @@ pub impl Parser {\n             self.is_keyword(&~\"fn\") &&\n             !self.fn_expr_lookahead(self.look_ahead(1u)) {\n             self.bump();\n-            let (ident, item_, extra_attrs) = self.parse_item_fn(impure_fn);\n+            let (ident, item_, extra_attrs) =\n+                self.parse_item_fn(impure_fn, AbiSet::Rust());\n             return iovi_item(self.mk_item(lo, self.last_span.hi, ident, item_,\n                                           visibility,\n                                           maybe_append(attrs, extra_attrs)));\n@@ -3970,7 +4002,8 @@ pub impl Parser {\n             // PURE FUNCTION ITEM\n             self.obsolete(*self.last_span, ObsoletePurity);\n             self.expect_keyword(&~\"fn\");\n-            let (ident, item_, extra_attrs) = self.parse_item_fn(impure_fn);\n+            let (ident, item_, extra_attrs) =\n+                self.parse_item_fn(impure_fn, AbiSet::Rust());\n             return iovi_item(self.mk_item(lo, self.last_span.hi, ident, item_,\n                                           visibility,\n                                           maybe_append(attrs, extra_attrs)));\n@@ -3987,24 +4020,28 @@ pub impl Parser {\n             // UNSAFE FUNCTION ITEM (where items are allowed)\n             self.bump();\n             self.expect_keyword(&~\"fn\");\n-            let (ident, item_, extra_attrs) = self.parse_item_fn(unsafe_fn);\n+            let (ident, item_, extra_attrs) =\n+                self.parse_item_fn(unsafe_fn, AbiSet::Rust());\n             return iovi_item(self.mk_item(lo, self.last_span.hi, ident, item_,\n                                           visibility,\n                                           maybe_append(attrs, extra_attrs)));\n         }\n         if self.eat_keyword(&~\"extern\") {\n+            let opt_abis = self.parse_opt_abis();\n+\n             if items_allowed && self.eat_keyword(&~\"fn\") {\n                 // EXTERN FUNCTION ITEM\n+                let abis = opt_abis.get_or_default(AbiSet::C());\n                 let (ident, item_, extra_attrs) =\n-                    self.parse_item_fn(extern_fn);\n+                    self.parse_item_fn(extern_fn, abis);\n                 return iovi_item(self.mk_item(lo, self.last_span.hi, ident,\n                                               item_, visibility,\n                                               maybe_append(attrs,\n                                                            extra_attrs)));\n             }\n             if !foreign_items_allowed {\n                 // EXTERN MODULE ITEM\n-                return self.parse_item_foreign_mod(lo, visibility, attrs,\n+                return self.parse_item_foreign_mod(lo, opt_abis, visibility, attrs,\n                                                    items_allowed);\n             }\n         }"}, {"sha": "0ec7bdba3d13e9b8c2914d0c67a3c175c1d37d33", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 47, "deletions": 17, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/fbd8eae26de23cf00081229176fd7efd80943905/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd8eae26de23cf00081229176fd7efd80943905/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=fbd8eae26de23cf00081229176fd7efd80943905", "patch": "@@ -10,6 +10,8 @@\n \n use core::prelude::*;\n \n+use abi::AbiSet;\n+use abi;\n use ast::{RegionTyParamBound, TraitTyParamBound, required, provided};\n use ast;\n use ast_util;\n@@ -186,7 +188,8 @@ pub fn fun_to_str(decl: &ast::fn_decl, purity: ast::purity, name: ast::ident,\n                   generics: &ast::Generics, intr: @ident_interner) -> ~str {\n     do io::with_str_writer |wr| {\n         let s = rust_printer(wr, intr);\n-        print_fn(s, decl, purity, name, generics, opt_self_ty, ast::inherited);\n+        print_fn(s, decl, Some(purity), AbiSet::Rust(),\n+                 name, generics, opt_self_ty, ast::inherited);\n         end(s); // Close the head box\n         end(s); // Close the outer box\n         eof(s.s);\n@@ -405,7 +408,7 @@ pub fn print_type(s: @ps, &&ty: @ast::Ty) {\n       ast::ty_bare_fn(f) => {\n           let generics = ast::Generics {lifetimes: copy f.lifetimes,\n                                         ty_params: opt_vec::Empty};\n-          print_ty_fn(s, Some(f.abi), None, None,\n+          print_ty_fn(s, Some(f.abis), None, None,\n                       f.purity, ast::Many, &f.decl, None,\n                       Some(&generics), None);\n       }\n@@ -446,7 +449,7 @@ pub fn print_foreign_item(s: @ps, item: @ast::foreign_item) {\n     print_outer_attributes(s, item.attrs);\n     match item.node {\n       ast::foreign_item_fn(ref decl, purity, ref generics) => {\n-        print_fn(s, decl, purity, item.ident, generics, None,\n+        print_fn(s, decl, Some(purity), AbiSet::Rust(), item.ident, generics, None,\n                  ast::inherited);\n         end(s); // end head-ibox\n         word(s.s, ~\";\");\n@@ -485,11 +488,12 @@ pub fn print_item(s: @ps, &&item: @ast::item) {\n         end(s); // end the outer cbox\n \n       }\n-      ast::item_fn(ref decl, purity, ref typarams, ref body) => {\n+      ast::item_fn(ref decl, purity, abi, ref typarams, ref body) => {\n         print_fn(\n             s,\n             decl,\n-            purity,\n+            Some(purity),\n+            abi,\n             item.ident,\n             typarams,\n             None,\n@@ -508,8 +512,7 @@ pub fn print_item(s: @ps, &&item: @ast::item) {\n       }\n       ast::item_foreign_mod(ref nmod) => {\n         head(s, visibility_qualified(item.vis, ~\"extern\"));\n-        print_string(s, *s.intr.get(nmod.abi));\n-        nbsp(s);\n+        word_nbsp(s, nmod.abis.to_str());\n         match nmod.sort {\n             ast::named => {\n                 word_nbsp(s, ~\"mod\");\n@@ -817,7 +820,7 @@ pub fn print_method(s: @ps, meth: @ast::method) {\n     hardbreak_if_not_bol(s);\n     maybe_print_comment(s, meth.span.lo);\n     print_outer_attributes(s, meth.attrs);\n-    print_fn(s, &meth.decl, meth.purity,\n+    print_fn(s, &meth.decl, Some(meth.purity), AbiSet::Rust(),\n              meth.ident, &meth.generics, Some(meth.self_ty.node),\n              meth.vis);\n     word(s.s, ~\" \");\n@@ -1650,13 +1653,14 @@ pub fn print_self_ty(s: @ps, self_ty: ast::self_ty_) -> bool {\n \n pub fn print_fn(s: @ps,\n                 decl: &ast::fn_decl,\n-                purity: ast::purity,\n+                purity: Option<ast::purity>,\n+                abis: AbiSet,\n                 name: ast::ident,\n                 generics: &ast::Generics,\n                 opt_self_ty: Option<ast::self_ty_>,\n                 vis: ast::visibility) {\n     head(s, ~\"\");\n-    print_fn_header_info(s, purity, ast::Many, None, vis);\n+    print_fn_header_info(s, opt_self_ty, purity, abis, ast::Many, None, vis);\n     nbsp(s);\n     print_ident(s, name);\n     print_generics(s, generics);\n@@ -1905,7 +1909,7 @@ pub fn print_arg(s: @ps, input: ast::arg) {\n }\n \n pub fn print_ty_fn(s: @ps,\n-                   opt_abi: Option<ast::Abi>,\n+                   opt_abis: Option<AbiSet>,\n                    opt_sigil: Option<ast::Sigil>,\n                    opt_region: Option<@ast::Lifetime>,\n                    purity: ast::purity,\n@@ -1918,7 +1922,7 @@ pub fn print_ty_fn(s: @ps,\n \n     // Duplicates the logic in `print_fn_header_info()`.  This is because that\n     // function prints the sigil in the wrong place.  That should be fixed.\n-    print_opt_abi(s, opt_abi);\n+    print_extern_opt_abis(s, opt_abis);\n     print_opt_sigil(s, opt_sigil);\n     print_opt_lifetime(s, opt_region);\n     print_purity(s, purity);\n@@ -2146,9 +2150,22 @@ pub fn next_comment(s: @ps) -> Option<comments::cmnt> {\n     }\n }\n \n-pub fn print_opt_abi(s: @ps, opt_abi: Option<ast::Abi>) {\n-    match opt_abi {\n-        Some(ast::RustAbi) => { word_nbsp(s, ~\"extern\"); }\n+pub fn print_opt_purity(s: @ps, opt_purity: Option<ast::purity>) {\n+    match opt_purity {\n+        Some(ast::impure_fn) => { }\n+        Some(purity) => {\n+            word_nbsp(s, purity_to_str(purity));\n+        }\n+        None => {}\n+    }\n+}\n+\n+pub fn print_extern_opt_abis(s: @ps, opt_abis: Option<AbiSet>) {\n+    match opt_abis {\n+        Some(abis) => {\n+            word_nbsp(s, ~\"extern\");\n+            word_nbsp(s, abis.to_str());\n+        }\n         None => {}\n     };\n }\n@@ -2163,12 +2180,25 @@ pub fn print_opt_sigil(s: @ps, opt_sigil: Option<ast::Sigil>) {\n }\n \n pub fn print_fn_header_info(s: @ps,\n-                            purity: ast::purity,\n+                            opt_sty: Option<ast::self_ty_>,\n+                            opt_purity: Option<ast::purity>,\n+                            abis: AbiSet,\n                             onceness: ast::Onceness,\n                             opt_sigil: Option<ast::Sigil>,\n                             vis: ast::visibility) {\n     word(s.s, visibility_qualified(vis, ~\"\"));\n-    print_purity(s, purity);\n+\n+    if abis != AbiSet::Rust() {\n+        word_nbsp(s, ~\"extern\");\n+        word_nbsp(s, abis.to_str());\n+\n+        if opt_purity != Some(ast::extern_fn) {\n+            print_opt_purity(s, opt_purity);\n+        }\n+    } else {\n+        print_opt_purity(s, opt_purity);\n+    }\n+\n     print_onceness(s, onceness);\n     word(s.s, ~\"fn\");\n     print_opt_sigil(s, opt_sigil);"}, {"sha": "21c52f1bfcc06e76d2eef7bf7deff8b0bdfb64bd", "filename": "src/libsyntax/syntax.rc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fbd8eae26de23cf00081229176fd7efd80943905/src%2Flibsyntax%2Fsyntax.rc", "raw_url": "https://github.com/rust-lang/rust/raw/fbd8eae26de23cf00081229176fd7efd80943905/src%2Flibsyntax%2Fsyntax.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fsyntax.rc?ref=fbd8eae26de23cf00081229176fd7efd80943905", "patch": "@@ -39,6 +39,7 @@ pub mod opt_vec;\n pub mod attr;\n pub mod diagnostic;\n pub mod codemap;\n+pub mod abi;\n pub mod ast;\n pub mod ast_util;\n pub mod ast_map;"}, {"sha": "a994f2b5b2280da649ed68e07a08346cb29b16cb", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 20, "deletions": 10, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/fbd8eae26de23cf00081229176fd7efd80943905/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd8eae26de23cf00081229176fd7efd80943905/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=fbd8eae26de23cf00081229176fd7efd80943905", "patch": "@@ -10,6 +10,7 @@\n \n use core::prelude::*;\n \n+use abi::AbiSet;\n use ast::*;\n use ast;\n use ast_util;\n@@ -29,10 +30,18 @@ use opt_vec::OptVec;\n pub enum vt<E> { mk_vt(visitor<E>), }\n \n pub enum fn_kind<'self> {\n-    fk_item_fn(ident, &'self Generics, purity),   // fn foo()\n-    fk_method(ident, &'self Generics, &'self method),   // fn foo(&self)\n-    fk_anon(ast::Sigil),                    // fn@(x, y) { ... }\n-    fk_fn_block,                            // |x, y| ...\n+    // fn foo() or extern \"Abi\" fn foo()\n+    fk_item_fn(ident, &'self Generics, purity, AbiSet),\n+\n+    // fn foo(&self)\n+    fk_method(ident, &'self Generics, &'self method),\n+\n+    // fn@(x, y) { ... }\n+    fk_anon(ast::Sigil),\n+\n+    // |x, y| ...\n+    fk_fn_block,\n+\n     fk_dtor( // class destructor\n         &'self Generics,\n         &'self [attribute],\n@@ -43,8 +52,8 @@ pub enum fn_kind<'self> {\n \n pub fn name_of_fn(fk: &fn_kind) -> ident {\n     match *fk {\n-      fk_item_fn(name, _, _) | fk_method(name, _, _) => {\n-          /* FIXME (#2543) */ copy name\n+      fk_item_fn(name, _, _, _) | fk_method(name, _, _) => {\n+          name\n       }\n       fk_anon(*) | fk_fn_block(*) => parse::token::special_idents::anon,\n       fk_dtor(*)                  => parse::token::special_idents::dtor\n@@ -53,7 +62,7 @@ pub fn name_of_fn(fk: &fn_kind) -> ident {\n \n pub fn generics_of_fn(fk: &fn_kind) -> Generics {\n     match *fk {\n-        fk_item_fn(_, generics, _) |\n+        fk_item_fn(_, generics, _, _) |\n         fk_method(_, generics, _) |\n         fk_dtor(generics, _, _, _) => {\n             copy *generics\n@@ -144,12 +153,13 @@ pub fn visit_item<E>(i: @item, e: E, v: vt<E>) {\n             (v.visit_ty)(t, e, v);\n             (v.visit_expr)(ex, e, v);\n         }\n-        item_fn(ref decl, purity, ref generics, ref body) => {\n+        item_fn(ref decl, purity, abi, ref generics, ref body) => {\n             (v.visit_fn)(\n                 &fk_item_fn(\n-                    /* FIXME (#2543) */ copy i.ident,\n+                    i.ident,\n                     generics,\n-                    purity\n+                    purity,\n+                    abi\n                 ),\n                 decl,\n                 body,"}, {"sha": "e98fc4aac0a93ccc6f9faa37b9f9983ee9c4c9db", "filename": "src/test/auxiliary/cci_intrinsic.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fbd8eae26de23cf00081229176fd7efd80943905/src%2Ftest%2Fauxiliary%2Fcci_intrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd8eae26de23cf00081229176fd7efd80943905/src%2Ftest%2Fauxiliary%2Fcci_intrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_intrinsic.rs?ref=fbd8eae26de23cf00081229176fd7efd80943905", "patch": "@@ -10,19 +10,19 @@\n \n pub mod rusti {\n     #[abi = \"rust-intrinsic\"]\n-    pub extern {\n+    pub extern \"rust-intrinsic\" {\n         fn atomic_cxchg(dst: &mut int, old: int, src: int) -> int;\n         fn atomic_cxchg_acq(dst: &mut int, old: int, src: int) -> int;\n         fn atomic_cxchg_rel(dst: &mut int, old: int, src: int) -> int;\n \n         fn atomic_xchg(dst: &mut int, src: int) -> int;\n         fn atomic_xchg_acq(dst: &mut int, src: int) -> int;\n         fn atomic_xchg_rel(dst: &mut int, src: int) -> int;\n-        \n+\n         fn atomic_xadd(dst: &mut int, src: int) -> int;\n         fn atomic_xadd_acq(dst: &mut int, src: int) -> int;\n         fn atomic_xadd_rel(dst: &mut int, src: int) -> int;\n-        \n+\n         fn atomic_xsub(dst: &mut int, src: int) -> int;\n         fn atomic_xsub_acq(dst: &mut int, src: int) -> int;\n         fn atomic_xsub_rel(dst: &mut int, src: int) -> int;"}, {"sha": "85ef09cc2a6318ce5f50edcf6a24f8f8f1924dbb", "filename": "src/test/compile-fail/block-coerce-no-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fbd8eae26de23cf00081229176fd7efd80943905/src%2Ftest%2Fcompile-fail%2Fblock-coerce-no-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd8eae26de23cf00081229176fd7efd80943905/src%2Ftest%2Fcompile-fail%2Fblock-coerce-no-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fblock-coerce-no-2.rs?ref=fbd8eae26de23cf00081229176fd7efd80943905", "patch": "@@ -19,5 +19,5 @@ fn main() {\n     }\n \n     f(g);\n-    //~^ ERROR mismatched types: expected `extern fn(extern fn(extern fn()))`\n+    //~^ ERROR mismatched types: expected `extern \"Rust\" fn(extern \"Rust\" fn(extern \"Rust\" fn()))`\n }"}, {"sha": "136cc2b8680bcffed41c8547d132538b4c449a01", "filename": "src/test/compile-fail/main-wrong-type-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fbd8eae26de23cf00081229176fd7efd80943905/src%2Ftest%2Fcompile-fail%2Fmain-wrong-type-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd8eae26de23cf00081229176fd7efd80943905/src%2Ftest%2Fcompile-fail%2Fmain-wrong-type-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmain-wrong-type-2.rs?ref=fbd8eae26de23cf00081229176fd7efd80943905", "patch": "@@ -9,5 +9,5 @@\n // except according to those terms.\n \n fn main() -> char {\n-//~^ ERROR Wrong type in main function: found `extern fn() -> char`\n+//~^ ERROR Wrong type in main function: found `extern \"Rust\" fn() -> char`\n }"}, {"sha": "f3ecac3f406bd869e573d9530d0de02f5396096e", "filename": "src/test/compile-fail/main-wrong-type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fbd8eae26de23cf00081229176fd7efd80943905/src%2Ftest%2Fcompile-fail%2Fmain-wrong-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd8eae26de23cf00081229176fd7efd80943905/src%2Ftest%2Fcompile-fail%2Fmain-wrong-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmain-wrong-type.rs?ref=fbd8eae26de23cf00081229176fd7efd80943905", "patch": "@@ -14,5 +14,5 @@ struct S {\n }\n \n fn main(foo: S) {\n-//~^ ERROR Wrong type in main function: found `extern fn(S)`\n+//~^ ERROR Wrong type in main function: found `extern \"Rust\" fn(S)`\n }"}, {"sha": "b5789d737716b6f465f27fb237834d35c4f05d14", "filename": "src/test/compile-fail/missing-do.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fbd8eae26de23cf00081229176fd7efd80943905/src%2Ftest%2Fcompile-fail%2Fmissing-do.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd8eae26de23cf00081229176fd7efd80943905/src%2Ftest%2Fcompile-fail%2Fmissing-do.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmissing-do.rs?ref=fbd8eae26de23cf00081229176fd7efd80943905", "patch": "@@ -14,6 +14,6 @@ fn foo(f: &fn()) { f() }\n \n fn main() {\n     ~\"\" || 42; //~ ERROR binary operation || cannot be applied to type `~str`\n-    foo || {}; //~ ERROR binary operation || cannot be applied to type `extern fn(&fn())`\n+    foo || {}; //~ ERROR binary operation || cannot be applied to type `extern \"Rust\" fn(&fn())`\n     //~^ NOTE did you forget the `do` keyword for the call?\n }"}, {"sha": "b1f7828a2f425fd7368c42e6816c21508db3ea1e", "filename": "src/test/pretty/fn-types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fbd8eae26de23cf00081229176fd7efd80943905/src%2Ftest%2Fpretty%2Ffn-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd8eae26de23cf00081229176fd7efd80943905/src%2Ftest%2Fpretty%2Ffn-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Ffn-types.rs?ref=fbd8eae26de23cf00081229176fd7efd80943905", "patch": "@@ -10,7 +10,7 @@\n \n // pp-exact\n \n-fn from_foreign_fn(x: extern fn()) { }\n+fn from_foreign_fn(x: extern \"Rust\" fn()) { }\n fn from_stack_closure(x: &fn()) { }\n fn from_box_closure(x: @fn()) { }\n fn from_unique_closure(x: ~fn()) { }"}, {"sha": "d6a59fac57a4d9c4296e1acd5de8d3d43d2566d9", "filename": "src/test/run-pass/intrinsic-alignment.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fbd8eae26de23cf00081229176fd7efd80943905/src%2Ftest%2Frun-pass%2Fintrinsic-alignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd8eae26de23cf00081229176fd7efd80943905/src%2Ftest%2Frun-pass%2Fintrinsic-alignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fintrinsic-alignment.rs?ref=fbd8eae26de23cf00081229176fd7efd80943905", "patch": "@@ -12,7 +12,7 @@\n \n mod rusti {\n     #[abi = \"rust-intrinsic\"]\n-    pub extern {\n+    pub extern \"rust-intrinsic\" {\n         pub fn pref_align_of<T>() -> uint;\n         pub fn min_align_of<T>() -> uint;\n     }"}, {"sha": "42d4f5e4d2078394ba69d50bef6990e44e8498c0", "filename": "src/test/run-pass/intrinsic-atomics.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fbd8eae26de23cf00081229176fd7efd80943905/src%2Ftest%2Frun-pass%2Fintrinsic-atomics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd8eae26de23cf00081229176fd7efd80943905/src%2Ftest%2Frun-pass%2Fintrinsic-atomics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fintrinsic-atomics.rs?ref=fbd8eae26de23cf00081229176fd7efd80943905", "patch": "@@ -10,19 +10,19 @@\n \n mod rusti {\n     #[abi = \"rust-intrinsic\"]\n-    pub extern {\n+    pub extern \"rust-intrinsic\" {\n         pub fn atomic_cxchg(dst: &mut int, old: int, src: int) -> int;\n         pub fn atomic_cxchg_acq(dst: &mut int, old: int, src: int) -> int;\n         pub fn atomic_cxchg_rel(dst: &mut int, old: int, src: int) -> int;\n \n         pub fn atomic_xchg(dst: &mut int, src: int) -> int;\n         pub fn atomic_xchg_acq(dst: &mut int, src: int) -> int;\n         pub fn atomic_xchg_rel(dst: &mut int, src: int) -> int;\n-        \n+\n         pub fn atomic_xadd(dst: &mut int, src: int) -> int;\n         pub fn atomic_xadd_acq(dst: &mut int, src: int) -> int;\n         pub fn atomic_xadd_rel(dst: &mut int, src: int) -> int;\n-        \n+\n         pub fn atomic_xsub(dst: &mut int, src: int) -> int;\n         pub fn atomic_xsub_acq(dst: &mut int, src: int) -> int;\n         pub fn atomic_xsub_rel(dst: &mut int, src: int) -> int;"}, {"sha": "4e00b36cbebffb410867cfaa4d471d923322ad02", "filename": "src/test/run-pass/intrinsic-frame-address.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fbd8eae26de23cf00081229176fd7efd80943905/src%2Ftest%2Frun-pass%2Fintrinsic-frame-address.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd8eae26de23cf00081229176fd7efd80943905/src%2Ftest%2Frun-pass%2Fintrinsic-frame-address.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fintrinsic-frame-address.rs?ref=fbd8eae26de23cf00081229176fd7efd80943905", "patch": "@@ -13,7 +13,7 @@\n \n mod rusti {\n     #[abi = \"rust-intrinsic\"]\n-    pub extern {\n+    pub extern \"rust-intrinsic\" {\n         pub fn frame_address(f: &once fn(*u8));\n     }\n }"}, {"sha": "966061a80856d570b556848db5e34c291114c86a", "filename": "src/test/run-pass/intrinsic-move-val.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fbd8eae26de23cf00081229176fd7efd80943905/src%2Ftest%2Frun-pass%2Fintrinsic-move-val.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd8eae26de23cf00081229176fd7efd80943905/src%2Ftest%2Frun-pass%2Fintrinsic-move-val.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fintrinsic-move-val.rs?ref=fbd8eae26de23cf00081229176fd7efd80943905", "patch": "@@ -10,7 +10,7 @@\n \n mod rusti {\n     #[abi = \"rust-intrinsic\"]\n-    pub extern {\n+    pub extern \"rust-intrinsic\" {\n         pub fn move_val_init<T>(dst: &mut T, +src: T);\n         pub fn move_val<T>(dst: &mut T, +src: T);\n     }"}, {"sha": "b96ea8cbb7b43aaafa08cf60a436d5e383f0bb92", "filename": "src/test/run-pass/intrinsics-integer.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fbd8eae26de23cf00081229176fd7efd80943905/src%2Ftest%2Frun-pass%2Fintrinsics-integer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd8eae26de23cf00081229176fd7efd80943905/src%2Ftest%2Frun-pass%2Fintrinsics-integer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fintrinsics-integer.rs?ref=fbd8eae26de23cf00081229176fd7efd80943905", "patch": "@@ -13,8 +13,8 @@\n extern mod std;\n \n mod rusti {\n-    #[abi = \"rust-intrinsic\"]  \n-    pub extern {\n+    #[abi = \"rust-intrinsic\"]\n+    pub extern \"rust-intrinsic\" {\n         fn ctpop8(x: i8) -> i8;\n         fn ctpop16(x: i16) -> i16;\n         fn ctpop32(x: i32) -> i32;"}, {"sha": "60e32a56ee5d84ae1e53ca89b51d874a99dacc76", "filename": "src/test/run-pass/intrinsics-math.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fbd8eae26de23cf00081229176fd7efd80943905/src%2Ftest%2Frun-pass%2Fintrinsics-math.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd8eae26de23cf00081229176fd7efd80943905/src%2Ftest%2Frun-pass%2Fintrinsics-math.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fintrinsics-math.rs?ref=fbd8eae26de23cf00081229176fd7efd80943905", "patch": "@@ -15,8 +15,8 @@ extern mod std;\n use std::cmp::FuzzyEq;\n \n mod rusti {\n-    #[abi = \"rust-intrinsic\"]  \n-    pub extern {\n+    #[abi = \"rust-intrinsic\"]\n+    pub extern \"rust-intrinsic\" {\n         fn sqrtf32(x: f32) -> f32;\n         fn sqrtf64(x: f64) -> f64;\n         fn powif32(a: f32, x: i32) -> f32;"}, {"sha": "816c20ba35f49fef64a2ebe05595591671709562", "filename": "src/test/run-pass/issue-2718.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fbd8eae26de23cf00081229176fd7efd80943905/src%2Ftest%2Frun-pass%2Fissue-2718.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd8eae26de23cf00081229176fd7efd80943905/src%2Ftest%2Frun-pass%2Fissue-2718.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2718.rs?ref=fbd8eae26de23cf00081229176fd7efd80943905", "patch": "@@ -45,7 +45,6 @@ pub mod pipes {\n         }\n     }\n \n-    #[abi = \"rust-intrinsic\"]\n     mod rusti {\n       pub fn atomic_xchg(_dst: &mut int, _src: int) -> int { fail!(); }\n       pub fn atomic_xchg_acq(_dst: &mut int, _src: int) -> int { fail!(); }"}, {"sha": "38628367eb86d409fdaedfcd7b69fdbbef8fefdf", "filename": "src/test/run-pass/morestack-address.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fbd8eae26de23cf00081229176fd7efd80943905/src%2Ftest%2Frun-pass%2Fmorestack-address.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd8eae26de23cf00081229176fd7efd80943905/src%2Ftest%2Frun-pass%2Fmorestack-address.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmorestack-address.rs?ref=fbd8eae26de23cf00081229176fd7efd80943905", "patch": "@@ -11,7 +11,7 @@\n mod rusti {\n     #[nolink]\n     #[abi = \"rust-intrinsic\"]\n-    pub extern {\n+    pub extern \"rust-intrinsic\" {\n         pub fn morestack_addr() -> *();\n     }\n }"}, {"sha": "703852d20bd25a88c7b4b04423c8043333d78caa", "filename": "src/test/run-pass/rec-align-u32.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fbd8eae26de23cf00081229176fd7efd80943905/src%2Ftest%2Frun-pass%2Frec-align-u32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd8eae26de23cf00081229176fd7efd80943905/src%2Ftest%2Frun-pass%2Frec-align-u32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frec-align-u32.rs?ref=fbd8eae26de23cf00081229176fd7efd80943905", "patch": "@@ -12,7 +12,7 @@\n \n mod rusti {\n     #[abi = \"rust-intrinsic\"]\n-    pub extern {\n+    pub extern \"rust-intrinsic\" {\n         pub fn pref_align_of<T>() -> uint;\n         pub fn min_align_of<T>() -> uint;\n     }"}, {"sha": "96713d120be2534b3df17fe53fb77f7055ef3f42", "filename": "src/test/run-pass/rec-align-u64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fbd8eae26de23cf00081229176fd7efd80943905/src%2Ftest%2Frun-pass%2Frec-align-u64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd8eae26de23cf00081229176fd7efd80943905/src%2Ftest%2Frun-pass%2Frec-align-u64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frec-align-u64.rs?ref=fbd8eae26de23cf00081229176fd7efd80943905", "patch": "@@ -12,7 +12,7 @@\n \n mod rusti {\n     #[abi = \"rust-intrinsic\"]\n-    pub extern {\n+    pub extern \"rust-intrinsic\" {\n         pub fn pref_align_of<T>() -> uint;\n         pub fn min_align_of<T>() -> uint;\n     }"}, {"sha": "452bfbf90b1502c7048b12db7c0f70b28303dd94", "filename": "src/test/run-pass/x86stdcall2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fbd8eae26de23cf00081229176fd7efd80943905/src%2Ftest%2Frun-pass%2Fx86stdcall2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbd8eae26de23cf00081229176fd7efd80943905/src%2Ftest%2Frun-pass%2Fx86stdcall2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fx86stdcall2.rs?ref=fbd8eae26de23cf00081229176fd7efd80943905", "patch": "@@ -19,7 +19,7 @@ mod kernel32 {\n \n     #[cfg(target_os = \"win32\")]\n     #[abi = \"stdcall\"]\n-    pub extern {\n+    pub extern \"stdcall\" {\n         pub fn GetProcessHeap() -> HANDLE;\n         pub fn HeapAlloc(hHeap: HANDLE, dwFlags: DWORD, dwBytes: SIZE_T)\n                       -> LPVOID;"}]}