{"sha": "dc9d5e168977b9f3e2595b2c33aaf4c90f09ae81", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRjOWQ1ZTE2ODk3N2I5ZjNlMjU5NWIyYzMzYWFmNGM5MGYwOWFlODE=", "commit": {"author": {"name": "Lindsey Kuper", "email": "lkuper@mozilla.com", "date": "2011-05-28T00:58:22Z"}, "committer": {"name": "Lindsey Kuper", "email": "lkuper@mozilla.com", "date": "2011-05-28T01:20:43Z"}, "message": "Lots of comments, and some more descriptive names.", "tree": {"sha": "5d68f17a708dbd329937bb36b6e0bbf761ede7e9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5d68f17a708dbd329937bb36b6e0bbf761ede7e9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dc9d5e168977b9f3e2595b2c33aaf4c90f09ae81", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dc9d5e168977b9f3e2595b2c33aaf4c90f09ae81", "html_url": "https://github.com/rust-lang/rust/commit/dc9d5e168977b9f3e2595b2c33aaf4c90f09ae81", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dc9d5e168977b9f3e2595b2c33aaf4c90f09ae81/comments", "author": {"login": "lkuper", "id": 535218, "node_id": "MDQ6VXNlcjUzNTIxOA==", "avatar_url": "https://avatars.githubusercontent.com/u/535218?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lkuper", "html_url": "https://github.com/lkuper", "followers_url": "https://api.github.com/users/lkuper/followers", "following_url": "https://api.github.com/users/lkuper/following{/other_user}", "gists_url": "https://api.github.com/users/lkuper/gists{/gist_id}", "starred_url": "https://api.github.com/users/lkuper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lkuper/subscriptions", "organizations_url": "https://api.github.com/users/lkuper/orgs", "repos_url": "https://api.github.com/users/lkuper/repos", "events_url": "https://api.github.com/users/lkuper/events{/privacy}", "received_events_url": "https://api.github.com/users/lkuper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lkuper", "id": 535218, "node_id": "MDQ6VXNlcjUzNTIxOA==", "avatar_url": "https://avatars.githubusercontent.com/u/535218?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lkuper", "html_url": "https://github.com/lkuper", "followers_url": "https://api.github.com/users/lkuper/followers", "following_url": "https://api.github.com/users/lkuper/following{/other_user}", "gists_url": "https://api.github.com/users/lkuper/gists{/gist_id}", "starred_url": "https://api.github.com/users/lkuper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lkuper/subscriptions", "organizations_url": "https://api.github.com/users/lkuper/orgs", "repos_url": "https://api.github.com/users/lkuper/repos", "events_url": "https://api.github.com/users/lkuper/events{/privacy}", "received_events_url": "https://api.github.com/users/lkuper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b6e0c5829f5bb87b9a3f0f74b1d98f6ea4cc8cef", "url": "https://api.github.com/repos/rust-lang/rust/commits/b6e0c5829f5bb87b9a3f0f74b1d98f6ea4cc8cef", "html_url": "https://github.com/rust-lang/rust/commit/b6e0c5829f5bb87b9a3f0f74b1d98f6ea4cc8cef"}], "stats": {"total": 265, "additions": 209, "deletions": 56}, "files": [{"sha": "0de35b9f006a4bdbdcca4a068eb49ef0d824ff5b", "filename": "src/comp/lib/llvm.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/dc9d5e168977b9f3e2595b2c33aaf4c90f09ae81/src%2Fcomp%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc9d5e168977b9f3e2595b2c33aaf4c90f09ae81/src%2Fcomp%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Flib%2Fllvm.rs?ref=dc9d5e168977b9f3e2595b2c33aaf4c90f09ae81", "patch": "@@ -886,7 +886,13 @@ native mod llvm = llvm_lib {\n native mod rustllvm = llvm_lib {\n }\n \n-/* Slightly more terse object-interface to LLVM's 'builder' functions. */\n+/* Slightly more terse object-interface to LLVM's 'builder' functions. For the\n+ * most part, build.Foo() wraps LLVMBuildFoo(), threading the correct\n+ * BuilderRef B into place.  A BuilderRef is a cursor-like LLVM value that\n+ * inserts instructions for a particular BasicBlockRef at a particular\n+ * position; for our purposes, it always inserts at the end of the basic block\n+ * it's attached to.  \n+ */\n \n // FIXME: Do we want to support mutable object fields?\n obj builder(BuilderRef B, @mutable bool terminated) {"}, {"sha": "9fe5d70bf7134b71ce5fcf9ac56cae6d510f359d", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 202, "deletions": 55, "changes": 257, "blob_url": "https://github.com/rust-lang/rust/blob/dc9d5e168977b9f3e2595b2c33aaf4c90f09ae81/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc9d5e168977b9f3e2595b2c33aaf4c90f09ae81/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=dc9d5e168977b9f3e2595b2c33aaf4c90f09ae81", "patch": "@@ -129,44 +129,155 @@ type local_ctxt = rec(vec[str] path,\n                       @crate_ctxt ccx);\n \n \n+// The type used for llself.\n type self_vt = rec(ValueRef v, ty::t t);\n \n-state type fn_ctxt = rec(ValueRef llfn,\n-                         ValueRef lltaskptr,\n-                         ValueRef llenv,\n-                         ValueRef llretptr,\n-                         mutable BasicBlockRef llallocas,\n-                         mutable BasicBlockRef llcopyargs,\n-                         mutable BasicBlockRef llderivedtydescs,\n-                         mutable option::t[self_vt] llself,\n-                         mutable option::t[ValueRef] lliterbody,\n-                         hashmap[ast::def_id, ValueRef] llargs,\n-                         hashmap[ast::def_id, ValueRef] llobjfields,\n-                         hashmap[ast::def_id, ValueRef] lllocals,\n-                         hashmap[ast::def_id, ValueRef] llupvars,\n-                         mutable vec[ValueRef] lltydescs,\n-                         hashmap[ty::t, derived_tydesc_info] derived_tydescs,\n-                         ast::span sp,\n-                         @local_ctxt lcx);\n+// Function context.  Every LLVM function we create will have one of these.\n+state type fn_ctxt = rec(\n+    // The ValueRef returned from a call to llvm::LLVMAddFunction; the address\n+    // of the first instruction in the sequence of instructions for this\n+    // function that will go in the .text section of the executable we're\n+    // generating.\n+    ValueRef llfn,\n+\n+    // The three implicit arguments that arrive in the function we're\n+    // creating.  For instance, foo(int, int) is really foo(ret*, task*, env*,\n+    // int, int).  These are also available via llvm::LLVMGetParam(llfn, uint)\n+    // where uint = 2, 0, 1 respectively, but we unpack them here for\n+    // convenience.\n+    ValueRef lltaskptr,\n+    ValueRef llenv,\n+    ValueRef llretptr,\n+    \n+    // The next three elements: \"hoisted basic blocks\" containing\n+    // administrative activities that have to happen in only one place in the\n+    // function, due to LLVM's quirks.\n+\n+    // A block for all the function's allocas, so that LLVM will coalesce them\n+    // into a single alloca.\n+    mutable BasicBlockRef llallocas, \n+\n+    // A block containing code that copies incoming arguments to space already\n+    // allocated by code in the llallocas block.  (LLVM requires that\n+    // arguments be copied to local allocas before allowing most any operation\n+    // to be performed on them.)\n+    mutable BasicBlockRef llcopyargs,\n+\n+    // A block containing derived tydescs received from the runtime.  See\n+    // description of derived_tydescs, below.\n+    mutable BasicBlockRef llderivedtydescs,\n+\n+    // FIXME: Is llcopyargs actually the block containing the allocas for\n+    // incoming function arguments?  Or is it merely the block containing code\n+    // that copies incoming args to space already alloca'd by code in\n+    // llallocas?\n+\n+    // The 'self' object currently in use in this function, if there is one.\n+    mutable option::t[self_vt] llself,\n+\n+    // If this function is actually a iter, a block containing the code called\n+    // whenever the iter calls 'put'.\n+    mutable option::t[ValueRef] lliterbody,\n+\n+    // The next four items: hash tables mapping from AST def_ids to\n+    // LLVM-stuff-in-the-frame.\n+\n+    // Maps arguments to allocas created for them in llallocas.\n+    hashmap[ast::def_id, ValueRef] llargs,\n+\n+    // Maps fields in objects to pointers into the interior of llself's body.\n+    hashmap[ast::def_id, ValueRef] llobjfields,\n+\n+    // Maps the def_ids for local variables to the allocas created for them in\n+    // llallocas.\n+    hashmap[ast::def_id, ValueRef] lllocals,\n+\n+    // The same as above, but for variables accessed via the frame pointer we\n+    // pass into an iter, for access to the static environment of the\n+    // iter-calling frame.\n+    hashmap[ast::def_id, ValueRef] llupvars,\n+\n+    // For convenience, a vector of the incoming tydescs for each of this\n+    // functions type parameters, fetched via llvm::LLVMGetParam.  For\n+    // example, for a function foo[A, B, C](), lltydescs contains the\n+    // ValueRefs for the tydescs for A, B, and C.\n+    mutable vec[ValueRef] lltydescs,\n+\n+    // Derived tydescs are tydescs created at runtime, for types that involve\n+    // type parameters inside type constructors.  For example, suppose a\n+    // function parameterized by T creates a vector of type vec[T].  The\n+    // function doesn't know what T is until runtime, and the function's\n+    // caller knows T but doesn't know that a vector is involved.  So a tydesc\n+    // for vec[T] can't be created until runtime, when information about both\n+    // \"vec\" and \"T\" are available.  When such a tydesc is created, we cache\n+    // it in the derived_tydescs table for the next time that such a tydesc is\n+    // needed.\n+    hashmap[ty::t, derived_tydesc_info] derived_tydescs,\n+\n+    // The source span where this function comes from, for error reporting.\n+    ast::span sp,\n+\n+    // This function's enclosing local context.\n+    @local_ctxt lcx\n+    );\n \n tag cleanup {\n     clean(fn(&@block_ctxt cx) -> result);\n }\n \n-\n tag block_kind {\n+    // A scope block is a basic block created by translating a block { ... }\n+    // the the source language.  Since these blocks create variable scope, any\n+    // variables created in them that are still live at the end of the block\n+    // must be dropped and cleaned up when the block ends.\n     SCOPE_BLOCK;\n+\n+    // A basic block created from the body of a loop.  Contains pointers to\n+    // which block to jump to in the case of \"continue\" or \"break\", with the\n+    // \"continue\" block optional, because \"while\" and \"do while\" don't support\n+    // \"continue\" (TODO: is this intentional?)\n     LOOP_SCOPE_BLOCK(option::t[@block_ctxt], @block_ctxt);\n+\n+    // A non-scope block is a basic block created as a translation artifact\n+    // from translating code that expresses conditional logic rather than by\n+    // explicit { ... } block structure in the source language.  It's called a\n+    // non-scope block because it doesn't introduce a new variable scope.\n     NON_SCOPE_BLOCK;\n }\n \n-state type block_ctxt = rec(BasicBlockRef llbb,\n-                            builder build,\n-                            block_parent parent,\n-                            block_kind kind,\n-                            mutable vec[cleanup] cleanups,\n-                            ast::span sp,\n-                            @fn_ctxt fcx);\n+// Basic block context.  We create a block context for each basic block\n+// (single-entry, single-exit sequence of instructions) we generate from Rust\n+// code.  Each basic block we generate is attached to a function, typically\n+// with many basic blocks per function.  All the basic blocks attached to a\n+// function are organized as a directed graph.\n+state type block_ctxt = rec(\n+    // The BasicBlockRef returned from a call to\n+    // llvm::LLVMAppendBasicBlock(llfn, name), which adds a basic block to the\n+    // function pointed to by llfn.  We insert instructions into that block by\n+    // way of this block context.\n+    BasicBlockRef llbb,\n+\n+    // The llvm::builder object serving as an interface to LLVM's LLVMBuild*\n+    // functions.\n+    builder build,\n+\n+    // The block pointing to this one in the function's digraph.\n+    block_parent parent,\n+\n+    // The 'kind' of basic block this is.\n+    block_kind kind,\n+\n+    // A list of functions that run at the end of translating this block,\n+    // cleaning up any variables that were introduced in the block and need to\n+    // go out of scope at the end of it.\n+    mutable vec[cleanup] cleanups,\n+\n+    // The source span where this block comes from, for error reporting.\n+    ast::span sp,\n+\n+    // The function context for the function to which this block is attached.\n+    @fn_ctxt fcx\n+    );\n \n // FIXME: we should be able to use option::t[@block_parent] here but\n // the infinite-tag check in rustboot gets upset.\n@@ -3115,7 +3226,7 @@ tag copy_action {\n     DROP_EXISTING;\n }\n \n-fn copy_ty(&@block_ctxt cx,\n+fn copy_val(&@block_ctxt cx,\n            copy_action action,\n            ValueRef dst,\n            ValueRef src,\n@@ -3143,7 +3254,7 @@ fn copy_ty(&@block_ctxt cx,\n         ret memmove_ty(r.bcx, dst, src, t);\n     }\n \n-    cx.fcx.lcx.ccx.sess.bug(\"unexpected type in trans::copy_ty: \" +\n+    cx.fcx.lcx.ccx.sess.bug(\"unexpected type in trans::copy_val: \" +\n                         ty::ty_to_str(cx.fcx.lcx.ccx.tcx, t));\n     fail;\n }\n@@ -3263,7 +3374,7 @@ fn trans_unary(&@block_ctxt cx, ast::unop op,\n                 body = sub.bcx.build.PointerCast(body, llety);\n             }\n \n-            sub = copy_ty(sub.bcx, INIT, body, e_val, e_ty);\n+            sub = copy_val(sub.bcx, INIT, body, e_val, e_ty);\n             ret res(sub.bcx, box);\n         }\n         case (ast::deref) {\n@@ -3353,7 +3464,7 @@ fn trans_vec_add(&@block_ctxt cx, &ty::t t,\n                  ValueRef lhs, ValueRef rhs) -> result {\n     auto r = alloc_ty(cx, t);\n     auto tmp = r.val;\n-    r = copy_ty(r.bcx, INIT, tmp, lhs, t);\n+    r = copy_val(r.bcx, INIT, tmp, lhs, t);\n     auto bcx = trans_vec_append(r.bcx, t, tmp, rhs).bcx;\n     tmp = load_if_immediate(bcx, tmp, t);\n     find_scope_cx(cx).cleanups +=\n@@ -3681,7 +3792,7 @@ fn trans_for(&@block_ctxt cx,\n \n         cx.build.Br(scope_cx.llbb);\n         auto local_res = alloc_local(scope_cx, local);\n-        auto bcx = copy_ty(local_res.bcx, INIT, local_res.val, curr, t).bcx;\n+        auto bcx = copy_val(local_res.bcx, INIT, local_res.val, curr, t).bcx;\n         scope_cx.cleanups +=\n             [clean(bind drop_slot(_, local_res.val, t))];\n         bcx = trans_block(bcx, body).bcx;\n@@ -4113,7 +4224,7 @@ fn trans_pat_binding(&@block_ctxt cx, &@ast::pat pat,\n                 bcx.fcx.lllocals.insert(def_id, dst);\n                 bcx.cleanups +=\n                     [clean(bind drop_slot(_, dst, t))];\n-                ret copy_ty(bcx, INIT, dst, llval, t);\n+                ret copy_val(bcx, INIT, dst, llval, t);\n             }\n         }\n         case (ast::pat_tag(_, ?subpats, ?ann)) {\n@@ -4846,7 +4957,7 @@ fn trans_bind(&@block_ctxt cx, &@ast::expr f,\n             for (ValueRef v in bound_vals) {\n                 auto bound = bcx.build.GEP(bindings,\n                                            [C_int(0), C_int(i as int)]);\n-                bcx = copy_ty(bcx, INIT, bound, v, bound_tys.(i)).bcx;\n+                bcx = copy_val(bcx, INIT, bound, v, bound_tys.(i)).bcx;\n                 i += 1u;\n             }\n \n@@ -5180,7 +5291,7 @@ fn trans_tup(&@block_ctxt cx, &vec[ast::elt] elts,\n         bcx = src_res.bcx;\n         auto dst_res = GEP_tup_like(bcx, t, tup_val, [0, i]);\n         bcx = dst_res.bcx;\n-        bcx = copy_ty(src_res.bcx, INIT, dst_res.val, src_res.val, e_ty).bcx;\n+        bcx = copy_val(src_res.bcx, INIT, dst_res.val, src_res.val, e_ty).bcx;\n         i += 1;\n     }\n     ret res(bcx, tup_val);\n@@ -5250,7 +5361,7 @@ fn trans_vec(&@block_ctxt cx, &vec[@ast::expr] args,\n             dst_val = dst_res.val;\n         }\n \n-        bcx = copy_ty(bcx, INIT, dst_val, src_res.val, unit_ty).bcx;\n+        bcx = copy_val(bcx, INIT, dst_val, src_res.val, unit_ty).bcx;\n         i += 1;\n     }\n     auto fill = bcx.build.GEP(vec_val,\n@@ -5310,7 +5421,7 @@ fn trans_rec(&@block_ctxt cx, &vec[ast::field] fields,\n         }\n \n         bcx = src_res.bcx;\n-        bcx = copy_ty(bcx, INIT, dst_res.val, src_res.val, e_ty).bcx;\n+        bcx = copy_val(bcx, INIT, dst_res.val, src_res.val, e_ty).bcx;\n         i += 1;\n     }\n     ret res(bcx, rec_val);\n@@ -5376,7 +5487,7 @@ fn trans_expr(&@block_ctxt cx, &@ast::expr e) -> result {\n             auto rhs_res = trans_expr(lhs_res.res.bcx, src);\n             auto t = node_ann_type(cx.fcx.lcx.ccx, ann);\n             // FIXME: calculate copy init-ness in typestate.\n-            ret copy_ty(rhs_res.bcx, DROP_EXISTING,\n+            ret copy_val(rhs_res.bcx, DROP_EXISTING,\n                         lhs_res.res.val, rhs_res.val, t);\n         }\n \n@@ -5401,7 +5512,7 @@ fn trans_expr(&@block_ctxt cx, &@ast::expr e) -> result {\n             auto v = trans_eager_binop(rhs_res.bcx, op, t,\n                                        lhs_val, rhs_res.val);\n             // FIXME: calculate copy init-ness in typestate.\n-            ret copy_ty(v.bcx, DROP_EXISTING,\n+            ret copy_val(v.bcx, DROP_EXISTING,\n                         lhs_res.res.val, v.val, t);\n         }\n \n@@ -5752,7 +5863,7 @@ fn trans_ret(&@block_ctxt cx, &option::t[@ast::expr] e) -> result {\n             auto r = trans_expr(cx, x);\n             bcx = r.bcx;\n             val = r.val;\n-            bcx = copy_ty(bcx, INIT, cx.fcx.llretptr, val, t).bcx;\n+            bcx = copy_val(bcx, INIT, cx.fcx.llretptr, val, t).bcx;\n         }\n         case (_) {\n             auto t = llvm::LLVMGetElementType(val_ty(cx.fcx.llretptr));\n@@ -6029,7 +6140,7 @@ fn trans_send(&@block_ctxt cx, &@ast::expr lhs, &@ast::expr rhs,\n \n     auto data_alloc = alloc_ty(bcx, unit_ty);\n     bcx = data_alloc.bcx;\n-    auto data_tmp = copy_ty(bcx, INIT, data_alloc.val, data.val, unit_ty);\n+    auto data_tmp = copy_val(bcx, INIT, data_alloc.val, data.val, unit_ty);\n     bcx = data_tmp.bcx;\n \n     find_scope_cx(bcx).cleanups +=\n@@ -6069,7 +6180,7 @@ fn recv_val(&@block_ctxt cx, ValueRef lhs, &@ast::expr rhs,\n                    [bcx.fcx.lltaskptr, lldataptr, llportptr]);\n \n     auto data_load = load_if_immediate(bcx, lhs, unit_ty);\n-    auto cp = copy_ty(bcx, action, lhs, data_load, unit_ty);\n+    auto cp = copy_val(bcx, action, lhs, data_load, unit_ty);\n     bcx = cp.bcx;\n \n     // TODO: Any cleanup need to be done here?\n@@ -6119,9 +6230,9 @@ fn trans_anon_obj(&@block_ctxt cx, &ast::span sp,\n     alt (anon_obj.with_obj) {\n         case (none[@ast::expr]) { }\n         case (some[@ast::expr](?e)) {\n-            // Translating with_obj returns a pointer to a 2-word value.  We\n-            // want to allocate space for this value in our outer object, then\n-            // copy it into the outer object.\n+            // Translating with_obj returns a ValueRef (pointer to a 2-word\n+            // value) wrapped in a result.  We want to allocate space for this\n+            // value in our outer object, then copy it into the outer object.\n             with_obj_val = some[result](trans_expr(cx, e));\n         }\n     }\n@@ -6164,7 +6275,7 @@ fn init_local(&@block_ctxt cx, &@ast::local local) -> result {\n             alt (init.op) {\n                 case (ast::init_assign) {\n                     auto sub = trans_expr(bcx, init.expr);\n-                    bcx = copy_ty(sub.bcx, INIT, llptr, sub.val, ty).bcx;\n+                    bcx = copy_val(sub.bcx, INIT, llptr, sub.val, ty).bcx;\n                 }\n                 case (ast::init_recv) {\n                     bcx = recv_val(bcx, llptr, init.expr, ty, INIT).bcx;\n@@ -6273,7 +6384,13 @@ fn new_raw_block_ctxt(&@fn_ctxt fcx, BasicBlockRef llbb) -> @block_ctxt {\n              fcx=fcx);\n }\n \n-\n+// trans_block_cleanups: Go through all the cleanups attached to this\n+// block_ctxt and execute them.  \n+//\n+// When translating a block that introdces new variables during its scope, we\n+// need to make sure those variables go out of scope when the block ends.  We\n+// do that by running a 'cleanup' function for each variable.\n+// trans_block_cleanups runs all the cleanup functions for the block.\n fn trans_block_cleanups(&@block_ctxt cx,\n                         &@block_ctxt cleanup_cx) -> @block_ctxt {\n     auto bcx = cx;\n@@ -6407,7 +6524,7 @@ fn trans_block(&@block_ctxt cx, &ast::block b) -> result {\n                     zero_alloca(llbcx, res_alloca.val, r_ty);\n \n                     // Now we're working in our own block context again\n-                    auto res_copy = copy_ty(bcx, INIT,\n+                    auto res_copy = copy_val(bcx, INIT,\n                                             res_alloca.val, r.val, r_ty);\n                     bcx = res_copy.bcx;\n \n@@ -6713,6 +6830,8 @@ fn finish_fn(&@fn_ctxt fcx, BasicBlockRef lltop) {\n     new_builder(fcx.llderivedtydescs).Br(lltop);\n }\n \n+// trans_fn: creates an LLVM function corresponding to a source language\n+// function.\n fn trans_fn(@local_ctxt cx, &ast::span sp, &ast::_fn f, ast::def_id fid,\n             option::t[tup(TypeRef, ty::t)] ty_self,\n             &vec[ast::ty_param] ty_params, &ast::ann ann) {\n@@ -6751,7 +6870,7 @@ fn trans_fn(@local_ctxt cx, &ast::span sp, &ast::_fn f, ast::def_id fid,\n     finish_fn(fcx, lltop);\n }\n \n-fn trans_vtbl(@local_ctxt cx,\n+fn create_vtbl(@local_ctxt cx,\n               TypeRef llself_ty,\n               ty::t self_ty,\n               &ast::_obj ob,\n@@ -6828,11 +6947,21 @@ fn trans_dtor(@local_ctxt cx,\n     ret llfn;\n }\n \n+// trans_obj: creates an LLVM function that is the object constructor for the\n+// object being translated.\n fn trans_obj(@local_ctxt cx, &ast::span sp, &ast::_obj ob, ast::def_id oid,\n              &vec[ast::ty_param] ty_params, &ast::ann ann) {\n+    // To make a function, we have to create a function context and, inside\n+    // that, a number of block contexts for which code is generated.\n+\n     auto ccx = cx.ccx;\n+\n     auto llctor_decl = ccx.item_ids.get(oid);\n \n+    // Much like trans_fn, we must create an LLVM function, but since we're\n+    // starting with an ast::_obj rather than an ast::_fn, we have some setup\n+    // work to do.\n+\n     // Translate obj ctor args to function arguments.\n     let vec[ast::arg] fn_args = [];\n     for (ast::obj_field f in ob.fields) {\n@@ -6848,14 +6977,17 @@ fn trans_obj(@local_ctxt cx, &ast::span sp, &ast::_obj ob, ast::def_id oid,\n     let vec[ty::arg] arg_tys = arg_tys_of_fn(ccx, ann);\n     copy_args_to_allocas(fcx, fn_args, arg_tys);\n \n+    //  Make the first block context in the function and keep a handle on it\n+    //  to pass to finish_fn later.\n     auto bcx = new_top_block_ctxt(fcx);\n     auto lltop = bcx.llbb;\n \n     auto self_ty = ret_ty_of_fn(ccx, ann);\n     auto llself_ty = type_of(ccx, sp, self_ty);\n     auto pair = bcx.fcx.llretptr;\n \n-    auto vtbl = trans_vtbl(cx, llself_ty, self_ty, ob, ty_params);\n+    auto vtbl = create_vtbl(cx, llself_ty, self_ty, ob, ty_params);\n+\n     auto pair_vtbl = bcx.build.GEP(pair,\n                                    [C_int(0),\n                                        C_int(abi::obj_field_vtbl)]);\n@@ -6874,6 +7006,7 @@ fn trans_obj(@local_ctxt cx, &ast::span sp, &ast::_obj ob, ast::def_id oid,\n         bcx.build.Store(C_null(llbox_ty), pair_box);\n     } else {\n         // Malloc a box for the body and copy args in.\n+\n         let vec[ty::t] obj_fields = [];\n         for (ty::arg a in arg_tys) {\n             vec::push[ty::t](obj_fields, a.ty);\n@@ -6886,12 +7019,19 @@ fn trans_obj(@local_ctxt cx, &ast::span sp, &ast::_obj ob, ast::def_id oid,\n             vec::push[ty::t](tps, tydesc_ty);\n         }\n \n+        // typarams_ty = [typaram_ty, ...]\n         let ty::t typarams_ty = ty::mk_imm_tup(ccx.tcx, tps);\n-        let ty::t fields_ty = ty::mk_imm_tup(ccx.tcx, obj_fields);\n+\n+        // fields_ty = [field_ty, ...]\n+        let ty::t fields_ty = ty::mk_imm_tup(ccx.tcx, obj_fields); \n+\n+        // body_ty = [tydesc_ty, [typaram_ty, ...], [field_ty, ...]]\n         let ty::t body_ty = ty::mk_imm_tup(ccx.tcx,\n                                           [tydesc_ty,\n-                                              typarams_ty,\n-                                              fields_ty]);\n+                                           typarams_ty,\n+                                           fields_ty]);\n+\n+        // boxed_body_ty = [[tydesc_ty, [typaram_ty, ...], [field_ty, ...]]]\n         let ty::t boxed_body_ty = ty::mk_imm_box(ccx.tcx, body_ty);\n \n         // Malloc a box for the body.\n@@ -6900,12 +7040,19 @@ fn trans_obj(@local_ctxt cx, &ast::span sp, &ast::_obj ob, ast::def_id oid,\n         auto rc = GEP_tup_like(bcx, boxed_body_ty, box.val,\n                                [0, abi::box_rc_field_refcnt]);\n         bcx = rc.bcx;\n+\n+        // We've now created a structure that looks like:\n+        // [refcount, [tydesc_ty, [typaram_ty, ...], [field_ty, ...]]]\n+\n         auto body = GEP_tup_like(bcx, boxed_body_ty, box.val,\n                                  [0, abi::box_rc_field_body]);\n         bcx = body.bcx;\n+\n+\n         bcx.build.Store(C_int(1), rc.val);\n \n-        // Store body tydesc.\n+        // Put together a tydesc for the body, so that the object can later be\n+        // freed by calling through its tydesc.\n         auto body_tydesc =\n             GEP_tup_like(bcx, body_ty, body.val,\n                          [0, abi::obj_body_elt_tydesc]);\n@@ -6938,7 +7085,7 @@ fn trans_obj(@local_ctxt cx, &ast::span sp, &ast::_obj ob, ast::def_id oid,\n             auto capture = GEP_tup_like(bcx, typarams_ty, body_typarams.val,\n                                         [0, i]);\n             bcx = capture.bcx;\n-            bcx = copy_ty(bcx, INIT, capture.val, typaram, tydesc_ty).bcx;\n+            bcx = copy_val(bcx, INIT, capture.val, typaram, tydesc_ty).bcx;\n             i += 1;\n         }\n \n@@ -6955,7 +7102,7 @@ fn trans_obj(@local_ctxt cx, &ast::span sp, &ast::_obj ob, ast::def_id oid,\n             auto field = GEP_tup_like(bcx, fields_ty, body_fields.val,\n                                       [0, i]);\n             bcx = field.bcx;\n-            bcx = copy_ty(bcx, INIT, field.val, arg, arg_tys.(i).ty).bcx;\n+            bcx = copy_val(bcx, INIT, field.val, arg, arg_tys.(i).ty).bcx;\n             i += 1;\n         }\n         // Store box ptr in outer pair.\n@@ -7040,7 +7187,7 @@ fn trans_tag_variant(@local_ctxt cx, ast::def_id tag_id,\n             llargval = bcx.build.Load(llargptr);\n         }\n \n-        rslt = copy_ty(bcx, INIT, lldestptr, llargval, arg_ty);\n+        rslt = copy_val(bcx, INIT, lldestptr, llargval, arg_ty);\n         bcx = rslt.bcx;\n \n         i += 1u;"}]}