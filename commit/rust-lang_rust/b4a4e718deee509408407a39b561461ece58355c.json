{"sha": "b4a4e718deee509408407a39b561461ece58355c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI0YTRlNzE4ZGVlZTUwOTQwODQwN2EzOWI1NjE0NjFlY2U1ODM1NWM=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-08-24T02:45:59Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-08-24T17:15:36Z"}, "message": "typeck/pat.rs: extract `check_pat_ref`.", "tree": {"sha": "19208bb0b580b1acecfc9d92f77d276bb0063059", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/19208bb0b580b1acecfc9d92f77d276bb0063059"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b4a4e718deee509408407a39b561461ece58355c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b4a4e718deee509408407a39b561461ece58355c", "html_url": "https://github.com/rust-lang/rust/commit/b4a4e718deee509408407a39b561461ece58355c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b4a4e718deee509408407a39b561461ece58355c/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3de221a862b064430bc8c5727e9e1346ad85c27e", "url": "https://api.github.com/repos/rust-lang/rust/commits/3de221a862b064430bc8c5727e9e1346ad85c27e", "html_url": "https://github.com/rust-lang/rust/commit/3de221a862b064430bc8c5727e9e1346ad85c27e"}], "stats": {"total": 99, "additions": 55, "deletions": 44}, "files": [{"sha": "55a9360b83f190bbea1caa4bfdbd755a9d010103", "filename": "src/librustc_typeck/check/pat.rs", "status": "modified", "additions": 55, "deletions": 44, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/b4a4e718deee509408407a39b561461ece58355c/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4a4e718deee509408407a39b561461ece58355c/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs?ref=b4a4e718deee509408407a39b561461ece58355c", "patch": "@@ -111,50 +111,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 self.check_pat_box(pat.span, inner, expected, def_bm, discrim_span)\n             }\n             PatKind::Ref(ref inner, mutbl) => {\n-                let expected = self.shallow_resolve(expected);\n-                if self.check_dereferencable(pat.span, expected, &inner) {\n-                    // `demand::subtype` would be good enough, but using\n-                    // `eqtype` turns out to be equally general. See (*)\n-                    // below for details.\n-\n-                    // Take region, inner-type from expected type if we\n-                    // can, to avoid creating needless variables.  This\n-                    // also helps with the bad interactions of the given\n-                    // hack detailed in (*) below.\n-                    debug!(\"check_pat_walk: expected={:?}\", expected);\n-                    let (rptr_ty, inner_ty) = match expected.sty {\n-                        ty::Ref(_, r_ty, r_mutbl) if r_mutbl == mutbl => {\n-                            (expected, r_ty)\n-                        }\n-                        _ => {\n-                            let inner_ty = self.next_ty_var(\n-                                TypeVariableOrigin {\n-                                    kind: TypeVariableOriginKind::TypeInference,\n-                                    span: inner.span,\n-                                }\n-                            );\n-                            let mt = ty::TypeAndMut { ty: inner_ty, mutbl: mutbl };\n-                            let region = self.next_region_var(infer::PatternRegion(pat.span));\n-                            let rptr_ty = tcx.mk_ref(region, mt);\n-                            debug!(\"check_pat_walk: demanding {:?} = {:?}\", expected, rptr_ty);\n-                            let err = self.demand_eqtype_diag(pat.span, expected, rptr_ty);\n-\n-                            // Look for a case like `fn foo(&foo: u32)` and suggest\n-                            // `fn foo(foo: &u32)`\n-                            if let Some(mut err) = err {\n-                                self.borrow_pat_suggestion(&mut err, &pat, &inner, &expected);\n-                                err.emit();\n-                            }\n-                            (rptr_ty, inner_ty)\n-                        }\n-                    };\n-\n-                    self.check_pat_walk(&inner, inner_ty, def_bm, discrim_span);\n-                    rptr_ty\n-                } else {\n-                    self.check_pat_walk(&inner, tcx.types.err, def_bm, discrim_span);\n-                    tcx.types.err\n-                }\n+                self.check_pat_ref(pat, inner, mutbl, expected, def_bm, discrim_span)\n             }\n             PatKind::Slice(ref before, ref slice, ref after) => {\n                 let expected_ty = self.structurally_resolved_type(pat.span, expected);\n@@ -1059,4 +1016,58 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             tcx.types.err\n         }\n     }\n+\n+    fn check_pat_ref(\n+        &self,\n+        pat: &hir::Pat,\n+        inner: &'tcx hir::Pat,\n+        mutbl: hir::Mutability,\n+        expected: Ty<'tcx>,\n+        def_bm: ty::BindingMode,\n+        discrim_span: Option<Span>,\n+    ) -> Ty<'tcx> {\n+        let tcx = self.tcx;\n+        let expected = self.shallow_resolve(expected);\n+        if self.check_dereferencable(pat.span, expected, &inner) {\n+            // `demand::subtype` would be good enough, but using `eqtype` turns\n+            // out to be equally general. See (*) below for details.\n+\n+            // Take region, inner-type from expected type if we can,\n+            // to avoid creating needless variables. This also helps with\n+            // the bad  interactions of the given hack detailed in (*) below.\n+            debug!(\"check_pat_ref: expected={:?}\", expected);\n+            let (rptr_ty, inner_ty) = match expected.sty {\n+                ty::Ref(_, r_ty, r_mutbl) if r_mutbl == mutbl => {\n+                    (expected, r_ty)\n+                }\n+                _ => {\n+                    let inner_ty = self.next_ty_var(\n+                        TypeVariableOrigin {\n+                            kind: TypeVariableOriginKind::TypeInference,\n+                            span: inner.span,\n+                        }\n+                    );\n+                    let mt = ty::TypeAndMut { ty: inner_ty, mutbl };\n+                    let region = self.next_region_var(infer::PatternRegion(pat.span));\n+                    let rptr_ty = tcx.mk_ref(region, mt);\n+                    debug!(\"check_pat_ref: demanding {:?} = {:?}\", expected, rptr_ty);\n+                    let err = self.demand_eqtype_diag(pat.span, expected, rptr_ty);\n+\n+                    // Look for a case like `fn foo(&foo: u32)` and suggest\n+                    // `fn foo(foo: &u32)`\n+                    if let Some(mut err) = err {\n+                        self.borrow_pat_suggestion(&mut err, &pat, &inner, &expected);\n+                        err.emit();\n+                    }\n+                    (rptr_ty, inner_ty)\n+                }\n+            };\n+\n+            self.check_pat_walk(&inner, inner_ty, def_bm, discrim_span);\n+            rptr_ty\n+        } else {\n+            self.check_pat_walk(&inner, tcx.types.err, def_bm, discrim_span);\n+            tcx.types.err\n+        }\n+    }\n }"}]}