{"sha": "76ecce0e0c1e307d0c387b3cc219d8410fe7a6f6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc2ZWNjZTBlMGMxZTMwN2QwYzM4N2IzY2MyMTlkODQxMGZlN2E2ZjY=", "commit": {"author": {"name": "gifnksm", "email": "makoto.nksm+github@gmail.com", "date": "2013-05-14T12:31:43Z"}, "committer": {"name": "gifnksm", "email": "makoto.nksm+github@gmail.com", "date": "2013-05-14T12:59:08Z"}, "message": "libstd: `Ratio` requires `Clone` instead of `Copy`\n\nThis allows creating `Ratio<T>` which `T` is non-implicitly copyable types\nsuch as `BigInt`.", "tree": {"sha": "5e68182c38b613d99249c46a447644956b895e42", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5e68182c38b613d99249c46a447644956b895e42"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/76ecce0e0c1e307d0c387b3cc219d8410fe7a6f6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/76ecce0e0c1e307d0c387b3cc219d8410fe7a6f6", "html_url": "https://github.com/rust-lang/rust/commit/76ecce0e0c1e307d0c387b3cc219d8410fe7a6f6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/76ecce0e0c1e307d0c387b3cc219d8410fe7a6f6/comments", "author": {"login": "gifnksm", "id": 164213, "node_id": "MDQ6VXNlcjE2NDIxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/164213?v=4", "gravatar_id": "", "url": "https://api.github.com/users/gifnksm", "html_url": "https://github.com/gifnksm", "followers_url": "https://api.github.com/users/gifnksm/followers", "following_url": "https://api.github.com/users/gifnksm/following{/other_user}", "gists_url": "https://api.github.com/users/gifnksm/gists{/gist_id}", "starred_url": "https://api.github.com/users/gifnksm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/gifnksm/subscriptions", "organizations_url": "https://api.github.com/users/gifnksm/orgs", "repos_url": "https://api.github.com/users/gifnksm/repos", "events_url": "https://api.github.com/users/gifnksm/events{/privacy}", "received_events_url": "https://api.github.com/users/gifnksm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "gifnksm", "id": 164213, "node_id": "MDQ6VXNlcjE2NDIxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/164213?v=4", "gravatar_id": "", "url": "https://api.github.com/users/gifnksm", "html_url": "https://github.com/gifnksm", "followers_url": "https://api.github.com/users/gifnksm/followers", "following_url": "https://api.github.com/users/gifnksm/following{/other_user}", "gists_url": "https://api.github.com/users/gifnksm/gists{/gist_id}", "starred_url": "https://api.github.com/users/gifnksm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/gifnksm/subscriptions", "organizations_url": "https://api.github.com/users/gifnksm/orgs", "repos_url": "https://api.github.com/users/gifnksm/repos", "events_url": "https://api.github.com/users/gifnksm/events{/privacy}", "received_events_url": "https://api.github.com/users/gifnksm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "41eaa97372ef0ede1f9f2657d2c6752bbf191edb", "url": "https://api.github.com/repos/rust-lang/rust/commits/41eaa97372ef0ede1f9f2657d2c6752bbf191edb", "html_url": "https://github.com/rust-lang/rust/commit/41eaa97372ef0ede1f9f2657d2c6752bbf191edb"}], "stats": {"total": 51, "additions": 28, "deletions": 23}, "files": [{"sha": "0ec6f7457d6e44b656e675665f10fa38b3c94224", "filename": "src/libstd/num/rational.rs", "status": "modified", "additions": 28, "deletions": 23, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/76ecce0e0c1e307d0c387b3cc219d8410fe7a6f6/src%2Flibstd%2Fnum%2Frational.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76ecce0e0c1e307d0c387b3cc219d8410fe7a6f6/src%2Flibstd%2Fnum%2Frational.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Frational.rs?ref=76ecce0e0c1e307d0c387b3cc219d8410fe7a6f6", "patch": "@@ -30,7 +30,7 @@ pub type Rational64 = Ratio<i64>;\n /// Alias for arbitrary precision rationals.\n pub type BigRational = Ratio<BigInt>;\n \n-impl<T: Copy + Integer + Ord>\n+impl<T: Clone + Integer + Ord>\n     Ratio<T> {\n     /// Create a ratio representing the integer `t`.\n     #[inline(always)]\n@@ -59,18 +59,23 @@ impl<T: Copy + Integer + Ord>\n     fn reduce(&mut self) {\n         let g : T = self.numer.gcd(&self.denom);\n \n-        self.numer /= g;\n-        self.denom /= g;\n+        // FIXME(#6050): overloaded operators force moves with generic types\n+        // self.numer /= g;\n+        self.numer = self.numer / g;\n+        // FIXME(#6050): overloaded operators force moves with generic types\n+        // self.denom /= g;\n+        self.denom = self.denom / g;\n \n         // keep denom positive!\n         if self.denom < Zero::zero() {\n             self.numer = -self.numer;\n             self.denom = -self.denom;\n         }\n     }\n+\n     /// Return a `reduce`d copy of self.\n     fn reduced(&self) -> Ratio<T> {\n-        let mut ret = copy *self;\n+        let mut ret = self.clone();\n         ret.reduce();\n         ret\n     }\n@@ -105,7 +110,7 @@ cmp_impl!(impl TotalOrd, cmp -> cmp::Ordering)\n \n /* Arithmetic */\n // a/b * c/d = (a*c)/(b*d)\n-impl<T: Copy + Integer + Ord>\n+impl<T: Clone + Integer + Ord>\n     Mul<Ratio<T>,Ratio<T>> for Ratio<T> {\n     #[inline]\n     fn mul(&self, rhs: &Ratio<T>) -> Ratio<T> {\n@@ -114,7 +119,7 @@ impl<T: Copy + Integer + Ord>\n }\n \n // (a/b) / (c/d) = (a*d)/(b*c)\n-impl<T: Copy + Integer + Ord>\n+impl<T: Clone + Integer + Ord>\n     Div<Ratio<T>,Ratio<T>> for Ratio<T> {\n     #[inline]\n     fn div(&self, rhs: &Ratio<T>) -> Ratio<T> {\n@@ -125,7 +130,7 @@ impl<T: Copy + Integer + Ord>\n // Abstracts the a/b `op` c/d = (a*d `op` b*d) / (b*d) pattern\n macro_rules! arith_impl {\n     (impl $imp:ident, $method:ident) => {\n-        impl<T: Copy + Integer + Ord>\n+        impl<T: Clone + Integer + Ord>\n             $imp<Ratio<T>,Ratio<T>> for Ratio<T> {\n             #[inline]\n             fn $method(&self, rhs: &Ratio<T>) -> Ratio<T> {\n@@ -145,7 +150,7 @@ arith_impl!(impl Sub, sub)\n // a/b % c/d = (a*d % b*c)/(b*d)\n arith_impl!(impl Rem, rem)\n \n-impl<T: Copy + Integer + Ord>\n+impl<T: Clone + Integer + Ord>\n     Neg<Ratio<T>> for Ratio<T> {\n     #[inline]\n     fn neg(&self) -> Ratio<T> {\n@@ -154,7 +159,7 @@ impl<T: Copy + Integer + Ord>\n }\n \n /* Constants */\n-impl<T: Copy + Integer + Ord>\n+impl<T: Clone + Integer + Ord>\n     Zero for Ratio<T> {\n     #[inline]\n     fn zero() -> Ratio<T> {\n@@ -167,19 +172,19 @@ impl<T: Copy + Integer + Ord>\n     }\n }\n \n-impl<T: Copy + Integer + Ord>\n+impl<T: Clone + Integer + Ord>\n     One for Ratio<T> {\n     #[inline]\n     fn one() -> Ratio<T> {\n         Ratio::new_raw(One::one(), One::one())\n     }\n }\n \n-impl<T: Copy + Integer + Ord>\n+impl<T: Clone + Integer + Ord>\n     Num for Ratio<T> {}\n \n /* Utils */\n-impl<T: Copy + Integer + Ord>\n+impl<T: Clone + Integer + Ord>\n     Round for Ratio<T> {\n \n     fn floor(&self) -> Ratio<T> {\n@@ -213,14 +218,14 @@ impl<T: Copy + Integer + Ord>\n     }\n \n     fn fract(&self) -> Ratio<T> {\n-        Ratio::new_raw(self.numer % self.denom, self.denom)\n+        Ratio::new_raw(self.numer % self.denom, self.denom.clone())\n     }\n }\n \n-impl<T: Copy + Integer + Ord> Fractional for Ratio<T> {\n+impl<T: Clone + Integer + Ord> Fractional for Ratio<T> {\n     #[inline]\n     fn recip(&self) -> Ratio<T> {\n-        Ratio::new_raw(self.denom, self.numer)\n+        Ratio::new_raw(self.denom.clone(), self.numer.clone())\n     }\n }\n \n@@ -238,7 +243,7 @@ impl<T: ToStrRadix> ToStrRadix for Ratio<T> {\n     }\n }\n \n-impl<T: FromStr + Copy + Integer + Ord>\n+impl<T: FromStr + Clone + Integer + Ord>\n     FromStr for Ratio<T> {\n     /// Parses `numer/denom`.\n     fn from_str(s: &str) -> Option<Ratio<T>> {\n@@ -248,14 +253,14 @@ impl<T: FromStr + Copy + Integer + Ord>\n             }\n         });\n         if split.len() < 2 { return None; }\n-        do FromStr::from_str(split[0]).chain |a| {\n-            do FromStr::from_str(split[1]).chain |b| {\n-                Some(Ratio::new(a,b))\n+        do FromStr::from_str::<T>(split[0]).chain |a| {\n+            do FromStr::from_str::<T>(split[1]).chain |b| {\n+                Some(Ratio::new(a.clone(), b.clone()))\n             }\n         }\n     }\n }\n-impl<T: FromStrRadix + Copy + Integer + Ord>\n+impl<T: FromStrRadix + Clone + Integer + Ord>\n     FromStrRadix for Ratio<T> {\n     /// Parses `numer/denom` where the numbers are in base `radix`.\n     fn from_str_radix(s: &str, radix: uint) -> Option<Ratio<T>> {\n@@ -266,9 +271,9 @@ impl<T: FromStrRadix + Copy + Integer + Ord>\n         });\n         if split.len() < 2 { None }\n         else {\n-            do FromStrRadix::from_str_radix(split[0], radix).chain |a| {\n-                do FromStrRadix::from_str_radix(split[1], radix).chain |b| {\n-                    Some(Ratio::new(a,b))\n+            do FromStrRadix::from_str_radix::<T>(split[0], radix).chain |a| {\n+                do FromStrRadix::from_str_radix::<T>(split[1], radix).chain |b| {\n+                    Some(Ratio::new(a.clone(), b.clone()))\n                 }\n             }\n         }"}]}