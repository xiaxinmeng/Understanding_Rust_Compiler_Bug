{"sha": "0bd47e8a393d8a670d2770d35e9158adfa1f813e", "node_id": "C_kwDOAAsO6NoAKDBiZDQ3ZThhMzkzZDhhNjcwZDI3NzBkMzVlOTE1OGFkZmExZjgxM2U", "commit": {"author": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-04-04T05:47:53Z"}, "committer": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-04-04T07:03:36Z"}, "message": "Reorder match arms in `parse_tt_inner`.\n\nTo match the order the variants are declared in.", "tree": {"sha": "68386837693c6f660b5b5a0a74d90f5328f095b5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/68386837693c6f660b5b5a0a74d90f5328f095b5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0bd47e8a393d8a670d2770d35e9158adfa1f813e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0bd47e8a393d8a670d2770d35e9158adfa1f813e", "html_url": "https://github.com/rust-lang/rust/commit/0bd47e8a393d8a670d2770d35e9158adfa1f813e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0bd47e8a393d8a670d2770d35e9158adfa1f813e/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "88f8fbcce07f74b26e308ae5b2156d75ec03e35e", "url": "https://api.github.com/repos/rust-lang/rust/commits/88f8fbcce07f74b26e308ae5b2156d75ec03e35e", "html_url": "https://github.com/rust-lang/rust/commit/88f8fbcce07f74b26e308ae5b2156d75ec03e35e"}], "stats": {"total": 62, "additions": 31, "deletions": 31}, "files": [{"sha": "522989c64548b8da79e12545f41fbb5dbdbe5eb2", "filename": "compiler/rustc_expand/src/mbe/macro_parser.rs", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/0bd47e8a393d8a670d2770d35e9158adfa1f813e/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bd47e8a393d8a670d2770d35e9158adfa1f813e/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs?ref=0bd47e8a393d8a670d2770d35e9158adfa1f813e", "patch": "@@ -443,6 +443,29 @@ impl<'tt> TtParser<'tt> {\n \n         while let Some(mut mp) = self.cur_mps.pop() {\n             match &self.locs[mp.idx] {\n+                MatcherLoc::Token { token: t } => {\n+                    // If it's a doc comment, we just ignore it and move on to the next tt in the\n+                    // matcher. This is a bug, but #95267 showed that existing programs rely on\n+                    // this behaviour, and changing it would require some care and a transition\n+                    // period.\n+                    //\n+                    // If the token matches, we can just advance the parser.\n+                    //\n+                    // Otherwise, this match has failed, there is nothing to do, and hopefully\n+                    // another mp in `cur_mps` will match.\n+                    if matches!(t, Token { kind: DocComment(..), .. }) {\n+                        mp.idx += 1;\n+                        self.cur_mps.push(mp);\n+                    } else if token_name_eq(&t, token) {\n+                        mp.idx += 1;\n+                        self.next_mps.push(mp);\n+                    }\n+                }\n+                MatcherLoc::Delimited => {\n+                    // Entering the delimeter is trivial.\n+                    mp.idx += 1;\n+                    self.cur_mps.push(mp);\n+                }\n                 &MatcherLoc::Sequence {\n                     op,\n                     num_metavar_decls,\n@@ -471,37 +494,6 @@ impl<'tt> TtParser<'tt> {\n                     mp.idx += 1;\n                     self.cur_mps.push(mp);\n                 }\n-                MatcherLoc::MetaVarDecl { kind, .. } => {\n-                    // Built-in nonterminals never start with these tokens, so we can eliminate\n-                    // them from consideration. We use the span of the metavariable declaration\n-                    // to determine any edition-specific matching behavior for non-terminals.\n-                    if Parser::nonterminal_may_begin_with(*kind, token) {\n-                        self.bb_mps.push(mp);\n-                    }\n-                }\n-                MatcherLoc::Delimited => {\n-                    // Entering the delimeter is trivial.\n-                    mp.idx += 1;\n-                    self.cur_mps.push(mp);\n-                }\n-                MatcherLoc::Token { token: t } => {\n-                    // If it's a doc comment, we just ignore it and move on to the next tt in the\n-                    // matcher. This is a bug, but #95267 showed that existing programs rely on\n-                    // this behaviour, and changing it would require some care and a transition\n-                    // period.\n-                    //\n-                    // If the token matches, we can just advance the parser.\n-                    //\n-                    // Otherwise, this match has failed, there is nothing to do, and hopefully\n-                    // another mp in `cur_mps` will match.\n-                    if matches!(t, Token { kind: DocComment(..), .. }) {\n-                        mp.idx += 1;\n-                        self.cur_mps.push(mp);\n-                    } else if token_name_eq(&t, token) {\n-                        mp.idx += 1;\n-                        self.next_mps.push(mp);\n-                    }\n-                }\n                 &MatcherLoc::SequenceKleeneOpNoSep { op, idx_first } => {\n                     // We are past the end of a sequence with no separator. Try ending the\n                     // sequence. If that's not possible, `ending_mp` will fail quietly when it is\n@@ -540,6 +532,14 @@ impl<'tt> TtParser<'tt> {\n                     mp.idx = idx_first;\n                     self.cur_mps.push(mp);\n                 }\n+                MatcherLoc::MetaVarDecl { kind, .. } => {\n+                    // Built-in nonterminals never start with these tokens, so we can eliminate\n+                    // them from consideration. We use the span of the metavariable declaration\n+                    // to determine any edition-specific matching behavior for non-terminals.\n+                    if Parser::nonterminal_may_begin_with(*kind, token) {\n+                        self.bb_mps.push(mp);\n+                    }\n+                }\n                 MatcherLoc::Eof => {\n                     // We are past the matcher's end, and not in a sequence. Try to end things.\n                     debug_assert_eq!(mp.idx, self.locs.len() - 1);"}]}