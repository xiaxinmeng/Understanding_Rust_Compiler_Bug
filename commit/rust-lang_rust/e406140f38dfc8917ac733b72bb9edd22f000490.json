{"sha": "e406140f38dfc8917ac733b72bb9edd22f000490", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU0MDYxNDBmMzhkZmM4OTE3YWM3MzNiNzJiYjllZGQyMmYwMDA0OTA=", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-06-23T14:43:53Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-06-23T14:43:53Z"}, "message": "Implement exit point highlighting", "tree": {"sha": "4dacfabfc6c95e69cf4ea1450f3aeb840728cea2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4dacfabfc6c95e69cf4ea1450f3aeb840728cea2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e406140f38dfc8917ac733b72bb9edd22f000490", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e406140f38dfc8917ac733b72bb9edd22f000490", "html_url": "https://github.com/rust-lang/rust/commit/e406140f38dfc8917ac733b72bb9edd22f000490", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e406140f38dfc8917ac733b72bb9edd22f000490/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9a53f1033efb166240d62cccf8f73501ada6938a", "url": "https://api.github.com/repos/rust-lang/rust/commits/9a53f1033efb166240d62cccf8f73501ada6938a", "html_url": "https://github.com/rust-lang/rust/commit/9a53f1033efb166240d62cccf8f73501ada6938a"}], "stats": {"total": 200, "additions": 160, "deletions": 40}, "files": [{"sha": "5493d11d07426662fa99af713166d6f49acb272d", "filename": "crates/ide/src/highlight_related.rs", "status": "modified", "additions": 160, "deletions": 40, "changes": 200, "blob_url": "https://github.com/rust-lang/rust/blob/e406140f38dfc8917ac733b72bb9edd22f000490/crates%2Fide%2Fsrc%2Fhighlight_related.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e406140f38dfc8917ac733b72bb9edd22f000490/crates%2Fide%2Fsrc%2Fhighlight_related.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhighlight_related.rs?ref=e406140f38dfc8917ac733b72bb9edd22f000490", "patch": "@@ -42,7 +42,91 @@ pub(crate) fn highlight_related(\n     }\n }\n \n-fn highlight_exit_points(_token: SyntaxToken) -> Option<Vec<DocumentHighlight>> {\n+fn highlight_references(\n+    sema: &Semantics<RootDatabase>,\n+    syntax: &SyntaxNode,\n+    FilePosition { offset, file_id }: FilePosition,\n+) -> Option<Vec<DocumentHighlight>> {\n+    let def = references::find_def(sema, syntax, offset)?;\n+    let usages = def.usages(sema).set_scope(Some(SearchScope::single_file(file_id))).all();\n+\n+    let declaration = match def {\n+        Definition::ModuleDef(hir::ModuleDef::Module(module)) => {\n+            Some(NavigationTarget::from_module_to_decl(sema.db, module))\n+        }\n+        def => def.try_to_nav(sema.db),\n+    }\n+    .filter(|decl| decl.file_id == file_id)\n+    .and_then(|decl| {\n+        let range = decl.focus_range?;\n+        let access = references::decl_access(&def, syntax, range);\n+        Some(DocumentHighlight { range, access })\n+    });\n+\n+    let file_refs = usages.references.get(&file_id).map_or(&[][..], Vec::as_slice);\n+    let mut res = Vec::with_capacity(file_refs.len() + 1);\n+    res.extend(declaration);\n+    res.extend(\n+        file_refs\n+            .iter()\n+            .map(|&FileReference { access, range, .. }| DocumentHighlight { range, access }),\n+    );\n+    Some(res)\n+}\n+\n+fn highlight_exit_points(token: SyntaxToken) -> Option<Vec<DocumentHighlight>> {\n+    fn hl(body: Option<ast::Expr>) -> Option<Vec<DocumentHighlight>> {\n+        let mut highlights = Vec::new();\n+        let body = body?;\n+        walk(body.syntax(), |node| {\n+            match_ast! {\n+                match node {\n+                    ast::ReturnExpr(expr) => if let Some(token) = expr.return_token() {\n+                        highlights.push(DocumentHighlight {\n+                            access: None,\n+                            range: token.text_range(),\n+                        });\n+                    },\n+                    ast::TryExpr(try_) => if let Some(token) = try_.question_mark_token() {\n+                        highlights.push(DocumentHighlight {\n+                            access: None,\n+                            range: token.text_range(),\n+                        });\n+                    },\n+                    ast::EffectExpr(effect) => if effect.async_token().is_some() {\n+                        return true;\n+                    },\n+                    ast::ClosureExpr(__) => return true,\n+                    ast::Item(__) => return true,\n+                    ast::Path(__) => return true,\n+                    _ => (),\n+                }\n+            }\n+            false\n+        });\n+        let tail = match body {\n+            ast::Expr::BlockExpr(b) => b.tail_expr(),\n+            e => Some(e),\n+        };\n+        if let Some(tail) = tail {\n+            highlights.push(DocumentHighlight { access: None, range: tail.syntax().text_range() });\n+        }\n+        Some(highlights)\n+    }\n+    for anc in token.ancestors() {\n+        return match_ast! {\n+            match anc {\n+                ast::Fn(fn_) => hl(fn_.body().map(ast::Expr::BlockExpr)),\n+                ast::ClosureExpr(closure) => hl(closure.body()),\n+                ast::EffectExpr(effect) => if effect.async_token().is_some() {\n+                    None\n+                } else {\n+                    continue;\n+                },\n+                _ => continue,\n+            }\n+        };\n+    }\n     None\n }\n \n@@ -54,12 +138,7 @@ fn highlight_yield_points(token: SyntaxToken) -> Option<Vec<DocumentHighlight>>\n         let mut highlights = Vec::new();\n         highlights.push(DocumentHighlight { access: None, range: async_token?.text_range() });\n         if let Some(body) = body {\n-            let mut preorder = body.syntax().preorder();\n-            while let Some(event) = preorder.next() {\n-                let node = match event {\n-                    WalkEvent::Enter(node) => node,\n-                    WalkEvent::Leave(_) => continue,\n-                };\n+            walk(body.syntax(), |node| {\n                 match_ast! {\n                     match node {\n                         ast::AwaitExpr(expr) => if let Some(token) = expr.await_token() {\n@@ -68,14 +147,17 @@ fn highlight_yield_points(token: SyntaxToken) -> Option<Vec<DocumentHighlight>>\n                                 range: token.text_range(),\n                             });\n                         },\n-                        ast::EffectExpr(__) => preorder.skip_subtree(),\n-                        ast::ClosureExpr(__) => preorder.skip_subtree(),\n-                        ast::Item(__) => preorder.skip_subtree(),\n-                        ast::Path(__) => preorder.skip_subtree(),\n+                        ast::EffectExpr(effect) => if effect.async_token().is_some() {\n+                            return true;\n+                        },\n+                        ast::ClosureExpr(__) => return true,\n+                        ast::Item(__) => return true,\n+                        ast::Path(__) => return true,\n                         _ => (),\n                     }\n                 }\n-            }\n+                false\n+            });\n         }\n         Some(highlights)\n     }\n@@ -92,36 +174,17 @@ fn highlight_yield_points(token: SyntaxToken) -> Option<Vec<DocumentHighlight>>\n     None\n }\n \n-fn highlight_references(\n-    sema: &Semantics<RootDatabase>,\n-    syntax: &SyntaxNode,\n-    FilePosition { offset, file_id }: FilePosition,\n-) -> Option<Vec<DocumentHighlight>> {\n-    let def = references::find_def(sema, syntax, offset)?;\n-    let usages = def.usages(sema).set_scope(Some(SearchScope::single_file(file_id))).all();\n-\n-    let declaration = match def {\n-        Definition::ModuleDef(hir::ModuleDef::Module(module)) => {\n-            Some(NavigationTarget::from_module_to_decl(sema.db, module))\n+fn walk(syntax: &SyntaxNode, mut cb: impl FnMut(SyntaxNode) -> bool) {\n+    let mut preorder = syntax.preorder();\n+    while let Some(event) = preorder.next() {\n+        let node = match event {\n+            WalkEvent::Enter(node) => node,\n+            WalkEvent::Leave(_) => continue,\n+        };\n+        if cb(node) {\n+            preorder.skip_subtree();\n         }\n-        def => def.try_to_nav(sema.db),\n     }\n-    .filter(|decl| decl.file_id == file_id)\n-    .and_then(|decl| {\n-        let range = decl.focus_range?;\n-        let access = references::decl_access(&def, syntax, range);\n-        Some(DocumentHighlight { range, access })\n-    });\n-\n-    let file_refs = usages.references.get(&file_id).map_or(&[][..], Vec::as_slice);\n-    let mut res = Vec::with_capacity(file_refs.len() + 1);\n-    res.extend(declaration);\n-    res.extend(\n-        file_refs\n-            .iter()\n-            .map(|&FileReference { access, range, .. }| DocumentHighlight { range, access }),\n-    );\n-    Some(res)\n }\n \n #[cfg(test)]\n@@ -278,6 +341,63 @@ async fn foo() {\n         // ^^^^^\n     ).await;\n }\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_hl_exit_points() {\n+        check(\n+            r#\"\n+fn foo() -> u32 {\n+    if true {\n+        return$0 0;\n+     // ^^^^^^\n+    }\n+\n+    0?;\n+  // ^\n+    0xDEAD_BEEF\n+ // ^^^^^^^^^^^\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_hl_exit_points2() {\n+        check(\n+            r#\"\n+fn foo() ->$0 u32 {\n+    if true {\n+        return 0;\n+     // ^^^^^^\n+    }\n+\n+    0?;\n+  // ^\n+    0xDEAD_BEEF\n+ // ^^^^^^^^^^^\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_hl_prefer_ref_over_tail_exit() {\n+        check(\n+            r#\"\n+fn foo() -> u32 {\n+// ^^^\n+    if true {\n+        return 0;\n+    }\n+\n+    0?;\n+\n+    foo$0()\n+ // ^^^\n+}\n \"#,\n         );\n     }"}]}