{"sha": "cb56ff5a775a8915d2e79cd8c8a0f2992f1a561d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNiNTZmZjVhNzc1YTg5MTVkMmU3OWNkOGM4YTBmMjk5MmYxYTU2MWQ=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-10-24T19:39:08Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-10-31T16:41:38Z"}, "message": "reorder liveness to bring the more significant code up top", "tree": {"sha": "4c6f320ef5f9b2e9e76391a827d5704bf8a240f2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4c6f320ef5f9b2e9e76391a827d5704bf8a240f2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cb56ff5a775a8915d2e79cd8c8a0f2992f1a561d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cb56ff5a775a8915d2e79cd8c8a0f2992f1a561d", "html_url": "https://github.com/rust-lang/rust/commit/cb56ff5a775a8915d2e79cd8c8a0f2992f1a561d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cb56ff5a775a8915d2e79cd8c8a0f2992f1a561d/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "899c7ad9b2003482283615902fb29513e2fc22ac", "url": "https://api.github.com/repos/rust-lang/rust/commits/899c7ad9b2003482283615902fb29513e2fc22ac", "html_url": "https://github.com/rust-lang/rust/commit/899c7ad9b2003482283615902fb29513e2fc22ac"}], "stats": {"total": 214, "additions": 107, "deletions": 107}, "files": [{"sha": "514ff2ab830caed227ae3ea78bac2aa7db1ca7c3", "filename": "src/librustc_mir/util/liveness.rs", "status": "modified", "additions": 107, "deletions": 107, "changes": 214, "blob_url": "https://github.com/rust-lang/rust/blob/cb56ff5a775a8915d2e79cd8c8a0f2992f1a561d/src%2Flibrustc_mir%2Futil%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb56ff5a775a8915d2e79cd8c8a0f2992f1a561d/src%2Flibrustc_mir%2Futil%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fliveness.rs?ref=cb56ff5a775a8915d2e79cd8c8a0f2992f1a561d", "patch": "@@ -47,6 +47,113 @@ use std::io::{self, Write};\n \n pub type LocalSet = IdxSetBuf<Local>;\n \n+// This gives the result of the liveness analysis at the boundary of basic blocks\n+pub struct LivenessResult {\n+    pub ins: IndexVec<BasicBlock, LocalSet>,\n+    pub outs: IndexVec<BasicBlock, LocalSet>,\n+}\n+\n+pub fn liveness_of_locals<'tcx>(mir: &Mir<'tcx>) -> LivenessResult {\n+    let locals = mir.local_decls.len();\n+    let def_use: IndexVec<_, _> = mir.basic_blocks().iter().map(|b| {\n+        block(b, locals)\n+    }).collect();\n+\n+    let mut ins: IndexVec<_, _> = mir.basic_blocks()\n+        .indices()\n+        .map(|_| LocalSet::new_empty(locals))\n+        .collect();\n+    let mut outs = ins.clone();\n+\n+    let mut changed = true;\n+    let mut bits = LocalSet::new_empty(locals);\n+    while changed {\n+        changed = false;\n+\n+        for b in mir.basic_blocks().indices().rev() {\n+            // outs[b] = \u222a {ins of successors}\n+            bits.clear();\n+            for &successor in mir.basic_blocks()[b].terminator().successors().into_iter() {\n+                bits.union(&ins[successor]);\n+            }\n+            outs[b].clone_from(&bits);\n+\n+            // bits = use \u222a (bits - def)\n+            def_use[b].apply(&mut bits);\n+\n+            // update bits on entry and flag if they have changed\n+            if ins[b] != bits {\n+                ins[b].clone_from(&bits);\n+                changed = true;\n+            }\n+        }\n+    }\n+\n+    LivenessResult {\n+        ins,\n+        outs,\n+    }\n+}\n+\n+impl LivenessResult {\n+    /// Walks backwards through the statements/terminator in the given\n+    /// basic block `block`.  At each point within `block`, invokes\n+    /// the callback `op` with the current location and the set of\n+    /// variables that are live on entry to that location.\n+    pub fn simulate_block<'tcx, OP>(&self,\n+                                    mir: &Mir<'tcx>,\n+                                    block: BasicBlock,\n+                                    mut callback: OP)\n+        where OP: FnMut(Location, &LocalSet)\n+    {\n+        let data = &mir[block];\n+\n+        // Get a copy of the bits on exit from the block.\n+        let mut bits = self.outs[block].clone();\n+\n+        // Start with the maximal statement index -- i.e., right before\n+        // the terminator executes.\n+        let mut statement_index = data.statements.len();\n+\n+        // Compute liveness right before terminator and invoke callback.\n+        let terminator_location = Location { block, statement_index };\n+        let terminator_defs_uses = self.defs_uses(mir, terminator_location, &data.terminator);\n+        terminator_defs_uses.apply(&mut bits);\n+        callback(terminator_location, &bits);\n+\n+        // Compute liveness before each statement (in rev order) and invoke callback.\n+        for statement in data.statements.iter().rev() {\n+            statement_index -= 1;\n+            let statement_location = Location { block, statement_index };\n+            let statement_defs_uses = self.defs_uses(mir, statement_location, statement);\n+            statement_defs_uses.apply(&mut bits);\n+            callback(statement_location, &bits);\n+        }\n+\n+        assert_eq!(bits, self.ins[block]);\n+    }\n+\n+    fn defs_uses<'tcx, V>(&self,\n+                          mir: &Mir<'tcx>,\n+                          location: Location,\n+                          thing: &V)\n+                          -> DefsUses\n+        where V: MirVisitable<'tcx>,\n+    {\n+        let locals = mir.local_decls.len();\n+        let mut visitor = DefsUses {\n+            defs: LocalSet::new_empty(locals),\n+            uses: LocalSet::new_empty(locals),\n+        };\n+\n+        // Visit the various parts of the basic block in reverse. If we go\n+        // forward, the logic in `add_def` and `add_use` would be wrong.\n+        thing.apply(location, &mut visitor);\n+\n+        visitor\n+    }\n+}\n+\n #[derive(Eq, PartialEq, Clone)]\n struct DefsUses {\n     defs: LocalSet,\n@@ -159,113 +266,6 @@ fn block<'tcx>(b: &BasicBlockData<'tcx>, locals: usize) -> DefsUses {\n     visitor\n }\n \n-// This gives the result of the liveness analysis at the boundary of basic blocks\n-pub struct LivenessResult {\n-    pub ins: IndexVec<BasicBlock, LocalSet>,\n-    pub outs: IndexVec<BasicBlock, LocalSet>,\n-}\n-\n-pub fn liveness_of_locals<'tcx>(mir: &Mir<'tcx>) -> LivenessResult {\n-    let locals = mir.local_decls.len();\n-    let def_use: IndexVec<_, _> = mir.basic_blocks().iter().map(|b| {\n-        block(b, locals)\n-    }).collect();\n-\n-    let mut ins: IndexVec<_, _> = mir.basic_blocks()\n-        .indices()\n-        .map(|_| LocalSet::new_empty(locals))\n-        .collect();\n-    let mut outs = ins.clone();\n-\n-    let mut changed = true;\n-    let mut bits = LocalSet::new_empty(locals);\n-    while changed {\n-        changed = false;\n-\n-        for b in mir.basic_blocks().indices().rev() {\n-            // outs[b] = \u222a {ins of successors}\n-            bits.clear();\n-            for &successor in mir.basic_blocks()[b].terminator().successors().into_iter() {\n-                bits.union(&ins[successor]);\n-            }\n-            outs[b].clone_from(&bits);\n-\n-            // bits = use \u222a (bits - def)\n-            def_use[b].apply(&mut bits);\n-\n-            // update bits on entry and flag if they have changed\n-            if ins[b] != bits {\n-                ins[b].clone_from(&bits);\n-                changed = true;\n-            }\n-        }\n-    }\n-\n-    LivenessResult {\n-        ins,\n-        outs,\n-    }\n-}\n-\n-impl LivenessResult {\n-    /// Walks backwards through the statements/terminator in the given\n-    /// basic block `block`.  At each point within `block`, invokes\n-    /// the callback `op` with the current location and the set of\n-    /// variables that are live on entry to that location.\n-    pub fn simulate_block<'tcx, OP>(&self,\n-                                    mir: &Mir<'tcx>,\n-                                    block: BasicBlock,\n-                                    mut callback: OP)\n-        where OP: FnMut(Location, &LocalSet)\n-    {\n-        let data = &mir[block];\n-\n-        // Get a copy of the bits on exit from the block.\n-        let mut bits = self.outs[block].clone();\n-\n-        // Start with the maximal statement index -- i.e., right before\n-        // the terminator executes.\n-        let mut statement_index = data.statements.len();\n-\n-        // Compute liveness right before terminator and invoke callback.\n-        let terminator_location = Location { block, statement_index };\n-        let terminator_defs_uses = self.defs_uses(mir, terminator_location, &data.terminator);\n-        terminator_defs_uses.apply(&mut bits);\n-        callback(terminator_location, &bits);\n-\n-        // Compute liveness before each statement (in rev order) and invoke callback.\n-        for statement in data.statements.iter().rev() {\n-            statement_index -= 1;\n-            let statement_location = Location { block, statement_index };\n-            let statement_defs_uses = self.defs_uses(mir, statement_location, statement);\n-            statement_defs_uses.apply(&mut bits);\n-            callback(statement_location, &bits);\n-        }\n-\n-        assert_eq!(bits, self.ins[block]);\n-    }\n-\n-    fn defs_uses<'tcx, V>(&self,\n-                          mir: &Mir<'tcx>,\n-                          location: Location,\n-                          thing: &V)\n-                          -> DefsUses\n-        where V: MirVisitable<'tcx>,\n-    {\n-        let locals = mir.local_decls.len();\n-        let mut visitor = DefsUses {\n-            defs: LocalSet::new_empty(locals),\n-            uses: LocalSet::new_empty(locals),\n-        };\n-\n-        // Visit the various parts of the basic block in reverse. If we go\n-        // forward, the logic in `add_def` and `add_use` would be wrong.\n-        thing.apply(location, &mut visitor);\n-\n-        visitor\n-    }\n-}\n-\n trait MirVisitable<'tcx> {\n     fn apply<V>(&self, location: Location, visitor: &mut V)\n         where V: Visitor<'tcx>;"}]}