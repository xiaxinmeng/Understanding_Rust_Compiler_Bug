{"sha": "d78a7fcea4d801a070f7848835f63dd8e6c5fa97", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ3OGE3ZmNlYTRkODAxYTA3MGY3ODQ4ODM1ZjYzZGQ4ZTZjNWZhOTc=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-02-25T12:13:26Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-02-25T12:13:26Z"}, "message": "Rollup merge of #39988 - arthurprs:hm-adapt2, r=alexcrichton\n\nSimplify/fix adaptive hashmap\n\nPlease see https://github.com/rust-lang/rust/pull/38368#issuecomment-280957863 for context.\n\nThe shift length math is broken. It turns out that checking for the shift length is complicated. Using simulations it's possible to see that a value of 2000 will only get probabilities down to ~1e-7 when the hashmap load factor is 90% (rust goes up to 90.9% as of today). That's probably not good enough to go into the stdlib with pluggable hashers.\n\nSo this PR simplify the adaptive behavior to only consider displacement, which is much safer and very useful by itself.\n\nThere's two comments because one of them is already being tested to be merged by bors.", "tree": {"sha": "2265030813fb0ea4b9a1c303af136056bd9f500b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2265030813fb0ea4b9a1c303af136056bd9f500b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d78a7fcea4d801a070f7848835f63dd8e6c5fa97", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d78a7fcea4d801a070f7848835f63dd8e6c5fa97", "html_url": "https://github.com/rust-lang/rust/commit/d78a7fcea4d801a070f7848835f63dd8e6c5fa97", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d78a7fcea4d801a070f7848835f63dd8e6c5fa97/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "33c19129c363eae3b84bdcc0fdf632f211dbd26a", "url": "https://api.github.com/repos/rust-lang/rust/commits/33c19129c363eae3b84bdcc0fdf632f211dbd26a", "html_url": "https://github.com/rust-lang/rust/commit/33c19129c363eae3b84bdcc0fdf632f211dbd26a"}, {"sha": "25b14889186b5e67906efe65a368ca75a69f6c20", "url": "https://api.github.com/repos/rust-lang/rust/commits/25b14889186b5e67906efe65a368ca75a69f6c20", "html_url": "https://github.com/rust-lang/rust/commit/25b14889186b5e67906efe65a368ca75a69f6c20"}], "stats": {"total": 34, "additions": 11, "deletions": 23}, "files": [{"sha": "f0738fe9b7033fea50795eaccb0dbe33238f4760", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 11, "deletions": 23, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/d78a7fcea4d801a070f7848835f63dd8e6c5fa97/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d78a7fcea4d801a070f7848835f63dd8e6c5fa97/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=d78a7fcea4d801a070f7848835f63dd8e6c5fa97", "patch": "@@ -182,46 +182,37 @@ impl DefaultResizePolicy {\n // ----------------------\n // To protect against degenerate performance scenarios (including DOS attacks),\n // the implementation includes an adaptive behavior that can resize the map\n-// early (before its capacity is exceeded) when suspiciously long probe or\n-// forward shifts sequences are encountered.\n+// early (before its capacity is exceeded) when suspiciously long probe sequences\n+// are encountered.\n //\n // With this algorithm in place it would be possible to turn a CPU attack into\n // a memory attack due to the aggressive resizing. To prevent that the\n-// adaptive behavior only triggers when the map occupancy is half the maximum occupancy.\n+// adaptive behavior only triggers when the map is at least half full.\n // This reduces the effectiveness of the algorithm but also makes it completely safe.\n //\n // The previous safety measure also prevents degenerate interactions with\n // really bad quality hash algorithms that can make normal inputs look like a\n // DOS attack.\n //\n const DISPLACEMENT_THRESHOLD: usize = 128;\n-const FORWARD_SHIFT_THRESHOLD: usize = 512;\n //\n-// The thresholds of 128 and 512 are chosen to minimize the chance of exceeding them.\n+// The threshold of 128 is chosen to minimize the chance of exceeding it.\n // In particular, we want that chance to be less than 10^-8 with a load of 90%.\n // For displacement, the smallest constant that fits our needs is 90,\n-// so we round that up to 128. For the number of forward-shifted buckets,\n-// we choose k=512. Keep in mind that the run length is a sum of the displacement and\n-// the number of forward-shifted buckets, so its threshold is 128+512=640.\n-// Even though the probability of having a run length of more than 640 buckets may be\n-// higher than the probability we want, it should be low enough.\n+// so we round that up to 128.\n //\n // At a load factor of \u03b1, the odds of finding the target bucket after exactly n\n // unsuccesful probes[1] are\n //\n // Pr_\u03b1{displacement = n} =\n // (1 - \u03b1) / \u03b1 * \u2211_{k\u22651} e^(-k\u03b1) * (k\u03b1)^(k+n) / (k + n)! * (1 - k\u03b1 / (k + n + 1))\n //\n-// We use this formula to find the probability of loading half of triggering the adaptive behavior\n+// We use this formula to find the probability of triggering the adaptive behavior\n //\n // Pr_0.909{displacement > 128} = 1.601 * 10^-11\n //\n-// FIXME: Extend with math for shift threshold in [2]\n-//\n // 1. Alfredo Viola (2005). Distributional analysis of Robin Hood linear probing\n //    hashing with buckets.\n-// 2. http://www.cs.tau.ac.il/~zwick/Adv-Alg-2015/Linear-Probing.pdf\n-\n \n /// A hash map implementation which uses linear probing with Robin Hood bucket\n /// stealing.\n@@ -494,7 +485,7 @@ fn robin_hood<'a, K: 'a, V: 'a>(bucket: FullBucketMut<'a, K, V>,\n                                 mut hash: SafeHash,\n                                 mut key: K,\n                                 mut val: V)\n-                                -> (usize, &'a mut V) {\n+                                -> &'a mut V {\n     let start_index = bucket.index();\n     let size = bucket.table().size();\n     // Save the *starting point*.\n@@ -519,15 +510,14 @@ fn robin_hood<'a, K: 'a, V: 'a>(bucket: FullBucketMut<'a, K, V>,\n                 Empty(bucket) => {\n                     // Found a hole!\n                     let bucket = bucket.put(hash, key, val);\n-                    let end_index = bucket.index();\n                     // Now that it's stolen, just read the value's pointer\n                     // right out of the table! Go back to the *starting point*.\n                     //\n                     // This use of `into_table` is misleading. It turns the\n                     // bucket, which is a FullBucket on top of a\n                     // FullBucketMut, into just one FullBucketMut. The \"table\"\n                     // refers to the inner FullBucketMut in this context.\n-                    return (end_index - start_index, bucket.into_table().into_mut_refs().1);\n+                    return bucket.into_table().into_mut_refs().1;\n                 }\n                 Full(bucket) => bucket,\n             };\n@@ -2128,18 +2118,16 @@ impl<'a, K: 'a, V: 'a> VacantEntry<'a, K, V> {\n     pub fn insert(self, value: V) -> &'a mut V {\n         match self.elem {\n             NeqElem(bucket, disp) => {\n-                let (shift, v_ref) = robin_hood(bucket, disp, self.hash, self.key, value);\n-                if disp >= DISPLACEMENT_THRESHOLD || shift >= FORWARD_SHIFT_THRESHOLD {\n+                if disp >= DISPLACEMENT_THRESHOLD {\n                     *self.long_probes = true;\n                 }\n-                v_ref\n+                robin_hood(bucket, disp, self.hash, self.key, value)\n             },\n             NoElem(bucket, disp) => {\n                 if disp >= DISPLACEMENT_THRESHOLD {\n                     *self.long_probes = true;\n                 }\n-                let bucket = bucket.put(self.hash, self.key, value);\n-                bucket.into_mut_refs().1\n+                bucket.put(self.hash, self.key, value).into_mut_refs().1\n             },\n         }\n     }"}]}