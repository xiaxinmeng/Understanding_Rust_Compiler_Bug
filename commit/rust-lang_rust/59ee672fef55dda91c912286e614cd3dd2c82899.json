{"sha": "59ee672fef55dda91c912286e614cd3dd2c82899", "node_id": "C_kwDOAAsO6NoAKDU5ZWU2NzJmZWY1NWRkYTkxYzkxMjI4NmU2MTRjZDNkZDJjODI4OTk", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-04-07T19:27:57Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-04-07T20:19:00Z"}, "message": "for variadic functions, accept arbitrary trailing arguments but make sure we check all leading arguments", "tree": {"sha": "a66a359ccf743bd83b6bb52fbfd5935ad0937329", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a66a359ccf743bd83b6bb52fbfd5935ad0937329"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/59ee672fef55dda91c912286e614cd3dd2c82899", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/59ee672fef55dda91c912286e614cd3dd2c82899", "html_url": "https://github.com/rust-lang/rust/commit/59ee672fef55dda91c912286e614cd3dd2c82899", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/59ee672fef55dda91c912286e614cd3dd2c82899/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8acc9b2799f5587f5f29dfce487ec3aa94964dfe", "url": "https://api.github.com/repos/rust-lang/rust/commits/8acc9b2799f5587f5f29dfce487ec3aa94964dfe", "html_url": "https://github.com/rust-lang/rust/commit/8acc9b2799f5587f5f29dfce487ec3aa94964dfe"}], "stats": {"total": 102, "additions": 52, "deletions": 50}, "files": [{"sha": "11b9082da64d79f01dd90f2eb6fcb7f253b23360", "filename": "src/shims/posix/fs.rs", "status": "modified", "additions": 17, "deletions": 14, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/59ee672fef55dda91c912286e614cd3dd2c82899/src%2Fshims%2Fposix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59ee672fef55dda91c912286e614cd3dd2c82899/src%2Fshims%2Fposix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fposix%2Ffs.rs?ref=59ee672fef55dda91c912286e614cd3dd2c82899", "patch": "@@ -15,7 +15,6 @@ use rustc_middle::ty::{self, layout::LayoutOf};\n use rustc_target::abi::{Align, Size};\n \n use crate::*;\n-use helpers::check_arg_count;\n use shims::os_str::os_str_to_bytes;\n use shims::time::system_time_to_duration;\n \n@@ -479,16 +478,16 @@ fn maybe_sync_file(\n impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n     fn open(&mut self, args: &[OpTy<'tcx, Tag>]) -> InterpResult<'tcx, i32> {\n-        if args.len() < 2 || args.len() > 3 {\n+        if args.len() < 2 {\n             throw_ub_format!(\n-                \"incorrect number of arguments for `open`: got {}, expected 2 or 3\",\n+                \"incorrect number of arguments for `open`: got {}, expected at least 2\",\n                 args.len()\n             );\n         }\n \n         let this = self.eval_context_mut();\n \n-        let path_op = &args[0];\n+        let path = this.read_pointer(&args[0])?;\n         let flag = this.read_scalar(&args[1])?.to_i32()?;\n \n         let mut options = OpenOptions::new();\n@@ -541,7 +540,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.read_scalar(arg)?.to_u32()?\n             } else {\n                 throw_ub_format!(\n-                    \"incorrect number of arguments for `open` with `O_CREAT`: got {}, expected 3\",\n+                    \"incorrect number of arguments for `open` with `O_CREAT`: got {}, expected at least 3\",\n                     args.len()\n                 );\n             };\n@@ -572,7 +571,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             throw_unsup_format!(\"unsupported flags {:#x}\", flag & !mirror);\n         }\n \n-        let path = this.read_path_from_c_str(this.read_pointer(path_op)?)?;\n+        let path = this.read_path_from_c_str(path)?;\n \n         // Reject if isolation is enabled.\n         if let IsolatedOp::Reject(reject_with) = this.machine.isolated_op {\n@@ -614,7 +613,6 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             // `FD_CLOEXEC` value without checking if the flag is set for the file because `std`\n             // always sets this flag when opening a file. However we still need to check that the\n             // file itself is open.\n-            let &[_, _] = check_arg_count(args)?;\n             if this.machine.file_handler.handles.contains_key(&fd) {\n                 Ok(this.eval_libc_i32(\"FD_CLOEXEC\")?)\n             } else {\n@@ -627,8 +625,13 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             // because exec() isn't supported. The F_DUPFD and F_DUPFD_CLOEXEC commands only\n             // differ in whether the FD_CLOEXEC flag is pre-set on the new file descriptor,\n             // thus they can share the same implementation here.\n-            let &[_, _, ref start] = check_arg_count(args)?;\n-            let start = this.read_scalar(start)?.to_i32()?;\n+            if args.len() < 3 {\n+                throw_ub_format!(\n+                    \"incorrect number of arguments for fcntl with cmd=`F_DUPFD`/`F_DUPFD_CLOEXEC`: got {}, expected at least 3\",\n+                    args.len()\n+                );\n+            }\n+            let start = this.read_scalar(&args[2])?.to_i32()?;\n \n             let fh = &mut this.machine.file_handler;\n \n@@ -646,7 +649,6 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 None => return this.handle_not_found(),\n             }\n         } else if this.tcx.sess.target.os == \"macos\" && cmd == this.eval_libc_i32(\"F_FULLFSYNC\")? {\n-            let &[_, _] = check_arg_count(args)?;\n             if let Some(file_descriptor) = this.machine.file_handler.handles.get(&fd) {\n                 // FIXME: Support fullfsync for all FDs\n                 let FileHandle { file, writable } = file_descriptor.as_file_handle()?;\n@@ -919,15 +921,18 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         dirfd_op: &OpTy<'tcx, Tag>,    // Should be an `int`\n         pathname_op: &OpTy<'tcx, Tag>, // Should be a `const char *`\n         flags_op: &OpTy<'tcx, Tag>,    // Should be an `int`\n-        _mask_op: &OpTy<'tcx, Tag>,    // Should be an `unsigned int`\n+        mask_op: &OpTy<'tcx, Tag>,    // Should be an `unsigned int`\n         statxbuf_op: &OpTy<'tcx, Tag>, // Should be a `struct statx *`\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n         this.assert_target_os(\"linux\", \"statx\");\n \n-        let statxbuf_ptr = this.read_pointer(statxbuf_op)?;\n+        let dirfd = this.read_scalar(dirfd_op)?.to_i32()?;\n         let pathname_ptr = this.read_pointer(pathname_op)?;\n+        let flags = this.read_scalar(flags_op)?.to_i32()?;\n+        let _mask = this.read_scalar(mask_op)?.to_u32()?;\n+        let statxbuf_ptr = this.read_pointer(statxbuf_op)?;\n \n         // If the statxbuf or pathname pointers are null, the function fails with `EFAULT`.\n         if this.ptr_is_null(statxbuf_ptr)? || this.ptr_is_null(pathname_ptr)? {\n@@ -953,9 +958,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         let path = this.read_path_from_c_str(pathname_ptr)?.into_owned();\n         // See <https://github.com/rust-lang/rust/pull/79196> for a discussion of argument sizes.\n-        let flags = this.read_scalar(flags_op)?.to_i32()?;\n         let empty_path_flag = flags & this.eval_libc(\"AT_EMPTY_PATH\")?.to_i32()? != 0;\n-        let dirfd = this.read_scalar(dirfd_op)?.to_i32()?;\n         // We only support:\n         // * interpreting `path` as an absolute directory,\n         // * interpreting `path` as a path relative to `dirfd` when the latter is `AT_FDCWD`, or"}, {"sha": "453c77f1b5342b36c69269b9385bbcf039e402b6", "filename": "src/shims/posix/linux/foreign_items.rs", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/59ee672fef55dda91c912286e614cd3dd2c82899/src%2Fshims%2Fposix%2Flinux%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59ee672fef55dda91c912286e614cd3dd2c82899/src%2Fshims%2Fposix%2Flinux%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fposix%2Flinux%2Fforeign_items.rs?ref=59ee672fef55dda91c912286e614cd3dd2c82899", "patch": "@@ -130,16 +130,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 // count is checked bellow.\n                 this.check_abi_and_shim_symbol_clash(abi, Abi::C { unwind: false }, link_name)?;\n                 // The syscall variadic function is legal to call with more arguments than needed,\n-                // extra arguments are simply ignored. However, all arguments need to be scalars;\n-                // other types might be treated differently by the calling convention.\n-                for arg in args {\n-                    if !matches!(arg.layout.abi, rustc_target::abi::Abi::Scalar(_)) {\n-                        throw_ub_format!(\n-                            \"`syscall` arguments must all have scalar layout, but {} does not\",\n-                            arg.layout.ty\n-                        );\n-                    }\n-                }\n+                // extra arguments are simply ignored. The important check is that when we use an\n+                // argument, we have to also check all arguments *before* it to ensure that they\n+                // have the right type.\n \n                 let sys_getrandom = this.eval_libc(\"SYS_getrandom\")?.to_machine_usize(this)?;\n \n@@ -181,7 +174,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                     }\n                     // `futex` is used by some synchonization primitives.\n                     id if id == sys_futex => {\n-                        futex(this, args, dest)?;\n+                        futex(this, &args[1..], dest)?;\n                     }\n                     id => {\n                         this.handle_unsupported(format!(\"can't execute syscall with ID {}\", id))?;"}, {"sha": "362373bb7d3b3df66e15c9e1238f45956a04c8e4", "filename": "src/shims/posix/linux/sync.rs", "status": "modified", "additions": 23, "deletions": 17, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/59ee672fef55dda91c912286e614cd3dd2c82899/src%2Fshims%2Fposix%2Flinux%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59ee672fef55dda91c912286e614cd3dd2c82899/src%2Fshims%2Fposix%2Flinux%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fposix%2Flinux%2Fsync.rs?ref=59ee672fef55dda91c912286e614cd3dd2c82899", "patch": "@@ -4,6 +4,7 @@ use rustc_target::abi::{Align, Size};\n use std::time::{Instant, SystemTime};\n \n /// Implementation of the SYS_futex syscall.\n+/// `args` is the arguments *after* the syscall number.\n pub fn futex<'tcx>(\n     this: &mut MiriEvalContext<'_, 'tcx>,\n     args: &[OpTy<'tcx, Tag>],\n@@ -17,22 +18,23 @@ pub fn futex<'tcx>(\n     // may or may not be left out from the `syscall()` call.\n     // Therefore we don't use `check_arg_count` here, but only check for the\n     // number of arguments to fall within a range.\n-    if args.len() < 4 {\n+    if args.len() < 3 {\n         throw_ub_format!(\n-            \"incorrect number of arguments for `futex` syscall: got {}, expected at least 4\",\n+            \"incorrect number of arguments for `futex` syscall: got {}, expected at least 3\",\n             args.len()\n         );\n     }\n \n     // The first three arguments (after the syscall number itself) are the same to all futex operations:\n     //     (int *addr, int op, int val).\n     // We checked above that these definitely exist.\n-    let addr = this.read_immediate(&args[1])?;\n-    let op = this.read_scalar(&args[2])?.to_i32()?;\n-    let val = this.read_scalar(&args[3])?.to_i32()?;\n+    let addr = this.read_immediate(&args[0])?;\n+    let op = this.read_scalar(&args[1])?.to_i32()?;\n+    let val = this.read_scalar(&args[2])?.to_i32()?;\n \n     let thread = this.get_active_thread();\n     let addr_scalar = addr.to_scalar()?;\n+    let addr_usize = addr_scalar.to_machine_usize(this)?;\n \n     let futex_private = this.eval_libc_i32(\"FUTEX_PRIVATE_FLAG\")?;\n     let futex_wait = this.eval_libc_i32(\"FUTEX_WAIT\")?;\n@@ -56,17 +58,19 @@ pub fn futex<'tcx>(\n             let wait_bitset = op & !futex_realtime == futex_wait_bitset;\n \n             let bitset = if wait_bitset {\n-                if args.len() != 7 {\n+                if args.len() < 6 {\n                     throw_ub_format!(\n-                        \"incorrect number of arguments for `futex` syscall with `op=FUTEX_WAIT_BITSET`: got {}, expected 7\",\n+                        \"incorrect number of arguments for `futex` syscall with `op=FUTEX_WAIT_BITSET`: got {}, expected at least 6\",\n                         args.len()\n                     );\n                 }\n-                this.read_scalar(&args[6])?.to_u32()?\n+                let _timeout = this.read_pointer(&args[3])?;\n+                let _uaddr2 = this.read_pointer(&args[4])?;\n+                this.read_scalar(&args[5])?.to_u32()?\n             } else {\n-                if args.len() < 5 {\n+                if args.len() < 4 {\n                     throw_ub_format!(\n-                        \"incorrect number of arguments for `futex` syscall with `op=FUTEX_WAIT`: got {}, expected at least 5\",\n+                        \"incorrect number of arguments for `futex` syscall with `op=FUTEX_WAIT`: got {}, expected at least 4\",\n                         args.len()\n                     );\n                 }\n@@ -81,7 +85,7 @@ pub fn futex<'tcx>(\n             }\n \n             // `deref_operand` but not actually dereferencing the ptr yet (it might be NULL!).\n-            let timeout = this.ref_to_mplace(&this.read_immediate(&args[4])?)?;\n+            let timeout = this.ref_to_mplace(&this.read_immediate(&args[3])?)?;\n             let timeout_time = if this.ptr_is_null(timeout.ptr)? {\n                 None\n             } else {\n@@ -145,7 +149,7 @@ pub fn futex<'tcx>(\n             if val == futex_val {\n                 // The value still matches, so we block the trait make it wait for FUTEX_WAKE.\n                 this.block_thread(thread);\n-                this.futex_wait(addr_scalar.to_machine_usize(this)?, thread, bitset);\n+                this.futex_wait(addr_usize, thread, bitset);\n                 // Succesfully waking up from FUTEX_WAIT always returns zero.\n                 this.write_scalar(Scalar::from_machine_isize(0, this), dest)?;\n                 // Register a timeout callback if a timeout was specified.\n@@ -157,7 +161,7 @@ pub fn futex<'tcx>(\n                         timeout_time,\n                         Box::new(move |this| {\n                             this.unblock_thread(thread);\n-                            this.futex_remove_waiter(addr_scalar.to_machine_usize(this)?, thread);\n+                            this.futex_remove_waiter(addr_usize, thread);\n                             let etimedout = this.eval_libc(\"ETIMEDOUT\")?;\n                             this.set_last_error(etimedout)?;\n                             this.write_scalar(Scalar::from_machine_isize(-1, this), &dest)?;\n@@ -181,13 +185,15 @@ pub fn futex<'tcx>(\n         // Same as FUTEX_WAKE, but allows you to specify a bitset to select which threads to wake up.\n         op if op == futex_wake || op == futex_wake_bitset => {\n             let bitset = if op == futex_wake_bitset {\n-                if args.len() != 7 {\n+                if args.len() < 6 {\n                     throw_ub_format!(\n-                        \"incorrect number of arguments for `futex` syscall with `op=FUTEX_WAKE_BITSET`: got {}, expected 7\",\n+                        \"incorrect number of arguments for `futex` syscall with `op=FUTEX_WAKE_BITSET`: got {}, expected at least 6\",\n                         args.len()\n                     );\n                 }\n-                this.read_scalar(&args[6])?.to_u32()?\n+                let _timeout = this.read_pointer(&args[3])?;\n+                let _uaddr2 = this.read_pointer(&args[4])?;\n+                this.read_scalar(&args[5])?.to_u32()?\n             } else {\n                 u32::MAX\n             };\n@@ -199,7 +205,7 @@ pub fn futex<'tcx>(\n             }\n             let mut n = 0;\n             for _ in 0..val {\n-                if let Some(thread) = this.futex_wake(addr_scalar.to_machine_usize(this)?, bitset) {\n+                if let Some(thread) = this.futex_wake(addr_usize, bitset) {\n                     this.unblock_thread(thread);\n                     this.unregister_timeout_callback_if_exists(thread);\n                     n += 1;"}, {"sha": "4ac928398e238e340dfa1419386d0580f3f7c37b", "filename": "tests/run-pass/concurrency/linux-futex.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/59ee672fef55dda91c912286e614cd3dd2c82899/tests%2Frun-pass%2Fconcurrency%2Flinux-futex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59ee672fef55dda91c912286e614cd3dd2c82899/tests%2Frun-pass%2Fconcurrency%2Flinux-futex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fconcurrency%2Flinux-futex.rs?ref=59ee672fef55dda91c912286e614cd3dd2c82899", "patch": "@@ -32,8 +32,8 @@ fn wake_nobody() {\n             &futex as *const i32,\n             libc::FUTEX_WAKE,\n             1,\n-            0,\n-            0,\n+            ptr::null::<libc::timespec>(),\n+            0usize,\n             0,\n         ), 0);\n     }\n@@ -121,7 +121,7 @@ fn wait_absolute_timeout() {\n             libc::FUTEX_WAIT_BITSET,\n             123,\n             &timeout,\n-            0,\n+            0usize,\n             u32::MAX,\n         ), -1);\n         assert_eq!(*libc::__errno_location(), libc::ETIMEDOUT);\n@@ -173,8 +173,8 @@ fn wait_wake_bitset() {\n                 &FUTEX as *const i32,\n                 libc::FUTEX_WAKE_BITSET,\n                 10, // Wake up at most 10 threads.\n-                0,\n-                0,\n+                ptr::null::<libc::timespec>(),\n+                0usize,\n                 0b1001, // bitset\n             ), 0); // Didn't match any thread.\n         }\n@@ -185,8 +185,8 @@ fn wait_wake_bitset() {\n                 &FUTEX as *const i32,\n                 libc::FUTEX_WAKE_BITSET,\n                 10, // Wake up at most 10 threads.\n-                0,\n-                0,\n+                ptr::null::<libc::timespec>(),\n+                0usize,\n                 0b0110, // bitset\n             ), 1); // Woken up one thread.\n         }\n@@ -199,7 +199,7 @@ fn wait_wake_bitset() {\n             libc::FUTEX_WAIT_BITSET,\n             0,\n             ptr::null::<libc::timespec>(),\n-            0,\n+            0usize,\n             0b0100, // bitset\n         ), 0);\n     }"}]}