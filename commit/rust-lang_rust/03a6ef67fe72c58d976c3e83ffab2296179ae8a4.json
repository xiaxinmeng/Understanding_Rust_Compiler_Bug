{"sha": "03a6ef67fe72c58d976c3e83ffab2296179ae8a4", "node_id": "C_kwDOAAsO6NoAKDAzYTZlZjY3ZmU3MmM1OGQ5NzZjM2U4M2ZmYWIyMjk2MTc5YWU4YTQ", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2023-04-03T16:13:06Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2023-04-03T16:13:06Z"}, "message": "Only emit lint on refutable patterns.", "tree": {"sha": "954b61fd1f8580de2e17626aa86f6c7e2cd64530", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/954b61fd1f8580de2e17626aa86f6c7e2cd64530"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/03a6ef67fe72c58d976c3e83ffab2296179ae8a4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/03a6ef67fe72c58d976c3e83ffab2296179ae8a4", "html_url": "https://github.com/rust-lang/rust/commit/03a6ef67fe72c58d976c3e83ffab2296179ae8a4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/03a6ef67fe72c58d976c3e83ffab2296179ae8a4/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "03fbb3db1e3dd767caebe176a368e0e52aeb68cb", "url": "https://api.github.com/repos/rust-lang/rust/commits/03fbb3db1e3dd767caebe176a368e0e52aeb68cb", "html_url": "https://github.com/rust-lang/rust/commit/03fbb3db1e3dd767caebe176a368e0e52aeb68cb"}], "stats": {"total": 18, "additions": 10, "deletions": 8}, "files": [{"sha": "0882b473f10877a62c730201dd6e466e2b1ee66b", "filename": "compiler/rustc_mir_build/src/thir/pattern/check_match.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/03a6ef67fe72c58d976c3e83ffab2296179ae8a4/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03a6ef67fe72c58d976c3e83ffab2296179ae8a4/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs?ref=03a6ef67fe72c58d976c3e83ffab2296179ae8a4", "patch": "@@ -199,12 +199,13 @@ impl<'p, 'tcx> MatchVisitor<'_, 'p, 'tcx> {\n         cx.pattern_arena.alloc(DeconstructedPat::from_pat(cx, &pattern))\n     }\n \n-    fn new_cx(&self, hir_id: HirId) -> MatchCheckCtxt<'p, 'tcx> {\n+    fn new_cx(&self, hir_id: HirId, refutable: bool) -> MatchCheckCtxt<'p, 'tcx> {\n         MatchCheckCtxt {\n             tcx: self.tcx,\n             param_env: self.param_env,\n             module: self.tcx.parent_module(hir_id).to_def_id(),\n             pattern_arena: &self.pattern_arena,\n+            refutable,\n         }\n     }\n \n@@ -214,7 +215,7 @@ impl<'p, 'tcx> MatchVisitor<'_, 'p, 'tcx> {\n             return;\n         }\n         self.check_patterns(pat, Refutable);\n-        let mut cx = self.new_cx(self.lint_level);\n+        let mut cx = self.new_cx(self.lint_level, true);\n         let tpat = self.lower_pattern(&mut cx, pat);\n         self.check_let_reachability(&mut cx, self.lint_level, source, tpat, span);\n     }\n@@ -226,7 +227,7 @@ impl<'p, 'tcx> MatchVisitor<'_, 'p, 'tcx> {\n         source: hir::MatchSource,\n         expr_span: Span,\n     ) {\n-        let mut cx = self.new_cx(self.lint_level);\n+        let mut cx = self.new_cx(self.lint_level, true);\n \n         for &arm in arms {\n             // Check the arm for some things unrelated to exhaustiveness.\n@@ -328,7 +329,7 @@ impl<'p, 'tcx> MatchVisitor<'_, 'p, 'tcx> {\n             debug!(?expr, ?local_lint_level, \"after scopes\");\n             match expr.kind {\n                 ExprKind::Let { box ref pat, expr: _ } => {\n-                    let mut ncx = self.new_cx(local_lint_level);\n+                    let mut ncx = self.new_cx(local_lint_level, true);\n                     let tpat = self.lower_pattern(&mut ncx, pat);\n                     let refutable = !is_let_irrefutable(&mut ncx, local_lint_level, tpat);\n                     Some((expr.span, refutable))\n@@ -409,7 +410,7 @@ impl<'p, 'tcx> MatchVisitor<'_, 'p, 'tcx> {\n \n     #[instrument(level = \"trace\", skip(self))]\n     fn check_irrefutable(&self, pat: &Pat<'tcx>, origin: &str, sp: Option<Span>) {\n-        let mut cx = self.new_cx(self.lint_level);\n+        let mut cx = self.new_cx(self.lint_level, false);\n \n         let pattern = self.lower_pattern(&mut cx, pat);\n         let pattern_ty = pattern.ty();"}, {"sha": "8c89bcb8cec8f2f685d6827b174eb03f0ea9382e", "filename": "compiler/rustc_mir_build/src/thir/pattern/usefulness.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/03a6ef67fe72c58d976c3e83ffab2296179ae8a4/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03a6ef67fe72c58d976c3e83ffab2296179ae8a4/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs?ref=03a6ef67fe72c58d976c3e83ffab2296179ae8a4", "patch": "@@ -300,7 +300,6 @@ use rustc_arena::TypedArena;\n use rustc_data_structures::stack::ensure_sufficient_stack;\n use rustc_hir::def_id::DefId;\n use rustc_hir::HirId;\n-use rustc_hir::Node;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_session::lint::builtin::NON_EXHAUSTIVE_OMITTED_PATTERNS;\n use rustc_span::{Span, DUMMY_SP};\n@@ -319,6 +318,8 @@ pub(crate) struct MatchCheckCtxt<'p, 'tcx> {\n     pub(crate) module: DefId,\n     pub(crate) param_env: ty::ParamEnv<'tcx>,\n     pub(crate) pattern_arena: &'p TypedArena<DeconstructedPat<'p, 'tcx>>,\n+    /// Only produce `NON_EXHAUSTIVE_OMITTED_PATTERNS` lint on refutable patterns.\n+    pub(crate) refutable: bool,\n }\n \n impl<'a, 'tcx> MatchCheckCtxt<'a, 'tcx> {\n@@ -860,6 +861,8 @@ fn is_useful<'p, 'tcx>(\n             // that has the potential to trigger the `non_exhaustive_omitted_patterns` lint.\n             // To understand the workings checkout `Constructor::split` and `SplitWildcard::new/into_ctors`\n             if is_non_exhaustive_and_wild\n+                // Only emit a lint on refutable patterns.\n+                && cx.refutable\n                 // We check that the match has a wildcard pattern and that wildcard is useful,\n                 // meaning there are variants that are covered by the wildcard. Without the check\n                 // for `witness_preference` the lint would trigger on `if let NonExhaustiveEnum::A = foo {}`\n@@ -868,8 +871,6 @@ fn is_useful<'p, 'tcx>(\n                     &ctor,\n                     Constructor::Missing { nonexhaustive_enum_missing_real_variants: true }\n                 )\n-                // We don't want to lint patterns which are function arguments or locals\n-                && !matches!(cx.tcx.hir().find_parent(hir_id), Some(Node::Param(_)|Node::Local(_)))\n             {\n                 let patterns = {\n                     let mut split_wildcard = SplitWildcard::new(pcx);"}]}