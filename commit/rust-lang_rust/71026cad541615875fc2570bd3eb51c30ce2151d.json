{"sha": "71026cad541615875fc2570bd3eb51c30ce2151d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcxMDI2Y2FkNTQxNjE1ODc1ZmMyNTcwYmQzZWI1MWMzMGNlMjE1MWQ=", "commit": {"author": {"name": "nahuakang", "email": "kangnahua@gmail.com", "date": "2021-02-08T21:01:05Z"}, "committer": {"name": "Yoshitomo Nakanishi", "email": "yurayura.rounin.3@gmail.com", "date": "2021-03-02T09:13:32Z"}, "message": "Refactor check_for_loop_explicit_counter to its own module", "tree": {"sha": "1c089facebce3993e355247f9a156ab12fdb1353", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1c089facebce3993e355247f9a156ab12fdb1353"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/71026cad541615875fc2570bd3eb51c30ce2151d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/71026cad541615875fc2570bd3eb51c30ce2151d", "html_url": "https://github.com/rust-lang/rust/commit/71026cad541615875fc2570bd3eb51c30ce2151d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/71026cad541615875fc2570bd3eb51c30ce2151d/comments", "author": {"login": "nahuakang", "id": 18533347, "node_id": "MDQ6VXNlcjE4NTMzMzQ3", "avatar_url": "https://avatars.githubusercontent.com/u/18533347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nahuakang", "html_url": "https://github.com/nahuakang", "followers_url": "https://api.github.com/users/nahuakang/followers", "following_url": "https://api.github.com/users/nahuakang/following{/other_user}", "gists_url": "https://api.github.com/users/nahuakang/gists{/gist_id}", "starred_url": "https://api.github.com/users/nahuakang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nahuakang/subscriptions", "organizations_url": "https://api.github.com/users/nahuakang/orgs", "repos_url": "https://api.github.com/users/nahuakang/repos", "events_url": "https://api.github.com/users/nahuakang/events{/privacy}", "received_events_url": "https://api.github.com/users/nahuakang/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Y-Nak", "id": 6376004, "node_id": "MDQ6VXNlcjYzNzYwMDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6376004?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Y-Nak", "html_url": "https://github.com/Y-Nak", "followers_url": "https://api.github.com/users/Y-Nak/followers", "following_url": "https://api.github.com/users/Y-Nak/following{/other_user}", "gists_url": "https://api.github.com/users/Y-Nak/gists{/gist_id}", "starred_url": "https://api.github.com/users/Y-Nak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Y-Nak/subscriptions", "organizations_url": "https://api.github.com/users/Y-Nak/orgs", "repos_url": "https://api.github.com/users/Y-Nak/repos", "events_url": "https://api.github.com/users/Y-Nak/events{/privacy}", "received_events_url": "https://api.github.com/users/Y-Nak/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "71c9fdf8b136cf9f879d5ca99615043ef6d09e68", "url": "https://api.github.com/repos/rust-lang/rust/commits/71c9fdf8b136cf9f879d5ca99615043ef6d09e68", "html_url": "https://github.com/rust-lang/rust/commit/71c9fdf8b136cf9f879d5ca99615043ef6d09e68"}], "stats": {"total": 133, "additions": 71, "deletions": 62}, "files": [{"sha": "68fee269eb1d6f3ac5f65e9ef5ab864745805417", "filename": "clippy_lints/src/loops/for_loop_explicit_counter.rs", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/71026cad541615875fc2570bd3eb51c30ce2151d/clippy_lints%2Fsrc%2Floops%2Ffor_loop_explicit_counter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71026cad541615875fc2570bd3eb51c30ce2151d/clippy_lints%2Fsrc%2Floops%2Ffor_loop_explicit_counter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Ffor_loop_explicit_counter.rs?ref=71026cad541615875fc2570bd3eb51c30ce2151d", "patch": "@@ -0,0 +1,56 @@\n+use super::{get_span_of_entire_for_loop, make_iterator_snippet, IncrementVisitor, InitializeVisitor};\n+use crate::utils::{get_enclosing_block, is_integer_const, snippet_with_applicability, span_lint_and_sugg};\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir::intravisit::{walk_block, walk_expr};\n+use rustc_hir::{Expr, Pat};\n+use rustc_lint::LateContext;\n+\n+// To trigger the EXPLICIT_COUNTER_LOOP lint, a variable must be\n+// incremented exactly once in the loop body, and initialized to zero\n+// at the start of the loop.\n+pub(super) fn check_for_loop_explicit_counter<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    pat: &'tcx Pat<'_>,\n+    arg: &'tcx Expr<'_>,\n+    body: &'tcx Expr<'_>,\n+    expr: &'tcx Expr<'_>,\n+) {\n+    // Look for variables that are incremented once per loop iteration.\n+    let mut increment_visitor = IncrementVisitor::new(cx);\n+    walk_expr(&mut increment_visitor, body);\n+\n+    // For each candidate, check the parent block to see if\n+    // it's initialized to zero at the start of the loop.\n+    if let Some(block) = get_enclosing_block(&cx, expr.hir_id) {\n+        for id in increment_visitor.into_results() {\n+            let mut initialize_visitor = InitializeVisitor::new(cx, expr, id);\n+            walk_block(&mut initialize_visitor, block);\n+\n+            if_chain! {\n+                if let Some((name, initializer)) = initialize_visitor.get_result();\n+                if is_integer_const(cx, initializer, 0);\n+                then {\n+                    let mut applicability = Applicability::MachineApplicable;\n+\n+                    let for_span = get_span_of_entire_for_loop(expr);\n+\n+                    span_lint_and_sugg(\n+                        cx,\n+                        super::EXPLICIT_COUNTER_LOOP,\n+                        for_span.with_hi(arg.span.hi()),\n+                        &format!(\"the variable `{}` is used as a loop counter\", name),\n+                        \"consider using\",\n+                        format!(\n+                            \"for ({}, {}) in {}.enumerate()\",\n+                            name,\n+                            snippet_with_applicability(cx, pat.span, \"item\", &mut applicability),\n+                            make_iterator_snippet(cx, arg, &mut applicability),\n+                        ),\n+                        applicability,\n+                    );\n+                }\n+            }\n+        }\n+    }\n+}"}, {"sha": "f06b3ae4c9ffcdfe531fccb59549157e6edb1e52", "filename": "clippy_lints/src/loops/mod.rs", "status": "modified", "additions": 3, "deletions": 62, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/71026cad541615875fc2570bd3eb51c30ce2151d/clippy_lints%2Fsrc%2Floops%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71026cad541615875fc2570bd3eb51c30ce2151d/clippy_lints%2Fsrc%2Floops%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fmod.rs?ref=71026cad541615875fc2570bd3eb51c30ce2151d", "patch": "@@ -1,4 +1,5 @@\n mod for_loop_arg;\n+mod for_loop_explicit_counter;\n mod for_loop_over_map_kv;\n mod for_loop_range;\n mod for_mut_range_bound;\n@@ -32,7 +33,7 @@ use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::Span;\n use rustc_span::symbol::{sym, Ident, Symbol};\n use std::iter::{once, Iterator};\n-use utils::make_iterator_snippet;\n+use utils::{get_span_of_entire_for_loop, make_iterator_snippet};\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for for-loops that manually copy items between\n@@ -857,7 +858,7 @@ fn check_for_loop<'tcx>(\n     let is_manual_memcpy_triggered = detect_manual_memcpy(cx, pat, arg, body, expr);\n     if !is_manual_memcpy_triggered {\n         for_loop_range::check_for_loop_range(cx, pat, arg, body, expr);\n-        check_for_loop_explicit_counter(cx, pat, arg, body, expr);\n+        for_loop_explicit_counter::check_for_loop_explicit_counter(cx, pat, arg, body, expr);\n     }\n     for_loop_arg::check_for_loop_arg(cx, pat, arg, expr);\n     for_loop_over_map_kv::check_for_loop_over_map_kv(cx, pat, arg, body, expr);\n@@ -867,17 +868,6 @@ fn check_for_loop<'tcx>(\n     manual_flatten::check_manual_flatten(cx, pat, arg, body, span);\n }\n \n-// this function assumes the given expression is a `for` loop.\n-fn get_span_of_entire_for_loop(expr: &Expr<'_>) -> Span {\n-    // for some reason this is the only way to get the `Span`\n-    // of the entire `for` loop\n-    if let ExprKind::Match(_, arms, _) = &expr.kind {\n-        arms[0].body.span\n-    } else {\n-        unreachable!()\n-    }\n-}\n-\n /// a wrapper of `Sugg`. Besides what `Sugg` do, this removes unnecessary `0`;\n /// and also, it avoids subtracting a variable from the same one by replacing it with `0`.\n /// it exists for the convenience of the overloaded operators while normal functions can do the\n@@ -1474,55 +1464,6 @@ fn detect_same_item_push<'tcx>(\n     }\n }\n \n-// To trigger the EXPLICIT_COUNTER_LOOP lint, a variable must be\n-// incremented exactly once in the loop body, and initialized to zero\n-// at the start of the loop.\n-fn check_for_loop_explicit_counter<'tcx>(\n-    cx: &LateContext<'tcx>,\n-    pat: &'tcx Pat<'_>,\n-    arg: &'tcx Expr<'_>,\n-    body: &'tcx Expr<'_>,\n-    expr: &'tcx Expr<'_>,\n-) {\n-    // Look for variables that are incremented once per loop iteration.\n-    let mut increment_visitor = IncrementVisitor::new(cx);\n-    walk_expr(&mut increment_visitor, body);\n-\n-    // For each candidate, check the parent block to see if\n-    // it's initialized to zero at the start of the loop.\n-    if let Some(block) = get_enclosing_block(&cx, expr.hir_id) {\n-        for id in increment_visitor.into_results() {\n-            let mut initialize_visitor = InitializeVisitor::new(cx, expr, id);\n-            walk_block(&mut initialize_visitor, block);\n-\n-            if_chain! {\n-                if let Some((name, initializer)) = initialize_visitor.get_result();\n-                if is_integer_const(cx, initializer, 0);\n-                then {\n-                    let mut applicability = Applicability::MachineApplicable;\n-\n-                    let for_span = get_span_of_entire_for_loop(expr);\n-\n-                    span_lint_and_sugg(\n-                        cx,\n-                        EXPLICIT_COUNTER_LOOP,\n-                        for_span.with_hi(arg.span.hi()),\n-                        &format!(\"the variable `{}` is used as a loop counter\", name),\n-                        \"consider using\",\n-                        format!(\n-                            \"for ({}, {}) in {}.enumerate()\",\n-                            name,\n-                            snippet_with_applicability(cx, pat.span, \"item\", &mut applicability),\n-                            make_iterator_snippet(cx, arg, &mut applicability),\n-                        ),\n-                        applicability,\n-                    );\n-                }\n-            }\n-        }\n-    }\n-}\n-\n fn check_for_single_element_loop<'tcx>(\n     cx: &LateContext<'tcx>,\n     pat: &'tcx Pat<'_>,"}, {"sha": "b9c934d5e549dc9a86ba662bf64e0cf3a37aa97e", "filename": "clippy_lints/src/loops/utils.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/71026cad541615875fc2570bd3eb51c30ce2151d/clippy_lints%2Fsrc%2Floops%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71026cad541615875fc2570bd3eb51c30ce2151d/clippy_lints%2Fsrc%2Floops%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Futils.rs?ref=71026cad541615875fc2570bd3eb51c30ce2151d", "patch": "@@ -2,6 +2,18 @@ use crate::utils::{get_trait_def_id, has_iter_method, implements_trait, paths, s\n use rustc_errors::Applicability;\n use rustc_hir::{BorrowKind, Expr, ExprKind, Mutability};\n use rustc_lint::LateContext;\n+use rustc_span::source_map::Span;\n+\n+// this function assumes the given expression is a `for` loop.\n+pub(super) fn get_span_of_entire_for_loop(expr: &Expr<'_>) -> Span {\n+    // for some reason this is the only way to get the `Span`\n+    // of the entire `for` loop\n+    if let ExprKind::Match(_, arms, _) = &expr.kind {\n+        arms[0].body.span\n+    } else {\n+        unreachable!()\n+    }\n+}\n \n /// If `arg` was the argument to a `for` loop, return the \"cleanest\" way of writing the\n /// actual `Iterator` that the loop uses."}]}