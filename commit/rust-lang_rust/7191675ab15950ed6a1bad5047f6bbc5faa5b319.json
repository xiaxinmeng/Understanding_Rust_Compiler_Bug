{"sha": "7191675ab15950ed6a1bad5047f6bbc5faa5b319", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcxOTE2NzVhYjE1OTUwZWQ2YTFiYWQ1MDQ3ZjZiYmM1ZmFhNWIzMTk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-05-06T07:46:52Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-05-06T07:46:52Z"}, "message": "Auto merge of #7166 - TaKO8Ki:refactor_misc_early_module, r=llogiq\n\nRefactor: arrange lints in misc_early module\n\nThis PR arranges misc_early lints so that they can be accessed more easily.\nBasically, I refactored them following the instruction described in #6680.\n\ncc: `@Y-Nak,` `@flip1995,` `@magurotuna`\n\nchangelog: Move lints in misc_early module into their own modules.", "tree": {"sha": "3cd3c2b5f3bc2f340ee69b4bab9631147a3026ce", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3cd3c2b5f3bc2f340ee69b4bab9631147a3026ce"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7191675ab15950ed6a1bad5047f6bbc5faa5b319", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7191675ab15950ed6a1bad5047f6bbc5faa5b319", "html_url": "https://github.com/rust-lang/rust/commit/7191675ab15950ed6a1bad5047f6bbc5faa5b319", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7191675ab15950ed6a1bad5047f6bbc5faa5b319/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9dd87051c79d593301864087657a09bf8837e57b", "url": "https://api.github.com/repos/rust-lang/rust/commits/9dd87051c79d593301864087657a09bf8837e57b", "html_url": "https://github.com/rust-lang/rust/commit/9dd87051c79d593301864087657a09bf8837e57b"}, {"sha": "3fbb060379485605fc8649ba5e749b141fbb9335", "url": "https://api.github.com/repos/rust-lang/rust/commits/3fbb060379485605fc8649ba5e749b141fbb9335", "html_url": "https://github.com/rust-lang/rust/commit/3fbb060379485605fc8649ba5e749b141fbb9335"}], "stats": {"total": 1207, "additions": 636, "deletions": 571}, "files": [{"sha": "3c6a7071c24a7e62cab0d4b2b49c7564e6ee57a3", "filename": "clippy_lints/src/misc_early.rs", "status": "removed", "additions": 0, "deletions": 569, "changes": 569, "blob_url": "https://github.com/rust-lang/rust/blob/9dd87051c79d593301864087657a09bf8837e57b/clippy_lints%2Fsrc%2Fmisc_early.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9dd87051c79d593301864087657a09bf8837e57b/clippy_lints%2Fsrc%2Fmisc_early.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc_early.rs?ref=9dd87051c79d593301864087657a09bf8837e57b", "patch": "@@ -1,569 +0,0 @@\n-use clippy_utils::diagnostics::{span_lint, span_lint_and_help, span_lint_and_sugg, span_lint_and_then};\n-use clippy_utils::source::snippet_opt;\n-use rustc_ast::ast::{\n-    BindingMode, Expr, ExprKind, GenericParamKind, Generics, Lit, LitFloatType, LitIntType, LitKind, Mutability,\n-    NodeId, Pat, PatKind, UnOp,\n-};\n-use rustc_ast::visit::FnKind;\n-use rustc_data_structures::fx::FxHashMap;\n-use rustc_errors::Applicability;\n-use rustc_hir::PrimTy;\n-use rustc_lint::{EarlyContext, EarlyLintPass, LintContext};\n-use rustc_middle::lint::in_external_macro;\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::source_map::Span;\n-\n-declare_clippy_lint! {\n-    /// **What it does:** Checks for structure field patterns bound to wildcards.\n-    ///\n-    /// **Why is this bad?** Using `..` instead is shorter and leaves the focus on\n-    /// the fields that are actually bound.\n-    ///\n-    /// **Known problems:** None.\n-    ///\n-    /// **Example:**\n-    /// ```rust\n-    /// # struct Foo {\n-    /// #     a: i32,\n-    /// #     b: i32,\n-    /// #     c: i32,\n-    /// # }\n-    /// let f = Foo { a: 0, b: 0, c: 0 };\n-    ///\n-    /// // Bad\n-    /// match f {\n-    ///     Foo { a: _, b: 0, .. } => {},\n-    ///     Foo { a: _, b: _, c: _ } => {},\n-    /// }\n-    ///\n-    /// // Good\n-    /// match f {\n-    ///     Foo { b: 0, .. } => {},\n-    ///     Foo { .. } => {},\n-    /// }\n-    /// ```\n-    pub UNNEEDED_FIELD_PATTERN,\n-    restriction,\n-    \"struct fields bound to a wildcard instead of using `..`\"\n-}\n-\n-declare_clippy_lint! {\n-    /// **What it does:** Checks for function arguments having the similar names\n-    /// differing by an underscore.\n-    ///\n-    /// **Why is this bad?** It affects code readability.\n-    ///\n-    /// **Known problems:** None.\n-    ///\n-    /// **Example:**\n-    /// ```rust\n-    /// // Bad\n-    /// fn foo(a: i32, _a: i32) {}\n-    ///\n-    /// // Good\n-    /// fn bar(a: i32, _b: i32) {}\n-    /// ```\n-    pub DUPLICATE_UNDERSCORE_ARGUMENT,\n-    style,\n-    \"function arguments having names which only differ by an underscore\"\n-}\n-\n-declare_clippy_lint! {\n-    /// **What it does:** Detects expressions of the form `--x`.\n-    ///\n-    /// **Why is this bad?** It can mislead C/C++ programmers to think `x` was\n-    /// decremented.\n-    ///\n-    /// **Known problems:** None.\n-    ///\n-    /// **Example:**\n-    /// ```rust\n-    /// let mut x = 3;\n-    /// --x;\n-    /// ```\n-    pub DOUBLE_NEG,\n-    style,\n-    \"`--x`, which is a double negation of `x` and not a pre-decrement as in C/C++\"\n-}\n-\n-declare_clippy_lint! {\n-    /// **What it does:** Warns on hexadecimal literals with mixed-case letter\n-    /// digits.\n-    ///\n-    /// **Why is this bad?** It looks confusing.\n-    ///\n-    /// **Known problems:** None.\n-    ///\n-    /// **Example:**\n-    /// ```rust\n-    /// // Bad\n-    /// let y = 0x1a9BAcD;\n-    ///\n-    /// // Good\n-    /// let y = 0x1A9BACD;\n-    /// ```\n-    pub MIXED_CASE_HEX_LITERALS,\n-    style,\n-    \"hex literals whose letter digits are not consistently upper- or lowercased\"\n-}\n-\n-declare_clippy_lint! {\n-    /// **What it does:** Warns if literal suffixes are not separated by an\n-    /// underscore.\n-    ///\n-    /// **Why is this bad?** It is much less readable.\n-    ///\n-    /// **Known problems:** None.\n-    ///\n-    /// **Example:**\n-    /// ```rust\n-    /// // Bad\n-    /// let y = 123832i32;\n-    ///\n-    /// // Good\n-    /// let y = 123832_i32;\n-    /// ```\n-    pub UNSEPARATED_LITERAL_SUFFIX,\n-    pedantic,\n-    \"literals whose suffix is not separated by an underscore\"\n-}\n-\n-declare_clippy_lint! {\n-    /// **What it does:** Warns if an integral constant literal starts with `0`.\n-    ///\n-    /// **Why is this bad?** In some languages (including the infamous C language\n-    /// and most of its\n-    /// family), this marks an octal constant. In Rust however, this is a decimal\n-    /// constant. This could\n-    /// be confusing for both the writer and a reader of the constant.\n-    ///\n-    /// **Known problems:** None.\n-    ///\n-    /// **Example:**\n-    ///\n-    /// In Rust:\n-    /// ```rust\n-    /// fn main() {\n-    ///     let a = 0123;\n-    ///     println!(\"{}\", a);\n-    /// }\n-    /// ```\n-    ///\n-    /// prints `123`, while in C:\n-    ///\n-    /// ```c\n-    /// #include <stdio.h>\n-    ///\n-    /// int main() {\n-    ///     int a = 0123;\n-    ///     printf(\"%d\\n\", a);\n-    /// }\n-    /// ```\n-    ///\n-    /// prints `83` (as `83 == 0o123` while `123 == 0o173`).\n-    pub ZERO_PREFIXED_LITERAL,\n-    complexity,\n-    \"integer literals starting with `0`\"\n-}\n-\n-declare_clippy_lint! {\n-    /// **What it does:** Warns if a generic shadows a built-in type.\n-    ///\n-    /// **Why is this bad?** This gives surprising type errors.\n-    ///\n-    /// **Known problems:** None.\n-    ///\n-    /// **Example:**\n-    ///\n-    /// ```ignore\n-    /// impl<u32> Foo<u32> {\n-    ///     fn impl_func(&self) -> u32 {\n-    ///         42\n-    ///     }\n-    /// }\n-    /// ```\n-    pub BUILTIN_TYPE_SHADOW,\n-    style,\n-    \"shadowing a builtin type\"\n-}\n-\n-declare_clippy_lint! {\n-    /// **What it does:** Checks for patterns in the form `name @ _`.\n-    ///\n-    /// **Why is this bad?** It's almost always more readable to just use direct\n-    /// bindings.\n-    ///\n-    /// **Known problems:** None.\n-    ///\n-    /// **Example:**\n-    /// ```rust\n-    /// # let v = Some(\"abc\");\n-    ///\n-    /// // Bad\n-    /// match v {\n-    ///     Some(x) => (),\n-    ///     y @ _ => (),\n-    /// }\n-    ///\n-    /// // Good\n-    /// match v {\n-    ///     Some(x) => (),\n-    ///     y => (),\n-    /// }\n-    /// ```\n-    pub REDUNDANT_PATTERN,\n-    style,\n-    \"using `name @ _` in a pattern\"\n-}\n-\n-declare_clippy_lint! {\n-    /// **What it does:** Checks for tuple patterns with a wildcard\n-    /// pattern (`_`) is next to a rest pattern (`..`).\n-    ///\n-    /// _NOTE_: While `_, ..` means there is at least one element left, `..`\n-    /// means there are 0 or more elements left. This can make a difference\n-    /// when refactoring, but shouldn't result in errors in the refactored code,\n-    /// since the wildcard pattern isn't used anyway.\n-    /// **Why is this bad?** The wildcard pattern is unneeded as the rest pattern\n-    /// can match that element as well.\n-    ///\n-    /// **Known problems:** None.\n-    ///\n-    /// **Example:**\n-    /// ```rust\n-    /// # struct TupleStruct(u32, u32, u32);\n-    /// # let t = TupleStruct(1, 2, 3);\n-    /// // Bad\n-    /// match t {\n-    ///     TupleStruct(0, .., _) => (),\n-    ///     _ => (),\n-    /// }\n-    ///\n-    /// // Good\n-    /// match t {\n-    ///     TupleStruct(0, ..) => (),\n-    ///     _ => (),\n-    /// }\n-    /// ```\n-    pub UNNEEDED_WILDCARD_PATTERN,\n-    complexity,\n-    \"tuple patterns with a wildcard pattern (`_`) is next to a rest pattern (`..`)\"\n-}\n-\n-declare_lint_pass!(MiscEarlyLints => [\n-    UNNEEDED_FIELD_PATTERN,\n-    DUPLICATE_UNDERSCORE_ARGUMENT,\n-    DOUBLE_NEG,\n-    MIXED_CASE_HEX_LITERALS,\n-    UNSEPARATED_LITERAL_SUFFIX,\n-    ZERO_PREFIXED_LITERAL,\n-    BUILTIN_TYPE_SHADOW,\n-    REDUNDANT_PATTERN,\n-    UNNEEDED_WILDCARD_PATTERN,\n-]);\n-\n-impl EarlyLintPass for MiscEarlyLints {\n-    fn check_generics(&mut self, cx: &EarlyContext<'_>, gen: &Generics) {\n-        for param in &gen.params {\n-            if let GenericParamKind::Type { .. } = param.kind {\n-                if let Some(prim_ty) = PrimTy::from_name(param.ident.name) {\n-                    span_lint(\n-                        cx,\n-                        BUILTIN_TYPE_SHADOW,\n-                        param.ident.span,\n-                        &format!(\"this generic shadows the built-in type `{}`\", prim_ty.name()),\n-                    );\n-                }\n-            }\n-        }\n-    }\n-\n-    fn check_pat(&mut self, cx: &EarlyContext<'_>, pat: &Pat) {\n-        if let PatKind::Struct(ref npat, ref pfields, _) = pat.kind {\n-            let mut wilds = 0;\n-            let type_name = npat\n-                .segments\n-                .last()\n-                .expect(\"A path must have at least one segment\")\n-                .ident\n-                .name;\n-\n-            for field in pfields {\n-                if let PatKind::Wild = field.pat.kind {\n-                    wilds += 1;\n-                }\n-            }\n-            if !pfields.is_empty() && wilds == pfields.len() {\n-                span_lint_and_help(\n-                    cx,\n-                    UNNEEDED_FIELD_PATTERN,\n-                    pat.span,\n-                    \"all the struct fields are matched to a wildcard pattern, consider using `..`\",\n-                    None,\n-                    &format!(\"try with `{} {{ .. }}` instead\", type_name),\n-                );\n-                return;\n-            }\n-            if wilds > 0 {\n-                for field in pfields {\n-                    if let PatKind::Wild = field.pat.kind {\n-                        wilds -= 1;\n-                        if wilds > 0 {\n-                            span_lint(\n-                                cx,\n-                                UNNEEDED_FIELD_PATTERN,\n-                                field.span,\n-                                \"you matched a field with a wildcard pattern, consider using `..` instead\",\n-                            );\n-                        } else {\n-                            let mut normal = vec![];\n-\n-                            for field in pfields {\n-                                match field.pat.kind {\n-                                    PatKind::Wild => {},\n-                                    _ => {\n-                                        if let Ok(n) = cx.sess().source_map().span_to_snippet(field.span) {\n-                                            normal.push(n);\n-                                        }\n-                                    },\n-                                }\n-                            }\n-\n-                            span_lint_and_help(\n-                                cx,\n-                                UNNEEDED_FIELD_PATTERN,\n-                                field.span,\n-                                \"you matched a field with a wildcard pattern, consider using `..` \\\n-                                 instead\",\n-                                None,\n-                                &format!(\"try with `{} {{ {}, .. }}`\", type_name, normal[..].join(\", \")),\n-                            );\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-\n-        if let PatKind::Ident(left, ident, Some(ref right)) = pat.kind {\n-            let left_binding = match left {\n-                BindingMode::ByRef(Mutability::Mut) => \"ref mut \",\n-                BindingMode::ByRef(Mutability::Not) => \"ref \",\n-                BindingMode::ByValue(..) => \"\",\n-            };\n-\n-            if let PatKind::Wild = right.kind {\n-                span_lint_and_sugg(\n-                    cx,\n-                    REDUNDANT_PATTERN,\n-                    pat.span,\n-                    &format!(\n-                        \"the `{} @ _` pattern can be written as just `{}`\",\n-                        ident.name, ident.name,\n-                    ),\n-                    \"try\",\n-                    format!(\"{}{}\", left_binding, ident.name),\n-                    Applicability::MachineApplicable,\n-                );\n-            }\n-        }\n-\n-        check_unneeded_wildcard_pattern(cx, pat);\n-    }\n-\n-    fn check_fn(&mut self, cx: &EarlyContext<'_>, fn_kind: FnKind<'_>, _: Span, _: NodeId) {\n-        let mut registered_names: FxHashMap<String, Span> = FxHashMap::default();\n-\n-        for arg in &fn_kind.decl().inputs {\n-            if let PatKind::Ident(_, ident, None) = arg.pat.kind {\n-                let arg_name = ident.to_string();\n-\n-                if let Some(arg_name) = arg_name.strip_prefix('_') {\n-                    if let Some(correspondence) = registered_names.get(arg_name) {\n-                        span_lint(\n-                            cx,\n-                            DUPLICATE_UNDERSCORE_ARGUMENT,\n-                            *correspondence,\n-                            &format!(\n-                                \"`{}` already exists, having another argument having almost the same \\\n-                                 name makes code comprehension and documentation more difficult\",\n-                                arg_name\n-                            ),\n-                        );\n-                    }\n-                } else {\n-                    registered_names.insert(arg_name, arg.pat.span);\n-                }\n-            }\n-        }\n-    }\n-\n-    fn check_expr(&mut self, cx: &EarlyContext<'_>, expr: &Expr) {\n-        if in_external_macro(cx.sess(), expr.span) {\n-            return;\n-        }\n-        match expr.kind {\n-            ExprKind::Unary(UnOp::Neg, ref inner) => {\n-                if let ExprKind::Unary(UnOp::Neg, _) = inner.kind {\n-                    span_lint(\n-                        cx,\n-                        DOUBLE_NEG,\n-                        expr.span,\n-                        \"`--x` could be misinterpreted as pre-decrement by C programmers, is usually a no-op\",\n-                    );\n-                }\n-            },\n-            ExprKind::Lit(ref lit) => Self::check_lit(cx, lit),\n-            _ => (),\n-        }\n-    }\n-}\n-\n-impl MiscEarlyLints {\n-    fn check_lit(cx: &EarlyContext<'_>, lit: &Lit) {\n-        // We test if first character in snippet is a number, because the snippet could be an expansion\n-        // from a built-in macro like `line!()` or a proc-macro like `#[wasm_bindgen]`.\n-        // Note that this check also covers special case that `line!()` is eagerly expanded by compiler.\n-        // See <https://github.com/rust-lang/rust-clippy/issues/4507> for a regression.\n-        // FIXME: Find a better way to detect those cases.\n-        let lit_snip = match snippet_opt(cx, lit.span) {\n-            Some(snip) if snip.chars().next().map_or(false, |c| c.is_digit(10)) => snip,\n-            _ => return,\n-        };\n-\n-        if let LitKind::Int(value, lit_int_type) = lit.kind {\n-            let suffix = match lit_int_type {\n-                LitIntType::Signed(ty) => ty.name_str(),\n-                LitIntType::Unsigned(ty) => ty.name_str(),\n-                LitIntType::Unsuffixed => \"\",\n-            };\n-\n-            let maybe_last_sep_idx = if let Some(val) = lit_snip.len().checked_sub(suffix.len() + 1) {\n-                val\n-            } else {\n-                return; // It's useless so shouldn't lint.\n-            };\n-            // Do not lint when literal is unsuffixed.\n-            if !suffix.is_empty() && lit_snip.as_bytes()[maybe_last_sep_idx] != b'_' {\n-                span_lint_and_sugg(\n-                    cx,\n-                    UNSEPARATED_LITERAL_SUFFIX,\n-                    lit.span,\n-                    \"integer type suffix should be separated by an underscore\",\n-                    \"add an underscore\",\n-                    format!(\"{}_{}\", &lit_snip[..=maybe_last_sep_idx], suffix),\n-                    Applicability::MachineApplicable,\n-                );\n-            }\n-\n-            if lit_snip.starts_with(\"0x\") {\n-                if maybe_last_sep_idx <= 2 {\n-                    // It's meaningless or causes range error.\n-                    return;\n-                }\n-                let mut seen = (false, false);\n-                for ch in lit_snip.as_bytes()[2..=maybe_last_sep_idx].iter() {\n-                    match ch {\n-                        b'a'..=b'f' => seen.0 = true,\n-                        b'A'..=b'F' => seen.1 = true,\n-                        _ => {},\n-                    }\n-                    if seen.0 && seen.1 {\n-                        span_lint(\n-                            cx,\n-                            MIXED_CASE_HEX_LITERALS,\n-                            lit.span,\n-                            \"inconsistent casing in hexadecimal literal\",\n-                        );\n-                        break;\n-                    }\n-                }\n-            } else if lit_snip.starts_with(\"0b\") || lit_snip.starts_with(\"0o\") {\n-                /* nothing to do */\n-            } else if value != 0 && lit_snip.starts_with('0') {\n-                span_lint_and_then(\n-                    cx,\n-                    ZERO_PREFIXED_LITERAL,\n-                    lit.span,\n-                    \"this is a decimal constant\",\n-                    |diag| {\n-                        diag.span_suggestion(\n-                            lit.span,\n-                            \"if you mean to use a decimal constant, remove the `0` to avoid confusion\",\n-                            lit_snip.trim_start_matches(|c| c == '_' || c == '0').to_string(),\n-                            Applicability::MaybeIncorrect,\n-                        );\n-                        diag.span_suggestion(\n-                            lit.span,\n-                            \"if you mean to use an octal constant, use `0o`\",\n-                            format!(\"0o{}\", lit_snip.trim_start_matches(|c| c == '_' || c == '0')),\n-                            Applicability::MaybeIncorrect,\n-                        );\n-                    },\n-                );\n-            }\n-        } else if let LitKind::Float(_, LitFloatType::Suffixed(float_ty)) = lit.kind {\n-            let suffix = float_ty.name_str();\n-            let maybe_last_sep_idx = if let Some(val) = lit_snip.len().checked_sub(suffix.len() + 1) {\n-                val\n-            } else {\n-                return; // It's useless so shouldn't lint.\n-            };\n-            if lit_snip.as_bytes()[maybe_last_sep_idx] != b'_' {\n-                span_lint_and_sugg(\n-                    cx,\n-                    UNSEPARATED_LITERAL_SUFFIX,\n-                    lit.span,\n-                    \"float type suffix should be separated by an underscore\",\n-                    \"add an underscore\",\n-                    format!(\"{}_{}\", &lit_snip[..=maybe_last_sep_idx], suffix),\n-                    Applicability::MachineApplicable,\n-                );\n-            }\n-        }\n-    }\n-}\n-\n-fn check_unneeded_wildcard_pattern(cx: &EarlyContext<'_>, pat: &Pat) {\n-    if let PatKind::TupleStruct(_, ref patterns) | PatKind::Tuple(ref patterns) = pat.kind {\n-        fn span_lint(cx: &EarlyContext<'_>, span: Span, only_one: bool) {\n-            span_lint_and_sugg(\n-                cx,\n-                UNNEEDED_WILDCARD_PATTERN,\n-                span,\n-                if only_one {\n-                    \"this pattern is unneeded as the `..` pattern can match that element\"\n-                } else {\n-                    \"these patterns are unneeded as the `..` pattern can match those elements\"\n-                },\n-                if only_one { \"remove it\" } else { \"remove them\" },\n-                \"\".to_string(),\n-                Applicability::MachineApplicable,\n-            );\n-        }\n-\n-        if let Some(rest_index) = patterns.iter().position(|pat| pat.is_rest()) {\n-            if let Some((left_index, left_pat)) = patterns[..rest_index]\n-                .iter()\n-                .rev()\n-                .take_while(|pat| matches!(pat.kind, PatKind::Wild))\n-                .enumerate()\n-                .last()\n-            {\n-                span_lint(cx, left_pat.span.until(patterns[rest_index].span), left_index == 0);\n-            }\n-\n-            if let Some((right_index, right_pat)) = patterns[rest_index + 1..]\n-                .iter()\n-                .take_while(|pat| matches!(pat.kind, PatKind::Wild))\n-                .enumerate()\n-                .last()\n-            {\n-                span_lint(\n-                    cx,\n-                    patterns[rest_index].span.shrink_to_hi().to(right_pat.span),\n-                    right_index == 0,\n-                );\n-            }\n-        }\n-    }\n-}"}, {"sha": "9f6b0bdc7a45a83335b51dbce36113e537ec7f80", "filename": "clippy_lints/src/misc_early/builtin_type_shadow.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/7191675ab15950ed6a1bad5047f6bbc5faa5b319/clippy_lints%2Fsrc%2Fmisc_early%2Fbuiltin_type_shadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7191675ab15950ed6a1bad5047f6bbc5faa5b319/clippy_lints%2Fsrc%2Fmisc_early%2Fbuiltin_type_shadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc_early%2Fbuiltin_type_shadow.rs?ref=7191675ab15950ed6a1bad5047f6bbc5faa5b319", "patch": "@@ -0,0 +1,19 @@\n+use clippy_utils::diagnostics::span_lint;\n+use rustc_ast::ast::{GenericParam, GenericParamKind};\n+use rustc_hir::PrimTy;\n+use rustc_lint::EarlyContext;\n+\n+use super::BUILTIN_TYPE_SHADOW;\n+\n+pub(super) fn check(cx: &EarlyContext<'_>, param: &GenericParam) {\n+    if let GenericParamKind::Type { .. } = param.kind {\n+        if let Some(prim_ty) = PrimTy::from_name(param.ident.name) {\n+            span_lint(\n+                cx,\n+                BUILTIN_TYPE_SHADOW,\n+                param.ident.span,\n+                &format!(\"this generic shadows the built-in type `{}`\", prim_ty.name()),\n+            );\n+        }\n+    }\n+}"}, {"sha": "6f65778e1193cfc08d011e0eec606f08e683bf6a", "filename": "clippy_lints/src/misc_early/double_neg.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/7191675ab15950ed6a1bad5047f6bbc5faa5b319/clippy_lints%2Fsrc%2Fmisc_early%2Fdouble_neg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7191675ab15950ed6a1bad5047f6bbc5faa5b319/clippy_lints%2Fsrc%2Fmisc_early%2Fdouble_neg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc_early%2Fdouble_neg.rs?ref=7191675ab15950ed6a1bad5047f6bbc5faa5b319", "patch": "@@ -0,0 +1,23 @@\n+use super::MiscEarlyLints;\n+use clippy_utils::diagnostics::span_lint;\n+use rustc_ast::ast::{Expr, ExprKind, UnOp};\n+use rustc_lint::EarlyContext;\n+\n+use super::DOUBLE_NEG;\n+\n+pub(super) fn check(cx: &EarlyContext<'_>, expr: &Expr) {\n+    match expr.kind {\n+        ExprKind::Unary(UnOp::Neg, ref inner) => {\n+            if let ExprKind::Unary(UnOp::Neg, _) = inner.kind {\n+                span_lint(\n+                    cx,\n+                    DOUBLE_NEG,\n+                    expr.span,\n+                    \"`--x` could be misinterpreted as pre-decrement by C programmers, is usually a no-op\",\n+                );\n+            }\n+        },\n+        ExprKind::Lit(ref lit) => MiscEarlyLints::check_lit(cx, lit),\n+        _ => (),\n+    }\n+}"}, {"sha": "80e24213100787f572d6e237b1d86f223ed6034a", "filename": "clippy_lints/src/misc_early/mixed_case_hex_literals.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/7191675ab15950ed6a1bad5047f6bbc5faa5b319/clippy_lints%2Fsrc%2Fmisc_early%2Fmixed_case_hex_literals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7191675ab15950ed6a1bad5047f6bbc5faa5b319/clippy_lints%2Fsrc%2Fmisc_early%2Fmixed_case_hex_literals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc_early%2Fmixed_case_hex_literals.rs?ref=7191675ab15950ed6a1bad5047f6bbc5faa5b319", "patch": "@@ -0,0 +1,34 @@\n+use clippy_utils::diagnostics::span_lint;\n+use rustc_ast::ast::Lit;\n+use rustc_lint::EarlyContext;\n+\n+use super::MIXED_CASE_HEX_LITERALS;\n+\n+pub(super) fn check(cx: &EarlyContext<'_>, lit: &Lit, suffix: &str, lit_snip: &str) {\n+    let maybe_last_sep_idx = if let Some(val) = lit_snip.len().checked_sub(suffix.len() + 1) {\n+        val\n+    } else {\n+        return; // It's useless so shouldn't lint.\n+    };\n+    if maybe_last_sep_idx <= 2 {\n+        // It's meaningless or causes range error.\n+        return;\n+    }\n+    let mut seen = (false, false);\n+    for ch in lit_snip.as_bytes()[2..=maybe_last_sep_idx].iter() {\n+        match ch {\n+            b'a'..=b'f' => seen.0 = true,\n+            b'A'..=b'F' => seen.1 = true,\n+            _ => {},\n+        }\n+        if seen.0 && seen.1 {\n+            span_lint(\n+                cx,\n+                MIXED_CASE_HEX_LITERALS,\n+                lit.span,\n+                \"inconsistent casing in hexadecimal literal\",\n+            );\n+            break;\n+        }\n+    }\n+}"}, {"sha": "dd38316fa25b0cea0f8334e76a2a8ae20d1351a1", "filename": "clippy_lints/src/misc_early/mod.rs", "status": "added", "additions": 348, "deletions": 0, "changes": 348, "blob_url": "https://github.com/rust-lang/rust/blob/7191675ab15950ed6a1bad5047f6bbc5faa5b319/clippy_lints%2Fsrc%2Fmisc_early%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7191675ab15950ed6a1bad5047f6bbc5faa5b319/clippy_lints%2Fsrc%2Fmisc_early%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc_early%2Fmod.rs?ref=7191675ab15950ed6a1bad5047f6bbc5faa5b319", "patch": "@@ -0,0 +1,348 @@\n+mod builtin_type_shadow;\n+mod double_neg;\n+mod mixed_case_hex_literals;\n+mod redundant_pattern;\n+mod unneeded_field_pattern;\n+mod unneeded_wildcard_pattern;\n+mod unseparated_literal_suffix;\n+mod zero_prefixed_literal;\n+\n+use clippy_utils::diagnostics::span_lint;\n+use clippy_utils::source::snippet_opt;\n+use rustc_ast::ast::{Expr, Generics, Lit, LitFloatType, LitIntType, LitKind, NodeId, Pat, PatKind};\n+use rustc_ast::visit::FnKind;\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_lint::{EarlyContext, EarlyLintPass, LintContext};\n+use rustc_middle::lint::in_external_macro;\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::source_map::Span;\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for structure field patterns bound to wildcards.\n+    ///\n+    /// **Why is this bad?** Using `..` instead is shorter and leaves the focus on\n+    /// the fields that are actually bound.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// # struct Foo {\n+    /// #     a: i32,\n+    /// #     b: i32,\n+    /// #     c: i32,\n+    /// # }\n+    /// let f = Foo { a: 0, b: 0, c: 0 };\n+    ///\n+    /// // Bad\n+    /// match f {\n+    ///     Foo { a: _, b: 0, .. } => {},\n+    ///     Foo { a: _, b: _, c: _ } => {},\n+    /// }\n+    ///\n+    /// // Good\n+    /// match f {\n+    ///     Foo { b: 0, .. } => {},\n+    ///     Foo { .. } => {},\n+    /// }\n+    /// ```\n+    pub UNNEEDED_FIELD_PATTERN,\n+    restriction,\n+    \"struct fields bound to a wildcard instead of using `..`\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for function arguments having the similar names\n+    /// differing by an underscore.\n+    ///\n+    /// **Why is this bad?** It affects code readability.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// // Bad\n+    /// fn foo(a: i32, _a: i32) {}\n+    ///\n+    /// // Good\n+    /// fn bar(a: i32, _b: i32) {}\n+    /// ```\n+    pub DUPLICATE_UNDERSCORE_ARGUMENT,\n+    style,\n+    \"function arguments having names which only differ by an underscore\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Detects expressions of the form `--x`.\n+    ///\n+    /// **Why is this bad?** It can mislead C/C++ programmers to think `x` was\n+    /// decremented.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let mut x = 3;\n+    /// --x;\n+    /// ```\n+    pub DOUBLE_NEG,\n+    style,\n+    \"`--x`, which is a double negation of `x` and not a pre-decrement as in C/C++\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Warns on hexadecimal literals with mixed-case letter\n+    /// digits.\n+    ///\n+    /// **Why is this bad?** It looks confusing.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// // Bad\n+    /// let y = 0x1a9BAcD;\n+    ///\n+    /// // Good\n+    /// let y = 0x1A9BACD;\n+    /// ```\n+    pub MIXED_CASE_HEX_LITERALS,\n+    style,\n+    \"hex literals whose letter digits are not consistently upper- or lowercased\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Warns if literal suffixes are not separated by an\n+    /// underscore.\n+    ///\n+    /// **Why is this bad?** It is much less readable.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// // Bad\n+    /// let y = 123832i32;\n+    ///\n+    /// // Good\n+    /// let y = 123832_i32;\n+    /// ```\n+    pub UNSEPARATED_LITERAL_SUFFIX,\n+    pedantic,\n+    \"literals whose suffix is not separated by an underscore\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Warns if an integral constant literal starts with `0`.\n+    ///\n+    /// **Why is this bad?** In some languages (including the infamous C language\n+    /// and most of its\n+    /// family), this marks an octal constant. In Rust however, this is a decimal\n+    /// constant. This could\n+    /// be confusing for both the writer and a reader of the constant.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// In Rust:\n+    /// ```rust\n+    /// fn main() {\n+    ///     let a = 0123;\n+    ///     println!(\"{}\", a);\n+    /// }\n+    /// ```\n+    ///\n+    /// prints `123`, while in C:\n+    ///\n+    /// ```c\n+    /// #include <stdio.h>\n+    ///\n+    /// int main() {\n+    ///     int a = 0123;\n+    ///     printf(\"%d\\n\", a);\n+    /// }\n+    /// ```\n+    ///\n+    /// prints `83` (as `83 == 0o123` while `123 == 0o173`).\n+    pub ZERO_PREFIXED_LITERAL,\n+    complexity,\n+    \"integer literals starting with `0`\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Warns if a generic shadows a built-in type.\n+    ///\n+    /// **Why is this bad?** This gives surprising type errors.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```ignore\n+    /// impl<u32> Foo<u32> {\n+    ///     fn impl_func(&self) -> u32 {\n+    ///         42\n+    ///     }\n+    /// }\n+    /// ```\n+    pub BUILTIN_TYPE_SHADOW,\n+    style,\n+    \"shadowing a builtin type\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for patterns in the form `name @ _`.\n+    ///\n+    /// **Why is this bad?** It's almost always more readable to just use direct\n+    /// bindings.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// # let v = Some(\"abc\");\n+    ///\n+    /// // Bad\n+    /// match v {\n+    ///     Some(x) => (),\n+    ///     y @ _ => (),\n+    /// }\n+    ///\n+    /// // Good\n+    /// match v {\n+    ///     Some(x) => (),\n+    ///     y => (),\n+    /// }\n+    /// ```\n+    pub REDUNDANT_PATTERN,\n+    style,\n+    \"using `name @ _` in a pattern\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for tuple patterns with a wildcard\n+    /// pattern (`_`) is next to a rest pattern (`..`).\n+    ///\n+    /// _NOTE_: While `_, ..` means there is at least one element left, `..`\n+    /// means there are 0 or more elements left. This can make a difference\n+    /// when refactoring, but shouldn't result in errors in the refactored code,\n+    /// since the wildcard pattern isn't used anyway.\n+    /// **Why is this bad?** The wildcard pattern is unneeded as the rest pattern\n+    /// can match that element as well.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// # struct TupleStruct(u32, u32, u32);\n+    /// # let t = TupleStruct(1, 2, 3);\n+    /// // Bad\n+    /// match t {\n+    ///     TupleStruct(0, .., _) => (),\n+    ///     _ => (),\n+    /// }\n+    ///\n+    /// // Good\n+    /// match t {\n+    ///     TupleStruct(0, ..) => (),\n+    ///     _ => (),\n+    /// }\n+    /// ```\n+    pub UNNEEDED_WILDCARD_PATTERN,\n+    complexity,\n+    \"tuple patterns with a wildcard pattern (`_`) is next to a rest pattern (`..`)\"\n+}\n+\n+declare_lint_pass!(MiscEarlyLints => [\n+    UNNEEDED_FIELD_PATTERN,\n+    DUPLICATE_UNDERSCORE_ARGUMENT,\n+    DOUBLE_NEG,\n+    MIXED_CASE_HEX_LITERALS,\n+    UNSEPARATED_LITERAL_SUFFIX,\n+    ZERO_PREFIXED_LITERAL,\n+    BUILTIN_TYPE_SHADOW,\n+    REDUNDANT_PATTERN,\n+    UNNEEDED_WILDCARD_PATTERN,\n+]);\n+\n+impl EarlyLintPass for MiscEarlyLints {\n+    fn check_generics(&mut self, cx: &EarlyContext<'_>, gen: &Generics) {\n+        for param in &gen.params {\n+            builtin_type_shadow::check(cx, param);\n+        }\n+    }\n+\n+    fn check_pat(&mut self, cx: &EarlyContext<'_>, pat: &Pat) {\n+        unneeded_field_pattern::check(cx, pat);\n+        redundant_pattern::check(cx, pat);\n+        unneeded_wildcard_pattern::check(cx, pat);\n+    }\n+\n+    fn check_fn(&mut self, cx: &EarlyContext<'_>, fn_kind: FnKind<'_>, _: Span, _: NodeId) {\n+        let mut registered_names: FxHashMap<String, Span> = FxHashMap::default();\n+\n+        for arg in &fn_kind.decl().inputs {\n+            if let PatKind::Ident(_, ident, None) = arg.pat.kind {\n+                let arg_name = ident.to_string();\n+\n+                if let Some(arg_name) = arg_name.strip_prefix('_') {\n+                    if let Some(correspondence) = registered_names.get(arg_name) {\n+                        span_lint(\n+                            cx,\n+                            DUPLICATE_UNDERSCORE_ARGUMENT,\n+                            *correspondence,\n+                            &format!(\n+                                \"`{}` already exists, having another argument having almost the same \\\n+                                 name makes code comprehension and documentation more difficult\",\n+                                arg_name\n+                            ),\n+                        );\n+                    }\n+                } else {\n+                    registered_names.insert(arg_name, arg.pat.span);\n+                }\n+            }\n+        }\n+    }\n+\n+    fn check_expr(&mut self, cx: &EarlyContext<'_>, expr: &Expr) {\n+        if in_external_macro(cx.sess(), expr.span) {\n+            return;\n+        }\n+        double_neg::check(cx, expr)\n+    }\n+}\n+\n+impl MiscEarlyLints {\n+    fn check_lit(cx: &EarlyContext<'_>, lit: &Lit) {\n+        // We test if first character in snippet is a number, because the snippet could be an expansion\n+        // from a built-in macro like `line!()` or a proc-macro like `#[wasm_bindgen]`.\n+        // Note that this check also covers special case that `line!()` is eagerly expanded by compiler.\n+        // See <https://github.com/rust-lang/rust-clippy/issues/4507> for a regression.\n+        // FIXME: Find a better way to detect those cases.\n+        let lit_snip = match snippet_opt(cx, lit.span) {\n+            Some(snip) if snip.chars().next().map_or(false, |c| c.is_digit(10)) => snip,\n+            _ => return,\n+        };\n+\n+        if let LitKind::Int(value, lit_int_type) = lit.kind {\n+            let suffix = match lit_int_type {\n+                LitIntType::Signed(ty) => ty.name_str(),\n+                LitIntType::Unsigned(ty) => ty.name_str(),\n+                LitIntType::Unsuffixed => \"\",\n+            };\n+            unseparated_literal_suffix::check(cx, lit, &lit_snip, suffix, \"integer\");\n+            if lit_snip.starts_with(\"0x\") {\n+                mixed_case_hex_literals::check(cx, lit, suffix, &lit_snip)\n+            } else if lit_snip.starts_with(\"0b\") || lit_snip.starts_with(\"0o\") {\n+                /* nothing to do */\n+            } else if value != 0 && lit_snip.starts_with('0') {\n+                zero_prefixed_literal::check(cx, lit, &lit_snip)\n+            }\n+        } else if let LitKind::Float(_, LitFloatType::Suffixed(float_ty)) = lit.kind {\n+            let suffix = float_ty.name_str();\n+            unseparated_literal_suffix::check(cx, lit, &lit_snip, suffix, \"float\")\n+        }\n+    }\n+}"}, {"sha": "525dbf7757c14c3c7e97cbffad764fca4d51a442", "filename": "clippy_lints/src/misc_early/redundant_pattern.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/7191675ab15950ed6a1bad5047f6bbc5faa5b319/clippy_lints%2Fsrc%2Fmisc_early%2Fredundant_pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7191675ab15950ed6a1bad5047f6bbc5faa5b319/clippy_lints%2Fsrc%2Fmisc_early%2Fredundant_pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc_early%2Fredundant_pattern.rs?ref=7191675ab15950ed6a1bad5047f6bbc5faa5b319", "patch": "@@ -0,0 +1,31 @@\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use rustc_ast::ast::{BindingMode, Mutability, Pat, PatKind};\n+use rustc_errors::Applicability;\n+use rustc_lint::EarlyContext;\n+\n+use super::REDUNDANT_PATTERN;\n+\n+pub(super) fn check(cx: &EarlyContext<'_>, pat: &Pat) {\n+    if let PatKind::Ident(left, ident, Some(ref right)) = pat.kind {\n+        let left_binding = match left {\n+            BindingMode::ByRef(Mutability::Mut) => \"ref mut \",\n+            BindingMode::ByRef(Mutability::Not) => \"ref \",\n+            BindingMode::ByValue(..) => \"\",\n+        };\n+\n+        if let PatKind::Wild = right.kind {\n+            span_lint_and_sugg(\n+                cx,\n+                REDUNDANT_PATTERN,\n+                pat.span,\n+                &format!(\n+                    \"the `{} @ _` pattern can be written as just `{}`\",\n+                    ident.name, ident.name,\n+                ),\n+                \"try\",\n+                format!(\"{}{}\", left_binding, ident.name),\n+                Applicability::MachineApplicable,\n+            );\n+        }\n+    }\n+}"}, {"sha": "329a0009a3e2cfc014aa00a1a92f8b37996926ed", "filename": "clippy_lints/src/misc_early/unneeded_field_pattern.rs", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/7191675ab15950ed6a1bad5047f6bbc5faa5b319/clippy_lints%2Fsrc%2Fmisc_early%2Funneeded_field_pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7191675ab15950ed6a1bad5047f6bbc5faa5b319/clippy_lints%2Fsrc%2Fmisc_early%2Funneeded_field_pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc_early%2Funneeded_field_pattern.rs?ref=7191675ab15950ed6a1bad5047f6bbc5faa5b319", "patch": "@@ -0,0 +1,72 @@\n+use clippy_utils::diagnostics::{span_lint, span_lint_and_help};\n+use rustc_ast::ast::{Pat, PatKind};\n+use rustc_lint::{EarlyContext, LintContext};\n+\n+use super::UNNEEDED_FIELD_PATTERN;\n+\n+pub(super) fn check(cx: &EarlyContext<'_>, pat: &Pat) {\n+    if let PatKind::Struct(ref npat, ref pfields, _) = pat.kind {\n+        let mut wilds = 0;\n+        let type_name = npat\n+            .segments\n+            .last()\n+            .expect(\"A path must have at least one segment\")\n+            .ident\n+            .name;\n+\n+        for field in pfields {\n+            if let PatKind::Wild = field.pat.kind {\n+                wilds += 1;\n+            }\n+        }\n+        if !pfields.is_empty() && wilds == pfields.len() {\n+            span_lint_and_help(\n+                cx,\n+                UNNEEDED_FIELD_PATTERN,\n+                pat.span,\n+                \"all the struct fields are matched to a wildcard pattern, consider using `..`\",\n+                None,\n+                &format!(\"try with `{} {{ .. }}` instead\", type_name),\n+            );\n+            return;\n+        }\n+        if wilds > 0 {\n+            for field in pfields {\n+                if let PatKind::Wild = field.pat.kind {\n+                    wilds -= 1;\n+                    if wilds > 0 {\n+                        span_lint(\n+                            cx,\n+                            UNNEEDED_FIELD_PATTERN,\n+                            field.span,\n+                            \"you matched a field with a wildcard pattern, consider using `..` instead\",\n+                        );\n+                    } else {\n+                        let mut normal = vec![];\n+\n+                        for field in pfields {\n+                            match field.pat.kind {\n+                                PatKind::Wild => {},\n+                                _ => {\n+                                    if let Ok(n) = cx.sess().source_map().span_to_snippet(field.span) {\n+                                        normal.push(n);\n+                                    }\n+                                },\n+                            }\n+                        }\n+\n+                        span_lint_and_help(\n+                            cx,\n+                            UNNEEDED_FIELD_PATTERN,\n+                            field.span,\n+                            \"you matched a field with a wildcard pattern, consider using `..` \\\n+                             instead\",\n+                            None,\n+                            &format!(\"try with `{} {{ {}, .. }}`\", type_name, normal[..].join(\", \")),\n+                        );\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}"}, {"sha": "4dd032d78f1d55f2651b43114036634c99e5bcf7", "filename": "clippy_lints/src/misc_early/unneeded_wildcard_pattern.rs", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/7191675ab15950ed6a1bad5047f6bbc5faa5b319/clippy_lints%2Fsrc%2Fmisc_early%2Funneeded_wildcard_pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7191675ab15950ed6a1bad5047f6bbc5faa5b319/clippy_lints%2Fsrc%2Fmisc_early%2Funneeded_wildcard_pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc_early%2Funneeded_wildcard_pattern.rs?ref=7191675ab15950ed6a1bad5047f6bbc5faa5b319", "patch": "@@ -0,0 +1,52 @@\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use rustc_ast::ast::{Pat, PatKind};\n+use rustc_errors::Applicability;\n+use rustc_lint::EarlyContext;\n+use rustc_span::source_map::Span;\n+\n+use super::UNNEEDED_WILDCARD_PATTERN;\n+\n+pub(super) fn check(cx: &EarlyContext<'_>, pat: &Pat) {\n+    if let PatKind::TupleStruct(_, ref patterns) | PatKind::Tuple(ref patterns) = pat.kind {\n+        if let Some(rest_index) = patterns.iter().position(|pat| pat.is_rest()) {\n+            if let Some((left_index, left_pat)) = patterns[..rest_index]\n+                .iter()\n+                .rev()\n+                .take_while(|pat| matches!(pat.kind, PatKind::Wild))\n+                .enumerate()\n+                .last()\n+            {\n+                span_lint(cx, left_pat.span.until(patterns[rest_index].span), left_index == 0);\n+            }\n+\n+            if let Some((right_index, right_pat)) = patterns[rest_index + 1..]\n+                .iter()\n+                .take_while(|pat| matches!(pat.kind, PatKind::Wild))\n+                .enumerate()\n+                .last()\n+            {\n+                span_lint(\n+                    cx,\n+                    patterns[rest_index].span.shrink_to_hi().to(right_pat.span),\n+                    right_index == 0,\n+                );\n+            }\n+        }\n+    }\n+}\n+\n+fn span_lint(cx: &EarlyContext<'_>, span: Span, only_one: bool) {\n+    span_lint_and_sugg(\n+        cx,\n+        UNNEEDED_WILDCARD_PATTERN,\n+        span,\n+        if only_one {\n+            \"this pattern is unneeded as the `..` pattern can match that element\"\n+        } else {\n+            \"these patterns are unneeded as the `..` pattern can match those elements\"\n+        },\n+        if only_one { \"remove it\" } else { \"remove them\" },\n+        \"\".to_string(),\n+        Applicability::MachineApplicable,\n+    );\n+}"}, {"sha": "2018aa6184a8db4568f751017d6e5514cbcda95f", "filename": "clippy_lints/src/misc_early/unseparated_literal_suffix.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/7191675ab15950ed6a1bad5047f6bbc5faa5b319/clippy_lints%2Fsrc%2Fmisc_early%2Funseparated_literal_suffix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7191675ab15950ed6a1bad5047f6bbc5faa5b319/clippy_lints%2Fsrc%2Fmisc_early%2Funseparated_literal_suffix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc_early%2Funseparated_literal_suffix.rs?ref=7191675ab15950ed6a1bad5047f6bbc5faa5b319", "patch": "@@ -0,0 +1,26 @@\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use rustc_ast::ast::Lit;\n+use rustc_errors::Applicability;\n+use rustc_lint::EarlyContext;\n+\n+use super::UNSEPARATED_LITERAL_SUFFIX;\n+\n+pub(super) fn check(cx: &EarlyContext<'_>, lit: &Lit, lit_snip: &str, suffix: &str, sugg_type: &str) {\n+    let maybe_last_sep_idx = if let Some(val) = lit_snip.len().checked_sub(suffix.len() + 1) {\n+        val\n+    } else {\n+        return; // It's useless so shouldn't lint.\n+    };\n+    // Do not lint when literal is unsuffixed.\n+    if !suffix.is_empty() && lit_snip.as_bytes()[maybe_last_sep_idx] != b'_' {\n+        span_lint_and_sugg(\n+            cx,\n+            UNSEPARATED_LITERAL_SUFFIX,\n+            lit.span,\n+            &format!(\"{} type suffix should be separated by an underscore\", sugg_type),\n+            \"add an underscore\",\n+            format!(\"{}_{}\", &lit_snip[..=maybe_last_sep_idx], suffix),\n+            Applicability::MachineApplicable,\n+        );\n+    }\n+}"}, {"sha": "4963bba82f2da169887da3f88a3a5c7641a64000", "filename": "clippy_lints/src/misc_early/zero_prefixed_literal.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/7191675ab15950ed6a1bad5047f6bbc5faa5b319/clippy_lints%2Fsrc%2Fmisc_early%2Fzero_prefixed_literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7191675ab15950ed6a1bad5047f6bbc5faa5b319/clippy_lints%2Fsrc%2Fmisc_early%2Fzero_prefixed_literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc_early%2Fzero_prefixed_literal.rs?ref=7191675ab15950ed6a1bad5047f6bbc5faa5b319", "patch": "@@ -0,0 +1,29 @@\n+use clippy_utils::diagnostics::span_lint_and_then;\n+use rustc_ast::ast::Lit;\n+use rustc_errors::Applicability;\n+use rustc_lint::EarlyContext;\n+\n+use super::ZERO_PREFIXED_LITERAL;\n+\n+pub(super) fn check(cx: &EarlyContext<'_>, lit: &Lit, lit_snip: &str) {\n+    span_lint_and_then(\n+        cx,\n+        ZERO_PREFIXED_LITERAL,\n+        lit.span,\n+        \"this is a decimal constant\",\n+        |diag| {\n+            diag.span_suggestion(\n+                lit.span,\n+                \"if you mean to use a decimal constant, remove the `0` to avoid confusion\",\n+                lit_snip.trim_start_matches(|c| c == '_' || c == '0').to_string(),\n+                Applicability::MaybeIncorrect,\n+            );\n+            diag.span_suggestion(\n+                lit.span,\n+                \"if you mean to use an octal constant, use `0o`\",\n+                format!(\"0o{}\", lit_snip.trim_start_matches(|c| c == '_' || c == '0')),\n+                Applicability::MaybeIncorrect,\n+            );\n+        },\n+    );\n+}"}, {"sha": "69b8b6a0e68c3af97530ff3316c953e96c2d4efc", "filename": "tests/ui/builtin_type_shadow.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7191675ab15950ed6a1bad5047f6bbc5faa5b319/tests%2Fui%2Fbuiltin_type_shadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7191675ab15950ed6a1bad5047f6bbc5faa5b319/tests%2Fui%2Fbuiltin_type_shadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fbuiltin_type_shadow.rs?ref=7191675ab15950ed6a1bad5047f6bbc5faa5b319", "previous_filename": "tests/ui/builtin-type-shadow.rs"}, {"sha": "47a8a1e623e8aa0592b2abb24c8f4e88373543c6", "filename": "tests/ui/builtin_type_shadow.stderr", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7191675ab15950ed6a1bad5047f6bbc5faa5b319/tests%2Fui%2Fbuiltin_type_shadow.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7191675ab15950ed6a1bad5047f6bbc5faa5b319/tests%2Fui%2Fbuiltin_type_shadow.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fbuiltin_type_shadow.stderr?ref=7191675ab15950ed6a1bad5047f6bbc5faa5b319", "patch": "@@ -1,13 +1,13 @@\n error: this generic shadows the built-in type `u32`\n-  --> $DIR/builtin-type-shadow.rs:4:8\n+  --> $DIR/builtin_type_shadow.rs:4:8\n    |\n LL | fn foo<u32>(a: u32) -> u32 {\n    |        ^^^\n    |\n    = note: `-D clippy::builtin-type-shadow` implied by `-D warnings`\n \n error[E0308]: mismatched types\n-  --> $DIR/builtin-type-shadow.rs:5:5\n+  --> $DIR/builtin_type_shadow.rs:5:5\n    |\n LL | fn foo<u32>(a: u32) -> u32 {\n    |        ---             --- expected `u32` because of return type", "previous_filename": "tests/ui/builtin-type-shadow.stderr"}]}