{"sha": "cd9f5ff2a1c50a5af94ad1dd1c976f631b9f19a6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNkOWY1ZmYyYTFjNTBhNWFmOTRhZDFkZDFjOTc2ZjYzMWI5ZjE5YTY=", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2020-02-13T20:29:03Z"}, "committer": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2020-02-13T20:31:25Z"}, "message": "Check `Copy` lifetimes bounds when copying from a projection", "tree": {"sha": "9a3a90a8fdcab7ed9ce8be849d479fa020645b8b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9a3a90a8fdcab7ed9ce8be849d479fa020645b8b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cd9f5ff2a1c50a5af94ad1dd1c976f631b9f19a6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cd9f5ff2a1c50a5af94ad1dd1c976f631b9f19a6", "html_url": "https://github.com/rust-lang/rust/commit/cd9f5ff2a1c50a5af94ad1dd1c976f631b9f19a6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cd9f5ff2a1c50a5af94ad1dd1c976f631b9f19a6/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d538b80ad77949e46989cd355cdec193b574f052", "url": "https://api.github.com/repos/rust-lang/rust/commits/d538b80ad77949e46989cd355cdec193b574f052", "html_url": "https://github.com/rust-lang/rust/commit/d538b80ad77949e46989cd355cdec193b574f052"}], "stats": {"total": 78, "additions": 51, "deletions": 27}, "files": [{"sha": "232e7e6b83d2bed5e62ee9be08af19f0185400da", "filename": "src/librustc_mir/borrow_check/type_check/mod.rs", "status": "modified", "additions": 25, "deletions": 27, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/cd9f5ff2a1c50a5af94ad1dd1c976f631b9f19a6/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd9f5ff2a1c50a5af94ad1dd1c976f631b9f19a6/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs?ref=cd9f5ff2a1c50a5af94ad1dd1c976f631b9f19a6", "patch": "@@ -466,33 +466,6 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n \n         let mut place_ty = PlaceTy::from_ty(self.body.local_decls[place.local].ty);\n \n-        if place.projection.is_empty() {\n-            if let PlaceContext::NonMutatingUse(NonMutatingUseContext::Copy) = context {\n-                let tcx = self.tcx();\n-                let trait_ref = ty::TraitRef {\n-                    def_id: tcx.lang_items().copy_trait().unwrap(),\n-                    substs: tcx.mk_substs_trait(place_ty.ty, &[]),\n-                };\n-\n-                // To have a `Copy` operand, the type `T` of the\n-                // value must be `Copy`. Note that we prove that `T: Copy`,\n-                // rather than using the `is_copy_modulo_regions`\n-                // test. This is important because\n-                // `is_copy_modulo_regions` ignores the resulting region\n-                // obligations and assumes they pass. This can result in\n-                // bounds from `Copy` impls being unsoundly ignored (e.g.,\n-                // #29149). Note that we decide to use `Copy` before knowing\n-                // whether the bounds fully apply: in effect, the rule is\n-                // that if a value of some type could implement `Copy`, then\n-                // it must.\n-                self.cx.prove_trait_ref(\n-                    trait_ref,\n-                    location.to_locations(),\n-                    ConstraintCategory::CopyBound,\n-                );\n-            }\n-        }\n-\n         for elem in place.projection.iter() {\n             if place_ty.variant_index.is_none() {\n                 if place_ty.ty.references_error() {\n@@ -503,6 +476,31 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n             place_ty = self.sanitize_projection(place_ty, elem, place, location)\n         }\n \n+        if let PlaceContext::NonMutatingUse(NonMutatingUseContext::Copy) = context {\n+            let tcx = self.tcx();\n+            let trait_ref = ty::TraitRef {\n+                def_id: tcx.lang_items().copy_trait().unwrap(),\n+                substs: tcx.mk_substs_trait(place_ty.ty, &[]),\n+            };\n+\n+            // To have a `Copy` operand, the type `T` of the\n+            // value must be `Copy`. Note that we prove that `T: Copy`,\n+            // rather than using the `is_copy_modulo_regions`\n+            // test. This is important because\n+            // `is_copy_modulo_regions` ignores the resulting region\n+            // obligations and assumes they pass. This can result in\n+            // bounds from `Copy` impls being unsoundly ignored (e.g.,\n+            // #29149). Note that we decide to use `Copy` before knowing\n+            // whether the bounds fully apply: in effect, the rule is\n+            // that if a value of some type could implement `Copy`, then\n+            // it must.\n+            self.cx.prove_trait_ref(\n+                trait_ref,\n+                location.to_locations(),\n+                ConstraintCategory::CopyBound,\n+            );\n+        }\n+\n         place_ty\n     }\n "}, {"sha": "96c8719468f27c3f49ed40ee7ded108f435a690d", "filename": "src/test/ui/nll/do-not-ignore-lifetime-bounds-in-copy-proj.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/cd9f5ff2a1c50a5af94ad1dd1c976f631b9f19a6/src%2Ftest%2Fui%2Fnll%2Fdo-not-ignore-lifetime-bounds-in-copy-proj.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd9f5ff2a1c50a5af94ad1dd1c976f631b9f19a6/src%2Ftest%2Fui%2Fnll%2Fdo-not-ignore-lifetime-bounds-in-copy-proj.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fdo-not-ignore-lifetime-bounds-in-copy-proj.rs?ref=cd9f5ff2a1c50a5af94ad1dd1c976f631b9f19a6", "patch": "@@ -0,0 +1,12 @@\n+// Test that the 'static bound from the Copy impl is respected. Regression test for #29149.\n+\n+#[derive(Clone)]\n+struct Foo<'a>(&'a u32);\n+impl Copy for Foo<'static> {}\n+\n+fn main() {\n+    let s = 2;\n+    let a = (Foo(&s),); //~ ERROR `s` does not live long enough [E0597]\n+    drop(a.0);\n+    drop(a.0);\n+}"}, {"sha": "65be3b37e0e3bed31239ba5bc20258d2b006527a", "filename": "src/test/ui/nll/do-not-ignore-lifetime-bounds-in-copy-proj.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cd9f5ff2a1c50a5af94ad1dd1c976f631b9f19a6/src%2Ftest%2Fui%2Fnll%2Fdo-not-ignore-lifetime-bounds-in-copy-proj.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cd9f5ff2a1c50a5af94ad1dd1c976f631b9f19a6/src%2Ftest%2Fui%2Fnll%2Fdo-not-ignore-lifetime-bounds-in-copy-proj.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fdo-not-ignore-lifetime-bounds-in-copy-proj.stderr?ref=cd9f5ff2a1c50a5af94ad1dd1c976f631b9f19a6", "patch": "@@ -0,0 +1,14 @@\n+error[E0597]: `s` does not live long enough\n+  --> $DIR/do-not-ignore-lifetime-bounds-in-copy-proj.rs:9:18\n+   |\n+LL |     let a = (Foo(&s),);\n+   |                  ^^ borrowed value does not live long enough\n+LL |     drop(a.0);\n+   |          --- copying this value requires that `s` is borrowed for `'static`\n+LL |     drop(a.0);\n+LL | }\n+   | - `s` dropped here while still borrowed\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0597`."}]}