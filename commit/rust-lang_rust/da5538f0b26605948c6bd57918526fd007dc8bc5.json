{"sha": "da5538f0b26605948c6bd57918526fd007dc8bc5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRhNTUzOGYwYjI2NjA1OTQ4YzZiZDU3OTE4NTI2ZmQwMDdkYzhiYzU=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2017-07-13T17:29:11Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2017-07-13T17:29:11Z"}, "message": "use closures to ensure proper bracketing of unaligned accesses", "tree": {"sha": "66d0069b9042f4d1218a92e687ee4f3ab2bf848d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/66d0069b9042f4d1218a92e687ee4f3ab2bf848d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/da5538f0b26605948c6bd57918526fd007dc8bc5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/da5538f0b26605948c6bd57918526fd007dc8bc5", "html_url": "https://github.com/rust-lang/rust/commit/da5538f0b26605948c6bd57918526fd007dc8bc5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/da5538f0b26605948c6bd57918526fd007dc8bc5/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d02e7f0da8d20e2e664b34566d3eaf8b904971dc", "url": "https://api.github.com/repos/rust-lang/rust/commits/d02e7f0da8d20e2e664b34566d3eaf8b904971dc", "html_url": "https://github.com/rust-lang/rust/commit/d02e7f0da8d20e2e664b34566d3eaf8b904971dc"}], "stats": {"total": 150, "additions": 78, "deletions": 72}, "files": [{"sha": "58fabf694d1ea410de78510d33793f2ea5942093", "filename": "src/eval_context.rs", "status": "modified", "additions": 17, "deletions": 25, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/da5538f0b26605948c6bd57918526fd007dc8bc5/src%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da5538f0b26605948c6bd57918526fd007dc8bc5/src%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval_context.rs?ref=da5538f0b26605948c6bd57918526fd007dc8bc5", "patch": "@@ -17,7 +17,7 @@ use syntax::abi::Abi;\n \n use error::{EvalError, EvalResult};\n use lvalue::{Global, GlobalId, Lvalue, LvalueExtra};\n-use memory::{Memory, MemoryPointer, TlsKey};\n+use memory::{Memory, MemoryPointer, TlsKey, HasMemory};\n use operator;\n use value::{PrimVal, PrimValKind, Value, Pointer};\n \n@@ -1051,10 +1051,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     pub(super) fn follow_by_ref_value(&mut self, value: Value, ty: Ty<'tcx>) -> EvalResult<'tcx, Value> {\n         match value {\n             Value::ByRef(ptr, aligned) => {\n-                self.memory.begin_unaligned_read(aligned);\n-                let r = self.read_value(ptr, ty);\n-                self.memory.end_unaligned_read();\n-                r\n+                self.read_maybe_aligned(aligned, |ectx| ectx.read_value(ptr, ty))\n             }\n             other => Ok(other),\n         }\n@@ -1127,10 +1124,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             Lvalue::Ptr { ptr, extra, aligned } => {\n                 assert_eq!(extra, LvalueExtra::None);\n-                self.memory.begin_unaligned_write(aligned);\n-                let r = self.write_value_to_ptr(src_val, ptr, dest_ty);\n-                self.memory.end_unaligned_write();\n-                r\n+                self.write_maybe_aligned(aligned,\n+                    |ectx| ectx.write_value_to_ptr(src_val, ptr, dest_ty))\n             }\n \n             Lvalue::Local { frame, local } => {\n@@ -1161,9 +1156,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             //\n             // Thus, it would be an error to replace the `ByRef` with a `ByVal`, unless we\n             // knew for certain that there were no outstanding pointers to this allocation.\n-            self.memory.begin_unaligned_write(aligned);\n-            self.write_value_to_ptr(src_val, dest_ptr, dest_ty)?;\n-            self.memory.end_unaligned_write();\n+            self.write_maybe_aligned(aligned,\n+                |ectx| ectx.write_value_to_ptr(src_val, dest_ptr, dest_ty))?;\n \n         } else if let Value::ByRef(src_ptr, aligned) = src_val {\n             // If the value is not `ByRef`, then we know there are no pointers to it\n@@ -1177,15 +1171,16 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             // It is a valid optimization to attempt reading a primitive value out of the\n             // source and write that into the destination without making an allocation, so\n             // we do so here.\n-            self.memory.begin_unaligned_read(aligned);\n-            if let Ok(Some(src_val)) = self.try_read_value(src_ptr, dest_ty) {\n-                write_dest(self, src_val)?;\n-            } else {\n-                let dest_ptr = self.alloc_ptr(dest_ty)?.into();\n-                self.copy(src_ptr, dest_ptr, dest_ty)?;\n-                write_dest(self, Value::by_ref(dest_ptr))?;\n-            }\n-            self.memory.end_unaligned_read();\n+            self.read_maybe_aligned(aligned, |ectx| {\n+                if let Ok(Some(src_val)) = ectx.try_read_value(src_ptr, dest_ty) {\n+                    write_dest(ectx, src_val)?;\n+                } else {\n+                    let dest_ptr = ectx.alloc_ptr(dest_ty)?.into();\n+                    ectx.copy(src_ptr, dest_ptr, dest_ty)?;\n+                    write_dest(ectx, Value::by_ref(dest_ptr))?;\n+                }\n+                Ok(())\n+            })?;\n \n         } else {\n             // Finally, we have the simple case where neither source nor destination are\n@@ -1203,10 +1198,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     ) -> EvalResult<'tcx> {\n         match value {\n             Value::ByRef(ptr, aligned) => {\n-                self.memory.begin_unaligned_read(aligned);\n-                let r = self.copy(ptr, dest, dest_ty);\n-                self.memory.end_unaligned_read();\n-                r\n+                self.read_maybe_aligned(aligned, |ectx| ectx.copy(ptr, dest, dest_ty))\n             },\n             Value::ByVal(primval) => {\n                 let size = self.type_size(dest_ty)?.expect(\"dest type must be sized\");"}, {"sha": "f4a1f050735aa7da3b1699ede807822b5b92bee0", "filename": "src/lvalue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da5538f0b26605948c6bd57918526fd007dc8bc5/src%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da5538f0b26605948c6bd57918526fd007dc8bc5/src%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flvalue.rs?ref=da5538f0b26605948c6bd57918526fd007dc8bc5", "patch": "@@ -4,7 +4,7 @@ use rustc::ty::{self, Ty};\n use rustc_data_structures::indexed_vec::Idx;\n \n use error::{EvalError, EvalResult};\n-use eval_context::{EvalContext};\n+use eval_context::EvalContext;\n use memory::MemoryPointer;\n use value::{PrimVal, Value, Pointer};\n "}, {"sha": "739e7f2a858c2fb5b5fb8f047407fb14a044d2f0", "filename": "src/memory.rs", "status": "modified", "additions": 44, "deletions": 27, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/da5538f0b26605948c6bd57918526fd007dc8bc5/src%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da5538f0b26605948c6bd57918526fd007dc8bc5/src%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmemory.rs?ref=da5538f0b26605948c6bd57918526fd007dc8bc5", "patch": "@@ -7,6 +7,7 @@ use rustc::ty::layout::{self, TargetDataLayout};\n \n use error::{EvalError, EvalResult};\n use value::{PrimVal, self, Pointer};\n+use eval_context::EvalContext;\n \n ////////////////////////////////////////////////////////////////////////////////\n // Allocations and pointers\n@@ -384,33 +385,6 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         }\n         return Ok(None);\n     }\n-\n-    #[inline]\n-    pub(crate) fn begin_unaligned_read(&mut self, aligned: bool) {\n-        assert!(self.reads_are_aligned, \"Unaligned reads must not be nested\");\n-        self.reads_are_aligned = aligned;\n-    }\n-\n-    #[inline]\n-    pub(crate) fn end_unaligned_read(&mut self) {\n-        self.reads_are_aligned = true;\n-    }\n-\n-    #[inline]\n-    pub(crate) fn begin_unaligned_write(&mut self, aligned: bool) {\n-        assert!(self.writes_are_aligned, \"Unaligned writes must not be nested\");\n-        self.writes_are_aligned = aligned;\n-    }\n-\n-    #[inline]\n-    pub(crate) fn end_unaligned_write(&mut self) {\n-        self.writes_are_aligned = true;\n-    }\n-\n-    #[inline]\n-    pub(crate) fn assert_all_aligned(&mut self) {\n-        assert!(self.reads_are_aligned && self.writes_are_aligned, \"Someone forgot to clear the 'unaligned' flag\");\n-    }\n }\n \n /// Allocation accessors\n@@ -1101,3 +1075,46 @@ fn bit_index(bits: u64) -> (usize, usize) {\n     assert_eq!(b as usize as u64, b);\n     (a as usize, b as usize)\n }\n+\n+////////////////////////////////////////////////////////////////////////////////\n+// Unaligned accesses\n+////////////////////////////////////////////////////////////////////////////////\n+\n+pub(crate) trait HasMemory<'a, 'tcx> {\n+    fn memory_mut(&mut self) -> &mut Memory<'a, 'tcx>;\n+\n+    // These are not supposed to be overriden.\n+    fn read_maybe_aligned<F, T>(&mut self, aligned: bool, f: F) -> EvalResult<'tcx, T>\n+        where F: FnOnce(&mut Self) -> EvalResult<'tcx, T>\n+    {\n+        assert!(self.memory_mut().reads_are_aligned, \"Unaligned reads must not be nested\");\n+        self.memory_mut().reads_are_aligned = aligned;\n+        let t = f(self);\n+        self.memory_mut().reads_are_aligned = true;\n+        t\n+    }\n+\n+    fn write_maybe_aligned<F, T>(&mut self, aligned: bool, f: F) -> EvalResult<'tcx, T>\n+        where F: FnOnce(&mut Self) -> EvalResult<'tcx, T>\n+    {\n+        assert!(self.memory_mut().writes_are_aligned, \"Unaligned writes must not be nested\");\n+        self.memory_mut().writes_are_aligned = aligned;\n+        let t = f(self);\n+        self.memory_mut().writes_are_aligned = true;\n+        t\n+    }\n+}\n+\n+impl<'a, 'tcx> HasMemory<'a, 'tcx> for Memory<'a, 'tcx> {\n+    #[inline]\n+    fn memory_mut(&mut self) -> &mut Memory<'a, 'tcx> {\n+        self\n+    }\n+}\n+\n+impl<'a, 'tcx> HasMemory<'a, 'tcx> for EvalContext<'a, 'tcx> {\n+    #[inline]\n+    fn memory_mut(&mut self) -> &mut Memory<'a, 'tcx> {\n+        &mut self.memory\n+    }\n+}"}, {"sha": "3aafda476363da4953b4aefb6ed77e0ac75aefdb", "filename": "src/step.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/da5538f0b26605948c6bd57918526fd007dc8bc5/src%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da5538f0b26605948c6bd57918526fd007dc8bc5/src%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstep.rs?ref=da5538f0b26605948c6bd57918526fd007dc8bc5", "patch": "@@ -28,7 +28,6 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n     /// Returns true as long as there are more things to do.\n     pub fn step(&mut self) -> EvalResult<'tcx, bool> {\n-        self.memory.assert_all_aligned();\n         self.inc_step_counter_and_check_limit(1)?;\n         if self.stack.is_empty() {\n             return Ok(false);"}, {"sha": "da45d7b410a6095eddd4975ecf9ab92c288f73b4", "filename": "src/terminator/intrinsic.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/da5538f0b26605948c6bd57918526fd007dc8bc5/src%2Fterminator%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da5538f0b26605948c6bd57918526fd007dc8bc5/src%2Fterminator%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fterminator%2Fintrinsic.rs?ref=da5538f0b26605948c6bd57918526fd007dc8bc5", "patch": "@@ -8,6 +8,7 @@ use error::{EvalError, EvalResult};\n use eval_context::EvalContext;\n use lvalue::{Lvalue, LvalueExtra};\n use value::{PrimVal, PrimValKind, Value, Pointer};\n+use memory::HasMemory;\n \n impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     pub(super) fn call_intrinsic(\n@@ -396,9 +397,9 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             \"transmute\" => {\n                 let src_ty = substs.type_at(0);\n                 let ptr = self.force_allocation(dest)?.to_ptr()?;\n-                self.memory.begin_unaligned_write(/*aligned*/false);\n-                self.write_value_to_ptr(arg_vals[0], ptr.into(), src_ty)?;\n-                self.memory.end_unaligned_write();\n+                self.write_maybe_aligned(/*aligned*/false, |ectx| {\n+                    ectx.write_value_to_ptr(arg_vals[0], ptr.into(), src_ty)\n+                })?;\n             }\n \n             \"unchecked_shl\" => {"}, {"sha": "f80a05805c2c3555ee3a07ac73a55377e473e121", "filename": "src/value.rs", "status": "modified", "additions": 12, "deletions": 15, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/da5538f0b26605948c6bd57918526fd007dc8bc5/src%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da5538f0b26605948c6bd57918526fd007dc8bc5/src%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvalue.rs?ref=da5538f0b26605948c6bd57918526fd007dc8bc5", "patch": "@@ -5,7 +5,7 @@ use std::mem::transmute;\n use rustc::ty::layout::TargetDataLayout;\n \n use error::{EvalError, EvalResult};\n-use memory::{Memory, MemoryPointer};\n+use memory::{Memory, MemoryPointer, HasMemory};\n \n pub(super) fn bytes_to_f32(bytes: u128) -> f32 {\n     unsafe { transmute::<u32, f32>(bytes as u32) }\n@@ -170,10 +170,7 @@ impl<'a, 'tcx: 'a> Value {\n         use self::Value::*;\n         match *self {\n             ByRef(ptr, aligned) => {\n-                mem.begin_unaligned_read(aligned);\n-                let r = mem.read_ptr(ptr.to_ptr()?);\n-                mem.end_unaligned_read();\n-                r\n+                mem.read_maybe_aligned(aligned, |mem| mem.read_ptr(ptr.to_ptr()?) )\n             },\n             ByVal(ptr) | ByValPair(ptr, _) => Ok(ptr.into()),\n         }\n@@ -186,11 +183,11 @@ impl<'a, 'tcx: 'a> Value {\n         use self::Value::*;\n         match *self {\n             ByRef(ref_ptr, aligned) => {\n-                mem.begin_unaligned_read(aligned);\n-                let ptr = mem.read_ptr(ref_ptr.to_ptr()?)?;\n-                let vtable = mem.read_ptr(ref_ptr.offset(mem.pointer_size(), mem.layout)?.to_ptr()?)?;\n-                mem.end_unaligned_read();\n-                Ok((ptr, vtable.to_ptr()?))\n+                mem.read_maybe_aligned(aligned, |mem| {\n+                    let ptr = mem.read_ptr(ref_ptr.to_ptr()?)?;\n+                    let vtable = mem.read_ptr(ref_ptr.offset(mem.pointer_size(), mem.layout)?.to_ptr()?)?;\n+                    Ok((ptr, vtable.to_ptr()?))\n+                })\n             }\n \n             ByValPair(ptr, vtable) => Ok((ptr.into(), vtable.to_ptr()?)),\n@@ -203,11 +200,11 @@ impl<'a, 'tcx: 'a> Value {\n         use self::Value::*;\n         match *self {\n             ByRef(ref_ptr, aligned) => {\n-                mem.begin_unaligned_read(aligned);\n-                let ptr = mem.read_ptr(ref_ptr.to_ptr()?)?;\n-                let len = mem.read_usize(ref_ptr.offset(mem.pointer_size(), mem.layout)?.to_ptr()?)?;\n-                mem.end_unaligned_read();\n-                Ok((ptr, len))\n+                mem.write_maybe_aligned(aligned, |mem| {\n+                    let ptr = mem.read_ptr(ref_ptr.to_ptr()?)?;\n+                    let len = mem.read_usize(ref_ptr.offset(mem.pointer_size(), mem.layout)?.to_ptr()?)?;\n+                    Ok((ptr, len))\n+                })\n             },\n             ByValPair(ptr, val) => {\n                 let len = val.to_u128()?;"}]}