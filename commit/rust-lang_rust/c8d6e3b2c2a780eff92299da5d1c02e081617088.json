{"sha": "c8d6e3b2c2a780eff92299da5d1c02e081617088", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM4ZDZlM2IyYzJhNzgwZWZmOTIyOTlkYTVkMWMwMmUwODE2MTcwODg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-11-18T19:11:43Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-11-18T19:11:43Z"}, "message": "auto merge of #18993 : nikomatsakis/rust/hrtb-5, r=pcwalton\n\nEnough said.\r\n\r\nFixes #18639.\r\n\r\nr? @pcwalton (or someone else?)\r\n\r\nThis is a [breaking-change]. In particular, several feature gates related to unboxed closures were consolidated into one (`overloaded_calls`, `unboxed_closure_sugar` => `unboxed_closures`). Otherwise, I think everything that worked before should still work. File a bug and cc @nikomatsakis if you find otherwise. :)", "tree": {"sha": "019ec1d05e20c8eba60f305b4c79cc942c1f85d3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/019ec1d05e20c8eba60f305b4c79cc942c1f85d3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c8d6e3b2c2a780eff92299da5d1c02e081617088", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c8d6e3b2c2a780eff92299da5d1c02e081617088", "html_url": "https://github.com/rust-lang/rust/commit/c8d6e3b2c2a780eff92299da5d1c02e081617088", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c8d6e3b2c2a780eff92299da5d1c02e081617088/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "09e2ad13d0aa01143bcb20dece3ff6c5a7e34ea3", "url": "https://api.github.com/repos/rust-lang/rust/commits/09e2ad13d0aa01143bcb20dece3ff6c5a7e34ea3", "html_url": "https://github.com/rust-lang/rust/commit/09e2ad13d0aa01143bcb20dece3ff6c5a7e34ea3"}, {"sha": "6866bf32343ce784a256cd0b9c7686a560fd8aa6", "url": "https://api.github.com/repos/rust-lang/rust/commits/6866bf32343ce784a256cd0b9c7686a560fd8aa6", "html_url": "https://github.com/rust-lang/rust/commit/6866bf32343ce784a256cd0b9c7686a560fd8aa6"}], "stats": {"total": 5958, "additions": 3954, "deletions": 2004}, "files": [{"sha": "62e0f5e4f1f48a4e5d4ad8a7fe3e61bc52f0249b", "filename": "src/doc/reference.md", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=c8d6e3b2c2a780eff92299da5d1c02e081617088", "patch": "@@ -2513,11 +2513,6 @@ The currently implemented features of the reference compiler are:\n                closure as `once` is unlikely to be supported going forward. So\n                they are hidden behind this feature until they are to be removed.\n \n-* `overloaded_calls` - Allow implementing the `Fn*` family of traits on user\n-                       types, allowing overloading the call operator (`()`).\n-                       This feature may still undergo changes before being\n-                       stabilized.\n-\n * `phase` - Usage of the `#[phase]` attribute allows loading compiler plugins\n             for custom lints or syntax extensions. The implementation is\n             considered unwholesome and in need of overhaul, and it is not clear\n@@ -2560,11 +2555,8 @@ The currently implemented features of the reference compiler are:\n * `trace_macros` - Allows use of the `trace_macros` macro, which is a nasty\n                    hack that will certainly be removed.\n \n-* `unboxed_closure_sugar` - Allows using `|Foo| -> Bar` as a trait bound\n-                            meaning one of the `Fn` traits. Still\n-                            experimental.\n-\n-* `unboxed_closures` - A work in progress feature with many known bugs.\n+* `unboxed_closures` - Rust's new closure design, which is currently a work in\n+                       progress feature with many known bugs.\n \n * `unsafe_destructor` - Allows use of the `#[unsafe_destructor]` attribute,\n                         which is considered wildly unsafe and will be"}, {"sha": "afbb18faa0b9f0dd170a55f6fa5b2a669fcde235", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=c8d6e3b2c2a780eff92299da5d1c02e081617088", "patch": "@@ -144,5 +144,6 @@ register_diagnostics!(\n     E0165,\n     E0166,\n     E0167,\n-    E0168\n+    E0168,\n+    E0169\n )"}, {"sha": "69be2e34915265666f65db69851240ddf570b53d", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=c8d6e3b2c2a780eff92299da5d1c02e081617088", "patch": "@@ -294,7 +294,7 @@ fn parse_region(st: &mut PState, conv: conv_did) -> ty::Region {\n     match next(st) {\n       'b' => {\n         assert_eq!(next(st), '[');\n-        let id = parse_uint(st) as ast::NodeId;\n+        let id = ty::DebruijnIndex::new(parse_uint(st));\n         assert_eq!(next(st), '|');\n         let br = parse_bound_region(st, |x,y| conv(x,y));\n         assert_eq!(next(st), ']');\n@@ -579,8 +579,6 @@ fn parse_bare_fn_ty(st: &mut PState, conv: conv_did) -> ty::BareFnTy {\n \n fn parse_sig(st: &mut PState, conv: conv_did) -> ty::FnSig {\n     assert_eq!(next(st), '[');\n-    let id = parse_uint(st) as ast::NodeId;\n-    assert_eq!(next(st), '|');\n     let mut inputs = Vec::new();\n     while peek(st) != ']' {\n         inputs.push(parse_ty(st, |x,y| conv(x,y)));\n@@ -598,8 +596,7 @@ fn parse_sig(st: &mut PState, conv: conv_did) -> ty::FnSig {\n         }\n         _ => ty::FnConverging(parse_ty(st, |x,y| conv(x,y)))\n     };\n-    ty::FnSig {binder_id: id,\n-               inputs: inputs,\n+    ty::FnSig {inputs: inputs,\n                output: output,\n                variadic: variadic}\n }"}, {"sha": "a53f5fa187df28b74fc7141533817eca439b5f24", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=c8d6e3b2c2a780eff92299da5d1c02e081617088", "patch": "@@ -130,7 +130,7 @@ fn enc_region_substs(w: &mut SeekableMemWriter, cx: &ctxt, substs: &subst::Regio\n pub fn enc_region(w: &mut SeekableMemWriter, cx: &ctxt, r: ty::Region) {\n     match r {\n         ty::ReLateBound(id, br) => {\n-            mywrite!(w, \"b[{}|\", id);\n+            mywrite!(w, \"b[{}|\", id.depth);\n             enc_bound_region(w, cx, br);\n             mywrite!(w, \"]\");\n         }\n@@ -331,7 +331,7 @@ pub fn enc_closure_ty(w: &mut SeekableMemWriter, cx: &ctxt, ft: &ty::ClosureTy)\n }\n \n fn enc_fn_sig(w: &mut SeekableMemWriter, cx: &ctxt, fsig: &ty::FnSig) {\n-    mywrite!(w, \"[{}|\", fsig.binder_id);\n+    mywrite!(w, \"[\");\n     for ty in fsig.inputs.iter() {\n         enc_ty(w, cx, *ty);\n     }"}, {"sha": "ff6965574be922cf528048edd135b9c4a64518cf", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=c8d6e3b2c2a780eff92299da5d1c02e081617088", "patch": "@@ -483,8 +483,8 @@ impl tr for def::Def {\n impl tr for ty::Region {\n     fn tr(&self, dcx: &DecodeContext) -> ty::Region {\n         match *self {\n-            ty::ReLateBound(id, br) => {\n-                ty::ReLateBound(dcx.tr_id(id), br.tr(dcx))\n+            ty::ReLateBound(debruijn, br) => {\n+                ty::ReLateBound(debruijn, br.tr(dcx))\n             }\n             ty::ReEarlyBound(id, space, index, ident) => {\n                 ty::ReEarlyBound(dcx.tr_id(id), space, index, ident)"}, {"sha": "d7925177c29db8ed608dbeaf3edd8e1fbda8ec28", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=c8d6e3b2c2a780eff92299da5d1c02e081617088", "patch": "@@ -65,8 +65,8 @@ pub type LoanDataFlow<'a, 'tcx> = DataFlowContext<'a, 'tcx, LoanDataFlowOperator\n \n impl<'a, 'tcx, 'v> Visitor<'v> for BorrowckCtxt<'a, 'tcx> {\n     fn visit_fn(&mut self, fk: FnKind<'v>, fd: &'v FnDecl,\n-                b: &'v Block, s: Span, n: NodeId) {\n-        borrowck_fn(self, fk, fd, b, s, n);\n+                b: &'v Block, s: Span, id: ast::NodeId) {\n+        borrowck_fn(self, fk, fd, b, s, id);\n     }\n \n     fn visit_item(&mut self, item: &ast::Item) {"}, {"sha": "c733084e9818a07a31fb615885ab70898a7021ae", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=c8d6e3b2c2a780eff92299da5d1c02e081617088", "patch": "@@ -139,8 +139,8 @@ impl<'a, 'tcx, 'v> Visitor<'v> for MatchCheckCtxt<'a, 'tcx> {\n         check_local(self, l);\n     }\n     fn visit_fn(&mut self, fk: FnKind<'v>, fd: &'v FnDecl,\n-                b: &'v Block, s: Span, _: NodeId) {\n-        check_fn(self, fk, fd, b, s);\n+                b: &'v Block, s: Span, n: NodeId) {\n+        check_fn(self, fk, fd, b, s, n);\n     }\n }\n \n@@ -920,7 +920,8 @@ fn check_fn(cx: &mut MatchCheckCtxt,\n             kind: FnKind,\n             decl: &FnDecl,\n             body: &Block,\n-            sp: Span) {\n+            sp: Span,\n+            _: NodeId) {\n     visit::walk_fn(cx, kind, decl, body, sp);\n     for input in decl.inputs.iter() {\n         is_refutable(cx, &*input.pat, |pat| {"}, {"sha": "8604c3967a92602370d83e3d5b624a633272a754", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=c8d6e3b2c2a780eff92299da5d1c02e081617088", "patch": "@@ -187,9 +187,8 @@ fn live_node_kind_to_string(lnk: LiveNodeKind, cx: &ty::ctxt) -> String {\n }\n \n impl<'a, 'tcx, 'v> Visitor<'v> for IrMaps<'a, 'tcx> {\n-    fn visit_fn(&mut self, fk: FnKind<'v>, fd: &'v FnDecl,\n-                b: &'v Block, s: Span, n: NodeId) {\n-        visit_fn(self, fk, fd, b, s, n);\n+    fn visit_fn(&mut self, fk: FnKind<'v>, fd: &'v FnDecl, b: &'v Block, s: Span, id: ast::NodeId) {\n+        visit_fn(self, fk, fd, b, s, id);\n     }\n     fn visit_local(&mut self, l: &ast::Local) { visit_local(self, l); }\n     fn visit_expr(&mut self, ex: &Expr) { visit_expr(self, ex); }\n@@ -374,9 +373,8 @@ fn visit_fn(ir: &mut IrMaps,\n             decl: &FnDecl,\n             body: &Block,\n             sp: Span,\n-            id: NodeId) {\n-    debug!(\"visit_fn: id={}\", id);\n-    let _i = ::util::common::indenter();\n+            id: ast::NodeId) {\n+    debug!(\"visit_fn\");\n \n     // swap in a new set of IR maps for this function body:\n     let mut fn_maps = IrMaps::new(ir.tcx);"}, {"sha": "baf53cc34ba94bded0b8fa304f13663e15ad8621", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=c8d6e3b2c2a780eff92299da5d1c02e081617088", "patch": "@@ -5038,10 +5038,10 @@ impl<'a> Resolver<'a> {\n                 visit::walk_ty(self, ty);\n             }\n \n-            TyPolyTraitRef(ref poly_trait_ref) => {\n-                self.resolve_poly_trait_reference(\n+            TyPolyTraitRef(ref bounds) => {\n+                self.resolve_type_parameter_bounds(\n                     ty.id,\n-                    &**poly_trait_ref,\n+                    bounds,\n                     TraitObject);\n                 visit::walk_ty(self, ty);\n             }"}, {"sha": "a1257caf47ffaa09b6602786ca123e9a265c77dc", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 100, "deletions": 68, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=c8d6e3b2c2a780eff92299da5d1c02e081617088", "patch": "@@ -21,11 +21,13 @@ pub use self::DefRegion::*;\n use self::ScopeChain::*;\n \n use session::Session;\n+use middle::def;\n+use middle::resolve::DefMap;\n use middle::subst;\n+use middle::ty;\n use std::fmt;\n use syntax::ast;\n use syntax::codemap::Span;\n-use syntax::owned_slice::OwnedSlice;\n use syntax::parse::token::special_idents;\n use syntax::parse::token;\n use syntax::print::pprust::{lifetime_to_string};\n@@ -39,8 +41,7 @@ pub enum DefRegion {\n     DefEarlyBoundRegion(/* space */ subst::ParamSpace,\n                         /* index */ uint,\n                         /* lifetime decl */ ast::NodeId),\n-    DefLateBoundRegion(/* binder_id */ ast::NodeId,\n-                       /* depth */ uint,\n+    DefLateBoundRegion(ty::DebruijnIndex,\n                        /* lifetime decl */ ast::NodeId),\n     DefFreeRegion(/* block scope */ ast::NodeId,\n                   /* lifetime decl */ ast::NodeId),\n@@ -53,16 +54,17 @@ pub type NamedRegionMap = NodeMap<DefRegion>;\n struct LifetimeContext<'a> {\n     sess: &'a Session,\n     named_region_map: &'a mut NamedRegionMap,\n-    scope: Scope<'a>\n+    scope: Scope<'a>,\n+    def_map: &'a DefMap,\n }\n \n enum ScopeChain<'a> {\n     /// EarlyScope(i, ['a, 'b, ...], s) extends s with early-bound\n     /// lifetimes, assigning indexes 'a => i, 'b => i+1, ... etc.\n     EarlyScope(subst::ParamSpace, &'a Vec<ast::LifetimeDef>, Scope<'a>),\n-    /// LateScope(binder_id, ['a, 'b, ...], s) extends s with late-bound\n+    /// LateScope(['a, 'b, ...], s) extends s with late-bound\n     /// lifetimes introduced by the declaration binder_id.\n-    LateScope(ast::NodeId, &'a Vec<ast::LifetimeDef>, Scope<'a>),\n+    LateScope(&'a Vec<ast::LifetimeDef>, Scope<'a>),\n     /// lifetimes introduced by items within a code block are scoped\n     /// to that block.\n     BlockScope(ast::NodeId, Scope<'a>),\n@@ -73,12 +75,13 @@ type Scope<'a> = &'a ScopeChain<'a>;\n \n static ROOT_SCOPE: ScopeChain<'static> = RootScope;\n \n-pub fn krate(sess: &Session, krate: &ast::Crate) -> NamedRegionMap {\n+pub fn krate(sess: &Session, krate: &ast::Crate, def_map: &DefMap) -> NamedRegionMap {\n     let mut named_region_map = NodeMap::new();\n     visit::walk_crate(&mut LifetimeContext {\n         sess: sess,\n         named_region_map: &mut named_region_map,\n-        scope: &ROOT_SCOPE\n+        scope: &ROOT_SCOPE,\n+        def_map: def_map,\n     }, krate);\n     sess.abort_if_errors();\n     named_region_map\n@@ -102,25 +105,31 @@ impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n             ast::ItemTy(_, ref generics) |\n             ast::ItemEnum(_, ref generics) |\n             ast::ItemStruct(_, ref generics) |\n-            ast::ItemTrait(ref generics, _, _, _) |\n-            ast::ItemImpl(ref generics, _, _, _) => {\n+            ast::ItemTrait(ref generics, _, _, _) => {\n                 // These kinds of items have only early bound lifetime parameters.\n                 let lifetimes = &generics.lifetimes;\n                 self.with(EarlyScope(subst::TypeSpace, lifetimes, &ROOT_SCOPE), |this| {\n                     this.check_lifetime_defs(lifetimes);\n                     visit::walk_item(this, item);\n                 });\n             }\n+            ast::ItemImpl(ref generics, _, _, _) => {\n+                // Impls have both early- and late-bound lifetimes.\n+                self.visit_early_late(subst::TypeSpace, generics, |this| {\n+                    this.check_lifetime_defs(&generics.lifetimes);\n+                    visit::walk_item(this, item);\n+                })\n+            }\n         }\n     }\n \n     fn visit_fn(&mut self, fk: visit::FnKind<'v>, fd: &'v ast::FnDecl,\n-                b: &'v ast::Block, s: Span, n: ast::NodeId) {\n+                b: &'v ast::Block, s: Span, _: ast::NodeId) {\n         match fk {\n             visit::FkItemFn(_, generics, _, _) |\n             visit::FkMethod(_, generics, _) => {\n                 self.visit_early_late(\n-                    subst::FnSpace, n, generics,\n+                    subst::FnSpace, generics,\n                     |this| visit::walk_fn(this, fk, fd, b, s))\n             }\n             visit::FkFnBlock(..) => {\n@@ -130,21 +139,58 @@ impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n     }\n \n     fn visit_ty(&mut self, ty: &ast::Ty) {\n-        let lifetimes = match ty.node {\n-            ast::TyClosure(ref c) | ast::TyProc(ref c) => &c.lifetimes,\n-            ast::TyBareFn(ref c) => &c.lifetimes,\n-            _ => return visit::walk_ty(self, ty)\n-        };\n-\n-        self.with(LateScope(ty.id, lifetimes, self.scope), |this| {\n-            this.check_lifetime_defs(lifetimes);\n-            visit::walk_ty(this, ty);\n-        });\n+        match ty.node {\n+            ast::TyClosure(ref c) | ast::TyProc(ref c) => {\n+                // Careful, the bounds on a closure/proc are *not* within its binder.\n+                visit::walk_ty_param_bounds_helper(self, &c.bounds);\n+                visit::walk_lifetime_decls_helper(self, &c.lifetimes);\n+                self.with(LateScope(&c.lifetimes, self.scope), |this| {\n+                    this.check_lifetime_defs(&c.lifetimes);\n+                    for argument in c.decl.inputs.iter() {\n+                        this.visit_ty(&*argument.ty)\n+                    }\n+                    visit::walk_fn_ret_ty(this, &c.decl.output);\n+                });\n+            }\n+            ast::TyBareFn(ref c) => {\n+                visit::walk_lifetime_decls_helper(self, &c.lifetimes);\n+                self.with(LateScope(&c.lifetimes, self.scope), |this| {\n+                    // a bare fn has no bounds, so everything\n+                    // contained within is scoped within its binder.\n+                    this.check_lifetime_defs(&c.lifetimes);\n+                    visit::walk_ty(this, ty);\n+                });\n+            }\n+            ast::TyPath(ref path, ref opt_bounds, id) => {\n+                // if this path references a trait, then this will resolve to\n+                // a trait ref, which introduces a binding scope.\n+                match self.def_map.borrow().get(&id) {\n+                    Some(&def::DefTrait(..)) => {\n+                        self.with(LateScope(&Vec::new(), self.scope), |this| {\n+                            this.visit_path(path, id);\n+                        });\n+\n+                        match *opt_bounds {\n+                            Some(ref bounds) => {\n+                                visit::walk_ty_param_bounds_helper(self, bounds);\n+                            }\n+                            None => { }\n+                        }\n+                    }\n+                    _ => {\n+                        visit::walk_ty(self, ty);\n+                    }\n+                }\n+            }\n+            _ => {\n+                visit::walk_ty(self, ty)\n+            }\n+        }\n     }\n \n     fn visit_ty_method(&mut self, m: &ast::TypeMethod) {\n         self.visit_early_late(\n-            subst::FnSpace, m.id, &m.generics,\n+            subst::FnSpace, &m.generics,\n             |this| visit::walk_ty_method(this, m))\n     }\n \n@@ -162,49 +208,22 @@ impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n \n     fn visit_generics(&mut self, generics: &ast::Generics) {\n         for ty_param in generics.ty_params.iter() {\n-            self.visit_ty_param_bounds(&ty_param.bounds);\n+            visit::walk_ty_param_bounds_helper(self, &ty_param.bounds);\n             match ty_param.default {\n                 Some(ref ty) => self.visit_ty(&**ty),\n                 None => {}\n             }\n         }\n         for predicate in generics.where_clause.predicates.iter() {\n             self.visit_ident(predicate.span, predicate.ident);\n-            self.visit_ty_param_bounds(&predicate.bounds);\n-        }\n-    }\n-}\n-\n-impl<'a> LifetimeContext<'a> {\n-    fn with(&mut self, wrap_scope: ScopeChain, f: |&mut LifetimeContext|) {\n-        let LifetimeContext {sess, ref mut named_region_map, ..} = *self;\n-        let mut this = LifetimeContext {\n-            sess: sess,\n-            named_region_map: *named_region_map,\n-            scope: &wrap_scope\n-        };\n-        debug!(\"entering scope {}\", this.scope);\n-        f(&mut this);\n-        debug!(\"exiting scope {}\", this.scope);\n-    }\n-\n-    fn visit_ty_param_bounds(&mut self,\n-                             bounds: &OwnedSlice<ast::TyParamBound>) {\n-        for bound in bounds.iter() {\n-            match *bound {\n-                ast::TraitTyParamBound(ref trait_ref) => {\n-                    self.visit_poly_trait_ref(trait_ref);\n-                }\n-                ast::RegionTyParamBound(ref lifetime) => {\n-                    self.visit_lifetime_ref(lifetime);\n-                }\n-            }\n+            visit::walk_ty_param_bounds_helper(self, &predicate.bounds);\n         }\n     }\n \n     fn visit_poly_trait_ref(&mut self, trait_ref: &ast::PolyTraitRef) {\n-        let ref_id = trait_ref.trait_ref.ref_id;\n-        self.with(LateScope(ref_id, &trait_ref.bound_lifetimes, self.scope), |this| {\n+        debug!(\"visit_poly_trait_ref trait_ref={}\", trait_ref);\n+\n+        self.with(LateScope(&trait_ref.bound_lifetimes, self.scope), |this| {\n             this.check_lifetime_defs(&trait_ref.bound_lifetimes);\n             for lifetime in trait_ref.bound_lifetimes.iter() {\n                 this.visit_lifetime_decl(lifetime);\n@@ -216,11 +235,25 @@ impl<'a> LifetimeContext<'a> {\n     fn visit_trait_ref(&mut self, trait_ref: &ast::TraitRef) {\n         self.visit_path(&trait_ref.path, trait_ref.ref_id);\n     }\n+}\n+\n+impl<'a> LifetimeContext<'a> {\n+    fn with(&mut self, wrap_scope: ScopeChain, f: |&mut LifetimeContext|) {\n+        let LifetimeContext {sess, ref mut named_region_map, ..} = *self;\n+        let mut this = LifetimeContext {\n+            sess: sess,\n+            named_region_map: *named_region_map,\n+            scope: &wrap_scope,\n+            def_map: self.def_map,\n+        };\n+        debug!(\"entering scope {}\", this.scope);\n+        f(&mut this);\n+        debug!(\"exiting scope {}\", this.scope);\n+    }\n \n     /// Visits self by adding a scope and handling recursive walk over the contents with `walk`.\n     fn visit_early_late(&mut self,\n                         early_space: subst::ParamSpace,\n-                        binder_id: ast::NodeId,\n                         generics: &ast::Generics,\n                         walk: |&mut LifetimeContext|) {\n         /*!\n@@ -249,15 +282,14 @@ impl<'a> LifetimeContext<'a> {\n \n         let referenced_idents = early_bound_lifetime_names(generics);\n \n-        debug!(\"visit_early_late: binder_id={} referenced_idents={}\",\n-               binder_id,\n+        debug!(\"visit_early_late: referenced_idents={}\",\n                referenced_idents);\n \n         let (early, late) = generics.lifetimes.clone().partition(\n             |l| referenced_idents.iter().any(|&i| i == l.lifetime.name));\n \n         self.with(EarlyScope(early_space, &early, self.scope), |this| {\n-            this.with(LateScope(binder_id, &late, this.scope), |this| {\n+            this.with(LateScope(&late, this.scope), |this| {\n                 this.check_lifetime_defs(&generics.lifetimes);\n                 walk(this);\n             });\n@@ -271,7 +303,7 @@ impl<'a> LifetimeContext<'a> {\n         // block, then the lifetime is not bound but free, so switch\n         // over to `resolve_free_lifetime_ref()` to complete the\n         // search.\n-        let mut depth = 0;\n+        let mut late_depth = 0;\n         let mut scope = self.scope;\n         loop {\n             match *scope {\n@@ -291,22 +323,22 @@ impl<'a> LifetimeContext<'a> {\n                             return;\n                         }\n                         None => {\n-                            depth += 1;\n                             scope = s;\n                         }\n                     }\n                 }\n \n-                LateScope(binder_id, lifetimes, s) => {\n+                LateScope(lifetimes, s) => {\n                     match search_lifetimes(lifetimes, lifetime_ref) {\n                         Some((_index, decl_id)) => {\n-                            let def = DefLateBoundRegion(binder_id, depth, decl_id);\n+                            let debruijn = ty::DebruijnIndex::new(late_depth + 1);\n+                            let def = DefLateBoundRegion(debruijn, decl_id);\n                             self.insert_lifetime(lifetime_ref, def);\n                             return;\n                         }\n \n                         None => {\n-                            depth += 1;\n+                            late_depth += 1;\n                             scope = s;\n                         }\n                     }\n@@ -339,7 +371,7 @@ impl<'a> LifetimeContext<'a> {\n                 }\n \n                 EarlyScope(_, lifetimes, s) |\n-                LateScope(_, lifetimes, s) => {\n+                LateScope(lifetimes, s) => {\n                     search_result = search_lifetimes(lifetimes, lifetime_ref);\n                     if search_result.is_some() {\n                         break;\n@@ -467,10 +499,10 @@ fn early_bound_lifetime_names(generics: &ast::Generics) -> Vec<ast::Name> {\n             FreeLifetimeCollector { early_bound: &mut early_bound,\n                                     late_bound: &mut late_bound };\n         for ty_param in generics.ty_params.iter() {\n-            visit::walk_ty_param_bounds(&mut collector, &ty_param.bounds);\n+            visit::walk_ty_param_bounds_helper(&mut collector, &ty_param.bounds);\n         }\n         for predicate in generics.where_clause.predicates.iter() {\n-            visit::walk_ty_param_bounds(&mut collector, &predicate.bounds);\n+            visit::walk_ty_param_bounds_helper(&mut collector, &predicate.bounds);\n         }\n     }\n \n@@ -517,7 +549,7 @@ impl<'a> fmt::Show for ScopeChain<'a> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n             EarlyScope(space, defs, _) => write!(fmt, \"EarlyScope({}, {})\", space, defs),\n-            LateScope(id, defs, _) => write!(fmt, \"LateScope({}, {})\", id, defs),\n+            LateScope(defs, _) => write!(fmt, \"LateScope({})\", defs),\n             BlockScope(id, _) => write!(fmt, \"BlockScope({})\", id),\n             RootScope => write!(fmt, \"RootScope\"),\n         }"}, {"sha": "4fabdabf3db4bba35d2ff3f8b10e48ba8d3114ec", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 182, "deletions": 31, "changes": 213, "blob_url": "https://github.com/rust-lang/rust/blob/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=c8d6e3b2c2a780eff92299da5d1c02e081617088", "patch": "@@ -14,8 +14,7 @@ pub use self::ParamSpace::*;\n pub use self::RegionSubsts::*;\n \n use middle::ty;\n-use middle::ty_fold;\n-use middle::ty_fold::{TypeFoldable, TypeFolder};\n+use middle::ty_fold::{mod, TypeFoldable, TypeFolder};\n use util::ppaux::Repr;\n \n use std::fmt;\n@@ -101,6 +100,17 @@ impl Substs {\n         regions_is_noop && self.types.is_empty()\n     }\n \n+    pub fn has_regions_escaping_depth(&self, depth: uint) -> bool {\n+        self.types.iter().any(|&t| ty::type_escapes_depth(t, depth)) || {\n+            match self.regions {\n+                ErasedRegions =>\n+                    false,\n+                NonerasedRegions(ref regions) =>\n+                    regions.iter().any(|r| r.escapes_depth(depth)),\n+            }\n+        }\n+    }\n+\n     pub fn self_ty(&self) -> Option<ty::t> {\n         self.types.get_self().map(|&t| t)\n     }\n@@ -166,6 +176,13 @@ impl RegionSubsts {\n             NonerasedRegions(r) => NonerasedRegions(op(r, a))\n         }\n     }\n+\n+    pub fn is_erased(&self) -> bool {\n+        match *self {\n+            ErasedRegions => true,\n+            NonerasedRegions(_) => false,\n+        }\n+    }\n }\n \n ///////////////////////////////////////////////////////////////////////////\n@@ -392,6 +409,10 @@ impl<T> VecPerParamSpace<T> {\n         self.content.iter()\n     }\n \n+    pub fn iter_enumerated<'a>(&'a self) -> EnumeratedItems<'a,T> {\n+        EnumeratedItems::new(self)\n+    }\n+\n     pub fn as_slice(&self) -> &[T] {\n         self.content.as_slice()\n     }\n@@ -421,6 +442,14 @@ impl<T> VecPerParamSpace<T> {\n                                        self.assoc_limit)\n     }\n \n+    pub fn map_enumerated<U>(&self, pred: |(ParamSpace, uint, &T)| -> U) -> VecPerParamSpace<U> {\n+        let result = self.iter_enumerated().map(pred).collect();\n+        VecPerParamSpace::new_internal(result,\n+                                       self.type_limit,\n+                                       self.self_limit,\n+                                       self.assoc_limit)\n+    }\n+\n     pub fn map_move<U>(self, pred: |T| -> U) -> VecPerParamSpace<U> {\n         let SeparateVecsPerParamSpace {\n             types: t,\n@@ -457,6 +486,49 @@ impl<T> VecPerParamSpace<T> {\n     }\n }\n \n+pub struct EnumeratedItems<'a,T:'a> {\n+    vec: &'a VecPerParamSpace<T>,\n+    space_index: uint,\n+    elem_index: uint\n+}\n+\n+impl<'a,T> EnumeratedItems<'a,T> {\n+    fn new(v: &'a VecPerParamSpace<T>) -> EnumeratedItems<'a,T> {\n+        let mut result = EnumeratedItems { vec: v, space_index: 0, elem_index: 0 };\n+        result.adjust_space();\n+        result\n+    }\n+\n+    fn adjust_space(&mut self) {\n+        let spaces = ParamSpace::all();\n+        while\n+            self.space_index < spaces.len() &&\n+            self.elem_index >= self.vec.len(spaces[self.space_index])\n+        {\n+            self.space_index += 1;\n+            self.elem_index = 0;\n+        }\n+    }\n+}\n+\n+impl<'a,T> Iterator<(ParamSpace, uint, &'a T)> for EnumeratedItems<'a,T> {\n+    fn next(&mut self) -> Option<(ParamSpace, uint, &'a T)> {\n+        let spaces = ParamSpace::all();\n+        if self.space_index < spaces.len() {\n+            let space = spaces[self.space_index];\n+            let index = self.elem_index;\n+            let item = self.vec.get(space, index);\n+\n+            self.elem_index += 1;\n+            self.adjust_space();\n+\n+            Some((space, index, item))\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n ///////////////////////////////////////////////////////////////////////////\n // Public trait `Subst`\n //\n@@ -486,7 +558,8 @@ impl<T:TypeFoldable> Subst for T {\n                                        substs: substs,\n                                        span: span,\n                                        root_ty: None,\n-                                       ty_stack_depth: 0 };\n+                                       ty_stack_depth: 0,\n+                                       region_binders_passed: 0 };\n         (*self).fold_with(&mut folder)\n     }\n }\n@@ -506,11 +579,22 @@ struct SubstFolder<'a, 'tcx: 'a> {\n \n     // Depth of type stack\n     ty_stack_depth: uint,\n+\n+    // Number of region binders we have passed through while doing the substitution\n+    region_binders_passed: uint,\n }\n \n impl<'a, 'tcx> TypeFolder<'tcx> for SubstFolder<'a, 'tcx> {\n     fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx> { self.tcx }\n \n+    fn enter_region_binder(&mut self) {\n+        self.region_binders_passed += 1;\n+    }\n+\n+    fn exit_region_binder(&mut self) {\n+        self.region_binders_passed -= 1;\n+    }\n+\n     fn fold_region(&mut self, r: ty::Region) -> ty::Region {\n         // Note: This routine only handles regions that are bound on\n         // type declarations and other outer declarations, not those\n@@ -524,7 +608,9 @@ impl<'a, 'tcx> TypeFolder<'tcx> for SubstFolder<'a, 'tcx> {\n                     ErasedRegions => ty::ReStatic,\n                     NonerasedRegions(ref regions) =>\n                         match regions.opt_get(space, i) {\n-                            Some(t) => *t,\n+                            Some(&r) => {\n+                                self.shift_region_through_binders(r)\n+                            }\n                             None => {\n                                 let span = self.span.unwrap_or(DUMMY_SP);\n                                 self.tcx().sess.span_bug(\n@@ -557,12 +643,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for SubstFolder<'a, 'tcx> {\n \n         let t1 = match ty::get(t).sty {\n             ty::ty_param(p) => {\n-                check(self,\n-                      p,\n-                      t,\n-                      self.substs.types.opt_get(p.space, p.idx),\n-                      p.space,\n-                      p.idx)\n+                self.ty_for_param(p, t)\n             }\n             _ => {\n                 ty_fold::super_fold_ty(self, t)\n@@ -576,30 +657,100 @@ impl<'a, 'tcx> TypeFolder<'tcx> for SubstFolder<'a, 'tcx> {\n         }\n \n         return t1;\n+    }\n+}\n \n-        fn check(this: &SubstFolder,\n-                 p: ty::ParamTy,\n-                 source_ty: ty::t,\n-                 opt_ty: Option<&ty::t>,\n-                 space: ParamSpace,\n-                 index: uint)\n-                 -> ty::t {\n-            match opt_ty {\n-                Some(t) => *t,\n-                None => {\n-                    let span = this.span.unwrap_or(DUMMY_SP);\n-                    this.tcx().sess.span_bug(\n-                        span,\n-                        format!(\"Type parameter `{}` ({}/{}/{}) out of range \\\n+impl<'a,'tcx> SubstFolder<'a,'tcx> {\n+    fn ty_for_param(&self, p: ty::ParamTy, source_ty: ty::t) -> ty::t {\n+        // Look up the type in the substitutions. It really should be in there.\n+        let opt_ty = self.substs.types.opt_get(p.space, p.idx);\n+        let ty = match opt_ty {\n+            Some(t) => *t,\n+            None => {\n+                let span = self.span.unwrap_or(DUMMY_SP);\n+                self.tcx().sess.span_bug(\n+                    span,\n+                    format!(\"Type parameter `{}` ({}/{}/{}) out of range \\\n                                  when substituting (root type={}) substs={}\",\n-                                p.repr(this.tcx()),\n-                                source_ty.repr(this.tcx()),\n-                                space,\n-                                index,\n-                                this.root_ty.repr(this.tcx()),\n-                                this.substs.repr(this.tcx())).as_slice());\n-                }\n+                            p.repr(self.tcx()),\n+                            source_ty.repr(self.tcx()),\n+                            p.space,\n+                            p.idx,\n+                            self.root_ty.repr(self.tcx()),\n+                            self.substs.repr(self.tcx())).as_slice());\n             }\n+        };\n+\n+        self.shift_regions_through_binders(ty)\n+    }\n+\n+    fn shift_regions_through_binders(&self, ty: ty::t) -> ty::t {\n+        /*!\n+         * It is sometimes necessary to adjust the debruijn indices\n+         * during substitution. This occurs when we are substituting a\n+         * type with escaping regions into a context where we have\n+         * passed through region binders. That's quite a\n+         * mouthful. Let's see an example:\n+         *\n+         * ```\n+         * type Func<A> = fn(A);\n+         * type MetaFunc = for<'a> fn(Func<&'a int>)\n+         * ```\n+         *\n+         * The type `MetaFunc`, when fully expanded, will be\n+         *\n+         *     for<'a> fn(fn(&'a int))\n+         *             ^~ ^~ ^~~\n+         *             |  |  |\n+         *             |  |  DebruijnIndex of 2\n+         *             Binders\n+         *\n+         * Here the `'a` lifetime is bound in the outer function, but\n+         * appears as an argument of the inner one. Therefore, that\n+         * appearance will have a DebruijnIndex of 2, because we must\n+         * skip over the inner binder (remember that we count Debruijn\n+         * indices from 1). However, in the definition of `MetaFunc`,\n+         * the binder is not visible, so the type `&'a int` will have\n+         * a debruijn index of 1. It's only during the substitution\n+         * that we can see we must increase the depth by 1 to account\n+         * for the binder that we passed through.\n+         *\n+         * As a second example, consider this twist:\n+         *\n+         * ```\n+         * type FuncTuple<A> = (A,fn(A));\n+         * type MetaFuncTuple = for<'a> fn(FuncTuple<&'a int>)\n+         * ```\n+         *\n+         * Here the final type will be:\n+         *\n+         *     for<'a> fn((&'a int, fn(&'a int)))\n+         *                 ^~~         ^~~\n+         *                 |           |\n+         *          DebruijnIndex of 1 |\n+         *                      DebruijnIndex of 2\n+         *\n+         * As indicated in the diagram, here the same type `&'a int`\n+         * is substituted once, but in the first case we do not\n+         * increase the Debruijn index and in the second case we\n+         * do. The reason is that only in the second case have we\n+         * passed through a fn binder.\n+         */\n+\n+        debug!(\"shift_regions(ty={}, region_binders_passed={}, type_has_escaping_regions={})\",\n+               ty.repr(self.tcx()), self.region_binders_passed, ty::type_has_escaping_regions(ty));\n+\n+        if self.region_binders_passed == 0 || !ty::type_has_escaping_regions(ty) {\n+            return ty;\n         }\n+\n+        let result = ty_fold::shift_regions(self.tcx(), self.region_binders_passed, &ty);\n+        debug!(\"shift_regions: shifted result = {}\", result.repr(self.tcx()));\n+\n+        result\n+    }\n+\n+    fn shift_region_through_binders(&self, region: ty::Region) -> ty::Region {\n+        ty_fold::shift_region(region, self.region_binders_passed)\n     }\n }"}, {"sha": "405f6509e596d5b3b13b1432d22d892144cd1f2e", "filename": "src/librustc/middle/traits/coherence.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs?ref=c8d6e3b2c2a780eff92299da5d1c02e081617088", "patch": "@@ -17,7 +17,7 @@ use super::util;\n use middle::subst;\n use middle::subst::Subst;\n use middle::ty;\n-use middle::typeck::infer::InferCtxt;\n+use middle::typeck::infer::{mod, InferCtxt};\n use syntax::ast;\n use syntax::codemap::DUMMY_SP;\n use util::ppaux::Repr;\n@@ -38,14 +38,18 @@ pub fn impl_can_satisfy(infcx: &InferCtxt,\n         util::fresh_substs_for_impl(infcx, DUMMY_SP, impl1_def_id);\n     let impl1_trait_ref =\n         ty::impl_trait_ref(infcx.tcx, impl1_def_id).unwrap()\n-            .subst(infcx.tcx, &impl1_substs);\n+                                                   .subst(infcx.tcx, &impl1_substs);\n+    let impl1_trait_ref =\n+        infcx.replace_late_bound_regions_with_fresh_var(DUMMY_SP,\n+                                                        infer::FnCall,\n+                                                        &impl1_trait_ref).0;\n \n     // Determine whether `impl2` can provide an implementation for those\n     // same types.\n     let param_env = ty::empty_parameter_environment();\n     let mut selcx = SelectionContext::intercrate(infcx, &param_env, infcx.tcx);\n     let obligation = Obligation::misc(DUMMY_SP, impl1_trait_ref);\n-    debug!(\"impl_can_satisfy obligation={}\", obligation.repr(infcx.tcx));\n+    debug!(\"impl_can_satisfy(obligation={})\", obligation.repr(infcx.tcx));\n     selcx.evaluate_impl(impl2_def_id, &obligation)\n }\n "}, {"sha": "ff5d80c8a16a21fa9d5c86bb8be57aa52ecdb17e", "filename": "src/librustc/middle/traits/fulfill.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs?ref=c8d6e3b2c2a780eff92299da5d1c02e081617088", "patch": "@@ -55,6 +55,7 @@ impl FulfillmentContext {\n                                obligation: Obligation)\n     {\n         debug!(\"register_obligation({})\", obligation.repr(tcx));\n+        assert!(!obligation.trait_ref.has_escaping_regions());\n         self.trait_obligations.push(obligation);\n     }\n "}, {"sha": "c9c9e3bd4ffdc1df9d459e82586729ae9c6ada6a", "filename": "src/librustc/middle/traits/mod.rs", "status": "modified", "additions": 10, "deletions": 15, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs?ref=c8d6e3b2c2a780eff92299da5d1c02e081617088", "patch": "@@ -281,33 +281,28 @@ pub fn overlapping_impls(infcx: &InferCtxt,\n     coherence::impl_can_satisfy(infcx, impl2_def_id, impl1_def_id)\n }\n \n-pub fn impl_obligations(tcx: &ty::ctxt,\n-                        cause: ObligationCause,\n-                        impl_def_id: ast::DefId,\n-                        impl_substs: &subst::Substs)\n-                        -> subst::VecPerParamSpace<Obligation>\n-{\n-    let impl_generics = ty::lookup_item_type(tcx, impl_def_id).generics;\n-    obligations_for_generics(tcx, cause, &impl_generics, impl_substs)\n-}\n-\n pub fn obligations_for_generics(tcx: &ty::ctxt,\n                                 cause: ObligationCause,\n-                                generics: &ty::Generics,\n-                                substs: &subst::Substs)\n+                                generic_bounds: &ty::GenericBounds,\n+                                type_substs: &subst::VecPerParamSpace<ty::t>)\n                                 -> subst::VecPerParamSpace<Obligation>\n {\n     /*!\n-     * Given generics for an impl like:\n+     * Given generic bounds from an impl like:\n      *\n      *    impl<A:Foo, B:Bar+Qux> ...\n      *\n-     * and a substs vector like `<A=A0, B=B0>`, yields a result like\n+     * along with the bindings for the types `A` and `B` (e.g.,\n+     * `<A=A0, B=B0>`), yields a result like\n      *\n      *    [[Foo for A0, Bar for B0, Qux for B0], [], []]\n+     *\n+     * Expects that `generic_bounds` have already been fully\n+     * substituted, late-bound regions liberated and so forth,\n+     * so that they are in the same namespace as `type_substs`.\n      */\n \n-    util::obligations_for_generics(tcx, cause, 0, generics, substs)\n+    util::obligations_for_generics(tcx, cause, 0, generic_bounds, type_substs)\n }\n \n pub fn obligation_for_builtin_bound(tcx: &ty::ctxt,"}, {"sha": "a941d2b079e21250411df2891cab723d9e838247", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 15, "deletions": 23, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=c8d6e3b2c2a780eff92299da5d1c02e081617088", "patch": "@@ -31,9 +31,7 @@ use middle::fast_reject;\n use middle::mem_categorization::Typer;\n use middle::subst::{Subst, Substs, VecPerParamSpace};\n use middle::ty;\n-use middle::typeck::check::regionmanip;\n use middle::typeck::infer;\n-use middle::typeck::infer::LateBoundRegionConversionTime::*;\n use middle::typeck::infer::{InferCtxt, TypeSkolemizer};\n use middle::ty_fold::TypeFoldable;\n use std::cell::RefCell;\n@@ -211,6 +209,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n          */\n \n         debug!(\"select({})\", obligation.repr(self.tcx()));\n+        assert!(!obligation.trait_ref.has_escaping_regions());\n \n         let stack = self.push_stack(None, obligation);\n         match try!(self.candidate_from_obligation(&stack)) {\n@@ -263,6 +262,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         debug!(\"evaluate_obligation({})\",\n                obligation.repr(self.tcx()));\n+        assert!(!obligation.trait_ref.has_escaping_regions());\n \n         let stack = self.push_stack(None, obligation);\n         self.evaluate_stack(&stack).may_apply()\n@@ -747,6 +747,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         debug!(\"candidate_from_obligation(cache_skol_trait_ref={}, obligation={})\",\n                cache_skol_trait_ref.repr(self.tcx()),\n                stack.repr(self.tcx()));\n+        assert!(!stack.obligation.trait_ref.has_escaping_regions());\n \n         match self.check_candidate_cache(cache_skol_trait_ref.clone()) {\n             Some(c) => {\n@@ -1707,27 +1708,18 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             }\n         };\n \n-        // FIXME(pcwalton): This is a bogus thing to do, but\n-        // it'll do for now until we get the new trait-bound\n-        // region skolemization working.\n-        let (_, new_signature) =\n-            regionmanip::replace_late_bound_regions(\n-                self.tcx(),\n-                closure_type.sig.binder_id,\n-                &closure_type.sig,\n-                |br| self.infcx.next_region_var(\n-                         infer::LateBoundRegion(obligation.cause.span, br,\n-                                                infer::FnCall)));\n-\n-        let arguments_tuple = new_signature.inputs[0];\n-        let trait_ref = Rc::new(ty::TraitRef {\n-            def_id: obligation.trait_ref.def_id,\n-            substs: Substs::new_trait(\n+        let closure_sig = &closure_type.sig;\n+        let arguments_tuple = closure_sig.inputs[0];\n+        let substs =\n+            Substs::new_trait(\n                 vec![arguments_tuple.subst(self.tcx(), substs),\n-                     new_signature.output.unwrap().subst(self.tcx(), substs)],\n+                     closure_sig.output.unwrap().subst(self.tcx(), substs)],\n                 vec![],\n                 vec![],\n-                obligation.self_ty())\n+                obligation.self_ty());\n+        let trait_ref = Rc::new(ty::TraitRef {\n+            def_id: obligation.trait_ref.def_id,\n+            substs: substs,\n         });\n \n         self.confirm(obligation.cause,\n@@ -2025,10 +2017,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                         impl_substs: &Substs)\n                         -> VecPerParamSpace<Obligation>\n     {\n-        let impl_generics = ty::lookup_item_type(self.tcx(),\n-                                                 impl_def_id).generics;\n+        let impl_generics = ty::lookup_item_type(self.tcx(), impl_def_id).generics;\n+        let bounds = impl_generics.to_bounds(self.tcx(), impl_substs);\n         util::obligations_for_generics(self.tcx(), cause, recursion_depth,\n-                                       &impl_generics, impl_substs)\n+                                       &bounds, &impl_substs.types)\n     }\n }\n "}, {"sha": "8f8203f0281b1735b6345f5f903d28f09850b1bd", "filename": "src/librustc/middle/traits/util.rs", "status": "modified", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs?ref=c8d6e3b2c2a780eff92299da5d1c02e081617088", "patch": "@@ -10,7 +10,7 @@\n // except according to those terms.\n \n use middle::subst;\n-use middle::subst::{ParamSpace, Subst, Substs, VecPerParamSpace};\n+use middle::subst::{ParamSpace, Substs, VecPerParamSpace};\n use middle::typeck::infer::InferCtxt;\n use middle::ty;\n use std::collections::HashSet;\n@@ -173,25 +173,25 @@ impl fmt::Show for VtableParamData {\n pub fn obligations_for_generics(tcx: &ty::ctxt,\n                                 cause: ObligationCause,\n                                 recursion_depth: uint,\n-                                generics: &ty::Generics,\n-                                substs: &Substs)\n+                                generic_bounds: &ty::GenericBounds,\n+                                type_substs: &VecPerParamSpace<ty::t>)\n                                 -> VecPerParamSpace<Obligation>\n {\n     /*! See `super::obligations_for_generics` */\n \n-    debug!(\"obligations_for_generics(generics={}, substs={})\",\n-           generics.repr(tcx), substs.repr(tcx));\n+    debug!(\"obligations_for_generics(generic_bounds={}, type_substs={})\",\n+           generic_bounds.repr(tcx), type_substs.repr(tcx));\n \n     let mut obligations = VecPerParamSpace::empty();\n \n-    for def in generics.types.iter() {\n+    for (space, index, bounds) in generic_bounds.types.iter_enumerated() {\n         push_obligations_for_param_bounds(tcx,\n                                           cause,\n                                           recursion_depth,\n-                                          def.space,\n-                                          def.index,\n-                                          &def.bounds,\n-                                          substs,\n+                                          space,\n+                                          index,\n+                                          bounds,\n+                                          type_substs,\n                                           &mut obligations);\n     }\n \n@@ -207,11 +207,10 @@ fn push_obligations_for_param_bounds(\n     space: subst::ParamSpace,\n     index: uint,\n     param_bounds: &ty::ParamBounds,\n-    param_substs: &Substs,\n+    param_type_substs: &VecPerParamSpace<ty::t>,\n     obligations: &mut VecPerParamSpace<Obligation>)\n {\n-    let param_ty = *param_substs.types.get(space, index);\n-\n+    let param_ty = *param_type_substs.get(space, index);\n     for builtin_bound in param_bounds.builtin_bounds.iter() {\n         let obligation = obligation_for_builtin_bound(tcx,\n                                                       cause,\n@@ -225,12 +224,11 @@ fn push_obligations_for_param_bounds(\n     }\n \n     for bound_trait_ref in param_bounds.trait_bounds.iter() {\n-        let bound_trait_ref = bound_trait_ref.subst(tcx, param_substs);\n         obligations.push(\n             space,\n             Obligation { cause: cause,\n                          recursion_depth: recursion_depth,\n-                         trait_ref: bound_trait_ref });\n+                         trait_ref: (*bound_trait_ref).clone() });\n     }\n }\n "}, {"sha": "9f90afa37490c6e37d9f9dd7e30f93618eb02f71", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 593, "deletions": 151, "changes": 744, "blob_url": "https://github.com/rust-lang/rust/blob/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=c8d6e3b2c2a780eff92299da5d1c02e081617088", "patch": "@@ -53,7 +53,7 @@ use middle::subst::{mod, Subst, Substs, VecPerParamSpace};\n use middle::traits;\n use middle::ty;\n use middle::typeck;\n-use middle::ty_fold::{mod, TypeFoldable,TypeFolder};\n+use middle::ty_fold::{mod, TypeFoldable, TypeFolder, HigherRankedFoldable};\n use middle;\n use util::ppaux::{note_and_explain_region, bound_region_ptr_to_string};\n use util::ppaux::{trait_store_to_string, ty_to_string};\n@@ -609,13 +609,14 @@ pub struct ctxt<'tcx> {\n // recursing over the type itself.\n bitflags! {\n     flags TypeFlags: u32 {\n-        const NO_TYPE_FLAGS = 0b0,\n-        const HAS_PARAMS    = 0b1,\n-        const HAS_SELF      = 0b10,\n-        const HAS_TY_INFER  = 0b100,\n-        const HAS_RE_INFER  = 0b1000,\n-        const HAS_REGIONS   = 0b10000,\n-        const HAS_TY_ERR    = 0b100000,\n+        const NO_TYPE_FLAGS       = 0b0,\n+        const HAS_PARAMS          = 0b1,\n+        const HAS_SELF            = 0b10,\n+        const HAS_TY_INFER        = 0b100,\n+        const HAS_RE_INFER        = 0b1000,\n+        const HAS_RE_LATE_BOUND   = 0b10000,\n+        const HAS_REGIONS         = 0b100000,\n+        const HAS_TY_ERR          = 0b1000000,\n         const NEEDS_SUBST   = HAS_PARAMS.bits | HAS_SELF.bits | HAS_REGIONS.bits,\n     }\n }\n@@ -626,6 +627,9 @@ pub type t_box = &'static t_box_;\n pub struct t_box_ {\n     pub sty: sty,\n     pub flags: TypeFlags,\n+\n+    // the maximal depth of any bound regions appearing in this type.\n+    region_depth: uint,\n }\n \n impl fmt::Show for TypeFlags {\n@@ -670,6 +674,50 @@ pub fn type_needs_infer(t: t) -> bool {\n     tbox_has_flag(get(t), HAS_TY_INFER | HAS_RE_INFER)\n }\n \n+pub fn type_has_late_bound_regions(ty: t) -> bool {\n+    get(ty).flags.intersects(HAS_RE_LATE_BOUND)\n+}\n+\n+pub fn type_has_escaping_regions(t: t) -> bool {\n+    /*!\n+     * An \"escaping region\" is a bound region whose binder is not part of `t`.\n+     *\n+     * So, for example, consider a type like the following, which has two\n+     * binders:\n+     *\n+     *    for<'a> fn(x: for<'b> fn(&'a int, &'b int))\n+     *    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ outer scope\n+     *                  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~  inner scope\n+     *\n+     * This type has *bound regions* (`'a`, `'b`), but it does not\n+     * have escaping regions, because the binders of both `'a` and\n+     * `'b` are part of the type itself. However, if we consider the\n+     * *inner fn type*, that type has an escaping region: `'a`.\n+     *\n+     * Note that what I'm calling an \"escaping region\" is often just\n+     * called a \"free region\". However, we already use the term \"free\n+     * region\". It refers to the regions that we use to represent\n+     * bound regions on a fn definition while we are typechecking its\n+     * body.\n+     *\n+     * To clarify, conceptually there is no particular difference\n+     * between an \"escaping\" region and a \"free\" region. However,\n+     * there is a big difference in practice. Basically, when\n+     * \"entering\" a binding level, one is generally required to do\n+     * some sort of processing to a bound region, such as replacing it\n+     * with a fresh/skolemized region, or making an entry in the\n+     * environment to represent the scope to which it is attached,\n+     * etc. An escaping region represents a bound region for which\n+     * this processing has not yet been done.\n+     */\n+\n+    type_escapes_depth(t, 0)\n+}\n+\n+pub fn type_escapes_depth(t: t, depth: uint) -> bool {\n+    get(t).region_depth > depth\n+}\n+\n #[deriving(Clone, PartialEq, Eq, Hash, Show)]\n pub struct BareFnTy {\n     pub fn_style: ast::FnStyle,\n@@ -706,17 +754,16 @@ impl FnOutput {\n  * Signature of a function type, which I have arbitrarily\n  * decided to use to refer to the input/output types.\n  *\n- * - `binder_id` is the node id where this fn type appeared;\n- *   it is used to identify all the bound regions appearing\n- *   in the input/output types that are bound by this fn type\n- *   (vs some enclosing or enclosed fn type)\n  * - `inputs` is the list of arguments and their modes.\n  * - `output` is the return type.\n  * - `variadic` indicates whether this is a varidic function. (only true for foreign fns)\n+ *\n+ * Note that a `FnSig` introduces a level of region binding, to\n+ * account for late-bound parameters that appear in the types of the\n+ * fn's arguments or the fn's return type.\n  */\n #[deriving(Clone, PartialEq, Eq, Hash)]\n pub struct FnSig {\n-    pub binder_id: ast::NodeId,\n     pub inputs: Vec<t>,\n     pub output: FnOutput,\n     pub variadic: bool\n@@ -729,6 +776,54 @@ pub struct ParamTy {\n     pub def_id: DefId\n }\n \n+/**\n+ * A [De Bruijn index][dbi] is a standard means of representing\n+ * regions (and perhaps later types) in a higher-ranked setting. In\n+ * particular, imagine a type like this:\n+ *\n+ *     for<'a> fn(for<'b> fn(&'b int, &'a int), &'a char)\n+ *     ^          ^            |        |         |\n+ *     |          |            |        |         |\n+ *     |          +------------+ 1      |         |\n+ *     |                                |         |\n+ *     +--------------------------------+ 2       |\n+ *     |                                          |\n+ *     +------------------------------------------+ 1\n+ *\n+ * In this type, there are two binders (the outer fn and the inner\n+ * fn). We need to be able to determine, for any given region, which\n+ * fn type it is bound by, the inner or the outer one. There are\n+ * various ways you can do this, but a De Bruijn index is one of the\n+ * more convenient and has some nice properties. The basic idea is to\n+ * count the number of binders, inside out. Some examples should help\n+ * clarify what I mean.\n+ *\n+ * Let's start with the reference type `&'b int` that is the first\n+ * argument to the inner function. This region `'b` is assigned a De\n+ * Bruijn index of 1, meaning \"the innermost binder\" (in this case, a\n+ * fn). The region `'a` that appears in the second argument type (`&'a\n+ * int`) would then be assigned a De Bruijn index of 2, meaning \"the\n+ * second-innermost binder\". (These indices are written on the arrays\n+ * in the diagram).\n+ *\n+ * What is interesting is that De Bruijn index attached to a particular\n+ * variable will vary depending on where it appears. For example,\n+ * the final type `&'a char` also refers to the region `'a` declared on\n+ * the outermost fn. But this time, this reference is not nested within\n+ * any other binders (i.e., it is not an argument to the inner fn, but\n+ * rather the outer one). Therefore, in this case, it is assigned a\n+ * De Bruijn index of 1, because the innermost binder in that location\n+ * is the outer fn.\n+ *\n+ * [dbi]: http://en.wikipedia.org/wiki/De_Bruijn_index\n+ */\n+#[deriving(Clone, PartialEq, Eq, Hash, Encodable, Decodable, Show)]\n+pub struct DebruijnIndex {\n+    // We maintain the invariant that this is never 0. So 1 indicates\n+    // the innermost binder. To ensure this, create with `DebruijnIndex::new`.\n+    pub depth: uint,\n+}\n+\n /// Representation of regions:\n #[deriving(Clone, PartialEq, Eq, Hash, Encodable, Decodable, Show)]\n pub enum Region {\n@@ -741,9 +836,8 @@ pub enum Region {\n                  ast::Name),\n \n     // Region bound in a function scope, which will be substituted when the\n-    // function is called. The first argument must be the `binder_id` of\n-    // some enclosing function signature.\n-    ReLateBound(/* binder_id */ ast::NodeId, BoundRegion),\n+    // function is called.\n+    ReLateBound(DebruijnIndex, BoundRegion),\n \n     /// When checking a function body, the types of all arguments and so forth\n     /// that refer to bound region parameters are modified to refer to free\n@@ -885,12 +979,19 @@ pub type UpvarBorrowMap = FnvHashMap<UpvarId, UpvarBorrow>;\n \n impl Region {\n     pub fn is_bound(&self) -> bool {\n-        match self {\n-            &ty::ReEarlyBound(..) => true,\n-            &ty::ReLateBound(..) => true,\n+        match *self {\n+            ty::ReEarlyBound(..) => true,\n+            ty::ReLateBound(..) => true,\n             _ => false\n         }\n     }\n+\n+    pub fn escapes_depth(&self, depth: uint) -> bool {\n+        match *self {\n+            ty::ReLateBound(debruijn, _) => debruijn.depth > depth,\n+            _ => false,\n+        }\n+    }\n }\n \n #[deriving(Clone, PartialEq, PartialOrd, Eq, Ord, Hash, Encodable, Decodable, Show)]\n@@ -928,6 +1029,7 @@ mod primitives {\n             pub static $name: t_box_ = t_box_ {\n                 sty: $sty,\n                 flags: super::NO_TYPE_FLAGS,\n+                region_depth: 0,\n             };\n         )\n     )\n@@ -950,6 +1052,7 @@ mod primitives {\n     pub static TY_ERR: t_box_ = t_box_ {\n         sty: super::ty_err,\n         flags: super::HAS_TY_ERR,\n+        region_depth: 0,\n     };\n }\n \n@@ -1002,12 +1105,46 @@ pub struct TyTrait {\n     pub bounds: ExistentialBounds\n }\n \n+/**\n+ * A complete reference to a trait. These take numerous guises in syntax,\n+ * but perhaps the most recognizable form is in a where clause:\n+ *\n+ *     T : Foo<U>\n+ *\n+ * This would be represented by a trait-reference where the def-id is the\n+ * def-id for the trait `Foo` and the substs defines `T` as parameter 0 in the\n+ * `SelfSpace` and `U` as parameter 0 in the `TypeSpace`.\n+ *\n+ * Trait references also appear in object types like `Foo<U>`, but in\n+ * that case the `Self` parameter is absent from the substitutions.\n+ *\n+ * Note that a `TraitRef` introduces a level of region binding, to\n+ * account for higher-ranked trait bounds like `T : for<'a> Foo<&'a\n+ * U>` or higher-ranked object types.\n+ */\n #[deriving(Clone, PartialEq, Eq, Hash, Show)]\n pub struct TraitRef {\n     pub def_id: DefId,\n     pub substs: Substs,\n }\n \n+/**\n+ * Binder serves as a synthetic binder for lifetimes. It is used when\n+ * we wish to replace the escaping higher-ranked lifetimes in a type\n+ * or something else that is not itself a binder (this is because the\n+ * `replace_late_bound_regions` function replaces all lifetimes bound\n+ * by the binder supplied to it; but a type is not a binder, so you\n+ * must introduce an artificial one).\n+ */\n+#[deriving(Clone, PartialEq, Eq, Hash, Show)]\n+pub struct Binder<T> {\n+    pub value: T\n+}\n+\n+pub fn bind<T>(value: T) -> Binder<T> {\n+    Binder { value: value }\n+}\n+\n #[deriving(Clone, PartialEq)]\n pub enum IntVarValue {\n     IntType(ast::IntTy),\n@@ -1272,6 +1409,52 @@ impl Generics {\n     pub fn has_region_params(&self, space: subst::ParamSpace) -> bool {\n         !self.regions.is_empty_in(space)\n     }\n+\n+    pub fn to_bounds(&self, tcx: &ty::ctxt, substs: &Substs) -> GenericBounds {\n+        GenericBounds {\n+            types: self.types.map(|d| d.bounds.subst(tcx, substs)),\n+            regions: self.regions.map(|d| d.bounds.subst(tcx, substs)),\n+        }\n+    }\n+}\n+\n+/**\n+ * Represents the bounds declared on a particular set of type\n+ * parameters.  Should eventually be generalized into a flag list of\n+ * where clauses.  You can obtain a `GenericBounds` list from a\n+ * `Generics` by using the `to_bounds` method. Note that this method\n+ * reflects an important semantic invariant of `GenericBounds`: while\n+ * the bounds in a `Generics` are expressed in terms of the bound type\n+ * parameters of the impl/trait/whatever, a `GenericBounds` instance\n+ * represented a set of bounds for some particular instantiation,\n+ * meaning that the generic parameters have been substituted with\n+ * their values.\n+ *\n+ * Example:\n+ *\n+ *     struct Foo<T,U:Bar<T>> { ... }\n+ *\n+ * Here, the `Generics` for `Foo` would contain a list of bounds like\n+ * `[[], [U:Bar<T>]]`.  Now if there were some particular reference\n+ * like `Foo<int,uint>`, then the `GenericBounds` would be `[[],\n+ * [uint:Bar<int>]]`.\n+ */\n+#[deriving(Clone, Show)]\n+pub struct GenericBounds {\n+    pub types: VecPerParamSpace<ParamBounds>,\n+    pub regions: VecPerParamSpace<Vec<Region>>,\n+}\n+\n+impl GenericBounds {\n+    pub fn empty() -> GenericBounds {\n+        GenericBounds { types: VecPerParamSpace::empty(),\n+                        regions: VecPerParamSpace::empty() }\n+    }\n+\n+    pub fn has_escaping_regions(&self) -> bool {\n+        self.types.any(|pb| pb.trait_bounds.iter().any(|tr| tr.has_escaping_regions())) ||\n+            self.regions.any(|rs| rs.iter().any(|r| r.escapes_depth(0)))\n+    }\n }\n \n impl TraitRef {\n@@ -1290,6 +1473,14 @@ impl TraitRef {\n         // associated types.\n         self.substs.types.as_slice()\n     }\n+\n+    pub fn has_escaping_regions(&self) -> bool {\n+        self.substs.has_regions_escaping_depth(1)\n+    }\n+\n+    pub fn has_bound_regions(&self) -> bool {\n+        self.substs.has_regions_escaping_depth(0)\n+    }\n }\n \n /// When type checking, we use the `ParameterEnvironment` to track\n@@ -1597,99 +1788,12 @@ pub fn mk_t(cx: &ctxt, st: sty) -> t {\n         _ => ()\n     }\n \n-    let mut flags = NO_TYPE_FLAGS;\n-    fn rflags(r: Region) -> TypeFlags {\n-        HAS_REGIONS | {\n-            match r {\n-              ty::ReInfer(_) => HAS_RE_INFER,\n-              _ => NO_TYPE_FLAGS,\n-            }\n-        }\n-    }\n-    fn sflags(substs: &Substs) -> TypeFlags {\n-        let mut f = NO_TYPE_FLAGS;\n-        let mut i = substs.types.iter();\n-        for tt in i {\n-            f = f | get(*tt).flags;\n-        }\n-        match substs.regions {\n-            subst::ErasedRegions => {}\n-            subst::NonerasedRegions(ref regions) => {\n-                for r in regions.iter() {\n-                    f = f | rflags(*r)\n-                }\n-            }\n-        }\n-        return f;\n-    }\n-    fn flags_for_bounds(bounds: &ExistentialBounds) -> TypeFlags {\n-        rflags(bounds.region_bound)\n-    }\n-    match &st {\n-      &ty_bool | &ty_char | &ty_int(_) | &ty_float(_) | &ty_uint(_) |\n-      &ty_str => {}\n-      // You might think that we could just return ty_err for\n-      // any type containing ty_err as a component, and get\n-      // rid of the HAS_TY_ERR flag -- likewise for ty_bot (with\n-      // the exception of function types that return bot).\n-      // But doing so caused sporadic memory corruption, and\n-      // neither I (tjc) nor nmatsakis could figure out why,\n-      // so we're doing it this way.\n-      &ty_err => flags = flags | HAS_TY_ERR,\n-      &ty_param(ref p) => {\n-          if p.space == subst::SelfSpace {\n-              flags = flags | HAS_SELF;\n-          } else {\n-              flags = flags | HAS_PARAMS;\n-          }\n-      }\n-      &ty_unboxed_closure(_, ref region, ref substs) => {\n-          flags = flags | rflags(*region);\n-          flags = flags | sflags(substs);\n-      }\n-      &ty_infer(_) => flags = flags | HAS_TY_INFER,\n-      &ty_enum(_, ref substs) | &ty_struct(_, ref substs) => {\n-          flags = flags | sflags(substs);\n-      }\n-      &ty_trait(box TyTrait { ref principal, ref bounds }) => {\n-          flags = flags | sflags(&principal.substs);\n-          flags = flags | flags_for_bounds(bounds);\n-      }\n-      &ty_uniq(tt) | &ty_vec(tt, _) | &ty_open(tt) => {\n-        flags = flags | get(tt).flags\n-      }\n-      &ty_ptr(ref m) => {\n-        flags = flags | get(m.ty).flags;\n-      }\n-      &ty_rptr(r, ref m) => {\n-        flags = flags | rflags(r);\n-        flags = flags | get(m.ty).flags;\n-      }\n-      &ty_tup(ref ts) => for tt in ts.iter() { flags = flags | get(*tt).flags; },\n-      &ty_bare_fn(ref f) => {\n-        for a in f.sig.inputs.iter() { flags = flags | get(*a).flags; }\n-        if let ty::FnConverging(output) = f.sig.output {\n-            flags = flags | get(output).flags;\n-        }\n-      }\n-      &ty_closure(ref f) => {\n-        match f.store {\n-            RegionTraitStore(r, _) => {\n-                flags = flags | rflags(r);\n-            }\n-            _ => {}\n-        }\n-        for a in f.sig.inputs.iter() { flags = flags | get(*a).flags; }\n-        if let ty::FnConverging(output) = f.sig.output {\n-            flags = flags | get(output).flags;\n-        }\n-        flags = flags | flags_for_bounds(&f.bounds);\n-      }\n-    }\n+    let flags = FlagComputation::for_sty(&st);\n \n     let t = cx.type_arena.alloc(t_box_ {\n         sty: st,\n-        flags: flags,\n+        flags: flags.flags,\n+        region_depth: flags.depth,\n     });\n \n     let sty_ptr = &t.sty as *const sty;\n@@ -1705,6 +1809,188 @@ pub fn mk_t(cx: &ctxt, st: sty) -> t {\n     }\n }\n \n+struct FlagComputation {\n+    flags: TypeFlags,\n+\n+    // maximum depth of any bound region that we have seen thus far\n+    depth: uint,\n+}\n+\n+impl FlagComputation {\n+    fn new() -> FlagComputation {\n+        FlagComputation { flags: NO_TYPE_FLAGS, depth: 0 }\n+    }\n+\n+    fn for_sty(st: &sty) -> FlagComputation {\n+        let mut result = FlagComputation::new();\n+        result.add_sty(st);\n+        result\n+    }\n+\n+    fn add_flags(&mut self, flags: TypeFlags) {\n+        self.flags = self.flags | flags;\n+    }\n+\n+    fn add_depth(&mut self, depth: uint) {\n+        if depth > self.depth {\n+            self.depth = depth;\n+        }\n+    }\n+\n+    fn add_bound_computation(&mut self, computation: &FlagComputation) {\n+        /*!\n+         * Adds the flags/depth from a set of types that appear within\n+         * the current type, but within a region binder.\n+         */\n+\n+        self.add_flags(computation.flags);\n+\n+        // The types that contributed to `computation` occured within\n+        // a region binder, so subtract one from the region depth\n+        // within when adding the depth to `self`.\n+        let depth = computation.depth;\n+        if depth > 0 {\n+            self.add_depth(depth - 1);\n+        }\n+    }\n+\n+    fn add_sty(&mut self, st: &sty) {\n+        match st {\n+            &ty_bool |\n+            &ty_char |\n+            &ty_int(_) |\n+            &ty_float(_) |\n+            &ty_uint(_) |\n+            &ty_str => {\n+            }\n+\n+            // You might think that we could just return ty_err for\n+            // any type containing ty_err as a component, and get\n+            // rid of the HAS_TY_ERR flag -- likewise for ty_bot (with\n+            // the exception of function types that return bot).\n+            // But doing so caused sporadic memory corruption, and\n+            // neither I (tjc) nor nmatsakis could figure out why,\n+            // so we're doing it this way.\n+            &ty_err => {\n+                self.add_flags(HAS_TY_ERR)\n+            }\n+\n+            &ty_param(ref p) => {\n+                if p.space == subst::SelfSpace {\n+                    self.add_flags(HAS_SELF);\n+                } else {\n+                    self.add_flags(HAS_PARAMS);\n+                }\n+            }\n+\n+            &ty_unboxed_closure(_, ref region, ref substs) => {\n+                self.add_region(*region);\n+                self.add_substs(substs);\n+            }\n+\n+            &ty_infer(_) => {\n+                self.add_flags(HAS_TY_INFER)\n+            }\n+\n+            &ty_enum(_, ref substs) | &ty_struct(_, ref substs) => {\n+                self.add_substs(substs);\n+            }\n+\n+            &ty_trait(box TyTrait { ref principal, ref bounds }) => {\n+                let mut computation = FlagComputation::new();\n+                computation.add_substs(&principal.substs);\n+                self.add_bound_computation(&computation);\n+\n+                self.add_bounds(bounds);\n+            }\n+\n+            &ty_uniq(tt) | &ty_vec(tt, _) | &ty_open(tt) => {\n+                self.add_ty(tt)\n+            }\n+\n+            &ty_ptr(ref m) => {\n+                self.add_ty(m.ty);\n+            }\n+\n+            &ty_rptr(r, ref m) => {\n+                self.add_region(r);\n+                self.add_ty(m.ty);\n+            }\n+\n+            &ty_tup(ref ts) => {\n+                self.add_tys(ts[]);\n+            }\n+\n+            &ty_bare_fn(ref f) => {\n+                self.add_fn_sig(&f.sig);\n+            }\n+\n+            &ty_closure(ref f) => {\n+                match f.store {\n+                    RegionTraitStore(r, _) => {\n+                        self.add_region(r);\n+                    }\n+                    _ => {}\n+                }\n+                self.add_fn_sig(&f.sig);\n+                self.add_bounds(&f.bounds);\n+            }\n+        }\n+    }\n+\n+    fn add_ty(&mut self, t: t) {\n+        let t_box = get(t);\n+        self.add_flags(t_box.flags);\n+        self.add_depth(t_box.region_depth);\n+    }\n+\n+    fn add_tys(&mut self, tys: &[t]) {\n+        for &ty in tys.iter() {\n+            self.add_ty(ty);\n+        }\n+    }\n+\n+    fn add_fn_sig(&mut self, fn_sig: &FnSig) {\n+        let mut computation = FlagComputation::new();\n+\n+        computation.add_tys(fn_sig.inputs[]);\n+\n+        if let ty::FnConverging(output) = fn_sig.output {\n+            computation.add_ty(output);\n+        }\n+\n+        self.add_bound_computation(&computation);\n+    }\n+\n+    fn add_region(&mut self, r: Region) {\n+        self.add_flags(HAS_REGIONS);\n+        match r {\n+            ty::ReInfer(_) => { self.add_flags(HAS_RE_INFER); }\n+            ty::ReLateBound(debruijn, _) => {\n+                self.add_flags(HAS_RE_LATE_BOUND);\n+                self.add_depth(debruijn.depth);\n+            }\n+            _ => { }\n+        }\n+    }\n+\n+    fn add_substs(&mut self, substs: &Substs) {\n+        self.add_tys(substs.types.as_slice());\n+        match substs.regions {\n+            subst::ErasedRegions => {}\n+            subst::NonerasedRegions(ref regions) => {\n+                for &r in regions.iter() {\n+                    self.add_region(r);\n+                }\n+            }\n+        }\n+    }\n+\n+    fn add_bounds(&mut self, bounds: &ExistentialBounds) {\n+        self.add_region(bounds.region_bound);\n+    }\n+}\n+\n #[inline]\n pub fn mk_prim_t(primitive: &'static t_box_) -> t {\n     unsafe {\n@@ -1855,7 +2141,6 @@ pub fn mk_bare_fn(cx: &ctxt, fty: BareFnTy) -> t {\n }\n \n pub fn mk_ctor_fn(cx: &ctxt,\n-                  binder_id: ast::NodeId,\n                   input_tys: &[ty::t],\n                   output: ty::t) -> t {\n     let input_args = input_tys.iter().map(|t| *t).collect();\n@@ -1864,7 +2149,6 @@ pub fn mk_ctor_fn(cx: &ctxt,\n                    fn_style: ast::NormalFn,\n                    abi: abi::Rust,\n                    sig: FnSig {\n-                    binder_id: binder_id,\n                     inputs: input_args,\n                     output: ty::FnConverging(output),\n                     variadic: false\n@@ -4498,9 +4782,99 @@ pub fn bounds_for_trait_ref(tcx: &ctxt,\n                             -> ty::ParamBounds\n {\n     let trait_def = lookup_trait_def(tcx, trait_ref.def_id);\n+\n     debug!(\"bounds_for_trait_ref(trait_def={}, trait_ref={})\",\n            trait_def.repr(tcx), trait_ref.repr(tcx));\n-    trait_def.bounds.subst(tcx, &trait_ref.substs)\n+\n+    // The interaction between HRTB and supertraits is not entirely\n+    // obvious. Let me walk you (and myself) through an example.\n+    //\n+    // Let's start with an easy case. Consider two traits:\n+    //\n+    //     trait Foo<'a> : Bar<'a,'a> { }\n+    //     trait Bar<'b,'c> { }\n+    //\n+    // Now, if we have a trait reference `for<'x> T : Foo<'x>`, then\n+    // we can deduce that `for<'x> T : Bar<'x,'x>`. Basically, if we\n+    // knew that `Foo<'x>` (for any 'x) then we also know that\n+    // `Bar<'x,'x>` (for any 'x). This more-or-less falls out from\n+    // normal substitution.\n+    //\n+    // In terms of why this is sound, the idea is that whenever there\n+    // is an impl of `T:Foo<'a>`, it must show that `T:Bar<'a,'a>`\n+    // holds.  So if there is an impl of `T:Foo<'a>` that applies to\n+    // all `'a`, then we must know that `T:Bar<'a,'a>` holds for all\n+    // `'a`.\n+    //\n+    // Another example to be careful of is this:\n+    //\n+    //     trait Foo1<'a> : for<'b> Bar1<'a,'b> { }\n+    //     trait Bar1<'b,'c> { }\n+    //\n+    // Here, if we have `for<'x> T : Foo1<'x>`, then what do we know?\n+    // The answer is that we know `for<'x,'b> T : Bar1<'x,'b>`. The\n+    // reason is similar to the previous example: any impl of\n+    // `T:Foo1<'x>` must show that `for<'b> T : Bar1<'x, 'b>`.  So\n+    // basically we would want to collapse the bound lifetimes from\n+    // the input (`trait_ref`) and the supertraits.\n+    //\n+    // To achieve this in practice is fairly straightforward. Let's\n+    // consider the more complicated scenario:\n+    //\n+    // - We start out with `for<'x> T : Foo1<'x>`. In this case, `'x`\n+    //   has a De Bruijn index of 1. We want to produce `for<'x,'b> T : Bar1<'x,'b>`,\n+    //   where both `'x` and `'b` would have a DB index of 1.\n+    //   The substitution from the input trait-ref is therefore going to be\n+    //   `'a => 'x` (where `'x` has a DB index of 1).\n+    // - The super-trait-ref is `for<'b> Bar1<'a,'b>`, where `'a` is an\n+    //   early-bound parameter and `'b' is a late-bound parameter with a\n+    //   DB index of 1.\n+    // - If we replace `'a` with `'x` from the input, it too will have\n+    //   a DB index of 1, and thus we'll have `for<'x,'b> Bar1<'x,'b>`\n+    //   just as we wanted.\n+    //\n+    // There is only one catch. If we just apply the substitution `'a\n+    // => 'x` to `for<'b> Bar1<'a,'b>`, the substitution code will\n+    // adjust the DB index because we substituting into a binder (it\n+    // tries to be so smart...) resulting in `for<'x> for<'b>\n+    // Bar1<'x,'b>` (we have no syntax for this, so use your\n+    // imagination). Basically the 'x will have DB index of 2 and 'b\n+    // will have DB index of 1. Not quite what we want. So we apply\n+    // the substitution to the *contents* of the trait reference,\n+    // rather than the trait reference itself (put another way, the\n+    // substitution code expects equal binding levels in the values\n+    // from the substitution and the value being substituted into, and\n+    // this trick achieves that).\n+\n+    // Carefully avoid the binder introduced by each trait-ref by\n+    // substituting over the substs, not the trait-refs themselves,\n+    // thus achieving the \"collapse\" described in the big comment\n+    // above.\n+    let trait_bounds: Vec<_> =\n+        trait_def.bounds.trait_bounds\n+        .iter()\n+        .map(|bound_trait_ref| {\n+            ty::TraitRef::new(bound_trait_ref.def_id,\n+                              bound_trait_ref.substs.subst(tcx, &trait_ref.substs))\n+        })\n+        .map(|bound_trait_ref| Rc::new(bound_trait_ref))\n+        .collect();\n+\n+    debug!(\"bounds_for_trait_ref: trait_bounds={}\",\n+           trait_bounds.repr(tcx));\n+\n+    // The region bounds and builtin bounds do not currently introduce\n+    // binders so we can just substitute in a straightforward way here.\n+    let region_bounds =\n+        trait_def.bounds.region_bounds.subst(tcx, &trait_ref.substs);\n+    let builtin_bounds =\n+        trait_def.bounds.builtin_bounds.subst(tcx, &trait_ref.substs);\n+\n+    ty::ParamBounds {\n+        trait_bounds: trait_bounds,\n+        region_bounds: region_bounds,\n+        builtin_bounds: builtin_bounds,\n+    }\n }\n \n /// Iterate over attributes of a definition.\n@@ -4783,13 +5157,12 @@ pub fn normalize_ty(cx: &ctxt, t: t) -> t {\n                             types: substs.types.fold_with(self) }\n         }\n \n-        fn fold_sig(&mut self,\n-                    sig: &ty::FnSig)\n-                    -> ty::FnSig {\n+        fn fold_fn_sig(&mut self,\n+                       sig: &ty::FnSig)\n+                       -> ty::FnSig {\n             // The binder-id is only relevant to bound regions, which\n             // are erased at trans time.\n             ty::FnSig {\n-                binder_id: ast::DUMMY_NODE_ID,\n                 inputs: sig.inputs.fold_with(self),\n                 output: sig.output.fold_with(self),\n                 variadic: sig.variadic,\n@@ -5305,11 +5678,13 @@ pub fn construct_parameter_environment(\n     // Compute the bounds on Self and the type parameters.\n     //\n \n-    let mut bounds = VecPerParamSpace::empty();\n-    for &space in subst::ParamSpace::all().iter() {\n-        push_bounds_from_defs(tcx, &mut bounds, space, &free_substs,\n-                              generics.types.get_slice(space));\n-    }\n+    let bounds = generics.to_bounds(tcx, &free_substs);\n+    let bounds = liberate_late_bound_regions(tcx, free_id, &bind(bounds)).value;\n+    let obligations = traits::obligations_for_generics(tcx,\n+                                                       traits::ObligationCause::misc(span),\n+                                                       &bounds,\n+                                                       &free_substs.types);\n+    let type_bounds = bounds.types.subst(tcx, &free_substs);\n \n     //\n     // Compute region bounds. For now, these relations are stored in a\n@@ -5318,24 +5693,20 @@ pub fn construct_parameter_environment(\n     //\n \n     for &space in subst::ParamSpace::all().iter() {\n-        record_region_bounds_from_defs(tcx, space, &free_substs,\n-                                       generics.regions.get_slice(space));\n+        record_region_bounds(tcx, space, &free_substs, bounds.regions.get_slice(space));\n     }\n \n \n-    debug!(\"construct_parameter_environment: free_id={} \\\n-           free_subst={} \\\n-           bounds={}\",\n+    debug!(\"construct_parameter_environment: free_id={} free_subst={} \\\n+           obligations={} type_bounds={}\",\n            free_id,\n            free_substs.repr(tcx),\n-           bounds.repr(tcx));\n-\n-    let obligations = traits::obligations_for_generics(tcx, traits::ObligationCause::misc(span),\n-                                                       generics, &free_substs);\n+           obligations.repr(tcx),\n+           type_bounds.repr(tcx));\n \n     return ty::ParameterEnvironment {\n         free_substs: free_substs,\n-        bounds: bounds,\n+        bounds: bounds.types,\n         implicit_region_bound: ty::ReScope(free_id),\n         caller_obligations: obligations,\n         selection_cache: traits::SelectionCache::new(),\n@@ -5366,28 +5737,16 @@ pub fn construct_parameter_environment(\n         }\n     }\n \n-    fn push_bounds_from_defs(tcx: &ty::ctxt,\n-                             bounds: &mut subst::VecPerParamSpace<ParamBounds>,\n-                             space: subst::ParamSpace,\n-                             free_substs: &subst::Substs,\n-                             defs: &[TypeParameterDef]) {\n-        for def in defs.iter() {\n-            let b = def.bounds.subst(tcx, free_substs);\n-            bounds.push(space, b);\n-        }\n-    }\n-\n-    fn record_region_bounds_from_defs(tcx: &ty::ctxt,\n-                                      space: subst::ParamSpace,\n-                                      free_substs: &subst::Substs,\n-                                      defs: &[RegionParameterDef]) {\n-        for (subst_region, def) in\n+    fn record_region_bounds(tcx: &ty::ctxt,\n+                            space: subst::ParamSpace,\n+                            free_substs: &Substs,\n+                            bound_sets: &[Vec<ty::Region>]) {\n+        for (subst_region, bound_set) in\n             free_substs.regions().get_slice(space).iter().zip(\n-                defs.iter())\n+                bound_sets.iter())\n         {\n             // For each region parameter 'subst...\n-            let bounds = def.bounds.subst(tcx, free_substs);\n-            for bound_region in bounds.iter() {\n+            for bound_region in bound_set.iter() {\n                 // Which is declared with a bound like 'subst:'bound...\n                 match (subst_region, bound_region) {\n                     (&ty::ReFree(subst_fr), &ty::ReFree(bound_fr)) => {\n@@ -5398,7 +5757,7 @@ pub fn construct_parameter_environment(\n                     _ => {\n                         // All named regions are instantiated with free regions.\n                         tcx.sess.bug(\n-                            format!(\"push_region_bounds_from_defs: \\\n+                            format!(\"record_region_bounds: \\\n                                      non free region: {} / {}\",\n                                     subst_region.repr(tcx),\n                                     bound_region.repr(tcx)).as_slice());\n@@ -5589,3 +5948,86 @@ impl AutoDerefRef {\n         self.autoderefs == 0 && self.autoref.is_none()\n     }\n }\n+\n+pub fn liberate_late_bound_regions<HR>(\n+    tcx: &ty::ctxt,\n+    scope_id: ast::NodeId,\n+    value: &HR)\n+    -> HR\n+    where HR : HigherRankedFoldable\n+{\n+    /*!\n+     * Replace any late-bound regions bound in `value` with free variants\n+     * attached to scope-id `scope_id`.\n+     */\n+\n+    replace_late_bound_regions(\n+        tcx, value,\n+        |br, _| ty::ReFree(ty::FreeRegion{scope_id: scope_id, bound_region: br})).0\n+}\n+\n+pub fn erase_late_bound_regions<HR>(\n+    tcx: &ty::ctxt,\n+    value: &HR)\n+    -> HR\n+    where HR : HigherRankedFoldable\n+{\n+    /*!\n+     * Replace any late-bound regions bound in `value` with `'static`.\n+     * Useful in trans but also method lookup and a few other places\n+     * where precise region relationships are not required.\n+     */\n+\n+    replace_late_bound_regions(tcx, value, |_, _| ty::ReStatic).0\n+}\n+\n+pub fn replace_late_bound_regions<HR>(\n+    tcx: &ty::ctxt,\n+    value: &HR,\n+    mapf: |BoundRegion, DebruijnIndex| -> ty::Region)\n+    -> (HR, FnvHashMap<ty::BoundRegion,ty::Region>)\n+    where HR : HigherRankedFoldable\n+{\n+    /*!\n+     * Replaces the late-bound-regions in `value` that are bound by `value`.\n+     */\n+\n+    debug!(\"replace_late_bound_regions({})\", value.repr(tcx));\n+\n+    let mut map = FnvHashMap::new();\n+    let value = {\n+        let mut f = ty_fold::RegionFolder::new(tcx, |region, current_depth| {\n+            debug!(\"region={}\", region.repr(tcx));\n+            match region {\n+                ty::ReLateBound(debruijn, br) if debruijn.depth == current_depth => {\n+                    * match map.entry(br) {\n+                        Vacant(entry) => entry.set(mapf(br, debruijn)),\n+                        Occupied(entry) => entry.into_mut(),\n+                    }\n+                }\n+                _ => {\n+                    region\n+                }\n+            }\n+        });\n+\n+        // Note: use `fold_contents` not `fold_with`. If we used\n+        // `fold_with`, it would consider the late-bound regions bound\n+        // by `value` to be bound, but we want to consider them as\n+        // `free`.\n+        value.fold_contents(&mut f)\n+    };\n+    debug!(\"resulting map: {} value: {}\", map, value.repr(tcx));\n+    (value, map)\n+}\n+\n+impl DebruijnIndex {\n+    pub fn new(depth: uint) -> DebruijnIndex {\n+        assert!(depth > 0);\n+        DebruijnIndex { depth: depth }\n+    }\n+\n+    pub fn shifted(&self, amount: uint) -> DebruijnIndex {\n+        DebruijnIndex { depth: self.depth + amount }\n+    }\n+}"}, {"sha": "4dfee673bca16c24d70446e4cf5c261de28a15da", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 167, "deletions": 61, "changes": 228, "blob_url": "https://github.com/rust-lang/rust/blob/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=c8d6e3b2c2a780eff92299da5d1c02e081617088", "patch": "@@ -42,7 +42,6 @@ use middle::ty;\n use middle::traits;\n use middle::typeck;\n use std::rc::Rc;\n-use syntax::ast;\n use syntax::owned_slice::OwnedSlice;\n use util::ppaux::Repr;\n \n@@ -63,6 +62,17 @@ pub trait TypeFoldable {\n pub trait TypeFolder<'tcx> {\n     fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx>;\n \n+    /// Invoked by the `super_*` routines when we enter a region\n+    /// binding level (for example, when entering a function\n+    /// signature). This is used by clients that want to track the\n+    /// Debruijn index nesting level.\n+    fn enter_region_binder(&mut self) { }\n+\n+    /// Invoked by the `super_*` routines when we exit a region\n+    /// binding level. This is used by clients that want to\n+    /// track the Debruijn index nesting level.\n+    fn exit_region_binder(&mut self) { }\n+\n     fn fold_ty(&mut self, t: ty::t) -> ty::t {\n         super_fold_ty(self, t)\n     }\n@@ -85,10 +95,10 @@ pub trait TypeFolder<'tcx> {\n         super_fold_substs(self, substs)\n     }\n \n-    fn fold_sig(&mut self,\n+    fn fold_fn_sig(&mut self,\n                 sig: &ty::FnSig)\n                 -> ty::FnSig {\n-        super_fold_sig(self, sig)\n+        super_fold_fn_sig(self, sig)\n     }\n \n     fn fold_output(&mut self,\n@@ -153,6 +163,12 @@ impl TypeFoldable for () {\n     }\n }\n \n+impl<T:TypeFoldable,U:TypeFoldable> TypeFoldable for (T, U) {\n+    fn fold_with<'tcx, F:TypeFolder<'tcx>>(&self, folder: &mut F) -> (T, U) {\n+        (self.0.fold_with(folder), self.1.fold_with(folder))\n+    }\n+}\n+\n impl<T:TypeFoldable> TypeFoldable for Option<T> {\n     fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Option<T> {\n         self.as_ref().map(|t| t.fold_with(folder))\n@@ -171,6 +187,15 @@ impl<T:TypeFoldable> TypeFoldable for Vec<T> {\n     }\n }\n \n+impl<T:TypeFoldable> TypeFoldable for ty::Binder<T> {\n+    fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::Binder<T> {\n+        folder.enter_region_binder();\n+        let result = ty::bind(self.value.fold_with(folder));\n+        folder.exit_region_binder();\n+        result\n+    }\n+}\n+\n impl<T:TypeFoldable> TypeFoldable for OwnedSlice<T> {\n     fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> OwnedSlice<T> {\n         self.iter().map(|t| t.fold_with(folder)).collect()\n@@ -179,7 +204,24 @@ impl<T:TypeFoldable> TypeFoldable for OwnedSlice<T> {\n \n impl<T:TypeFoldable> TypeFoldable for VecPerParamSpace<T> {\n     fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> VecPerParamSpace<T> {\n-        self.map(|t| t.fold_with(folder))\n+\n+        // Things in the Fn space take place under an additional level\n+        // of region binding relative to the other spaces. This is\n+        // because those entries are attached to a method, and methods\n+        // always introduce a level of region binding.\n+\n+        let result = self.map_enumerated(|(space, index, elem)| {\n+            if space == subst::FnSpace && index == 0 {\n+                // enter new level when/if we reach the first thing in fn space\n+                folder.enter_region_binder();\n+            }\n+            elem.fold_with(folder)\n+        });\n+        if result.len(subst::FnSpace) > 0 {\n+            // if there was anything in fn space, exit the region binding level\n+            folder.exit_region_binder();\n+        }\n+        result\n     }\n }\n \n@@ -221,7 +263,7 @@ impl TypeFoldable for ty::FnOutput {\n \n impl TypeFoldable for ty::FnSig {\n     fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::FnSig {\n-        folder.fold_sig(self)\n+        folder.fold_fn_sig(self)\n     }\n }\n \n@@ -368,6 +410,15 @@ impl TypeFoldable for ty::Generics {\n     }\n }\n \n+impl TypeFoldable for ty::GenericBounds {\n+    fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::GenericBounds {\n+        ty::GenericBounds {\n+            types: self.types.fold_with(folder),\n+            regions: self.regions.fold_with(folder),\n+        }\n+    }\n+}\n+\n impl TypeFoldable for ty::UnsizeKind {\n     fn fold_with<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::UnsizeKind {\n         match *self {\n@@ -434,6 +485,7 @@ impl TypeFoldable for traits::VtableParamData {\n // \"super\" routines: these are the default implementations for TypeFolder.\n //\n // They should invoke `foo.fold_with()` to do recursive folding.\n+\n pub fn super_fold_ty<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n                                                 t: ty::t)\n                                                 -> ty::t {\n@@ -457,11 +509,21 @@ pub fn super_fold_substs<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n                     types: substs.types.fold_with(this) }\n }\n \n-pub fn super_fold_sig<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n-                                                 sig: &ty::FnSig)\n-                                                 -> ty::FnSig {\n-    ty::FnSig { binder_id: sig.binder_id,\n-                inputs: sig.inputs.fold_with(this),\n+pub fn super_fold_fn_sig<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n+                                                    sig: &ty::FnSig)\n+                                                    -> ty::FnSig\n+{\n+    this.enter_region_binder();\n+    let result = super_fold_fn_sig_contents(this, sig);\n+    this.exit_region_binder();\n+    result\n+}\n+\n+pub fn super_fold_fn_sig_contents<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n+                                                             sig: &ty::FnSig)\n+                                                             -> ty::FnSig\n+{\n+    ty::FnSig { inputs: sig.inputs.fold_with(this),\n                 output: sig.output.fold_with(this),\n                 variadic: sig.variadic }\n }\n@@ -497,9 +559,21 @@ pub fn super_fold_closure_ty<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n         abi: fty.abi,\n     }\n }\n+\n pub fn super_fold_trait_ref<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n                                                        t: &ty::TraitRef)\n-                                                       -> ty::TraitRef {\n+                                                       -> ty::TraitRef\n+{\n+    this.enter_region_binder();\n+    let result = super_fold_trait_ref_contents(this, t);\n+    this.exit_region_binder();\n+    result\n+}\n+\n+pub fn super_fold_trait_ref_contents<'tcx, T: TypeFolder<'tcx>>(this: &mut T,\n+                                                                t: &ty::TraitRef)\n+                                                                -> ty::TraitRef\n+{\n     ty::TraitRef {\n         def_id: t.def_id,\n         substs: t.substs.fold_with(this),\n@@ -621,6 +695,42 @@ pub fn super_fold_obligation<'tcx, T:TypeFolder<'tcx>>(this: &mut T,\n     }\n }\n \n+///////////////////////////////////////////////////////////////////////////\n+// Higher-ranked things\n+\n+/**\n+ * Designates a \"binder\" for late-bound regions.\n+ */\n+pub trait HigherRankedFoldable : Repr {\n+    /// Folds the contents of `self`, ignoring the region binder created\n+    /// by `self`.\n+    fn fold_contents<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self;\n+}\n+\n+impl HigherRankedFoldable for ty::FnSig {\n+    fn fold_contents<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::FnSig {\n+        super_fold_fn_sig_contents(folder, self)\n+    }\n+}\n+\n+impl HigherRankedFoldable for ty::TraitRef {\n+    fn fold_contents<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::TraitRef {\n+        super_fold_trait_ref_contents(folder, self)\n+    }\n+}\n+\n+impl<T:TypeFoldable+Repr> HigherRankedFoldable for ty::Binder<T> {\n+    fn fold_contents<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::Binder<T> {\n+        ty::bind(self.value.fold_with(folder))\n+    }\n+}\n+\n+impl<T:HigherRankedFoldable> HigherRankedFoldable for Rc<T> {\n+    fn fold_contents<'tcx, F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Rc<T> {\n+        Rc::new((**self).fold_contents(folder))\n+    }\n+}\n+\n ///////////////////////////////////////////////////////////////////////////\n // Some sample folders\n \n@@ -655,77 +765,43 @@ impl<'a, 'tcx> TypeFolder<'tcx> for BottomUpFolder<'a, 'tcx> {\n /// current position of the fold.)\n pub struct RegionFolder<'a, 'tcx: 'a> {\n     tcx: &'a ty::ctxt<'tcx>,\n-    fld_t: |ty::t|: 'a -> ty::t,\n-    fld_r: |ty::Region|: 'a -> ty::Region,\n-    within_binder_ids: Vec<ast::NodeId>,\n+    current_depth: uint,\n+    fld_r: |ty::Region, uint|: 'a -> ty::Region,\n }\n \n impl<'a, 'tcx> RegionFolder<'a, 'tcx> {\n-    pub fn general(tcx: &'a ty::ctxt<'tcx>,\n-                   fld_r: |ty::Region|: 'a -> ty::Region,\n-                   fld_t: |ty::t|: 'a -> ty::t)\n-                   -> RegionFolder<'a, 'tcx> {\n+    pub fn new(tcx: &'a ty::ctxt<'tcx>, fld_r: |ty::Region, uint|: 'a -> ty::Region)\n+               -> RegionFolder<'a, 'tcx> {\n         RegionFolder {\n             tcx: tcx,\n-            fld_t: fld_t,\n+            current_depth: 1,\n             fld_r: fld_r,\n-            within_binder_ids: vec![],\n-        }\n-    }\n-\n-    pub fn regions(tcx: &'a ty::ctxt<'tcx>, fld_r: |ty::Region|: 'a -> ty::Region)\n-                   -> RegionFolder<'a, 'tcx> {\n-        fn noop(t: ty::t) -> ty::t { t }\n-\n-        RegionFolder {\n-            tcx: tcx,\n-            fld_t: noop,\n-            fld_r: fld_r,\n-            within_binder_ids: vec![],\n         }\n     }\n }\n \n-/// If `ty` has `FnSig` (i.e. closure or fn), return its binder_id;\n-/// else None.\n-fn opt_binder_id_of_function(t: ty::t) -> Option<ast::NodeId> {\n-    match ty::get(t).sty {\n-        ty::ty_closure(ref f) => Some(f.sig.binder_id),\n-        ty::ty_bare_fn(ref f) => Some(f.sig.binder_id),\n-        _                     => None,\n-    }\n-}\n-\n impl<'a, 'tcx> TypeFolder<'tcx> for RegionFolder<'a, 'tcx> {\n     fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx> { self.tcx }\n \n-    fn fold_ty(&mut self, ty: ty::t) -> ty::t {\n-        debug!(\"RegionFolder.fold_ty({})\", ty.repr(self.tcx()));\n-        let opt_binder_id = opt_binder_id_of_function(ty);\n-        match opt_binder_id {\n-            Some(binder_id) => self.within_binder_ids.push(binder_id),\n-            None => {}\n-        }\n-\n-        let t1 = super_fold_ty(self, ty);\n-        let ret = (self.fld_t)(t1);\n-\n-        if opt_binder_id.is_some() {\n-            self.within_binder_ids.pop();\n-        }\n+    fn enter_region_binder(&mut self) {\n+        self.current_depth += 1;\n+    }\n \n-        ret\n+    fn exit_region_binder(&mut self) {\n+        self.current_depth -= 1;\n     }\n \n     fn fold_region(&mut self, r: ty::Region) -> ty::Region {\n         match r {\n-            ty::ReLateBound(binder_id, _) if self.within_binder_ids.contains(&binder_id) => {\n-                debug!(\"RegionFolder.fold_region({}) skipped bound region\", r.repr(self.tcx()));\n+            ty::ReLateBound(debruijn, _) if debruijn.depth < self.current_depth => {\n+                debug!(\"RegionFolder.fold_region({}) skipped bound region (current depth={})\",\n+                       r.repr(self.tcx()), self.current_depth);\n                 r\n             }\n             _ => {\n-                debug!(\"RegionFolder.fold_region({}) folding free region\", r.repr(self.tcx()));\n-                (self.fld_r)(r)\n+                debug!(\"RegionFolder.fold_region({}) folding free region (current_depth={})\",\n+                       r.repr(self.tcx()), self.current_depth);\n+                (self.fld_r)(r, self.current_depth)\n             }\n         }\n     }\n@@ -755,3 +831,33 @@ impl<'a, 'tcx> TypeFolder<'tcx> for RegionEraser<'a, 'tcx> {\n         }\n     }\n }\n+\n+///////////////////////////////////////////////////////////////////////////\n+// Region shifter\n+//\n+// Shifts the De Bruijn indices on all escaping bound regions by a\n+// fixed amount. Useful in substitution or when otherwise introducing\n+// a binding level that is not intended to capture the existing bound\n+// regions. See comment on `shift_regions_through_binders` method in\n+// `subst.rs` for more details.\n+\n+pub fn shift_region(region: ty::Region, amount: uint) -> ty::Region {\n+    match region {\n+        ty::ReLateBound(debruijn, br) => {\n+            ty::ReLateBound(debruijn.shifted(amount), br)\n+        }\n+        _ => {\n+            region\n+        }\n+    }\n+}\n+\n+pub fn shift_regions<T:TypeFoldable+Repr>(tcx: &ty::ctxt, amount: uint, value: &T) -> T {\n+    debug!(\"shift_regions(value={}, amount={})\",\n+           value.repr(tcx), amount);\n+\n+    value.fold_with(&mut RegionFolder::new(tcx, |region, _current_depth| {\n+        shift_region(region, amount)\n+    }))\n+}\n+"}, {"sha": "68677492649615936600652419b19e1af03cc29e", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 281, "deletions": 206, "changes": 487, "blob_url": "https://github.com/rust-lang/rust/blob/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=c8d6e3b2c2a780eff92299da5d1c02e081617088", "patch": "@@ -55,11 +55,10 @@ use middle::subst::{FnSpace, TypeSpace, AssocSpace, SelfSpace, Subst, Substs};\n use middle::subst::{VecPerParamSpace};\n use middle::ty;\n use middle::typeck::lookup_def_tcx;\n-use middle::typeck::infer;\n-use middle::typeck::rscope::{UnelidableRscope, RegionScope, SpecificRscope, BindingRscope};\n+use middle::typeck::rscope::{UnelidableRscope, RegionScope, SpecificRscope,\n+                             ShiftedRscope, BindingRscope};\n use middle::typeck::rscope;\n use middle::typeck::TypeAndSubsts;\n-use middle::typeck;\n use util::nodemap::DefIdMap;\n use util::ppaux::{Repr, UserString};\n \n@@ -106,9 +105,8 @@ pub fn ast_region_to_region(tcx: &ty::ctxt, lifetime: &ast::Lifetime)\n             ty::ReStatic\n         }\n \n-        Some(&rl::DefLateBoundRegion(binder_id, _, id)) => {\n-            ty::ReLateBound(binder_id, ty::BrNamed(ast_util::local_def(id),\n-                                                   lifetime.name))\n+        Some(&rl::DefLateBoundRegion(debruijn, id)) => {\n+            ty::ReLateBound(debruijn, ty::BrNamed(ast_util::local_def(id), lifetime.name))\n         }\n \n         Some(&rl::DefEarlyBoundRegion(space, index, id)) => {\n@@ -203,15 +201,14 @@ pub fn opt_ast_region_to_region<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n     r\n }\n \n-fn ast_path_substs<'tcx,AC,RS>(\n+fn ast_path_substs_for_ty<'tcx,AC,RS>(\n     this: &AC,\n     rscope: &RS,\n     decl_def_id: ast::DefId,\n     decl_generics: &ty::Generics,\n     self_ty: Option<ty::t>,\n     associated_ty: Option<ty::t>,\n-    path: &ast::Path,\n-    binder_id: ast::NodeId)\n+    path: &ast::Path)\n     -> Substs\n     where AC: AstConv<'tcx>, RS: RegionScope\n {\n@@ -235,12 +232,35 @@ fn ast_path_substs<'tcx,AC,RS>(\n     assert!(decl_generics.types.all(|d| d.space != FnSpace));\n \n     let (regions, types) = match path.segments.last().unwrap().parameters {\n-        ast::AngleBracketedParameters(ref data) =>\n-            angle_bracketed_parameters(this, rscope, data),\n-        ast::ParenthesizedParameters(ref data) =>\n-            parenthesized_parameters(this, binder_id, data),\n+        ast::AngleBracketedParameters(ref data) => {\n+            convert_angle_bracketed_parameters(this, rscope, data)\n+        }\n+        ast::ParenthesizedParameters(ref data) => {\n+            span_err!(tcx.sess, path.span, E0169,\n+                      \"parenthesized parameters may only be used with a trait\");\n+            (Vec::new(), convert_parenthesized_parameters(this, data))\n+        }\n     };\n \n+    create_substs_for_ast_path(this, rscope, path.span, decl_def_id,\n+                               decl_generics, self_ty, types, regions, associated_ty)\n+}\n+\n+fn create_substs_for_ast_path<'tcx,AC,RS>(\n+    this: &AC,\n+    rscope: &RS,\n+    span: Span,\n+    decl_def_id: ast::DefId,\n+    decl_generics: &ty::Generics,\n+    self_ty: Option<ty::t>,\n+    types: Vec<ty::t>,\n+    regions: Vec<ty::Region>,\n+    associated_ty: Option<ty::t>)\n+    -> Substs\n+    where AC: AstConv<'tcx>, RS: RegionScope\n+{\n+    let tcx = this.tcx();\n+\n     // If the type is parameterized by the this region, then replace this\n     // region with the current anon region binding (in other words,\n     // whatever & would get replaced with).\n@@ -250,10 +270,10 @@ fn ast_path_substs<'tcx,AC,RS>(\n         regions\n     } else {\n         let anon_regions =\n-            rscope.anon_regions(path.span, expected_num_region_params);\n+            rscope.anon_regions(span, expected_num_region_params);\n \n         if supplied_num_region_params != 0 || anon_regions.is_err() {\n-            span_err!(tcx.sess, path.span, E0107,\n+            span_err!(tcx.sess, span, E0107,\n                       \"wrong number of lifetime parameters: expected {}, found {}\",\n                       expected_num_region_params, supplied_num_region_params);\n         }\n@@ -285,7 +305,7 @@ fn ast_path_substs<'tcx,AC,RS>(\n         } else {\n             \"expected\"\n         };\n-        this.tcx().sess.span_fatal(path.span,\n+        this.tcx().sess.span_fatal(span,\n                                    format!(\"wrong number of type arguments: {} {}, found {}\",\n                                            expected,\n                                            required_ty_param_count,\n@@ -296,7 +316,7 @@ fn ast_path_substs<'tcx,AC,RS>(\n         } else {\n             \"expected\"\n         };\n-        this.tcx().sess.span_fatal(path.span,\n+        this.tcx().sess.span_fatal(span,\n                                    format!(\"wrong number of type arguments: {} {}, found {}\",\n                                            expected,\n                                            formal_ty_param_count,\n@@ -305,9 +325,9 @@ fn ast_path_substs<'tcx,AC,RS>(\n \n     if supplied_ty_param_count > required_ty_param_count\n         && !this.tcx().sess.features.borrow().default_type_params {\n-        span_err!(this.tcx().sess, path.span, E0108,\n+        span_err!(this.tcx().sess, span, E0108,\n             \"default type parameters are experimental and possibly buggy\");\n-        span_help!(this.tcx().sess, path.span,\n+        span_help!(this.tcx().sess, span,\n             \"add #![feature(default_type_params)] to the crate attributes to enable\");\n     }\n \n@@ -333,66 +353,76 @@ fn ast_path_substs<'tcx,AC,RS>(\n                 // This is a default type parameter.\n                 let default = default.subst_spanned(tcx,\n                                                     &substs,\n-                                                    Some(path.span));\n+                                                    Some(span));\n                 substs.types.push(TypeSpace, default);\n             }\n             None => {\n-                tcx.sess.span_bug(path.span,\n-                                  \"extra parameter without default\");\n+                tcx.sess.span_bug(span, \"extra parameter without default\");\n             }\n         }\n     }\n \n     for param in decl_generics.types.get_slice(AssocSpace).iter() {\n         substs.types.push(\n             AssocSpace,\n-            this.associated_type_binding(path.span,\n+            this.associated_type_binding(span,\n                                          associated_ty,\n                                          decl_def_id,\n                                          param.def_id))\n     }\n \n     return substs;\n+}\n \n-    fn angle_bracketed_parameters<'tcx, AC, RS>(this: &AC,\n-                                                rscope: &RS,\n-                                                data: &ast::AngleBracketedParameterData)\n-                                                -> (Vec<ty::Region>, Vec<ty::t>)\n-        where AC: AstConv<'tcx>, RS: RegionScope\n-    {\n-        let regions: Vec<_> =\n-            data.lifetimes.iter()\n-            .map(|l| ast_region_to_region(this.tcx(), l))\n-            .collect();\n-\n-        let types: Vec<_> =\n-            data.types.iter()\n-            .map(|t| ast_ty_to_ty(this, rscope, &**t))\n-            .collect();\n-\n-        (regions, types)\n-    }\n+fn convert_angle_bracketed_parameters<'tcx, AC, RS>(this: &AC,\n+                                                    rscope: &RS,\n+                                                    data: &ast::AngleBracketedParameterData)\n+                                                    -> (Vec<ty::Region>, Vec<ty::t>)\n+    where AC: AstConv<'tcx>, RS: RegionScope\n+{\n+    let regions: Vec<_> =\n+        data.lifetimes.iter()\n+        .map(|l| ast_region_to_region(this.tcx(), l))\n+        .collect();\n \n-    fn parenthesized_parameters<'tcx,AC>(this: &AC,\n-                                         binder_id: ast::NodeId,\n-                                         data: &ast::ParenthesizedParameterData)\n-                                         -> (Vec<ty::Region>, Vec<ty::t>)\n-        where AC: AstConv<'tcx>\n-    {\n-        let binding_rscope = BindingRscope::new(binder_id);\n-\n-        let inputs = data.inputs.iter()\n-                                .map(|a_t| ast_ty_to_ty(this, &binding_rscope, &**a_t))\n-                                .collect();\n-        let input_ty = ty::mk_tup(this.tcx(), inputs);\n-\n-        let output = match data.output {\n-            Some(ref output_ty) => ast_ty_to_ty(this, &binding_rscope, &**output_ty),\n-            None => ty::mk_nil(this.tcx())\n-        };\n+    let types: Vec<_> =\n+        data.types.iter()\n+        .map(|t| ast_ty_to_ty(this, rscope, &**t))\n+        .collect();\n \n-        (Vec::new(), vec![input_ty, output])\n-    }\n+    (regions, types)\n+}\n+\n+fn convert_parenthesized_parameters<'tcx,AC>(this: &AC,\n+                                             data: &ast::ParenthesizedParameterData)\n+                                             -> Vec<ty::t>\n+    where AC: AstConv<'tcx>\n+{\n+    let binding_rscope = BindingRscope::new();\n+\n+    let inputs = data.inputs.iter()\n+                            .map(|a_t| ast_ty_to_ty(this, &binding_rscope, &**a_t))\n+                            .collect();\n+    let input_ty = ty::mk_tup(this.tcx(), inputs);\n+\n+    let output = match data.output {\n+        Some(ref output_ty) => ast_ty_to_ty(this, &binding_rscope, &**output_ty),\n+        None => ty::mk_nil(this.tcx()),\n+    };\n+\n+    vec![input_ty, output]\n+}\n+\n+pub fn instantiate_poly_trait_ref<'tcx,AC,RS>(\n+    this: &AC,\n+    rscope: &RS,\n+    ast_trait_ref: &ast::PolyTraitRef,\n+    self_ty: Option<ty::t>,\n+    associated_type: Option<ty::t>)\n+    -> Rc<ty::TraitRef>\n+    where AC: AstConv<'tcx>, RS: RegionScope\n+{\n+    instantiate_trait_ref(this, rscope, &ast_trait_ref.trait_ref, self_ty, associated_type)\n }\n \n pub fn instantiate_trait_ref<'tcx,AC,RS>(this: &AC,\n@@ -413,16 +443,9 @@ pub fn instantiate_trait_ref<'tcx,AC,RS>(this: &AC,\n     match lookup_def_tcx(this.tcx(),\n                          ast_trait_ref.path.span,\n                          ast_trait_ref.ref_id) {\n-        def::DefTrait(trait_did) => {\n-            let trait_ref =\n-                Rc::new(ast_path_to_trait_ref(this,\n-                                              rscope,\n-                                              trait_did,\n-                                              self_ty,\n-                                              associated_type,\n-                                              &ast_trait_ref.path,\n-                                              ast_trait_ref.ref_id));\n-\n+        def::DefTrait(trait_def_id) => {\n+            let trait_ref = Rc::new(ast_path_to_trait_ref(this, rscope, trait_def_id, self_ty,\n+                                                          associated_type, &ast_trait_ref.path));\n             this.tcx().trait_refs.borrow_mut().insert(ast_trait_ref.ref_id,\n                                                       trait_ref.clone());\n             trait_ref\n@@ -435,36 +458,52 @@ pub fn instantiate_trait_ref<'tcx,AC,RS>(this: &AC,\n     }\n }\n \n-pub fn ast_path_to_trait_ref<'tcx,AC,RS>(this: &AC,\n-                                         rscope: &RS,\n-                                         trait_def_id: ast::DefId,\n-                                         self_ty: Option<ty::t>,\n-                                         associated_type: Option<ty::t>,\n-                                         path: &ast::Path,\n-                                         binder_id: ast::NodeId)\n-                                         -> ty::TraitRef\n-                                         where AC: AstConv<'tcx>,\n-                                               RS: RegionScope {\n+fn ast_path_to_trait_ref<'tcx,AC,RS>(\n+    this: &AC,\n+    rscope: &RS,\n+    trait_def_id: ast::DefId,\n+    self_ty: Option<ty::t>,\n+    associated_type: Option<ty::t>,\n+    path: &ast::Path)\n+    -> ty::TraitRef\n+    where AC: AstConv<'tcx>, RS: RegionScope\n+{\n     let trait_def = this.get_trait_def(trait_def_id);\n-    ty::TraitRef {\n-        def_id: trait_def_id,\n-        substs: ast_path_substs(this,\n-                                rscope,\n-                                trait_def_id,\n-                                &trait_def.generics,\n-                                self_ty,\n-                                associated_type,\n-                                path,\n-                                binder_id)\n-    }\n+\n+    // the trait reference introduces a binding level here, so\n+    // we need to shift the `rscope`. It'd be nice if we could\n+    // do away with this rscope stuff and work this knowledge\n+    // into resolve_lifetimes, as we do with non-omitted\n+    // lifetimes. Oh well, not there yet.\n+    let shifted_rscope = ShiftedRscope::new(rscope);\n+\n+    let (regions, types) = match path.segments.last().unwrap().parameters {\n+        ast::AngleBracketedParameters(ref data) => {\n+            convert_angle_bracketed_parameters(this, &shifted_rscope, data)\n+        }\n+        ast::ParenthesizedParameters(ref data) => {\n+            (Vec::new(), convert_parenthesized_parameters(this, data))\n+        }\n+    };\n+\n+    let substs = create_substs_for_ast_path(this,\n+                                            &shifted_rscope,\n+                                            path.span,\n+                                            trait_def_id,\n+                                            &trait_def.generics,\n+                                            self_ty,\n+                                            types,\n+                                            regions,\n+                                            associated_type);\n+\n+    ty::TraitRef::new(trait_def_id, substs)\n }\n \n pub fn ast_path_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n     this: &AC,\n     rscope: &RS,\n     did: ast::DefId,\n-    path: &ast::Path,\n-    binder_id: ast::NodeId)\n+    path: &ast::Path)\n     -> TypeAndSubsts\n {\n     let tcx = this.tcx();\n@@ -473,14 +512,13 @@ pub fn ast_path_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n         ty: decl_ty\n     } = this.get_item_ty(did);\n \n-    let substs = ast_path_substs(this,\n-                                 rscope,\n-                                 did,\n-                                 &generics,\n-                                 None,\n-                                 None,\n-                                 path,\n-                                 binder_id);\n+    let substs = ast_path_substs_for_ty(this,\n+                                        rscope,\n+                                        did,\n+                                        &generics,\n+                                        None,\n+                                        None,\n+                                        path);\n     let ty = decl_ty.subst(tcx, &substs);\n     TypeAndSubsts { substs: substs, ty: ty }\n }\n@@ -494,8 +532,7 @@ pub fn ast_path_to_ty_relaxed<'tcx,AC,RS>(\n     this: &AC,\n     rscope: &RS,\n     did: ast::DefId,\n-    path: &ast::Path,\n-    binder_id: ast::NodeId)\n+    path: &ast::Path)\n     -> TypeAndSubsts\n     where AC : AstConv<'tcx>, RS : RegionScope\n {\n@@ -521,7 +558,7 @@ pub fn ast_path_to_ty_relaxed<'tcx,AC,RS>(\n         Substs::new(VecPerParamSpace::params_from_type(type_params),\n                     VecPerParamSpace::params_from_type(region_params))\n     } else {\n-        ast_path_substs(this, rscope, did, &generics, None, None, path, binder_id)\n+        ast_path_substs_for_ty(this, rscope, did, &generics, None, None, path)\n     };\n \n     let ty = decl_ty.subst(tcx, &substs);\n@@ -628,7 +665,7 @@ pub fn ast_ty_to_builtin_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n             match a_def {\n                 def::DefTy(did, _) |\n                 def::DefStruct(did) if Some(did) == this.tcx().lang_items.owned_box() => {\n-                    let ty = ast_path_to_ty(this, rscope, did, path, id).ty;\n+                    let ty = ast_path_to_ty(this, rscope, did, path).ty;\n                     match ty::get(ty).sty {\n                         ty::ty_struct(struct_def_id, ref substs) => {\n                             assert_eq!(struct_def_id, did);\n@@ -689,8 +726,7 @@ fn mk_pointer<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n                                                        trait_def_id,\n                                                        None,\n                                                        None,\n-                                                       path,\n-                                                       id);\n+                                                       path);\n                     let empty_vec = [];\n                     let bounds = match *opt_bounds { None => empty_vec.as_slice(),\n                                                      Some(ref bounds) => bounds.as_slice() };\n@@ -752,12 +788,7 @@ fn associated_ty_to_ty<'tcx,AC,RS>(this: &AC,\n                                           trait_did,\n                                           None,\n                                           Some(for_type),\n-                                          trait_path,\n-                                          ast::DUMMY_NODE_ID); // *see below\n-\n-    // * The trait in a qualified path cannot be \"higher-ranked\" and\n-    // hence cannot use the parenthetical sugar, so the binder-id is\n-    // irrelevant.\n+                                          trait_path);\n \n     debug!(\"associated_ty_to_ty(trait_ref={})\",\n            trait_ref.repr(this.tcx()));\n@@ -830,8 +861,7 @@ pub fn ast_ty_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n                     tcx.sess.span_err(ast_ty.span,\n                                       \"variadic function must have C calling convention\");\n                 }\n-                ty::mk_bare_fn(tcx, ty_of_bare_fn(this, ast_ty.id, bf.fn_style,\n-                                                  bf.abi, &*bf.decl))\n+                ty::mk_bare_fn(tcx, ty_of_bare_fn(this, bf.fn_style, bf.abi, &*bf.decl))\n             }\n             ast::TyClosure(ref f) => {\n                 // Use corresponding trait store to figure out default bounds\n@@ -842,7 +872,6 @@ pub fn ast_ty_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n                                                      [].as_slice(),\n                                                      f.bounds.as_slice());\n                 let fn_decl = ty_of_closure(this,\n-                                            ast_ty.id,\n                                             f.fn_style,\n                                             f.onceness,\n                                             bounds,\n@@ -863,7 +892,6 @@ pub fn ast_ty_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n                                                      f.bounds.as_slice());\n \n                 let fn_decl = ty_of_closure(this,\n-                                            ast_ty.id,\n                                             f.fn_style,\n                                             f.onceness,\n                                             bounds,\n@@ -874,15 +902,8 @@ pub fn ast_ty_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n \n                 ty::mk_closure(tcx, fn_decl)\n             }\n-            ast::TyPolyTraitRef(ref data) => {\n-                // FIXME(#18639) this is just a placeholder for code to come\n-                let principal = instantiate_trait_ref(this, rscope, &data.trait_ref, None, None);\n-                let bounds = conv_existential_bounds(this,\n-                                                     rscope,\n-                                                     ast_ty.span,\n-                                                     &[principal.clone()],\n-                                                     &[]);\n-                ty::mk_trait(tcx, (*principal).clone(), bounds)\n+            ast::TyPolyTraitRef(ref bounds) => {\n+                conv_ty_poly_trait_ref(this, rscope, ast_ty.span, bounds.as_slice())\n             }\n             ast::TyPath(ref path, ref bounds, id) => {\n                 let a_def = match tcx.def_map.borrow().get(&id) {\n@@ -910,8 +931,7 @@ pub fn ast_ty_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n                                                            trait_def_id,\n                                                            None,\n                                                            None,\n-                                                           path,\n-                                                           id);\n+                                                           path);\n                         let empty_bounds: &[ast::TyParamBound] = &[];\n                         let ast_bounds = match *bounds {\n                             Some(ref b) => b.as_slice(),\n@@ -922,12 +942,12 @@ pub fn ast_ty_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n                                                              ast_ty.span,\n                                                              &[Rc::new(result.clone())],\n                                                              ast_bounds);\n-                        ty::mk_trait(tcx,\n-                                     result,\n-                                     bounds)\n+                        let result_ty = ty::mk_trait(tcx, result, bounds);\n+                        debug!(\"ast_ty_to_ty: result_ty={}\", result_ty.repr(this.tcx()));\n+                        result_ty\n                     }\n                     def::DefTy(did, _) | def::DefStruct(did) => {\n-                        ast_path_to_ty(this, rscope, did, path, id).ty\n+                        ast_path_to_ty(this, rscope, did, path).ty\n                     }\n                     def::DefTyParam(space, id, n) => {\n                         check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n@@ -1056,7 +1076,6 @@ struct SelfInfo<'a> {\n \n pub fn ty_of_method<'tcx, AC: AstConv<'tcx>>(\n                     this: &AC,\n-                    id: ast::NodeId,\n                     fn_style: ast::FnStyle,\n                     untransformed_self_ty: ty::t,\n                     explicit_self: &ast::ExplicitSelf,\n@@ -1069,25 +1088,21 @@ pub fn ty_of_method<'tcx, AC: AstConv<'tcx>>(\n     });\n     let (bare_fn_ty, optional_explicit_self_category) =\n         ty_of_method_or_bare_fn(this,\n-                                id,\n                                 fn_style,\n                                 abi,\n                                 self_info,\n                                 decl);\n     (bare_fn_ty, optional_explicit_self_category.unwrap())\n }\n \n-pub fn ty_of_bare_fn<'tcx, AC: AstConv<'tcx>>(this: &AC, id: ast::NodeId,\n-                                              fn_style: ast::FnStyle, abi: abi::Abi,\n+pub fn ty_of_bare_fn<'tcx, AC: AstConv<'tcx>>(this: &AC, fn_style: ast::FnStyle, abi: abi::Abi,\n                                               decl: &ast::FnDecl) -> ty::BareFnTy {\n-    let (bare_fn_ty, _) =\n-        ty_of_method_or_bare_fn(this, id, fn_style, abi, None, decl);\n+    let (bare_fn_ty, _) = ty_of_method_or_bare_fn(this, fn_style, abi, None, decl);\n     bare_fn_ty\n }\n \n fn ty_of_method_or_bare_fn<'tcx, AC: AstConv<'tcx>>(\n                            this: &AC,\n-                           id: ast::NodeId,\n                            fn_style: ast::FnStyle,\n                            abi: abi::Abi,\n                            opt_self_info: Option<SelfInfo>,\n@@ -1098,7 +1113,7 @@ fn ty_of_method_or_bare_fn<'tcx, AC: AstConv<'tcx>>(\n \n     // New region names that appear inside of the arguments of the function\n     // declaration are bound to that function type.\n-    let rb = rscope::BindingRscope::new(id);\n+    let rb = rscope::BindingRscope::new();\n \n     // `implied_output_region` is the region that will be assumed for any\n     // region parameters in the return type. In accordance with the rules for\n@@ -1114,7 +1129,9 @@ fn ty_of_method_or_bare_fn<'tcx, AC: AstConv<'tcx>>(\n                 determine_explicit_self_category(this, &rb, &self_info);\n             explicit_self_category_result = Some(explicit_self_category);\n             match explicit_self_category {\n-                ty::StaticExplicitSelfCategory => (None, None),\n+                ty::StaticExplicitSelfCategory => {\n+                    (None, None)\n+                }\n                 ty::ByValueExplicitSelfCategory => {\n                     (Some(self_info.untransformed_self_ty), None)\n                 }\n@@ -1205,7 +1222,6 @@ fn ty_of_method_or_bare_fn<'tcx, AC: AstConv<'tcx>>(\n         fn_style: fn_style,\n         abi: abi,\n         sig: ty::FnSig {\n-            binder_id: id,\n             inputs: self_and_input_tys,\n             output: output_ty,\n             variadic: decl.variadic\n@@ -1218,8 +1234,9 @@ fn determine_explicit_self_category<'tcx, AC: AstConv<'tcx>,\n                                     this: &AC,\n                                     rscope: &RS,\n                                     self_info: &SelfInfo)\n-                                    -> ty::ExplicitSelfCategory {\n-    match self_info.explicit_self.node {\n+                                    -> ty::ExplicitSelfCategory\n+{\n+    return match self_info.explicit_self.node {\n         ast::SelfStatic => ty::StaticExplicitSelfCategory,\n         ast::SelfValue(_) => ty::ByValueExplicitSelfCategory,\n         ast::SelfRegion(ref lifetime, mutability, _) => {\n@@ -1233,64 +1250,69 @@ fn determine_explicit_self_category<'tcx, AC: AstConv<'tcx>,\n         ast::SelfExplicit(ref ast_type, _) => {\n             let explicit_type = ast_ty_to_ty(this, rscope, &**ast_type);\n \n-            {\n-                let inference_context = infer::new_infer_ctxt(this.tcx());\n-                let expected_self = self_info.untransformed_self_ty;\n-                let actual_self = explicit_type;\n-                let result = infer::mk_eqty(\n-                    &inference_context,\n-                    false,\n-                    infer::Misc(self_info.explicit_self.span),\n-                    expected_self,\n-                    actual_self);\n-                match result {\n-                    Ok(_) => {\n-                        inference_context.resolve_regions_and_report_errors();\n-                        return ty::ByValueExplicitSelfCategory\n-                    }\n-                    Err(_) => {}\n+            // We wish to (for now) categorize an explicit self\n+            // declaration like `self: SomeType` into either `self`,\n+            // `&self`, `&mut self`, or `Box<self>`. We do this here\n+            // by some simple pattern matching. A more precise check\n+            // is done later in `check_method_self_type()`.\n+            //\n+            // Examples:\n+            //\n+            // ```\n+            // impl Foo for &T {\n+            //     // Legal declarations:\n+            //     fn method1(self: &&T); // ByReferenceExplicitSelfCategory\n+            //     fn method2(self: &T); // ByValueExplicitSelfCategory\n+            //     fn method3(self: Box<&T>); // ByBoxExplicitSelfCategory\n+            //\n+            //     // Invalid cases will be caught later by `check_method_self_type`:\n+            //     fn method_err1(self: &mut T); // ByReferenceExplicitSelfCategory\n+            // }\n+            // ```\n+            //\n+            // To do the check we just count the number of \"modifiers\"\n+            // on each type and compare them. If they are the same or\n+            // the impl has more, we call it \"by value\". Otherwise, we\n+            // look at the outermost modifier on the method decl and\n+            // call it by-ref, by-box as appropriate. For method1, for\n+            // example, the impl type has one modifier, but the method\n+            // type has two, so we end up with\n+            // ByReferenceExplicitSelfCategory.\n+\n+            let impl_modifiers = count_modifiers(self_info.untransformed_self_ty);\n+            let method_modifiers = count_modifiers(explicit_type);\n+\n+            debug!(\"determine_explicit_self_category(self_info.untransformed_self_ty={} \\\n+                   explicit_type={} \\\n+                   modifiers=({},{})\",\n+                   self_info.untransformed_self_ty.repr(this.tcx()),\n+                   explicit_type.repr(this.tcx()),\n+                   impl_modifiers,\n+                   method_modifiers);\n+\n+            if impl_modifiers >= method_modifiers {\n+                ty::ByValueExplicitSelfCategory\n+            } else {\n+                match ty::get(explicit_type).sty {\n+                    ty::ty_rptr(r, mt) => ty::ByReferenceExplicitSelfCategory(r, mt.mutbl),\n+                    ty::ty_uniq(_) => ty::ByBoxExplicitSelfCategory,\n+                    _ => ty::ByValueExplicitSelfCategory,\n                 }\n             }\n+        }\n+    };\n \n-            match ty::get(explicit_type).sty {\n-                ty::ty_rptr(region, tm) => {\n-                    typeck::require_same_types(\n-                        this.tcx(),\n-                        None,\n-                        false,\n-                        self_info.explicit_self.span,\n-                        self_info.untransformed_self_ty,\n-                        tm.ty,\n-                        || \"not a valid type for `self`\".to_string());\n-                    return ty::ByReferenceExplicitSelfCategory(region,\n-                                                               tm.mutbl)\n-                }\n-                ty::ty_uniq(typ) => {\n-                    typeck::require_same_types(\n-                        this.tcx(),\n-                        None,\n-                        false,\n-                        self_info.explicit_self.span,\n-                        self_info.untransformed_self_ty,\n-                        typ,\n-                        || \"not a valid type for `self`\".to_string());\n-                    return ty::ByBoxExplicitSelfCategory\n-                }\n-                _ => {\n-                    this.tcx()\n-                        .sess\n-                        .span_err(self_info.explicit_self.span,\n-                                  \"not a valid type for `self`\");\n-                    return ty::ByValueExplicitSelfCategory\n-                }\n-            }\n+    fn count_modifiers(ty: ty::t) -> uint {\n+        match ty::get(ty).sty {\n+            ty::ty_rptr(_, mt) => count_modifiers(mt.ty) + 1,\n+            ty::ty_uniq(t) => count_modifiers(t) + 1,\n+            _ => 0,\n         }\n     }\n }\n \n pub fn ty_of_closure<'tcx, AC: AstConv<'tcx>>(\n     this: &AC,\n-    id: ast::NodeId,\n     fn_style: ast::FnStyle,\n     onceness: ast::Onceness,\n     bounds: ty::ExistentialBounds,\n@@ -1300,13 +1322,14 @@ pub fn ty_of_closure<'tcx, AC: AstConv<'tcx>>(\n     expected_sig: Option<ty::FnSig>)\n     -> ty::ClosureTy\n {\n-    debug!(\"ty_of_fn_decl\");\n+    debug!(\"ty_of_closure(expected_sig={})\",\n+           expected_sig.repr(this.tcx()));\n \n     // new region names that appear inside of the fn decl are bound to\n     // that function type\n-    let rb = rscope::BindingRscope::new(id);\n+    let rb = rscope::BindingRscope::new();\n \n-    let input_tys = decl.inputs.iter().enumerate().map(|(i, a)| {\n+    let input_tys: Vec<_> = decl.inputs.iter().enumerate().map(|(i, a)| {\n         let expected_arg_ty = expected_sig.as_ref().and_then(|e| {\n             // no guarantee that the correct number of expected args\n             // were supplied\n@@ -1331,14 +1354,16 @@ pub fn ty_of_closure<'tcx, AC: AstConv<'tcx>>(\n         ast::NoReturn(_) => ty::FnDiverging\n     };\n \n+    debug!(\"ty_of_closure: input_tys={}\", input_tys.repr(this.tcx()));\n+    debug!(\"ty_of_closure: output_ty={}\", output_ty.repr(this.tcx()));\n+\n     ty::ClosureTy {\n         fn_style: fn_style,\n         onceness: onceness,\n         store: store,\n         bounds: bounds,\n         abi: abi,\n-        sig: ty::FnSig {binder_id: id,\n-                        inputs: input_tys,\n+        sig: ty::FnSig {inputs: input_tys,\n                         output: output_ty,\n                         variadic: decl.variadic}\n     }\n@@ -1365,15 +1390,66 @@ pub fn conv_existential_bounds<'tcx, AC: AstConv<'tcx>, RS:RegionScope>(\n     let ast_bound_refs: Vec<&ast::TyParamBound> =\n         ast_bounds.iter().collect();\n \n+    let partitioned_bounds =\n+        partition_bounds(this.tcx(), span, ast_bound_refs.as_slice());\n+\n+    conv_existential_bounds_from_partitioned_bounds(\n+        this, rscope, span, main_trait_refs, partitioned_bounds)\n+}\n+\n+fn conv_ty_poly_trait_ref<'tcx, AC, RS>(\n+    this: &AC,\n+    rscope: &RS,\n+    span: Span,\n+    ast_bounds: &[ast::TyParamBound])\n+    -> ty::t\n+    where AC: AstConv<'tcx>, RS:RegionScope\n+{\n+    let ast_bounds: Vec<&ast::TyParamBound> = ast_bounds.iter().collect();\n+    let mut partitioned_bounds = partition_bounds(this.tcx(), span, ast_bounds[]);\n+\n+    let main_trait_bound = match partitioned_bounds.trait_bounds.remove(0) {\n+        Some(trait_bound) => {\n+            Some(instantiate_poly_trait_ref(this, rscope, trait_bound, None, None))\n+        }\n+        None => {\n+            this.tcx().sess.span_err(\n+                span,\n+                \"at least one non-builtin trait is required for an object type\");\n+            None\n+        }\n+    };\n+\n+    let bounds = conv_existential_bounds_from_partitioned_bounds(this,\n+                                                                 rscope,\n+                                                                 span,\n+                                                                 main_trait_bound.as_slice(),\n+                                                                 partitioned_bounds);\n+\n+    match main_trait_bound {\n+        None => ty::mk_err(),\n+        Some(principal) => ty::mk_trait(this.tcx(), (*principal).clone(), bounds)\n+    }\n+}\n+\n+pub fn conv_existential_bounds_from_partitioned_bounds<'tcx, AC, RS>(\n+    this: &AC,\n+    rscope: &RS,\n+    span: Span,\n+    main_trait_refs: &[Rc<ty::TraitRef>],\n+    partitioned_bounds: PartitionedBounds)\n+    -> ty::ExistentialBounds\n+    where AC: AstConv<'tcx>, RS:RegionScope\n+{\n     let PartitionedBounds { builtin_bounds,\n                             trait_bounds,\n                             region_bounds } =\n-        partition_bounds(this.tcx(), span, ast_bound_refs.as_slice());\n+        partitioned_bounds;\n \n     if !trait_bounds.is_empty() {\n         let b = &trait_bounds[0];\n         this.tcx().sess.span_err(\n-            b.path.span,\n+            b.trait_ref.path.span,\n             format!(\"only the builtin traits can be used \\\n                      as closure or object bounds\").as_slice());\n     }\n@@ -1505,7 +1581,7 @@ fn compute_region_bound<'tcx, AC: AstConv<'tcx>, RS:RegionScope>(\n \n pub struct PartitionedBounds<'a> {\n     pub builtin_bounds: ty::BuiltinBounds,\n-    pub trait_bounds: Vec<&'a ast::TraitRef>,\n+    pub trait_bounds: Vec<&'a ast::PolyTraitRef>,\n     pub region_bounds: Vec<&'a ast::Lifetime>,\n }\n \n@@ -1527,19 +1603,18 @@ pub fn partition_bounds<'a>(tcx: &ty::ctxt,\n     for &ast_bound in ast_bounds.iter() {\n         match *ast_bound {\n             ast::TraitTyParamBound(ref b) => {\n-                let b = &b.trait_ref; // FIXME\n-                match lookup_def_tcx(tcx, b.path.span, b.ref_id) {\n+                match lookup_def_tcx(tcx, b.trait_ref.path.span, b.trait_ref.ref_id) {\n                     def::DefTrait(trait_did) => {\n                         match trait_def_ids.get(&trait_did) {\n                             // Already seen this trait. We forbid\n                             // duplicates in the list (for some\n                             // reason).\n                             Some(span) => {\n                                 span_err!(\n-                                    tcx.sess, b.path.span, E0127,\n+                                    tcx.sess, b.trait_ref.path.span, E0127,\n                                     \"trait `{}` already appears in the \\\n                                      list of bounds\",\n-                                    b.path.user_string(tcx));\n+                                    b.trait_ref.path.user_string(tcx));\n                                 tcx.sess.span_note(\n                                     *span,\n                                     \"previous appearance is here\");\n@@ -1550,7 +1625,7 @@ pub fn partition_bounds<'a>(tcx: &ty::ctxt,\n                             None => { }\n                         }\n \n-                        trait_def_ids.insert(trait_did, b.path.span);\n+                        trait_def_ids.insert(trait_did, b.trait_ref.path.span);\n \n                         if ty::try_add_builtin_trait(tcx,\n                                                      trait_did,"}, {"sha": "b4d22f117d4b7f2e0659ad34664bcf435c0cc51a", "filename": "src/librustc/middle/typeck/check/method/confirm.rs", "status": "modified", "additions": 103, "deletions": 24, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=c8d6e3b2c2a780eff92299da5d1c02e081617088", "patch": "@@ -20,6 +20,7 @@ use middle::typeck::{MethodCall, MethodCallee, MethodObject, MethodOrigin,\n                      MethodParam, MethodStatic, MethodTraitObject, MethodTypeParam};\n use middle::typeck::infer;\n use middle::typeck::infer::InferCtxt;\n+use middle::ty_fold::HigherRankedFoldable;\n use syntax::ast;\n use syntax::codemap::Span;\n use std::rc::Rc;\n@@ -32,6 +33,27 @@ struct ConfirmContext<'a, 'tcx:'a> {\n     self_expr: &'a ast::Expr,\n }\n \n+struct InstantiatedMethodSig {\n+    /// Function signature of the method being invoked. The 0th\n+    /// argument is the receiver.\n+    method_sig: ty::FnSig,\n+\n+    /// Substitutions for all types/early-bound-regions declared on\n+    /// the method.\n+    all_substs: subst::Substs,\n+\n+    /// Substitution to use when adding obligations from the method\n+    /// bounds. Normally equal to `all_substs` except for object\n+    /// receivers. See FIXME in instantiate_method_sig() for\n+    /// explanation.\n+    method_bounds_substs: subst::Substs,\n+\n+    /// Generic bounds on the method's parameters which must be added\n+    /// as pending obligations.\n+    method_bounds: ty::GenericBounds,\n+}\n+\n+\n pub fn confirm(fcx: &FnCtxt,\n                span: Span,\n                self_expr: &ast::Expr,\n@@ -79,14 +101,16 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n         debug!(\"all_substs={}\", all_substs.repr(self.tcx()));\n \n         // Create the final signature for the method, replacing late-bound regions.\n-        let method_sig = self.instantiate_method_sig(&pick, &all_substs);\n+        let InstantiatedMethodSig {\n+            method_sig, all_substs, method_bounds_substs, method_bounds\n+        } = self.instantiate_method_sig(&pick, all_substs);\n         let method_self_ty = method_sig.inputs[0];\n \n         // Unify the (adjusted) self type with what the method expects.\n         self.unify_receivers(self_ty, method_self_ty);\n \n         // Add any trait/regions obligations specified on the method's type parameters.\n-        self.add_obligations(&pick, &all_substs);\n+        self.add_obligations(&pick, &method_bounds_substs, &method_bounds);\n \n         // Create the final `MethodCallee`.\n         let fty = ty::mk_bare_fn(self.tcx(), ty::BareFnTy {\n@@ -176,6 +200,10 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n          * where all type and region parameters are instantiated with\n          * fresh variables. This substitution does not include any\n          * parameters declared on the method itself.\n+         *\n+         * Note that this substitution may include late-bound regions\n+         * from the impl level. If so, these are instantiated later in\n+         * the `instantiate_method_sig` routine.\n          */\n \n         match pick.kind {\n@@ -354,20 +382,34 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n \n     fn instantiate_method_sig(&mut self,\n                               pick: &probe::Pick,\n-                              all_substs: &subst::Substs)\n-                              -> ty::FnSig\n+                              all_substs: subst::Substs)\n+                              -> InstantiatedMethodSig\n     {\n-        let ref bare_fn_ty = pick.method_ty.fty;\n-        let fn_sig = bare_fn_ty.sig.subst(self.tcx(), all_substs);\n-        self.infcx().replace_late_bound_regions_with_fresh_var(fn_sig.binder_id,\n-                                                               self.span,\n-                                                               infer::FnCall,\n-                                                               &fn_sig).0\n-    }\n-\n-    fn add_obligations(&mut self,\n-                       pick: &probe::Pick,\n-                       all_substs: &subst::Substs) {\n+        // If this method comes from an impl (as opposed to a trait),\n+        // it may have late-bound regions from the impl that appear in\n+        // the substitutions, method signature, and\n+        // bounds. Instantiate those at this point. (If it comes from\n+        // a trait, this step has no effect, as there are no\n+        // late-bound regions to instantiate.)\n+        //\n+        // The binder level here corresponds to the impl.\n+        let (all_substs, (method_sig, method_generics)) =\n+            self.replace_late_bound_regions_with_fresh_var(\n+                &ty::bind((all_substs,\n+                           (pick.method_ty.fty.sig.clone(),\n+                            pick.method_ty.generics.clone())))).value;\n+\n+        debug!(\"late-bound lifetimes from impl instantiated, \\\n+                all_substs={} method_sig={} method_generics={}\",\n+               all_substs.repr(self.tcx()),\n+               method_sig.repr(self.tcx()),\n+               method_generics.repr(self.tcx()));\n+\n+        // Instantiate the bounds on the method with the\n+        // type/early-bound-regions substitutions performed.  The only\n+        // late-bound-regions that can appear in bounds are from the\n+        // impl, and those were already instantiated above.\n+        //\n         // FIXME(DST). Super hack. For a method on a trait object\n         // `Trait`, the generic signature requires that\n         // `Self:Trait`. Since, for an object, we bind `Self` to the\n@@ -381,24 +423,54 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n         // obligations.  This causes us to generate the obligation\n         // `err:Trait`, and the error type is considered to implement\n         // all traits, so we're all good. Hack hack hack.\n-        match pick.kind {\n+        let method_bounds_substs = match pick.kind {\n             probe::ObjectPick(..) => {\n                 let mut temp_substs = all_substs.clone();\n                 temp_substs.types.get_mut_slice(subst::SelfSpace)[0] = ty::mk_err();\n-                self.fcx.add_obligations_for_parameters(\n-                    traits::ObligationCause::misc(self.span),\n-                    &temp_substs,\n-                    &pick.method_ty.generics);\n+                temp_substs\n             }\n             _ => {\n-                self.fcx.add_obligations_for_parameters(\n-                    traits::ObligationCause::misc(self.span),\n-                    all_substs,\n-                    &pick.method_ty.generics);\n+                all_substs.clone()\n             }\n+        };\n+        let method_bounds =\n+            method_generics.to_bounds(self.tcx(), &method_bounds_substs);\n+\n+        debug!(\"method_bounds after subst = {}\",\n+               method_bounds.repr(self.tcx()));\n+\n+        // Substitute the type/early-bound-regions into the method\n+        // signature. In addition, the method signature may bind\n+        // late-bound regions, so instantiate those.\n+        let method_sig = method_sig.subst(self.tcx(), &all_substs);\n+        let method_sig = self.replace_late_bound_regions_with_fresh_var(&method_sig);\n+\n+        debug!(\"late-bound lifetimes from method instantiated, method_sig={}\",\n+               method_sig.repr(self.tcx()));\n+\n+        InstantiatedMethodSig {\n+            method_sig: method_sig,\n+            all_substs: all_substs,\n+            method_bounds_substs: method_bounds_substs,\n+            method_bounds: method_bounds,\n         }\n     }\n \n+    fn add_obligations(&mut self,\n+                       pick: &probe::Pick,\n+                       method_bounds_substs: &subst::Substs,\n+                       method_bounds: &ty::GenericBounds) {\n+        debug!(\"add_obligations: pick={} method_bounds_substs={} method_bounds={}\",\n+               pick.repr(self.tcx()),\n+               method_bounds_substs.repr(self.tcx()),\n+               method_bounds.repr(self.tcx()));\n+\n+        self.fcx.add_obligations_for_parameters(\n+            traits::ObligationCause::misc(self.span),\n+            method_bounds_substs,\n+            method_bounds);\n+    }\n+\n     ///////////////////////////////////////////////////////////////////////////\n     // RECONCILIATION\n \n@@ -591,6 +663,13 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                     source_trait_ref.repr(self.tcx()),\n                     target_trait_def_id.repr(self.tcx()))[]);\n     }\n+\n+    fn replace_late_bound_regions_with_fresh_var<T>(&self, value: &T) -> T\n+        where T : HigherRankedFoldable\n+    {\n+        self.infcx().replace_late_bound_regions_with_fresh_var(\n+            self.span, infer::FnCall, value).0\n+    }\n }\n \n fn wrap_autoref(mut deref: ty::AutoDerefRef,"}, {"sha": "6c7df2cd07ed2a17c0d34951a7fa09fd01ad9e52", "filename": "src/librustc/middle/typeck/check/method/mod.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod%2Fmod.rs?ref=c8d6e3b2c2a780eff92299da5d1c02e081617088", "patch": "@@ -200,10 +200,12 @@ pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &'a FnCtxt<'a, 'tcx>,\n \n     // Substitute the trait parameters into the method type and\n     // instantiate late-bound regions to get the actual method type.\n+    //\n+    // Note that as the method comes from a trait, it can only have\n+    // late-bound regions from the fn itself, not the impl.\n     let ref bare_fn_ty = method_ty.fty;\n     let fn_sig = bare_fn_ty.sig.subst(tcx, &trait_ref.substs);\n-    let fn_sig = fcx.infcx().replace_late_bound_regions_with_fresh_var(fn_sig.binder_id,\n-                                                                       span,\n+    let fn_sig = fcx.infcx().replace_late_bound_regions_with_fresh_var(span,\n                                                                        infer::FnCall,\n                                                                        &fn_sig).0;\n     let transformed_self_ty = fn_sig.inputs[0];\n@@ -222,10 +224,15 @@ pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &'a FnCtxt<'a, 'tcx>,\n     // so this also effectively registers `obligation` as well.  (We\n     // used to register `obligation` explicitly, but that resulted in\n     // double error messages being reported.)\n+    //\n+    // Note that as the method comes from a trait, it should not have\n+    // any late-bound regions appearing in its bounds.\n+    let method_bounds = method_ty.generics.to_bounds(fcx.tcx(), &trait_ref.substs);\n+    assert!(!method_bounds.has_escaping_regions());\n     fcx.add_obligations_for_parameters(\n         traits::ObligationCause::misc(span),\n         &trait_ref.substs,\n-        &method_ty.generics);\n+        &method_bounds);\n \n     // FIXME(#18653) -- Try to resolve obligations, giving us more\n     // typing information, which can sometimes be needed to avoid"}, {"sha": "f9c3fa86752ea03cdf905047d45c061b18468ca2", "filename": "src/librustc/middle/typeck/check/method/probe.rs", "status": "modified", "additions": 95, "deletions": 24, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=c8d6e3b2c2a780eff92299da5d1c02e081617088", "patch": "@@ -17,6 +17,7 @@ use middle::subst;\n use middle::subst::Subst;\n use middle::traits;\n use middle::ty;\n+use middle::ty_fold::HigherRankedFoldable;\n use middle::typeck::check;\n use middle::typeck::check::{FnCtxt, NoPreference};\n use middle::typeck::{MethodObject};\n@@ -257,29 +258,28 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         ty::populate_implementations_for_type_if_necessary(self.tcx(), def_id);\n \n         for impl_infos in self.tcx().inherent_impls.borrow().get(&def_id).iter() {\n-            for &impl_did in impl_infos.iter() {\n-                self.assemble_inherent_impl_probe(impl_did);\n+            for &impl_def_id in impl_infos.iter() {\n+                self.assemble_inherent_impl_probe(impl_def_id);\n             }\n         }\n     }\n \n-    fn assemble_inherent_impl_probe(&mut self, impl_did: ast::DefId) {\n-        if !self.impl_dups.insert(impl_did) {\n+    fn assemble_inherent_impl_probe(&mut self, impl_def_id: ast::DefId) {\n+        if !self.impl_dups.insert(impl_def_id) {\n             return; // already visited\n         }\n \n-        let method = match impl_method(self.tcx(), impl_did, self.method_name) {\n+        let method = match impl_method(self.tcx(), impl_def_id, self.method_name) {\n             Some(m) => m,\n             None => { return; } // No method with correct name on this impl\n         };\n \n         if !self.has_applicable_self(&*method) {\n             // No receiver declared. Not a candidate.\n-            return self.record_static_candidate(ImplSource(impl_did));\n+            return self.record_static_candidate(ImplSource(impl_def_id));\n         }\n \n-        let impl_pty = check::impl_self_ty(self.fcx, self.span, impl_did);\n-        let impl_substs = impl_pty.substs;\n+        let impl_substs = self.impl_substs(impl_def_id);\n \n         // Determine the receiver type that the method itself expects.\n         let xform_self_ty =\n@@ -288,7 +288,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         self.inherent_candidates.push(Candidate {\n             xform_self_ty: xform_self_ty,\n             method_ty: method,\n-            kind: InherentImplCandidate(impl_did, impl_substs)\n+            kind: InherentImplCandidate(impl_def_id, impl_substs)\n         });\n     }\n \n@@ -496,8 +496,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                 continue;\n             }\n \n-            let impl_pty = check::impl_self_ty(self.fcx, self.span, impl_def_id);\n-            let impl_substs = impl_pty.substs;\n+            let impl_substs = self.impl_substs(impl_def_id);\n \n             debug!(\"impl_substs={}\", impl_substs.repr(self.tcx()));\n \n@@ -675,7 +674,9 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                            mk_autoref_ty: |ast::Mutability, ty::Region| -> ty::t)\n                            -> Option<PickResult>\n     {\n-        let region = self.infcx().next_region_var(infer::Autoref(self.span));\n+        // In general, during probing we erase regions. See\n+        // `impl_self_ty()` for an explanation.\n+        let region = ty::ReStatic;\n \n         // Search through mutabilities in order to find one where pick works:\n         [ast::MutImmutable, ast::MutMutable]\n@@ -746,6 +747,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                probe.repr(self.tcx()));\n \n         self.infcx().probe(|| {\n+            // First check that the self type can be related.\n             match self.make_sub_ty(self_ty, probe.xform_self_ty) {\n                 Ok(()) => { }\n                 Err(_) => {\n@@ -754,23 +756,34 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                 }\n             }\n \n+            // If so, impls may carry other conditions (e.g., where\n+            // clauses) that must be considered. Make sure that those\n+            // match as well (or at least may match, sometimes we\n+            // don't have enough information to fully evaluate).\n             match probe.kind {\n                 InherentImplCandidate(impl_def_id, ref substs) |\n                 ExtensionImplCandidate(impl_def_id, _, ref substs, _) => {\n                     // Check whether the impl imposes obligations we have to worry about.\n+                    let impl_generics = ty::lookup_item_type(self.tcx(), impl_def_id).generics;\n+                    let impl_bounds = impl_generics.to_bounds(self.tcx(), substs);\n+\n+                    // Erase any late-bound regions bound in the impl\n+                    // which appear in the bounds.\n+                    let impl_bounds = self.erase_late_bound_regions(&ty::bind(impl_bounds)).value;\n+\n+                    // Convert the bounds into obligations.\n                     let obligations =\n-                        traits::impl_obligations(\n+                        traits::obligations_for_generics(\n                             self.tcx(),\n                             traits::ObligationCause::misc(self.span),\n-                            impl_def_id,\n-                            substs);\n-\n+                            &impl_bounds,\n+                            &substs.types);\n                     debug!(\"impl_obligations={}\", obligations.repr(self.tcx()));\n \n+                    // Evaluate those obligations to see if they might possibly hold.\n                     let mut selcx = traits::SelectionContext::new(self.infcx(),\n                                                                   &self.fcx.inh.param_env,\n                                                                   self.fcx);\n-\n                     obligations.all(|o| selcx.evaluate_obligation(o))\n                 }\n \n@@ -883,20 +896,78 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                 self.infcx().next_ty_vars(\n                     method.generics.types.len(subst::FnSpace));\n \n+            // In general, during probe we erase regions. See\n+            // `impl_self_ty()` for an explanation.\n             let method_regions =\n-                self.infcx().region_vars_for_defs(\n-                    self.span,\n-                    method.generics.regions.get_slice(subst::FnSpace));\n+                method.generics.regions.get_slice(subst::FnSpace)\n+                .iter()\n+                .map(|_| ty::ReStatic)\n+                .collect();\n \n             placeholder = (*substs).clone().with_method(method_types, method_regions);\n             substs = &placeholder;\n         }\n \n+        // Replace early-bound regions and types.\n         let xform_self_ty = method.fty.sig.inputs[0].subst(self.tcx(), substs);\n-        self.infcx().replace_late_bound_regions_with_fresh_var(method.fty.sig.binder_id,\n-                                                               self.span,\n-                                                               infer::FnCall,\n-                                                               &xform_self_ty).0\n+\n+        // Replace late-bound regions bound in the impl or\n+        // where-clause (2 levels of binding).\n+        let xform_self_ty =\n+            self.erase_late_bound_regions(&ty::bind(ty::bind(xform_self_ty))).value.value;\n+\n+        // Replace late-bound regions bound in the method (1 level of binding).\n+        self.erase_late_bound_regions(&ty::bind(xform_self_ty)).value\n+    }\n+\n+    fn impl_substs(&self,\n+                   impl_def_id: ast::DefId)\n+                   -> subst::Substs\n+    {\n+        let impl_pty = ty::lookup_item_type(self.tcx(), impl_def_id);\n+\n+        let type_vars =\n+            impl_pty.generics.types.map(\n+                |_| self.infcx().next_ty_var());\n+\n+        let region_placeholders =\n+            impl_pty.generics.regions.map(\n+                |_| ty::ReStatic); // see erase_late_bound_regions() for an expl of why 'static\n+\n+        subst::Substs::new(type_vars, region_placeholders)\n+    }\n+\n+    fn erase_late_bound_regions<T>(&self, value: &T) -> T\n+        where T : HigherRankedFoldable\n+    {\n+        /*!\n+         * Replace late-bound-regions bound by `value` with `'static`\n+         * using `ty::erase_late_bound_regions`.\n+         *\n+         * This is only a reasonable thing to do during the *probe*\n+         * phase, not the *confirm* phase, of method matching. It is\n+         * reasonable during the probe phase because we don't consider\n+         * region relationships at all. Therefore, we can just replace\n+         * all the region variables with 'static rather than creating\n+         * fresh region variables. This is nice for two reasons:\n+         *\n+         * 1. Because the numbers of the region variables would\n+         *    otherwise be fairly unique to this particular method\n+         *    call, it winds up creating fewer types overall, which\n+         *    helps for memory usage. (Admittedly, this is a rather\n+         *    small effect, though measureable.)\n+         *\n+         * 2. It makes it easier to deal with higher-ranked trait\n+         *    bounds, because we can replace any late-bound regions\n+         *    with 'static. Otherwise, if we were going to replace\n+         *    late-bound regions with actual region variables as is\n+         *    proper, we'd have to ensure that the same region got\n+         *    replaced with the same variable, which requires a bit\n+         *    more coordination and/or tracking the substitution and\n+         *    so forth.\n+         */\n+\n+        ty::erase_late_bound_regions(self.tcx(), value)\n     }\n }\n "}, {"sha": "8ae5c3a0a959704f51cccfb49f103d5dd28329f4", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 219, "deletions": 112, "changes": 331, "blob_url": "https://github.com/rust-lang/rust/blob/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=c8d6e3b2c2a780eff92299da5d1c02e081617088", "patch": "@@ -97,12 +97,12 @@ use middle::ty::{FnSig, VariantInfo};\n use middle::ty::{Polytype};\n use middle::ty::{Disr, ParamTy, ParameterEnvironment};\n use middle::ty;\n+use middle::ty::{replace_late_bound_regions, liberate_late_bound_regions};\n use middle::ty_fold::TypeFolder;\n use middle::typeck::astconv::AstConv;\n use middle::typeck::astconv::{ast_region_to_region, ast_ty_to_ty};\n use middle::typeck::astconv;\n use middle::typeck::check::_match::pat_ctxt;\n-use middle::typeck::check::regionmanip::replace_late_bound_regions;\n use middle::typeck::CrateCtxt;\n use middle::typeck::infer;\n use middle::typeck::rscope::RegionScope;\n@@ -528,9 +528,7 @@ fn check_fn<'a, 'tcx>(ccx: &'a CrateCtxt<'a, 'tcx>,\n \n     // First, we have to replace any bound regions in the fn type with free ones.\n     // The free region references will be bound the node_id of the body block.\n-    let (_, fn_sig) = replace_late_bound_regions(tcx, fn_sig.binder_id, fn_sig, |br| {\n-        ty::ReFree(ty::FreeRegion {scope_id: body.id, bound_region: br})\n-    });\n+    let fn_sig = liberate_late_bound_regions(tcx, body.id, fn_sig);\n \n     let arg_tys = fn_sig.inputs.as_slice();\n     let ret_ty = fn_sig.output;\n@@ -740,6 +738,11 @@ fn check_method_body(ccx: &CrateCtxt,\n     let param_env = ParameterEnvironment::for_item(ccx.tcx, method.id);\n \n     let fty = ty::node_id_to_type(ccx.tcx, method.id);\n+    debug!(\"fty (raw): {}\", fty.repr(ccx.tcx));\n+\n+    let body_id = method.pe_body().id;\n+    let fty = liberate_late_bound_regions(ccx.tcx, body_id, &ty::bind(fty)).value;\n+    debug!(\"fty (liberated): {}\", fty.repr(ccx.tcx));\n \n     check_bare_fn(ccx,\n                   &*method.pe_fn_decl(),\n@@ -784,7 +787,7 @@ fn check_impl_items_against_trait(ccx: &CrateCtxt,\n                                                     impl_method.span,\n                                                     impl_method.pe_body().id,\n                                                     &**trait_method_ty,\n-                                                    &impl_trait_ref.substs);\n+                                                    impl_trait_ref);\n                             }\n                             _ => {\n                                 // This is span_bug as it should have already been\n@@ -929,11 +932,36 @@ fn compare_impl_method(tcx: &ty::ctxt,\n                        impl_m_span: Span,\n                        impl_m_body_id: ast::NodeId,\n                        trait_m: &ty::Method,\n-                       trait_to_impl_substs: &subst::Substs) {\n-    debug!(\"compare_impl_method(trait_to_impl_substs={})\",\n-           trait_to_impl_substs.repr(tcx));\n+                       impl_trait_ref: &ty::TraitRef) {\n+    debug!(\"compare_impl_method(impl_trait_ref={})\",\n+           impl_trait_ref.repr(tcx));\n+\n+    // The impl's trait ref may bind late-bound regions from the impl.\n+    // Liberate them and assign them the scope of the method body.\n+    //\n+    // An example would be:\n+    //\n+    //     impl<'a> Foo<&'a T> for &'a U { ... }\n+    //\n+    // Here, the region parameter `'a` is late-bound, so the\n+    // trait reference associated with the impl will be\n+    //\n+    //     for<'a> Foo<&'a T>\n+    //\n+    // liberating will convert this into:\n+    //\n+    //     Foo<&'A T>\n+    //\n+    // where `'A` is the `ReFree` version of `'a`.\n+    let impl_trait_ref = liberate_late_bound_regions(tcx, impl_m_body_id, impl_trait_ref);\n+\n+    debug!(\"impl_trait_ref (liberated) = {}\",\n+           impl_trait_ref.repr(tcx));\n+\n     let infcx = infer::new_infer_ctxt(tcx);\n \n+    let trait_to_impl_substs = &impl_trait_ref.substs;\n+\n     // Try to give more informative error messages about self typing\n     // mismatches.  Note that any mismatch will also be detected\n     // below, where we construct a canonical function type that\n@@ -997,22 +1025,23 @@ fn compare_impl_method(tcx: &ty::ctxt,\n \n     // This code is best explained by example. Consider a trait:\n     //\n-    //     trait Trait<T> {\n-    //          fn method<'a,M>(t: T, m: &'a M) -> Self;\n+    //     trait Trait<'t,T> {\n+    //          fn method<'a,M>(t: &'t T, m: &'a M) -> Self;\n     //     }\n     //\n     // And an impl:\n     //\n-    //     impl<'i, U> Trait<&'i U> for Foo {\n-    //          fn method<'b,N>(t: &'i U, m: &'b N) -> Foo;\n+    //     impl<'i, 'j, U> Trait<'j, &'i U> for Foo {\n+    //          fn method<'b,N>(t: &'j &'i U, m: &'b N) -> Foo;\n     //     }\n     //\n     // We wish to decide if those two method types are compatible.\n     //\n-    // We start out with trait_to_impl_substs, that maps the trait type\n-    // parameters to impl type parameters:\n+    // We start out with trait_to_impl_substs, that maps the trait\n+    // type parameters to impl type parameters. This is taken from the\n+    // impl trait reference:\n     //\n-    //     trait_to_impl_substs = {T => &'i U, Self => Foo}\n+    //     trait_to_impl_substs = {'t => 'j, T => &'i U, Self => Foo}\n     //\n     // We create a mapping `dummy_substs` that maps from the impl type\n     // parameters to fresh types and regions. For type parameters,\n@@ -1067,22 +1096,58 @@ fn compare_impl_method(tcx: &ty::ctxt,\n     if !check_region_bounds_on_impl_method(tcx,\n                                            impl_m_span,\n                                            impl_m,\n+                                           impl_m_body_id,\n                                            &trait_m.generics,\n                                            &impl_m.generics,\n                                            &trait_to_skol_substs,\n                                            &impl_to_skol_substs) {\n         return;\n     }\n \n-    // Check bounds.\n-    let it = trait_m.generics.types.get_slice(subst::FnSpace).iter()\n-        .zip(impl_m.generics.types.get_slice(subst::FnSpace).iter());\n-    for (i, (trait_param_def, impl_param_def)) in it.enumerate() {\n+    // Check bounds. Note that the bounds from the impl may reference\n+    // late-bound regions declared on the impl, so liberate those.\n+    // This requires two artificial binding scopes -- one for the impl,\n+    // and one for the method.\n+    //\n+    // An example would be:\n+    //\n+    //     trait Foo<T> { fn method<U:Bound<T>>() { ... } }\n+    //\n+    //     impl<'a> Foo<&'a T> for &'a U {\n+    //         fn method<U:Bound<&'a T>>() { ... }\n+    //     }\n+    //\n+    // Here, the region parameter `'a` is late-bound, so in the bound\n+    // `Bound<&'a T>`, the lifetime `'a` will be late-bound with a\n+    // depth of 3 (it is nested within 3 binders: the impl, method,\n+    // and trait-ref itself). So when we do the liberation, we have\n+    // two introduce two `ty::bind` scopes, one for the impl and one\n+    // the method.\n+    //\n+    // The only late-bounded regions that can possibly appear here are\n+    // from the impl, not the method. This is because region\n+    // parameters declared on the method which appear in a type bound\n+    // would be early bound. On the trait side, there can be no\n+    // late-bound lifetimes because trait definitions do not introduce\n+    // a late region binder.\n+    let trait_bounds =\n+        trait_m.generics.types.get_slice(subst::FnSpace).iter()\n+        .map(|trait_param_def| &trait_param_def.bounds);\n+    let impl_bounds =\n+        impl_m.generics.types.get_slice(subst::FnSpace).iter()\n+        .map(|impl_param_def|\n+             liberate_late_bound_regions(\n+                 tcx,\n+                 impl_m_body_id,\n+                 &ty::bind(ty::bind(impl_param_def.bounds.clone()))).value.value);\n+    for (i, (trait_param_bounds, impl_param_bounds)) in\n+        trait_bounds.zip(impl_bounds).enumerate()\n+    {\n         // Check that the impl does not require any builtin-bounds\n         // that the trait does not guarantee:\n         let extra_bounds =\n-            impl_param_def.bounds.builtin_bounds -\n-            trait_param_def.bounds.builtin_bounds;\n+            impl_param_bounds.builtin_bounds -\n+            trait_param_bounds.builtin_bounds;\n         if !extra_bounds.is_empty() {\n             span_err!(tcx.sess, impl_m_span, E0051,\n                 \"in method `{}`, type parameter {} requires `{}`, \\\n@@ -1099,31 +1164,32 @@ fn compare_impl_method(tcx: &ty::ctxt,\n         //\n         // FIXME(pcwalton): We could be laxer here regarding sub- and super-\n         // traits, but I doubt that'll be wanted often, so meh.\n-        for impl_trait_bound in impl_param_def.bounds.trait_bounds.iter() {\n+        for impl_trait_bound in impl_param_bounds.trait_bounds.iter() {\n             debug!(\"compare_impl_method(): impl-trait-bound subst\");\n             let impl_trait_bound =\n                 impl_trait_bound.subst(tcx, &impl_to_skol_substs);\n \n-            let mut ok = false;\n-            for trait_bound in trait_param_def.bounds.trait_bounds.iter() {\n-                debug!(\"compare_impl_method(): trait-bound subst\");\n-                let trait_bound =\n-                    trait_bound.subst(tcx, &trait_to_skol_substs);\n-                let infcx = infer::new_infer_ctxt(tcx);\n-                match infer::mk_sub_trait_refs(&infcx,\n-                                               true,\n-                                               infer::Misc(impl_m_span),\n-                                               trait_bound,\n-                                               impl_trait_bound.clone()) {\n-                    Ok(_) => {\n-                        ok = true;\n-                        break\n-                    }\n-                    Err(_) => continue,\n-                }\n-            }\n+            // There may be late-bound regions from the impl in the\n+            // impl's bound, so \"liberate\" those. Note that the\n+            // trait_to_skol_substs is derived from the impl's\n+            // trait-ref, and the late-bound regions appearing there\n+            // have already been liberated, so the result should match\n+            // up.\n+\n+            let found_match_in_trait =\n+                trait_param_bounds.trait_bounds.iter().any(|trait_bound| {\n+                    debug!(\"compare_impl_method(): trait-bound subst\");\n+                    let trait_bound =\n+                        trait_bound.subst(tcx, &trait_to_skol_substs);\n+                    let infcx = infer::new_infer_ctxt(tcx);\n+                    infer::mk_sub_trait_refs(&infcx,\n+                                             true,\n+                                             infer::Misc(impl_m_span),\n+                                             trait_bound,\n+                                             impl_trait_bound.clone()).is_ok()\n+                });\n \n-            if !ok {\n+            if !found_match_in_trait {\n                 span_err!(tcx.sess, impl_m_span, E0052,\n                     \"in method `{}`, type parameter {} requires bound `{}`, which is not \\\n                      required by the corresponding type parameter in the trait declaration\",\n@@ -1134,9 +1200,11 @@ fn compare_impl_method(tcx: &ty::ctxt,\n         }\n     }\n \n-    // Compute skolemized form of impl and trait method tys.\n+    // Compute skolemized form of impl and trait method tys. Note\n+    // that we must liberate the late-bound regions from the impl.\n     let impl_fty = ty::mk_bare_fn(tcx, impl_m.fty.clone());\n     let impl_fty = impl_fty.subst(tcx, &impl_to_skol_substs);\n+    let impl_fty = liberate_late_bound_regions(tcx, impl_m_body_id, &ty::bind(impl_fty)).value;\n     let trait_fty = ty::mk_bare_fn(tcx, trait_m.fty.clone());\n     let trait_fty = trait_fty.subst(tcx, &trait_to_skol_substs);\n \n@@ -1171,6 +1239,7 @@ fn compare_impl_method(tcx: &ty::ctxt,\n     fn check_region_bounds_on_impl_method(tcx: &ty::ctxt,\n                                           span: Span,\n                                           impl_m: &ty::Method,\n+                                          impl_m_body_id: ast::NodeId,\n                                           trait_generics: &ty::Generics,\n                                           impl_generics: &ty::Generics,\n                                           trait_to_skol_substs: &Substs,\n@@ -1216,9 +1285,13 @@ fn compare_impl_method(tcx: &ty::ctxt,\n \n         debug!(\"check_region_bounds_on_impl_method: \\\n                trait_generics={} \\\n-               impl_generics={}\",\n+               impl_generics={} \\\n+               trait_to_skol_substs={} \\\n+               impl_to_skol_substs={}\",\n                trait_generics.repr(tcx),\n-               impl_generics.repr(tcx));\n+               impl_generics.repr(tcx),\n+               trait_to_skol_substs.repr(tcx),\n+               impl_to_skol_substs.repr(tcx));\n \n         // Must have same number of early-bound lifetime parameters.\n         // Unfortunately, if the user screws up the bounds, then this\n@@ -1249,6 +1322,18 @@ fn compare_impl_method(tcx: &ty::ctxt,\n             let impl_bounds =\n                 impl_param.bounds.subst(tcx, impl_to_skol_substs);\n \n+            // The bounds may reference late-bound regions from the\n+            // impl declaration. In that case, we want to replace\n+            // those with the liberated variety so as to match the\n+            // versions appearing in the `trait_to_skol_substs`.\n+            // There are two-levels of binder to be aware of: the\n+            // impl, and the method.\n+            let impl_bounds =\n+                ty::liberate_late_bound_regions(\n+                    tcx,\n+                    impl_m_body_id,\n+                    &ty::bind(ty::bind(impl_bounds))).value.value;\n+\n             debug!(\"check_region_bounds_on_impl_method: \\\n                    trait_param={} \\\n                    impl_param={} \\\n@@ -1603,15 +1688,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    pub fn write_ty_substs(&self,\n-                           node_id: ast::NodeId,\n-                           ty: ty::t,\n-                           substs: ty::ItemSubsts) {\n-        let ty = ty.subst(self.tcx(), &substs.substs);\n-        self.write_ty(node_id, ty);\n-        self.write_substs(node_id, substs);\n-    }\n-\n     pub fn write_autoderef_adjustment(&self,\n                                       node_id: ast::NodeId,\n                                       span: Span,\n@@ -1709,17 +1785,21 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    pub fn instantiate_item_type(&self,\n-                                 span: Span,\n-                                 def_id: ast::DefId)\n-                                 -> TypeAndSubsts\n+    pub fn instantiate_type(&self,\n+                            span: Span,\n+                            def_id: ast::DefId)\n+                            -> TypeAndSubsts\n     {\n         /*!\n          * Returns the type of `def_id` with all generics replaced by\n          * by fresh type/region variables. Also returns the\n          * substitution from the type parameters on `def_id` to the\n-         * fresh variables.  Registers any trait obligations specified\n+         * fresh variables. Registers any trait obligations specified\n          * on `def_id` at the same time.\n+         *\n+         * Note that function is only intended to be used with types\n+         * (notably, not impls). This is because it doesn't do any\n+         * instantiation of late-bound regions.\n          */\n \n         let polytype =\n@@ -1728,12 +1808,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             self.infcx().fresh_substs_for_generics(\n                 span,\n                 &polytype.generics);\n+        let bounds =\n+            polytype.generics.to_bounds(self.tcx(), &substs);\n         self.add_obligations_for_parameters(\n             traits::ObligationCause::new(\n                 span,\n                 traits::ItemObligation(def_id)),\n             &substs,\n-            &polytype.generics);\n+            &bounds);\n         let monotype =\n             polytype.ty.subst(self.tcx(), &substs);\n \n@@ -1958,8 +2040,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         let mut region_obligations = self.inh.region_obligations.borrow_mut();\n         let region_obligation = RegionObligation { sub_region: r,\n-                                  sup_type: ty,\n-                                  origin: origin };\n+                                                   sup_type: ty,\n+                                                   origin: origin };\n \n         match region_obligations.entry(self.body_id) {\n             Vacant(entry) => { entry.set(vec![region_obligation]); },\n@@ -1970,12 +2052,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn add_obligations_for_parameters(&self,\n                                           cause: traits::ObligationCause,\n                                           substs: &Substs,\n-                                          generics: &ty::Generics)\n+                                          generic_bounds: &ty::GenericBounds)\n     {\n         /*!\n-         * Given a set of generic parameter definitions (`generics`)\n-         * and the values provided for each of them (`substs`),\n-         * creates and registers suitable region obligations.\n+         * Given a fully substituted set of bounds (`generic_bounds`),\n+         * and the values with which each type/region parameter was\n+         * instantiated (`substs`), creates and registers suitable\n+         * trait/region obligations.\n          *\n          * For example, if there is a function:\n          *\n@@ -1991,60 +2074,60 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n          * locally.\n          */\n \n-        debug!(\"add_obligations_for_parameters(substs={}, generics={})\",\n+        assert!(!generic_bounds.has_escaping_regions());\n+\n+        debug!(\"add_obligations_for_parameters(substs={}, generic_bounds={})\",\n                substs.repr(self.tcx()),\n-               generics.repr(self.tcx()));\n+               generic_bounds.repr(self.tcx()));\n \n-        self.add_trait_obligations_for_generics(cause, substs, generics);\n-        self.add_region_obligations_for_generics(cause, substs, generics);\n+        self.add_trait_obligations_for_generics(cause, substs, generic_bounds);\n+        self.add_region_obligations_for_generics(cause, substs, generic_bounds);\n     }\n \n     fn add_trait_obligations_for_generics(&self,\n                                           cause: traits::ObligationCause,\n                                           substs: &Substs,\n-                                          generics: &ty::Generics) {\n+                                          generic_bounds: &ty::GenericBounds) {\n+        assert!(!generic_bounds.has_escaping_regions());\n+        assert!(!substs.has_regions_escaping_depth(0));\n+\n         let obligations =\n             traits::obligations_for_generics(self.tcx(),\n                                              cause,\n-                                             generics,\n-                                             substs);\n+                                             generic_bounds,\n+                                             &substs.types);\n         obligations.map_move(|o| self.register_obligation(o));\n     }\n \n     fn add_region_obligations_for_generics(&self,\n                                            cause: traits::ObligationCause,\n                                            substs: &Substs,\n-                                           generics: &ty::Generics)\n+                                           generic_bounds: &ty::GenericBounds)\n     {\n-        assert_eq!(generics.types.iter().len(),\n-                   substs.types.iter().len());\n-        for (type_def, &type_param) in\n-            generics.types.iter().zip(\n+        assert!(!generic_bounds.has_escaping_regions());\n+        assert_eq!(generic_bounds.types.iter().len(), substs.types.iter().len());\n+\n+        for (type_bounds, &type_param) in\n+            generic_bounds.types.iter().zip(\n                 substs.types.iter())\n         {\n-            let param_ty = ty::ParamTy { space: type_def.space,\n-                                         idx: type_def.index,\n-                                         def_id: type_def.def_id };\n-            let bounds = type_def.bounds.subst(self.tcx(), substs);\n             self.add_region_obligations_for_type_parameter(\n-                cause.span, param_ty, &bounds, type_param);\n+                cause.span, type_bounds, type_param);\n         }\n \n-        assert_eq!(generics.regions.iter().len(),\n+        assert_eq!(generic_bounds.regions.iter().len(),\n                    substs.regions().iter().len());\n-        for (region_def, &region_param) in\n-            generics.regions.iter().zip(\n+        for (region_bounds, &region_param) in\n+            generic_bounds.regions.iter().zip(\n                 substs.regions().iter())\n         {\n-            let bounds = region_def.bounds.subst(self.tcx(), substs);\n             self.add_region_obligations_for_region_parameter(\n-                cause.span, bounds.as_slice(), region_param);\n+                cause.span, region_bounds.as_slice(), region_param);\n         }\n     }\n \n     fn add_region_obligations_for_type_parameter(&self,\n                                                  span: Span,\n-                                                 param_ty: ty::ParamTy,\n                                                  param_bound: &ty::ParamBounds,\n                                                  ty: ty::t)\n     {\n@@ -2056,7 +2139,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 param_bound.builtin_bounds,\n                 param_bound.trait_bounds.as_slice());\n         for &r in region_bounds.iter() {\n-            let origin = infer::RelateParamBound(span, param_ty, ty);\n+            let origin = infer::RelateParamBound(span, ty);\n             self.register_region_obligation(origin, ty, r);\n         }\n     }\n@@ -2181,11 +2264,11 @@ fn try_overloaded_call<'a>(fcx: &FnCtxt,\n         fcx.inh.method_map.borrow_mut().insert(method_call, method_callee);\n         write_call(fcx, call_expression, output_type);\n \n-        if !fcx.tcx().sess.features.borrow().overloaded_calls {\n+        if !fcx.tcx().sess.features.borrow().unboxed_closures {\n             span_err!(fcx.tcx().sess, call_expression.span, E0056,\n                 \"overloaded calls are experimental\");\n             span_help!(fcx.tcx().sess, call_expression.span,\n-                \"add `#![feature(overloaded_calls)]` to \\\n+                \"add `#![feature(unboxed_closures)]` to \\\n                 the crate attributes to enable\");\n         }\n \n@@ -3031,7 +3114,6 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n         // In that case, we check each argument against \"error\" in order to\n         // set up all the node type bindings.\n         let error_fn_sig = FnSig {\n-            binder_id: ast::CRATE_NODE_ID,\n             inputs: err_args(args.len()),\n             output: ty::FnConverging(ty::mk_err()),\n             variadic: false\n@@ -3051,11 +3133,9 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n         // Replace any bound regions that appear in the function\n         // signature with region variables\n         let fn_sig =\n-            fcx.infcx().replace_late_bound_regions_with_fresh_var(\n-                fn_sig.binder_id,\n-                call_expr.span,\n-                infer::FnCall,\n-                fn_sig).0;\n+            fcx.infcx().replace_late_bound_regions_with_fresh_var(call_expr.span,\n+                                                                  infer::FnCall,\n+                                                                  fn_sig).0;\n \n         // Call the generic checker.\n         check_argument_types(fcx,\n@@ -3437,7 +3517,6 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                              body: &ast::Block) {\n         let mut fn_ty = astconv::ty_of_closure(\n             fcx,\n-            expr.id,\n             ast::NormalFn,\n             ast::Many,\n \n@@ -3508,6 +3587,10 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                      expected: Expectation) {\n         let tcx = fcx.ccx.tcx;\n \n+        debug!(\"check_expr_fn(expr={}, expected={})\",\n+               expr.repr(tcx),\n+               expected.repr(tcx));\n+\n         // Find the expected input/output types (if any). Substitute\n         // fresh bound regions for any bound regions we find in the\n         // expected types so as to avoid capture.\n@@ -3517,10 +3600,11 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n              expected_bounds) = {\n             match expected_sty {\n                 Some(ty::ty_closure(ref cenv)) => {\n-                    let (_, sig) =\n+                    let (sig, _) =\n                         replace_late_bound_regions(\n-                            tcx, cenv.sig.binder_id, &cenv.sig,\n-                            |_| fcx.inh.infcx.fresh_bound_region(expr.id));\n+                            tcx,\n+                            &cenv.sig,\n+                            |_, debruijn| fcx.inh.infcx.fresh_bound_region(debruijn));\n                     let onceness = match (&store, &cenv.store) {\n                         // As the closure type and onceness go, only three\n                         // combinations are legit:\n@@ -3561,7 +3645,6 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n \n         // construct the function type\n         let fn_ty = astconv::ty_of_closure(fcx,\n-                                           expr.id,\n                                            ast::NormalFn,\n                                            expected_onceness,\n                                            expected_bounds,\n@@ -3818,7 +3901,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n         let TypeAndSubsts {\n             ty: mut struct_type,\n             substs: struct_substs\n-        } = fcx.instantiate_item_type(span, class_id);\n+        } = fcx.instantiate_type(span, class_id);\n \n         // Look up and check the fields.\n         let class_fields = ty::lookup_struct_fields(tcx, class_id);\n@@ -3860,7 +3943,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n         let TypeAndSubsts {\n             ty: enum_type,\n             substs: substitutions\n-        } = fcx.instantiate_item_type(span, enum_id);\n+        } = fcx.instantiate_type(span, enum_id);\n \n         // Look up and check the enum variant fields.\n         let variant_fields = ty::lookup_struct_fields(tcx, variant_id);\n@@ -4454,8 +4537,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n             let type_and_substs = astconv::ast_path_to_ty_relaxed(fcx,\n                                                                   fcx.infcx(),\n                                                                   struct_id,\n-                                                                  path,\n-                                                                  expr.id);\n+                                                                  path);\n             match fcx.mk_subty(false,\n                                infer::Misc(path.span),\n                                actual_structure_type,\n@@ -5339,14 +5421,39 @@ pub fn instantiate_path(fcx: &FnCtxt,\n         assert_eq!(substs.regions().len(space), region_defs.len(space));\n     }\n \n+    // The things we are substituting into the type should not contain\n+    // escaping late-bound regions.\n+    assert!(!substs.has_regions_escaping_depth(0));\n+\n+    // In the case of static items taken from impls, there may be\n+    // late-bound regions associated with the impl (not declared on\n+    // the fn itself). Those should be replaced with fresh variables\n+    // now. These can appear either on the type being referenced, or\n+    // on the associated bounds.\n+    let bounds = polytype.generics.to_bounds(fcx.tcx(), &substs);\n+    let (ty_late_bound, bounds) =\n+        fcx.infcx().replace_late_bound_regions_with_fresh_var(\n+            span,\n+            infer::FnCall,\n+            &ty::bind((polytype.ty, bounds))).0.value;\n+\n+    debug!(\"after late-bounds have been replaced: ty_late_bound={}\", ty_late_bound.repr(fcx.tcx()));\n+    debug!(\"after late-bounds have been replaced: bounds={}\", bounds.repr(fcx.tcx()));\n+\n     fcx.add_obligations_for_parameters(\n         traits::ObligationCause::new(span, traits::ItemObligation(def.def_id())),\n         &substs,\n-        &polytype.generics);\n+        &bounds);\n \n-    fcx.write_ty_substs(node_id, polytype.ty, ty::ItemSubsts {\n-        substs: substs,\n-    });\n+    // Substitute the values for the type parameters into the type of\n+    // the referenced item.\n+    let ty_substituted = ty_late_bound.subst(fcx.tcx(), &substs);\n+\n+    debug!(\"ty_substituted: ty_substituted={}\", ty_substituted.repr(fcx.tcx()));\n+\n+    fcx.write_ty(node_id, ty_substituted);\n+    fcx.write_substs(node_id, ty::ItemSubsts { substs: substs });\n+    return;\n \n     fn report_error_if_segment_contains_type_parameters(\n         fcx: &FnCtxt,\n@@ -5739,7 +5846,8 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n             \"move_val_init\" => {\n                 (1u,\n                  vec!(\n-                    ty::mk_mut_rptr(tcx, ty::ReLateBound(it.id, ty::BrAnon(0)), param(ccx, 0)),\n+                    ty::mk_mut_rptr(tcx, ty::ReLateBound(ty::DebruijnIndex::new(1), ty::BrAnon(0)),\n+                                    param(ccx, 0)),\n                     param(ccx, 0u)\n                   ),\n                ty::mk_nil(tcx))\n@@ -5943,7 +6051,6 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n         fn_style: ast::UnsafeFn,\n         abi: abi::RustIntrinsic,\n         sig: FnSig {\n-            binder_id: it.id,\n             inputs: inputs,\n             output: output,\n             variadic: false,"}, {"sha": "2e727a8ef9aa594901f3b86bfc1a46dc163ca061", "filename": "src/librustc/middle/typeck/check/regionmanip.rs", "status": "modified", "additions": 1, "deletions": 34, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs?ref=c8d6e3b2c2a780eff92299da5d1c02e081617088", "patch": "@@ -14,47 +14,14 @@ pub use self::WfConstraint::*;\n \n use middle::subst::{ParamSpace, Subst, Substs};\n use middle::ty;\n-use middle::ty_fold;\n-use middle::ty_fold::{TypeFolder, TypeFoldable};\n+use middle::ty_fold::{TypeFolder};\n \n use syntax::ast;\n \n-use std::collections::hash_map::{Occupied, Vacant};\n-use util::nodemap::FnvHashMap;\n use util::ppaux::Repr;\n \n // Helper functions related to manipulating region types.\n \n-pub fn replace_late_bound_regions<T>(\n-    tcx: &ty::ctxt,\n-    binder_id: ast::NodeId,\n-    value: &T,\n-    map_fn: |ty::BoundRegion| -> ty::Region)\n-    -> (FnvHashMap<ty::BoundRegion,ty::Region>, T)\n-    where T : TypeFoldable + Repr\n-{\n-    debug!(\"replace_late_bound_regions(binder_id={}, value={})\",\n-           binder_id, value.repr(tcx));\n-\n-    let mut map = FnvHashMap::new();\n-    let new_value = {\n-        let mut folder = ty_fold::RegionFolder::regions(tcx, |r| {\n-            match r {\n-                ty::ReLateBound(s, br) if s == binder_id => {\n-                    match map.entry(br) {\n-                        Vacant(entry) => *entry.set(map_fn(br)),\n-                        Occupied(entry) => *entry.into_mut(),\n-                    }\n-                }\n-                _ => r\n-            }\n-        });\n-        value.fold_with(&mut folder)\n-    };\n-    debug!(\"resulting map: {}\", map);\n-    (map, new_value)\n-}\n-\n pub enum WfConstraint {\n     RegionSubRegionConstraint(Option<ty::t>, ty::Region, ty::Region),\n     RegionSubParamConstraint(Option<ty::t>, ty::Region, ty::ParamTy),"}, {"sha": "041d21a8baf3669319349422687f9b7285f09711", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=c8d6e3b2c2a780eff92299da5d1c02e081617088", "patch": "@@ -300,14 +300,14 @@ pub fn select_all_fcx_obligations_or_error(fcx: &FnCtxt) {\n }\n \n fn resolve_trait_ref(fcx: &FnCtxt, obligation: &Obligation)\n-                     -> (ty::TraitRef, ty::t)\n+                     -> (Rc<ty::TraitRef>, ty::t)\n {\n     let trait_ref =\n         fcx.infcx().resolve_type_vars_in_trait_ref_if_possible(\n             &*obligation.trait_ref);\n     let self_ty =\n         trait_ref.substs.self_ty().unwrap();\n-    (trait_ref, self_ty)\n+    (Rc::new(trait_ref), self_ty)\n }\n \n pub fn report_fulfillment_errors(fcx: &FnCtxt,"}, {"sha": "8e02f9f7bfd572917d8023d146fe20ed55287795", "filename": "src/librustc/middle/typeck/check/wf.rs", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwf.rs?ref=c8d6e3b2c2a780eff92299da5d1c02e081617088", "patch": "@@ -12,10 +12,10 @@ use middle::subst;\n use middle::subst::{Subst};\n use middle::traits;\n use middle::ty;\n+use middle::ty::liberate_late_bound_regions;\n use middle::ty_fold::{TypeFolder, TypeFoldable};\n use middle::typeck::astconv::AstConv;\n use middle::typeck::check::{FnCtxt, Inherited, blank_fn_ctxt, vtable, regionck};\n-use middle::typeck::check::regionmanip::replace_late_bound_regions;\n use middle::typeck::CrateCtxt;\n use util::ppaux::Repr;\n \n@@ -166,16 +166,24 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n             let mut bounds_checker = BoundsChecker::new(fcx, item.span,\n                                                         item.id, Some(&mut this.cache));\n \n+            // Find the impl self type as seen from the \"inside\" --\n+            // that is, with all type parameters converted from bound\n+            // to free, and any late-bound regions on the impl\n+            // liberated.\n             let self_ty = ty::node_id_to_type(fcx.tcx(), item.id);\n             let self_ty = self_ty.subst(fcx.tcx(), &fcx.inh.param_env.free_substs);\n+            let self_ty = liberate_late_bound_regions(fcx.tcx(), item.id, &ty::bind(self_ty)).value;\n \n             bounds_checker.check_traits_in_ty(self_ty);\n \n+            // Similarly, obtain an \"inside\" reference to the trait\n+            // that the impl implements.\n             let trait_ref = match ty::impl_trait_ref(fcx.tcx(), local_def(item.id)) {\n                 None => { return; }\n                 Some(t) => { t }\n             };\n             let trait_ref = (*trait_ref).subst(fcx.tcx(), &fcx.inh.param_env.free_substs);\n+            let trait_ref = liberate_late_bound_regions(fcx.tcx(), item.id, &trait_ref);\n \n             // There are special rules that apply to drop.\n             if\n@@ -215,7 +223,6 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n             // FIXME -- This is a bit ill-factored. There is very similar\n             // code in traits::util::obligations_for_generics.\n             fcx.add_region_obligations_for_type_parameter(item.span,\n-                                                          ty::ParamTy::for_self(trait_ref.def_id),\n                                                           &trait_def.bounds,\n                                                           trait_ref.self_ty());\n             for builtin_bound in trait_def.bounds.builtin_bounds.iter() {\n@@ -280,12 +287,13 @@ impl<'cx,'tcx> BoundsChecker<'cx,'tcx> {\n \n         let trait_def = ty::lookup_trait_def(self.fcx.tcx(), trait_ref.def_id);\n \n+        let bounds = trait_def.generics.to_bounds(self.tcx(), &trait_ref.substs);\n         self.fcx.add_obligations_for_parameters(\n             traits::ObligationCause::new(\n                 self.span,\n                 traits::ItemObligation(trait_ref.def_id)),\n             &trait_ref.substs,\n-            &trait_def.generics);\n+            &bounds);\n \n         for &ty in trait_ref.substs.types.iter() {\n             self.check_traits_in_ty(ty);\n@@ -335,7 +343,7 @@ impl<'cx,'tcx> TypeFolder<'tcx> for BoundsChecker<'cx,'tcx> {\n                         traits::ObligationCause::new(self.span,\n                                                      traits::ItemObligation(type_id)),\n                         substs,\n-                        &polytype.generics);\n+                        &polytype.generics.to_bounds(self.tcx(), substs));\n                 } else {\n                     // There are two circumstances in which we ignore\n                     // region obligations.\n@@ -363,7 +371,7 @@ impl<'cx,'tcx> TypeFolder<'tcx> for BoundsChecker<'cx,'tcx> {\n                         traits::ObligationCause::new(self.span,\n                                                      traits::ItemObligation(type_id)),\n                         substs,\n-                        &polytype.generics);\n+                        &polytype.generics.to_bounds(self.tcx(), substs));\n                 }\n \n                 self.fold_substs(substs);\n@@ -372,16 +380,12 @@ impl<'cx,'tcx> TypeFolder<'tcx> for BoundsChecker<'cx,'tcx> {\n             ty::ty_closure(box ty::ClosureTy{sig: ref fn_sig, ..}) => {\n                 self.binding_count += 1;\n \n-                let (_, fn_sig) =\n-                    replace_late_bound_regions(\n-                        self.fcx.tcx(), fn_sig.binder_id, fn_sig,\n-                        |br| ty::ReFree(ty::FreeRegion{scope_id: self.scope_id,\n-                                                       bound_region: br}));\n+                let fn_sig = liberate_late_bound_regions(self.fcx.tcx(), self.scope_id, fn_sig);\n \n                 debug!(\"late-bound regions replaced: {}\",\n                        fn_sig.repr(self.tcx()));\n \n-                self.fold_sig(&fn_sig);\n+                self.fold_fn_sig(&fn_sig);\n \n                 self.binding_count -= 1;\n             }"}, {"sha": "a0b198a59c266b80230b260ebe43f37bede0b068", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 59, "deletions": 32, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=c8d6e3b2c2a780eff92299da5d1c02e081617088", "patch": "@@ -214,12 +214,11 @@ pub fn get_enum_variant_types(ccx: &CrateCtxt,\n     for variant in variants.iter() {\n         // Nullary enum constructors get turned into constants; n-ary enum\n         // constructors get turned into functions.\n-        let scope = variant.node.id;\n         let result_ty = match variant.node.kind {\n             ast::TupleVariantKind(ref args) if args.len() > 0 => {\n                 let rs = ExplicitRscope;\n                 let input_tys: Vec<_> = args.iter().map(|va| ccx.to_ty(&rs, &*va.ty)).collect();\n-                ty::mk_ctor_fn(tcx, scope, input_tys.as_slice(), enum_ty)\n+                ty::mk_ctor_fn(tcx, input_tys.as_slice(), enum_ty)\n             }\n \n             ast::TupleVariantKind(_) => {\n@@ -403,7 +402,6 @@ fn collect_trait_methods(ccx: &CrateCtxt,\n             let trait_self_ty = ty::mk_self_type(tmcx.tcx(),\n                                                  local_def(trait_id));\n             astconv::ty_of_method(&tmcx,\n-                                  *m_id,\n                                   *m_fn_style,\n                                   trait_self_ty,\n                                   m_explicit_self,\n@@ -588,7 +586,6 @@ fn convert_methods<'a,I>(ccx: &CrateCtxt,\n                     method_generics: &m_ty_generics,\n                 };\n                 astconv::ty_of_method(&imcx,\n-                                      m.id,\n                                       m.pe_fn_style(),\n                                       untransformed_rcvr_ty,\n                                       m.pe_explicit_self(),\n@@ -603,7 +600,6 @@ fn convert_methods<'a,I>(ccx: &CrateCtxt,\n                     method_generics: &m_ty_generics,\n                 };\n                 astconv::ty_of_method(&tmcx,\n-                                      m.id,\n                                       m.pe_fn_style(),\n                                       untransformed_rcvr_ty,\n                                       m.pe_explicit_self(),\n@@ -1116,10 +1112,12 @@ pub fn convert(ccx: &CrateCtxt, it: &ast::Item) {\n             for impl_item in impl_items.iter() {\n                 match *impl_item {\n                     ast::MethodImplItem(ref method) => {\n+                        let body_id = method.pe_body().id;\n                         check_method_self_type(ccx,\n-                                               &BindingRscope::new(method.id),\n+                                               &BindingRscope::new(),\n                                                selfty,\n-                                               method.pe_explicit_self());\n+                                               method.pe_explicit_self(),\n+                                               body_id);\n                         methods.push(&**method);\n                     }\n                     ast::TypeImplItem(ref typedef) => {\n@@ -1174,17 +1172,19 @@ pub fn convert(ccx: &CrateCtxt, it: &ast::Item) {\n                                              local_def(it.id));\n                 match *trait_method {\n                     ast::RequiredMethod(ref type_method) => {\n-                        let rscope = BindingRscope::new(type_method.id);\n+                        let rscope = BindingRscope::new();\n                         check_method_self_type(ccx,\n                                                &rscope,\n                                                self_type,\n-                                               &type_method.explicit_self)\n+                                               &type_method.explicit_self,\n+                                               it.id)\n                     }\n                     ast::ProvidedMethod(ref method) => {\n                         check_method_self_type(ccx,\n-                                               &BindingRscope::new(method.id),\n+                                               &BindingRscope::new(),\n                                                self_type,\n-                                               method.pe_explicit_self())\n+                                               method.pe_explicit_self(),\n+                                               it.id)\n                     }\n                     ast::TypeTraitItem(ref associated_type) => {\n                         convert_associated_type(ccx,\n@@ -1294,7 +1294,6 @@ pub fn convert_struct(ccx: &CrateCtxt,\n                         |field| (*tcx.tcache.borrow())[\n                             local_def(field.node.id)].ty).collect();\n                 let ctor_fn_ty = ty::mk_ctor_fn(tcx,\n-                                                ctor_id,\n                                                 inputs.as_slice(),\n                                                 selfty);\n                 write_ty_to_tcx(tcx, ctor_id, ctor_fn_ty);\n@@ -1465,11 +1464,7 @@ pub fn ty_of_item(ccx: &CrateCtxt, it: &ast::Item)\n                     ccx: ccx,\n                     generics: &ty_generics,\n                 };\n-                astconv::ty_of_bare_fn(&fcx,\n-                                       it.id,\n-                                       fn_style,\n-                                       abi,\n-                                       &**decl)\n+                astconv::ty_of_bare_fn(&fcx, fn_style, abi, &**decl)\n             };\n             let pty = Polytype {\n                 generics: ty_generics,\n@@ -2015,12 +2010,12 @@ fn conv_param_bounds<'tcx,AC>(this: &AC,\n         astconv::partition_bounds(this.tcx(), span, all_bounds.as_slice());\n     let trait_bounds: Vec<Rc<ty::TraitRef>> =\n         trait_bounds.into_iter()\n-        .map(|b| {\n-            astconv::instantiate_trait_ref(this,\n-                                           &ExplicitRscope,\n-                                           b,\n-                                           Some(param_ty.to_ty(this.tcx())),\n-                                           Some(param_ty.to_ty(this.tcx())))\n+        .map(|bound| {\n+            astconv::instantiate_poly_trait_ref(this,\n+                                                &ExplicitRscope,\n+                                                bound,\n+                                                Some(param_ty.to_ty(this.tcx())),\n+                                                Some(param_ty.to_ty(this.tcx())))\n         })\n         .collect();\n     let region_bounds: Vec<ty::Region> =\n@@ -2091,7 +2086,7 @@ pub fn ty_of_foreign_fn_decl(ccx: &CrateCtxt,\n             ast_generics,\n             ty::Generics::empty(),\n             DontCreateTypeParametersForAssociatedTypes);\n-    let rb = BindingRscope::new(def_id.node);\n+    let rb = BindingRscope::new();\n     let input_tys = decl.inputs\n                         .iter()\n                         .map(|a| ty_of_arg(ccx, &rb, a, None))\n@@ -2109,8 +2104,7 @@ pub fn ty_of_foreign_fn_decl(ccx: &CrateCtxt,\n         ty::BareFnTy {\n             abi: abi,\n             fn_style: ast::UnsafeFn,\n-            sig: ty::FnSig {binder_id: def_id.node,\n-                            inputs: input_tys,\n+            sig: ty::FnSig {inputs: input_tys,\n                             output: output,\n                             variadic: decl.variadic}\n         });\n@@ -2142,10 +2136,12 @@ pub fn mk_item_substs(ccx: &CrateCtxt,\n /// Verifies that the explicit self type of a method matches the impl or\n /// trait.\n fn check_method_self_type<RS:RegionScope>(\n-                          crate_context: &CrateCtxt,\n-                          rs: &RS,\n-                          required_type: ty::t,\n-                          explicit_self: &ast::ExplicitSelf) {\n+    crate_context: &CrateCtxt,\n+    rs: &RS,\n+    required_type: ty::t,\n+    explicit_self: &ast::ExplicitSelf,\n+    body_id: ast::NodeId)\n+{\n     match explicit_self.node {\n         ast::SelfExplicit(ref ast_type, _) => {\n             let typ = crate_context.to_ty(rs, &**ast_type);\n@@ -2154,13 +2150,44 @@ fn check_method_self_type<RS:RegionScope>(\n                 ty::ty_uniq(typ) => typ,\n                 _ => typ,\n             };\n+\n+            // \"Required type\" comes from the trait definition. It may\n+            // contain late-bound regions from the method, but not the\n+            // trait (since traits only have early-bound region\n+            // parameters).\n+            assert!(!ty::type_escapes_depth(required_type, 1));\n+            let required_type_free =\n+                ty::liberate_late_bound_regions(\n+                    crate_context.tcx,\n+                    body_id,\n+                    &ty::bind(required_type)).value;\n+\n+            // The \"base type\" comes from the impl. It may have late-bound\n+            // regions from the impl or the method.\n+            let base_type_free = // liberate impl regions:\n+                ty::liberate_late_bound_regions(\n+                    crate_context.tcx,\n+                    body_id,\n+                    &ty::bind(ty::bind(base_type))).value.value;\n+            let base_type_free = // liberate method regions:\n+                ty::liberate_late_bound_regions(\n+                    crate_context.tcx,\n+                    body_id,\n+                    &ty::bind(base_type_free)).value;\n+\n+            debug!(\"required_type={} required_type_free={} \\\n+                    base_type={} base_type_free={}\",\n+                   required_type.repr(crate_context.tcx),\n+                   required_type_free.repr(crate_context.tcx),\n+                   base_type.repr(crate_context.tcx),\n+                   base_type_free.repr(crate_context.tcx));\n             let infcx = infer::new_infer_ctxt(crate_context.tcx);\n             drop(typeck::require_same_types(crate_context.tcx,\n                                             Some(&infcx),\n                                             false,\n                                             explicit_self.span,\n-                                            base_type,\n-                                            required_type,\n+                                            base_type_free,\n+                                            required_type_free,\n                                             || {\n                 format!(\"mismatched self type: expected `{}`\",\n                         ppaux::ty_to_string(crate_context.tcx, required_type))"}, {"sha": "0f9554cd417f7fa8ae46555902650a93176541e2", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 4, "deletions": 57, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=c8d6e3b2c2a780eff92299da5d1c02e081617088", "patch": "@@ -59,6 +59,7 @@ use syntax::codemap::Span;\n \n pub trait Combine<'tcx> {\n     fn infcx<'a>(&'a self) -> &'a InferCtxt<'a, 'tcx>;\n+    fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx> { self.infcx().tcx }\n     fn tag(&self) -> String;\n     fn a_is_expected(&self) -> bool;\n     fn trace(&self) -> TypeTrace;\n@@ -296,26 +297,14 @@ pub trait Combine<'tcx> {\n                 Err(ty::terr_trait_stores_differ(vk, expected_found(self, a, b)))\n             }\n         }\n-\n     }\n \n     fn trait_refs(&self,\n                   a: &ty::TraitRef,\n                   b: &ty::TraitRef)\n-                  -> cres<ty::TraitRef> {\n-        // Different traits cannot be related\n-\n-        // - NOTE in the future, expand out subtraits!\n-\n-        if a.def_id != b.def_id {\n-            Err(ty::terr_traits(\n-                                expected_found(self, a.def_id, b.def_id)))\n-        } else {\n-            let substs = try!(self.substs(a.def_id, &a.substs, &b.substs));\n-            Ok(ty::TraitRef { def_id: a.def_id,\n-                              substs: substs })\n-        }\n-    }\n+                  -> cres<ty::TraitRef>;\n+    // this must be overridden to do correctly, so as to account for higher-ranked\n+    // behavior\n }\n \n #[deriving(Clone)]\n@@ -334,48 +323,6 @@ pub fn expected_found<'tcx, C: Combine<'tcx>, T>(\n     }\n }\n \n-pub fn super_fn_sigs<'tcx, C: Combine<'tcx>>(this: &C,\n-                                             a: &ty::FnSig,\n-                                             b: &ty::FnSig)\n-                                             -> cres<ty::FnSig> {\n-\n-    fn argvecs<'tcx, C: Combine<'tcx>>(this: &C,\n-                                       a_args: &[ty::t],\n-                                       b_args: &[ty::t])\n-                                       -> cres<Vec<ty::t>> {\n-        if a_args.len() == b_args.len() {\n-            a_args.iter().zip(b_args.iter())\n-                  .map(|(a, b)| this.args(*a, *b)).collect()\n-        } else {\n-            Err(ty::terr_arg_count)\n-        }\n-    }\n-\n-    if a.variadic != b.variadic {\n-        return Err(ty::terr_variadic_mismatch(expected_found(this, a.variadic, b.variadic)));\n-    }\n-\n-    let inputs = try!(argvecs(this,\n-                                a.inputs.as_slice(),\n-                                b.inputs.as_slice()));\n-\n-    let output = try!(match (a.output, b.output) {\n-        (ty::FnConverging(a_ty), ty::FnConverging(b_ty)) =>\n-            Ok(ty::FnConverging(try!(this.tys(a_ty, b_ty)))),\n-        (ty::FnDiverging, ty::FnDiverging) =>\n-            Ok(ty::FnDiverging),\n-        (a, b) =>\n-            Err(ty::terr_convergence_mismatch(\n-                expected_found(this, a != ty::FnDiverging, b != ty::FnDiverging)\n-            )),\n-    });\n-\n-    Ok(FnSig {binder_id: a.binder_id,\n-              inputs: inputs,\n-              output: output,\n-              variadic: a.variadic})\n-}\n-\n pub fn super_tys<'tcx, C: Combine<'tcx>>(this: &C, a: ty::t, b: ty::t) -> cres<ty::t> {\n \n     let tcx = this.infcx().tcx;"}, {"sha": "3874f5fc5e4aaa2ca4fb0e7386513fa08c661c7b", "filename": "src/librustc/middle/typeck/infer/equate.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fequate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fequate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fequate.rs?ref=c8d6e3b2c2a780eff92299da5d1c02e081617088", "patch": "@@ -137,4 +137,9 @@ impl<'f, 'tcx> Combine<'tcx> for Equate<'f, 'tcx> {\n         try!(self.sub().fn_sigs(a, b));\n         self.sub().fn_sigs(b, a)\n     }\n+\n+    fn trait_refs(&self, a: &ty::TraitRef, b: &ty::TraitRef) -> cres<ty::TraitRef> {\n+        try!(self.sub().trait_refs(a, b));\n+        self.sub().trait_refs(b, a)\n+    }\n }"}, {"sha": "65bd21b14e02582354a78c975bd4eb9524e2f2ea", "filename": "src/librustc/middle/typeck/infer/error_reporting.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs?ref=c8d6e3b2c2a780eff92299da5d1c02e081617088", "patch": "@@ -650,14 +650,12 @@ impl<'a, 'tcx> ErrorReporting for InferCtxt<'a, 'tcx> {\n                     sup,\n                     \"\");\n             }\n-            infer::RelateParamBound(span, param_ty, ty) => {\n+            infer::RelateParamBound(span, ty) => {\n                 self.tcx.sess.span_err(\n                     span,\n-                    format!(\"the type `{}` (provided as the value of \\\n-                             the parameter `{}`) does not fulfill the \\\n+                    format!(\"the type `{}` does not fulfill the \\\n                              required lifetime\",\n-                            self.ty_to_string(ty),\n-                            param_ty.user_string(self.tcx)).as_slice());\n+                            self.ty_to_string(ty)).as_slice());\n                 note_and_explain_region(self.tcx,\n                                         \"type must outlive \",\n                                         sub,\n@@ -1460,8 +1458,8 @@ impl<'a, 'tcx> ErrorReportingHelpers for InferCtxt<'a, 'tcx> {\n                 format!(\" for {}in function call\",\n                         bound_region_to_string(self.tcx, \"lifetime parameter \", true, br))\n             }\n-            infer::LateBoundRegion(_, br, infer::FnType) => {\n-                format!(\" for {}in function type\",\n+            infer::LateBoundRegion(_, br, infer::HigherRankedType) => {\n+                format!(\" for {}in generic type\",\n                         bound_region_to_string(self.tcx, \"lifetime parameter \", true, br))\n             }\n             infer::EarlyBoundRegion(_, name) => {\n@@ -1651,13 +1649,11 @@ impl<'a, 'tcx> ErrorReportingHelpers for InferCtxt<'a, 'tcx> {\n                              does not outlive the data it points at\",\n                             self.ty_to_string(ty)).as_slice());\n             }\n-            infer::RelateParamBound(span, param_ty, t) => {\n+            infer::RelateParamBound(span, t) => {\n                 self.tcx.sess.span_note(\n                     span,\n-                    format!(\"...so that the parameter `{}`, \\\n-                             when instantiated with `{}`, \\\n-                             will meet its declared lifetime bounds.\",\n-                            param_ty.user_string(self.tcx),\n+                    format!(\"...so that the type `{}` \\\n+                             will meet the declared lifetime bounds.\",\n                             self.ty_to_string(t)).as_slice());\n             }\n             infer::RelateDefaultParamBound(span, t) => {"}, {"sha": "287a5cfba9e34aabd4316b9aa5b2bc7205c6e11f", "filename": "src/librustc/middle/typeck/infer/glb.rs", "status": "modified", "additions": 6, "deletions": 140, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs?ref=c8d6e3b2c2a780eff92299da5d1c02e081617088", "patch": "@@ -10,23 +10,18 @@\n \n \n use middle::ty::{BuiltinBounds};\n-use middle::ty::RegionVid;\n use middle::ty;\n use middle::typeck::infer::combine::*;\n use middle::typeck::infer::lattice::*;\n use middle::typeck::infer::equate::Equate;\n-use middle::typeck::infer::fold_regions_in_sig;\n-use middle::typeck::infer::LateBoundRegionConversionTime::FnType;\n+use middle::typeck::infer::higher_ranked::HigherRankedRelations;\n use middle::typeck::infer::lub::Lub;\n-use middle::typeck::infer::region_inference::RegionMark;\n use middle::typeck::infer::sub::Sub;\n use middle::typeck::infer::{cres, InferCtxt};\n use middle::typeck::infer::{TypeTrace, Subtype};\n use syntax::ast::{Many, Once, MutImmutable, MutMutable};\n-use syntax::ast::{NormalFn, UnsafeFn, NodeId};\n+use syntax::ast::{NormalFn, UnsafeFn};\n use syntax::ast::{Onceness, FnStyle};\n-use util::common::{indenter};\n-use util::nodemap::FnvHashMap;\n use util::ppaux::mt_to_string;\n use util::ppaux::Repr;\n \n@@ -128,139 +123,10 @@ impl<'f, 'tcx> Combine<'tcx> for Glb<'f, 'tcx> {\n     }\n \n     fn fn_sigs(&self, a: &ty::FnSig, b: &ty::FnSig) -> cres<ty::FnSig> {\n-        // Note: this is a subtle algorithm.  For a full explanation,\n-        // please see the large comment in `region_inference.rs`.\n-\n-        debug!(\"{}.fn_sigs({}, {})\",\n-               self.tag(), a.repr(self.fields.infcx.tcx), b.repr(self.fields.infcx.tcx));\n-        let _indenter = indenter();\n-\n-        // Make a mark so we can examine \"all bindings that were\n-        // created as part of this type comparison\".\n-        let mark = self.fields.infcx.region_vars.mark();\n-\n-        // Instantiate each bound region with a fresh region variable.\n-        let (a_with_fresh, a_map) =\n-            self.fields.infcx.replace_late_bound_regions_with_fresh_var(\n-                a.binder_id, self.trace().span(), FnType, a);\n-        let a_vars = var_ids(self, &a_map);\n-        let (b_with_fresh, b_map) =\n-            self.fields.infcx.replace_late_bound_regions_with_fresh_var(\n-                b.binder_id, self.trace().span(), FnType, b);\n-        let b_vars = var_ids(self, &b_map);\n-\n-        // Collect constraints.\n-        let sig0 = try!(super_fn_sigs(self, &a_with_fresh, &b_with_fresh));\n-        debug!(\"sig0 = {}\", sig0.repr(self.fields.infcx.tcx));\n-\n-        // Generalize the regions appearing in fn_ty0 if possible\n-        let new_vars =\n-            self.fields.infcx.region_vars.vars_created_since_mark(mark);\n-        let sig1 =\n-            fold_regions_in_sig(\n-                self.fields.infcx.tcx,\n-                &sig0,\n-                |r| {\n-                generalize_region(self,\n-                                  mark,\n-                                  new_vars.as_slice(),\n-                                  sig0.binder_id,\n-                                  &a_map,\n-                                  a_vars.as_slice(),\n-                                  b_vars.as_slice(),\n-                                  r)\n-            });\n-        debug!(\"sig1 = {}\", sig1.repr(self.fields.infcx.tcx));\n-        return Ok(sig1);\n-\n-        fn generalize_region(this: &Glb,\n-                             mark: RegionMark,\n-                             new_vars: &[RegionVid],\n-                             new_binder_id: NodeId,\n-                             a_map: &FnvHashMap<ty::BoundRegion, ty::Region>,\n-                             a_vars: &[RegionVid],\n-                             b_vars: &[RegionVid],\n-                             r0: ty::Region) -> ty::Region {\n-            if !is_var_in_set(new_vars, r0) {\n-                assert!(!r0.is_bound());\n-                return r0;\n-            }\n-\n-            let tainted = this.fields.infcx.region_vars.tainted(mark, r0);\n-\n-            let mut a_r = None;\n-            let mut b_r = None;\n-            let mut only_new_vars = true;\n-            for r in tainted.iter() {\n-                if is_var_in_set(a_vars, *r) {\n-                    if a_r.is_some() {\n-                        return fresh_bound_variable(this, new_binder_id);\n-                    } else {\n-                        a_r = Some(*r);\n-                    }\n-                } else if is_var_in_set(b_vars, *r) {\n-                    if b_r.is_some() {\n-                        return fresh_bound_variable(this, new_binder_id);\n-                    } else {\n-                        b_r = Some(*r);\n-                    }\n-                } else if !is_var_in_set(new_vars, *r) {\n-                    only_new_vars = false;\n-                }\n-            }\n-\n-            // NB---I do not believe this algorithm computes\n-            // (necessarily) the GLB.  As written it can\n-            // spuriously fail. In particular, if there is a case\n-            // like: |fn(&a)| and fn(fn(&b)), where a and b are\n-            // free, it will return fn(&c) where c = GLB(a,b).  If\n-            // however this GLB is not defined, then the result is\n-            // an error, even though something like\n-            // \"fn<X>(fn(&X))\" where X is bound would be a\n-            // subtype of both of those.\n-            //\n-            // The problem is that if we were to return a bound\n-            // variable, we'd be computing a lower-bound, but not\n-            // necessarily the *greatest* lower-bound.\n-            //\n-            // Unfortunately, this problem is non-trivial to solve,\n-            // because we do not know at the time of computing the GLB\n-            // whether a GLB(a,b) exists or not, because we haven't\n-            // run region inference (or indeed, even fully computed\n-            // the region hierarchy!). The current algorithm seems to\n-            // works ok in practice.\n-\n-            if a_r.is_some() && b_r.is_some() && only_new_vars {\n-                // Related to exactly one bound variable from each fn:\n-                return rev_lookup(this, a_map, new_binder_id, a_r.unwrap());\n-            } else if a_r.is_none() && b_r.is_none() {\n-                // Not related to bound variables from either fn:\n-                assert!(!r0.is_bound());\n-                return r0;\n-            } else {\n-                // Other:\n-                return fresh_bound_variable(this, new_binder_id);\n-            }\n-        }\n-\n-        fn rev_lookup(this: &Glb,\n-                      a_map: &FnvHashMap<ty::BoundRegion, ty::Region>,\n-                      new_binder_id: NodeId,\n-                      r: ty::Region) -> ty::Region\n-        {\n-            for (a_br, a_r) in a_map.iter() {\n-                if *a_r == r {\n-                    return ty::ReLateBound(new_binder_id, *a_br);\n-                }\n-            }\n-            this.fields.infcx.tcx.sess.span_bug(\n-                this.fields.trace.origin.span(),\n-                format!(\"could not find original bound region for {}\",\n-                        r).as_slice())\n-        }\n+        self.higher_ranked_glb(a, b)\n+    }\n \n-        fn fresh_bound_variable(this: &Glb, binder_id: NodeId) -> ty::Region {\n-            this.fields.infcx.region_vars.new_bound(binder_id)\n-        }\n+    fn trait_refs(&self, a: &ty::TraitRef, b: &ty::TraitRef) -> cres<ty::TraitRef> {\n+        self.higher_ranked_glb(a, b)\n     }\n }"}, {"sha": "4c4452ac892361e4af91dd6eb450e044135d2f1d", "filename": "src/librustc/middle/typeck/infer/higher_ranked/doc.rs", "status": "added", "additions": 415, "deletions": 0, "changes": 415, "blob_url": "https://github.com/rust-lang/rust/blob/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fhigher_ranked%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fhigher_ranked%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fhigher_ranked%2Fdoc.rs?ref=c8d6e3b2c2a780eff92299da5d1c02e081617088", "patch": "@@ -0,0 +1,415 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/*!\n+\n+# Skolemization and functions\n+\n+One of the trickiest and most subtle aspects of regions is dealing\n+with higher-ranked things which include bound region variables, such\n+as function types. I strongly suggest that if you want to understand\n+the situation, you read this paper (which is, admittedly, very long,\n+but you don't have to read the whole thing):\n+\n+http://research.microsoft.com/en-us/um/people/simonpj/papers/higher-rank/\n+\n+Although my explanation will never compete with SPJ's (for one thing,\n+his is approximately 100 pages), I will attempt to explain the basic\n+problem and also how we solve it. Note that the paper only discusses\n+subtyping, not the computation of LUB/GLB.\n+\n+The problem we are addressing is that there is a kind of subtyping\n+between functions with bound region parameters. Consider, for\n+example, whether the following relation holds:\n+\n+    for<'a> fn(&'a int) <: for<'b> fn(&'b int)? (Yes, a => b)\n+\n+The answer is that of course it does. These two types are basically\n+the same, except that in one we used the name `a` and one we used\n+the name `b`.\n+\n+In the examples that follow, it becomes very important to know whether\n+a lifetime is bound in a function type (that is, is a lifetime\n+parameter) or appears free (is defined in some outer scope).\n+Therefore, from now on I will always write the bindings explicitly,\n+using the Rust syntax `for<'a> fn(&'a int)` to indicate that `a` is a\n+lifetime parameter.\n+\n+Now let's consider two more function types. Here, we assume that the\n+`'b` lifetime is defined somewhere outside and hence is not a lifetime\n+parameter bound by the function type (it \"appears free\"):\n+\n+    for<'a> fn(&'a int) <: fn(&'b int)? (Yes, a => b)\n+\n+This subtyping relation does in fact hold. To see why, you have to\n+consider what subtyping means. One way to look at `T1 <: T2` is to\n+say that it means that it is always ok to treat an instance of `T1` as\n+if it had the type `T2`. So, with our functions, it is always ok to\n+treat a function that can take pointers with any lifetime as if it\n+were a function that can only take a pointer with the specific\n+lifetime `'b`. After all, `'b` is a lifetime, after all, and\n+the function can take values of any lifetime.\n+\n+You can also look at subtyping as the *is a* relationship. This amounts\n+to the same thing: a function that accepts pointers with any lifetime\n+*is a* function that accepts pointers with some specific lifetime.\n+\n+So, what if we reverse the order of the two function types, like this:\n+\n+    fn(&'b int) <: for<'a> fn(&'a int)? (No)\n+\n+Does the subtyping relationship still hold?  The answer of course is\n+no. In this case, the function accepts *only the lifetime `'b`*,\n+so it is not reasonable to treat it as if it were a function that\n+accepted any lifetime.\n+\n+What about these two examples:\n+\n+    for<'a,'b> fn(&'a int, &'b int) <: for<'a>    fn(&'a int, &'a int)? (Yes)\n+    for<'a>    fn(&'a int, &'a int) <: for<'a,'b> fn(&'a int, &'b int)? (No)\n+\n+Here, it is true that functions which take two pointers with any two\n+lifetimes can be treated as if they only accepted two pointers with\n+the same lifetime, but not the reverse.\n+\n+## The algorithm\n+\n+Here is the algorithm we use to perform the subtyping check:\n+\n+1. Replace all bound regions in the subtype with new variables\n+2. Replace all bound regions in the supertype with skolemized\n+   equivalents. A \"skolemized\" region is just a new fresh region\n+   name.\n+3. Check that the parameter and return types match as normal\n+4. Ensure that no skolemized regions 'leak' into region variables\n+   visible from \"the outside\"\n+\n+Let's walk through some examples and see how this algorithm plays out.\n+\n+#### First example\n+\n+We'll start with the first example, which was:\n+\n+    1. for<'a> fn(&'a T) <: for<'b> fn(&'b T)?        Yes: a -> b\n+\n+After steps 1 and 2 of the algorithm we will have replaced the types\n+like so:\n+\n+    1. fn(&'A T) <: fn(&'x T)?\n+\n+Here the upper case `&A` indicates a *region variable*, that is, a\n+region whose value is being inferred by the system. I also replaced\n+`&b` with `&x`---I'll use letters late in the alphabet (`x`, `y`, `z`)\n+to indicate skolemized region names. We can assume they don't appear\n+elsewhere. Note that neither the sub- nor the supertype bind any\n+region names anymore (as indicated by the absence of `<` and `>`).\n+\n+The next step is to check that the parameter types match. Because\n+parameters are contravariant, this means that we check whether:\n+\n+    &'x T <: &'A T\n+\n+Region pointers are contravariant so this implies that\n+\n+    &A <= &x\n+\n+must hold, where `<=` is the subregion relationship. Processing\n+*this* constrain simply adds a constraint into our graph that `&A <=\n+&x` and is considered successful (it can, for example, be satisfied by\n+choosing the value `&x` for `&A`).\n+\n+So far we have encountered no error, so the subtype check succeeds.\n+\n+#### The third example\n+\n+Now let's look first at the third example, which was:\n+\n+    3. fn(&'a T)    <: for<'b> fn(&'b T)?        No!\n+\n+After steps 1 and 2 of the algorithm we will have replaced the types\n+like so:\n+\n+    3. fn(&'a T) <: fn(&'x T)?\n+\n+This looks pretty much the same as before, except that on the LHS\n+`'a` was not bound, and hence was left as-is and not replaced with\n+a variable. The next step is again to check that the parameter types\n+match. This will ultimately require (as before) that `'a` <= `&x`\n+must hold: but this does not hold. `self` and `x` are both distinct\n+free regions. So the subtype check fails.\n+\n+#### Checking for skolemization leaks\n+\n+You may be wondering about that mysterious last step in the algorithm.\n+So far it has not been relevant. The purpose of that last step is to\n+catch something like *this*:\n+\n+    for<'a> fn() -> fn(&'a T) <: fn() -> for<'b> fn(&'b T)?   No.\n+\n+Here the function types are the same but for where the binding occurs.\n+The subtype returns a function that expects a value in precisely one\n+region. The supertype returns a function that expects a value in any\n+region. If we allow an instance of the subtype to be used where the\n+supertype is expected, then, someone could call the fn and think that\n+the return value has type `fn<b>(&'b T)` when it really has type\n+`fn(&'a T)` (this is case #3, above). Bad.\n+\n+So let's step through what happens when we perform this subtype check.\n+We first replace the bound regions in the subtype (the supertype has\n+no bound regions). This gives us:\n+\n+    fn() -> fn(&'A T) <: fn() -> for<'b> fn(&'b T)?\n+\n+Now we compare the return types, which are covariant, and hence we have:\n+\n+    fn(&'A T) <: for<'b> fn(&'b T)?\n+\n+Here we skolemize the bound region in the supertype to yield:\n+\n+    fn(&'A T) <: fn(&'x T)?\n+\n+And then proceed to compare the argument types:\n+\n+    &'x T <: &'A T\n+    'A <= 'x\n+\n+Finally, this is where it gets interesting!  This is where an error\n+*should* be reported. But in fact this will not happen. The reason why\n+is that `A` is a variable: we will infer that its value is the fresh\n+region `x` and think that everything is happy. In fact, this behavior\n+is *necessary*, it was key to the first example we walked through.\n+\n+The difference between this example and the first one is that the variable\n+`A` already existed at the point where the skolemization occurred. In\n+the first example, you had two functions:\n+\n+    for<'a> fn(&'a T) <: for<'b> fn(&'b T)\n+\n+and hence `&A` and `&x` were created \"together\". In general, the\n+intention of the skolemized names is that they are supposed to be\n+fresh names that could never be equal to anything from the outside.\n+But when inference comes into play, we might not be respecting this\n+rule.\n+\n+So the way we solve this is to add a fourth step that examines the\n+constraints that refer to skolemized names. Basically, consider a\n+non-directed verison of the constraint graph. Let `Tainted(x)` be the\n+set of all things reachable from a skolemized variable `x`.\n+`Tainted(x)` should not contain any regions that existed before the\n+step at which the skolemization was performed. So this case here\n+would fail because `&x` was created alone, but is relatable to `&A`.\n+\n+## Computing the LUB and GLB\n+\n+The paper I pointed you at is written for Haskell. It does not\n+therefore considering subtyping and in particular does not consider\n+LUB or GLB computation. We have to consider this. Here is the\n+algorithm I implemented.\n+\n+First though, let's discuss what we are trying to compute in more\n+detail. The LUB is basically the \"common supertype\" and the GLB is\n+\"common subtype\"; one catch is that the LUB should be the\n+*most-specific* common supertype and the GLB should be *most general*\n+common subtype (as opposed to any common supertype or any common\n+subtype).\n+\n+Anyway, to help clarify, here is a table containing some function\n+pairs and their LUB/GLB (for conciseness, in this table, I'm just\n+including the lifetimes here, not the rest of the types, and I'm\n+writing `fn<>` instead of `for<> fn`):\n+\n+```\n+Type 1                Type 2                LUB                    GLB\n+fn<'a>('a)            fn('X)                fn('X)                 fn<'a>('a)\n+fn('a)                fn('X)                --                     fn<'a>('a)\n+fn<'a,'b>('a, 'b)     fn<'x>('x, 'x)        fn<'a>('a, 'a)         fn<'a,'b>('a, 'b)\n+fn<'a,'b>('a, 'b, 'a) fn<'x,'y>('x, 'y, 'y) fn<'a>('a, 'a, 'a)     fn<'a,'b,'c>('a,'b,'c)\n+```\n+\n+### Conventions\n+\n+I use lower-case letters (e.g., `&a`) for bound regions and upper-case\n+letters for free regions (`&A`).  Region variables written with a\n+dollar-sign (e.g., `$a`).  I will try to remember to enumerate the\n+bound-regions on the fn type as well (e.g., `for<'a> fn(&a)`).\n+\n+### High-level summary\n+\n+Both the LUB and the GLB algorithms work in a similar fashion.  They\n+begin by replacing all bound regions (on both sides) with fresh region\n+inference variables.  Therefore, both functions are converted to types\n+that contain only free regions.  We can then compute the LUB/GLB in a\n+straightforward way, as described in `combine.rs`.  This results in an\n+interim type T.  The algorithms then examine the regions that appear\n+in T and try to, in some cases, replace them with bound regions to\n+yield the final result.\n+\n+To decide whether to replace a region `R` that appears in `T` with a\n+bound region, the algorithms make use of two bits of information.\n+First is a set `V` that contains all region variables created as part\n+of the LUB/GLB computation. `V` will contain the region variables\n+created to replace the bound regions in the input types, but it also\n+contains 'intermediate' variables created to represent the LUB/GLB of\n+individual regions.  Basically, when asked to compute the LUB/GLB of a\n+region variable with another region, the inferencer cannot oblige\n+immediately since the values of that variables are not known.\n+Therefore, it creates a new variable that is related to the two\n+regions.  For example, the LUB of two variables `$x` and `$y` is a\n+fresh variable `$z` that is constrained such that `$x <= $z` and `$y\n+<= $z`.  So `V` will contain these intermediate variables as well.\n+\n+The other important factor in deciding how to replace a region in T is\n+the function `Tainted($r)` which, for a region variable, identifies\n+all regions that the region variable is related to in some way\n+(`Tainted()` made an appearance in the subtype computation as well).\n+\n+### LUB\n+\n+The LUB algorithm proceeds in three steps:\n+\n+1. Replace all bound regions (on both sides) with fresh region\n+   inference variables.\n+2. Compute the LUB \"as normal\", meaning compute the GLB of each\n+   pair of argument types and the LUB of the return types and\n+   so forth.  Combine those to a new function type `F`.\n+3. Replace each region `R` that appears in `F` as follows:\n+   - Let `V` be the set of variables created during the LUB\n+     computational steps 1 and 2, as described in the previous section.\n+   - If `R` is not in `V`, replace `R` with itself.\n+   - If `Tainted(R)` contains a region that is not in `V`,\n+     replace `R` with itself.\n+   - Otherwise, select the earliest variable in `Tainted(R)` that originates\n+     from the left-hand side and replace `R` with the bound region that\n+     this variable was a replacement for.\n+\n+So, let's work through the simplest example: `fn(&A)` and `for<'a> fn(&a)`.\n+In this case, `&a` will be replaced with `$a` and the interim LUB type\n+`fn($b)` will be computed, where `$b=GLB(&A,$a)`.  Therefore, `V =\n+{$a, $b}` and `Tainted($b) = { $b, $a, &A }`.  When we go to replace\n+`$b`, we find that since `&A \\in Tainted($b)` is not a member of `V`,\n+we leave `$b` as is.  When region inference happens, `$b` will be\n+resolved to `&A`, as we wanted.\n+\n+Let's look at a more complex one: `fn(&a, &b)` and `fn(&x, &x)`.  In\n+this case, we'll end up with a (pre-replacement) LUB type of `fn(&g,\n+&h)` and a graph that looks like:\n+\n+```\n+     $a        $b     *--$x\n+       \\        \\    /  /\n+        \\        $h-*  /\n+         $g-----------*\n+```\n+\n+Here `$g` and `$h` are fresh variables that are created to represent\n+the LUB/GLB of things requiring inference.  This means that `V` and\n+`Tainted` will look like:\n+\n+```\n+V = {$a, $b, $g, $h, $x}\n+Tainted($g) = Tainted($h) = { $a, $b, $h, $g, $x }\n+```\n+\n+Therefore we replace both `$g` and `$h` with `$a`, and end up\n+with the type `fn(&a, &a)`.\n+\n+### GLB\n+\n+The procedure for computing the GLB is similar.  The difference lies\n+in computing the replacements for the various variables. For each\n+region `R` that appears in the type `F`, we again compute `Tainted(R)`\n+and examine the results:\n+\n+1. If `R` is not in `V`, it is not replaced.\n+2. Else, if `Tainted(R)` contains only variables in `V`, and it\n+   contains exactly one variable from the LHS and one variable from\n+   the RHS, then `R` can be mapped to the bound version of the\n+   variable from the LHS.\n+3. Else, if `Tainted(R)` contains no variable from the LHS and no\n+   variable from the RHS, then `R` can be mapped to itself.\n+4. Else, `R` is mapped to a fresh bound variable.\n+\n+These rules are pretty complex.  Let's look at some examples to see\n+how they play out.\n+\n+Out first example was `fn(&a)` and `fn(&X)`.  In this case, `&a` will\n+be replaced with `$a` and we will ultimately compute a\n+(pre-replacement) GLB type of `fn($g)` where `$g=LUB($a,&X)`.\n+Therefore, `V={$a,$g}` and `Tainted($g)={$g,$a,&X}.  To find the\n+replacement for `$g` we consult the rules above:\n+- Rule (1) does not apply because `$g \\in V`\n+- Rule (2) does not apply because `&X \\in Tainted($g)`\n+- Rule (3) does not apply because `$a \\in Tainted($g)`\n+- Hence, by rule (4), we replace `$g` with a fresh bound variable `&z`.\n+So our final result is `fn(&z)`, which is correct.\n+\n+The next example is `fn(&A)` and `fn(&Z)`. In this case, we will again\n+have a (pre-replacement) GLB of `fn(&g)`, where `$g = LUB(&A,&Z)`.\n+Therefore, `V={$g}` and `Tainted($g) = {$g, &A, &Z}`.  In this case,\n+by rule (3), `$g` is mapped to itself, and hence the result is\n+`fn($g)`.  This result is correct (in this case, at least), but it is\n+indicative of a case that *can* lead us into concluding that there is\n+no GLB when in fact a GLB does exist.  See the section \"Questionable\n+Results\" below for more details.\n+\n+The next example is `fn(&a, &b)` and `fn(&c, &c)`. In this case, as\n+before, we'll end up with `F=fn($g, $h)` where `Tainted($g) =\n+Tainted($h) = {$g, $h, $a, $b, $c}`.  Only rule (4) applies and hence\n+we'll select fresh bound variables `y` and `z` and wind up with\n+`fn(&y, &z)`.\n+\n+For the last example, let's consider what may seem trivial, but is\n+not: `fn(&a, &a)` and `fn(&b, &b)`.  In this case, we'll get `F=fn($g,\n+$h)` where `Tainted($g) = {$g, $a, $x}` and `Tainted($h) = {$h, $a,\n+$x}`.  Both of these sets contain exactly one bound variable from each\n+side, so we'll map them both to `&a`, resulting in `fn(&a, &a)`, which\n+is the desired result.\n+\n+### Shortcomings and correctness\n+\n+You may be wondering whether this algorithm is correct.  The answer is\n+\"sort of\".  There are definitely cases where they fail to compute a\n+result even though a correct result exists.  I believe, though, that\n+if they succeed, then the result is valid, and I will attempt to\n+convince you.  The basic argument is that the \"pre-replacement\" step\n+computes a set of constraints.  The replacements, then, attempt to\n+satisfy those constraints, using bound identifiers where needed.\n+\n+For now I will briefly go over the cases for LUB/GLB and identify\n+their intent:\n+\n+- LUB:\n+  - The region variables that are substituted in place of bound regions\n+    are intended to collect constraints on those bound regions.\n+  - If Tainted(R) contains only values in V, then this region is unconstrained\n+    and can therefore be generalized, otherwise it cannot.\n+- GLB:\n+  - The region variables that are substituted in place of bound regions\n+    are intended to collect constraints on those bound regions.\n+  - If Tainted(R) contains exactly one variable from each side, and\n+    only variables in V, that indicates that those two bound regions\n+    must be equated.\n+  - Otherwise, if Tainted(R) references any variables from left or right\n+    side, then it is trying to combine a bound region with a free one or\n+    multiple bound regions, so we need to select fresh bound regions.\n+\n+Sorry this is more of a shorthand to myself.  I will try to write up something\n+more convincing in the future.\n+\n+#### Where are the algorithms wrong?\n+\n+- The pre-replacement computation can fail even though using a\n+  bound-region would have succeeded.\n+- We will compute GLB(fn(fn($a)), fn(fn($b))) as fn($c) where $c is the\n+  GLB of $a and $b.  But if inference finds that $a and $b must be mapped\n+  to regions without a GLB, then this is effectively a failure to compute\n+  the GLB.  However, the result `fn<$c>(fn($c))` is a valid GLB.\n+\n+ */"}, {"sha": "09f0bbb2254ade3c9119f0d3f2c3ccc84f0b086b", "filename": "src/librustc/middle/typeck/infer/higher_ranked/mod.rs", "status": "added", "additions": 445, "deletions": 0, "changes": 445, "blob_url": "https://github.com/rust-lang/rust/blob/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=c8d6e3b2c2a780eff92299da5d1c02e081617088", "patch": "@@ -0,0 +1,445 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/*!\n+ * Helper routines for higher-ranked things. See the `doc` module at\n+ * the end of the file for details.\n+ */\n+\n+use middle::ty;\n+use middle::ty::replace_late_bound_regions;\n+use middle::typeck::infer::{mod, combine, cres, InferCtxt};\n+use middle::typeck::infer::combine::Combine;\n+use middle::typeck::infer::region_inference::{RegionMark};\n+use middle::ty_fold::{mod, HigherRankedFoldable, TypeFoldable};\n+use syntax::codemap::Span;\n+use util::nodemap::FnvHashMap;\n+use util::ppaux::{bound_region_to_string, Repr};\n+\n+pub trait HigherRankedCombineable : HigherRankedFoldable + TypeFoldable + Repr {\n+    fn super_combine<'tcx,C:Combine<'tcx>>(combiner: &C, a: &Self, b: &Self) -> cres<Self>;\n+}\n+\n+pub trait HigherRankedRelations {\n+    fn higher_ranked_sub<T>(&self, a: &T, b: &T) -> cres<T>\n+        where T : HigherRankedCombineable;\n+\n+    fn higher_ranked_lub<T>(&self, a: &T, b: &T) -> cres<T>\n+        where T : HigherRankedCombineable;\n+\n+    fn higher_ranked_glb<T>(&self, a: &T, b: &T) -> cres<T>\n+        where T : HigherRankedCombineable;\n+}\n+\n+impl<'tcx,C> HigherRankedRelations for C\n+    where C : Combine<'tcx>\n+{\n+    fn higher_ranked_sub<T>(&self, a: &T, b: &T) -> cres<T>\n+        where T : HigherRankedCombineable\n+    {\n+        debug!(\"higher_ranked_sub(a={}, b={})\",\n+               a.repr(self.tcx()), b.repr(self.tcx()));\n+\n+        // Rather than checking the subtype relationship between `a` and `b`\n+        // as-is, we need to do some extra work here in order to make sure\n+        // that function subtyping works correctly with respect to regions\n+        //\n+        // Note: this is a subtle algorithm.  For a full explanation,\n+        // please see the large comment at the end of the file in the (inlined) module\n+        // `doc`.\n+\n+        // Make a mark so we can examine \"all bindings that were\n+        // created as part of this type comparison\".\n+        let mark = self.infcx().region_vars.mark();\n+\n+        // First, we instantiate each bound region in the subtype with a fresh\n+        // region variable.\n+        let (a_prime, _) =\n+            self.infcx().replace_late_bound_regions_with_fresh_var(\n+                self.trace().origin.span(),\n+                infer::HigherRankedType,\n+                a);\n+\n+        // Second, we instantiate each bound region in the supertype with a\n+        // fresh concrete region.\n+        let (b_prime, skol_map) = {\n+            replace_late_bound_regions(self.tcx(), b, |br, _| {\n+                let skol = self.infcx().region_vars.new_skolemized(br);\n+                debug!(\"Bound region {} skolemized to {}\",\n+                       bound_region_to_string(self.tcx(), \"\", false, br),\n+                       skol);\n+                skol\n+            })\n+        };\n+\n+        debug!(\"a_prime={}\", a_prime.repr(self.tcx()));\n+        debug!(\"b_prime={}\", b_prime.repr(self.tcx()));\n+\n+        // Compare types now that bound regions have been replaced.\n+        let result = try!(HigherRankedCombineable::super_combine(self, &a_prime, &b_prime));\n+\n+        // Presuming type comparison succeeds, we need to check\n+        // that the skolemized regions do not \"leak\".\n+        let new_vars =\n+            self.infcx().region_vars.vars_created_since_mark(mark);\n+        for (&skol_br, &skol) in skol_map.iter() {\n+            let tainted = self.infcx().region_vars.tainted(mark, skol);\n+            for tainted_region in tainted.iter() {\n+                // Each skolemized should only be relatable to itself\n+                // or new variables:\n+                match *tainted_region {\n+                    ty::ReInfer(ty::ReVar(ref vid)) => {\n+                        if new_vars.iter().any(|x| x == vid) { continue; }\n+                    }\n+                    _ => {\n+                        if *tainted_region == skol { continue; }\n+                    }\n+                };\n+\n+                // A is not as polymorphic as B:\n+                if self.a_is_expected() {\n+                    debug!(\"Not as polymorphic!\");\n+                    return Err(ty::terr_regions_insufficiently_polymorphic(\n+                        skol_br, *tainted_region));\n+                } else {\n+                    debug!(\"Overly polymorphic!\");\n+                    return Err(ty::terr_regions_overly_polymorphic(\n+                        skol_br, *tainted_region));\n+                }\n+            }\n+        }\n+\n+        debug!(\"higher_ranked_sub: OK result={}\",\n+               result.repr(self.tcx()));\n+\n+        return Ok(result);\n+    }\n+\n+    fn higher_ranked_lub<T>(&self, a: &T, b: &T) -> cres<T>\n+        where T : HigherRankedCombineable\n+    {\n+        // Make a mark so we can examine \"all bindings that were\n+        // created as part of this type comparison\".\n+        let mark = self.infcx().region_vars.mark();\n+\n+        // Instantiate each bound region with a fresh region variable.\n+        let span = self.trace().origin.span();\n+        let (a_with_fresh, a_map) =\n+            self.infcx().replace_late_bound_regions_with_fresh_var(\n+                span, infer::HigherRankedType, a);\n+        let (b_with_fresh, _) =\n+            self.infcx().replace_late_bound_regions_with_fresh_var(\n+                span, infer::HigherRankedType, b);\n+\n+        // Collect constraints.\n+        let result0 =\n+            try!(HigherRankedCombineable::super_combine(self, &a_with_fresh, &b_with_fresh));\n+        debug!(\"lub result0 = {}\", result0.repr(self.tcx()));\n+\n+        // Generalize the regions appearing in result0 if possible\n+        let new_vars = self.infcx().region_vars.vars_created_since_mark(mark);\n+        let span = self.trace().origin.span();\n+        let result1 =\n+            fold_regions_in(\n+                self.tcx(),\n+                &result0,\n+                |r, debruijn| generalize_region(self.infcx(), span, mark, debruijn,\n+                                                new_vars.as_slice(), &a_map, r));\n+\n+        debug!(\"lub({},{}) = {}\",\n+               a.repr(self.tcx()),\n+               b.repr(self.tcx()),\n+               result1.repr(self.tcx()));\n+\n+        return Ok(result1);\n+\n+        fn generalize_region(infcx: &InferCtxt,\n+                             span: Span,\n+                             mark: RegionMark,\n+                             debruijn: ty::DebruijnIndex,\n+                             new_vars: &[ty::RegionVid],\n+                             a_map: &FnvHashMap<ty::BoundRegion, ty::Region>,\n+                             r0: ty::Region)\n+                             -> ty::Region {\n+            // Regions that pre-dated the LUB computation stay as they are.\n+            if !is_var_in_set(new_vars, r0) {\n+                assert!(!r0.is_bound());\n+                debug!(\"generalize_region(r0={}): not new variable\", r0);\n+                return r0;\n+            }\n+\n+            let tainted = infcx.region_vars.tainted(mark, r0);\n+\n+            // Variables created during LUB computation which are\n+            // *related* to regions that pre-date the LUB computation\n+            // stay as they are.\n+            if !tainted.iter().all(|r| is_var_in_set(new_vars, *r)) {\n+                debug!(\"generalize_region(r0={}): \\\n+                        non-new-variables found in {}\",\n+                       r0, tainted);\n+                assert!(!r0.is_bound());\n+                return r0;\n+            }\n+\n+            // Otherwise, the variable must be associated with at\n+            // least one of the variables representing bound regions\n+            // in both A and B.  Replace the variable with the \"first\"\n+            // bound region from A that we find it to be associated\n+            // with.\n+            for (a_br, a_r) in a_map.iter() {\n+                if tainted.iter().any(|x| x == a_r) {\n+                    debug!(\"generalize_region(r0={}): \\\n+                            replacing with {}, tainted={}\",\n+                           r0, *a_br, tainted);\n+                    return ty::ReLateBound(debruijn, *a_br);\n+                }\n+            }\n+\n+            infcx.tcx.sess.span_bug(\n+                span,\n+                format!(\"region {} is not associated with \\\n+                         any bound region from A!\",\n+                        r0).as_slice())\n+        }\n+    }\n+\n+    fn higher_ranked_glb<T>(&self, a: &T, b: &T) -> cres<T>\n+        where T : HigherRankedCombineable\n+    {\n+        debug!(\"{}.higher_ranked_glb({}, {})\",\n+               self.tag(), a.repr(self.tcx()), b.repr(self.tcx()));\n+\n+        // Make a mark so we can examine \"all bindings that were\n+        // created as part of this type comparison\".\n+        let mark = self.infcx().region_vars.mark();\n+\n+        // Instantiate each bound region with a fresh region variable.\n+        let (a_with_fresh, a_map) =\n+            self.infcx().replace_late_bound_regions_with_fresh_var(\n+                self.trace().origin.span(), infer::HigherRankedType, a);\n+        let (b_with_fresh, b_map) =\n+            self.infcx().replace_late_bound_regions_with_fresh_var(\n+                self.trace().origin.span(), infer::HigherRankedType, b);\n+        let a_vars = var_ids(self, &a_map);\n+        let b_vars = var_ids(self, &b_map);\n+\n+        // Collect constraints.\n+        let result0 =\n+            try!(HigherRankedCombineable::super_combine(self, &a_with_fresh, &b_with_fresh));\n+        debug!(\"glb result0 = {}\", result0.repr(self.tcx()));\n+\n+        // Generalize the regions appearing in fn_ty0 if possible\n+        let new_vars = self.infcx().region_vars.vars_created_since_mark(mark);\n+        let span = self.trace().origin.span();\n+        let result1 =\n+            fold_regions_in(\n+                self.tcx(),\n+                &result0,\n+                |r, debruijn| generalize_region(self.infcx(), span, mark, debruijn,\n+                                                new_vars.as_slice(),\n+                                                &a_map, a_vars.as_slice(), b_vars.as_slice(),\n+                                                r));\n+\n+        debug!(\"glb({},{}) = {}\",\n+               a.repr(self.tcx()),\n+               b.repr(self.tcx()),\n+               result1.repr(self.tcx()));\n+\n+        return Ok(result1);\n+\n+        fn generalize_region(infcx: &InferCtxt,\n+                             span: Span,\n+                             mark: RegionMark,\n+                             debruijn: ty::DebruijnIndex,\n+                             new_vars: &[ty::RegionVid],\n+                             a_map: &FnvHashMap<ty::BoundRegion, ty::Region>,\n+                             a_vars: &[ty::RegionVid],\n+                             b_vars: &[ty::RegionVid],\n+                             r0: ty::Region) -> ty::Region {\n+            if !is_var_in_set(new_vars, r0) {\n+                assert!(!r0.is_bound());\n+                return r0;\n+            }\n+\n+            let tainted = infcx.region_vars.tainted(mark, r0);\n+\n+            let mut a_r = None;\n+            let mut b_r = None;\n+            let mut only_new_vars = true;\n+            for r in tainted.iter() {\n+                if is_var_in_set(a_vars, *r) {\n+                    if a_r.is_some() {\n+                        return fresh_bound_variable(infcx, debruijn);\n+                    } else {\n+                        a_r = Some(*r);\n+                    }\n+                } else if is_var_in_set(b_vars, *r) {\n+                    if b_r.is_some() {\n+                        return fresh_bound_variable(infcx, debruijn);\n+                    } else {\n+                        b_r = Some(*r);\n+                    }\n+                } else if !is_var_in_set(new_vars, *r) {\n+                    only_new_vars = false;\n+                }\n+            }\n+\n+            // NB---I do not believe this algorithm computes\n+            // (necessarily) the GLB.  As written it can\n+            // spuriously fail. In particular, if there is a case\n+            // like: |fn(&a)| and fn(fn(&b)), where a and b are\n+            // free, it will return fn(&c) where c = GLB(a,b).  If\n+            // however this GLB is not defined, then the result is\n+            // an error, even though something like\n+            // \"fn<X>(fn(&X))\" where X is bound would be a\n+            // subtype of both of those.\n+            //\n+            // The problem is that if we were to return a bound\n+            // variable, we'd be computing a lower-bound, but not\n+            // necessarily the *greatest* lower-bound.\n+            //\n+            // Unfortunately, this problem is non-trivial to solve,\n+            // because we do not know at the time of computing the GLB\n+            // whether a GLB(a,b) exists or not, because we haven't\n+            // run region inference (or indeed, even fully computed\n+            // the region hierarchy!). The current algorithm seems to\n+            // works ok in practice.\n+\n+            if a_r.is_some() && b_r.is_some() && only_new_vars {\n+                // Related to exactly one bound variable from each fn:\n+                return rev_lookup(infcx, span, a_map, a_r.unwrap());\n+            } else if a_r.is_none() && b_r.is_none() {\n+                // Not related to bound variables from either fn:\n+                assert!(!r0.is_bound());\n+                return r0;\n+            } else {\n+                // Other:\n+                return fresh_bound_variable(infcx, debruijn);\n+            }\n+        }\n+\n+        fn rev_lookup(infcx: &InferCtxt,\n+                      span: Span,\n+                      a_map: &FnvHashMap<ty::BoundRegion, ty::Region>,\n+                      r: ty::Region) -> ty::Region\n+        {\n+            for (a_br, a_r) in a_map.iter() {\n+                if *a_r == r {\n+                    return ty::ReLateBound(ty::DebruijnIndex::new(1), *a_br);\n+                }\n+            }\n+            infcx.tcx.sess.span_bug(\n+                span,\n+                format!(\"could not find original bound region for {}\", r)[]);\n+        }\n+\n+        fn fresh_bound_variable(infcx: &InferCtxt, debruijn: ty::DebruijnIndex) -> ty::Region {\n+            infcx.region_vars.new_bound(debruijn)\n+        }\n+    }\n+}\n+\n+impl HigherRankedCombineable for ty::FnSig {\n+    fn super_combine<'tcx,C:Combine<'tcx>>(combiner: &C, a: &ty::FnSig, b: &ty::FnSig)\n+                                           -> cres<ty::FnSig>\n+    {\n+        if a.variadic != b.variadic {\n+            return Err(ty::terr_variadic_mismatch(\n+                combine::expected_found(combiner, a.variadic, b.variadic)));\n+        }\n+\n+        let inputs = try!(argvecs(combiner,\n+                                  a.inputs.as_slice(),\n+                                  b.inputs.as_slice()));\n+\n+        let output = try!(match (a.output, b.output) {\n+            (ty::FnConverging(a_ty), ty::FnConverging(b_ty)) =>\n+                Ok(ty::FnConverging(try!(combiner.tys(a_ty, b_ty)))),\n+            (ty::FnDiverging, ty::FnDiverging) =>\n+                Ok(ty::FnDiverging),\n+            (a, b) =>\n+                Err(ty::terr_convergence_mismatch(\n+                    combine::expected_found(combiner, a != ty::FnDiverging, b != ty::FnDiverging))),\n+        });\n+\n+        return Ok(ty::FnSig {inputs: inputs,\n+                             output: output,\n+                             variadic: a.variadic});\n+\n+\n+        fn argvecs<'tcx, C: Combine<'tcx>>(combiner: &C,\n+                                           a_args: &[ty::t],\n+                                           b_args: &[ty::t])\n+                                           -> cres<Vec<ty::t>>\n+        {\n+            if a_args.len() == b_args.len() {\n+                a_args.iter().zip(b_args.iter())\n+                    .map(|(a, b)| combiner.args(*a, *b)).collect()\n+            } else {\n+                Err(ty::terr_arg_count)\n+            }\n+        }\n+    }\n+}\n+\n+impl HigherRankedCombineable for ty::TraitRef {\n+    fn super_combine<'tcx,C:Combine<'tcx>>(combiner: &C, a: &ty::TraitRef, b: &ty::TraitRef)\n+                                           -> cres<ty::TraitRef>\n+    {\n+        // Different traits cannot be related\n+        if a.def_id != b.def_id {\n+            Err(ty::terr_traits(\n+                combine::expected_found(combiner, a.def_id, b.def_id)))\n+        } else {\n+            let substs = try!(combiner.substs(a.def_id, &a.substs, &b.substs));\n+            Ok(ty::TraitRef { def_id: a.def_id,\n+                              substs: substs })\n+        }\n+    }\n+}\n+\n+fn var_ids<'tcx, T: Combine<'tcx>>(combiner: &T,\n+                                   map: &FnvHashMap<ty::BoundRegion, ty::Region>)\n+                                   -> Vec<ty::RegionVid> {\n+    map.iter().map(|(_, r)| match *r {\n+            ty::ReInfer(ty::ReVar(r)) => { r }\n+            r => {\n+                combiner.infcx().tcx.sess.span_bug(\n+                    combiner.trace().origin.span(),\n+                    format!(\"found non-region-vid: {}\", r).as_slice());\n+            }\n+        }).collect()\n+}\n+\n+fn is_var_in_set(new_vars: &[ty::RegionVid], r: ty::Region) -> bool {\n+    match r {\n+        ty::ReInfer(ty::ReVar(ref v)) => new_vars.iter().any(|x| x == v),\n+        _ => false\n+    }\n+}\n+\n+fn fold_regions_in<T:HigherRankedFoldable>(tcx: &ty::ctxt,\n+                                           value: &T,\n+                                           fldr: |ty::Region, ty::DebruijnIndex| -> ty::Region)\n+                                           -> T\n+{\n+    value.fold_contents(&mut ty_fold::RegionFolder::new(tcx, |region, current_depth| {\n+        // we should only be encountering \"escaping\" late-bound regions here,\n+        // because the ones at the current level should have been replaced\n+        // with fresh variables\n+        assert!(match region {\n+            ty::ReLateBound(..) => false,\n+            _ => true\n+        });\n+\n+        fldr(region, ty::DebruijnIndex::new(current_depth))\n+    }))\n+}\n+"}, {"sha": "f7e6cef99af93660c4521a97c96e18aa8e66560f", "filename": "src/librustc/middle/typeck/infer/lattice.rs", "status": "modified", "additions": 1, "deletions": 26, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs?ref=c8d6e3b2c2a780eff92299da5d1c02e081617088", "patch": "@@ -31,13 +31,12 @@\n  * a lattice.\n  */\n \n-use middle::ty::{RegionVid, TyVar};\n+use middle::ty::{TyVar};\n use middle::ty;\n use middle::typeck::infer::*;\n use middle::typeck::infer::combine::*;\n use middle::typeck::infer::glb::Glb;\n use middle::typeck::infer::lub::Lub;\n-use util::nodemap::FnvHashMap;\n use util::ppaux::Repr;\n \n pub trait LatticeDir {\n@@ -101,27 +100,3 @@ pub fn super_lattice_tys<'tcx, L:LatticeDir+Combine<'tcx>>(this: &L,\n         }\n     }\n }\n-\n-///////////////////////////////////////////////////////////////////////////\n-// Random utility functions used by LUB/GLB when computing LUB/GLB of\n-// fn types\n-\n-pub fn var_ids<'tcx, T: Combine<'tcx>>(this: &T,\n-                                       map: &FnvHashMap<ty::BoundRegion, ty::Region>)\n-                                       -> Vec<RegionVid> {\n-    map.iter().map(|(_, r)| match *r {\n-            ty::ReInfer(ty::ReVar(r)) => { r }\n-            r => {\n-                this.infcx().tcx.sess.span_bug(\n-                    this.trace().origin.span(),\n-                    format!(\"found non-region-vid: {}\", r).as_slice());\n-            }\n-        }).collect()\n-}\n-\n-pub fn is_var_in_set(new_vars: &[RegionVid], r: ty::Region) -> bool {\n-    match r {\n-        ty::ReInfer(ty::ReVar(ref v)) => new_vars.iter().any(|x| x == v),\n-        _ => false\n-    }\n-}"}, {"sha": "8856f42d1f5ab6d0fa5366a95dc409193012f58a", "filename": "src/librustc/middle/typeck/infer/lub.rs", "status": "modified", "additions": 11, "deletions": 87, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs?ref=c8d6e3b2c2a780eff92299da5d1c02e081617088", "patch": "@@ -9,23 +9,19 @@\n // except according to those terms.\n \n use middle::ty::{BuiltinBounds};\n-use middle::ty::RegionVid;\n use middle::ty;\n use middle::typeck::infer::combine::*;\n use middle::typeck::infer::equate::Equate;\n use middle::typeck::infer::glb::Glb;\n+use middle::typeck::infer::higher_ranked::HigherRankedRelations;\n use middle::typeck::infer::lattice::*;\n-use middle::typeck::infer::LateBoundRegionConversionTime::FnType;\n use middle::typeck::infer::sub::Sub;\n use middle::typeck::infer::{cres, InferCtxt};\n-use middle::typeck::infer::fold_regions_in_sig;\n use middle::typeck::infer::{TypeTrace, Subtype};\n-use middle::typeck::infer::region_inference::RegionMark;\n-use syntax::ast::{Many, Once, NodeId};\n+use syntax::ast::{Many, Once};\n use syntax::ast::{NormalFn, UnsafeFn};\n use syntax::ast::{Onceness, FnStyle};\n use syntax::ast::{MutMutable, MutImmutable};\n-use util::nodemap::FnvHashMap;\n use util::ppaux::mt_to_string;\n use util::ppaux::Repr;\n \n@@ -51,7 +47,7 @@ impl<'f, 'tcx> Combine<'tcx> for Lub<'f, 'tcx> {\n     fn glb<'a>(&'a self) -> Glb<'a, 'tcx> { Glb(self.fields.clone()) }\n \n     fn mts(&self, a: &ty::mt, b: &ty::mt) -> cres<ty::mt> {\n-        let tcx = self.fields.infcx.tcx;\n+        let tcx = self.tcx();\n \n         debug!(\"{}.mts({}, {})\",\n                self.tag(),\n@@ -111,93 +107,21 @@ impl<'f, 'tcx> Combine<'tcx> for Lub<'f, 'tcx> {\n     fn regions(&self, a: ty::Region, b: ty::Region) -> cres<ty::Region> {\n         debug!(\"{}.regions({}, {})\",\n                self.tag(),\n-               a.repr(self.fields.infcx.tcx),\n-               b.repr(self.fields.infcx.tcx));\n+               a.repr(self.tcx()),\n+               b.repr(self.tcx()));\n \n-        Ok(self.fields.infcx.region_vars.lub_regions(Subtype(self.trace()), a, b))\n+        Ok(self.infcx().region_vars.lub_regions(Subtype(self.trace()), a, b))\n     }\n \n     fn fn_sigs(&self, a: &ty::FnSig, b: &ty::FnSig) -> cres<ty::FnSig> {\n-        // Note: this is a subtle algorithm.  For a full explanation,\n-        // please see the large comment in `region_inference.rs`.\n-\n-        // Make a mark so we can examine \"all bindings that were\n-        // created as part of this type comparison\".\n-        let mark = self.fields.infcx.region_vars.mark();\n-\n-        // Instantiate each bound region with a fresh region variable.\n-        let (a_with_fresh, a_map) =\n-            self.fields.infcx.replace_late_bound_regions_with_fresh_var(\n-                a.binder_id, self.trace().span(), FnType, a);\n-        let (b_with_fresh, _) =\n-            self.fields.infcx.replace_late_bound_regions_with_fresh_var(\n-                b.binder_id, self.trace().span(), FnType, b);\n-\n-        // Collect constraints.\n-        let sig0 = try!(super_fn_sigs(self, &a_with_fresh, &b_with_fresh));\n-        debug!(\"sig0 = {}\", sig0.repr(self.fields.infcx.tcx));\n-\n-        // Generalize the regions appearing in sig0 if possible\n-        let new_vars =\n-            self.fields.infcx.region_vars.vars_created_since_mark(mark);\n-        let sig1 =\n-            fold_regions_in_sig(\n-                self.fields.infcx.tcx,\n-                &sig0,\n-                |r| generalize_region(self, mark, new_vars.as_slice(),\n-                                      sig0.binder_id, &a_map, r));\n-        return Ok(sig1);\n-\n-        fn generalize_region(this: &Lub,\n-                             mark: RegionMark,\n-                             new_vars: &[RegionVid],\n-                             new_scope: NodeId,\n-                             a_map: &FnvHashMap<ty::BoundRegion, ty::Region>,\n-                             r0: ty::Region)\n-                             -> ty::Region {\n-            // Regions that pre-dated the LUB computation stay as they are.\n-            if !is_var_in_set(new_vars, r0) {\n-                assert!(!r0.is_bound());\n-                debug!(\"generalize_region(r0={}): not new variable\", r0);\n-                return r0;\n-            }\n-\n-            let tainted = this.fields.infcx.region_vars.tainted(mark, r0);\n-\n-            // Variables created during LUB computation which are\n-            // *related* to regions that pre-date the LUB computation\n-            // stay as they are.\n-            if !tainted.iter().all(|r| is_var_in_set(new_vars, *r)) {\n-                debug!(\"generalize_region(r0={}): \\\n-                        non-new-variables found in {}\",\n-                       r0, tainted);\n-                assert!(!r0.is_bound());\n-                return r0;\n-            }\n-\n-            // Otherwise, the variable must be associated with at\n-            // least one of the variables representing bound regions\n-            // in both A and B.  Replace the variable with the \"first\"\n-            // bound region from A that we find it to be associated\n-            // with.\n-            for (a_br, a_r) in a_map.iter() {\n-                if tainted.iter().any(|x| x == a_r) {\n-                    debug!(\"generalize_region(r0={}): \\\n-                            replacing with {}, tainted={}\",\n-                           r0, *a_br, tainted);\n-                    return ty::ReLateBound(new_scope, *a_br);\n-                }\n-            }\n-\n-            this.fields.infcx.tcx.sess.span_bug(\n-                this.fields.trace.origin.span(),\n-                format!(\"region {} is not associated with \\\n-                         any bound region from A!\",\n-                        r0).as_slice())\n-        }\n+        self.higher_ranked_lub(a, b)\n     }\n \n     fn tys(&self, a: ty::t, b: ty::t) -> cres<ty::t> {\n         super_lattice_tys(self, a, b)\n     }\n+\n+    fn trait_refs(&self, a: &ty::TraitRef, b: &ty::TraitRef) -> cres<ty::TraitRef> {\n+        self.higher_ranked_lub(a, b)\n+    }\n }"}, {"sha": "e69bd2157662e79414fc39570a2c2eca324d1fb4", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 20, "deletions": 32, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=c8d6e3b2c2a780eff92299da5d1c02e081617088", "patch": "@@ -31,10 +31,9 @@ pub use self::skolemize::TypeSkolemizer;\n use middle::subst;\n use middle::subst::Substs;\n use middle::ty::{TyVid, IntVid, FloatVid, RegionVid};\n+use middle::ty::replace_late_bound_regions;\n use middle::ty;\n-use middle::ty_fold;\n-use middle::ty_fold::{TypeFolder, TypeFoldable};\n-use middle::typeck::check::regionmanip::replace_late_bound_regions;\n+use middle::ty_fold::{HigherRankedFoldable, TypeFolder, TypeFoldable};\n use std::cell::{RefCell};\n use std::rc::Rc;\n use syntax::ast;\n@@ -61,6 +60,7 @@ pub mod doc;\n pub mod equate;\n pub mod error_reporting;\n pub mod glb;\n+pub mod higher_ranked;\n pub mod lattice;\n pub mod lub;\n pub mod region_inference;\n@@ -184,9 +184,9 @@ pub enum SubregionOrigin {\n     // type of the variable outlives the lifetime bound.\n     RelateProcBound(Span, ast::NodeId, ty::t),\n \n-    // The given type parameter was instantiated with the given type,\n+    // Some type parameter was instantiated with the given type,\n     // and that type must outlive some region.\n-    RelateParamBound(Span, ty::ParamTy, ty::t),\n+    RelateParamBound(Span, ty::t),\n \n     // The given region parameter was instantiated with a region\n     // that must outlive some other region.\n@@ -233,8 +233,8 @@ pub enum LateBoundRegionConversionTime {\n     /// when a fn is called\n     FnCall,\n \n-    /// when two fn types are compared\n-    FnType,\n+    /// when two higher-ranked types are compared\n+    HigherRankedType,\n }\n \n /// Reasons to create a region inference variable\n@@ -796,8 +796,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         subst::Substs::new_trait(type_parameters, regions, assoc_type_parameters, self_ty)\n     }\n \n-    pub fn fresh_bound_region(&self, binder_id: ast::NodeId) -> ty::Region {\n-        self.region_vars.new_bound(binder_id)\n+    pub fn fresh_bound_region(&self, debruijn: ty::DebruijnIndex) -> ty::Region {\n+        self.region_vars.new_bound(debruijn)\n     }\n \n     pub fn resolve_regions_and_report_errors(&self) {\n@@ -815,8 +815,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         format!(\"({})\", tstrs.connect(\", \"))\n     }\n \n-    pub fn trait_ref_to_string(&self, t: &ty::TraitRef) -> String {\n-        let t = self.resolve_type_vars_in_trait_ref_if_possible(t);\n+    pub fn trait_ref_to_string(&self, t: &Rc<ty::TraitRef>) -> String {\n+        let t = self.resolve_type_vars_in_trait_ref_if_possible(&**t);\n         trait_ref_to_string(self.tcx, &t)\n     }\n \n@@ -967,30 +967,19 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n     pub fn replace_late_bound_regions_with_fresh_var<T>(\n         &self,\n-        binder_id: ast::NodeId,\n         span: Span,\n         lbrct: LateBoundRegionConversionTime,\n         value: &T)\n         -> (T, FnvHashMap<ty::BoundRegion,ty::Region>)\n-        where T : TypeFoldable + Repr\n+        where T : HigherRankedFoldable\n     {\n-        let (map, value) =\n-            replace_late_bound_regions(\n-                self.tcx,\n-                binder_id,\n-                value,\n-                |br| self.next_region_var(LateBoundRegion(span, br, lbrct)));\n-        (value, map)\n+        ty::replace_late_bound_regions(\n+            self.tcx,\n+            value,\n+            |br, _| self.next_region_var(LateBoundRegion(span, br, lbrct)))\n     }\n }\n \n-pub fn fold_regions_in_sig(tcx: &ty::ctxt,\n-                           fn_sig: &ty::FnSig,\n-                           fldr: |r: ty::Region| -> ty::Region)\n-                           -> ty::FnSig {\n-    ty_fold::RegionFolder::regions(tcx, fldr).fold_sig(fn_sig)\n-}\n-\n impl TypeTrace {\n     pub fn span(&self) -> Span {\n         self.origin.span()\n@@ -1073,7 +1062,7 @@ impl SubregionOrigin {\n             IndexSlice(a) => a,\n             RelateObjectBound(a) => a,\n             RelateProcBound(a, _, _) => a,\n-            RelateParamBound(a, _, _) => a,\n+            RelateParamBound(a, _) => a,\n             RelateRegionParamBound(a) => a,\n             RelateDefaultParamBound(a, _) => a,\n             Reborrow(a) => a,\n@@ -1123,11 +1112,10 @@ impl Repr for SubregionOrigin {\n                         b,\n                         c.repr(tcx))\n             }\n-            RelateParamBound(a, b, c) => {\n-                format!(\"RelateParamBound({},{},{})\",\n+            RelateParamBound(a, b) => {\n+                format!(\"RelateParamBound({},{})\",\n                         a.repr(tcx),\n-                        b.repr(tcx),\n-                        c.repr(tcx))\n+                        b.repr(tcx))\n             }\n             RelateRegionParamBound(a) => {\n                 format!(\"RelateRegionParamBound({})\","}, {"sha": "40b41deeb2b66096cf78ddd979c994846d543224", "filename": "src/librustc/middle/typeck/infer/region_inference/doc.rs", "status": "modified", "additions": 3, "deletions": 398, "changes": 401, "blob_url": "https://github.com/rust-lang/rust/blob/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fdoc.rs?ref=c8d6e3b2c2a780eff92299da5d1c02e081617088", "patch": "@@ -370,404 +370,9 @@ address this problem somehow and make region inference somewhat more\n efficient. Note that this is solely a matter of performance, not\n expressiveness.\n \n-# Skolemization and functions\n+### Skolemization\n \n-One of the trickiest and most subtle aspects of regions is dealing\n-with the fact that region variables are bound in function types.  I\n-strongly suggest that if you want to understand the situation, you\n-read this paper (which is, admittedly, very long, but you don't have\n-to read the whole thing):\n-\n-http://research.microsoft.com/en-us/um/people/simonpj/papers/higher-rank/\n-\n-Although my explanation will never compete with SPJ's (for one thing,\n-his is approximately 100 pages), I will attempt to explain the basic\n-problem and also how we solve it.  Note that the paper only discusses\n-subtyping, not the computation of LUB/GLB.\n-\n-The problem we are addressing is that there is a kind of subtyping\n-between functions with bound region parameters.  Consider, for\n-example, whether the following relation holds:\n-\n-    fn(&'a int) <: |&'b int|? (Yes, a => b)\n-\n-The answer is that of course it does.  These two types are basically\n-the same, except that in one we used the name `a` and one we used\n-the name `b`.\n-\n-In the examples that follow, it becomes very important to know whether\n-a lifetime is bound in a function type (that is, is a lifetime\n-parameter) or appears free (is defined in some outer scope).\n-Therefore, from now on I will write the bindings explicitly, using a\n-notation like `fn<a>(&'a int)` to indicate that `a` is a lifetime\n-parameter.\n-\n-Now let's consider two more function types.  Here, we assume that the\n-`self` lifetime is defined somewhere outside and hence is not a\n-lifetime parameter bound by the function type (it \"appears free\"):\n-\n-    fn<a>(&'a int) <: |&'a int|? (Yes, a => self)\n-\n-This subtyping relation does in fact hold.  To see why, you have to\n-consider what subtyping means.  One way to look at `T1 <: T2` is to\n-say that it means that it is always ok to treat an instance of `T1` as\n-if it had the type `T2`.  So, with our functions, it is always ok to\n-treat a function that can take pointers with any lifetime as if it\n-were a function that can only take a pointer with the specific\n-lifetime `&self`.  After all, `&self` is a lifetime, after all, and\n-the function can take values of any lifetime.\n-\n-You can also look at subtyping as the *is a* relationship.  This amounts\n-to the same thing: a function that accepts pointers with any lifetime\n-*is a* function that accepts pointers with some specific lifetime.\n-\n-So, what if we reverse the order of the two function types, like this:\n-\n-    fn(&'a int) <: <a>|&'a int|? (No)\n-\n-Does the subtyping relationship still hold?  The answer of course is\n-no.  In this case, the function accepts *only the lifetime `&self`*,\n-so it is not reasonable to treat it as if it were a function that\n-accepted any lifetime.\n-\n-What about these two examples:\n-\n-    fn<a,b>(&'a int, &'b int) <: <a>|&'a int, &'a int|? (Yes)\n-    fn<a>(&'a int, &'a int) <: <a,b>|&'a int, &'b int|? (No)\n-\n-Here, it is true that functions which take two pointers with any two\n-lifetimes can be treated as if they only accepted two pointers with\n-the same lifetime, but not the reverse.\n-\n-## The algorithm\n-\n-Here is the algorithm we use to perform the subtyping check:\n-\n-1. Replace all bound regions in the subtype with new variables\n-2. Replace all bound regions in the supertype with skolemized\n-   equivalents.  A \"skolemized\" region is just a new fresh region\n-   name.\n-3. Check that the parameter and return types match as normal\n-4. Ensure that no skolemized regions 'leak' into region variables\n-   visible from \"the outside\"\n-\n-Let's walk through some examples and see how this algorithm plays out.\n-\n-#### First example\n-\n-We'll start with the first example, which was:\n-\n-    1. fn<a>(&'a T) <: <b>|&'b T|?        Yes: a -> b\n-\n-After steps 1 and 2 of the algorithm we will have replaced the types\n-like so:\n-\n-    1. fn(&'A T) <: |&'x T|?\n-\n-Here the upper case `&A` indicates a *region variable*, that is, a\n-region whose value is being inferred by the system.  I also replaced\n-`&b` with `&x`---I'll use letters late in the alphabet (`x`, `y`, `z`)\n-to indicate skolemized region names.  We can assume they don't appear\n-elsewhere.  Note that neither the sub- nor the supertype bind any\n-region names anymore (as indicated by the absence of `<` and `>`).\n-\n-The next step is to check that the parameter types match.  Because\n-parameters are contravariant, this means that we check whether:\n-\n-    &'x T <: &'A T\n-\n-Region pointers are contravariant so this implies that\n-\n-    &A <= &x\n-\n-must hold, where `<=` is the subregion relationship.  Processing\n-*this* constrain simply adds a constraint into our graph that `&A <=\n-&x` and is considered successful (it can, for example, be satisfied by\n-choosing the value `&x` for `&A`).\n-\n-So far we have encountered no error, so the subtype check succeeds.\n-\n-#### The third example\n-\n-Now let's look first at the third example, which was:\n-\n-    3. fn(&'a T)    <: <b>|&'b T|?        No!\n-\n-After steps 1 and 2 of the algorithm we will have replaced the types\n-like so:\n-\n-    3. fn(&'a T) <: |&'x T|?\n-\n-This looks pretty much the same as before, except that on the LHS\n-`&self` was not bound, and hence was left as-is and not replaced with\n-a variable.  The next step is again to check that the parameter types\n-match.  This will ultimately require (as before) that `&self` <= `&x`\n-must hold: but this does not hold.  `self` and `x` are both distinct\n-free regions.  So the subtype check fails.\n-\n-#### Checking for skolemization leaks\n-\n-You may be wondering about that mysterious last step in the algorithm.\n-So far it has not been relevant.  The purpose of that last step is to\n-catch something like *this*:\n-\n-    fn<a>() -> fn(&'a T) <: || -> fn<b>(&'b T)?   No.\n-\n-Here the function types are the same but for where the binding occurs.\n-The subtype returns a function that expects a value in precisely one\n-region.  The supertype returns a function that expects a value in any\n-region.  If we allow an instance of the subtype to be used where the\n-supertype is expected, then, someone could call the fn and think that\n-the return value has type `fn<b>(&'b T)` when it really has type\n-`fn(&'a T)` (this is case #3, above).  Bad.\n-\n-So let's step through what happens when we perform this subtype check.\n-We first replace the bound regions in the subtype (the supertype has\n-no bound regions).  This gives us:\n-\n-    fn() -> fn(&'A T) <: || -> fn<b>(&'b T)?\n-\n-Now we compare the return types, which are covariant, and hence we have:\n-\n-    fn(&'A T) <: <b>|&'b T|?\n-\n-Here we skolemize the bound region in the supertype to yield:\n-\n-    fn(&'A T) <: |&'x T|?\n-\n-And then proceed to compare the argument types:\n-\n-    &'x T <: &'A T\n-    &A <= &x\n-\n-Finally, this is where it gets interesting!  This is where an error\n-*should* be reported.  But in fact this will not happen.  The reason why\n-is that `A` is a variable: we will infer that its value is the fresh\n-region `x` and think that everything is happy.  In fact, this behavior\n-is *necessary*, it was key to the first example we walked through.\n-\n-The difference between this example and the first one is that the variable\n-`A` already existed at the point where the skolemization occurred.  In\n-the first example, you had two functions:\n-\n-    fn<a>(&'a T) <: <b>|&'b T|\n-\n-and hence `&A` and `&x` were created \"together\".  In general, the\n-intention of the skolemized names is that they are supposed to be\n-fresh names that could never be equal to anything from the outside.\n-But when inference comes into play, we might not be respecting this\n-rule.\n-\n-So the way we solve this is to add a fourth step that examines the\n-constraints that refer to skolemized names.  Basically, consider a\n-non-directed verison of the constraint graph.  Let `Tainted(x)` be the\n-set of all things reachable from a skolemized variable `x`.\n-`Tainted(x)` should not contain any regions that existed before the\n-step at which the skolemization was performed.  So this case here\n-would fail because `&x` was created alone, but is relatable to `&A`.\n-\n-## Computing the LUB and GLB\n-\n-The paper I pointed you at is written for Haskell.  It does not\n-therefore considering subtyping and in particular does not consider\n-LUB or GLB computation.  We have to consider this.  Here is the\n-algorithm I implemented.\n-\n-First though, let's discuss what we are trying to compute in more\n-detail.  The LUB is basically the \"common supertype\" and the GLB is\n-\"common subtype\"; one catch is that the LUB should be the\n-*most-specific* common supertype and the GLB should be *most general*\n-common subtype (as opposed to any common supertype or any common\n-subtype).\n-\n-Anyway, to help clarify, here is a table containing some\n-function pairs and their LUB/GLB:\n-\n-```\n-Type 1              Type 2              LUB               GLB\n-fn<a>(&a)           fn(&X)              fn(&X)            fn<a>(&a)\n-fn(&A)              fn(&X)              --                fn<a>(&a)\n-fn<a,b>(&a, &b)     fn<x>(&x, &x)       fn<a>(&a, &a)     fn<a,b>(&a, &b)\n-fn<a,b>(&a, &b, &a) fn<x,y>(&x, &y, &y) fn<a>(&a, &a, &a) fn<a,b,c>(&a,&b,&c)\n-```\n-\n-### Conventions\n-\n-I use lower-case letters (e.g., `&a`) for bound regions and upper-case\n-letters for free regions (`&A`).  Region variables written with a\n-dollar-sign (e.g., `$a`).  I will try to remember to enumerate the\n-bound-regions on the fn type as well (e.g., `fn<a>(&a)`).\n-\n-### High-level summary\n-\n-Both the LUB and the GLB algorithms work in a similar fashion.  They\n-begin by replacing all bound regions (on both sides) with fresh region\n-inference variables.  Therefore, both functions are converted to types\n-that contain only free regions.  We can then compute the LUB/GLB in a\n-straightforward way, as described in `combine.rs`.  This results in an\n-interim type T.  The algorithms then examine the regions that appear\n-in T and try to, in some cases, replace them with bound regions to\n-yield the final result.\n-\n-To decide whether to replace a region `R` that appears in `T` with a\n-bound region, the algorithms make use of two bits of information.\n-First is a set `V` that contains all region variables created as part\n-of the LUB/GLB computation. `V` will contain the region variables\n-created to replace the bound regions in the input types, but it also\n-contains 'intermediate' variables created to represent the LUB/GLB of\n-individual regions.  Basically, when asked to compute the LUB/GLB of a\n-region variable with another region, the inferencer cannot oblige\n-immediately since the values of that variables are not known.\n-Therefore, it creates a new variable that is related to the two\n-regions.  For example, the LUB of two variables `$x` and `$y` is a\n-fresh variable `$z` that is constrained such that `$x <= $z` and `$y\n-<= $z`.  So `V` will contain these intermediate variables as well.\n-\n-The other important factor in deciding how to replace a region in T is\n-the function `Tainted($r)` which, for a region variable, identifies\n-all regions that the region variable is related to in some way\n-(`Tainted()` made an appearance in the subtype computation as well).\n-\n-### LUB\n-\n-The LUB algorithm proceeds in three steps:\n-\n-1. Replace all bound regions (on both sides) with fresh region\n-   inference variables.\n-2. Compute the LUB \"as normal\", meaning compute the GLB of each\n-   pair of argument types and the LUB of the return types and\n-   so forth.  Combine those to a new function type `F`.\n-3. Replace each region `R` that appears in `F` as follows:\n-   - Let `V` be the set of variables created during the LUB\n-     computational steps 1 and 2, as described in the previous section.\n-   - If `R` is not in `V`, replace `R` with itself.\n-   - If `Tainted(R)` contains a region that is not in `V`,\n-     replace `R` with itself.\n-   - Otherwise, select the earliest variable in `Tainted(R)` that originates\n-     from the left-hand side and replace `R` with the bound region that\n-     this variable was a replacement for.\n-\n-So, let's work through the simplest example: `fn(&A)` and `fn<a>(&a)`.\n-In this case, `&a` will be replaced with `$a` and the interim LUB type\n-`fn($b)` will be computed, where `$b=GLB(&A,$a)`.  Therefore, `V =\n-{$a, $b}` and `Tainted($b) = { $b, $a, &A }`.  When we go to replace\n-`$b`, we find that since `&A \\in Tainted($b)` is not a member of `V`,\n-we leave `$b` as is.  When region inference happens, `$b` will be\n-resolved to `&A`, as we wanted.\n-\n-Let's look at a more complex one: `fn(&a, &b)` and `fn(&x, &x)`.  In\n-this case, we'll end up with a (pre-replacement) LUB type of `fn(&g,\n-&h)` and a graph that looks like:\n-\n-```\n-     $a        $b     *--$x\n-       \\        \\    /  /\n-        \\        $h-*  /\n-         $g-----------*\n-```\n-\n-Here `$g` and `$h` are fresh variables that are created to represent\n-the LUB/GLB of things requiring inference.  This means that `V` and\n-`Tainted` will look like:\n-\n-```\n-V = {$a, $b, $g, $h, $x}\n-Tainted($g) = Tainted($h) = { $a, $b, $h, $g, $x }\n-```\n-\n-Therefore we replace both `$g` and `$h` with `$a`, and end up\n-with the type `fn(&a, &a)`.\n-\n-### GLB\n-\n-The procedure for computing the GLB is similar.  The difference lies\n-in computing the replacements for the various variables. For each\n-region `R` that appears in the type `F`, we again compute `Tainted(R)`\n-and examine the results:\n-\n-1. If `R` is not in `V`, it is not replaced.\n-2. Else, if `Tainted(R)` contains only variables in `V`, and it\n-   contains exactly one variable from the LHS and one variable from\n-   the RHS, then `R` can be mapped to the bound version of the\n-   variable from the LHS.\n-3. Else, if `Tainted(R)` contains no variable from the LHS and no\n-   variable from the RHS, then `R` can be mapped to itself.\n-4. Else, `R` is mapped to a fresh bound variable.\n-\n-These rules are pretty complex.  Let's look at some examples to see\n-how they play out.\n-\n-Out first example was `fn(&a)` and `fn(&X)`.  In this case, `&a` will\n-be replaced with `$a` and we will ultimately compute a\n-(pre-replacement) GLB type of `fn($g)` where `$g=LUB($a,&X)`.\n-Therefore, `V={$a,$g}` and `Tainted($g)={$g,$a,&X}.  To find the\n-replacement for `$g` we consult the rules above:\n-- Rule (1) does not apply because `$g \\in V`\n-- Rule (2) does not apply because `&X \\in Tainted($g)`\n-- Rule (3) does not apply because `$a \\in Tainted($g)`\n-- Hence, by rule (4), we replace `$g` with a fresh bound variable `&z`.\n-So our final result is `fn(&z)`, which is correct.\n-\n-The next example is `fn(&A)` and `fn(&Z)`. In this case, we will again\n-have a (pre-replacement) GLB of `fn(&g)`, where `$g = LUB(&A,&Z)`.\n-Therefore, `V={$g}` and `Tainted($g) = {$g, &A, &Z}`.  In this case,\n-by rule (3), `$g` is mapped to itself, and hence the result is\n-`fn($g)`.  This result is correct (in this case, at least), but it is\n-indicative of a case that *can* lead us into concluding that there is\n-no GLB when in fact a GLB does exist.  See the section \"Questionable\n-Results\" below for more details.\n-\n-The next example is `fn(&a, &b)` and `fn(&c, &c)`. In this case, as\n-before, we'll end up with `F=fn($g, $h)` where `Tainted($g) =\n-Tainted($h) = {$g, $h, $a, $b, $c}`.  Only rule (4) applies and hence\n-we'll select fresh bound variables `y` and `z` and wind up with\n-`fn(&y, &z)`.\n-\n-For the last example, let's consider what may seem trivial, but is\n-not: `fn(&a, &a)` and `fn(&b, &b)`.  In this case, we'll get `F=fn($g,\n-$h)` where `Tainted($g) = {$g, $a, $x}` and `Tainted($h) = {$h, $a,\n-$x}`.  Both of these sets contain exactly one bound variable from each\n-side, so we'll map them both to `&a`, resulting in `fn(&a, &a)`, which\n-is the desired result.\n-\n-### Shortcomings and correctness\n-\n-You may be wondering whether this algorithm is correct.  The answer is\n-\"sort of\".  There are definitely cases where they fail to compute a\n-result even though a correct result exists.  I believe, though, that\n-if they succeed, then the result is valid, and I will attempt to\n-convince you.  The basic argument is that the \"pre-replacement\" step\n-computes a set of constraints.  The replacements, then, attempt to\n-satisfy those constraints, using bound identifiers where needed.\n-\n-For now I will briefly go over the cases for LUB/GLB and identify\n-their intent:\n-\n-- LUB:\n-  - The region variables that are substituted in place of bound regions\n-    are intended to collect constraints on those bound regions.\n-  - If Tainted(R) contains only values in V, then this region is unconstrained\n-    and can therefore be generalized, otherwise it cannot.\n-- GLB:\n-  - The region variables that are substituted in place of bound regions\n-    are intended to collect constraints on those bound regions.\n-  - If Tainted(R) contains exactly one variable from each side, and\n-    only variables in V, that indicates that those two bound regions\n-    must be equated.\n-  - Otherwise, if Tainted(R) references any variables from left or right\n-    side, then it is trying to combine a bound region with a free one or\n-    multiple bound regions, so we need to select fresh bound regions.\n-\n-Sorry this is more of a shorthand to myself.  I will try to write up something\n-more convincing in the future.\n-\n-#### Where are the algorithms wrong?\n-\n-- The pre-replacement computation can fail even though using a\n-  bound-region would have succeeded.\n-- We will compute GLB(fn(fn($a)), fn(fn($b))) as fn($c) where $c is the\n-  GLB of $a and $b.  But if inference finds that $a and $b must be mapped\n-  to regions without a GLB, then this is effectively a failure to compute\n-  the GLB.  However, the result `fn<$c>(fn($c))` is a valid GLB.\n+For a discussion on skolemization and higher-ranked subtyping, please\n+see the module `middle::typeck::infer::higher_ranked::doc`.\n \n */"}, {"sha": "54fb7872f3b03ccab1be84f4c66904c71dbf8d62", "filename": "src/librustc/middle/typeck/infer/region_inference/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs?ref=c8d6e3b2c2a780eff92299da5d1c02e081617088", "patch": "@@ -332,7 +332,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         ReInfer(ReSkolemized(sc, br))\n     }\n \n-    pub fn new_bound(&self, binder_id: ast::NodeId) -> Region {\n+    pub fn new_bound(&self, debruijn: ty::DebruijnIndex) -> Region {\n         // Creates a fresh bound variable for use in GLB computations.\n         // See discussion of GLB computation in the large comment at\n         // the top of this file for more details.\n@@ -358,7 +358,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n             self.tcx.sess.bug(\"rollover in RegionInference new_bound()\");\n         }\n \n-        ReLateBound(binder_id, BrFresh(sc))\n+        ReLateBound(debruijn, BrFresh(sc))\n     }\n \n     fn values_are_none(&self) -> bool {"}, {"sha": "f85cb85ff21a231c0e64c1d9d46c0ffaf5ed1aab", "filename": "src/librustc/middle/typeck/infer/sub.rs", "status": "modified", "additions": 12, "deletions": 80, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs?ref=c8d6e3b2c2a780eff92299da5d1c02e081617088", "patch": "@@ -12,18 +12,16 @@\n use middle::ty::{BuiltinBounds};\n use middle::ty;\n use middle::ty::TyVar;\n-use middle::typeck::check::regionmanip::replace_late_bound_regions;\n use middle::typeck::infer::combine::*;\n use middle::typeck::infer::{cres, CresCompare};\n use middle::typeck::infer::equate::Equate;\n-use middle::typeck::infer::LateBoundRegionConversionTime::FnType;\n use middle::typeck::infer::glb::Glb;\n+use middle::typeck::infer::higher_ranked::HigherRankedRelations;\n use middle::typeck::infer::InferCtxt;\n use middle::typeck::infer::lub::Lub;\n use middle::typeck::infer::{TypeTrace, Subtype};\n use middle::typeck::infer::type_variable::{SubtypeOf, SupertypeOf};\n-use util::common::{indenter};\n-use util::ppaux::{bound_region_to_string, Repr};\n+use util::ppaux::{Repr};\n \n use syntax::ast::{Onceness, FnStyle, MutImmutable, MutMutable};\n \n@@ -65,16 +63,16 @@ impl<'f, 'tcx> Combine<'tcx> for Sub<'f, 'tcx> {\n     fn regions(&self, a: ty::Region, b: ty::Region) -> cres<ty::Region> {\n         debug!(\"{}.regions({}, {})\",\n                self.tag(),\n-               a.repr(self.fields.infcx.tcx),\n-               b.repr(self.fields.infcx.tcx));\n-        self.fields.infcx.region_vars.make_subregion(Subtype(self.trace()), a, b);\n+               a.repr(self.tcx()),\n+               b.repr(self.tcx()));\n+        self.infcx().region_vars.make_subregion(Subtype(self.trace()), a, b);\n         Ok(a)\n     }\n \n     fn mts(&self, a: &ty::mt, b: &ty::mt) -> cres<ty::mt> {\n         debug!(\"mts({} <: {})\",\n-               a.repr(self.fields.infcx.tcx),\n-               b.repr(self.fields.infcx.tcx));\n+               a.repr(self.tcx()),\n+               b.repr(self.tcx()));\n \n         if a.mutbl != b.mutbl {\n             return Err(ty::terr_mutability);\n@@ -123,7 +121,7 @@ impl<'f, 'tcx> Combine<'tcx> for Sub<'f, 'tcx> {\n \n     fn tys(&self, a: ty::t, b: ty::t) -> cres<ty::t> {\n         debug!(\"{}.tys({}, {})\", self.tag(),\n-               a.repr(self.fields.infcx.tcx), b.repr(self.fields.infcx.tcx));\n+               a.repr(self.tcx()), b.repr(self.tcx()));\n         if a == b { return Ok(a); }\n \n         let infcx = self.fields.infcx;\n@@ -158,77 +156,11 @@ impl<'f, 'tcx> Combine<'tcx> for Sub<'f, 'tcx> {\n     }\n \n     fn fn_sigs(&self, a: &ty::FnSig, b: &ty::FnSig) -> cres<ty::FnSig> {\n-        debug!(\"fn_sigs(a={}, b={})\",\n-               a.repr(self.fields.infcx.tcx), b.repr(self.fields.infcx.tcx));\n-        let _indenter = indenter();\n-\n-        // Rather than checking the subtype relationship between `a` and `b`\n-        // as-is, we need to do some extra work here in order to make sure\n-        // that function subtyping works correctly with respect to regions\n-        //\n-        // Note: this is a subtle algorithm.  For a full explanation,\n-        // please see the large comment in `region_inference.rs`.\n-\n-        // Make a mark so we can examine \"all bindings that were\n-        // created as part of this type comparison\".\n-        let mark = self.fields.infcx.region_vars.mark();\n-\n-        // First, we instantiate each bound region in the subtype with a fresh\n-        // region variable.\n-        let (a_sig, _) =\n-            self.fields.infcx.replace_late_bound_regions_with_fresh_var(\n-                a.binder_id, self.trace().span(), FnType, a);\n-\n-        // Second, we instantiate each bound region in the supertype with a\n-        // fresh concrete region.\n-        let (skol_map, b_sig) = {\n-            replace_late_bound_regions(self.fields.infcx.tcx, b.binder_id, b, |br| {\n-                let skol = self.fields.infcx.region_vars.new_skolemized(br);\n-                debug!(\"Bound region {} skolemized to {}\",\n-                       bound_region_to_string(self.fields.infcx.tcx, \"\", false, br),\n-                       skol);\n-                skol\n-            })\n-        };\n-\n-        debug!(\"a_sig={}\", a_sig.repr(self.fields.infcx.tcx));\n-        debug!(\"b_sig={}\", b_sig.repr(self.fields.infcx.tcx));\n-\n-        // Compare types now that bound regions have been replaced.\n-        let sig = try!(super_fn_sigs(self, &a_sig, &b_sig));\n-\n-        // Presuming type comparison succeeds, we need to check\n-        // that the skolemized regions do not \"leak\".\n-        let new_vars =\n-            self.fields.infcx.region_vars.vars_created_since_mark(mark);\n-        for (&skol_br, &skol) in skol_map.iter() {\n-            let tainted = self.fields.infcx.region_vars.tainted(mark, skol);\n-            for tainted_region in tainted.iter() {\n-                // Each skolemized should only be relatable to itself\n-                // or new variables:\n-                match *tainted_region {\n-                    ty::ReInfer(ty::ReVar(ref vid)) => {\n-                        if new_vars.iter().any(|x| x == vid) { continue; }\n-                    }\n-                    _ => {\n-                        if *tainted_region == skol { continue; }\n-                    }\n-                };\n-\n-                // A is not as polymorphic as B:\n-                if self.a_is_expected() {\n-                    debug!(\"Not as polymorphic!\");\n-                    return Err(ty::terr_regions_insufficiently_polymorphic(\n-                        skol_br, *tainted_region));\n-                } else {\n-                    debug!(\"Overly polymorphic!\");\n-                    return Err(ty::terr_regions_overly_polymorphic(\n-                        skol_br, *tainted_region));\n-                }\n-            }\n-        }\n+        self.higher_ranked_sub(a, b)\n+    }\n \n-        return Ok(sig);\n+    fn trait_refs(&self, a: &ty::TraitRef, b: &ty::TraitRef) -> cres<ty::TraitRef> {\n+        self.higher_ranked_sub(a, b)\n     }\n }\n "}, {"sha": "24d11b25a60f2c3df05ced17d6568b3dcba8702a", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=c8d6e3b2c2a780eff92299da5d1c02e081617088", "patch": "@@ -383,7 +383,6 @@ fn check_main_fn_ty(ccx: &CrateCtxt,\n                 fn_style: ast::NormalFn,\n                 abi: abi::Rust,\n                 sig: ty::FnSig {\n-                    binder_id: main_id,\n                     inputs: Vec::new(),\n                     output: ty::FnConverging(ty::mk_nil(tcx)),\n                     variadic: false\n@@ -432,7 +431,6 @@ fn check_start_fn_ty(ccx: &CrateCtxt,\n                 fn_style: ast::NormalFn,\n                 abi: abi::Rust,\n                 sig: ty::FnSig {\n-                    binder_id: start_id,\n                     inputs: vec!(\n                         ty::mk_int(),\n                         ty::mk_imm_ptr(tcx, ty::mk_imm_ptr(tcx, ty::mk_u8()))"}, {"sha": "2f72d3cf50db1853dc64d35b903f313849f3d581", "filename": "src/librustc/middle/typeck/rscope.rs", "status": "modified", "additions": 40, "deletions": 5, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs?ref=c8d6e3b2c2a780eff92299da5d1c02e081617088", "patch": "@@ -10,9 +10,9 @@\n \n \n use middle::ty;\n+use middle::ty_fold;\n \n use std::cell::Cell;\n-use syntax::ast;\n use syntax::codemap::Span;\n \n /// Defines strategies for handling regions that are omitted.  For\n@@ -104,22 +104,20 @@ impl RegionScope for SpecificRscope {\n /// A scope in which we generate anonymous, late-bound regions for\n /// omitted regions. This occurs in function signatures.\n pub struct BindingRscope {\n-    binder_id: ast::NodeId,\n     anon_bindings: Cell<uint>,\n }\n \n impl BindingRscope {\n-    pub fn new(binder_id: ast::NodeId) -> BindingRscope {\n+    pub fn new() -> BindingRscope {\n         BindingRscope {\n-            binder_id: binder_id,\n             anon_bindings: Cell::new(0),\n         }\n     }\n \n     fn next_region(&self) -> ty::Region {\n         let idx = self.anon_bindings.get();\n         self.anon_bindings.set(idx + 1);\n-        ty::ReLateBound(self.binder_id, ty::BrAnon(idx))\n+        ty::ReLateBound(ty::DebruijnIndex::new(1), ty::BrAnon(idx))\n     }\n }\n \n@@ -138,3 +136,40 @@ impl RegionScope for BindingRscope {\n     }\n }\n \n+/// A scope which simply shifts the Debruijn index of other scopes\n+/// to account for binding levels.\n+pub struct ShiftedRscope<'r> {\n+    base_scope: &'r RegionScope+'r\n+}\n+\n+impl<'r> ShiftedRscope<'r> {\n+    pub fn new(base_scope: &'r RegionScope+'r) -> ShiftedRscope<'r> {\n+        ShiftedRscope { base_scope: base_scope }\n+    }\n+}\n+\n+impl<'r> RegionScope for ShiftedRscope<'r> {\n+    fn default_region_bound(&self, span: Span) -> Option<ty::Region>\n+    {\n+        self.base_scope.default_region_bound(span)\n+            .map(|r| ty_fold::shift_region(r, 1))\n+    }\n+\n+    fn anon_regions(&self,\n+                    span: Span,\n+                    count: uint)\n+                    -> Result<Vec<ty::Region>, Option<Vec<(String, uint)>>>\n+    {\n+        match self.base_scope.anon_regions(span, count) {\n+            Ok(mut v) => {\n+                for r in v.iter_mut() {\n+                    *r = ty_fold::shift_region(*r, 1);\n+                }\n+                Ok(v)\n+            }\n+            Err(errs) => {\n+                Err(errs)\n+            }\n+        }\n+    }\n+}"}, {"sha": "4ce783b37b73727e057f88e60283e8b1b148fe80", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 56, "deletions": 9, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=c8d6e3b2c2a780eff92299da5d1c02e081617088", "patch": "@@ -252,8 +252,7 @@ pub fn vec_map_to_string<T>(ts: &[T], f: |t: &T| -> String) -> String {\n }\n \n pub fn fn_sig_to_string(cx: &ctxt, typ: &ty::FnSig) -> String {\n-    format!(\"fn{}{} -> {}\", typ.binder_id, typ.inputs.repr(cx),\n-            typ.output.repr(cx))\n+    format!(\"fn{} -> {}\", typ.inputs.repr(cx), typ.output.repr(cx))\n }\n \n pub fn trait_ref_to_string(cx: &ctxt, trait_ref: &ty::TraitRef) -> String {\n@@ -262,11 +261,11 @@ pub fn trait_ref_to_string(cx: &ctxt, trait_ref: &ty::TraitRef) -> String {\n \n pub fn ty_to_string(cx: &ctxt, typ: t) -> String {\n     fn bare_fn_to_string(cx: &ctxt,\n-                      fn_style: ast::FnStyle,\n-                      abi: abi::Abi,\n-                      ident: Option<ast::Ident>,\n-                      sig: &ty::FnSig)\n-                      -> String {\n+                         fn_style: ast::FnStyle,\n+                         abi: abi::Abi,\n+                         ident: Option<ast::Ident>,\n+                         sig: &ty::FnSig)\n+                         -> String {\n         let mut s = String::new();\n         match fn_style {\n             ast::NormalFn => {}\n@@ -732,6 +731,9 @@ impl Repr for ty::ParamBounds {\n \n impl Repr for ty::TraitRef {\n     fn repr(&self, tcx: &ctxt) -> String {\n+        // when printing out the debug representation, we don't need\n+        // to enumerate the `for<...>` etc because the debruijn index\n+        // tells you everything you need to know.\n         let base = ty::item_path_str(tcx, self.def_id);\n         let trait_def = ty::lookup_trait_def(tcx, self.def_id);\n         format!(\"<{} : {}>\",\n@@ -922,6 +924,14 @@ impl Repr for ty::Generics {\n     }\n }\n \n+impl Repr for ty::GenericBounds {\n+    fn repr(&self, tcx: &ctxt) -> String {\n+        format!(\"GenericBounds(types: {}, regions: {})\",\n+                self.types.repr(tcx),\n+                self.regions.repr(tcx))\n+    }\n+}\n+\n impl Repr for ty::ItemVariances {\n     fn repr(&self, tcx: &ctxt) -> String {\n         format!(\"ItemVariances(types={}, \\\n@@ -1140,9 +1150,41 @@ impl UserString for ty::BuiltinBounds {\n \n impl UserString for ty::TraitRef {\n     fn user_string(&self, tcx: &ctxt) -> String {\n-        let base = ty::item_path_str(tcx, self.def_id);\n+        // Replace any anonymous late-bound regions with named\n+        // variants, using gensym'd identifiers, so that we can\n+        // clearly differentiate between named and unnamed regions in\n+        // the output. We'll probably want to tweak this over time to\n+        // decide just how much information to give.\n+        let mut names = Vec::new();\n+        let (trait_ref, _) = ty::replace_late_bound_regions(tcx, self, |br, debruijn| {\n+            ty::ReLateBound(debruijn, match br {\n+                ty::BrNamed(_, name) => {\n+                    names.push(token::get_name(name));\n+                    br\n+                }\n+                ty::BrAnon(_) |\n+                ty::BrFresh(_) |\n+                ty::BrEnv => {\n+                    let name = token::gensym(\"r\");\n+                    names.push(token::get_name(name));\n+                    ty::BrNamed(ast_util::local_def(ast::DUMMY_NODE_ID), name)\n+                }\n+            })\n+        });\n+        let names: Vec<_> = names.iter().map(|s| s.get()).collect();\n+\n+        // Let the base string be either `SomeTrait` for `for<'a,'b> SomeTrait`,\n+        // depending on whether there are bound regions.\n+        let path_str = ty::item_path_str(tcx, self.def_id);\n+        let base =\n+            if names.is_empty() {\n+                path_str\n+            } else {\n+                format!(\"for<{}> {}\", names.connect(\",\"), path_str)\n+            };\n+\n         let trait_def = ty::lookup_trait_def(tcx, self.def_id);\n-        parameterized(tcx, base.as_slice(), &self.substs, &trait_def.generics)\n+        parameterized(tcx, base.as_slice(), &trait_ref.substs, &trait_def.generics)\n     }\n }\n \n@@ -1301,3 +1343,8 @@ impl<A:Repr,B:Repr> Repr for (A,B) {\n     }\n }\n \n+impl<T:Repr> Repr for ty::Binder<T> {\n+    fn repr(&self, tcx: &ctxt) -> String {\n+        format!(\"Binder({})\", self.value.repr(tcx))\n+    }\n+}"}, {"sha": "a0e2bf07b830f94dc505173126b74530ac4959e5", "filename": "src/librustc_trans/driver/driver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Flibrustc_trans%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Flibrustc_trans%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdriver%2Fdriver.rs?ref=c8d6e3b2c2a780eff92299da5d1c02e081617088", "patch": "@@ -385,7 +385,7 @@ pub fn phase_3_run_analysis_passes<'tcx>(sess: Session,\n     syntax::ext::mtwt::clear_tables();\n \n     let named_region_map = time(time_passes, \"lifetime resolution\", (),\n-                                |_| middle::resolve_lifetime::krate(&sess, krate));\n+                                |_| middle::resolve_lifetime::krate(&sess, krate, &def_map));\n \n     time(time_passes, \"looking for entry point\", (),\n          |_| middle::entry::find_entry_point(&sess, &ast_map));"}, {"sha": "c9410d753ae6abd53cbc367d392aad14e281f1f1", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=c8d6e3b2c2a780eff92299da5d1c02e081617088", "patch": "@@ -1095,7 +1095,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                 fd: &'v ast::FnDecl,\n                 b: &'v ast::Block,\n                 s: Span,\n-                _: NodeId) {\n+                _: ast::NodeId) {\n         if generated_code(s) {\n             return;\n         }"}, {"sha": "a17702ac1dcaa0613c1953a9dcadefd0e26ef4f7", "filename": "src/librustc_trans/test.rs", "status": "modified", "additions": 289, "deletions": 107, "changes": 396, "blob_url": "https://github.com/rust-lang/rust/blob/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Flibrustc_trans%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Flibrustc_trans%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftest.rs?ref=c8d6e3b2c2a780eff92299da5d1c02e081617088", "patch": "@@ -14,9 +14,6 @@\n \n */\n \n-// This is only used by tests, hence allow dead code.\n-#![allow(dead_code)]\n-\n use driver::diagnostic;\n use driver::diagnostic::Emitter;\n use driver::driver;\n@@ -25,17 +22,20 @@ use middle::region;\n use middle::resolve;\n use middle::resolve_lifetime;\n use middle::stability;\n+use middle::subst;\n+use middle::subst::Subst;\n use middle::ty;\n use middle::typeck::infer::combine::Combine;\n use middle::typeck::infer;\n use middle::typeck::infer::lub::Lub;\n use middle::typeck::infer::glb::Glb;\n-use session::{mod, config};\n+use session::{mod,config};\n+use syntax::{abi, ast, ast_map, ast_util};\n use syntax::codemap;\n use syntax::codemap::{Span, CodeMap, DUMMY_SP};\n use syntax::diagnostic::{Level, RenderSpan, Bug, Fatal, Error, Warning, Note, Help};\n-use syntax::{ast, ast_map};\n-use util::ppaux::{ty_to_string, UserString};\n+use syntax::parse::token;\n+use util::ppaux::{ty_to_string, Repr, UserString};\n \n use arena::TypedArena;\n \n@@ -97,12 +97,12 @@ fn errors(msgs: &[&str]) -> (Box<Emitter+Send>, uint) {\n     (box ExpectErrorEmitter { messages: v } as Box<Emitter+Send>, msgs.len())\n }\n \n-fn test_env(_test_name: &str,\n-            source_string: &str,\n+fn test_env(source_string: &str,\n             (emitter, expected_err_count): (Box<Emitter+Send>, uint),\n             body: |Env|) {\n-    let options =\n+    let mut options =\n         config::basic_options();\n+    options.debugging_opts |= config::VERBOSE;\n     let codemap =\n         CodeMap::new();\n     let diagnostic_handler =\n@@ -125,7 +125,7 @@ fn test_env(_test_name: &str,\n     let lang_items = lang_items::collect_language_items(krate, &sess);\n     let resolve::CrateMap { def_map, freevars, capture_mode_map, .. } =\n         resolve::resolve_crate(&sess, &lang_items, krate);\n-    let named_region_map = resolve_lifetime::krate(&sess, krate);\n+    let named_region_map = resolve_lifetime::krate(&sess, krate, &def_map);\n     let region_map = region::resolve_crate(&sess, krate);\n     let stability_index = stability::Index::build(krate);\n     let type_arena = TypedArena::new();\n@@ -164,6 +164,7 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n                             sub: &[]}]});\n     }\n \n+    #[allow(dead_code)] // this seems like it could be useful, even if we don't use it now\n     pub fn lookup_item(&self, names: &[String]) -> ast::NodeId {\n         return match search_mod(self, &self.infcx.tcx.map.krate().module, 0, names) {\n             Some(id) => id,\n@@ -237,14 +238,6 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n         }\n     }\n \n-    pub fn assert_not_subtype(&self, a: ty::t, b: ty::t) {\n-        if self.is_subtype(a, b) {\n-            panic!(\"{} is a subtype of {}, but it shouldn't be\",\n-                  self.ty_to_string(a),\n-                  self.ty_to_string(b));\n-        }\n-    }\n-\n     pub fn assert_eq(&self, a: ty::t, b: ty::t) {\n         self.assert_subtype(a, b);\n         self.assert_subtype(b, a);\n@@ -255,36 +248,91 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n     }\n \n     pub fn t_fn(&self,\n-                binder_id: ast::NodeId,\n                 input_tys: &[ty::t],\n                 output_ty: ty::t)\n                 -> ty::t\n     {\n-        ty::mk_ctor_fn(self.infcx.tcx, binder_id, input_tys, output_ty)\n+        ty::mk_ctor_fn(self.infcx.tcx, input_tys, output_ty)\n+    }\n+\n+    pub fn t_nil(&self) -> ty::t {\n+        ty::mk_nil(self.infcx.tcx)\n+    }\n+\n+    pub fn t_pair(&self, ty1: ty::t, ty2: ty::t) -> ty::t\n+    {\n+        ty::mk_tup(self.infcx.tcx, vec![ty1, ty2])\n+    }\n+\n+    pub fn t_closure(&self,\n+                     input_tys: &[ty::t],\n+                     output_ty: ty::t,\n+                     region_bound: ty::Region)\n+                     -> ty::t\n+    {\n+        ty::mk_closure(self.infcx.tcx, ty::ClosureTy {\n+            fn_style: ast::NormalFn,\n+            onceness: ast::Many,\n+            store: ty::RegionTraitStore(region_bound, ast::MutMutable),\n+            bounds: ty::region_existential_bound(region_bound),\n+            sig: ty::FnSig {\n+                inputs: input_tys.to_vec(),\n+                output: ty::FnConverging(output_ty),\n+                variadic: false,\n+            },\n+            abi: abi::Rust,\n+        })\n+    }\n+\n+    pub fn t_param(&self, space: subst::ParamSpace, index: uint) -> ty::t {\n+        ty::mk_param(self.infcx.tcx, space, index, ast_util::local_def(ast::DUMMY_NODE_ID))\n+    }\n+\n+    pub fn re_early_bound(&self,\n+                          space: subst::ParamSpace,\n+                          index: uint,\n+                          name: &'static str)\n+                          -> ty::Region\n+    {\n+        let name = token::intern(name);\n+        ty::ReEarlyBound(ast::DUMMY_NODE_ID, space, index, name)\n+    }\n+\n+    pub fn re_late_bound_with_debruijn(&self, id: uint, debruijn: ty::DebruijnIndex) -> ty::Region {\n+        ty::ReLateBound(debruijn, ty::BrAnon(id))\n+    }\n+\n+    pub fn t_rptr(&self, r: ty::Region) -> ty::t {\n+        ty::mk_imm_rptr(self.infcx.tcx, r, ty::mk_int())\n     }\n \n-    pub fn t_int(&self) -> ty::t {\n-        ty::mk_int()\n+    pub fn t_rptr_late_bound(&self, id: uint) -> ty::t {\n+        ty::mk_imm_rptr(self.infcx.tcx,\n+                        self.re_late_bound_with_debruijn(id, ty::DebruijnIndex::new(1)),\n+                        ty::mk_int())\n     }\n \n-    pub fn t_rptr_late_bound(&self, binder_id: ast::NodeId, id: uint) -> ty::t {\n-        ty::mk_imm_rptr(self.infcx.tcx, ty::ReLateBound(binder_id, ty::BrAnon(id)),\n-                        self.t_int())\n+    pub fn t_rptr_late_bound_with_debruijn(&self, id: uint, debruijn: ty::DebruijnIndex) -> ty::t {\n+        ty::mk_imm_rptr(self.infcx.tcx,\n+                        self.re_late_bound_with_debruijn(id, debruijn),\n+                        ty::mk_int())\n     }\n \n     pub fn t_rptr_scope(&self, id: ast::NodeId) -> ty::t {\n-        ty::mk_imm_rptr(self.infcx.tcx, ty::ReScope(id), self.t_int())\n+        ty::mk_imm_rptr(self.infcx.tcx, ty::ReScope(id), ty::mk_int())\n+    }\n+\n+    pub fn re_free(&self, nid: ast::NodeId, id: uint) -> ty::Region {\n+        ty::ReFree(ty::FreeRegion {scope_id: nid,\n+                                   bound_region: ty::BrAnon(id)})\n     }\n \n     pub fn t_rptr_free(&self, nid: ast::NodeId, id: uint) -> ty::t {\n-        ty::mk_imm_rptr(self.infcx.tcx,\n-                        ty::ReFree(ty::FreeRegion {scope_id: nid,\n-                                                    bound_region: ty::BrAnon(id)}),\n-                        self.t_int())\n+        ty::mk_imm_rptr(self.infcx.tcx, self.re_free(nid, id), ty::mk_int())\n     }\n \n     pub fn t_rptr_static(&self) -> ty::t {\n-        ty::mk_imm_rptr(self.infcx.tcx, ty::ReStatic, self.t_int())\n+        ty::mk_imm_rptr(self.infcx.tcx, ty::ReStatic, ty::mk_int())\n     }\n \n     pub fn dummy_type_trace(&self) -> infer::TypeTrace {\n@@ -301,10 +349,6 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n         Glb(self.infcx.combine_fields(true, trace))\n     }\n \n-    pub fn resolve_regions(&self) {\n-        self.infcx.resolve_regions_and_report_errors();\n-    }\n-\n     pub fn make_lub_ty(&self, t1: ty::t, t2: ty::t) -> ty::t {\n         match self.lub().tys(t1, t2) {\n             Ok(t) => t,\n@@ -345,31 +389,11 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n             }\n         }\n     }\n-\n-    /// Checks that `LUB(t1,t2)` is undefined\n-    pub fn check_no_lub(&self, t1: ty::t, t2: ty::t) {\n-        match self.lub().tys(t1, t2) {\n-            Err(_) => {}\n-            Ok(t) => {\n-                panic!(\"unexpected success computing LUB: {}\", self.ty_to_string(t))\n-            }\n-        }\n-    }\n-\n-    /// Checks that `GLB(t1,t2)` is undefined\n-    pub fn check_no_glb(&self, t1: ty::t, t2: ty::t) {\n-        match self.glb().tys(t1, t2) {\n-            Err(_) => {}\n-            Ok(t) => {\n-                panic!(\"unexpected success computing GLB: {}\", self.ty_to_string(t))\n-            }\n-        }\n-    }\n }\n \n #[test]\n fn contravariant_region_ptr_ok() {\n-    test_env(\"contravariant_region_ptr\", EMPTY_SOURCE_STR, errors(&[]), |env| {\n+    test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n         env.create_simple_region_hierarchy();\n         let t_rptr1 = env.t_rptr_scope(1);\n         let t_rptr10 = env.t_rptr_scope(10);\n@@ -381,8 +405,7 @@ fn contravariant_region_ptr_ok() {\n \n #[test]\n fn contravariant_region_ptr_err() {\n-    test_env(\"contravariant_region_ptr\",\n-             EMPTY_SOURCE_STR,\n+    test_env(EMPTY_SOURCE_STR,\n              errors(&[\"lifetime mismatch\"]),\n              |env| {\n                  env.create_simple_region_hierarchy();\n@@ -398,114 +421,273 @@ fn contravariant_region_ptr_err() {\n \n #[test]\n fn lub_bound_bound() {\n-    test_env(\"contravariant_region_ptr\", EMPTY_SOURCE_STR, errors(&[]), |env| {\n-        let t_rptr_bound1 = env.t_rptr_late_bound(22, 1);\n-        let t_rptr_bound2 = env.t_rptr_late_bound(22, 2);\n-        env.check_lub(env.t_fn(22, &[t_rptr_bound1], env.t_int()),\n-                      env.t_fn(22, &[t_rptr_bound2], env.t_int()),\n-                      env.t_fn(22, &[t_rptr_bound1], env.t_int()));\n+    test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n+        let t_rptr_bound1 = env.t_rptr_late_bound(1);\n+        let t_rptr_bound2 = env.t_rptr_late_bound(2);\n+        env.check_lub(env.t_fn(&[t_rptr_bound1], ty::mk_int()),\n+                      env.t_fn(&[t_rptr_bound2], ty::mk_int()),\n+                      env.t_fn(&[t_rptr_bound1], ty::mk_int()));\n     })\n }\n \n #[test]\n fn lub_bound_free() {\n-    test_env(\"contravariant_region_ptr\", EMPTY_SOURCE_STR, errors(&[]), |env| {\n-        let t_rptr_bound1 = env.t_rptr_late_bound(22, 1);\n+    test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n+        let t_rptr_bound1 = env.t_rptr_late_bound(1);\n         let t_rptr_free1 = env.t_rptr_free(0, 1);\n-        env.check_lub(env.t_fn(22, &[t_rptr_bound1], env.t_int()),\n-                      env.t_fn(22, &[t_rptr_free1], env.t_int()),\n-                      env.t_fn(22, &[t_rptr_free1], env.t_int()));\n+        env.check_lub(env.t_fn(&[t_rptr_bound1], ty::mk_int()),\n+                      env.t_fn(&[t_rptr_free1], ty::mk_int()),\n+                      env.t_fn(&[t_rptr_free1], ty::mk_int()));\n     })\n }\n \n #[test]\n fn lub_bound_static() {\n-    test_env(\"contravariant_region_ptr\", EMPTY_SOURCE_STR, errors(&[]), |env| {\n-        let t_rptr_bound1 = env.t_rptr_late_bound(22, 1);\n+    test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n+        let t_rptr_bound1 = env.t_rptr_late_bound(1);\n         let t_rptr_static = env.t_rptr_static();\n-        env.check_lub(env.t_fn(22, &[t_rptr_bound1], env.t_int()),\n-                      env.t_fn(22, &[t_rptr_static], env.t_int()),\n-                      env.t_fn(22, &[t_rptr_static], env.t_int()));\n+        env.check_lub(env.t_fn(&[t_rptr_bound1], ty::mk_int()),\n+                      env.t_fn(&[t_rptr_static], ty::mk_int()),\n+                      env.t_fn(&[t_rptr_static], ty::mk_int()));\n     })\n }\n \n #[test]\n fn lub_bound_bound_inverse_order() {\n-    test_env(\"contravariant_region_ptr\", EMPTY_SOURCE_STR, errors(&[]), |env| {\n-        let t_rptr_bound1 = env.t_rptr_late_bound(22, 1);\n-        let t_rptr_bound2 = env.t_rptr_late_bound(22, 2);\n-        env.check_lub(env.t_fn(22, &[t_rptr_bound1, t_rptr_bound2], t_rptr_bound1),\n-                      env.t_fn(22, &[t_rptr_bound2, t_rptr_bound1], t_rptr_bound1),\n-                      env.t_fn(22, &[t_rptr_bound1, t_rptr_bound1], t_rptr_bound1));\n+    test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n+        let t_rptr_bound1 = env.t_rptr_late_bound(1);\n+        let t_rptr_bound2 = env.t_rptr_late_bound(2);\n+        env.check_lub(env.t_fn(&[t_rptr_bound1, t_rptr_bound2], t_rptr_bound1),\n+                      env.t_fn(&[t_rptr_bound2, t_rptr_bound1], t_rptr_bound1),\n+                      env.t_fn(&[t_rptr_bound1, t_rptr_bound1], t_rptr_bound1));\n     })\n }\n \n #[test]\n fn lub_free_free() {\n-    test_env(\"contravariant_region_ptr\", EMPTY_SOURCE_STR, errors(&[]), |env| {\n+    test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n         let t_rptr_free1 = env.t_rptr_free(0, 1);\n         let t_rptr_free2 = env.t_rptr_free(0, 2);\n         let t_rptr_static = env.t_rptr_static();\n-        env.check_lub(env.t_fn(22, &[t_rptr_free1], env.t_int()),\n-                      env.t_fn(22, &[t_rptr_free2], env.t_int()),\n-                      env.t_fn(22, &[t_rptr_static], env.t_int()));\n+        env.check_lub(env.t_fn(&[t_rptr_free1], ty::mk_int()),\n+                      env.t_fn(&[t_rptr_free2], ty::mk_int()),\n+                      env.t_fn(&[t_rptr_static], ty::mk_int()));\n     })\n }\n \n #[test]\n fn lub_returning_scope() {\n-    test_env(\"contravariant_region_ptr\", EMPTY_SOURCE_STR,\n+    test_env(EMPTY_SOURCE_STR,\n              errors(&[\"cannot infer an appropriate lifetime\"]), |env| {\n                  let t_rptr_scope10 = env.t_rptr_scope(10);\n                  let t_rptr_scope11 = env.t_rptr_scope(11);\n \n                  // this should generate an error when regions are resolved\n-                 env.make_lub_ty(env.t_fn(22, &[], t_rptr_scope10),\n-                                 env.t_fn(22, &[], t_rptr_scope11));\n+                 env.make_lub_ty(env.t_fn(&[], t_rptr_scope10),\n+                                 env.t_fn(&[], t_rptr_scope11));\n              })\n }\n \n #[test]\n fn glb_free_free_with_common_scope() {\n-    test_env(\"contravariant_region_ptr\", EMPTY_SOURCE_STR, errors(&[]), |env| {\n+    test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n         let t_rptr_free1 = env.t_rptr_free(0, 1);\n         let t_rptr_free2 = env.t_rptr_free(0, 2);\n         let t_rptr_scope = env.t_rptr_scope(0);\n-        env.check_glb(env.t_fn(22, &[t_rptr_free1], env.t_int()),\n-                      env.t_fn(22, &[t_rptr_free2], env.t_int()),\n-                      env.t_fn(22, &[t_rptr_scope], env.t_int()));\n+        env.check_glb(env.t_fn(&[t_rptr_free1], ty::mk_int()),\n+                      env.t_fn(&[t_rptr_free2], ty::mk_int()),\n+                      env.t_fn(&[t_rptr_scope], ty::mk_int()));\n     })\n }\n \n #[test]\n fn glb_bound_bound() {\n-    test_env(\"contravariant_region_ptr\", EMPTY_SOURCE_STR, errors(&[]), |env| {\n-        let t_rptr_bound1 = env.t_rptr_late_bound(22, 1);\n-        let t_rptr_bound2 = env.t_rptr_late_bound(22, 2);\n-        env.check_glb(env.t_fn(22, &[t_rptr_bound1], env.t_int()),\n-                      env.t_fn(22, &[t_rptr_bound2], env.t_int()),\n-                      env.t_fn(22, &[t_rptr_bound1], env.t_int()));\n+    test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n+        let t_rptr_bound1 = env.t_rptr_late_bound(1);\n+        let t_rptr_bound2 = env.t_rptr_late_bound(2);\n+        env.check_glb(env.t_fn(&[t_rptr_bound1], ty::mk_int()),\n+                      env.t_fn(&[t_rptr_bound2], ty::mk_int()),\n+                      env.t_fn(&[t_rptr_bound1], ty::mk_int()));\n     })\n }\n \n #[test]\n fn glb_bound_free() {\n-    test_env(\"contravariant_region_ptr\", EMPTY_SOURCE_STR, errors(&[]), |env| {\n-        let t_rptr_bound1 = env.t_rptr_late_bound(22, 1);\n+    test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n+        let t_rptr_bound1 = env.t_rptr_late_bound(1);\n         let t_rptr_free1 = env.t_rptr_free(0, 1);\n-        env.check_glb(env.t_fn(22, &[t_rptr_bound1], env.t_int()),\n-                      env.t_fn(22, &[t_rptr_free1], env.t_int()),\n-                      env.t_fn(22, &[t_rptr_bound1], env.t_int()));\n+        env.check_glb(env.t_fn(&[t_rptr_bound1], ty::mk_int()),\n+                      env.t_fn(&[t_rptr_free1], ty::mk_int()),\n+                      env.t_fn(&[t_rptr_bound1], ty::mk_int()));\n     })\n }\n \n #[test]\n fn glb_bound_static() {\n-    test_env(\"contravariant_region_ptr\", EMPTY_SOURCE_STR, errors(&[]), |env| {\n-        let t_rptr_bound1 = env.t_rptr_late_bound(22, 1);\n+    test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n+        let t_rptr_bound1 = env.t_rptr_late_bound(1);\n         let t_rptr_static = env.t_rptr_static();\n-        env.check_glb(env.t_fn(22, &[t_rptr_bound1], env.t_int()),\n-                      env.t_fn(22, &[t_rptr_static], env.t_int()),\n-                      env.t_fn(22, &[t_rptr_bound1], env.t_int()));\n+        env.check_glb(env.t_fn(&[t_rptr_bound1], ty::mk_int()),\n+                      env.t_fn(&[t_rptr_static], ty::mk_int()),\n+                      env.t_fn(&[t_rptr_bound1], ty::mk_int()));\n     })\n }\n+\n+#[test]\n+fn subst_ty_renumber_bound() {\n+    /*!\n+     * Test substituting a bound region into a function, which introduces another\n+     * level of binding. This requires adjusting the Debruijn index.\n+     */\n+\n+    test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n+        // Situation:\n+        // Theta = [A -> &'a foo]\n+\n+        let t_rptr_bound1 = env.t_rptr_late_bound(1);\n+\n+        // t_source = fn(A)\n+        let t_source = {\n+            let t_param = env.t_param(subst::TypeSpace, 0);\n+            env.t_fn(&[t_param], env.t_nil())\n+        };\n+\n+        let substs = subst::Substs::new_type(vec![t_rptr_bound1], vec![]);\n+        let t_substituted = t_source.subst(env.infcx.tcx, &substs);\n+\n+        // t_expected = fn(&'a int)\n+        let t_expected = {\n+            let t_ptr_bound2 = env.t_rptr_late_bound_with_debruijn(1, ty::DebruijnIndex::new(2));\n+            env.t_fn(&[t_ptr_bound2], env.t_nil())\n+        };\n+\n+        debug!(\"subst_bound: t_source={} substs={} t_substituted={} t_expected={}\",\n+               t_source.repr(env.infcx.tcx),\n+               substs.repr(env.infcx.tcx),\n+               t_substituted.repr(env.infcx.tcx),\n+               t_expected.repr(env.infcx.tcx));\n+\n+        assert_eq!(t_substituted, t_expected);\n+    })\n+}\n+\n+#[test]\n+fn subst_ty_renumber_some_bounds() {\n+    /*!\n+     * Test substituting a bound region into a function, which introduces another\n+     * level of binding. This requires adjusting the Debruijn index.\n+     */\n+\n+    test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n+        // Situation:\n+        // Theta = [A -> &'a foo]\n+\n+        let t_rptr_bound1 = env.t_rptr_late_bound(1);\n+\n+        // t_source = (A, fn(A))\n+        let t_source = {\n+            let t_param = env.t_param(subst::TypeSpace, 0);\n+            env.t_pair(t_param, env.t_fn(&[t_param], env.t_nil()))\n+        };\n+\n+        let substs = subst::Substs::new_type(vec![t_rptr_bound1], vec![]);\n+        let t_substituted = t_source.subst(env.infcx.tcx, &substs);\n+\n+        // t_expected = (&'a int, fn(&'a int))\n+        //\n+        // but not that the Debruijn index is different in the different cases.\n+        let t_expected = {\n+            let t_rptr_bound2 = env.t_rptr_late_bound_with_debruijn(1, ty::DebruijnIndex::new(2));\n+            env.t_pair(t_rptr_bound1, env.t_fn(&[t_rptr_bound2], env.t_nil()))\n+        };\n+\n+        debug!(\"subst_bound: t_source={} substs={} t_substituted={} t_expected={}\",\n+               t_source.repr(env.infcx.tcx),\n+               substs.repr(env.infcx.tcx),\n+               t_substituted.repr(env.infcx.tcx),\n+               t_expected.repr(env.infcx.tcx));\n+\n+        assert_eq!(t_substituted, t_expected);\n+    })\n+}\n+\n+#[test]\n+fn escaping() {\n+    /*!\n+     * Test that we correctly compute whether a type has escaping\n+     * regions or not.\n+     */\n+\n+    test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n+        // Situation:\n+        // Theta = [A -> &'a foo]\n+\n+        assert!(!ty::type_has_escaping_regions(env.t_nil()));\n+\n+        let t_rptr_free1 = env.t_rptr_free(0, 1);\n+        assert!(!ty::type_has_escaping_regions(t_rptr_free1));\n+\n+        let t_rptr_bound1 = env.t_rptr_late_bound_with_debruijn(1, ty::DebruijnIndex::new(1));\n+        assert!(ty::type_has_escaping_regions(t_rptr_bound1));\n+\n+        let t_rptr_bound2 = env.t_rptr_late_bound_with_debruijn(1, ty::DebruijnIndex::new(2));\n+        assert!(ty::type_has_escaping_regions(t_rptr_bound2));\n+\n+        // t_fn = fn(A)\n+        let t_param = env.t_param(subst::TypeSpace, 0);\n+        assert!(!ty::type_has_escaping_regions(t_param));\n+        let t_fn = env.t_fn(&[t_param], env.t_nil());\n+        assert!(!ty::type_has_escaping_regions(t_fn));\n+\n+        // t_fn = |&int|+'a\n+        let t_fn = env.t_closure(&[t_rptr_bound1], env.t_nil(), env.re_free(0, 1));\n+        assert!(!ty::type_has_escaping_regions(t_fn));\n+\n+        // t_fn = |&int|+'a (where &int has depth 2)\n+        let t_fn = env.t_closure(&[t_rptr_bound2], env.t_nil(), env.re_free(0, 1));\n+        assert!(ty::type_has_escaping_regions(t_fn));\n+\n+        // t_fn = |&int|+&int\n+        let t_fn = env.t_closure(&[t_rptr_bound1], env.t_nil(),\n+                                 env.re_late_bound_with_debruijn(1, ty::DebruijnIndex::new(1)));\n+        assert!(ty::type_has_escaping_regions(t_fn));\n+    })\n+}\n+\n+#[test]\n+fn subst_region_renumber_region() {\n+    /*!\n+     * Test applying a substitution where the value being substituted\n+     * for an early-bound region is a late-bound region.\n+     */\n+\n+    test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n+        let re_bound1 = env.re_late_bound_with_debruijn(1, ty::DebruijnIndex::new(1));\n+\n+        // type t_source<'a> = fn(&'a int)\n+        let t_source = {\n+            let re_early = env.re_early_bound(subst::TypeSpace, 0, \"'a\");\n+            env.t_fn(&[env.t_rptr(re_early)], env.t_nil())\n+        };\n+\n+        let substs = subst::Substs::new_type(vec![], vec![re_bound1]);\n+        let t_substituted = t_source.subst(env.infcx.tcx, &substs);\n+\n+        // t_expected = fn(&'a int)\n+        //\n+        // but not that the Debruijn index is different in the different cases.\n+        let t_expected = {\n+            let t_rptr_bound2 = env.t_rptr_late_bound_with_debruijn(1, ty::DebruijnIndex::new(2));\n+            env.t_fn(&[t_rptr_bound2], env.t_nil())\n+        };\n+\n+        debug!(\"subst_bound: t_source={} substs={} t_substituted={} t_expected={}\",\n+               t_source.repr(env.infcx.tcx),\n+               substs.repr(env.infcx.tcx),\n+               t_substituted.repr(env.infcx.tcx),\n+               t_expected.repr(env.infcx.tcx));\n+\n+        assert_eq!(t_substituted, t_expected);\n+    })\n+}\n+"}, {"sha": "9c4a532790ddea6e1993b3ac4095a3fce91d7d59", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=c8d6e3b2c2a780eff92299da5d1c02e081617088", "patch": "@@ -519,8 +519,9 @@ pub fn get_res_dtor(ccx: &CrateContext,\n         let name = csearch::get_symbol(&ccx.sess().cstore, did);\n         let class_ty = ty::lookup_item_type(tcx, parent_id).ty.subst(tcx, substs);\n         let llty = type_of_dtor(ccx, class_ty);\n-        let dtor_ty = ty::mk_ctor_fn(ccx.tcx(), ast::DUMMY_NODE_ID,\n-                                     &[glue::get_drop_glue_type(ccx, t)], ty::mk_nil(ccx.tcx()));\n+        let dtor_ty = ty::mk_ctor_fn(ccx.tcx(),\n+                                     &[glue::get_drop_glue_type(ccx, t)],\n+                                     ty::mk_nil(ccx.tcx()));\n         get_extern_fn(ccx,\n                       &mut *ccx.externs().borrow_mut(),\n                       name.as_slice(),"}, {"sha": "de49754fe7f9dfaac4f45779be723ab7685439a5", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=c8d6e3b2c2a780eff92299da5d1c02e081617088", "patch": "@@ -269,7 +269,6 @@ pub fn trans_unboxing_shim(bcx: Block,\n     let self_type = fty.sig.inputs[0];\n     let boxed_self_type = ty::mk_uniq(tcx, self_type);\n     let boxed_function_type = ty::FnSig {\n-        binder_id: fty.sig.binder_id,\n         inputs: fty.sig.inputs.iter().enumerate().map(|(i, typ)| {\n             if i == 0 {\n                 boxed_self_type\n@@ -294,7 +293,6 @@ pub fn trans_unboxing_shim(bcx: Block,\n             // RustCall so the untupled arguments can be passed\n             // through verbatim.  This is kind of ugly.\n             let fake_ty = ty::FnSig {\n-                binder_id: fty.sig.binder_id,\n                 inputs: type_of::untuple_arguments_if_necessary(ccx,\n                                                                 fty.sig.inputs.as_slice(),\n                                                                 fty.abi),\n@@ -434,6 +432,8 @@ pub fn trans_fn_ref_with_substs(\n            substs.repr(tcx));\n \n     assert!(substs.types.all(|t| !ty::type_needs_infer(*t)));\n+    assert!(substs.types.all(|t| !ty::type_has_escaping_regions(*t)));\n+    let substs = substs.erase_regions();\n \n     // Load the info for the appropriate trait if necessary.\n     match ty::trait_of_item(tcx, def_id) {\n@@ -467,13 +467,13 @@ pub fn trans_fn_ref_with_substs(\n             let impl_or_trait_item = ty::impl_or_trait_item(tcx, source_id);\n             match impl_or_trait_item {\n                 ty::MethodTraitItem(method) => {\n-                    let trait_ref = ty::impl_trait_ref(tcx, impl_id)\n-                        .expect(\"could not find trait_ref for impl with \\\n-                                 default methods\");\n+                    let trait_ref = ty::impl_trait_ref(tcx, impl_id).unwrap();\n+                    let trait_ref = ty::erase_late_bound_regions(tcx, &trait_ref);\n \n                     // Compute the first substitution\n-                    let first_subst = make_substs_for_receiver_types(\n-                        tcx, &*trait_ref, &*method);\n+                    let first_subst =\n+                        make_substs_for_receiver_types(tcx, &*trait_ref, &*method)\n+                        .erase_regions();\n \n                     // And compose them\n                     let new_substs = first_subst.subst(tcx, &substs);\n@@ -663,7 +663,7 @@ pub fn trans_lang_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                 trans_fn_ref_with_substs_to_callee(bcx,\n                                                                    did,\n                                                                    0,\n-                                                                   subst::Substs::empty())\n+                                                                   subst::Substs::trans_empty())\n                              },\n                              ArgVals(args),\n                              dest)"}, {"sha": "3cb823aec34c1c6e905d01c0c480d8350a8aee6d", "filename": "src/librustc_trans/trans/closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs?ref=c8d6e3b2c2a780eff92299da5d1c02e081617088", "patch": "@@ -486,7 +486,7 @@ pub fn trans_unboxed_closure<'blk, 'tcx>(\n     let llfn = get_or_create_declaration_if_unboxed_closure(\n         bcx,\n         closure_id,\n-        &bcx.fcx.param_substs.substs).unwrap();\n+        bcx.fcx.param_substs.substs()).unwrap();\n \n     let function_type = (*bcx.tcx().unboxed_closures.borrow())[closure_id]\n                                                               .closure_type"}, {"sha": "21cf313866144da8fd47f00dff90ff94fcc57d6d", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=c8d6e3b2c2a780eff92299da5d1c02e081617088", "patch": "@@ -191,10 +191,21 @@ pub type ExternMap = FnvHashMap<String, ValueRef>;\n // Here `self_ty` is the real type of the self parameter to this method. It\n // will only be set in the case of default methods.\n pub struct param_substs {\n-    pub substs: subst::Substs,\n+    substs: subst::Substs,\n }\n \n impl param_substs {\n+    pub fn new(substs: subst::Substs) -> param_substs {\n+        assert!(substs.types.all(|t| !ty::type_needs_infer(*t)));\n+        assert!(substs.types.all(|t| !ty::type_has_params(*t)));\n+        assert!(substs.types.all(|t| !ty::type_has_escaping_regions(*t)));\n+        param_substs { substs: substs.erase_regions() }\n+    }\n+\n+    pub fn substs(&self) -> &subst::Substs {\n+        &self.substs\n+    }\n+\n     pub fn empty() -> param_substs {\n         param_substs {\n             substs: subst::Substs::trans_empty(),\n@@ -822,6 +833,8 @@ pub fn fulfill_obligation(ccx: &CrateContext,\n         None => { }\n     }\n \n+    debug!(\"trans fulfill_obligation: trait_ref={}\", trait_ref.repr(ccx.tcx()));\n+\n     ty::populate_implementations_for_trait_if_necessary(tcx, trait_ref.def_id);\n     let infcx = infer::new_infer_ctxt(tcx);\n "}, {"sha": "65fd95667608a6f64bd9f0af540ba11dd6f32905", "filename": "src/librustc_trans/trans/debuginfo.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs?ref=c8d6e3b2c2a780eff92299da5d1c02e081617088", "patch": "@@ -1410,7 +1410,7 @@ pub fn create_function_debug_context(cx: &CrateContext,\n                                file_metadata: DIFile,\n                                name_to_append_suffix_to: &mut String)\n                                -> DIArray {\n-        let self_type = param_substs.substs.self_ty();\n+        let self_type = param_substs.substs().self_ty();\n \n         // Only true for static default methods:\n         let has_self_type = self_type.is_some();\n@@ -1467,7 +1467,7 @@ pub fn create_function_debug_context(cx: &CrateContext,\n         }\n \n         // Handle other generic parameters\n-        let actual_types = param_substs.substs.types.get_slice(subst::FnSpace);\n+        let actual_types = param_substs.substs().types.get_slice(subst::FnSpace);\n         for (index, &ast::TyParam{ ident, .. }) in generics.ty_params.iter().enumerate() {\n             let actual_type = actual_types[index];\n             // Add actual type name to <...> clause of function name"}, {"sha": "40a4d6047aa5387c02989176e93a91b5880823c4", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=c8d6e3b2c2a780eff92299da5d1c02e081617088", "patch": "@@ -329,12 +329,12 @@ fn apply_adjustments<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                           bcx.ty_to_string(unsized_ty)).as_slice())\n             },\n             &ty::UnsizeVtable(ty::TyTrait { ref principal, .. }, _) => {\n-                let substs = principal.substs.with_self_ty(unsized_ty);\n+                let substs = principal.substs.with_self_ty(unsized_ty).erase_regions();\n                 let trait_ref =\n                     Rc::new(ty::TraitRef { def_id: principal.def_id,\n                                            substs: substs });\n                 let trait_ref =\n-                    trait_ref.subst(bcx.tcx(), &bcx.fcx.param_substs.substs);\n+                    trait_ref.subst(bcx.tcx(), bcx.fcx.param_substs.substs());\n                 let box_ty = mk_ty(unsized_ty);\n                 PointerCast(bcx,\n                             meth::get_vtable(bcx, box_ty, trait_ref),\n@@ -1122,7 +1122,7 @@ fn trans_rvalue_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                              .map(|t| (*t).clone())\n                                              .unwrap();\n                 let trait_ref =\n-                    trait_ref.subst(bcx.tcx(), &bcx.fcx.param_substs.substs);\n+                    trait_ref.subst(bcx.tcx(), bcx.fcx.param_substs.substs());\n                 let datum = unpack_datum!(bcx, trans(bcx, &**val));\n                 meth::trans_trait_cast(bcx, datum, expr.id,\n                                        trait_ref, dest)"}, {"sha": "f86a0994bf95c9c3b52ad6dc3b9ba36da8f7f5cf", "filename": "src/librustc_trans/trans/foreign.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs?ref=c8d6e3b2c2a780eff92299da5d1c02e081617088", "patch": "@@ -536,7 +536,7 @@ pub fn trans_rust_fn_with_foreign_abi(ccx: &CrateContext,\n     let _icx = push_ctxt(\"foreign::build_foreign_fn\");\n \n     let fnty = ty::node_id_to_type(ccx.tcx(), id);\n-    let mty = fnty.subst(ccx.tcx(), &param_substs.substs);\n+    let mty = fnty.subst(ccx.tcx(), param_substs.substs());\n     let tys = foreign_types_for_fn_ty(ccx, mty);\n \n     unsafe { // unsafe because we call LLVM operations\n@@ -558,7 +558,7 @@ pub fn trans_rust_fn_with_foreign_abi(ccx: &CrateContext,\n         let _icx = push_ctxt(\"foreign::foreign::build_rust_fn\");\n         let tcx = ccx.tcx();\n         let t = ty::node_id_to_type(tcx, id).subst(\n-            ccx.tcx(), &param_substs.substs);\n+            ccx.tcx(), param_substs.substs());\n \n         let ps = ccx.tcx().map.with_path(id, |path| {\n             let abi = Some(ast_map::PathName(special_idents::clownshoe_abi.name));"}, {"sha": "5188ca773503abdbef3d822e6f9c6314a6ac7927", "filename": "src/librustc_trans/trans/glue.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fglue.rs?ref=c8d6e3b2c2a780eff92299da5d1c02e081617088", "patch": "@@ -287,8 +287,9 @@ fn trans_struct_drop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                              val, *ty);\n         }\n \n-        let dtor_ty = ty::mk_ctor_fn(variant_cx.tcx(), ast::DUMMY_NODE_ID,\n-                                     &[get_drop_glue_type(bcx.ccx(), t)], ty::mk_nil(bcx.tcx()));\n+        let dtor_ty = ty::mk_ctor_fn(bcx.tcx(),\n+                                     &[get_drop_glue_type(bcx.ccx(), t)],\n+                                     ty::mk_nil(bcx.tcx()));\n         let (_, variant_cx) = invoke(variant_cx, dtor_addr, args, dtor_ty, None, false);\n \n         variant_cx.fcx.pop_and_trans_custom_cleanup_scope(variant_cx, field_scope);"}, {"sha": "90777afff7e7204105cd026c0eef12bd4e241636", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=c8d6e3b2c2a780eff92299da5d1c02e081617088", "patch": "@@ -137,8 +137,11 @@ pub fn trans_method_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         }) => {\n             let trait_ref =\n                 Rc::new(trait_ref.subst(bcx.tcx(),\n-                                        &bcx.fcx.param_substs.substs));\n+                                        bcx.fcx.param_substs.substs()));\n             let span = bcx.tcx().map.span(method_call.expr_id);\n+            debug!(\"method_call={} trait_ref={}\",\n+                   method_call,\n+                   trait_ref.repr(bcx.tcx()));\n             let origin = fulfill_obligation(bcx.ccx(),\n                                             span,\n                                             (*trait_ref).clone());\n@@ -609,9 +612,6 @@ pub fn get_vtable(bcx: Block,\n                             fn_style: closure_info.closure_type.fn_style,\n                             abi: Rust,\n                             sig: ty::FnSig {\n-                                binder_id: closure_info.closure_type\n-                                                       .sig\n-                                                       .binder_id,\n                                 inputs: new_inputs,\n                                 output: new_output,\n                                 variadic: false,"}, {"sha": "52aa81fa427da2117117f3eee08899465fd7e8ab", "filename": "src/librustc_trans/trans/monomorphize.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs?ref=c8d6e3b2c2a780eff92299da5d1c02e081617088", "patch": "@@ -63,9 +63,8 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n         None => ()\n     }\n \n-    let psubsts = param_substs {\n-        substs: (*real_substs).clone(),\n-    };\n+    debug!(\"creating param_substs with real_substs={}\", real_substs.repr(ccx.tcx()));\n+    let psubsts = param_substs::new((*real_substs).clone());\n \n     debug!(\"monomorphic_fn(\\\n             fn_id={}, \\"}, {"sha": "15e14902727f5db6e4dff09d7e143b57a430bdc3", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=c8d6e3b2c2a780eff92299da5d1c02e081617088", "patch": "@@ -1154,7 +1154,7 @@ pub enum Ty_ {\n     /// Type parameters are stored in the Path itself\n     TyPath(Path, Option<TyParamBounds>, NodeId), // for #7264; see above\n     /// A type like `for<'a> Foo<&'a Bar>`\n-    TyPolyTraitRef(P<PolyTraitRef>),\n+    TyPolyTraitRef(TyParamBounds),\n     /// A \"qualified path\", e.g. `<Vec<T> as SomeTrait>::SomeType`\n     TyQPath(P<QPath>),\n     /// No-op; kept solely so that we can pretty-print faithfully"}, {"sha": "30cdecbc851999877562f804c51d37822e1f7196", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=c8d6e3b2c2a780eff92299da5d1c02e081617088", "patch": "@@ -494,10 +494,10 @@ impl<'a, 'v, O: IdVisitingOperation> Visitor<'v> for IdVisitor<'a, O> {\n         }\n \n         visit::walk_fn(self,\n-                        function_kind,\n-                        function_declaration,\n-                        block,\n-                        span);\n+                       function_kind,\n+                       function_declaration,\n+                       block,\n+                       span);\n \n         if !self.pass_through_items {\n             match function_kind {"}, {"sha": "ebdcf2789340227b0214e2c80e03579121c12583", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=c8d6e3b2c2a780eff92299da5d1c02e081617088", "patch": "@@ -58,8 +58,6 @@ static KNOWN_FEATURES: &'static [(&'static str, Status)] = &[\n     (\"quote\", Active),\n     (\"linkage\", Active),\n     (\"struct_inherit\", Removed),\n-    (\"overloaded_calls\", Active),\n-    (\"unboxed_closure_sugar\", Active),\n \n     (\"quad_precision_float\", Removed),\n \n@@ -102,7 +100,7 @@ enum Status {\n /// A set of features to be used by later passes.\n pub struct Features {\n     pub default_type_params: bool,\n-    pub overloaded_calls: bool,\n+    pub unboxed_closures: bool,\n     pub rustc_diagnostic_macros: bool,\n     pub import_shadowing: bool,\n     pub visible_private_types: bool,\n@@ -113,7 +111,7 @@ impl Features {\n     pub fn new() -> Features {\n         Features {\n             default_type_params: false,\n-            overloaded_calls: false,\n+            unboxed_closures: false,\n             rustc_diagnostic_macros: false,\n             import_shadowing: false,\n             visible_private_types: false,\n@@ -381,7 +379,7 @@ impl<'a, 'v> Visitor<'v> for Context<'a> {\n                 fn_decl: &'v ast::FnDecl,\n                 block: &'v ast::Block,\n                 span: Span,\n-                _: NodeId) {\n+                _node_id: NodeId) {\n         match fn_kind {\n             visit::FkItemFn(_, _, _, abi) if abi == RustIntrinsic => {\n                 self.gate_feature(\"intrinsics\",\n@@ -392,6 +390,19 @@ impl<'a, 'v> Visitor<'v> for Context<'a> {\n         }\n         visit::walk_fn(self, fn_kind, fn_decl, block, span);\n     }\n+\n+    fn visit_path_parameters(&mut self, path_span: Span, parameters: &'v ast::PathParameters) {\n+        match *parameters {\n+            ast::ParenthesizedParameters(..) => {\n+                self.gate_feature(\"unboxed_closures\",\n+                                  path_span,\n+                                  \"parenthetical parameter notation is subject to change\");\n+            }\n+            ast::AngleBracketedParameters(..) => { }\n+        }\n+\n+        visit::walk_path_parameters(self, path_span, parameters)\n+    }\n }\n \n pub fn check_crate(span_handler: &SpanHandler, krate: &ast::Crate) -> (Features, Vec<Span>) {\n@@ -446,7 +457,7 @@ pub fn check_crate(span_handler: &SpanHandler, krate: &ast::Crate) -> (Features,\n \n     (Features {\n         default_type_params: cx.has_feature(\"default_type_params\"),\n-        overloaded_calls: cx.has_feature(\"overloaded_calls\"),\n+        unboxed_closures: cx.has_feature(\"unboxed_closures\"),\n         rustc_diagnostic_macros: cx.has_feature(\"rustc_diagnostic_macros\"),\n         import_shadowing: cx.has_feature(\"import_shadowing\"),\n         visible_private_types: cx.has_feature(\"visible_private_types\"),"}, {"sha": "b3137ff5f7e52c0acd00cac02a9b748dfffcade9", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=c8d6e3b2c2a780eff92299da5d1c02e081617088", "patch": "@@ -445,10 +445,12 @@ pub fn noop_fold_ty<T: Folder>(t: P<Ty>, fld: &mut T) -> P<Ty> {\n             TyFixedLengthVec(ty, e) => {\n                 TyFixedLengthVec(fld.fold_ty(ty), fld.fold_expr(e))\n             }\n-            TyTypeof(expr) => TyTypeof(fld.fold_expr(expr)),\n-            TyPolyTraitRef(poly_trait_ref) => {\n-                TyPolyTraitRef(poly_trait_ref.map(|p| fld.fold_poly_trait_ref(p)))\n-            },\n+            TyTypeof(expr) => {\n+                TyTypeof(fld.fold_expr(expr))\n+            }\n+            TyPolyTraitRef(bounds) => {\n+                TyPolyTraitRef(bounds.move_map(|b| fld.fold_ty_param_bound(b)))\n+            }\n         },\n         span: fld.new_span(span)\n     })"}, {"sha": "40c4ac9f8c04418fa2b1a811fcf2dfaff73e9ee5", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=c8d6e3b2c2a780eff92299da5d1c02e081617088", "patch": "@@ -1023,10 +1023,21 @@ impl<'a> Parser<'a> {\n             self.parse_ty_bare_fn_or_ty_closure(lifetime_defs)\n         } else if self.token == token::ModSep ||\n                   self.token.is_ident() ||\n-                  self.token.is_path() {\n+                  self.token.is_path()\n+        {\n             let trait_ref = self.parse_trait_ref();\n-            TyPolyTraitRef(P(PolyTraitRef { bound_lifetimes: lifetime_defs,\n-                                            trait_ref: trait_ref }))\n+            let poly_trait_ref = ast::PolyTraitRef { bound_lifetimes: lifetime_defs,\n+                                                     trait_ref: trait_ref };\n+            let other_bounds = if self.eat(&token::BinOp(token::Plus)) {\n+                self.parse_ty_param_bounds()\n+            } else {\n+                OwnedSlice::empty()\n+            };\n+            let all_bounds =\n+                Some(TraitTyParamBound(poly_trait_ref)).into_iter()\n+                .chain(other_bounds.into_vec().into_iter())\n+                .collect();\n+            ast::TyPolyTraitRef(all_bounds)\n         } else {\n             self.parse_ty_closure(lifetime_defs)\n         }"}, {"sha": "e6e0c33a42dbdf0497ddb841ba33f3d09cacf429", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=c8d6e3b2c2a780eff92299da5d1c02e081617088", "patch": "@@ -739,8 +739,8 @@ impl<'a> State<'a> {\n             ast::TyPath(ref path, ref bounds, _) => {\n                 try!(self.print_bounded_path(path, bounds));\n             }\n-            ast::TyPolyTraitRef(ref poly_trait_ref) => {\n-                try!(self.print_poly_trait_ref(&**poly_trait_ref));\n+            ast::TyPolyTraitRef(ref bounds) => {\n+                try!(self.print_bounds(\"\", bounds));\n             }\n             ast::TyQPath(ref qpath) => {\n                 try!(word(&mut self.s, \"<\"));"}, {"sha": "efe1e18eda92872d6b2800373a4e64034cb45727", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 70, "deletions": 42, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=c8d6e3b2c2a780eff92299da5d1c02e081617088", "patch": "@@ -78,6 +78,9 @@ pub trait Visitor<'v> {\n     fn visit_ty_method(&mut self, t: &'v TypeMethod) { walk_ty_method(self, t) }\n     fn visit_trait_item(&mut self, t: &'v TraitItem) { walk_trait_item(self, t) }\n     fn visit_trait_ref(&mut self, t: &'v TraitRef) { walk_trait_ref(self, t) }\n+    fn visit_ty_param_bound(&mut self, bounds: &'v TyParamBound) {\n+        walk_ty_param_bound(self, bounds)\n+    }\n     fn visit_poly_trait_ref(&mut self, t: &'v PolyTraitRef) {\n         walk_poly_trait_ref(self, t)\n     }\n@@ -119,6 +122,12 @@ pub trait Visitor<'v> {\n     fn visit_path(&mut self, path: &'v Path, _id: ast::NodeId) {\n         walk_path(self, path)\n     }\n+    fn visit_path_segment(&mut self, path_span: Span, path_segment: &'v PathSegment) {\n+        walk_path_segment(self, path_span, path_segment)\n+    }\n+    fn visit_path_parameters(&mut self, path_span: Span, path_parameters: &'v PathParameters) {\n+        walk_path_parameters(self, path_span, path_parameters)\n+    }\n     fn visit_attribute(&mut self, _attr: &'v Attribute) {}\n }\n \n@@ -170,7 +179,7 @@ pub fn walk_view_item<'v, V: Visitor<'v>>(visitor: &mut V, vi: &'v ViewItem) {\n                 ViewPathGlob(ref path, id) => {\n                     visitor.visit_path(path, id);\n                 }\n-                ViewPathList(ref path, ref list, _) => {\n+                ViewPathList(ref prefix, ref list, _) => {\n                     for id in list.iter() {\n                         match id.node {\n                             PathListIdent { name, .. } => {\n@@ -179,7 +188,10 @@ pub fn walk_view_item<'v, V: Visitor<'v>>(visitor: &mut V, vi: &'v ViewItem) {\n                             PathListMod { .. } => ()\n                         }\n                     }\n-                    walk_path(visitor, path);\n+\n+                    // Note that the `prefix` here is not a complete\n+                    // path, so we don't use `visit_path`.\n+                    walk_path(visitor, prefix);\n                 }\n             }\n         }\n@@ -212,7 +224,7 @@ pub fn walk_poly_trait_ref<'v, V>(visitor: &mut V,\n                                          trait_ref: &'v PolyTraitRef)\n     where V: Visitor<'v>\n {\n-    walk_lifetime_decls(visitor, &trait_ref.bound_lifetimes);\n+    walk_lifetime_decls_helper(visitor, &trait_ref.bound_lifetimes);\n     visitor.visit_trait_ref(&trait_ref.trait_ref);\n }\n \n@@ -290,7 +302,7 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item) {\n         }\n         ItemTrait(ref generics, _, ref bounds, ref methods) => {\n             visitor.visit_generics(generics);\n-            walk_ty_param_bounds(visitor, bounds);\n+            walk_ty_param_bounds_helper(visitor, bounds);\n             for method in methods.iter() {\n                 visitor.visit_trait_item(method)\n             }\n@@ -363,29 +375,29 @@ pub fn walk_ty<'v, V: Visitor<'v>>(visitor: &mut V, typ: &'v Ty) {\n                 visitor.visit_ty(&*argument.ty)\n             }\n             walk_fn_ret_ty(visitor, &function_declaration.decl.output);\n-            walk_ty_param_bounds(visitor, &function_declaration.bounds);\n-            walk_lifetime_decls(visitor, &function_declaration.lifetimes);\n+            walk_ty_param_bounds_helper(visitor, &function_declaration.bounds);\n+            walk_lifetime_decls_helper(visitor, &function_declaration.lifetimes);\n         }\n         TyProc(ref function_declaration) => {\n             for argument in function_declaration.decl.inputs.iter() {\n                 visitor.visit_ty(&*argument.ty)\n             }\n             walk_fn_ret_ty(visitor, &function_declaration.decl.output);\n-            walk_ty_param_bounds(visitor, &function_declaration.bounds);\n-            walk_lifetime_decls(visitor, &function_declaration.lifetimes);\n+            walk_ty_param_bounds_helper(visitor, &function_declaration.bounds);\n+            walk_lifetime_decls_helper(visitor, &function_declaration.lifetimes);\n         }\n         TyBareFn(ref function_declaration) => {\n             for argument in function_declaration.decl.inputs.iter() {\n                 visitor.visit_ty(&*argument.ty)\n             }\n             walk_fn_ret_ty(visitor, &function_declaration.decl.output);\n-            walk_lifetime_decls(visitor, &function_declaration.lifetimes);\n+            walk_lifetime_decls_helper(visitor, &function_declaration.lifetimes);\n         }\n         TyPath(ref path, ref opt_bounds, id) => {\n             visitor.visit_path(path, id);\n             match *opt_bounds {\n                 Some(ref bounds) => {\n-                    walk_ty_param_bounds(visitor, bounds);\n+                    walk_ty_param_bounds_helper(visitor, bounds);\n                 }\n                 None => { }\n             }\n@@ -399,8 +411,8 @@ pub fn walk_ty<'v, V: Visitor<'v>>(visitor: &mut V, typ: &'v Ty) {\n             visitor.visit_ty(&**ty);\n             visitor.visit_expr(&**expression)\n         }\n-        TyPolyTraitRef(ref poly_trait_ref) => {\n-            visitor.visit_poly_trait_ref(&**poly_trait_ref)\n+        TyPolyTraitRef(ref bounds) => {\n+            walk_ty_param_bounds_helper(visitor, bounds)\n         }\n         TyTypeof(ref expression) => {\n             visitor.visit_expr(&**expression)\n@@ -409,33 +421,44 @@ pub fn walk_ty<'v, V: Visitor<'v>>(visitor: &mut V, typ: &'v Ty) {\n     }\n }\n \n-fn walk_lifetime_decls<'v, V: Visitor<'v>>(visitor: &mut V,\n-                                           lifetimes: &'v Vec<LifetimeDef>) {\n+pub fn walk_lifetime_decls_helper<'v, V: Visitor<'v>>(visitor: &mut V,\n+                                                      lifetimes: &'v Vec<LifetimeDef>) {\n     for l in lifetimes.iter() {\n         visitor.visit_lifetime_decl(l);\n     }\n }\n \n pub fn walk_path<'v, V: Visitor<'v>>(visitor: &mut V, path: &'v Path) {\n     for segment in path.segments.iter() {\n-        visitor.visit_ident(path.span, segment.identifier);\n+        visitor.visit_path_segment(path.span, segment);\n+    }\n+}\n \n-        match segment.parameters {\n-            ast::AngleBracketedParameters(ref data) => {\n-                for typ in data.types.iter() {\n-                    visitor.visit_ty(&**typ);\n-                }\n-                for lifetime in data.lifetimes.iter() {\n-                    visitor.visit_lifetime_ref(lifetime);\n-                }\n+pub fn walk_path_segment<'v, V: Visitor<'v>>(visitor: &mut V,\n+                                             path_span: Span,\n+                                             segment: &'v PathSegment) {\n+    visitor.visit_ident(path_span, segment.identifier);\n+    visitor.visit_path_parameters(path_span, &segment.parameters);\n+}\n+\n+pub fn walk_path_parameters<'v, V: Visitor<'v>>(visitor: &mut V,\n+                                                _path_span: Span,\n+                                                path_parameters: &'v PathParameters) {\n+    match *path_parameters {\n+        ast::AngleBracketedParameters(ref data) => {\n+            for typ in data.types.iter() {\n+                visitor.visit_ty(&**typ);\n             }\n-            ast::ParenthesizedParameters(ref data) => {\n-                for typ in data.inputs.iter() {\n-                    visitor.visit_ty(&**typ);\n-                }\n-                for typ in data.output.iter() {\n-                    visitor.visit_ty(&**typ);\n-                }\n+            for lifetime in data.lifetimes.iter() {\n+                visitor.visit_lifetime_ref(lifetime);\n+            }\n+        }\n+        ast::ParenthesizedParameters(ref data) => {\n+            for typ in data.inputs.iter() {\n+                visitor.visit_ty(&**typ);\n+            }\n+            for typ in data.output.iter() {\n+                visitor.visit_ty(&**typ);\n             }\n         }\n     }\n@@ -511,32 +534,37 @@ pub fn walk_foreign_item<'v, V: Visitor<'v>>(visitor: &mut V,\n     }\n }\n \n-pub fn walk_ty_param_bounds<'v, V: Visitor<'v>>(visitor: &mut V,\n-                                                bounds: &'v OwnedSlice<TyParamBound>) {\n+pub fn walk_ty_param_bounds_helper<'v, V: Visitor<'v>>(visitor: &mut V,\n+                                                       bounds: &'v OwnedSlice<TyParamBound>) {\n     for bound in bounds.iter() {\n-        match *bound {\n-            TraitTyParamBound(ref typ) => {\n-                visitor.visit_poly_trait_ref(typ)\n-            }\n-            RegionTyParamBound(ref lifetime) => {\n-                visitor.visit_lifetime_ref(lifetime);\n-            }\n+        visitor.visit_ty_param_bound(bound)\n+    }\n+}\n+\n+pub fn walk_ty_param_bound<'v, V: Visitor<'v>>(visitor: &mut V,\n+                                               bound: &'v TyParamBound) {\n+    match *bound {\n+        TraitTyParamBound(ref typ) => {\n+            visitor.visit_poly_trait_ref(typ);\n+        }\n+        RegionTyParamBound(ref lifetime) => {\n+            visitor.visit_lifetime_ref(lifetime);\n         }\n     }\n }\n \n pub fn walk_generics<'v, V: Visitor<'v>>(visitor: &mut V, generics: &'v Generics) {\n     for type_parameter in generics.ty_params.iter() {\n-        walk_ty_param_bounds(visitor, &type_parameter.bounds);\n+        walk_ty_param_bounds_helper(visitor, &type_parameter.bounds);\n         match type_parameter.default {\n             Some(ref ty) => visitor.visit_ty(&**ty),\n             None => {}\n         }\n     }\n-    walk_lifetime_decls(visitor, &generics.lifetimes);\n+    walk_lifetime_decls_helper(visitor, &generics.lifetimes);\n     for predicate in generics.where_clause.predicates.iter() {\n         visitor.visit_ident(predicate.span, predicate.ident);\n-        walk_ty_param_bounds(visitor, &predicate.bounds);\n+        walk_ty_param_bounds_helper(visitor, &predicate.bounds);\n     }\n }\n "}, {"sha": "54f1595780db715f0dc3b23705d47512364e3073", "filename": "src/test/auxiliary/issue-18711.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Ftest%2Fauxiliary%2Fissue-18711.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Ftest%2Fauxiliary%2Fissue-18711.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-18711.rs?ref=c8d6e3b2c2a780eff92299da5d1c02e081617088", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(unboxed_closures, overloaded_calls)]\n+#![feature(unboxed_closures)]\n #![crate_type = \"rlib\"]\n \n pub fn inner<F>(f: F) -> F {"}, {"sha": "9a6a2c7495b798b147b75f8244169046bfdcfc11", "filename": "src/test/auxiliary/unboxed-closures-cross-crate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Ftest%2Fauxiliary%2Funboxed-closures-cross-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Ftest%2Fauxiliary%2Funboxed-closures-cross-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Funboxed-closures-cross-crate.rs?ref=c8d6e3b2c2a780eff92299da5d1c02e081617088", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(unboxed_closures, overloaded_calls)]\n+#![feature(unboxed_closures)]\n \n #[inline]\n pub fn has_closures() -> uint {"}, {"sha": "ffe5739e0bb5e41f573172b7979b6f474c7a3019", "filename": "src/test/bench/shootout-reverse-complement.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-reverse-complement.rs?ref=c8d6e3b2c2a780eff92299da5d1c02e081617088", "patch": "@@ -40,7 +40,7 @@\n \n // ignore-android see #10393 #13206\n \n-#![feature(slicing_syntax, unboxed_closures, overloaded_calls)]\n+#![feature(slicing_syntax, unboxed_closures)]\n \n extern crate libc;\n "}, {"sha": "acb289aa3ade89f0b87a853f22872be1f60ece61", "filename": "src/test/bench/shootout-spectralnorm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs?ref=c8d6e3b2c2a780eff92299da5d1c02e081617088", "patch": "@@ -41,7 +41,7 @@\n // no-pretty-expanded FIXME #15189\n \n #![allow(non_snake_case)]\n-#![feature(unboxed_closures, overloaded_calls)]\n+#![feature(unboxed_closures)]\n \n use std::iter::AdditiveIterator;\n use std::mem;"}, {"sha": "938fc53d61054c89b6ce16672729ce585a0951b2", "filename": "src/test/compile-fail/borrowck-overloaded-call.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Ftest%2Fcompile-fail%2Fborrowck-overloaded-call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Ftest%2Fcompile-fail%2Fborrowck-overloaded-call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-overloaded-call.rs?ref=c8d6e3b2c2a780eff92299da5d1c02e081617088", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(overloaded_calls)]\n+#![feature(unboxed_closures)]\n \n use std::ops::{Fn, FnMut, FnOnce};\n "}, {"sha": "cca3dcb8b34dbd328bc55c36024785cdf4f77839", "filename": "src/test/compile-fail/borrowck-unboxed-closures.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Ftest%2Fcompile-fail%2Fborrowck-unboxed-closures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Ftest%2Fcompile-fail%2Fborrowck-unboxed-closures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-unboxed-closures.rs?ref=c8d6e3b2c2a780eff92299da5d1c02e081617088", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(overloaded_calls)]\n+#![feature(overloaded_calls, unboxed_closures)]\n \n fn a<F:Fn(int, int) -> int>(mut f: F) {\n     let g = &mut f;"}, {"sha": "9b2264b8902a3614b2c2c4441fd0f319fcb7b349", "filename": "src/test/compile-fail/explicit-self-lifetime-mismatch.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Ftest%2Fcompile-fail%2Fexplicit-self-lifetime-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Ftest%2Fcompile-fail%2Fexplicit-self-lifetime-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fexplicit-self-lifetime-mismatch.rs?ref=c8d6e3b2c2a780eff92299da5d1c02e081617088", "patch": "@@ -14,12 +14,9 @@ struct Foo<'a,'b> {\n }\n \n impl<'a,'b> Foo<'a,'b> {\n-    // The number of errors is related to the way invariance works.\n     fn bar(self: Foo<'b,'a>) {}\n     //~^ ERROR mismatched types: expected `Foo<'a, 'b>`, found `Foo<'b, 'a>`\n     //~^^ ERROR mismatched types: expected `Foo<'a, 'b>`, found `Foo<'b, 'a>`\n-    //~^^^ ERROR mismatched types: expected `Foo<'b, 'a>`, found `Foo<'a, 'b>`\n-    //~^^^^ ERROR mismatched types: expected `Foo<'b, 'a>`, found `Foo<'a, 'b>`\n }\n \n fn main() {}"}, {"sha": "4199deee7b80e037d99d4a25e0543728673fdaa8", "filename": "src/test/compile-fail/hrtb-higher-ranker-supertraits-transitive.rs", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Ftest%2Fcompile-fail%2Fhrtb-higher-ranker-supertraits-transitive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Ftest%2Fcompile-fail%2Fhrtb-higher-ranker-supertraits-transitive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fhrtb-higher-ranker-supertraits-transitive.rs?ref=c8d6e3b2c2a780eff92299da5d1c02e081617088", "patch": "@@ -0,0 +1,60 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test HRTB supertraits with several levels of expansion required.\n+\n+trait Foo<'tcx>\n+{\n+    fn foo(&'tcx self) -> &'tcx int;\n+}\n+\n+trait Bar<'ccx>\n+    : for<'tcx> Foo<'tcx>\n+{\n+    fn bar(&'ccx self) -> &'ccx int;\n+}\n+\n+trait Baz\n+    : for<'ccx> Bar<'ccx>\n+{\n+    fn dummy(&self);\n+}\n+\n+trait Qux\n+    : Bar<'static>\n+{\n+    fn dummy(&self);\n+}\n+\n+fn want_foo_for_any_tcx<F>(f: &F)\n+    where F : for<'tcx> Foo<'tcx>\n+{\n+}\n+\n+fn want_bar_for_any_ccx<B>(b: &B)\n+    where B : for<'ccx> Bar<'ccx>\n+{\n+}\n+\n+fn want_baz<B>(b: &B)\n+    where B : Baz\n+{\n+    want_foo_for_any_tcx(b);\n+    want_bar_for_any_ccx(b);\n+}\n+\n+fn want_qux<B>(b: &B)\n+    where B : Qux\n+{\n+    want_foo_for_any_tcx(b);\n+    want_bar_for_any_ccx(b); //~ ERROR not implemented\n+}\n+\n+fn main() {}"}, {"sha": "108ca1b82e0df69659c377337bfaeb3bb5484dd3", "filename": "src/test/compile-fail/hrtb-higher-ranker-supertraits.rs", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Ftest%2Fcompile-fail%2Fhrtb-higher-ranker-supertraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Ftest%2Fcompile-fail%2Fhrtb-higher-ranker-supertraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fhrtb-higher-ranker-supertraits.rs?ref=c8d6e3b2c2a780eff92299da5d1c02e081617088", "patch": "@@ -0,0 +1,58 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test a trait (`Bar`) with a higher-ranked supertrait.\n+\n+trait Foo<'tcx>\n+{\n+    fn foo(&'tcx self) -> &'tcx int;\n+}\n+\n+trait Bar<'ccx>\n+    : for<'tcx> Foo<'tcx>\n+{\n+    fn bar(&'ccx self) -> &'ccx int;\n+}\n+\n+fn want_foo_for_some_tcx<'x,F>(f: &'x F)\n+    where F : Foo<'x>\n+{\n+    want_foo_for_some_tcx(f);\n+    want_foo_for_any_tcx(f); //~ ERROR not implemented\n+}\n+\n+fn want_foo_for_any_tcx<F>(f: &F)\n+    where F : for<'tcx> Foo<'tcx>\n+{\n+    want_foo_for_some_tcx(f);\n+    want_foo_for_any_tcx(f);\n+}\n+\n+fn want_bar_for_some_ccx<'x,B>(b: &B)\n+    where B : Bar<'x>\n+{\n+    want_foo_for_some_tcx(b);\n+    want_foo_for_any_tcx(b);\n+\n+    want_bar_for_some_ccx(b);\n+    want_bar_for_any_ccx(b); //~ ERROR not implemented\n+}\n+\n+fn want_bar_for_any_ccx<B>(b: &B)\n+    where B : for<'ccx> Bar<'ccx>\n+{\n+    want_foo_for_some_tcx(b);\n+    want_foo_for_any_tcx(b);\n+\n+    want_bar_for_some_ccx(b);\n+    want_bar_for_any_ccx(b);\n+}\n+\n+fn main() {}"}, {"sha": "733a5b2a85af1238aaabb96f5cfc8000e6fd1128", "filename": "src/test/compile-fail/hrtb-identity-fn-borrows.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Ftest%2Fcompile-fail%2Fhrtb-identity-fn-borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Ftest%2Fcompile-fail%2Fhrtb-identity-fn-borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fhrtb-identity-fn-borrows.rs?ref=c8d6e3b2c2a780eff92299da5d1c02e081617088", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that the `'a` in the where clause correctly links the region\n+// of the output to the region of the input.\n+\n+trait FnLike<A,R> {\n+    fn call(&self, arg: A) -> R;\n+}\n+\n+fn call_repeatedly<F>(f: F)\n+    where F : for<'a> FnLike<&'a int, &'a int>\n+{\n+    // Result is stored: cannot re-assign `x`\n+    let mut x = 3;\n+    let y = f.call(&x);\n+    x = 5; //~ ERROR cannot assign\n+\n+    // Result is not stored: can re-assign `x`\n+    let mut x = 3;\n+    f.call(&x);\n+    f.call(&x);\n+    f.call(&x);\n+    x = 5;\n+}\n+\n+fn main() {\n+}"}, {"sha": "dd3c88b8a10b4c7709c1aa85907a0959b62c4fbd", "filename": "src/test/compile-fail/issue-15094.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Ftest%2Fcompile-fail%2Fissue-15094.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Ftest%2Fcompile-fail%2Fissue-15094.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-15094.rs?ref=c8d6e3b2c2a780eff92299da5d1c02e081617088", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(overloaded_calls)]\n+#![feature(unboxed_closures)]\n \n use std::{fmt, ops};\n "}, {"sha": "7ec3fef5c878eb05a060356e60fa5b169b03392c", "filename": "src/test/compile-fail/issue-16939.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Ftest%2Fcompile-fail%2Fissue-16939.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Ftest%2Fcompile-fail%2Fissue-16939.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-16939.rs?ref=c8d6e3b2c2a780eff92299da5d1c02e081617088", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(overloaded_calls)]\n+#![feature(overloaded_calls, unboxed_closures)]\n \n // Make sure we don't ICE when making an overloaded call with the\n // wrong arity."}, {"sha": "943d326182f89e30cfdba190256e2aeef1069990", "filename": "src/test/compile-fail/issue-18532.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Ftest%2Fcompile-fail%2Fissue-18532.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Ftest%2Fcompile-fail%2Fissue-18532.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-18532.rs?ref=c8d6e3b2c2a780eff92299da5d1c02e081617088", "patch": "@@ -12,7 +12,7 @@\n // when a type error or unconstrained type variable propagates\n // into it.\n \n-#![feature(overloaded_calls)]\n+#![feature(unboxed_closures)]\n \n fn main() {\n     (return)((),());"}, {"sha": "b3a4c3125891fdf7bdba3d1f1e40704b75a8d0ba", "filename": "src/test/compile-fail/overloaded-calls-bad.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Ftest%2Fcompile-fail%2Foverloaded-calls-bad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Ftest%2Fcompile-fail%2Foverloaded-calls-bad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Foverloaded-calls-bad.rs?ref=c8d6e3b2c2a780eff92299da5d1c02e081617088", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(overloaded_calls)]\n+#![feature(unboxed_closures)]\n \n use std::ops::FnMut;\n "}, {"sha": "396a809c2e12fc541639ce7625d5137d2537e28d", "filename": "src/test/compile-fail/overloaded-calls-nontuple.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Ftest%2Fcompile-fail%2Foverloaded-calls-nontuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Ftest%2Fcompile-fail%2Foverloaded-calls-nontuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Foverloaded-calls-nontuple.rs?ref=c8d6e3b2c2a780eff92299da5d1c02e081617088", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(overloaded_calls)]\n+#![feature(unboxed_closures)]\n \n use std::ops::FnMut;\n "}, {"sha": "75e9e55138e06a45a5bffa1068188d797b01e447", "filename": "src/test/compile-fail/regionck-unboxed-closure-lifetimes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Ftest%2Fcompile-fail%2Fregionck-unboxed-closure-lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Ftest%2Fcompile-fail%2Fregionck-unboxed-closure-lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregionck-unboxed-closure-lifetimes.rs?ref=c8d6e3b2c2a780eff92299da5d1c02e081617088", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(unboxed_closure_sugar, unboxed_closures, overloaded_calls)]\n+#![feature(unboxed_closures, overloaded_calls)]\n \n use std::ops::FnMut;\n "}, {"sha": "ffd1501075e94c594b3e3f7c9932f742654196c1", "filename": "src/test/compile-fail/regions-name-undeclared.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Ftest%2Fcompile-fail%2Fregions-name-undeclared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Ftest%2Fcompile-fail%2Fregions-name-undeclared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-name-undeclared.rs?ref=c8d6e3b2c2a780eff92299da5d1c02e081617088", "patch": "@@ -44,6 +44,9 @@ fn bar<'a>(x: &'a int) {\n     // &'a CAN be declared on functions and used then:\n     fn g<'a>(a: &'a int) { } // OK\n     fn h(a: for<'a>|&'a int|) { } // OK\n+\n+    // But not in the bound of a closure, it's not in scope *there*\n+    fn i(a: for<'a>|&int|:'a) { } //~ ERROR undeclared lifetime\n }\n \n // Test nesting of lifetimes in fn type declarations"}, {"sha": "1d1b244ab5aeb51a031c23a1c31b0aaee78c3943", "filename": "src/test/compile-fail/stage0-clone-contravariant-lifetime.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Ftest%2Fcompile-fail%2Fstage0-clone-contravariant-lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Ftest%2Fcompile-fail%2Fstage0-clone-contravariant-lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstage0-clone-contravariant-lifetime.rs?ref=c8d6e3b2c2a780eff92299da5d1c02e081617088", "patch": "@@ -0,0 +1,43 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// A zero-dependency test that covers some basic traits, default\n+// methods, etc.  When mucking about with basic type system stuff I\n+// often encounter problems in the iterator trait, so it's useful to\n+// have hanging around. -nmatsakis\n+\n+// error-pattern: requires `start` lang_item\n+\n+#![no_std]\n+#![feature(lang_items)]\n+\n+#[lang = \"sized\"]\n+pub trait Sized for Sized? {\n+    // Empty.\n+}\n+\n+pub mod std {\n+    pub mod clone {\n+        pub trait Clone {\n+            fn clone(&self) -> Self;\n+        }\n+    }\n+}\n+\n+pub struct ContravariantLifetime<'a>;\n+\n+impl <'a> ::std::clone::Clone for ContravariantLifetime<'a> {\n+    #[inline]\n+    fn clone(&self) -> ContravariantLifetime<'a> {\n+        match *self { ContravariantLifetime => ContravariantLifetime, }\n+    }\n+}\n+\n+fn main() { }"}, {"sha": "2c0772b1414bd8567ab56729347e1186c6cefdaf", "filename": "src/test/compile-fail/stage0-cmp.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Ftest%2Fcompile-fail%2Fstage0-cmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Ftest%2Fcompile-fail%2Fstage0-cmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstage0-cmp.rs?ref=c8d6e3b2c2a780eff92299da5d1c02e081617088", "patch": "@@ -0,0 +1,40 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+// A zero-dependency test that covers some basic traits, default\n+// methods, etc.  When mucking about with basic type system stuff I\n+// often encounter problems in the iterator trait, so it's useful to\n+// have hanging around. -nmatsakis\n+\n+// error-pattern: requires `start` lang_item\n+\n+#![no_std]\n+#![feature(lang_items)]\n+\n+#[lang = \"sized\"]\n+pub trait Sized for Sized? {\n+    // Empty.\n+}\n+\n+#[unstable = \"Definition may change slightly after trait reform\"]\n+pub trait PartialEq for Sized? {\n+    /// This method tests for `self` and `other` values to be equal, and is used by `==`.\n+    fn eq(&self, other: &Self) -> bool;\n+}\n+\n+#[cfg(not(stage0))]  // NOTE(stage0): remove cfg after a snapshot\n+#[unstable = \"Trait is unstable.\"]\n+impl<'a, Sized? T: PartialEq> PartialEq for &'a T {\n+    #[inline]\n+    fn eq(&self, other: & &'a T) -> bool { PartialEq::eq(*self, *other) }\n+}\n+\n+fn main() { }"}, {"sha": "8d3610affdfb967aa4f0539b7c5bf6a5c85449f8", "filename": "src/test/compile-fail/ufcs-explicit-self-bad.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Ftest%2Fcompile-fail%2Fufcs-explicit-self-bad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Ftest%2Fcompile-fail%2Fufcs-explicit-self-bad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fufcs-explicit-self-bad.rs?ref=c8d6e3b2c2a780eff92299da5d1c02e081617088", "patch": "@@ -14,7 +14,6 @@ struct Foo {\n \n impl Foo {\n     fn foo(self: int, x: int) -> int {  //~ ERROR mismatched self type\n-//~^ ERROR not a valid type for `self`\n         self.f + x\n     }\n }\n@@ -25,15 +24,26 @@ struct Bar<T> {\n \n impl<T> Bar<T> {\n     fn foo(self: Bar<int>, x: int) -> int { //~ ERROR mismatched self type\n-//~^ ERROR not a valid type for `self`\n         x\n     }\n     fn bar(self: &Bar<uint>, x: int) -> int {   //~ ERROR mismatched self type\n-//~^ ERROR not a valid type for `self`\n         x\n     }\n }\n \n+trait SomeTrait {\n+    fn dummy1(&self);\n+    fn dummy2(&self);\n+    fn dummy3(&self);\n+}\n+\n+impl<'a, T> SomeTrait for &'a Bar<T> {\n+    fn dummy1(self: &&'a Bar<T>) { }\n+    fn dummy2(self: &Bar<T>) {} //~ ERROR mismatched self type\n+    fn dummy3(self: &&Bar<T>) {} //~ ERROR lifetime mismatch\n+    //~^ ERROR lifetime mismatch\n+}\n+\n fn main() {\n     let foo = box Foo {\n         f: 1,"}, {"sha": "06a934063927a8b06620e294d7f1fad034088d0a", "filename": "src/test/compile-fail/unboxed-closure-sugar-default.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-default.rs?ref=c8d6e3b2c2a780eff92299da5d1c02e081617088", "patch": "@@ -11,16 +11,16 @@\n // Test interaction between unboxed closure sugar and default type\n // parameters (should be exactly as if angle brackets were used).\n \n-#![feature(default_type_params)]\n+#![feature(default_type_params, unboxed_closures)]\n #![allow(dead_code)]\n \n-struct Foo<T,U,V=T> {\n-    t: T, u: U\n+trait Foo<T,U,V=T> {\n+    fn dummy(&self, t: T, u: U, v: V);\n }\n \n-trait Eq<X> { }\n-impl<X> Eq<X> for X { }\n-fn eq<A,B:Eq<A>>() { }\n+trait Eq<Sized? X> for Sized? { }\n+impl<Sized? X> Eq<X> for X { }\n+fn eq<Sized? A,Sized? B>() where A : Eq<B> { }\n \n fn test<'a,'b>() {\n     // Parens are equivalent to omitting default in angle."}, {"sha": "6f875efdef7eab13715525a710ed1ac8759f39c1", "filename": "src/test/compile-fail/unboxed-closure-sugar-equiv.rs", "status": "modified", "additions": 22, "deletions": 5, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-equiv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-equiv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-equiv.rs?ref=c8d6e3b2c2a780eff92299da5d1c02e081617088", "patch": "@@ -13,15 +13,16 @@\n // angle brackets. This test covers only simple types and in\n // particular doesn't test bound regions.\n \n+#![feature(unboxed_closures)]\n #![allow(dead_code)]\n \n-struct Foo<T,U> {\n-    t: T, u: U\n+trait Foo<T,U> {\n+    fn dummy(&self, t: T, u: U);\n }\n \n-trait Eq<X> { }\n-impl<X> Eq<X> for X { }\n-fn eq<A,B:Eq<A>>() { }\n+trait Eq<Sized? X> for Sized? { }\n+impl<Sized? X> Eq<X> for X { }\n+fn eq<Sized? A,Sized? B:Eq<A>>() { }\n \n fn test<'a,'b>() {\n     // No errors expected:\n@@ -31,6 +32,22 @@ fn test<'a,'b>() {\n     eq::< Foo<(int,uint),uint>,         Foo(int,uint) -> uint         >();\n     eq::< Foo<(&'a int,&'b uint),uint>, Foo(&'a int,&'b uint) -> uint >();\n \n+    // Test that anonymous regions in `()` form are equivalent\n+    // to fresh bound regions, and that we can intermingle\n+    // named and anonymous as we choose:\n+    eq::< for<'a,'b> Foo<(&'a int,&'b uint),uint>,\n+          for<'a,'b> Foo(&'a int,&'b uint) -> uint            >();\n+    eq::< for<'a,'b> Foo<(&'a int,&'b uint),uint>,\n+          for<'a> Foo(&'a int,&uint) -> uint                  >();\n+    eq::< for<'a,'b> Foo<(&'a int,&'b uint),uint>,\n+          for<'b> Foo(&int,&'b uint) -> uint                  >();\n+    eq::< for<'a,'b> Foo<(&'a int,&'b uint),uint>,\n+          Foo(&int,&uint) -> uint                             >();\n+\n+    // FIXME(#18992) Test lifetime elision in `()` form:\n+    // eq::< for<'a,'b> Foo<(&'a int,), &'a int>,\n+    //      Foo(&int) -> &int                                   >();\n+\n     // Errors expected:\n     eq::< Foo<(),()>,                   Foo(char)                     >();\n     //~^ ERROR not implemented"}, {"sha": "23e2d2f4365afdbe53039e2000c2bed0677b5f0f", "filename": "src/test/compile-fail/unboxed-closure-sugar-nonexistent-trait.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-nonexistent-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-nonexistent-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-nonexistent-trait.rs?ref=c8d6e3b2c2a780eff92299da5d1c02e081617088", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(unboxed_closures)]\n+\n fn f<F:Nonexist(int) -> int>(x: F) {} //~ ERROR nonexistent trait `Nonexist`\n \n type Typedef = int;"}, {"sha": "a938f126c16077f6925c4a65a7fda0825d8029ed", "filename": "src/test/compile-fail/unboxed-closure-sugar-region.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-region.rs?ref=c8d6e3b2c2a780eff92299da5d1c02e081617088", "patch": "@@ -12,20 +12,19 @@\n // parameters (should be exactly as if angle brackets were used\n // and regions omitted).\n \n-#![feature(default_type_params)]\n+#![feature(default_type_params, unboxed_closures)]\n #![allow(dead_code)]\n \n use std::kinds::marker;\n \n-struct Foo<'a,T,U> {\n-    t: T,\n-    u: U,\n-    m: marker::InvariantLifetime<'a>\n+trait Foo<'a,T,U> {\n+    fn dummy(&'a self) -> &'a (T,U);\n }\n \n-trait Eq<X> { }\n-impl<X> Eq<X> for X { }\n-fn eq<A,B:Eq<A>>() { }\n+trait Eq<Sized? X> for Sized? { }\n+impl<Sized? X> Eq<X> for X { }\n+fn eq<Sized? A,Sized? B:Eq<A>>() { }\n+\n fn same_type<A,B:Eq<A>>(a: A, b: B) { }\n \n fn test<'a,'b>() {\n@@ -34,10 +33,10 @@ fn test<'a,'b>() {\n \n     // Here we specify 'static explicitly in angle-bracket version.\n     // Parenthesized winds up getting inferred.\n-    eq::< Foo<'static, (int,),()>,               Foo(int)                      >();\n+    eq::< Foo<'static, (int,),()>,      Foo(int)                      >();\n }\n \n-fn test2(x: Foo<(int,),()>, y: Foo(int)) {\n+fn test2(x: &Foo<(int,),()>, y: &Foo(int)) {\n     // Here, the omitted lifetimes are expanded to distinct things.\n     same_type(x, y) //~ ERROR cannot infer\n }"}, {"sha": "d9efab974d83f83e625e031a0f7c90bfbe22944f", "filename": "src/test/compile-fail/unboxed-closure-sugar-wrong-number-number-type-parameters-1.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-wrong-number-number-type-parameters-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-wrong-number-number-type-parameters-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-wrong-number-number-type-parameters-1.rs?ref=c8d6e3b2c2a780eff92299da5d1c02e081617088", "patch": "@@ -8,9 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-struct One<A>;\n+#![feature(unboxed_closures)]\n \n-fn foo(_: One()) //~ ERROR wrong number of type arguments\n+trait One<A> { fn foo(&self) -> A; }\n+\n+fn foo(_: &One()) //~ ERROR wrong number of type arguments\n {}\n \n fn main() { }"}, {"sha": "dcfcb7d47728c7e5dd2534b20b0da1fbf2736608", "filename": "src/test/compile-fail/unboxed-closure-sugar-wrong-number-number-type-parameters-3.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-wrong-number-number-type-parameters-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-wrong-number-number-type-parameters-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-wrong-number-number-type-parameters-3.rs?ref=c8d6e3b2c2a780eff92299da5d1c02e081617088", "patch": "@@ -8,9 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-struct Three<A,B,C>;\n+#![feature(unboxed_closures)]\n \n-fn foo(_: Three()) //~ ERROR wrong number of type arguments\n+trait Three<A,B,C> { fn dummy(&self) -> (A,B,C); }\n+\n+fn foo(_: &Three()) //~ ERROR wrong number of type arguments\n {}\n \n fn main() { }"}, {"sha": "a8ac62444aafc047d4cd4c1df2838507cbd99d59", "filename": "src/test/compile-fail/unboxed-closure-sugar-wrong-number-number-type-parameters.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-wrong-number-number-type-parameters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-wrong-number-number-type-parameters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-wrong-number-number-type-parameters.rs?ref=c8d6e3b2c2a780eff92299da5d1c02e081617088", "patch": "@@ -8,7 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-struct Zero;\n+#![feature(unboxed_closures)]\n+\n+trait Zero { fn dummy(&self); }\n \n fn foo(_: Zero()) //~ ERROR wrong number of type arguments\n {}"}, {"sha": "ba1e931ac64344cdadc84e5c7af9ed97fda9466a", "filename": "src/test/compile-fail/unboxed-closure-sugar-wrong-trait.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-wrong-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-wrong-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closure-sugar-wrong-trait.rs?ref=c8d6e3b2c2a780eff92299da5d1c02e081617088", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(unboxed_closures)]\n+\n trait Trait {}\n \n fn f<F:Trait(int) -> int>(x: F) {}"}, {"sha": "9fbb8a18ae93a4b55227bb292a33a3d4c5b918f3", "filename": "src/test/compile-fail/unboxed-closures-fnmut-as-fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Ftest%2Fcompile-fail%2Funboxed-closures-fnmut-as-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Ftest%2Fcompile-fail%2Funboxed-closures-fnmut-as-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closures-fnmut-as-fn.rs?ref=c8d6e3b2c2a780eff92299da5d1c02e081617088", "patch": "@@ -11,7 +11,7 @@\n // Checks that the Fn trait hierarchy rules do not permit\n // Fn to be used where FnMut is implemented.\n \n-#![feature(unboxed_closure_sugar)]\n+#![feature(unboxed_closures)]\n #![feature(overloaded_calls)]\n \n use std::ops::{Fn,FnMut,FnOnce};"}, {"sha": "9d104afd6464e98ae162960f227377e78d26cf9e", "filename": "src/test/run-pass/bare-fn-implements-fn-mut.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Ftest%2Frun-pass%2Fbare-fn-implements-fn-mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Ftest%2Frun-pass%2Fbare-fn-implements-fn-mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbare-fn-implements-fn-mut.rs?ref=c8d6e3b2c2a780eff92299da5d1c02e081617088", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(overloaded_calls)]\n+#![feature(unboxed_closures)]\n \n use std::ops::FnMut;\n "}, {"sha": "cd40e2a7843665c85a7f8fa51db2ec5e14161460", "filename": "src/test/run-pass/capture-clauses-unboxed-closures.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Ftest%2Frun-pass%2Fcapture-clauses-unboxed-closures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Ftest%2Frun-pass%2Fcapture-clauses-unboxed-closures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcapture-clauses-unboxed-closures.rs?ref=c8d6e3b2c2a780eff92299da5d1c02e081617088", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(overloaded_calls, unboxed_closures)]\n+#![feature(unboxed_closures)]\n \n fn each<'a,T,F:FnMut(&'a T)>(x: &'a [T], mut f: F) {\n     for val in x.iter() {"}, {"sha": "6716c3468d0f84b67635c4fe94609021ffa2eb38", "filename": "src/test/run-pass/closure-syntax.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Ftest%2Frun-pass%2Fclosure-syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Ftest%2Frun-pass%2Fclosure-syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclosure-syntax.rs?ref=c8d6e3b2c2a780eff92299da5d1c02e081617088", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n #![allow(dead_code)]\n-#![feature(unboxed_closures, unboxed_closure_sugar)]\n+#![feature(unboxed_closures)]\n \n // compile-flags:-g\n "}, {"sha": "5a793f7065a41fa6a0c93ac5c7e792a79fc1f1bb", "filename": "src/test/run-pass/hrtb-binder-levels-in-object-types.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Ftest%2Frun-pass%2Fhrtb-binder-levels-in-object-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Ftest%2Frun-pass%2Fhrtb-binder-levels-in-object-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhrtb-binder-levels-in-object-types.rs?ref=c8d6e3b2c2a780eff92299da5d1c02e081617088", "patch": "@@ -0,0 +1,34 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we handle binder levels in object types correctly.\n+// Initially, the reference to `'tcx` in the object type\n+// `&Typer<'tcx>` was getting an incorrect binder level, yielding\n+// weird compilation ICEs and so forth.\n+\n+trait Typer<'tcx> {\n+    fn method(&self, data: &'tcx int) -> &'tcx int { data }\n+}\n+\n+struct Tcx<'tcx> {\n+    fields: &'tcx int\n+}\n+\n+impl<'tcx> Typer<'tcx> for Tcx<'tcx> {\n+}\n+\n+fn g<'tcx>(typer: &Typer<'tcx>) {\n+}\n+\n+fn check_static_type<'x>(tcx: &Tcx<'x>) {\n+    g(tcx)\n+}\n+\n+fn main() { }"}, {"sha": "5bdfa3cafd747973cb915cdb8c108d79d93ae2d0", "filename": "src/test/run-pass/hrtb-debruijn-object-types-in-closures.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Ftest%2Frun-pass%2Fhrtb-debruijn-object-types-in-closures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Ftest%2Frun-pass%2Fhrtb-debruijn-object-types-in-closures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhrtb-debruijn-object-types-in-closures.rs?ref=c8d6e3b2c2a780eff92299da5d1c02e081617088", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+trait Typer<'tcx> {\n+    fn method(&self, data: &'tcx int) -> &'tcx int { data }\n+    fn dummy(&self) { }\n+}\n+\n+fn g(_: |&Typer|) {\n+}\n+\n+fn h() {\n+    g(|typer| typer.dummy())\n+}\n+\n+fn main() { }"}, {"sha": "c8992afe36ac71870b2d345fb6f7a3b054d8f64e", "filename": "src/test/run-pass/hrtb-fn-like-trait-object.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Ftest%2Frun-pass%2Fhrtb-fn-like-trait-object.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Ftest%2Frun-pass%2Fhrtb-fn-like-trait-object.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhrtb-fn-like-trait-object.rs?ref=c8d6e3b2c2a780eff92299da5d1c02e081617088", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// A basic test of using a higher-ranked trait bound.\n+\n+trait FnLike<A,R> {\n+    fn call(&self, arg: A) -> R;\n+}\n+\n+type FnObject<'b> = for<'a> FnLike<&'a int, &'a int> + 'b;\n+\n+struct Identity;\n+\n+impl<'a, T> FnLike<&'a T, &'a T> for Identity {\n+    fn call(&self, arg: &'a T) -> &'a T {\n+        arg\n+    }\n+}\n+\n+fn call_repeatedly(f: &FnObject) {\n+    let x = 3;\n+    let y = f.call(&x);\n+    assert_eq!(3, *y);\n+}\n+\n+fn main() {\n+    call_repeatedly(&Identity);\n+}"}, {"sha": "4067b922cfd6b18ef149758adb2e1851e7d3913f", "filename": "src/test/run-pass/hrtb-fn-like-trait.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Ftest%2Frun-pass%2Fhrtb-fn-like-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Ftest%2Frun-pass%2Fhrtb-fn-like-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhrtb-fn-like-trait.rs?ref=c8d6e3b2c2a780eff92299da5d1c02e081617088", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// A basic test of using a higher-ranked trait bound.\n+\n+trait FnLike<A,R> {\n+    fn call(&self, arg: A) -> R;\n+}\n+\n+struct Identity;\n+\n+impl<'a, T> FnLike<&'a T, &'a T> for Identity {\n+    fn call(&self, arg: &'a T) -> &'a T {\n+        arg\n+    }\n+}\n+\n+fn call_repeatedly<F>(f: F)\n+    where F : for<'a> FnLike<&'a int, &'a int>\n+{\n+    let x = 3;\n+    let y = f.call(&x);\n+    assert_eq!(3, *y);\n+}\n+\n+fn main() {\n+    call_repeatedly(Identity);\n+}"}, {"sha": "02d3bc120da8c84a7ca5184678c34fa702dc3034", "filename": "src/test/run-pass/hrtb-parse.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Ftest%2Frun-pass%2Fhrtb-parse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Ftest%2Frun-pass%2Fhrtb-parse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhrtb-parse.rs?ref=c8d6e3b2c2a780eff92299da5d1c02e081617088", "patch": "@@ -11,6 +11,7 @@\n // Test that we can parse all the various places that a `for` keyword\n // can appear representing universal quantification.\n \n+#![feature(unboxed_closures)]\n #![allow(unused_variables)]\n #![allow(dead_code)]\n "}, {"sha": "9b37b8e49ef3c5c247639548a813c6f95ddd4af5", "filename": "src/test/run-pass/hrtb-resolve-lifetime.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Ftest%2Frun-pass%2Fhrtb-resolve-lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Ftest%2Frun-pass%2Fhrtb-resolve-lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhrtb-resolve-lifetime.rs?ref=c8d6e3b2c2a780eff92299da5d1c02e081617088", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// A basic test of using a higher-ranked trait bound.\n+\n+trait FnLike<A,R> {\n+    fn call(&self, arg: A) -> R;\n+}\n+\n+type FnObject<'b> = for<'a> FnLike<&'a int, &'a int> + 'b;\n+\n+fn main() {\n+}"}, {"sha": "e17e0ae2189d3aa760a4d740e53a968d7bf898c3", "filename": "src/test/run-pass/hrtb-trait-object-paren-notation.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Ftest%2Frun-pass%2Fhrtb-trait-object-paren-notation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Ftest%2Frun-pass%2Fhrtb-trait-object-paren-notation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhrtb-trait-object-paren-notation.rs?ref=c8d6e3b2c2a780eff92299da5d1c02e081617088", "patch": "@@ -0,0 +1,37 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(unboxed_closures)]\n+\n+// A basic test of using a higher-ranked trait bound.\n+\n+trait FnLike<A,R> {\n+    fn call(&self, arg: A) -> R;\n+}\n+\n+type FnObject<'b> = for<'a> FnLike(&'a int) -> (&'a int) + 'b;\n+\n+struct Identity;\n+\n+impl<'a, T> FnLike<(&'a T,), &'a T> for Identity {\n+    fn call(&self, (arg,): (&'a T,)) -> &'a T {\n+        arg\n+    }\n+}\n+\n+fn call_repeatedly(f: &FnObject) {\n+    let x = 3;\n+    let y = f.call((&x,));\n+    assert_eq!(3, *y);\n+}\n+\n+fn main() {\n+    call_repeatedly(&Identity);\n+}"}, {"sha": "076b9c7684ec4010b0de0cad705edece265b19f7", "filename": "src/test/run-pass/hrtb-trait-object-passed-to-closure.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Ftest%2Frun-pass%2Fhrtb-trait-object-passed-to-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Ftest%2Frun-pass%2Fhrtb-trait-object-passed-to-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhrtb-trait-object-passed-to-closure.rs?ref=c8d6e3b2c2a780eff92299da5d1c02e081617088", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that `&PrinterSupport`, which is really short for `&'a\n+// PrinterSupport<'b>`, gets properly expanded when it appears in a\n+// closure type. This used to result in messed up De Bruijn indices.\n+\n+trait PrinterSupport<'ast> {\n+    fn ast_map(&self) -> Option<&'ast uint> { None }\n+}\n+\n+struct NoAnn<'ast> {\n+    f: Option<&'ast uint>\n+}\n+\n+impl<'ast> PrinterSupport<'ast> for NoAnn<'ast> {\n+}\n+\n+fn foo<'ast> (f: Option<&'ast uint>, g: |&PrinterSupport|) {\n+    let annotation = NoAnn { f: f };\n+    g(&annotation)\n+}\n+\n+fn main() {}"}, {"sha": "fea628177da41c4933caf9650e3e847dd9f755f5", "filename": "src/test/run-pass/hrtb-unboxed-closure-trait.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Ftest%2Frun-pass%2Fhrtb-unboxed-closure-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Ftest%2Frun-pass%2Fhrtb-unboxed-closure-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhrtb-unboxed-closure-trait.rs?ref=c8d6e3b2c2a780eff92299da5d1c02e081617088", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test HRTB used with the `Fn` trait.\n+\n+#![feature(unboxed_closures)]\n+\n+fn foo<F:Fn(&int)>(f: F) {\n+    let x = 22;\n+    f(&x);\n+}\n+\n+fn main() {\n+    foo(|&: x: &int| println!(\"{}\", *x));\n+}"}, {"sha": "7f3321e0b3eed8143146f5984fdacda707365275", "filename": "src/test/run-pass/issue-14958.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Ftest%2Frun-pass%2Fissue-14958.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Ftest%2Frun-pass%2Fissue-14958.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-14958.rs?ref=c8d6e3b2c2a780eff92299da5d1c02e081617088", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(overloaded_calls)]\n+#![feature(unboxed_closures)]\n \n trait Foo {}\n "}, {"sha": "6cc5ab4d6cbaa49f4968debd0c4c067ca72620cb", "filename": "src/test/run-pass/issue-14959.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Ftest%2Frun-pass%2Fissue-14959.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Ftest%2Frun-pass%2Fissue-14959.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-14959.rs?ref=c8d6e3b2c2a780eff92299da5d1c02e081617088", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(overloaded_calls)]\n+#![feature(unboxed_closures)]\n \n use std::ops::Fn;\n "}, {"sha": "ebc879d82fbb1f197a074c512e5ba3819ed1ed99", "filename": "src/test/run-pass/issue-16774.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Ftest%2Frun-pass%2Fissue-16774.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Ftest%2Frun-pass%2Fissue-16774.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-16774.rs?ref=c8d6e3b2c2a780eff92299da5d1c02e081617088", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(overloaded_calls, unboxed_closures)]\n+#![feature(unboxed_closures)]\n \n struct X(Box<int>);\n "}, {"sha": "ef2c15c748ca36a317efa02f7993daf4215a9d20", "filename": "src/test/run-pass/issue-18652.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Ftest%2Frun-pass%2Fissue-18652.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Ftest%2Frun-pass%2Fissue-18652.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-18652.rs?ref=c8d6e3b2c2a780eff92299da5d1c02e081617088", "patch": "@@ -12,7 +12,7 @@\n // once closure as an optimization by trans.  This used to hit an\n // incorrect assert.\n \n-#![feature(unboxed_closures, overloaded_calls)]\n+#![feature(unboxed_closures)]\n \n fn main() {\n     let x = 2u8;"}, {"sha": "be6dd583132ecf742f94741a236a5dd8505d3e4e", "filename": "src/test/run-pass/issue-18685.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Ftest%2Frun-pass%2Fissue-18685.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Ftest%2Frun-pass%2Fissue-18685.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-18685.rs?ref=c8d6e3b2c2a780eff92299da5d1c02e081617088", "patch": "@@ -11,7 +11,7 @@\n // Test that the self param space is not used in a conflicting\n // manner by unboxed closures within a default method on a trait\n \n-#![feature(unboxed_closures, overloaded_calls)]\n+#![feature(unboxed_closures)]\n \n trait Tr {\n     fn foo(&self);"}, {"sha": "6a04e68af0cb3c028abcd5119523dba397f7599e", "filename": "src/test/run-pass/issue-18711.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Ftest%2Frun-pass%2Fissue-18711.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Ftest%2Frun-pass%2Fissue-18711.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-18711.rs?ref=c8d6e3b2c2a780eff92299da5d1c02e081617088", "patch": "@@ -11,7 +11,7 @@\n // Test that we don't panic on a RefCell borrow conflict in certain\n // code paths involving unboxed closures.\n \n-#![feature(unboxed_closures, overloaded_calls)]\n+#![feature(unboxed_closures)]\n \n // aux-build:issue-18711.rs\n extern crate \"issue-18711\" as issue;"}, {"sha": "d0dbee39ae095cece48af0590070b040fbb15e91", "filename": "src/test/run-pass/overloaded-calls-param-vtables.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Ftest%2Frun-pass%2Foverloaded-calls-param-vtables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Ftest%2Frun-pass%2Foverloaded-calls-param-vtables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foverloaded-calls-param-vtables.rs?ref=c8d6e3b2c2a780eff92299da5d1c02e081617088", "patch": "@@ -10,7 +10,7 @@\n \n // Tests that nested vtables work with overloaded calls.\n \n-#![feature(overloaded_calls)]\n+#![feature(unboxed_closures)]\n \n use std::ops::Fn;\n "}, {"sha": "b0a40f74ff973dff2466d35148406636cb71ec63", "filename": "src/test/run-pass/overloaded-calls-simple.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Ftest%2Frun-pass%2Foverloaded-calls-simple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Ftest%2Frun-pass%2Foverloaded-calls-simple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foverloaded-calls-simple.rs?ref=c8d6e3b2c2a780eff92299da5d1c02e081617088", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(lang_items, overloaded_calls)]\n+#![feature(lang_items, unboxed_closures)]\n \n use std::ops::{Fn, FnMut, FnOnce};\n "}, {"sha": "809a251fe8059b547af96225cb7c84c4955dcaf4", "filename": "src/test/run-pass/overloaded-calls-zero-args.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Ftest%2Frun-pass%2Foverloaded-calls-zero-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Ftest%2Frun-pass%2Foverloaded-calls-zero-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foverloaded-calls-zero-args.rs?ref=c8d6e3b2c2a780eff92299da5d1c02e081617088", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(overloaded_calls)]\n+#![feature(unboxed_closures)]\n \n use std::ops::{FnMut};\n "}, {"sha": "635e1670aada1bd2be866634b7e3a41df878659d", "filename": "src/test/run-pass/unboxed-closures-all-traits.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Ftest%2Frun-pass%2Funboxed-closures-all-traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Ftest%2Frun-pass%2Funboxed-closures-all-traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funboxed-closures-all-traits.rs?ref=c8d6e3b2c2a780eff92299da5d1c02e081617088", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(lang_items, overloaded_calls, unboxed_closures)]\n+#![feature(lang_items, unboxed_closures)]\n \n fn a<F:Fn(int, int) -> int>(f: F) -> int {\n     f(1, 2)"}, {"sha": "be955486dac33d75ce2a8f2939c844d2adc095c7", "filename": "src/test/run-pass/unboxed-closures-by-ref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Ftest%2Frun-pass%2Funboxed-closures-by-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Ftest%2Frun-pass%2Funboxed-closures-by-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funboxed-closures-by-ref.rs?ref=c8d6e3b2c2a780eff92299da5d1c02e081617088", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(overloaded_calls, unboxed_closures)]\n+#![feature(unboxed_closures)]\n \n // Test by-ref capture of environment in unboxed closure types\n "}, {"sha": "2854d64f6637b8dec6e8fd78b70637b7ea6efb06", "filename": "src/test/run-pass/unboxed-closures-direct-sugary-call.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Ftest%2Frun-pass%2Funboxed-closures-direct-sugary-call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Ftest%2Frun-pass%2Funboxed-closures-direct-sugary-call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funboxed-closures-direct-sugary-call.rs?ref=c8d6e3b2c2a780eff92299da5d1c02e081617088", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(unboxed_closures, overloaded_calls)]\n+#![feature(unboxed_closures)]\n \n fn main() {\n     let mut unboxed = |&mut:| {};"}, {"sha": "8d4d7b4ecb5033ad8873d1b51e93163b3e1cf209", "filename": "src/test/run-pass/unboxed-closures-drop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Ftest%2Frun-pass%2Funboxed-closures-drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Ftest%2Frun-pass%2Funboxed-closures-drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funboxed-closures-drop.rs?ref=c8d6e3b2c2a780eff92299da5d1c02e081617088", "patch": "@@ -11,7 +11,7 @@\n // A battery of tests to ensure destructors of unboxed closure environments\n // run at the right times.\n \n-#![feature(overloaded_calls, unboxed_closures)]\n+#![feature(unboxed_closures)]\n \n static mut DROP_COUNT: uint = 0;\n "}, {"sha": "2628bd90eef0e1756ea2f26ac7aa7e81f2a66be1", "filename": "src/test/run-pass/unboxed-closures-extern-fn.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Ftest%2Frun-pass%2Funboxed-closures-extern-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Ftest%2Frun-pass%2Funboxed-closures-extern-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funboxed-closures-extern-fn.rs?ref=c8d6e3b2c2a780eff92299da5d1c02e081617088", "patch": "@@ -10,8 +10,8 @@\n \n // Checks that extern fn points implement the full range of Fn traits.\n \n-#![feature(unboxed_closure_sugar)]\n-#![feature(overloaded_calls)]\n+#![feature(unboxed_closures)]\n+#![feature(unboxed_closures)]\n \n use std::ops::{Fn,FnMut,FnOnce};\n "}, {"sha": "77d41ae190778a738cf39661311eeb7b5fede41e", "filename": "src/test/run-pass/unboxed-closures-fn-as-fnmut-and-fnonce.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Ftest%2Frun-pass%2Funboxed-closures-fn-as-fnmut-and-fnonce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Ftest%2Frun-pass%2Funboxed-closures-fn-as-fnmut-and-fnonce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funboxed-closures-fn-as-fnmut-and-fnonce.rs?ref=c8d6e3b2c2a780eff92299da5d1c02e081617088", "patch": "@@ -11,8 +11,8 @@\n // Checks that the Fn trait hierarchy rules permit\n // any Fn trait to be used where Fn is implemented.\n \n-#![feature(unboxed_closure_sugar)]\n-#![feature(overloaded_calls)]\n+#![feature(unboxed_closures)]\n+#![feature(unboxed_closures)]\n \n use std::ops::{Fn,FnMut,FnOnce};\n "}, {"sha": "02395624cd123b2c310115c9920286b5048d5bac", "filename": "src/test/run-pass/unboxed-closures-fnmut-as-fnonce.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Ftest%2Frun-pass%2Funboxed-closures-fnmut-as-fnonce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Ftest%2Frun-pass%2Funboxed-closures-fnmut-as-fnonce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funboxed-closures-fnmut-as-fnonce.rs?ref=c8d6e3b2c2a780eff92299da5d1c02e081617088", "patch": "@@ -11,8 +11,8 @@\n // Checks that the Fn trait hierarchy rules permit\n // FnMut or FnOnce to be used where FnMut is implemented.\n \n-#![feature(unboxed_closure_sugar)]\n-#![feature(overloaded_calls)]\n+#![feature(unboxed_closures)]\n+#![feature(unboxed_closures)]\n \n use std::ops::{FnMut,FnOnce};\n "}, {"sha": "3a750dadb911c4ca2e30e7746798131b3e9f26b4", "filename": "src/test/run-pass/unboxed-closures-manual-impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Ftest%2Frun-pass%2Funboxed-closures-manual-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Ftest%2Frun-pass%2Funboxed-closures-manual-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funboxed-closures-manual-impl.rs?ref=c8d6e3b2c2a780eff92299da5d1c02e081617088", "patch": "@@ -9,7 +9,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(unboxed_closure_sugar)]\n+#![feature(unboxed_closures)]\n \n use std::ops::FnMut;\n "}, {"sha": "6f672f2f2828c98fe8bf0182438b64405d11e7ff", "filename": "src/test/run-pass/unboxed-closures-prelude.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Ftest%2Frun-pass%2Funboxed-closures-prelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Ftest%2Frun-pass%2Funboxed-closures-prelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funboxed-closures-prelude.rs?ref=c8d6e3b2c2a780eff92299da5d1c02e081617088", "patch": "@@ -10,7 +10,7 @@\n \n // Tests that the reexports of `FnOnce` et al from the prelude work.\n \n-#![feature(unboxed_closures, unboxed_closure_sugar)]\n+#![feature(unboxed_closures)]\n \n fn main() {\n     let task: Box<FnOnce(int) -> int> = box |: x| x;"}, {"sha": "61ceb5e140e32bcb102adc9f8ad46fba0a2e63ee", "filename": "src/test/run-pass/unboxed-closures-single-word-env.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Ftest%2Frun-pass%2Funboxed-closures-single-word-env.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Ftest%2Frun-pass%2Funboxed-closures-single-word-env.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funboxed-closures-single-word-env.rs?ref=c8d6e3b2c2a780eff92299da5d1c02e081617088", "patch": "@@ -11,7 +11,7 @@\n // Ensures that single-word environments work right in unboxed closures.\n // These take a different path in codegen.\n \n-#![feature(overloaded_calls, unboxed_closures)]\n+#![feature(unboxed_closures)]\n \n fn a<F:Fn(int, int) -> int>(f: F) -> int {\n     f(1, 2)"}, {"sha": "b358e7ce288339f26a6a727dadeb85ac4666d1ad", "filename": "src/test/run-pass/unboxed-closures-sugar-1.rs", "status": "removed", "additions": 0, "deletions": 34, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/09e2ad13d0aa01143bcb20dece3ff6c5a7e34ea3/src%2Ftest%2Frun-pass%2Funboxed-closures-sugar-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09e2ad13d0aa01143bcb20dece3ff6c5a7e34ea3/src%2Ftest%2Frun-pass%2Funboxed-closures-sugar-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funboxed-closures-sugar-1.rs?ref=09e2ad13d0aa01143bcb20dece3ff6c5a7e34ea3", "patch": "@@ -1,34 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Test that the unboxed closure sugar can be used with an arbitrary\n-// struct type and that it is equivalent to the same syntax using\n-// angle brackets. This test covers only simple types and in\n-// particular doesn't test bound regions.\n-\n-#![allow(dead_code)]\n-\n-struct Foo<T,U> {\n-    t: T, u: U\n-}\n-\n-trait Eq<X> { }\n-impl<X> Eq<X> for X { }\n-fn eq<A,B:Eq<A>>() { }\n-\n-fn test<'a,'b>() {\n-    eq::< Foo<(),()>,                   Foo()                         >();\n-    eq::< Foo<(int,),()>,               Foo(int)                      >();\n-    eq::< Foo<(int,uint),()>,           Foo(int,uint)                 >();\n-    eq::< Foo<(int,uint),uint>,         Foo(int,uint) -> uint         >();\n-    eq::< Foo<(&'a int,&'b uint),uint>, Foo(&'a int,&'b uint) -> uint >();\n-}\n-\n-fn main() { }"}, {"sha": "d65de438514f5cdc1f0e8e1d0eaf437fc256084a", "filename": "src/test/run-pass/unboxed-closures-sugar-object.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Ftest%2Frun-pass%2Funboxed-closures-sugar-object.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Ftest%2Frun-pass%2Funboxed-closures-sugar-object.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funboxed-closures-sugar-object.rs?ref=c8d6e3b2c2a780eff92299da5d1c02e081617088", "patch": "@@ -11,6 +11,7 @@\n // Test unboxed closure sugar used in object types.\n \n #![allow(dead_code)]\n+#![feature(unboxed_closures)]\n \n struct Foo<T,U> {\n     t: T, u: U"}, {"sha": "c41aeaa673f80cb87a230e63d85e8cfd3eadc376", "filename": "src/test/run-pass/unboxed-closures-unboxing-shim.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Ftest%2Frun-pass%2Funboxed-closures-unboxing-shim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Ftest%2Frun-pass%2Funboxed-closures-unboxing-shim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funboxed-closures-unboxing-shim.rs?ref=c8d6e3b2c2a780eff92299da5d1c02e081617088", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(unboxed_closures, unboxed_closure_sugar)]\n+#![feature(unboxed_closures)]\n \n use std::ops::FnOnce;\n "}, {"sha": "4fdfb8cf02a716774f3bb130d6c2a529d83b1d13", "filename": "src/test/run-pass/unboxed-closures-unique-type-id.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Ftest%2Frun-pass%2Funboxed-closures-unique-type-id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8d6e3b2c2a780eff92299da5d1c02e081617088/src%2Ftest%2Frun-pass%2Funboxed-closures-unique-type-id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funboxed-closures-unique-type-id.rs?ref=c8d6e3b2c2a780eff92299da5d1c02e081617088", "patch": "@@ -19,7 +19,7 @@\n //\n // compile-flags: -g\n \n-#![feature(unboxed_closures, overloaded_calls)]\n+#![feature(unboxed_closures)]\n \n use std::ptr;\n "}]}