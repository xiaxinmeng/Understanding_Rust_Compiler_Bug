{"sha": "5d86686e7facd7a5e5acc1c8b682310ad1fe878c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVkODY2ODZlN2ZhY2Q3YTVlNWFjYzFjOGI2ODIzMTBhZDFmZTg3OGM=", "commit": {"author": {"name": "Jeff Olson", "email": "olson.jeffery@gmail.com", "date": "2012-05-28T05:50:11Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-06-29T22:41:55Z"}, "message": "std: mod cleanup, impl/test for conn. refused err + mem leak fix", "tree": {"sha": "3a8d97aa93fe66164143d9d508cc478dfa7a04b2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3a8d97aa93fe66164143d9d508cc478dfa7a04b2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5d86686e7facd7a5e5acc1c8b682310ad1fe878c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5d86686e7facd7a5e5acc1c8b682310ad1fe878c", "html_url": "https://github.com/rust-lang/rust/commit/5d86686e7facd7a5e5acc1c8b682310ad1fe878c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5d86686e7facd7a5e5acc1c8b682310ad1fe878c/comments", "author": {"login": "olsonjeffery", "id": 10408, "node_id": "MDQ6VXNlcjEwNDA4", "avatar_url": "https://avatars.githubusercontent.com/u/10408?v=4", "gravatar_id": "", "url": "https://api.github.com/users/olsonjeffery", "html_url": "https://github.com/olsonjeffery", "followers_url": "https://api.github.com/users/olsonjeffery/followers", "following_url": "https://api.github.com/users/olsonjeffery/following{/other_user}", "gists_url": "https://api.github.com/users/olsonjeffery/gists{/gist_id}", "starred_url": "https://api.github.com/users/olsonjeffery/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/olsonjeffery/subscriptions", "organizations_url": "https://api.github.com/users/olsonjeffery/orgs", "repos_url": "https://api.github.com/users/olsonjeffery/repos", "events_url": "https://api.github.com/users/olsonjeffery/events{/privacy}", "received_events_url": "https://api.github.com/users/olsonjeffery/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "900e4460155c0022c8bbe8d53506d0262929f581", "url": "https://api.github.com/repos/rust-lang/rust/commits/900e4460155c0022c8bbe8d53506d0262929f581", "html_url": "https://github.com/rust-lang/rust/commit/900e4460155c0022c8bbe8d53506d0262929f581"}], "stats": {"total": 135, "additions": 100, "deletions": 35}, "files": [{"sha": "fde1ef490b5ededc235af4d907baadf004834770", "filename": "src/libstd/net_tcp.rs", "status": "modified", "additions": 100, "deletions": 35, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/5d86686e7facd7a5e5acc1c8b682310ad1fe878c/src%2Flibstd%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d86686e7facd7a5e5acc1c8b682310ad1fe878c/src%2Flibstd%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_tcp.rs?ref=5d86686e7facd7a5e5acc1c8b682310ad1fe878c", "patch": "@@ -12,8 +12,10 @@ import result::*;\n import libc::size_t;\n import str::extensions;\n \n-// data\n-export tcp_socket, tcp_conn_port, tcp_err_data;\n+// tcp interfaces\n+export tcp_socket, tcp_conn_port;\n+// errors\n+export tcp_err_data, tcp_connect_err_data;\n // operations on a tcp_socket\n export write, write_future, read_start, read_stop;\n // tcp server stuff\n@@ -22,6 +24,7 @@ export new_listener, conn_recv, conn_recv_spawn, conn_peek;\n // tcp client stuff\n export connect;\n // helper methods\n+import methods = net_tcp_methods;\n export methods;\n \n #[nolink]\n@@ -43,25 +46,7 @@ class tcp_socket {\n   new(socket_data: @tcp_socket_data) { self.socket_data = socket_data; }\n   drop {\n     unsafe {\n-       let closed_po = comm::port::<()>();\n-       let closed_ch = comm::chan(closed_po);\n-       let close_data = {\n-             closed_ch: closed_ch\n-       };\n-       let close_data_ptr = ptr::addr_of(close_data);\n-       let stream_handle_ptr = (*(self.socket_data)).stream_handle_ptr;\n-       iotask::interact((*(self.socket_data)).iotask) {|loop_ptr|\n-          log(debug, #fmt(\"interact dtor for tcp_socket stream %? loop %?\",\n-            stream_handle_ptr, loop_ptr));\n-           uv::ll::set_data_for_uv_handle(stream_handle_ptr,\n-                                       close_data_ptr);\n-           uv::ll::close(stream_handle_ptr, tcp_socket_dtor_close_cb);\n-       };\n-       comm::recv(closed_po);\n-       log(debug, #fmt(\"about to free socket_data at %?\", self.socket_data));\n-       rustrt::rust_uv_current_kernel_free(stream_handle_ptr\n-                                           as *libc::c_void);\n-       log(debug, \"exiting dtor for tcp_socket\");\n+        tear_down_socket_data(socket_data)\n     }\n   }\n }\n@@ -90,6 +75,17 @@ type tcp_err_data = {\n     err_name: str,\n     err_msg: str\n };\n+enum tcp_connect_err_data {\n+    #[doc=\"\n+    Some unplanned-for error. The first and second fields correspond\n+    to libuv's `err_name` and `err_msg` fields, respectively.\n+    \"]\n+    generic_connect_err(str, str),\n+    #[doc=\"\n+    Invalid IP or invalid port\n+    \"]\n+    connection_refused\n+}\n \n #[doc=\"\n Initiate a client connection over TCP/IP\n@@ -108,7 +104,7 @@ of failure, a `tcp_err_data` will be returned\n \"]\n fn connect(input_ip: ip::ip_addr, port: uint,\n            iotask: iotask)\n-    -> result::result<tcp_socket, tcp_err_data> unsafe {\n+    -> result::result<tcp_socket, tcp_connect_err_data> unsafe {\n     let result_po = comm::port::<conn_attempt>();\n     let closed_signal_po = comm::port::<()>();\n     let conn_data = {\n@@ -198,7 +194,14 @@ fn connect(input_ip: ip::ip_addr, port: uint,\n       conn_failure(err_data) {\n         comm::recv(closed_signal_po);\n         log(debug, \"tcp::connect - received failure on result_po\");\n-        result::err(err_data.to_tcp_err())\n+        // still have to free the malloc'd stream handle..\n+        rustrt::rust_uv_current_kernel_free(stream_handle_ptr\n+                                           as *libc::c_void);\n+        let tcp_conn_err = alt err_data.err_name {\n+          \"ECONNREFUSED\" { connection_refused }\n+          _ { generic_connect_err(err_data.err_name, err_data.err_msg) }\n+        };\n+        result::err(tcp_conn_err)\n       }\n     }\n }\n@@ -777,7 +780,8 @@ fn listen_for_conn(host_ip: ip::ip_addr, port: uint, backlog: uint,\n       }\n     }\n }\n-mod methods {\n+\n+mod net_tcp_methods {\n     #[doc=\"\n     Convenience methods extending `net::tcp::tcp_conn_port`\n     \"]\n@@ -821,6 +825,28 @@ mod methods {\n }\n // INTERNAL API\n \n+fn tear_down_socket_data(socket_data: @tcp_socket_data) unsafe {\n+    let closed_po = comm::port::<()>();\n+    let closed_ch = comm::chan(closed_po);\n+    let close_data = {\n+        closed_ch: closed_ch\n+    };\n+    let close_data_ptr = ptr::addr_of(close_data);\n+    let stream_handle_ptr = (*socket_data).stream_handle_ptr;\n+    iotask::interact((*socket_data).iotask) {|loop_ptr|\n+        log(debug, #fmt(\"interact dtor for tcp_socket stream %? loop %?\",\n+            stream_handle_ptr, loop_ptr));\n+        uv::ll::set_data_for_uv_handle(stream_handle_ptr,\n+                                       close_data_ptr);\n+        uv::ll::close(stream_handle_ptr, tcp_socket_dtor_close_cb);\n+    };\n+    comm::recv(closed_po);\n+    log(debug, #fmt(\"about to free socket_data at %?\", socket_data));\n+    rustrt::rust_uv_current_kernel_free(stream_handle_ptr\n+                                       as *libc::c_void);\n+    log(debug, \"exiting dtor for tcp_socket\");\n+}\n+\n // shared implementation for tcp::read\n fn read_common_impl(socket_data: *tcp_socket_data, timeout_msecs: uint)\n     -> result::result<[u8]/~,tcp_err_data> unsafe {\n@@ -1308,6 +1334,10 @@ mod test {\n             fn test_gl_tcp_server_listener_and_client_ipv4() unsafe {\n                 impl_gl_tcp_ipv4_server_listener_and_client();\n             }\n+            #[test]\n+            fn test_gl_tcp_ipv4_client_error_connection_refused() unsafe {\n+                impl_gl_tcp_ipv4_client_error_connection_refused();\n+            }\n         }\n         #[cfg(target_arch=\"x86\")]\n         mod impl32 {\n@@ -1321,6 +1351,11 @@ mod test {\n             fn test_gl_tcp_server_listener_and_client_ipv4() unsafe {\n                 impl_gl_tcp_ipv4_server_listener_and_client();\n             }\n+            #[test]\n+            #[ignore(cfg(target_os = \"linux\"))]\n+            fn test_gl_tcp_ipv4_client_error_connection_refused() unsafe {\n+                impl_gl_tcp_ipv4_client_error_connection_refused();\n+            }\n         }\n     }\n     fn impl_gl_tcp_ipv4_server_and_client() {\n@@ -1351,14 +1386,16 @@ mod test {\n         comm::recv(cont_po);\n         // client\n         log(debug, \"server started, firing up client..\");\n-        let actual_resp = comm::listen {|client_ch|\n+        let actual_resp_result = comm::listen {|client_ch|\n             run_tcp_test_client(\n                 server_ip,\n                 server_port,\n                 expected_req,\n                 client_ch,\n                 hl_loop)\n         };\n+        assert actual_resp_result.is_success();\n+        let actual_resp = actual_resp_result.get();\n         let actual_req = comm::recv(server_result_po);\n         log(debug, #fmt(\"REQ: expected: '%s' actual: '%s'\",\n                        expected_req, actual_req));\n@@ -1395,14 +1432,16 @@ mod test {\n         comm::recv(cont_po);\n         // client\n         log(debug, \"server started, firing up client..\");\n-        let actual_resp = comm::listen {|client_ch|\n+        let actual_resp_result = comm::listen {|client_ch|\n             run_tcp_test_client(\n                 server_ip,\n                 server_port,\n                 expected_req,\n                 client_ch,\n                 hl_loop)\n         };\n+        assert actual_resp_result.is_success();\n+        let actual_resp = actual_resp_result.get();\n         let actual_req = comm::recv(server_result_po);\n         log(debug, #fmt(\"REQ: expected: '%s' actual: '%s'\",\n                        expected_req, actual_req));\n@@ -1411,6 +1450,29 @@ mod test {\n         assert str::contains(actual_req, expected_req);\n         assert str::contains(actual_resp, expected_resp);\n     }\n+    fn impl_gl_tcp_ipv4_client_error_connection_refused() {\n+        let hl_loop = uv::global_loop::get();\n+        let server_ip = \"127.0.0.1\";\n+        let server_port = 8890u;\n+        let expected_req = \"ping\";\n+        // client\n+        log(debug, \"firing up client..\");\n+        let actual_resp_result = comm::listen {|client_ch|\n+            run_tcp_test_client(\n+                server_ip,\n+                server_port,\n+                expected_req,\n+                client_ch,\n+                hl_loop)\n+        };\n+        alt actual_resp_result.get_err() {\n+          connection_refused {\n+          }\n+          _ {\n+            fail \"unknown error.. expected connection_refused\"\n+          }\n+        }\n+    }\n \n     fn run_tcp_test_server(server_ip: str, server_port: uint, resp: str,\n                           server_ch: comm::chan<str>,\n@@ -1453,7 +1515,7 @@ mod test {\n                             let sock = result::unwrap(accept_result);\n                             log(debug, \"SERVER: successfully accepted\"+\n                                 \"connection!\");\n-                            let received_req_bytes = sock.read(0u);\n+                            let received_req_bytes = read(sock, 0u);\n                             alt received_req_bytes {\n                               result::ok(data) {\n                                 server_ch.send(\n@@ -1522,7 +1584,7 @@ mod test {\n             log(debug, \"SERVER: successfully accepted\"+\n                 \"connection!\");\n             let received_req_bytes =\n-                sock.read(0u);\n+                read(sock, 0u);\n             alt received_req_bytes {\n               result::ok(data) {\n                 server_ch.send(\n@@ -1543,18 +1605,16 @@ mod test {\n \n     fn run_tcp_test_client(server_ip: str, server_port: uint, resp: str,\n                           client_ch: comm::chan<str>,\n-                          iotask: iotask) -> str {\n-\n+                          iotask: iotask) -> result::result<str,\n+                                                    tcp_connect_err_data> {\n         let server_ip_addr = ip::v4::parse_addr(server_ip);\n \n         log(debug, \"CLIENT: starting..\");\n         let connect_result = connect(server_ip_addr, server_port, iotask);\n         if result::is_err(connect_result) {\n             log(debug, \"CLIENT: failed to connect\");\n             let err_data = result::get_err(connect_result);\n-            log(debug, #fmt(\"CLIENT: connect err name: %s msg: %s\",\n-                            err_data.err_name, err_data.err_msg));\n-            \"\"\n+            err(err_data)\n         }\n         else {\n             let sock = result::unwrap(connect_result);\n@@ -1563,20 +1623,25 @@ mod test {\n             let read_result = sock.read(0u);\n             if read_result.is_err() {\n                 log(debug, \"CLIENT: failure to read\");\n-                \"\"\n+                ok(\"\")\n             }\n             else {\n                 client_ch.send(str::from_bytes(read_result.get()));\n                 let ret_val = client_ch.recv();\n                 log(debug, #fmt(\"CLIENT: after client_ch recv ret: '%s'\",\n                    ret_val));\n-                ret_val\n+                ok(ret_val)\n             }\n         }\n     }\n \n+<<<<<<< HEAD\n     fn tcp_write_single(sock: tcp_socket, val: [u8]/~) {\n         let write_result_future = sock.write_future(val);\n+=======\n+    fn tcp_write_single(sock: tcp_socket, val: [u8]) {\n+        let write_result_future = write_future(sock, val);\n+>>>>>>> std: mod cleanup, impl/test for conn. refused err + mem leak fix\n         let write_result = write_result_future.get();\n         if result::is_err(write_result) {\n             log(debug, \"tcp_write_single: write failed!\");"}]}