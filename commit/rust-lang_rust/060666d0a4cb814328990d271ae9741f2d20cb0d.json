{"sha": "060666d0a4cb814328990d271ae9741f2d20cb0d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA2MDY2NmQwYTRjYjgxNDMyODk5MGQyNzFhZTk3NDFmMmQyMGNiMGQ=", "commit": {"author": {"name": "jumbatm", "email": "30644300+jumbatm@users.noreply.github.com", "date": "2020-07-13T13:06:35Z"}, "committer": {"name": "jumbatm", "email": "30644300+jumbatm@users.noreply.github.com", "date": "2020-07-30T11:59:02Z"}, "message": "Address code review comments.\n\n- Make `is_repr_nullable_ptr` freestanding again to avoid usage of\nImproperCTypesVisitor in ClashingExternDeclarations (and don't\naccidentally revert the ParamEnv::reveal_all() fix from a week earlier)\n- Revise match condition for 1 Adt, 1 primitive\n- Generalise check for non-null type so that it would also work for\nranges which exclude any single value (all bits set, for example)\n- Make is_repr_nullable_ptr return the representable type instead of\njust a boolean, to avoid adding an additional, independent \"source of\ntruth\" about the FFI-compatibility of Option-like enums. Also, rename to\n`repr_nullable_ptr`.", "tree": {"sha": "f757bc62d1b9939bb2f05d06ea667b36d866fa55", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f757bc62d1b9939bb2f05d06ea667b36d866fa55"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/060666d0a4cb814328990d271ae9741f2d20cb0d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/060666d0a4cb814328990d271ae9741f2d20cb0d", "html_url": "https://github.com/rust-lang/rust/commit/060666d0a4cb814328990d271ae9741f2d20cb0d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/060666d0a4cb814328990d271ae9741f2d20cb0d/comments", "author": {"login": "jumbatm", "id": 30644300, "node_id": "MDQ6VXNlcjMwNjQ0MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/30644300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jumbatm", "html_url": "https://github.com/jumbatm", "followers_url": "https://api.github.com/users/jumbatm/followers", "following_url": "https://api.github.com/users/jumbatm/following{/other_user}", "gists_url": "https://api.github.com/users/jumbatm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jumbatm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jumbatm/subscriptions", "organizations_url": "https://api.github.com/users/jumbatm/orgs", "repos_url": "https://api.github.com/users/jumbatm/repos", "events_url": "https://api.github.com/users/jumbatm/events{/privacy}", "received_events_url": "https://api.github.com/users/jumbatm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jumbatm", "id": 30644300, "node_id": "MDQ6VXNlcjMwNjQ0MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/30644300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jumbatm", "html_url": "https://github.com/jumbatm", "followers_url": "https://api.github.com/users/jumbatm/followers", "following_url": "https://api.github.com/users/jumbatm/following{/other_user}", "gists_url": "https://api.github.com/users/jumbatm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jumbatm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jumbatm/subscriptions", "organizations_url": "https://api.github.com/users/jumbatm/orgs", "repos_url": "https://api.github.com/users/jumbatm/repos", "events_url": "https://api.github.com/users/jumbatm/events{/privacy}", "received_events_url": "https://api.github.com/users/jumbatm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5e52edca529ba5051d0bb752c751159d3057ab15", "url": "https://api.github.com/repos/rust-lang/rust/commits/5e52edca529ba5051d0bb752c751159d3057ab15", "html_url": "https://github.com/rust-lang/rust/commit/5e52edca529ba5051d0bb752c751159d3057ab15"}], "stats": {"total": 349, "additions": 202, "deletions": 147}, "files": [{"sha": "7c4f893ce1d4254e4e7f48d62f4ae8259edb90c9", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 46, "deletions": 63, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/060666d0a4cb814328990d271ae9741f2d20cb0d/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/060666d0a4cb814328990d271ae9741f2d20cb0d/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=060666d0a4cb814328990d271ae9741f2d20cb0d", "patch": "@@ -20,7 +20,9 @@\n //! If you define a new `LateLintPass`, you will also need to add it to the\n //! `late_lint_methods!` invocation in `lib.rs`.\n \n-use crate::{EarlyContext, EarlyLintPass, LateContext, LateLintPass, LintContext};\n+use crate::{\n+    types::CItemKind, EarlyContext, EarlyLintPass, LateContext, LateLintPass, LintContext,\n+};\n use rustc_ast::ast::{self, Expr};\n use rustc_ast::attr::{self, HasAttrs};\n use rustc_ast::tokenstream::{TokenStream, TokenTree};\n@@ -2144,7 +2146,13 @@ impl ClashingExternDeclarations {\n     /// Checks whether two types are structurally the same enough that the declarations shouldn't\n     /// clash. We need this so we don't emit a lint when two modules both declare an extern struct,\n     /// with the same members (as the declarations shouldn't clash).\n-    fn structurally_same_type<'tcx>(cx: &LateContext<'tcx>, a: Ty<'tcx>, b: Ty<'tcx>) -> bool {\n+    fn structurally_same_type<'tcx>(\n+        cx: &LateContext<'tcx>,\n+        a: Ty<'tcx>,\n+        b: Ty<'tcx>,\n+        ckind: CItemKind,\n+    ) -> bool {\n+        debug!(\"structurally_same_type(cx, a = {:?}, b = {:?})\", a, b);\n         let tcx = cx.tcx;\n         if a == b || rustc_middle::ty::TyS::same_type(a, b) {\n             // All nominally-same types are structurally same, too.\n@@ -2156,29 +2164,30 @@ impl ClashingExternDeclarations {\n             let b_kind = &b.kind;\n \n             use rustc_target::abi::LayoutOf;\n-            let compare_layouts = |a, b| {\n-                let a_layout = &cx.layout_of(a).unwrap().layout.abi;\n-                let b_layout = &cx.layout_of(b).unwrap().layout.abi;\n-                let result = a_layout == b_layout;\n-                result\n+            let compare_layouts = |a, b| -> bool {\n+                &cx.layout_of(a).unwrap().layout.abi == &cx.layout_of(b).unwrap().layout.abi\n             };\n \n+            #[allow(rustc::usage_of_ty_tykind)]\n+            let is_primitive_or_pointer =\n+                |kind: &ty::TyKind<'_>| kind.is_primitive() || matches!(kind, RawPtr(..));\n+\n             match (a_kind, b_kind) {\n                 (Adt(..), Adt(..)) => compare_layouts(a, b),\n                 (Array(a_ty, a_const), Array(b_ty, b_const)) => {\n                     // For arrays, we also check the constness of the type.\n                     a_const.val == b_const.val\n-                        && Self::structurally_same_type(cx, a_const.ty, b_const.ty)\n-                        && Self::structurally_same_type(cx, a_ty, b_ty)\n+                        && Self::structurally_same_type(cx, a_const.ty, b_const.ty, ckind)\n+                        && Self::structurally_same_type(cx, a_ty, b_ty, ckind)\n                 }\n-                (Slice(a_ty), Slice(b_ty)) => Self::structurally_same_type(cx, a_ty, b_ty),\n+                (Slice(a_ty), Slice(b_ty)) => Self::structurally_same_type(cx, a_ty, b_ty, ckind),\n                 (RawPtr(a_tymut), RawPtr(b_tymut)) => {\n                     a_tymut.mutbl == a_tymut.mutbl\n-                        && Self::structurally_same_type(cx, &a_tymut.ty, &b_tymut.ty)\n+                        && Self::structurally_same_type(cx, &a_tymut.ty, &b_tymut.ty, ckind)\n                 }\n                 (Ref(_a_region, a_ty, a_mut), Ref(_b_region, b_ty, b_mut)) => {\n                     // For structural sameness, we don't need the region to be same.\n-                    a_mut == b_mut && Self::structurally_same_type(cx, a_ty, b_ty)\n+                    a_mut == b_mut && Self::structurally_same_type(cx, a_ty, b_ty, ckind)\n                 }\n                 (FnDef(..), FnDef(..)) => {\n                     let a_poly_sig = a.fn_sig(tcx);\n@@ -2191,13 +2200,13 @@ impl ClashingExternDeclarations {\n                     (a_sig.abi, a_sig.unsafety, a_sig.c_variadic)\n                         == (b_sig.abi, b_sig.unsafety, b_sig.c_variadic)\n                         && a_sig.inputs().iter().eq_by(b_sig.inputs().iter(), |a, b| {\n-                            Self::structurally_same_type(cx, a, b)\n+                            Self::structurally_same_type(cx, a, b, ckind)\n                         })\n-                        && Self::structurally_same_type(cx, a_sig.output(), b_sig.output())\n+                        && Self::structurally_same_type(cx, a_sig.output(), b_sig.output(), ckind)\n                 }\n                 (Tuple(a_substs), Tuple(b_substs)) => {\n                     a_substs.types().eq_by(b_substs.types(), |a_ty, b_ty| {\n-                        Self::structurally_same_type(cx, a_ty, b_ty)\n+                        Self::structurally_same_type(cx, a_ty, b_ty, ckind)\n                     })\n                 }\n                 // For these, it's not quite as easy to define structural-sameness quite so easily.\n@@ -2210,58 +2219,27 @@ impl ClashingExternDeclarations {\n                 | (GeneratorWitness(..), GeneratorWitness(..))\n                 | (Projection(..), Projection(..))\n                 | (Opaque(..), Opaque(..)) => false,\n+\n                 // These definitely should have been caught above.\n                 (Bool, Bool) | (Char, Char) | (Never, Never) | (Str, Str) => unreachable!(),\n \n-                // Disjoint kinds.\n-                (_, _) => {\n-                    // First, check if the conversion is FFI-safe. This can happen if the type is an\n-                    // enum with a non-null field (see improper_ctypes).\n-                    let is_primitive_or_pointer =\n-                        |ty: Ty<'tcx>| ty.is_primitive() || matches!(ty.kind, RawPtr(..));\n-                    if (is_primitive_or_pointer(a) || is_primitive_or_pointer(b))\n-                        && !(is_primitive_or_pointer(a) && is_primitive_or_pointer(b))\n-                        && (matches!(a_kind, Adt(..)) || matches!(b_kind, Adt(..)))\n-                    /* ie, 1 adt and 1 primitive */\n-                    {\n-                        let (primitive_ty, adt_ty) =\n-                            if is_primitive_or_pointer(a) { (a, b) } else { (b, a) };\n-                        // First, check that the Adt is FFI-safe to use.\n-                        use crate::types::{ImproperCTypesMode, ImproperCTypesVisitor};\n-                        let vis =\n-                            ImproperCTypesVisitor { cx, mode: ImproperCTypesMode::Declarations };\n-\n-                        if let Adt(def, substs) = adt_ty.kind {\n-                            let repr_nullable = vis.is_repr_nullable_ptr(adt_ty, def, substs);\n-                            if let Some(safe_ty) = repr_nullable {\n-                                let safe_ty_layout = &cx.layout_of(safe_ty).unwrap();\n-                                let primitive_ty_layout = &cx.layout_of(primitive_ty).unwrap();\n-\n-                                use rustc_target::abi::Abi::*;\n-                                match (&safe_ty_layout.abi, &primitive_ty_layout.abi) {\n-                                    (Scalar(safe), Scalar(primitive)) => {\n-                                        // The two types are safe to convert between if `safe` is\n-                                        // the non-zero version of `primitive`.\n-                                        use std::ops::RangeInclusive;\n-\n-                                        let safe_range: &RangeInclusive<_> = &safe.valid_range;\n-                                        let primitive_range: &RangeInclusive<_> =\n-                                            &primitive.valid_range;\n-\n-                                        return primitive_range.end() == safe_range.end()\n-                                            // This check works for both signed and unsigned types due to wraparound.\n-                                            && *safe_range.start() == 1\n-                                            && *primitive_range.start() == 0;\n-                                    }\n-                                    _ => {}\n-                                }\n-                            }\n-                        }\n+                // An Adt and a primitive type. This can be FFI-safe is the ADT is an enum with a\n+                // non-null field.\n+                (Adt(..), other_kind) | (other_kind, Adt(..))\n+                    if is_primitive_or_pointer(other_kind) =>\n+                {\n+                    let (primitive, adt) =\n+                        if is_primitive_or_pointer(&a.kind) { (a, b) } else { (b, a) };\n+                    if let Some(ty) = crate::types::repr_nullable_ptr(cx, adt, ckind) {\n+                        ty == primitive\n+                    } else {\n+                        compare_layouts(a, b)\n                     }\n-                    // Otherwise, just compare the layouts. This may be underapproximate, but at\n-                    // the very least, will stop reads into uninitialised memory.\n-                    compare_layouts(a, b)\n                 }\n+                // Otherwise, just compare the layouts. This may fail to lint for some\n+                // incompatible types, but at the very least, will stop reads into\n+                // uninitialised memory.\n+                _ => compare_layouts(a, b),\n             }\n         }\n     }\n@@ -2282,7 +2260,12 @@ impl<'tcx> LateLintPass<'tcx> for ClashingExternDeclarations {\n                     existing_hid, existing_decl_ty, this_fi.hir_id, this_decl_ty\n                 );\n                 // Check that the declarations match.\n-                if !Self::structurally_same_type(cx, existing_decl_ty, this_decl_ty) {\n+                if !Self::structurally_same_type(\n+                    cx,\n+                    existing_decl_ty,\n+                    this_decl_ty,\n+                    CItemKind::Declaration,\n+                ) {\n                     let orig_fi = tcx.hir().expect_foreign_item(existing_hid);\n                     let orig = Self::name_of_extern_decl(tcx, orig_fi);\n "}, {"sha": "a35c313d0b643386c7a270de59eb73fce8567f4c", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 122, "deletions": 74, "changes": 196, "blob_url": "https://github.com/rust-lang/rust/blob/060666d0a4cb814328990d271ae9741f2d20cb0d/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/060666d0a4cb814328990d271ae9741f2d20cb0d/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=060666d0a4cb814328990d271ae9741f2d20cb0d", "patch": "@@ -11,12 +11,13 @@ use rustc_index::vec::Idx;\n use rustc_middle::mir::interpret::{sign_extend, truncate};\n use rustc_middle::ty::layout::{IntegerExt, SizeSkeleton};\n use rustc_middle::ty::subst::SubstsRef;\n-use rustc_middle::ty::{self, AdtKind, Ty, TypeFoldable};\n+use rustc_middle::ty::{self, AdtKind, Ty, TyCtxt, TypeFoldable};\n use rustc_span::source_map;\n use rustc_span::symbol::sym;\n use rustc_span::{Span, DUMMY_SP};\n+use rustc_target::abi::Abi;\n use rustc_target::abi::{Integer, LayoutOf, TagEncoding, VariantIdx, Variants};\n-use rustc_target::spec::abi::Abi;\n+use rustc_target::spec::abi::Abi as SpecAbi;\n \n use log::debug;\n use std::cmp;\n@@ -509,14 +510,15 @@ declare_lint! {\n \n declare_lint_pass!(ImproperCTypesDefinitions => [IMPROPER_CTYPES_DEFINITIONS]);\n \n-crate enum ImproperCTypesMode {\n-    Declarations,\n-    Definitions,\n+#[derive(Clone, Copy)]\n+crate enum CItemKind {\n+    Declaration,\n+    Definition,\n }\n \n-crate struct ImproperCTypesVisitor<'a, 'tcx> {\n-    crate cx: &'a LateContext<'tcx>,\n-    crate mode: ImproperCTypesMode,\n+struct ImproperCTypesVisitor<'a, 'tcx> {\n+    cx: &'a LateContext<'tcx>,\n+    mode: CItemKind,\n }\n \n enum FfiResult<'tcx> {\n@@ -525,53 +527,87 @@ enum FfiResult<'tcx> {\n     FfiUnsafe { ty: Ty<'tcx>, reason: String, help: Option<String> },\n }\n \n-impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n-    /// Is type known to be non-null?\n-    fn ty_is_known_nonnull(&self, ty: Ty<'tcx>) -> bool {\n-        match ty.kind {\n-            ty::FnPtr(_) => true,\n-            ty::Ref(..) => true,\n-            ty::Adt(def, _)\n-                if def.is_box() && matches!(self.mode, ImproperCTypesMode::Definitions) =>\n-            {\n-                true\n-            }\n-            ty::Adt(def, substs) if def.repr.transparent() && !def.is_union() => {\n-                let guaranteed_nonnull_optimization = self\n-                    .cx\n-                    .tcx\n-                    .get_attrs(def.did)\n-                    .iter()\n-                    .any(|a| a.check_name(sym::rustc_nonnull_optimization_guaranteed));\n-\n-                if guaranteed_nonnull_optimization {\n-                    return true;\n-                }\n+/// Is type known to be non-null?\n+fn ty_is_known_nonnull<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, mode: CItemKind) -> bool {\n+    let tcx = cx.tcx;\n+    match ty.kind {\n+        ty::FnPtr(_) => true,\n+        ty::Ref(..) => true,\n+        ty::Adt(def, _) if def.is_box() && matches!(mode, CItemKind::Definition) => true,\n+        ty::Adt(def, substs) if def.repr.transparent() && !def.is_union() => {\n+            let guaranteed_nonnull_optimization = tcx\n+                .get_attrs(def.did)\n+                .iter()\n+                .any(|a| a.check_name(sym::rustc_nonnull_optimization_guaranteed));\n \n-                for variant in &def.variants {\n-                    if let Some(field) = variant.transparent_newtype_field(self.cx.tcx) {\n-                        if self.ty_is_known_nonnull(field.ty(self.cx.tcx, substs)) {\n-                            return true;\n-                        }\n+            if guaranteed_nonnull_optimization {\n+                return true;\n+            }\n+            for variant in &def.variants {\n+                if let Some(field) = variant.transparent_newtype_field(tcx) {\n+                    if ty_is_known_nonnull(cx, field.ty(tcx, substs), mode) {\n+                        return true;\n                     }\n                 }\n-\n-                false\n             }\n-            _ => false,\n+\n+            false\n         }\n+        _ => false,\n     }\n+}\n+/// Given a potentially non-null type `ty`, return its default, nullable type.\n+fn get_nullable_type<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> {\n+    match ty.kind {\n+        ty::Adt(field_def, field_substs) => {\n+            let field_variants = &field_def.variants;\n+            // We hit this case for #[repr(transparent)] structs with a single\n+            // field.\n+            debug_assert!(\n+                field_variants.len() == 1 && field_variants[VariantIdx::new(0)].fields.len() == 1,\n+                \"inner ty not a newtype struct\"\n+            );\n+            debug_assert!(field_def.repr.transparent(), \"inner ty not transparent\");\n+            // As it's easy to get this wrong, it's worth noting that\n+            // `inner_field_ty` is not the same as `field_ty`: Given Option<S>,\n+            // where S is a transparent newtype of some type T, `field_ty`\n+            // gives us S, while `inner_field_ty` is T.\n+            let inner_field_ty =\n+                field_def.variants[VariantIdx::new(0)].fields[0].ty(tcx, field_substs);\n+            get_nullable_type(tcx, inner_field_ty)\n+        }\n+        ty::Int(ty) => tcx.mk_mach_int(ty),\n+        ty::Uint(ty) => tcx.mk_mach_uint(ty),\n+        ty::RawPtr(ty_mut) => tcx.mk_ptr(ty_mut),\n+        // As these types are always non-null, the nullable equivalent of\n+        // Option<T> of these types are their raw pointer counterparts.\n+        ty::Ref(_region, ty, mutbl) => tcx.mk_ptr(ty::TypeAndMut { ty, mutbl }),\n+        ty::FnPtr(..) => {\n+            // There is no nullable equivalent for Rust's function pointers -- you\n+            // must use an Option<fn(..) -> _> to represent it.\n+            ty\n+        }\n \n-    /// Check if this enum can be safely exported based on the \"nullable pointer optimization\". If\n-    /// it can, return the known non-null field type, otherwise return `None`. Currently restricted\n-    /// to function pointers, boxes, references, `core::num::NonZero*`, `core::ptr::NonNull`, and\n-    /// `#[repr(transparent)]` newtypes.\n-    crate fn is_repr_nullable_ptr(\n-        &self,\n-        ty: Ty<'tcx>,\n-        ty_def: &'tcx ty::AdtDef,\n-        substs: SubstsRef<'tcx>,\n-    ) -> Option<Ty<'tcx>> {\n+        // We should only ever reach this case if ty_is_known_nonnull is extended\n+        // to other types.\n+        ref unhandled => {\n+            unreachable!(\"Unhandled scalar kind: {:?} while checking {:?}\", unhandled, ty)\n+        }\n+    }\n+}\n+\n+/// Check if this enum can be safely exported based on the \"nullable pointer optimization\". If it\n+/// can, return the the type that `ty` can be safely converted to, otherwise return `None`.\n+/// Currently restricted to function pointers, boxes, references, `core::num::NonZero*`,\n+/// `core::ptr::NonNull`, and `#[repr(transparent)]` newtypes.\n+/// FIXME: This duplicates code in codegen.\n+crate fn repr_nullable_ptr<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    ty: Ty<'tcx>,\n+    ckind: CItemKind,\n+) -> Option<Ty<'tcx>> {\n+    debug!(\"is_repr_nullable_ptr(cx, ty = {:?})\", ty);\n+    if let ty::Adt(ty_def, substs) = ty.kind {\n         if ty_def.variants.len() != 2 {\n             return None;\n         }\n@@ -590,23 +626,35 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n             return None;\n         }\n \n-        let field_ty = fields[0].ty(self.cx.tcx, substs);\n-        if !self.ty_is_known_nonnull(field_ty) {\n+        let field_ty = fields[0].ty(cx.tcx, substs);\n+        if !ty_is_known_nonnull(cx, field_ty, ckind) {\n             return None;\n         }\n \n-        // At this point, the field's type is known to be nonnull and the parent enum is\n-        // Option-like. If the computed size for the field and the enum are different, the non-null\n-        // optimization isn't being applied (and we've got a problem somewhere).\n-        let compute_size_skeleton =\n-            |t| SizeSkeleton::compute(t, self.cx.tcx, self.cx.param_env).unwrap();\n+        // At this point, the field's type is known to be nonnull and the parent enum is Option-like.\n+        // If the computed size for the field and the enum are different, the nonnull optimization isn't\n+        // being applied (and we've got a problem somewhere).\n+        let compute_size_skeleton = |t| SizeSkeleton::compute(t, cx.tcx, cx.param_env).unwrap();\n         if !compute_size_skeleton(ty).same_size(compute_size_skeleton(field_ty)) {\n             bug!(\"improper_ctypes: Option nonnull optimization not applied?\");\n         }\n \n-        Some(field_ty)\n+        // Return the nullable type this Option-like enum can be safely represented with.\n+        let field_ty_abi = &cx.layout_of(field_ty).unwrap().abi;\n+        if let Abi::Scalar(field_ty_scalar) = field_ty_abi {\n+            match (field_ty_scalar.valid_range.start(), field_ty_scalar.valid_range.end()) {\n+                (0, _) => bug!(\"Non-null optimisation extended to a non-zero value.\"),\n+                (1, _) => {\n+                    return Some(get_nullable_type(cx.tcx, field_ty));\n+                }\n+                (start, end) => unreachable!(\"Unhandled start and end range: ({}, {})\", start, end),\n+            };\n+        }\n     }\n+    None\n+}\n \n+impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n     /// Check if the type is array and emit an unsafe type lint.\n     fn check_for_array_ty(&mut self, sp: Span, ty: Ty<'tcx>) -> bool {\n         if let ty::Array(..) = ty.kind {\n@@ -687,7 +735,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n     fn check_type_for_ffi(&self, cache: &mut FxHashSet<Ty<'tcx>>, ty: Ty<'tcx>) -> FfiResult<'tcx> {\n         use FfiResult::*;\n \n-        let cx = self.cx.tcx;\n+        let tcx = self.cx.tcx;\n \n         // Protect against infinite recursion, for example\n         // `struct S(*mut S);`.\n@@ -698,9 +746,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n         }\n \n         match ty.kind {\n-            ty::Adt(def, _)\n-                if def.is_box() && matches!(self.mode, ImproperCTypesMode::Definitions) =>\n-            {\n+            ty::Adt(def, _) if def.is_box() && matches!(self.mode, CItemKind::Definition) => {\n                 FfiSafe\n             }\n \n@@ -754,7 +800,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                         // discriminant.\n                         if !def.repr.c() && !def.repr.transparent() && def.repr.int.is_none() {\n                             // Special-case types like `Option<extern fn()>`.\n-                            if self.is_repr_nullable_ptr(ty, def, substs).is_none() {\n+                            if repr_nullable_ptr(self.cx, ty, self.mode).is_none() {\n                                 return FfiUnsafe {\n                                     ty,\n                                     reason: \"enum has no representation hint\".into(),\n@@ -837,7 +883,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n \n             ty::RawPtr(ty::TypeAndMut { ty, .. }) | ty::Ref(_, ty, _)\n                 if {\n-                    matches!(self.mode, ImproperCTypesMode::Definitions)\n+                    matches!(self.mode, CItemKind::Definition)\n                         && ty.is_sized(self.cx.tcx.at(DUMMY_SP), self.cx.param_env)\n                 } =>\n             {\n@@ -863,7 +909,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                     };\n                 }\n \n-                let sig = cx.erase_late_bound_regions(&sig);\n+                let sig = tcx.erase_late_bound_regions(&sig);\n                 if !sig.output().is_unit() {\n                     let r = self.check_type_for_ffi(cache, sig.output());\n                     match r {\n@@ -895,9 +941,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n \n             // `extern \"C\" fn` functions can have type parameters, which may or may not be FFI-safe,\n             //  so they are currently ignored for the purposes of this lint.\n-            ty::Param(..) | ty::Projection(..)\n-                if matches!(self.mode, ImproperCTypesMode::Definitions) =>\n-            {\n+            ty::Param(..) | ty::Projection(..) if matches!(self.mode, CItemKind::Definition) => {\n                 FfiSafe\n             }\n \n@@ -922,14 +966,14 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n         help: Option<&str>,\n     ) {\n         let lint = match self.mode {\n-            ImproperCTypesMode::Declarations => IMPROPER_CTYPES,\n-            ImproperCTypesMode::Definitions => IMPROPER_CTYPES_DEFINITIONS,\n+            CItemKind::Declaration => IMPROPER_CTYPES,\n+            CItemKind::Definition => IMPROPER_CTYPES_DEFINITIONS,\n         };\n \n         self.cx.struct_span_lint(lint, sp, |lint| {\n             let item_description = match self.mode {\n-                ImproperCTypesMode::Declarations => \"block\",\n-                ImproperCTypesMode::Definitions => \"fn\",\n+                CItemKind::Declaration => \"block\",\n+                CItemKind::Definition => \"fn\",\n             };\n             let mut diag = lint.build(&format!(\n                 \"`extern` {} uses type `{}`, which is not FFI-safe\",\n@@ -1053,8 +1097,12 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n         self.check_type_for_ffi_and_report_errors(span, ty, true, false);\n     }\n \n-    fn is_internal_abi(&self, abi: Abi) -> bool {\n-        if let Abi::Rust | Abi::RustCall | Abi::RustIntrinsic | Abi::PlatformIntrinsic = abi {\n+    fn is_internal_abi(&self, abi: SpecAbi) -> bool {\n+        if let SpecAbi::Rust\n+        | SpecAbi::RustCall\n+        | SpecAbi::RustIntrinsic\n+        | SpecAbi::PlatformIntrinsic = abi\n+        {\n             true\n         } else {\n             false\n@@ -1064,7 +1112,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n \n impl<'tcx> LateLintPass<'tcx> for ImproperCTypesDeclarations {\n     fn check_foreign_item(&mut self, cx: &LateContext<'_>, it: &hir::ForeignItem<'_>) {\n-        let mut vis = ImproperCTypesVisitor { cx, mode: ImproperCTypesMode::Declarations };\n+        let mut vis = ImproperCTypesVisitor { cx, mode: CItemKind::Declaration };\n         let abi = cx.tcx.hir().get_foreign_abi(it.hir_id);\n \n         if !vis.is_internal_abi(abi) {\n@@ -1099,7 +1147,7 @@ impl<'tcx> LateLintPass<'tcx> for ImproperCTypesDefinitions {\n             _ => return,\n         };\n \n-        let mut vis = ImproperCTypesVisitor { cx, mode: ImproperCTypesMode::Definitions };\n+        let mut vis = ImproperCTypesVisitor { cx, mode: CItemKind::Definition };\n         if !vis.is_internal_abi(abi) {\n             vis.check_foreign_fn(hir_id, decl);\n         }"}, {"sha": "310ab4f7235ebf8e57fc4d5b8603619b62e6c81a", "filename": "src/librustc_middle/ty/sty.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/060666d0a4cb814328990d271ae9741f2d20cb0d/src%2Flibrustc_middle%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/060666d0a4cb814328990d271ae9741f2d20cb0d/src%2Flibrustc_middle%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fsty.rs?ref=060666d0a4cb814328990d271ae9741f2d20cb0d", "patch": "@@ -202,6 +202,16 @@ pub enum TyKind<'tcx> {\n     Error(DelaySpanBugEmitted),\n }\n \n+impl TyKind<'tcx> {\n+    #[inline]\n+    pub fn is_primitive(&self) -> bool {\n+        match self {\n+            Bool | Char | Int(_) | Uint(_) | Float(_) => true,\n+            _ => false,\n+        }\n+    }\n+}\n+\n /// A type that is not publicly constructable. This prevents people from making `TyKind::Error`\n /// except through `tcx.err*()`.\n #[derive(Copy, Clone, Debug, Eq, Hash, PartialEq, PartialOrd, Ord)]\n@@ -1766,10 +1776,7 @@ impl<'tcx> TyS<'tcx> {\n \n     #[inline]\n     pub fn is_primitive(&self) -> bool {\n-        match self.kind {\n-            Bool | Char | Int(_) | Uint(_) | Float(_) => true,\n-            _ => false,\n-        }\n+        self.kind.is_primitive()\n     }\n \n     #[inline]"}, {"sha": "e165a4f4658d9e2cd9bc3dcba74470fb4fd8584e", "filename": "src/test/ui/lint/clashing-extern-fn.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/060666d0a4cb814328990d271ae9741f2d20cb0d/src%2Ftest%2Fui%2Flint%2Fclashing-extern-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/060666d0a4cb814328990d271ae9741f2d20cb0d/src%2Ftest%2Fui%2Flint%2Fclashing-extern-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fclashing-extern-fn.rs?ref=060666d0a4cb814328990d271ae9741f2d20cb0d", "patch": "@@ -181,6 +181,7 @@ mod transparent {\n         use super::T;\n         extern \"C\" {\n             fn transparent() -> T;\n+            fn transparent_incorrect() -> T;\n         }\n     }\n \n@@ -189,6 +190,10 @@ mod transparent {\n             // Shouldn't warn here, because repr(transparent) guarantees that T's layout is the\n             // same as just the usize.\n             fn transparent() -> usize;\n+\n+            // Should warn, because there's a signedness conversion here:\n+            fn transparent_incorrect() -> isize;\n+            //~^ WARN `transparent_incorrect` redeclared with a different signature\n         }\n     }\n }"}, {"sha": "31810a2998ac8a749fd47755b193b5649e3b9002", "filename": "src/test/ui/lint/clashing-extern-fn.stderr", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/060666d0a4cb814328990d271ae9741f2d20cb0d/src%2Ftest%2Fui%2Flint%2Fclashing-extern-fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/060666d0a4cb814328990d271ae9741f2d20cb0d/src%2Ftest%2Fui%2Flint%2Fclashing-extern-fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fclashing-extern-fn.stderr?ref=060666d0a4cb814328990d271ae9741f2d20cb0d", "patch": "@@ -105,8 +105,20 @@ LL |             fn draw_point(p: Point);\n    = note: expected `unsafe extern \"C\" fn(sameish_members::a::Point)`\n               found `unsafe extern \"C\" fn(sameish_members::b::Point)`\n \n+warning: `transparent_incorrect` redeclared with a different signature\n+  --> $DIR/clashing-extern-fn.rs:195:13\n+   |\n+LL |             fn transparent_incorrect() -> T;\n+   |             -------------------------------- `transparent_incorrect` previously declared here\n+...\n+LL |             fn transparent_incorrect() -> isize;\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this signature doesn't match the previous declaration\n+   |\n+   = note: expected `unsafe extern \"C\" fn() -> transparent::T`\n+              found `unsafe extern \"C\" fn() -> isize`\n+\n warning: `missing_return_type` redeclared with a different signature\n-  --> $DIR/clashing-extern-fn.rs:208:13\n+  --> $DIR/clashing-extern-fn.rs:213:13\n    |\n LL |             fn missing_return_type() -> usize;\n    |             ---------------------------------- `missing_return_type` previously declared here\n@@ -118,7 +130,7 @@ LL |             fn missing_return_type();\n               found `unsafe extern \"C\" fn()`\n \n warning: `non_zero_usize` redeclared with a different signature\n-  --> $DIR/clashing-extern-fn.rs:226:13\n+  --> $DIR/clashing-extern-fn.rs:231:13\n    |\n LL |             fn non_zero_usize() -> core::num::NonZeroUsize;\n    |             ----------------------------------------------- `non_zero_usize` previously declared here\n@@ -130,7 +142,7 @@ LL |             fn non_zero_usize() -> usize;\n               found `unsafe extern \"C\" fn() -> usize`\n \n warning: `non_null_ptr` redeclared with a different signature\n-  --> $DIR/clashing-extern-fn.rs:228:13\n+  --> $DIR/clashing-extern-fn.rs:233:13\n    |\n LL |             fn non_null_ptr() -> core::ptr::NonNull<usize>;\n    |             ----------------------------------------------- `non_null_ptr` previously declared here\n@@ -142,7 +154,7 @@ LL |             fn non_null_ptr() -> *const usize;\n               found `unsafe extern \"C\" fn() -> *const usize`\n \n warning: `option_non_zero_usize_incorrect` redeclared with a different signature\n-  --> $DIR/clashing-extern-fn.rs:254:13\n+  --> $DIR/clashing-extern-fn.rs:259:13\n    |\n LL |             fn option_non_zero_usize_incorrect() -> usize;\n    |             ---------------------------------------------- `option_non_zero_usize_incorrect` previously declared here\n@@ -154,7 +166,7 @@ LL |             fn option_non_zero_usize_incorrect() -> isize;\n               found `unsafe extern \"C\" fn() -> isize`\n \n warning: `option_non_null_ptr_incorrect` redeclared with a different signature\n-  --> $DIR/clashing-extern-fn.rs:256:13\n+  --> $DIR/clashing-extern-fn.rs:261:13\n    |\n LL |             fn option_non_null_ptr_incorrect() -> *const usize;\n    |             --------------------------------------------------- `option_non_null_ptr_incorrect` previously declared here\n@@ -165,5 +177,5 @@ LL |             fn option_non_null_ptr_incorrect() -> *const isize;\n    = note: expected `unsafe extern \"C\" fn() -> *const usize`\n               found `unsafe extern \"C\" fn() -> *const isize`\n \n-warning: 13 warnings emitted\n+warning: 14 warnings emitted\n "}]}