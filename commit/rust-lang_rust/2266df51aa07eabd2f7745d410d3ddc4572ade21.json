{"sha": "2266df51aa07eabd2f7745d410d3ddc4572ade21", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIyNjZkZjUxYWEwN2VhYmQyZjc3NDVkNDEwZDNkZGM0NTcyYWRlMjE=", "commit": {"author": {"name": "Steven Fackler", "email": "sfackler@gmail.com", "date": "2013-08-04T18:42:39Z"}, "committer": {"name": "Steven Fackler", "email": "sfackler@gmail.com", "date": "2013-08-06T16:58:35Z"}, "message": "Added hexadecimal encoding module\n\nFromHex ignores whitespace and parses either upper or lower case hex\ndigits. ToHex outputs lower case hex digits with no whitespace. Unlike\nToBase64, ToHex doesn't allow you to configure the output format. I\ndon't feel that it's super useful in this case.", "tree": {"sha": "ddfe8c6c26f1bd6ef29395eb945791140cf03377", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ddfe8c6c26f1bd6ef29395eb945791140cf03377"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2266df51aa07eabd2f7745d410d3ddc4572ade21", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2266df51aa07eabd2f7745d410d3ddc4572ade21", "html_url": "https://github.com/rust-lang/rust/commit/2266df51aa07eabd2f7745d410d3ddc4572ade21", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2266df51aa07eabd2f7745d410d3ddc4572ade21/comments", "author": {"login": "sfackler", "id": 1455697, "node_id": "MDQ6VXNlcjE0NTU2OTc=", "avatar_url": "https://avatars.githubusercontent.com/u/1455697?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sfackler", "html_url": "https://github.com/sfackler", "followers_url": "https://api.github.com/users/sfackler/followers", "following_url": "https://api.github.com/users/sfackler/following{/other_user}", "gists_url": "https://api.github.com/users/sfackler/gists{/gist_id}", "starred_url": "https://api.github.com/users/sfackler/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sfackler/subscriptions", "organizations_url": "https://api.github.com/users/sfackler/orgs", "repos_url": "https://api.github.com/users/sfackler/repos", "events_url": "https://api.github.com/users/sfackler/events{/privacy}", "received_events_url": "https://api.github.com/users/sfackler/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sfackler", "id": 1455697, "node_id": "MDQ6VXNlcjE0NTU2OTc=", "avatar_url": "https://avatars.githubusercontent.com/u/1455697?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sfackler", "html_url": "https://github.com/sfackler", "followers_url": "https://api.github.com/users/sfackler/followers", "following_url": "https://api.github.com/users/sfackler/following{/other_user}", "gists_url": "https://api.github.com/users/sfackler/gists{/gist_id}", "starred_url": "https://api.github.com/users/sfackler/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sfackler/subscriptions", "organizations_url": "https://api.github.com/users/sfackler/orgs", "repos_url": "https://api.github.com/users/sfackler/repos", "events_url": "https://api.github.com/users/sfackler/events{/privacy}", "received_events_url": "https://api.github.com/users/sfackler/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ba3d03d3a4836aa5776ca8c4cb0e9982b00f516b", "url": "https://api.github.com/repos/rust-lang/rust/commits/ba3d03d3a4836aa5776ca8c4cb0e9982b00f516b", "html_url": "https://github.com/rust-lang/rust/commit/ba3d03d3a4836aa5776ca8c4cb0e9982b00f516b"}], "stats": {"total": 239, "additions": 239, "deletions": 0}, "files": [{"sha": "44781a1fd19b632f0794802ae3d9ee8cbae167ce", "filename": "src/libextra/extra.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2266df51aa07eabd2f7745d410d3ddc4572ade21/src%2Flibextra%2Fextra.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2266df51aa07eabd2f7745d410d3ddc4572ade21/src%2Flibextra%2Fextra.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fextra.rs?ref=2266df51aa07eabd2f7745d410d3ddc4572ade21", "patch": "@@ -102,6 +102,7 @@ pub mod stats;\n pub mod semver;\n pub mod fileinput;\n pub mod flate;\n+pub mod hex;\n \n #[cfg(unicode)]\n mod unicode;"}, {"sha": "7a1417e72d8cc5d614c0c1ac6a07656048ae263e", "filename": "src/libextra/hex.rs", "status": "added", "additions": 238, "deletions": 0, "changes": 238, "blob_url": "https://github.com/rust-lang/rust/blob/2266df51aa07eabd2f7745d410d3ddc4572ade21/src%2Flibextra%2Fhex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2266df51aa07eabd2f7745d410d3ddc4572ade21/src%2Flibextra%2Fhex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fhex.rs?ref=2266df51aa07eabd2f7745d410d3ddc4572ade21", "patch": "@@ -0,0 +1,238 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Hex binary-to-text encoding\n+use std::str;\n+use std::vec;\n+\n+/// A trait for converting a value to hexadecimal encoding\n+pub trait ToHex {\n+    /// Converts the value of `self` to a hex value, returning the owned\n+    /// string.\n+    fn to_hex(&self) -> ~str;\n+}\n+\n+static CHARS: [char, ..16] = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n+                              'a', 'b', 'c', 'd', 'e', 'f'];\n+\n+impl<'self> ToHex for &'self [u8] {\n+    /**\n+     * Turn a vector of `u8` bytes into a hexadecimal string.\n+     *\n+     * # Example\n+     *\n+     * ~~~ {.rust}\n+     * extern mod extra;\n+     * use extra::hex::ToHex;\n+     *\n+     * fn main () {\n+     *     let str = [52,32].to_hex();\n+     *     printfln!(\"%s\", str);\n+     * }\n+     * ~~~\n+     */\n+    fn to_hex(&self) -> ~str {\n+        let mut s = str::with_capacity(self.len() * 2);\n+        for &byte in self.iter() {\n+            s.push_char(CHARS[byte >> 4]);\n+            s.push_char(CHARS[byte & 0xf]);\n+        }\n+\n+        s\n+    }\n+}\n+\n+impl<'self> ToHex for &'self str {\n+    /**\n+     * Convert any string (literal, `@`, `&`, or `~`) to hexadecimal encoding.\n+     *\n+     *\n+     * # Example\n+     *\n+     * ~~~ {.rust}\n+         * extern mod extra;\n+     * use extra::ToHex;\n+     *\n+     * fn main () {\n+     *     let str = \"Hello, World\".to_hex();\n+     *     printfln!(\"%s\", str);\n+     * }\n+     * ~~~\n+     *\n+     */\n+    fn to_hex(&self) -> ~str {\n+        self.as_bytes().to_hex()\n+    }\n+}\n+\n+/// A trait for converting hexadecimal encoded values\n+pub trait FromHex {\n+    /// Converts the value of `self`, interpreted as base64 encoded data, into\n+    /// an owned vector of bytes, returning the vector.\n+    fn from_hex(&self) -> Result<~[u8], ~str>;\n+}\n+\n+impl<'self> FromHex for &'self [u8] {\n+    /**\n+     * Convert hexadecimal `u8` vector into u8 byte values.\n+     * Every 2 encoded characters is converted into 1 octet.\n+     *\n+     * # Example\n+     *\n+     * ~~~ {.rust}\n+     * extern mod extra;\n+     * use extra::hex::{ToHex, FromHex};\n+     *\n+     * fn main () {\n+     *     let str = [52,32].to_hex();\n+     *     printfln!(\"%s\", str);\n+     *     let bytes = str.from_hex().get();\n+     *     printfln!(\"%?\", bytes);\n+     * }\n+     * ~~~\n+     */\n+    fn from_hex(&self) -> Result<~[u8], ~str> {\n+        // This may be an overestimate if there is any whitespace\n+        let mut b = vec::with_capacity(self.len() / 2);\n+        let mut modulus = 0;\n+        let mut buf = 0u8;\n+\n+        for &byte in self.iter() {\n+            buf <<= 4;\n+\n+            match byte as char {\n+                'A'..'F' => buf |= byte - ('A' as u8) + 10,\n+                'a'..'f' => buf |= byte - ('a' as u8) + 10,\n+                '0'..'9' => buf |= byte - ('0' as u8),\n+                ' '|'\\r'|'\\n' => {\n+                    buf >>= 4;\n+                    loop\n+                }\n+                _ => return Err(~\"Invalid hex char\")\n+            }\n+\n+            modulus += 1;\n+            if modulus == 2 {\n+                modulus = 0;\n+                b.push(buf);\n+            }\n+        }\n+\n+        match modulus {\n+            0 => Ok(b),\n+            _ => Err(~\"Invalid input length\")\n+        }\n+    }\n+}\n+\n+impl<'self> FromHex for &'self str {\n+    /**\n+     * Convert any hexadecimal encoded string (literal, `@`, `&`, or `~`)\n+     * to the byte values it encodes.\n+     *\n+     * You can use the `from_bytes` function in `std::str`\n+     * to turn a `[u8]` into a string with characters corresponding to those\n+     * values.\n+     *\n+     * # Example\n+     *\n+     * This converts a string literal to hexadecimal and back.\n+     *\n+     * ~~~ {.rust}\n+     * extern mod extra;\n+     * use extra::hex::{FromHex, ToHex};\n+     * use std::str;\n+     *\n+     * fn main () {\n+     *     let hello_str = \"Hello, World\".to_hex();\n+     *     printfln!(\"%s\", hello_str);\n+     *     let bytes = hello_str.from_hex().get();\n+     *     printfln!(\"%?\", bytes);\n+     *     let result_str = str::from_bytes(bytes);\n+     *     printfln!(\"%s\", result_str);\n+     * }\n+     * ~~~\n+     */\n+    fn from_hex(&self) -> Result<~[u8], ~str> {\n+        self.as_bytes().from_hex()\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use test::BenchHarness;\n+    use hex::*;\n+\n+    #[test]\n+    pub fn test_to_hex() {\n+        assert_eq!(\"foobar\".to_hex(), ~\"666f6f626172\");\n+    }\n+\n+    #[test]\n+    pub fn test_from_hex_okay() {\n+        assert_eq!(\"666f6f626172\".from_hex().get(),\n+                   \"foobar\".as_bytes().to_owned());\n+        assert_eq!(\"666F6F626172\".from_hex().get(),\n+                   \"foobar\".as_bytes().to_owned());\n+    }\n+\n+    #[test]\n+    pub fn test_from_hex_odd_len() {\n+        assert!(\"666\".from_hex().is_err());\n+        assert!(\"66 6\".from_hex().is_err());\n+    }\n+\n+    #[test]\n+    pub fn test_from_hex_invalid_char() {\n+        assert!(\"66y6\".from_hex().is_err());\n+    }\n+\n+    #[test]\n+    pub fn test_from_hex_ignores_whitespace() {\n+        assert_eq!(\"666f 6f6\\r\\n26172 \".from_hex().get(),\n+                   \"foobar\".as_bytes().to_owned());\n+    }\n+\n+    #[test]\n+    pub fn test_to_hex_all_bytes() {\n+        for i in range(0, 256) {\n+            assert_eq!([i as u8].to_hex(), fmt!(\"%02x\", i as uint));\n+        }\n+    }\n+\n+    #[test]\n+    pub fn test_from_hex_all_bytes() {\n+        for i in range(0, 256) {\n+            assert_eq!(fmt!(\"%02x\", i as uint).from_hex().get(), ~[i as u8]);\n+            assert_eq!(fmt!(\"%02X\", i as uint).from_hex().get(), ~[i as u8]);\n+        }\n+    }\n+\n+    #[bench]\n+    pub fn bench_to_hex(bh: & mut BenchHarness) {\n+        let s = \"\u30a4\u30ed\u30cf\u30cb\u30db\u30d8\u30c8 \u30c1\u30ea\u30cc\u30eb\u30f2 \u30ef\u30ab\u30e8\u30bf\u30ec\u30bd \u30c4\u30cd\u30ca\u30e9\u30e0 \\\n+                 \u30a6\u30f0\u30ce\u30aa\u30af\u30e4\u30de \u30b1\u30d5\u30b3\u30a8\u30c6 \u30a2\u30b5\u30ad\u30e6\u30e1\u30df\u30b7 \u30f1\u30d2\u30e2\u30bb\u30b9\u30f3\";\n+        do bh.iter {\n+            s.to_hex();\n+        }\n+        bh.bytes = s.len() as u64;\n+    }\n+\n+    #[bench]\n+    pub fn bench_from_hex(bh: & mut BenchHarness) {\n+        let s = \"\u30a4\u30ed\u30cf\u30cb\u30db\u30d8\u30c8 \u30c1\u30ea\u30cc\u30eb\u30f2 \u30ef\u30ab\u30e8\u30bf\u30ec\u30bd \u30c4\u30cd\u30ca\u30e9\u30e0 \\\n+                 \u30a6\u30f0\u30ce\u30aa\u30af\u30e4\u30de \u30b1\u30d5\u30b3\u30a8\u30c6 \u30a2\u30b5\u30ad\u30e6\u30e1\u30df\u30b7 \u30f1\u30d2\u30e2\u30bb\u30b9\u30f3\";\n+        let b = s.to_hex();\n+        do bh.iter {\n+            b.from_hex();\n+        }\n+        bh.bytes = b.len() as u64;\n+    }\n+}"}]}