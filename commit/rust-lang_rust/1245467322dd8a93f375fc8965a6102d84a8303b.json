{"sha": "1245467322dd8a93f375fc8965a6102d84a8303b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEyNDU0NjczMjJkZDhhOTNmMzc1ZmM4OTY1YTYxMDJkODRhODMwM2I=", "commit": {"author": {"name": "Aaron Hill", "email": "aa1ronham@gmail.com", "date": "2019-08-18T05:20:24Z"}, "committer": {"name": "Aaron Hill", "email": "aa1ronham@gmail.com", "date": "2019-10-01T23:47:28Z"}, "message": "Improve HRTB error span when -Zno-leak-check is used\n\nAs described in #57374, NLL currently produces unhelpful higher-ranked\ntrait bound (HRTB) errors when '-Zno-leak-check' is enabled.\n\nThis PR tackles one half of this issue - making the error message point\nat the proper span. The error message itself is still the very generic\n\"higher-ranked subtype error\", but this can be improved in a follow-up\nPR.\n\nThe root cause of the bad spans lies in how NLL attempts to compute the\n'blamed' region, for which it will retrieve a span for.\nConsider the following code, which (correctly) does not compile:\n\n```rust\nlet my_val: u8 = 25;\nlet a: &u8 = &my_val;\nlet b = a;\nlet c = b;\nlet d: &'static u8 = c;\n```\n\nThis will cause NLL to generate the following subtype constraints:\n\nd :< c\nc :< b\nb <: a\n\nSince normal Rust lifetimes are covariant, this results in the following\nregion constraints (I'm using 'd to denote the lifetime of 'd',\n'c to denote the lifetime of 'c, etc.):\n\n'c: 'd\n'b: 'c\n'a: 'b\n\nFrom this, we can derive that 'a: 'd holds, which implies that 'a: 'static\nmust hold. However, this is not the case, since 'a refers to 'my_val',\nwhich does not outlive the current function.\n\nWhen NLL attempts to infer regions for this code, it will see that the\nregion 'a has grown 'too large' - it will be inferred to outlive\n'static, despite the fact that is not declared as outliving 'static\nWe can find the region responsible, 'd, by starting at the *end* of\nthe 'constraint chain' we generated above. This works because for normal\n(non-higher-ranked) lifetimes, we generally build up a 'chain' of\nlifetime constraints *away* from the original variable/lifetime.\nThat is, our original lifetime 'a is required to outlive progressively\nmore regions. If it ends up living for too long, we can look at the\n'end' of this chain to determine the 'most recent' usage that caused\nthe lifetime to grow too large.\n\nHowever, this logic does not work correctly when higher-ranked trait\nbounds (HRTBs) come into play. This is because HRTBs have\n*contravariance* with respect to their bound regions. For example,\nthis code snippet compiles:\n\n```rust\nlet a: for<'a> fn(&'a ()) = |_| {};\nlet b: fn(&'static ()) = a;\n```\n\nHere, we require that 'a' is a subtype of 'b'. Because of\ncontravariance, we end up with the region constraint 'static: 'a,\n*not* 'a: 'static\n\nThis means that our 'constraint chains' grow in the opposite direction\nof 'normal lifetime' constraint chains. As we introduce subtypes, our\nlifetime ends up being outlived by other lifetimes, rather than\noutliving other lifetimes. Therefore, starting at the end of the\n'constraint chain' will cause us to 'blame' a lifetime close to the original\ndefinition of a variable, instead of close to where the bad lifetime\nconstraint is introduced.\n\nThis PR improves how we select the region to blame for 'too large'\nuniversal lifetimes, when bound lifetimes are involved. If the region\nwe're checking is a 'placeholder' region (e.g. the region 'a' in\nfor<'a>, or the implicit region in fn(&())), we start traversing the\nconstraint chain from the beginning, rather than the end.\n\nThere are two (maybe more) different ways we generate region constraints for NLL:\nrequirements generated from trait queries, and requirements generated\nfrom MIR subtype constraints. While the former always use explicit\nplaceholder regions, the latter is more tricky. In order to implement\ncontravariance for HRTBs, TypeRelating replaces placeholder regions with\nexistential regions. This requires us to keep track of whether or not an\nexistential region was originally a placeholder region. When we look for\na region to blame, we check if our starting region is either a\nplaceholder region or is an existential region created from a\nplaceholder region. If so, we start iterating from the beginning of the\nconstraint chain, rather than the end.", "tree": {"sha": "fd10de88acb2ed8574305b9d46fded44b1d9051e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fd10de88acb2ed8574305b9d46fded44b1d9051e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1245467322dd8a93f375fc8965a6102d84a8303b", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE7J9Gc3TfBwj2K399tAh+UQ6YsWQFAl2T5ZAACgkQtAh+UQ6Y\nsWQ86hAArI9fiXNceJiAZOMGnG1A8GWYTnn6HTIFRvY+WZcZOyNDPrkqqRAKP0SV\nvuRaxR0Qt1tmCWmd8GWJqgP3YaN3Xrvsvww3BjmGFz0ydXJdNUbbfwrvMfA9unA/\nF+QlridSniPMg5bGrcb3NlmkiwKE+Y2O00F63srQToVT/mOf63JPxtdjnDq+GMOT\n5B6L0m3t1dhJ6RQx4t4xqVp/MxJT5U2hh0dft88ojN+9adGGlojqni0psKxq89Wo\nuvRS6NSHw4wjVvw9L4AXHjsXWGozLFinEFQ6+Od5vGLBHYH4lSCtEsB1S9pOtfeg\nHnxIHe6o62hcXdC6zZ5qYZSEAzrs8InhPAzGYFukPwNR7CsHeB8fIq7ZPtOOi609\nbNOMCGDXy6wCe+Me3jJ7ubpl0M4wp3aXt7MoV1sLkMmFFn7L+JeHxfa5Ww7AGY4z\n08h87P/w0s2GbqXJi3iJksNgRjLFxcW3ngmpyreewRoBp8AO3cd2/qu+J0fZ0zc7\n+W5QRBl75zm+xMkJwcQ/VvfRsiCn2Tqan9tau/wxlgI67S0hkUwpju6e4pnRTRmN\n2KwcpxZJ7I3JR6CGeUIeNc3rpYiKtwqCPonRUXpBKU4LoFVP+jeF91FFDWwXG3x3\namOCi79oSrJ75G32ytP/YapVNYIuX1P6QbIMq/N27yd+JLdHqRs=\n=UsVk\n-----END PGP SIGNATURE-----", "payload": "tree fd10de88acb2ed8574305b9d46fded44b1d9051e\nparent 702b45e409495a41afcccbe87a251a692b0cefab\nauthor Aaron Hill <aa1ronham@gmail.com> 1566105624 -0400\ncommitter Aaron Hill <aa1ronham@gmail.com> 1569973648 -0400\n\nImprove HRTB error span when -Zno-leak-check is used\n\nAs described in #57374, NLL currently produces unhelpful higher-ranked\ntrait bound (HRTB) errors when '-Zno-leak-check' is enabled.\n\nThis PR tackles one half of this issue - making the error message point\nat the proper span. The error message itself is still the very generic\n\"higher-ranked subtype error\", but this can be improved in a follow-up\nPR.\n\nThe root cause of the bad spans lies in how NLL attempts to compute the\n'blamed' region, for which it will retrieve a span for.\nConsider the following code, which (correctly) does not compile:\n\n```rust\nlet my_val: u8 = 25;\nlet a: &u8 = &my_val;\nlet b = a;\nlet c = b;\nlet d: &'static u8 = c;\n```\n\nThis will cause NLL to generate the following subtype constraints:\n\nd :< c\nc :< b\nb <: a\n\nSince normal Rust lifetimes are covariant, this results in the following\nregion constraints (I'm using 'd to denote the lifetime of 'd',\n'c to denote the lifetime of 'c, etc.):\n\n'c: 'd\n'b: 'c\n'a: 'b\n\nFrom this, we can derive that 'a: 'd holds, which implies that 'a: 'static\nmust hold. However, this is not the case, since 'a refers to 'my_val',\nwhich does not outlive the current function.\n\nWhen NLL attempts to infer regions for this code, it will see that the\nregion 'a has grown 'too large' - it will be inferred to outlive\n'static, despite the fact that is not declared as outliving 'static\nWe can find the region responsible, 'd, by starting at the *end* of\nthe 'constraint chain' we generated above. This works because for normal\n(non-higher-ranked) lifetimes, we generally build up a 'chain' of\nlifetime constraints *away* from the original variable/lifetime.\nThat is, our original lifetime 'a is required to outlive progressively\nmore regions. If it ends up living for too long, we can look at the\n'end' of this chain to determine the 'most recent' usage that caused\nthe lifetime to grow too large.\n\nHowever, this logic does not work correctly when higher-ranked trait\nbounds (HRTBs) come into play. This is because HRTBs have\n*contravariance* with respect to their bound regions. For example,\nthis code snippet compiles:\n\n```rust\nlet a: for<'a> fn(&'a ()) = |_| {};\nlet b: fn(&'static ()) = a;\n```\n\nHere, we require that 'a' is a subtype of 'b'. Because of\ncontravariance, we end up with the region constraint 'static: 'a,\n*not* 'a: 'static\n\nThis means that our 'constraint chains' grow in the opposite direction\nof 'normal lifetime' constraint chains. As we introduce subtypes, our\nlifetime ends up being outlived by other lifetimes, rather than\noutliving other lifetimes. Therefore, starting at the end of the\n'constraint chain' will cause us to 'blame' a lifetime close to the original\ndefinition of a variable, instead of close to where the bad lifetime\nconstraint is introduced.\n\nThis PR improves how we select the region to blame for 'too large'\nuniversal lifetimes, when bound lifetimes are involved. If the region\nwe're checking is a 'placeholder' region (e.g. the region 'a' in\nfor<'a>, or the implicit region in fn(&())), we start traversing the\nconstraint chain from the beginning, rather than the end.\n\nThere are two (maybe more) different ways we generate region constraints for NLL:\nrequirements generated from trait queries, and requirements generated\nfrom MIR subtype constraints. While the former always use explicit\nplaceholder regions, the latter is more tricky. In order to implement\ncontravariance for HRTBs, TypeRelating replaces placeholder regions with\nexistential regions. This requires us to keep track of whether or not an\nexistential region was originally a placeholder region. When we look for\na region to blame, we check if our starting region is either a\nplaceholder region or is an existential region created from a\nplaceholder region. If so, we start iterating from the beginning of the\nconstraint chain, rather than the end.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1245467322dd8a93f375fc8965a6102d84a8303b", "html_url": "https://github.com/rust-lang/rust/commit/1245467322dd8a93f375fc8965a6102d84a8303b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1245467322dd8a93f375fc8965a6102d84a8303b/comments", "author": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "702b45e409495a41afcccbe87a251a692b0cefab", "url": "https://api.github.com/repos/rust-lang/rust/commits/702b45e409495a41afcccbe87a251a692b0cefab", "html_url": "https://github.com/rust-lang/rust/commit/702b45e409495a41afcccbe87a251a692b0cefab"}], "stats": {"total": 142, "additions": 116, "deletions": 26}, "files": [{"sha": "99297d7222b07ea1e050ca51603dffe11c6d17af", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1245467322dd8a93f375fc8965a6102d84a8303b/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1245467322dd8a93f375fc8965a6102d84a8303b/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=1245467322dd8a93f375fc8965a6102d84a8303b", "patch": "@@ -418,15 +418,17 @@ pub enum NLLRegionVariableOrigin {\n     /// from a `for<'a> T` binder). Meant to represent \"any region\".\n     Placeholder(ty::PlaceholderRegion),\n \n-    Existential,\n+    Existential {\n+        was_placeholder: bool\n+    },\n }\n \n impl NLLRegionVariableOrigin {\n     pub fn is_universal(self) -> bool {\n         match self {\n             NLLRegionVariableOrigin::FreeRegion => true,\n             NLLRegionVariableOrigin::Placeholder(..) => true,\n-            NLLRegionVariableOrigin::Existential => false,\n+            NLLRegionVariableOrigin::Existential{ .. } => false,\n         }\n     }\n "}, {"sha": "4649f3f9567e78fb4e3eddcf48eadd3a33c2706f", "filename": "src/librustc/infer/nll_relate/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1245467322dd8a93f375fc8965a6102d84a8303b/src%2Flibrustc%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1245467322dd8a93f375fc8965a6102d84a8303b/src%2Flibrustc%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fnll_relate%2Fmod.rs?ref=1245467322dd8a93f375fc8965a6102d84a8303b", "patch": "@@ -93,7 +93,7 @@ pub trait TypeRelatingDelegate<'tcx> {\n     /// we will invoke this method to instantiate `'a` with an\n     /// inference variable (though `'b` would be instantiated first,\n     /// as a placeholder).\n-    fn next_existential_region_var(&mut self) -> ty::Region<'tcx>;\n+    fn next_existential_region_var(&mut self, was_placeholder: bool) -> ty::Region<'tcx>;\n \n     /// Creates a new region variable representing a\n     /// higher-ranked region that is instantiated universally.\n@@ -193,7 +193,7 @@ where\n                     let placeholder = ty::PlaceholderRegion { universe, name: br };\n                     delegate.next_placeholder_region(placeholder)\n                 } else {\n-                    delegate.next_existential_region_var()\n+                    delegate.next_existential_region_var(true)\n                 }\n             }\n         };"}, {"sha": "826be88e365728ef0718fd627d31a6051fc2e812", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/mod.rs", "status": "modified", "additions": 51, "deletions": 12, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/1245467322dd8a93f375fc8965a6102d84a8303b/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1245467322dd8a93f375fc8965a6102d84a8303b/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs?ref=1245467322dd8a93f375fc8965a6102d84a8303b", "patch": "@@ -98,9 +98,11 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         &self,\n         body: &Body<'tcx>,\n         from_region: RegionVid,\n+        from_region_origin: NLLRegionVariableOrigin,\n         target_test: impl Fn(RegionVid) -> bool,\n     ) -> (ConstraintCategory, bool, Span) {\n-        debug!(\"best_blame_constraint(from_region={:?})\", from_region);\n+        debug!(\"best_blame_constraint(from_region={:?}, from_region_origin={:?})\",\n+            from_region, from_region_origin);\n \n         // Find all paths\n         let (path, target_region) =\n@@ -153,19 +155,50 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         // we still want to screen for an \"interesting\" point to\n         // highlight (e.g., a call site or something).\n         let target_scc = self.constraint_sccs.scc(target_region);\n-        let best_choice = (0..path.len()).rev().find(|&i| {\n-            let constraint = path[i];\n+        let mut range = 0..path.len();\n+\n+        let should_reverse = match from_region_origin {\n+            NLLRegionVariableOrigin::FreeRegion\n+                | NLLRegionVariableOrigin::Existential { was_placeholder: false  } => {\n+                    true\n+            }\n+            NLLRegionVariableOrigin::Placeholder(_)\n+                | NLLRegionVariableOrigin::Existential { was_placeholder: true  } => {\n+                    false\n+            }\n+        };\n+\n+        let find_region = |i: &usize| {\n+            let constraint = path[*i];\n \n             let constraint_sup_scc = self.constraint_sccs.scc(constraint.sup);\n \n-            match categorized_path[i].0 {\n-                ConstraintCategory::OpaqueType | ConstraintCategory::Boring |\n-                ConstraintCategory::BoringNoLocation | ConstraintCategory::Internal => false,\n-                ConstraintCategory::TypeAnnotation | ConstraintCategory::Return |\n-                ConstraintCategory::Yield => true,\n-                _ => constraint_sup_scc != target_scc,\n+            if should_reverse {\n+                match categorized_path[*i].0 {\n+                    ConstraintCategory::OpaqueType | ConstraintCategory::Boring |\n+                    ConstraintCategory::BoringNoLocation | ConstraintCategory::Internal => false,\n+                    ConstraintCategory::TypeAnnotation | ConstraintCategory::Return |\n+                    ConstraintCategory::Yield => true,\n+                    _ => constraint_sup_scc != target_scc,\n+                }\n+            } else {\n+                match categorized_path[*i].0 {\n+                    ConstraintCategory::OpaqueType | ConstraintCategory::Boring |\n+                    ConstraintCategory::BoringNoLocation | ConstraintCategory::Internal => false,\n+                    _ => true\n+                }\n             }\n-        });\n+        };\n+\n+        let best_choice = if should_reverse {\n+            range.rev().find(find_region)\n+        } else {\n+            range.find(find_region)\n+        };\n+\n+        debug!(\"best_blame_constraint: best_choice={:?} should_reverse={}\",\n+            best_choice, should_reverse);\n+\n         if let Some(i) = best_choice {\n             if let Some(next) = categorized_path.get(i + 1) {\n                 if categorized_path[i].0 == ConstraintCategory::Return\n@@ -297,12 +330,13 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         infcx: &'a InferCtxt<'a, 'tcx>,\n         mir_def_id: DefId,\n         fr: RegionVid,\n+        fr_origin: NLLRegionVariableOrigin,\n         outlived_fr: RegionVid,\n         renctx: &mut RegionErrorNamingCtx,\n     ) -> DiagnosticBuilder<'a> {\n         debug!(\"report_error(fr={:?}, outlived_fr={:?})\", fr, outlived_fr);\n \n-        let (category, _, span) = self.best_blame_constraint(body, fr, |r| {\n+        let (category, _, span) = self.best_blame_constraint(body, fr, fr_origin, |r| {\n             self.provides_universal_region(r, fr, outlived_fr)\n         });\n \n@@ -709,6 +743,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         let (category, from_closure, span) = self.best_blame_constraint(\n             body,\n             borrow_region,\n+            NLLRegionVariableOrigin::FreeRegion,\n             |r| self.provides_universal_region(r, borrow_region, outlived_region)\n         );\n \n@@ -768,11 +803,13 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         &self,\n         body: &Body<'tcx>,\n         fr1: RegionVid,\n+        fr1_origin: NLLRegionVariableOrigin,\n         fr2: RegionVid,\n     ) -> (ConstraintCategory, Span) {\n         let (category, _, span) = self.best_blame_constraint(\n             body,\n             fr1,\n+            fr1_origin,\n             |r| self.provides_universal_region(r, fr1, fr2),\n         );\n         (category, span)\n@@ -825,7 +862,9 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 universe1.cannot_name(placeholder.universe)\n             }\n \n-            NLLRegionVariableOrigin::FreeRegion | NLLRegionVariableOrigin::Existential => false,\n+            NLLRegionVariableOrigin::FreeRegion | NLLRegionVariableOrigin::Existential { .. } => {\n+                false\n+            }\n         }\n     }\n }"}, {"sha": "164f7b0627c2da147324acee0775cb47cd771567", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1245467322dd8a93f375fc8965a6102d84a8303b/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1245467322dd8a93f375fc8965a6102d84a8303b/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=1245467322dd8a93f375fc8965a6102d84a8303b", "patch": "@@ -406,7 +406,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                     }\n                 }\n \n-                NLLRegionVariableOrigin::Existential => {\n+                NLLRegionVariableOrigin::Existential { .. } => {\n                     // For existential, regions, nothing to do.\n                 }\n             }\n@@ -1348,7 +1348,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                     self.check_bound_universal_region(infcx, body, mir_def_id, fr, placeholder);\n                 }\n \n-                NLLRegionVariableOrigin::Existential => {\n+                NLLRegionVariableOrigin::Existential { .. } => {\n                     // nothing to check here\n                 }\n             }\n@@ -1461,7 +1461,8 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 debug!(\"check_universal_region: fr_minus={:?}\", fr_minus);\n \n                 let blame_span_category =\n-                    self.find_outlives_blame_span(body, longer_fr, shorter_fr);\n+                    self.find_outlives_blame_span(body, longer_fr,\n+                                                  NLLRegionVariableOrigin::FreeRegion,shorter_fr);\n \n                 // Grow `shorter_fr` until we find some non-local regions. (We\n                 // always will.)  We'll call them `shorter_fr+` -- they're ever\n@@ -1494,6 +1495,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             infcx,\n             mir_def_id,\n             longer_fr,\n+            NLLRegionVariableOrigin::FreeRegion,\n             shorter_fr,\n             region_naming,\n         );\n@@ -1547,7 +1549,9 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         };\n \n         // Find the code to blame for the fact that `longer_fr` outlives `error_fr`.\n-        let (_, span) = self.find_outlives_blame_span(body, longer_fr, error_region);\n+        let (_, span) = self.find_outlives_blame_span(\n+            body, longer_fr, NLLRegionVariableOrigin::Placeholder(placeholder), error_region\n+        );\n \n         // Obviously, this error message is far from satisfactory.\n         // At present, though, it only appears in unit tests --\n@@ -1608,7 +1612,7 @@ impl<'tcx> RegionDefinition<'tcx> {\n \n         let origin = match rv_origin {\n             RegionVariableOrigin::NLL(origin) => origin,\n-            _ => NLLRegionVariableOrigin::Existential,\n+            _ => NLLRegionVariableOrigin::Existential { was_placeholder: false },\n         };\n \n         Self { origin, universe, external_name: None }"}, {"sha": "6e4db36bdce03c281baef1df76e5239c0b84a049", "filename": "src/librustc_mir/borrow_check/nll/renumber.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1245467322dd8a93f375fc8965a6102d84a8303b/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Frenumber.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1245467322dd8a93f375fc8965a6102d84a8303b/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Frenumber.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Frenumber.rs?ref=1245467322dd8a93f375fc8965a6102d84a8303b", "patch": "@@ -35,7 +35,7 @@ where\n     infcx\n         .tcx\n         .fold_regions(value, &mut false, |_region, _depth| {\n-            let origin = NLLRegionVariableOrigin::Existential;\n+            let origin = NLLRegionVariableOrigin::Existential { was_placeholder: false };\n             infcx.next_nll_region_var(origin)\n         })\n }"}, {"sha": "919fcdbd39ba066d8aad9ff7617b0d7d837b3c88", "filename": "src/librustc_mir/borrow_check/nll/type_check/relate_tys.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1245467322dd8a93f375fc8965a6102d84a8303b/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Frelate_tys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1245467322dd8a93f375fc8965a6102d84a8303b/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Frelate_tys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Frelate_tys.rs?ref=1245467322dd8a93f375fc8965a6102d84a8303b", "patch": "@@ -66,9 +66,9 @@ impl TypeRelatingDelegate<'tcx> for NllTypeRelatingDelegate<'_, '_, 'tcx> {\n         self.infcx.create_next_universe()\n     }\n \n-    fn next_existential_region_var(&mut self) -> ty::Region<'tcx> {\n+    fn next_existential_region_var(&mut self, was_placeholder: bool) -> ty::Region<'tcx> {\n         if let Some(_) = &mut self.borrowck_context {\n-            let origin = NLLRegionVariableOrigin::Existential;\n+            let origin = NLLRegionVariableOrigin::Existential { was_placeholder };\n             self.infcx.next_nll_region_var(origin)\n         } else {\n             self.infcx.tcx.lifetimes.re_erased\n@@ -88,7 +88,9 @@ impl TypeRelatingDelegate<'tcx> for NllTypeRelatingDelegate<'_, '_, 'tcx> {\n \n     fn generalize_existential(&mut self, universe: ty::UniverseIndex) -> ty::Region<'tcx> {\n         self.infcx\n-            .next_nll_region_var_in_universe(NLLRegionVariableOrigin::Existential, universe)\n+            .next_nll_region_var_in_universe(NLLRegionVariableOrigin::Existential {\n+                was_placeholder: false\n+            }, universe)\n     }\n \n     fn push_outlives(&mut self, sup: ty::Region<'tcx>, sub: ty::Region<'tcx>) {"}, {"sha": "5959c2ea5ca147b90f30bda166af2fdb529510e8", "filename": "src/librustc_traits/chalk_context/unify.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1245467322dd8a93f375fc8965a6102d84a8303b/src%2Flibrustc_traits%2Fchalk_context%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1245467322dd8a93f375fc8965a6102d84a8303b/src%2Flibrustc_traits%2Fchalk_context%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Fchalk_context%2Funify.rs?ref=1245467322dd8a93f375fc8965a6102d84a8303b", "patch": "@@ -65,7 +65,7 @@ impl TypeRelatingDelegate<'tcx> for &mut ChalkTypeRelatingDelegate<'_, 'tcx> {\n         self.infcx.create_next_universe()\n     }\n \n-    fn next_existential_region_var(&mut self) -> ty::Region<'tcx> {\n+    fn next_existential_region_var(&mut self, _was_placeholder: bool) -> ty::Region<'tcx> {\n         self.infcx.next_region_var(RegionVariableOrigin::MiscVariable(DUMMY_SP))\n     }\n "}, {"sha": "1bbef995fe8859b72275483c9759569a63cb1ee2", "filename": "src/test/ui/hrtb/issue-30786.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1245467322dd8a93f375fc8965a6102d84a8303b/src%2Ftest%2Fui%2Fhrtb%2Fissue-30786.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1245467322dd8a93f375fc8965a6102d84a8303b/src%2Ftest%2Fui%2Fhrtb%2Fissue-30786.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhrtb%2Fissue-30786.rs?ref=1245467322dd8a93f375fc8965a6102d84a8303b", "patch": "@@ -114,4 +114,5 @@ fn main() {\n     //[nll]~^ ERROR higher-ranked subtype error\n     let count = filter.count(); // Assert that we still have a valid stream.\n     //[nll]~^ ERROR higher-ranked subtype error\n+\n }"}, {"sha": "ac00627ad00ebfb941165f8fc6bb78ae3d8ce29b", "filename": "src/test/ui/nll/relate_tys/fn-subtype.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1245467322dd8a93f375fc8965a6102d84a8303b/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Ffn-subtype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1245467322dd8a93f375fc8965a6102d84a8303b/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Ffn-subtype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Ffn-subtype.rs?ref=1245467322dd8a93f375fc8965a6102d84a8303b", "patch": "@@ -0,0 +1,10 @@\n+// Test that NLL produces correct spans for higher-ranked subtyping errors.\n+//\n+// compile-flags:-Zno-leak-check\n+\n+#![feature(nll)]\n+\n+fn main() {\n+    let x: fn(&'static ()) = |_| {};\n+    let y: for<'a> fn(&'a ()) = x; //~ ERROR higher-ranked subtype error\n+}"}, {"sha": "b089b5aaa25354595a30cbc0a657999ba16f96f3", "filename": "src/test/ui/nll/relate_tys/fn-subtype.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1245467322dd8a93f375fc8965a6102d84a8303b/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Ffn-subtype.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1245467322dd8a93f375fc8965a6102d84a8303b/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Ffn-subtype.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Ffn-subtype.stderr?ref=1245467322dd8a93f375fc8965a6102d84a8303b", "patch": "@@ -0,0 +1,8 @@\n+error: higher-ranked subtype error\n+  --> $DIR/fn-subtype.rs:9:33\n+   |\n+LL |     let y: for<'a> fn(&'a ()) = x;\n+   |                                 ^\n+\n+error: aborting due to previous error\n+"}, {"sha": "80f31ca6b4782d86baff8223ee9beac9e84bb4cb", "filename": "src/test/ui/nll/relate_tys/trait-hrtb.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1245467322dd8a93f375fc8965a6102d84a8303b/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Ftrait-hrtb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1245467322dd8a93f375fc8965a6102d84a8303b/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Ftrait-hrtb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Ftrait-hrtb.rs?ref=1245467322dd8a93f375fc8965a6102d84a8303b", "patch": "@@ -0,0 +1,16 @@\n+// Test that NLL generates proper error spans for trait HRTB errors\n+//\n+// compile-flags:-Zno-leak-check\n+\n+#![feature(nll)]\n+\n+trait Foo<'a> {}\n+\n+fn make_foo<'a>() -> Box<dyn Foo<'a>> {\n+    panic!()\n+}\n+\n+fn main() {\n+    let x: Box<dyn Foo<'static>> = make_foo();\n+    let y: Box<dyn for<'a> Foo<'a>> = x; //~ ERROR higher-ranked subtype error\n+}"}, {"sha": "4df2f352522a3e3078a283bf3b0e83ebb233d9ac", "filename": "src/test/ui/nll/relate_tys/trait-hrtb.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1245467322dd8a93f375fc8965a6102d84a8303b/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Ftrait-hrtb.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1245467322dd8a93f375fc8965a6102d84a8303b/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Ftrait-hrtb.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Frelate_tys%2Ftrait-hrtb.stderr?ref=1245467322dd8a93f375fc8965a6102d84a8303b", "patch": "@@ -0,0 +1,8 @@\n+error: higher-ranked subtype error\n+  --> $DIR/trait-hrtb.rs:15:39\n+   |\n+LL |     let y: Box<dyn for<'a> Foo<'a>> = x;\n+   |                                       ^\n+\n+error: aborting due to previous error\n+"}]}