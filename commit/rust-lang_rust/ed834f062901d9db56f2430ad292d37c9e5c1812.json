{"sha": "ed834f062901d9db56f2430ad292d37c9e5c1812", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVkODM0ZjA2MjkwMWQ5ZGI1NmYyNDMwYWQyOTJkMzdjOWU1YzE4MTI=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-06-30T01:09:56Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-06-30T23:01:52Z"}, "message": "syntax: Add support for new lambda syntax", "tree": {"sha": "9537c13611f662f344fcbbea9197614d69175dca", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9537c13611f662f344fcbbea9197614d69175dca"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ed834f062901d9db56f2430ad292d37c9e5c1812", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ed834f062901d9db56f2430ad292d37c9e5c1812", "html_url": "https://github.com/rust-lang/rust/commit/ed834f062901d9db56f2430ad292d37c9e5c1812", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ed834f062901d9db56f2430ad292d37c9e5c1812/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0293a31b689ff71cbe39112e226d151529f5a1cd", "url": "https://api.github.com/repos/rust-lang/rust/commits/0293a31b689ff71cbe39112e226d151529f5a1cd", "html_url": "https://github.com/rust-lang/rust/commit/0293a31b689ff71cbe39112e226d151529f5a1cd"}], "stats": {"total": 91, "additions": 81, "deletions": 10}, "files": [{"sha": "55058d337e9af79cc338071726117ec4d094aa1e", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 61, "deletions": 9, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/ed834f062901d9db56f2430ad292d37c9e5c1812/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed834f062901d9db56f2430ad292d37c9e5c1812/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=ed834f062901d9db56f2430ad292d37c9e5c1812", "patch": "@@ -30,6 +30,7 @@ enum restriction {\n     RESTRICT_STMT_EXPR,\n     RESTRICT_NO_CALL_EXPRS,\n     RESTRICT_NO_BAR_OP,\n+    RESTRICT_NO_BAR_OR_DOUBLEBAR_OP,\n }\n \n enum file_type { CRATE_FILE, SOURCE_FILE, }\n@@ -776,11 +777,13 @@ class parser {\n                 self.expect(token::RBRACE);\n                 ex = expr_rec(fields, base);\n             } else if token::is_bar(self.token) {\n-                ret pexpr(self.parse_fn_block_expr());\n+                ret pexpr(self.parse_fn_block_expr_old());\n             } else {\n                 let blk = self.parse_block_tail(lo, default_blk);\n                 ret self.mk_pexpr(blk.span.lo, blk.span.hi, expr_block(blk));\n             }\n+        } else if token::is_bar(self.token) {\n+            ret pexpr(self.parse_lambda_expr());\n         } else if self.eat_keyword(\"new\") {\n             self.expect(token::LPAREN);\n             let r = self.parse_expr();\n@@ -1234,7 +1237,14 @@ class parser {\n         if self.expr_is_complete(plhs) { ret lhs; }\n         let peeked = self.token;\n         if peeked == token::BINOP(token::OR) &&\n-            self.restriction == RESTRICT_NO_BAR_OP { ret lhs; }\n+            (self.restriction == RESTRICT_NO_BAR_OP ||\n+             self.restriction == RESTRICT_NO_BAR_OR_DOUBLEBAR_OP) {\n+            ret lhs;\n+        }\n+        if peeked == token::OROR &&\n+            self.restriction == RESTRICT_NO_BAR_OR_DOUBLEBAR_OP {\n+            ret lhs;\n+        }\n         let cur_opt   = token_to_binop(peeked);\n         alt cur_opt {\n           some(cur_op) {\n@@ -1347,14 +1357,46 @@ class parser {\n                          expr_fn(proto, decl, body, capture_clause));\n     }\n \n-    fn parse_fn_block_expr() -> @expr {\n+    fn parse_fn_block_expr_old() -> @expr {\n         let lo = self.last_span.lo;\n         let (decl, captures) = self.parse_fn_block_decl();\n         let body = self.parse_block_tail(lo, default_blk);\n         ret self.mk_expr(lo, body.span.hi,\n                          expr_fn_block(decl, body, captures));\n     }\n \n+    // `|args| { ... }` like in `do` expressions\n+    fn parse_lambda_block_expr() -> @expr {\n+        self.parse_lambda_expr_({||\n+            let blk = self.parse_block();\n+            self.mk_expr(blk.span.lo, blk.span.hi, expr_block(blk))\n+        })\n+    }\n+\n+    // `|args| expr`\n+    fn parse_lambda_expr() -> @expr {\n+        self.parse_lambda_expr_({|| self.parse_expr()})\n+    }\n+\n+    fn parse_lambda_expr_(parse_body: fn&() -> @expr) -> @expr {\n+        if self.token == token::LBRACE {\n+            // Old style lambdas `{|args| ... }`\n+            self.expect(token::LBRACE);\n+            ret self.parse_fn_block_expr_old();\n+        } else {\n+            let lo = self.last_span.lo;\n+            // New style lambdas `|args| expr`\n+            let (decl, captures) = self.parse_fn_block_decl();\n+            let body = parse_body();\n+            let fakeblock = {view_items: ~[], stmts: ~[], expr: some(body),\n+                             id: self.get_id(), rules: default_blk};\n+            let fakeblock = spanned(body.span.lo, body.span.hi,\n+                                    fakeblock);\n+            ret self.mk_expr(lo, body.span.hi,\n+                             expr_fn_block(decl, fakeblock, captures));\n+        }\n+    }\n+\n     fn parse_else_expr() -> @expr {\n         if self.eat_keyword(\"if\") {\n             ret self.parse_if_expr();\n@@ -1367,27 +1409,37 @@ class parser {\n     fn parse_sugary_call_expr(keyword: str,\n                               ctor: fn(+@expr) -> expr_) -> @expr {\n         let lo = self.last_span;\n-        let e = self.parse_expr_res(RESTRICT_STMT_EXPR);\n+        // Parse the callee `foo` in\n+        //    for foo || {\n+        //    for foo.bar || {\n+        // etc, or the portion of the call expression before the lambda in\n+        //    for foo() || {\n+        // or\n+        //    for foo.bar(a) || {\n+        // Turn on the restriction to stop at | or || so we can parse\n+        // them as the lambda arguments\n+        let e = self.parse_expr_res(RESTRICT_NO_BAR_OR_DOUBLEBAR_OP);\n         alt e.node {\n           expr_call(f, args, false) {\n-            self.expect(token::LBRACE);\n-            let block = self.parse_fn_block_expr();\n+            let block = self.parse_lambda_block_expr();\n             let last_arg = self.mk_expr(block.span.lo, block.span.hi,\n                                     ctor(block));\n             let args = vec::append(args, ~[last_arg]);\n             @{node: expr_call(f, args, true)\n               with *e}\n           }\n           expr_path(*) | expr_field(*) | expr_call(*) {\n-            self.expect(token::LBRACE);\n-            let block = self.parse_fn_block_expr();\n+            let block = self.parse_lambda_block_expr();\n             let last_arg = self.mk_expr(block.span.lo, block.span.hi,\n                                     ctor(block));\n             self.mk_expr(lo.lo, last_arg.span.hi,\n                          expr_call(e, ~[last_arg], true))\n           }\n           _ {\n-            self.warn(#fmt(\"unexpected sugary call %?\", e.node));\n+            // There may be other types of expressions that can\n+            // represent the callee in `for` and `do` expressions\n+            // but they aren't represented by tests\n+            #debug(\"sugary call on %?\", e.node);\n             self.span_fatal(\n                 lo, #fmt(\"`%s` must be followed by a block call\", keyword));\n           }"}, {"sha": "25f10e5e8b9d98a88a06f5c77493fdf4863b735d", "filename": "src/test/compile-fail/do-lambda-requires-braces.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ed834f062901d9db56f2430ad292d37c9e5c1812/src%2Ftest%2Fcompile-fail%2Fdo-lambda-requires-braces.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed834f062901d9db56f2430ad292d37c9e5c1812/src%2Ftest%2Fcompile-fail%2Fdo-lambda-requires-braces.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdo-lambda-requires-braces.rs?ref=ed834f062901d9db56f2430ad292d37c9e5c1812", "patch": "@@ -0,0 +1,5 @@\n+fn main() {\n+    do something\n+        |x| do somethingelse //! ERROR: expecting '{' but found 'do'\n+        |y| say(x, y)\n+}"}, {"sha": "85997046b4e287e3a4eed47cb30fe57c564edd75", "filename": "src/test/compile-fail/do1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ed834f062901d9db56f2430ad292d37c9e5c1812/src%2Ftest%2Fcompile-fail%2Fdo1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed834f062901d9db56f2430ad292d37c9e5c1812/src%2Ftest%2Fcompile-fail%2Fdo1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdo1.rs?ref=ed834f062901d9db56f2430ad292d37c9e5c1812", "patch": "@@ -1,3 +1,3 @@\n fn main() {\n-    let x = do y; //! ERROR: expecting '{' but found\n+    let x = do y; //! ERROR: expecting '|' but found\n }"}, {"sha": "c3cc6792cdc0a896db0076352d56727a1a65b98c", "filename": "src/test/run-pass/newlambdas.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ed834f062901d9db56f2430ad292d37c9e5c1812/src%2Ftest%2Frun-pass%2Fnewlambdas.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed834f062901d9db56f2430ad292d37c9e5c1812/src%2Ftest%2Frun-pass%2Fnewlambdas.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnewlambdas.rs?ref=ed834f062901d9db56f2430ad292d37c9e5c1812", "patch": "@@ -0,0 +1,14 @@\n+// Tests for the new |args| expr lambda syntax\n+\n+fn f(i: int, f: fn(int) -> int) -> int { f(i) }\n+\n+fn g(g: fn()) { }\n+\n+fn main() {\n+    assert f(10, |a| a) == 10;\n+    g(||());\n+    assert do f(10) |a| { a } == 10;\n+    do g() || { }\n+    let _x: fn@() -> int = || 10;\n+    let _y: fn@(int) -> int = |a| a;\n+}"}]}