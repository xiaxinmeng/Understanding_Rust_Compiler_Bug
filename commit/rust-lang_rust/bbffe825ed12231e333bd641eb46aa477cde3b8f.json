{"sha": "bbffe825ed12231e333bd641eb46aa477cde3b8f", "node_id": "C_kwDOAAsO6NoAKGJiZmZlODI1ZWQxMjIzMWUzMzNiZDY0MWViNDZhYTQ3N2NkZTNiOGY", "commit": {"author": {"name": "togami2864", "email": "tuabobo123@gmail.com", "date": "2021-11-15T17:06:31Z"}, "committer": {"name": "togami2864", "email": "tuabobo123@gmail.com", "date": "2021-11-15T17:06:31Z"}, "message": "add reduce_unit_expression", "tree": {"sha": "fb2405976274f9aa9ad34e75a0f4f5127e7e65f4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fb2405976274f9aa9ad34e75a0f4f5127e7e65f4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bbffe825ed12231e333bd641eb46aa477cde3b8f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bbffe825ed12231e333bd641eb46aa477cde3b8f", "html_url": "https://github.com/rust-lang/rust/commit/bbffe825ed12231e333bd641eb46aa477cde3b8f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bbffe825ed12231e333bd641eb46aa477cde3b8f/comments", "author": {"login": "togami2864", "id": 62130798, "node_id": "MDQ6VXNlcjYyMTMwNzk4", "avatar_url": "https://avatars.githubusercontent.com/u/62130798?v=4", "gravatar_id": "", "url": "https://api.github.com/users/togami2864", "html_url": "https://github.com/togami2864", "followers_url": "https://api.github.com/users/togami2864/followers", "following_url": "https://api.github.com/users/togami2864/following{/other_user}", "gists_url": "https://api.github.com/users/togami2864/gists{/gist_id}", "starred_url": "https://api.github.com/users/togami2864/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/togami2864/subscriptions", "organizations_url": "https://api.github.com/users/togami2864/orgs", "repos_url": "https://api.github.com/users/togami2864/repos", "events_url": "https://api.github.com/users/togami2864/events{/privacy}", "received_events_url": "https://api.github.com/users/togami2864/received_events", "type": "User", "site_admin": false}, "committer": {"login": "togami2864", "id": 62130798, "node_id": "MDQ6VXNlcjYyMTMwNzk4", "avatar_url": "https://avatars.githubusercontent.com/u/62130798?v=4", "gravatar_id": "", "url": "https://api.github.com/users/togami2864", "html_url": "https://github.com/togami2864", "followers_url": "https://api.github.com/users/togami2864/followers", "following_url": "https://api.github.com/users/togami2864/following{/other_user}", "gists_url": "https://api.github.com/users/togami2864/gists{/gist_id}", "starred_url": "https://api.github.com/users/togami2864/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/togami2864/subscriptions", "organizations_url": "https://api.github.com/users/togami2864/orgs", "repos_url": "https://api.github.com/users/togami2864/repos", "events_url": "https://api.github.com/users/togami2864/events{/privacy}", "received_events_url": "https://api.github.com/users/togami2864/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4f71ff3f847e7da299be5cc3ba00ebfda5899166", "url": "https://api.github.com/repos/rust-lang/rust/commits/4f71ff3f847e7da299be5cc3ba00ebfda5899166", "html_url": "https://github.com/rust-lang/rust/commit/4f71ff3f847e7da299be5cc3ba00ebfda5899166"}], "stats": {"total": 154, "additions": 96, "deletions": 58}, "files": [{"sha": "00a4dda9701d9e465c9db0afec00bcf5f14b9e24", "filename": "clippy_lints/src/methods/option_map_or_none.rs", "status": "modified", "additions": 89, "deletions": 49, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/bbffe825ed12231e333bd641eb46aa477cde3b8f/clippy_lints%2Fsrc%2Fmethods%2Foption_map_or_none.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbffe825ed12231e333bd641eb46aa477cde3b8f/clippy_lints%2Fsrc%2Fmethods%2Foption_map_or_none.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Foption_map_or_none.rs?ref=bbffe825ed12231e333bd641eb46aa477cde3b8f", "patch": "@@ -1,7 +1,7 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::is_lang_ctor;\n use clippy_utils::source::snippet;\n use clippy_utils::ty::is_type_diagnostic_item;\n+use clippy_utils::{is_lang_ctor, single_segment_path};\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_hir::LangItem::{OptionNone, OptionSome};\n@@ -11,6 +11,26 @@ use rustc_span::symbol::sym;\n use super::OPTION_MAP_OR_NONE;\n use super::RESULT_MAP_OR_INTO_OPTION;\n \n+fn reduce_unit_expression<'a>(\n+    cx: &LateContext<'_>,\n+    expr: &'a hir::Expr<'_>,\n+) -> Option<(&'a hir::Expr<'a>, &'a [hir::Expr<'a>])> {\n+    match expr.kind {\n+        hir::ExprKind::Call(func, arg_char) => Some((func, arg_char)),\n+        hir::ExprKind::Block(block, _) => {\n+            match block.expr {\n+                Some(inner_expr) => {\n+                    // If block only contains an expression,\n+                    // reduce `{ X }` to `X`\n+                    reduce_unit_expression(cx, inner_expr)\n+                },\n+                _ => None,\n+            }\n+        },\n+        _ => None,\n+    }\n+}\n+\n /// lint use of `_.map_or(None, _)` for `Option`s and `Result`s\n pub(super) fn check<'tcx>(\n     cx: &LateContext<'tcx>,\n@@ -31,58 +51,78 @@ pub(super) fn check<'tcx>(\n         return;\n     }\n \n-    let (lint_name, msg, instead, hint) = {\n-        let default_arg_is_none = if let hir::ExprKind::Path(ref qpath) = def_arg.kind {\n-            is_lang_ctor(cx, qpath, OptionNone)\n-        } else {\n-            return;\n-        };\n+    // let (lint_name, msg, instead, hint) = {\n+    let default_arg_is_none = if let hir::ExprKind::Path(ref qpath) = def_arg.kind {\n+        is_lang_ctor(cx, qpath, OptionNone)\n+    } else {\n+        return;\n+    };\n \n-        if !default_arg_is_none {\n-            // nothing to lint!\n-            return;\n-        }\n+    if !default_arg_is_none {\n+        // nothing to lint!\n+        return;\n+    }\n \n-        let f_arg_is_some = if let hir::ExprKind::Path(ref qpath) = map_arg.kind {\n-            is_lang_ctor(cx, qpath, OptionSome)\n-        } else {\n-            false\n-        };\n+    let f_arg_is_some = if let hir::ExprKind::Path(ref qpath) = map_arg.kind {\n+        is_lang_ctor(cx, qpath, OptionSome)\n+    } else {\n+        false\n+    };\n \n-        if is_option {\n-            let self_snippet = snippet(cx, recv.span, \"..\");\n-            let func_snippet = snippet(cx, map_arg.span, \"..\");\n-            let msg = \"called `map_or(None, ..)` on an `Option` value. This can be done more directly by calling \\\n+    if is_option {\n+        let self_snippet = snippet(cx, recv.span, \"..\");\n+        if let hir::ExprKind::Closure(_, _, id, _, _) = map_arg.kind {\n+            if_chain! {\n+                let body = cx.tcx.hir().body(id);\n+                if let Some((func, arg_char)) = reduce_unit_expression(cx, &body.value);\n+                if arg_char.len() == 1;\n+                if let hir::ExprKind::Path(ref qpath) = func.kind;\n+                if let Some(segment) = single_segment_path(qpath);\n+                if segment.ident.name == sym::Some;\n+                then {\n+                    let func_snippet = snippet(cx, arg_char[0].span, \"..\");\n+                    let msg = \"called `map_or(None, ..)` on an `Option` value. This can be done more directly by calling \\\n                        `map(..)` instead\";\n-            (\n-                OPTION_MAP_OR_NONE,\n-                msg,\n-                \"try using `map` instead\",\n-                format!(\"{0}.map({1})\", self_snippet, func_snippet),\n-            )\n-        } else if f_arg_is_some {\n-            let msg = \"called `map_or(None, Some)` on a `Result` value. This can be done more directly by calling \\\n-                       `ok()` instead\";\n-            let self_snippet = snippet(cx, recv.span, \"..\");\n-            (\n-                RESULT_MAP_OR_INTO_OPTION,\n-                msg,\n-                \"try using `ok` instead\",\n-                format!(\"{0}.ok()\", self_snippet),\n-            )\n-        } else {\n-            // nothing to lint!\n-            return;\n+                    return span_lint_and_sugg(\n+                        cx,\n+                        OPTION_MAP_OR_NONE,\n+                        expr.span,\n+                        msg,\n+                        \"try using `map` instead\",\n+                        format!(\"{0}.map({1})\", self_snippet, func_snippet),\n+                        Applicability::MachineApplicable,\n+                    );\n+                }\n+            }\n         }\n-    };\n \n-    span_lint_and_sugg(\n-        cx,\n-        lint_name,\n-        expr.span,\n-        msg,\n-        instead,\n-        hint,\n-        Applicability::MachineApplicable,\n-    );\n+        let func_snippet = snippet(cx, map_arg.span, \"..\");\n+        let msg = \"called `map_or(None, ..)` on an `Option` value. This can be done more directly by calling \\\n+                       `and_then(..)` instead\";\n+        span_lint_and_sugg(\n+            cx,\n+            OPTION_MAP_OR_NONE,\n+            expr.span,\n+            msg,\n+            \"try using `and_then` instead\",\n+            format!(\"{0}.and_then({1})\", self_snippet, func_snippet),\n+            Applicability::MachineApplicable,\n+        )\n+    } else if f_arg_is_some {\n+        let msg = \"called `map_or(None, Some)` on a `Result` value. This can be done more directly by calling \\\n+                       `ok()` instead\";\n+        let self_snippet = snippet(cx, recv.span, \"..\");\n+        span_lint_and_sugg(\n+            cx,\n+            RESULT_MAP_OR_INTO_OPTION,\n+            expr.span,\n+            msg,\n+            \"try using `ok` instead\",\n+            format!(\"{0}.ok()\", self_snippet),\n+            Applicability::MachineApplicable,\n+        )\n+    } else {\n+        // nothing to lint!\n+        return;\n+    }\n }"}, {"sha": "9333cb89c9a0ca63d07b4742d9c1b28d7624d9c0", "filename": "tests/ui/option_map_or_none.fixed", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bbffe825ed12231e333bd641eb46aa477cde3b8f/tests%2Fui%2Foption_map_or_none.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/bbffe825ed12231e333bd641eb46aa477cde3b8f/tests%2Fui%2Foption_map_or_none.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Foption_map_or_none.fixed?ref=bbffe825ed12231e333bd641eb46aa477cde3b8f", "patch": "@@ -5,17 +5,15 @@\n fn main() {\n     let opt = Some(1);\n     let bar = |_| {\n-       Some(1)\n+        Some(1)\n     };\n \n     // Check `OPTION_MAP_OR_NONE`.\n     // Single line case.\n     let _ :Option<i32> = opt.map(|x| x + 1);\n     // Multi-line case.\n     #[rustfmt::skip]\n-    let _ :Option<i32> = opt.map(|x| {\n-                        x + 1\n-                       });\n+    let _ :Option<i32> = opt.map(|x| x + 1);\n     // function returning `Option`\n     let _ :Option<i32> = opt.and_then(bar);\n }"}, {"sha": "3d75f2776f6deca2265dd730437aedd60a593c1a", "filename": "tests/ui/option_map_or_none.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bbffe825ed12231e333bd641eb46aa477cde3b8f/tests%2Fui%2Foption_map_or_none.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bbffe825ed12231e333bd641eb46aa477cde3b8f/tests%2Fui%2Foption_map_or_none.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Foption_map_or_none.stderr?ref=bbffe825ed12231e333bd641eb46aa477cde3b8f", "patch": "@@ -1,16 +1,16 @@\n error: called `map_or(None, ..)` on an `Option` value. This can be done more directly by calling `map(..)` instead\n-  --> $DIR/option_map_or_none.rs:10:13\n+  --> $DIR/option_map_or_none.rs:13:26\n    |\n LL |     let _ :Option<i32> = opt.map_or(None, |x| Some(x + 1));\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try using `map` instead: `opt.map(|x| x + 1)`\n+   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try using `map` instead: `opt.map(|x| x + 1)`\n    |\n    = note: `-D clippy::option-map-or-none` implied by `-D warnings`\n \n error: called `map_or(None, ..)` on an `Option` value. This can be done more directly by calling `map(..)` instead\n-  --> $DIR/option_map_or_none.rs:13:13\n+  --> $DIR/option_map_or_none.rs:16:26\n    |\n LL |       let _ :Option<i32> = opt.map_or(None, |x| {\n-   |  _____________^\n+   |  __________________________^\n LL | |                         Some(x + 1)\n LL | |                        });\n    | |_________________________^\n@@ -22,7 +22,7 @@ LL +                         x + 1\n LL ~                        });\n    |\n \n-error: called `map_or(None, ..)` on an `Option` value. This can be done more directly by calling `map(..)` instead\n+error: called `map_or(None, ..)` on an `Option` value. This can be done more directly by calling `and_then(..)` instead\n   --> $DIR/option_map_or_none.rs:20:26\n    |\n LL |     let _ :Option<i32> = opt.map_or(None, bar);"}]}