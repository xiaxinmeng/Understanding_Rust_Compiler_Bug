{"sha": "de2edb226b213c414546b4e739356f0524b871f6", "node_id": "C_kwDOAAsO6NoAKGRlMmVkYjIyNmIyMTNjNDE0NTQ2YjRlNzM5MzU2ZjA1MjRiODcxZjY", "commit": {"author": {"name": "Maybe Waffle", "email": "waffle.lapkin@gmail.com", "date": "2022-04-12T07:29:23Z"}, "committer": {"name": "Maybe Waffle", "email": "waffle.lapkin@gmail.com", "date": "2022-04-12T07:29:23Z"}, "message": "Fix wrong suggestions for `T:`\n\nThis commit fixes a corner case in `suggest_constraining_type_params`\nthat was causing incorrect suggestions.\n\nFor the following functions:\n```rust\nfn a<T:>(t: T) { [t, t]; }\nfn b<T>(t: T) where T: { [t, t]; }\n```\nWe previously suggested the following:\n```text\n...\nhelp: consider restricting type parameter `T`\n  |\n1 | fn a<T: Copy:>(t: T) { [t, t]; }\n  |       ++++++\n...\nhelp: consider further restricting this bound\n  |\n2 | fn b<T>(t: T) where T: + Copy { [t, t]; }\n  |                        ++++++\n```\nNote that neither `T: Copy:` not `where T: + Copy` is a correct bound.\n\nWith this commit the suggestions are correct:\n```text\n...\nhelp: consider restricting type parameter `T`\n  |\n1 | fn a<T: Copy>(t: T) { [t, t]; }\n  |         ++++\n...\nhelp: consider further restricting this bound\n  |\n2 | fn b<T>(t: T) where T: Copy { [t, t]; }\n  |                        ++++\n```", "tree": {"sha": "e0ef406fb350f3a5636b157c9c229b16e4a38b2a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e0ef406fb350f3a5636b157c9c229b16e4a38b2a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/de2edb226b213c414546b4e739356f0524b871f6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/de2edb226b213c414546b4e739356f0524b871f6", "html_url": "https://github.com/rust-lang/rust/commit/de2edb226b213c414546b4e739356f0524b871f6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/de2edb226b213c414546b4e739356f0524b871f6/comments", "author": {"login": "WaffleLapkin", "id": 38225716, "node_id": "MDQ6VXNlcjM4MjI1NzE2", "avatar_url": "https://avatars.githubusercontent.com/u/38225716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/WaffleLapkin", "html_url": "https://github.com/WaffleLapkin", "followers_url": "https://api.github.com/users/WaffleLapkin/followers", "following_url": "https://api.github.com/users/WaffleLapkin/following{/other_user}", "gists_url": "https://api.github.com/users/WaffleLapkin/gists{/gist_id}", "starred_url": "https://api.github.com/users/WaffleLapkin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/WaffleLapkin/subscriptions", "organizations_url": "https://api.github.com/users/WaffleLapkin/orgs", "repos_url": "https://api.github.com/users/WaffleLapkin/repos", "events_url": "https://api.github.com/users/WaffleLapkin/events{/privacy}", "received_events_url": "https://api.github.com/users/WaffleLapkin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "WaffleLapkin", "id": 38225716, "node_id": "MDQ6VXNlcjM4MjI1NzE2", "avatar_url": "https://avatars.githubusercontent.com/u/38225716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/WaffleLapkin", "html_url": "https://github.com/WaffleLapkin", "followers_url": "https://api.github.com/users/WaffleLapkin/followers", "following_url": "https://api.github.com/users/WaffleLapkin/following{/other_user}", "gists_url": "https://api.github.com/users/WaffleLapkin/gists{/gist_id}", "starred_url": "https://api.github.com/users/WaffleLapkin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/WaffleLapkin/subscriptions", "organizations_url": "https://api.github.com/users/WaffleLapkin/orgs", "repos_url": "https://api.github.com/users/WaffleLapkin/repos", "events_url": "https://api.github.com/users/WaffleLapkin/events{/privacy}", "received_events_url": "https://api.github.com/users/WaffleLapkin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fa723160318fac5f3fa6f4141cfc41c0606a3008", "url": "https://api.github.com/repos/rust-lang/rust/commits/fa723160318fac5f3fa6f4141cfc41c0606a3008", "html_url": "https://github.com/rust-lang/rust/commit/fa723160318fac5f3fa6f4141cfc41c0606a3008"}], "stats": {"total": 71, "additions": 63, "deletions": 8}, "files": [{"sha": "76971d7ad3a05404d45b5875277f83d51637aba3", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 35, "deletions": 1, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/de2edb226b213c414546b4e739356f0524b871f6/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de2edb226b213c414546b4e739356f0524b871f6/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=de2edb226b213c414546b4e739356f0524b871f6", "patch": "@@ -17,7 +17,7 @@ use rustc_error_messages::MultiSpan;\n use rustc_index::vec::IndexVec;\n use rustc_macros::HashStable_Generic;\n use rustc_span::hygiene::MacroKind;\n-use rustc_span::source_map::Spanned;\n+use rustc_span::source_map::{SourceMap, Spanned};\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{def_id::LocalDefId, BytePos, Span, DUMMY_SP};\n use rustc_target::asm::InlineAsmRegOrRegClass;\n@@ -523,6 +523,40 @@ impl<'hir> GenericParam<'hir> {\n             })\n             .map(|sp| sp.shrink_to_hi())\n     }\n+\n+    /// Returns the span of `:` after a generic parameter.\n+    ///\n+    /// For example:\n+    ///\n+    /// ```text\n+    /// fn a<T:>()\n+    ///       ^\n+    ///       |      here\n+    ///       here   |\n+    ///              v\n+    /// fn b<T       :>()\n+    ///\n+    /// fn c<T\n+    ///\n+    /// :>()\n+    /// ^\n+    /// |\n+    /// here\n+    /// ```\n+    pub fn colon_span_for_suggestions(&self, source_map: &SourceMap) -> Option<Span> {\n+        let sp = source_map\n+            .span_extend_while(self.span.shrink_to_hi(), |c| c.is_whitespace() || c == ':')\n+            .ok()?;\n+\n+        let snippet = source_map.span_to_snippet(sp).ok()?;\n+        let offset = snippet.find(':')?;\n+\n+        let colon_sp = sp\n+            .with_lo(BytePos(sp.lo().0 + offset as u32))\n+            .with_hi(BytePos(sp.lo().0 + (offset + ':'.len_utf8()) as u32));\n+\n+        Some(colon_sp)\n+    }\n }\n \n #[derive(Default)]"}, {"sha": "3b044b19259d0b2000dad7c3abc5387c3b1cb3e9", "filename": "compiler/rustc_middle/src/ty/diagnostics.rs", "status": "modified", "additions": 28, "deletions": 7, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/de2edb226b213c414546b4e739356f0524b871f6/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de2edb226b213c414546b4e739356f0524b871f6/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs?ref=de2edb226b213c414546b4e739356f0524b871f6", "patch": "@@ -336,10 +336,14 @@ pub fn suggest_constraining_type_params<'a>(\n         }\n \n         let constraint = constraints.iter().map(|&(c, _)| c).collect::<Vec<_>>().join(\" + \");\n-        let mut suggest_restrict = |span| {\n+        let mut suggest_restrict = |span, bound_list_non_empty| {\n             suggestions.push((\n                 span,\n-                format!(\" + {}\", constraint),\n+                if bound_list_non_empty {\n+                    format!(\" + {}\", constraint)\n+                } else {\n+                    format!(\" {}\", constraint)\n+                },\n                 SuggestChangingConstraintsMessage::RestrictBoundFurther,\n             ))\n         };\n@@ -360,7 +364,10 @@ pub fn suggest_constraining_type_params<'a>(\n             //             |\n             //             replace with: `impl Foo + Bar`\n \n-            suggest_restrict(param.span.shrink_to_hi());\n+            // `impl Trait` must have at least one trait in the list\n+            let bound_list_non_empty = true;\n+\n+            suggest_restrict(param.span.shrink_to_hi(), bound_list_non_empty);\n             continue;\n         }\n \n@@ -383,15 +390,25 @@ pub fn suggest_constraining_type_params<'a>(\n                 //          --\n                 //          |\n                 //          replace with: `T: Bar +`\n-                suggest_restrict(span);\n+\n+                // `bounds_span_for_suggestions` returns `None` if the list is empty\n+                let bound_list_non_empty = true;\n+\n+                suggest_restrict(span, bound_list_non_empty);\n             } else {\n+                let (colon, span) = match param.colon_span_for_suggestions(tcx.sess.source_map()) {\n+                    // If there is already a colon after generic, do not suggest adding it again\n+                    Some(sp) => (\"\", sp.shrink_to_hi()),\n+                    None => (\":\", param.span.shrink_to_hi()),\n+                };\n+\n                 // If user hasn't provided any bounds, suggest adding a new one:\n                 //\n                 //   fn foo<T>(t: T) { ... }\n                 //          - help: consider restricting this type parameter with `T: Foo`\n                 suggestions.push((\n-                    param.span.shrink_to_hi(),\n-                    format!(\": {}\", constraint),\n+                    span,\n+                    format!(\"{colon} {constraint}\"),\n                     SuggestChangingConstraintsMessage::RestrictType { ty: param_name },\n                 ));\n             }\n@@ -459,17 +476,21 @@ pub fn suggest_constraining_type_params<'a>(\n                 ));\n             } else {\n                 let mut param_spans = Vec::new();\n+                let mut non_empty = false;\n \n                 for predicate in generics.where_clause.predicates {\n                     if let WherePredicate::BoundPredicate(WhereBoundPredicate {\n                         span,\n                         bounded_ty,\n+                        bounds,\n                         ..\n                     }) = predicate\n                     {\n                         if let TyKind::Path(QPath::Resolved(_, path)) = &bounded_ty.kind {\n                             if let Some(segment) = path.segments.first() {\n                                 if segment.ident.to_string() == param_name {\n+                                    non_empty = !bounds.is_empty();\n+\n                                     param_spans.push(span);\n                                 }\n                             }\n@@ -478,7 +499,7 @@ pub fn suggest_constraining_type_params<'a>(\n                 }\n \n                 match param_spans[..] {\n-                    [&param_span] => suggest_restrict(param_span.shrink_to_hi()),\n+                    [&param_span] => suggest_restrict(param_span.shrink_to_hi(), non_empty),\n                     _ => {\n                         suggestions.push((\n                             generics.where_clause.tail_span_for_suggestion(),"}]}