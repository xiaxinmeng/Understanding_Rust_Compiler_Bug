{"sha": "20052c83c037ee76dfc0e95f5c42c929250e6b71", "node_id": "C_kwDOAAsO6NoAKDIwMDUyYzgzYzAzN2VlNzZkZmMwZTk1ZjVjNDJjOTI5MjUwZTZiNzE", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-12-17T20:11:29Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-12-22T03:07:18Z"}, "message": "Suggest associated const on capitalization error", "tree": {"sha": "22ffe3fc3b15529d8d122e3e7c705a468ff7f645", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/22ffe3fc3b15529d8d122e3e7c705a468ff7f645"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/20052c83c037ee76dfc0e95f5c42c929250e6b71", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/20052c83c037ee76dfc0e95f5c42c929250e6b71", "html_url": "https://github.com/rust-lang/rust/commit/20052c83c037ee76dfc0e95f5c42c929250e6b71", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/20052c83c037ee76dfc0e95f5c42c929250e6b71/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bdbe392a13bc9782b98de193c3751b9d96bb5fcc", "url": "https://api.github.com/repos/rust-lang/rust/commits/bdbe392a13bc9782b98de193c3751b9d96bb5fcc", "html_url": "https://github.com/rust-lang/rust/commit/bdbe392a13bc9782b98de193c3751b9d96bb5fcc"}], "stats": {"total": 191, "additions": 178, "deletions": 13}, "files": [{"sha": "e68bd1297c87865d58574f933ec4b5e138d885ad", "filename": "compiler/rustc_hir_typeck/src/demand.rs", "status": "modified", "additions": 20, "deletions": 5, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/20052c83c037ee76dfc0e95f5c42c929250e6b71/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20052c83c037ee76dfc0e95f5c42c929250e6b71/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs?ref=20052c83c037ee76dfc0e95f5c42c929250e6b71", "patch": "@@ -23,24 +23,24 @@ use std::cmp::min;\n use std::iter;\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n-    pub fn emit_coerce_suggestions(\n+    pub fn emit_type_mismatch_suggestions(\n         &self,\n         err: &mut Diagnostic,\n         expr: &hir::Expr<'tcx>,\n         expr_ty: Ty<'tcx>,\n         expected: Ty<'tcx>,\n         expected_ty_expr: Option<&'tcx hir::Expr<'tcx>>,\n-        error: Option<TypeError<'tcx>>,\n+        _error: Option<TypeError<'tcx>>,\n     ) {\n         if expr_ty == expected {\n             return;\n         }\n \n-        self.annotate_expected_due_to_let_ty(err, expr, error);\n-\n         // Use `||` to give these suggestions a precedence\n         let _ = self.suggest_missing_parentheses(err, expr)\n+            || self.suggest_associated_const(err, expr, expected)\n             || self.suggest_deref_ref_or_into(err, expr, expected, expr_ty, expected_ty_expr)\n+            || self.suggest_option_to_bool(err, expr, expr_ty, expected)\n             || self.suggest_compatible_variants(err, expr, expected, expr_ty)\n             || self.suggest_non_zero_new_unwrap(err, expr, expected, expr_ty)\n             || self.suggest_calling_boxed_future_when_appropriate(err, expr, expected, expr_ty)\n@@ -49,9 +49,24 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             || self.suggest_block_to_brackets_peeling_refs(err, expr, expr_ty, expected)\n             || self.suggest_copied_or_cloned(err, expr, expr_ty, expected)\n             || self.suggest_into(err, expr, expr_ty, expected)\n-            || self.suggest_option_to_bool(err, expr, expr_ty, expected)\n             || self.suggest_floating_point_literal(err, expr, expected);\n+    }\n \n+    pub fn emit_coerce_suggestions(\n+        &self,\n+        err: &mut Diagnostic,\n+        expr: &hir::Expr<'tcx>,\n+        expr_ty: Ty<'tcx>,\n+        expected: Ty<'tcx>,\n+        expected_ty_expr: Option<&'tcx hir::Expr<'tcx>>,\n+        error: Option<TypeError<'tcx>>,\n+    ) {\n+        if expr_ty == expected {\n+            return;\n+        }\n+\n+        self.annotate_expected_due_to_let_ty(err, expr, error);\n+        self.emit_type_mismatch_suggestions(err, expr, expr_ty, expected, expected_ty_expr, error);\n         self.note_type_is_not_clone(err, expected, expr_ty, expr);\n         self.note_need_for_fn_pointer(err, expected, expr_ty);\n         self.note_internal_mutation_in_method(err, expr, expected, expr_ty);"}, {"sha": "ae641b26eeedbb48898bb1019e747c217b57833a", "filename": "compiler/rustc_hir_typeck/src/expr.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/20052c83c037ee76dfc0e95f5c42c929250e6b71/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20052c83c037ee76dfc0e95f5c42c929250e6b71/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs?ref=20052c83c037ee76dfc0e95f5c42c929250e6b71", "patch": "@@ -104,16 +104,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n \n         if let Some(mut err) = self.demand_suptype_diag(expr.span, expected_ty, ty) {\n-            // FIXME(compiler-errors): We probably should fold some of the\n-            // `suggest_` functions from  `emit_coerce_suggestions` into here,\n-            // since some of those aren't necessarily just coerce suggestions.\n-            let _ = self.suggest_deref_ref_or_into(\n+            let _ = self.emit_type_mismatch_suggestions(\n                 &mut err,\n                 expr.peel_drop_temps(),\n-                expected_ty,\n                 ty,\n+                expected_ty,\n                 None,\n-            ) || self.suggest_option_to_bool(&mut err, expr, ty, expected_ty);\n+                None,\n+            );\n             extend_err(&mut err);\n             err.emit();\n         }"}, {"sha": "efec0244633340e6947783902d2b1db102ba1bea", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/suggestions.rs", "status": "modified", "additions": 82, "deletions": 2, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/20052c83c037ee76dfc0e95f5c42c929250e6b71/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20052c83c037ee76dfc0e95f5c42c929250e6b71/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs?ref=20052c83c037ee76dfc0e95f5c42c929250e6b71", "patch": "@@ -1,6 +1,7 @@\n use super::FnCtxt;\n \n use crate::errors::{AddReturnTypeSuggestion, ExpectedReturnTypeLabel};\n+use crate::method::probe::{IsSuggestion, Mode, ProbeScope};\n use rustc_ast::util::parser::{ExprPrecedence, PREC_POSTFIX};\n use rustc_errors::{Applicability, Diagnostic, MultiSpan};\n use rustc_hir as hir;\n@@ -15,10 +16,11 @@ use rustc_infer::traits::{self, StatementAsExpression};\n use rustc_middle::lint::in_external_macro;\n use rustc_middle::ty::{\n     self, suggest_constraining_type_params, Binder, DefIdTree, IsSuggestable, ToPredicate, Ty,\n+    TypeVisitable,\n };\n use rustc_session::errors::ExprParenthesesNeeded;\n-use rustc_span::symbol::sym;\n-use rustc_span::Span;\n+use rustc_span::symbol::{sym, Ident};\n+use rustc_span::{Span, Symbol};\n use rustc_trait_selection::infer::InferCtxtExt;\n use rustc_trait_selection::traits::error_reporting::DefIdOrName;\n use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt as _;\n@@ -1236,6 +1238,84 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n+    pub(crate) fn suggest_associated_const(\n+        &self,\n+        err: &mut Diagnostic,\n+        expr: &hir::Expr<'_>,\n+        expected_ty: Ty<'tcx>,\n+    ) -> bool {\n+        let Some((DefKind::AssocFn, old_def_id)) = self.typeck_results.borrow().type_dependent_def(expr.hir_id) else {\n+            return false;\n+        };\n+        let old_item_name = self.tcx.item_name(old_def_id);\n+        let capitalized_name = Symbol::intern(&old_item_name.as_str().to_uppercase());\n+        if old_item_name == capitalized_name {\n+            return false;\n+        }\n+        let (item, segment) = match expr.kind {\n+            hir::ExprKind::Path(QPath::Resolved(\n+                Some(ty),\n+                hir::Path { segments: [segment], .. },\n+            ))\n+            | hir::ExprKind::Path(QPath::TypeRelative(ty, segment)) => {\n+                let self_ty = <dyn AstConv<'_>>::ast_ty_to_ty(self, ty);\n+                if let Ok(pick) = self.probe_for_name(\n+                    Mode::Path,\n+                    Ident::new(capitalized_name, segment.ident.span),\n+                    IsSuggestion(true),\n+                    self_ty,\n+                    expr.hir_id,\n+                    ProbeScope::TraitsInScope,\n+                ) {\n+                    (pick.item, segment)\n+                } else {\n+                    return false;\n+                }\n+            }\n+            hir::ExprKind::Path(QPath::Resolved(\n+                None,\n+                hir::Path { segments: [.., segment], .. },\n+            )) => {\n+                // we resolved through some path that doesn't end in the item name,\n+                // better not do a bad suggestion by accident.\n+                if old_item_name != segment.ident.name {\n+                    return false;\n+                }\n+                if let Some(item) = self\n+                    .tcx\n+                    .associated_items(self.tcx.parent(old_def_id))\n+                    .filter_by_name_unhygienic(capitalized_name)\n+                    .next()\n+                {\n+                    (*item, segment)\n+                } else {\n+                    return false;\n+                }\n+            }\n+            _ => return false,\n+        };\n+        if item.def_id == old_def_id || self.tcx.def_kind(item.def_id) != DefKind::AssocConst {\n+            // Same item\n+            return false;\n+        }\n+        let item_ty = self.tcx.type_of(item.def_id);\n+        // FIXME(compiler-errors): This check is *so* rudimentary\n+        if item_ty.needs_subst() {\n+            return false;\n+        }\n+        if self.can_coerce(item_ty, expected_ty) {\n+            err.span_suggestion_verbose(\n+                segment.ident.span,\n+                format!(\"try referring to the associated const `{capitalized_name}` instead\",),\n+                capitalized_name,\n+                Applicability::MachineApplicable,\n+            );\n+            true\n+        } else {\n+            false\n+        }\n+    }\n+\n     fn is_loop(&self, id: hir::HirId) -> bool {\n         let node = self.tcx.hir().get(id);\n         matches!(node, Node::Expr(Expr { kind: ExprKind::Loop(..), .. }))"}, {"sha": "fe2227769894c066cd11960ff6dd05d1643028ce", "filename": "src/test/ui/suggestions/assoc-ct-for-assoc-method.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/20052c83c037ee76dfc0e95f5c42c929250e6b71/src%2Ftest%2Fui%2Fsuggestions%2Fassoc-ct-for-assoc-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20052c83c037ee76dfc0e95f5c42c929250e6b71/src%2Ftest%2Fui%2Fsuggestions%2Fassoc-ct-for-assoc-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fassoc-ct-for-assoc-method.rs?ref=20052c83c037ee76dfc0e95f5c42c929250e6b71", "patch": "@@ -0,0 +1,25 @@\n+struct MyS;\n+\n+impl MyS {\n+    const FOO: i32 = 1;\n+    fn foo() -> MyS {\n+        MyS\n+    }\n+}\n+\n+fn main() {\n+    let x: i32 = MyS::foo;\n+    //~^ ERROR mismatched types\n+    //~| HELP try referring to the\n+\n+    let z: i32 = i32::max;\n+    //~^ ERROR mismatched types\n+    //~| HELP try referring to the\n+\n+    // This example is still broken though... This is a hard suggestion to make,\n+    // because we don't have access to the associated const probing code to make\n+    // this suggestion where it's emitted, i.e. in trait selection.\n+    let y: i32 = i32::max - 42;\n+    //~^ ERROR cannot subtract\n+    //~| HELP use parentheses\n+}"}, {"sha": "afef38f12967493a3916ab8d6bb4591c5cc81a7f", "filename": "src/test/ui/suggestions/assoc-ct-for-assoc-method.stderr", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/20052c83c037ee76dfc0e95f5c42c929250e6b71/src%2Ftest%2Fui%2Fsuggestions%2Fassoc-ct-for-assoc-method.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/20052c83c037ee76dfc0e95f5c42c929250e6b71/src%2Ftest%2Fui%2Fsuggestions%2Fassoc-ct-for-assoc-method.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fassoc-ct-for-assoc-method.stderr?ref=20052c83c037ee76dfc0e95f5c42c929250e6b71", "patch": "@@ -0,0 +1,47 @@\n+error[E0308]: mismatched types\n+  --> $DIR/assoc-ct-for-assoc-method.rs:11:18\n+   |\n+LL |     let x: i32 = MyS::foo;\n+   |            ---   ^^^^^^^^ expected `i32`, found fn item\n+   |            |\n+   |            expected due to this\n+   |\n+   = note: expected type `i32`\n+           found fn item `fn() -> MyS {MyS::foo}`\n+help: try referring to the associated const `FOO` instead\n+   |\n+LL |     let x: i32 = MyS::FOO;\n+   |                       ~~~\n+\n+error[E0308]: mismatched types\n+  --> $DIR/assoc-ct-for-assoc-method.rs:15:18\n+   |\n+LL |     let z: i32 = i32::max;\n+   |            ---   ^^^^^^^^ expected `i32`, found fn item\n+   |            |\n+   |            expected due to this\n+   |\n+   = note: expected type `i32`\n+           found fn item `fn(i32, i32) -> i32 {<i32 as Ord>::max}`\n+help: try referring to the associated const `MAX` instead\n+   |\n+LL |     let z: i32 = i32::MAX;\n+   |                       ~~~\n+\n+error[E0369]: cannot subtract `{integer}` from `fn(i32, i32) -> i32 {<i32 as Ord>::max}`\n+  --> $DIR/assoc-ct-for-assoc-method.rs:22:27\n+   |\n+LL |     let y: i32 = i32::max - 42;\n+   |                  -------- ^ -- {integer}\n+   |                  |\n+   |                  fn(i32, i32) -> i32 {<i32 as Ord>::max}\n+   |\n+help: use parentheses to call this associated function\n+   |\n+LL |     let y: i32 = i32::max(/* i32 */, /* i32 */) - 42;\n+   |                          ++++++++++++++++++++++\n+\n+error: aborting due to 3 previous errors\n+\n+Some errors have detailed explanations: E0308, E0369.\n+For more information about an error, try `rustc --explain E0308`."}]}