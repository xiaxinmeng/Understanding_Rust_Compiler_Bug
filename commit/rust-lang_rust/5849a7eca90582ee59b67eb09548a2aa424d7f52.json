{"sha": "5849a7eca90582ee59b67eb09548a2aa424d7f52", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU4NDlhN2VjYTkwNTgyZWU1OWI2N2ViMDk1NDhhMmFhNDI0ZDdmNTI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-10-06T10:17:48Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-10-06T10:17:48Z"}, "message": "Auto merge of #77594 - timvermeulen:chain_advance_by, r=scottmcm\n\nImplement advance_by, advance_back_by for iter::Chain\n\nPart of #77404.\n\nThis PR does two things:\n- implement `Chain::advance[_back]_by` in terms of `advance[_back]_by` on `self.a` and `advance[_back]_by` on `self.b`\n- change `Chain::nth[_back]` to use `advance[_back]_by` on `self.a` and `nth[_back]` on `self.b`\n\nThis ensures that `Chain::nth` can take advantage of an efficient `nth` implementation on the second iterator, in case it doesn't implement `advance_by`.\n\ncc `@scottmcm` in case you want to review this", "tree": {"sha": "43ce31b24c5252bd2aa10968ffd99403eec65b25", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/43ce31b24c5252bd2aa10968ffd99403eec65b25"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5849a7eca90582ee59b67eb09548a2aa424d7f52", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5849a7eca90582ee59b67eb09548a2aa424d7f52", "html_url": "https://github.com/rust-lang/rust/commit/5849a7eca90582ee59b67eb09548a2aa424d7f52", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5849a7eca90582ee59b67eb09548a2aa424d7f52/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5ded394553296d56bb66e925d7001ab3271979ce", "url": "https://api.github.com/repos/rust-lang/rust/commits/5ded394553296d56bb66e925d7001ab3271979ce", "html_url": "https://github.com/rust-lang/rust/commit/5ded394553296d56bb66e925d7001ab3271979ce"}, {"sha": "1d27a508d12a7ef1688579abb3e271b7fdcd917b", "url": "https://api.github.com/repos/rust-lang/rust/commits/1d27a508d12a7ef1688579abb3e271b7fdcd917b", "html_url": "https://github.com/rust-lang/rust/commit/1d27a508d12a7ef1688579abb3e271b7fdcd917b"}], "stats": {"total": 179, "additions": 167, "deletions": 12}, "files": [{"sha": "38fb74372db18f329a2c4c36de687d508dae3b2c", "filename": "library/core/src/iter/adapters/chain.rs", "status": "modified", "additions": 64, "deletions": 12, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/5849a7eca90582ee59b67eb09548a2aa424d7f52/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fchain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5849a7eca90582ee59b67eb09548a2aa424d7f52/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fchain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fchain.rs?ref=5849a7eca90582ee59b67eb09548a2aa424d7f52", "patch": "@@ -126,16 +126,42 @@ where\n     }\n \n     #[inline]\n-    fn nth(&mut self, mut n: usize) -> Option<A::Item> {\n+    fn advance_by(&mut self, n: usize) -> Result<(), usize> {\n+        let mut rem = n;\n+\n         if let Some(ref mut a) = self.a {\n-            while let Some(x) = a.next() {\n-                if n == 0 {\n-                    return Some(x);\n-                }\n-                n -= 1;\n+            match a.advance_by(rem) {\n+                Ok(()) => return Ok(()),\n+                Err(k) => rem -= k,\n             }\n             self.a = None;\n         }\n+\n+        if let Some(ref mut b) = self.b {\n+            match b.advance_by(rem) {\n+                Ok(()) => return Ok(()),\n+                Err(k) => rem -= k,\n+            }\n+            // we don't fuse the second iterator\n+        }\n+\n+        if rem == 0 { Ok(()) } else { Err(n - rem) }\n+    }\n+\n+    #[inline]\n+    fn nth(&mut self, mut n: usize) -> Option<Self::Item> {\n+        if let Some(ref mut a) = self.a {\n+            match a.advance_by(n) {\n+                Ok(()) => match a.next() {\n+                    None => n = 0,\n+                    x => return x,\n+                },\n+                Err(k) => n -= k,\n+            }\n+\n+            self.a = None;\n+        }\n+\n         maybe!(self.b.nth(n))\n     }\n \n@@ -202,16 +228,42 @@ where\n     }\n \n     #[inline]\n-    fn nth_back(&mut self, mut n: usize) -> Option<A::Item> {\n+    fn advance_back_by(&mut self, n: usize) -> Result<(), usize> {\n+        let mut rem = n;\n+\n         if let Some(ref mut b) = self.b {\n-            while let Some(x) = b.next_back() {\n-                if n == 0 {\n-                    return Some(x);\n-                }\n-                n -= 1;\n+            match b.advance_back_by(rem) {\n+                Ok(()) => return Ok(()),\n+                Err(k) => rem -= k,\n             }\n             self.b = None;\n         }\n+\n+        if let Some(ref mut a) = self.a {\n+            match a.advance_back_by(rem) {\n+                Ok(()) => return Ok(()),\n+                Err(k) => rem -= k,\n+            }\n+            // we don't fuse the second iterator\n+        }\n+\n+        if rem == 0 { Ok(()) } else { Err(n - rem) }\n+    }\n+\n+    #[inline]\n+    fn nth_back(&mut self, mut n: usize) -> Option<Self::Item> {\n+        if let Some(ref mut b) = self.b {\n+            match b.advance_back_by(n) {\n+                Ok(()) => match b.next_back() {\n+                    None => n = 0,\n+                    x => return x,\n+                },\n+                Err(k) => n -= k,\n+            }\n+\n+            self.b = None;\n+        }\n+\n         maybe!(self.a.nth_back(n))\n     }\n "}, {"sha": "75ca897cadc918c55324277a957e083b1e721889", "filename": "library/core/tests/iter.rs", "status": "modified", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/5849a7eca90582ee59b67eb09548a2aa424d7f52/library%2Fcore%2Ftests%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5849a7eca90582ee59b67eb09548a2aa424d7f52/library%2Fcore%2Ftests%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fiter.rs?ref=5849a7eca90582ee59b67eb09548a2aa424d7f52", "patch": "@@ -4,6 +4,43 @@ use core::cell::Cell;\n use core::convert::TryFrom;\n use core::iter::*;\n \n+/// An iterator wrapper that panics whenever `next` or `next_back` is called\n+/// after `None` has been returned.\n+struct Unfuse<I> {\n+    iter: I,\n+    exhausted: bool,\n+}\n+\n+fn unfuse<I: IntoIterator>(iter: I) -> Unfuse<I::IntoIter> {\n+    Unfuse { iter: iter.into_iter(), exhausted: false }\n+}\n+\n+impl<I> Iterator for Unfuse<I>\n+where\n+    I: Iterator,\n+{\n+    type Item = I::Item;\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        assert!(!self.exhausted);\n+        let next = self.iter.next();\n+        self.exhausted = next.is_none();\n+        next\n+    }\n+}\n+\n+impl<I> DoubleEndedIterator for Unfuse<I>\n+where\n+    I: DoubleEndedIterator,\n+{\n+    fn next_back(&mut self) -> Option<Self::Item> {\n+        assert!(!self.exhausted);\n+        let next = self.iter.next_back();\n+        self.exhausted = next.is_none();\n+        next\n+    }\n+}\n+\n #[test]\n fn test_lt() {\n     let empty: [isize; 0] = [];\n@@ -142,6 +179,72 @@ fn test_iterator_chain() {\n     assert_eq!(i, expected.len());\n }\n \n+#[test]\n+fn test_iterator_chain_advance_by() {\n+    fn test_chain(xs: &[i32], ys: &[i32]) {\n+        let len = xs.len() + ys.len();\n+\n+        for i in 0..xs.len() {\n+            let mut iter = unfuse(xs).chain(unfuse(ys));\n+            iter.advance_by(i).unwrap();\n+            assert_eq!(iter.next(), Some(&xs[i]));\n+            assert_eq!(iter.advance_by(100), Err(len - i - 1));\n+        }\n+\n+        for i in 0..ys.len() {\n+            let mut iter = unfuse(xs).chain(unfuse(ys));\n+            iter.advance_by(xs.len() + i).unwrap();\n+            assert_eq!(iter.next(), Some(&ys[i]));\n+            assert_eq!(iter.advance_by(100), Err(ys.len() - i - 1));\n+        }\n+\n+        let mut iter = xs.iter().chain(ys);\n+        iter.advance_by(len).unwrap();\n+        assert_eq!(iter.next(), None);\n+\n+        let mut iter = xs.iter().chain(ys);\n+        assert_eq!(iter.advance_by(len + 1), Err(len));\n+    }\n+\n+    test_chain(&[], &[]);\n+    test_chain(&[], &[0, 1, 2, 3, 4, 5]);\n+    test_chain(&[0, 1, 2, 3, 4, 5], &[]);\n+    test_chain(&[0, 1, 2, 3, 4, 5], &[30, 40, 50, 60]);\n+}\n+\n+#[test]\n+fn test_iterator_chain_advance_back_by() {\n+    fn test_chain(xs: &[i32], ys: &[i32]) {\n+        let len = xs.len() + ys.len();\n+\n+        for i in 0..ys.len() {\n+            let mut iter = unfuse(xs).chain(unfuse(ys));\n+            iter.advance_back_by(i).unwrap();\n+            assert_eq!(iter.next_back(), Some(&ys[ys.len() - i - 1]));\n+            assert_eq!(iter.advance_back_by(100), Err(len - i - 1));\n+        }\n+\n+        for i in 0..xs.len() {\n+            let mut iter = unfuse(xs).chain(unfuse(ys));\n+            iter.advance_back_by(ys.len() + i).unwrap();\n+            assert_eq!(iter.next_back(), Some(&xs[xs.len() - i - 1]));\n+            assert_eq!(iter.advance_back_by(100), Err(xs.len() - i - 1));\n+        }\n+\n+        let mut iter = xs.iter().chain(ys);\n+        iter.advance_back_by(len).unwrap();\n+        assert_eq!(iter.next_back(), None);\n+\n+        let mut iter = xs.iter().chain(ys);\n+        assert_eq!(iter.advance_back_by(len + 1), Err(len));\n+    }\n+\n+    test_chain(&[], &[]);\n+    test_chain(&[], &[0, 1, 2, 3, 4, 5]);\n+    test_chain(&[0, 1, 2, 3, 4, 5], &[]);\n+    test_chain(&[0, 1, 2, 3, 4, 5], &[30, 40, 50, 60]);\n+}\n+\n #[test]\n fn test_iterator_chain_nth() {\n     let xs = [0, 1, 2, 3, 4, 5];"}]}