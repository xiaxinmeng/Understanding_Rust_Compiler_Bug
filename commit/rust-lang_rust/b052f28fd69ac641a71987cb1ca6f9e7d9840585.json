{"sha": "b052f28fd69ac641a71987cb1ca6f9e7d9840585", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIwNTJmMjhmZDY5YWM2NDFhNzE5ODdjYjFjYTZmOWU3ZDk4NDA1ODU=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-11-23T23:17:34Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-11-23T23:34:27Z"}, "message": "extra: improve the errors for the JSON Decoder.\n\nFixes #4244.", "tree": {"sha": "65251ec63f1e497415841bb79b11d8e766364a24", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/65251ec63f1e497415841bb79b11d8e766364a24"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b052f28fd69ac641a71987cb1ca6f9e7d9840585", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b052f28fd69ac641a71987cb1ca6f9e7d9840585", "html_url": "https://github.com/rust-lang/rust/commit/b052f28fd69ac641a71987cb1ca6f9e7d9840585", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b052f28fd69ac641a71987cb1ca6f9e7d9840585/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fb279aa02a7ff2ed069791f60a5159d73c8ed993", "url": "https://api.github.com/repos/rust-lang/rust/commits/fb279aa02a7ff2ed069791f60a5159d73c8ed993", "html_url": "https://github.com/rust-lang/rust/commit/fb279aa02a7ff2ed069791f60a5159d73c8ed993"}], "stats": {"total": 151, "additions": 126, "deletions": 25}, "files": [{"sha": "3137d85d7c4532d06403bcd0d93ea36d92680fb7", "filename": "src/libextra/json.rs", "status": "modified", "additions": 126, "deletions": 25, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/b052f28fd69ac641a71987cb1ca6f9e7d9840585/src%2Flibextra%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b052f28fd69ac641a71987cb1ca6f9e7d9840585/src%2Flibextra%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fjson.rs?ref=b052f28fd69ac641a71987cb1ca6f9e7d9840585", "patch": "@@ -804,7 +804,7 @@ impl<T : Iterator<char>> Parser<T> {\n         while !self.eof() {\n             self.parse_whitespace();\n \n-            if self.ch != '\"' {\n+            if self.ch != '\\\"' {\n                 return self.error(~\"key must be a string\");\n             }\n \n@@ -866,12 +866,34 @@ pub fn Decoder(json: Json) -> Decoder {\n     }\n }\n \n+impl Decoder {\n+    fn err(&self, msg: &str) -> ! {\n+        fail!(\"JSON decode error: {}\", msg);\n+    }\n+    fn missing_field(&self, field: &str, object: ~Object) -> ! {\n+        self.err(format!(\"missing required '{}' field in object: {}\",\n+                         field, Object(object).to_str()))\n+    }\n+    fn expected(&self, expected: &str, found: &Json) -> ! {\n+        let found_s = match *found {\n+            Null => \"null\",\n+            List(*) => \"list\",\n+            Object(*) => \"object\",\n+            Number(*) => \"number\",\n+            String(*) => \"string\",\n+            Boolean(*) => \"boolean\"\n+        };\n+        self.err(format!(\"expected {expct} but found {fnd}: {val}\",\n+                         expct=expected, fnd=found_s, val=found.to_str()))\n+    }\n+}\n+\n impl serialize::Decoder for Decoder {\n     fn read_nil(&mut self) -> () {\n         debug!(\"read_nil\");\n         match self.stack.pop() {\n             Null => (),\n-            value => fail!(\"not a null: {:?}\", value)\n+            value => self.expected(\"null\", &value)\n         }\n     }\n \n@@ -891,33 +913,38 @@ impl serialize::Decoder for Decoder {\n         debug!(\"read_bool\");\n         match self.stack.pop() {\n             Boolean(b) => b,\n-            value => fail!(\"not a boolean: {:?}\", value)\n+            value => self.expected(\"boolean\", &value)\n         }\n     }\n \n     fn read_f64(&mut self) -> f64 {\n         debug!(\"read_f64\");\n         match self.stack.pop() {\n             Number(f) => f,\n-            value => fail!(\"not a number: {:?}\", value)\n+            value => self.expected(\"number\", &value)\n         }\n     }\n     fn read_f32(&mut self) -> f32 { self.read_f64() as f32 }\n     fn read_f32(&mut self) -> f32 { self.read_f64() as f32 }\n \n     fn read_char(&mut self) -> char {\n-        let mut v = ~[];\n         let s = self.read_str();\n-        for c in s.iter() { v.push(c) }\n-        if v.len() != 1 { fail!(\"string must have one character\") }\n-        v[0]\n+        {\n+            let mut it = s.iter();\n+            match (it.next(), it.next()) {\n+                // exactly one character\n+                (Some(c), None) => return c,\n+                _ => ()\n+            }\n+        }\n+        self.expected(\"single character string\", &String(s))\n     }\n \n     fn read_str(&mut self) -> ~str {\n         debug!(\"read_str\");\n         match self.stack.pop() {\n             String(s) => s,\n-            json => fail!(\"not a string: {:?}\", json)\n+            value => self.expected(\"string\", &value)\n         }\n     }\n \n@@ -933,26 +960,34 @@ impl serialize::Decoder for Decoder {\n         debug!(\"read_enum_variant(names={:?})\", names);\n         let name = match self.stack.pop() {\n             String(s) => s,\n-            Object(o) => {\n-                let n = match o.find(&~\"variant\").expect(\"invalidly encoded json\") {\n-                    &String(ref s) => s.clone(),\n-                    _ => fail!(\"invalidly encoded json\"),\n+            Object(mut o) => {\n+                let n = match o.pop(&~\"variant\") {\n+                    Some(String(s)) => s,\n+                    Some(val) => self.expected(\"string\", &val),\n+                    None => self.missing_field(\"variant\", o)\n                 };\n-                match o.find(&~\"fields\").expect(\"invalidly encoded json\") {\n-                    &List(ref l) => {\n-                        for field in l.rev_iter() {\n+                match o.pop(&~\"fields\") {\n+                    Some(List(l)) => {\n+                        for field in l.move_rev_iter() {\n                             self.stack.push(field.clone());\n                         }\n                     },\n-                    _ => fail!(\"invalidly encoded json\")\n+                    Some(val) => self.expected(\"list\", &val),\n+                    None => {\n+                        // re-insert the variant field so we're\n+                        // printing the \"whole\" struct in the error\n+                        // message... ick.\n+                        o.insert(~\"variant\", String(n));\n+                        self.missing_field(\"fields\", o);\n+                    }\n                 }\n                 n\n             }\n-            ref json => fail!(\"invalid variant: {:?}\", *json),\n+            json => self.expected(\"string or object\", &json)\n         };\n         let idx = match names.iter().position(|n| str::eq_slice(*n, name)) {\n             Some(idx) => idx,\n-            None => fail!(\"Unknown variant name: {}\", name),\n+            None => self.err(format!(\"unknown variant name: {}\", name))\n         };\n         f(self, idx)\n     }\n@@ -999,10 +1034,9 @@ impl serialize::Decoder for Decoder {\n                             -> T {\n         debug!(\"read_struct_field(name={}, idx={})\", name, idx);\n         match self.stack.pop() {\n-            Object(obj) => {\n-                let mut obj = obj;\n+            Object(mut obj) => {\n                 let value = match obj.pop(&name.to_owned()) {\n-                    None => fail!(\"no such field: {}\", name),\n+                    None => self.missing_field(name, obj),\n                     Some(json) => {\n                         self.stack.push(json);\n                         f(self)\n@@ -1011,7 +1045,7 @@ impl serialize::Decoder for Decoder {\n                 self.stack.push(Object(obj));\n                 value\n             }\n-            value => fail!(\"not an object: {:?}\", value)\n+            value => self.expected(\"object\", &value)\n         }\n     }\n \n@@ -1058,7 +1092,7 @@ impl serialize::Decoder for Decoder {\n                 }\n                 len\n             }\n-            _ => fail!(\"not a list\"),\n+            value => self.expected(\"list\", &value)\n         };\n         f(self, len)\n     }\n@@ -1079,7 +1113,7 @@ impl serialize::Decoder for Decoder {\n                 }\n                 len\n             }\n-            json => fail!(\"not an object: {:?}\", json),\n+            value => self.expected(\"object\", &value)\n         };\n         f(self, len)\n     }\n@@ -1936,4 +1970,71 @@ mod tests {\n                 col: 8u,\n                 msg: @~\"EOF while parsing object\"}));\n     }\n+\n+    #[deriving(Decodable)]\n+    struct DecodeStruct {\n+        x: f64,\n+        y: bool,\n+        z: ~str,\n+        w: ~[DecodeStruct]\n+    }\n+    #[deriving(Decodable)]\n+    enum DecodeEnum {\n+        A(f64),\n+        B(~str)\n+    }\n+    fn check_err<T: Decodable<Decoder>>(to_parse: &'static str, expected_error: &str) {\n+        use std::task;\n+        let res = task::try(|| {\n+            // either fails in `decode` (which is what we want), or\n+            // returns Some(error_message)/None if the string was\n+            // invalid or valid JSON.\n+            match from_str(to_parse) {\n+                Err(e) => Some(e.to_str()),\n+                Ok(json) => {\n+                    let _: T = Decodable::decode(&mut Decoder(json));\n+                    None\n+                }\n+            }\n+        });\n+        match res {\n+            Ok(Some(parse_error)) => fail!(\"`{}` is not valid json: {}\",\n+                                           to_parse, parse_error),\n+            Ok(None) => fail!(\"`{}` parsed & decoded ok, expecting error `{}`\",\n+                              to_parse, expected_error),\n+            Err(e) => {\n+                let err = e.as_ref::<~str>().unwrap();\n+                assert!(err.contains(expected_error),\n+                        \"`{}` errored incorrectly, found `{}` expecting `{}`\",\n+                        to_parse, *err, expected_error);\n+            }\n+        }\n+    }\n+    #[test]\n+    fn test_decode_errors_struct() {\n+        check_err::<DecodeStruct>(\"[]\", \"object but found list\");\n+        check_err::<DecodeStruct>(\"{\\\"x\\\": true, \\\"y\\\": true, \\\"z\\\": \\\"\\\", \\\"w\\\": []}\",\n+                                  \"number but found boolean\");\n+        check_err::<DecodeStruct>(\"{\\\"x\\\": 1, \\\"y\\\": [], \\\"z\\\": \\\"\\\", \\\"w\\\": []}\",\n+                                  \"boolean but found list\");\n+        check_err::<DecodeStruct>(\"{\\\"x\\\": 1, \\\"y\\\": true, \\\"z\\\": {}, \\\"w\\\": []}\",\n+                                  \"string but found object\");\n+        check_err::<DecodeStruct>(\"{\\\"x\\\": 1, \\\"y\\\": true, \\\"z\\\": \\\"\\\", \\\"w\\\": null}\",\n+                                  \"list but found null\");\n+        check_err::<DecodeStruct>(\"{\\\"x\\\": 1, \\\"y\\\": true, \\\"z\\\": \\\"\\\"}\",\n+                                  \"'w' field in object\");\n+    }\n+    #[test]\n+    fn test_decode_errors_enum() {\n+        check_err::<DecodeEnum>(\"{}\",\n+                                \"'variant' field in object\");\n+        check_err::<DecodeEnum>(\"{\\\"variant\\\": 1}\",\n+                                \"string but found number\");\n+        check_err::<DecodeEnum>(\"{\\\"variant\\\": \\\"A\\\"}\",\n+                                \"'fields' field in object\");\n+        check_err::<DecodeEnum>(\"{\\\"variant\\\": \\\"A\\\", \\\"fields\\\": null}\",\n+                                \"list but found null\");\n+        check_err::<DecodeEnum>(\"{\\\"variant\\\": \\\"C\\\", \\\"fields\\\": []}\",\n+                                \"unknown variant name\");\n+    }\n }"}]}