{"sha": "3a2d64f04404142cb2769aaaa57c101b258eef72", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNhMmQ2NGYwNDQwNDE0MmNiMjc2OWFhYWE1N2MxMDFiMjU4ZWVmNzI=", "commit": {"author": {"name": "Brian Anderson", "email": "andersrb@gmail.com", "date": "2011-05-22T01:54:26Z"}, "committer": {"name": "Brian Anderson", "email": "andersrb@gmail.com", "date": "2011-05-22T06:10:09Z"}, "message": "stdlib: Use if/alt expressions in std::getopts", "tree": {"sha": "dcfc58ef9a924a2a3388a56e84d0044cde6a083c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dcfc58ef9a924a2a3388a56e84d0044cde6a083c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3a2d64f04404142cb2769aaaa57c101b258eef72", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3a2d64f04404142cb2769aaaa57c101b258eef72", "html_url": "https://github.com/rust-lang/rust/commit/3a2d64f04404142cb2769aaaa57c101b258eef72", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3a2d64f04404142cb2769aaaa57c101b258eef72/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a0f855e48812d8ce5c0c2d4e7496aa0e4643bdb3", "url": "https://api.github.com/repos/rust-lang/rust/commits/a0f855e48812d8ce5c0c2d4e7496aa0e4643bdb3", "html_url": "https://github.com/rust-lang/rust/commit/a0f855e48812d8ce5c0c2d4e7496aa0e4643bdb3"}], "stats": {"total": 63, "additions": 33, "deletions": 30}, "files": [{"sha": "d6e209739d00b0baaeb039013892a2e7499e51dc", "filename": "src/lib/getopts.rs", "status": "modified", "additions": 33, "deletions": 30, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/3a2d64f04404142cb2769aaaa57c101b258eef72/src%2Flib%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a2d64f04404142cb2769aaaa57c101b258eef72/src%2Flib%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fgetopts.rs?ref=3a2d64f04404142cb2769aaaa57c101b258eef72", "patch": "@@ -38,8 +38,11 @@ tag occur { req; optional; multi; }\n type opt = rec(name name, hasarg hasarg, occur occur);\n \n fn mkname(str nm) -> name {\n-    if (str::char_len(nm) == 1u) { ret short(str::char_at(nm, 0u)); }\n-    else { ret long(nm); }\n+    ret if (str::char_len(nm) == 1u) {\n+        short(str::char_at(nm, 0u))\n+    } else {\n+        long(nm)\n+    };\n }\n fn reqopt(str name) -> opt {\n     ret rec(name=mkname(name), hasarg=yes, occur=req);\n@@ -65,23 +68,23 @@ fn is_arg(str arg) -> bool {\n     ret str::byte_len(arg) > 1u && arg.(0) == '-' as u8;\n }\n fn name_str(name nm) -> str {\n-    alt (nm) {\n-        case (short(?ch)) {ret str::from_char(ch);}\n-        case (long(?s)) {ret s;}\n-    }\n+    ret alt (nm) {\n+        case (short(?ch)) {str::from_char(ch)}\n+        case (long(?s)) {s}\n+    };\n }\n \n // FIXME rustboot workaround\n fn name_eq(name a, name b) -> bool {\n-    alt (a) {\n+    ret alt (a) {\n         case (long(?a)) {\n             alt (b) {\n-                case (long(?b)) { ret str::eq(a, b); }\n-                case (_) { ret false; }\n+                case (long(?b)) { str::eq(a, b) }\n+                case (_) { false }\n             }\n         }\n-        case (_) { if (a == b) { ret true; } else {ret false; } }\n-    }\n+        case (_) { if (a == b) { true } else { false } }\n+    };\n }\n fn find_opt(vec[opt] opts, name nm) -> option::t[uint] {\n     auto i = 0u;\n@@ -102,23 +105,23 @@ tag fail_ {\n }\n \n fn fail_str(fail_ f) -> str {\n-    alt (f) {\n+    ret alt (f) {\n         case (argument_missing(?nm)) {\n-            ret \"Argument to option '\" + nm + \"' missing.\";\n+            \"Argument to option '\" + nm + \"' missing.\"\n         }\n         case (unrecognized_option(?nm)) {\n-            ret \"Unrecognized option: '\" + nm + \"'.\";\n+            \"Unrecognized option: '\" + nm + \"'.\"\n         }\n         case (option_missing(?nm)) {\n-            ret \"Required option '\" + nm + \"' missing.\";\n+            \"Required option '\" + nm + \"' missing.\"\n         }\n         case (option_duplicated(?nm)) {\n-            ret \"option '\" + nm + \"' given more than once.\";\n+            \"option '\" + nm + \"' given more than once.\"\n         }\n         case (unexpected_argument(?nm)) {\n-            ret \"Option \" + nm + \" does not take an argument.\";\n+            \"Option \" + nm + \" does not take an argument.\"\n         }\n-    }\n+    };\n }\n \n tag result {\n@@ -228,13 +231,13 @@ fn getopts(vec[str] args, vec[opt] opts) -> result {\n }\n \n fn opt_vals(match m, str nm) -> vec[optval] {\n-    alt (find_opt(m.opts, mkname(nm))) {\n-        case (some[uint](?id)) { ret m.vals.(id); }\n+    ret alt (find_opt(m.opts, mkname(nm))) {\n+        case (some[uint](?id)) { m.vals.(id) }\n         case (none[uint]) {\n             log_err \"No option '\" + nm + \"' defined.\";\n-            fail;\n+            fail\n         }\n-    }\n+    };\n }\n fn opt_val(match m, str nm) -> optval {\n     ret opt_vals(m, nm).(0);\n@@ -243,10 +246,10 @@ fn opt_present(match m, str nm) -> bool {\n     ret vec::len[optval](opt_vals(m, nm)) > 0u;\n }\n fn opt_str(match m, str nm) -> str {\n-    alt (opt_val(m, nm)) {\n-        case (val(?s)) { ret s; }\n-        case (_) { fail; }\n-    }\n+    ret alt (opt_val(m, nm)) {\n+        case (val(?s)) { s }\n+        case (_) { fail }\n+    };\n }\n fn opt_strs(match m, str nm) -> vec[str] {\n     let vec[str] acc = [];\n@@ -261,10 +264,10 @@ fn opt_strs(match m, str nm) -> vec[str] {\n fn opt_maybe_str(match m, str nm) -> option::t[str] {\n     auto vals = opt_vals(m, nm);\n     if (vec::len[optval](vals) == 0u) { ret none[str]; }\n-    alt (vals.(0)) {\n-        case (val(?s)) { ret some[str](s); }\n-        case (_) { ret none[str]; }\n-    }\n+    ret alt (vals.(0)) {\n+        case (val(?s)) { some[str](s) }\n+        case (_) { none[str] }\n+    };\n }\n \n // Local Variables:"}]}