{"sha": "1cf8fdd4f0be26bcfa9e3b1e10d4bf80107ba492", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFjZjhmZGQ0ZjBiZTI2YmNmYTllM2IxZTEwZDRiZjgwMTA3YmE0OTI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-09-02T16:16:13Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-09-02T16:16:13Z"}, "message": "Auto merge of #87580 - ChrisDenton:win-arg-parse-2008, r=m-ou-se\n\nUpdate Windows Argument Parsing\n\nFixes #44650\n\nThe Windows command line is passed to applications [as a single string](https://docs.microsoft.com/en-us/archive/blogs/larryosterman/the-windows-command-line-is-just-a-string) which the application then parses to get a list of arguments. The standard rules (as used by C/C++) for parsing the command line have slightly changed over the years, most recently in 2008 which added new escaping rules.\n\nThis PR implements the new rules as [described on MSDN](https://docs.microsoft.com/en-us/cpp/cpp/main-function-command-line-args?view=msvc-160#parsing-c-command-line-arguments) and [further detailed here](https://daviddeley.com/autohotkey/parameters/parameters.htm#WIN). It has been tested against the behaviour of C++ by calling a C++ program that outputs its raw command line and the contents of `argv`. See [my repo](https://github.com/ChrisDenton/winarg/tree/std) if anyone wants to reproduce my work.\n\nFor an overview of how this PR changes argument parsing behavior and why we feel it is warranted see https://github.com/rust-lang/rust/pull/87580#issuecomment-893833893.\n\nFor some examples see: https://github.com/rust-lang/rust/pull/87580#issuecomment-894299249", "tree": {"sha": "c3c227121d1ac48d951f55a5a9af387911130328", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c3c227121d1ac48d951f55a5a9af387911130328"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1cf8fdd4f0be26bcfa9e3b1e10d4bf80107ba492", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1cf8fdd4f0be26bcfa9e3b1e10d4bf80107ba492", "html_url": "https://github.com/rust-lang/rust/commit/1cf8fdd4f0be26bcfa9e3b1e10d4bf80107ba492", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1cf8fdd4f0be26bcfa9e3b1e10d4bf80107ba492/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fcce644119cf4e8e36001368e514bb5ed67cb855", "url": "https://api.github.com/repos/rust-lang/rust/commits/fcce644119cf4e8e36001368e514bb5ed67cb855", "html_url": "https://github.com/rust-lang/rust/commit/fcce644119cf4e8e36001368e514bb5ed67cb855"}, {"sha": "e26dda564219341e25589ff745b16258ad424b78", "url": "https://api.github.com/repos/rust-lang/rust/commits/e26dda564219341e25589ff745b16258ad424b78", "html_url": "https://github.com/rust-lang/rust/commit/e26dda564219341e25589ff745b16258ad424b78"}], "stats": {"total": 324, "additions": 201, "deletions": 123}, "files": [{"sha": "3a1eb625b57c3d6295defa621d8517096c4974b6", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1cf8fdd4f0be26bcfa9e3b1e10d4bf80107ba492/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf8fdd4f0be26bcfa9e3b1e10d4bf80107ba492/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=1cf8fdd4f0be26bcfa9e3b1e10d4bf80107ba492", "patch": "@@ -253,6 +253,7 @@\n #![feature(const_ip)]\n #![feature(const_ipv4)]\n #![feature(const_ipv6)]\n+#![feature(const_option)]\n #![feature(const_raw_ptr_deref)]\n #![feature(const_socketaddr)]\n #![feature(const_trait_impl)]"}, {"sha": "3919025b0800663c3b37e749daa27b8ba47915d0", "filename": "library/std/src/sys/windows/args.rs", "status": "modified", "additions": 152, "deletions": 105, "changes": 257, "blob_url": "https://github.com/rust-lang/rust/blob/1cf8fdd4f0be26bcfa9e3b1e10d4bf80107ba492/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf8fdd4f0be26bcfa9e3b1e10d4bf80107ba492/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fargs.rs?ref=1cf8fdd4f0be26bcfa9e3b1e10d4bf80107ba492", "patch": "@@ -1,23 +1,30 @@\n-#![allow(dead_code)] // runtime init functions not used during testing\n+//! The Windows command line is just a string\n+//! <https://docs.microsoft.com/en-us/archive/blogs/larryosterman/the-windows-command-line-is-just-a-string>\n+//!\n+//! This module implements the parsing necessary to turn that string into a list of arguments.\n \n #[cfg(test)]\n mod tests;\n \n use crate::ffi::OsString;\n use crate::fmt;\n+use crate::marker::PhantomData;\n+use crate::num::NonZeroU16;\n use crate::os::windows::prelude::*;\n use crate::path::PathBuf;\n-use crate::slice;\n+use crate::ptr::NonNull;\n use crate::sys::c;\n use crate::sys::windows::os::current_exe;\n use crate::vec;\n \n use core::iter;\n \n pub fn args() -> Args {\n+    // SAFETY: `GetCommandLineW` returns a pointer to a null terminated UTF-16\n+    // string so it's safe for `WStrUnits` to use.\n     unsafe {\n         let lp_cmd_line = c::GetCommandLineW();\n-        let parsed_args_list = parse_lp_cmd_line(lp_cmd_line as *const u16, || {\n+        let parsed_args_list = parse_lp_cmd_line(WStrUnits::new(lp_cmd_line), || {\n             current_exe().map(PathBuf::into_os_string).unwrap_or_else(|_| OsString::new())\n         });\n \n@@ -28,129 +35,120 @@ pub fn args() -> Args {\n /// Implements the Windows command-line argument parsing algorithm.\n ///\n /// Microsoft's documentation for the Windows CLI argument format can be found at\n-/// <https://docs.microsoft.com/en-us/previous-versions//17w5ykft(v=vs.85)>.\n+/// <https://docs.microsoft.com/en-us/cpp/cpp/main-function-command-line-args?view=msvc-160#parsing-c-command-line-arguments>\n ///\n-/// Windows includes a function to do this in shell32.dll,\n-/// but linking with that DLL causes the process to be registered as a GUI application.\n+/// A more in-depth explanation is here:\n+/// <https://daviddeley.com/autohotkey/parameters/parameters.htm#WIN>\n+///\n+/// Windows includes a function to do command line parsing in shell32.dll.\n+/// However, this is not used for two reasons:\n+///\n+/// 1. Linking with that DLL causes the process to be registered as a GUI application.\n /// GUI applications add a bunch of overhead, even if no windows are drawn. See\n /// <https://randomascii.wordpress.com/2018/12/03/a-not-called-function-can-cause-a-5x-slowdown/>.\n ///\n-/// This function was tested for equivalence to the shell32.dll implementation in\n-/// Windows 10 Pro v1803, using an exhaustive test suite available at\n-/// <https://gist.github.com/notriddle/dde431930c392e428055b2dc22e638f5> or\n-/// <https://paste.gg/p/anonymous/47d6ed5f5bd549168b1c69c799825223>.\n-unsafe fn parse_lp_cmd_line<F: Fn() -> OsString>(\n-    lp_cmd_line: *const u16,\n+/// 2. It does not follow the modern C/C++ argv rules outlined in the first two links above.\n+///\n+/// This function was tested for equivalence to the C/C++ parsing rules using an\n+/// extensive test suite available at\n+/// <https://github.com/ChrisDenton/winarg/tree/std>.\n+fn parse_lp_cmd_line<'a, F: Fn() -> OsString>(\n+    lp_cmd_line: Option<WStrUnits<'a>>,\n     exe_name: F,\n ) -> Vec<OsString> {\n-    const BACKSLASH: u16 = '\\\\' as u16;\n-    const QUOTE: u16 = '\"' as u16;\n-    const TAB: u16 = '\\t' as u16;\n-    const SPACE: u16 = ' ' as u16;\n+    const BACKSLASH: NonZeroU16 = NonZeroU16::new(b'\\\\' as u16).unwrap();\n+    const QUOTE: NonZeroU16 = NonZeroU16::new(b'\"' as u16).unwrap();\n+    const TAB: NonZeroU16 = NonZeroU16::new(b'\\t' as u16).unwrap();\n+    const SPACE: NonZeroU16 = NonZeroU16::new(b' ' as u16).unwrap();\n+\n     let mut ret_val = Vec::new();\n-    if lp_cmd_line.is_null() || *lp_cmd_line == 0 {\n+    // If the cmd line pointer is null or it points to an empty string then\n+    // return the name of the executable as argv[0].\n+    if lp_cmd_line.as_ref().and_then(|cmd| cmd.peek()).is_none() {\n         ret_val.push(exe_name());\n         return ret_val;\n     }\n-    let mut cmd_line = {\n-        let mut end = 0;\n-        while *lp_cmd_line.offset(end) != 0 {\n-            end += 1;\n-        }\n-        slice::from_raw_parts(lp_cmd_line, end as usize)\n-    };\n+    let mut code_units = lp_cmd_line.unwrap();\n+\n     // The executable name at the beginning is special.\n-    cmd_line = match cmd_line[0] {\n-        // The executable name ends at the next quote mark,\n-        // no matter what.\n-        QUOTE => {\n-            let args = {\n-                let mut cut = cmd_line[1..].splitn(2, |&c| c == QUOTE);\n-                if let Some(exe) = cut.next() {\n-                    ret_val.push(OsString::from_wide(exe));\n-                }\n-                cut.next()\n-            };\n-            if let Some(args) = args {\n-                args\n-            } else {\n-                return ret_val;\n-            }\n-        }\n-        // Implement quirk: when they say whitespace here,\n-        // they include the entire ASCII control plane:\n-        // \"However, if lpCmdLine starts with any amount of whitespace, CommandLineToArgvW\n-        // will consider the first argument to be an empty string. Excess whitespace at the\n-        // end of lpCmdLine is ignored.\"\n-        0..=SPACE => {\n-            ret_val.push(OsString::new());\n-            &cmd_line[1..]\n-        }\n-        // The executable name ends at the next whitespace,\n-        // no matter what.\n-        _ => {\n-            let args = {\n-                let mut cut = cmd_line.splitn(2, |&c| c > 0 && c <= SPACE);\n-                if let Some(exe) = cut.next() {\n-                    ret_val.push(OsString::from_wide(exe));\n-                }\n-                cut.next()\n-            };\n-            if let Some(args) = args {\n-                args\n-            } else {\n-                return ret_val;\n-            }\n+    let mut in_quotes = false;\n+    let mut cur = Vec::new();\n+    for w in &mut code_units {\n+        match w {\n+            // A quote mark always toggles `in_quotes` no matter what because\n+            // there are no escape characters when parsing the executable name.\n+            QUOTE => in_quotes = !in_quotes,\n+            // If not `in_quotes` then whitespace ends argv[0].\n+            SPACE | TAB if !in_quotes => break,\n+            // In all other cases the code unit is taken literally.\n+            _ => cur.push(w.get()),\n         }\n-    };\n+    }\n+    // Skip whitespace.\n+    code_units.advance_while(|w| w == SPACE || w == TAB);\n+    ret_val.push(OsString::from_wide(&cur));\n+\n+    // Parse the arguments according to these rules:\n+    // * All code units are taken literally except space, tab, quote and backslash.\n+    // * When not `in_quotes`, space and tab separate arguments. Consecutive spaces and tabs are\n+    // treated as a single separator.\n+    // * A space or tab `in_quotes` is taken literally.\n+    // * A quote toggles `in_quotes` mode unless it's escaped. An escaped quote is taken literally.\n+    // * A quote can be escaped if preceded by an odd number of backslashes.\n+    // * If any number of backslashes is immediately followed by a quote then the number of\n+    // backslashes is halved (rounding down).\n+    // * Backslashes not followed by a quote are all taken literally.\n+    // * If `in_quotes` then a quote can also be escaped using another quote\n+    // (i.e. two consecutive quotes become one literal quote).\n     let mut cur = Vec::new();\n     let mut in_quotes = false;\n-    let mut was_in_quotes = false;\n-    let mut backslash_count: usize = 0;\n-    for &c in cmd_line {\n-        match c {\n-            // backslash\n-            BACKSLASH => {\n-                backslash_count += 1;\n-                was_in_quotes = false;\n+    while let Some(w) = code_units.next() {\n+        match w {\n+            // If not `in_quotes`, a space or tab ends the argument.\n+            SPACE | TAB if !in_quotes => {\n+                ret_val.push(OsString::from_wide(&cur[..]));\n+                cur.truncate(0);\n+\n+                // Skip whitespace.\n+                code_units.advance_while(|w| w == SPACE || w == TAB);\n             }\n-            QUOTE if backslash_count % 2 == 0 => {\n-                cur.extend(iter::repeat(b'\\\\' as u16).take(backslash_count / 2));\n-                backslash_count = 0;\n-                if was_in_quotes {\n-                    cur.push('\"' as u16);\n-                    was_in_quotes = false;\n+            // Backslashes can escape quotes or backslashes but only if consecutive backslashes are followed by a quote.\n+            BACKSLASH => {\n+                let backslash_count = code_units.advance_while(|w| w == BACKSLASH) + 1;\n+                if code_units.peek() == Some(QUOTE) {\n+                    cur.extend(iter::repeat(BACKSLASH.get()).take(backslash_count / 2));\n+                    // The quote is escaped if there are an odd number of backslashes.\n+                    if backslash_count % 2 == 1 {\n+                        code_units.next();\n+                        cur.push(QUOTE.get());\n+                    }\n                 } else {\n-                    was_in_quotes = in_quotes;\n-                    in_quotes = !in_quotes;\n+                    // If there is no quote on the end then there is no escaping.\n+                    cur.extend(iter::repeat(BACKSLASH.get()).take(backslash_count));\n                 }\n             }\n-            QUOTE if backslash_count % 2 != 0 => {\n-                cur.extend(iter::repeat(b'\\\\' as u16).take(backslash_count / 2));\n-                backslash_count = 0;\n-                was_in_quotes = false;\n-                cur.push(b'\"' as u16);\n-            }\n-            SPACE | TAB if !in_quotes => {\n-                cur.extend(iter::repeat(b'\\\\' as u16).take(backslash_count));\n-                if !cur.is_empty() || was_in_quotes {\n-                    ret_val.push(OsString::from_wide(&cur[..]));\n-                    cur.truncate(0);\n+            // If `in_quotes` and not backslash escaped (see above) then a quote either\n+            // unsets `in_quote` or is escaped by another quote.\n+            QUOTE if in_quotes => match code_units.peek() {\n+                // Two consecutive quotes when `in_quotes` produces one literal quote.\n+                Some(QUOTE) => {\n+                    cur.push(QUOTE.get());\n+                    code_units.next();\n                 }\n-                backslash_count = 0;\n-                was_in_quotes = false;\n-            }\n-            _ => {\n-                cur.extend(iter::repeat(b'\\\\' as u16).take(backslash_count));\n-                backslash_count = 0;\n-                was_in_quotes = false;\n-                cur.push(c);\n-            }\n+                // Otherwise set `in_quotes`.\n+                Some(_) => in_quotes = false,\n+                // The end of the command line.\n+                // Push `cur` even if empty, which we do by breaking while `in_quotes` is still set.\n+                None => break,\n+            },\n+            // If not `in_quotes` and not BACKSLASH escaped (see above) then a quote sets `in_quote`.\n+            QUOTE => in_quotes = true,\n+            // Everything else is always taken literally.\n+            _ => cur.push(w.get()),\n         }\n     }\n-    cur.extend(iter::repeat(b'\\\\' as u16).take(backslash_count));\n-    // include empty quoted strings at the end of the arguments list\n-    if !cur.is_empty() || was_in_quotes || in_quotes {\n+    // Push the final argument, if any.\n+    if !cur.is_empty() || in_quotes {\n         ret_val.push(OsString::from_wide(&cur[..]));\n     }\n     ret_val\n@@ -187,3 +185,52 @@ impl ExactSizeIterator for Args {\n         self.parsed_args_list.len()\n     }\n }\n+\n+/// A safe iterator over a LPWSTR\n+/// (aka a pointer to a series of UTF-16 code units terminated by a NULL).\n+struct WStrUnits<'a> {\n+    // The pointer must never be null...\n+    lpwstr: NonNull<u16>,\n+    // ...and the memory it points to must be valid for this lifetime.\n+    lifetime: PhantomData<&'a [u16]>,\n+}\n+impl WStrUnits<'_> {\n+    /// Create the iterator. Returns `None` if `lpwstr` is null.\n+    ///\n+    /// SAFETY: `lpwstr` must point to a null-terminated wide string that lives\n+    /// at least as long as the lifetime of this struct.\n+    unsafe fn new(lpwstr: *const u16) -> Option<Self> {\n+        Some(Self { lpwstr: NonNull::new(lpwstr as _)?, lifetime: PhantomData })\n+    }\n+    fn peek(&self) -> Option<NonZeroU16> {\n+        // SAFETY: It's always safe to read the current item because we don't\n+        // ever move out of the array's bounds.\n+        unsafe { NonZeroU16::new(*self.lpwstr.as_ptr()) }\n+    }\n+    /// Advance the iterator while `predicate` returns true.\n+    /// Returns the number of items it advanced by.\n+    fn advance_while<P: FnMut(NonZeroU16) -> bool>(&mut self, mut predicate: P) -> usize {\n+        let mut counter = 0;\n+        while let Some(w) = self.peek() {\n+            if !predicate(w) {\n+                break;\n+            }\n+            counter += 1;\n+            self.next();\n+        }\n+        counter\n+    }\n+}\n+impl Iterator for WStrUnits<'_> {\n+    // This can never return zero as that marks the end of the string.\n+    type Item = NonZeroU16;\n+    fn next(&mut self) -> Option<NonZeroU16> {\n+        // SAFETY: If NULL is reached we immediately return.\n+        // Therefore it's safe to advance the pointer after that.\n+        unsafe {\n+            let next = self.peek()?;\n+            self.lpwstr = NonNull::new_unchecked(self.lpwstr.as_ptr().add(1));\n+            Some(next)\n+        }\n+    }\n+}"}, {"sha": "82c32d08c5ea8f927a576b3b709f04396c621339", "filename": "library/std/src/sys/windows/args/tests.rs", "status": "modified", "additions": 47, "deletions": 17, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/1cf8fdd4f0be26bcfa9e3b1e10d4bf80107ba492/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fargs%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf8fdd4f0be26bcfa9e3b1e10d4bf80107ba492/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fargs%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fargs%2Ftests.rs?ref=1cf8fdd4f0be26bcfa9e3b1e10d4bf80107ba492", "patch": "@@ -5,9 +5,9 @@ fn chk(string: &str, parts: &[&str]) {\n     let mut wide: Vec<u16> = OsString::from(string).encode_wide().collect();\n     wide.push(0);\n     let parsed =\n-        unsafe { parse_lp_cmd_line(wide.as_ptr() as *const u16, || OsString::from(\"TEST.EXE\")) };\n+        unsafe { parse_lp_cmd_line(WStrUnits::new(wide.as_ptr()), || OsString::from(\"TEST.EXE\")) };\n     let expected: Vec<OsString> = parts.iter().map(|k| OsString::from(k)).collect();\n-    assert_eq!(parsed.as_slice(), expected.as_slice());\n+    assert_eq!(parsed.as_slice(), expected.as_slice(), \"{:?}\", string);\n }\n \n #[test]\n@@ -27,35 +27,65 @@ fn single_words() {\n #[test]\n fn official_examples() {\n     chk(r#\"EXE \"abc\" d e\"#, &[\"EXE\", \"abc\", \"d\", \"e\"]);\n-    chk(r#\"EXE a\\\\\\b d\"e f\"g h\"#, &[\"EXE\", r#\"a\\\\\\b\"#, \"de fg\", \"h\"]);\n+    chk(r#\"EXE a\\\\\\b d\"e f\"g h\"#, &[\"EXE\", r\"a\\\\\\b\", \"de fg\", \"h\"]);\n     chk(r#\"EXE a\\\\\\\"b c d\"#, &[\"EXE\", r#\"a\\\"b\"#, \"c\", \"d\"]);\n-    chk(r#\"EXE a\\\\\\\\\"b c\" d e\"#, &[\"EXE\", r#\"a\\\\b c\"#, \"d\", \"e\"]);\n+    chk(r#\"EXE a\\\\\\\\\"b c\" d e\"#, &[\"EXE\", r\"a\\\\b c\", \"d\", \"e\"]);\n }\n \n #[test]\n fn whitespace_behavior() {\n-    chk(r#\" test\"#, &[\"\", \"test\"]);\n-    chk(r#\"  test\"#, &[\"\", \"test\"]);\n-    chk(r#\" test test2\"#, &[\"\", \"test\", \"test2\"]);\n-    chk(r#\" test  test2\"#, &[\"\", \"test\", \"test2\"]);\n-    chk(r#\"test test2 \"#, &[\"test\", \"test2\"]);\n-    chk(r#\"test  test2 \"#, &[\"test\", \"test2\"]);\n-    chk(r#\"test \"#, &[\"test\"]);\n+    chk(\" test\", &[\"\", \"test\"]);\n+    chk(\"  test\", &[\"\", \"test\"]);\n+    chk(\" test test2\", &[\"\", \"test\", \"test2\"]);\n+    chk(\" test  test2\", &[\"\", \"test\", \"test2\"]);\n+    chk(\"test test2 \", &[\"test\", \"test2\"]);\n+    chk(\"test  test2 \", &[\"test\", \"test2\"]);\n+    chk(\"test \", &[\"test\"]);\n }\n \n #[test]\n fn genius_quotes() {\n     chk(r#\"EXE \"\" \"\"\"#, &[\"EXE\", \"\", \"\"]);\n-    chk(r#\"EXE \"\" \"\"\"\"#, &[\"EXE\", \"\", \"\\\"\"]);\n+    chk(r#\"EXE \"\" \"\"\"\"#, &[\"EXE\", \"\", r#\"\"\"#]);\n     chk(\n         r#\"EXE \"this is \"\"\"all\"\"\" in the same argument\"\"#,\n-        &[\"EXE\", \"this is \\\"all\\\" in the same argument\"],\n+        &[\"EXE\", r#\"this is \"all\" in the same argument\"#],\n     );\n-    chk(r#\"EXE \"a\"\"\"#, &[\"EXE\", \"a\\\"\"]);\n-    chk(r#\"EXE \"a\"\" a\"#, &[\"EXE\", \"a\\\"\", \"a\"]);\n+    chk(r#\"EXE \"a\"\"\"#, &[\"EXE\", r#\"a\"\"#]);\n+    chk(r#\"EXE \"a\"\" a\"#, &[\"EXE\", r#\"a\" a\"#]);\n     // quotes cannot be escaped in command names\n     chk(r#\"\"EXE\" check\"#, &[\"EXE\", \"check\"]);\n     chk(r#\"\"EXE check\"\"#, &[\"EXE check\"]);\n-    chk(r#\"\"EXE \"\"\"for\"\"\" check\"#, &[\"EXE \", r#\"for\"\"#, \"check\"]);\n-    chk(r#\"\"EXE \\\"for\\\" check\"#, &[r#\"EXE \\\"#, r#\"for\"\"#, \"check\"]);\n+    chk(r#\"\"EXE \"\"\"for\"\"\" check\"#, &[\"EXE for check\"]);\n+    chk(r#\"\"EXE \\\"for\\\" check\"#, &[r\"EXE \\for\\ check\"]);\n+    chk(r#\"\"EXE \\\" for \\\" check\"#, &[r\"EXE \\\", \"for\", r#\"\"\"#, \"check\"]);\n+    chk(r#\"E\"X\"E test\"#, &[\"EXE\", \"test\"]);\n+    chk(r#\"EX\"\"E test\"#, &[\"EXE\", \"test\"]);\n+}\n+\n+// from https://daviddeley.com/autohotkey/parameters/parameters.htm#WINCRULESEX\n+#[test]\n+fn post_2008() {\n+    chk(\"EXE CallMeIshmael\", &[\"EXE\", \"CallMeIshmael\"]);\n+    chk(r#\"EXE \"Call Me Ishmael\"\"#, &[\"EXE\", \"Call Me Ishmael\"]);\n+    chk(r#\"EXE Cal\"l Me I\"shmael\"#, &[\"EXE\", \"Call Me Ishmael\"]);\n+    chk(r#\"EXE CallMe\\\"Ishmael\"#, &[\"EXE\", r#\"CallMe\"Ishmael\"#]);\n+    chk(r#\"EXE \"CallMe\\\"Ishmael\"\"#, &[\"EXE\", r#\"CallMe\"Ishmael\"#]);\n+    chk(r#\"EXE \"Call Me Ishmael\\\\\"\"#, &[\"EXE\", r\"Call Me Ishmael\\\"]);\n+    chk(r#\"EXE \"CallMe\\\\\\\"Ishmael\"\"#, &[\"EXE\", r#\"CallMe\\\"Ishmael\"#]);\n+    chk(r#\"EXE a\\\\\\b\"#, &[\"EXE\", r\"a\\\\\\b\"]);\n+    chk(r#\"EXE \"a\\\\\\b\"\"#, &[\"EXE\", r\"a\\\\\\b\"]);\n+    chk(r#\"EXE \"\\\"Call Me Ishmael\\\"\"\"#, &[\"EXE\", r#\"\"Call Me Ishmael\"\"#]);\n+    chk(r#\"EXE \"C:\\TEST A\\\\\"\"#, &[\"EXE\", r\"C:\\TEST A\\\"]);\n+    chk(r#\"EXE \"\\\"C:\\TEST A\\\\\\\"\"\"#, &[\"EXE\", r#\"\"C:\\TEST A\\\"\"#]);\n+    chk(r#\"EXE \"a b c\"  d  e\"#, &[\"EXE\", \"a b c\", \"d\", \"e\"]);\n+    chk(r#\"EXE \"ab\\\"c\"  \"\\\\\"  d\"#, &[\"EXE\", r#\"ab\"c\"#, r\"\\\", \"d\"]);\n+    chk(r#\"EXE a\\\\\\b d\"e f\"g h\"#, &[\"EXE\", r\"a\\\\\\b\", \"de fg\", \"h\"]);\n+    chk(r#\"EXE a\\\\\\\"b c d\"#, &[\"EXE\", r#\"a\\\"b\"#, \"c\", \"d\"]);\n+    chk(r#\"EXE a\\\\\\\\\"b c\" d e\"#, &[\"EXE\", r\"a\\\\b c\", \"d\", \"e\"]);\n+    // Double Double Quotes\n+    chk(r#\"EXE \"a b c\"\"\"#, &[\"EXE\", r#\"a b c\"\"#]);\n+    chk(r#\"EXE \"\"\"CallMeIshmael\"\"\"  b  c\"#, &[\"EXE\", r#\"\"CallMeIshmael\"\"#, \"b\", \"c\"]);\n+    chk(r#\"EXE \"\"\"Call Me Ishmael\"\"\"\"#, &[\"EXE\", r#\"\"Call Me Ishmael\"\"#]);\n+    chk(r#\"EXE \"\"\"\"Call Me Ishmael\"\" b c\"#, &[\"EXE\", r#\"\"Call\"#, \"Me\", \"Ishmael\", \"b\", \"c\"]);\n }"}, {"sha": "6fb850d182889e7297f931894fa68560a03301b5", "filename": "library/std/src/sys/windows/c.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1cf8fdd4f0be26bcfa9e3b1e10d4bf80107ba492/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf8fdd4f0be26bcfa9e3b1e10d4bf80107ba492/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs?ref=1cf8fdd4f0be26bcfa9e3b1e10d4bf80107ba492", "patch": "@@ -789,7 +789,7 @@ extern \"system\" {\n     pub fn RemoveDirectoryW(lpPathName: LPCWSTR) -> BOOL;\n     pub fn SetFileAttributesW(lpFileName: LPCWSTR, dwFileAttributes: DWORD) -> BOOL;\n     pub fn SetLastError(dwErrCode: DWORD);\n-    pub fn GetCommandLineW() -> *mut LPCWSTR;\n+    pub fn GetCommandLineW() -> LPWSTR;\n     pub fn GetTempPathW(nBufferLength: DWORD, lpBuffer: LPCWSTR) -> DWORD;\n     pub fn GetCurrentProcess() -> HANDLE;\n     pub fn GetCurrentThread() -> HANDLE;"}]}