{"sha": "b97d4c062b4d99139f14960daa7ce99d63625833", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI5N2Q0YzA2MmI0ZDk5MTM5ZjE0OTYwZGFhN2NlOTlkNjM2MjU4MzM=", "commit": {"author": {"name": "Caio", "email": "c410.f3r@gmail.com", "date": "2021-08-08T14:49:13Z"}, "committer": {"name": "Caio", "email": "c410.f3r@gmail.com", "date": "2021-08-15T19:18:26Z"}, "message": "Introduce hir::ExprKind::Let - Take 2", "tree": {"sha": "6e6efd12d504fec2d5317b39e7f4329432cc9b40", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6e6efd12d504fec2d5317b39e7f4329432cc9b40"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b97d4c062b4d99139f14960daa7ce99d63625833", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b97d4c062b4d99139f14960daa7ce99d63625833", "html_url": "https://github.com/rust-lang/rust/commit/b97d4c062b4d99139f14960daa7ce99d63625833", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b97d4c062b4d99139f14960daa7ce99d63625833/comments", "author": {"login": "c410-f3r", "id": 17877264, "node_id": "MDQ6VXNlcjE3ODc3MjY0", "avatar_url": "https://avatars.githubusercontent.com/u/17877264?v=4", "gravatar_id": "", "url": "https://api.github.com/users/c410-f3r", "html_url": "https://github.com/c410-f3r", "followers_url": "https://api.github.com/users/c410-f3r/followers", "following_url": "https://api.github.com/users/c410-f3r/following{/other_user}", "gists_url": "https://api.github.com/users/c410-f3r/gists{/gist_id}", "starred_url": "https://api.github.com/users/c410-f3r/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/c410-f3r/subscriptions", "organizations_url": "https://api.github.com/users/c410-f3r/orgs", "repos_url": "https://api.github.com/users/c410-f3r/repos", "events_url": "https://api.github.com/users/c410-f3r/events{/privacy}", "received_events_url": "https://api.github.com/users/c410-f3r/received_events", "type": "User", "site_admin": false}, "committer": {"login": "c410-f3r", "id": 17877264, "node_id": "MDQ6VXNlcjE3ODc3MjY0", "avatar_url": "https://avatars.githubusercontent.com/u/17877264?v=4", "gravatar_id": "", "url": "https://api.github.com/users/c410-f3r", "html_url": "https://github.com/c410-f3r", "followers_url": "https://api.github.com/users/c410-f3r/followers", "following_url": "https://api.github.com/users/c410-f3r/following{/other_user}", "gists_url": "https://api.github.com/users/c410-f3r/gists{/gist_id}", "starred_url": "https://api.github.com/users/c410-f3r/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/c410-f3r/subscriptions", "organizations_url": "https://api.github.com/users/c410-f3r/orgs", "repos_url": "https://api.github.com/users/c410-f3r/repos", "events_url": "https://api.github.com/users/c410-f3r/events{/privacy}", "received_events_url": "https://api.github.com/users/c410-f3r/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "80bff87c6f22b98c5a7c0cb36233e4e2ba7e5a56", "url": "https://api.github.com/repos/rust-lang/rust/commits/80bff87c6f22b98c5a7c0cb36233e4e2ba7e5a56", "html_url": "https://github.com/rust-lang/rust/commit/80bff87c6f22b98c5a7c0cb36233e4e2ba7e5a56"}], "stats": {"total": 1712, "additions": 1043, "deletions": 669}, "files": [{"sha": "891e865b245dda516c07987e4a5ce3827d0a094a", "filename": "clippy_lints/src/assertions_on_constants.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b97d4c062b4d99139f14960daa7ce99d63625833/clippy_lints%2Fsrc%2Fassertions_on_constants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b97d4c062b4d99139f14960daa7ce99d63625833/clippy_lints%2Fsrc%2Fassertions_on_constants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fassertions_on_constants.rs?ref=b97d4c062b4d99139f14960daa7ce99d63625833", "patch": "@@ -1,5 +1,6 @@\n use clippy_utils::consts::{constant, Constant};\n use clippy_utils::diagnostics::span_lint_and_help;\n+use clippy_utils::higher;\n use clippy_utils::source::snippet_opt;\n use clippy_utils::{is_direct_expn_of, is_expn_of, match_panic_call};\n use if_chain::if_chain;\n@@ -116,8 +117,8 @@ enum AssertKind {\n /// where `message` is any expression and `c` is a constant bool.\n fn match_assert_with_message<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> Option<AssertKind> {\n     if_chain! {\n-        if let ExprKind::If(cond, then, _) = expr.kind;\n-        if let ExprKind::Unary(UnOp::Not, expr) = cond.kind;\n+        if let Some(higher::If { cond, then, .. }) = higher::If::hir(expr);\n+        if let ExprKind::Unary(UnOp::Not, ref expr) = cond.kind;\n         // bind the first argument of the `assert!` macro\n         if let Some((Constant::Bool(is_true), _)) = constant(cx, cx.typeck_results(), expr);\n         // block"}, {"sha": "51d95cc6f0b10b485c2f94e3fd10b200e9bb8442", "filename": "clippy_lints/src/blocks_in_if_conditions.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b97d4c062b4d99139f14960daa7ce99d63625833/clippy_lints%2Fsrc%2Fblocks_in_if_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b97d4c062b4d99139f14960daa7ce99d63625833/clippy_lints%2Fsrc%2Fblocks_in_if_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fblocks_in_if_conditions.rs?ref=b97d4c062b4d99139f14960daa7ce99d63625833", "patch": "@@ -1,4 +1,5 @@\n use clippy_utils::diagnostics::{span_lint, span_lint_and_sugg};\n+use clippy_utils::higher;\n use clippy_utils::source::snippet_block_with_applicability;\n use clippy_utils::ty::implements_trait;\n use clippy_utils::{differing_macro_contexts, get_parent_expr};\n@@ -92,7 +93,7 @@ impl<'tcx> LateLintPass<'tcx> for BlocksInIfConditions {\n         if in_external_macro(cx.sess(), expr.span) {\n             return;\n         }\n-        if let ExprKind::If(cond, _, _) = &expr.kind {\n+        if let Some(higher::If { cond, .. }) = higher::If::hir(expr) {\n             if let ExprKind::Block(block, _) = &cond.kind {\n                 if block.rules == BlockCheckMode::DefaultBlock {\n                     if block.stmts.is_empty() {"}, {"sha": "6b63c2cf157ac8a8c819431005d56027022daab9", "filename": "clippy_lints/src/collapsible_match.rs", "status": "modified", "additions": 62, "deletions": 15, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/b97d4c062b4d99139f14960daa7ce99d63625833/clippy_lints%2Fsrc%2Fcollapsible_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b97d4c062b4d99139f14960daa7ce99d63625833/clippy_lints%2Fsrc%2Fcollapsible_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcollapsible_match.rs?ref=b97d4c062b4d99139f14960daa7ce99d63625833", "patch": "@@ -1,9 +1,9 @@\n use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::visitors::LocalUsedVisitor;\n-use clippy_utils::{is_lang_ctor, path_to_local, peel_ref_operators, SpanlessEq};\n+use clippy_utils::{higher, is_lang_ctor, path_to_local, peel_ref_operators, SpanlessEq};\n use if_chain::if_chain;\n use rustc_hir::LangItem::OptionNone;\n-use rustc_hir::{Arm, Expr, ExprKind, Guard, HirId, Pat, PatKind, StmtKind};\n+use rustc_hir::{Expr, ExprKind, Guard, HirId, Pat, PatKind, StmtKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::{MultiSpan, Span};\n@@ -49,22 +49,44 @@ declare_lint_pass!(CollapsibleMatch => [COLLAPSIBLE_MATCH]);\n \n impl<'tcx> LateLintPass<'tcx> for CollapsibleMatch {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &Expr<'tcx>) {\n+        if let Some(higher::IfLet {\n+            let_pat,\n+            if_then,\n+            if_else,\n+            ..\n+        }) = higher::IfLet::hir(expr)\n+        {\n+            check_arm(cx, if_then, None, let_pat, if_else);\n+\n+            check_if_let(cx, if_then, let_pat);\n+        }\n+\n         if let ExprKind::Match(_expr, arms, _source) = expr.kind {\n-            if let Some(wild_arm) = arms.iter().rfind(|arm| arm_is_wild_like(cx, arm)) {\n+            if let Some(wild_arm) = arms.iter().rfind(|arm| is_wild_like(cx, &arm.pat.kind, &arm.guard)) {\n                 for arm in arms {\n-                    check_arm(arm, wild_arm, cx);\n+                    check_arm(cx, arm.body, arm.guard.as_ref(), arm.pat, Some(wild_arm.body));\n                 }\n             }\n+\n+            if let Some(first_arm) = arms.get(0) {\n+                check_if_let(cx, &first_arm.body, &first_arm.pat);\n+            }\n         }\n     }\n }\n \n-fn check_arm<'tcx>(arm: &Arm<'tcx>, wild_outer_arm: &Arm<'tcx>, cx: &LateContext<'tcx>) {\n-    let expr = strip_singleton_blocks(arm.body);\n+fn check_arm<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    outer_block: &'tcx Expr<'tcx>,\n+    outer_guard: Option<&Guard<'tcx>>,\n+    outer_pat: &'tcx Pat<'tcx>,\n+    wild_outer_block: Option<&'tcx Expr<'tcx>>,\n+) {\n+    let expr = strip_singleton_blocks(outer_block);\n     if_chain! {\n         if let ExprKind::Match(expr_in, arms_inner, _) = expr.kind;\n         // the outer arm pattern and the inner match\n-        if expr_in.span.ctxt() == arm.pat.span.ctxt();\n+        if expr_in.span.ctxt() == outer_pat.span.ctxt();\n         // there must be no more than two arms in the inner match for this lint\n         if arms_inner.len() == 2;\n         // no if guards on the inner match\n@@ -73,18 +95,18 @@ fn check_arm<'tcx>(arm: &Arm<'tcx>, wild_outer_arm: &Arm<'tcx>, cx: &LateContext\n         // match <local> { .. }\n         if let Some(binding_id) = path_to_local(peel_ref_operators(cx, expr_in));\n         // one of the branches must be \"wild-like\"\n-        if let Some(wild_inner_arm_idx) = arms_inner.iter().rposition(|arm_inner| arm_is_wild_like(cx, arm_inner));\n+        if let Some(wild_inner_arm_idx) = arms_inner.iter().rposition(|arm_inner| is_wild_like(cx, &arm_inner.pat.kind, &arm_inner.guard));\n         let (wild_inner_arm, non_wild_inner_arm) =\n             (&arms_inner[wild_inner_arm_idx], &arms_inner[1 - wild_inner_arm_idx]);\n         if !pat_contains_or(non_wild_inner_arm.pat);\n         // the binding must come from the pattern of the containing match arm\n         // ..<local>.. => match <local> { .. }\n-        if let Some(binding_span) = find_pat_binding(arm.pat, binding_id);\n+        if let Some(binding_span) = find_pat_binding(outer_pat, binding_id);\n         // the \"wild-like\" branches must be equal\n-        if SpanlessEq::new(cx).eq_expr(wild_inner_arm.body, wild_outer_arm.body);\n+        if wild_outer_block.map(|el| SpanlessEq::new(cx).eq_expr(wild_inner_arm.body, el)).unwrap_or(true);\n         // the binding must not be used in the if guard\n         let mut used_visitor = LocalUsedVisitor::new(cx, binding_id);\n-        if match arm.guard {\n+        if match outer_guard {\n             None => true,\n             Some(Guard::If(expr) | Guard::IfLet(_, expr)) => !used_visitor.check_expr(expr),\n         };\n@@ -107,6 +129,31 @@ fn check_arm<'tcx>(arm: &Arm<'tcx>, wild_outer_arm: &Arm<'tcx>, cx: &LateContext\n     }\n }\n \n+fn check_if_let<'tcx>(cx: &LateContext<'tcx>, outer_expr: &'tcx Expr<'tcx>, outer_pat: &'tcx Pat<'tcx>) {\n+    let block_inner = strip_singleton_blocks(outer_expr);\n+    if_chain! {\n+        if let Some(higher::IfLet { if_then: inner_if_then, let_expr: inner_let_expr, let_pat: inner_let_pat, .. }) = higher::IfLet::hir(block_inner);\n+        if let Some(binding_id) = path_to_local(peel_ref_operators(cx, inner_let_expr));\n+        if let Some(binding_span) = find_pat_binding(outer_pat, binding_id);\n+        let mut used_visitor = LocalUsedVisitor::new(cx, binding_id);\n+        if !used_visitor.check_expr(inner_if_then);\n+        then {\n+            span_lint_and_then(\n+                cx,\n+                COLLAPSIBLE_MATCH,\n+                block_inner.span,\n+                \"unnecessary nested `if let` or `match`\",\n+                |diag| {\n+                    let mut help_span = MultiSpan::from_spans(vec![binding_span, inner_let_pat.span]);\n+                    help_span.push_span_label(binding_span, \"replace this binding\".into());\n+                    help_span.push_span_label(inner_let_pat.span, \"with this pattern\".into());\n+                    diag.span_help(help_span, \"the outer pattern can be modified to include the inner pattern\");\n+                },\n+            );\n+        }\n+    }\n+}\n+\n fn strip_singleton_blocks<'hir>(mut expr: &'hir Expr<'hir>) -> &'hir Expr<'hir> {\n     while let ExprKind::Block(block, _) = expr.kind {\n         match (block.stmts, block.expr) {\n@@ -122,13 +169,13 @@ fn strip_singleton_blocks<'hir>(mut expr: &'hir Expr<'hir>) -> &'hir Expr<'hir>\n }\n \n /// A \"wild-like\" pattern is wild (\"_\") or `None`.\n-/// For this lint to apply, both the outer and inner match expressions\n+/// For this lint to apply, both the outer and inner patterns\n /// must have \"wild-like\" branches that can be combined.\n-fn arm_is_wild_like(cx: &LateContext<'_>, arm: &Arm<'_>) -> bool {\n-    if arm.guard.is_some() {\n+fn is_wild_like(cx: &LateContext<'_>, pat_kind: &PatKind<'_>, arm_guard: &Option<Guard<'_>>) -> bool {\n+    if arm_guard.is_some() {\n         return false;\n     }\n-    match arm.pat.kind {\n+    match pat_kind {\n         PatKind::Binding(..) | PatKind::Wild => true,\n         PatKind::Path(ref qpath) => is_lang_ctor(cx, qpath, OptionNone),\n         _ => false,"}, {"sha": "5eb99cfe24f49dbae264ea7e6d48b02c7febab4f", "filename": "clippy_lints/src/copies.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b97d4c062b4d99139f14960daa7ce99d63625833/clippy_lints%2Fsrc%2Fcopies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b97d4c062b4d99139f14960daa7ce99d63625833/clippy_lints%2Fsrc%2Fcopies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcopies.rs?ref=b97d4c062b4d99139f14960daa7ce99d63625833", "patch": "@@ -316,9 +316,10 @@ fn scan_block_for_eq(cx: &LateContext<'tcx>, blocks: &[&Block<'tcx>]) -> Option<\n     let mut start_eq = usize::MAX;\n     let mut end_eq = usize::MAX;\n     let mut expr_eq = true;\n-    for win in blocks.windows(2) {\n-        let l_stmts = win[0].stmts;\n-        let r_stmts = win[1].stmts;\n+    let mut iter = blocks.windows(2);\n+    while let Some(&[win0, win1]) = iter.next() {\n+        let l_stmts = win0.stmts;\n+        let r_stmts = win1.stmts;\n \n         // `SpanlessEq` now keeps track of the locals and is therefore context sensitive clippy#6752.\n         // The comparison therefore needs to be done in a way that builds the correct context.\n@@ -335,22 +336,22 @@ fn scan_block_for_eq(cx: &LateContext<'tcx>, blocks: &[&Block<'tcx>]) -> Option<\n             it1.zip(it2)\n                 .fold(0, |acc, (l, r)| if evaluator.eq_stmt(l, r) { acc + 1 } else { 0 })\n         };\n-        let block_expr_eq = both(&win[0].expr, &win[1].expr, |l, r| evaluator.eq_expr(l, r));\n+        let block_expr_eq = both(&win0.expr, &win1.expr, |l, r| evaluator.eq_expr(l, r));\n \n         // IF_SAME_THEN_ELSE\n         if_chain! {\n             if block_expr_eq;\n             if l_stmts.len() == r_stmts.len();\n             if l_stmts.len() == current_start_eq;\n-            if !is_lint_allowed(cx, IF_SAME_THEN_ELSE, win[0].hir_id);\n-            if !is_lint_allowed(cx, IF_SAME_THEN_ELSE, win[1].hir_id);\n+            if !is_lint_allowed(cx, IF_SAME_THEN_ELSE, win0.hir_id);\n+            if !is_lint_allowed(cx, IF_SAME_THEN_ELSE, win1.hir_id);\n             then {\n                 span_lint_and_note(\n                     cx,\n                     IF_SAME_THEN_ELSE,\n-                    win[0].span,\n+                    win0.span,\n                     \"this `if` has identical blocks\",\n-                    Some(win[1].span),\n+                    Some(win1.span),\n                     \"same as this\",\n                 );\n "}, {"sha": "7825e5f6ed52e45f9f715c0cb2b93fd55a4fc9ca", "filename": "clippy_lints/src/dereference.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b97d4c062b4d99139f14960daa7ce99d63625833/clippy_lints%2Fsrc%2Fdereference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b97d4c062b4d99139f14960daa7ce99d63625833/clippy_lints%2Fsrc%2Fdereference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdereference.rs?ref=b97d4c062b4d99139f14960daa7ce99d63625833", "patch": "@@ -232,6 +232,7 @@ fn is_linted_explicit_deref_position(parent: Option<Node<'_>>, child_id: HirId,\n         | ExprKind::If(..)\n         | ExprKind::Loop(..)\n         | ExprKind::Match(..)\n+        | ExprKind::Let(..)\n         | ExprKind::Closure(..)\n         | ExprKind::Block(..)\n         | ExprKind::Assign(..)"}, {"sha": "627f746ec99716fd6510ba61cbd7b0912c327e53", "filename": "clippy_lints/src/entry.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b97d4c062b4d99139f14960daa7ce99d63625833/clippy_lints%2Fsrc%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b97d4c062b4d99139f14960daa7ce99d63625833/clippy_lints%2Fsrc%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fentry.rs?ref=b97d4c062b4d99139f14960daa7ce99d63625833", "patch": "@@ -1,10 +1,12 @@\n+use clippy_utils::higher;\n use clippy_utils::{\n     can_move_expr_to_closure_no_visit,\n     diagnostics::span_lint_and_sugg,\n     is_expr_final_block_expr, is_expr_used_or_unified, match_def_path, paths, peel_hir_expr_while,\n     source::{reindent_multiline, snippet_indent, snippet_with_applicability, snippet_with_context},\n     SpanlessEq,\n };\n+use core::fmt::Write;\n use rustc_errors::Applicability;\n use rustc_hir::{\n     intravisit::{walk_expr, ErasedMap, NestedVisitorMap, Visitor},\n@@ -13,7 +15,6 @@ use rustc_hir::{\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::{Span, SyntaxContext, DUMMY_SP};\n-use std::fmt::Write;\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -62,10 +63,11 @@ declare_lint_pass!(HashMapPass => [MAP_ENTRY]);\n impl<'tcx> LateLintPass<'tcx> for HashMapPass {\n     #[allow(clippy::too_many_lines)]\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        let (cond_expr, then_expr, else_expr) = match expr.kind {\n-            ExprKind::If(c, t, e) => (c, t, e),\n+        let (cond_expr, then_expr, else_expr) = match higher::If::hir(expr) {\n+            Some(higher::If { cond, then, r#else }) => (cond, then, r#else),\n             _ => return,\n         };\n+\n         let (map_ty, contains_expr) = match try_parse_contains(cx, cond_expr) {\n             Some(x) => x,\n             None => return,"}, {"sha": "f6a64a8ca6031f7a352595ed48d0f283ba8ea8da", "filename": "clippy_lints/src/eta_reduction.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b97d4c062b4d99139f14960daa7ce99d63625833/clippy_lints%2Fsrc%2Feta_reduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b97d4c062b4d99139f14960daa7ce99d63625833/clippy_lints%2Fsrc%2Feta_reduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feta_reduction.rs?ref=b97d4c062b4d99139f14960daa7ce99d63625833", "patch": "@@ -100,7 +100,7 @@ fn check_closure<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n \n         if ex.span.ctxt() != expr.span.ctxt() {\n             if decl.inputs.is_empty() {\n-                if let Some(VecArgs::Vec(&[])) = higher::vec_macro(cx, ex) {\n+                if let Some(VecArgs::Vec(&[])) = higher::VecArgs::hir(cx, ex) {\n                     // replace `|| vec![]` with `Vec::new`\n                     span_lint_and_sugg(\n                         cx,"}, {"sha": "d12482e7b7bb9531bb4fe569e29321b1976d121c", "filename": "clippy_lints/src/floating_point_arithmetic.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b97d4c062b4d99139f14960daa7ce99d63625833/clippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b97d4c062b4d99139f14960daa7ce99d63625833/clippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs?ref=b97d4c062b4d99139f14960daa7ce99d63625833", "patch": "@@ -3,6 +3,7 @@ use clippy_utils::consts::{\n     Constant::{Int, F32, F64},\n };\n use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::higher;\n use clippy_utils::{eq_expr_value, get_parent_expr, numeric_literal, sugg};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n@@ -545,11 +546,11 @@ fn are_negated<'a>(cx: &LateContext<'_>, expr1: &'a Expr<'a>, expr2: &'a Expr<'a\n \n fn check_custom_abs(cx: &LateContext<'_>, expr: &Expr<'_>) {\n     if_chain! {\n-        if let ExprKind::If(cond, body, else_body) = expr.kind;\n-        if let ExprKind::Block(block, _) = body.kind;\n+        if let Some(higher::If { cond, then, r#else }) = higher::If::hir(expr);\n+        if let ExprKind::Block(block, _) = then.kind;\n         if block.stmts.is_empty();\n         if let Some(if_body_expr) = block.expr;\n-        if let Some(ExprKind::Block(else_block, _)) = else_body.map(|el| &el.kind);\n+        if let Some(ExprKind::Block(else_block, _)) = r#else.map(|el| &el.kind);\n         if else_block.stmts.is_empty();\n         if let Some(else_body_expr) = else_block.expr;\n         if let Some((if_expr_positive, body)) = are_negated(cx, if_body_expr, else_body_expr);"}, {"sha": "e2d3905eacb504106cbe27b58fe633c9174dfc86", "filename": "clippy_lints/src/if_let_mutex.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/b97d4c062b4d99139f14960daa7ce99d63625833/clippy_lints%2Fsrc%2Fif_let_mutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b97d4c062b4d99139f14960daa7ce99d63625833/clippy_lints%2Fsrc%2Fif_let_mutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fif_let_mutex.rs?ref=b97d4c062b4d99139f14960daa7ce99d63625833", "patch": "@@ -1,9 +1,10 @@\n use clippy_utils::diagnostics::span_lint_and_help;\n+use clippy_utils::higher;\n use clippy_utils::ty::is_type_diagnostic_item;\n use clippy_utils::SpanlessEq;\n use if_chain::if_chain;\n use rustc_hir::intravisit::{self as visit, NestedVisitorMap, Visitor};\n-use rustc_hir::{Expr, ExprKind, MatchSource};\n+use rustc_hir::{Expr, ExprKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::hir::map::Map;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n@@ -42,7 +43,7 @@ declare_clippy_lint! {\n declare_lint_pass!(IfLetMutex => [IF_LET_MUTEX]);\n \n impl<'tcx> LateLintPass<'tcx> for IfLetMutex {\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, ex: &'tcx Expr<'tcx>) {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'tcx>) {\n         let mut arm_visit = ArmVisitor {\n             mutex_lock_called: false,\n             found_mutex: None,\n@@ -53,25 +54,23 @@ impl<'tcx> LateLintPass<'tcx> for IfLetMutex {\n             found_mutex: None,\n             cx,\n         };\n-        if let ExprKind::Match(\n-            op,\n-            arms,\n-            MatchSource::IfLetDesugar {\n-                contains_else_clause: true,\n-            },\n-        ) = ex.kind\n+        if let Some(higher::IfLet {\n+            let_expr,\n+            if_then,\n+            if_else: Some(if_else),\n+            ..\n+        }) = higher::IfLet::hir(expr)\n         {\n-            op_visit.visit_expr(op);\n+            op_visit.visit_expr(let_expr);\n             if op_visit.mutex_lock_called {\n-                for arm in arms {\n-                    arm_visit.visit_arm(arm);\n-                }\n+                arm_visit.visit_expr(if_then);\n+                arm_visit.visit_expr(if_else);\n \n                 if arm_visit.mutex_lock_called && arm_visit.same_mutex(cx, op_visit.found_mutex.unwrap()) {\n                     span_lint_and_help(\n                         cx,\n                         IF_LET_MUTEX,\n-                        ex.span,\n+                        expr.span,\n                         \"calling `Mutex::lock` inside the scope of another `Mutex::lock` causes a deadlock\",\n                         None,\n                         \"move the lock call outside of the `if let ...` expression\","}, {"sha": "cd813c639dbbf2391c2bac32b1262e90926ff851", "filename": "clippy_lints/src/if_let_some_result.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b97d4c062b4d99139f14960daa7ce99d63625833/clippy_lints%2Fsrc%2Fif_let_some_result.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b97d4c062b4d99139f14960daa7ce99d63625833/clippy_lints%2Fsrc%2Fif_let_some_result.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fif_let_some_result.rs?ref=b97d4c062b4d99139f14960daa7ce99d63625833", "patch": "@@ -1,10 +1,11 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::higher;\n use clippy_utils::method_chain_args;\n use clippy_utils::source::snippet_with_applicability;\n use clippy_utils::ty::is_type_diagnostic_item;\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n-use rustc_hir::{Expr, ExprKind, MatchSource, PatKind, QPath};\n+use rustc_hir::{Expr, ExprKind, PatKind, QPath};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::sym;\n@@ -44,17 +45,17 @@ declare_lint_pass!(OkIfLet => [IF_LET_SOME_RESULT]);\n impl<'tcx> LateLintPass<'tcx> for OkIfLet {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if_chain! { //begin checking variables\n-            if let ExprKind::Match(op, body, MatchSource::IfLetDesugar { .. }) = expr.kind; //test if expr is if let\n-            if let ExprKind::MethodCall(_, ok_span, result_types, _) = op.kind; //check is expr.ok() has type Result<T,E>.ok(, _)\n-            if let PatKind::TupleStruct(QPath::Resolved(_, x), y, _)  = body[0].pat.kind; //get operation\n-            if method_chain_args(op, &[\"ok\"]).is_some(); //test to see if using ok() methoduse std::marker::Sized;\n+            if let Some(higher::IfLet { let_pat, let_expr, .. }) = higher::IfLet::hir(expr);\n+            if let ExprKind::MethodCall(_, ok_span, ref result_types, _) = let_expr.kind; //check is expr.ok() has type Result<T,E>.ok(, _)\n+            if let PatKind::TupleStruct(QPath::Resolved(_, ref x), ref y, _)  = let_pat.kind; //get operation\n+            if method_chain_args(let_expr, &[\"ok\"]).is_some(); //test to see if using ok() methoduse std::marker::Sized;\n             if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(&result_types[0]), sym::result_type);\n             if rustc_hir_pretty::to_string(rustc_hir_pretty::NO_ANN, |s| s.print_path(x, false)) == \"Some\";\n \n             then {\n                 let mut applicability = Applicability::MachineApplicable;\n                 let some_expr_string = snippet_with_applicability(cx, y[0].span, \"\", &mut applicability);\n-                let trimmed_ok = snippet_with_applicability(cx, op.span.until(ok_span), \"\", &mut applicability);\n+                let trimmed_ok = snippet_with_applicability(cx, let_expr.span.until(ok_span), \"\", &mut applicability);\n                 let sugg = format!(\n                     \"if let Ok({}) = {}\",\n                     some_expr_string,\n@@ -63,7 +64,7 @@ impl<'tcx> LateLintPass<'tcx> for OkIfLet {\n                 span_lint_and_sugg(\n                     cx,\n                     IF_LET_SOME_RESULT,\n-                    expr.span.with_hi(op.span.hi()),\n+                    expr.span.with_hi(let_expr.span.hi()),\n                     \"matching on `Some` with `ok()` is redundant\",\n                     &format!(\"consider matching on `Ok({})` and removing the call to `ok` instead\", some_expr_string),\n                     sugg,"}, {"sha": "a2dac57454f2d3b7430d4127c70dec75b1952e64", "filename": "clippy_lints/src/if_then_some_else_none.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b97d4c062b4d99139f14960daa7ce99d63625833/clippy_lints%2Fsrc%2Fif_then_some_else_none.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b97d4c062b4d99139f14960daa7ce99d63625833/clippy_lints%2Fsrc%2Fif_then_some_else_none.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fif_then_some_else_none.rs?ref=b97d4c062b4d99139f14960daa7ce99d63625833", "patch": "@@ -1,6 +1,6 @@\n use clippy_utils::diagnostics::span_lint_and_help;\n use clippy_utils::source::snippet_with_macro_callsite;\n-use clippy_utils::{is_else_clause, is_lang_ctor, meets_msrv, msrvs};\n+use clippy_utils::{higher, is_else_clause, is_lang_ctor, meets_msrv, msrvs};\n use if_chain::if_chain;\n use rustc_hir::LangItem::{OptionNone, OptionSome};\n use rustc_hir::{Expr, ExprKind};\n@@ -70,7 +70,7 @@ impl LateLintPass<'_> for IfThenSomeElseNone {\n         }\n \n         if_chain! {\n-            if let ExprKind::If(cond, then, Some(els)) = expr.kind;\n+            if let Some(higher::If { cond, then, r#else: Some(els) }) = higher::If::hir(expr);\n             if let ExprKind::Block(then_block, _) = then.kind;\n             if let Some(then_expr) = then_block.expr;\n             if let ExprKind::Call(then_call, [then_arg]) = then_expr.kind;"}, {"sha": "79d4d7ddcbcedfe8e0ad85116a98a76068dc6c46", "filename": "clippy_lints/src/implicit_saturating_sub.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b97d4c062b4d99139f14960daa7ce99d63625833/clippy_lints%2Fsrc%2Fimplicit_saturating_sub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b97d4c062b4d99139f14960daa7ce99d63625833/clippy_lints%2Fsrc%2Fimplicit_saturating_sub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fimplicit_saturating_sub.rs?ref=b97d4c062b4d99139f14960daa7ce99d63625833", "patch": "@@ -1,4 +1,5 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::higher;\n use clippy_utils::{in_macro, SpanlessEq};\n use if_chain::if_chain;\n use rustc_ast::ast::LitKind;\n@@ -42,7 +43,7 @@ impl<'tcx> LateLintPass<'tcx> for ImplicitSaturatingSub {\n             return;\n         }\n         if_chain! {\n-            if let ExprKind::If(cond, then, None) = &expr.kind;\n+            if let Some(higher::If { cond, then, .. }) = higher::If::hir(expr);\n \n             // Check if the conditional expression is a binary operation\n             if let ExprKind::Binary(ref cond_op, cond_left, cond_right) = cond.kind;"}, {"sha": "f52f090d3872e11ab873ada16b9a0621620d299e", "filename": "clippy_lints/src/indexing_slicing.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b97d4c062b4d99139f14960daa7ce99d63625833/clippy_lints%2Fsrc%2Findexing_slicing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b97d4c062b4d99139f14960daa7ce99d63625833/clippy_lints%2Fsrc%2Findexing_slicing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Findexing_slicing.rs?ref=b97d4c062b4d99139f14960daa7ce99d63625833", "patch": "@@ -96,7 +96,7 @@ impl<'tcx> LateLintPass<'tcx> for IndexingSlicing {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if let ExprKind::Index(array, index) = &expr.kind {\n             let ty = cx.typeck_results().expr_ty(array).peel_refs();\n-            if let Some(range) = higher::range(index) {\n+            if let Some(range) = higher::Range::hir(index) {\n                 // Ranged indexes, i.e., &x[n..m], &x[n..], &x[..n] and &x[..]\n                 if let ty::Array(_, s) = ty.kind() {\n                     let size: u128 = if let Some(size) = s.try_eval_usize(cx.tcx, cx.param_env) {"}, {"sha": "58646385def52412fad1a43941fd2df562029da7", "filename": "clippy_lints/src/infinite_iter.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b97d4c062b4d99139f14960daa7ce99d63625833/clippy_lints%2Fsrc%2Finfinite_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b97d4c062b4d99139f14960daa7ce99d63625833/clippy_lints%2Fsrc%2Finfinite_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Finfinite_iter.rs?ref=b97d4c062b4d99139f14960daa7ce99d63625833", "patch": "@@ -172,7 +172,7 @@ fn is_infinite(cx: &LateContext<'_>, expr: &Expr<'_>) -> Finiteness {\n                 Finite\n             }\n         },\n-        ExprKind::Struct(..) => higher::range(expr).map_or(false, |r| r.end.is_none()).into(),\n+        ExprKind::Struct(..) => higher::Range::hir(expr).map_or(false, |r| r.end.is_none()).into(),\n         _ => Finite,\n     }\n }"}, {"sha": "0594b73dd38378dd17f4821f639fb76ea8e4815a", "filename": "clippy_lints/src/let_if_seq.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b97d4c062b4d99139f14960daa7ce99d63625833/clippy_lints%2Fsrc%2Flet_if_seq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b97d4c062b4d99139f14960daa7ce99d63625833/clippy_lints%2Fsrc%2Flet_if_seq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flet_if_seq.rs?ref=b97d4c062b4d99139f14960daa7ce99d63625833", "patch": "@@ -64,7 +64,7 @@ impl<'tcx> LateLintPass<'tcx> for LetIfSeq {\n                 if let hir::StmtKind::Local(local) = stmt.kind;\n                 if let hir::PatKind::Binding(mode, canonical_id, ident, None) = local.pat.kind;\n                 if let hir::StmtKind::Expr(if_) = expr.kind;\n-                if let hir::ExprKind::If(cond, then, ref else_) = if_.kind;\n+                if let hir::ExprKind::If(hir::Expr { kind: hir::ExprKind::DropTemps(cond), ..}, then, else_) = if_.kind;\n                 let mut used_visitor = LocalUsedVisitor::new(cx, canonical_id);\n                 if !used_visitor.check_expr(cond);\n                 if let hir::ExprKind::Block(then, _) = then.kind;\n@@ -79,7 +79,7 @@ impl<'tcx> LateLintPass<'tcx> for LetIfSeq {\n                     );\n                     if has_interior_mutability { return; }\n \n-                    let (default_multi_stmts, default) = if let Some(else_) = *else_ {\n+                    let (default_multi_stmts, default) = if let Some(else_) = else_ {\n                         if let hir::ExprKind::Block(else_, _) = else_.kind {\n                             if let Some(default) = check_assign(cx, canonical_id, else_) {\n                                 (else_.stmts.len() > 1, default)"}, {"sha": "9f2bc3c7ebae7787c1b89a4a236b7c50b74deae5", "filename": "clippy_lints/src/loops/manual_flatten.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b97d4c062b4d99139f14960daa7ce99d63625833/clippy_lints%2Fsrc%2Floops%2Fmanual_flatten.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b97d4c062b4d99139f14960daa7ce99d63625833/clippy_lints%2Fsrc%2Floops%2Fmanual_flatten.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fmanual_flatten.rs?ref=b97d4c062b4d99139f14960daa7ce99d63625833", "patch": "@@ -1,11 +1,12 @@\n use super::utils::make_iterator_snippet;\n use super::MANUAL_FLATTEN;\n use clippy_utils::diagnostics::span_lint_and_then;\n+use clippy_utils::higher;\n use clippy_utils::{is_lang_ctor, path_to_local_id};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::LangItem::{OptionSome, ResultOk};\n-use rustc_hir::{Expr, ExprKind, MatchSource, Pat, PatKind, StmtKind};\n+use rustc_hir::{Expr, ExprKind, Pat, PatKind, StmtKind};\n use rustc_lint::LateContext;\n use rustc_middle::ty;\n use rustc_span::source_map::Span;\n@@ -36,14 +37,12 @@ pub(super) fn check<'tcx>(\n \n         if_chain! {\n             if let Some(inner_expr) = inner_expr;\n-            if let ExprKind::Match(\n-                match_expr, match_arms, MatchSource::IfLetDesugar{ contains_else_clause: false }\n-            ) = inner_expr.kind;\n+            if let Some(higher::IfLet { let_pat, let_expr, if_else: None, .. }) = higher::IfLet::hir(inner_expr);\n             // Ensure match_expr in `if let` statement is the same as the pat from the for-loop\n             if let PatKind::Binding(_, pat_hir_id, _, _) = pat.kind;\n-            if path_to_local_id(match_expr, pat_hir_id);\n+            if path_to_local_id(let_expr, pat_hir_id);\n             // Ensure the `if let` statement is for the `Some` variant of `Option` or the `Ok` variant of `Result`\n-            if let PatKind::TupleStruct(ref qpath, _, _) = match_arms[0].pat.kind;\n+            if let PatKind::TupleStruct(ref qpath, _, _) = let_pat.kind;\n             let some_ctor = is_lang_ctor(cx, qpath, OptionSome);\n             let ok_ctor = is_lang_ctor(cx, qpath, ResultOk);\n             if some_ctor || ok_ctor;\n@@ -55,7 +54,7 @@ pub(super) fn check<'tcx>(\n                 // Prepare the help message\n                 let mut applicability = Applicability::MaybeIncorrect;\n                 let arg_snippet = make_iterator_snippet(cx, arg, &mut applicability);\n-                let copied = match cx.typeck_results().expr_ty(match_expr).kind() {\n+                let copied = match cx.typeck_results().expr_ty(let_expr).kind() {\n                     ty::Ref(_, inner, _) => match inner.kind() {\n                         ty::Ref(..) => \".copied()\",\n                         _ => \"\""}, {"sha": "2525b14e1c5c3dbb8a8d461ba2a1e2a4877f0260", "filename": "clippy_lints/src/loops/manual_memcpy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b97d4c062b4d99139f14960daa7ce99d63625833/clippy_lints%2Fsrc%2Floops%2Fmanual_memcpy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b97d4c062b4d99139f14960daa7ce99d63625833/clippy_lints%2Fsrc%2Floops%2Fmanual_memcpy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fmanual_memcpy.rs?ref=b97d4c062b4d99139f14960daa7ce99d63625833", "patch": "@@ -27,7 +27,7 @@ pub(super) fn check<'tcx>(\n         start: Some(start),\n         end: Some(end),\n         limits,\n-    }) = higher::range(arg)\n+    }) = higher::Range::hir(arg)\n     {\n         // the var must be a single name\n         if let PatKind::Binding(_, canonical_id, _, _) = pat.kind {"}, {"sha": "bd9de5e08d736e877f013b15bcf878afe8666877", "filename": "clippy_lints/src/loops/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b97d4c062b4d99139f14960daa7ce99d63625833/clippy_lints%2Fsrc%2Floops%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b97d4c062b4d99139f14960daa7ce99d63625833/clippy_lints%2Fsrc%2Floops%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fmod.rs?ref=b97d4c062b4d99139f14960daa7ce99d63625833", "patch": "@@ -551,7 +551,7 @@ declare_lint_pass!(Loops => [\n impl<'tcx> LateLintPass<'tcx> for Loops {\n     #[allow(clippy::too_many_lines)]\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if let Some((pat, arg, body, span)) = higher::for_loop(expr) {\n+        if let Some(higher::ForLoop { pat, arg, body, span }) = higher::ForLoop::hir(expr) {\n             // we don't want to check expanded macros\n             // this check is not at the top of the function\n             // since higher::for_loop expressions are marked as expansions\n@@ -580,8 +580,8 @@ impl<'tcx> LateLintPass<'tcx> for Loops {\n \n         while_let_on_iterator::check(cx, expr);\n \n-        if let Some((cond, body)) = higher::while_loop(expr) {\n-            while_immutable_condition::check(cx, cond, body);\n+        if let Some(higher::While { if_cond, if_then, .. }) = higher::While::hir(&expr) {\n+            while_immutable_condition::check(cx, if_cond, if_then);\n         }\n \n         needless_collect::check(expr, cx);"}, {"sha": "344dc5074d369ff5e47e2751fbb46c79019963aa", "filename": "clippy_lints/src/loops/mut_range_bound.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b97d4c062b4d99139f14960daa7ce99d63625833/clippy_lints%2Fsrc%2Floops%2Fmut_range_bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b97d4c062b4d99139f14960daa7ce99d63625833/clippy_lints%2Fsrc%2Floops%2Fmut_range_bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fmut_range_bound.rs?ref=b97d4c062b4d99139f14960daa7ce99d63625833", "patch": "@@ -14,7 +14,7 @@ pub(super) fn check(cx: &LateContext<'_>, arg: &Expr<'_>, body: &Expr<'_>) {\n         start: Some(start),\n         end: Some(end),\n         ..\n-    }) = higher::range(arg)\n+    }) = higher::Range::hir(arg)\n     {\n         let mut_ids = vec![check_for_mutability(cx, start), check_for_mutability(cx, end)];\n         if mut_ids[0].is_some() || mut_ids[1].is_some() {"}, {"sha": "3f77e7af927ad67c79dcf3ec92dda54335a048b9", "filename": "clippy_lints/src/loops/needless_range_loop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b97d4c062b4d99139f14960daa7ce99d63625833/clippy_lints%2Fsrc%2Floops%2Fneedless_range_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b97d4c062b4d99139f14960daa7ce99d63625833/clippy_lints%2Fsrc%2Floops%2Fneedless_range_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fneedless_range_loop.rs?ref=b97d4c062b4d99139f14960daa7ce99d63625833", "patch": "@@ -34,7 +34,7 @@ pub(super) fn check<'tcx>(\n         start: Some(start),\n         ref end,\n         limits,\n-    }) = higher::range(arg)\n+    }) = higher::Range::hir(arg)\n     {\n         // the var must be a single name\n         if let PatKind::Binding(_, canonical_id, ident, _) = pat.kind {"}, {"sha": "2c46971d5f741358eba4646be0997efb601c0aa5", "filename": "clippy_lints/src/loops/never_loop.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b97d4c062b4d99139f14960daa7ce99d63625833/clippy_lints%2Fsrc%2Floops%2Fnever_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b97d4c062b4d99139f14960daa7ce99d63625833/clippy_lints%2Fsrc%2Floops%2Fnever_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fnever_loop.rs?ref=b97d4c062b4d99139f14960daa7ce99d63625833", "patch": "@@ -1,7 +1,7 @@\n use super::utils::make_iterator_snippet;\n use super::NEVER_LOOP;\n use clippy_utils::diagnostics::span_lint_and_then;\n-use clippy_utils::higher;\n+use clippy_utils::higher::ForLoop;\n use clippy_utils::source::snippet;\n use rustc_errors::Applicability;\n use rustc_hir::{Block, Expr, ExprKind, HirId, InlineAsmOperand, LoopSource, Node, Pat, Stmt, StmtKind};\n@@ -16,7 +16,7 @@ pub(super) fn check(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n                     if_chain! {\n                         if let LoopSource::ForLoop = source;\n                         if let Some((_, Node::Expr(parent_match))) = cx.tcx.hir().parent_iter(expr.hir_id).nth(1);\n-                        if let Some((pat, iterator, _, for_span)) = higher::for_loop(parent_match);\n+                        if let Some(ForLoop { arg: iterator, pat, span: for_span, .. }) = ForLoop::hir(parent_match);\n                         then {\n                             // Suggests using an `if let` instead. This is `Unspecified` because the\n                             // loop may (probably) contain `break` statements which would be invalid\n@@ -111,6 +111,7 @@ fn never_loop_expr(expr: &Expr<'_>, main_loop_id: HirId) -> NeverLoopResult {\n         | ExprKind::Unary(_, e)\n         | ExprKind::Cast(e, _)\n         | ExprKind::Type(e, _)\n+        | ExprKind::Let(_, e, _)\n         | ExprKind::Field(e, _)\n         | ExprKind::AddrOf(_, _, e)\n         | ExprKind::Struct(_, _, Some(e))\n@@ -128,7 +129,7 @@ fn never_loop_expr(expr: &Expr<'_>, main_loop_id: HirId) -> NeverLoopResult {\n             // Break can come from the inner loop so remove them.\n             absorb_break(&never_loop_block(b, main_loop_id))\n         },\n-        ExprKind::If(e, e2, ref e3) => {\n+        ExprKind::If(e, e2, e3) => {\n             let e1 = never_loop_expr(e, main_loop_id);\n             let e2 = never_loop_expr(e2, main_loop_id);\n             let e3 = e3\n@@ -156,7 +157,7 @@ fn never_loop_expr(expr: &Expr<'_>, main_loop_id: HirId) -> NeverLoopResult {\n                 NeverLoopResult::AlwaysBreak\n             }\n         },\n-        ExprKind::Break(_, ref e) | ExprKind::Ret(ref e) => e.as_ref().map_or(NeverLoopResult::AlwaysBreak, |e| {\n+        ExprKind::Break(_, e) | ExprKind::Ret(e) => e.as_ref().map_or(NeverLoopResult::AlwaysBreak, |e| {\n             combine_seq(never_loop_expr(e, main_loop_id), NeverLoopResult::AlwaysBreak)\n         }),\n         ExprKind::InlineAsm(asm) => asm"}, {"sha": "6be410ca8e3cbafd5489cbb962f4eb0b73e37b82", "filename": "clippy_lints/src/loops/while_let_loop.rs", "status": "modified", "additions": 56, "deletions": 42, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/b97d4c062b4d99139f14960daa7ce99d63625833/clippy_lints%2Fsrc%2Floops%2Fwhile_let_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b97d4c062b4d99139f14960daa7ce99d63625833/clippy_lints%2Fsrc%2Floops%2Fwhile_let_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fwhile_let_loop.rs?ref=b97d4c062b4d99139f14960daa7ce99d63625833", "patch": "@@ -1,8 +1,9 @@\n use super::WHILE_LET_LOOP;\n use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::higher;\n use clippy_utils::source::snippet_with_applicability;\n use rustc_errors::Applicability;\n-use rustc_hir::{Block, Expr, ExprKind, MatchSource, StmtKind};\n+use rustc_hir::{Block, Expr, ExprKind, MatchSource, Pat, StmtKind};\n use rustc_lint::{LateContext, LintContext};\n use rustc_middle::lint::in_external_macro;\n \n@@ -11,41 +12,25 @@ pub(super) fn check(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, loop_block: &'\n     let inner_stmt_expr = extract_expr_from_first_stmt(loop_block);\n     // or extract the first expression (if any) from the block\n     if let Some(inner) = inner_stmt_expr.or_else(|| extract_first_expr(loop_block)) {\n-        if let ExprKind::Match(matchexpr, arms, ref source) = inner.kind {\n-            // ensure \"if let\" compatible match structure\n-            match *source {\n-                MatchSource::Normal | MatchSource::IfLetDesugar { .. } => {\n-                    if arms.len() == 2\n-                        && arms[0].guard.is_none()\n-                        && arms[1].guard.is_none()\n-                        && is_simple_break_expr(arms[1].body)\n-                    {\n-                        if in_external_macro(cx.sess(), expr.span) {\n-                            return;\n-                        }\n+        if let Some(higher::IfLet {\n+            let_pat,\n+            let_expr,\n+            if_else: Some(if_else),\n+            ..\n+        }) = higher::IfLet::hir(inner)\n+        {\n+            if is_simple_break_expr(if_else) {\n+                could_be_while_let(cx, expr, let_pat, let_expr);\n+            }\n+        }\n \n-                        // NOTE: we used to build a body here instead of using\n-                        // ellipsis, this was removed because:\n-                        // 1) it was ugly with big bodies;\n-                        // 2) it was not indented properly;\n-                        // 3) it wasn\u2019t very smart (see #675).\n-                        let mut applicability = Applicability::HasPlaceholders;\n-                        span_lint_and_sugg(\n-                            cx,\n-                            WHILE_LET_LOOP,\n-                            expr.span,\n-                            \"this loop could be written as a `while let` loop\",\n-                            \"try\",\n-                            format!(\n-                                \"while let {} = {} {{ .. }}\",\n-                                snippet_with_applicability(cx, arms[0].pat.span, \"..\", &mut applicability),\n-                                snippet_with_applicability(cx, matchexpr.span, \"..\", &mut applicability),\n-                            ),\n-                            applicability,\n-                        );\n-                    }\n-                },\n-                _ => (),\n+        if let ExprKind::Match(ref matchexpr, ref arms, MatchSource::Normal) = inner.kind {\n+            if arms.len() == 2\n+                && arms[0].guard.is_none()\n+                && arms[1].guard.is_none()\n+                && is_simple_break_expr(&arms[1].body)\n+            {\n+                could_be_while_let(cx, expr, &arms[0].pat, matchexpr);\n             }\n         }\n     }\n@@ -54,14 +39,12 @@ pub(super) fn check(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, loop_block: &'\n /// If a block begins with a statement (possibly a `let` binding) and has an\n /// expression, return it.\n fn extract_expr_from_first_stmt<'tcx>(block: &Block<'tcx>) -> Option<&'tcx Expr<'tcx>> {\n-    if block.stmts.is_empty() {\n-        return None;\n-    }\n-    if let StmtKind::Local(local) = block.stmts[0].kind {\n-        local.init //.map(|expr| expr)\n-    } else {\n-        None\n+    if let Some(first_stmt) = block.stmts.get(0) {\n+        if let StmtKind::Local(local) = first_stmt.kind {\n+            return local.init;\n+        }\n     }\n+    None\n }\n \n /// If a block begins with an expression (with or without semicolon), return it.\n@@ -86,3 +69,34 @@ fn is_simple_break_expr(expr: &Expr<'_>) -> bool {\n         _ => false,\n     }\n }\n+\n+fn could_be_while_let<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx Expr<'_>,\n+    let_pat: &'tcx Pat<'_>,\n+    let_expr: &'tcx Expr<'_>,\n+) {\n+    if in_external_macro(cx.sess(), expr.span) {\n+        return;\n+    }\n+\n+    // NOTE: we used to build a body here instead of using\n+    // ellipsis, this was removed because:\n+    // 1) it was ugly with big bodies;\n+    // 2) it was not indented properly;\n+    // 3) it wasn\u2019t very smart (see #675).\n+    let mut applicability = Applicability::HasPlaceholders;\n+    span_lint_and_sugg(\n+        cx,\n+        WHILE_LET_LOOP,\n+        expr.span,\n+        \"this loop could be written as a `while let` loop\",\n+        \"try\",\n+        format!(\n+            \"while let {} = {} {{ .. }}\",\n+            snippet_with_applicability(cx, let_pat.span, \"..\", &mut applicability),\n+            snippet_with_applicability(cx, let_expr.span, \"..\", &mut applicability),\n+        ),\n+        applicability,\n+    );\n+}"}, {"sha": "0757d329125cb12a1680ad90feef70e29c64e9fb", "filename": "clippy_lints/src/loops/while_let_on_iterator.rs", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/b97d4c062b4d99139f14960daa7ce99d63625833/clippy_lints%2Fsrc%2Floops%2Fwhile_let_on_iterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b97d4c062b4d99139f14960daa7ce99d63625833/clippy_lints%2Fsrc%2Floops%2Fwhile_let_on_iterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fwhile_let_on_iterator.rs?ref=b97d4c062b4d99139f14960daa7ce99d63625833", "patch": "@@ -1,33 +1,38 @@\n use super::WHILE_LET_ON_ITERATOR;\n use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::higher;\n use clippy_utils::source::snippet_with_applicability;\n use clippy_utils::{\n     get_enclosing_loop_or_closure, is_refutable, is_trait_method, match_def_path, paths, visitors::is_res_used,\n };\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::intravisit::{walk_expr, ErasedMap, NestedVisitorMap, Visitor};\n-use rustc_hir::{def::Res, Expr, ExprKind, HirId, Local, MatchSource, Mutability, Node, PatKind, QPath, UnOp};\n+use rustc_hir::{def::Res, Expr, ExprKind, HirId, Local, Mutability, PatKind, QPath, UnOp};\n use rustc_lint::LateContext;\n use rustc_span::{symbol::sym, Span, Symbol};\n \n pub(super) fn check(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n     let (scrutinee_expr, iter_expr, some_pat, loop_expr) = if_chain! {\n-        if let ExprKind::Match(scrutinee_expr, [arm, _], MatchSource::WhileLetDesugar) = expr.kind;\n+        if let Some(higher::WhileLet {\n+            if_then,\n+            let_pat,\n+            let_expr,\n+            ..\n+        }) = higher::WhileLet::hir(expr);\n         // check for `Some(..)` pattern\n-        if let PatKind::TupleStruct(QPath::Resolved(None, pat_path), some_pat, _) = arm.pat.kind;\n+        if let PatKind::TupleStruct(QPath::Resolved(None, pat_path), some_pat, _) = let_pat.kind;\n         if let Res::Def(_, pat_did) = pat_path.res;\n         if match_def_path(cx, pat_did, &paths::OPTION_SOME);\n         // check for call to `Iterator::next`\n-        if let ExprKind::MethodCall(method_name, _, [iter_expr], _) = scrutinee_expr.kind;\n+        if let ExprKind::MethodCall(method_name, _, [iter_expr], _) = let_expr.kind;\n         if method_name.ident.name == sym::next;\n-        if is_trait_method(cx, scrutinee_expr, sym::Iterator);\n-        if let Some(iter_expr) = try_parse_iter_expr(cx, iter_expr);\n+        if is_trait_method(cx, let_expr, sym::Iterator);\n+        if let Some(iter_expr_struct) = try_parse_iter_expr(cx, iter_expr);\n         // get the loop containing the match expression\n-        if let Some((_, Node::Expr(loop_expr))) = cx.tcx.hir().parent_iter(expr.hir_id).nth(1);\n-        if !uses_iter(cx, &iter_expr, arm.body);\n+        if !uses_iter(cx, &iter_expr_struct, if_then);\n         then {\n-            (scrutinee_expr, iter_expr, some_pat, loop_expr)\n+            (let_expr, iter_expr_struct, some_pat, expr)\n         } else {\n             return;\n         }\n@@ -81,6 +86,7 @@ struct IterExpr {\n     /// The path being used.\n     path: Res,\n }\n+\n /// Parses any expression to find out which field of which variable is used. Will return `None` if\n /// the expression might have side effects.\n fn try_parse_iter_expr(cx: &LateContext<'_>, mut e: &Expr<'_>) -> Option<IterExpr> {\n@@ -285,6 +291,7 @@ fn needs_mutable_borrow(cx: &LateContext<'tcx>, iter_expr: &IterExpr, loop_expr:\n     }\n     impl Visitor<'tcx> for NestedLoopVisitor<'a, 'b, 'tcx> {\n         type Map = ErasedMap<'tcx>;\n+\n         fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n             NestedVisitorMap::None\n         }"}, {"sha": "53d97f775435a8dbb1c8e5920c28e8a55f3d2a6a", "filename": "clippy_lints/src/manual_map.rs", "status": "modified", "additions": 161, "deletions": 140, "changes": 301, "blob_url": "https://github.com/rust-lang/rust/blob/b97d4c062b4d99139f14960daa7ce99d63625833/clippy_lints%2Fsrc%2Fmanual_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b97d4c062b4d99139f14960daa7ce99d63625833/clippy_lints%2Fsrc%2Fmanual_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmanual_map.rs?ref=b97d4c062b4d99139f14960daa7ce99d63625833", "patch": "@@ -1,5 +1,6 @@\n use crate::{map_unit_fn::OPTION_MAP_UNIT_FN, matches::MATCH_AS_REF};\n use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::higher;\n use clippy_utils::source::{snippet_with_applicability, snippet_with_context};\n use clippy_utils::ty::{is_type_diagnostic_item, peel_mid_ty_refs_is_mutable};\n use clippy_utils::{\n@@ -9,7 +10,7 @@ use clippy_utils::{\n use rustc_ast::util::parser::PREC_POSTFIX;\n use rustc_errors::Applicability;\n use rustc_hir::LangItem::{OptionNone, OptionSome};\n-use rustc_hir::{Arm, BindingAnnotation, Block, Expr, ExprKind, HirId, MatchSource, Mutability, Pat, PatKind};\n+use rustc_hir::{Arm, BindingAnnotation, Block, Expr, ExprKind, HirId, Mutability, Pat, PatKind};\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::lint::in_external_macro;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n@@ -43,163 +44,176 @@ declare_lint_pass!(ManualMap => [MANUAL_MAP]);\n impl LateLintPass<'_> for ManualMap {\n     #[allow(clippy::too_many_lines)]\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if let ExprKind::Match(\n-            scrutinee,\n-            [arm1 @ Arm { guard: None, .. }, arm2 @ Arm { guard: None, .. }],\n-            match_kind,\n-        ) = expr.kind\n+        if let Some(higher::IfLet {\n+            let_pat,\n+            let_expr,\n+            if_then,\n+            if_else: Some(if_else),\n+        }) = higher::IfLet::hir(expr)\n         {\n-            if in_external_macro(cx.sess(), expr.span) || in_constant(cx, expr.hir_id) {\n-                return;\n-            }\n+            manage_lint(cx, expr, (&let_pat.kind, if_then), (&PatKind::Wild, if_else), let_expr);\n+        }\n \n-            let (scrutinee_ty, ty_ref_count, ty_mutability) =\n-                peel_mid_ty_refs_is_mutable(cx.typeck_results().expr_ty(scrutinee));\n-            if !(is_type_diagnostic_item(cx, scrutinee_ty, sym::option_type)\n-                && is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(expr), sym::option_type))\n-            {\n-                return;\n-            }\n+        if let ExprKind::Match(scrutinee, [then @ Arm { guard: None, .. }, r#else @ Arm { guard: None, .. }], _) =\n+            expr.kind\n+        {\n+            manage_lint(\n+                cx,\n+                expr,\n+                (&then.pat.kind, then.body),\n+                (&r#else.pat.kind, r#else.body),\n+                scrutinee,\n+            );\n+        }\n+    }\n+}\n \n-            let expr_ctxt = expr.span.ctxt();\n-            let (some_expr, some_pat, pat_ref_count, is_wild_none) = match (\n-                try_parse_pattern(cx, arm1.pat, expr_ctxt),\n-                try_parse_pattern(cx, arm2.pat, expr_ctxt),\n-            ) {\n-                (Some(OptionPat::Wild), Some(OptionPat::Some { pattern, ref_count }))\n-                    if is_none_expr(cx, arm1.body) =>\n-                {\n-                    (arm2.body, pattern, ref_count, true)\n-                },\n-                (Some(OptionPat::None), Some(OptionPat::Some { pattern, ref_count }))\n-                    if is_none_expr(cx, arm1.body) =>\n-                {\n-                    (arm2.body, pattern, ref_count, false)\n-                },\n-                (Some(OptionPat::Some { pattern, ref_count }), Some(OptionPat::Wild))\n-                    if is_none_expr(cx, arm2.body) =>\n-                {\n-                    (arm1.body, pattern, ref_count, true)\n-                },\n-                (Some(OptionPat::Some { pattern, ref_count }), Some(OptionPat::None))\n-                    if is_none_expr(cx, arm2.body) =>\n-                {\n-                    (arm1.body, pattern, ref_count, false)\n-                },\n-                _ => return,\n-            };\n+fn manage_lint<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    expr: &'tcx Expr<'_>,\n+    then: (&'tcx PatKind<'_>, &'tcx Expr<'_>),\n+    r#else: (&'tcx PatKind<'_>, &'tcx Expr<'_>),\n+    scrut: &'tcx Expr<'_>,\n+) {\n+    if in_external_macro(cx.sess(), expr.span) || in_constant(cx, expr.hir_id) {\n+        return;\n+    }\n \n-            // Top level or patterns aren't allowed in closures.\n-            if matches!(some_pat.kind, PatKind::Or(_)) {\n-                return;\n-            }\n+    let (scrutinee_ty, ty_ref_count, ty_mutability) = peel_mid_ty_refs_is_mutable(cx.typeck_results().expr_ty(scrut));\n+    if !(is_type_diagnostic_item(cx, scrutinee_ty, sym::option_type)\n+        && is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(expr), sym::option_type))\n+    {\n+        return;\n+    }\n \n-            let some_expr = match get_some_expr(cx, some_expr, expr_ctxt) {\n-                Some(expr) => expr,\n-                None => return,\n-            };\n+    let (then_pat, then_expr) = then;\n+    let (else_pat, else_expr) = r#else;\n \n-            // These two lints will go back and forth with each other.\n-            if cx.typeck_results().expr_ty(some_expr) == cx.tcx.types.unit\n-                && !is_lint_allowed(cx, OPTION_MAP_UNIT_FN, expr.hir_id)\n-            {\n-                return;\n-            }\n+    let expr_ctxt = expr.span.ctxt();\n+    let (some_expr, some_pat, pat_ref_count, is_wild_none) = match (\n+        try_parse_pattern(cx, then_pat, expr_ctxt),\n+        try_parse_pattern(cx, else_pat, expr_ctxt),\n+    ) {\n+        (Some(OptionPat::Wild), Some(OptionPat::Some { pattern, ref_count })) if is_none_expr(cx, then_expr) => {\n+            (else_expr, pattern, ref_count, true)\n+        },\n+        (Some(OptionPat::None), Some(OptionPat::Some { pattern, ref_count })) if is_none_expr(cx, then_expr) => {\n+            (else_expr, pattern, ref_count, false)\n+        },\n+        (Some(OptionPat::Some { pattern, ref_count }), Some(OptionPat::Wild)) if is_none_expr(cx, else_expr) => {\n+            (then_expr, pattern, ref_count, true)\n+        },\n+        (Some(OptionPat::Some { pattern, ref_count }), Some(OptionPat::None)) if is_none_expr(cx, else_expr) => {\n+            (then_expr, pattern, ref_count, false)\n+        },\n+        _ => return,\n+    };\n \n-            // `map` won't perform any adjustments.\n-            if !cx.typeck_results().expr_adjustments(some_expr).is_empty() {\n-                return;\n-            }\n+    // Top level or patterns aren't allowed in closures.\n+    if matches!(some_pat.kind, PatKind::Or(_)) {\n+        return;\n+    }\n \n-            if !can_move_expr_to_closure(cx, some_expr) {\n-                return;\n-            }\n+    let some_expr = match get_some_expr(cx, some_expr, expr_ctxt) {\n+        Some(expr) => expr,\n+        None => return,\n+    };\n \n-            // Determine which binding mode to use.\n-            let explicit_ref = some_pat.contains_explicit_ref_binding();\n-            let binding_ref = explicit_ref.or_else(|| (ty_ref_count != pat_ref_count).then(|| ty_mutability));\n+    if cx.typeck_results().expr_ty(some_expr) == cx.tcx.types.unit && !is_lint_allowed(cx, OPTION_MAP_UNIT_FN, expr.hir_id) {\n+        return;\n+    }\n \n-            let as_ref_str = match binding_ref {\n-                Some(Mutability::Mut) => \".as_mut()\",\n-                Some(Mutability::Not) => \".as_ref()\",\n-                None => \"\",\n-            };\n+    // `map` won't perform any adjustments.\n+    if !cx.typeck_results().expr_adjustments(some_expr).is_empty() {\n+        return;\n+    }\n \n-            let mut app = Applicability::MachineApplicable;\n+    if !can_move_expr_to_closure(cx, some_expr) {\n+        return;\n+    }\n \n-            // Remove address-of expressions from the scrutinee. Either `as_ref` will be called, or\n-            // it's being passed by value.\n-            let scrutinee = peel_hir_expr_refs(scrutinee).0;\n-            let (scrutinee_str, _) = snippet_with_context(cx, scrutinee.span, expr_ctxt, \"..\", &mut app);\n-            let scrutinee_str =\n-                if scrutinee.span.ctxt() == expr.span.ctxt() && scrutinee.precedence().order() < PREC_POSTFIX {\n-                    format!(\"({})\", scrutinee_str)\n-                } else {\n-                    scrutinee_str.into()\n-                };\n+    // Determine which binding mode to use.\n+    let explicit_ref = some_pat.contains_explicit_ref_binding();\n+    let binding_ref = explicit_ref.or_else(|| (ty_ref_count != pat_ref_count).then(|| ty_mutability));\n+\n+    let as_ref_str = match binding_ref {\n+        Some(Mutability::Mut) => \".as_mut()\",\n+        Some(Mutability::Not) => \".as_ref()\",\n+        None => \"\",\n+    };\n+\n+    let mut app = Applicability::MachineApplicable;\n \n-            let body_str = if let PatKind::Binding(annotation, id, some_binding, None) = some_pat.kind {\n-                match can_pass_as_func(cx, id, some_expr) {\n-                    Some(func) if func.span.ctxt() == some_expr.span.ctxt() => {\n-                        snippet_with_applicability(cx, func.span, \"..\", &mut app).into_owned()\n-                    },\n-                    _ => {\n-                        if path_to_local_id(some_expr, id)\n-                            && !is_lint_allowed(cx, MATCH_AS_REF, expr.hir_id)\n-                            && binding_ref.is_some()\n-                        {\n-                            return;\n-                        }\n+    // Remove address-of expressions from the scrutinee. Either `as_ref` will be called, or\n+    // it's being passed by value.\n+    let scrutinee = peel_hir_expr_refs(scrut).0;\n+    let (scrutinee_str, _) = snippet_with_context(cx, scrutinee.span, expr_ctxt, \"..\", &mut app);\n+    let scrutinee_str = if scrutinee.span.ctxt() == expr.span.ctxt() && scrutinee.precedence().order() < PREC_POSTFIX {\n+        format!(\"({})\", scrutinee_str)\n+    } else {\n+        scrutinee_str.into()\n+    };\n \n-                        // `ref` and `ref mut` annotations were handled earlier.\n-                        let annotation = if matches!(annotation, BindingAnnotation::Mutable) {\n-                            \"mut \"\n-                        } else {\n-                            \"\"\n-                        };\n-                        format!(\n-                            \"|{}{}| {}\",\n-                            annotation,\n-                            some_binding,\n-                            snippet_with_context(cx, some_expr.span, expr_ctxt, \"..\", &mut app).0\n-                        )\n-                    },\n+    let body_str = if let PatKind::Binding(annotation, id, some_binding, None) = some_pat.kind {\n+        match can_pass_as_func(cx, id, some_expr) {\n+            Some(func) if func.span.ctxt() == some_expr.span.ctxt() => {\n+                snippet_with_applicability(cx, func.span, \"..\", &mut app).into_owned()\n+            },\n+            _ => {\n+                if path_to_local_id(some_expr, id)\n+                    && !is_lint_allowed(cx, MATCH_AS_REF, expr.hir_id)\n+                    && binding_ref.is_some()\n+                {\n+                    return;\n                 }\n-            } else if !is_wild_none && explicit_ref.is_none() {\n-                // TODO: handle explicit reference annotations.\n+\n+                // `ref` and `ref mut` annotations were handled earlier.\n+                let annotation = if matches!(annotation, BindingAnnotation::Mutable) {\n+                    \"mut \"\n+                } else {\n+                    \"\"\n+                };\n                 format!(\n-                    \"|{}| {}\",\n-                    snippet_with_context(cx, some_pat.span, expr_ctxt, \"..\", &mut app).0,\n+                    \"|{}{}| {}\",\n+                    annotation,\n+                    some_binding,\n                     snippet_with_context(cx, some_expr.span, expr_ctxt, \"..\", &mut app).0\n                 )\n-            } else {\n-                // Refutable bindings and mixed reference annotations can't be handled by `map`.\n-                return;\n-            };\n-\n-            span_lint_and_sugg(\n-                cx,\n-                MANUAL_MAP,\n-                expr.span,\n-                \"manual implementation of `Option::map`\",\n-                \"try this\",\n-                if matches!(match_kind, MatchSource::IfLetDesugar { .. }) && is_else_clause(cx.tcx, expr) {\n-                    format!(\"{{ {}{}.map({}) }}\", scrutinee_str, as_ref_str, body_str)\n-                } else {\n-                    format!(\"{}{}.map({})\", scrutinee_str, as_ref_str, body_str)\n-                },\n-                app,\n-            );\n+            },\n         }\n-    }\n+    } else if !is_wild_none && explicit_ref.is_none() {\n+        // TODO: handle explicit reference annotations.\n+        format!(\n+            \"|{}| {}\",\n+            snippet_with_context(cx, some_pat.span, expr_ctxt, \"..\", &mut app).0,\n+            snippet_with_context(cx, some_expr.span, expr_ctxt, \"..\", &mut app).0\n+        )\n+    } else {\n+        // Refutable bindings and mixed reference annotations can't be handled by `map`.\n+        return;\n+    };\n+\n+    span_lint_and_sugg(\n+        cx,\n+        MANUAL_MAP,\n+        expr.span,\n+        \"manual implementation of `Option::map`\",\n+        \"try this\",\n+        if is_else_clause(cx.tcx, expr) {\n+            format!(\"{{ {}{}.map({}) }}\", scrutinee_str, as_ref_str, body_str)\n+        } else {\n+            format!(\"{}{}.map({})\", scrutinee_str, as_ref_str, body_str)\n+        },\n+        app,\n+    );\n }\n \n // Checks whether the expression could be passed as a function, or whether a closure is needed.\n // Returns the function to be passed to `map` if it exists.\n fn can_pass_as_func(cx: &LateContext<'tcx>, binding: HirId, expr: &'tcx Expr<'_>) -> Option<&'tcx Expr<'tcx>> {\n     match expr.kind {\n         ExprKind::Call(func, [arg])\n-            if path_to_local_id(arg, binding) && cx.typeck_results().expr_adjustments(arg).is_empty() =>\n+            if path_to_local_id (arg, binding) && cx.typeck_results().expr_adjustments(arg).is_empty() =>\n         {\n             Some(func)\n         },\n@@ -221,21 +235,28 @@ enum OptionPat<'a> {\n \n // Try to parse into a recognized `Option` pattern.\n // i.e. `_`, `None`, `Some(..)`, or a reference to any of those.\n-fn try_parse_pattern(cx: &LateContext<'tcx>, pat: &'tcx Pat<'_>, ctxt: SyntaxContext) -> Option<OptionPat<'tcx>> {\n-    fn f(cx: &LateContext<'tcx>, pat: &'tcx Pat<'_>, ref_count: usize, ctxt: SyntaxContext) -> Option<OptionPat<'tcx>> {\n-        match pat.kind {\n+fn try_parse_pattern(\n+    cx: &LateContext<'tcx>,\n+    pat_kind: &'tcx PatKind<'_>,\n+    ctxt: SyntaxContext,\n+) -> Option<OptionPat<'tcx>> {\n+    fn f(\n+        cx: &LateContext<'tcx>,\n+        pat_kind: &'tcx PatKind<'_>,\n+        ref_count: usize,\n+        ctxt: SyntaxContext,\n+    ) -> Option<OptionPat<'tcx>> {\n+        match pat_kind {\n             PatKind::Wild => Some(OptionPat::Wild),\n-            PatKind::Ref(pat, _) => f(cx, pat, ref_count + 1, ctxt),\n+            PatKind::Ref(ref_pat, _) => f(cx, &ref_pat.kind, ref_count + 1, ctxt),\n             PatKind::Path(ref qpath) if is_lang_ctor(cx, qpath, OptionNone) => Some(OptionPat::None),\n-            PatKind::TupleStruct(ref qpath, [pattern], _)\n-                if is_lang_ctor(cx, qpath, OptionSome) && pat.span.ctxt() == ctxt =>\n-            {\n+            PatKind::TupleStruct(ref qpath, [pattern], _) if is_lang_ctor(cx, qpath, OptionSome) => {\n                 Some(OptionPat::Some { pattern, ref_count })\n             },\n             _ => None,\n         }\n     }\n-    f(cx, pat, 0, ctxt)\n+    f(cx, pat_kind, 0, ctxt)\n }\n \n // Checks for an expression wrapped by the `Some` constructor. Returns the contained expression."}, {"sha": "4e040508b6bfbdc396c233c1df3222add7802ca1", "filename": "clippy_lints/src/manual_strip.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b97d4c062b4d99139f14960daa7ce99d63625833/clippy_lints%2Fsrc%2Fmanual_strip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b97d4c062b4d99139f14960daa7ce99d63625833/clippy_lints%2Fsrc%2Fmanual_strip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmanual_strip.rs?ref=b97d4c062b4d99139f14960daa7ce99d63625833", "patch": "@@ -73,7 +73,7 @@ impl<'tcx> LateLintPass<'tcx> for ManualStrip {\n         }\n \n         if_chain! {\n-            if let ExprKind::If(cond, then, _) = &expr.kind;\n+            if let Some(higher::If { cond, then, .. }) = higher::If::hir(expr);\n             if let ExprKind::MethodCall(_, _, [target_arg, pattern], _) = cond.kind;\n             if let Some(method_def_id) = cx.typeck_results().type_dependent_def_id(cond.hir_id);\n             if let ExprKind::Path(target_path) = &target_arg.kind;\n@@ -212,7 +212,7 @@ fn find_stripping<'tcx>(\n                 if is_ref_str(self.cx, ex);\n                 let unref = peel_ref(ex);\n                 if let ExprKind::Index(indexed, index) = &unref.kind;\n-                if let Some(higher::Range { start, end, .. }) = higher::range(index);\n+                if let Some(higher::Range { start, end, .. }) = higher::Range::hir(index);\n                 if let ExprKind::Path(path) = &indexed.kind;\n                 if self.cx.qpath_res(path, ex.hir_id) == self.target;\n                 then {"}, {"sha": "a183d0c66e8ced59d9da785a2e9b2d18ef4545b2", "filename": "clippy_lints/src/matches.rs", "status": "modified", "additions": 169, "deletions": 96, "changes": 265, "blob_url": "https://github.com/rust-lang/rust/blob/b97d4c062b4d99139f14960daa7ce99d63625833/clippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b97d4c062b4d99139f14960daa7ce99d63625833/clippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches.rs?ref=b97d4c062b4d99139f14960daa7ce99d63625833", "patch": "@@ -2,6 +2,7 @@ use clippy_utils::consts::{constant, miri_to_const, Constant};\n use clippy_utils::diagnostics::{\n     multispan_sugg, span_lint_and_help, span_lint_and_note, span_lint_and_sugg, span_lint_and_then,\n };\n+use clippy_utils::higher;\n use clippy_utils::source::{expr_block, indent_of, snippet, snippet_block, snippet_opt, snippet_with_applicability};\n use clippy_utils::sugg::Sugg;\n use clippy_utils::ty::{implements_trait, is_type_diagnostic_item, match_type, peel_mid_ty_refs};\n@@ -12,8 +13,10 @@ use clippy_utils::{\n     strip_pat_refs,\n };\n use clippy_utils::{paths, search_same, SpanlessEq, SpanlessHash};\n+use core::array;\n+use core::iter::{once, ExactSizeIterator};\n use if_chain::if_chain;\n-use rustc_ast::ast::LitKind;\n+use rustc_ast::ast::{Attribute, LitKind};\n use rustc_errors::Applicability;\n use rustc_hir::def::{CtorKind, DefKind, Res};\n use rustc_hir::LangItem::{OptionNone, OptionSome};\n@@ -628,8 +631,11 @@ impl<'tcx> LateLintPass<'tcx> for Matches {\n                 check_match_single_binding(cx, ex, arms, expr);\n             }\n         }\n-        if let ExprKind::Match(ex, arms, _) = expr.kind {\n-            check_match_ref_pats(cx, ex, arms, expr);\n+        if let ExprKind::Match(ref ex, ref arms, _) = expr.kind {\n+            check_match_ref_pats(cx, ex, arms.iter().map(|el| el.pat), expr);\n+        }\n+        if let Some(higher::IfLet { let_pat, let_expr, .. }) = higher::IfLet::hir(expr) {\n+            check_match_ref_pats(cx, let_expr, once(let_pat), expr);\n         }\n     }\n \n@@ -1179,39 +1185,40 @@ fn is_panic_block(block: &Block<'_>) -> bool {\n     }\n }\n \n-fn check_match_ref_pats(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>], expr: &Expr<'_>) {\n-    if has_only_ref_pats(arms) {\n-        let mut suggs = Vec::with_capacity(arms.len() + 1);\n-        let (title, msg) = if let ExprKind::AddrOf(BorrowKind::Ref, Mutability::Not, inner) = ex.kind {\n-            let span = ex.span.source_callsite();\n-            suggs.push((span, Sugg::hir_with_macro_callsite(cx, inner, \"..\").to_string()));\n-            (\n-                \"you don't need to add `&` to both the expression and the patterns\",\n-                \"try\",\n-            )\n-        } else {\n-            let span = ex.span.source_callsite();\n-            suggs.push((span, Sugg::hir_with_macro_callsite(cx, ex, \"..\").deref().to_string()));\n-            (\n-                \"you don't need to add `&` to all patterns\",\n-                \"instead of prefixing all patterns with `&`, you can dereference the expression\",\n-            )\n-        };\n-\n-        suggs.extend(arms.iter().filter_map(|a| {\n-            if let PatKind::Ref(refp, _) = a.pat.kind {\n-                Some((a.pat.span, snippet(cx, refp.span, \"..\").to_string()))\n-            } else {\n-                None\n-            }\n-        }));\n+fn check_match_ref_pats<'a, 'b, I>(cx: &LateContext<'_>, ex: &Expr<'_>, pats: I, expr: &Expr<'_>)\n+where\n+    'b: 'a,\n+    I: Clone + Iterator<Item = &'a Pat<'b>>,\n+{\n+    if !has_only_ref_pats(pats.clone()) {\n+        return;\n+    }\n \n-        span_lint_and_then(cx, MATCH_REF_PATS, expr.span, title, |diag| {\n-            if !expr.span.from_expansion() {\n-                multispan_sugg(diag, msg, suggs);\n-            }\n-        });\n+    let (first_sugg, msg, title);\n+    let span = ex.span.source_callsite();\n+    if let ExprKind::AddrOf(BorrowKind::Ref, Mutability::Not, ref inner) = ex.kind {\n+        first_sugg = once((span, Sugg::hir_with_macro_callsite(cx, inner, \"..\").to_string()));\n+        msg = \"try\";\n+        title = \"you don't need to add `&` to both the expression and the patterns\";\n+    } else {\n+        first_sugg = once((span, Sugg::hir_with_macro_callsite(cx, ex, \"..\").deref().to_string()));\n+        msg = \"instead of prefixing all patterns with `&`, you can dereference the expression\";\n+        title = \"you don't need to add `&` to all patterns\";\n     }\n+\n+    let remaining_suggs = pats.filter_map(|pat| {\n+        if let PatKind::Ref(ref refp, _) = pat.kind {\n+            Some((pat.span, snippet(cx, refp.span, \"..\").to_string()))\n+        } else {\n+            None\n+        }\n+    });\n+\n+    span_lint_and_then(cx, MATCH_REF_PATS, expr.span, title, |diag| {\n+        if !expr.span.from_expansion() {\n+            multispan_sugg(diag, msg, first_sugg.chain(remaining_suggs));\n+        }\n+    });\n }\n \n fn check_match_as_ref(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>], expr: &Expr<'_>) {\n@@ -1286,46 +1293,99 @@ fn check_wild_in_or_pats(cx: &LateContext<'_>, arms: &[Arm<'_>]) {\n \n /// Lint a `match` or `if let .. { .. } else { .. }` expr that could be replaced by `matches!`\n fn check_match_like_matches<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) -> bool {\n-    if let ExprKind::Match(ex, arms, ref match_source) = &expr.kind {\n-        match match_source {\n-            MatchSource::Normal => find_matches_sugg(cx, ex, arms, expr, false),\n-            MatchSource::IfLetDesugar { .. } => find_matches_sugg(cx, ex, arms, expr, true),\n-            _ => false,\n-        }\n-    } else {\n-        false\n+    if let Some(higher::IfLet {\n+        let_pat,\n+        let_expr,\n+        if_then,\n+        if_else: Some(if_else),\n+    }) = higher::IfLet::hir(expr)\n+    {\n+        return find_matches_sugg(\n+            cx,\n+            let_expr,\n+            array::IntoIter::new([(&[][..], Some(let_pat), if_then, None), (&[][..], None, if_else, None)]),\n+            expr,\n+            true,\n+        );\n     }\n+\n+    if let ExprKind::Match(scrut, arms, MatchSource::Normal) = expr.kind {\n+        return find_matches_sugg(\n+            cx,\n+            scrut,\n+            arms.iter().map(|arm| {\n+                (\n+                    cx.tcx.hir().attrs(arm.hir_id),\n+                    Some(arm.pat),\n+                    arm.body,\n+                    arm.guard.as_ref(),\n+                )\n+            }),\n+            expr,\n+            false,\n+        );\n+    }\n+\n+    false\n }\n \n-/// Lint a `match` or desugared `if let` for replacement by `matches!`\n-fn find_matches_sugg(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>], expr: &Expr<'_>, desugared: bool) -> bool {\n+/// Lint a `match` or `if let` for replacement by `matches!`\n+fn find_matches_sugg<'a, 'b, I>(\n+    cx: &LateContext<'_>,\n+    ex: &Expr<'_>,\n+    mut iter: I,\n+    expr: &Expr<'_>,\n+    is_if_let: bool,\n+) -> bool\n+where\n+    'b: 'a,\n+    I: Clone\n+        + DoubleEndedIterator\n+        + ExactSizeIterator\n+        + Iterator<\n+            Item = (\n+                &'a [Attribute],\n+                Option<&'a Pat<'b>>,\n+                &'a Expr<'b>,\n+                Option<&'a Guard<'b>>,\n+            ),\n+        >,\n+{\n     if_chain! {\n-        if arms.len() >= 2;\n+        if iter.len() >= 2;\n         if cx.typeck_results().expr_ty(expr).is_bool();\n-        if let Some((b1_arm, b0_arms)) = arms.split_last();\n-        if let Some(b0) = find_bool_lit(&b0_arms[0].body.kind, desugared);\n-        if let Some(b1) = find_bool_lit(&b1_arm.body.kind, desugared);\n-        if is_wild(b1_arm.pat);\n+        if let Some((_, last_pat_opt, last_expr, _)) = iter.next_back();\n+        let iter_without_last = iter.clone();\n+        if let Some((first_attrs, _, first_expr, first_guard)) = iter.next();\n+        if let Some(b0) = find_bool_lit(&first_expr.kind, is_if_let);\n+        if let Some(b1) = find_bool_lit(&last_expr.kind, is_if_let);\n         if b0 != b1;\n-        let if_guard = &b0_arms[0].guard;\n-        if if_guard.is_none() || b0_arms.len() == 1;\n-        if cx.tcx.hir().attrs(b0_arms[0].hir_id).is_empty();\n-        if b0_arms[1..].iter()\n+        if first_guard.is_none() || iter.len() == 0;\n+        if first_attrs.is_empty();\n+        if iter\n             .all(|arm| {\n-                find_bool_lit(&arm.body.kind, desugared).map_or(false, |b| b == b0) &&\n-                arm.guard.is_none() && cx.tcx.hir().attrs(arm.hir_id).is_empty()\n+                find_bool_lit(&arm.2.kind, is_if_let).map_or(false, |b| b == b0) && arm.3.is_none() && arm.0.is_empty()\n             });\n         then {\n+            if let Some(ref last_pat) = last_pat_opt {\n+                if !is_wild(last_pat) {\n+                    return false;\n+                }\n+            }\n+\n             // The suggestion may be incorrect, because some arms can have `cfg` attributes\n             // evaluated into `false` and so such arms will be stripped before.\n             let mut applicability = Applicability::MaybeIncorrect;\n             let pat = {\n                 use itertools::Itertools as _;\n-                b0_arms.iter()\n-                    .map(|arm| snippet_with_applicability(cx, arm.pat.span, \"..\", &mut applicability))\n+                iter_without_last\n+                    .filter_map(|arm| {\n+                        let pat_span = arm.1?.span;\n+                        Some(snippet_with_applicability(cx, pat_span, \"..\", &mut applicability))\n+                    })\n                     .join(\" | \")\n             };\n-            let pat_and_guard = if let Some(Guard::If(g)) = if_guard {\n+            let pat_and_guard = if let Some(Guard::If(g)) = first_guard {\n                 format!(\"{} if {}\", pat, snippet_with_applicability(cx, g.span, \"..\", &mut applicability))\n             } else {\n                 pat\n@@ -1342,7 +1402,7 @@ fn find_matches_sugg(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>], expr\n                 cx,\n                 MATCH_LIKE_MATCHES_MACRO,\n                 expr.span,\n-                &format!(\"{} expression looks like `matches!` macro\", if desugared { \"if let .. else\" } else { \"match\" }),\n+                &format!(\"{} expression looks like `matches!` macro\", if is_if_let { \"if let .. else\" } else { \"match\" }),\n                 \"try this\",\n                 format!(\n                     \"{}matches!({}, {})\",\n@@ -1360,7 +1420,7 @@ fn find_matches_sugg(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>], expr\n }\n \n /// Extract a `bool` or `{ bool }`\n-fn find_bool_lit(ex: &ExprKind<'_>, desugared: bool) -> Option<bool> {\n+fn find_bool_lit(ex: &ExprKind<'_>, is_if_let: bool) -> Option<bool> {\n     match ex {\n         ExprKind::Lit(Spanned {\n             node: LitKind::Bool(b), ..\n@@ -1372,7 +1432,7 @@ fn find_bool_lit(ex: &ExprKind<'_>, desugared: bool) -> Option<bool> {\n                 ..\n             },\n             _,\n-        ) if desugared => {\n+        ) if is_if_let => {\n             if let ExprKind::Lit(Spanned {\n                 node: LitKind::Bool(b), ..\n             }) = exp.kind\n@@ -1644,19 +1704,26 @@ fn is_ref_some_arm(cx: &LateContext<'_>, arm: &Arm<'_>) -> Option<BindingAnnotat\n     None\n }\n \n-fn has_only_ref_pats(arms: &[Arm<'_>]) -> bool {\n-    let mapped = arms\n-        .iter()\n-        .map(|a| {\n-            match a.pat.kind {\n-                PatKind::Ref(..) => Some(true), // &-patterns\n-                PatKind::Wild => Some(false),   // an \"anything\" wildcard is also fine\n-                _ => None,                      // any other pattern is not fine\n+fn has_only_ref_pats<'a, 'b, I>(pats: I) -> bool\n+where\n+    'b: 'a,\n+    I: Iterator<Item = &'a Pat<'b>>,\n+{\n+    let mut at_least_one_is_true = false;\n+    for opt in pats.map(|pat| match pat.kind {\n+        PatKind::Ref(..) => Some(true), // &-patterns\n+        PatKind::Wild => Some(false),   // an \"anything\" wildcard is also fine\n+        _ => None,                      // any other pattern is not fine\n+    }) {\n+        if let Some(inner) = opt {\n+            if inner {\n+                at_least_one_is_true = true;\n             }\n-        })\n-        .collect::<Option<Vec<bool>>>();\n-    // look for Some(v) where there's at least one true element\n-    mapped.map_or(false, |v| v.iter().any(|el| *el))\n+        } else {\n+            return false;\n+        }\n+    }\n+    at_least_one_is_true\n }\n \n pub fn overlapping<T>(ranges: &[SpannedRange<T>]) -> Option<(&SpannedRange<T>, &SpannedRange<T>)>\n@@ -1745,6 +1812,7 @@ where\n mod redundant_pattern_match {\n     use super::REDUNDANT_PATTERN_MATCHING;\n     use clippy_utils::diagnostics::span_lint_and_then;\n+    use clippy_utils::higher;\n     use clippy_utils::source::{snippet, snippet_with_applicability};\n     use clippy_utils::ty::{implements_trait, is_type_diagnostic_item, is_type_lang_item, match_type};\n     use clippy_utils::{is_lang_ctor, is_qpath_def_path, is_trait_method, paths};\n@@ -1755,22 +1823,27 @@ mod redundant_pattern_match {\n     use rustc_hir::LangItem::{OptionNone, OptionSome, PollPending, PollReady, ResultErr, ResultOk};\n     use rustc_hir::{\n         intravisit::{walk_expr, ErasedMap, NestedVisitorMap, Visitor},\n-        Arm, Block, Expr, ExprKind, LangItem, MatchSource, Node, PatKind, QPath,\n+        Arm, Block, Expr, ExprKind, LangItem, MatchSource, Node, Pat, PatKind, QPath,\n     };\n     use rustc_lint::LateContext;\n     use rustc_middle::ty::{self, subst::GenericArgKind, Ty};\n     use rustc_span::sym;\n \n     pub fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if let ExprKind::Match(op, arms, ref match_source) = &expr.kind {\n-            match match_source {\n-                MatchSource::Normal => find_sugg_for_match(cx, expr, op, arms),\n-                MatchSource::IfLetDesugar { contains_else_clause } => {\n-                    find_sugg_for_if_let(cx, expr, op, &arms[0], \"if\", *contains_else_clause);\n-                },\n-                MatchSource::WhileLetDesugar => find_sugg_for_if_let(cx, expr, op, &arms[0], \"while\", false),\n-                _ => {},\n-            }\n+        if let Some(higher::IfLet {\n+            if_else,\n+            let_pat,\n+            let_expr,\n+            ..\n+        }) = higher::IfLet::ast(cx, expr)\n+        {\n+            find_sugg_for_if_let(cx, expr, let_pat, let_expr, \"if\", if_else.is_some())\n+        }\n+        if let ExprKind::Match(op, arms, MatchSource::Normal) = &expr.kind {\n+            find_sugg_for_match(cx, expr, op, arms)\n+        }\n+        if let Some(higher::WhileLet { let_pat, let_expr, .. }) = higher::WhileLet::hir(expr) {\n+            find_sugg_for_if_let(cx, expr, let_pat, let_expr, \"while\", false)\n         }\n     }\n \n@@ -1924,18 +1997,18 @@ mod redundant_pattern_match {\n     fn find_sugg_for_if_let<'tcx>(\n         cx: &LateContext<'tcx>,\n         expr: &'tcx Expr<'_>,\n-        op: &'tcx Expr<'tcx>,\n-        arm: &Arm<'_>,\n+        let_pat: &Pat<'_>,\n+        let_expr: &'tcx Expr<'_>,\n         keyword: &'static str,\n         has_else: bool,\n     ) {\n         // also look inside refs\n-        let mut kind = &arm.pat.kind;\n+        let mut kind = &let_pat.kind;\n         // if we have &None for example, peel it so we can detect \"if let None = x\"\n         if let PatKind::Ref(inner, _mutability) = kind {\n             kind = &inner.kind;\n         }\n-        let op_ty = cx.typeck_results().expr_ty(op);\n+        let op_ty = cx.typeck_results().expr_ty(let_expr);\n         // Determine which function should be used, and the type contained by the corresponding\n         // variant.\n         let (good_method, inner_ty) = match kind {\n@@ -1989,38 +2062,38 @@ mod redundant_pattern_match {\n         // scrutinee would be, so they have to be considered as well.\n         // e.g. in `if let Some(x) = foo.lock().unwrap().baz.as_ref() { .. }` the lock will be held\n         // for the duration if body.\n-        let needs_drop = type_needs_ordered_drop(cx, check_ty) || temporaries_need_ordered_drop(cx, op);\n+        let needs_drop = type_needs_ordered_drop(cx, check_ty) || temporaries_need_ordered_drop(cx, let_expr);\n \n         // check that `while_let_on_iterator` lint does not trigger\n         if_chain! {\n             if keyword == \"while\";\n-            if let ExprKind::MethodCall(method_path, _, _, _) = op.kind;\n+            if let ExprKind::MethodCall(method_path, _, _, _) = let_expr.kind;\n             if method_path.ident.name == sym::next;\n-            if is_trait_method(cx, op, sym::Iterator);\n+            if is_trait_method(cx, let_expr, sym::Iterator);\n             then {\n                 return;\n             }\n         }\n \n-        let result_expr = match &op.kind {\n+        let result_expr = match &let_expr.kind {\n             ExprKind::AddrOf(_, _, borrowed) => borrowed,\n-            _ => op,\n+            _ => let_expr,\n         };\n         span_lint_and_then(\n             cx,\n             REDUNDANT_PATTERN_MATCHING,\n-            arm.pat.span,\n+            let_pat.span,\n             &format!(\"redundant pattern matching, consider using `{}`\", good_method),\n             |diag| {\n-                // while let ... = ... { ... }\n+                // if/while let ... = ... { ... }\n                 // ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n                 let expr_span = expr.span;\n \n-                // while let ... = ... { ... }\n+                // if/while let ... = ... { ... }\n                 //                 ^^^\n                 let op_span = result_expr.span.source_callsite();\n \n-                // while let ... = ... { ... }\n+                // if/while let ... = ... { ... }\n                 // ^^^^^^^^^^^^^^^^^^^\n                 let span = expr_span.until(op_span.shrink_to_hi());\n "}, {"sha": "6954da67e32c0fe3ae940abcaedd1b93c14005af", "filename": "clippy_lints/src/methods/iter_next_slice.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b97d4c062b4d99139f14960daa7ce99d63625833/clippy_lints%2Fsrc%2Fmethods%2Fiter_next_slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b97d4c062b4d99139f14960daa7ce99d63625833/clippy_lints%2Fsrc%2Fmethods%2Fiter_next_slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fiter_next_slice.rs?ref=b97d4c062b4d99139f14960daa7ce99d63625833", "patch": "@@ -18,7 +18,7 @@ pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>, cal\n     // since it is already covered by `&loops::ITER_NEXT_LOOP`\n     let mut parent_expr_opt = get_parent_expr(cx, expr);\n     while let Some(parent_expr) = parent_expr_opt {\n-        if higher::for_loop(parent_expr).is_some() {\n+        if higher::ForLoop::hir(parent_expr).is_some() {\n             return;\n         }\n         parent_expr_opt = get_parent_expr(cx, parent_expr);\n@@ -29,7 +29,7 @@ pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>, cal\n         if_chain! {\n             if let hir::ExprKind::Index(caller_var, index_expr) = &caller_expr.kind;\n             if let Some(higher::Range { start: Some(start_expr), end: None, limits: ast::RangeLimits::HalfOpen })\n-                = higher::range(index_expr);\n+                = higher::Range::hir(index_expr);\n             if let hir::ExprKind::Lit(ref start_lit) = &start_expr.kind;\n             if let ast::LitKind::Int(start_idx, _) = start_lit.node;\n             then {"}, {"sha": "610152a217f1e3dac93028b9b41a945f37b92468", "filename": "clippy_lints/src/mut_mut.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b97d4c062b4d99139f14960daa7ce99d63625833/clippy_lints%2Fsrc%2Fmut_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b97d4c062b4d99139f14960daa7ce99d63625833/clippy_lints%2Fsrc%2Fmut_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmut_mut.rs?ref=b97d4c062b4d99139f14960daa7ce99d63625833", "patch": "@@ -53,7 +53,7 @@ impl<'a, 'tcx> intravisit::Visitor<'tcx> for MutVisitor<'a, 'tcx> {\n             return;\n         }\n \n-        if let Some((_, arg, body, _)) = higher::for_loop(expr) {\n+        if let Some(higher::ForLoop { arg, body, .. }) = higher::ForLoop::hir(expr) {\n             // A `for` loop lowers to:\n             // ```rust\n             // match ::std::iter::Iterator::next(&mut iter) {"}, {"sha": "c9dd94400efb96163f0d01028cc92cb91eef4ecc", "filename": "clippy_lints/src/needless_bool.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b97d4c062b4d99139f14960daa7ce99d63625833/clippy_lints%2Fsrc%2Fneedless_bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b97d4c062b4d99139f14960daa7ce99d63625833/clippy_lints%2Fsrc%2Fneedless_bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_bool.rs?ref=b97d4c062b4d99139f14960daa7ce99d63625833", "patch": "@@ -3,6 +3,7 @@\n //! This lint is **warn** by default\n \n use clippy_utils::diagnostics::{span_lint, span_lint_and_sugg};\n+use clippy_utils::higher;\n use clippy_utils::source::snippet_with_applicability;\n use clippy_utils::sugg::Sugg;\n use clippy_utils::{is_else_clause, is_expn_of};\n@@ -77,10 +78,15 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessBool {\n         if e.span.from_expansion() {\n             return;\n         }\n-        if let ExprKind::If(pred, then_block, Some(else_expr)) = e.kind {\n+        if let Some(higher::If {\n+            cond,\n+            then,\n+            r#else: Some(r#else),\n+        }) = higher::If::hir(e)\n+        {\n             let reduce = |ret, not| {\n                 let mut applicability = Applicability::MachineApplicable;\n-                let snip = Sugg::hir_with_applicability(cx, pred, \"<predicate>\", &mut applicability);\n+                let snip = Sugg::hir_with_applicability(cx, cond, \"<predicate>\", &mut applicability);\n                 let mut snip = if not { !snip } else { snip };\n \n                 if ret {\n@@ -101,8 +107,8 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessBool {\n                     applicability,\n                 );\n             };\n-            if let ExprKind::Block(then_block, _) = then_block.kind {\n-                match (fetch_bool_block(then_block), fetch_bool_expr(else_expr)) {\n+            if let ExprKind::Block(then, _) = then.kind {\n+                match (fetch_bool_block(then), fetch_bool_expr(r#else)) {\n                     (RetBool(true), RetBool(true)) | (Bool(true), Bool(true)) => {\n                         span_lint(\n                             cx,"}, {"sha": "ac21eb5275f0f8bc443e0a88a903d0ac70e7e089", "filename": "clippy_lints/src/non_expressive_names.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b97d4c062b4d99139f14960daa7ce99d63625833/clippy_lints%2Fsrc%2Fnon_expressive_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b97d4c062b4d99139f14960daa7ce99d63625833/clippy_lints%2Fsrc%2Fnon_expressive_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnon_expressive_names.rs?ref=b97d4c062b4d99139f14960daa7ce99d63625833", "patch": "@@ -1,7 +1,6 @@\n use clippy_utils::diagnostics::{span_lint, span_lint_and_then};\n use rustc_ast::ast::{\n-    Arm, AssocItem, AssocItemKind, Attribute, Block, FnDecl, FnKind, Item, ItemKind, Local, Pat,\n-    PatKind,\n+    Arm, AssocItem, AssocItemKind, Attribute, Block, FnDecl, FnKind, Item, ItemKind, Local, Pat, PatKind,\n };\n use rustc_ast::visit::{walk_block, walk_expr, walk_pat, Visitor};\n use rustc_lint::{EarlyContext, EarlyLintPass};"}, {"sha": "d0b0bad5eb1cce187a4de039284ac924ea5ce067", "filename": "clippy_lints/src/option_if_let_else.rs", "status": "modified", "additions": 20, "deletions": 23, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/b97d4c062b4d99139f14960daa7ce99d63625833/clippy_lints%2Fsrc%2Foption_if_let_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b97d4c062b4d99139f14960daa7ce99d63625833/clippy_lints%2Fsrc%2Foption_if_let_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foption_if_let_else.rs?ref=b97d4c062b4d99139f14960daa7ce99d63625833", "patch": "@@ -1,12 +1,13 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::higher;\n use clippy_utils::sugg::Sugg;\n use clippy_utils::ty::is_type_diagnostic_item;\n use clippy_utils::usage::contains_return_break_continue_macro;\n use clippy_utils::{eager_or_lazy, in_macro, is_else_clause, is_lang_ctor};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::LangItem::OptionSome;\n-use rustc_hir::{Arm, BindingAnnotation, Block, Expr, ExprKind, MatchSource, Mutability, PatKind, UnOp};\n+use rustc_hir::{BindingAnnotation, Block, Expr, ExprKind, Mutability, PatKind, UnOp};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::sym;\n@@ -84,20 +85,20 @@ struct OptionIfLetElseOccurence {\n \n /// Extracts the body of a given arm. If the arm contains only an expression,\n /// then it returns the expression. Otherwise, it returns the entire block\n-fn extract_body_from_arm<'a>(arm: &'a Arm<'a>) -> Option<&'a Expr<'a>> {\n+fn extract_body_from_expr<'a>(expr: &'a Expr<'a>) -> Option<&'a Expr<'a>> {\n     if let ExprKind::Block(\n         Block {\n-            stmts: statements,\n-            expr: Some(expr),\n+            stmts: block_stmts,\n+            expr: Some(block_expr),\n             ..\n         },\n         _,\n-    ) = &arm.body.kind\n+    ) = expr.kind\n     {\n-        if let [] = statements {\n-            Some(expr)\n+        if let [] = block_stmts {\n+            Some(block_expr)\n         } else {\n-            Some(arm.body)\n+            Some(expr)\n         }\n     } else {\n         None\n@@ -121,37 +122,33 @@ fn format_option_in_sugg(cx: &LateContext<'_>, cond_expr: &Expr<'_>, as_ref: boo\n /// If this expression is the option if let/else construct we're detecting, then\n /// this function returns an `OptionIfLetElseOccurence` struct with details if\n /// this construct is found, or None if this construct is not found.\n-fn detect_option_if_let_else<'tcx>(\n-    cx: &'_ LateContext<'tcx>,\n-    expr: &'_ Expr<'tcx>,\n-) -> Option<OptionIfLetElseOccurence> {\n+fn detect_option_if_let_else<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'tcx>) -> Option<OptionIfLetElseOccurence> {\n     if_chain! {\n         if !in_macro(expr.span); // Don't lint macros, because it behaves weirdly\n-        if let ExprKind::Match(cond_expr, arms, MatchSource::IfLetDesugar{contains_else_clause: true}) = &expr.kind;\n+        if let Some(higher::IfLet { let_pat, let_expr, if_then, if_else: Some(if_else) }) = higher::IfLet::hir(expr);\n         if !is_else_clause(cx.tcx, expr);\n-        if arms.len() == 2;\n-        if !is_result_ok(cx, cond_expr); // Don't lint on Result::ok because a different lint does it already\n-        if let PatKind::TupleStruct(struct_qpath, [inner_pat], _) = &arms[0].pat.kind;\n+        if !is_result_ok(cx, let_expr); // Don't lint on Result::ok because a different lint does it already\n+        if let PatKind::TupleStruct(struct_qpath, [inner_pat], _) = &let_pat.kind;\n         if is_lang_ctor(cx, struct_qpath, OptionSome);\n         if let PatKind::Binding(bind_annotation, _, id, _) = &inner_pat.kind;\n-        if !contains_return_break_continue_macro(arms[0].body);\n-        if !contains_return_break_continue_macro(arms[1].body);\n+        if !contains_return_break_continue_macro(if_then);\n+        if !contains_return_break_continue_macro(if_else);\n \n         then {\n             let capture_mut = if bind_annotation == &BindingAnnotation::Mutable { \"mut \" } else { \"\" };\n-            let some_body = extract_body_from_arm(&arms[0])?;\n-            let none_body = extract_body_from_arm(&arms[1])?;\n+            let some_body = extract_body_from_expr(if_then)?;\n+            let none_body = extract_body_from_expr(if_else)?;\n             let method_sugg = if eager_or_lazy::is_eagerness_candidate(cx, none_body) { \"map_or\" } else { \"map_or_else\" };\n             let capture_name = id.name.to_ident_string();\n-            let (as_ref, as_mut) = match &cond_expr.kind {\n+            let (as_ref, as_mut) = match &let_expr.kind {\n                 ExprKind::AddrOf(_, Mutability::Not, _) => (true, false),\n                 ExprKind::AddrOf(_, Mutability::Mut, _) => (false, true),\n                 _ => (bind_annotation == &BindingAnnotation::Ref, bind_annotation == &BindingAnnotation::RefMut),\n             };\n-            let cond_expr = match &cond_expr.kind {\n+            let cond_expr = match let_expr.kind {\n                 // Pointer dereferencing happens automatically, so we can omit it in the suggestion\n                 ExprKind::Unary(UnOp::Deref, expr) | ExprKind::AddrOf(_, _, expr) => expr,\n-                _ => cond_expr,\n+                _ => let_expr,\n             };\n             Some(OptionIfLetElseOccurence {\n                 option: format_option_in_sugg(cx, cond_expr, as_ref, as_mut),"}, {"sha": "35cff4141a903b40cdf58c3f176a9a599aeca3dc", "filename": "clippy_lints/src/pattern_type_mismatch.rs", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/b97d4c062b4d99139f14960daa7ce99d63625833/clippy_lints%2Fsrc%2Fpattern_type_mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b97d4c062b4d99139f14960daa7ce99d63625833/clippy_lints%2Fsrc%2Fpattern_type_mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fpattern_type_mismatch.rs?ref=b97d4c062b4d99139f14960daa7ce99d63625833", "patch": "@@ -104,22 +104,25 @@ impl<'tcx> LateLintPass<'tcx> for PatternTypeMismatch {\n     }\n \n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if let ExprKind::Match(expr, arms, source) = expr.kind {\n-            match source {\n-                MatchSource::Normal | MatchSource::IfLetDesugar { .. } | MatchSource::WhileLetDesugar => {\n-                    if let Some(expr_ty) = cx.typeck_results().node_type_opt(expr.hir_id) {\n-                        'pattern_checks: for arm in arms {\n-                            let pat = &arm.pat;\n-                            if in_external_macro(cx.sess(), pat.span) {\n-                                continue 'pattern_checks;\n-                            }\n-                            if apply_lint(cx, pat, expr_ty, DerefPossible::Possible) {\n-                                break 'pattern_checks;\n-                            }\n-                        }\n+        if let ExprKind::Match(scrutinee, arms, MatchSource::Normal) = expr.kind {\n+            if let Some(expr_ty) = cx.typeck_results().node_type_opt(scrutinee.hir_id) {\n+                'pattern_checks: for arm in arms {\n+                    let pat = &arm.pat;\n+                    if in_external_macro(cx.sess(), pat.span) {\n+                        continue 'pattern_checks;\n                     }\n-                },\n-                _ => (),\n+                    if apply_lint(cx, pat, expr_ty, DerefPossible::Possible) {\n+                        break 'pattern_checks;\n+                    }\n+                }\n+            }\n+        }\n+        if let ExprKind::Let(let_pat, let_expr, _) = expr.kind {\n+            if let Some(ref expr_ty) = cx.typeck_results().node_type_opt(let_expr.hir_id) {\n+                if in_external_macro(cx.sess(), let_pat.span) {\n+                    return;\n+                }\n+                apply_lint(cx, let_pat, expr_ty, DerefPossible::Possible);\n             }\n         }\n     }"}, {"sha": "91085c13ac4a4f76faf4f1255af42987e231c4c4", "filename": "clippy_lints/src/question_mark.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/b97d4c062b4d99139f14960daa7ce99d63625833/clippy_lints%2Fsrc%2Fquestion_mark.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b97d4c062b4d99139f14960daa7ce99d63625833/clippy_lints%2Fsrc%2Fquestion_mark.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fquestion_mark.rs?ref=b97d4c062b4d99139f14960daa7ce99d63625833", "patch": "@@ -1,4 +1,5 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::higher;\n use clippy_utils::is_lang_ctor;\n use clippy_utils::source::snippet_with_applicability;\n use clippy_utils::sugg::Sugg;\n@@ -7,7 +8,7 @@ use clippy_utils::{eq_expr_value, path_to_local_id};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::LangItem::{OptionNone, OptionSome};\n-use rustc_hir::{BindingAnnotation, Block, Expr, ExprKind, MatchSource, PatKind, StmtKind};\n+use rustc_hir::{BindingAnnotation, Block, Expr, ExprKind, PatKind, StmtKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::sym;\n@@ -50,20 +51,20 @@ impl QuestionMark {\n     /// If it matches, it will suggest to use the question mark operator instead\n     fn check_is_none_and_early_return_none(cx: &LateContext<'_>, expr: &Expr<'_>) {\n         if_chain! {\n-            if let ExprKind::If(if_expr, body, else_) = &expr.kind;\n-            if let ExprKind::MethodCall(segment, _, args, _) = &if_expr.kind;\n+            if let Some(higher::If { cond, then, r#else }) = higher::If::hir(expr);\n+            if let ExprKind::MethodCall(segment, _, args, _) = &cond.kind;\n             if segment.ident.name == sym!(is_none);\n-            if Self::expression_returns_none(cx, body);\n+            if Self::expression_returns_none(cx, then);\n             if let Some(subject) = args.get(0);\n             if Self::is_option(cx, subject);\n \n             then {\n                 let mut applicability = Applicability::MachineApplicable;\n                 let receiver_str = &Sugg::hir_with_applicability(cx, subject, \"..\", &mut applicability);\n                 let mut replacement: Option<String> = None;\n-                if let Some(else_) = else_ {\n+                if let Some(else_inner) = r#else {\n                     if_chain! {\n-                        if let ExprKind::Block(block, None) = &else_.kind;\n+                        if let ExprKind::Block(block, None) = &else_inner.kind;\n                         if block.stmts.is_empty();\n                         if let Some(block_expr) = &block.expr;\n                         if eq_expr_value(cx, subject, block_expr);\n@@ -96,25 +97,23 @@ impl QuestionMark {\n \n     fn check_if_let_some_and_early_return_none(cx: &LateContext<'_>, expr: &Expr<'_>) {\n         if_chain! {\n-            if let ExprKind::Match(subject, arms, source) = &expr.kind;\n-            if *source == MatchSource::IfLetDesugar { contains_else_clause: true };\n-            if Self::is_option(cx, subject);\n+            if let Some(higher::IfLet { let_pat, let_expr, if_then, if_else: Some(if_else) }) = higher::IfLet::hir(expr);\n+            if Self::is_option(cx, let_expr);\n \n-            if let PatKind::TupleStruct(path1, fields, None) = &arms[0].pat.kind;\n+            if let PatKind::TupleStruct(ref path1, fields, None) = let_pat.kind;\n             if is_lang_ctor(cx, path1, OptionSome);\n             if let PatKind::Binding(annot, bind_id, _, _) = fields[0].kind;\n             let by_ref = matches!(annot, BindingAnnotation::Ref | BindingAnnotation::RefMut);\n \n-            if let ExprKind::Block(block, None) = &arms[0].body.kind;\n+            if let ExprKind::Block(ref block, None) = if_then.kind;\n             if block.stmts.is_empty();\n             if let Some(trailing_expr) = &block.expr;\n             if path_to_local_id(trailing_expr, bind_id);\n \n-            if let PatKind::Wild = arms[1].pat.kind;\n-            if Self::expression_returns_none(cx, arms[1].body);\n+            if Self::expression_returns_none(cx, if_else);\n             then {\n                 let mut applicability = Applicability::MachineApplicable;\n-                let receiver_str = snippet_with_applicability(cx, subject.span, \"..\", &mut applicability);\n+                let receiver_str = snippet_with_applicability(cx, let_expr.span, \"..\", &mut applicability);\n                 let replacement = format!(\n                     \"{}{}?\",\n                     receiver_str,"}, {"sha": "0114a2f97a2287d84a82269d9f5dd19f08e81dfa", "filename": "clippy_lints/src/ranges.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b97d4c062b4d99139f14960daa7ce99d63625833/clippy_lints%2Fsrc%2Franges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b97d4c062b4d99139f14960daa7ce99d63625833/clippy_lints%2Fsrc%2Franges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Franges.rs?ref=b97d4c062b4d99139f14960daa7ce99d63625833", "patch": "@@ -329,15 +329,15 @@ fn check_range_zip_with_len(cx: &LateContext<'_>, path: &PathSegment<'_>, args:\n         if let ExprKind::MethodCall(iter_path, _, iter_args, _) = iter.kind;\n         if iter_path.ident.name == sym::iter;\n         // range expression in `.zip()` call: `0..x.len()`\n-        if let Some(higher::Range { start: Some(start), end: Some(end), .. }) = higher::range(zip_arg);\n+        if let Some(higher::Range { start: Some(start), end: Some(end), .. }) = higher::Range::hir(zip_arg);\n         if is_integer_const(cx, start, 0);\n         // `.len()` call\n         if let ExprKind::MethodCall(len_path, _, len_args, _) = end.kind;\n         if len_path.ident.name == sym::len && len_args.len() == 1;\n         // `.iter()` and `.len()` called on same `Path`\n         if let ExprKind::Path(QPath::Resolved(_, iter_path)) = iter_args[0].kind;\n         if let ExprKind::Path(QPath::Resolved(_, len_path)) = len_args[0].kind;\n-        if SpanlessEq::new(cx).eq_path_segments(iter_path.segments, len_path.segments);\n+        if SpanlessEq::new(cx).eq_path_segments(&iter_path.segments, &len_path.segments);\n         then {\n             span_lint(cx,\n                 RANGE_ZIP_WITH_LEN,\n@@ -356,7 +356,7 @@ fn check_exclusive_range_plus_one(cx: &LateContext<'_>, expr: &Expr<'_>) {\n             start,\n             end: Some(end),\n             limits: RangeLimits::HalfOpen\n-        }) = higher::range(expr);\n+        }) = higher::Range::hir(expr);\n         if let Some(y) = y_plus_one(cx, end);\n         then {\n             let span = if expr.span.from_expansion() {\n@@ -401,7 +401,7 @@ fn check_exclusive_range_plus_one(cx: &LateContext<'_>, expr: &Expr<'_>) {\n // inclusive range minus one: `x..=(y-1)`\n fn check_inclusive_range_minus_one(cx: &LateContext<'_>, expr: &Expr<'_>) {\n     if_chain! {\n-        if let Some(higher::Range { start, end: Some(end), limits: RangeLimits::Closed }) = higher::range(expr);\n+        if let Some(higher::Range { start, end: Some(end), limits: RangeLimits::Closed }) = higher::Range::hir(expr);\n         if let Some(y) = y_minus_one(cx, end);\n         then {\n             span_lint_and_then(\n@@ -438,8 +438,8 @@ fn check_reversed_empty_range(cx: &LateContext<'_>, expr: &Expr<'_>) {\n     fn is_for_loop_arg(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n         let mut cur_expr = expr;\n         while let Some(parent_expr) = get_parent_expr(cx, cur_expr) {\n-            match higher::for_loop(parent_expr) {\n-                Some((_, args, _, _)) if args.hir_id == expr.hir_id => return true,\n+            match higher::ForLoop::hir(parent_expr) {\n+                Some(higher::ForLoop { arg, .. }) if arg.hir_id == expr.hir_id => return true,\n                 _ => cur_expr = parent_expr,\n             }\n         }\n@@ -455,7 +455,7 @@ fn check_reversed_empty_range(cx: &LateContext<'_>, expr: &Expr<'_>) {\n     }\n \n     if_chain! {\n-        if let Some(higher::Range { start: Some(start), end: Some(end), limits }) = higher::range(expr);\n+        if let Some(higher::Range { start: Some(start), end: Some(end), limits }) = higher::Range::hir(expr);\n         let ty = cx.typeck_results().expr_ty(start);\n         if let ty::Int(_) | ty::Uint(_) = ty.kind();\n         if let Some((start_idx, _)) = constant(cx, cx.typeck_results(), start);"}, {"sha": "530b3396abef698fd0c16baee09116f18c35f28b", "filename": "clippy_lints/src/redundant_clone.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b97d4c062b4d99139f14960daa7ce99d63625833/clippy_lints%2Fsrc%2Fredundant_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b97d4c062b4d99139f14960daa7ce99d63625833/clippy_lints%2Fsrc%2Fredundant_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fredundant_clone.rs?ref=b97d4c062b4d99139f14960daa7ce99d63625833", "patch": "@@ -725,7 +725,7 @@ fn rvalue_locals(rvalue: &mir::Rvalue<'_>, mut visit: impl FnMut(mir::Local)) {\n         BinaryOp(_, box (lhs, rhs)) | CheckedBinaryOp(_, box (lhs, rhs)) => {\n             visit_op(lhs);\n             visit_op(rhs);\n-        }\n+        },\n         _ => (),\n     }\n }"}, {"sha": "e153288aa58df6dce17331634af31b7bf75a36e1", "filename": "clippy_lints/src/returns.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b97d4c062b4d99139f14960daa7ce99d63625833/clippy_lints%2Fsrc%2Freturns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b97d4c062b4d99139f14960daa7ce99d63625833/clippy_lints%2Fsrc%2Freturns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Freturns.rs?ref=b97d4c062b4d99139f14960daa7ce99d63625833", "patch": "@@ -212,14 +212,6 @@ fn check_final_expr<'tcx>(\n                     check_final_expr(cx, arm.body, Some(arm.body.span), RetReplacement::Block);\n                 }\n             },\n-            MatchSource::IfLetDesugar {\n-                contains_else_clause: true,\n-            } => {\n-                if let ExprKind::Block(ifblock, _) = arms[0].body.kind {\n-                    check_block_return(cx, ifblock);\n-                }\n-                check_final_expr(cx, arms[1].body, None, RetReplacement::Empty);\n-            },\n             _ => (),\n         },\n         ExprKind::DropTemps(expr) => check_final_expr(cx, expr, None, RetReplacement::Empty),"}, {"sha": "44d5ff0b63ad51a5fd2c014f44969d2858644df8", "filename": "clippy_lints/src/suspicious_operation_groupings.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b97d4c062b4d99139f14960daa7ce99d63625833/clippy_lints%2Fsrc%2Fsuspicious_operation_groupings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b97d4c062b4d99139f14960daa7ce99d63625833/clippy_lints%2Fsrc%2Fsuspicious_operation_groupings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fsuspicious_operation_groupings.rs?ref=b97d4c062b4d99139f14960daa7ce99d63625833", "patch": "@@ -588,7 +588,7 @@ fn ident_difference_expr_with_base_location(\n         | (ForLoop(_, _, _, _), ForLoop(_, _, _, _))\n         | (While(_, _, _), While(_, _, _))\n         | (If(_, _, _), If(_, _, _))\n-        | (Let(_, _), Let(_, _))\n+        | (Let(_, _, _), Let(_, _, _))\n         | (Type(_, _), Type(_, _))\n         | (Cast(_, _), Cast(_, _))\n         | (Lit(_), Lit(_))"}, {"sha": "d6cf7190abb04959099378856509d1ad4cbe0ea0", "filename": "clippy_lints/src/unnested_or_patterns.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b97d4c062b4d99139f14960daa7ce99d63625833/clippy_lints%2Fsrc%2Funnested_or_patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b97d4c062b4d99139f14960daa7ce99d63625833/clippy_lints%2Fsrc%2Funnested_or_patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funnested_or_patterns.rs?ref=b97d4c062b4d99139f14960daa7ce99d63625833", "patch": "@@ -67,7 +67,7 @@ impl EarlyLintPass for UnnestedOrPatterns {\n \n     fn check_expr(&mut self, cx: &EarlyContext<'_>, e: &ast::Expr) {\n         if meets_msrv(self.msrv.as_ref(), &msrvs::OR_PATTERNS) {\n-            if let ast::ExprKind::Let(pat, _) = &e.kind {\n+            if let ast::ExprKind::Let(pat, _, _) = &e.kind {\n                 lint_unnested_or_patterns(cx, pat);\n             }\n         }"}, {"sha": "bffd9f3612b0a978ffb6426b9fc3932bfb728f87", "filename": "clippy_lints/src/unwrap.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b97d4c062b4d99139f14960daa7ce99d63625833/clippy_lints%2Fsrc%2Funwrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b97d4c062b4d99139f14960daa7ce99d63625833/clippy_lints%2Fsrc%2Funwrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funwrap.rs?ref=b97d4c062b4d99139f14960daa7ce99d63625833", "patch": "@@ -1,4 +1,5 @@\n use clippy_utils::diagnostics::span_lint_and_then;\n+use clippy_utils::higher;\n use clippy_utils::ty::is_type_diagnostic_item;\n use clippy_utils::{differing_macro_contexts, usage::is_potentially_mutated};\n use if_chain::if_chain;\n@@ -160,11 +161,11 @@ impl<'a, 'tcx> Visitor<'tcx> for UnwrappableVariablesVisitor<'a, 'tcx> {\n         if in_external_macro(self.cx.tcx.sess, expr.span) {\n             return;\n         }\n-        if let ExprKind::If(cond, then, els) = &expr.kind {\n+        if let Some(higher::If { cond, then, r#else }) = higher::If::hir(expr) {\n             walk_expr(self, cond);\n             self.visit_branch(cond, then, false);\n-            if let Some(els) = els {\n-                self.visit_branch(cond, els, true);\n+            if let Some(else_inner) = r#else {\n+                self.visit_branch(cond, else_inner, true);\n             }\n         } else {\n             // find `unwrap[_err]()` calls:"}, {"sha": "f93d7782e2511bd0ad666ca1e2e6a08440c1dac7", "filename": "clippy_lints/src/utils/author.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b97d4c062b4d99139f14960daa7ce99d63625833/clippy_lints%2Fsrc%2Futils%2Fauthor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b97d4c062b4d99139f14960daa7ce99d63625833/clippy_lints%2Fsrc%2Futils%2Fauthor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fauthor.rs?ref=b97d4c062b4d99139f14960daa7ce99d63625833", "patch": "@@ -208,6 +208,15 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n         print!(\"    if let ExprKind::\");\n         let current = format!(\"{}.kind\", self.current);\n         match expr.kind {\n+            ExprKind::Let(pat, expr, _) => {\n+                let let_pat = self.next(\"pat\");\n+                let let_expr = self.next(\"expr\");\n+                println!(\"    Let(ref {}, ref {}, _) = {};\", let_pat, let_expr, current);\n+                self.current = let_expr;\n+                self.visit_expr(expr);\n+                self.current = let_pat;\n+                self.visit_pat(pat);\n+            },\n             ExprKind::Box(inner) => {\n                 let inner_pat = self.next(\"inner\");\n                 println!(\"Box(ref {}) = {};\", inner_pat, current);"}, {"sha": "6bf216cec1670f1011e1806d653dfd48cd5af4ca", "filename": "clippy_lints/src/utils/inspector.rs", "status": "modified", "additions": 4, "deletions": 29, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/b97d4c062b4d99139f14960daa7ce99d63625833/clippy_lints%2Fsrc%2Futils%2Finspector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b97d4c062b4d99139f14960daa7ce99d63625833/clippy_lints%2Fsrc%2Futils%2Finspector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finspector.rs?ref=b97d4c062b4d99139f14960daa7ce99d63625833", "patch": "@@ -66,28 +66,6 @@ impl<'tcx> LateLintPass<'tcx> for DeepCodeInspector {\n             hir::ImplItemKind::TyAlias(_) => println!(\"associated type\"),\n         }\n     }\n-    // fn check_trait_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx\n-    // hir::TraitItem) {\n-    // if !has_attr(&item.attrs) {\n-    // return;\n-    // }\n-    // }\n-    //\n-    // fn check_variant(&mut self, cx: &LateContext<'tcx>, var: &'tcx\n-    // hir::Variant, _:\n-    // &hir::Generics) {\n-    // if !has_attr(&var.node.attrs) {\n-    // return;\n-    // }\n-    // }\n-    //\n-    // fn check_field_def(&mut self, cx: &LateContext<'tcx>, field: &'tcx\n-    // hir::FieldDef) {\n-    // if !has_attr(&field.attrs) {\n-    // return;\n-    // }\n-    // }\n-    //\n \n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n         if !has_attr(cx.sess(), cx.tcx.hir().attrs(expr.hir_id)) {\n@@ -127,13 +105,6 @@ impl<'tcx> LateLintPass<'tcx> for DeepCodeInspector {\n             hir::StmtKind::Expr(e) | hir::StmtKind::Semi(e) => print_expr(cx, e, 0),\n         }\n     }\n-    // fn check_foreign_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx\n-    // hir::ForeignItem) {\n-    // if !has_attr(&item.attrs) {\n-    // return;\n-    // }\n-    // }\n-    //\n }\n \n fn has_attr(sess: &Session, attrs: &[Attribute]) -> bool {\n@@ -171,6 +142,10 @@ fn print_expr(cx: &LateContext<'_>, expr: &hir::Expr<'_>, indent: usize) {\n                 print_expr(cx, arg, indent + 1);\n             }\n         },\n+        hir::ExprKind::Let(ref pat, ref expr, _) => {\n+            print_pat(cx, pat, indent + 1);\n+            print_expr(cx, expr, indent + 1);\n+        },\n         hir::ExprKind::MethodCall(path, _, args, _) => {\n             println!(\"{}MethodCall\", ind);\n             println!(\"{}method name: {}\", ind, path.ident.name);"}, {"sha": "95a45fa937f11ab8d9a7f79fa4eae96016bad9d8", "filename": "clippy_lints/src/vec.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b97d4c062b4d99139f14960daa7ce99d63625833/clippy_lints%2Fsrc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b97d4c062b4d99139f14960daa7ce99d63625833/clippy_lints%2Fsrc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fvec.rs?ref=b97d4c062b4d99139f14960daa7ce99d63625833", "patch": "@@ -49,17 +49,17 @@ impl<'tcx> LateLintPass<'tcx> for UselessVec {\n         if_chain! {\n             if let ty::Ref(_, ty, _) = cx.typeck_results().expr_ty_adjusted(expr).kind();\n             if let ty::Slice(..) = ty.kind();\n-            if let ExprKind::AddrOf(BorrowKind::Ref, mutability, addressee) = expr.kind;\n-            if let Some(vec_args) = higher::vec_macro(cx, addressee);\n+            if let ExprKind::AddrOf(BorrowKind::Ref, mutability, ref addressee) = expr.kind;\n+            if let Some(vec_args) = higher::VecArgs::hir(cx, addressee);\n             then {\n                 self.check_vec_macro(cx, &vec_args, mutability, expr.span);\n             }\n         }\n \n         // search for `for _ in vec![\u2026]`\n         if_chain! {\n-            if let Some((_, arg, _, _)) = higher::for_loop(expr);\n-            if let Some(vec_args) = higher::vec_macro(cx, arg);\n+            if let Some(higher::ForLoop { arg, .. }) = higher::ForLoop::hir(expr);\n+            if let Some(vec_args) = higher::VecArgs::hir(cx, arg);\n             if is_copy(cx, vec_type(cx.typeck_results().expr_ty_adjusted(arg)));\n             then {\n                 // report the error around the `vec!` not inside `<std macros>:`"}, {"sha": "7ea07a15aea51874457cee13b0319f4a8c9452db", "filename": "clippy_utils/src/ast_utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b97d4c062b4d99139f14960daa7ce99d63625833/clippy_utils%2Fsrc%2Fast_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b97d4c062b4d99139f14960daa7ce99d63625833/clippy_utils%2Fsrc%2Fast_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fast_utils.rs?ref=b97d4c062b4d99139f14960daa7ce99d63625833", "patch": "@@ -158,7 +158,7 @@ pub fn eq_expr(l: &Expr, r: &Expr) -> bool {\n         (Unary(lo, l), Unary(ro, r)) => mem::discriminant(lo) == mem::discriminant(ro) && eq_expr(l, r),\n         (Lit(l), Lit(r)) => l.kind == r.kind,\n         (Cast(l, lt), Cast(r, rt)) | (Type(l, lt), Type(r, rt)) => eq_expr(l, r) && eq_ty(lt, rt),\n-        (Let(lp, le), Let(rp, re)) => eq_pat(lp, rp) && eq_expr(le, re),\n+        (Let(lp, le, _), Let(rp, re, _)) => eq_pat(lp, rp) && eq_expr(le, re),\n         (If(lc, lt, le), If(rc, rt, re)) => eq_expr(lc, rc) && eq_block(lt, rt) && eq_expr_opt(le, re),\n         (While(lc, lt, ll), While(rc, rt, rl)) => eq_label(ll, rl) && eq_expr(lc, rc) && eq_block(lt, rt),\n         (ForLoop(lp, li, lt, ll), ForLoop(rp, ri, rt, rl)) => {"}, {"sha": "29e2559fc6d603d45a05b8d0e91b142095f23f57", "filename": "clippy_utils/src/eager_or_lazy.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b97d4c062b4d99139f14960daa7ce99d63625833/clippy_utils%2Fsrc%2Feager_or_lazy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b97d4c062b4d99139f14960daa7ce99d63625833/clippy_utils%2Fsrc%2Feager_or_lazy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Feager_or_lazy.rs?ref=b97d4c062b4d99139f14960daa7ce99d63625833", "patch": "@@ -60,6 +60,7 @@ fn identify_some_pure_patterns(expr: &Expr<'_>) -> bool {\n         | ExprKind::MethodCall(..)\n         | ExprKind::Binary(..)\n         | ExprKind::Unary(..)\n+        | ExprKind::Let(..)\n         | ExprKind::Cast(..)\n         | ExprKind::Type(..)\n         | ExprKind::DropTemps(..)"}, {"sha": "29b698e56e3c0f9e9cfb2dd49444c8769e90ad31", "filename": "clippy_utils/src/higher.rs", "status": "modified", "additions": 363, "deletions": 144, "changes": 507, "blob_url": "https://github.com/rust-lang/rust/blob/b97d4c062b4d99139f14960daa7ce99d63625833/clippy_utils%2Fsrc%2Fhigher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b97d4c062b4d99139f14960daa7ce99d63625833/clippy_utils%2Fsrc%2Fhigher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fhigher.rs?ref=b97d4c062b4d99139f14960daa7ce99d63625833", "patch": "@@ -1,148 +1,219 @@\n-//! This module contains functions for retrieve the original AST from lowered\n-//! `hir`.\n+//! This module contains functions that retrieves specifiec elements.\n \n #![deny(clippy::missing_docs_in_private_items)]\n \n use crate::{is_expn_of, match_def_path, paths};\n use if_chain::if_chain;\n use rustc_ast::ast::{self, LitKind};\n use rustc_hir as hir;\n-use rustc_hir::{BorrowKind, Expr, ExprKind, StmtKind, UnOp};\n+use rustc_hir::{Block, BorrowKind, Expr, ExprKind, LoopSource, Node, Pat, StmtKind, UnOp};\n use rustc_lint::LateContext;\n use rustc_span::{sym, ExpnKind, Span, Symbol};\n \n-/// Represent a range akin to `ast::ExprKind::Range`.\n-#[derive(Debug, Copy, Clone)]\n-pub struct Range<'a> {\n-    /// The lower bound of the range, or `None` for ranges such as `..X`.\n-    pub start: Option<&'a hir::Expr<'a>>,\n-    /// The upper bound of the range, or `None` for ranges such as `X..`.\n-    pub end: Option<&'a hir::Expr<'a>>,\n-    /// Whether the interval is open or closed.\n-    pub limits: ast::RangeLimits,\n+/// The essential nodes of a desugared for loop as well as the entire span:\n+/// `for pat in arg { body }` becomes `(pat, arg, body)`. Return `(pat, arg, body, span)`.\n+pub struct ForLoop<'tcx> {\n+    pub pat: &'tcx hir::Pat<'tcx>,\n+    pub arg: &'tcx hir::Expr<'tcx>,\n+    pub body: &'tcx hir::Expr<'tcx>,\n+    pub span: Span,\n }\n \n-/// Higher a `hir` range to something similar to `ast::ExprKind::Range`.\n-pub fn range<'a>(expr: &'a hir::Expr<'_>) -> Option<Range<'a>> {\n-    /// Finds the field named `name` in the field. Always return `Some` for\n-    /// convenience.\n-    fn get_field<'c>(name: &str, fields: &'c [hir::ExprField<'_>]) -> Option<&'c hir::Expr<'c>> {\n-        let expr = &fields.iter().find(|field| field.ident.name.as_str() == name)?.expr;\n-\n-        Some(expr)\n+impl<'tcx> ForLoop<'tcx> {\n+    #[inline]\n+    pub fn hir(expr: &Expr<'tcx>) -> Option<Self> {\n+        if_chain! {\n+            if let hir::ExprKind::Match(ref iterexpr, ref arms, hir::MatchSource::ForLoopDesugar) = expr.kind;\n+            if let Some(first_arm) = arms.get(0);\n+            if let hir::ExprKind::Call(_, ref iterargs) = iterexpr.kind;\n+            if let Some(first_arg) = iterargs.get(0);\n+            if iterargs.len() == 1 && arms.len() == 1 && first_arm.guard.is_none();\n+            if let hir::ExprKind::Loop(ref block, ..) = first_arm.body.kind;\n+            if block.expr.is_none();\n+            if let [ _, _, ref let_stmt, ref body ] = *block.stmts;\n+            if let hir::StmtKind::Local(ref local) = let_stmt.kind;\n+            if let hir::StmtKind::Expr(ref body_expr) = body.kind;\n+            then {\n+                return Some(Self {\n+                    pat: &*local.pat,\n+                    arg: first_arg,\n+                    body: body_expr,\n+                    span: first_arm.span\n+                });\n+            }\n+        }\n+        None\n     }\n+}\n+\n+pub struct If<'hir> {\n+    pub cond: &'hir Expr<'hir>,\n+    pub r#else: Option<&'hir Expr<'hir>>,\n+    pub then: &'hir Expr<'hir>,\n+}\n \n-    match expr.kind {\n-        hir::ExprKind::Call(path, args)\n-            if matches!(\n-                path.kind,\n-                hir::ExprKind::Path(hir::QPath::LangItem(hir::LangItem::RangeInclusiveNew, _))\n-            ) =>\n+impl<'hir> If<'hir> {\n+    #[inline]\n+    pub const fn hir(expr: &Expr<'hir>) -> Option<Self> {\n+        if let ExprKind::If(\n+            Expr {\n+                kind: ExprKind::DropTemps(cond),\n+                ..\n+            },\n+            then,\n+            r#else,\n+        ) = expr.kind\n         {\n-            Some(Range {\n-                start: Some(&args[0]),\n-                end: Some(&args[1]),\n-                limits: ast::RangeLimits::Closed,\n-            })\n-        },\n-        hir::ExprKind::Struct(path, fields, None) => match path {\n-            hir::QPath::LangItem(hir::LangItem::RangeFull, _) => Some(Range {\n-                start: None,\n-                end: None,\n-                limits: ast::RangeLimits::HalfOpen,\n-            }),\n-            hir::QPath::LangItem(hir::LangItem::RangeFrom, _) => Some(Range {\n-                start: Some(get_field(\"start\", fields)?),\n-                end: None,\n-                limits: ast::RangeLimits::HalfOpen,\n-            }),\n-            hir::QPath::LangItem(hir::LangItem::Range, _) => Some(Range {\n-                start: Some(get_field(\"start\", fields)?),\n-                end: Some(get_field(\"end\", fields)?),\n-                limits: ast::RangeLimits::HalfOpen,\n-            }),\n-            hir::QPath::LangItem(hir::LangItem::RangeToInclusive, _) => Some(Range {\n-                start: None,\n-                end: Some(get_field(\"end\", fields)?),\n-                limits: ast::RangeLimits::Closed,\n-            }),\n-            hir::QPath::LangItem(hir::LangItem::RangeTo, _) => Some(Range {\n-                start: None,\n-                end: Some(get_field(\"end\", fields)?),\n-                limits: ast::RangeLimits::HalfOpen,\n-            }),\n-            _ => None,\n-        },\n-        _ => None,\n+            Some(Self { cond, r#else, then })\n+        } else {\n+            None\n+        }\n     }\n }\n \n-/// Checks if a `let` statement is from a `for` loop desugaring.\n-pub fn is_from_for_desugar(local: &hir::Local<'_>) -> bool {\n-    // This will detect plain for-loops without an actual variable binding:\n-    //\n-    // ```\n-    // for x in some_vec {\n-    //     // do stuff\n-    // }\n-    // ```\n-    if_chain! {\n-        if let Some(expr) = local.init;\n-        if let hir::ExprKind::Match(_, _, hir::MatchSource::ForLoopDesugar) = expr.kind;\n-        then {\n-            return true;\n+pub struct IfLet<'hir> {\n+    pub let_pat: &'hir Pat<'hir>,\n+    pub let_expr: &'hir Expr<'hir>,\n+    pub if_then: &'hir Expr<'hir>,\n+    pub if_else: Option<&'hir Expr<'hir>>,\n+}\n+\n+impl<'hir> IfLet<'hir> {\n+    #[inline]\n+    pub fn ast(cx: &LateContext<'tcx>, expr: &Expr<'hir>) -> Option<Self> {\n+        let rslt = Self::hir(expr)?;\n+        Self::is_not_within_while_context(cx, expr)?;\n+        Some(rslt)\n+    }\n+\n+    #[inline]\n+    pub const fn hir(expr: &Expr<'hir>) -> Option<Self> {\n+        if let ExprKind::If(\n+            Expr {\n+                kind: ExprKind::Let(let_pat, let_expr, _),\n+                ..\n+            },\n+            if_then,\n+            if_else,\n+        ) = expr.kind\n+        {\n+            return Some(Self {\n+                let_pat,\n+                let_expr,\n+                if_then,\n+                if_else,\n+            });\n         }\n+        None\n     }\n \n-    // This detects a variable binding in for loop to avoid `let_unit_value`\n-    // lint (see issue #1964).\n-    //\n-    // ```\n-    // for _ in vec![()] {\n-    //     // anything\n-    // }\n-    // ```\n-    if let hir::LocalSource::ForLoopDesugar = local.source {\n-        return true;\n+    #[inline]\n+    fn is_not_within_while_context(cx: &LateContext<'tcx>, expr: &Expr<'hir>) -> Option<()> {\n+        let hir = cx.tcx.hir();\n+        let parent = hir.get_parent_node(expr.hir_id);\n+        let parent_parent = hir.get_parent_node(parent);\n+        let parent_parent_node = hir.get(parent_parent);\n+        if let Node::Expr(Expr {\n+            kind: ExprKind::Loop(_, _, LoopSource::While, _),\n+            ..\n+        }) = parent_parent_node\n+        {\n+            return None;\n+        }\n+        Some(())\n     }\n+}\n \n-    false\n+pub struct IfOrIfLet<'hir> {\n+    pub cond: &'hir Expr<'hir>,\n+    pub r#else: Option<&'hir Expr<'hir>>,\n+    pub then: &'hir Expr<'hir>,\n }\n \n-/// Recover the essential nodes of a desugared for loop as well as the entire span:\n-/// `for pat in arg { body }` becomes `(pat, arg, body)`. Return `(pat, arg, body, span)`.\n-pub fn for_loop<'tcx>(\n-    expr: &'tcx hir::Expr<'tcx>,\n-) -> Option<(&hir::Pat<'_>, &'tcx hir::Expr<'tcx>, &'tcx hir::Expr<'tcx>, Span)> {\n-    if_chain! {\n-        if let hir::ExprKind::Match(iterexpr, arms, hir::MatchSource::ForLoopDesugar) = expr.kind;\n-        if let hir::ExprKind::Call(_, iterargs) = iterexpr.kind;\n-        if iterargs.len() == 1 && arms.len() == 1 && arms[0].guard.is_none();\n-        if let hir::ExprKind::Loop(block, ..) = arms[0].body.kind;\n-        if block.expr.is_none();\n-        if let [ _, _, ref let_stmt, ref body ] = *block.stmts;\n-        if let hir::StmtKind::Local(local) = let_stmt.kind;\n-        if let hir::StmtKind::Expr(expr) = body.kind;\n-        then {\n-            return Some((&*local.pat, &iterargs[0], expr, arms[0].span));\n+impl<'hir> IfOrIfLet<'hir> {\n+    #[inline]\n+    pub const fn hir(expr: &Expr<'hir>) -> Option<Self> {\n+        if let ExprKind::If(cond, then, r#else) = expr.kind {\n+            if let ExprKind::DropTemps(new_cond) = cond.kind {\n+                return Some(Self {\n+                    cond: new_cond,\n+                    r#else,\n+                    then,\n+                });\n+            }\n+            if let ExprKind::Let(..) = cond.kind {\n+                return Some(Self { cond, r#else, then });\n+            }\n         }\n+        None\n     }\n-    None\n }\n \n-/// Recover the essential nodes of a desugared while loop:\n-/// `while cond { body }` becomes `(cond, body)`.\n-pub fn while_loop<'tcx>(expr: &'tcx hir::Expr<'tcx>) -> Option<(&'tcx hir::Expr<'tcx>, &'tcx hir::Expr<'tcx>)> {\n-    if_chain! {\n-        if let hir::ExprKind::Loop(hir::Block { expr: Some(expr), .. }, _, hir::LoopSource::While, _) = &expr.kind;\n-        if let hir::ExprKind::Match(cond, arms, hir::MatchSource::WhileDesugar) = &expr.kind;\n-        if let hir::ExprKind::DropTemps(cond) = &cond.kind;\n-        if let [hir::Arm { body, .. }, ..] = &arms[..];\n-        then {\n-            return Some((cond, body));\n+/// Represent a range akin to `ast::ExprKind::Range`.\n+#[derive(Debug, Copy, Clone)]\n+pub struct Range<'a> {\n+    /// The lower bound of the range, or `None` for ranges such as `..X`.\n+    pub start: Option<&'a hir::Expr<'a>>,\n+    /// The upper bound of the range, or `None` for ranges such as `X..`.\n+    pub end: Option<&'a hir::Expr<'a>>,\n+    /// Whether the interval is open or closed.\n+    pub limits: ast::RangeLimits,\n+}\n+\n+impl<'a> Range<'a> {\n+    /// Higher a `hir` range to something similar to `ast::ExprKind::Range`.\n+    pub fn hir(expr: &'a hir::Expr<'_>) -> Option<Range<'a>> {\n+        /// Finds the field named `name` in the field. Always return `Some` for\n+        /// convenience.\n+        fn get_field<'c>(name: &str, fields: &'c [hir::ExprField<'_>]) -> Option<&'c hir::Expr<'c>> {\n+            let expr = &fields.iter().find(|field| field.ident.name.as_str() == name)?.expr;\n+            Some(expr)\n+        }\n+\n+        match expr.kind {\n+            hir::ExprKind::Call(ref path, ref args)\n+                if matches!(\n+                    path.kind,\n+                    hir::ExprKind::Path(hir::QPath::LangItem(hir::LangItem::RangeInclusiveNew, _))\n+                ) =>\n+            {\n+                Some(Range {\n+                    start: Some(&args[0]),\n+                    end: Some(&args[1]),\n+                    limits: ast::RangeLimits::Closed,\n+                })\n+            },\n+            hir::ExprKind::Struct(ref path, ref fields, None) => match path {\n+                hir::QPath::LangItem(hir::LangItem::RangeFull, _) => Some(Range {\n+                    start: None,\n+                    end: None,\n+                    limits: ast::RangeLimits::HalfOpen,\n+                }),\n+                hir::QPath::LangItem(hir::LangItem::RangeFrom, _) => Some(Range {\n+                    start: Some(get_field(\"start\", fields)?),\n+                    end: None,\n+                    limits: ast::RangeLimits::HalfOpen,\n+                }),\n+                hir::QPath::LangItem(hir::LangItem::Range, _) => Some(Range {\n+                    start: Some(get_field(\"start\", fields)?),\n+                    end: Some(get_field(\"end\", fields)?),\n+                    limits: ast::RangeLimits::HalfOpen,\n+                }),\n+                hir::QPath::LangItem(hir::LangItem::RangeToInclusive, _) => Some(Range {\n+                    start: None,\n+                    end: Some(get_field(\"end\", fields)?),\n+                    limits: ast::RangeLimits::Closed,\n+                }),\n+                hir::QPath::LangItem(hir::LangItem::RangeTo, _) => Some(Range {\n+                    start: None,\n+                    end: Some(get_field(\"end\", fields)?),\n+                    limits: ast::RangeLimits::HalfOpen,\n+                }),\n+                _ => None,\n+            },\n+            _ => None,\n         }\n     }\n-    None\n }\n \n /// Represent the pre-expansion arguments of a `vec!` invocation.\n@@ -153,41 +224,157 @@ pub enum VecArgs<'a> {\n     Vec(&'a [hir::Expr<'a>]),\n }\n \n-/// Returns the arguments of the `vec!` macro if this expression was expanded\n-/// from `vec!`.\n-pub fn vec_macro<'e>(cx: &LateContext<'_>, expr: &'e hir::Expr<'_>) -> Option<VecArgs<'e>> {\n-    if_chain! {\n-        if let hir::ExprKind::Call(fun, args) = expr.kind;\n-        if let hir::ExprKind::Path(ref qpath) = fun.kind;\n-        if is_expn_of(fun.span, \"vec\").is_some();\n-        if let Some(fun_def_id) = cx.qpath_res(qpath, fun.hir_id).opt_def_id();\n-        then {\n-            return if match_def_path(cx, fun_def_id, &paths::VEC_FROM_ELEM) && args.len() == 2 {\n-                // `vec![elem; size]` case\n-                Some(VecArgs::Repeat(&args[0], &args[1]))\n-            }\n-            else if match_def_path(cx, fun_def_id, &paths::SLICE_INTO_VEC) && args.len() == 1 {\n-                // `vec![a, b, c]` case\n-                if_chain! {\n-                    if let hir::ExprKind::Box(boxed) = args[0].kind;\n-                    if let hir::ExprKind::Array(args) = boxed.kind;\n-                    then {\n-                        return Some(VecArgs::Vec(&*args));\n-                    }\n+impl<'a> VecArgs<'a> {\n+    /// Returns the arguments of the `vec!` macro if this expression was expanded\n+    /// from `vec!`.\n+    pub fn hir(cx: &LateContext<'_>, expr: &'a hir::Expr<'_>) -> Option<VecArgs<'a>> {\n+        if_chain! {\n+            if let hir::ExprKind::Call(ref fun, ref args) = expr.kind;\n+            if let hir::ExprKind::Path(ref qpath) = fun.kind;\n+            if is_expn_of(fun.span, \"vec\").is_some();\n+            if let Some(fun_def_id) = cx.qpath_res(qpath, fun.hir_id).opt_def_id();\n+            then {\n+                return if match_def_path(cx, fun_def_id, &paths::VEC_FROM_ELEM) && args.len() == 2 {\n+                    // `vec![elem; size]` case\n+                    Some(VecArgs::Repeat(&args[0], &args[1]))\n                 }\n+                else if match_def_path(cx, fun_def_id, &paths::SLICE_INTO_VEC) && args.len() == 1 {\n+                    // `vec![a, b, c]` case\n+                    if_chain! {\n+                        if let hir::ExprKind::Box(ref boxed) = args[0].kind;\n+                        if let hir::ExprKind::Array(ref args) = boxed.kind;\n+                        then {\n+                            return Some(VecArgs::Vec(&*args));\n+                        }\n+                    }\n \n-                None\n+                    None\n+                }\n+                else if match_def_path(cx, fun_def_id, &paths::VEC_NEW) && args.is_empty() {\n+                    Some(VecArgs::Vec(&[]))\n+                }\n+                else {\n+                    None\n+                };\n             }\n-            else if match_def_path(cx, fun_def_id, &paths::VEC_NEW) && args.is_empty() {\n-                Some(VecArgs::Vec(&[]))\n+        }\n+\n+        None\n+    }\n+}\n+\n+pub struct While<'hir> {\n+    pub if_cond: &'hir Expr<'hir>,\n+    pub if_then: &'hir Expr<'hir>,\n+    pub if_else: Option<&'hir Expr<'hir>>,\n+}\n+\n+impl<'hir> While<'hir> {\n+    #[inline]\n+    pub const fn hir(expr: &Expr<'hir>) -> Option<Self> {\n+        if let ExprKind::Loop(\n+            Block {\n+                expr:\n+                    Some(Expr {\n+                        kind:\n+                            ExprKind::If(\n+                                Expr {\n+                                    kind: ExprKind::DropTemps(if_cond),\n+                                    ..\n+                                },\n+                                if_then,\n+                                if_else_ref,\n+                            ),\n+                        ..\n+                    }),\n+                ..\n+            },\n+            _,\n+            LoopSource::While,\n+            _,\n+        ) = expr.kind\n+        {\n+            let if_else = *if_else_ref;\n+            return Some(Self {\n+                if_cond,\n+                if_then,\n+                if_else,\n+            });\n+        }\n+        None\n+    }\n+}\n+\n+pub struct WhileLet<'hir> {\n+    pub if_expr: &'hir Expr<'hir>,\n+    pub let_pat: &'hir Pat<'hir>,\n+    pub let_expr: &'hir Expr<'hir>,\n+    pub if_then: &'hir Expr<'hir>,\n+    pub if_else: Option<&'hir Expr<'hir>>,\n+}\n+\n+impl<'hir> WhileLet<'hir> {\n+    #[inline]\n+    pub const fn hir(expr: &Expr<'hir>) -> Option<Self> {\n+        if let ExprKind::Loop(\n+            Block {\n+                expr: Some(if_expr), ..\n+            },\n+            _,\n+            LoopSource::While,\n+            _,\n+        ) = expr.kind\n+        {\n+            if let Expr {\n+                kind:\n+                    ExprKind::If(\n+                        Expr {\n+                            kind: ExprKind::Let(let_pat, let_expr, _),\n+                            ..\n+                        },\n+                        if_then,\n+                        if_else_ref,\n+                    ),\n+                ..\n+            } = if_expr\n+            {\n+                let if_else = *if_else_ref;\n+                return Some(Self {\n+                    if_expr,\n+                    let_pat,\n+                    let_expr,\n+                    if_then,\n+                    if_else,\n+                });\n             }\n-            else {\n-                None\n-            };\n         }\n+        None\n     }\n+}\n \n-    None\n+/// Converts a hir binary operator to the corresponding `ast` type.\n+#[must_use]\n+pub fn binop(op: hir::BinOpKind) -> ast::BinOpKind {\n+    match op {\n+        hir::BinOpKind::Eq => ast::BinOpKind::Eq,\n+        hir::BinOpKind::Ge => ast::BinOpKind::Ge,\n+        hir::BinOpKind::Gt => ast::BinOpKind::Gt,\n+        hir::BinOpKind::Le => ast::BinOpKind::Le,\n+        hir::BinOpKind::Lt => ast::BinOpKind::Lt,\n+        hir::BinOpKind::Ne => ast::BinOpKind::Ne,\n+        hir::BinOpKind::Or => ast::BinOpKind::Or,\n+        hir::BinOpKind::Add => ast::BinOpKind::Add,\n+        hir::BinOpKind::And => ast::BinOpKind::And,\n+        hir::BinOpKind::BitAnd => ast::BinOpKind::BitAnd,\n+        hir::BinOpKind::BitOr => ast::BinOpKind::BitOr,\n+        hir::BinOpKind::BitXor => ast::BinOpKind::BitXor,\n+        hir::BinOpKind::Div => ast::BinOpKind::Div,\n+        hir::BinOpKind::Mul => ast::BinOpKind::Mul,\n+        hir::BinOpKind::Rem => ast::BinOpKind::Rem,\n+        hir::BinOpKind::Shl => ast::BinOpKind::Shl,\n+        hir::BinOpKind::Shr => ast::BinOpKind::Shr,\n+        hir::BinOpKind::Sub => ast::BinOpKind::Sub,\n+    }\n }\n \n /// Extract args from an assert-like macro.\n@@ -218,8 +405,8 @@ pub fn extract_assert_macro_args<'tcx>(e: &'tcx Expr<'tcx>) -> Option<Vec<&'tcx\n             if let StmtKind::Semi(matchexpr) = block.stmts.get(0)?.kind {\n                 // macros with unique arg: `{debug_}assert!` (e.g., `debug_assert!(some_condition)`)\n                 if_chain! {\n-                    if let ExprKind::If(clause, _, _)  = matchexpr.kind;\n-                    if let ExprKind::Unary(UnOp::Not, condition) = clause.kind;\n+                    if let Some(If { cond, .. }) = If::hir(matchexpr);\n+                    if let ExprKind::Unary(UnOp::Not, condition) = cond.kind;\n                     then {\n                         return Some(vec![condition]);\n                     }\n@@ -345,3 +532,35 @@ impl FormatArgsExpn<'tcx> {\n         }\n     }\n }\n+\n+/// Checks if a `let` statement is from a `for` loop desugaring.\n+pub fn is_from_for_desugar(local: &hir::Local<'_>) -> bool {\n+    // This will detect plain for-loops without an actual variable binding:\n+    //\n+    // ```\n+    // for x in some_vec {\n+    //     // do stuff\n+    // }\n+    // ```\n+    if_chain! {\n+        if let Some(ref expr) = local.init;\n+        if let hir::ExprKind::Match(_, _, hir::MatchSource::ForLoopDesugar) = expr.kind;\n+        then {\n+            return true;\n+        }\n+    }\n+\n+    // This detects a variable binding in for loop to avoid `let_unit_value`\n+    // lint (see issue #1964).\n+    //\n+    // ```\n+    // for _ in vec![()] {\n+    //     // anything\n+    // }\n+    // ```\n+    if let hir::LocalSource::ForLoopDesugar = local.source {\n+        return true;\n+    }\n+\n+    false\n+}"}, {"sha": "a44f2df2fd631e9793dd022cc50517a48caa7e07", "filename": "clippy_utils/src/hir_utils.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b97d4c062b4d99139f14960daa7ce99d63625833/clippy_utils%2Fsrc%2Fhir_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b97d4c062b4d99139f14960daa7ce99d63625833/clippy_utils%2Fsrc%2Fhir_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fhir_utils.rs?ref=b97d4c062b4d99139f14960daa7ce99d63625833", "patch": "@@ -232,6 +232,9 @@ impl HirEqInterExpr<'_, '_, '_> {\n             (&ExprKind::If(lc, lt, ref le), &ExprKind::If(rc, rt, ref re)) => {\n                 self.eq_expr(lc, rc) && self.eq_expr(&**lt, &**rt) && both(le, re, |l, r| self.eq_expr(l, r))\n             },\n+            (&ExprKind::Let(ref lp, ref le, _), &ExprKind::Let(ref rp, ref re, _)) => {\n+                self.eq_pat(lp, rp) && self.eq_expr(le, re)\n+            },\n             (&ExprKind::Lit(ref l), &ExprKind::Lit(ref r)) => l.node == r.node,\n             (&ExprKind::Loop(lb, ref ll, ref lls, _), &ExprKind::Loop(rb, ref rl, ref rls, _)) => {\n                 lls == rls && self.eq_block(lb, rb) && both(ll, rl, |l, r| l.ident.name == r.ident.name)\n@@ -665,6 +668,10 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n                     }\n                 }\n             },\n+            ExprKind::Let(ref pat, ref expr, _) => {\n+                self.hash_expr(expr);\n+                self.hash_pat(pat);\n+            },\n             ExprKind::LlvmInlineAsm(..) | ExprKind::Err => {},\n             ExprKind::Lit(ref l) => {\n                 l.node.hash(&mut self.s);"}, {"sha": "82bfce8fe789ed454ed5dadcc6828967d5443d35", "filename": "clippy_utils/src/lib.rs", "status": "modified", "additions": 4, "deletions": 15, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b97d4c062b4d99139f14960daa7ce99d63625833/clippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b97d4c062b4d99139f14960daa7ce99d63625833/clippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Flib.rs?ref=b97d4c062b4d99139f14960daa7ce99d63625833", "patch": "@@ -961,17 +961,6 @@ pub fn is_else_clause(tcx: TyCtxt<'_>, expr: &Expr<'_>) -> bool {\n     let map = tcx.hir();\n     let mut iter = map.parent_iter(expr.hir_id);\n     match iter.next() {\n-        Some((arm_id, Node::Arm(..))) => matches!(\n-            iter.next(),\n-            Some((\n-                _,\n-                Node::Expr(Expr {\n-                    kind: ExprKind::Match(_, [_, else_arm], MatchSource::IfLetDesugar { .. }),\n-                    ..\n-                })\n-            ))\n-            if else_arm.hir_id == arm_id\n-        ),\n         Some((\n             _,\n             Node::Expr(Expr {\n@@ -1370,15 +1359,15 @@ pub fn if_sequence<'tcx>(mut expr: &'tcx Expr<'tcx>) -> (Vec<&'tcx Expr<'tcx>>,\n     let mut conds = Vec::new();\n     let mut blocks: Vec<&Block<'_>> = Vec::new();\n \n-    while let ExprKind::If(cond, then_expr, ref else_expr) = expr.kind {\n-        conds.push(cond);\n-        if let ExprKind::Block(block, _) = then_expr.kind {\n+    while let Some(higher::IfOrIfLet { cond, then, r#else }) = higher::IfOrIfLet::hir(expr) {\n+        conds.push(&*cond);\n+        if let ExprKind::Block(ref block, _) = then.kind {\n             blocks.push(block);\n         } else {\n             panic!(\"ExprKind::If node is not an ExprKind::Block\");\n         }\n \n-        if let Some(else_expr) = *else_expr {\n+        if let Some(ref else_expr) = r#else {\n             expr = else_expr;\n         } else {\n             break;"}, {"sha": "3b494e1fc8535b3430c0c69fdf88b843c9b015af", "filename": "clippy_utils/src/sugg.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b97d4c062b4d99139f14960daa7ce99d63625833/clippy_utils%2Fsrc%2Fsugg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b97d4c062b4d99139f14960daa7ce99d63625833/clippy_utils%2Fsrc%2Fsugg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fsugg.rs?ref=b97d4c062b4d99139f14960daa7ce99d63625833", "patch": "@@ -116,7 +116,7 @@ impl<'a> Sugg<'a> {\n     /// Generate a suggestion for an expression with the given snippet. This is used by the `hir_*`\n     /// function variants of `Sugg`, since these use different snippet functions.\n     fn hir_from_snippet(expr: &hir::Expr<'_>, snippet: Cow<'a, str>) -> Self {\n-        if let Some(range) = higher::range(expr) {\n+        if let Some(range) = higher::Range::hir(expr) {\n             let op = match range.limits {\n                 ast::RangeLimits::HalfOpen => AssocOp::DotDot,\n                 ast::RangeLimits::Closed => AssocOp::DotDotEq,\n@@ -128,6 +128,7 @@ impl<'a> Sugg<'a> {\n             hir::ExprKind::AddrOf(..)\n             | hir::ExprKind::Box(..)\n             | hir::ExprKind::If(..)\n+            | hir::ExprKind::Let(..)\n             | hir::ExprKind::Closure(..)\n             | hir::ExprKind::Unary(..)\n             | hir::ExprKind::Match(..) => Sugg::MaybeParen(snippet),"}, {"sha": "1653de9a6f26d132e449cb48bcbff58f9fdd19d6", "filename": "tests/ui/author/if.stdout", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b97d4c062b4d99139f14960daa7ce99d63625833/tests%2Fui%2Fauthor%2Fif.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/b97d4c062b4d99139f14960daa7ce99d63625833/tests%2Fui%2Fauthor%2Fif.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fauthor%2Fif.stdout?ref=b97d4c062b4d99139f14960daa7ce99d63625833", "patch": "@@ -12,7 +12,8 @@ if_chain! {\n     if let ExprKind::Lit(ref lit1) = right.kind;\n     if let LitKind::Int(2, _) = lit1.node;\n     if block.expr.is_none();\n-    if let ExprKind::Lit(ref lit2) = cond.kind;\n+    if let ExprKind::DropTemps(ref expr) = cond.kind;\n+    if let ExprKind::Lit(ref lit2) = expr.kind;\n     if let LitKind::Bool(true) = lit2.node;\n     if let ExprKind::Block(ref block1) = then.kind;\n     if block1.stmts.len() == 1;"}, {"sha": "f96917f58334429d4da29db842201b2f97a86bf7", "filename": "tests/ui/collapsible_match.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b97d4c062b4d99139f14960daa7ce99d63625833/tests%2Fui%2Fcollapsible_match.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b97d4c062b4d99139f14960daa7ce99d63625833/tests%2Fui%2Fcollapsible_match.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcollapsible_match.stderr?ref=b97d4c062b4d99139f14960daa7ce99d63625833", "patch": "@@ -35,7 +35,7 @@ LL |         Ok(val) => match val {\n LL |             Some(n) => foo(n),\n    |             ^^^^^^^ with this pattern\n \n-error: unnecessary nested match\n+error: unnecessary nested `if let` or `match`\n   --> $DIR/collapsible_match.rs:25:9\n    |\n LL | /         if let Some(n) = val {\n@@ -51,7 +51,7 @@ LL |     if let Ok(val) = res_opt {\n LL |         if let Some(n) = val {\n    |                ^^^^^^^ with this pattern\n \n-error: unnecessary nested match\n+error: unnecessary nested `if let` or `match`\n   --> $DIR/collapsible_match.rs:32:9\n    |\n LL | /         if let Some(n) = val {\n@@ -87,7 +87,7 @@ LL |         match val {\n LL |             Some(n) => foo(n),\n    |             ^^^^^^^ with this pattern\n \n-error: unnecessary nested match\n+error: unnecessary nested `if let` or `match`\n   --> $DIR/collapsible_match.rs:52:13\n    |\n LL | /             if let Some(n) = val {\n@@ -121,7 +121,7 @@ LL |         match val {\n LL |             Some(n) => foo(n),\n    |             ^^^^^^^ with this pattern\n \n-error: unnecessary nested match\n+error: unnecessary nested `if let` or `match`\n   --> $DIR/collapsible_match.rs:72:13\n    |\n LL | /             if let Some(n) = val {"}, {"sha": "85fa421032191505e9d76edd1cb2111d9c4bbce9", "filename": "tests/ui/crashes/ice-7410.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b97d4c062b4d99139f14960daa7ce99d63625833/tests%2Fui%2Fcrashes%2Fice-7410.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b97d4c062b4d99139f14960daa7ce99d63625833/tests%2Fui%2Fcrashes%2Fice-7410.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcrashes%2Fice-7410.rs?ref=b97d4c062b4d99139f14960daa7ce99d63625833", "patch": "@@ -4,6 +4,7 @@\n \n #![feature(lang_items, start, libc)]\n #![no_std]\n+#![allow(clippy::if_same_then_else)]\n #![allow(clippy::redundant_pattern_matching)]\n \n use core::panic::PanicInfo;"}, {"sha": "553c840f9b081420197e772d72f0bff2fd15dc4c", "filename": "tests/ui/crashes/issues_loop_mut_cond.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b97d4c062b4d99139f14960daa7ce99d63625833/tests%2Fui%2Fcrashes%2Fissues_loop_mut_cond.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b97d4c062b4d99139f14960daa7ce99d63625833/tests%2Fui%2Fcrashes%2Fissues_loop_mut_cond.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcrashes%2Fissues_loop_mut_cond.rs?ref=b97d4c062b4d99139f14960daa7ce99d63625833", "patch": "@@ -1,3 +1,4 @@\n+#![allow(clippy::blocks_in_if_conditions)]\n #![allow(dead_code)]\n \n /// Issue: https://github.com/rust-lang/rust-clippy/issues/2596"}, {"sha": "e518b2677b7bf351d73e6941e236641433177d0a", "filename": "tests/ui/infinite_loop.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b97d4c062b4d99139f14960daa7ce99d63625833/tests%2Fui%2Finfinite_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b97d4c062b4d99139f14960daa7ce99d63625833/tests%2Fui%2Finfinite_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Finfinite_loop.rs?ref=b97d4c062b4d99139f14960daa7ce99d63625833", "patch": "@@ -1,3 +1,5 @@\n+#![allow(clippy::blocks_in_if_conditions)]\n+\n fn fn_val(i: i32) -> i32 {\n     unimplemented!()\n }"}, {"sha": "2736753c14b6eccfc33acd4575f63efca21f89e5", "filename": "tests/ui/infinite_loop.stderr", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b97d4c062b4d99139f14960daa7ce99d63625833/tests%2Fui%2Finfinite_loop.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b97d4c062b4d99139f14960daa7ce99d63625833/tests%2Fui%2Finfinite_loop.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Finfinite_loop.stderr?ref=b97d4c062b4d99139f14960daa7ce99d63625833", "patch": "@@ -1,5 +1,5 @@\n error: variables in the condition are not mutated in the loop body\n-  --> $DIR/infinite_loop.rs:21:11\n+  --> $DIR/infinite_loop.rs:23:11\n    |\n LL |     while y < 10 {\n    |           ^^^^^^\n@@ -8,71 +8,71 @@ LL |     while y < 10 {\n    = note: this may lead to an infinite or to a never running loop\n \n error: variables in the condition are not mutated in the loop body\n-  --> $DIR/infinite_loop.rs:26:11\n+  --> $DIR/infinite_loop.rs:28:11\n    |\n LL |     while y < 10 && x < 3 {\n    |           ^^^^^^^^^^^^^^^\n    |\n    = note: this may lead to an infinite or to a never running loop\n \n error: variables in the condition are not mutated in the loop body\n-  --> $DIR/infinite_loop.rs:33:11\n+  --> $DIR/infinite_loop.rs:35:11\n    |\n LL |     while !cond {\n    |           ^^^^^\n    |\n    = note: this may lead to an infinite or to a never running loop\n \n error: variables in the condition are not mutated in the loop body\n-  --> $DIR/infinite_loop.rs:77:11\n+  --> $DIR/infinite_loop.rs:79:11\n    |\n LL |     while i < 3 {\n    |           ^^^^^\n    |\n    = note: this may lead to an infinite or to a never running loop\n \n error: variables in the condition are not mutated in the loop body\n-  --> $DIR/infinite_loop.rs:82:11\n+  --> $DIR/infinite_loop.rs:84:11\n    |\n LL |     while i < 3 && j > 0 {\n    |           ^^^^^^^^^^^^^^\n    |\n    = note: this may lead to an infinite or to a never running loop\n \n error: variables in the condition are not mutated in the loop body\n-  --> $DIR/infinite_loop.rs:86:11\n+  --> $DIR/infinite_loop.rs:88:11\n    |\n LL |     while i < 3 {\n    |           ^^^^^\n    |\n    = note: this may lead to an infinite or to a never running loop\n \n error: variables in the condition are not mutated in the loop body\n-  --> $DIR/infinite_loop.rs:101:11\n+  --> $DIR/infinite_loop.rs:103:11\n    |\n LL |     while i < 3 {\n    |           ^^^^^\n    |\n    = note: this may lead to an infinite or to a never running loop\n \n error: variables in the condition are not mutated in the loop body\n-  --> $DIR/infinite_loop.rs:106:11\n+  --> $DIR/infinite_loop.rs:108:11\n    |\n LL |     while i < 3 {\n    |           ^^^^^\n    |\n    = note: this may lead to an infinite or to a never running loop\n \n error: variables in the condition are not mutated in the loop body\n-  --> $DIR/infinite_loop.rs:172:15\n+  --> $DIR/infinite_loop.rs:174:15\n    |\n LL |         while self.count < n {\n    |               ^^^^^^^^^^^^^^\n    |\n    = note: this may lead to an infinite or to a never running loop\n \n error: variables in the condition are not mutated in the loop body\n-  --> $DIR/infinite_loop.rs:180:11\n+  --> $DIR/infinite_loop.rs:182:11\n    |\n LL |     while y < 10 {\n    |           ^^^^^^\n@@ -82,7 +82,7 @@ LL |     while y < 10 {\n    = help: rewrite it as `if cond { loop { } }`\n \n error: variables in the condition are not mutated in the loop body\n-  --> $DIR/infinite_loop.rs:187:11\n+  --> $DIR/infinite_loop.rs:189:11\n    |\n LL |     while y < 10 {\n    |           ^^^^^^"}, {"sha": "c84e31ea482a48e8fefc32c8d43912acb2e3b874", "filename": "tests/ui/match_overlapping_arm.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b97d4c062b4d99139f14960daa7ce99d63625833/tests%2Fui%2Fmatch_overlapping_arm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b97d4c062b4d99139f14960daa7ce99d63625833/tests%2Fui%2Fmatch_overlapping_arm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatch_overlapping_arm.rs?ref=b97d4c062b4d99139f14960daa7ce99d63625833", "patch": "@@ -2,6 +2,7 @@\n #![feature(half_open_range_patterns)]\n #![warn(clippy::match_overlapping_arm)]\n #![allow(clippy::redundant_pattern_matching)]\n+#![allow(clippy::if_same_then_else)]\n \n /// Tests for match_overlapping_arm\n "}, {"sha": "359fa49f51be73735e65231454cc6bda7fbbbe89", "filename": "tests/ui/match_overlapping_arm.stderr", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b97d4c062b4d99139f14960daa7ce99d63625833/tests%2Fui%2Fmatch_overlapping_arm.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b97d4c062b4d99139f14960daa7ce99d63625833/tests%2Fui%2Fmatch_overlapping_arm.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmatch_overlapping_arm.stderr?ref=b97d4c062b4d99139f14960daa7ce99d63625833", "patch": "@@ -1,60 +1,60 @@\n error: some ranges overlap\n-  --> $DIR/match_overlapping_arm.rs:12:9\n+  --> $DIR/match_overlapping_arm.rs:13:9\n    |\n LL |         0..=10 => println!(\"0 ... 10\"),\n    |         ^^^^^^\n    |\n    = note: `-D clippy::match-overlapping-arm` implied by `-D warnings`\n note: overlaps with this\n-  --> $DIR/match_overlapping_arm.rs:13:9\n+  --> $DIR/match_overlapping_arm.rs:14:9\n    |\n LL |         0..=11 => println!(\"0 ... 11\"),\n    |         ^^^^^^\n \n error: some ranges overlap\n-  --> $DIR/match_overlapping_arm.rs:18:9\n+  --> $DIR/match_overlapping_arm.rs:19:9\n    |\n LL |         0..=5 => println!(\"0 ... 5\"),\n    |         ^^^^^\n    |\n note: overlaps with this\n-  --> $DIR/match_overlapping_arm.rs:20:9\n+  --> $DIR/match_overlapping_arm.rs:21:9\n    |\n LL |         FOO..=11 => println!(\"0 ... 11\"),\n    |         ^^^^^^^^\n \n error: some ranges overlap\n-  --> $DIR/match_overlapping_arm.rs:55:9\n+  --> $DIR/match_overlapping_arm.rs:56:9\n    |\n LL |         0..11 => println!(\"0 .. 11\"),\n    |         ^^^^^\n    |\n note: overlaps with this\n-  --> $DIR/match_overlapping_arm.rs:56:9\n+  --> $DIR/match_overlapping_arm.rs:57:9\n    |\n LL |         0..=11 => println!(\"0 ... 11\"),\n    |         ^^^^^^\n \n error: some ranges overlap\n-  --> $DIR/match_overlapping_arm.rs:80:9\n+  --> $DIR/match_overlapping_arm.rs:81:9\n    |\n LL |         0..=10 => println!(\"0 ... 10\"),\n    |         ^^^^^^\n    |\n note: overlaps with this\n-  --> $DIR/match_overlapping_arm.rs:79:9\n+  --> $DIR/match_overlapping_arm.rs:80:9\n    |\n LL |         5..14 => println!(\"5 .. 14\"),\n    |         ^^^^^\n \n error: some ranges overlap\n-  --> $DIR/match_overlapping_arm.rs:85:9\n+  --> $DIR/match_overlapping_arm.rs:86:9\n    |\n LL |         0..7 => println!(\"0 .. 7\"),\n    |         ^^^^\n    |\n note: overlaps with this\n-  --> $DIR/match_overlapping_arm.rs:86:9\n+  --> $DIR/match_overlapping_arm.rs:87:9\n    |\n LL |         0..=10 => println!(\"0 ... 10\"),\n    |         ^^^^^^"}]}