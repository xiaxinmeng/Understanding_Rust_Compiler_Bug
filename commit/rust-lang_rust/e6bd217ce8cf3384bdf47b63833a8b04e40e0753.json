{"sha": "e6bd217ce8cf3384bdf47b63833a8b04e40e0753", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU2YmQyMTdjZThjZjMzODRiZGY0N2I2MzgzM2E4YjA0ZTQwZTA3NTM=", "commit": {"author": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2014-11-27T19:19:27Z"}, "committer": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2014-12-07T00:05:58Z"}, "message": "librustdoc: remove unnecessary `as_slice()` calls", "tree": {"sha": "44e318064e488880fa024ed844e08d52461e142b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/44e318064e488880fa024ed844e08d52461e142b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e6bd217ce8cf3384bdf47b63833a8b04e40e0753", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e6bd217ce8cf3384bdf47b63833a8b04e40e0753", "html_url": "https://github.com/rust-lang/rust/commit/e6bd217ce8cf3384bdf47b63833a8b04e40e0753", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e6bd217ce8cf3384bdf47b63833a8b04e40e0753/comments", "author": null, "committer": null, "parents": [{"sha": "8bb5ef9df5aeb7e46a9ad9350aaf9086d05f0556", "url": "https://api.github.com/repos/rust-lang/rust/commits/8bb5ef9df5aeb7e46a9ad9350aaf9086d05f0556", "html_url": "https://github.com/rust-lang/rust/commit/8bb5ef9df5aeb7e46a9ad9350aaf9086d05f0556"}], "stats": {"total": 78, "additions": 39, "deletions": 39}, "files": [{"sha": "3ee07df6ed447d38336a711143678a98f7768382", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e6bd217ce8cf3384bdf47b63833a8b04e40e0753/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6bd217ce8cf3384bdf47b63833a8b04e40e0753/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=e6bd217ce8cf3384bdf47b63833a8b04e40e0753", "patch": "@@ -341,10 +341,10 @@ fn build_impl(cx: &DocContext, tcx: &ty::ctxt,\n \n     fn is_doc_hidden(a: &clean::Attribute) -> bool {\n         match *a {\n-            clean::List(ref name, ref inner) if name.as_slice() == \"doc\" => {\n+            clean::List(ref name, ref inner) if *name == \"doc\" => {\n                 inner.iter().any(|a| {\n                     match *a {\n-                        clean::Word(ref s) => s.as_slice() == \"hidden\",\n+                        clean::Word(ref s) => *s == \"hidden\",\n                         _ => false,\n                     }\n                 })"}, {"sha": "bc870d39c5d7ff924440fc546e6497e296e84b8c", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e6bd217ce8cf3384bdf47b63833a8b04e40e0753/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6bd217ce8cf3384bdf47b63833a8b04e40e0753/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=e6bd217ce8cf3384bdf47b63833a8b04e40e0753", "patch": "@@ -256,7 +256,7 @@ impl Item {\n     pub fn doc_list<'a>(&'a self) -> Option<&'a [Attribute]> {\n         for attr in self.attrs.iter() {\n             match *attr {\n-                List(ref x, ref list) if \"doc\" == x.as_slice() => {\n+                List(ref x, ref list) if \"doc\" == *x => {\n                     return Some(list.as_slice());\n                 }\n                 _ => {}\n@@ -270,7 +270,7 @@ impl Item {\n     pub fn doc_value<'a>(&'a self) -> Option<&'a str> {\n         for attr in self.attrs.iter() {\n             match *attr {\n-                NameValue(ref x, ref v) if \"doc\" == x.as_slice() => {\n+                NameValue(ref x, ref v) if \"doc\" == *x => {\n                     return Some(v.as_slice());\n                 }\n                 _ => {}\n@@ -284,7 +284,7 @@ impl Item {\n             Some(ref l) => {\n                 for innerattr in l.iter() {\n                     match *innerattr {\n-                        Word(ref s) if \"hidden\" == s.as_slice() => {\n+                        Word(ref s) if \"hidden\" == *s => {\n                             return true\n                         }\n                         _ => (),\n@@ -1217,13 +1217,13 @@ impl PrimitiveType {\n     fn find(attrs: &[Attribute]) -> Option<PrimitiveType> {\n         for attr in attrs.iter() {\n             let list = match *attr {\n-                List(ref k, ref l) if k.as_slice() == \"doc\" => l,\n+                List(ref k, ref l) if *k == \"doc\" => l,\n                 _ => continue,\n             };\n             for sub_attr in list.iter() {\n                 let value = match *sub_attr {\n                     NameValue(ref k, ref v)\n-                        if k.as_slice() == \"primitive\" => v.as_slice(),\n+                        if *k == \"primitive\" => v.as_slice(),\n                     _ => continue,\n                 };\n                 match PrimitiveType::from_str(value) {"}, {"sha": "0fca59962d40c3ecd5667f9f997fce9558c51407", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e6bd217ce8cf3384bdf47b63833a8b04e40e0753/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6bd217ce8cf3384bdf47b63833a8b04e40e0753/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=e6bd217ce8cf3384bdf47b63833a8b04e40e0753", "patch": "@@ -251,8 +251,8 @@ fn path(w: &mut fmt::Formatter, path: &clean::Path, print_all: bool,\n             Some(root) => {\n                 let mut root = String::from_str(root.as_slice());\n                 for seg in path.segments[..amt].iter() {\n-                    if \"super\" == seg.name.as_slice() ||\n-                            \"self\" == seg.name.as_slice() {\n+                    if \"super\" == seg.name ||\n+                            \"self\" == seg.name {\n                         try!(write!(w, \"{}::\", seg.name));\n                     } else {\n                         root.push_str(seg.name.as_slice());\n@@ -337,7 +337,7 @@ fn primitive_link(f: &mut fmt::Formatter,\n                 Some(root) => {\n                     try!(write!(f, \"<a href='{}{}/primitive.{}.html'>\",\n                                 root,\n-                                path.ref0().as_slice().head().unwrap(),\n+                                path.ref0().head().unwrap(),\n                                 prim.to_url_str()));\n                     needs_termination = true;\n                 }"}, {"sha": "10563c61e1465d93bd095ecaa93c97e7850a6b3c", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e6bd217ce8cf3384bdf47b63833a8b04e40e0753/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6bd217ce8cf3384bdf47b63833a8b04e40e0753/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=e6bd217ce8cf3384bdf47b63833a8b04e40e0753", "patch": "@@ -231,7 +231,7 @@ pub fn render(w: &mut fmt::Formatter, s: &str, print_toc: bool) -> fmt::Result {\n         };\n \n         // Transform the contents of the header into a hyphenated string\n-        let id = s.as_slice().words().map(|s| s.to_ascii_lower())\n+        let id = s.words().map(|s| s.to_ascii_lower())\n             .collect::<Vec<String>>().connect(\"-\");\n \n         // This is a terrible hack working around how hoedown gives us rendered\n@@ -393,7 +393,7 @@ impl LangString {\n         let mut seen_other_tags = false;\n         let mut data = LangString::all_false();\n \n-        let mut tokens = string.as_slice().split(|c: char|\n+        let mut tokens = string.split(|c: char|\n             !(c == '_' || c == '-' || c.is_alphanumeric())\n         );\n "}, {"sha": "79ab452dba626ba48e516dbe6f96e9a2498259a7", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e6bd217ce8cf3384bdf47b63833a8b04e40e0753/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6bd217ce8cf3384bdf47b63833a8b04e40e0753/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=e6bd217ce8cf3384bdf47b63833a8b04e40e0753", "patch": "@@ -277,15 +277,15 @@ pub fn run(mut krate: clean::Crate,\n             for attr in attrs.iter() {\n                 match *attr {\n                     clean::NameValue(ref x, ref s)\n-                            if \"html_favicon_url\" == x.as_slice() => {\n+                            if \"html_favicon_url\" == *x => {\n                         cx.layout.favicon = s.to_string();\n                     }\n                     clean::NameValue(ref x, ref s)\n-                            if \"html_logo_url\" == x.as_slice() => {\n+                            if \"html_logo_url\" == *x => {\n                         cx.layout.logo = s.to_string();\n                     }\n                     clean::NameValue(ref x, ref s)\n-                            if \"html_playground_url\" == x.as_slice() => {\n+                            if \"html_playground_url\" == *x => {\n                         cx.layout.playground_url = s.to_string();\n                         markdown::PLAYGROUND_KRATE.with(|slot| {\n                             if slot.borrow().is_none() {\n@@ -295,7 +295,7 @@ pub fn run(mut krate: clean::Crate,\n                         });\n                     }\n                     clean::Word(ref x)\n-                            if \"html_no_source\" == x.as_slice() => {\n+                            if \"html_no_source\" == *x => {\n                         cx.include_sources = false;\n                     }\n                     _ => {}\n@@ -434,7 +434,7 @@ fn build_index(krate: &clean::Crate, cache: &mut Cache) -> io::IoResult<String>\n     for (i, item) in cache.search_index.iter().enumerate() {\n         // Omit the path if it is same to that of the prior item.\n         let path;\n-        if lastpath.as_slice() == item.path.as_slice() {\n+        if lastpath == item.path {\n             path = \"\";\n         } else {\n             lastpath = item.path.to_string();\n@@ -513,10 +513,10 @@ fn write_shared(cx: &Context,\n         if path.exists() {\n             for line in BufferedReader::new(File::open(path)).lines() {\n                 let line = try!(line);\n-                if !line.as_slice().starts_with(key) {\n+                if !line.starts_with(key) {\n                     continue\n                 }\n-                if line.as_slice().starts_with(\n+                if line.starts_with(\n                         format!(\"{}['{}']\", key, krate).as_slice()) {\n                     continue\n                 }\n@@ -670,12 +670,12 @@ fn extern_location(e: &clean::ExternalCrate, dst: &Path) -> ExternalLocation {\n     // external crate\n     for attr in e.attrs.iter() {\n         match *attr {\n-            clean::List(ref x, ref list) if \"doc\" == x.as_slice() => {\n+            clean::List(ref x, ref list) if \"doc\" == *x => {\n                 for attr in list.iter() {\n                     match *attr {\n                         clean::NameValue(ref x, ref s)\n-                                if \"html_root_url\" == x.as_slice() => {\n-                            if s.as_slice().ends_with(\"/\") {\n+                                if \"html_root_url\" == *x => {\n+                            if s.ends_with(\"/\") {\n                                 return Remote(s.to_string());\n                             }\n                             return Remote(format!(\"{}/\", s));\n@@ -964,7 +964,7 @@ impl DocFolder for Cache {\n                         let dox = match attrs.into_iter().find(|a| {\n                             match *a {\n                                 clean::NameValue(ref x, _)\n-                                        if \"doc\" == x.as_slice() => {\n+                                        if \"doc\" == *x => {\n                                     true\n                                 }\n                                 _ => false"}, {"sha": "6d9e8dc722f8a6b09850a7fdd3d7370a077f80b5", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e6bd217ce8cf3384bdf47b63833a8b04e40e0753/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6bd217ce8cf3384bdf47b63833a8b04e40e0753/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=e6bd217ce8cf3384bdf47b63833a8b04e40e0753", "patch": "@@ -299,7 +299,7 @@ fn acquire_input(input: &str,\n fn parse_externs(matches: &getopts::Matches) -> Result<core::Externs, String> {\n     let mut externs = HashMap::new();\n     for arg in matches.opt_strs(\"extern\").iter() {\n-        let mut parts = arg.as_slice().splitn(1, '=');\n+        let mut parts = arg.splitn(1, '=');\n         let name = match parts.next() {\n             Some(s) => s,\n             None => {\n@@ -363,18 +363,18 @@ fn rust_input(cratefile: &str, externs: core::Externs, matches: &getopts::Matche\n             for inner in nested.iter() {\n                 match *inner {\n                     clean::Word(ref x)\n-                            if \"no_default_passes\" == x.as_slice() => {\n+                            if \"no_default_passes\" == *x => {\n                         default_passes = false;\n                     }\n                     clean::NameValue(ref x, ref value)\n-                            if \"passes\" == x.as_slice() => {\n-                        for pass in value.as_slice().words() {\n+                            if \"passes\" == *x => {\n+                        for pass in value.words() {\n                             passes.push(pass.to_string());\n                         }\n                     }\n                     clean::NameValue(ref x, ref value)\n-                            if \"plugins\" == x.as_slice() => {\n-                        for p in value.as_slice().words() {\n+                            if \"plugins\" == *x => {\n+                        for p in value.words() {\n                             plugins.push(p.to_string());\n                         }\n                     }\n@@ -397,7 +397,7 @@ fn rust_input(cratefile: &str, externs: core::Externs, matches: &getopts::Matche\n     for pass in passes.iter() {\n         let plugin = match PASSES.iter()\n                                  .position(|&(p, _, _)| {\n-                                     p == pass.as_slice()\n+                                     p == *pass\n                                  }) {\n             Some(i) => PASSES[i].val1(),\n             None => {\n@@ -434,7 +434,7 @@ fn json_input(input: &str) -> Result<Output, String> {\n             // Make sure the schema is what we expect\n             match obj.remove(&\"schema\".to_string()) {\n                 Some(Json::String(version)) => {\n-                    if version.as_slice() != SCHEMA_VERSION {\n+                    if version != SCHEMA_VERSION {\n                         return Err(format!(\n                                 \"sorry, but I only understand version {}\",\n                                 SCHEMA_VERSION))"}, {"sha": "e368d7f93320c74c3c01ce03f32881b7b458abfd", "filename": "src/librustdoc/passes.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e6bd217ce8cf3384bdf47b63833a8b04e40e0753/src%2Flibrustdoc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e6bd217ce8cf3384bdf47b63833a8b04e40e0753/src%2Flibrustdoc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses.rs?ref=e6bd217ce8cf3384bdf47b63833a8b04e40e0753", "patch": "@@ -258,7 +258,7 @@ pub fn unindent_comments(krate: clean::Crate) -> plugins::PluginResult {\n             for attr in i.attrs.iter() {\n                 match attr {\n                     &clean::NameValue(ref x, ref s)\n-                            if \"doc\" == x.as_slice() => {\n+                            if \"doc\" == *x => {\n                         avec.push(clean::NameValue(\"doc\".to_string(),\n                                                    unindent(s.as_slice())))\n                     }\n@@ -283,15 +283,15 @@ pub fn collapse_docs(krate: clean::Crate) -> plugins::PluginResult {\n             for attr in i.attrs.iter() {\n                 match *attr {\n                     clean::NameValue(ref x, ref s)\n-                            if \"doc\" == x.as_slice() => {\n+                            if \"doc\" == *x => {\n                         docstr.push_str(s.as_slice());\n                         docstr.push('\\n');\n                     },\n                     _ => ()\n                 }\n             }\n             let mut a: Vec<clean::Attribute> = i.attrs.iter().filter(|&a| match a {\n-                &clean::NameValue(ref x, _) if \"doc\" == x.as_slice() => false,\n+                &clean::NameValue(ref x, _) if \"doc\" == *x => false,\n                 _ => true\n             }).map(|x| x.clone()).collect();\n             if docstr.len() > 0 {\n@@ -374,14 +374,14 @@ mod unindent_tests {\n     fn should_unindent() {\n         let s = \"    line1\\n    line2\".to_string();\n         let r = unindent(s.as_slice());\n-        assert_eq!(r.as_slice(), \"line1\\nline2\");\n+        assert_eq!(r, \"line1\\nline2\");\n     }\n \n     #[test]\n     fn should_unindent_multiple_paragraphs() {\n         let s = \"    line1\\n\\n    line2\".to_string();\n         let r = unindent(s.as_slice());\n-        assert_eq!(r.as_slice(), \"line1\\n\\nline2\");\n+        assert_eq!(r, \"line1\\n\\nline2\");\n     }\n \n     #[test]\n@@ -390,7 +390,7 @@ mod unindent_tests {\n         // base indentation and should be preserved\n         let s = \"    line1\\n\\n        line2\".to_string();\n         let r = unindent(s.as_slice());\n-        assert_eq!(r.as_slice(), \"line1\\n\\n    line2\");\n+        assert_eq!(r, \"line1\\n\\n    line2\");\n     }\n \n     #[test]\n@@ -402,13 +402,13 @@ mod unindent_tests {\n         //          and continue here\"]\n         let s = \"line1\\n    line2\".to_string();\n         let r = unindent(s.as_slice());\n-        assert_eq!(r.as_slice(), \"line1\\nline2\");\n+        assert_eq!(r, \"line1\\nline2\");\n     }\n \n     #[test]\n     fn should_not_ignore_first_line_indent_in_a_single_line_para() {\n         let s = \"line1\\n\\n    line2\".to_string();\n         let r = unindent(s.as_slice());\n-        assert_eq!(r.as_slice(), \"line1\\n\\n    line2\");\n+        assert_eq!(r, \"line1\\n\\n    line2\");\n     }\n }"}]}