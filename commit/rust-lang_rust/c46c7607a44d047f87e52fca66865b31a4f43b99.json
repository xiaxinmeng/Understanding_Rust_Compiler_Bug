{"sha": "c46c7607a44d047f87e52fca66865b31a4f43b99", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM0NmM3NjA3YTQ0ZDA0N2Y4N2U1MmZjYTY2ODY1YjMxYTRmNDNiOTk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-04-22T12:06:33Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-04-22T12:06:33Z"}, "message": "auto merge of #13653 : jbcrail/rust/fix-comment-mistakes, r=alexcrichton", "tree": {"sha": "9cfa9e1439dc02643b279fca674a9de9041047ec", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9cfa9e1439dc02643b279fca674a9de9041047ec"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c46c7607a44d047f87e52fca66865b31a4f43b99", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c46c7607a44d047f87e52fca66865b31a4f43b99", "html_url": "https://github.com/rust-lang/rust/commit/c46c7607a44d047f87e52fca66865b31a4f43b99", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c46c7607a44d047f87e52fca66865b31a4f43b99/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ef1b929b2f732f96d6f9357467cf7b45b85c5413", "url": "https://api.github.com/repos/rust-lang/rust/commits/ef1b929b2f732f96d6f9357467cf7b45b85c5413", "html_url": "https://github.com/rust-lang/rust/commit/ef1b929b2f732f96d6f9357467cf7b45b85c5413"}, {"sha": "809f13ea9441d972b5777a9c8bf837add9484a45", "url": "https://api.github.com/repos/rust-lang/rust/commits/809f13ea9441d972b5777a9c8bf837add9484a45", "html_url": "https://github.com/rust-lang/rust/commit/809f13ea9441d972b5777a9c8bf837add9484a45"}], "stats": {"total": 106, "additions": 53, "deletions": 53}, "files": [{"sha": "b6dc790ea88a06939c1edc1d999b49eac4b81547", "filename": "src/libcollections/btree.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c46c7607a44d047f87e52fca66865b31a4f43b99/src%2Flibcollections%2Fbtree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c46c7607a44d047f87e52fca66865b31a4f43b99/src%2Flibcollections%2Fbtree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree.rs?ref=c46c7607a44d047f87e52fca66865b31a4f43b99", "patch": "@@ -659,13 +659,13 @@ impl<K: fmt::Show + TotalOrd, V: fmt::Show> fmt::Show for Branch<K, V> {\n     }\n }\n \n-//A LeafElt containts no left child, but a key-value pair.\n+//A LeafElt contains no left child, but a key-value pair.\n struct LeafElt<K, V> {\n     key: K,\n     value: V\n }\n \n-//A BranchElt has a left child in insertition to a key-value pair.\n+//A BranchElt has a left child in insertion to a key-value pair.\n struct BranchElt<K, V> {\n     left: ~Node<K, V>,\n     key: K,"}, {"sha": "f6a2b1c6250394a4bc9289d66165e607e21465e6", "filename": "src/libcollections/hashmap.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c46c7607a44d047f87e52fca66865b31a4f43b99/src%2Flibcollections%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c46c7607a44d047f87e52fca66865b31a4f43b99/src%2Flibcollections%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fhashmap.rs?ref=c46c7607a44d047f87e52fca66865b31a4f43b99", "patch": "@@ -605,7 +605,7 @@ static INITIAL_LOAD_FACTOR: Fraction = (9, 10);\n //\n // > Why a load factor of 90%?\n //\n-// In general, all the distances to inital buckets will converge on the mean.\n+// In general, all the distances to initial buckets will converge on the mean.\n // At a load factor of \u03b1, the odds of finding the target bucket after k\n // probes is approximately 1-\u03b1^k. If we set this equal to 50% (since we converge\n // on the mean) and set k=8 (64-byte cache line / 8-byte hash), \u03b1=0.92. I round\n@@ -618,7 +618,7 @@ static INITIAL_LOAD_FACTOR: Fraction = (9, 10);\n // > Wait, what? Where did you get 1-\u03b1^k from?\n //\n // On the first probe, your odds of a collision with an existing element is \u03b1.\n-// The odds of doing this twice in a row is approximatelly \u03b1^2. For three times,\n+// The odds of doing this twice in a row is approximately \u03b1^2. For three times,\n // \u03b1^3, etc. Therefore, the odds of colliding k times is \u03b1^k. The odds of NOT\n // colliding after k tries is 1-\u03b1^k.\n //\n@@ -692,7 +692,7 @@ static INITIAL_LOAD_FACTOR: Fraction = (9, 10);\n /// let mut book_reviews = HashMap::new();\n ///\n /// // review some books.\n-/// book_reviews.insert(\"Adventures of Hucklebury Fin\",      \"My favorite book.\");\n+/// book_reviews.insert(\"Adventures of Huckleberry Finn\",    \"My favorite book.\");\n /// book_reviews.insert(\"Grimms' Fairy Tales\",               \"Masterpiece.\");\n /// book_reviews.insert(\"Pride and Prejudice\",               \"Very enjoyable.\");\n /// book_reviews.insert(\"The Adventures of Sherlock Holmes\", \"Eye lyked it alot.\");\n@@ -782,7 +782,7 @@ impl<K: TotalEq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// from its 'ideal' location.\n     ///\n     /// In the cited blog posts above, this is called the \"distance to\n-    /// inital bucket\", or DIB.\n+    /// initial bucket\", or DIB.\n     fn bucket_distance(&self, index_of_elem: &table::FullIndex) -> uint {\n         // where the hash of the element that happens to reside at\n         // `index_of_elem` tried to place itself first."}, {"sha": "dc8e64ed86b505ffa08bbd1c4812ef0402dcee7d", "filename": "src/libcollections/treemap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c46c7607a44d047f87e52fca66865b31a4f43b99/src%2Flibcollections%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c46c7607a44d047f87e52fca66865b31a4f43b99/src%2Flibcollections%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftreemap.rs?ref=c46c7607a44d047f87e52fca66865b31a4f43b99", "patch": "@@ -308,7 +308,7 @@ pub struct RevMutEntries<'a, K, V> {\n // (with many different `x`) below, so we need to optionally pass mut\n // as a tt, but the only thing we can do with a `tt` is pass them to\n // other macros, so this takes the `& <mutability> <operand>` token\n-// sequence and forces their evalutation as an expression.\n+// sequence and forces their evaluation as an expression.\n macro_rules! addr { ($e:expr) => { $e }}\n // putting an optional mut into type signatures\n macro_rules! item { ($i:item) => { $i }}"}, {"sha": "e040bb0a9e5a21172485e07a92418cdc537dd925", "filename": "src/libcollections/trie.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c46c7607a44d047f87e52fca66865b31a4f43b99/src%2Flibcollections%2Ftrie.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c46c7607a44d047f87e52fca66865b31a4f43b99/src%2Flibcollections%2Ftrie.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftrie.rs?ref=c46c7607a44d047f87e52fca66865b31a4f43b99", "patch": "@@ -141,7 +141,7 @@ impl<T> TrieMap<T> {\n // (with many different `x`) below, so we need to optionally pass mut\n // as a tt, but the only thing we can do with a `tt` is pass them to\n // other macros, so this takes the `& <mutability> <operand>` token\n-// sequence and forces their evalutation as an expression. (see also\n+// sequence and forces their evaluation as an expression. (see also\n // `item!` below.)\n macro_rules! addr { ($e:expr) => { $e } }\n "}, {"sha": "e68c5f227289a1b4edbf6ee594c7fff175c1085d", "filename": "src/libnum/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c46c7607a44d047f87e52fca66865b31a4f43b99/src%2Flibnum%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c46c7607a44d047f87e52fca66865b31a4f43b99/src%2Flibnum%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnum%2Flib.rs?ref=c46c7607a44d047f87e52fca66865b31a4f43b99", "patch": "@@ -171,7 +171,7 @@ macro_rules! impl_integer_for_int {\n             /// `other`.\n             #[inline]\n             fn lcm(&self, other: &$T) -> $T {\n-                // should not have to recaluculate abs\n+                // should not have to recalculate abs\n                 ((*self * *other) / self.gcd(other)).abs()\n             }\n "}, {"sha": "9fd3894d7948e831878505f396eaa662c8478c2d", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c46c7607a44d047f87e52fca66865b31a4f43b99/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c46c7607a44d047f87e52fca66865b31a4f43b99/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=c46c7607a44d047f87e52fca66865b31a4f43b99", "patch": "@@ -1171,7 +1171,7 @@ fn link_args(sess: &Session,\n         // actually creates \"invalid\" objects [1] [2], but only for some\n         // introspection tools, not in terms of whether it can be loaded.\n         //\n-        // Long story shory, passing this flag forces the linker to *not*\n+        // Long story short, passing this flag forces the linker to *not*\n         // truncate section names (so we can find the metadata section after\n         // it's compiled). The real kicker is that rust compiled just fine on\n         // windows for quite a long time *without* this flag, so I have no idea\n@@ -1491,7 +1491,7 @@ fn add_upstream_rust_crates(args: &mut Vec<~str>, sess: &Session,\n }\n \n // Link in all of our upstream crates' native dependencies. Remember that\n-// all of these upstream native depenencies are all non-static\n+// all of these upstream native dependencies are all non-static\n // dependencies. We've got two cases then:\n //\n // 1. The upstream crate is an rlib. In this case we *must* link in the\n@@ -1509,7 +1509,7 @@ fn add_upstream_rust_crates(args: &mut Vec<~str>, sess: &Session,\n // be instantiated in the target crate, meaning that the native symbol must\n // also be resolved in the target crate.\n fn add_upstream_native_libraries(args: &mut Vec<~str>, sess: &Session) {\n-    // Be sure to use a topological sorting of crates becuase there may be\n+    // Be sure to use a topological sorting of crates because there may be\n     // interdependencies between native libraries. When passing -nodefaultlibs,\n     // for example, almost all native libraries depend on libc, so we have to\n     // make sure that's all the way at the right (liblibc is near the base of"}, {"sha": "633850f37180d3a44becc0658704b3da33b920af", "filename": "src/librustc/back/svh.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c46c7607a44d047f87e52fca66865b31a4f43b99/src%2Flibrustc%2Fback%2Fsvh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c46c7607a44d047f87e52fca66865b31a4f43b99/src%2Flibrustc%2Fback%2Fsvh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Fsvh.rs?ref=c46c7607a44d047f87e52fca66865b31a4f43b99", "patch": "@@ -20,7 +20,7 @@\n //! such.\n //!\n //! The core of this problem is when an upstream dependency changes and\n-//! downstream dependants are not recompiled. This causes compile errors because\n+//! downstream dependents are not recompiled. This causes compile errors because\n //! the upstream crate's metadata has changed but the downstream crates are\n //! still referencing the older crate's metadata.\n //!"}, {"sha": "bd95ba95c70d9c1ee3cdf85b6335ca331b83fd40", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c46c7607a44d047f87e52fca66865b31a4f43b99/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c46c7607a44d047f87e52fca66865b31a4f43b99/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=c46c7607a44d047f87e52fca66865b31a4f43b99", "patch": "@@ -222,7 +222,7 @@ impl<'a> Context<'a> {\n         //\n         // A Library candidate is created if the metadata for the set of\n         // libraries corresponds to the crate id and hash criteria that this\n-        // serach is being performed for.\n+        // search is being performed for.\n         let mut libraries = Vec::new();\n         for (_hash, (rlibs, dylibs)) in candidates.move_iter() {\n             let mut metadata = None;\n@@ -278,7 +278,7 @@ impl<'a> Context<'a> {\n     // rlib/dylib).\n     //\n     // The return value is `None` if `file` doesn't look like a rust-generated\n-    // library, or if a specific version was requested and it doens't match the\n+    // library, or if a specific version was requested and it doesn't match the\n     // apparent file's version.\n     //\n     // If everything checks out, then `Some(hash)` is returned where `hash` is"}, {"sha": "413c6a4de1d036d1fcafd70aad88557800b005fc", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c46c7607a44d047f87e52fca66865b31a4f43b99/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c46c7607a44d047f87e52fca66865b31a4f43b99/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=c46c7607a44d047f87e52fca66865b31a4f43b99", "patch": "@@ -275,7 +275,7 @@ fn create_and_seed_worklist(tcx: &ty::ctxt,\n         None => ()\n     }\n \n-    // Seed implemeneted trait methods\n+    // Seed implemented trait methods\n     let mut life_seeder = LifeSeeder {\n         worklist: worklist\n     };"}, {"sha": "a189b9776356e85608bcb556344d32d47221a252", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c46c7607a44d047f87e52fca66865b31a4f43b99/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c46c7607a44d047f87e52fca66865b31a4f43b99/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=c46c7607a44d047f87e52fca66865b31a4f43b99", "patch": "@@ -480,7 +480,7 @@ fn visit_expr(ir: &mut IrMaps, expr: &Expr) {\n                     // var must be dead afterwards\n                     moves::CapMove => true,\n \n-                    // var can stil be used\n+                    // var can still be used\n                     moves::CapCopy | moves::CapRef => false\n                 };\n                 call_caps.push(CaptureInfo {ln: cv_ln,\n@@ -613,7 +613,7 @@ impl<'a> Liveness<'a> {\n                          f: |&mut Liveness<'a>, LiveNode, Variable, Span, NodeId|) {\n         // only consider the first pattern; any later patterns must have\n         // the same bindings, and we also consider the first pattern to be\n-        // the \"authoratative\" set of ids\n+        // the \"authoritative\" set of ids\n         if !pats.is_empty() {\n             self.pat_bindings(pats[0], f)\n         }"}, {"sha": "1e160df106124700a58cdb1e9eb56a253e1a78c0", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c46c7607a44d047f87e52fca66865b31a4f43b99/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c46c7607a44d047f87e52fca66865b31a4f43b99/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=c46c7607a44d047f87e52fca66865b31a4f43b99", "patch": "@@ -63,7 +63,7 @@ impl Visitor<()> for ParentVisitor {\n         let prev = self.curparent;\n         match item.node {\n             ast::ItemMod(..) => { self.curparent = item.id; }\n-            // Enum variants are parented to the enum definition itself beacuse\n+            // Enum variants are parented to the enum definition itself because\n             // they inherit privacy\n             ast::ItemEnum(ref def, _) => {\n                 for variant in def.variants.iter() {\n@@ -1034,7 +1034,7 @@ impl<'a> Visitor<()> for SanePrivacyVisitor<'a> {\n }\n \n impl<'a> SanePrivacyVisitor<'a> {\n-    /// Validates all of the visibility qualifers placed on the item given. This\n+    /// Validates all of the visibility qualifiers placed on the item given. This\n     /// ensures that there are no extraneous qualifiers that don't actually do\n     /// anything. In theory these qualifiers wouldn't parse, but that may happen\n     /// later on down the road...\n@@ -1262,7 +1262,7 @@ impl<'a> Visitor<()> for VisiblePrivateTypesVisitor<'a> {\n                     self_is_public_path = visitor.outer_type_is_public_path;\n                 }\n \n-                // miscellanous info about the impl\n+                // miscellaneous info about the impl\n \n                 // `true` iff this is `impl Private for ...`.\n                 let not_private_trait ="}, {"sha": "33db3b44d95032f8265bb4a11feb286821994b24", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c46c7607a44d047f87e52fca66865b31a4f43b99/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c46c7607a44d047f87e52fca66865b31a4f43b99/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=c46c7607a44d047f87e52fca66865b31a4f43b99", "patch": "@@ -182,7 +182,7 @@ impl RegionMaps {\n \n         // else, locate the innermost terminating scope\n         // if there's one. Static items, for instance, won't\n-        // have an enclusing scope, hence no scope will be\n+        // have an enclosing scope, hence no scope will be\n         // returned.\n         let mut id = match self.opt_encl_scope(expr_id) {\n             Some(i) => i,\n@@ -533,7 +533,7 @@ fn resolve_expr(visitor: &mut RegionResolutionVisitor,\n             // the invoked function is actually running* and call.id\n             // represents *the time to prepare the arguments and make the\n             // call*.  See the section \"Borrows in Calls\" borrowck/doc.rs\n-            // for an extended explanantion of why this distinction is\n+            // for an extended explanation of why this distinction is\n             // important.\n             //\n             // record_superlifetime(new_cx, expr.callee_id);\n@@ -604,7 +604,7 @@ fn resolve_local(visitor: &mut RegionResolutionVisitor,\n     //    (covers cases `expr` borrows an rvalue that is then assigned\n     //     to memory (at least partially) owned by the binding)\n     //\n-    // Here are some examples hopefully giving an intution where each\n+    // Here are some examples hopefully giving an intuition where each\n     // rule comes into play and why:\n     //\n     // Rule A. `let (ref x, ref y) = (foo().x, 44)`. The rvalue `(22, 44)`"}, {"sha": "cd9d88537b4f03859314deea8cf4a2a5eea1712f", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c46c7607a44d047f87e52fca66865b31a4f43b99/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c46c7607a44d047f87e52fca66865b31a4f43b99/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=c46c7607a44d047f87e52fca66865b31a4f43b99", "patch": "@@ -72,7 +72,7 @@ pub enum LastPrivate {\n     // `use` directives (imports) can refer to two separate definitions in the\n     // type and value namespaces. We record here the last private node for each\n     // and whether the import is in fact used for each.\n-    // If the Option<PrivateDep> fields are None, it means there is no defintion\n+    // If the Option<PrivateDep> fields are None, it means there is no definition\n     // in that namespace.\n     LastImport{pub value_priv: Option<PrivateDep>,\n                pub value_used: ImportUse,\n@@ -3610,7 +3610,7 @@ impl<'a> Resolver<'a> {\n                     }\n                 }\n \n-                // n.b. the discr expr gets visted twice.\n+                // n.b. the discr expr gets visited twice.\n                 // but maybe it's okay since the first time will signal an\n                 // error if there is one? -- tjc\n                 self.with_type_parameter_rib(HasTypeParameters(generics,"}, {"sha": "e964bc5d6b0bc53f0cafd1e96d9ba9a12c29d75a", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c46c7607a44d047f87e52fca66865b31a4f43b99/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c46c7607a44d047f87e52fca66865b31a4f43b99/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=c46c7607a44d047f87e52fca66865b31a4f43b99", "patch": "@@ -272,7 +272,7 @@ impl Subst for ty::Region {\n                      substs: &ty::substs,\n                      _: Option<Span>) -> ty::Region {\n         // Note: This routine only handles regions that are bound on\n-        // type declarationss and other outer declarations, not those\n+        // type declarations and other outer declarations, not those\n         // bound in *fn types*. Region substitution of the bound\n         // regions that appear in a function signature is done using\n         // the specialized routine"}, {"sha": "bab7a227572358bfc4a43384c277ad8faf73e199", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c46c7607a44d047f87e52fca66865b31a4f43b99/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c46c7607a44d047f87e52fca66865b31a4f43b99/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=c46c7607a44d047f87e52fca66865b31a4f43b99", "patch": "@@ -963,7 +963,7 @@ fn get_options(bcx: &Block, m: &[Match], col: uint) -> Vec<Opt> {\n         if set.iter().any(|l| opt_eq(tcx, l, &val)) {return;}\n         set.push(val);\n     }\n-    // Vector comparisions are special in that since the actual\n+    // Vector comparisons are special in that since the actual\n     // conditions over-match, we need to be careful about them. This\n     // means that in order to properly handle things in order, we need\n     // to not always merge conditions."}, {"sha": "7002d09beca66efa0c42ed7b8c106220eb84fc5c", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c46c7607a44d047f87e52fca66865b31a4f43b99/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c46c7607a44d047f87e52fca66865b31a4f43b99/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=c46c7607a44d047f87e52fca66865b31a4f43b99", "patch": "@@ -370,7 +370,7 @@ pub fn trans_fn_ref_with_vtables(\n         false\n     };\n \n-    // Create a monomorphic verison of generic functions\n+    // Create a monomorphic version of generic functions\n     if must_monomorphise {\n         // Should be either intra-crate or inlined.\n         assert_eq!(def_id.krate, ast::LOCAL_CRATE);"}, {"sha": "68744643ca606b29c54d6016438d07c89e45ffd0", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c46c7607a44d047f87e52fca66865b31a4f43b99/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c46c7607a44d047f87e52fca66865b31a4f43b99/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=c46c7607a44d047f87e52fca66865b31a4f43b99", "patch": "@@ -84,7 +84,7 @@ use syntax::ast_util;\n // because the alignment requirements of the bound data affects the\n // alignment requires of the closure_data struct as a whole.  However,\n // right now this is a non-issue in any case, because the size of the\n-// rust_opaque_box header is always a mutiple of 16-bytes, which is\n+// rust_opaque_box header is always a multiple of 16-bytes, which is\n // the maximum alignment requirement we ever have to worry about.\n //\n // The only reason alignment matters is that, in order to learn what data"}, {"sha": "c5739960a1910f44c9586be2114a438516ebd94d", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c46c7607a44d047f87e52fca66865b31a4f43b99/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c46c7607a44d047f87e52fca66865b31a4f43b99/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=c46c7607a44d047f87e52fca66865b31a4f43b99", "patch": "@@ -2503,7 +2503,7 @@ fn populate_scope_map(cx: &CrateContext,\n             ast::PatIdent(_, ref path_ref, ref sub_pat_opt) => {\n \n                 // Check if this is a binding. If so we need to put it on the scope stack and maybe\n-                // introduce an articial scope\n+                // introduce an artificial scope\n                 if pat_util::pat_is_binding(def_map, pat) {\n \n                     let ident = ast_util::path_to_ident(path_ref);"}, {"sha": "7d7ea5a221106618c1ac0a3411261e95a5ad6de2", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c46c7607a44d047f87e52fca66865b31a4f43b99/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c46c7607a44d047f87e52fca66865b31a4f43b99/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=c46c7607a44d047f87e52fca66865b31a4f43b99", "patch": "@@ -128,7 +128,7 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n             // Static default methods are a little unfortunate, in\n             // that the \"internal\" and \"external\" type of them differ.\n             // Internally, the method body can refer to Self, but the\n-            // externally visable type of the method has a type param\n+            // externally visible type of the method has a type param\n             // inserted in between the trait type params and the\n             // method type params. The substs that we are given are\n             // the proper substs *internally* to the method body, so"}, {"sha": "7745b0cc08fa4b74439a1aefcc84c7363276a35b", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c46c7607a44d047f87e52fca66865b31a4f43b99/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c46c7607a44d047f87e52fca66865b31a4f43b99/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=c46c7607a44d047f87e52fca66865b31a4f43b99", "patch": "@@ -2338,7 +2338,7 @@ pub fn is_instantiable(cx: &ctxt, r_ty: t) -> bool {\n         let r = match get(ty).sty {\n             // fixed length vectors need special treatment compared to\n             // normal vectors, since they don't necessarily have the\n-            // possibilty to have length zero.\n+            // possibility to have length zero.\n             ty_vec(_, Some(0)) => false, // don't need no contents\n             ty_vec(mt, Some(_)) => type_requires(cx, seen, r_ty, mt.ty),\n "}, {"sha": "f80b8f2f9e85d102f4f4b3895a0f2545cac969ad", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c46c7607a44d047f87e52fca66865b31a4f43b99/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c46c7607a44d047f87e52fca66865b31a4f43b99/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=c46c7607a44d047f87e52fca66865b31a4f43b99", "patch": "@@ -238,7 +238,7 @@ pub struct FnCtxt<'a> {\n     //\n     // What we do in such cases is to generate a region variable with\n     // `region_lb` as a lower bound.  The regionck pass then adds\n-    // other constriants based on how the variable is used and region\n+    // other constraints based on how the variable is used and region\n     // inference selects the ultimate value.  Finally, borrowck is\n     // charged with guaranteeing that the value whose address was taken\n     // can actually be made to live as long as it needs to live.\n@@ -2548,7 +2548,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n                                                              ty::mt {ty: t, mutbl: mutability},\n                                                              None)), // Sadly, we know the length\n                                                                      // - Some(args.len()) - but\n-                                                                     // must thow it away or cause\n+                                                                     // must throw it away or cause\n                                                                      // confusion further down the\n                                                                      // pipeline. Hopefully we can\n                                                                      // remedy this later."}, {"sha": "9df610dc7bc2a57d30fee71223f442436bd1dcdb", "filename": "src/librustc/middle/typeck/infer/resolve.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c46c7607a44d047f87e52fca66865b31a4f43b99/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c46c7607a44d047f87e52fca66865b31a4f43b99/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs?ref=c46c7607a44d047f87e52fca66865b31a4f43b99", "patch": "@@ -36,7 +36,7 @@\n // therefore cannot sensibly be mapped to any particular result.  By\n // default, we will leave such variables as is (so you will get back a\n // variable in your result).  The options force_* will cause the\n-// resolution to fail in this case intead, except for the case of\n+// resolution to fail in this case instead, except for the case of\n // integral variables, which resolve to `int` if forced.\n //\n // # resolve_all and force_all"}, {"sha": "cbc3be3f6e164e24092b53270fd5c9dce3b772d1", "filename": "src/librustc/util/sha2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c46c7607a44d047f87e52fca66865b31a4f43b99/src%2Flibrustc%2Futil%2Fsha2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c46c7607a44d047f87e52fca66865b31a4f43b99/src%2Flibrustc%2Futil%2Fsha2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fsha2.rs?ref=c46c7607a44d047f87e52fca66865b31a4f43b99", "patch": "@@ -146,14 +146,14 @@ impl FixedBuffer for FixedBuffer64 {\n             }\n         }\n \n-        // While we have at least a full buffer size chunks's worth of data, process that data\n+        // While we have at least a full buffer size chunk's worth of data, process that data\n         // without copying it into the buffer\n         while input.len() - i >= size {\n             func(input.slice(i, i + size));\n             i += size;\n         }\n \n-        // Copy any input data into the buffer. At this point in the method, the ammount of\n+        // Copy any input data into the buffer. At this point in the method, the amount of\n         // data left in the input vector will be less than the buffer size and the buffer will\n         // be empty.\n         let input_remaining = input.len() - i;"}, {"sha": "a6d6649aca0d5d5e1115754e1218dd02337fcd7d", "filename": "src/libstd/cmp.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c46c7607a44d047f87e52fca66865b31a4f43b99/src%2Flibstd%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c46c7607a44d047f87e52fca66865b31a4f43b99/src%2Flibstd%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcmp.rs?ref=c46c7607a44d047f87e52fca66865b31a4f43b99", "patch": "@@ -26,7 +26,7 @@\n //!\n //! // Our implementation of `Eq` to support `==` and `!=`.\n //! impl Eq for SketchyNum {\n-//!     // Our custom eq allows numbers which are near eachother to be equal! :D\n+//!     // Our custom eq allows numbers which are near each other to be equal! :D\n //!     fn eq(&self, other: &SketchyNum) -> bool {\n //!         (self.num - other.num).abs() < 5\n //!     }\n@@ -283,7 +283,7 @@ mod test {\n \n         // Our implementation of `Eq` to support `==` and `!=`.\n         impl Eq for SketchyNum {\n-            // Our custom eq allows numbers which are near eachother to be equal! :D\n+            // Our custom eq allows numbers which are near each other to be equal! :D\n             fn eq(&self, other: &SketchyNum) -> bool {\n                 (self.num - other.num).abs() < 5\n             }"}, {"sha": "7a04303268b1fce5f1521dd0e5895c5dfbd03753", "filename": "src/libstd/iter.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c46c7607a44d047f87e52fca66865b31a4f43b99/src%2Flibstd%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c46c7607a44d047f87e52fca66865b31a4f43b99/src%2Flibstd%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fiter.rs?ref=c46c7607a44d047f87e52fca66865b31a4f43b99", "patch": "@@ -937,7 +937,7 @@ impl<A: TotalOrd, T: Iterator<A>> OrdIterator<A> for T {\n         loop {\n             // `first` and `second` are the two next elements we want to look at.\n             // We first compare `first` and `second` (#1). The smaller one is then compared to\n-            // current mininum (#2). The larger one is compared to current maximum (#3). This\n+            // current minimum (#2). The larger one is compared to current maximum (#3). This\n             // way we do 3 comparisons for 2 elements.\n             let first = match self.next() {\n                 None => break,"}, {"sha": "dbaef3358043e259ea091461237acf06bc6f82f0", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c46c7607a44d047f87e52fca66865b31a4f43b99/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c46c7607a44d047f87e52fca66865b31a4f43b99/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=c46c7607a44d047f87e52fca66865b31a4f43b99", "patch": "@@ -24,7 +24,7 @@\n /// which is transmitted.\n ///\n /// The multi-argument form of this macro fails with a string and has the\n-/// `format!` sytnax for building a string.\n+/// `format!` syntax for building a string.\n ///\n /// # Example\n ///"}, {"sha": "f70715ed756dca92167299284bec4ed71a4b8605", "filename": "src/libstd/ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c46c7607a44d047f87e52fca66865b31a4f43b99/src%2Flibstd%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c46c7607a44d047f87e52fca66865b31a4f43b99/src%2Flibstd%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fptr.rs?ref=c46c7607a44d047f87e52fca66865b31a4f43b99", "patch": "@@ -15,7 +15,7 @@\n //! an unsafe pointer when safe pointers are unsuitable;\n //! checking for null; and converting back to safe pointers.\n //! As a result, there is not yet an abundance of library code\n-//! for working with unsafe poniters, and in particular,\n+//! for working with unsafe pointers, and in particular,\n //! since pointer math is fairly uncommon in Rust, it is not\n //! all that convenient.\n //!"}, {"sha": "9b0463089d0f918aefc517e885e07690b6542d80", "filename": "src/libstd/raw.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c46c7607a44d047f87e52fca66865b31a4f43b99/src%2Flibstd%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c46c7607a44d047f87e52fca66865b31a4f43b99/src%2Flibstd%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fraw.rs?ref=c46c7607a44d047f87e52fca66865b31a4f43b99", "patch": "@@ -15,7 +15,7 @@\n //! They can be used as targets of transmutes in unsafe code for manipulating\n //! the raw representations directly.\n //!\n-//! Their definitition should always match the ABI defined in `rustc::back::abi`.\n+//! Their definition should always match the ABI defined in `rustc::back::abi`.\n \n use cast;\n "}, {"sha": "7080da266f6660662a7457c0a469b67349253ca4", "filename": "src/libstd/result.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c46c7607a44d047f87e52fca66865b31a4f43b99/src%2Flibstd%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c46c7607a44d047f87e52fca66865b31a4f43b99/src%2Flibstd%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fresult.rs?ref=c46c7607a44d047f87e52fca66865b31a4f43b99", "patch": "@@ -103,7 +103,7 @@\n //! ~~~\n //!\n //! *Note: The actual definition of `Writer` uses `IoResult`, which\n-//! is just a synonymn for `Result<T, IoError>`.*\n+//! is just a synonym for `Result<T, IoError>`.*\n //!\n //! This method doesn`t produce a value, but the write may\n //! fail. It's crucial to handle the error case, and *not* write\n@@ -255,7 +255,7 @@\n //! handling requires encapsulating fallable code in a task. Calling\n //! the `fail!` macro, or invoking `fail!` indirectly should be\n //! avoided as an error reporting strategy. Failure is only for\n-//! unrecovereable errors and a failing task is typically the sign of\n+//! unrecoverable errors and a failing task is typically the sign of\n //! a bug.\n //!\n //! A module that instead returns `Results` is alerting the caller"}, {"sha": "f60cfa23e81f9bc3b49db7626292db592c4d4c84", "filename": "src/libstd/rt/local_ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c46c7607a44d047f87e52fca66865b31a4f43b99/src%2Flibstd%2Frt%2Flocal_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c46c7607a44d047f87e52fca66865b31a4f43b99/src%2Flibstd%2Frt%2Flocal_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flocal_ptr.rs?ref=c46c7607a44d047f87e52fca66865b31a4f43b99", "patch": "@@ -374,7 +374,7 @@ pub mod native {\n     pub fn maybe_tls_key() -> Option<tls::Key> {\n         unsafe {\n             // NB: This is a little racy because, while the key is\n-            // initalized under a mutex and it's assumed to be initalized\n+            // initialized under a mutex and it's assumed to be initialized\n             // in the Scheduler ctor by any thread that needs to use it,\n             // we are not accessing the key under a mutex.  Threads that\n             // are not using the new Scheduler but still *want to check*"}, {"sha": "672442bb931f43cded1ace0aa44560f00c255fb0", "filename": "src/libstd/str.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c46c7607a44d047f87e52fca66865b31a4f43b99/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c46c7607a44d047f87e52fca66865b31a4f43b99/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=c46c7607a44d047f87e52fca66865b31a4f43b99", "patch": "@@ -662,7 +662,7 @@ impl<'a> Iterator<char> for Normalizations<'a> {\n ///\n /// # Return value\n ///\n-/// The original string with all occurances of `from` replaced with `to`\n+/// The original string with all occurrences of `from` replaced with `to`\n pub fn replace(s: &str, from: &str, to: &str) -> ~str {\n     let mut result = StrBuf::new();\n     let mut last_end = 0;\n@@ -1443,7 +1443,7 @@ pub mod raw {\n     /// Sets the length of a string\n     ///\n     /// This will explicitly set the size of the string, without actually\n-    /// modifing its buffers, so it is up to the caller to ensure that\n+    /// modifying its buffers, so it is up to the caller to ensure that\n     /// the string is actually the specified size.\n     #[test]\n     fn test_from_buf_len() {\n@@ -2022,7 +2022,7 @@ pub trait StrSlice<'a> {\n     ///\n     /// # Return value\n     ///\n-    /// The original string with all occurances of `from` replaced with `to`.\n+    /// The original string with all occurrences of `from` replaced with `to`.\n     ///\n     /// # Example\n     ///"}, {"sha": "86da11aceda134b6663cf6cde270c57656d11f19", "filename": "src/libstd/strbuf.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c46c7607a44d047f87e52fca66865b31a4f43b99/src%2Flibstd%2Fstrbuf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c46c7607a44d047f87e52fca66865b31a4f43b99/src%2Flibstd%2Fstrbuf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstrbuf.rs?ref=c46c7607a44d047f87e52fca66865b31a4f43b99", "patch": "@@ -31,7 +31,7 @@ pub struct StrBuf {\n }\n \n impl StrBuf {\n-    /// Creates a new string buffer initalized with the empty string.\n+    /// Creates a new string buffer initialized with the empty string.\n     #[inline]\n     pub fn new() -> StrBuf {\n         StrBuf {"}, {"sha": "c5f3206d9d557342a72db5d3803ec8b4a0552504", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c46c7607a44d047f87e52fca66865b31a4f43b99/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c46c7607a44d047f87e52fca66865b31a4f43b99/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=c46c7607a44d047f87e52fca66865b31a4f43b99", "patch": "@@ -135,7 +135,7 @@ impl<T> Vec<T> {\n         Vec { len: length, cap: capacity, ptr: ptr }\n     }\n \n-    /// Consumes the `Vec`, partitioning it based on a predcate.\n+    /// Consumes the `Vec`, partitioning it based on a predicate.\n     ///\n     /// Partitions the `Vec` into two `Vec`s `(A,B)`, where all elements of `A`\n     /// satisfy `f` and all elements of `B` do not. The order of elements is\n@@ -279,7 +279,7 @@ impl<T: Clone> Vec<T> {\n         *self.get_mut(index) = value;\n     }\n \n-    /// Partitions a vector based on a predcate.\n+    /// Partitions a vector based on a predicate.\n     ///\n     /// Clones the elements of the vector, partitioning them into two `Vec`s\n     /// `(A,B)`, where all elements of `A` satisfy `f` and all elements of `B`"}]}