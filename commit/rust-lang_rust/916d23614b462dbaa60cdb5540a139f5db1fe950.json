{"sha": "916d23614b462dbaa60cdb5540a139f5db1fe950", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkxNmQyMzYxNGI0NjJkYmFhNjBjZGI1NTQwYTEzOWY1ZGIxZmU5NTA=", "commit": {"author": {"name": "Jake Vossen", "email": "jake@vossen.dev", "date": "2020-09-30T16:07:15Z"}, "committer": {"name": "Jake Vossen", "email": "jake@vossen.dev", "date": "2020-09-30T16:07:15Z"}, "message": "updated p! macro to accept literals", "tree": {"sha": "b9439a849c2ee5c5f9d3a3b371ce89cb29906a09", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b9439a849c2ee5c5f9d3a3b371ce89cb29906a09"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/916d23614b462dbaa60cdb5540a139f5db1fe950", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/916d23614b462dbaa60cdb5540a139f5db1fe950", "html_url": "https://github.com/rust-lang/rust/commit/916d23614b462dbaa60cdb5540a139f5db1fe950", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/916d23614b462dbaa60cdb5540a139f5db1fe950/comments", "author": {"login": "jakevossen5", "id": 16298666, "node_id": "MDQ6VXNlcjE2Mjk4NjY2", "avatar_url": "https://avatars.githubusercontent.com/u/16298666?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakevossen5", "html_url": "https://github.com/jakevossen5", "followers_url": "https://api.github.com/users/jakevossen5/followers", "following_url": "https://api.github.com/users/jakevossen5/following{/other_user}", "gists_url": "https://api.github.com/users/jakevossen5/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakevossen5/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakevossen5/subscriptions", "organizations_url": "https://api.github.com/users/jakevossen5/orgs", "repos_url": "https://api.github.com/users/jakevossen5/repos", "events_url": "https://api.github.com/users/jakevossen5/events{/privacy}", "received_events_url": "https://api.github.com/users/jakevossen5/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakevossen5", "id": 16298666, "node_id": "MDQ6VXNlcjE2Mjk4NjY2", "avatar_url": "https://avatars.githubusercontent.com/u/16298666?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakevossen5", "html_url": "https://github.com/jakevossen5", "followers_url": "https://api.github.com/users/jakevossen5/followers", "following_url": "https://api.github.com/users/jakevossen5/following{/other_user}", "gists_url": "https://api.github.com/users/jakevossen5/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakevossen5/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakevossen5/subscriptions", "organizations_url": "https://api.github.com/users/jakevossen5/orgs", "repos_url": "https://api.github.com/users/jakevossen5/repos", "events_url": "https://api.github.com/users/jakevossen5/events{/privacy}", "received_events_url": "https://api.github.com/users/jakevossen5/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "939cc3e445db1eaf8b3834984e274f8c2267d9c5", "url": "https://api.github.com/repos/rust-lang/rust/commits/939cc3e445db1eaf8b3834984e274f8c2267d9c5", "html_url": "https://github.com/rust-lang/rust/commit/939cc3e445db1eaf8b3834984e274f8c2267d9c5"}], "stats": {"total": 173, "additions": 92, "deletions": 81}, "files": [{"sha": "adf1fc5e16a0978d9b24e39ba8fb56bce2555c36", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 92, "deletions": 81, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/916d23614b462dbaa60cdb5540a139f5db1fe950/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/916d23614b462dbaa60cdb5540a139f5db1fe950/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=916d23614b462dbaa60cdb5540a139f5db1fe950", "patch": "@@ -28,6 +28,9 @@ use std::ops::{Deref, DerefMut};\n use super::*;\n \n macro_rules! p {\n+    (@$lit:literal) => {\n+        write!(scoped_cx!(), $lit)?\n+    };\n     (@write($($data:expr),+)) => {\n         write!(scoped_cx!(), $($data),+)?\n     };\n@@ -37,8 +40,8 @@ macro_rules! p {\n     (@$method:ident($($arg:expr),*)) => {\n         scoped_cx!() = scoped_cx!().$method($($arg),*)?\n     };\n-    ($($kind:ident $data:tt),+) => {{\n-        $(p!(@$kind $data);)+\n+    ($($elem:tt $(($($args:tt)*))?),+) => {{\n+        $(p!(@ $elem $(($($args)*))?);)+\n     }};\n }\n macro_rules! define_scoped_cx {\n@@ -478,7 +481,7 @@ pub trait PrettyPrinter<'tcx>:\n \n             p!(print(self_ty));\n             if let Some(trait_ref) = trait_ref {\n-                p!(write(\" as \"), print(trait_ref.print_only_trait_path()));\n+                p!(\" as \", print(trait_ref.print_only_trait_path()));\n             }\n             Ok(cx)\n         })\n@@ -495,9 +498,9 @@ pub trait PrettyPrinter<'tcx>:\n         self.generic_delimiters(|mut cx| {\n             define_scoped_cx!(cx);\n \n-            p!(write(\"impl \"));\n+            p!(\"impl \");\n             if let Some(trait_ref) = trait_ref {\n-                p!(print(trait_ref.print_only_trait_path()), write(\" for \"));\n+                p!(print(trait_ref.print_only_trait_path()), \" for \");\n             }\n             p!(print(self_ty));\n \n@@ -509,8 +512,8 @@ pub trait PrettyPrinter<'tcx>:\n         define_scoped_cx!(self);\n \n         match *ty.kind() {\n-            ty::Bool => p!(write(\"bool\")),\n-            ty::Char => p!(write(\"char\")),\n+            ty::Bool => p!(\"bool\"),\n+            ty::Char => p!(\"char\"),\n             ty::Int(t) => p!(write(\"{}\", t.name_str())),\n             ty::Uint(t) => p!(write(\"{}\", t.name_str())),\n             ty::Float(t) => p!(write(\"{}\", t.name_str())),\n@@ -525,23 +528,23 @@ pub trait PrettyPrinter<'tcx>:\n                 p!(print(tm.ty))\n             }\n             ty::Ref(r, ty, mutbl) => {\n-                p!(write(\"&\"));\n+                p!(\"&\");\n                 if self.region_should_not_be_omitted(r) {\n                     p!(print(r), write(\" \"));\n                 }\n                 p!(print(ty::TypeAndMut { ty, mutbl }))\n             }\n-            ty::Never => p!(write(\"!\")),\n+            ty::Never => p!(\"!\"),\n             ty::Tuple(ref tys) => {\n-                p!(write(\"(\"), comma_sep(tys.iter()));\n+                p!(\"(\", comma_sep(tys.iter()));\n                 if tys.len() == 1 {\n-                    p!(write(\",\"));\n+                    p!(\",\");\n                 }\n-                p!(write(\")\"))\n+                p!(\")\")\n             }\n             ty::FnDef(def_id, substs) => {\n                 let sig = self.tcx().fn_sig(def_id).subst(self.tcx(), substs);\n-                p!(print(sig), write(\" {{\"), print_value_path(def_id, substs), write(\"}}\"));\n+                p!(print(sig), \" {{\", print_value_path(def_id, substs), \"}}\");\n             }\n             ty::FnPtr(ref bare_fn) => p!(print(bare_fn)),\n             ty::Infer(infer_ty) => {\n@@ -555,7 +558,7 @@ pub trait PrettyPrinter<'tcx>:\n                     p!(write(\"{}\", infer_ty))\n                 }\n             }\n-            ty::Error(_) => p!(write(\"[type error]\")),\n+            ty::Error(_) => p!(\"[type error]\"),\n             ty::Param(ref param_ty) => p!(write(\"{}\", param_ty)),\n             ty::Bound(debruijn, bound_ty) => match bound_ty.kind {\n                 ty::BoundTyKind::Anon => self.pretty_print_bound_var(debruijn, bound_ty.var)?,\n@@ -567,11 +570,11 @@ pub trait PrettyPrinter<'tcx>:\n             ty::Dynamic(data, r) => {\n                 let print_r = self.region_should_not_be_omitted(r);\n                 if print_r {\n-                    p!(write(\"(\"));\n+                    p!(\"(\");\n                 }\n-                p!(write(\"dyn \"), print(data));\n+                p!(\"dyn \", print(data));\n                 if print_r {\n-                    p!(write(\" + \"), print(r), write(\")\"));\n+                    p!(\" + \", print(r), \")\");\n                 }\n             }\n             ty::Foreign(def_id) => {\n@@ -597,7 +600,7 @@ pub trait PrettyPrinter<'tcx>:\n                         p!(write(\"{}\", name));\n                         // FIXME(eddyb) print this with `print_def_path`.\n                         if !substs.is_empty() {\n-                            p!(write(\"::\"));\n+                            p!(\"::\");\n                             p!(generic_delimiters(|cx| cx.comma_sep(substs.iter())));\n                         }\n                         return Ok(self);\n@@ -608,7 +611,7 @@ pub trait PrettyPrinter<'tcx>:\n \n                     let mut first = true;\n                     let mut is_sized = false;\n-                    p!(write(\"impl\"));\n+                    p!(\"impl\");\n                     for predicate in bounds.predicates {\n                         // Note: We can't use `to_opt_poly_trait_ref` here as `predicate`\n                         // may contain unbound variables. We therefore do this manually.\n@@ -634,12 +637,12 @@ pub trait PrettyPrinter<'tcx>:\n                     if !is_sized {\n                         p!(write(\"{}?Sized\", if first { \" \" } else { \"+\" }));\n                     } else if first {\n-                        p!(write(\" Sized\"));\n+                        p!(\" Sized\");\n                     }\n                     Ok(self)\n                 })?);\n             }\n-            ty::Str => p!(write(\"str\")),\n+            ty::Str => p!(\"str\"),\n             ty::Generator(did, substs, movability) => {\n                 p!(write(\"[\"));\n                 match movability {\n@@ -674,10 +677,10 @@ pub trait PrettyPrinter<'tcx>:\n                 }\n \n                 if substs.as_generator().is_valid() {\n-                    p!(write(\" \"), print(substs.as_generator().witness()));\n+                    p!(\" \", print(substs.as_generator().witness()));\n                 }\n \n-                p!(write(\"]\"));\n+                p!(\"]\")\n             }\n             ty::GeneratorWitness(types) => {\n                 p!(in_binder(&types));\n@@ -723,24 +726,24 @@ pub trait PrettyPrinter<'tcx>:\n                 p!(write(\"]\"));\n             }\n             ty::Array(ty, sz) => {\n-                p!(write(\"[\"), print(ty), write(\"; \"));\n+                p!(\"[\", print(ty), \"; \");\n                 if self.tcx().sess.verbose() {\n                     p!(write(\"{:?}\", sz));\n                 } else if let ty::ConstKind::Unevaluated(..) = sz.val {\n                     // Do not try to evaluate unevaluated constants. If we are const evaluating an\n                     // array length anon const, rustc will (with debug assertions) print the\n                     // constant's path. Which will end up here again.\n-                    p!(write(\"_\"));\n+                    p!(\"_\");\n                 } else if let Some(n) = sz.val.try_to_bits(self.tcx().data_layout.pointer_size) {\n                     p!(write(\"{}\", n));\n                 } else if let ty::ConstKind::Param(param) = sz.val {\n                     p!(write(\"{}\", param));\n                 } else {\n-                    p!(write(\"_\"));\n+                    p!(\"_\");\n                 }\n-                p!(write(\"]\"))\n+                p!(\"]\")\n             }\n-            ty::Slice(ty) => p!(write(\"[\"), print(ty), write(\"]\")),\n+            ty::Slice(ty) => p!(\"[\", print(ty), \"]\"),\n         }\n \n         Ok(self)\n@@ -847,7 +850,7 @@ pub trait PrettyPrinter<'tcx>:\n \n         for (_, def_id) in auto_traits {\n             if !first {\n-                p!(write(\" + \"));\n+                p!(\" + \");\n             }\n             first = false;\n \n@@ -865,16 +868,16 @@ pub trait PrettyPrinter<'tcx>:\n     ) -> Result<Self, Self::Error> {\n         define_scoped_cx!(self);\n \n-        p!(write(\"(\"), comma_sep(inputs.iter().copied()));\n+        p!(\"(\", comma_sep(inputs.iter().copied()));\n         if c_variadic {\n             if !inputs.is_empty() {\n-                p!(write(\", \"));\n+                p!(\", \");\n             }\n-            p!(write(\"...\"));\n+            p!(\"...\");\n         }\n-        p!(write(\")\"));\n+        p!(\")\");\n         if !output.is_unit() {\n-            p!(write(\" -> \"), print(output));\n+            p!(\" -> \", print(output));\n         }\n \n         Ok(self)\n@@ -945,7 +948,7 @@ pub trait PrettyPrinter<'tcx>:\n                 self.pretty_print_bound_var(debruijn, bound_var)?\n             }\n             ty::ConstKind::Placeholder(placeholder) => p!(write(\"Placeholder({:?})\", placeholder)),\n-            ty::ConstKind::Error(_) => p!(write(\"[const error]\")),\n+            ty::ConstKind::Error(_) => p!(\"[const error]\"),\n         };\n         Ok(self)\n     }\n@@ -987,17 +990,17 @@ pub trait PrettyPrinter<'tcx>:\n                     {\n                         p!(pretty_print_byte_str(byte_str))\n                     } else {\n-                        p!(write(\"<too short allocation>\"))\n+                        p!(\"<too short allocation>\")\n                     }\n                 }\n                 // FIXME: for statics and functions, we could in principle print more detail.\n                 Some(GlobalAlloc::Static(def_id)) => p!(write(\"<static({:?})>\", def_id)),\n-                Some(GlobalAlloc::Function(_)) => p!(write(\"<function>\")),\n-                None => p!(write(\"<dangling pointer>\")),\n+                Some(GlobalAlloc::Function(_)) => p!(\"<function>\"),\n+                None => p!(\"<dangling pointer>\"),\n             },\n             // Bool\n-            (Scalar::Raw { data: 0, .. }, ty::Bool) => p!(write(\"false\")),\n-            (Scalar::Raw { data: 1, .. }, ty::Bool) => p!(write(\"true\")),\n+            (Scalar::Raw { data: 0, .. }, ty::Bool) => p!(\"false\"),\n+            (Scalar::Raw { data: 1, .. }, ty::Bool) => p!(\"true\"),\n             // Float\n             (Scalar::Raw { data, .. }, ty::Float(ast::FloatTy::F32)) => {\n                 p!(write(\"{}f32\", Single::from_bits(data)))\n@@ -1009,12 +1012,20 @@ pub trait PrettyPrinter<'tcx>:\n             (Scalar::Raw { data, .. }, ty::Uint(ui)) => {\n                 let size = Integer::from_attr(&self.tcx(), UnsignedInt(*ui)).size();\n                 let int = ConstInt::new(data, size, false, ty.is_ptr_sized_integral());\n-                if print_ty { p!(write(\"{:#?}\", int)) } else { p!(write(\"{:?}\", int)) }\n+                if print_ty {\n+                    p!(write(\"{:#?}\", int))\n+                } else {\n+                    p!(write(\"{:?}\", int))\n+                }\n             }\n             (Scalar::Raw { data, .. }, ty::Int(i)) => {\n                 let size = Integer::from_attr(&self.tcx(), SignedInt(*i)).size();\n                 let int = ConstInt::new(data, size, true, ty.is_ptr_sized_integral());\n-                if print_ty { p!(write(\"{:#?}\", int)) } else { p!(write(\"{:?}\", int)) }\n+                if print_ty {\n+                    p!(write(\"{:#?}\", int))\n+                } else {\n+                    p!(write(\"{:?}\", int))\n+                }\n             }\n             // Char\n             (Scalar::Raw { data, .. }, ty::Char) if char::from_u32(data as u32).is_some() => {\n@@ -1093,13 +1104,13 @@ pub trait PrettyPrinter<'tcx>:\n \n     fn pretty_print_byte_str(mut self, byte_str: &'tcx [u8]) -> Result<Self::Const, Self::Error> {\n         define_scoped_cx!(self);\n-        p!(write(\"b\\\"\"));\n+        p!(\"b\\\"\");\n         for &c in byte_str {\n             for e in std::ascii::escape_default(c) {\n                 self.write_char(e as char)?;\n             }\n         }\n-        p!(write(\"\\\"\"));\n+        p!(\"\\\"\");\n         Ok(self)\n     }\n \n@@ -1112,7 +1123,7 @@ pub trait PrettyPrinter<'tcx>:\n         define_scoped_cx!(self);\n \n         if self.tcx().sess.verbose() {\n-            p!(write(\"ConstValue({:?}: \", ct), print(ty), write(\")\"));\n+            p!(write(\"ConstValue({:?}: \", ct), print(ty), \")\");\n             return Ok(self);\n         }\n \n@@ -1149,7 +1160,7 @@ pub trait PrettyPrinter<'tcx>:\n                 let ptr = Pointer::new(AllocId(0), offset);\n \n                 let byte_str = alloc.get_bytes(&self.tcx(), ptr, n).unwrap();\n-                p!(write(\"*\"));\n+                p!(\"*\");\n                 p!(pretty_print_byte_str(byte_str));\n                 Ok(self)\n             }\n@@ -1173,14 +1184,14 @@ pub trait PrettyPrinter<'tcx>:\n \n                 match *ty.kind() {\n                     ty::Array(..) => {\n-                        p!(write(\"[\"), comma_sep(fields), write(\"]\"));\n+                        p!(\"[\", comma_sep(fields), \"]\");\n                     }\n                     ty::Tuple(..) => {\n-                        p!(write(\"(\"), comma_sep(fields));\n+                        p!(\"(\", comma_sep(fields));\n                         if contents.fields.len() == 1 {\n-                            p!(write(\",\"));\n+                            p!(\",\");\n                         }\n-                        p!(write(\")\"));\n+                        p!(\")\");\n                     }\n                     ty::Adt(def, substs) if def.variants.is_empty() => {\n                         p!(print_value_path(def.did, substs));\n@@ -1194,19 +1205,19 @@ pub trait PrettyPrinter<'tcx>:\n                         match variant_def.ctor_kind {\n                             CtorKind::Const => {}\n                             CtorKind::Fn => {\n-                                p!(write(\"(\"), comma_sep(fields), write(\")\"));\n+                                p!(\"(\", comma_sep(fields), \")\");\n                             }\n                             CtorKind::Fictive => {\n-                                p!(write(\" {{ \"));\n+                                p!(\" {{ \");\n                                 let mut first = true;\n                                 for (field_def, field) in variant_def.fields.iter().zip(fields) {\n                                     if !first {\n-                                        p!(write(\", \"));\n+                                        p!(\", \");\n                                     }\n                                     p!(write(\"{}: \", field_def.ident), print(field));\n                                     first = false;\n                                 }\n-                                p!(write(\" }}\"));\n+                                p!(\" }}\");\n                             }\n                         }\n                     }\n@@ -1224,7 +1235,7 @@ pub trait PrettyPrinter<'tcx>:\n                 // fallback\n                 p!(write(\"{:?}\", ct));\n                 if print_ty {\n-                    p!(write(\": \"), print(ty));\n+                    p!(\": \", print(ty));\n                 }\n                 Ok(self)\n             }\n@@ -1637,7 +1648,7 @@ impl<F: fmt::Write> PrettyPrinter<'tcx> for FmtPrinter<'_, 'tcx, F> {\n             if this.print_alloc_ids {\n                 p!(write(\"{:?}\", p));\n             } else {\n-                p!(write(\"&_\"));\n+                p!(\"&_\");\n             }\n             Ok(this)\n         };\n@@ -1703,11 +1714,11 @@ impl<F: fmt::Write> FmtPrinter<'_, '_, F> {\n             ty::ReVar(_) => {}\n             ty::ReErased => {}\n             ty::ReStatic => {\n-                p!(write(\"'static\"));\n+                p!(\"'static\");\n                 return Ok(self);\n             }\n             ty::ReEmpty(ty::UniverseIndex::ROOT) => {\n-                p!(write(\"'<empty>\"));\n+                p!(\"'<empty>\");\n                 return Ok(self);\n             }\n             ty::ReEmpty(ui) => {\n@@ -1716,7 +1727,7 @@ impl<F: fmt::Write> FmtPrinter<'_, '_, F> {\n             }\n         }\n \n-        p!(write(\"'_\"));\n+        p!(\"'_\");\n \n         Ok(self)\n     }\n@@ -1847,7 +1858,7 @@ where\n     type Error = P::Error;\n     fn print(&self, mut cx: P) -> Result<Self::Output, Self::Error> {\n         define_scoped_cx!(cx);\n-        p!(print(self.0), write(\": \"), print(self.1));\n+        p!(print(self.0), \": \", print(self.1));\n         Ok(cx)\n     }\n }\n@@ -1945,7 +1956,7 @@ define_print_and_forward_display! {\n     (self, cx):\n \n     &'tcx ty::List<Ty<'tcx>> {\n-        p!(write(\"{{\"), comma_sep(self.iter()), write(\"}}\"))\n+        p!(\"{{\", comma_sep(self.iter()), \"}}\")\n     }\n \n     ty::TypeAndMut<'tcx> {\n@@ -1981,7 +1992,7 @@ define_print_and_forward_display! {\n             p!(write(\"extern {} \", self.abi));\n         }\n \n-        p!(write(\"fn\"), pretty_fn_sig(self.inputs(), self.c_variadic, self.output()));\n+        p!(\"fn\", pretty_fn_sig(self.inputs(), self.c_variadic, self.output()));\n     }\n \n     ty::InferTy {\n@@ -1990,7 +2001,7 @@ define_print_and_forward_display! {\n             return Ok(cx);\n         }\n         match *self {\n-            ty::TyVar(_) => p!(write(\"_\")),\n+            ty::TyVar(_) => p!(\"_\"),\n             ty::IntVar(_) => p!(write(\"{}\", \"{integer}\")),\n             ty::FloatVar(_) => p!(write(\"{}\", \"{float}\")),\n             ty::FreshTy(v) => p!(write(\"FreshTy({})\", v)),\n@@ -2016,16 +2027,16 @@ define_print_and_forward_display! {\n     }\n \n     ty::SubtypePredicate<'tcx> {\n-        p!(print(self.a), write(\" <: \"), print(self.b))\n+        p!(print(self.a), \" <: \", print(self.b))\n     }\n \n     ty::TraitPredicate<'tcx> {\n-        p!(print(self.trait_ref.self_ty()), write(\": \"),\n+        p!(print(self.trait_ref.self_ty()), \": \",\n            print(self.trait_ref.print_only_trait_path()))\n     }\n \n     ty::ProjectionPredicate<'tcx> {\n-        p!(print(self.projection_ty), write(\" == \"), print(self.ty))\n+        p!(print(self.projection_ty), \" == \", print(self.ty))\n     }\n \n     ty::ProjectionTy<'tcx> {\n@@ -2034,9 +2045,9 @@ define_print_and_forward_display! {\n \n     ty::ClosureKind {\n         match *self {\n-            ty::ClosureKind::Fn => p!(write(\"Fn\")),\n-            ty::ClosureKind::FnMut => p!(write(\"FnMut\")),\n-            ty::ClosureKind::FnOnce => p!(write(\"FnOnce\")),\n+            ty::ClosureKind::Fn => p!(\"Fn\"),\n+            ty::ClosureKind::FnMut => p!(\"FnMut\"),\n+            ty::ClosureKind::FnOnce => p!(\"FnOnce\"),\n         }\n     }\n \n@@ -2051,41 +2062,41 @@ define_print_and_forward_display! {\n         match *self {\n             ty::PredicateAtom::Trait(ref data, constness) => {\n                 if let hir::Constness::Const = constness {\n-                    p!(write(\"const \"));\n+                    p!(\"const \");\n                 }\n                 p!(print(data))\n             }\n             ty::PredicateAtom::Subtype(predicate) => p!(print(predicate)),\n             ty::PredicateAtom::RegionOutlives(predicate) => p!(print(predicate)),\n             ty::PredicateAtom::TypeOutlives(predicate) => p!(print(predicate)),\n             ty::PredicateAtom::Projection(predicate) => p!(print(predicate)),\n-            ty::PredicateAtom::WellFormed(arg) => p!(print(arg), write(\" well-formed\")),\n+            ty::PredicateAtom::WellFormed(arg) => p!(print(arg), \" well-formed\"),\n             ty::PredicateAtom::ObjectSafe(trait_def_id) => {\n-                p!(write(\"the trait `\"),\n+                p!(\"the trait `\",\n                 print_def_path(trait_def_id, &[]),\n-                write(\"` is object-safe\"))\n+                \"` is object-safe\")\n             }\n             ty::PredicateAtom::ClosureKind(closure_def_id, _closure_substs, kind) => {\n-                p!(write(\"the closure `\"),\n+                p!(\"the closure `\",\n                 print_value_path(closure_def_id, &[]),\n                 write(\"` implements the trait `{}`\", kind))\n             }\n             ty::PredicateAtom::ConstEvaluatable(def, substs) => {\n-                p!(write(\"the constant `\"),\n+                p!(\"the constant `\",\n                 print_value_path(def.did, substs),\n-                write(\"` can be evaluated\"))\n+                \"` can be evaluated\")\n             }\n             ty::PredicateAtom::ConstEquate(c1, c2) => {\n-                p!(write(\"the constant `\"),\n+                p!(\"the constant `\",\n                 print(c1),\n-                write(\"` equals `\"),\n+                \"` equals `\",\n                 print(c2),\n-                write(\"`\"))\n+                \"`\")\n             }\n             ty::PredicateAtom::TypeWellFormedFromEnv(ty) => {\n-                p!(write(\"the type `\"),\n+                p!(\"the type `\",\n                 print(ty),\n-                write(\"` is found in the environment\"))\n+                \"` is found in the environment\")\n             }\n         }\n     }"}]}