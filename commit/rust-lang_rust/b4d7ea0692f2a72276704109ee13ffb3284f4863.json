{"sha": "b4d7ea0692f2a72276704109ee13ffb3284f4863", "node_id": "C_kwDOAAsO6NoAKGI0ZDdlYTA2OTJmMmE3MjI3NjcwNDEwOWVlMTNmZmIzMjg0ZjQ4NjM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-14T19:57:01Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-14T19:57:01Z"}, "message": "Auto merge of #13994 - Veykril:incoherent-impl, r=Veykril\n\nlint incoherent inherent impls", "tree": {"sha": "586473b9ce4a940ffb50e76f0c67c2547f0b9e4f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/586473b9ce4a940ffb50e76f0c67c2547f0b9e4f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b4d7ea0692f2a72276704109ee13ffb3284f4863", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b4d7ea0692f2a72276704109ee13ffb3284f4863", "html_url": "https://github.com/rust-lang/rust/commit/b4d7ea0692f2a72276704109ee13ffb3284f4863", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b4d7ea0692f2a72276704109ee13ffb3284f4863/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c15335c8b02dbc0ccc04f04c56d6471120db1bd2", "url": "https://api.github.com/repos/rust-lang/rust/commits/c15335c8b02dbc0ccc04f04c56d6471120db1bd2", "html_url": "https://github.com/rust-lang/rust/commit/c15335c8b02dbc0ccc04f04c56d6471120db1bd2"}, {"sha": "510e4b402994124cff40893ad240646e7e0bfa54", "url": "https://api.github.com/repos/rust-lang/rust/commits/510e4b402994124cff40893ad240646e7e0bfa54", "html_url": "https://github.com/rust-lang/rust/commit/510e4b402994124cff40893ad240646e7e0bfa54"}], "stats": {"total": 378, "additions": 305, "deletions": 73}, "files": [{"sha": "b336f59ffee312f08c1128e71fcbd6f5e8ce1dde", "filename": "crates/hir-def/src/adt.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b4d7ea0692f2a72276704109ee13ffb3284f4863/crates%2Fhir-def%2Fsrc%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4d7ea0692f2a72276704109ee13ffb3284f4863/crates%2Fhir-def%2Fsrc%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fadt.rs?ref=b4d7ea0692f2a72276704109ee13ffb3284f4863", "patch": "@@ -40,6 +40,7 @@ pub struct StructData {\n     pub repr: Option<ReprOptions>,\n     pub visibility: RawVisibility,\n     pub rustc_has_incoherent_inherent_impls: bool,\n+    pub fundamental: bool,\n }\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n@@ -173,10 +174,10 @@ impl StructData {\n         let item_tree = loc.id.item_tree(db);\n         let repr = repr_from_value(db, krate, &item_tree, ModItem::from(loc.id.value).into());\n         let cfg_options = db.crate_graph()[loc.container.krate].cfg_options.clone();\n-        let rustc_has_incoherent_inherent_impls = item_tree\n-            .attrs(db, loc.container.krate, ModItem::from(loc.id.value).into())\n-            .by_key(\"rustc_has_incoherent_inherent_impls\")\n-            .exists();\n+        let attrs = item_tree.attrs(db, loc.container.krate, ModItem::from(loc.id.value).into());\n+        let rustc_has_incoherent_inherent_impls =\n+            attrs.by_key(\"rustc_has_incoherent_inherent_impls\").exists();\n+        let fundamental = attrs.by_key(\"fundamental\").exists();\n \n         let strukt = &item_tree[loc.id.value];\n         let (variant_data, diagnostics) = lower_fields(\n@@ -196,6 +197,7 @@ impl StructData {\n                 repr,\n                 visibility: item_tree[strukt.visibility].clone(),\n                 rustc_has_incoherent_inherent_impls,\n+                fundamental,\n             }),\n             diagnostics.into(),\n         )\n@@ -215,10 +217,10 @@ impl StructData {\n         let repr = repr_from_value(db, krate, &item_tree, ModItem::from(loc.id.value).into());\n         let cfg_options = db.crate_graph()[loc.container.krate].cfg_options.clone();\n \n-        let rustc_has_incoherent_inherent_impls = item_tree\n-            .attrs(db, loc.container.krate, ModItem::from(loc.id.value).into())\n-            .by_key(\"rustc_has_incoherent_inherent_impls\")\n-            .exists();\n+        let attrs = item_tree.attrs(db, loc.container.krate, ModItem::from(loc.id.value).into());\n+        let rustc_has_incoherent_inherent_impls =\n+            attrs.by_key(\"rustc_has_incoherent_inherent_impls\").exists();\n+        let fundamental = attrs.by_key(\"fundamental\").exists();\n \n         let union = &item_tree[loc.id.value];\n         let (variant_data, diagnostics) = lower_fields(\n@@ -238,6 +240,7 @@ impl StructData {\n                 repr,\n                 visibility: item_tree[union.visibility].clone(),\n                 rustc_has_incoherent_inherent_impls,\n+                fundamental,\n             }),\n             diagnostics.into(),\n         )"}, {"sha": "1633a33bedde87d1d7a0cf6c63df9e17dec1b5b3", "filename": "crates/hir-def/src/data.rs", "status": "modified", "additions": 26, "deletions": 7, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/b4d7ea0692f2a72276704109ee13ffb3284f4863/crates%2Fhir-def%2Fsrc%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4d7ea0692f2a72276704109ee13ffb3284f4863/crates%2Fhir-def%2Fsrc%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fdata.rs?ref=b4d7ea0692f2a72276704109ee13ffb3284f4863", "patch": "@@ -35,6 +35,7 @@ pub struct FunctionData {\n     pub visibility: RawVisibility,\n     pub abi: Option<Interned<str>>,\n     pub legacy_const_generics_indices: Box<[u32]>,\n+    pub rustc_allow_incoherent_impl: bool,\n     flags: FnFlags,\n }\n \n@@ -84,13 +85,14 @@ impl FunctionData {\n             }\n         }\n \n-        let legacy_const_generics_indices = item_tree\n-            .attrs(db, krate, ModItem::from(loc.id.value).into())\n+        let attrs = item_tree.attrs(db, krate, ModItem::from(loc.id.value).into());\n+        let legacy_const_generics_indices = attrs\n             .by_key(\"rustc_legacy_const_generics\")\n             .tt_values()\n             .next()\n             .map(parse_rustc_legacy_const_generics)\n             .unwrap_or_default();\n+        let rustc_allow_incoherent_impl = attrs.by_key(\"rustc_allow_incoherent_impl\").exists();\n \n         Arc::new(FunctionData {\n             name: func.name.clone(),\n@@ -108,6 +110,7 @@ impl FunctionData {\n             abi: func.abi.clone(),\n             legacy_const_generics_indices,\n             flags,\n+            rustc_allow_incoherent_impl,\n         })\n     }\n \n@@ -171,6 +174,7 @@ pub struct TypeAliasData {\n     pub visibility: RawVisibility,\n     pub is_extern: bool,\n     pub rustc_has_incoherent_inherent_impls: bool,\n+    pub rustc_allow_incoherent_impl: bool,\n     /// Bounds restricting the type alias itself (eg. `type Ty: Bound;` in a trait or impl).\n     pub bounds: Vec<Interned<TypeBound>>,\n }\n@@ -189,17 +193,22 @@ impl TypeAliasData {\n             item_tree[typ.visibility].clone()\n         };\n \n-        let rustc_has_incoherent_inherent_impls = item_tree\n-            .attrs(db, loc.container.module(db).krate(), ModItem::from(loc.id.value).into())\n-            .by_key(\"rustc_has_incoherent_inherent_impls\")\n-            .exists();\n+        let attrs = item_tree.attrs(\n+            db,\n+            loc.container.module(db).krate(),\n+            ModItem::from(loc.id.value).into(),\n+        );\n+        let rustc_has_incoherent_inherent_impls =\n+            attrs.by_key(\"rustc_has_incoherent_inherent_impls\").exists();\n+        let rustc_allow_incoherent_impl = attrs.by_key(\"rustc_allow_incoherent_impl\").exists();\n \n         Arc::new(TypeAliasData {\n             name: typ.name.clone(),\n             type_ref: typ.type_ref.clone(),\n             visibility,\n             is_extern: matches!(loc.container, ItemContainerId::ExternBlockId(_)),\n             rustc_has_incoherent_inherent_impls,\n+            rustc_allow_incoherent_impl,\n             bounds: typ.bounds.to_vec(),\n         })\n     }\n@@ -212,11 +221,12 @@ pub struct TraitData {\n     pub is_auto: bool,\n     pub is_unsafe: bool,\n     pub rustc_has_incoherent_inherent_impls: bool,\n+    pub skip_array_during_method_dispatch: bool,\n+    pub fundamental: bool,\n     pub visibility: RawVisibility,\n     /// Whether the trait has `#[rust_skip_array_during_method_dispatch]`. `hir_ty` will ignore\n     /// method calls to this trait's methods when the receiver is an array and the crate edition is\n     /// 2015 or 2018.\n-    pub skip_array_during_method_dispatch: bool,\n     // box it as the vec is usually empty anyways\n     pub attribute_calls: Option<Box<Vec<(AstId<ast::Item>, MacroCallId)>>>,\n }\n@@ -245,6 +255,7 @@ impl TraitData {\n             attrs.by_key(\"rustc_skip_array_during_method_dispatch\").exists();\n         let rustc_has_incoherent_inherent_impls =\n             attrs.by_key(\"rustc_has_incoherent_inherent_impls\").exists();\n+        let fundamental = attrs.by_key(\"fundamental\").exists();\n         let mut collector =\n             AssocItemCollector::new(db, module_id, tree_id.file_id(), ItemContainerId::TraitId(tr));\n         collector.collect(&item_tree, tree_id.tree_id(), &tr_def.items);\n@@ -260,6 +271,7 @@ impl TraitData {\n                 visibility,\n                 skip_array_during_method_dispatch,\n                 rustc_has_incoherent_inherent_impls,\n+                fundamental,\n             }),\n             diagnostics.into(),\n         )\n@@ -450,6 +462,7 @@ pub struct ConstData {\n     pub name: Option<Name>,\n     pub type_ref: Interned<TypeRef>,\n     pub visibility: RawVisibility,\n+    pub rustc_allow_incoherent_impl: bool,\n }\n \n impl ConstData {\n@@ -463,10 +476,16 @@ impl ConstData {\n             item_tree[konst.visibility].clone()\n         };\n \n+        let rustc_allow_incoherent_impl = item_tree\n+            .attrs(db, loc.container.module(db).krate(), ModItem::from(loc.id.value).into())\n+            .by_key(\"rustc_allow_incoherent_impl\")\n+            .exists();\n+\n         Arc::new(ConstData {\n             name: konst.name.clone(),\n             type_ref: konst.type_ref.clone(),\n             visibility,\n+            rustc_allow_incoherent_impl,\n         })\n     }\n }"}, {"sha": "121b25c6c9722fcd7f6a7566db460601790e0504", "filename": "crates/hir-def/src/nameres.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b4d7ea0692f2a72276704109ee13ffb3284f4863/crates%2Fhir-def%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4d7ea0692f2a72276704109ee13ffb3284f4863/crates%2Fhir-def%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fnameres.rs?ref=b4d7ea0692f2a72276704109ee13ffb3284f4863", "patch": "@@ -120,6 +120,8 @@ pub struct DefMap {\n     registered_tools: Vec<SmolStr>,\n     /// Unstable features of Rust enabled with `#![feature(A, B)]`.\n     unstable_features: FxHashSet<SmolStr>,\n+    /// #[rustc_coherence_is_core]\n+    rustc_coherence_is_core: bool,\n \n     edition: Edition,\n     recursion_limit: Option<u32>,\n@@ -292,6 +294,7 @@ impl DefMap {\n             registered_tools: Vec::new(),\n             unstable_features: FxHashSet::default(),\n             diagnostics: Vec::new(),\n+            rustc_coherence_is_core: false,\n         }\n     }\n \n@@ -325,6 +328,10 @@ impl DefMap {\n         self.unstable_features.contains(feature)\n     }\n \n+    pub fn is_rustc_coherence_is_core(&self) -> bool {\n+        self.rustc_coherence_is_core\n+    }\n+\n     pub fn root(&self) -> LocalModuleId {\n         self.root\n     }\n@@ -337,7 +344,7 @@ impl DefMap {\n         self.proc_macro_loading_error.as_deref()\n     }\n \n-    pub(crate) fn krate(&self) -> CrateId {\n+    pub fn krate(&self) -> CrateId {\n         self.krate\n     }\n \n@@ -502,6 +509,7 @@ impl DefMap {\n             krate: _,\n             prelude: _,\n             root: _,\n+            rustc_coherence_is_core: _,\n         } = self;\n \n         extern_prelude.shrink_to_fit();"}, {"sha": "ddcee77ec4ccfa3327c4d56cf024243878df7b41", "filename": "crates/hir-def/src/nameres/collector.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b4d7ea0692f2a72276704109ee13ffb3284f4863/crates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4d7ea0692f2a72276704109ee13ffb3284f4863/crates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs?ref=b4d7ea0692f2a72276704109ee13ffb3284f4863", "patch": "@@ -296,6 +296,11 @@ impl DefCollector<'_> {\n                     continue;\n                 }\n \n+                if attr_name.as_text().as_deref() == Some(\"rustc_coherence_is_core\") {\n+                    self.def_map.rustc_coherence_is_core = true;\n+                    continue;\n+                }\n+\n                 if *attr_name == hir_expand::name![feature] {\n                     let features =\n                         attr.parse_path_comma_token_tree().into_iter().flatten().filter_map("}, {"sha": "2141894922f7b78c1a07f386148cdbeb5579f999", "filename": "crates/hir-ty/src/chalk_ext.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b4d7ea0692f2a72276704109ee13ffb3284f4863/crates%2Fhir-ty%2Fsrc%2Fchalk_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4d7ea0692f2a72276704109ee13ffb3284f4863/crates%2Fhir-ty%2Fsrc%2Fchalk_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fchalk_ext.rs?ref=b4d7ea0692f2a72276704109ee13ffb3284f4863", "patch": "@@ -12,7 +12,7 @@ use hir_def::{\n use crate::{\n     db::HirDatabase, from_assoc_type_id, from_chalk_trait_id, from_foreign_def_id,\n     from_placeholder_idx, to_chalk_trait_id, utils::generics, AdtId, AliasEq, AliasTy, Binders,\n-    CallableDefId, CallableSig, FnPointer, ImplTraitId, Interner, Lifetime, ProjectionTy,\n+    CallableDefId, CallableSig, DynTy, FnPointer, ImplTraitId, Interner, Lifetime, ProjectionTy,\n     QuantifiedWhereClause, Substitution, TraitRef, Ty, TyBuilder, TyKind, TypeFlags, WhereClause,\n };\n \n@@ -378,6 +378,19 @@ impl ProjectionTyExt for ProjectionTy {\n     }\n }\n \n+pub trait DynTyExt {\n+    fn principal(&self) -> Option<&TraitRef>;\n+}\n+\n+impl DynTyExt for DynTy {\n+    fn principal(&self) -> Option<&TraitRef> {\n+        self.bounds.skip_binders().interned().get(0).and_then(|b| match b.skip_binders() {\n+            crate::WhereClause::Implemented(trait_ref) => Some(trait_ref),\n+            _ => None,\n+        })\n+    }\n+}\n+\n pub trait TraitRefExt {\n     fn hir_trait_id(&self) -> TraitId;\n }"}, {"sha": "4b147b99707c15ad6c71a171307b605cec108fe6", "filename": "crates/hir-ty/src/diagnostics.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b4d7ea0692f2a72276704109ee13ffb3284f4863/crates%2Fhir-ty%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4d7ea0692f2a72276704109ee13ffb3284f4863/crates%2Fhir-ty%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fdiagnostics.rs?ref=b4d7ea0692f2a72276704109ee13ffb3284f4863", "patch": "@@ -11,3 +11,9 @@ pub use crate::diagnostics::{\n     },\n     unsafe_check::{missing_unsafe, unsafe_expressions, UnsafeExpr},\n };\n+\n+#[derive(Debug, PartialEq, Eq)]\n+pub struct IncoherentImpl {\n+    pub file_id: hir_expand::HirFileId,\n+    pub impl_: syntax::AstPtr<syntax::ast::Impl>,\n+}"}, {"sha": "f3a27632bf545f9c578bb1a8bcd9673fb9186e75", "filename": "crates/hir-ty/src/method_resolution.rs", "status": "modified", "additions": 83, "deletions": 9, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/b4d7ea0692f2a72276704109ee13ffb3284f4863/crates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4d7ea0692f2a72276704109ee13ffb3284f4863/crates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs?ref=b4d7ea0692f2a72276704109ee13ffb3284f4863", "patch": "@@ -19,13 +19,13 @@ use stdx::never;\n use crate::{\n     autoderef::{self, AutoderefKind},\n     db::HirDatabase,\n-    from_foreign_def_id,\n+    from_chalk_trait_id, from_foreign_def_id,\n     infer::{unify::InferenceTable, Adjust, Adjustment, AutoBorrow, OverloadedDeref, PointerCast},\n     primitive::{FloatTy, IntTy, UintTy},\n     static_lifetime, to_chalk_trait_id,\n     utils::all_super_traits,\n-    AdtId, Canonical, CanonicalVarKinds, DebruijnIndex, ForeignDefId, InEnvironment, Interner,\n-    Scalar, Substitution, TraitEnvironment, TraitRef, TraitRefExt, Ty, TyBuilder, TyExt,\n+    AdtId, Canonical, CanonicalVarKinds, DebruijnIndex, DynTyExt, ForeignDefId, InEnvironment,\n+    Interner, Scalar, Substitution, TraitEnvironment, TraitRef, TraitRefExt, Ty, TyBuilder, TyExt,\n };\n \n /// This is used as a key for indexing impls.\n@@ -266,11 +266,12 @@ impl TraitImpls {\n #[derive(Debug, Eq, PartialEq)]\n pub struct InherentImpls {\n     map: FxHashMap<TyFingerprint, Vec<ImplId>>,\n+    invalid_impls: Vec<ImplId>,\n }\n \n impl InherentImpls {\n     pub(crate) fn inherent_impls_in_crate_query(db: &dyn HirDatabase, krate: CrateId) -> Arc<Self> {\n-        let mut impls = Self { map: FxHashMap::default() };\n+        let mut impls = Self { map: FxHashMap::default(), invalid_impls: Vec::default() };\n \n         let crate_def_map = db.crate_def_map(krate);\n         impls.collect_def_map(db, &crate_def_map);\n@@ -283,7 +284,7 @@ impl InherentImpls {\n         db: &dyn HirDatabase,\n         block: BlockId,\n     ) -> Option<Arc<Self>> {\n-        let mut impls = Self { map: FxHashMap::default() };\n+        let mut impls = Self { map: FxHashMap::default(), invalid_impls: Vec::default() };\n         if let Some(block_def_map) = db.block_def_map(block) {\n             impls.collect_def_map(db, &block_def_map);\n             impls.shrink_to_fit();\n@@ -306,11 +307,17 @@ impl InherentImpls {\n                 }\n \n                 let self_ty = db.impl_self_ty(impl_id);\n-                let fp = TyFingerprint::for_inherent_impl(self_ty.skip_binders());\n-                if let Some(fp) = fp {\n-                    self.map.entry(fp).or_default().push(impl_id);\n+                let self_ty = self_ty.skip_binders();\n+\n+                match is_inherent_impl_coherent(db, def_map, &data, self_ty) {\n+                    true => {\n+                        // `fp` should only be `None` in error cases (either erroneous code or incomplete name resolution)\n+                        if let Some(fp) = TyFingerprint::for_inherent_impl(self_ty) {\n+                            self.map.entry(fp).or_default().push(impl_id);\n+                        }\n+                    }\n+                    false => self.invalid_impls.push(impl_id),\n                 }\n-                // `fp` should only be `None` in error cases (either erroneous code or incomplete name resolution)\n             }\n \n             // To better support custom derives, collect impls in all unnamed const items.\n@@ -334,6 +341,10 @@ impl InherentImpls {\n     pub fn all_impls(&self) -> impl Iterator<Item = ImplId> + '_ {\n         self.map.values().flat_map(|v| v.iter().copied())\n     }\n+\n+    pub fn invalid_impls(&self) -> &[ImplId] {\n+        &self.invalid_impls\n+    }\n }\n \n pub(crate) fn incoherent_inherent_impl_crates(\n@@ -775,6 +786,69 @@ fn find_matching_impl(\n     }\n }\n \n+fn is_inherent_impl_coherent(\n+    db: &dyn HirDatabase,\n+    def_map: &DefMap,\n+    impl_data: &ImplData,\n+    self_ty: &Ty,\n+) -> bool {\n+    let self_ty = self_ty.kind(Interner);\n+    let impl_allowed = match self_ty {\n+        TyKind::Tuple(_, _)\n+        | TyKind::FnDef(_, _)\n+        | TyKind::Array(_, _)\n+        | TyKind::Never\n+        | TyKind::Raw(_, _)\n+        | TyKind::Ref(_, _, _)\n+        | TyKind::Slice(_)\n+        | TyKind::Str\n+        | TyKind::Scalar(_) => def_map.is_rustc_coherence_is_core(),\n+\n+        &TyKind::Adt(AdtId(adt), _) => adt.module(db.upcast()).krate() == def_map.krate(),\n+        TyKind::Dyn(it) => it.principal().map_or(false, |trait_ref| {\n+            from_chalk_trait_id(trait_ref.trait_id).module(db.upcast()).krate() == def_map.krate()\n+        }),\n+\n+        _ => true,\n+    };\n+    impl_allowed || {\n+        let rustc_has_incoherent_inherent_impls = match self_ty {\n+            TyKind::Tuple(_, _)\n+            | TyKind::FnDef(_, _)\n+            | TyKind::Array(_, _)\n+            | TyKind::Never\n+            | TyKind::Raw(_, _)\n+            | TyKind::Ref(_, _, _)\n+            | TyKind::Slice(_)\n+            | TyKind::Str\n+            | TyKind::Scalar(_) => true,\n+\n+            &TyKind::Adt(AdtId(adt), _) => match adt {\n+                hir_def::AdtId::StructId(it) => {\n+                    db.struct_data(it).rustc_has_incoherent_inherent_impls\n+                }\n+                hir_def::AdtId::UnionId(it) => {\n+                    db.union_data(it).rustc_has_incoherent_inherent_impls\n+                }\n+                hir_def::AdtId::EnumId(it) => db.enum_data(it).rustc_has_incoherent_inherent_impls,\n+            },\n+            TyKind::Dyn(it) => it.principal().map_or(false, |trait_ref| {\n+                db.trait_data(from_chalk_trait_id(trait_ref.trait_id))\n+                    .rustc_has_incoherent_inherent_impls\n+            }),\n+\n+            _ => false,\n+        };\n+        rustc_has_incoherent_inherent_impls\n+            && !impl_data.items.is_empty()\n+            && impl_data.items.iter().copied().all(|assoc| match assoc {\n+                AssocItemId::FunctionId(it) => db.function_data(it).rustc_allow_incoherent_impl,\n+                AssocItemId::ConstId(it) => db.const_data(it).rustc_allow_incoherent_impl,\n+                AssocItemId::TypeAliasId(it) => db.type_alias_data(it).rustc_allow_incoherent_impl,\n+            })\n+    }\n+}\n+\n pub fn iterate_path_candidates(\n     ty: &Canonical<Ty>,\n     db: &dyn HirDatabase,"}, {"sha": "378d478336102f0c2399e7d2b2aedfd7531a0503", "filename": "crates/hir-ty/src/tests/method_resolution.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b4d7ea0692f2a72276704109ee13ffb3284f4863/crates%2Fhir-ty%2Fsrc%2Ftests%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4d7ea0692f2a72276704109ee13ffb3284f4863/crates%2Fhir-ty%2Fsrc%2Ftests%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftests%2Fmethod_resolution.rs?ref=b4d7ea0692f2a72276704109ee13ffb3284f4863", "patch": "@@ -9,6 +9,7 @@ fn infer_slice_method() {\n     check_types(\n         r#\"\n impl<T> [T] {\n+    #[rustc_allow_incoherent_impl]\n     fn foo(&self) -> T {\n         loop {}\n     }\n@@ -35,6 +36,7 @@ fn test() {\n //- /lib.rs crate:other_crate\n mod foo {\n     impl f32 {\n+        #[rustc_allow_incoherent_impl]\n         pub fn foo(self) -> f32 { 0. }\n     }\n }\n@@ -47,6 +49,7 @@ fn infer_array_inherent_impl() {\n     check_types(\n         r#\"\n impl<T, const N: usize> [T; N] {\n+    #[rustc_allow_incoherent_impl]\n     fn foo(&self) -> T {\n         loop {}\n     }\n@@ -1437,6 +1440,7 @@ fn resolve_const_generic_array_methods() {\n         r#\"\n #[lang = \"array\"]\n impl<T, const N: usize> [T; N] {\n+    #[rustc_allow_incoherent_impl]\n     pub fn map<F, U>(self, f: F) -> [U; N]\n     where\n         F: FnMut(T) -> U,\n@@ -1445,6 +1449,7 @@ impl<T, const N: usize> [T; N] {\n \n #[lang = \"slice\"]\n impl<T> [T] {\n+    #[rustc_allow_incoherent_impl]\n     pub fn map<F, U>(self, f: F) -> &[U]\n     where\n         F: FnMut(T) -> U,\n@@ -1468,6 +1473,7 @@ struct Const<const N: usize>;\n \n #[lang = \"array\"]\n impl<T, const N: usize> [T; N] {\n+    #[rustc_allow_incoherent_impl]\n     pub fn my_map<F, U, const X: usize>(self, f: F, c: Const<X>) -> [U; X]\n     where\n         F: FnMut(T) -> U,\n@@ -1476,6 +1482,7 @@ impl<T, const N: usize> [T; N] {\n \n #[lang = \"slice\"]\n impl<T> [T] {\n+    #[rustc_allow_incoherent_impl]\n     pub fn my_map<F, const X: usize, U>(self, f: F, c: Const<X>) -> &[U]\n     where\n         F: FnMut(T) -> U,\n@@ -1874,14 +1881,14 @@ fn incoherent_impls() {\n pub struct Box<T>(T);\n use core::error::Error;\n \n-#[rustc_allow_incoherent_impl]\n impl dyn Error {\n+    #[rustc_allow_incoherent_impl]\n     pub fn downcast<T: Error + 'static>(self: Box<Self>) -> Result<Box<T>, Box<dyn Error>> {\n         loop {}\n     }\n }\n-#[rustc_allow_incoherent_impl]\n impl dyn Error + Send {\n+    #[rustc_allow_incoherent_impl]\n     /// Attempts to downcast the box to a concrete type.\n     pub fn downcast<T: Error + 'static>(self: Box<Self>) -> Result<Box<T>, Box<dyn Error + Send>> {\n         let err: Box<dyn Error> = self;"}, {"sha": "13cc3fea52d16281c33419c4788ab94f27f38222", "filename": "crates/hir-ty/src/tests/simple.rs", "status": "modified", "additions": 31, "deletions": 29, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/b4d7ea0692f2a72276704109ee13ffb3284f4863/crates%2Fhir-ty%2Fsrc%2Ftests%2Fsimple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4d7ea0692f2a72276704109ee13ffb3284f4863/crates%2Fhir-ty%2Fsrc%2Ftests%2Fsimple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftests%2Fsimple.rs?ref=b4d7ea0692f2a72276704109ee13ffb3284f4863", "patch": "@@ -1116,21 +1116,22 @@ fn infer_inherent_method() {\n fn infer_inherent_method_str() {\n     check_infer(\n         r#\"\n-        #[lang = \"str\"]\n-        impl str {\n-            fn foo(&self) -> i32 {}\n-        }\n+#![rustc_coherence_is_core]\n+#[lang = \"str\"]\n+impl str {\n+    fn foo(&self) -> i32 {}\n+}\n \n-        fn test() {\n-            \"foo\".foo();\n-        }\n-        \"#,\n+fn test() {\n+    \"foo\".foo();\n+}\n+\"#,\n         expect![[r#\"\n-            39..43 'self': &str\n-            52..54 '{}': i32\n-            68..88 '{     ...o(); }': ()\n-            74..79 '\"foo\"': &str\n-            74..85 '\"foo\".foo()': i32\n+            67..71 'self': &str\n+            80..82 '{}': i32\n+            96..116 '{     ...o(); }': ()\n+            102..107 '\"foo\"': &str\n+            102..113 '\"foo\".foo()': i32\n         \"#]],\n     );\n }\n@@ -2640,6 +2641,7 @@ impl<T> [T] {}\n \n #[lang = \"slice_alloc\"]\n impl<T> [T] {\n+    #[rustc_allow_incoherent_impl]\n     pub fn into_vec<A: Allocator>(self: Box<Self, A>) -> Vec<T, A> {\n         unimplemented!()\n     }\n@@ -2655,22 +2657,22 @@ struct Astruct;\n impl B for Astruct {}\n \"#,\n         expect![[r#\"\n-            569..573 'self': Box<[T], A>\n-            602..634 '{     ...     }': Vec<T, A>\n-            648..761 '{     ...t]); }': ()\n-            658..661 'vec': Vec<i32, Global>\n-            664..679 '<[_]>::into_vec': fn into_vec<i32, Global>(Box<[i32], Global>) -> Vec<i32, Global>\n-            664..691 '<[_]>:...1i32])': Vec<i32, Global>\n-            680..690 'box [1i32]': Box<[i32; 1], Global>\n-            684..690 '[1i32]': [i32; 1]\n-            685..689 '1i32': i32\n-            701..702 'v': Vec<Box<dyn B, Global>, Global>\n-            722..739 '<[_]> ...to_vec': fn into_vec<Box<dyn B, Global>, Global>(Box<[Box<dyn B, Global>], Global>) -> Vec<Box<dyn B, Global>, Global>\n-            722..758 '<[_]> ...ruct])': Vec<Box<dyn B, Global>, Global>\n-            740..757 'box [b...truct]': Box<[Box<dyn B, Global>; 1], Global>\n-            744..757 '[box Astruct]': [Box<dyn B, Global>; 1]\n-            745..756 'box Astruct': Box<Astruct, Global>\n-            749..756 'Astruct': Astruct\n+            604..608 'self': Box<[T], A>\n+            637..669 '{     ...     }': Vec<T, A>\n+            683..796 '{     ...t]); }': ()\n+            693..696 'vec': Vec<i32, Global>\n+            699..714 '<[_]>::into_vec': fn into_vec<i32, Global>(Box<[i32], Global>) -> Vec<i32, Global>\n+            699..726 '<[_]>:...1i32])': Vec<i32, Global>\n+            715..725 'box [1i32]': Box<[i32; 1], Global>\n+            719..725 '[1i32]': [i32; 1]\n+            720..724 '1i32': i32\n+            736..737 'v': Vec<Box<dyn B, Global>, Global>\n+            757..774 '<[_]> ...to_vec': fn into_vec<Box<dyn B, Global>, Global>(Box<[Box<dyn B, Global>], Global>) -> Vec<Box<dyn B, Global>, Global>\n+            757..793 '<[_]> ...ruct])': Vec<Box<dyn B, Global>, Global>\n+            775..792 'box [b...truct]': Box<[Box<dyn B, Global>; 1], Global>\n+            779..792 '[box Astruct]': [Box<dyn B, Global>; 1]\n+            780..791 'box Astruct': Box<Astruct, Global>\n+            784..791 'Astruct': Astruct\n         \"#]],\n     )\n }"}, {"sha": "253d62dafc60b20ec3845e7cd7c189112d6a8e48", "filename": "crates/hir/src/diagnostics.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b4d7ea0692f2a72276704109ee13ffb3284f4863/crates%2Fhir%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4d7ea0692f2a72276704109ee13ffb3284f4863/crates%2Fhir%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fdiagnostics.rs?ref=b4d7ea0692f2a72276704109ee13ffb3284f4863", "patch": "@@ -3,6 +3,8 @@\n //!\n //! This probably isn't the best way to do this -- ideally, diagnostics should\n //! be expressed in terms of hir types themselves.\n+pub use hir_ty::diagnostics::{IncoherentImpl, IncorrectCase};\n+\n use base_db::CrateId;\n use cfg::{CfgExpr, CfgOptions};\n use either::Either;\n@@ -35,6 +37,7 @@ diagnostics![\n     InactiveCode,\n     IncorrectCase,\n     InvalidDeriveTarget,\n+    IncoherentImpl,\n     MacroError,\n     MalformedDerive,\n     MismatchedArgCount,\n@@ -220,5 +223,3 @@ pub struct NeedMut {\n pub struct UnusedMut {\n     pub local: Local,\n }\n-\n-pub use hir_ty::diagnostics::IncorrectCase;"}, {"sha": "35424feec8b29b294220be299c6ecaab1e1594cf", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b4d7ea0692f2a72276704109ee13ffb3284f4863/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4d7ea0692f2a72276704109ee13ffb3284f4863/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=b4d7ea0692f2a72276704109ee13ffb3284f4863", "patch": "@@ -85,10 +85,10 @@ use crate::db::{DefDatabase, HirDatabase};\n pub use crate::{\n     attrs::{HasAttrs, Namespace},\n     diagnostics::{\n-        AnyDiagnostic, BreakOutsideOfLoop, ExpectedFunction, InactiveCode, IncorrectCase,\n-        InvalidDeriveTarget, MacroError, MalformedDerive, MismatchedArgCount, MissingFields,\n-        MissingMatchArms, MissingUnsafe, NeedMut, NoSuchField, PrivateAssocItem, PrivateField,\n-        ReplaceFilterMapNextWithFindMap, TypeMismatch, UnimplementedBuiltinMacro,\n+        AnyDiagnostic, BreakOutsideOfLoop, ExpectedFunction, InactiveCode, IncoherentImpl,\n+        IncorrectCase, InvalidDeriveTarget, MacroError, MalformedDerive, MismatchedArgCount,\n+        MissingFields, MissingMatchArms, MissingUnsafe, NeedMut, NoSuchField, PrivateAssocItem,\n+        PrivateField, ReplaceFilterMapNextWithFindMap, TypeMismatch, UnimplementedBuiltinMacro,\n         UnresolvedExternCrate, UnresolvedField, UnresolvedImport, UnresolvedMacroCall,\n         UnresolvedMethodCall, UnresolvedModule, UnresolvedProcMacro, UnusedMut,\n     },\n@@ -604,11 +604,23 @@ impl Module {\n             }\n         }\n \n+        let inherent_impls = db.inherent_impls_in_crate(self.id.krate());\n+\n         for impl_def in self.impl_defs(db) {\n             for diag in db.impl_data_with_diagnostics(impl_def.id).1.iter() {\n                 emit_def_diagnostic(db, acc, diag);\n             }\n \n+            if inherent_impls.invalid_impls().contains(&impl_def.id) {\n+                let loc = impl_def.id.lookup(db.upcast());\n+                let tree = loc.id.item_tree(db.upcast());\n+                let node = &tree[loc.id.value];\n+                let file_id = loc.id.file_id();\n+                let ast_id_map = db.ast_id_map(file_id);\n+\n+                acc.push(IncoherentImpl { impl_: ast_id_map.get(node.ast_id()), file_id }.into())\n+            }\n+\n             for item in impl_def.items(db) {\n                 let def: DefWithBody = match item {\n                     AssocItem::Function(it) => it.into(),"}, {"sha": "77246379e7bd98a436dbae9f598260369318f275", "filename": "crates/ide-completion/src/completions/dot.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b4d7ea0692f2a72276704109ee13ffb3284f4863/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fdot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4d7ea0692f2a72276704109ee13ffb3284f4863/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fdot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fdot.rs?ref=b4d7ea0692f2a72276704109ee13ffb3284f4863", "patch": "@@ -415,7 +415,6 @@ fn foo(a: lib::A) { a.$0 }\n     fn test_local_impls() {\n         check(\n             r#\"\n-//- /lib.rs crate:lib\n pub struct A {}\n mod m {\n     impl super::A {\n@@ -427,9 +426,8 @@ mod m {\n         }\n     }\n }\n-//- /main.rs crate:main deps:lib\n-fn foo(a: lib::A) {\n-    impl lib::A {\n+fn foo(a: A) {\n+    impl A {\n         fn local_method(&self) {}\n     }\n     a.$0"}, {"sha": "c0e485c36fdd11c13aaabc2e92b4d13e4abfb8bf", "filename": "crates/ide-completion/src/tests/pattern.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b4d7ea0692f2a72276704109ee13ffb3284f4863/crates%2Fide-completion%2Fsrc%2Ftests%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4d7ea0692f2a72276704109ee13ffb3284f4863/crates%2Fide-completion%2Fsrc%2Ftests%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Ftests%2Fpattern.rs?ref=b4d7ea0692f2a72276704109ee13ffb3284f4863", "patch": "@@ -614,6 +614,7 @@ fn f(u: U) {\n \n     check_empty(\n         r#\"\n+#![rustc_coherence_is_core]\n #[lang = \"u32\"]\n impl u32 {\n     pub const MIN: Self = 0;"}, {"sha": "f8a6f6cd3ed065824f3943ca13aaefbf8c92ced8", "filename": "crates/ide-completion/src/tests/special.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b4d7ea0692f2a72276704109ee13ffb3284f4863/crates%2Fide-completion%2Fsrc%2Ftests%2Fspecial.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4d7ea0692f2a72276704109ee13ffb3284f4863/crates%2Fide-completion%2Fsrc%2Ftests%2Fspecial.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Ftests%2Fspecial.rs?ref=b4d7ea0692f2a72276704109ee13ffb3284f4863", "patch": "@@ -608,6 +608,7 @@ fn f() {\n }\n \n //- /core.rs crate:core\n+#![rustc_coherence_is_core]\n #[lang = \"u8\"]\n impl u8 {\n     pub const MAX: Self = 255;"}, {"sha": "72af9ebfcbb62e48a6c110bfaa5bbcca21b2b2cc", "filename": "crates/ide-diagnostics/src/handlers/incoherent_impl.rs", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/b4d7ea0692f2a72276704109ee13ffb3284f4863/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fincoherent_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4d7ea0692f2a72276704109ee13ffb3284f4863/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fincoherent_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fincoherent_impl.rs?ref=b4d7ea0692f2a72276704109ee13ffb3284f4863", "patch": "@@ -0,0 +1,77 @@\n+use hir::InFile;\n+\n+use crate::{Diagnostic, DiagnosticsContext, Severity};\n+\n+// Diagnostic: incoherent-impl\n+//\n+// This diagnostic is triggered if the targe type of an impl is from a foreign crate.\n+pub(crate) fn incoherent_impl(ctx: &DiagnosticsContext<'_>, d: &hir::IncoherentImpl) -> Diagnostic {\n+    Diagnostic::new(\n+        \"incoherent-impl\",\n+        format!(\"cannot define inherent `impl` for foreign type\"),\n+        ctx.sema.diagnostics_display_range(InFile::new(d.file_id, d.impl_.clone().into())).range,\n+    )\n+    .severity(Severity::Error)\n+}\n+\n+#[cfg(test)]\n+mod change_case {\n+    use crate::tests::check_diagnostics;\n+\n+    #[test]\n+    fn primitive() {\n+        check_diagnostics(\n+            r#\"\n+  impl bool {}\n+//^^^^^^^^^^^^ error: cannot define inherent `impl` for foreign type\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn primitive_rustc_allow_incoherent_impl() {\n+        check_diagnostics(\n+            r#\"\n+impl bool {\n+    #[rustc_allow_incoherent_impl]\n+    fn falsch(self) -> Self { false }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn rustc_allow_incoherent_impl() {\n+        check_diagnostics(\n+            r#\"\n+//- /lib.rs crate:foo\n+#[rustc_has_incoherent_inherent_impls]\n+pub struct S;\n+//- /main.rs crate:main deps:foo\n+impl foo::S {\n+    #[rustc_allow_incoherent_impl]\n+    fn func(self) {}\n+}\n+\"#,\n+        );\n+        check_diagnostics(\n+            r#\"\n+//- /lib.rs crate:foo\n+pub struct S;\n+//- /main.rs crate:main deps:foo\n+  impl foo::S { #[rustc_allow_incoherent_impl] fn func(self) {} }\n+//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ error: cannot define inherent `impl` for foreign type\n+\"#,\n+        );\n+        check_diagnostics(\n+            r#\"\n+//- /lib.rs crate:foo\n+#[rustc_has_incoherent_inherent_impls]\n+pub struct S;\n+//- /main.rs crate:main deps:foo\n+  impl foo::S { fn func(self) {} }\n+//^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ error: cannot define inherent `impl` for foreign type\n+\"#,\n+        );\n+    }\n+}"}, {"sha": "71f136b8c9030c0e85f9de909eb11b18368496e7", "filename": "crates/ide-diagnostics/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b4d7ea0692f2a72276704109ee13ffb3284f4863/crates%2Fide-diagnostics%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4d7ea0692f2a72276704109ee13ffb3284f4863/crates%2Fide-diagnostics%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Flib.rs?ref=b4d7ea0692f2a72276704109ee13ffb3284f4863", "patch": "@@ -29,6 +29,7 @@ mod handlers {\n     pub(crate) mod break_outside_of_loop;\n     pub(crate) mod expected_function;\n     pub(crate) mod inactive_code;\n+    pub(crate) mod incoherent_impl;\n     pub(crate) mod incorrect_case;\n     pub(crate) mod invalid_derive_target;\n     pub(crate) mod macro_error;\n@@ -254,6 +255,7 @@ pub fn diagnostics(\n             AnyDiagnostic::BreakOutsideOfLoop(d) => handlers::break_outside_of_loop::break_outside_of_loop(&ctx, &d),\n             AnyDiagnostic::ExpectedFunction(d) => handlers::expected_function::expected_function(&ctx, &d),\n             AnyDiagnostic::IncorrectCase(d) => handlers::incorrect_case::incorrect_case(&ctx, &d),\n+            AnyDiagnostic::IncoherentImpl(d) => handlers::incoherent_impl::incoherent_impl(&ctx, &d),\n             AnyDiagnostic::MacroError(d) => handlers::macro_error::macro_error(&ctx, &d),\n             AnyDiagnostic::MalformedDerive(d) => handlers::malformed_derive::malformed_derive(&ctx, &d),\n             AnyDiagnostic::MismatchedArgCount(d) => handlers::mismatched_arg_count::mismatched_arg_count(&ctx, &d),"}, {"sha": "a1a119629a94e43b814b95efb59ff7a0160bc123", "filename": "crates/ide/src/goto_implementation.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b4d7ea0692f2a72276704109ee13ffb3284f4863/crates%2Fide%2Fsrc%2Fgoto_implementation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4d7ea0692f2a72276704109ee13ffb3284f4863/crates%2Fide%2Fsrc%2Fgoto_implementation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fgoto_implementation.rs?ref=b4d7ea0692f2a72276704109ee13ffb3284f4863", "patch": "@@ -297,6 +297,7 @@ impl Foo<str> {}\n //- /lib.rs crate:main deps:core\n fn foo(_: bool$0) {{}}\n //- /libcore.rs crate:core\n+#![rustc_coherence_is_core]\n #[lang = \"bool\"]\n impl bool {}\n    //^^^^"}, {"sha": "1e1771259b1ba624101e1b911886ce3b5e2c7518", "filename": "crates/ide/src/inlay_hints/chaining.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b4d7ea0692f2a72276704109ee13ffb3284f4863/crates%2Fide%2Fsrc%2Finlay_hints%2Fchaining.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4d7ea0692f2a72276704109ee13ffb3284f4863/crates%2Fide%2Fsrc%2Finlay_hints%2Fchaining.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Finlay_hints%2Fchaining.rs?ref=b4d7ea0692f2a72276704109ee13ffb3284f4863", "patch": "@@ -435,7 +435,7 @@ fn main() {\n                                         file_id: FileId(\n                                             1,\n                                         ),\n-                                        range: 3386..3394,\n+                                        range: 3415..3423,\n                                     },\n                                 ),\n                                 tooltip: \"\",\n@@ -448,7 +448,7 @@ fn main() {\n                                         file_id: FileId(\n                                             1,\n                                         ),\n-                                        range: 3418..3422,\n+                                        range: 3447..3451,\n                                     },\n                                 ),\n                                 tooltip: \"\",\n@@ -468,7 +468,7 @@ fn main() {\n                                         file_id: FileId(\n                                             1,\n                                         ),\n-                                        range: 3386..3394,\n+                                        range: 3415..3423,\n                                     },\n                                 ),\n                                 tooltip: \"\",\n@@ -481,7 +481,7 @@ fn main() {\n                                         file_id: FileId(\n                                             1,\n                                         ),\n-                                        range: 3418..3422,\n+                                        range: 3447..3451,\n                                     },\n                                 ),\n                                 tooltip: \"\",\n@@ -501,7 +501,7 @@ fn main() {\n                                         file_id: FileId(\n                                             1,\n                                         ),\n-                                        range: 3386..3394,\n+                                        range: 3415..3423,\n                                     },\n                                 ),\n                                 tooltip: \"\",\n@@ -514,7 +514,7 @@ fn main() {\n                                         file_id: FileId(\n                                             1,\n                                         ),\n-                                        range: 3418..3422,\n+                                        range: 3447..3451,\n                                     },\n                                 ),\n                                 tooltip: \"\","}, {"sha": "ca6de4061a4b8d24c8ced00e423c72e9e9d511f2", "filename": "crates/test-utils/src/minicore.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b4d7ea0692f2a72276704109ee13ffb3284f4863/crates%2Ftest-utils%2Fsrc%2Fminicore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4d7ea0692f2a72276704109ee13ffb3284f4863/crates%2Ftest-utils%2Fsrc%2Fminicore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest-utils%2Fsrc%2Fminicore.rs?ref=b4d7ea0692f2a72276704109ee13ffb3284f4863", "patch": "@@ -44,6 +44,8 @@\n //!     try: infallible\n //!     unsize: sized\n \n+#![rustc_coherence_is_core]\n+\n pub mod marker {\n     // region:sized\n     #[lang = \"sized\"]"}]}