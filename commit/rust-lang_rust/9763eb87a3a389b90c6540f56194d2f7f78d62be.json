{"sha": "9763eb87a3a389b90c6540f56194d2f7f78d62be", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk3NjNlYjg3YTNhMzg5YjkwYzY1NDBmNTYxOTRkMmY3Zjc4ZDYyYmU=", "commit": {"author": {"name": "Camelid", "email": "camelidcamel@gmail.com", "date": "2021-02-21T22:21:43Z"}, "committer": {"name": "Camelid", "email": "camelidcamel@gmail.com", "date": "2021-03-06T01:57:58Z"}, "message": "rustdoc: Move most shared fields to `SharedContext`\n\n...and remove `Rc`s for the moved fields.\n\nThe only shared one that I didn't move was `cache`; see the doc-comment\nI added to `cache` for details.", "tree": {"sha": "d535e72c8bea6fbfa8801b7fa978eb9f2cea56d6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d535e72c8bea6fbfa8801b7fa978eb9f2cea56d6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9763eb87a3a389b90c6540f56194d2f7f78d62be", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9763eb87a3a389b90c6540f56194d2f7f78d62be", "html_url": "https://github.com/rust-lang/rust/commit/9763eb87a3a389b90c6540f56194d2f7f78d62be", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9763eb87a3a389b90c6540f56194d2f7f78d62be/comments", "author": {"login": "camelid", "id": 37223377, "node_id": "MDQ6VXNlcjM3MjIzMzc3", "avatar_url": "https://avatars.githubusercontent.com/u/37223377?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camelid", "html_url": "https://github.com/camelid", "followers_url": "https://api.github.com/users/camelid/followers", "following_url": "https://api.github.com/users/camelid/following{/other_user}", "gists_url": "https://api.github.com/users/camelid/gists{/gist_id}", "starred_url": "https://api.github.com/users/camelid/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camelid/subscriptions", "organizations_url": "https://api.github.com/users/camelid/orgs", "repos_url": "https://api.github.com/users/camelid/repos", "events_url": "https://api.github.com/users/camelid/events{/privacy}", "received_events_url": "https://api.github.com/users/camelid/received_events", "type": "User", "site_admin": false}, "committer": {"login": "camelid", "id": 37223377, "node_id": "MDQ6VXNlcjM3MjIzMzc3", "avatar_url": "https://avatars.githubusercontent.com/u/37223377?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camelid", "html_url": "https://github.com/camelid", "followers_url": "https://api.github.com/users/camelid/followers", "following_url": "https://api.github.com/users/camelid/following{/other_user}", "gists_url": "https://api.github.com/users/camelid/gists{/gist_id}", "starred_url": "https://api.github.com/users/camelid/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camelid/subscriptions", "organizations_url": "https://api.github.com/users/camelid/orgs", "repos_url": "https://api.github.com/users/camelid/repos", "events_url": "https://api.github.com/users/camelid/events{/privacy}", "received_events_url": "https://api.github.com/users/camelid/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8fd946c63a6c3aae9788bd459d278cb2efa77099", "url": "https://api.github.com/repos/rust-lang/rust/commits/8fd946c63a6c3aae9788bd459d278cb2efa77099", "html_url": "https://github.com/rust-lang/rust/commit/8fd946c63a6c3aae9788bd459d278cb2efa77099"}], "stats": {"total": 85, "additions": 48, "deletions": 37}, "files": [{"sha": "990a05679f1c4ba60ff072d9fb840607f45c438c", "filename": "src/librustdoc/html/render/context.rs", "status": "modified", "additions": 26, "deletions": 30, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/9763eb87a3a389b90c6540f56194d2f7f78d62be/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9763eb87a3a389b90c6540f56194d2f7f78d62be/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs?ref=9763eb87a3a389b90c6540f56194d2f7f78d62be", "patch": "@@ -3,11 +3,11 @@ use std::collections::BTreeMap;\n use std::io;\n use std::path::PathBuf;\n use std::rc::Rc;\n-use std::sync::mpsc::{channel, Receiver};\n+use std::sync::mpsc::channel;\n use std::sync::Arc;\n \n use rustc_data_structures::fx::FxHashMap;\n-use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n+use rustc_hir::def_id::LOCAL_CRATE;\n use rustc_middle::ty::TyCtxt;\n use rustc_session::Session;\n use rustc_span::edition::Edition;\n@@ -31,7 +31,7 @@ use crate::formats::item_type::ItemType;\n use crate::formats::FormatRenderer;\n use crate::html::escape::Escape;\n use crate::html::format::Buffer;\n-use crate::html::markdown::{self, plain_text_summary, ErrorCodes, IdMap};\n+use crate::html::markdown::{self, plain_text_summary, ErrorCodes};\n use crate::html::{layout, sources};\n \n /// Major driving force in all rustdoc rendering. This contains information\n@@ -53,20 +53,16 @@ crate struct Context<'tcx> {\n     /// real location of an item. This is used to allow external links to\n     /// publicly reused items to redirect to the right location.\n     crate render_redirect_pages: bool,\n-    /// `None` by default, depends on the `generate-redirect-map` option flag. If this field is set\n-    /// to `Some(...)`, it'll store redirections and then generate a JSON file at the top level of\n-    /// the crate.\n-    crate redirections: Option<Rc<RefCell<FxHashMap<String, String>>>>,\n-    /// The map used to ensure all generated 'id=' attributes are unique.\n-    pub(super) id_map: Rc<RefCell<IdMap>>,\n-    /// Tracks section IDs for `Deref` targets so they match in both the main\n-    /// body and the sidebar.\n-    pub(super) deref_id_map: Rc<RefCell<FxHashMap<DefId, String>>>,\n     crate shared: Arc<SharedContext<'tcx>>,\n-    all: Rc<RefCell<AllTypes>>,\n-    /// Storage for the errors produced while generating documentation so they\n-    /// can be printed together at the end.\n-    crate errors: Rc<Receiver<String>>,\n+    /// The [`Cache`] used during rendering.\n+    ///\n+    /// Ideally the cache would be in [`SharedContext`], but it's mutated\n+    /// between when the `SharedContext` is created and when `Context`\n+    /// is created, so more refactoring would be needed.\n+    ///\n+    /// It's immutable once in `Context`, so it's not as bad that it's not in\n+    /// `SharedContext`.\n+    // FIXME: move `cache` to `SharedContext`\n     crate cache: Rc<Cache>,\n }\n \n@@ -91,7 +87,7 @@ impl<'tcx> Context<'tcx> {\n     }\n \n     pub(super) fn derive_id(&self, id: String) -> String {\n-        let mut map = self.id_map.borrow_mut();\n+        let mut map = self.shared.id_map.borrow_mut();\n         map.derive(id)\n     }\n \n@@ -149,8 +145,8 @@ impl<'tcx> Context<'tcx> {\n         };\n \n         {\n-            self.id_map.borrow_mut().reset();\n-            self.id_map.borrow_mut().populate(&INITIAL_IDS);\n+            self.shared.id_map.borrow_mut().reset();\n+            self.shared.id_map.borrow_mut().populate(&INITIAL_IDS);\n         }\n \n         if !self.render_redirect_pages {\n@@ -169,7 +165,7 @@ impl<'tcx> Context<'tcx> {\n                     path.push('/');\n                 }\n                 path.push_str(&item_path(ty, names.last().unwrap()));\n-                match self.redirections {\n+                match self.shared.redirections {\n                     Some(ref redirections) => {\n                         let mut current_path = String::new();\n                         for name in &self.current {\n@@ -383,6 +379,11 @@ impl<'tcx> FormatRenderer<'tcx> for Context<'tcx> {\n             edition,\n             codes: ErrorCodes::from(unstable_features.is_nightly_build()),\n             playground,\n+            id_map: RefCell::new(id_map),\n+            deref_id_map: RefCell::new(FxHashMap::default()),\n+            all: RefCell::new(AllTypes::new()),\n+            errors: receiver,\n+            redirections: if generate_redirect_map { Some(Default::default()) } else { None },\n         };\n \n         // Add the default themes to the `Vec` of stylepaths\n@@ -409,13 +410,8 @@ impl<'tcx> FormatRenderer<'tcx> for Context<'tcx> {\n             current: Vec::new(),\n             dst,\n             render_redirect_pages: false,\n-            id_map: Rc::new(RefCell::new(id_map)),\n-            deref_id_map: Rc::new(RefCell::new(FxHashMap::default())),\n             shared: Arc::new(scx),\n-            all: Rc::new(RefCell::new(AllTypes::new())),\n-            errors: Rc::new(receiver),\n             cache: Rc::new(cache),\n-            redirections: if generate_redirect_map { Some(Default::default()) } else { None },\n         };\n \n         CURRENT_DEPTH.with(|s| s.set(0));\n@@ -464,7 +460,7 @@ impl<'tcx> FormatRenderer<'tcx> for Context<'tcx> {\n         } else {\n             String::new()\n         };\n-        let all = self.all.replace(AllTypes::new());\n+        let all = self.shared.all.replace(AllTypes::new());\n         let v = layout::render(\n             &self.shared.layout,\n             &page,\n@@ -494,7 +490,7 @@ impl<'tcx> FormatRenderer<'tcx> for Context<'tcx> {\n             &style_files,\n         );\n         self.shared.fs.write(&settings_file, v.as_bytes())?;\n-        if let Some(redirections) = self.redirections.take() {\n+        if let Some(ref redirections) = self.shared.redirections {\n             if !redirections.borrow().is_empty() {\n                 let redirect_map_path =\n                     self.dst.join(&*krate.name.as_str()).join(\"redirect-map.json\");\n@@ -506,7 +502,7 @@ impl<'tcx> FormatRenderer<'tcx> for Context<'tcx> {\n \n         // Flush pending errors.\n         Arc::get_mut(&mut self.shared).unwrap().fs.close();\n-        let nb_errors = self.errors.iter().map(|err| diag.struct_err(&err).emit()).count();\n+        let nb_errors = self.shared.errors.iter().map(|err| diag.struct_err(&err).emit()).count();\n         if nb_errors > 0 {\n             Err(Error::new(io::Error::new(io::ErrorKind::Other, \"I/O error\"), \"\"))\n         } else {\n@@ -585,13 +581,13 @@ impl<'tcx> FormatRenderer<'tcx> for Context<'tcx> {\n             self.shared.fs.write(&joint_dst, buf.as_bytes())?;\n \n             if !self.render_redirect_pages {\n-                self.all.borrow_mut().append(full_path(self, &item), &item_type);\n+                self.shared.all.borrow_mut().append(full_path(self, &item), &item_type);\n             }\n             // If the item is a macro, redirect from the old macro URL (with !)\n             // to the new one (without).\n             if item_type == ItemType::Macro {\n                 let redir_name = format!(\"{}.{}!.html\", item_type, name);\n-                if let Some(ref redirections) = self.redirections {\n+                if let Some(ref redirections) = self.shared.redirections {\n                     let crate_name = &self.shared.layout.krate;\n                     redirections.borrow_mut().insert(\n                         format!(\"{}/{}\", crate_name, redir_name),"}, {"sha": "3bb13d2999267967d8bae30fc254b7e729398efc", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 22, "deletions": 7, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/9763eb87a3a389b90c6540f56194d2f7f78d62be/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9763eb87a3a389b90c6540f56194d2f7f78d62be/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=9763eb87a3a389b90c6540f56194d2f7f78d62be", "patch": "@@ -41,6 +41,7 @@ use std::fmt;\n use std::path::{Path, PathBuf};\n use std::str;\n use std::string::ToString;\n+use std::sync::mpsc::Receiver;\n \n use itertools::Itertools;\n use rustc_ast_pretty::pprust;\n@@ -69,7 +70,7 @@ use crate::html::format::{\n     PrintWithSpace, WhereClause,\n };\n use crate::html::layout;\n-use crate::html::markdown::{self, ErrorCodes, Markdown, MarkdownHtml, MarkdownSummaryLine};\n+use crate::html::markdown::{self, ErrorCodes, IdMap, Markdown, MarkdownHtml, MarkdownSummaryLine};\n \n /// A pair of name and its optional document.\n crate type NameDoc = (String, Option<String>);\n@@ -119,6 +120,19 @@ crate struct SharedContext<'tcx> {\n     crate edition: Edition,\n     crate codes: ErrorCodes,\n     playground: Option<markdown::Playground>,\n+    /// The map used to ensure all generated 'id=' attributes are unique.\n+    id_map: RefCell<IdMap>,\n+    /// Tracks section IDs for `Deref` targets so they match in both the main\n+    /// body and the sidebar.\n+    deref_id_map: RefCell<FxHashMap<DefId, String>>,\n+    all: RefCell<AllTypes>,\n+    /// Storage for the errors produced while generating documentation so they\n+    /// can be printed together at the end.\n+    crate errors: Receiver<String>,\n+    /// `None` by default, depends on the `generate-redirect-map` option flag. If this field is set\n+    /// to `Some(...)`, it'll store redirections and then generate a JSON file at the top level of\n+    /// the crate.\n+    crate redirections: Option<RefCell<FxHashMap<String, String>>>,\n }\n \n impl SharedContext<'_> {\n@@ -635,7 +649,7 @@ fn render_markdown(\n     prefix: &str,\n     is_hidden: bool,\n ) {\n-    let mut ids = cx.id_map.borrow_mut();\n+    let mut ids = cx.shared.id_map.borrow_mut();\n     write!(\n         w,\n         \"<div class=\\\"docblock{}\\\">{}{}</div>\",\n@@ -795,7 +809,7 @@ fn short_item_info(\n \n         if let Some(note) = note {\n             let note = note.as_str();\n-            let mut ids = cx.id_map.borrow_mut();\n+            let mut ids = cx.shared.id_map.borrow_mut();\n             let html = MarkdownHtml(\n                 &note,\n                 &mut ids,\n@@ -834,7 +848,7 @@ fn short_item_info(\n         message.push_str(&format!(\" ({})\", feature));\n \n         if let Some(unstable_reason) = reason {\n-            let mut ids = cx.id_map.borrow_mut();\n+            let mut ids = cx.shared.id_map.borrow_mut();\n             message = format!(\n                 \"<details><summary>{}</summary>{}</details>\",\n                 message,\n@@ -1174,7 +1188,8 @@ fn render_assoc_items(\n                     type_.print(cx.cache())\n                 )));\n                 debug!(\"Adding {} to deref id map\", type_.print(cx.cache()));\n-                cx.deref_id_map\n+                cx.shared\n+                    .deref_id_map\n                     .borrow_mut()\n                     .insert(type_.def_id_full(cx.cache()).unwrap(), id.clone());\n                 write!(\n@@ -1481,7 +1496,7 @@ fn render_impl(\n         }\n \n         if let Some(ref dox) = cx.shared.maybe_collapsed_doc_value(&i.impl_item) {\n-            let mut ids = cx.id_map.borrow_mut();\n+            let mut ids = cx.shared.id_map.borrow_mut();\n             write!(\n                 w,\n                 \"<div class=\\\"docblock\\\">{}</div>\",\n@@ -2030,7 +2045,7 @@ fn sidebar_deref_methods(cx: &Context<'_>, out: &mut Buffer, impl_: &Impl, v: &V\n                 .flat_map(|i| get_methods(i.inner_impl(), true, &mut used_links, deref_mut, c))\n                 .collect::<Vec<_>>();\n             if !ret.is_empty() {\n-                let deref_id_map = cx.deref_id_map.borrow();\n+                let deref_id_map = cx.shared.deref_id_map.borrow();\n                 let id = deref_id_map\n                     .get(&real_target.def_id_full(cx.cache()).unwrap())\n                     .expect(\"Deref section without derived id\");"}]}