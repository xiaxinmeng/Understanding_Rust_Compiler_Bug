{"sha": "c9e51cef122bcdd50e4571649421e5ab7d99faeb", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM5ZTUxY2VmMTIyYmNkZDUwZTQ1NzE2NDk0MjFlNWFiN2Q5OWZhZWI=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@gmail", "date": "2013-07-18T10:04:33Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@gmail", "date": "2013-07-25T17:47:03Z"}, "message": "debuginfo: Support for function arguments. (WIP)", "tree": {"sha": "c5b9524d4af7fac8d54149347cfc35cf364441f3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c5b9524d4af7fac8d54149347cfc35cf364441f3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c9e51cef122bcdd50e4571649421e5ab7d99faeb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c9e51cef122bcdd50e4571649421e5ab7d99faeb", "html_url": "https://github.com/rust-lang/rust/commit/c9e51cef122bcdd50e4571649421e5ab7d99faeb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c9e51cef122bcdd50e4571649421e5ab7d99faeb/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "203f96f71d86cc6a2d95b8337977835ac1a41c36", "url": "https://api.github.com/repos/rust-lang/rust/commits/203f96f71d86cc6a2d95b8337977835ac1a41c36", "html_url": "https://github.com/rust-lang/rust/commit/203f96f71d86cc6a2d95b8337977835ac1a41c36"}], "stats": {"total": 151, "additions": 84, "deletions": 67}, "files": [{"sha": "add52254b02be06bfd19a12a409a08e289635f78", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 83, "deletions": 64, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/c9e51cef122bcdd50e4571649421e5ab7d99faeb/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9e51cef122bcdd50e4571649421e5ab7d99faeb/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=c9e51cef122bcdd50e4571649421e5ab7d99faeb", "patch": "@@ -91,14 +91,15 @@ static DW_ATE_unsigned_char: c_uint = 0x08;\n \n /// A context object for maintaining all state needed by the debuginfo module.\n pub struct DebugContext {\n-    crate_file: ~str,\n-    llcontext: ContextRef,\n-    builder: DIBuilderRef,\n-    curr_loc: (uint, uint),\n-    created_files: HashMap<~str, DIFile>,\n-    created_functions: HashMap<ast::node_id, DISubprogram>,\n-    created_blocks: HashMap<ast::node_id, DILexicalBlock>,\n-    created_types: HashMap<uint, DIType>\n+    priv crate_file: ~str,\n+    priv llcontext: ContextRef,\n+    priv builder: DIBuilderRef,\n+    priv curr_loc: (uint, uint),\n+    priv created_files: HashMap<~str, DIFile>,\n+    priv created_functions: HashMap<ast::node_id, DISubprogram>,\n+    priv created_blocks: HashMap<ast::node_id, DILexicalBlock>,\n+    priv created_types: HashMap<uint, DIType>,\n+    priv argument_index_counters: HashMap<ast::node_id, uint>,\n }\n \n impl DebugContext {\n@@ -116,6 +117,7 @@ impl DebugContext {\n             created_functions: HashMap::new(),\n             created_blocks: HashMap::new(),\n             created_types: HashMap::new(),\n+            argument_index_counters: HashMap::new(),\n         };\n     }\n }\n@@ -138,11 +140,14 @@ pub fn create_local_var_metadata(bcx: @mut Block, local: &ast::Local) {\n     let def_map = cx.tcx.def_map;\n     let pattern = local.node.pat;\n \n-    let context = match bcx.parent {\n+    let scope = match bcx.parent {\n         None => create_function_metadata(bcx.fcx),\n         Some(_) => lexical_block_metadata(bcx)\n     };\n \n+    let filename = span_start(cx, local.span).file.name;\n+    let file_metadata = file_metadata(cx, filename);\n+\n     do pat_util::pat_bindings(def_map, pattern) |_, node_id, span, path_ref| {\n \n         let ident = ast_util::path_to_ident(path_ref);\n@@ -151,14 +156,13 @@ pub fn create_local_var_metadata(bcx: @mut Block, local: &ast::Local) {\n         let loc = span_start(cx, span);\n         let ty = node_id_type(bcx, node_id);\n         let type_metadata = type_metadata(cx, ty, span);\n-        let file_metadata = file_metadata(cx, loc.file.name);\n \n         let var_metadata = do as_c_str(name) |name| {\n             unsafe {\n                 llvm::LLVMDIBuilderCreateLocalVariable(\n                     DIB(cx),\n                     DW_TAG_auto_variable,\n-                    context,\n+                    scope,\n                     name,\n                     file_metadata,\n                     loc.line as c_uint,\n@@ -172,9 +176,7 @@ pub fn create_local_var_metadata(bcx: @mut Block, local: &ast::Local) {\n         let llptr = match bcx.fcx.lllocals.find_copy(&node_id) {\n             Some(v) => v,\n             None => {\n-                bcx.tcx().sess.span_bug(\n-                    local.span,\n-                    fmt!(\"No entry in lllocals table for %?\", local.node.id));\n+                bcx.tcx().sess.span_bug(span, fmt!(\"No entry in lllocals table for %?\", node_id));\n             }\n         };\n \n@@ -194,64 +196,77 @@ pub fn create_local_var_metadata(bcx: @mut Block, local: &ast::Local) {\n /// Creates debug information for the given function argument.\n ///\n /// Adds the created metadata nodes directly to the crate's IR.\n-/// The return value should be ignored if called from outside of the debuginfo module.\n-pub fn create_argument_metadata(bcx: @mut Block, arg: &ast::arg, span: span) -> Option<DIVariable> {\n-    debug!(\"create_argument_metadata\");\n-    if true {\n-        // XXX create_argument_metadata disabled for now because \"node_id_type(bcx, arg.id)\" below\n-        // blows up:\n-        // \"error: internal compiler error: node_id_to_type: no type for node `arg (id=10)`\"\n-        return None;\n-    }\n-\n+pub fn create_argument_metadata(bcx: @mut Block, arg: &ast::arg, span: span) {\n     let fcx = bcx.fcx;\n     let cx = fcx.ccx;\n \n-    let loc = span_start(cx, span);\n-    if \"<intrinsic>\" == loc.file.name {\n-        return None;\n+    if fcx.span.is_none() {\n+        return;\n     }\n \n-    let ty = node_id_type(bcx, arg.id);\n-    let type_metadata = type_metadata(cx, ty, arg.ty.span);\n-    let file_metadata = file_metadata(cx, loc.file.name);\n-    let context = create_function_metadata(fcx);\n-\n-    match arg.pat.node {\n-        ast::pat_ident(_, ref path, _) => {\n-            // XXX: This is wrong; it should work for multiple bindings.\n-            let ident = path.idents.last();\n-            let name: &str = cx.sess.str_of(*ident);\n-            let var_metadata = do name.as_c_str |name| {\n-                unsafe {\n-                    llvm::LLVMDIBuilderCreateLocalVariable(\n-                        DIB(cx),\n-                        DW_TAG_arg_variable as u32,\n-                        context,\n-                        name,\n-                        file_metadata,\n-                        loc.line as c_uint,\n-                        type_metadata,\n-                        false,\n-                        0,\n-                        0)\n-                    // XXX need to pass in a real argument number\n-                }\n-            };\n+    if \"<intrinsic>\" == span_start(cx, span).file.name {\n+        return;\n+    }\n+\n+    let def_map = cx.tcx.def_map;\n+    let pattern = arg.pat;\n+\n+    let mut argument_index = match dbg_cx(cx).argument_index_counters.find_copy(&arg.id) {\n+        Some(value) => value,\n+        None => 0\n+    };\n+\n+    let filename = span_start(cx, span).file.name;\n+    let file_metadata = file_metadata(cx, filename);\n+    let scope = create_function_metadata(fcx);\n+\n+    do pat_util::pat_bindings(def_map, pattern) |_, node_id, span, path_ref| {\n+\n+        let ty = node_id_type(bcx, node_id);\n+        let type_metadata = type_metadata(cx, ty, codemap::dummy_sp());\n+        let loc = span_start(cx, span);\n+        let ident = ast_util::path_to_ident(path_ref);\n+        let name: &str = cx.sess.str_of(ident);\n+        debug!(\"create_argument_metadata: %s\", name);\n \n-            let llptr = fcx.llargs.get_copy(&arg.id);\n-            set_debug_location(cx, lexical_block_metadata(bcx), loc.line, loc.col.to_uint());\n+        let arg_metadata = do as_c_str(name) |name| {\n             unsafe {\n-                let instr = llvm::LLVMDIBuilderInsertDeclareAtEnd(\n-                        DIB(cx), llptr, var_metadata, bcx.llbb);\n-                llvm::LLVMSetInstDebugLocation(trans::build::B(bcx).llbuilder, instr);\n+                llvm::LLVMDIBuilderCreateLocalVariable(\n+                    DIB(cx),\n+                    DW_TAG_arg_variable,\n+                    scope,\n+                    name,\n+                    file_metadata,\n+                    loc.line as c_uint,\n+                    type_metadata,\n+                    false,\n+                    0,\n+                    argument_index as c_uint)\n             }\n-            return Some(var_metadata);\n-        }\n-        _ => {\n-            return None;\n+        };\n+\n+        argument_index += 1;\n+\n+        let llptr = match bcx.fcx.llargs.find_copy(&node_id) {\n+            Some(v) => v,\n+            None => {\n+                bcx.tcx().sess.span_bug(span, fmt!(\"No entry in llargs table for %?\", node_id));\n+            }\n+        };\n+\n+        set_debug_location(cx, lexical_block_metadata(bcx), loc.line, loc.col.to_uint());\n+        unsafe {\n+            let instr = llvm::LLVMDIBuilderInsertDeclareAtEnd(\n+                DIB(cx),\n+                llptr,\n+                arg_metadata,\n+                bcx.llbb);\n+\n+            llvm::LLVMSetInstDebugLocation(trans::build::B(bcx), instr);\n         }\n     }\n+\n+    dbg_cx(cx).argument_index_counters.insert(arg.id, argument_index);\n }\n \n /// Sets the current debug location at the beginning of the span\n@@ -272,7 +287,6 @@ pub fn update_source_pos(bcx: @mut Block, span: span) {\n /// The return value should be ignored if called from outside of the debuginfo module.\n pub fn create_function_metadata(fcx: &FunctionContext) -> DISubprogram {\n     let cx = fcx.ccx;\n-    let span = fcx.span.get();\n \n     let fnitem = cx.tcx.items.get_copy(&fcx.id);\n     let (ident, ret_ty, id) = match fnitem {\n@@ -318,14 +332,19 @@ pub fn create_function_metadata(fcx: &FunctionContext) -> DISubprogram {\n             _) => {\n             (ident, ty, id)\n         }\n-        _ => fcx.ccx.sess.bug(\"create_function_metadata: unexpected sort of node\")\n+        _ => fcx.ccx.sess.bug(fmt!(\"create_function_metadata: unexpected sort of node: %?\", fnitem))\n     };\n \n     match dbg_cx(cx).created_functions.find(&id) {\n         Some(fn_metadata) => return *fn_metadata,\n         None => ()\n     }\n \n+    let span = match fcx.span {\n+        Some(value) => value,\n+        None => codemap::dummy_sp()\n+    };\n+\n     debug!(\"create_function_metadata: %s, %s\",\n            cx.sess.str_of(ident),\n            cx.sess.codemap.span_to_str(span));"}, {"sha": "5a410ef6462caf40fd9a80c3b9859f89f4b8083c", "filename": "src/test/debug-info/function-arguments.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c9e51cef122bcdd50e4571649421e5ab7d99faeb/src%2Ftest%2Fdebug-info%2Ffunction-arguments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9e51cef122bcdd50e4571649421e5ab7d99faeb/src%2Ftest%2Fdebug-info%2Ffunction-arguments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Ffunction-arguments.rs?ref=c9e51cef122bcdd50e4571649421e5ab7d99faeb", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// xfail-test\n-\n // compile-flags:-Z extra-debug-info\n // debugger:break zzz\n // debugger:run\n@@ -34,7 +32,7 @@ fn main() {\n     nested(2000, 3000);\n \n     fn nested(a: i32, b: i64) -> (i32, i64) {\n-        zzz()\n+        zzz();\n         (a, b)\n     }\n }"}]}