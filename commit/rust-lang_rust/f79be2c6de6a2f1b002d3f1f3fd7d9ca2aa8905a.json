{"sha": "f79be2c6de6a2f1b002d3f1f3fd7d9ca2aa8905a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY3OWJlMmM2ZGU2YTJmMWIwMDJkM2YxZjNmZDdkOWNhMmFhODkwNWE=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2021-02-17T22:51:17Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-02-17T22:51:17Z"}, "message": "Rollup merge of #81898 - nanguye2496:nanguye2496/fix_str_and_slice_visualization, r=varkor\n\nFix debug information for function arguments of type &str or slice.\n\nIssue details:\nWhen lowering MIR to LLVM IR, the compiler decomposes every &str and slice argument into a data pointer and a usize. Then, the original argument is reconstructed from the pointer and the usize arguments in the body of the function that owns it. Since the original argument is declared in the body of a function, it should be marked as a LocalVariable instead of an ArgumentVairable. This confusion causes MSVC debuggers unable to visualize &str and slice arguments correctly. (See https://github.com/rust-lang/rust/issues/81894 for more details).\n\nFix details:\nMaking sure that the debug variable for every &str and slice argument is marked as LocalVariable instead of ArgumentVariable in computing_per_local_var_debug_info. This change has been verified on VS Code debugger, VS debugger, WinDbg and LLDB.", "tree": {"sha": "fd3758275f0cd5f99e0d54dd9190bdc5479cb2b1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fd3758275f0cd5f99e0d54dd9190bdc5479cb2b1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f79be2c6de6a2f1b002d3f1f3fd7d9ca2aa8905a", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgLZ3lCRBK7hj4Ov3rIwAAdHIIALDOmt35tllWGTlFR+IUMdpI\ngTupMgEjlxFy35u2O10OShfMe+bfqMU08xxasz1LMU9q9kBe9Qf1ZwuXTnMAo9Hm\nRsXjxtG1MKfq6YaZeJc/bwtPZLYsTcCsszl8OLAdMWHHlyPWoeTLTrBn+9P+BN3J\n1l3KXRiRr3uxbxcGmM+OYssqMyDECqeP6A0dVblKpHvO5CpPI77OOzCk4jr+9K7O\nW+7y2w9KaoACRuWtnkiUg5C1a3e0AFRupI+pNcJ+JAVWzJfv6q6b6v1Y1HVayaN5\nf0ws7lB/4M+RnBV1X/oAnXSK1WfWT0262v6gQ1lKojDLSykKbDxmwLB/IzwErFg=\n=5HOs\n-----END PGP SIGNATURE-----\n", "payload": "tree fd3758275f0cd5f99e0d54dd9190bdc5479cb2b1\nparent 91e5384fc0d4b7babc360dca12c5a9d88332f13b\nparent 615fd141bde1e4319f95c3ea2981a1f5a8aa5dbd\nauthor Dylan DPC <dylan.dpc@gmail.com> 1613602277 +0100\ncommitter GitHub <noreply@github.com> 1613602277 +0100\n\nRollup merge of #81898 - nanguye2496:nanguye2496/fix_str_and_slice_visualization, r=varkor\n\nFix debug information for function arguments of type &str or slice.\n\nIssue details:\nWhen lowering MIR to LLVM IR, the compiler decomposes every &str and slice argument into a data pointer and a usize. Then, the original argument is reconstructed from the pointer and the usize arguments in the body of the function that owns it. Since the original argument is declared in the body of a function, it should be marked as a LocalVariable instead of an ArgumentVairable. This confusion causes MSVC debuggers unable to visualize &str and slice arguments correctly. (See https://github.com/rust-lang/rust/issues/81894 for more details).\n\nFix details:\nMaking sure that the debug variable for every &str and slice argument is marked as LocalVariable instead of ArgumentVariable in computing_per_local_var_debug_info. This change has been verified on VS Code debugger, VS debugger, WinDbg and LLDB.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f79be2c6de6a2f1b002d3f1f3fd7d9ca2aa8905a", "html_url": "https://github.com/rust-lang/rust/commit/f79be2c6de6a2f1b002d3f1f3fd7d9ca2aa8905a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f79be2c6de6a2f1b002d3f1f3fd7d9ca2aa8905a/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "91e5384fc0d4b7babc360dca12c5a9d88332f13b", "url": "https://api.github.com/repos/rust-lang/rust/commits/91e5384fc0d4b7babc360dca12c5a9d88332f13b", "html_url": "https://github.com/rust-lang/rust/commit/91e5384fc0d4b7babc360dca12c5a9d88332f13b"}, {"sha": "615fd141bde1e4319f95c3ea2981a1f5a8aa5dbd", "url": "https://api.github.com/repos/rust-lang/rust/commits/615fd141bde1e4319f95c3ea2981a1f5a8aa5dbd", "html_url": "https://github.com/rust-lang/rust/commit/615fd141bde1e4319f95c3ea2981a1f5a8aa5dbd"}], "stats": {"total": 30, "additions": 25, "deletions": 5}, "files": [{"sha": "ea59e1831188b82bca2bb0db58037f9d3c1bcba9", "filename": "compiler/rustc_codegen_ssa/src/mir/debuginfo.rs", "status": "modified", "additions": 25, "deletions": 5, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/f79be2c6de6a2f1b002d3f1f3fd7d9ca2aa8905a/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f79be2c6de6a2f1b002d3f1f3fd7d9ca2aa8905a/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fdebuginfo.rs?ref=f79be2c6de6a2f1b002d3f1f3fd7d9ca2aa8905a", "patch": "@@ -320,6 +320,8 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     ) -> Option<IndexVec<mir::Local, Vec<PerLocalVarDebugInfo<'tcx, Bx::DIVariable>>>> {\n         let full_debug_info = self.cx.sess().opts.debuginfo == DebugInfo::Full;\n \n+        let target_is_msvc = self.cx.sess().target.is_like_msvc;\n+\n         if !full_debug_info && self.cx.sess().fewer_names() {\n             return None;\n         }\n@@ -341,11 +343,29 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                             && var.source_info.scope == mir::OUTERMOST_SOURCE_SCOPE\n                         {\n                             let arg_index = place.local.index() - 1;\n-\n-                            // FIXME(eddyb) shouldn't `ArgumentVariable` indices be\n-                            // offset in closures to account for the hidden environment?\n-                            // Also, is this `+ 1` needed at all?\n-                            VariableKind::ArgumentVariable(arg_index + 1)\n+                            if target_is_msvc {\n+                                // Rust compiler decomposes every &str or slice argument into two components:\n+                                // a pointer to the memory address where the data is stored and a usize representing\n+                                // the length of the str (or slice). These components will later be used to reconstruct\n+                                // the original argument inside the body of the function that owns it (see the\n+                                // definition of debug_introduce_local for more details).\n+                                //\n+                                // Since the original argument is declared inside a function rather than being passed\n+                                // in as an argument, it must be marked as a LocalVariable for MSVC debuggers to visualize\n+                                // its data correctly. (See issue #81894 for an in-depth description of the problem).\n+                                match *var_ty.kind() {\n+                                    ty::Ref(_, inner_type, _) => match *inner_type.kind() {\n+                                        ty::Slice(_) | ty::Str => VariableKind::LocalVariable,\n+                                        _ => VariableKind::ArgumentVariable(arg_index + 1),\n+                                    },\n+                                    _ => VariableKind::ArgumentVariable(arg_index + 1),\n+                                }\n+                            } else {\n+                                // FIXME(eddyb) shouldn't `ArgumentVariable` indices be\n+                                // offset in closures to account for the hidden environment?\n+                                // Also, is this `+ 1` needed at all?\n+                                VariableKind::ArgumentVariable(arg_index + 1)\n+                            }\n                         } else {\n                             VariableKind::LocalVariable\n                         };"}]}