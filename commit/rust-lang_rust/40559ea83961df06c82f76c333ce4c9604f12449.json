{"sha": "40559ea83961df06c82f76c333ce4c9604f12449", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQwNTU5ZWE4Mzk2MWRmMDZjODJmNzZjMzMzY2U0Yzk2MDRmMTI0NDk=", "commit": {"author": {"name": "Eric Holk", "email": "eric.holk@gmail.com", "date": "2012-06-15T21:10:36Z"}, "committer": {"name": "Eric Holk", "email": "eric.holk@gmail.com", "date": "2012-06-21T23:11:11Z"}, "message": "Adding a benchmark for the new message passing code", "tree": {"sha": "ab367023fad94616c8d6d40126ef00b6d1e084a8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ab367023fad94616c8d6d40126ef00b6d1e084a8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/40559ea83961df06c82f76c333ce4c9604f12449", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/40559ea83961df06c82f76c333ce4c9604f12449", "html_url": "https://github.com/rust-lang/rust/commit/40559ea83961df06c82f76c333ce4c9604f12449", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/40559ea83961df06c82f76c333ce4c9604f12449/comments", "author": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dc3862bf58297b75a0e3d4dfdf1f66b56f51dd1d", "url": "https://api.github.com/repos/rust-lang/rust/commits/dc3862bf58297b75a0e3d4dfdf1f66b56f51dd1d", "html_url": "https://github.com/rust-lang/rust/commit/dc3862bf58297b75a0e3d4dfdf1f66b56f51dd1d"}], "stats": {"total": 76, "additions": 76, "deletions": 0}, "files": [{"sha": "cba62f2ada11900b9a6a236fec9fb8a94b27145c", "filename": "src/test/bench/msgsend-ring-new.rs", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/40559ea83961df06c82f76c333ce4c9604f12449/src%2Ftest%2Fbench%2Fmsgsend-ring-new.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40559ea83961df06c82f76c333ce4c9604f12449/src%2Ftest%2Fbench%2Fmsgsend-ring-new.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-new.rs?ref=40559ea83961df06c82f76c333ce4c9604f12449", "patch": "@@ -0,0 +1,76 @@\n+// This test creates a bunch of tasks that simultaneously send to each\n+// other in a ring. The messages should all be basically\n+// independent. It's designed to hammer the global kernel lock, so\n+// that things will look really good once we get that lock out of the\n+// message path.\n+\n+import newcomm::*;\n+import future::future;\n+\n+use std;\n+import std::time;\n+\n+fn thread_ring(i: uint,\n+               count: uint,\n+               num_chan: chan<uint>,\n+               num_port: port<uint>) {\n+    // Send/Receive lots of messages.\n+    for uint::range(0u, count) {|j|\n+        num_chan.send(i * j);\n+        num_port.recv();\n+    };\n+}\n+\n+fn main(args: [str]) {\n+    let args = if os::getenv(\"RUST_BENCH\").is_some() {\n+        [\"\", \"100\", \"10000\"]\n+    } else if args.len() <= 1u {\n+        [\"\", \"100\", \"1000\"]\n+    } else {\n+        args\n+    };        \n+\n+    let num_tasks = option::get(uint::from_str(args[1]));\n+    let msg_per_task = option::get(uint::from_str(args[2]));\n+\n+    let num_port = port();\n+    let mut num_chan = chan(num_port);\n+\n+    let start = time::precise_time_s();\n+\n+    // create the ring\n+    let mut futures = [];\n+\n+    for uint::range(1u, num_tasks) {|i|\n+        let get_chan = port();\n+        let get_chan_chan = chan(get_chan);\n+        {\n+            let num_chan = num_chan.clone();\n+            futures += [future::spawn {|move num_chan, move get_chan_chan|\n+                let p = port();\n+                get_chan_chan.send(chan(p));\n+                thread_ring(i, msg_per_task, num_chan,  p)\n+            }];\n+        }\n+        \n+        num_chan = get_chan.recv();\n+    };\n+\n+    // do our iteration\n+    thread_ring(0u, msg_per_task, num_chan, num_port);\n+\n+    // synchronize\n+    for futures.each {|f| f.get() };\n+\n+    let stop = time::precise_time_s();\n+\n+    // all done, report stats.\n+    let num_msgs = num_tasks * msg_per_task;\n+    let elapsed = (stop - start);\n+    let rate = (num_msgs as float) / elapsed;\n+\n+    io::println(#fmt(\"Sent %? messages in %? seconds\",\n+                     num_msgs, elapsed));\n+    io::println(#fmt(\"  %? messages / second\", rate));\n+    io::println(#fmt(\"  %? \u03bcs / message\", 1000000. / rate));\n+}"}]}