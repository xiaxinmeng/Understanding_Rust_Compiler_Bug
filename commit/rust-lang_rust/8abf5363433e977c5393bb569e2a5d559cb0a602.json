{"sha": "8abf5363433e977c5393bb569e2a5d559cb0a602", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhhYmY1MzYzNDMzZTk3N2M1MzkzYmI1NjllMmE1ZDU1OWNiMGE2MDI=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-08-29T15:03:14Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-08-29T15:03:14Z"}, "message": "Grand refactoring", "tree": {"sha": "8bb7bc3097cb9e22af9e3be8605cb4745c2fae5f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8bb7bc3097cb9e22af9e3be8605cb4745c2fae5f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8abf5363433e977c5393bb569e2a5d559cb0a602", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8abf5363433e977c5393bb569e2a5d559cb0a602", "html_url": "https://github.com/rust-lang/rust/commit/8abf5363433e977c5393bb569e2a5d559cb0a602", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8abf5363433e977c5393bb569e2a5d559cb0a602/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2007ccfcfe0bf01c934589dd3c87fda83b06b272", "url": "https://api.github.com/repos/rust-lang/rust/commits/2007ccfcfe0bf01c934589dd3c87fda83b06b272", "html_url": "https://github.com/rust-lang/rust/commit/2007ccfcfe0bf01c934589dd3c87fda83b06b272"}], "stats": {"total": 1071, "additions": 589, "deletions": 482}, "files": [{"sha": "f2589ef2f8d85cb9291770776514303e799b8c11", "filename": "code/src/extension.ts", "status": "modified", "additions": 51, "deletions": 40, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/8abf5363433e977c5393bb569e2a5d559cb0a602/code%2Fsrc%2Fextension.ts", "raw_url": "https://github.com/rust-lang/rust/raw/8abf5363433e977c5393bb569e2a5d559cb0a602/code%2Fsrc%2Fextension.ts", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/code%2Fsrc%2Fextension.ts?ref=8abf5363433e977c5393bb569e2a5d559cb0a602", "patch": "@@ -60,11 +60,8 @@ export function activate(context: vscode.ExtensionContext) {\n             textDocument: { uri: editor.document.uri.toString() },\n             range: client.code2ProtocolConverter.asRange(editor.selection),\n         }\n-        let response = await client.sendRequest<lc.TextEdit[]>(\"m/joinLines\", request)\n-        let edits = client.protocol2CodeConverter.asTextEdits(response)\n-        let wsEdit = new vscode.WorkspaceEdit()\n-        wsEdit.set(editor.document.uri, edits)\n-        return vscode.workspace.applyEdit(wsEdit)\n+        let change = await client.sendRequest<SourceChange>(\"m/joinLines\", request)\n+        await applySourceChange(change)\n     })\n     registerCommand('libsyntax-rust.parentModule', async () => {\n         let editor = vscode.window.activeTextEditor\n@@ -113,28 +110,7 @@ export function activate(context: vscode.ExtensionContext) {\n             return await vscode.tasks.executeTask(task)\n         }\n     })\n-    registerCommand('libsyntax-rust.fsEdit', async (ops: FsOp[]) => {\n-        let edit = new vscode.WorkspaceEdit()\n-        let created;\n-        let moved;\n-        for (let op of ops) {\n-            if (op.type == \"createFile\") {\n-                let uri = vscode.Uri.parse(op.uri!)\n-                edit.createFile(uri)\n-                created = uri\n-            } else if (op.type == \"moveFile\") {\n-                let src = vscode.Uri.parse(op.src!)\n-                let dst = vscode.Uri.parse(op.dst!)\n-                edit.renameFile(src, dst)\n-                moved = dst\n-            } else {\n-                console.error(`unknown op: ${JSON.stringify(op)}`)\n-            }\n-        }\n-        await vscode.workspace.applyEdit(edit)\n-        let doc = await vscode.workspace.openTextDocument((created || moved)!)\n-        await vscode.window.showTextDocument(doc)\n-    })\n+    registerCommand('libsyntax-rust.applySourceChange', applySourceChange)\n \n     dispose(vscode.workspace.registerTextDocumentContentProvider(\n         'libsyntax-rust',\n@@ -207,18 +183,6 @@ function startServer() {\n                 )\n             }\n         )\n-        client.onRequest(\n-            new lc.RequestType<lc.Position, void, any, any>(\"m/moveCursor\"),\n-            (params: lc.Position, token: lc.CancellationToken) => {\n-                let editor = vscode.window.activeTextEditor;\n-                if (!editor) return\n-                if (!editor.selection.isEmpty) return\n-                let position = client.protocol2CodeConverter.asPosition(params)\n-                afterLs(() => {\n-                    editor!.selection = new vscode.Selection(position, position)\n-                })\n-            }\n-        )\n     })\n     client.start();\n }\n@@ -383,9 +347,56 @@ function createTask(spec: Runnable): vscode.Task {\n     return t;\n }\n \n-interface FsOp {\n+interface FileSystemEdit {\n     type: string;\n     uri?: string;\n     src?: string;\n     dst?: string;\n }\n+\n+interface SourceChange {\n+    label: string,\n+    sourceFileEdits: lc.TextDocumentEdit[],\n+    fileSystemEdits: FileSystemEdit[],\n+    cursorPosition?: lc.TextDocumentPositionParams,\n+}\n+\n+async function applySourceChange(change: SourceChange) {\n+    console.log(`applySOurceChange ${JSON.stringify(change)}`)\n+    let wsEdit = new vscode.WorkspaceEdit()\n+    for (let sourceEdit of change.sourceFileEdits) {\n+        let uri = client.protocol2CodeConverter.asUri(sourceEdit.textDocument.uri)\n+        let edits = client.protocol2CodeConverter.asTextEdits(sourceEdit.edits)\n+        wsEdit.set(uri, edits)\n+    }\n+    let created;\n+    let moved;\n+    for (let fsEdit of change.fileSystemEdits) {\n+        if (fsEdit.type == \"createFile\") {\n+            let uri = vscode.Uri.parse(fsEdit.uri!)\n+            wsEdit.createFile(uri)\n+            created = uri\n+        } else if (fsEdit.type == \"moveFile\") {\n+            let src = vscode.Uri.parse(fsEdit.src!)\n+            let dst = vscode.Uri.parse(fsEdit.dst!)\n+            wsEdit.renameFile(src, dst)\n+            moved = dst\n+        } else {\n+            console.error(`unknown op: ${JSON.stringify(fsEdit)}`)\n+        }\n+    }\n+    let toOpen = created || moved\n+    let toReveal = change.cursorPosition\n+    await vscode.workspace.applyEdit(wsEdit)\n+    if (toOpen) {\n+        let doc = await vscode.workspace.openTextDocument(toOpen)\n+        await vscode.window.showTextDocument(doc)\n+    } else if (toReveal) {\n+        let uri = client.protocol2CodeConverter.asUri(toReveal.textDocument.uri)\n+        let position = client.protocol2CodeConverter.asPosition(toReveal.position)\n+        let editor = vscode.window.activeTextEditor;\n+        if (!editor || editor.document.uri != uri) return\n+        if (!editor.selection.isEmpty) return\n+        editor!.selection = new vscode.Selection(position, position)\n+    }\n+}"}, {"sha": "bb4fee398d6cdc7d1d811c1f8b0ec4208195ea69", "filename": "crates/libanalysis/src/api.rs", "status": "added", "additions": 136, "deletions": 0, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/8abf5363433e977c5393bb569e2a5d559cb0a602/crates%2Flibanalysis%2Fsrc%2Fapi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8abf5363433e977c5393bb569e2a5d559cb0a602/crates%2Flibanalysis%2Fsrc%2Fapi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibanalysis%2Fsrc%2Fapi.rs?ref=8abf5363433e977c5393bb569e2a5d559cb0a602", "patch": "@@ -0,0 +1,136 @@\n+use relative_path::RelativePathBuf;\n+use libsyntax2::{File, TextRange, TextUnit, AtomEdit};\n+use libeditor;\n+use {World, FileId, Query};\n+\n+pub use libeditor::{\n+    LocalEdit, StructureNode, LineIndex, FileSymbol,\n+    Runnable, RunnableKind, HighlightedRange, CompletionItem\n+};\n+\n+#[derive(Clone, Debug)]\n+pub struct Analysis {\n+    pub(crate) imp: World\n+}\n+\n+impl Analysis {\n+    pub fn file_syntax(&self, file_id: FileId) -> File {\n+        self.imp.file_syntax(file_id)\n+            .unwrap()\n+    }\n+    pub fn file_line_index(&self, file_id: FileId) -> LineIndex {\n+        self.imp.file_line_index(file_id)\n+            .unwrap()\n+    }\n+    pub fn extend_selection(&self, file: &File, range: TextRange) -> TextRange {\n+        libeditor::extend_selection(file, range).unwrap_or(range)\n+    }\n+    pub fn matching_brace(&self, file: &File, offset: TextUnit) -> Option<TextUnit> {\n+        libeditor::matching_brace(file, offset)\n+    }\n+    pub fn syntax_tree(&self, file_id: FileId) -> String {\n+        let file = self.file_syntax(file_id);\n+        libeditor::syntax_tree(&file)\n+    }\n+    pub fn join_lines(&self, file_id: FileId, range: TextRange) -> SourceChange {\n+        let file = self.file_syntax(file_id);\n+        SourceChange::from_local_edit(\n+            file_id, \"join lines\",\n+            libeditor::join_lines(&file, range),\n+        )\n+    }\n+    pub fn on_eq_typed(&self, file_id: FileId, offset: TextUnit) -> Option<SourceChange> {\n+        let file = self.file_syntax(file_id);\n+        Some(SourceChange::from_local_edit(\n+            file_id, \"add semicolon\",\n+            libeditor::on_eq_typed(&file, offset)?,\n+        ))\n+    }\n+    pub fn file_structure(&self, file_id: FileId) -> Vec<StructureNode> {\n+        let file = self.file_syntax(file_id);\n+        libeditor::file_structure(&file)\n+    }\n+    pub fn symbol_search(&self, query: Query) -> Vec<(FileId, FileSymbol)> {\n+        self.imp.world_symbols(query)\n+    }\n+    pub fn approximately_resolve_symbol(&self, file_id: FileId, offset: TextUnit) -> Vec<(FileId, FileSymbol)> {\n+        self.imp.approximately_resolve_symbol(file_id, offset)\n+            .unwrap()\n+    }\n+    pub fn parent_module(&self, file_id: FileId) -> Vec<(FileId, FileSymbol)> {\n+        self.imp.parent_module(file_id)\n+    }\n+    pub fn runnables(&self, file_id: FileId) -> Vec<Runnable> {\n+        let file = self.file_syntax(file_id);\n+        libeditor::runnables(&file)\n+    }\n+    pub fn highlight(&self, file_id: FileId) -> Vec<HighlightedRange> {\n+        let file = self.file_syntax(file_id);\n+        libeditor::highlight(&file)\n+    }\n+    pub fn completions(&self, file_id: FileId, offset: TextUnit) -> Option<Vec<CompletionItem>> {\n+        let file = self.file_syntax(file_id);\n+        libeditor::scope_completion(&file, offset)\n+    }\n+    pub fn assists(&self, file_id: FileId, offset: TextUnit) -> Vec<SourceChange> {\n+        self.imp.assists(file_id, offset)\n+    }\n+    pub fn diagnostics(&self, file_id: FileId) -> Vec<Diagnostic> {\n+        self.imp.diagnostics(file_id)\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub struct SourceChange {\n+    pub label: String,\n+    pub source_file_edits: Vec<SourceFileEdit>,\n+    pub file_system_edits: Vec<FileSystemEdit>,\n+    pub cursor_position: Option<Position>,\n+}\n+\n+#[derive(Debug)]\n+pub struct Position {\n+    pub file_id: FileId,\n+    pub offset: TextUnit,\n+}\n+\n+#[derive(Debug)]\n+pub struct SourceFileEdit {\n+    pub file_id: FileId,\n+    pub edits: Vec<AtomEdit>,\n+}\n+\n+#[derive(Debug)]\n+pub enum FileSystemEdit {\n+    CreateFile {\n+        anchor: FileId,\n+        path: RelativePathBuf,\n+    },\n+    MoveFile {\n+        file: FileId,\n+        path: RelativePathBuf,\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub struct Diagnostic {\n+    pub message: String,\n+    pub range: TextRange,\n+    pub fix: Option<SourceChange>,\n+}\n+\n+impl SourceChange {\n+    pub(crate) fn from_local_edit(file_id: FileId, label: &str, edit: LocalEdit) -> SourceChange {\n+        let file_edit = SourceFileEdit {\n+            file_id,\n+            edits: edit.edit.into_atoms(),\n+        };\n+        SourceChange {\n+            label: label.to_string(),\n+            source_file_edits: vec![file_edit],\n+            file_system_edits: vec![],\n+            cursor_position: edit.cursor_position\n+                .map(|offset| Position { offset, file_id })\n+        }\n+    }\n+}"}, {"sha": "ec20d106f6d99638bc2420cefff8f7b32ae1f350", "filename": "crates/libanalysis/src/lib.rs", "status": "modified", "additions": 59, "deletions": 32, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/8abf5363433e977c5393bb569e2a5d559cb0a602/crates%2Flibanalysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8abf5363433e977c5393bb569e2a5d559cb0a602/crates%2Flibanalysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibanalysis%2Fsrc%2Flib.rs?ref=8abf5363433e977c5393bb569e2a5d559cb0a602", "patch": "@@ -12,6 +12,7 @@ extern crate relative_path;\n \n mod symbol_index;\n mod module_map;\n+mod api;\n \n use std::{\n     fmt,\n@@ -34,13 +35,14 @@ use libsyntax2::{\n     ast::{self, AstNode, NameOwner},\n     SyntaxKind::*,\n };\n-use libeditor::{Diagnostic, LineIndex, FileSymbol, find_node_at_offset};\n+use libeditor::{LineIndex, FileSymbol, find_node_at_offset};\n \n use self::{\n     symbol_index::FileSymbols,\n     module_map::{ModuleMap, ChangeKind, Problem},\n };\n pub use self::symbol_index::Query;\n+pub use self::api::*;\n \n pub type Result<T> = ::std::result::Result<T, ::failure::Error>;\n \n@@ -97,6 +99,13 @@ impl WorldState {\n         }\n     }\n \n+    pub fn analysis(\n+        &self,\n+        file_resolver: impl FileResolver,\n+    ) -> Analysis {\n+        Analysis { imp: self.snapshot(file_resolver) }\n+    }\n+\n     pub fn change_file(&mut self, file_id: FileId, text: Option<String>) {\n         self.change_files(::std::iter::once((file_id, text)));\n     }\n@@ -231,56 +240,74 @@ impl World {\n         Ok(vec![])\n     }\n \n-    pub fn diagnostics(&self, file_id: FileId) -> Result<Vec<(Diagnostic, Option<QuickFix>)>> {\n-        let syntax = self.file_syntax(file_id)?;\n+    pub fn diagnostics(&self, file_id: FileId) -> Vec<Diagnostic> {\n+        let syntax = self.file_syntax(file_id).unwrap();\n         let mut res = libeditor::diagnostics(&syntax)\n             .into_iter()\n-            .map(|d| (d, None))\n+            .map(|d| Diagnostic { range: d.range, message: d.msg, fix: None })\n             .collect::<Vec<_>>();\n \n         self.data.module_map.problems(\n             file_id,\n             &*self.file_resolver,\n             &|file_id| self.file_syntax(file_id).unwrap(),\n             |name_node, problem| {\n-                let (diag, fix) = match problem {\n+                let diag = match problem {\n                     Problem::UnresolvedModule { candidate } => {\n-                        let diag = Diagnostic {\n-                            range: name_node.syntax().range(),\n-                            msg: \"unresolved module\".to_string(),\n+                        let create_file = FileSystemEdit::CreateFile {\n+                            anchor: file_id,\n+                            path: candidate.clone(),\n                         };\n-                        let fix = QuickFix {\n-                            fs_ops: vec![FsOp::CreateFile {\n-                                anchor: file_id,\n-                                path: candidate.clone(),\n-                            }]\n+                        let fix = SourceChange {\n+                            label: \"create module\".to_string(),\n+                            source_file_edits: Vec::new(),\n+                            file_system_edits: vec![create_file],\n+                            cursor_position: None,\n                         };\n-                        (diag, fix)\n+                        Diagnostic {\n+                            range: name_node.syntax().range(),\n+                            message: \"unresolved module\".to_string(),\n+                            fix: Some(fix),\n+                        }\n                     }\n                     Problem::NotDirOwner { move_to, candidate } => {\n-                        let diag = Diagnostic {\n-                            range: name_node.syntax().range(),\n-                            msg: \"can't declare module at this location\".to_string(),\n+                        let move_file = FileSystemEdit::MoveFile { file: file_id, path: move_to.clone() };\n+                        let create_file = FileSystemEdit::CreateFile { anchor: file_id, path: move_to.join(candidate) };\n+                        let fix = SourceChange {\n+                            label: \"move file and create module\".to_string(),\n+                            source_file_edits: Vec::new(),\n+                            file_system_edits: vec![move_file, create_file],\n+                            cursor_position: None,\n                         };\n-                        let fix = QuickFix {\n-                            fs_ops: vec![\n-                                FsOp::MoveFile {\n-                                    file: file_id,\n-                                    path: move_to.clone(),\n-                                },\n-                                FsOp::CreateFile {\n-                                    anchor: file_id,\n-                                    path: move_to.join(candidate),\n-                                }\n-                            ],\n-                        };\n-                        (diag, fix)\n+                        Diagnostic {\n+                            range: name_node.syntax().range(),\n+                            message: \"can't declare module at this location\".to_string(),\n+                            fix: Some(fix),\n+                        }\n                     }\n                 };\n-                res.push((diag, Some(fix)))\n+                res.push(diag)\n             }\n         );\n-        Ok(res)\n+        res\n+    }\n+\n+    pub fn assists(&self, file_id: FileId, offset: TextUnit) -> Vec<SourceChange> {\n+        let file = self.file_syntax(file_id).unwrap();\n+        let actions = vec![\n+            (\"flip comma\", libeditor::flip_comma(&file, offset).map(|f| f())),\n+            (\"add `#[derive]`\", libeditor::add_derive(&file, offset).map(|f| f())),\n+            (\"add impl\", libeditor::add_impl(&file, offset).map(|f| f())),\n+        ];\n+        let mut res = Vec::new();\n+        for (name, local_edit) in actions {\n+            if let Some(local_edit) = local_edit {\n+                res.push(SourceChange::from_local_edit(\n+                    file_id, name, local_edit\n+                ))\n+            }\n+        }\n+        res\n     }\n \n     fn index_resolve(&self, name_ref: ast::NameRef) -> Vec<(FileId, FileSymbol)> {"}, {"sha": "dadbd63ab968b57690f4a9ded92ea9c3edb5d808", "filename": "crates/libeditor/src/code_actions.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8abf5363433e977c5393bb569e2a5d559cb0a602/crates%2Flibeditor%2Fsrc%2Fcode_actions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8abf5363433e977c5393bb569e2a5d559cb0a602/crates%2Flibeditor%2Fsrc%2Fcode_actions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibeditor%2Fsrc%2Fcode_actions.rs?ref=8abf5363433e977c5393bb569e2a5d559cb0a602", "patch": "@@ -13,13 +13,14 @@ use libsyntax2::{\n \n use {EditBuilder, Edit, find_node_at_offset};\n \n+// TODO: rename to FileEdit\n #[derive(Debug)]\n-pub struct ActionResult {\n+pub struct LocalEdit {\n     pub edit: Edit,\n     pub cursor_position: Option<TextUnit>,\n }\n \n-pub fn flip_comma<'a>(file: &'a File, offset: TextUnit) -> Option<impl FnOnce() -> ActionResult + 'a> {\n+pub fn flip_comma<'a>(file: &'a File, offset: TextUnit) -> Option<impl FnOnce() -> LocalEdit + 'a> {\n     let syntax = file.syntax();\n \n     let comma = find_leaf_at_offset(syntax, offset).find(|leaf| leaf.kind() == COMMA)?;\n@@ -29,14 +30,14 @@ pub fn flip_comma<'a>(file: &'a File, offset: TextUnit) -> Option<impl FnOnce()\n         let mut edit = EditBuilder::new();\n         edit.replace(left.range(), right.text().to_string());\n         edit.replace(right.range(), left.text().to_string());\n-        ActionResult {\n+        LocalEdit {\n             edit: edit.finish(),\n             cursor_position: None,\n         }\n     })\n }\n \n-pub fn add_derive<'a>(file: &'a File, offset: TextUnit) -> Option<impl FnOnce() -> ActionResult + 'a> {\n+pub fn add_derive<'a>(file: &'a File, offset: TextUnit) -> Option<impl FnOnce() -> LocalEdit + 'a> {\n     let nominal = find_node_at_offset::<ast::NominalDef>(file.syntax(), offset)?;\n     Some(move || {\n         let derive_attr = nominal\n@@ -56,14 +57,14 @@ pub fn add_derive<'a>(file: &'a File, offset: TextUnit) -> Option<impl FnOnce()\n                 tt.syntax().range().end() - TextUnit::of_char(')')\n             }\n         };\n-        ActionResult {\n+        LocalEdit {\n             edit: edit.finish(),\n             cursor_position: Some(offset),\n         }\n     })\n }\n \n-pub fn add_impl<'a>(file: &'a File, offset: TextUnit) -> Option<impl FnOnce() -> ActionResult + 'a> {\n+pub fn add_impl<'a>(file: &'a File, offset: TextUnit) -> Option<impl FnOnce() -> LocalEdit + 'a> {\n     let nominal = find_node_at_offset::<ast::NominalDef>(file.syntax(), offset)?;\n     let name = nominal.name()?;\n \n@@ -90,7 +91,7 @@ pub fn add_impl<'a>(file: &'a File, offset: TextUnit) -> Option<impl FnOnce() ->\n         let offset = start_offset + TextUnit::of_str(&buf);\n         buf.push_str(\"\\n}\");\n         edit.insert(start_offset, buf);\n-        ActionResult {\n+        LocalEdit {\n             edit: edit.finish(),\n             cursor_position: Some(offset),\n         }"}, {"sha": "d95c407738358a087b6f8b6e53a912b089bdee90", "filename": "crates/libeditor/src/completion.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8abf5363433e977c5393bb569e2a5d559cb0a602/crates%2Flibeditor%2Fsrc%2Fcompletion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8abf5363433e977c5393bb569e2a5d559cb0a602/crates%2Flibeditor%2Fsrc%2Fcompletion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibeditor%2Fsrc%2Fcompletion.rs?ref=8abf5363433e977c5393bb569e2a5d559cb0a602", "patch": "@@ -12,8 +12,7 @@ use {\n };\n \n #[derive(Debug)]\n-pub struct\n-       CompletionItem {\n+pub struct CompletionItem {\n     pub name: String,\n     pub snippet: Option<String>\n }"}, {"sha": "4700ef32886e5bd38b9019ca46677b2e1baebf5e", "filename": "crates/libeditor/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8abf5363433e977c5393bb569e2a5d559cb0a602/crates%2Flibeditor%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8abf5363433e977c5393bb569e2a5d559cb0a602/crates%2Flibeditor%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibeditor%2Fsrc%2Flib.rs?ref=8abf5363433e977c5393bb569e2a5d559cb0a602", "patch": "@@ -30,11 +30,11 @@ pub use self::{\n     symbols::{StructureNode, file_structure, FileSymbol, file_symbols},\n     edit::{EditBuilder, Edit},\n     code_actions::{\n-        ActionResult,\n+        LocalEdit,\n         flip_comma, add_derive, add_impl,\n     },\n     typing::{join_lines, on_eq_typed},\n-    completion::scope_completion,\n+    completion::{scope_completion, CompletionItem},\n };\n \n #[derive(Debug)]"}, {"sha": "037319cd0047c1cceed6378723547de1e5ea4941", "filename": "crates/libeditor/src/test_utils.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8abf5363433e977c5393bb569e2a5d559cb0a602/crates%2Flibeditor%2Fsrc%2Ftest_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8abf5363433e977c5393bb569e2a5d559cb0a602/crates%2Flibeditor%2Fsrc%2Ftest_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibeditor%2Fsrc%2Ftest_utils.rs?ref=8abf5363433e977c5393bb569e2a5d559cb0a602", "patch": "@@ -1,8 +1,8 @@\n use libsyntax2::{File, TextUnit};\n pub use _test_utils::*;\n-use ActionResult;\n+use LocalEdit;\n \n-pub fn check_action<F: Fn(&File, TextUnit) -> Option<ActionResult>> (\n+pub fn check_action<F: Fn(&File, TextUnit) -> Option<LocalEdit>> (\n     before: &str,\n     after: &str,\n     f: F,"}, {"sha": "f888f3240a76396687c817d6491fd1ce3f5b9174", "filename": "crates/libeditor/src/typing.rs", "status": "modified", "additions": 41, "deletions": 7, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/8abf5363433e977c5393bb569e2a5d559cb0a602/crates%2Flibeditor%2Fsrc%2Ftyping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8abf5363433e977c5393bb569e2a5d559cb0a602/crates%2Flibeditor%2Fsrc%2Ftyping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibeditor%2Fsrc%2Ftyping.rs?ref=8abf5363433e977c5393bb569e2a5d559cb0a602", "patch": "@@ -11,14 +11,14 @@ use libsyntax2::{\n     SyntaxKind::*,\n };\n \n-use {ActionResult, EditBuilder, find_node_at_offset};\n+use {LocalEdit, EditBuilder, find_node_at_offset};\n \n-pub fn join_lines(file: &File, range: TextRange) -> ActionResult {\n+pub fn join_lines(file: &File, range: TextRange) -> LocalEdit {\n     let range = if range.is_empty() {\n         let syntax = file.syntax();\n         let text = syntax.text().slice(range.start()..);\n         let pos = match text.find('\\n') {\n-            None => return ActionResult {\n+            None => return LocalEdit {\n                 edit: EditBuilder::new().finish(),\n                 cursor_position: None\n             },\n@@ -50,13 +50,13 @@ pub fn join_lines(file: &File, range: TextRange) -> ActionResult {\n     }\n     eprintln!(\"{:?}\", edit);\n \n-    ActionResult {\n+    LocalEdit {\n         edit: edit.finish(),\n         cursor_position: None,\n     }\n }\n \n-pub fn on_eq_typed(file: &File, offset: TextUnit) -> Option<ActionResult> {\n+pub fn on_eq_typed(file: &File, offset: TextUnit) -> Option<LocalEdit> {\n     let let_stmt: ast::LetStmt = find_node_at_offset(file.syntax(), offset)?;\n     if let_stmt.has_semi() {\n         return None;\n@@ -75,7 +75,7 @@ pub fn on_eq_typed(file: &File, offset: TextUnit) -> Option<ActionResult> {\n     let offset = let_stmt.syntax().range().end();\n     let mut edit = EditBuilder::new();\n     edit.insert(offset, \";\".to_string());\n-    Some(ActionResult {\n+    Some(LocalEdit {\n         edit: edit.finish(),\n         cursor_position: None,\n     })\n@@ -277,7 +277,41 @@ fn foo() {\n }\", r\"\n fn foo() {\n     join(type_params.type_params().filter_map(|it| it.name()).map(|it| it.text()))\n-}\")\n+}\");\n+\n+        do_check(r\"\n+pub fn handle_find_matching_brace(\n+    world: ServerWorld,\n+    params: req::FindMatchingBraceParams,\n+) -> Result<Vec<Position>> {\n+    let file_id = params.text_document.try_conv_with(&world)?;\n+    let file = world.analysis().file_syntax(file_id);\n+    let line_index = world.analysis().file_line_index(file_id);\n+    let res = params.offsets\n+        .into_iter()\n+        .map_conv_with(&line_index)\n+        .map(|offset| <|>{\n+            world.analysis().matching_brace(&file, offset).unwrap_or(offset)\n+        }<|>)\n+        .map_conv_with(&line_index)\n+        .collect();\n+    Ok(res)\n+}\", r\"\n+pub fn handle_find_matching_brace(\n+    world: ServerWorld,\n+    params: req::FindMatchingBraceParams,\n+) -> Result<Vec<Position>> {\n+    let file_id = params.text_document.try_conv_with(&world)?;\n+    let file = world.analysis().file_syntax(file_id);\n+    let line_index = world.analysis().file_line_index(file_id);\n+    let res = params.offsets\n+        .into_iter()\n+        .map_conv_with(&line_index)\n+        .map(|offset| world.analysis().matching_brace(&file, offset).unwrap_or(offset))\n+        .map_conv_with(&line_index)\n+        .collect();\n+    Ok(res)\n+}\");\n     }\n \n     #[test]"}, {"sha": "a59308c3fbb65d2e268c3f929251022fb69fa439", "filename": "crates/server/src/conv.rs", "status": "modified", "additions": 79, "deletions": 1, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/8abf5363433e977c5393bb569e2a5d559cb0a602/crates%2Fserver%2Fsrc%2Fconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8abf5363433e977c5393bb569e2a5d559cb0a602/crates%2Fserver%2Fsrc%2Fconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fserver%2Fsrc%2Fconv.rs?ref=8abf5363433e977c5393bb569e2a5d559cb0a602", "patch": "@@ -1,14 +1,16 @@\n use languageserver_types::{\n     Range, SymbolKind, Position, TextEdit, Location, Url,\n     TextDocumentIdentifier, VersionedTextDocumentIdentifier, TextDocumentItem,\n+    TextDocumentPositionParams, TextDocumentEdit,\n };\n use libeditor::{LineIndex, LineCol, Edit, AtomEdit};\n use libsyntax2::{SyntaxKind, TextUnit, TextRange};\n-use libanalysis::FileId;\n+use libanalysis::{FileId, SourceChange, SourceFileEdit, FileSystemEdit};\n \n use {\n     Result,\n     server_world::ServerWorld,\n+    req,\n };\n \n pub trait Conv {\n@@ -168,6 +170,82 @@ impl<'a> TryConvWith for &'a TextDocumentIdentifier {\n     }\n }\n \n+impl<T: TryConvWith> TryConvWith for Vec<T> {\n+    type Ctx = <T as TryConvWith>::Ctx;\n+    type Output = Vec<<T as TryConvWith>::Output>;\n+    fn try_conv_with(self, ctx: &Self::Ctx) -> Result<Self::Output> {\n+        let mut res = Vec::with_capacity(self.len());\n+        for item in self {\n+            res.push(item.try_conv_with(ctx)?);\n+        }\n+        Ok(res)\n+    }\n+}\n+\n+impl TryConvWith for SourceChange {\n+    type Ctx = ServerWorld;\n+    type Output = req::SourceChange;\n+    fn try_conv_with(self, world: &ServerWorld) -> Result<req::SourceChange> {\n+        let cursor_position = match self.cursor_position {\n+            None => None,\n+            Some(pos) => {\n+                let line_index = world.analysis().file_line_index(pos.file_id);\n+                Some(TextDocumentPositionParams {\n+                    text_document: TextDocumentIdentifier::new(pos.file_id.try_conv_with(world)?),\n+                    position: pos.offset.conv_with(&line_index),\n+                })\n+            }\n+        };\n+        let source_file_edits = self.source_file_edits.try_conv_with(world)?;\n+        let file_system_edits = self.file_system_edits.try_conv_with(world)?;\n+        Ok(req::SourceChange {\n+            label: self.label,\n+            source_file_edits,\n+            file_system_edits,\n+            cursor_position,\n+        })\n+    }\n+}\n+\n+impl TryConvWith for SourceFileEdit {\n+    type Ctx = ServerWorld;\n+    type Output = TextDocumentEdit;\n+    fn try_conv_with(self, world: &ServerWorld) -> Result<TextDocumentEdit> {\n+        let text_document = VersionedTextDocumentIdentifier {\n+            uri: self.file_id.try_conv_with(world)?,\n+            version: None,\n+        };\n+        let line_index = world.analysis().file_line_index(self.file_id);\n+        let edits = self.edits\n+            .into_iter()\n+            .map_conv_with(&line_index)\n+            .collect();\n+        Ok(TextDocumentEdit { text_document, edits })\n+    }\n+}\n+\n+impl TryConvWith for FileSystemEdit {\n+    type Ctx = ServerWorld;\n+    type Output = req::FileSystemEdit;\n+    fn try_conv_with(self, world: &ServerWorld) -> Result<req::FileSystemEdit> {\n+        let res = match self {\n+            FileSystemEdit::CreateFile { anchor, path } => {\n+                let uri = world.file_id_to_uri(anchor)?;\n+                let path = &path.as_str()[3..]; // strip `../` b/c url is weird\n+                let uri = uri.join(path)?;\n+                req::FileSystemEdit::CreateFile { uri }\n+            },\n+            FileSystemEdit::MoveFile { file, path } => {\n+                let src = world.file_id_to_uri(file)?;\n+                let path = &path.as_str()[3..]; // strip `../` b/c url is weird\n+                let dst = src.join(path)?;\n+                req::FileSystemEdit::MoveFile { src, dst }\n+            },\n+        };\n+        Ok(res)\n+    }\n+}\n+\n pub fn to_location(\n     file_id: FileId,\n     range: TextRange,"}, {"sha": "6af8bf81b2561968bdb4debff4372544539e7b49", "filename": "crates/server/src/main.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8abf5363433e977c5393bb569e2a5d559cb0a602/crates%2Fserver%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8abf5363433e977c5393bb569e2a5d559cb0a602/crates%2Fserver%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fserver%2Fsrc%2Fmain.rs?ref=8abf5363433e977c5393bb569e2a5d559cb0a602", "patch": "@@ -35,7 +35,7 @@ use crossbeam_channel::bounded;\n use flexi_logger::{Logger, Duplicate};\n \n use ::{\n-    io::{Io, RawMsg, RawResponse, RawRequest, RawNotification},\n+    io::{Io, RawMsg, RawResponse, RawNotification},\n };\n \n pub type Result<T> = ::std::result::Result<T, ::failure::Error>;\n@@ -109,7 +109,6 @@ fn initialize(io: &mut Io) -> Result<()> {\n \n enum Task {\n     Respond(RawResponse),\n-    Request(RawRequest),\n     Notify(RawNotification),\n     Die(::failure::Error),\n }"}, {"sha": "45083b084ebb98a4d12c7100468c8fafa4682225", "filename": "crates/server/src/main_loop/handlers.rs", "status": "modified", "additions": 131, "deletions": 253, "changes": 384, "blob_url": "https://github.com/rust-lang/rust/blob/8abf5363433e977c5393bb569e2a5d559cb0a602/crates%2Fserver%2Fsrc%2Fmain_loop%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8abf5363433e977c5393bb569e2a5d559cb0a602/crates%2Fserver%2Fsrc%2Fmain_loop%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fserver%2Fsrc%2Fmain_loop%2Fhandlers.rs?ref=8abf5363433e977c5393bb569e2a5d559cb0a602", "patch": "@@ -2,16 +2,13 @@ use std::collections::HashMap;\n \n use languageserver_types::{\n     Diagnostic, DiagnosticSeverity, Url, DocumentSymbol,\n-    Command, TextDocumentIdentifier, WorkspaceEdit,\n+    Command, TextDocumentIdentifier,\n     SymbolInformation, Position, Location, TextEdit,\n     CompletionItem, InsertTextFormat, CompletionItemKind,\n };\n-use serde_json::{to_value, from_value};\n-use url_serde;\n-use libanalysis::{self, Query, FileId};\n-use libeditor;\n+use serde_json::to_value;\n+use libanalysis::{Query, FileId, RunnableKind};\n use libsyntax2::{\n-    TextUnit,\n     text_utils::contains_offset_nonstrict,\n };\n \n@@ -26,20 +23,20 @@ pub fn handle_syntax_tree(\n     params: req::SyntaxTreeParams,\n ) -> Result<String> {\n     let id = params.text_document.try_conv_with(&world)?;\n-    let file = world.analysis().file_syntax(id)?;\n-    Ok(libeditor::syntax_tree(&file))\n+    let res = world.analysis().syntax_tree(id);\n+    Ok(res)\n }\n \n pub fn handle_extend_selection(\n     world: ServerWorld,\n     params: req::ExtendSelectionParams,\n ) -> Result<req::ExtendSelectionResult> {\n     let file_id = params.text_document.try_conv_with(&world)?;\n-    let file = world.analysis().file_syntax(file_id)?;\n-    let line_index = world.analysis().file_line_index(file_id)?;\n+    let file = world.analysis().file_syntax(file_id);\n+    let line_index = world.analysis().file_line_index(file_id);\n     let selections = params.selections.into_iter()\n         .map_conv_with(&line_index)\n-        .map(|r| libeditor::extend_selection(&file, r).unwrap_or(r))\n+        .map(|r| world.analysis().extend_selection(&file, r))\n         .map_conv_with(&line_index)\n         .collect();\n     Ok(req::ExtendSelectionResult { selections })\n@@ -50,13 +47,13 @@ pub fn handle_find_matching_brace(\n     params: req::FindMatchingBraceParams,\n ) -> Result<Vec<Position>> {\n     let file_id = params.text_document.try_conv_with(&world)?;\n-    let file = world.analysis().file_syntax(file_id)?;\n-    let line_index = world.analysis().file_line_index(file_id)?;\n+    let file = world.analysis().file_syntax(file_id);\n+    let line_index = world.analysis().file_line_index(file_id);\n     let res = params.offsets\n         .into_iter()\n         .map_conv_with(&line_index)\n         .map(|offset| {\n-            libeditor::matching_brace(&file, offset).unwrap_or(offset)\n+            world.analysis().matching_brace(&file, offset).unwrap_or(offset)\n         })\n         .map_conv_with(&line_index)\n         .collect();\n@@ -66,26 +63,43 @@ pub fn handle_find_matching_brace(\n pub fn handle_join_lines(\n     world: ServerWorld,\n     params: req::JoinLinesParams,\n-) -> Result<Vec<TextEdit>> {\n+) -> Result<req::SourceChange> {\n     let file_id = params.text_document.try_conv_with(&world)?;\n-    let file = world.analysis().file_syntax(file_id)?;\n-    let line_index = world.analysis().file_line_index(file_id)?;\n+    let line_index = world.analysis().file_line_index(file_id);\n     let range = params.range.conv_with(&line_index);\n-    let res = libeditor::join_lines(&file, range);\n-    Ok(res.edit.conv_with(&line_index))\n+    world.analysis().join_lines(file_id, range)\n+        .try_conv_with(&world)\n+}\n+\n+pub fn handle_on_type_formatting(\n+    world: ServerWorld,\n+    params: req::DocumentOnTypeFormattingParams,\n+) -> Result<Option<Vec<TextEdit>>> {\n+    if params.ch != \"=\" {\n+        return Ok(None);\n+    }\n+\n+    let file_id = params.text_document.try_conv_with(&world)?;\n+    let line_index = world.analysis().file_line_index(file_id);\n+    let offset = params.position.conv_with(&line_index);\n+    let edits = match world.analysis().on_eq_typed(file_id, offset) {\n+        None => return Ok(None),\n+        Some(mut action) => action.source_file_edits.pop().unwrap().edits,\n+    };\n+    let edits = edits.into_iter().map_conv_with(&line_index).collect();\n+    Ok(Some(edits))\n }\n \n pub fn handle_document_symbol(\n     world: ServerWorld,\n     params: req::DocumentSymbolParams,\n ) -> Result<Option<req::DocumentSymbolResponse>> {\n     let file_id = params.text_document.try_conv_with(&world)?;\n-    let file = world.analysis().file_syntax(file_id)?;\n-    let line_index = world.analysis().file_line_index(file_id)?;\n+    let line_index = world.analysis().file_line_index(file_id);\n \n     let mut parents: Vec<(DocumentSymbol, Option<usize>)> = Vec::new();\n \n-    for symbol in libeditor::file_structure(&file) {\n+    for symbol in world.analysis().file_structure(file_id) {\n         let doc_symbol = DocumentSymbol {\n             name: symbol.label,\n             detail: Some(\"\".to_string()),\n@@ -114,130 +128,6 @@ pub fn handle_document_symbol(\n     Ok(Some(req::DocumentSymbolResponse::Nested(res)))\n }\n \n-pub fn handle_code_action(\n-    world: ServerWorld,\n-    params: req::CodeActionParams,\n-) -> Result<Option<Vec<Command>>> {\n-    let file_id = params.text_document.try_conv_with(&world)?;\n-    let file = world.analysis().file_syntax(file_id)?;\n-    let line_index = world.analysis().file_line_index(file_id)?;\n-    let offset = params.range.conv_with(&line_index).start();\n-    let mut res = Vec::new();\n-\n-    let actions = &[\n-        (ActionId::FlipComma, libeditor::flip_comma(&file, offset).is_some()),\n-        (ActionId::AddDerive, libeditor::add_derive(&file, offset).is_some()),\n-        (ActionId::AddImpl, libeditor::add_impl(&file, offset).is_some()),\n-    ];\n-\n-    for (id, edit) in actions {\n-        if *edit {\n-            let cmd = apply_code_action_cmd(*id, params.text_document.clone(), offset);\n-            res.push(cmd);\n-        }\n-    }\n-\n-    for (diag, quick_fix) in world.analysis().diagnostics(file_id)? {\n-        let quick_fix = match quick_fix {\n-            Some(quick_fix) => quick_fix,\n-            None => continue,\n-        };\n-        if !contains_offset_nonstrict(diag.range, offset) {\n-            continue;\n-        }\n-        let mut ops = Vec::new();\n-        for op in quick_fix.fs_ops {\n-            let op = match op {\n-                libanalysis::FsOp::CreateFile { anchor, path } => {\n-                    let uri = world.file_id_to_uri(anchor)?;\n-                    let path = &path.as_str()[3..]; // strip `../` b/c url is weird\n-                    let uri = uri.join(path)?;\n-                    FsOp::CreateFile { uri }\n-                },\n-                libanalysis::FsOp::MoveFile { file, path } => {\n-                    let src = world.file_id_to_uri(file)?;\n-                    let path = &path.as_str()[3..]; // strip `../` b/c url is weird\n-                    let dst = src.join(path)?;\n-                    FsOp::MoveFile { src, dst }\n-                },\n-            };\n-            ops.push(op)\n-        }\n-        let cmd = Command {\n-            title: \"Create module\".to_string(),\n-            command: \"libsyntax-rust.fsEdit\".to_string(),\n-            arguments: Some(vec![to_value(ops).unwrap()]),\n-        };\n-        res.push(cmd)\n-    }\n-    return Ok(Some(res));\n-}\n-\n-#[derive(Serialize)]\n-#[serde(tag = \"type\", rename_all = \"camelCase\")]\n-enum FsOp {\n-    CreateFile {\n-        #[serde(with = \"url_serde\")]\n-        uri: Url\n-    },\n-    MoveFile {\n-        #[serde(with = \"url_serde\")]\n-        src: Url,\n-        #[serde(with = \"url_serde\")]\n-        dst: Url,\n-    }\n-}\n-\n-pub fn handle_runnables(\n-    world: ServerWorld,\n-    params: req::RunnablesParams,\n-) -> Result<Vec<req::Runnable>> {\n-    let file_id = params.text_document.try_conv_with(&world)?;\n-    let file = world.analysis().file_syntax(file_id)?;\n-    let line_index = world.analysis().file_line_index(file_id)?;\n-    let offset = params.position.map(|it| it.conv_with(&line_index));\n-    let mut res = Vec::new();\n-    for runnable in libeditor::runnables(&file) {\n-        if let Some(offset) = offset {\n-            if !contains_offset_nonstrict(runnable.range, offset) {\n-                continue;\n-            }\n-        }\n-\n-        let r = req::Runnable {\n-            range: runnable.range.conv_with(&line_index),\n-            label: match &runnable.kind {\n-                libeditor::RunnableKind::Test { name } =>\n-                    format!(\"test {}\", name),\n-                libeditor::RunnableKind::Bin =>\n-                    \"run binary\".to_string(),\n-            },\n-            bin: \"cargo\".to_string(),\n-            args: match runnable.kind {\n-                libeditor::RunnableKind::Test { name } => {\n-                    vec![\n-                        \"test\".to_string(),\n-                        \"--\".to_string(),\n-                        name,\n-                        \"--nocapture\".to_string(),\n-                    ]\n-                }\n-                libeditor::RunnableKind::Bin => vec![\"run\".to_string()]\n-            },\n-            env: {\n-                let mut m = HashMap::new();\n-                m.insert(\n-                    \"RUST_BACKTRACE\".to_string(),\n-                    \"short\".to_string(),\n-                );\n-                m\n-            }\n-        };\n-        res.push(r);\n-    }\n-    return Ok(res);\n-}\n-\n pub fn handle_workspace_symbol(\n     world: ServerWorld,\n     params: req::WorkspaceSymbolParams,\n@@ -265,8 +155,8 @@ pub fn handle_workspace_symbol(\n \n     fn exec_query(world: &ServerWorld, query: Query) -> Result<Vec<SymbolInformation>> {\n         let mut res = Vec::new();\n-        for (file_id, symbol) in world.analysis().world_symbols(query) {\n-            let line_index = world.analysis().file_line_index(file_id)?;\n+        for (file_id, symbol) in world.analysis().symbol_search(query) {\n+            let line_index = world.analysis().file_line_index(file_id);\n             let info = SymbolInformation {\n                 name: symbol.name.to_string(),\n                 kind: symbol.kind.conv(),\n@@ -287,11 +177,11 @@ pub fn handle_goto_definition(\n     params: req::TextDocumentPositionParams,\n ) -> Result<Option<req::GotoDefinitionResponse>> {\n     let file_id = params.text_document.try_conv_with(&world)?;\n-    let line_index = world.analysis().file_line_index(file_id)?;\n+    let line_index = world.analysis().file_line_index(file_id);\n     let offset = params.position.conv_with(&line_index);\n     let mut res = Vec::new();\n-    for (file_id, symbol) in world.analysis().approximately_resolve_symbol(file_id, offset)? {\n-        let line_index = world.analysis().file_line_index(file_id)?;\n+    for (file_id, symbol) in world.analysis().approximately_resolve_symbol(file_id, offset) {\n+        let line_index = world.analysis().file_line_index(file_id);\n         let location = to_location(\n             file_id, symbol.node_range,\n             &world, &line_index,\n@@ -308,7 +198,7 @@ pub fn handle_parent_module(\n     let file_id = params.try_conv_with(&world)?;\n     let mut res = Vec::new();\n     for (file_id, symbol) in world.analysis().parent_module(file_id) {\n-        let line_index = world.analysis().file_line_index(file_id)?;\n+        let line_index = world.analysis().file_line_index(file_id);\n         let location = to_location(\n             file_id, symbol.node_range,\n             &world, &line_index\n@@ -318,15 +208,71 @@ pub fn handle_parent_module(\n     Ok(res)\n }\n \n+pub fn handle_runnables(\n+    world: ServerWorld,\n+    params: req::RunnablesParams,\n+) -> Result<Vec<req::Runnable>> {\n+    let file_id = params.text_document.try_conv_with(&world)?;\n+    let line_index = world.analysis().file_line_index(file_id);\n+    let offset = params.position.map(|it| it.conv_with(&line_index));\n+    let mut res = Vec::new();\n+    for runnable in world.analysis().runnables(file_id) {\n+        if let Some(offset) = offset {\n+            if !contains_offset_nonstrict(runnable.range, offset) {\n+                continue;\n+            }\n+        }\n+\n+        let r = req::Runnable {\n+            range: runnable.range.conv_with(&line_index),\n+            label: match &runnable.kind {\n+                RunnableKind::Test { name } =>\n+                    format!(\"test {}\", name),\n+                RunnableKind::Bin =>\n+                    \"run binary\".to_string(),\n+            },\n+            bin: \"cargo\".to_string(),\n+            args: match runnable.kind {\n+                RunnableKind::Test { name } => {\n+                    vec![\n+                        \"test\".to_string(),\n+                        \"--\".to_string(),\n+                        name,\n+                        \"--nocapture\".to_string(),\n+                    ]\n+                }\n+                RunnableKind::Bin => vec![\"run\".to_string()]\n+            },\n+            env: {\n+                let mut m = HashMap::new();\n+                m.insert(\n+                    \"RUST_BACKTRACE\".to_string(),\n+                    \"short\".to_string(),\n+                );\n+                m\n+            }\n+        };\n+        res.push(r);\n+    }\n+    return Ok(res);\n+}\n+\n+pub fn handle_decorations(\n+    world: ServerWorld,\n+    params: TextDocumentIdentifier,\n+) -> Result<Vec<Decoration>> {\n+    let file_id = params.try_conv_with(&world)?;\n+    Ok(highlight(&world, file_id))\n+}\n+\n pub fn handle_completion(\n     world: ServerWorld,\n     params: req::CompletionParams,\n ) -> Result<Option<req::CompletionResponse>> {\n     let file_id = params.text_document.try_conv_with(&world)?;\n-    let file = world.analysis().file_syntax(file_id)?;\n-    let line_index = world.analysis().file_line_index(file_id)?;\n+    let line_index = world.analysis().file_line_index(file_id);\n     let offset = params.position.conv_with(&line_index);\n-    let items = match libeditor::scope_completion(&file, offset) {\n+    let items = match world.analysis().completions(file_id, offset) {\n         None => return Ok(None),\n         Some(items) => items,\n     };\n@@ -348,139 +294,71 @@ pub fn handle_completion(\n     Ok(Some(req::CompletionResponse::Array(items)))\n }\n \n-pub fn handle_on_type_formatting(\n+pub fn handle_code_action(\n     world: ServerWorld,\n-    params: req::DocumentOnTypeFormattingParams,\n-) -> Result<Option<Vec<TextEdit>>> {\n-    if params.ch != \"=\" {\n-        return Ok(None);\n-    }\n-\n+    params: req::CodeActionParams,\n+) -> Result<Option<Vec<Command>>> {\n     let file_id = params.text_document.try_conv_with(&world)?;\n-    let line_index = world.analysis().file_line_index(file_id)?;\n-    let offset = params.position.conv_with(&line_index);\n-    let file = world.analysis().file_syntax(file_id)?;\n-    let action = match libeditor::on_eq_typed(&file, offset) {\n-        None => return Ok(None),\n-        Some(action) => action,\n-    };\n-    Ok(Some(action.edit.conv_with(&line_index)))\n-}\n-\n-pub fn handle_execute_command(\n-    world: ServerWorld,\n-    mut params: req::ExecuteCommandParams,\n-) -> Result<(req::ApplyWorkspaceEditParams, Option<Position>)> {\n-    if params.command.as_str() != \"apply_code_action\" {\n-        bail!(\"unknown cmd: {:?}\", params.command);\n-    }\n-    if params.arguments.len() != 1 {\n-        bail!(\"expected single arg, got {}\", params.arguments.len());\n-    }\n-    let arg = params.arguments.pop().unwrap();\n-    let arg: ActionRequest = from_value(arg)?;\n-    let file_id = arg.text_document.try_conv_with(&world)?;\n-    let file = world.analysis().file_syntax(file_id)?;\n-    let action_result = match arg.id {\n-        ActionId::FlipComma => libeditor::flip_comma(&file, arg.offset).map(|f| f()),\n-        ActionId::AddDerive => libeditor::add_derive(&file, arg.offset).map(|f| f()),\n-        ActionId::AddImpl => libeditor::add_impl(&file, arg.offset).map(|f| f()),\n-    }.ok_or_else(|| format_err!(\"command not applicable\"))?;\n-    let line_index = world.analysis().file_line_index(file_id)?;\n-    let mut changes = HashMap::new();\n-    changes.insert(\n-        arg.text_document.uri,\n-        action_result.edit.conv_with(&line_index),\n-    );\n-    let edit = WorkspaceEdit {\n-        changes: Some(changes),\n-        document_changes: None,\n-    };\n-    let edit = req::ApplyWorkspaceEditParams { edit };\n-    let cursor_pos = action_result.cursor_position\n-        .map(|off| off.conv_with(&line_index));\n-    Ok((edit, cursor_pos))\n-}\n+    let line_index = world.analysis().file_line_index(file_id);\n+    let offset = params.range.conv_with(&line_index).start();\n \n-#[derive(Serialize, Deserialize)]\n-struct ActionRequest {\n-    id: ActionId,\n-    text_document: TextDocumentIdentifier,\n-    offset: TextUnit,\n-}\n+    let assists = world.analysis().assists(file_id, offset).into_iter();\n+    let fixes = world.analysis().diagnostics(file_id).into_iter()\n+        .filter_map(|d| Some((d.range, d.fix?)))\n+        .filter(|(range, _fix)| contains_offset_nonstrict(*range, offset))\n+        .map(|(_range, fix)| fix);\n \n-fn apply_code_action_cmd(id: ActionId, doc: TextDocumentIdentifier, offset: TextUnit) -> Command {\n-    let action_request = ActionRequest { id, text_document: doc, offset };\n-    Command {\n-        title: id.title().to_string(),\n-        command: \"apply_code_action\".to_string(),\n-        arguments: Some(vec![to_value(action_request).unwrap()]),\n+    let mut res = Vec::new();\n+    for source_edit in assists.chain(fixes) {\n+        let title = source_edit.label.clone();\n+        let edit = source_edit.try_conv_with(&world)?;\n+        let cmd = Command {\n+            title,\n+            command: \"libsyntax-rust.applySourceChange\".to_string(),\n+            arguments: Some(vec![to_value(edit).unwrap()]),\n+        };\n+        res.push(cmd);\n     }\n-}\n \n-#[derive(Serialize, Deserialize, Clone, Copy)]\n-enum ActionId {\n-    FlipComma,\n-    AddDerive,\n-    AddImpl,\n-}\n-\n-impl ActionId {\n-    fn title(&self) -> &'static str {\n-        match *self {\n-            ActionId::FlipComma => \"Flip `,`\",\n-            ActionId::AddDerive => \"Add `#[derive]`\",\n-            ActionId::AddImpl => \"Add impl\",\n-        }\n-    }\n+    Ok(Some(res))\n }\n \n pub fn publish_diagnostics(\n     world: ServerWorld,\n     uri: Url\n ) -> Result<req::PublishDiagnosticsParams> {\n     let file_id = world.uri_to_file_id(&uri)?;\n-    let line_index = world.analysis().file_line_index(file_id)?;\n-    let diagnostics = world.analysis().diagnostics(file_id)?\n+    let line_index = world.analysis().file_line_index(file_id);\n+    let diagnostics = world.analysis().diagnostics(file_id)\n         .into_iter()\n-        .map(|(d, _quick_fix)| Diagnostic {\n+        .map(|d| Diagnostic {\n             range: d.range.conv_with(&line_index),\n             severity: Some(DiagnosticSeverity::Error),\n             code: None,\n             source: Some(\"libsyntax2\".to_string()),\n-            message: d.msg,\n+            message: d.message,\n             related_information: None,\n         }).collect();\n     Ok(req::PublishDiagnosticsParams { uri, diagnostics })\n }\n \n-pub fn handle_decorations(\n-    world: ServerWorld,\n-    params: TextDocumentIdentifier,\n-) -> Result<Vec<Decoration>> {\n-    let file_id = params.try_conv_with(&world)?;\n-    highlight(&world, file_id)\n-}\n-\n pub fn publish_decorations(\n     world: ServerWorld,\n     uri: Url\n ) -> Result<req::PublishDecorationsParams> {\n     let file_id = world.uri_to_file_id(&uri)?;\n     Ok(req::PublishDecorationsParams {\n         uri,\n-        decorations: highlight(&world, file_id)?\n+        decorations: highlight(&world, file_id),\n     })\n }\n \n-fn highlight(world: &ServerWorld, file_id: FileId) -> Result<Vec<Decoration>> {\n-    let file = world.analysis().file_syntax(file_id)?;\n-    let line_index = world.analysis().file_line_index(file_id)?;\n-    let res = libeditor::highlight(&file)\n+fn highlight(world: &ServerWorld, file_id: FileId) -> Vec<Decoration> {\n+    let line_index = world.analysis().file_line_index(file_id);\n+    world.analysis().highlight(file_id)\n         .into_iter()\n         .map(|h| Decoration {\n             range: h.range.conv_with(&line_index),\n             tag: h.tag,\n-        }).collect();\n-    Ok(res)\n+        }).collect()\n }"}, {"sha": "0f66248a5a7f80181da92d1cad42bd6c2e54db62", "filename": "crates/server/src/main_loop/mod.rs", "status": "modified", "additions": 48, "deletions": 121, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/8abf5363433e977c5393bb569e2a5d559cb0a602/crates%2Fserver%2Fsrc%2Fmain_loop%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8abf5363433e977c5393bb569e2a5d559cb0a602/crates%2Fserver%2Fsrc%2Fmain_loop%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fserver%2Fsrc%2Fmain_loop%2Fmod.rs?ref=8abf5363433e977c5393bb569e2a5d559cb0a602", "patch": "@@ -7,32 +7,13 @@ use std::{\n use threadpool::ThreadPool;\n use crossbeam_channel::{Sender, Receiver};\n use languageserver_types::Url;\n-use serde_json::to_value;\n \n use {\n     req, dispatch,\n     Task, Result,\n     io::{Io, RawMsg, RawRequest, RawNotification},\n     vfs::FileEvent,\n     server_world::{ServerWorldState, ServerWorld},\n-    main_loop::handlers::{\n-        handle_syntax_tree,\n-        handle_extend_selection,\n-        publish_diagnostics,\n-        publish_decorations,\n-        handle_document_symbol,\n-        handle_code_action,\n-        handle_execute_command,\n-        handle_workspace_symbol,\n-        handle_goto_definition,\n-        handle_find_matching_brace,\n-        handle_parent_module,\n-        handle_join_lines,\n-        handle_completion,\n-        handle_runnables,\n-        handle_decorations,\n-        handle_on_type_formatting,\n-    },\n };\n \n pub(super) fn main_loop(\n@@ -45,7 +26,6 @@ pub(super) fn main_loop(\n     info!(\"server initialized, serving requests\");\n     let mut state = ServerWorldState::new();\n \n-    let mut next_request_id = 0;\n     let mut pending_requests: HashSet<u64> = HashSet::new();\n     let mut fs_events_receiver = Some(&fs_events_receiver);\n     loop {\n@@ -78,12 +58,6 @@ pub(super) fn main_loop(\n             }\n             Event::Task(task) => {\n                 match task {\n-                    Task::Request(mut request) => {\n-                        request.id = next_request_id;\n-                        pending_requests.insert(next_request_id);\n-                        next_request_id += 1;\n-                        io.send(RawMsg::Request(request));\n-                    }\n                     Task::Respond(response) =>\n                         io.send(RawMsg::Response(response)),\n                     Task::Notify(n) =>\n@@ -125,79 +99,26 @@ fn on_request(\n     sender: &Sender<Task>,\n     req: RawRequest,\n ) -> Result<bool> {\n-    let mut req = Some(req);\n-    handle_request_on_threadpool::<req::SyntaxTree>(\n-        &mut req, pool, world, sender, handle_syntax_tree,\n-    )?;\n-    handle_request_on_threadpool::<req::ExtendSelection>(\n-        &mut req, pool, world, sender, handle_extend_selection,\n-    )?;\n-    handle_request_on_threadpool::<req::FindMatchingBrace>(\n-        &mut req, pool, world, sender, handle_find_matching_brace,\n-    )?;\n-    handle_request_on_threadpool::<req::DocumentSymbolRequest>(\n-        &mut req, pool, world, sender, handle_document_symbol,\n-    )?;\n-    handle_request_on_threadpool::<req::CodeActionRequest>(\n-        &mut req, pool, world, sender, handle_code_action,\n-    )?;\n-    handle_request_on_threadpool::<req::Runnables>(\n-        &mut req, pool, world, sender, handle_runnables,\n-    )?;\n-    handle_request_on_threadpool::<req::WorkspaceSymbol>(\n-        &mut req, pool, world, sender, handle_workspace_symbol,\n-    )?;\n-    handle_request_on_threadpool::<req::GotoDefinition>(\n-        &mut req, pool, world, sender, handle_goto_definition,\n-    )?;\n-    handle_request_on_threadpool::<req::Completion>(\n-        &mut req, pool, world, sender, handle_completion,\n-    )?;\n-    handle_request_on_threadpool::<req::ParentModule>(\n-        &mut req, pool, world, sender, handle_parent_module,\n-    )?;\n-    handle_request_on_threadpool::<req::JoinLines>(\n-        &mut req, pool, world, sender, handle_join_lines,\n-    )?;\n-    handle_request_on_threadpool::<req::DecorationsRequest>(\n-        &mut req, pool, world, sender, handle_decorations,\n-    )?;\n-    handle_request_on_threadpool::<req::OnTypeFormatting>(\n-        &mut req, pool, world, sender, handle_on_type_formatting,\n-    )?;\n-    dispatch::handle_request::<req::ExecuteCommand, _>(&mut req, |params, resp| {\n-        io.send(RawMsg::Response(resp.into_response(Ok(None))?));\n-\n-        let world = world.snapshot();\n-        let sender = sender.clone();\n-        pool.execute(move || {\n-            let (edit, cursor) = match handle_execute_command(world, params) {\n-                Ok(res) => res,\n-                Err(e) => return sender.send(Task::Die(e)),\n-            };\n-            match to_value(edit) {\n-                Err(e) => return sender.send(Task::Die(e.into())),\n-                Ok(params) => {\n-                    let request = RawRequest {\n-                        id: 0,\n-                        method: <req::ApplyWorkspaceEdit as req::ClientRequest>::METHOD.to_string(),\n-                        params,\n-                    };\n-                    sender.send(Task::Request(request))\n-                }\n-            }\n-            if let Some(cursor) = cursor {\n-                let request = RawRequest {\n-                    id: 0,\n-                    method: <req::MoveCursor as req::ClientRequest>::METHOD.to_string(),\n-                    params: to_value(cursor).unwrap(),\n-                };\n-                sender.send(Task::Request(request))\n-            }\n-        });\n-        Ok(())\n-    })?;\n+    let mut pool_dispatcher = PoolDispatcher {\n+        req: Some(req),\n+        pool, world, sender\n+    };\n+    pool_dispatcher\n+        .on::<req::SyntaxTree>(handlers::handle_syntax_tree)?\n+        .on::<req::ExtendSelection>(handlers::handle_extend_selection)?\n+        .on::<req::FindMatchingBrace>(handlers::handle_find_matching_brace)?\n+        .on::<req::JoinLines>(handlers::handle_join_lines)?\n+        .on::<req::OnTypeFormatting>(handlers::handle_on_type_formatting)?\n+        .on::<req::DocumentSymbolRequest>(handlers::handle_document_symbol)?\n+        .on::<req::WorkspaceSymbol>(handlers::handle_workspace_symbol)?\n+        .on::<req::GotoDefinition>(handlers::handle_goto_definition)?\n+        .on::<req::ParentModule>(handlers::handle_parent_module)?\n+        .on::<req::Runnables>(handlers::handle_runnables)?\n+        .on::<req::DecorationsRequest>(handlers::handle_decorations)?\n+        .on::<req::Completion>(handlers::handle_completion)?\n+        .on::<req::CodeActionRequest>(handlers::handle_code_action)?;\n \n+    let mut req = pool_dispatcher.req;\n     let mut shutdown = false;\n     dispatch::handle_request::<req::Shutdown, _>(&mut req, |(), resp| {\n         let resp = resp.into_response(Ok(()))?;\n@@ -273,27 +194,33 @@ fn on_notification(\n     Ok(())\n }\n \n-fn handle_request_on_threadpool<R: req::ClientRequest>(\n-    req: &mut Option<RawRequest>,\n-    pool: &ThreadPool,\n-    world: &ServerWorldState,\n-    sender: &Sender<Task>,\n-    f: fn(ServerWorld, R::Params) -> Result<R::Result>,\n-) -> Result<()>\n-{\n-    dispatch::handle_request::<R, _>(req, |params, resp| {\n-        let world = world.snapshot();\n-        let sender = sender.clone();\n-        pool.execute(move || {\n-            let res = f(world, params);\n-            let task = match resp.into_response(res) {\n-                Ok(resp) => Task::Respond(resp),\n-                Err(e) => Task::Die(e),\n-            };\n-            sender.send(task);\n-        });\n-        Ok(())\n-    })\n+struct PoolDispatcher<'a> {\n+    req: Option<RawRequest>,\n+    pool: &'a ThreadPool,\n+    world: &'a ServerWorldState,\n+    sender: &'a Sender<Task>,\n+}\n+\n+impl<'a> PoolDispatcher<'a> {\n+    fn on<'b, R: req::ClientRequest>(&'b mut self, f: fn(ServerWorld, R::Params) -> Result<R::Result>) -> Result<&'b mut Self> {\n+        let world = self.world;\n+        let sender = self.sender;\n+        let pool = self.pool;\n+        dispatch::handle_request::<R, _>(&mut self.req, |params, resp| {\n+            let world = world.snapshot();\n+            let sender = sender.clone();\n+            pool.execute(move || {\n+                let res = f(world, params);\n+                let task = match resp.into_response(res) {\n+                    Ok(resp) => Task::Respond(resp),\n+                    Err(e) => Task::Die(e),\n+                };\n+                sender.send(task);\n+            });\n+            Ok(())\n+        })?;\n+        Ok(self)\n+    }\n }\n \n fn update_file_notifications_on_threadpool(\n@@ -303,7 +230,7 @@ fn update_file_notifications_on_threadpool(\n     uri: Url,\n ) {\n     pool.execute(move || {\n-        match publish_diagnostics(world.clone(), uri.clone()) {\n+        match handlers::publish_diagnostics(world.clone(), uri.clone()) {\n             Err(e) => {\n                 error!(\"failed to compute diagnostics: {:?}\", e)\n             }\n@@ -312,7 +239,7 @@ fn update_file_notifications_on_threadpool(\n                 sender.send(Task::Notify(not));\n             }\n         }\n-        match publish_decorations(world, uri) {\n+        match handlers::publish_decorations(world, uri) {\n             Err(e) => {\n                 error!(\"failed to compute decorations: {:?}\", e)\n             }"}, {"sha": "c6d2f2efbc639c0e9652aa846469c0fc1978ace4", "filename": "crates/server/src/req.rs", "status": "modified", "additions": 26, "deletions": 9, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/8abf5363433e977c5393bb569e2a5d559cb0a602/crates%2Fserver%2Fsrc%2Freq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8abf5363433e977c5393bb569e2a5d559cb0a602/crates%2Fserver%2Fsrc%2Freq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fserver%2Fsrc%2Freq.rs?ref=8abf5363433e977c5393bb569e2a5d559cb0a602", "patch": "@@ -15,6 +15,7 @@ pub use languageserver_types::{\n     TextEdit,\n     CompletionParams, CompletionResponse,\n     DocumentOnTypeFormattingParams,\n+    TextDocumentEdit,\n };\n \n \n@@ -115,14 +116,6 @@ pub struct Decoration {\n     pub tag: &'static str\n }\n \n-pub enum MoveCursor {}\n-\n-impl Request for MoveCursor {\n-    type Params = Position;\n-    type Result = ();\n-    const METHOD: &'static str = \"m/moveCursor\";\n-}\n-\n pub enum ParentModule {}\n \n impl Request for ParentModule {\n@@ -135,7 +128,7 @@ pub enum JoinLines {}\n \n impl Request for JoinLines {\n     type Params = JoinLinesParams;\n-    type Result = Vec<TextEdit>;\n+    type Result = SourceChange;\n     const METHOD: &'static str = \"m/joinLines\";\n }\n \n@@ -170,3 +163,27 @@ pub struct Runnable {\n     pub args: Vec<String>,\n     pub env: HashMap<String, String>,\n }\n+\n+#[derive(Serialize, Debug)]\n+#[serde(rename_all = \"camelCase\")]\n+pub struct SourceChange {\n+    pub label: String,\n+    pub source_file_edits: Vec<TextDocumentEdit>,\n+    pub file_system_edits: Vec<FileSystemEdit>,\n+    pub cursor_position: Option<TextDocumentPositionParams>,\n+}\n+\n+#[derive(Serialize, Debug)]\n+#[serde(tag = \"type\", rename_all = \"camelCase\")]\n+pub enum FileSystemEdit {\n+    CreateFile {\n+        #[serde(with = \"url_serde\")]\n+        uri: Url\n+    },\n+    MoveFile {\n+        #[serde(with = \"url_serde\")]\n+        src: Url,\n+        #[serde(with = \"url_serde\")]\n+        dst: Url,\n+    }\n+}"}, {"sha": "6c85914ba3c55f5372375787fd509a70ee756f7a", "filename": "crates/server/src/server_world.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8abf5363433e977c5393bb569e2a5d559cb0a602/crates%2Fserver%2Fsrc%2Fserver_world.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8abf5363433e977c5393bb569e2a5d559cb0a602/crates%2Fserver%2Fsrc%2Fserver_world.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fserver%2Fsrc%2Fserver_world.rs?ref=8abf5363433e977c5393bb569e2a5d559cb0a602", "patch": "@@ -5,7 +5,7 @@ use std::{\n };\n \n use languageserver_types::Url;\n-use libanalysis::{FileId, WorldState, World};\n+use libanalysis::{FileId, WorldState, Analysis};\n \n use {\n     Result,\n@@ -22,7 +22,7 @@ pub struct ServerWorldState {\n \n #[derive(Clone)]\n pub struct ServerWorld {\n-    pub analysis: World,\n+    pub analysis: Analysis,\n     pub path_map: PathMap,\n }\n \n@@ -91,14 +91,14 @@ impl ServerWorldState {\n \n     pub fn snapshot(&self) -> ServerWorld {\n         ServerWorld {\n-            analysis: self.analysis.snapshot(self.path_map.clone()),\n+            analysis: self.analysis.analysis(self.path_map.clone()),\n             path_map: self.path_map.clone()\n         }\n     }\n }\n \n impl ServerWorld {\n-    pub fn analysis(&self) -> &World {\n+    pub fn analysis(&self) -> &Analysis {\n         &self.analysis\n     }\n "}]}