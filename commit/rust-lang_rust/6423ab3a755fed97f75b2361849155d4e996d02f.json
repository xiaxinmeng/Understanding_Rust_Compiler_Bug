{"sha": "6423ab3a755fed97f75b2361849155d4e996d02f", "node_id": "C_kwDOAAsO6NoAKDY0MjNhYjNhNzU1ZmVkOTdmNzViMjM2MTg0OTE1NWQ0ZTk5NmQwMmY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-01T01:11:08Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-08-01T01:11:08Z"}, "message": "Auto merge of #99998 - matthiaskrgr:rollup-igafy0r, r=matthiaskrgr\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #99519 (Remove implicit names and values from `--cfg` in `--check-cfg`)\n - #99620 (`-Z location-detail`: provide option to disable all location details)\n - #99932 (Fix unwinding on certain platforms when debug assertions are enabled)\n - #99973 (Layout things)\n - #99980 (Remove more Clean trait implementations)\n - #99984 (Fix compat.rs for `cfg(miri)`)\n - #99986 (Add wrap suggestions for record variants)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "30241f14b8068f0e26702892825809640dc56249", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/30241f14b8068f0e26702892825809640dc56249"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6423ab3a755fed97f75b2361849155d4e996d02f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6423ab3a755fed97f75b2361849155d4e996d02f", "html_url": "https://github.com/rust-lang/rust/commit/6423ab3a755fed97f75b2361849155d4e996d02f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6423ab3a755fed97f75b2361849155d4e996d02f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "34805f36752fd81cabc5104579e065e62fc0fec6", "url": "https://api.github.com/repos/rust-lang/rust/commits/34805f36752fd81cabc5104579e065e62fc0fec6", "html_url": "https://github.com/rust-lang/rust/commit/34805f36752fd81cabc5104579e065e62fc0fec6"}, {"sha": "20a5e9fd7cdf3f9b3e60f1f4d52148b5ff45819e", "url": "https://api.github.com/repos/rust-lang/rust/commits/20a5e9fd7cdf3f9b3e60f1f4d52148b5ff45819e", "html_url": "https://github.com/rust-lang/rust/commit/20a5e9fd7cdf3f9b3e60f1f4d52148b5ff45819e"}], "stats": {"total": 2160, "additions": 1096, "deletions": 1064}, "files": [{"sha": "5e5596f13c845a5508039529c368b5e98a9dacbb", "filename": "compiler/rustc_interface/src/util.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6423ab3a755fed97f75b2361849155d4e996d02f/compiler%2Frustc_interface%2Fsrc%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6423ab3a755fed97f75b2361849155d4e996d02f/compiler%2Frustc_interface%2Fsrc%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Futil.rs?ref=6423ab3a755fed97f75b2361849155d4e996d02f", "patch": "@@ -117,7 +117,6 @@ pub fn create_session(\n \n     let mut check_cfg = config::to_crate_check_config(check_cfg);\n     check_cfg.fill_well_known();\n-    check_cfg.fill_actual(&cfg);\n \n     sess.parse_sess.config = cfg;\n     sess.parse_sess.check_config = check_cfg;"}, {"sha": "ad78d24e954653f80791612914f822a0dbbd9851", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6423ab3a755fed97f75b2361849155d4e996d02f/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6423ab3a755fed97f75b2361849155d4e996d02f/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=6423ab3a755fed97f75b2361849155d4e996d02f", "patch": "@@ -232,6 +232,10 @@ fn sanity_check_layout<'tcx>(\n         assert!(layout.abi.is_uninhabited());\n     }\n \n+    if layout.size.bytes() % layout.align.abi.bytes() != 0 {\n+        bug!(\"size is not a multiple of align, in the following layout:\\n{layout:#?}\");\n+    }\n+\n     if cfg!(debug_assertions) {\n         fn check_layout_abi<'tcx>(tcx: TyCtxt<'tcx>, layout: Layout<'tcx>) {\n             match layout.abi() {"}, {"sha": "6a8298605a23b8624d657e2912e8ed6ebca1e5e4", "filename": "compiler/rustc_session/src/config.rs", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6423ab3a755fed97f75b2361849155d4e996d02f/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6423ab3a755fed97f75b2361849155d4e996d02f/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fconfig.rs?ref=6423ab3a755fed97f75b2361849155d4e996d02f", "patch": "@@ -1159,20 +1159,6 @@ impl CrateCheckConfig {\n         self.fill_well_known_names();\n         self.fill_well_known_values();\n     }\n-\n-    /// Fills a `CrateCheckConfig` with configuration names and values that are actually active.\n-    pub fn fill_actual(&mut self, cfg: &CrateConfig) {\n-        for &(k, v) in cfg {\n-            if let Some(names_valid) = &mut self.names_valid {\n-                names_valid.insert(k);\n-            }\n-            if let Some(v) = v {\n-                self.values_valid.entry(k).and_modify(|values| {\n-                    values.insert(v);\n-                });\n-            }\n-        }\n-    }\n }\n \n pub fn build_configuration(sess: &Session, mut user_cfg: CrateConfig) -> CrateConfig {"}, {"sha": "1827f1c208de7a5648040c2cf0a82fa6a3afe267", "filename": "compiler/rustc_session/src/options.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6423ab3a755fed97f75b2361849155d4e996d02f/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6423ab3a755fed97f75b2361849155d4e996d02f/compiler%2Frustc_session%2Fsrc%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Foptions.rs?ref=6423ab3a755fed97f75b2361849155d4e996d02f", "patch": "@@ -393,8 +393,7 @@ mod desc {\n         \"either a boolean (`yes`, `no`, `on`, `off`, etc), `thin`, `fat`, or omitted\";\n     pub const parse_linker_plugin_lto: &str =\n         \"either a boolean (`yes`, `no`, `on`, `off`, etc), or the path to the linker plugin\";\n-    pub const parse_location_detail: &str =\n-        \"comma separated list of location details to track: `file`, `line`, or `column`\";\n+    pub const parse_location_detail: &str = \"either `none`, or a comma separated list of location details to track: `file`, `line`, or `column`\";\n     pub const parse_switch_with_opt_path: &str =\n         \"an optional path to the profiling data output directory\";\n     pub const parse_merge_functions: &str = \"one of: `disabled`, `trampolines`, or `aliases`\";\n@@ -551,6 +550,9 @@ mod parse {\n             ld.line = false;\n             ld.file = false;\n             ld.column = false;\n+            if v == \"none\" {\n+                return true;\n+            }\n             for s in v.split(',') {\n                 match s {\n                     \"file\" => ld.file = true,\n@@ -1374,8 +1376,9 @@ options! {\n     llvm_time_trace: bool = (false, parse_bool, [UNTRACKED],\n         \"generate JSON tracing data file from LLVM data (default: no)\"),\n     location_detail: LocationDetail = (LocationDetail::all(), parse_location_detail, [TRACKED],\n-        \"comma separated list of location details to be tracked when using caller_location \\\n-        valid options are `file`, `line`, and `column` (default: all)\"),\n+        \"what location details should be tracked when using caller_location, either \\\n+        `none`, or a comma separated list of location details, for which \\\n+        valid options are `file`, `line`, and `column` (default: `file,line,column`)\"),\n     ls: bool = (false, parse_bool, [UNTRACKED],\n         \"list the symbols defined by a library crate (default: no)\"),\n     macro_backtrace: bool = (false, parse_bool, [UNTRACKED],"}, {"sha": "d4d5674e246d86f0a5e68bfa71e552d1c069d1ad", "filename": "compiler/rustc_target/src/abi/mod.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/6423ab3a755fed97f75b2361849155d4e996d02f/compiler%2Frustc_target%2Fsrc%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6423ab3a755fed97f75b2361849155d4e996d02f/compiler%2Frustc_target%2Fsrc%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fmod.rs?ref=6423ab3a755fed97f75b2361849155d4e996d02f", "patch": "@@ -1279,13 +1279,14 @@ impl<'a> fmt::Debug for LayoutS<'a> {\n         // This is how `Layout` used to print before it become\n         // `Interned<LayoutS>`. We print it like this to avoid having to update\n         // expected output in a lot of tests.\n+        let LayoutS { size, align, abi, fields, largest_niche, variants } = self;\n         f.debug_struct(\"Layout\")\n-            .field(\"fields\", &self.fields)\n-            .field(\"variants\", &self.variants)\n-            .field(\"abi\", &self.abi)\n-            .field(\"largest_niche\", &self.largest_niche)\n-            .field(\"align\", &self.align)\n-            .field(\"size\", &self.size)\n+            .field(\"size\", size)\n+            .field(\"align\", align)\n+            .field(\"abi\", abi)\n+            .field(\"fields\", fields)\n+            .field(\"largest_niche\", largest_niche)\n+            .field(\"variants\", variants)\n             .finish()\n     }\n }"}, {"sha": "f0110645551af94740851e5a3c434469c6a64a92", "filename": "compiler/rustc_typeck/src/check/demand.rs", "status": "modified", "additions": 33, "deletions": 19, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/6423ab3a755fed97f75b2361849155d4e996d02f/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6423ab3a755fed97f75b2361849155d4e996d02f/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs?ref=6423ab3a755fed97f75b2361849155d4e996d02f", "patch": "@@ -1,5 +1,6 @@\n use crate::check::FnCtxt;\n use rustc_infer::infer::InferOk;\n+use rustc_middle::middle::stability::EvalResult;\n use rustc_trait_selection::infer::InferCtxtExt as _;\n use rustc_trait_selection::traits::ObligationCause;\n \n@@ -363,18 +364,20 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 }\n             }\n \n-            let compatible_variants: Vec<(String, Option<String>)> = expected_adt\n+            let compatible_variants: Vec<(String, _, _, Option<String>)> = expected_adt\n                 .variants()\n                 .iter()\n                 .filter(|variant| {\n-                    variant.fields.len() == 1 && variant.ctor_kind == hir::def::CtorKind::Fn\n+                    variant.fields.len() == 1\n                 })\n                 .filter_map(|variant| {\n                     let sole_field = &variant.fields[0];\n \n                     let field_is_local = sole_field.did.is_local();\n                     let field_is_accessible =\n-                        sole_field.vis.is_accessible_from(expr.hir_id.owner.to_def_id(), self.tcx);\n+                        sole_field.vis.is_accessible_from(expr.hir_id.owner.to_def_id(), self.tcx)\n+                        // Skip suggestions for unstable public fields (for example `Pin::pointer`)\n+                        && matches!(self.tcx.eval_stability(sole_field.did, None, expr.span, None), EvalResult::Allow | EvalResult::Unmarked);\n \n                     if !field_is_local && !field_is_accessible {\n                         return None;\n@@ -391,33 +394,45 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         if let Some(path) = variant_path.strip_prefix(\"std::prelude::\")\n                             && let Some((_, path)) = path.split_once(\"::\")\n                         {\n-                            return Some((path.to_string(), note_about_variant_field_privacy));\n+                            return Some((path.to_string(), variant.ctor_kind, sole_field.name, note_about_variant_field_privacy));\n                         }\n-                        Some((variant_path, note_about_variant_field_privacy))\n+                        Some((variant_path, variant.ctor_kind, sole_field.name, note_about_variant_field_privacy))\n                     } else {\n                         None\n                     }\n                 })\n                 .collect();\n \n-            let prefix = match self.maybe_get_struct_pattern_shorthand_field(expr) {\n-                Some(ident) => format!(\"{ident}: \"),\n-                None => String::new(),\n+            let suggestions_for = |variant: &_, ctor, field_name| {\n+                let prefix = match self.maybe_get_struct_pattern_shorthand_field(expr) {\n+                    Some(ident) => format!(\"{ident}: \"),\n+                    None => String::new(),\n+                };\n+\n+                let (open, close) = match ctor {\n+                    hir::def::CtorKind::Fn => (\"(\".to_owned(), \")\"),\n+                    hir::def::CtorKind::Fictive => (format!(\" {{ {field_name}: \"), \" }\"),\n+\n+                    // unit variants don't have fields\n+                    hir::def::CtorKind::Const => unreachable!(),\n+                };\n+\n+                vec![\n+                    (expr.span.shrink_to_lo(), format!(\"{prefix}{variant}{open}\")),\n+                    (expr.span.shrink_to_hi(), close.to_owned()),\n+                ]\n             };\n \n             match &compatible_variants[..] {\n                 [] => { /* No variants to format */ }\n-                [(variant, note)] => {\n+                [(variant, ctor_kind, field_name, note)] => {\n                     // Just a single matching variant.\n                     err.multipart_suggestion_verbose(\n                         &format!(\n                             \"try wrapping the expression in `{variant}`{note}\",\n                             note = note.as_deref().unwrap_or(\"\")\n                         ),\n-                        vec![\n-                            (expr.span.shrink_to_lo(), format!(\"{prefix}{variant}(\")),\n-                            (expr.span.shrink_to_hi(), \")\".to_string()),\n-                        ],\n+                        suggestions_for(&**variant, *ctor_kind, *field_name),\n                         Applicability::MaybeIncorrect,\n                     );\n                 }\n@@ -428,12 +443,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             \"try wrapping the expression in a variant of `{}`\",\n                             self.tcx.def_path_str(expected_adt.did())\n                         ),\n-                        compatible_variants.into_iter().map(|(variant, _)| {\n-                            vec![\n-                                (expr.span.shrink_to_lo(), format!(\"{prefix}{variant}(\")),\n-                                (expr.span.shrink_to_hi(), \")\".to_string()),\n-                            ]\n-                        }),\n+                        compatible_variants.into_iter().map(\n+                            |(variant, ctor_kind, field_name, _)| {\n+                                suggestions_for(&variant, ctor_kind, field_name)\n+                            },\n+                        ),\n                         Applicability::MaybeIncorrect,\n                     );\n                 }"}, {"sha": "a596592311a640c000f8116fee3eece7e02f30f0", "filename": "library/panic_unwind/src/gcc.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6423ab3a755fed97f75b2361849155d4e996d02f/library%2Fpanic_unwind%2Fsrc%2Fgcc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6423ab3a755fed97f75b2361849155d4e996d02f/library%2Fpanic_unwind%2Fsrc%2Fgcc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fpanic_unwind%2Fsrc%2Fgcc.rs?ref=6423ab3a755fed97f75b2361849155d4e996d02f", "patch": "@@ -306,7 +306,9 @@ unsafe fn find_eh_action(context: *mut uw::_Unwind_Context) -> Result<EHAction,\n     let eh_context = EHContext {\n         // The return address points 1 byte past the call instruction,\n         // which could be in the next IP range in LSDA range table.\n-        ip: if ip_before_instr != 0 { ip } else { ip - 1 },\n+        //\n+        // `ip = -1` has special meaning, so use wrapping sub to allow for that\n+        ip: if ip_before_instr != 0 { ip } else { ip.wrapping_sub(1) },\n         func_start: uw::_Unwind_GetRegionStart(context),\n         get_text_start: &|| uw::_Unwind_GetTextRelBase(context),\n         get_data_start: &|| uw::_Unwind_GetDataRelBase(context),"}, {"sha": "ccc90177a2034740f83e1ffd2bebc0a0f839c93e", "filename": "library/std/src/sys/windows/compat.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6423ab3a755fed97f75b2361849155d4e996d02f/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fcompat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6423ab3a755fed97f75b2361849155d4e996d02f/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fcompat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fcompat.rs?ref=6423ab3a755fed97f75b2361849155d4e996d02f", "patch": "@@ -180,8 +180,8 @@ macro_rules! compat_fn_with_fallback {\n \n             fn load_from_module(module: Option<Module>) -> F {\n                 unsafe {\n-                    static symbol_name: &CStr = ansi_str!(sym $symbol);\n-                    if let Some(f) = module.and_then(|m| m.proc_address(symbol_name)) {\n+                    static SYMBOL_NAME: &CStr = ansi_str!(sym $symbol);\n+                    if let Some(f) = module.and_then(|m| m.proc_address(SYMBOL_NAME)) {\n                         PTR.store(f.as_ptr(), Ordering::Relaxed);\n                         mem::transmute(f)\n                     } else {\n@@ -251,7 +251,7 @@ macro_rules! compat_fn_optional {\n             pub fn option() -> Option<F> {\n                 let mut func = NonNull::new(PTR.load(Ordering::Relaxed));\n                 if func.is_none() {\n-                    Module::new($module).map(preload);\n+                    unsafe { Module::new($module).map(preload) };\n                     func = NonNull::new(PTR.load(Ordering::Relaxed));\n                 }\n                 unsafe {\n@@ -262,8 +262,8 @@ macro_rules! compat_fn_optional {\n             #[allow(unused)]\n             pub(in crate::sys) fn preload(module: Module) {\n                 unsafe {\n-                    let symbol_name = ansi_str!(sym $symbol);\n-                    if let Some(f) = module.proc_address(symbol_name) {\n+                    static SYMBOL_NAME: &CStr = ansi_str!(sym $symbol);\n+                    if let Some(f) = module.proc_address(SYMBOL_NAME) {\n                         PTR.store(f.as_ptr(), Ordering::Relaxed);\n                     }\n                 }"}, {"sha": "bfa92e7d32a8eaf1851275a680043049cdc71fff", "filename": "src/doc/unstable-book/src/compiler-flags/check-cfg.md", "status": "modified", "additions": 9, "deletions": 26, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/6423ab3a755fed97f75b2361849155d4e996d02f/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fcheck-cfg.md", "raw_url": "https://github.com/rust-lang/rust/raw/6423ab3a755fed97f75b2361849155d4e996d02f/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fcheck-cfg.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fcheck-cfg.md?ref=6423ab3a755fed97f75b2361849155d4e996d02f", "patch": "@@ -18,6 +18,9 @@ check cfg specification is parsed using the Rust metadata syntax, just as the `-\n These two options are independent. `names` checks only the namespace of condition names\n while `values` checks only the namespace of the values of list-valued conditions.\n \n+NOTE: No implicit expectation is added when using `--cfg` for both forms. Users are expected to\n+pass all expected names and values using `names(...)` and `values(...)`.\n+\n ## The `names(...)` form\n \n The `names(...)` form enables checking the names. This form uses a named list:\n@@ -53,27 +56,6 @@ The first form enables checking condition names, while specifying that there are\n condition names (outside of the set of well-known names defined by `rustc`). Omitting the\n `--check-cfg 'names(...)'` option does not enable checking condition names.\n \n-Conditions that are enabled are implicitly valid; it is unnecessary (but legal) to specify a\n-condition name as both enabled and valid. For example, the following invocations are equivalent:\n-\n-```bash\n-# condition names will be checked, and 'has_time_travel' is valid\n-rustc --cfg 'has_time_travel' --check-cfg 'names()'\n-\n-# condition names will be checked, and 'has_time_travel' is valid\n-rustc --cfg 'has_time_travel' --check-cfg 'names(has_time_travel)'\n-```\n-\n-In contrast, the following two invocations are _not_ equivalent:\n-\n-```bash\n-# condition names will not be checked (because there is no --check-cfg names(...))\n-rustc --cfg 'has_time_travel'\n-\n-# condition names will be checked, and 'has_time_travel' is both valid and enabled.\n-rustc --cfg 'has_time_travel' --check-cfg 'names(has_time_travel)'\n-```\n-\n ## The `values(...)` form\n \n The `values(...)` form enables checking the values within list-valued conditions. It has this\n@@ -149,7 +131,7 @@ fn tame_lion() {}\n ```bash\n # This turns on checking for condition names, but not values, such as 'feature' values.\n rustc --check-cfg 'names(is_embedded, has_feathers)' \\\n-      --cfg has_feathers --cfg 'feature = \"zapping\"' -Z unstable-options\n+      --cfg has_feathers -Z unstable-options\n ```\n \n ```rust\n@@ -159,13 +141,14 @@ fn do_embedded() {}\n #[cfg(has_feathers)]        // This is expected as \"has_feathers\" was provided in names()\n fn do_features() {}\n \n+#[cfg(has_feathers = \"zapping\")] // This is expected as \"has_feathers\" was provided in names()\n+                                 // and because no value checking was enable for \"has_feathers\"\n+                                 // no warning is emited for the value \"zapping\"\n+fn do_zapping() {}\n+\n #[cfg(has_mumble_frotz)]    // This is UNEXPECTED because names checking is enable and\n                             // \"has_mumble_frotz\" was not provided in names()\n fn do_mumble_frotz() {}\n-\n-#[cfg(feature = \"lasers\")]  // This doesn't raise a warning, because values checking for \"feature\"\n-                            // was never used\n-fn shoot_lasers() {}\n ```\n \n ### Example: Checking feature values, but not condition names"}, {"sha": "db070619969649034ba4f531cb47a65289afe07e", "filename": "src/doc/unstable-book/src/compiler-flags/location-detail.md", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6423ab3a755fed97f75b2361849155d4e996d02f/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Flocation-detail.md", "raw_url": "https://github.com/rust-lang/rust/raw/6423ab3a755fed97f75b2361849155d4e996d02f/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Flocation-detail.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Flocation-detail.md?ref=6423ab3a755fed97f75b2361849155d4e996d02f", "patch": "@@ -17,8 +17,9 @@ within this list are:\n - `line` - the source line of the panic will be included in the panic output\n - `column` - the source column of the panic will be included in the panic output\n \n-Any combination of these three options are supported. If this option is not specified,\n-all three are included by default.\n+Any combination of these three options are supported. Alternatively, you can pass\n+`none` to this option, which results in no location details being tracked.\n+If this option is not specified, all three are included by default.\n \n An example of a panic output when using `-Z location-detail=line`:\n ```text"}, {"sha": "5071581e5dc43306f1f61317b8f990ef99acf6b2", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 16, "deletions": 22, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/6423ab3a755fed97f75b2361849155d4e996d02f/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6423ab3a755fed97f75b2361849155d4e996d02f/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=6423ab3a755fed97f75b2361849155d4e996d02f", "patch": "@@ -1019,7 +1019,7 @@ impl<'tcx> Clean<'tcx, bool> for hir::IsAuto {\n \n impl<'tcx> Clean<'tcx, Path> for hir::TraitRef<'tcx> {\n     fn clean(&self, cx: &mut DocContext<'tcx>) -> Path {\n-        let path = self.path.clean(cx);\n+        let path = clean_path(self.path, cx);\n         register_res(cx, path.res);\n         path\n     }\n@@ -1344,7 +1344,7 @@ fn clean_qpath<'tcx>(hir_ty: &hir::Ty<'tcx>, cx: &mut DocContext<'tcx>) -> Type\n             if let Some(expanded) = maybe_expand_private_type_alias(cx, path) {\n                 expanded\n             } else {\n-                let path = path.clean(cx);\n+                let path = clean_path(path, cx);\n                 resolve_type(cx, path)\n             }\n         }\n@@ -1380,7 +1380,7 @@ fn clean_qpath<'tcx>(hir_ty: &hir::Ty<'tcx>, cx: &mut DocContext<'tcx>) -> Type\n                 ty::Error(_) => return Type::Infer,\n                 _ => bug!(\"clean: expected associated type, found `{:?}`\", ty),\n             };\n-            let trait_ = hir::Path { span, res, segments: &[] }.clean(cx);\n+            let trait_ = clean_path(&hir::Path { span, res, segments: &[] }, cx);\n             register_res(cx, trait_.res);\n             let self_def_id = res.opt_def_id();\n             let self_type = clean_ty(qself, cx);\n@@ -1857,10 +1857,8 @@ fn clean_variant_data<'tcx>(\n     }\n }\n \n-impl<'tcx> Clean<'tcx, Path> for hir::Path<'tcx> {\n-    fn clean(&self, cx: &mut DocContext<'tcx>) -> Path {\n-        Path { res: self.res, segments: self.segments.iter().map(|x| x.clean(cx)).collect() }\n-    }\n+fn clean_path<'tcx>(path: &hir::Path<'tcx>, cx: &mut DocContext<'tcx>) -> Path {\n+    Path { res: path.res, segments: path.segments.iter().map(|x| x.clean(cx)).collect() }\n }\n \n impl<'tcx> Clean<'tcx, GenericArgs> for hir::GenericArgs<'tcx> {\n@@ -1886,7 +1884,8 @@ impl<'tcx> Clean<'tcx, GenericArgs> for hir::GenericArgs<'tcx> {\n                 })\n                 .collect::<Vec<_>>()\n                 .into();\n-            let bindings = self.bindings.iter().map(|x| x.clean(cx)).collect::<Vec<_>>().into();\n+            let bindings =\n+                self.bindings.iter().map(|x| clean_type_binding(x, cx)).collect::<Vec<_>>().into();\n             GenericArgs::AngleBracketed { args, bindings }\n         }\n     }\n@@ -2172,7 +2171,7 @@ fn clean_use_statement<'tcx>(\n \n     // Also check whether imports were asked to be inlined, in case we're trying to re-export a\n     // crate in Rust 2018+\n-    let path = path.clean(cx);\n+    let path = clean_path(path, cx);\n     let inner = if kind == hir::UseKind::Glob {\n         if !denied {\n             let mut visited = FxHashSet::default();\n@@ -2252,24 +2251,19 @@ fn clean_maybe_renamed_foreign_item<'tcx>(\n     })\n }\n \n-impl<'tcx> Clean<'tcx, TypeBinding> for hir::TypeBinding<'tcx> {\n-    fn clean(&self, cx: &mut DocContext<'tcx>) -> TypeBinding {\n-        TypeBinding {\n-            assoc: PathSegment { name: self.ident.name, args: self.gen_args.clean(cx) },\n-            kind: self.kind.clean(cx),\n-        }\n-    }\n-}\n-\n-impl<'tcx> Clean<'tcx, TypeBindingKind> for hir::TypeBindingKind<'tcx> {\n-    fn clean(&self, cx: &mut DocContext<'tcx>) -> TypeBindingKind {\n-        match *self {\n+fn clean_type_binding<'tcx>(\n+    type_binding: &hir::TypeBinding<'tcx>,\n+    cx: &mut DocContext<'tcx>,\n+) -> TypeBinding {\n+    TypeBinding {\n+        assoc: PathSegment { name: type_binding.ident.name, args: type_binding.gen_args.clean(cx) },\n+        kind: match type_binding.kind {\n             hir::TypeBindingKind::Equality { ref term } => {\n                 TypeBindingKind::Equality { term: clean_hir_term(term, cx) }\n             }\n             hir::TypeBindingKind::Constraint { bounds } => TypeBindingKind::Constraint {\n                 bounds: bounds.iter().filter_map(|b| b.clean(cx)).collect(),\n             },\n-        }\n+        },\n     }\n }"}, {"sha": "6dc41231559c0dc25d2440e772b477f4fed1fc72", "filename": "src/test/rustdoc-ui/z-help.stdout", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6423ab3a755fed97f75b2361849155d4e996d02f/src%2Ftest%2Frustdoc-ui%2Fz-help.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/6423ab3a755fed97f75b2361849155d4e996d02f/src%2Ftest%2Frustdoc-ui%2Fz-help.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fz-help.stdout?ref=6423ab3a755fed97f75b2361849155d4e996d02f", "patch": "@@ -69,7 +69,7 @@\n     -Z                               link-only=val -- link the `.rlink` file generated by `-Z no-link` (default: no)\n     -Z                            llvm-plugins=val -- a list LLVM plugins to enable (space separated)\n     -Z                         llvm-time-trace=val -- generate JSON tracing data file from LLVM data (default: no)\n-    -Z                         location-detail=val -- comma separated list of location details to be tracked when using caller_location valid options are `file`, `line`, and `column` (default: all)\n+    -Z                         location-detail=val -- what location details should be tracked when using caller_location, either `none`, or a comma separated list of location details, for which valid options are `file`, `line`, and `column` (default: `file,line,column`)\n     -Z                                      ls=val -- list the symbols defined by a library crate (default: no)\n     -Z                         macro-backtrace=val -- show macro backtraces (default: no)\n     -Z                         merge-functions=val -- control the operation of the MergeFunctions LLVM pass, taking the same values as the target option of the same name"}, {"sha": "9e428d367fdf431cf5f91abea7f75f00bc033b67", "filename": "src/test/ui/check-cfg/invalid-cfg-value.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6423ab3a755fed97f75b2361849155d4e996d02f/src%2Ftest%2Fui%2Fcheck-cfg%2Finvalid-cfg-value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6423ab3a755fed97f75b2361849155d4e996d02f/src%2Ftest%2Fui%2Fcheck-cfg%2Finvalid-cfg-value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcheck-cfg%2Finvalid-cfg-value.rs?ref=6423ab3a755fed97f75b2361849155d4e996d02f", "patch": "@@ -12,6 +12,7 @@ pub fn f() {}\n pub fn g() {}\n \n #[cfg(feature = \"rand\")]\n+//~^ WARNING unexpected `cfg` condition value\n pub fn h() {}\n \n pub fn main() {}"}, {"sha": "6cce31d339286babadec43ef7dddd93094fb31cb", "filename": "src/test/ui/check-cfg/invalid-cfg-value.stderr", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6423ab3a755fed97f75b2361849155d4e996d02f/src%2Ftest%2Fui%2Fcheck-cfg%2Finvalid-cfg-value.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6423ab3a755fed97f75b2361849155d4e996d02f/src%2Ftest%2Fui%2Fcheck-cfg%2Finvalid-cfg-value.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcheck-cfg%2Finvalid-cfg-value.stderr?ref=6423ab3a755fed97f75b2361849155d4e996d02f", "patch": "@@ -5,7 +5,15 @@ LL | #[cfg(feature = \"sedre\")]\n    |       ^^^^^^^^^^^^^^^^^\n    |\n    = note: `#[warn(unexpected_cfgs)]` on by default\n-   = note: expected values for `feature` are: full, rand, serde\n+   = note: expected values for `feature` are: full, serde\n \n-warning: 1 warning emitted\n+warning: unexpected `cfg` condition value\n+  --> $DIR/invalid-cfg-value.rs:14:7\n+   |\n+LL | #[cfg(feature = \"rand\")]\n+   |       ^^^^^^^^^^^^^^^^\n+   |\n+   = note: expected values for `feature` are: full, serde\n+\n+warning: 2 warnings emitted\n "}, {"sha": "8e3d20d50458fb4a39ed6b305b190d0d65ba12ca", "filename": "src/test/ui/check-cfg/mix.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6423ab3a755fed97f75b2361849155d4e996d02f/src%2Ftest%2Fui%2Fcheck-cfg%2Fmix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6423ab3a755fed97f75b2361849155d4e996d02f/src%2Ftest%2Fui%2Fcheck-cfg%2Fmix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcheck-cfg%2Fmix.rs?ref=6423ab3a755fed97f75b2361849155d4e996d02f", "patch": "@@ -1,6 +1,6 @@\n-// This test checks the combination of well known names, their activation via names(), the usage of\n-// partial values() with a --cfg and test that we also correctly lint on the `cfg!` macro and\n-// `cfg_attr` attribute.\n+// This test checks the combination of well known names, their activation via names(),\n+// the usage of values(), and that no implicit is done with --cfg while also testing that\n+// we correctly lint on the `cfg!` macro and `cfg_attr` attribute.\n //\n // check-pass\n // compile-flags: --check-cfg=names() --check-cfg=values(feature,\"foo\") --cfg feature=\"bar\" -Z unstable-options\n@@ -16,6 +16,7 @@ fn do_windows_stuff() {}\n fn use_foo() {}\n \n #[cfg(feature = \"bar\")]\n+//~^ WARNING unexpected `cfg` condition value\n fn use_bar() {}\n \n #[cfg(feature = \"zebra\")]\n@@ -35,6 +36,7 @@ fn test_cfg_macro() {\n     //~^ WARNING unexpected `cfg` condition name\n     cfg!(feature = \"foo\");\n     cfg!(feature = \"bar\");\n+    //~^ WARNING unexpected `cfg` condition value\n     cfg!(feature = \"zebra\");\n     //~^ WARNING unexpected `cfg` condition value\n     cfg!(xxx = \"foo\");"}, {"sha": "e51b75b3d4358a1f8c0059d2885a15c27e8cc5fb", "filename": "src/test/ui/check-cfg/mix.stderr", "status": "modified", "additions": 47, "deletions": 33, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/6423ab3a755fed97f75b2361849155d4e996d02f/src%2Ftest%2Fui%2Fcheck-cfg%2Fmix.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6423ab3a755fed97f75b2361849155d4e996d02f/src%2Ftest%2Fui%2Fcheck-cfg%2Fmix.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcheck-cfg%2Fmix.stderr?ref=6423ab3a755fed97f75b2361849155d4e996d02f", "patch": "@@ -7,154 +7,168 @@ LL | #[cfg(widnows)]\n    = note: `#[warn(unexpected_cfgs)]` on by default\n \n warning: unexpected `cfg` condition value\n-  --> $DIR/mix.rs:21:7\n+  --> $DIR/mix.rs:18:7\n+   |\n+LL | #[cfg(feature = \"bar\")]\n+   |       ^^^^^^^^^^^^^^^\n+   |\n+   = note: expected values for `feature` are: foo\n+\n+warning: unexpected `cfg` condition value\n+  --> $DIR/mix.rs:22:7\n    |\n LL | #[cfg(feature = \"zebra\")]\n    |       ^^^^^^^^^^^^^^^^^\n    |\n-   = note: expected values for `feature` are: bar, foo\n+   = note: expected values for `feature` are: foo\n \n warning: unexpected `cfg` condition name\n-  --> $DIR/mix.rs:25:12\n+  --> $DIR/mix.rs:26:12\n    |\n LL | #[cfg_attr(uu, test)]\n    |            ^^\n \n warning: unexpected `cfg` condition name\n-  --> $DIR/mix.rs:34:10\n+  --> $DIR/mix.rs:35:10\n    |\n LL |     cfg!(widnows);\n    |          ^^^^^^^ help: did you mean: `windows`\n \n warning: unexpected `cfg` condition value\n   --> $DIR/mix.rs:38:10\n    |\n+LL |     cfg!(feature = \"bar\");\n+   |          ^^^^^^^^^^^^^^^\n+   |\n+   = note: expected values for `feature` are: foo\n+\n+warning: unexpected `cfg` condition value\n+  --> $DIR/mix.rs:40:10\n+   |\n LL |     cfg!(feature = \"zebra\");\n    |          ^^^^^^^^^^^^^^^^^\n    |\n-   = note: expected values for `feature` are: bar, foo\n+   = note: expected values for `feature` are: foo\n \n warning: unexpected `cfg` condition name\n-  --> $DIR/mix.rs:40:10\n+  --> $DIR/mix.rs:42:10\n    |\n LL |     cfg!(xxx = \"foo\");\n    |          ^^^^^^^^^^^\n \n warning: unexpected `cfg` condition name\n-  --> $DIR/mix.rs:42:10\n+  --> $DIR/mix.rs:44:10\n    |\n LL |     cfg!(xxx);\n    |          ^^^\n \n warning: unexpected `cfg` condition name\n-  --> $DIR/mix.rs:44:14\n+  --> $DIR/mix.rs:46:14\n    |\n LL |     cfg!(any(xxx, windows));\n    |              ^^^\n \n warning: unexpected `cfg` condition value\n-  --> $DIR/mix.rs:46:14\n+  --> $DIR/mix.rs:48:14\n    |\n LL |     cfg!(any(feature = \"bad\", windows));\n-   |              ^^^^^^^^^^-----\n-   |                        |\n-   |                        help: did you mean: `\"bar\"`\n+   |              ^^^^^^^^^^^^^^^\n    |\n-   = note: expected values for `feature` are: bar, foo\n+   = note: expected values for `feature` are: foo\n \n warning: unexpected `cfg` condition name\n-  --> $DIR/mix.rs:48:23\n+  --> $DIR/mix.rs:50:23\n    |\n LL |     cfg!(any(windows, xxx));\n    |                       ^^^\n \n warning: unexpected `cfg` condition name\n-  --> $DIR/mix.rs:50:20\n+  --> $DIR/mix.rs:52:20\n    |\n LL |     cfg!(all(unix, xxx));\n    |                    ^^^\n \n warning: unexpected `cfg` condition name\n-  --> $DIR/mix.rs:52:14\n+  --> $DIR/mix.rs:54:14\n    |\n LL |     cfg!(all(aa, bb));\n    |              ^^\n \n warning: unexpected `cfg` condition name\n-  --> $DIR/mix.rs:52:18\n+  --> $DIR/mix.rs:54:18\n    |\n LL |     cfg!(all(aa, bb));\n    |                  ^^\n \n warning: unexpected `cfg` condition name\n-  --> $DIR/mix.rs:55:14\n+  --> $DIR/mix.rs:57:14\n    |\n LL |     cfg!(any(aa, bb));\n    |              ^^\n \n warning: unexpected `cfg` condition name\n-  --> $DIR/mix.rs:55:18\n+  --> $DIR/mix.rs:57:18\n    |\n LL |     cfg!(any(aa, bb));\n    |                  ^^\n \n warning: unexpected `cfg` condition value\n-  --> $DIR/mix.rs:58:20\n+  --> $DIR/mix.rs:60:20\n    |\n LL |     cfg!(any(unix, feature = \"zebra\"));\n    |                    ^^^^^^^^^^^^^^^^^\n    |\n-   = note: expected values for `feature` are: bar, foo\n+   = note: expected values for `feature` are: foo\n \n warning: unexpected `cfg` condition name\n-  --> $DIR/mix.rs:60:14\n+  --> $DIR/mix.rs:62:14\n    |\n LL |     cfg!(any(xxx, feature = \"zebra\"));\n    |              ^^^\n \n warning: unexpected `cfg` condition value\n-  --> $DIR/mix.rs:60:19\n+  --> $DIR/mix.rs:62:19\n    |\n LL |     cfg!(any(xxx, feature = \"zebra\"));\n    |                   ^^^^^^^^^^^^^^^^^\n    |\n-   = note: expected values for `feature` are: bar, foo\n+   = note: expected values for `feature` are: foo\n \n warning: unexpected `cfg` condition name\n-  --> $DIR/mix.rs:63:14\n+  --> $DIR/mix.rs:65:14\n    |\n LL |     cfg!(any(xxx, unix, xxx));\n    |              ^^^\n \n warning: unexpected `cfg` condition name\n-  --> $DIR/mix.rs:63:25\n+  --> $DIR/mix.rs:65:25\n    |\n LL |     cfg!(any(xxx, unix, xxx));\n    |                         ^^^\n \n warning: unexpected `cfg` condition value\n-  --> $DIR/mix.rs:66:14\n+  --> $DIR/mix.rs:68:14\n    |\n LL |     cfg!(all(feature = \"zebra\", feature = \"zebra\", feature = \"zebra\"));\n    |              ^^^^^^^^^^^^^^^^^\n    |\n-   = note: expected values for `feature` are: bar, foo\n+   = note: expected values for `feature` are: foo\n \n warning: unexpected `cfg` condition value\n-  --> $DIR/mix.rs:66:33\n+  --> $DIR/mix.rs:68:33\n    |\n LL |     cfg!(all(feature = \"zebra\", feature = \"zebra\", feature = \"zebra\"));\n    |                                 ^^^^^^^^^^^^^^^^^\n    |\n-   = note: expected values for `feature` are: bar, foo\n+   = note: expected values for `feature` are: foo\n \n warning: unexpected `cfg` condition value\n-  --> $DIR/mix.rs:66:52\n+  --> $DIR/mix.rs:68:52\n    |\n LL |     cfg!(all(feature = \"zebra\", feature = \"zebra\", feature = \"zebra\"));\n    |                                                    ^^^^^^^^^^^^^^^^^\n    |\n-   = note: expected values for `feature` are: bar, foo\n+   = note: expected values for `feature` are: foo\n \n-warning: 23 warnings emitted\n+warning: 25 warnings emitted\n "}, {"sha": "b1c7dc2a7f67297f2e108551b5f70e135ea7092a", "filename": "src/test/ui/did_you_mean/compatible-variants.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6423ab3a755fed97f75b2361849155d4e996d02f/src%2Ftest%2Fui%2Fdid_you_mean%2Fcompatible-variants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6423ab3a755fed97f75b2361849155d4e996d02f/src%2Ftest%2Fui%2Fdid_you_mean%2Fcompatible-variants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fcompatible-variants.rs?ref=6423ab3a755fed97f75b2361849155d4e996d02f", "patch": "@@ -66,7 +66,7 @@ fn main() {\n }\n \n enum A {\n-    B { b: B},\n+    B { b: B },\n }\n \n struct A2(B);\n@@ -77,13 +77,12 @@ enum B {\n }\n \n fn foo() {\n-    // We don't want to suggest `A::B(B::Fst)` here.\n     let a: A = B::Fst;\n     //~^ ERROR mismatched types\n+    //~| HELP try wrapping\n }\n \n fn bar() {\n-    // But we _do_ want to suggest `A2(B::Fst)` here!\n     let a: A2 = B::Fst;\n     //~^ ERROR mismatched types\n     //~| HELP try wrapping"}, {"sha": "fe81da19833a7e2baba18c922b3c834d8578aea6", "filename": "src/test/ui/did_you_mean/compatible-variants.stderr", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6423ab3a755fed97f75b2361849155d4e996d02f/src%2Ftest%2Fui%2Fdid_you_mean%2Fcompatible-variants.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6423ab3a755fed97f75b2361849155d4e996d02f/src%2Ftest%2Fui%2Fdid_you_mean%2Fcompatible-variants.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fcompatible-variants.stderr?ref=6423ab3a755fed97f75b2361849155d4e996d02f", "patch": "@@ -191,15 +191,20 @@ LL |     let _ = Foo { bar: Some(bar) };\n    |                   ++++++++++   +\n \n error[E0308]: mismatched types\n-  --> $DIR/compatible-variants.rs:81:16\n+  --> $DIR/compatible-variants.rs:80:16\n    |\n LL |     let a: A = B::Fst;\n    |            -   ^^^^^^ expected enum `A`, found enum `B`\n    |            |\n    |            expected due to this\n+   |\n+help: try wrapping the expression in `A::B`\n+   |\n+LL |     let a: A = A::B { b: B::Fst };\n+   |                +++++++++        +\n \n error[E0308]: mismatched types\n-  --> $DIR/compatible-variants.rs:87:17\n+  --> $DIR/compatible-variants.rs:86:17\n    |\n LL |     let a: A2 = B::Fst;\n    |            --   ^^^^^^ expected struct `A2`, found enum `B`"}, {"sha": "eb96c2480630eb140f8fe135cac027b34678056b", "filename": "src/test/ui/did_you_mean/issue-42764.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6423ab3a755fed97f75b2361849155d4e996d02f/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-42764.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6423ab3a755fed97f75b2361849155d4e996d02f/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-42764.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-42764.rs?ref=6423ab3a755fed97f75b2361849155d4e996d02f", "patch": "@@ -26,4 +26,5 @@ struct Context { wrapper: Wrapper }\n fn overton() {\n     let _c = Context { wrapper: Payload{} };\n     //~^ ERROR mismatched types\n+    //~| try wrapping the expression in `Wrapper`\n }"}, {"sha": "6a7fd8fe251dc16c06e50e2ff5f0db20780036a8", "filename": "src/test/ui/did_you_mean/issue-42764.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6423ab3a755fed97f75b2361849155d4e996d02f/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-42764.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6423ab3a755fed97f75b2361849155d4e996d02f/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-42764.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-42764.stderr?ref=6423ab3a755fed97f75b2361849155d4e996d02f", "patch": "@@ -25,6 +25,11 @@ error[E0308]: mismatched types\n    |\n LL |     let _c = Context { wrapper: Payload{} };\n    |                                 ^^^^^^^^^ expected struct `Wrapper`, found struct `Payload`\n+   |\n+help: try wrapping the expression in `Wrapper`\n+   |\n+LL |     let _c = Context { wrapper: Wrapper { payload: Payload{} } };\n+   |                                 ++++++++++++++++++           +\n \n error: aborting due to 2 previous errors\n "}, {"sha": "c5e1c41d1304c0515dd3ad359e8963754a4fefbe", "filename": "src/test/ui/layout/debug.stderr", "status": "modified", "additions": 121, "deletions": 121, "changes": 242, "blob_url": "https://github.com/rust-lang/rust/blob/6423ab3a755fed97f75b2361849155d4e996d02f/src%2Ftest%2Fui%2Flayout%2Fdebug.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6423ab3a755fed97f75b2361849155d4e996d02f/src%2Ftest%2Fui%2Flayout%2Fdebug.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flayout%2Fdebug.stderr?ref=6423ab3a755fed97f75b2361849155d4e996d02f", "patch": "@@ -1,4 +1,12 @@\n error: layout_of(E) = Layout {\n+           size: Size(12 bytes),\n+           align: AbiAndPrefAlign {\n+               abi: Align(4 bytes),\n+               pref: $PREF_ALIGN,\n+           },\n+           abi: Aggregate {\n+               sized: true,\n+           },\n            fields: Arbitrary {\n                offsets: [\n                    Size(0 bytes),\n@@ -7,6 +15,16 @@ error: layout_of(E) = Layout {\n                    0,\n                ],\n            },\n+           largest_niche: Some(\n+               Niche {\n+                   offset: Size(0 bytes),\n+                   value: Int(\n+                       I32,\n+                       false,\n+                   ),\n+                   valid_range: 0..=0,\n+               },\n+           ),\n            variants: Multiple {\n                tag: Initialized {\n                    value: Int(\n@@ -19,24 +37,30 @@ error: layout_of(E) = Layout {\n                tag_field: 0,\n                variants: [\n                    Layout {\n+                       size: Size(4 bytes),\n+                       align: AbiAndPrefAlign {\n+                           abi: Align(1 bytes),\n+                           pref: $PREF_ALIGN,\n+                       },\n+                       abi: Aggregate {\n+                           sized: true,\n+                       },\n                        fields: Arbitrary {\n                            offsets: [],\n                            memory_index: [],\n                        },\n+                       largest_niche: None,\n                        variants: Single {\n                            index: 0,\n                        },\n-                       abi: Aggregate {\n-                           sized: true,\n-                       },\n-                       largest_niche: None,\n+                   },\n+                   Layout {\n+                       size: Size(12 bytes),\n                        align: AbiAndPrefAlign {\n-                           abi: Align(1 bytes),\n+                           abi: Align(4 bytes),\n                            pref: $PREF_ALIGN,\n                        },\n-                       size: Size(4 bytes),\n-                   },\n-                   Layout {\n+                       abi: Uninhabited,\n                        fields: Arbitrary {\n                            offsets: [\n                                Size(4 bytes),\n@@ -49,58 +73,24 @@ error: layout_of(E) = Layout {\n                                2,\n                            ],\n                        },\n+                       largest_niche: None,\n                        variants: Single {\n                            index: 1,\n                        },\n-                       abi: Uninhabited,\n-                       largest_niche: None,\n-                       align: AbiAndPrefAlign {\n-                           abi: Align(4 bytes),\n-                           pref: $PREF_ALIGN,\n-                       },\n-                       size: Size(12 bytes),\n                    },\n                ],\n            },\n-           abi: Aggregate {\n-               sized: true,\n-           },\n-           largest_niche: Some(\n-               Niche {\n-                   offset: Size(0 bytes),\n-                   value: Int(\n-                       I32,\n-                       false,\n-                   ),\n-                   valid_range: 0..=0,\n-               },\n-           ),\n-           align: AbiAndPrefAlign {\n-               abi: Align(4 bytes),\n-               pref: $PREF_ALIGN,\n-           },\n-           size: Size(12 bytes),\n        }\n   --> $DIR/debug.rs:6:1\n    |\n LL | enum E { Foo, Bar(!, i32, i32) }\n    | ^^^^^^\n \n error: layout_of(S) = Layout {\n-           fields: Arbitrary {\n-               offsets: [\n-                   Size(0 bytes),\n-                   Size(0 bytes),\n-                   Size(4 bytes),\n-               ],\n-               memory_index: [\n-                   1,\n-                   0,\n-                   2,\n-               ],\n-           },\n-           variants: Single {\n-               index: 0,\n+           size: Size(8 bytes),\n+           align: AbiAndPrefAlign {\n+               abi: Align(4 bytes),\n+               pref: $PREF_ALIGN,\n            },\n            abi: ScalarPair(\n                Initialized {\n@@ -118,41 +108,72 @@ error: layout_of(S) = Layout {\n                    valid_range: 0..=4294967295,\n                },\n            ),\n+           fields: Arbitrary {\n+               offsets: [\n+                   Size(0 bytes),\n+                   Size(0 bytes),\n+                   Size(4 bytes),\n+               ],\n+               memory_index: [\n+                   1,\n+                   0,\n+                   2,\n+               ],\n+           },\n            largest_niche: None,\n-           align: AbiAndPrefAlign {\n-               abi: Align(4 bytes),\n-               pref: $PREF_ALIGN,\n+           variants: Single {\n+               index: 0,\n            },\n-           size: Size(8 bytes),\n        }\n   --> $DIR/debug.rs:9:1\n    |\n LL | struct S { f1: i32, f2: (), f3: i32 }\n    | ^^^^^^^^\n \n error: layout_of(U) = Layout {\n-           fields: Union(\n-               2,\n-           ),\n-           variants: Single {\n-               index: 0,\n+           size: Size(8 bytes),\n+           align: AbiAndPrefAlign {\n+               abi: Align(4 bytes),\n+               pref: $PREF_ALIGN,\n            },\n            abi: Aggregate {\n                sized: true,\n            },\n+           fields: Union(\n+               2,\n+           ),\n            largest_niche: None,\n-           align: AbiAndPrefAlign {\n-               abi: Align(4 bytes),\n-               pref: $PREF_ALIGN,\n+           variants: Single {\n+               index: 0,\n            },\n-           size: Size(8 bytes),\n        }\n   --> $DIR/debug.rs:12:1\n    |\n LL | union U { f1: (i32, i32), f3: i32 }\n    | ^^^^^^^\n \n error: layout_of(std::result::Result<i32, i32>) = Layout {\n+           size: Size(8 bytes),\n+           align: AbiAndPrefAlign {\n+               abi: Align(4 bytes),\n+               pref: $PREF_ALIGN,\n+           },\n+           abi: ScalarPair(\n+               Initialized {\n+                   value: Int(\n+                       I32,\n+                       false,\n+                   ),\n+                   valid_range: 0..=1,\n+               },\n+               Initialized {\n+                   value: Int(\n+                       I32,\n+                       true,\n+                   ),\n+                   valid_range: 0..=4294967295,\n+               },\n+           ),\n            fields: Arbitrary {\n                offsets: [\n                    Size(0 bytes),\n@@ -161,6 +182,16 @@ error: layout_of(std::result::Result<i32, i32>) = Layout {\n                    0,\n                ],\n            },\n+           largest_niche: Some(\n+               Niche {\n+                   offset: Size(0 bytes),\n+                   value: Int(\n+                       I32,\n+                       false,\n+                   ),\n+                   valid_range: 0..=1,\n+               },\n+           ),\n            variants: Multiple {\n                tag: Initialized {\n                    value: Int(\n@@ -173,16 +204,10 @@ error: layout_of(std::result::Result<i32, i32>) = Layout {\n                tag_field: 0,\n                variants: [\n                    Layout {\n-                       fields: Arbitrary {\n-                           offsets: [\n-                               Size(4 bytes),\n-                           ],\n-                           memory_index: [\n-                               0,\n-                           ],\n-                       },\n-                       variants: Single {\n-                           index: 0,\n+                       size: Size(8 bytes),\n+                       align: AbiAndPrefAlign {\n+                           abi: Align(4 bytes),\n+                           pref: $PREF_ALIGN,\n                        },\n                        abi: ScalarPair(\n                            Initialized {\n@@ -200,14 +225,6 @@ error: layout_of(std::result::Result<i32, i32>) = Layout {\n                                valid_range: 0..=4294967295,\n                            },\n                        ),\n-                       largest_niche: None,\n-                       align: AbiAndPrefAlign {\n-                           abi: Align(4 bytes),\n-                           pref: $PREF_ALIGN,\n-                       },\n-                       size: Size(8 bytes),\n-                   },\n-                   Layout {\n                        fields: Arbitrary {\n                            offsets: [\n                                Size(4 bytes),\n@@ -216,8 +233,16 @@ error: layout_of(std::result::Result<i32, i32>) = Layout {\n                                0,\n                            ],\n                        },\n+                       largest_niche: None,\n                        variants: Single {\n-                           index: 1,\n+                           index: 0,\n+                       },\n+                   },\n+                   Layout {\n+                       size: Size(8 bytes),\n+                       align: AbiAndPrefAlign {\n+                           abi: Align(4 bytes),\n+                           pref: $PREF_ALIGN,\n                        },\n                        abi: ScalarPair(\n                            Initialized {\n@@ -235,56 +260,32 @@ error: layout_of(std::result::Result<i32, i32>) = Layout {\n                                valid_range: 0..=4294967295,\n                            },\n                        ),\n+                       fields: Arbitrary {\n+                           offsets: [\n+                               Size(4 bytes),\n+                           ],\n+                           memory_index: [\n+                               0,\n+                           ],\n+                       },\n                        largest_niche: None,\n-                       align: AbiAndPrefAlign {\n-                           abi: Align(4 bytes),\n-                           pref: $PREF_ALIGN,\n+                       variants: Single {\n+                           index: 1,\n                        },\n-                       size: Size(8 bytes),\n                    },\n                ],\n            },\n-           abi: ScalarPair(\n-               Initialized {\n-                   value: Int(\n-                       I32,\n-                       false,\n-                   ),\n-                   valid_range: 0..=1,\n-               },\n-               Initialized {\n-                   value: Int(\n-                       I32,\n-                       true,\n-                   ),\n-                   valid_range: 0..=4294967295,\n-               },\n-           ),\n-           largest_niche: Some(\n-               Niche {\n-                   offset: Size(0 bytes),\n-                   value: Int(\n-                       I32,\n-                       false,\n-                   ),\n-                   valid_range: 0..=1,\n-               },\n-           ),\n-           align: AbiAndPrefAlign {\n-               abi: Align(4 bytes),\n-               pref: $PREF_ALIGN,\n-           },\n-           size: Size(8 bytes),\n        }\n   --> $DIR/debug.rs:15:1\n    |\n LL | type Test = Result<i32, i32>;\n    | ^^^^^^^^^\n \n error: layout_of(i32) = Layout {\n-           fields: Primitive,\n-           variants: Single {\n-               index: 0,\n+           size: Size(4 bytes),\n+           align: AbiAndPrefAlign {\n+               abi: Align(4 bytes),\n+               pref: $PREF_ALIGN,\n            },\n            abi: Scalar(\n                Initialized {\n@@ -295,12 +296,11 @@ error: layout_of(i32) = Layout {\n                    valid_range: 0..=4294967295,\n                },\n            ),\n+           fields: Primitive,\n            largest_niche: None,\n-           align: AbiAndPrefAlign {\n-               abi: Align(4 bytes),\n-               pref: $PREF_ALIGN,\n+           variants: Single {\n+               index: 0,\n            },\n-           size: Size(4 bytes),\n        }\n   --> $DIR/debug.rs:18:1\n    |"}, {"sha": "d850dd69c96e3a6f7b8413fd19a38a561a90d832", "filename": "src/test/ui/layout/hexagon-enum.stderr", "status": "modified", "additions": 163, "deletions": 163, "changes": 326, "blob_url": "https://github.com/rust-lang/rust/blob/6423ab3a755fed97f75b2361849155d4e996d02f/src%2Ftest%2Fui%2Flayout%2Fhexagon-enum.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6423ab3a755fed97f75b2361849155d4e996d02f/src%2Ftest%2Fui%2Flayout%2Fhexagon-enum.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flayout%2Fhexagon-enum.stderr?ref=6423ab3a755fed97f75b2361849155d4e996d02f", "patch": "@@ -1,4 +1,18 @@\n error: layout_of(A) = Layout {\n+           size: Size(1 bytes),\n+           align: AbiAndPrefAlign {\n+               abi: Align(1 bytes),\n+               pref: Align(1 bytes),\n+           },\n+           abi: Scalar(\n+               Initialized {\n+                   value: Int(\n+                       I8,\n+                       false,\n+                   ),\n+                   valid_range: 0..=0,\n+               },\n+           ),\n            fields: Arbitrary {\n                offsets: [\n                    Size(0 bytes),\n@@ -7,6 +21,16 @@ error: layout_of(A) = Layout {\n                    0,\n                ],\n            },\n+           largest_niche: Some(\n+               Niche {\n+                   offset: Size(0 bytes),\n+                   value: Int(\n+                       I8,\n+                       false,\n+                   ),\n+                   valid_range: 0..=0,\n+               },\n+           ),\n            variants: Multiple {\n                tag: Initialized {\n                    value: Int(\n@@ -19,64 +43,64 @@ error: layout_of(A) = Layout {\n                tag_field: 0,\n                variants: [\n                    Layout {\n+                       size: Size(1 bytes),\n+                       align: AbiAndPrefAlign {\n+                           abi: Align(1 bytes),\n+                           pref: Align(1 bytes),\n+                       },\n+                       abi: Aggregate {\n+                           sized: true,\n+                       },\n                        fields: Arbitrary {\n                            offsets: [],\n                            memory_index: [],\n                        },\n+                       largest_niche: None,\n                        variants: Single {\n                            index: 0,\n                        },\n-                       abi: Aggregate {\n-                           sized: true,\n-                       },\n-                       largest_niche: None,\n-                       align: AbiAndPrefAlign {\n-                           abi: Align(1 bytes),\n-                           pref: Align(1 bytes),\n-                       },\n-                       size: Size(1 bytes),\n                    },\n                ],\n            },\n+       }\n+  --> $DIR/hexagon-enum.rs:16:1\n+   |\n+LL | enum A { Apple }\n+   | ^^^^^^\n+\n+error: layout_of(B) = Layout {\n+           size: Size(1 bytes),\n+           align: AbiAndPrefAlign {\n+               abi: Align(1 bytes),\n+               pref: Align(1 bytes),\n+           },\n            abi: Scalar(\n                Initialized {\n                    value: Int(\n                        I8,\n                        false,\n                    ),\n-                   valid_range: 0..=0,\n+                   valid_range: 255..=255,\n                },\n            ),\n+           fields: Arbitrary {\n+               offsets: [\n+                   Size(0 bytes),\n+               ],\n+               memory_index: [\n+                   0,\n+               ],\n+           },\n            largest_niche: Some(\n                Niche {\n                    offset: Size(0 bytes),\n                    value: Int(\n                        I8,\n                        false,\n                    ),\n-                   valid_range: 0..=0,\n+                   valid_range: 255..=255,\n                },\n            ),\n-           align: AbiAndPrefAlign {\n-               abi: Align(1 bytes),\n-               pref: Align(1 bytes),\n-           },\n-           size: Size(1 bytes),\n-       }\n-  --> $DIR/hexagon-enum.rs:16:1\n-   |\n-LL | enum A { Apple }\n-   | ^^^^^^\n-\n-error: layout_of(B) = Layout {\n-           fields: Arbitrary {\n-               offsets: [\n-                   Size(0 bytes),\n-               ],\n-               memory_index: [\n-                   0,\n-               ],\n-           },\n            variants: Multiple {\n                tag: Initialized {\n                    value: Int(\n@@ -89,56 +113,46 @@ error: layout_of(B) = Layout {\n                tag_field: 0,\n                variants: [\n                    Layout {\n+                       size: Size(1 bytes),\n+                       align: AbiAndPrefAlign {\n+                           abi: Align(1 bytes),\n+                           pref: Align(1 bytes),\n+                       },\n+                       abi: Aggregate {\n+                           sized: true,\n+                       },\n                        fields: Arbitrary {\n                            offsets: [],\n                            memory_index: [],\n                        },\n+                       largest_niche: None,\n                        variants: Single {\n                            index: 0,\n                        },\n-                       abi: Aggregate {\n-                           sized: true,\n-                       },\n-                       largest_niche: None,\n-                       align: AbiAndPrefAlign {\n-                           abi: Align(1 bytes),\n-                           pref: Align(1 bytes),\n-                       },\n-                       size: Size(1 bytes),\n                    },\n                ],\n            },\n-           abi: Scalar(\n-               Initialized {\n-                   value: Int(\n-                       I8,\n-                       false,\n-                   ),\n-                   valid_range: 255..=255,\n-               },\n-           ),\n-           largest_niche: Some(\n-               Niche {\n-                   offset: Size(0 bytes),\n-                   value: Int(\n-                       I8,\n-                       false,\n-                   ),\n-                   valid_range: 255..=255,\n-               },\n-           ),\n-           align: AbiAndPrefAlign {\n-               abi: Align(1 bytes),\n-               pref: Align(1 bytes),\n-           },\n-           size: Size(1 bytes),\n        }\n   --> $DIR/hexagon-enum.rs:20:1\n    |\n LL | enum B { Banana = 255, }\n    | ^^^^^^\n \n error: layout_of(C) = Layout {\n+           size: Size(2 bytes),\n+           align: AbiAndPrefAlign {\n+               abi: Align(2 bytes),\n+               pref: Align(2 bytes),\n+           },\n+           abi: Scalar(\n+               Initialized {\n+                   value: Int(\n+                       I16,\n+                       false,\n+                   ),\n+                   valid_range: 256..=256,\n+               },\n+           ),\n            fields: Arbitrary {\n                offsets: [\n                    Size(0 bytes),\n@@ -147,6 +161,16 @@ error: layout_of(C) = Layout {\n                    0,\n                ],\n            },\n+           largest_niche: Some(\n+               Niche {\n+                   offset: Size(0 bytes),\n+                   value: Int(\n+                       I16,\n+                       false,\n+                   ),\n+                   valid_range: 256..=256,\n+               },\n+           ),\n            variants: Multiple {\n                tag: Initialized {\n                    value: Int(\n@@ -159,56 +183,46 @@ error: layout_of(C) = Layout {\n                tag_field: 0,\n                variants: [\n                    Layout {\n+                       size: Size(2 bytes),\n+                       align: AbiAndPrefAlign {\n+                           abi: Align(2 bytes),\n+                           pref: Align(2 bytes),\n+                       },\n+                       abi: Aggregate {\n+                           sized: true,\n+                       },\n                        fields: Arbitrary {\n                            offsets: [],\n                            memory_index: [],\n                        },\n+                       largest_niche: None,\n                        variants: Single {\n                            index: 0,\n                        },\n-                       abi: Aggregate {\n-                           sized: true,\n-                       },\n-                       largest_niche: None,\n-                       align: AbiAndPrefAlign {\n-                           abi: Align(2 bytes),\n-                           pref: Align(2 bytes),\n-                       },\n-                       size: Size(2 bytes),\n                    },\n                ],\n            },\n-           abi: Scalar(\n-               Initialized {\n-                   value: Int(\n-                       I16,\n-                       false,\n-                   ),\n-                   valid_range: 256..=256,\n-               },\n-           ),\n-           largest_niche: Some(\n-               Niche {\n-                   offset: Size(0 bytes),\n-                   value: Int(\n-                       I16,\n-                       false,\n-                   ),\n-                   valid_range: 256..=256,\n-               },\n-           ),\n-           align: AbiAndPrefAlign {\n-               abi: Align(2 bytes),\n-               pref: Align(2 bytes),\n-           },\n-           size: Size(2 bytes),\n        }\n   --> $DIR/hexagon-enum.rs:24:1\n    |\n LL | enum C { Chaenomeles = 256, }\n    | ^^^^^^\n \n error: layout_of(P) = Layout {\n+           size: Size(4 bytes),\n+           align: AbiAndPrefAlign {\n+               abi: Align(4 bytes),\n+               pref: Align(4 bytes),\n+           },\n+           abi: Scalar(\n+               Initialized {\n+                   value: Int(\n+                       I32,\n+                       false,\n+                   ),\n+                   valid_range: 268435456..=268435456,\n+               },\n+           ),\n            fields: Arbitrary {\n                offsets: [\n                    Size(0 bytes),\n@@ -217,6 +231,16 @@ error: layout_of(P) = Layout {\n                    0,\n                ],\n            },\n+           largest_niche: Some(\n+               Niche {\n+                   offset: Size(0 bytes),\n+                   value: Int(\n+                       I32,\n+                       false,\n+                   ),\n+                   valid_range: 268435456..=268435456,\n+               },\n+           ),\n            variants: Multiple {\n                tag: Initialized {\n                    value: Int(\n@@ -229,56 +253,46 @@ error: layout_of(P) = Layout {\n                tag_field: 0,\n                variants: [\n                    Layout {\n+                       size: Size(4 bytes),\n+                       align: AbiAndPrefAlign {\n+                           abi: Align(4 bytes),\n+                           pref: Align(4 bytes),\n+                       },\n+                       abi: Aggregate {\n+                           sized: true,\n+                       },\n                        fields: Arbitrary {\n                            offsets: [],\n                            memory_index: [],\n                        },\n+                       largest_niche: None,\n                        variants: Single {\n                            index: 0,\n                        },\n-                       abi: Aggregate {\n-                           sized: true,\n-                       },\n-                       largest_niche: None,\n-                       align: AbiAndPrefAlign {\n-                           abi: Align(4 bytes),\n-                           pref: Align(4 bytes),\n-                       },\n-                       size: Size(4 bytes),\n                    },\n                ],\n            },\n-           abi: Scalar(\n-               Initialized {\n-                   value: Int(\n-                       I32,\n-                       false,\n-                   ),\n-                   valid_range: 268435456..=268435456,\n-               },\n-           ),\n-           largest_niche: Some(\n-               Niche {\n-                   offset: Size(0 bytes),\n-                   value: Int(\n-                       I32,\n-                       false,\n-                   ),\n-                   valid_range: 268435456..=268435456,\n-               },\n-           ),\n-           align: AbiAndPrefAlign {\n-               abi: Align(4 bytes),\n-               pref: Align(4 bytes),\n-           },\n-           size: Size(4 bytes),\n        }\n   --> $DIR/hexagon-enum.rs:28:1\n    |\n LL | enum P { Peach = 0x1000_0000isize, }\n    | ^^^^^^\n \n error: layout_of(T) = Layout {\n+           size: Size(4 bytes),\n+           align: AbiAndPrefAlign {\n+               abi: Align(4 bytes),\n+               pref: Align(4 bytes),\n+           },\n+           abi: Scalar(\n+               Initialized {\n+                   value: Int(\n+                       I32,\n+                       true,\n+                   ),\n+                   valid_range: 2164260864..=2164260864,\n+               },\n+           ),\n            fields: Arbitrary {\n                offsets: [\n                    Size(0 bytes),\n@@ -287,6 +301,16 @@ error: layout_of(T) = Layout {\n                    0,\n                ],\n            },\n+           largest_niche: Some(\n+               Niche {\n+                   offset: Size(0 bytes),\n+                   value: Int(\n+                       I32,\n+                       true,\n+                   ),\n+                   valid_range: 2164260864..=2164260864,\n+               },\n+           ),\n            variants: Multiple {\n                tag: Initialized {\n                    value: Int(\n@@ -299,49 +323,25 @@ error: layout_of(T) = Layout {\n                tag_field: 0,\n                variants: [\n                    Layout {\n+                       size: Size(4 bytes),\n+                       align: AbiAndPrefAlign {\n+                           abi: Align(4 bytes),\n+                           pref: Align(4 bytes),\n+                       },\n+                       abi: Aggregate {\n+                           sized: true,\n+                       },\n                        fields: Arbitrary {\n                            offsets: [],\n                            memory_index: [],\n                        },\n+                       largest_niche: None,\n                        variants: Single {\n                            index: 0,\n                        },\n-                       abi: Aggregate {\n-                           sized: true,\n-                       },\n-                       largest_niche: None,\n-                       align: AbiAndPrefAlign {\n-                           abi: Align(4 bytes),\n-                           pref: Align(4 bytes),\n-                       },\n-                       size: Size(4 bytes),\n                    },\n                ],\n            },\n-           abi: Scalar(\n-               Initialized {\n-                   value: Int(\n-                       I32,\n-                       true,\n-                   ),\n-                   valid_range: 2164260864..=2164260864,\n-               },\n-           ),\n-           largest_niche: Some(\n-               Niche {\n-                   offset: Size(0 bytes),\n-                   value: Int(\n-                       I32,\n-                       true,\n-                   ),\n-                   valid_range: 2164260864..=2164260864,\n-               },\n-           ),\n-           align: AbiAndPrefAlign {\n-               abi: Align(4 bytes),\n-               pref: Align(4 bytes),\n-           },\n-           size: Size(4 bytes),\n        }\n   --> $DIR/hexagon-enum.rs:34:1\n    |"}, {"sha": "6deb1f271a72870f21157ff37e12dafa1d9615e7", "filename": "src/test/ui/layout/issue-96158-scalarpair-payload-might-be-uninit.stderr", "status": "modified", "additions": 248, "deletions": 248, "changes": 496, "blob_url": "https://github.com/rust-lang/rust/blob/6423ab3a755fed97f75b2361849155d4e996d02f/src%2Ftest%2Fui%2Flayout%2Fissue-96158-scalarpair-payload-might-be-uninit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6423ab3a755fed97f75b2361849155d4e996d02f/src%2Ftest%2Fui%2Flayout%2Fissue-96158-scalarpair-payload-might-be-uninit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flayout%2Fissue-96158-scalarpair-payload-might-be-uninit.stderr?ref=6423ab3a755fed97f75b2361849155d4e996d02f", "patch": "@@ -1,4 +1,24 @@\n error: layout_of(MissingPayloadField) = Layout {\n+           size: Size(2 bytes),\n+           align: AbiAndPrefAlign {\n+               abi: Align(1 bytes),\n+               pref: $PREF_ALIGN,\n+           },\n+           abi: ScalarPair(\n+               Initialized {\n+                   value: Int(\n+                       I8,\n+                       false,\n+                   ),\n+                   valid_range: 0..=1,\n+               },\n+               Union {\n+                   value: Int(\n+                       I8,\n+                       false,\n+                   ),\n+               },\n+           ),\n            fields: Arbitrary {\n                offsets: [\n                    Size(0 bytes),\n@@ -7,6 +27,16 @@ error: layout_of(MissingPayloadField) = Layout {\n                    0,\n                ],\n            },\n+           largest_niche: Some(\n+               Niche {\n+                   offset: Size(0 bytes),\n+                   value: Int(\n+                       I8,\n+                       false,\n+                   ),\n+                   valid_range: 0..=1,\n+               },\n+           ),\n            variants: Multiple {\n                tag: Initialized {\n                    value: Int(\n@@ -19,16 +49,10 @@ error: layout_of(MissingPayloadField) = Layout {\n                tag_field: 0,\n                variants: [\n                    Layout {\n-                       fields: Arbitrary {\n-                           offsets: [\n-                               Size(1 bytes),\n-                           ],\n-                           memory_index: [\n-                               0,\n-                           ],\n-                       },\n-                       variants: Single {\n-                           index: 0,\n+                       size: Size(2 bytes),\n+                       align: AbiAndPrefAlign {\n+                           abi: Align(1 bytes),\n+                           pref: $PREF_ALIGN,\n                        },\n                        abi: ScalarPair(\n                            Initialized {\n@@ -45,33 +69,51 @@ error: layout_of(MissingPayloadField) = Layout {\n                                ),\n                            },\n                        ),\n+                       fields: Arbitrary {\n+                           offsets: [\n+                               Size(1 bytes),\n+                           ],\n+                           memory_index: [\n+                               0,\n+                           ],\n+                       },\n                        largest_niche: None,\n+                       variants: Single {\n+                           index: 0,\n+                       },\n+                   },\n+                   Layout {\n+                       size: Size(1 bytes),\n                        align: AbiAndPrefAlign {\n                            abi: Align(1 bytes),\n                            pref: $PREF_ALIGN,\n                        },\n-                       size: Size(2 bytes),\n-                   },\n-                   Layout {\n+                       abi: Aggregate {\n+                           sized: true,\n+                       },\n                        fields: Arbitrary {\n                            offsets: [],\n                            memory_index: [],\n                        },\n+                       largest_niche: None,\n                        variants: Single {\n                            index: 1,\n                        },\n-                       abi: Aggregate {\n-                           sized: true,\n-                       },\n-                       largest_niche: None,\n-                       align: AbiAndPrefAlign {\n-                           abi: Align(1 bytes),\n-                           pref: $PREF_ALIGN,\n-                       },\n-                       size: Size(1 bytes),\n                    },\n                ],\n            },\n+       }\n+  --> $DIR/issue-96158-scalarpair-payload-might-be-uninit.rs:16:1\n+   |\n+LL | pub enum MissingPayloadField {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: layout_of(CommonPayloadField) = Layout {\n+           size: Size(2 bytes),\n+           align: AbiAndPrefAlign {\n+               abi: Align(1 bytes),\n+               pref: $PREF_ALIGN,\n+           },\n            abi: ScalarPair(\n                Initialized {\n                    value: Int(\n@@ -80,13 +122,22 @@ error: layout_of(MissingPayloadField) = Layout {\n                    ),\n                    valid_range: 0..=1,\n                },\n-               Union {\n+               Initialized {\n                    value: Int(\n                        I8,\n                        false,\n                    ),\n+                   valid_range: 0..=255,\n                },\n            ),\n+           fields: Arbitrary {\n+               offsets: [\n+                   Size(0 bytes),\n+               ],\n+               memory_index: [\n+                   0,\n+               ],\n+           },\n            largest_niche: Some(\n                Niche {\n                    offset: Size(0 bytes),\n@@ -97,26 +148,6 @@ error: layout_of(MissingPayloadField) = Layout {\n                    valid_range: 0..=1,\n                },\n            ),\n-           align: AbiAndPrefAlign {\n-               abi: Align(1 bytes),\n-               pref: $PREF_ALIGN,\n-           },\n-           size: Size(2 bytes),\n-       }\n-  --> $DIR/issue-96158-scalarpair-payload-might-be-uninit.rs:16:1\n-   |\n-LL | pub enum MissingPayloadField {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-error: layout_of(CommonPayloadField) = Layout {\n-           fields: Arbitrary {\n-               offsets: [\n-                   Size(0 bytes),\n-               ],\n-               memory_index: [\n-                   0,\n-               ],\n-           },\n            variants: Multiple {\n                tag: Initialized {\n                    value: Int(\n@@ -129,16 +160,10 @@ error: layout_of(CommonPayloadField) = Layout {\n                tag_field: 0,\n                variants: [\n                    Layout {\n-                       fields: Arbitrary {\n-                           offsets: [\n-                               Size(1 bytes),\n-                           ],\n-                           memory_index: [\n-                               0,\n-                           ],\n-                       },\n-                       variants: Single {\n-                           index: 0,\n+                       size: Size(2 bytes),\n+                       align: AbiAndPrefAlign {\n+                           abi: Align(1 bytes),\n+                           pref: $PREF_ALIGN,\n                        },\n                        abi: ScalarPair(\n                            Initialized {\n@@ -156,14 +181,6 @@ error: layout_of(CommonPayloadField) = Layout {\n                                valid_range: 0..=255,\n                            },\n                        ),\n-                       largest_niche: None,\n-                       align: AbiAndPrefAlign {\n-                           abi: Align(1 bytes),\n-                           pref: $PREF_ALIGN,\n-                       },\n-                       size: Size(2 bytes),\n-                   },\n-                   Layout {\n                        fields: Arbitrary {\n                            offsets: [\n                                Size(1 bytes),\n@@ -172,8 +189,16 @@ error: layout_of(CommonPayloadField) = Layout {\n                                0,\n                            ],\n                        },\n+                       largest_niche: None,\n                        variants: Single {\n-                           index: 1,\n+                           index: 0,\n+                       },\n+                   },\n+                   Layout {\n+                       size: Size(2 bytes),\n+                       align: AbiAndPrefAlign {\n+                           abi: Align(1 bytes),\n+                           pref: $PREF_ALIGN,\n                        },\n                        abi: ScalarPair(\n                            Initialized {\n@@ -191,15 +216,33 @@ error: layout_of(CommonPayloadField) = Layout {\n                                valid_range: 0..=255,\n                            },\n                        ),\n+                       fields: Arbitrary {\n+                           offsets: [\n+                               Size(1 bytes),\n+                           ],\n+                           memory_index: [\n+                               0,\n+                           ],\n+                       },\n                        largest_niche: None,\n-                       align: AbiAndPrefAlign {\n-                           abi: Align(1 bytes),\n-                           pref: $PREF_ALIGN,\n+                       variants: Single {\n+                           index: 1,\n                        },\n-                       size: Size(2 bytes),\n                    },\n                ],\n            },\n+       }\n+  --> $DIR/issue-96158-scalarpair-payload-might-be-uninit.rs:25:1\n+   |\n+LL | pub enum CommonPayloadField {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: layout_of(CommonPayloadFieldIsMaybeUninit) = Layout {\n+           size: Size(2 bytes),\n+           align: AbiAndPrefAlign {\n+               abi: Align(1 bytes),\n+               pref: $PREF_ALIGN,\n+           },\n            abi: ScalarPair(\n                Initialized {\n                    value: Int(\n@@ -208,14 +251,21 @@ error: layout_of(CommonPayloadField) = Layout {\n                    ),\n                    valid_range: 0..=1,\n                },\n-               Initialized {\n+               Union {\n                    value: Int(\n                        I8,\n                        false,\n                    ),\n-                   valid_range: 0..=255,\n                },\n            ),\n+           fields: Arbitrary {\n+               offsets: [\n+                   Size(0 bytes),\n+               ],\n+               memory_index: [\n+                   0,\n+               ],\n+           },\n            largest_niche: Some(\n                Niche {\n                    offset: Size(0 bytes),\n@@ -226,26 +276,6 @@ error: layout_of(CommonPayloadField) = Layout {\n                    valid_range: 0..=1,\n                },\n            ),\n-           align: AbiAndPrefAlign {\n-               abi: Align(1 bytes),\n-               pref: $PREF_ALIGN,\n-           },\n-           size: Size(2 bytes),\n-       }\n-  --> $DIR/issue-96158-scalarpair-payload-might-be-uninit.rs:25:1\n-   |\n-LL | pub enum CommonPayloadField {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-error: layout_of(CommonPayloadFieldIsMaybeUninit) = Layout {\n-           fields: Arbitrary {\n-               offsets: [\n-                   Size(0 bytes),\n-               ],\n-               memory_index: [\n-                   0,\n-               ],\n-           },\n            variants: Multiple {\n                tag: Initialized {\n                    value: Int(\n@@ -258,16 +288,10 @@ error: layout_of(CommonPayloadFieldIsMaybeUninit) = Layout {\n                tag_field: 0,\n                variants: [\n                    Layout {\n-                       fields: Arbitrary {\n-                           offsets: [\n-                               Size(1 bytes),\n-                           ],\n-                           memory_index: [\n-                               0,\n-                           ],\n-                       },\n-                       variants: Single {\n-                           index: 0,\n+                       size: Size(2 bytes),\n+                       align: AbiAndPrefAlign {\n+                           abi: Align(1 bytes),\n+                           pref: $PREF_ALIGN,\n                        },\n                        abi: ScalarPair(\n                            Initialized {\n@@ -284,14 +308,6 @@ error: layout_of(CommonPayloadFieldIsMaybeUninit) = Layout {\n                                ),\n                            },\n                        ),\n-                       largest_niche: None,\n-                       align: AbiAndPrefAlign {\n-                           abi: Align(1 bytes),\n-                           pref: $PREF_ALIGN,\n-                       },\n-                       size: Size(2 bytes),\n-                   },\n-                   Layout {\n                        fields: Arbitrary {\n                            offsets: [\n                                Size(1 bytes),\n@@ -300,8 +316,16 @@ error: layout_of(CommonPayloadFieldIsMaybeUninit) = Layout {\n                                0,\n                            ],\n                        },\n+                       largest_niche: None,\n                        variants: Single {\n-                           index: 1,\n+                           index: 0,\n+                       },\n+                   },\n+                   Layout {\n+                       size: Size(2 bytes),\n+                       align: AbiAndPrefAlign {\n+                           abi: Align(1 bytes),\n+                           pref: $PREF_ALIGN,\n                        },\n                        abi: ScalarPair(\n                            Initialized {\n@@ -318,22 +342,40 @@ error: layout_of(CommonPayloadFieldIsMaybeUninit) = Layout {\n                                ),\n                            },\n                        ),\n+                       fields: Arbitrary {\n+                           offsets: [\n+                               Size(1 bytes),\n+                           ],\n+                           memory_index: [\n+                               0,\n+                           ],\n+                       },\n                        largest_niche: None,\n-                       align: AbiAndPrefAlign {\n-                           abi: Align(1 bytes),\n-                           pref: $PREF_ALIGN,\n+                       variants: Single {\n+                           index: 1,\n                        },\n-                       size: Size(2 bytes),\n                    },\n                ],\n            },\n+       }\n+  --> $DIR/issue-96158-scalarpair-payload-might-be-uninit.rs:33:1\n+   |\n+LL | pub enum CommonPayloadFieldIsMaybeUninit {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: layout_of(NicheFirst) = Layout {\n+           size: Size(2 bytes),\n+           align: AbiAndPrefAlign {\n+               abi: Align(1 bytes),\n+               pref: $PREF_ALIGN,\n+           },\n            abi: ScalarPair(\n                Initialized {\n                    value: Int(\n                        I8,\n                        false,\n                    ),\n-                   valid_range: 0..=1,\n+                   valid_range: 0..=4,\n                },\n                Union {\n                    value: Int(\n@@ -342,36 +384,24 @@ error: layout_of(CommonPayloadFieldIsMaybeUninit) = Layout {\n                    ),\n                },\n            ),\n+           fields: Arbitrary {\n+               offsets: [\n+                   Size(0 bytes),\n+               ],\n+               memory_index: [\n+                   0,\n+               ],\n+           },\n            largest_niche: Some(\n                Niche {\n                    offset: Size(0 bytes),\n                    value: Int(\n                        I8,\n                        false,\n                    ),\n-                   valid_range: 0..=1,\n+                   valid_range: 0..=4,\n                },\n            ),\n-           align: AbiAndPrefAlign {\n-               abi: Align(1 bytes),\n-               pref: $PREF_ALIGN,\n-           },\n-           size: Size(2 bytes),\n-       }\n-  --> $DIR/issue-96158-scalarpair-payload-might-be-uninit.rs:33:1\n-   |\n-LL | pub enum CommonPayloadFieldIsMaybeUninit {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-error: layout_of(NicheFirst) = Layout {\n-           fields: Arbitrary {\n-               offsets: [\n-                   Size(0 bytes),\n-               ],\n-               memory_index: [\n-                   0,\n-               ],\n-           },\n            variants: Multiple {\n                tag: Initialized {\n                    value: Int(\n@@ -388,18 +418,10 @@ error: layout_of(NicheFirst) = Layout {\n                tag_field: 0,\n                variants: [\n                    Layout {\n-                       fields: Arbitrary {\n-                           offsets: [\n-                               Size(0 bytes),\n-                               Size(1 bytes),\n-                           ],\n-                           memory_index: [\n-                               0,\n-                               1,\n-                           ],\n-                       },\n-                       variants: Single {\n-                           index: 0,\n+                       size: Size(2 bytes),\n+                       align: AbiAndPrefAlign {\n+                           abi: Align(1 bytes),\n+                           pref: $PREF_ALIGN,\n                        },\n                        abi: ScalarPair(\n                            Initialized {\n@@ -417,6 +439,16 @@ error: layout_of(NicheFirst) = Layout {\n                                valid_range: 0..=255,\n                            },\n                        ),\n+                       fields: Arbitrary {\n+                           offsets: [\n+                               Size(0 bytes),\n+                               Size(1 bytes),\n+                           ],\n+                           memory_index: [\n+                               0,\n+                               1,\n+                           ],\n+                       },\n                        largest_niche: Some(\n                            Niche {\n                                offset: Size(0 bytes),\n@@ -427,87 +459,75 @@ error: layout_of(NicheFirst) = Layout {\n                                valid_range: 0..=2,\n                            },\n                        ),\n+                       variants: Single {\n+                           index: 0,\n+                       },\n+                   },\n+                   Layout {\n+                       size: Size(0 bytes),\n                        align: AbiAndPrefAlign {\n                            abi: Align(1 bytes),\n                            pref: $PREF_ALIGN,\n                        },\n-                       size: Size(2 bytes),\n-                   },\n-                   Layout {\n+                       abi: Aggregate {\n+                           sized: true,\n+                       },\n                        fields: Arbitrary {\n                            offsets: [],\n                            memory_index: [],\n                        },\n+                       largest_niche: None,\n                        variants: Single {\n                            index: 1,\n                        },\n-                       abi: Aggregate {\n-                           sized: true,\n-                       },\n-                       largest_niche: None,\n+                   },\n+                   Layout {\n+                       size: Size(0 bytes),\n                        align: AbiAndPrefAlign {\n                            abi: Align(1 bytes),\n                            pref: $PREF_ALIGN,\n                        },\n-                       size: Size(0 bytes),\n-                   },\n-                   Layout {\n+                       abi: Aggregate {\n+                           sized: true,\n+                       },\n                        fields: Arbitrary {\n                            offsets: [],\n                            memory_index: [],\n                        },\n+                       largest_niche: None,\n                        variants: Single {\n                            index: 2,\n                        },\n-                       abi: Aggregate {\n-                           sized: true,\n-                       },\n-                       largest_niche: None,\n-                       align: AbiAndPrefAlign {\n-                           abi: Align(1 bytes),\n-                           pref: $PREF_ALIGN,\n-                       },\n-                       size: Size(0 bytes),\n                    },\n                ],\n            },\n+       }\n+  --> $DIR/issue-96158-scalarpair-payload-might-be-uninit.rs:41:1\n+   |\n+LL | pub enum NicheFirst {\n+   | ^^^^^^^^^^^^^^^^^^^\n+\n+error: layout_of(NicheSecond) = Layout {\n+           size: Size(2 bytes),\n+           align: AbiAndPrefAlign {\n+               abi: Align(1 bytes),\n+               pref: $PREF_ALIGN,\n+           },\n            abi: ScalarPair(\n-               Initialized {\n-                   value: Int(\n-                       I8,\n-                       false,\n-                   ),\n-                   valid_range: 0..=4,\n-               },\n                Union {\n                    value: Int(\n                        I8,\n                        false,\n                    ),\n                },\n-           ),\n-           largest_niche: Some(\n-               Niche {\n-                   offset: Size(0 bytes),\n+               Initialized {\n                    value: Int(\n                        I8,\n                        false,\n                    ),\n                    valid_range: 0..=4,\n                },\n            ),\n-           align: AbiAndPrefAlign {\n-               abi: Align(1 bytes),\n-               pref: $PREF_ALIGN,\n-           },\n-           size: Size(2 bytes),\n-       }\n-  --> $DIR/issue-96158-scalarpair-payload-might-be-uninit.rs:41:1\n-   |\n-LL | pub enum NicheFirst {\n-   | ^^^^^^^^^^^^^^^^^^^\n-\n-error: layout_of(NicheSecond) = Layout {\n            fields: Arbitrary {\n                offsets: [\n                    Size(1 bytes),\n@@ -516,6 +536,16 @@ error: layout_of(NicheSecond) = Layout {\n                    0,\n                ],\n            },\n+           largest_niche: Some(\n+               Niche {\n+                   offset: Size(1 bytes),\n+                   value: Int(\n+                       I8,\n+                       false,\n+                   ),\n+                   valid_range: 0..=4,\n+               },\n+           ),\n            variants: Multiple {\n                tag: Initialized {\n                    value: Int(\n@@ -532,18 +562,10 @@ error: layout_of(NicheSecond) = Layout {\n                tag_field: 0,\n                variants: [\n                    Layout {\n-                       fields: Arbitrary {\n-                           offsets: [\n-                               Size(0 bytes),\n-                               Size(1 bytes),\n-                           ],\n-                           memory_index: [\n-                               0,\n-                               1,\n-                           ],\n-                       },\n-                       variants: Single {\n-                           index: 0,\n+                       size: Size(2 bytes),\n+                       align: AbiAndPrefAlign {\n+                           abi: Align(1 bytes),\n+                           pref: $PREF_ALIGN,\n                        },\n                        abi: ScalarPair(\n                            Initialized {\n@@ -561,6 +583,16 @@ error: layout_of(NicheSecond) = Layout {\n                                valid_range: 0..=2,\n                            },\n                        ),\n+                       fields: Arbitrary {\n+                           offsets: [\n+                               Size(0 bytes),\n+                               Size(1 bytes),\n+                           ],\n+                           memory_index: [\n+                               0,\n+                               1,\n+                           ],\n+                       },\n                        largest_niche: Some(\n                            Niche {\n                                offset: Size(1 bytes),\n@@ -571,80 +603,48 @@ error: layout_of(NicheSecond) = Layout {\n                                valid_range: 0..=2,\n                            },\n                        ),\n+                       variants: Single {\n+                           index: 0,\n+                       },\n+                   },\n+                   Layout {\n+                       size: Size(0 bytes),\n                        align: AbiAndPrefAlign {\n                            abi: Align(1 bytes),\n                            pref: $PREF_ALIGN,\n                        },\n-                       size: Size(2 bytes),\n-                   },\n-                   Layout {\n+                       abi: Aggregate {\n+                           sized: true,\n+                       },\n                        fields: Arbitrary {\n                            offsets: [],\n                            memory_index: [],\n                        },\n+                       largest_niche: None,\n                        variants: Single {\n                            index: 1,\n                        },\n-                       abi: Aggregate {\n-                           sized: true,\n-                       },\n-                       largest_niche: None,\n+                   },\n+                   Layout {\n+                       size: Size(0 bytes),\n                        align: AbiAndPrefAlign {\n                            abi: Align(1 bytes),\n                            pref: $PREF_ALIGN,\n                        },\n-                       size: Size(0 bytes),\n-                   },\n-                   Layout {\n+                       abi: Aggregate {\n+                           sized: true,\n+                       },\n                        fields: Arbitrary {\n                            offsets: [],\n                            memory_index: [],\n                        },\n+                       largest_niche: None,\n                        variants: Single {\n                            index: 2,\n                        },\n-                       abi: Aggregate {\n-                           sized: true,\n-                       },\n-                       largest_niche: None,\n-                       align: AbiAndPrefAlign {\n-                           abi: Align(1 bytes),\n-                           pref: $PREF_ALIGN,\n-                       },\n-                       size: Size(0 bytes),\n                    },\n                ],\n            },\n-           abi: ScalarPair(\n-               Union {\n-                   value: Int(\n-                       I8,\n-                       false,\n-                   ),\n-               },\n-               Initialized {\n-                   value: Int(\n-                       I8,\n-                       false,\n-                   ),\n-                   valid_range: 0..=4,\n-               },\n-           ),\n-           largest_niche: Some(\n-               Niche {\n-                   offset: Size(1 bytes),\n-                   value: Int(\n-                       I8,\n-                       false,\n-                   ),\n-                   valid_range: 0..=4,\n-               },\n-           ),\n-           align: AbiAndPrefAlign {\n-               abi: Align(1 bytes),\n-               pref: $PREF_ALIGN,\n-           },\n-           size: Size(2 bytes),\n        }\n   --> $DIR/issue-96158-scalarpair-payload-might-be-uninit.rs:50:1\n    |"}, {"sha": "de6177c8dfc4d24aba0b98ace81c35546e1cb8bd", "filename": "src/test/ui/layout/issue-96185-overaligned-enum.stderr", "status": "modified", "additions": 73, "deletions": 73, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/6423ab3a755fed97f75b2361849155d4e996d02f/src%2Ftest%2Fui%2Flayout%2Fissue-96185-overaligned-enum.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6423ab3a755fed97f75b2361849155d4e996d02f/src%2Ftest%2Fui%2Flayout%2Fissue-96185-overaligned-enum.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flayout%2Fissue-96185-overaligned-enum.stderr?ref=6423ab3a755fed97f75b2361849155d4e996d02f", "patch": "@@ -1,4 +1,12 @@\n error: layout_of(Aligned1) = Layout {\n+           size: Size(8 bytes),\n+           align: AbiAndPrefAlign {\n+               abi: Align(8 bytes),\n+               pref: $PREF_ALIGN,\n+           },\n+           abi: Aggregate {\n+               sized: true,\n+           },\n            fields: Arbitrary {\n                offsets: [\n                    Size(0 bytes),\n@@ -7,6 +15,16 @@ error: layout_of(Aligned1) = Layout {\n                    0,\n                ],\n            },\n+           largest_niche: Some(\n+               Niche {\n+                   offset: Size(0 bytes),\n+                   value: Int(\n+                       I8,\n+                       false,\n+                   ),\n+                   valid_range: 0..=1,\n+               },\n+           ),\n            variants: Multiple {\n                tag: Initialized {\n                    value: Int(\n@@ -19,68 +37,64 @@ error: layout_of(Aligned1) = Layout {\n                tag_field: 0,\n                variants: [\n                    Layout {\n+                       size: Size(8 bytes),\n+                       align: AbiAndPrefAlign {\n+                           abi: Align(8 bytes),\n+                           pref: $PREF_ALIGN,\n+                       },\n+                       abi: Aggregate {\n+                           sized: true,\n+                       },\n                        fields: Arbitrary {\n                            offsets: [],\n                            memory_index: [],\n                        },\n+                       largest_niche: None,\n                        variants: Single {\n                            index: 0,\n                        },\n-                       abi: Aggregate {\n-                           sized: true,\n-                       },\n-                       largest_niche: None,\n+                   },\n+                   Layout {\n+                       size: Size(8 bytes),\n                        align: AbiAndPrefAlign {\n                            abi: Align(8 bytes),\n                            pref: $PREF_ALIGN,\n                        },\n-                       size: Size(8 bytes),\n-                   },\n-                   Layout {\n+                       abi: Aggregate {\n+                           sized: true,\n+                       },\n                        fields: Arbitrary {\n                            offsets: [],\n                            memory_index: [],\n                        },\n+                       largest_niche: None,\n                        variants: Single {\n                            index: 1,\n                        },\n-                       abi: Aggregate {\n-                           sized: true,\n-                       },\n-                       largest_niche: None,\n-                       align: AbiAndPrefAlign {\n-                           abi: Align(8 bytes),\n-                           pref: $PREF_ALIGN,\n-                       },\n-                       size: Size(8 bytes),\n                    },\n                ],\n            },\n-           abi: Aggregate {\n-               sized: true,\n+       }\n+  --> $DIR/issue-96185-overaligned-enum.rs:8:1\n+   |\n+LL | pub enum Aligned1 {\n+   | ^^^^^^^^^^^^^^^^^\n+\n+error: layout_of(Aligned2) = Layout {\n+           size: Size(1 bytes),\n+           align: AbiAndPrefAlign {\n+               abi: Align(1 bytes),\n+               pref: $PREF_ALIGN,\n            },\n-           largest_niche: Some(\n-               Niche {\n-                   offset: Size(0 bytes),\n+           abi: Scalar(\n+               Initialized {\n                    value: Int(\n                        I8,\n                        false,\n                    ),\n                    valid_range: 0..=1,\n                },\n            ),\n-           align: AbiAndPrefAlign {\n-               abi: Align(8 bytes),\n-               pref: $PREF_ALIGN,\n-           },\n-           size: Size(8 bytes),\n-       }\n-  --> $DIR/issue-96185-overaligned-enum.rs:8:1\n-   |\n-LL | pub enum Aligned1 {\n-   | ^^^^^^^^^^^^^^^^^\n-\n-error: layout_of(Aligned2) = Layout {\n            fields: Arbitrary {\n                offsets: [\n                    Size(0 bytes),\n@@ -89,6 +103,16 @@ error: layout_of(Aligned2) = Layout {\n                    0,\n                ],\n            },\n+           largest_niche: Some(\n+               Niche {\n+                   offset: Size(0 bytes),\n+                   value: Int(\n+                       I8,\n+                       false,\n+                   ),\n+                   valid_range: 0..=1,\n+               },\n+           ),\n            variants: Multiple {\n                tag: Initialized {\n                    value: Int(\n@@ -101,67 +125,43 @@ error: layout_of(Aligned2) = Layout {\n                tag_field: 0,\n                variants: [\n                    Layout {\n+                       size: Size(1 bytes),\n+                       align: AbiAndPrefAlign {\n+                           abi: Align(1 bytes),\n+                           pref: $PREF_ALIGN,\n+                       },\n+                       abi: Aggregate {\n+                           sized: true,\n+                       },\n                        fields: Arbitrary {\n                            offsets: [],\n                            memory_index: [],\n                        },\n+                       largest_niche: None,\n                        variants: Single {\n                            index: 0,\n                        },\n-                       abi: Aggregate {\n-                           sized: true,\n-                       },\n-                       largest_niche: None,\n+                   },\n+                   Layout {\n+                       size: Size(1 bytes),\n                        align: AbiAndPrefAlign {\n                            abi: Align(1 bytes),\n                            pref: $PREF_ALIGN,\n                        },\n-                       size: Size(1 bytes),\n-                   },\n-                   Layout {\n+                       abi: Aggregate {\n+                           sized: true,\n+                       },\n                        fields: Arbitrary {\n                            offsets: [],\n                            memory_index: [],\n                        },\n+                       largest_niche: None,\n                        variants: Single {\n                            index: 1,\n                        },\n-                       abi: Aggregate {\n-                           sized: true,\n-                       },\n-                       largest_niche: None,\n-                       align: AbiAndPrefAlign {\n-                           abi: Align(1 bytes),\n-                           pref: $PREF_ALIGN,\n-                       },\n-                       size: Size(1 bytes),\n                    },\n                ],\n            },\n-           abi: Scalar(\n-               Initialized {\n-                   value: Int(\n-                       I8,\n-                       false,\n-                   ),\n-                   valid_range: 0..=1,\n-               },\n-           ),\n-           largest_niche: Some(\n-               Niche {\n-                   offset: Size(0 bytes),\n-                   value: Int(\n-                       I8,\n-                       false,\n-                   ),\n-                   valid_range: 0..=1,\n-               },\n-           ),\n-           align: AbiAndPrefAlign {\n-               abi: Align(1 bytes),\n-               pref: $PREF_ALIGN,\n-           },\n-           size: Size(1 bytes),\n        }\n   --> $DIR/issue-96185-overaligned-enum.rs:16:1\n    |"}, {"sha": "227bd950b66663d0e2a64fbdaea9a001c01b74ee", "filename": "src/test/ui/layout/thumb-enum.stderr", "status": "modified", "additions": 163, "deletions": 163, "changes": 326, "blob_url": "https://github.com/rust-lang/rust/blob/6423ab3a755fed97f75b2361849155d4e996d02f/src%2Ftest%2Fui%2Flayout%2Fthumb-enum.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6423ab3a755fed97f75b2361849155d4e996d02f/src%2Ftest%2Fui%2Flayout%2Fthumb-enum.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flayout%2Fthumb-enum.stderr?ref=6423ab3a755fed97f75b2361849155d4e996d02f", "patch": "@@ -1,4 +1,18 @@\n error: layout_of(A) = Layout {\n+           size: Size(1 bytes),\n+           align: AbiAndPrefAlign {\n+               abi: Align(1 bytes),\n+               pref: Align(4 bytes),\n+           },\n+           abi: Scalar(\n+               Initialized {\n+                   value: Int(\n+                       I8,\n+                       false,\n+                   ),\n+                   valid_range: 0..=0,\n+               },\n+           ),\n            fields: Arbitrary {\n                offsets: [\n                    Size(0 bytes),\n@@ -7,6 +21,16 @@ error: layout_of(A) = Layout {\n                    0,\n                ],\n            },\n+           largest_niche: Some(\n+               Niche {\n+                   offset: Size(0 bytes),\n+                   value: Int(\n+                       I8,\n+                       false,\n+                   ),\n+                   valid_range: 0..=0,\n+               },\n+           ),\n            variants: Multiple {\n                tag: Initialized {\n                    value: Int(\n@@ -19,64 +43,64 @@ error: layout_of(A) = Layout {\n                tag_field: 0,\n                variants: [\n                    Layout {\n+                       size: Size(1 bytes),\n+                       align: AbiAndPrefAlign {\n+                           abi: Align(1 bytes),\n+                           pref: Align(4 bytes),\n+                       },\n+                       abi: Aggregate {\n+                           sized: true,\n+                       },\n                        fields: Arbitrary {\n                            offsets: [],\n                            memory_index: [],\n                        },\n+                       largest_niche: None,\n                        variants: Single {\n                            index: 0,\n                        },\n-                       abi: Aggregate {\n-                           sized: true,\n-                       },\n-                       largest_niche: None,\n-                       align: AbiAndPrefAlign {\n-                           abi: Align(1 bytes),\n-                           pref: Align(4 bytes),\n-                       },\n-                       size: Size(1 bytes),\n                    },\n                ],\n            },\n+       }\n+  --> $DIR/thumb-enum.rs:16:1\n+   |\n+LL | enum A { Apple }\n+   | ^^^^^^\n+\n+error: layout_of(B) = Layout {\n+           size: Size(1 bytes),\n+           align: AbiAndPrefAlign {\n+               abi: Align(1 bytes),\n+               pref: Align(4 bytes),\n+           },\n            abi: Scalar(\n                Initialized {\n                    value: Int(\n                        I8,\n                        false,\n                    ),\n-                   valid_range: 0..=0,\n+                   valid_range: 255..=255,\n                },\n            ),\n+           fields: Arbitrary {\n+               offsets: [\n+                   Size(0 bytes),\n+               ],\n+               memory_index: [\n+                   0,\n+               ],\n+           },\n            largest_niche: Some(\n                Niche {\n                    offset: Size(0 bytes),\n                    value: Int(\n                        I8,\n                        false,\n                    ),\n-                   valid_range: 0..=0,\n+                   valid_range: 255..=255,\n                },\n            ),\n-           align: AbiAndPrefAlign {\n-               abi: Align(1 bytes),\n-               pref: Align(4 bytes),\n-           },\n-           size: Size(1 bytes),\n-       }\n-  --> $DIR/thumb-enum.rs:16:1\n-   |\n-LL | enum A { Apple }\n-   | ^^^^^^\n-\n-error: layout_of(B) = Layout {\n-           fields: Arbitrary {\n-               offsets: [\n-                   Size(0 bytes),\n-               ],\n-               memory_index: [\n-                   0,\n-               ],\n-           },\n            variants: Multiple {\n                tag: Initialized {\n                    value: Int(\n@@ -89,56 +113,46 @@ error: layout_of(B) = Layout {\n                tag_field: 0,\n                variants: [\n                    Layout {\n+                       size: Size(1 bytes),\n+                       align: AbiAndPrefAlign {\n+                           abi: Align(1 bytes),\n+                           pref: Align(4 bytes),\n+                       },\n+                       abi: Aggregate {\n+                           sized: true,\n+                       },\n                        fields: Arbitrary {\n                            offsets: [],\n                            memory_index: [],\n                        },\n+                       largest_niche: None,\n                        variants: Single {\n                            index: 0,\n                        },\n-                       abi: Aggregate {\n-                           sized: true,\n-                       },\n-                       largest_niche: None,\n-                       align: AbiAndPrefAlign {\n-                           abi: Align(1 bytes),\n-                           pref: Align(4 bytes),\n-                       },\n-                       size: Size(1 bytes),\n                    },\n                ],\n            },\n-           abi: Scalar(\n-               Initialized {\n-                   value: Int(\n-                       I8,\n-                       false,\n-                   ),\n-                   valid_range: 255..=255,\n-               },\n-           ),\n-           largest_niche: Some(\n-               Niche {\n-                   offset: Size(0 bytes),\n-                   value: Int(\n-                       I8,\n-                       false,\n-                   ),\n-                   valid_range: 255..=255,\n-               },\n-           ),\n-           align: AbiAndPrefAlign {\n-               abi: Align(1 bytes),\n-               pref: Align(4 bytes),\n-           },\n-           size: Size(1 bytes),\n        }\n   --> $DIR/thumb-enum.rs:20:1\n    |\n LL | enum B { Banana = 255, }\n    | ^^^^^^\n \n error: layout_of(C) = Layout {\n+           size: Size(2 bytes),\n+           align: AbiAndPrefAlign {\n+               abi: Align(2 bytes),\n+               pref: Align(4 bytes),\n+           },\n+           abi: Scalar(\n+               Initialized {\n+                   value: Int(\n+                       I16,\n+                       false,\n+                   ),\n+                   valid_range: 256..=256,\n+               },\n+           ),\n            fields: Arbitrary {\n                offsets: [\n                    Size(0 bytes),\n@@ -147,6 +161,16 @@ error: layout_of(C) = Layout {\n                    0,\n                ],\n            },\n+           largest_niche: Some(\n+               Niche {\n+                   offset: Size(0 bytes),\n+                   value: Int(\n+                       I16,\n+                       false,\n+                   ),\n+                   valid_range: 256..=256,\n+               },\n+           ),\n            variants: Multiple {\n                tag: Initialized {\n                    value: Int(\n@@ -159,56 +183,46 @@ error: layout_of(C) = Layout {\n                tag_field: 0,\n                variants: [\n                    Layout {\n+                       size: Size(2 bytes),\n+                       align: AbiAndPrefAlign {\n+                           abi: Align(2 bytes),\n+                           pref: Align(4 bytes),\n+                       },\n+                       abi: Aggregate {\n+                           sized: true,\n+                       },\n                        fields: Arbitrary {\n                            offsets: [],\n                            memory_index: [],\n                        },\n+                       largest_niche: None,\n                        variants: Single {\n                            index: 0,\n                        },\n-                       abi: Aggregate {\n-                           sized: true,\n-                       },\n-                       largest_niche: None,\n-                       align: AbiAndPrefAlign {\n-                           abi: Align(2 bytes),\n-                           pref: Align(4 bytes),\n-                       },\n-                       size: Size(2 bytes),\n                    },\n                ],\n            },\n-           abi: Scalar(\n-               Initialized {\n-                   value: Int(\n-                       I16,\n-                       false,\n-                   ),\n-                   valid_range: 256..=256,\n-               },\n-           ),\n-           largest_niche: Some(\n-               Niche {\n-                   offset: Size(0 bytes),\n-                   value: Int(\n-                       I16,\n-                       false,\n-                   ),\n-                   valid_range: 256..=256,\n-               },\n-           ),\n-           align: AbiAndPrefAlign {\n-               abi: Align(2 bytes),\n-               pref: Align(4 bytes),\n-           },\n-           size: Size(2 bytes),\n        }\n   --> $DIR/thumb-enum.rs:24:1\n    |\n LL | enum C { Chaenomeles = 256, }\n    | ^^^^^^\n \n error: layout_of(P) = Layout {\n+           size: Size(4 bytes),\n+           align: AbiAndPrefAlign {\n+               abi: Align(4 bytes),\n+               pref: Align(4 bytes),\n+           },\n+           abi: Scalar(\n+               Initialized {\n+                   value: Int(\n+                       I32,\n+                       false,\n+                   ),\n+                   valid_range: 268435456..=268435456,\n+               },\n+           ),\n            fields: Arbitrary {\n                offsets: [\n                    Size(0 bytes),\n@@ -217,6 +231,16 @@ error: layout_of(P) = Layout {\n                    0,\n                ],\n            },\n+           largest_niche: Some(\n+               Niche {\n+                   offset: Size(0 bytes),\n+                   value: Int(\n+                       I32,\n+                       false,\n+                   ),\n+                   valid_range: 268435456..=268435456,\n+               },\n+           ),\n            variants: Multiple {\n                tag: Initialized {\n                    value: Int(\n@@ -229,56 +253,46 @@ error: layout_of(P) = Layout {\n                tag_field: 0,\n                variants: [\n                    Layout {\n+                       size: Size(4 bytes),\n+                       align: AbiAndPrefAlign {\n+                           abi: Align(4 bytes),\n+                           pref: Align(4 bytes),\n+                       },\n+                       abi: Aggregate {\n+                           sized: true,\n+                       },\n                        fields: Arbitrary {\n                            offsets: [],\n                            memory_index: [],\n                        },\n+                       largest_niche: None,\n                        variants: Single {\n                            index: 0,\n                        },\n-                       abi: Aggregate {\n-                           sized: true,\n-                       },\n-                       largest_niche: None,\n-                       align: AbiAndPrefAlign {\n-                           abi: Align(4 bytes),\n-                           pref: Align(4 bytes),\n-                       },\n-                       size: Size(4 bytes),\n                    },\n                ],\n            },\n-           abi: Scalar(\n-               Initialized {\n-                   value: Int(\n-                       I32,\n-                       false,\n-                   ),\n-                   valid_range: 268435456..=268435456,\n-               },\n-           ),\n-           largest_niche: Some(\n-               Niche {\n-                   offset: Size(0 bytes),\n-                   value: Int(\n-                       I32,\n-                       false,\n-                   ),\n-                   valid_range: 268435456..=268435456,\n-               },\n-           ),\n-           align: AbiAndPrefAlign {\n-               abi: Align(4 bytes),\n-               pref: Align(4 bytes),\n-           },\n-           size: Size(4 bytes),\n        }\n   --> $DIR/thumb-enum.rs:28:1\n    |\n LL | enum P { Peach = 0x1000_0000isize, }\n    | ^^^^^^\n \n error: layout_of(T) = Layout {\n+           size: Size(4 bytes),\n+           align: AbiAndPrefAlign {\n+               abi: Align(4 bytes),\n+               pref: Align(4 bytes),\n+           },\n+           abi: Scalar(\n+               Initialized {\n+                   value: Int(\n+                       I32,\n+                       true,\n+                   ),\n+                   valid_range: 2164260864..=2164260864,\n+               },\n+           ),\n            fields: Arbitrary {\n                offsets: [\n                    Size(0 bytes),\n@@ -287,6 +301,16 @@ error: layout_of(T) = Layout {\n                    0,\n                ],\n            },\n+           largest_niche: Some(\n+               Niche {\n+                   offset: Size(0 bytes),\n+                   value: Int(\n+                       I32,\n+                       true,\n+                   ),\n+                   valid_range: 2164260864..=2164260864,\n+               },\n+           ),\n            variants: Multiple {\n                tag: Initialized {\n                    value: Int(\n@@ -299,49 +323,25 @@ error: layout_of(T) = Layout {\n                tag_field: 0,\n                variants: [\n                    Layout {\n+                       size: Size(4 bytes),\n+                       align: AbiAndPrefAlign {\n+                           abi: Align(4 bytes),\n+                           pref: Align(4 bytes),\n+                       },\n+                       abi: Aggregate {\n+                           sized: true,\n+                       },\n                        fields: Arbitrary {\n                            offsets: [],\n                            memory_index: [],\n                        },\n+                       largest_niche: None,\n                        variants: Single {\n                            index: 0,\n                        },\n-                       abi: Aggregate {\n-                           sized: true,\n-                       },\n-                       largest_niche: None,\n-                       align: AbiAndPrefAlign {\n-                           abi: Align(4 bytes),\n-                           pref: Align(4 bytes),\n-                       },\n-                       size: Size(4 bytes),\n                    },\n                ],\n            },\n-           abi: Scalar(\n-               Initialized {\n-                   value: Int(\n-                       I32,\n-                       true,\n-                   ),\n-                   valid_range: 2164260864..=2164260864,\n-               },\n-           ),\n-           largest_niche: Some(\n-               Niche {\n-                   offset: Size(0 bytes),\n-                   value: Int(\n-                       I32,\n-                       true,\n-                   ),\n-                   valid_range: 2164260864..=2164260864,\n-               },\n-           ),\n-           align: AbiAndPrefAlign {\n-               abi: Align(4 bytes),\n-               pref: Align(4 bytes),\n-           },\n-           size: Size(4 bytes),\n        }\n   --> $DIR/thumb-enum.rs:34:1\n    |"}, {"sha": "56d3a52bb7ff9133a2f0fcdcf0ea3f95572d30b2", "filename": "src/test/ui/layout/zero-sized-array-enum-niche.stderr", "status": "modified", "additions": 152, "deletions": 152, "changes": 304, "blob_url": "https://github.com/rust-lang/rust/blob/6423ab3a755fed97f75b2361849155d4e996d02f/src%2Ftest%2Fui%2Flayout%2Fzero-sized-array-enum-niche.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6423ab3a755fed97f75b2361849155d4e996d02f/src%2Ftest%2Fui%2Flayout%2Fzero-sized-array-enum-niche.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flayout%2Fzero-sized-array-enum-niche.stderr?ref=6423ab3a755fed97f75b2361849155d4e996d02f", "patch": "@@ -1,4 +1,12 @@\n error: layout_of(std::result::Result<[u32; 0], bool>) = Layout {\n+           size: Size(4 bytes),\n+           align: AbiAndPrefAlign {\n+               abi: Align(4 bytes),\n+               pref: $PREF_ALIGN,\n+           },\n+           abi: Aggregate {\n+               sized: true,\n+           },\n            fields: Arbitrary {\n                offsets: [\n                    Size(0 bytes),\n@@ -7,6 +15,16 @@ error: layout_of(std::result::Result<[u32; 0], bool>) = Layout {\n                    0,\n                ],\n            },\n+           largest_niche: Some(\n+               Niche {\n+                   offset: Size(0 bytes),\n+                   value: Int(\n+                       I8,\n+                       false,\n+                   ),\n+                   valid_range: 0..=1,\n+               },\n+           ),\n            variants: Multiple {\n                tag: Initialized {\n                    value: Int(\n@@ -19,6 +37,14 @@ error: layout_of(std::result::Result<[u32; 0], bool>) = Layout {\n                tag_field: 0,\n                variants: [\n                    Layout {\n+                       size: Size(4 bytes),\n+                       align: AbiAndPrefAlign {\n+                           abi: Align(4 bytes),\n+                           pref: $PREF_ALIGN,\n+                       },\n+                       abi: Aggregate {\n+                           sized: true,\n+                       },\n                        fields: Arbitrary {\n                            offsets: [\n                                Size(4 bytes),\n@@ -27,20 +53,20 @@ error: layout_of(std::result::Result<[u32; 0], bool>) = Layout {\n                                0,\n                            ],\n                        },\n+                       largest_niche: None,\n                        variants: Single {\n                            index: 0,\n                        },\n-                       abi: Aggregate {\n-                           sized: true,\n-                       },\n-                       largest_niche: None,\n+                   },\n+                   Layout {\n+                       size: Size(2 bytes),\n                        align: AbiAndPrefAlign {\n-                           abi: Align(4 bytes),\n+                           abi: Align(1 bytes),\n                            pref: $PREF_ALIGN,\n                        },\n-                       size: Size(4 bytes),\n-                   },\n-                   Layout {\n+                       abi: Aggregate {\n+                           sized: true,\n+                       },\n                        fields: Arbitrary {\n                            offsets: [\n                                Size(1 bytes),\n@@ -49,12 +75,6 @@ error: layout_of(std::result::Result<[u32; 0], bool>) = Layout {\n                                0,\n                            ],\n                        },\n-                       variants: Single {\n-                           index: 1,\n-                       },\n-                       abi: Aggregate {\n-                           sized: true,\n-                       },\n                        largest_niche: Some(\n                            Niche {\n                                offset: Size(1 bytes),\n@@ -65,39 +85,27 @@ error: layout_of(std::result::Result<[u32; 0], bool>) = Layout {\n                                valid_range: 0..=1,\n                            },\n                        ),\n-                       align: AbiAndPrefAlign {\n-                           abi: Align(1 bytes),\n-                           pref: $PREF_ALIGN,\n+                       variants: Single {\n+                           index: 1,\n                        },\n-                       size: Size(2 bytes),\n                    },\n                ],\n            },\n-           abi: Aggregate {\n-               sized: true,\n-           },\n-           largest_niche: Some(\n-               Niche {\n-                   offset: Size(0 bytes),\n-                   value: Int(\n-                       I8,\n-                       false,\n-                   ),\n-                   valid_range: 0..=1,\n-               },\n-           ),\n-           align: AbiAndPrefAlign {\n-               abi: Align(4 bytes),\n-               pref: $PREF_ALIGN,\n-           },\n-           size: Size(4 bytes),\n        }\n   --> $DIR/zero-sized-array-enum-niche.rs:13:1\n    |\n LL | type AlignedResult = Result<[u32; 0], bool>;\n    | ^^^^^^^^^^^^^^^^^^\n \n error: layout_of(MultipleAlignments) = Layout {\n+           size: Size(4 bytes),\n+           align: AbiAndPrefAlign {\n+               abi: Align(4 bytes),\n+               pref: $PREF_ALIGN,\n+           },\n+           abi: Aggregate {\n+               sized: true,\n+           },\n            fields: Arbitrary {\n                offsets: [\n                    Size(0 bytes),\n@@ -106,6 +114,16 @@ error: layout_of(MultipleAlignments) = Layout {\n                    0,\n                ],\n            },\n+           largest_niche: Some(\n+               Niche {\n+                   offset: Size(0 bytes),\n+                   value: Int(\n+                       I8,\n+                       false,\n+                   ),\n+                   valid_range: 0..=2,\n+               },\n+           ),\n            variants: Multiple {\n                tag: Initialized {\n                    value: Int(\n@@ -118,6 +136,14 @@ error: layout_of(MultipleAlignments) = Layout {\n                tag_field: 0,\n                variants: [\n                    Layout {\n+                       size: Size(2 bytes),\n+                       align: AbiAndPrefAlign {\n+                           abi: Align(2 bytes),\n+                           pref: $PREF_ALIGN,\n+                       },\n+                       abi: Aggregate {\n+                           sized: true,\n+                       },\n                        fields: Arbitrary {\n                            offsets: [\n                                Size(2 bytes),\n@@ -126,20 +152,20 @@ error: layout_of(MultipleAlignments) = Layout {\n                                0,\n                            ],\n                        },\n+                       largest_niche: None,\n                        variants: Single {\n                            index: 0,\n                        },\n-                       abi: Aggregate {\n-                           sized: true,\n-                       },\n-                       largest_niche: None,\n+                   },\n+                   Layout {\n+                       size: Size(4 bytes),\n                        align: AbiAndPrefAlign {\n-                           abi: Align(2 bytes),\n+                           abi: Align(4 bytes),\n                            pref: $PREF_ALIGN,\n                        },\n-                       size: Size(2 bytes),\n-                   },\n-                   Layout {\n+                       abi: Aggregate {\n+                           sized: true,\n+                       },\n                        fields: Arbitrary {\n                            offsets: [\n                                Size(4 bytes),\n@@ -148,20 +174,20 @@ error: layout_of(MultipleAlignments) = Layout {\n                                0,\n                            ],\n                        },\n+                       largest_niche: None,\n                        variants: Single {\n                            index: 1,\n                        },\n-                       abi: Aggregate {\n-                           sized: true,\n-                       },\n-                       largest_niche: None,\n+                   },\n+                   Layout {\n+                       size: Size(2 bytes),\n                        align: AbiAndPrefAlign {\n-                           abi: Align(4 bytes),\n+                           abi: Align(1 bytes),\n                            pref: $PREF_ALIGN,\n                        },\n-                       size: Size(4 bytes),\n-                   },\n-                   Layout {\n+                       abi: Aggregate {\n+                           sized: true,\n+                       },\n                        fields: Arbitrary {\n                            offsets: [\n                                Size(1 bytes),\n@@ -170,12 +196,6 @@ error: layout_of(MultipleAlignments) = Layout {\n                                0,\n                            ],\n                        },\n-                       variants: Single {\n-                           index: 2,\n-                       },\n-                       abi: Aggregate {\n-                           sized: true,\n-                       },\n                        largest_niche: Some(\n                            Niche {\n                                offset: Size(1 bytes),\n@@ -186,39 +206,27 @@ error: layout_of(MultipleAlignments) = Layout {\n                                valid_range: 0..=1,\n                            },\n                        ),\n-                       align: AbiAndPrefAlign {\n-                           abi: Align(1 bytes),\n-                           pref: $PREF_ALIGN,\n+                       variants: Single {\n+                           index: 2,\n                        },\n-                       size: Size(2 bytes),\n                    },\n                ],\n            },\n-           abi: Aggregate {\n-               sized: true,\n-           },\n-           largest_niche: Some(\n-               Niche {\n-                   offset: Size(0 bytes),\n-                   value: Int(\n-                       I8,\n-                       false,\n-                   ),\n-                   valid_range: 0..=2,\n-               },\n-           ),\n-           align: AbiAndPrefAlign {\n-               abi: Align(4 bytes),\n-               pref: $PREF_ALIGN,\n-           },\n-           size: Size(4 bytes),\n        }\n   --> $DIR/zero-sized-array-enum-niche.rs:21:1\n    |\n LL | enum MultipleAlignments {\n    | ^^^^^^^^^^^^^^^^^^^^^^^\n \n error: layout_of(std::result::Result<[u32; 0], Packed<std::num::NonZeroU16>>) = Layout {\n+           size: Size(4 bytes),\n+           align: AbiAndPrefAlign {\n+               abi: Align(4 bytes),\n+               pref: $PREF_ALIGN,\n+           },\n+           abi: Aggregate {\n+               sized: true,\n+           },\n            fields: Arbitrary {\n                offsets: [\n                    Size(0 bytes),\n@@ -227,6 +235,16 @@ error: layout_of(std::result::Result<[u32; 0], Packed<std::num::NonZeroU16>>) =\n                    0,\n                ],\n            },\n+           largest_niche: Some(\n+               Niche {\n+                   offset: Size(0 bytes),\n+                   value: Int(\n+                       I8,\n+                       false,\n+                   ),\n+                   valid_range: 0..=1,\n+               },\n+           ),\n            variants: Multiple {\n                tag: Initialized {\n                    value: Int(\n@@ -239,6 +257,14 @@ error: layout_of(std::result::Result<[u32; 0], Packed<std::num::NonZeroU16>>) =\n                tag_field: 0,\n                variants: [\n                    Layout {\n+                       size: Size(4 bytes),\n+                       align: AbiAndPrefAlign {\n+                           abi: Align(4 bytes),\n+                           pref: $PREF_ALIGN,\n+                       },\n+                       abi: Aggregate {\n+                           sized: true,\n+                       },\n                        fields: Arbitrary {\n                            offsets: [\n                                Size(4 bytes),\n@@ -247,20 +273,20 @@ error: layout_of(std::result::Result<[u32; 0], Packed<std::num::NonZeroU16>>) =\n                                0,\n                            ],\n                        },\n+                       largest_niche: None,\n                        variants: Single {\n                            index: 0,\n                        },\n-                       abi: Aggregate {\n-                           sized: true,\n-                       },\n-                       largest_niche: None,\n+                   },\n+                   Layout {\n+                       size: Size(3 bytes),\n                        align: AbiAndPrefAlign {\n-                           abi: Align(4 bytes),\n+                           abi: Align(1 bytes),\n                            pref: $PREF_ALIGN,\n                        },\n-                       size: Size(4 bytes),\n-                   },\n-                   Layout {\n+                       abi: Aggregate {\n+                           sized: true,\n+                       },\n                        fields: Arbitrary {\n                            offsets: [\n                                Size(1 bytes),\n@@ -269,12 +295,6 @@ error: layout_of(std::result::Result<[u32; 0], Packed<std::num::NonZeroU16>>) =\n                                0,\n                            ],\n                        },\n-                       variants: Single {\n-                           index: 1,\n-                       },\n-                       abi: Aggregate {\n-                           sized: true,\n-                       },\n                        largest_niche: Some(\n                            Niche {\n                                offset: Size(1 bytes),\n@@ -285,39 +305,27 @@ error: layout_of(std::result::Result<[u32; 0], Packed<std::num::NonZeroU16>>) =\n                                valid_range: 1..=65535,\n                            },\n                        ),\n-                       align: AbiAndPrefAlign {\n-                           abi: Align(1 bytes),\n-                           pref: $PREF_ALIGN,\n+                       variants: Single {\n+                           index: 1,\n                        },\n-                       size: Size(3 bytes),\n                    },\n                ],\n            },\n-           abi: Aggregate {\n-               sized: true,\n-           },\n-           largest_niche: Some(\n-               Niche {\n-                   offset: Size(0 bytes),\n-                   value: Int(\n-                       I8,\n-                       false,\n-                   ),\n-                   valid_range: 0..=1,\n-               },\n-           ),\n-           align: AbiAndPrefAlign {\n-               abi: Align(4 bytes),\n-               pref: $PREF_ALIGN,\n-           },\n-           size: Size(4 bytes),\n        }\n   --> $DIR/zero-sized-array-enum-niche.rs:37:1\n    |\n LL | type NicheLosesToTagged = Result<[u32; 0], Packed<std::num::NonZeroU16>>;\n    | ^^^^^^^^^^^^^^^^^^^^^^^\n \n error: layout_of(std::result::Result<[u32; 0], Packed<U16IsZero>>) = Layout {\n+           size: Size(4 bytes),\n+           align: AbiAndPrefAlign {\n+               abi: Align(4 bytes),\n+               pref: $PREF_ALIGN,\n+           },\n+           abi: Aggregate {\n+               sized: true,\n+           },\n            fields: Arbitrary {\n                offsets: [\n                    Size(0 bytes),\n@@ -326,6 +334,16 @@ error: layout_of(std::result::Result<[u32; 0], Packed<U16IsZero>>) = Layout {\n                    0,\n                ],\n            },\n+           largest_niche: Some(\n+               Niche {\n+                   offset: Size(0 bytes),\n+                   value: Int(\n+                       I16,\n+                       false,\n+                   ),\n+                   valid_range: 0..=1,\n+               },\n+           ),\n            variants: Multiple {\n                tag: Initialized {\n                    value: Int(\n@@ -342,6 +360,14 @@ error: layout_of(std::result::Result<[u32; 0], Packed<U16IsZero>>) = Layout {\n                tag_field: 0,\n                variants: [\n                    Layout {\n+                       size: Size(0 bytes),\n+                       align: AbiAndPrefAlign {\n+                           abi: Align(4 bytes),\n+                           pref: $PREF_ALIGN,\n+                       },\n+                       abi: Aggregate {\n+                           sized: true,\n+                       },\n                        fields: Arbitrary {\n                            offsets: [\n                                Size(0 bytes),\n@@ -350,20 +376,20 @@ error: layout_of(std::result::Result<[u32; 0], Packed<U16IsZero>>) = Layout {\n                                0,\n                            ],\n                        },\n+                       largest_niche: None,\n                        variants: Single {\n                            index: 0,\n                        },\n-                       abi: Aggregate {\n-                           sized: true,\n-                       },\n-                       largest_niche: None,\n+                   },\n+                   Layout {\n+                       size: Size(2 bytes),\n                        align: AbiAndPrefAlign {\n-                           abi: Align(4 bytes),\n+                           abi: Align(1 bytes),\n                            pref: $PREF_ALIGN,\n                        },\n-                       size: Size(0 bytes),\n-                   },\n-                   Layout {\n+                       abi: Aggregate {\n+                           sized: true,\n+                       },\n                        fields: Arbitrary {\n                            offsets: [\n                                Size(0 bytes),\n@@ -372,12 +398,6 @@ error: layout_of(std::result::Result<[u32; 0], Packed<U16IsZero>>) = Layout {\n                                0,\n                            ],\n                        },\n-                       variants: Single {\n-                           index: 1,\n-                       },\n-                       abi: Aggregate {\n-                           sized: true,\n-                       },\n                        largest_niche: Some(\n                            Niche {\n                                offset: Size(0 bytes),\n@@ -388,32 +408,12 @@ error: layout_of(std::result::Result<[u32; 0], Packed<U16IsZero>>) = Layout {\n                                valid_range: 0..=0,\n                            },\n                        ),\n-                       align: AbiAndPrefAlign {\n-                           abi: Align(1 bytes),\n-                           pref: $PREF_ALIGN,\n+                       variants: Single {\n+                           index: 1,\n                        },\n-                       size: Size(2 bytes),\n                    },\n                ],\n            },\n-           abi: Aggregate {\n-               sized: true,\n-           },\n-           largest_niche: Some(\n-               Niche {\n-                   offset: Size(0 bytes),\n-                   value: Int(\n-                       I16,\n-                       false,\n-                   ),\n-                   valid_range: 0..=1,\n-               },\n-           ),\n-           align: AbiAndPrefAlign {\n-               abi: Align(4 bytes),\n-               pref: $PREF_ALIGN,\n-           },\n-           size: Size(4 bytes),\n        }\n   --> $DIR/zero-sized-array-enum-niche.rs:44:1\n    |"}, {"sha": "7b609145bad7298ca95197ab553de4cb50c47d11", "filename": "src/test/ui/panics/location-detail-panic-no-location-info.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6423ab3a755fed97f75b2361849155d4e996d02f/src%2Ftest%2Fui%2Fpanics%2Flocation-detail-panic-no-location-info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6423ab3a755fed97f75b2361849155d4e996d02f/src%2Ftest%2Fui%2Fpanics%2Flocation-detail-panic-no-location-info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpanics%2Flocation-detail-panic-no-location-info.rs?ref=6423ab3a755fed97f75b2361849155d4e996d02f", "patch": "@@ -0,0 +1,8 @@\n+// run-fail\n+// check-run-results\n+// compile-flags: -Zlocation-detail=none\n+// exec-env:RUST_BACKTRACE=0\n+\n+fn main() {\n+    panic!(\"no location info\");\n+}"}, {"sha": "d1c3108643c6c9ae4dc2a9fdc78dacf6560686f0", "filename": "src/test/ui/panics/location-detail-panic-no-location-info.run.stderr", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6423ab3a755fed97f75b2361849155d4e996d02f/src%2Ftest%2Fui%2Fpanics%2Flocation-detail-panic-no-location-info.run.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6423ab3a755fed97f75b2361849155d4e996d02f/src%2Ftest%2Fui%2Fpanics%2Flocation-detail-panic-no-location-info.run.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpanics%2Flocation-detail-panic-no-location-info.run.stderr?ref=6423ab3a755fed97f75b2361849155d4e996d02f", "patch": "@@ -0,0 +1,2 @@\n+thread 'main' panicked at 'no location info', <redacted>:0:0\n+note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace"}]}