{"sha": "0411132679b58ff3c177ccf24a22212881d6538d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA0MTExMzI2NzliNThmZjNjMTc3Y2NmMjRhMjIyMTI4ODFkNjUzOGQ=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2010-12-22T01:47:13Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2010-12-22T01:47:13Z"}, "message": "rustc: Move unification out of typeck.rs; trans will need it too.", "tree": {"sha": "ffdc1b06c5e77a38ada30a0c3a2258f67c4d180e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ffdc1b06c5e77a38ada30a0c3a2258f67c4d180e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0411132679b58ff3c177ccf24a22212881d6538d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0411132679b58ff3c177ccf24a22212881d6538d", "html_url": "https://github.com/rust-lang/rust/commit/0411132679b58ff3c177ccf24a22212881d6538d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0411132679b58ff3c177ccf24a22212881d6538d/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e06263ff4bb2fcdb39d28a65dd14438809fc83b3", "url": "https://api.github.com/repos/rust-lang/rust/commits/e06263ff4bb2fcdb39d28a65dd14438809fc83b3", "html_url": "https://github.com/rust-lang/rust/commit/e06263ff4bb2fcdb39d28a65dd14438809fc83b3"}], "stats": {"total": 860, "additions": 449, "deletions": 411}, "files": [{"sha": "bfcfcb672d7c96f5b10ad2d137d5506640bee193", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 425, "deletions": 0, "changes": 425, "blob_url": "https://github.com/rust-lang/rust/blob/0411132679b58ff3c177ccf24a22212881d6538d/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0411132679b58ff3c177ccf24a22212881d6538d/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=0411132679b58ff3c177ccf24a22212881d6538d", "patch": "@@ -1,5 +1,8 @@\n import std._str;\n+import std._uint;\n import std._vec;\n+import std.map;\n+import std.map.hashmap;\n import std.option;\n import std.option.none;\n import std.option.some;\n@@ -8,6 +11,7 @@ import driver.session;\n import front.ast;\n import front.ast.mutability;\n import util.common;\n+import util.common.append;\n import util.common.span;\n \n // Data types\n@@ -40,6 +44,30 @@ tag sty {\n     // TODO: ty_fn_arg(@t), for a possibly-aliased function argument\n }\n \n+// Data structures used in type unification\n+\n+type unify_handler = obj {\n+    fn resolve_local(ast.def_id id) -> @t;\n+    fn record_local(ast.def_id id, @t ty);\n+    fn unify_expected_param(ast.def_id id, @t expected, @t actual)\n+        -> unify_result;\n+};\n+\n+tag type_err {\n+    terr_mismatch;\n+    terr_tuple_size(uint, uint);\n+    terr_tuple_mutability;\n+    terr_record_size(uint, uint);\n+    terr_record_mutability;\n+    terr_record_fields(ast.ident,ast.ident);\n+    terr_arg_count;\n+}\n+\n+tag unify_result {\n+    ures_ok(@ty.t);\n+    ures_err(type_err, @ty.t, @ty.t);\n+}\n+\n // Stringification\n \n fn ast_ty_to_str(&@ast.ty ty) -> str {\n@@ -586,3 +614,400 @@ fn is_lval(@ast.expr expr) -> bool {\n     }\n }\n \n+// Type unification\n+\n+fn unify(@ty.t expected, @ty.t actual, &unify_handler handler)\n+        -> unify_result {\n+    // Wraps the given type in an appropriate cname.\n+    //\n+    // TODO: This doesn't do anything yet. We should carry the cname up from\n+    // the expected and/or actual types when unification results in a type\n+    // identical to one or both of the two. The precise algorithm for this is\n+    // something we'll probably need to develop over time.\n+\n+    // Simple structural type comparison.\n+    fn struct_cmp(@ty.t expected, @ty.t actual) -> unify_result {\n+        if (expected.struct == actual.struct) {\n+            ret ures_ok(expected);\n+        }\n+\n+        ret ures_err(terr_mismatch, expected, actual);\n+    }\n+\n+    fn unify_step(&hashmap[int,@ty.t] bindings, @ty.t expected, @ty.t actual,\n+                  &unify_handler handler) -> unify_result {\n+        // TODO: rewrite this using tuple pattern matching when available, to\n+        // avoid all this rightward drift and spikiness.\n+\n+        // If the RHS is a variable type, then just do the appropriate\n+        // binding.\n+        alt (actual.struct) {\n+            case (ty.ty_var(?actual_id)) {\n+                alt (bindings.find(actual_id)) {\n+                    case (some[@ty.t](?actual_ty)) {\n+                        // FIXME: change the binding here?\n+                        // FIXME: \"be\"\n+                        ret unify_step(bindings, expected, actual_ty,\n+                                       handler);\n+                    }\n+                    case (none[@ty.t]) {\n+                        bindings.insert(actual_id, expected);\n+                        ret ures_ok(expected);\n+                    }\n+                }\n+            }\n+            case (ty.ty_local(?actual_id)) {\n+                auto actual_ty = handler.resolve_local(actual_id);\n+                auto result = unify_step(bindings,\n+                                         expected,\n+                                         actual_ty,\n+                                         handler);\n+                alt (result) {\n+                    case (ures_ok(?result_ty)) {\n+                        handler.record_local(actual_id, result_ty);\n+                    }\n+                    case (_) { /* empty */ }\n+                }\n+                ret result;\n+            }\n+            case (_) { /* empty */ }\n+        }\n+\n+        alt (expected.struct) {\n+            case (ty.ty_nil)        { ret struct_cmp(expected, actual); }\n+            case (ty.ty_bool)       { ret struct_cmp(expected, actual); }\n+            case (ty.ty_int)        { ret struct_cmp(expected, actual); }\n+            case (ty.ty_uint)       { ret struct_cmp(expected, actual); }\n+            case (ty.ty_machine(_)) { ret struct_cmp(expected, actual); }\n+            case (ty.ty_char)       { ret struct_cmp(expected, actual); }\n+            case (ty.ty_str)        { ret struct_cmp(expected, actual); }\n+\n+            case (ty.ty_tag(?expected_id)) {\n+                alt (actual.struct) {\n+                    case (ty.ty_tag(?actual_id)) {\n+                        if (expected_id._0 == actual_id._0 &&\n+                                expected_id._1 == actual_id._1) {\n+                            ret ures_ok(expected);\n+                        }\n+                    }\n+                    case (_) { /* fall through */ }\n+                }\n+\n+                ret ures_err(terr_mismatch, expected, actual);\n+            }\n+\n+            case (ty.ty_box(?expected_sub)) {\n+                alt (actual.struct) {\n+                    case (ty.ty_box(?actual_sub)) {\n+                        auto result = unify_step(bindings,\n+                                                 expected_sub,\n+                                                 actual_sub,\n+                                                 handler);\n+                        alt (result) {\n+                            case (ures_ok(?result_sub)) {\n+                                ret ures_ok(plain_ty(ty.ty_box(result_sub)));\n+                            }\n+                            case (_) {\n+                                ret result;\n+                            }\n+                        }\n+                    }\n+\n+                    // TODO: ty_var\n+\n+                    case (_) {\n+                        ret ures_err(terr_mismatch, expected, actual);\n+                    }\n+                }\n+            }\n+\n+            case (ty.ty_vec(?expected_sub)) {\n+                alt (actual.struct) {\n+                    case (ty.ty_vec(?actual_sub)) {\n+                        auto result = unify_step(bindings,\n+                                                 expected_sub,\n+                                                 actual_sub,\n+                                                 handler);\n+                        alt (result) {\n+                            case (ures_ok(?result_sub)) {\n+                                ret ures_ok(plain_ty(ty.ty_vec(result_sub)));\n+                            }\n+                            case (_) {\n+                                ret result;\n+                            }\n+                        }\n+                    }\n+\n+                    // TODO: ty_var\n+\n+                    case (_) {\n+                        ret ures_err(terr_mismatch, expected, actual);\n+                   }\n+                }\n+            }\n+\n+            case (ty.ty_tup(?expected_elems)) {\n+                alt (actual.struct) {\n+                    case (ty.ty_tup(?actual_elems)) {\n+                        auto expected_len = _vec.len[@ty.t](expected_elems);\n+                        auto actual_len = _vec.len[@ty.t](actual_elems);\n+                        if (expected_len != actual_len) {\n+                            auto err = terr_tuple_size(expected_len,\n+                                                       actual_len);\n+                            ret ures_err(err, expected, actual);\n+                        }\n+\n+                        // TODO: implement an iterator that can iterate over\n+                        // two arrays simultaneously.\n+                        let vec[@ty.t] result_elems = vec();\n+                        auto i = 0u;\n+                        while (i < expected_len) {\n+                            auto expected_elem = expected_elems.(i);\n+                            auto actual_elem = actual_elems.(i);\n+                            if (expected_elem.mut != actual_elem.mut) {\n+                                auto err = terr_tuple_mutability;\n+                                ret ures_err(err, expected, actual);\n+                            }\n+\n+                            auto result = unify_step(bindings,\n+                                                     expected_elem,\n+                                                     actual_elem,\n+                                                     handler);\n+                            alt (result) {\n+                                case (ures_ok(?rty)) {\n+                                    append[@ty.t](result_elems,rty);\n+                                }\n+                                case (_) {\n+                                    ret result;\n+                                }\n+                            }\n+\n+                            i += 1u;\n+                        }\n+\n+                        ret ures_ok(plain_ty(ty.ty_tup(result_elems)));\n+                    }\n+\n+                    // TODO: ty_var\n+\n+                    case (_) {\n+                        ret ures_err(terr_mismatch, expected, actual);\n+                    }\n+                }\n+            }\n+\n+            case (ty.ty_rec(?expected_fields)) {\n+                alt (actual.struct) {\n+                    case (ty.ty_rec(?actual_fields)) {\n+                        auto expected_len = _vec.len[field](expected_fields);\n+                        auto actual_len = _vec.len[field](actual_fields);\n+                        if (expected_len != actual_len) {\n+                            auto err = terr_record_size(expected_len,\n+                                                        actual_len);\n+                            ret ures_err(err, expected, actual);\n+                        }\n+\n+                        // TODO: implement an iterator that can iterate over\n+                        // two arrays simultaneously.\n+                        let vec[field] result_fields = vec();\n+                        auto i = 0u;\n+                        while (i < expected_len) {\n+                            auto expected_field = expected_fields.(i);\n+                            auto actual_field = actual_fields.(i);\n+                            if (expected_field.ty.mut\n+                                != actual_field.ty.mut) {\n+                                auto err = terr_record_mutability;\n+                                ret ures_err(err, expected, actual);\n+                            }\n+\n+                            if (!_str.eq(expected_field.ident,\n+                                        actual_field.ident)) {\n+                                auto err =\n+                                    terr_record_fields(expected_field.ident,\n+                                                       actual_field.ident);\n+                                ret ures_err(err, expected, actual);\n+                            }\n+\n+                            auto result = unify_step(bindings,\n+                                                     expected_field.ty,\n+                                                     actual_field.ty,\n+                                                     handler);\n+                            alt (result) {\n+                                case (ures_ok(?rty)) {\n+                                    append[field]\n+                                        (result_fields,\n+                                         rec(ty=rty with expected_field));\n+                                }\n+                                case (_) {\n+                                    ret result;\n+                                }\n+                            }\n+\n+                            i += 1u;\n+                        }\n+\n+                        ret ures_ok(plain_ty(ty.ty_rec(result_fields)));\n+                    }\n+\n+                    // TODO: ty_var\n+\n+                    case (_) {\n+                        ret ures_err(terr_mismatch, expected, actual);\n+                    }\n+                }\n+            }\n+\n+            case (ty.ty_fn(?expected_inputs, ?expected_output)) {\n+                alt (actual.struct) {\n+                    case (ty.ty_fn(?actual_inputs, ?actual_output)) {\n+                        auto expected_len = _vec.len[arg](expected_inputs);\n+                        auto actual_len = _vec.len[arg](actual_inputs);\n+                        if (expected_len != actual_len) {\n+                            ret ures_err(terr_arg_count, expected, actual);\n+                        }\n+\n+                        // TODO: as above, we should have an iter2 iterator.\n+                        let vec[arg] result_ins = vec();\n+                        auto i = 0u;\n+                        while (i < expected_len) {\n+                            auto expected_input = expected_inputs.(i);\n+                            auto actual_input = actual_inputs.(i);\n+\n+                            // This should be safe, I think?\n+                            auto result_mode;\n+                            if (mode_is_alias(expected_input.mode) ||\n+                                    mode_is_alias(actual_input.mode)) {\n+                                result_mode = ast.alias;\n+                            } else {\n+                                result_mode = ast.val;\n+                            }\n+\n+                            auto result = unify_step(bindings,\n+                                                     actual_input.ty,\n+                                                     expected_input.ty,\n+                                                     handler);\n+\n+                            alt (result) {\n+                                case (ures_ok(?rty)) {\n+                                    result_ins += vec(rec(mode=result_mode,\n+                                                          ty=rty));\n+                                }\n+\n+                                case (_) {\n+                                    ret result;\n+                                }\n+                            }\n+\n+                            i += 1u;\n+                        }\n+\n+                        // Check the output.\n+                        auto result_out;\n+                        auto result = unify_step(bindings,\n+                                                 expected_output,\n+                                                 actual_output,\n+                                                 handler);\n+                        alt (result) {\n+                            case (ures_ok(?rty)) {\n+                                result_out = rty;\n+                            }\n+\n+                            case (_) {\n+                                ret result;\n+                            }\n+                        }\n+\n+                        auto t = plain_ty(ty.ty_fn(result_ins, result_out));\n+                        ret ures_ok(t);\n+                    }\n+\n+                    case (_) {\n+                        ret ures_err(terr_mismatch, expected, actual);\n+                    }\n+                }\n+            }\n+\n+            case (ty.ty_var(?expected_id)) {\n+                alt (bindings.find(expected_id)) {\n+                    case (some[@ty.t](?expected_ty)) {\n+                        // FIXME: change the binding here?\n+                        // FIXME: \"be\"\n+                        ret unify_step(bindings,\n+                                       expected_ty,\n+                                       actual,\n+                                       handler);\n+                    }\n+                    case (none[@ty.t]) {\n+                        bindings.insert(expected_id, actual);\n+                        ret ures_ok(actual);\n+                    }\n+                }\n+            }\n+\n+            case (ty.ty_local(?expected_id)) {\n+                auto expected_ty = handler.resolve_local(expected_id);\n+                auto result = unify_step(bindings,\n+                                         expected_ty,\n+                                         actual,\n+                                         handler);\n+                alt (result) {\n+                    case (ures_ok(?result_ty)) {\n+                        handler.record_local(expected_id, result_ty);\n+                    }\n+                    case (_) { /* empty */ }\n+                }\n+                ret result;\n+            }\n+\n+            case (ty.ty_param(?expected_id)) {\n+                ret handler.unify_expected_param(expected_id,\n+                                                 expected,\n+                                                 actual);\n+            }\n+        }\n+\n+        // TODO: remove me once match-exhaustiveness checking works\n+        fail;\n+    }\n+\n+    fn hash_int(&int x) -> uint { ret x as uint; }\n+    fn eq_int(&int a, &int b) -> bool { ret a == b; }\n+    auto hasher = hash_int;\n+    auto eqer = eq_int;\n+    auto bindings = map.mk_hashmap[int,@ty.t](hasher, eqer);\n+\n+    ret unify_step(bindings, expected, actual, handler);\n+}\n+\n+fn type_err_to_str(&ty.type_err err) -> str {\n+    alt (err) {\n+        case (terr_mismatch) {\n+            ret \"types differ\";\n+        }\n+        case (terr_tuple_size(?e_sz, ?a_sz)) {\n+            ret \"expected a tuple with \" + _uint.to_str(e_sz, 10u) +\n+                \" elements but found one with \" + _uint.to_str(a_sz, 10u) +\n+                \" elements\";\n+        }\n+        case (terr_tuple_mutability) {\n+            ret \"tuple elements differ in mutability\";\n+        }\n+        case (terr_record_size(?e_sz, ?a_sz)) {\n+            ret \"expected a record with \" + _uint.to_str(e_sz, 10u) +\n+                \" fields but found one with \" + _uint.to_str(a_sz, 10u) +\n+                \" fields\";\n+        }\n+        case (terr_record_mutability) {\n+            ret \"record elements differ in mutability\";\n+        }\n+        case (terr_record_fields(?e_fld, ?a_fld)) {\n+            ret \"expected a record with field '\" + e_fld +\n+                \"' but found one with field '\" + a_fld +\n+                \"'\";\n+        }\n+        case (terr_arg_count) {\n+            ret \"incorrect number of function parameters\";\n+        }\n+    }\n+}\n+"}, {"sha": "f3276090b57235475e4ea7a7720f350bc02a7fb9", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 24, "deletions": 411, "changes": 435, "blob_url": "https://github.com/rust-lang/rust/blob/0411132679b58ff3c177ccf24a22212881d6538d/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0411132679b58ff3c177ccf24a22212881d6538d/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=0411132679b58ff3c177ccf24a22212881d6538d", "patch": "@@ -25,7 +25,6 @@ import middle.ty.type_is_scalar;\n import std._str;\n import std._uint;\n import std._vec;\n-import std.map;\n import std.map.hashmap;\n import std.option;\n import std.option.none;\n@@ -43,21 +42,6 @@ type fn_ctxt = rec(@ty.t ret_ty,\n // Used for ast_ty_to_ty() below.\n type ty_getter = fn(ast.def_id) -> @ty.t;\n \n-tag type_err {\n-    terr_mismatch;\n-    terr_tuple_size(uint, uint);\n-    terr_tuple_mutability;\n-    terr_record_size(uint, uint);\n-    terr_record_mutability;\n-    terr_record_fields(ast.ident,ast.ident);\n-    terr_arg_count;\n-}\n-\n-tag unify_result {\n-    ures_ok(@ty.t);\n-    ures_err(type_err, @ty.t, @ty.t);\n-}\n-\n // Replaces parameter types inside a type with type variables.\n fn generalize_ty(@crate_ctxt cx, @ty.t t) -> @ty.t {\n     state obj ty_generalizer(@crate_ctxt cx,\n@@ -168,38 +152,6 @@ fn ast_ty_to_ty_crate(@crate_ctxt ccx, &@ast.ty ast_ty) -> @ty.t {\n     ret ast_ty_to_ty(f, ast_ty);\n }\n \n-fn type_err_to_str(&type_err err) -> str {\n-    alt (err) {\n-        case (terr_mismatch) {\n-            ret \"types differ\";\n-        }\n-        case (terr_tuple_size(?e_sz, ?a_sz)) {\n-            ret \"expected a tuple with \" + _uint.to_str(e_sz, 10u) +\n-                \" elements but found one with \" + _uint.to_str(a_sz, 10u) +\n-                \" elements\";\n-        }\n-        case (terr_tuple_mutability) {\n-            ret \"tuple elements differ in mutability\";\n-        }\n-        case (terr_record_size(?e_sz, ?a_sz)) {\n-            ret \"expected a record with \" + _uint.to_str(e_sz, 10u) +\n-                \" fields but found one with \" + _uint.to_str(a_sz, 10u) +\n-                \" fields\";\n-        }\n-        case (terr_record_mutability) {\n-            ret \"record elements differ in mutability\";\n-        }\n-        case (terr_record_fields(?e_fld, ?a_fld)) {\n-            ret \"expected a record with field '\" + e_fld +\n-                \"' but found one with field '\" + a_fld +\n-                \"'\";\n-        }\n-        case (terr_arg_count) {\n-            ret \"incorrect number of function parameters\";\n-        }\n-    }\n-}\n-\n // Item collection - a pair of bootstrap passes:\n //\n // 1. Collect the IDs of all type items (typedefs) and store them in a table.\n@@ -511,383 +463,44 @@ fn collect_item_types(@ast.crate crate) -> tup(@ast.crate, @ty_table) {\n     ret tup(crate_, item_to_ty);\n }\n \n-// Type unification\n-\n-fn unify(&@fn_ctxt fcx, @ty.t expected, @ty.t actual) -> unify_result {\n-    // Wraps the given type in an appropriate cname.\n-    //\n-    // TODO: This doesn't do anything yet. We should carry the cname up from\n-    // the expected and/or actual types when unification results in a type\n-    // identical to one or both of the two. The precise algorithm for this is\n-    // something we'll probably need to develop over time.\n-\n-    // Simple structural type comparison.\n-    fn struct_cmp(@ty.t expected, @ty.t actual) -> unify_result {\n-        if (expected.struct == actual.struct) {\n-            ret ures_ok(expected);\n-        }\n-\n-        ret ures_err(terr_mismatch, expected, actual);\n-    }\n-\n-    fn unify_step(&@fn_ctxt fcx, &hashmap[int,@ty.t] bindings, @ty.t expected,\n-                  @ty.t actual) -> unify_result {\n-        // TODO: rewrite this using tuple pattern matching when available, to\n-        // avoid all this rightward drift and spikiness.\n-\n-        // If the RHS is a variable type, then just do the appropriate\n-        // binding.\n-        alt (actual.struct) {\n-            case (ty.ty_var(?actual_id)) {\n-                alt (bindings.find(actual_id)) {\n-                    case (some[@ty.t](?actual_ty)) {\n-                        // FIXME: change the binding here?\n-                        // FIXME: \"be\"\n-                        ret unify_step(fcx, bindings, expected, actual_ty);\n-                    }\n-                    case (none[@ty.t]) {\n-                        bindings.insert(actual_id, expected);\n-                        ret ures_ok(expected);\n-                    }\n-                }\n-            }\n-            case (ty.ty_local(?actual_id)) {\n-                check (fcx.locals.contains_key(actual_id));\n-                auto actual_ty = fcx.locals.get(actual_id);\n-                auto result = unify_step(fcx, bindings, expected, actual_ty);\n-                alt (result) {\n-                    case (ures_ok(?result_ty)) {\n-                        fcx.locals.insert(actual_id, result_ty);\n-                    }\n-                    case (_) { /* empty */ }\n-                }\n-                ret result;\n-            }\n-            case (_) { /* empty */ }\n-        }\n-\n-        alt (expected.struct) {\n-            case (ty.ty_nil)        { ret struct_cmp(expected, actual); }\n-            case (ty.ty_bool)       { ret struct_cmp(expected, actual); }\n-            case (ty.ty_int)        { ret struct_cmp(expected, actual); }\n-            case (ty.ty_uint)       { ret struct_cmp(expected, actual); }\n-            case (ty.ty_machine(_)) { ret struct_cmp(expected, actual); }\n-            case (ty.ty_char)       { ret struct_cmp(expected, actual); }\n-            case (ty.ty_str)        { ret struct_cmp(expected, actual); }\n-\n-            case (ty.ty_tag(?expected_id)) {\n-                alt (actual.struct) {\n-                    case (ty.ty_tag(?actual_id)) {\n-                        if (expected_id._0 == actual_id._0 &&\n-                                expected_id._1 == actual_id._1) {\n-                            ret ures_ok(expected);\n-                        }\n-                    }\n-                    case (_) { /* fall through */ }\n-                }\n-\n-                ret ures_err(terr_mismatch, expected, actual);\n-            }\n-\n-            case (ty.ty_box(?expected_sub)) {\n-                alt (actual.struct) {\n-                    case (ty.ty_box(?actual_sub)) {\n-                        auto result = unify_step(fcx,\n-                                                 bindings,\n-                                                 expected_sub,\n-                                                 actual_sub);\n-                        alt (result) {\n-                            case (ures_ok(?result_sub)) {\n-                                ret ures_ok(plain_ty(ty.ty_box(result_sub)));\n-                            }\n-                            case (_) {\n-                                ret result;\n-                            }\n-                        }\n-                    }\n-\n-                    // TODO: ty_var\n-\n-                    case (_) {\n-                        ret ures_err(terr_mismatch, expected, actual);\n-                    }\n-                }\n-            }\n-\n-            case (ty.ty_vec(?expected_sub)) {\n-                alt (actual.struct) {\n-                    case (ty.ty_vec(?actual_sub)) {\n-                        auto result = unify_step(fcx,\n-                                                 bindings,\n-                                                 expected_sub,\n-                                                 actual_sub);\n-                        alt (result) {\n-                            case (ures_ok(?result_sub)) {\n-                                ret ures_ok(plain_ty(ty.ty_vec(result_sub)));\n-                            }\n-                            case (_) {\n-                                ret result;\n-                            }\n-                        }\n-                    }\n-\n-                    // TODO: ty_var\n-\n-                    case (_) {\n-                        ret ures_err(terr_mismatch, expected, actual);\n-                   }\n-                }\n-            }\n-\n-            case (ty.ty_tup(?expected_elems)) {\n-                alt (actual.struct) {\n-                    case (ty.ty_tup(?actual_elems)) {\n-                        auto expected_len = _vec.len[@ty.t](expected_elems);\n-                        auto actual_len = _vec.len[@ty.t](actual_elems);\n-                        if (expected_len != actual_len) {\n-                            auto err = terr_tuple_size(expected_len,\n-                                                       actual_len);\n-                            ret ures_err(err, expected, actual);\n-                        }\n-\n-                        // TODO: implement an iterator that can iterate over\n-                        // two arrays simultaneously.\n-                        let vec[@ty.t] result_elems = vec();\n-                        auto i = 0u;\n-                        while (i < expected_len) {\n-                            auto expected_elem = expected_elems.(i);\n-                            auto actual_elem = actual_elems.(i);\n-                            if (expected_elem.mut != actual_elem.mut) {\n-                                auto err = terr_tuple_mutability;\n-                                ret ures_err(err, expected, actual);\n-                            }\n-\n-                            auto result = unify_step(fcx,\n-                                                     bindings,\n-                                                     expected_elem,\n-                                                     actual_elem);\n-                            alt (result) {\n-                                case (ures_ok(?rty)) {\n-                                    append[@ty.t](result_elems,rty);\n-                                }\n-                                case (_) {\n-                                    ret result;\n-                                }\n-                            }\n-\n-                            i += 1u;\n-                        }\n-\n-                        ret ures_ok(plain_ty(ty.ty_tup(result_elems)));\n-                    }\n-\n-                    // TODO: ty_var\n-\n-                    case (_) {\n-                        ret ures_err(terr_mismatch, expected, actual);\n-                    }\n-                }\n-            }\n-\n-            case (ty.ty_rec(?expected_fields)) {\n-                alt (actual.struct) {\n-                    case (ty.ty_rec(?actual_fields)) {\n-                        auto expected_len = _vec.len[field](expected_fields);\n-                        auto actual_len = _vec.len[field](actual_fields);\n-                        if (expected_len != actual_len) {\n-                            auto err = terr_record_size(expected_len,\n-                                                        actual_len);\n-                            ret ures_err(err, expected, actual);\n-                        }\n-\n-                        // TODO: implement an iterator that can iterate over\n-                        // two arrays simultaneously.\n-                        let vec[field] result_fields = vec();\n-                        auto i = 0u;\n-                        while (i < expected_len) {\n-                            auto expected_field = expected_fields.(i);\n-                            auto actual_field = actual_fields.(i);\n-                            if (expected_field.ty.mut\n-                                != actual_field.ty.mut) {\n-                                auto err = terr_record_mutability;\n-                                ret ures_err(err, expected, actual);\n-                            }\n-\n-                            if (!_str.eq(expected_field.ident,\n-                                        actual_field.ident)) {\n-                                auto err =\n-                                    terr_record_fields(expected_field.ident,\n-                                                       actual_field.ident);\n-                                ret ures_err(err, expected, actual);\n-                            }\n-\n-                            auto result = unify_step(fcx,\n-                                                     bindings,\n-                                                     expected_field.ty,\n-                                                     actual_field.ty);\n-                            alt (result) {\n-                                case (ures_ok(?rty)) {\n-                                    append[field]\n-                                        (result_fields,\n-                                         rec(ty=rty with expected_field));\n-                                }\n-                                case (_) {\n-                                    ret result;\n-                                }\n-                            }\n-\n-                            i += 1u;\n-                        }\n-\n-                        ret ures_ok(plain_ty(ty.ty_rec(result_fields)));\n-                    }\n-\n-                    // TODO: ty_var\n-\n-                    case (_) {\n-                        ret ures_err(terr_mismatch, expected, actual);\n-                    }\n-                }\n-            }\n-\n-            case (ty.ty_fn(?expected_inputs, ?expected_output)) {\n-                alt (actual.struct) {\n-                    case (ty.ty_fn(?actual_inputs, ?actual_output)) {\n-                        auto expected_len = _vec.len[arg](expected_inputs);\n-                        auto actual_len = _vec.len[arg](actual_inputs);\n-                        if (expected_len != actual_len) {\n-                            ret ures_err(terr_arg_count, expected, actual);\n-                        }\n-\n-                        // TODO: as above, we should have an iter2 iterator.\n-                        let vec[arg] result_ins = vec();\n-                        auto i = 0u;\n-                        while (i < expected_len) {\n-                            auto expected_input = expected_inputs.(i);\n-                            auto actual_input = actual_inputs.(i);\n-\n-                            // This should be safe, I think?\n-                            auto result_mode;\n-                            if (mode_is_alias(expected_input.mode) ||\n-                                    mode_is_alias(actual_input.mode)) {\n-                                result_mode = ast.alias;\n-                            } else {\n-                                result_mode = ast.val;\n-                            }\n-\n-                            auto result = unify_step(fcx,\n-                                                     bindings,\n-                                                     actual_input.ty,\n-                                                     expected_input.ty);\n-\n-                            alt (result) {\n-                                case (ures_ok(?rty)) {\n-                                    result_ins += vec(rec(mode=result_mode,\n-                                                          ty=rty));\n-                                }\n-\n-                                case (_) {\n-                                    ret result;\n-                                }\n-                            }\n-\n-                            i += 1u;\n-                        }\n-\n-                        // Check the output.\n-                        auto result_out;\n-                        auto result = unify_step(fcx,\n-                                                 bindings,\n-                                                 expected_output,\n-                                                 actual_output);\n-                        alt (result) {\n-                            case (ures_ok(?rty)) {\n-                                result_out = rty;\n-                            }\n-\n-                            case (_) {\n-                                ret result;\n-                            }\n-                        }\n-\n-                        auto t = plain_ty(ty.ty_fn(result_ins, result_out));\n-                        ret ures_ok(t);\n-                    }\n-\n-                    case (_) {\n-                        ret ures_err(terr_mismatch, expected, actual);\n-                    }\n-                }\n-            }\n-\n-            case (ty.ty_var(?expected_id)) {\n-                alt (bindings.find(expected_id)) {\n-                    case (some[@ty.t](?expected_ty)) {\n-                        // FIXME: change the binding here?\n-                        // FIXME: \"be\"\n-                        ret unify_step(fcx, bindings, expected_ty, actual);\n-                    }\n-                    case (none[@ty.t]) {\n-                        bindings.insert(expected_id, actual);\n-                        ret ures_ok(actual);\n-                    }\n-                }\n-            }\n-\n-            case (ty.ty_local(?expected_id)) {\n-                check (fcx.locals.contains_key(expected_id));\n-                auto expected_ty = fcx.locals.get(expected_id);\n-                auto result = unify_step(fcx, bindings, expected_ty, actual);\n-                alt (result) {\n-                    case (ures_ok(?result_ty)) {\n-                        fcx.locals.insert(expected_id, result_ty);\n-                    }\n-                    case (_) { /* empty */ }\n-                }\n-                ret result;\n-            }\n-\n-            case (ty.ty_param(?expected_id)) {\n-                alt (actual.struct) {\n-                    case (ty.ty_param(?actual_id)) {\n-                        if (expected_id._0 == actual_id._0 &&\n-                                expected_id._1 == actual_id._1) {\n-                            ret ures_ok(expected);\n-                        }\n-                    }\n-                    case (_) {\n-                        ret ures_err(terr_mismatch, expected, actual);\n+fn unify(&@fn_ctxt fcx, @ty.t expected, @ty.t actual) -> ty.unify_result {\n+    obj unify_handler(@fn_ctxt fcx) {\n+        fn resolve_local(ast.def_id id) -> @ty.t {\n+            check (fcx.locals.contains_key(id));\n+            ret fcx.locals.get(id);\n+        }\n+        fn record_local(ast.def_id id, @ty.t t) {\n+            fcx.locals.insert(id, t);\n+        }\n+        fn unify_expected_param(ast.def_id id, @ty.t expected, @ty.t actual)\n+                -> ty.unify_result {\n+            alt (actual.struct) {\n+                case (ty.ty_param(?actual_id)) {\n+                    if (id._0 == actual_id._0 && id._1 == actual_id._1) {\n+                        ret ty.ures_ok(expected);\n                     }\n                 }\n+                case (_) { /* fall through */ }\n             }\n+            ret ty.ures_err(ty.terr_mismatch, expected, actual);\n         }\n-\n-        // TODO: remove me once match-exhaustiveness checking works\n-        fail;\n     }\n \n-    fn hash_int(&int x) -> uint { ret x as uint; }\n-    fn eq_int(&int a, &int b) -> bool { ret a == b; }\n-    auto hasher = hash_int;\n-    auto eqer = eq_int;\n-    auto bindings = map.mk_hashmap[int,@ty.t](hasher, eqer);\n-\n-    ret unify_step(fcx, bindings, expected, actual);\n+    auto handler = unify_handler(fcx);\n+    ret ty.unify(expected, actual, handler);\n }\n \n // Requires that the two types unify, and prints an error message if they\n // don't. Returns the unified type.\n fn demand(&@fn_ctxt fcx, &span sp, @ty.t expected, @ty.t actual) -> @ty.t {\n     alt (unify(fcx, expected, actual)) {\n-        case (ures_ok(?ty)) {\n-            ret ty;\n-        }\n+        case (ty.ures_ok(?t)) { ret t; }\n \n-        case (ures_err(?err, ?expected, ?actual)) {\n+        case (ty.ures_err(?err, ?expected, ?actual)) {\n             fcx.ccx.sess.span_err(sp, \"mismatched types: expected \"\n                                   + ty_to_str(expected) + \" but found \"\n                                   + ty_to_str(actual) + \" (\" +\n-                                  type_err_to_str(err) + \")\");\n+                                  ty.type_err_to_str(err) + \")\");\n \n             // TODO: In the future, try returning \"expected\", reporting the\n             // error, and continue.\n@@ -899,8 +512,8 @@ fn demand(&@fn_ctxt fcx, &span sp, @ty.t expected, @ty.t actual) -> @ty.t {\n // Returns true if the two types unify and false if they don't.\n fn are_compatible(&@fn_ctxt fcx, @ty.t expected, @ty.t actual) -> bool {\n     alt (unify(fcx, expected, actual)) {\n-        case (ures_ok(_))        { ret true;  }\n-        case (ures_err(_, _, _)) { ret false; }\n+        case (ty.ures_ok(_))        { ret true;  }\n+        case (ty.ures_err(_, _, _)) { ret false; }\n     }\n }\n "}]}