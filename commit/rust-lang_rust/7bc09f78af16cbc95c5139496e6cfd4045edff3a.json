{"sha": "7bc09f78af16cbc95c5139496e6cfd4045edff3a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdiYzA5Zjc4YWYxNmNiYzk1YzUxMzk0OTZlNmNmZDQwNDVlZGZmM2E=", "commit": {"author": {"name": "Julian Wollersberger", "email": "julian.wollersberger@gmx.at", "date": "2021-01-31T20:37:17Z"}, "committer": {"name": "Julian Wollersberger", "email": "julian.wollersberger@gmx.at", "date": "2021-01-31T20:37:17Z"}, "message": "Remove the remains of the query categories.", "tree": {"sha": "5ed6cfc8adc2a61328a8919d2d21208c9ae319e9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5ed6cfc8adc2a61328a8919d2d21208c9ae319e9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7bc09f78af16cbc95c5139496e6cfd4045edff3a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7bc09f78af16cbc95c5139496e6cfd4045edff3a", "html_url": "https://github.com/rust-lang/rust/commit/7bc09f78af16cbc95c5139496e6cfd4045edff3a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7bc09f78af16cbc95c5139496e6cfd4045edff3a/comments", "author": null, "committer": null, "parents": [{"sha": "0e63af5da3400ace48a0345117980473fd21ad73", "url": "https://api.github.com/repos/rust-lang/rust/commits/0e63af5da3400ace48a0345117980473fd21ad73", "html_url": "https://github.com/rust-lang/rust/commit/0e63af5da3400ace48a0345117980473fd21ad73"}], "stats": {"total": 146, "additions": 17, "deletions": 129}, "files": [{"sha": "92269920d29710f4fc416e1a5f85171f851c613c", "filename": "compiler/rustc_macros/src/query.rs", "status": "modified", "additions": 4, "deletions": 23, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/7bc09f78af16cbc95c5139496e6cfd4045edff3a/compiler%2Frustc_macros%2Fsrc%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc09f78af16cbc95c5139496e6cfd4045edff3a/compiler%2Frustc_macros%2Fsrc%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fquery.rs?ref=7bc09f78af16cbc95c5139496e6cfd4045edff3a", "patch": "@@ -189,25 +189,6 @@ impl<T: Parse> Parse for List<T> {\n     }\n }\n \n-/// A named group containing queries.\n-///\n-/// For now, the name is not used any more, but the capability remains interesting for future\n-/// developments of the query system.\n-struct Group {\n-    #[allow(unused)]\n-    name: Ident,\n-    queries: List<Query>,\n-}\n-\n-impl Parse for Group {\n-    fn parse(input: ParseStream<'_>) -> Result<Self> {\n-        let name: Ident = input.parse()?;\n-        let content;\n-        braced!(content in input);\n-        Ok(Group { name, queries: content.parse()? })\n-    }\n-}\n-\n struct QueryModifiers {\n     /// The description of the query.\n     desc: (Option<Ident>, Punctuated<Expr, Token![,]>),\n@@ -450,15 +431,15 @@ fn add_query_description_impl(\n }\n \n pub fn rustc_queries(input: TokenStream) -> TokenStream {\n-    let groups = parse_macro_input!(input as List<Group>);\n+    let queries = parse_macro_input!(input as List<Query>);\n \n     let mut query_stream = quote! {};\n     let mut query_description_stream = quote! {};\n     let mut dep_node_def_stream = quote! {};\n     let mut cached_queries = quote! {};\n \n-    for group in groups.0 {\n-        for mut query in group.queries.0 {\n+    //for group in groups.0 {\n+        for mut query in queries.0 {\n             let modifiers = process_modifiers(&mut query);\n             let name = &query.name;\n             let arg = &query.arg;\n@@ -516,7 +497,7 @@ pub fn rustc_queries(input: TokenStream) -> TokenStream {\n \n             add_query_description_impl(&query, modifiers, &mut query_description_stream);\n         }\n-    }\n+    //}\n \n     TokenStream::from(quote! {\n         macro_rules! rustc_query_append {"}, {"sha": "abaa60dec4a9638e98869abca95f64f95ea9c486", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 13, "deletions": 106, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/7bc09f78af16cbc95c5139496e6cfd4045edff3a/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7bc09f78af16cbc95c5139496e6cfd4045edff3a/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=7bc09f78af16cbc95c5139496e6cfd4045edff3a", "patch": "@@ -35,13 +35,10 @@ fn describe_as_module(def_id: LocalDefId, tcx: TyCtxt<'_>) -> String {\n // Queries marked with `fatal_cycle` do not need the latter implementation,\n // as they will raise an fatal error on query cycles instead.\n rustc_queries! {\n-    Other {\n         query trigger_delay_span_bug(key: DefId) -> () {\n             desc { \"trigger a delay span bug\" }\n         }\n-    }\n \n-    Other {\n         /// Represents crate as a whole (as distinct from the top-level crate module).\n         /// If you call `hir_crate` (e.g., indirectly by calling `tcx.hir().krate()`),\n         /// we will have to assume that any change means that you need to be recompiled.\n@@ -223,16 +220,12 @@ rustc_queries! {\n         query expn_that_defined(key: DefId) -> rustc_span::ExpnId {\n             desc { |tcx| \"expansion that defined `{}`\", tcx.def_path_str(key) }\n         }\n-    }\n \n-    Codegen {\n         query is_panic_runtime(_: CrateNum) -> bool {\n             fatal_cycle\n             desc { \"checking if the crate is_panic_runtime\" }\n         }\n-    }\n \n-    Codegen {\n         /// Set of all the `DefId`s in this crate that have MIR associated with\n         /// them. This includes all the body owners, but also things like struct\n         /// constructors.\n@@ -386,9 +379,7 @@ rustc_queries! {\n                 tcx.def_path_str(key.0.to_def_id()),\n             }\n         }\n-    }\n \n-    TypeChecking {\n         /// Erases regions from `ty` to yield a new type.\n         /// Normally you would just use `tcx.erase_regions(value)`,\n         /// however, which uses this query as a kind of cache.\n@@ -402,16 +393,12 @@ rustc_queries! {\n             anon\n             desc { \"erasing regions from `{:?}`\", ty }\n         }\n-    }\n \n-    Linking {\n         query wasm_import_module_map(_: CrateNum) -> FxHashMap<DefId, String> {\n             storage(ArenaCacheSelector<'tcx>)\n             desc { \"wasm import module map\" }\n         }\n-    }\n \n-    Other {\n         /// Maps from the `DefId` of an item (trait/struct/enum/fn) to the\n         /// predicates (where-clauses) directly defined on it. This is\n         /// equal to the `explicit_predicates_of` predicates plus the\n@@ -555,18 +542,14 @@ rustc_queries! {\n         query variances_of(def_id: DefId) -> &'tcx [ty::Variance] {\n             desc { |tcx| \"computing the variances of `{}`\", tcx.def_path_str(def_id) }\n         }\n-    }\n \n-    TypeChecking {\n         /// Maps from thee `DefId` of a type to its (inferred) outlives.\n         query inferred_outlives_crate(_: CrateNum)\n             -> ty::CratePredicatesMap<'tcx> {\n             storage(ArenaCacheSelector<'tcx>)\n             desc { \"computing the inferred outlives predicates for items in this crate\" }\n         }\n-    }\n-\n-    Other {\n+    \n         /// Maps from an impl/trait `DefId to a list of the `DefId`s of its items.\n         query associated_item_def_ids(key: DefId) -> &'tcx [DefId] {\n             desc { |tcx| \"collecting associated items of `{}`\", tcx.def_path_str(key) }\n@@ -596,19 +579,15 @@ rustc_queries! {\n         query issue33140_self_ty(key: DefId) -> Option<ty::Ty<'tcx>> {\n             desc { |tcx| \"computing Self type wrt issue #33140 `{}`\", tcx.def_path_str(key) }\n         }\n-    }\n-\n-    TypeChecking {\n+    \n         /// Maps a `DefId` of a type to a list of its inherent impls.\n         /// Contains implementations of methods that are inherent to a type.\n         /// Methods in these implementations don't need to be exported.\n         query inherent_impls(key: DefId) -> &'tcx [DefId] {\n             desc { |tcx| \"collecting inherent impls for `{}`\", tcx.def_path_str(key) }\n             eval_always\n         }\n-    }\n-\n-    TypeChecking {\n+    \n         /// The result of unsafety-checking this `LocalDefId`.\n         query unsafety_check_result(key: LocalDefId) -> &'tcx mir::UnsafetyCheckResult {\n             desc { |tcx| \"unsafety-checking `{}`\", tcx.def_path_str(key.to_def_id()) }\n@@ -634,9 +613,7 @@ rustc_queries! {\n         query fn_sig(key: DefId) -> ty::PolyFnSig<'tcx> {\n             desc { |tcx| \"computing function signature of `{}`\", tcx.def_path_str(key) }\n         }\n-    }\n-\n-    Other {\n+    \n         query lint_mod(key: LocalDefId) -> () {\n             desc { |tcx| \"linting {}\", describe_as_module(key, tcx) }\n         }\n@@ -693,9 +670,7 @@ rustc_queries! {\n             -> ty::adjustment::CoerceUnsizedInfo {\n                 desc { |tcx| \"computing CoerceUnsized info for `{}`\", tcx.def_path_str(key) }\n             }\n-    }\n-\n-    TypeChecking {\n+    \n         query typeck_item_bodies(_: CrateNum) -> () {\n             desc { \"type-checking all item bodies\" }\n         }\n@@ -723,26 +698,20 @@ rustc_queries! {\n                 typeck_results.map(|x| &*tcx.arena.alloc(x))\n             }\n         }\n-    }\n-\n-    Other {\n+    \n         query used_trait_imports(key: LocalDefId) -> &'tcx FxHashSet<LocalDefId> {\n             desc { |tcx| \"used_trait_imports `{}`\", tcx.def_path_str(key.to_def_id()) }\n             cache_on_disk_if { true }\n         }\n-    }\n-\n-    TypeChecking {\n+    \n         query has_typeck_results(def_id: DefId) -> bool {\n             desc { |tcx| \"checking whether `{}` has a body\", tcx.def_path_str(def_id) }\n         }\n \n         query coherent_trait(def_id: DefId) -> () {\n             desc { |tcx| \"coherence checking all impls of trait `{}`\", tcx.def_path_str(def_id) }\n         }\n-    }\n-\n-    BorrowChecking {\n+    \n         /// Borrow-checks the function body. If this is a closure, returns\n         /// additional requirements that the closure's creator must verify.\n         query mir_borrowck(key: LocalDefId) -> &'tcx mir::BorrowCheckResult<'tcx> {\n@@ -758,9 +727,7 @@ rustc_queries! {\n                 tcx.def_path_str(key.0.to_def_id())\n             }\n         }\n-    }\n-\n-    TypeChecking {\n+    \n         /// Gets a complete map from all types to their inherent impls.\n         /// Not meant to be used directly outside of coherence.\n         /// (Defined only for `LOCAL_CRATE`.)\n@@ -779,9 +746,7 @@ rustc_queries! {\n             eval_always\n             desc { \"check for overlap between inherent impls defined in this crate\" }\n         }\n-    }\n-\n-    Other {\n+    \n         /// Check whether the function has any recursion that could cause the inliner to trigger\n         /// a cycle. Returns the call stack causing the cycle. The call stack does not contain the\n         /// current function, just all intermediate functions.\n@@ -855,9 +820,7 @@ rustc_queries! {\n         ) -> Result<&'tcx ty::Const<'tcx>, LitToConstError> {\n             desc { \"converting literal to const\" }\n         }\n-    }\n-\n-    TypeChecking {\n+    \n         query check_match(key: DefId) {\n             desc { |tcx| \"match-checking `{}`\", tcx.def_path_str(key) }\n             cache_on_disk_if { key.is_local() }\n@@ -872,9 +835,7 @@ rustc_queries! {\n             eval_always\n             desc { \"checking for private elements in public interfaces\" }\n         }\n-    }\n-\n-    Other {\n+    \n         query reachable_set(_: CrateNum) -> FxHashSet<LocalDefId> {\n             storage(ArenaCacheSelector<'tcx>)\n             desc { \"reachability\" }\n@@ -932,17 +893,13 @@ rustc_queries! {\n         query item_attrs(def_id: DefId) -> &'tcx [ast::Attribute] {\n             desc { |tcx| \"collecting attributes of `{}`\", tcx.def_path_str(def_id) }\n         }\n-    }\n-\n-    Codegen {\n+    \n         query codegen_fn_attrs(def_id: DefId) -> CodegenFnAttrs {\n             desc { |tcx| \"computing codegen attributes of `{}`\", tcx.def_path_str(def_id) }\n             storage(ArenaCacheSelector<'tcx>)\n             cache_on_disk_if { true }\n         }\n-    }\n \n-    Other {\n         query fn_arg_names(def_id: DefId) -> &'tcx [rustc_span::symbol::Ident] {\n             desc { |tcx| \"looking up function parameter names for `{}`\", tcx.def_path_str(def_id) }\n         }\n@@ -954,33 +911,25 @@ rustc_queries! {\n         query impl_parent(def_id: DefId) -> Option<DefId> {\n             desc { |tcx| \"computing specialization parent impl of `{}`\", tcx.def_path_str(def_id) }\n         }\n-    }\n \n-    TypeChecking {\n         /// Given an `associated_item`, find the trait it belongs to.\n         /// Return `None` if the `DefId` is not an associated item.\n         query trait_of_item(associated_item: DefId) -> Option<DefId> {\n             desc { |tcx| \"finding trait defining `{}`\", tcx.def_path_str(associated_item) }\n         }\n-    }\n \n-    Codegen {\n         query is_ctfe_mir_available(key: DefId) -> bool {\n             desc { |tcx| \"checking if item has ctfe mir available: `{}`\", tcx.def_path_str(key) }\n         }\n         query is_mir_available(key: DefId) -> bool {\n             desc { |tcx| \"checking if item has mir available: `{}`\", tcx.def_path_str(key) }\n         }\n-    }\n \n-    Other {\n         query vtable_methods(key: ty::PolyTraitRef<'tcx>)\n                             -> &'tcx [Option<(DefId, SubstsRef<'tcx>)>] {\n             desc { |tcx| \"finding all methods for trait {}\", tcx.def_path_str(key.def_id()) }\n         }\n-    }\n \n-    Codegen {\n         query codegen_fulfill_obligation(\n             key: (ty::ParamEnv<'tcx>, ty::PolyTraitRef<'tcx>)\n         ) -> Result<ImplSource<'tcx, ()>, ErrorReported> {\n@@ -990,9 +939,7 @@ rustc_queries! {\n                 tcx.def_path_str(key.1.def_id())\n             }\n         }\n-    }\n \n-    TypeChecking {\n         /// Return all `impl` blocks in the current crate.\n         ///\n         /// To allow caching this between crates, you must pass in [`LOCAL_CRATE`] as the crate number.\n@@ -1077,9 +1024,7 @@ rustc_queries! {\n         ) -> Result<&'tcx rustc_target::abi::Layout, ty::layout::LayoutError<'tcx>> {\n             desc { \"computing layout of `{}`\", env.value }\n         }\n-    }\n \n-    Other {\n         query dylib_dependency_formats(_: CrateNum)\n                                         -> &'tcx [(CrateNum, LinkagePreference)] {\n             desc { \"dylib dependency formats of crate\" }\n@@ -1090,9 +1035,7 @@ rustc_queries! {\n         {\n             desc { \"get the linkage format of all dependencies\" }\n         }\n-    }\n \n-    Codegen {\n         query is_compiler_builtins(_: CrateNum) -> bool {\n             fatal_cycle\n             desc { \"checking if the crate is_compiler_builtins\" }\n@@ -1126,9 +1069,7 @@ rustc_queries! {\n             eval_always\n             desc { \"getting crate's ExternCrateData\" }\n         }\n-    }\n \n-    TypeChecking {\n         query specializes(_: (DefId, DefId)) -> bool {\n             desc { \"computing whether impls specialize one another\" }\n         }\n@@ -1137,16 +1078,12 @@ rustc_queries! {\n             eval_always\n             desc { \"traits in scope at a block\" }\n         }\n-    }\n \n-    Other {\n         query module_exports(def_id: LocalDefId) -> Option<&'tcx [Export<LocalDefId>]> {\n             desc { |tcx| \"looking up items exported by `{}`\", tcx.def_path_str(def_id.to_def_id()) }\n             eval_always\n         }\n-    }\n \n-    TypeChecking {\n         query impl_defaultness(def_id: DefId) -> hir::Defaultness {\n             desc { |tcx| \"looking up whether `{}` is a default impl\", tcx.def_path_str(def_id) }\n         }\n@@ -1160,10 +1097,7 @@ rustc_queries! {\n         query check_impl_item_well_formed(key: LocalDefId) -> () {\n             desc { |tcx| \"checking that `{}` is well-formed\", tcx.def_path_str(key.to_def_id()) }\n         }\n-    }\n \n-\n-    Linking {\n         // The `DefId`s of all non-generic functions and statics in the given crate\n         // that can be reached from outside the crate.\n         //\n@@ -1190,9 +1124,7 @@ rustc_queries! {\n                 tcx.def_path_str(def_id),\n             }\n         }\n-    }\n \n-    Codegen {\n         /// The entire set of monomorphizations the local crate can safely link\n         /// to because they are exported from upstream crates. Do not depend on\n         /// this directly, as its value changes anytime a monomorphization gets\n@@ -1239,9 +1171,7 @@ rustc_queries! {\n         query upstream_drop_glue_for(substs: SubstsRef<'tcx>) -> Option<CrateNum> {\n             desc { \"available upstream drop-glue for `{:?}`\", substs }\n         }\n-    }\n \n-    Other {\n         query foreign_modules(_: CrateNum) -> Lrc<FxHashMap<DefId, ForeignModule>> {\n             desc { \"looking up the foreign modules of a linked crate\" }\n         }\n@@ -1283,9 +1213,7 @@ rustc_queries! {\n             eval_always\n             desc { \"looking up the paths for extern crates\" }\n         }\n-    }\n \n-    TypeChecking {\n         /// Given a crate and a trait, look up all impls of that trait in the crate.\n         /// Return `(impl_id, self_ty)`.\n         query implementations_of_trait(_: (CrateNum, DefId))\n@@ -1299,9 +1227,7 @@ rustc_queries! {\n             -> &'tcx [(DefId, Option<ty::fast_reject::SimplifiedType>)] {\n             desc { \"looking up all (?) trait implementations\" }\n         }\n-    }\n \n-    Other {\n         query is_dllimport_foreign_item(def_id: DefId) -> bool {\n             desc { |tcx| \"is_dllimport_foreign_item({})\", tcx.def_path_str(def_id) }\n         }\n@@ -1312,16 +1238,12 @@ rustc_queries! {\n             -> Option<NativeLibKind> {\n             desc { |tcx| \"native_library_kind({})\", tcx.def_path_str(def_id) }\n         }\n-    }\n \n-    Linking {\n         query link_args(_: CrateNum) -> Lrc<Vec<String>> {\n             eval_always\n             desc { \"looking up link arguments for a crate\" }\n         }\n-    }\n \n-    BorrowChecking {\n         /// Lifetime resolution. See `middle::resolve_lifetimes`.\n         query resolve_lifetimes(_: CrateNum) -> ResolveLifetimes {\n             storage(ArenaCacheSelector<'tcx>)\n@@ -1339,9 +1261,7 @@ rustc_queries! {\n             -> Option<&'tcx FxHashMap<ItemLocalId, Vec<ObjectLifetimeDefault>>> {\n             desc { \"looking up lifetime defaults for a region\" }\n         }\n-    }\n \n-    TypeChecking {\n         query visibility(def_id: DefId) -> ty::Visibility {\n             eval_always\n             desc { |tcx| \"computing visibility of `{}`\", tcx.def_path_str(def_id) }\n@@ -1355,9 +1275,7 @@ rustc_queries! {\n         ) -> ty::inhabitedness::DefIdForest {\n             desc { \"computing the inhabitedness of `{:?}`\", key }\n         }\n-    }\n \n-    Other {\n         query dep_kind(_: CrateNum) -> CrateDepKind {\n             eval_always\n             desc { \"fetching what a dependency looks like\" }\n@@ -1470,9 +1388,7 @@ rustc_queries! {\n         query all_traits(_: CrateNum) -> &'tcx [DefId] {\n             desc { \"fetching all foreign and local traits\" }\n         }\n-    }\n \n-    Linking {\n         /// The list of symbols exported from the given crate.\n         ///\n         /// - All names contained in `exported_symbols(cnum)` are guaranteed to\n@@ -1482,9 +1398,7 @@ rustc_queries! {\n             -> &'tcx [(ExportedSymbol<'tcx>, SymbolExportLevel)] {\n             desc { \"exported_symbols\" }\n         }\n-    }\n \n-    Codegen {\n         query collect_and_partition_mono_items(_: CrateNum)\n             -> (&'tcx DefIdSet, &'tcx [CodegenUnit<'tcx>]) {\n             eval_always\n@@ -1506,16 +1420,12 @@ rustc_queries! {\n         query backend_optimization_level(_: CrateNum) -> OptLevel {\n             desc { \"optimization level used by backend\" }\n         }\n-    }\n \n-    Other {\n         query output_filenames(_: CrateNum) -> Arc<OutputFilenames> {\n             eval_always\n             desc { \"output_filenames\" }\n         }\n-    }\n \n-    TypeChecking {\n         /// Do not call this query directly: invoke `normalize` instead.\n         query normalize_projection_ty(\n             goal: CanonicalProjectionGoal<'tcx>\n@@ -1667,9 +1577,7 @@ rustc_queries! {\n         ) -> MethodAutoderefStepsResult<'tcx> {\n             desc { \"computing autoderef types for `{:?}`\", goal }\n         }\n-    }\n \n-    Other {\n         query supported_target_features(_: CrateNum) -> FxHashMap<String, Option<Symbol>> {\n             storage(ArenaCacheSelector<'tcx>)\n             eval_always\n@@ -1714,5 +1622,4 @@ rustc_queries! {\n         query normalize_opaque_types(key: &'tcx ty::List<ty::Predicate<'tcx>>) -> &'tcx ty::List<ty::Predicate<'tcx>> {\n             desc { \"normalizing opaque types in {:?}\", key }\n         }\n-    }\n }"}]}