{"sha": "76c3e8a38cea2fe6342d83158c267e57a6b1f53f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc2YzNlOGEzOGNlYTJmZTYzNDJkODMxNThjMjY3ZTU3YTZiMWY1M2Y=", "commit": {"author": {"name": "Marvin L\u00f6bel", "email": "loebel.marvin@gmail.com", "date": "2013-09-14T17:37:45Z"}, "committer": {"name": "Marvin L\u00f6bel", "email": "loebel.marvin@gmail.com", "date": "2013-09-16T14:57:50Z"}, "message": "Add an SendStr type\n\nA SendStr is a string that can hold either a ~str or a &'static str.\nThis can be useful as an optimization when an allocation is sometimes needed but the common case is statically known.\n\nPossible use cases include Maps with both static and owned keys, or propagating error messages across task boundaries.\n\nSendStr implements most basic traits in a way that hides the fact that it is an enum; in particular things like order and equality are only determined by the content of the wrapped strings.\n\nReplaced std::rt:logging::SendableString with SendStr\nAdded tests for using an SendStr as key in Hash- and Treemaps", "tree": {"sha": "db7c6ca84a3e769ed40343411ecf43f369883418", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/db7c6ca84a3e769ed40343411ecf43f369883418"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/76c3e8a38cea2fe6342d83158c267e57a6b1f53f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/76c3e8a38cea2fe6342d83158c267e57a6b1f53f", "html_url": "https://github.com/rust-lang/rust/commit/76c3e8a38cea2fe6342d83158c267e57a6b1f53f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/76c3e8a38cea2fe6342d83158c267e57a6b1f53f/comments", "author": {"login": "Kimundi", "id": 2903206, "node_id": "MDQ6VXNlcjI5MDMyMDY=", "avatar_url": "https://avatars.githubusercontent.com/u/2903206?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Kimundi", "html_url": "https://github.com/Kimundi", "followers_url": "https://api.github.com/users/Kimundi/followers", "following_url": "https://api.github.com/users/Kimundi/following{/other_user}", "gists_url": "https://api.github.com/users/Kimundi/gists{/gist_id}", "starred_url": "https://api.github.com/users/Kimundi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Kimundi/subscriptions", "organizations_url": "https://api.github.com/users/Kimundi/orgs", "repos_url": "https://api.github.com/users/Kimundi/repos", "events_url": "https://api.github.com/users/Kimundi/events{/privacy}", "received_events_url": "https://api.github.com/users/Kimundi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Kimundi", "id": 2903206, "node_id": "MDQ6VXNlcjI5MDMyMDY=", "avatar_url": "https://avatars.githubusercontent.com/u/2903206?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Kimundi", "html_url": "https://github.com/Kimundi", "followers_url": "https://api.github.com/users/Kimundi/followers", "following_url": "https://api.github.com/users/Kimundi/following{/other_user}", "gists_url": "https://api.github.com/users/Kimundi/gists{/gist_id}", "starred_url": "https://api.github.com/users/Kimundi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Kimundi/subscriptions", "organizations_url": "https://api.github.com/users/Kimundi/orgs", "repos_url": "https://api.github.com/users/Kimundi/repos", "events_url": "https://api.github.com/users/Kimundi/events{/privacy}", "received_events_url": "https://api.github.com/users/Kimundi/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3e1803f3af1adc1b2e5595650f6920f40bbedc2e", "url": "https://api.github.com/repos/rust-lang/rust/commits/3e1803f3af1adc1b2e5595650f6920f40bbedc2e", "html_url": "https://github.com/rust-lang/rust/commit/3e1803f3af1adc1b2e5595650f6920f40bbedc2e"}], "stats": {"total": 422, "additions": 406, "deletions": 16}, "files": [{"sha": "b39b3102a343a3982d846d853e7d9b2d38c193a8", "filename": "src/libstd/logging.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/76c3e8a38cea2fe6342d83158c267e57a6b1f53f/src%2Flibstd%2Flogging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76c3e8a38cea2fe6342d83158c267e57a6b1f53f/src%2Flibstd%2Flogging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flogging.rs?ref=76c3e8a38cea2fe6342d83158c267e57a6b1f53f", "patch": "@@ -13,7 +13,8 @@\n use option::*;\n use os;\n use rt;\n-use rt::logging::{Logger, StdErrLogger, OwnedString};\n+use rt::logging::{Logger, StdErrLogger};\n+use send_str::SendStrOwned;\n \n /// Turns on logging to stdout globally\n pub fn console_on() {\n@@ -56,12 +57,12 @@ fn newsched_log_str(msg: ~str) {\n         match optional_task {\n             Some(local) => {\n                 // Use the available logger\n-                (*local).logger.log(OwnedString(msg));\n+                (*local).logger.log(SendStrOwned(msg));\n             }\n             None => {\n                 // There is no logger anywhere, just write to stderr\n                 let mut logger = StdErrLogger;\n-                logger.log(OwnedString(msg));\n+                logger.log(SendStrOwned(msg));\n             }\n         }\n     }"}, {"sha": "1672f0a902e71282f767c97aa6178e1237808373", "filename": "src/libstd/prelude.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/76c3e8a38cea2fe6342d83158c267e57a6b1f53f/src%2Flibstd%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76c3e8a38cea2fe6342d83158c267e57a6b1f53f/src%2Flibstd%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude.rs?ref=76c3e8a38cea2fe6342d83158c267e57a6b1f53f", "patch": "@@ -66,6 +66,7 @@ pub use path::PosixPath;\n pub use path::WindowsPath;\n pub use ptr::RawPtr;\n pub use ascii::{Ascii, AsciiCast, OwnedAsciiCast, AsciiStr, ToBytesConsume};\n+pub use send_str::{SendStr, SendStrOwned, SendStrStatic, IntoSendStr};\n pub use str::{Str, StrVector, StrSlice, OwnedStr};\n pub use from_str::FromStr;\n pub use to_bytes::IterBytes;"}, {"sha": "fbe05267cf4f9ff9bafef3b088c6e2d612b0e7bb", "filename": "src/libstd/rt/logging.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/76c3e8a38cea2fe6342d83158c267e57a6b1f53f/src%2Flibstd%2Frt%2Flogging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76c3e8a38cea2fe6342d83158c267e57a6b1f53f/src%2Flibstd%2Frt%2Flogging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flogging.rs?ref=76c3e8a38cea2fe6342d83158c267e57a6b1f53f", "patch": "@@ -17,6 +17,7 @@ use str::raw::from_c_str;\n use u32;\n use vec::ImmutableVector;\n use cast::transmute;\n+use send_str::{SendStr, SendStrOwned, SendStrStatic};\n \n struct LogDirective {\n     name: Option<~str>,\n@@ -168,32 +169,26 @@ fn update_log_settings(crate_map: *u8, settings: ~str) {\n     }\n }\n \n-/// Represent a string with `Send` bound.\n-pub enum SendableString {\n-    OwnedString(~str),\n-    StaticString(&'static str)\n-}\n-\n pub trait Logger {\n-    fn log(&mut self, msg: SendableString);\n+    fn log(&mut self, msg: SendStr);\n }\n \n pub struct StdErrLogger;\n \n impl Logger for StdErrLogger {\n-    fn log(&mut self, msg: SendableString) {\n+    fn log(&mut self, msg: SendStr) {\n         use io::{Writer, WriterUtil};\n \n         if !should_log_console() {\n             return;\n         }\n \n         let s: &str = match msg {\n-            OwnedString(ref s) => {\n+            SendStrOwned(ref s) => {\n                 let slc: &str = *s;\n                 slc\n             },\n-            StaticString(s) => s,\n+            SendStrStatic(s) => s,\n         };\n \n         // Truncate the string"}, {"sha": "1b7d0a40e1cd9254d227b9127dbc821a09fe0cfe", "filename": "src/libstd/send_str.rs", "status": "added", "additions": 223, "deletions": 0, "changes": 223, "blob_url": "https://github.com/rust-lang/rust/blob/76c3e8a38cea2fe6342d83158c267e57a6b1f53f/src%2Flibstd%2Fsend_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76c3e8a38cea2fe6342d83158c267e57a6b1f53f/src%2Flibstd%2Fsend_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsend_str.rs?ref=76c3e8a38cea2fe6342d83158c267e57a6b1f53f", "patch": "@@ -0,0 +1,223 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! `SendStr` definition and trait implementations\n+\n+use clone::{Clone, DeepClone};\n+use cmp::{Eq, TotalEq, Ord, TotalOrd, Equiv};\n+use cmp::{Ordering, Less};\n+use container::Container;\n+use default::Default;\n+use str::{Str, StrSlice};\n+use to_str::ToStr;\n+use to_bytes::{IterBytes, Cb};\n+\n+/// A SendStr is a string that can hold either a ~str or a &'static str.\n+/// This can be useful as an optimization when an allocation is sometimes\n+/// needed but the common case is statically known.\n+pub enum SendStr {\n+    SendStrOwned(~str),\n+    SendStrStatic(&'static str)\n+}\n+\n+impl SendStr {\n+    /// Returns `true` if this `SendStr` wraps an owned string\n+    #[inline]\n+    pub fn is_owned(&self) -> bool {\n+        match *self {\n+            SendStrOwned(_) => true,\n+            SendStrStatic(_) => false\n+        }\n+    }\n+\n+    /// Returns `true` if this `SendStr` wraps an static string\n+    #[inline]\n+    pub fn is_static(&self) -> bool {\n+        match *self {\n+            SendStrOwned(_) => false,\n+            SendStrStatic(_) => true\n+        }\n+    }\n+}\n+\n+/// Trait for moving into an `SendStr`\n+pub trait IntoSendStr {\n+    /// Moves self into an `SendStr`\n+    fn into_send_str(self) -> SendStr;\n+}\n+\n+impl IntoSendStr for ~str {\n+    #[inline]\n+    fn into_send_str(self) -> SendStr { SendStrOwned(self) }\n+}\n+\n+impl IntoSendStr for &'static str {\n+    #[inline]\n+    fn into_send_str(self) -> SendStr { SendStrStatic(self) }\n+}\n+\n+/*\n+Section: string trait impls\n+\n+`SendStr `should behave like a normal string, so we don't derive.\n+*/\n+\n+impl ToStr for SendStr {\n+    #[inline]\n+    fn to_str(&self) -> ~str { self.as_slice().to_owned() }\n+}\n+\n+impl Eq for SendStr {\n+    #[inline]\n+    fn eq(&self, other: &SendStr) -> bool {\n+        self.as_slice().equals(&other.as_slice())\n+    }\n+}\n+\n+impl TotalEq for SendStr {\n+    #[inline]\n+    fn equals(&self, other: &SendStr) -> bool {\n+        self.as_slice().equals(&other.as_slice())\n+    }\n+}\n+\n+impl Ord for SendStr {\n+    #[inline]\n+    fn lt(&self, other: &SendStr) -> bool { self.cmp(other) == Less }\n+}\n+\n+impl TotalOrd for SendStr {\n+    #[inline]\n+    fn cmp(&self, other: &SendStr) -> Ordering {\n+        self.as_slice().cmp(&other.as_slice())\n+    }\n+}\n+\n+impl<'self, S: Str> Equiv<S> for SendStr {\n+    #[inline]\n+    fn equiv(&self, other: &S) -> bool {\n+        self.as_slice().equals(&other.as_slice())\n+    }\n+}\n+\n+impl Str for SendStr {\n+    #[inline]\n+    fn as_slice<'r>(&'r self) -> &'r str {\n+        match *self {\n+            SendStrOwned(ref s) => s.as_slice(),\n+            // XXX: Borrowchecker doesn't recognize lifetime as static unless prompted\n+            // SendStrStatic(s) => s.as_slice()\n+            SendStrStatic(s)    => {let tmp: &'static str = s; tmp}\n+        }\n+    }\n+\n+    #[inline]\n+    fn into_owned(self) -> ~str {\n+        match self {\n+            SendStrOwned(s)  => s,\n+            SendStrStatic(s) => s.to_owned()\n+        }\n+    }\n+}\n+\n+impl Container for SendStr {\n+    #[inline]\n+    fn len(&self) -> uint { self.as_slice().len() }\n+}\n+\n+impl Clone for SendStr {\n+    #[inline]\n+    fn clone(&self) -> SendStr {\n+        match *self {\n+            SendStrOwned(ref s) => SendStrOwned(s.to_owned()),\n+            SendStrStatic(s)    => SendStrStatic(s)\n+        }\n+    }\n+}\n+\n+impl DeepClone for SendStr {\n+    #[inline]\n+    fn deep_clone(&self) -> SendStr {\n+        match *self {\n+            SendStrOwned(ref s) => SendStrOwned(s.to_owned()),\n+            SendStrStatic(s)    => SendStrStatic(s)\n+        }\n+    }\n+}\n+\n+impl Default for SendStr {\n+    #[inline]\n+    fn default() -> SendStr { SendStrStatic(\"\") }\n+}\n+\n+impl IterBytes for SendStr {\n+    #[inline]\n+    fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n+        match *self {\n+            SendStrOwned(ref s) => s.iter_bytes(lsb0, f),\n+            SendStrStatic(s)    => s.iter_bytes(lsb0, f)\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use clone::{Clone, DeepClone};\n+    use cmp::{TotalEq, Ord, TotalOrd, Equiv};\n+    use cmp::Equal;\n+    use container::Container;\n+    use default::Default;\n+    use send_str::{SendStrOwned, SendStrStatic};\n+    use str::Str;\n+    use to_str::ToStr;\n+\n+    #[test]\n+    fn test_send_str() {\n+        let s = SendStrStatic(\"abcde\");\n+        assert_eq!(s.len(), 5);\n+        assert_eq!(s.as_slice(), \"abcde\");\n+        assert_eq!(s.to_str(), ~\"abcde\");\n+        assert!(s.equiv(&@\"abcde\"));\n+        assert!(s.lt(&SendStrOwned(~\"bcdef\")));\n+        assert_eq!(SendStrStatic(\"\"), Default::default());\n+        assert!(s.is_static());\n+        assert!(!s.is_owned());\n+\n+        assert_eq!(s.clone(), s.clone());\n+        assert_eq!(s.clone().into_owned(), ~\"abcde\");\n+        assert_eq!(s.clone().deep_clone(), s.clone());\n+\n+        let o = SendStrOwned(~\"abcde\");\n+        assert_eq!(o.len(), 5);\n+        assert_eq!(o.as_slice(), \"abcde\");\n+        assert_eq!(o.to_str(), ~\"abcde\");\n+        assert!(o.equiv(&@\"abcde\"));\n+        assert!(o.lt(&SendStrStatic(\"bcdef\")));\n+        assert_eq!(SendStrOwned(~\"\"), Default::default());\n+        assert!(!o.is_static());\n+        assert!(o.is_owned());\n+\n+        assert_eq!(o.clone(), o.clone());\n+        assert_eq!(o.clone().into_owned(), ~\"abcde\");\n+        assert_eq!(o.clone().deep_clone(), o.clone());\n+\n+        assert_eq!(s.cmp(&o), Equal);\n+        assert!(s.equals(&o));\n+        assert!(s.equiv(&o));\n+        assert_eq!(o.cmp(&s), Equal);\n+        assert!(o.equals(&s));\n+        assert!(o.equiv(&s));\n+\n+        assert_eq!(\"abcde\".into_send_str(), SendStrStatic(\"abcde\"));\n+        assert_eq!((~\"abcde\").into_send_str(), SendStrStatic(\"abcde\"));\n+        assert_eq!(\"abcde\".into_send_str(), SendStrOwned(~\"abcde\"));\n+        assert_eq!((~\"abcde\").into_send_str(), SendStrOwned(~\"abcde\"));\n+    }\n+}"}, {"sha": "05433c4705983b9545f33f6d5a19a2b92e2fe237", "filename": "src/libstd/std.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/76c3e8a38cea2fe6342d83158c267e57a6b1f53f/src%2Flibstd%2Fstd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76c3e8a38cea2fe6342d83158c267e57a6b1f53f/src%2Flibstd%2Fstd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstd.rs?ref=76c3e8a38cea2fe6342d83158c267e57a6b1f53f", "patch": "@@ -121,6 +121,7 @@ pub mod str;\n \n #[path = \"str/ascii.rs\"]\n pub mod ascii;\n+pub mod send_str;\n \n pub mod ptr;\n pub mod owned;"}, {"sha": "ccb39c605eb062bd3c4c9ea60fda544483a81dfc", "filename": "src/libstd/str.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/76c3e8a38cea2fe6342d83158c267e57a6b1f53f/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76c3e8a38cea2fe6342d83158c267e57a6b1f53f/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=76c3e8a38cea2fe6342d83158c267e57a6b1f53f", "patch": "@@ -37,6 +37,7 @@ use unstable::raw::{Repr, Slice};\n use vec;\n use vec::{OwnedVector, OwnedCopyableVector, ImmutableVector, MutableVector};\n use default::Default;\n+use send_str::{SendStr, SendStrOwned};\n \n /*\n Section: Conditions\n@@ -130,10 +131,12 @@ impl ToStr for ~str {\n     #[inline]\n     fn to_str(&self) -> ~str { self.to_owned() }\n }\n+\n impl<'self> ToStr for &'self str {\n     #[inline]\n     fn to_str(&self) -> ~str { self.to_owned() }\n }\n+\n impl ToStr for @str {\n     #[inline]\n     fn to_str(&self) -> ~str { self.to_owned() }\n@@ -330,7 +333,6 @@ impl<'self> DoubleEndedIterator<char> for CharIterator<'self> {\n     }\n }\n \n-\n /// External iterator for a string's characters and their byte offsets.\n /// Use with the `std::iterator` module.\n #[deriving(Clone)]\n@@ -1355,6 +1357,7 @@ pub trait StrSlice<'self> {\n     fn to_owned(&self) -> ~str;\n     fn to_managed(&self) -> @str;\n     fn to_utf16(&self) -> ~[u16];\n+    fn to_send_str(&self) -> SendStr;\n     fn is_char_boundary(&self, index: uint) -> bool;\n     fn char_range_at(&self, start: uint) -> CharRange;\n     fn char_at(&self, i: uint) -> char;\n@@ -1869,6 +1872,11 @@ impl<'self> StrSlice<'self> for &'self str {\n         u\n     }\n \n+    #[inline]\n+    fn to_send_str(&self) -> SendStr {\n+        SendStrOwned(self.to_owned())\n+    }\n+\n     /// Returns false if the index points into the middle of a multi-byte\n     /// character sequence.\n     #[inline]\n@@ -2428,6 +2436,7 @@ mod tests {\n     use vec;\n     use vec::{Vector, ImmutableVector, CopyableVector};\n     use cmp::{TotalOrd, Less, Equal, Greater};\n+    use send_str::{SendStrOwned, SendStrStatic};\n \n     #[test]\n     fn test_eq() {\n@@ -3724,6 +3733,12 @@ mod tests {\n         let xs = bytes!(\"hello\", 0xff).to_owned();\n         assert_eq!(from_utf8_owned_opt(xs), None);\n     }\n+\n+    #[test]\n+    fn test_to_send_str() {\n+        assert_eq!(\"abcde\".to_send_str(), SendStrStatic(\"abcde\"));\n+        assert_eq!(\"abcde\".to_send_str(), SendStrOwned(~\"abcde\"));\n+    }\n }\n \n #[cfg(test)]"}, {"sha": "3d35de0f898153b9e731c709af138eec2b28b6e0", "filename": "src/libstd/sys.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/76c3e8a38cea2fe6342d83158c267e57a6b1f53f/src%2Flibstd%2Fsys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76c3e8a38cea2fe6342d83158c267e57a6b1f53f/src%2Flibstd%2Fsys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys.rs?ref=76c3e8a38cea2fe6342d83158c267e57a6b1f53f", "patch": "@@ -140,7 +140,8 @@ pub fn begin_unwind_(msg: *c_char, file: *c_char, line: size_t) -> ! {\n     use rt::in_green_task_context;\n     use rt::task::Task;\n     use rt::local::Local;\n-    use rt::logging::{Logger, OwnedString};\n+    use rt::logging::Logger;\n+    use send_str::SendStrOwned;\n     use str::Str;\n \n     unsafe {\n@@ -163,7 +164,7 @@ pub fn begin_unwind_(msg: *c_char, file: *c_char, line: size_t) -> ! {\n                          msg, file, line as int)\n                 };\n \n-                task.logger.log(OwnedString(msg));\n+                task.logger.log(SendStrOwned(msg));\n             }\n         } else {\n             rterrln!(\"failed in non-task context at '%s', %s:%i\","}, {"sha": "a33cb99682bb0ac7ced2ac32c381d80ea1f56586", "filename": "src/test/run-pass/send_str_hashmap.rs", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/76c3e8a38cea2fe6342d83158c267e57a6b1f53f/src%2Ftest%2Frun-pass%2Fsend_str_hashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76c3e8a38cea2fe6342d83158c267e57a6b1f53f/src%2Ftest%2Frun-pass%2Fsend_str_hashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsend_str_hashmap.rs?ref=76c3e8a38cea2fe6342d83158c267e57a6b1f53f", "patch": "@@ -0,0 +1,80 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::clone::{Clone, DeepClone};\n+use std::cmp::{TotalEq, Ord, TotalOrd, Equiv};\n+use std::cmp::Equal;\n+use std::container::{Container, Map, MutableMap};\n+use std::default::Default;\n+use std::send_str::{SendStr, SendStrOwned, SendStrStatic};\n+use std::str::Str;\n+use std::to_str::ToStr;\n+use std::hashmap::HashMap;\n+use std::option::Some;\n+\n+fn main() {\n+    let mut map: HashMap<SendStr, uint> = HashMap::new();\n+    assert!(map.insert(SendStrStatic(\"foo\"), 42));\n+    assert!(!map.insert(SendStrOwned(~\"foo\"), 42));\n+    assert!(!map.insert(SendStrStatic(\"foo\"), 42));\n+    assert!(!map.insert(SendStrOwned(~\"foo\"), 42));\n+\n+    assert!(!map.insert(SendStrStatic(\"foo\"), 43));\n+    assert!(!map.insert(SendStrOwned(~\"foo\"), 44));\n+    assert!(!map.insert(SendStrStatic(\"foo\"), 45));\n+    assert!(!map.insert(SendStrOwned(~\"foo\"), 46));\n+\n+    let v = 46;\n+\n+    assert_eq!(map.find(&SendStrOwned(~\"foo\")), Some(&v));\n+    assert_eq!(map.find(&SendStrStatic(\"foo\")), Some(&v));\n+\n+    let (a, b, c, d) = (50, 51, 52, 53);\n+\n+    assert!(map.insert(SendStrStatic(\"abc\"), a));\n+    assert!(map.insert(SendStrOwned(~\"bcd\"), b));\n+    assert!(map.insert(SendStrStatic(\"cde\"), c));\n+    assert!(map.insert(SendStrOwned(~\"def\"), d));\n+\n+    assert!(!map.insert(SendStrStatic(\"abc\"), a));\n+    assert!(!map.insert(SendStrOwned(~\"bcd\"), b));\n+    assert!(!map.insert(SendStrStatic(\"cde\"), c));\n+    assert!(!map.insert(SendStrOwned(~\"def\"), d));\n+\n+    assert!(!map.insert(SendStrOwned(~\"abc\"), a));\n+    assert!(!map.insert(SendStrStatic(\"bcd\"), b));\n+    assert!(!map.insert(SendStrOwned(~\"cde\"), c));\n+    assert!(!map.insert(SendStrStatic(\"def\"), d));\n+\n+    assert_eq!(map.find_equiv(&(\"abc\")), Some(&a));\n+    assert_eq!(map.find_equiv(&(\"bcd\")), Some(&b));\n+    assert_eq!(map.find_equiv(&(\"cde\")), Some(&c));\n+    assert_eq!(map.find_equiv(&(\"def\")), Some(&d));\n+\n+    assert_eq!(map.find_equiv(&(~\"abc\")), Some(&a));\n+    assert_eq!(map.find_equiv(&(~\"bcd\")), Some(&b));\n+    assert_eq!(map.find_equiv(&(~\"cde\")), Some(&c));\n+    assert_eq!(map.find_equiv(&(~\"def\")), Some(&d));\n+\n+    assert_eq!(map.find_equiv(&(@\"abc\")), Some(&a));\n+    assert_eq!(map.find_equiv(&(@\"bcd\")), Some(&b));\n+    assert_eq!(map.find_equiv(&(@\"cde\")), Some(&c));\n+    assert_eq!(map.find_equiv(&(@\"def\")), Some(&d));\n+\n+    assert_eq!(map.find_equiv(&SendStrStatic(\"abc\")), Some(&a));\n+    assert_eq!(map.find_equiv(&SendStrStatic(\"bcd\")), Some(&b));\n+    assert_eq!(map.find_equiv(&SendStrStatic(\"cde\")), Some(&c));\n+    assert_eq!(map.find_equiv(&SendStrStatic(\"def\")), Some(&d));\n+\n+    assert_eq!(map.find_equiv(&SendStrOwned(~\"abc\")), Some(&a));\n+    assert_eq!(map.find_equiv(&SendStrOwned(~\"bcd\")), Some(&b));\n+    assert_eq!(map.find_equiv(&SendStrOwned(~\"cde\")), Some(&c));\n+    assert_eq!(map.find_equiv(&SendStrOwned(~\"def\")), Some(&d));\n+}"}, {"sha": "d3af1360b4bb5ba759bf34b0a876d05137fddb41", "filename": "src/test/run-pass/send_str_treemap.rs", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/76c3e8a38cea2fe6342d83158c267e57a6b1f53f/src%2Ftest%2Frun-pass%2Fsend_str_treemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76c3e8a38cea2fe6342d83158c267e57a6b1f53f/src%2Ftest%2Frun-pass%2Fsend_str_treemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsend_str_treemap.rs?ref=76c3e8a38cea2fe6342d83158c267e57a6b1f53f", "patch": "@@ -0,0 +1,73 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+extern mod extra;\n+\n+use std::clone::{Clone, DeepClone};\n+use std::cmp::{TotalEq, Ord, TotalOrd, Equiv};\n+use std::cmp::Equal;\n+use std::container::{Container, Map, MutableMap};\n+use std::default::Default;\n+use std::send_str::{SendStr, SendStrOwned, SendStrStatic};\n+use std::str::Str;\n+use std::to_str::ToStr;\n+use extra::treemap::TreeMap;\n+use std::option::Some;\n+\n+fn main() {\n+    let mut map: TreeMap<SendStr, uint> = TreeMap::new();\n+    assert!(map.insert(SendStrStatic(\"foo\"), 42));\n+    assert!(!map.insert(SendStrOwned(~\"foo\"), 42));\n+    assert!(!map.insert(SendStrStatic(\"foo\"), 42));\n+    assert!(!map.insert(SendStrOwned(~\"foo\"), 42));\n+\n+    assert!(!map.insert(SendStrStatic(\"foo\"), 43));\n+    assert!(!map.insert(SendStrOwned(~\"foo\"), 44));\n+    assert!(!map.insert(SendStrStatic(\"foo\"), 45));\n+    assert!(!map.insert(SendStrOwned(~\"foo\"), 46));\n+\n+    let v = 46;\n+\n+    assert_eq!(map.find(&SendStrOwned(~\"foo\")), Some(&v));\n+    assert_eq!(map.find(&SendStrStatic(\"foo\")), Some(&v));\n+\n+    let (a, b, c, d) = (50, 51, 52, 53);\n+\n+    assert!(map.insert(SendStrStatic(\"abc\"), a));\n+    assert!(map.insert(SendStrOwned(~\"bcd\"), b));\n+    assert!(map.insert(SendStrStatic(\"cde\"), c));\n+    assert!(map.insert(SendStrOwned(~\"def\"), d));\n+\n+    assert!(!map.insert(SendStrStatic(\"abc\"), a));\n+    assert!(!map.insert(SendStrOwned(~\"bcd\"), b));\n+    assert!(!map.insert(SendStrStatic(\"cde\"), c));\n+    assert!(!map.insert(SendStrOwned(~\"def\"), d));\n+\n+    assert!(!map.insert(SendStrOwned(~\"abc\"), a));\n+    assert!(!map.insert(SendStrStatic(\"bcd\"), b));\n+    assert!(!map.insert(SendStrOwned(~\"cde\"), c));\n+    assert!(!map.insert(SendStrStatic(\"def\"), d));\n+\n+    assert_eq!(map.find(&SendStrStatic(\"abc\")), Some(&a));\n+    assert_eq!(map.find(&SendStrStatic(\"bcd\")), Some(&b));\n+    assert_eq!(map.find(&SendStrStatic(\"cde\")), Some(&c));\n+    assert_eq!(map.find(&SendStrStatic(\"def\")), Some(&d));\n+\n+    assert_eq!(map.find(&SendStrOwned(~\"abc\")), Some(&a));\n+    assert_eq!(map.find(&SendStrOwned(~\"bcd\")), Some(&b));\n+    assert_eq!(map.find(&SendStrOwned(~\"cde\")), Some(&c));\n+    assert_eq!(map.find(&SendStrOwned(~\"def\")), Some(&d));\n+\n+    assert!(map.pop(&SendStrStatic(\"foo\")).is_some());\n+    assert_eq!(map.move_iter().map(|(k, v)| k.to_str() + v.to_str())\n+                              .to_owned_vec()\n+                              .concat(),\n+               ~\"abc50bcd51cde52def53\");\n+}"}]}