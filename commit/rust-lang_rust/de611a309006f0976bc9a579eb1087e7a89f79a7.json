{"sha": "de611a309006f0976bc9a579eb1087e7a89f79a7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRlNjExYTMwOTAwNmYwOTc2YmM5YTU3OWViMTA4N2U3YTg5Zjc5YTc=", "commit": {"author": {"name": "Michael Bebenita", "email": "mbebenita@mozilla.com", "date": "2010-09-08T01:39:07Z"}, "committer": {"name": "Michael Bebenita", "email": "mbebenita@mozilla.com", "date": "2010-09-08T01:44:12Z"}, "message": "Lots of design changes around proxies and message passing. Made it so that domains can only talk to other domains via handles, and with the help of the rust_kernel.", "tree": {"sha": "cd30b33ab1986c0cc84e0fc0743593bd99b0caaa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cd30b33ab1986c0cc84e0fc0743593bd99b0caaa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/de611a309006f0976bc9a579eb1087e7a89f79a7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/de611a309006f0976bc9a579eb1087e7a89f79a7", "html_url": "https://github.com/rust-lang/rust/commit/de611a309006f0976bc9a579eb1087e7a89f79a7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/de611a309006f0976bc9a579eb1087e7a89f79a7/comments", "author": {"login": "mbebenita", "id": 311082, "node_id": "MDQ6VXNlcjMxMTA4Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/311082?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mbebenita", "html_url": "https://github.com/mbebenita", "followers_url": "https://api.github.com/users/mbebenita/followers", "following_url": "https://api.github.com/users/mbebenita/following{/other_user}", "gists_url": "https://api.github.com/users/mbebenita/gists{/gist_id}", "starred_url": "https://api.github.com/users/mbebenita/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mbebenita/subscriptions", "organizations_url": "https://api.github.com/users/mbebenita/orgs", "repos_url": "https://api.github.com/users/mbebenita/repos", "events_url": "https://api.github.com/users/mbebenita/events{/privacy}", "received_events_url": "https://api.github.com/users/mbebenita/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mbebenita", "id": 311082, "node_id": "MDQ6VXNlcjMxMTA4Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/311082?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mbebenita", "html_url": "https://github.com/mbebenita", "followers_url": "https://api.github.com/users/mbebenita/followers", "following_url": "https://api.github.com/users/mbebenita/following{/other_user}", "gists_url": "https://api.github.com/users/mbebenita/gists{/gist_id}", "starred_url": "https://api.github.com/users/mbebenita/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mbebenita/subscriptions", "organizations_url": "https://api.github.com/users/mbebenita/orgs", "repos_url": "https://api.github.com/users/mbebenita/repos", "events_url": "https://api.github.com/users/mbebenita/events{/privacy}", "received_events_url": "https://api.github.com/users/mbebenita/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a6aebdaedd4abb95b040c9cd09cfdb6b9b940789", "url": "https://api.github.com/repos/rust-lang/rust/commits/a6aebdaedd4abb95b040c9cd09cfdb6b9b940789", "html_url": "https://github.com/rust-lang/rust/commit/a6aebdaedd4abb95b040c9cd09cfdb6b9b940789"}], "stats": {"total": 1080, "additions": 643, "deletions": 437}, "files": [{"sha": "36aaf2a8a150c3cc05894d699eae2cff4fb5856b", "filename": "src/Makefile", "status": "modified", "additions": 4, "deletions": 26, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/de611a309006f0976bc9a579eb1087e7a89f79a7/src%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/de611a309006f0976bc9a579eb1087e7a89f79a7/src%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FMakefile?ref=de611a309006f0976bc9a579eb1087e7a89f79a7", "patch": "@@ -380,33 +380,10 @@ self: $(CFG_COMPILER)\n # Temporarily xfail the entire multi-tasking system, pending resolution\n # of inter-task shutdown races introduced with notification proxies.\n \n-TASK_XFAILS := test/run-pass/acyclic-unwind.rs \\\n-               test/run-pass/alt-type-simple.rs \\\n-               test/run-pass/basic.rs \\\n-               test/run-pass/clone-with-exterior.rs \\\n-               test/run-pass/comm.rs \\\n-               test/run-pass/lazychan.rs \\\n-               test/run-pass/many.rs \\\n-               test/run-pass/obj-dtor.rs \\\n-               test/run-pass/preempt.rs \\\n-               test/run-pass/spawn-fn.rs \\\n-               test/run-pass/spawn-module-qualified.rs \\\n-               test/run-pass/spawn.rs \\\n-               test/run-pass/task-comm-0.rs \\\n-               test/run-pass/task-comm-1.rs \\\n-               test/run-pass/task-comm-2.rs \\\n-               test/run-pass/task-comm-3.rs \\\n-               test/run-pass/task-comm-7.rs \\\n-               test/run-pass/task-comm-8.rs \\\n-               test/run-pass/task-comm-9.rs \\\n-               test/run-pass/task-comm-10.rs \\\n-               test/run-pass/task-comm-11.rs \\\n-               test/run-pass/task-life-0.rs \\\n-               test/run-pass/task-comm.rs \\\n-               test/run-pass/threads.rs \\\n-               test/run-pass/yield.rs \\\n+TASK_XFAILS := test/run-pass/task-comm-10.rs \\\n                test/run-pass/task-comm-15.rs \\\n-               test/run-pass/task-life-0.rs\n+               test/run-pass/task-life-0.rs \\\n+               test/run-pass/alt-type-simple.rs\n \n TEST_XFAILS_X86 :=  $(TASK_XFAILS) \\\n                     test/run-pass/child-outlives-parent.rs \\\n@@ -425,6 +402,7 @@ TEST_XFAILS_X86 :=  $(TASK_XFAILS) \\\n                     test/run-pass/task-comm.rs \\\n                     test/run-pass/vec-slice.rs \\\n                     test/run-pass/task-comm-3.rs \\\n+                    test/run-fail/task-comm-14.rs \\\n                     test/compile-fail/bad-recv.rs \\\n                     test/compile-fail/bad-send.rs \\\n                     test/compile-fail/infinite-tag-type-recursion.rs \\"}, {"sha": "43043e111a661a113beb1d15be3e3f5f4dbcb064", "filename": "src/boot/be/abi.ml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/de611a309006f0976bc9a579eb1087e7a89f79a7/src%2Fboot%2Fbe%2Fabi.ml", "raw_url": "https://github.com/rust-lang/rust/raw/de611a309006f0976bc9a579eb1087e7a89f79a7/src%2Fboot%2Fbe%2Fabi.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fbe%2Fabi.ml?ref=de611a309006f0976bc9a579eb1087e7a89f79a7", "patch": "@@ -20,7 +20,7 @@ let task_field_gc_alloc_chain = task_field_rust_sp + 1;;\n let task_field_dom = task_field_gc_alloc_chain + 1;;\n let n_visible_task_fields = task_field_dom + 1;;\n \n-let dom_field_interrupt_flag = 0;;\n+let dom_field_interrupt_flag = 1;;\n \n let frame_glue_fns_field_mark = 0;;\n let frame_glue_fns_field_drop = 1;;"}, {"sha": "9196e28dd83b2dad1e3802d5ee477fbd1865d410", "filename": "src/rt/memory.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/de611a309006f0976bc9a579eb1087e7a89f79a7/src%2Frt%2Fmemory.h", "raw_url": "https://github.com/rust-lang/rust/raw/de611a309006f0976bc9a579eb1087e7a89f79a7/src%2Frt%2Fmemory.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fmemory.h?ref=de611a309006f0976bc9a579eb1087e7a89f79a7", "patch": "@@ -1,11 +1,6 @@\n-/*\n- *\n- */\n-\n #ifndef MEMORY_H\n #define MEMORY_H\n \n-\n inline void *operator new(size_t size, void *mem) {\n     return mem;\n }"}, {"sha": "2f841935c113c4f8d773ce5432020ea850d4ac88", "filename": "src/rt/memory_region.cpp", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/de611a309006f0976bc9a579eb1087e7a89f79a7/src%2Frt%2Fmemory_region.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/de611a309006f0976bc9a579eb1087e7a89f79a7/src%2Frt%2Fmemory_region.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fmemory_region.cpp?ref=de611a309006f0976bc9a579eb1087e7a89f79a7", "patch": "@@ -1,7 +1,3 @@\n-/*\n- *\n- */\n-\n #include \"rust_internal.h\"\n #include \"memory_region.h\"\n \n@@ -20,6 +16,7 @@ memory_region::memory_region(memory_region *parent) :\n }\n \n void memory_region::free(void *mem) {\n+    // printf(\"free: ptr 0x%\" PRIxPTR\"\\n\", (uintptr_t) mem);\n     if (_synchronized) { _lock.lock(); }\n #ifdef TRACK_ALLOCATIONS\n     if (_allocation_list.replace(mem, NULL) == false) {\n@@ -34,7 +31,6 @@ void memory_region::free(void *mem) {\n     _live_allocations--;\n     _srv->free(mem);\n     if (_synchronized) { _lock.unlock(); }\n-\n }\n \n void *\n@@ -63,6 +59,7 @@ memory_region::malloc(size_t size) {\n #ifdef TRACK_ALLOCATIONS\n     _allocation_list.append(mem);\n #endif\n+    // printf(\"malloc: ptr 0x%\" PRIxPTR \"\\n\", (uintptr_t) mem);\n     if (_synchronized) { _lock.unlock(); }\n     return mem;\n }"}, {"sha": "0ea167a4a8c900ca4a9787826a6aa03de83a5df3", "filename": "src/rt/rust.cpp", "status": "modified", "additions": 45, "deletions": 40, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/de611a309006f0976bc9a579eb1087e7a89f79a7/src%2Frt%2Frust.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/de611a309006f0976bc9a579eb1087e7a89f79a7/src%2Frt%2Frust.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust.cpp?ref=de611a309006f0976bc9a579eb1087e7a89f79a7", "patch": "@@ -1,16 +1,16 @@\n #include \"rust_internal.h\"\n \n struct\n-command_line_args\n+command_line_args : public dom_owned<command_line_args>\n {\n-    rust_dom &dom;\n+    rust_dom *dom;\n     int argc;\n     char **argv;\n \n     // vec[str] passed to rust_task::start.\n     rust_vec *args;\n \n-    command_line_args(rust_dom &dom,\n+    command_line_args(rust_dom *dom,\n                       int sys_argc,\n                       char **sys_argv)\n         : dom(dom),\n@@ -21,29 +21,29 @@ command_line_args\n #if defined(__WIN32__)\n         LPCWSTR cmdline = GetCommandLineW();\n         LPWSTR *wargv = CommandLineToArgvW(cmdline, &argc);\n-        dom.win32_require(\"CommandLineToArgvW\", wargv != NULL);\n-        argv = (char **) dom.malloc(sizeof(char*) * argc);\n+        dom->win32_require(\"CommandLineToArgvW\", wargv != NULL);\n+        argv = (char **) dom->malloc(sizeof(char*) * argc);\n         for (int i = 0; i < argc; ++i) {\n             int n_chars = WideCharToMultiByte(CP_UTF8, 0, wargv[i], -1,\n                                               NULL, 0, NULL, NULL);\n-            dom.win32_require(\"WideCharToMultiByte(0)\", n_chars != 0);\n-            argv[i] = (char *) dom.malloc(n_chars);\n+            dom->win32_require(\"WideCharToMultiByte(0)\", n_chars != 0);\n+            argv[i] = (char *) dom->malloc(n_chars);\n             n_chars = WideCharToMultiByte(CP_UTF8, 0, wargv[i], -1,\n                                           argv[i], n_chars, NULL, NULL);\n-            dom.win32_require(\"WideCharToMultiByte(1)\", n_chars != 0);\n+            dom->win32_require(\"WideCharToMultiByte(1)\", n_chars != 0);\n         }\n         LocalFree(wargv);\n #endif\n         size_t vec_fill = sizeof(rust_str *) * argc;\n         size_t vec_alloc = next_power_of_two(sizeof(rust_vec) + vec_fill);\n-        void *mem = dom.malloc(vec_alloc);\n-        args = new (mem) rust_vec(&dom, vec_alloc, 0, NULL);\n+        void *mem = dom->malloc(vec_alloc);\n+        args = new (mem) rust_vec(dom, vec_alloc, 0, NULL);\n         rust_str **strs = (rust_str**) &args->data[0];\n         for (int i = 0; i < argc; ++i) {\n             size_t str_fill = strlen(argv[i]) + 1;\n             size_t str_alloc = next_power_of_two(sizeof(rust_str) + str_fill);\n-            mem = dom.malloc(str_alloc);\n-            strs[i] = new (mem) rust_str(&dom, str_alloc, str_fill,\n+            mem = dom->malloc(str_alloc);\n+            strs[i] = new (mem) rust_str(dom, str_alloc, str_fill,\n                                          (uint8_t const *)argv[i]);\n         }\n         args->fill = vec_fill;\n@@ -58,50 +58,55 @@ command_line_args\n             // Drop the args we've had pinned here.\n             rust_str **strs = (rust_str**) &args->data[0];\n             for (int i = 0; i < argc; ++i)\n-                dom.free(strs[i]);\n-            dom.free(args);\n+                dom->free(strs[i]);\n+            dom->free(args);\n         }\n \n #ifdef __WIN32__\n         for (int i = 0; i < argc; ++i) {\n-            dom.free(argv[i]);\n+            dom->free(argv[i]);\n         }\n-        dom.free(argv);\n+        dom->free(argv);\n #endif\n     }\n };\n \n+/**\n+ * Main entry point into the Rust runtime. Here we create a Rust service,\n+ * initialize the kernel, create the root domain and run it.\n+ */\n \n extern \"C\" CDECL int\n-rust_start(uintptr_t main_fn, rust_crate const *crate, int argc, char **argv)\n-{\n-    int ret;\n-    {\n-        rust_srv srv;\n-        rust_dom dom(&srv, crate, \"main\");\n-        srv.kernel->register_domain(&dom);\n-        command_line_args args(dom, argc, argv);\n+rust_start(uintptr_t main_fn, rust_crate const *crate, int argc,\n+    char **argv) {\n \n-        dom.log(rust_log::DOM, \"startup: %d args\", args.argc);\n-        for (int i = 0; i < args.argc; ++i)\n-            dom.log(rust_log::DOM,\n-                    \"startup: arg[%d] = '%s'\", i, args.argv[i]);\n-\n-        if (dom._log.is_tracing(rust_log::DWARF)) {\n-            rust_crate_reader rdr(&dom, crate);\n-        }\n+    rust_srv *srv = new rust_srv();\n+    rust_kernel *kernel = new rust_kernel(srv);\n+    kernel->start();\n+    rust_handle<rust_dom> *handle = kernel->create_domain(crate, \"main\");\n+    rust_dom *dom = handle->referent();\n+    command_line_args *args = new (dom) command_line_args(dom, argc, argv);\n \n-        uintptr_t main_args[4] = { 0, 0, 0, (uintptr_t)args.args };\n-\n-        dom.root_task->start(crate->get_exit_task_glue(),\n-                             main_fn,\n-                             (uintptr_t)&main_args,\n-                             sizeof(main_args));\n+    dom->log(rust_log::DOM, \"startup: %d args\", args->argc);\n+    for (int i = 0; i < args->argc; i++) {\n+        dom->log(rust_log::DOM,\n+            \"startup: arg[%d] = '%s'\", i, args->argv[i]);\n+    }\n \n-        ret = dom.start_main_loop();\n-        srv.kernel->deregister_domain(&dom);\n+    if (dom->_log.is_tracing(rust_log::DWARF)) {\n+        rust_crate_reader create_reader(dom, crate);\n     }\n \n+    uintptr_t main_args[4] = {0, 0, 0, (uintptr_t)args->args};\n+    dom->root_task->start(crate->get_exit_task_glue(),\n+        main_fn, (uintptr_t)&main_args, sizeof(main_args));\n+    int ret = dom->start_main_loop();\n+    delete args;\n+    kernel->destroy_domain(dom);\n+    kernel->join_all_domains();\n+    delete kernel;\n+    delete srv;\n+\n #if !defined(__WIN32__)\n     // Don't take down the process if the main thread exits without an\n     // error."}, {"sha": "9a6664535cfcadc3117cf12c8eb95409c29059a7", "filename": "src/rt/rust_chan.cpp", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/de611a309006f0976bc9a579eb1087e7a89f79a7/src%2Frt%2Frust_chan.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/de611a309006f0976bc9a579eb1087e7a89f79a7/src%2Frt%2Frust_chan.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_chan.cpp?ref=de611a309006f0976bc9a579eb1087e7a89f79a7", "patch": "@@ -4,13 +4,15 @@\n /**\n  * Create a new rust channel and associate it with the specified port.\n  */\n-rust_chan::rust_chan(rust_task *task, maybe_proxy<rust_port> *port) :\n-    task(task), port(port), buffer(task->dom, port->delegate()->unit_sz) {\n-\n+rust_chan::rust_chan(rust_task *task,\n+                     maybe_proxy<rust_port> *port,\n+                     size_t unit_sz) :\n+                     task(task),\n+                     port(port),\n+                     buffer(task->dom, unit_sz) {\n     if (port) {\n         associate(port);\n     }\n-\n     task->log(rust_log::MEM | rust_log::COMM,\n               \"new rust_chan(task=0x%\" PRIxPTR\n               \", port=0x%\" PRIxPTR \") -> chan=0x%\" PRIxPTR,\n@@ -34,7 +36,7 @@ void rust_chan::associate(maybe_proxy<rust_port> *port) {\n         task->log(rust_log::TASK,\n             \"associating chan: 0x%\" PRIxPTR \" with port: 0x%\" PRIxPTR,\n             this, port);\n-        this->port->delegate()->chans.push(this);\n+        this->port->referent()->chans.push(this);\n     }\n }\n \n@@ -51,8 +53,8 @@ void rust_chan::disassociate() {\n     if (port->is_proxy() == false) {\n         task->log(rust_log::TASK,\n             \"disassociating chan: 0x%\" PRIxPTR \" from port: 0x%\" PRIxPTR,\n-            this, port->delegate());\n-        port->delegate()->chans.swap_delete(this);\n+            this, port->referent());\n+        port->referent()->chans.swap_delete(this);\n     }\n \n     // Delete reference to the port.\n@@ -76,14 +78,11 @@ void rust_chan::send(void *sptr) {\n       \"rust_chan::transmit with nothing to send.\");\n \n     if (port->is_proxy()) {\n-        // TODO: Cache port task locally.\n-        rust_proxy<rust_task> *port_task =\n-            dom->get_task_proxy(port->delegate()->task);\n-        data_message::send(buffer.peek(), buffer.unit_sz,\n-            \"send data\", task, port_task, port->as_proxy());\n+        data_message::send(buffer.peek(), buffer.unit_sz, \"send data\",\n+                           task->get_handle(), port->as_proxy()->handle());\n         buffer.dequeue(NULL);\n     } else {\n-        rust_port *target_port = port->delegate();\n+        rust_port *target_port = port->referent();\n         if (target_port->task->blocked_on(target_port)) {\n             dom->log(rust_log::COMM, \"dequeued in rendezvous_ptr\");\n             buffer.dequeue(target_port->task->rendezvous_ptr);"}, {"sha": "a6e4d3d6b43c91b42fc6bd831e762020b9d37ce7", "filename": "src/rt/rust_chan.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/de611a309006f0976bc9a579eb1087e7a89f79a7/src%2Frt%2Frust_chan.h", "raw_url": "https://github.com/rust-lang/rust/raw/de611a309006f0976bc9a579eb1087e7a89f79a7/src%2Frt%2Frust_chan.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_chan.h?ref=de611a309006f0976bc9a579eb1087e7a89f79a7", "patch": "@@ -5,7 +5,8 @@ class rust_chan : public rc_base<rust_chan>,\n                   public task_owned<rust_chan>,\n                   public rust_cond {\n public:\n-    rust_chan(rust_task *task, maybe_proxy<rust_port> *port);\n+    rust_chan(rust_task *task, maybe_proxy<rust_port> *port, size_t unit_sz);\n+\n     ~rust_chan();\n \n     rust_task *task;"}, {"sha": "323e9c3981bbd7542b185b430c6e30390ca3b8a4", "filename": "src/rt/rust_dom.cpp", "status": "modified", "additions": 13, "deletions": 108, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/de611a309006f0976bc9a579eb1087e7a89f79a7/src%2Frt%2Frust_dom.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/de611a309006f0976bc9a579eb1087e7a89f79a7/src%2Frt%2Frust_dom.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_dom.cpp?ref=de611a309006f0976bc9a579eb1087e7a89f79a7", "patch": "@@ -4,8 +4,9 @@\n \n template class ptr_vec<rust_task>;\n \n-rust_dom::rust_dom(rust_srv *srv, rust_crate const *root_crate,\n-                   const char *name) :\n+rust_dom::rust_dom(rust_kernel *kernel,\n+    rust_message_queue *message_queue, rust_srv *srv,\n+    rust_crate const *root_crate, const char *name) :\n     interrupt_flag(0),\n     root_crate(root_crate),\n     _log(srv, this),\n@@ -20,7 +21,8 @@ rust_dom::rust_dom(rust_srv *srv, rust_crate const *root_crate,\n     root_task(NULL),\n     curr_task(NULL),\n     rval(0),\n-    _kernel(srv->kernel)\n+    kernel(kernel),\n+    message_queue(message_queue)\n {\n     logptr(\"new dom\", (uintptr_t)this);\n     isaac_init(this, &rctx);\n@@ -42,33 +44,9 @@ del_all_tasks(rust_dom *dom, ptr_vec<rust_task> *v) {\n     }\n }\n \n-void\n-rust_dom::delete_proxies() {\n-    rust_task *task;\n-    rust_proxy<rust_task> *task_proxy;\n-    while (_task_proxies.pop(&task, &task_proxy)) {\n-        log(rust_log::TASK,\n-            \"deleting proxy 0x%\" PRIxPTR \" in dom %s 0x%\" PRIxPTR,\n-            task_proxy, task_proxy->dom->name, task_proxy->dom);\n-        delete task_proxy;\n-    }\n-\n-    rust_port *port;\n-    rust_proxy<rust_port> *port_proxy;\n-    while (_port_proxies.pop(&port, &port_proxy)) {\n-        log(rust_log::TASK,\n-            \"deleting proxy 0x%\" PRIxPTR \" in dom %s 0x%\" PRIxPTR,\n-            port_proxy, port_proxy->dom->name, port_proxy->dom);\n-        delete port_proxy;\n-    }\n-}\n-\n rust_dom::~rust_dom() {\n     log(rust_log::MEM | rust_log::DOM,\n         \"~rust_dom %s @0x%\" PRIxPTR, name, (uintptr_t)this);\n-\n-    log(rust_log::TASK, \"deleting all proxies\");\n-    delete_proxies();\n     log(rust_log::TASK, \"deleting all running tasks\");\n     del_all_tasks(this, &running_tasks);\n     log(rust_log::TASK, \"deleting all blocked tasks\");\n@@ -78,8 +56,9 @@ rust_dom::~rust_dom() {\n #ifndef __WIN32__\n     pthread_attr_destroy(&attr);\n #endif\n-    while (caches.length())\n+    while (caches.length()) {\n         delete caches.pop();\n+    }\n }\n \n void\n@@ -275,68 +254,19 @@ rust_dom::reap_dead_tasks() {\n     }\n }\n \n-/**\n- * Enqueues a message in this domain's incoming message queue. It's the\n- * responsibility of the receiver to free the message once it's processed.\n- */\n-void rust_dom::send_message(rust_message *message) {\n-    log(rust_log::COMM, \"==> enqueueing \\\"%s\\\" 0x%\" PRIxPTR\n-                        \" in queue 0x%\" PRIxPTR\n-                        \" in domain 0x%\" PRIxPTR,\n-                        message->label,\n-                        message,\n-                        &_incoming_message_queue,\n-                        this);\n-    _incoming_message_queue.enqueue(message);\n-}\n-\n /**\n  * Drains and processes incoming pending messages.\n  */\n void rust_dom::drain_incoming_message_queue(bool process) {\n     rust_message *message;\n-    while (_incoming_message_queue.dequeue(&message)) {\n-        log(rust_log::COMM, \"<== processing incoming message \\\"%s\\\" 0x%\"\n-            PRIxPTR, message->label, message);\n+    while (message_queue->dequeue(&message)) {\n+        log(rust_log::COMM, \"<== receiving \\\"%s\\\" \" PTR,\n+            message->label, message);\n         if (process) {\n             message->process();\n         }\n-        message->~rust_message();\n-        this->synchronized_region.free(message);\n-    }\n-}\n-\n-rust_proxy<rust_task> *\n-rust_dom::get_task_proxy(rust_task *task) {\n-    rust_proxy<rust_task> *proxy = NULL;\n-    if (_task_proxies.get(task, &proxy)) {\n-        return proxy;\n+        delete message;\n     }\n-    log(rust_log::COMM, \"no proxy for %s @0x%\" PRIxPTR, task->name, task);\n-    proxy = new (this) rust_proxy<rust_task> (this, task, false);\n-    _task_proxies.put(task, proxy);\n-    return proxy;\n-}\n-\n-/**\n- * Gets a proxy for this port.\n- *\n- * TODO: This method needs to be synchronized since it's usually called\n- * during upcall_clone_chan in a different thread. However, for now\n- * since this usually happens before the thread actually starts,\n- * we may get lucky without synchronizing.\n- *\n- */\n-rust_proxy<rust_port> *\n-rust_dom::get_port_proxy_synchronized(rust_port *port) {\n-    rust_proxy<rust_port> *proxy = NULL;\n-    if (_port_proxies.get(port, &proxy)) {\n-        return proxy;\n-    }\n-    log(rust_log::COMM, \"no proxy for 0x%\" PRIxPTR, port);\n-    proxy = new (this) rust_proxy<rust_port> (this, port, false);\n-    _port_proxies.put(port, proxy);\n-    return proxy;\n }\n \n /**\n@@ -362,31 +292,6 @@ rust_dom::schedule_task() {\n     return NULL;\n }\n \n-/**\n- * Checks for simple deadlocks.\n- */\n-bool\n-rust_dom::is_deadlocked() {\n-    if (_kernel->domains.length() != 1) {\n-        // We cannot tell if we are deadlocked if other domains exists.\n-        return false;\n-    }\n-\n-    if (running_tasks.length() != 0) {\n-        // We are making progress and therefore we are not deadlocked.\n-        return false;\n-    }\n-\n-    if (_incoming_message_queue.is_empty() && blocked_tasks.length() > 0) {\n-        // We have no messages to process, no running tasks to schedule\n-        // and some blocked tasks therefore we are likely in a deadlock.\n-        _kernel->log_all_domain_state();\n-        return true;\n-    }\n-\n-    return false;\n-}\n-\n void\n rust_dom::log_state() {\n     if (!running_tasks.is_empty()) {\n@@ -439,7 +344,7 @@ rust_dom::start_main_loop()\n     logptr(\"exit-task glue\", root_crate->get_exit_task_glue());\n \n     while (n_live_tasks() > 0) {\n-        A(this, is_deadlocked() == false, \"deadlock\");\n+        A(this, kernel->is_deadlocked() == false, \"deadlock\");\n \n         drain_incoming_message_queue(true);\n \n@@ -496,7 +401,7 @@ rust_dom::start_main_loop()\n     log(rust_log::DOM, \"terminated scheduler loop, reaping dead tasks ...\");\n \n     while (dead_tasks.length() > 0) {\n-        if (_incoming_message_queue.is_empty()) {\n+        if (message_queue->is_empty()) {\n             log(rust_log::DOM,\n                 \"waiting for %d dead tasks to become dereferenced, \"\n                 \"scheduler yielding ...\","}, {"sha": "3f90bb679155da076360ab15b9bf5703f0978961", "filename": "src/rt/rust_dom.h", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/de611a309006f0976bc9a579eb1087e7a89f79a7/src%2Frt%2Frust_dom.h", "raw_url": "https://github.com/rust-lang/rust/raw/de611a309006f0976bc9a579eb1087e7a89f79a7/src%2Frt%2Frust_dom.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_dom.h?ref=de611a309006f0976bc9a579eb1087e7a89f79a7", "patch": "@@ -1,7 +1,7 @@\n #ifndef RUST_DOM_H\n #define RUST_DOM_H\n \n-struct rust_dom\n+struct rust_dom : public kernel_owned<rust_dom>, rc_base<rust_dom>\n {\n     // Fields known to the compiler:\n     uintptr_t interrupt_flag;\n@@ -27,24 +27,25 @@ struct rust_dom\n     rust_task *curr_task;\n     int rval;\n \n-    rust_kernel *_kernel;\n+    rust_kernel *kernel;\n     int32_t list_index;\n \n     hash_map<rust_task *, rust_proxy<rust_task> *> _task_proxies;\n     hash_map<rust_port *, rust_proxy<rust_port> *> _port_proxies;\n \n     // Incoming messages from other domains.\n-    lock_free_queue<rust_message*> _incoming_message_queue;\n+    rust_message_queue *message_queue;\n \n #ifndef __WIN32__\n     pthread_attr_t attr;\n #endif\n \n     // Only a pointer to 'name' is kept, so it must live as long as this\n     // domain.\n-    rust_dom(rust_srv *srv, rust_crate const *root_crate, const char *name);\n+    rust_dom(rust_kernel *kernel,\n+        rust_message_queue *message_queue, rust_srv *srv,\n+        rust_crate const *root_crate, const char *name);\n     ~rust_dom();\n-\n     void activate(rust_task *task);\n     void log(rust_task *task, uint32_t logbit, char const *fmt, ...);\n     void log(uint32_t logbit, char const *fmt, ...);\n@@ -63,11 +64,7 @@ struct rust_dom\n     void free(void *mem);\n     void free(void *mem, memory_region::memory_region_type type);\n \n-    void send_message(rust_message *message);\n     void drain_incoming_message_queue(bool process);\n-    rust_proxy<rust_task> *get_task_proxy(rust_task *task);\n-    void delete_proxies();\n-    rust_proxy<rust_port> *get_port_proxy_synchronized(rust_port *port);\n \n #ifdef __WIN32__\n     void win32_require(LPCTSTR fn, BOOL ok);\n@@ -81,7 +78,7 @@ struct rust_dom\n \n     void reap_dead_tasks();\n     rust_task *schedule_task();\n-    bool is_deadlocked();\n+\n     int start_main_loop();\n \n     void log_state();"}, {"sha": "c327f8c055c401f2dd03ae7d054c46cc2d7d017e", "filename": "src/rt/rust_internal.h", "status": "modified", "additions": 20, "deletions": 8, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/de611a309006f0976bc9a579eb1087e7a89f79a7/src%2Frt%2Frust_internal.h", "raw_url": "https://github.com/rust-lang/rust/raw/de611a309006f0976bc9a579eb1087e7a89f79a7/src%2Frt%2Frust_internal.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_internal.h?ref=de611a309006f0976bc9a579eb1087e7a89f79a7", "patch": "@@ -72,6 +72,11 @@ struct frame_glue_fns;\n #define A(dom, e, s, ...) ((e) ? (void)0 : \\\n          (dom)->srv->fatal(#e, __FILE__, __LINE__, s, ## __VA_ARGS__))\n \n+#define K(srv, e, s, ...) ((e) ? (void)0 : \\\n+         srv->fatal(#e, __FILE__, __LINE__, s, ## __VA_ARGS__))\n+\n+#define PTR \"0x%\" PRIxPTR\n+\n // This drives our preemption scheme.\n \n static size_t const TIME_SLICE_IN_MS = 10;\n@@ -96,22 +101,26 @@ template <typename T> struct rc_base {\n };\n \n template <typename T> struct dom_owned {\n-    rust_dom *get_dom() const {\n-        return ((T*)this)->dom;\n-    }\n-\n     void operator delete(void *ptr) {\n         ((T *)ptr)->dom->free(ptr);\n     }\n };\n \n template <typename T> struct task_owned {\n-    rust_dom *get_dom() const {\n-        return ((T *)this)->task->dom;\n+    void operator delete(void *ptr) {\n+        ((T *)ptr)->task->dom->free(ptr);\n     }\n+};\n \n+template <typename T> struct kernel_owned {\n     void operator delete(void *ptr) {\n-        ((T *)ptr)->task->dom->free(ptr);\n+        ((T *)ptr)->kernel->free(ptr);\n+    }\n+};\n+\n+template <typename T> struct region_owned {\n+    void operator delete(void *ptr) {\n+        ((T *)ptr)->region->free(ptr);\n     }\n };\n \n@@ -152,8 +161,8 @@ template <typename T> class ptr_vec : public dom_owned<ptr_vec<T> > {\n #include \"rust_srv.h\"\n #include \"rust_log.h\"\n #include \"rust_proxy.h\"\n-#include \"rust_message.h\"\n #include \"rust_kernel.h\"\n+#include \"rust_message.h\"\n #include \"rust_dom.h\"\n #include \"memory.h\"\n \n@@ -552,6 +561,9 @@ struct gc_alloc {\n #include \"rust_chan.h\"\n #include \"rust_port.h\"\n \n+#include \"test/rust_test_harness.h\"\n+#include \"test/rust_test_util.h\"\n+\n //\n // Local Variables:\n // mode: C++"}, {"sha": "9ea1f2ebee59024a9111052ca6659c3491ff237a", "filename": "src/rt/rust_kernel.cpp", "status": "modified", "additions": 161, "deletions": 9, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/de611a309006f0976bc9a579eb1087e7a89f79a7/src%2Frt%2Frust_kernel.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/de611a309006f0976bc9a579eb1087e7a89f79a7/src%2Frt%2Frust_kernel.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_kernel.cpp?ref=de611a309006f0976bc9a579eb1087e7a89f79a7", "patch": "@@ -1,25 +1,81 @@\n #include \"rust_internal.h\"\n \n rust_kernel::rust_kernel(rust_srv *srv) :\n-    _region(srv->local_region),\n+    _region(&srv->local_region),\n     _log(srv, NULL),\n-    domains(srv->local_region),\n-    message_queues(srv->local_region) {\n+    _srv(srv),\n+    _interrupt_kernel_loop(FALSE),\n+    domains(&srv->local_region),\n+    message_queues(&srv->local_region) {\n     // Nop.\n }\n \n-rust_kernel::~rust_kernel() {\n-    // Nop.\n+rust_handle<rust_dom> *\n+rust_kernel::create_domain(const rust_crate *crate, const char *name) {\n+    rust_message_queue *message_queue =\n+        new (this) rust_message_queue(_srv, this);\n+    rust_srv *srv = _srv->clone();\n+    rust_dom *dom =\n+        new (this) rust_dom(this, message_queue, srv, crate, name);\n+    rust_handle<rust_dom> *handle = get_dom_handle(dom);\n+    message_queue->associate(handle);\n+    domains.append(dom);\n+    message_queues.append(message_queue);\n+    return handle;\n }\n \n void\n-rust_kernel::register_domain(rust_dom *dom) {\n-    domains.append(dom);\n+rust_kernel::destroy_domain(rust_dom *dom) {\n+    log(rust_log::KERN, \"deleting domain: \" PTR \", index: %d, domains %d\",\n+        dom, dom->list_index, domains.length());\n+    domains.remove(dom);\n+    dom->message_queue->disassociate();\n+    rust_srv *srv = dom->srv;\n+    delete dom;\n+    delete srv;\n+}\n+\n+rust_handle<rust_dom> *\n+rust_kernel::get_dom_handle(rust_dom *dom) {\n+    rust_handle<rust_dom> *handle = NULL;\n+    if (_dom_handles.get(dom, &handle)) {\n+        return handle;\n+    }\n+    handle = new (this) rust_handle<rust_dom>(this, dom->message_queue, dom);\n+    _dom_handles.put(dom, handle);\n+    return handle;\n+}\n+\n+rust_handle<rust_task> *\n+rust_kernel::get_task_handle(rust_task *task) {\n+    rust_handle<rust_task> *handle = NULL;\n+    if (_task_handles.get(task, &handle)) {\n+        return handle;\n+    }\n+    handle = new (this) rust_handle<rust_task>(this, task->dom->message_queue,\n+                                               task);\n+    _task_handles.put(task, handle);\n+    return handle;\n+}\n+\n+rust_handle<rust_port> *\n+rust_kernel::get_port_handle(rust_port *port) {\n+    rust_handle<rust_port> *handle = NULL;\n+    if (_port_handles.get(port, &handle)) {\n+        return handle;\n+    }\n+    handle = new (this) rust_handle<rust_port>(this,\n+       port->task->dom->message_queue, port);\n+    _port_handles.put(port, handle);\n+    return handle;\n }\n \n void\n-rust_kernel::deregister_domain(rust_dom *dom) {\n-    domains.remove(dom);\n+rust_kernel::join_all_domains() {\n+    // TODO: Perhaps we can do this a little smarter. Just spin wait for now.\n+    while (domains.length() > 0) {\n+        sync::yield();\n+    }\n }\n \n void\n@@ -30,6 +86,36 @@ rust_kernel::log_all_domain_state() {\n     }\n }\n \n+/**\n+ * Checks for simple deadlocks.\n+ */\n+bool\n+rust_kernel::is_deadlocked() {\n+    return false;\n+//    _lock.lock();\n+//    if (domains.length() != 1) {\n+//        // We can only check for deadlocks when only one domain exists.\n+//        return false;\n+//    }\n+//\n+//    if (domains[0]->running_tasks.length() != 0) {\n+//        // We are making progress and therefore we are not deadlocked.\n+//        return false;\n+//    }\n+//\n+//    if (domains[0]->message_queue->is_empty() &&\n+//        domains[0]->blocked_tasks.length() > 0) {\n+//        // We have no messages to process, no running tasks to schedule\n+//        // and some blocked tasks therefore we are likely in a deadlock.\n+//        log_all_domain_state();\n+//        return true;\n+//    }\n+//\n+//    _lock.unlock();\n+//    return false;\n+}\n+\n+\n void\n rust_kernel::log(uint32_t type_bits, char const *fmt, ...) {\n     char buf[256];\n@@ -41,3 +127,69 @@ rust_kernel::log(uint32_t type_bits, char const *fmt, ...) {\n         va_end(args);\n     }\n }\n+\n+void\n+rust_kernel::start_kernel_loop() {\n+    while (_interrupt_kernel_loop == false) {\n+        message_queues.global.lock();\n+        for (size_t i = 0; i < message_queues.length(); i++) {\n+            rust_message_queue *queue = message_queues[i];\n+            if (queue->is_associated() == false) {\n+                rust_message *message = NULL;\n+                while (queue->dequeue(&message)) {\n+                    message->kernel_process();\n+                    delete message;\n+                }\n+            }\n+        }\n+        message_queues.global.unlock();\n+    }\n+}\n+\n+void\n+rust_kernel::run() {\n+    log(rust_log::KERN, \"started kernel loop\");\n+    start_kernel_loop();\n+    log(rust_log::KERN, \"finished kernel loop\");\n+}\n+\n+rust_kernel::~rust_kernel() {\n+    K(_srv, domains.length() == 0,\n+      \"Kernel has %d live domain(s), join all domains before killing \"\n+       \"the kernel.\", domains.length());\n+\n+    // If the kernel loop is running, interrupt it, join and exit.\n+    if (is_running()) {\n+        _interrupt_kernel_loop = true;\n+        join();\n+    }\n+\n+    free_handles(_task_handles);\n+    free_handles(_port_handles);\n+    free_handles(_dom_handles);\n+\n+    rust_message_queue *queue = NULL;\n+    while (message_queues.pop(&queue)) {\n+        K(_srv, queue->is_empty(), \"Kernel message queue should be empty \"\n+          \"before killing the kernel.\");\n+        delete queue;\n+    }\n+}\n+\n+void *\n+rust_kernel::malloc(size_t size) {\n+    return _region->malloc(size);\n+}\n+\n+void rust_kernel::free(void *mem) {\n+    _region->free(mem);\n+}\n+\n+template<class T> void\n+rust_kernel::free_handles(hash_map<T*, rust_handle<T>* > &map) {\n+    T* key;\n+    rust_handle<T> *value;\n+    while (map.pop(&key, &value)) {\n+        delete value;\n+    }\n+}"}, {"sha": "902a9a2f3b46a5ce9ac1eacc432d18cdf73e28ca", "filename": "src/rt/rust_kernel.h", "status": "modified", "additions": 99, "deletions": 6, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/de611a309006f0976bc9a579eb1087e7a89f79a7/src%2Frt%2Frust_kernel.h", "raw_url": "https://github.com/rust-lang/rust/raw/de611a309006f0976bc9a579eb1087e7a89f79a7/src%2Frt%2Frust_kernel.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_kernel.h?ref=de611a309006f0976bc9a579eb1087e7a89f79a7", "patch": "@@ -2,20 +2,113 @@\n #define RUST_KERNEL_H\n \n /**\n- * A global object shared by all domains.\n+ * A handle object for Rust tasks. We need a reference to the message queue\n+ * of the referent's domain which we can safely hang on to since it's a\n+ * kernel object. We use the referent reference as a label we stash in\n+ * messages sent via this proxy.\n  */\n-class rust_kernel {\n-    memory_region &_region;\n+\n+class rust_kernel;\n+\n+template <typename T> class\n+rust_handle :\n+    public rust_cond,\n+    public rc_base<rust_handle<T> >,\n+    public kernel_owned<rust_handle<T> > {\n+public:\n+    rust_kernel *kernel;\n+    rust_message_queue *message_queue;\n+    T *_referent;\n+    T * referent() {\n+        return _referent;\n+    }\n+    rust_handle(rust_kernel *kernel,\n+                rust_message_queue *message_queue,\n+                T *referent) :\n+                kernel(kernel),\n+                message_queue(message_queue),\n+                _referent(referent) {\n+        // Nop.\n+    }\n+};\n+\n+/**\n+ * A global object shared by all thread domains. Most of the data structures\n+ * in this class are synchronized since they are accessed from multiple\n+ * threads.\n+ */\n+class rust_kernel : public rust_thread {\n+    memory_region *_region;\n     rust_log _log;\n+    rust_srv *_srv;\n+\n+    /**\n+     * Task proxy objects are kernel owned handles to Rust objects.\n+     */\n+    hash_map<rust_task *, rust_handle<rust_task> *> _task_handles;\n+    hash_map<rust_port *, rust_handle<rust_port> *> _port_handles;\n+    hash_map<rust_dom *, rust_handle<rust_dom> *> _dom_handles;\n+\n+    template<class T> void free_handles(hash_map<T*, rust_handle<T>* > &map);\n+\n+    void run();\n+    void start_kernel_loop();\n+    bool volatile _interrupt_kernel_loop;\n+\n+    /**\n+     * Lock for the message queue list, so we can safely\n+     */\n+    spin_lock _message_queues_lock;\n+\n public:\n+\n+    /**\n+     * List of domains that are currently executing.\n+     */\n     synchronized_indexed_list<rust_dom> domains;\n-    synchronized_indexed_list<lock_free_queue<rust_message*> > message_queues;\n+\n+    /**\n+     * Message queues are kernel objects and are associated with domains.\n+     * Their lifetime is not bound to the lifetime of a domain and in fact\n+     * live on after their associated domain has died. This way we can safely\n+     * communicate with domains that may have died.\n+     *\n+     * Although the message_queues list is synchronized, each individual\n+     * message queue is lock free.\n+     */\n+    synchronized_indexed_list<rust_message_queue> message_queues;\n+\n+    rust_handle<rust_dom> *get_dom_handle(rust_dom *dom);\n+    rust_handle<rust_task> *get_task_handle(rust_task *task);\n+    rust_handle<rust_port> *get_port_handle(rust_port *port);\n+\n     rust_kernel(rust_srv *srv);\n-    void register_domain(rust_dom *dom);\n-    void deregister_domain(rust_dom *dom);\n+\n+    rust_handle<rust_dom> *create_domain(rust_crate const *root_crate,\n+                                         const char *name);\n+    void destroy_domain(rust_dom *dom);\n+\n+    bool is_deadlocked();\n+\n+    /**\n+     * Blocks until all domains have terminated.\n+     */\n+    void join_all_domains();\n+\n     void log_all_domain_state();\n     void log(uint32_t type_bits, char const *fmt, ...);\n     virtual ~rust_kernel();\n+\n+    void *malloc(size_t size);\n+    void free(void *mem);\n };\n \n+inline void *operator new(size_t size, rust_kernel *kernel) {\n+    return kernel->malloc(size);\n+}\n+\n+inline void *operator new(size_t size, rust_kernel &kernel) {\n+    return kernel.malloc(size);\n+}\n+\n #endif /* RUST_KERNEL_H */"}, {"sha": "dab13c091e2ca9f8fa290737eb5ec799f32aefce", "filename": "src/rt/rust_message.cpp", "status": "modified", "additions": 63, "deletions": 39, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/de611a309006f0976bc9a579eb1087e7a89f79a7/src%2Frt%2Frust_message.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/de611a309006f0976bc9a579eb1087e7a89f79a7/src%2Frt%2Frust_message.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_message.cpp?ref=de611a309006f0976bc9a579eb1087e7a89f79a7", "patch": "@@ -2,36 +2,35 @@\n #include \"rust_message.h\"\n \n rust_message::\n-rust_message(const char* label, rust_task *source, rust_task *target) :\n-             label(label),\n-             _dom(target->dom),\n-             _source(source),\n-             _target(target) {\n+rust_message(memory_region *region, const char* label,\n+             rust_handle<rust_task> *source, rust_handle<rust_task> *target) :\n+             label(label), region(region), _source(source), _target(target) {\n }\n \n rust_message::~rust_message() {\n+    // Nop.\n }\n \n void rust_message::process() {\n-    I(_dom, false);\n+    // Nop.\n }\n \n-rust_proxy<rust_task> *\n-rust_message::get_source_proxy() {\n-    return _dom->get_task_proxy(_source);\n+void rust_message::kernel_process() {\n+    // Nop.\n }\n \n notify_message::\n-notify_message(notification_type type, const char* label,\n-               rust_task *source,\n-               rust_task *target) :\n-               rust_message(label, source, target), type(type) {\n+notify_message(memory_region *region, notification_type type,\n+    const char* label, rust_handle<rust_task> *source,\n+    rust_handle<rust_task> *target) :\n+    rust_message(region, label, source, target), type(type) {\n }\n \n data_message::\n-data_message(uint8_t *buffer, size_t buffer_sz, const char* label,\n-             rust_task *source, rust_task *target, rust_port *port) :\n-             rust_message(label, source, target),\n+data_message(memory_region *region, uint8_t *buffer, size_t buffer_sz,\n+             const char* label, rust_handle<rust_task> *source,\n+             rust_handle<rust_port> *port) :\n+             rust_message(region, label, source, NULL),\n              _buffer_sz(buffer_sz), _port(port) {\n     _buffer = (uint8_t *)malloc(buffer_sz);\n     memcpy(_buffer, buffer, buffer_sz);\n@@ -47,54 +46,79 @@ data_message::~data_message() {\n  * source task.\n  */\n void notify_message::\n-send(notification_type type, const char* label, rust_task *source,\n-     rust_proxy<rust_task> *target) {\n-    rust_task *target_task = target->delegate();\n-    rust_dom *target_domain = target_task->dom;\n+send(notification_type type, const char* label,\n+     rust_handle<rust_task> *source, rust_handle<rust_task> *target) {\n+    memory_region *region = &target->message_queue->region;\n     notify_message *message =\n-        new (target_domain, memory_region::SYNCHRONIZED) notify_message(type,\n-            label, source, target_task);\n-    target_domain->send_message(message);\n+        new (region) notify_message(region, type, label, source, target);\n+//    target->referent()->log(rust_log::COMM,\n+//                            \"==> sending \\\"%s\\\" \" PTR \" in queue \" PTR,\n+//                            label, message, &target->message_queue);\n+    target->message_queue->enqueue(message);\n }\n \n void notify_message::process() {\n-    rust_task *task = _target;\n+    rust_task *task = _target->referent();\n     switch (type) {\n     case KILL:\n-        task->ref_count--;\n+        // task->ref_count--;\n         task->kill();\n         break;\n     case JOIN: {\n         if (task->dead() == false) {\n-            task->tasks_waiting_to_join.append(get_source_proxy());\n+            rust_proxy<rust_task> *proxy = new rust_proxy<rust_task>(_source);\n+            task->tasks_waiting_to_join.append(proxy);\n         } else {\n-            send(WAKEUP, \"wakeup\", task, get_source_proxy());\n+            send(WAKEUP, \"wakeup\", _target, _source);\n         }\n         break;\n     }\n     case WAKEUP:\n-        task->wakeup(get_source_proxy()->delegate());\n+        task->wakeup(_source);\n+        break;\n+    }\n+}\n+\n+void notify_message::kernel_process() {\n+    switch(type) {\n+    case WAKEUP:\n+    case KILL:\n+        // Ignore.\n+        break;\n+    case JOIN:\n+        send(WAKEUP, \"wakeup\", _target, _source);\n         break;\n     }\n }\n \n void data_message::\n-send(uint8_t *buffer, size_t buffer_sz, const char* label, rust_task *source,\n-     rust_proxy<rust_task> *target, rust_proxy<rust_port> *port) {\n+send(uint8_t *buffer, size_t buffer_sz, const char* label,\n+     rust_handle<rust_task> *source, rust_handle<rust_port> *port) {\n \n-    rust_task *target_task = target->delegate();\n-    rust_port *target_port = port->delegate();\n-    rust_dom *target_domain = target_task->dom;\n+    memory_region *region = &port->message_queue->region;\n     data_message *message =\n-        new (target_domain, memory_region::SYNCHRONIZED)\n-            data_message(buffer, buffer_sz, label, source,\n-                target_task, target_port);\n-    target_domain->send_message(message);\n+        new (region) data_message(region, buffer, buffer_sz, label, source,\n+                                  port);\n+    source->referent()->log(rust_log::COMM,\n+                            \"==> sending \\\"%s\\\"\" PTR \" in queue \" PTR,\n+                            label, message, &port->message_queue);\n+    port->message_queue->enqueue(message);\n }\n \n void data_message::process() {\n-    _port->remote_channel->send(_buffer);\n-    _target->log(rust_log::COMM, \"<=== received data via message ===\");\n+    _port->referent()->remote_channel->send(_buffer);\n+    // _target->referent()->log(rust_log::COMM,\n+    //                         \"<=== received data via message ===\");\n+}\n+\n+void data_message::kernel_process() {\n+\n+}\n+\n+rust_message_queue::rust_message_queue(rust_srv *srv, rust_kernel *kernel) :\n+                                       region (srv, true), kernel(kernel),\n+                                       dom_handle(NULL) {\n+    // Nop.\n }\n \n //"}, {"sha": "c342e3e411a3d64b9886c86c6c3ef15fb3a38060", "filename": "src/rt/rust_message.h", "status": "modified", "additions": 54, "deletions": 19, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/de611a309006f0976bc9a579eb1087e7a89f79a7/src%2Frt%2Frust_message.h", "raw_url": "https://github.com/rust-lang/rust/raw/de611a309006f0976bc9a579eb1087e7a89f79a7/src%2Frt%2Frust_message.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_message.h?ref=de611a309006f0976bc9a579eb1087e7a89f79a7", "patch": "@@ -9,28 +9,31 @@\n /**\n  * Abstract base class for all message types.\n  */\n-class rust_message {\n+class rust_message : public region_owned<rust_message> {\n public:\n     const char* label;\n+    memory_region *region;\n private:\n-    rust_dom *_dom;\n-    rust_task *_source;\n protected:\n-    rust_task *_target;\n+    rust_handle<rust_task> *_source;\n+    rust_handle<rust_task> *_target;\n public:\n-    rust_message(const char* label, rust_task *source, rust_task *target);\n+    rust_message(memory_region *region,\n+                 const char* label,\n+                 rust_handle<rust_task> *source,\n+                 rust_handle<rust_task> *target);\n+\n     virtual ~rust_message();\n \n     /**\n-     * We can only access the source task through a proxy, so create one\n-     * on demand if we need it.\n+     * Processes the message in the target domain.\n      */\n-    rust_proxy<rust_task> *get_source_proxy();\n+    virtual void process();\n \n     /**\n-     * Processes the message in the target domain thread.\n+     * Processes the message in the kernel.\n      */\n-    virtual void process();\n+    virtual void kernel_process();\n };\n \n /**\n@@ -44,17 +47,19 @@ class notify_message : public rust_message {\n \n     const notification_type type;\n \n-    notify_message(notification_type type, const char* label,\n-                   rust_task *source, rust_task *target);\n+    notify_message(memory_region *region, notification_type type,\n+                   const char* label, rust_handle<rust_task> *source,\n+                   rust_handle<rust_task> *target);\n \n     void process();\n+    void kernel_process();\n \n     /**\n      * This code executes in the sending domain's thread.\n      */\n     static void\n-    send(notification_type type, const char* label, rust_task *source,\n-         rust_proxy<rust_task> *target);\n+    send(notification_type type, const char* label,\n+         rust_handle<rust_task> *source, rust_handle<rust_task> *target);\n };\n \n /**\n@@ -64,21 +69,51 @@ class data_message : public rust_message {\n private:\n     uint8_t *_buffer;\n     size_t _buffer_sz;\n-    rust_port *_port;\n+    rust_handle<rust_port> *_port;\n+\n public:\n+    data_message(memory_region *region, uint8_t *buffer, size_t buffer_sz,\n+                 const char* label, rust_handle<rust_task> *source,\n+                 rust_handle<rust_port> *port);\n \n-    data_message(uint8_t *buffer, size_t buffer_sz, const char* label,\n-                 rust_task *source, rust_task *target, rust_port *port);\n     virtual ~data_message();\n     void process();\n+    void kernel_process();\n \n     /**\n      * This code executes in the sending domain's thread.\n      */\n     static void\n     send(uint8_t *buffer, size_t buffer_sz, const char* label,\n-         rust_task *source, rust_proxy<rust_task> *target,\n-         rust_proxy<rust_port> *port);\n+         rust_handle<rust_task> *source, rust_handle<rust_port> *port);\n+};\n+\n+class rust_message_queue : public lock_free_queue<rust_message*>,\n+                           public kernel_owned<rust_message_queue> {\n+public:\n+    memory_region region;\n+    rust_kernel *kernel;\n+    rust_handle<rust_dom> *dom_handle;\n+    int32_t list_index;\n+    rust_message_queue(rust_srv *srv, rust_kernel *kernel);\n+\n+    void associate(rust_handle<rust_dom> *dom_handle) {\n+        this->dom_handle = dom_handle;\n+    }\n+\n+    /**\n+     * The Rust domain relinquishes control to the Rust kernel.\n+     */\n+    void disassociate() {\n+        this->dom_handle = NULL;\n+    }\n+\n+    /**\n+     * Checks if a Rust domain is responsible for draining the message queue.\n+     */\n+    bool is_associated() {\n+        return this->dom_handle != NULL;\n+    }\n };\n \n //"}, {"sha": "82054687f2f6d63459ed9a18906d441e46d28005", "filename": "src/rt/rust_port.cpp", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/de611a309006f0976bc9a579eb1087e7a89f79a7/src%2Frt%2Frust_port.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/de611a309006f0976bc9a579eb1087e7a89f79a7/src%2Frt%2Frust_port.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_port.cpp?ref=de611a309006f0976bc9a579eb1087e7a89f79a7", "patch": "@@ -2,15 +2,15 @@\n #include \"rust_port.h\"\n \n rust_port::rust_port(rust_task *task, size_t unit_sz) :\n-    maybe_proxy<rust_port>(this), task(task), unit_sz(unit_sz),\n-    writers(task->dom), chans(task->dom) {\n+                     maybe_proxy<rust_port>(this), task(task),\n+                     unit_sz(unit_sz), writers(task->dom), chans(task->dom) {\n \n     task->log(rust_log::MEM | rust_log::COMM,\n               \"new rust_port(task=0x%\" PRIxPTR \", unit_sz=%d) -> port=0x%\"\n               PRIxPTR, (uintptr_t)task, unit_sz, (uintptr_t)this);\n \n     // Allocate a remote channel, for remote channel data.\n-    remote_channel = new (task->dom) rust_chan(task, this);\n+    remote_channel = new (task->dom) rust_chan(task, this, unit_sz);\n }\n \n rust_port::~rust_port() {"}, {"sha": "2b5e820da100a1cdc2847b96299e447e97c0ad11", "filename": "src/rt/rust_proxy.h", "status": "modified", "additions": 33, "deletions": 20, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/de611a309006f0976bc9a579eb1087e7a89f79a7/src%2Frt%2Frust_proxy.h", "raw_url": "https://github.com/rust-lang/rust/raw/de611a309006f0976bc9a579eb1087e7a89f79a7/src%2Frt%2Frust_proxy.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_proxy.h?ref=de611a309006f0976bc9a579eb1087e7a89f79a7", "patch": "@@ -2,57 +2,70 @@\n #define RUST_PROXY_H\n \n /**\n- * A proxy object is a wrapper around other Rust objects. One use of the proxy\n- * object is to mitigate access between tasks in different thread domains.\n+ * A proxy object is a wrapper for remote objects. Proxy objects are domain\n+ * owned and provide a way distinguish between local and remote objects.\n  */\n \n template <typename T> struct rust_proxy;\n+\n /**\n  * The base class of all objects that may delegate.\n  */\n template <typename T> struct\n maybe_proxy : public rc_base<T>, public rust_cond {\n protected:\n-    T *_delegate;\n+    T *_referent;\n public:\n-    maybe_proxy(T * delegate) : _delegate(delegate) {\n-\n+    maybe_proxy(T *referent) : _referent(referent) {\n+        // Nop.\n     }\n-    T *delegate() {\n-        return _delegate;\n+\n+    T *referent() {\n+        return (T *)_referent;\n     }\n+\n     bool is_proxy() {\n-        return _delegate != this;\n+        return _referent != this;\n     }\n+\n     rust_proxy<T> *as_proxy() {\n         return (rust_proxy<T> *) this;\n     }\n-    T *as_delegate() {\n-        I(_delegate->get_dom(), !is_proxy());\n+\n+    T *as_referent() {\n         return (T *) this;\n     }\n };\n \n+template <typename T> class rust_handle;\n+\n /**\n  * A proxy object that delegates to another.\n  */\n template <typename T> struct\n-rust_proxy : public maybe_proxy<T>,\n-             public dom_owned<rust_proxy<T> > {\n+rust_proxy : public maybe_proxy<T> {\n private:\n     bool _strong;\n+    rust_handle<T> *_handle;\n public:\n-    rust_dom *dom;\n-    rust_proxy(rust_dom *dom, T *delegate, bool strong) :\n-        maybe_proxy<T> (delegate), _strong(strong), dom(dom) {\n-        this->dom->log(rust_log::COMM,\n-            \"new proxy: 0x%\" PRIxPTR \" => 0x%\" PRIxPTR, this, delegate);\n-        if (strong) {\n-            delegate->ref();\n-        }\n+    rust_proxy(rust_handle<T> *handle) :\n+        maybe_proxy<T> (NULL), _strong(FALSE), _handle(handle) {\n+        // Nop.\n+    }\n+\n+    rust_proxy(T *referent) :\n+        maybe_proxy<T> (referent), _strong(FALSE), _handle(NULL) {\n+        // Nop.\n+    }\n+\n+    rust_handle<T> *handle() {\n+        return _handle;\n     }\n };\n \n+class rust_message_queue;\n+class rust_task;\n+\n //\n // Local Variables:\n // mode: C++"}, {"sha": "a5fcde9b3a0438499a53bfb076f72d7d53fb646f", "filename": "src/rt/rust_srv.cpp", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/de611a309006f0976bc9a579eb1087e7a89f79a7/src%2Frt%2Frust_srv.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/de611a309006f0976bc9a579eb1087e7a89f79a7/src%2Frt%2Frust_srv.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_srv.cpp?ref=de611a309006f0976bc9a579eb1087e7a89f79a7", "patch": "@@ -7,13 +7,14 @@\n \n rust_srv::rust_srv() :\n     local_region(this, false),\n-    synchronized_region(this, true),\n-    kernel(new rust_kernel(this)) {\n+    synchronized_region(this, true) {\n     // Nop.\n }\n \n rust_srv::~rust_srv() {\n-    // Nop.\n+//    char msg[1024];\n+//    snprintf(msg, sizeof(msg), \"~rust_srv %\" PRIxPTR, (uintptr_t) this);\n+//    log(msg);\n }\n \n void\n@@ -74,3 +75,8 @@ rust_srv::warning(char const *expression,\n              expression, file, (int)line, buf);\n     log(msg);\n }\n+\n+rust_srv *\n+rust_srv::clone() {\n+    return new rust_srv();\n+}"}, {"sha": "465b03b7ecc3b8b15de1ee70a16d277a9f31b55f", "filename": "src/rt/rust_srv.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/de611a309006f0976bc9a579eb1087e7a89f79a7/src%2Frt%2Frust_srv.h", "raw_url": "https://github.com/rust-lang/rust/raw/de611a309006f0976bc9a579eb1087e7a89f79a7/src%2Frt%2Frust_srv.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_srv.h?ref=de611a309006f0976bc9a579eb1087e7a89f79a7", "patch": "@@ -7,7 +7,6 @@ class rust_srv {\n public:\n     memory_region local_region;\n     memory_region synchronized_region;\n-    rust_kernel *kernel;\n     virtual void log(char const *msg);\n     virtual void fatal(char const *expression,\n         char const *file,\n@@ -24,6 +23,7 @@ class rust_srv {\n     virtual void *realloc(void *, size_t);\n     rust_srv();\n     virtual ~rust_srv();\n+    virtual rust_srv *clone();\n };\n \n #endif /* RUST_SRV_H */"}, {"sha": "408996f69db69b17bf66ae0c50b8291ba50f7a63", "filename": "src/rt/rust_task.cpp", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/de611a309006f0976bc9a579eb1087e7a89f79a7/src%2Frt%2Frust_task.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/de611a309006f0976bc9a579eb1087e7a89f79a7/src%2Frt%2Frust_task.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task.cpp?ref=de611a309006f0976bc9a579eb1087e7a89f79a7", "patch": "@@ -404,9 +404,10 @@ rust_task::notify_tasks_waiting_to_join() {\n         tasks_waiting_to_join.pop(&waiting_task);\n         if (waiting_task->is_proxy()) {\n             notify_message::send(notify_message::WAKEUP, \"wakeup\",\n-                                 this, waiting_task->as_proxy());\n+                get_handle(), waiting_task->as_proxy()->handle());\n+            delete waiting_task;\n         } else {\n-            rust_task *task = waiting_task->delegate();\n+            rust_task *task = waiting_task->referent();\n             if (task->dead() == false) {\n                 task->wakeup(this);\n             }\n@@ -563,8 +564,7 @@ rust_task::transition(ptr_vec<rust_task> *src, ptr_vec<rust_task> *dst)\n }\n \n void\n-rust_task::block(rust_cond *on, const char* name)\n-{\n+rust_task::block(rust_cond *on, const char* name) {\n     log(rust_log::TASK, \"Blocking on 0x%\" PRIxPTR \", cond: 0x%\" PRIxPTR,\n                          (uintptr_t) on, (uintptr_t) cond);\n     A(dom, cond == NULL, \"Cannot block an already blocked task.\");\n@@ -631,6 +631,11 @@ rust_task::log(uint32_t type_bits, char const *fmt, ...) {\n     }\n }\n \n+rust_handle<rust_task> *\n+rust_task::get_handle() {\n+    return dom->kernel->get_task_handle(this);\n+}\n+\n //\n // Local Variables:\n // mode: C++"}, {"sha": "383707f0aeb6e306916e1e5503d2643df8e848f8", "filename": "src/rt/rust_task.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/de611a309006f0976bc9a579eb1087e7a89f79a7/src%2Frt%2Frust_task.h", "raw_url": "https://github.com/rust-lang/rust/raw/de611a309006f0976bc9a579eb1087e7a89f79a7/src%2Frt%2Frust_task.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task.h?ref=de611a309006f0976bc9a579eb1087e7a89f79a7", "patch": "@@ -50,6 +50,7 @@ rust_task : public maybe_proxy<rust_task>,\n     rust_task(rust_dom *dom,\n               rust_task *spawner,\n               const char *name);\n+\n     ~rust_task();\n \n     void start(uintptr_t exit_task_glue,\n@@ -110,6 +111,8 @@ rust_task : public maybe_proxy<rust_task>,\n     // Notify tasks waiting for us that we are about to die.\n     void notify_tasks_waiting_to_join();\n \n+    rust_handle<rust_task> * get_handle();\n+\n     uintptr_t get_fp();\n     uintptr_t get_previous_fp(uintptr_t fp);\n     frame_glue_fns *get_frame_glue_fns(uintptr_t fp);"}, {"sha": "4b5fa1d631b3462e99ebbb67f1794c5219cd22a8", "filename": "src/rt/rust_upcall.cpp", "status": "modified", "additions": 100, "deletions": 112, "changes": 212, "blob_url": "https://github.com/rust-lang/rust/blob/de611a309006f0976bc9a579eb1087e7a89f79a7/src%2Frt%2Frust_upcall.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/de611a309006f0976bc9a579eb1087e7a89f79a7/src%2Frt%2Frust_upcall.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_upcall.cpp?ref=de611a309006f0976bc9a579eb1087e7a89f79a7", "patch": "@@ -23,20 +23,6 @@\n     (task)->dom->get_log().indent();\n #endif\n \n-void\n-log_task_state(rust_task *task, maybe_proxy<rust_task> *target) {\n-    rust_task *delegate = target->delegate();\n-    if (target->is_proxy()) {\n-        task->log(rust_log::TASK,\n-                  \"remote task: 0x%\" PRIxPTR \", ref_count: %d state: %s\",\n-                  delegate, delegate->ref_count, delegate->state_str());\n-    } else {\n-        task->log(rust_log::TASK,\n-                  \"local task: 0x%\" PRIxPTR \", ref_count: %d state: %s\",\n-                  delegate, delegate->ref_count, delegate->state_str());\n-    }\n-}\n-\n extern \"C\" CDECL char const *\n str_buf(rust_task *task, rust_str *s);\n \n@@ -104,7 +90,7 @@ upcall_new_chan(rust_task *task, rust_port *port) {\n               \"task=0x%\" PRIxPTR \" (%s), port=0x%\" PRIxPTR \")\",\n               (uintptr_t) task, task->name, port);\n     I(dom, port);\n-    return new (dom) rust_chan(task, port);\n+    return new (dom) rust_chan(task, port, port->unit_sz);\n }\n \n /**\n@@ -135,43 +121,55 @@ void upcall_del_chan(rust_task *task, rust_chan *chan) {\n       \"Channel's ref count should be zero.\");\n \n     if (chan->is_associated()) {\n-        // We're trying to delete a channel that another task may be reading\n-        // from. We have two options:\n-        //\n-        // 1. We can flush the channel by blocking in upcall_flush_chan()\n-        //    and resuming only when the channel is flushed. The problem\n-        //    here is that we can get ourselves in a deadlock if the parent\n-        //    task tries to join us.\n-        //\n-        // 2. We can leave the channel in a \"dormnat\" state by not freeing\n-        //    it and letting the receiver task delete it for us instead.\n-        if (chan->buffer.is_empty() == false) {\n-            return;\n+        if (chan->port->is_proxy()) {\n+            // Here is a good place to delete the port proxy we allocated\n+            // in upcall_clone_chan.\n+            rust_proxy<rust_port> *proxy = chan->port->as_proxy();\n+            chan->disassociate();\n+            delete proxy;\n+        } else {\n+            // We're trying to delete a channel that another task may be\n+            // reading from. We have two options:\n+            //\n+            // 1. We can flush the channel by blocking in upcall_flush_chan()\n+            //    and resuming only when the channel is flushed. The problem\n+            //    here is that we can get ourselves in a deadlock if the\n+            //    parent task tries to join us.\n+            //\n+            // 2. We can leave the channel in a \"dormnat\" state by not freeing\n+            //    it and letting the receiver task delete it for us instead.\n+            if (chan->buffer.is_empty() == false) {\n+                return;\n+            }\n+            chan->disassociate();\n         }\n-        chan->disassociate();\n     }\n     delete chan;\n }\n \n /**\n  * Clones a channel and stores it in the spawnee's domain. Each spawned task\n- * has it's own copy of the channel.\n+ * has its own copy of the channel.\n  */\n extern \"C\" CDECL rust_chan *\n-upcall_clone_chan(rust_task *task,\n-                  maybe_proxy<rust_task> *target,\n+upcall_clone_chan(rust_task *task, maybe_proxy<rust_task> *target,\n                   rust_chan *chan) {\n     LOG_UPCALL_ENTRY(task);\n-    task->log(rust_log::UPCALL | rust_log::COMM,\n-              \"target: 0x%\" PRIxPTR \", chan: 0x%\" PRIxPTR,\n-              target, chan);\n-    rust_task *target_task = target->delegate();\n+    size_t unit_sz = chan->buffer.unit_sz;\n     maybe_proxy<rust_port> *port = chan->port;\n-    if (target->is_proxy()) {\n-        port = target_task->dom->get_port_proxy_synchronized(\n-                chan->port->as_delegate());\n+    rust_task *target_task = NULL;\n+    if (target->is_proxy() == false) {\n+        port = chan->port;\n+        target_task = target->referent();\n+    } else {\n+        rust_handle<rust_port> *handle =\n+            task->dom->kernel->get_port_handle(port->as_referent());\n+        maybe_proxy<rust_port> *proxy = new rust_proxy<rust_port> (handle);\n+        task->log(rust_log::MEM, \"new proxy: \" PTR, proxy);\n+        port = proxy;\n+        target_task = target->as_proxy()->handle()->referent();\n     }\n-    return new (target_task->dom) rust_chan(target_task, port);\n+    return new (target_task->dom) rust_chan(target_task, port, unit_sz);\n }\n \n extern \"C\" CDECL void\n@@ -193,17 +191,15 @@ upcall_sleep(rust_task *task, size_t time_in_us) {\n extern \"C\" CDECL void\n upcall_join(rust_task *task, maybe_proxy<rust_task> *target) {\n     LOG_UPCALL_ENTRY(task);\n-    rust_task *target_task = target->delegate();\n-    task->log(rust_log::UPCALL | rust_log::COMM,\n-              \"target: 0x%\" PRIxPTR \", task: %s @0x%\" PRIxPTR,\n-              target, target_task->name, target_task);\n \n     if (target->is_proxy()) {\n-        notify_message::\n-        send(notify_message::JOIN, \"join\", task, target->as_proxy());\n-        task->block(target_task, \"joining remote task\");\n+        rust_handle<rust_task> *task_handle = target->as_proxy()->handle();\n+        notify_message::send(notify_message::JOIN, \"join\",\n+                             task->get_handle(), task_handle);\n+        task->block(task_handle, \"joining remote task\");\n         task->yield(2);\n     } else {\n+        rust_task *target_task = target->referent();\n         // If the other task is already dying, we don't have to wait for it.\n         if (target_task->dead() == false) {\n             target_task->tasks_waiting_to_join.push(task);\n@@ -221,10 +217,6 @@ upcall_join(rust_task *task, maybe_proxy<rust_task> *target) {\n extern \"C\" CDECL void\n upcall_send(rust_task *task, rust_chan *chan, void *sptr) {\n     LOG_UPCALL_ENTRY(task);\n-    task->log(rust_log::UPCALL | rust_log::COMM,\n-              \"chan: 0x%\" PRIxPTR \", sptr: 0x%\" PRIxPTR \", size: %d\",\n-              (uintptr_t) chan, (uintptr_t) sptr,\n-              chan->port->delegate()->unit_sz);\n     chan->send(sptr);\n     task->log(rust_log::COMM, \"=== sent data ===>\");\n }\n@@ -269,21 +261,14 @@ upcall_fail(rust_task *task,\n extern \"C\" CDECL void\n upcall_kill(rust_task *task, maybe_proxy<rust_task> *target) {\n     LOG_UPCALL_ENTRY(task);\n-    log_task_state(task, target);\n-    rust_task *target_task = target->delegate();\n-\n-    task->log(rust_log::UPCALL | rust_log::TASK,\n-              \"kill task %s @0x%\" PRIxPTR \", ref count %d\",\n-              target_task->name, target_task,\n-              target_task->ref_count);\n-\n     if (target->is_proxy()) {\n         notify_message::\n-        send(notify_message::KILL, \"kill\", task, target->as_proxy());\n+        send(notify_message::KILL, \"kill\", task->get_handle(),\n+             target->as_proxy()->handle());\n         // The proxy ref_count dropped to zero, delete it here.\n         delete target->as_proxy();\n     } else {\n-        target_task->kill();\n+        target->referent()->kill();\n     }\n }\n \n@@ -554,25 +539,6 @@ upcall_get_type_desc(rust_task *task,\n     return td;\n }\n \n-#if defined(__WIN32__)\n-static DWORD WINAPI rust_thread_start(void *ptr)\n-#elif defined(__GNUC__)\n-static void *rust_thread_start(void *ptr)\n-#else\n-#error \"Platform not supported\"\n-#endif\n-{\n-    // We were handed the domain we are supposed to run.\n-    rust_dom *dom = (rust_dom *) ptr;\n-\n-    // Start a new rust main loop for this thread.\n-    dom->start_main_loop();\n-    rust_srv *srv = dom->srv;\n-    srv->kernel->deregister_domain(dom);\n-    delete dom;\n-    return 0;\n-}\n-\n extern \"C\" CDECL rust_task *\n upcall_new_task(rust_task *spawner, const char *name) {\n     LOG_UPCALL_ENTRY(spawner);\n@@ -604,54 +570,76 @@ upcall_start_task(rust_task *spawner,\n     return task;\n }\n \n+/**\n+ * Called whenever a new domain is created.\n+ */\n extern \"C\" CDECL maybe_proxy<rust_task> *\n upcall_new_thread(rust_task *task, const char *name) {\n     LOG_UPCALL_ENTRY(task);\n-\n-    rust_dom *old_dom = task->dom;\n-    rust_dom *new_dom = new rust_dom(old_dom->srv,\n-                                     old_dom->root_crate,\n-                                     name);\n-    old_dom->srv->kernel->register_domain(new_dom);\n+    rust_dom *parent_dom = task->dom;\n+    rust_kernel *kernel = parent_dom->kernel;\n+    rust_handle<rust_dom> *child_dom_handle =\n+        kernel->create_domain(parent_dom->root_crate, name);\n+    rust_handle<rust_task> *child_task_handle =\n+        kernel->get_task_handle(child_dom_handle->referent()->root_task);\n     task->log(rust_log::UPCALL | rust_log::MEM,\n-              \"upcall new_thread(%s) = dom 0x%\" PRIxPTR \" task 0x%\" PRIxPTR,\n-              name, new_dom, new_dom->root_task);\n-    rust_proxy<rust_task> *proxy =\n-        new (old_dom) rust_proxy<rust_task>(old_dom,\n-                                            new_dom->root_task, true);\n-    task->log(rust_log::UPCALL | rust_log::MEM,\n-              \"new proxy = 0x%\" PRIxPTR \" -> task = 0x%\" PRIxPTR,\n-              proxy, proxy->delegate());\n-    return proxy;\n+              \"child name: %s, child_dom_handle: \" PTR\n+              \", child_task_handle: \" PTR,\n+              name, child_dom_handle, child_task_handle);\n+    rust_proxy<rust_task> *child_task_proxy =\n+        new rust_proxy<rust_task> (child_task_handle);\n+    return child_task_proxy;\n+}\n+\n+#if defined(__WIN32__)\n+static DWORD WINAPI rust_thread_start(void *ptr)\n+#elif defined(__GNUC__)\n+static void *rust_thread_start(void *ptr)\n+#else\n+#error \"Platform not supported\"\n+#endif\n+{\n+    // We were handed the domain we are supposed to run.\n+    rust_dom *dom = (rust_dom *) ptr;\n+\n+    // Start a new rust main loop for this thread.\n+    dom->start_main_loop();\n+\n+    // Destroy the domain.\n+    dom->kernel->destroy_domain(dom);\n+\n+    return 0;\n }\n \n+/**\n+ * Called after a new domain is created. Here we create a new thread and\n+ * and start the domain main loop.\n+ */\n extern \"C\" CDECL maybe_proxy<rust_task> *\n-upcall_start_thread(rust_task *spawner,\n-                    maybe_proxy<rust_task> *root_task_proxy,\n+upcall_start_thread(rust_task *task,\n+                    rust_proxy<rust_task> *child_task_proxy,\n                     uintptr_t exit_task_glue,\n                     uintptr_t spawnee_fn,\n                     size_t callsz) {\n-    LOG_UPCALL_ENTRY(spawner);\n-\n-    rust_dom *dom = spawner->dom;\n-    rust_task *root_task = root_task_proxy->delegate();\n-    dom->log(rust_log::UPCALL | rust_log::MEM | rust_log::TASK,\n-             \"upcall start_thread(exit_task_glue 0x%\" PRIxPTR\n-             \", spawnee 0x%\" PRIxPTR\n-             \", callsz %\" PRIdPTR \")\", exit_task_glue, spawnee_fn, callsz);\n-    root_task->start(exit_task_glue, spawnee_fn, spawner->rust_sp, callsz);\n-\n+    LOG_UPCALL_ENTRY(task);\n+    rust_dom *parenet_dom = task->dom;\n+    rust_handle<rust_task> *child_task_handle = child_task_proxy->handle();\n+    task->log(rust_log::UPCALL | rust_log::MEM | rust_log::TASK,\n+              \"exit_task_glue: \" PTR \", spawnee_fn \" PTR\n+              \", callsz %\" PRIdPTR \")\", exit_task_glue, spawnee_fn, callsz);\n+    rust_task *child_task = child_task_handle->referent();\n+    child_task->start(exit_task_glue, spawnee_fn, task->rust_sp, callsz);\n #if defined(__WIN32__)\n     HANDLE thread;\n-    thread = CreateThread(NULL, 0, rust_thread_start, root_task->dom,\n-            0, NULL);\n-    dom->win32_require(\"CreateThread\", thread != NULL);\n+    thread = CreateThread(NULL, 0, rust_thread_start, child_task->dom, 0,\n+                          NULL);\n+    parenet_dom->win32_require(\"CreateThread\", thread != NULL);\n #else\n     pthread_t thread;\n-    pthread_create(&thread, &dom->attr, rust_thread_start,\n-                   (void *) root_task->dom);\n+    pthread_create(&thread, &parenet_dom->attr, rust_thread_start,\n+                   (void *) child_task->dom);\n #endif\n-    return root_task_proxy;\n+    return child_task_proxy;\n }\n \n //"}, {"sha": "ac0c5b046a00388fa75a0f50a4e1e30fe4620e87", "filename": "src/rt/sync/lock_free_queue.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/de611a309006f0976bc9a579eb1087e7a89f79a7/src%2Frt%2Fsync%2Flock_free_queue.h", "raw_url": "https://github.com/rust-lang/rust/raw/de611a309006f0976bc9a579eb1087e7a89f79a7/src%2Frt%2Fsync%2Flock_free_queue.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fsync%2Flock_free_queue.h?ref=de611a309006f0976bc9a579eb1087e7a89f79a7", "patch": "@@ -98,8 +98,6 @@ class lock_free_queue {\n     }\n \n public:\n-    int32_t list_index;\n-\n     lock_free_queue() {\n         // We can only handle 64bit CAS for counted pointers, so this will\n         // not work with 64bit pointers."}, {"sha": "d643a050540a4ad469bd7f55191bc85b7aead2dd", "filename": "src/rt/util/indexed_list.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/de611a309006f0976bc9a579eb1087e7a89f79a7/src%2Frt%2Futil%2Findexed_list.h", "raw_url": "https://github.com/rust-lang/rust/raw/de611a309006f0976bc9a579eb1087e7a89f79a7/src%2Frt%2Futil%2Findexed_list.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Futil%2Findexed_list.h?ref=de611a309006f0976bc9a579eb1087e7a89f79a7", "patch": "@@ -28,10 +28,10 @@ class indexed_list_element : public indexed_list_object {\n  * object inserted in this list must define a \"int32_t list_index\" member.\n  */\n template<typename T> class indexed_list {\n-    memory_region &region;\n+    memory_region *region;\n     array_list<T*> list;\n public:\n-    indexed_list(memory_region &region) : region(region) {}\n+    indexed_list(memory_region *region) : region(region) {}\n     virtual int32_t append(T *value);\n     virtual bool pop(T **value);\n     virtual size_t length() {"}]}