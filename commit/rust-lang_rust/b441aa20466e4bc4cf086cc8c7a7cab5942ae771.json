{"sha": "b441aa20466e4bc4cf086cc8c7a7cab5942ae771", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI0NDFhYTIwNDY2ZTRiYzRjZjA4NmNjOGM3YTdjYWI1OTQyYWU3NzE=", "commit": {"author": {"name": "BooksBaum", "email": "15612932+Booksbaum@users.noreply.github.com", "date": "2021-08-10T11:28:32Z"}, "committer": {"name": "BooksBaum", "email": "15612932+Booksbaum@users.noreply.github.com", "date": "2021-08-17T17:23:06Z"}, "message": "Cleanup according to style-requirements in tests", "tree": {"sha": "5e1e5cc11b1f9d0231be1aa2107af96bdd7b4421", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5e1e5cc11b1f9d0231be1aa2107af96bdd7b4421"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b441aa20466e4bc4cf086cc8c7a7cab5942ae771", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEJTdsK5zmAD3L8AFljIMXU7iI9loFAmEb8HoACgkQjIMXU7iI\n9lpJiRAAhmzEInLmDctU338u5a0CBzf8oIRXE0ulkmQTxRpUTcXx3Y07JjNnlQIl\nV5EYikSU7N4uL5150WBn/NrCXh0isSN17KqUkdlc089wC4GUq8CAPOdcrR6TFVIc\nK4v7VUCwmo5oMkDWMqIaOSeGaSdi2g3x/wG/N2H6XLpYE7f+BSnqbfw3wfOryHBV\nbfTNAIgtsU8F3tKhsUPjRLv/ixosiAj1tBqChC3+ImYCMN6aK3egd6YkL+ANhw6x\nBHKKndaUjzmWaPew8b7P0lV7gK+gLrKDDux70W9te1HINa6Co3uTwOZmNGSKf4A+\nGydqJohbtpchl8UcNag5rMl4FpKCK2NtV2NZlfgvshFc/F1UK2bGyZISGt34Dq8H\ns5uuLyyxcskZmwPs3iFUVQG64r+dIL4JOz8XCnpmklRPNKnYOkMqBZrWBnsP+MPv\nnCNTWnuJsH9GumxJrydy8xL2uK2U1L5nUTzZZFahc7p+O+LlWz7goGBn7Ibx1UdT\n8SzjTPvcDVzx2/0aohu0s0JkYuanTk1TL+kKouMrRRMbkIaImWeqzvPCPrl/f9K3\noB8qVaiZ+FlVKBIs58HpREhbf7lD5CRewYyXga2AGkIHUuOXJApxIqJn2ExGaHU8\nHbEq4ERLY/zNTD2BIVhIjzed0q3q54KOljQUrNFDGsTXAmpp3DY=\n=4q2N\n-----END PGP SIGNATURE-----", "payload": "tree 5e1e5cc11b1f9d0231be1aa2107af96bdd7b4421\nparent 45ef57bd23dd3b97184b167385c81c0f0b34d8cf\nauthor BooksBaum <15612932+Booksbaum@users.noreply.github.com> 1628594912 +0200\ncommitter BooksBaum <15612932+Booksbaum@users.noreply.github.com> 1629220986 +0200\n\nCleanup according to style-requirements in tests\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b441aa20466e4bc4cf086cc8c7a7cab5942ae771", "html_url": "https://github.com/rust-lang/rust/commit/b441aa20466e4bc4cf086cc8c7a7cab5942ae771", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b441aa20466e4bc4cf086cc8c7a7cab5942ae771/comments", "author": {"login": "Booksbaum", "id": 15612932, "node_id": "MDQ6VXNlcjE1NjEyOTMy", "avatar_url": "https://avatars.githubusercontent.com/u/15612932?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Booksbaum", "html_url": "https://github.com/Booksbaum", "followers_url": "https://api.github.com/users/Booksbaum/followers", "following_url": "https://api.github.com/users/Booksbaum/following{/other_user}", "gists_url": "https://api.github.com/users/Booksbaum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Booksbaum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Booksbaum/subscriptions", "organizations_url": "https://api.github.com/users/Booksbaum/orgs", "repos_url": "https://api.github.com/users/Booksbaum/repos", "events_url": "https://api.github.com/users/Booksbaum/events{/privacy}", "received_events_url": "https://api.github.com/users/Booksbaum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Booksbaum", "id": 15612932, "node_id": "MDQ6VXNlcjE1NjEyOTMy", "avatar_url": "https://avatars.githubusercontent.com/u/15612932?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Booksbaum", "html_url": "https://github.com/Booksbaum", "followers_url": "https://api.github.com/users/Booksbaum/followers", "following_url": "https://api.github.com/users/Booksbaum/following{/other_user}", "gists_url": "https://api.github.com/users/Booksbaum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Booksbaum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Booksbaum/subscriptions", "organizations_url": "https://api.github.com/users/Booksbaum/orgs", "repos_url": "https://api.github.com/users/Booksbaum/repos", "events_url": "https://api.github.com/users/Booksbaum/events{/privacy}", "received_events_url": "https://api.github.com/users/Booksbaum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "45ef57bd23dd3b97184b167385c81c0f0b34d8cf", "url": "https://api.github.com/repos/rust-lang/rust/commits/45ef57bd23dd3b97184b167385c81c0f0b34d8cf", "html_url": "https://github.com/rust-lang/rust/commit/45ef57bd23dd3b97184b167385c81c0f0b34d8cf"}], "stats": {"total": 107, "additions": 52, "deletions": 55}, "files": [{"sha": "01a7d462d71bf5639c3fdc7625fc24906bb4d7d4", "filename": "crates/ide_assists/src/handlers/destructure_tuple_binding.rs", "status": "modified", "additions": 52, "deletions": 55, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/b441aa20466e4bc4cf086cc8c7a7cab5942ae771/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fdestructure_tuple_binding.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b441aa20466e4bc4cf086cc8c7a7cab5942ae771/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fdestructure_tuple_binding.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fdestructure_tuple_binding.rs?ref=b441aa20466e4bc4cf086cc8c7a7cab5942ae771", "patch": "@@ -4,7 +4,10 @@ use ide_db::{\n     search::{FileReference, SearchScope, UsageSearchResult},\n };\n use itertools::Itertools;\n-use syntax::{TextRange, ast::{self, AstNode, IdentPat, NameOwner}};\n+use syntax::{\n+    ast::{self, AstNode, IdentPat, NameOwner},\n+    TextRange,\n+};\n \n use crate::assist_context::{AssistBuilder, AssistContext, Assists};\n \n@@ -49,7 +52,11 @@ pub(crate) fn destructure_tuple_binding(acc: &mut Assists, ctx: &AssistContext)\n     destructure_tuple_binding_impl(acc, ctx, false)\n }\n \n-pub(crate) fn destructure_tuple_binding_impl(acc: &mut Assists, ctx: &AssistContext, with_sub_pattern: bool) -> Option<()> {\n+pub(crate) fn destructure_tuple_binding_impl(\n+    acc: &mut Assists,\n+    ctx: &AssistContext,\n+    with_sub_pattern: bool,\n+) -> Option<()> {\n     let ident_pat = ctx.find_node_at_offset::<ast::IdentPat>()?;\n     let data = collect_data(ident_pat, ctx)?;\n \n@@ -121,7 +128,7 @@ fn generate_name(\n     _usages: &Option<UsageSearchResult>,\n     _ctx: &AssistContext,\n ) -> String {\n-    //TODO: detect if name already used\n+    // FIXME: detect if name already used\n     format!(\"_{}\", index)\n }\n \n@@ -133,16 +140,19 @@ struct TupleData {\n     // field_types: Vec<Type>,\n     usages: Option<UsageSearchResult>,\n }\n-fn edit_tuple_assignment(data: &TupleData, builder: &mut AssistBuilder, ctx: &AssistContext, in_sub_pattern: bool) {\n+fn edit_tuple_assignment(\n+    data: &TupleData,\n+    builder: &mut AssistBuilder,\n+    ctx: &AssistContext,\n+    in_sub_pattern: bool,\n+) {\n     let tuple_pat = {\n         let original = &data.ident_pat;\n         let is_ref = original.ref_token().is_some();\n         let is_mut = original.mut_token().is_some();\n-        let fields =\n-            data\n-            .field_names\n-            .iter()\n-            .map(|name| ast::Pat::from(ast::make::ident_pat(is_ref, is_mut, ast::make::name(name))));\n+        let fields = data.field_names.iter().map(|name| {\n+            ast::Pat::from(ast::make::ident_pat(is_ref, is_mut, ast::make::name(name)))\n+        });\n         ast::make::tuple_pat(fields)\n     };\n \n@@ -231,17 +241,17 @@ fn detect_tuple_index(usage: &FileReference, data: &TupleData) -> Option<TupleIn\n     //      PAREN_EXRP*\n     //       FIELD_EXPR\n \n-    let node = \n-        usage.name.syntax()\n+    let node = usage\n+        .name\n+        .syntax()\n         .ancestors()\n         .skip_while(|s| !ast::PathExpr::can_cast(s.kind()))\n         .skip(1) // PATH_EXPR\n-        .find(|s| !ast::ParenExpr::can_cast(s.kind()))?;    // skip parentheses\n+        .find(|s| !ast::ParenExpr::can_cast(s.kind()))?; // skip parentheses\n \n     if let Some(field_expr) = ast::FieldExpr::cast(node) {\n         let idx = field_expr.name_ref()?.as_tuple_field()?;\n         if idx < data.field_names.len() {\n-\n             // special case: in macro call -> range of `field_expr` in applied macro, NOT range in actual file!\n             if field_expr.syntax().ancestors().any(|a| ast::MacroStmts::can_cast(a.kind())) {\n                 cov_mark::hit!(destructure_tuple_macro_call);\n@@ -260,10 +270,7 @@ fn detect_tuple_index(usage: &FileReference, data: &TupleData) -> Option<TupleIn\n                 return None;\n             }\n \n-            Some(TupleIndex {\n-                            index: idx,\n-                            range: field_expr.syntax().text_range(),\n-                        })\n+            Some(TupleIndex { index: idx, range: field_expr.syntax().text_range() })\n         } else {\n             // tuple index out of range\n             None\n@@ -279,7 +286,7 @@ mod tests {\n \n     use crate::tests::{check_assist, check_assist_not_applicable};\n \n-    // Tests for direct tuple destructure: \n+    // Tests for direct tuple destructure:\n     // `let $0t = (1,2);` -> `let (_0, _1) = (1,2);`\n \n     fn assist(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n@@ -459,13 +466,13 @@ fn main() {\n             r#\"\n fn main() {\n     let $0t = (\"3.14\", 0);\n-    let pi: f32 = t.0.parse().unwrap();\n+    let pi: f32 = t.0.parse().unwrap_or(0.0);\n }\n             \"#,\n             r#\"\n fn main() {\n     let ($0_0, _1) = (\"3.14\", 0);\n-    let pi: f32 = _0.parse().unwrap();\n+    let pi: f32 = _0.parse().unwrap_or(0.0);\n }\n             \"#,\n         )\n@@ -849,7 +856,6 @@ fn f(o: Option<(usize, usize)>) {\n         )\n     }\n \n-\n     #[test]\n     fn in_match() {\n         check_assist(\n@@ -1019,7 +1025,7 @@ fn main() {\n             assist,\n             r#\"\n fn main {\n-    let $0t = \n+    let $0t =\n         if 1 > 2 {\n             (1,2)\n         } else {\n@@ -1036,7 +1042,7 @@ fn main {\n             \"#,\n             r#\"\n fn main {\n-    let ($0_0, _1) = \n+    let ($0_0, _1) =\n         if 1 > 2 {\n             (1,2)\n         } else {\n@@ -1062,28 +1068,21 @@ fn main {\n             destructure_tuple_binding_impl(acc, ctx, true)\n         }\n \n-        pub(crate) fn check_in_place_assist(\n-\n-            ra_fixture_before: &str,\n-            ra_fixture_after: &str,\n-        ) {\n+        pub(crate) fn check_in_place_assist(ra_fixture_before: &str, ra_fixture_after: &str) {\n             check_assist_by_label(\n-                assist, \n-                ra_fixture_before, \n-                ra_fixture_after, \n-                \"Destructure tuple in place\"\n+                assist,\n+                ra_fixture_before,\n+                ra_fixture_after,\n+                \"Destructure tuple in place\",\n             );\n         }\n \n-        pub(crate) fn check_sub_pattern_assist(\n-            ra_fixture_before: &str,\n-            ra_fixture_after: &str,\n-        ) {\n+        pub(crate) fn check_sub_pattern_assist(ra_fixture_before: &str, ra_fixture_after: &str) {\n             check_assist_by_label(\n-                assist, \n-                ra_fixture_before, \n-                ra_fixture_after, \n-                \"Destructure tuple in sub-pattern\"\n+                assist,\n+                ra_fixture_before,\n+                ra_fixture_after,\n+                \"Destructure tuple in sub-pattern\",\n             );\n         }\n \n@@ -1097,11 +1096,11 @@ fn main {\n         }\n     }\n \n-    /// Tests for destructure of tuple in sub-pattern: \n+    /// Tests for destructure of tuple in sub-pattern:\n     /// `let $0t = (1,2);` -> `let t @ (_0, _1) = (1,2);`\n     mod sub_pattern {\n-        use super::*;\n         use super::assist::*;\n+        use super::*;\n         use crate::tests::check_assist_by_label;\n \n         #[test]\n@@ -1123,7 +1122,7 @@ fn main() {\n                 \"#,\n             )\n         }\n-    \n+\n         #[test]\n         fn trigger_both_destructure_tuple_assists() {\n             fn assist(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n@@ -1135,23 +1134,23 @@ fn main() {\n }\n             \"#;\n             check_assist_by_label(\n-                assist, \n-                text, \n+                assist,\n+                text,\n                 r#\"\n fn main() {\n     let ($0_0, _1) = (1,2);\n }\n-            \"#, \n+            \"#,\n                 \"Destructure tuple in place\",\n             );\n             check_assist_by_label(\n-                assist, \n-                text, \n+                assist,\n+                text,\n                 r#\"\n fn main() {\n     let t @ ($0_0, _1) = (1,2);\n }\n-            \"#, \n+            \"#,\n                 \"Destructure tuple in sub-pattern\",\n             );\n         }\n@@ -1175,7 +1174,7 @@ fn main() {\n                 \"#,\n             )\n         }\n-    \n+\n         #[test]\n         fn keep_function_call() {\n             cov_mark::check!(destructure_tuple_call_with_subpattern);\n@@ -1194,7 +1193,7 @@ fn main() {\n                 \"#,\n             )\n         }\n-    \n+\n         #[test]\n         fn keep_type() {\n             check_sub_pattern_assist(\n@@ -1293,11 +1292,10 @@ fn main() {\n     }\n \n     /// Tests for tuple usage in macro call:\n-    /// `dbg!(t.0)`\n-    mod in_macro_call {       \n+    /// `println!(\"{}\", t.0)`\n+    mod in_macro_call {\n         use super::assist::*;\n \n-\n         #[test]\n         fn detect_macro_call() {\n             cov_mark::check!(destructure_tuple_macro_call);\n@@ -1539,7 +1537,6 @@ fn main() {\n }\n                 \"#,\n             )\n-\n         }\n     }\n }"}]}