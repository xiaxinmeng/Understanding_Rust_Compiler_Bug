{"sha": "e9067bd5cc5804edf75bb9d9e56956e0670c3ed1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU5MDY3YmQ1Y2M1ODA0ZWRmNzViYjlkOWU1Njk1NmUwNjcwYzNlZDE=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-11-20T21:45:12Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-12-04T14:14:37Z"}, "message": "MIR dump: restructure pretty to be more extensible by other code", "tree": {"sha": "95cdc56f97c96a1bb915525e33cab29beed16a7a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/95cdc56f97c96a1bb915525e33cab29beed16a7a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e9067bd5cc5804edf75bb9d9e56956e0670c3ed1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e9067bd5cc5804edf75bb9d9e56956e0670c3ed1", "html_url": "https://github.com/rust-lang/rust/commit/e9067bd5cc5804edf75bb9d9e56956e0670c3ed1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e9067bd5cc5804edf75bb9d9e56956e0670c3ed1/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "49d2274cfe184f4a8ed490f7be5d523e02c33fa8", "url": "https://api.github.com/repos/rust-lang/rust/commits/49d2274cfe184f4a8ed490f7be5d523e02c33fa8", "html_url": "https://github.com/rust-lang/rust/commit/49d2274cfe184f4a8ed490f7be5d523e02c33fa8"}], "stats": {"total": 379, "additions": 246, "deletions": 133}, "files": [{"sha": "a04cc113e723d749ca28f9e853d518410bbc3945", "filename": "src/librustc_mir/borrow_check/nll/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e9067bd5cc5804edf75bb9d9e56956e0670c3ed1/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9067bd5cc5804edf75bb9d9e56956e0670c3ed1/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs?ref=e9067bd5cc5804edf75bb9d9e56956e0670c3ed1", "patch": "@@ -170,14 +170,15 @@ fn dump_mir_results<'a, 'gcx, 'tcx>(\n                 writeln!(out, \"    | Live variables on entry to {:?}: {}\", bb, s)?;\n             }\n \n-            PassWhere::InCFG(location) => {\n+            PassWhere::BeforeLocation(location) => {\n                 let s = live_variable_set(\n                     &regular_liveness_per_location[&location],\n                     &drop_liveness_per_location[&location],\n                 );\n                 writeln!(out, \"            | Live variables at {:?}: {}\", location, s)?;\n             }\n \n+            PassWhere::AfterLocation(_) |\n             PassWhere::AfterCFG => {}\n         }\n         Ok(())"}, {"sha": "53f9b885ac6c62481a456e05b37bd16611e0edd9", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e9067bd5cc5804edf75bb9d9e56956e0670c3ed1/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9067bd5cc5804edf75bb9d9e56956e0670c3ed1/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=e9067bd5cc5804edf75bb9d9e56956e0670c3ed1", "patch": "@@ -18,12 +18,15 @@ Rust MIR: a lowered representation of Rust. Also: an experiment!\n \n #![feature(box_patterns)]\n #![feature(box_syntax)]\n+#![feature(catch_expr)]\n #![feature(conservative_impl_trait)]\n #![feature(const_fn)]\n #![feature(core_intrinsics)]\n #![feature(decl_macro)]\n #![feature(i128_type)]\n+#![feature(inclusive_range_syntax)]\n #![feature(match_default_bindings)]\n+#![feature(range_contains)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(placement_in_syntax)]\n #![feature(collection_placement)]"}, {"sha": "eebe5a86018ea6ebb2a8eab45e6441ed48134d8a", "filename": "src/librustc_mir/util/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9067bd5cc5804edf75bb9d9e56956e0670c3ed1/src%2Flibrustc_mir%2Futil%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9067bd5cc5804edf75bb9d9e56956e0670c3ed1/src%2Flibrustc_mir%2Futil%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fmod.rs?ref=e9067bd5cc5804edf75bb9d9e56956e0670c3ed1", "patch": "@@ -15,7 +15,7 @@ pub mod patch;\n \n mod alignment;\n mod graphviz;\n-mod pretty;\n+pub(crate) mod pretty;\n pub mod liveness;\n \n pub use self::alignment::is_disaligned;"}, {"sha": "8a3db0eb25b99b0d921ff4b907b6add7f3cb6b17", "filename": "src/librustc_mir/util/pretty.rs", "status": "modified", "additions": 240, "deletions": 131, "changes": 371, "blob_url": "https://github.com/rust-lang/rust/blob/e9067bd5cc5804edf75bb9d9e56956e0670c3ed1/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9067bd5cc5804edf75bb9d9e56956e0670c3ed1/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fpretty.rs?ref=e9067bd5cc5804edf75bb9d9e56956e0670c3ed1", "patch": "@@ -14,17 +14,17 @@ use rustc::mir::*;\n use rustc::ty::TyCtxt;\n use rustc::ty::item_path;\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_data_structures::indexed_vec::{Idx};\n+use rustc_data_structures::indexed_vec::Idx;\n use std::fmt::Display;\n use std::fs;\n use std::io::{self, Write};\n-use std::path::{PathBuf, Path};\n+use std::path::{Path, PathBuf};\n use super::graphviz::write_mir_fn_graphviz;\n use transform::MirSource;\n \n const INDENT: &'static str = \"    \";\n /// Alignment for lining up comments following MIR statements\n-const ALIGN: usize = 40;\n+pub(crate) const ALIGN: usize = 40;\n \n /// An indication of where we are in the control flow graph. Used for printing\n /// extra information in `dump_mir`\n@@ -38,8 +38,11 @@ pub enum PassWhere {\n     /// We are about to start dumping the given basic block.\n     BeforeBlock(BasicBlock),\n \n-    /// We are just about to dumpt the given statement or terminator.\n-    InCFG(Location),\n+    /// We are just about to dump the given statement or terminator.\n+    BeforeLocation(Location),\n+\n+    /// We just dumped the given statement or terminator.\n+    AfterLocation(Location),\n }\n \n /// If the session is properly configured, dumps a human-readable\n@@ -56,64 +59,124 @@ pub enum PassWhere {\n /// - `substring1&substring2,...` -- `&`-separated list of substrings\n ///   that can appear in the pass-name or the `item_path_str` for the given\n ///   node-id. If any one of the substrings match, the data is dumped out.\n-pub fn dump_mir<'a, 'gcx, 'tcx, F>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                   pass_num: Option<&Display>,\n-                                   pass_name: &str,\n-                                   disambiguator: &Display,\n-                                   source: MirSource,\n-                                   mir: &Mir<'tcx>,\n-                                   extra_data: F)\n-where\n-    F: FnMut(PassWhere, &mut Write) -> io::Result<()>\n+pub fn dump_mir<'a, 'gcx, 'tcx, F>(\n+    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    pass_num: Option<&Display>,\n+    pass_name: &str,\n+    disambiguator: &Display,\n+    source: MirSource,\n+    mir: &Mir<'tcx>,\n+    extra_data: F,\n+) where\n+    F: FnMut(PassWhere, &mut Write) -> io::Result<()>,\n {\n     if !dump_enabled(tcx, pass_name, source) {\n         return;\n     }\n \n-    let node_path = item_path::with_forced_impl_filename_line(|| { // see notes on #41697 below\n+    let node_path = item_path::with_forced_impl_filename_line(|| {\n+        // see notes on #41697 below\n         tcx.item_path_str(source.def_id)\n     });\n-    dump_matched_mir_node(tcx, pass_num, pass_name, &node_path,\n-                          disambiguator, source, mir, extra_data);\n+    dump_matched_mir_node(\n+        tcx,\n+        pass_num,\n+        pass_name,\n+        &node_path,\n+        disambiguator,\n+        source,\n+        mir,\n+        extra_data,\n+    );\n }\n \n-pub fn dump_enabled<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                    pass_name: &str,\n-                                    source: MirSource)\n-                                    -> bool {\n+pub fn dump_enabled<'a, 'gcx, 'tcx>(\n+    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    pass_name: &str,\n+    source: MirSource,\n+) -> bool {\n     let filters = match tcx.sess.opts.debugging_opts.dump_mir {\n         None => return false,\n         Some(ref filters) => filters,\n     };\n-    let node_path = item_path::with_forced_impl_filename_line(|| { // see notes on #41697 below\n+    let node_path = item_path::with_forced_impl_filename_line(|| {\n+        // see notes on #41697 below\n         tcx.item_path_str(source.def_id)\n     });\n-    filters.split(\"&\")\n-           .any(|filter| {\n-               filter == \"all\" ||\n-                   pass_name.contains(filter) ||\n-                   node_path.contains(filter)\n-           })\n+    filters.split(\"&\").any(|filter| {\n+        filter == \"all\" || pass_name.contains(filter) || node_path.contains(filter)\n+    })\n }\n \n // #41697 -- we use `with_forced_impl_filename_line()` because\n // `item_path_str()` would otherwise trigger `type_of`, and this can\n // run while we are already attempting to evaluate `type_of`.\n \n-fn dump_matched_mir_node<'a, 'gcx, 'tcx, F>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                            pass_num: Option<&Display>,\n-                                            pass_name: &str,\n-                                            node_path: &str,\n-                                            disambiguator: &Display,\n-                                            source: MirSource,\n-                                            mir: &Mir<'tcx>,\n-                                            mut extra_data: F)\n-where\n-    F: FnMut(PassWhere, &mut Write) -> io::Result<()>\n+fn dump_matched_mir_node<'a, 'gcx, 'tcx, F>(\n+    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    pass_num: Option<&Display>,\n+    pass_name: &str,\n+    node_path: &str,\n+    disambiguator: &Display,\n+    source: MirSource,\n+    mir: &Mir<'tcx>,\n+    mut extra_data: F,\n+) where\n+    F: FnMut(PassWhere, &mut Write) -> io::Result<()>,\n {\n+    let _: io::Result<()> = do catch {\n+        let mut file = create_dump_file(\n+            tcx,\n+            \"mir\",\n+            pass_num,\n+            pass_name,\n+            disambiguator,\n+            source,\n+        )?;\n+        writeln!(file, \"// MIR for `{}`\", node_path)?;\n+        writeln!(file, \"// source = {:?}\", source)?;\n+        writeln!(file, \"// pass_name = {}\", pass_name)?;\n+        writeln!(file, \"// disambiguator = {}\", disambiguator)?;\n+        if let Some(ref layout) = mir.generator_layout {\n+            writeln!(file, \"// generator_layout = {:?}\", layout)?;\n+        }\n+        writeln!(file, \"\")?;\n+        extra_data(PassWhere::BeforeCFG, &mut file)?;\n+        write_mir_fn(tcx, source, mir, &mut extra_data, &mut file)?;\n+        extra_data(PassWhere::AfterCFG, &mut file)?;\n+        Ok(())\n+    };\n+\n+    if tcx.sess.opts.debugging_opts.dump_mir_graphviz {\n+    let _: io::Result<()> = do catch {\n+            let mut file = create_dump_file(\n+                tcx,\n+                \"dot\",\n+                pass_num,\n+                pass_name,\n+                disambiguator,\n+                source,\n+            )?;\n+            write_mir_fn_graphviz(tcx, source.def_id, mir, &mut file)?;\n+            Ok(())\n+        };\n+    }\n+}\n+\n+/// Returns the path to the filename where we should dump a given MIR.\n+/// Also used by other bits of code (e.g., NLL inference) that dump\n+/// graphviz data or other things.\n+fn dump_path(\n+    tcx: TyCtxt<'_, '_, '_>,\n+    extension: &str,\n+    pass_num: Option<&Display>,\n+    pass_name: &str,\n+    disambiguator: &Display,\n+    source: MirSource,\n+) -> PathBuf {\n     let promotion_id = match source.promoted {\n         Some(id) => format!(\"-{:?}\", id),\n-        None => String::new()\n+        None => String::new(),\n     };\n \n     let pass_num = if tcx.sess.opts.debugging_opts.dump_mir_exclude_pass_number {\n@@ -126,48 +189,64 @@ where\n     };\n \n     let mut file_path = PathBuf::new();\n+\n     if let Some(ref file_dir) = tcx.sess.opts.debugging_opts.dump_mir_dir {\n         let p = Path::new(file_dir);\n         file_path.push(p);\n     };\n \n-    let _ = fs::create_dir_all(&file_path);\n-    let item_name = tcx.hir.def_path(source.def_id).to_filename_friendly_no_crate();\n-    let file_name = format!(\"rustc.{}{}{}.{}.{}.mir\",\n-                            item_name, promotion_id, pass_num, pass_name, disambiguator);\n+    let item_name = tcx.hir\n+        .def_path(source.def_id)\n+        .to_filename_friendly_no_crate();\n+\n+    let file_name = format!(\n+        \"rustc.{}{}{}.{}.{}.{}\",\n+        item_name,\n+        promotion_id,\n+        pass_num,\n+        pass_name,\n+        disambiguator,\n+        extension,\n+    );\n+\n     file_path.push(&file_name);\n-    let _ = fs::File::create(&file_path).and_then(|mut file| {\n-        writeln!(file, \"// MIR for `{}`\", node_path)?;\n-        writeln!(file, \"// source = {:?}\", source)?;\n-        writeln!(file, \"// pass_name = {}\", pass_name)?;\n-        writeln!(file, \"// disambiguator = {}\", disambiguator)?;\n-        if let Some(ref layout) = mir.generator_layout {\n-            writeln!(file, \"// generator_layout = {:?}\", layout)?;\n-        }\n-        writeln!(file, \"\")?;\n-        extra_data(PassWhere::BeforeCFG, &mut file)?;\n-        write_mir_fn(tcx, source, mir, &mut extra_data, &mut file)?;\n-        extra_data(PassWhere::AfterCFG, &mut file)?;\n-        Ok(())\n-    });\n \n-    if tcx.sess.opts.debugging_opts.dump_mir_graphviz {\n-        file_path.set_extension(\"dot\");\n-        let _ = fs::File::create(&file_path).and_then(|mut file| {\n-            write_mir_fn_graphviz(tcx, source.def_id, mir, &mut file)?;\n-            Ok(())\n-        });\n+    file_path\n+}\n+\n+/// Attempts to open a file where we should dump a given MIR or other\n+/// bit of MIR-related data. Used by `mir-dump`, but also by other\n+/// bits of code (e.g., NLL inference) that dump graphviz data or\n+/// other things, and hence takes the extension as an argument.\n+pub(crate) fn create_dump_file(\n+    tcx: TyCtxt<'_, '_, '_>,\n+    extension: &str,\n+    pass_num: Option<&Display>,\n+    pass_name: &str,\n+    disambiguator: &Display,\n+    source: MirSource,\n+) -> io::Result<fs::File> {\n+    let file_path = dump_path(tcx, extension, pass_num, pass_name, disambiguator, source);\n+    if let Some(parent) = file_path.parent() {\n+        fs::create_dir_all(parent)?;\n     }\n+    fs::File::create(&file_path)\n }\n \n /// Write out a human-readable textual representation for the given MIR.\n-pub fn write_mir_pretty<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                        single: Option<DefId>,\n-                                        w: &mut Write)\n-                                        -> io::Result<()>\n-{\n-    writeln!(w, \"// WARNING: This output format is intended for human consumers only\")?;\n-    writeln!(w, \"// and is subject to change without notice. Knock yourself out.\")?;\n+pub fn write_mir_pretty<'a, 'gcx, 'tcx>(\n+    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    single: Option<DefId>,\n+    w: &mut Write,\n+) -> io::Result<()> {\n+    writeln!(\n+        w,\n+        \"// WARNING: This output format is intended for human consumers only\"\n+    )?;\n+    writeln!(\n+        w,\n+        \"// and is subject to change without notice. Knock yourself out.\"\n+    )?;\n \n     let mut first = true;\n     for def_id in dump_mir_def_ids(tcx, single) {\n@@ -186,22 +265,23 @@ pub fn write_mir_pretty<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n             writeln!(w, \"\")?;\n             let src = MirSource {\n                 def_id,\n-                promoted: Some(i)\n+                promoted: Some(i),\n             };\n             write_mir_fn(tcx, src, mir, &mut |_, _| Ok(()), w)?;\n         }\n     }\n     Ok(())\n }\n \n-pub fn write_mir_fn<'a, 'gcx, 'tcx, F>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                       src: MirSource,\n-                                       mir: &Mir<'tcx>,\n-                                       extra_data: &mut F,\n-                                       w: &mut Write)\n-                                       -> io::Result<()>\n+pub fn write_mir_fn<'a, 'gcx, 'tcx, F>(\n+    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    src: MirSource,\n+    mir: &Mir<'tcx>,\n+    extra_data: &mut F,\n+    w: &mut Write,\n+) -> io::Result<()>\n where\n-    F: FnMut(PassWhere, &mut Write) -> io::Result<()>\n+    F: FnMut(PassWhere, &mut Write) -> io::Result<()>,\n {\n     write_mir_intro(tcx, src, mir, w)?;\n     for block in mir.basic_blocks().indices() {\n@@ -217,14 +297,15 @@ where\n }\n \n /// Write out a human-readable textual representation for the given basic block.\n-pub fn write_basic_block<F>(tcx: TyCtxt,\n-                            block: BasicBlock,\n-                            mir: &Mir,\n-                            extra_data: &mut F,\n-                            w: &mut Write)\n-                            -> io::Result<()>\n+pub fn write_basic_block<F>(\n+    tcx: TyCtxt,\n+    block: BasicBlock,\n+    mir: &Mir,\n+    extra_data: &mut F,\n+    w: &mut Write,\n+) -> io::Result<()>\n where\n-    F: FnMut(PassWhere, &mut Write) -> io::Result<()>\n+    F: FnMut(PassWhere, &mut Write) -> io::Result<()>,\n {\n     let data = &mir[block];\n \n@@ -234,43 +315,61 @@ where\n     writeln!(w, \"{0:1$}{2}\", lbl, ALIGN, cleanup_text)?;\n \n     // List of statements in the middle.\n-    let mut current_location = Location { block: block, statement_index: 0 };\n+    let mut current_location = Location {\n+        block: block,\n+        statement_index: 0,\n+    };\n     for statement in &data.statements {\n-        extra_data(PassWhere::InCFG(current_location), w)?;\n+        extra_data(PassWhere::BeforeLocation(current_location), w)?;\n         let indented_mir = format!(\"{0}{0}{1:?};\", INDENT, statement);\n-        writeln!(w, \"{0:1$} // {2}\",\n-                 indented_mir,\n-                 ALIGN,\n-                 comment(tcx, statement.source_info))?;\n+        writeln!(\n+            w,\n+            \"{:A$} // {:?}: {}\",\n+            indented_mir,\n+            current_location,\n+            comment(tcx, statement.source_info),\n+            A = ALIGN,\n+        )?;\n+        extra_data(PassWhere::AfterLocation(current_location), w)?;\n \n         current_location.statement_index += 1;\n     }\n \n     // Terminator at the bottom.\n-    extra_data(PassWhere::InCFG(current_location), w)?;\n+    extra_data(PassWhere::BeforeLocation(current_location), w)?;\n     let indented_terminator = format!(\"{0}{0}{1:?};\", INDENT, data.terminator().kind);\n-    writeln!(w, \"{0:1$} // {2}\",\n-             indented_terminator,\n-             ALIGN,\n-             comment(tcx, data.terminator().source_info))?;\n+    writeln!(\n+        w,\n+        \"{:A$} // {:?}: {}\",\n+        indented_terminator,\n+        current_location,\n+        comment(tcx, data.terminator().source_info),\n+        A = ALIGN,\n+    )?;\n+    extra_data(PassWhere::AfterLocation(current_location), w)?;\n \n     writeln!(w, \"{}}}\", INDENT)\n }\n \n fn comment(tcx: TyCtxt, SourceInfo { span, scope }: SourceInfo) -> String {\n-    format!(\"scope {} at {}\", scope.index(), tcx.sess.codemap().span_to_string(span))\n+    format!(\n+        \"scope {} at {}\",\n+        scope.index(),\n+        tcx.sess.codemap().span_to_string(span)\n+    )\n }\n \n /// Prints user-defined variables in a scope tree.\n ///\n /// Returns the total number of variables printed.\n-fn write_scope_tree(tcx: TyCtxt,\n-                    mir: &Mir,\n-                    scope_tree: &FxHashMap<VisibilityScope, Vec<VisibilityScope>>,\n-                    w: &mut Write,\n-                    parent: VisibilityScope,\n-                    depth: usize)\n-                    -> io::Result<()> {\n+fn write_scope_tree(\n+    tcx: TyCtxt,\n+    mir: &Mir,\n+    scope_tree: &FxHashMap<VisibilityScope, Vec<VisibilityScope>>,\n+    w: &mut Write,\n+    parent: VisibilityScope,\n+    depth: usize,\n+) -> io::Result<()> {\n     let indent = depth * INDENT.len();\n \n     let children = match scope_tree.get(&parent) {\n@@ -300,17 +399,22 @@ fn write_scope_tree(tcx: TyCtxt,\n             };\n \n             let indent = indent + INDENT.len();\n-            let indented_var = format!(\"{0:1$}let {2}{3:?}: {4};\",\n-                                       INDENT,\n-                                       indent,\n-                                       mut_str,\n-                                       local,\n-                                       var.ty);\n-            writeln!(w, \"{0:1$} // \\\"{2}\\\" in {3}\",\n-                     indented_var,\n-                     ALIGN,\n-                     name,\n-                     comment(tcx, source_info))?;\n+            let indented_var = format!(\n+                \"{0:1$}let {2}{3:?}: {4:?};\",\n+                INDENT,\n+                indent,\n+                mut_str,\n+                local,\n+                var.ty\n+            );\n+            writeln!(\n+                w,\n+                \"{0:1$} // \\\"{2}\\\" in {3}\",\n+                indented_var,\n+                ALIGN,\n+                name,\n+                comment(tcx, source_info)\n+            )?;\n         }\n \n         write_scope_tree(tcx, mir, scope_tree, w, child, depth + 1)?;\n@@ -323,21 +427,23 @@ fn write_scope_tree(tcx: TyCtxt,\n \n /// Write out a human-readable textual representation of the MIR's `fn` type and the types of its\n /// local variables (both user-defined bindings and compiler temporaries).\n-pub fn write_mir_intro<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                       src: MirSource,\n-                                       mir: &Mir,\n-                                       w: &mut Write)\n-                                       -> io::Result<()> {\n+pub fn write_mir_intro<'a, 'gcx, 'tcx>(\n+    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    src: MirSource,\n+    mir: &Mir,\n+    w: &mut Write,\n+) -> io::Result<()> {\n     write_mir_sig(tcx, src, mir, w)?;\n     writeln!(w, \" {{\")?;\n \n     // construct a scope tree and write it out\n     let mut scope_tree: FxHashMap<VisibilityScope, Vec<VisibilityScope>> = FxHashMap();\n     for (index, scope_data) in mir.visibility_scopes.iter().enumerate() {\n         if let Some(parent) = scope_data.parent_scope {\n-            scope_tree.entry(parent)\n-                      .or_insert(vec![])\n-                      .push(VisibilityScope::new(index));\n+            scope_tree\n+                .entry(parent)\n+                .or_insert(vec![])\n+                .push(VisibilityScope::new(index));\n         } else {\n             // Only the argument scope has no parent, because it's the root.\n             assert_eq!(index, ARGUMENT_VISIBILITY_SCOPE.index());\n@@ -363,9 +469,7 @@ pub fn write_mir_intro<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     Ok(())\n }\n \n-fn write_mir_sig(tcx: TyCtxt, src: MirSource, mir: &Mir, w: &mut Write)\n-                 -> io::Result<()>\n-{\n+fn write_mir_sig(tcx: TyCtxt, src: MirSource, mir: &Mir, w: &mut Write) -> io::Result<()> {\n     let id = tcx.hir.as_local_node_id(src.def_id).unwrap();\n     let body_owner_kind = tcx.hir.body_owner_kind(id);\n     match (body_owner_kind, src.promoted) {\n@@ -376,7 +480,8 @@ fn write_mir_sig(tcx: TyCtxt, src: MirSource, mir: &Mir, w: &mut Write)\n         (hir::BodyOwnerKind::Static(hir::MutMutable), _) => write!(w, \"static mut\")?,\n     }\n \n-    item_path::with_forced_impl_filename_line(|| { // see notes on #41697 elsewhere\n+    item_path::with_forced_impl_filename_line(|| {\n+        // see notes on #41697 elsewhere\n         write!(w, \" {}\", tcx.item_path_str(src.def_id))\n     })?;\n \n@@ -394,9 +499,7 @@ fn write_mir_sig(tcx: TyCtxt, src: MirSource, mir: &Mir, w: &mut Write)\n \n             write!(w, \") -> {}\", mir.return_ty())\n         }\n-        (hir::BodyOwnerKind::Const, _) |\n-        (hir::BodyOwnerKind::Static(_), _) |\n-        (_, Some(_)) => {\n+        (hir::BodyOwnerKind::Const, _) | (hir::BodyOwnerKind::Static(_), _) | (_, Some(_)) => {\n             assert_eq!(mir.arg_count, 0);\n             write!(w, \": {} =\", mir.return_ty())\n         }\n@@ -406,7 +509,13 @@ fn write_mir_sig(tcx: TyCtxt, src: MirSource, mir: &Mir, w: &mut Write)\n fn write_temp_decls(mir: &Mir, w: &mut Write) -> io::Result<()> {\n     // Compiler-introduced temporary types.\n     for temp in mir.temps_iter() {\n-        writeln!(w, \"{}let mut {:?}: {};\", INDENT, temp, mir.local_decls[temp].ty)?;\n+        writeln!(\n+            w,\n+            \"{}let mut {:?}: {};\",\n+            INDENT,\n+            temp,\n+            mir.local_decls[temp].ty\n+        )?;\n     }\n \n     Ok(())"}]}