{"sha": "102eaa5c107d48b6787279be8d9de6782a565cb8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEwMmVhYTVjMTA3ZDQ4YjY3ODcyNzliZThkOWRlNjc4MmE1NjVjYjg=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2017-11-07T14:14:32Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2017-11-07T14:14:32Z"}, "message": "incr.comp.: Always require Session when decoding Spans (as to avoid silently wrong results).", "tree": {"sha": "73acf4bfec9eb35159ab36bbe033c47ff21278da", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/73acf4bfec9eb35159ab36bbe033c47ff21278da"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/102eaa5c107d48b6787279be8d9de6782a565cb8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/102eaa5c107d48b6787279be8d9de6782a565cb8", "html_url": "https://github.com/rust-lang/rust/commit/102eaa5c107d48b6787279be8d9de6782a565cb8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/102eaa5c107d48b6787279be8d9de6782a565cb8/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a1749512721a9bdb103d6fc7d645aca930ac13ac", "url": "https://api.github.com/repos/rust-lang/rust/commits/a1749512721a9bdb103d6fc7d645aca930ac13ac", "html_url": "https://github.com/rust-lang/rust/commit/a1749512721a9bdb103d6fc7d645aca930ac13ac"}], "stats": {"total": 128, "additions": 71, "deletions": 57}, "files": [{"sha": "ba89961adc68739c561f664da02a6eec0eaed4a0", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/102eaa5c107d48b6787279be8d9de6782a565cb8/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/102eaa5c107d48b6787279be8d9de6782a565cb8/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=102eaa5c107d48b6787279be8d9de6782a565cb8", "patch": "@@ -838,7 +838,10 @@ impl<'a> LoweringContext<'a> {\n                         return n;\n                     }\n                     assert!(!def_id.is_local());\n-                    let n = self.cstore.item_generics_cloned_untracked(def_id).regions.len();\n+                    let n = self.cstore\n+                                .item_generics_cloned_untracked(def_id, self.sess)\n+                                .regions\n+                                .len();\n                     self.type_def_lifetime_params.insert(def_id, n);\n                     n\n                 });"}, {"sha": "628538b41c5d8ab9812e401ea2badf3475882717", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/102eaa5c107d48b6787279be8d9de6782a565cb8/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/102eaa5c107d48b6787279be8d9de6782a565cb8/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=102eaa5c107d48b6787279be8d9de6782a565cb8", "patch": "@@ -273,7 +273,7 @@ pub trait CrateStore {\n     fn item_children_untracked(&self, did: DefId, sess: &Session) -> Vec<def::Export>;\n     fn load_macro_untracked(&self, did: DefId, sess: &Session) -> LoadedMacro;\n     fn extern_mod_stmt_cnum_untracked(&self, emod_id: ast::NodeId) -> Option<CrateNum>;\n-    fn item_generics_cloned_untracked(&self, def: DefId) -> ty::Generics;\n+    fn item_generics_cloned_untracked(&self, def: DefId, sess: &Session) -> ty::Generics;\n     fn associated_item_cloned_untracked(&self, def: DefId) -> ty::AssociatedItem;\n     fn postorder_cnums_untracked(&self) -> Vec<CrateNum>;\n \n@@ -327,7 +327,7 @@ impl CrateStore for DummyCrateStore {\n         { bug!(\"crate_data_as_rc_any\") }\n     // item info\n     fn visibility_untracked(&self, def: DefId) -> ty::Visibility { bug!(\"visibility\") }\n-    fn item_generics_cloned_untracked(&self, def: DefId) -> ty::Generics\n+    fn item_generics_cloned_untracked(&self, def: DefId, sess: &Session) -> ty::Generics\n         { bug!(\"item_generics_cloned\") }\n \n     // trait/impl-item info"}, {"sha": "ffd06ee8a2e3abad7da087c578e789bbe5423790", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/102eaa5c107d48b6787279be8d9de6782a565cb8/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/102eaa5c107d48b6787279be8d9de6782a565cb8/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=102eaa5c107d48b6787279be8d9de6782a565cb8", "patch": "@@ -1001,8 +1001,12 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 &map.object_lifetime_defaults[&id]\n             } else {\n                 let cstore = self.cstore;\n+                let sess = self.sess;\n                 self.xcrate_object_lifetime_defaults.entry(def_id).or_insert_with(|| {\n-                    cstore.item_generics_cloned_untracked(def_id).types.into_iter().map(|def| {\n+                    cstore.item_generics_cloned_untracked(def_id, sess)\n+                          .types\n+                          .into_iter()\n+                          .map(|def| {\n                         def.object_lifetime_default\n                     }).collect()\n                 })"}, {"sha": "d0eddee71ada9721116c2baa6f0263c19a40d079", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/102eaa5c107d48b6787279be8d9de6782a565cb8/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/102eaa5c107d48b6787279be8d9de6782a565cb8/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=102eaa5c107d48b6787279be8d9de6782a565cb8", "patch": "@@ -685,14 +685,15 @@ impl<'a> CrateLoader<'a> {\n         let mut needs_panic_runtime = attr::contains_name(&krate.attrs,\n                                                           \"needs_panic_runtime\");\n \n+        let sess = self.sess;\n         self.cstore.iter_crate_data(|cnum, data| {\n             needs_panic_runtime = needs_panic_runtime ||\n-                                  data.needs_panic_runtime();\n-            if data.is_panic_runtime() {\n+                                  data.needs_panic_runtime(sess);\n+            if data.is_panic_runtime(sess) {\n                 // Inject a dependency from all #![needs_panic_runtime] to this\n                 // #![panic_runtime] crate.\n                 self.inject_dependency_if(cnum, \"a panic runtime\",\n-                                          &|data| data.needs_panic_runtime());\n+                                          &|data| data.needs_panic_runtime(sess));\n                 runtime_found = runtime_found || data.dep_kind.get() == DepKind::Explicit;\n             }\n         });\n@@ -728,7 +729,7 @@ impl<'a> CrateLoader<'a> {\n \n         // Sanity check the loaded crate to ensure it is indeed a panic runtime\n         // and the panic strategy is indeed what we thought it was.\n-        if !data.is_panic_runtime() {\n+        if !data.is_panic_runtime(self.sess) {\n             self.sess.err(&format!(\"the crate `{}` is not a panic runtime\",\n                                    name));\n         }\n@@ -740,7 +741,7 @@ impl<'a> CrateLoader<'a> {\n \n         self.sess.injected_panic_runtime.set(Some(cnum));\n         self.inject_dependency_if(cnum, \"a panic runtime\",\n-                                  &|data| data.needs_panic_runtime());\n+                                  &|data| data.needs_panic_runtime(self.sess));\n     }\n \n     fn inject_sanitizer_runtime(&mut self) {\n@@ -835,7 +836,7 @@ impl<'a> CrateLoader<'a> {\n                                        PathKind::Crate, dep_kind);\n \n                 // Sanity check the loaded crate to ensure it is indeed a sanitizer runtime\n-                if !data.is_sanitizer_runtime() {\n+                if !data.is_sanitizer_runtime(self.sess) {\n                     self.sess.err(&format!(\"the crate `{}` is not a sanitizer runtime\",\n                                            name));\n                 }\n@@ -856,7 +857,7 @@ impl<'a> CrateLoader<'a> {\n                                    PathKind::Crate, dep_kind);\n \n             // Sanity check the loaded crate to ensure it is indeed a profiler runtime\n-            if !data.is_profiler_runtime() {\n+            if !data.is_profiler_runtime(self.sess) {\n                 self.sess.err(&format!(\"the crate `profiler_builtins` is not \\\n                                         a profiler runtime\"));\n             }\n@@ -875,7 +876,7 @@ impl<'a> CrateLoader<'a> {\n         let mut needs_allocator = attr::contains_name(&krate.attrs,\n                                                       \"needs_allocator\");\n         self.cstore.iter_crate_data(|_, data| {\n-            needs_allocator = needs_allocator || data.needs_allocator();\n+            needs_allocator = needs_allocator || data.needs_allocator(self.sess);\n         });\n         if !needs_allocator {\n             return\n@@ -997,7 +998,7 @@ impl<'a> CrateLoader<'a> {\n             Some(data) => {\n                 // We have an allocator. We detect separately what kind it is, to allow for some\n                 // flexibility in misconfiguration.\n-                let attrs = data.get_item_attrs(CRATE_DEF_INDEX);\n+                let attrs = data.get_item_attrs(CRATE_DEF_INDEX, self.sess);\n                 let kind_interned = attr::first_attr_value_str_by_name(&attrs, \"rustc_alloc_kind\")\n                     .map(Symbol::as_str);\n                 let kind_str = kind_interned"}, {"sha": "a86b55e269d418720b77f572feb29993b885327e", "filename": "src/librustc_metadata/cstore.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/102eaa5c107d48b6787279be8d9de6782a565cb8/src%2Flibrustc_metadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/102eaa5c107d48b6787279be8d9de6782a565cb8/src%2Flibrustc_metadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore.rs?ref=102eaa5c107d48b6787279be8d9de6782a565cb8", "patch": "@@ -17,7 +17,7 @@ use rustc::hir::def_id::{CRATE_DEF_INDEX, CrateNum, DefIndex};\n use rustc::hir::map::definitions::DefPathTable;\n use rustc::hir::svh::Svh;\n use rustc::middle::cstore::{DepKind, ExternCrate, MetadataLoader};\n-use rustc::session::CrateDisambiguator;\n+use rustc::session::{Session, CrateDisambiguator};\n use rustc_back::PanicStrategy;\n use rustc_data_structures::indexed_vec::IndexVec;\n use rustc::util::nodemap::{FxHashMap, FxHashSet, NodeMap};\n@@ -176,8 +176,8 @@ impl CrateMetadata {\n         self.root.disambiguator\n     }\n \n-    pub fn needs_allocator(&self) -> bool {\n-        let attrs = self.get_item_attrs(CRATE_DEF_INDEX);\n+    pub fn needs_allocator(&self, sess: &Session) -> bool {\n+        let attrs = self.get_item_attrs(CRATE_DEF_INDEX, sess);\n         attr::contains_name(&attrs, \"needs_allocator\")\n     }\n \n@@ -189,43 +189,43 @@ impl CrateMetadata {\n         self.root.has_default_lib_allocator.clone()\n     }\n \n-    pub fn is_panic_runtime(&self) -> bool {\n-        let attrs = self.get_item_attrs(CRATE_DEF_INDEX);\n+    pub fn is_panic_runtime(&self, sess: &Session) -> bool {\n+        let attrs = self.get_item_attrs(CRATE_DEF_INDEX, sess);\n         attr::contains_name(&attrs, \"panic_runtime\")\n     }\n \n-    pub fn needs_panic_runtime(&self) -> bool {\n-        let attrs = self.get_item_attrs(CRATE_DEF_INDEX);\n+    pub fn needs_panic_runtime(&self, sess: &Session) -> bool {\n+        let attrs = self.get_item_attrs(CRATE_DEF_INDEX, sess);\n         attr::contains_name(&attrs, \"needs_panic_runtime\")\n     }\n \n-    pub fn is_compiler_builtins(&self) -> bool {\n-        let attrs = self.get_item_attrs(CRATE_DEF_INDEX);\n+    pub fn is_compiler_builtins(&self, sess: &Session) -> bool {\n+        let attrs = self.get_item_attrs(CRATE_DEF_INDEX, sess);\n         attr::contains_name(&attrs, \"compiler_builtins\")\n     }\n \n-    pub fn is_sanitizer_runtime(&self) -> bool {\n-        let attrs = self.get_item_attrs(CRATE_DEF_INDEX);\n+    pub fn is_sanitizer_runtime(&self, sess: &Session) -> bool {\n+        let attrs = self.get_item_attrs(CRATE_DEF_INDEX, sess);\n         attr::contains_name(&attrs, \"sanitizer_runtime\")\n     }\n \n-    pub fn is_profiler_runtime(&self) -> bool {\n-        let attrs = self.get_item_attrs(CRATE_DEF_INDEX);\n+    pub fn is_profiler_runtime(&self, sess: &Session) -> bool {\n+        let attrs = self.get_item_attrs(CRATE_DEF_INDEX, sess);\n         attr::contains_name(&attrs, \"profiler_runtime\")\n     }\n \n-    pub fn is_no_builtins(&self) -> bool {\n-        let attrs = self.get_item_attrs(CRATE_DEF_INDEX);\n+    pub fn is_no_builtins(&self, sess: &Session) -> bool {\n+        let attrs = self.get_item_attrs(CRATE_DEF_INDEX, sess);\n         attr::contains_name(&attrs, \"no_builtins\")\n     }\n \n-     pub fn has_copy_closures(&self) -> bool {\n-        let attrs = self.get_item_attrs(CRATE_DEF_INDEX);\n+     pub fn has_copy_closures(&self, sess: &Session) -> bool {\n+        let attrs = self.get_item_attrs(CRATE_DEF_INDEX, sess);\n         attr::contains_feature_attr(&attrs, \"copy_closures\")\n     }\n \n-    pub fn has_clone_closures(&self) -> bool {\n-        let attrs = self.get_item_attrs(CRATE_DEF_INDEX);\n+    pub fn has_clone_closures(&self, sess: &Session) -> bool {\n+        let attrs = self.get_item_attrs(CRATE_DEF_INDEX, sess);\n         attr::contains_feature_attr(&attrs, \"clone_closures\")\n     }\n "}, {"sha": "376ef8c40e36141fc2656c400def9335f5c44fce", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/102eaa5c107d48b6787279be8d9de6782a565cb8/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/102eaa5c107d48b6787279be8d9de6782a565cb8/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=102eaa5c107d48b6787279be8d9de6782a565cb8", "patch": "@@ -99,11 +99,13 @@ impl IntoArgs for (CrateNum, DefId) {\n \n provide! { <'tcx> tcx, def_id, other, cdata,\n     type_of => { cdata.get_type(def_id.index, tcx) }\n-    generics_of => { tcx.alloc_generics(cdata.get_generics(def_id.index)) }\n+    generics_of => {\n+        tcx.alloc_generics(cdata.get_generics(def_id.index, tcx.sess))\n+    }\n     predicates_of => { cdata.get_predicates(def_id.index, tcx) }\n     super_predicates_of => { cdata.get_super_predicates(def_id.index, tcx) }\n     trait_def => {\n-        tcx.alloc_trait_def(cdata.get_trait_def(def_id.index))\n+        tcx.alloc_trait_def(cdata.get_trait_def(def_id.index, tcx.sess))\n     }\n     adt_def => { cdata.get_adt_def(def_id.index, tcx) }\n     adt_destructor => {\n@@ -153,7 +155,7 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n     lookup_deprecation_entry => {\n         cdata.get_deprecation(def_id.index).map(DeprecationEntry::external)\n     }\n-    item_attrs => { cdata.get_item_attrs(def_id.index) }\n+    item_attrs => { cdata.get_item_attrs(def_id.index, tcx.sess) }\n     // FIXME(#38501) We've skipped a `read` on the `HirBody` of\n     // a `fn` when encoding, so the dep-tracking wouldn't work.\n     // This is only used by rustdoc anyway, which shouldn't have\n@@ -171,14 +173,14 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n     is_mir_available => { cdata.is_item_mir_available(def_id.index) }\n \n     dylib_dependency_formats => { Rc::new(cdata.get_dylib_dependency_formats()) }\n-    is_panic_runtime => { cdata.is_panic_runtime() }\n-    is_compiler_builtins => { cdata.is_compiler_builtins() }\n+    is_panic_runtime => { cdata.is_panic_runtime(tcx.sess) }\n+    is_compiler_builtins => { cdata.is_compiler_builtins(tcx.sess) }\n     has_global_allocator => { cdata.has_global_allocator() }\n-    is_sanitizer_runtime => { cdata.is_sanitizer_runtime() }\n-    is_profiler_runtime => { cdata.is_profiler_runtime() }\n+    is_sanitizer_runtime => { cdata.is_sanitizer_runtime(tcx.sess) }\n+    is_profiler_runtime => { cdata.is_profiler_runtime(tcx.sess) }\n     panic_strategy => { cdata.panic_strategy() }\n     extern_crate => { Rc::new(cdata.extern_crate.get()) }\n-    is_no_builtins => { cdata.is_no_builtins() }\n+    is_no_builtins => { cdata.is_no_builtins(tcx.sess) }\n     impl_defaultness => { cdata.get_impl_defaultness(def_id.index) }\n     exported_symbol_ids => { Rc::new(cdata.get_exported_symbols()) }\n     native_libraries => { Rc::new(cdata.get_native_libraries()) }\n@@ -237,8 +239,8 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n \n     used_crate_source => { Rc::new(cdata.source.clone()) }\n \n-    has_copy_closures => { cdata.has_copy_closures() }\n-    has_clone_closures => { cdata.has_clone_closures() }\n+    has_copy_closures => { cdata.has_copy_closures(tcx.sess) }\n+    has_clone_closures => { cdata.has_clone_closures(tcx.sess) }\n }\n \n pub fn provide_local<'tcx>(providers: &mut Providers<'tcx>) {\n@@ -358,8 +360,8 @@ impl CrateStore for cstore::CStore {\n         self.get_crate_data(def.krate).get_visibility(def.index)\n     }\n \n-    fn item_generics_cloned_untracked(&self, def: DefId) -> ty::Generics {\n-        self.get_crate_data(def.krate).get_generics(def.index)\n+    fn item_generics_cloned_untracked(&self, def: DefId, sess: &Session) -> ty::Generics {\n+        self.get_crate_data(def.krate).get_generics(def.index, sess)\n     }\n \n     fn associated_item_cloned_untracked(&self, def: DefId) -> ty::AssociatedItem\n@@ -454,7 +456,7 @@ impl CrateStore for cstore::CStore {\n         let body = filemap_to_stream(&sess.parse_sess, filemap, None);\n \n         // Mark the attrs as used\n-        let attrs = data.get_item_attrs(id.index);\n+        let attrs = data.get_item_attrs(id.index, sess);\n         for attr in attrs.iter() {\n             attr::mark_used(attr);\n         }"}, {"sha": "3ae070b10a9d12e3724e0965df1e9dad75985330", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/102eaa5c107d48b6787279be8d9de6782a565cb8/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/102eaa5c107d48b6787279be8d9de6782a565cb8/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=102eaa5c107d48b6787279be8d9de6782a565cb8", "patch": "@@ -291,7 +291,7 @@ impl<'a, 'tcx> SpecializedDecoder<Span> for DecodeContext<'a, 'tcx> {\n         let sess = if let Some(sess) = self.sess {\n             sess\n         } else {\n-            return Ok(Span::new(lo, hi, NO_EXPANSION));\n+            bug!(\"Cannot decode Span without Session.\")\n         };\n \n         let (lo, hi) = if lo > hi {\n@@ -313,7 +313,8 @@ impl<'a, 'tcx> SpecializedDecoder<Span> for DecodeContext<'a, 'tcx> {\n             // originate from the same filemap.\n             let last_filemap = &imported_filemaps[self.last_filemap_index];\n \n-            if lo >= last_filemap.original_start_pos && lo <= last_filemap.original_end_pos &&\n+            if lo >= last_filemap.original_start_pos &&\n+               lo <= last_filemap.original_end_pos &&\n                hi >= last_filemap.original_start_pos &&\n                hi <= last_filemap.original_end_pos {\n                 last_filemap\n@@ -335,8 +336,8 @@ impl<'a, 'tcx> SpecializedDecoder<Span> for DecodeContext<'a, 'tcx> {\n             }\n         };\n \n-        let lo = (lo - filemap.original_start_pos) + filemap.translated_filemap.start_pos;\n-        let hi = (hi - filemap.original_start_pos) + filemap.translated_filemap.start_pos;\n+        let lo = (lo + filemap.translated_filemap.start_pos) - filemap.original_start_pos;\n+        let hi = (hi + filemap.translated_filemap.start_pos) - filemap.original_start_pos;\n \n         Ok(Span::new(lo, hi, NO_EXPANSION))\n     }\n@@ -521,9 +522,9 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    pub fn get_trait_def(&self, item_id: DefIndex) -> ty::TraitDef {\n+    pub fn get_trait_def(&self, item_id: DefIndex, sess: &Session) -> ty::TraitDef {\n         let data = match self.entry(item_id).kind {\n-            EntryKind::Trait(data) => data.decode(self),\n+            EntryKind::Trait(data) => data.decode((self, sess)),\n             _ => bug!(),\n         };\n \n@@ -607,8 +608,11 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    pub fn get_generics(&self, item_id: DefIndex) -> ty::Generics {\n-        self.entry(item_id).generics.unwrap().decode(self)\n+    pub fn get_generics(&self,\n+                        item_id: DefIndex,\n+                        sess: &Session)\n+                        -> ty::Generics {\n+        self.entry(item_id).generics.unwrap().decode((self, sess))\n     }\n \n     pub fn get_type(&self, id: DefIndex, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Ty<'tcx> {\n@@ -908,7 +912,7 @@ impl<'a, 'tcx> CrateMetadata {\n         }\n     }\n \n-    pub fn get_item_attrs(&self, node_id: DefIndex) -> Rc<[ast::Attribute]> {\n+    pub fn get_item_attrs(&self, node_id: DefIndex, sess: &Session) -> Rc<[ast::Attribute]> {\n         let (node_as, node_index) =\n             (node_id.address_space().index(), node_id.as_array_index());\n         if self.is_proc_macro(node_id) {\n@@ -928,7 +932,7 @@ impl<'a, 'tcx> CrateMetadata {\n         if def_key.disambiguated_data.data == DefPathData::StructCtor {\n             item = self.entry(def_key.parent.unwrap());\n         }\n-        let result: Rc<[ast::Attribute]> = Rc::from(self.get_attributes(&item));\n+        let result: Rc<[ast::Attribute]> = Rc::from(self.get_attributes(&item, sess));\n         let vec_ = &mut self.attribute_cache.borrow_mut()[node_as];\n         if vec_.len() < node_index + 1 {\n             vec_.resize(node_index + 1, None);\n@@ -945,9 +949,9 @@ impl<'a, 'tcx> CrateMetadata {\n             .collect()\n     }\n \n-    fn get_attributes(&self, item: &Entry<'tcx>) -> Vec<ast::Attribute> {\n+    fn get_attributes(&self, item: &Entry<'tcx>, sess: &Session) -> Vec<ast::Attribute> {\n         item.attributes\n-            .decode(self)\n+            .decode((self, sess))\n             .map(|mut attr| {\n                 // Need new unique IDs: old thread-local IDs won't map to new threads.\n                 attr.id = attr::mk_attr_id();"}]}