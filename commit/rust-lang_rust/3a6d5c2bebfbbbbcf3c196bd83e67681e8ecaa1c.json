{"sha": "3a6d5c2bebfbbbbcf3c196bd83e67681e8ecaa1c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNhNmQ1YzJiZWJmYmJiYmNmM2MxOTZiZDgzZTY3NjgxZThlY2FhMWM=", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2021-05-15T15:23:16Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2021-06-01T19:43:30Z"}, "message": "Avoid creating anonymous nodes with zero or one dependency.", "tree": {"sha": "d86cdb6059cb5f4f6840c032e4558aa05e69bf70", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d86cdb6059cb5f4f6840c032e4558aa05e69bf70"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3a6d5c2bebfbbbbcf3c196bd83e67681e8ecaa1c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3a6d5c2bebfbbbbcf3c196bd83e67681e8ecaa1c", "html_url": "https://github.com/rust-lang/rust/commit/3a6d5c2bebfbbbbcf3c196bd83e67681e8ecaa1c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3a6d5c2bebfbbbbcf3c196bd83e67681e8ecaa1c/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7f9ab0300cd66f6f616e03ea90b2d71af474bf28", "url": "https://api.github.com/repos/rust-lang/rust/commits/7f9ab0300cd66f6f616e03ea90b2d71af474bf28", "html_url": "https://github.com/rust-lang/rust/commit/7f9ab0300cd66f6f616e03ea90b2d71af474bf28"}], "stats": {"total": 77, "additions": 50, "deletions": 27}, "files": [{"sha": "a8455854ebb5fd97809e26f170c29c13beb4cfca", "filename": "compiler/rustc_incremental/src/persist/save.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3a6d5c2bebfbbbbcf3c196bd83e67681e8ecaa1c/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fsave.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a6d5c2bebfbbbbcf3c196bd83e67681e8ecaa1c/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fsave.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fsave.rs?ref=3a6d5c2bebfbbbbcf3c196bd83e67681e8ecaa1c", "patch": "@@ -229,6 +229,7 @@ pub fn build_dep_graph(\n     }\n \n     Some(DepGraph::new(\n+        &sess.prof,\n         prev_graph,\n         prev_work_products,\n         encoder,"}, {"sha": "9481da70f4241ec24562af96e830f73eb1f05f2e", "filename": "compiler/rustc_query_system/src/dep_graph/graph.rs", "status": "modified", "additions": 49, "deletions": 27, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/3a6d5c2bebfbbbbcf3c196bd83e67681e8ecaa1c/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3a6d5c2bebfbbbbcf3c196bd83e67681e8ecaa1c/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs?ref=3a6d5c2bebfbbbbcf3c196bd83e67681e8ecaa1c", "patch": "@@ -44,6 +44,7 @@ rustc_index::newtype_index! {\n \n impl DepNodeIndex {\n     pub const INVALID: DepNodeIndex = DepNodeIndex::MAX;\n+    pub const DUMMY_ANON: DepNodeIndex = DepNodeIndex::from_u32(0);\n }\n \n impl std::convert::From<DepNodeIndex> for QueryInvocationId {\n@@ -108,6 +109,7 @@ where\n \n impl<K: DepKind> DepGraph<K> {\n     pub fn new(\n+        profiler: &SelfProfilerRef,\n         prev_graph: SerializedDepGraph<K>,\n         prev_work_products: FxHashMap<WorkProductId, WorkProduct>,\n         encoder: FileEncoder,\n@@ -116,16 +118,23 @@ impl<K: DepKind> DepGraph<K> {\n     ) -> DepGraph<K> {\n         let prev_graph_node_count = prev_graph.node_count();\n \n+        let current =\n+            CurrentDepGraph::new(prev_graph_node_count, encoder, record_graph, record_stats);\n+\n+        // Instantiate an *always green* node for dependency-less anonymous queries.\n+        let _green_node_index = current.intern_new_node(\n+            profiler,\n+            DepNode { kind: DepKind::NULL, hash: current.anon_id_seed.into() },\n+            smallvec![],\n+            Fingerprint::ZERO,\n+        );\n+        debug_assert_eq!(_green_node_index, DepNodeIndex::DUMMY_ANON);\n+\n         DepGraph {\n             data: Some(Lrc::new(DepGraphData {\n                 previous_work_products: prev_work_products,\n                 dep_node_debug: Default::default(),\n-                current: CurrentDepGraph::new(\n-                    prev_graph_node_count,\n-                    encoder,\n-                    record_graph,\n-                    record_stats,\n-                ),\n+                current,\n                 emitting_diagnostics: Default::default(),\n                 emitting_diagnostics_cond_var: Condvar::new(),\n                 previous: prev_graph,\n@@ -287,29 +296,42 @@ impl<K: DepKind> DepGraph<K> {\n             let task_deps = Lock::new(TaskDeps::default());\n             let result = K::with_deps(Some(&task_deps), op);\n             let task_deps = task_deps.into_inner();\n+            let task_deps = task_deps.reads;\n \n-            // The dep node indices are hashed here instead of hashing the dep nodes of the\n-            // dependencies. These indices may refer to different nodes per session, but this isn't\n-            // a problem here because we that ensure the final dep node hash is per session only by\n-            // combining it with the per session random number `anon_id_seed`. This hash only need\n-            // to map the dependencies to a single value on a per session basis.\n-            let mut hasher = StableHasher::new();\n-            task_deps.reads.hash(&mut hasher);\n-\n-            let target_dep_node = DepNode {\n-                kind: dep_kind,\n-                // Fingerprint::combine() is faster than sending Fingerprint\n-                // through the StableHasher (at least as long as StableHasher\n-                // is so slow).\n-                hash: data.current.anon_id_seed.combine(hasher.finish()).into(),\n-            };\n+            let dep_node_index = match task_deps.len() {\n+                0 => {\n+                    // Dependency-less anonymous nodes can safely be replaced by a dummy node.\n+                    DepNodeIndex::DUMMY_ANON\n+                }\n+                1 => {\n+                    // When there is only one dependency, don't bother creating a node.\n+                    task_deps[0]\n+                }\n+                _ => {\n+                    // The dep node indices are hashed here instead of hashing the dep nodes of the\n+                    // dependencies. These indices may refer to different nodes per session, but this isn't\n+                    // a problem here because we that ensure the final dep node hash is per session only by\n+                    // combining it with the per session random number `anon_id_seed`. This hash only need\n+                    // to map the dependencies to a single value on a per session basis.\n+                    let mut hasher = StableHasher::new();\n+                    task_deps.hash(&mut hasher);\n+\n+                    let target_dep_node = DepNode {\n+                        kind: dep_kind,\n+                        // Fingerprint::combine() is faster than sending Fingerprint\n+                        // through the StableHasher (at least as long as StableHasher\n+                        // is so slow).\n+                        hash: data.current.anon_id_seed.combine(hasher.finish()).into(),\n+                    };\n \n-            let dep_node_index = data.current.intern_new_node(\n-                cx.profiler(),\n-                target_dep_node,\n-                task_deps.reads,\n-                Fingerprint::ZERO,\n-            );\n+                    data.current.intern_new_node(\n+                        cx.profiler(),\n+                        target_dep_node,\n+                        task_deps,\n+                        Fingerprint::ZERO,\n+                    )\n+                }\n+            };\n \n             (result, dep_node_index)\n         } else {"}]}