{"sha": "df59a44feadad386a8b69cfafaf50605c6af2689", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRmNTlhNDRmZWFkYWQzODZhOGI2OWNmYWZhZjUwNjA1YzZhZjI2ODk=", "commit": {"author": {"name": "Tyson Nottingham", "email": "tgnottingham@gmail.com", "date": "2020-09-21T00:40:40Z"}, "committer": {"name": "Tyson Nottingham", "email": "tgnottingham@gmail.com", "date": "2020-10-26T23:34:04Z"}, "message": "rustc_span: improve bounds checks in byte_pos_to_line_and_col\n\nThe effect of this change is to consider edge-case spans that start or\nend at the position one past the end of a file to be valid during span\nhashing and encoding. This change means that these spans will be\npreserved across incremental compilation sessions when they are part of\na serialized query result, instead of causing the dummy span to be used.", "tree": {"sha": "7ef316cd9c873cd650f7f1ded323db08bcf55405", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7ef316cd9c873cd650f7f1ded323db08bcf55405"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/df59a44feadad386a8b69cfafaf50605c6af2689", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/df59a44feadad386a8b69cfafaf50605c6af2689", "html_url": "https://github.com/rust-lang/rust/commit/df59a44feadad386a8b69cfafaf50605c6af2689", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/df59a44feadad386a8b69cfafaf50605c6af2689/comments", "author": {"login": "tgnottingham", "id": 3668166, "node_id": "MDQ6VXNlcjM2NjgxNjY=", "avatar_url": "https://avatars.githubusercontent.com/u/3668166?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tgnottingham", "html_url": "https://github.com/tgnottingham", "followers_url": "https://api.github.com/users/tgnottingham/followers", "following_url": "https://api.github.com/users/tgnottingham/following{/other_user}", "gists_url": "https://api.github.com/users/tgnottingham/gists{/gist_id}", "starred_url": "https://api.github.com/users/tgnottingham/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tgnottingham/subscriptions", "organizations_url": "https://api.github.com/users/tgnottingham/orgs", "repos_url": "https://api.github.com/users/tgnottingham/repos", "events_url": "https://api.github.com/users/tgnottingham/events{/privacy}", "received_events_url": "https://api.github.com/users/tgnottingham/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tgnottingham", "id": 3668166, "node_id": "MDQ6VXNlcjM2NjgxNjY=", "avatar_url": "https://avatars.githubusercontent.com/u/3668166?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tgnottingham", "html_url": "https://github.com/tgnottingham", "followers_url": "https://api.github.com/users/tgnottingham/followers", "following_url": "https://api.github.com/users/tgnottingham/following{/other_user}", "gists_url": "https://api.github.com/users/tgnottingham/gists{/gist_id}", "starred_url": "https://api.github.com/users/tgnottingham/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tgnottingham/subscriptions", "organizations_url": "https://api.github.com/users/tgnottingham/orgs", "repos_url": "https://api.github.com/users/tgnottingham/repos", "events_url": "https://api.github.com/users/tgnottingham/events{/privacy}", "received_events_url": "https://api.github.com/users/tgnottingham/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0dce3f606e05cffab7361c132a399d3550ab0df8", "url": "https://api.github.com/repos/rust-lang/rust/commits/0dce3f606e05cffab7361c132a399d3550ab0df8", "html_url": "https://github.com/rust-lang/rust/commit/0dce3f606e05cffab7361c132a399d3550ab0df8"}], "stats": {"total": 43, "additions": 39, "deletions": 4}, "files": [{"sha": "2393ae21613713430909a48d879238bf08f61bc0", "filename": "compiler/rustc_span/src/caching_source_map_view.rs", "status": "modified", "additions": 29, "deletions": 3, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/df59a44feadad386a8b69cfafaf50605c6af2689/compiler%2Frustc_span%2Fsrc%2Fcaching_source_map_view.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df59a44feadad386a8b69cfafaf50605c6af2689/compiler%2Frustc_span%2Fsrc%2Fcaching_source_map_view.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fcaching_source_map_view.rs?ref=df59a44feadad386a8b69cfafaf50605c6af2689", "patch": "@@ -47,7 +47,7 @@ impl<'sm> CachingSourceMapView<'sm> {\n \n         // Check if the position is in one of the cached lines\n         for cache_entry in self.line_cache.iter_mut() {\n-            if pos >= cache_entry.line_start && pos < cache_entry.line_end {\n+            if line_contains((cache_entry.line_start, cache_entry.line_end), pos) {\n                 cache_entry.time_stamp = self.time_stamp;\n \n                 return Some((\n@@ -69,13 +69,13 @@ impl<'sm> CachingSourceMapView<'sm> {\n         let cache_entry = &mut self.line_cache[oldest];\n \n         // If the entry doesn't point to the correct file, fix it up\n-        if pos < cache_entry.file.start_pos || pos >= cache_entry.file.end_pos {\n+        if !file_contains(&cache_entry.file, pos) {\n             let file_valid;\n             if self.source_map.files().len() > 0 {\n                 let file_index = self.source_map.lookup_source_file_idx(pos);\n                 let file = self.source_map.files()[file_index].clone();\n \n-                if pos >= file.start_pos && pos < file.end_pos {\n+                if file_contains(&file, pos) {\n                     cache_entry.file = file;\n                     cache_entry.file_index = file_index;\n                     file_valid = true;\n@@ -102,3 +102,29 @@ impl<'sm> CachingSourceMapView<'sm> {\n         Some((cache_entry.file.clone(), cache_entry.line_number, pos - cache_entry.line_start))\n     }\n }\n+\n+#[inline]\n+fn line_contains(line_bounds: (BytePos, BytePos), pos: BytePos) -> bool {\n+    // This condition will be false in one case where we'd rather it wasn't. Spans often start/end\n+    // one past something, and when that something is the last character of a file (this can happen\n+    // when a file doesn't end in a newline, for example), we'd still like for the position to be\n+    // considered within the last line. However, it isn't according to the exclusive upper bound\n+    // below. We cannot change the upper bound to be inclusive, because for most lines, the upper\n+    // bound is the same as the lower bound of the next line, so there would be an ambiguity.\n+    //\n+    // Supposing we only use this function to check whether or not the line cache entry contains\n+    // a position, the only ramification of the above is that we will get cache misses for these\n+    // rare positions. A line lookup for the position via `SourceMap::lookup_line` after a cache\n+    // miss will produce the last line number, as desired.\n+    line_bounds.0 <= pos && pos < line_bounds.1\n+}\n+\n+#[inline]\n+fn file_contains(file: &SourceFile, pos: BytePos) -> bool {\n+    // `SourceMap::lookup_source_file_idx` and `SourceFile::contains` both consider the position\n+    // one past the end of a file to belong to it. Normally, that's what we want. But for the\n+    // purposes of converting a byte position to a line and column number, we can't come up with a\n+    // line and column number if the file is empty, because an empty file doesn't contain any\n+    // lines. So for our purposes, we don't consider empty files to contain any byte position.\n+    file.contains(pos) && !file.is_empty()\n+}"}, {"sha": "21a38283f45e6cc77a69ca56081fa82a735d9243", "filename": "compiler/rustc_span/src/lib.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/df59a44feadad386a8b69cfafaf50605c6af2689/compiler%2Frustc_span%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df59a44feadad386a8b69cfafaf50605c6af2689/compiler%2Frustc_span%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Flib.rs?ref=df59a44feadad386a8b69cfafaf50605c6af2689", "patch": "@@ -1427,7 +1427,7 @@ impl SourceFile {\n     }\n \n     pub fn line_bounds(&self, line_index: usize) -> (BytePos, BytePos) {\n-        if self.start_pos == self.end_pos {\n+        if self.is_empty() {\n             return (self.start_pos, self.end_pos);\n         }\n \n@@ -1439,11 +1439,20 @@ impl SourceFile {\n         }\n     }\n \n+    /// Returns whether or not the file contains the given `SourceMap` byte\n+    /// position. The position one past the end of the file is considered to be\n+    /// contained by the file. This implies that files for which `is_empty`\n+    /// returns true still contain one byte position according to this function.\n     #[inline]\n     pub fn contains(&self, byte_pos: BytePos) -> bool {\n         byte_pos >= self.start_pos && byte_pos <= self.end_pos\n     }\n \n+    #[inline]\n+    pub fn is_empty(&self) -> bool {\n+        self.start_pos == self.end_pos\n+    }\n+\n     /// Calculates the original byte position relative to the start of the file\n     /// based on the given byte position.\n     pub fn original_relative_byte_pos(&self, pos: BytePos) -> BytePos {"}]}