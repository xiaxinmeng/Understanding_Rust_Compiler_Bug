{"sha": "666687a68cb9c42bf5eadcb2e5e447d7de5190d5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY2NjY4N2E2OGNiOWM0MmJmNWVhZGNiMmU1ZTQ0N2Q3ZGU1MTkwZDU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-11-05T16:49:08Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-11-05T16:49:08Z"}, "message": "Auto merge of #45072 - nikomatsakis:issue-38714, r=arielb1\n\nnew rules for merging expected and supplied types in closure signatures\n\nAs uncovered in #38714, we currently have some pretty bogus code for combining the \"expected signature\" of a closure with the \"supplied signature\". To set the scene, consider a case like this:\n\n```rust\nfn foo<F>(f: F)\nwhere\n  F: for<'a> FnOnce(&'a u32) -> &'a u32\n  // ^ *expected* signature comes from this where-clause\n{\n    ...\n}\n\nfn main() {\n    foo(|x: &u32| -> &u32 { .. }\n     // ^^^^^^^^^^^^^^^^^ supplied signature\n     // comes from here\n}\n```\n\nIn this case, the supplied signature (a) includes all the parts and (b) is the same as the expected signature, modulo the names used for the regions. But often people supply only *some* parts of the signature. For example, one might write `foo(|x| ..)`, leaving *everything* to be inferred, or perhaps `foo(|x: &u32| ...)`, which leaves the return type to be inferred.\n\nIn the current code, we use the expected type to supply the types that are not given, but otherwise use the type the user gave, except for one case: if the user writes `fn foo(|x: _| ..)` (i.e., an underscore at the outermost level), then we will take the expected type (rather than instantiating a fresh type variable). This can result in nonsensical situations, particularly with bound regions that link the types of parameters to one another or to the return type. Consider `foo(|x: &u32| ...)` -- if we *literally* splice the expected return type of `&'a u32` together with what the user gave, we wind up with a signature like `for<'a> fn(&u32) -> &'a u32`. This is not even permitted as a type, because bound regions like `'a` must appear also in the arguments somewhere, which is why #38714 leads to an ICE.\n\nThis PR institutes some new rules. These are not meant to be the *final* set of rules, but they are a kind of \"lower bar\" for what kind of code we accept (i.e., we can extend these rules in the future to be smarter in some cases, but -- as we will see -- these rules do accept some things that we then would not be able to back off from).\n\nThese rules are derived from a few premises:\n\n- First and foremost, anonymous regions in closure annotation are mostly requests for the code to \"figure out the right lifetime\" and shouldn't be read too closely. So for example when people write a closure signature like `|x: &u32|`, they are really intended for us to \"figure out\" the right region for `x`.\n    - In contrast, the current code treats this supplied type as being more definitive. In particular, writing `|x: &u32|` would always result in the region of `x` being bound in the closure type. In other words, the signature would be something like `for<'a> fn(&'a u32)` -- this is derived from the fact that `fn(&u32)` expands to a type where the region is bound in the fn type.\n    - This PR takes a different approach. The \"binding level\" for reference types appearing in closure signatures can be informed in some cases by the expected signature. So, for example, if the expected signature is something like `(&'f u32)`, where the region of the first argument appears free, then for `|x: &u32|`, the new code would infer `x` to also have the free region `'f`.\n        - This inference has some limits. We don't do this for bindings that appear within the selected types themselves. So e.g. `|x: fn(&u32)|`, when combined with an expected type of `fn(fn(&'f u32))`, would still result in a closure that expects `for<'a> fn(&'a u32)`. Such an annotation will ultimately result in an error, as it happens, since `foo` is supplying a `fn(&'f u32)` to the closure, but the closure signature demands a `for<'a> fn(&'a u32)`. But still we choose to trust it and have the user change it.\n        - I wanted to preserve the rough intuition that one can copy-and-paste a type out of the fn signature and into the fn body without dramatically changing its meaning. Interestingly, if one has `|x: &u32|`, then regardless of whether the region of `x` is bound or free in the closure signature, it is also free in the region body, and that is also true when one writes `let x: &u32`, so that intuition holds here. But the same would not be true for `fn(&u32)`, hence the different behavior.\n- Second, we must take either **all** the references to bound regions from the expected type or **none**. The current code, as we saw, will happily take a bound region in the return type but drop the other place where it is used, in the parameters. Since bound regions are all about linking multiple things together, I think it's important not to do that. (That said, we could conceivably be a bit less strict here, since the subtyping rules will get our back, but we definitely don't want any bound regions that appear only in the return type.)\n- Finally, we cannot take the bound region names from the supplied types and \"intermix\" them with the names from the expected types.\n    - We *could* potentially do some alpha renaming, but I didn't do that.\n- Ultimately, if the types the user supplied do not match expectations in some way that we cannot recover from, we fallback to deriving the closure signature solely from those expected types.\n    - For example, if the expected type is `u32` but the user wrote `i32`.\n    - Or, more subtle, if the user wrote e.g. `&'x u32` for some named lifetime `'x`, but the expected type includes a bound lifetime (`for<'a> (&'a u32)`). In that case, preferring the type that the user explicitly wrote would hide an appearance of a bound name from the expected type, and we try to never do that.\n\nThe detailed rules that I came up with are found in the code, but for ease of reading I've also [excerpted them into a gist](https://gist.github.com/nikomatsakis/e69252a2b57e6d97d044c2f254c177f1). I am not convinced they are correct and would welcome feedback for alternative approaches.\n\n(As an aside, the way I think I would ultimately *prefer* to think about this is that the conversion from HIR types to internal types could be parameterized by an \"expected type\" that it uses to guide itself. However, since that would be a pain, I opted *in the code* to first instantiate the supplied types as `Ty<'tcx>` and then \"merge\" those types with the `Ty<'tcx>` from the expected signature.)\n\nI think we should probably FCP this before landing.\n\ncc @rust-lang/lang\nr? @arielb1", "tree": {"sha": "47afa62a461e46d465dca7fb8b1a0c1cf6023f3c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/47afa62a461e46d465dca7fb8b1a0c1cf6023f3c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/666687a68cb9c42bf5eadcb2e5e447d7de5190d5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/666687a68cb9c42bf5eadcb2e5e447d7de5190d5", "html_url": "https://github.com/rust-lang/rust/commit/666687a68cb9c42bf5eadcb2e5e447d7de5190d5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/666687a68cb9c42bf5eadcb2e5e447d7de5190d5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b55d29095646f24461de8adebe867986863f8c46", "url": "https://api.github.com/repos/rust-lang/rust/commits/b55d29095646f24461de8adebe867986863f8c46", "html_url": "https://github.com/rust-lang/rust/commit/b55d29095646f24461de8adebe867986863f8c46"}, {"sha": "e8a96c97f4972c3d4823105f53e28b88cd9b533e", "url": "https://api.github.com/repos/rust-lang/rust/commits/e8a96c97f4972c3d4823105f53e28b88cd9b533e", "html_url": "https://github.com/rust-lang/rust/commit/e8a96c97f4972c3d4823105f53e28b88cd9b533e"}], "stats": {"total": 1007, "additions": 838, "deletions": 169}, "files": [{"sha": "6736751a5a2c225065b2c6baf966de387474a60a", "filename": "src/librustc/infer/higher_ranked/mod.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/666687a68cb9c42bf5eadcb2e5e447d7de5190d5/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/666687a68cb9c42bf5eadcb2e5e447d7de5190d5/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=666687a68cb9c42bf5eadcb2e5e447d7de5190d5", "patch": "@@ -155,7 +155,10 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n                                .filter(|&&r| !skol_resolution_map.contains_key(r))\n                                .cloned()\n                                .next()\n-                               .expect(\"no representative region\");\n+                               .unwrap_or_else(|| {\n+                                   bug!(\"no representative region for `{:?}` in `{:?}`\",\n+                                        skol, regions)\n+                               });\n \n                     (skol, representative)\n                 })"}, {"sha": "1471e235156eb8ade6a050fe0668ceb92e75565a", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 0, "deletions": 54, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/666687a68cb9c42bf5eadcb2e5e447d7de5190d5/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/666687a68cb9c42bf5eadcb2e5e447d7de5190d5/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=666687a68cb9c42bf5eadcb2e5e447d7de5190d5", "patch": "@@ -1206,60 +1206,6 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         bare_fn_ty\n     }\n \n-    pub fn ty_of_closure(&self,\n-        unsafety: hir::Unsafety,\n-        decl: &hir::FnDecl,\n-        abi: abi::Abi,\n-        expected_sig: Option<ty::FnSig<'tcx>>)\n-        -> ty::PolyFnSig<'tcx>\n-    {\n-        debug!(\"ty_of_closure(expected_sig={:?})\",\n-               expected_sig);\n-\n-        let input_tys = decl.inputs.iter().enumerate().map(|(i, a)| {\n-            let expected_arg_ty = expected_sig.as_ref().and_then(|e| {\n-                // no guarantee that the correct number of expected args\n-                // were supplied\n-                if i < e.inputs().len() {\n-                    Some(e.inputs()[i])\n-                } else {\n-                    None\n-                }\n-            });\n-            self.ty_of_arg(a, expected_arg_ty)\n-        });\n-\n-        let expected_ret_ty = expected_sig.as_ref().map(|e| e.output());\n-\n-        let output_ty = match decl.output {\n-            hir::Return(ref output) => {\n-                if let (&hir::TyInfer, Some(expected_ret_ty)) = (&output.node, expected_ret_ty) {\n-                    self.record_ty(output.hir_id, expected_ret_ty, output.span);\n-                    expected_ret_ty\n-                } else {\n-                    self.ast_ty_to_ty(&output)\n-                }\n-            }\n-            hir::DefaultReturn(span) => {\n-                if let Some(expected_ret_ty) = expected_ret_ty {\n-                    expected_ret_ty\n-                } else {\n-                    self.ty_infer(span)\n-                }\n-            }\n-        };\n-\n-        debug!(\"ty_of_closure: output_ty={:?}\", output_ty);\n-\n-        ty::Binder(self.tcx().mk_fn_sig(\n-            input_tys,\n-            output_ty,\n-            decl.variadic,\n-            unsafety,\n-            abi\n-        ))\n-    }\n-\n     /// Given the bounds on an object, determines what single region bound (if any) we can\n     /// use to summarize this type. The basic idea is that we will use the bound the user\n     /// provided, if they provided one, and otherwise search the supertypes of trait bounds"}, {"sha": "d475fb0cf1a142c5139f8a607f996d79743c1aaf", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 391, "deletions": 92, "changes": 483, "blob_url": "https://github.com/rust-lang/rust/blob/666687a68cb9c42bf5eadcb2e5e447d7de5190d5/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/666687a68cb9c42bf5eadcb2e5e447d7de5190d5/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=666687a68cb9c42bf5eadcb2e5e447d7de5190d5", "patch": "@@ -13,25 +13,37 @@\n use super::{check_fn, Expectation, FnCtxt};\n \n use astconv::AstConv;\n+use rustc::hir::def_id::DefId;\n+use rustc::infer::{InferOk, InferResult};\n+use rustc::infer::LateBoundRegionConversionTime;\n use rustc::infer::type_variable::TypeVariableOrigin;\n use rustc::ty::{self, ToPolyTraitRef, Ty};\n use rustc::ty::subst::Substs;\n+use rustc::ty::TypeFoldable;\n use std::cmp;\n use std::iter;\n use syntax::abi::Abi;\n use rustc::hir;\n \n+struct ClosureSignatures<'tcx> {\n+    bound_sig: ty::PolyFnSig<'tcx>,\n+    liberated_sig: ty::FnSig<'tcx>,\n+}\n+\n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n-    pub fn check_expr_closure(&self,\n-                              expr: &hir::Expr,\n-                              _capture: hir::CaptureClause,\n-                              decl: &'gcx hir::FnDecl,\n-                              body_id: hir::BodyId,\n-                              expected: Expectation<'tcx>)\n-                              -> Ty<'tcx> {\n-        debug!(\"check_expr_closure(expr={:?},expected={:?})\",\n-               expr,\n-               expected);\n+    pub fn check_expr_closure(\n+        &self,\n+        expr: &hir::Expr,\n+        _capture: hir::CaptureClause,\n+        decl: &'gcx hir::FnDecl,\n+        body_id: hir::BodyId,\n+        expected: Expectation<'tcx>,\n+    ) -> Ty<'tcx> {\n+        debug!(\n+            \"check_expr_closure(expr={:?},expected={:?})\",\n+            expr,\n+            expected\n+        );\n \n         // It's always helpful for inference if we know the kind of\n         // closure sooner rather than later, so first examine the expected\n@@ -44,70 +56,84 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         self.check_closure(expr, expected_kind, decl, body, expected_sig)\n     }\n \n-    fn check_closure(&self,\n-                     expr: &hir::Expr,\n-                     opt_kind: Option<ty::ClosureKind>,\n-                     decl: &'gcx hir::FnDecl,\n-                     body: &'gcx hir::Body,\n-                     expected_sig: Option<ty::FnSig<'tcx>>)\n-                     -> Ty<'tcx> {\n-        debug!(\"check_closure opt_kind={:?} expected_sig={:?}\",\n-               opt_kind,\n-               expected_sig);\n+    fn check_closure(\n+        &self,\n+        expr: &hir::Expr,\n+        opt_kind: Option<ty::ClosureKind>,\n+        decl: &'gcx hir::FnDecl,\n+        body: &'gcx hir::Body,\n+        expected_sig: Option<ty::FnSig<'tcx>>,\n+    ) -> Ty<'tcx> {\n+        debug!(\n+            \"check_closure(opt_kind={:?}, expected_sig={:?})\",\n+            opt_kind,\n+            expected_sig\n+        );\n \n         let expr_def_id = self.tcx.hir.local_def_id(expr.id);\n-        let sig = AstConv::ty_of_closure(self,\n-                                         hir::Unsafety::Normal,\n-                                         decl,\n-                                         Abi::RustCall,\n-                                         expected_sig);\n-        // `deduce_expectations_from_expected_type` introduces late-bound\n-        // lifetimes defined elsewhere, which we need to anonymize away.\n-        let sig = self.tcx.anonymize_late_bound_regions(&sig);\n+\n+        let ClosureSignatures {\n+            bound_sig,\n+            liberated_sig,\n+        } = self.sig_of_closure(expr_def_id, decl, body, expected_sig);\n+\n+        debug!(\"check_closure: ty_of_closure returns {:?}\", liberated_sig);\n+\n+        let interior = check_fn(\n+            self,\n+            self.param_env,\n+            liberated_sig,\n+            decl,\n+            expr.id,\n+            body,\n+            true,\n+        ).1;\n \n         // Create type variables (for now) to represent the transformed\n         // types of upvars. These will be unified during the upvar\n         // inference phase (`upvar.rs`).\n-        let base_substs = Substs::identity_for_item(self.tcx,\n-            self.tcx.closure_base_def_id(expr_def_id));\n-        let substs = base_substs.extend_to(self.tcx, expr_def_id,\n-                |_, _| span_bug!(expr.span, \"closure has region param\"),\n-                |_, _| self.infcx.next_ty_var(TypeVariableOrigin::TransformedUpvar(expr.span))\n+        let base_substs =\n+            Substs::identity_for_item(self.tcx, self.tcx.closure_base_def_id(expr_def_id));\n+        let substs = base_substs.extend_to(\n+            self.tcx,\n+            expr_def_id,\n+            |_, _| span_bug!(expr.span, \"closure has region param\"),\n+            |_, _| {\n+                self.infcx\n+                    .next_ty_var(TypeVariableOrigin::TransformedUpvar(expr.span))\n+            },\n         );\n-\n-        let fn_sig = self.liberate_late_bound_regions(expr_def_id, &sig);\n-        let fn_sig = self.inh.normalize_associated_types_in(body.value.span,\n-                                                            body.value.id,\n-                                                            self.param_env,\n-                                                            &fn_sig);\n-\n-        let interior = check_fn(self, self.param_env, fn_sig, decl, expr.id, body, true).1;\n+        let closure_type = self.tcx.mk_closure(expr_def_id, substs);\n \n         if let Some(interior) = interior {\n-            let closure_substs = ty::ClosureSubsts {\n-                substs: substs,\n-            };\n+            let closure_substs = ty::ClosureSubsts { substs: substs };\n             return self.tcx.mk_generator(expr_def_id, closure_substs, interior);\n         }\n \n-        let closure_type = self.tcx.mk_closure(expr_def_id, substs);\n-\n-        debug!(\"check_closure: expr.id={:?} closure_type={:?}\", expr.id, closure_type);\n+        debug!(\n+            \"check_closure: expr.id={:?} closure_type={:?}\",\n+            expr.id,\n+            closure_type\n+        );\n \n         // Tuple up the arguments and insert the resulting function type into\n         // the `closures` table.\n-        let sig = sig.map_bound(|sig| self.tcx.mk_fn_sig(\n-            iter::once(self.tcx.intern_tup(sig.inputs(), false)),\n-            sig.output(),\n-            sig.variadic,\n-            sig.unsafety,\n-            sig.abi\n-        ));\n-\n-        debug!(\"closure for {:?} --> sig={:?} opt_kind={:?}\",\n-               expr_def_id,\n-               sig,\n-               opt_kind);\n+        let sig = bound_sig.map_bound(|sig| {\n+            self.tcx.mk_fn_sig(\n+                iter::once(self.tcx.intern_tup(sig.inputs(), false)),\n+                sig.output(),\n+                sig.variadic,\n+                sig.unsafety,\n+                sig.abi,\n+            )\n+        });\n+\n+        debug!(\n+            \"check_closure: expr_def_id={:?}, sig={:?}, opt_kind={:?}\",\n+            expr_def_id,\n+            sig,\n+            opt_kind\n+        );\n \n         {\n             let mut tables = self.tables.borrow_mut();\n@@ -123,22 +149,26 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         closure_type\n     }\n \n-    fn deduce_expectations_from_expected_type\n-        (&self,\n-         expected_ty: Ty<'tcx>)\n-         -> (Option<ty::FnSig<'tcx>>, Option<ty::ClosureKind>) {\n-        debug!(\"deduce_expectations_from_expected_type(expected_ty={:?})\",\n-               expected_ty);\n+    fn deduce_expectations_from_expected_type(\n+        &self,\n+        expected_ty: Ty<'tcx>,\n+    ) -> (Option<ty::FnSig<'tcx>>, Option<ty::ClosureKind>) {\n+        debug!(\n+            \"deduce_expectations_from_expected_type(expected_ty={:?})\",\n+            expected_ty\n+        );\n \n         match expected_ty.sty {\n             ty::TyDynamic(ref object_type, ..) => {\n-                let sig = object_type.projection_bounds()\n+                let sig = object_type\n+                    .projection_bounds()\n                     .filter_map(|pb| {\n                         let pb = pb.with_self_ty(self.tcx, self.tcx.types.err);\n                         self.deduce_sig_from_projection(&pb)\n                     })\n                     .next();\n-                let kind = object_type.principal()\n+                let kind = object_type\n+                    .principal()\n                     .and_then(|p| self.tcx.lang_items().fn_trait_kind(p.def_id()));\n                 (sig, kind)\n             }\n@@ -148,19 +178,22 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn deduce_expectations_from_obligations\n-        (&self,\n-         expected_vid: ty::TyVid)\n-         -> (Option<ty::FnSig<'tcx>>, Option<ty::ClosureKind>) {\n+    fn deduce_expectations_from_obligations(\n+        &self,\n+        expected_vid: ty::TyVid,\n+    ) -> (Option<ty::FnSig<'tcx>>, Option<ty::ClosureKind>) {\n         let fulfillment_cx = self.fulfillment_cx.borrow();\n         // Here `expected_ty` is known to be a type inference variable.\n \n-        let expected_sig = fulfillment_cx.pending_obligations()\n+        let expected_sig = fulfillment_cx\n+            .pending_obligations()\n             .iter()\n             .map(|obligation| &obligation.obligation)\n             .filter_map(|obligation| {\n-                debug!(\"deduce_expectations_from_obligations: obligation.predicate={:?}\",\n-                       obligation.predicate);\n+                debug!(\n+                    \"deduce_expectations_from_obligations: obligation.predicate={:?}\",\n+                    obligation.predicate\n+                );\n \n                 match obligation.predicate {\n                     // Given a Projection predicate, we can potentially infer\n@@ -179,7 +212,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // infer the kind. This can occur if there is a trait-reference\n         // like `F : Fn<A>`. Note that due to subtyping we could encounter\n         // many viable options, so pick the most restrictive.\n-        let expected_kind = fulfillment_cx.pending_obligations()\n+        let expected_kind = fulfillment_cx\n+            .pending_obligations()\n             .iter()\n             .map(|obligation| &obligation.obligation)\n             .filter_map(|obligation| {\n@@ -204,20 +238,23 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     // inference variable.\n                     ty::Predicate::ClosureKind(..) => None,\n                 };\n-                opt_trait_ref.and_then(|tr| self.self_type_matches_expected_vid(tr, expected_vid))\n+                opt_trait_ref\n+                    .and_then(|tr| self.self_type_matches_expected_vid(tr, expected_vid))\n                     .and_then(|tr| self.tcx.lang_items().fn_trait_kind(tr.def_id()))\n             })\n-            .fold(None,\n-                  |best, cur| Some(best.map_or(cur, |best| cmp::min(best, cur))));\n+            .fold(None, |best, cur| {\n+                Some(best.map_or(cur, |best| cmp::min(best, cur)))\n+            });\n \n         (expected_sig, expected_kind)\n     }\n \n     /// Given a projection like \"<F as Fn(X)>::Result == Y\", we can deduce\n     /// everything we need to know about a closure.\n-    fn deduce_sig_from_projection(&self,\n-                                  projection: &ty::PolyProjectionPredicate<'tcx>)\n-                                  -> Option<ty::FnSig<'tcx>> {\n+    fn deduce_sig_from_projection(\n+        &self,\n+        projection: &ty::PolyProjectionPredicate<'tcx>,\n+    ) -> Option<ty::FnSig<'tcx>> {\n         let tcx = self.tcx;\n \n         debug!(\"deduce_sig_from_projection({:?})\", projection);\n@@ -230,8 +267,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         let arg_param_ty = trait_ref.substs().type_at(1);\n         let arg_param_ty = self.resolve_type_vars_if_possible(&arg_param_ty);\n-        debug!(\"deduce_sig_from_projection: arg_param_ty {:?}\",\n-               arg_param_ty);\n+        debug!(\n+            \"deduce_sig_from_projection: arg_param_ty {:?}\",\n+            arg_param_ty\n+        );\n \n         let input_tys = match arg_param_ty.sty {\n             ty::TyTuple(tys, _) => tys.into_iter(),\n@@ -242,31 +281,291 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         let ret_param_ty = projection.0.ty;\n         let ret_param_ty = self.resolve_type_vars_if_possible(&ret_param_ty);\n-        debug!(\"deduce_sig_from_projection: ret_param_ty {:?}\", ret_param_ty);\n+        debug!(\n+            \"deduce_sig_from_projection: ret_param_ty {:?}\",\n+            ret_param_ty\n+        );\n \n         let fn_sig = self.tcx.mk_fn_sig(\n             input_tys.cloned(),\n             ret_param_ty,\n             false,\n             hir::Unsafety::Normal,\n-            Abi::Rust\n+            Abi::Rust,\n         );\n         debug!(\"deduce_sig_from_projection: fn_sig {:?}\", fn_sig);\n \n         Some(fn_sig)\n     }\n \n-    fn self_type_matches_expected_vid(&self,\n-                                      trait_ref: ty::PolyTraitRef<'tcx>,\n-                                      expected_vid: ty::TyVid)\n-                                      -> Option<ty::PolyTraitRef<'tcx>> {\n+    fn self_type_matches_expected_vid(\n+        &self,\n+        trait_ref: ty::PolyTraitRef<'tcx>,\n+        expected_vid: ty::TyVid,\n+    ) -> Option<ty::PolyTraitRef<'tcx>> {\n         let self_ty = self.shallow_resolve(trait_ref.self_ty());\n-        debug!(\"self_type_matches_expected_vid(trait_ref={:?}, self_ty={:?})\",\n-               trait_ref,\n-               self_ty);\n+        debug!(\n+            \"self_type_matches_expected_vid(trait_ref={:?}, self_ty={:?})\",\n+            trait_ref,\n+            self_ty\n+        );\n         match self_ty.sty {\n             ty::TyInfer(ty::TyVar(v)) if expected_vid == v => Some(trait_ref),\n             _ => None,\n         }\n     }\n+\n+    fn sig_of_closure(\n+        &self,\n+        expr_def_id: DefId,\n+        decl: &hir::FnDecl,\n+        body: &hir::Body,\n+        expected_sig: Option<ty::FnSig<'tcx>>,\n+    ) -> ClosureSignatures<'tcx> {\n+        if let Some(e) = expected_sig {\n+            self.sig_of_closure_with_expectation(expr_def_id, decl, body, e)\n+        } else {\n+            self.sig_of_closure_no_expectation(expr_def_id, decl, body)\n+        }\n+    }\n+\n+    /// If there is no expected signature, then we will convert the\n+    /// types that the user gave into a signature.\n+    fn sig_of_closure_no_expectation(\n+        &self,\n+        expr_def_id: DefId,\n+        decl: &hir::FnDecl,\n+        body: &hir::Body,\n+    ) -> ClosureSignatures<'tcx> {\n+        debug!(\"sig_of_closure_no_expectation()\");\n+\n+        let bound_sig = self.supplied_sig_of_closure(decl);\n+\n+        self.closure_sigs(expr_def_id, body, bound_sig)\n+    }\n+\n+    /// Invoked to compute the signature of a closure expression. This\n+    /// combines any user-provided type annotations (e.g., `|x: u32|\n+    /// -> u32 { .. }`) with the expected signature.\n+    ///\n+    /// The approach is as follows:\n+    ///\n+    /// - Let `S` be the (higher-ranked) signature that we derive from the user's annotations.\n+    /// - Let `E` be the (higher-ranked) signature that we derive from the expectations, if any.\n+    ///   - If we have no expectation `E`, then the signature of the closure is `S`.\n+    ///   - Otherwise, the signature of the closure is E. Moreover:\n+    ///     - Skolemize the late-bound regions in `E`, yielding `E'`.\n+    ///     - Instantiate all the late-bound regions bound in the closure within `S`\n+    ///       with fresh (existential) variables, yielding `S'`\n+    ///     - Require that `E' = S'`\n+    ///       - We could use some kind of subtyping relationship here,\n+    ///         I imagine, but equality is easier and works fine for\n+    ///         our purposes.\n+    ///\n+    /// The key intuition here is that the user's types must be valid\n+    /// from \"the inside\" of the closure, but the expectation\n+    /// ultimately drives the overall signature.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// fn with_closure<F>(_: F)\n+    ///   where F: Fn(&u32) -> &u32 { .. }\n+    ///\n+    /// with_closure(|x: &u32| { ... })\n+    /// ```\n+    ///\n+    /// Here:\n+    /// - E would be `fn(&u32) -> &u32`.\n+    /// - S would be `fn(&u32) ->\n+    /// - E' is `&'!0 u32 -> &'!0 u32`\n+    /// - S' is `&'?0 u32 -> ?T`\n+    ///\n+    /// S' can be unified with E' with `['?0 = '!0, ?T = &'!10 u32]`.\n+    ///\n+    /// # Arguments\n+    ///\n+    /// - `expr_def_id`: the def-id of the closure expression\n+    /// - `decl`: the HIR declaration of the closure\n+    /// - `body`: the body of the closure\n+    /// - `expected_sig`: the expected signature (if any). Note that\n+    ///   this is missing a binder: that is, there may be late-bound\n+    ///   regions with depth 1, which are bound then by the closure.\n+    fn sig_of_closure_with_expectation(\n+        &self,\n+        expr_def_id: DefId,\n+        decl: &hir::FnDecl,\n+        body: &hir::Body,\n+        expected_sig: ty::FnSig<'tcx>,\n+    ) -> ClosureSignatures<'tcx> {\n+        debug!(\n+            \"sig_of_closure_with_expectation(expected_sig={:?})\",\n+            expected_sig\n+        );\n+\n+        // Watch out for some surprises and just ignore the\n+        // expectation if things don't see to match up with what we\n+        // expect.\n+        if expected_sig.variadic != decl.variadic {\n+            return self.sig_of_closure_no_expectation(expr_def_id, decl, body);\n+        } else if expected_sig.inputs_and_output.len() != decl.inputs.len() + 1 {\n+            // we could probably handle this case more gracefully\n+            return self.sig_of_closure_no_expectation(expr_def_id, decl, body);\n+        }\n+\n+        // Create a `PolyFnSig`. Note the oddity that late bound\n+        // regions appearing free in `expected_sig` are now bound up\n+        // in this binder we are creating.\n+        assert!(!expected_sig.has_regions_escaping_depth(1));\n+        let bound_sig = ty::Binder(self.tcx.mk_fn_sig(\n+            expected_sig.inputs().iter().cloned(),\n+            expected_sig.output(),\n+            decl.variadic,\n+            hir::Unsafety::Normal,\n+            Abi::RustCall,\n+        ));\n+\n+        // `deduce_expectations_from_expected_type` introduces\n+        // late-bound lifetimes defined elsewhere, which we now\n+        // anonymize away, so as not to confuse the user.\n+        let bound_sig = self.tcx.anonymize_late_bound_regions(&bound_sig);\n+\n+        let closure_sigs = self.closure_sigs(expr_def_id, body, bound_sig);\n+\n+        // Up till this point, we have ignored the annotations that the user\n+        // gave. This function will check that they unify successfully.\n+        // Along the way, it also writes out entries for types that the user\n+        // wrote into our tables, which are then later used by the privacy\n+        // check.\n+        match self.check_supplied_sig_against_expectation(decl, &closure_sigs) {\n+            Ok(infer_ok) => self.register_infer_ok_obligations(infer_ok),\n+            Err(_) => return self.sig_of_closure_no_expectation(expr_def_id, decl, body),\n+        }\n+\n+        closure_sigs\n+    }\n+\n+    /// Enforce the user's types against the expectation.  See\n+    /// `sig_of_closure_with_expectation` for details on the overall\n+    /// strategy.\n+    fn check_supplied_sig_against_expectation(\n+        &self,\n+        decl: &hir::FnDecl,\n+        expected_sigs: &ClosureSignatures<'tcx>,\n+    ) -> InferResult<'tcx, ()> {\n+        // Get the signature S that the user gave.\n+        //\n+        // (See comment on `sig_of_closure_with_expectation` for the\n+        // meaning of these letters.)\n+        let supplied_sig = self.supplied_sig_of_closure(decl);\n+\n+        debug!(\n+            \"check_supplied_sig_against_expectation: supplied_sig={:?}\",\n+            supplied_sig\n+        );\n+\n+        // FIXME(#45727): As discussed in [this comment][c1], naively\n+        // forcing equality here actually results in suboptimal error\n+        // messages in some cases.  For now, if there would have been\n+        // an obvious error, we fallback to declaring the type of the\n+        // closure to be the one the user gave, which allows other\n+        // error message code to trigger.\n+        //\n+        // However, I think [there is potential to do even better\n+        // here][c2], since in *this* code we have the precise span of\n+        // the type parameter in question in hand when we report the\n+        // error.\n+        //\n+        // [c1]: https://github.com/rust-lang/rust/pull/45072#issuecomment-341089706\n+        // [c2]: https://github.com/rust-lang/rust/pull/45072#issuecomment-341096796\n+        self.infcx.commit_if_ok(|_| {\n+            let mut all_obligations = vec![];\n+\n+            // The liberated version of this signature should be be a subtype\n+            // of the liberated form of the expectation.\n+            for ((hir_ty, &supplied_ty), expected_ty) in decl.inputs.iter()\n+                           .zip(*supplied_sig.inputs().skip_binder()) // binder moved to (*) below\n+                           .zip(expected_sigs.liberated_sig.inputs())\n+            // `liberated_sig` is E'.\n+            {\n+                // Instantiate (this part of..) S to S', i.e., with fresh variables.\n+                let (supplied_ty, _) = self.infcx.replace_late_bound_regions_with_fresh_var(\n+                    hir_ty.span,\n+                    LateBoundRegionConversionTime::FnCall,\n+                    &ty::Binder(supplied_ty),\n+                ); // recreated from (*) above\n+\n+                // Check that E' = S'.\n+                let cause = &self.misc(hir_ty.span);\n+                let InferOk {\n+                    value: (),\n+                    obligations,\n+                } = self.at(cause, self.param_env)\n+                    .eq(*expected_ty, supplied_ty)?;\n+                all_obligations.extend(obligations);\n+            }\n+\n+            let (supplied_output_ty, _) = self.infcx.replace_late_bound_regions_with_fresh_var(\n+                decl.output.span(),\n+                LateBoundRegionConversionTime::FnCall,\n+                &supplied_sig.output(),\n+            );\n+            let cause = &self.misc(decl.output.span());\n+            let InferOk {\n+                value: (),\n+                obligations,\n+            } = self.at(cause, self.param_env)\n+                .eq(expected_sigs.liberated_sig.output(), supplied_output_ty)?;\n+            all_obligations.extend(obligations);\n+\n+            Ok(InferOk {\n+                value: (),\n+                obligations: all_obligations,\n+            })\n+        })\n+    }\n+\n+    /// If there is no expected signature, then we will convert the\n+    /// types that the user gave into a signature.\n+    fn supplied_sig_of_closure(&self, decl: &hir::FnDecl) -> ty::PolyFnSig<'tcx> {\n+        let astconv: &AstConv = self;\n+\n+        // First, convert the types that the user supplied (if any).\n+        let supplied_arguments = decl.inputs.iter().map(|a| astconv.ast_ty_to_ty(a));\n+        let supplied_return = match decl.output {\n+            hir::Return(ref output) => astconv.ast_ty_to_ty(&output),\n+            hir::DefaultReturn(_) => astconv.ty_infer(decl.output.span()),\n+        };\n+\n+        let result = ty::Binder(self.tcx.mk_fn_sig(\n+            supplied_arguments,\n+            supplied_return,\n+            decl.variadic,\n+            hir::Unsafety::Normal,\n+            Abi::RustCall,\n+        ));\n+\n+        debug!(\"supplied_sig_of_closure: result={:?}\", result);\n+\n+        result\n+    }\n+\n+    fn closure_sigs(\n+        &self,\n+        expr_def_id: DefId,\n+        body: &hir::Body,\n+        bound_sig: ty::PolyFnSig<'tcx>,\n+    ) -> ClosureSignatures<'tcx> {\n+        let liberated_sig = self.liberate_late_bound_regions(expr_def_id, &bound_sig);\n+        let liberated_sig = self.inh.normalize_associated_types_in(\n+            body.value.span,\n+            body.value.id,\n+            self.param_env,\n+            &liberated_sig,\n+        );\n+        ClosureSignatures {\n+            bound_sig,\n+            liberated_sig,\n+        }\n+    }\n }"}, {"sha": "5227955d7b902441dce6e08c0dcc85faa0b0c947", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/666687a68cb9c42bf5eadcb2e5e447d7de5190d5/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/666687a68cb9c42bf5eadcb2e5e447d7de5190d5/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=666687a68cb9c42bf5eadcb2e5e447d7de5190d5", "patch": "@@ -76,6 +76,7 @@ This API is completely unstable and subject to change.\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n #![feature(conservative_impl_trait)]\n+#![feature(match_default_bindings)]\n #![feature(never_type)]\n #![feature(quote)]\n #![feature(rustc_diagnostic_macros)]"}, {"sha": "9995b00a9a76d9487b646254e9fd0098d591fa57", "filename": "src/test/compile-fail/closure-expected-type/README.md", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/666687a68cb9c42bf5eadcb2e5e447d7de5190d5/src%2Ftest%2Fcompile-fail%2Fclosure-expected-type%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/666687a68cb9c42bf5eadcb2e5e447d7de5190d5/src%2Ftest%2Fcompile-fail%2Fclosure-expected-type%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fclosure-expected-type%2FREADME.md?ref=666687a68cb9c42bf5eadcb2e5e447d7de5190d5", "patch": "@@ -0,0 +1 @@\n+See `src/test/run-pass/closure-expected-type`."}, {"sha": "f1b198a059176a6e425c8f2a871d11263d340d59", "filename": "src/test/compile-fail/closure-expected-type/expect-fn-supply-fn-multiple.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/666687a68cb9c42bf5eadcb2e5e447d7de5190d5/src%2Ftest%2Fcompile-fail%2Fclosure-expected-type%2Fexpect-fn-supply-fn-multiple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/666687a68cb9c42bf5eadcb2e5e447d7de5190d5/src%2Ftest%2Fcompile-fail%2Fclosure-expected-type%2Fexpect-fn-supply-fn-multiple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fclosure-expected-type%2Fexpect-fn-supply-fn-multiple.rs?ref=666687a68cb9c42bf5eadcb2e5e447d7de5190d5", "patch": "@@ -0,0 +1,49 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// must-compile-successfully\n+\n+#![feature(underscore_lifetimes)]\n+#![allow(warnings)]\n+\n+type Different<'a, 'b> = &'a mut (&'a (), &'b ());\n+type Same<'a> = Different<'a, 'a>;\n+\n+fn with_closure_expecting_different<F>(_: F)\n+    where F: for<'a, 'b> FnOnce(Different<'a, 'b>)\n+{\n+}\n+\n+fn with_closure_expecting_different_anon<F>(_: F)\n+    where F: FnOnce(Different<'_, '_>)\n+{\n+}\n+\n+fn supplying_nothing_expecting_anon() {\n+    with_closure_expecting_different_anon(|x: Different| {\n+    })\n+}\n+\n+fn supplying_nothing_expecting_named() {\n+    with_closure_expecting_different(|x: Different| {\n+    })\n+}\n+\n+fn supplying_underscore_expecting_anon() {\n+    with_closure_expecting_different_anon(|x: Different<'_, '_>| {\n+    })\n+}\n+\n+fn supplying_underscore_expecting_named() {\n+    with_closure_expecting_different(|x: Different<'_, '_>| {\n+    })\n+}\n+\n+fn main() { }"}, {"sha": "645fd1f80babf339dfe3521cd9901234ae31d389", "filename": "src/test/compile-fail/closure-expected-type/expect-fn-supply-fn.rs", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/666687a68cb9c42bf5eadcb2e5e447d7de5190d5/src%2Ftest%2Fcompile-fail%2Fclosure-expected-type%2Fexpect-fn-supply-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/666687a68cb9c42bf5eadcb2e5e447d7de5190d5/src%2Ftest%2Fcompile-fail%2Fclosure-expected-type%2Fexpect-fn-supply-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fclosure-expected-type%2Fexpect-fn-supply-fn.rs?ref=666687a68cb9c42bf5eadcb2e5e447d7de5190d5", "patch": "@@ -0,0 +1,70 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(underscore_lifetimes)]\n+\n+fn with_closure_expecting_fn_with_free_region<F>(_: F)\n+    where F: for<'a> FnOnce(fn(&'a u32), &i32)\n+{\n+}\n+\n+fn with_closure_expecting_fn_with_bound_region<F>(_: F)\n+    where F: FnOnce(fn(&u32), &i32)\n+{\n+}\n+\n+fn expect_free_supply_free_from_fn<'x>(x: &'x u32) {\n+    // Here, the type given for `'x` \"obscures\" a region from the\n+    // expected signature that is bound at closure level.\n+    with_closure_expecting_fn_with_free_region(|x: fn(&'x u32), y| {});\n+    //~^ ERROR mismatched types\n+    //~| ERROR mismatched types\n+}\n+\n+fn expect_free_supply_free_from_closure() {\n+    // A variant on the previous test. Here, the region `'a` will be\n+    // bound at the closure level, just as is expected, so no error\n+    // results.\n+    type Foo<'a> = fn(&'a u32);\n+    with_closure_expecting_fn_with_free_region(|_x: Foo<'_>, y| {});\n+}\n+\n+fn expect_free_supply_bound() {\n+    // Here, we are given a function whose region is bound at closure level,\n+    // but we expect one bound in the argument. Error results.\n+    with_closure_expecting_fn_with_free_region(|x: fn(&u32), y| {});\n+    //~^ ERROR type mismatch in closure arguments\n+}\n+\n+fn expect_bound_supply_free_from_fn<'x>(x: &'x u32) {\n+    // Here, we are given a `fn(&u32)` but we expect a `fn(&'x\n+    // u32)`. In principle, this could be ok, but we demand equality.\n+    with_closure_expecting_fn_with_bound_region(|x: fn(&'x u32), y| {});\n+    //~^ ERROR type mismatch in closure arguments\n+}\n+\n+fn expect_bound_supply_free_from_closure() {\n+    // A variant on the previous test. Here, the region `'a` will be\n+    // bound at the closure level, but we expect something bound at\n+    // the argument level.\n+    type Foo<'a> = fn(&'a u32);\n+    with_closure_expecting_fn_with_bound_region(|_x: Foo<'_>, y| {});\n+    //~^ ERROR type mismatch in closure arguments\n+}\n+\n+fn expect_bound_supply_bound<'x>(x: &'x u32) {\n+    // No error in this case. The supplied type supplies the bound\n+    // regions, and hence we are able to figure out the type of `y`\n+    // from the expected type\n+    with_closure_expecting_fn_with_bound_region(|x: for<'z> fn(&'z u32), y| {\n+    });\n+}\n+\n+fn main() { }"}, {"sha": "bef69a4b0b9f86c62e62c318e4c07b38c392a98b", "filename": "src/test/compile-fail/closure-expected-type/expect-infer-var-appearing-twice.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/666687a68cb9c42bf5eadcb2e5e447d7de5190d5/src%2Ftest%2Fcompile-fail%2Fclosure-expected-type%2Fexpect-infer-var-appearing-twice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/666687a68cb9c42bf5eadcb2e5e447d7de5190d5/src%2Ftest%2Fcompile-fail%2Fclosure-expected-type%2Fexpect-infer-var-appearing-twice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fclosure-expected-type%2Fexpect-infer-var-appearing-twice.rs?ref=666687a68cb9c42bf5eadcb2e5e447d7de5190d5", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn with_closure<F, A>(_: F)\n+    where F: FnOnce(A, A)\n+{\n+}\n+\n+fn a() {\n+    with_closure(|x: u32, y| {\n+        // We deduce type of `y` from `x`.\n+    });\n+}\n+\n+fn b() {\n+    // Here we take the supplied types, resulting in an error later on.\n+    with_closure(|x: u32, y: i32| {\n+        //~^ ERROR type mismatch in closure arguments\n+    });\n+}\n+\n+fn c() {\n+    with_closure(|x, y: i32| {\n+        // We deduce type of `x` from `y`.\n+    });\n+}\n+\n+fn main() { }"}, {"sha": "f8cb643c8d64659e8a0aea0f3db8014efd8ca42e", "filename": "src/test/compile-fail/closure-expected-type/expect-infer-var-supply-ty-with-bound-region.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/666687a68cb9c42bf5eadcb2e5e447d7de5190d5/src%2Ftest%2Fcompile-fail%2Fclosure-expected-type%2Fexpect-infer-var-supply-ty-with-bound-region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/666687a68cb9c42bf5eadcb2e5e447d7de5190d5/src%2Ftest%2Fcompile-fail%2Fclosure-expected-type%2Fexpect-infer-var-supply-ty-with-bound-region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fclosure-expected-type%2Fexpect-infer-var-supply-ty-with-bound-region.rs?ref=666687a68cb9c42bf5eadcb2e5e447d7de5190d5", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// must-compile-successfully\n+\n+fn with_closure<F, A>(_: F)\n+    where F: FnOnce(A, &u32)\n+{\n+}\n+\n+fn foo() {\n+    // This version works; we infer `A` to be `u32`, and take the type\n+    // of `y` to be `&u32`.\n+    with_closure(|x: u32, y| {});\n+}\n+\n+fn bar() {\n+    // This version also works.\n+    with_closure(|x: &u32, y| {});\n+}\n+\n+fn main() { }"}, {"sha": "d3c111c5daf158230f158dcb68a8bd281211f9b8", "filename": "src/test/compile-fail/closure-expected-type/expect-infer-var-supply-ty-with-free-region.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/666687a68cb9c42bf5eadcb2e5e447d7de5190d5/src%2Ftest%2Fcompile-fail%2Fclosure-expected-type%2Fexpect-infer-var-supply-ty-with-free-region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/666687a68cb9c42bf5eadcb2e5e447d7de5190d5/src%2Ftest%2Fcompile-fail%2Fclosure-expected-type%2Fexpect-infer-var-supply-ty-with-free-region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fclosure-expected-type%2Fexpect-infer-var-supply-ty-with-free-region.rs?ref=666687a68cb9c42bf5eadcb2e5e447d7de5190d5", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// must-compile-successfully\n+\n+fn with_closure<F, A>(_: F)\n+    where F: FnOnce(A, &u32)\n+{\n+}\n+\n+fn foo() {\n+    // This version works; we infer `A` to be `u32`, and take the type\n+    // of `y` to be `&u32`.\n+    with_closure(|x: u32, y| {});\n+}\n+\n+fn bar<'x>(x: &'x u32) {\n+    // Same.\n+    with_closure(|x: &'x u32, y| {});\n+}\n+\n+fn main() { }"}, {"sha": "9da12dc901fbaaa9d95c6750cdbcc4a9142f14b1", "filename": "src/test/compile-fail/closure-expected-type/expect-region-supply-region.rs", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/666687a68cb9c42bf5eadcb2e5e447d7de5190d5/src%2Ftest%2Fcompile-fail%2Fclosure-expected-type%2Fexpect-region-supply-region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/666687a68cb9c42bf5eadcb2e5e447d7de5190d5/src%2Ftest%2Fcompile-fail%2Fclosure-expected-type%2Fexpect-region-supply-region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fclosure-expected-type%2Fexpect-region-supply-region.rs?ref=666687a68cb9c42bf5eadcb2e5e447d7de5190d5", "patch": "@@ -0,0 +1,80 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(warnings)]\n+\n+fn closure_expecting_bound<F>(_: F)\n+    where F: FnOnce(&u32)\n+{\n+}\n+\n+fn closure_expecting_free<'a, F>(_: F)\n+    where F: FnOnce(&'a u32)\n+{\n+}\n+\n+fn expect_bound_supply_nothing() {\n+    // Because `x` is inferred to have a bound region, we cannot allow\n+    // it to escape into `f`:\n+    let mut f: Option<&u32> = None;\n+    closure_expecting_bound(|x| {\n+        f = Some(x); //~ ERROR E0495\n+    });\n+}\n+\n+fn expect_bound_supply_bound() {\n+    // Because `x` is inferred to have a bound region, we cannot allow\n+    // it to escape into `f`, even with an explicit type annotation on\n+    // closure:\n+    let mut f: Option<&u32> = None;\n+    closure_expecting_bound(|x: &u32| {\n+        f = Some(x); //~ ERROR E0495\n+    });\n+}\n+\n+fn expect_bound_supply_named<'x>() {\n+    let mut f: Option<&u32> = None;\n+\n+    // Here we give a type annotation that `x` should be free. We get\n+    // an error because of that.\n+    closure_expecting_bound(|x: &'x u32| {\n+        //~^ ERROR mismatched types\n+        //~| ERROR mismatched types\n+\n+        // And we still cannot let `x` escape into `f`.\n+        f = Some(x);\n+        //~^ ERROR cannot infer\n+    });\n+}\n+\n+fn expect_free_supply_nothing() {\n+    let mut f: Option<&u32> = None;\n+    closure_expecting_free(|x| f = Some(x)); // OK\n+}\n+\n+fn expect_free_supply_bound() {\n+    let mut f: Option<&u32> = None;\n+\n+    // Here, even though the annotation `&u32` could be seen as being\n+    // bound in the closure, we permit it to be defined as a free\n+    // region (which is inferred to something in the fn body).\n+    closure_expecting_free(|x: &u32| f = Some(x)); // OK\n+}\n+\n+fn expect_free_supply_named<'x>() {\n+    let mut f: Option<&u32> = None;\n+\n+    // Here, even though the annotation `&u32` could be seen as being\n+    // bound in the closure, we permit it to be defined as a free\n+    // region (which is inferred to something in the fn body).\n+    closure_expecting_free(|x: &'x u32| f = Some(x)); // OK\n+}\n+\n+fn main() { }"}, {"sha": "377eaadbd6af0d681b7779621d87cbdd1abe4d8a", "filename": "src/test/compile-fail/closure-expected-type/expect-two-infer-vars-supply-ty-with-bound-region.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/666687a68cb9c42bf5eadcb2e5e447d7de5190d5/src%2Ftest%2Fcompile-fail%2Fclosure-expected-type%2Fexpect-two-infer-vars-supply-ty-with-bound-region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/666687a68cb9c42bf5eadcb2e5e447d7de5190d5/src%2Ftest%2Fcompile-fail%2Fclosure-expected-type%2Fexpect-two-infer-vars-supply-ty-with-bound-region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fclosure-expected-type%2Fexpect-two-infer-vars-supply-ty-with-bound-region.rs?ref=666687a68cb9c42bf5eadcb2e5e447d7de5190d5", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn with_closure<F, A, B>(_: F)\n+    where F: FnOnce(A, B)\n+{\n+}\n+\n+fn a() {\n+    // Type of `y` is unconstrained.\n+    with_closure(|x: u32, y| {}); //~ ERROR E0282\n+}\n+\n+fn b() {\n+    with_closure(|x: u32, y: u32| {}); // OK\n+}\n+\n+fn c() {\n+    with_closure(|x: u32, y: u32| {}); // OK\n+}\n+\n+fn main() { }"}, {"sha": "a97ce4e8cbe5549326e128000b5e2e292c725047", "filename": "src/test/mir-opt/validate_1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/666687a68cb9c42bf5eadcb2e5e447d7de5190d5/src%2Ftest%2Fmir-opt%2Fvalidate_1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/666687a68cb9c42bf5eadcb2e5e447d7de5190d5/src%2Ftest%2Fmir-opt%2Fvalidate_1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fvalidate_1.rs?ref=666687a68cb9c42bf5eadcb2e5e447d7de5190d5", "patch": "@@ -62,7 +62,7 @@ fn main() {\n // fn main::{{closure}}(_1: &ReErased [closure@NodeId(50)], _2: &ReErased mut i32) -> i32 {\n //     ...\n //     bb0: {\n-//         Validate(Acquire, [_1: &ReFree(DefId { krate: CrateNum(0), index: DefIndex(1:11) => validate_1[317d]::main[0]::{{closure}}[0] }, BrEnv) [closure@NodeId(50)], _2: &ReFree(DefId { krate: CrateNum(0), index: DefIndex(1:11) => validate_1[317d]::main[0]::{{closure}}[0] }, BrAnon(1)) mut i32]);\n+//         Validate(Acquire, [_1: &ReFree(DefId { krate: CrateNum(0), index: DefIndex(1:11) => validate_1[317d]::main[0]::{{closure}}[0] }, BrEnv) [closure@NodeId(50)], _2: &ReFree(DefId { krate: CrateNum(0), index: DefIndex(1:11) => validate_1[317d]::main[0]::{{closure}}[0] }, BrAnon(0)) mut i32]);\n //         StorageLive(_3);\n //         Validate(Suspend(ReScope(Remainder(BlockRemainder { block: ItemLocalId(22), first_statement_index: 0 }))), [(*_2): i32]);\n //         _3 = &ReErased (*_2);"}, {"sha": "3585ac0b8be76529025ed7ab98a849a94b731cf4", "filename": "src/test/mir-opt/validate_4.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/666687a68cb9c42bf5eadcb2e5e447d7de5190d5/src%2Ftest%2Fmir-opt%2Fvalidate_4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/666687a68cb9c42bf5eadcb2e5e447d7de5190d5/src%2Ftest%2Fmir-opt%2Fvalidate_4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fvalidate_4.rs?ref=666687a68cb9c42bf5eadcb2e5e447d7de5190d5", "patch": "@@ -78,8 +78,8 @@ fn main() {\n // fn main::{{closure}}(_1: &ReErased [closure@NodeId(60)], _2: &ReErased mut i32) -> bool {\n //     ...\n //     bb0: {\n-//         Validate(Acquire, [_1: &ReFree(DefId { krate: CrateNum(0), index: DefIndex(1:10) => validate_4[317d]::main[0]::{{closure}}[0] }, BrEnv) [closure@NodeId(60)], _2: &ReFree(DefId { krate: CrateNum(0), index: DefIndex(1:10) => validate_4[317d]::main[0]::{{closure}}[0] }, BrAnon(1)) mut i32]);\n-//         Validate(Release, [_1: &ReFree(DefId { krate: CrateNum(0), index: DefIndex(1:10) => validate_4[317d]::main[0]::{{closure}}[0] }, BrEnv) [closure@NodeId(60)], _2: &ReFree(DefId { krate: CrateNum(0), index: DefIndex(1:10) => validate_4[317d]::main[0]::{{closure}}[0] }, BrAnon(1)) mut i32]);\n+//         Validate(Acquire, [_1: &ReFree(DefId { krate: CrateNum(0), index: DefIndex(1:10) => validate_4[317d]::main[0]::{{closure}}[0] }, BrEnv) [closure@NodeId(60)], _2: &ReFree(DefId { krate: CrateNum(0), index: DefIndex(1:10) => validate_4[317d]::main[0]::{{closure}}[0] }, BrAnon(0)) mut i32]);\n+//         Validate(Release, [_1: &ReFree(DefId { krate: CrateNum(0), index: DefIndex(1:10) => validate_4[317d]::main[0]::{{closure}}[0] }, BrEnv) [closure@NodeId(60)], _2: &ReFree(DefId { krate: CrateNum(0), index: DefIndex(1:10) => validate_4[317d]::main[0]::{{closure}}[0] }, BrAnon(0)) mut i32]);\n //         StorageLive(_3);\n //         ...\n //         _0 = const write_42(_3) -> bb1;"}, {"sha": "ae09d72942e55808e3ce1b9c60f9868014f6be49", "filename": "src/test/mir-opt/validate_5.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/666687a68cb9c42bf5eadcb2e5e447d7de5190d5/src%2Ftest%2Fmir-opt%2Fvalidate_5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/666687a68cb9c42bf5eadcb2e5e447d7de5190d5/src%2Ftest%2Fmir-opt%2Fvalidate_5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fvalidate_5.rs?ref=666687a68cb9c42bf5eadcb2e5e447d7de5190d5", "patch": "@@ -49,7 +49,7 @@ fn main() {\n // fn main::{{closure}}(_1: &ReErased [closure@NodeId(46)], _2: &ReErased mut i32) -> bool {\n //     ...\n //     bb0: {\n-//         Validate(Acquire, [_1: &ReFree(DefId { krate: CrateNum(0), index: DefIndex(1:9) => validate_5[317d]::main[0]::{{closure}}[0] }, BrEnv) [closure@NodeId(46)], _2: &ReFree(DefId { krate: CrateNum(0), index: DefIndex(1:9) => validate_5[317d]::main[0]::{{closure}}[0] }, BrAnon(1)) mut i32]);\n+//         Validate(Acquire, [_1: &ReFree(DefId { krate: CrateNum(0), index: DefIndex(1:9) => validate_5[317d]::main[0]::{{closure}}[0] }, BrEnv) [closure@NodeId(46)], _2: &ReFree(DefId { krate: CrateNum(0), index: DefIndex(1:9) => validate_5[317d]::main[0]::{{closure}}[0] }, BrAnon(0)) mut i32]);\n //         StorageLive(_3);\n //         StorageLive(_4);\n //         Validate(Suspend(ReScope(Node(ItemLocalId(9)))), [(*_2): i32]);"}, {"sha": "fd493e1ff37d6e6b31faa1cdca506d19ff99e6ff", "filename": "src/test/run-pass/closure-expected-type/README.md", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/666687a68cb9c42bf5eadcb2e5e447d7de5190d5/src%2Ftest%2Frun-pass%2Fclosure-expected-type%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/666687a68cb9c42bf5eadcb2e5e447d7de5190d5/src%2Ftest%2Frun-pass%2Fclosure-expected-type%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclosure-expected-type%2FREADME.md?ref=666687a68cb9c42bf5eadcb2e5e447d7de5190d5", "patch": "@@ -0,0 +1,8 @@\n+Some tests targeted at how we deduce the types of closure arguments.\n+This process is a result of some heuristics aimed at combining the\n+*expected type* we have with the *actual types* that we get from\n+inputs. This investigation was kicked off by #38714, which revealed\n+some pretty deep flaws in the ad-hoc way that we were doing things\n+before.\n+\n+See also `src/test/compile-fail/closure-expected-type`."}, {"sha": "8a90a491f7e58c51b8a8d763702feb4010da9f05", "filename": "src/test/run-pass/closure-expected-type/expect-infer-supply-two-infers.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/666687a68cb9c42bf5eadcb2e5e447d7de5190d5/src%2Ftest%2Frun-pass%2Fclosure-expected-type%2Fexpect-infer-supply-two-infers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/666687a68cb9c42bf5eadcb2e5e447d7de5190d5/src%2Ftest%2Frun-pass%2Fclosure-expected-type%2Fexpect-infer-supply-two-infers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclosure-expected-type%2Fexpect-infer-supply-two-infers.rs?ref=666687a68cb9c42bf5eadcb2e5e447d7de5190d5", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn with_closure<A, F>(_: F)\n+    where F: FnOnce(Vec<A>, A)\n+{\n+}\n+\n+fn expect_free_supply_free<'x>(x: &'x u32) {\n+    with_closure(|mut x: Vec<_>, y| {\n+        // Shows that the call to `x.push()` is influencing type of `y`...\n+        x.push(22_u32);\n+\n+        // ...since we now know the type of `y` and can resolve the method call.\n+        y.wrapping_add(1);\n+    });\n+}\n+\n+fn main() { }"}, {"sha": "a1d512105c9337c3523cac698254a370a72cee98", "filename": "src/test/run-pass/closure-expected-type/issue-38714.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/666687a68cb9c42bf5eadcb2e5e447d7de5190d5/src%2Ftest%2Frun-pass%2Fclosure-expected-type%2Fissue-38714.rs", "raw_url": "https://github.com/rust-lang/rust/raw/666687a68cb9c42bf5eadcb2e5e447d7de5190d5/src%2Ftest%2Frun-pass%2Fclosure-expected-type%2Fissue-38714.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclosure-expected-type%2Fissue-38714.rs?ref=666687a68cb9c42bf5eadcb2e5e447d7de5190d5", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct UsizeRef<'a> {\n+    a: &'a usize\n+}\n+\n+type RefTo = Box<for<'r> Fn(&'r Vec<usize>) -> UsizeRef<'r>>;\n+\n+fn ref_to<'a>(vec: &'a Vec<usize>) -> UsizeRef<'a> {\n+    UsizeRef{ a: &vec[0]}\n+}\n+\n+fn main() {\n+    // Regression test: this was causing ICEs; it should compile.\n+    let a: RefTo = Box::new(|vec: &Vec<usize>| {\n+        UsizeRef{ a: &vec[0] }\n+    });\n+}"}, {"sha": "0b930b338fd72bef8789051b01faf26a16baee3f", "filename": "src/test/run-pass/closure-expected-type/supply-just-return-type.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/666687a68cb9c42bf5eadcb2e5e447d7de5190d5/src%2Ftest%2Frun-pass%2Fclosure-expected-type%2Fsupply-just-return-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/666687a68cb9c42bf5eadcb2e5e447d7de5190d5/src%2Ftest%2Frun-pass%2Fclosure-expected-type%2Fsupply-just-return-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclosure-expected-type%2Fsupply-just-return-type.rs?ref=666687a68cb9c42bf5eadcb2e5e447d7de5190d5", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn with_closure<F, R>(f: F) -> Result<char, R>\n+    where F: FnOnce(&char) -> Result<char, R>,\n+{\n+    f(&'a')\n+}\n+\n+fn main() {\n+    // Test that supplying the `-> Result<char, ()>` manually here\n+    // (which is needed to constrain `R`) still allows us to figure\n+    // out that the type of `x` is `&'a char` where `'a` is bound in\n+    // the closure (if we didn't, we'd get a type-error because\n+    // `with_closure` requires a bound region).\n+    //\n+    // This pattern was found in the wild.\n+    let z = with_closure(|x| -> Result<char, ()> { Ok(*x) });\n+    assert_eq!(z.unwrap(), 'a');\n+\n+    // It also works with `_`:\n+    let z = with_closure(|x: _| -> Result<char, ()> { Ok(*x) });\n+    assert_eq!(z.unwrap(), 'a');\n+\n+    // It also works with `&_`:\n+    let z = with_closure(|x: &_| -> Result<char, ()> { Ok(*x) });\n+    assert_eq!(z.unwrap(), 'a');\n+}"}, {"sha": "15d8b393c152fc861cc8f65065927f0312219073", "filename": "src/test/run-pass/closure-expected-type/supply-nothing.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/666687a68cb9c42bf5eadcb2e5e447d7de5190d5/src%2Ftest%2Frun-pass%2Fclosure-expected-type%2Fsupply-nothing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/666687a68cb9c42bf5eadcb2e5e447d7de5190d5/src%2Ftest%2Frun-pass%2Fclosure-expected-type%2Fsupply-nothing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclosure-expected-type%2Fsupply-nothing.rs?ref=666687a68cb9c42bf5eadcb2e5e447d7de5190d5", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn with_closure<F>(f: F) -> u32\n+    where F: FnOnce(&u32, &u32) -> u32\n+{\n+    f(&22, &44)\n+}\n+\n+fn main() {\n+    let z = with_closure(|x, y| x + y).wrapping_add(1);\n+    assert_eq!(z, 22 + 44 + 1);\n+}"}, {"sha": "9de5e8fea0194e15b836a09593635e3eefdb2066", "filename": "src/test/ui/mismatched_types/closure-arg-count.stderr", "status": "modified", "additions": 1, "deletions": 18, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/666687a68cb9c42bf5eadcb2e5e447d7de5190d5/src%2Ftest%2Fui%2Fmismatched_types%2Fclosure-arg-count.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/666687a68cb9c42bf5eadcb2e5e447d7de5190d5/src%2Ftest%2Fui%2Fmismatched_types%2Fclosure-arg-count.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Fclosure-arg-count.stderr?ref=666687a68cb9c42bf5eadcb2e5e447d7de5190d5", "patch": "@@ -14,23 +14,6 @@ error[E0593]: closure is expected to take 2 arguments, but it takes 1 argument\n    |               |\n    |               expected closure that takes 2 arguments\n \n-error: non-reference pattern used to match a reference (see issue #42640)\n-  --> $DIR/closure-arg-count.rs:17:24\n-   |\n-17 |     [1, 2, 3].sort_by(|(tuple, tuple2)| panic!());\n-   |                        ^^^^^^^^^^^^^^^ help: consider using: `&(tuple, tuple2)`\n-   |\n-   = help: add #![feature(match_default_bindings)] to the crate attributes to enable\n-\n-error[E0308]: mismatched types\n-  --> $DIR/closure-arg-count.rs:17:24\n-   |\n-17 |     [1, 2, 3].sort_by(|(tuple, tuple2)| panic!());\n-   |                        ^^^^^^^^^^^^^^^ expected integral variable, found tuple\n-   |\n-   = note: expected type `{integer}`\n-              found type `(_, _)`\n-\n error[E0593]: closure is expected to take 2 arguments, but it takes 1 argument\n   --> $DIR/closure-arg-count.rs:17:15\n    |\n@@ -73,5 +56,5 @@ error[E0593]: closure is expected to take a single 2-tuple as argument, but it t\n    |                                                     |\n    |                                                     expected closure that takes a single 2-tuple as argument\n \n-error: aborting due to 9 previous errors\n+error: aborting due to 7 previous errors\n "}]}