{"sha": "7f826cb25ac3c1295a90bc8eb16e1cdf518fc6e1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdmODI2Y2IyNWFjM2MxMjk1YTkwYmM4ZWIxNmUxY2RmNTE4ZmM2ZTE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-09-20T04:46:45Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-09-20T04:46:45Z"}, "message": "auto merge of #9308 : ben0x539/rust/lexer-error-spans, r=alexcrichton\n\nPreviously, the lexer calling `rdr.fatal(...)` would report the span of\r\nthe last complete token, instead of a span within the erroneous token\r\n(besides one span fixed in 1ac90bb).\r\n\r\nThis branch adds wrappers around `rdr.fatal(...)` that sets the span\r\nexplicilty, so that all fatal errors in `libsyntax/parse/lexer.rs` now\r\nreport the offending code more precisely. A number of tests try to\r\nverify that, though the `compile-fail` testing setup can only check that\r\nthe spans are on the right lines, and the \"unterminated string/block\r\ncomment\" errors can't have the line marked at all, so that's incomplete.\r\n\r\nThis closes #9149.\r\n\r\nAlso, the lexer errors now report the offending code in the error message,\r\nnot just via the span, just like other errors do.", "tree": {"sha": "2be92973440fb858516695621584587bbe0afe15", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2be92973440fb858516695621584587bbe0afe15"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7f826cb25ac3c1295a90bc8eb16e1cdf518fc6e1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7f826cb25ac3c1295a90bc8eb16e1cdf518fc6e1", "html_url": "https://github.com/rust-lang/rust/commit/7f826cb25ac3c1295a90bc8eb16e1cdf518fc6e1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7f826cb25ac3c1295a90bc8eb16e1cdf518fc6e1/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "407d179f4e0b625e6911ebaf72c87cd35935fb06", "url": "https://api.github.com/repos/rust-lang/rust/commits/407d179f4e0b625e6911ebaf72c87cd35935fb06", "html_url": "https://github.com/rust-lang/rust/commit/407d179f4e0b625e6911ebaf72c87cd35935fb06"}, {"sha": "567c567b2dabbab9d74cf565b252e5024900e290", "url": "https://api.github.com/repos/rust-lang/rust/commits/567c567b2dabbab9d74cf565b252e5024900e290", "html_url": "https://github.com/rust-lang/rust/commit/567c567b2dabbab9d74cf565b252e5024900e290"}], "stats": {"total": 273, "additions": 247, "deletions": 26}, "files": [{"sha": "d3b0866d4a79c4635ab7325bc78a9f8625406935", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 91, "deletions": 26, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/7f826cb25ac3c1295a90bc8eb16e1cdf518fc6e1/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f826cb25ac3c1295a90bc8eb16e1cdf518fc6e1/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=7f826cb25ac3c1295a90bc8eb16e1cdf518fc6e1", "patch": "@@ -149,6 +149,46 @@ impl reader for TtReader {\n     fn dup(@mut self) -> @mut reader { dup_tt_reader(self) as @mut reader }\n }\n \n+// report a lexical error spanning [`from_pos`, `to_pos`)\n+fn fatal_span(rdr: @mut StringReader,\n+              from_pos: BytePos,\n+              to_pos: BytePos,\n+              m: ~str)\n+           -> ! {\n+    rdr.peek_span = codemap::mk_sp(from_pos, to_pos);\n+    rdr.fatal(m);\n+}\n+\n+// report a lexical error spanning [`from_pos`, `to_pos`), appending an\n+// escaped character to the error message\n+fn fatal_span_char(rdr: @mut StringReader,\n+                   from_pos: BytePos,\n+                   to_pos: BytePos,\n+                   m: ~str,\n+                   c: char)\n+                -> ! {\n+    let mut m = m;\n+    m.push_str(\": \");\n+    char::escape_default(c, |c| m.push_char(c));\n+    fatal_span(rdr, from_pos, to_pos, m);\n+}\n+\n+// report a lexical error spanning [`from_pos`, `to_pos`), appending the\n+// offending string to the error message\n+fn fatal_span_verbose(rdr: @mut StringReader,\n+                      from_pos: BytePos,\n+                      to_pos: BytePos,\n+                      m: ~str)\n+                   -> ! {\n+    let mut m = m;\n+    m.push_str(\": \");\n+    let s = rdr.src.slice(\n+                  byte_offset(rdr, from_pos).to_uint(),\n+                  byte_offset(rdr, to_pos).to_uint());\n+    m.push_str(s);\n+    fatal_span(rdr, from_pos, to_pos, m);\n+}\n+\n // EFFECT: advance peek_tok and peek_span to refer to the next token.\n // EFFECT: update the interner, maybe.\n fn string_advance_token(r: @mut StringReader) {\n@@ -327,7 +367,8 @@ fn consume_block_comment(rdr: @mut StringReader)\n             bump(rdr);\n         }\n         if is_eof(rdr) {\n-            rdr.fatal(~\"unterminated block doc-comment\");\n+            fatal_span(rdr, start_bpos, rdr.last_pos,\n+                       ~\"unterminated block doc-comment\");\n         } else {\n             bump(rdr);\n             bump(rdr);\n@@ -344,8 +385,12 @@ fn consume_block_comment(rdr: @mut StringReader)\n             }\n         }\n     } else {\n+        let start_bpos = rdr.last_pos - BytePos(2u);\n         loop {\n-            if is_eof(rdr) { rdr.fatal(~\"unterminated block comment\"); }\n+            if is_eof(rdr) {\n+                fatal_span(rdr, start_bpos, rdr.last_pos,\n+                           ~\"unterminated block comment\");\n+            }\n             if rdr.curr == '*' && nextch(rdr) == '/' {\n                 bump(rdr);\n                 bump(rdr);\n@@ -361,7 +406,7 @@ fn consume_block_comment(rdr: @mut StringReader)\n    if res.is_some() { res } else { consume_whitespace_and_comments(rdr) }\n }\n \n-fn scan_exponent(rdr: @mut StringReader) -> Option<~str> {\n+fn scan_exponent(rdr: @mut StringReader, start_bpos: BytePos) -> Option<~str> {\n     let mut c = rdr.curr;\n     let mut rslt = ~\"\";\n     if c == 'e' || c == 'E' {\n@@ -375,7 +420,10 @@ fn scan_exponent(rdr: @mut StringReader) -> Option<~str> {\n         let exponent = scan_digits(rdr, 10u);\n         if exponent.len() > 0u {\n             return Some(rslt + exponent);\n-        } else { rdr.fatal(~\"scan_exponent: bad fp literal\"); }\n+        } else {\n+            fatal_span(rdr, start_bpos, rdr.last_pos,\n+                       ~\"scan_exponent: bad fp literal\");\n+        }\n     } else { return None::<~str>; }\n }\n \n@@ -399,6 +447,7 @@ fn scan_number(c: char, rdr: @mut StringReader) -> token::Token {\n     let mut base = 10u;\n     let mut c = c;\n     let mut n = nextch(rdr);\n+    let start_bpos = rdr.last_pos;\n     if c == '0' && n == 'x' {\n         bump(rdr);\n         bump(rdr);\n@@ -442,11 +491,13 @@ fn scan_number(c: char, rdr: @mut StringReader) -> token::Token {\n                       else { either::Right(ast::ty_u64) };\n         }\n         if num_str.len() == 0u {\n-            rdr.fatal(~\"no valid digits found for number\");\n+            fatal_span(rdr, start_bpos, rdr.last_pos,\n+                       ~\"no valid digits found for number\");\n         }\n         let parsed = match from_str_radix::<u64>(num_str, base as uint) {\n             Some(p) => p,\n-            None => rdr.fatal(~\"int literal is too large\")\n+            None => fatal_span(rdr, start_bpos, rdr.last_pos,\n+                               ~\"int literal is too large\")\n         };\n \n         match tp {\n@@ -464,12 +515,14 @@ fn scan_number(c: char, rdr: @mut StringReader) -> token::Token {\n     }\n     if is_float {\n         match base {\n-          16u => rdr.fatal(~\"hexadecimal float literal is not supported\"),\n-          2u => rdr.fatal(~\"binary float literal is not supported\"),\n+          16u => fatal_span(rdr, start_bpos, rdr.last_pos,\n+                            ~\"hexadecimal float literal is not supported\"),\n+          2u => fatal_span(rdr, start_bpos, rdr.last_pos,\n+                           ~\"binary float literal is not supported\"),\n           _ => ()\n         }\n     }\n-    match scan_exponent(rdr) {\n+    match scan_exponent(rdr, start_bpos) {\n       Some(ref s) => {\n         is_float = true;\n         num_str.push_str(*s);\n@@ -507,11 +560,13 @@ fn scan_number(c: char, rdr: @mut StringReader) -> token::Token {\n         return token::LIT_FLOAT_UNSUFFIXED(str_to_ident(num_str));\n     } else {\n         if num_str.len() == 0u {\n-            rdr.fatal(~\"no valid digits found for number\");\n+            fatal_span(rdr, start_bpos, rdr.last_pos,\n+                       ~\"no valid digits found for number\");\n         }\n         let parsed = match from_str_radix::<u64>(num_str, base as uint) {\n             Some(p) => p,\n-            None => rdr.fatal(~\"int literal is too large\")\n+            None => fatal_span(rdr, start_bpos, rdr.last_pos,\n+                               ~\"int literal is too large\")\n         };\n \n         debug!(\"lexing %s as an unsuffixed integer literal\",\n@@ -523,19 +578,23 @@ fn scan_number(c: char, rdr: @mut StringReader) -> token::Token {\n fn scan_numeric_escape(rdr: @mut StringReader, n_hex_digits: uint) -> char {\n     let mut accum_int = 0;\n     let mut i = n_hex_digits;\n+    let start_bpos = rdr.last_pos;\n     while i != 0u {\n         let n = rdr.curr;\n-        bump(rdr);\n         if !is_hex_digit(n) {\n-            rdr.fatal(fmt!(\"illegal numeric character escape: %d\", n as int));\n+            fatal_span_char(rdr, rdr.last_pos, rdr.pos,\n+                            ~\"illegal character in numeric character escape\",\n+                            n);\n         }\n+        bump(rdr);\n         accum_int *= 16;\n         accum_int += hex_digit_val(n);\n         i -= 1u;\n     }\n     match char::from_u32(accum_int as u32) {\n         Some(x) => x,\n-        None => rdr.fatal(fmt!(\"illegal numeric character escape\"))\n+        None => fatal_span(rdr, start_bpos, rdr.last_pos,\n+                           ~\"illegal numeric character escape\")\n     }\n }\n \n@@ -691,6 +750,7 @@ fn next_token_inner(rdr: @mut StringReader) -> token::Token {\n         if c2 == '\\\\' {\n             // '\\X' for some X must be a character constant:\n             let escaped = rdr.curr;\n+            let escaped_pos = rdr.last_pos;\n             bump(rdr);\n             match escaped {\n               'n' => { c2 = '\\n'; }\n@@ -704,32 +764,39 @@ fn next_token_inner(rdr: @mut StringReader) -> token::Token {\n               'u' => { c2 = scan_numeric_escape(rdr, 4u); }\n               'U' => { c2 = scan_numeric_escape(rdr, 8u); }\n               c2 => {\n-                rdr.fatal(fmt!(\"unknown character escape: %d\", c2 as int));\n+                fatal_span_char(rdr, escaped_pos, rdr.last_pos,\n+                                ~\"unknown character escape\", c2);\n               }\n             }\n         }\n         if rdr.curr != '\\'' {\n-            rdr.fatal(~\"unterminated character constant\");\n+            fatal_span_verbose(rdr,\n+                               // Byte offsetting here is okay because the\n+                               // character before position `start` is an\n+                               // ascii single quote.\n+                               start - BytePos(1u),\n+                               rdr.last_pos,\n+                               ~\"unterminated character constant\");\n         }\n         bump(rdr); // advance curr past token\n         return token::LIT_CHAR(c2 as u32);\n       }\n       '\"' => {\n         let mut accum_str = ~\"\";\n-        let n = rdr.last_pos;\n+        let start_bpos = rdr.last_pos;\n         bump(rdr);\n         while rdr.curr != '\"' {\n             if is_eof(rdr) {\n-                do with_str_from(rdr, n) |s| {\n-                    rdr.fatal(fmt!(\"unterminated double quote string: %s\", s));\n-                }\n+                fatal_span(rdr, start_bpos, rdr.last_pos,\n+                           ~\"unterminated double quote string\");\n             }\n \n             let ch = rdr.curr;\n             bump(rdr);\n             match ch {\n               '\\\\' => {\n                 let escaped = rdr.curr;\n+                let escaped_pos = rdr.last_pos;\n                 bump(rdr);\n                 match escaped {\n                   'n' => accum_str.push_char('\\n'),\n@@ -750,7 +817,8 @@ fn next_token_inner(rdr: @mut StringReader) -> token::Token {\n                     accum_str.push_char(scan_numeric_escape(rdr, 8u));\n                   }\n                   c2 => {\n-                    rdr.fatal(fmt!(\"unknown string escape: %d\", c2 as int));\n+                    fatal_span_char(rdr, escaped_pos, rdr.last_pos,\n+                                    ~\"unknown string escape\", c2);\n                   }\n                 }\n               }\n@@ -786,11 +854,8 @@ fn next_token_inner(rdr: @mut StringReader) -> token::Token {\n       '^' => { return binop(rdr, token::CARET); }\n       '%' => { return binop(rdr, token::PERCENT); }\n       c => {\n-          // So the error span points to the unrecognized character\n-          rdr.peek_span = codemap::mk_sp(rdr.last_pos, rdr.pos);\n-          let mut cs = ~\"\";\n-          char::escape_default(c, |c| cs.push_char(c));\n-          rdr.fatal(fmt!(\"unknown start of token: %s\", cs));\n+          fatal_span_char(rdr, rdr.last_pos, rdr.pos,\n+                          ~\"unknown start of token\", c);\n       }\n     }\n }"}, {"sha": "5a5e9d7d8f23876a792d72ed5ca623b8ea52014d", "filename": "src/test/compile-fail/lex-bad-fp-lit.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7f826cb25ac3c1295a90bc8eb16e1cdf518fc6e1/src%2Ftest%2Fcompile-fail%2Flex-bad-fp-lit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f826cb25ac3c1295a90bc8eb16e1cdf518fc6e1/src%2Ftest%2Fcompile-fail%2Flex-bad-fp-lit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flex-bad-fp-lit.rs?ref=7f826cb25ac3c1295a90bc8eb16e1cdf518fc6e1", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+static f: float =\n+    1e+ //~ ERROR: scan_exponent: bad fp literal\n+;"}, {"sha": "457c6126c44a5959f0433e955fe573ed7efaaecf", "filename": "src/test/compile-fail/lex-hex-float-lit.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7f826cb25ac3c1295a90bc8eb16e1cdf518fc6e1/src%2Ftest%2Fcompile-fail%2Flex-hex-float-lit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f826cb25ac3c1295a90bc8eb16e1cdf518fc6e1/src%2Ftest%2Fcompile-fail%2Flex-hex-float-lit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flex-hex-float-lit.rs?ref=7f826cb25ac3c1295a90bc8eb16e1cdf518fc6e1", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+static f: float =\n+    0x539.0 //~ ERROR: hexadecimal float literal is not supported\n+;"}, {"sha": "fe46cec776dfa77a86a0bf8fc06d0bec2a2014b5", "filename": "src/test/compile-fail/lex-illegal-num-char-escape-2.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7f826cb25ac3c1295a90bc8eb16e1cdf518fc6e1/src%2Ftest%2Fcompile-fail%2Flex-illegal-num-char-escape-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f826cb25ac3c1295a90bc8eb16e1cdf518fc6e1/src%2Ftest%2Fcompile-fail%2Flex-illegal-num-char-escape-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flex-illegal-num-char-escape-2.rs?ref=7f826cb25ac3c1295a90bc8eb16e1cdf518fc6e1", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+static c: char =\n+    '\\Uffffffff' //~ ERROR: illegal numeric character escape\n+;"}, {"sha": "858afffb443f38a48c68bccc7d0cc5ca7e634c18", "filename": "src/test/compile-fail/lex-illegal-num-char-escape.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7f826cb25ac3c1295a90bc8eb16e1cdf518fc6e1/src%2Ftest%2Fcompile-fail%2Flex-illegal-num-char-escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f826cb25ac3c1295a90bc8eb16e1cdf518fc6e1/src%2Ftest%2Fcompile-fail%2Flex-illegal-num-char-escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flex-illegal-num-char-escape.rs?ref=7f826cb25ac3c1295a90bc8eb16e1cdf518fc6e1", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+static c: char =\n+    '\\u539_' //~ ERROR: illegal character in numeric character escape\n+;"}, {"sha": "39d1cba64b08bce68eff5c8dfb0f41fbb03ae688", "filename": "src/test/compile-fail/lex-int-lit-too-large-2.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7f826cb25ac3c1295a90bc8eb16e1cdf518fc6e1/src%2Ftest%2Fcompile-fail%2Flex-int-lit-too-large-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f826cb25ac3c1295a90bc8eb16e1cdf518fc6e1/src%2Ftest%2Fcompile-fail%2Flex-int-lit-too-large-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flex-int-lit-too-large-2.rs?ref=7f826cb25ac3c1295a90bc8eb16e1cdf518fc6e1", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+static i: int =\n+    99999999999999999999999999999999u32 //~ ERROR: int literal is too large\n+;"}, {"sha": "6343be651fa5961d3ece0c02ad1067a008786a3a", "filename": "src/test/compile-fail/lex-int-lit-too-large.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7f826cb25ac3c1295a90bc8eb16e1cdf518fc6e1/src%2Ftest%2Fcompile-fail%2Flex-int-lit-too-large.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f826cb25ac3c1295a90bc8eb16e1cdf518fc6e1/src%2Ftest%2Fcompile-fail%2Flex-int-lit-too-large.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flex-int-lit-too-large.rs?ref=7f826cb25ac3c1295a90bc8eb16e1cdf518fc6e1", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+static i: int =\n+    99999999999999999999999999999999 //~ ERROR: int literal is too large\n+;"}, {"sha": "549dbf5bc8c6c0f1ff8bdd830010c642272f124d", "filename": "src/test/compile-fail/lex-no-valid-digits-2.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7f826cb25ac3c1295a90bc8eb16e1cdf518fc6e1/src%2Ftest%2Fcompile-fail%2Flex-no-valid-digits-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f826cb25ac3c1295a90bc8eb16e1cdf518fc6e1/src%2Ftest%2Fcompile-fail%2Flex-no-valid-digits-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flex-no-valid-digits-2.rs?ref=7f826cb25ac3c1295a90bc8eb16e1cdf518fc6e1", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+static i: int =\n+    0xu32 //~ ERROR: no valid digits\n+;"}, {"sha": "6a5b8e93f010a5f6b1ab21a7b3b2f40360c8c613", "filename": "src/test/compile-fail/lex-no-valid-digits.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7f826cb25ac3c1295a90bc8eb16e1cdf518fc6e1/src%2Ftest%2Fcompile-fail%2Flex-no-valid-digits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f826cb25ac3c1295a90bc8eb16e1cdf518fc6e1/src%2Ftest%2Fcompile-fail%2Flex-no-valid-digits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flex-no-valid-digits.rs?ref=7f826cb25ac3c1295a90bc8eb16e1cdf518fc6e1", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+static i: int =\n+    0x //~ ERROR: no valid digits\n+;"}, {"sha": "f2445c2b60ebaf7c100605e7e833fcb75bedfb25", "filename": "src/test/compile-fail/lex-unknown-char-escape.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7f826cb25ac3c1295a90bc8eb16e1cdf518fc6e1/src%2Ftest%2Fcompile-fail%2Flex-unknown-char-escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f826cb25ac3c1295a90bc8eb16e1cdf518fc6e1/src%2Ftest%2Fcompile-fail%2Flex-unknown-char-escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flex-unknown-char-escape.rs?ref=7f826cb25ac3c1295a90bc8eb16e1cdf518fc6e1", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+static c: char =\n+    '\\\u25cf' //~ ERROR: unknown character escape\n+;"}, {"sha": "1bb682303451bd30c36864458cabb741ed275b55", "filename": "src/test/compile-fail/lex-unknown-start-tok.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7f826cb25ac3c1295a90bc8eb16e1cdf518fc6e1/src%2Ftest%2Fcompile-fail%2Flex-unknown-start-tok.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f826cb25ac3c1295a90bc8eb16e1cdf518fc6e1/src%2Ftest%2Fcompile-fail%2Flex-unknown-start-tok.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flex-unknown-start-tok.rs?ref=7f826cb25ac3c1295a90bc8eb16e1cdf518fc6e1", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    \u25cf //~ ERROR: unknown start of token\n+}"}, {"sha": "f7809b02b0be34a3405f3ba51784ce77ae2cd668", "filename": "src/test/compile-fail/lex-unknown-str-escape.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7f826cb25ac3c1295a90bc8eb16e1cdf518fc6e1/src%2Ftest%2Fcompile-fail%2Flex-unknown-str-escape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f826cb25ac3c1295a90bc8eb16e1cdf518fc6e1/src%2Ftest%2Fcompile-fail%2Flex-unknown-str-escape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flex-unknown-str-escape.rs?ref=7f826cb25ac3c1295a90bc8eb16e1cdf518fc6e1", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+static s: &'static str =\n+    \"\\\u25cf\" //~ ERROR: unknown string escape\n+;"}, {"sha": "551360ff9e095b425b94f748100f3f6092b65f23", "filename": "src/test/compile-fail/lex-unterminated-char-const.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7f826cb25ac3c1295a90bc8eb16e1cdf518fc6e1/src%2Ftest%2Fcompile-fail%2Flex-unterminated-char-const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f826cb25ac3c1295a90bc8eb16e1cdf518fc6e1/src%2Ftest%2Fcompile-fail%2Flex-unterminated-char-const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flex-unterminated-char-const.rs?ref=7f826cb25ac3c1295a90bc8eb16e1cdf518fc6e1", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+static c: char =\n+    '\u25cf  //~ ERROR: unterminated character constant\n+;"}]}