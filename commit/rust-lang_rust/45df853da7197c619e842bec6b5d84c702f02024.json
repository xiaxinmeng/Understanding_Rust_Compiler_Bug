{"sha": "45df853da7197c619e842bec6b5d84c702f02024", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ1ZGY4NTNkYTcxOTdjNjE5ZTg0MmJlYzZiNWQ4NGM3MDJmMDIwMjQ=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-02-07T13:22:20Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-02-07T13:22:20Z"}, "message": "cleanup buggy closure dispatch code", "tree": {"sha": "e1158e13d5399703cf636d7742f53de09b9fa7eb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e1158e13d5399703cf636d7742f53de09b9fa7eb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/45df853da7197c619e842bec6b5d84c702f02024", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/45df853da7197c619e842bec6b5d84c702f02024", "html_url": "https://github.com/rust-lang/rust/commit/45df853da7197c619e842bec6b5d84c702f02024", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/45df853da7197c619e842bec6b5d84c702f02024/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5118aadee2c45352bea4357649cae682a3ded452", "url": "https://api.github.com/repos/rust-lang/rust/commits/5118aadee2c45352bea4357649cae682a3ded452", "html_url": "https://github.com/rust-lang/rust/commit/5118aadee2c45352bea4357649cae682a3ded452"}], "stats": {"total": 303, "additions": 255, "deletions": 48}, "files": [{"sha": "e0434c48e51b87a2d26410b8ad474e85a2754f13", "filename": "src/error.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/45df853da7197c619e842bec6b5d84c702f02024/src%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45df853da7197c619e842bec6b5d84c702f02024/src%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ferror.rs?ref=45df853da7197c619e842bec6b5d84c702f02024", "patch": "@@ -3,7 +3,7 @@ use std::fmt;\n use rustc::mir;\n use rustc::ty::{BareFnTy, Ty, FnSig, layout};\n use syntax::abi::Abi;\n-use memory::Pointer;\n+use memory::{Pointer, Function};\n use rustc_const_math::ConstMathErr;\n use syntax::codemap::Span;\n \n@@ -53,6 +53,9 @@ pub enum EvalError<'tcx> {\n     DeallocatedFrozenMemory,\n     Layout(layout::LayoutError<'tcx>),\n     Unreachable,\n+    ExpectedConcreteFunction(Function<'tcx>),\n+    ExpectedDropGlue(Function<'tcx>),\n+    ManuallyCalledDropGlue,\n }\n \n pub type EvalResult<'tcx, T = ()> = Result<T, EvalError<'tcx>>;\n@@ -125,6 +128,12 @@ impl<'tcx> Error for EvalError<'tcx> {\n                 \"attempted to get length of a null terminated string, but no null found before end of allocation\",\n             EvalError::Unreachable =>\n                 \"entered unreachable code\",\n+            EvalError::ExpectedConcreteFunction(_) =>\n+                \"tried to use glue function as function\",\n+            EvalError::ExpectedDropGlue(_) =>\n+                \"tried to use non-drop-glue function as drop glue\",\n+            EvalError::ManuallyCalledDropGlue =>\n+                \"tried to manually invoke drop glue\",\n         }\n     }\n "}, {"sha": "d372f37698d739ecf4ba200368429c378d1c3ed0", "filename": "src/eval_context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/45df853da7197c619e842bec6b5d84c702f02024/src%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45df853da7197c619e842bec6b5d84c702f02024/src%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval_context.rs?ref=45df853da7197c619e842bec6b5d84c702f02024", "patch": "@@ -659,9 +659,9 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                         ty::TyFnPtr(unsafe_fn_ty) => {\n                             let src = self.eval_operand(operand)?;\n                             let ptr = src.read_ptr(&self.memory)?;\n-                            let (def_id, substs, _, _) = self.memory.get_fn(ptr.alloc_id)?;\n+                            let fn_def = self.memory.get_fn(ptr.alloc_id)?.expect_concrete()?;\n                             let unsafe_fn_ty = self.tcx.erase_regions(&unsafe_fn_ty);\n-                            let fn_ptr = self.memory.create_fn_ptr(self.tcx, def_id, substs, unsafe_fn_ty);\n+                            let fn_ptr = self.memory.create_fn_ptr(self.tcx, fn_def.def_id, fn_def.substs, unsafe_fn_ty);\n                             self.write_value(Value::ByVal(PrimVal::Ptr(fn_ptr)), dest, dest_ty)?;\n                         },\n                         ref other => bug!(\"fn to unsafe fn cast on {:?}\", other),"}, {"sha": "3b7356cf06f9e6f2fa292a5484f98a9e7c927f32", "filename": "src/memory.rs", "status": "modified", "additions": 99, "deletions": 25, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/45df853da7197c619e842bec6b5d84c702f02024/src%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45df853da7197c619e842bec6b5d84c702f02024/src%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmemory.rs?ref=45df853da7197c619e842bec6b5d84c702f02024", "patch": "@@ -94,14 +94,47 @@ impl Pointer {\n     }\n }\n \n-#[derive(Debug, Clone, Hash, Eq, PartialEq)]\n-struct FunctionDefinition<'tcx> {\n+#[derive(Debug, Copy, Clone, Hash, Eq, PartialEq)]\n+/// Identifies a specific monomorphized function\n+pub struct FunctionDefinition<'tcx> {\n     pub def_id: DefId,\n     pub substs: &'tcx Substs<'tcx>,\n     pub abi: Abi,\n     pub sig: &'tcx ty::FnSig<'tcx>,\n }\n \n+/// Either a concrete function, or a glue function\n+#[derive(Debug, Copy, Clone, Hash, Eq, PartialEq)]\n+pub enum Function<'tcx> {\n+    /// A function or method created by compiling code\n+    Concrete(FunctionDefinition<'tcx>),\n+    /// Glue required to call a regular function through a Fn(Mut|Once) trait object\n+    FnDefAsTraitObject(FunctionDefinition<'tcx>),\n+    /// Glue required to call the actual drop impl's `drop` method.\n+    /// Drop glue takes the `self` by value, while `Drop::drop` take `&mut self`\n+    DropGlue(FunctionDefinition<'tcx>),\n+    /// Glue required to treat the ptr part of a fat pointer\n+    /// as a function pointer\n+    FnPtrAsTraitObject(&'tcx ty::FnSig<'tcx>),\n+    /// Glue for Closures\n+    Closure(FunctionDefinition<'tcx>),\n+}\n+\n+impl<'tcx> Function<'tcx> {\n+    pub fn expect_concrete(self) -> EvalResult<'tcx, FunctionDefinition<'tcx>> {\n+        match self {\n+            Function::Concrete(fn_def) => Ok(fn_def),\n+            other => Err(EvalError::ExpectedConcreteFunction(other)),\n+        }\n+    }\n+    pub fn expect_drop_glue(self) -> EvalResult<'tcx, FunctionDefinition<'tcx>> {\n+        match self {\n+            Function::DropGlue(fn_def) => Ok(fn_def),\n+            other => Err(EvalError::ExpectedDropGlue(other)),\n+        }\n+    }\n+}\n+\n ////////////////////////////////////////////////////////////////////////////////\n // Top-level interpreter memory\n ////////////////////////////////////////////////////////////////////////////////\n@@ -115,9 +148,9 @@ pub struct Memory<'a, 'tcx> {\n     memory_size: u64,\n     /// Function \"allocations\". They exist solely so pointers have something to point to, and\n     /// we can figure out what they point to.\n-    functions: HashMap<AllocId, FunctionDefinition<'tcx>>,\n+    functions: HashMap<AllocId, Function<'tcx>>,\n     /// Inverse map of `functions` so we don't allocate a new pointer every time we need one\n-    function_alloc_cache: HashMap<FunctionDefinition<'tcx>, AllocId>,\n+    function_alloc_cache: HashMap<Function<'tcx>, AllocId>,\n     next_id: AllocId,\n     pub layout: &'a TargetDataLayout,\n     /// List of memory regions containing packed structures\n@@ -160,35 +193,61 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n             abi: fn_ty.abi,\n             sig: fn_ty.sig,\n         });\n-        self.create_fn_alloc(FunctionDefinition {\n+        self.create_fn_alloc(Function::Closure(FunctionDefinition {\n             def_id,\n             substs: substs.substs,\n             abi: fn_ty.abi,\n             // FIXME: why doesn't this compile?\n             //sig: tcx.erase_late_bound_regions(&fn_ty.sig),\n             sig: fn_ty.sig.skip_binder(),\n-        })\n+        }))\n+    }\n+\n+    pub fn create_fn_as_trait_glue(&mut self, _tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId, substs: &'tcx Substs<'tcx>, fn_ty: &'tcx BareFnTy<'tcx>) -> Pointer {\n+        self.create_fn_alloc(Function::FnDefAsTraitObject(FunctionDefinition {\n+            def_id,\n+            substs,\n+            abi: fn_ty.abi,\n+            // FIXME: why doesn't this compile?\n+            //sig: tcx.erase_late_bound_regions(&fn_ty.sig),\n+            sig: fn_ty.sig.skip_binder(),\n+        }))\n+    }\n+\n+    pub fn create_fn_ptr_as_trait_glue(&mut self, fn_ty: &'tcx BareFnTy<'tcx>) -> Pointer {\n+        self.create_fn_alloc(Function::FnPtrAsTraitObject(fn_ty.sig.skip_binder()))\n+    }\n+\n+    pub fn create_drop_glue(&mut self, _tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId, substs: &'tcx Substs<'tcx>, fn_ty: &'tcx BareFnTy<'tcx>) -> Pointer {\n+        self.create_fn_alloc(Function::DropGlue(FunctionDefinition {\n+            def_id,\n+            substs,\n+            abi: fn_ty.abi,\n+            // FIXME: why doesn't this compile?\n+            //sig: tcx.erase_late_bound_regions(&fn_ty.sig),\n+            sig: fn_ty.sig.skip_binder(),\n+        }))\n     }\n \n     pub fn create_fn_ptr(&mut self, _tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId, substs: &'tcx Substs<'tcx>, fn_ty: &'tcx BareFnTy<'tcx>) -> Pointer {\n-        self.create_fn_alloc(FunctionDefinition {\n+        self.create_fn_alloc(Function::Concrete(FunctionDefinition {\n             def_id,\n             substs,\n             abi: fn_ty.abi,\n             // FIXME: why doesn't this compile?\n             //sig: tcx.erase_late_bound_regions(&fn_ty.sig),\n             sig: fn_ty.sig.skip_binder(),\n-        })\n+        }))\n     }\n \n-    fn create_fn_alloc(&mut self, def: FunctionDefinition<'tcx>) -> Pointer {\n+    fn create_fn_alloc(&mut self, def: Function<'tcx>) -> Pointer {\n         if let Some(&alloc_id) = self.function_alloc_cache.get(&def) {\n             return Pointer::new(alloc_id, 0);\n         }\n         let id = self.next_id;\n         debug!(\"creating fn ptr: {}\", id);\n         self.next_id.0 += 1;\n-        self.functions.insert(id, def.clone());\n+        self.functions.insert(id, def);\n         self.function_alloc_cache.insert(def, id);\n         Pointer::new(id, 0)\n     }\n@@ -381,15 +440,10 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         }\n     }\n \n-    pub fn get_fn(&self, id: AllocId) -> EvalResult<'tcx, (DefId, &'tcx Substs<'tcx>, Abi, &'tcx ty::FnSig<'tcx>)> {\n+    pub fn get_fn(&self, id: AllocId) -> EvalResult<'tcx, Function<'tcx>> {\n         debug!(\"reading fn ptr: {}\", id);\n         match self.functions.get(&id) {\n-            Some(&FunctionDefinition {\n-                def_id,\n-                substs,\n-                abi,\n-                sig,\n-            }) => Ok((def_id, substs, abi, sig)),\n+            Some(&fndef) => Ok(fndef),\n             None => match self.alloc_map.get(&id) {\n                 Some(_) => Err(EvalError::ExecuteMemory),\n                 None => Err(EvalError::InvalidFunctionPointer),\n@@ -418,14 +472,24 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n \n             let alloc = match (self.alloc_map.get(&id), self.functions.get(&id)) {\n                 (Some(a), None) => a,\n-                (None, Some(fn_def)) => {\n-                    let name = ty::tls::with(|tcx| tcx.item_path_str(fn_def.def_id));\n-                    let abi = if fn_def.abi == Abi::Rust {\n-                        format!(\"\")\n-                    } else {\n-                        format!(\"extern {} \", fn_def.abi)\n-                    };\n-                    trace!(\"{} function pointer: {}: {}{}\", msg, name, abi, fn_def.sig);\n+                (None, Some(&Function::Concrete(fn_def))) => {\n+                    trace!(\"{} {}\", msg, dump_fn_def(fn_def));\n+                    continue;\n+                },\n+                (None, Some(&Function::DropGlue(fn_def))) => {\n+                    trace!(\"{} drop glue for {}\", msg, dump_fn_def(fn_def));\n+                    continue;\n+                },\n+                (None, Some(&Function::FnDefAsTraitObject(fn_def))) => {\n+                    trace!(\"{} fn as Fn glue for {}\", msg, dump_fn_def(fn_def));\n+                    continue;\n+                },\n+                (None, Some(&Function::FnPtrAsTraitObject(fn_def))) => {\n+                    trace!(\"{} fn ptr as Fn glue (signature: {:?})\", msg, fn_def);\n+                    continue;\n+                },\n+                (None, Some(&Function::Closure(fn_def))) => {\n+                    trace!(\"{} closure glue for {}\", msg, dump_fn_def(fn_def));\n                     continue;\n                 },\n                 (None, None) => {\n@@ -476,6 +540,16 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n     }\n }\n \n+fn dump_fn_def<'tcx>(fn_def: FunctionDefinition<'tcx>) -> String {\n+    let name = ty::tls::with(|tcx| tcx.item_path_str(fn_def.def_id));\n+    let abi = if fn_def.abi == Abi::Rust {\n+        format!(\"\")\n+    } else {\n+        format!(\"extern {} \", fn_def.abi)\n+    };\n+    format!(\"function pointer: {}: {}{}\", name, abi, fn_def.sig)\n+}\n+\n /// Byte accessors\n impl<'a, 'tcx> Memory<'a, 'tcx> {\n     fn get_bytes_unchecked(&self, ptr: Pointer, size: u64, align: u64) -> EvalResult<'tcx, &[u8]> {"}, {"sha": "d813e13c48e13640987032d66a18fdce756ab894", "filename": "src/terminator/mod.rs", "status": "modified", "additions": 34, "deletions": 17, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/45df853da7197c619e842bec6b5d84c702f02024/src%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45df853da7197c619e842bec6b5d84c702f02024/src%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fterminator%2Fmod.rs?ref=45df853da7197c619e842bec6b5d84c702f02024", "patch": "@@ -11,7 +11,7 @@ use syntax::{ast, attr, abi};\n use error::{EvalError, EvalResult};\n use eval_context::{EvalContext, IntegerExt, StackPopCleanup, monomorphize_field_ty, is_inhabited};\n use lvalue::{Lvalue, LvalueExtra};\n-use memory::Pointer;\n+use memory::{Pointer, FunctionDefinition, Function};\n use value::PrimVal;\n use value::Value;\n \n@@ -89,7 +89,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 match func_ty.sty {\n                     ty::TyFnPtr(bare_fn_ty) => {\n                         let fn_ptr = self.eval_operand_to_primval(func)?.to_ptr()?;\n-                        let (def_id, substs, abi, sig) = self.memory.get_fn(fn_ptr.alloc_id)?;\n+                        let FunctionDefinition {def_id, substs, abi, sig} = self.memory.get_fn(fn_ptr.alloc_id)?.expect_concrete()?;\n                         let bare_sig = self.tcx.erase_late_bound_regions_and_normalize(&bare_fn_ty.sig);\n                         let bare_sig = self.tcx.erase_regions(&bare_sig);\n                         // transmuting function pointers in miri is fine as long as the number of\n@@ -314,9 +314,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n                 let arg_locals = self.frame().mir.args_iter();\n                 // FIXME: impl ExactSizeIterator and use args_locals.len()\n-                // FIXME: last-use-in-cap-clause works by chance, insert some arguments and it will fail\n-                // we currently write the first argument (unit) to the return field (unit)\n-                //assert_eq!(self.frame().mir.args_iter().count(), args.len());\n+                assert_eq!(arg_locals.size_hint().0, args.len());\n+                assert_eq!(arg_locals.size_hint().1, Some(args.len()));\n                 for (arg_local, (arg_val, arg_ty)) in arg_locals.zip(args) {\n                     let dest = self.eval_lvalue(&mir::Lvalue::Local(arg_local))?;\n                     self.write_value(arg_val, dest, arg_ty)?;\n@@ -635,24 +634,42 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let idx = idx + 3;\n                 let offset = idx * self.memory.pointer_size();\n                 let fn_ptr = self.memory.read_ptr(vtable.offset(offset))?;\n-                let (def_id, substs, abi, sig) = self.memory.get_fn(fn_ptr.alloc_id)?;\n                 trace!(\"args: {:#?}\", args);\n-                trace!(\"sig: {:#?}\", sig);\n-                if abi != abi::Abi::RustCall && args.len() == 2 {\n-                    if let ty::TyTuple(wrapped_args) = args[1].1.sty {\n-                        assert_eq!(sig.inputs(), &wrapped_args[..]);\n+                match self.memory.get_fn(fn_ptr.alloc_id)? {\n+                    Function::FnDefAsTraitObject(fn_def) => {\n+                        trace!(\"sig: {:#?}\", fn_def.sig);\n+                        assert!(fn_def.abi != abi::Abi::RustCall);\n+                        assert_eq!(args.len(), 2);\n                         // a function item turned into a closure trait object\n                         // the first arg is just there to give use the vtable\n                         args.remove(0);\n                         self.unpack_fn_args(args)?;\n-                        return Ok((def_id, substs, Vec::new()));\n+                        Ok((fn_def.def_id, fn_def.substs, Vec::new()))\n+                    },\n+                    Function::DropGlue(_) => Err(EvalError::ManuallyCalledDropGlue),\n+                    Function::Concrete(fn_def) => {\n+                        trace!(\"sig: {:#?}\", fn_def.sig);\n+                        args[0] = (\n+                            Value::ByVal(PrimVal::Ptr(self_ptr)),\n+                            fn_def.sig.inputs()[0],\n+                        );\n+                        Ok((fn_def.def_id, fn_def.substs, Vec::new()))\n+                    },\n+                    Function::Closure(fn_def) => {\n+                        self.unpack_fn_args(args)?;\n+                        Ok((fn_def.def_id, fn_def.substs, Vec::new()))\n+                    }\n+                    Function::FnPtrAsTraitObject(sig) => {\n+                        trace!(\"sig: {:#?}\", sig);\n+                        // the first argument was the fat ptr\n+                        args.remove(0);\n+                        self.unpack_fn_args(args)?;\n+                        let fn_ptr = self.memory.read_ptr(self_ptr)?;\n+                        let fn_def = self.memory.get_fn(fn_ptr.alloc_id)?.expect_concrete()?;\n+                        assert_eq!(sig, fn_def.sig);\n+                        Ok((fn_def.def_id, fn_def.substs, Vec::new()))\n                     }\n                 }\n-                args[0] = (\n-                    Value::ByVal(PrimVal::Ptr(self_ptr)),\n-                    sig.inputs()[0],\n-                );\n-                Ok((def_id, substs, Vec::new()))\n             },\n             vtable => bug!(\"resolved vtable bad vtable {:?} in trans\", vtable),\n         }\n@@ -785,7 +802,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let drop_fn = self.memory.read_ptr(vtable)?;\n                 // some values don't need to call a drop impl, so the value is null\n                 if drop_fn != Pointer::from_int(0) {\n-                    let (def_id, substs, _abi, sig) = self.memory.get_fn(drop_fn.alloc_id)?;\n+                    let FunctionDefinition {def_id, substs, sig, ..} = self.memory.get_fn(drop_fn.alloc_id)?.expect_drop_glue()?;\n                     let real_ty = sig.inputs()[0];\n                     self.drop(Lvalue::from_ptr(ptr), real_ty, drop)?;\n                     drop.push((def_id, Value::ByVal(PrimVal::Ptr(ptr)), substs));"}, {"sha": "fb9ec7124cca3500621ea22fd19b7887e8c94a37", "filename": "src/vtable.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/45df853da7197c619e842bec6b5d84c702f02024/src%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45df853da7197c619e842bec6b5d84c702f02024/src%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvtable.rs?ref=45df853da7197c619e842bec6b5d84c702f02024", "patch": "@@ -55,12 +55,16 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     vec![Some(self.memory.create_closure_ptr(self.tcx, closure_def_id, substs, closure_type))].into_iter()\n                 }\n \n+                // turn a function definition into a Fn trait object\n                 traits::VtableFnPointer(traits::VtableFnPointerData { fn_ty, .. }) => {\n                     match fn_ty.sty {\n                         ty::TyFnDef(did, substs, bare_fn_ty) => {\n-                            vec![Some(self.memory.create_fn_ptr(self.tcx, did, substs, bare_fn_ty))].into_iter()\n+                            vec![Some(self.memory.create_fn_as_trait_glue(self.tcx, did, substs, bare_fn_ty))].into_iter()\n                         },\n-                        _ => bug!(\"bad VtableFnPointer fn_ty: {:?}\", fn_ty),\n+                        ty::TyFnPtr(bare_fn_ty) => {\n+                            vec![Some(self.memory.create_fn_ptr_as_trait_glue(bare_fn_ty))].into_iter()\n+                        },\n+                        _ => bug!(\"bad VtableFnPointer fn_ty: {:#?}\", fn_ty.sty),\n                     }\n                 }\n \n@@ -94,7 +98,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     ty::TyFnDef(_, _, fn_ty) => self.tcx.erase_regions(&fn_ty),\n                     _ => bug!(\"drop method is not a TyFnDef\"),\n                 };\n-                let fn_ptr = self.memory.create_fn_ptr(self.tcx, drop_def_id, substs, fn_ty);\n+                let fn_ptr = self.memory.create_drop_glue(self.tcx, drop_def_id, substs, fn_ty);\n                 self.memory.write_ptr(vtable, fn_ptr)?;\n             }\n         }"}, {"sha": "24ae1f35bb60ba828633354b687728b9fc69f7ac", "filename": "tests/run-pass/fn_ptr_as_closure_trait_object.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/45df853da7197c619e842bec6b5d84c702f02024/tests%2Frun-pass%2Ffn_ptr_as_closure_trait_object.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45df853da7197c619e842bec6b5d84c702f02024/tests%2Frun-pass%2Ffn_ptr_as_closure_trait_object.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Ffn_ptr_as_closure_trait_object.rs?ref=45df853da7197c619e842bec6b5d84c702f02024", "patch": "@@ -0,0 +1,15 @@\n+fn foo() {}\n+fn bar(u: u32) { assert_eq!(u, 42); }\n+fn baa(u: u32, f: f32) {\n+    assert_eq!(u, 42);\n+    assert_eq!(f, 3.141);\n+}\n+\n+fn main() {\n+    let f: &Fn() = &(foo as fn());\n+    f();\n+    let f: &Fn(u32) = &(bar as fn(u32));\n+    f(42);\n+    let f: &Fn(u32, f32) = &(baa as fn(u32, f32));\n+    f(42, 3.141);\n+}"}, {"sha": "36155297e32f0224f9d9ef637944b0b3497daf3c", "filename": "tests/run-pass/mir_coercions.rs", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/45df853da7197c619e842bec6b5d84c702f02024/tests%2Frun-pass%2Fmir_coercions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45df853da7197c619e842bec6b5d84c702f02024/tests%2Frun-pass%2Fmir_coercions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fmir_coercions.rs?ref=45df853da7197c619e842bec6b5d84c702f02024", "patch": "@@ -0,0 +1,80 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(coerce_unsized, unsize)]\n+\n+use std::ops::CoerceUnsized;\n+use std::marker::Unsize;\n+\n+fn identity_coercion(x: &(Fn(u32)->u32 + Send)) -> &Fn(u32)->u32 {\n+    x\n+}\n+fn fn_coercions(f: &fn(u32) -> u32) ->\n+    (unsafe fn(u32) -> u32,\n+     &(Fn(u32) -> u32+Send))\n+{\n+    (*f, f)\n+}\n+\n+fn simple_array_coercion(x: &[u8; 3]) -> &[u8] { x }\n+\n+fn square(a: u32) -> u32 { a * a }\n+\n+#[derive(PartialEq,Eq)]\n+struct PtrWrapper<'a, T: 'a+?Sized>(u32, u32, (), &'a T);\n+impl<'a, T: ?Sized+Unsize<U>, U: ?Sized>\n+    CoerceUnsized<PtrWrapper<'a, U>> for PtrWrapper<'a, T> {}\n+\n+struct TrivPtrWrapper<'a, T: 'a+?Sized>(&'a T);\n+impl<'a, T: ?Sized+Unsize<U>, U: ?Sized>\n+    CoerceUnsized<TrivPtrWrapper<'a, U>> for TrivPtrWrapper<'a, T> {}\n+\n+fn coerce_ptr_wrapper(p: PtrWrapper<[u8; 3]>) -> PtrWrapper<[u8]> {\n+    p\n+}\n+\n+fn coerce_triv_ptr_wrapper(p: TrivPtrWrapper<[u8; 3]>) -> TrivPtrWrapper<[u8]> {\n+    p\n+}\n+\n+fn coerce_fat_ptr_wrapper(p: PtrWrapper<Fn(u32) -> u32+Send>)\n+                          -> PtrWrapper<Fn(u32) -> u32> {\n+    p\n+}\n+\n+fn coerce_ptr_wrapper_poly<'a, T, Trait: ?Sized>(p: PtrWrapper<'a, T>)\n+                                                 -> PtrWrapper<'a, Trait>\n+    where PtrWrapper<'a, T>: CoerceUnsized<PtrWrapper<'a, Trait>>\n+{\n+    p\n+}\n+\n+fn main() {\n+    let a = [0,1,2];\n+    let square_local : fn(u32) -> u32 = square;\n+    let (f,g) = fn_coercions(&square_local);\n+    assert_eq!(f as *const (), square as *const());\n+    assert_eq!(g(4), 16);\n+    assert_eq!(identity_coercion(g)(5), 25);\n+\n+    assert_eq!(simple_array_coercion(&a), &a);\n+    let w = coerce_ptr_wrapper(PtrWrapper(2,3,(),&a));\n+    assert!(w == PtrWrapper(2,3,(),&a) as PtrWrapper<[u8]>);\n+\n+    let w = coerce_triv_ptr_wrapper(TrivPtrWrapper(&a));\n+    assert_eq!(&w.0, &a);\n+\n+    let z = coerce_fat_ptr_wrapper(PtrWrapper(2,3,(),&square_local));\n+    assert_eq!((z.3)(6), 36);\n+\n+    let z: PtrWrapper<Fn(u32) -> u32> =\n+        coerce_ptr_wrapper_poly(PtrWrapper(2,3,(),&square_local));\n+    assert_eq!((z.3)(6), 36);\n+}"}, {"sha": "30cfb5b685b2098c4a901d67577250699c1bbe18", "filename": "tests/run-pass/multi_arg_closure.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/45df853da7197c619e842bec6b5d84c702f02024/tests%2Frun-pass%2Fmulti_arg_closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45df853da7197c619e842bec6b5d84c702f02024/tests%2Frun-pass%2Fmulti_arg_closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fmulti_arg_closure.rs?ref=45df853da7197c619e842bec6b5d84c702f02024", "patch": "@@ -0,0 +1,8 @@\n+fn foo(f: &mut FnMut(isize, isize) -> isize) -> isize {\n+    f(1, 2)\n+}\n+\n+fn main() {\n+    let z = foo(&mut |x, y| x * 10 + y);\n+    assert_eq!(z, 12);\n+}"}]}