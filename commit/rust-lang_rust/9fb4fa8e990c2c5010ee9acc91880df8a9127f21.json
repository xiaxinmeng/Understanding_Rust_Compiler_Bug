{"sha": "9fb4fa8e990c2c5010ee9acc91880df8a9127f21", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlmYjRmYThlOTkwYzJjNTAxMGVlOWFjYzkxODgwZGY4YTkxMjdmMjE=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2016-08-14T17:29:49Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-08-14T17:29:49Z"}, "message": "Rollup merge of #35539 - cgswords:ts_concat, r=nrc\n\nImplemented a smarter TokenStream concatenation system\n\nThe new algorithm performs 'aggressive compacting' during concatenation as follows:\n\n- If the nodes' combined total total length is less than 32, we copy both of\n   them into a new vector and build a new leaf node.\n- If one node is an internal node and the other is a 'small' leaf (length<32),\n   we recur down the internal node on the appropriate side.\n - Otherwise, we construct a new internal node that points to them as left and\n right.\n\nThis should produce notably better behavior than the current concatenation implementation.", "tree": {"sha": "248bf0f9f0576cbbfe0621c55888510a4ffa836c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/248bf0f9f0576cbbfe0621c55888510a4ffa836c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9fb4fa8e990c2c5010ee9acc91880df8a9127f21", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9fb4fa8e990c2c5010ee9acc91880df8a9127f21", "html_url": "https://github.com/rust-lang/rust/commit/9fb4fa8e990c2c5010ee9acc91880df8a9127f21", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9fb4fa8e990c2c5010ee9acc91880df8a9127f21/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b1ec5b2ad23aa4e2e6670f47e270e30945444924", "url": "https://api.github.com/repos/rust-lang/rust/commits/b1ec5b2ad23aa4e2e6670f47e270e30945444924", "html_url": "https://github.com/rust-lang/rust/commit/b1ec5b2ad23aa4e2e6670f47e270e30945444924"}, {"sha": "16cc8a767a70b15927933507321a5ce6cb00372d", "url": "https://api.github.com/repos/rust-lang/rust/commits/16cc8a767a70b15927933507321a5ce6cb00372d", "html_url": "https://github.com/rust-lang/rust/commit/16cc8a767a70b15927933507321a5ce6cb00372d"}], "stats": {"total": 112, "additions": 92, "deletions": 20}, "files": [{"sha": "0171f24101aecd6565fa29655481cf5f928a63bd", "filename": "src/libsyntax/tokenstream.rs", "status": "modified", "additions": 92, "deletions": 20, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/9fb4fa8e990c2c5010ee9acc91880df8a9127f21/src%2Flibsyntax%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fb4fa8e990c2c5010ee9acc91880df8a9127f21/src%2Flibsyntax%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftokenstream.rs?ref=9fb4fa8e990c2c5010ee9acc91880df8a9127f21", "patch": "@@ -340,6 +340,11 @@ pub struct TokenStream {\n     ts: InternalTS,\n }\n \n+// This indicates the maximum size for a leaf in the concatenation algorithm.\n+// If two leafs will be collectively smaller than this, they will be merged.\n+// If a leaf is larger than this, it will be concatenated at the top.\n+const LEAF_SIZE : usize = 32;\n+\n // NB If Leaf access proves to be slow, inroducing a secondary Leaf without the bounds\n // for unsliced Leafs may lead to some performance improvemenet.\n #[derive(Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n@@ -483,6 +488,37 @@ impl InternalTS {\n             }\n         }\n     }\n+\n+    fn to_vec(&self) -> Vec<&TokenTree> {\n+        let mut res = Vec::with_capacity(self.len());\n+        fn traverse_and_append<'a>(res: &mut Vec<&'a TokenTree>, ts: &'a InternalTS) {\n+            match *ts {\n+                InternalTS::Empty(..) => {},\n+                InternalTS::Leaf { ref tts, offset, len, .. } => {\n+                    let mut to_app = tts[offset..offset + len].iter().collect();\n+                    res.append(&mut to_app);\n+                }\n+                InternalTS::Node { ref left, ref right, .. } => {\n+                    traverse_and_append(res, left);\n+                    traverse_and_append(res, right);\n+                }\n+            }\n+        }\n+        traverse_and_append(&mut res, self);\n+        res\n+    }\n+\n+    fn to_tts(&self) -> Vec<TokenTree> {\n+        self.to_vec().into_iter().cloned().collect::<Vec<TokenTree>>()\n+    }\n+\n+    // Returns an internal node's children.\n+    fn children(&self) -> Option<(Rc<InternalTS>, Rc<InternalTS>)> {\n+        match *self {\n+            InternalTS::Node { ref left, ref right, .. } => Some((left.clone(), right.clone())),\n+            _ => None,\n+        }\n+    }\n }\n \n /// TokenStream operators include basic destructuring, boolean operations, `maybe_...`\n@@ -496,14 +532,17 @@ impl InternalTS {\n ///\n ///    `maybe_path_prefix(\"a::b::c(a,b,c).foo()\") -> (a::b::c, \"(a,b,c).foo()\")`\n impl TokenStream {\n+    // Construct an empty node with a dummy span.\n     pub fn mk_empty() -> TokenStream {\n         TokenStream { ts: InternalTS::Empty(DUMMY_SP) }\n     }\n \n+    // Construct an empty node with the provided span.\n     fn mk_spanned_empty(sp: Span) -> TokenStream {\n         TokenStream { ts: InternalTS::Empty(sp) }\n     }\n \n+    // Construct a leaf node with a 0 offset and length equivalent to the input.\n     fn mk_leaf(tts: Rc<Vec<TokenTree>>, sp: Span) -> TokenStream {\n         let len = tts.len();\n         TokenStream {\n@@ -516,6 +555,7 @@ impl TokenStream {\n         }\n     }\n \n+    // Construct a leaf node with the provided values.\n     fn mk_sub_leaf(tts: Rc<Vec<TokenTree>>, offset: usize, len: usize, sp: Span) -> TokenStream {\n         TokenStream {\n             ts: InternalTS::Leaf {\n@@ -527,6 +567,7 @@ impl TokenStream {\n         }\n     }\n \n+    // Construct an internal node with the provided values.\n     fn mk_int_node(left: Rc<InternalTS>,\n                    right: Rc<InternalTS>,\n                    len: usize,\n@@ -561,11 +602,56 @@ impl TokenStream {\n         }\n     }\n \n-    /// Concatenates two TokenStreams into a new TokenStream\n+    /// Concatenates two TokenStreams into a new TokenStream.\n     pub fn concat(left: TokenStream, right: TokenStream) -> TokenStream {\n-        let new_len = left.len() + right.len();\n-        let new_span = combine_spans(left.span(), right.span());\n-        TokenStream::mk_int_node(Rc::new(left.ts), Rc::new(right.ts), new_len, new_span)\n+        // This internal procedure performs 'aggressive compacting' during concatenation as\n+        // follows:\n+        // - If the nodes' combined total total length is less than 32, we copy both of\n+        //   them into a new vector and build a new leaf node.\n+        // - If one node is an internal node and the other is a 'small' leaf (length<32),\n+        //   we recur down the internal node on the appropriate side.\n+        // - Otherwise, we construct a new internal node that points to them as left and\n+        // right.\n+        fn concat_internal(left: Rc<InternalTS>, right: Rc<InternalTS>) -> TokenStream {\n+            let llen = left.len();\n+            let rlen = right.len();\n+            let len = llen + rlen;\n+            let span = combine_spans(left.span(), right.span());\n+            if len <= LEAF_SIZE {\n+                let mut new_vec = left.to_tts();\n+                let mut rvec = right.to_tts();\n+                new_vec.append(&mut rvec);\n+                return TokenStream::mk_leaf(Rc::new(new_vec), span);\n+            }\n+\n+            match (left.children(), right.children()) {\n+                (Some((lleft, lright)), None) => {\n+                    if rlen <= LEAF_SIZE  {\n+                        let new_right = concat_internal(lright, right);\n+                        TokenStream::mk_int_node(lleft, Rc::new(new_right.ts), len, span)\n+                    } else {\n+                       TokenStream::mk_int_node(left, right, len, span)\n+                    }\n+                }\n+                (None, Some((rleft, rright))) => {\n+                    if rlen <= LEAF_SIZE  {\n+                        let new_left = concat_internal(left, rleft);\n+                        TokenStream::mk_int_node(Rc::new(new_left.ts), rright, len, span)\n+                    } else {\n+                       TokenStream::mk_int_node(left, right, len, span)\n+                    }\n+                }\n+                (_, _) => TokenStream::mk_int_node(left, right, len, span),\n+            }\n+        }\n+\n+        if left.is_empty() {\n+            right\n+        } else if right.is_empty() {\n+            left\n+        } else {\n+            concat_internal(Rc::new(left.ts), Rc::new(right.ts))\n+        }\n     }\n \n     /// Indicate if the TokenStream is empty.\n@@ -580,27 +666,13 @@ impl TokenStream {\n \n     /// Convert a TokenStream into a vector of borrowed TokenTrees.\n     pub fn to_vec(&self) -> Vec<&TokenTree> {\n-        fn internal_to_vec(ts: &InternalTS) -> Vec<&TokenTree> {\n-            match *ts {\n-                InternalTS::Empty(..) => Vec::new(),\n-                InternalTS::Leaf { ref tts, offset, len, .. } => {\n-                    tts[offset..offset + len].iter().collect()\n-                }\n-                InternalTS::Node { ref left, ref right, .. } => {\n-                    let mut v1 = internal_to_vec(left);\n-                    let mut v2 = internal_to_vec(right);\n-                    v1.append(&mut v2);\n-                    v1\n-                }\n-            }\n-        }\n-        internal_to_vec(&self.ts)\n+        self.ts.to_vec()\n     }\n \n     /// Convert a TokenStream into a vector of TokenTrees (by cloning the TokenTrees).\n     /// (This operation is an O(n) deep copy of the underlying structure.)\n     pub fn to_tts(&self) -> Vec<TokenTree> {\n-        self.to_vec().into_iter().cloned().collect::<Vec<TokenTree>>()\n+        self.ts.to_tts()\n     }\n \n     /// Return the TokenStream's span."}]}