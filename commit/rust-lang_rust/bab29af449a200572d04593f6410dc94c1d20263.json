{"sha": "bab29af449a200572d04593f6410dc94c1d20263", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJhYjI5YWY0NDlhMjAwNTcyZDA0NTkzZjY0MTBkYzk0YzFkMjAyNjM=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-08-15T22:45:52Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-08-16T17:29:09Z"}, "message": "Continue migrating the std #fmt interface to ivecs\n\nOnly thing left is to remove some duplicate interfaces in std::extfmt::rt\nafter the next snapshot", "tree": {"sha": "5ac70ef23ecc1a880eb47c2d2e9a294cc50efd54", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5ac70ef23ecc1a880eb47c2d2e9a294cc50efd54"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bab29af449a200572d04593f6410dc94c1d20263", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bab29af449a200572d04593f6410dc94c1d20263", "html_url": "https://github.com/rust-lang/rust/commit/bab29af449a200572d04593f6410dc94c1d20263", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bab29af449a200572d04593f6410dc94c1d20263/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "46658c4a9c6a6f67ae6a20f3c9f6040c212af68c", "url": "https://api.github.com/repos/rust-lang/rust/commits/46658c4a9c6a6f67ae6a20f3c9f6040c212af68c", "html_url": "https://github.com/rust-lang/rust/commit/46658c4a9c6a6f67ae6a20f3c9f6040c212af68c"}], "stats": {"total": 50, "additions": 21, "deletions": 29}, "files": [{"sha": "369fc7be0c393dae2100622c68a67ea8575599c1", "filename": "src/comp/syntax/ext/fmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bab29af449a200572d04593f6410dc94c1d20263/src%2Fcomp%2Fsyntax%2Fext%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab29af449a200572d04593f6410dc94c1d20263/src%2Fcomp%2Fsyntax%2Fext%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Ffmt.rs?ref=bab29af449a200572d04593f6410dc94c1d20263", "patch": "@@ -182,7 +182,7 @@ fn pieces_to_expr(cx: &ext_ctxt, sp: span, pieces: &[piece],\n     }\n     fn make_conv_call(cx: &ext_ctxt, sp: span, conv_type: str, cnv: &conv,\n                       arg: @ast::expr) -> @ast::expr {\n-        let fname = \"conv_\" + conv_type + \"_ivec\";\n+        let fname = \"conv_\" + conv_type;\n         let path = make_path_vec(cx, fname);\n         let cnv_expr = make_rt_conv_expr(cx, sp, cnv);\n         let args = ~[cnv_expr, arg];"}, {"sha": "25cdc2a46c88f6e371a5c6990b6e4a8803cb2388", "filename": "src/lib/extfmt.rs", "status": "modified", "additions": 20, "deletions": 28, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/bab29af449a200572d04593f6410dc94c1d20263/src%2Flib%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bab29af449a200572d04593f6410dc94c1d20263/src%2Flib%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fextfmt.rs?ref=bab29af449a200572d04593f6410dc94c1d20263", "patch": "@@ -268,34 +268,26 @@ mod rt {\n \n     // FIXME: May not want to use a vector here for flags;\n     // instead just use a bool per flag\n-    type conv = {flags: vec[flag], width: count, precision: count, ty: ty};\n+    type conv = {flags: [flag], width: count, precision: count, ty: ty};\n \n-    type conv_ivec = {flags: [flag], width: count, precision: count, ty: ty};\n-\n-    fn to_conv_ivec(cv: &conv) -> conv_ivec {\n-        {flags: ivec::from_vec(cv.flags),\n-         width: cv.width,\n-         precision: cv.precision,\n-         ty: cv.ty}\n+    // FIXME: Remove these transitional *_ivec interfaces\n+    fn conv_int_ivec(cv: &conv, i: int) -> str {\n+        conv_int(cv, i)\n     }\n-\n-    fn conv_int(cv: &conv, i: int) -> str {\n-        conv_int_ivec(to_conv_ivec(cv), i)\n+    fn conv_uint_ivec(cv: &conv, u: uint) -> str {\n+        conv_uint(cv, u)\n     }\n-    fn conv_uint(cv: &conv, u: uint) -> str {\n-        conv_uint_ivec(to_conv_ivec(cv), u)\n+    fn conv_bool_ivec(cv: &conv, b: bool) -> str {\n+        conv_bool(cv, b)\n     }\n-    fn conv_bool(cv: &conv, b: bool) -> str {\n-        conv_bool_ivec(to_conv_ivec(cv), b)\n+    fn conv_char_ivec(cv: &conv, c: char) -> str {\n+        conv_char(cv, c)\n     }\n-    fn conv_char(cv: &conv, c: char) -> str {\n-        conv_char_ivec(to_conv_ivec(cv), c)\n-    }\n-    fn conv_str(cv: &conv, s: str) -> str {\n-        conv_str_ivec(to_conv_ivec(cv), s)\n+    fn conv_str_ivec(cv: &conv, s: str) -> str {\n+        conv_str(cv, s)\n     }\n \n-    fn conv_int_ivec(cv: &conv_ivec, i: int) -> str {\n+    fn conv_int(cv: &conv, i: int) -> str {\n         let radix = 10u;\n         let prec = get_int_precision(cv);\n         let s = int_to_str_prec(i, radix, prec);\n@@ -308,7 +300,7 @@ mod rt {\n         }\n         ret pad(cv, s, pad_signed);\n     }\n-    fn conv_uint_ivec(cv: &conv_ivec, u: uint) -> str {\n+    fn conv_uint(cv: &conv, u: uint) -> str {\n         let prec = get_int_precision(cv);\n         let rs =\n             alt cv.ty {\n@@ -320,17 +312,17 @@ mod rt {\n             };\n         ret pad(cv, rs, pad_unsigned);\n     }\n-    fn conv_bool_ivec(cv: &conv_ivec, b: bool) -> str {\n+    fn conv_bool(cv: &conv, b: bool) -> str {\n         let s = if b { \"true\" } else { \"false\" };\n         // run the boolean conversion through the string conversion logic,\n         // giving it the same rules for precision, etc.\n \n         ret conv_str_ivec(cv, s);\n     }\n-    fn conv_char_ivec(cv: &conv_ivec, c: char) -> str {\n+    fn conv_char(cv: &conv, c: char) -> str {\n         ret pad(cv, str::from_char(c), pad_nozero);\n     }\n-    fn conv_str_ivec(cv: &conv_ivec, s: str) -> str {\n+    fn conv_str(cv: &conv, s: str) -> str {\n         // For strings, precision is the maximum characters\n         // displayed\n \n@@ -371,7 +363,7 @@ mod rt {\n                 } else { s }\n             };\n     }\n-    fn get_int_precision(cv: &conv_ivec) -> uint {\n+    fn get_int_precision(cv: &conv) -> uint {\n         ret alt cv.precision {\n               count_is(c) { c as uint }\n               count_implied. { 1u }\n@@ -385,7 +377,7 @@ mod rt {\n         ret str::unsafe_from_bytes(svec);\n     }\n     tag pad_mode { pad_signed; pad_unsigned; pad_nozero; }\n-    fn pad(cv: &conv_ivec, s: str, mode: pad_mode) -> str {\n+    fn pad(cv: &conv, s: str, mode: pad_mode) -> str {\n         let uwidth;\n         alt cv.width {\n           count_implied. { ret s; }\n@@ -413,7 +405,7 @@ mod rt {\n           pad_signed. { might_zero_pad = true; signed = true; }\n           pad_unsigned. { might_zero_pad = true; }\n         }\n-        fn have_precision(cv: &conv_ivec) -> bool {\n+        fn have_precision(cv: &conv) -> bool {\n             ret alt cv.precision { count_implied. { false } _ { true } };\n         }\n         let zero_padding = false;"}]}