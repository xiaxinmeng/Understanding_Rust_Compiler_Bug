{"sha": "cd982ad3f74673c55af6034a4f757e60be9b381c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNkOTgyYWQzZjc0NjczYzU1YWY2MDM0YTRmNzU3ZTYwYmU5YjM4MWM=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-04-19T00:40:53Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-04-20T03:23:23Z"}, "message": "std: clean up tests (mostly unused unsafe blocks)", "tree": {"sha": "7f0ce98e1cab151616202af2b5b7111be91e6359", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7f0ce98e1cab151616202af2b5b7111be91e6359"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cd982ad3f74673c55af6034a4f757e60be9b381c", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cd982ad3f74673c55af6034a4f757e60be9b381c", "html_url": "https://github.com/rust-lang/rust/commit/cd982ad3f74673c55af6034a4f757e60be9b381c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cd982ad3f74673c55af6034a4f757e60be9b381c/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "98dfeb173fc1fbe8724abf8cf0943bd32653dd65", "url": "https://api.github.com/repos/rust-lang/rust/commits/98dfeb173fc1fbe8724abf8cf0943bd32653dd65", "html_url": "https://github.com/rust-lang/rust/commit/98dfeb173fc1fbe8724abf8cf0943bd32653dd65"}], "stats": {"total": 248, "additions": 116, "deletions": 132}, "files": [{"sha": "dd85e886b1ec6160e591d21201f7fbba038ec3e7", "filename": "src/libstd/c_vec.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cd982ad3f74673c55af6034a4f757e60be9b381c/src%2Flibstd%2Fc_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd982ad3f74673c55af6034a4f757e60be9b381c/src%2Flibstd%2Fc_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_vec.rs?ref=cd982ad3f74673c55af6034a4f757e60be9b381c", "patch": "@@ -159,8 +159,8 @@ mod tests {\n \n             assert!(mem as int != 0);\n \n-            return unsafe { c_vec_with_dtor(mem as *mut u8, n as uint,\n-                                         || unsafe { free(mem) }) };\n+            return c_vec_with_dtor(mem as *mut u8, n as uint,\n+                                   || unsafe { free(mem) });\n         }\n     }\n \n@@ -196,7 +196,7 @@ mod tests {\n     #[test]\n     fn test_and_I_mean_it() {\n         let cv = malloc(16u as size_t);\n-        let p = unsafe { ptr(cv) };\n+        let p = ptr(cv);\n \n         set(cv, 0u, 32u8);\n         set(cv, 1u, 33u8);"}, {"sha": "890712a97085b9061990fe4e65804e5744f8e8cc", "filename": "src/libstd/rope.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/cd982ad3f74673c55af6034a4f757e60be9b381c/src%2Flibstd%2Frope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd982ad3f74673c55af6034a4f757e60be9b381c/src%2Flibstd%2Frope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frope.rs?ref=cd982ad3f74673c55af6034a4f757e60be9b381c", "patch": "@@ -1287,18 +1287,16 @@ mod tests {\n           node::Content(x) => {\n             let str = @mut ~\"\";\n             fn aux(str: @mut ~str, node: @node::Node) {\n-                unsafe {\n-                    match (*node) {\n-                      node::Leaf(x) => {\n-                        *str += str::slice(\n-                            *x.content, x.byte_offset,\n-                            x.byte_offset + x.byte_len).to_owned();\n-                      }\n-                      node::Concat(ref x) => {\n-                        aux(str, x.left);\n-                        aux(str, x.right);\n-                      }\n-                    }\n+                match (*node) {\n+                  node::Leaf(x) => {\n+                    *str += str::slice(\n+                        *x.content, x.byte_offset,\n+                        x.byte_offset + x.byte_len).to_owned();\n+                  }\n+                  node::Concat(ref x) => {\n+                    aux(str, x.left);\n+                    aux(str, x.right);\n+                  }\n                 }\n             }\n             aux(str, x);"}, {"sha": "7e1c9d858ce0c8243c4cbbc56088de644d20bb2c", "filename": "src/libstd/uv_iotask.rs", "status": "modified", "additions": 53, "deletions": 61, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/cd982ad3f74673c55af6034a4f757e60be9b381c/src%2Flibstd%2Fuv_iotask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd982ad3f74673c55af6034a4f757e60be9b381c/src%2Flibstd%2Fuv_iotask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_iotask.rs?ref=cd982ad3f74673c55af6034a4f757e60be9b381c", "patch": "@@ -224,36 +224,32 @@ struct AhData {\n \n #[cfg(test)]\n fn impl_uv_iotask_async(iotask: &IoTask) {\n-    unsafe {\n-        let async_handle = ll::async_t();\n-        let ah_ptr = ptr::addr_of(&async_handle);\n-        let (exit_po, exit_ch) = stream::<()>();\n-        let ah_data = AhData {\n-            iotask: iotask.clone(),\n-            exit_ch: SharedChan::new(exit_ch)\n-        };\n-        let ah_data_ptr: *AhData = unsafe {\n-            ptr::to_unsafe_ptr(&ah_data)\n-        };\n-        debug!(\"about to interact\");\n-        do interact(iotask) |loop_ptr| {\n-            unsafe {\n-                debug!(\"interacting\");\n-                ll::async_init(loop_ptr, ah_ptr, async_handle_cb);\n-                ll::set_data_for_uv_handle(\n-                    ah_ptr, ah_data_ptr as *libc::c_void);\n-                ll::async_send(ah_ptr);\n-            }\n-        };\n-        debug!(\"waiting for async close\");\n-        exit_po.recv();\n-    }\n+    let async_handle = ll::async_t();\n+    let ah_ptr = ptr::addr_of(&async_handle);\n+    let (exit_po, exit_ch) = stream::<()>();\n+    let ah_data = AhData {\n+        iotask: iotask.clone(),\n+        exit_ch: SharedChan::new(exit_ch)\n+    };\n+    let ah_data_ptr: *AhData = ptr::to_unsafe_ptr(&ah_data);\n+    debug!(\"about to interact\");\n+    do interact(iotask) |loop_ptr| {\n+        unsafe {\n+            debug!(\"interacting\");\n+            ll::async_init(loop_ptr, ah_ptr, async_handle_cb);\n+            ll::set_data_for_uv_handle(\n+                ah_ptr, ah_data_ptr as *libc::c_void);\n+            ll::async_send(ah_ptr);\n+        }\n+    };\n+    debug!(\"waiting for async close\");\n+    exit_po.recv();\n }\n \n // this fn documents the bear minimum neccesary to roll your own\n // high_level_loop\n #[cfg(test)]\n-unsafe fn spawn_test_loop(exit_ch: ~Chan<()>) -> IoTask {\n+fn spawn_test_loop(exit_ch: ~Chan<()>) -> IoTask {\n     let (iotask_port, iotask_ch) = stream::<IoTask>();\n     do task::spawn_sched(task::ManualThreads(1u)) {\n         debug!(\"about to run a test loop\");\n@@ -265,9 +261,7 @@ unsafe fn spawn_test_loop(exit_ch: ~Chan<()>) -> IoTask {\n \n #[cfg(test)]\n extern fn lifetime_handle_close(handle: *libc::c_void) {\n-    unsafe {\n-        debug!(\"lifetime_handle_close ptr %?\", handle);\n-    }\n+    debug!(\"lifetime_handle_close ptr %?\", handle);\n }\n \n #[cfg(test)]\n@@ -279,38 +273,36 @@ extern fn lifetime_async_callback(handle: *libc::c_void,\n \n #[test]\n fn test_uv_iotask_async() {\n-    unsafe {\n-        let (exit_po, exit_ch) = stream::<()>();\n-        let iotask = &spawn_test_loop(~exit_ch);\n-\n-        debug!(\"spawned iotask\");\n-\n-        // using this handle to manage the lifetime of the\n-        // high_level_loop, as it will exit the first time one of\n-        // the impl_uv_hl_async() is cleaned up with no one ref'd\n-        // handles on the loop (Which can happen under\n-        // race-condition type situations.. this ensures that the\n-        // loop lives until, at least, all of the\n-        // impl_uv_hl_async() runs have been called, at least.\n-        let (work_exit_po, work_exit_ch) = stream::<()>();\n-        let work_exit_ch = SharedChan::new(work_exit_ch);\n-        for iter::repeat(7u) {\n-            let iotask_clone = iotask.clone();\n-            let work_exit_ch_clone = work_exit_ch.clone();\n-            do task::spawn_sched(task::ManualThreads(1u)) {\n-                debug!(\"async\");\n-                impl_uv_iotask_async(&iotask_clone);\n-                debug!(\"done async\");\n-                work_exit_ch_clone.send(());\n-            };\n+    let (exit_po, exit_ch) = stream::<()>();\n+    let iotask = &spawn_test_loop(~exit_ch);\n+\n+    debug!(\"spawned iotask\");\n+\n+    // using this handle to manage the lifetime of the\n+    // high_level_loop, as it will exit the first time one of\n+    // the impl_uv_hl_async() is cleaned up with no one ref'd\n+    // handles on the loop (Which can happen under\n+    // race-condition type situations.. this ensures that the\n+    // loop lives until, at least, all of the\n+    // impl_uv_hl_async() runs have been called, at least.\n+    let (work_exit_po, work_exit_ch) = stream::<()>();\n+    let work_exit_ch = SharedChan::new(work_exit_ch);\n+    for iter::repeat(7u) {\n+        let iotask_clone = iotask.clone();\n+        let work_exit_ch_clone = work_exit_ch.clone();\n+        do task::spawn_sched(task::ManualThreads(1u)) {\n+            debug!(\"async\");\n+            impl_uv_iotask_async(&iotask_clone);\n+            debug!(\"done async\");\n+            work_exit_ch_clone.send(());\n         };\n-        for iter::repeat(7u) {\n-            debug!(\"waiting\");\n-            work_exit_po.recv();\n-        };\n-        debug!(~\"sending teardown_loop msg..\");\n-        exit(iotask);\n-        exit_po.recv();\n-        debug!(~\"after recv on exit_po.. exiting..\");\n-    }\n+    };\n+    for iter::repeat(7u) {\n+        debug!(\"waiting\");\n+        work_exit_po.recv();\n+    };\n+    debug!(~\"sending teardown_loop msg..\");\n+    exit(iotask);\n+    exit_po.recv();\n+    debug!(~\"after recv on exit_po.. exiting..\");\n }"}, {"sha": "a5c531004003abcbff3f018e1234d978a8e372dd", "filename": "src/libstd/uv_ll.rs", "status": "modified", "additions": 50, "deletions": 56, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/cd982ad3f74673c55af6034a4f757e60be9b381c/src%2Flibstd%2Fuv_ll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd982ad3f74673c55af6034a4f757e60be9b381c/src%2Flibstd%2Fuv_ll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_ll.rs?ref=cd982ad3f74673c55af6034a4f757e60be9b381c", "patch": "@@ -1422,10 +1422,8 @@ mod test {\n     }\n \n     extern fn server_after_close_cb(handle: *libc::c_void) {\n-        unsafe {\n-            debug!(\"SERVER server stream closed, should exit. h: %?\",\n-                       handle);\n-        }\n+        debug!(\"SERVER server stream closed, should exit. h: %?\",\n+                   handle);\n     }\n \n     extern fn client_stream_after_close_cb(handle: *libc::c_void) {\n@@ -1709,48 +1707,46 @@ mod test {\n     // this is the impl for a test that is (maybe) ran on a\n     // per-platform/arch basis below\n     pub fn impl_uv_tcp_server_and_request() {\n-        unsafe {\n-            let bind_ip = ~\"0.0.0.0\";\n-            let request_ip = ~\"127.0.0.1\";\n-            let port = 8886;\n-            let kill_server_msg = ~\"does a dog have buddha nature?\";\n-            let server_resp_msg = ~\"mu!\";\n-            let (client_port, client_chan) = stream::<~str>();\n-            let client_chan = SharedChan::new(client_chan);\n-            let (server_port, server_chan) = stream::<~str>();\n-            let server_chan = SharedChan::new(server_chan);\n-\n-            let (continue_port, continue_chan) = stream::<bool>();\n-            let continue_chan = SharedChan::new(continue_chan);\n-\n-            let kill_server_msg_copy = copy kill_server_msg;\n-            let server_resp_msg_copy = copy server_resp_msg;\n-            do task::spawn_sched(task::ManualThreads(1)) {\n-                impl_uv_tcp_server(bind_ip, port,\n-                                   copy kill_server_msg_copy,\n-                                   copy server_resp_msg_copy,\n-                                   server_chan.clone(),\n-                                   continue_chan.clone());\n-            };\n-\n-            // block until the server up is.. possibly a race?\n-            debug!(~\"before receiving on server continue_port\");\n-            continue_port.recv();\n-            debug!(~\"received on continue port, set up tcp client\");\n-\n-            let kill_server_msg_copy = copy kill_server_msg;\n-            do task::spawn_sched(task::ManualThreads(1u)) {\n-                impl_uv_tcp_request(request_ip, port,\n-                                   kill_server_msg_copy,\n-                                   client_chan.clone());\n-            };\n-\n-            let msg_from_client = server_port.recv();\n-            let msg_from_server = client_port.recv();\n-\n-            assert!(str::contains(msg_from_client, kill_server_msg));\n-            assert!(str::contains(msg_from_server, server_resp_msg));\n-        }\n+        let bind_ip = ~\"0.0.0.0\";\n+        let request_ip = ~\"127.0.0.1\";\n+        let port = 8886;\n+        let kill_server_msg = ~\"does a dog have buddha nature?\";\n+        let server_resp_msg = ~\"mu!\";\n+        let (client_port, client_chan) = stream::<~str>();\n+        let client_chan = SharedChan::new(client_chan);\n+        let (server_port, server_chan) = stream::<~str>();\n+        let server_chan = SharedChan::new(server_chan);\n+\n+        let (continue_port, continue_chan) = stream::<bool>();\n+        let continue_chan = SharedChan::new(continue_chan);\n+\n+        let kill_server_msg_copy = copy kill_server_msg;\n+        let server_resp_msg_copy = copy server_resp_msg;\n+        do task::spawn_sched(task::ManualThreads(1)) {\n+            impl_uv_tcp_server(bind_ip, port,\n+                               copy kill_server_msg_copy,\n+                               copy server_resp_msg_copy,\n+                               server_chan.clone(),\n+                               continue_chan.clone());\n+        };\n+\n+        // block until the server up is.. possibly a race?\n+        debug!(~\"before receiving on server continue_port\");\n+        continue_port.recv();\n+        debug!(~\"received on continue port, set up tcp client\");\n+\n+        let kill_server_msg_copy = copy kill_server_msg;\n+        do task::spawn_sched(task::ManualThreads(1u)) {\n+            impl_uv_tcp_request(request_ip, port,\n+                               kill_server_msg_copy,\n+                               client_chan.clone());\n+        };\n+\n+        let msg_from_client = server_port.recv();\n+        let msg_from_server = client_port.recv();\n+\n+        assert!(str::contains(msg_from_client, kill_server_msg));\n+        assert!(str::contains(msg_from_server, server_resp_msg));\n     }\n \n     // FIXME don't run on fbsd or linux 32 bit(#2064)\n@@ -1784,17 +1780,15 @@ mod test {\n \n     fn struct_size_check_common<TStruct>(t_name: ~str,\n                                          foreign_size: libc::c_uint) {\n-        unsafe {\n-            let rust_size = sys::size_of::<TStruct>();\n-            let sizes_match = foreign_size as uint == rust_size;\n-            if !sizes_match {\n-                let output = fmt!(\n-                    \"STRUCT_SIZE FAILURE: %s -- actual: %u expected: %u\",\n-                    t_name, rust_size, foreign_size as uint);\n-                debug!(output);\n-            }\n-            assert!(sizes_match);\n+        let rust_size = sys::size_of::<TStruct>();\n+        let sizes_match = foreign_size as uint == rust_size;\n+        if !sizes_match {\n+            let output = fmt!(\n+                \"STRUCT_SIZE FAILURE: %s -- actual: %u expected: %u\",\n+                t_name, rust_size, foreign_size as uint);\n+            debug!(output);\n         }\n+        assert!(sizes_match);\n     }\n \n     // struct size tests"}]}