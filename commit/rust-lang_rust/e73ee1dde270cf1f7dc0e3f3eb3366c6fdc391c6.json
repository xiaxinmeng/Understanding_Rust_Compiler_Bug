{"sha": "e73ee1dde270cf1f7dc0e3f3eb3366c6fdc391c6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU3M2VlMWRkZTI3MGNmMWY3ZGMwZTNmM2ViMzM2NmM2ZmRjMzkxYzY=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2021-01-13T02:20:17Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-01-13T02:20:17Z"}, "message": "Rollup merge of #80736 - KodrAus:feat/lazy-resolve, r=dtolnay\n\nuse Once instead of Mutex to manage capture resolution\n\nFor #78299\n\nThis allows us to return borrows of the captured backtrace frames that are tied to a borrow of the Backtrace itself, instead of to some short-lived Mutex guard.\n\nWe could alternatively share `&Mutex<Capture>`s and lock on-demand, but then we could potentially forget to call `resolve()` before working with the capture. It also makes it semantically clearer what synchronization is needed on the capture.\n\ncc `@seanchen1991` `@rust-lang/project-error-handling`", "tree": {"sha": "052d3e06cf443d7c6928281c6c1bbcf9b3a0dc56", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/052d3e06cf443d7c6928281c6c1bbcf9b3a0dc56"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e73ee1dde270cf1f7dc0e3f3eb3366c6fdc391c6", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJf/ljhCRBK7hj4Ov3rIwAAdHIIAC/dJMx/k9o6TFSmXzUznNB2\nkh/gvS90Fo4HukKSn4P2kc+xC4je3hZEYss7pHkvuI595A2X4eH8lbnj3sQ5ImdN\nvDU2UxGLmXJUwor7gpbBJ1GUeFQ+AT3PjCnZBFdUpVVdQ40wLi3Pwac5cSCc1Ecw\n8UlUIvJOwKlxtE99dm4ljyvovydprSWh9myD+iYkMx86Pm6/IqyhqLiO2EeBluDK\nFml1Vom8Z5VFQ0xvAG/r6pXSUkJg6W0lTA8fV8q7PBisl1iFCdgp09mToovCZeri\ncR7/HphdMRBR3GNwSYkUVuQaVrbju7GxCDpoQ6WwOsBw+9gQ9ABSNwXqN2u9gdA=\n=InoP\n-----END PGP SIGNATURE-----\n", "payload": "tree 052d3e06cf443d7c6928281c6c1bbcf9b3a0dc56\nparent 492cb3982520a995dcfc97b968e2b0489ae7a178\nparent db4585aa3b1ee56e4722710d7665ee011fc11145\nauthor Dylan DPC <dylan.dpc@gmail.com> 1610504417 +0100\ncommitter GitHub <noreply@github.com> 1610504417 +0100\n\nRollup merge of #80736 - KodrAus:feat/lazy-resolve, r=dtolnay\n\nuse Once instead of Mutex to manage capture resolution\n\nFor #78299\n\nThis allows us to return borrows of the captured backtrace frames that are tied to a borrow of the Backtrace itself, instead of to some short-lived Mutex guard.\n\nWe could alternatively share `&Mutex<Capture>`s and lock on-demand, but then we could potentially forget to call `resolve()` before working with the capture. It also makes it semantically clearer what synchronization is needed on the capture.\n\ncc `@seanchen1991` `@rust-lang/project-error-handling`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e73ee1dde270cf1f7dc0e3f3eb3366c6fdc391c6", "html_url": "https://github.com/rust-lang/rust/commit/e73ee1dde270cf1f7dc0e3f3eb3366c6fdc391c6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e73ee1dde270cf1f7dc0e3f3eb3366c6fdc391c6/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "492cb3982520a995dcfc97b968e2b0489ae7a178", "url": "https://api.github.com/repos/rust-lang/rust/commits/492cb3982520a995dcfc97b968e2b0489ae7a178", "html_url": "https://github.com/rust-lang/rust/commit/492cb3982520a995dcfc97b968e2b0489ae7a178"}, {"sha": "db4585aa3b1ee56e4722710d7665ee011fc11145", "url": "https://api.github.com/repos/rust-lang/rust/commits/db4585aa3b1ee56e4722710d7665ee011fc11145", "html_url": "https://github.com/rust-lang/rust/commit/db4585aa3b1ee56e4722710d7665ee011fc11145"}], "stats": {"total": 49, "additions": 39, "deletions": 10}, "files": [{"sha": "95e18ef2a654343b71f3f96063b956a11c2c94fa", "filename": "library/std/src/backtrace.rs", "status": "modified", "additions": 35, "deletions": 9, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/e73ee1dde270cf1f7dc0e3f3eb3366c6fdc391c6/library%2Fstd%2Fsrc%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e73ee1dde270cf1f7dc0e3f3eb3366c6fdc391c6/library%2Fstd%2Fsrc%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fbacktrace.rs?ref=e73ee1dde270cf1f7dc0e3f3eb3366c6fdc391c6", "patch": "@@ -95,11 +95,12 @@ mod tests;\n // a backtrace or actually symbolizing it.\n \n use crate::backtrace_rs::{self, BytesOrWideString};\n+use crate::cell::UnsafeCell;\n use crate::env;\n use crate::ffi::c_void;\n use crate::fmt;\n use crate::sync::atomic::{AtomicUsize, Ordering::SeqCst};\n-use crate::sync::Mutex;\n+use crate::sync::Once;\n use crate::sys_common::backtrace::{lock, output_filename};\n use crate::vec::Vec;\n \n@@ -132,7 +133,7 @@ pub enum BacktraceStatus {\n enum Inner {\n     Unsupported,\n     Disabled,\n-    Captured(Mutex<Capture>),\n+    Captured(LazilyResolvedCapture),\n }\n \n struct Capture {\n@@ -171,12 +172,11 @@ enum BytesOrWide {\n \n impl fmt::Debug for Backtrace {\n     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        let mut capture = match &self.inner {\n+        let capture = match &self.inner {\n             Inner::Unsupported => return fmt.write_str(\"<unsupported>\"),\n             Inner::Disabled => return fmt.write_str(\"<disabled>\"),\n-            Inner::Captured(c) => c.lock().unwrap(),\n+            Inner::Captured(c) => c.force(),\n         };\n-        capture.resolve();\n \n         let frames = &capture.frames[capture.actual_start..];\n \n@@ -331,7 +331,7 @@ impl Backtrace {\n         let inner = if frames.is_empty() {\n             Inner::Unsupported\n         } else {\n-            Inner::Captured(Mutex::new(Capture {\n+            Inner::Captured(LazilyResolvedCapture::new(Capture {\n                 actual_start: actual_start.unwrap_or(0),\n                 frames,\n                 resolved: false,\n@@ -355,12 +355,11 @@ impl Backtrace {\n \n impl fmt::Display for Backtrace {\n     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        let mut capture = match &self.inner {\n+        let capture = match &self.inner {\n             Inner::Unsupported => return fmt.write_str(\"unsupported backtrace\"),\n             Inner::Disabled => return fmt.write_str(\"disabled backtrace\"),\n-            Inner::Captured(c) => c.lock().unwrap(),\n+            Inner::Captured(c) => c.force(),\n         };\n-        capture.resolve();\n \n         let full = fmt.alternate();\n         let (frames, style) = if full {\n@@ -404,6 +403,33 @@ impl fmt::Display for Backtrace {\n     }\n }\n \n+struct LazilyResolvedCapture {\n+    sync: Once,\n+    capture: UnsafeCell<Capture>,\n+}\n+\n+impl LazilyResolvedCapture {\n+    fn new(capture: Capture) -> Self {\n+        LazilyResolvedCapture { sync: Once::new(), capture: UnsafeCell::new(capture) }\n+    }\n+\n+    fn force(&self) -> &Capture {\n+        self.sync.call_once(|| {\n+            // SAFETY: This exclusive reference can't overlap with any others\n+            // `Once` guarantees callers will block until this closure returns\n+            // `Once` also guarantees only a single caller will enter this closure\n+            unsafe { &mut *self.capture.get() }.resolve();\n+        });\n+\n+        // SAFETY: This shared reference can't overlap with the exclusive reference above\n+        unsafe { &*self.capture.get() }\n+    }\n+}\n+\n+// SAFETY: Access to the inner value is synchronized using a thread-safe `Once`\n+// So long as `Capture` is `Sync`, `LazilyResolvedCapture` is too\n+unsafe impl Sync for LazilyResolvedCapture where Capture: Sync {}\n+\n impl Capture {\n     fn resolve(&mut self) {\n         // If we're already resolved, nothing to do!"}, {"sha": "31cf0f702185c9ca47e0df66821f302b673d0334", "filename": "library/std/src/backtrace/tests.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e73ee1dde270cf1f7dc0e3f3eb3366c6fdc391c6/library%2Fstd%2Fsrc%2Fbacktrace%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e73ee1dde270cf1f7dc0e3f3eb3366c6fdc391c6/library%2Fstd%2Fsrc%2Fbacktrace%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fbacktrace%2Ftests.rs?ref=e73ee1dde270cf1f7dc0e3f3eb3366c6fdc391c6", "patch": "@@ -3,7 +3,7 @@ use super::*;\n #[test]\n fn test_debug() {\n     let backtrace = Backtrace {\n-        inner: Inner::Captured(Mutex::new(Capture {\n+        inner: Inner::Captured(LazilyResolvedCapture::new(Capture {\n             actual_start: 1,\n             resolved: true,\n             frames: vec![\n@@ -54,4 +54,7 @@ fn test_debug() {\n     \\n]\";\n \n     assert_eq!(format!(\"{:#?}\", backtrace), expected);\n+\n+    // Format the backtrace a second time, just to make sure lazily resolved state is stable\n+    assert_eq!(format!(\"{:#?}\", backtrace), expected);\n }"}]}