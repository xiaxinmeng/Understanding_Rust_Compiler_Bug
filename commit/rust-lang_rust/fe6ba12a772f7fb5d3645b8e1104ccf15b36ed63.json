{"sha": "fe6ba12a772f7fb5d3645b8e1104ccf15b36ed63", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZlNmJhMTJhNzcyZjdmYjVkMzY0NWI4ZTExMDRjY2YxNWIzNmVkNjM=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2019-11-04T09:06:53Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-11-04T09:06:53Z"}, "message": "Merge #2149\n\n2149: Handle IfLet in convert_to_guarded_return. r=matklad a=krk\n\nFixes https://github.com/rust-analyzer/rust-analyzer/issues/2124\r\n\r\nI could not move the cursor position out of `let`:\r\n`le<|>t` vs `let<|>`.\r\n\r\nAlso, please suggest extra test cases.\n\nCo-authored-by: krk <keremkat@gmail.com>", "tree": {"sha": "fec106c13469a149c9d51efc867713b17f44f4fa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fec106c13469a149c9d51efc867713b17f44f4fa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fe6ba12a772f7fb5d3645b8e1104ccf15b36ed63", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdv+otCRBK7hj4Ov3rIwAAdHIIAGPMiTfg4eWzb/Jlv13ypCGr\njWMhgF+VTKfwbRAHdA/jma941yRYgil667+UEgCt5UZDyw0I/6g0laKm0ScnsUwd\na2mxsfzjZm/vAZWSZrUfD5AMK/+xsAb9GxrK00oOkJAJyVwR/+SvI0cyKT5A8rPB\nLI930K0vmE5YWG0rXMOrOYEnfP/ZDiKIQZxbDIiEZFg7XlBK5gYpcWhKl3L+0tkY\nrB1oufrTjjsI3CcjRJ3K2b1dTtDkvPxal627DwQ8Bgqpzb3atDugxpVSKgd3CNGl\nYw1+skI9XnMGqaiKjF4SKLp/8CTdo/5oVZ1QP6mGmUSo5az4p4rWV9G5yNXjitw=\n=xJIV\n-----END PGP SIGNATURE-----\n", "payload": "tree fec106c13469a149c9d51efc867713b17f44f4fa\nparent 5c35539f0f69472546253d415c30f524d0a1a212\nparent bc14f500a0b0e1349d0f795b85dde5946da113bd\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1572858413 +0000\ncommitter GitHub <noreply@github.com> 1572858413 +0000\n\nMerge #2149\n\n2149: Handle IfLet in convert_to_guarded_return. r=matklad a=krk\n\nFixes https://github.com/rust-analyzer/rust-analyzer/issues/2124\r\n\r\nI could not move the cursor position out of `let`:\r\n`le<|>t` vs `let<|>`.\r\n\r\nAlso, please suggest extra test cases.\n\nCo-authored-by: krk <keremkat@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fe6ba12a772f7fb5d3645b8e1104ccf15b36ed63", "html_url": "https://github.com/rust-lang/rust/commit/fe6ba12a772f7fb5d3645b8e1104ccf15b36ed63", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fe6ba12a772f7fb5d3645b8e1104ccf15b36ed63/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5c35539f0f69472546253d415c30f524d0a1a212", "url": "https://api.github.com/repos/rust-lang/rust/commits/5c35539f0f69472546253d415c30f524d0a1a212", "html_url": "https://github.com/rust-lang/rust/commit/5c35539f0f69472546253d415c30f524d0a1a212"}, {"sha": "bc14f500a0b0e1349d0f795b85dde5946da113bd", "url": "https://api.github.com/repos/rust-lang/rust/commits/bc14f500a0b0e1349d0f795b85dde5946da113bd", "html_url": "https://github.com/rust-lang/rust/commit/bc14f500a0b0e1349d0f795b85dde5946da113bd"}], "stats": {"total": 236, "additions": 207, "deletions": 29}, "files": [{"sha": "570a07a20c56620b83d4e3e7898d529ca758fa2c", "filename": "crates/ra_assists/src/assists/early_return.rs", "status": "modified", "additions": 190, "deletions": 29, "changes": 219, "blob_url": "https://github.com/rust-lang/rust/blob/fe6ba12a772f7fb5d3645b8e1104ccf15b36ed63/crates%2Fra_assists%2Fsrc%2Fassists%2Fearly_return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe6ba12a772f7fb5d3645b8e1104ccf15b36ed63/crates%2Fra_assists%2Fsrc%2Fassists%2Fearly_return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fassists%2Fearly_return.rs?ref=fe6ba12a772f7fb5d3645b8e1104ccf15b36ed63", "patch": "@@ -3,9 +3,10 @@ use std::ops::RangeInclusive;\n use hir::db::HirDatabase;\n use ra_syntax::{\n     algo::replace_children,\n-    ast::{self, edit::IndentLevel, make},\n+    ast::{self, edit::IndentLevel, make, Block, Pat::TupleStructPat},\n     AstNode,\n     SyntaxKind::{FN_DEF, LOOP_EXPR, L_CURLY, R_CURLY, WHILE_EXPR, WHITESPACE},\n+    SyntaxNode,\n };\n \n use crate::{\n@@ -37,7 +38,23 @@ use crate::{\n // ```\n pub(crate) fn convert_to_guarded_return(ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n     let if_expr: ast::IfExpr = ctx.find_node_at_offset()?;\n-    let expr = if_expr.condition()?.expr()?;\n+    let cond = if_expr.condition()?;\n+    let mut if_let_ident: Option<String> = None;\n+\n+    // Check if there is an IfLet that we can handle.\n+    match cond.pat() {\n+        None => {} // No IfLet, supported.\n+        Some(TupleStructPat(ref pat)) if pat.args().count() == 1usize => match &pat.path() {\n+            Some(p) => match p.qualifier() {\n+                None => if_let_ident = Some(p.syntax().text().to_string()),\n+                _ => return None,\n+            },\n+            _ => return None,\n+        },\n+        _ => return None, // Unsupported IfLet.\n+    };\n+\n+    let expr = cond.expr()?;\n     let then_block = if_expr.then_branch()?.block()?;\n     if if_expr.else_branch().is_some() {\n         return None;\n@@ -63,8 +80,8 @@ pub(crate) fn convert_to_guarded_return(ctx: AssistCtx<impl HirDatabase>) -> Opt\n     let parent_container = parent_block.syntax().parent()?.parent()?;\n \n     let early_expression = match parent_container.kind() {\n-        WHILE_EXPR | LOOP_EXPR => Some(\"continue;\"),\n-        FN_DEF => Some(\"return;\"),\n+        WHILE_EXPR | LOOP_EXPR => Some(\"continue\"),\n+        FN_DEF => Some(\"return\"),\n         _ => None,\n     }?;\n \n@@ -77,34 +94,58 @@ pub(crate) fn convert_to_guarded_return(ctx: AssistCtx<impl HirDatabase>) -> Opt\n \n     ctx.add_assist(AssistId(\"convert_to_guarded_return\"), \"convert to guarded return\", |edit| {\n         let if_indent_level = IndentLevel::from_node(&if_expr.syntax());\n-        let new_if_expr =\n-            if_indent_level.increase_indent(make::if_expression(&expr, early_expression));\n-        let then_block_items = IndentLevel::from(1).decrease_indent(then_block.clone());\n-        let end_of_then = then_block_items.syntax().last_child_or_token().unwrap();\n-        let end_of_then =\n-            if end_of_then.prev_sibling_or_token().map(|n| n.kind()) == Some(WHITESPACE) {\n-                end_of_then.prev_sibling_or_token().unwrap()\n-            } else {\n-                end_of_then\n-            };\n-        let mut new_if_and_then_statements = new_if_expr.syntax().children_with_tokens().chain(\n-            then_block_items\n-                .syntax()\n-                .children_with_tokens()\n-                .skip(1)\n-                .take_while(|i| *i != end_of_then),\n-        );\n-        let new_block = replace_children(\n-            &parent_block.syntax(),\n-            RangeInclusive::new(\n-                if_expr.clone().syntax().clone().into(),\n-                if_expr.syntax().clone().into(),\n-            ),\n-            &mut new_if_and_then_statements,\n-        );\n+        let new_block = match if_let_ident {\n+            None => {\n+                // If.\n+                let early_expression = &(early_expression.to_owned() + \";\");\n+                let new_expr =\n+                    if_indent_level.increase_indent(make::if_expression(&expr, early_expression));\n+                replace(new_expr, &then_block, &parent_block, &if_expr)\n+            }\n+            Some(if_let_ident) => {\n+                // If-let.\n+                let new_expr = if_indent_level.increase_indent(make::let_match_early(\n+                    expr,\n+                    &if_let_ident,\n+                    early_expression,\n+                ));\n+                replace(new_expr, &then_block, &parent_block, &if_expr)\n+            }\n+        };\n         edit.target(if_expr.syntax().text_range());\n         edit.replace_ast(parent_block, ast::Block::cast(new_block).unwrap());\n         edit.set_cursor(cursor_position);\n+\n+        fn replace(\n+            new_expr: impl AstNode,\n+            then_block: &Block,\n+            parent_block: &Block,\n+            if_expr: &ast::IfExpr,\n+        ) -> SyntaxNode {\n+            let then_block_items = IndentLevel::from(1).decrease_indent(then_block.clone());\n+            let end_of_then = then_block_items.syntax().last_child_or_token().unwrap();\n+            let end_of_then =\n+                if end_of_then.prev_sibling_or_token().map(|n| n.kind()) == Some(WHITESPACE) {\n+                    end_of_then.prev_sibling_or_token().unwrap()\n+                } else {\n+                    end_of_then\n+                };\n+            let mut then_statements = new_expr.syntax().children_with_tokens().chain(\n+                then_block_items\n+                    .syntax()\n+                    .children_with_tokens()\n+                    .skip(1)\n+                    .take_while(|i| *i != end_of_then),\n+            );\n+            replace_children(\n+                &parent_block.syntax(),\n+                RangeInclusive::new(\n+                    if_expr.clone().syntax().clone().into(),\n+                    if_expr.syntax().clone().into(),\n+                ),\n+                &mut then_statements,\n+            )\n+        }\n     })\n }\n \n@@ -143,6 +184,68 @@ mod tests {\n         );\n     }\n \n+    #[test]\n+    fn convert_let_inside_fn() {\n+        check_assist(\n+            convert_to_guarded_return,\n+            r#\"\n+            fn main(n: Option<String>) {\n+                bar();\n+                if<|> let Some(n) = n {\n+                    foo(n);\n+\n+                    //comment\n+                    bar();\n+                }\n+            }\n+            \"#,\n+            r#\"\n+            fn main(n: Option<String>) {\n+                bar();\n+                le<|>t n = match n {\n+                    Some(it) => it,\n+                    None => return,\n+                };\n+                foo(n);\n+\n+                //comment\n+                bar();\n+            }\n+            \"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn convert_let_ok_inside_fn() {\n+        check_assist(\n+            convert_to_guarded_return,\n+            r#\"\n+            fn main(n: Option<String>) {\n+                bar();\n+                if<|> let Ok(n) = n {\n+                    foo(n);\n+\n+                    //comment\n+                    bar();\n+                }\n+            }\n+            \"#,\n+            r#\"\n+            fn main(n: Option<String>) {\n+                bar();\n+                le<|>t n = match n {\n+                    Ok(it) => it,\n+                    None => return,\n+                };\n+                foo(n);\n+\n+                //comment\n+                bar();\n+            }\n+            \"#,\n+        );\n+    }\n+\n     #[test]\n     fn convert_inside_while() {\n         check_assist(\n@@ -171,6 +274,35 @@ mod tests {\n         );\n     }\n \n+    #[test]\n+    fn convert_let_inside_while() {\n+        check_assist(\n+            convert_to_guarded_return,\n+            r#\"\n+            fn main() {\n+                while true {\n+                    if<|> let Some(n) = n {\n+                        foo(n);\n+                        bar();\n+                    }\n+                }\n+            }\n+            \"#,\n+            r#\"\n+            fn main() {\n+                while true {\n+                    le<|>t n = match n {\n+                        Some(it) => it,\n+                        None => continue,\n+                    };\n+                    foo(n);\n+                    bar();\n+                }\n+            }\n+            \"#,\n+        );\n+    }\n+\n     #[test]\n     fn convert_inside_loop() {\n         check_assist(\n@@ -199,6 +331,35 @@ mod tests {\n         );\n     }\n \n+    #[test]\n+    fn convert_let_inside_loop() {\n+        check_assist(\n+            convert_to_guarded_return,\n+            r#\"\n+            fn main() {\n+                loop {\n+                    if<|> let Some(n) = n {\n+                        foo(n);\n+                        bar();\n+                    }\n+                }\n+            }\n+            \"#,\n+            r#\"\n+            fn main() {\n+                loop {\n+                    le<|>t n = match n {\n+                        Some(it) => it,\n+                        None => continue,\n+                    };\n+                    foo(n);\n+                    bar();\n+                }\n+            }\n+            \"#,\n+        );\n+    }\n+\n     #[test]\n     fn ignore_already_converted_if() {\n         check_assist_not_applicable("}, {"sha": "95062ef6c467a92829924e02d6563540a6cb616f", "filename": "crates/ra_syntax/src/ast/make.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/fe6ba12a772f7fb5d3645b8e1104ccf15b36ed63/crates%2Fra_syntax%2Fsrc%2Fast%2Fmake.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe6ba12a772f7fb5d3645b8e1104ccf15b36ed63/crates%2Fra_syntax%2Fsrc%2Fast%2Fmake.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fmake.rs?ref=fe6ba12a772f7fb5d3645b8e1104ccf15b36ed63", "patch": "@@ -110,6 +110,23 @@ pub fn match_arm_list(arms: impl Iterator<Item = ast::MatchArm>) -> ast::MatchAr\n     }\n }\n \n+pub fn let_match_early(expr: ast::Expr, path: &str, early_expression: &str) -> ast::LetStmt {\n+    return from_text(&format!(\n+        r#\"let {} = match {} {{\n+    {}(it) => it,\n+    None => {},\n+}};\"#,\n+        expr.syntax().text(),\n+        expr.syntax().text(),\n+        path,\n+        early_expression\n+    ));\n+\n+    fn from_text(text: &str) -> ast::LetStmt {\n+        ast_from_text(&format!(\"fn f() {{ {} }}\", text))\n+    }\n+}\n+\n pub fn where_pred(path: ast::Path, bounds: impl Iterator<Item = ast::TypeBound>) -> ast::WherePred {\n     let bounds = bounds.map(|b| b.syntax().to_string()).join(\" + \");\n     return from_text(&format!(\"{}: {}\", path.syntax(), bounds));"}]}