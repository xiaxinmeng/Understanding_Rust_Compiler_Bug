{"sha": "8e0f486ea6fb168f5ffd61febd71217e5d16d1bf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhlMGY0ODZlYTZmYjE2OGY1ZmZkNjFmZWJkNzEyMTdlNWQxNmQxYmY=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-08-25T21:42:28Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-08-25T21:42:28Z"}, "message": "First pass of updating the in-memory layout of closures, for issue 81.", "tree": {"sha": "f2e631cb7c381092457c7aa34ed7d595afa2d10f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f2e631cb7c381092457c7aa34ed7d595afa2d10f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8e0f486ea6fb168f5ffd61febd71217e5d16d1bf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8e0f486ea6fb168f5ffd61febd71217e5d16d1bf", "html_url": "https://github.com/rust-lang/rust/commit/8e0f486ea6fb168f5ffd61febd71217e5d16d1bf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8e0f486ea6fb168f5ffd61febd71217e5d16d1bf/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c2b6c27d65f09647d95bef39e2feefd767d045c1", "url": "https://api.github.com/repos/rust-lang/rust/commits/c2b6c27d65f09647d95bef39e2feefd767d045c1", "html_url": "https://github.com/rust-lang/rust/commit/c2b6c27d65f09647d95bef39e2feefd767d045c1"}], "stats": {"total": 274, "additions": 153, "deletions": 121}, "files": [{"sha": "32c9f44ac991df0fe64f98df766a05cd89e4a077", "filename": "src/boot/be/abi.ml", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/8e0f486ea6fb168f5ffd61febd71217e5d16d1bf/src%2Fboot%2Fbe%2Fabi.ml", "raw_url": "https://github.com/rust-lang/rust/raw/8e0f486ea6fb168f5ffd61febd71217e5d16d1bf/src%2Fboot%2Fbe%2Fabi.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fbe%2Fabi.ml?ref=8e0f486ea6fb168f5ffd61febd71217e5d16d1bf", "patch": "@@ -45,9 +45,9 @@ let stk_field_valgrind_id = 0;;\n let stk_field_limit = stk_field_valgrind_id + 1;;\n let stk_field_data = stk_field_limit + 1;;\n \n-(* Both obj and fn are two-word \"bindings\":  One word points to some\n- * static dispatch information (vtbl or thunk), and the other points to\n- * some bag of bound data (object-body or closure).\n+(* Both obj and fn are two-word \"bindings\": One word points to some static\n+ * dispatch information (vtbl, thunk, callee), and the other points to some\n+ * box of bound data (object-body or closure).\n  *)\n \n let binding_field_dispatch = 0;;\n@@ -59,11 +59,12 @@ let obj_field_box = binding_field_bound_data;;\n let obj_body_elt_tydesc = 0;;\n let obj_body_elt_fields = 1;;\n \n-let fn_field_thunk = binding_field_dispatch;;\n-let fn_field_closure = binding_field_bound_data;;\n-let closure_elt_rc = 0;;\n-let closure_elt_target = 1;;\n-let closure_elt_bound_args = 2;;\n+let fn_field_code = binding_field_dispatch;;\n+let fn_field_box = binding_field_bound_data;;\n+\n+let closure_body_elt_tydesc = 0;;\n+let closure_body_elt_target = 1;;\n+let closure_body_elt_bound_args = 2;;\n \n let tag_elt_discriminant = 0;;\n let tag_elt_variant = 1;;"}, {"sha": "8a7d6aa015a421794ed6dbcabe37e3bbc8024043", "filename": "src/boot/me/semant.ml", "status": "modified", "additions": 60, "deletions": 23, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/8e0f486ea6fb168f5ffd61febd71217e5d16d1bf/src%2Fboot%2Fme%2Fsemant.ml", "raw_url": "https://github.com/rust-lang/rust/raw/8e0f486ea6fb168f5ffd61febd71217e5d16d1bf/src%2Fboot%2Fme%2Fsemant.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Fsemant.ml?ref=8e0f486ea6fb168f5ffd61febd71217e5d16d1bf", "patch": "@@ -36,7 +36,7 @@ type glue =\n   | GLUE_mark_frame of node_id    (* Node is the frame.                 *)\n   | GLUE_drop_frame of node_id    (* Node is the frame.                 *)\n   | GLUE_reloc_frame of node_id   (* Node is the frame.                 *)\n-  | GLUE_fn_binding of node_id    (* Node is the 'bind' stmt.           *)\n+  | GLUE_fn_thunk of node_id      (* Node is the 'bind' stmt.           *)\n   | GLUE_obj_drop of node_id      (* Node is the obj.                   *)\n   | GLUE_loop_body of node_id     (* Node is the 'for each' body block. *)\n   | GLUE_forward of (Ast.ident * Ast.ty_obj * Ast.ty_obj)\n@@ -1878,21 +1878,64 @@ let tydesc_rty (word_bits:Il.bits) : Il.referent_ty =\n     |]\n ;;\n \n-(* \n- * [ rc [ tydesc* | obj-body ] ]\n- *)\n let obj_box_rty (word_bits:Il.bits) : Il.referent_ty =\n-  Il.StructTy [|\n-    word_rty word_bits;\n-    Il.StructTy [|\n-      Il.ScalarTy (Il.AddrTy (tydesc_rty word_bits));\n-      word_rty word_bits (* A lie: it's opaque, but this permits\n-                          * GEP'ing to it. *)\n-    |]\n-  |]\n+  let s t = Il.ScalarTy t in\n+  let p t = Il.AddrTy t in\n+  let sp t = s (p t) in\n+  let r rtys = Il.StructTy rtys in\n+\n+  let rc = word_rty word_bits in\n+  let tydesc = sp (tydesc_rty word_bits) in\n+\n+  (* This is a lie: it's opaque, but this permits GEP'ing to it. *)\n+  let fields = word_rty word_bits in\n+\n+    r [| rc; r [| tydesc; fields |] |]\n ;;\n \n-let rec referent_type (word_bits:Il.bits) (t:Ast.ty) : Il.referent_ty =\n+let obj_rty (word_bits:Il.bits) : Il.referent_ty =\n+  let s t = Il.ScalarTy t in\n+  let p t = Il.AddrTy t in\n+  let sp t = s (p t) in\n+  let r rtys = Il.StructTy rtys in\n+\n+  let obj_box_ptr = sp (obj_box_rty word_bits) in\n+  let obj_vtbl_ptr = sp Il.OpaqueTy in\n+\n+    r [| obj_vtbl_ptr; obj_box_ptr |]\n+;;\n+\n+\n+\n+let rec closure_box_rty\n+    (word_bits:Il.bits)\n+    (bs:Ast.slot array)\n+    : Il.referent_ty =\n+  let s t = Il.ScalarTy t in\n+  let p t = Il.AddrTy t in\n+  let sp t = s (p t) in\n+  let r rtys = Il.StructTy rtys in\n+\n+  let rc = word_rty word_bits in\n+  let tydesc = sp (tydesc_rty word_bits) in\n+  let targ = fn_rty word_bits in\n+  let bound_args = r (Array.map (slot_referent_type word_bits) bs) in\n+\n+    r [| rc; r [| tydesc; targ; bound_args |] |]\n+\n+and fn_rty (word_bits:Il.bits) : Il.referent_ty =\n+  let s t = Il.ScalarTy t in\n+  let p t = Il.AddrTy t in\n+  let sp t = s (p t) in\n+  let r rtys = Il.StructTy rtys in\n+  let word = word_rty word_bits in\n+\n+  let box_ptr = sp (Il.StructTy [| word; Il.OpaqueTy |]) in\n+  let code_ptr = sp Il.CodeTy in\n+\n+    r [| code_ptr; box_ptr |]\n+\n+and referent_type (word_bits:Il.bits) (t:Ast.ty) : Il.referent_ty =\n   let s t = Il.ScalarTy t in\n   let v b = Il.ValTy b in\n   let p t = Il.AddrTy t in\n@@ -1902,7 +1945,6 @@ let rec referent_type (word_bits:Il.bits) (t:Ast.ty) : Il.referent_ty =\n   let word = word_rty word_bits in\n   let ptr = sp Il.OpaqueTy in\n   let rc_ptr = sp (Il.StructTy [| word; Il.OpaqueTy |]) in\n-  let codeptr = sp Il.CodeTy in\n   let tup ttup = Il.StructTy (Array.map (referent_type word_bits) ttup) in\n   let tag ttag =\n     let union =\n@@ -1943,13 +1985,8 @@ let rec referent_type (word_bits:Il.bits) (t:Ast.ty) : Il.referent_ty =\n       | Ast.TY_tup tt -> tup tt\n       | Ast.TY_rec tr -> tup (Array.map snd tr)\n \n-      | Ast.TY_fn _ ->\n-          let fn_closure_ptr = sp (Il.StructTy [| word; Il.OpaqueTy |]) in\n-            Il.StructTy [| codeptr; fn_closure_ptr |]\n-\n-      | Ast.TY_obj _ ->\n-          let obj_box_ptr = sp (obj_box_rty word_bits) in\n-            Il.StructTy [| ptr; obj_box_ptr |]\n+      | Ast.TY_fn _ -> fn_rty word_bits\n+      | Ast.TY_obj _ -> obj_rty word_bits\n \n       | Ast.TY_tag ttag -> tag ttag\n       | Ast.TY_iso tiso -> tag tiso.Ast.iso_group.(tiso.Ast.iso_index)\n@@ -2292,8 +2329,8 @@ let glue_str (cx:ctxt) (g:glue) : string =\n          * a statement; lookup bind target and encode bound arg \n          * tuple type.\n          *)\n-    | GLUE_fn_binding i\n-      -> \"glue$fn_binding$\" ^ (string_of_int (int_of_node i))\n+    | GLUE_fn_thunk i\n+      -> \"glue$fn_thunk$\" ^ (string_of_int (int_of_node i))\n     | GLUE_obj_drop oid\n       -> (item_str cx oid) ^ \".drop\"\n     | GLUE_loop_body i"}, {"sha": "a37ed460809a2a0346dd3c852663748b87db77f6", "filename": "src/boot/me/trans.ml", "status": "modified", "additions": 84, "deletions": 90, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/8e0f486ea6fb168f5ffd61febd71217e5d16d1bf/src%2Fboot%2Fme%2Ftrans.ml", "raw_url": "https://github.com/rust-lang/rust/raw/8e0f486ea6fb168f5ffd61febd71217e5d16d1bf/src%2Fboot%2Fme%2Ftrans.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Ftrans.ml?ref=8e0f486ea6fb168f5ffd61febd71217e5d16d1bf", "patch": "@@ -1452,49 +1452,15 @@ let trans_visitor\n               emit_exit_task_glue fix g;\n               fix\n \n-  (*\n-   * Closure representation has 3 GEP-parts:\n-   * \n-   *  ......\n-   *  . gc . gc control word, if mutable\n-   *  +----+\n-   *  | rc | refcount\n-   *  +----+\n-   * \n-   *  +----+\n-   *  | tf | ----> pair of fn+binding that closure \n-   *  +----+   /   targets\n-   *  | tb | --\n-   *  +----+\n-   * \n-   *  +----+\n-   *  | b1 | bound arg1\n-   *  +----+\n-   *  .    .\n-   *  .    .\n-   *  .    .\n-   *  +----+\n-   *  | bN | bound argN\n-   *  +----+\n-   *)\n-\n-  and closure_referent_type\n-      (bs:Ast.slot array)\n-      (* FIXME (issue #5): mutability flag *)\n-      : Il.referent_ty =\n-    let rc = Il.ScalarTy word_sty in\n-    let targ = referent_type word_bits (mk_simple_ty_fn [||]) in\n-    let bindings = Array.map (slot_referent_type word_bits) bs in\n-      Il.StructTy [| rc; targ; Il.StructTy bindings |]\n-\n   (* FIXME (issue #2): this should eventually use tail calling logic *)\n \n-  and emit_fn_binding_glue\n+  and emit_fn_thunk_glue\n       (arg_slots:Ast.slot array)\n       (arg_bound_flags:bool array)\n       (fix:fixup)\n       (g:glue)\n       : unit =\n+\n     let extract_slots want_bound =\n       arr_filter_some\n         (arr_map2\n@@ -1505,14 +1471,16 @@ let trans_visitor\n     in\n     let bound_slots = extract_slots true in\n     let unbound_slots = extract_slots false in\n+\n     let (self_ty:Ast.ty) = mk_simple_ty_fn unbound_slots in\n     let (callee_ty:Ast.ty) = mk_simple_ty_fn arg_slots in\n \n-    let self_closure_rty = closure_referent_type bound_slots in\n-    (* FIXME (issue #81): binding type parameters doesn't work. *)\n+    let self_box_rty = closure_box_rty word_bits bound_slots in\n+\n     let self_args_rty =\n-      call_args_referent_type cx 0 self_ty (Some self_closure_rty)\n+      call_args_referent_type cx 0 self_ty (Some self_box_rty)\n     in\n+\n     let callee_args_rty =\n       call_args_referent_type cx 0 callee_ty (Some Il.OpaqueTy)\n     in\n@@ -1522,40 +1490,48 @@ let trans_visitor\n       trans_glue_frame_entry callsz spill;\n \n       let all_self_args_cell = caller_args_cell self_args_rty in\n+\n       let self_indirect_args_cell =\n         get_element_ptr all_self_args_cell Abi.calltup_elt_indirect_args\n       in\n-      let closure_cell =\n+\n+      let box_cell =\n         deref (get_element_ptr self_indirect_args_cell\n                  Abi.indirect_args_elt_closure)\n       in\n+\n+      let closure_cell =\n+        get_element_ptr box_cell Abi.box_rc_field_body\n+      in\n+\n       let closure_target_cell =\n-        get_element_ptr closure_cell Abi.fn_field_closure\n+        get_element_ptr closure_cell Abi.closure_body_elt_target\n       in\n-      let closure_target_fn_cell =\n-        get_element_ptr closure_target_cell Abi.fn_field_thunk\n+\n+      let closure_target_code_cell =\n+        get_element_ptr closure_target_cell Abi.fn_field_code\n       in\n \n         merge_bound_args\n           self_args_rty callee_args_rty\n           arg_slots arg_bound_flags;\n         iflog (fun _ -> annotate \"call through to closure target fn\");\n \n-        call_code (code_of_cell closure_target_fn_cell);\n+        call_code (code_of_cell closure_target_code_cell);\n         trans_glue_frame_exit fix spill g\n \n \n-  and get_fn_binding_glue\n+  and get_fn_thunk_glue\n       (bind_id:node_id)\n       (arg_slots:Ast.slot array)\n       (arg_bound_flags:bool array)\n       : fixup =\n-    let g = GLUE_fn_binding bind_id in\n+    let g = GLUE_fn_thunk bind_id in\n       match htab_search cx.ctxt_glue_code g with\n           Some code -> code.code_fixup\n         | None ->\n             let fix = new_fixup (glue_str cx g) in\n-              emit_fn_binding_glue arg_slots arg_bound_flags fix g;\n+              emit_fn_thunk_glue arg_slots arg_bound_flags fix g;\n               fix\n \n \n@@ -2630,14 +2606,14 @@ let trans_visitor\n \n           Ast.TY_fn _ ->\n             note_drop_step ty \"drop_ty: fn path\";\n-            let binding = get_element_ptr cell Abi.fn_field_closure in\n-            let null_jmp = null_check binding in\n+            let box = get_element_ptr cell Abi.fn_field_box in\n+            let null_jmp = null_check box in\n               (* Drop non-null bindings. *)\n               (* FIXME (issue #58): this is completely wrong, Closures need to\n                * carry tydescs like objs. For now this only works by accident,\n                * and will leak closures with box substructure.\n                *)\n-              drop_ty ty_params binding (Ast.TY_box Ast.TY_int) curr_iso;\n+              drop_ty ty_params box (Ast.TY_box Ast.TY_int) curr_iso;\n               patch null_jmp;\n               note_drop_step ty \"drop_ty: done fn path\";\n \n@@ -3389,7 +3365,7 @@ let trans_visitor\n \n         | (_, Ast.EXPR_atom (Ast.ATOM_lval src_lval)) ->\n             if lval_is_direct_fn cx src_lval then\n-              trans_copy_direct_fn dst_cell src_lval\n+              trans_init_direct_fn dst_cell src_lval\n             else\n               (* Possibly-large structure copying *)\n               let (src_cell, src_ty) = trans_lval src_lval in\n@@ -3400,21 +3376,22 @@ let trans_visitor\n                   src_cell src_ty\n                   None\n \n-  and trans_copy_direct_fn\n+  and trans_init_direct_fn\n       (dst_cell:Il.cell)\n       (flv:Ast.lval)\n       : unit =\n     let item = lval_item cx flv in\n     let fix = Hashtbl.find cx.ctxt_fn_fixups item.id in\n \n-    let dst_pair_item_cell =\n-      get_element_ptr dst_cell Abi.fn_field_thunk\n+    let dst_pair_code_cell =\n+      get_element_ptr dst_cell Abi.fn_field_code\n     in\n-    let dst_pair_binding_cell =\n-      get_element_ptr dst_cell Abi.fn_field_closure\n+\n+    let dst_pair_box_cell =\n+      get_element_ptr dst_cell Abi.fn_field_box\n     in\n-      mov dst_pair_item_cell (reify_ptr (Il.ImmPtr (fix, Il.CodeTy)));\n-      mov dst_pair_binding_cell zero\n+      mov dst_pair_code_cell (reify_ptr (Il.ImmPtr (fix, Il.CodeTy)));\n+      mov dst_pair_box_cell zero\n \n \n   and trans_init_structural_from_atoms\n@@ -3636,21 +3613,31 @@ let trans_visitor\n       (bound_args:Ast.atom array)\n       : unit =\n \n-    let rc_cell = get_element_ptr closure_cell Abi.closure_elt_rc in\n-    let targ_cell = get_element_ptr closure_cell Abi.closure_elt_target in\n-    let args_cell = get_element_ptr closure_cell Abi.closure_elt_bound_args in\n+    let rc_cell = get_element_ptr closure_cell Abi.box_rc_field_refcnt in\n+    let body_cell = get_element_ptr closure_cell Abi.box_rc_field_body in\n+    let targ_cell = get_element_ptr body_cell Abi.closure_body_elt_target in\n+    let tydesc_cell = get_element_ptr body_cell Abi.closure_body_elt_tydesc in\n+    let args_cell =\n+      get_element_ptr body_cell Abi.closure_body_elt_bound_args\n+    in\n \n     iflog (fun _ -> annotate \"init closure refcount\");\n     mov rc_cell one;\n \n+    iflog (fun _ -> annotate \"set closure tydesc ptr\");\n+    mov tydesc_cell\n+      (Il.Cell (get_tydesc None\n+                  (Ast.TY_tup (Array.map slot_ty bound_arg_slots))));\n+\n+\n     iflog (fun _ -> annotate \"set closure target code ptr\");\n     mov\n-      (get_element_ptr targ_cell Abi.fn_field_thunk)\n+      (get_element_ptr targ_cell Abi.fn_field_code)\n       (reify_ptr target_fn_ptr);\n \n     iflog (fun _ -> annotate \"set closure target closure ptr\");\n     mov\n-      (get_element_ptr targ_cell Abi.fn_field_closure)\n+      (get_element_ptr targ_cell Abi.fn_field_box)\n       (reify_ptr target_binding_ptr);\n \n     iflog (fun _ -> annotate \"set closure bound args\");\n@@ -3677,28 +3664,31 @@ let trans_visitor\n     in\n     let bound_arg_slots = arr_filter_some arg_slots in\n     let bound_args = arr_filter_some args in\n-    let glue_fixup =\n-      get_fn_binding_glue bind_id fn_sig.Ast.sig_input_slots arg_bound_flags\n+    let thunk_fixup =\n+      get_fn_thunk_glue bind_id fn_sig.Ast.sig_input_slots arg_bound_flags\n+    in\n+    let target_code_ptr = callee_code_ptr target_ptr cc in\n+    let target_box_ptr = callee_box_ptr flv cc in\n+    let closure_box_rty = closure_box_rty word_bits bound_arg_slots in\n+    let closure_box_sz =\n+      calculate_sz_in_current_frame\n+        (Il.referent_ty_size word_bits closure_box_rty)\n     in\n-    let target_fn_ptr = callee_fn_ptr target_ptr cc in\n-    let target_binding_ptr = callee_binding_ptr flv cc in\n-    let closure_rty = closure_referent_type bound_arg_slots in\n-    let closure_sz = force_sz (Il.referent_ty_size word_bits closure_rty) in\n-    let fn_cell = get_element_ptr dst_cell Abi.fn_field_thunk in\n-    let closure_cell =\n+    let pair_code_cell = get_element_ptr dst_cell Abi.fn_field_code in\n+    let pair_box_cell =\n       ptr_cast\n-        (get_element_ptr dst_cell Abi.fn_field_closure)\n-        (Il.ScalarTy (Il.AddrTy (closure_rty)))\n+        (get_element_ptr dst_cell Abi.fn_field_box)\n+        (Il.ScalarTy (Il.AddrTy (closure_box_rty)))\n     in\n-      iflog (fun _ -> annotate \"assign glue-code to fn slot of pair\");\n-      mov fn_cell (reify_ptr (Il.ImmPtr (glue_fixup, Il.CodeTy)));\n+      iflog (fun _ -> annotate \"assign thunk-ptr to code field of pair\");\n+      mov pair_code_cell (reify_ptr (Il.ImmPtr (thunk_fixup, Il.CodeTy)));\n       iflog (fun _ ->\n                annotate \"heap-allocate closure to binding slot of pair\");\n-      trans_malloc closure_cell (imm closure_sz) zero;\n+      trans_malloc pair_box_cell closure_box_sz zero;\n       trans_init_closure\n-        (deref closure_cell)\n-        target_fn_ptr\n-        target_binding_ptr\n+        (deref pair_box_cell)\n+        target_code_ptr\n+        target_box_ptr\n         bound_arg_slots\n         bound_args\n \n@@ -3947,12 +3937,16 @@ let trans_visitor\n                       Abi.calltup_elt_task_ptr));\n \n         iflog (fun _ -> annotate \"extract closure indirect-arg\");\n-        let closure_cell =\n+        let closure_box_cell =\n           deref (get_element_ptr self_indirect_args_cell\n                    Abi.indirect_args_elt_closure)\n         in\n+        let closure_cell =\n+          get_element_ptr closure_box_cell Abi.box_rc_field_body\n+        in\n+\n         let closure_args_cell =\n-          get_element_ptr closure_cell Abi.closure_elt_bound_args\n+          get_element_ptr closure_cell Abi.closure_body_elt_bound_args\n         in\n \n           for arg_i = 0 to (n_args - 1) do\n@@ -3990,19 +3984,19 @@ let trans_visitor\n     end\n \n \n-  and callee_fn_ptr\n+  and callee_code_ptr\n       (fptr:Il.operand)\n       (cc:call_ctrl)\n       : Il.operand =\n     match cc with\n         CALL_direct\n       | CALL_vtbl -> fptr\n       | CALL_indirect ->\n-          (* fptr is a pair [fptr, binding*] *)\n+          (* fptr is a pair [code*, box*] *)\n           let pair_cell = need_cell (reify_ptr fptr) in\n-            Il.Cell (get_element_ptr pair_cell Abi.fn_field_thunk)\n+            Il.Cell (get_element_ptr pair_cell Abi.fn_field_code)\n \n-  and callee_binding_ptr\n+  and callee_box_ptr\n       (pair_lval:Ast.lval)\n       (cc:call_ctrl)\n       : Il.operand =\n@@ -4054,15 +4048,15 @@ let trans_visitor\n       begin\n         match cc with\n             CALL_direct -> [| |]\n-          | CALL_indirect -> [| callee_binding_ptr flv cc |]\n+          | CALL_indirect -> [| callee_box_ptr flv cc |]\n           | CALL_vtbl ->\n               begin\n                 match flv with\n                     (* FIXME (issue #84): will need to pass both words of obj\n                      * if we add a 'self' value for self-dispatch within\n                      * objs. Also to support forwarding-functions / 'as'.\n                      *)\n-                    Ast.LVAL_ext (base, _) -> [| callee_binding_ptr base cc |]\n+                    Ast.LVAL_ext (base, _) -> [| callee_box_ptr base cc |]\n                   | _ ->\n                       bug (lval_base_id flv)\n                         \"call_indirect_args on obj-fn without base obj\"\n@@ -4074,7 +4068,7 @@ let trans_visitor\n       (caller_is_closure:bool)\n       (call:call)\n       : unit =\n-    let callee_fptr = callee_fn_ptr call.call_callee_ptr call.call_ctrl in\n+    let callee_fptr = callee_code_ptr call.call_callee_ptr call.call_ctrl in\n     let callee_code = code_of_operand callee_fptr in\n     let callee_args_rty =\n       call_args_referent_type cx 0 call.call_callee_ty\n@@ -4106,7 +4100,7 @@ let trans_visitor\n       (call:call)\n       : Il.operand =\n \n-    let callee_fptr = callee_fn_ptr call.call_callee_ptr call.call_ctrl in\n+    let callee_fptr = callee_code_ptr call.call_callee_ptr call.call_ctrl in\n       iflog (fun _ -> annotate\n                (Printf.sprintf \"copy args for call to %s\" (logname ())));\n       copy_fn_args false initializing CLONE_none call;\n@@ -5011,7 +5005,7 @@ let trans_visitor\n             (Il.Cell (get_tydesc\n                         (Some obj_id)\n                         (Ast.TY_tup obj_fields_tup)));\n-          iflog (fun _ -> annotate \"copy ctor args to obj args\");\n+          iflog (fun _ -> annotate \"copy ctor args to obj body fields\");\n           trans_copy_tup\n             frame_ty_params true\n             obj_fields frame_args obj_fields_tup;"}]}