{"sha": "ad5bfd600d1611c9d1bb933a383d0db2fa0ee7bf", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFkNWJmZDYwMGQxNjExYzlkMWJiOTMzYTM4M2QwZGIyZmEwZWU3YmY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-05-13T21:49:48Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-05-13T21:49:48Z"}, "message": "auto merge of #6387 : brson/rust/unstable, r=brson\n\nr? @pcwalton\r\n\r\n* Move `SharedMutableState`, `LittleLock`, and `Exclusive` from `core::unstable` to `core::unstable::sync`\r\n* Modernize the `SharedMutableState` interface with methods\r\n* Rename `SharedMutableState` to `UnsafeAtomicRcBox` to match `RcBox`.", "tree": {"sha": "5f4639e6b344a37bb62b08d5440e441d5e957ece", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5f4639e6b344a37bb62b08d5440e441d5e957ece"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ad5bfd600d1611c9d1bb933a383d0db2fa0ee7bf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ad5bfd600d1611c9d1bb933a383d0db2fa0ee7bf", "html_url": "https://github.com/rust-lang/rust/commit/ad5bfd600d1611c9d1bb933a383d0db2fa0ee7bf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ad5bfd600d1611c9d1bb933a383d0db2fa0ee7bf/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3abc5b3ffb87b51931594f9ce953af648aad342e", "url": "https://api.github.com/repos/rust-lang/rust/commits/3abc5b3ffb87b51931594f9ce953af648aad342e", "html_url": "https://github.com/rust-lang/rust/commit/3abc5b3ffb87b51931594f9ce953af648aad342e"}, {"sha": "369231beb4b29a16c27bcc2c4f9a5679b613ed19", "url": "https://api.github.com/repos/rust-lang/rust/commits/369231beb4b29a16c27bcc2c4f9a5679b613ed19", "html_url": "https://github.com/rust-lang/rust/commit/369231beb4b29a16c27bcc2c4f9a5679b613ed19"}], "stats": {"total": 858, "additions": 434, "deletions": 424}, "files": [{"sha": "322584f8df174049d9ed787886aecd1ca9db77d5", "filename": "src/libcore/comm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad5bfd600d1611c9d1bb933a383d0db2fa0ee7bf/src%2Flibcore%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad5bfd600d1611c9d1bb933a383d0db2fa0ee7bf/src%2Flibcore%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcomm.rs?ref=ad5bfd600d1611c9d1bb933a383d0db2fa0ee7bf", "patch": "@@ -19,8 +19,8 @@ use option::{Option, Some, None};\n use uint;\n use unstable;\n use vec;\n-use unstable::Exclusive;\n use util::replace;\n+use unstable::sync::{Exclusive, exclusive};\n \n use pipes::{recv, try_recv, wait_many, peek, PacketHeader};\n \n@@ -304,7 +304,7 @@ pub struct SharedChan<T> {\n impl<T: Owned> SharedChan<T> {\n     /// Converts a `chan` into a `shared_chan`.\n     pub fn new(c: Chan<T>) -> SharedChan<T> {\n-        SharedChan { ch: unstable::exclusive(c) }\n+        SharedChan { ch: exclusive(c) }\n     }\n }\n "}, {"sha": "0b4c0cf80693149aa79847f900e849e304c4a696", "filename": "src/libcore/core.rc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ad5bfd600d1611c9d1bb933a383d0db2fa0ee7bf/src%2Flibcore%2Fcore.rc", "raw_url": "https://github.com/rust-lang/rust/raw/ad5bfd600d1611c9d1bb933a383d0db2fa0ee7bf/src%2Flibcore%2Fcore.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rc?ref=ad5bfd600d1611c9d1bb933a383d0db2fa0ee7bf", "patch": "@@ -238,6 +238,7 @@ pub mod util;\n /* Unsupported interfaces */\n \n // Private APIs\n+#[path = \"unstable/mod.rs\"]\n pub mod unstable;\n \n /* For internal use, not exported */"}, {"sha": "3e87f4f8dbb1653a405ab42985fbcc4f8e6e7945", "filename": "src/libcore/os.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad5bfd600d1611c9d1bb933a383d0db2fa0ee7bf/src%2Flibcore%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad5bfd600d1611c9d1bb933a383d0db2fa0ee7bf/src%2Flibcore%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fos.rs?ref=ad5bfd600d1611c9d1bb933a383d0db2fa0ee7bf", "patch": "@@ -152,7 +152,7 @@ FIXME #4726: It would probably be appropriate to make this a real global\n */\n fn with_env_lock<T>(f: &fn() -> T) -> T {\n     use unstable::global::global_data_clone_create;\n-    use unstable::{Exclusive, exclusive};\n+    use unstable::sync::{Exclusive, exclusive};\n \n     struct SharedValue(());\n     type ValueMutex = Exclusive<SharedValue>;\n@@ -855,7 +855,7 @@ pub fn change_dir(p: &Path) -> bool {\n /// is otherwise unsuccessful.\n pub fn change_dir_locked(p: &Path, action: &fn()) -> bool {\n     use unstable::global::global_data_clone_create;\n-    use unstable::{Exclusive, exclusive};\n+    use unstable::sync::{Exclusive, exclusive};\n \n     fn key(_: Exclusive<()>) { }\n "}, {"sha": "545f1ac8adaa88f02cc98867f2a86c7ddb010d4f", "filename": "src/libcore/task/spawn.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ad5bfd600d1611c9d1bb933a383d0db2fa0ee7bf/src%2Flibcore%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad5bfd600d1611c9d1bb933a383d0db2fa0ee7bf/src%2Flibcore%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fspawn.rs?ref=ad5bfd600d1611c9d1bb933a383d0db2fa0ee7bf", "patch": "@@ -90,6 +90,7 @@ use task::{ExistingScheduler, SchedulerHandle};\n use task::unkillable;\n use uint;\n use util;\n+use unstable::sync::{Exclusive, exclusive};\n \n #[cfg(test)] use task::default_task_opts;\n \n@@ -128,7 +129,7 @@ struct TaskGroupData {\n     // tasks in this group.\n     descendants: TaskSet,\n }\n-type TaskGroupArc = unstable::Exclusive<Option<TaskGroupData>>;\n+type TaskGroupArc = Exclusive<Option<TaskGroupData>>;\n \n type TaskGroupInner<'self> = &'self mut Option<TaskGroupData>;\n \n@@ -158,7 +159,7 @@ struct AncestorNode {\n     ancestors:      AncestorList,\n }\n \n-struct AncestorList(Option<unstable::Exclusive<AncestorNode>>);\n+struct AncestorList(Option<Exclusive<AncestorNode>>);\n \n // Accessors for taskgroup arcs and ancestor arcs that wrap the unsafety.\n #[inline(always)]\n@@ -167,7 +168,7 @@ fn access_group<U>(x: &TaskGroupArc, blk: &fn(TaskGroupInner) -> U) -> U {\n }\n \n #[inline(always)]\n-fn access_ancestors<U>(x: &unstable::Exclusive<AncestorNode>,\n+fn access_ancestors<U>(x: &Exclusive<AncestorNode>,\n                        blk: &fn(x: &mut AncestorNode) -> U) -> U {\n     x.with(blk)\n }\n@@ -479,7 +480,7 @@ fn gen_child_taskgroup(linked: bool, supervised: bool)\n                     // here.\n                     let mut members = new_taskset();\n                     taskset_insert(&mut members, spawner);\n-                    let tasks = unstable::exclusive(Some(TaskGroupData {\n+                    let tasks = exclusive(Some(TaskGroupData {\n                         members: members,\n                         descendants: new_taskset(),\n                     }));\n@@ -508,7 +509,7 @@ fn gen_child_taskgroup(linked: bool, supervised: bool)\n             (g, a, spawner_group.is_main)\n         } else {\n             // Child is in a separate group from spawner.\n-            let g = unstable::exclusive(Some(TaskGroupData {\n+            let g = exclusive(Some(TaskGroupData {\n                 members:     new_taskset(),\n                 descendants: new_taskset(),\n             }));\n@@ -528,7 +529,7 @@ fn gen_child_taskgroup(linked: bool, supervised: bool)\n                     };\n                 assert!(new_generation < uint::max_value);\n                 // Build a new node in the ancestor list.\n-                AncestorList(Some(unstable::exclusive(AncestorNode {\n+                AncestorList(Some(exclusive(AncestorNode {\n                     generation: new_generation,\n                     parent_group: Some(spawner_group.tasks.clone()),\n                     ancestors: old_ancestors,"}, {"sha": "25e4d07b01da1f2aadbcef9eaa74a4be09e33ebe", "filename": "src/libcore/unstable.rs", "status": "removed", "additions": 0, "deletions": 354, "changes": 354, "blob_url": "https://github.com/rust-lang/rust/blob/3abc5b3ffb87b51931594f9ce953af648aad342e/src%2Flibcore%2Funstable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3abc5b3ffb87b51931594f9ce953af648aad342e/src%2Flibcore%2Funstable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable.rs?ref=3abc5b3ffb87b51931594f9ce953af648aad342e", "patch": "@@ -1,354 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#[doc(hidden)];\n-\n-use cast;\n-use libc;\n-use comm::{GenericChan, GenericPort};\n-use prelude::*;\n-use task;\n-use task::atomically;\n-use self::finally::Finally;\n-\n-#[path = \"unstable/at_exit.rs\"]\n-pub mod at_exit;\n-#[path = \"unstable/global.rs\"]\n-pub mod global;\n-#[path = \"unstable/finally.rs\"]\n-pub mod finally;\n-#[path = \"unstable/weak_task.rs\"]\n-pub mod weak_task;\n-#[path = \"unstable/exchange_alloc.rs\"]\n-pub mod exchange_alloc;\n-#[path = \"unstable/intrinsics.rs\"]\n-pub mod intrinsics;\n-#[path = \"unstable/simd.rs\"]\n-pub mod simd;\n-#[path = \"unstable/extfmt.rs\"]\n-pub mod extfmt;\n-#[path = \"unstable/lang.rs\"]\n-#[cfg(not(test))]\n-pub mod lang;\n-\n-mod rustrt {\n-    use unstable::{raw_thread, rust_little_lock};\n-\n-    pub extern {\n-        pub unsafe fn rust_create_little_lock() -> rust_little_lock;\n-        pub unsafe fn rust_destroy_little_lock(lock: rust_little_lock);\n-        pub unsafe fn rust_lock_little_lock(lock: rust_little_lock);\n-        pub unsafe fn rust_unlock_little_lock(lock: rust_little_lock);\n-\n-        pub unsafe fn rust_raw_thread_start(f: &(&fn())) -> *raw_thread;\n-        pub unsafe fn rust_raw_thread_join_delete(thread: *raw_thread);\n-    }\n-}\n-\n-#[allow(non_camel_case_types)] // runtime type\n-pub type raw_thread = libc::c_void;\n-\n-/**\n-\n-Start a new thread outside of the current runtime context and wait\n-for it to terminate.\n-\n-The executing thread has no access to a task pointer and will be using\n-a normal large stack.\n-*/\n-pub fn run_in_bare_thread(f: ~fn()) {\n-    let (port, chan) = comm::stream();\n-    // FIXME #4525: Unfortunate that this creates an extra scheduler but it's\n-    // necessary since rust_raw_thread_join_delete is blocking\n-    do task::spawn_sched(task::SingleThreaded) {\n-        unsafe {\n-            let closure: &fn() = || {\n-                f()\n-            };\n-            let thread = rustrt::rust_raw_thread_start(&closure);\n-            rustrt::rust_raw_thread_join_delete(thread);\n-            chan.send(());\n-        }\n-    }\n-    port.recv();\n-}\n-\n-#[test]\n-fn test_run_in_bare_thread() {\n-    let i = 100;\n-    do run_in_bare_thread {\n-        assert!(i == 100);\n-    }\n-}\n-\n-#[test]\n-fn test_run_in_bare_thread_exchange() {\n-    // Does the exchange heap work without the runtime?\n-    let i = ~100;\n-    do run_in_bare_thread {\n-        assert!(i == ~100);\n-    }\n-}\n-\n-fn compare_and_swap(address: &mut int, oldval: int, newval: int) -> bool {\n-    unsafe {\n-        let old = intrinsics::atomic_cxchg(address, oldval, newval);\n-        old == oldval\n-    }\n-}\n-\n-/****************************************************************************\n- * Shared state & exclusive ARC\n- ****************************************************************************/\n-\n-struct ArcData<T> {\n-    count:     libc::intptr_t,\n-    // FIXME(#3224) should be able to make this non-option to save memory\n-    data:      Option<T>,\n-}\n-\n-struct ArcDestruct<T> {\n-    data: *libc::c_void,\n-}\n-\n-#[unsafe_destructor]\n-impl<T> Drop for ArcDestruct<T>{\n-    fn finalize(&self) {\n-        unsafe {\n-            do task::unkillable {\n-                let mut data: ~ArcData<T> = cast::transmute(self.data);\n-                let new_count =\n-                    intrinsics::atomic_xsub(&mut data.count, 1) - 1;\n-                assert!(new_count >= 0);\n-                if new_count == 0 {\n-                    // drop glue takes over.\n-                } else {\n-                    cast::forget(data);\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-fn ArcDestruct<T>(data: *libc::c_void) -> ArcDestruct<T> {\n-    ArcDestruct {\n-        data: data\n-    }\n-}\n-\n-/**\n- * COMPLETELY UNSAFE. Used as a primitive for the safe versions in std::arc.\n- *\n- * Data races between tasks can result in crashes and, with sufficient\n- * cleverness, arbitrary type coercion.\n- */\n-pub type SharedMutableState<T> = ArcDestruct<T>;\n-\n-pub unsafe fn shared_mutable_state<T:Owned>(data: T) ->\n-        SharedMutableState<T> {\n-    let data = ~ArcData { count: 1, data: Some(data) };\n-    let ptr = cast::transmute(data);\n-    ArcDestruct(ptr)\n-}\n-\n-#[inline(always)]\n-pub unsafe fn get_shared_mutable_state<T:Owned>(\n-    rc: *SharedMutableState<T>) -> *mut T\n-{\n-    let ptr: ~ArcData<T> = cast::transmute((*rc).data);\n-    assert!(ptr.count > 0);\n-    let r = cast::transmute(ptr.data.get_ref());\n-    cast::forget(ptr);\n-    return r;\n-}\n-#[inline(always)]\n-pub unsafe fn get_shared_immutable_state<'a,T:Owned>(\n-        rc: &'a SharedMutableState<T>) -> &'a T {\n-    let ptr: ~ArcData<T> = cast::transmute((*rc).data);\n-    assert!(ptr.count > 0);\n-    // Cast us back into the correct region\n-    let r = cast::transmute_region(ptr.data.get_ref());\n-    cast::forget(ptr);\n-    return r;\n-}\n-\n-pub unsafe fn clone_shared_mutable_state<T:Owned>(rc: &SharedMutableState<T>)\n-        -> SharedMutableState<T> {\n-    let mut ptr: ~ArcData<T> = cast::transmute((*rc).data);\n-    let new_count = intrinsics::atomic_xadd(&mut ptr.count, 1) + 1;\n-    assert!(new_count >= 2);\n-    cast::forget(ptr);\n-    ArcDestruct((*rc).data)\n-}\n-\n-impl<T:Owned> Clone for SharedMutableState<T> {\n-    fn clone(&self) -> SharedMutableState<T> {\n-        unsafe {\n-            clone_shared_mutable_state(self)\n-        }\n-    }\n-}\n-\n-/****************************************************************************/\n-\n-#[allow(non_camel_case_types)] // runtime type\n-pub type rust_little_lock = *libc::c_void;\n-\n-struct LittleLock {\n-    l: rust_little_lock,\n-}\n-\n-impl Drop for LittleLock {\n-    fn finalize(&self) {\n-        unsafe {\n-            rustrt::rust_destroy_little_lock(self.l);\n-        }\n-    }\n-}\n-\n-fn LittleLock() -> LittleLock {\n-    unsafe {\n-        LittleLock {\n-            l: rustrt::rust_create_little_lock()\n-        }\n-    }\n-}\n-\n-pub impl LittleLock {\n-    #[inline(always)]\n-    unsafe fn lock<T>(&self, f: &fn() -> T) -> T {\n-        do atomically {\n-            rustrt::rust_lock_little_lock(self.l);\n-            do (|| {\n-                f()\n-            }).finally {\n-                rustrt::rust_unlock_little_lock(self.l);\n-            }\n-        }\n-    }\n-}\n-\n-struct ExData<T> {\n-    lock: LittleLock,\n-    failed: bool,\n-    data: T,\n-}\n-\n-/**\n- * An arc over mutable data that is protected by a lock. For library use only.\n- */\n-pub struct Exclusive<T> {\n-    x: SharedMutableState<ExData<T>>\n-}\n-\n-pub fn exclusive<T:Owned>(user_data: T) -> Exclusive<T> {\n-    let data = ExData {\n-        lock: LittleLock(),\n-        failed: false,\n-        data: user_data\n-    };\n-    Exclusive {\n-        x: unsafe {\n-            shared_mutable_state(data)\n-        }\n-    }\n-}\n-\n-impl<T:Owned> Clone for Exclusive<T> {\n-    // Duplicate an exclusive ARC, as std::arc::clone.\n-    fn clone(&self) -> Exclusive<T> {\n-        Exclusive { x: unsafe { clone_shared_mutable_state(&self.x) } }\n-    }\n-}\n-\n-pub impl<T:Owned> Exclusive<T> {\n-    // Exactly like std::arc::mutex_arc,access(), but with the little_lock\n-    // instead of a proper mutex. Same reason for being unsafe.\n-    //\n-    // Currently, scheduling operations (i.e., yielding, receiving on a pipe,\n-    // accessing the provided condition variable) are prohibited while inside\n-    // the exclusive. Supporting that is a work in progress.\n-    #[inline(always)]\n-    unsafe fn with<U>(&self, f: &fn(x: &mut T) -> U) -> U {\n-        let rec = get_shared_mutable_state(&self.x);\n-        do (*rec).lock.lock {\n-            if (*rec).failed {\n-                fail!(\n-                    ~\"Poisoned exclusive - another task failed inside!\");\n-            }\n-            (*rec).failed = true;\n-            let result = f(&mut (*rec).data);\n-            (*rec).failed = false;\n-            result\n-        }\n-    }\n-\n-    #[inline(always)]\n-    unsafe fn with_imm<U>(&self, f: &fn(x: &T) -> U) -> U {\n-        do self.with |x| {\n-            f(cast::transmute_immut(x))\n-        }\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use comm;\n-    use super::exclusive;\n-    use task;\n-    use uint;\n-\n-    #[test]\n-    fn exclusive_arc() {\n-        let mut futures = ~[];\n-\n-        let num_tasks = 10;\n-        let count = 10;\n-\n-        let total = exclusive(~0);\n-\n-        for uint::range(0, num_tasks) |_i| {\n-            let total = total.clone();\n-            let (port, chan) = comm::stream();\n-            futures.push(port);\n-\n-            do task::spawn || {\n-                for uint::range(0, count) |_i| {\n-                    do total.with |count| {\n-                        **count += 1;\n-                    }\n-                }\n-                chan.send(());\n-            }\n-        };\n-\n-        for futures.each |f| { f.recv() }\n-\n-        do total.with |total| {\n-            assert!(**total == num_tasks * count)\n-        };\n-    }\n-\n-    #[test] #[should_fail] #[ignore(cfg(windows))]\n-    fn exclusive_poison() {\n-        // Tests that if one task fails inside of an exclusive, subsequent\n-        // accesses will also fail.\n-        let x = exclusive(1);\n-        let x2 = x.clone();\n-        do task::try || {\n-            do x2.with |one| {\n-                assert!(*one == 2);\n-            }\n-        };\n-        do x.with |one| {\n-            assert!(*one == 1);\n-        }\n-    }\n-}"}, {"sha": "2d6698fb96adec1f95e5f8b1c90bb146d2c1afb2", "filename": "src/libcore/unstable/global.rs", "status": "modified", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/ad5bfd600d1611c9d1bb933a383d0db2fa0ee7bf/src%2Flibcore%2Funstable%2Fglobal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad5bfd600d1611c9d1bb933a383d0db2fa0ee7bf/src%2Flibcore%2Funstable%2Fglobal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable%2Fglobal.rs?ref=ad5bfd600d1611c9d1bb933a383d0db2fa0ee7bf", "patch": "@@ -31,14 +31,13 @@ use kinds::Owned;\n use libc::{c_void};\n use option::{Option, Some, None};\n use ops::Drop;\n-use unstable::{Exclusive, exclusive};\n+use unstable::sync::{Exclusive, exclusive};\n use unstable::at_exit::at_exit;\n use unstable::intrinsics::atomic_cxchg;\n use hashmap::HashMap;\n use sys::Closure;\n \n-#[cfg(test)] use unstable::{SharedMutableState, shared_mutable_state};\n-#[cfg(test)] use unstable::get_shared_immutable_state;\n+#[cfg(test)] use unstable::sync::{UnsafeAtomicRcBox};\n #[cfg(test)] use task::spawn;\n #[cfg(test)] use uint;\n \n@@ -234,35 +233,31 @@ extern {\n \n #[test]\n fn test_clone_rc() {\n-    type MyType = SharedMutableState<int>;\n-\n-    fn key(_v: SharedMutableState<int>) { }\n+    fn key(_v: UnsafeAtomicRcBox<int>) { }\n \n     for uint::range(0, 100) |_| {\n         do spawn {\n             unsafe {\n                 let val = do global_data_clone_create(key) {\n-                    ~shared_mutable_state(10)\n+                    ~UnsafeAtomicRcBox::new(10)\n                 };\n \n-                assert!(get_shared_immutable_state(&val) == &10);\n+                assert!(val.get() == &10);\n             }\n         }\n     }\n }\n \n #[test]\n fn test_modify() {\n-    type MyType = SharedMutableState<int>;\n-\n-    fn key(_v: SharedMutableState<int>) { }\n+    fn key(_v: UnsafeAtomicRcBox<int>) { }\n \n     unsafe {\n         do global_data_modify(key) |v| {\n             match v {\n                 None => {\n                     unsafe {\n-                        Some(~shared_mutable_state(10))\n+                        Some(~UnsafeAtomicRcBox::new(10))\n                     }\n                 }\n                 _ => fail!()\n@@ -272,7 +267,7 @@ fn test_modify() {\n         do global_data_modify(key) |v| {\n             match v {\n                 Some(sms) => {\n-                    let v = get_shared_immutable_state(sms);\n+                    let v = sms.get();\n                     assert!(*v == 10);\n                     None\n                 },\n@@ -284,7 +279,7 @@ fn test_modify() {\n             match v {\n                 None => {\n                     unsafe {\n-                        Some(~shared_mutable_state(10))\n+                        Some(~UnsafeAtomicRcBox::new(10))\n                     }\n                 }\n                 _ => fail!()"}, {"sha": "bef7a7f87d3bd7a8622ab9c925a8ba395952d4c7", "filename": "src/libcore/unstable/mod.rs", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/ad5bfd600d1611c9d1bb933a383d0db2fa0ee7bf/src%2Flibcore%2Funstable%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad5bfd600d1611c9d1bb933a383d0db2fa0ee7bf/src%2Flibcore%2Funstable%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable%2Fmod.rs?ref=ad5bfd600d1611c9d1bb933a383d0db2fa0ee7bf", "patch": "@@ -0,0 +1,78 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[doc(hidden)];\n+\n+use libc;\n+use comm::{GenericChan, GenericPort};\n+use prelude::*;\n+use task;\n+\n+pub mod at_exit;\n+pub mod global;\n+pub mod finally;\n+pub mod weak_task;\n+pub mod exchange_alloc;\n+pub mod intrinsics;\n+pub mod simd;\n+pub mod extfmt;\n+#[cfg(not(test))]\n+pub mod lang;\n+pub mod sync;\n+\n+/**\n+\n+Start a new thread outside of the current runtime context and wait\n+for it to terminate.\n+\n+The executing thread has no access to a task pointer and will be using\n+a normal large stack.\n+*/\n+pub fn run_in_bare_thread(f: ~fn()) {\n+    let (port, chan) = comm::stream();\n+    // FIXME #4525: Unfortunate that this creates an extra scheduler but it's\n+    // necessary since rust_raw_thread_join_delete is blocking\n+    do task::spawn_sched(task::SingleThreaded) {\n+        unsafe {\n+            let closure: &fn() = || {\n+                f()\n+            };\n+            let thread = rust_raw_thread_start(&closure);\n+            rust_raw_thread_join_delete(thread);\n+            chan.send(());\n+        }\n+    }\n+    port.recv();\n+}\n+\n+#[test]\n+fn test_run_in_bare_thread() {\n+    let i = 100;\n+    do run_in_bare_thread {\n+        assert!(i == 100);\n+    }\n+}\n+\n+#[test]\n+fn test_run_in_bare_thread_exchange() {\n+    // Does the exchange heap work without the runtime?\n+    let i = ~100;\n+    do run_in_bare_thread {\n+        assert!(i == ~100);\n+    }\n+}\n+\n+#[allow(non_camel_case_types)] // runtime type\n+pub type raw_thread = libc::c_void;\n+\n+extern {\n+    fn rust_raw_thread_start(f: &(&fn())) -> *raw_thread;\n+    fn rust_raw_thread_join_delete(thread: *raw_thread);\n+}"}, {"sha": "e22046f04f95b6419a5867218462a9828899635e", "filename": "src/libcore/unstable/sync.rs", "status": "added", "additions": 286, "deletions": 0, "changes": 286, "blob_url": "https://github.com/rust-lang/rust/blob/ad5bfd600d1611c9d1bb933a383d0db2fa0ee7bf/src%2Flibcore%2Funstable%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad5bfd600d1611c9d1bb933a383d0db2fa0ee7bf/src%2Flibcore%2Funstable%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable%2Fsync.rs?ref=ad5bfd600d1611c9d1bb933a383d0db2fa0ee7bf", "patch": "@@ -0,0 +1,286 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use cast;\n+use libc;\n+use option::*;\n+use task;\n+use task::atomically;\n+use unstable::finally::Finally;\n+use unstable::intrinsics;\n+use ops::Drop;\n+use clone::Clone;\n+use kinds::Owned;\n+\n+/// An atomically reference counted pointer.\n+///\n+/// Enforces no shared-memory safety.\n+pub struct UnsafeAtomicRcBox<T> {\n+    data: *mut libc::c_void,\n+}\n+\n+struct AtomicRcBoxData<T> {\n+    count: int,\n+    data: Option<T>,\n+}\n+\n+impl<T: Owned> UnsafeAtomicRcBox<T> {\n+    pub fn new(data: T) -> UnsafeAtomicRcBox<T> {\n+        unsafe {\n+            let data = ~AtomicRcBoxData { count: 1, data: Some(data) };\n+            let ptr = cast::transmute(data);\n+            return UnsafeAtomicRcBox { data: ptr };\n+        }\n+    }\n+\n+    #[inline(always)]\n+    #[cfg(stage0)]\n+    pub unsafe fn get(&self) -> *mut T\n+    {\n+        let mut data: ~AtomicRcBoxData<T> = cast::transmute(self.data);\n+        assert!(data.count > 0);\n+        let r: *mut T = cast::transmute(data.data.get_mut_ref());\n+        cast::forget(data);\n+        return r;\n+    }\n+\n+    #[inline(always)]\n+    #[cfg(not(stage0))]\n+    pub unsafe fn get(&self) -> *mut T\n+    {\n+        let mut data: ~AtomicRcBoxData<T> = cast::transmute(self.data);\n+        assert!(data.count > 0);\n+        let r: *mut T = data.data.get_mut_ref();\n+        cast::forget(data);\n+        return r;\n+    }\n+\n+    #[inline(always)]\n+    #[cfg(stage0)]\n+    pub unsafe fn get_immut(&self) -> *T\n+    {\n+        let mut data: ~AtomicRcBoxData<T> = cast::transmute(self.data);\n+        assert!(data.count > 0);\n+        let r: *T = cast::transmute(data.data.get_mut_ref());\n+        cast::forget(data);\n+        return r;\n+    }\n+\n+    #[inline(always)]\n+    #[cfg(not(stage0))]\n+    pub unsafe fn get_immut(&self) -> *T\n+    {\n+        let mut data: ~AtomicRcBoxData<T> = cast::transmute(self.data);\n+        assert!(data.count > 0);\n+        let r: *T = cast::transmute_immut(data.data.get_mut_ref());\n+        cast::forget(data);\n+        return r;\n+    }\n+}\n+\n+impl<T: Owned> Clone for UnsafeAtomicRcBox<T> {\n+    fn clone(&self) -> UnsafeAtomicRcBox<T> {\n+        unsafe {\n+            let mut data: ~AtomicRcBoxData<T> = cast::transmute(self.data);\n+            let new_count = intrinsics::atomic_xadd(&mut data.count, 1) + 1;\n+            assert!(new_count >= 2);\n+            cast::forget(data);\n+            return UnsafeAtomicRcBox { data: self.data };\n+        }\n+    }\n+}\n+\n+#[unsafe_destructor]\n+impl<T> Drop for UnsafeAtomicRcBox<T>{\n+    fn finalize(&self) {\n+        unsafe {\n+            do task::unkillable {\n+                let mut data: ~AtomicRcBoxData<T> = cast::transmute(self.data);\n+                let new_count = intrinsics::atomic_xsub(&mut data.count, 1) - 1;\n+                assert!(new_count >= 0);\n+                if new_count == 0 {\n+                    // drop glue takes over.\n+                } else {\n+                    cast::forget(data);\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+\n+/****************************************************************************/\n+\n+#[allow(non_camel_case_types)] // runtime type\n+pub type rust_little_lock = *libc::c_void;\n+\n+struct LittleLock {\n+    l: rust_little_lock,\n+}\n+\n+impl Drop for LittleLock {\n+    fn finalize(&self) {\n+        unsafe {\n+            rust_destroy_little_lock(self.l);\n+        }\n+    }\n+}\n+\n+fn LittleLock() -> LittleLock {\n+    unsafe {\n+        LittleLock {\n+            l: rust_create_little_lock()\n+        }\n+    }\n+}\n+\n+pub impl LittleLock {\n+    #[inline(always)]\n+    unsafe fn lock<T>(&self, f: &fn() -> T) -> T {\n+        do atomically {\n+            rust_lock_little_lock(self.l);\n+            do (|| {\n+                f()\n+            }).finally {\n+                rust_unlock_little_lock(self.l);\n+            }\n+        }\n+    }\n+}\n+\n+struct ExData<T> {\n+    lock: LittleLock,\n+    failed: bool,\n+    data: T,\n+}\n+\n+/**\n+ * An arc over mutable data that is protected by a lock. For library use only.\n+ */\n+pub struct Exclusive<T> {\n+    x: UnsafeAtomicRcBox<ExData<T>>\n+}\n+\n+pub fn exclusive<T:Owned>(user_data: T) -> Exclusive<T> {\n+    let data = ExData {\n+        lock: LittleLock(),\n+        failed: false,\n+        data: user_data\n+    };\n+    Exclusive {\n+        x: UnsafeAtomicRcBox::new(data)\n+    }\n+}\n+\n+impl<T:Owned> Clone for Exclusive<T> {\n+    // Duplicate an exclusive ARC, as std::arc::clone.\n+    fn clone(&self) -> Exclusive<T> {\n+        Exclusive { x: self.x.clone() }\n+    }\n+}\n+\n+pub impl<T:Owned> Exclusive<T> {\n+    // Exactly like std::arc::mutex_arc,access(), but with the little_lock\n+    // instead of a proper mutex. Same reason for being unsafe.\n+    //\n+    // Currently, scheduling operations (i.e., yielding, receiving on a pipe,\n+    // accessing the provided condition variable) are prohibited while inside\n+    // the exclusive. Supporting that is a work in progress.\n+    #[inline(always)]\n+    unsafe fn with<U>(&self, f: &fn(x: &mut T) -> U) -> U {\n+        let rec = self.x.get();\n+        do (*rec).lock.lock {\n+            if (*rec).failed {\n+                fail!(\n+                    ~\"Poisoned exclusive - another task failed inside!\");\n+            }\n+            (*rec).failed = true;\n+            let result = f(&mut (*rec).data);\n+            (*rec).failed = false;\n+            result\n+        }\n+    }\n+\n+    #[inline(always)]\n+    unsafe fn with_imm<U>(&self, f: &fn(x: &T) -> U) -> U {\n+        do self.with |x| {\n+            f(cast::transmute_immut(x))\n+        }\n+    }\n+}\n+\n+fn compare_and_swap(address: &mut int, oldval: int, newval: int) -> bool {\n+    unsafe {\n+        let old = intrinsics::atomic_cxchg(address, oldval, newval);\n+        old == oldval\n+    }\n+}\n+\n+extern {\n+    fn rust_create_little_lock() -> rust_little_lock;\n+    fn rust_destroy_little_lock(lock: rust_little_lock);\n+    fn rust_lock_little_lock(lock: rust_little_lock);\n+    fn rust_unlock_little_lock(lock: rust_little_lock);\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use comm;\n+    use super::exclusive;\n+    use task;\n+    use uint;\n+\n+    #[test]\n+    fn exclusive_arc() {\n+        let mut futures = ~[];\n+\n+        let num_tasks = 10;\n+        let count = 10;\n+\n+        let total = exclusive(~0);\n+\n+        for uint::range(0, num_tasks) |_i| {\n+            let total = total.clone();\n+            let (port, chan) = comm::stream();\n+            futures.push(port);\n+\n+            do task::spawn || {\n+                for uint::range(0, count) |_i| {\n+                    do total.with |count| {\n+                        **count += 1;\n+                    }\n+                }\n+                chan.send(());\n+            }\n+        };\n+\n+        for futures.each |f| { f.recv() }\n+\n+        do total.with |total| {\n+            assert!(**total == num_tasks * count)\n+        };\n+    }\n+\n+    #[test] #[should_fail] #[ignore(cfg(windows))]\n+    fn exclusive_poison() {\n+        // Tests that if one task fails inside of an exclusive, subsequent\n+        // accesses will also fail.\n+        let x = exclusive(1);\n+        let x2 = x.clone();\n+        do task::try || {\n+            do x2.with |one| {\n+                assert!(*one == 2);\n+            }\n+        };\n+        do x.with |one| {\n+            assert!(*one == 1);\n+        }\n+    }\n+}"}, {"sha": "e56144ebc0a3bb72bb571d068bc2258e7ab0f581", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ad5bfd600d1611c9d1bb933a383d0db2fa0ee7bf/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad5bfd600d1611c9d1bb933a383d0db2fa0ee7bf/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=ad5bfd600d1611c9d1bb933a383d0db2fa0ee7bf", "patch": "@@ -3298,8 +3298,9 @@ mod tests {\n     #[test]\n     fn test_swap_remove_noncopyable() {\n         // Tests that we don't accidentally run destructors twice.\n-        let mut v = ~[::unstable::exclusive(()), ::unstable::exclusive(()),\n-                      ::unstable::exclusive(())];\n+        let mut v = ~[::unstable::sync::exclusive(()),\n+                      ::unstable::sync::exclusive(()),\n+                      ::unstable::sync::exclusive(())];\n         let mut _e = v.swap_remove(0);\n         assert!(v.len() == 2);\n         _e = v.swap_remove(1);"}, {"sha": "d3f774a1cd51fd17ad8d768537705b7ea9d5e7ba", "filename": "src/libstd/arc.rs", "status": "modified", "additions": 43, "deletions": 41, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/ad5bfd600d1611c9d1bb933a383d0db2fa0ee7bf/src%2Flibstd%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad5bfd600d1611c9d1bb933a383d0db2fa0ee7bf/src%2Flibstd%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Farc.rs?ref=ad5bfd600d1611c9d1bb933a383d0db2fa0ee7bf", "patch": "@@ -17,9 +17,7 @@ use sync;\n use sync::{Mutex, mutex_with_condvars, RWlock, rwlock_with_condvars};\n \n use core::cast;\n-use core::unstable::{SharedMutableState, shared_mutable_state};\n-use core::unstable::{clone_shared_mutable_state};\n-use core::unstable::{get_shared_mutable_state, get_shared_immutable_state};\n+use core::unstable::sync::UnsafeAtomicRcBox;\n use core::ptr;\n use core::task;\n \n@@ -83,19 +81,19 @@ pub impl<'self> Condvar<'self> {\n  ****************************************************************************/\n \n /// An atomically reference counted wrapper for shared immutable state.\n-struct ARC<T> { x: SharedMutableState<T> }\n+struct ARC<T> { x: UnsafeAtomicRcBox<T> }\n \n /// Create an atomically reference counted wrapper.\n pub fn ARC<T:Const + Owned>(data: T) -> ARC<T> {\n-    ARC { x: unsafe { shared_mutable_state(data) } }\n+    ARC { x: UnsafeAtomicRcBox::new(data) }\n }\n \n /**\n  * Access the underlying data in an atomically reference counted\n  * wrapper.\n  */\n pub fn get<'a, T:Const + Owned>(rc: &'a ARC<T>) -> &'a T {\n-    unsafe { get_shared_immutable_state(&rc.x) }\n+    unsafe { &*rc.x.get_immut() }\n }\n \n /**\n@@ -106,7 +104,7 @@ pub fn get<'a, T:Const + Owned>(rc: &'a ARC<T>) -> &'a T {\n  * allowing them to share the underlying data.\n  */\n pub fn clone<T:Const + Owned>(rc: &ARC<T>) -> ARC<T> {\n-    ARC { x: unsafe { clone_shared_mutable_state(&rc.x) } }\n+    ARC { x: rc.x.clone() }\n }\n \n impl<T:Const + Owned> Clone for ARC<T> {\n@@ -122,7 +120,7 @@ impl<T:Const + Owned> Clone for ARC<T> {\n #[doc(hidden)]\n struct MutexARCInner<T> { lock: Mutex, failed: bool, data: T }\n /// An ARC with mutable data protected by a blocking mutex.\n-struct MutexARC<T> { x: SharedMutableState<MutexARCInner<T>> }\n+struct MutexARC<T> { x: UnsafeAtomicRcBox<MutexARCInner<T>> }\n \n /// Create a mutex-protected ARC with the supplied data.\n pub fn MutexARC<T:Owned>(user_data: T) -> MutexARC<T> {\n@@ -137,15 +135,15 @@ pub fn mutex_arc_with_condvars<T:Owned>(user_data: T,\n     let data =\n         MutexARCInner { lock: mutex_with_condvars(num_condvars),\n                           failed: false, data: user_data };\n-    MutexARC { x: unsafe { shared_mutable_state(data) } }\n+    MutexARC { x: UnsafeAtomicRcBox::new(data) }\n }\n \n impl<T:Owned> Clone for MutexARC<T> {\n     /// Duplicate a mutex-protected ARC, as arc::clone.\n     fn clone(&self) -> MutexARC<T> {\n         // NB: Cloning the underlying mutex is not necessary. Its reference\n         // count would be exactly the same as the shared state's.\n-        MutexARC { x: unsafe { clone_shared_mutable_state(&self.x) } }\n+        MutexARC { x: self.x.clone() }\n     }\n }\n \n@@ -176,7 +174,7 @@ pub impl<T:Owned> MutexARC<T> {\n      */\n     #[inline(always)]\n     unsafe fn access<U>(&self, blk: &fn(x: &mut T) -> U) -> U {\n-        let state = get_shared_mutable_state(&self.x);\n+        let state = self.x.get();\n         // Borrowck would complain about this if the function were\n         // not already unsafe. See borrow_rwlock, far below.\n         do (&(*state).lock).lock {\n@@ -192,7 +190,7 @@ pub impl<T:Owned> MutexARC<T> {\n         &self,\n         blk: &fn(x: &'x mut T, c: &'c Condvar) -> U) -> U\n     {\n-        let state = get_shared_mutable_state(&self.x);\n+        let state = self.x.get();\n         do (&(*state).lock).lock_cond |cond| {\n             check_poison(true, (*state).failed);\n             let _z = PoisonOnFail(&mut (*state).failed);\n@@ -254,7 +252,7 @@ struct RWARCInner<T> { lock: RWlock, failed: bool, data: T }\n  */\n #[mutable]\n struct RWARC<T> {\n-    x: SharedMutableState<RWARCInner<T>>,\n+    x: UnsafeAtomicRcBox<RWARCInner<T>>,\n     cant_nest: ()\n }\n \n@@ -273,13 +271,13 @@ pub fn rw_arc_with_condvars<T:Const + Owned>(\n     let data =\n         RWARCInner { lock: rwlock_with_condvars(num_condvars),\n                      failed: false, data: user_data };\n-    RWARC { x: unsafe { shared_mutable_state(data) }, cant_nest: () }\n+    RWARC { x: UnsafeAtomicRcBox::new(data), cant_nest: () }\n }\n \n pub impl<T:Const + Owned> RWARC<T> {\n     /// Duplicate a rwlock-protected ARC, as arc::clone.\n     fn clone(&self) -> RWARC<T> {\n-        RWARC { x: unsafe { clone_shared_mutable_state(&self.x) },\n+        RWARC { x: self.x.clone(),\n                 cant_nest: () }\n     }\n \n@@ -299,7 +297,7 @@ pub impl<T:Const + Owned> RWARC<T> {\n     #[inline(always)]\n     fn write<U>(&self, blk: &fn(x: &mut T) -> U) -> U {\n         unsafe {\n-            let state = get_shared_mutable_state(&self.x);\n+            let state = self.x.get();\n             do (*borrow_rwlock(state)).write {\n                 check_poison(false, (*state).failed);\n                 let _z = PoisonOnFail(&mut (*state).failed);\n@@ -313,7 +311,7 @@ pub impl<T:Const + Owned> RWARC<T> {\n                              blk: &fn(x: &'x mut T, c: &'c Condvar) -> U)\n                           -> U {\n         unsafe {\n-            let state = get_shared_mutable_state(&self.x);\n+            let state = self.x.get();\n             do (*borrow_rwlock(state)).write_cond |cond| {\n                 check_poison(false, (*state).failed);\n                 let _z = PoisonOnFail(&mut (*state).failed);\n@@ -334,10 +332,12 @@ pub impl<T:Const + Owned> RWARC<T> {\n      * access modes, this will not poison the ARC.\n      */\n     fn read<U>(&self, blk: &fn(x: &T) -> U) -> U {\n-        let state = unsafe { get_shared_immutable_state(&self.x) };\n-        do (&state.lock).read {\n-            check_poison(false, state.failed);\n-            blk(&state.data)\n+        let state = self.x.get();\n+        unsafe {\n+            do (*state).lock.read {\n+                check_poison(false, (*state).failed);\n+                blk(&(*state).data)\n+            }\n         }\n     }\n \n@@ -360,7 +360,7 @@ pub impl<T:Const + Owned> RWARC<T> {\n      */\n     fn write_downgrade<U>(&self, blk: &fn(v: RWWriteMode<T>) -> U) -> U {\n         unsafe {\n-            let state = get_shared_mutable_state(&self.x);\n+            let state = self.x.get();\n             do (*borrow_rwlock(state)).write_downgrade |write_mode| {\n                 check_poison(false, (*state).failed);\n                 blk(RWWriteMode {\n@@ -374,25 +374,27 @@ pub impl<T:Const + Owned> RWARC<T> {\n \n     /// To be called inside of the write_downgrade block.\n     fn downgrade<'a>(&self, token: RWWriteMode<'a, T>) -> RWReadMode<'a, T> {\n-        // The rwlock should assert that the token belongs to us for us.\n-        let state = unsafe { get_shared_immutable_state(&self.x) };\n-        let RWWriteMode {\n-            data: data,\n-            token: t,\n-            poison: _poison\n-        } = token;\n-        // Let readers in\n-        let new_token = (&state.lock).downgrade(t);\n-        // Whatever region the input reference had, it will be safe to use\n-        // the same region for the output reference. (The only 'unsafe' part\n-        // of this cast is removing the mutability.)\n-        let new_data = unsafe { cast::transmute_immut(data) };\n-        // Downgrade ensured the token belonged to us. Just a sanity check.\n-        assert!(ptr::ref_eq(&state.data, new_data));\n-        // Produce new token\n-        RWReadMode {\n-            data: new_data,\n-            token: new_token,\n+        unsafe {\n+            // The rwlock should assert that the token belongs to us for us.\n+            let state = self.x.get();\n+            let RWWriteMode {\n+                data: data,\n+                token: t,\n+                poison: _poison\n+            } = token;\n+            // Let readers in\n+            let new_token = (*state).lock.downgrade(t);\n+            // Whatever region the input reference had, it will be safe to use\n+            // the same region for the output reference. (The only 'unsafe' part\n+            // of this cast is removing the mutability.)\n+            let new_data = cast::transmute_immut(data);\n+            // Downgrade ensured the token belonged to us. Just a sanity check.\n+            assert!(ptr::ref_eq(&(*state).data, new_data));\n+            // Produce new token\n+            RWReadMode {\n+                data: new_data,\n+                token: new_token,\n+            }\n         }\n     }\n }"}, {"sha": "108f24d60dc3649719fc392ee53c352f6d1fc4f8", "filename": "src/libstd/sync.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad5bfd600d1611c9d1bb933a383d0db2fa0ee7bf/src%2Flibstd%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad5bfd600d1611c9d1bb933a383d0db2fa0ee7bf/src%2Flibstd%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync.rs?ref=ad5bfd600d1611c9d1bb933a383d0db2fa0ee7bf", "patch": "@@ -15,7 +15,7 @@\n  * in std.\n  */\n \n-use core::unstable::{Exclusive, exclusive};\n+use core::unstable::sync::{Exclusive, exclusive};\n use core::ptr;\n use core::task;\n use core::util;"}, {"sha": "155b398148339bdb0c46e6e4f7400624b18def5c", "filename": "src/test/compile-fail/noncopyable-match-pattern.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad5bfd600d1611c9d1bb933a383d0db2fa0ee7bf/src%2Ftest%2Fcompile-fail%2Fnoncopyable-match-pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad5bfd600d1611c9d1bb933a383d0db2fa0ee7bf/src%2Ftest%2Fcompile-fail%2Fnoncopyable-match-pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnoncopyable-match-pattern.rs?ref=ad5bfd600d1611c9d1bb933a383d0db2fa0ee7bf", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n fn main() {\n-    let x = Some(unstable::exclusive(false));\n+    let x = Some(unstable::sync::exclusive(false));\n     match x {\n         Some(copy z) => { //~ ERROR copying a value of non-copyable type\n             do z.with |b| { assert!(!*b); }"}, {"sha": "ed7a631637433b7196a47229fd4f065f62e5444e", "filename": "src/test/run-pass/alt-ref-binding-in-guard-3256.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad5bfd600d1611c9d1bb933a383d0db2fa0ee7bf/src%2Ftest%2Frun-pass%2Falt-ref-binding-in-guard-3256.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad5bfd600d1611c9d1bb933a383d0db2fa0ee7bf/src%2Ftest%2Frun-pass%2Falt-ref-binding-in-guard-3256.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-ref-binding-in-guard-3256.rs?ref=ad5bfd600d1611c9d1bb933a383d0db2fa0ee7bf", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n pub fn main() {\n-    let x = Some(unstable::exclusive(true));\n+    let x = Some(unstable::sync::exclusive(true));\n     match x {\n         Some(ref z) if z.with(|b| *b) => {\n             do z.with |b| { assert!(*b); }"}]}