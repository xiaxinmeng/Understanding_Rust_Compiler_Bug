{"sha": "e2bb53ca527b0fb86849b34f166f9835eb145203", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUyYmI1M2NhNTI3YjBmYjg2ODQ5YjM0ZjE2NmY5ODM1ZWIxNDUyMDM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-11-02T23:38:49Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-11-02T23:38:49Z"}, "message": "Auto merge of #29291 - petrochenkov:privacy, r=alexcrichton\n\nThe public set is expanded with trait items, impls and their items, foreign items, exported macros, variant fields, i.e. all the missing parts. Now it's a subset of the exported set.\r\nThis is needed for https://github.com/rust-lang/rust/pull/29083 because stability annotation pass uses the public set and all things listed above need to be annotated.\r\nRustdoc can now be migrated to the public set as well, I guess.\r\n\r\nExported set is now slightly more correct with regard to exported items in blocks - 1) blocks in foreign items are considered and 2) publicity is not inherited from the block's parent - if a function is public it doesn't mean structures defined in its body are public.\r\n\r\nr? @alexcrichton or maybe someone else", "tree": {"sha": "c3c1b43b196c24c69bf8330486d3d29a3efef3f8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c3c1b43b196c24c69bf8330486d3d29a3efef3f8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e2bb53ca527b0fb86849b34f166f9835eb145203", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e2bb53ca527b0fb86849b34f166f9835eb145203", "html_url": "https://github.com/rust-lang/rust/commit/e2bb53ca527b0fb86849b34f166f9835eb145203", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e2bb53ca527b0fb86849b34f166f9835eb145203/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a1fd944eb83d23c3e7484850a1e7db275d38a58c", "url": "https://api.github.com/repos/rust-lang/rust/commits/a1fd944eb83d23c3e7484850a1e7db275d38a58c", "html_url": "https://github.com/rust-lang/rust/commit/a1fd944eb83d23c3e7484850a1e7db275d38a58c"}, {"sha": "ab7b3456d00d13e52fa6631eb745bd1a472b5731", "url": "https://api.github.com/repos/rust-lang/rust/commits/ab7b3456d00d13e52fa6631eb745bd1a472b5731", "html_url": "https://github.com/rust-lang/rust/commit/ab7b3456d00d13e52fa6631eb745bd1a472b5731"}], "stats": {"total": 360, "additions": 217, "deletions": 143}, "files": [{"sha": "97ab9c2dfb7f9636a67ab068451af883c7204ad8", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 6, "deletions": 17, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/e2bb53ca527b0fb86849b34f166f9835eb145203/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2bb53ca527b0fb86849b34f166f9835eb145203/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=e2bb53ca527b0fb86849b34f166f9835eb145203", "patch": "@@ -125,16 +125,11 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ReachableContext<'a, 'tcx> {\n             hir::ExprMethodCall(..) => {\n                 let method_call = ty::MethodCall::expr(expr.id);\n                 let def_id = self.tcx.tables.borrow().method_map[&method_call].def_id;\n-                match self.tcx.impl_or_trait_item(def_id).container() {\n-                    ty::ImplContainer(_) => {\n-                        if let Some(node_id) = self.tcx.map.as_local_node_id(def_id) {\n-                            if self.def_id_represents_local_inlined_item(def_id) {\n-                                self.worklist.push(node_id)\n-                            }\n-                            self.reachable_symbols.insert(node_id);\n-                        }\n+                if let Some(node_id) = self.tcx.map.as_local_node_id(def_id) {\n+                    if self.def_id_represents_local_inlined_item(def_id) {\n+                        self.worklist.push(node_id)\n                     }\n-                    ty::TraitContainer(_) => {}\n+                    self.reachable_symbols.insert(node_id);\n                 }\n             }\n             _ => {}\n@@ -228,14 +223,8 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                 continue\n             }\n \n-            match self.tcx.map.find(search_item) {\n-                Some(ref item) => self.propagate_node(item, search_item),\n-                None if search_item == ast::CRATE_NODE_ID => {}\n-                None => {\n-                    self.tcx.sess.bug(&format!(\"found unmapped ID in worklist: \\\n-                                               {}\",\n-                                              search_item))\n-                }\n+            if let Some(ref item) = self.tcx.map.find(search_item) {\n+                self.propagate_node(item, search_item);\n             }\n         }\n     }"}, {"sha": "4cc374431f4c76557c02947011bb35f5c06aae53", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e2bb53ca527b0fb86849b34f166f9835eb145203/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2bb53ca527b0fb86849b34f166f9835eb145203/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=e2bb53ca527b0fb86849b34f166f9835eb145203", "patch": "@@ -217,7 +217,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for Annotator<'a, 'tcx> {\n \n     fn visit_impl_item(&mut self, ii: &hir::ImplItem) {\n         self.annotate(ii.id, true, &ii.attrs, ii.span,\n-                      |v| visit::walk_impl_item(v, ii), true);\n+                      |v| visit::walk_impl_item(v, ii), false);\n     }\n \n     fn visit_variant(&mut self, var: &Variant, g: &'v Generics, item_id: NodeId) {\n@@ -227,7 +227,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for Annotator<'a, 'tcx> {\n \n     fn visit_struct_field(&mut self, s: &StructField) {\n         self.annotate(s.node.id, true, &s.node.attrs, s.span,\n-                      |v| visit::walk_struct_field(v, s), true);\n+                      |v| visit::walk_struct_field(v, s), !s.node.kind.is_unnamed());\n     }\n \n     fn visit_foreign_item(&mut self, i: &hir::ForeignItem) {"}, {"sha": "6004a1c6556a54f698cbf7e1111e0d1d435bd022", "filename": "src/librustc_front/hir.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e2bb53ca527b0fb86849b34f166f9835eb145203/src%2Flibrustc_front%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2bb53ca527b0fb86849b34f166f9835eb145203/src%2Flibrustc_front%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Fhir.rs?ref=e2bb53ca527b0fb86849b34f166f9835eb145203", "patch": "@@ -1148,6 +1148,12 @@ impl StructFieldKind {\n             NamedField(..) => false,\n         }\n     }\n+\n+    pub fn visibility(&self) -> Visibility {\n+        match *self {\n+            NamedField(_, vis) | UnnamedField(vis) => vis\n+        }\n+    }\n }\n \n /// Fields and Ids of enum variants and structs"}, {"sha": "4fbe3a6833573e6f82ffe726498d3b54df5d9ace", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 149, "deletions": 124, "changes": 273, "blob_url": "https://github.com/rust-lang/rust/blob/e2bb53ca527b0fb86849b34f166f9835eb145203/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2bb53ca527b0fb86849b34f166f9835eb145203/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=e2bb53ca527b0fb86849b34f166f9835eb145203", "patch": "@@ -162,7 +162,7 @@ struct EmbargoVisitor<'a, 'tcx: 'a> {\n     // This is a list of all exported items in the AST. An exported item is any\n     // function/method/item which is usable by external crates. This essentially\n     // means that the result is \"public all the way down\", but the \"path down\"\n-    // may jump across private boundaries through reexport statements.\n+    // may jump across private boundaries through reexport statements or type aliases.\n     exported_items: ExportedItems,\n \n     // This sets contains all the destination nodes which are publicly\n@@ -172,168 +172,162 @@ struct EmbargoVisitor<'a, 'tcx: 'a> {\n     // destination must also be exported.\n     reexports: NodeSet,\n \n+    // Items that are directly public without help of reexports or type aliases.\n     // These two fields are closely related to one another in that they are only\n-    // used for generation of the 'PublicItems' set, not for privacy checking at\n-    // all\n+    // used for generation of the `public_items` set, not for privacy checking at\n+    // all. Invariant: at any moment public items are a subset of exported items.\n     public_items: PublicItems,\n     prev_public: bool,\n }\n \n impl<'a, 'tcx> EmbargoVisitor<'a, 'tcx> {\n-    // There are checks inside of privacy which depend on knowing whether a\n-    // trait should be exported or not. The two current consumers of this are:\n-    //\n-    //  1. Should default methods of a trait be exported?\n-    //  2. Should the methods of an implementation of a trait be exported?\n-    //\n-    // The answer to both of these questions partly rely on whether the trait\n-    // itself is exported or not. If the trait is somehow exported, then the\n-    // answers to both questions must be yes. Right now this question involves\n-    // more analysis than is currently done in rustc, so we conservatively\n-    // answer \"yes\" so that all traits need to be exported.\n-    fn exported_trait(&self, _id: ast::NodeId) -> bool {\n-        true\n+    // Returns tuple (is_public, is_exported) for a type\n+    fn is_public_exported_ty(&self, ty: &hir::Ty) -> (bool, bool) {\n+        if let hir::TyPath(..) = ty.node {\n+            match self.tcx.def_map.borrow().get(&ty.id).unwrap().full_def() {\n+                def::DefPrimTy(..) | def::DefSelfTy(..) => (true, true),\n+                def => {\n+                    if let Some(node_id) = self.tcx.map.as_local_node_id(def.def_id()) {\n+                        (self.public_items.contains(&node_id),\n+                         self.exported_items.contains(&node_id))\n+                    } else {\n+                        (true, true)\n+                    }\n+                }\n+            }\n+        } else {\n+            (true, true)\n+        }\n     }\n-}\n \n-impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n-    fn visit_item(&mut self, item: &hir::Item) {\n-        let orig_all_pub = self.prev_public;\n-        self.prev_public = orig_all_pub && item.vis == hir::Public;\n+    // Returns tuple (is_public, is_exported) for a trait\n+    fn is_public_exported_trait(&self, trait_ref: &hir::TraitRef) -> (bool, bool) {\n+        let did = self.tcx.trait_ref_to_def_id(trait_ref);\n+        if let Some(node_id) = self.tcx.map.as_local_node_id(did) {\n+            (self.public_items.contains(&node_id), self.exported_items.contains(&node_id))\n+        } else {\n+            (true, true)\n+        }\n+    }\n+\n+    fn maybe_insert_id(&mut self, id: ast::NodeId) {\n         if self.prev_public {\n-            self.public_items.insert(item.id);\n+            self.public_items.insert(id);\n+        }\n+        if self.prev_exported {\n+            self.exported_items.insert(id);\n         }\n+    }\n+}\n \n+impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n+    fn visit_item(&mut self, item: &hir::Item) {\n+        let orig_all_public = self.prev_public;\n         let orig_all_exported = self.prev_exported;\n         match item.node {\n             // impls/extern blocks do not break the \"public chain\" because they\n-            // cannot have visibility qualifiers on them anyway\n+            // cannot have visibility qualifiers on them anyway. They are also not\n+            // added to public/exported sets based on inherited publicity.\n             hir::ItemImpl(..) | hir::ItemDefaultImpl(..) | hir::ItemForeignMod(..) => {}\n \n-            // Traits are a little special in that even if they themselves are\n-            // not public they may still be exported.\n-            hir::ItemTrait(..) => {\n-                self.prev_exported = self.exported_trait(item.id);\n-            }\n-\n             // Private by default, hence we only retain the \"public chain\" if\n             // `pub` is explicitly listed.\n             _ => {\n-                self.prev_exported =\n-                    (orig_all_exported && item.vis == hir::Public) ||\n-                     self.reexports.contains(&item.id);\n+                self.prev_public = self.prev_public && item.vis == hir::Public;\n+                self.prev_exported = (self.prev_exported && item.vis == hir::Public) ||\n+                                     self.reexports.contains(&item.id);\n+\n+                self.maybe_insert_id(item.id);\n             }\n         }\n \n-        let public_first = self.prev_exported &&\n-                           self.exported_items.insert(item.id);\n-\n         match item.node {\n             // Enum variants inherit from their parent, so if the enum is\n-            // public all variants are public unless they're explicitly priv\n-            hir::ItemEnum(ref def, _) if public_first => {\n+            // public all variants are public\n+            hir::ItemEnum(ref def, _) => {\n                 for variant in &def.variants {\n-                    self.exported_items.insert(variant.node.data.id());\n-                    self.public_items.insert(variant.node.data.id());\n+                    self.maybe_insert_id(variant.node.data.id());\n+                    for field in variant.node.data.fields() {\n+                        // Variant fields are always public\n+                        self.maybe_insert_id(field.node.id);\n+                    }\n                 }\n             }\n \n-            // Implementations are a little tricky to determine what's exported\n-            // out of them. Here's a few cases which are currently defined:\n-            //\n-            // * Impls for private types do not need to export their methods\n-            //   (either public or private methods)\n-            //\n-            // * Impls for public types only have public methods exported\n-            //\n-            // * Public trait impls for public types must have all methods\n-            //   exported.\n-            //\n-            // * Private trait impls for public types can be ignored\n-            //\n-            // * Public trait impls for private types have their methods\n-            //   exported. I'm not entirely certain that this is the correct\n-            //   thing to do, but I have seen use cases of where this will cause\n-            //   undefined symbols at linkage time if this case is not handled.\n-            //\n-            // * Private trait impls for private types can be completely ignored\n-            hir::ItemImpl(_, _, _, _, ref ty, ref impl_items) => {\n-                let public_ty = match ty.node {\n-                    hir::TyPath(..) => {\n-                        match self.tcx.def_map.borrow().get(&ty.id).unwrap().full_def() {\n-                            def::DefPrimTy(..) => true,\n-                            def::DefSelfTy(..) => true,\n-                            def => {\n-                                let did = def.def_id();\n-                                if let Some(node_id) = self.tcx.map.as_local_node_id(did) {\n-                                    self.exported_items.contains(&node_id)\n-                                } else {\n-                                    true\n-                                }\n-                            }\n+            // Public items in inherent impls for public/exported types are public/exported\n+            // Inherent impls themselves are not public/exported, they are nothing more than\n+            // containers for other items\n+            hir::ItemImpl(_, _, _, None, ref ty, ref impl_items) => {\n+                let (public_ty, exported_ty) = self.is_public_exported_ty(&ty);\n+\n+                for impl_item in impl_items {\n+                    if impl_item.vis == hir::Public {\n+                        if public_ty {\n+                            self.public_items.insert(impl_item.id);\n+                        }\n+                        if exported_ty {\n+                            self.exported_items.insert(impl_item.id);\n                         }\n                     }\n-                    _ => true,\n-                };\n-                let tr = self.tcx.impl_trait_ref(self.tcx.map.local_def_id(item.id));\n-                let public_trait = tr.clone().map_or(false, |tr| {\n-                    if let Some(node_id) = self.tcx.map.as_local_node_id(tr.def_id) {\n-                        self.exported_items.contains(&node_id)\n-                    } else {\n-                        true\n-                    }\n-                });\n+                }\n+            }\n \n-                if public_ty || public_trait {\n-                    for impl_item in impl_items {\n-                        match impl_item.node {\n-                            hir::ConstImplItem(..) => {\n-                                if (public_ty && impl_item.vis == hir::Public)\n-                                    || tr.is_some() {\n-                                    self.exported_items.insert(impl_item.id);\n-                                }\n-                            }\n-                            hir::MethodImplItem(ref sig, _) => {\n-                                let meth_public = match sig.explicit_self.node {\n-                                    hir::SelfStatic => public_ty,\n-                                    _ => true,\n-                                } && impl_item.vis == hir::Public;\n-                                if meth_public || tr.is_some() {\n-                                    self.exported_items.insert(impl_item.id);\n-                                }\n-                            }\n-                            hir::TypeImplItem(_) => {}\n-                        }\n+            // It's not known until monomorphization if a trait impl item should be reachable\n+            // from external crates or not. So, we conservatively mark all of them exported and\n+            // the reachability pass (middle::reachable) marks all exported items as reachable.\n+            // For example of private trait impl for private type that should be reachable see\n+            // src/test/auxiliary/issue-11225-3.rs\n+            hir::ItemImpl(_, _, _, Some(ref trait_ref), ref ty, ref impl_items) => {\n+                let (public_ty, _exported_ty) = self.is_public_exported_ty(&ty);\n+                let (public_trait, _exported_trait) = self.is_public_exported_trait(trait_ref);\n+\n+                if public_ty && public_trait {\n+                    self.public_items.insert(item.id);\n+                }\n+                self.exported_items.insert(item.id);\n+\n+                for impl_item in impl_items {\n+                    if public_ty && public_trait {\n+                        self.public_items.insert(impl_item.id);\n                     }\n+                    self.exported_items.insert(impl_item.id);\n+                }\n+            }\n+\n+            // Default trait impls are public/exported for public/exported traits\n+            hir::ItemDefaultImpl(_, ref trait_ref) => {\n+                let (public_trait, exported_trait) = self.is_public_exported_trait(trait_ref);\n+\n+                if public_trait {\n+                    self.public_items.insert(item.id);\n+                }\n+                if exported_trait {\n+                    self.exported_items.insert(item.id);\n                 }\n             }\n \n-            // Default methods on traits are all public so long as the trait\n-            // is public\n-            hir::ItemTrait(_, _, _, ref trait_items) if public_first => {\n+            // Default methods on traits are all public/exported so long as the trait\n+            // is public/exported\n+            hir::ItemTrait(_, _, _, ref trait_items) => {\n                 for trait_item in trait_items {\n-                    debug!(\"trait item {}\", trait_item.id);\n-                    self.exported_items.insert(trait_item.id);\n+                    self.maybe_insert_id(trait_item.id);\n                 }\n             }\n \n             // Struct constructors are public if the struct is all public.\n-            hir::ItemStruct(ref def, _) if public_first => {\n+            hir::ItemStruct(ref def, _) => {\n                 if !def.is_struct() {\n-                    self.exported_items.insert(def.id());\n+                    self.maybe_insert_id(def.id());\n                 }\n-                // fields can be public or private, so lets check\n                 for field in def.fields() {\n-                    let vis = match field.node.kind {\n-                        hir::NamedField(_, vis) | hir::UnnamedField(vis) => vis\n-                    };\n-                    if vis == hir::Public {\n-                        self.public_items.insert(field.node.id);\n+                    // Struct fields can be public or private, so lets check\n+                    if field.node.kind.visibility() == hir::Public {\n+                        self.maybe_insert_id(field.node.id);\n                     }\n                 }\n             }\n \n-            hir::ItemTy(ref ty, _) if public_first => {\n+            hir::ItemTy(ref ty, _) if self.prev_exported => {\n                 if let hir::TyPath(..) = ty.node {\n                     match self.tcx.def_map.borrow().get(&ty.id).unwrap().full_def() {\n                         def::DefPrimTy(..) | def::DefSelfTy(..) | def::DefTyParam(..) => {},\n@@ -347,19 +341,41 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n                 }\n             }\n \n+            hir::ItemForeignMod(ref foreign_mod) => {\n+                for foreign_item in &foreign_mod.items {\n+                    let public = self.prev_public && foreign_item.vis == hir::Public;\n+                    let exported = (self.prev_exported && foreign_item.vis == hir::Public) ||\n+                                   self.reexports.contains(&foreign_item.id);\n+\n+                    if public {\n+                        self.public_items.insert(foreign_item.id);\n+                    }\n+                    if exported {\n+                        self.exported_items.insert(foreign_item.id);\n+                    }\n+                }\n+            }\n+\n             _ => {}\n         }\n \n         visit::walk_item(self, item);\n \n+        self.prev_public = orig_all_public;\n         self.prev_exported = orig_all_exported;\n-        self.prev_public = orig_all_pub;\n     }\n \n-    fn visit_foreign_item(&mut self, a: &hir::ForeignItem) {\n-        if (self.prev_exported && a.vis == hir::Public) || self.reexports.contains(&a.id) {\n-            self.exported_items.insert(a.id);\n-        }\n+    fn visit_block(&mut self, b: &'v hir::Block) {\n+        let orig_all_public = replace(&mut self.prev_public, false);\n+        let orig_all_exported = replace(&mut self.prev_exported, false);\n+\n+        // Blocks can have exported and public items, for example impls, but they always\n+        // start as non-public and non-exported regardless of publicity of a function,\n+        // constant, type, field, etc. in which this block resides\n+        visit::walk_block(self, b);\n+\n+        self.prev_public = orig_all_public;\n+        self.prev_exported = orig_all_exported;\n     }\n \n     fn visit_mod(&mut self, m: &hir::Mod, _sp: Span, id: ast::NodeId) {\n@@ -375,6 +391,10 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n         }\n         visit::walk_mod(self, m)\n     }\n+\n+    fn visit_macro_def(&mut self, md: &'v hir::MacroDef) {\n+        self.maybe_insert_id(md.id);\n+    }\n }\n \n ////////////////////////////////////////////////////////////////////////////////\n@@ -1460,11 +1480,13 @@ impl<'a, 'tcx, 'v> Visitor<'v> for VisiblePrivateTypesVisitor<'a, 'tcx> {\n         }\n     }\n \n-\n     // we don't need to introspect into these at all: an\n     // expression/block context can't possibly contain exported things.\n     // (Making them no-ops stops us from traversing the whole AST without\n     // having to be super careful about our `walk_...` calls above.)\n+    // FIXME(#29524): Unfortunately this ^^^ is not true, blocks can contain\n+    // exported items (e.g. impls) and actual code in rustc itself breaks\n+    // if we don't traverse blocks in `EmbargoVisitor`\n     fn visit_block(&mut self, _: &hir::Block) {}\n     fn visit_expr(&mut self, _: &hir::Expr) {}\n }\n@@ -1514,9 +1536,12 @@ pub fn check_crate(tcx: &ty::ctxt,\n         prev_public: true,\n     };\n     loop {\n-        let before = visitor.exported_items.len();\n+        let before = (visitor.exported_items.len(), visitor.public_items.len(),\n+                      visitor.reexports.len());\n         visit::walk_crate(&mut visitor, krate);\n-        if before == visitor.exported_items.len() {\n+        let after = (visitor.exported_items.len(), visitor.public_items.len(),\n+                     visitor.reexports.len());\n+        if after == before {\n             break\n         }\n     }"}, {"sha": "e56e49c4f4902049b9714db5d09af739e1a2f7bb", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e2bb53ca527b0fb86849b34f166f9835eb145203/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2bb53ca527b0fb86849b34f166f9835eb145203/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=e2bb53ca527b0fb86849b34f166f9835eb145203", "patch": "@@ -1726,6 +1726,12 @@ impl StructFieldKind {\n             NamedField(..) => false,\n         }\n     }\n+\n+    pub fn visibility(&self) -> Visibility {\n+        match *self {\n+            NamedField(_, vis) | UnnamedField(vis) => vis\n+        }\n+    }\n }\n \n /// Fields and Ids of enum variants and structs"}, {"sha": "51d73925dff219ad89865fef5e9a2a02aa6b5799", "filename": "src/test/auxiliary/issue-11225-3.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/e2bb53ca527b0fb86849b34f166f9835eb145203/src%2Ftest%2Fauxiliary%2Fissue-11225-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2bb53ca527b0fb86849b34f166f9835eb145203/src%2Ftest%2Fauxiliary%2Fissue-11225-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-11225-3.rs?ref=e2bb53ca527b0fb86849b34f166f9835eb145203", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+trait PrivateTrait {\n+    fn private_trait_method(&self);\n+}\n+\n+struct PrivateStruct;\n+\n+impl PrivateStruct {\n+    fn private_inherent_method(&self) { }\n+}\n+\n+impl PrivateTrait for PrivateStruct {\n+    fn private_trait_method(&self) { }\n+}\n+\n+#[inline]\n+pub fn public_generic_function() {\n+    PrivateStruct.private_trait_method();\n+    PrivateStruct.private_inherent_method();\n+}"}, {"sha": "046c145e70e784e948b0ed21c05d284ef6ca9e59", "filename": "src/test/run-pass/issue-11225-3.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e2bb53ca527b0fb86849b34f166f9835eb145203/src%2Ftest%2Frun-pass%2Fissue-11225-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2bb53ca527b0fb86849b34f166f9835eb145203/src%2Ftest%2Frun-pass%2Fissue-11225-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-11225-3.rs?ref=e2bb53ca527b0fb86849b34f166f9835eb145203", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:issue-11225-3.rs\n+\n+// pretty-expanded FIXME #23616\n+\n+extern crate issue_11225_3;\n+\n+pub fn main() {\n+    issue_11225_3::public_generic_function();\n+}"}]}