{"sha": "d1e59d691039731b8ae05aadf8358c499dfa5b89", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQxZTU5ZDY5MTAzOTczMWI4YWUwNWFhZGY4MzU4YzQ5OWRmYTViODk=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-10-06T01:21:44Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-10-06T01:21:44Z"}, "message": "Add input coordinate tracking to all major rustc ast nodes.", "tree": {"sha": "0e032c573a823598941ceb6fe488273749d0df31", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0e032c573a823598941ceb6fe488273749d0df31"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d1e59d691039731b8ae05aadf8358c499dfa5b89", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d1e59d691039731b8ae05aadf8358c499dfa5b89", "html_url": "https://github.com/rust-lang/rust/commit/d1e59d691039731b8ae05aadf8358c499dfa5b89", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d1e59d691039731b8ae05aadf8358c499dfa5b89/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4168c1dcdaf4cdde860633ea95e0d92d8e116128", "url": "https://api.github.com/repos/rust-lang/rust/commits/4168c1dcdaf4cdde860633ea95e0d92d8e116128", "html_url": "https://github.com/rust-lang/rust/commit/4168c1dcdaf4cdde860633ea95e0d92d8e116128"}], "stats": {"total": 279, "additions": 196, "deletions": 83}, "files": [{"sha": "15c29db9f9f3b2cda3ac15f15a7042dfced69b34", "filename": "src/comp/front/ast.rs", "status": "modified", "additions": 37, "deletions": 20, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/d1e59d691039731b8ae05aadf8358c499dfa5b89/src%2Fcomp%2Ffront%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1e59d691039731b8ae05aadf8358c499dfa5b89/src%2Fcomp%2Ffront%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fast.rs?ref=d1e59d691039731b8ae05aadf8358c499dfa5b89", "patch": "@@ -2,28 +2,39 @@\n import util.common.option;\n import std.map.hashmap;\n import util.common.span;\n+import util.common.spanned;\n import util.common.option;\n import util.common.some;\n import util.common.none;\n \n type ident = str;\n \n-type name = rec(ident ident, vec[ty] types);\n+type name_ = rec(ident ident, vec[ty] types);\n+type name = spanned[name_];\n type path = vec[name];\n \n-type crate_id = int;\n-type slot_id = int;\n-type item_id = int;\n+type crate_num = int;\n+type slot_num = int;\n+type item_num = int;\n \n-tag referent {\n-    ref_slot(crate_id, slot_id);\n-    ref_item(crate_id, item_id);\n+tag slot_id {\n+    id_slot(crate_num, slot_num);\n+}\n+\n+tag item_id {\n+    id_item(crate_num, slot_num);\n }\n \n+tag referent {\n+    ref_slot(slot_id);\n+    ref_item(item_id);\n+}\n \n-type crate = rec(_mod module);\n+type crate = spanned[crate_];\n+type crate_ = rec(_mod module);\n \n-type block = vec[@stmt];\n+type block = spanned[block_];\n+type block_ = vec[@stmt];\n \n tag binop {\n     add;\n@@ -55,19 +66,22 @@ tag unop {\n     neg;\n }\n \n-tag stmt {\n+type stmt = spanned[stmt_];\n+tag stmt_ {\n     stmt_decl(@decl);\n     stmt_ret(option[@expr]);\n     stmt_log(@expr);\n     stmt_expr(@expr);\n }\n \n-tag decl {\n-    decl_local(ident, option[ty]);\n-    decl_item(ident, @item);\n+type decl = spanned[decl_];\n+tag decl_ {\n+    decl_local(ident, option[ty], ty);\n+    decl_item(name, @item);\n }\n \n-tag expr {\n+type expr = spanned[expr_];\n+tag expr_ {\n     expr_vec(vec[@expr]);\n     expr_tup(vec[@expr]);\n     expr_rec(vec[tup(ident,@expr)]);\n@@ -83,7 +97,8 @@ tag expr {\n     expr_block(block);\n }\n \n-tag lit {\n+type lit = spanned[lit_];\n+tag lit_ {\n     lit_str(str);\n     lit_char(char);\n     lit_int(int);\n@@ -92,7 +107,8 @@ tag lit {\n     lit_bool(bool);\n }\n \n-tag ty {\n+type ty = spanned[ty_];\n+tag ty_ {\n     ty_nil;\n     ty_bool;\n     ty_int;\n@@ -109,18 +125,19 @@ tag mode {\n     alias;\n }\n \n-type slot = rec(ty ty, mode mode);\n+type slot = rec(ty ty, mode mode, option[slot_id] id);\n \n type _fn = rec(vec[rec(slot slot, ident ident)] inputs,\n                slot output,\n                block body);\n \n type _mod = hashmap[ident,item];\n \n-tag item {\n-    item_fn(@_fn);\n+type item = spanned[item_];\n+tag item_ {\n+    item_fn(@_fn, item_id);\n     item_mod(@_mod);\n-    item_ty(@ty);\n+    item_ty(@ty, item_id);\n }\n \n "}, {"sha": "75edba16a16b304bcc43857284f7681c939fa1d6", "filename": "src/comp/front/parser.rs", "status": "modified", "additions": 149, "deletions": 54, "changes": 203, "blob_url": "https://github.com/rust-lang/rust/blob/d1e59d691039731b8ae05aadf8358c499dfa5b89/src%2Fcomp%2Ffront%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1e59d691039731b8ae05aadf8358c499dfa5b89/src%2Fcomp%2Ffront%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fparser.rs?ref=d1e59d691039731b8ae05aadf8358c499dfa5b89", "patch": "@@ -1,6 +1,7 @@\n import std._io;\n import driver.session;\n import util.common;\n+import util.common.span;\n import util.common.new_str_hash;\n import util.common.option;\n import util.common.some;\n@@ -23,7 +24,7 @@ io fn new_parser(session.session sess, str path) -> parser {\n                            lexer.reader rdr)\n         {\n             fn peek() -> token.token {\n-                log token.to_str(tok);\n+                // log token.to_str(tok);\n                 ret tok;\n             }\n \n@@ -66,6 +67,12 @@ io fn expect(parser p, token.token t) {\n     }\n }\n \n+fn spanned[T](&span lo, &span hi, &T node) -> ast.spanned[T] {\n+    ret rec(node=node, span=rec(filename=lo.filename,\n+                                lo=lo.lo,\n+                                hi=hi.hi));\n+}\n+\n io fn parse_ident(parser p) -> ast.ident {\n     alt (p.peek()) {\n         case (token.IDENT(?i)) { p.bump(); ret i; }\n@@ -77,15 +84,21 @@ io fn parse_ident(parser p) -> ast.ident {\n }\n \n io fn parse_ty(parser p) -> ast.ty {\n+    auto lo = p.get_span();\n+    let ast.ty_ t;\n     alt (p.peek()) {\n-        case (token.INT) { p.bump(); ret ast.ty_int; }\n-        case (token.UINT) { p.bump(); ret ast.ty_int; }\n-        case (token.STR) { p.bump(); ret ast.ty_str; }\n-        case (token.CHAR) { p.bump(); ret ast.ty_char; }\n-        case (token.MACH(?tm)) { p.bump(); ret ast.ty_machine(tm); }\n+        case (token.INT) { p.bump(); t = ast.ty_int; }\n+        case (token.UINT) { p.bump(); t = ast.ty_int; }\n+        case (token.STR) { p.bump(); t = ast.ty_str; }\n+        case (token.CHAR) { p.bump(); t = ast.ty_char; }\n+        case (token.MACH(?tm)) { p.bump(); t = ast.ty_machine(tm); }\n+        case (_) {\n+            p.err(\"expecting type\");\n+            t = ast.ty_nil;\n+            fail;\n+        }\n     }\n-    p.err(\"expecting type\");\n-    fail;\n+    ret spanned(lo, lo, t);\n }\n \n io fn parse_slot(parser p) -> ast.slot {\n@@ -95,15 +108,16 @@ io fn parse_slot(parser p) -> ast.slot {\n         p.bump();\n     }\n     let ast.ty t = parse_ty(p);\n-    ret rec(ty=t, mode=m);\n+    ret rec(ty=t, mode=m, id=none[ast.slot_id]);\n }\n \n io fn parse_seq[T](token.token bra,\n                       token.token ket,\n                       option[token.token] sep,\n                       (io fn(parser) -> T) f,\n-                      parser p) -> vec[T] {\n+                      parser p) -> util.common.spanned[vec[T]] {\n     let bool first = true;\n+    auto lo = p.get_span();\n     expect(p, bra);\n     let vec[T] v = vec();\n     while (p.peek() != ket) {\n@@ -122,41 +136,52 @@ io fn parse_seq[T](token.token bra,\n         let T t = f(p);\n         v += vec(t);\n     }\n+    auto hi = p.get_span();\n     expect(p, ket);\n-    ret v;\n+    ret spanned(lo, hi, v);\n }\n \n io fn parse_lit(parser p) -> @ast.lit {\n+    auto lo = p.get_span();\n+    let ast.lit_ lit;\n     alt (p.peek()) {\n         case (token.LIT_INT(?i)) {\n             p.bump();\n-            ret @ast.lit_int(i);\n+            lit = ast.lit_int(i);\n         }\n         case (token.LIT_UINT(?u)) {\n             p.bump();\n-            ret @ast.lit_uint(u);\n+            lit = ast.lit_uint(u);\n         }\n         case (token.LIT_CHAR(?c)) {\n             p.bump();\n-            ret @ast.lit_char(c);\n+            lit = ast.lit_char(c);\n         }\n         case (token.LIT_BOOL(?b)) {\n             p.bump();\n-            ret @ast.lit_bool(b);\n+            lit = ast.lit_bool(b);\n         }\n         case (token.LIT_STR(?s)) {\n             p.bump();\n-            ret @ast.lit_str(s);\n+            lit = ast.lit_str(s);\n+        }\n+        case (_) {\n+            lit = ast.lit_nil;\n+            p.err(\"expected literal\");\n+            fail;\n         }\n     }\n-    p.err(\"expected literal\");\n-    fail;\n+    ret @spanned(lo, lo, lit);\n }\n \n io fn parse_name(parser p, ast.ident id) -> ast.name {\n+\n+    auto lo = p.get_span();\n+\n     p.bump();\n \n-    let vec[ast.ty] tys = vec();\n+    let vec[ast.ty] v = vec();\n+    let util.common.spanned[vec[ast.ty]] tys = rec(node=v, span=lo);\n \n     alt (p.peek()) {\n         case (token.LBRACKET) {\n@@ -169,16 +194,25 @@ io fn parse_name(parser p, ast.ident id) -> ast.name {\n         case (_) {\n         }\n     }\n-    ret rec(ident=id, types=tys);\n+    ret spanned(lo, tys.span, rec(ident=id, types=tys.node));\n }\n \n io fn parse_bottom_expr(parser p) -> @ast.expr {\n+\n+    auto lo = p.get_span();\n+    auto hi = lo;\n+\n+    // FIXME: can only remove this sort of thing when both typestate and\n+    // alt-exhaustive-match checking are co-operating.\n+    let ast.expr_ ex = ast.expr_lit(@spanned(lo, lo, ast.lit_nil));\n+\n     alt (p.peek()) {\n         case (token.LPAREN) {\n             p.bump();\n             auto e = parse_expr(p);\n+            hi = p.get_span();\n             expect(p, token.RPAREN);\n-            ret e;\n+            ret @spanned(lo, hi, e.node);\n         }\n \n         case (token.TUP) {\n@@ -188,7 +222,8 @@ io fn parse_bottom_expr(parser p) -> @ast.expr {\n                                            token.RPAREN,\n                                            some(token.COMMA),\n                                            pf, p);\n-            ret @ast.expr_tup(es);\n+            hi = es.span;\n+            ex = ast.expr_tup(es.node);\n         }\n \n         case (token.VEC) {\n@@ -198,7 +233,8 @@ io fn parse_bottom_expr(parser p) -> @ast.expr {\n                                            token.RPAREN,\n                                            some(token.COMMA),\n                                            pf, p);\n-            ret @ast.expr_vec(es);\n+            hi = es.span;\n+            ex = ast.expr_vec(es.node);\n         }\n \n         case (token.REC) {\n@@ -216,35 +252,45 @@ io fn parse_bottom_expr(parser p) -> @ast.expr {\n                                                      token.RPAREN,\n                                                      some(token.COMMA),\n                                                      pf, p);\n-            ret @ast.expr_rec(es);\n+            hi = es.span;\n+            ex = ast.expr_rec(es.node);\n         }\n \n         case (token.IDENT(?i)) {\n-            ret @ast.expr_name(parse_name(p, i), none[ast.referent]);\n+            auto n = parse_name(p, i);\n+            hi = n.span;\n+            ex = ast.expr_name(n, none[ast.referent]);\n         }\n \n         case (_) {\n-            ret @ast.expr_lit(parse_lit(p));\n+            auto lit = parse_lit(p);\n+            hi = lit.span;\n+            ex = ast.expr_lit(lit);\n         }\n     }\n+    ret @spanned(lo, hi, ex);\n }\n \n io fn parse_path_expr(parser p) -> @ast.expr {\n+    auto lo = p.get_span();\n     auto e = parse_bottom_expr(p);\n+    auto hi = e.span;\n     while (true) {\n         alt (p.peek()) {\n             case (token.DOT) {\n                 p.bump();\n                 alt (p.peek()) {\n \n                     case (token.IDENT(?i)) {\n+                        hi = p.get_span();\n                         p.bump();\n-                        e = @ast.expr_field(e, i);\n+                        e = @spanned(lo, hi, ast.expr_field(e, i));\n                     }\n \n                     case (token.LPAREN) {\n                         auto ix = parse_bottom_expr(p);\n-                        e = @ast.expr_index(e, ix);\n+                        hi = ix.span;\n+                        e = @spanned(lo, hi, ast.expr_index(e, ix));\n                     }\n                 }\n             }\n@@ -257,33 +303,44 @@ io fn parse_path_expr(parser p) -> @ast.expr {\n }\n \n io fn parse_prefix_expr(parser p) -> @ast.expr {\n+\n+    auto lo = p.get_span();\n+    auto hi = lo;\n+\n+    // FIXME: can only remove this sort of thing when both typestate and\n+    // alt-exhaustive-match checking are co-operating.\n+    let ast.expr_ ex = ast.expr_lit(@spanned(lo, lo, ast.lit_nil));\n+\n     alt (p.peek()) {\n \n         case (token.NOT) {\n             p.bump();\n             auto e = parse_prefix_expr(p);\n-            ret @ast.expr_unary(ast.not, e);\n+            hi = e.span;\n+            ex = ast.expr_unary(ast.not, e);\n         }\n \n         case (token.TILDE) {\n             p.bump();\n             auto e = parse_prefix_expr(p);\n-            ret @ast.expr_unary(ast.bitnot, e);\n+            hi = e.span;\n+            ex = ast.expr_unary(ast.bitnot, e);\n         }\n \n         case (token.BINOP(?b)) {\n             alt (b) {\n-\n                 case (token.MINUS) {\n                     p.bump();\n                     auto e = parse_prefix_expr(p);\n-                    ret @ast.expr_unary(ast.neg, e);\n+                    hi = e.span;\n+                    ex = ast.expr_unary(ast.neg, e);\n                 }\n \n                 case (token.STAR) {\n                     p.bump();\n                     auto e = parse_prefix_expr(p);\n-                    ret @ast.expr_unary(ast.deref, e);\n+                    hi = e.span;\n+                    ex = ast.expr_unary(ast.deref, e);\n                 }\n \n                 case (_) {\n@@ -295,19 +352,23 @@ io fn parse_prefix_expr(parser p) -> @ast.expr {\n         case (token.AT) {\n             p.bump();\n             auto e = parse_prefix_expr(p);\n-            ret @ast.expr_unary(ast.box, e);\n+            hi = e.span;\n+            ex = ast.expr_unary(ast.box, e);\n         }\n \n         case (_) {\n             ret parse_path_expr(p);\n         }\n     }\n+    ret @spanned(lo, hi, ex);\n }\n \n io fn parse_binops(parser p,\n-                      (io fn(parser) -> @ast.expr) sub,\n-                      vec[tup(token.binop, ast.binop)] ops)\n+                   (io fn(parser) -> @ast.expr) sub,\n+                   vec[tup(token.binop, ast.binop)] ops)\n     -> @ast.expr {\n+    auto lo = p.get_span();\n+    auto hi = lo;\n     auto e = sub(p);\n     auto more = true;\n     while (more) {\n@@ -317,7 +378,10 @@ io fn parse_binops(parser p,\n                 case (token.BINOP(?op)) {\n                     if (pair._0 == op) {\n                         p.bump();\n-                        e = @ast.expr_binary(pair._1, e, sub(p));\n+                        auto rhs = sub(p);\n+                        hi = rhs.span;\n+                        auto exp = ast.expr_binary(pair._1, e, rhs);\n+                        e = @spanned(lo, hi, exp);\n                         more = true;\n                     }\n                 }\n@@ -331,14 +395,19 @@ io fn parse_binary_exprs(parser p,\n                             (io fn(parser) -> @ast.expr) sub,\n                             vec[tup(token.token, ast.binop)] ops)\n     -> @ast.expr {\n+    auto lo = p.get_span();\n+    auto hi = lo;\n     auto e = sub(p);\n     auto more = true;\n     while (more) {\n         more = false;\n         for (tup(token.token, ast.binop) pair in ops) {\n             if (pair._0 == p.peek()) {\n                 p.bump();\n-                e = @ast.expr_binary(pair._1, e, sub(p));\n+                auto rhs = sub(p);\n+                hi = rhs.span;\n+                auto exp = ast.expr_binary(pair._1, e, rhs);\n+                e = @spanned(lo, hi, exp);\n                 more = true;\n             }\n         }\n@@ -382,13 +451,16 @@ io fn parse_bitor_expr(parser p) -> @ast.expr {\n }\n \n io fn parse_cast_expr(parser p) -> @ast.expr {\n+    auto lo = p.get_span();\n     auto e = parse_bitor_expr(p);\n+    auto hi = e.span;\n     while (true) {\n         alt (p.peek()) {\n             case (token.AS) {\n                 p.bump();\n                 auto t = parse_ty(p);\n-                e = @ast.expr_cast(e, t);\n+                hi = t.span;\n+                e = @spanned(lo, hi, ast.expr_cast(e, t));\n             }\n \n             case (_) {\n@@ -425,25 +497,33 @@ io fn parse_or_expr(parser p) -> @ast.expr {\n }\n \n io fn parse_if_expr(parser p) -> @ast.expr {\n+    auto lo = p.get_span();\n+    auto hi = lo;\n+\n     expect(p, token.IF);\n     expect(p, token.LPAREN);\n     auto cond = parse_expr(p);\n     expect(p, token.RPAREN);\n     auto thn = parse_block(p);\n     let option[ast.block] els = none[ast.block];\n+    hi = thn.span;\n     alt (p.peek()) {\n         case (token.ELSE) {\n             p.bump();\n-            els = some(parse_block(p));\n+            auto eblk = parse_block(p);\n+            els = some(eblk);\n+            hi = eblk.span;\n         }\n     }\n-    ret @ast.expr_if(cond, thn, els);\n+    ret @spanned(lo, hi, ast.expr_if(cond, thn, els));\n }\n \n io fn parse_expr(parser p) -> @ast.expr {\n     alt (p.peek()) {\n         case (token.LBRACE) {\n-            ret @ast.expr_block(parse_block(p));\n+            auto blk = parse_block(p);\n+            ret @spanned(blk.span, blk.span,\n+                         ast.expr_block(blk));\n         }\n         case (token.IF) {\n             ret parse_if_expr(p);\n@@ -456,31 +536,37 @@ io fn parse_expr(parser p) -> @ast.expr {\n }\n \n io fn parse_stmt(parser p) -> @ast.stmt {\n+    auto lo = p.get_span();\n     alt (p.peek()) {\n+\n         case (token.LOG) {\n             p.bump();\n             auto e = parse_expr(p);\n+            auto hi = p.get_span();\n             expect(p, token.SEMI);\n-            ret @ast.stmt_log(e);\n+            ret @spanned(lo, hi, ast.stmt_log(e));\n         }\n \n         // Handle the (few) block-expr stmts first.\n \n         case (token.IF) {\n-            ret @ast.stmt_expr(parse_expr(p));\n+            auto e = parse_expr(p);\n+            ret @spanned(lo, e.span, ast.stmt_expr(e));\n         }\n \n         case (token.LBRACE) {\n-            ret @ast.stmt_expr(parse_expr(p));\n+            auto e = parse_expr(p);\n+            ret @spanned(lo, e.span, ast.stmt_expr(e));\n         }\n \n \n         // Remainder are line-expr stmts.\n \n         case (_) {\n             auto e = parse_expr(p);\n+            auto hi = p.get_span();\n             expect(p, token.SEMI);\n-            ret @ast.stmt_expr(e);\n+            ret @spanned(lo, hi, ast.stmt_expr(e));\n         }\n     }\n     p.err(\"expected statement\");\n@@ -504,10 +590,11 @@ io fn parse_slot_ident_pair(parser p) ->\n }\n \n io fn parse_fn(parser p) -> tup(ast.ident, ast.item) {\n+    auto lo = p.get_span();\n     expect(p, token.FN);\n     auto id = parse_ident(p);\n     auto pf = parse_slot_ident_pair;\n-    auto inputs =\n+    let util.common.spanned[vec[rec(ast.slot slot, ast.ident ident)]] inputs =\n         // FIXME: passing parse_slot_ident_pair as an lval doesn't work at the\n         // moment.\n         parse_seq[rec(ast.slot slot, ast.ident ident)]\n@@ -516,24 +603,28 @@ io fn parse_fn(parser p) -> tup(ast.ident, ast.item) {\n          some(token.COMMA),\n          pf, p);\n \n-    auto output;\n+    let ast.slot output;\n     if (p.peek() == token.RARROW) {\n         p.bump();\n-        output = rec(ty=parse_ty(p), mode=ast.val);\n+        output = rec(ty=parse_ty(p), mode=ast.val, id=none[ast.slot_id]);\n     } else {\n-        output = rec(ty=ast.ty_nil, mode=ast.val);\n+        output = rec(ty=spanned(lo, inputs.span, ast.ty_nil),\n+                     mode=ast.val, id=none[ast.slot_id]);\n     }\n \n     auto body = parse_block(p);\n \n-    let ast._fn f = rec(inputs = inputs,\n+    let ast._fn f = rec(inputs = inputs.node,\n                         output = output,\n                         body = body);\n \n-    ret tup(id, ast.item_fn(@f));\n+    let ast.item i = spanned(lo, body.span,\n+                             ast.item_fn(@f, ast.id_item(0,0)));\n+    ret tup(id, i);\n }\n \n io fn parse_mod(parser p) -> tup(ast.ident, ast.item) {\n+    auto lo = p.get_span();\n     expect(p, token.MOD);\n     auto id = parse_ident(p);\n     expect(p, token.LBRACE);\n@@ -542,8 +633,9 @@ io fn parse_mod(parser p) -> tup(ast.ident, ast.item) {\n         auto i = parse_item(p);\n         m.insert(i._0, i._1);\n     }\n+    auto hi = p.get_span();\n     expect(p, token.RBRACE);\n-    ret tup(id, ast.item_mod(@m));\n+    ret tup(id, spanned(lo, hi, ast.item_mod(@m)));\n }\n \n io fn parse_item(parser p) -> tup(ast.ident, ast.item) {\n@@ -560,12 +652,15 @@ io fn parse_item(parser p) -> tup(ast.ident, ast.item) {\n }\n \n io fn parse_crate(parser p) -> ast.crate {\n+    auto lo = p.get_span();\n+    auto hi = lo;\n     let ast._mod m = new_str_hash[ast.item]();\n     while (p.peek() != token.EOF) {\n         auto i = parse_item(p);\n         m.insert(i._0, i._1);\n+        hi = i._1.span;\n     }\n-    ret rec(module=m);\n+    ret spanned(lo, hi, rec(module=m));\n }\n \n //"}, {"sha": "ab851f4ba2b0c640ce3e212bc0a9495f8f3aee13", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d1e59d691039731b8ae05aadf8358c499dfa5b89/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1e59d691039731b8ae05aadf8358c499dfa5b89/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=d1e59d691039731b8ae05aadf8358c499dfa5b89", "patch": "@@ -348,7 +348,7 @@ fn trans_drop_str(@block_ctxt cx, ValueRef v) -> result {\n }\n \n fn trans_lit(@block_ctxt cx, &ast.lit lit) -> result {\n-    alt (lit) {\n+    alt (lit.node) {\n         case (ast.lit_int(?i)) {\n             ret res(cx, C_int(i));\n         }\n@@ -545,7 +545,7 @@ fn trans_if(@block_ctxt cx, &ast.expr cond,\n }\n \n fn trans_expr(@block_ctxt cx, &ast.expr e) -> result {\n-    alt (e) {\n+    alt (e.node) {\n         case (ast.expr_lit(?lit)) {\n             ret trans_lit(cx, *lit);\n         }\n@@ -578,9 +578,9 @@ fn trans_expr(@block_ctxt cx, &ast.expr e) -> result {\n }\n \n fn trans_log(@block_ctxt cx, &ast.expr e) -> result {\n-    alt (e) {\n+    alt (e.node) {\n         case (ast.expr_lit(?lit)) {\n-            alt (*lit) {\n+            alt (lit.node) {\n                 case (ast.lit_str(_)) {\n                     auto sub = trans_expr(cx, e);\n                     auto v = sub.bcx.build.PtrToInt(sub.val, T_int());\n@@ -607,7 +607,7 @@ fn trans_log(@block_ctxt cx, &ast.expr e) -> result {\n \n fn trans_stmt(@block_ctxt cx, &ast.stmt s) -> result {\n     auto sub = res(cx, C_nil());\n-    alt (s) {\n+    alt (s.node) {\n         case (ast.stmt_log(?a)) {\n             sub.bcx = trans_log(cx, *a).bcx;\n         }\n@@ -688,7 +688,7 @@ fn trans_block_cleanups(@block_ctxt cx) -> @block_ctxt {\n fn trans_block(@block_ctxt cx, &ast.block b) -> result {\n     auto bcx = cx;\n \n-    for (@ast.stmt s in b) {\n+    for (@ast.stmt s in b.node) {\n         bcx = trans_stmt(bcx, *s).bcx;\n     }\n \n@@ -726,8 +726,8 @@ fn trans_fn(@trans_ctxt cx, &ast._fn f) {\n \n fn trans_item(@trans_ctxt cx, &str name, &ast.item item) {\n     auto sub_cx = @rec(path=cx.path + \".\" + name with *cx);\n-    alt (item) {\n-        case (ast.item_fn(?f)) {\n+    alt (item.node) {\n+        case (ast.item_fn(?f, _)) {\n             trans_fn(sub_cx, *f);\n         }\n         case (ast.item_mod(?m)) {\n@@ -872,7 +872,7 @@ fn trans_crate(session.session sess, ast.crate crate) {\n                    names = namegen(0),\n                    path = \"_rust\");\n \n-    trans_mod(cx, crate.module);\n+    trans_mod(cx, crate.node.module);\n     trans_exit_task_glue(cx);\n     trans_main_fn(cx, crate_constant(cx));\n "}, {"sha": "51dbfbb1e3c2b430daae526358f8e8ce51b24633", "filename": "src/comp/util/common.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d1e59d691039731b8ae05aadf8358c499dfa5b89/src%2Fcomp%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d1e59d691039731b8ae05aadf8358c499dfa5b89/src%2Fcomp%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fcommon.rs?ref=d1e59d691039731b8ae05aadf8358c499dfa5b89", "patch": "@@ -3,6 +3,7 @@ import std._int;\n \n type pos = rec(uint line, uint col);\n type span = rec(str filename, pos lo, pos hi);\n+type spanned[T] = rec(T node, span span);\n \n // FIXME: import std.util.option and use it here.\n // import std.util.option;"}]}