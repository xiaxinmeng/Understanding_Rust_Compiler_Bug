{"sha": "b45fabddfddd3d70d79848be5ff45dd5ef6de9c5", "node_id": "C_kwDOAAsO6NoAKGI0NWZhYmRkZmRkZDNkNzBkNzk4NDhiZTVmZjQ1ZGQ1ZWY2ZGU5YzU", "commit": {"author": {"name": "Oli Scherer", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2022-01-27T14:57:56Z"}, "committer": {"name": "Oli Scherer", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2022-02-02T15:40:11Z"}, "message": "Inline a function that is only used once", "tree": {"sha": "92e30116c5123222eda9ee0219a7235b9bacbd74", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/92e30116c5123222eda9ee0219a7235b9bacbd74"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b45fabddfddd3d70d79848be5ff45dd5ef6de9c5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b45fabddfddd3d70d79848be5ff45dd5ef6de9c5", "html_url": "https://github.com/rust-lang/rust/commit/b45fabddfddd3d70d79848be5ff45dd5ef6de9c5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b45fabddfddd3d70d79848be5ff45dd5ef6de9c5/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d35d1ef4f52a6e90e138c3c4bd7cd23a044ae6e4", "url": "https://api.github.com/repos/rust-lang/rust/commits/d35d1ef4f52a6e90e138c3c4bd7cd23a044ae6e4", "html_url": "https://github.com/rust-lang/rust/commit/d35d1ef4f52a6e90e138c3c4bd7cd23a044ae6e4"}], "stats": {"total": 92, "additions": 39, "deletions": 53}, "files": [{"sha": "0819c2363ffbcbe1ad2f5f8a84d2d411961a72eb", "filename": "compiler/rustc_infer/src/infer/opaque_types.rs", "status": "modified", "additions": 39, "deletions": 53, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/b45fabddfddd3d70d79848be5ff45dd5ef6de9c5/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b45fabddfddd3d70d79848be5ff45dd5ef6de9c5/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs?ref=b45fabddfddd3d70d79848be5ff45dd5ef6de9c5", "patch": "@@ -80,12 +80,47 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         }\n         if self.defining_use_anchor.is_some() {\n             let process = |a: Ty<'tcx>, b: Ty<'tcx>| match *a.kind() {\n-                ty::Opaque(def_id, substs) => self.fold_opaque_ty_new(\n+                ty::Opaque(def_id, substs) => Some(self.register_hidden_type(\n                     OpaqueTypeKey { def_id, substs },\n                     cause.clone(),\n                     param_env,\n                     b,\n-                ),\n+                    // Check that this is `impl Trait` type is\n+                    // declared by `parent_def_id` -- i.e., one whose\n+                    // value we are inferring.  At present, this is\n+                    // always true during the first phase of\n+                    // type-check, but not always true later on during\n+                    // NLL. Once we support named opaque types more fully,\n+                    // this same scenario will be able to arise during all phases.\n+                    //\n+                    // Here is an example using type alias `impl Trait`\n+                    // that indicates the distinction we are checking for:\n+                    //\n+                    // ```rust\n+                    // mod a {\n+                    //   pub type Foo = impl Iterator;\n+                    //   pub fn make_foo() -> Foo { .. }\n+                    // }\n+                    //\n+                    // mod b {\n+                    //   fn foo() -> a::Foo { a::make_foo() }\n+                    // }\n+                    // ```\n+                    //\n+                    // Here, the return type of `foo` references an\n+                    // `Opaque` indeed, but not one whose value is\n+                    // presently being inferred. You can get into a\n+                    // similar situation with closure return types\n+                    // today:\n+                    //\n+                    // ```rust\n+                    // fn foo() -> impl Iterator { .. }\n+                    // fn bar() {\n+                    //     let x = || foo(); // returns the Opaque assoc with `foo`\n+                    // }\n+                    // ```\n+                    self.opaque_type_origin(def_id, cause.span)?,\n+                )),\n                 _ => None,\n             };\n             if let Some(res) = process(a, b) {\n@@ -479,63 +514,14 @@ impl UseKind {\n }\n \n impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n-    fn fold_opaque_ty_new(\n+    #[instrument(skip(self), level = \"debug\")]\n+    fn register_hidden_type(\n         &self,\n         opaque_type_key: OpaqueTypeKey<'tcx>,\n         cause: ObligationCause<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n         hidden_ty: Ty<'tcx>,\n-    ) -> Option<InferResult<'tcx, ()>> {\n-        // Check that this is `impl Trait` type is\n-        // declared by `parent_def_id` -- i.e., one whose\n-        // value we are inferring.  At present, this is\n-        // always true during the first phase of\n-        // type-check, but not always true later on during\n-        // NLL. Once we support named opaque types more fully,\n-        // this same scenario will be able to arise during all phases.\n-        //\n-        // Here is an example using type alias `impl Trait`\n-        // that indicates the distinction we are checking for:\n-        //\n-        // ```rust\n-        // mod a {\n-        //   pub type Foo = impl Iterator;\n-        //   pub fn make_foo() -> Foo { .. }\n-        // }\n-        //\n-        // mod b {\n-        //   fn foo() -> a::Foo { a::make_foo() }\n-        // }\n-        // ```\n-        //\n-        // Here, the return type of `foo` references an\n-        // `Opaque` indeed, but not one whose value is\n-        // presently being inferred. You can get into a\n-        // similar situation with closure return types\n-        // today:\n-        //\n-        // ```rust\n-        // fn foo() -> impl Iterator { .. }\n-        // fn bar() {\n-        //     let x = || foo(); // returns the Opaque assoc with `foo`\n-        // }\n-        // ```\n-        if let Some(origin) = self.opaque_type_origin(opaque_type_key.def_id, cause.span) {\n-            return Some(self.fold_opaque_ty(cause, param_env, opaque_type_key, origin, hidden_ty));\n-        }\n-\n-        debug!(?opaque_type_key, \"encountered opaque outside its definition scope\",);\n-        None\n-    }\n-\n-    #[instrument(skip(self), level = \"debug\")]\n-    fn fold_opaque_ty(\n-        &self,\n-        cause: ObligationCause<'tcx>,\n-        param_env: ty::ParamEnv<'tcx>,\n-        opaque_type_key: OpaqueTypeKey<'tcx>,\n         origin: hir::OpaqueTyOrigin,\n-        hidden_ty: Ty<'tcx>,\n     ) -> InferResult<'tcx, ()> {\n         let tcx = self.tcx;\n         let OpaqueTypeKey { def_id, substs } = opaque_type_key;"}]}