{"sha": "3897395787866281e98e3f0e41cf26dab5d94d7b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM4OTczOTU3ODc4NjYyODFlOThlM2YwZTQxY2YyNmRhYjVkOTRkN2I=", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2020-11-28T21:48:05Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2021-02-20T21:53:47Z"}, "message": "Move Query to rustc_query_system.\n\nRename it to QueryStackFrame and document a bit.", "tree": {"sha": "2a114967ca3e1965e2b2bdb9afc61456af463817", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2a114967ca3e1965e2b2bdb9afc61456af463817"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3897395787866281e98e3f0e41cf26dab5d94d7b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3897395787866281e98e3f0e41cf26dab5d94d7b", "html_url": "https://github.com/rust-lang/rust/commit/3897395787866281e98e3f0e41cf26dab5d94d7b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3897395787866281e98e3f0e41cf26dab5d94d7b/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0144d6a3b7e2f2bba4c7cc9adc04c2b6e4e01b93", "url": "https://api.github.com/repos/rust-lang/rust/commits/0144d6a3b7e2f2bba4c7cc9adc04c2b6e4e01b93", "html_url": "https://github.com/rust-lang/rust/commit/0144d6a3b7e2f2bba4c7cc9adc04c2b6e4e01b93"}], "stats": {"total": 278, "additions": 140, "deletions": 138}, "files": [{"sha": "bfba7c7410ede616c4aa6edef39308d8be183ca1", "filename": "compiler/rustc_query_impl/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3897395787866281e98e3f0e41cf26dab5d94d7b/compiler%2Frustc_query_impl%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3897395787866281e98e3f0e41cf26dab5d94d7b/compiler%2Frustc_query_impl%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Flib.rs?ref=3897395787866281e98e3f0e41cf26dab5d94d7b", "patch": "@@ -17,7 +17,6 @@ extern crate rustc_middle;\n extern crate tracing;\n \n use rustc_data_structures::fingerprint::Fingerprint;\n-use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_errors::{Diagnostic, Handler, Level};\n use rustc_hir::def_id::CrateNum;"}, {"sha": "01fb5a7ba20293ba66b78784913a681a64b13641", "filename": "compiler/rustc_query_impl/src/plumbing.rs", "status": "modified", "additions": 16, "deletions": 42, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/3897395787866281e98e3f0e41cf26dab5d94d7b/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3897395787866281e98e3f0e41cf26dab5d94d7b/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs?ref=3897395787866281e98e3f0e41cf26dab5d94d7b", "patch": "@@ -2,16 +2,15 @@\n //! generate the actual methods on tcx which find and execute the provider,\n //! manage the caches, and so forth.\n \n-use super::{queries, Query};\n+use super::queries;\n use rustc_middle::dep_graph::{DepKind, DepNode, DepNodeExt, DepNodeIndex, SerializedDepNodeIndex};\n use rustc_middle::ty::query::on_disk_cache;\n use rustc_middle::ty::tls::{self, ImplicitCtxt};\n use rustc_middle::ty::{self, TyCtxt};\n use rustc_query_system::dep_graph::HasDepContext;\n-use rustc_query_system::query::{CycleError, QueryJobId, QueryJobInfo};\n-use rustc_query_system::query::{QueryContext, QueryDescription};\n+use rustc_query_system::query::{CycleError, QueryJobId};\n+use rustc_query_system::query::{QueryContext, QueryDescription, QueryMap, QueryStackFrame};\n \n-use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::Lock;\n use rustc_data_structures::thin_vec::ThinVec;\n use rustc_errors::{struct_span_err, Diagnostic, DiagnosticBuilder};\n@@ -45,8 +44,6 @@ impl HasDepContext for QueryCtxt<'tcx> {\n }\n \n impl QueryContext for QueryCtxt<'tcx> {\n-    type Query = Query;\n-\n     fn def_path_str(&self, def_id: DefId) -> String {\n         self.tcx.def_path_str(def_id)\n     }\n@@ -55,10 +52,7 @@ impl QueryContext for QueryCtxt<'tcx> {\n         tls::with_related_context(**self, |icx| icx.query)\n     }\n \n-    fn try_collect_active_jobs(\n-        &self,\n-    ) -> Option<FxHashMap<QueryJobId<Self::DepKind>, QueryJobInfo<Self::DepKind, Self::Query>>>\n-    {\n+    fn try_collect_active_jobs(&self) -> Option<QueryMap<Self::DepKind>> {\n         self.queries.try_collect_active_jobs(**self)\n     }\n \n@@ -185,11 +179,11 @@ impl<'tcx> QueryCtxt<'tcx> {\n     #[cold]\n     pub(super) fn report_cycle(\n         self,\n-        CycleError { usage, cycle: stack }: CycleError<Query>,\n+        CycleError { usage, cycle: stack }: CycleError,\n     ) -> DiagnosticBuilder<'tcx> {\n         assert!(!stack.is_empty());\n \n-        let fix_span = |span: Span, query: &Query| {\n+        let fix_span = |span: Span, query: &QueryStackFrame| {\n             self.sess.source_map().guess_head_span(query.default_span(span))\n         };\n \n@@ -371,17 +365,12 @@ macro_rules! define_queries {\n             input: ($(([$($modifiers)*] [$($attr)*] [$name]))*)\n         }\n \n-        #[derive(Clone, Debug)]\n-        pub struct Query {\n-            pub name: &'static str,\n-            hash: Fingerprint,\n-            description: String,\n-            span: Option<Span>,\n-        }\n+        mod make_query {\n+            use super::*;\n \n-        impl Query {\n+            // Create an eponymous constructor for each query.\n             $(#[allow(nonstandard_style)] $(#[$attr])*\n-            pub fn $name<$tcx>(tcx: QueryCtxt<$tcx>, key: query_keys::$name<$tcx>) -> Self {\n+            pub fn $name<$tcx>(tcx: QueryCtxt<$tcx>, key: query_keys::$name<$tcx>) -> QueryStackFrame {\n                 let kind = dep_graph::DepKind::$name;\n                 let name = stringify!($name);\n                 let description = ty::print::with_forced_impl_filename_line(\n@@ -408,22 +397,8 @@ macro_rules! define_queries {\n                     hasher.finish()\n                 };\n \n-                Self { name, description, span, hash }\n+                QueryStackFrame::new(name, description, span, hash)\n             })*\n-\n-            // FIXME(eddyb) Get more valid `Span`s on queries.\n-            pub fn default_span(&self, span: Span) -> Span {\n-                if !span.is_dummy() {\n-                    return span;\n-                }\n-                self.span.unwrap_or(span)\n-            }\n-        }\n-\n-        impl<'a> HashStable<StableHashingContext<'a>> for Query {\n-            fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n-                self.hash.hash_stable(hcx, hasher)\n-            }\n         }\n \n         #[allow(nonstandard_style)]\n@@ -450,7 +425,7 @@ macro_rules! define_queries {\n             type Cache = query_storage::$name<$tcx>;\n \n             #[inline(always)]\n-            fn query_state<'a>(tcx: QueryCtxt<$tcx>) -> &'a QueryState<crate::dep_graph::DepKind, Query, Self::Key>\n+            fn query_state<'a>(tcx: QueryCtxt<$tcx>) -> &'a QueryState<crate::dep_graph::DepKind, Self::Key>\n                 where QueryCtxt<$tcx>: 'a\n             {\n                 &tcx.queries.$name\n@@ -484,7 +459,7 @@ macro_rules! define_queries {\n \n             fn handle_cycle_error(\n                 tcx: QueryCtxt<'tcx>,\n-                error: CycleError<Query>\n+                error: CycleError,\n             ) -> Self::Value {\n                 handle_cycle_error!([$($modifiers)*][tcx, error])\n             }\n@@ -587,7 +562,6 @@ macro_rules! define_queries_struct {\n \n             $($(#[$attr])*  $name: QueryState<\n                 crate::dep_graph::DepKind,\n-                Query,\n                 query_keys::$name<$tcx>,\n             >,)*\n         }\n@@ -607,15 +581,15 @@ macro_rules! define_queries_struct {\n             pub(crate) fn try_collect_active_jobs(\n                 &$tcx self,\n                 tcx: TyCtxt<$tcx>,\n-            ) -> Option<FxHashMap<QueryJobId<crate::dep_graph::DepKind>, QueryJobInfo<crate::dep_graph::DepKind, Query>>> {\n+            ) -> Option<QueryMap<crate::dep_graph::DepKind>> {\n                 let tcx = QueryCtxt { tcx, queries: self };\n-                let mut jobs = FxHashMap::default();\n+                let mut jobs = QueryMap::default();\n \n                 $(\n                     self.$name.try_collect_active_jobs(\n                         tcx,\n                         dep_graph::DepKind::$name,\n-                        Query::$name,\n+                        make_query::$name,\n                         &mut jobs,\n                     )?;\n                 )*"}, {"sha": "d01b0de3b4803362c4bf5d9c05c38f5ce7d7f4e7", "filename": "compiler/rustc_query_system/src/query/config.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3897395787866281e98e3f0e41cf26dab5d94d7b/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3897395787866281e98e3f0e41cf26dab5d94d7b/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fconfig.rs?ref=3897395787866281e98e3f0e41cf26dab5d94d7b", "patch": "@@ -27,7 +27,7 @@ pub(crate) struct QueryVtable<CTX: QueryContext, K, V> {\n     pub compute: fn(CTX, K) -> V,\n \n     pub hash_result: fn(&mut CTX::StableHashingContext, &V) -> Option<Fingerprint>,\n-    pub handle_cycle_error: fn(CTX, CycleError<CTX::Query>) -> V,\n+    pub handle_cycle_error: fn(CTX, CycleError) -> V,\n     pub cache_on_disk: fn(CTX, &K, Option<&V>) -> bool,\n     pub try_load_from_disk: fn(CTX, SerializedDepNodeIndex) -> Option<V>,\n }\n@@ -52,7 +52,7 @@ impl<CTX: QueryContext, K, V> QueryVtable<CTX, K, V> {\n         (self.hash_result)(hcx, value)\n     }\n \n-    pub(crate) fn handle_cycle_error(&self, tcx: CTX, error: CycleError<CTX::Query>) -> V {\n+    pub(crate) fn handle_cycle_error(&self, tcx: CTX, error: CycleError) -> V {\n         (self.handle_cycle_error)(tcx, error)\n     }\n \n@@ -73,7 +73,7 @@ pub trait QueryAccessors<CTX: QueryContext>: QueryConfig {\n     type Cache: QueryCache<Key = Self::Key, Stored = Self::Stored, Value = Self::Value>;\n \n     // Don't use this method to access query results, instead use the methods on TyCtxt\n-    fn query_state<'a>(tcx: CTX) -> &'a QueryState<CTX::DepKind, CTX::Query, Self::Key>\n+    fn query_state<'a>(tcx: CTX) -> &'a QueryState<CTX::DepKind, Self::Key>\n     where\n         CTX: 'a;\n \n@@ -90,7 +90,7 @@ pub trait QueryAccessors<CTX: QueryContext>: QueryConfig {\n         result: &Self::Value,\n     ) -> Option<Fingerprint>;\n \n-    fn handle_cycle_error(tcx: CTX, error: CycleError<CTX::Query>) -> Self::Value;\n+    fn handle_cycle_error(tcx: CTX, error: CycleError) -> Self::Value;\n }\n \n pub trait QueryDescription<CTX: QueryContext>: QueryAccessors<CTX> {"}, {"sha": "cc3cefe46bef296aa3c2242bdcac977ee209cf04", "filename": "compiler/rustc_query_system/src/query/job.rs", "status": "modified", "additions": 43, "deletions": 48, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/3897395787866281e98e3f0e41cf26dab5d94d7b/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fjob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3897395787866281e98e3f0e41cf26dab5d94d7b/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fjob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fjob.rs?ref=3897395787866281e98e3f0e41cf26dab5d94d7b", "patch": "@@ -1,4 +1,5 @@\n use crate::query::plumbing::CycleError;\n+use crate::query::QueryStackFrame;\n \n use rustc_data_structures::fx::FxHashMap;\n use rustc_span::Span;\n@@ -26,13 +27,13 @@ use {\n \n /// Represents a span and a query key.\n #[derive(Clone, Debug)]\n-pub struct QueryInfo<Q> {\n+pub struct QueryInfo {\n     /// The span corresponding to the reason for which this query was required.\n     pub span: Span,\n-    pub query: Q,\n+    pub query: QueryStackFrame,\n }\n \n-pub(crate) type QueryMap<D, Q> = FxHashMap<QueryJobId<D>, QueryJobInfo<D, Q>>;\n+pub type QueryMap<D> = FxHashMap<QueryJobId<D>, QueryJobInfo<D>>;\n \n /// A value uniquely identifying an active query job within a shard in the query cache.\n #[derive(Copy, Clone, Eq, PartialEq, Hash)]\n@@ -59,34 +60,34 @@ where\n         QueryJobId { job, shard: u16::try_from(shard).unwrap(), kind }\n     }\n \n-    fn query<Q: Clone>(self, map: &QueryMap<D, Q>) -> Q {\n+    fn query(self, map: &QueryMap<D>) -> QueryStackFrame {\n         map.get(&self).unwrap().info.query.clone()\n     }\n \n     #[cfg(parallel_compiler)]\n-    fn span<Q: Clone>(self, map: &QueryMap<D, Q>) -> Span {\n+    fn span(self, map: &QueryMap<D>) -> Span {\n         map.get(&self).unwrap().job.span\n     }\n \n     #[cfg(parallel_compiler)]\n-    fn parent<Q: Clone>(self, map: &QueryMap<D, Q>) -> Option<QueryJobId<D>> {\n+    fn parent(self, map: &QueryMap<D>) -> Option<QueryJobId<D>> {\n         map.get(&self).unwrap().job.parent\n     }\n \n     #[cfg(parallel_compiler)]\n-    fn latch<'a, Q: Clone>(self, map: &'a QueryMap<D, Q>) -> Option<&'a QueryLatch<D, Q>> {\n+    fn latch<'a>(self, map: &'a QueryMap<D>) -> Option<&'a QueryLatch<D>> {\n         map.get(&self).unwrap().job.latch.as_ref()\n     }\n }\n \n-pub struct QueryJobInfo<D, Q> {\n-    pub info: QueryInfo<Q>,\n-    pub job: QueryJob<D, Q>,\n+pub struct QueryJobInfo<D> {\n+    pub info: QueryInfo,\n+    pub job: QueryJob<D>,\n }\n \n /// Represents an active query job.\n #[derive(Clone)]\n-pub struct QueryJob<D, Q> {\n+pub struct QueryJob<D> {\n     pub id: QueryShardJobId,\n \n     /// The span corresponding to the reason for which this query was required.\n@@ -97,15 +98,14 @@ pub struct QueryJob<D, Q> {\n \n     /// The latch that is used to wait on this job.\n     #[cfg(parallel_compiler)]\n-    latch: Option<QueryLatch<D, Q>>,\n+    latch: Option<QueryLatch<D>>,\n \n-    dummy: PhantomData<QueryLatch<D, Q>>,\n+    dummy: PhantomData<QueryLatch<D>>,\n }\n \n-impl<D, Q> QueryJob<D, Q>\n+impl<D> QueryJob<D>\n where\n     D: Copy + Clone + Eq + Hash,\n-    Q: Clone,\n {\n     /// Creates a new query job.\n     pub fn new(id: QueryShardJobId, span: Span, parent: Option<QueryJobId<D>>) -> Self {\n@@ -120,16 +120,16 @@ where\n     }\n \n     #[cfg(parallel_compiler)]\n-    pub(super) fn latch(&mut self, _id: QueryJobId<D>) -> QueryLatch<D, Q> {\n+    pub(super) fn latch(&mut self, _id: QueryJobId<D>) -> QueryLatch<D> {\n         if self.latch.is_none() {\n             self.latch = Some(QueryLatch::new());\n         }\n         self.latch.as_ref().unwrap().clone()\n     }\n \n     #[cfg(not(parallel_compiler))]\n-    pub(super) fn latch(&mut self, id: QueryJobId<D>) -> QueryLatch<D, Q> {\n-        QueryLatch { id, dummy: PhantomData }\n+    pub(super) fn latch(&mut self, id: QueryJobId<D>) -> QueryLatch<D> {\n+        QueryLatch { id }\n     }\n \n     /// Signals to waiters that the query is complete.\n@@ -148,23 +148,21 @@ where\n \n #[cfg(not(parallel_compiler))]\n #[derive(Clone)]\n-pub(super) struct QueryLatch<D, Q> {\n+pub(super) struct QueryLatch<D> {\n     id: QueryJobId<D>,\n-    dummy: PhantomData<Q>,\n }\n \n #[cfg(not(parallel_compiler))]\n-impl<D, Q> QueryLatch<D, Q>\n+impl<D> QueryLatch<D>\n where\n     D: Copy + Clone + Eq + Hash,\n-    Q: Clone,\n {\n     pub(super) fn find_cycle_in_stack(\n         &self,\n-        query_map: QueryMap<D, Q>,\n+        query_map: QueryMap<D>,\n         current_job: &Option<QueryJobId<D>>,\n         span: Span,\n-    ) -> CycleError<Q> {\n+    ) -> CycleError {\n         // Find the waitee amongst `current_job` parents\n         let mut cycle = Vec::new();\n         let mut current_job = Option::clone(current_job);\n@@ -198,35 +196,35 @@ where\n }\n \n #[cfg(parallel_compiler)]\n-struct QueryWaiter<D, Q> {\n+struct QueryWaiter<D> {\n     query: Option<QueryJobId<D>>,\n     condvar: Condvar,\n     span: Span,\n-    cycle: Lock<Option<CycleError<Q>>>,\n+    cycle: Lock<Option<CycleError>>,\n }\n \n #[cfg(parallel_compiler)]\n-impl<D, Q> QueryWaiter<D, Q> {\n+impl<D> QueryWaiter<D> {\n     fn notify(&self, registry: &rayon_core::Registry) {\n         rayon_core::mark_unblocked(registry);\n         self.condvar.notify_one();\n     }\n }\n \n #[cfg(parallel_compiler)]\n-struct QueryLatchInfo<D, Q> {\n+struct QueryLatchInfo<D> {\n     complete: bool,\n-    waiters: Vec<Lrc<QueryWaiter<D, Q>>>,\n+    waiters: Vec<Lrc<QueryWaiter<D>>>,\n }\n \n #[cfg(parallel_compiler)]\n #[derive(Clone)]\n-pub(super) struct QueryLatch<D, Q> {\n-    info: Lrc<Mutex<QueryLatchInfo<D, Q>>>,\n+pub(super) struct QueryLatch<D> {\n+    info: Lrc<Mutex<QueryLatchInfo<D>>>,\n }\n \n #[cfg(parallel_compiler)]\n-impl<D: Eq + Hash, Q: Clone> QueryLatch<D, Q> {\n+impl<D: Eq + Hash> QueryLatch<D> {\n     fn new() -> Self {\n         QueryLatch {\n             info: Lrc::new(Mutex::new(QueryLatchInfo { complete: false, waiters: Vec::new() })),\n@@ -235,13 +233,13 @@ impl<D: Eq + Hash, Q: Clone> QueryLatch<D, Q> {\n }\n \n #[cfg(parallel_compiler)]\n-impl<D, Q> QueryLatch<D, Q> {\n+impl<D> QueryLatch<D> {\n     /// Awaits for the query job to complete.\n     pub(super) fn wait_on(\n         &self,\n         query: Option<QueryJobId<D>>,\n         span: Span,\n-    ) -> Result<(), CycleError<Q>> {\n+    ) -> Result<(), CycleError> {\n         let waiter =\n             Lrc::new(QueryWaiter { query, span, cycle: Lock::new(None), condvar: Condvar::new() });\n         self.wait_on_inner(&waiter);\n@@ -256,7 +254,7 @@ impl<D, Q> QueryLatch<D, Q> {\n     }\n \n     /// Awaits the caller on this latch by blocking the current thread.\n-    fn wait_on_inner(&self, waiter: &Lrc<QueryWaiter<D, Q>>) {\n+    fn wait_on_inner(&self, waiter: &Lrc<QueryWaiter<D>>) {\n         let mut info = self.info.lock();\n         if !info.complete {\n             // We push the waiter on to the `waiters` list. It can be accessed inside\n@@ -290,7 +288,7 @@ impl<D, Q> QueryLatch<D, Q> {\n \n     /// Removes a single waiter from the list of waiters.\n     /// This is used to break query cycles.\n-    fn extract_waiter(&self, waiter: usize) -> Lrc<QueryWaiter<D, Q>> {\n+    fn extract_waiter(&self, waiter: usize) -> Lrc<QueryWaiter<D>> {\n         let mut info = self.info.lock();\n         debug_assert!(!info.complete);\n         // Remove the waiter from the list of waiters\n@@ -312,14 +310,13 @@ type Waiter<D> = (QueryJobId<D>, usize);\n /// required information to resume the waiter.\n /// If all `visit` calls returns None, this function also returns None.\n #[cfg(parallel_compiler)]\n-fn visit_waiters<D, Q, F>(\n-    query_map: &QueryMap<D, Q>,\n+fn visit_waiters<D, F>(\n+    query_map: &QueryMap<D>,\n     query: QueryJobId<D>,\n     mut visit: F,\n ) -> Option<Option<Waiter<D>>>\n where\n     D: Copy + Clone + Eq + Hash,\n-    Q: Clone,\n     F: FnMut(Span, QueryJobId<D>) -> Option<Option<Waiter<D>>>,\n {\n     // Visit the parent query which is a non-resumable waiter since it's on the same stack\n@@ -349,16 +346,15 @@ where\n /// If a cycle is detected, this initial value is replaced with the span causing\n /// the cycle.\n #[cfg(parallel_compiler)]\n-fn cycle_check<D, Q>(\n-    query_map: &QueryMap<D, Q>,\n+fn cycle_check<D>(\n+    query_map: &QueryMap<D>,\n     query: QueryJobId<D>,\n     span: Span,\n     stack: &mut Vec<(Span, QueryJobId<D>)>,\n     visited: &mut FxHashSet<QueryJobId<D>>,\n ) -> Option<Option<Waiter<D>>>\n where\n     D: Copy + Clone + Eq + Hash,\n-    Q: Clone,\n {\n     if !visited.insert(query) {\n         return if let Some(p) = stack.iter().position(|q| q.1 == query) {\n@@ -394,14 +390,13 @@ where\n /// from `query` without going through any of the queries in `visited`.\n /// This is achieved with a depth first search.\n #[cfg(parallel_compiler)]\n-fn connected_to_root<D, Q>(\n-    query_map: &QueryMap<D, Q>,\n+fn connected_to_root<D>(\n+    query_map: &QueryMap<D>,\n     query: QueryJobId<D>,\n     visited: &mut FxHashSet<QueryJobId<D>>,\n ) -> bool\n where\n     D: Copy + Clone + Eq + Hash,\n-    Q: Clone,\n {\n     // We already visited this or we're deliberately ignoring it\n     if !visited.insert(query) {\n@@ -422,7 +417,7 @@ where\n // Deterministically pick an query from a list\n #[cfg(parallel_compiler)]\n fn pick_query<'a, CTX, T, F>(\n-    query_map: &QueryMap<CTX::DepKind, CTX::Query>,\n+    query_map: &QueryMap<CTX::DepKind>,\n     tcx: CTX,\n     queries: &'a [T],\n     f: F,\n@@ -456,9 +451,9 @@ where\n /// the function returns false.\n #[cfg(parallel_compiler)]\n fn remove_cycle<CTX: QueryContext>(\n-    query_map: &QueryMap<CTX::DepKind, CTX::Query>,\n+    query_map: &QueryMap<CTX::DepKind>,\n     jobs: &mut Vec<QueryJobId<CTX::DepKind>>,\n-    wakelist: &mut Vec<Lrc<QueryWaiter<CTX::DepKind, CTX::Query>>>,\n+    wakelist: &mut Vec<Lrc<QueryWaiter<CTX::DepKind>>>,\n     tcx: CTX,\n ) -> bool {\n     let mut visited = FxHashSet::default();"}, {"sha": "7b46674c74338dcfa89729ab7fc644c58c0b686a", "filename": "compiler/rustc_query_system/src/query/mod.rs", "status": "modified", "additions": 45, "deletions": 6, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/3897395787866281e98e3f0e41cf26dab5d94d7b/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3897395787866281e98e3f0e41cf26dab5d94d7b/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fmod.rs?ref=3897395787866281e98e3f0e41cf26dab5d94d7b", "patch": "@@ -4,7 +4,7 @@ pub use self::plumbing::*;\n mod job;\n #[cfg(parallel_compiler)]\n pub use self::job::deadlock;\n-pub use self::job::{QueryInfo, QueryJob, QueryJobId, QueryJobInfo};\n+pub use self::job::{QueryInfo, QueryJob, QueryJobId, QueryJobInfo, QueryMap};\n \n mod caches;\n pub use self::caches::{\n@@ -15,24 +15,63 @@ mod config;\n pub use self::config::{QueryAccessors, QueryConfig, QueryDescription};\n \n use crate::dep_graph::{DepNode, DepNodeIndex, HasDepContext, SerializedDepNodeIndex};\n-use crate::query::job::QueryMap;\n \n-use rustc_data_structures::stable_hasher::HashStable;\n+use rustc_data_structures::fingerprint::Fingerprint;\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::sync::Lock;\n use rustc_data_structures::thin_vec::ThinVec;\n use rustc_errors::Diagnostic;\n use rustc_span::def_id::DefId;\n+use rustc_span::Span;\n \n-pub trait QueryContext: HasDepContext {\n-    type Query: Clone + HashStable<Self::StableHashingContext>;\n+/// Description of a frame in the query stack.\n+///\n+/// This is mostly used in case of cycles for error reporting.\n+#[derive(Clone, Debug)]\n+pub struct QueryStackFrame {\n+    pub name: &'static str,\n+    pub description: String,\n+    span: Option<Span>,\n+    /// This hash is used to deterministically pick\n+    /// a query to remove cycles in the parallel compiler.\n+    hash: Fingerprint,\n+}\n+\n+impl QueryStackFrame {\n+    #[inline]\n+    pub fn new(\n+        name: &'static str,\n+        description: String,\n+        span: Option<Span>,\n+        hash: Fingerprint,\n+    ) -> Self {\n+        Self { name, hash, description, span }\n+    }\n+\n+    // FIXME(eddyb) Get more valid `Span`s on queries.\n+    #[inline]\n+    pub fn default_span(&self, span: Span) -> Span {\n+        if !span.is_dummy() {\n+            return span;\n+        }\n+        self.span.unwrap_or(span)\n+    }\n+}\n+\n+impl<CTX> HashStable<CTX> for QueryStackFrame {\n+    fn hash_stable(&self, hcx: &mut CTX, hasher: &mut StableHasher) {\n+        self.hash.hash_stable(hcx, hasher)\n+    }\n+}\n \n+pub trait QueryContext: HasDepContext {\n     /// Get string representation from DefPath.\n     fn def_path_str(&self, def_id: DefId) -> String;\n \n     /// Get the query information from the TLS context.\n     fn current_query_job(&self) -> Option<QueryJobId<Self::DepKind>>;\n \n-    fn try_collect_active_jobs(&self) -> Option<QueryMap<Self::DepKind, Self::Query>>;\n+    fn try_collect_active_jobs(&self) -> Option<QueryMap<Self::DepKind>>;\n \n     /// Load data from the on-disk cache.\n     fn try_load_from_on_disk_cache(&self, dep_node: &DepNode<Self::DepKind>);"}, {"sha": "28ee1a179942c8b242590d419057b9b245a47d81", "filename": "compiler/rustc_query_system/src/query/plumbing.rs", "status": "modified", "additions": 32, "deletions": 37, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/3897395787866281e98e3f0e41cf26dab5d94d7b/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3897395787866281e98e3f0e41cf26dab5d94d7b/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs?ref=3897395787866281e98e3f0e41cf26dab5d94d7b", "patch": "@@ -7,7 +7,7 @@ use crate::dep_graph::{DepNodeIndex, SerializedDepNodeIndex};\n use crate::query::caches::QueryCache;\n use crate::query::config::{QueryDescription, QueryVtable, QueryVtableExt};\n use crate::query::job::{QueryInfo, QueryJob, QueryJobId, QueryJobInfo, QueryShardJobId};\n-use crate::query::{QueryContext, QueryMap};\n+use crate::query::{QueryContext, QueryMap, QueryStackFrame};\n \n #[cfg(not(parallel_compiler))]\n use rustc_data_structures::cold_path;\n@@ -81,37 +81,36 @@ impl<C: QueryCache> QueryCacheStore<C> {\n     }\n }\n \n-struct QueryStateShard<D, Q, K> {\n-    active: FxHashMap<K, QueryResult<D, Q>>,\n+struct QueryStateShard<D, K> {\n+    active: FxHashMap<K, QueryResult<D>>,\n \n     /// Used to generate unique ids for active jobs.\n     jobs: u32,\n }\n \n-impl<D, Q, K> Default for QueryStateShard<D, Q, K> {\n-    fn default() -> QueryStateShard<D, Q, K> {\n+impl<D, K> Default for QueryStateShard<D, K> {\n+    fn default() -> QueryStateShard<D, K> {\n         QueryStateShard { active: Default::default(), jobs: 0 }\n     }\n }\n \n-pub struct QueryState<D, Q, K> {\n-    shards: Sharded<QueryStateShard<D, Q, K>>,\n+pub struct QueryState<D, K> {\n+    shards: Sharded<QueryStateShard<D, K>>,\n }\n \n /// Indicates the state of a query for a given key in a query map.\n-enum QueryResult<D, Q> {\n+enum QueryResult<D> {\n     /// An already executing query. The query job can be used to await for its completion.\n-    Started(QueryJob<D, Q>),\n+    Started(QueryJob<D>),\n \n     /// The query panicked. Queries trying to wait on this will raise a fatal error which will\n     /// silently panic.\n     Poisoned,\n }\n \n-impl<D, Q, K> QueryState<D, Q, K>\n+impl<D, K> QueryState<D, K>\n where\n     D: Copy + Clone + Eq + Hash,\n-    Q: Clone,\n     K: Eq + Hash + Clone + Debug,\n {\n     pub fn all_inactive(&self) -> bool {\n@@ -123,8 +122,8 @@ where\n         &self,\n         tcx: CTX,\n         kind: D,\n-        make_query: fn(CTX, K) -> Q,\n-        jobs: &mut QueryMap<D, Q>,\n+        make_query: fn(CTX, K) -> QueryStackFrame,\n+        jobs: &mut QueryMap<D>,\n     ) -> Option<()> {\n         // We use try_lock_shards here since we are called from the\n         // deadlock handler, and this shouldn't be locked.\n@@ -146,30 +145,28 @@ where\n     }\n }\n \n-impl<D, Q, K> Default for QueryState<D, Q, K> {\n-    fn default() -> QueryState<D, Q, K> {\n+impl<D, K> Default for QueryState<D, K> {\n+    fn default() -> QueryState<D, K> {\n         QueryState { shards: Default::default() }\n     }\n }\n \n /// A type representing the responsibility to execute the job in the `job` field.\n /// This will poison the relevant query if dropped.\n-struct JobOwner<'tcx, D, Q, C>\n+struct JobOwner<'tcx, D, C>\n where\n     D: Copy + Clone + Eq + Hash,\n-    Q: Clone,\n     C: QueryCache,\n {\n-    state: &'tcx QueryState<D, Q, C::Key>,\n+    state: &'tcx QueryState<D, C::Key>,\n     cache: &'tcx QueryCacheStore<C>,\n     key: C::Key,\n     id: QueryJobId<D>,\n }\n \n-impl<'tcx, D, Q, C> JobOwner<'tcx, D, Q, C>\n+impl<'tcx, D, C> JobOwner<'tcx, D, C>\n where\n     D: Copy + Clone + Eq + Hash,\n-    Q: Clone,\n     C: QueryCache,\n {\n     /// Either gets a `JobOwner` corresponding the query, allowing us to\n@@ -183,13 +180,13 @@ where\n     #[inline(always)]\n     fn try_start<'b, CTX>(\n         tcx: CTX,\n-        state: &'b QueryState<CTX::DepKind, CTX::Query, C::Key>,\n+        state: &'b QueryState<CTX::DepKind, C::Key>,\n         cache: &'b QueryCacheStore<C>,\n         span: Span,\n         key: &C::Key,\n         lookup: QueryLookup,\n         query: &QueryVtable<CTX, C::Key, C::Value>,\n-    ) -> TryGetJob<'b, CTX::DepKind, CTX::Query, C>\n+    ) -> TryGetJob<'b, CTX::DepKind, C>\n     where\n         CTX: QueryContext,\n     {\n@@ -243,7 +240,7 @@ where\n         // so we just return the error.\n         #[cfg(not(parallel_compiler))]\n         return TryGetJob::Cycle(cold_path(|| {\n-            let error: CycleError<CTX::Query> = latch.find_cycle_in_stack(\n+            let error: CycleError = latch.find_cycle_in_stack(\n                 tcx.try_collect_active_jobs().unwrap(),\n                 &tcx.current_query_job(),\n                 span,\n@@ -328,10 +325,9 @@ where\n     (result, diagnostics.into_inner())\n }\n \n-impl<'tcx, D, Q, C> Drop for JobOwner<'tcx, D, Q, C>\n+impl<'tcx, D, C> Drop for JobOwner<'tcx, D, C>\n where\n     D: Copy + Clone + Eq + Hash,\n-    Q: Clone,\n     C: QueryCache,\n {\n     #[inline(never)]\n@@ -356,21 +352,20 @@ where\n }\n \n #[derive(Clone)]\n-pub struct CycleError<Q> {\n+pub struct CycleError {\n     /// The query and related span that uses the cycle.\n-    pub usage: Option<(Span, Q)>,\n-    pub cycle: Vec<QueryInfo<Q>>,\n+    pub usage: Option<(Span, QueryStackFrame)>,\n+    pub cycle: Vec<QueryInfo>,\n }\n \n /// The result of `try_start`.\n-enum TryGetJob<'tcx, D, Q, C>\n+enum TryGetJob<'tcx, D, C>\n where\n     D: Copy + Clone + Eq + Hash,\n-    Q: Clone,\n     C: QueryCache,\n {\n     /// The query is not yet started. Contains a guard to the cache eventually used to start it.\n-    NotYetStarted(JobOwner<'tcx, D, Q, C>),\n+    NotYetStarted(JobOwner<'tcx, D, C>),\n \n     /// The query was already completed.\n     /// Returns the result of the query and its dep-node index\n@@ -414,7 +409,7 @@ where\n \n fn try_execute_query<CTX, C>(\n     tcx: CTX,\n-    state: &QueryState<CTX::DepKind, CTX::Query, C::Key>,\n+    state: &QueryState<CTX::DepKind, C::Key>,\n     cache: &QueryCacheStore<C>,\n     span: Span,\n     key: C::Key,\n@@ -426,7 +421,7 @@ where\n     C::Key: crate::dep_graph::DepNodeParams<CTX::DepContext>,\n     CTX: QueryContext,\n {\n-    let job = match JobOwner::<'_, CTX::DepKind, CTX::Query, C>::try_start(\n+    let job = match JobOwner::<'_, CTX::DepKind, C>::try_start(\n         tcx, state, cache, span, &key, lookup, query,\n     ) {\n         TryGetJob::NotYetStarted(job) => job,\n@@ -590,7 +585,7 @@ fn incremental_verify_ich<CTX, K, V: Debug>(\n fn force_query_with_job<C, CTX>(\n     tcx: CTX,\n     key: C::Key,\n-    job: JobOwner<'_, CTX::DepKind, CTX::Query, C>,\n+    job: JobOwner<'_, CTX::DepKind, C>,\n     dep_node: DepNode<CTX::DepKind>,\n     query: &QueryVtable<CTX, C::Key, C::Value>,\n ) -> (C::Stored, DepNodeIndex)\n@@ -650,7 +645,7 @@ where\n #[inline(never)]\n fn get_query_impl<CTX, C>(\n     tcx: CTX,\n-    state: &QueryState<CTX::DepKind, CTX::Query, C::Key>,\n+    state: &QueryState<CTX::DepKind, C::Key>,\n     cache: &QueryCacheStore<C>,\n     span: Span,\n     key: C::Key,\n@@ -708,7 +703,7 @@ where\n #[inline(never)]\n fn force_query_impl<CTX, C>(\n     tcx: CTX,\n-    state: &QueryState<CTX::DepKind, CTX::Query, C::Key>,\n+    state: &QueryState<CTX::DepKind, C::Key>,\n     cache: &QueryCacheStore<C>,\n     key: C::Key,\n     span: Span,\n@@ -736,7 +731,7 @@ fn force_query_impl<CTX, C>(\n         Err(lookup) => lookup,\n     };\n \n-    let job = match JobOwner::<'_, CTX::DepKind, CTX::Query, C>::try_start(\n+    let job = match JobOwner::<'_, CTX::DepKind, C>::try_start(\n         tcx, state, cache, span, &key, lookup, query,\n     ) {\n         TryGetJob::NotYetStarted(job) => job,"}]}