{"sha": "8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhjZjdkOWIwMzdiYmRmNWNkOTcwYjJmMTMzZGRkN2QzOWFjYzE1ODg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-03-31T21:57:48Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-03-31T21:57:48Z"}, "message": "Auto merge of #7010 - camsteffen:if-chain-lint, r=llogiq\n\nInternal `if_chain!` lints\n\nchangelog: none\n\nWe use `if_chain!` a lot. So this enforces some style rules around it, internal only.\n\nLints when...\n* Nested `if`/`if_chain!` can be collapsed\n* An `if_chain!` starts with `let` or ends with `let ..; then {..}`\n* An `if_chain!` has only one `if`\n* An `if_chain!` contains `if .. && ..;` that spans multiple lines", "tree": {"sha": "8feaa3043bd6d70bb470d559eb8c2274351ef84f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8feaa3043bd6d70bb470d559eb8c2274351ef84f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588", "html_url": "https://github.com/rust-lang/rust/commit/8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "459bca84b72ea92a8b7cfffb53a14d9cb3de0a4b", "url": "https://api.github.com/repos/rust-lang/rust/commits/459bca84b72ea92a8b7cfffb53a14d9cb3de0a4b", "html_url": "https://github.com/rust-lang/rust/commit/459bca84b72ea92a8b7cfffb53a14d9cb3de0a4b"}, {"sha": "827d6aaad4a7ec24dd3191160cefe0c1e0b654b9", "url": "https://api.github.com/repos/rust-lang/rust/commits/827d6aaad4a7ec24dd3191160cefe0c1e0b654b9", "html_url": "https://github.com/rust-lang/rust/commit/827d6aaad4a7ec24dd3191160cefe0c1e0b654b9"}], "stats": {"total": 1359, "additions": 822, "deletions": 537}, "files": [{"sha": "0ce46e1c21458a3f8bc0f5d439b2482ce4477db5", "filename": "clippy_lints/src/attrs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588/clippy_lints%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588/clippy_lints%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fattrs.rs?ref=8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588", "patch": "@@ -371,8 +371,8 @@ fn extract_clippy_lint(lint: &NestedMetaItem) -> Option<SymbolStr> {\n         if meta_item.path.segments.len() > 1;\n         if let tool_name = meta_item.path.segments[0].ident;\n         if tool_name.name == sym::clippy;\n-        let lint_name = meta_item.path.segments.last().unwrap().ident.name;\n         then {\n+            let lint_name = meta_item.path.segments.last().unwrap().ident.name;\n             return Some(lint_name.as_str());\n         }\n     }"}, {"sha": "1546d82316729215f876a87478fe8863c8a3623b", "filename": "clippy_lints/src/bytecount.rs", "status": "modified", "additions": 39, "deletions": 43, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588/clippy_lints%2Fsrc%2Fbytecount.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588/clippy_lints%2Fsrc%2Fbytecount.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbytecount.rs?ref=8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588", "patch": "@@ -45,52 +45,48 @@ impl<'tcx> LateLintPass<'tcx> for ByteCount {\n             if filter.ident.name == sym!(filter);\n             if filter_args.len() == 2;\n             if let ExprKind::Closure(_, _, body_id, _, _) = filter_args[1].kind;\n+            let body = cx.tcx.hir().body(body_id);\n+            if body.params.len() == 1;\n+            if let Some(argname) = get_pat_name(&body.params[0].pat);\n+            if let ExprKind::Binary(ref op, ref l, ref r) = body.value.kind;\n+            if op.node == BinOpKind::Eq;\n+            if match_type(cx,\n+                       cx.typeck_results().expr_ty(&filter_args[0]).peel_refs(),\n+                       &paths::SLICE_ITER);\n             then {\n-                let body = cx.tcx.hir().body(body_id);\n-                if_chain! {\n-                    if body.params.len() == 1;\n-                    if let Some(argname) = get_pat_name(&body.params[0].pat);\n-                    if let ExprKind::Binary(ref op, ref l, ref r) = body.value.kind;\n-                    if op.node == BinOpKind::Eq;\n-                    if match_type(cx,\n-                               cx.typeck_results().expr_ty(&filter_args[0]).peel_refs(),\n-                               &paths::SLICE_ITER);\n-                    then {\n-                        let needle = match get_path_name(l) {\n-                            Some(name) if check_arg(name, argname, r) => r,\n-                            _ => match get_path_name(r) {\n-                                Some(name) if check_arg(name, argname, l) => l,\n-                                _ => { return; }\n-                            }\n-                        };\n-                        if ty::Uint(UintTy::U8) != *cx.typeck_results().expr_ty(needle).peel_refs().kind() {\n-                            return;\n-                        }\n-                        let haystack = if let ExprKind::MethodCall(ref path, _, ref args, _) =\n-                                filter_args[0].kind {\n-                            let p = path.ident.name;\n-                            if (p == sym::iter || p == sym!(iter_mut)) && args.len() == 1 {\n-                                &args[0]\n-                            } else {\n-                                &filter_args[0]\n-                            }\n-                        } else {\n-                            &filter_args[0]\n-                        };\n-                        let mut applicability = Applicability::MaybeIncorrect;\n-                        span_lint_and_sugg(\n-                            cx,\n-                            NAIVE_BYTECOUNT,\n-                            expr.span,\n-                            \"you appear to be counting bytes the naive way\",\n-                            \"consider using the bytecount crate\",\n-                            format!(\"bytecount::count({}, {})\",\n-                                    snippet_with_applicability(cx, haystack.span, \"..\", &mut applicability),\n-                                    snippet_with_applicability(cx, needle.span, \"..\", &mut applicability)),\n-                            applicability,\n-                        );\n+                let needle = match get_path_name(l) {\n+                    Some(name) if check_arg(name, argname, r) => r,\n+                    _ => match get_path_name(r) {\n+                        Some(name) if check_arg(name, argname, l) => l,\n+                        _ => { return; }\n                     }\n                 };\n+                if ty::Uint(UintTy::U8) != *cx.typeck_results().expr_ty(needle).peel_refs().kind() {\n+                    return;\n+                }\n+                let haystack = if let ExprKind::MethodCall(ref path, _, ref args, _) =\n+                        filter_args[0].kind {\n+                    let p = path.ident.name;\n+                    if (p == sym::iter || p == sym!(iter_mut)) && args.len() == 1 {\n+                        &args[0]\n+                    } else {\n+                        &filter_args[0]\n+                    }\n+                } else {\n+                    &filter_args[0]\n+                };\n+                let mut applicability = Applicability::MaybeIncorrect;\n+                span_lint_and_sugg(\n+                    cx,\n+                    NAIVE_BYTECOUNT,\n+                    expr.span,\n+                    \"you appear to be counting bytes the naive way\",\n+                    \"consider using the bytecount crate\",\n+                    format!(\"bytecount::count({}, {})\",\n+                            snippet_with_applicability(cx, haystack.span, \"..\", &mut applicability),\n+                            snippet_with_applicability(cx, needle.span, \"..\", &mut applicability)),\n+                    applicability,\n+                );\n             }\n         };\n     }"}, {"sha": "b38c70bcc4132d6d3da8e644c9ba46c77ad88501", "filename": "clippy_lints/src/checked_conversions.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588/clippy_lints%2Fsrc%2Fchecked_conversions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588/clippy_lints%2Fsrc%2Fchecked_conversions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fchecked_conversions.rs?ref=8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588", "patch": "@@ -321,9 +321,8 @@ fn get_implementing_type<'a>(path: &QPath<'_>, candidates: &'a [&str], function:\n         if path.ident.name.as_str() == function;\n         if let TyKind::Path(QPath::Resolved(None, ref tp)) = &ty.kind;\n         if let [int] = &*tp.segments;\n-        let name = &int.ident.name.as_str();\n-\n         then {\n+            let name = &int.ident.name.as_str();\n             candidates.iter().find(|c| name == *c).cloned()\n         } else {\n             None\n@@ -336,9 +335,8 @@ fn int_ty_to_sym<'tcx>(path: &QPath<'_>) -> Option<&'tcx str> {\n     if_chain! {\n         if let QPath::Resolved(_, ref path) = *path;\n         if let [ty] = &*path.segments;\n-        let name = &ty.ident.name.as_str();\n-\n         then {\n+            let name = &ty.ident.name.as_str();\n             INTS.iter().find(|c| name == *c).cloned()\n         } else {\n             None"}, {"sha": "04fff237bb4cbe4fa576aa2c0332284bdabeada2", "filename": "clippy_lints/src/collapsible_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588/clippy_lints%2Fsrc%2Fcollapsible_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588/clippy_lints%2Fsrc%2Fcollapsible_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcollapsible_match.rs?ref=8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588", "patch": "@@ -62,8 +62,8 @@ impl<'tcx> LateLintPass<'tcx> for CollapsibleMatch {\n }\n \n fn check_arm<'tcx>(arm: &Arm<'tcx>, wild_outer_arm: &Arm<'tcx>, cx: &LateContext<'tcx>) {\n+    let expr = strip_singleton_blocks(arm.body);\n     if_chain! {\n-        let expr = strip_singleton_blocks(arm.body);\n         if let ExprKind::Match(expr_in, arms_inner, _) = expr.kind;\n         // the outer arm pattern and the inner match\n         if expr_in.span.ctxt() == arm.pat.span.ctxt();"}, {"sha": "8a2146d93e86fa8fca7e250d6834925d67954343", "filename": "clippy_lints/src/default.rs", "status": "modified", "additions": 21, "deletions": 22, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588/clippy_lints%2Fsrc%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588/clippy_lints%2Fsrc%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdefault.rs?ref=8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588", "patch": "@@ -84,22 +84,21 @@ impl LateLintPass<'_> for Default {\n             if match_def_path(cx, def_id, &paths::DEFAULT_TRAIT_METHOD);\n             // Detect and ignore <Foo as Default>::default() because these calls do explicitly name the type.\n             if let QPath::Resolved(None, _path) = qpath;\n+            let expr_ty = cx.typeck_results().expr_ty(expr);\n+            if let ty::Adt(def, ..) = expr_ty.kind();\n             then {\n-                let expr_ty = cx.typeck_results().expr_ty(expr);\n-                if let ty::Adt(def, ..) = expr_ty.kind() {\n-                    // TODO: Work out a way to put \"whatever the imported way of referencing\n-                    // this type in this file\" rather than a fully-qualified type.\n-                    let replacement = format!(\"{}::default()\", cx.tcx.def_path_str(def.did));\n-                    span_lint_and_sugg(\n-                        cx,\n-                        DEFAULT_TRAIT_ACCESS,\n-                        expr.span,\n-                        &format!(\"calling `{}` is more clear than this expression\", replacement),\n-                        \"try\",\n-                        replacement,\n-                        Applicability::Unspecified, // First resolve the TODO above\n-                    );\n-                }\n+                // TODO: Work out a way to put \"whatever the imported way of referencing\n+                // this type in this file\" rather than a fully-qualified type.\n+                let replacement = format!(\"{}::default()\", cx.tcx.def_path_str(def.did));\n+                span_lint_and_sugg(\n+                    cx,\n+                    DEFAULT_TRAIT_ACCESS,\n+                    expr.span,\n+                    &format!(\"calling `{}` is more clear than this expression\", replacement),\n+                    \"try\",\n+                    replacement,\n+                    Applicability::Unspecified, // First resolve the TODO above\n+                );\n             }\n         }\n     }\n@@ -202,14 +201,14 @@ impl LateLintPass<'_> for Default {\n                 let binding_type = if_chain! {\n                     if let ty::Adt(adt_def, substs) = binding_type.kind();\n                     if !substs.is_empty();\n-                    let adt_def_ty_name = cx.tcx.item_name(adt_def.did);\n-                    let generic_args = substs.iter().collect::<Vec<_>>();\n-                    let tys_str = generic_args\n-                        .iter()\n-                        .map(ToString::to_string)\n-                        .collect::<Vec<_>>()\n-                        .join(\", \");\n                     then {\n+                        let adt_def_ty_name = cx.tcx.item_name(adt_def.did);\n+                        let generic_args = substs.iter().collect::<Vec<_>>();\n+                        let tys_str = generic_args\n+                            .iter()\n+                            .map(ToString::to_string)\n+                            .collect::<Vec<_>>()\n+                            .join(\", \");\n                         format!(\"{}::<{}>\", adt_def_ty_name, &tys_str)\n                     } else {\n                         binding_type.to_string()"}, {"sha": "42bafc3442e57dd339ed779feaa4450375a2ae68", "filename": "clippy_lints/src/default_numeric_fallback.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588/clippy_lints%2Fsrc%2Fdefault_numeric_fallback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588/clippy_lints%2Fsrc%2Fdefault_numeric_fallback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdefault_numeric_fallback.rs?ref=8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588", "patch": "@@ -130,8 +130,8 @@ impl<'a, 'tcx> Visitor<'tcx> for NumericFallbackVisitor<'a, 'tcx> {\n             },\n \n             ExprKind::Struct(_, fields, base) => {\n+                let ty = self.cx.typeck_results().expr_ty(expr);\n                 if_chain! {\n-                    let ty = self.cx.typeck_results().expr_ty(expr);\n                     if let Some(adt_def) = ty.ty_adt_def();\n                     if adt_def.is_struct();\n                     if let Some(variant) = adt_def.variants.iter().next();"}, {"sha": "84fac9986623493a79f6420d181e4bac31b3e71d", "filename": "clippy_lints/src/exit.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588/clippy_lints%2Fsrc%2Fexit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588/clippy_lints%2Fsrc%2Fexit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fexit.rs?ref=8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588", "patch": "@@ -32,16 +32,14 @@ impl<'tcx> LateLintPass<'tcx> for Exit {\n             if let ExprKind::Path(ref path) = path_expr.kind;\n             if let Some(def_id) = cx.qpath_res(path, path_expr.hir_id).opt_def_id();\n             if match_def_path(cx, def_id, &paths::EXIT);\n+            let parent = cx.tcx.hir().get_parent_item(e.hir_id);\n+            if let Some(Node::Item(Item{kind: ItemKind::Fn(..), ..})) = cx.tcx.hir().find(parent);\n+            // If the next item up is a function we check if it is an entry point\n+            // and only then emit a linter warning\n+            let def_id = cx.tcx.hir().local_def_id(parent);\n+            if !is_entrypoint_fn(cx, def_id.to_def_id());\n             then {\n-                let parent = cx.tcx.hir().get_parent_item(e.hir_id);\n-                if let Some(Node::Item(Item{kind: ItemKind::Fn(..), ..})) = cx.tcx.hir().find(parent) {\n-                    // If the next item up is a function we check if it is an entry point\n-                    // and only then emit a linter warning\n-                    let def_id = cx.tcx.hir().local_def_id(parent);\n-                    if !is_entrypoint_fn(cx, def_id.to_def_id()) {\n-                        span_lint(cx, EXIT, e.span, \"usage of `process::exit`\");\n-                    }\n-                }\n+                span_lint(cx, EXIT, e.span, \"usage of `process::exit`\");\n             }\n         }\n     }"}, {"sha": "7968e7b764df356c8d5cb1c1cbb6f18ac2b813f5", "filename": "clippy_lints/src/float_literal.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588/clippy_lints%2Fsrc%2Ffloat_literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588/clippy_lints%2Fsrc%2Ffloat_literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffloat_literal.rs?ref=8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588", "patch": "@@ -61,8 +61,8 @@ declare_lint_pass!(FloatLiteral => [EXCESSIVE_PRECISION, LOSSY_FLOAT_LITERAL]);\n \n impl<'tcx> LateLintPass<'tcx> for FloatLiteral {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n+        let ty = cx.typeck_results().expr_ty(expr);\n         if_chain! {\n-            let ty = cx.typeck_results().expr_ty(expr);\n             if let ty::Float(fty) = *ty.kind();\n             if let hir::ExprKind::Lit(ref lit) = expr.kind;\n             if let LitKind::Float(sym, lit_float_ty) = lit.node;"}, {"sha": "48612befc68d905a5e10a42ad314b6f047dd3bf8", "filename": "clippy_lints/src/formatting.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588/clippy_lints%2Fsrc%2Fformatting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588/clippy_lints%2Fsrc%2Fformatting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fformatting.rs?ref=8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588", "patch": "@@ -217,9 +217,8 @@ fn check_else(cx: &EarlyContext<'_>, expr: &Expr) {\n         if let Some(else_snippet) = snippet_opt(cx, else_span);\n         if let Some(else_pos) = else_snippet.find(\"else\");\n         if else_snippet[else_pos..].contains('\\n');\n-        let else_desc = if is_if(else_) { \"if\" } else { \"{..}\" };\n-\n         then {\n+            let else_desc = if is_if(else_) { \"if\" } else { \"{..}\" };\n             span_lint_and_note(\n                 cx,\n                 SUSPICIOUS_ELSE_FORMATTING,"}, {"sha": "56dfcc6a5064bf31f8cb1ba05e937f5f8ce540d5", "filename": "clippy_lints/src/if_let_mutex.rs", "status": "modified", "additions": 8, "deletions": 14, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588/clippy_lints%2Fsrc%2Fif_let_mutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588/clippy_lints%2Fsrc%2Fif_let_mutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fif_let_mutex.rs?ref=8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588", "patch": "@@ -94,13 +94,10 @@ impl<'tcx> Visitor<'tcx> for OppVisitor<'_, 'tcx> {\n     type Map = Map<'tcx>;\n \n     fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n-        if_chain! {\n-            if let Some(mutex) = is_mutex_lock_call(self.cx, expr);\n-            then {\n-                self.found_mutex = Some(mutex);\n-                self.mutex_lock_called = true;\n-                return;\n-            }\n+        if let Some(mutex) = is_mutex_lock_call(self.cx, expr) {\n+            self.found_mutex = Some(mutex);\n+            self.mutex_lock_called = true;\n+            return;\n         }\n         visit::walk_expr(self, expr);\n     }\n@@ -121,13 +118,10 @@ impl<'tcx> Visitor<'tcx> for ArmVisitor<'_, 'tcx> {\n     type Map = Map<'tcx>;\n \n     fn visit_expr(&mut self, expr: &'tcx Expr<'tcx>) {\n-        if_chain! {\n-            if let Some(mutex) = is_mutex_lock_call(self.cx, expr);\n-            then {\n-                self.found_mutex = Some(mutex);\n-                self.mutex_lock_called = true;\n-                return;\n-            }\n+        if let Some(mutex) = is_mutex_lock_call(self.cx, expr) {\n+            self.found_mutex = Some(mutex);\n+            self.mutex_lock_called = true;\n+            return;\n         }\n         visit::walk_expr(self, expr);\n     }"}, {"sha": "f5941977dd12428959eb08cf5b66c139bee41c07", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588", "patch": "@@ -550,6 +550,8 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         #[cfg(feature = \"internal-lints\")]\n         &utils::internal_lints::DEFAULT_LINT,\n         #[cfg(feature = \"internal-lints\")]\n+        &utils::internal_lints::IF_CHAIN_STYLE,\n+        #[cfg(feature = \"internal-lints\")]\n         &utils::internal_lints::INTERNING_DEFINED_SYMBOL,\n         #[cfg(feature = \"internal-lints\")]\n         &utils::internal_lints::INVALID_PATHS,\n@@ -1026,6 +1028,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         store.register_late_pass(|| box utils::inspector::DeepCodeInspector);\n         store.register_late_pass(|| box utils::internal_lints::CollapsibleCalls);\n         store.register_late_pass(|| box utils::internal_lints::CompilerLintFunctions::new());\n+        store.register_late_pass(|| box utils::internal_lints::IfChainStyle);\n         store.register_late_pass(|| box utils::internal_lints::InvalidPaths);\n         store.register_late_pass(|| box utils::internal_lints::InterningDefinedSymbol::default());\n         store.register_late_pass(|| box utils::internal_lints::LintWithoutLintPass::default());\n@@ -1442,6 +1445,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&utils::internal_lints::COLLAPSIBLE_SPAN_LINT_CALLS),\n         LintId::of(&utils::internal_lints::COMPILER_LINT_FUNCTIONS),\n         LintId::of(&utils::internal_lints::DEFAULT_LINT),\n+        LintId::of(&utils::internal_lints::IF_CHAIN_STYLE),\n         LintId::of(&utils::internal_lints::INTERNING_DEFINED_SYMBOL),\n         LintId::of(&utils::internal_lints::INVALID_PATHS),\n         LintId::of(&utils::internal_lints::LINT_WITHOUT_LINT_PASS),"}, {"sha": "574ad8c0f29dd905bab9f6590c956ee140487e63", "filename": "clippy_lints/src/loops/manual_flatten.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588/clippy_lints%2Fsrc%2Floops%2Fmanual_flatten.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588/clippy_lints%2Fsrc%2Floops%2Fmanual_flatten.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fmanual_flatten.rs?ref=8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588", "patch": "@@ -46,9 +46,8 @@ pub(super) fn check<'tcx>(\n             let some_ctor = is_some_ctor(cx, path.res);\n             let ok_ctor = is_ok_ctor(cx, path.res);\n             if some_ctor || ok_ctor;\n-            let if_let_type = if some_ctor { \"Some\" } else { \"Ok\" };\n-\n             then {\n+                let if_let_type = if some_ctor { \"Some\" } else { \"Ok\" };\n                 // Prepare the error message\n                 let msg = format!(\"unnecessary `if let` since only the `{}` variant of the iterator element is used\", if_let_type);\n "}, {"sha": "3c5abb7a3c429467afe16d9c7d95306d22c76c5e", "filename": "clippy_lints/src/loops/manual_memcpy.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588/clippy_lints%2Fsrc%2Floops%2Fmanual_memcpy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588/clippy_lints%2Fsrc%2Floops%2Fmanual_memcpy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fmanual_memcpy.rs?ref=8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588", "patch": "@@ -61,8 +61,8 @@ pub(super) fn check<'tcx>(\n                         if_chain! {\n                             if let ExprKind::Index(base_left, idx_left) = lhs.kind;\n                             if let ExprKind::Index(base_right, idx_right) = rhs.kind;\n-                            if is_slice_like(cx, cx.typeck_results().expr_ty(base_left))\n-                                && is_slice_like(cx, cx.typeck_results().expr_ty(base_right));\n+                            if is_slice_like(cx, cx.typeck_results().expr_ty(base_left));\n+                            if is_slice_like(cx, cx.typeck_results().expr_ty(base_right));\n                             if let Some((start_left, offset_left)) = get_details_from_idx(cx, &idx_left, &starts);\n                             if let Some((start_right, offset_right)) = get_details_from_idx(cx, &idx_right, &starts);\n "}, {"sha": "d23d3c508fa9451b093259c8748ade15df4b7a5f", "filename": "clippy_lints/src/loops/needless_collect.rs", "status": "modified", "additions": 52, "deletions": 53, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588/clippy_lints%2Fsrc%2Floops%2Fneedless_collect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588/clippy_lints%2Fsrc%2Floops%2Fneedless_collect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fneedless_collect.rs?ref=8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588", "patch": "@@ -26,60 +26,59 @@ fn check_needless_collect_direct_usage<'tcx>(expr: &'tcx Expr<'_>, cx: &LateCont\n         if chain_method.ident.name == sym!(collect) && is_trait_method(cx, &args[0], sym::Iterator);\n         if let Some(ref generic_args) = chain_method.args;\n         if let Some(GenericArg::Type(ref ty)) = generic_args.args.get(0);\n+        let ty = cx.typeck_results().node_type(ty.hir_id);\n+        if is_type_diagnostic_item(cx, ty, sym::vec_type)\n+            || is_type_diagnostic_item(cx, ty, sym::vecdeque_type)\n+            || match_type(cx, ty, &paths::BTREEMAP)\n+            || is_type_diagnostic_item(cx, ty, sym::hashmap_type);\n         then {\n-            let ty = cx.typeck_results().node_type(ty.hir_id);\n-            if is_type_diagnostic_item(cx, ty, sym::vec_type) ||\n-                is_type_diagnostic_item(cx, ty, sym::vecdeque_type) ||\n-                match_type(cx, ty, &paths::BTREEMAP) ||\n-                is_type_diagnostic_item(cx, ty, sym::hashmap_type) {\n-                if method.ident.name == sym!(len) {\n-                    let span = shorten_needless_collect_span(expr);\n-                    span_lint_and_sugg(\n-                        cx,\n-                        NEEDLESS_COLLECT,\n-                        span,\n-                        NEEDLESS_COLLECT_MSG,\n-                        \"replace with\",\n-                        \"count()\".to_string(),\n-                        Applicability::MachineApplicable,\n-                    );\n-                }\n-                if method.ident.name == sym!(is_empty) {\n-                    let span = shorten_needless_collect_span(expr);\n-                    span_lint_and_sugg(\n-                        cx,\n-                        NEEDLESS_COLLECT,\n-                        span,\n-                        NEEDLESS_COLLECT_MSG,\n-                        \"replace with\",\n-                        \"next().is_none()\".to_string(),\n-                        Applicability::MachineApplicable,\n-                    );\n-                }\n-                if method.ident.name == sym!(contains) {\n-                    let contains_arg = snippet(cx, args[1].span, \"??\");\n-                    let span = shorten_needless_collect_span(expr);\n-                    span_lint_and_then(\n-                        cx,\n-                        NEEDLESS_COLLECT,\n-                        span,\n-                        NEEDLESS_COLLECT_MSG,\n-                        |diag| {\n-                            let (arg, pred) = contains_arg\n-                                    .strip_prefix('&')\n-                                    .map_or((\"&x\", &*contains_arg), |s| (\"x\", s));\n-                            diag.span_suggestion(\n-                                span,\n-                                \"replace with\",\n-                                format!(\n-                                    \"any(|{}| x == {})\",\n-                                    arg, pred\n-                                ),\n-                                Applicability::MachineApplicable,\n-                            );\n-                        }\n-                    );\n-                }\n+            if method.ident.name == sym!(len) {\n+                let span = shorten_needless_collect_span(expr);\n+                span_lint_and_sugg(\n+                    cx,\n+                    NEEDLESS_COLLECT,\n+                    span,\n+                    NEEDLESS_COLLECT_MSG,\n+                    \"replace with\",\n+                    \"count()\".to_string(),\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n+            if method.ident.name == sym!(is_empty) {\n+                let span = shorten_needless_collect_span(expr);\n+                span_lint_and_sugg(\n+                    cx,\n+                    NEEDLESS_COLLECT,\n+                    span,\n+                    NEEDLESS_COLLECT_MSG,\n+                    \"replace with\",\n+                    \"next().is_none()\".to_string(),\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n+            if method.ident.name == sym!(contains) {\n+                let contains_arg = snippet(cx, args[1].span, \"??\");\n+                let span = shorten_needless_collect_span(expr);\n+                span_lint_and_then(\n+                    cx,\n+                    NEEDLESS_COLLECT,\n+                    span,\n+                    NEEDLESS_COLLECT_MSG,\n+                    |diag| {\n+                        let (arg, pred) = contains_arg\n+                                .strip_prefix('&')\n+                                .map_or((\"&x\", &*contains_arg), |s| (\"x\", s));\n+                        diag.span_suggestion(\n+                            span,\n+                            \"replace with\",\n+                            format!(\n+                                \"any(|{}| x == {})\",\n+                                arg, pred\n+                            ),\n+                            Applicability::MachineApplicable,\n+                        );\n+                    }\n+                );\n             }\n         }\n     }"}, {"sha": "60afa449a4556c2e689921d63dd972175706623a", "filename": "clippy_lints/src/loops/needless_range_loop.rs", "status": "modified", "additions": 36, "deletions": 38, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588/clippy_lints%2Fsrc%2Floops%2Fneedless_range_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588/clippy_lints%2Fsrc%2Floops%2Fneedless_range_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fneedless_range_loop.rs?ref=8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588", "patch": "@@ -256,49 +256,47 @@ impl<'a, 'tcx> VarVisitor<'a, 'tcx> {\n             if let ExprKind::Path(ref seqpath) = seqexpr.kind;\n             if let QPath::Resolved(None, ref seqvar) = *seqpath;\n             if seqvar.segments.len() == 1;\n+            let index_used_directly = path_to_local_id(idx, self.var);\n+            let indexed_indirectly = {\n+                let mut used_visitor = LocalUsedVisitor::new(self.cx, self.var);\n+                walk_expr(&mut used_visitor, idx);\n+                used_visitor.used\n+            };\n+            if indexed_indirectly || index_used_directly;\n             then {\n-                let index_used_directly = path_to_local_id(idx, self.var);\n-                let indexed_indirectly = {\n-                    let mut used_visitor = LocalUsedVisitor::new(self.cx, self.var);\n-                    walk_expr(&mut used_visitor, idx);\n-                    used_visitor.used\n-                };\n-\n-                if indexed_indirectly || index_used_directly {\n-                    if self.prefer_mutable {\n-                        self.indexed_mut.insert(seqvar.segments[0].ident.name);\n+                if self.prefer_mutable {\n+                    self.indexed_mut.insert(seqvar.segments[0].ident.name);\n+                }\n+                let res = self.cx.qpath_res(seqpath, seqexpr.hir_id);\n+                match res {\n+                    Res::Local(hir_id) => {\n+                        let parent_id = self.cx.tcx.hir().get_parent_item(expr.hir_id);\n+                        let parent_def_id = self.cx.tcx.hir().local_def_id(parent_id);\n+                        let extent = self.cx.tcx.region_scope_tree(parent_def_id).var_scope(hir_id.local_id);\n+                        if indexed_indirectly {\n+                            self.indexed_indirectly.insert(seqvar.segments[0].ident.name, Some(extent));\n+                        }\n+                        if index_used_directly {\n+                            self.indexed_directly.insert(\n+                                seqvar.segments[0].ident.name,\n+                                (Some(extent), self.cx.typeck_results().node_type(seqexpr.hir_id)),\n+                            );\n+                        }\n+                        return false;  // no need to walk further *on the variable*\n                     }\n-                    let res = self.cx.qpath_res(seqpath, seqexpr.hir_id);\n-                    match res {\n-                        Res::Local(hir_id) => {\n-                            let parent_id = self.cx.tcx.hir().get_parent_item(expr.hir_id);\n-                            let parent_def_id = self.cx.tcx.hir().local_def_id(parent_id);\n-                            let extent = self.cx.tcx.region_scope_tree(parent_def_id).var_scope(hir_id.local_id);\n-                            if indexed_indirectly {\n-                                self.indexed_indirectly.insert(seqvar.segments[0].ident.name, Some(extent));\n-                            }\n-                            if index_used_directly {\n-                                self.indexed_directly.insert(\n-                                    seqvar.segments[0].ident.name,\n-                                    (Some(extent), self.cx.typeck_results().node_type(seqexpr.hir_id)),\n-                                );\n-                            }\n-                            return false;  // no need to walk further *on the variable*\n+                    Res::Def(DefKind::Static | DefKind::Const, ..) => {\n+                        if indexed_indirectly {\n+                            self.indexed_indirectly.insert(seqvar.segments[0].ident.name, None);\n                         }\n-                        Res::Def(DefKind::Static | DefKind::Const, ..) => {\n-                            if indexed_indirectly {\n-                                self.indexed_indirectly.insert(seqvar.segments[0].ident.name, None);\n-                            }\n-                            if index_used_directly {\n-                                self.indexed_directly.insert(\n-                                    seqvar.segments[0].ident.name,\n-                                    (None, self.cx.typeck_results().node_type(seqexpr.hir_id)),\n-                                );\n-                            }\n-                            return false;  // no need to walk further *on the variable*\n+                        if index_used_directly {\n+                            self.indexed_directly.insert(\n+                                seqvar.segments[0].ident.name,\n+                                (None, self.cx.typeck_results().node_type(seqexpr.hir_id)),\n+                            );\n                         }\n-                        _ => (),\n+                        return false;  // no need to walk further *on the variable*\n                     }\n+                    _ => (),\n                 }\n             }\n         }"}, {"sha": "62c131968e7a06283b66c699fadea6d042934bc0", "filename": "clippy_lints/src/loops/same_item_push.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588/clippy_lints%2Fsrc%2Floops%2Fsame_item_push.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588/clippy_lints%2Fsrc%2Floops%2Fsame_item_push.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fsame_item_push.rs?ref=8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588", "patch": "@@ -63,8 +63,8 @@ pub(super) fn check<'tcx>(\n                         match cx.qpath_res(qpath, pushed_item.hir_id) {\n                             // immutable bindings that are initialized with literal or constant\n                             Res::Local(hir_id) => {\n+                                let node = cx.tcx.hir().get(hir_id);\n                                 if_chain! {\n-                                    let node = cx.tcx.hir().get(hir_id);\n                                     if let Node::Binding(pat) = node;\n                                     if let PatKind::Binding(bind_ann, ..) = pat.kind;\n                                     if !matches!(bind_ann, BindingAnnotation::RefMut | BindingAnnotation::Mutable);"}, {"sha": "7d697b2bf00ee0cbfe94b8f5d03a3df29cb5e2c8", "filename": "clippy_lints/src/loops/while_immutable_condition.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588/clippy_lints%2Fsrc%2Floops%2Fwhile_immutable_condition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588/clippy_lints%2Fsrc%2Floops%2Fwhile_immutable_condition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fwhile_immutable_condition.rs?ref=8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588", "patch": "@@ -103,9 +103,8 @@ impl<'a, 'tcx> VarCollectorVisitor<'a, 'tcx> {\n         if_chain! {\n             if let ExprKind::Path(ref qpath) = ex.kind;\n             if let QPath::Resolved(None, _) = *qpath;\n-            let res = self.cx.qpath_res(qpath, ex.hir_id);\n             then {\n-                match res {\n+                match self.cx.qpath_res(qpath, ex.hir_id) {\n                     Res::Local(hir_id) => {\n                         self.ids.insert(hir_id);\n                     },"}, {"sha": "5a3f0f27bc6a8ced5559b656b91fa0c2a6600431", "filename": "clippy_lints/src/manual_non_exhaustive.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588/clippy_lints%2Fsrc%2Fmanual_non_exhaustive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588/clippy_lints%2Fsrc%2Fmanual_non_exhaustive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmanual_non_exhaustive.rs?ref=8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588", "patch": "@@ -113,8 +113,8 @@ fn check_manual_non_exhaustive_enum(cx: &EarlyContext<'_>, item: &Item, variants\n             }\n     }\n \n+    let mut markers = variants.iter().filter(|v| is_non_exhaustive_marker(v));\n     if_chain! {\n-        let mut markers = variants.iter().filter(|v| is_non_exhaustive_marker(v));\n         if let Some(marker) = markers.next();\n         if markers.count() == 0 && variants.len() > 1;\n         then {"}, {"sha": "9f1ab1f695d80184cf6599d5fee2b684cc9ce829", "filename": "clippy_lints/src/map_clone.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588/clippy_lints%2Fsrc%2Fmap_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588/clippy_lints%2Fsrc%2Fmap_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmap_clone.rs?ref=8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588", "patch": "@@ -58,9 +58,9 @@ impl<'tcx> LateLintPass<'tcx> for MapClone {\n             let ty = cx.typeck_results().expr_ty(&args[0]);\n             if is_type_diagnostic_item(cx, ty, sym::option_type) || is_trait_method(cx, e, sym::Iterator);\n             if let hir::ExprKind::Closure(_, _, body_id, _, _) = args[1].kind;\n-            let closure_body = cx.tcx.hir().body(body_id);\n-            let closure_expr = remove_blocks(&closure_body.value);\n             then {\n+                let closure_body = cx.tcx.hir().body(body_id);\n+                let closure_expr = remove_blocks(&closure_body.value);\n                 match closure_body.params[0].pat.kind {\n                     hir::PatKind::Ref(ref inner, hir::Mutability::Not) => if let hir::PatKind::Binding(\n                         hir::BindingAnnotation::Unannotated, .., name, None"}, {"sha": "5cc16244a0dad7355eb4cb68ea13e52c6ed348e4", "filename": "clippy_lints/src/map_unit_fn.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588/clippy_lints%2Fsrc%2Fmap_unit_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588/clippy_lints%2Fsrc%2Fmap_unit_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmap_unit_fn.rs?ref=8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588", "patch": "@@ -168,17 +168,15 @@ fn unit_closure<'tcx>(\n     cx: &LateContext<'tcx>,\n     expr: &hir::Expr<'_>,\n ) -> Option<(&'tcx hir::Param<'tcx>, &'tcx hir::Expr<'tcx>)> {\n-    if let hir::ExprKind::Closure(_, ref decl, inner_expr_id, _, _) = expr.kind {\n+    if_chain! {\n+        if let hir::ExprKind::Closure(_, ref decl, inner_expr_id, _, _) = expr.kind;\n         let body = cx.tcx.hir().body(inner_expr_id);\n         let body_expr = &body.value;\n-\n-        if_chain! {\n-            if decl.inputs.len() == 1;\n-            if is_unit_expression(cx, body_expr);\n-            if let Some(binding) = iter_input_pats(&decl, body).next();\n-            then {\n-                return Some((binding, body_expr));\n-            }\n+        if decl.inputs.len() == 1;\n+        if is_unit_expression(cx, body_expr);\n+        if let Some(binding) = iter_input_pats(&decl, body).next();\n+        then {\n+            return Some((binding, body_expr));\n         }\n     }\n     None"}, {"sha": "4a3be67dd752953d14bb9c67bd27a98172e09f03", "filename": "clippy_lints/src/matches.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588/clippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588/clippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches.rs?ref=8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588", "patch": "@@ -732,8 +732,8 @@ fn report_single_match_single_pattern(\n         format!(\" else {}\", expr_block(cx, els, None, \"..\", Some(expr.span)))\n     });\n \n+    let (pat, pat_ref_count) = peel_hir_pat_refs(arms[0].pat);\n     let (msg, sugg) = if_chain! {\n-        let (pat, pat_ref_count) = peel_hir_pat_refs(arms[0].pat);\n         if let PatKind::Path(_) | PatKind::Lit(_) = pat.kind;\n         let (ty, ty_ref_count) = peel_mid_ty_refs(cx.typeck_results().expr_ty(ex));\n         if let Some(trait_id) = cx.tcx.lang_items().structural_peq_trait();\n@@ -1480,8 +1480,8 @@ fn check_match_single_binding<'a>(cx: &LateContext<'a>, ex: &Expr<'a>, arms: &[A\n \n /// Returns true if the `ex` match expression is in a local (`let`) statement\n fn opt_parent_let<'a>(cx: &LateContext<'a>, ex: &Expr<'a>) -> Option<&'a Local<'a>> {\n+    let map = &cx.tcx.hir();\n     if_chain! {\n-        let map = &cx.tcx.hir();\n         if let Some(Node::Expr(parent_arm_expr)) = map.find(map.get_parent_node(ex.hir_id));\n         if let Some(Node::Local(parent_let_expr)) = map.find(map.get_parent_node(parent_arm_expr.hir_id));\n         then {"}, {"sha": "0418c616efa8ad39344c7e1832e9705c80d40cfb", "filename": "clippy_lints/src/mem_replace.rs", "status": "modified", "additions": 24, "deletions": 25, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588/clippy_lints%2Fsrc%2Fmem_replace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588/clippy_lints%2Fsrc%2Fmem_replace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmem_replace.rs?ref=8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588", "patch": "@@ -225,34 +225,33 @@ fn is_default_equivalent_ctor(cx: &LateContext<'_>, def_id: DefId, path: &QPath<\n }\n \n fn check_replace_with_default(cx: &LateContext<'_>, src: &Expr<'_>, dest: &Expr<'_>, expr_span: Span) {\n-    if let ExprKind::Call(ref repl_func, _) = src.kind {\n-        if_chain! {\n-            if !in_external_macro(cx.tcx.sess, expr_span);\n-            if let ExprKind::Path(ref repl_func_qpath) = repl_func.kind;\n-            if let Some(repl_def_id) = cx.qpath_res(repl_func_qpath, repl_func.hir_id).opt_def_id();\n-            if is_diagnostic_assoc_item(cx, repl_def_id, sym::Default)\n-                || is_default_equivalent_ctor(cx, repl_def_id, repl_func_qpath);\n+    if_chain! {\n+        if let ExprKind::Call(ref repl_func, _) = src.kind;\n+        if !in_external_macro(cx.tcx.sess, expr_span);\n+        if let ExprKind::Path(ref repl_func_qpath) = repl_func.kind;\n+        if let Some(repl_def_id) = cx.qpath_res(repl_func_qpath, repl_func.hir_id).opt_def_id();\n+        if is_diagnostic_assoc_item(cx, repl_def_id, sym::Default)\n+            || is_default_equivalent_ctor(cx, repl_def_id, repl_func_qpath);\n \n-            then {\n-                span_lint_and_then(\n-                    cx,\n-                    MEM_REPLACE_WITH_DEFAULT,\n-                    expr_span,\n-                    \"replacing a value of type `T` with `T::default()` is better expressed using `std::mem::take`\",\n-                    |diag| {\n-                        if !in_macro(expr_span) {\n-                            let suggestion = format!(\"std::mem::take({})\", snippet(cx, dest.span, \"\"));\n+        then {\n+            span_lint_and_then(\n+                cx,\n+                MEM_REPLACE_WITH_DEFAULT,\n+                expr_span,\n+                \"replacing a value of type `T` with `T::default()` is better expressed using `std::mem::take`\",\n+                |diag| {\n+                    if !in_macro(expr_span) {\n+                        let suggestion = format!(\"std::mem::take({})\", snippet(cx, dest.span, \"\"));\n \n-                            diag.span_suggestion(\n-                                expr_span,\n-                                \"consider using\",\n-                                suggestion,\n-                                Applicability::MachineApplicable\n-                            );\n-                        }\n+                        diag.span_suggestion(\n+                            expr_span,\n+                            \"consider using\",\n+                            suggestion,\n+                            Applicability::MachineApplicable\n+                        );\n                     }\n-                );\n-            }\n+                }\n+            );\n         }\n     }\n }"}, {"sha": "2ad3e673c574fea36ec111d6897e5b6b27c7cd7e", "filename": "clippy_lints/src/methods/bytes_nth.rs", "status": "modified", "additions": 22, "deletions": 28, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588/clippy_lints%2Fsrc%2Fmethods%2Fbytes_nth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588/clippy_lints%2Fsrc%2Fmethods%2Fbytes_nth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fbytes_nth.rs?ref=8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588", "patch": "@@ -1,7 +1,6 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::snippet_with_applicability;\n use clippy_utils::ty::is_type_diagnostic_item;\n-use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::Expr;\n use rustc_lint::LateContext;\n@@ -10,31 +9,26 @@ use rustc_span::sym;\n use super::BYTES_NTH;\n \n pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'_>, recv: &'tcx Expr<'tcx>, n_arg: &'tcx Expr<'tcx>) {\n-    if_chain! {\n-        let ty = cx.typeck_results().expr_ty(recv).peel_refs();\n-        let caller_type = if is_type_diagnostic_item(cx, ty, sym::string_type) {\n-            Some(\"String\")\n-        } else if ty.is_str() {\n-            Some(\"str\")\n-        } else {\n-            None\n-        };\n-        if let Some(caller_type) = caller_type;\n-        then {\n-            let mut applicability = Applicability::MachineApplicable;\n-            span_lint_and_sugg(\n-                cx,\n-                BYTES_NTH,\n-                expr.span,\n-                &format!(\"called `.byte().nth()` on a `{}`\", caller_type),\n-                \"try\",\n-                format!(\n-                    \"{}.as_bytes().get({})\",\n-                    snippet_with_applicability(cx, recv.span, \"..\", &mut applicability),\n-                    snippet_with_applicability(cx, n_arg.span, \"..\", &mut applicability)\n-                ),\n-                applicability,\n-            );\n-        }\n-    }\n+    let ty = cx.typeck_results().expr_ty(recv).peel_refs();\n+    let caller_type = if ty.is_str() {\n+        \"str\"\n+    } else if is_type_diagnostic_item(cx, ty, sym::string_type) {\n+        \"String\"\n+    } else {\n+        return;\n+    };\n+    let mut applicability = Applicability::MachineApplicable;\n+    span_lint_and_sugg(\n+        cx,\n+        BYTES_NTH,\n+        expr.span,\n+        &format!(\"called `.byte().nth()` on a `{}`\", caller_type),\n+        \"try\",\n+        format!(\n+            \"{}.as_bytes().get({})\",\n+            snippet_with_applicability(cx, recv.span, \"..\", &mut applicability),\n+            snippet_with_applicability(cx, n_arg.span, \"..\", &mut applicability)\n+        ),\n+        applicability,\n+    );\n }"}, {"sha": "707c54f7a3cad180a37af7f2c0175fef03b4eecb", "filename": "clippy_lints/src/methods/from_iter_instead_of_collect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588/clippy_lints%2Fsrc%2Fmethods%2Ffrom_iter_instead_of_collect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588/clippy_lints%2Fsrc%2Fmethods%2Ffrom_iter_instead_of_collect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Ffrom_iter_instead_of_collect.rs?ref=8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588", "patch": "@@ -40,8 +40,8 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, args: &[hir::Exp\n }\n \n fn extract_turbofish(cx: &LateContext<'_>, expr: &hir::Expr<'_>, ty: Ty<'tcx>) -> String {\n+    let call_site = expr.span.source_callsite();\n     if_chain! {\n-        let call_site = expr.span.source_callsite();\n         if let Ok(snippet) = cx.sess().source_map().span_to_snippet(call_site);\n         let snippet_split = snippet.split(\"::\").collect::<Vec<_>>();\n         if let Some((_, elements)) = snippet_split.split_last();"}, {"sha": "70acf9f6e734007649a405516b8645ede25ced81", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588", "patch": "@@ -1882,11 +1882,10 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n         if_chain! {\n             if let TraitItemKind::Fn(ref sig, _) = item.kind;\n             if let Some(first_arg_ty) = sig.decl.inputs.iter().next();\n-            let first_arg_span = first_arg_ty.span;\n-            let first_arg_ty = hir_ty_to_ty(cx.tcx, first_arg_ty);\n-            let self_ty = TraitRef::identity(cx.tcx, item.def_id.to_def_id()).self_ty();\n-\n             then {\n+                let first_arg_span = first_arg_ty.span;\n+                let first_arg_ty = hir_ty_to_ty(cx.tcx, first_arg_ty);\n+                let self_ty = TraitRef::identity(cx.tcx, item.def_id.to_def_id()).self_ty();\n                 wrong_self_convention::check(\n                     cx,\n                     &item.ident.name.as_str(),"}, {"sha": "8e637e123933b03892e289733315af2b607df423", "filename": "clippy_lints/src/methods/unnecessary_filter_map.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_filter_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_filter_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_filter_map.rs?ref=8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588", "patch": "@@ -1,7 +1,6 @@\n use clippy_utils::diagnostics::span_lint;\n use clippy_utils::usage::mutated_variables;\n use clippy_utils::{is_trait_method, match_qpath, path_to_local_id, paths};\n-use if_chain::if_chain;\n use rustc_hir as hir;\n use rustc_hir::intravisit::{walk_expr, NestedVisitorMap, Visitor};\n use rustc_lint::LateContext;\n@@ -54,18 +53,15 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, arg: &hir::Expr<\n fn check_expression<'tcx>(cx: &LateContext<'tcx>, arg_id: hir::HirId, expr: &'tcx hir::Expr<'_>) -> (bool, bool) {\n     match &expr.kind {\n         hir::ExprKind::Call(ref func, ref args) => {\n-            if_chain! {\n-                if let hir::ExprKind::Path(ref path) = func.kind;\n-                then {\n-                    if match_qpath(path, &paths::OPTION_SOME) {\n-                        if path_to_local_id(&args[0], arg_id) {\n-                            return (false, false)\n-                        }\n-                        return (true, false);\n+            if let hir::ExprKind::Path(ref path) = func.kind {\n+                if match_qpath(path, &paths::OPTION_SOME) {\n+                    if path_to_local_id(&args[0], arg_id) {\n+                        return (false, false);\n                     }\n-                    // We don't know. It might do anything.\n-                    return (true, true);\n+                    return (true, false);\n                 }\n+                // We don't know. It might do anything.\n+                return (true, true);\n             }\n             (true, true)\n         },"}, {"sha": "c23643cb2f5b8ab3d704ffa4823d51b2c0fe3a03", "filename": "clippy_lints/src/misc.rs", "status": "modified", "additions": 49, "deletions": 53, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588/clippy_lints%2Fsrc%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588/clippy_lints%2Fsrc%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc.rs?ref=8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588", "patch": "@@ -308,46 +308,45 @@ impl<'tcx> LateLintPass<'tcx> for MiscLints {\n             if let PatKind::Binding(an, .., name, None) = local.pat.kind;\n             if let Some(ref init) = local.init;\n             if !higher::is_from_for_desugar(local);\n+            if an == BindingAnnotation::Ref || an == BindingAnnotation::RefMut;\n             then {\n-                if an == BindingAnnotation::Ref || an == BindingAnnotation::RefMut {\n-                    // use the macro callsite when the init span (but not the whole local span)\n-                    // comes from an expansion like `vec![1, 2, 3]` in `let ref _ = vec![1, 2, 3];`\n-                    let sugg_init = if init.span.from_expansion() && !local.span.from_expansion() {\n-                        Sugg::hir_with_macro_callsite(cx, init, \"..\")\n-                    } else {\n-                        Sugg::hir(cx, init, \"..\")\n-                    };\n-                    let (mutopt, initref) = if an == BindingAnnotation::RefMut {\n-                        (\"mut \", sugg_init.mut_addr())\n-                    } else {\n-                        (\"\", sugg_init.addr())\n-                    };\n-                    let tyopt = if let Some(ref ty) = local.ty {\n-                        format!(\": &{mutopt}{ty}\", mutopt=mutopt, ty=snippet(cx, ty.span, \"..\"))\n-                    } else {\n-                        String::new()\n-                    };\n-                    span_lint_hir_and_then(\n-                        cx,\n-                        TOPLEVEL_REF_ARG,\n-                        init.hir_id,\n-                        local.pat.span,\n-                        \"`ref` on an entire `let` pattern is discouraged, take a reference with `&` instead\",\n-                        |diag| {\n-                            diag.span_suggestion(\n-                                stmt.span,\n-                                \"try\",\n-                                format!(\n-                                    \"let {name}{tyopt} = {initref};\",\n-                                    name=snippet(cx, name.span, \"..\"),\n-                                    tyopt=tyopt,\n-                                    initref=initref,\n-                                ),\n-                                Applicability::MachineApplicable,\n-                            );\n-                        }\n-                    );\n-                }\n+                // use the macro callsite when the init span (but not the whole local span)\n+                // comes from an expansion like `vec![1, 2, 3]` in `let ref _ = vec![1, 2, 3];`\n+                let sugg_init = if init.span.from_expansion() && !local.span.from_expansion() {\n+                    Sugg::hir_with_macro_callsite(cx, init, \"..\")\n+                } else {\n+                    Sugg::hir(cx, init, \"..\")\n+                };\n+                let (mutopt, initref) = if an == BindingAnnotation::RefMut {\n+                    (\"mut \", sugg_init.mut_addr())\n+                } else {\n+                    (\"\", sugg_init.addr())\n+                };\n+                let tyopt = if let Some(ref ty) = local.ty {\n+                    format!(\": &{mutopt}{ty}\", mutopt=mutopt, ty=snippet(cx, ty.span, \"..\"))\n+                } else {\n+                    String::new()\n+                };\n+                span_lint_hir_and_then(\n+                    cx,\n+                    TOPLEVEL_REF_ARG,\n+                    init.hir_id,\n+                    local.pat.span,\n+                    \"`ref` on an entire `let` pattern is discouraged, take a reference with `&` instead\",\n+                    |diag| {\n+                        diag.span_suggestion(\n+                            stmt.span,\n+                            \"try\",\n+                            format!(\n+                                \"let {name}{tyopt} = {initref};\",\n+                                name=snippet(cx, name.span, \"..\"),\n+                                tyopt=tyopt,\n+                                initref=initref,\n+                            ),\n+                            Applicability::MachineApplicable,\n+                        );\n+                    }\n+                );\n             }\n         };\n         if_chain! {\n@@ -462,21 +461,18 @@ fn check_nan(cx: &LateContext<'_>, expr: &Expr<'_>, cmp_expr: &Expr<'_>) {\n     if_chain! {\n         if !in_constant(cx, cmp_expr.hir_id);\n         if let Some((value, _)) = constant(cx, cx.typeck_results(), expr);\n+        if match value {\n+            Constant::F32(num) => num.is_nan(),\n+            Constant::F64(num) => num.is_nan(),\n+            _ => false,\n+        };\n         then {\n-            let needs_lint = match value {\n-                Constant::F32(num) => num.is_nan(),\n-                Constant::F64(num) => num.is_nan(),\n-                _ => false,\n-            };\n-\n-            if needs_lint {\n-                span_lint(\n-                    cx,\n-                    CMP_NAN,\n-                    cmp_expr.span,\n-                    \"doomed comparison with `NAN`, use `{f32,f64}::is_nan()` instead\",\n-                );\n-            }\n+            span_lint(\n+                cx,\n+                CMP_NAN,\n+                cmp_expr.span,\n+                \"doomed comparison with `NAN`, use `{f32,f64}::is_nan()` instead\",\n+            );\n         }\n     }\n }"}, {"sha": "a5f91eb035f97a0a57688ba4df77b5f56fb989b9", "filename": "clippy_lints/src/new_without_default.rs", "status": "modified", "additions": 48, "deletions": 48, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588/clippy_lints%2Fsrc%2Fnew_without_default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588/clippy_lints%2Fsrc%2Fnew_without_default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnew_without_default.rs?ref=8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588", "patch": "@@ -97,60 +97,60 @@ impl<'tcx> LateLintPass<'tcx> for NewWithoutDefault {\n                             // impl of `Default`\n                             return;\n                         }\n-                        if sig.decl.inputs.is_empty() && name == sym::new && cx.access_levels.is_reachable(id) {\n+                        if_chain! {\n+                            if sig.decl.inputs.is_empty();\n+                            if name == sym::new;\n+                            if cx.access_levels.is_reachable(id);\n                             let self_def_id = cx.tcx.hir().local_def_id(cx.tcx.hir().get_parent_item(id));\n                             let self_ty = cx.tcx.type_of(self_def_id);\n-                            if_chain! {\n-                                if TyS::same_type(self_ty, return_ty(cx, id));\n-                                if let Some(default_trait_id) = get_trait_def_id(cx, &paths::DEFAULT_TRAIT);\n-                                then {\n-                                    if self.impling_types.is_none() {\n-                                        let mut impls = HirIdSet::default();\n-                                        cx.tcx.for_each_impl(default_trait_id, |d| {\n-                                            if let Some(ty_def) = cx.tcx.type_of(d).ty_adt_def() {\n-                                                if let Some(local_def_id) = ty_def.did.as_local() {\n-                                                    impls.insert(cx.tcx.hir().local_def_id_to_hir_id(local_def_id));\n-                                                }\n-                                            }\n-                                        });\n-                                        self.impling_types = Some(impls);\n-                                    }\n-\n-                                    // Check if a Default implementation exists for the Self type, regardless of\n-                                    // generics\n-                                    if_chain! {\n-                                        if let Some(ref impling_types) = self.impling_types;\n-                                        if let Some(self_def) = cx.tcx.type_of(self_def_id).ty_adt_def();\n-                                        if let Some(self_local_did) = self_def.did.as_local();\n-                                        then {\n-                                            let self_id = cx.tcx.hir().local_def_id_to_hir_id(self_local_did);\n-                                            if impling_types.contains(&self_id) {\n-                                                return;\n+                            if TyS::same_type(self_ty, return_ty(cx, id));\n+                            if let Some(default_trait_id) = get_trait_def_id(cx, &paths::DEFAULT_TRAIT);\n+                            then {\n+                                if self.impling_types.is_none() {\n+                                    let mut impls = HirIdSet::default();\n+                                    cx.tcx.for_each_impl(default_trait_id, |d| {\n+                                        if let Some(ty_def) = cx.tcx.type_of(d).ty_adt_def() {\n+                                            if let Some(local_def_id) = ty_def.did.as_local() {\n+                                                impls.insert(cx.tcx.hir().local_def_id_to_hir_id(local_def_id));\n                                             }\n                                         }\n-                                    }\n+                                    });\n+                                    self.impling_types = Some(impls);\n+                                }\n \n-                                    let generics_sugg = snippet(cx, generics.span, \"\");\n-                                    span_lint_hir_and_then(\n-                                        cx,\n-                                        NEW_WITHOUT_DEFAULT,\n-                                        id,\n-                                        impl_item.span,\n-                                        &format!(\n-                                            \"you should consider adding a `Default` implementation for `{}`\",\n-                                            self_ty\n-                                        ),\n-                                        |diag| {\n-                                            diag.suggest_prepend_item(\n-                                                cx,\n-                                                item.span,\n-                                                \"try this\",\n-                                                &create_new_without_default_suggest_msg(self_ty, &generics_sugg),\n-                                                Applicability::MaybeIncorrect,\n-                                            );\n-                                        },\n-                                    );\n+                                // Check if a Default implementation exists for the Self type, regardless of\n+                                // generics\n+                                if_chain! {\n+                                    if let Some(ref impling_types) = self.impling_types;\n+                                    if let Some(self_def) = cx.tcx.type_of(self_def_id).ty_adt_def();\n+                                    if let Some(self_local_did) = self_def.did.as_local();\n+                                    let self_id = cx.tcx.hir().local_def_id_to_hir_id(self_local_did);\n+                                    if impling_types.contains(&self_id);\n+                                    then {\n+                                        return;\n+                                    }\n                                 }\n+\n+                                let generics_sugg = snippet(cx, generics.span, \"\");\n+                                span_lint_hir_and_then(\n+                                    cx,\n+                                    NEW_WITHOUT_DEFAULT,\n+                                    id,\n+                                    impl_item.span,\n+                                    &format!(\n+                                        \"you should consider adding a `Default` implementation for `{}`\",\n+                                        self_ty\n+                                    ),\n+                                    |diag| {\n+                                        diag.suggest_prepend_item(\n+                                            cx,\n+                                            item.span,\n+                                            \"try this\",\n+                                            &create_new_without_default_suggest_msg(self_ty, &generics_sugg),\n+                                            Applicability::MaybeIncorrect,\n+                                        );\n+                                    },\n+                                );\n                             }\n                         }\n                     }"}, {"sha": "d775cd7c7f740b4392563a5bb09ea8ec32dd0ff6", "filename": "clippy_lints/src/non_copy_const.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588/clippy_lints%2Fsrc%2Fnon_copy_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588/clippy_lints%2Fsrc%2Fnon_copy_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnon_copy_const.rs?ref=8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588", "patch": "@@ -307,19 +307,17 @@ impl<'tcx> LateLintPass<'tcx> for NonCopyConst {\n                             // we should use here as a frozen variant is a potential to be frozen\n                             // similar to unknown layouts.\n                             // e.g. `layout_of(...).is_err() || has_frozen_variant(...);`\n+                        let ty = hir_ty_to_ty(cx.tcx, hir_ty);\n+                        let normalized = cx.tcx.normalize_erasing_regions(cx.param_env, ty);\n+                        if is_unfrozen(cx, normalized);\n+                        if is_value_unfrozen_poly(cx, *body_id, normalized);\n                         then {\n-                            let ty = hir_ty_to_ty(cx.tcx, hir_ty);\n-                            let normalized = cx.tcx.normalize_erasing_regions(cx.param_env, ty);\n-                            if is_unfrozen(cx, normalized)\n-                                && is_value_unfrozen_poly(cx, *body_id, normalized)\n-                            {\n-                                lint(\n-                                   cx,\n-                                   Source::Assoc {\n-                                       item: impl_item.span,\n-                                    },\n-                                );\n-                            }\n+                            lint(\n+                               cx,\n+                               Source::Assoc {\n+                                   item: impl_item.span,\n+                                },\n+                            );\n                         }\n                     }\n                 },"}, {"sha": "1e9468589472326ad23098a935f3de9ff052a747", "filename": "clippy_lints/src/panic_unimplemented.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588/clippy_lints%2Fsrc%2Fpanic_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588/clippy_lints%2Fsrc%2Fpanic_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fpanic_unimplemented.rs?ref=8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588", "patch": "@@ -97,11 +97,10 @@ impl<'tcx> LateLintPass<'tcx> for PanicUnimplemented {\n fn get_outer_span(expr: &Expr<'_>) -> Span {\n     if_chain! {\n         if expr.span.from_expansion();\n-        let first = expr.span.ctxt().outer_expn_data();\n-        if first.call_site.from_expansion();\n-        let second = first.call_site.ctxt().outer_expn_data();\n+        let first = expr.span.ctxt().outer_expn_data().call_site;\n+        if first.from_expansion();\n         then {\n-            second.call_site\n+            first.ctxt().outer_expn_data().call_site\n         } else {\n             expr.span\n         }"}, {"sha": "6e530d0ffb03c2eb20fe95b4cfc8e5d1377d26dd", "filename": "clippy_lints/src/ptr.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588/clippy_lints%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588/clippy_lints%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fptr.rs?ref=8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588", "patch": "@@ -271,19 +271,18 @@ fn check_fn(cx: &LateContext<'_>, decl: &FnDecl<'_>, fn_id: HirId, opt_body_id:\n                         GenericArg::Type(ty) => Some(ty),\n                         _ => None,\n                     });\n+                    let replacement = snippet_opt(cx, inner.span);\n+                    if let Some(r) = replacement;\n                     then {\n-                        let replacement = snippet_opt(cx, inner.span);\n-                        if let Some(r) = replacement {\n-                            span_lint_and_sugg(\n-                                cx,\n-                                PTR_ARG,\n-                                arg.span,\n-                                \"using a reference to `Cow` is not recommended\",\n-                                \"change this to\",\n-                                \"&\".to_owned() + &r,\n-                                Applicability::Unspecified,\n-                            );\n-                        }\n+                        span_lint_and_sugg(\n+                            cx,\n+                            PTR_ARG,\n+                            arg.span,\n+                            \"using a reference to `Cow` is not recommended\",\n+                            \"change this to\",\n+                            \"&\".to_owned() + &r,\n+                            Applicability::Unspecified,\n+                        );\n                     }\n                 }\n             }"}, {"sha": "79692abb6acf10d9bb12609c06693645bd036dc2", "filename": "clippy_lints/src/ranges.rs", "status": "modified", "additions": 23, "deletions": 26, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588/clippy_lints%2Fsrc%2Franges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588/clippy_lints%2Fsrc%2Franges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Franges.rs?ref=8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588", "patch": "@@ -320,32 +320,29 @@ fn match_ident(e: &Expr<'_>) -> Option<Ident> {\n }\n \n fn check_range_zip_with_len(cx: &LateContext<'_>, path: &PathSegment<'_>, args: &[Expr<'_>], span: Span) {\n-    let name = path.ident.as_str();\n-    if name == \"zip\" && args.len() == 2 {\n-        let iter = &args[0].kind;\n-        let zip_arg = &args[1];\n-        if_chain! {\n-            // `.iter()` call\n-            if let ExprKind::MethodCall(ref iter_path, _, ref iter_args, _) = *iter;\n-            if iter_path.ident.name == sym::iter;\n-            // range expression in `.zip()` call: `0..x.len()`\n-            if let Some(higher::Range { start: Some(start), end: Some(end), .. }) = higher::range(zip_arg);\n-            if is_integer_const(cx, start, 0);\n-            // `.len()` call\n-            if let ExprKind::MethodCall(ref len_path, _, ref len_args, _) = end.kind;\n-            if len_path.ident.name == sym!(len) && len_args.len() == 1;\n-            // `.iter()` and `.len()` called on same `Path`\n-            if let ExprKind::Path(QPath::Resolved(_, ref iter_path)) = iter_args[0].kind;\n-            if let ExprKind::Path(QPath::Resolved(_, ref len_path)) = len_args[0].kind;\n-            if SpanlessEq::new(cx).eq_path_segments(&iter_path.segments, &len_path.segments);\n-            then {\n-                span_lint(cx,\n-                    RANGE_ZIP_WITH_LEN,\n-                    span,\n-                    &format!(\"it is more idiomatic to use `{}.iter().enumerate()`\",\n-                        snippet(cx, iter_args[0].span, \"_\"))\n-                );\n-            }\n+    if_chain! {\n+        if path.ident.as_str() == \"zip\";\n+        if let [iter, zip_arg] = args;\n+        // `.iter()` call\n+        if let ExprKind::MethodCall(ref iter_path, _, ref iter_args, _) = iter.kind;\n+        if iter_path.ident.name == sym::iter;\n+        // range expression in `.zip()` call: `0..x.len()`\n+        if let Some(higher::Range { start: Some(start), end: Some(end), .. }) = higher::range(zip_arg);\n+        if is_integer_const(cx, start, 0);\n+        // `.len()` call\n+        if let ExprKind::MethodCall(ref len_path, _, ref len_args, _) = end.kind;\n+        if len_path.ident.name == sym!(len) && len_args.len() == 1;\n+        // `.iter()` and `.len()` called on same `Path`\n+        if let ExprKind::Path(QPath::Resolved(_, ref iter_path)) = iter_args[0].kind;\n+        if let ExprKind::Path(QPath::Resolved(_, ref len_path)) = len_args[0].kind;\n+        if SpanlessEq::new(cx).eq_path_segments(&iter_path.segments, &len_path.segments);\n+        then {\n+            span_lint(cx,\n+                RANGE_ZIP_WITH_LEN,\n+                span,\n+                &format!(\"it is more idiomatic to use `{}.iter().enumerate()`\",\n+                    snippet(cx, iter_args[0].span, \"_\"))\n+            );\n         }\n     }\n }"}, {"sha": "5429d3896101cfa1ba3f803630ab9e3a26fe63c0", "filename": "clippy_lints/src/redundant_closure_call.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588/clippy_lints%2Fsrc%2Fredundant_closure_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588/clippy_lints%2Fsrc%2Fredundant_closure_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fredundant_closure_call.rs?ref=8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588", "patch": "@@ -113,8 +113,8 @@ impl<'tcx> LateLintPass<'tcx> for RedundantClosureCall {\n                     if_chain! {\n                         if let hir::ExprKind::Call(ref closure, _) = expr.kind;\n                         if let hir::ExprKind::Path(hir::QPath::Resolved(_, ref path)) = closure.kind;\n-                        if self.path.segments[0].ident == path.segments[0].ident\n-                            && self.path.res == path.res;\n+                        if self.path.segments[0].ident == path.segments[0].ident;\n+                        if self.path.res == path.res;\n                         then {\n                             self.count += 1;\n                         }"}, {"sha": "512abde11a63433a827f797f95002b6489ac6a20", "filename": "clippy_lints/src/suspicious_trait_impl.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588/clippy_lints%2Fsrc%2Fsuspicious_trait_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588/clippy_lints%2Fsrc%2Fsuspicious_trait_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fsuspicious_trait_impl.rs?ref=8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588", "patch": "@@ -68,14 +68,13 @@ impl<'tcx> LateLintPass<'tcx> for SuspiciousImpl {\n \n             // Check for more than one binary operation in the implemented function\n             // Linting when multiple operations are involved can result in false positives\n+            let parent_fn = cx.tcx.hir().get_parent_item(expr.hir_id);\n             if_chain! {\n-                let parent_fn = cx.tcx.hir().get_parent_item(expr.hir_id);\n                 if let hir::Node::ImplItem(impl_item) = cx.tcx.hir().get(parent_fn);\n                 if let hir::ImplItemKind::Fn(_, body_id) = impl_item.kind;\n-                let body = cx.tcx.hir().body(body_id);\n-                let mut visitor = BinaryExprVisitor { nb_binops: 0 };\n-\n                 then {\n+                    let body = cx.tcx.hir().body(body_id);\n+                    let mut visitor = BinaryExprVisitor { nb_binops: 0 };\n                     walk_expr(&mut visitor, &body.value);\n                     if visitor.nb_binops > 1 {\n                         return;"}, {"sha": "1a6124e9ddb7ac57f896cfd47d3bf18161117acf", "filename": "clippy_lints/src/transmute/transmute_float_to_int.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_float_to_int.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_float_to_int.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute%2Ftransmute_float_to_int.rs?ref=8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588", "patch": "@@ -36,10 +36,10 @@ pub(super) fn check<'tcx>(\n                     if_chain! {\n                         // if the expression is a float literal and it is unsuffixed then\n                         // add a suffix so the suggestion is valid and unambiguous\n-                        let op = format!(\"{}{}\", arg, float_ty.name_str()).into();\n                         if let ExprKind::Lit(lit) = &expr.kind;\n                         if let ast::LitKind::Float(_, ast::LitFloatType::Unsuffixed) = lit.node;\n                         then {\n+                            let op = format!(\"{}{}\", arg, float_ty.name_str()).into();\n                             match arg {\n                                 sugg::Sugg::MaybeParen(_) => arg = sugg::Sugg::MaybeParen(op),\n                                 _ => arg = sugg::Sugg::NonParen(op)"}, {"sha": "e4799790d3512116a496e3920da9312fb2bbb1eb", "filename": "clippy_lints/src/try_err.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588/clippy_lints%2Fsrc%2Ftry_err.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588/clippy_lints%2Fsrc%2Ftry_err.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftry_err.rs?ref=8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588", "patch": "@@ -138,9 +138,8 @@ fn result_error_type<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> Option<Ty<'t\n     if_chain! {\n         if let ty::Adt(_, subst) = ty.kind();\n         if is_type_diagnostic_item(cx, ty, sym::result_type);\n-        let err_ty = subst.type_at(1);\n         then {\n-            Some(err_ty)\n+            Some(subst.type_at(1))\n         } else {\n             None\n         }\n@@ -156,10 +155,8 @@ fn poll_result_error_type<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> Option<\n \n         if let ty::Adt(ready_def, ready_subst) = ready_ty.kind();\n         if cx.tcx.is_diagnostic_item(sym::result_type, ready_def.did);\n-        let err_ty = ready_subst.type_at(1);\n-\n         then {\n-            Some(err_ty)\n+            Some(ready_subst.type_at(1))\n         } else {\n             None\n         }\n@@ -179,10 +176,8 @@ fn poll_option_result_error_type<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) ->\n \n         if let ty::Adt(some_def, some_subst) = some_ty.kind();\n         if cx.tcx.is_diagnostic_item(sym::result_type, some_def.did);\n-        let err_ty = some_subst.type_at(1);\n-\n         then {\n-            Some(err_ty)\n+            Some(some_subst.type_at(1))\n         } else {\n             None\n         }"}, {"sha": "cdc65abe47c3be7ea9e49e94d4c6416acef69e13", "filename": "clippy_lints/src/unit_return_expecting_ord.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588/clippy_lints%2Fsrc%2Funit_return_expecting_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588/clippy_lints%2Fsrc%2Funit_return_expecting_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funit_return_expecting_ord.rs?ref=8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588", "patch": "@@ -116,8 +116,8 @@ fn check_arg<'tcx>(cx: &LateContext<'tcx>, arg: &'tcx Expr<'tcx>) -> Option<(Spa\n         let ty = cx.tcx.erase_late_bound_regions(ret_ty);\n         if ty.is_unit();\n         then {\n+            let body = cx.tcx.hir().body(body_id);\n             if_chain! {\n-                let body = cx.tcx.hir().body(body_id);\n                 if let ExprKind::Block(block, _) = body.value.kind;\n                 if block.expr.is_none();\n                 if let Some(stmt) = block.stmts.last();"}, {"sha": "f77d811c2835dcb8d5c6fdf56778a5000f923b22", "filename": "clippy_lints/src/unit_types/unit_arg.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588/clippy_lints%2Fsrc%2Funit_types%2Funit_arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588/clippy_lints%2Fsrc%2Funit_types%2Funit_arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funit_types%2Funit_arg.rs?ref=8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588", "patch": "@@ -19,9 +19,9 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>) {\n     if is_questionmark_desugar_marked_call(expr) {\n         return;\n     }\n+    let map = &cx.tcx.hir();\n+    let opt_parent_node = map.find(map.get_parent_node(expr.hir_id));\n     if_chain! {\n-        let map = &cx.tcx.hir();\n-        let opt_parent_node = map.find(map.get_parent_node(expr.hir_id));\n         if let Some(hir::Node::Expr(parent_expr)) = opt_parent_node;\n         if is_questionmark_desugar_marked_call(parent_expr);\n         then {"}, {"sha": "9ceb2c3ffe257bc367bacf6b08c7405c0a337aff", "filename": "clippy_lints/src/unnamed_address.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588/clippy_lints%2Fsrc%2Funnamed_address.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588/clippy_lints%2Fsrc%2Funnamed_address.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funnamed_address.rs?ref=8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588", "patch": "@@ -116,8 +116,8 @@ impl LateLintPass<'_> for UnnamedAddress {\n         if_chain! {\n             if let ExprKind::Binary(binop, ref left, ref right) = expr.kind;\n             if is_comparison(binop.node);\n-            if cx.typeck_results().expr_ty_adjusted(left).is_fn_ptr() &&\n-                cx.typeck_results().expr_ty_adjusted(right).is_fn_ptr();\n+            if cx.typeck_results().expr_ty_adjusted(left).is_fn_ptr();\n+            if cx.typeck_results().expr_ty_adjusted(right).is_fn_ptr();\n             if is_fn_def(cx, left) || is_fn_def(cx, right);\n             then {\n                 span_lint("}, {"sha": "15343cf90f2311931c86f6981dd08558b8d59349", "filename": "clippy_lints/src/unused_self.rs", "status": "modified", "additions": 11, "deletions": 14, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588/clippy_lints%2Fsrc%2Funused_self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588/clippy_lints%2Fsrc%2Funused_self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funused_self.rs?ref=8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588", "patch": "@@ -49,21 +49,18 @@ impl<'tcx> LateLintPass<'tcx> for UnusedSelf {\n             if assoc_item.fn_has_self_parameter;\n             if let ImplItemKind::Fn(.., body_id) = &impl_item.kind;\n             let body = cx.tcx.hir().body(*body_id);\n-            if !body.params.is_empty();\n+            if let [self_param, ..] = body.params;\n+            let self_hir_id = self_param.pat.hir_id;\n+            if !LocalUsedVisitor::new(cx, self_hir_id).check_body(body);\n             then {\n-                let self_param = &body.params[0];\n-                let self_hir_id = self_param.pat.hir_id;\n-                if !LocalUsedVisitor::new(cx, self_hir_id).check_body(body) {\n-                    span_lint_and_help(\n-                        cx,\n-                        UNUSED_SELF,\n-                        self_param.span,\n-                        \"unused `self` argument\",\n-                        None,\n-                        \"consider refactoring to a associated function\",\n-                    );\n-                    return;\n-                }\n+                span_lint_and_help(\n+                    cx,\n+                    UNUSED_SELF,\n+                    self_param.span,\n+                    \"unused `self` argument\",\n+                    None,\n+                    \"consider refactoring to a associated function\",\n+                );\n             }\n         }\n     }"}, {"sha": "d17aa6d842411e2ba252c40ea9a58bf793e0fd62", "filename": "clippy_lints/src/unwrap_in_result.rs", "status": "modified", "additions": 20, "deletions": 24, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588/clippy_lints%2Fsrc%2Funwrap_in_result.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588/clippy_lints%2Fsrc%2Funwrap_in_result.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funwrap_in_result.rs?ref=8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588", "patch": "@@ -110,31 +110,27 @@ impl<'a, 'tcx> Visitor<'tcx> for FindExpectUnwrap<'a, 'tcx> {\n }\n \n fn lint_impl_body<'tcx>(cx: &LateContext<'tcx>, impl_span: Span, impl_item: &'tcx hir::ImplItem<'_>) {\n-    if_chain! {\n+    if let ImplItemKind::Fn(_, body_id) = impl_item.kind {\n+        let body = cx.tcx.hir().body(body_id);\n+        let mut fpu = FindExpectUnwrap {\n+            lcx: cx,\n+            typeck_results: cx.tcx.typeck(impl_item.def_id),\n+            result: Vec::new(),\n+        };\n+        fpu.visit_expr(&body.value);\n \n-        if let ImplItemKind::Fn(_, body_id) = impl_item.kind;\n-        then {\n-            let body = cx.tcx.hir().body(body_id);\n-            let mut fpu = FindExpectUnwrap {\n-                lcx: cx,\n-                typeck_results: cx.tcx.typeck(impl_item.def_id),\n-                result: Vec::new(),\n-            };\n-            fpu.visit_expr(&body.value);\n-\n-            // if we've found one, lint\n-            if  !fpu.result.is_empty()  {\n-                span_lint_and_then(\n-                    cx,\n-                    UNWRAP_IN_RESULT,\n-                    impl_span,\n-                    \"used unwrap or expect in a function that returns result or option\",\n-                    move |diag| {\n-                        diag.help(\n-                            \"unwrap and expect should not be used in a function that returns result or option\" );\n-                        diag.span_note(fpu.result, \"potential non-recoverable error(s)\");\n-                    });\n-            }\n+        // if we've found one, lint\n+        if !fpu.result.is_empty() {\n+            span_lint_and_then(\n+                cx,\n+                UNWRAP_IN_RESULT,\n+                impl_span,\n+                \"used unwrap or expect in a function that returns result or option\",\n+                move |diag| {\n+                    diag.help(\"unwrap and expect should not be used in a function that returns result or option\");\n+                    diag.span_note(fpu.result, \"potential non-recoverable error(s)\");\n+                },\n+            );\n         }\n     }\n }"}, {"sha": "d893b271a206097fefe0533f271022f52f6ff9f5", "filename": "clippy_lints/src/useless_conversion.rs", "status": "modified", "additions": 19, "deletions": 22, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588/clippy_lints%2Fsrc%2Fuseless_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588/clippy_lints%2Fsrc%2Fuseless_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fuseless_conversion.rs?ref=8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588", "patch": "@@ -103,25 +103,23 @@ impl<'tcx> LateLintPass<'tcx> for UselessConversion {\n                         );\n                     }\n                 }\n-                if match_trait_method(cx, e, &paths::TRY_INTO_TRAIT) && &*name.ident.as_str() == \"try_into\" {\n-                    if_chain! {\n-                        let a = cx.typeck_results().expr_ty(e);\n-                        let b = cx.typeck_results().expr_ty(&args[0]);\n-                        if is_type_diagnostic_item(cx, a, sym::result_type);\n-                        if let ty::Adt(_, substs) = a.kind();\n-                        if let Some(a_type) = substs.types().next();\n-                        if TyS::same_type(a_type, b);\n-\n-                        then {\n-                            span_lint_and_help(\n-                                cx,\n-                                USELESS_CONVERSION,\n-                                e.span,\n-                                &format!(\"useless conversion to the same type: `{}`\", b),\n-                                None,\n-                                \"consider removing `.try_into()`\",\n-                            );\n-                        }\n+                if_chain! {\n+                    if match_trait_method(cx, e, &paths::TRY_INTO_TRAIT) && &*name.ident.as_str() == \"try_into\";\n+                    let a = cx.typeck_results().expr_ty(e);\n+                    let b = cx.typeck_results().expr_ty(&args[0]);\n+                    if is_type_diagnostic_item(cx, a, sym::result_type);\n+                    if let ty::Adt(_, substs) = a.kind();\n+                    if let Some(a_type) = substs.types().next();\n+                    if TyS::same_type(a_type, b);\n+                    then {\n+                        span_lint_and_help(\n+                            cx,\n+                            USELESS_CONVERSION,\n+                            e.span,\n+                            &format!(\"useless conversion to the same type: `{}`\", b),\n+                            None,\n+                            \"consider removing `.try_into()`\",\n+                        );\n                     }\n                 }\n             },\n@@ -131,10 +129,9 @@ impl<'tcx> LateLintPass<'tcx> for UselessConversion {\n                     if args.len() == 1;\n                     if let ExprKind::Path(ref qpath) = path.kind;\n                     if let Some(def_id) = cx.qpath_res(qpath, path.hir_id).opt_def_id();\n-                    let a = cx.typeck_results().expr_ty(e);\n-                    let b = cx.typeck_results().expr_ty(&args[0]);\n-\n                     then {\n+                        let a = cx.typeck_results().expr_ty(e);\n+                        let b = cx.typeck_results().expr_ty(&args[0]);\n                         if_chain! {\n                             if match_def_path(cx, def_id, &paths::TRY_FROM);\n                             if is_type_diagnostic_item(cx, a, sym::result_type);"}, {"sha": "d5a13c135b1dba146947901a8f330dc2a169ba78", "filename": "clippy_lints/src/utils/internal_lints.rs", "status": "modified", "additions": 174, "deletions": 7, "changes": 181, "blob_url": "https://github.com/rust-lang/rust/blob/8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs?ref=8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588", "patch": "@@ -1,8 +1,10 @@\n use crate::consts::{constant_simple, Constant};\n-use clippy_utils::diagnostics::{span_lint, span_lint_and_help, span_lint_and_sugg};\n+use clippy_utils::diagnostics::{span_lint, span_lint_and_help, span_lint_and_sugg, span_lint_and_then};\n use clippy_utils::source::snippet;\n use clippy_utils::ty::match_type;\n-use clippy_utils::{is_expn_of, match_def_path, match_qpath, method_calls, path_to_res, paths, run_lints, SpanlessEq};\n+use clippy_utils::{\n+    is_else_clause, is_expn_of, match_def_path, match_qpath, method_calls, path_to_res, paths, run_lints, SpanlessEq,\n+};\n use if_chain::if_chain;\n use rustc_ast::ast::{Crate as AstCrate, ItemKind, LitKind, ModKind, NodeId};\n use rustc_ast::visit::FnKind;\n@@ -14,15 +16,17 @@ use rustc_hir::def_id::DefId;\n use rustc_hir::hir_id::CRATE_HIR_ID;\n use rustc_hir::intravisit::{NestedVisitorMap, Visitor};\n use rustc_hir::{\n-    BinOpKind, Crate, Expr, ExprKind, HirId, Item, MutTy, Mutability, Node, Path, StmtKind, Ty, TyKind, UnOp,\n+    BinOpKind, Block, Crate, Expr, ExprKind, HirId, Item, Local, MatchSource, MutTy, Mutability, Node, Path, Stmt,\n+    StmtKind, Ty, TyKind, UnOp,\n };\n-use rustc_lint::{EarlyContext, EarlyLintPass, LateContext, LateLintPass};\n+use rustc_lint::{EarlyContext, EarlyLintPass, LateContext, LateLintPass, LintContext};\n use rustc_middle::hir::map::Map;\n use rustc_middle::mir::interpret::ConstValue;\n use rustc_middle::ty;\n use rustc_session::{declare_lint_pass, declare_tool_lint, impl_lint_pass};\n-use rustc_span::source_map::{Span, Spanned};\n+use rustc_span::source_map::Spanned;\n use rustc_span::symbol::{Symbol, SymbolStr};\n+use rustc_span::{BytePos, Span};\n use rustc_typeck::hir_ty_to_ty;\n \n use std::borrow::{Borrow, Cow};\n@@ -297,6 +301,13 @@ declare_clippy_lint! {\n     \"unnecessary conversion between Symbol and string\"\n }\n \n+declare_clippy_lint! {\n+    /// Finds unidiomatic usage of `if_chain!`\n+    pub IF_CHAIN_STYLE,\n+    internal,\n+    \"non-idiomatic `if_chain!` usage\"\n+}\n+\n declare_lint_pass!(ClippyLintsInternal => [CLIPPY_LINTS_INTERNAL]);\n \n impl EarlyLintPass for ClippyLintsInternal {\n@@ -577,9 +588,9 @@ impl<'tcx> LateLintPass<'tcx> for CollapsibleCalls {\n             if stmts.len() == 1 && block.expr.is_none();\n             if let StmtKind::Semi(only_expr) = &stmts[0].kind;\n             if let ExprKind::MethodCall(ref ps, _, ref span_call_args, _) = &only_expr.kind;\n-            let and_then_snippets = get_and_then_snippets(cx, and_then_args);\n-            let mut sle = SpanlessEq::new(cx).deny_side_effects();\n             then {\n+                let and_then_snippets = get_and_then_snippets(cx, and_then_args);\n+                let mut sle = SpanlessEq::new(cx).deny_side_effects();\n                 match &*ps.ident.as_str() {\n                     \"span_suggestion\" if sle.eq_expr(&and_then_args[2], &span_call_args[1]) => {\n                         suggest_suggestion(cx, expr, &and_then_snippets, &span_suggestion_snippets(cx, span_call_args));\n@@ -1063,3 +1074,159 @@ impl<'tcx> SymbolStrExpr<'tcx> {\n         }\n     }\n }\n+\n+declare_lint_pass!(IfChainStyle => [IF_CHAIN_STYLE]);\n+\n+impl<'tcx> LateLintPass<'tcx> for IfChainStyle {\n+    fn check_block(&mut self, cx: &LateContext<'tcx>, block: &'tcx hir::Block<'_>) {\n+        let (local, after, if_chain_span) = if_chain! {\n+            if let [Stmt { kind: StmtKind::Local(local), .. }, after @ ..] = block.stmts;\n+            if let Some(if_chain_span) = is_expn_of(block.span, \"if_chain\");\n+            then { (local, after, if_chain_span) } else { return }\n+        };\n+        if is_first_if_chain_expr(cx, block.hir_id, if_chain_span) {\n+            span_lint(\n+                cx,\n+                IF_CHAIN_STYLE,\n+                if_chain_local_span(cx, local, if_chain_span),\n+                \"`let` expression should be above the `if_chain!`\",\n+            );\n+        } else if local.span.ctxt() == block.span.ctxt() && is_if_chain_then(after, block.expr, if_chain_span) {\n+            span_lint(\n+                cx,\n+                IF_CHAIN_STYLE,\n+                if_chain_local_span(cx, local, if_chain_span),\n+                \"`let` expression should be inside `then { .. }`\",\n+            )\n+        }\n+    }\n+\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n+        let (cond, then, els) = match expr.kind {\n+            ExprKind::If(cond, then, els) => (Some(cond), then, els.is_some()),\n+            ExprKind::Match(\n+                _,\n+                [arm, ..],\n+                MatchSource::IfLetDesugar {\n+                    contains_else_clause: els,\n+                },\n+            ) => (None, arm.body, els),\n+            _ => return,\n+        };\n+        let then_block = match then.kind {\n+            ExprKind::Block(block, _) => block,\n+            _ => return,\n+        };\n+        let if_chain_span = is_expn_of(expr.span, \"if_chain\");\n+        if !els {\n+            check_nested_if_chains(cx, expr, then_block, if_chain_span);\n+        }\n+        let if_chain_span = match if_chain_span {\n+            None => return,\n+            Some(span) => span,\n+        };\n+        // check for `if a && b;`\n+        if_chain! {\n+            if let Some(cond) = cond;\n+            if let ExprKind::Binary(op, _, _) = cond.kind;\n+            if op.node == BinOpKind::And;\n+            if cx.sess().source_map().is_multiline(cond.span);\n+            then {\n+                span_lint(cx, IF_CHAIN_STYLE, cond.span, \"`if a && b;` should be `if a; if b;`\");\n+            }\n+        }\n+        if is_first_if_chain_expr(cx, expr.hir_id, if_chain_span)\n+            && is_if_chain_then(then_block.stmts, then_block.expr, if_chain_span)\n+        {\n+            span_lint(cx, IF_CHAIN_STYLE, expr.span, \"`if_chain!` only has one `if`\")\n+        }\n+    }\n+}\n+\n+fn check_nested_if_chains(\n+    cx: &LateContext<'_>,\n+    if_expr: &Expr<'_>,\n+    then_block: &Block<'_>,\n+    if_chain_span: Option<Span>,\n+) {\n+    #[rustfmt::skip]\n+    let (head, tail) = match *then_block {\n+        Block { stmts, expr: Some(tail), .. } => (stmts, tail),\n+        Block {\n+            stmts: &[\n+                ref head @ ..,\n+                Stmt { kind: StmtKind::Expr(tail) | StmtKind::Semi(tail), .. }\n+            ],\n+            ..\n+        } => (head, tail),\n+        _ => return,\n+    };\n+    if_chain! {\n+        if matches!(tail.kind,\n+            ExprKind::If(_, _, None)\n+            | ExprKind::Match(.., MatchSource::IfLetDesugar { contains_else_clause: false }));\n+        let sm = cx.sess().source_map();\n+        if head\n+            .iter()\n+            .all(|stmt| matches!(stmt.kind, StmtKind::Local(..)) && !sm.is_multiline(stmt.span));\n+        if if_chain_span.is_some() || !is_else_clause(cx.tcx, if_expr);\n+        then {} else { return }\n+    }\n+    let (span, msg) = match (if_chain_span, is_expn_of(tail.span, \"if_chain\")) {\n+        (None, Some(_)) => (if_expr.span, \"this `if` can be part of the inner `if_chain!`\"),\n+        (Some(_), None) => (tail.span, \"this `if` can be part of the outer `if_chain!`\"),\n+        (Some(a), Some(b)) if a != b => (b, \"this `if_chain!` can be merged with the outer `if_chain!`\"),\n+        _ => return,\n+    };\n+    span_lint_and_then(cx, IF_CHAIN_STYLE, span, msg, |diag| {\n+        let (span, msg) = match head {\n+            [] => return,\n+            [stmt] => (stmt.span, \"this `let` statement can also be in the `if_chain!`\"),\n+            [a, .., b] => (\n+                a.span.to(b.span),\n+                \"these `let` statements can also be in the `if_chain!`\",\n+            ),\n+        };\n+        diag.span_help(span, msg);\n+    });\n+}\n+\n+fn is_first_if_chain_expr(cx: &LateContext<'_>, hir_id: HirId, if_chain_span: Span) -> bool {\n+    cx.tcx\n+        .hir()\n+        .parent_iter(hir_id)\n+        .find(|(_, node)| {\n+            #[rustfmt::skip]\n+            !matches!(node, Node::Expr(Expr { kind: ExprKind::Block(..), .. }) | Node::Stmt(_))\n+        })\n+        .map_or(false, |(id, _)| {\n+            is_expn_of(cx.tcx.hir().span(id), \"if_chain\") != Some(if_chain_span)\n+        })\n+}\n+\n+/// Checks a trailing slice of statements and expression of a `Block` to see if they are part\n+/// of the `then {..}` portion of an `if_chain!`\n+fn is_if_chain_then(stmts: &[Stmt<'_>], expr: Option<&Expr<'_>>, if_chain_span: Span) -> bool {\n+    let span = if let [stmt, ..] = stmts {\n+        stmt.span\n+    } else if let Some(expr) = expr {\n+        expr.span\n+    } else {\n+        // empty `then {}`\n+        return true;\n+    };\n+    is_expn_of(span, \"if_chain\").map_or(true, |span| span != if_chain_span)\n+}\n+\n+/// Creates a `Span` for `let x = ..;` in an `if_chain!` call.\n+fn if_chain_local_span(cx: &LateContext<'_>, local: &Local<'_>, if_chain_span: Span) -> Span {\n+    let mut span = local.pat.span;\n+    if let Some(init) = local.init {\n+        span = span.to(init.span);\n+    }\n+    span.adjust(if_chain_span.ctxt().outer_expn());\n+    let sm = cx.sess().source_map();\n+    let span = sm.span_extend_to_prev_str(span, \"let\", false);\n+    let span = sm.span_extend_to_next_char(span, ';', false);\n+    Span::new(span.lo() - BytePos(3), span.hi() + BytePos(1), span.ctxt())\n+}"}, {"sha": "c7190e2f9798c67f88a17695282cdf704d7b91a9", "filename": "clippy_lints/src/vec_init_then_push.rs", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588/clippy_lints%2Fsrc%2Fvec_init_then_push.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588/clippy_lints%2Fsrc%2Fvec_init_then_push.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fvec_init_then_push.rs?ref=8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588", "patch": "@@ -108,22 +108,21 @@ impl LateLintPass<'_> for VecInitThenPush {\n     }\n \n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if self.searcher.is_none() {\n-            if_chain! {\n-                if !in_external_macro(cx.sess(), expr.span);\n-                if let ExprKind::Assign(left, right, _) = expr.kind;\n-                if let Some(id) = path_to_local(left);\n-                if let Some(init_kind) = get_vec_init_kind(cx, right);\n-                then {\n-                    self.searcher = Some(VecPushSearcher {\n-                        local_id: id,\n-                        init: init_kind,\n-                        lhs_is_local: false,\n-                        lhs_span: left.span,\n-                        err_span: expr.span,\n-                        found: 0,\n-                    });\n-                }\n+        if_chain! {\n+            if self.searcher.is_none();\n+            if !in_external_macro(cx.sess(), expr.span);\n+            if let ExprKind::Assign(left, right, _) = expr.kind;\n+            if let Some(id) = path_to_local(left);\n+            if let Some(init_kind) = get_vec_init_kind(cx, right);\n+            then {\n+                self.searcher = Some(VecPushSearcher {\n+                    local_id: id,\n+                    init: init_kind,\n+                    lhs_is_local: false,\n+                    lhs_span: left.span,\n+                    err_span: expr.span,\n+                    found: 0,\n+                });\n             }\n         }\n     }"}, {"sha": "8e871707aa8f36953805aaf9780309ea45995f59", "filename": "tests/ui-internal/if_chain_style.rs", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588/tests%2Fui-internal%2Fif_chain_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588/tests%2Fui-internal%2Fif_chain_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-internal%2Fif_chain_style.rs?ref=8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588", "patch": "@@ -0,0 +1,92 @@\n+#![warn(clippy::if_chain_style)]\n+#![allow(clippy::no_effect)]\n+\n+extern crate if_chain;\n+\n+use if_chain::if_chain;\n+\n+fn main() {\n+    if true {\n+        let x = \"\";\n+        // `if_chain!` inside `if`\n+        if_chain! {\n+            if true;\n+            if true;\n+            then {}\n+        }\n+    }\n+    if_chain! {\n+        if true\n+            // multi-line AND'ed conditions\n+            && false;\n+        if let Some(1) = Some(1);\n+        // `let` before `then`\n+        let x = \"\";\n+        then {\n+            ();\n+        }\n+    }\n+    if_chain! {\n+        // single `if` condition\n+        if true;\n+        then {\n+            let x = \"\";\n+            // nested if\n+            if true {}\n+        }\n+    }\n+    if_chain! {\n+        // starts with `let ..`\n+        let x = \"\";\n+        if let Some(1) = Some(1);\n+        then {\n+            let x = \"\";\n+            let x = \"\";\n+            // nested if_chain!\n+            if_chain! {\n+                if true;\n+                if true;\n+                then {}\n+            }\n+        }\n+    }\n+}\n+\n+fn negative() {\n+    if true {\n+        ();\n+        if_chain! {\n+            if true;\n+            if true;\n+            then { (); }\n+        }\n+    }\n+    if_chain! {\n+        if true;\n+        let x = \"\";\n+        if true;\n+        then { (); }\n+    }\n+    if_chain! {\n+        if true;\n+        if true;\n+        then {\n+            if true { 1 } else { 2 }\n+        } else {\n+            3\n+        }\n+    };\n+    if true {\n+        if_chain! {\n+            if true;\n+            if true;\n+            then {}\n+        }\n+    } else if false {\n+        if_chain! {\n+            if true;\n+            if false;\n+            then {}\n+        }\n+    }\n+}"}, {"sha": "b53c3ea05da9f20d91195349d78029390279cc26", "filename": "tests/ui-internal/if_chain_style.stderr", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588/tests%2Fui-internal%2Fif_chain_style.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588/tests%2Fui-internal%2Fif_chain_style.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-internal%2Fif_chain_style.stderr?ref=8cf7d9b037bbdf5cd970b2f133ddd7d39acc1588", "patch": "@@ -0,0 +1,85 @@\n+error: this `if` can be part of the inner `if_chain!`\n+  --> $DIR/if_chain_style.rs:9:5\n+   |\n+LL | /     if true {\n+LL | |         let x = \"\";\n+LL | |         // `if_chain!` inside `if`\n+LL | |         if_chain! {\n+...  |\n+LL | |         }\n+LL | |     }\n+   | |_____^\n+   |\n+   = note: `-D clippy::if-chain-style` implied by `-D warnings`\n+help: this `let` statement can also be in the `if_chain!`\n+  --> $DIR/if_chain_style.rs:10:9\n+   |\n+LL |         let x = \"\";\n+   |         ^^^^^^^^^^^\n+\n+error: `if a && b;` should be `if a; if b;`\n+  --> $DIR/if_chain_style.rs:19:12\n+   |\n+LL |           if true\n+   |  ____________^\n+LL | |             // multi-line AND'ed conditions\n+LL | |             && false;\n+   | |____________________^\n+\n+error: `let` expression should be inside `then { .. }`\n+  --> $DIR/if_chain_style.rs:24:9\n+   |\n+LL |         let x = \"\";\n+   |         ^^^^^^^^^^^\n+\n+error: this `if` can be part of the outer `if_chain!`\n+  --> $DIR/if_chain_style.rs:35:13\n+   |\n+LL |             if true {}\n+   |             ^^^^^^^^^^\n+   |\n+help: this `let` statement can also be in the `if_chain!`\n+  --> $DIR/if_chain_style.rs:33:13\n+   |\n+LL |             let x = \"\";\n+   |             ^^^^^^^^^^^\n+\n+error: `if_chain!` only has one `if`\n+  --> $DIR/if_chain_style.rs:29:5\n+   |\n+LL | /     if_chain! {\n+LL | |         // single `if` condition\n+LL | |         if true;\n+LL | |         then {\n+...  |\n+LL | |         }\n+LL | |     }\n+   | |_____^\n+   |\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: `let` expression should be above the `if_chain!`\n+  --> $DIR/if_chain_style.rs:40:9\n+   |\n+LL |         let x = \"\";\n+   |         ^^^^^^^^^^^\n+\n+error: this `if_chain!` can be merged with the outer `if_chain!`\n+  --> $DIR/if_chain_style.rs:46:13\n+   |\n+LL | /             if_chain! {\n+LL | |                 if true;\n+LL | |                 if true;\n+LL | |                 then {}\n+LL | |             }\n+   | |_____________^\n+   |\n+help: these `let` statements can also be in the `if_chain!`\n+  --> $DIR/if_chain_style.rs:43:13\n+   |\n+LL | /             let x = \"\";\n+LL | |             let x = \"\";\n+   | |_______________________^\n+\n+error: aborting due to 7 previous errors\n+"}]}