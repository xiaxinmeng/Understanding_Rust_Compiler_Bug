{"sha": "24af0c94b30271198d6101cdd14c78182f76fd07", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI0YWYwYzk0YjMwMjcxMTk4ZDYxMDFjZGQxNGM3ODE4MmY3NmZkMDc=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-11-06T06:03:03Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-11-06T06:03:03Z"}, "message": "Rollup merge of #65973 - eddyb:caller-location-panic, r=petrochenkov\n\ncaller_location: point to macro invocation sites, like file!/line!, and use in core::panic!.\n\nThe main change here is to `core::panic!`, trying to fix this remaining regression: https://github.com/rust-lang/rust/pull/65927#issuecomment-547625147\n\nHowever, in order for `caller_location` to be usable from macros the same way `file!()`/`line!()` are, it needs to have the same behavior (of extracting the macro invocation site `Span` and using that).\n\nArguably we would've had to do this at some point anyway, if we want to use `#[track_caller]` to replace the `file!()`/`line!()` uses from macros, but I'm not sure the RFC mentions this at all.\n\nr? @petrochenkov cc @anp @nnethercote", "tree": {"sha": "3d3a3a48a2eb026852412562d7b038a01b65ae8b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3d3a3a48a2eb026852412562d7b038a01b65ae8b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/24af0c94b30271198d6101cdd14c78182f76fd07", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdwmIXCRBK7hj4Ov3rIwAAdHIIAC+5acCy0s1iIPstdn712Fe3\n1Ss9feIm0m6lfLw9p4MPV0caEzQZVCv++itVeM5lHyshdEHwuViDSB8uCEkAtpMU\n5grw3dBvifrJOunJY5k/bU5DjSeBvJXV1bnI74V37ous6T7upCksQaDOxZiiX2TC\n78i0YdhzGmZzjzkhBCsisXPz3Ykn3CE2I2kFWO8jvMSfOlMG9KPk726NCy1T3zKR\n7lwHoz9Fk/OlZEuCbMuml2SIx292J4M5RrPDSH0A2SSARBJk13hCXGrakAFvhUb5\nvjBd6xjS0Mo5MHILafm+ilLpwDtAODeiu+pL1LFOVlOn8NErFoqURIRGTY8EHdY=\n=0O6l\n-----END PGP SIGNATURE-----\n", "payload": "tree 3d3a3a48a2eb026852412562d7b038a01b65ae8b\nparent a0b4b4dafaef944df28f2d9d5e94d6ce190a0504\nparent 49f9626a553c0ff191aa96912f4880f99d0a8716\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1573020183 +0100\ncommitter GitHub <noreply@github.com> 1573020183 +0100\n\nRollup merge of #65973 - eddyb:caller-location-panic, r=petrochenkov\n\ncaller_location: point to macro invocation sites, like file!/line!, and use in core::panic!.\n\nThe main change here is to `core::panic!`, trying to fix this remaining regression: https://github.com/rust-lang/rust/pull/65927#issuecomment-547625147\n\nHowever, in order for `caller_location` to be usable from macros the same way `file!()`/`line!()` are, it needs to have the same behavior (of extracting the macro invocation site `Span` and using that).\n\nArguably we would've had to do this at some point anyway, if we want to use `#[track_caller]` to replace the `file!()`/`line!()` uses from macros, but I'm not sure the RFC mentions this at all.\n\nr? @petrochenkov cc @anp @nnethercote\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/24af0c94b30271198d6101cdd14c78182f76fd07", "html_url": "https://github.com/rust-lang/rust/commit/24af0c94b30271198d6101cdd14c78182f76fd07", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/24af0c94b30271198d6101cdd14c78182f76fd07/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a0b4b4dafaef944df28f2d9d5e94d6ce190a0504", "url": "https://api.github.com/repos/rust-lang/rust/commits/a0b4b4dafaef944df28f2d9d5e94d6ce190a0504", "html_url": "https://github.com/rust-lang/rust/commit/a0b4b4dafaef944df28f2d9d5e94d6ce190a0504"}, {"sha": "49f9626a553c0ff191aa96912f4880f99d0a8716", "url": "https://api.github.com/repos/rust-lang/rust/commits/49f9626a553c0ff191aa96912f4880f99d0a8716", "html_url": "https://github.com/rust-lang/rust/commit/49f9626a553c0ff191aa96912f4880f99d0a8716"}], "stats": {"total": 84, "additions": 51, "deletions": 33}, "files": [{"sha": "131fb52e2d22b535873cc49bdcc55ea38baf63be", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 15, "deletions": 17, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/24af0c94b30271198d6101cdd14c78182f76fd07/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24af0c94b30271198d6101cdd14c78182f76fd07/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=24af0c94b30271198d6101cdd14c78182f76fd07", "patch": "@@ -26,31 +26,29 @@ macro_rules! panic {\n /// For details, see `std::macros`.\n #[cfg(not(bootstrap))]\n #[macro_export]\n-#[allow_internal_unstable(core_panic, panic_internals)]\n+#[allow_internal_unstable(core_panic,\n+    // FIXME(anp, eddyb) `core_intrinsics` is used here to allow calling\n+    // the `caller_location` intrinsic, but once  `#[track_caller]` is implemented,\n+    // `panicking::{panic, panic_fmt}` can use that instead of a `Location` argument.\n+    core_intrinsics,\n+)]\n #[stable(feature = \"core\", since = \"1.6.0\")]\n macro_rules! panic {\n     () => (\n         $crate::panic!(\"explicit panic\")\n     );\n-    ($msg:expr) => ({\n-        const LOC: &$crate::panic::Location<'_> = &$crate::panic::Location::internal_constructor(\n-            $crate::file!(),\n-            $crate::line!(),\n-            $crate::column!(),\n-        );\n-        $crate::panicking::panic($msg, LOC)\n-    });\n+    ($msg:expr) => (\n+        $crate::panicking::panic($msg, $crate::intrinsics::caller_location())\n+    );\n     ($msg:expr,) => (\n         $crate::panic!($msg)\n     );\n-    ($fmt:expr, $($arg:tt)+) => ({\n-        const LOC: &$crate::panic::Location<'_> = &$crate::panic::Location::internal_constructor(\n-            $crate::file!(),\n-            $crate::line!(),\n-            $crate::column!(),\n-        );\n-        $crate::panicking::panic_fmt($crate::format_args!($fmt, $($arg)+), LOC)\n-    });\n+    ($fmt:expr, $($arg:tt)+) => (\n+        $crate::panicking::panic_fmt(\n+            $crate::format_args!($fmt, $($arg)+),\n+            $crate::intrinsics::caller_location(),\n+        )\n+    );\n }\n \n /// Asserts that two expressions are equal to each other (using [`PartialEq`])."}, {"sha": "13cd202158b771ab389469805ca45d694b35229b", "filename": "src/librustc_codegen_ssa/mir/block.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/24af0c94b30271198d6101cdd14c78182f76fd07/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24af0c94b30271198d6101cdd14c78182f76fd07/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs?ref=24af0c94b30271198d6101cdd14c78182f76fd07", "patch": "@@ -995,7 +995,8 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         bx: &mut Bx,\n         span: Span,\n     ) -> OperandRef<'tcx, Bx::Value> {\n-        let caller = bx.tcx().sess.source_map().lookup_char_pos(span.lo());\n+        let topmost = span.ctxt().outer_expn().expansion_cause().unwrap_or(span);\n+        let caller = bx.tcx().sess.source_map().lookup_char_pos(topmost.lo());\n         let const_loc = bx.tcx().const_caller_location((\n             Symbol::intern(&caller.file.name.to_string()),\n             caller.line as u32,"}, {"sha": "1b5cc2f0948ab5854490e2715ee3cb985e61ddd7", "filename": "src/librustc_mir/interpret/intrinsics.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/24af0c94b30271198d6101cdd14c78182f76fd07/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24af0c94b30271198d6101cdd14c78182f76fd07/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs?ref=24af0c94b30271198d6101cdd14c78182f76fd07", "patch": "@@ -98,7 +98,8 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         let intrinsic_name = &*self.tcx.item_name(instance.def_id()).as_str();\n         match intrinsic_name {\n             \"caller_location\" => {\n-                let caller = self.tcx.sess.source_map().lookup_char_pos(span.lo());\n+                let topmost = span.ctxt().outer_expn().expansion_cause().unwrap_or(span);\n+                let caller = self.tcx.sess.source_map().lookup_char_pos(topmost.lo());\n                 let location = self.alloc_caller_location(\n                     Symbol::intern(&caller.file.name.to_string()),\n                     caller.line as u32,"}, {"sha": "d02251eb746d0209c6dc613d31869cb2a9e5d025", "filename": "src/libsyntax_expand/base.rs", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/24af0c94b30271198d6101cdd14c78182f76fd07/src%2Flibsyntax_expand%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24af0c94b30271198d6101cdd14c78182f76fd07/src%2Flibsyntax_expand%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_expand%2Fbase.rs?ref=24af0c94b30271198d6101cdd14c78182f76fd07", "patch": "@@ -953,18 +953,7 @@ impl<'a> ExtCtxt<'a> {\n     ///\n     /// Stops backtracing at include! boundary.\n     pub fn expansion_cause(&self) -> Option<Span> {\n-        let mut expn_id = self.current_expansion.id;\n-        let mut last_macro = None;\n-        loop {\n-            let expn_data = expn_id.expn_data();\n-            // Stop going up the backtrace once include! is encountered\n-            if expn_data.is_root() || expn_data.kind.descr() == sym::include {\n-                break;\n-            }\n-            expn_id = expn_data.call_site.ctxt().outer_expn();\n-            last_macro = Some(expn_data.call_site);\n-        }\n-        last_macro\n+        self.current_expansion.id.expansion_cause()\n     }\n \n     pub fn struct_span_warn<S: Into<MultiSpan>>(&self,"}, {"sha": "2a48f8e44aa1259a2e7d6add29b70c9cc8589e16", "filename": "src/libsyntax_pos/hygiene.rs", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/24af0c94b30271198d6101cdd14c78182f76fd07/src%2Flibsyntax_pos%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24af0c94b30271198d6101cdd14c78182f76fd07/src%2Flibsyntax_pos%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fhygiene.rs?ref=24af0c94b30271198d6101cdd14c78182f76fd07", "patch": "@@ -28,7 +28,7 @@\n use crate::GLOBALS;\n use crate::{Span, DUMMY_SP};\n use crate::edition::Edition;\n-use crate::symbol::{kw, Symbol};\n+use crate::symbol::{kw, sym, Symbol};\n \n use rustc_serialize::{Encodable, Decodable, Encoder, Decoder};\n use rustc_data_structures::fx::FxHashMap;\n@@ -119,6 +119,23 @@ impl ExpnId {\n     pub fn outer_expn_is_descendant_of(self, ctxt: SyntaxContext) -> bool {\n         HygieneData::with(|data| data.is_descendant_of(self, data.outer_expn(ctxt)))\n     }\n+\n+    /// Returns span for the macro which originally caused this expansion to happen.\n+    ///\n+    /// Stops backtracing at include! boundary.\n+    pub fn expansion_cause(mut self) -> Option<Span> {\n+        let mut last_macro = None;\n+        loop {\n+            let expn_data = self.expn_data();\n+            // Stop going up the backtrace once include! is encountered\n+            if expn_data.is_root() || expn_data.kind.descr() == sym::include {\n+                break;\n+            }\n+            self = expn_data.call_site.ctxt().outer_expn();\n+            last_macro = Some(expn_data.call_site);\n+        }\n+        last_macro\n+    }\n }\n \n #[derive(Debug)]"}, {"sha": "1c4d4666fa1800c2a57bc06849facfe660a20dca", "filename": "src/test/ui/rfc-2091-track-caller/caller-location-intrinsic.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/24af0c94b30271198d6101cdd14c78182f76fd07/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Fcaller-location-intrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/24af0c94b30271198d6101cdd14c78182f76fd07/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Fcaller-location-intrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Fcaller-location-intrinsic.rs?ref=24af0c94b30271198d6101cdd14c78182f76fd07", "patch": "@@ -1,9 +1,21 @@\n // run-pass\n \n #![feature(core_intrinsics)]\n+\n+macro_rules! caller_location_from_macro {\n+    () => (core::intrinsics::caller_location());\n+}\n+\n fn main() {\n     let loc = core::intrinsics::caller_location();\n     assert_eq!(loc.file(), file!());\n-    assert_eq!(loc.line(), 5);\n+    assert_eq!(loc.line(), 10);\n     assert_eq!(loc.column(), 15);\n+\n+    // `caller_location()` in a macro should behave similarly to `file!` and `line!`,\n+    // i.e. point to where the macro was invoked, instead of the macro itself.\n+    let loc2 = caller_location_from_macro!();\n+    assert_eq!(loc2.file(), file!());\n+    assert_eq!(loc2.line(), 17);\n+    assert_eq!(loc2.column(), 16);\n }"}]}