{"sha": "ff12ab2d9913ff20db62379378ccddc6bffa9f4e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZmMTJhYjJkOTkxM2ZmMjBkYjYyMzc5Mzc4Y2NkZGM2YmZmYTlmNGU=", "commit": {"author": {"name": "The8472", "email": "git@infinite-source.de", "date": "2021-08-16T20:15:52Z"}, "committer": {"name": "The8472", "email": "git@infinite-source.de", "date": "2021-08-16T20:15:52Z"}, "message": "correct overflows in the backslide case, add test", "tree": {"sha": "9ca7a767837a027ba9f6c9d4f7265a8cad075535", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9ca7a767837a027ba9f6c9d4f7265a8cad075535"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ff12ab2d9913ff20db62379378ccddc6bffa9f4e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ff12ab2d9913ff20db62379378ccddc6bffa9f4e", "html_url": "https://github.com/rust-lang/rust/commit/ff12ab2d9913ff20db62379378ccddc6bffa9f4e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ff12ab2d9913ff20db62379378ccddc6bffa9f4e/comments", "author": {"login": "the8472", "id": 1065730, "node_id": "MDQ6VXNlcjEwNjU3MzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1065730?v=4", "gravatar_id": "", "url": "https://api.github.com/users/the8472", "html_url": "https://github.com/the8472", "followers_url": "https://api.github.com/users/the8472/followers", "following_url": "https://api.github.com/users/the8472/following{/other_user}", "gists_url": "https://api.github.com/users/the8472/gists{/gist_id}", "starred_url": "https://api.github.com/users/the8472/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/the8472/subscriptions", "organizations_url": "https://api.github.com/users/the8472/orgs", "repos_url": "https://api.github.com/users/the8472/repos", "events_url": "https://api.github.com/users/the8472/events{/privacy}", "received_events_url": "https://api.github.com/users/the8472/received_events", "type": "User", "site_admin": false}, "committer": {"login": "the8472", "id": 1065730, "node_id": "MDQ6VXNlcjEwNjU3MzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1065730?v=4", "gravatar_id": "", "url": "https://api.github.com/users/the8472", "html_url": "https://github.com/the8472", "followers_url": "https://api.github.com/users/the8472/followers", "following_url": "https://api.github.com/users/the8472/following{/other_user}", "gists_url": "https://api.github.com/users/the8472/gists{/gist_id}", "starred_url": "https://api.github.com/users/the8472/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/the8472/subscriptions", "organizations_url": "https://api.github.com/users/the8472/orgs", "repos_url": "https://api.github.com/users/the8472/repos", "events_url": "https://api.github.com/users/the8472/events{/privacy}", "received_events_url": "https://api.github.com/users/the8472/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7256a6a86d10e51f47af994cb3f6fc0d68deebd1", "url": "https://api.github.com/repos/rust-lang/rust/commits/7256a6a86d10e51f47af994cb3f6fc0d68deebd1", "html_url": "https://github.com/rust-lang/rust/commit/7256a6a86d10e51f47af994cb3f6fc0d68deebd1"}], "stats": {"total": 56, "additions": 48, "deletions": 8}, "files": [{"sha": "c347bc3d342ca27c253aeaa54250600355de9b9b", "filename": "library/std/src/time/monotonic.rs", "status": "modified", "additions": 30, "deletions": 8, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/ff12ab2d9913ff20db62379378ccddc6bffa9f4e/library%2Fstd%2Fsrc%2Ftime%2Fmonotonic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff12ab2d9913ff20db62379378ccddc6bffa9f4e/library%2Fstd%2Fsrc%2Ftime%2Fmonotonic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ftime%2Fmonotonic.rs?ref=ff12ab2d9913ff20db62379378ccddc6bffa9f4e", "patch": "@@ -12,14 +12,19 @@ pub mod inner {\n     use crate::sys::time;\n     use crate::time::Duration;\n \n-    const ZERO: time::Instant = time::Instant::zero();\n+    pub(in crate::time) const ZERO: time::Instant = time::Instant::zero();\n \n     // bits 30 and 31 are never used since the seconds part never exceeds 10^9\n-    const UNINITIALIZED: u64 = 0xff00_0000;\n+    const UNINITIALIZED: u64 = 0b11 << 30;\n     static MONO: AtomicU64 = AtomicU64::new(UNINITIALIZED);\n \n     #[inline]\n     pub(super) fn monotonize(raw: time::Instant) -> time::Instant {\n+        monotonize_impl(&MONO, raw)\n+    }\n+\n+    #[inline]\n+    pub(in crate::time) fn monotonize_impl(mono: &AtomicU64, raw: time::Instant) -> time::Instant {\n         let delta = raw.checked_sub_instant(&ZERO).unwrap();\n         let secs = delta.as_secs();\n         // occupies no more than 30 bits (10^9 seconds)\n@@ -32,16 +37,33 @@ pub mod inner {\n         // This could be a problem for programs that call instants at intervals greater\n         // than 68 years. Interstellar probes may want to ensure that actually_monotonic() is true.\n         let packed = (secs << 32) | nanos;\n-        let old = MONO.load(Relaxed);\n+        let old = mono.load(Relaxed);\n \n         if old == UNINITIALIZED || packed.wrapping_sub(old) < u64::MAX / 2 {\n-            MONO.store(packed, Relaxed);\n+            mono.store(packed, Relaxed);\n             raw\n         } else {\n-            // Backslide occurred. We reconstruct monotonized time by assuming the clock will never\n-            // backslide more than 2`32 seconds which means we can reuse the upper 32bits from\n-            // the seconds.\n-            let secs = (secs & 0xffff_ffff_0000_0000) | old >> 32;\n+            // Backslide occurred. We reconstruct monotonized time from the upper 32 bit of the\n+            // passed in value and the 64bits loaded from the atomic\n+            let seconds_lower = old >> 32;\n+            let mut seconds_upper = secs & 0xffff_ffff_0000_0000;\n+            if secs & 0xffff_ffff > seconds_lower {\n+                // Backslide caused the lower 32bit of the seconds part to wrap.\n+                // This must be the case because the seconds part is larger even though\n+                // we are in the backslide branch, i.e. the seconds count should be smaller or equal.\n+                //\n+                // We assume that backslides are smaller than 2^32 seconds\n+                // which means we need to add 1 to the upper half to restore it.\n+                //\n+                // Example:\n+                // most recent observed time: 0xA1_0000_0000_0000_0000u128\n+                // bits stored in AtomicU64:     0x0000_0000_0000_0000u64\n+                // backslide by 1s\n+                // caller time is             0xA0_ffff_ffff_0000_0000u128\n+                // -> we can fix up the upper half time by adding 1 << 32\n+                seconds_upper = seconds_upper.wrapping_add(0x1_0000_0000);\n+            }\n+            let secs = seconds_upper | seconds_lower;\n             let nanos = old as u32;\n             ZERO.checked_add_duration(&Duration::new(secs, nanos)).unwrap()\n         }"}, {"sha": "82693d35e1532a7a590ec8026a9e7bba9f50dbaf", "filename": "library/std/src/time/tests.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ff12ab2d9913ff20db62379378ccddc6bffa9f4e/library%2Fstd%2Fsrc%2Ftime%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff12ab2d9913ff20db62379378ccddc6bffa9f4e/library%2Fstd%2Fsrc%2Ftime%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ftime%2Ftests.rs?ref=ff12ab2d9913ff20db62379378ccddc6bffa9f4e", "patch": "@@ -1,4 +1,5 @@\n use super::{Duration, Instant, SystemTime, UNIX_EPOCH};\n+use core::sync::atomic::AtomicU64;\n use test::{black_box, Bencher};\n \n macro_rules! assert_almost_eq {\n@@ -190,6 +191,23 @@ fn since_epoch() {\n     assert!(a < hundred_twenty_years);\n }\n \n+#[cfg(all(target_has_atomic = \"64\", not(target_has_atomic = \"128\")))]\n+#[test]\n+fn monotonizer_wrapping_backslide() {\n+    use super::monotonic::inner::{monotonize_impl, ZERO};\n+\n+    let reference = AtomicU64::new(0);\n+\n+    let time = ZERO.checked_add_duration(&Duration::from_secs(0xffff_ffff)).unwrap();\n+\n+    let monotonized = monotonize_impl(&reference, time);\n+    let expected = ZERO.checked_add_duration(&Duration::from_secs(1 << 32)).unwrap();\n+    assert_eq!(\n+        monotonized, expected,\n+        \"64bit monotonizer should handle overflows in the seconds part\"\n+    );\n+}\n+\n macro_rules! bench_instant_threaded {\n     ($bench_name:ident, $thread_count:expr) => {\n         #[bench]"}]}