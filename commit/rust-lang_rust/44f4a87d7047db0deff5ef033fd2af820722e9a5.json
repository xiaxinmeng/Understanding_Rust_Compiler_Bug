{"sha": "44f4a87d7047db0deff5ef033fd2af820722e9a5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ0ZjRhODdkNzA0N2RiMGRlZmY1ZWYwMzNmZDJhZjgyMDcyMmU5YTU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-06-22T07:01:54Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-06-22T07:01:54Z"}, "message": "Auto merge of #85707 - jam1garner:future_prelude_collision_lint, r=nikomatsakis\n\nAdd `future_prelude_collision` lint\n\nImplements #84594. (RFC rust-lang/rfcs#3114 ([rendered](https://github.com/rust-lang/rfcs/blob/master/text/3114-prelude-2021.md))) Not entirely complete but wanted to have my progress decently available while I finish off the last little bits.\n\nThings left to implement:\n\n* [x] UI tests for lints\n* [x] Only emit lint for 2015 and 2018 editions\n* [ ] Lint name/message bikeshedding\n* [x] Implement for `FromIterator` (from best I can tell, the current approach as mentioned from [this comment](https://github.com/rust-lang/rust/issues/84594#issuecomment-847288288) won't work due to `FromIterator` instances not using dot-call syntax, but if I'm correct about this then that would also need to be fixed for `TryFrom`/`TryInto`)*\n* [x] Add to `rust-2021-migration` group? (See #85512) (added to `rust-2021-compatibility` group)\n* [ ] Link to edition guide in lint docs\n\n*edit: looked into it, `lookup_method` will also not be hit for `TryFrom`/`TryInto` for non-dotcall syntax. If anyone who is more familiar with typecheck knows the equivalent for looking up associated functions, feel free to chime in.", "tree": {"sha": "4960627de594af7fc920104a8f40245e480485e9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4960627de594af7fc920104a8f40245e480485e9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/44f4a87d7047db0deff5ef033fd2af820722e9a5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/44f4a87d7047db0deff5ef033fd2af820722e9a5", "html_url": "https://github.com/rust-lang/rust/commit/44f4a87d7047db0deff5ef033fd2af820722e9a5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/44f4a87d7047db0deff5ef033fd2af820722e9a5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c38111c4fb9c22a36f9a9195d1884052bb670af2", "url": "https://api.github.com/repos/rust-lang/rust/commits/c38111c4fb9c22a36f9a9195d1884052bb670af2", "html_url": "https://github.com/rust-lang/rust/commit/c38111c4fb9c22a36f9a9195d1884052bb670af2"}, {"sha": "aa3580baa6f5ef69aba41a63297fb659bcd4b793", "url": "https://api.github.com/repos/rust-lang/rust/commits/aa3580baa6f5ef69aba41a63297fb659bcd4b793", "html_url": "https://github.com/rust-lang/rust/commit/aa3580baa6f5ef69aba41a63297fb659bcd4b793"}], "stats": {"total": 1175, "additions": 1144, "deletions": 31}, "files": [{"sha": "a2f60142ffc7567a1b6272bc2f1db7d1c051109d", "filename": "compiler/rustc_lint_defs/src/builtin.rs", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/44f4a87d7047db0deff5ef033fd2af820722e9a5/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44f4a87d7047db0deff5ef033fd2af820722e9a5/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs?ref=44f4a87d7047db0deff5ef033fd2af820722e9a5", "patch": "@@ -3001,6 +3001,7 @@ declare_lint_pass! {\n         PROC_MACRO_BACK_COMPAT,\n         OR_PATTERNS_BACK_COMPAT,\n         LARGE_ASSIGNMENTS,\n+        FUTURE_PRELUDE_COLLISION,\n     ]\n }\n \n@@ -3244,3 +3245,52 @@ declare_lint! {\n         edition: Some(Edition::Edition2021),\n     };\n }\n+\n+declare_lint! {\n+    /// The `future_prelude_collision` lint detects the usage of trait methods which are ambiguous\n+    /// with traits added to the prelude in future editions.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust,compile_fail\n+    /// #![deny(future_prelude_collision)]\n+    ///\n+    /// trait Foo {\n+    ///     fn try_into(self) -> Result<String, !>;\n+    /// }\n+    ///\n+    /// impl Foo for &str {\n+    ///     fn try_into(self) -> Result<String, !> {\n+    ///         Ok(String::from(self))\n+    ///     }\n+    /// }\n+    ///\n+    /// fn main() {\n+    ///     let x: String = \"3\".try_into().unwrap();\n+    ///     //                  ^^^^^^^^\n+    ///     // This call to try_into matches both Foo:try_into and TryInto::try_into as\n+    ///     // `TryInto` has been added to the Rust prelude in 2021 edition.\n+    ///     println!(\"{}\", x);\n+    /// }\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// In Rust 2021, one of the important introductions is the [prelude changes], which add\n+    /// `TryFrom`, `TryInto`, and `FromIterator` into the standard library's prelude. Since this\n+    /// results in an amiguity as to which method/function to call when an existing `try_into`\n+    ///  method is called via dot-call syntax or a `try_from`/`from_iter` associated function\n+    ///  is called directly on a type.\n+    ///\n+    /// [prelude changes]: https://blog.rust-lang.org/inside-rust/2021/03/04/planning-rust-2021.html#prelude-changes\n+    pub FUTURE_PRELUDE_COLLISION,\n+    Allow,\n+    \"detects the usage of trait methods which are ambiguous with traits added to the \\\n+        prelude in future editions\",\n+    @future_incompatible = FutureIncompatibleInfo {\n+        reference: \"issue #85684 <https://github.com/rust-lang/rust/issues/85684>\",\n+        edition: Some(Edition::Edition2021),\n+    };\n+}"}, {"sha": "55b6056209d7c408e4c27b6afdbefa9ea4b4e8aa", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/44f4a87d7047db0deff5ef033fd2af820722e9a5/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44f4a87d7047db0deff5ef033fd2af820722e9a5/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=44f4a87d7047db0deff5ef033fd2af820722e9a5", "patch": "@@ -586,6 +586,7 @@ symbols! {\n         from,\n         from_desugaring,\n         from_generator,\n+        from_iter,\n         from_method,\n         from_output,\n         from_residual,\n@@ -1238,7 +1239,9 @@ symbols! {\n         truncf32,\n         truncf64,\n         try_blocks,\n+        try_from,\n         try_from_trait,\n+        try_into,\n         try_into_trait,\n         try_trait_v2,\n         tt,"}, {"sha": "28ab6b1513310b4eef2d7ee244f4cc923b1869a8", "filename": "compiler/rustc_typeck/src/check/expr.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/44f4a87d7047db0deff5ef033fd2af820722e9a5/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44f4a87d7047db0deff5ef033fd2af820722e9a5/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs?ref=44f4a87d7047db0deff5ef033fd2af820722e9a5", "patch": "@@ -466,7 +466,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         expr: &'tcx hir::Expr<'tcx>,\n     ) -> Ty<'tcx> {\n         let tcx = self.tcx;\n-        let (res, opt_ty, segs) = self.resolve_ty_and_res_ufcs(qpath, expr.hir_id, expr.span);\n+        let (res, opt_ty, segs) =\n+            self.resolve_ty_and_res_fully_qualified_call(qpath, expr.hir_id, expr.span);\n         let ty = match res {\n             Res::Err => {\n                 self.set_tainted_by_errors();\n@@ -940,7 +941,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // no need to check for bot/err -- callee does that\n         let rcvr_t = self.structurally_resolved_type(args[0].span, rcvr_t);\n \n-        let method = match self.lookup_method(rcvr_t, segment, span, expr, rcvr) {\n+        let method = match self.lookup_method(rcvr_t, segment, span, expr, rcvr, args) {\n             Ok(method) => {\n                 // We could add a \"consider `foo::<params>`\" suggestion here, but I wasn't able to\n                 // trigger this codepath causing `structuraly_resolved_type` to emit an error."}, {"sha": "8e33f4f9e12f637ccae950c920a5ffa08b4d6c9c", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/_impl.rs", "status": "modified", "additions": 28, "deletions": 21, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/44f4a87d7047db0deff5ef033fd2af820722e9a5/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44f4a87d7047db0deff5ef033fd2af820722e9a5/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs?ref=44f4a87d7047db0deff5ef033fd2af820722e9a5", "patch": "@@ -906,13 +906,16 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     /// Resolves an associated value path into a base type and associated constant, or method\n     /// resolution. The newly resolved definition is written into `type_dependent_defs`.\n-    pub fn resolve_ty_and_res_ufcs(\n+    pub fn resolve_ty_and_res_fully_qualified_call(\n         &self,\n         qpath: &'tcx QPath<'tcx>,\n         hir_id: hir::HirId,\n         span: Span,\n     ) -> (Res, Option<Ty<'tcx>>, &'tcx [hir::PathSegment<'tcx>]) {\n-        debug!(\"resolve_ty_and_res_ufcs: qpath={:?} hir_id={:?} span={:?}\", qpath, hir_id, span);\n+        debug!(\n+            \"resolve_ty_and_res_fully_qualified_call: qpath={:?} hir_id={:?} span={:?}\",\n+            qpath, hir_id, span\n+        );\n         let (ty, qself, item_segment) = match *qpath {\n             QPath::Resolved(ref opt_qself, ref path) => {\n                 return (\n@@ -922,7 +925,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 );\n             }\n             QPath::TypeRelative(ref qself, ref segment) => (self.to_ty(qself), qself, segment),\n-            QPath::LangItem(..) => bug!(\"`resolve_ty_and_res_ufcs` called on `LangItem`\"),\n+            QPath::LangItem(..) => {\n+                bug!(\"`resolve_ty_and_res_fully_qualified_call` called on `LangItem`\")\n+            }\n         };\n         if let Some(&cached_result) = self.typeck_results.borrow().type_dependent_defs().get(hir_id)\n         {\n@@ -932,25 +937,27 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             return (def, Some(ty), slice::from_ref(&**item_segment));\n         }\n         let item_name = item_segment.ident;\n-        let result = self.resolve_ufcs(span, item_name, ty, hir_id).or_else(|error| {\n-            let result = match error {\n-                method::MethodError::PrivateMatch(kind, def_id, _) => Ok((kind, def_id)),\n-                _ => Err(ErrorReported),\n-            };\n-            if item_name.name != kw::Empty {\n-                if let Some(mut e) = self.report_method_error(\n-                    span,\n-                    ty,\n-                    item_name,\n-                    SelfSource::QPath(qself),\n-                    error,\n-                    None,\n-                ) {\n-                    e.emit();\n+        let result = self\n+            .resolve_fully_qualified_call(span, item_name, ty, qself.span, hir_id)\n+            .or_else(|error| {\n+                let result = match error {\n+                    method::MethodError::PrivateMatch(kind, def_id, _) => Ok((kind, def_id)),\n+                    _ => Err(ErrorReported),\n+                };\n+                if item_name.name != kw::Empty {\n+                    if let Some(mut e) = self.report_method_error(\n+                        span,\n+                        ty,\n+                        item_name,\n+                        SelfSource::QPath(qself),\n+                        error,\n+                        None,\n+                    ) {\n+                        e.emit();\n+                    }\n                 }\n-            }\n-            result\n-        });\n+                result\n+            });\n \n         if result.is_ok() {\n             self.maybe_lint_bare_trait(qpath, hir_id);"}, {"sha": "be6bc625d893ff5012eda2b63e1a19ac6c411436", "filename": "compiler/rustc_typeck/src/check/method/mod.rs", "status": "modified", "additions": 41, "deletions": 6, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/44f4a87d7047db0deff5ef033fd2af820722e9a5/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44f4a87d7047db0deff5ef033fd2af820722e9a5/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fmod.rs?ref=44f4a87d7047db0deff5ef033fd2af820722e9a5", "patch": "@@ -3,6 +3,7 @@\n //! [rustc dev guide]: https://rustc-dev-guide.rust-lang.org/method-lookup.html\n \n mod confirm;\n+mod prelude2021;\n pub mod probe;\n mod suggest;\n \n@@ -173,14 +174,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     ///\n     /// # Arguments\n     ///\n-    /// Given a method call like `foo.bar::<T1,...Tn>(...)`:\n+    /// Given a method call like `foo.bar::<T1,...Tn>(a, b + 1, ...)`:\n     ///\n     /// * `self`:                  the surrounding `FnCtxt` (!)\n     /// * `self_ty`:               the (unadjusted) type of the self expression (`foo`)\n     /// * `segment`:               the name and generic arguments of the method (`bar::<T1, ...Tn>`)\n     /// * `span`:                  the span for the method call\n     /// * `call_expr`:             the complete method call: (`foo.bar::<T1,...Tn>(...)`)\n     /// * `self_expr`:             the self expression (`foo`)\n+    /// * `args`:                  the expressions of the arguments (`a, b + 1, ...`)\n     #[instrument(level = \"debug\", skip(self, call_expr, self_expr))]\n     pub fn lookup_method(\n         &self,\n@@ -189,6 +191,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         span: Span,\n         call_expr: &'tcx hir::Expr<'tcx>,\n         self_expr: &'tcx hir::Expr<'tcx>,\n+        args: &'tcx [hir::Expr<'tcx>],\n     ) -> Result<MethodCallee<'tcx>, MethodError<'tcx>> {\n         debug!(\n             \"lookup(method_name={}, self_ty={:?}, call_expr={:?}, self_expr={:?})\",\n@@ -198,6 +201,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let pick =\n             self.lookup_probe(span, segment.ident, self_ty, call_expr, ProbeScope::TraitsInScope)?;\n \n+        self.lint_dot_call_from_2018(self_ty, segment, span, call_expr, self_expr, &pick, args);\n+\n         for import_id in &pick.import_ids {\n             debug!(\"used_trait_import: {:?}\", import_id);\n             Lrc::get_mut(&mut self.typeck_results.borrow_mut().used_trait_imports)\n@@ -417,16 +422,33 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         Some(InferOk { obligations, value: callee })\n     }\n \n+    /// Performs a [full-qualified function call] (formerly \"universal function call\") lookup. If\n+    /// lookup is successful, it will return the type of definition and the [`DefId`] of the found\n+    /// function definition.\n+    ///\n+    /// [full-qualified function call]: https://doc.rust-lang.org/reference/expressions/call-expr.html#disambiguating-function-calls\n+    ///\n+    /// # Arguments\n+    ///\n+    /// Given a function call like `Foo::bar::<T1,...Tn>(...)`:\n+    ///\n+    /// * `self`:                  the surrounding `FnCtxt` (!)\n+    /// * `span`:                  the span of the call, excluding arguments (`Foo::bar::<T1, ...Tn>`)\n+    /// * `method_name`:           the identifier of the function within the container type (`bar`)\n+    /// * `self_ty`:               the type to search within (`Foo`)\n+    /// * `self_ty_span`           the span for the type being searched within (span of `Foo`)\n+    /// * `expr_id`:               the [`hir::HirId`] of the expression composing the entire call\n     #[instrument(level = \"debug\", skip(self))]\n-    pub fn resolve_ufcs(\n+    pub fn resolve_fully_qualified_call(\n         &self,\n         span: Span,\n         method_name: Ident,\n         self_ty: Ty<'tcx>,\n+        self_ty_span: Span,\n         expr_id: hir::HirId,\n     ) -> Result<(DefKind, DefId), MethodError<'tcx>> {\n         debug!(\n-            \"resolve_ufcs: method_name={:?} self_ty={:?} expr_id={:?}\",\n+            \"resolve_fully_qualified_call: method_name={:?} self_ty={:?} expr_id={:?}\",\n             method_name, self_ty, expr_id,\n         );\n \n@@ -463,18 +485,31 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             expr_id,\n             ProbeScope::TraitsInScope,\n         )?;\n-        debug!(\"resolve_ufcs: pick={:?}\", pick);\n+\n+        self.lint_fully_qualified_call_from_2018(\n+            span,\n+            method_name,\n+            self_ty,\n+            self_ty_span,\n+            expr_id,\n+            &pick,\n+        );\n+\n+        debug!(\"resolve_fully_qualified_call: pick={:?}\", pick);\n         {\n             let mut typeck_results = self.typeck_results.borrow_mut();\n             let used_trait_imports = Lrc::get_mut(&mut typeck_results.used_trait_imports).unwrap();\n             for import_id in pick.import_ids {\n-                debug!(\"resolve_ufcs: used_trait_import: {:?}\", import_id);\n+                debug!(\"resolve_fully_qualified_call: used_trait_import: {:?}\", import_id);\n                 used_trait_imports.insert(import_id);\n             }\n         }\n \n         let def_kind = pick.item.kind.as_def_kind();\n-        debug!(\"resolve_ufcs: def_kind={:?}, def_id={:?}\", def_kind, pick.item.def_id);\n+        debug!(\n+            \"resolve_fully_qualified_call: def_kind={:?}, def_id={:?}\",\n+            def_kind, pick.item.def_id\n+        );\n         tcx.check_stability(pick.item.def_id, Some(expr_id), span, Some(method_name.span));\n         Ok((def_kind, pick.item.def_id))\n     }"}, {"sha": "4c925a6f2370775a7c31ae85c0b3617c9f46cba7", "filename": "compiler/rustc_typeck/src/check/method/prelude2021.rs", "status": "added", "additions": 330, "deletions": 0, "changes": 330, "blob_url": "https://github.com/rust-lang/rust/blob/44f4a87d7047db0deff5ef033fd2af820722e9a5/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprelude2021.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44f4a87d7047db0deff5ef033fd2af820722e9a5/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprelude2021.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprelude2021.rs?ref=44f4a87d7047db0deff5ef033fd2af820722e9a5", "patch": "@@ -0,0 +1,330 @@\n+use hir::def_id::DefId;\n+use hir::HirId;\n+use hir::ItemKind;\n+use rustc_ast::Mutability;\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_middle::ty::{Ref, Ty};\n+use rustc_session::lint::builtin::FUTURE_PRELUDE_COLLISION;\n+use rustc_span::symbol::kw::Underscore;\n+use rustc_span::symbol::{sym, Ident};\n+use rustc_span::Span;\n+\n+use crate::check::{\n+    method::probe::{self, Pick},\n+    FnCtxt,\n+};\n+\n+impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n+    pub(super) fn lint_dot_call_from_2018(\n+        &self,\n+        self_ty: Ty<'tcx>,\n+        segment: &hir::PathSegment<'_>,\n+        span: Span,\n+        call_expr: &'tcx hir::Expr<'tcx>,\n+        self_expr: &'tcx hir::Expr<'tcx>,\n+        pick: &Pick<'tcx>,\n+        args: &'tcx [hir::Expr<'tcx>],\n+    ) {\n+        debug!(\n+            \"lookup(method_name={}, self_ty={:?}, call_expr={:?}, self_expr={:?})\",\n+            segment.ident, self_ty, call_expr, self_expr\n+        );\n+\n+        // Rust 2021 and later is already using the new prelude\n+        if span.rust_2021() {\n+            return;\n+        }\n+\n+        // These are the method names that were added to prelude in Rust 2021\n+        if !matches!(segment.ident.name, sym::try_into) {\n+            return;\n+        }\n+\n+        // No need to lint if method came from std/core, as that will now be in the prelude\n+        if matches!(self.tcx.crate_name(pick.item.def_id.krate), sym::std | sym::core) {\n+            return;\n+        }\n+\n+        if matches!(pick.kind, probe::PickKind::InherentImplPick | probe::PickKind::ObjectPick) {\n+            // avoid repeatedly adding unneeded `&*`s\n+            if pick.autoderefs == 1\n+                && matches!(\n+                    pick.autoref_or_ptr_adjustment,\n+                    Some(probe::AutorefOrPtrAdjustment::Autoref { .. })\n+                )\n+                && matches!(self_ty.kind(), Ref(..))\n+            {\n+                return;\n+            }\n+            // Inherent impls only require not relying on autoref and autoderef in order to\n+            // ensure that the trait implementation won't be used\n+            self.tcx.struct_span_lint_hir(\n+                FUTURE_PRELUDE_COLLISION,\n+                self_expr.hir_id,\n+                self_expr.span,\n+                |lint| {\n+                    let sp = self_expr.span;\n+\n+                    let mut lint = lint.build(&format!(\n+                        \"trait method `{}` will become ambiguous in Rust 2021\",\n+                        segment.ident.name\n+                    ));\n+\n+                    let derefs = \"*\".repeat(pick.autoderefs);\n+\n+                    let autoref = match pick.autoref_or_ptr_adjustment {\n+                        Some(probe::AutorefOrPtrAdjustment::Autoref {\n+                            mutbl: Mutability::Mut,\n+                            ..\n+                        }) => \"&mut \",\n+                        Some(probe::AutorefOrPtrAdjustment::Autoref {\n+                            mutbl: Mutability::Not,\n+                            ..\n+                        }) => \"&\",\n+                        Some(probe::AutorefOrPtrAdjustment::ToConstPtr) | None => \"\",\n+                    };\n+                    if let Ok(self_expr) = self.sess().source_map().span_to_snippet(self_expr.span)\n+                    {\n+                        let self_adjusted = if let Some(probe::AutorefOrPtrAdjustment::ToConstPtr) =\n+                            pick.autoref_or_ptr_adjustment\n+                        {\n+                            format!(\"{}{} as *const _\", derefs, self_expr)\n+                        } else {\n+                            format!(\"{}{}{}\", autoref, derefs, self_expr)\n+                        };\n+\n+                        lint.span_suggestion(\n+                            sp,\n+                            \"disambiguate the method call\",\n+                            format!(\"({})\", self_adjusted),\n+                            Applicability::MachineApplicable,\n+                        );\n+                    } else {\n+                        let self_adjusted = if let Some(probe::AutorefOrPtrAdjustment::ToConstPtr) =\n+                            pick.autoref_or_ptr_adjustment\n+                        {\n+                            format!(\"{}(...) as *const _\", derefs)\n+                        } else {\n+                            format!(\"{}{}...\", autoref, derefs)\n+                        };\n+                        lint.span_help(\n+                            sp,\n+                            &format!(\"disambiguate the method call with `({})`\", self_adjusted,),\n+                        );\n+                    }\n+\n+                    lint.emit();\n+                },\n+            );\n+        } else {\n+            // trait implementations require full disambiguation to not clash with the new prelude\n+            // additions (i.e. convert from dot-call to fully-qualified call)\n+            self.tcx.struct_span_lint_hir(\n+                FUTURE_PRELUDE_COLLISION,\n+                call_expr.hir_id,\n+                call_expr.span,\n+                |lint| {\n+                    let sp = call_expr.span;\n+                    let trait_name = self.trait_path_or_bare_name(\n+                        span,\n+                        call_expr.hir_id,\n+                        pick.item.container.id(),\n+                    );\n+\n+                    let mut lint = lint.build(&format!(\n+                        \"trait method `{}` will become ambiguous in Rust 2021\",\n+                        segment.ident.name\n+                    ));\n+\n+                    let (self_adjusted, precise) = self.adjust_expr(pick, self_expr);\n+                    if precise {\n+                        let args = args\n+                            .iter()\n+                            .skip(1)\n+                            .map(|arg| {\n+                                format!(\n+                                    \", {}\",\n+                                    self.sess().source_map().span_to_snippet(arg.span).unwrap()\n+                                )\n+                            })\n+                            .collect::<String>();\n+\n+                        lint.span_suggestion(\n+                            sp,\n+                            \"disambiguate the associated function\",\n+                            format!(\n+                                \"{}::{}({}{})\",\n+                                trait_name, segment.ident.name, self_adjusted, args\n+                            ),\n+                            Applicability::MachineApplicable,\n+                        );\n+                    } else {\n+                        lint.span_help(\n+                            sp,\n+                            &format!(\n+                                \"disambiguate the associated function with `{}::{}(...)`\",\n+                                trait_name, segment.ident,\n+                            ),\n+                        );\n+                    }\n+\n+                    lint.emit();\n+                },\n+            );\n+        }\n+    }\n+\n+    pub(super) fn lint_fully_qualified_call_from_2018(\n+        &self,\n+        span: Span,\n+        method_name: Ident,\n+        self_ty: Ty<'tcx>,\n+        self_ty_span: Span,\n+        expr_id: hir::HirId,\n+        pick: &Pick<'tcx>,\n+    ) {\n+        // Rust 2021 and later is already using the new prelude\n+        if span.rust_2021() {\n+            return;\n+        }\n+\n+        // These are the fully qualified methods added to prelude in Rust 2021\n+        if !matches!(method_name.name, sym::try_into | sym::try_from | sym::from_iter) {\n+            return;\n+        }\n+\n+        // No need to lint if method came from std/core, as that will now be in the prelude\n+        if matches!(self.tcx.crate_name(pick.item.def_id.krate), sym::std | sym::core) {\n+            return;\n+        }\n+\n+        // No need to lint if this is an inherent method called on a specific type, like `Vec::foo(...)`,\n+        // since such methods take precedence over trait methods.\n+        if matches!(pick.kind, probe::PickKind::InherentImplPick) {\n+            return;\n+        }\n+\n+        self.tcx.struct_span_lint_hir(FUTURE_PRELUDE_COLLISION, expr_id, span, |lint| {\n+            // \"type\" refers to either a type or, more likely, a trait from which\n+            // the associated function or method is from.\n+            let trait_path = self.trait_path_or_bare_name(span, expr_id, pick.item.container.id());\n+            let trait_generics = self.tcx.generics_of(pick.item.container.id());\n+\n+            let parameter_count = trait_generics.count() - (trait_generics.has_self as usize);\n+            let trait_name = if parameter_count == 0 {\n+                trait_path\n+            } else {\n+                format!(\n+                    \"{}<{}>\",\n+                    trait_path,\n+                    std::iter::repeat(\"_\").take(parameter_count).collect::<Vec<_>>().join(\", \")\n+                )\n+            };\n+\n+            let mut lint = lint.build(&format!(\n+                \"trait-associated function `{}` will become ambiguous in Rust 2021\",\n+                method_name.name\n+            ));\n+\n+            let self_ty = self\n+                .sess()\n+                .source_map()\n+                .span_to_snippet(self_ty_span)\n+                .unwrap_or_else(|_| self_ty.to_string());\n+\n+            lint.span_suggestion(\n+                span,\n+                \"disambiguate the associated function\",\n+                format!(\"<{} as {}>::{}\", self_ty, trait_name, method_name.name,),\n+                Applicability::MachineApplicable,\n+            );\n+\n+            lint.emit();\n+        });\n+    }\n+\n+    fn trait_path_or_bare_name(\n+        &self,\n+        span: Span,\n+        expr_hir_id: HirId,\n+        trait_def_id: DefId,\n+    ) -> String {\n+        self.trait_path(span, expr_hir_id, trait_def_id).unwrap_or_else(|| {\n+            let key = self.tcx.def_key(trait_def_id);\n+            format!(\"{}\", key.disambiguated_data.data)\n+        })\n+    }\n+\n+    fn trait_path(&self, span: Span, expr_hir_id: HirId, trait_def_id: DefId) -> Option<String> {\n+        let applicable_traits = self.tcx.in_scope_traits(expr_hir_id)?;\n+        let applicable_trait = applicable_traits.iter().find(|t| t.def_id == trait_def_id)?;\n+        if applicable_trait.import_ids.is_empty() {\n+            // The trait was declared within the module, we only need to use its name.\n+            return None;\n+        }\n+\n+        let import_items: Vec<_> = applicable_trait\n+            .import_ids\n+            .iter()\n+            .map(|&import_id| {\n+                let hir_id = self.tcx.hir().local_def_id_to_hir_id(import_id);\n+                self.tcx.hir().expect_item(hir_id)\n+            })\n+            .collect();\n+\n+        // Find an identifier with which this trait was imported (note that `_` doesn't count).\n+        let any_id = import_items\n+            .iter()\n+            .filter_map(|item| if item.ident.name != Underscore { Some(item.ident) } else { None })\n+            .next();\n+        if let Some(any_id) = any_id {\n+            return Some(format!(\"{}\", any_id));\n+        }\n+\n+        // All that is left is `_`! We need to use the full path. It doesn't matter which one we pick,\n+        // so just take the first one.\n+        match import_items[0].kind {\n+            ItemKind::Use(path, _) => Some(\n+                path.segments\n+                    .iter()\n+                    .map(|segment| segment.ident.to_string())\n+                    .collect::<Vec<_>>()\n+                    .join(\"::\"),\n+            ),\n+            _ => {\n+                span_bug!(span, \"unexpected item kind, expected a use: {:?}\", import_items[0].kind);\n+            }\n+        }\n+    }\n+\n+    /// Creates a string version of the `expr` that includes explicit adjustments.\n+    /// Returns the string and also a bool indicating whther this is a *precise*\n+    /// suggestion.\n+    fn adjust_expr(&self, pick: &Pick<'tcx>, expr: &hir::Expr<'tcx>) -> (String, bool) {\n+        let derefs = \"*\".repeat(pick.autoderefs);\n+\n+        let autoref = match pick.autoref_or_ptr_adjustment {\n+            Some(probe::AutorefOrPtrAdjustment::Autoref { mutbl: Mutability::Mut, .. }) => \"&mut \",\n+            Some(probe::AutorefOrPtrAdjustment::Autoref { mutbl: Mutability::Not, .. }) => \"&\",\n+            Some(probe::AutorefOrPtrAdjustment::ToConstPtr) | None => \"\",\n+        };\n+\n+        let (expr_text, precise) =\n+            if let Ok(expr_text) = self.sess().source_map().span_to_snippet(expr.span) {\n+                (expr_text, true)\n+            } else {\n+                (format!(\"(..)\"), false)\n+            };\n+\n+        let adjusted_text = if let Some(probe::AutorefOrPtrAdjustment::ToConstPtr) =\n+            pick.autoref_or_ptr_adjustment\n+        {\n+            format!(\"{}{} as *const _\", derefs, expr_text)\n+        } else {\n+            format!(\"{}{}{}\", autoref, derefs, expr_text)\n+        };\n+\n+        (adjusted_text, precise)\n+    }\n+}"}, {"sha": "2879614d0c8085ff9ebcbbfa0769af46da4a2aaf", "filename": "compiler/rustc_typeck/src/check/pat.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/44f4a87d7047db0deff5ef033fd2af820722e9a5/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44f4a87d7047db0deff5ef033fd2af820722e9a5/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fpat.rs?ref=44f4a87d7047db0deff5ef033fd2af820722e9a5", "patch": "@@ -160,7 +160,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         ti: TopInfo<'tcx>,\n     ) {\n         let path_res = match &pat.kind {\n-            PatKind::Path(qpath) => Some(self.resolve_ty_and_res_ufcs(qpath, pat.hir_id, pat.span)),\n+            PatKind::Path(qpath) => {\n+                Some(self.resolve_ty_and_res_fully_qualified_call(qpath, pat.hir_id, pat.span))\n+            }\n             _ => None,\n         };\n         let adjust_mode = self.calc_adjust_mode(pat, path_res.map(|(res, ..)| res));\n@@ -904,7 +906,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         };\n \n         // Resolve the path and check the definition for errors.\n-        let (res, opt_ty, segments) = self.resolve_ty_and_res_ufcs(qpath, pat.hir_id, pat.span);\n+        let (res, opt_ty, segments) =\n+            self.resolve_ty_and_res_fully_qualified_call(qpath, pat.hir_id, pat.span);\n         if res == Res::Err {\n             self.set_tainted_by_errors();\n             on_error();"}, {"sha": "4f8fd9b345b2821cac490016138656e986e4b612", "filename": "src/test/ui/rust-2021/future-prelude-collision-imported.fixed", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/44f4a87d7047db0deff5ef033fd2af820722e9a5/src%2Ftest%2Fui%2Frust-2021%2Ffuture-prelude-collision-imported.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/44f4a87d7047db0deff5ef033fd2af820722e9a5/src%2Ftest%2Fui%2Frust-2021%2Ffuture-prelude-collision-imported.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2021%2Ffuture-prelude-collision-imported.fixed?ref=44f4a87d7047db0deff5ef033fd2af820722e9a5", "patch": "@@ -0,0 +1,59 @@\n+// run-rustfix\n+// edition:2018\n+// check-pass\n+#![warn(future_prelude_collision)]\n+#![allow(dead_code)]\n+#![allow(unused_imports)]\n+\n+mod m {\n+    pub trait TryIntoU32 {\n+        fn try_into(self) -> Result<u32, ()>;\n+    }\n+\n+    impl TryIntoU32 for u8 {\n+        fn try_into(self) -> Result<u32, ()> {\n+            Ok(self as u32)\n+        }\n+    }\n+\n+    pub trait AnotherTrick {}\n+}\n+\n+mod a {\n+    use crate::m::TryIntoU32;\n+\n+    fn main() {\n+        // In this case, we can just use `TryIntoU32`\n+        let _: u32 = TryIntoU32::try_into(3u8).unwrap();\n+        //~^ WARNING trait method `try_into` will become ambiguous in Rust 2021\n+        //~^^ WARNING this was previously accepted by the compiler but is being phased out; it will become a hard error in the 2021 edition!\n+    }\n+}\n+\n+mod b {\n+    use crate::m::AnotherTrick as TryIntoU32;\n+    use crate::m::TryIntoU32 as _;\n+\n+    fn main() {\n+        // In this case, a `TryIntoU32::try_into` rewrite will not work, and we need to use\n+        // the path `crate::m::TryIntoU32` (with which it was imported).\n+        let _: u32 = crate::m::TryIntoU32::try_into(3u8).unwrap();\n+        //~^ WARNING trait method `try_into` will become ambiguous in Rust 2021\n+        //~^^ WARNING this was previously accepted by the compiler but is being phased out; it will become a hard error in the 2021 edition!\n+    }\n+}\n+\n+mod c {\n+    use super::m::TryIntoU32 as _;\n+    use crate::m::AnotherTrick as TryIntoU32;\n+\n+    fn main() {\n+        // In this case, a `TryIntoU32::try_into` rewrite will not work, and we need to use\n+        // the path `super::m::TryIntoU32` (with which it was imported).\n+        let _: u32 = super::m::TryIntoU32::try_into(3u8).unwrap();\n+        //~^ WARNING trait method `try_into` will become ambiguous in Rust 2021\n+        //~^^ WARNING this was previously accepted by the compiler but is being phased out; it will become a hard error in the 2021 edition!\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "2ce1be6151b11759bb30825c2acd6ee614681edc", "filename": "src/test/ui/rust-2021/future-prelude-collision-imported.rs", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/44f4a87d7047db0deff5ef033fd2af820722e9a5/src%2Ftest%2Fui%2Frust-2021%2Ffuture-prelude-collision-imported.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44f4a87d7047db0deff5ef033fd2af820722e9a5/src%2Ftest%2Fui%2Frust-2021%2Ffuture-prelude-collision-imported.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2021%2Ffuture-prelude-collision-imported.rs?ref=44f4a87d7047db0deff5ef033fd2af820722e9a5", "patch": "@@ -0,0 +1,59 @@\n+// run-rustfix\n+// edition:2018\n+// check-pass\n+#![warn(future_prelude_collision)]\n+#![allow(dead_code)]\n+#![allow(unused_imports)]\n+\n+mod m {\n+    pub trait TryIntoU32 {\n+        fn try_into(self) -> Result<u32, ()>;\n+    }\n+\n+    impl TryIntoU32 for u8 {\n+        fn try_into(self) -> Result<u32, ()> {\n+            Ok(self as u32)\n+        }\n+    }\n+\n+    pub trait AnotherTrick {}\n+}\n+\n+mod a {\n+    use crate::m::TryIntoU32;\n+\n+    fn main() {\n+        // In this case, we can just use `TryIntoU32`\n+        let _: u32 = 3u8.try_into().unwrap();\n+        //~^ WARNING trait method `try_into` will become ambiguous in Rust 2021\n+        //~^^ WARNING this was previously accepted by the compiler but is being phased out; it will become a hard error in the 2021 edition!\n+    }\n+}\n+\n+mod b {\n+    use crate::m::AnotherTrick as TryIntoU32;\n+    use crate::m::TryIntoU32 as _;\n+\n+    fn main() {\n+        // In this case, a `TryIntoU32::try_into` rewrite will not work, and we need to use\n+        // the path `crate::m::TryIntoU32` (with which it was imported).\n+        let _: u32 = 3u8.try_into().unwrap();\n+        //~^ WARNING trait method `try_into` will become ambiguous in Rust 2021\n+        //~^^ WARNING this was previously accepted by the compiler but is being phased out; it will become a hard error in the 2021 edition!\n+    }\n+}\n+\n+mod c {\n+    use super::m::TryIntoU32 as _;\n+    use crate::m::AnotherTrick as TryIntoU32;\n+\n+    fn main() {\n+        // In this case, a `TryIntoU32::try_into` rewrite will not work, and we need to use\n+        // the path `super::m::TryIntoU32` (with which it was imported).\n+        let _: u32 = 3u8.try_into().unwrap();\n+        //~^ WARNING trait method `try_into` will become ambiguous in Rust 2021\n+        //~^^ WARNING this was previously accepted by the compiler but is being phased out; it will become a hard error in the 2021 edition!\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "3903cbfe824904445ccc97d4e0c4b7d4a6269e1d", "filename": "src/test/ui/rust-2021/future-prelude-collision-imported.stderr", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/44f4a87d7047db0deff5ef033fd2af820722e9a5/src%2Ftest%2Fui%2Frust-2021%2Ffuture-prelude-collision-imported.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/44f4a87d7047db0deff5ef033fd2af820722e9a5/src%2Ftest%2Fui%2Frust-2021%2Ffuture-prelude-collision-imported.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2021%2Ffuture-prelude-collision-imported.stderr?ref=44f4a87d7047db0deff5ef033fd2af820722e9a5", "patch": "@@ -0,0 +1,34 @@\n+warning: trait method `try_into` will become ambiguous in Rust 2021\n+  --> $DIR/future-prelude-collision-imported.rs:27:22\n+   |\n+LL |         let _: u32 = 3u8.try_into().unwrap();\n+   |                      ^^^^^^^^^^^^^^ help: disambiguate the associated function: `TryIntoU32::try_into(3u8)`\n+   |\n+note: the lint level is defined here\n+  --> $DIR/future-prelude-collision-imported.rs:4:9\n+   |\n+LL | #![warn(future_prelude_collision)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in the 2021 edition!\n+   = note: for more information, see issue #85684 <https://github.com/rust-lang/rust/issues/85684>\n+\n+warning: trait method `try_into` will become ambiguous in Rust 2021\n+  --> $DIR/future-prelude-collision-imported.rs:40:22\n+   |\n+LL |         let _: u32 = 3u8.try_into().unwrap();\n+   |                      ^^^^^^^^^^^^^^ help: disambiguate the associated function: `crate::m::TryIntoU32::try_into(3u8)`\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in the 2021 edition!\n+   = note: for more information, see issue #85684 <https://github.com/rust-lang/rust/issues/85684>\n+\n+warning: trait method `try_into` will become ambiguous in Rust 2021\n+  --> $DIR/future-prelude-collision-imported.rs:53:22\n+   |\n+LL |         let _: u32 = 3u8.try_into().unwrap();\n+   |                      ^^^^^^^^^^^^^^ help: disambiguate the associated function: `super::m::TryIntoU32::try_into(3u8)`\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in the 2021 edition!\n+   = note: for more information, see issue #85684 <https://github.com/rust-lang/rust/issues/85684>\n+\n+warning: 3 warnings emitted\n+"}, {"sha": "c9d2529341f4f1a0eae784cf3714584dd22bc9d6", "filename": "src/test/ui/rust-2021/future-prelude-collision-shadow.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/44f4a87d7047db0deff5ef033fd2af820722e9a5/src%2Ftest%2Fui%2Frust-2021%2Ffuture-prelude-collision-shadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44f4a87d7047db0deff5ef033fd2af820722e9a5/src%2Ftest%2Fui%2Frust-2021%2Ffuture-prelude-collision-shadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2021%2Ffuture-prelude-collision-shadow.rs?ref=44f4a87d7047db0deff5ef033fd2af820722e9a5", "patch": "@@ -0,0 +1,32 @@\n+// edition:2018\n+#![warn(future_prelude_collision)]\n+#![allow(dead_code)]\n+#![allow(unused_imports)]\n+\n+mod m {\n+    pub trait TryIntoU32 {\n+        fn try_into(self) -> Result<u32, ()>;\n+    }\n+\n+    impl TryIntoU32 for u8 {\n+        fn try_into(self) -> Result<u32, ()> {\n+            Ok(self as u32)\n+        }\n+    }\n+\n+    pub trait AnotherTrick {}\n+}\n+\n+mod d {\n+    use crate::m::AnotherTrick as TryIntoU32;\n+    use crate::m::*;\n+\n+    fn main() {\n+        // Here, `TryIntoU32` is imported but shadowed, but in that case we don't permit its methods\n+        // to be available.\n+        let _: u32 = 3u8.try_into().unwrap();\n+        //~^ ERROR no method named `try_into` found for type `u8` in the current scope\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "ad9b8af00e467b5173d083e73968f6ea8d2f5b11", "filename": "src/test/ui/rust-2021/future-prelude-collision-shadow.stderr", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/44f4a87d7047db0deff5ef033fd2af820722e9a5/src%2Ftest%2Fui%2Frust-2021%2Ffuture-prelude-collision-shadow.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/44f4a87d7047db0deff5ef033fd2af820722e9a5/src%2Ftest%2Fui%2Frust-2021%2Ffuture-prelude-collision-shadow.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2021%2Ffuture-prelude-collision-shadow.stderr?ref=44f4a87d7047db0deff5ef033fd2af820722e9a5", "patch": "@@ -0,0 +1,40 @@\n+error[E0599]: no method named `try_into` found for type `u8` in the current scope\n+  --> $DIR/future-prelude-collision-shadow.rs:27:26\n+   |\n+LL |         let _: u32 = 3u8.try_into().unwrap();\n+   |                          ^^^^^^^^ method not found in `u8`\n+   | \n+  ::: $SRC_DIR/core/src/convert/mod.rs:LL:COL\n+   |\n+LL |     fn try_into(self) -> Result<T, Self::Error>;\n+   |        --------\n+   |        |\n+   |        the method is available for `Box<u8>` here\n+   |        the method is available for `Pin<u8>` here\n+   |        the method is available for `Arc<u8>` here\n+   |        the method is available for `Rc<u8>` here\n+   |\n+   = help: items from traits can only be used if the trait is in scope\n+   = note: the following traits are implemented but not in scope; perhaps add a `use` for one of them:\n+           candidate #1: `use crate::m::TryIntoU32;`\n+           candidate #2: `use std::convert::TryInto;`\n+help: consider wrapping the receiver expression with the appropriate type\n+   |\n+LL |         let _: u32 = Box::new(3u8).try_into().unwrap();\n+   |                      ^^^^^^^^^   ^\n+help: consider wrapping the receiver expression with the appropriate type\n+   |\n+LL |         let _: u32 = Pin::new(3u8).try_into().unwrap();\n+   |                      ^^^^^^^^^   ^\n+help: consider wrapping the receiver expression with the appropriate type\n+   |\n+LL |         let _: u32 = Arc::new(3u8).try_into().unwrap();\n+   |                      ^^^^^^^^^   ^\n+help: consider wrapping the receiver expression with the appropriate type\n+   |\n+LL |         let _: u32 = Rc::new(3u8).try_into().unwrap();\n+   |                      ^^^^^^^^   ^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0599`."}, {"sha": "9ede9f3a2fb45e39c6da382be6d8ef00fe6918e9", "filename": "src/test/ui/rust-2021/future-prelude-collision.fixed", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/44f4a87d7047db0deff5ef033fd2af820722e9a5/src%2Ftest%2Fui%2Frust-2021%2Ffuture-prelude-collision.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/44f4a87d7047db0deff5ef033fd2af820722e9a5/src%2Ftest%2Fui%2Frust-2021%2Ffuture-prelude-collision.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2021%2Ffuture-prelude-collision.fixed?ref=44f4a87d7047db0deff5ef033fd2af820722e9a5", "patch": "@@ -0,0 +1,96 @@\n+// run-rustfix\n+// edition:2018\n+// check-pass\n+#![warn(future_prelude_collision)]\n+\n+trait TryIntoU32 {\n+    fn try_into(self) -> Result<u32, ()>;\n+}\n+\n+impl TryIntoU32 for u8 {\n+    fn try_into(self) -> Result<u32, ()> {\n+        Ok(self as u32)\n+    }\n+}\n+\n+// needed for autoref test\n+impl TryIntoU32 for &f32 {\n+    fn try_into(self) -> Result<u32, ()> {\n+        Ok(*self as u32)\n+    }\n+}\n+\n+trait TryFromU8: Sized {\n+    fn try_from(x: u8) -> Result<Self, ()>;\n+}\n+\n+impl TryFromU8 for u32 {\n+    fn try_from(x: u8) -> Result<Self, ()> {\n+        Ok(x as u32)\n+    }\n+}\n+\n+impl TryIntoU32 for *const u16 {\n+    fn try_into(self) -> Result<u32, ()> {\n+        Ok(unsafe { *self } as u32)\n+    }\n+}\n+\n+trait FromByteIterator {\n+    fn from_iter<T>(iter: T) -> Self\n+        where T: Iterator<Item = u8>;\n+}\n+\n+impl FromByteIterator for Vec<u8> {\n+    fn from_iter<T>(iter: T) -> Self\n+        where T: Iterator<Item = u8>\n+    {\n+        iter.collect()\n+    }\n+}\n+\n+fn main() {\n+    // test dot-call that will break in 2021 edition\n+    let _: u32 = TryIntoU32::try_into(3u8).unwrap();\n+    //~^ WARNING trait method `try_into` will become ambiguous in Rust 2021\n+    //~^^ WARNING this was previously accepted by the compiler but is being phased out; it will become a hard error in the 2021 edition!\n+\n+    // test associated function call that will break in 2021 edition\n+    let _ = <u32 as TryFromU8>::try_from(3u8).unwrap();\n+    //~^ WARNING trait-associated function `try_from` will become ambiguous in Rust 2021\n+    //~^^ WARNING this was previously accepted by the compiler but is being phased out; it will become a hard error in the 2021 edition!\n+\n+    // test reverse turbofish too\n+    let _ = <Vec<u8> as FromByteIterator>::from_iter(vec![1u8, 2, 3, 4, 5, 6].into_iter());\n+    //~^ WARNING trait-associated function `from_iter` will become ambiguous in Rust 2021\n+    //~^^ WARNING this was previously accepted by the compiler but is being phased out; it will become a hard error in the 2021 edition!\n+\n+    // negative testing lint (this line should *not* emit a warning)\n+    let _: u32 = TryFromU8::try_from(3u8).unwrap();\n+\n+    // test type omission\n+    let _: u32 = <_ as TryFromU8>::try_from(3u8).unwrap();\n+    //~^ WARNING trait-associated function `try_from` will become ambiguous in Rust 2021\n+    //~^^ WARNING this was previously accepted by the compiler but is being phased out; it will become a hard error in the 2021 edition!\n+\n+    // test autoderef\n+    let _: u32 = TryIntoU32::try_into(*(&3u8)).unwrap();\n+    //~^ WARNING trait method `try_into` will become ambiguous in Rust 2021\n+    //~^^ WARNING this was previously accepted by the compiler but is being phased out; it will become a hard error in the 2021 edition!\n+\n+    // test autoref\n+    let _: u32 = TryIntoU32::try_into(&3.0).unwrap();\n+    //~^ WARNING trait method `try_into` will become ambiguous in Rust 2021\n+    //~^^ WARNING this was previously accepted by the compiler but is being phased out; it will become a hard error in the 2021 edition!\n+\n+    let mut data = 3u16;\n+    let mut_ptr = std::ptr::addr_of_mut!(data);\n+    let _: u32 = TryIntoU32::try_into(mut_ptr as *const _).unwrap();\n+    //~^ WARNING trait method `try_into` will become ambiguous in Rust 2021\n+    //~^^ WARNING this was previously accepted by the compiler but is being phased out; it will become a hard error in the 2021 edition!\n+\n+    type U32Alias = u32;\n+    let _ = <U32Alias as TryFromU8>::try_from(3u8).unwrap();\n+    //~^ WARNING trait-associated function `try_from` will become ambiguous in Rust 2021\n+    //~^^ WARNING this was previously accepted by the compiler but is being phased out; it will become a hard error in the 2021 edition!\n+}"}, {"sha": "914e910396a666921008e86e02ed48c6c8d335a9", "filename": "src/test/ui/rust-2021/future-prelude-collision.rs", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/44f4a87d7047db0deff5ef033fd2af820722e9a5/src%2Ftest%2Fui%2Frust-2021%2Ffuture-prelude-collision.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44f4a87d7047db0deff5ef033fd2af820722e9a5/src%2Ftest%2Fui%2Frust-2021%2Ffuture-prelude-collision.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2021%2Ffuture-prelude-collision.rs?ref=44f4a87d7047db0deff5ef033fd2af820722e9a5", "patch": "@@ -0,0 +1,96 @@\n+// run-rustfix\n+// edition:2018\n+// check-pass\n+#![warn(future_prelude_collision)]\n+\n+trait TryIntoU32 {\n+    fn try_into(self) -> Result<u32, ()>;\n+}\n+\n+impl TryIntoU32 for u8 {\n+    fn try_into(self) -> Result<u32, ()> {\n+        Ok(self as u32)\n+    }\n+}\n+\n+// needed for autoref test\n+impl TryIntoU32 for &f32 {\n+    fn try_into(self) -> Result<u32, ()> {\n+        Ok(*self as u32)\n+    }\n+}\n+\n+trait TryFromU8: Sized {\n+    fn try_from(x: u8) -> Result<Self, ()>;\n+}\n+\n+impl TryFromU8 for u32 {\n+    fn try_from(x: u8) -> Result<Self, ()> {\n+        Ok(x as u32)\n+    }\n+}\n+\n+impl TryIntoU32 for *const u16 {\n+    fn try_into(self) -> Result<u32, ()> {\n+        Ok(unsafe { *self } as u32)\n+    }\n+}\n+\n+trait FromByteIterator {\n+    fn from_iter<T>(iter: T) -> Self\n+        where T: Iterator<Item = u8>;\n+}\n+\n+impl FromByteIterator for Vec<u8> {\n+    fn from_iter<T>(iter: T) -> Self\n+        where T: Iterator<Item = u8>\n+    {\n+        iter.collect()\n+    }\n+}\n+\n+fn main() {\n+    // test dot-call that will break in 2021 edition\n+    let _: u32 = 3u8.try_into().unwrap();\n+    //~^ WARNING trait method `try_into` will become ambiguous in Rust 2021\n+    //~^^ WARNING this was previously accepted by the compiler but is being phased out; it will become a hard error in the 2021 edition!\n+\n+    // test associated function call that will break in 2021 edition\n+    let _ = u32::try_from(3u8).unwrap();\n+    //~^ WARNING trait-associated function `try_from` will become ambiguous in Rust 2021\n+    //~^^ WARNING this was previously accepted by the compiler but is being phased out; it will become a hard error in the 2021 edition!\n+\n+    // test reverse turbofish too\n+    let _ = <Vec<u8>>::from_iter(vec![1u8, 2, 3, 4, 5, 6].into_iter());\n+    //~^ WARNING trait-associated function `from_iter` will become ambiguous in Rust 2021\n+    //~^^ WARNING this was previously accepted by the compiler but is being phased out; it will become a hard error in the 2021 edition!\n+\n+    // negative testing lint (this line should *not* emit a warning)\n+    let _: u32 = TryFromU8::try_from(3u8).unwrap();\n+\n+    // test type omission\n+    let _: u32 = <_>::try_from(3u8).unwrap();\n+    //~^ WARNING trait-associated function `try_from` will become ambiguous in Rust 2021\n+    //~^^ WARNING this was previously accepted by the compiler but is being phased out; it will become a hard error in the 2021 edition!\n+\n+    // test autoderef\n+    let _: u32 = (&3u8).try_into().unwrap();\n+    //~^ WARNING trait method `try_into` will become ambiguous in Rust 2021\n+    //~^^ WARNING this was previously accepted by the compiler but is being phased out; it will become a hard error in the 2021 edition!\n+\n+    // test autoref\n+    let _: u32 = 3.0.try_into().unwrap();\n+    //~^ WARNING trait method `try_into` will become ambiguous in Rust 2021\n+    //~^^ WARNING this was previously accepted by the compiler but is being phased out; it will become a hard error in the 2021 edition!\n+\n+    let mut data = 3u16;\n+    let mut_ptr = std::ptr::addr_of_mut!(data);\n+    let _: u32 = mut_ptr.try_into().unwrap();\n+    //~^ WARNING trait method `try_into` will become ambiguous in Rust 2021\n+    //~^^ WARNING this was previously accepted by the compiler but is being phased out; it will become a hard error in the 2021 edition!\n+\n+    type U32Alias = u32;\n+    let _ = U32Alias::try_from(3u8).unwrap();\n+    //~^ WARNING trait-associated function `try_from` will become ambiguous in Rust 2021\n+    //~^^ WARNING this was previously accepted by the compiler but is being phased out; it will become a hard error in the 2021 edition!\n+}"}, {"sha": "190145ef4dbfcd637134584c5ca807f348274a6f", "filename": "src/test/ui/rust-2021/future-prelude-collision.stderr", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/44f4a87d7047db0deff5ef033fd2af820722e9a5/src%2Ftest%2Fui%2Frust-2021%2Ffuture-prelude-collision.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/44f4a87d7047db0deff5ef033fd2af820722e9a5/src%2Ftest%2Fui%2Frust-2021%2Ffuture-prelude-collision.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2021%2Ffuture-prelude-collision.stderr?ref=44f4a87d7047db0deff5ef033fd2af820722e9a5", "patch": "@@ -0,0 +1,79 @@\n+warning: trait method `try_into` will become ambiguous in Rust 2021\n+  --> $DIR/future-prelude-collision.rs:54:18\n+   |\n+LL |     let _: u32 = 3u8.try_into().unwrap();\n+   |                  ^^^^^^^^^^^^^^ help: disambiguate the associated function: `TryIntoU32::try_into(3u8)`\n+   |\n+note: the lint level is defined here\n+  --> $DIR/future-prelude-collision.rs:4:9\n+   |\n+LL | #![warn(future_prelude_collision)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in the 2021 edition!\n+   = note: for more information, see issue #85684 <https://github.com/rust-lang/rust/issues/85684>\n+\n+warning: trait-associated function `try_from` will become ambiguous in Rust 2021\n+  --> $DIR/future-prelude-collision.rs:59:13\n+   |\n+LL |     let _ = u32::try_from(3u8).unwrap();\n+   |             ^^^^^^^^^^^^^ help: disambiguate the associated function: `<u32 as TryFromU8>::try_from`\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in the 2021 edition!\n+   = note: for more information, see issue #85684 <https://github.com/rust-lang/rust/issues/85684>\n+\n+warning: trait-associated function `from_iter` will become ambiguous in Rust 2021\n+  --> $DIR/future-prelude-collision.rs:64:13\n+   |\n+LL |     let _ = <Vec<u8>>::from_iter(vec![1u8, 2, 3, 4, 5, 6].into_iter());\n+   |             ^^^^^^^^^^^^^^^^^^^^ help: disambiguate the associated function: `<Vec<u8> as FromByteIterator>::from_iter`\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in the 2021 edition!\n+   = note: for more information, see issue #85684 <https://github.com/rust-lang/rust/issues/85684>\n+\n+warning: trait-associated function `try_from` will become ambiguous in Rust 2021\n+  --> $DIR/future-prelude-collision.rs:72:18\n+   |\n+LL |     let _: u32 = <_>::try_from(3u8).unwrap();\n+   |                  ^^^^^^^^^^^^^ help: disambiguate the associated function: `<_ as TryFromU8>::try_from`\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in the 2021 edition!\n+   = note: for more information, see issue #85684 <https://github.com/rust-lang/rust/issues/85684>\n+\n+warning: trait method `try_into` will become ambiguous in Rust 2021\n+  --> $DIR/future-prelude-collision.rs:77:18\n+   |\n+LL |     let _: u32 = (&3u8).try_into().unwrap();\n+   |                  ^^^^^^^^^^^^^^^^^ help: disambiguate the associated function: `TryIntoU32::try_into(*(&3u8))`\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in the 2021 edition!\n+   = note: for more information, see issue #85684 <https://github.com/rust-lang/rust/issues/85684>\n+\n+warning: trait method `try_into` will become ambiguous in Rust 2021\n+  --> $DIR/future-prelude-collision.rs:82:18\n+   |\n+LL |     let _: u32 = 3.0.try_into().unwrap();\n+   |                  ^^^^^^^^^^^^^^ help: disambiguate the associated function: `TryIntoU32::try_into(&3.0)`\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in the 2021 edition!\n+   = note: for more information, see issue #85684 <https://github.com/rust-lang/rust/issues/85684>\n+\n+warning: trait method `try_into` will become ambiguous in Rust 2021\n+  --> $DIR/future-prelude-collision.rs:88:18\n+   |\n+LL |     let _: u32 = mut_ptr.try_into().unwrap();\n+   |                  ^^^^^^^^^^^^^^^^^^ help: disambiguate the associated function: `TryIntoU32::try_into(mut_ptr as *const _)`\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in the 2021 edition!\n+   = note: for more information, see issue #85684 <https://github.com/rust-lang/rust/issues/85684>\n+\n+warning: trait-associated function `try_from` will become ambiguous in Rust 2021\n+  --> $DIR/future-prelude-collision.rs:93:13\n+   |\n+LL |     let _ = U32Alias::try_from(3u8).unwrap();\n+   |             ^^^^^^^^^^^^^^^^^^ help: disambiguate the associated function: `<U32Alias as TryFromU8>::try_from`\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in the 2021 edition!\n+   = note: for more information, see issue #85684 <https://github.com/rust-lang/rust/issues/85684>\n+\n+warning: 8 warnings emitted\n+"}, {"sha": "00fb128a981e1d564f9019e5aa509dc1e28be120", "filename": "src/test/ui/rust-2021/generic-type-collision.fixed", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/44f4a87d7047db0deff5ef033fd2af820722e9a5/src%2Ftest%2Fui%2Frust-2021%2Fgeneric-type-collision.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/44f4a87d7047db0deff5ef033fd2af820722e9a5/src%2Ftest%2Fui%2Frust-2021%2Fgeneric-type-collision.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2021%2Fgeneric-type-collision.fixed?ref=44f4a87d7047db0deff5ef033fd2af820722e9a5", "patch": "@@ -0,0 +1,18 @@\n+// check-pass\n+// run-rustfix\n+// edition 2018\n+#![warn(future_prelude_collision)]\n+\n+trait MyTrait<A> {\n+    fn from_iter(x: Option<A>);\n+}\n+\n+impl<T> MyTrait<()> for Vec<T> {\n+    fn from_iter(_: Option<()>) {}\n+}\n+\n+fn main() {\n+    <Vec<i32> as MyTrait<_>>::from_iter(None);\n+    //~^ WARNING trait-associated function `from_iter` will become ambiguous in Rust 2021\n+    //~^^ WARNING this was previously accepted by the compiler but is being phased out; it will become a hard error in the 2021 edition!\n+}"}, {"sha": "406fba4d2479b004ddc9045759f14866c8243eee", "filename": "src/test/ui/rust-2021/generic-type-collision.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/44f4a87d7047db0deff5ef033fd2af820722e9a5/src%2Ftest%2Fui%2Frust-2021%2Fgeneric-type-collision.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44f4a87d7047db0deff5ef033fd2af820722e9a5/src%2Ftest%2Fui%2Frust-2021%2Fgeneric-type-collision.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2021%2Fgeneric-type-collision.rs?ref=44f4a87d7047db0deff5ef033fd2af820722e9a5", "patch": "@@ -0,0 +1,18 @@\n+// check-pass\n+// run-rustfix\n+// edition 2018\n+#![warn(future_prelude_collision)]\n+\n+trait MyTrait<A> {\n+    fn from_iter(x: Option<A>);\n+}\n+\n+impl<T> MyTrait<()> for Vec<T> {\n+    fn from_iter(_: Option<()>) {}\n+}\n+\n+fn main() {\n+    <Vec<i32>>::from_iter(None);\n+    //~^ WARNING trait-associated function `from_iter` will become ambiguous in Rust 2021\n+    //~^^ WARNING this was previously accepted by the compiler but is being phased out; it will become a hard error in the 2021 edition!\n+}"}, {"sha": "9374379d24763d58d25fb307f10f4022828c690d", "filename": "src/test/ui/rust-2021/generic-type-collision.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/44f4a87d7047db0deff5ef033fd2af820722e9a5/src%2Ftest%2Fui%2Frust-2021%2Fgeneric-type-collision.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/44f4a87d7047db0deff5ef033fd2af820722e9a5/src%2Ftest%2Fui%2Frust-2021%2Fgeneric-type-collision.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2021%2Fgeneric-type-collision.stderr?ref=44f4a87d7047db0deff5ef033fd2af820722e9a5", "patch": "@@ -0,0 +1,16 @@\n+warning: trait-associated function `from_iter` will become ambiguous in Rust 2021\n+  --> $DIR/generic-type-collision.rs:15:5\n+   |\n+LL |     <Vec<i32>>::from_iter(None);\n+   |     ^^^^^^^^^^^^^^^^^^^^^ help: disambiguate the associated function: `<Vec<i32> as MyTrait<_>>::from_iter`\n+   |\n+note: the lint level is defined here\n+  --> $DIR/generic-type-collision.rs:4:9\n+   |\n+LL | #![warn(future_prelude_collision)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in the 2021 edition!\n+   = note: for more information, see issue #85684 <https://github.com/rust-lang/rust/issues/85684>\n+\n+warning: 1 warning emitted\n+"}, {"sha": "cbb6e9659dff31a7bf00d059c58b8cc0e40d7e54", "filename": "src/test/ui/rust-2021/inherent-dyn-collision.fixed", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/44f4a87d7047db0deff5ef033fd2af820722e9a5/src%2Ftest%2Fui%2Frust-2021%2Finherent-dyn-collision.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/44f4a87d7047db0deff5ef033fd2af820722e9a5/src%2Ftest%2Fui%2Frust-2021%2Finherent-dyn-collision.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2021%2Finherent-dyn-collision.fixed?ref=44f4a87d7047db0deff5ef033fd2af820722e9a5", "patch": "@@ -0,0 +1,53 @@\n+// Test case where the method we want is an inherent method on a\n+// dyn Trait. In that case, the fix is to insert `*` on the receiver.\n+//\n+// check-pass\n+// run-rustfix\n+// edition:2018\n+\n+#![warn(future_prelude_collision)]\n+\n+trait TryIntoU32 {\n+    fn try_into(&self) -> Result<u32, ()>;\n+}\n+\n+impl TryIntoU32 for u8 {\n+    // note: &self\n+    fn try_into(&self) -> Result<u32, ()> {\n+        Ok(22)\n+    }\n+}\n+\n+mod inner {\n+    use super::get_dyn_trait;\n+\n+    // note: this does nothing, but is copying from ffishim's problem of\n+    // having a struct of the same name as the trait in-scope, while *also*\n+    // implementing the trait for that struct but **without** importing the\n+    // trait itself into scope\n+    struct TryIntoU32;\n+\n+    impl super::TryIntoU32 for TryIntoU32 {\n+        fn try_into(&self) -> Result<u32, ()> {\n+            Ok(0)\n+        }\n+    }\n+\n+    // this is where the gross part happens. since `get_dyn_trait` returns\n+    // a Box<dyn Trait>, it can still call the method for `dyn Trait` without\n+    // `Trait` being in-scope. it might even be possible to make the trait itself\n+    // entirely unreference-able from the callsite?\n+    pub fn test() -> u32 {\n+        (&*get_dyn_trait()).try_into().unwrap()\n+        //~^ WARNING trait method `try_into` will become ambiguous\n+        //~| WARNING this was previously accepted\n+    }\n+}\n+\n+fn get_dyn_trait() -> Box<dyn TryIntoU32> {\n+    Box::new(3u8) as Box<dyn TryIntoU32>\n+}\n+\n+fn main() {\n+    dbg!(inner::test());\n+}"}, {"sha": "1c9929eff91deffc45c1635497c7908e114f5750", "filename": "src/test/ui/rust-2021/inherent-dyn-collision.rs", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/44f4a87d7047db0deff5ef033fd2af820722e9a5/src%2Ftest%2Fui%2Frust-2021%2Finherent-dyn-collision.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44f4a87d7047db0deff5ef033fd2af820722e9a5/src%2Ftest%2Fui%2Frust-2021%2Finherent-dyn-collision.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2021%2Finherent-dyn-collision.rs?ref=44f4a87d7047db0deff5ef033fd2af820722e9a5", "patch": "@@ -0,0 +1,53 @@\n+// Test case where the method we want is an inherent method on a\n+// dyn Trait. In that case, the fix is to insert `*` on the receiver.\n+//\n+// check-pass\n+// run-rustfix\n+// edition:2018\n+\n+#![warn(future_prelude_collision)]\n+\n+trait TryIntoU32 {\n+    fn try_into(&self) -> Result<u32, ()>;\n+}\n+\n+impl TryIntoU32 for u8 {\n+    // note: &self\n+    fn try_into(&self) -> Result<u32, ()> {\n+        Ok(22)\n+    }\n+}\n+\n+mod inner {\n+    use super::get_dyn_trait;\n+\n+    // note: this does nothing, but is copying from ffishim's problem of\n+    // having a struct of the same name as the trait in-scope, while *also*\n+    // implementing the trait for that struct but **without** importing the\n+    // trait itself into scope\n+    struct TryIntoU32;\n+\n+    impl super::TryIntoU32 for TryIntoU32 {\n+        fn try_into(&self) -> Result<u32, ()> {\n+            Ok(0)\n+        }\n+    }\n+\n+    // this is where the gross part happens. since `get_dyn_trait` returns\n+    // a Box<dyn Trait>, it can still call the method for `dyn Trait` without\n+    // `Trait` being in-scope. it might even be possible to make the trait itself\n+    // entirely unreference-able from the callsite?\n+    pub fn test() -> u32 {\n+        get_dyn_trait().try_into().unwrap()\n+        //~^ WARNING trait method `try_into` will become ambiguous\n+        //~| WARNING this was previously accepted\n+    }\n+}\n+\n+fn get_dyn_trait() -> Box<dyn TryIntoU32> {\n+    Box::new(3u8) as Box<dyn TryIntoU32>\n+}\n+\n+fn main() {\n+    dbg!(inner::test());\n+}"}, {"sha": "3d7637100c2c962853377dbe9ffcca3e5cf855f0", "filename": "src/test/ui/rust-2021/inherent-dyn-collision.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/44f4a87d7047db0deff5ef033fd2af820722e9a5/src%2Ftest%2Fui%2Frust-2021%2Finherent-dyn-collision.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/44f4a87d7047db0deff5ef033fd2af820722e9a5/src%2Ftest%2Fui%2Frust-2021%2Finherent-dyn-collision.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2021%2Finherent-dyn-collision.stderr?ref=44f4a87d7047db0deff5ef033fd2af820722e9a5", "patch": "@@ -0,0 +1,16 @@\n+warning: trait method `try_into` will become ambiguous in Rust 2021\n+  --> $DIR/inherent-dyn-collision.rs:41:9\n+   |\n+LL |         get_dyn_trait().try_into().unwrap()\n+   |         ^^^^^^^^^^^^^^^ help: disambiguate the method call: `(&*get_dyn_trait())`\n+   |\n+note: the lint level is defined here\n+  --> $DIR/inherent-dyn-collision.rs:8:9\n+   |\n+LL | #![warn(future_prelude_collision)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in the 2021 edition!\n+   = note: for more information, see issue #85684 <https://github.com/rust-lang/rust/issues/85684>\n+\n+warning: 1 warning emitted\n+"}, {"sha": "c638351d5fc09bf9a93e999402cc5da6d165a02f", "filename": "src/test/ui/rust-2021/inherent-method-collision.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/44f4a87d7047db0deff5ef033fd2af820722e9a5/src%2Ftest%2Fui%2Frust-2021%2Finherent-method-collision.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44f4a87d7047db0deff5ef033fd2af820722e9a5/src%2Ftest%2Fui%2Frust-2021%2Finherent-method-collision.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2021%2Finherent-method-collision.rs?ref=44f4a87d7047db0deff5ef033fd2af820722e9a5", "patch": "@@ -0,0 +1,15 @@\n+// Test that we do NOT warn for inherent methods invoked via `T::` form.\n+//\n+// check-pass\n+\n+#![deny(future_prelude_collision)]\n+\n+pub struct MySeq {}\n+\n+impl MySeq {\n+    pub fn from_iter(_: impl IntoIterator<Item = u32>) {}\n+}\n+\n+fn main() {\n+    MySeq::from_iter(Some(22));\n+}"}]}