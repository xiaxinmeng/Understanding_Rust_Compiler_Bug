{"sha": "1c4510adc81bd7623bc2993b42ee7d87320f1f2b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFjNDUxMGFkYzgxYmQ3NjIzYmMyOTkzYjQyZWU3ZDg3MzIwZjFmMmI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-09-26T09:19:03Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-09-26T09:19:03Z"}, "message": "Auto merge of #44736 - pnkfelix:mir-borrowck4, r=arielb1\n\nSome fixes to mir-borrowck\n\nMake the code more closely match the NLL RFC (updated description).\n\n(The biggest visible fix the addition of the Shallow/Deep distinction, which means mir-borrowck stops falsely thinking that StorageDeads need deep access to their input L-value.)", "tree": {"sha": "b6db144ed54054104a3a1a7c7c23ccd62c82886a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b6db144ed54054104a3a1a7c7c23ccd62c82886a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1c4510adc81bd7623bc2993b42ee7d87320f1f2b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1c4510adc81bd7623bc2993b42ee7d87320f1f2b", "html_url": "https://github.com/rust-lang/rust/commit/1c4510adc81bd7623bc2993b42ee7d87320f1f2b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1c4510adc81bd7623bc2993b42ee7d87320f1f2b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4b8bf391fd595ac0c1ff6e6b7f1ef57cec4eb6da", "url": "https://api.github.com/repos/rust-lang/rust/commits/4b8bf391fd595ac0c1ff6e6b7f1ef57cec4eb6da", "html_url": "https://github.com/rust-lang/rust/commit/4b8bf391fd595ac0c1ff6e6b7f1ef57cec4eb6da"}, {"sha": "e319f4093c6f2e67f68a29a7eb2eda9bcbb96aa5", "url": "https://api.github.com/repos/rust-lang/rust/commits/e319f4093c6f2e67f68a29a7eb2eda9bcbb96aa5", "html_url": "https://github.com/rust-lang/rust/commit/e319f4093c6f2e67f68a29a7eb2eda9bcbb96aa5"}], "stats": {"total": 658, "additions": 317, "deletions": 341}, "files": [{"sha": "9e261d60248917ced17645bdabe13363e3048696", "filename": "src/librustc_mir/borrow_check.rs", "status": "modified", "additions": 317, "deletions": 341, "changes": 658, "blob_url": "https://github.com/rust-lang/rust/blob/1c4510adc81bd7623bc2993b42ee7d87320f1f2b/src%2Flibrustc_mir%2Fborrow_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c4510adc81bd7623bc2993b42ee7d87320f1f2b/src%2Flibrustc_mir%2Fborrow_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check.rs?ref=1c4510adc81bd7623bc2993b42ee7d87320f1f2b", "patch": "@@ -173,14 +173,23 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> DataflowResultsConsumer<'b, 'gcx>\n         let span = stmt.source_info.span;\n         match stmt.kind {\n             StatementKind::Assign(ref lhs, ref rhs) => {\n+                // NOTE: NLL RFC calls for *shallow* write; using Deep\n+                // for short-term compat w/ AST-borrowck. Also, switch\n+                // to shallow requires to dataflow: \"if this is an\n+                // assignment `lv = <rvalue>`, then any loan for some\n+                // path P of which `lv` is a prefix is killed.\"\n                 self.mutate_lvalue(ContextKind::AssignLhs.new(location),\n-                                   (lhs, span), JustWrite, flow_state);\n+                                   (lhs, span), Deep, JustWrite, flow_state);\n+\n                 self.consume_rvalue(ContextKind::AssignRhs.new(location),\n                                     (rhs, span), location, flow_state);\n             }\n             StatementKind::SetDiscriminant { ref lvalue, variant_index: _ } => {\n                 self.mutate_lvalue(ContextKind::SetDiscrim.new(location),\n-                                   (lvalue, span), JustWrite, flow_state);\n+                                   (lvalue, span),\n+                                   Shallow(Some(ArtificialField::Discriminant)),\n+                                   JustWrite,\n+                                   flow_state);\n             }\n             StatementKind::InlineAsm { ref asm, ref outputs, ref inputs } => {\n                 for (o, output) in asm.outputs.iter().zip(outputs) {\n@@ -192,6 +201,7 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> DataflowResultsConsumer<'b, 'gcx>\n                     } else {\n                         self.mutate_lvalue(ContextKind::InlineAsm.new(location),\n                                            (output, span),\n+                                           Deep,\n                                            if o.is_rw { WriteAndRead } else { JustWrite },\n                                            flow_state);\n                     }\n@@ -209,15 +219,15 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> DataflowResultsConsumer<'b, 'gcx>\n             StatementKind::Nop |\n             StatementKind::Validate(..) |\n             StatementKind::StorageLive(..) => {\n-                // ignored by borrowck\n+                // `Nop`, `Validate`, and `StorageLive` are irrelevant\n+                // to borrow check.\n             }\n \n             StatementKind::StorageDead(local) => {\n-                // causes non-drop values to be dropped.\n-                self.consume_lvalue(ContextKind::StorageDead.new(location),\n-                                    ConsumeKind::Consume,\n-                                    (&Lvalue::Local(local), span),\n-                                    flow_state)\n+                self.access_lvalue(ContextKind::StorageDead.new(location),\n+                                   (&Lvalue::Local(local), span),\n+                                   (Shallow(None), Write(WriteKind::StorageDead)),\n+                                   flow_state);\n             }\n         }\n     }\n@@ -246,7 +256,10 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> DataflowResultsConsumer<'b, 'gcx>\n                                              target: _,\n                                              unwind: _ } => {\n                 self.mutate_lvalue(ContextKind::DropAndReplace.new(loc),\n-                                   (drop_lvalue, span), JustWrite, flow_state);\n+                                   (drop_lvalue, span),\n+                                   Deep,\n+                                   JustWrite,\n+                                   flow_state);\n                 self.consume_operand(ContextKind::DropAndReplace.new(loc),\n                                      ConsumeKind::Drop,\n                                      (new_value, span), flow_state);\n@@ -262,7 +275,10 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> DataflowResultsConsumer<'b, 'gcx>\n                 }\n                 if let Some((ref dest, _/*bb*/)) = *destination {\n                     self.mutate_lvalue(ContextKind::CallDest.new(loc),\n-                                       (dest, span), JustWrite, flow_state);\n+                                       (dest, span),\n+                                       Deep,\n+                                       JustWrite,\n+                                       flow_state);\n                 }\n             }\n             TerminatorKind::Assert { ref cond, expected: _, ref msg, target: _, cleanup: _ } => {\n@@ -309,29 +325,121 @@ enum ConsumeKind { Drop, Consume }\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n enum Control { Continue, Break }\n \n+use self::ShallowOrDeep::{Shallow, Deep};\n+use self::ReadOrWrite::{Read, Write};\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+enum ArtificialField {\n+    Discriminant,\n+    ArrayLength,\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+enum ShallowOrDeep {\n+    /// From the RFC: \"A *shallow* access means that the immediate\n+    /// fields reached at LV are accessed, but references or pointers\n+    /// found within are not dereferenced. Right now, the only access\n+    /// that is shallow is an assignment like `x = ...;`, which would\n+    /// be a *shallow write* of `x`.\"\n+    Shallow(Option<ArtificialField>),\n+\n+    /// From the RFC: \"A *deep* access means that all data reachable\n+    /// through the given lvalue may be invalidated or accesses by\n+    /// this action.\"\n+    Deep,\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+enum ReadOrWrite {\n+    /// From the RFC: \"A *read* means that the existing data may be\n+    /// read, but will not be changed.\"\n+    Read(ReadKind),\n+\n+    /// From the RFC: \"A *write* means that the data may be mutated to\n+    /// new values or otherwise invalidated (for example, it could be\n+    /// de-initialized, as in a move operation).\n+    Write(WriteKind),\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+enum ReadKind {\n+    Borrow(BorrowKind),\n+    Copy,\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+enum WriteKind {\n+    StorageDead,\n+    MutableBorrow(BorrowKind),\n+    Mutate,\n+    Move,\n+}\n+\n impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx> {\n+    fn access_lvalue(&mut self,\n+                     context: Context,\n+                     lvalue_span: (&Lvalue<'gcx>, Span),\n+                     kind: (ShallowOrDeep, ReadOrWrite),\n+                     flow_state: &InProgress<'b, 'gcx>) {\n+        // FIXME: also need to check permissions (e.g. reject mut\n+        // borrow of immutable ref, moves through non-`Box`-ref)\n+        let (sd, rw) = kind;\n+        self.each_borrow_involving_path(\n+            context, (sd, lvalue_span.0), flow_state, |this, _index, borrow| {\n+                match (rw, borrow.kind) {\n+                    (Read(_), BorrowKind::Shared) => {\n+                        Control::Continue\n+                    }\n+                    (Read(kind), BorrowKind::Unique) |\n+                    (Read(kind), BorrowKind::Mut) => {\n+                        match kind {\n+                            ReadKind::Copy =>\n+                                this.report_use_while_mutably_borrowed(\n+                                    context, lvalue_span, borrow),\n+                            ReadKind::Borrow(bk) =>\n+                                this.report_conflicting_borrow(\n+                                    context, lvalue_span,\n+                                    (lvalue_span.0, bk), (&borrow.lvalue, borrow.kind)),\n+                        }\n+                        Control::Break\n+                    }\n+                    (Write(kind), _) => {\n+                        match kind {\n+                            WriteKind::MutableBorrow(bk) =>\n+                                this.report_conflicting_borrow(\n+                                    context, lvalue_span,\n+                                    (lvalue_span.0, bk), (&borrow.lvalue, borrow.kind)),\n+                            WriteKind::StorageDead |\n+                            WriteKind::Mutate =>\n+                                this.report_illegal_mutation_of_borrowed(\n+                                    context, lvalue_span),\n+                            WriteKind::Move =>\n+                                this.report_move_out_while_borrowed(\n+                                    context, lvalue_span, borrow),\n+                        }\n+                        Control::Break\n+                    }\n+                }\n+            });\n+    }\n+\n     fn mutate_lvalue(&mut self,\n                      context: Context,\n                      lvalue_span: (&Lvalue<'gcx>, Span),\n+                     kind: ShallowOrDeep,\n                      mode: MutateMode,\n                      flow_state: &InProgress<'b, 'gcx>) {\n         // Write of P[i] or *P, or WriteAndRead of any P, requires P init'd.\n         match mode {\n             MutateMode::WriteAndRead => {\n-                self.check_if_path_is_moved(context, lvalue_span, flow_state);\n+                self.check_if_path_is_moved(context, \"update\", lvalue_span, flow_state);\n             }\n             MutateMode::JustWrite => {\n                 self.check_if_assigned_path_is_moved(context, lvalue_span, flow_state);\n             }\n         }\n \n-        // check we don't invalidate any outstanding loans\n-        self.each_borrow_involving_path(context,\n-                                        lvalue_span.0, flow_state, |this, _index, _data| {\n-                                            this.report_illegal_mutation_of_borrowed(context,\n-                                                                                     lvalue_span);\n-                                            Control::Break\n-                                        });\n+        self.access_lvalue(context, lvalue_span, (kind, Write(WriteKind::Mutate)), flow_state);\n \n         // check for reassignments to immutable local variables\n         self.check_if_reassignment_to_immutable_state(context, lvalue_span, flow_state);\n@@ -340,11 +448,17 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n     fn consume_rvalue(&mut self,\n                       context: Context,\n                       (rvalue, span): (&Rvalue<'gcx>, Span),\n-                      location: Location,\n+                      _location: Location,\n                       flow_state: &InProgress<'b, 'gcx>) {\n         match *rvalue {\n             Rvalue::Ref(_/*rgn*/, bk, ref lvalue) => {\n-                self.borrow(context, location, bk, (lvalue, span), flow_state)\n+                let access_kind = match bk {\n+                    BorrowKind::Shared => (Deep, Read(ReadKind::Borrow(bk))),\n+                    BorrowKind::Unique |\n+                    BorrowKind::Mut => (Deep, Write(WriteKind::MutableBorrow(bk))),\n+                };\n+                self.access_lvalue(context, (lvalue, span), access_kind, flow_state);\n+                self.check_if_path_is_moved(context, \"borrow\", (lvalue, span), flow_state);\n             }\n \n             Rvalue::Use(ref operand) |\n@@ -356,8 +470,14 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n \n             Rvalue::Len(ref lvalue) |\n             Rvalue::Discriminant(ref lvalue) => {\n-                // len(_)/discriminant(_) merely read, not consume.\n-                self.check_if_path_is_moved(context, (lvalue, span), flow_state);\n+                let af = match *rvalue {\n+                    Rvalue::Len(..) => ArtificialField::ArrayLength,\n+                    Rvalue::Discriminant(..) => ArtificialField::Discriminant,\n+                    _ => unreachable!(),\n+                };\n+                self.access_lvalue(\n+                    context, (lvalue, span), (Shallow(Some(af)), Read(ReadKind::Copy)), flow_state);\n+                self.check_if_path_is_moved(context, \"use\", (lvalue, span), flow_state);\n             }\n \n             Rvalue::BinaryOp(_bin_op, ref operand1, ref operand2) |\n@@ -388,8 +508,9 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n                        (operand, span): (&Operand<'gcx>, Span),\n                        flow_state: &InProgress<'b, 'gcx>) {\n         match *operand {\n-            Operand::Consume(ref lvalue) =>\n-                self.consume_lvalue(context, consume_via_drop, (lvalue, span), flow_state),\n+            Operand::Consume(ref lvalue) => {\n+                self.consume_lvalue(context, consume_via_drop, (lvalue, span), flow_state)\n+            }\n             Operand::Constant(_) => {}\n         }\n     }\n@@ -405,26 +526,10 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n             self.fake_infer_ctxt.type_moves_by_default(self.param_env, ty, DUMMY_SP);\n         if moves_by_default {\n             // move of lvalue: check if this is move of already borrowed path\n-            self.each_borrow_involving_path(\n-                context, lvalue_span.0, flow_state, |this, _idx, borrow| {\n-                    if !borrow.compatible_with(BorrowKind::Mut) {\n-                        this.report_move_out_while_borrowed(context, lvalue_span, borrow);\n-                        Control::Break\n-                    } else {\n-                        Control::Continue\n-                    }\n-                });\n+            self.access_lvalue(context, lvalue_span, (Deep, Write(WriteKind::Move)), flow_state);\n         } else {\n             // copy of lvalue: check if this is \"copy of frozen path\" (FIXME: see check_loans.rs)\n-            self.each_borrow_involving_path(\n-                context, lvalue_span.0, flow_state, |this, _idx, borrow| {\n-                    if !borrow.compatible_with(BorrowKind::Shared) {\n-                        this.report_use_while_mutably_borrowed(context, lvalue_span, borrow);\n-                        Control::Break\n-                    } else {\n-                        Control::Continue\n-                    }\n-                });\n+            self.access_lvalue(context, lvalue_span, (Deep, Read(ReadKind::Copy)), flow_state);\n         }\n \n         // Finally, check if path was already moved.\n@@ -435,22 +540,10 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n                 // skip this check in that case).\n             }\n             ConsumeKind::Consume => {\n-                self.check_if_path_is_moved(context, lvalue_span, flow_state);\n+                self.check_if_path_is_moved(context, \"use\", lvalue_span, flow_state);\n             }\n         }\n     }\n-\n-    fn borrow(&mut self,\n-              context: Context,\n-              location: Location,\n-              bk: BorrowKind,\n-              lvalue_span: (&Lvalue<'gcx>, Span),\n-              flow_state: &InProgress<'b, 'gcx>) {\n-        debug!(\"borrow location: {:?} lvalue: {:?} span: {:?}\",\n-               location, lvalue_span.0, lvalue_span.1);\n-        self.check_if_path_is_moved(context, lvalue_span, flow_state);\n-        self.check_for_conflicting_loans(context, location, bk, lvalue_span, flow_state);\n-    }\n }\n \n impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx> {\n@@ -494,6 +587,7 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n \n     fn check_if_path_is_moved(&mut self,\n                               context: Context,\n+                              desired_action: &str,\n                               lvalue_span: (&Lvalue<'gcx>, Span),\n                               flow_state: &InProgress<'b, 'gcx>) {\n         // FIXME: analogous code in check_loans first maps `lvalue` to\n@@ -505,7 +599,7 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n         if let Some(mpi) = self.move_path_for_lvalue(context, move_data, lvalue) {\n             if maybe_uninits.curr_state.contains(&mpi) {\n                 // find and report move(s) that could cause this to be uninitialized\n-                self.report_use_of_moved(context, lvalue_span);\n+                self.report_use_of_moved(context, desired_action, lvalue_span);\n             } else {\n                 // sanity check: initialized on *some* path, right?\n                 assert!(flow_state.inits.curr_state.contains(&mpi));\n@@ -572,8 +666,8 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n                                     // check_loans.rs first maps\n                                     // `base` to its base_path.\n \n-                                    self.check_if_path_is_moved(context,\n-                                                                (base, span), flow_state);\n+                                    self.check_if_path_is_moved(\n+                                        context, \"assignment\", (base, span), flow_state);\n \n                                     // (base initialized; no need to\n                                     // recur further)\n@@ -590,72 +684,18 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n             }\n         }\n     }\n-\n-    fn check_for_conflicting_loans(&mut self,\n-                                   context: Context,\n-                                   _location: Location,\n-                                   _bk: BorrowKind,\n-                                   lvalue_span: (&Lvalue<'gcx>, Span),\n-                                   flow_state: &InProgress<'b, 'gcx>) {\n-        // NOTE FIXME: The analogous code in old borrowck\n-        // check_loans.rs is careful to iterate over every *issued*\n-        // loan, as opposed to just the in scope ones.\n-        //\n-        // (Or if you prefer, all the *other* iterations over loans\n-        // only consider loans that are in scope of some given\n-        // region::Scope)\n-        //\n-        // The (currently skeletal) code here does not encode such a\n-        // distinction, which means it is almost certainly over\n-        // looking something.\n-        //\n-        // (It is probably going to reject code that should be\n-        // accepted, I suspect, by treated issued-but-out-of-scope\n-        // loans as issued-and-in-scope, and thus causing them to\n-        // interfere with other loans.)\n-        //\n-        // However, I just want to get something running, especially\n-        // since I am trying to move into new territory with NLL, so\n-        // lets get this going first, and then address the issued vs\n-        // in-scope distinction later.\n-\n-        let state = &flow_state.borrows;\n-        let data = &state.base_results.operator().borrows();\n-\n-        debug!(\"check_for_conflicting_loans location: {:?}\", _location);\n-\n-        // does any loan generated here conflict with a previously issued loan?\n-        let mut loans_generated = 0;\n-        for (g, gen) in state.elems_generated().map(|g| (g, &data[g])) {\n-            loans_generated += 1;\n-            for (i, issued) in state.elems_incoming().map(|i| (i, &data[i])) {\n-                debug!(\"check_for_conflicting_loans gen: {:?} issued: {:?} conflicts: {}\",\n-                       (g, gen, self.base_path(&gen.lvalue),\n-                        self.restrictions(&gen.lvalue).collect::<Vec<_>>()),\n-                       (i, issued, self.base_path(&issued.lvalue),\n-                        self.restrictions(&issued.lvalue).collect::<Vec<_>>()),\n-                       self.conflicts_with(gen, issued));\n-                if self.conflicts_with(gen, issued) {\n-                    self.report_conflicting_borrow(context, lvalue_span, gen, issued);\n-                }\n-            }\n-        }\n-\n-        // MIR statically ensures each statement gens *at most one*\n-        // loan; mutual conflict (within a statement) can't arise.\n-        //\n-        // As safe-guard, assert that above property actually holds.\n-        assert!(loans_generated <= 1);\n-    } }\n+}\n \n impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx> {\n     fn each_borrow_involving_path<F>(&mut self,\n                                      _context: Context,\n-                                     lvalue: &Lvalue<'gcx>,\n+                                     access_lvalue: (ShallowOrDeep, &Lvalue<'gcx>),\n                                      flow_state: &InProgress<'b, 'gcx>,\n                                      mut op: F)\n         where F: FnMut(&mut Self, BorrowIndex, &BorrowData<'gcx>) -> Control\n     {\n+        let (access, lvalue) = access_lvalue;\n+\n         // FIXME: analogous code in check_loans first maps `lvalue` to\n         // its base_path.\n \n@@ -664,228 +704,182 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n \n         // check for loan restricting path P being used. Accounts for\n         // borrows of P, P.a.b, etc.\n-        for i in flow_state.borrows.elems_incoming() {\n-            // FIXME: check_loans.rs filtered this to \"in scope\"\n-            // loans; i.e. it took a scope S and checked that each\n-            // restriction's kill_scope was a superscope of S.\n+        'next_borrow: for i in flow_state.borrows.elems_incoming() {\n             let borrowed = &data[i];\n-            for restricted in self.restrictions(&borrowed.lvalue) {\n-                if restricted == lvalue {\n+\n+            // Is `lvalue` (or a prefix of it) already borrowed? If\n+            // so, that's relevant.\n+            //\n+            // FIXME: Differs from AST-borrowck; includes drive-by fix\n+            // to #38899. Will probably need back-compat mode flag.\n+            for accessed_prefix in self.prefixes(lvalue, PrefixSet::All) {\n+                if *accessed_prefix == borrowed.lvalue {\n+                    // FIXME: pass in prefix here too? And/or enum\n+                    // describing case we are in?\n                     let ctrl = op(self, i, borrowed);\n                     if ctrl == Control::Break { return; }\n                 }\n             }\n-        }\n \n-        // check for loans (not restrictions) on any base path.\n-        // e.g. Rejects `{ let x = &mut a.b; let y = a.b.c; }`,\n-        // since that moves out of borrowed path `a.b`.\n-        //\n-        // Limiting to loans (not restrictions) keeps this one\n-        // working: `{ let x = &mut a.b; let y = a.c; }`\n-        let mut cursor = lvalue;\n-        loop {\n-            // FIXME: check_loans.rs invoked `op` *before* cursor\n-            // shift here.  Might just work (and even avoid redundant\n-            // errors?) given code above?  But for now, I want to try\n-            // doing what I think is more \"natural\" check.\n-            for i in flow_state.borrows.elems_incoming() {\n-                let borrowed = &data[i];\n-                if borrowed.lvalue == *cursor {\n+            // Is `lvalue` a prefix (modulo access type) of the\n+            // `borrowed.lvalue`? If so, that's relevant.\n+\n+            let prefix_kind = match access {\n+                Shallow(Some(ArtificialField::Discriminant)) |\n+                Shallow(Some(ArtificialField::ArrayLength)) => {\n+                    // The discriminant and array length are like\n+                    // additional fields on the type; they do not\n+                    // overlap any existing data there. Furthermore,\n+                    // they cannot actually be a prefix of any\n+                    // borrowed lvalue (at least in MIR as it is\n+                    // currently.)\n+                    continue 'next_borrow;\n+                }\n+                Shallow(None) => PrefixSet::Shallow,\n+                Deep => PrefixSet::Supporting,\n+            };\n+\n+            for borrowed_prefix in self.prefixes(&borrowed.lvalue, prefix_kind) {\n+                if borrowed_prefix == lvalue {\n+                    // FIXME: pass in prefix here too? And/or enum\n+                    // describing case we are in?\n                     let ctrl = op(self, i, borrowed);\n                     if ctrl == Control::Break { return; }\n                 }\n             }\n-\n-            match *cursor {\n-                Lvalue::Local(_) | Lvalue::Static(_) => break,\n-                Lvalue::Projection(ref proj) => cursor = &proj.base,\n-            }\n         }\n     }\n }\n \n-mod restrictions {\n-    use super::MirBorrowckCtxt;\n+use self::prefixes::PrefixSet;\n+\n+/// From the NLL RFC: \"The deep [aka 'supporting'] prefixes for an\n+/// lvalue are formed by stripping away fields and derefs, except that\n+/// we stop when we reach the deref of a shared reference. [...] \"\n+///\n+/// \"Shallow prefixes are found by stripping away fields, but stop at\n+/// any dereference. So: writing a path like `a` is illegal if `a.b`\n+/// is borrowed. But: writing `a` is legal if `*a` is borrowed,\n+/// whether or not `a` is a shared or mutable reference. [...] \"\n+mod prefixes {\n+    use super::{MirBorrowckCtxt};\n \n     use rustc::hir;\n     use rustc::ty::{self, TyCtxt};\n     use rustc::mir::{Lvalue, Mir, ProjectionElem};\n \n-    pub(super) struct Restrictions<'c, 'tcx: 'c> {\n+    pub(super) struct Prefixes<'c, 'tcx: 'c> {\n         mir: &'c Mir<'tcx>,\n         tcx: TyCtxt<'c, 'tcx, 'tcx>,\n-        lvalue_stack: Vec<&'c Lvalue<'tcx>>,\n+        kind: PrefixSet,\n+        next: Option<&'c Lvalue<'tcx>>,\n+    }\n+\n+    #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+    pub(super) enum PrefixSet {\n+        All,\n+        Shallow,\n+        Supporting,\n     }\n \n     impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx> {\n-        pub(super) fn restrictions<'d>(&self,\n-                                       lvalue: &'d Lvalue<'gcx>)\n-                                       -> Restrictions<'d, 'gcx> where 'b: 'd\n+        pub(super) fn prefixes<'d>(&self,\n+                                   lvalue: &'d Lvalue<'gcx>,\n+                                   kind: PrefixSet)\n+                                   -> Prefixes<'d, 'gcx> where 'b: 'd\n         {\n-            let lvalue_stack = if self.has_restrictions(lvalue) { vec![lvalue] } else { vec![] };\n-            Restrictions { lvalue_stack: lvalue_stack, mir: self.mir, tcx: self.tcx }\n+            Prefixes { next: Some(lvalue), kind, mir: self.mir, tcx: self.tcx }\n         }\n+    }\n \n-        fn has_restrictions(&self, lvalue: &Lvalue<'gcx>) -> bool {\n-            let mut cursor = lvalue;\n-            loop {\n+    impl<'c, 'tcx> Iterator for Prefixes<'c, 'tcx> {\n+        type Item = &'c Lvalue<'tcx>;\n+        fn next(&mut self) -> Option<Self::Item> {\n+            let mut cursor = match self.next {\n+                None => return None,\n+                Some(lvalue) => lvalue,\n+            };\n+\n+            // Post-processing `lvalue`: Enqueue any remaining\n+            // work. Also, `lvalue` may not be a prefix itself, but\n+            // may hold one further down (e.g. we never return\n+            // downcasts here, but may return a base of a downcast).\n+\n+            'cursor: loop {\n                 let proj = match *cursor {\n-                    Lvalue::Local(_) => return true,\n-                    Lvalue::Static(_) => return false,\n+                    Lvalue::Local(_) | // search yielded this leaf\n+                    Lvalue::Static(_) => {\n+                        self.next = None;\n+                        return Some(cursor);\n+                    }\n+\n                     Lvalue::Projection(ref proj) => proj,\n                 };\n+\n                 match proj.elem {\n-                    ProjectionElem::Index(..) |\n-                    ProjectionElem::ConstantIndex { .. } |\n+                    ProjectionElem::Field(_/*field*/, _/*ty*/) => {\n+                        // FIXME: add union handling\n+                        self.next = Some(&proj.base);\n+                        return Some(cursor);\n+                    }\n                     ProjectionElem::Downcast(..) |\n                     ProjectionElem::Subslice { .. } |\n-                    ProjectionElem::Field(_/*field*/, _/*ty*/) => {\n+                    ProjectionElem::ConstantIndex { .. } |\n+                    ProjectionElem::Index(_) => {\n                         cursor = &proj.base;\n-                        continue;\n+                        continue 'cursor;\n                     }\n                     ProjectionElem::Deref => {\n-                        let ty = proj.base.ty(self.mir, self.tcx).to_ty(self.tcx);\n-                        match ty.sty {\n-                            ty::TyRawPtr(_) => {\n-                                return false;\n-                            }\n-                            ty::TyRef(_, ty::TypeAndMut { ty: _, mutbl: hir::MutImmutable }) => {\n-                                // FIXME: do I need to check validity of\n-                                // region here though? (I think the original\n-                                // check_loans code did, like readme says)\n-                                return false;\n-                            }\n-                            ty::TyRef(_, ty::TypeAndMut { ty: _, mutbl: hir::MutMutable }) => {\n-                                cursor = &proj.base;\n-                                continue;\n-                            }\n-                            ty::TyAdt(..) if ty.is_box() => {\n-                                cursor = &proj.base;\n-                                continue;\n-                            }\n-                            _ => {\n-                                panic!(\"unknown type fed to Projection Deref.\");\n-                            }\n-                        }\n+                        // (handled below)\n                     }\n                 }\n-            }\n-        }\n-    }\n \n-    impl<'c, 'tcx> Iterator for Restrictions<'c, 'tcx> {\n-        type Item = &'c Lvalue<'tcx>;\n-        fn next(&mut self) -> Option<Self::Item> {\n-            'pop: loop {\n-                let lvalue = match self.lvalue_stack.pop() {\n-                    None => return None,\n-                    Some(lvalue) => lvalue,\n-                };\n+                assert_eq!(proj.elem, ProjectionElem::Deref);\n \n-                // `lvalue` may not be a restriction itself, but may\n-                // hold one further down (e.g. we never return\n-                // downcasts here, but may return a base of a\n-                // downcast).\n-                //\n-                // Also, we need to enqueue any additional\n-                // subrestrictions that it implies, since we can only\n-                // return from from this call alone.\n-\n-                let mut cursor = lvalue;\n-                'cursor: loop {\n-                    let proj = match *cursor {\n-                        Lvalue::Local(_) => return Some(cursor), // search yielded this leaf\n-                        Lvalue::Static(_) => continue 'pop, // fruitless leaf; try next on stack\n-                        Lvalue::Projection(ref proj) => proj,\n-                    };\n-\n-                    match proj.elem {\n-                        ProjectionElem::Field(_/*field*/, _/*ty*/) => {\n-                            // FIXME: add union handling\n-                            self.lvalue_stack.push(&proj.base);\n-                            return Some(cursor);\n-                        }\n-                        ProjectionElem::Downcast(..) |\n-                        ProjectionElem::Subslice { .. } |\n-                        ProjectionElem::ConstantIndex { .. } |\n-                        ProjectionElem::Index(_) => {\n-                            cursor = &proj.base;\n-                            continue 'cursor;\n-                        }\n-                        ProjectionElem::Deref => {\n-                            // (handled below)\n-                        }\n+                match self.kind {\n+                    PrefixSet::Shallow => {\n+                        // shallow prefixes are found by stripping away\n+                        // fields, but stop at *any* dereference.\n+                        // So we can just stop the traversal now.\n+                        self.next = None;\n+                        return Some(cursor);\n                     }\n+                    PrefixSet::All => {\n+                        // all prefixes: just blindly enqueue the base\n+                        // of the projection\n+                        self.next = Some(&proj.base);\n+                        return Some(cursor);\n+                    }\n+                    PrefixSet::Supporting => {\n+                        // fall through!\n+                    }\n+                }\n \n-                    assert_eq!(proj.elem, ProjectionElem::Deref);\n-\n-                    let ty = proj.base.ty(self.mir, self.tcx).to_ty(self.tcx);\n-                    match ty.sty {\n-                        ty::TyRawPtr(_) => {\n-                            // borrowck ignores raw ptrs; treat analogous to imm borrow\n-                            continue 'pop;\n-                        }\n-                        // R-Deref-Imm-Borrowed\n-                        ty::TyRef(_/*rgn*/, ty::TypeAndMut { ty: _, mutbl: hir::MutImmutable }) => {\n-                            // immutably-borrowed referents do not\n-                            // have recursively-implied restrictions\n-                            // (because preventing actions on `*LV`\n-                            // does nothing about aliases like `*LV1`)\n-\n-                            // FIXME: do I need to check validity of\n-                            // `_r` here though? (I think the original\n-                            // check_loans code did, like the readme\n-                            // says)\n-\n-                            // (And do I *really* not have to\n-                            // recursively process the `base` as a\n-                            // further search here? Leaving this `if\n-                            // false` here as a hint to look at this\n-                            // again later.\n-                            //\n-                            // Ah, it might be because the\n-                            // restrictions are distinct from the path\n-                            // substructure. Note that there is a\n-                            // separate loop over the path\n-                            // substructure in fn\n-                            // each_borrow_involving_path, for better\n-                            // or for worse.\n-\n-                            if false {\n-                                cursor = &proj.base;\n-                                continue 'cursor;\n-                            } else {\n-                                continue 'pop;\n-                            }\n-                        }\n-\n-                        // R-Deref-Mut-Borrowed\n-                        ty::TyRef(_/*rgn*/, ty::TypeAndMut { ty: _, mutbl: hir::MutMutable }) => {\n-                            // mutably-borrowed referents are\n-                            // themselves restricted.\n-\n-                            // FIXME: do I need to check validity of\n-                            // `_r` here though? (I think the original\n-                            // check_loans code did, like the readme\n-                            // says)\n-\n-                            // schedule base for future iteration.\n-                            self.lvalue_stack.push(&proj.base);\n-                            return Some(cursor); // search yielded interior node\n-                        }\n+                assert_eq!(self.kind, PrefixSet::Supporting);\n+                // supporting prefixes: strip away fields and\n+                // derefs, except we stop at the deref of a shared\n+                // reference.\n+\n+                let ty = proj.base.ty(self.mir, self.tcx).to_ty(self.tcx);\n+                match ty.sty {\n+                    ty::TyRawPtr(_) |\n+                    ty::TyRef(_/*rgn*/, ty::TypeAndMut { ty: _, mutbl: hir::MutImmutable }) => {\n+                        // don't continue traversing over derefs of raw pointers or shared borrows.\n+                        self.next = None;\n+                        return Some(cursor);\n+                    }\n \n-                        // R-Deref-Send-Pointer\n-                        ty::TyAdt(..) if ty.is_box() => {\n-                            // borrowing interior of a box implies that\n-                            // its base can no longer be mutated (o/w box\n-                            // storage would be freed)\n-                            self.lvalue_stack.push(&proj.base);\n-                            return Some(cursor); // search yielded interior node\n-                        }\n+                    ty::TyRef(_/*rgn*/, ty::TypeAndMut { ty: _, mutbl: hir::MutMutable }) => {\n+                        self.next = Some(&proj.base);\n+                        return Some(cursor);\n+                    }\n \n-                        _ => panic!(\"unknown type fed to Projection Deref.\"),\n+                    ty::TyAdt(..) if ty.is_box() => {\n+                        self.next = Some(&proj.base);\n+                        return Some(cursor);\n                     }\n+\n+                    _ => panic!(\"unknown type fed to Projection Deref.\"),\n                 }\n             }\n         }\n@@ -895,9 +889,10 @@ mod restrictions {\n impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx> {\n     fn report_use_of_moved(&mut self,\n                            _context: Context,\n+                           desired_action: &str,\n                            (lvalue, span): (&Lvalue, Span)) {\n         self.tcx.cannot_act_on_uninitialized_variable(span,\n-                                                      \"use\",\n+                                                      desired_action,\n                                                       &self.describe_lvalue(lvalue),\n                                                       Origin::Mir)\n                 .span_label(span, format!(\"use of possibly uninitialized `{}`\",\n@@ -939,23 +934,41 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n     fn report_conflicting_borrow(&mut self,\n                                  _context: Context,\n                                  (lvalue, span): (&Lvalue, Span),\n-                                 loan1: &BorrowData,\n-                                 loan2: &BorrowData) {\n+                                 loan1: (&Lvalue, BorrowKind),\n+                                 loan2: (&Lvalue, BorrowKind)) {\n+        let (loan1_lvalue, loan1_kind) = loan1;\n+        let (loan2_lvalue, loan2_kind) = loan2;\n         // FIXME: obviously falsifiable. Generalize for non-eq lvalues later.\n-        assert_eq!(loan1.lvalue, loan2.lvalue);\n+        assert_eq!(loan1_lvalue, loan2_lvalue);\n \n         // FIXME: supply non-\"\" `opt_via` when appropriate\n-        let mut err = match (loan1.kind, \"immutable\", \"mutable\",\n-                             loan2.kind, \"immutable\", \"mutable\") {\n+        let mut err = match (loan1_kind, \"immutable\", \"mutable\",\n+                             loan2_kind, \"immutable\", \"mutable\") {\n             (BorrowKind::Shared, lft, _, BorrowKind::Mut, _, rgt) |\n-            (BorrowKind::Mut, _, lft, BorrowKind::Shared, rgt, _) |\n-            (BorrowKind::Mut, _, lft, BorrowKind::Mut, _, rgt) =>\n+            (BorrowKind::Mut, _, lft, BorrowKind::Shared, rgt, _) =>\n                 self.tcx.cannot_reborrow_already_borrowed(\n                     span, &self.describe_lvalue(lvalue),\n                     \"\", lft, \"it\", rgt, \"\", Origin::Mir),\n \n-            _ =>  self.tcx.cannot_mutably_borrow_multiply(\n-                span, &self.describe_lvalue(lvalue), \"\", Origin::Mir),\n+            (BorrowKind::Mut, _, _, BorrowKind::Mut, _, _) =>\n+                self.tcx.cannot_mutably_borrow_multiply(\n+                    span, &self.describe_lvalue(lvalue), \"\", Origin::Mir),\n+\n+            (BorrowKind::Unique, _, _, BorrowKind::Unique, _, _) =>\n+                self.tcx.cannot_uniquely_borrow_by_two_closures(\n+                    span, &self.describe_lvalue(lvalue), Origin::Mir),\n+\n+            (BorrowKind::Unique, _, _, _, _, _) =>\n+                self.tcx.cannot_uniquely_borrow_by_one_closure(\n+                    span, &self.describe_lvalue(lvalue), \"it\", \"\", Origin::Mir),\n+\n+            (_, _, _, BorrowKind::Unique, _, _) =>\n+                self.tcx.cannot_reborrow_already_uniquely_borrowed(\n+                    span, &self.describe_lvalue(lvalue), \"it\", \"\", Origin::Mir),\n+\n+            (BorrowKind::Shared, _, _, BorrowKind::Shared, _, _) =>\n+                unreachable!(),\n+\n             // FIXME: add span labels for first and second mutable borrows, as well as\n             // end point for first.\n         };\n@@ -1048,25 +1061,6 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n }\n \n impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx> {\n-    // FIXME: needs to be able to express errors analogous to check_loans.rs\n-    fn conflicts_with(&self, loan1: &BorrowData<'gcx>, loan2: &BorrowData<'gcx>) -> bool {\n-        if loan1.compatible_with(loan2.kind) { return false; }\n-\n-        let loan2_base_path = self.base_path(&loan2.lvalue);\n-        for restricted in self.restrictions(&loan1.lvalue) {\n-            if restricted != loan2_base_path { continue; }\n-            return true;\n-        }\n-\n-        let loan1_base_path = self.base_path(&loan1.lvalue);\n-        for restricted in self.restrictions(&loan2.lvalue) {\n-            if restricted != loan1_base_path { continue; }\n-            return true;\n-        }\n-\n-        return false;\n-    }\n-\n     // FIXME (#16118): function intended to allow the borrow checker\n     // to be less precise in its handling of Box while still allowing\n     // moves out of a Box. They should be removed when/if we stop\n@@ -1113,8 +1107,8 @@ enum ContextKind {\n     CallOperand,\n     CallDest,\n     Assert,\n-    StorageDead,\n     Yield,\n+    StorageDead,\n }\n \n impl ContextKind {\n@@ -1246,26 +1240,8 @@ impl<BD> FlowInProgress<BD> where BD: BitDenotation {\n         self.curr_state.subtract(&self.stmt_kill);\n     }\n \n-    fn elems_generated(&self) -> indexed_set::Elems<BD::Idx> {\n-        let univ = self.base_results.sets().bits_per_block();\n-        self.stmt_gen.elems(univ)\n-    }\n-\n     fn elems_incoming(&self) -> indexed_set::Elems<BD::Idx> {\n         let univ = self.base_results.sets().bits_per_block();\n         self.curr_state.elems(univ)\n     }\n }\n-\n-impl<'tcx> BorrowData<'tcx> {\n-    fn compatible_with(&self, bk: BorrowKind) -> bool {\n-        match (self.kind, bk) {\n-            (BorrowKind::Shared, BorrowKind::Shared) => true,\n-\n-            (BorrowKind::Mut, _) |\n-            (BorrowKind::Unique, _) |\n-            (_, BorrowKind::Mut) |\n-            (_, BorrowKind::Unique) => false,\n-        }\n-    }\n-}"}]}