{"sha": "faec28970f86f52ca37e0e8cec0a447ba2f1393b", "node_id": "C_kwDOAAsO6NoAKGZhZWMyODk3MGY4NmY1MmNhMzdlMGU4Y2VjMGE0NDdiYTJmMTM5M2I", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-12-03T18:08:05Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-12-03T18:08:05Z"}, "message": "Auto merge of #2713 - RalfJung:not-unpin-fake-read, r=RalfJung\n\nfor now, do not do fake reads on non-Unpin mutable references\n\nWork-around for https://github.com/rust-lang/unsafe-code-guidelines/issues/381, needed to make the new test pass. Undoes parts of https://github.com/rust-lang/miri/pull/2694.", "tree": {"sha": "b6977f4e3e7e7b6506142c87a7a482d02dd753a1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b6977f4e3e7e7b6506142c87a7a482d02dd753a1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/faec28970f86f52ca37e0e8cec0a447ba2f1393b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/faec28970f86f52ca37e0e8cec0a447ba2f1393b", "html_url": "https://github.com/rust-lang/rust/commit/faec28970f86f52ca37e0e8cec0a447ba2f1393b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/faec28970f86f52ca37e0e8cec0a447ba2f1393b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "229e65af51d75ec1a02ca24d2f638fd2b8d4d516", "url": "https://api.github.com/repos/rust-lang/rust/commits/229e65af51d75ec1a02ca24d2f638fd2b8d4d516", "html_url": "https://github.com/rust-lang/rust/commit/229e65af51d75ec1a02ca24d2f638fd2b8d4d516"}, {"sha": "3fa692c8b22cfcd4d13e0568056b680235d0cef0", "url": "https://api.github.com/repos/rust-lang/rust/commits/3fa692c8b22cfcd4d13e0568056b680235d0cef0", "html_url": "https://github.com/rust-lang/rust/commit/3fa692c8b22cfcd4d13e0568056b680235d0cef0"}], "stats": {"total": 170, "additions": 116, "deletions": 54}, "files": [{"sha": "bcac873251f587509c766cd4197cb929feb950f2", "filename": "src/tools/miri/src/borrow_tracker/stacked_borrows/mod.rs", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/faec28970f86f52ca37e0e8cec0a447ba2f1393b/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fstacked_borrows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/faec28970f86f52ca37e0e8cec0a447ba2f1393b/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fstacked_borrows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fstacked_borrows%2Fmod.rs?ref=faec28970f86f52ca37e0e8cec0a447ba2f1393b", "patch": "@@ -45,7 +45,9 @@ pub struct Stacks {\n /// new pointer.\n #[derive(Copy, Clone, Hash, PartialEq, Eq)]\n enum RefKind {\n-    /// `&mut` and `Box`.\n+    /// `Box`.\n+    Box,\n+    /// `&mut`.\n     Unique { two_phase: bool },\n     /// `&` with or without interior mutability.\n     Shared,\n@@ -56,6 +58,7 @@ enum RefKind {\n impl fmt::Display for RefKind {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match self {\n+            RefKind::Box => write!(f, \"Box\"),\n             RefKind::Unique { two_phase: false } => write!(f, \"unique reference\"),\n             RefKind::Unique { two_phase: true } => write!(f, \"unique reference (two-phase)\"),\n             RefKind::Shared => write!(f, \"shared reference\"),\n@@ -654,15 +657,17 @@ trait EvalContextPrivExt<'mir: 'ecx, 'tcx: 'mir, 'ecx>: crate::MiriInterpCxExt<'\n         let (perm, access) = match kind {\n             RefKind::Unique { two_phase } => {\n                 // Permission is Unique only if the type is `Unpin` and this is not twophase\n-                let perm = if !two_phase && place.layout.ty.is_unpin(*this.tcx, this.param_env()) {\n-                    Permission::Unique\n+                if !two_phase && place.layout.ty.is_unpin(*this.tcx, this.param_env()) {\n+                    (Permission::Unique, Some(AccessKind::Write))\n                 } else {\n-                    Permission::SharedReadWrite\n-                };\n-                // We do an access for all full borrows, even if `!Unpin`.\n-                let access = if !two_phase { Some(AccessKind::Write) } else { None };\n-                (perm, access)\n+                    // FIXME: We emit `dereferenceable` for `!Unpin` mutable references, so we\n+                    // should do fake accesses here. But then we run into\n+                    // <https://github.com/rust-lang/unsafe-code-guidelines/issues/381>, so for now\n+                    // we don't do that.\n+                    (Permission::SharedReadWrite, None)\n+                }\n             }\n+            RefKind::Box => (Permission::Unique, Some(AccessKind::Write)),\n             RefKind::Raw { mutable: true } => {\n                 // Creating a raw ptr does not count as an access\n                 (Permission::SharedReadWrite, None)\n@@ -853,7 +858,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                 // Boxes get a weak protectors, since they may be deallocated.\n                 self.retag_place(\n                     place,\n-                    RefKind::Unique { two_phase: false },\n+                    RefKind::Box,\n                     self.retag_cause,\n                     /*protector*/\n                     (self.kind == RetagKind::FnEntry).then_some(ProtectorKind::WeakProtector),"}, {"sha": "d660921bfe6e2d4755bb18e3c79e8da602fd707a", "filename": "src/tools/miri/tests/fail/stacked_borrows/notunpin_dereferenceable_fakeread.rs", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/229e65af51d75ec1a02ca24d2f638fd2b8d4d516/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fnotunpin_dereferenceable_fakeread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/229e65af51d75ec1a02ca24d2f638fd2b8d4d516/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fnotunpin_dereferenceable_fakeread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fnotunpin_dereferenceable_fakeread.rs?ref=229e65af51d75ec1a02ca24d2f638fd2b8d4d516", "patch": "@@ -1,17 +0,0 @@\n-//! Reborrowing a `&mut !Unpin` must still act like a (fake) read.\n-use std::marker::PhantomPinned;\n-\n-struct NotUnpin(i32, PhantomPinned);\n-\n-fn main() {\n-    unsafe {\n-        let mut x = NotUnpin(0, PhantomPinned);\n-        // Mutable borrow of `Unpin` field (with lifetime laundering)\n-        let fieldref = &mut *(&mut x.0 as *mut i32);\n-        // Mutable reborrow of the entire `x`, which is `!Unpin` but should\n-        // still count as a read since we would add `dereferenceable`.\n-        let _xref = &mut x;\n-        // That read should have invalidated `fieldref`.\n-        *fieldref = 0; //~ ERROR: /write access .* tag does not exist in the borrow stack/\n-    }\n-}"}, {"sha": "3ef8a8e0e9c6a8939975bc3829fbd16e50092577", "filename": "src/tools/miri/tests/fail/stacked_borrows/notunpin_dereferenceable_fakeread.stderr", "status": "removed", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/229e65af51d75ec1a02ca24d2f638fd2b8d4d516/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fnotunpin_dereferenceable_fakeread.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/229e65af51d75ec1a02ca24d2f638fd2b8d4d516/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fnotunpin_dereferenceable_fakeread.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fnotunpin_dereferenceable_fakeread.stderr?ref=229e65af51d75ec1a02ca24d2f638fd2b8d4d516", "patch": "@@ -1,28 +0,0 @@\n-error: Undefined Behavior: attempting a write access using <TAG> at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n-  --> $DIR/notunpin_dereferenceable_fakeread.rs:LL:CC\n-   |\n-LL |         *fieldref = 0;\n-   |         ^^^^^^^^^^^^^\n-   |         |\n-   |         attempting a write access using <TAG> at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n-   |         this error occurs as part of an access at ALLOC[0x0..0x4]\n-   |\n-   = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n-   = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n-help: <TAG> was created by a Unique retag at offsets [0x0..0x4]\n-  --> $DIR/notunpin_dereferenceable_fakeread.rs:LL:CC\n-   |\n-LL |         let fieldref = &mut *(&mut x.0 as *mut i32);\n-   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-help: <TAG> was later invalidated at offsets [0x0..0x4] by a SharedReadWrite retag\n-  --> $DIR/notunpin_dereferenceable_fakeread.rs:LL:CC\n-   |\n-LL |         let _xref = &mut x;\n-   |                     ^^^^^^\n-   = note: BACKTRACE:\n-   = note: inside `main` at $DIR/notunpin_dereferenceable_fakeread.rs:LL:CC\n-\n-note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n-\n-error: aborting due to previous error\n-"}, {"sha": "3ba21552fd362da1ce18c442c6e4a559e095f17e", "filename": "src/tools/miri/tests/pass/stacked-borrows/future-self-referential.rs", "status": "added", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/faec28970f86f52ca37e0e8cec0a447ba2f1393b/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fstacked-borrows%2Ffuture-self-referential.rs", "raw_url": "https://github.com/rust-lang/rust/raw/faec28970f86f52ca37e0e8cec0a447ba2f1393b/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fstacked-borrows%2Ffuture-self-referential.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fstacked-borrows%2Ffuture-self-referential.rs?ref=faec28970f86f52ca37e0e8cec0a447ba2f1393b", "patch": "@@ -0,0 +1,102 @@\n+#![feature(pin_macro)]\n+\n+use std::future::*;\n+use std::marker::PhantomPinned;\n+use std::pin::*;\n+use std::ptr;\n+use std::task::*;\n+\n+struct Delay {\n+    delay: usize,\n+}\n+\n+impl Delay {\n+    fn new(delay: usize) -> Self {\n+        Delay { delay }\n+    }\n+}\n+\n+impl Future for Delay {\n+    type Output = ();\n+    fn poll(mut self: Pin<&mut Self>, _cx: &mut Context<'_>) -> Poll<()> {\n+        if self.delay > 0 {\n+            self.delay -= 1;\n+            Poll::Pending\n+        } else {\n+            Poll::Ready(())\n+        }\n+    }\n+}\n+\n+async fn do_stuff() {\n+    (&mut Delay::new(1)).await;\n+}\n+\n+// Same thing implemented by hand\n+struct DoStuff {\n+    state: usize,\n+    delay: Delay,\n+    delay_ref: *mut Delay,\n+    _marker: PhantomPinned,\n+}\n+\n+impl DoStuff {\n+    fn new() -> Self {\n+        DoStuff {\n+            state: 0,\n+            delay: Delay::new(1),\n+            delay_ref: ptr::null_mut(),\n+            _marker: PhantomPinned,\n+        }\n+    }\n+}\n+\n+impl Future for DoStuff {\n+    type Output = ();\n+    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<()> {\n+        unsafe {\n+            let this = self.get_unchecked_mut();\n+            match this.state {\n+                0 => {\n+                    // Set up self-ref.\n+                    this.delay_ref = &mut this.delay;\n+                    // Move to next state.\n+                    this.state = 1;\n+                    Poll::Pending\n+                }\n+                1 => {\n+                    let delay = &mut *this.delay_ref;\n+                    Pin::new_unchecked(delay).poll(cx)\n+                }\n+                _ => unreachable!(),\n+            }\n+        }\n+    }\n+}\n+\n+fn run_fut<T>(fut: impl Future<Output = T>) -> T {\n+    use std::sync::Arc;\n+\n+    struct MyWaker;\n+    impl Wake for MyWaker {\n+        fn wake(self: Arc<Self>) {\n+            unimplemented!()\n+        }\n+    }\n+\n+    let waker = Waker::from(Arc::new(MyWaker));\n+    let mut context = Context::from_waker(&waker);\n+\n+    let mut pinned = pin!(fut);\n+    loop {\n+        match pinned.as_mut().poll(&mut context) {\n+            Poll::Pending => continue,\n+            Poll::Ready(v) => return v,\n+        }\n+    }\n+}\n+\n+fn main() {\n+    run_fut(do_stuff());\n+    run_fut(DoStuff::new());\n+}"}]}