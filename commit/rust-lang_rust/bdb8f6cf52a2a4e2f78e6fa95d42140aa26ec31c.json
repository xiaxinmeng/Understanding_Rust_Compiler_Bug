{"sha": "bdb8f6cf52a2a4e2f78e6fa95d42140aa26ec31c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJkYjhmNmNmNTJhMmE0ZTJmNzhlNmZhOTVkNDIxNDBhYTI2ZWMzMWM=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-01-19T22:24:03Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-01-19T22:24:03Z"}, "message": "rustc: \"tag\" -> \"enum\"", "tree": {"sha": "0d0b55cfc904eeec0d4bf99bd92744ff81324b39", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0d0b55cfc904eeec0d4bf99bd92744ff81324b39"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bdb8f6cf52a2a4e2f78e6fa95d42140aa26ec31c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bdb8f6cf52a2a4e2f78e6fa95d42140aa26ec31c", "html_url": "https://github.com/rust-lang/rust/commit/bdb8f6cf52a2a4e2f78e6fa95d42140aa26ec31c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bdb8f6cf52a2a4e2f78e6fa95d42140aa26ec31c/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e6a7383a5f478b90b95556da25160ffee870b57d", "url": "https://api.github.com/repos/rust-lang/rust/commits/e6a7383a5f478b90b95556da25160ffee870b57d", "html_url": "https://github.com/rust-lang/rust/commit/e6a7383a5f478b90b95556da25160ffee870b57d"}], "stats": {"total": 366, "additions": 183, "deletions": 183}, "files": [{"sha": "49b6373129145d37e153fd3111e89375d68ca4ad", "filename": "src/comp/back/link.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bdb8f6cf52a2a4e2f78e6fa95d42140aa26ec31c/src%2Fcomp%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdb8f6cf52a2a4e2f78e6fa95d42140aa26ec31c/src%2Fcomp%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Flink.rs?ref=bdb8f6cf52a2a4e2f78e6fa95d42140aa26ec31c", "patch": "@@ -22,7 +22,7 @@ import lib::llvm::mk_target_data;\n import lib::llvm::False;\n import util::filesearch;\n \n-tag output_type {\n+enum output_type {\n     output_type_none;\n     output_type_bitcode;\n     output_type_assembly;"}, {"sha": "6011f35ab922187b39be64868f82465e82c109b9", "filename": "src/comp/driver/diagnostic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bdb8f6cf52a2a4e2f78e6fa95d42140aa26ec31c/src%2Fcomp%2Fdriver%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdb8f6cf52a2a4e2f78e6fa95d42140aa26ec31c/src%2Fcomp%2Fdriver%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Fdiagnostic.rs?ref=bdb8f6cf52a2a4e2f78e6fa95d42140aa26ec31c", "patch": "@@ -107,7 +107,7 @@ fn mk_handler(cm: codemap::codemap,\n     } as handler\n }\n \n-tag level {\n+enum level {\n     fatal;\n     error;\n     warning;"}, {"sha": "7d0d1741918c3245a0626ddc6127a45a3f288512", "filename": "src/comp/driver/driver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bdb8f6cf52a2a4e2f78e6fa95d42140aa26ec31c/src%2Fcomp%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdb8f6cf52a2a4e2f78e6fa95d42140aa26ec31c/src%2Fcomp%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Fdriver.rs?ref=bdb8f6cf52a2a4e2f78e6fa95d42140aa26ec31c", "patch": "@@ -18,7 +18,7 @@ import option::{some, none};\n import getopts::{optopt, optmulti, optflag, optflagopt, opt_present};\n import back::{x86, x86_64};\n \n-tag pp_mode { ppm_normal; ppm_expanded; ppm_typed; ppm_identified; }\n+enum pp_mode { ppm_normal; ppm_expanded; ppm_typed; ppm_identified; }\n \n fn default_configuration(sess: session, argv0: str, input: str) ->\n    ast::crate_cfg {"}, {"sha": "9e6bb565cadfe10cd8372cd9c675f1797f47e475", "filename": "src/comp/driver/rustc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bdb8f6cf52a2a4e2f78e6fa95d42140aa26ec31c/src%2Fcomp%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdb8f6cf52a2a4e2f78e6fa95d42140aa26ec31c/src%2Fcomp%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Frustc.rs?ref=bdb8f6cf52a2a4e2f78e6fa95d42140aa26ec31c", "patch": "@@ -127,7 +127,7 @@ fails without recording a fatal error then we've encountered a compiler\n bug and need to present an error.\n */\n fn monitor(f: fn~(diagnostic::emitter)) {\n-    tag monitor_msg {\n+    enum monitor_msg {\n         fatal;\n         done;\n     };"}, {"sha": "bef939bb1c8a72e62a9bd994d369c563a64ff608", "filename": "src/comp/driver/session.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bdb8f6cf52a2a4e2f78e6fa95d42140aa26ec31c/src%2Fcomp%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdb8f6cf52a2a4e2f78e6fa95d42140aa26ec31c/src%2Fcomp%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Fsession.rs?ref=bdb8f6cf52a2a4e2f78e6fa95d42140aa26ec31c", "patch": "@@ -10,11 +10,11 @@ import util::filesearch;\n import back::target_strs;\n import middle::lint;\n \n-tag os { os_win32; os_macos; os_linux; os_freebsd; }\n+enum os { os_win32; os_macos; os_linux; os_freebsd; }\n \n-tag arch { arch_x86; arch_x86_64; arch_arm; }\n+enum arch { arch_x86; arch_x86_64; arch_arm; }\n \n-tag crate_type { bin_crate; lib_crate; unknown_crate; }\n+enum crate_type { bin_crate; lib_crate; unknown_crate; }\n \n type config =\n     {os: os,"}, {"sha": "1ee0f44297d364898c1fe1f0647f3a22cb4f5034", "filename": "src/comp/lib/llvm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bdb8f6cf52a2a4e2f78e6fa95d42140aa26ec31c/src%2Fcomp%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdb8f6cf52a2a4e2f78e6fa95d42140aa26ec31c/src%2Fcomp%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Flib%2Fllvm.rs?ref=bdb8f6cf52a2a4e2f78e6fa95d42140aa26ec31c", "patch": "@@ -15,7 +15,7 @@ const False: Bool = 0;\n \n // Consts for the LLVM CallConv type, pre-cast to uint.\n // FIXME: figure out a way to merge these with the native\n-// typedef and/or a tag type in the native module below.\n+// typedef and/or a enum type in the native module below.\n \n const LLVMCCallConv: uint = 0u;\n const LLVMFastCallConv: uint = 8u;"}, {"sha": "c4ca48d6b3e2ba7653be919053e316f615762626", "filename": "src/comp/metadata/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bdb8f6cf52a2a4e2f78e6fa95d42140aa26ec31c/src%2Fcomp%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdb8f6cf52a2a4e2f78e6fa95d42140aa26ec31c/src%2Fcomp%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fcommon.rs?ref=bdb8f6cf52a2a4e2f78e6fa95d42140aa26ec31c", "patch": "@@ -1,4 +1,4 @@\n-// EBML tag definitions and utils shared by the encoder and decoder\n+// EBML enum definitions and utils shared by the encoder and decoder\n \n import str;\n "}, {"sha": "6fb9ac4edb4f9e50372449e7de988a467d097425", "filename": "src/comp/metadata/cstore.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bdb8f6cf52a2a4e2f78e6fa95d42140aa26ec31c/src%2Fcomp%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdb8f6cf52a2a4e2f78e6fa95d42140aa26ec31c/src%2Fcomp%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fcstore.rs?ref=bdb8f6cf52a2a4e2f78e6fa95d42140aa26ec31c", "patch": "@@ -36,11 +36,11 @@ type crate_metadata = @{name: str,\n                         cnum: ast::crate_num};\n \n // This is a bit of an experiment at encapsulating the data in cstore. By\n-// keeping all the data in a non-exported tag variant, it's impossible for\n+// keeping all the data in a non-exported enum variant, it's impossible for\n // other modules to access the cstore's private data. This could also be\n // achieved with an obj, but at the expense of a vtable. Not sure if this is a\n // good pattern or not.\n-tag cstore { private(cstore_private); }\n+enum cstore { private(cstore_private); }\n \n type cstore_private =\n     @{metas: map::hashmap<ast::crate_num, crate_metadata>,"}, {"sha": "6b573de4c50a49573e9a771ef58dc17c4e2b2eb1", "filename": "src/comp/metadata/decoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bdb8f6cf52a2a4e2f78e6fa95d42140aa26ec31c/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdb8f6cf52a2a4e2f78e6fa95d42140aa26ec31c/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fdecoder.rs?ref=bdb8f6cf52a2a4e2f78e6fa95d42140aa26ec31c", "patch": "@@ -252,7 +252,7 @@ fn get_tag_variants(cdata: cmd, id: ast::node_id, tcx: ty::ctxt)\n           ty::ty_fn(f) {\n             for a: ty::arg in f.inputs { arg_tys += [a.ty]; }\n           }\n-          _ { /* Nullary tag variant. */ }\n+          _ { /* Nullary enum variant. */ }\n         }\n         alt variant_disr_val(item) {\n           some(val) { disr_val = val; }\n@@ -347,7 +347,7 @@ fn item_family_to_str(fam: u8) -> str {\n       't' { ret \"type\"; }\n       'm' { ret \"mod\"; }\n       'n' { ret \"native mod\"; }\n-      'v' { ret \"tag\"; }\n+      'v' { ret \"enum\"; }\n       'i' { ret \"impl\"; }\n       'I' { ret \"iface\"; }\n     }"}, {"sha": "539d3fad079af1c619f1716774c13b41650d771a", "filename": "src/comp/metadata/tyencode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bdb8f6cf52a2a4e2f78e6fa95d42140aa26ec31c/src%2Fcomp%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdb8f6cf52a2a4e2f78e6fa95d42140aa26ec31c/src%2Fcomp%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftyencode.rs?ref=bdb8f6cf52a2a4e2f78e6fa95d42140aa26ec31c", "patch": "@@ -25,7 +25,7 @@ type ctxt =\n // Whatever format you choose should not contain pipe characters.\n type ty_abbrev = {pos: uint, len: uint, s: @str};\n \n-tag abbrev_ctxt { ac_no_abbrevs; ac_use_abbrevs(hashmap<ty::t, ty_abbrev>); }\n+enum abbrev_ctxt { ac_no_abbrevs; ac_use_abbrevs(hashmap<ty::t, ty_abbrev>); }\n \n fn cx_uses_abbrevs(cx: @ctxt) -> bool {\n     alt cx.abbrevs {"}, {"sha": "adb08f3e563b76eabcdf40a6cfaa97edbd5aa2c7", "filename": "src/comp/middle/alias.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bdb8f6cf52a2a4e2f78e6fa95d42140aa26ec31c/src%2Fcomp%2Fmiddle%2Falias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdb8f6cf52a2a4e2f78e6fa95d42140aa26ec31c/src%2Fcomp%2Fmiddle%2Falias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Falias.rs?ref=bdb8f6cf52a2a4e2f78e6fa95d42140aa26ec31c", "patch": "@@ -15,13 +15,13 @@ import pat_util::*;\n // getting input from one, to be more precise). It is a pass that checks\n // whether aliases are used in a safe way.\n \n-tag copied { not_allowed; copied; not_copied; }\n-tag invalid_reason { overwritten; val_taken; }\n+enum copied { not_allowed; copied; not_copied; }\n+enum invalid_reason { overwritten; val_taken; }\n type invalid = {reason: invalid_reason,\n                 node_id: node_id,\n                 sp: span, path: @ast::path};\n \n-tag unsafe_ty { contains(ty::t); mut_contains(ty::t); }\n+enum unsafe_ty { contains(ty::t); mut_contains(ty::t); }\n \n type binding = @{node_id: node_id,\n                  span: span,\n@@ -46,7 +46,7 @@ fn mk_binding(cx: ctx, id: node_id, span: span, root_var: option::t<node_id>,\n           mutable copied: not_copied};\n }\n \n-tag local_info { local(uint); }\n+enum local_info { local(uint); }\n \n type copy_map = std::map::hashmap<node_id, ()>;\n type ref_map = std::map::hashmap<node_id, node_id>;"}, {"sha": "eeb44ce3a51201f5df68c1e21244e7dc6c60a2c6", "filename": "src/comp/middle/ast_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bdb8f6cf52a2a4e2f78e6fa95d42140aa26ec31c/src%2Fcomp%2Fmiddle%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdb8f6cf52a2a4e2f78e6fa95d42140aa26ec31c/src%2Fcomp%2Fmiddle%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fast_map.rs?ref=bdb8f6cf52a2a4e2f78e6fa95d42140aa26ec31c", "patch": "@@ -4,7 +4,7 @@ import syntax::ast::*;\n import syntax::ast_util;\n import syntax::{visit, codemap};\n \n-tag ast_node {\n+enum ast_node {\n     node_item(@item);\n     node_native_item(@native_item);\n     node_method(@method);"}, {"sha": "7d4bd45256e88606d1210e8a3290a38c8150e76e", "filename": "src/comp/middle/capture.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bdb8f6cf52a2a4e2f78e6fa95d42140aa26ec31c/src%2Fcomp%2Fmiddle%2Fcapture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdb8f6cf52a2a4e2f78e6fa95d42140aa26ec31c/src%2Fcomp%2Fmiddle%2Fcapture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fcapture.rs?ref=bdb8f6cf52a2a4e2f78e6fa95d42140aa26ec31c", "patch": "@@ -12,7 +12,7 @@ export cap_move;\n export cap_drop;\n export cap_ref;\n \n-tag capture_mode {\n+enum capture_mode {\n     cap_copy; //< Copy the value into the closure.\n     cap_move; //< Move the value into the closure.\n     cap_drop; //< Drop value after creating closure."}, {"sha": "fc56e39b63aaebe784eb56dae9933fc5cb012d62", "filename": "src/comp/middle/debuginfo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bdb8f6cf52a2a4e2f78e6fa95d42140aa26ec31c/src%2Fcomp%2Fmiddle%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdb8f6cf52a2a4e2f78e6fa95d42140aa26ec31c/src%2Fcomp%2Fmiddle%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fdebuginfo.rs?ref=bdb8f6cf52a2a4e2f78e6fa95d42140aa26ec31c", "patch": "@@ -108,7 +108,7 @@ type retval_md = {id: ast::node_id};\n \n type metadata_cache = hashmap<int, [debug_metadata]>;\n \n-tag debug_metadata {\n+enum debug_metadata {\n     file_metadata(@metadata<file_md>);\n     compile_unit_metadata(@metadata<compile_unit_md>);\n     subprogram_metadata(@metadata<subprogram_md>);"}, {"sha": "ce860506feb8a385ce231952e4f378bfc8093d6c", "filename": "src/comp/middle/last_use.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bdb8f6cf52a2a4e2f78e6fa95d42140aa26ec31c/src%2Fcomp%2Fmiddle%2Flast_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdb8f6cf52a2a4e2f78e6fa95d42140aa26ec31c/src%2Fcomp%2Fmiddle%2Flast_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Flast_use.rs?ref=bdb8f6cf52a2a4e2f78e6fa95d42140aa26ec31c", "patch": "@@ -26,8 +26,8 @@ import std::list;\n // Marks expr_paths that are last uses.\n type last_uses = std::map::hashmap<node_id, ()>;\n \n-tag seen { unset; seen(node_id); }\n-tag block_type { func; loop; }\n+enum seen { unset; seen(node_id); }\n+enum block_type { func; loop; }\n \n type set = [{def: node_id, exprs: list<node_id>}];\n type bl = @{type: block_type, mutable second: bool, mutable exits: [set]};"}, {"sha": "953b430a21b2f8f742e67c9a140b8c9445af99da", "filename": "src/comp/middle/mut.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bdb8f6cf52a2a4e2f78e6fa95d42140aa26ec31c/src%2Fcomp%2Fmiddle%2Fmut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdb8f6cf52a2a4e2f78e6fa95d42140aa26ec31c/src%2Fcomp%2Fmiddle%2Fmut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fmut.rs?ref=bdb8f6cf52a2a4e2f78e6fa95d42140aa26ec31c", "patch": "@@ -5,7 +5,7 @@ import syntax::visit;\n import syntax::ast_util;\n import driver::session::session;\n \n-tag deref_t { unbox; field; index; }\n+enum deref_t { unbox; field; index; }\n \n type deref = @{mut: bool, kind: deref_t, outer_t: ty::t};\n \n@@ -121,7 +121,7 @@ fn check_crate(tcx: ty::ctxt, crate: @crate) -> mut_map {\n     ret cx.mut_map;\n }\n \n-tag msg { msg_assign; msg_move_out; msg_mut_ref; }\n+enum msg { msg_assign; msg_move_out; msg_mut_ref; }\n \n fn mk_err(cx: @ctx, span: syntax::codemap::span, msg: msg, name: str) {\n     cx.tcx.sess.span_err(span, alt msg {"}, {"sha": "0f19721d56e119177d14fc5ea882efa2cbf3e4ab", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/bdb8f6cf52a2a4e2f78e6fa95d42140aa26ec31c/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdb8f6cf52a2a4e2f78e6fa95d42140aa26ec31c/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=bdb8f6cf52a2a4e2f78e6fa95d42140aa26ec31c", "patch": "@@ -30,7 +30,7 @@ export _impl, iscopes, method_info;\n // locates all names (in expressions, types, and alt patterns) and resolves\n // them, storing the resulting def in the AST nodes.\n \n-tag scope {\n+enum scope {\n     scope_crate;\n     scope_item(@ast::item);\n     scope_bare_fn(ast::fn_decl, node_id, [ast::ty_param]);\n@@ -44,7 +44,7 @@ tag scope {\n \n type scopes = list<scope>;\n \n-tag import_state {\n+enum import_state {\n     todo(ast::node_id, ast::ident, @[ast::ident], codemap::span, scopes);\n     is_glob(@[ast::ident], scopes, codemap::span);\n     resolving(span);\n@@ -56,7 +56,7 @@ tag import_state {\n              ast::ident, codemap::span);\n }\n \n-tag glob_import_state {\n+enum glob_import_state {\n     glob_resolving(span);\n     glob_resolved(option::t<def>,  /* value */\n                   option::t<def>,  /* type */\n@@ -98,12 +98,12 @@ fn new_exp_hash() -> exp_map {\n     ret std::map::mk_hashmap::<key, def>(hash, eq);\n }\n \n-tag mod_index_entry {\n+enum mod_index_entry {\n     mie_view_item(@ast::view_item);\n     mie_import_ident(node_id, codemap::span);\n     mie_item(@ast::item);\n     mie_native_item(@ast::native_item);\n-    mie_tag_variant(/* tag item */@ast::item, /* variant index */uint);\n+    mie_tag_variant(/* enum item */@ast::item, /* variant index */uint);\n }\n \n type mod_index = hashmap<ident, list<mod_index_entry>>;\n@@ -151,14 +151,14 @@ type env =\n \n // Used to distinguish between lookups from outside and from inside modules,\n // since export restrictions should only be applied for the former.\n-tag dir { inside; outside; }\n+enum dir { inside; outside; }\n \n-// There are two types of ns_value tag: \"definitely a tag\";\n+// There are two types of ns_value enum: \"definitely a enum\";\n // and \"any value\". This is so that lookup can behave differently\n // when looking up a variable name that's not yet in scope to check\n-// if it's already bound to a tag.\n-tag namespace { ns_val(ns_value_type); ns_type; ns_module; }\n-tag ns_value_type { ns_a_tag; ns_any_value; }\n+// if it's already bound to a enum.\n+enum namespace { ns_val(ns_value_type); ns_type; ns_module; }\n+enum ns_value_type { ns_a_tag; ns_any_value; }\n \n fn resolve_crate(sess: session, amap: ast_map::map, crate: @ast::crate) ->\n    {def_map: def_map, exp_map: exp_map, impl_map: impl_map} {\n@@ -186,7 +186,7 @@ fn resolve_crate(sess: session, amap: ast_map::map, crate: @ast::crate) ->\n     resolve_names(e, crate);\n     resolve_impls(e, crate);\n     // check_for_collisions must happen after resolve_names so we\n-    // don't complain if a pattern uses the same nullary tag twice\n+    // don't complain if a pattern uses the same nullary enum twice\n     check_for_collisions(e, *crate);\n     if sess.opts.warn_unused_imports {\n         check_unused_imports(e);\n@@ -415,13 +415,13 @@ fn resolve_names(e: @env, c: @ast::crate) {\n               }\n               _ {\n                 e.sess.span_err(p.span,\n-                                \"not a tag variant: \" +\n+                                \"not a enum variant: \" +\n                                     ast_util::path_name(p));\n               }\n             }\n           }\n           /* Here we determine whether a given pat_ident binds a new\n-           variable a refers to a nullary tag. */\n+           variable a refers to a nullary enum. */\n           ast::pat_ident(p, none) {\n               let fnd = lookup_in_scope(*e, sc, p.span, path_to_ident(p),\n                                     ns_val(ns_a_tag));\n@@ -557,24 +557,24 @@ fn visit_expr_with_scope(x: @ast::expr, sc: scopes, v: vt<scopes>) {\n }\n \n // This is only for irrefutable patterns (e.g. ones that appear in a let)\n-// So if x occurs, and x is already known to be a tag, that's always an error\n+// So if x occurs, and x is already known to be a enum, that's always an error\n fn visit_local_with_scope(e: @env, loc: @local, sc:scopes, v:vt<scopes>) {\n-    // Check whether the given local has the same name as a tag that's\n+    // Check whether the given local has the same name as a enum that's\n     // in scope\n     // We disallow this, in order to make alt patterns consisting of\n     // a single identifier unambiguous (does the pattern \"foo\" refer\n-    // to tag foo, or is it binding a new name foo?)\n+    // to enum foo, or is it binding a new name foo?)\n     alt loc.node.pat.node {\n       pat_ident(an_ident,_) {\n           // Be sure to pass ns_a_tag to lookup_in_scope so that\n           // if this is a name that's being shadowed, we don't die\n           alt lookup_in_scope(*e, sc, loc.span,\n                  path_to_ident(an_ident), ns_val(ns_a_tag)) {\n               some(ast::def_variant(tag_id,variant_id)) {\n-                  // Declaration shadows a tag that's in scope.\n+                  // Declaration shadows a enum that's in scope.\n                   // That's an error.\n                   e.sess.span_err(loc.span,\n-                    #fmt(\"Declaration of %s shadows a tag that's in scope\",\n+                    #fmt(\"Declaration of %s shadows a enum that's in scope\",\n                          path_to_ident(an_ident)));\n                   }\n               _ {}\n@@ -742,14 +742,14 @@ fn ns_name(ns: namespace) -> str {\n       ns_val(v) {\n           alt (v) {\n               ns_any_value { \"name\" }\n-              ns_a_tag     { \"tag\" }\n+              ns_a_tag     { \"enum\" }\n           }\n       }\n       ns_module { ret \"modulename\" }\n     }\n }\n \n-tag ctxt { in_mod(def); in_scope(scopes); }\n+enum ctxt { in_mod(def); in_scope(scopes); }\n \n fn unresolved_err(e: env, cx: ctxt, sp: span, name: ident, kind: str) {\n     fn find_fn_or_mod_scope(sc: scopes) -> option::t<scope> {\n@@ -967,8 +967,8 @@ fn lookup_in_scope(e: env, sc: scopes, sp: span, name: ident, ns: namespace)\n                       }\n                       ns_val(v) {\n                           alt(v) {\n-                            /* If we were looking for a tag, at this point\n-                               we know it's bound to a non-tag value, and\n+                            /* If we were looking for a enum, at this point\n+                               we know it's bound to a non-enum value, and\n                                we can return none instead of failing */\n                             ns_a_tag { ret none; }\n                             _ { \"attempted dynamic environment-capture\" }\n@@ -1468,7 +1468,7 @@ fn ns_for_def(d: def) -> namespace {\n }\n \n // if we're searching for a value, it's ok if we found\n-// a tag\n+// a enum\n fn ns_ok(wanted:namespace, actual:namespace) -> bool {\n     alt actual {\n       ns_val(ns_a_tag) {"}, {"sha": "0f391f4161a6f1a73df1e554bca4889a1f0f5973", "filename": "src/comp/middle/shape.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/bdb8f6cf52a2a4e2f78e6fa95d42140aa26ec31c/src%2Fcomp%2Fmiddle%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdb8f6cf52a2a4e2f78e6fa95d42140aa26ec31c/src%2Fcomp%2Fmiddle%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fshape.rs?ref=bdb8f6cf52a2a4e2f78e6fa95d42140aa26ec31c", "patch": "@@ -98,8 +98,8 @@ fn mk_global(ccx: @crate_ctxt, name: str, llval: ValueRef, internal: bool) ->\n }\n \n \n-// Computes a set of variants of a tag that are guaranteed to have size and\n-// alignment at least as large as any other variant of the tag. This is an\n+// Computes a set of variants of a enum that are guaranteed to have size and\n+// alignment at least as large as any other variant of the enum. This is an\n // important performance optimization.\n //\n // TODO: Use this in dynamic_size_of() as well.\n@@ -180,7 +180,7 @@ fn largest_variants(ccx: @crate_ctxt, tag_id: ast::def_id) -> [uint] {\n     ret result;\n }\n \n-// Computes the static size of a tag, without using mk_tup(), which is\n+// Computes the static size of a enum, without using mk_tup(), which is\n // bad for performance.\n //\n // TODO: Migrate trans over to use this.\n@@ -217,8 +217,8 @@ fn compute_static_tag_size(ccx: @crate_ctxt, largest_variants: [uint],\n         if max_align < variant_align { max_align = variant_align; }\n     }\n \n-    // Add space for the tag if applicable.\n-    // FIXME (issue #792): This is wrong. If the tag starts with an 8 byte\n+    // Add space for the enum if applicable.\n+    // FIXME (issue #792): This is wrong. If the enum starts with an 8 byte\n     // aligned quantity, we don't align it.\n     if vec::len(*variants) > 1u {\n         let variant_t = T_tag_variant(ccx);\n@@ -230,7 +230,7 @@ fn compute_static_tag_size(ccx: @crate_ctxt, largest_variants: [uint],\n     ret {size: max_size, align: max_align};\n }\n \n-tag tag_kind { tk_unit; tk_enum; tk_complex; }\n+enum tag_kind { tk_unit; tk_enum; tk_complex; }\n \n fn tag_kind(ccx: @crate_ctxt, did: ast::def_id) -> tag_kind {\n     let variants = ty::tag_variants(ccx.tcx, did);\n@@ -469,7 +469,7 @@ fn shape_of_variant(ccx: @crate_ctxt, v: ty::variant_info,\n //}\n \n fn gen_tag_shapes(ccx: @crate_ctxt) -> ValueRef {\n-    // Loop over all the tag variants and write their shapes into a data\n+    // Loop over all the enum variants and write their shapes into a data\n     // buffer. As we do this, it's possible for us to discover new tags, so we\n     // must do this first.\n     let i = 0u;\n@@ -495,7 +495,7 @@ fn gen_tag_shapes(ccx: @crate_ctxt) -> ValueRef {\n     }\n \n     // Now calculate the sizes of the header space (which contains offsets to\n-    // info records for each tag) and the info space (which contains offsets\n+    // info records for each enum) and the info space (which contains offsets\n     // to each variant shape). As we do so, build up the header.\n \n     let header = [];\n@@ -512,7 +512,7 @@ fn gen_tag_shapes(ccx: @crate_ctxt) -> ValueRef {\n     }\n \n     // Construct the info tables, which contain offsets to the shape of each\n-    // variant. Also construct the largest-variant table for each tag, which\n+    // variant. Also construct the largest-variant table for each enum, which\n     // contains the variants that the size-of operation needs to look at.\n \n     let lv_table = [];\n@@ -530,15 +530,15 @@ fn gen_tag_shapes(ccx: @crate_ctxt) -> ValueRef {\n         add_u16(lv_table, vec::len(lv) as u16);\n         for v: uint in lv { add_u16(lv_table, v as u16); }\n \n-        // Determine whether the tag has dynamic size.\n+        // Determine whether the enum has dynamic size.\n         let dynamic = false;\n         for variant: ty::variant_info in *variants {\n             for typ: ty::t in variant.args {\n                 if ty::type_has_dynamic_size(ccx.tcx, typ) { dynamic = true; }\n             }\n         }\n \n-        // If we can, write in the static size and alignment of the tag.\n+        // If we can, write in the static size and alignment of the enum.\n         // Otherwise, write a placeholder.\n         let size_align;\n         if dynamic {"}, {"sha": "8b85b78fde10ca1510aa023410819d19a9d022ba", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/bdb8f6cf52a2a4e2f78e6fa95d42140aa26ec31c/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdb8f6cf52a2a4e2f78e6fa95d42140aa26ec31c/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=bdb8f6cf52a2a4e2f78e6fa95d42140aa26ec31c", "patch": "@@ -498,7 +498,7 @@ fn simplify_type(ccx: @crate_ctxt, typ: ty::t) -> ty::t {\n }\n \n \n-// Computes the size of the data part of a non-dynamically-sized tag.\n+// Computes the size of the data part of a non-dynamically-sized enum.\n fn static_size_of_tag(cx: @crate_ctxt, sp: span, t: ty::t)\n     : type_has_static_size(cx, t) -> uint {\n     if cx.tag_sizes.contains_key(t) { ret cx.tag_sizes.get(t); }\n@@ -526,7 +526,7 @@ fn static_size_of_tag(cx: @crate_ctxt, sp: span, t: ty::t)\n         ret max_size;\n       }\n       _ {\n-        cx.tcx.sess.span_fatal(sp, \"non-tag passed to static_size_of_tag()\");\n+        cx.tcx.sess.span_fatal(sp, \"non-enum passed to static_size_of_tag()\");\n       }\n     }\n }\n@@ -736,9 +736,9 @@ fn GEP_tup_like(bcx: @block_ctxt, t: ty::t, base: ValueRef, ixs: [int])\n }\n \n \n-// Replacement for the LLVM 'GEP' instruction when field indexing into a tag.\n+// Replacement for the LLVM 'GEP' instruction when field indexing into a enum.\n // This function uses GEP_tup_like() above and automatically performs casts as\n-// appropriate. @llblobptr is the data part of a tag value; its actual type is\n+// appropriate. @llblobptr is the data part of a enum value; its actual type is\n // meaningless, as it will be cast away.\n fn GEP_tag(cx: @block_ctxt, llblobptr: ValueRef, tag_id: ast::def_id,\n            variant_id: ast::def_id, ty_substs: [ty::t],\n@@ -1470,7 +1470,7 @@ fn maybe_name_value(cx: @crate_ctxt, v: ValueRef, s: str) {\n \n \n // Used only for creating scalar comparison glue.\n-tag scalar_type { nil_type; signed_int; unsigned_int; floating_point; }\n+enum scalar_type { nil_type; signed_int; unsigned_int; floating_point; }\n \n \n fn compare_scalar_types(cx: @block_ctxt, lhs: ValueRef, rhs: ValueRef,\n@@ -1658,14 +1658,14 @@ fn iter_structural_ty(cx: @block_ctxt, av: ValueRef, t: ty::t,\n         // NB: we must hit the discriminant first so that structural\n         // comparison know not to proceed when the discriminants differ.\n         cx = f(cx, lldiscrim_a_ptr, ty::mk_int(bcx_tcx(cx)));\n-        let unr_cx = new_sub_block_ctxt(cx, \"tag-iter-unr\");\n+        let unr_cx = new_sub_block_ctxt(cx, \"enum-iter-unr\");\n         Unreachable(unr_cx);\n         let llswitch = Switch(cx, lldiscrim_a, unr_cx.llbb, n_variants);\n-        let next_cx = new_sub_block_ctxt(cx, \"tag-iter-next\");\n+        let next_cx = new_sub_block_ctxt(cx, \"enum-iter-next\");\n         for variant: ty::variant_info in *variants {\n             let variant_cx =\n                 new_sub_block_ctxt(cx,\n-                                   \"tag-iter-variant-\" +\n+                                   \"enum-iter-variant-\" +\n                                        int::to_str(variant.disr_val, 10u));\n             AddCase(llswitch, C_int(ccx, variant.disr_val), variant_cx.llbb);\n             variant_cx =\n@@ -1938,7 +1938,7 @@ fn memmove_ty(bcx: @block_ctxt, dst: ValueRef, src: ValueRef, t: ty::t) ->\n     ret call_memmove(bcx, dst, src, llsz).bcx;\n }\n \n-tag copy_action { INIT; DROP_EXISTING; }\n+enum copy_action { INIT; DROP_EXISTING; }\n \n // These are the types that are passed by pointer.\n fn type_is_structural_or_param(tcx: ty::ctxt, t: ty::t) -> bool {\n@@ -2244,7 +2244,7 @@ fn autoderef(cx: @block_ctxt, v: ValueRef, t: ty::t) -> result_t {\n             t1 = mt.ty;\n \n             // Since we're changing levels of box indirection, we may have\n-            // to cast this pointer, since statically-sized tag types have\n+            // to cast this pointer, since statically-sized enum types have\n             // different types depending on whether they're behind a box\n             // or not.\n             if check type_has_static_size(ccx, t1) {\n@@ -2330,7 +2330,7 @@ fn trans_binary(cx: @block_ctxt, op: ast::binop, a: @ast::expr, b: @ast::expr,\n     }\n }\n \n-tag dest {\n+enum dest {\n     by_val(@mutable ValueRef);\n     save_in(ValueRef);\n     ignore;\n@@ -2495,14 +2495,14 @@ type generic_info = {\n     origins: option::t<typeck::dict_res>\n };\n \n-tag lval_kind {\n+enum lval_kind {\n     temporary; //< Temporary value passed by value if of immediate type\n     owned;     //< Non-temporary value passed by pointer\n     owned_imm; //< Non-temporary value passed by value\n }\n type local_var_result = {val: ValueRef, kind: lval_kind};\n type lval_result = {bcx: @block_ctxt, val: ValueRef, kind: lval_kind};\n-tag callee_env {\n+enum callee_env {\n     null_env;\n     is_closure;\n     self_env(ValueRef);\n@@ -2896,7 +2896,7 @@ fn trans_cast(cx: @block_ctxt, e: @ast::expr, id: ast::node_id,\n     check (type_has_static_size(ccx, t_out));\n     let ll_t_out = type_of(ccx, e.span, t_out);\n \n-    tag kind { pointer; integral; float; tag_; other; }\n+    enum kind { pointer; integral; float; tag_; other; }\n     fn t_kind(tcx: ty::ctxt, t: ty::t) -> kind {\n         ret if ty::type_is_fp(tcx, t) {\n                 float\n@@ -3540,7 +3540,7 @@ fn trans_expr(bcx: @block_ctxt, e: @ast::expr, dest: dest) -> @block_ctxt {\n         ret trans_ret(bcx, ex);\n       }\n       ast::expr_be(ex) {\n-        // Ideally, the expr_be tag would have a precondition\n+        // Ideally, the expr_be enum would have a precondition\n         // that is_call_expr(ex) -- but we don't support that\n         // yet\n         // FIXME\n@@ -4409,7 +4409,7 @@ fn finish_fn(fcx: @fn_ctxt, lltop: BasicBlockRef) {\n     RetVoid(ret_cx);\n }\n \n-tag self_arg { impl_self(ty::t); no_self; }\n+enum self_arg { impl_self(ty::t); no_self; }\n \n // trans_closure: Builds an LLVM function out of a source function.\n // If the function closes over its environment a closure will be\n@@ -4557,7 +4557,7 @@ fn trans_tag_variant(cx: @local_ctxt, tag_id: ast::node_id,\n     let lltop = bcx.llbb;\n     bcx = copy_args_to_allocas(fcx, bcx, fn_args, arg_tys);\n \n-    // Cast the tag to a type we can GEP into.\n+    // Cast the enum to a type we can GEP into.\n     let llblobptr =\n         if is_degen {\n             fcx.llretptr\n@@ -4576,7 +4576,7 @@ fn trans_tag_variant(cx: @local_ctxt, tag_id: ast::node_id,\n         let rslt = GEP_tag(bcx, llblobptr, t_id, v_id, ty_param_substs, i);\n         bcx = rslt.bcx;\n         let lldestptr = rslt.val;\n-        // If this argument to this function is a tag, it'll have come in to\n+        // If this argument to this function is a enum, it'll have come in to\n         // this function as an opaque blob due to the way that type_of()\n         // works. So we have to cast to the destination's view of the type.\n         let llarg = alt fcx.llargs.find(va.id) { some(local_mem(x)) { x } };\n@@ -5222,7 +5222,7 @@ fn collect_item(ccx: @crate_ctxt, abi: @mutable option::t<ast::native_abi>,\n         for variant in variants {\n             if vec::len(variant.node.args) != 0u {\n                 register_fn(ccx, i.span, new_pt + [variant.node.name],\n-                            \"tag\", tps, variant.node.id);\n+                            \"enum\", tps, variant.node.id);\n             }\n         }\n       }"}, {"sha": "dbe46f6e4568a85cd8ffc4e8adfa0cc2e7d7481c", "filename": "src/comp/middle/trans_alt.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bdb8f6cf52a2a4e2f78e6fa95d42140aa26ec31c/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdb8f6cf52a2a4e2f78e6fa95d42140aa26ec31c/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs?ref=bdb8f6cf52a2a4e2f78e6fa95d42140aa26ec31c", "patch": "@@ -16,8 +16,8 @@ import syntax::print::pprust::pat_to_str;\n \n import trans_common::*;\n \n-// An option identifying a branch (either a literal, a tag variant or a range)\n-tag opt {\n+// An option identifying a branch (either a literal, a enum variant or a range)\n+enum opt {\n     lit(@ast::expr);\n     var(/* disr val */int, /* variant dids */{tg: def_id, var: def_id});\n     range(@ast::expr, @ast::expr);\n@@ -34,7 +34,7 @@ fn opt_eq(a: opt, b: opt) -> bool {\n     }\n }\n \n-tag opt_result {\n+enum opt_result {\n     single_result(result);\n     range_result(result, result);\n }\n@@ -284,7 +284,7 @@ fn extract_variant_args(bcx: @block_ctxt, pat_id: ast::node_id,\n         let r =\n             // invariant needed:\n             // how do we know it even makes sense to pass in ty_param_substs\n-            // here? What if it's [] and the tag type has variables in it?\n+            // here? What if it's [] and the enum type has variables in it?\n             trans::GEP_tag(bcx, blobptr, vdefs_tg, vdefs_var, ty_param_substs,\n                            i);\n         bcx = r.bcx;\n@@ -472,7 +472,7 @@ fn compile_submatch(bcx: @block_ctxt, m: match, vals: [ValueRef], f: mk_fail,\n \n     // Decide what kind of branch we need\n     let opts = get_options(ccx, m, col);\n-    tag branch_kind { no_branch; single; switch; compare; }\n+    enum branch_kind { no_branch; single; switch; compare; }\n     let kind = no_branch;\n     let test_val = val;\n     if vec::len(opts) > 0u {"}, {"sha": "9b864603b0c57481ee791fc4efcb0abf784c7df8", "filename": "src/comp/middle/trans_closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bdb8f6cf52a2a4e2f78e6fa95d42140aa26ec31c/src%2Fcomp%2Fmiddle%2Ftrans_closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdb8f6cf52a2a4e2f78e6fa95d42140aa26ec31c/src%2Fcomp%2Fmiddle%2Ftrans_closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_closure.rs?ref=bdb8f6cf52a2a4e2f78e6fa95d42140aa26ec31c", "patch": "@@ -109,7 +109,7 @@ import trans::{\n //\n // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n \n-tag environment_value {\n+enum environment_value {\n     // Evaluate expr and store result in env (used for bind).\n     env_expr(@ast::expr);\n "}, {"sha": "56a8c7016eb89f080d88907710b2a647aaf37d1b", "filename": "src/comp/middle/trans_common.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/bdb8f6cf52a2a4e2f78e6fa95d42140aa26ec31c/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdb8f6cf52a2a4e2f78e6fa95d42140aa26ec31c/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_common.rs?ref=bdb8f6cf52a2a4e2f78e6fa95d42140aa26ec31c", "patch": "@@ -32,7 +32,7 @@ fn new_namegen() -> namegen {\n \n type derived_tydesc_info = {lltydesc: ValueRef, escapes: bool};\n \n-tag tydesc_kind {\n+enum tydesc_kind {\n     tk_static; // Static (monomorphic) type descriptor\n     tk_param; // Type parameter.\n     tk_derived; // Derived from a typaram or another derived tydesc.\n@@ -131,7 +131,7 @@ type local_ctxt =\n // Types used for llself.\n type val_self_pair = {v: ValueRef, t: ty::t};\n \n-tag local_val { local_mem(ValueRef); local_imm(ValueRef); }\n+enum local_val { local_mem(ValueRef); local_imm(ValueRef); }\n \n type fn_ty_param = {desc: ValueRef, dicts: option::t<[ValueRef]>};\n \n@@ -242,7 +242,7 @@ type fn_ctxt =\n      sp: span,\n      lcx: @local_ctxt};\n \n-tag cleanup {\n+enum cleanup {\n     clean(fn@(@block_ctxt) -> @block_ctxt);\n     clean_temp(ValueRef, fn@(@block_ctxt) -> @block_ctxt);\n }\n@@ -331,7 +331,7 @@ fn get_res_dtor(ccx: @crate_ctxt, sp: span, did: ast::def_id, inner_t: ty::t)\n                                                     did), f_t);\n }\n \n-tag block_kind {\n+enum block_kind {\n \n \n     // A scope block is a basic block created by translating a block { ... }\n@@ -387,8 +387,8 @@ type block_ctxt =\n      fcx: @fn_ctxt};\n \n // FIXME: we should be able to use option::t<@block_parent> here but\n-// the infinite-tag check in rustboot gets upset.\n-tag block_parent { parent_none; parent_some(@block_ctxt); }\n+// the infinite-enum check in rustboot gets upset.\n+enum block_parent { parent_none; parent_some(@block_ctxt); }\n \n type result = {bcx: @block_ctxt, val: ValueRef};\n type result_t = {bcx: @block_ctxt, val: ValueRef, ty: ty::t};\n@@ -885,7 +885,7 @@ pure fn type_is_tup_like(cx: @block_ctxt, t: ty::t) -> bool {\n }\n \n // Used to identify cached dictionaries\n-tag dict_param {\n+enum dict_param {\n     dict_param_dict(dict_id);\n     dict_param_ty(ty::t);\n }"}, {"sha": "e3a85c41692beef614f545d211745c2ffa0af6fb", "filename": "src/comp/middle/tstate/auxiliary.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bdb8f6cf52a2a4e2f78e6fa95d42140aa26ec31c/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdb8f6cf52a2a4e2f78e6fa95d42140aa26ec31c/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs?ref=bdb8f6cf52a2a4e2f78e6fa95d42140aa26ec31c", "patch": "@@ -22,7 +22,7 @@ import syntax::print::pprust::{constr_args_to_str, lit_to_str};\n \n // Used to communicate which operands should be invalidated\n // to helper functions\n-tag oper_type {\n+enum oper_type {\n     oper_move;\n     oper_swap;\n     oper_assign;\n@@ -198,7 +198,7 @@ type pred_args = spanned<pred_args_>;\n // for this local.\n type constr_arg_use = spanned<constr_arg_general_<inst>>;\n \n-tag constraint {\n+enum constraint {\n     cinit(uint, span, ident);\n \n     // FIXME: really only want it to be mutable during collect_locals.\n@@ -211,7 +211,7 @@ tag constraint {\n // predicate need not be local.\n // FIXME: would be nice to give both a def_id field,\n // and give ninit a constraint saying it's local.\n-tag tsconstr {\n+enum tsconstr {\n     ninit(node_id, ident);\n     npred(@path, def_id, [@constr_arg_use]);\n }\n@@ -780,7 +780,7 @@ fn replace(subst: subst, d: pred_args) -> [constr_arg_general_<inst>] {\n     ret rslt;\n }\n \n-tag if_ty { if_check; plain_if; }\n+enum if_ty { if_check; plain_if; }\n \n fn local_node_id_to_def_id_strict(fcx: fn_ctxt, sp: span, i: node_id) ->\n    def_id {"}, {"sha": "6bb471390590d899951c95fb234dc999efe2c99b", "filename": "src/comp/middle/tstate/tritv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bdb8f6cf52a2a4e2f78e6fa95d42140aa26ec31c/src%2Fcomp%2Fmiddle%2Ftstate%2Ftritv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdb8f6cf52a2a4e2f78e6fa95d42140aa26ec31c/src%2Fcomp%2Fmiddle%2Ftstate%2Ftritv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Ftritv.rs?ref=bdb8f6cf52a2a4e2f78e6fa95d42140aa26ec31c", "patch": "@@ -30,7 +30,7 @@ export to_str;\n */\n \n type t = {uncertain: bitv::t, val: bitv::t, nbits: uint};\n-tag trit { ttrue; tfalse; dont_care; }\n+enum trit { ttrue; tfalse; dont_care; }\n \n fn create_tritv(len: uint) -> t {\n     ret {uncertain: bitv::create(len, true),"}, {"sha": "9a54c58ab0b10338547111388d6b0ddf20cd2ee0", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/bdb8f6cf52a2a4e2f78e6fa95d42140aa26ec31c/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdb8f6cf52a2a4e2f78e6fa95d42140aa26ec31c/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=bdb8f6cf52a2a4e2f78e6fa95d42140aa26ec31c", "patch": "@@ -235,7 +235,7 @@ type raw_t = {struct: sty,\n \n type t = uint;\n \n-tag closure_kind {\n+enum closure_kind {\n     ck_any;\n     ck_block;\n     ck_box;\n@@ -250,7 +250,7 @@ type fn_ty = {proto: ast::proto,\n \n // NB: If you change this, you'll probably want to change the corresponding\n // AST structure in front/ast::rs as well.\n-tag sty {\n+enum sty {\n     ty_nil;\n     ty_bot;\n     ty_bool;\n@@ -271,7 +271,7 @@ tag sty {\n     ty_tup([t]);\n     ty_var(int); // type variable\n \n-    ty_param(uint, def_id); // fn/tag type param\n+    ty_param(uint, def_id); // fn/enum type param\n \n     ty_type; // type_desc*\n     ty_send_type; // type_desc* that has been cloned into exchange heap\n@@ -288,7 +288,7 @@ type type_constr = constr_general<@path>;\n type constr = constr_general<uint>;\n \n // Data structures used in type unification\n-tag type_err {\n+enum type_err {\n     terr_mismatch;\n     terr_ret_style_mismatch(ast::ret_style, ast::ret_style);\n     terr_box_mutability;\n@@ -303,7 +303,7 @@ tag type_err {\n     terr_constr_mismatch(@type_constr, @type_constr);\n }\n \n-tag param_bound {\n+enum param_bound {\n     bound_copy;\n     bound_send;\n     bound_iface(t);\n@@ -712,7 +712,7 @@ fn walk_ty(cx: ctxt, walker: ty_walk, ty: t) {\n     walker(ty);\n }\n \n-tag fold_mode {\n+enum fold_mode {\n     fm_var(fn@(int) -> t);\n     fm_param(fn@(uint, def_id) -> t);\n     fm_general(fn@(t) -> t);\n@@ -973,7 +973,7 @@ fn type_needs_drop(cx: ctxt, ty: t) -> bool {\n     ret result;\n }\n \n-tag kind { kind_sendable; kind_copyable; kind_noncopyable; }\n+enum kind { kind_sendable; kind_copyable; kind_noncopyable; }\n \n // Using these query functons is preferable to direct comparison or matching\n // against the kind constants, as we may modify the kind hierarchy in the\n@@ -1245,7 +1245,7 @@ fn type_is_tag(cx: ctxt, ty: t) -> bool {\n     }\n }\n \n-// Whether a type is enum like, that is a tag type with only nullary\n+// Whether a type is enum like, that is a enum type with only nullary\n // constructors\n fn type_is_c_like_enum(cx: ctxt, ty: t) -> bool {\n     alt struct(cx, ty) {\n@@ -1732,16 +1732,16 @@ mod unify {\n     export var_bindings;\n     export precise, in_bindings;\n \n-    tag result { ures_ok(t); ures_err(type_err); }\n-    tag union_result { unres_ok; unres_err(type_err); }\n-    tag fixup_result {\n+    enum result { ures_ok(t); ures_err(type_err); }\n+    enum union_result { unres_ok; unres_err(type_err); }\n+    enum fixup_result {\n         fix_ok(t); // fixup succeeded\n         fix_err(int); // fixup failed because a type variable was unresolved\n     }\n     type var_bindings =\n         {sets: ufind::ufind, types: smallintmap::smallintmap<t>};\n \n-    tag unify_style {\n+    enum unify_style {\n         precise;\n         in_bindings(@var_bindings);\n     }\n@@ -2041,7 +2041,7 @@ mod unify {\n     }\n \n     // Specifies the allowable subtyping between expected and actual types\n-    tag variance {\n+    enum variance {\n         // Actual may be a subtype of expected\n         covariant;\n         // Actual may be a supertype of expected\n@@ -2676,7 +2676,7 @@ fn tag_variants(cx: ctxt, id: ast::def_id) -> @[variant_info] {\n }\n \n \n-// Returns information about the tag variant with the given ID:\n+// Returns information about the enum variant with the given ID:\n fn tag_variant_with_id(cx: ctxt, tag_id: ast::def_id, variant_id: ast::def_id)\n    -> variant_info {\n     let variants = tag_variants(cx, tag_id);"}, {"sha": "15c247bd81b28e613b7c84d5d72c0b9cbf586c7c", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/bdb8f6cf52a2a4e2f78e6fa95d42140aa26ec31c/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdb8f6cf52a2a4e2f78e6fa95d42140aa26ec31c/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=bdb8f6cf52a2a4e2f78e6fa95d42140aa26ec31c", "patch": "@@ -23,7 +23,7 @@ export check_crate;\n export method_map, method_origin, method_static, method_param, method_iface;\n export dict_map, dict_res, dict_origin, dict_static, dict_param, dict_iface;\n \n-tag method_origin {\n+enum method_origin {\n     method_static(ast::def_id);\n     // iface id, method num, param num, bound num\n     method_param(ast::def_id, uint, uint, uint);\n@@ -33,7 +33,7 @@ type method_map = hashmap<ast::node_id, method_origin>;\n \n // Resolutions for bounds of all parameters, left to right, for a given path.\n type dict_res = @[dict_origin];\n-tag dict_origin {\n+enum dict_origin {\n     dict_static(ast::def_id, [ty::t], dict_res);\n     // Param number, bound number\n     dict_param(uint, uint);\n@@ -44,7 +44,7 @@ type dict_map = hashmap<ast::node_id, dict_res>;\n type ty_table = hashmap<ast::def_id, ty::t>;\n \n // Used for typechecking the methods of an impl\n-tag self_info {\n+enum self_info {\n     self_impl(ty::t);\n }\n \n@@ -231,7 +231,7 @@ fn default_arg_mode_for_ty(tcx: ty::ctxt, m: ast::mode,\n     }\n }\n \n-tag mode { m_collect; m_check; m_check_tyvar(@fn_ctxt); }\n+enum mode { m_collect; m_check; m_check_tyvar(@fn_ctxt); }\n \n fn ast_ty_to_ty(tcx: ty::ctxt, mode: mode, &&ast_ty: @ast::ty) -> ty::t {\n     fn getter(tcx: ty::ctxt, mode: mode, id: ast::def_id)\n@@ -263,7 +263,7 @@ fn ast_ty_to_ty(tcx: ty::ctxt, mode: mode, &&ast_ty: @ast::ty) -> ty::t {\n       some(none) {\n         tcx.sess.span_fatal(ast_ty.span,\n                             \"illegal recursive type \\\n-                              insert a tag in the cycle, \\\n+                              insert a enum in the cycle, \\\n                               if this is desired)\");\n       }\n       none { }\n@@ -650,7 +650,7 @@ mod collect {\n         // Create a set of parameter types shared among all the variants.\n \n         for variant: ast::variant in variants {\n-            // Nullary tag constructors get turned into constants; n-ary tag\n+            // Nullary enum constructors get turned into constants; n-ary enum\n             // constructors get turned into functions.\n \n             let result_ty = if vec::len(variant.node.args) == 0u {\n@@ -921,7 +921,7 @@ fn are_compatible(fcx: @fn_ctxt, expected: ty::t, actual: ty::t) -> bool {\n }\n \n \n-// Returns the types of the arguments to a tag variant.\n+// Returns the types of the arguments to a enum variant.\n fn variant_arg_types(ccx: @crate_ctxt, _sp: span, vid: ast::def_id,\n                      tag_ty_params: [ty::t]) -> [ty::t] {\n     let result: [ty::t] = [];\n@@ -1243,10 +1243,10 @@ fn check_pat(fcx: @fn_ctxt, map: pat_util::pat_id_map, pat: @ast::pat,\n         let tag_tpt = ty::lookup_item_type(fcx.ccx.tcx, v_def_ids.tg);\n         let path_tpot = instantiate_path(fcx, path, tag_tpt, pat.span);\n \n-        // Take the tag type params out of `expected`.\n+        // Take the enum type params out of `expected`.\n         alt structure_of(fcx, pat.span, expected) {\n           ty::ty_tag(_, expected_tps) {\n-            // Unify with the expected tag type.\n+            // Unify with the expected enum type.\n             let ctor_ty =\n                 ty::ty_param_substs_opt_and_ty_to_monotype(fcx.ccx.tcx,\n                                                            path_tpot);\n@@ -1257,7 +1257,7 @@ fn check_pat(fcx: @fn_ctxt, map: pat_util::pat_id_map, pat: @ast::pat,\n             path_tpot =\n                 {substs: some::<[ty::t]>(path_tpt.substs), ty: path_tpt.ty};\n \n-            // Get the number of arguments in this tag variant.\n+            // Get the number of arguments in this enum variant.\n             let arg_types =\n                 variant_arg_types(fcx.ccx, pat.span, v_def_ids.var,\n                                   expected_tps);\n@@ -1267,7 +1267,7 @@ fn check_pat(fcx: @fn_ctxt, map: pat_util::pat_id_map, pat: @ast::pat,\n \n                 let arg_len = vec::len::<ty::t>(arg_types);\n                 if arg_len != subpats_len {\n-                    // TODO: note definition of tag variant\n+                    // TODO: note definition of enum variant\n                     // TODO (issue #448): Wrap a #fmt string over multiple\n                     // lines...\n                     let s =\n@@ -1287,7 +1287,7 @@ fn check_pat(fcx: @fn_ctxt, map: pat_util::pat_id_map, pat: @ast::pat,\n                     i += 1u;\n                 }\n             } else if subpats_len > 0u {\n-                // TODO: note definition of tag variant\n+                // TODO: note definition of enum variant\n                 fcx.ccx.tcx.sess.span_fatal\n                     (pat.span,\n                      #fmt[\"this pattern has %u field%s, \\\n@@ -1305,7 +1305,7 @@ fn check_pat(fcx: @fn_ctxt, map: pat_util::pat_id_map, pat: @ast::pat,\n             // can never tell.\n             fcx.ccx.tcx.sess.span_fatal\n                 (pat.span,\n-                 #fmt[\"mismatched types: expected `%s` but found tag\",\n+                 #fmt[\"mismatched types: expected `%s` but found enum\",\n                       ty_to_str(fcx.ccx.tcx, expected)]);\n           }\n         }"}, {"sha": "a8bbf75aaa28409c55453d74ee416305366ddd3c", "filename": "src/comp/syntax/ast.rs", "status": "modified", "additions": 36, "deletions": 36, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/bdb8f6cf52a2a4e2f78e6fa95d42140aa26ec31c/src%2Fcomp%2Fsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdb8f6cf52a2a4e2f78e6fa95d42140aa26ec31c/src%2Fcomp%2Fsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast.rs?ref=bdb8f6cf52a2a4e2f78e6fa95d42140aa26ec31c", "patch": "@@ -24,23 +24,23 @@ type def_id = {crate: crate_num, node: node_id};\n const local_crate: crate_num = 0;\n const crate_node_id: node_id = 0;\n \n-tag ty_param_bound {\n+enum ty_param_bound {\n     bound_copy;\n     bound_send;\n     bound_iface(@ty);\n }\n \n type ty_param = {ident: ident, id: node_id, bounds: @[ty_param_bound]};\n \n-tag def {\n+enum def {\n     def_fn(def_id, purity);\n     def_self(def_id);\n     def_mod(def_id);\n     def_native_mod(def_id);\n     def_const(def_id);\n     def_arg(def_id, mode);\n     def_local(def_id, let_style);\n-    def_variant(def_id /* tag */, def_id /* variant */);\n+    def_variant(def_id /* enum */, def_id /* variant */);\n     def_ty(def_id);\n     def_ty_param(def_id, uint);\n     def_binding(def_id);\n@@ -62,13 +62,13 @@ type crate_ =\n      attrs: [attribute],\n      config: crate_cfg};\n \n-tag crate_directive_ {\n+enum crate_directive_ {\n     cdir_src_mod(ident, [attribute]);\n     cdir_dir_mod(ident, [@crate_directive], [attribute]);\n \n     // NB: cdir_view_item is *not* processed by the rest of the compiler; the\n     // attached view_items are sunk into the crate's module during parsing,\n-    // and processed (resolved, imported, etc.) there. This tag-variant exists\n+    // and processed (resolved, imported, etc.) there. This enum-variant exists\n     // only to preserve the view items in order in case we decide to\n     // pretty-print crates in the future.\n     cdir_view_item(@view_item);\n@@ -80,7 +80,7 @@ type crate_directive = spanned<crate_directive_>;\n \n type meta_item = spanned<meta_item_>;\n \n-tag meta_item_ {\n+enum meta_item_ {\n     meta_word(ident);\n     meta_list(ident, [@meta_item]);\n     meta_name_value(ident, lit);\n@@ -95,12 +95,12 @@ type pat = {id: node_id, node: pat_, span: span};\n \n type field_pat = {ident: ident, pat: @pat};\n \n-tag pat_ {\n+enum pat_ {\n     pat_wild;\n     // A pat_ident may either be a new bound variable,\n-    // or a nullary tag (in which case the second field\n+    // or a nullary enum (in which case the second field\n     // is none).\n-    // In the nullary tag case, the parser can't determine\n+    // In the nullary enum case, the parser can't determine\n     // which it is. The resolver determines this, and\n     // records this pattern's node_id in an auxiliary\n     // set (of \"pat_idents that refer to nullary tags\")\n@@ -117,9 +117,9 @@ tag pat_ {\n     pat_range(@expr, @expr);\n }\n \n-tag mutability { mut; imm; maybe_mut; }\n+enum mutability { mut; imm; maybe_mut; }\n \n-tag proto {\n+enum proto {\n     proto_bare;    // native fn\n     proto_any;     // fn\n     proto_uniq;    // fn~\n@@ -134,7 +134,7 @@ pure fn is_blockish(p: ast::proto) -> bool {\n     }\n }\n \n-tag binop {\n+enum binop {\n     add;\n     subtract;\n     mul;\n@@ -156,17 +156,17 @@ tag binop {\n     gt;\n }\n \n-tag unop {\n+enum unop {\n     box(mutability);\n     uniq(mutability);\n     deref; not; neg;\n }\n \n-tag mode { by_ref; by_val; by_mut_ref; by_move; by_copy; mode_infer; }\n+enum mode { by_ref; by_val; by_mut_ref; by_move; by_copy; mode_infer; }\n \n type stmt = spanned<stmt_>;\n \n-tag stmt_ {\n+enum stmt_ {\n     stmt_decl(@decl, node_id);\n \n     // expr without trailing semi-colon (must have unit type):\n@@ -176,7 +176,7 @@ tag stmt_ {\n     stmt_semi(@expr, node_id);\n }\n \n-tag init_op { init_assign; init_move; }\n+enum init_op { init_assign; init_move; }\n \n type initializer = {op: init_op, expr: @expr};\n \n@@ -187,23 +187,23 @@ type local = spanned<local_>;\n \n type decl = spanned<decl_>;\n \n-tag let_style { let_copy; let_ref; }\n+enum let_style { let_copy; let_ref; }\n \n-tag decl_ { decl_local([(let_style, @local)]); decl_item(@item); }\n+enum decl_ { decl_local([(let_style, @local)]); decl_item(@item); }\n \n type arm = {pats: [@pat], guard: option::t<@expr>, body: blk};\n \n type field_ = {mut: mutability, ident: ident, expr: @expr};\n \n type field = spanned<field_>;\n \n-tag blk_check_mode { default_blk; unchecked_blk; unsafe_blk; }\n+enum blk_check_mode { default_blk; unchecked_blk; unsafe_blk; }\n \n-tag expr_check_mode { claimed_expr; checked_expr; }\n+enum expr_check_mode { claimed_expr; checked_expr; }\n \n type expr = {id: node_id, node: expr_, span: span};\n \n-tag expr_ {\n+enum expr_ {\n     expr_vec([@expr], mutability);\n     expr_rec([field], option::t<@expr>);\n     expr_call(@expr, [@expr], bool);\n@@ -267,15 +267,15 @@ type capture_clause = {\n /*\n // Says whether this is a block the user marked as\n // \"unchecked\"\n-tag blk_sort {\n+enum blk_sort {\n     blk_unchecked; // declared as \"exception to effect-checking rules\"\n     blk_checked; // all typing rules apply\n }\n */\n \n type mac = spanned<mac_>;\n \n-tag mac_ {\n+enum mac_ {\n     mac_invoc(@path, @expr, option::t<str>);\n     mac_embed_type(@ty);\n     mac_embed_block(blk);\n@@ -284,7 +284,7 @@ tag mac_ {\n \n type lit = spanned<lit_>;\n \n-tag lit_ {\n+enum lit_ {\n     lit_str(str);\n     lit_int(i64, int_ty);\n     lit_uint(u64, uint_ty);\n@@ -303,15 +303,15 @@ type ty_field = spanned<ty_field_>;\n \n type ty_method = {ident: ident, decl: fn_decl, tps: [ty_param], span: span};\n \n-tag int_ty { ty_i; ty_char; ty_i8; ty_i16; ty_i32; ty_i64; }\n+enum int_ty { ty_i; ty_char; ty_i8; ty_i16; ty_i32; ty_i64; }\n \n-tag uint_ty { ty_u; ty_u8; ty_u16; ty_u32; ty_u64; }\n+enum uint_ty { ty_u; ty_u8; ty_u16; ty_u32; ty_u64; }\n \n-tag float_ty { ty_f; ty_f32; ty_f64; }\n+enum float_ty { ty_f; ty_f32; ty_f64; }\n \n type ty = spanned<ty_>;\n \n-tag ty_ {\n+enum ty_ {\n     ty_nil;\n     ty_bot; /* return type of ! functions and type of\n              ret/fail/break/cont. there is no syntax\n@@ -354,7 +354,7 @@ so that the typestate pass doesn't have to map a function name onto its decl.\n So, the constr_arg type is parameterized: it's instantiated with uint for\n declarations, and ident for uses.\n */\n-tag constr_arg_general_<T> { carg_base; carg_ident(T); carg_lit(@lit); }\n+enum constr_arg_general_<T> { carg_base; carg_ident(T); carg_lit(@lit); }\n \n type fn_constr_arg = constr_arg_general_<uint>;\n type sp_constr_arg<T> = spanned<constr_arg_general_<T>>;\n@@ -389,13 +389,13 @@ type fn_decl =\n      cf: ret_style,\n      constraints: [@constr]};\n \n-tag purity {\n+enum purity {\n     pure_fn; // declared with \"pure fn\"\n     unsafe_fn; // declared with \"unsafe fn\"\n     impure_fn; // declared with \"fn\"\n }\n \n-tag ret_style {\n+enum ret_style {\n     noreturn; // functions with return type _|_ that always\n               // raise an error or exit (i.e. never return to the caller)\n     return_val; // everything else\n@@ -406,7 +406,7 @@ type method = {ident: ident, tps: [ty_param], decl: fn_decl, body: blk,\n \n type _mod = {view_items: [@view_item], items: [@item]};\n \n-tag native_abi {\n+enum native_abi {\n     native_abi_rust_intrinsic;\n     native_abi_cdecl;\n     native_abi_stdcall;\n@@ -433,7 +433,7 @@ type import_ident_ = {name: ident, id: node_id};\n \n type import_ident = spanned<import_ident_>;\n \n-tag view_item_ {\n+enum view_item_ {\n     view_item_use(ident, [@meta_item], node_id);\n     view_item_import(ident, @simple_path, node_id);\n     view_item_import_glob(@simple_path, node_id);\n@@ -448,14 +448,14 @@ type attribute = spanned<attribute_>;\n // Distinguishes between attributes that decorate items and attributes that\n // are contained as statements within items. These two cases need to be\n // distinguished for pretty-printing.\n-tag attr_style { attr_outer; attr_inner; }\n+enum attr_style { attr_outer; attr_inner; }\n \n type attribute_ = {style: attr_style, value: meta_item};\n \n type item = {ident: ident, attrs: [attribute],\n              id: node_id, node: item_, span: span};\n \n-tag item_ {\n+enum item_ {\n     item_const(@ty, @expr);\n     item_fn(fn_decl, [ty_param], blk);\n     item_mod(_mod);\n@@ -476,7 +476,7 @@ type native_item =\n      id: node_id,\n      span: span};\n \n-tag native_item_ {\n+enum native_item_ {\n     native_item_ty;\n     native_item_fn(fn_decl, [ty_param]);\n }"}, {"sha": "b1513b24e242a76429d9f2dcbbe31533d5a3e3a3", "filename": "src/comp/syntax/ast_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bdb8f6cf52a2a4e2f78e6fa95d42140aa26ec31c/src%2Fcomp%2Fsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdb8f6cf52a2a4e2f78e6fa95d42140aa26ec31c/src%2Fcomp%2Fsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast_util.rs?ref=bdb8f6cf52a2a4e2f78e6fa95d42140aa26ec31c", "patch": "@@ -201,7 +201,7 @@ fn ternary_to_if(e: @expr) -> @expr {\n \n // FIXME this doesn't handle big integer/float literals correctly (nor does\n // the rest of our literal handling)\n-tag const_val {\n+enum const_val {\n     const_float(float);\n     const_int(i64);\n     const_uint(u64);"}, {"sha": "7844e9c197e8c303e74e37a422f75e3dd8fbce87", "filename": "src/comp/syntax/codemap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bdb8f6cf52a2a4e2f78e6fa95d42140aa26ec31c/src%2Fcomp%2Fsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdb8f6cf52a2a4e2f78e6fa95d42140aa26ec31c/src%2Fcomp%2Fsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fcodemap.rs?ref=bdb8f6cf52a2a4e2f78e6fa95d42140aa26ec31c", "patch": "@@ -65,7 +65,7 @@ fn lookup_byte_pos(map: codemap, pos: uint) -> loc {\n     ret lookup_pos(map, pos, lookup);\n }\n \n-tag opt_span {\n+enum opt_span {\n \n     //hack (as opposed to option::t), to make `span` compile\n     os_none;"}, {"sha": "bead9a5d85b25d292cab0ae17e83d50edab0fdca", "filename": "src/comp/syntax/ext/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bdb8f6cf52a2a4e2f78e6fa95d42140aa26ec31c/src%2Fcomp%2Fsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdb8f6cf52a2a4e2f78e6fa95d42140aa26ec31c/src%2Fcomp%2Fsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fbase.rs?ref=bdb8f6cf52a2a4e2f78e6fa95d42140aa26ec31c", "patch": "@@ -11,7 +11,7 @@ type macro_def = {ident: str, ext: syntax_extension};\n type macro_definer =\n     fn@(ext_ctxt, span, @ast::expr, option::t<str>) -> macro_def;\n \n-tag syntax_extension {\n+enum syntax_extension {\n     normal(syntax_expander);\n     macro_defining(macro_definer);\n }"}, {"sha": "85d6d451810129ed004d982ec519aabb21637f6d", "filename": "src/comp/syntax/ext/simplext.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bdb8f6cf52a2a4e2f78e6fa95d42140aa26ec31c/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdb8f6cf52a2a4e2f78e6fa95d42140aa26ec31c/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Fsimplext.rs?ref=bdb8f6cf52a2a4e2f78e6fa95d42140aa26ec31c", "patch": "@@ -25,10 +25,10 @@ fn path_to_ident(pth: @path) -> option::t<ident> {\n type clause = {params: binders, body: @expr};\n \n /* logically, an arb_depth should contain only one kind of matchable */\n-tag arb_depth<T> { leaf(T); seq(@[arb_depth<T>], span); }\n+enum arb_depth<T> { leaf(T); seq(@[arb_depth<T>], span); }\n \n \n-tag matchable {\n+enum matchable {\n     match_expr(@expr);\n     match_path(@path);\n     match_ident(ast::spanned<ident>);"}, {"sha": "78cde98a9c5d76ad9172b85866b44b52a8d9149d", "filename": "src/comp/syntax/parse/lexer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bdb8f6cf52a2a4e2f78e6fa95d42140aa26ec31c/src%2Fcomp%2Fsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdb8f6cf52a2a4e2f78e6fa95d42140aa26ec31c/src%2Fcomp%2Fsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Flexer.rs?ref=bdb8f6cf52a2a4e2f78e6fa95d42140aa26ec31c", "patch": "@@ -510,7 +510,7 @@ fn next_token_inner(rdr: reader) -> token::token {\n     }\n }\n \n-tag cmnt_style {\n+enum cmnt_style {\n     isolated; // No code on either side of each line of the comment\n     trailing; // Code exists to the left of the comment\n     mixed; // Code before /* foo */ and after the comment"}, {"sha": "373b1f22a4495ba13a948dfeb51486fe32c500a7", "filename": "src/comp/syntax/parse/parser.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/bdb8f6cf52a2a4e2f78e6fa95d42140aa26ec31c/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdb8f6cf52a2a4e2f78e6fa95d42140aa26ec31c/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs?ref=bdb8f6cf52a2a4e2f78e6fa95d42140aa26ec31c", "patch": "@@ -13,14 +13,14 @@ import front::attr;\n import lexer::reader;\n import driver::diagnostic;\n \n-tag restriction {\n+enum restriction {\n     UNRESTRICTED;\n     RESTRICT_STMT_EXPR;\n     RESTRICT_NO_CALL_EXPRS;\n     RESTRICT_NO_BAR_OP;\n }\n \n-tag file_type { CRATE_FILE; SOURCE_FILE; }\n+enum file_type { CRATE_FILE; SOURCE_FILE; }\n \n type parse_sess = @{\n     cm: codemap::codemap,\n@@ -147,7 +147,7 @@ fn bad_expr_word_table() -> hashmap<str, ()> {\n                  \"cont\", \"ret\", \"be\", \"fail\", \"type\", \"resource\", \"check\",\n                  \"assert\", \"claim\", \"native\", \"fn\", \"pure\",\n                  \"unsafe\", \"block\", \"import\", \"export\", \"let\", \"const\",\n-                 \"log\", \"copy\", \"sendfn\", \"impl\", \"iface\", \"enum\"] {\n+                 \"log\", \"copy\", \"sendfn\", \"impl\", \"iface\", \"tag\", \"enum\"] {\n         words.insert(word, ());\n     }\n     words\n@@ -719,9 +719,9 @@ fn mk_lit_u32(p: parser, i: u32) -> @ast::expr {\n // parsing because `(while{...})+3` parses differently from `while{...}+3`.\n //\n // To reflect the fact that the @ast::expr is not a true expr that should be\n-// part of the AST, we wrap such expressions in the pexpr tag.  They\n+// part of the AST, we wrap such expressions in the pexpr enum.  They\n // can then be converted to true expressions by a call to `to_expr()`.\n-tag pexpr {\n+enum pexpr {\n     pexpr(@ast::expr);\n }\n \n@@ -1508,7 +1508,7 @@ fn parse_pat(p: parser) -> @ast::pat {\n               }\n               _ { args = []; }\n             }\n-            // at this point, we're not sure whether it's a tag or a bind\n+            // at this point, we're not sure whether it's a enum or a bind\n             if vec::len(args) == 0u &&\n                vec::len(tag_path.node.idents) == 1u {\n                 pat = ast::pat_ident(tag_path, none);\n@@ -2026,7 +2026,7 @@ fn parse_item_tag(p: parser, attrs: [ast::attribute]) -> @ast::item {\n     // Newtype syntax\n     if p.token == token::EQ {\n         if p.bad_expr_words.contains_key(id) {\n-            p.fatal(\"found \" + id + \" in tag constructor position\");\n+            p.fatal(\"found \" + id + \" in enum constructor position\");\n         }\n         p.bump();\n         let ty = parse_ty(p, false);"}, {"sha": "e1851d831b10d2623b495d5a43d8cafa1734f00a", "filename": "src/comp/syntax/parse/token.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bdb8f6cf52a2a4e2f78e6fa95d42140aa26ec31c/src%2Fcomp%2Fsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdb8f6cf52a2a4e2f78e6fa95d42140aa26ec31c/src%2Fcomp%2Fsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Ftoken.rs?ref=bdb8f6cf52a2a4e2f78e6fa95d42140aa26ec31c", "patch": "@@ -5,7 +5,7 @@ import lexer::reader;\n \n type str_num = uint;\n \n-tag binop {\n+enum binop {\n     PLUS;\n     MINUS;\n     STAR;\n@@ -19,7 +19,7 @@ tag binop {\n     ASR;\n }\n \n-tag token {\n+enum token {\n     /* Expression-operator symbols. */\n     EQ;\n     LT;"}, {"sha": "4950af7b624ddaf6ef2acc492b9a42b6cb8363d0", "filename": "src/comp/syntax/print/pp.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bdb8f6cf52a2a4e2f78e6fa95d42140aa26ec31c/src%2Fcomp%2Fsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdb8f6cf52a2a4e2f78e6fa95d42140aa26ec31c/src%2Fcomp%2Fsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fprint%2Fpp.rs?ref=bdb8f6cf52a2a4e2f78e6fa95d42140aa26ec31c", "patch": "@@ -55,13 +55,13 @@ import io::writer_util;\n  * line (which it can't) and so naturally place the content on its own line to\n  * avoid combining it with other lines and making matters even worse.\n  */\n-tag breaks { consistent; inconsistent; }\n+enum breaks { consistent; inconsistent; }\n \n type break_t = {offset: int, blank_space: int};\n \n type begin_t = {offset: int, breaks: breaks};\n \n-tag token { STRING(str, int); BREAK(break_t); BEGIN(begin_t); END; EOF; }\n+enum token { STRING(str, int); BREAK(break_t); BEGIN(begin_t); END; EOF; }\n \n fn tok_str(t: token) -> str {\n     alt t {\n@@ -91,7 +91,7 @@ fn buf_str(toks: [mutable token], szs: [mutable int], left: uint, right: uint,\n     ret s;\n }\n \n-tag print_stack_break { fits; broken(breaks); }\n+enum print_stack_break { fits; broken(breaks); }\n \n type print_stack_elt = {offset: int, pbreak: print_stack_break};\n "}, {"sha": "3717dc8378026578fa9affff523bdbc8d119b943", "filename": "src/comp/syntax/print/pprust.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bdb8f6cf52a2a4e2f78e6fa95d42140aa26ec31c/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdb8f6cf52a2a4e2f78e6fa95d42140aa26ec31c/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs?ref=bdb8f6cf52a2a4e2f78e6fa95d42140aa26ec31c", "patch": "@@ -12,8 +12,8 @@ import pp::{break_offset, word, printer,\n import driver::diagnostic;\n \n // The ps is stored here to prevent recursive type.\n-// FIXME use a nominal tag instead\n-tag ann_node {\n+// FIXME use a nominal enum instead\n+enum ann_node {\n     node_block(ps, ast::blk);\n     node_item(ps, @ast::item);\n     node_expr(ps, @ast::expr);\n@@ -565,7 +565,7 @@ fn print_block_with_attrs(s: ps, blk: ast::blk, attrs: [ast::attribute]) {\n     print_possibly_embedded_block_(s, blk, block_normal, indent_unit, attrs);\n }\n \n-tag embed_type { block_macro; block_block_fn; block_normal; }\n+enum embed_type { block_macro; block_block_fn; block_normal; }\n \n fn print_possibly_embedded_block(s: ps, blk: ast::blk, embedded: embed_type,\n                                  indented: uint) {"}, {"sha": "8f0f1f6f5587e9cacc16712ebd29932b539f8c11", "filename": "src/comp/syntax/visit.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bdb8f6cf52a2a4e2f78e6fa95d42140aa26ec31c/src%2Fcomp%2Fsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdb8f6cf52a2a4e2f78e6fa95d42140aa26ec31c/src%2Fcomp%2Fsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fvisit.rs?ref=bdb8f6cf52a2a4e2f78e6fa95d42140aa26ec31c", "patch": "@@ -12,10 +12,10 @@ import codemap::span;\n // override the context), or prevent deeper traversal by doing nothing.\n \n // Our typesystem doesn't do circular types, so the visitor record can not\n-// hold functions that take visitors. A vt tag is used to break the cycle.\n-tag vt<E> { mk_vt(visitor<E>); }\n+// hold functions that take visitors. A vt enum is used to break the cycle.\n+enum vt<E> { mk_vt(visitor<E>); }\n \n-tag fn_kind {\n+enum fn_kind {\n     fk_item_fn(ident, [ty_param]); //< an item declared with fn()\n     fk_method(ident, [ty_param]);\n     fk_res(ident, [ty_param]);"}]}