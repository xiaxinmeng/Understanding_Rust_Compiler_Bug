{"sha": "92f3d9a6b46a116a48b0dd35b66c8f66786296d6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkyZjNkOWE2YjQ2YTExNmE0OGIwZGQzNWI2NmM4ZjY2Nzg2Mjk2ZDY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-03-29T19:47:18Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-03-29T19:47:18Z"}, "message": "Auto merge of #23820 - sfackler:fast_read_to_end, r=alexcrichton\n\nwith_end_to_cap is enormously expensive now that it's initializing\r\nmemory since it involves 64k allocation + memset on every call. This is\r\nmost noticable when calling read_to_end on very small readers, where the\r\nnew version if **4 orders of magnitude** faster.\r\n\r\nBufReader also depended on with_end_to_cap so I've rewritten it in its\r\noriginal form.\r\n\r\nAs a bonus, converted the buffered IO struct Debug impls to use the\r\ndebug builders.\r\n\r\nI first came across this in sfackler/rust-postgres#106 where a user reported a 10x performance regression. A call to read_to_end turned out to be the culprit: https://github.com/sfackler/rust-postgres/commit/9cd413d42c287154d6c64cc7913666b0517f35f3.\r\n\r\nThe new version differs from the old in a couple of ways. The buffer size used is now adaptive. It starts at 32 bytes and doubles each time EOF hasn't been reached up to a limit of 64k. In addition, the buffer is only truncated when EOF or an error has been reached, rather than after every call to read as was the case for the old implementation.\r\n\r\nI wrote up a benchmark to compare the old version and new version: https://gist.github.com/sfackler/e979711b0ee2f2063462\r\n\r\nIt tests a couple of different cases: a high bandwidth reader, a low bandwidth reader, and a low bandwidth reader that won't return more than 10k per call to `read`. The high bandwidth reader should be analagous to use cases when reading from e.g. a `BufReader` or `Vec`, and the low bandwidth readers should be analogous to reading from something like a `TcpStream`.\r\n\r\nOf special note, reads from a high bandwith reader containing 4 bytes are now *4,495 times faster*. \r\n```\r\n~/foo \u276f cargo bench\r\n   Compiling foo v0.0.1 (file:///home/sfackler/foo)\r\n     Running target/release/foo-7498d7dd7faecf5c\r\n\r\nrunning 13 tests\r\ntest test_new ... ignored\r\ntest new_delay_4      ... bench:    230768 ns/iter (+/- 14812)\r\ntest new_delay_4_cap  ... bench:    231421 ns/iter (+/- 7211)\r\ntest new_delay_5m     ... bench:  14495370 ns/iter (+/- 4008648)\r\ntest new_delay_5m_cap ... bench:  73127954 ns/iter (+/- 59908587)\r\ntest new_nodelay_4    ... bench:        83 ns/iter (+/- 2)\r\ntest new_nodelay_5m   ... bench:  12527237 ns/iter (+/- 335243)\r\ntest std_delay_4      ... bench:    373095 ns/iter (+/- 12613)\r\ntest std_delay_4_cap  ... bench:    374190 ns/iter (+/- 19611)\r\ntest std_delay_5m     ... bench:  17356012 ns/iter (+/- 15906588)\r\ntest std_delay_5m_cap ... bench: 883555035 ns/iter (+/- 205559857)\r\ntest std_nodelay_4    ... bench:    144937 ns/iter (+/- 2448)\r\ntest std_nodelay_5m   ... bench:  16095893 ns/iter (+/- 3315116)\r\n\r\ntest result: ok. 0 passed; 0 failed; 1 ignored; 12 measured\r\n```\r\n\r\nr? @alexcrichton", "tree": {"sha": "bd3f7646595846f15e86fbd9bb6b6267d0c2b88d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bd3f7646595846f15e86fbd9bb6b6267d0c2b88d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/92f3d9a6b46a116a48b0dd35b66c8f66786296d6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/92f3d9a6b46a116a48b0dd35b66c8f66786296d6", "html_url": "https://github.com/rust-lang/rust/commit/92f3d9a6b46a116a48b0dd35b66c8f66786296d6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/92f3d9a6b46a116a48b0dd35b66c8f66786296d6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c5370be36ec6601c4a816f0341d1acd81e08d345", "url": "https://api.github.com/repos/rust-lang/rust/commits/c5370be36ec6601c4a816f0341d1acd81e08d345", "html_url": "https://github.com/rust-lang/rust/commit/c5370be36ec6601c4a816f0341d1acd81e08d345"}, {"sha": "ccb4e8423e50fef0f13a642715c3e617ee9f78fe", "url": "https://api.github.com/repos/rust-lang/rust/commits/ccb4e8423e50fef0f13a642715c3e617ee9f78fe", "html_url": "https://github.com/rust-lang/rust/commit/ccb4e8423e50fef0f13a642715c3e617ee9f78fe"}], "stats": {"total": 135, "additions": 76, "deletions": 59}, "files": [{"sha": "98581fc43f89e978584db5a707d05aad051ac6f8", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 43, "deletions": 28, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/92f3d9a6b46a116a48b0dd35b66c8f66786296d6/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f3d9a6b46a116a48b0dd35b66c8f66786296d6/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=92f3d9a6b46a116a48b0dd35b66c8f66786296d6", "patch": "@@ -18,8 +18,9 @@ use io::prelude::*;\n use cmp;\n use error::{self, FromError};\n use fmt;\n-use io::{self, Cursor, DEFAULT_BUF_SIZE, Error, ErrorKind};\n+use io::{self, DEFAULT_BUF_SIZE, Error, ErrorKind};\n use ptr;\n+use iter;\n \n /// Wraps a `Read` and buffers input from it\n ///\n@@ -30,7 +31,9 @@ use ptr;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct BufReader<R> {\n     inner: R,\n-    buf: Cursor<Vec<u8>>,\n+    buf: Vec<u8>,\n+    pos: usize,\n+    cap: usize,\n }\n \n impl<R: Read> BufReader<R> {\n@@ -43,9 +46,13 @@ impl<R: Read> BufReader<R> {\n     /// Creates a new `BufReader` with the specified buffer capacity\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn with_capacity(cap: usize, inner: R) -> BufReader<R> {\n+        let mut buf = Vec::with_capacity(cap);\n+        buf.extend(iter::repeat(0).take(cap));\n         BufReader {\n             inner: inner,\n-            buf: Cursor::new(Vec::with_capacity(cap)),\n+            buf: buf,\n+            pos: 0,\n+            cap: 0,\n         }\n     }\n \n@@ -74,12 +81,15 @@ impl<R: Read> Read for BufReader<R> {\n         // If we don't have any buffered data and we're doing a massive read\n         // (larger than our internal buffer), bypass our internal buffer\n         // entirely.\n-        if self.buf.get_ref().len() == self.buf.position() as usize &&\n-            buf.len() >= self.buf.get_ref().capacity() {\n+        if self.pos == self.cap && buf.len() >= self.buf.len() {\n             return self.inner.read(buf);\n         }\n-        try!(self.fill_buf());\n-        self.buf.read(buf)\n+        let nread = {\n+            let mut rem = try!(self.fill_buf());\n+            try!(rem.read(buf))\n+        };\n+        self.consume(nread);\n+        Ok(nread)\n     }\n }\n \n@@ -88,26 +98,25 @@ impl<R: Read> BufRead for BufReader<R> {\n     fn fill_buf(&mut self) -> io::Result<&[u8]> {\n         // If we've reached the end of our internal buffer then we need to fetch\n         // some more data from the underlying reader.\n-        if self.buf.position() as usize == self.buf.get_ref().len() {\n-            self.buf.set_position(0);\n-            let v = self.buf.get_mut();\n-            v.truncate(0);\n-            let inner = &mut self.inner;\n-            try!(super::with_end_to_cap(v, |b| inner.read(b)));\n+        if self.pos == self.cap {\n+            self.cap = try!(self.inner.read(&mut self.buf));\n+            self.pos = 0;\n         }\n-        self.buf.fill_buf()\n+        Ok(&self.buf[self.pos..self.cap])\n     }\n \n     fn consume(&mut self, amt: usize) {\n-        self.buf.consume(amt)\n+        self.pos = cmp::min(self.pos + amt, self.cap);\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<R> fmt::Debug for BufReader<R> where R: fmt::Debug {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        write!(fmt, \"BufReader {{ reader: {:?}, buffer: {}/{} }}\",\n-               self.inner, self.buf.position(), self.buf.get_ref().len())\n+        fmt.debug_struct(\"BufReader\")\n+            .field(\"reader\", &self.inner)\n+            .field(\"buffer\", &format_args!(\"{}/{}\", self.cap - self.pos, self.buf.len()))\n+            .finish()\n     }\n }\n \n@@ -222,8 +231,10 @@ impl<W: Write> Write for BufWriter<W> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<W: Write> fmt::Debug for BufWriter<W> where W: fmt::Debug {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        write!(fmt, \"BufWriter {{ writer: {:?}, buffer: {}/{} }}\",\n-               self.inner.as_ref().unwrap(), self.buf.len(), self.buf.capacity())\n+        fmt.debug_struct(\"BufWriter\")\n+            .field(\"writer\", &self.inner.as_ref().unwrap())\n+            .field(\"buffer\", &format_args!(\"{}/{}\", self.buf.len(), self.buf.capacity()))\n+            .finish()\n     }\n }\n \n@@ -337,9 +348,11 @@ impl<W: Write> Write for LineWriter<W> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<W: Write> fmt::Debug for LineWriter<W> where W: fmt::Debug {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        write!(fmt, \"LineWriter {{ writer: {:?}, buffer: {}/{} }}\",\n-               self.inner.inner, self.inner.buf.len(),\n-               self.inner.buf.capacity())\n+        fmt.debug_struct(\"LineWriter\")\n+            .field(\"writer\", &self.inner.inner)\n+            .field(\"buffer\",\n+                   &format_args!(\"{}/{}\", self.inner.buf.len(), self.inner.buf.capacity()))\n+            .finish()\n     }\n }\n \n@@ -415,10 +428,10 @@ impl<S: Read + Write> BufStream<S> {\n     /// Any leftover data in the read buffer is lost.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn into_inner(self) -> Result<S, IntoInnerError<BufStream<S>>> {\n-        let BufReader { inner: InternalBufWriter(w), buf } = self.inner;\n+        let BufReader { inner: InternalBufWriter(w), buf, pos, cap } = self.inner;\n         w.into_inner().map_err(|IntoInnerError(w, e)| {\n             IntoInnerError(BufStream {\n-                inner: BufReader { inner: InternalBufWriter(w), buf: buf },\n+                inner: BufReader { inner: InternalBufWriter(w), buf: buf, pos: pos, cap: cap },\n             }, e)\n         })\n     }\n@@ -452,10 +465,12 @@ impl<S: Write> fmt::Debug for BufStream<S> where S: fmt::Debug {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         let reader = &self.inner;\n         let writer = &self.inner.inner.0;\n-        write!(fmt, \"BufStream {{ stream: {:?}, write_buffer: {}/{}, read_buffer: {}/{} }}\",\n-               writer.inner,\n-               writer.buf.len(), writer.buf.capacity(),\n-               reader.buf.position(), reader.buf.get_ref().len())\n+        fmt.debug_struct(\"BufStream\")\n+            .field(\"stream\", &writer.inner)\n+            .field(\"write_buffer\", &format_args!(\"{}/{}\", writer.buf.len(), writer.buf.capacity()))\n+            .field(\"read_buffer\",\n+                   &format_args!(\"{}/{}\", reader.cap - reader.pos, reader.buf.len()))\n+            .finish()\n     }\n }\n "}, {"sha": "830a88bb6c95b1fe75d54d797233cbc1a3f6fd5d", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 33, "deletions": 31, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/92f3d9a6b46a116a48b0dd35b66c8f66786296d6/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92f3d9a6b46a116a48b0dd35b66c8f66786296d6/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=92f3d9a6b46a116a48b0dd35b66c8f66786296d6", "patch": "@@ -48,30 +48,6 @@ mod stdio;\n \n const DEFAULT_BUF_SIZE: usize = 64 * 1024;\n \n-// Acquires a slice of the vector `v` from its length to its capacity\n-// (after initializing the data), reads into it, and then updates the length.\n-//\n-// This function is leveraged to efficiently read some bytes into a destination\n-// vector without extra copying and taking advantage of the space that's already\n-// in `v`.\n-fn with_end_to_cap<F>(v: &mut Vec<u8>, f: F) -> Result<usize>\n-    where F: FnOnce(&mut [u8]) -> Result<usize>\n-{\n-    let len = v.len();\n-    let new_area = v.capacity() - len;\n-    v.extend(iter::repeat(0).take(new_area));\n-    match f(&mut v[len..]) {\n-        Ok(n) => {\n-            v.truncate(len + n);\n-            Ok(n)\n-        }\n-        Err(e) => {\n-            v.truncate(len);\n-            Err(e)\n-        }\n-    }\n-}\n-\n // A few methods below (read_to_string, read_line) will append data into a\n // `String` buffer, but we need to be pretty careful when doing this. The\n // implementation will just call `.as_mut_vec()` and then delegate to a\n@@ -116,19 +92,45 @@ fn append_to_string<F>(buf: &mut String, f: F) -> Result<usize>\n     }\n }\n \n+// This uses an adaptive system to extend the vector when it fills. We want to\n+// avoid paying to allocate and zero a huge chunk of memory if the reader only\n+// has 4 bytes while still making large reads if the reader does have a ton\n+// of data to return. Simply tacking on an extra DEFAULT_BUF_SIZE space every\n+// time is 4,500 times (!) slower than this if the reader has a very small\n+// amount of data to return.\n fn read_to_end<R: Read + ?Sized>(r: &mut R, buf: &mut Vec<u8>) -> Result<usize> {\n-    let mut read = 0;\n+    let start_len = buf.len();\n+    let mut len = start_len;\n+    let mut cap_bump = 16;\n+    let ret;\n     loop {\n-        if buf.capacity() == buf.len() {\n-            buf.reserve(DEFAULT_BUF_SIZE);\n+        if len == buf.len() {\n+            if buf.capacity() == buf.len() {\n+                if cap_bump < DEFAULT_BUF_SIZE {\n+                    cap_bump *= 2;\n+                }\n+                buf.reserve(cap_bump);\n+            }\n+            let new_area = buf.capacity() - buf.len();\n+            buf.extend(iter::repeat(0).take(new_area));\n         }\n-        match with_end_to_cap(buf, |b| r.read(b)) {\n-            Ok(0) => return Ok(read),\n-            Ok(n) => read += n,\n+\n+        match r.read(&mut buf[len..]) {\n+            Ok(0) => {\n+                ret = Ok(len - start_len);\n+                break;\n+            }\n+            Ok(n) => len += n,\n             Err(ref e) if e.kind() == ErrorKind::Interrupted => {}\n-            Err(e) => return Err(e),\n+            Err(e) => {\n+                ret = Err(e);\n+                break;\n+            }\n         }\n     }\n+\n+    buf.truncate(len);\n+    ret\n }\n \n /// A trait for objects which are byte-oriented sources."}]}