{"sha": "6eab968c601637361e8fbd1ee93ded1b0d967bee", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZlYWI5NjhjNjAxNjM3MzYxZThmYmQxZWU5M2RlZDFiMGQ5NjdiZWU=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2019-12-20T19:51:03Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-12-20T19:51:03Z"}, "message": "Merge #2624\n\n2624: Separate module item from module scope r=matklad a=matklad\n\nbors r+\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "0d45c734f00247837f923f203b8cc3ffcfcc3e61", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0d45c734f00247837f923f203b8cc3ffcfcc3e61"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6eab968c601637361e8fbd1ee93ded1b0d967bee", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJd/SYnCRBK7hj4Ov3rIwAAdHIIACjrbW8mhweCjW+46iRbcr/R\nNjLcehoRFiY36m2rzKIibI1aPccx/4PrQJTqG6h8AVWpFzNVvXKJll7u22n6gI7G\nBCGjHclDpJ/YCpFKvFC2+icXmOWQxKmKBNUJ55+9DIvUA3SA6RcmwlEofU4BUAaM\nfan6HmEKLmic+KmCaTC+BEZg9SIE0yVfkup80TKxyfVgHuN2MflTnPwXJgElU6om\nLfldxWlbCRTvxS/XgsVOLUzrZupFTpU2xA+i8BwhZ2cP55WlkWGWCRcifmkBGNir\nVCzsb8ItA7UVSj+hFPIc+Ri5AgMGfQz5BbA6eJWtEM091M4zus/czMupp1/C+lc=\n=2Q+k\n-----END PGP SIGNATURE-----\n", "payload": "tree 0d45c734f00247837f923f203b8cc3ffcfcc3e61\nparent f578cd21823484cc1ee8e4273cd5c2f837934f34\nparent 7a862f0d47e8ae018d449a04c918ea3705785552\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1576871463 +0000\ncommitter GitHub <noreply@github.com> 1576871463 +0000\n\nMerge #2624\n\n2624: Separate module item from module scope r=matklad a=matklad\n\nbors r+\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6eab968c601637361e8fbd1ee93ded1b0d967bee", "html_url": "https://github.com/rust-lang/rust/commit/6eab968c601637361e8fbd1ee93ded1b0d967bee", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6eab968c601637361e8fbd1ee93ded1b0d967bee/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f578cd21823484cc1ee8e4273cd5c2f837934f34", "url": "https://api.github.com/repos/rust-lang/rust/commits/f578cd21823484cc1ee8e4273cd5c2f837934f34", "html_url": "https://github.com/rust-lang/rust/commit/f578cd21823484cc1ee8e4273cd5c2f837934f34"}, {"sha": "7a862f0d47e8ae018d449a04c918ea3705785552", "url": "https://api.github.com/repos/rust-lang/rust/commits/7a862f0d47e8ae018d449a04c918ea3705785552", "html_url": "https://github.com/rust-lang/rust/commit/7a862f0d47e8ae018d449a04c918ea3705785552"}], "stats": {"total": 388, "additions": 210, "deletions": 178}, "files": [{"sha": "fca3a295099df43da265eec1babd7330d36f0f44", "filename": "crates/ra_hir/src/code_model.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6eab968c601637361e8fbd1ee93ded1b0d967bee/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6eab968c601637361e8fbd1ee93ded1b0d967bee/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model.rs?ref=6eab968c601637361e8fbd1ee93ded1b0d967bee", "patch": "@@ -221,7 +221,7 @@ impl Module {\n \n     pub fn impl_blocks(self, db: &impl DefDatabase) -> Vec<ImplBlock> {\n         let def_map = db.crate_def_map(self.id.krate);\n-        def_map[self.id.local_id].impls.iter().copied().map(ImplBlock::from).collect()\n+        def_map[self.id.local_id].scope.impls().map(ImplBlock::from).collect()\n     }\n \n     pub(crate) fn with_module_id(self, module_id: LocalModuleId) -> Module {"}, {"sha": "445d215b7b33c0995ded639ebd3b05d7b60dd93e", "filename": "crates/ra_hir_def/src/body.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6eab968c601637361e8fbd1ee93ded1b0d967bee/crates%2Fra_hir_def%2Fsrc%2Fbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6eab968c601637361e8fbd1ee93ded1b0d967bee/crates%2Fra_hir_def%2Fsrc%2Fbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fbody.rs?ref=6eab968c601637361e8fbd1ee93ded1b0d967bee", "patch": "@@ -17,7 +17,8 @@ use rustc_hash::FxHashMap;\n use crate::{\n     db::DefDatabase,\n     expr::{Expr, ExprId, Pat, PatId},\n-    nameres::{BuiltinShadowMode, CrateDefMap},\n+    item_scope::BuiltinShadowMode,\n+    nameres::CrateDefMap,\n     path::{ModPath, Path},\n     src::HasSource,\n     DefWithBodyId, HasModule, Lookup, ModuleDefId, ModuleId,"}, {"sha": "4488e85020e7fc018604122adb4692475c681045", "filename": "crates/ra_hir_def/src/child_by_source.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6eab968c601637361e8fbd1ee93ded1b0d967bee/crates%2Fra_hir_def%2Fsrc%2Fchild_by_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6eab968c601637361e8fbd1ee93ded1b0d967bee/crates%2Fra_hir_def%2Fsrc%2Fchild_by_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fchild_by_source.rs?ref=6eab968c601637361e8fbd1ee93ded1b0d967bee", "patch": "@@ -80,9 +80,9 @@ impl ChildBySource for ModuleId {\n \n         module_data.scope.declarations().for_each(|item| add_module_def(db, &mut res, item));\n \n-        for &impl_ in module_data.impls.iter() {\n-            let src = impl_.lookup(db).source(db);\n-            res[keys::IMPL].insert(src, impl_)\n+        for imp in module_data.scope.impls() {\n+            let src = imp.lookup(db).source(db);\n+            res[keys::IMPL].insert(src, imp)\n         }\n \n         res"}, {"sha": "6b9be8325d498f3e481273742a353772d242795c", "filename": "crates/ra_hir_def/src/item_scope.rs", "status": "added", "additions": 165, "deletions": 0, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/6eab968c601637361e8fbd1ee93ded1b0d967bee/crates%2Fra_hir_def%2Fsrc%2Fitem_scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6eab968c601637361e8fbd1ee93ded1b0d967bee/crates%2Fra_hir_def%2Fsrc%2Fitem_scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fitem_scope.rs?ref=6eab968c601637361e8fbd1ee93ded1b0d967bee", "patch": "@@ -0,0 +1,165 @@\n+//! Describes items defined or visible (ie, imported) in a certain scope.\n+//! This is shared between modules and blocks.\n+\n+use hir_expand::name::Name;\n+use once_cell::sync::Lazy;\n+use rustc_hash::FxHashMap;\n+\n+use crate::{per_ns::PerNs, BuiltinType, ImplId, LocalImportId, MacroDefId, ModuleDefId, TraitId};\n+\n+#[derive(Debug, Default, PartialEq, Eq)]\n+pub struct ItemScope {\n+    items: FxHashMap<Name, Resolution>,\n+    impls: Vec<ImplId>,\n+    /// Macros visible in current module in legacy textual scope\n+    ///\n+    /// For macros invoked by an unqualified identifier like `bar!()`, `legacy_macros` will be searched in first.\n+    /// If it yields no result, then it turns to module scoped `macros`.\n+    /// It macros with name qualified with a path like `crate::foo::bar!()`, `legacy_macros` will be skipped,\n+    /// and only normal scoped `macros` will be searched in.\n+    ///\n+    /// Note that this automatically inherit macros defined textually before the definition of module itself.\n+    ///\n+    /// Module scoped macros will be inserted into `items` instead of here.\n+    // FIXME: Macro shadowing in one module is not properly handled. Non-item place macros will\n+    // be all resolved to the last one defined if shadowing happens.\n+    legacy_macros: FxHashMap<Name, MacroDefId>,\n+}\n+\n+static BUILTIN_SCOPE: Lazy<FxHashMap<Name, Resolution>> = Lazy::new(|| {\n+    BuiltinType::ALL\n+        .iter()\n+        .map(|(name, ty)| {\n+            (name.clone(), Resolution { def: PerNs::types(ty.clone().into()), import: None })\n+        })\n+        .collect()\n+});\n+\n+/// Shadow mode for builtin type which can be shadowed by module.\n+#[derive(Debug, Copy, Clone, PartialEq, Eq)]\n+pub(crate) enum BuiltinShadowMode {\n+    // Prefer Module\n+    Module,\n+    // Prefer Other Types\n+    Other,\n+}\n+\n+/// Legacy macros can only be accessed through special methods like `get_legacy_macros`.\n+/// Other methods will only resolve values, types and module scoped macros only.\n+impl ItemScope {\n+    pub fn entries<'a>(&'a self) -> impl Iterator<Item = (&'a Name, &'a Resolution)> + 'a {\n+        //FIXME: shadowing\n+        self.items.iter().chain(BUILTIN_SCOPE.iter())\n+    }\n+\n+    pub fn declarations(&self) -> impl Iterator<Item = ModuleDefId> + '_ {\n+        self.entries()\n+            .filter_map(|(_name, res)| if res.import.is_none() { Some(res.def) } else { None })\n+            .flat_map(|per_ns| {\n+                per_ns.take_types().into_iter().chain(per_ns.take_values().into_iter())\n+            })\n+    }\n+\n+    pub fn impls(&self) -> impl Iterator<Item = ImplId> + ExactSizeIterator + '_ {\n+        self.impls.iter().copied()\n+    }\n+\n+    /// Iterate over all module scoped macros\n+    pub(crate) fn macros<'a>(&'a self) -> impl Iterator<Item = (&'a Name, MacroDefId)> + 'a {\n+        self.items\n+            .iter()\n+            .filter_map(|(name, res)| res.def.take_macros().map(|macro_| (name, macro_)))\n+    }\n+\n+    /// Iterate over all legacy textual scoped macros visible at the end of the module\n+    pub(crate) fn legacy_macros<'a>(&'a self) -> impl Iterator<Item = (&'a Name, MacroDefId)> + 'a {\n+        self.legacy_macros.iter().map(|(name, def)| (name, *def))\n+    }\n+\n+    /// Get a name from current module scope, legacy macros are not included\n+    pub(crate) fn get(&self, name: &Name, shadow: BuiltinShadowMode) -> Option<&Resolution> {\n+        match shadow {\n+            BuiltinShadowMode::Module => self.items.get(name).or_else(|| BUILTIN_SCOPE.get(name)),\n+            BuiltinShadowMode::Other => {\n+                let item = self.items.get(name);\n+                if let Some(res) = item {\n+                    if let Some(ModuleDefId::ModuleId(_)) = res.def.take_types() {\n+                        return BUILTIN_SCOPE.get(name).or(item);\n+                    }\n+                }\n+\n+                item.or_else(|| BUILTIN_SCOPE.get(name))\n+            }\n+        }\n+    }\n+\n+    pub(crate) fn traits<'a>(&'a self) -> impl Iterator<Item = TraitId> + 'a {\n+        self.items.values().filter_map(|r| match r.def.take_types() {\n+            Some(ModuleDefId::TraitId(t)) => Some(t),\n+            _ => None,\n+        })\n+    }\n+\n+    pub(crate) fn get_legacy_macro(&self, name: &Name) -> Option<MacroDefId> {\n+        self.legacy_macros.get(name).copied()\n+    }\n+\n+    pub(crate) fn define_impl(&mut self, imp: ImplId) {\n+        self.impls.push(imp)\n+    }\n+\n+    pub(crate) fn define_legacy_macro(&mut self, name: Name, mac: MacroDefId) {\n+        self.legacy_macros.insert(name, mac);\n+    }\n+\n+    pub(crate) fn push_res(\n+        &mut self,\n+        name: Name,\n+        res: &Resolution,\n+        import: Option<LocalImportId>,\n+    ) -> bool {\n+        let mut changed = false;\n+        let existing = self.items.entry(name.clone()).or_default();\n+\n+        if existing.def.types.is_none() && res.def.types.is_some() {\n+            existing.def.types = res.def.types;\n+            existing.import = import.or(res.import);\n+            changed = true;\n+        }\n+        if existing.def.values.is_none() && res.def.values.is_some() {\n+            existing.def.values = res.def.values;\n+            existing.import = import.or(res.import);\n+            changed = true;\n+        }\n+        if existing.def.macros.is_none() && res.def.macros.is_some() {\n+            existing.def.macros = res.def.macros;\n+            existing.import = import.or(res.import);\n+            changed = true;\n+        }\n+\n+        if existing.def.is_none()\n+            && res.def.is_none()\n+            && existing.import.is_none()\n+            && res.import.is_some()\n+        {\n+            existing.import = res.import;\n+        }\n+        changed\n+    }\n+\n+    pub(crate) fn collect_resolutions(&self) -> Vec<(Name, Resolution)> {\n+        self.items.iter().map(|(name, res)| (name.clone(), res.clone())).collect()\n+    }\n+\n+    pub(crate) fn collect_legacy_macros(&self) -> FxHashMap<Name, MacroDefId> {\n+        self.legacy_macros.clone()\n+    }\n+}\n+\n+#[derive(Debug, Clone, PartialEq, Eq, Default)]\n+pub struct Resolution {\n+    /// None for unresolved\n+    pub def: PerNs,\n+    /// ident by which this is imported into local scope.\n+    pub import: Option<LocalImportId>,\n+}"}, {"sha": "cef061837b6f9df804ecacf51902668f8425ee85", "filename": "crates/ra_hir_def/src/lang_item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6eab968c601637361e8fbd1ee93ded1b0d967bee/crates%2Fra_hir_def%2Fsrc%2Flang_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6eab968c601637361e8fbd1ee93ded1b0d967bee/crates%2Fra_hir_def%2Fsrc%2Flang_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Flang_item.rs?ref=6eab968c601637361e8fbd1ee93ded1b0d967bee", "patch": "@@ -81,7 +81,7 @@ impl LangItems {\n         // Look for impl targets\n         let def_map = db.crate_def_map(module.krate);\n         let module_data = &def_map[module.local_id];\n-        for &impl_block in module_data.impls.iter() {\n+        for impl_block in module_data.scope.impls() {\n             self.collect_lang_item(db, impl_block, LangItemTarget::ImplBlockId)\n         }\n "}, {"sha": "acd4f4af17b85052c8c7d4f4b88e2d2100d1fc44", "filename": "crates/ra_hir_def/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6eab968c601637361e8fbd1ee93ded1b0d967bee/crates%2Fra_hir_def%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6eab968c601637361e8fbd1ee93ded1b0d967bee/crates%2Fra_hir_def%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Flib.rs?ref=6eab968c601637361e8fbd1ee93ded1b0d967bee", "patch": "@@ -15,6 +15,7 @@ pub mod type_ref;\n pub mod builtin_type;\n pub mod diagnostics;\n pub mod per_ns;\n+pub mod item_scope;\n \n pub mod dyn_map;\n pub mod keys;"}, {"sha": "5d4ca73a398855f3f07816bd2473c56e4fe880b5", "filename": "crates/ra_hir_def/src/nameres.rs", "status": "modified", "additions": 4, "deletions": 108, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/6eab968c601637361e8fbd1ee93ded1b0d967bee/crates%2Fra_hir_def%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6eab968c601637361e8fbd1ee93ded1b0d967bee/crates%2Fra_hir_def%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres.rs?ref=6eab968c601637361e8fbd1ee93ded1b0d967bee", "patch": "@@ -57,8 +57,7 @@ mod tests;\n \n use std::sync::Arc;\n \n-use hir_expand::{diagnostics::DiagnosticSink, name::Name, InFile, MacroDefId};\n-use once_cell::sync::Lazy;\n+use hir_expand::{diagnostics::DiagnosticSink, name::Name, InFile};\n use ra_arena::Arena;\n use ra_db::{CrateId, Edition, FileId, FilePosition};\n use ra_prof::profile;\n@@ -69,12 +68,12 @@ use ra_syntax::{\n use rustc_hash::FxHashMap;\n \n use crate::{\n-    builtin_type::BuiltinType,\n     db::DefDatabase,\n+    item_scope::{BuiltinShadowMode, ItemScope},\n     nameres::{diagnostics::DefDiagnostic, path_resolution::ResolveMode},\n     path::ModPath,\n     per_ns::PerNs,\n-    AstId, ImplId, LocalImportId, LocalModuleId, ModuleDefId, ModuleId, TraitId,\n+    AstId, LocalModuleId, ModuleDefId, ModuleId,\n };\n \n /// Contains all top-level defs from a macro-expanded crate\n@@ -166,113 +165,10 @@ impl ModuleOrigin {\n pub struct ModuleData {\n     pub parent: Option<LocalModuleId>,\n     pub children: FxHashMap<Name, LocalModuleId>,\n-    pub scope: ModuleScope,\n+    pub scope: ItemScope,\n \n     /// Where does this module come from?\n     pub origin: ModuleOrigin,\n-\n-    pub impls: Vec<ImplId>,\n-}\n-\n-#[derive(Debug, Default, PartialEq, Eq)]\n-pub struct ModuleScope {\n-    items: FxHashMap<Name, Resolution>,\n-    /// Macros visable in current module in legacy textual scope\n-    ///\n-    /// For macros invoked by an unquatified identifier like `bar!()`, `legacy_macros` will be searched in first.\n-    /// If it yields no result, then it turns to module scoped `macros`.\n-    /// It macros with name quatified with a path like `crate::foo::bar!()`, `legacy_macros` will be skipped,\n-    /// and only normal scoped `macros` will be searched in.\n-    ///\n-    /// Note that this automatically inherit macros defined textually before the definition of module itself.\n-    ///\n-    /// Module scoped macros will be inserted into `items` instead of here.\n-    // FIXME: Macro shadowing in one module is not properly handled. Non-item place macros will\n-    // be all resolved to the last one defined if shadowing happens.\n-    legacy_macros: FxHashMap<Name, MacroDefId>,\n-}\n-\n-static BUILTIN_SCOPE: Lazy<FxHashMap<Name, Resolution>> = Lazy::new(|| {\n-    BuiltinType::ALL\n-        .iter()\n-        .map(|(name, ty)| {\n-            (name.clone(), Resolution { def: PerNs::types(ty.clone().into()), import: None })\n-        })\n-        .collect()\n-});\n-\n-/// Shadow mode for builtin type which can be shadowed by module.\n-#[derive(Debug, Copy, Clone, PartialEq, Eq)]\n-pub enum BuiltinShadowMode {\n-    // Prefer Module\n-    Module,\n-    // Prefer Other Types\n-    Other,\n-}\n-\n-/// Legacy macros can only be accessed through special methods like `get_legacy_macros`.\n-/// Other methods will only resolve values, types and module scoped macros only.\n-impl ModuleScope {\n-    pub fn entries<'a>(&'a self) -> impl Iterator<Item = (&'a Name, &'a Resolution)> + 'a {\n-        //FIXME: shadowing\n-        self.items.iter().chain(BUILTIN_SCOPE.iter())\n-    }\n-\n-    pub fn declarations(&self) -> impl Iterator<Item = ModuleDefId> + '_ {\n-        self.entries()\n-            .filter_map(|(_name, res)| if res.import.is_none() { Some(res.def) } else { None })\n-            .flat_map(|per_ns| {\n-                per_ns.take_types().into_iter().chain(per_ns.take_values().into_iter())\n-            })\n-    }\n-\n-    /// Iterate over all module scoped macros\n-    pub fn macros<'a>(&'a self) -> impl Iterator<Item = (&'a Name, MacroDefId)> + 'a {\n-        self.items\n-            .iter()\n-            .filter_map(|(name, res)| res.def.take_macros().map(|macro_| (name, macro_)))\n-    }\n-\n-    /// Iterate over all legacy textual scoped macros visable at the end of the module\n-    pub fn legacy_macros<'a>(&'a self) -> impl Iterator<Item = (&'a Name, MacroDefId)> + 'a {\n-        self.legacy_macros.iter().map(|(name, def)| (name, *def))\n-    }\n-\n-    /// Get a name from current module scope, legacy macros are not included\n-    pub fn get(&self, name: &Name, shadow: BuiltinShadowMode) -> Option<&Resolution> {\n-        match shadow {\n-            BuiltinShadowMode::Module => self.items.get(name).or_else(|| BUILTIN_SCOPE.get(name)),\n-            BuiltinShadowMode::Other => {\n-                let item = self.items.get(name);\n-                if let Some(res) = item {\n-                    if let Some(ModuleDefId::ModuleId(_)) = res.def.take_types() {\n-                        return BUILTIN_SCOPE.get(name).or(item);\n-                    }\n-                }\n-\n-                item.or_else(|| BUILTIN_SCOPE.get(name))\n-            }\n-        }\n-    }\n-\n-    pub fn traits<'a>(&'a self) -> impl Iterator<Item = TraitId> + 'a {\n-        self.items.values().filter_map(|r| match r.def.take_types() {\n-            Some(ModuleDefId::TraitId(t)) => Some(t),\n-            _ => None,\n-        })\n-    }\n-\n-    fn get_legacy_macro(&self, name: &Name) -> Option<MacroDefId> {\n-        self.legacy_macros.get(name).copied()\n-    }\n-}\n-\n-#[derive(Debug, Clone, PartialEq, Eq, Default)]\n-pub struct Resolution {\n-    /// None for unresolved\n-    pub def: PerNs,\n-    /// ident by which this is imported into local scope.\n-    pub import: Option<LocalImportId>,\n }\n \n impl CrateDefMap {"}, {"sha": "8b641d8b561519f0d5d5a4376c601506af2fe13a", "filename": "crates/ra_hir_def/src/nameres/collector.rs", "status": "modified", "additions": 17, "deletions": 44, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/6eab968c601637361e8fbd1ee93ded1b0d967bee/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6eab968c601637361e8fbd1ee93ded1b0d967bee/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs?ref=6eab968c601637361e8fbd1ee93ded1b0d967bee", "patch": "@@ -18,9 +18,10 @@ use test_utils::tested_by;\n use crate::{\n     attr::Attrs,\n     db::DefDatabase,\n+    item_scope::Resolution,\n     nameres::{\n         diagnostics::DefDiagnostic, mod_resolution::ModDir, path_resolution::ReachedFixedPoint,\n-        raw, BuiltinShadowMode, CrateDefMap, ModuleData, ModuleOrigin, Resolution, ResolveMode,\n+        raw, BuiltinShadowMode, CrateDefMap, ModuleData, ModuleOrigin, ResolveMode,\n     },\n     path::{ModPath, PathKind},\n     per_ns::PerNs,\n@@ -225,14 +226,14 @@ where\n \n     /// Define a legacy textual scoped macro in module\n     ///\n-    /// We use a map `legacy_macros` to store all legacy textual scoped macros visable per module.\n+    /// We use a map `legacy_macros` to store all legacy textual scoped macros visible per module.\n     /// It will clone all macros from parent legacy scope, whose definition is prior to\n     /// the definition of current module.\n-    /// And also, `macro_use` on a module will import all legacy macros visable inside to\n+    /// And also, `macro_use` on a module will import all legacy macros visible inside to\n     /// current legacy scope, with possible shadowing.\n-    fn define_legacy_macro(&mut self, module_id: LocalModuleId, name: Name, macro_: MacroDefId) {\n+    fn define_legacy_macro(&mut self, module_id: LocalModuleId, name: Name, mac: MacroDefId) {\n         // Always shadowing\n-        self.def_map.modules[module_id].scope.legacy_macros.insert(name, macro_);\n+        self.def_map.modules[module_id].scope.define_legacy_macro(name, mac);\n     }\n \n     /// Import macros from `#[macro_use] extern crate`.\n@@ -371,11 +372,7 @@ where\n                         let scope = &item_map[m.local_id].scope;\n \n                         // Module scoped macros is included\n-                        let items = scope\n-                            .items\n-                            .iter()\n-                            .map(|(name, res)| (name.clone(), res.clone()))\n-                            .collect::<Vec<_>>();\n+                        let items = scope.collect_resolutions();\n \n                         self.update(module_id, Some(import_id), &items);\n                     } else {\n@@ -385,11 +382,7 @@ where\n                         let scope = &self.def_map[m.local_id].scope;\n \n                         // Module scoped macros is included\n-                        let items = scope\n-                            .items\n-                            .iter()\n-                            .map(|(name, res)| (name.clone(), res.clone()))\n-                            .collect::<Vec<_>>();\n+                        let items = scope.collect_resolutions();\n \n                         self.update(module_id, Some(import_id), &items);\n                         // record the glob import in case we add further items\n@@ -466,34 +459,10 @@ where\n             // prevent stack overflows (but this shouldn't be possible)\n             panic!(\"infinite recursion in glob imports!\");\n         }\n-        let module_items = &mut self.def_map.modules[module_id].scope;\n+        let scope = &mut self.def_map.modules[module_id].scope;\n         let mut changed = false;\n         for (name, res) in resolutions {\n-            let existing = module_items.items.entry(name.clone()).or_default();\n-\n-            if existing.def.types.is_none() && res.def.types.is_some() {\n-                existing.def.types = res.def.types;\n-                existing.import = import.or(res.import);\n-                changed = true;\n-            }\n-            if existing.def.values.is_none() && res.def.values.is_some() {\n-                existing.def.values = res.def.values;\n-                existing.import = import.or(res.import);\n-                changed = true;\n-            }\n-            if existing.def.macros.is_none() && res.def.macros.is_some() {\n-                existing.def.macros = res.def.macros;\n-                existing.import = import.or(res.import);\n-                changed = true;\n-            }\n-\n-            if existing.def.is_none()\n-                && res.def.is_none()\n-                && existing.import.is_none()\n-                && res.import.is_some()\n-            {\n-                existing.import = res.import;\n-            }\n+            changed |= scope.push_res(name.clone(), res, import);\n         }\n \n         if !changed {\n@@ -666,7 +635,9 @@ where\n                         let impl_id =\n                             ImplLoc { container, ast_id: AstId::new(self.file_id, ast_id) }\n                                 .intern(self.def_collector.db);\n-                        self.def_collector.def_map.modules[self.module_id].impls.push(impl_id)\n+                        self.def_collector.def_map.modules[self.module_id]\n+                            .scope\n+                            .define_impl(impl_id)\n                     }\n                 }\n             }\n@@ -740,7 +711,9 @@ where\n         let res = modules.alloc(ModuleData::default());\n         modules[res].parent = Some(self.module_id);\n         modules[res].origin = ModuleOrigin::not_sure_file(definition, declaration);\n-        modules[res].scope.legacy_macros = modules[self.module_id].scope.legacy_macros.clone();\n+        for (name, mac) in modules[self.module_id].scope.collect_legacy_macros() {\n+            modules[res].scope.define_legacy_macro(name, mac)\n+        }\n         modules[self.module_id].children.insert(name.clone(), res);\n         let resolution = Resolution {\n             def: PerNs::types(\n@@ -904,7 +877,7 @@ where\n     }\n \n     fn import_all_legacy_macros(&mut self, module_id: LocalModuleId) {\n-        let macros = self.def_collector.def_map[module_id].scope.legacy_macros.clone();\n+        let macros = self.def_collector.def_map[module_id].scope.collect_legacy_macros();\n         for (name, macro_) in macros {\n             self.def_collector.define_legacy_macro(self.module_id, name.clone(), macro_);\n         }"}, {"sha": "4e968bcc842dfa079f1a792d72a082dafb1219f0", "filename": "crates/ra_hir_def/src/nameres/tests.rs", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/6eab968c601637361e8fbd1ee93ded1b0d967bee/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6eab968c601637361e8fbd1ee93ded1b0d967bee/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests.rs?ref=6eab968c601637361e8fbd1ee93ded1b0d967bee", "patch": "@@ -32,27 +32,22 @@ fn render_crate_def_map(map: &CrateDefMap) -> String {\n         *buf += path;\n         *buf += \"\\n\";\n \n-        let mut entries = map.modules[module]\n-            .scope\n-            .items\n-            .iter()\n-            .map(|(name, res)| (name, res.def))\n-            .collect::<Vec<_>>();\n-        entries.sort_by_key(|(name, _)| *name);\n+        let mut entries = map.modules[module].scope.collect_resolutions();\n+        entries.sort_by_key(|(name, _)| name.clone());\n \n         for (name, res) in entries {\n             *buf += &format!(\"{}:\", name);\n \n-            if res.types.is_some() {\n+            if res.def.types.is_some() {\n                 *buf += \" t\";\n             }\n-            if res.values.is_some() {\n+            if res.def.values.is_some() {\n                 *buf += \" v\";\n             }\n-            if res.macros.is_some() {\n+            if res.def.macros.is_some() {\n                 *buf += \" m\";\n             }\n-            if res.is_none() {\n+            if res.def.is_none() {\n                 *buf += \" _\";\n             }\n \n@@ -587,6 +582,6 @@ mod b {\n     \u22eeT: v\n     \u22ee\n     \u22eecrate::a\n-    \u22eeT: t v    \n+    \u22eeT: t v\n \"###);\n }"}, {"sha": "ef2e9435cf64b4f57926e25d65d0167accde5afd", "filename": "crates/ra_hir_def/src/nameres/tests/incremental.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6eab968c601637361e8fbd1ee93ded1b0d967bee/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests%2Fincremental.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6eab968c601637361e8fbd1ee93ded1b0d967bee/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests%2Fincremental.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests%2Fincremental.rs?ref=6eab968c601637361e8fbd1ee93ded1b0d967bee", "patch": "@@ -116,7 +116,7 @@ fn typing_inside_a_macro_should_not_invalidate_def_map() {\n         let events = db.log_executed(|| {\n             let crate_def_map = db.crate_def_map(krate);\n             let (_, module_data) = crate_def_map.modules.iter().last().unwrap();\n-            assert_eq!(module_data.scope.items.len(), 1);\n+            assert_eq!(module_data.scope.collect_resolutions().len(), 1);\n         });\n         assert!(format!(\"{:?}\", events).contains(\"crate_def_map\"), \"{:#?}\", events)\n     }\n@@ -126,7 +126,7 @@ fn typing_inside_a_macro_should_not_invalidate_def_map() {\n         let events = db.log_executed(|| {\n             let crate_def_map = db.crate_def_map(krate);\n             let (_, module_data) = crate_def_map.modules.iter().last().unwrap();\n-            assert_eq!(module_data.scope.items.len(), 1);\n+            assert_eq!(module_data.scope.collect_resolutions().len(), 1);\n         });\n         assert!(!format!(\"{:?}\", events).contains(\"crate_def_map\"), \"{:#?}\", events)\n     }"}, {"sha": "d104f5993fe3aecd71f29df183a3744a43a62fa0", "filename": "crates/ra_hir_def/src/nameres/tests/macros.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6eab968c601637361e8fbd1ee93ded1b0d967bee/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6eab968c601637361e8fbd1ee93ded1b0d967bee/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs?ref=6eab968c601637361e8fbd1ee93ded1b0d967bee", "patch": "@@ -610,7 +610,7 @@ fn expand_derive() {\n         struct Foo;\n         \",\n     );\n-    assert_eq!(map.modules[map.root].impls.len(), 1);\n+    assert_eq!(map.modules[map.root].scope.impls().len(), 1);\n }\n \n #[test]\n@@ -622,5 +622,5 @@ fn expand_multiple_derive() {\n         struct Foo;\n         \",\n     );\n-    assert_eq!(map.modules[map.root].impls.len(), 2);\n+    assert_eq!(map.modules[map.root].scope.impls().len(), 2);\n }"}, {"sha": "83013fed3d5b61cf0480bf77ccd0851eeb45222f", "filename": "crates/ra_hir_def/src/resolver.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6eab968c601637361e8fbd1ee93ded1b0d967bee/crates%2Fra_hir_def%2Fsrc%2Fresolver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6eab968c601637361e8fbd1ee93ded1b0d967bee/crates%2Fra_hir_def%2Fsrc%2Fresolver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fresolver.rs?ref=6eab968c601637361e8fbd1ee93ded1b0d967bee", "patch": "@@ -14,7 +14,8 @@ use crate::{\n     db::DefDatabase,\n     expr::{ExprId, PatId},\n     generics::GenericParams,\n-    nameres::{BuiltinShadowMode, CrateDefMap},\n+    item_scope::BuiltinShadowMode,\n+    nameres::CrateDefMap,\n     path::{ModPath, PathKind},\n     per_ns::PerNs,\n     AdtId, AssocContainerId, ConstId, ContainerId, DefWithBodyId, EnumId, EnumVariantId,"}, {"sha": "888dc311662758c9ee9eb229fc3e656985a08478", "filename": "crates/ra_hir_ty/src/method_resolution.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6eab968c601637361e8fbd1ee93ded1b0d967bee/crates%2Fra_hir_ty%2Fsrc%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6eab968c601637361e8fbd1ee93ded1b0d967bee/crates%2Fra_hir_ty%2Fsrc%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fmethod_resolution.rs?ref=6eab968c601637361e8fbd1ee93ded1b0d967bee", "patch": "@@ -58,7 +58,7 @@ impl CrateImplBlocks {\n \n         let crate_def_map = db.crate_def_map(krate);\n         for (_module_id, module_data) in crate_def_map.modules.iter() {\n-            for &impl_id in module_data.impls.iter() {\n+            for impl_id in module_data.scope.impls() {\n                 match db.impl_trait(impl_id) {\n                     Some(tr) => {\n                         res.impls_by_trait.entry(tr.trait_).or_default().push(impl_id);"}, {"sha": "1a31b587bbc3b4bb5b1e5cc04afe2ddbe5a4a08f", "filename": "crates/ra_hir_ty/src/test_db.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6eab968c601637361e8fbd1ee93ded1b0d967bee/crates%2Fra_hir_ty%2Fsrc%2Ftest_db.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6eab968c601637361e8fbd1ee93ded1b0d967bee/crates%2Fra_hir_ty%2Fsrc%2Ftest_db.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftest_db.rs?ref=6eab968c601637361e8fbd1ee93ded1b0d967bee", "patch": "@@ -98,7 +98,7 @@ impl TestDB {\n                     }\n                 }\n \n-                for &impl_id in crate_def_map[module_id].impls.iter() {\n+                for impl_id in crate_def_map[module_id].scope.impls() {\n                     let impl_data = self.impl_data(impl_id);\n                     for item in impl_data.items.iter() {\n                         if let AssocItemId::FunctionId(f) = item {"}, {"sha": "d447b4571832c5e9cf6a3b5ad07ba2b6cc9330ea", "filename": "crates/ra_hir_ty/src/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6eab968c601637361e8fbd1ee93ded1b0d967bee/crates%2Fra_hir_ty%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6eab968c601637361e8fbd1ee93ded1b0d967bee/crates%2Fra_hir_ty%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests.rs?ref=6eab968c601637361e8fbd1ee93ded1b0d967bee", "patch": "@@ -182,7 +182,7 @@ fn visit_module(\n             _ => (),\n         }\n     }\n-    for &impl_id in crate_def_map[module_id].impls.iter() {\n+    for impl_id in crate_def_map[module_id].scope.impls() {\n         let impl_data = db.impl_data(impl_id);\n         for &item in impl_data.items.iter() {\n             match item {"}]}