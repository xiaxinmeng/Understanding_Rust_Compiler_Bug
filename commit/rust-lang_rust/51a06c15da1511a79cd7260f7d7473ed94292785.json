{"sha": "51a06c15da1511a79cd7260f7d7473ed94292785", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUxYTA2YzE1ZGExNTExYTc5Y2Q3MjYwZjdkNzQ3M2VkOTQyOTI3ODU=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-07-30T23:33:02Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-07-31T02:37:20Z"}, "message": "libsyntax: Parse self types in methods", "tree": {"sha": "868d622154bb09cd47583b679f8a9af78285220e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/868d622154bb09cd47583b679f8a9af78285220e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/51a06c15da1511a79cd7260f7d7473ed94292785", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/51a06c15da1511a79cd7260f7d7473ed94292785", "html_url": "https://github.com/rust-lang/rust/commit/51a06c15da1511a79cd7260f7d7473ed94292785", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/51a06c15da1511a79cd7260f7d7473ed94292785/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "290f079474670a14168104af5e3a32ff49abfae9", "url": "https://api.github.com/repos/rust-lang/rust/commits/290f079474670a14168104af5e3a32ff49abfae9", "html_url": "https://github.com/rust-lang/rust/commit/290f079474670a14168104af5e3a32ff49abfae9"}], "stats": {"total": 191, "additions": 174, "deletions": 17}, "files": [{"sha": "8210f0734ac23472abd83fa2443f74c1adb4f6d7", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/51a06c15da1511a79cd7260f7d7473ed94292785/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51a06c15da1511a79cd7260f7d7473ed94292785/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=51a06c15da1511a79cd7260f7d7473ed94292785", "patch": "@@ -19,7 +19,6 @@ import std::serialization::{serializer,\n                             deserialize_bool};\n import parse::token;\n \n-\n /* Note #1972 -- spans are serialized but not deserialized */\n fn serialize_span<S>(_s: S, _v: span) {\n }\n@@ -589,9 +588,21 @@ enum ret_style {\n     return_val, // everything else\n }\n \n+#[auto_serialize]\n+enum self_ty_ {\n+    sty_by_ref,                         // old by-reference self: ``\n+    sty_value,                          // by-value self: `self`\n+    sty_region(@region, mutability),    // by-region self: `&self`\n+    sty_box(mutability),                // by-managed-pointer self: `@self`\n+    sty_uniq(mutability)                // by-unique-pointer self: `~self`\n+}\n+\n+#[auto_serialize]\n+type self_ty = spanned<self_ty_>;\n+\n #[auto_serialize]\n type method = {ident: ident, attrs: ~[attribute],\n-               tps: ~[ty_param], decl: fn_decl, body: blk,\n+               tps: ~[ty_param], self_ty: self_ty, decl: fn_decl, body: blk,\n                id: node_id, span: span, self_id: node_id,\n                vis: visibility};  // always public, unless it's a\n                                   // class method"}, {"sha": "d1fea34513b2eb053727932aff69decadf8b08e2", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/51a06c15da1511a79cd7260f7d7473ed94292785/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51a06c15da1511a79cd7260f7d7473ed94292785/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=51a06c15da1511a79cd7260f7d7473ed94292785", "patch": "@@ -297,6 +297,7 @@ fn noop_fold_method(&&m: @method, fld: ast_fold) -> @method {\n     ret @{ident: fld.fold_ident(m.ident),\n           attrs: /* FIXME (#2543) */ copy m.attrs,\n           tps: fold_ty_params(m.tps, fld),\n+          self_ty: m.self_ty,\n           decl: fold_fn_decl(m.decl, fld),\n           body: fld.fold_block(m.body),\n           id: fld.new_id(m.id),"}, {"sha": "c747c8e9165df8969f7fead28fd763b047a6a906", "filename": "src/libsyntax/parse/common.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/51a06c15da1511a79cd7260f7d7473ed94292785/src%2Flibsyntax%2Fparse%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51a06c15da1511a79cd7260f7d7473ed94292785/src%2Flibsyntax%2Fparse%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcommon.rs?ref=51a06c15da1511a79cd7260f7d7473ed94292785", "patch": "@@ -117,14 +117,18 @@ impl parser_common of parser_common for parser {\n         }\n     }\n \n-    fn token_is_keyword(word: ~str, ++tok: token::token) -> bool {\n-        self.require_keyword(word);\n+    fn token_is_word(word: ~str, ++tok: token::token) -> bool {\n         alt tok {\n-          token::IDENT(sid, false) { str::eq(word, *self.get_str(sid)) }\n-          _ { false }\n+          token::IDENT(sid, false) => { str::eq(word, *self.get_str(sid)) }\n+          _ => { false }\n         }\n     }\n \n+    fn token_is_keyword(word: ~str, ++tok: token::token) -> bool {\n+        self.require_keyword(word);\n+        self.token_is_word(word, tok)\n+    }\n+\n     fn is_keyword(word: ~str) -> bool {\n         self.token_is_keyword(word, self.token)\n     }"}, {"sha": "f7b899cca955970b890290ee646f49f3fb43808f", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 152, "deletions": 11, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/51a06c15da1511a79cd7260f7d7473ed94292785/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51a06c15da1511a79cd7260f7d7473ed94292785/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=51a06c15da1511a79cd7260f7d7473ed94292785", "patch": "@@ -45,13 +45,14 @@ import ast::{_mod, add, alt_check, alt_exhaustive, arg, arm, attribute,\n              pat_range, pat_rec, pat_tup, pat_uniq, pat_wild, path, private,\n              proto, proto_any, proto_bare, proto_block, proto_box, proto_uniq,\n              provided, public, pure_fn, purity, re_anon, re_named, region,\n-             rem, required, ret_style, return_val, shl, shr, stmt, stmt_decl,\n-             stmt_expr, stmt_semi, subtract, token_tree, trait_method,\n-             trait_ref, tt_delim, tt_seq, tt_tok, tt_nonterminal, ty,\n-             ty_, ty_bot, ty_box, ty_field, ty_fn, ty_infer, ty_mac,\n-             ty_method, ty_nil, ty_param, ty_path, ty_ptr, ty_rec, ty_rptr,\n-             ty_tup, ty_u32, ty_uniq, ty_vec, ty_fixed_length, unchecked_blk,\n-             uniq, unsafe_blk, unsafe_fn, variant, view_item, view_item_,\n+             rem, required, ret_style, return_val, self_ty, shl, shr, stmt,\n+             stmt_decl, stmt_expr, stmt_semi, subtract, sty_box, sty_by_ref,\n+             sty_region, sty_uniq, sty_value, token_tree, trait_method,\n+             trait_ref, tt_delim, tt_seq, tt_tok, tt_nonterminal, ty, ty_,\n+             ty_bot, ty_box, ty_field, ty_fn, ty_infer, ty_mac, ty_method,\n+             ty_nil, ty_param, ty_path, ty_ptr, ty_rec, ty_rptr, ty_tup,\n+             ty_u32, ty_uniq, ty_vec, ty_fixed_length, unchecked_blk, uniq,\n+             unsafe_blk, unsafe_fn, variant, view_item, view_item_,\n              view_item_export, view_item_import, view_item_use, view_path,\n              view_path_glob, view_path_list, view_path_simple, visibility,\n              vstore, vstore_box, vstore_fixed, vstore_slice, vstore_uniq};\n@@ -273,7 +274,8 @@ class parser {\n             let tps = p.parse_ty_params();\n             let d = p.parse_ty_fn_decl(pur);\n             let hi = p.last_span.hi;\n-            debug!{\"parse_trait_methods(): trait method signature ends in \\\n+            let self_ty = spanned(lo, hi, sty_by_ref);  // XXX: Wrong.\n+            debug![\"parse_trait_methods(): trait method signature ends in \\\n                     `%s`\",\n                    token_to_str(p.reader, p.token)};\n             alt p.token {\n@@ -294,6 +296,7 @@ class parser {\n                 provided(@{ident: ident,\n                            attrs: attrs,\n                            tps: tps,\n+                           self_ty: self_ty,\n                            decl: d,\n                            body: body,\n                            id: p.get_id(),\n@@ -1978,6 +1981,142 @@ class parser {\n               cf: ret_style}, capture_clause);\n     }\n \n+    fn is_self_ident() -> bool {\n+        alt self.token {\n+            token::IDENT(sid, false) if str::eq(~\"self\", *self.get_str(sid)) {\n+                true\n+            }\n+            _ => {\n+                false\n+            }\n+        }\n+    }\n+\n+    fn expect_self_ident() {\n+        if !self.is_self_ident() {\n+            self.fatal(#fmt(\"expected `self` but found `%s`\",\n+                            token_to_str(self.reader, self.token)));\n+        }\n+        self.bump();\n+    }\n+\n+    fn parse_fn_decl_with_self(purity: purity,\n+                               parse_arg_fn:\n+                                    fn(parser) -> arg_or_capture_item)\n+                            -> (self_ty, fn_decl, capture_clause) {\n+\n+        self.expect(token::LPAREN);\n+\n+        // A bit of complexity and lookahead is needed here in order to to be\n+        // backwards compatible.\n+        let lo = self.span.lo;\n+        let self_ty;\n+        alt copy self.token {\n+            token::BINOP(token::AND) => {\n+                // We need to make sure it isn't a mode.\n+                self.bump();\n+                if self.token_is_keyword(~\"self\", self.look_ahead(1)) ||\n+                    ((self.token_is_keyword(~\"const\", self.look_ahead(1)) ||\n+                      self.token_is_keyword(~\"mut\", self.look_ahead(1))) &&\n+                      self.token_is_keyword(~\"self\", self.look_ahead(2))) {\n+\n+                    self.bump();\n+                    let mutability = self.parse_mutability();\n+                    self.expect_self_ident();\n+\n+                    // Parse an explicit region, if possible.\n+                    let region_name;\n+                    alt copy self.token {\n+                        token::BINOP(token::SLASH) => {\n+                            self.bump();\n+                            alt copy self.token {\n+                                token::IDENT(sid, false) => {\n+                                    self.bump();\n+                                    region_name = some(self.get_str(sid));\n+                                }\n+                                _ => {\n+                                    region_name = none;\n+                                }\n+                            }\n+                        }\n+                        _ => {\n+                            region_name = none;\n+                        }\n+                    }\n+\n+                    let region = self.region_from_name(region_name);\n+                    self_ty = sty_region(region, mutability);\n+                } else {\n+                    self_ty = sty_by_ref;\n+                }\n+            }\n+            token::AT => {\n+                self.bump();\n+                let mutability = self.parse_mutability();\n+                self.expect_self_ident();\n+                self_ty = sty_box(mutability);\n+            }\n+            token::TILDE => {\n+                self.bump();\n+                let mutability = self.parse_mutability();\n+                self.expect_self_ident();\n+                self_ty = sty_uniq(mutability);\n+            }\n+            token::IDENT(*) if self.is_self_ident() => {\n+                self.bump();\n+                self_ty = sty_value;\n+            }\n+            _ => {\n+                self_ty = sty_by_ref;\n+            }\n+        }\n+\n+        // If we parsed a self type, expect a comma before the argument list.\n+        let args_or_capture_items;\n+        if self_ty != sty_by_ref {\n+            alt copy self.token {\n+                token::COMMA => {\n+                    self.bump();\n+                    let sep = seq_sep_trailing_disallowed(token::COMMA);\n+                    args_or_capture_items =\n+                        self.parse_seq_to_before_end(token::RPAREN,\n+                                                     sep,\n+                                                     parse_arg_fn);\n+                }\n+                token::RPAREN => {\n+                    args_or_capture_items = ~[];\n+                }\n+                _ => {\n+                    self.fatal(~\"expected `,` or `)`, found `\" +\n+                               token_to_str(self.reader, self.token) + \"`\");\n+                }\n+            }\n+        } else {\n+            let sep = seq_sep_trailing_disallowed(token::COMMA);\n+            args_or_capture_items =\n+                self.parse_seq_to_before_end(token::RPAREN,\n+                                             sep,\n+                                             parse_arg_fn);\n+        }\n+\n+        self.expect(token::RPAREN);\n+\n+        let hi = self.span.hi;\n+\n+        let inputs = either::lefts(args_or_capture_items);\n+        let capture_clause = @either::rights(args_or_capture_items);\n+        let (ret_style, ret_ty) = self.parse_ret_ty();\n+\n+        let fn_decl = {\n+            inputs: inputs,\n+            output: ret_ty,\n+            purity: purity,\n+            cf: ret_style\n+        };\n+\n+        (spanned(lo, hi, self_ty), fn_decl, capture_clause)\n+    }\n+\n     fn parse_fn_block_decl() -> (fn_decl, capture_clause) {\n         let inputs_captures = {\n             if self.eat(token::OROR) {\n@@ -2049,11 +2188,13 @@ class parser {\n         let lo = self.span.lo, pur = self.parse_fn_purity();\n         let ident = self.parse_method_name();\n         let tps = self.parse_ty_params();\n-        let (decl, _) = self.parse_fn_decl(pur, |p| p.parse_arg());\n+        let (self_ty, decl, _) = do self.parse_fn_decl_with_self(pur) |p| {\n+            p.parse_arg()\n+        };\n         let (inner_attrs, body) = self.parse_inner_attrs_and_block(true);\n         let attrs = vec::append(attrs, inner_attrs);\n-        @{ident: ident, attrs: attrs, tps: tps, decl: decl, body: body,\n-          id: self.get_id(), span: mk_sp(lo, body.span.hi),\n+        @{ident: ident, attrs: attrs, tps: tps, self_ty: self_ty, decl: decl,\n+          body: body, id: self.get_id(), span: mk_sp(lo, body.span.hi),\n           self_id: self.get_id(), vis: pr}\n     }\n "}]}