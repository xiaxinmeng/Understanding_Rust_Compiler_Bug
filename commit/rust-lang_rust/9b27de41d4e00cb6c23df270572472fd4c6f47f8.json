{"sha": "9b27de41d4e00cb6c23df270572472fd4c6f47f8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjliMjdkZTQxZDRlMDBjYjZjMjNkZjI3MDU3MjQ3MmZkNGM2ZjQ3Zjg=", "commit": {"author": {"name": "John Renner", "email": "john@jrenner.net", "date": "2018-07-21T01:04:02Z"}, "committer": {"name": "John Renner", "email": "john@jrenner.net", "date": "2018-09-05T05:33:00Z"}, "message": "Introduce Custom Test Frameworks", "tree": {"sha": "9f51c7baf3dd1fe2b1d021007b36aa70fb36689d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9f51c7baf3dd1fe2b1d021007b36aa70fb36689d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9b27de41d4e00cb6c23df270572472fd4c6f47f8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9b27de41d4e00cb6c23df270572472fd4c6f47f8", "html_url": "https://github.com/rust-lang/rust/commit/9b27de41d4e00cb6c23df270572472fd4c6f47f8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9b27de41d4e00cb6c23df270572472fd4c6f47f8/comments", "author": {"login": "djrenren", "id": 634666, "node_id": "MDQ6VXNlcjYzNDY2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/634666?v=4", "gravatar_id": "", "url": "https://api.github.com/users/djrenren", "html_url": "https://github.com/djrenren", "followers_url": "https://api.github.com/users/djrenren/followers", "following_url": "https://api.github.com/users/djrenren/following{/other_user}", "gists_url": "https://api.github.com/users/djrenren/gists{/gist_id}", "starred_url": "https://api.github.com/users/djrenren/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/djrenren/subscriptions", "organizations_url": "https://api.github.com/users/djrenren/orgs", "repos_url": "https://api.github.com/users/djrenren/repos", "events_url": "https://api.github.com/users/djrenren/events{/privacy}", "received_events_url": "https://api.github.com/users/djrenren/received_events", "type": "User", "site_admin": false}, "committer": {"login": "djrenren", "id": 634666, "node_id": "MDQ6VXNlcjYzNDY2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/634666?v=4", "gravatar_id": "", "url": "https://api.github.com/users/djrenren", "html_url": "https://github.com/djrenren", "followers_url": "https://api.github.com/users/djrenren/followers", "following_url": "https://api.github.com/users/djrenren/following{/other_user}", "gists_url": "https://api.github.com/users/djrenren/gists{/gist_id}", "starred_url": "https://api.github.com/users/djrenren/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/djrenren/subscriptions", "organizations_url": "https://api.github.com/users/djrenren/orgs", "repos_url": "https://api.github.com/users/djrenren/repos", "events_url": "https://api.github.com/users/djrenren/events{/privacy}", "received_events_url": "https://api.github.com/users/djrenren/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0be2c303692cab31390e52701007cfa87867bf74", "url": "https://api.github.com/repos/rust-lang/rust/commits/0be2c303692cab31390e52701007cfa87867bf74", "html_url": "https://github.com/rust-lang/rust/commit/0be2c303692cab31390e52701007cfa87867bf74"}], "stats": {"total": 1378, "additions": 804, "deletions": 574}, "files": [{"sha": "a4f9082c284cd226770dfcf74e5e924f216d9b1b", "filename": "src/Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9b27de41d4e00cb6c23df270572472fd4c6f47f8/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/9b27de41d4e00cb6c23df270572472fd4c6f47f8/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=9b27de41d4e00cb6c23df270572472fd4c6f47f8", "patch": "@@ -2739,6 +2739,7 @@ name = \"syntax_ext\"\n version = \"0.0.0\"\n dependencies = [\n  \"fmt_macros 0.0.0\",\n+ \"log 0.4.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"proc_macro 0.0.0\",\n  \"rustc_data_structures 0.0.0\",\n  \"rustc_errors 0.0.0\","}, {"sha": "40662bafa1b39c598e28eb4394a5c8bebf226623", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 40, "deletions": 27, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/9b27de41d4e00cb6c23df270572472fd4c6f47f8/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b27de41d4e00cb6c23df270572472fd4c6f47f8/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=9b27de41d4e00cb6c23df270572472fd4c6f47f8", "patch": "@@ -1835,43 +1835,56 @@ impl EarlyLintPass for EllipsisInclusiveRangePatterns {\n }\n \n declare_lint! {\n-    UNNAMEABLE_TEST_FUNCTIONS,\n+    UNNAMEABLE_TEST_ITEMS,\n     Warn,\n-    \"detects an function that cannot be named being marked as #[test]\"\n+    \"detects an item that cannot be named being marked as #[test_case]\",\n+    report_in_external_macro: true\n+}\n+\n+pub struct UnnameableTestItems {\n+    boundary: ast::NodeId, // NodeId of the item under which things are not nameable\n+    items_nameable: bool,\n }\n \n-pub struct UnnameableTestFunctions;\n+impl UnnameableTestItems {\n+    pub fn new() -> Self {\n+        Self {\n+            boundary: ast::DUMMY_NODE_ID,\n+            items_nameable: true\n+        }\n+    }\n+}\n \n-impl LintPass for UnnameableTestFunctions {\n+impl LintPass for UnnameableTestItems {\n     fn get_lints(&self) -> LintArray {\n-        lint_array!(UNNAMEABLE_TEST_FUNCTIONS)\n+        lint_array!(UNNAMEABLE_TEST_ITEMS)\n     }\n }\n \n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnnameableTestFunctions {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnnameableTestItems {\n     fn check_item(&mut self, cx: &LateContext, it: &hir::Item) {\n-        match it.node {\n-            hir::ItemKind::Fn(..) => {\n-                for attr in &it.attrs {\n-                    if attr.name() == \"test\" {\n-                        let parent = cx.tcx.hir.get_parent(it.id);\n-                        match cx.tcx.hir.find(parent) {\n-                            Some(Node::Item(hir::Item {node: hir::ItemKind::Mod(_), ..})) |\n-                            None => {}\n-                            _ => {\n-                                cx.struct_span_lint(\n-                                    UNNAMEABLE_TEST_FUNCTIONS,\n-                                    attr.span,\n-                                    \"cannot test inner function\",\n-                                ).emit();\n-                            }\n-                        }\n-                        break;\n-                    }\n-                }\n+        if self.items_nameable {\n+            if let hir::ItemKind::Mod(..) = it.node {}\n+            else {\n+                self.items_nameable = false;\n+                self.boundary = it.id;\n             }\n-            _ => return,\n-        };\n+            return;\n+        }\n+\n+        if let Some(attr) = attr::find_by_name(&it.attrs, \"test_case\") {\n+            cx.struct_span_lint(\n+                UNNAMEABLE_TEST_ITEMS,\n+                attr.span,\n+                \"cannot test inner items\",\n+            ).emit();\n+        }\n+    }\n+\n+    fn check_item_post(&mut self, _cx: &LateContext, it: &hir::Item) {\n+        if !self.items_nameable && self.boundary == it.id {\n+            self.items_nameable = true;\n+        }\n     }\n }\n "}, {"sha": "2c32cbdd00f363019a5be05af46a20405fcf79cd", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b27de41d4e00cb6c23df270572472fd4c6f47f8/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b27de41d4e00cb6c23df270572472fd4c6f47f8/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=9b27de41d4e00cb6c23df270572472fd4c6f47f8", "patch": "@@ -149,7 +149,7 @@ pub fn register_builtins(store: &mut lint::LintStore, sess: Option<&Session>) {\n         MutableTransmutes: MutableTransmutes,\n         UnionsWithDropFields: UnionsWithDropFields,\n         UnreachablePub: UnreachablePub,\n-        UnnameableTestFunctions: UnnameableTestFunctions,\n+        UnnameableTestItems: UnnameableTestItems::new(),\n         TypeAliasBounds: TypeAliasBounds,\n         UnusedBrokenConst: UnusedBrokenConst,\n         TrivialConstraints: TrivialConstraints,"}, {"sha": "0d3e615b446fa00c981da47fbb6e6d84b79a8442", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9b27de41d4e00cb6c23df270572472fd4c6f47f8/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b27de41d4e00cb6c23df270572472fd4c6f47f8/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=9b27de41d4e00cb6c23df270572472fd4c6f47f8", "patch": "@@ -462,6 +462,10 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n             return def;\n         }\n \n+        if kind == MacroKind::Attr && *&path[0].as_str() == \"test\" {\n+            return Ok(self.macro_prelude.get(&path[0].name).unwrap().def())\n+        }\n+\n         let legacy_resolution = self.resolve_legacy_scope(&invocation.legacy_scope, path[0], false);\n         let result = if let Some((legacy_binding, _)) = legacy_resolution {\n             Ok(legacy_binding.def())"}, {"sha": "9851749be3765ff0ba8f7e6ba0ef1b9a7b220472", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b27de41d4e00cb6c23df270572472fd4c6f47f8/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b27de41d4e00cb6c23df270572472fd4c6f47f8/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=9b27de41d4e00cb6c23df270572472fd4c6f47f8", "patch": "@@ -1587,7 +1587,7 @@ impl TyKind {\n         if let TyKind::ImplicitSelf = *self { true } else { false }\n     }\n \n-    crate fn is_unit(&self) -> bool {\n+    pub fn is_unit(&self) -> bool {\n         if let TyKind::Tup(ref tys) = *self { tys.is_empty() } else { false }\n     }\n }"}, {"sha": "900d830b4c038dcdb32279ae70d34ecf2b0d7789", "filename": "src/libsyntax/config.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9b27de41d4e00cb6c23df270572472fd4c6f47f8/src%2Flibsyntax%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b27de41d4e00cb6c23df270572472fd4c6f47f8/src%2Flibsyntax%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fconfig.rs?ref=9b27de41d4e00cb6c23df270572472fd4c6f47f8", "patch": "@@ -119,7 +119,7 @@ impl<'a> StripUnconfigured<'a> {\n     pub fn in_cfg(&mut self, attrs: &[ast::Attribute]) -> bool {\n         attrs.iter().all(|attr| {\n             // When not compiling with --test we should not compile the #[test] functions\n-            if !self.should_test && is_test_or_bench(attr) {\n+            if !self.should_test && is_test(attr) {\n                 return false;\n             }\n \n@@ -249,7 +249,7 @@ impl<'a> StripUnconfigured<'a> {\n         //\n         // NB: This is intentionally not part of the fold_expr() function\n         //     in order for fold_opt_expr() to be able to avoid this check\n-        if let Some(attr) = expr.attrs().iter().find(|a| is_cfg(a) || is_test_or_bench(a)) {\n+        if let Some(attr) = expr.attrs().iter().find(|a| is_cfg(a) || is_test(a)) {\n             let msg = \"removing an expression is not supported in this position\";\n             self.sess.span_diagnostic.span_err(attr.span, msg);\n         }\n@@ -353,6 +353,6 @@ fn is_cfg(attr: &ast::Attribute) -> bool {\n     attr.check_name(\"cfg\")\n }\n \n-pub fn is_test_or_bench(attr: &ast::Attribute) -> bool {\n-    attr.check_name(\"test\") || attr.check_name(\"bench\")\n+pub fn is_test(att: &ast::Attribute) -> bool {\n+    att.check_name(\"test_case\")\n }"}, {"sha": "956e086b01beb94565074323e9a62ce1636f38de", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 10, "deletions": 38, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/9b27de41d4e00cb6c23df270572472fd4c6f47f8/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b27de41d4e00cb6c23df270572472fd4c6f47f8/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=9b27de41d4e00cb6c23df270572472fd4c6f47f8", "patch": "@@ -12,10 +12,9 @@ use ast::{self, Block, Ident, NodeId, PatKind, Path};\n use ast::{MacStmtStyle, StmtKind, ItemKind};\n use attr::{self, HasAttrs};\n use source_map::{ExpnInfo, MacroBang, MacroAttribute, dummy_spanned, respan};\n-use config::{is_test_or_bench, StripUnconfigured};\n+use config::StripUnconfigured;\n use errors::{Applicability, FatalError};\n use ext::base::*;\n-use ext::build::AstBuilder;\n use ext::derive::{add_derived_markers, collect_derives};\n use ext::hygiene::{self, Mark, SyntaxContext};\n use ext::placeholders::{placeholder, PlaceholderExpander};\n@@ -37,7 +36,6 @@ use visit::{self, Visitor};\n use rustc_data_structures::fx::FxHashMap;\n use std::fs::File;\n use std::io::Read;\n-use std::iter::FromIterator;\n use std::{iter, mem};\n use std::rc::Rc;\n use std::path::PathBuf;\n@@ -1366,51 +1364,25 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n                 self.cx.current_expansion.directory_ownership = orig_directory_ownership;\n                 result\n             }\n-            // Ensure that test functions are accessible from the test harness.\n+\n+            // Ensure that test items can be exported by the harness generator.\n             // #[test] fn foo() {}\n             // becomes:\n             // #[test] pub fn foo_gensym(){}\n-            // #[allow(unused)]\n-            // use foo_gensym as foo;\n-            ast::ItemKind::Fn(..) if self.cx.ecfg.should_test => {\n-                if self.tests_nameable && item.attrs.iter().any(|attr| is_test_or_bench(attr)) {\n-                    let orig_ident = item.ident;\n-                    let orig_vis   = item.vis.clone();\n-\n+              ast::ItemKind::Const(..)\n+            | ast::ItemKind::Static(..)\n+            | ast::ItemKind::Fn(..) if self.cx.ecfg.should_test => {\n+                if self.tests_nameable && attr::contains_name(&item.attrs, \"test_case\") {\n                     // Publicize the item under gensymed name to avoid pollution\n+                    // This means #[test_case] items can't be referenced by user code\n                     item = item.map(|mut item| {\n                         item.vis = respan(item.vis.span, ast::VisibilityKind::Public);\n                         item.ident = item.ident.gensym();\n                         item\n                     });\n-\n-                    // Use the gensymed name under the item's original visibility\n-                    let mut use_item = self.cx.item_use_simple_(\n-                        item.ident.span,\n-                        orig_vis,\n-                        Some(orig_ident),\n-                        self.cx.path(item.ident.span,\n-                            vec![keywords::SelfValue.ident(), item.ident]));\n-\n-                    // #[allow(unused)] because the test function probably isn't being referenced\n-                    use_item = use_item.map(|mut ui| {\n-                        ui.attrs.push(\n-                            self.cx.attribute(DUMMY_SP, attr::mk_list_item(DUMMY_SP,\n-                                Ident::from_str(\"allow\"), vec![\n-                                    attr::mk_nested_word_item(Ident::from_str(\"unused\"))\n-                                ]\n-                            ))\n-                        );\n-\n-                        ui\n-                    });\n-\n-                    OneVector::from_iter(\n-                        self.fold_unnameable(item).into_iter()\n-                            .chain(self.fold_unnameable(use_item)))\n-                } else {\n-                    self.fold_unnameable(item)\n                 }\n+\n+                self.fold_unnameable(item)\n             }\n             _ => self.fold_unnameable(item),\n         }"}, {"sha": "35cb5aa547554fd7f7bf2773f573f91e0abf8cca", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9b27de41d4e00cb6c23df270572472fd4c6f47f8/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b27de41d4e00cb6c23df270572472fd4c6f47f8/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=9b27de41d4e00cb6c23df270572472fd4c6f47f8", "patch": "@@ -515,6 +515,10 @@ declare_features! (\n \n     // unsized rvalues at arguments and parameters\n     (active, unsized_locals, \"1.30.0\", Some(48055), None),\n+\n+    // #![test_runner]\n+    // #[test_case]\n+    (active, custom_test_frameworks, \"1.30.0\", Some(50297), None),\n );\n \n declare_features! (\n@@ -775,6 +779,10 @@ pub const BUILTIN_ATTRIBUTES: &'static [(&'static str, AttributeType, AttributeG\n     (\"no_link\", Normal, Ungated),\n     (\"derive\", Normal, Ungated),\n     (\"should_panic\", Normal, Ungated),\n+    (\"test_case\", Normal, Gated(Stability::Unstable,\n+                                \"custom_test_frameworks\",\n+                                \"Custom test frameworks are experimental\",\n+                                cfg_fn!(custom_test_frameworks))),\n     (\"ignore\", Normal, Ungated),\n     (\"no_implicit_prelude\", Normal, Ungated),\n     (\"reexport_test_harness_main\", Normal, Ungated),\n@@ -1156,6 +1164,10 @@ pub const BUILTIN_ATTRIBUTES: &'static [(&'static str, AttributeType, AttributeG\n     (\"no_builtins\", CrateLevel, Ungated),\n     (\"recursion_limit\", CrateLevel, Ungated),\n     (\"type_length_limit\", CrateLevel, Ungated),\n+    (\"test_runner\", CrateLevel, Gated(Stability::Unstable,\n+                    \"custom_test_frameworks\",\n+                    \"Custom Test Frameworks is an unstable feature\",\n+                    cfg_fn!(custom_test_frameworks))),\n ];\n \n // cfg(...)'s that are feature gated"}, {"sha": "91c63227d305fe0b39ed7b7bfbe09485f9fb76c4", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 104, "deletions": 476, "changes": 580, "blob_url": "https://github.com/rust-lang/rust/blob/9b27de41d4e00cb6c23df270572472fd4c6f47f8/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b27de41d4e00cb6c23df270572472fd4c6f47f8/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=9b27de41d4e00cb6c23df270572472fd4c6f47f8", "patch": "@@ -22,7 +22,7 @@ use std::vec;\n use attr::{self, HasAttrs};\n use syntax_pos::{self, DUMMY_SP, NO_EXPANSION, Span, SourceFile, BytePos};\n \n-use source_map::{self, SourceMap, ExpnInfo, MacroAttribute, dummy_spanned};\n+use source_map::{self, SourceMap, ExpnInfo, MacroAttribute, dummy_spanned, respan};\n use errors;\n use config;\n use entry::{self, EntryPointType};\n@@ -43,29 +43,21 @@ use symbol::{self, Symbol, keywords};\n use ThinVec;\n use rustc_data_structures::small_vec::ExpectOne;\n \n-enum ShouldPanic {\n-    No,\n-    Yes(Option<Symbol>),\n-}\n-\n struct Test {\n     span: Span,\n-    path: Vec<Ident> ,\n-    bench: bool,\n-    ignore: bool,\n-    should_panic: ShouldPanic,\n-    allow_fail: bool,\n+    path: Vec<Ident>,\n }\n \n struct TestCtxt<'a> {\n     span_diagnostic: &'a errors::Handler,\n     path: Vec<Ident>,\n     ext_cx: ExtCtxt<'a>,\n-    testfns: Vec<Test>,\n+    test_cases: Vec<Test>,\n     reexport_test_harness_main: Option<Symbol>,\n     is_libtest: bool,\n     ctxt: SyntaxContext,\n     features: &'a Features,\n+    test_runner: Option<ast::Path>,\n \n     // top-level re-export submodule, filled out after folding is finished\n     toplevel_reexport: Option<Ident>,\n@@ -87,9 +79,13 @@ pub fn modify_for_testing(sess: &ParseSess,\n         attr::first_attr_value_str_by_name(&krate.attrs,\n                                            \"reexport_test_harness_main\");\n \n+    // Do this here so that the test_runner crate attribute gets marked as used\n+    // even in non-test builds\n+    let test_runner = get_test_runner(span_diagnostic, &krate);\n+\n     if should_test {\n         generate_test_harness(sess, resolver, reexport_test_harness_main,\n-                              krate, span_diagnostic, features)\n+                              krate, span_diagnostic, features, test_runner)\n     } else {\n         krate\n     }\n@@ -107,13 +103,13 @@ impl<'a> fold::Folder for TestHarnessGenerator<'a> {\n     fn fold_crate(&mut self, c: ast::Crate) -> ast::Crate {\n         let mut folded = fold::noop_fold_crate(c, self);\n \n-        // Add a special __test module to the crate that will contain code\n-        // generated for the test harness\n-        let (mod_, reexport) = mk_test_module(&mut self.cx);\n-        if let Some(re) = reexport {\n-            folded.module.items.push(re)\n-        }\n-        folded.module.items.push(mod_);\n+        // Create a main function to run our tests\n+        let test_main = {\n+            let unresolved = mk_main(&mut self.cx);\n+            self.cx.ext_cx.monotonic_expander().fold_item(unresolved).pop().unwrap()\n+        };\n+\n+        folded.module.items.push(test_main);\n         folded\n     }\n \n@@ -124,41 +120,18 @@ impl<'a> fold::Folder for TestHarnessGenerator<'a> {\n         }\n         debug!(\"current path: {}\", path_name_i(&self.cx.path));\n \n-        if is_test_fn(&self.cx, &i) || is_bench_fn(&self.cx, &i) {\n-            match i.node {\n-                ast::ItemKind::Fn(_, header, _, _) => {\n-                    if header.unsafety == ast::Unsafety::Unsafe {\n-                        let diag = self.cx.span_diagnostic;\n-                        diag.span_fatal(\n-                            i.span,\n-                            \"unsafe functions cannot be used for tests\"\n-                        ).raise();\n-                    }\n-                    if header.asyncness.is_async() {\n-                        let diag = self.cx.span_diagnostic;\n-                        diag.span_fatal(\n-                            i.span,\n-                            \"async functions cannot be used for tests\"\n-                        ).raise();\n-                    }\n-                }\n-                _ => {},\n-            }\n+        let mut item = i.into_inner();\n+        if is_test_case(&item) {\n+            debug!(\"this is a test item\");\n \n-            debug!(\"this is a test function\");\n             let test = Test {\n-                span: i.span,\n+                span: item.span,\n                 path: self.cx.path.clone(),\n-                bench: is_bench_fn(&self.cx, &i),\n-                ignore: is_ignored(&i),\n-                should_panic: should_panic(&i, &self.cx),\n-                allow_fail: is_allowed_fail(&i),\n             };\n-            self.cx.testfns.push(test);\n-            self.tests.push(i.ident);\n+            self.cx.test_cases.push(test);\n+            self.tests.push(item.ident);\n         }\n \n-        let mut item = i.into_inner();\n         // We don't want to recurse into anything other than mods, since\n         // mods or tests inside of functions will break things\n         if let ast::ItemKind::Mod(module) = item.node {\n@@ -190,6 +163,8 @@ impl<'a> fold::Folder for TestHarnessGenerator<'a> {\n     fn fold_mac(&mut self, mac: ast::Mac) -> ast::Mac { mac }\n }\n \n+/// A folder used to remove any entry points (like fn main) because the harness\n+/// generator will provide its own\n struct EntryPointCleaner {\n     // Current depth in the ast\n     depth: usize,\n@@ -242,6 +217,10 @@ impl fold::Folder for EntryPointCleaner {\n     fn fold_mac(&mut self, mac: ast::Mac) -> ast::Mac { mac }\n }\n \n+/// Creates an item (specifically a module) that \"pub use\"s the tests passed in.\n+/// Each tested submodule will contain a similar reexport module that we will export\n+/// under the name of the original module. That is, `submod::__test_reexports` is\n+/// reexported like so `pub use submod::__test_reexports as submod`.\n fn mk_reexport_mod(cx: &mut TestCtxt,\n                    parent: ast::NodeId,\n                    tests: Vec<Ident>,\n@@ -279,12 +258,14 @@ fn mk_reexport_mod(cx: &mut TestCtxt,\n     (it, sym)\n }\n \n+/// Crawl over the crate, inserting test reexports and the test main function\n fn generate_test_harness(sess: &ParseSess,\n                          resolver: &mut dyn Resolver,\n                          reexport_test_harness_main: Option<Symbol>,\n                          krate: ast::Crate,\n                          sd: &errors::Handler,\n-                         features: &Features) -> ast::Crate {\n+                         features: &Features,\n+                         test_runner: Option<ast::Path>) -> ast::Crate {\n     // Remove the entry points\n     let mut cleaner = EntryPointCleaner { depth: 0 };\n     let krate = cleaner.fold_crate(krate);\n@@ -298,19 +279,20 @@ fn generate_test_harness(sess: &ParseSess,\n         span_diagnostic: sd,\n         ext_cx: ExtCtxt::new(sess, econfig, resolver),\n         path: Vec::new(),\n-        testfns: Vec::new(),\n+        test_cases: Vec::new(),\n         reexport_test_harness_main,\n         // NB: doesn't consider the value of `--crate-name` passed on the command line.\n         is_libtest: attr::find_crate_name(&krate.attrs).map(|s| s == \"test\").unwrap_or(false),\n         toplevel_reexport: None,\n         ctxt: SyntaxContext::empty().apply_mark(mark),\n         features,\n+        test_runner\n     };\n \n     mark.set_expn_info(ExpnInfo {\n         call_site: DUMMY_SP,\n         def_site: None,\n-        format: MacroAttribute(Symbol::intern(\"test\")),\n+        format: MacroAttribute(Symbol::intern(\"test_case\")),\n         allow_internal_unstable: true,\n         allow_internal_unsafe: false,\n         local_inner_macros: false,\n@@ -344,288 +326,72 @@ enum BadTestSignature {\n     ShouldPanicOnlyWithNoArgs,\n }\n \n-fn is_test_fn(cx: &TestCtxt, i: &ast::Item) -> bool {\n-    let has_test_attr = attr::contains_name(&i.attrs, \"test\");\n-\n-    fn has_test_signature(_cx: &TestCtxt, i: &ast::Item) -> HasTestSignature {\n-        let has_should_panic_attr = attr::contains_name(&i.attrs, \"should_panic\");\n-        match i.node {\n-            ast::ItemKind::Fn(ref decl, _, ref generics, _) => {\n-                // If the termination trait is active, the compiler will check that the output\n-                // type implements the `Termination` trait as `libtest` enforces that.\n-                let has_output = match decl.output {\n-                    ast::FunctionRetTy::Default(..) => false,\n-                    ast::FunctionRetTy::Ty(ref t) if t.node.is_unit() => false,\n-                    _ => true\n-                };\n-\n-                if !decl.inputs.is_empty() {\n-                    return No(BadTestSignature::NoArgumentsAllowed);\n-                }\n-\n-                match (has_output, has_should_panic_attr) {\n-                    (true, true) => No(BadTestSignature::ShouldPanicOnlyWithNoArgs),\n-                    (true, false) => if !generics.params.is_empty() {\n-                        No(BadTestSignature::WrongTypeSignature)\n-                    } else {\n-                        Yes\n-                    },\n-                    (false, _) => Yes\n-                }\n-            }\n-            _ => No(BadTestSignature::NotEvenAFunction),\n-        }\n-    }\n-\n-    let has_test_signature = if has_test_attr {\n-        let diag = cx.span_diagnostic;\n-        match has_test_signature(cx, i) {\n-            Yes => true,\n-            No(cause) => {\n-                match cause {\n-                    BadTestSignature::NotEvenAFunction =>\n-                        diag.span_err(i.span, \"only functions may be used as tests\"),\n-                    BadTestSignature::WrongTypeSignature =>\n-                        diag.span_err(i.span,\n-                                      \"functions used as tests must have signature fn() -> ()\"),\n-                    BadTestSignature::NoArgumentsAllowed =>\n-                        diag.span_err(i.span, \"functions used as tests can not have any arguments\"),\n-                    BadTestSignature::ShouldPanicOnlyWithNoArgs =>\n-                        diag.span_err(i.span, \"functions using `#[should_panic]` must return `()`\"),\n-                }\n-                false\n-            }\n-        }\n-    } else {\n-        false\n-    };\n-\n-    has_test_attr && has_test_signature\n-}\n-\n-fn is_bench_fn(cx: &TestCtxt, i: &ast::Item) -> bool {\n-    let has_bench_attr = attr::contains_name(&i.attrs, \"bench\");\n-\n-    fn has_bench_signature(_cx: &TestCtxt, i: &ast::Item) -> bool {\n-        match i.node {\n-            ast::ItemKind::Fn(ref decl, _, _, _) => {\n-                // NB: inadequate check, but we're running\n-                // well before resolve, can't get too deep.\n-                decl.inputs.len() == 1\n-            }\n-            _ => false\n-        }\n-    }\n-\n-    let has_bench_signature = has_bench_signature(cx, i);\n-\n-    if has_bench_attr && !has_bench_signature {\n-        let diag = cx.span_diagnostic;\n-\n-        diag.span_err(i.span, \"functions used as benches must have signature \\\n-                                   `fn(&mut Bencher) -> impl Termination`\");\n-    }\n-\n-    has_bench_attr && has_bench_signature\n-}\n-\n-fn is_ignored(i: &ast::Item) -> bool {\n-    attr::contains_name(&i.attrs, \"ignore\")\n-}\n-\n-fn is_allowed_fail(i: &ast::Item) -> bool {\n-    attr::contains_name(&i.attrs, \"allow_fail\")\n-}\n-\n-fn should_panic(i: &ast::Item, cx: &TestCtxt) -> ShouldPanic {\n-    match attr::find_by_name(&i.attrs, \"should_panic\") {\n-        Some(attr) => {\n-            let sd = cx.span_diagnostic;\n-            if attr.is_value_str() {\n-                sd.struct_span_warn(\n-                    attr.span(),\n-                    \"attribute must be of the form: \\\n-                     `#[should_panic]` or \\\n-                     `#[should_panic(expected = \\\"error message\\\")]`\"\n-                ).note(\"Errors in this attribute were erroneously allowed \\\n-                        and will become a hard error in a future release.\")\n-                .emit();\n-                return ShouldPanic::Yes(None);\n-            }\n-            match attr.meta_item_list() {\n-                // Handle #[should_panic]\n-                None => ShouldPanic::Yes(None),\n-                // Handle #[should_panic(expected = \"foo\")]\n-                Some(list) => {\n-                    let msg = list.iter()\n-                        .find(|mi| mi.check_name(\"expected\"))\n-                        .and_then(|mi| mi.meta_item())\n-                        .and_then(|mi| mi.value_str());\n-                    if list.len() != 1 || msg.is_none() {\n-                        sd.struct_span_warn(\n-                            attr.span(),\n-                            \"argument must be of the form: \\\n-                             `expected = \\\"error message\\\"`\"\n-                        ).note(\"Errors in this attribute were erroneously \\\n-                                allowed and will become a hard error in a \\\n-                                future release.\").emit();\n-                        ShouldPanic::Yes(None)\n-                    } else {\n-                        ShouldPanic::Yes(msg)\n-                    }\n-                },\n-            }\n-        }\n-        None => ShouldPanic::No,\n-    }\n-}\n-\n-/*\n-\n-We're going to be building a module that looks more or less like:\n-\n-mod __test {\n-  extern crate test (name = \"test\", vers = \"...\");\n-  fn main() {\n-    test::test_main_static(&::os::args()[], tests, test::Options::new())\n-  }\n-\n-  static tests : &'static [test::TestDescAndFn] = &[\n-    ... the list of tests in the crate ...\n-  ];\n-}\n-\n-*/\n-\n-fn mk_std(cx: &TestCtxt) -> P<ast::Item> {\n-    let id_test = Ident::from_str(\"test\");\n-    let sp = ignored_span(cx, DUMMY_SP);\n-    let (vi, vis, ident) = if cx.is_libtest {\n-        (ast::ItemKind::Use(P(ast::UseTree {\n-            span: DUMMY_SP,\n-            prefix: path_node(vec![id_test]),\n-            kind: ast::UseTreeKind::Simple(None, ast::DUMMY_NODE_ID, ast::DUMMY_NODE_ID),\n-        })),\n-         ast::VisibilityKind::Public, keywords::Invalid.ident())\n-    } else {\n-        (ast::ItemKind::ExternCrate(None), ast::VisibilityKind::Inherited, id_test)\n-    };\n-    P(ast::Item {\n-        id: ast::DUMMY_NODE_ID,\n-        ident,\n-        node: vi,\n-        attrs: vec![],\n-        vis: dummy_spanned(vis),\n-        span: sp,\n-        tokens: None,\n-    })\n-}\n-\n+/// Creates a function item for use as the main function of a test build.\n+/// This function will call the `test_runner` as specified by the crate attribute\n fn mk_main(cx: &mut TestCtxt) -> P<ast::Item> {\n     // Writing this out by hand with 'ignored_span':\n     //        pub fn main() {\n     //            #![main]\n-    //            use std::slice::AsSlice;\n-    //            test::test_main_static(::std::os::args().as_slice(), TESTS, test::Options::new());\n+    //            test::test_main_static(::std::os::args().as_slice(), &[..tests]);\n     //        }\n-\n     let sp = ignored_span(cx, DUMMY_SP);\n     let ecx = &cx.ext_cx;\n-\n-    // test::test_main_static\n-    let test_main_path =\n-        ecx.path(sp, vec![Ident::from_str(\"test\"), Ident::from_str(\"test_main_static\")]);\n+    let test_id = ecx.ident_of(\"test\").gensym();\n \n     // test::test_main_static(...)\n-    let test_main_path_expr = ecx.expr_path(test_main_path);\n-    let tests_ident_expr = ecx.expr_ident(sp, Ident::from_str(\"TESTS\"));\n+    let mut test_runner = cx.test_runner.clone().unwrap_or(\n+        ecx.path(sp, vec![\n+            test_id, ecx.ident_of(\"test_main_static\")\n+        ]));\n+\n+    test_runner.span = sp;\n+\n+    let test_main_path_expr = ecx.expr_path(test_runner.clone());\n     let call_test_main = ecx.expr_call(sp, test_main_path_expr,\n-                                       vec![tests_ident_expr]);\n+                                       vec![mk_tests_slice(cx)]);\n     let call_test_main = ecx.stmt_expr(call_test_main);\n+\n     // #![main]\n     let main_meta = ecx.meta_word(sp, Symbol::intern(\"main\"));\n     let main_attr = ecx.attribute(sp, main_meta);\n+\n+    // extern crate test as test_gensym\n+    let test_extern_stmt = ecx.stmt_item(sp, ecx.item(sp,\n+        test_id,\n+        vec![],\n+        ast::ItemKind::ExternCrate(Some(Symbol::intern(\"test\")))\n+    ));\n+\n     // pub fn main() { ... }\n     let main_ret_ty = ecx.ty(sp, ast::TyKind::Tup(vec![]));\n-    let main_body = ecx.block(sp, vec![call_test_main]);\n+\n+    // If no test runner is provided we need to import the test crate\n+    let main_body = if cx.test_runner.is_none() {\n+        ecx.block(sp, vec![test_extern_stmt, call_test_main])\n+    } else {\n+        ecx.block(sp, vec![call_test_main])\n+    };\n+\n     let main = ast::ItemKind::Fn(ecx.fn_decl(vec![], ast::FunctionRetTy::Ty(main_ret_ty)),\n                            ast::FnHeader::default(),\n                            ast::Generics::default(),\n                            main_body);\n+\n+    // Honor the reexport_test_harness_main attribute\n+    let main_id = Ident::new(\n+        cx.reexport_test_harness_main.unwrap_or(Symbol::gensym(\"main\")),\n+        sp);\n+\n     P(ast::Item {\n-        ident: Ident::from_str(\"main\"),\n+        ident: main_id,\n         attrs: vec![main_attr],\n         id: ast::DUMMY_NODE_ID,\n         node: main,\n         vis: dummy_spanned(ast::VisibilityKind::Public),\n         span: sp,\n         tokens: None,\n     })\n-}\n-\n-fn mk_test_module(cx: &mut TestCtxt) -> (P<ast::Item>, Option<P<ast::Item>>) {\n-    // Link to test crate\n-    let import = mk_std(cx);\n-\n-    // A constant vector of test descriptors.\n-    let tests = mk_tests(cx);\n-\n-    // The synthesized main function which will call the console test runner\n-    // with our list of tests\n-    let mainfn = mk_main(cx);\n \n-    let testmod = ast::Mod {\n-        inner: DUMMY_SP,\n-        items: vec![import, mainfn, tests],\n-    };\n-    let item_ = ast::ItemKind::Mod(testmod);\n-    let mod_ident = Ident::with_empty_ctxt(Symbol::gensym(\"__test\"));\n-\n-    let mut expander = cx.ext_cx.monotonic_expander();\n-    let item = expander.fold_item(P(ast::Item {\n-        id: ast::DUMMY_NODE_ID,\n-        ident: mod_ident,\n-        attrs: vec![],\n-        node: item_,\n-        vis: dummy_spanned(ast::VisibilityKind::Public),\n-        span: DUMMY_SP,\n-        tokens: None,\n-    })).pop().unwrap();\n-    let reexport = cx.reexport_test_harness_main.map(|s| {\n-        // building `use __test::main as <ident>;`\n-        let rename = Ident::with_empty_ctxt(s);\n-\n-        let use_path = ast::UseTree {\n-            span: DUMMY_SP,\n-            prefix: path_node(vec![mod_ident, Ident::from_str(\"main\")]),\n-            kind: ast::UseTreeKind::Simple(Some(rename), ast::DUMMY_NODE_ID, ast::DUMMY_NODE_ID),\n-        };\n-\n-        expander.fold_item(P(ast::Item {\n-            id: ast::DUMMY_NODE_ID,\n-            ident: keywords::Invalid.ident(),\n-            attrs: vec![],\n-            node: ast::ItemKind::Use(P(use_path)),\n-            vis: dummy_spanned(ast::VisibilityKind::Inherited),\n-            span: DUMMY_SP,\n-            tokens: None,\n-        })).pop().unwrap()\n-    });\n-\n-    debug!(\"Synthetic test module:\\n{}\\n\", pprust::item_to_string(&item));\n-\n-    (item, reexport)\n-}\n-\n-fn nospan<T>(t: T) -> source_map::Spanned<T> {\n-    source_map::Spanned { node: t, span: DUMMY_SP }\n-}\n-\n-fn path_node(ids: Vec<Ident>) -> ast::Path {\n-    ast::Path {\n-        span: DUMMY_SP,\n-        segments: ids.into_iter().map(|id| ast::PathSegment::from_ident(id)).collect(),\n-    }\n }\n \n fn path_name_i(idents: &[Ident]) -> String {\n@@ -640,184 +406,46 @@ fn path_name_i(idents: &[Ident]) -> String {\n     path_name\n }\n \n-fn mk_tests(cx: &TestCtxt) -> P<ast::Item> {\n-    // The vector of test_descs for this crate\n-    let test_descs = mk_test_descs(cx);\n-\n-    // FIXME #15962: should be using quote_item, but that stringifies\n-    // __test_reexports, causing it to be reinterned, losing the\n-    // gensym information.\n-    let sp = ignored_span(cx, DUMMY_SP);\n-    let ecx = &cx.ext_cx;\n-    let struct_type = ecx.ty_path(ecx.path(sp, vec![ecx.ident_of(\"self\"),\n-                                                    ecx.ident_of(\"test\"),\n-                                                    ecx.ident_of(\"TestDescAndFn\")]));\n-    let static_lt = ecx.lifetime(sp, keywords::StaticLifetime.ident());\n-    // &'static [self::test::TestDescAndFn]\n-    let static_type = ecx.ty_rptr(sp,\n-                                  ecx.ty(sp, ast::TyKind::Slice(struct_type)),\n-                                  Some(static_lt),\n-                                  ast::Mutability::Immutable);\n-    // static TESTS: $static_type = &[...];\n-    ecx.item_const(sp,\n-                   ecx.ident_of(\"TESTS\"),\n-                   static_type,\n-                   test_descs)\n+/// Creates a slice containing every test like so:\n+/// &[path::to::test1, path::to::test2]\n+fn mk_tests_slice(cx: &TestCtxt) -> P<ast::Expr> {\n+    debug!(\"building test vector from {} tests\", cx.test_cases.len());\n+    let ref ecx = cx.ext_cx;\n+\n+    ecx.expr_vec_slice(DUMMY_SP,\n+        cx.test_cases.iter().map(|test| {\n+            ecx.expr_addr_of(test.span,\n+                ecx.expr_path(ecx.path(test.span, visible_path(cx, &test.path))))\n+        }).collect())\n }\n \n-fn mk_test_descs(cx: &TestCtxt) -> P<ast::Expr> {\n-    debug!(\"building test vector from {} tests\", cx.testfns.len());\n-\n-    P(ast::Expr {\n-        id: ast::DUMMY_NODE_ID,\n-        node: ast::ExprKind::AddrOf(ast::Mutability::Immutable,\n-            P(ast::Expr {\n-                id: ast::DUMMY_NODE_ID,\n-                node: ast::ExprKind::Array(cx.testfns.iter().map(|test| {\n-                    mk_test_desc_and_fn_rec(cx, test)\n-                }).collect()),\n-                span: DUMMY_SP,\n-                attrs: ThinVec::new(),\n-            })),\n-        span: DUMMY_SP,\n-        attrs: ThinVec::new(),\n-    })\n-}\n-\n-fn mk_test_desc_and_fn_rec(cx: &TestCtxt, test: &Test) -> P<ast::Expr> {\n-    // FIXME #15962: should be using quote_expr, but that stringifies\n-    // __test_reexports, causing it to be reinterned, losing the\n-    // gensym information.\n-\n-    let span = ignored_span(cx, test.span);\n-    let ecx = &cx.ext_cx;\n-    let self_id = ecx.ident_of(\"self\");\n-    let test_id = ecx.ident_of(\"test\");\n-\n-    // creates self::test::$name\n-    let test_path = |name| {\n-        ecx.path(span, vec![self_id, test_id, ecx.ident_of(name)])\n-    };\n-    // creates $name: $expr\n-    let field = |name, expr| ecx.field_imm(span, ecx.ident_of(name), expr);\n-\n-    // path to the #[test] function: \"foo::bar::baz\"\n-    let path_string = path_name_i(&test.path[..]);\n-\n-    debug!(\"encoding {}\", path_string);\n-\n-    let name_expr = ecx.expr_str(span, Symbol::intern(&path_string));\n-\n-    // self::test::StaticTestName($name_expr)\n-    let name_expr = ecx.expr_call(span,\n-                                  ecx.expr_path(test_path(\"StaticTestName\")),\n-                                  vec![name_expr]);\n-\n-    let ignore_expr = ecx.expr_bool(span, test.ignore);\n-    let should_panic_path = |name| {\n-        ecx.path(span, vec![self_id, test_id, ecx.ident_of(\"ShouldPanic\"), ecx.ident_of(name)])\n-    };\n-    let fail_expr = match test.should_panic {\n-        ShouldPanic::No => ecx.expr_path(should_panic_path(\"No\")),\n-        ShouldPanic::Yes(msg) => {\n-            match msg {\n-                Some(msg) => {\n-                    let msg = ecx.expr_str(span, msg);\n-                    let path = should_panic_path(\"YesWithMessage\");\n-                    ecx.expr_call(span, ecx.expr_path(path), vec![msg])\n-                }\n-                None => ecx.expr_path(should_panic_path(\"Yes\")),\n-            }\n-        }\n-    };\n-    let allow_fail_expr = ecx.expr_bool(span, test.allow_fail);\n-\n-    // self::test::TestDesc { ... }\n-    let desc_expr = ecx.expr_struct(\n-        span,\n-        test_path(\"TestDesc\"),\n-        vec![field(\"name\", name_expr),\n-             field(\"ignore\", ignore_expr),\n-             field(\"should_panic\", fail_expr),\n-             field(\"allow_fail\", allow_fail_expr)]);\n-\n+/// Creates a path from the top-level __test module to the test via __test_reexports\n+fn visible_path(cx: &TestCtxt, path: &[Ident]) -> Vec<Ident>{\n     let mut visible_path = vec![];\n-    if cx.features.extern_absolute_paths {\n-        visible_path.push(keywords::Crate.ident());\n-    }\n     match cx.toplevel_reexport {\n         Some(id) => visible_path.push(id),\n         None => {\n-            let diag = cx.span_diagnostic;\n-            diag.bug(\"expected to find top-level re-export name, but found None\");\n-        }\n-    };\n-    visible_path.extend_from_slice(&test.path[..]);\n-\n-    // Rather than directly give the test function to the test\n-    // harness, we create a wrapper like one of the following:\n-    //\n-    //     || test::assert_test_result(real_function()) // for test\n-    //     |b| test::assert_test_result(real_function(b)) // for bench\n-    //\n-    // this will coerce into a fn pointer that is specialized to the\n-    // actual return type of `real_function` (Typically `()`, but not always).\n-    let fn_expr = {\n-        // construct `real_function()` (this will be inserted into the overall expr)\n-        let real_function_expr = ecx.expr_path(ecx.path_global(span, visible_path));\n-        // construct path `test::assert_test_result`\n-        let assert_test_result = test_path(\"assert_test_result\");\n-        if test.bench {\n-            // construct `|b| {..}`\n-            let b_ident = Ident::with_empty_ctxt(Symbol::gensym(\"b\"));\n-            let b_expr = ecx.expr_ident(span, b_ident);\n-            ecx.lambda(\n-                span,\n-                vec![b_ident],\n-                // construct `assert_test_result(..)`\n-                ecx.expr_call(\n-                    span,\n-                    ecx.expr_path(assert_test_result),\n-                    vec![\n-                        // construct `real_function(b)`\n-                        ecx.expr_call(\n-                            span,\n-                            real_function_expr,\n-                            vec![b_expr],\n-                        )\n-                    ],\n-                ),\n-            )\n-        } else {\n-            // construct `|| {..}`\n-            ecx.lambda(\n-                span,\n-                vec![],\n-                // construct `assert_test_result(..)`\n-                ecx.expr_call(\n-                    span,\n-                    ecx.expr_path(assert_test_result),\n-                    vec![\n-                        // construct `real_function()`\n-                        ecx.expr_call(\n-                            span,\n-                            real_function_expr,\n-                            vec![],\n-                        )\n-                    ],\n-                ),\n-            )\n+            cx.span_diagnostic.bug(\"expected to find top-level re-export name, but found None\");\n         }\n-    };\n-\n-    let variant_name = if test.bench { \"StaticBenchFn\" } else { \"StaticTestFn\" };\n+    }\n+    visible_path.extend_from_slice(path);\n+    visible_path\n+}\n \n-    // self::test::$variant_name($fn_expr)\n-    let testfn_expr = ecx.expr_call(span, ecx.expr_path(test_path(variant_name)), vec![fn_expr]);\n+fn is_test_case(i: &ast::Item) -> bool {\n+    attr::contains_name(&i.attrs, \"test_case\")\n+}\n \n-    // self::test::TestDescAndFn { ... }\n-    ecx.expr_struct(span,\n-                    test_path(\"TestDescAndFn\"),\n-                    vec![field(\"desc\", desc_expr),\n-                         field(\"testfn\", testfn_expr)])\n+fn get_test_runner(sd: &errors::Handler, krate: &ast::Crate) -> Option<ast::Path> {\n+    let test_attr = attr::find_by_name(&krate.attrs, \"test_runner\")?;\n+    if let Some(meta_list) = test_attr.meta_item_list() {\n+        if meta_list.len() != 1 {\n+            sd.span_fatal(test_attr.span(),\n+                \"#![test_runner(..)] accepts exactly 1 argument\").raise()\n+        }\n+        Some(meta_list[0].word().as_ref().unwrap().ident.clone())\n+    } else {\n+        sd.span_fatal(test_attr.span(),\n+            \"test_runner must be of the form #[test_runner(..)]\").raise()\n+    }\n }"}, {"sha": "5a691bde3ecb3c24886bccc936a7e5acbeaa4633", "filename": "src/libsyntax_ext/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9b27de41d4e00cb6c23df270572472fd4c6f47f8/src%2Flibsyntax_ext%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/9b27de41d4e00cb6c23df270572472fd4c6f47f8/src%2Flibsyntax_ext%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2FCargo.toml?ref=9b27de41d4e00cb6c23df270572472fd4c6f47f8", "patch": "@@ -17,3 +17,4 @@ syntax_pos = { path = \"../libsyntax_pos\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_target = { path = \"../librustc_target\" }\n smallvec = { version = \"0.6.5\", features = [\"union\"] }\n+log = \"0.4\""}, {"sha": "bbbf338c4f3fb9fd80425a2612a7c7701617b095", "filename": "src/libsyntax_ext/lib.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9b27de41d4e00cb6c23df270572472fd4c6f47f8/src%2Flibsyntax_ext%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b27de41d4e00cb6c23df270572472fd4c6f47f8/src%2Flibsyntax_ext%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Flib.rs?ref=9b27de41d4e00cb6c23df270572472fd4c6f47f8", "patch": "@@ -19,7 +19,7 @@\n #![cfg_attr(not(stage0), feature(nll))]\n #![cfg_attr(not(stage0), feature(infer_outlives_requirements))]\n #![feature(str_escape)]\n-\n+#![feature(quote)]\n #![feature(rustc_diagnostic_macros)]\n \n extern crate fmt_macros;\n@@ -32,6 +32,8 @@ extern crate rustc_errors as errors;\n extern crate rustc_target;\n #[macro_use]\n extern crate smallvec;\n+#[macro_use]\n+extern crate log;\n \n mod diagnostics;\n \n@@ -51,6 +53,7 @@ mod format_foreign;\n mod global_asm;\n mod log_syntax;\n mod trace_macros;\n+mod test;\n \n pub mod proc_macro_registrar;\n \n@@ -59,7 +62,7 @@ pub mod proc_macro_impl;\n \n use rustc_data_structures::sync::Lrc;\n use syntax::ast;\n-use syntax::ext::base::{MacroExpanderFn, NormalTT, NamedSyntaxExtension};\n+use syntax::ext::base::{MacroExpanderFn, NormalTT, NamedSyntaxExtension, MultiModifier};\n use syntax::ext::hygiene;\n use syntax::symbol::Symbol;\n \n@@ -130,6 +133,9 @@ pub fn register_builtins(resolver: &mut dyn syntax::ext::base::Resolver,\n         assert: assert::expand_assert,\n     }\n \n+    register(Symbol::intern(\"test\"), MultiModifier(Box::new(test::expand_test)));\n+    register(Symbol::intern(\"bench\"), MultiModifier(Box::new(test::expand_bench)));\n+\n     // format_args uses `unstable` things internally.\n     register(Symbol::intern(\"format_args\"),\n              NormalTT {"}, {"sha": "d9d0f3d0a326c59fe5baadc68960e04dc9391017", "filename": "src/libsyntax_ext/test.rs", "status": "added", "additions": 328, "deletions": 0, "changes": 328, "blob_url": "https://github.com/rust-lang/rust/blob/9b27de41d4e00cb6c23df270572472fd4c6f47f8/src%2Flibsyntax_ext%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b27de41d4e00cb6c23df270572472fd4c6f47f8/src%2Flibsyntax_ext%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Ftest.rs?ref=9b27de41d4e00cb6c23df270572472fd4c6f47f8", "patch": "@@ -0,0 +1,328 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/// The expansion from a test function to the appropriate test struct for libtest\n+/// Ideally, this code would be in libtest but for efficiency and error messages it lives here.\n+\n+use syntax::ext::base::*;\n+use syntax::ext::build::AstBuilder;\n+use syntax::ext::hygiene::{self, Mark, SyntaxContext};\n+use syntax::attr;\n+use syntax::ast;\n+use syntax::print::pprust;\n+use syntax::symbol::Symbol;\n+use syntax_pos::{DUMMY_SP, Span};\n+use syntax::source_map::{ExpnInfo, MacroAttribute};\n+use std::iter;\n+\n+pub fn expand_test(\n+    cx: &mut ExtCtxt,\n+    attr_sp: Span,\n+    _meta_item: &ast::MetaItem,\n+    item: Annotatable,\n+) -> Vec<Annotatable> {\n+    expand_test_or_bench(cx, attr_sp, item, false)\n+}\n+\n+pub fn expand_bench(\n+    cx: &mut ExtCtxt,\n+    attr_sp: Span,\n+    _meta_item: &ast::MetaItem,\n+    item: Annotatable,\n+) -> Vec<Annotatable> {\n+    expand_test_or_bench(cx, attr_sp, item, true)\n+}\n+\n+pub fn expand_test_or_bench(\n+    cx: &mut ExtCtxt,\n+    attr_sp: Span,\n+    item: Annotatable,\n+    is_bench: bool\n+) -> Vec<Annotatable> {\n+    // If we're not in test configuration, remove the annotated item\n+    if !cx.ecfg.should_test { return vec![]; }\n+\n+    let item =\n+        if let Annotatable::Item(i) = item { i }\n+        else {\n+            cx.parse_sess.span_diagnostic.span_fatal(item.span(),\n+                \"#[test] attribute is only allowed on fn items\").raise();\n+        };\n+\n+    if let ast::ItemKind::Mac(_) = item.node {\n+        cx.parse_sess.span_diagnostic.span_warn(item.span,\n+            \"#[test] attribute should not be used on macros. Use #[cfg(test)] instead.\");\n+        return vec![Annotatable::Item(item)];\n+    }\n+\n+    // has_*_signature will report any errors in the type so compilation\n+    // will fail. We shouldn't try to expand in this case because the errors\n+    // would be spurious.\n+    if (!is_bench && !has_test_signature(cx, &item)) ||\n+        (is_bench && !has_bench_signature(cx, &item)) {\n+        return vec![Annotatable::Item(item)];\n+    }\n+\n+    let (sp, attr_sp) = {\n+        let mark = Mark::fresh(Mark::root());\n+        mark.set_expn_info(ExpnInfo {\n+            call_site: DUMMY_SP,\n+            def_site: None,\n+            format: MacroAttribute(Symbol::intern(\"test\")),\n+            allow_internal_unstable: true,\n+            allow_internal_unsafe: false,\n+            local_inner_macros: false,\n+            edition: hygiene::default_edition(),\n+        });\n+        (item.span.with_ctxt(SyntaxContext::empty().apply_mark(mark)),\n+         attr_sp.with_ctxt(SyntaxContext::empty().apply_mark(mark)))\n+    };\n+\n+    // Gensym \"test\" so we can extern crate without conflicting with any local names\n+    let test_id = cx.ident_of(\"test\").gensym();\n+\n+    // creates test::$name\n+    let test_path = |name| {\n+        cx.path(sp, vec![test_id, cx.ident_of(name)])\n+    };\n+\n+    // creates test::$name\n+    let should_panic_path = |name| {\n+        cx.path(sp, vec![test_id, cx.ident_of(\"ShouldPanic\"), cx.ident_of(name)])\n+    };\n+\n+    // creates $name: $expr\n+    let field = |name, expr| cx.field_imm(sp, cx.ident_of(name), expr);\n+\n+    let test_fn = if is_bench {\n+        // A simple ident for a lambda\n+        let b = cx.ident_of(\"b\");\n+\n+        cx.expr_call(sp, cx.expr_path(test_path(\"StaticBenchFn\")), vec![\n+            // |b| self::test::assert_test_result(\n+            cx.lambda1(sp,\n+                cx.expr_call(sp, cx.expr_path(test_path(\"assert_test_result\")), vec![\n+                    // super::$test_fn(b)\n+                    cx.expr_call(sp,\n+                        cx.expr_path(cx.path(sp, vec![item.ident])),\n+                        vec![cx.expr_ident(sp, b)])\n+                ]),\n+                b\n+            )\n+            // )\n+        ])\n+    } else {\n+        cx.expr_call(sp, cx.expr_path(test_path(\"StaticTestFn\")), vec![\n+            // || {\n+            cx.lambda0(sp,\n+                // test::assert_test_result(\n+                cx.expr_call(sp, cx.expr_path(test_path(\"assert_test_result\")), vec![\n+                    // $test_fn()\n+                    cx.expr_call(sp, cx.expr_path(cx.path(sp, vec![item.ident])), vec![])\n+                // )\n+                ])\n+            // }\n+            )\n+        // )\n+        ])\n+    };\n+\n+    let mut test_const = cx.item(sp, item.ident.gensym(),\n+        // #[test_case]\n+        vec![cx.attribute(attr_sp, cx.meta_word(attr_sp, Symbol::intern(\"test_case\")))],\n+        // const $ident: test::TestDescAndFn =\n+        ast::ItemKind::Const(cx.ty(sp, ast::TyKind::Path(None, test_path(\"TestDescAndFn\"))),\n+            // test::TestDescAndFn {\n+            cx.expr_struct(sp, test_path(\"TestDescAndFn\"), vec![\n+                // desc: test::TestDesc {\n+                field(\"desc\", cx.expr_struct(sp, test_path(\"TestDesc\"), vec![\n+                    // name: \"path::to::test\"\n+                    field(\"name\", cx.expr_call(sp, cx.expr_path(test_path(\"StaticTestName\")),\n+                        vec![\n+                            cx.expr_str(sp, Symbol::intern(&item_path(\n+                                // skip the name of the root module\n+                                &cx.current_expansion.module.mod_path[1..],\n+                                &item.ident\n+                            )))\n+                        ])),\n+                    // ignore: true | false\n+                    field(\"ignore\", cx.expr_bool(sp, should_ignore(&item))),\n+                    // allow_fail: true | false\n+                    field(\"allow_fail\", cx.expr_bool(sp, should_fail(&item))),\n+                    // should_panic: ...\n+                    field(\"should_panic\", match should_panic(cx, &item) {\n+                        // test::ShouldPanic::No\n+                        ShouldPanic::No => cx.expr_path(should_panic_path(\"No\")),\n+                        // test::ShouldPanic::Yes\n+                        ShouldPanic::Yes(None) => cx.expr_path(should_panic_path(\"Yes\")),\n+                        // test::ShouldPanic::YesWithMessage(\"...\")\n+                        ShouldPanic::Yes(Some(sym)) => cx.expr_call(sp,\n+                            cx.expr_path(should_panic_path(\"YesWithMessage\")),\n+                            vec![cx.expr_str(sp, sym)]),\n+                    }),\n+                // },\n+                ])),\n+                // testfn: test::StaticTestFn(...) | test::StaticBenchFn(...)\n+                field(\"testfn\", test_fn)\n+            // }\n+            ])\n+        // }\n+        ));\n+    test_const = test_const.map(|mut tc| { tc.vis.node = ast::VisibilityKind::Public; tc});\n+\n+    // extern crate test as test_gensym\n+    let test_extern = cx.item(sp,\n+        test_id,\n+        vec![],\n+        ast::ItemKind::ExternCrate(Some(Symbol::intern(\"test\")))\n+    );\n+\n+    debug!(\"Synthetic test item:\\n{}\\n\", pprust::item_to_string(&test_const));\n+\n+    vec![\n+        // Access to libtest under a gensymed name\n+        Annotatable::Item(test_extern),\n+        // The generated test case\n+        Annotatable::Item(test_const),\n+        // The original item\n+        Annotatable::Item(item)\n+    ]\n+}\n+\n+fn item_path(mod_path: &[ast::Ident], item_ident: &ast::Ident) -> String {\n+    mod_path.iter().chain(iter::once(item_ident))\n+        .map(|x| x.to_string()).collect::<Vec<String>>().join(\"::\")\n+}\n+\n+enum ShouldPanic {\n+    No,\n+    Yes(Option<Symbol>),\n+}\n+\n+fn should_ignore(i: &ast::Item) -> bool {\n+    attr::contains_name(&i.attrs, \"ignore\")\n+}\n+\n+fn should_fail(i: &ast::Item) -> bool {\n+    attr::contains_name(&i.attrs, \"allow_fail\")\n+}\n+\n+fn should_panic(cx: &ExtCtxt, i: &ast::Item) -> ShouldPanic {\n+    match attr::find_by_name(&i.attrs, \"should_panic\") {\n+        Some(attr) => {\n+            let ref sd = cx.parse_sess.span_diagnostic;\n+            if attr.is_value_str() {\n+                sd.struct_span_warn(\n+                    attr.span(),\n+                    \"attribute must be of the form: \\\n+                     `#[should_panic]` or \\\n+                     `#[should_panic(expected = \\\"error message\\\")]`\"\n+                ).note(\"Errors in this attribute were erroneously allowed \\\n+                        and will become a hard error in a future release.\")\n+                .emit();\n+                return ShouldPanic::Yes(None);\n+            }\n+            match attr.meta_item_list() {\n+                // Handle #[should_panic]\n+                None => ShouldPanic::Yes(None),\n+                // Handle #[should_panic(expected = \"foo\")]\n+                Some(list) => {\n+                    let msg = list.iter()\n+                        .find(|mi| mi.check_name(\"expected\"))\n+                        .and_then(|mi| mi.meta_item())\n+                        .and_then(|mi| mi.value_str());\n+                    if list.len() != 1 || msg.is_none() {\n+                        sd.struct_span_warn(\n+                            attr.span(),\n+                            \"argument must be of the form: \\\n+                             `expected = \\\"error message\\\"`\"\n+                        ).note(\"Errors in this attribute were erroneously \\\n+                                allowed and will become a hard error in a \\\n+                                future release.\").emit();\n+                        ShouldPanic::Yes(None)\n+                    } else {\n+                        ShouldPanic::Yes(msg)\n+                    }\n+                },\n+            }\n+        }\n+        None => ShouldPanic::No,\n+    }\n+}\n+\n+fn has_test_signature(cx: &ExtCtxt, i: &ast::Item) -> bool {\n+    let has_should_panic_attr = attr::contains_name(&i.attrs, \"should_panic\");\n+    let ref sd = cx.parse_sess.span_diagnostic;\n+    if let ast::ItemKind::Fn(ref decl, ref header, ref generics, _) = i.node {\n+        if header.unsafety == ast::Unsafety::Unsafe {\n+            sd.span_err(\n+                i.span,\n+                \"unsafe functions cannot be used for tests\"\n+            );\n+            return false\n+        }\n+        if header.asyncness.is_async() {\n+            sd.span_err(\n+                i.span,\n+                \"async functions cannot be used for tests\"\n+            );\n+            return false\n+        }\n+\n+\n+        // If the termination trait is active, the compiler will check that the output\n+        // type implements the `Termination` trait as `libtest` enforces that.\n+        let has_output = match decl.output {\n+            ast::FunctionRetTy::Default(..) => false,\n+            ast::FunctionRetTy::Ty(ref t) if t.node.is_unit() => false,\n+            _ => true\n+        };\n+\n+        if !decl.inputs.is_empty() {\n+            sd.span_err(i.span, \"functions used as tests can not have any arguments\");\n+            return false;\n+        }\n+\n+        match (has_output, has_should_panic_attr) {\n+            (true, true) => {\n+                sd.span_err(i.span, \"functions using `#[should_panic]` must return `()`\");\n+                false\n+            },\n+            (true, false) => if !generics.params.is_empty() {\n+                sd.span_err(i.span,\n+                                \"functions used as tests must have signature fn() -> ()\");\n+                false\n+            } else {\n+                true\n+            },\n+            (false, _) => true\n+        }\n+    } else {\n+        sd.span_err(i.span, \"only functions may be used as tests\");\n+        false\n+    }\n+}\n+\n+fn has_bench_signature(cx: &ExtCtxt, i: &ast::Item) -> bool {\n+    let has_sig = if let ast::ItemKind::Fn(ref decl, _, _, _) = i.node {\n+        // NB: inadequate check, but we're running\n+        // well before resolve, can't get too deep.\n+        decl.inputs.len() == 1\n+    } else {\n+        false\n+    };\n+\n+    if !has_sig {\n+        cx.parse_sess.span_diagnostic.span_err(i.span, \"functions used as benches must have \\\n+            signature `fn(&mut Bencher) -> impl Termination`\");\n+    }\n+\n+    has_sig\n+}"}, {"sha": "bf3cb7c537bd0da9879851e85c5c1d5312c49d94", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9b27de41d4e00cb6c23df270572472fd4c6f47f8/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b27de41d4e00cb6c23df270572472fd4c6f47f8/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=9b27de41d4e00cb6c23df270572472fd4c6f47f8", "patch": "@@ -41,6 +41,7 @@\n #![feature(panic_unwind)]\n #![feature(staged_api)]\n #![feature(termination_trait_lib)]\n+#![feature(test)]\n \n extern crate getopts;\n #[cfg(any(unix, target_os = \"cloudabi\"))]\n@@ -302,7 +303,7 @@ pub fn test_main(args: &[String], tests: Vec<TestDescAndFn>, options: Options) {\n // a Vec<TestDescAndFn> is used in order to effect ownership-transfer\n // semantics into parallel test runners, which in turn requires a Vec<>\n // rather than a &[].\n-pub fn test_main_static(tests: &[TestDescAndFn]) {\n+pub fn test_main_static(tests: &[&TestDescAndFn]) {\n     let args = env::args().collect::<Vec<_>>();\n     let owned_tests = tests\n         .iter()"}, {"sha": "9a8749712c355122f874648dc060eec333100920", "filename": "src/libtest/stats.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9b27de41d4e00cb6c23df270572472fd4c6f47f8/src%2Flibtest%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b27de41d4e00cb6c23df270572472fd4c6f47f8/src%2Flibtest%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fstats.rs?ref=9b27de41d4e00cb6c23df270572472fd4c6f47f8", "patch": "@@ -907,7 +907,8 @@ mod tests {\n \n #[cfg(test)]\n mod bench {\n-    use Bencher;\n+    extern crate test;\n+    use self::test::Bencher;\n     use stats::Stats;\n \n     #[bench]"}, {"sha": "7067e7250728fa9aae942e139587e21ab50cfd7e", "filename": "src/test/incremental/issue-49595/issue_49595.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9b27de41d4e00cb6c23df270572472fd4c6f47f8/src%2Ftest%2Fincremental%2Fissue-49595%2Fissue_49595.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b27de41d4e00cb6c23df270572472fd4c6f47f8/src%2Ftest%2Fincremental%2Fissue-49595%2Fissue_49595.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fissue-49595%2Fissue_49595.rs?ref=9b27de41d4e00cb6c23df270572472fd4c6f47f8", "patch": "@@ -15,12 +15,11 @@\n #![feature(rustc_attrs)]\n #![crate_type = \"rlib\"]\n \n-#![rustc_partition_codegened(module=\"issue_49595-__test\", cfg=\"cfail2\")]\n+#![rustc_partition_codegened(module=\"issue_49595-tests\", cfg=\"cfail2\")]\n #![rustc_partition_codegened(module=\"issue_49595-lit_test\", cfg=\"cfail3\")]\n \n mod tests {\n-    #[cfg_attr(not(cfail1), ignore)]\n-    #[test]\n+    #[cfg_attr(not(cfail1), test)]\n     fn test() {\n     }\n }"}, {"sha": "bd0a5c66b3ee2756341b0f524cdd5beb449a266c", "filename": "src/test/ui/cfg-non-opt-expr.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9b27de41d4e00cb6c23df270572472fd4c6f47f8/src%2Ftest%2Fui%2Fcfg-non-opt-expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b27de41d4e00cb6c23df270572472fd4c6f47f8/src%2Ftest%2Fui%2Fcfg-non-opt-expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcfg-non-opt-expr.rs?ref=9b27de41d4e00cb6c23df270572472fd4c6f47f8", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n #![feature(stmt_expr_attributes)]\n+#![feature(custom_test_frameworks)]\n \n fn main() {\n     let _ = #[cfg(unset)] ();\n@@ -17,6 +18,6 @@ fn main() {\n     //~^ ERROR removing an expression is not supported in this position\n     let _ = [1, 2, 3][#[cfg(unset)] 1];\n     //~^ ERROR removing an expression is not supported in this position\n-    let _ = #[test] ();\n+    let _ = #[test_case] ();\n     //~^ ERROR removing an expression is not supported in this position\n }"}, {"sha": "8c5d8900f8b2e23e6f07933e868a07379f3ca0f9", "filename": "src/test/ui/cfg-non-opt-expr.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9b27de41d4e00cb6c23df270572472fd4c6f47f8/src%2Ftest%2Fui%2Fcfg-non-opt-expr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9b27de41d4e00cb6c23df270572472fd4c6f47f8/src%2Ftest%2Fui%2Fcfg-non-opt-expr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcfg-non-opt-expr.stderr?ref=9b27de41d4e00cb6c23df270572472fd4c6f47f8", "patch": "@@ -1,26 +1,26 @@\n error: removing an expression is not supported in this position\n-  --> $DIR/cfg-non-opt-expr.rs:14:13\n+  --> $DIR/cfg-non-opt-expr.rs:15:13\n    |\n LL |     let _ = #[cfg(unset)] ();\n    |             ^^^^^^^^^^^^^\n \n error: removing an expression is not supported in this position\n-  --> $DIR/cfg-non-opt-expr.rs:16:21\n+  --> $DIR/cfg-non-opt-expr.rs:17:21\n    |\n LL |     let _ = 1 + 2 + #[cfg(unset)] 3;\n    |                     ^^^^^^^^^^^^^\n \n error: removing an expression is not supported in this position\n-  --> $DIR/cfg-non-opt-expr.rs:18:23\n+  --> $DIR/cfg-non-opt-expr.rs:19:23\n    |\n LL |     let _ = [1, 2, 3][#[cfg(unset)] 1];\n    |                       ^^^^^^^^^^^^^\n \n error: removing an expression is not supported in this position\n-  --> $DIR/cfg-non-opt-expr.rs:20:13\n+  --> $DIR/cfg-non-opt-expr.rs:21:13\n    |\n-LL |     let _ = #[test] ();\n-   |             ^^^^^^^\n+LL |     let _ = #[test_case] ();\n+   |             ^^^^^^^^^^^^\n \n error: aborting due to 4 previous errors\n "}, {"sha": "39a4dc569fa62534cf1f971cf7f15ed3b8082994", "filename": "src/test/ui/custom-test-frameworks-simple.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/9b27de41d4e00cb6c23df270572472fd4c6f47f8/src%2Ftest%2Fui%2Fcustom-test-frameworks-simple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b27de41d4e00cb6c23df270572472fd4c6f47f8/src%2Ftest%2Fui%2Fcustom-test-frameworks-simple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcustom-test-frameworks-simple.rs?ref=9b27de41d4e00cb6c23df270572472fd4c6f47f8", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: --test\n+// run-pass\n+\n+#![feature(custom_test_frameworks)]\n+#![test_runner(crate::foo_runner)]\n+\n+#[cfg(test)]\n+fn foo_runner(ts: &[&Fn(usize)->()]) {\n+    for (i, t) in ts.iter().enumerate() {\n+        t(i);\n+    }\n+}\n+\n+#[test_case]\n+fn test1(i: usize) {\n+    println!(\"Hi #{}\", i);\n+}\n+\n+#[test_case]\n+fn test2(i: usize) {\n+    println!(\"Hey #{}\", i);\n+}"}, {"sha": "c204e69eafca687f8ca93c9108cb3cbb39821d7a", "filename": "src/test/ui/custom_test_frameworks/auxiliary/dynamic_runner.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/9b27de41d4e00cb6c23df270572472fd4c6f47f8/src%2Ftest%2Fui%2Fcustom_test_frameworks%2Fauxiliary%2Fdynamic_runner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b27de41d4e00cb6c23df270572472fd4c6f47f8/src%2Ftest%2Fui%2Fcustom_test_frameworks%2Fauxiliary%2Fdynamic_runner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcustom_test_frameworks%2Fauxiliary%2Fdynamic_runner.rs?ref=9b27de41d4e00cb6c23df270572472fd4c6f47f8", "patch": "@@ -0,0 +1,45 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::process::exit;\n+\n+pub trait Testable {\n+    // Name of the test\n+    fn name(&self) -> String;\n+\n+    // Tests pass by default\n+    fn run(&self) -> bool {\n+        true\n+    }\n+\n+    // A test can generate subtests\n+    fn subtests(&self) -> Vec<Box<dyn Testable>> {\n+        vec![]\n+    }\n+}\n+\n+fn run_test(t: &dyn Testable) -> bool {\n+    let success = t.subtests().into_iter().all(|sub_t| run_test(&*sub_t)) && t.run();\n+    println!(\"{}...{}\", t.name(), if success { \"SUCCESS\" } else { \"FAIL\" });\n+    success\n+}\n+\n+pub fn runner(tests: &[&dyn Testable]) {\n+    let mut failed = false;\n+    for t in tests {\n+        if !run_test(*t) {\n+            failed = true;\n+        }\n+    }\n+\n+    if failed {\n+        exit(1);\n+    }\n+}"}, {"sha": "7b6b5e02955cce15a788a70e1665acc50b12dbca", "filename": "src/test/ui/custom_test_frameworks/auxiliary/example_runner.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/9b27de41d4e00cb6c23df270572472fd4c6f47f8/src%2Ftest%2Fui%2Fcustom_test_frameworks%2Fauxiliary%2Fexample_runner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b27de41d4e00cb6c23df270572472fd4c6f47f8/src%2Ftest%2Fui%2Fcustom_test_frameworks%2Fauxiliary%2Fexample_runner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcustom_test_frameworks%2Fauxiliary%2Fexample_runner.rs?ref=9b27de41d4e00cb6c23df270572472fd4c6f47f8", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub trait Testable {\n+    fn name(&self) -> String;\n+    fn run(&self) -> Option<String>; // None will be success, Some is the error message\n+}\n+\n+pub fn runner(tests: &[&dyn Testable]) {\n+    for t in tests {\n+        print!(\"{}........{}\", t.name(), t.run().unwrap_or_else(|| \"SUCCESS\".to_string()));\n+    }\n+}"}, {"sha": "f82571b948ab7eb9ab022e70371a5fdced145511", "filename": "src/test/ui/custom_test_frameworks/dynamic.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/9b27de41d4e00cb6c23df270572472fd4c6f47f8/src%2Ftest%2Fui%2Fcustom_test_frameworks%2Fdynamic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b27de41d4e00cb6c23df270572472fd4c6f47f8/src%2Ftest%2Fui%2Fcustom_test_frameworks%2Fdynamic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcustom_test_frameworks%2Fdynamic.rs?ref=9b27de41d4e00cb6c23df270572472fd4c6f47f8", "patch": "@@ -0,0 +1,45 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// run-pass\n+// aux-build:dynamic_runner.rs\n+// compile-flags:--test\n+#![feature(custom_test_frameworks)]\n+#![test_runner(dynamic_runner::runner)]\n+\n+extern crate dynamic_runner;\n+\n+pub struct AllFoo(&'static str);\n+struct IsFoo(String);\n+\n+impl dynamic_runner::Testable for AllFoo {\n+    fn name(&self) -> String {\n+        String::from(self.0)\n+    }\n+\n+    fn subtests(&self) -> Vec<Box<dyn dynamic_runner::Testable>> {\n+        self.0.split(\" \").map(|word|\n+            Box::new(IsFoo(word.into())) as Box<dyn dynamic_runner::Testable>\n+        ).collect()\n+    }\n+}\n+\n+impl dynamic_runner::Testable for IsFoo {\n+    fn name(&self) -> String {\n+        self.0.clone()\n+    }\n+\n+    fn run(&self) -> bool {\n+        self.0 == \"foo\"\n+    }\n+}\n+\n+#[test_case]\n+const TEST_2: AllFoo = AllFoo(\"foo foo\");"}, {"sha": "9fcf76ec33e28f24182c73100eda7ffb63927c2a", "filename": "src/test/ui/custom_test_frameworks/full.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/9b27de41d4e00cb6c23df270572472fd4c6f47f8/src%2Ftest%2Fui%2Fcustom_test_frameworks%2Ffull.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b27de41d4e00cb6c23df270572472fd4c6f47f8/src%2Ftest%2Fui%2Fcustom_test_frameworks%2Ffull.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcustom_test_frameworks%2Ffull.rs?ref=9b27de41d4e00cb6c23df270572472fd4c6f47f8", "patch": "@@ -0,0 +1,38 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// run-pass\n+// aux-build:example_runner.rs\n+// compile-flags:--test\n+\n+#![feature(custom_test_frameworks)]\n+#![test_runner(example_runner::runner)]\n+extern crate example_runner;\n+\n+pub struct IsFoo(&'static str);\n+\n+impl example_runner::Testable for IsFoo {\n+    fn name(&self) -> String {\n+        self.0.to_string()\n+    }\n+\n+    fn run(&self) -> Option<String> {\n+        if self.0 != \"foo\" {\n+            return Some(format!(\"{} != foo\", self.0));\n+        }\n+        None\n+    }\n+}\n+\n+#[test_case]\n+const TEST_1: IsFoo = IsFoo(\"hello\");\n+\n+#[test_case]\n+const TEST_2: IsFoo = IsFoo(\"foo\");"}, {"sha": "28753f1649abdc6184cdf7acba057f465935912f", "filename": "src/test/ui/custom_test_frameworks/mismatch.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/9b27de41d4e00cb6c23df270572472fd4c6f47f8/src%2Ftest%2Fui%2Fcustom_test_frameworks%2Fmismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b27de41d4e00cb6c23df270572472fd4c6f47f8/src%2Ftest%2Fui%2Fcustom_test_frameworks%2Fmismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcustom_test_frameworks%2Fmismatch.rs?ref=9b27de41d4e00cb6c23df270572472fd4c6f47f8", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:example_runner.rs\n+// compile-flags:--test\n+#![feature(custom_test_frameworks)]\n+#![test_runner(example_runner::runner)]\n+\n+extern crate example_runner;\n+\n+#[test]\n+fn wrong_kind(){}"}, {"sha": "8e2afaedfffaad459c2097347d75fcaf4b2f4d41", "filename": "src/test/ui/custom_test_frameworks/mismatch.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9b27de41d4e00cb6c23df270572472fd4c6f47f8/src%2Ftest%2Fui%2Fcustom_test_frameworks%2Fmismatch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9b27de41d4e00cb6c23df270572472fd4c6f47f8/src%2Ftest%2Fui%2Fcustom_test_frameworks%2Fmismatch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcustom_test_frameworks%2Fmismatch.stderr?ref=9b27de41d4e00cb6c23df270572472fd4c6f47f8", "patch": "@@ -0,0 +1,11 @@\n+error[E0277]: the trait bound `test::TestDescAndFn: example_runner::Testable` is not satisfied\n+  --> $DIR/mismatch.rs:19:1\n+   |\n+LL | fn wrong_kind(){}\n+   | ^^^^^^^^^^^^^^^^^ the trait `example_runner::Testable` is not implemented for `test::TestDescAndFn`\n+   |\n+   = note: required for the cast to the object type `dyn example_runner::Testable`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "e8d1524996fa1bc333a76b0de9d4e577fc0204c8", "filename": "src/test/ui/feature-gate-custom_test_frameworks.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9b27de41d4e00cb6c23df270572472fd4c6f47f8/src%2Ftest%2Fui%2Ffeature-gate-custom_test_frameworks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b27de41d4e00cb6c23df270572472fd4c6f47f8/src%2Ftest%2Fui%2Ffeature-gate-custom_test_frameworks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-custom_test_frameworks.rs?ref=9b27de41d4e00cb6c23df270572472fd4c6f47f8", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![test_runner(main)] //~ ERROR Custom Test Frameworks is an unstable feature\n+\n+fn main() {}"}, {"sha": "cd04f32697bf5ba5ff01b28aec3e4a8239d92e5d", "filename": "src/test/ui/feature-gate-custom_test_frameworks.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9b27de41d4e00cb6c23df270572472fd4c6f47f8/src%2Ftest%2Fui%2Ffeature-gate-custom_test_frameworks.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9b27de41d4e00cb6c23df270572472fd4c6f47f8/src%2Ftest%2Fui%2Ffeature-gate-custom_test_frameworks.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-custom_test_frameworks.stderr?ref=9b27de41d4e00cb6c23df270572472fd4c6f47f8", "patch": "@@ -0,0 +1,11 @@\n+error[E0658]: Custom Test Frameworks is an unstable feature (see issue #50297)\n+  --> $DIR/feature-gate-custom_test_frameworks.rs:11:1\n+   |\n+LL | #![test_runner(main)] //~ ERROR Custom Test Frameworks is an unstable feature\n+   | ^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(custom_test_frameworks)] to the crate attributes to enable\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "5b964c1a14b992aa6a41e2d53e6fa4720aa052f4", "filename": "src/test/ui/inaccessible-test-modules.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b27de41d4e00cb6c23df270572472fd4c6f47f8/src%2Ftest%2Fui%2Finaccessible-test-modules.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9b27de41d4e00cb6c23df270572472fd4c6f47f8/src%2Ftest%2Fui%2Finaccessible-test-modules.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finaccessible-test-modules.stderr?ref=9b27de41d4e00cb6c23df270572472fd4c6f47f8", "patch": "@@ -2,7 +2,7 @@ error[E0432]: unresolved import `__test`\n   --> $DIR/inaccessible-test-modules.rs:15:5\n    |\n LL | use __test as x; //~ ERROR unresolved import `__test`\n-   |     ^^^^^^^^^^^ no `__test` in the root. Did you mean to use `__test`?\n+   |     ^^^^^^^^^^^ no `__test` in the root. Did you mean to use `test`?\n \n error[E0432]: unresolved import `__test_reexports`\n   --> $DIR/inaccessible-test-modules.rs:16:5"}, {"sha": "d1f5712afb6c9b6ce7f7bf782edbe19f8bcaad33", "filename": "src/test/ui/issues/issue-11692-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b27de41d4e00cb6c23df270572472fd4c6f47f8/src%2Ftest%2Fui%2Fissues%2Fissue-11692-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b27de41d4e00cb6c23df270572472fd4c6f47f8/src%2Ftest%2Fui%2Fissues%2Fissue-11692-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-11692-2.rs?ref=9b27de41d4e00cb6c23df270572472fd4c6f47f8", "patch": "@@ -10,5 +10,5 @@\n \n fn main() {\n     concat!(test!());\n-    //~^ ERROR cannot find macro `test!` in this scope\n+    //~^ error: `test` can only be used in attributes\n }"}, {"sha": "6c21287bed304922f8e670e1aaef08aa1ecc1587", "filename": "src/test/ui/issues/issue-11692-2.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b27de41d4e00cb6c23df270572472fd4c6f47f8/src%2Ftest%2Fui%2Fissues%2Fissue-11692-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9b27de41d4e00cb6c23df270572472fd4c6f47f8/src%2Ftest%2Fui%2Fissues%2Fissue-11692-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-11692-2.stderr?ref=9b27de41d4e00cb6c23df270572472fd4c6f47f8", "patch": "@@ -1,4 +1,4 @@\n-error: cannot find macro `test!` in this scope\n+error: `test` can only be used in attributes\n   --> $DIR/issue-11692-2.rs:12:13\n    |\n LL |     concat!(test!());"}, {"sha": "853a2a0f1b4f1018f812d7823b14f01d1b9b2d05", "filename": "src/test/ui/issues/issue-12997-2.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b27de41d4e00cb6c23df270572472fd4c6f47f8/src%2Ftest%2Fui%2Fissues%2Fissue-12997-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9b27de41d4e00cb6c23df270572472fd4c6f47f8/src%2Ftest%2Fui%2Fissues%2Fissue-12997-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-12997-2.stderr?ref=9b27de41d4e00cb6c23df270572472fd4c6f47f8", "patch": "@@ -5,7 +5,7 @@ LL | fn bar(x: isize) { }\n    | ^^^^^^^^^^^^^^^^^^^^ expected isize, found mutable reference\n    |\n    = note: expected type `isize`\n-              found type `&mut __test::test::Bencher`\n+              found type `&mut test::Bencher`\n \n error: aborting due to previous error\n "}, {"sha": "a7727c69e4c0cfb2ae2e730d5961e22471996afb", "filename": "src/test/ui/lint/test-inner-fn.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9b27de41d4e00cb6c23df270572472fd4c6f47f8/src%2Ftest%2Fui%2Flint%2Ftest-inner-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b27de41d4e00cb6c23df270572472fd4c6f47f8/src%2Ftest%2Fui%2Flint%2Ftest-inner-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Ftest-inner-fn.rs?ref=9b27de41d4e00cb6c23df270572472fd4c6f47f8", "patch": "@@ -8,19 +8,19 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// compile-flags: --test -D unnameable_test_functions\n+// compile-flags: --test -D unnameable_test_items\n \n #[test]\n fn foo() {\n-    #[test] //~ ERROR cannot test inner function [unnameable_test_functions]\n+    #[test] //~ ERROR cannot test inner items [unnameable_test_items]\n     fn bar() {}\n     bar();\n }\n \n mod x {\n     #[test]\n     fn foo() {\n-        #[test] //~ ERROR cannot test inner function [unnameable_test_functions]\n+        #[test] //~ ERROR cannot test inner items [unnameable_test_items]\n         fn bar() {}\n         bar();\n     }"}, {"sha": "182fb31a9aa3707853f01412cd25f618e00dc510", "filename": "src/test/ui/lint/test-inner-fn.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9b27de41d4e00cb6c23df270572472fd4c6f47f8/src%2Ftest%2Fui%2Flint%2Ftest-inner-fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9b27de41d4e00cb6c23df270572472fd4c6f47f8/src%2Ftest%2Fui%2Flint%2Ftest-inner-fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Ftest-inner-fn.stderr?ref=9b27de41d4e00cb6c23df270572472fd4c6f47f8", "patch": "@@ -1,15 +1,15 @@\n-error: cannot test inner function\n+error: cannot test inner items\n   --> $DIR/test-inner-fn.rs:15:5\n    |\n-LL |     #[test] //~ ERROR cannot test inner function [unnameable_test_functions]\n+LL |     #[test] //~ ERROR cannot test inner items [unnameable_test_items]\n    |     ^^^^^^^\n    |\n-   = note: requested on the command line with `-D unnameable-test-functions`\n+   = note: requested on the command line with `-D unnameable-test-items`\n \n-error: cannot test inner function\n+error: cannot test inner items\n   --> $DIR/test-inner-fn.rs:23:9\n    |\n-LL |         #[test] //~ ERROR cannot test inner function [unnameable_test_functions]\n+LL |         #[test] //~ ERROR cannot test inner items [unnameable_test_items]\n    |         ^^^^^^^\n \n error: aborting due to 2 previous errors"}, {"sha": "0e95c053ce4cfa46c7d57139380f061c21000643", "filename": "src/test/ui/rfc-1937-termination-trait/termination-trait-test-wrong-type.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b27de41d4e00cb6c23df270572472fd4c6f47f8/src%2Ftest%2Fui%2Frfc-1937-termination-trait%2Ftermination-trait-test-wrong-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9b27de41d4e00cb6c23df270572472fd4c6f47f8/src%2Ftest%2Fui%2Frfc-1937-termination-trait%2Ftermination-trait-test-wrong-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-1937-termination-trait%2Ftermination-trait-test-wrong-type.stderr?ref=9b27de41d4e00cb6c23df270572472fd4c6f47f8", "patch": "@@ -7,7 +7,7 @@ LL | | }\n    | |_^ `main` can only return types that implement `std::process::Termination`\n    |\n    = help: the trait `std::process::Termination` is not implemented for `std::result::Result<f32, std::num::ParseIntError>`\n-   = note: required by `__test::test::assert_test_result`\n+   = note: required by `test::assert_test_result`\n \n error: aborting due to previous error\n "}, {"sha": "a153e63443406ba6392dd07b9233bac1acbc1d68", "filename": "src/test/ui/test-on-macro.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/9b27de41d4e00cb6c23df270572472fd4c6f47f8/src%2Ftest%2Fui%2Ftest-on-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b27de41d4e00cb6c23df270572472fd4c6f47f8/src%2Ftest%2Fui%2Ftest-on-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftest-on-macro.rs?ref=9b27de41d4e00cb6c23df270572472fd4c6f47f8", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-pass\n+// compile-flags:--test\n+\n+#![deny(warnings)]\n+\n+macro_rules! foo {\n+    () => (fn foo(){})\n+}\n+\n+#[test]\n+foo!();\n+\n+fn main(){}"}, {"sha": "a45bb25255efadeffee1b8df63a7aa748797d12e", "filename": "src/test/ui/test-on-macro.stderr", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9b27de41d4e00cb6c23df270572472fd4c6f47f8/src%2Ftest%2Fui%2Ftest-on-macro.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9b27de41d4e00cb6c23df270572472fd4c6f47f8/src%2Ftest%2Fui%2Ftest-on-macro.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftest-on-macro.stderr?ref=9b27de41d4e00cb6c23df270572472fd4c6f47f8", "patch": "@@ -0,0 +1,6 @@\n+warning: #[test] attribute should not be used on macros. Use #[cfg(test)] instead.\n+  --> $DIR/test-on-macro.rs:21:1\n+   |\n+LL | foo!();\n+   | ^^^^^^^\n+"}]}