{"sha": "8a9f7862bcfa5870a34bb54f77a03c73d1db5c37", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhhOWY3ODYyYmNmYTU4NzBhMzRiYjU0Zjc3YTAzYzczZDFkYjVjMzc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-02-22T09:33:31Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-02-22T09:33:31Z"}, "message": "Auto merge of #82393 - JohnTitor:rollup-5c8jryl, r=JohnTitor\n\nRollup of 9 pull requests\n\nSuccessful merges:\n\n - #82098 (Add internal `collect_into_array[_unchecked]` to remove duplicate code)\n - #82228 (Provide NonZero_c_* integers)\n - #82287 (Make \"missing field\" error message more natural)\n - #82351 (Use the first paragraph, instead of cookie-cutter text, for rustdoc descriptions)\n - #82353 (rustdoc: Remove unnecessary `Cell` around `param_env`)\n - #82367 (remove redundant option/result wrapping of return values)\n - #82372 (improve UnsafeCell docs)\n - #82379 (Fix sizes of repr(C) enums on hexagon)\n - #82382 (rustdoc: Remove `fake_def_ids` RefCell)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "6f304fa25f5113a1129bdb35069a25e0321d6942", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6f304fa25f5113a1129bdb35069a25e0321d6942"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8a9f7862bcfa5870a34bb54f77a03c73d1db5c37", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8a9f7862bcfa5870a34bb54f77a03c73d1db5c37", "html_url": "https://github.com/rust-lang/rust/commit/8a9f7862bcfa5870a34bb54f77a03c73d1db5c37", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8a9f7862bcfa5870a34bb54f77a03c73d1db5c37/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "352238d152b6b3f106554e75445bbdd5201671b2", "url": "https://api.github.com/repos/rust-lang/rust/commits/352238d152b6b3f106554e75445bbdd5201671b2", "html_url": "https://github.com/rust-lang/rust/commit/352238d152b6b3f106554e75445bbdd5201671b2"}, {"sha": "86940bed983909f092e3333a018bfd48d40f394a", "url": "https://api.github.com/repos/rust-lang/rust/commits/86940bed983909f092e3333a018bfd48d40f394a", "html_url": "https://github.com/rust-lang/rust/commit/86940bed983909f092e3333a018bfd48d40f394a"}], "stats": {"total": 979, "additions": 767, "deletions": 212}, "files": [{"sha": "24da75114a65671458855207720e69763cdaba71", "filename": "compiler/rustc_attr/src/builtin.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8a9f7862bcfa5870a34bb54f77a03c73d1db5c37/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a9f7862bcfa5870a34bb54f77a03c73d1db5c37/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs?ref=8a9f7862bcfa5870a34bb54f77a03c73d1db5c37", "patch": "@@ -1035,22 +1035,22 @@ pub fn find_transparency(\n pub fn allow_internal_unstable<'a>(\n     sess: &'a Session,\n     attrs: &'a [Attribute],\n-) -> Option<impl Iterator<Item = Symbol> + 'a> {\n+) -> impl Iterator<Item = Symbol> + 'a {\n     allow_unstable(sess, attrs, sym::allow_internal_unstable)\n }\n \n pub fn rustc_allow_const_fn_unstable<'a>(\n     sess: &'a Session,\n     attrs: &'a [Attribute],\n-) -> Option<impl Iterator<Item = Symbol> + 'a> {\n+) -> impl Iterator<Item = Symbol> + 'a {\n     allow_unstable(sess, attrs, sym::rustc_allow_const_fn_unstable)\n }\n \n fn allow_unstable<'a>(\n     sess: &'a Session,\n     attrs: &'a [Attribute],\n     symbol: Symbol,\n-) -> Option<impl Iterator<Item = Symbol> + 'a> {\n+) -> impl Iterator<Item = Symbol> + 'a {\n     let attrs = sess.filter_by_name(attrs, symbol);\n     let list = attrs\n         .filter_map(move |attr| {\n@@ -1064,7 +1064,7 @@ fn allow_unstable<'a>(\n         })\n         .flatten();\n \n-    Some(list.into_iter().filter_map(move |it| {\n+    list.into_iter().filter_map(move |it| {\n         let name = it.ident().map(|ident| ident.name);\n         if name.is_none() {\n             sess.diagnostic().span_err(\n@@ -1073,5 +1073,5 @@ fn allow_unstable<'a>(\n             );\n         }\n         name\n-    }))\n+    })\n }"}, {"sha": "f5ae406faec2d071f644aa3c4c7a615c1732c39c", "filename": "compiler/rustc_codegen_ssa/src/back/write.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8a9f7862bcfa5870a34bb54f77a03c73d1db5c37/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a9f7862bcfa5870a34bb54f77a03c73d1db5c37/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs?ref=8a9f7862bcfa5870a34bb54f77a03c73d1db5c37", "patch": "@@ -735,7 +735,7 @@ fn execute_work_item<B: ExtraBackendMethods>(\n     match work_item {\n         WorkItem::Optimize(module) => execute_optimize_work_item(cgcx, module, module_config),\n         WorkItem::CopyPostLtoArtifacts(module) => {\n-            execute_copy_from_cache_work_item(cgcx, module, module_config)\n+            Ok(execute_copy_from_cache_work_item(cgcx, module, module_config))\n         }\n         WorkItem::LTO(module) => execute_lto_work_item(cgcx, module, module_config),\n     }\n@@ -844,7 +844,7 @@ fn execute_copy_from_cache_work_item<B: ExtraBackendMethods>(\n     cgcx: &CodegenContext<B>,\n     module: CachedModuleCodegen,\n     module_config: &ModuleConfig,\n-) -> Result<WorkItemResult<B>, FatalError> {\n+) -> WorkItemResult<B> {\n     let incr_comp_session_dir = cgcx.incr_comp_session_dir.as_ref().unwrap();\n     let mut object = None;\n     if let Some(saved_file) = module.source.saved_file {\n@@ -870,13 +870,13 @@ fn execute_copy_from_cache_work_item<B: ExtraBackendMethods>(\n \n     assert_eq!(object.is_some(), module_config.emit_obj != EmitObj::None);\n \n-    Ok(WorkItemResult::Compiled(CompiledModule {\n+    WorkItemResult::Compiled(CompiledModule {\n         name: module.name,\n         kind: ModuleKind::Regular,\n         object,\n         dwarf_object: None,\n         bytecode: None,\n-    }))\n+    })\n }\n \n fn execute_lto_work_item<B: ExtraBackendMethods>("}, {"sha": "ca304c05cdce30614a7e464c2255f62e2cc2b5a8", "filename": "compiler/rustc_expand/src/base.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8a9f7862bcfa5870a34bb54f77a03c73d1db5c37/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a9f7862bcfa5870a34bb54f77a03c73d1db5c37/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbase.rs?ref=8a9f7862bcfa5870a34bb54f77a03c73d1db5c37", "patch": "@@ -756,8 +756,8 @@ impl SyntaxExtension {\n         name: Symbol,\n         attrs: &[ast::Attribute],\n     ) -> SyntaxExtension {\n-        let allow_internal_unstable = attr::allow_internal_unstable(sess, &attrs)\n-            .map(|features| features.collect::<Vec<Symbol>>().into());\n+        let allow_internal_unstable =\n+            Some(attr::allow_internal_unstable(sess, &attrs).collect::<Vec<Symbol>>().into());\n \n         let mut local_inner_macros = false;\n         if let Some(macro_export) = sess.find_by_name(attrs, sym::macro_export) {"}, {"sha": "449b3a82dcbb7c68f8423071d3a85975fa21b461", "filename": "compiler/rustc_middle/src/mir/interpret/allocation.rs", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8a9f7862bcfa5870a34bb54f77a03c73d1db5c37/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a9f7862bcfa5870a34bb54f77a03c73d1db5c37/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs?ref=8a9f7862bcfa5870a34bb54f77a03c73d1db5c37", "patch": "@@ -266,7 +266,7 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n         let range = self.check_bounds(ptr.offset, size);\n \n         self.mark_init(ptr, size, true);\n-        self.clear_relocations(cx, ptr, size)?;\n+        self.clear_relocations(cx, ptr, size);\n \n         AllocationExtra::memory_written(self, ptr, size)?;\n \n@@ -484,18 +484,13 @@ impl<'tcx, Tag: Copy, Extra> Allocation<Tag, Extra> {\n     /// uninitialized. This is a somewhat odd \"spooky action at a distance\",\n     /// but it allows strictly more code to run than if we would just error\n     /// immediately in that case.\n-    fn clear_relocations(\n-        &mut self,\n-        cx: &impl HasDataLayout,\n-        ptr: Pointer<Tag>,\n-        size: Size,\n-    ) -> InterpResult<'tcx> {\n+    fn clear_relocations(&mut self, cx: &impl HasDataLayout, ptr: Pointer<Tag>, size: Size) {\n         // Find the start and end of the given range and its outermost relocations.\n         let (first, last) = {\n             // Find all relocations overlapping the given range.\n             let relocations = self.get_relocations(cx, ptr, size);\n             if relocations.is_empty() {\n-                return Ok(());\n+                return;\n             }\n \n             (\n@@ -517,8 +512,6 @@ impl<'tcx, Tag: Copy, Extra> Allocation<Tag, Extra> {\n \n         // Forget all the relocations.\n         self.relocations.remove_range(first..last);\n-\n-        Ok(())\n     }\n \n     /// Errors if there are relocations overlapping with the edges of the"}, {"sha": "12dcb95187cff4b32ae52ada59f6448a0ca0fddd", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8a9f7862bcfa5870a34bb54f77a03c73d1db5c37/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a9f7862bcfa5870a34bb54f77a03c73d1db5c37/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=8a9f7862bcfa5870a34bb54f77a03c73d1db5c37", "patch": "@@ -130,6 +130,7 @@ impl IntegerExt for Integer {\n \n         if repr.c() {\n             match &tcx.sess.target.arch[..] {\n+                \"hexagon\" => min_from_extern = Some(I8),\n                 // WARNING: the ARM EABI has two variants; the one corresponding\n                 // to `at_least == I32` appears to be used on Linux and NetBSD,\n                 // but some systems may use the variant corresponding to no"}, {"sha": "d36b3a7d9b56ecd7d4f59a26b86402d932146200", "filename": "compiler/rustc_mir/src/interpret/intrinsics.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8a9f7862bcfa5870a34bb54f77a03c73d1db5c37/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a9f7862bcfa5870a34bb54f77a03c73d1db5c37/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Fintrinsics.rs?ref=8a9f7862bcfa5870a34bb54f77a03c73d1db5c37", "patch": "@@ -23,11 +23,7 @@ use super::{\n mod caller_location;\n mod type_name;\n \n-fn numeric_intrinsic<'tcx, Tag>(\n-    name: Symbol,\n-    bits: u128,\n-    kind: Primitive,\n-) -> InterpResult<'tcx, Scalar<Tag>> {\n+fn numeric_intrinsic<Tag>(name: Symbol, bits: u128, kind: Primitive) -> Scalar<Tag> {\n     let size = match kind {\n         Primitive::Int(integer, _) => integer.size(),\n         _ => bug!(\"invalid `{}` argument: {:?}\", name, bits),\n@@ -41,7 +37,7 @@ fn numeric_intrinsic<'tcx, Tag>(\n         sym::bitreverse => (bits << extra).reverse_bits(),\n         _ => bug!(\"not a numeric intrinsic: {}\", name),\n     };\n-    Ok(Scalar::from_uint(bits_out, size))\n+    Scalar::from_uint(bits_out, size)\n }\n \n /// The logic for all nullary intrinsics is implemented here. These intrinsics don't get evaluated\n@@ -208,7 +204,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 if nonzero && bits == 0 {\n                     throw_ub_format!(\"`{}_nonzero` called on 0\", intrinsic_name);\n                 }\n-                let out_val = numeric_intrinsic(intrinsic_name, bits, kind)?;\n+                let out_val = numeric_intrinsic(intrinsic_name, bits, kind);\n                 self.write_scalar(out_val, dest)?;\n             }\n             sym::add_with_overflow | sym::sub_with_overflow | sym::mul_with_overflow => {"}, {"sha": "19aee033a6923fb1cda51eef51fe67efb3999160", "filename": "compiler/rustc_mir/src/transform/check_consts/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8a9f7862bcfa5870a34bb54f77a03c73d1db5c37/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a9f7862bcfa5870a34bb54f77a03c73d1db5c37/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fmod.rs?ref=8a9f7862bcfa5870a34bb54f77a03c73d1db5c37", "patch": "@@ -85,8 +85,7 @@ pub fn rustc_allow_const_fn_unstable(\n     feature_gate: Symbol,\n ) -> bool {\n     let attrs = tcx.get_attrs(def_id);\n-    attr::rustc_allow_const_fn_unstable(&tcx.sess, attrs)\n-        .map_or(false, |mut features| features.any(|name| name == feature_gate))\n+    attr::rustc_allow_const_fn_unstable(&tcx.sess, attrs).any(|name| name == feature_gate)\n }\n \n // Returns `true` if the given `const fn` is \"const-stable\"."}, {"sha": "28bfaea4555b5070e6e7435f29a364cf79aaee75", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8a9f7862bcfa5870a34bb54f77a03c73d1db5c37/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a9f7862bcfa5870a34bb54f77a03c73d1db5c37/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=8a9f7862bcfa5870a34bb54f77a03c73d1db5c37", "patch": "@@ -426,7 +426,7 @@ impl<'a> Parser<'a> {\n         let span = self.mk_expr_sp(&lhs, lhs.span, rhs_span);\n         let limits =\n             if op == AssocOp::DotDot { RangeLimits::HalfOpen } else { RangeLimits::Closed };\n-        Ok(self.mk_expr(span, self.mk_range(Some(lhs), rhs, limits)?, AttrVec::new()))\n+        Ok(self.mk_expr(span, self.mk_range(Some(lhs), rhs, limits), AttrVec::new()))\n     }\n \n     fn is_at_start_of_range_notation_rhs(&self) -> bool {\n@@ -474,7 +474,7 @@ impl<'a> Parser<'a> {\n             } else {\n                 (lo, None)\n             };\n-            Ok(this.mk_expr(span, this.mk_range(None, opt_end, limits)?, attrs.into()))\n+            Ok(this.mk_expr(span, this.mk_range(None, opt_end, limits), attrs.into()))\n         })\n     }\n \n@@ -1041,7 +1041,7 @@ impl<'a> Parser<'a> {\n     /// Assuming we have just parsed `.`, continue parsing into an expression.\n     fn parse_dot_suffix(&mut self, self_arg: P<Expr>, lo: Span) -> PResult<'a, P<Expr>> {\n         if self.token.uninterpolated_span().rust_2018() && self.eat_keyword(kw::Await) {\n-            return self.mk_await_expr(self_arg, lo);\n+            return Ok(self.mk_await_expr(self_arg, lo));\n         }\n \n         let fn_span_lo = self.token.span;\n@@ -2396,12 +2396,12 @@ impl<'a> Parser<'a> {\n         start: Option<P<Expr>>,\n         end: Option<P<Expr>>,\n         limits: RangeLimits,\n-    ) -> PResult<'a, ExprKind> {\n+    ) -> ExprKind {\n         if end.is_none() && limits == RangeLimits::Closed {\n             self.error_inclusive_range_with_no_end(self.prev_token.span);\n-            Ok(ExprKind::Err)\n+            ExprKind::Err\n         } else {\n-            Ok(ExprKind::Range(start, end, limits))\n+            ExprKind::Range(start, end, limits)\n         }\n     }\n \n@@ -2421,11 +2421,11 @@ impl<'a> Parser<'a> {\n         ExprKind::Call(f, args)\n     }\n \n-    fn mk_await_expr(&mut self, self_arg: P<Expr>, lo: Span) -> PResult<'a, P<Expr>> {\n+    fn mk_await_expr(&mut self, self_arg: P<Expr>, lo: Span) -> P<Expr> {\n         let span = lo.to(self.prev_token.span);\n         let await_expr = self.mk_expr(span, ExprKind::Await(self_arg), AttrVec::new());\n         self.recover_from_await_method_call();\n-        Ok(await_expr)\n+        await_expr\n     }\n \n     crate fn mk_expr(&self, span: Span, kind: ExprKind, attrs: AttrVec) -> P<Expr> {"}, {"sha": "f3f5fc9af64fea7302e7dc4211d86e6d512fa0b8", "filename": "compiler/rustc_parse/src/parser/item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8a9f7862bcfa5870a34bb54f77a03c73d1db5c37/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a9f7862bcfa5870a34bb54f77a03c73d1db5c37/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs?ref=8a9f7862bcfa5870a34bb54f77a03c73d1db5c37", "patch": "@@ -1679,7 +1679,7 @@ impl<'a> Parser<'a> {\n         let constness = self.parse_constness();\n         let asyncness = self.parse_asyncness();\n         let unsafety = self.parse_unsafety();\n-        let ext = self.parse_extern()?;\n+        let ext = self.parse_extern();\n \n         if let Async::Yes { span, .. } = asyncness {\n             self.ban_async_in_2015(span);"}, {"sha": "1292286bc18b0dc68450db6f3b18562c6d7465c6", "filename": "compiler/rustc_parse/src/parser/mod.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8a9f7862bcfa5870a34bb54f77a03c73d1db5c37/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a9f7862bcfa5870a34bb54f77a03c73d1db5c37/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs?ref=8a9f7862bcfa5870a34bb54f77a03c73d1db5c37", "patch": "@@ -1202,12 +1202,8 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parses `extern string_literal?`.\n-    fn parse_extern(&mut self) -> PResult<'a, Extern> {\n-        Ok(if self.eat_keyword(kw::Extern) {\n-            Extern::from_abi(self.parse_abi())\n-        } else {\n-            Extern::None\n-        })\n+    fn parse_extern(&mut self) -> Extern {\n+        if self.eat_keyword(kw::Extern) { Extern::from_abi(self.parse_abi()) } else { Extern::None }\n     }\n \n     /// Parses a string literal as an ABI spec."}, {"sha": "da713566c31211e607e4f63d1af344b231611099", "filename": "compiler/rustc_passes/src/check_const.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8a9f7862bcfa5870a34bb54f77a03c73d1db5c37/compiler%2Frustc_passes%2Fsrc%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a9f7862bcfa5870a34bb54f77a03c73d1db5c37/compiler%2Frustc_passes%2Fsrc%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fcheck_const.rs?ref=8a9f7862bcfa5870a34bb54f77a03c73d1db5c37", "patch": "@@ -106,7 +106,7 @@ impl<'tcx> CheckConstVisitor<'tcx> {\n             // However, we cannot allow stable `const fn`s to use unstable features without an explicit\n             // opt-in via `rustc_allow_const_fn_unstable`.\n             attr::rustc_allow_const_fn_unstable(&tcx.sess, &tcx.get_attrs(def_id))\n-                .map_or(false, |mut features| features.any(|name| name == feature_gate))\n+                .any(|name| name == feature_gate)\n         };\n \n         match required_gates {"}, {"sha": "2faf128c491fdc3af54b65096853fecfa0520b6f", "filename": "compiler/rustc_typeck/src/check/expr.rs", "status": "modified", "additions": 17, "deletions": 14, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/8a9f7862bcfa5870a34bb54f77a03c73d1db5c37/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a9f7862bcfa5870a34bb54f77a03c73d1db5c37/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs?ref=8a9f7862bcfa5870a34bb54f77a03c73d1db5c37", "patch": "@@ -1348,33 +1348,36 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         span: Span,\n         remaining_fields: FxHashMap<Ident, (usize, &ty::FieldDef)>,\n     ) {\n-        let tcx = self.tcx;\n         let len = remaining_fields.len();\n \n         let mut displayable_field_names =\n             remaining_fields.keys().map(|ident| ident.as_str()).collect::<Vec<_>>();\n \n         displayable_field_names.sort();\n \n-        let truncated_fields_error = if len <= 3 {\n-            String::new()\n-        } else {\n-            format!(\" and {} other field{}\", (len - 3), if len - 3 == 1 { \"\" } else { \"s\" })\n+        let mut truncated_fields_error = String::new();\n+        let remaining_fields_names = match &displayable_field_names[..] {\n+            [field1] => format!(\"`{}`\", field1),\n+            [field1, field2] => format!(\"`{}` and `{}`\", field1, field2),\n+            [field1, field2, field3] => format!(\"`{}`, `{}` and `{}`\", field1, field2, field3),\n+            _ => {\n+                truncated_fields_error =\n+                    format!(\" and {} other field{}\", len - 3, pluralize!(len - 3));\n+                displayable_field_names\n+                    .iter()\n+                    .take(3)\n+                    .map(|n| format!(\"`{}`\", n))\n+                    .collect::<Vec<_>>()\n+                    .join(\", \")\n+            }\n         };\n \n-        let remaining_fields_names = displayable_field_names\n-            .iter()\n-            .take(3)\n-            .map(|n| format!(\"`{}`\", n))\n-            .collect::<Vec<_>>()\n-            .join(\", \");\n-\n         struct_span_err!(\n-            tcx.sess,\n+            self.tcx.sess,\n             span,\n             E0063,\n             \"missing field{} {}{} in initializer of `{}`\",\n-            pluralize!(remaining_fields.len()),\n+            pluralize!(len),\n             remaining_fields_names,\n             truncated_fields_error,\n             adt_ty"}, {"sha": "d4fd7545d9bda2303ed8820357de44e16cc5280e", "filename": "library/core/src/array/mod.rs", "status": "modified", "additions": 110, "deletions": 60, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/8a9f7862bcfa5870a34bb54f77a03c73d1db5c37/library%2Fcore%2Fsrc%2Farray%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a9f7862bcfa5870a34bb54f77a03c73d1db5c37/library%2Fcore%2Fsrc%2Farray%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Farray%2Fmod.rs?ref=8a9f7862bcfa5870a34bb54f77a03c73d1db5c37", "patch": "@@ -11,8 +11,9 @@ use crate::cmp::Ordering;\n use crate::convert::{Infallible, TryFrom};\n use crate::fmt;\n use crate::hash::{self, Hash};\n+use crate::iter::TrustedLen;\n use crate::marker::Unsize;\n-use crate::mem::MaybeUninit;\n+use crate::mem::{self, MaybeUninit};\n use crate::ops::{Index, IndexMut};\n use crate::slice::{Iter, IterMut};\n \n@@ -426,41 +427,13 @@ impl<T, const N: usize> [T; N] {\n     /// assert_eq!(y, [6, 9, 3, 3]);\n     /// ```\n     #[unstable(feature = \"array_map\", issue = \"75243\")]\n-    pub fn map<F, U>(self, mut f: F) -> [U; N]\n+    pub fn map<F, U>(self, f: F) -> [U; N]\n     where\n         F: FnMut(T) -> U,\n     {\n-        struct Guard<T, const N: usize> {\n-            dst: *mut T,\n-            initialized: usize,\n-        }\n-\n-        impl<T, const N: usize> Drop for Guard<T, N> {\n-            fn drop(&mut self) {\n-                debug_assert!(self.initialized <= N);\n-\n-                let initialized_part =\n-                    crate::ptr::slice_from_raw_parts_mut(self.dst, self.initialized);\n-                // SAFETY: this raw slice will contain only initialized objects\n-                // that's why, it is allowed to drop it.\n-                unsafe {\n-                    crate::ptr::drop_in_place(initialized_part);\n-                }\n-            }\n-        }\n-        let mut dst = MaybeUninit::uninit_array::<N>();\n-        let mut guard: Guard<U, N> =\n-            Guard { dst: MaybeUninit::slice_as_mut_ptr(&mut dst), initialized: 0 };\n-        for (src, dst) in IntoIter::new(self).zip(&mut dst) {\n-            dst.write(f(src));\n-            guard.initialized += 1;\n-        }\n-        // FIXME: Convert to crate::mem::transmute once it works with generics.\n-        // unsafe { crate::mem::transmute::<[MaybeUninit<U>; N], [U; N]>(dst) }\n-        crate::mem::forget(guard);\n-        // SAFETY: At this point we've properly initialized the whole array\n-        // and we just need to cast it to the correct type.\n-        unsafe { crate::mem::transmute_copy::<_, [U; N]>(&dst) }\n+        // SAFETY: we know for certain that this iterator will yield exactly `N`\n+        // items.\n+        unsafe { collect_into_array_unchecked(&mut IntoIter::new(self).map(f)) }\n     }\n \n     /// 'Zips up' two arrays into a single array of pairs.\n@@ -481,15 +454,11 @@ impl<T, const N: usize> [T; N] {\n     /// ```\n     #[unstable(feature = \"array_zip\", issue = \"80094\")]\n     pub fn zip<U>(self, rhs: [U; N]) -> [(T, U); N] {\n-        let mut dst = MaybeUninit::uninit_array::<N>();\n-        for (i, (lhs, rhs)) in IntoIter::new(self).zip(IntoIter::new(rhs)).enumerate() {\n-            dst[i].write((lhs, rhs));\n-        }\n-        // FIXME: Convert to crate::mem::transmute once it works with generics.\n-        // unsafe { crate::mem::transmute::<[MaybeUninit<U>; N], [U; N]>(dst) }\n-        // SAFETY: At this point we've properly initialized the whole array\n-        // and we just need to cast it to the correct type.\n-        unsafe { crate::mem::transmute_copy::<_, [(T, U); N]>(&dst) }\n+        let mut iter = IntoIter::new(self).zip(IntoIter::new(rhs));\n+\n+        // SAFETY: we know for certain that this iterator will yield exactly `N`\n+        // items.\n+        unsafe { collect_into_array_unchecked(&mut iter) }\n     }\n \n     /// Returns a slice containing the entire array. Equivalent to `&s[..]`.\n@@ -535,16 +504,9 @@ impl<T, const N: usize> [T; N] {\n     /// ```\n     #[unstable(feature = \"array_methods\", issue = \"76118\")]\n     pub fn each_ref(&self) -> [&T; N] {\n-        // Unlike in `map`, we don't need a guard here, as dropping a reference\n-        // is a noop.\n-        let mut out = MaybeUninit::uninit_array::<N>();\n-        for (src, dst) in self.iter().zip(&mut out) {\n-            dst.write(src);\n-        }\n-\n-        // SAFETY: All elements of `dst` are properly initialized and\n-        // `MaybeUninit<T>` has the same layout as `T`, so this cast is valid.\n-        unsafe { (&mut out as *mut _ as *mut [&T; N]).read() }\n+        // SAFETY: we know for certain that this iterator will yield exactly `N`\n+        // items.\n+        unsafe { collect_into_array_unchecked(&mut self.iter()) }\n     }\n \n     /// Borrows each element mutably and returns an array of mutable references\n@@ -564,15 +526,103 @@ impl<T, const N: usize> [T; N] {\n     /// ```\n     #[unstable(feature = \"array_methods\", issue = \"76118\")]\n     pub fn each_mut(&mut self) -> [&mut T; N] {\n-        // Unlike in `map`, we don't need a guard here, as dropping a reference\n-        // is a noop.\n-        let mut out = MaybeUninit::uninit_array::<N>();\n-        for (src, dst) in self.iter_mut().zip(&mut out) {\n-            dst.write(src);\n+        // SAFETY: we know for certain that this iterator will yield exactly `N`\n+        // items.\n+        unsafe { collect_into_array_unchecked(&mut self.iter_mut()) }\n+    }\n+}\n+\n+/// Pulls `N` items from `iter` and returns them as an array. If the iterator\n+/// yields fewer than `N` items, this function exhibits undefined behavior.\n+///\n+/// See [`collect_into_array`] for more information.\n+///\n+///\n+/// # Safety\n+///\n+/// It is up to the caller to guarantee that `iter` yields at least `N` items.\n+/// Violating this condition causes undefined behavior.\n+unsafe fn collect_into_array_unchecked<I, const N: usize>(iter: &mut I) -> [I::Item; N]\n+where\n+    // Note: `TrustedLen` here is somewhat of an experiment. This is just an\n+    // internal function, so feel free to remove if this bound turns out to be a\n+    // bad idea. In that case, remember to also remove the lower bound\n+    // `debug_assert!` below!\n+    I: Iterator + TrustedLen,\n+{\n+    debug_assert!(N <= iter.size_hint().1.unwrap_or(usize::MAX));\n+    debug_assert!(N <= iter.size_hint().0);\n+\n+    match collect_into_array(iter) {\n+        Some(array) => array,\n+        // SAFETY: covered by the function contract.\n+        None => unsafe { crate::hint::unreachable_unchecked() },\n+    }\n+}\n+\n+/// Pulls `N` items from `iter` and returns them as an array. If the iterator\n+/// yields fewer than `N` items, `None` is returned and all already yielded\n+/// items are dropped.\n+///\n+/// Since the iterator is passed as mutable reference and this function calls\n+/// `next` at most `N` times, the iterator can still be used afterwards to\n+/// retrieve the remaining items.\n+///\n+/// If `iter.next()` panicks, all items already yielded by the iterator are\n+/// dropped.\n+fn collect_into_array<I, const N: usize>(iter: &mut I) -> Option<[I::Item; N]>\n+where\n+    I: Iterator,\n+{\n+    if N == 0 {\n+        // SAFETY: An empty array is always inhabited and has no validity invariants.\n+        return unsafe { Some(mem::zeroed()) };\n+    }\n+\n+    struct Guard<T, const N: usize> {\n+        ptr: *mut T,\n+        initialized: usize,\n+    }\n+\n+    impl<T, const N: usize> Drop for Guard<T, N> {\n+        fn drop(&mut self) {\n+            debug_assert!(self.initialized <= N);\n+\n+            let initialized_part = crate::ptr::slice_from_raw_parts_mut(self.ptr, self.initialized);\n+\n+            // SAFETY: this raw slice will contain only initialized objects.\n+            unsafe {\n+                crate::ptr::drop_in_place(initialized_part);\n+            }\n+        }\n+    }\n+\n+    let mut array = MaybeUninit::uninit_array::<N>();\n+    let mut guard: Guard<_, N> =\n+        Guard { ptr: MaybeUninit::slice_as_mut_ptr(&mut array), initialized: 0 };\n+\n+    while let Some(item) = iter.next() {\n+        // SAFETY: `guard.initialized` starts at 0, is increased by one in the\n+        // loop and the loop is aborted once it reaches N (which is\n+        // `array.len()`).\n+        unsafe {\n+            array.get_unchecked_mut(guard.initialized).write(item);\n         }\n+        guard.initialized += 1;\n+\n+        // Check if the whole array was initialized.\n+        if guard.initialized == N {\n+            mem::forget(guard);\n \n-        // SAFETY: All elements of `dst` are properly initialized and\n-        // `MaybeUninit<T>` has the same layout as `T`, so this cast is valid.\n-        unsafe { (&mut out as *mut _ as *mut [&mut T; N]).read() }\n+            // SAFETY: the condition above asserts that all elements are\n+            // initialized.\n+            let out = unsafe { MaybeUninit::array_assume_init(array) };\n+            return Some(out);\n+        }\n     }\n+\n+    // This is only reached if the iterator is exhausted before\n+    // `guard.initialized` reaches `N`. Also note that `guard` is dropped here,\n+    // dropping all already initialized elements.\n+    None\n }"}, {"sha": "cce1242d84f52ff5496879009ad727ee426337cc", "filename": "library/core/src/cell.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/8a9f7862bcfa5870a34bb54f77a03c73d1db5c37/library%2Fcore%2Fsrc%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a9f7862bcfa5870a34bb54f77a03c73d1db5c37/library%2Fcore%2Fsrc%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fcell.rs?ref=8a9f7862bcfa5870a34bb54f77a03c73d1db5c37", "patch": "@@ -1619,17 +1619,18 @@ impl<T: ?Sized + fmt::Display> fmt::Display for RefMut<'_, T> {\n \n /// The core primitive for interior mutability in Rust.\n ///\n-/// `UnsafeCell<T>` is a type that wraps some `T` and indicates unsafe interior operations on the\n-/// wrapped type. Types with an `UnsafeCell<T>` field are considered to have an 'unsafe interior'.\n-/// The `UnsafeCell<T>` type is the only legal way to obtain aliasable data that is considered\n-/// mutable. In general, transmuting a `&T` type into a `&mut T` is considered undefined behavior.\n+/// If you have a reference `&T`, then normally in Rust the compiler performs optimizations based on\n+/// the knowledge that `&T` points to immutable data. Mutating that data, for example through an\n+/// alias or by transmuting an `&T` into an `&mut T`, is considered undefined behavior.\n+/// `UnsafeCell<T>` opts-out of the immutability guarantee for `&T`: a shared reference\n+/// `&UnsafeCell<T>` may point to data that is being mutated. This is called \"interior mutability\".\n ///\n-/// If you have a reference `&SomeStruct`, then normally in Rust all fields of `SomeStruct` are\n-/// immutable. The compiler makes optimizations based on the knowledge that `&T` is not mutably\n-/// aliased or mutated, and that `&mut T` is unique. `UnsafeCell<T>` is the only core language\n-/// feature to work around the restriction that `&T` may not be mutated. All other types that\n-/// allow internal mutability, such as `Cell<T>` and `RefCell<T>`, use `UnsafeCell` to wrap their\n-/// internal data. There is *no* legal way to obtain aliasing `&mut`, not even with `UnsafeCell<T>`.\n+/// All other types that allow internal mutability, such as `Cell<T>` and `RefCell<T>`, internally\n+/// use `UnsafeCell` to wrap their data.\n+///\n+/// Note that only the immutability guarantee for shared references is affected by `UnsafeCell`. The\n+/// uniqueness guarantee for mutable references is unaffected. There is *no* legal way to obtain\n+/// aliasing `&mut`, not even with `UnsafeCell<T>`.\n ///\n /// The `UnsafeCell` API itself is technically very simple: [`.get()`] gives you a raw pointer\n /// `*mut T` to its contents. It is up to _you_ as the abstraction designer to use that raw pointer"}, {"sha": "5e46d2c17c941a17168bd4c43165eb701ae81e45", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8a9f7862bcfa5870a34bb54f77a03c73d1db5c37/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a9f7862bcfa5870a34bb54f77a03c73d1db5c37/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=8a9f7862bcfa5870a34bb54f77a03c73d1db5c37", "patch": "@@ -263,6 +263,7 @@\n #![feature(exact_size_is_empty)]\n #![feature(exhaustive_patterns)]\n #![feature(extend_one)]\n+#![feature(extended_key_value_attributes)]\n #![feature(external_doc)]\n #![feature(fn_traits)]\n #![feature(format_args_nl)]"}, {"sha": "22c98d7ade99240e3a0b5961f84ec597c69c82d9", "filename": "library/std/src/os/raw/mod.rs", "status": "modified", "additions": 56, "deletions": 54, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/8a9f7862bcfa5870a34bb54f77a03c73d1db5c37/library%2Fstd%2Fsrc%2Fos%2Fraw%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a9f7862bcfa5870a34bb54f77a03c73d1db5c37/library%2Fstd%2Fsrc%2Fos%2Fraw%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fraw%2Fmod.rs?ref=8a9f7862bcfa5870a34bb54f77a03c73d1db5c37", "patch": "@@ -11,7 +11,41 @@\n #[cfg(test)]\n mod tests;\n \n-#[doc(include = \"char.md\")]\n+use core::num::*;\n+\n+macro_rules! type_alias_no_nz {\n+    {\n+      $Docfile:tt, $Alias:ident = $Real:ty;\n+      $( $Cfg:tt )*\n+    } => {\n+        #[doc(include = $Docfile)]\n+        $( $Cfg )*\n+        #[stable(feature = \"raw_os\", since = \"1.1.0\")]\n+        pub type $Alias = $Real;\n+    }\n+}\n+\n+// To verify that the NonZero types in this file's macro invocations correspond\n+//\n+//  perl -n < library/std/src/os/raw/mod.rs -e 'next unless m/type_alias\\!/; die \"$_ ?\" unless m/, (c_\\w+) = (\\w+), NonZero_(\\w+) = NonZero(\\w+)/; die \"$_ ?\" unless $3 eq $1 and $4 eq ucfirst $2'\n+//\n+// NB this does not check that the main c_* types are right.\n+\n+macro_rules! type_alias {\n+    {\n+      $Docfile:tt, $Alias:ident = $Real:ty, $NZAlias:ident = $NZReal:ty;\n+      $( $Cfg:tt )*\n+    } => {\n+        type_alias_no_nz! { $Docfile, $Alias = $Real; $( $Cfg )* }\n+\n+        #[doc = concat!(\"Type alias for `NonZero` version of [`\", stringify!($Alias), \"`]\")]\n+        #[unstable(feature = \"raw_os_nonzero\", issue = \"82363\")]\n+        $( $Cfg )*\n+        pub type $NZAlias = $NZReal;\n+    }\n+}\n+\n+type_alias! { \"char.md\", c_char = u8, NonZero_c_char = NonZeroU8;\n #[cfg(any(\n     all(\n         target_os = \"linux\",\n@@ -52,10 +86,8 @@ mod tests;\n         )\n     ),\n     all(target_os = \"fuchsia\", target_arch = \"aarch64\")\n-))]\n-#[stable(feature = \"raw_os\", since = \"1.1.0\")]\n-pub type c_char = u8;\n-#[doc(include = \"char.md\")]\n+))]}\n+type_alias! { \"char.md\", c_char = i8, NonZero_c_char = NonZeroI8;\n #[cfg(not(any(\n     all(\n         target_os = \"linux\",\n@@ -96,55 +128,25 @@ pub type c_char = u8;\n         )\n     ),\n     all(target_os = \"fuchsia\", target_arch = \"aarch64\")\n-)))]\n-#[stable(feature = \"raw_os\", since = \"1.1.0\")]\n-pub type c_char = i8;\n-#[doc(include = \"schar.md\")]\n-#[stable(feature = \"raw_os\", since = \"1.1.0\")]\n-pub type c_schar = i8;\n-#[doc(include = \"uchar.md\")]\n-#[stable(feature = \"raw_os\", since = \"1.1.0\")]\n-pub type c_uchar = u8;\n-#[doc(include = \"short.md\")]\n-#[stable(feature = \"raw_os\", since = \"1.1.0\")]\n-pub type c_short = i16;\n-#[doc(include = \"ushort.md\")]\n-#[stable(feature = \"raw_os\", since = \"1.1.0\")]\n-pub type c_ushort = u16;\n-#[doc(include = \"int.md\")]\n-#[stable(feature = \"raw_os\", since = \"1.1.0\")]\n-pub type c_int = i32;\n-#[doc(include = \"uint.md\")]\n-#[stable(feature = \"raw_os\", since = \"1.1.0\")]\n-pub type c_uint = u32;\n-#[doc(include = \"long.md\")]\n-#[cfg(any(target_pointer_width = \"32\", windows))]\n-#[stable(feature = \"raw_os\", since = \"1.1.0\")]\n-pub type c_long = i32;\n-#[doc(include = \"ulong.md\")]\n-#[cfg(any(target_pointer_width = \"32\", windows))]\n-#[stable(feature = \"raw_os\", since = \"1.1.0\")]\n-pub type c_ulong = u32;\n-#[doc(include = \"long.md\")]\n-#[cfg(all(target_pointer_width = \"64\", not(windows)))]\n-#[stable(feature = \"raw_os\", since = \"1.1.0\")]\n-pub type c_long = i64;\n-#[doc(include = \"ulong.md\")]\n-#[cfg(all(target_pointer_width = \"64\", not(windows)))]\n-#[stable(feature = \"raw_os\", since = \"1.1.0\")]\n-pub type c_ulong = u64;\n-#[doc(include = \"longlong.md\")]\n-#[stable(feature = \"raw_os\", since = \"1.1.0\")]\n-pub type c_longlong = i64;\n-#[doc(include = \"ulonglong.md\")]\n-#[stable(feature = \"raw_os\", since = \"1.1.0\")]\n-pub type c_ulonglong = u64;\n-#[doc(include = \"float.md\")]\n-#[stable(feature = \"raw_os\", since = \"1.1.0\")]\n-pub type c_float = f32;\n-#[doc(include = \"double.md\")]\n-#[stable(feature = \"raw_os\", since = \"1.1.0\")]\n-pub type c_double = f64;\n+)))]}\n+type_alias! { \"schar.md\", c_schar = i8, NonZero_c_schar = NonZeroI8; }\n+type_alias! { \"uchar.md\", c_uchar = u8, NonZero_c_uchar = NonZeroU8; }\n+type_alias! { \"short.md\", c_short = i16, NonZero_c_short = NonZeroI16; }\n+type_alias! { \"ushort.md\", c_ushort = u16, NonZero_c_ushort = NonZeroU16; }\n+type_alias! { \"int.md\", c_int = i32, NonZero_c_int = NonZeroI32; }\n+type_alias! { \"uint.md\", c_uint = u32, NonZero_c_uint = NonZeroU32; }\n+type_alias! { \"long.md\", c_long = i32, NonZero_c_long = NonZeroI32;\n+#[cfg(any(target_pointer_width = \"32\", windows))] }\n+type_alias! { \"ulong.md\", c_ulong = u32, NonZero_c_ulong = NonZeroU32;\n+#[cfg(any(target_pointer_width = \"32\", windows))] }\n+type_alias! { \"long.md\", c_long = i64, NonZero_c_long = NonZeroI64;\n+#[cfg(all(target_pointer_width = \"64\", not(windows)))] }\n+type_alias! { \"ulong.md\", c_ulong = u64, NonZero_c_ulong = NonZeroU64;\n+#[cfg(all(target_pointer_width = \"64\", not(windows)))] }\n+type_alias! { \"longlong.md\", c_longlong = i64, NonZero_c_longlong = NonZeroI64; }\n+type_alias! { \"ulonglong.md\", c_ulonglong = u64, NonZero_c_ulonglong = NonZeroU64; }\n+type_alias_no_nz! { \"float.md\", c_float = f32; }\n+type_alias_no_nz! { \"double.md\", c_double = f64; }\n \n #[stable(feature = \"raw_os\", since = \"1.1.0\")]\n #[doc(no_inline)]"}, {"sha": "98e1299df2f261c2f6e0df847c86326a7443e7a6", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8a9f7862bcfa5870a34bb54f77a03c73d1db5c37/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a9f7862bcfa5870a34bb54f77a03c73d1db5c37/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=8a9f7862bcfa5870a34bb54f77a03c73d1db5c37", "patch": "@@ -1519,7 +1519,7 @@ fn normalize(cx: &mut DocContext<'tcx>, ty: Ty<'_>) -> Option<Ty<'tcx>> {\n     let lifted = ty.lift_to_tcx(cx.tcx).unwrap();\n     let normalized = cx.tcx.infer_ctxt().enter(|infcx| {\n         infcx\n-            .at(&ObligationCause::dummy(), cx.param_env.get())\n+            .at(&ObligationCause::dummy(), cx.param_env)\n             .normalize(lifted)\n             .map(|resolved| infcx.resolve_vars_if_possible(resolved.value))\n     });"}, {"sha": "dbf202a7321083b8139a8d9b983b60affbbd6e5b", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/8a9f7862bcfa5870a34bb54f77a03c73d1db5c37/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a9f7862bcfa5870a34bb54f77a03c73d1db5c37/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=8a9f7862bcfa5870a34bb54f77a03c73d1db5c37", "patch": "@@ -26,10 +26,7 @@ use rustc_span::DUMMY_SP;\n \n use std::mem;\n use std::rc::Rc;\n-use std::{\n-    cell::{Cell, RefCell},\n-    collections::hash_map::Entry,\n-};\n+use std::{cell::RefCell, collections::hash_map::Entry};\n \n use crate::clean;\n use crate::clean::inline::build_external_trait;\n@@ -49,7 +46,7 @@ crate struct DocContext<'tcx> {\n     /// Used for normalization.\n     ///\n     /// Most of this logic is copied from rustc_lint::late.\n-    crate param_env: Cell<ParamEnv<'tcx>>,\n+    crate param_env: ParamEnv<'tcx>,\n     /// Later on moved into `cache`\n     crate renderinfo: RefCell<RenderInfo>,\n     /// Later on moved through `clean::Crate` into `cache`\n@@ -67,7 +64,7 @@ crate struct DocContext<'tcx> {\n     crate ct_substs: RefCell<FxHashMap<DefId, clean::Constant>>,\n     /// Table synthetic type parameter for `impl Trait` in argument position -> bounds\n     crate impl_trait_bounds: RefCell<FxHashMap<ImplTraitParam, Vec<clean::GenericBound>>>,\n-    crate fake_def_ids: RefCell<FxHashMap<CrateNum, DefIndex>>,\n+    crate fake_def_ids: FxHashMap<CrateNum, DefIndex>,\n     /// Auto-trait or blanket impls processed so far, as `(self_ty, trait_def_id)`.\n     // FIXME(eddyb) make this a `ty::TraitRef<'tcx>` set.\n     crate generated_synthetics: RefCell<FxHashSet<(Ty<'tcx>, DefId)>>,\n@@ -89,9 +86,9 @@ impl<'tcx> DocContext<'tcx> {\n     }\n \n     crate fn with_param_env<T, F: FnOnce(&mut Self) -> T>(&mut self, def_id: DefId, f: F) -> T {\n-        let old_param_env = self.param_env.replace(self.tcx.param_env(def_id));\n+        let old_param_env = mem::replace(&mut self.param_env, self.tcx.param_env(def_id));\n         let ret = f(self);\n-        self.param_env.set(old_param_env);\n+        self.param_env = old_param_env;\n         ret\n     }\n \n@@ -140,16 +137,14 @@ impl<'tcx> DocContext<'tcx> {\n     /// [`RefCell`]: std::cell::RefCell\n     /// [`Debug`]: std::fmt::Debug\n     /// [`clean::Item`]: crate::clean::types::Item\n-    crate fn next_def_id(&self, crate_num: CrateNum) -> DefId {\n-        let mut fake_ids = self.fake_def_ids.borrow_mut();\n-\n-        let def_index = match fake_ids.entry(crate_num) {\n+    crate fn next_def_id(&mut self, crate_num: CrateNum) -> DefId {\n+        let def_index = match self.fake_def_ids.entry(crate_num) {\n             Entry::Vacant(e) => {\n                 let num_def_idx = {\n                     let num_def_idx = if crate_num == LOCAL_CRATE {\n                         self.tcx.hir().definitions().def_path_table().num_def_ids()\n                     } else {\n-                        self.enter_resolver(|r| r.cstore().num_def_ids(crate_num))\n+                        self.resolver.borrow_mut().access(|r| r.cstore().num_def_ids(crate_num))\n                     };\n \n                     DefIndex::from_usize(num_def_idx)\n@@ -511,7 +506,7 @@ crate fn run_global_ctxt(\n     let mut ctxt = DocContext {\n         tcx,\n         resolver,\n-        param_env: Cell::new(ParamEnv::empty()),\n+        param_env: ParamEnv::empty(),\n         external_traits: Default::default(),\n         active_extern_traits: Default::default(),\n         renderinfo: RefCell::new(renderinfo),"}, {"sha": "b7854bbf82b1723eb3c114aea7b11d7bc8677c94", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8a9f7862bcfa5870a34bb54f77a03c73d1db5c37/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a9f7862bcfa5870a34bb54f77a03c73d1db5c37/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=8a9f7862bcfa5870a34bb54f77a03c73d1db5c37", "patch": "@@ -1124,6 +1124,7 @@ crate fn plain_text_summary(md: &str) -> String {\n             Event::HardBreak | Event::SoftBreak => s.push(' '),\n             Event::Start(Tag::CodeBlock(..)) => break,\n             Event::End(Tag::Paragraph) => break,\n+            Event::End(Tag::Heading(..)) => break,\n             _ => (),\n         }\n     }"}, {"sha": "994fe8206e8d48a692b0eac282c179304c0f41eb", "filename": "src/librustdoc/html/markdown/tests.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8a9f7862bcfa5870a34bb54f77a03c73d1db5c37/src%2Flibrustdoc%2Fhtml%2Fmarkdown%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a9f7862bcfa5870a34bb54f77a03c73d1db5c37/src%2Flibrustdoc%2Fhtml%2Fmarkdown%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown%2Ftests.rs?ref=8a9f7862bcfa5870a34bb54f77a03c73d1db5c37", "patch": "@@ -230,6 +230,7 @@ fn test_plain_text_summary() {\n     t(\"code `let x = i32;` ...\", \"code `let x = i32;` ...\");\n     t(\"type `Type<'static>` ...\", \"type `Type<'static>` ...\");\n     t(\"# top header\", \"top header\");\n+    t(\"# top header\\n\\nfollowed by some text\", \"top header\");\n     t(\"## header\", \"header\");\n     t(\"first paragraph\\n\\nsecond paragraph\", \"first paragraph\");\n     t(\"```\\nfn main() {}\\n```\", \"\");"}, {"sha": "7f122bb8cb5ae410f010a695f72c9f0fb4003973", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8a9f7862bcfa5870a34bb54f77a03c73d1db5c37/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a9f7862bcfa5870a34bb54f77a03c73d1db5c37/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=8a9f7862bcfa5870a34bb54f77a03c73d1db5c37", "patch": "@@ -1548,7 +1548,10 @@ impl Context<'_> {\n         }\n         title.push_str(\" - Rust\");\n         let tyname = it.type_();\n-        let desc = if it.is_crate() {\n+        let desc = it.doc_value().as_ref().map(|doc| plain_text_summary(&doc));\n+        let desc = if let Some(desc) = desc {\n+            desc\n+        } else if it.is_crate() {\n             format!(\"API documentation for the Rust `{}` crate.\", self.shared.layout.krate)\n         } else {\n             format!("}, {"sha": "05ec42822084710f33aa970a074e78c1e63b985d", "filename": "src/test/rustdoc/description.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8a9f7862bcfa5870a34bb54f77a03c73d1db5c37/src%2Ftest%2Frustdoc%2Fdescription.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a9f7862bcfa5870a34bb54f77a03c73d1db5c37/src%2Ftest%2Frustdoc%2Fdescription.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fdescription.rs?ref=8a9f7862bcfa5870a34bb54f77a03c73d1db5c37", "patch": "@@ -0,0 +1,24 @@\n+#![crate_name = \"foo\"]\n+//! # Description test crate\n+//!\n+//! This is the contents of the test crate docstring.\n+//! It should not show up in the description.\n+\n+// @has 'foo/index.html' '//meta[@name=\"description\"]/@content' \\\n+//   'Description test crate'\n+// @!has - '//meta[@name=\"description\"]/@content' 'should not show up'\n+\n+// @has 'foo/foo_mod/index.html' '//meta[@name=\"description\"]/@content' \\\n+//   'First paragraph description.'\n+// @!has - '//meta[@name=\"description\"]/@content' 'Second paragraph'\n+/// First paragraph description.\n+///\n+/// Second paragraph should not show up.\n+pub mod foo_mod {\n+    pub struct __Thing {}\n+}\n+\n+// @has 'foo/fn.foo_fn.html' '//meta[@name=\"description\"]/@content' \\\n+//   'Only paragraph.'\n+/// Only paragraph.\n+pub fn foo_fn() {}"}, {"sha": "21d8e04d3f95a561310077e2b6840a6d3db060d0", "filename": "src/test/rustdoc/description_default.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8a9f7862bcfa5870a34bb54f77a03c73d1db5c37/src%2Ftest%2Frustdoc%2Fdescription_default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a9f7862bcfa5870a34bb54f77a03c73d1db5c37/src%2Ftest%2Frustdoc%2Fdescription_default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fdescription_default.rs?ref=8a9f7862bcfa5870a34bb54f77a03c73d1db5c37", "patch": "@@ -0,0 +1,14 @@\n+#![crate_name = \"foo\"]\n+\n+// @has 'foo/index.html' '//meta[@name=\"description\"]/@content' \\\n+//   'API documentation for the Rust `foo` crate.'\n+\n+// @has 'foo/foo_mod/index.html' '//meta[@name=\"description\"]/@content' \\\n+//   'API documentation for the Rust `foo_mod` mod in crate `foo`.'\n+pub mod foo_mod {\n+    pub struct __Thing {}\n+}\n+\n+// @has 'foo/fn.foo_fn.html' '//meta[@name=\"description\"]/@content' \\\n+//   'API documentation for the Rust `foo_fn` fn in crate `foo`.'\n+pub fn foo_fn() {}"}, {"sha": "58527cc0c5dd7d3754f1c68f0a9f8ed12ca2e95c", "filename": "src/test/ui/error-codes/E0063.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8a9f7862bcfa5870a34bb54f77a03c73d1db5c37/src%2Ftest%2Fui%2Ferror-codes%2FE0063.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a9f7862bcfa5870a34bb54f77a03c73d1db5c37/src%2Ftest%2Fui%2Ferror-codes%2FE0063.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0063.rs?ref=8a9f7862bcfa5870a34bb54f77a03c73d1db5c37", "patch": "@@ -32,7 +32,7 @@ fn main() {\n     let w = SingleFoo { };\n     //~^ ERROR missing field `x` in initializer of `SingleFoo`\n     let x = PluralFoo {x: 1};\n-    //~^ ERROR missing fields `y`, `z` in initializer of `PluralFoo`\n+    //~^ ERROR missing fields `y` and `z` in initializer of `PluralFoo`\n     let y = TruncatedFoo{x:1};\n     //~^ missing fields `a`, `b`, `y` and 1 other field in initializer of `TruncatedFoo`\n     let z = TruncatedPluralFoo{x:1};"}, {"sha": "5dc4927071b6b128cc620db4c64224ddeb1289e9", "filename": "src/test/ui/error-codes/E0063.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8a9f7862bcfa5870a34bb54f77a03c73d1db5c37/src%2Ftest%2Fui%2Ferror-codes%2FE0063.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8a9f7862bcfa5870a34bb54f77a03c73d1db5c37/src%2Ftest%2Fui%2Ferror-codes%2FE0063.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0063.stderr?ref=8a9f7862bcfa5870a34bb54f77a03c73d1db5c37", "patch": "@@ -4,11 +4,11 @@ error[E0063]: missing field `x` in initializer of `SingleFoo`\n LL |     let w = SingleFoo { };\n    |             ^^^^^^^^^ missing `x`\n \n-error[E0063]: missing fields `y`, `z` in initializer of `PluralFoo`\n+error[E0063]: missing fields `y` and `z` in initializer of `PluralFoo`\n   --> $DIR/E0063.rs:34:13\n    |\n LL |     let x = PluralFoo {x: 1};\n-   |             ^^^^^^^^^ missing `y`, `z`\n+   |             ^^^^^^^^^ missing `y` and `z`\n \n error[E0063]: missing fields `a`, `b`, `y` and 1 other field in initializer of `TruncatedFoo`\n   --> $DIR/E0063.rs:36:13"}, {"sha": "b94278bfdd2216b8bf5e3575d3fc44a868b60950", "filename": "src/test/ui/issues/issue-79593.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8a9f7862bcfa5870a34bb54f77a03c73d1db5c37/src%2Ftest%2Fui%2Fissues%2Fissue-79593.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a9f7862bcfa5870a34bb54f77a03c73d1db5c37/src%2Ftest%2Fui%2Fissues%2Fissue-79593.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-79593.rs?ref=8a9f7862bcfa5870a34bb54f77a03c73d1db5c37", "patch": "@@ -23,7 +23,7 @@ fn wrong() {\n     foo::Enum::Variant { x: () };\n     //~^ ERROR missing field `y` in initializer of `Enum`\n     foo::Enum::Variant { };\n-    //~^ ERROR missing fields `x`, `y` in initializer of `Enum`\n+    //~^ ERROR missing fields `x` and `y` in initializer of `Enum`\n }\n \n fn main() {}"}, {"sha": "b8c7d4f23a28f4b6c2f01c660f943b6b9fe78c8e", "filename": "src/test/ui/issues/issue-79593.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8a9f7862bcfa5870a34bb54f77a03c73d1db5c37/src%2Ftest%2Fui%2Fissues%2Fissue-79593.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8a9f7862bcfa5870a34bb54f77a03c73d1db5c37/src%2Ftest%2Fui%2Fissues%2Fissue-79593.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-79593.stderr?ref=8a9f7862bcfa5870a34bb54f77a03c73d1db5c37", "patch": "@@ -22,11 +22,11 @@ error[E0063]: missing field `y` in initializer of `Enum`\n LL |     foo::Enum::Variant { x: () };\n    |     ^^^^^^^^^^^^^^^^^^ missing `y`\n \n-error[E0063]: missing fields `x`, `y` in initializer of `Enum`\n+error[E0063]: missing fields `x` and `y` in initializer of `Enum`\n   --> $DIR/issue-79593.rs:25:5\n    |\n LL |     foo::Enum::Variant { };\n-   |     ^^^^^^^^^^^^^^^^^^ missing `x`, `y`\n+   |     ^^^^^^^^^^^^^^^^^^ missing `x` and `y`\n \n error: aborting due to 5 previous errors\n "}, {"sha": "4bcfa58f7cf1595036815140fc862d56edf54c1e", "filename": "src/test/ui/layout/hexagon-enum.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/8a9f7862bcfa5870a34bb54f77a03c73d1db5c37/src%2Ftest%2Fui%2Flayout%2Fhexagon-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a9f7862bcfa5870a34bb54f77a03c73d1db5c37/src%2Ftest%2Fui%2Flayout%2Fhexagon-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flayout%2Fhexagon-enum.rs?ref=8a9f7862bcfa5870a34bb54f77a03c73d1db5c37", "patch": "@@ -0,0 +1,33 @@\n+// compile-flags: --target hexagon-unknown-linux-musl\n+//\n+// Verify that the hexagon targets implement the repr(C) for enums correctly.\n+//\n+// See #82100\n+#![feature(never_type, rustc_attrs, type_alias_impl_trait, no_core, lang_items)]\n+#![crate_type = \"lib\"]\n+#![no_core]\n+\n+#[lang=\"sized\"]\n+trait Sized {}\n+\n+#[rustc_layout(debug)]\n+#[repr(C)]\n+enum A { Apple } //~ ERROR: layout_of\n+\n+#[rustc_layout(debug)]\n+#[repr(C)]\n+enum B { Banana = 255, } //~ ERROR: layout_of\n+\n+#[rustc_layout(debug)]\n+#[repr(C)]\n+enum C { Chaenomeles = 256, } //~ ERROR: layout_of\n+\n+#[rustc_layout(debug)]\n+#[repr(C)]\n+enum P { Peach = 0x1000_0000isize, } //~ ERROR: layout_of\n+\n+const TANGERINE: usize = 0x8100_0000; // hack to get negative numbers without negation operator!\n+\n+#[rustc_layout(debug)]\n+#[repr(C)]\n+enum T { Tangerine = TANGERINE as isize } //~ ERROR: layout_of"}, {"sha": "390eff6e5b957b96e11e3c43c400a8d329026029", "filename": "src/test/ui/layout/hexagon-enum.stderr", "status": "added", "additions": 442, "deletions": 0, "changes": 442, "blob_url": "https://github.com/rust-lang/rust/blob/8a9f7862bcfa5870a34bb54f77a03c73d1db5c37/src%2Ftest%2Fui%2Flayout%2Fhexagon-enum.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8a9f7862bcfa5870a34bb54f77a03c73d1db5c37/src%2Ftest%2Fui%2Flayout%2Fhexagon-enum.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flayout%2Fhexagon-enum.stderr?ref=8a9f7862bcfa5870a34bb54f77a03c73d1db5c37", "patch": "@@ -0,0 +1,442 @@\n+error: layout_of(A) = Layout {\n+    fields: Arbitrary {\n+        offsets: [\n+            Size {\n+                raw: 0,\n+            },\n+        ],\n+        memory_index: [\n+            0,\n+        ],\n+    },\n+    variants: Multiple {\n+        tag: Scalar {\n+            value: Int(\n+                I8,\n+                false,\n+            ),\n+            valid_range: 0..=0,\n+        },\n+        tag_encoding: Direct,\n+        tag_field: 0,\n+        variants: [\n+            Layout {\n+                fields: Arbitrary {\n+                    offsets: [],\n+                    memory_index: [],\n+                },\n+                variants: Single {\n+                    index: 0,\n+                },\n+                abi: Aggregate {\n+                    sized: true,\n+                },\n+                largest_niche: None,\n+                align: AbiAndPrefAlign {\n+                    abi: Align {\n+                        pow2: 0,\n+                    },\n+                    pref: Align {\n+                        pow2: 0,\n+                    },\n+                },\n+                size: Size {\n+                    raw: 1,\n+                },\n+            },\n+        ],\n+    },\n+    abi: Scalar(\n+        Scalar {\n+            value: Int(\n+                I8,\n+                false,\n+            ),\n+            valid_range: 0..=0,\n+        },\n+    ),\n+    largest_niche: Some(\n+        Niche {\n+            offset: Size {\n+                raw: 0,\n+            },\n+            scalar: Scalar {\n+                value: Int(\n+                    I8,\n+                    false,\n+                ),\n+                valid_range: 0..=0,\n+            },\n+        },\n+    ),\n+    align: AbiAndPrefAlign {\n+        abi: Align {\n+            pow2: 0,\n+        },\n+        pref: Align {\n+            pow2: 0,\n+        },\n+    },\n+    size: Size {\n+        raw: 1,\n+    },\n+}\n+  --> $DIR/hexagon-enum.rs:15:1\n+   |\n+LL | enum A { Apple }\n+   | ^^^^^^^^^^^^^^^^\n+\n+error: layout_of(B) = Layout {\n+    fields: Arbitrary {\n+        offsets: [\n+            Size {\n+                raw: 0,\n+            },\n+        ],\n+        memory_index: [\n+            0,\n+        ],\n+    },\n+    variants: Multiple {\n+        tag: Scalar {\n+            value: Int(\n+                I8,\n+                false,\n+            ),\n+            valid_range: 255..=255,\n+        },\n+        tag_encoding: Direct,\n+        tag_field: 0,\n+        variants: [\n+            Layout {\n+                fields: Arbitrary {\n+                    offsets: [],\n+                    memory_index: [],\n+                },\n+                variants: Single {\n+                    index: 0,\n+                },\n+                abi: Aggregate {\n+                    sized: true,\n+                },\n+                largest_niche: None,\n+                align: AbiAndPrefAlign {\n+                    abi: Align {\n+                        pow2: 0,\n+                    },\n+                    pref: Align {\n+                        pow2: 0,\n+                    },\n+                },\n+                size: Size {\n+                    raw: 1,\n+                },\n+            },\n+        ],\n+    },\n+    abi: Scalar(\n+        Scalar {\n+            value: Int(\n+                I8,\n+                false,\n+            ),\n+            valid_range: 255..=255,\n+        },\n+    ),\n+    largest_niche: Some(\n+        Niche {\n+            offset: Size {\n+                raw: 0,\n+            },\n+            scalar: Scalar {\n+                value: Int(\n+                    I8,\n+                    false,\n+                ),\n+                valid_range: 255..=255,\n+            },\n+        },\n+    ),\n+    align: AbiAndPrefAlign {\n+        abi: Align {\n+            pow2: 0,\n+        },\n+        pref: Align {\n+            pow2: 0,\n+        },\n+    },\n+    size: Size {\n+        raw: 1,\n+    },\n+}\n+  --> $DIR/hexagon-enum.rs:19:1\n+   |\n+LL | enum B { Banana = 255, }\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: layout_of(C) = Layout {\n+    fields: Arbitrary {\n+        offsets: [\n+            Size {\n+                raw: 0,\n+            },\n+        ],\n+        memory_index: [\n+            0,\n+        ],\n+    },\n+    variants: Multiple {\n+        tag: Scalar {\n+            value: Int(\n+                I16,\n+                false,\n+            ),\n+            valid_range: 256..=256,\n+        },\n+        tag_encoding: Direct,\n+        tag_field: 0,\n+        variants: [\n+            Layout {\n+                fields: Arbitrary {\n+                    offsets: [],\n+                    memory_index: [],\n+                },\n+                variants: Single {\n+                    index: 0,\n+                },\n+                abi: Aggregate {\n+                    sized: true,\n+                },\n+                largest_niche: None,\n+                align: AbiAndPrefAlign {\n+                    abi: Align {\n+                        pow2: 1,\n+                    },\n+                    pref: Align {\n+                        pow2: 1,\n+                    },\n+                },\n+                size: Size {\n+                    raw: 2,\n+                },\n+            },\n+        ],\n+    },\n+    abi: Scalar(\n+        Scalar {\n+            value: Int(\n+                I16,\n+                false,\n+            ),\n+            valid_range: 256..=256,\n+        },\n+    ),\n+    largest_niche: Some(\n+        Niche {\n+            offset: Size {\n+                raw: 0,\n+            },\n+            scalar: Scalar {\n+                value: Int(\n+                    I16,\n+                    false,\n+                ),\n+                valid_range: 256..=256,\n+            },\n+        },\n+    ),\n+    align: AbiAndPrefAlign {\n+        abi: Align {\n+            pow2: 1,\n+        },\n+        pref: Align {\n+            pow2: 1,\n+        },\n+    },\n+    size: Size {\n+        raw: 2,\n+    },\n+}\n+  --> $DIR/hexagon-enum.rs:23:1\n+   |\n+LL | enum C { Chaenomeles = 256, }\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: layout_of(P) = Layout {\n+    fields: Arbitrary {\n+        offsets: [\n+            Size {\n+                raw: 0,\n+            },\n+        ],\n+        memory_index: [\n+            0,\n+        ],\n+    },\n+    variants: Multiple {\n+        tag: Scalar {\n+            value: Int(\n+                I32,\n+                false,\n+            ),\n+            valid_range: 268435456..=268435456,\n+        },\n+        tag_encoding: Direct,\n+        tag_field: 0,\n+        variants: [\n+            Layout {\n+                fields: Arbitrary {\n+                    offsets: [],\n+                    memory_index: [],\n+                },\n+                variants: Single {\n+                    index: 0,\n+                },\n+                abi: Aggregate {\n+                    sized: true,\n+                },\n+                largest_niche: None,\n+                align: AbiAndPrefAlign {\n+                    abi: Align {\n+                        pow2: 2,\n+                    },\n+                    pref: Align {\n+                        pow2: 2,\n+                    },\n+                },\n+                size: Size {\n+                    raw: 4,\n+                },\n+            },\n+        ],\n+    },\n+    abi: Scalar(\n+        Scalar {\n+            value: Int(\n+                I32,\n+                false,\n+            ),\n+            valid_range: 268435456..=268435456,\n+        },\n+    ),\n+    largest_niche: Some(\n+        Niche {\n+            offset: Size {\n+                raw: 0,\n+            },\n+            scalar: Scalar {\n+                value: Int(\n+                    I32,\n+                    false,\n+                ),\n+                valid_range: 268435456..=268435456,\n+            },\n+        },\n+    ),\n+    align: AbiAndPrefAlign {\n+        abi: Align {\n+            pow2: 2,\n+        },\n+        pref: Align {\n+            pow2: 2,\n+        },\n+    },\n+    size: Size {\n+        raw: 4,\n+    },\n+}\n+  --> $DIR/hexagon-enum.rs:27:1\n+   |\n+LL | enum P { Peach = 0x1000_0000isize, }\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: layout_of(T) = Layout {\n+    fields: Arbitrary {\n+        offsets: [\n+            Size {\n+                raw: 0,\n+            },\n+        ],\n+        memory_index: [\n+            0,\n+        ],\n+    },\n+    variants: Multiple {\n+        tag: Scalar {\n+            value: Int(\n+                I32,\n+                true,\n+            ),\n+            valid_range: 2164260864..=2164260864,\n+        },\n+        tag_encoding: Direct,\n+        tag_field: 0,\n+        variants: [\n+            Layout {\n+                fields: Arbitrary {\n+                    offsets: [],\n+                    memory_index: [],\n+                },\n+                variants: Single {\n+                    index: 0,\n+                },\n+                abi: Aggregate {\n+                    sized: true,\n+                },\n+                largest_niche: None,\n+                align: AbiAndPrefAlign {\n+                    abi: Align {\n+                        pow2: 2,\n+                    },\n+                    pref: Align {\n+                        pow2: 2,\n+                    },\n+                },\n+                size: Size {\n+                    raw: 4,\n+                },\n+            },\n+        ],\n+    },\n+    abi: Scalar(\n+        Scalar {\n+            value: Int(\n+                I32,\n+                true,\n+            ),\n+            valid_range: 2164260864..=2164260864,\n+        },\n+    ),\n+    largest_niche: Some(\n+        Niche {\n+            offset: Size {\n+                raw: 0,\n+            },\n+            scalar: Scalar {\n+                value: Int(\n+                    I32,\n+                    true,\n+                ),\n+                valid_range: 2164260864..=2164260864,\n+            },\n+        },\n+    ),\n+    align: AbiAndPrefAlign {\n+        abi: Align {\n+            pow2: 2,\n+        },\n+        pref: Align {\n+            pow2: 2,\n+        },\n+    },\n+    size: Size {\n+        raw: 4,\n+    },\n+}\n+  --> $DIR/hexagon-enum.rs:33:1\n+   |\n+LL | enum T { Tangerine = TANGERINE as isize }\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 5 previous errors\n+"}, {"sha": "05461f8b8c41307046171cd31dfcb13dd9b3f344", "filename": "src/test/ui/parser/issue-52496.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8a9f7862bcfa5870a34bb54f77a03c73d1db5c37/src%2Ftest%2Fui%2Fparser%2Fissue-52496.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a9f7862bcfa5870a34bb54f77a03c73d1db5c37/src%2Ftest%2Fui%2Fparser%2Fissue-52496.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-52496.rs?ref=8a9f7862bcfa5870a34bb54f77a03c73d1db5c37", "patch": "@@ -7,6 +7,6 @@ fn main() {\n     let bar = 1.5f32;\n     let _ = Foo { bar.into(), bat: -1, . };\n     //~^ ERROR expected one of\n-    //~| ERROR missing fields `bar`, `baz` in initializer of `Foo`\n+    //~| ERROR missing fields `bar` and `baz` in initializer of `Foo`\n     //~| ERROR expected identifier, found `.`\n }"}, {"sha": "9dbf26ef4b68c234f8f61169144df3716ca05f7c", "filename": "src/test/ui/parser/issue-52496.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8a9f7862bcfa5870a34bb54f77a03c73d1db5c37/src%2Ftest%2Fui%2Fparser%2Fissue-52496.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8a9f7862bcfa5870a34bb54f77a03c73d1db5c37/src%2Ftest%2Fui%2Fparser%2Fissue-52496.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-52496.stderr?ref=8a9f7862bcfa5870a34bb54f77a03c73d1db5c37", "patch": "@@ -26,11 +26,11 @@ error[E0063]: missing field `bat` in initializer of `Foo`\n LL |     let _ = Foo { bar: .5, baz: 42 };\n    |             ^^^ missing `bat`\n \n-error[E0063]: missing fields `bar`, `baz` in initializer of `Foo`\n+error[E0063]: missing fields `bar` and `baz` in initializer of `Foo`\n   --> $DIR/issue-52496.rs:8:13\n    |\n LL |     let _ = Foo { bar.into(), bat: -1, . };\n-   |             ^^^ missing `bar`, `baz`\n+   |             ^^^ missing `bar` and `baz`\n \n error: aborting due to 5 previous errors\n "}, {"sha": "645abd9c7192dc740f3ffd8a6eebf72a8bf7e347", "filename": "src/test/ui/parser/struct-field-numeric-shorthand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8a9f7862bcfa5870a34bb54f77a03c73d1db5c37/src%2Ftest%2Fui%2Fparser%2Fstruct-field-numeric-shorthand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a9f7862bcfa5870a34bb54f77a03c73d1db5c37/src%2Ftest%2Fui%2Fparser%2Fstruct-field-numeric-shorthand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fstruct-field-numeric-shorthand.rs?ref=8a9f7862bcfa5870a34bb54f77a03c73d1db5c37", "patch": "@@ -5,5 +5,5 @@ fn main() {\n     //~^ ERROR expected identifier, found `0`\n     //~| ERROR expected identifier, found `1`\n     //~| ERROR expected identifier, found `2`\n-    //~| ERROR missing fields `0`, `1`, `2` in initializer of `Rgb`\n+    //~| ERROR missing fields `0`, `1` and `2` in initializer of `Rgb`\n }"}, {"sha": "bfb8a931b6406e3a7b3b9e3d23f77cef52367eb8", "filename": "src/test/ui/parser/struct-field-numeric-shorthand.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8a9f7862bcfa5870a34bb54f77a03c73d1db5c37/src%2Ftest%2Fui%2Fparser%2Fstruct-field-numeric-shorthand.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8a9f7862bcfa5870a34bb54f77a03c73d1db5c37/src%2Ftest%2Fui%2Fparser%2Fstruct-field-numeric-shorthand.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fstruct-field-numeric-shorthand.stderr?ref=8a9f7862bcfa5870a34bb54f77a03c73d1db5c37", "patch": "@@ -22,11 +22,11 @@ LL |     let _ = Rgb { 0, 1, 2 };\n    |             |\n    |             while parsing this struct\n \n-error[E0063]: missing fields `0`, `1`, `2` in initializer of `Rgb`\n+error[E0063]: missing fields `0`, `1` and `2` in initializer of `Rgb`\n   --> $DIR/struct-field-numeric-shorthand.rs:4:13\n    |\n LL |     let _ = Rgb { 0, 1, 2 };\n-   |             ^^^ missing `0`, `1`, `2`\n+   |             ^^^ missing `0`, `1` and `2`\n \n error: aborting due to 4 previous errors\n "}]}