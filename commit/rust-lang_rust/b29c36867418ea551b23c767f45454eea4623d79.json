{"sha": "b29c36867418ea551b23c767f45454eea4623d79", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIyOWMzNjg2NzQxOGVhNTUxYjIzYzc2N2Y0NTQ1NGVlYTQ2MjNkNzk=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-06-24T03:44:11Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-06-29T15:35:48Z"}, "message": "Removing a lot of usage of '&const'", "tree": {"sha": "f2b8a856324998d703e256580d25d83c370c12d9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f2b8a856324998d703e256580d25d83c370c12d9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b29c36867418ea551b23c767f45454eea4623d79", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b29c36867418ea551b23c767f45454eea4623d79", "html_url": "https://github.com/rust-lang/rust/commit/b29c36867418ea551b23c767f45454eea4623d79", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b29c36867418ea551b23c767f45454eea4623d79/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0326b0abed3fe9045bfc8e84d060115aecdcee37", "url": "https://api.github.com/repos/rust-lang/rust/commits/0326b0abed3fe9045bfc8e84d060115aecdcee37", "html_url": "https://github.com/rust-lang/rust/commit/0326b0abed3fe9045bfc8e84d060115aecdcee37"}], "stats": {"total": 242, "additions": 105, "deletions": 137}, "files": [{"sha": "13d159d8fed33ddc7511b9fff7f5034b9f5ed2aa", "filename": "src/libextra/arc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b29c36867418ea551b23c767f45454eea4623d79/src%2Flibextra%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b29c36867418ea551b23c767f45454eea4623d79/src%2Flibextra%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Farc.rs?ref=b29c36867418ea551b23c767f45454eea4623d79", "patch": "@@ -436,8 +436,8 @@ impl<T:Freeze + Send> RWARC<T> {\n // lock it. This wraps the unsafety, with the justification that the 'lock'\n // field is never overwritten; only 'failed' and 'data'.\n #[doc(hidden)]\n-fn borrow_rwlock<T:Freeze + Send>(state: *const RWARCInner<T>) -> *RWlock {\n-    unsafe { cast::transmute(&const (*state).lock) }\n+fn borrow_rwlock<T:Freeze + Send>(state: *mut RWARCInner<T>) -> *RWlock {\n+    unsafe { cast::transmute(&(*state).lock) }\n }\n \n /// The \"write permission\" token used for RWARC.write_downgrade()."}, {"sha": "92ee3fb43c688ba585ca3626f3388a9bba8225dd", "filename": "src/libextra/bitv.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b29c36867418ea551b23c767f45454eea4623d79/src%2Flibextra%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b29c36867418ea551b23c767f45454eea4623d79/src%2Flibextra%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fbitv.rs?ref=b29c36867418ea551b23c767f45454eea4623d79", "patch": "@@ -705,8 +705,8 @@ impl cmp::Eq for BitvSet {\n }\n \n impl Container for BitvSet {\n-    fn len(&const self) -> uint { self.size }\n-    fn is_empty(&const self) -> bool { self.size == 0 }\n+    fn len(&self) -> uint { self.size }\n+    fn is_empty(&self) -> bool { self.size == 0 }\n }\n \n impl Mutable for BitvSet {"}, {"sha": "cf7b188cb1d9291961c894539c6b52a0c422bf67", "filename": "src/libextra/deque.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b29c36867418ea551b23c767f45454eea4623d79/src%2Flibextra%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b29c36867418ea551b23c767f45454eea4623d79/src%2Flibextra%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fdeque.rs?ref=b29c36867418ea551b23c767f45454eea4623d79", "patch": "@@ -28,10 +28,10 @@ pub struct Deque<T> {\n \n impl<T> Container for Deque<T> {\n     /// Return the number of elements in the deque\n-    fn len(&const self) -> uint { self.nelts }\n+    fn len(&self) -> uint { self.nelts }\n \n     /// Return true if the deque contains no elements\n-    fn is_empty(&const self) -> bool { self.len() == 0 }\n+    fn is_empty(&self) -> bool { self.len() == 0 }\n }\n \n impl<T> Mutable for Deque<T> {"}, {"sha": "fe8f4bee75e762941264f5f609a1f7237bfb45f4", "filename": "src/libextra/flate.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b29c36867418ea551b23c767f45454eea4623d79/src%2Flibextra%2Fflate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b29c36867418ea551b23c767f45454eea4623d79/src%2Flibextra%2Fflate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fflate.rs?ref=b29c36867418ea551b23c767f45454eea4623d79", "patch": "@@ -44,8 +44,8 @@ static lz_fast : c_int = 0x1;   // LZ with only one probe\n static lz_norm : c_int = 0x80;  // LZ with 128 probes, \"normal\"\n static lz_best : c_int = 0xfff; // LZ with 4095 probes, \"best\"\n \n-pub fn deflate_bytes(bytes: &const [u8]) -> ~[u8] {\n-    do vec::as_const_buf(bytes) |b, len| {\n+pub fn deflate_bytes(bytes: &[u8]) -> ~[u8] {\n+    do vec::as_imm_buf(bytes) |b, len| {\n         unsafe {\n             let mut outsz : size_t = 0;\n             let res =\n@@ -62,8 +62,8 @@ pub fn deflate_bytes(bytes: &const [u8]) -> ~[u8] {\n     }\n }\n \n-pub fn inflate_bytes(bytes: &const [u8]) -> ~[u8] {\n-    do vec::as_const_buf(bytes) |b, len| {\n+pub fn inflate_bytes(bytes: &[u8]) -> ~[u8] {\n+    do vec::as_imm_buf(bytes) |b, len| {\n         unsafe {\n             let mut outsz : size_t = 0;\n             let res ="}, {"sha": "fcee3a2b796847cccd16bd70efd3131854c94652", "filename": "src/libextra/treemap.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b29c36867418ea551b23c767f45454eea4623d79/src%2Flibextra%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b29c36867418ea551b23c767f45454eea4623d79/src%2Flibextra%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftreemap.rs?ref=b29c36867418ea551b23c767f45454eea4623d79", "patch": "@@ -87,10 +87,10 @@ impl<K: Ord + TotalOrd, V> Ord for TreeMap<K, V> {\n \n impl<K: TotalOrd, V> Container for TreeMap<K, V> {\n     /// Return the number of elements in the map\n-    fn len(&const self) -> uint { self.length }\n+    fn len(&self) -> uint { self.length }\n \n     /// Return true if the map contains no elements\n-    fn is_empty(&const self) -> bool { self.root.is_none() }\n+    fn is_empty(&self) -> bool { self.root.is_none() }\n }\n \n impl<K: TotalOrd, V> Mutable for TreeMap<K, V> {\n@@ -265,11 +265,11 @@ impl<T: Ord + TotalOrd> Ord for TreeSet<T> {\n impl<T: TotalOrd> Container for TreeSet<T> {\n     /// Return the number of elements in the set\n     #[inline]\n-    fn len(&const self) -> uint { self.map.len() }\n+    fn len(&self) -> uint { self.map.len() }\n \n     /// Return true if the set contains no elements\n     #[inline]\n-    fn is_empty(&const self) -> bool { self.map.is_empty() }\n+    fn is_empty(&self) -> bool { self.map.is_empty() }\n }\n \n impl<T: TotalOrd> Mutable for TreeSet<T> {"}, {"sha": "b167a22992cf17d792a5a053ddc13ef6d9f13a09", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 38, "deletions": 38, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/b29c36867418ea551b23c767f45454eea4623d79/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b29c36867418ea551b23c767f45454eea4623d79/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=b29c36867418ea551b23c767f45454eea4623d79", "patch": "@@ -152,122 +152,122 @@ impl LanguageItems {\n \n     // FIXME #4621: Method macros sure would be nice here.\n \n-    pub fn freeze_trait(&const self) -> def_id {\n+    pub fn freeze_trait(&self) -> def_id {\n         self.items[FreezeTraitLangItem as uint].get()\n     }\n-    pub fn copy_trait(&const self) -> def_id {\n+    pub fn copy_trait(&self) -> def_id {\n         self.items[CopyTraitLangItem as uint].get()\n     }\n-    pub fn send_trait(&const self) -> def_id {\n+    pub fn send_trait(&self) -> def_id {\n         self.items[SendTraitLangItem as uint].get()\n     }\n-    pub fn sized_trait(&const self) -> def_id {\n+    pub fn sized_trait(&self) -> def_id {\n         self.items[SizedTraitLangItem as uint].get()\n     }\n \n-    pub fn drop_trait(&const self) -> def_id {\n+    pub fn drop_trait(&self) -> def_id {\n         self.items[DropTraitLangItem as uint].get()\n     }\n \n-    pub fn add_trait(&const self) -> def_id {\n+    pub fn add_trait(&self) -> def_id {\n         self.items[AddTraitLangItem as uint].get()\n     }\n-    pub fn sub_trait(&const self) -> def_id {\n+    pub fn sub_trait(&self) -> def_id {\n         self.items[SubTraitLangItem as uint].get()\n     }\n-    pub fn mul_trait(&const self) -> def_id {\n+    pub fn mul_trait(&self) -> def_id {\n         self.items[MulTraitLangItem as uint].get()\n     }\n-    pub fn div_trait(&const self) -> def_id {\n+    pub fn div_trait(&self) -> def_id {\n         self.items[DivTraitLangItem as uint].get()\n     }\n-    pub fn rem_trait(&const self) -> def_id {\n+    pub fn rem_trait(&self) -> def_id {\n         self.items[RemTraitLangItem as uint].get()\n     }\n-    pub fn neg_trait(&const self) -> def_id {\n+    pub fn neg_trait(&self) -> def_id {\n         self.items[NegTraitLangItem as uint].get()\n     }\n-    pub fn not_trait(&const self) -> def_id {\n+    pub fn not_trait(&self) -> def_id {\n         self.items[NotTraitLangItem as uint].get()\n     }\n-    pub fn bitxor_trait(&const self) -> def_id {\n+    pub fn bitxor_trait(&self) -> def_id {\n         self.items[BitXorTraitLangItem as uint].get()\n     }\n-    pub fn bitand_trait(&const self) -> def_id {\n+    pub fn bitand_trait(&self) -> def_id {\n         self.items[BitAndTraitLangItem as uint].get()\n     }\n-    pub fn bitor_trait(&const self) -> def_id {\n+    pub fn bitor_trait(&self) -> def_id {\n         self.items[BitOrTraitLangItem as uint].get()\n     }\n-    pub fn shl_trait(&const self) -> def_id {\n+    pub fn shl_trait(&self) -> def_id {\n         self.items[ShlTraitLangItem as uint].get()\n     }\n-    pub fn shr_trait(&const self) -> def_id {\n+    pub fn shr_trait(&self) -> def_id {\n         self.items[ShrTraitLangItem as uint].get()\n     }\n-    pub fn index_trait(&const self) -> def_id {\n+    pub fn index_trait(&self) -> def_id {\n         self.items[IndexTraitLangItem as uint].get()\n     }\n \n-    pub fn eq_trait(&const self) -> def_id {\n+    pub fn eq_trait(&self) -> def_id {\n         self.items[EqTraitLangItem as uint].get()\n     }\n-    pub fn ord_trait(&const self) -> def_id {\n+    pub fn ord_trait(&self) -> def_id {\n         self.items[OrdTraitLangItem as uint].get()\n     }\n \n-    pub fn str_eq_fn(&const self) -> def_id {\n+    pub fn str_eq_fn(&self) -> def_id {\n         self.items[StrEqFnLangItem as uint].get()\n     }\n-    pub fn uniq_str_eq_fn(&const self) -> def_id {\n+    pub fn uniq_str_eq_fn(&self) -> def_id {\n         self.items[UniqStrEqFnLangItem as uint].get()\n     }\n-    pub fn annihilate_fn(&const self) -> def_id {\n+    pub fn annihilate_fn(&self) -> def_id {\n         self.items[AnnihilateFnLangItem as uint].get()\n     }\n-    pub fn log_type_fn(&const self) -> def_id {\n+    pub fn log_type_fn(&self) -> def_id {\n         self.items[LogTypeFnLangItem as uint].get()\n     }\n-    pub fn fail_fn(&const self) -> def_id {\n+    pub fn fail_fn(&self) -> def_id {\n         self.items[FailFnLangItem as uint].get()\n     }\n-    pub fn fail_bounds_check_fn(&const self) -> def_id {\n+    pub fn fail_bounds_check_fn(&self) -> def_id {\n         self.items[FailBoundsCheckFnLangItem as uint].get()\n     }\n-    pub fn exchange_malloc_fn(&const self) -> def_id {\n+    pub fn exchange_malloc_fn(&self) -> def_id {\n         self.items[ExchangeMallocFnLangItem as uint].get()\n     }\n-    pub fn exchange_free_fn(&const self) -> def_id {\n+    pub fn exchange_free_fn(&self) -> def_id {\n         self.items[ExchangeFreeFnLangItem as uint].get()\n     }\n-    pub fn malloc_fn(&const self) -> def_id {\n+    pub fn malloc_fn(&self) -> def_id {\n         self.items[MallocFnLangItem as uint].get()\n     }\n-    pub fn free_fn(&const self) -> def_id {\n+    pub fn free_fn(&self) -> def_id {\n         self.items[FreeFnLangItem as uint].get()\n     }\n-    pub fn borrow_as_imm_fn(&const self) -> def_id {\n+    pub fn borrow_as_imm_fn(&self) -> def_id {\n         self.items[BorrowAsImmFnLangItem as uint].get()\n     }\n-    pub fn borrow_as_mut_fn(&const self) -> def_id {\n+    pub fn borrow_as_mut_fn(&self) -> def_id {\n         self.items[BorrowAsMutFnLangItem as uint].get()\n     }\n-    pub fn return_to_mut_fn(&const self) -> def_id {\n+    pub fn return_to_mut_fn(&self) -> def_id {\n         self.items[ReturnToMutFnLangItem as uint].get()\n     }\n-    pub fn check_not_borrowed_fn(&const self) -> def_id {\n+    pub fn check_not_borrowed_fn(&self) -> def_id {\n         self.items[CheckNotBorrowedFnLangItem as uint].get()\n     }\n-    pub fn strdup_uniq_fn(&const self) -> def_id {\n+    pub fn strdup_uniq_fn(&self) -> def_id {\n         self.items[StrDupUniqFnLangItem as uint].get()\n     }\n-    pub fn record_borrow_fn(&const self) -> def_id {\n+    pub fn record_borrow_fn(&self) -> def_id {\n         self.items[RecordBorrowFnLangItem as uint].get()\n     }\n-    pub fn unrecord_borrow_fn(&const self) -> def_id {\n+    pub fn unrecord_borrow_fn(&self) -> def_id {\n         self.items[UnrecordBorrowFnLangItem as uint].get()\n     }\n-    pub fn start_fn(&const self) -> def_id {\n+    pub fn start_fn(&self) -> def_id {\n         self.items[StartFnLangItem as uint].get()\n     }\n     pub fn ty_desc(&const self) -> def_id {"}, {"sha": "48e841353c084faae2417fb652318427c896a137", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b29c36867418ea551b23c767f45454eea4623d79/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b29c36867418ea551b23c767f45454eea4623d79/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=b29c36867418ea551b23c767f45454eea4623d79", "patch": "@@ -3696,14 +3696,14 @@ pub enum DtorKind {\n }\n \n impl DtorKind {\n-    pub fn is_not_present(&const self) -> bool {\n+    pub fn is_not_present(&self) -> bool {\n         match *self {\n             NoDtor => true,\n             _ => false\n         }\n     }\n \n-    pub fn is_present(&const self) -> bool {\n+    pub fn is_present(&self) -> bool {\n         !self.is_not_present()\n     }\n "}, {"sha": "a46d2f28b1390f93593a375561e71c1700297d91", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b29c36867418ea551b23c767f45454eea4623d79/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b29c36867418ea551b23c767f45454eea4623d79/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=b29c36867418ea551b23c767f45454eea4623d79", "patch": "@@ -64,7 +64,7 @@ pub struct VtableContext {\n }\n \n impl VtableContext {\n-    pub fn tcx(&const self) -> ty::ctxt { self.ccx.tcx }\n+    pub fn tcx(&self) -> ty::ctxt { self.ccx.tcx }\n }\n \n fn has_trait_bounds(type_param_defs: &[ty::TypeParameterDef]) -> bool {"}, {"sha": "325ce097cd5a0f0407680699ba1860efd2d4e51c", "filename": "src/libstd/at_vec.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b29c36867418ea551b23c767f45454eea4623d79/src%2Flibstd%2Fat_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b29c36867418ea551b23c767f45454eea4623d79/src%2Flibstd%2Fat_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fat_vec.rs?ref=b29c36867418ea551b23c767f45454eea4623d79", "patch": "@@ -108,7 +108,7 @@ pub fn build_sized_opt<A>(size: Option<uint>,\n /// Iterates over the `rhs` vector, copying each element and appending it to the\n /// `lhs`. Afterwards, the `lhs` is then returned for use again.\n #[inline]\n-pub fn append<T:Copy>(lhs: @[T], rhs: &const [T]) -> @[T] {\n+pub fn append<T:Copy>(lhs: @[T], rhs: &[T]) -> @[T] {\n     do build_sized(lhs.len() + rhs.len()) |push| {\n         for lhs.iter().advance |x| { push(copy *x); }\n         for uint::range(0, rhs.len()) |i| { push(copy rhs[i]); }\n@@ -180,9 +180,9 @@ pub mod traits {\n     use kinds::Copy;\n     use ops::Add;\n \n-    impl<'self,T:Copy> Add<&'self const [T],@[T]> for @[T] {\n+    impl<'self,T:Copy> Add<&'self [T],@[T]> for @[T] {\n         #[inline]\n-        fn add(&self, rhs: & &'self const [T]) -> @[T] {\n+        fn add(&self, rhs: & &'self [T]) -> @[T] {\n             append(*self, (*rhs))\n         }\n     }"}, {"sha": "35db229b65d304bf5d04cf14a37e35d3a6b7d4ac", "filename": "src/libstd/hashmap.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b29c36867418ea551b23c767f45454eea4623d79/src%2Flibstd%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b29c36867418ea551b23c767f45454eea4623d79/src%2Flibstd%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhashmap.rs?ref=b29c36867418ea551b23c767f45454eea4623d79", "patch": "@@ -282,10 +282,10 @@ impl<K:Hash + Eq,V> HashMap<K, V> {\n \n impl<K:Hash + Eq,V> Container for HashMap<K, V> {\n     /// Return the number of elements in the map\n-    fn len(&const self) -> uint { self.size }\n+    fn len(&self) -> uint { self.size }\n \n     /// Return true if the map contains no elements\n-    fn is_empty(&const self) -> bool { self.len() == 0 }\n+    fn is_empty(&self) -> bool { self.len() == 0 }\n }\n \n impl<K:Hash + Eq,V> Mutable for HashMap<K, V> {\n@@ -623,10 +623,10 @@ impl<T:Hash + Eq> Eq for HashSet<T> {\n \n impl<T:Hash + Eq> Container for HashSet<T> {\n     /// Return the number of elements in the set\n-    fn len(&const self) -> uint { self.map.len() }\n+    fn len(&self) -> uint { self.map.len() }\n \n     /// Return true if the set contains no elements\n-    fn is_empty(&const self) -> bool { self.map.is_empty() }\n+    fn is_empty(&self) -> bool { self.map.is_empty() }\n }\n \n impl<T:Hash + Eq> Mutable for HashSet<T> {"}, {"sha": "40793ff1af7b16e4f1e8fbe962df8f7429338528", "filename": "src/libstd/io.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b29c36867418ea551b23c767f45454eea4623d79/src%2Flibstd%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b29c36867418ea551b23c767f45454eea4623d79/src%2Flibstd%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio.rs?ref=b29c36867418ea551b23c767f45454eea4623d79", "patch": "@@ -1152,7 +1152,7 @@ impl<W:Writer,C> Writer for Wrapper<W, C> {\n impl Writer for *libc::FILE {\n     fn write(&self, v: &[u8]) {\n         unsafe {\n-            do vec::as_const_buf(v) |vbuf, len| {\n+            do vec::as_imm_buf(v) |vbuf, len| {\n                 let nout = libc::fwrite(vbuf as *c_void,\n                                         1,\n                                         len as size_t,\n@@ -1203,9 +1203,9 @@ impl Writer for fd_t {\n     fn write(&self, v: &[u8]) {\n         unsafe {\n             let mut count = 0u;\n-            do vec::as_const_buf(v) |vbuf, len| {\n+            do vec::as_imm_buf(v) |vbuf, len| {\n                 while count < len {\n-                    let vb = ptr::const_offset(vbuf, count) as *c_void;\n+                    let vb = ptr::offset(vbuf, count) as *c_void;\n                     let nout = libc::write(*self, vb, len as size_t);\n                     if nout < 0 as ssize_t {\n                         error!(\"error writing buffer\");"}, {"sha": "643812312582e30d33bdb66713f52ac133e329e3", "filename": "src/libstd/option.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b29c36867418ea551b23c767f45454eea4623d79/src%2Flibstd%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b29c36867418ea551b23c767f45454eea4623d79/src%2Flibstd%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Foption.rs?ref=b29c36867418ea551b23c767f45454eea4623d79", "patch": "@@ -121,13 +121,13 @@ impl<T> Option<T> {\n \n     /// Returns true if the option equals `none`\n     #[inline]\n-    pub fn is_none(&const self) -> bool {\n+    pub fn is_none(&self) -> bool {\n         match *self { None => true, Some(_) => false }\n     }\n \n     /// Returns true if the option contains some value\n     #[inline]\n-    pub fn is_some(&const self) -> bool { !self.is_none() }\n+    pub fn is_some(&self) -> bool { !self.is_none() }\n \n     /// Update an optional value by optionally running its content through a\n     /// function that returns an option."}, {"sha": "473f56ddd7984f1bfea0846210ff7a31f1aaea8e", "filename": "src/libstd/ptr.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b29c36867418ea551b23c767f45454eea4623d79/src%2Flibstd%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b29c36867418ea551b23c767f45454eea4623d79/src%2Flibstd%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fptr.rs?ref=b29c36867418ea551b23c767f45454eea4623d79", "patch": "@@ -232,21 +232,21 @@ pub unsafe fn array_each<T>(arr: **T, cb: &fn(*T)) {\n \n #[allow(missing_doc)]\n pub trait RawPtr<T> {\n-    fn is_null(&const self) -> bool;\n-    fn is_not_null(&const self) -> bool;\n-    unsafe fn to_option(&const self) -> Option<&T>;\n+    fn is_null(&self) -> bool;\n+    fn is_not_null(&self) -> bool;\n+    unsafe fn to_option(&self) -> Option<&T>;\n     fn offset(&self, count: uint) -> Self;\n }\n \n /// Extension methods for immutable pointers\n impl<T> RawPtr<T> for *T {\n     /// Returns true if the pointer is equal to the null pointer.\n     #[inline]\n-    fn is_null(&const self) -> bool { is_null(*self) }\n+    fn is_null(&self) -> bool { is_null(*self) }\n \n     /// Returns true if the pointer is not equal to the null pointer.\n     #[inline]\n-    fn is_not_null(&const self) -> bool { is_not_null(*self) }\n+    fn is_not_null(&self) -> bool { is_not_null(*self) }\n \n     ///\n     /// Returns `None` if the pointer is null, or else returns the value wrapped\n@@ -259,7 +259,7 @@ impl<T> RawPtr<T> for *T {\n     /// be pointing to invalid memory.\n     ///\n     #[inline]\n-    unsafe fn to_option(&const self) -> Option<&T> {\n+    unsafe fn to_option(&self) -> Option<&T> {\n         if self.is_null() { None } else {\n             Some(cast::transmute(*self))\n         }\n@@ -274,11 +274,11 @@ impl<T> RawPtr<T> for *T {\n impl<T> RawPtr<T> for *mut T {\n     /// Returns true if the pointer is equal to the null pointer.\n     #[inline]\n-    fn is_null(&const self) -> bool { is_null(*self) }\n+    fn is_null(&self) -> bool { is_null(*self) }\n \n     /// Returns true if the pointer is not equal to the null pointer.\n     #[inline]\n-    fn is_not_null(&const self) -> bool { is_not_null(*self) }\n+    fn is_not_null(&self) -> bool { is_not_null(*self) }\n \n     ///\n     /// Returns `None` if the pointer is null, or else returns the value wrapped\n@@ -291,7 +291,7 @@ impl<T> RawPtr<T> for *mut T {\n     /// be pointing to invalid memory.\n     ///\n     #[inline]\n-    unsafe fn to_option(&const self) -> Option<&T> {\n+    unsafe fn to_option(&self) -> Option<&T> {\n         if self.is_null() { None } else {\n             Some(cast::transmute(*self))\n         }"}, {"sha": "a06d858e4243b4985f86e9ec6fe6eb1c805be83d", "filename": "src/libstd/str.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b29c36867418ea551b23c767f45454eea4623d79/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b29c36867418ea551b23c767f45454eea4623d79/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=b29c36867418ea551b23c767f45454eea4623d79", "patch": "@@ -569,7 +569,7 @@ Section: Misc\n */\n \n /// Determines if a vector of bytes contains valid UTF-8\n-pub fn is_utf8(v: &const [u8]) -> bool {\n+pub fn is_utf8(v: &[u8]) -> bool {\n     let mut i = 0u;\n     let total = v.len();\n     while i < total {\n@@ -815,7 +815,7 @@ pub mod raw {\n     }\n \n     /// Create a Rust string from a *u8 buffer of the given length\n-    pub unsafe fn from_buf_len(buf: *const u8, len: uint) -> ~str {\n+    pub unsafe fn from_buf_len(buf: *u8, len: uint) -> ~str {\n         let mut v: ~[u8] = vec::with_capacity(len + 1);\n         vec::as_mut_buf(v, |vbuf, _len| {\n             ptr::copy_memory(vbuf, buf as *u8, len)\n@@ -838,8 +838,8 @@ pub mod raw {\n     }\n \n     /// Converts a vector of bytes to a new owned string.\n-    pub unsafe fn from_bytes(v: &const [u8]) -> ~str {\n-        do vec::as_const_buf(v) |buf, len| {\n+    pub unsafe fn from_bytes(v: &[u8]) -> ~str {\n+        do vec::as_imm_buf(v) |buf, len| {\n             from_buf_len(buf, len)\n         }\n     }"}, {"sha": "190485a720aa726e849d0ad4476656cdc19a0e9d", "filename": "src/libstd/task/spawn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b29c36867418ea551b23c767f45454eea4623d79/src%2Flibstd%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b29c36867418ea551b23c767f45454eea4623d79/src%2Flibstd%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fspawn.rs?ref=b29c36867418ea551b23c767f45454eea4623d79", "patch": "@@ -129,7 +129,7 @@ type TaskGroupInner<'self> = &'self mut Option<TaskGroupData>;\n \n // A taskgroup is 'dead' when nothing can cause it to fail; only members can.\n fn taskgroup_is_dead(tg: &TaskGroupData) -> bool {\n-    (&const tg.members).is_empty()\n+    tg.members.is_empty()\n }\n \n // A list-like structure by which taskgroups keep track of all ancestor groups"}, {"sha": "8ce02d59ab15c6fab53db596d02086147da8da9e", "filename": "src/libstd/trie.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b29c36867418ea551b23c767f45454eea4623d79/src%2Flibstd%2Ftrie.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b29c36867418ea551b23c767f45454eea4623d79/src%2Flibstd%2Ftrie.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftrie.rs?ref=b29c36867418ea551b23c767f45454eea4623d79", "patch": "@@ -35,11 +35,11 @@ pub struct TrieMap<T> {\n impl<T> Container for TrieMap<T> {\n     /// Return the number of elements in the map\n     #[inline]\n-    fn len(&const self) -> uint { self.length }\n+    fn len(&self) -> uint { self.length }\n \n     /// Return true if the map contains no elements\n     #[inline]\n-    fn is_empty(&const self) -> bool { self.len() == 0 }\n+    fn is_empty(&self) -> bool { self.len() == 0 }\n }\n \n impl<T> Mutable for TrieMap<T> {\n@@ -179,11 +179,11 @@ pub struct TrieSet {\n impl Container for TrieSet {\n     /// Return the number of elements in the set\n     #[inline]\n-    fn len(&const self) -> uint { self.map.len() }\n+    fn len(&self) -> uint { self.map.len() }\n \n     /// Return true if the set contains no elements\n     #[inline]\n-    fn is_empty(&const self) -> bool { self.map.is_empty() }\n+    fn is_empty(&self) -> bool { self.map.is_empty() }\n }\n \n impl Mutable for TrieSet {"}, {"sha": "4196fbac0beb5a7bc391784364858dc75d09f54d", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 20, "deletions": 52, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/b29c36867418ea551b23c767f45454eea4623d79/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b29c36867418ea551b23c767f45454eea4623d79/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=b29c36867418ea551b23c767f45454eea4623d79", "patch": "@@ -64,7 +64,7 @@ pub mod rustrt {\n }\n \n /// Returns true if two vectors have the same length\n-pub fn same_length<T, U>(xs: &const [T], ys: &const [U]) -> bool {\n+pub fn same_length<T, U>(xs: &[T], ys: &[U]) -> bool {\n     xs.len() == ys.len()\n }\n \n@@ -350,10 +350,7 @@ pub fn dedup<T:Eq>(v: &mut ~[T]) {\n         if v.len() < 1 { return; }\n         let mut last_written = 0;\n         let mut next_to_read = 1;\n-        do as_const_buf(*v) |p, ln| {\n-            // We have a mutable reference to v, so we can make arbitrary\n-            // changes. (cf. push and pop)\n-            let p = p as *mut T;\n+        do as_mut_buf(*v) |p, ln| {\n             // last_written < next_to_read <= ln\n             while next_to_read < ln {\n                 // last_written < next_to_read < ln\n@@ -384,7 +381,7 @@ pub fn dedup<T:Eq>(v: &mut ~[T]) {\n /// Iterates over the `rhs` vector, copying each element and appending it to the\n /// `lhs`. Afterwards, the `lhs` is then returned for use again.\n #[inline]\n-pub fn append<T:Copy>(lhs: ~[T], rhs: &const [T]) -> ~[T] {\n+pub fn append<T:Copy>(lhs: ~[T], rhs: &[T]) -> ~[T] {\n     let mut v = lhs;\n     v.push_all(rhs);\n     v\n@@ -831,7 +828,7 @@ pub fn unzip<T,U>(v: ~[(T, U)]) -> (~[T], ~[U]) {\n /**\n  * Convert two vectors to a vector of pairs, by reference. As zip().\n  */\n-pub fn zip_slice<T:Copy,U:Copy>(v: &const [T], u: &const [U])\n+pub fn zip_slice<T:Copy,U:Copy>(v: &[T], u: &[U])\n         -> ~[(T, U)] {\n     let mut zipped = ~[];\n     let sz = v.len();\n@@ -893,7 +890,7 @@ pub fn reverse<T>(v: &mut [T]) {\n }\n \n /// Returns a vector with the order of elements reversed\n-pub fn reversed<T:Copy>(v: &const [T]) -> ~[T] {\n+pub fn reversed<T:Copy>(v: &[T]) -> ~[T] {\n     let mut rs: ~[T] = ~[];\n     let mut i = v.len();\n     if i == 0 { return (rs); } else { i -= 1; }\n@@ -1003,16 +1000,6 @@ pub fn as_imm_buf<T,U>(s: &[T],\n     }\n }\n \n-/// Similar to `as_imm_buf` but passing a `*const T`\n-#[inline]\n-pub fn as_const_buf<T,U>(s: &const [T], f: &fn(*const T, uint) -> U) -> U {\n-    unsafe {\n-        let v : *(*const T,uint) = transmute(&s);\n-        let (buf,len) = *v;\n-        f(buf, len / sys::nonzero_size_of::<T>())\n-    }\n-}\n-\n /// Similar to `as_imm_buf` but passing a `*mut T`\n #[inline]\n pub fn as_mut_buf<T,U>(s: &mut [T], f: &fn(*mut T, uint) -> U) -> U {\n@@ -1198,39 +1185,39 @@ pub mod traits {\n     use ops::Add;\n     use vec::append;\n \n-    impl<'self,T:Copy> Add<&'self const [T],~[T]> for ~[T] {\n+    impl<'self,T:Copy> Add<&'self [T],~[T]> for ~[T] {\n         #[inline]\n-        fn add(&self, rhs: & &'self const [T]) -> ~[T] {\n+        fn add(&self, rhs: & &'self [T]) -> ~[T] {\n             append(copy *self, (*rhs))\n         }\n     }\n }\n \n-impl<'self, T> Container for &'self const [T] {\n+impl<'self, T> Container for &'self [T] {\n     /// Returns true if a vector contains no elements\n     #[inline]\n     fn is_empty(&self) -> bool {\n-        as_const_buf(*self, |_p, len| len == 0u)\n+        as_imm_buf(*self, |_p, len| len == 0u)\n     }\n \n     /// Returns the length of a vector\n     #[inline]\n     fn len(&self) -> uint {\n-        as_const_buf(*self, |_p, len| len)\n+        as_imm_buf(*self, |_p, len| len)\n     }\n }\n \n impl<T> Container for ~[T] {\n     /// Returns true if a vector contains no elements\n     #[inline]\n     fn is_empty(&self) -> bool {\n-        as_const_buf(*self, |_p, len| len == 0u)\n+        as_imm_buf(*self, |_p, len| len == 0u)\n     }\n \n     /// Returns the length of a vector\n     #[inline]\n     fn len(&self) -> uint {\n-        as_const_buf(*self, |_p, len| len)\n+        as_imm_buf(*self, |_p, len| len)\n     }\n }\n \n@@ -1843,7 +1830,7 @@ impl<T> Mutable for ~[T] {\n \n #[allow(missing_doc)]\n pub trait OwnedCopyableVector<T:Copy> {\n-    fn push_all(&mut self, rhs: &const [T]);\n+    fn push_all(&mut self, rhs: &[T]);\n     fn grow(&mut self, n: uint, initval: &T);\n     fn grow_set(&mut self, index: uint, initval: &T, val: T);\n }\n@@ -1860,7 +1847,7 @@ impl<T:Copy> OwnedCopyableVector<T> for ~[T] {\n     /// assert!(a == ~[1, 2, 3, 4]);\n     /// ~~~\n     #[inline]\n-    fn push_all(&mut self, rhs: &const [T]) {\n+    fn push_all(&mut self, rhs: &[T]) {\n         let new_len = self.len() + rhs.len();\n         self.reserve(new_len);\n \n@@ -2017,7 +2004,7 @@ pub mod raw {\n     use ptr;\n     use sys;\n     use unstable::intrinsics;\n-    use vec::{UnboxedVecRepr, as_const_buf, as_mut_buf, with_capacity};\n+    use vec::{UnboxedVecRepr, as_imm_buf, as_mut_buf, with_capacity};\n     use util;\n \n     /// The internal representation of a (boxed) vector\n@@ -2065,15 +2052,6 @@ pub mod raw {\n         }\n     }\n \n-    /** see `to_ptr()` */\n-    #[inline]\n-    pub fn to_const_ptr<T>(v: &const [T]) -> *const T {\n-        unsafe {\n-            let repr: **SliceRepr = transmute(&v);\n-            transmute(&((**repr).data))\n-        }\n-    }\n-\n     /** see `to_ptr()` */\n     #[inline]\n     pub fn to_mut_ptr<T>(v: &mut [T]) -> *mut T {\n@@ -2113,8 +2091,8 @@ pub mod raw {\n      * Unchecked vector indexing.\n      */\n     #[inline]\n-    pub unsafe fn get<T:Copy>(v: &const [T], i: uint) -> T {\n-        as_const_buf(v, |p, _len| copy *ptr::const_offset(p, i))\n+    pub unsafe fn get<T:Copy>(v: &[T], i: uint) -> T {\n+        as_imm_buf(v, |p, _len| copy *ptr::offset(p, i))\n     }\n \n     /**\n@@ -2156,13 +2134,13 @@ pub mod raw {\n       * may overlap.\n       */\n     #[inline]\n-    pub unsafe fn copy_memory<T>(dst: &mut [T], src: &const [T],\n+    pub unsafe fn copy_memory<T>(dst: &mut [T], src: &[T],\n                                  count: uint) {\n         assert!(dst.len() >= count);\n         assert!(src.len() >= count);\n \n         do as_mut_buf(dst) |p_dst, _len_dst| {\n-            do as_const_buf(src) |p_src, _len_src| {\n+            do as_imm_buf(src) |p_src, _len_src| {\n                 ptr::copy_memory(p_dst, p_src, count)\n             }\n         }\n@@ -2238,7 +2216,7 @@ pub mod bytes {\n       * may overlap.\n       */\n     #[inline]\n-    pub fn copy_memory(dst: &mut [u8], src: &const [u8], count: uint) {\n+    pub fn copy_memory(dst: &mut [u8], src: &[u8], count: uint) {\n         // Bound checks are done at vec::raw::copy_memory.\n         unsafe { vec::raw::copy_memory(dst, src, count) }\n     }\n@@ -3690,16 +3668,6 @@ mod tests {\n         }\n     }\n \n-    #[test]\n-    #[ignore(windows)]\n-    #[should_fail]\n-    fn test_as_const_buf_fail() {\n-        let v = [(~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n-        do as_const_buf(v) |_buf, _i| {\n-            fail!()\n-        }\n-    }\n-\n     #[test]\n     #[ignore(cfg(windows))]\n     #[should_fail]"}]}