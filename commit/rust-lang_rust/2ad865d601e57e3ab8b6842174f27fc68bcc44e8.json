{"sha": "2ad865d601e57e3ab8b6842174f27fc68bcc44e8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJhZDg2NWQ2MDFlNTdlM2FiOGI2ODQyMTc0ZjI3ZmM2OGJjYzQ0ZTg=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2018-08-11T08:13:57Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2018-08-14T04:06:50Z"}, "message": "rustc_resolve: inject ambiguity \"canaries\" when #![feature(uniform_paths)] is enabled.", "tree": {"sha": "a076efa289e0b98d50ae537b5b9902c64701a696", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a076efa289e0b98d50ae537b5b9902c64701a696"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2ad865d601e57e3ab8b6842174f27fc68bcc44e8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2ad865d601e57e3ab8b6842174f27fc68bcc44e8", "html_url": "https://github.com/rust-lang/rust/commit/2ad865d601e57e3ab8b6842174f27fc68bcc44e8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2ad865d601e57e3ab8b6842174f27fc68bcc44e8/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "39ce9ef00e6f418a7db972e07063c1445e72e0c3", "url": "https://api.github.com/repos/rust-lang/rust/commits/39ce9ef00e6f418a7db972e07063c1445e72e0c3", "html_url": "https://github.com/rust-lang/rust/commit/39ce9ef00e6f418a7db972e07063c1445e72e0c3"}], "stats": {"total": 358, "additions": 343, "deletions": 15}, "files": [{"sha": "7b42e7af2eb02d3ee950a18729d6e4f8e2578d5b", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 107, "deletions": 12, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/2ad865d601e57e3ab8b6842174f27fc68bcc44e8/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ad865d601e57e3ab8b6842174f27fc68bcc44e8/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=2ad865d601e57e3ab8b6842174f27fc68bcc44e8", "patch": "@@ -113,16 +113,24 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n         }\n     }\n \n-    fn build_reduced_graph_for_use_tree(&mut self,\n-                                        root_use_tree: &ast::UseTree,\n-                                        root_id: NodeId,\n-                                        use_tree: &ast::UseTree,\n-                                        id: NodeId,\n-                                        vis: ty::Visibility,\n-                                        prefix: &ast::Path,\n-                                        nested: bool,\n-                                        item: &Item,\n-                                        expansion: Mark) {\n+    fn build_reduced_graph_for_use_tree(\n+        &mut self,\n+        root_use_tree: &ast::UseTree,\n+        root_id: NodeId,\n+        use_tree: &ast::UseTree,\n+        id: NodeId,\n+        vis: ty::Visibility,\n+        prefix: &ast::Path,\n+        mut uniform_paths_canary_emitted: bool,\n+        nested: bool,\n+        item: &Item,\n+        expansion: Mark,\n+    ) {\n+        debug!(\"build_reduced_graph_for_use_tree(prefix={:?}, \\\n+                uniform_paths_canary_emitted={}, \\\n+                use_tree={:?}, nested={})\",\n+               prefix, uniform_paths_canary_emitted, use_tree, nested);\n+\n         let is_prelude = attr::contains_name(&item.attrs, \"prelude_import\");\n         let path = &use_tree.prefix;\n \n@@ -131,6 +139,71 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n             .map(|seg| seg.ident)\n             .collect();\n \n+        debug!(\"build_reduced_graph_for_use_tree: module_path={:?}\", module_path);\n+\n+        // `#[feature(uniform_paths)]` allows an unqualified import path,\n+        // e.g. `use x::...;` to resolve not just globally (`use ::x::...;`)\n+        // but also relatively (`use self::x::...;`). To catch ambiguities\n+        // that might arise from both of these being available and resolution\n+        // silently picking one of them, an artificial `use self::x as _;`\n+        // import is injected as a \"canary\", and an error is emitted if it\n+        // successfully resolves while an `x` external crate exists.\n+        //\n+        // Additionally, the canary might be able to catch limitations of the\n+        // current implementation, where `::x` may be chosen due to `self::x`\n+        // not existing, but `self::x` could appear later, from macro expansion.\n+        //\n+        // NB. The canary currently only errors if the `x::...` path *could*\n+        // resolve as a relative path through the extern crate, i.e. `x` is\n+        // in `extern_prelude`, *even though* `::x` might still forcefully\n+        // load a non-`extern_prelude` crate.\n+        // While always producing an ambiguity errors if `self::x` exists and\n+        // a crate *could* be loaded, would be more conservative, imports for\n+        // local modules named `test` (or less commonly, `syntax` or `log`),\n+        // would need to be qualified (e.g. `self::test`), which is considered\n+        // ergonomically unacceptable.\n+        let emit_uniform_paths_canary =\n+            !uniform_paths_canary_emitted &&\n+            module_path.get(0).map_or(false, |ident| {\n+                !ident.is_path_segment_keyword()\n+            });\n+        if emit_uniform_paths_canary {\n+            // Relative paths should only get here if the feature-gate is on.\n+            assert!(self.session.rust_2018() &&\n+                    self.session.features_untracked().uniform_paths);\n+\n+            let source = module_path[0];\n+            let subclass = SingleImport {\n+                target: Ident {\n+                    name: keywords::Underscore.name().gensymed(),\n+                    span: source.span,\n+                },\n+                source,\n+                result: PerNS {\n+                    type_ns: Cell::new(Err(Undetermined)),\n+                    value_ns: Cell::new(Err(Undetermined)),\n+                    macro_ns: Cell::new(Err(Undetermined)),\n+                },\n+                type_ns_only: false,\n+            };\n+            self.add_import_directive(\n+                vec![Ident {\n+                    name: keywords::SelfValue.name(),\n+                    span: source.span,\n+                }],\n+                subclass,\n+                source.span,\n+                id,\n+                root_use_tree.span,\n+                root_id,\n+                ty::Visibility::Invisible,\n+                expansion,\n+                true, // is_uniform_paths_canary\n+            );\n+\n+            uniform_paths_canary_emitted = true;\n+        }\n+\n         match use_tree.kind {\n             ast::UseTreeKind::Simple(rename, ..) => {\n                 let mut ident = use_tree.ident();\n@@ -223,6 +296,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                     root_id,\n                     vis,\n                     expansion,\n+                    false, // is_uniform_paths_canary\n                 );\n             }\n             ast::UseTreeKind::Glob => {\n@@ -239,6 +313,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                     root_id,\n                     vis,\n                     expansion,\n+                    false, // is_uniform_paths_canary\n                 );\n             }\n             ast::UseTreeKind::Nested(ref items) => {\n@@ -273,7 +348,16 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n \n                 for &(ref tree, id) in items {\n                     self.build_reduced_graph_for_use_tree(\n-                        root_use_tree, root_id, tree, id, vis, &prefix, true, item, expansion\n+                        root_use_tree,\n+                        root_id,\n+                        tree,\n+                        id,\n+                        vis,\n+                        &prefix,\n+                        uniform_paths_canary_emitted,\n+                        true,\n+                        item,\n+                        expansion,\n                     );\n                 }\n             }\n@@ -305,7 +389,16 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                 };\n \n                 self.build_reduced_graph_for_use_tree(\n-                    use_tree, item.id, use_tree, item.id, vis, &prefix, false, item, expansion,\n+                    use_tree,\n+                    item.id,\n+                    use_tree,\n+                    item.id,\n+                    vis,\n+                    &prefix,\n+                    false, // uniform_paths_canary_emitted\n+                    false,\n+                    item,\n+                    expansion,\n                 );\n             }\n \n@@ -333,6 +426,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                     vis: Cell::new(vis),\n                     expansion,\n                     used: Cell::new(used),\n+                    is_uniform_paths_canary: false,\n                 });\n                 self.potentially_unused_imports.push(directive);\n                 let imported_binding = self.import(binding, directive);\n@@ -735,6 +829,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n             vis: Cell::new(ty::Visibility::Restricted(DefId::local(CRATE_DEF_INDEX))),\n             expansion,\n             used: Cell::new(false),\n+            is_uniform_paths_canary: false,\n         });\n \n         if let Some(span) = legacy_imports.import_all {"}, {"sha": "9ba4e4866930959218f519cadee3b2e61e7d0422", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 64, "deletions": 3, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/2ad865d601e57e3ab8b6842174f27fc68bcc44e8/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ad865d601e57e3ab8b6842174f27fc68bcc44e8/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=2ad865d601e57e3ab8b6842174f27fc68bcc44e8", "patch": "@@ -91,6 +91,13 @@ pub struct ImportDirective<'a> {\n     pub vis: Cell<ty::Visibility>,\n     pub expansion: Mark,\n     pub used: Cell<bool>,\n+\n+    /// Whether this import is a \"canary\" for the `uniform_paths` feature,\n+    /// i.e. `use x::...;` results in an `use self::x as _;` canary.\n+    /// This flag affects diagnostics: an error is reported if and only if\n+    /// the import resolves successfully and an external crate with the same\n+    /// name (`x` above) also exists; any resolution failures are ignored.\n+    pub is_uniform_paths_canary: bool,\n }\n \n impl<'a> ImportDirective<'a> {\n@@ -177,6 +184,11 @@ impl<'a, 'crateloader> Resolver<'a, 'crateloader> {\n                     // But when a crate does exist, it will get chosen even when\n                     // macro expansion could result in a success from the lookup\n                     // in the `self` module, later on.\n+                    //\n+                    // NB. This is currently alleviated by the \"ambiguity canaries\"\n+                    // (see `is_uniform_paths_canary`) that get introduced for the\n+                    // maybe-relative imports handled here: if the false negative\n+                    // case were to arise, it would *also* cause an ambiguity error.\n                     if binding.is_ok() {\n                         return binding;\n                     }\n@@ -369,7 +381,8 @@ impl<'a, 'crateloader> Resolver<'a, 'crateloader> {\n                                 root_span: Span,\n                                 root_id: NodeId,\n                                 vis: ty::Visibility,\n-                                expansion: Mark) {\n+                                expansion: Mark,\n+                                is_uniform_paths_canary: bool) {\n         let current_module = self.current_module;\n         let directive = self.arenas.alloc_import_directive(ImportDirective {\n             parent: current_module,\n@@ -383,8 +396,11 @@ impl<'a, 'crateloader> Resolver<'a, 'crateloader> {\n             vis: Cell::new(vis),\n             expansion,\n             used: Cell::new(false),\n+            is_uniform_paths_canary,\n         });\n \n+        debug!(\"add_import_directive({:?})\", directive);\n+\n         self.indeterminate_imports.push(directive);\n         match directive.subclass {\n             SingleImport { target, type_ns_only, .. } => {\n@@ -602,7 +618,47 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n         let mut seen_spans = FxHashSet();\n         for i in 0 .. self.determined_imports.len() {\n             let import = self.determined_imports[i];\n-            if let Some((span, err)) = self.finalize_import(import) {\n+            let error = self.finalize_import(import);\n+\n+            // For a `#![feature(uniform_paths)]` `use self::x as _` canary,\n+            // failure is ignored, while success may cause an ambiguity error.\n+            if import.is_uniform_paths_canary {\n+                let (name, result) = match import.subclass {\n+                    SingleImport { source, ref result, .. } => {\n+                        let type_ns = result[TypeNS].get().ok();\n+                        let value_ns = result[ValueNS].get().ok();\n+                        (source.name, type_ns.or(value_ns))\n+                    }\n+                    _ => bug!(),\n+                };\n+\n+                if error.is_some() {\n+                    continue;\n+                }\n+\n+                let extern_crate_exists = self.extern_prelude.contains(&name);\n+\n+                // A successful `self::x` is ambiguous with an `x` external crate.\n+                if !extern_crate_exists {\n+                    continue;\n+                }\n+\n+                errors = true;\n+\n+                let msg = format!(\"import from `{}` is ambiguous\", name);\n+                let mut err = self.session.struct_span_err(import.span, &msg);\n+                err.span_label(import.span,\n+                    format!(\"could refer to external crate `::{}`\", name));\n+                if let Some(result) = result {\n+                    err.span_label(result.span,\n+                        format!(\"could also refer to `self::{}`\", name));\n+                        err.span_label(result.span,\n+                            format!(\"could also refer to `self::{}`\", name));\n+                }\n+                err.help(&format!(\"write `::{0}` or `self::{0}` explicitly instead\", name));\n+                err.note(\"relative `use` paths enabled by `#![feature(uniform_paths)]`\");\n+                err.emit();\n+            } else if let Some((span, err)) = error {\n                 errors = true;\n \n                 if let SingleImport { source, ref result, .. } = import.subclass {\n@@ -632,9 +688,14 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n         // Report unresolved imports only if no hard error was already reported\n         // to avoid generating multiple errors on the same import.\n         if !errors {\n-            if let Some(import) = self.indeterminate_imports.iter().next() {\n+            for import in &self.indeterminate_imports {\n+                if import.is_uniform_paths_canary {\n+                    continue;\n+                }\n+\n                 let error = ResolutionError::UnresolvedImport(None);\n                 resolve_error(self.resolver, import.span, error);\n+                break;\n             }\n         }\n     }"}, {"sha": "5f29e7bc99e94bf472bc7e13448bb47b13543335", "filename": "src/test/ui/rust-2018/uniform-paths/ambiguity-macros-nested.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/2ad865d601e57e3ab8b6842174f27fc68bcc44e8/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fambiguity-macros-nested.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ad865d601e57e3ab8b6842174f27fc68bcc44e8/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fambiguity-macros-nested.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fambiguity-macros-nested.rs?ref=2ad865d601e57e3ab8b6842174f27fc68bcc44e8", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// edition:2018\n+\n+#![feature(uniform_paths)]\n+\n+// This test is similar to `ambiguity-macros.rs`, but nested in a module.\n+\n+mod foo {\n+    pub use std::io;\n+    //~^ ERROR import from `std` is ambiguous\n+\n+    macro_rules! m {\n+        () => {\n+            mod std {\n+                pub struct io;\n+            }\n+        }\n+    }\n+    m!();\n+}\n+\n+fn main() {}"}, {"sha": "d400987dfee3c8e8522618308dcff8f2107f6a2c", "filename": "src/test/ui/rust-2018/uniform-paths/ambiguity-macros-nested.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2ad865d601e57e3ab8b6842174f27fc68bcc44e8/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fambiguity-macros-nested.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2ad865d601e57e3ab8b6842174f27fc68bcc44e8/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fambiguity-macros-nested.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fambiguity-macros-nested.stderr?ref=2ad865d601e57e3ab8b6842174f27fc68bcc44e8", "patch": "@@ -0,0 +1,16 @@\n+error: import from `std` is ambiguous\n+  --> $DIR/ambiguity-macros-nested.rs:18:13\n+   |\n+LL |       pub use std::io;\n+   |               ^^^ could refer to external crate `::std`\n+...\n+LL | /             mod std {\n+LL | |                 pub struct io;\n+LL | |             }\n+   | |_____________- could also refer to `self::std`\n+   |\n+   = help: write `::std` or `self::std` explicitly instead\n+   = note: relative `use` paths enabled by `#![feature(uniform_paths)]`\n+\n+error: aborting due to previous error\n+"}, {"sha": "547b2508b96ab42c453eaa8ab370131aab7a41f4", "filename": "src/test/ui/rust-2018/uniform-paths/ambiguity-macros.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/2ad865d601e57e3ab8b6842174f27fc68bcc44e8/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fambiguity-macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ad865d601e57e3ab8b6842174f27fc68bcc44e8/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fambiguity-macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fambiguity-macros.rs?ref=2ad865d601e57e3ab8b6842174f27fc68bcc44e8", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// edition:2018\n+\n+#![feature(uniform_paths)]\n+\n+// This test is similar to `ambiguity.rs`, but with macros defining local items.\n+\n+use std::io;\n+//~^ ERROR import from `std` is ambiguous\n+\n+macro_rules! m {\n+    () => {\n+        mod std {\n+            pub struct io;\n+        }\n+    }\n+}\n+m!();\n+\n+fn main() {}"}, {"sha": "24a2061a3cb2aa63488465079bdb4442073d30d2", "filename": "src/test/ui/rust-2018/uniform-paths/ambiguity-macros.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2ad865d601e57e3ab8b6842174f27fc68bcc44e8/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fambiguity-macros.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2ad865d601e57e3ab8b6842174f27fc68bcc44e8/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fambiguity-macros.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fambiguity-macros.stderr?ref=2ad865d601e57e3ab8b6842174f27fc68bcc44e8", "patch": "@@ -0,0 +1,16 @@\n+error: import from `std` is ambiguous\n+  --> $DIR/ambiguity-macros.rs:17:5\n+   |\n+LL |   use std::io;\n+   |       ^^^ could refer to external crate `::std`\n+...\n+LL | /         mod std {\n+LL | |             pub struct io;\n+LL | |         }\n+   | |_________- could also refer to `self::std`\n+   |\n+   = help: write `::std` or `self::std` explicitly instead\n+   = note: relative `use` paths enabled by `#![feature(uniform_paths)]`\n+\n+error: aborting due to previous error\n+"}, {"sha": "fe00fd94ee942a69069f1bebe78cf5ff88f8cfc0", "filename": "src/test/ui/rust-2018/uniform-paths/ambiguity-nested.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/2ad865d601e57e3ab8b6842174f27fc68bcc44e8/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fambiguity-nested.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ad865d601e57e3ab8b6842174f27fc68bcc44e8/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fambiguity-nested.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fambiguity-nested.rs?ref=2ad865d601e57e3ab8b6842174f27fc68bcc44e8", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// edition:2018\n+\n+#![feature(uniform_paths)]\n+\n+// This test is similar to `ambiguity.rs`, but nested in a module.\n+\n+mod foo {\n+    pub use std::io;\n+    //~^ ERROR import from `std` is ambiguous\n+\n+    mod std {\n+        pub struct io;\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "5104aba8b44a21b500dc84bd34e2c76a4a3f860d", "filename": "src/test/ui/rust-2018/uniform-paths/ambiguity-nested.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2ad865d601e57e3ab8b6842174f27fc68bcc44e8/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fambiguity-nested.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2ad865d601e57e3ab8b6842174f27fc68bcc44e8/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fambiguity-nested.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fambiguity-nested.stderr?ref=2ad865d601e57e3ab8b6842174f27fc68bcc44e8", "patch": "@@ -0,0 +1,16 @@\n+error: import from `std` is ambiguous\n+  --> $DIR/ambiguity-nested.rs:18:13\n+   |\n+LL |       pub use std::io;\n+   |               ^^^ could refer to external crate `::std`\n+...\n+LL | /     mod std {\n+LL | |         pub struct io;\n+LL | |     }\n+   | |_____- could also refer to `self::std`\n+   |\n+   = help: write `::std` or `self::std` explicitly instead\n+   = note: relative `use` paths enabled by `#![feature(uniform_paths)]`\n+\n+error: aborting due to previous error\n+"}, {"sha": "49ab2f0c19168e0e0071c21273e5869257894ca9", "filename": "src/test/ui/rust-2018/uniform-paths/ambiguity.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/2ad865d601e57e3ab8b6842174f27fc68bcc44e8/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fambiguity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ad865d601e57e3ab8b6842174f27fc68bcc44e8/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fambiguity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fambiguity.rs?ref=2ad865d601e57e3ab8b6842174f27fc68bcc44e8", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// edition:2018\n+\n+#![feature(uniform_paths)]\n+\n+use std::io;\n+//~^ ERROR import from `std` is ambiguous\n+\n+mod std {\n+    pub struct io;\n+}\n+\n+fn main() {}"}, {"sha": "2e227dce96cb0ce7ffd348fd843fedb519ad0b41", "filename": "src/test/ui/rust-2018/uniform-paths/ambiguity.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2ad865d601e57e3ab8b6842174f27fc68bcc44e8/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fambiguity.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2ad865d601e57e3ab8b6842174f27fc68bcc44e8/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fambiguity.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fambiguity.stderr?ref=2ad865d601e57e3ab8b6842174f27fc68bcc44e8", "patch": "@@ -0,0 +1,16 @@\n+error: import from `std` is ambiguous\n+  --> $DIR/ambiguity.rs:15:5\n+   |\n+LL |   use std::io;\n+   |       ^^^ could refer to external crate `::std`\n+...\n+LL | / mod std {\n+LL | |     pub struct io;\n+LL | | }\n+   | |_- could also refer to `self::std`\n+   |\n+   = help: write `::std` or `self::std` explicitly instead\n+   = note: relative `use` paths enabled by `#![feature(uniform_paths)]`\n+\n+error: aborting due to previous error\n+"}]}