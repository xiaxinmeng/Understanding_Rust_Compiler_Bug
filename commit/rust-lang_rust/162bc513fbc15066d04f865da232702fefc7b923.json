{"sha": "162bc513fbc15066d04f865da232702fefc7b923", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE2MmJjNTEzZmJjMTUwNjZkMDRmODY1ZGEyMzI3MDJmZWZjN2I5MjM=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-05-18T20:59:39Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2017-05-28T07:43:25Z"}, "message": "use a pointer-based array drop loop for non-zero-sized types", "tree": {"sha": "f62ee63c79dabb22f3db0a4595d154a205932be2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f62ee63c79dabb22f3db0a4595d154a205932be2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/162bc513fbc15066d04f865da232702fefc7b923", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/162bc513fbc15066d04f865da232702fefc7b923", "html_url": "https://github.com/rust-lang/rust/commit/162bc513fbc15066d04f865da232702fefc7b923", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/162bc513fbc15066d04f865da232702fefc7b923/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6548aefdeb425170cb40f7160cceedf14c97a433", "url": "https://api.github.com/repos/rust-lang/rust/commits/6548aefdeb425170cb40f7160cceedf14c97a433", "html_url": "https://github.com/rust-lang/rust/commit/6548aefdeb425170cb40f7160cceedf14c97a433"}], "stats": {"total": 189, "additions": 136, "deletions": 53}, "files": [{"sha": "50ebe366387330901ab6fc96db53c8f70fc58577", "filename": "src/librustc_mir/util/elaborate_drops.rs", "status": "modified", "additions": 136, "deletions": 53, "changes": 189, "blob_url": "https://github.com/rust-lang/rust/blob/162bc513fbc15066d04f865da232702fefc7b923/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/162bc513fbc15066d04f865da232702fefc7b923/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs?ref=162bc513fbc15066d04f865da232702fefc7b923", "patch": "@@ -493,13 +493,8 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n         let discr_ty = adt.repr.discr_type().to_ty(self.tcx());\n         let discr = Lvalue::Local(self.new_temp(discr_ty));\n         let discr_rv = Rvalue::Discriminant(self.lvalue.clone());\n-        let switch_block = self.elaborator.patch().new_block(BasicBlockData {\n-            statements: vec![\n-                Statement {\n-                    source_info: self.source_info,\n-                    kind: StatementKind::Assign(discr.clone(), discr_rv),\n-                }\n-                ],\n+        let switch_block = BasicBlockData {\n+            statements: vec![self.assign(&discr, discr_rv)],\n             terminator: Some(Terminator {\n                 source_info: self.source_info,\n                 kind: TerminatorKind::SwitchInt {\n@@ -510,7 +505,8 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n                 }\n             }),\n             is_cleanup: unwind.is_cleanup(),\n-        });\n+        };\n+        let switch_block = self.elaborator.patch().new_block(switch_block);\n         self.drop_flag_test_block(switch_block, succ, unwind)\n     }\n \n@@ -531,14 +527,11 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n         let ref_lvalue = self.new_temp(ref_ty);\n         let unit_temp = Lvalue::Local(self.new_temp(tcx.mk_nil()));\n \n-        self.elaborator.patch().new_block(BasicBlockData {\n-            statements: vec![Statement {\n-                source_info: self.source_info,\n-                kind: StatementKind::Assign(\n-                    Lvalue::Local(ref_lvalue),\n-                    Rvalue::Ref(tcx.types.re_erased, BorrowKind::Mut, self.lvalue.clone())\n-                )\n-            }],\n+        let result = BasicBlockData {\n+            statements: vec![self.assign(\n+                &Lvalue::Local(ref_lvalue),\n+                Rvalue::Ref(tcx.types.re_erased, BorrowKind::Mut, self.lvalue.clone())\n+            )],\n             terminator: Some(Terminator {\n                 kind: TerminatorKind::Call {\n                     func: Operand::function_handle(tcx, drop_fn.def_id, substs,\n@@ -550,24 +543,33 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n                 source_info: self.source_info\n             }),\n             is_cleanup: unwind.is_cleanup(),\n-        })\n+        };\n+        self.elaborator.patch().new_block(result)\n     }\n \n     /// create a loop that drops an array:\n+    ///\n+\n     ///\n     /// loop-block:\n-    ///    can_go = index == len\n+    ///    can_go = cur == length_or_end\n     ///    if can_go then succ else drop-block\n     /// drop-block:\n-    ///    ptr = &mut LV[index]\n-    ///    index = index + 1\n+    ///    if ptr_based {\n+    ///        ptr = cur\n+    ///        cur = cur.offset(1)\n+    ///    } else {\n+    ///        ptr = &mut LV[cur]\n+    ///        cur = cur + 1\n+    ///    }\n     ///    drop(ptr)\n     fn drop_loop(&mut self,\n                  succ: BasicBlock,\n-                 index: &Lvalue<'tcx>,\n-                 length: &Lvalue<'tcx>,\n+                 cur: &Lvalue<'tcx>,\n+                 length_or_end: &Lvalue<'tcx>,\n                  ety: Ty<'tcx>,\n-                 unwind: Unwind)\n+                 unwind: Unwind,\n+                 ptr_based: bool)\n                  -> BasicBlock\n     {\n         let use_ = |lv: &Lvalue<'tcx>| Operand::Consume(lv.clone());\n@@ -581,38 +583,44 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n         let can_go = &Lvalue::Local(self.new_temp(tcx.types.bool));\n \n         let one = self.constant_usize(1);\n-        let drop_block = self.elaborator.patch().new_block(BasicBlockData {\n+        let (ptr_next, cur_next) = if ptr_based {\n+            (Rvalue::Use(use_(cur)),\n+             Rvalue::BinaryOp(BinOp::Offset, use_(cur), one))\n+        } else {\n+            (Rvalue::Ref(\n+                 tcx.types.re_erased,\n+                 BorrowKind::Mut,\n+                 self.lvalue.clone().index(use_(cur))),\n+             Rvalue::BinaryOp(BinOp::Add, use_(cur), one))\n+        };\n+\n+        let drop_block = BasicBlockData {\n             statements: vec![\n-                Statement { source_info: self.source_info, kind: StatementKind::Assign(\n-                    ptr.clone(), Rvalue::Ref(\n-                        tcx.types.re_erased, BorrowKind::Mut,\n-                        self.lvalue.clone().index(use_(index))\n-                    ),\n-                )},\n-                Statement { source_info: self.source_info, kind: StatementKind::Assign(\n-                    index.clone(), Rvalue::BinaryOp(BinOp::Add, use_(index), one)\n-                )},\n+                self.assign(ptr, ptr_next),\n+                self.assign(cur, cur_next)\n             ],\n             is_cleanup: unwind.is_cleanup(),\n             terminator: Some(Terminator {\n                 source_info: self.source_info,\n                 // this gets overwritten by drop elaboration.\n                 kind: TerminatorKind::Unreachable,\n             })\n-        });\n+        };\n+        let drop_block = self.elaborator.patch().new_block(drop_block);\n \n-        let loop_block = self.elaborator.patch().new_block(BasicBlockData {\n+        let loop_block = BasicBlockData {\n             statements: vec![\n-                Statement { source_info: self.source_info, kind: StatementKind::Assign(\n-                    can_go.clone(), Rvalue::BinaryOp(BinOp::Eq, use_(index), use_(length))\n-                )},\n+                self.assign(can_go, Rvalue::BinaryOp(BinOp::Eq,\n+                                                     use_(cur),\n+                                                     use_(length_or_end)))\n             ],\n             is_cleanup: unwind.is_cleanup(),\n             terminator: Some(Terminator {\n                 source_info: self.source_info,\n                 kind: TerminatorKind::if_(tcx, use_(can_go), succ, drop_block)\n             })\n-        });\n+        };\n+        let loop_block = self.elaborator.patch().new_block(loop_block);\n \n         self.elaborator.patch().patch_terminator(drop_block, TerminatorKind::Drop {\n             location: ptr.clone().deref(),\n@@ -625,29 +633,97 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n \n     fn open_drop_for_array(&mut self, ety: Ty<'tcx>) -> BasicBlock {\n         debug!(\"open_drop_for_array({:?})\", ety);\n-        // FIXME: using an index instead of a pointer to avoid\n-        // special-casing ZSTs.\n+\n+        // if size_of::<ety>() == 0 {\n+        //     index_based_loop\n+        // } else {\n+        //     ptr_based_loop\n+        // }\n+\n+        let tcx = self.tcx();\n+\n+        let use_ = |lv: &Lvalue<'tcx>| Operand::Consume(lv.clone());\n+        let size = &Lvalue::Local(self.new_temp(tcx.types.usize));\n+        let size_is_zero = &Lvalue::Local(self.new_temp(tcx.types.bool));\n+        let base_block = BasicBlockData {\n+            statements: vec![\n+                self.assign(size, Rvalue::NullaryOp(NullOp::SizeOf, ety)),\n+                self.assign(size_is_zero, Rvalue::BinaryOp(BinOp::Eq,\n+                                                           use_(size),\n+                                                           self.constant_usize(0)))\n+            ],\n+            is_cleanup: self.unwind.is_cleanup(),\n+            terminator: Some(Terminator {\n+                source_info: self.source_info,\n+                kind: TerminatorKind::if_(\n+                    tcx,\n+                    use_(size_is_zero),\n+                    self.drop_loop_pair(ety, false),\n+                    self.drop_loop_pair(ety, true)\n+                )\n+            })\n+        };\n+        self.elaborator.patch().new_block(base_block)\n+    }\n+\n+    // create a pair of drop-loops of `lvalue`, which drops its contents\n+    // even in the case of 1 panic. If `ptr_based`, create a pointer loop,\n+    // otherwise create an index loop.\n+    fn drop_loop_pair(&mut self, ety: Ty<'tcx>, ptr_based: bool) -> BasicBlock {\n+        debug!(\"drop_loop_pair({:?}, {:?})\", ety, ptr_based);\n         let tcx = self.tcx();\n-        let index = &Lvalue::Local(self.new_temp(tcx.types.usize));\n-        let length = &Lvalue::Local(self.new_temp(tcx.types.usize));\n+        let iter_ty = if ptr_based {\n+            tcx.mk_ptr(ty::TypeAndMut { ty: ety, mutbl: hir::Mutability::MutMutable })\n+        } else {\n+            tcx.types.usize\n+        };\n+\n+        let cur = Lvalue::Local(self.new_temp(iter_ty));\n+        let length = Lvalue::Local(self.new_temp(tcx.types.usize));\n+        let length_or_end = if ptr_based {\n+            Lvalue::Local(self.new_temp(iter_ty))\n+        } else {\n+            length.clone()\n+        };\n \n         let unwind = self.unwind.map(|unwind| {\n-            self.drop_loop(unwind, index, length, ety, Unwind::InCleanup)\n+            self.drop_loop(unwind,\n+                           &cur,\n+                           &length_or_end,\n+                           ety,\n+                           Unwind::InCleanup,\n+                           ptr_based)\n         });\n \n         let succ = self.succ; // FIXME(#6393)\n-        let loop_block = self.drop_loop(succ, index, length, ety, unwind);\n+        let loop_block = self.drop_loop(\n+            succ,\n+            &cur,\n+            &length_or_end,\n+            ety,\n+            unwind,\n+            ptr_based);\n \n         let zero = self.constant_usize(0);\n+        let mut drop_block_stmts = vec![];\n+        drop_block_stmts.push(self.assign(&length, Rvalue::Len(self.lvalue.clone())));\n+        if ptr_based {\n+            // cur = &LV[0];\n+            // end = &LV[len];\n+            drop_block_stmts.push(self.assign(&cur, Rvalue::Ref(\n+                tcx.types.re_erased, BorrowKind::Mut,\n+                self.lvalue.clone().index(zero.clone())\n+            )));\n+            drop_block_stmts.push(self.assign(&length_or_end, Rvalue::Ref(\n+                tcx.types.re_erased, BorrowKind::Mut,\n+                self.lvalue.clone().index(Operand::Consume(length.clone()))\n+            )));\n+        } else {\n+            // index = 0 (length already pushed)\n+            drop_block_stmts.push(self.assign(&cur, Rvalue::Use(zero)));\n+        }\n         let drop_block = self.elaborator.patch().new_block(BasicBlockData {\n-            statements: vec![\n-                Statement { source_info: self.source_info, kind: StatementKind::Assign(\n-                    length.clone(), Rvalue::Len(self.lvalue.clone())\n-                )},\n-                Statement { source_info: self.source_info, kind: StatementKind::Assign(\n-                    index.clone(), Rvalue::Use(zero),\n-                )},\n-            ],\n+            statements: drop_block_stmts,\n             is_cleanup: unwind.is_cleanup(),\n             terminator: Some(Terminator {\n                 source_info: self.source_info,\n@@ -836,4 +912,11 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n             literal: Literal::Value { value: ConstVal::Integral(self.tcx().const_usize(val)) }\n         })\n     }\n+\n+    fn assign(&self, lhs: &Lvalue<'tcx>, rhs: Rvalue<'tcx>) -> Statement<'tcx> {\n+        Statement {\n+            source_info: self.source_info,\n+            kind: StatementKind::Assign(lhs.clone(), rhs)\n+        }\n+    }\n }"}]}