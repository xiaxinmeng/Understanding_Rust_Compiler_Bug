{"sha": "4992b75e518ae1427a040efa7cc2601186e8898e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ5OTJiNzVlNTE4YWUxNDI3YTA0MGVmYTdjYzI2MDExODZlODg5OGU=", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2020-11-03T22:29:53Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2020-11-03T22:41:35Z"}, "message": "Qualify trait impl created by add_custom_impl assist", "tree": {"sha": "c28db776ea1ff781f2bff2cf8ba6b2c994f7a5c4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c28db776ea1ff781f2bff2cf8ba6b2c994f7a5c4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4992b75e518ae1427a040efa7cc2601186e8898e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4992b75e518ae1427a040efa7cc2601186e8898e", "html_url": "https://github.com/rust-lang/rust/commit/4992b75e518ae1427a040efa7cc2601186e8898e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4992b75e518ae1427a040efa7cc2601186e8898e/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "060c8b2c96a0de4a131c4d780d2aac80afe13de8", "url": "https://api.github.com/repos/rust-lang/rust/commits/060c8b2c96a0de4a131c4d780d2aac80afe13de8", "html_url": "https://github.com/rust-lang/rust/commit/060c8b2c96a0de4a131c4d780d2aac80afe13de8"}], "stats": {"total": 152, "additions": 114, "deletions": 38}, "files": [{"sha": "669dd9b2173a4a5c4a6182edce4dde4e7693da97", "filename": "crates/assists/src/handlers/add_custom_impl.rs", "status": "modified", "additions": 114, "deletions": 38, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/4992b75e518ae1427a040efa7cc2601186e8898e/crates%2Fassists%2Fsrc%2Fhandlers%2Fadd_custom_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4992b75e518ae1427a040efa7cc2601186e8898e/crates%2Fassists%2Fsrc%2Fhandlers%2Fadd_custom_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Fadd_custom_impl.rs?ref=4992b75e518ae1427a040efa7cc2601186e8898e", "patch": "@@ -1,13 +1,16 @@\n+use ide_db::imports_locator;\n use itertools::Itertools;\n use syntax::{\n-    ast::{self, AstNode},\n+    ast::{self, make, AstNode},\n     Direction, SmolStr,\n     SyntaxKind::{IDENT, WHITESPACE},\n     TextRange, TextSize,\n };\n \n use crate::{\n-    assist_context::{AssistContext, Assists},\n+    assist_config::SnippetCap,\n+    assist_context::{AssistBuilder, AssistContext, Assists},\n+    utils::mod_path_to_ast,\n     AssistId, AssistKind,\n };\n \n@@ -30,78 +33,151 @@ use crate::{\n // ```\n pub(crate) fn add_custom_impl(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let attr = ctx.find_node_at_offset::<ast::Attr>()?;\n-    let input = attr.token_tree()?;\n \n     let attr_name = attr\n         .syntax()\n         .descendants_with_tokens()\n         .filter(|t| t.kind() == IDENT)\n-        .find_map(|i| i.into_token())\n-        .filter(|t| *t.text() == \"derive\")?\n+        .find_map(syntax::NodeOrToken::into_token)\n+        .filter(|t| t.text() == \"derive\")?\n         .text()\n         .clone();\n \n     let trait_token =\n         ctx.token_at_offset().find(|t| t.kind() == IDENT && *t.text() != attr_name)?;\n+    let trait_path = make::path_unqualified(make::path_segment(make::name_ref(trait_token.text())));\n \n     let annotated = attr.syntax().siblings(Direction::Next).find_map(ast::Name::cast)?;\n     let annotated_name = annotated.syntax().text().to_string();\n-    let start_offset = annotated.syntax().parent()?.text_range().end();\n+    let insert_pos = annotated.syntax().parent()?.text_range().end();\n+\n+    let current_module = ctx.sema.scope(annotated.syntax()).module()?;\n+    let current_crate = current_module.krate();\n+\n+    let found_traits = imports_locator::find_imports(&ctx.sema, current_crate, trait_token.text())\n+        .into_iter()\n+        .filter_map(|candidate: either::Either<hir::ModuleDef, hir::MacroDef>| match candidate {\n+            either::Either::Left(hir::ModuleDef::Trait(trait_)) => Some(trait_),\n+            _ => None,\n+        })\n+        .flat_map(|trait_| {\n+            current_module\n+                .find_use_path(ctx.sema.db, hir::ModuleDef::Trait(trait_))\n+                .as_ref()\n+                .map(mod_path_to_ast)\n+                .zip(Some(trait_))\n+        });\n \n-    let label =\n-        format!(\"Add custom impl `{}` for `{}`\", trait_token.text().as_str(), annotated_name);\n+    let mut no_traits_found = true;\n+    for (trait_path, _trait) in found_traits.inspect(|_| no_traits_found = false) {\n+        add_assist(acc, ctx.config.snippet_cap, &attr, &trait_path, &annotated_name, insert_pos)?;\n+    }\n+    if no_traits_found {\n+        add_assist(acc, ctx.config.snippet_cap, &attr, &trait_path, &annotated_name, insert_pos)?;\n+    }\n+    Some(())\n+}\n \n+fn add_assist(\n+    acc: &mut Assists,\n+    snippet_cap: Option<SnippetCap>,\n+    attr: &ast::Attr,\n+    trait_path: &ast::Path,\n+    annotated_name: &str,\n+    insert_pos: TextSize,\n+) -> Option<()> {\n     let target = attr.syntax().text_range();\n-    acc.add(AssistId(\"add_custom_impl\", AssistKind::Refactor), label, target, |builder| {\n-        let new_attr_input = input\n-            .syntax()\n-            .descendants_with_tokens()\n-            .filter(|t| t.kind() == IDENT)\n-            .filter_map(|t| t.into_token().map(|t| t.text().clone()))\n-            .filter(|t| t != trait_token.text())\n-            .collect::<Vec<SmolStr>>();\n-        let has_more_derives = !new_attr_input.is_empty();\n-\n-        if has_more_derives {\n-            let new_attr_input = format!(\"({})\", new_attr_input.iter().format(\", \"));\n-            builder.replace(input.syntax().text_range(), new_attr_input);\n-        } else {\n-            let attr_range = attr.syntax().text_range();\n-            builder.delete(attr_range);\n-\n-            let line_break_range = attr\n-                .syntax()\n-                .next_sibling_or_token()\n-                .filter(|t| t.kind() == WHITESPACE)\n-                .map(|t| t.text_range())\n-                .unwrap_or_else(|| TextRange::new(TextSize::from(0), TextSize::from(0)));\n-            builder.delete(line_break_range);\n-        }\n+    let input = attr.token_tree()?;\n+    let label = format!(\"Add custom impl `{}` for `{}`\", trait_path, annotated_name);\n+    let trait_name = trait_path.segment().and_then(|seg| seg.name_ref())?;\n \n-        match ctx.config.snippet_cap {\n+    acc.add(AssistId(\"add_custom_impl\", AssistKind::Refactor), label, target, |builder| {\n+        update_attribute(builder, &input, &trait_name, &attr);\n+        match snippet_cap {\n             Some(cap) => {\n                 builder.insert_snippet(\n                     cap,\n-                    start_offset,\n-                    format!(\"\\n\\nimpl {} for {} {{\\n    $0\\n}}\", trait_token, annotated_name),\n+                    insert_pos,\n+                    format!(\"\\n\\nimpl {} for {} {{\\n    $0\\n}}\", trait_path, annotated_name),\n                 );\n             }\n             None => {\n                 builder.insert(\n-                    start_offset,\n-                    format!(\"\\n\\nimpl {} for {} {{\\n\\n}}\", trait_token, annotated_name),\n+                    insert_pos,\n+                    format!(\"\\n\\nimpl {} for {} {{\\n\\n}}\", trait_path, annotated_name),\n                 );\n             }\n         }\n     })\n }\n \n+fn update_attribute(\n+    builder: &mut AssistBuilder,\n+    input: &ast::TokenTree,\n+    trait_name: &ast::NameRef,\n+    attr: &ast::Attr,\n+) {\n+    let new_attr_input = input\n+        .syntax()\n+        .descendants_with_tokens()\n+        .filter(|t| t.kind() == IDENT)\n+        .filter_map(|t| t.into_token().map(|t| t.text().clone()))\n+        .filter(|t| t != trait_name.text())\n+        .collect::<Vec<SmolStr>>();\n+    let has_more_derives = !new_attr_input.is_empty();\n+\n+    if has_more_derives {\n+        let new_attr_input = format!(\"({})\", new_attr_input.iter().format(\", \"));\n+        builder.replace(input.syntax().text_range(), new_attr_input);\n+    } else {\n+        let attr_range = attr.syntax().text_range();\n+        builder.delete(attr_range);\n+\n+        let line_break_range = attr\n+            .syntax()\n+            .next_sibling_or_token()\n+            .filter(|t| t.kind() == WHITESPACE)\n+            .map(|t| t.text_range())\n+            .unwrap_or_else(|| TextRange::new(TextSize::from(0), TextSize::from(0)));\n+        builder.delete(line_break_range);\n+    }\n+}\n+\n #[cfg(test)]\n mod tests {\n     use crate::tests::{check_assist, check_assist_not_applicable};\n \n     use super::*;\n \n+    #[test]\n+    fn add_custom_impl_qualified() {\n+        check_assist(\n+            add_custom_impl,\n+            \"\n+mod fmt {\n+    pub trait Debug {}\n+}\n+\n+#[derive(Debu<|>g)]\n+struct Foo {\n+    bar: String,\n+}\n+\",\n+            \"\n+mod fmt {\n+    pub trait Debug {}\n+}\n+\n+struct Foo {\n+    bar: String,\n+}\n+\n+impl fmt::Debug for Foo {\n+    $0\n+}\n+\",\n+        )\n+    }\n     #[test]\n     fn add_custom_impl_for_unique_input() {\n         check_assist("}]}