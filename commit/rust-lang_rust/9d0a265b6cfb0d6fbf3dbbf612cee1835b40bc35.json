{"sha": "9d0a265b6cfb0d6fbf3dbbf612cee1835b40bc35", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlkMGEyNjViNmNmYjBkNmZiZjNkYmJmNjEyY2VlMTgzNWI0MGJjMzU=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-09-16T06:25:02Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-09-16T06:25:02Z"}, "message": "Rollup merge of #76662 - RalfJung:lib-test-miri, r=Mark-Simulacrum\n\nFix liballoc test suite for Miri\n\nMostly, fix the regression introduced by https://github.com/rust-lang/rust/pull/75207 that caused slices (i.e., references) to be created to invalid memory or memory that has aliasing pointers that we want to keep valid. @dylni  this changes the type of `check_range` to only require the length, not the full reference to the slice, which indeed is all the information this function requires.\n\nAlso reduce the size of a test introduced in https://github.com/rust-lang/rust/pull/70793 to make it not take 3 minutes in Miri.\n\nThis makes https://github.com/RalfJung/miri-test-libstd work again.", "tree": {"sha": "4a1d9dafc553ea2d3918dfe0e151be3197cd3f83", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4a1d9dafc553ea2d3918dfe0e151be3197cd3f83"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9d0a265b6cfb0d6fbf3dbbf612cee1835b40bc35", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfYa++CRBK7hj4Ov3rIwAAdHIIADZkJgeDGX2G3YbNX+Ad2dno\nuX2qEfOKfVr1R0m1hS/0zujSvy5aSsTPrW5i4wMhqWWAUTSZOqe0V6NW9R7K6qPZ\nzAC5UNRQs/1Xz4ZCLNolB69J5vdIH2yQX5YdV0cvlcGrU9q/lH0woYsdW5GvN2Eu\n2D924Y95cLEhStocHE2MjWjcT1i39c8PsuxsS5YVVoxYdKvQE959JAp41QnxAxqn\nJjM6uVYwE0qnF7QxA4lZ/kaKUzi6J1N3xGlPp2PpBrVlTbeU7NmQ0Qx90wdyIU+r\n7O1qLcedQgrziwfqy+kscCSwQ7cqzwxk3/y+99y8CT4bdPfrBMdjbEiIO+RbX2U=\n=NWCq\n-----END PGP SIGNATURE-----\n", "payload": "tree 4a1d9dafc553ea2d3918dfe0e151be3197cd3f83\nparent 0bcc96dd3d54d459f3ae9a178bac3e7e944a9102\nparent 7d67546a6ade5c1ade4b8e66266411f7aa4fae69\nauthor Ralf Jung <post@ralfj.de> 1600237502 +0200\ncommitter GitHub <noreply@github.com> 1600237502 +0200\n\nRollup merge of #76662 - RalfJung:lib-test-miri, r=Mark-Simulacrum\n\nFix liballoc test suite for Miri\n\nMostly, fix the regression introduced by https://github.com/rust-lang/rust/pull/75207 that caused slices (i.e., references) to be created to invalid memory or memory that has aliasing pointers that we want to keep valid. @dylni  this changes the type of `check_range` to only require the length, not the full reference to the slice, which indeed is all the information this function requires.\n\nAlso reduce the size of a test introduced in https://github.com/rust-lang/rust/pull/70793 to make it not take 3 minutes in Miri.\n\nThis makes https://github.com/RalfJung/miri-test-libstd work again.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9d0a265b6cfb0d6fbf3dbbf612cee1835b40bc35", "html_url": "https://github.com/rust-lang/rust/commit/9d0a265b6cfb0d6fbf3dbbf612cee1835b40bc35", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9d0a265b6cfb0d6fbf3dbbf612cee1835b40bc35/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0bcc96dd3d54d459f3ae9a178bac3e7e944a9102", "url": "https://api.github.com/repos/rust-lang/rust/commits/0bcc96dd3d54d459f3ae9a178bac3e7e944a9102", "html_url": "https://github.com/rust-lang/rust/commit/0bcc96dd3d54d459f3ae9a178bac3e7e944a9102"}, {"sha": "7d67546a6ade5c1ade4b8e66266411f7aa4fae69", "url": "https://api.github.com/repos/rust-lang/rust/commits/7d67546a6ade5c1ade4b8e66266411f7aa4fae69", "html_url": "https://github.com/rust-lang/rust/commit/7d67546a6ade5c1ade4b8e66266411f7aa4fae69"}], "stats": {"total": 171, "additions": 85, "deletions": 86}, "files": [{"sha": "65cfe9a9b49965c3b1576952c64f977c312b0ca4", "filename": "library/alloc/src/collections/vec_deque.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9d0a265b6cfb0d6fbf3dbbf612cee1835b40bc35/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d0a265b6cfb0d6fbf3dbbf612cee1835b40bc35/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fvec_deque.rs?ref=9d0a265b6cfb0d6fbf3dbbf612cee1835b40bc35", "patch": "@@ -1089,11 +1089,7 @@ impl<T> VecDeque<T> {\n     where\n         R: RangeBounds<usize>,\n     {\n-        // SAFETY: This buffer is only used to check the range. It might be partially\n-        // uninitialized, but `check_range` needs a contiguous slice.\n-        // https://github.com/rust-lang/rust/pull/75207#discussion_r471193682\n-        let buffer = unsafe { slice::from_raw_parts(self.ptr(), self.len()) };\n-        let Range { start, end } = buffer.check_range(range);\n+        let Range { start, end } = slice::check_range(self.len(), range);\n         let tail = self.wrap_add(self.tail, start);\n         let head = self.wrap_add(self.tail, end);\n         (tail, head)"}, {"sha": "55afdd94f4468ebc4403812291211b102d0b510e", "filename": "library/alloc/src/slice.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d0a265b6cfb0d6fbf3dbbf612cee1835b40bc35/library%2Falloc%2Fsrc%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d0a265b6cfb0d6fbf3dbbf612cee1835b40bc35/library%2Falloc%2Fsrc%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fslice.rs?ref=9d0a265b6cfb0d6fbf3dbbf612cee1835b40bc35", "patch": "@@ -91,6 +91,8 @@ use crate::borrow::ToOwned;\n use crate::boxed::Box;\n use crate::vec::Vec;\n \n+#[unstable(feature = \"slice_check_range\", issue = \"76393\")]\n+pub use core::slice::check_range;\n #[unstable(feature = \"array_chunks\", issue = \"74985\")]\n pub use core::slice::ArrayChunks;\n #[unstable(feature = \"array_chunks\", issue = \"74985\")]"}, {"sha": "2b0ce5ede56308b1a907def495bc12d5215b0d27", "filename": "library/alloc/src/string.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9d0a265b6cfb0d6fbf3dbbf612cee1835b40bc35/library%2Falloc%2Fsrc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d0a265b6cfb0d6fbf3dbbf612cee1835b40bc35/library%2Falloc%2Fsrc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fstring.rs?ref=9d0a265b6cfb0d6fbf3dbbf612cee1835b40bc35", "patch": "@@ -49,6 +49,7 @@ use core::iter::{FromIterator, FusedIterator};\n use core::ops::Bound::{Excluded, Included, Unbounded};\n use core::ops::{self, Add, AddAssign, Index, IndexMut, Range, RangeBounds};\n use core::ptr;\n+use core::slice;\n use core::str::{lossy, pattern::Pattern};\n \n use crate::borrow::{Cow, ToOwned};\n@@ -1506,7 +1507,7 @@ impl String {\n         // of the vector version. The data is just plain bytes.\n         // Because the range removal happens in Drop, if the Drain iterator is leaked,\n         // the removal will not happen.\n-        let Range { start, end } = self.as_bytes().check_range(range);\n+        let Range { start, end } = slice::check_range(self.len(), range);\n         assert!(self.is_char_boundary(start));\n         assert!(self.is_char_boundary(end));\n "}, {"sha": "9dbea0dc9e68b9296d8d2dbdaebdb48635cb07d4", "filename": "library/alloc/src/vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d0a265b6cfb0d6fbf3dbbf612cee1835b40bc35/library%2Falloc%2Fsrc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d0a265b6cfb0d6fbf3dbbf612cee1835b40bc35/library%2Falloc%2Fsrc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec.rs?ref=9d0a265b6cfb0d6fbf3dbbf612cee1835b40bc35", "patch": "@@ -1312,7 +1312,7 @@ impl<T> Vec<T> {\n         // the hole, and the vector length is restored to the new length.\n         //\n         let len = self.len();\n-        let Range { start, end } = self.check_range(range);\n+        let Range { start, end } = slice::check_range(len, range);\n \n         unsafe {\n             // set self.vec length's to start, to be safe in case Drain is leaked"}, {"sha": "368ca4c543219a50d0d8e8a601185eeea7d4c5da", "filename": "library/alloc/tests/vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d0a265b6cfb0d6fbf3dbbf612cee1835b40bc35/library%2Falloc%2Ftests%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d0a265b6cfb0d6fbf3dbbf612cee1835b40bc35/library%2Falloc%2Ftests%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fvec.rs?ref=9d0a265b6cfb0d6fbf3dbbf612cee1835b40bc35", "patch": "@@ -919,7 +919,7 @@ fn test_from_iter_partially_drained_in_place_specialization() {\n #[test]\n fn test_from_iter_specialization_with_iterator_adapters() {\n     fn assert_in_place_trait<T: InPlaceIterable>(_: &T) {};\n-    let src: Vec<usize> = vec![0usize; 65535];\n+    let src: Vec<usize> = vec![0usize; 256];\n     let srcptr = src.as_ptr();\n     let iter = src\n         .into_iter()"}, {"sha": "16fcb6231dc0981834e67af5d2a769f21421e746", "filename": "library/core/src/slice/index.rs", "status": "modified", "additions": 74, "deletions": 1, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/9d0a265b6cfb0d6fbf3dbbf612cee1835b40bc35/library%2Fcore%2Fsrc%2Fslice%2Findex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d0a265b6cfb0d6fbf3dbbf612cee1835b40bc35/library%2Fcore%2Fsrc%2Fslice%2Findex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Findex.rs?ref=9d0a265b6cfb0d6fbf3dbbf612cee1835b40bc35", "patch": "@@ -1,6 +1,6 @@\n //! Indexing implementations for `[T]`.\n \n-use crate::ops;\n+use crate::ops::{self, Bound, Range, RangeBounds};\n use crate::ptr;\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -62,6 +62,79 @@ pub(super) fn slice_end_index_overflow_fail() -> ! {\n     panic!(\"attempted to index slice up to maximum usize\");\n }\n \n+/// Performs bounds-checking of the given range.\n+/// The returned [`Range`] is safe to pass to [`get_unchecked`] and [`get_unchecked_mut`]\n+/// for slices of the given length.\n+///\n+/// [`get_unchecked`]: ../../std/primitive.slice.html#method.get_unchecked\n+/// [`get_unchecked_mut`]: ../../std/primitive.slice.html#method.get_unchecked_mut\n+///\n+/// # Panics\n+///\n+/// Panics if the range is out of bounds.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// #![feature(slice_check_range)]\n+/// use std::slice;\n+///\n+/// let v = [10, 40, 30];\n+/// assert_eq!(1..2, slice::check_range(v.len(), 1..2));\n+/// assert_eq!(0..2, slice::check_range(v.len(), ..2));\n+/// assert_eq!(1..3, slice::check_range(v.len(), 1..));\n+/// ```\n+///\n+/// Panics when [`Index::index`] would panic:\n+///\n+/// ```should_panic\n+/// #![feature(slice_check_range)]\n+///\n+/// std::slice::check_range(3, 2..1);\n+/// ```\n+///\n+/// ```should_panic\n+/// #![feature(slice_check_range)]\n+///\n+/// std::slice::check_range(3, 1..4);\n+/// ```\n+///\n+/// ```should_panic\n+/// #![feature(slice_check_range)]\n+///\n+/// std::slice::check_range(3, 1..=usize::MAX);\n+/// ```\n+///\n+/// [`Index::index`]: ops::Index::index\n+#[track_caller]\n+#[unstable(feature = \"slice_check_range\", issue = \"76393\")]\n+pub fn check_range<R: RangeBounds<usize>>(len: usize, range: R) -> Range<usize> {\n+    let start = match range.start_bound() {\n+        Bound::Included(&start) => start,\n+        Bound::Excluded(start) => {\n+            start.checked_add(1).unwrap_or_else(|| slice_start_index_overflow_fail())\n+        }\n+        Bound::Unbounded => 0,\n+    };\n+\n+    let end = match range.end_bound() {\n+        Bound::Included(end) => {\n+            end.checked_add(1).unwrap_or_else(|| slice_end_index_overflow_fail())\n+        }\n+        Bound::Excluded(&end) => end,\n+        Bound::Unbounded => len,\n+    };\n+\n+    if start > end {\n+        slice_index_order_fail(start, end);\n+    }\n+    if end > len {\n+        slice_end_index_len_fail(end, len);\n+    }\n+\n+    Range { start, end }\n+}\n+\n mod private_slice_index {\n     use super::ops;\n     #[stable(feature = \"slice_get_slice\", since = \"1.28.0\")]"}, {"sha": "ba3185433c8d86639a019cd0f2ad9f46fb4869c5", "filename": "library/core/src/slice/mod.rs", "status": "modified", "additions": 4, "deletions": 77, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/9d0a265b6cfb0d6fbf3dbbf612cee1835b40bc35/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d0a265b6cfb0d6fbf3dbbf612cee1835b40bc35/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs?ref=9d0a265b6cfb0d6fbf3dbbf612cee1835b40bc35", "patch": "@@ -12,7 +12,7 @@ use crate::cmp::Ordering::{self, Equal, Greater, Less};\n use crate::intrinsics::assume;\n use crate::marker::{self, Copy};\n use crate::mem;\n-use crate::ops::{Bound, FnMut, Range, RangeBounds};\n+use crate::ops::{FnMut, Range, RangeBounds};\n use crate::option::Option;\n use crate::option::Option::{None, Some};\n use crate::ptr::{self, NonNull};\n@@ -72,8 +72,8 @@ pub use sort::heapsort;\n #[stable(feature = \"slice_get_slice\", since = \"1.28.0\")]\n pub use index::SliceIndex;\n \n-use index::{slice_end_index_len_fail, slice_index_order_fail};\n-use index::{slice_end_index_overflow_fail, slice_start_index_overflow_fail};\n+#[unstable(feature = \"slice_check_range\", issue = \"76393\")]\n+pub use index::check_range;\n \n #[lang = \"slice\"]\n #[cfg(not(test))]\n@@ -378,79 +378,6 @@ impl<T> [T] {\n         unsafe { &mut *index.get_unchecked_mut(self) }\n     }\n \n-    /// Converts a range over this slice to [`Range`].\n-    ///\n-    /// The returned range is safe to pass to [`get_unchecked`] and [`get_unchecked_mut`].\n-    ///\n-    /// [`get_unchecked`]: #method.get_unchecked\n-    /// [`get_unchecked_mut`]: #method.get_unchecked_mut\n-    ///\n-    /// # Panics\n-    ///\n-    /// Panics if the range is out of bounds.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(slice_check_range)]\n-    ///\n-    /// let v = [10, 40, 30];\n-    /// assert_eq!(1..2, v.check_range(1..2));\n-    /// assert_eq!(0..2, v.check_range(..2));\n-    /// assert_eq!(1..3, v.check_range(1..));\n-    /// ```\n-    ///\n-    /// Panics when [`Index::index`] would panic:\n-    ///\n-    /// ```should_panic\n-    /// #![feature(slice_check_range)]\n-    ///\n-    /// [10, 40, 30].check_range(2..1);\n-    /// ```\n-    ///\n-    /// ```should_panic\n-    /// #![feature(slice_check_range)]\n-    ///\n-    /// [10, 40, 30].check_range(1..4);\n-    /// ```\n-    ///\n-    /// ```should_panic\n-    /// #![feature(slice_check_range)]\n-    ///\n-    /// [10, 40, 30].check_range(1..=usize::MAX);\n-    /// ```\n-    ///\n-    /// [`Index::index`]: crate::ops::Index::index\n-    #[track_caller]\n-    #[unstable(feature = \"slice_check_range\", issue = \"76393\")]\n-    pub fn check_range<R: RangeBounds<usize>>(&self, range: R) -> Range<usize> {\n-        let start = match range.start_bound() {\n-            Bound::Included(&start) => start,\n-            Bound::Excluded(start) => {\n-                start.checked_add(1).unwrap_or_else(|| slice_start_index_overflow_fail())\n-            }\n-            Bound::Unbounded => 0,\n-        };\n-\n-        let len = self.len();\n-        let end = match range.end_bound() {\n-            Bound::Included(end) => {\n-                end.checked_add(1).unwrap_or_else(|| slice_end_index_overflow_fail())\n-            }\n-            Bound::Excluded(&end) => end,\n-            Bound::Unbounded => len,\n-        };\n-\n-        if start > end {\n-            slice_index_order_fail(start, end);\n-        }\n-        if end > len {\n-            slice_end_index_len_fail(end, len);\n-        }\n-\n-        Range { start, end }\n-    }\n-\n     /// Returns a raw pointer to the slice's buffer.\n     ///\n     /// The caller must ensure that the slice outlives the pointer this\n@@ -2794,7 +2721,7 @@ impl<T> [T] {\n     where\n         T: Copy,\n     {\n-        let Range { start: src_start, end: src_end } = self.check_range(src);\n+        let Range { start: src_start, end: src_end } = check_range(self.len(), src);\n         let count = src_end - src_start;\n         assert!(dest <= self.len() - count, \"dest is out of bounds\");\n         // SAFETY: the conditions for `ptr::copy` have all been checked above,"}]}