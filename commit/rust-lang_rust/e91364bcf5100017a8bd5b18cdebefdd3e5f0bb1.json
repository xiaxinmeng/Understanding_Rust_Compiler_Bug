{"sha": "e91364bcf5100017a8bd5b18cdebefdd3e5f0bb1", "node_id": "C_kwDOAAsO6NoAKGU5MTM2NGJjZjUxMDAwMTdhOGJkNWIxOGNkZWJlZmRkM2U1ZjBiYjE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-20T06:13:10Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-20T06:13:10Z"}, "message": "Auto merge of #109376 - matthiaskrgr:rollup-0aut57k, r=matthiaskrgr\n\nRollup of 13 pull requests\n\nSuccessful merges:\n\n - #109249 (Update names/comments for new return-position impl trait in trait lowering strategy)\n - #109259 (rustdoc: Fix missing private inlining)\n - #109269 (rustdoc: cleanup some intermediate allocs)\n - #109301 (fix: fix ICE in `custom-test-frameworks` feature)\n - #109319 (Add test for `c_variadic` in rustdoc-json)\n - #109323 (Ignore files in .gitignore in mir opt check)\n - #109331 (rustdoc: implement bag semantics for function parameter search)\n - #109337 (Improve `Iterator::collect_into` documentation)\n - #109351 (rustdoc: Remove footnote references from doc summary)\n - #109353 (Fix wrong crate name in custom MIR docs)\n - #109362 (Split `items` from `-Zmeta-stats` in two.)\n - #109370 (fix ClashingExternDeclarations lint ICE)\n - #109375 (rustdoc: Fix improper escaping of deprecation reasons)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "bd6f8517c64a103a210a406efc1b0bfbf34d8c20", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bd6f8517c64a103a210a406efc1b0bfbf34d8c20"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e91364bcf5100017a8bd5b18cdebefdd3e5f0bb1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e91364bcf5100017a8bd5b18cdebefdd3e5f0bb1", "html_url": "https://github.com/rust-lang/rust/commit/e91364bcf5100017a8bd5b18cdebefdd3e5f0bb1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e91364bcf5100017a8bd5b18cdebefdd3e5f0bb1/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9d0eac4d02da8a1b139ff3dca7fc4b458fb99eb6", "url": "https://api.github.com/repos/rust-lang/rust/commits/9d0eac4d02da8a1b139ff3dca7fc4b458fb99eb6", "html_url": "https://github.com/rust-lang/rust/commit/9d0eac4d02da8a1b139ff3dca7fc4b458fb99eb6"}, {"sha": "130923586d109afbd0eebe87a020c2b971652962", "url": "https://api.github.com/repos/rust-lang/rust/commits/130923586d109afbd0eebe87a020c2b971652962", "html_url": "https://github.com/rust-lang/rust/commit/130923586d109afbd0eebe87a020c2b971652962"}], "stats": {"total": 562, "additions": 400, "deletions": 162}, "files": [{"sha": "151afd2d458b0484e36ea3fb4ac410c2f3e42ba9", "filename": "compiler/rustc_builtin_macros/src/test.rs", "status": "modified", "additions": 24, "deletions": 2, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e91364bcf5100017a8bd5b18cdebefdd3e5f0bb1/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e91364bcf5100017a8bd5b18cdebefdd3e5f0bb1/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest.rs?ref=e91364bcf5100017a8bd5b18cdebefdd3e5f0bb1", "patch": "@@ -33,7 +33,23 @@ pub fn expand_test_case(\n     }\n \n     let sp = ecx.with_def_site_ctxt(attr_sp);\n-    let mut item = anno_item.expect_item();\n+    let (mut item, is_stmt) = match anno_item {\n+        Annotatable::Item(item) => (item, false),\n+        Annotatable::Stmt(stmt) if let ast::StmtKind::Item(_) = stmt.kind => if let ast::StmtKind::Item(i) = stmt.into_inner().kind {\n+            (i, true)\n+        } else {\n+            unreachable!()\n+        },\n+        _ => {\n+            ecx.struct_span_err(\n+                anno_item.span(),\n+                \"`#[test_case]` attribute is only allowed on items\",\n+            )\n+            .emit();\n+\n+            return vec![];\n+        }\n+    };\n     item = item.map(|mut item| {\n         let test_path_symbol = Symbol::intern(&item_path(\n             // skip the name of the root module\n@@ -50,7 +66,13 @@ pub fn expand_test_case(\n         item\n     });\n \n-    return vec![Annotatable::Item(item)];\n+    let ret = if is_stmt {\n+        Annotatable::Stmt(P(ecx.stmt_item(item.span, item)))\n+    } else {\n+        Annotatable::Item(item)\n+    };\n+\n+    vec![ret]\n }\n \n pub fn expand_test("}, {"sha": "71b54e11cc078b59c2723644aab8cf38262f5328", "filename": "compiler/rustc_hir_analysis/src/astconv/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e91364bcf5100017a8bd5b18cdebefdd3e5f0bb1/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e91364bcf5100017a8bd5b18cdebefdd3e5f0bb1/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs?ref=e91364bcf5100017a8bd5b18cdebefdd3e5f0bb1", "patch": "@@ -3068,7 +3068,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                         // generate the def_id of an associated type for the trait and return as\n                         // type a projection.\n                         let def_id = if in_trait && tcx.lower_impl_trait_in_trait_to_assoc_ty() {\n-                            tcx.associated_item_for_impl_trait_in_trait(local_def_id).to_def_id()\n+                            tcx.associated_type_for_impl_trait_in_trait(local_def_id).to_def_id()\n                         } else {\n                             local_def_id.to_def_id()\n                         };"}, {"sha": "b1ff76865abda729882fc497c557e1a6778eb894", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/e91364bcf5100017a8bd5b18cdebefdd3e5f0bb1/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e91364bcf5100017a8bd5b18cdebefdd3e5f0bb1/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=e91364bcf5100017a8bd5b18cdebefdd3e5f0bb1", "patch": "@@ -2781,8 +2781,7 @@ impl ClashingExternDeclarations {\n \n             // Given a transparent newtype, reach through and grab the inner\n             // type unless the newtype makes the type non-null.\n-            let non_transparent_ty = |ty: Ty<'tcx>| -> Ty<'tcx> {\n-                let mut ty = ty;\n+            let non_transparent_ty = |mut ty: Ty<'tcx>| -> Ty<'tcx> {\n                 loop {\n                     if let ty::Adt(def, substs) = *ty.kind() {\n                         let is_transparent = def.repr().transparent();\n@@ -2792,14 +2791,14 @@ impl ClashingExternDeclarations {\n                             ty, is_transparent, is_non_null\n                         );\n                         if is_transparent && !is_non_null {\n-                            debug_assert!(def.variants().len() == 1);\n+                            debug_assert_eq!(def.variants().len(), 1);\n                             let v = &def.variant(VariantIdx::new(0));\n-                            ty = transparent_newtype_field(tcx, v)\n-                                .expect(\n-                                    \"single-variant transparent structure with zero-sized field\",\n-                                )\n-                                .ty(tcx, substs);\n-                            continue;\n+                            // continue with `ty`'s non-ZST field,\n+                            // otherwise `ty` is a ZST and we can return\n+                            if let Some(field) = transparent_newtype_field(tcx, v) {\n+                                ty = field.ty(tcx, substs);\n+                                continue;\n+                            }\n                         }\n                     }\n                     debug!(\"non_transparent_ty -> {:?}\", ty);\n@@ -2813,10 +2812,8 @@ impl ClashingExternDeclarations {\n             if !seen_types.insert((a, b)) {\n                 // We've encountered a cycle. There's no point going any further -- the types are\n                 // structurally the same.\n-                return true;\n-            }\n-            let tcx = cx.tcx;\n-            if a == b {\n+                true\n+            } else if a == b {\n                 // All nominally-same types are structurally same, too.\n                 true\n             } else {"}, {"sha": "561e770d90cec6ed2eec63696eace7f49c691af0", "filename": "compiler/rustc_metadata/src/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e91364bcf5100017a8bd5b18cdebefdd3e5f0bb1/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e91364bcf5100017a8bd5b18cdebefdd3e5f0bb1/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=e91364bcf5100017a8bd5b18cdebefdd3e5f0bb1", "patch": "@@ -254,7 +254,7 @@ provide! { tcx, def_id, other, cdata,\n             .process_decoded(tcx, || panic!(\"{def_id:?} does not have trait_impl_trait_tys\")))\n      }\n \n-    associated_items_for_impl_trait_in_trait => { table_defaulted_array }\n+    associated_types_for_impl_traits_in_associated_fn => { table_defaulted_array }\n \n     visibility => { cdata.get_visibility(def_id.index) }\n     adt_def => { cdata.get_adt_def(def_id.index, tcx) }"}, {"sha": "46fd0cace09a1cc928fef6d274283102b7b1796f", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e91364bcf5100017a8bd5b18cdebefdd3e5f0bb1/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e91364bcf5100017a8bd5b18cdebefdd3e5f0bb1/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=e91364bcf5100017a8bd5b18cdebefdd3e5f0bb1", "patch": "@@ -609,10 +609,9 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n         _ = stat!(\"mir\", || self.encode_mir());\n \n-        _ = stat!(\"items\", || {\n-            self.encode_def_ids();\n-            self.encode_info_for_items();\n-        });\n+        _ = stat!(\"def-ids\", || self.encode_def_ids());\n+\n+        _ = stat!(\"items\", || self.encode_info_for_items());\n \n         let interpret_alloc_index = stat!(\"interpret-alloc-index\", || {\n             let mut interpret_alloc_index = Vec::new();\n@@ -1198,8 +1197,8 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 record!(self.tables.trait_impl_trait_tys[def_id] <- table);\n             }\n             if should_encode_fn_impl_trait_in_trait(tcx, def_id) {\n-                let table = tcx.associated_items_for_impl_trait_in_trait(def_id);\n-                record_defaulted_array!(self.tables.associated_items_for_impl_trait_in_trait[def_id] <- table);\n+                let table = tcx.associated_types_for_impl_traits_in_associated_fn(def_id);\n+                record_defaulted_array!(self.tables.associated_types_for_impl_traits_in_associated_fn[def_id] <- table);\n             }\n         }\n "}, {"sha": "6dc6041b284ea3898f6517eb755becde21265fe0", "filename": "compiler/rustc_metadata/src/rmeta/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e91364bcf5100017a8bd5b18cdebefdd3e5f0bb1/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e91364bcf5100017a8bd5b18cdebefdd3e5f0bb1/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs?ref=e91364bcf5100017a8bd5b18cdebefdd3e5f0bb1", "patch": "@@ -354,7 +354,7 @@ define_tables! {\n     explicit_item_bounds: Table<DefIndex, LazyArray<(ty::Predicate<'static>, Span)>>,\n     inferred_outlives_of: Table<DefIndex, LazyArray<(ty::Clause<'static>, Span)>>,\n     inherent_impls: Table<DefIndex, LazyArray<DefIndex>>,\n-    associated_items_for_impl_trait_in_trait: Table<DefIndex, LazyArray<DefId>>,\n+    associated_types_for_impl_traits_in_associated_fn: Table<DefIndex, LazyArray<DefId>>,\n     opt_rpitit_info: Table<DefIndex, Option<LazyValue<ty::ImplTraitInTraitData>>>,\n     unused_generic_params: Table<DefIndex, UnusedGenericParams>,\n "}, {"sha": "4bf81c97d06adba414bae577be37afbc61472294", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e91364bcf5100017a8bd5b18cdebefdd3e5f0bb1/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e91364bcf5100017a8bd5b18cdebefdd3e5f0bb1/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=e91364bcf5100017a8bd5b18cdebefdd3e5f0bb1", "patch": "@@ -785,15 +785,15 @@ rustc_queries! {\n     /// if `fn_def_id` is the def id of a function defined inside an impl that implements a trait, then it\n     /// creates and returns the associated items that correspond to each impl trait in return position\n     /// of the implemented trait.\n-    query associated_items_for_impl_trait_in_trait(fn_def_id: DefId) -> &'tcx [DefId] {\n+    query associated_types_for_impl_traits_in_associated_fn(fn_def_id: DefId) -> &'tcx [DefId] {\n         desc { |tcx| \"creating associated items for impl trait in trait returned by `{}`\", tcx.def_path_str(fn_def_id) }\n         cache_on_disk_if { fn_def_id.is_local() }\n         separate_provide_extern\n     }\n \n     /// Given an impl trait in trait `opaque_ty_def_id`, create and return the corresponding\n     /// associated item.\n-    query associated_item_for_impl_trait_in_trait(opaque_ty_def_id: LocalDefId) -> LocalDefId {\n+    query associated_type_for_impl_trait_in_trait(opaque_ty_def_id: LocalDefId) -> LocalDefId {\n         desc { |tcx| \"creates the associated item corresponding to the opaque type `{}`\", tcx.def_path_str(opaque_ty_def_id.to_def_id()) }\n         cache_on_disk_if { true }\n         separate_provide_extern"}, {"sha": "298b2c3073cd399a1fa0bbf7293058b227e024d1", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e91364bcf5100017a8bd5b18cdebefdd3e5f0bb1/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e91364bcf5100017a8bd5b18cdebefdd3e5f0bb1/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=e91364bcf5100017a8bd5b18cdebefdd3e5f0bb1", "patch": "@@ -2579,7 +2579,9 @@ impl<'tcx> TyCtxt<'tcx> {\n         let Some(trait_item_def_id) = item.trait_item_def_id else { return false; };\n \n         if self.lower_impl_trait_in_trait_to_assoc_ty() {\n-            return !self.associated_items_for_impl_trait_in_trait(trait_item_def_id).is_empty();\n+            return !self\n+                .associated_types_for_impl_traits_in_associated_fn(trait_item_def_id)\n+                .is_empty();\n         }\n \n         // FIXME(RPITIT): This does a somewhat manual walk through the signature"}, {"sha": "b5bd6a81ff8b012a5b2a821bf424548ebd7ac38e", "filename": "compiler/rustc_ty_utils/src/assoc.rs", "status": "modified", "additions": 37, "deletions": 24, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/e91364bcf5100017a8bd5b18cdebefdd3e5f0bb1/compiler%2Frustc_ty_utils%2Fsrc%2Fassoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e91364bcf5100017a8bd5b18cdebefdd3e5f0bb1/compiler%2Frustc_ty_utils%2Fsrc%2Fassoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fassoc.rs?ref=e91364bcf5100017a8bd5b18cdebefdd3e5f0bb1", "patch": "@@ -11,8 +11,8 @@ pub fn provide(providers: &mut ty::query::Providers) {\n         associated_item,\n         associated_item_def_ids,\n         associated_items,\n-        associated_items_for_impl_trait_in_trait,\n-        associated_item_for_impl_trait_in_trait,\n+        associated_types_for_impl_traits_in_associated_fn,\n+        associated_type_for_impl_trait_in_trait,\n         impl_item_implementor_ids,\n         ..*providers\n     };\n@@ -24,7 +24,7 @@ fn associated_item_def_ids(tcx: TyCtxt<'_>, def_id: DefId) -> &[DefId] {\n         hir::ItemKind::Trait(.., ref trait_item_refs) => {\n             if tcx.lower_impl_trait_in_trait_to_assoc_ty() {\n                 // We collect RPITITs for each trait method's return type and create a\n-                // corresponding associated item using associated_items_for_impl_trait_in_trait\n+                // corresponding associated item using associated_types_for_impl_traits_in_associated_fn\n                 // query.\n                 tcx.arena.alloc_from_iter(\n                     trait_item_refs\n@@ -39,7 +39,9 @@ fn associated_item_def_ids(tcx: TyCtxt<'_>, def_id: DefId) -> &[DefId] {\n                                 .flat_map(|trait_item_ref| {\n                                     let trait_fn_def_id =\n                                         trait_item_ref.id.owner_id.def_id.to_def_id();\n-                                    tcx.associated_items_for_impl_trait_in_trait(trait_fn_def_id)\n+                                    tcx.associated_types_for_impl_traits_in_associated_fn(\n+                                        trait_fn_def_id,\n+                                    )\n                                 })\n                                 .map(|def_id| *def_id),\n                         ),\n@@ -56,7 +58,7 @@ fn associated_item_def_ids(tcx: TyCtxt<'_>, def_id: DefId) -> &[DefId] {\n             if tcx.lower_impl_trait_in_trait_to_assoc_ty() {\n                 // We collect RPITITs for each trait method's return type, on the impl side too and\n                 // create a corresponding associated item using\n-                // associated_items_for_impl_trait_in_trait query.\n+                // associated_types_for_impl_traits_in_associated_fn query.\n                 tcx.arena.alloc_from_iter(\n                     impl_\n                         .items\n@@ -72,7 +74,9 @@ fn associated_item_def_ids(tcx: TyCtxt<'_>, def_id: DefId) -> &[DefId] {\n                                 .flat_map(|impl_item_ref| {\n                                     let impl_fn_def_id =\n                                         impl_item_ref.id.owner_id.def_id.to_def_id();\n-                                    tcx.associated_items_for_impl_trait_in_trait(impl_fn_def_id)\n+                                    tcx.associated_types_for_impl_traits_in_associated_fn(\n+                                        impl_fn_def_id,\n+                                    )\n                                 })\n                                 .map(|def_id| *def_id)\n                         })),\n@@ -176,13 +180,19 @@ fn associated_item_from_impl_item_ref(impl_item_ref: &hir::ImplItemRef) -> ty::A\n     }\n }\n \n-/// Given an `fn_def_id` of a trait or of an impl that implements a given trait:\n-/// if `fn_def_id` is the def id of a function defined inside a trait, then it creates and returns\n-/// the associated items that correspond to each impl trait in return position for that trait.\n-/// if `fn_def_id` is the def id of a function defined inside an impl that implements a trait, then it\n-/// creates and returns the associated items that correspond to each impl trait in return position\n-/// of the implemented trait.\n-fn associated_items_for_impl_trait_in_trait(tcx: TyCtxt<'_>, fn_def_id: DefId) -> &'_ [DefId] {\n+/// Given an `fn_def_id` of a trait or a trait implementation:\n+///\n+/// if `fn_def_id` is a function defined inside a trait, then it synthesizes\n+/// a new def id corresponding to a new associated type for each return-\n+/// position `impl Trait` in the signature.\n+///\n+/// if `fn_def_id` is a function inside of an impl, then for each synthetic\n+/// associated type generated for the corresponding trait function described\n+/// above, synthesize a corresponding associated type in the impl.\n+fn associated_types_for_impl_traits_in_associated_fn(\n+    tcx: TyCtxt<'_>,\n+    fn_def_id: DefId,\n+) -> &'_ [DefId] {\n     let parent_def_id = tcx.parent(fn_def_id);\n \n     match tcx.def_kind(parent_def_id) {\n@@ -206,7 +216,7 @@ fn associated_items_for_impl_trait_in_trait(tcx: TyCtxt<'_>, fn_def_id: DefId) -\n                 visitor.visit_fn_ret_ty(output);\n \n                 tcx.arena.alloc_from_iter(visitor.rpits.iter().map(|opaque_ty_def_id| {\n-                    tcx.associated_item_for_impl_trait_in_trait(opaque_ty_def_id).to_def_id()\n+                    tcx.associated_type_for_impl_trait_in_trait(opaque_ty_def_id).to_def_id()\n                 }))\n             } else {\n                 &[]\n@@ -217,9 +227,9 @@ fn associated_items_for_impl_trait_in_trait(tcx: TyCtxt<'_>, fn_def_id: DefId) -\n             let Some(trait_fn_def_id) = tcx.associated_item(fn_def_id).trait_item_def_id else { return &[] };\n \n             tcx.arena.alloc_from_iter(\n-                tcx.associated_items_for_impl_trait_in_trait(trait_fn_def_id).iter().map(\n+                tcx.associated_types_for_impl_traits_in_associated_fn(trait_fn_def_id).iter().map(\n                     move |trait_assoc_def_id| {\n-                        impl_associated_item_for_impl_trait_in_trait(\n+                        associated_type_for_impl_trait_in_impl(\n                             tcx,\n                             trait_assoc_def_id.expect_local(),\n                             fn_def_id.expect_local(),\n@@ -231,16 +241,17 @@ fn associated_items_for_impl_trait_in_trait(tcx: TyCtxt<'_>, fn_def_id: DefId) -\n         }\n \n         def_kind => bug!(\n-            \"associated_items_for_impl_trait_in_trait: {:?} should be Trait or Impl but is {:?}\",\n+            \"associated_types_for_impl_traits_in_associated_fn: {:?} should be Trait or Impl but is {:?}\",\n             parent_def_id,\n             def_kind\n         ),\n     }\n }\n \n-/// Given an `opaque_ty_def_id` corresponding to an impl trait in trait, create and return the\n-/// corresponding associated item.\n-fn associated_item_for_impl_trait_in_trait(\n+/// Given an `opaque_ty_def_id` corresponding to an `impl Trait` in an associated\n+/// function from a trait, synthesize an associated type for that `impl Trait`\n+/// that inherits properties that we infer from the method and the opaque type.\n+fn associated_type_for_impl_trait_in_trait(\n     tcx: TyCtxt<'_>,\n     opaque_ty_def_id: LocalDefId,\n ) -> LocalDefId {\n@@ -335,10 +346,12 @@ fn associated_item_for_impl_trait_in_trait(\n     local_def_id\n }\n \n-/// Given an `trait_assoc_def_id` that corresponds to a previously synthesized impl trait in trait\n-/// into an associated type and an `impl_def_id` corresponding to an impl block, create and return\n-/// the corresponding associated item inside the impl block.\n-fn impl_associated_item_for_impl_trait_in_trait(\n+/// Given an `trait_assoc_def_id` corresponding to an associated item synthesized\n+/// from an `impl Trait` in an associated function from a trait, and an\n+/// `impl_fn_def_id` that represents an implementation of the associated function\n+/// that the `impl Trait` comes from, synthesize an associated type for that `impl Trait`\n+/// that inherits properties that we infer from the method and the associated type.\n+fn associated_type_for_impl_trait_in_impl(\n     tcx: TyCtxt<'_>,\n     trait_assoc_def_id: LocalDefId,\n     impl_fn_def_id: LocalDefId,"}, {"sha": "64fc1c0c2774171f976bd595c224bcf5e96c6da1", "filename": "library/core/src/intrinsics/mir.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e91364bcf5100017a8bd5b18cdebefdd3e5f0bb1/library%2Fcore%2Fsrc%2Fintrinsics%2Fmir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e91364bcf5100017a8bd5b18cdebefdd3e5f0bb1/library%2Fcore%2Fsrc%2Fintrinsics%2Fmir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fintrinsics%2Fmir.rs?ref=e91364bcf5100017a8bd5b18cdebefdd3e5f0bb1", "patch": "@@ -8,7 +8,7 @@\n //!\n //! The documentation for this module describes how to use this feature. If you are interested in\n //! hacking on the implementation, most of that documentation lives at\n-//! `rustc_mir_building/src/build/custom/mod.rs`.\n+//! `rustc_mir_build/src/build/custom/mod.rs`.\n //!\n //! Typical usage will look like this:\n //!"}, {"sha": "6c3030336c6b893d0cf526a784e5956107905bc1", "filename": "library/core/src/iter/traits/iterator.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e91364bcf5100017a8bd5b18cdebefdd3e5f0bb1/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e91364bcf5100017a8bd5b18cdebefdd3e5f0bb1/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs?ref=e91364bcf5100017a8bd5b18cdebefdd3e5f0bb1", "patch": "@@ -2003,7 +2003,7 @@ pub trait Iterator {\n     /// a.iter().map(|&x| x * 2).collect_into(&mut vec);\n     /// a.iter().map(|&x| x * 10).collect_into(&mut vec);\n     ///\n-    /// assert_eq!(vec![0, 1, 2, 4, 6, 10, 20, 30], vec);\n+    /// assert_eq!(vec, vec![0, 1, 2, 4, 6, 10, 20, 30]);\n     /// ```\n     ///\n     /// `Vec` can have a manual set capacity to avoid reallocating it:\n@@ -2018,7 +2018,7 @@ pub trait Iterator {\n     /// a.iter().map(|&x| x * 10).collect_into(&mut vec);\n     ///\n     /// assert_eq!(6, vec.capacity());\n-    /// println!(\"{:?}\", vec);\n+    /// assert_eq!(vec, vec![2, 4, 6, 10, 20, 30]);\n     /// ```\n     ///\n     /// The returned mutable reference can be used to continue the call chain:\n@@ -2032,12 +2032,12 @@ pub trait Iterator {\n     /// let count = a.iter().collect_into(&mut vec).iter().count();\n     ///\n     /// assert_eq!(count, vec.len());\n-    /// println!(\"Vec len is {}\", count);\n+    /// assert_eq!(vec, vec![1, 2, 3]);\n     ///\n     /// let count = a.iter().collect_into(&mut vec).iter().count();\n     ///\n     /// assert_eq!(count, vec.len());\n-    /// println!(\"Vec len now is {}\", count);\n+    /// assert_eq!(vec, vec![1, 2, 3, 1, 2, 3]);\n     /// ```\n     #[inline]\n     #[unstable(feature = \"iter_collect_into\", reason = \"new API\", issue = \"94780\")]"}, {"sha": "f2b9c0bcf3ee7785f53e166f668360dd2c845c85", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e91364bcf5100017a8bd5b18cdebefdd3e5f0bb1/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e91364bcf5100017a8bd5b18cdebefdd3e5f0bb1/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=e91364bcf5100017a8bd5b18cdebefdd3e5f0bb1", "patch": "@@ -1480,7 +1480,7 @@ pub(crate) fn visibility_print_with_space<'a, 'tcx: 'a>(\n                 debug!(\"path={:?}\", path);\n                 // modified from `resolved_path()` to work with `DefPathData`\n                 let last_name = path.data.last().unwrap().data.get_opt_name().unwrap();\n-                let anchor = anchor(vis_did, last_name, cx).to_string();\n+                let anchor = anchor(vis_did, last_name, cx);\n \n                 let mut s = \"pub(in \".to_owned();\n                 for seg in &path.data[..path.data.len() - 1] {"}, {"sha": "fd81a21f5a99453bf4268509cb22d59cf6ff341f", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e91364bcf5100017a8bd5b18cdebefdd3e5f0bb1/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e91364bcf5100017a8bd5b18cdebefdd3e5f0bb1/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=e91364bcf5100017a8bd5b18cdebefdd3e5f0bb1", "patch": "@@ -556,7 +556,15 @@ fn check_if_allowed_tag(t: &Tag<'_>) -> bool {\n }\n \n fn is_forbidden_tag(t: &Tag<'_>) -> bool {\n-    matches!(t, Tag::CodeBlock(_) | Tag::Table(_) | Tag::TableHead | Tag::TableRow | Tag::TableCell)\n+    matches!(\n+        t,\n+        Tag::CodeBlock(_)\n+            | Tag::Table(_)\n+            | Tag::TableHead\n+            | Tag::TableRow\n+            | Tag::TableCell\n+            | Tag::FootnoteDefinition(_)\n+    )\n }\n \n impl<'a, I: Iterator<Item = Event<'a>>> Iterator for SummaryLine<'a, I> {\n@@ -589,6 +597,10 @@ impl<'a, I: Iterator<Item = Event<'a>>> Iterator for SummaryLine<'a, I> {\n                     is_start = false;\n                     check_if_allowed_tag(c)\n                 }\n+                Event::FootnoteReference(_) => {\n+                    self.skipped_tags += 1;\n+                    false\n+                }\n                 _ => true,\n             };\n             if !is_allowed_tag {"}, {"sha": "ac5054ce1b6b520bc01f2c031265d5d542d11df5", "filename": "src/librustdoc/html/render/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e91364bcf5100017a8bd5b18cdebefdd3e5f0bb1/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e91364bcf5100017a8bd5b18cdebefdd3e5f0bb1/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs?ref=e91364bcf5100017a8bd5b18cdebefdd3e5f0bb1", "patch": "@@ -352,7 +352,7 @@ impl<'tcx> Context<'tcx> {\n                 },\n             );\n \n-            path = href.into_inner().to_string_lossy().to_string();\n+            path = href.into_inner().to_string_lossy().into_owned();\n \n             if let Some(c) = path.as_bytes().last() && *c != b'/' {\n                 path.push('/');"}, {"sha": "7eb9c0b7cf52af0f8ff782d6f26e15ab05ddabd0", "filename": "src/librustdoc/html/render/print_item.rs", "status": "modified", "additions": 56, "deletions": 35, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/e91364bcf5100017a8bd5b18cdebefdd3e5f0bb1/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e91364bcf5100017a8bd5b18cdebefdd3e5f0bb1/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs?ref=e91364bcf5100017a8bd5b18cdebefdd3e5f0bb1", "patch": "@@ -1,5 +1,6 @@\n use clean::AttributesExt;\n \n+use rustc_data_structures::captures::Captures;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_hir as hir;\n use rustc_hir::def::CtorKind;\n@@ -28,8 +29,8 @@ use crate::formats::item_type::ItemType;\n use crate::formats::{AssocItemRender, Impl, RenderMode};\n use crate::html::escape::Escape;\n use crate::html::format::{\n-    join_with_double_colon, print_abi_with_space, print_constness_with_space, print_where_clause,\n-    visibility_print_with_space, Buffer, Ending, PrintWithSpace,\n+    display_fn, join_with_double_colon, print_abi_with_space, print_constness_with_space,\n+    print_where_clause, visibility_print_with_space, Buffer, Ending, PrintWithSpace,\n };\n use crate::html::layout::Page;\n use crate::html::markdown::{HeadingOffset, MarkdownSummaryLine};\n@@ -367,7 +368,7 @@ fn item_module(w: &mut Buffer, cx: &mut Context<'_>, item: &clean::Item, items:\n                         ..myitem.clone()\n                     };\n \n-                    let stab_tags = Some(extra_info_tags(&import_item, item, cx.tcx()));\n+                    let stab_tags = Some(extra_info_tags(&import_item, item, cx.tcx()).to_string());\n                     stab_tags\n                 } else {\n                     None\n@@ -461,42 +462,62 @@ fn item_module(w: &mut Buffer, cx: &mut Context<'_>, item: &clean::Item, items:\n \n /// Render the stability, deprecation and portability tags that are displayed in the item's summary\n /// at the module level.\n-fn extra_info_tags(item: &clean::Item, parent: &clean::Item, tcx: TyCtxt<'_>) -> String {\n-    let mut tags = String::new();\n-\n-    fn tag_html(class: &str, title: &str, contents: &str) -> String {\n-        format!(r#\"<span class=\"stab {}\" title=\"{}\">{}</span>\"#, class, Escape(title), contents)\n-    }\n-\n-    // The trailing space after each tag is to space it properly against the rest of the docs.\n-    if let Some(depr) = &item.deprecation(tcx) {\n-        let message = if stability::deprecation_in_effect(depr) {\n-            \"Deprecated\"\n-        } else {\n-            \"Deprecation planned\"\n-        };\n-        tags += &tag_html(\"deprecated\", \"\", message);\n-    }\n+fn extra_info_tags<'a, 'tcx: 'a>(\n+    item: &'a clean::Item,\n+    parent: &'a clean::Item,\n+    tcx: TyCtxt<'tcx>,\n+) -> impl fmt::Display + 'a + Captures<'tcx> {\n+    display_fn(move |f| {\n+        fn tag_html<'a>(\n+            class: &'a str,\n+            title: &'a str,\n+            contents: &'a str,\n+        ) -> impl fmt::Display + 'a {\n+            display_fn(move |f| {\n+                write!(\n+                    f,\n+                    r#\"<span class=\"stab {}\" title=\"{}\">{}</span>\"#,\n+                    class,\n+                    Escape(title),\n+                    contents\n+                )\n+            })\n+        }\n \n-    // The \"rustc_private\" crates are permanently unstable so it makes no sense\n-    // to render \"unstable\" everywhere.\n-    if item.stability(tcx).as_ref().map(|s| s.is_unstable() && s.feature != sym::rustc_private)\n-        == Some(true)\n-    {\n-        tags += &tag_html(\"unstable\", \"\", \"Experimental\");\n-    }\n+        // The trailing space after each tag is to space it properly against the rest of the docs.\n+        if let Some(depr) = &item.deprecation(tcx) {\n+            let message = if stability::deprecation_in_effect(depr) {\n+                \"Deprecated\"\n+            } else {\n+                \"Deprecation planned\"\n+            };\n+            write!(f, \"{}\", tag_html(\"deprecated\", \"\", message))?;\n+        }\n \n-    let cfg = match (&item.cfg, parent.cfg.as_ref()) {\n-        (Some(cfg), Some(parent_cfg)) => cfg.simplify_with(parent_cfg),\n-        (cfg, _) => cfg.as_deref().cloned(),\n-    };\n+        // The \"rustc_private\" crates are permanently unstable so it makes no sense\n+        // to render \"unstable\" everywhere.\n+        if item.stability(tcx).as_ref().map(|s| s.is_unstable() && s.feature != sym::rustc_private)\n+            == Some(true)\n+        {\n+            write!(f, \"{}\", tag_html(\"unstable\", \"\", \"Experimental\"))?;\n+        }\n \n-    debug!(\"Portability name={:?} {:?} - {:?} = {:?}\", item.name, item.cfg, parent.cfg, cfg);\n-    if let Some(ref cfg) = cfg {\n-        tags += &tag_html(\"portability\", &cfg.render_long_plain(), &cfg.render_short_html());\n-    }\n+        let cfg = match (&item.cfg, parent.cfg.as_ref()) {\n+            (Some(cfg), Some(parent_cfg)) => cfg.simplify_with(parent_cfg),\n+            (cfg, _) => cfg.as_deref().cloned(),\n+        };\n \n-    tags\n+        debug!(\"Portability name={:?} {:?} - {:?} = {:?}\", item.name, item.cfg, parent.cfg, cfg);\n+        if let Some(ref cfg) = cfg {\n+            write!(\n+                f,\n+                \"{}\",\n+                tag_html(\"portability\", &cfg.render_long_plain(), &cfg.render_short_html())\n+            )\n+        } else {\n+            Ok(())\n+        }\n+    })\n }\n \n fn item_function(w: &mut Buffer, cx: &mut Context<'_>, it: &clean::Item, f: &clean::Function) {"}, {"sha": "be9d1c408eca6173aec745c0cabef427524c6804", "filename": "src/librustdoc/html/sources.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e91364bcf5100017a8bd5b18cdebefdd3e5f0bb1/src%2Flibrustdoc%2Fhtml%2Fsources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e91364bcf5100017a8bd5b18cdebefdd3e5f0bb1/src%2Flibrustdoc%2Fhtml%2Fsources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fsources.rs?ref=e91364bcf5100017a8bd5b18cdebefdd3e5f0bb1", "patch": "@@ -85,7 +85,7 @@ impl LocalSourcesCollector<'_, '_> {\n             },\n         );\n \n-        let mut href = href.into_inner().to_string_lossy().to_string();\n+        let mut href = href.into_inner().to_string_lossy().into_owned();\n         if let Some(c) = href.as_bytes().last() && *c != b'/' {\n             href.push('/');\n         }"}, {"sha": "36ff20e299e1ef5a628ace561b3e3788151695a9", "filename": "src/librustdoc/html/static/js/search.js", "status": "modified", "additions": 70, "deletions": 26, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/e91364bcf5100017a8bd5b18cdebefdd3e5f0bb1/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsearch.js", "raw_url": "https://github.com/rust-lang/rust/raw/e91364bcf5100017a8bd5b18cdebefdd3e5f0bb1/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsearch.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsearch.js?ref=e91364bcf5100017a8bd5b18cdebefdd3e5f0bb1", "patch": "@@ -1202,28 +1202,42 @@ function initSearch(rawSearchIndex) {\n          * @param {Row} row\n          * @param {QueryElement} elem    - The element from the parsed query.\n          * @param {integer} typeFilter\n+         * @param {Array<integer>} skipPositions - Do not return one of these positions.\n          *\n-         * @return {integer} - Returns an edit distance to the best match. If there is no\n-         *                      match, returns `maxEditDistance + 1`.\n+         * @return {dist: integer, position: integer} - Returns an edit distance to the best match.\n+         *                                              If there is no match, returns\n+         *                                              `maxEditDistance + 1` and position: -1.\n          */\n-        function findArg(row, elem, typeFilter, maxEditDistance) {\n+        function findArg(row, elem, typeFilter, maxEditDistance, skipPositions) {\n             let dist = maxEditDistance + 1;\n+            let position = -1;\n \n             if (row && row.type && row.type.inputs && row.type.inputs.length > 0) {\n+                let i = 0;\n                 for (const input of row.type.inputs) {\n-                    if (!typePassesFilter(typeFilter, input.ty)) {\n+                    if (!typePassesFilter(typeFilter, input.ty) ||\n+                        skipPositions.indexOf(i) !== -1) {\n+                        i += 1;\n                         continue;\n                     }\n-                    dist = Math.min(\n-                        dist,\n-                        checkType(input, elem, parsedQuery.literalSearch, maxEditDistance)\n+                    const typeDist = checkType(\n+                        input,\n+                        elem,\n+                        parsedQuery.literalSearch,\n+                        maxEditDistance\n                     );\n-                    if (dist === 0) {\n-                        return 0;\n+                    if (typeDist === 0) {\n+                        return {dist: 0, position: i};\n+                    }\n+                    if (typeDist < dist) {\n+                        dist = typeDist;\n+                        position = i;\n                     }\n+                    i += 1;\n                 }\n             }\n-            return parsedQuery.literalSearch ? maxEditDistance + 1 : dist;\n+            dist = parsedQuery.literalSearch ? maxEditDistance + 1 : dist;\n+            return {dist, position};\n         }\n \n         /**\n@@ -1232,29 +1246,43 @@ function initSearch(rawSearchIndex) {\n          * @param {Row} row\n          * @param {QueryElement} elem   - The element from the parsed query.\n          * @param {integer} typeFilter\n+         * @param {Array<integer>} skipPositions - Do not return one of these positions.\n          *\n-         * @return {integer} - Returns an edit distance to the best match. If there is no\n-         *                      match, returns `maxEditDistance + 1`.\n+         * @return {dist: integer, position: integer} - Returns an edit distance to the best match.\n+         *                                              If there is no match, returns\n+         *                                              `maxEditDistance + 1` and position: -1.\n          */\n-        function checkReturned(row, elem, typeFilter, maxEditDistance) {\n+        function checkReturned(row, elem, typeFilter, maxEditDistance, skipPositions) {\n             let dist = maxEditDistance + 1;\n+            let position = -1;\n \n             if (row && row.type && row.type.output.length > 0) {\n                 const ret = row.type.output;\n+                let i = 0;\n                 for (const ret_ty of ret) {\n-                    if (!typePassesFilter(typeFilter, ret_ty.ty)) {\n+                    if (!typePassesFilter(typeFilter, ret_ty.ty) ||\n+                        skipPositions.indexOf(i) !== -1) {\n+                        i += 1;\n                         continue;\n                     }\n-                    dist = Math.min(\n-                        dist,\n-                        checkType(ret_ty, elem, parsedQuery.literalSearch, maxEditDistance)\n+                    const typeDist = checkType(\n+                        ret_ty,\n+                        elem,\n+                        parsedQuery.literalSearch,\n+                        maxEditDistance\n                     );\n-                    if (dist === 0) {\n-                        return 0;\n+                    if (typeDist === 0) {\n+                        return {dist: 0, position: i};\n                     }\n+                    if (typeDist < dist) {\n+                        dist = typeDist;\n+                        position = i;\n+                    }\n+                    i += 1;\n                 }\n             }\n-            return parsedQuery.literalSearch ? maxEditDistance + 1 : dist;\n+            dist = parsedQuery.literalSearch ? maxEditDistance + 1 : dist;\n+            return {dist, position};\n         }\n \n         function checkPath(contains, ty, maxEditDistance) {\n@@ -1455,13 +1483,13 @@ function initSearch(rawSearchIndex) {\n             const fullId = row.id;\n             const searchWord = searchWords[pos];\n \n-            const in_args = findArg(row, elem, parsedQuery.typeFilter, maxEditDistance);\n-            const returned = checkReturned(row, elem, parsedQuery.typeFilter, maxEditDistance);\n+            const in_args = findArg(row, elem, parsedQuery.typeFilter, maxEditDistance, []);\n+            const returned = checkReturned(row, elem, parsedQuery.typeFilter, maxEditDistance, []);\n \n             // path_dist is 0 because no parent path information is currently stored\n             // in the search index\n-            addIntoResults(results_in_args, fullId, pos, -1, in_args, 0, maxEditDistance);\n-            addIntoResults(results_returned, fullId, pos, -1, returned, 0, maxEditDistance);\n+            addIntoResults(results_in_args, fullId, pos, -1, in_args.dist, 0, maxEditDistance);\n+            addIntoResults(results_returned, fullId, pos, -1, returned.dist, 0, maxEditDistance);\n \n             if (!typePassesFilter(parsedQuery.typeFilter, row.ty)) {\n                 return;\n@@ -1534,12 +1562,20 @@ function initSearch(rawSearchIndex) {\n \n             // If the result is too \"bad\", we return false and it ends this search.\n             function checkArgs(elems, callback) {\n+                const skipPositions = [];\n                 for (const elem of elems) {\n                     // There is more than one parameter to the query so all checks should be \"exact\"\n-                    const dist = callback(row, elem, NO_TYPE_FILTER, maxEditDistance);\n+                    const { dist, position } = callback(\n+                        row,\n+                        elem,\n+                        NO_TYPE_FILTER,\n+                        maxEditDistance,\n+                        skipPositions\n+                    );\n                     if (dist <= 1) {\n                         nbDist += 1;\n                         totalDist += dist;\n+                        skipPositions.push(position);\n                     } else {\n                         return false;\n                     }\n@@ -1597,9 +1633,17 @@ function initSearch(rawSearchIndex) {\n                             row,\n                             elem,\n                             parsedQuery.typeFilter,\n+                            maxEditDistance,\n+                            []\n+                        );\n+                        addIntoResults(\n+                            results_others,\n+                            row.id,\n+                            i,\n+                            -1,\n+                            in_returned.dist,\n                             maxEditDistance\n                         );\n-                        addIntoResults(results_others, row.id, i, -1, in_returned, maxEditDistance);\n                     }\n                 }\n             } else if (parsedQuery.foundElems > 0) {"}, {"sha": "75d155e91c203b027327ee52f325e44baf5249e3", "filename": "src/librustdoc/html/templates/short_item_info.html", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e91364bcf5100017a8bd5b18cdebefdd3e5f0bb1/src%2Flibrustdoc%2Fhtml%2Ftemplates%2Fshort_item_info.html", "raw_url": "https://github.com/rust-lang/rust/raw/e91364bcf5100017a8bd5b18cdebefdd3e5f0bb1/src%2Flibrustdoc%2Fhtml%2Ftemplates%2Fshort_item_info.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Ftemplates%2Fshort_item_info.html?ref=e91364bcf5100017a8bd5b18cdebefdd3e5f0bb1", "patch": "@@ -2,7 +2,7 @@\n     {% when Self::Deprecation with { message } %}\n         <div class=\"stab deprecated\"> {# #}\n             <span class=\"emoji\">\ud83d\udc4e</span> {# #}\n-            <span>{{message}}</span> {# #}\n+            <span>{{message|safe}}</span> {# #}\n         </div> {# #}\n     {% when Self::Unstable with { feature, tracking } %}\n         <div class=\"stab unstable\"> {# #}"}, {"sha": "6ed7b98999977664d54327fb3d91a99834a37d10", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e91364bcf5100017a8bd5b18cdebefdd3e5f0bb1/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e91364bcf5100017a8bd5b18cdebefdd3e5f0bb1/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=e91364bcf5100017a8bd5b18cdebefdd3e5f0bb1", "patch": "@@ -286,7 +286,6 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n             split.next().map(|f|  Symbol::intern(f)).ok_or_else(no_res)?;\n         let path = split\n             .next()\n-            .map(|f| f.to_owned())\n             // If there's no third component, we saw `[a::b]` before and it failed to resolve.\n             // So there's no partial res.\n             .ok_or_else(no_res)?;\n@@ -429,7 +428,6 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         let item_name = Symbol::intern(item_str);\n         let path_root = split\n             .next()\n-            .map(|f| f.to_owned())\n             // If there's no `::`, it's not an associated item.\n             // So we can be sure that `rustc_resolve` was accurate when it said it wasn't resolved.\n             .ok_or_else(|| {"}, {"sha": "060062db0027aa5cd809501e7d6db85d11a169ff", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e91364bcf5100017a8bd5b18cdebefdd3e5f0bb1/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e91364bcf5100017a8bd5b18cdebefdd3e5f0bb1/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=e91364bcf5100017a8bd5b18cdebefdd3e5f0bb1", "patch": "@@ -265,10 +265,6 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n             return false;\n         }\n \n-        if !self.view_item_stack.insert(res_did) {\n-            return false;\n-        }\n-\n         if !please_inline &&\n             let mut visitor = OneLevelVisitor::new(self.cx.tcx.hir(), res_did) &&\n             let Some(item) = visitor.find_target(self.cx.tcx, def_id.to_def_id(), path) &&\n@@ -285,6 +281,10 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n             return false;\n         }\n \n+        if !self.view_item_stack.insert(res_did) {\n+            return false;\n+        }\n+\n         let ret = match tcx.hir().get_by_def_id(res_did) {\n             Node::Item(&hir::Item { kind: hir::ItemKind::Mod(ref m), .. }) if glob => {\n                 let prev = mem::replace(&mut self.inlining, true);"}, {"sha": "b316e9e9009fcad18fee617ac01f0cc158227eb5", "filename": "src/tools/tidy/src/mir_opt_tests.rs", "status": "modified", "additions": 22, "deletions": 19, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/e91364bcf5100017a8bd5b18cdebefdd3e5f0bb1/src%2Ftools%2Ftidy%2Fsrc%2Fmir_opt_tests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e91364bcf5100017a8bd5b18cdebefdd3e5f0bb1/src%2Ftools%2Ftidy%2Fsrc%2Fmir_opt_tests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fmir_opt_tests.rs?ref=e91364bcf5100017a8bd5b18cdebefdd3e5f0bb1", "patch": "@@ -3,19 +3,24 @@\n use std::collections::HashSet;\n use std::path::{Path, PathBuf};\n \n+use crate::walk::walk_no_read;\n+\n fn check_unused_files(path: &Path, bless: bool, bad: &mut bool) {\n     let mut rs_files = Vec::<PathBuf>::new();\n     let mut output_files = HashSet::<PathBuf>::new();\n-    let files = walkdir::WalkDir::new(&path.join(\"mir-opt\")).into_iter();\n \n-    for file in files.filter_map(Result::ok).filter(|e| e.file_type().is_file()) {\n-        let filepath = file.path();\n-        if filepath.extension() == Some(\"rs\".as_ref()) {\n-            rs_files.push(filepath.to_owned());\n-        } else {\n-            output_files.insert(filepath.to_owned());\n-        }\n-    }\n+    walk_no_read(\n+        &[&path.join(\"mir-opt\")],\n+        |path| path.file_name() == Some(\"README.md\".as_ref()),\n+        &mut |file| {\n+            let filepath = file.path();\n+            if filepath.extension() == Some(\"rs\".as_ref()) {\n+                rs_files.push(filepath.to_owned());\n+            } else {\n+                output_files.insert(filepath.to_owned());\n+            }\n+        },\n+    );\n \n     for file in rs_files {\n         for bw in [32, 64] {\n@@ -26,16 +31,14 @@ fn check_unused_files(path: &Path, bless: bool, bad: &mut bool) {\n     }\n \n     for extra in output_files {\n-        if extra.file_name() != Some(\"README.md\".as_ref()) {\n-            if !bless {\n-                tidy_error!(\n-                    bad,\n-                    \"the following output file is not associated with any mir-opt test, you can remove it: {}\",\n-                    extra.display()\n-                );\n-            } else {\n-                let _ = std::fs::remove_file(extra);\n-            }\n+        if !bless {\n+            tidy_error!(\n+                bad,\n+                \"the following output file is not associated with any mir-opt test, you can remove it: {}\",\n+                extra.display()\n+            );\n+        } else {\n+            let _ = std::fs::remove_file(extra);\n         }\n     }\n }"}, {"sha": "c56a3df5f904c06312aca4393a77304bc08abb0b", "filename": "tests/rustdoc-js/search-bag-semantics.js", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e91364bcf5100017a8bd5b18cdebefdd3e5f0bb1/tests%2Frustdoc-js%2Fsearch-bag-semantics.js", "raw_url": "https://github.com/rust-lang/rust/raw/e91364bcf5100017a8bd5b18cdebefdd3e5f0bb1/tests%2Frustdoc-js%2Fsearch-bag-semantics.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-js%2Fsearch-bag-semantics.js?ref=e91364bcf5100017a8bd5b18cdebefdd3e5f0bb1", "patch": "@@ -0,0 +1,20 @@\n+// exact-check\n+\n+const QUERY = [\n+    'P',\n+    'P, P',\n+];\n+\n+const EXPECTED = [\n+    {\n+        'in_args': [\n+            { 'path': 'search_bag_semantics', 'name': 'alacazam' },\n+            { 'path': 'search_bag_semantics', 'name': 'abracadabra' },\n+        ],\n+    },\n+    {\n+        'others': [\n+            { 'path': 'search_bag_semantics', 'name': 'abracadabra' },\n+        ],\n+    },\n+];"}, {"sha": "546572dc4ef06660797ea48145cfaf8877fbc574", "filename": "tests/rustdoc-js/search-bag-semantics.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e91364bcf5100017a8bd5b18cdebefdd3e5f0bb1/tests%2Frustdoc-js%2Fsearch-bag-semantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e91364bcf5100017a8bd5b18cdebefdd3e5f0bb1/tests%2Frustdoc-js%2Fsearch-bag-semantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-js%2Fsearch-bag-semantics.rs?ref=e91364bcf5100017a8bd5b18cdebefdd3e5f0bb1", "patch": "@@ -0,0 +1,4 @@\n+pub struct P;\n+\n+pub fn abracadabra(a: P, b: P) {}\n+pub fn alacazam(a: P) {}"}, {"sha": "33bebbab5e0080810a6056db224d45c4eaf34446", "filename": "tests/rustdoc-json/fns/extern_c_variadic.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e91364bcf5100017a8bd5b18cdebefdd3e5f0bb1/tests%2Frustdoc-json%2Ffns%2Fextern_c_variadic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e91364bcf5100017a8bd5b18cdebefdd3e5f0bb1/tests%2Frustdoc-json%2Ffns%2Fextern_c_variadic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-json%2Ffns%2Fextern_c_variadic.rs?ref=e91364bcf5100017a8bd5b18cdebefdd3e5f0bb1", "patch": "@@ -0,0 +1,9 @@\n+#![feature(no_core)]\n+#![no_core]\n+\n+extern \"C\" {\n+    // @is \"$.index[*][?(@.name == 'not_variadic')].inner.decl.c_variadic\" false\n+    pub fn not_variadic(_: i32);\n+    // @is \"$.index[*][?(@.name == 'variadic')].inner.decl.c_variadic\" true\n+    pub fn variadic(_: i32, ...);\n+}"}, {"sha": "9c9c0945b8fd94500f180193514b0bbe452f3d6e", "filename": "tests/rustdoc/deprecated.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e91364bcf5100017a8bd5b18cdebefdd3e5f0bb1/tests%2Frustdoc%2Fdeprecated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e91364bcf5100017a8bd5b18cdebefdd3e5f0bb1/tests%2Frustdoc%2Fdeprecated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fdeprecated.rs?ref=e91364bcf5100017a8bd5b18cdebefdd3e5f0bb1", "patch": "@@ -28,6 +28,6 @@ pub struct V;\n pub struct W;\n \n // @matches deprecated/struct.X.html '//*[@class=\"stab deprecated\"]' \\\n-//      'Deprecated: shorthand reason$'\n-#[deprecated = \"shorthand reason\"]\n+//      'Deprecated: shorthand reason: code$'\n+#[deprecated = \"shorthand reason: `code`\"]\n pub struct X;"}, {"sha": "e6ff5a7fd51dcb901366c10a33381c3ed282bf60", "filename": "tests/rustdoc/footnote-in-summary.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e91364bcf5100017a8bd5b18cdebefdd3e5f0bb1/tests%2Frustdoc%2Ffootnote-in-summary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e91364bcf5100017a8bd5b18cdebefdd3e5f0bb1/tests%2Frustdoc%2Ffootnote-in-summary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Ffootnote-in-summary.rs?ref=e91364bcf5100017a8bd5b18cdebefdd3e5f0bb1", "patch": "@@ -0,0 +1,17 @@\n+// This test ensures that no footnote reference is generated inside\n+// summary doc.\n+\n+#![crate_name = \"foo\"]\n+\n+// @has 'foo/index.html'\n+// @has - '//*[@class=\"desc docblock-short\"]' 'hello bla'\n+// @!has - '//*[@class=\"desc docblock-short\"]/sup' '1'\n+\n+// @has 'foo/struct.S.html'\n+// @has - '//*[@class=\"docblock\"]//sup' '1'\n+// @has - '//*[@class=\"docblock\"]' 'hello 1 bla'\n+\n+/// hello [^foot] bla\n+///\n+/// [^foot]: blabla\n+pub struct S;"}, {"sha": "96f606368b27db0c435d51221b10356d903c88d3", "filename": "tests/rustdoc/issue-109258-missing-private-inlining.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/e91364bcf5100017a8bd5b18cdebefdd3e5f0bb1/tests%2Frustdoc%2Fissue-109258-missing-private-inlining.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e91364bcf5100017a8bd5b18cdebefdd3e5f0bb1/tests%2Frustdoc%2Fissue-109258-missing-private-inlining.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fissue-109258-missing-private-inlining.rs?ref=e91364bcf5100017a8bd5b18cdebefdd3e5f0bb1", "patch": "@@ -0,0 +1,27 @@\n+// Regression test for <https://github.com/rust-lang/rust/issues/109258>.\n+\n+#![crate_name = \"foo\"]\n+\n+// @has 'foo/index.html'\n+// We should only have a \"Re-exports\" and a \"Modules\" headers.\n+// @count - '//*[@id=\"main-content\"]/h2[@class=\"small-section-header\"]' 2\n+// @has - '//*[@id=\"main-content\"]/h2[@class=\"small-section-header\"]' 'Re-exports'\n+// @has - '//*[@id=\"main-content\"]/h2[@class=\"small-section-header\"]' 'Modules'\n+\n+// @has - '//*[@id=\"reexport.Foo\"]' 'pub use crate::issue_109258::Foo;'\n+// @has - '//*[@id=\"reexport.Foo\"]//a[@href=\"issue_109258/struct.Foo.html\"]' 'Foo'\n+// @!has 'foo/struct.Foo.html'\n+pub use crate::issue_109258::Foo;\n+\n+// @has 'foo/issue_109258/index.html'\n+// We should only have a \"Structs\" header.\n+// @count - '//*[@id=\"main-content\"]/h2[@class=\"small-section-header\"]' 1\n+// @has - '//*[@id=\"main-content\"]/h2[@class=\"small-section-header\"]' 'Structs'\n+// @has - '//*[@id=\"main-content\"]//a[@href=\"struct.Foo.html\"]' 'Foo'\n+// @has 'foo/issue_109258/struct.Foo.html'\n+pub mod issue_109258 {\n+    mod priv_mod {\n+        pub struct Foo;\n+    }\n+    pub use self::priv_mod::Foo;\n+}"}, {"sha": "09fda33dbec5c1c51aee99c2dd1bca45494d78ed", "filename": "tests/ui/lint/clashing-extern-fn.rs", "status": "modified", "additions": 29, "deletions": 4, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/e91364bcf5100017a8bd5b18cdebefdd3e5f0bb1/tests%2Fui%2Flint%2Fclashing-extern-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e91364bcf5100017a8bd5b18cdebefdd3e5f0bb1/tests%2Fui%2Flint%2Fclashing-extern-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flint%2Fclashing-extern-fn.rs?ref=e91364bcf5100017a8bd5b18cdebefdd3e5f0bb1", "patch": "@@ -122,8 +122,8 @@ mod banana {\n             weight: u32,\n             length: u16,\n         } // note: distinct type\n-          // This should not trigger the lint because two::Banana is structurally equivalent to\n-          // one::Banana.\n+        // This should not trigger the lint because two::Banana is structurally equivalent to\n+        // one::Banana.\n         extern \"C\" {\n             fn weigh_banana(count: *const Banana) -> u64;\n         }\n@@ -223,6 +223,27 @@ mod transparent {\n     }\n }\n \n+#[allow(improper_ctypes)]\n+mod zst {\n+    mod transparent {\n+        #[repr(transparent)]\n+        struct TransparentZst(());\n+        extern \"C\" {\n+            fn zst() -> ();\n+            fn transparent_zst() -> TransparentZst;\n+        }\n+    }\n+\n+    mod not_transparent {\n+        struct NotTransparentZst(());\n+        extern \"C\" {\n+            // These shouldn't warn since all return types are zero sized\n+            fn zst() -> NotTransparentZst;\n+            fn transparent_zst() -> NotTransparentZst;\n+        }\n+    }\n+}\n+\n mod missing_return_type {\n     mod a {\n         extern \"C\" {\n@@ -397,10 +418,14 @@ mod hidden_niche {\n         use std::num::NonZeroUsize;\n \n         #[repr(transparent)]\n-        struct Transparent { x: NonZeroUsize }\n+        struct Transparent {\n+            x: NonZeroUsize,\n+        }\n \n         #[repr(transparent)]\n-        struct TransparentNoNiche { y: UnsafeCell<NonZeroUsize> }\n+        struct TransparentNoNiche {\n+            y: UnsafeCell<NonZeroUsize>,\n+        }\n \n         extern \"C\" {\n             fn hidden_niche_transparent() -> Option<Transparent>;"}, {"sha": "5d457ba0ec7637401eab9505b7ce690fb2e9c494", "filename": "tests/ui/lint/clashing-extern-fn.stderr", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e91364bcf5100017a8bd5b18cdebefdd3e5f0bb1/tests%2Fui%2Flint%2Fclashing-extern-fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e91364bcf5100017a8bd5b18cdebefdd3e5f0bb1/tests%2Fui%2Flint%2Fclashing-extern-fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flint%2Fclashing-extern-fn.stderr?ref=e91364bcf5100017a8bd5b18cdebefdd3e5f0bb1", "patch": "@@ -130,7 +130,7 @@ LL |             fn transparent_incorrect() -> isize;\n               found `unsafe extern \"C\" fn() -> isize`\n \n warning: `missing_return_type` redeclared with a different signature\n-  --> $DIR/clashing-extern-fn.rs:238:13\n+  --> $DIR/clashing-extern-fn.rs:259:13\n    |\n LL |             fn missing_return_type() -> usize;\n    |             ---------------------------------- `missing_return_type` previously declared here\n@@ -142,7 +142,7 @@ LL |             fn missing_return_type();\n               found `unsafe extern \"C\" fn()`\n \n warning: `non_zero_usize` redeclared with a different signature\n-  --> $DIR/clashing-extern-fn.rs:256:13\n+  --> $DIR/clashing-extern-fn.rs:277:13\n    |\n LL |             fn non_zero_usize() -> core::num::NonZeroUsize;\n    |             ----------------------------------------------- `non_zero_usize` previously declared here\n@@ -154,7 +154,7 @@ LL |             fn non_zero_usize() -> usize;\n               found `unsafe extern \"C\" fn() -> usize`\n \n warning: `non_null_ptr` redeclared with a different signature\n-  --> $DIR/clashing-extern-fn.rs:258:13\n+  --> $DIR/clashing-extern-fn.rs:279:13\n    |\n LL |             fn non_null_ptr() -> core::ptr::NonNull<usize>;\n    |             ----------------------------------------------- `non_null_ptr` previously declared here\n@@ -166,7 +166,7 @@ LL |             fn non_null_ptr() -> *const usize;\n               found `unsafe extern \"C\" fn() -> *const usize`\n \n warning: `option_non_zero_usize_incorrect` redeclared with a different signature\n-  --> $DIR/clashing-extern-fn.rs:356:13\n+  --> $DIR/clashing-extern-fn.rs:377:13\n    |\n LL |             fn option_non_zero_usize_incorrect() -> usize;\n    |             ---------------------------------------------- `option_non_zero_usize_incorrect` previously declared here\n@@ -178,7 +178,7 @@ LL |             fn option_non_zero_usize_incorrect() -> isize;\n               found `unsafe extern \"C\" fn() -> isize`\n \n warning: `option_non_null_ptr_incorrect` redeclared with a different signature\n-  --> $DIR/clashing-extern-fn.rs:358:13\n+  --> $DIR/clashing-extern-fn.rs:379:13\n    |\n LL |             fn option_non_null_ptr_incorrect() -> *const usize;\n    |             --------------------------------------------------- `option_non_null_ptr_incorrect` previously declared here\n@@ -190,7 +190,7 @@ LL |             fn option_non_null_ptr_incorrect() -> *const isize;\n               found `unsafe extern \"C\" fn() -> *const isize`\n \n warning: `hidden_niche_transparent_no_niche` redeclared with a different signature\n-  --> $DIR/clashing-extern-fn.rs:408:13\n+  --> $DIR/clashing-extern-fn.rs:433:13\n    |\n LL |             fn hidden_niche_transparent_no_niche() -> usize;\n    |             ------------------------------------------------ `hidden_niche_transparent_no_niche` previously declared here\n@@ -202,7 +202,7 @@ LL |             fn hidden_niche_transparent_no_niche() -> Option<TransparentNoN\n               found `unsafe extern \"C\" fn() -> Option<TransparentNoNiche>`\n \n warning: `hidden_niche_unsafe_cell` redeclared with a different signature\n-  --> $DIR/clashing-extern-fn.rs:412:13\n+  --> $DIR/clashing-extern-fn.rs:437:13\n    |\n LL |             fn hidden_niche_unsafe_cell() -> usize;\n    |             --------------------------------------- `hidden_niche_unsafe_cell` previously declared here\n@@ -214,7 +214,7 @@ LL |             fn hidden_niche_unsafe_cell() -> Option<UnsafeCell<NonZeroUsize\n               found `unsafe extern \"C\" fn() -> Option<UnsafeCell<NonZeroUsize>>`\n \n warning: `extern` block uses type `Option<TransparentNoNiche>`, which is not FFI-safe\n-  --> $DIR/clashing-extern-fn.rs:408:55\n+  --> $DIR/clashing-extern-fn.rs:433:55\n    |\n LL |             fn hidden_niche_transparent_no_niche() -> Option<TransparentNoNiche>;\n    |                                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^ not FFI-safe\n@@ -224,7 +224,7 @@ LL |             fn hidden_niche_transparent_no_niche() -> Option<TransparentNoN\n    = note: `#[warn(improper_ctypes)]` on by default\n \n warning: `extern` block uses type `Option<UnsafeCell<NonZeroUsize>>`, which is not FFI-safe\n-  --> $DIR/clashing-extern-fn.rs:412:46\n+  --> $DIR/clashing-extern-fn.rs:437:46\n    |\n LL |             fn hidden_niche_unsafe_cell() -> Option<UnsafeCell<NonZeroUsize>>;\n    |                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not FFI-safe"}, {"sha": "2bb133e8bfd42667fec4f3b3f695b395dbb4ef39", "filename": "tests/ui/test-attrs/custom-test-frameworks/issue-107454.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e91364bcf5100017a8bd5b18cdebefdd3e5f0bb1/tests%2Fui%2Ftest-attrs%2Fcustom-test-frameworks%2Fissue-107454.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e91364bcf5100017a8bd5b18cdebefdd3e5f0bb1/tests%2Fui%2Ftest-attrs%2Fcustom-test-frameworks%2Fissue-107454.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftest-attrs%2Fcustom-test-frameworks%2Fissue-107454.rs?ref=e91364bcf5100017a8bd5b18cdebefdd3e5f0bb1", "patch": "@@ -0,0 +1,10 @@\n+// compile-flags: --test\n+\n+#![feature(custom_test_frameworks)]\n+#![deny(unnameable_test_items)]\n+\n+fn foo() {\n+    #[test_case]\n+    //~^ ERROR cannot test inner items [unnameable_test_items]\n+    fn test2() {}\n+}"}, {"sha": "bd604afb79f8e5a4a3a69288c8f172609d15fe00", "filename": "tests/ui/test-attrs/custom-test-frameworks/issue-107454.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e91364bcf5100017a8bd5b18cdebefdd3e5f0bb1/tests%2Fui%2Ftest-attrs%2Fcustom-test-frameworks%2Fissue-107454.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e91364bcf5100017a8bd5b18cdebefdd3e5f0bb1/tests%2Fui%2Ftest-attrs%2Fcustom-test-frameworks%2Fissue-107454.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftest-attrs%2Fcustom-test-frameworks%2Fissue-107454.stderr?ref=e91364bcf5100017a8bd5b18cdebefdd3e5f0bb1", "patch": "@@ -0,0 +1,15 @@\n+error: cannot test inner items\n+  --> $DIR/issue-107454.rs:7:5\n+   |\n+LL |     #[test_case]\n+   |     ^^^^^^^^^^^^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/issue-107454.rs:4:9\n+   |\n+LL | #![deny(unnameable_test_items)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^\n+   = note: this error originates in the attribute macro `test_case` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: aborting due to previous error\n+"}]}