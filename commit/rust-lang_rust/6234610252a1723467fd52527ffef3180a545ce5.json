{"sha": "6234610252a1723467fd52527ffef3180a545ce5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYyMzQ2MTAyNTJhMTcyMzQ2N2ZkNTI1MjdmZmVmMzE4MGE1NDVjZTU=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2016-07-30T08:14:46Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-07-30T08:14:46Z"}, "message": "Rollup merge of #35058 - jethrogb:no_panic_abs, r=alexcrichton\n\nAdd non-panicking abs() functions to all signed integer types.\n\nCurrently, calling abs() on one of the signed integer types might panic (in\ndebug mode at least) because the absolute value of the largest negative value\ncan not be represented in that signed type. Unlike all other integer\noperations, there is currently not a non-panicking version on this function.\nThis seems to just be an oversight in the design, therefore just adding it now.", "tree": {"sha": "d21538ad5a7e2cd38e6554e29c11c40eed0b62a4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d21538ad5a7e2cd38e6554e29c11c40eed0b62a4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6234610252a1723467fd52527ffef3180a545ce5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6234610252a1723467fd52527ffef3180a545ce5", "html_url": "https://github.com/rust-lang/rust/commit/6234610252a1723467fd52527ffef3180a545ce5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6234610252a1723467fd52527ffef3180a545ce5/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "96e3972707a12aefd3ae3ceac71fe6009ccbb061", "url": "https://api.github.com/repos/rust-lang/rust/commits/96e3972707a12aefd3ae3ceac71fe6009ccbb061", "html_url": "https://github.com/rust-lang/rust/commit/96e3972707a12aefd3ae3ceac71fe6009ccbb061"}, {"sha": "cdc6afed389ecdcea0955eadae59ea6b008a58fe", "url": "https://api.github.com/repos/rust-lang/rust/commits/cdc6afed389ecdcea0955eadae59ea6b008a58fe", "html_url": "https://github.com/rust-lang/rust/commit/cdc6afed389ecdcea0955eadae59ea6b008a58fe"}], "stats": {"total": 84, "additions": 84, "deletions": 0}, "files": [{"sha": "4636811aa46da2c95f96d6c87bf9cdd3a06a09b6", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/6234610252a1723467fd52527ffef3180a545ce5/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6234610252a1723467fd52527ffef3180a545ce5/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=6234610252a1723467fd52527ffef3180a545ce5", "patch": "@@ -611,6 +611,31 @@ macro_rules! int_impl {\n             if b {None} else {Some(a)}\n         }\n \n+        /// Checked absolute value. Computes `self.abs()`, returning `None` if\n+        /// `self == MIN`.\n+        ///\n+        /// # Examples\n+        ///\n+        /// Basic usage:\n+        ///\n+        /// ```\n+        /// # #![feature(no_panic_abs)]\n+        ///\n+        /// use std::i32;\n+        ///\n+        /// assert_eq!((-5i32).checked_abs(), Some(5));\n+        /// assert_eq!(i32::MIN.checked_abs(), None);\n+        /// ```\n+        #[unstable(feature = \"no_panic_abs\", issue = \"35057\")]\n+        #[inline]\n+        pub fn checked_abs(self) -> Option<Self> {\n+            if self.is_negative() {\n+                self.checked_neg()\n+            } else {\n+                Some(self)\n+            }\n+        }\n+\n         /// Saturating integer addition. Computes `self + other`, saturating at\n         /// the numeric bounds instead of overflowing.\n         ///\n@@ -863,6 +888,36 @@ macro_rules! int_impl {\n             self.overflowing_shr(rhs).0\n         }\n \n+        /// Wrapping (modular) absolute value. Computes `self.abs()`,\n+        /// wrapping around at the boundary of the type.\n+        ///\n+        /// The only case where such wrapping can occur is when one takes\n+        /// the absolute value of the negative minimal value for the type\n+        /// this is a positive value that is too large to represent in the\n+        /// type. In such a case, this function returns `MIN` itself.\n+        ///\n+        /// # Examples\n+        ///\n+        /// Basic usage:\n+        ///\n+        /// ```\n+        /// # #![feature(no_panic_abs)]\n+        ///\n+        /// assert_eq!(100i8.wrapping_abs(), 100);\n+        /// assert_eq!((-100i8).wrapping_abs(), 100);\n+        /// assert_eq!((-128i8).wrapping_abs(), -128);\n+        /// assert_eq!((-128i8).wrapping_abs() as u8, 128);\n+        /// ```\n+        #[unstable(feature = \"no_panic_abs\", issue = \"35057\")]\n+        #[inline(always)]\n+        pub fn wrapping_abs(self) -> Self {\n+            if self.is_negative() {\n+                self.wrapping_neg()\n+            } else {\n+                self\n+            }\n+        }\n+\n         /// Calculates `self` + `rhs`\n         ///\n         /// Returns a tuple of the addition along with a boolean indicating\n@@ -1071,6 +1126,35 @@ macro_rules! int_impl {\n             (self >> (rhs & ($BITS - 1)), (rhs > ($BITS - 1)))\n         }\n \n+        /// Computes the absolute value of `self`.\n+        ///\n+        /// Returns a tuple of the absolute version of self along with a\n+        /// boolean indicating whether an overflow happened. If self is the\n+        /// minimum value (e.g. i32::MIN for values of type i32), then the\n+        /// minimum value will be returned again and true will be returned for\n+        /// an overflow happening.\n+        ///\n+        /// # Examples\n+        ///\n+        /// Basic usage:\n+        ///\n+        /// ```\n+        /// # #![feature(no_panic_abs)]\n+        ///\n+        /// assert_eq!(10i8.overflowing_abs(), (10,false));\n+        /// assert_eq!((-10i8).overflowing_abs(), (10,false));\n+        /// assert_eq!((-128i8).overflowing_abs(), (-128,true));\n+        /// ```\n+        #[unstable(feature = \"no_panic_abs\", issue = \"35057\")]\n+        #[inline]\n+        pub fn overflowing_abs(self) -> (Self, bool) {\n+            if self.is_negative() {\n+                self.overflowing_neg()\n+            } else {\n+                (self, false)\n+            }\n+        }\n+\n         /// Raises self to the power of `exp`, using exponentiation by squaring.\n         ///\n         /// # Examples"}]}