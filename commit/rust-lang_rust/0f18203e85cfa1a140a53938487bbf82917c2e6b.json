{"sha": "0f18203e85cfa1a140a53938487bbf82917c2e6b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBmMTgyMDNlODVjZmExYTE0MGE1MzkzODQ4N2JiZjgyOTE3YzJlNmI=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-04-14T10:49:15Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-05-25T13:42:12Z"}, "message": "Miri: refactor read_discriminant and make it return Scalar", "tree": {"sha": "dbf542dab4c23646267aee2faa2138fd09248674", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dbf542dab4c23646267aee2faa2138fd09248674"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0f18203e85cfa1a140a53938487bbf82917c2e6b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0f18203e85cfa1a140a53938487bbf82917c2e6b", "html_url": "https://github.com/rust-lang/rust/commit/0f18203e85cfa1a140a53938487bbf82917c2e6b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0f18203e85cfa1a140a53938487bbf82917c2e6b/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ee6c0dae394f67b5286909704f8f0a608696c96c", "url": "https://api.github.com/repos/rust-lang/rust/commits/ee6c0dae394f67b5286909704f8f0a608696c96c", "html_url": "https://github.com/rust-lang/rust/commit/ee6c0dae394f67b5286909704f8f0a608696c96c"}], "stats": {"total": 156, "additions": 86, "deletions": 70}, "files": [{"sha": "fc588e049d7d8b9da719d8ff096f5ff40ed4d53d", "filename": "src/librustc_middle/mir/interpret/error.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f18203e85cfa1a140a53938487bbf82917c2e6b/src%2Flibrustc_middle%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f18203e85cfa1a140a53938487bbf82917c2e6b/src%2Flibrustc_middle%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Finterpret%2Ferror.rs?ref=0f18203e85cfa1a140a53938487bbf82917c2e6b", "patch": "@@ -1,4 +1,4 @@\n-use super::{AllocId, Pointer, RawConst, ScalarMaybeUninit};\n+use super::{AllocId, Pointer, RawConst, Scalar};\n \n use crate::mir::interpret::ConstValue;\n use crate::ty::layout::LayoutError;\n@@ -391,7 +391,7 @@ pub enum UndefinedBehaviorInfo<'tcx> {\n     /// Using a non-character `u32` as character.\n     InvalidChar(u32),\n     /// An enum discriminant was set to a value which was outside the range of valid values.\n-    InvalidDiscriminant(ScalarMaybeUninit),\n+    InvalidDiscriminant(Scalar),\n     /// Using a pointer-not-to-a-function as function pointer.\n     InvalidFunctionPointer(Pointer),\n     /// Using a string that is not valid UTF-8,"}, {"sha": "6c7db9fce4cf07506bcadfd75e9bc3e72b17cf5a", "filename": "src/librustc_mir/interpret/intrinsics.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0f18203e85cfa1a140a53938487bbf82917c2e6b/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f18203e85cfa1a140a53938487bbf82917c2e6b/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs?ref=0f18203e85cfa1a140a53938487bbf82917c2e6b", "patch": "@@ -218,15 +218,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             sym::discriminant_value => {\n                 let place = self.deref_operand(args[0])?;\n                 let discr_val = self.read_discriminant(place.into())?.0;\n-                let scalar = match dest.layout.ty.kind {\n-                    ty::Int(_) => Scalar::from_int(\n-                        self.sign_extend(discr_val, dest.layout) as i128,\n-                        dest.layout.size,\n-                    ),\n-                    ty::Uint(_) => Scalar::from_uint(discr_val, dest.layout.size),\n-                    _ => bug!(\"invalid `discriminant_value` return layout: {:?}\", dest.layout),\n-                };\n-                self.write_scalar(scalar, dest)?;\n+                self.write_scalar(discr_val, dest)?;\n             }\n             sym::unchecked_shl\n             | sym::unchecked_shr"}, {"sha": "7ad16a051fdecb27c4594813c83ac30ba51a2012", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 82, "deletions": 57, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/0f18203e85cfa1a140a53938487bbf82917c2e6b/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f18203e85cfa1a140a53938487bbf82917c2e6b/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=0f18203e85cfa1a140a53938487bbf82917c2e6b", "patch": "@@ -15,8 +15,8 @@ use rustc_target::abi::{Abi, DiscriminantKind, HasDataLayout, Integer, LayoutOf,\n use rustc_target::abi::{VariantIdx, Variants};\n \n use super::{\n-    from_known_layout, sign_extend, truncate, ConstValue, GlobalId, InterpCx, InterpResult,\n-    MPlaceTy, Machine, MemPlace, Place, PlaceTy, Pointer, Scalar, ScalarMaybeUninit,\n+    from_known_layout, ConstValue, GlobalId, InterpCx, InterpResult, MPlaceTy, Machine, MemPlace,\n+    Place, PlaceTy, Pointer, Scalar, ScalarMaybeUninit,\n };\n \n /// An `Immediate` represents a single immediate self-contained Rust value.\n@@ -577,91 +577,112 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     pub fn read_discriminant(\n         &self,\n         rval: OpTy<'tcx, M::PointerTag>,\n-    ) -> InterpResult<'tcx, (u128, VariantIdx)> {\n+    ) -> InterpResult<'tcx, (Scalar<M::PointerTag>, VariantIdx)> {\n         trace!(\"read_discriminant_value {:#?}\", rval.layout);\n \n-        let (discr_layout, discr_kind, discr_index) = match rval.layout.variants {\n+        let (discr_scalar_layout, discr_kind, discr_index) = match rval.layout.variants {\n             Variants::Single { index } => {\n-                let discr_val = rval\n-                    .layout\n-                    .ty\n-                    .discriminant_for_variant(*self.tcx, index)\n-                    .map_or(u128::from(index.as_u32()), |discr| discr.val);\n-                return Ok((discr_val, index));\n+                let discr = match rval.layout.ty.discriminant_for_variant(*self.tcx, index) {\n+                    Some(discr) => {\n+                        // This type actually has discriminants.\n+                        let discr_layout = self.layout_of(discr.ty)?;\n+                        Scalar::from_uint(discr.val, discr_layout.size)\n+                    }\n+                    None => {\n+                        // On a type without actual discriminants, return variant idx as `u8`.\n+                        let discr_layout = self.layout_of(self.tcx.types.u8)?;\n+                        Scalar::from_uint(index.as_u32(), discr_layout.size)\n+                    }\n+                };\n+                return Ok((discr, index));\n             }\n-            Variants::Multiple { discr: ref discr_layout, ref discr_kind, discr_index, .. } => {\n-                (discr_layout, discr_kind, discr_index)\n+            Variants::Multiple { ref discr, ref discr_kind, discr_index, .. } => {\n+                (discr, discr_kind, discr_index)\n             }\n         };\n \n-        // read raw discriminant value\n-        let discr_op = self.operand_field(rval, discr_index)?;\n-        let discr_val = self.read_immediate(discr_op)?;\n-        let raw_discr = discr_val.to_scalar_or_undef();\n-        trace!(\"discr value: {:?}\", raw_discr);\n-        // post-process\n+        // There are *three* types/layouts that come into play here:\n+        // - The field storing the discriminant has a layout, which my be a pointer.\n+        //   This is `discr_val.layout`; we just use it for sanity checks.\n+        // - The discriminant has a layout for tag storing purposes, which is always an integer.\n+        //   This is `discr_layout` and is used to interpret the value we read from the\n+        //   discriminant field.\n+        // - The discriminant also has a type for typechecking, and that type's\n+        //   layout can be *different*. This is `discr_ty`, and is used for the `Scalar`\n+        //   we return. If necessary, a cast from `discr_layout` is performed.\n+\n+        // Get layout for tag.\n+        let discr_layout = self.layout_of(discr_scalar_layout.value.to_int_ty(*self.tcx))?;\n+\n+        // Read discriminant value and sanity-check `discr_layout`.\n+        let discr_val = self.read_immediate(self.operand_field(rval, discr_index)?)?;\n+        assert_eq!(discr_layout.size, discr_val.layout.size);\n+        assert_eq!(discr_layout.abi.is_signed(), discr_val.layout.abi.is_signed());\n+        let discr_val = discr_val.to_scalar()?;\n+        trace!(\"discriminant value: {:?}\", discr_val);\n+\n+        // Get type used by typechecking.\n+        let discr_ty = match rval.layout.ty.kind {\n+            ty::Adt(adt, _) => {\n+                let discr_int_ty = Integer::from_attr(self, adt.repr.discr_type());\n+                // The signedness of tag and discriminant is the same.\n+                discr_int_ty.to_ty(*self.tcx, discr_layout.abi.is_signed())\n+            }\n+            ty::Generator(_, substs, _) => {\n+                let substs = substs.as_generator();\n+                substs.discr_ty(*self.tcx)\n+            }\n+            _ => bug!(\"multiple variants for non-adt non-generator\"),\n+        };\n+\n+        // Figure out which discriminant and variant this corresponds to.\n         Ok(match *discr_kind {\n             DiscriminantKind::Tag => {\n-                let bits_discr = raw_discr\n-                    .not_undef()\n-                    .and_then(|raw_discr| self.force_bits(raw_discr, discr_val.layout.size))\n-                    .map_err(|_| err_ub!(InvalidDiscriminant(raw_discr.erase_tag())))?;\n-                let real_discr = if discr_val.layout.abi.is_signed() {\n-                    // going from layout tag type to typeck discriminant type\n-                    // requires first sign extending with the discriminant layout\n-                    let sexted = sign_extend(bits_discr, discr_val.layout.size);\n-                    // and then zeroing with the typeck discriminant type\n-                    let discr_ty = rval\n-                        .layout\n-                        .ty\n-                        .ty_adt_def()\n-                        .expect(\"tagged layout corresponds to adt\")\n-                        .repr\n-                        .discr_type();\n-                    let size = Integer::from_attr(self, discr_ty).size();\n-                    truncate(sexted, size)\n-                } else {\n-                    bits_discr\n-                };\n-                // Make sure we catch invalid discriminants\n+                let discr_bits = self\n+                    .force_bits(discr_val, discr_layout.size)\n+                    .map_err(|_| err_ub!(InvalidDiscriminant(discr_val.erase_tag())))?;\n+                // Cast discriminant bits to the right type.\n+                let discr_ty_layout = self.layout_of(discr_ty)?;\n+                let discr_val_cast =\n+                    self.cast_from_scalar(discr_bits, discr_layout, discr_ty);\n+                let discr_bits = discr_val_cast.assert_bits(discr_ty_layout.size);\n+                // Find variant index for this tag, and catch invalid discriminants.\n                 let index = match rval.layout.ty.kind {\n                     ty::Adt(adt, _) => {\n-                        adt.discriminants(self.tcx.tcx).find(|(_, var)| var.val == real_discr)\n+                        adt.discriminants(self.tcx.tcx).find(|(_, var)| var.val == discr_bits)\n                     }\n                     ty::Generator(def_id, substs, _) => {\n                         let substs = substs.as_generator();\n                         substs\n                             .discriminants(def_id, self.tcx.tcx)\n-                            .find(|(_, var)| var.val == real_discr)\n+                            .find(|(_, var)| var.val == discr_bits)\n                     }\n                     _ => bug!(\"tagged layout for non-adt non-generator\"),\n                 }\n-                .ok_or_else(|| err_ub!(InvalidDiscriminant(raw_discr.erase_tag())))?;\n-                (real_discr, index.0)\n+                .ok_or_else(|| err_ub!(InvalidDiscriminant(discr_val.erase_tag())))?;\n+                // Return the cast value, and the index.\n+                (discr_val_cast, index.0)\n             }\n             DiscriminantKind::Niche { dataful_variant, ref niche_variants, niche_start } => {\n+                // Compute the variant this discriminant corresponds to. With niche layout,\n+                // tag and variant index are the same.\n                 let variants_start = niche_variants.start().as_u32();\n                 let variants_end = niche_variants.end().as_u32();\n-                let raw_discr = raw_discr\n-                    .not_undef()\n-                    .map_err(|_| err_ub!(InvalidDiscriminant(ScalarMaybeUninit::Uninit)))?;\n-                match raw_discr.to_bits_or_ptr(discr_val.layout.size, self) {\n+                let variant = match discr_val.to_bits_or_ptr(discr_layout.size, self) {\n                     Err(ptr) => {\n                         // The niche must be just 0 (which an inbounds pointer value never is)\n                         let ptr_valid = niche_start == 0\n                             && variants_start == variants_end\n                             && !self.memory.ptr_may_be_null(ptr);\n                         if !ptr_valid {\n-                            throw_ub!(InvalidDiscriminant(raw_discr.erase_tag().into()))\n+                            throw_ub!(InvalidDiscriminant(discr_val.erase_tag()))\n                         }\n-                        (u128::from(dataful_variant.as_u32()), dataful_variant)\n+                        dataful_variant\n                     }\n-                    Ok(raw_discr) => {\n+                    Ok(bits_discr) => {\n                         // We need to use machine arithmetic to get the relative variant idx:\n                         // variant_index_relative = discr_val - niche_start_val\n-                        let discr_layout =\n-                            self.layout_of(discr_layout.value.to_int_ty(*self.tcx))?;\n-                        let discr_val = ImmTy::from_uint(raw_discr, discr_layout);\n+                        let discr_val = ImmTy::from_uint(bits_discr, discr_layout);\n                         let niche_start_val = ImmTy::from_uint(niche_start, discr_layout);\n                         let variant_index_relative_val =\n                             self.binary_op(mir::BinOp::Sub, discr_val, niche_start_val)?;\n@@ -684,12 +705,16 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                                 .variants\n                                 .len();\n                             assert!(usize::try_from(variant_index).unwrap() < variants_len);\n-                            (u128::from(variant_index), VariantIdx::from_u32(variant_index))\n+                            VariantIdx::from_u32(variant_index)\n                         } else {\n-                            (u128::from(dataful_variant.as_u32()), dataful_variant)\n+                            dataful_variant\n                         }\n                     }\n-                }\n+                };\n+                // Compute the size of the scalar we need to return.\n+                // FIXME: Why do we not need to do a cast here like we do above?\n+                let size = self.layout_of(discr_ty)?.size;\n+                (Scalar::from_uint(variant.as_u32(), size), variant)\n             }\n         })\n     }"}, {"sha": "bd4df788057e248939d2fa49d1425e7c149aa722", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0f18203e85cfa1a140a53938487bbf82917c2e6b/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f18203e85cfa1a140a53938487bbf82917c2e6b/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=0f18203e85cfa1a140a53938487bbf82917c2e6b", "patch": "@@ -262,8 +262,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             Discriminant(place) => {\n                 let op = self.eval_place_to_op(place, None)?;\n                 let discr_val = self.read_discriminant(op)?.0;\n-                let size = dest.layout.size;\n-                self.write_scalar(Scalar::from_uint(discr_val, size), dest)?;\n+                self.write_scalar(discr_val, dest)?;\n             }\n         }\n "}]}