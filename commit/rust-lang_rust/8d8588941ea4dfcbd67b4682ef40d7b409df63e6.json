{"sha": "8d8588941ea4dfcbd67b4682ef40d7b409df63e6", "node_id": "C_kwDOAAsO6NoAKDhkODU4ODk0MWVhNGRmY2JkNjdiNDY4MmVmNDBkN2I0MDlkZjYzZTY", "commit": {"author": {"name": "tamaron", "email": "tamaron1203@gmail.com", "date": "2022-05-07T09:18:57Z"}, "committer": {"name": "tamaron", "email": "tamaron1203@gmail.com", "date": "2022-05-07T10:50:34Z"}, "message": "fix", "tree": {"sha": "5cac48d559fa28f164a01694839fbde3171c8371", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5cac48d559fa28f164a01694839fbde3171c8371"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8d8588941ea4dfcbd67b4682ef40d7b409df63e6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8d8588941ea4dfcbd67b4682ef40d7b409df63e6", "html_url": "https://github.com/rust-lang/rust/commit/8d8588941ea4dfcbd67b4682ef40d7b409df63e6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8d8588941ea4dfcbd67b4682ef40d7b409df63e6/comments", "author": {"login": "tamaroning", "id": 20992019, "node_id": "MDQ6VXNlcjIwOTkyMDE5", "avatar_url": "https://avatars.githubusercontent.com/u/20992019?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tamaroning", "html_url": "https://github.com/tamaroning", "followers_url": "https://api.github.com/users/tamaroning/followers", "following_url": "https://api.github.com/users/tamaroning/following{/other_user}", "gists_url": "https://api.github.com/users/tamaroning/gists{/gist_id}", "starred_url": "https://api.github.com/users/tamaroning/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tamaroning/subscriptions", "organizations_url": "https://api.github.com/users/tamaroning/orgs", "repos_url": "https://api.github.com/users/tamaroning/repos", "events_url": "https://api.github.com/users/tamaroning/events{/privacy}", "received_events_url": "https://api.github.com/users/tamaroning/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tamaroning", "id": 20992019, "node_id": "MDQ6VXNlcjIwOTkyMDE5", "avatar_url": "https://avatars.githubusercontent.com/u/20992019?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tamaroning", "html_url": "https://github.com/tamaroning", "followers_url": "https://api.github.com/users/tamaroning/followers", "following_url": "https://api.github.com/users/tamaroning/following{/other_user}", "gists_url": "https://api.github.com/users/tamaroning/gists{/gist_id}", "starred_url": "https://api.github.com/users/tamaroning/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tamaroning/subscriptions", "organizations_url": "https://api.github.com/users/tamaroning/orgs", "repos_url": "https://api.github.com/users/tamaroning/repos", "events_url": "https://api.github.com/users/tamaroning/events{/privacy}", "received_events_url": "https://api.github.com/users/tamaroning/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5d0ca74c753d72bf5b6dcfa532001cdd07aa0365", "url": "https://api.github.com/repos/rust-lang/rust/commits/5d0ca74c753d72bf5b6dcfa532001cdd07aa0365", "html_url": "https://github.com/rust-lang/rust/commit/5d0ca74c753d72bf5b6dcfa532001cdd07aa0365"}], "stats": {"total": 255, "additions": 161, "deletions": 94}, "files": [{"sha": "09efb12f5daa14d7c30a712213f4fd0d123beb07", "filename": "clippy_lints/src/undocumented_unsafe_blocks.rs", "status": "modified", "additions": 132, "deletions": 84, "changes": 216, "blob_url": "https://github.com/rust-lang/rust/blob/8d8588941ea4dfcbd67b4682ef40d7b409df63e6/clippy_lints%2Fsrc%2Fundocumented_unsafe_blocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d8588941ea4dfcbd67b4682ef40d7b409df63e6/clippy_lints%2Fsrc%2Fundocumented_unsafe_blocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fundocumented_unsafe_blocks.rs?ref=8d8588941ea4dfcbd67b4682ef40d7b409df63e6", "patch": "@@ -1,19 +1,18 @@\n use clippy_utils::diagnostics::span_lint_and_help;\n-use clippy_utils::is_lint_allowed;\n use clippy_utils::source::walk_span_to_context;\n+use clippy_utils::{get_parent_node, is_lint_allowed};\n use rustc_data_structures::sync::Lrc;\n use rustc_hir as hir;\n-use rustc_hir::{Block, BlockCheckMode, UnsafeSource};\n+use rustc_hir::{Block, BlockCheckMode, ItemKind, Node, UnsafeSource};\n use rustc_lexer::{tokenize, TokenKind};\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::lint::in_external_macro;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::{BytePos, Pos, Span, SyntaxContext};\n-use std::rc::Rc;\n \n declare_clippy_lint! {\n     /// ### What it does\n-    /// Checks for `unsafe` blocks without a `// SAFETY: ` comment\n+    /// Checks for `unsafe` blocks and impls without a `// SAFETY: ` comment\n     /// explaining why the unsafe operations performed inside\n     /// the block are safe.\n     ///\n@@ -36,7 +35,7 @@ declare_clippy_lint! {\n     /// ```\n     ///\n     /// ### Why is this bad?\n-    /// Undocumented unsafe blocks can make it difficult to\n+    /// Undocumented unsafe blocks and impls can make it difficult to\n     /// read and maintain code, as well as uncover unsoundness\n     /// and bugs.\n     ///\n@@ -68,7 +67,7 @@ impl LateLintPass<'_> for UndocumentedUnsafeBlocks {\n         if block.rules == BlockCheckMode::UnsafeBlock(UnsafeSource::UserProvided)\n             && !in_external_macro(cx.tcx.sess, block.span)\n             && !is_lint_allowed(cx, UNDOCUMENTED_UNSAFE_BLOCKS, block.hir_id)\n-            && !is_unsafe_from_proc_macro(cx, block)\n+            && !is_unsafe_from_proc_macro(cx, block.span)\n             && !block_has_safety_comment(cx, block)\n         {\n             let source_map = cx.tcx.sess.source_map();\n@@ -89,70 +88,36 @@ impl LateLintPass<'_> for UndocumentedUnsafeBlocks {\n         }\n     }\n \n-    fn check_mod(&mut self, cx: &LateContext<'_>, module: &'_ hir::Mod<'_>, mod_span: Span, hir_id: hir::HirId) {\n-        let source_map = cx.sess().source_map();\n-        let mut item_and_spans: Vec<(&hir::Item<'_>, Span)> = Vec::new(); // (start, end, item)\n-\n-        // Collect all items and their spans\n-        for item_id in module.item_ids {\n-            let item = cx.tcx.hir().item(*item_id);\n-            item_and_spans.push((item, item.span));\n-        }\n-        // Sort items by start position\n-        item_and_spans.sort_by_key(|e| e.1.lo());\n-\n-        for (idx, (item, item_span)) in item_and_spans.iter().enumerate() {\n-            if let hir::ItemKind::Impl(imple) = &item.kind\n-                && imple.unsafety == hir::Unsafety::Unsafe\n-                && !item_span.from_expansion()\n-                && !is_lint_allowed(cx, UNDOCUMENTED_UNSAFE_BLOCKS, hir_id)\n-            {\n-                // Checks if the lines immediately preceding the impl contain a safety comment.\n-                let impl_has_safety_comment = {\n-                    let span_before_impl = if idx == 0 {\n-                        // mod A { /* comment */ unsafe impl T {} }\n-                        // ^--------------------^\n-                        todo!();\n-                        //mod_span.until(module.spans)\n-                    } else {\n-                        // unsafe impl S {} /* comment */ unsafe impl T {}\n-                        //                 ^-------------^\n-                        item_and_spans[idx - 1].1.between(*item_span)\n-                    };\n-\n-                    if let Ok(start) = source_map.lookup_line(span_before_impl.lo())\n-                        && let Ok(end) = source_map.lookup_line(span_before_impl.hi())\n-                        && let Some(src) = start.sf.src.as_deref()\n-                    {\n-                        start.line < end.line && text_has_safety_comment(\n-                            src,\n-                            &start.sf.lines[start.line + 1 ..= end.line],\n-                            start.sf.start_pos.to_usize()\n-                        )\n-                    } else {\n-                        // Problem getting source text. Pretend a comment was found.\n-                        true\n-                    }\n-                };\n+    fn check_item(&mut self, cx: &LateContext<'_>, item: &hir::Item<'_>) {\n+        if let hir::ItemKind::Impl(imple) = item.kind\n+            && imple.unsafety == hir::Unsafety::Unsafe\n+            && !in_external_macro(cx.tcx.sess, item.span)\n+            && !is_lint_allowed(cx, UNDOCUMENTED_UNSAFE_BLOCKS, item.hir_id())\n+            && !is_unsafe_from_proc_macro(cx, item.span)\n+            && !item_has_safety_comment(cx, item)\n+        {\n+            let source_map = cx.tcx.sess.source_map();\n+            let span = if source_map.is_multiline(item.span) {\n+                source_map.span_until_char(item.span, '\\n')\n+            } else {\n+                item.span\n+            };\n \n-                if !impl_has_safety_comment {\n-                    span_lint_and_help(\n-                        cx,\n-                        UNDOCUMENTED_UNSAFE_BLOCKS,\n-                        *item_span,\n-                        \"unsafe impl missing a safety comment\",\n-                        None,\n-                        \"consider adding a safety comment on the preceding line\",\n-                    );\n-                }\n-            }\n+            span_lint_and_help(\n+                cx,\n+                UNDOCUMENTED_UNSAFE_BLOCKS,\n+                span,\n+                \"unsafe impl missing a safety comment\",\n+                None,\n+                \"consider adding a safety comment on the preceding line\",\n+            );\n         }\n     }\n }\n \n-fn is_unsafe_from_proc_macro(cx: &LateContext<'_>, block: &Block<'_>) -> bool {\n+fn is_unsafe_from_proc_macro(cx: &LateContext<'_>, span: Span) -> bool {\n     let source_map = cx.sess().source_map();\n-    let file_pos = source_map.lookup_byte_offset(block.span.lo());\n+    let file_pos = source_map.lookup_byte_offset(span.lo());\n     file_pos\n         .sf\n         .src\n@@ -162,7 +127,7 @@ fn is_unsafe_from_proc_macro(cx: &LateContext<'_>, block: &Block<'_>) -> bool {\n }\n \n /// Checks if the lines immediately preceding the block contain a safety comment.\n-fn block_has_safety_comment(cx: &LateContext<'_>, block: &Block<'_>) -> bool {\n+fn block_has_safety_comment(cx: &LateContext<'_>, block: &hir::Block<'_>) -> bool {\n     // This intentionally ignores text before the start of a function so something like:\n     // ```\n     //     // SAFETY: reason\n@@ -171,13 +136,85 @@ fn block_has_safety_comment(cx: &LateContext<'_>, block: &Block<'_>) -> bool {\n     // won't work. This is to avoid dealing with where such a comment should be place relative to\n     // attributes and doc comments.\n \n+    span_from_macro_expansion_has_safety_comment(cx, block.span) || span_in_body_has_safety_comment(cx, block.span)\n+}\n+\n+/// Checks if the lines immediately preceding the item contain a safety comment.\n+fn item_has_safety_comment(cx: &LateContext<'_>, item: &hir::Item<'_>) -> bool {\n+    if span_from_macro_expansion_has_safety_comment(cx, item.span) || span_in_body_has_safety_comment(cx, item.span) {\n+        return true;\n+    }\n+\n+    if item.span.ctxt() == SyntaxContext::root() {\n+        if let Some(parent_node) = get_parent_node(cx.tcx, item.hir_id()) {\n+            let mut span_before_item = None;\n+            let mut hi = false;\n+            if let Node::Item(parent_item) = parent_node {\n+                if let ItemKind::Mod(parent_mod) = &parent_item.kind {\n+                    for (idx, item_id) in parent_mod.item_ids.iter().enumerate() {\n+                        if *item_id == item.item_id() {\n+                            if idx == 0 {\n+                                // mod A { /* comment */ unsafe impl T {} ... }\n+                                // ^------------------------------------------^ gets this span\n+                                // ^---------------------^ finally checks the text in this range\n+                                hi = false;\n+                                span_before_item = Some(parent_item.span);\n+                            } else {\n+                                let prev_item = cx.tcx.hir().item(parent_mod.item_ids[idx - 1]);\n+                                // some_item /* comment */ unsafe impl T {}\n+                                // ^-------^ gets this span\n+                                //         ^---------------^ finally checks the text in this range\n+                                hi = true;\n+                                span_before_item = Some(prev_item.span);\n+                            }\n+                            break;\n+                        }\n+                    }\n+                }\n+            }\n+            let span_before_item = span_before_item.unwrap();\n+\n+            let source_map = cx.sess().source_map();\n+            if let Some(item_span) = walk_span_to_context(item.span, SyntaxContext::root())\n+                && let Some(span_before_item) = walk_span_to_context(span_before_item, SyntaxContext::root())\n+                && let Ok(unsafe_line) = source_map.lookup_line(item_span.lo())\n+                && let Ok(line_before_unsafe) = source_map.lookup_line(if hi {\n+                    span_before_item.hi()\n+                } else {\n+                    span_before_item.lo()\n+                })\n+                && Lrc::ptr_eq(&unsafe_line.sf, &line_before_unsafe.sf)\n+                && let Some(src) = unsafe_line.sf.src.as_deref()\n+            {\n+                line_before_unsafe.line < unsafe_line.line && text_has_safety_comment(\n+                    src,\n+                    &unsafe_line.sf.lines[line_before_unsafe.line + 1..=unsafe_line.line],\n+                    unsafe_line.sf.start_pos.to_usize(),\n+                )\n+            } else {\n+                // Problem getting source text. Pretend a comment was found.\n+                true\n+            }\n+        } else {\n+            // No parent node. Pretend a comment was found.\n+            true\n+        }\n+    } else {\n+        false\n+    }\n+}\n+\n+fn span_from_macro_expansion_has_safety_comment(cx: &LateContext<'_>, span: Span) -> bool {\n     let source_map = cx.sess().source_map();\n-    let ctxt = block.span.ctxt();\n-    if ctxt != SyntaxContext::root() {\n-        // From a macro expansion. Get the text from the start of the macro declaration to start of the unsafe block.\n+    let ctxt = span.ctxt();\n+    if ctxt == SyntaxContext::root() {\n+        false\n+    } else {\n+        // From a macro expansion. Get the text from the start of the macro declaration to start of the\n+        // unsafe block.\n         //     macro_rules! foo { () => { stuff }; (x) => { unsafe { stuff } }; }\n         //     ^--------------------------------------------^\n-        if let Ok(unsafe_line) = source_map.lookup_line(block.span.lo())\n+        if let Ok(unsafe_line) = source_map.lookup_line(span.lo())\n             && let Ok(macro_line) = source_map.lookup_line(ctxt.outer_expn_data().def_site.lo())\n             && Lrc::ptr_eq(&unsafe_line.sf, &macro_line.sf)\n             && let Some(src) = unsafe_line.sf.src.as_deref()\n@@ -191,24 +228,35 @@ fn block_has_safety_comment(cx: &LateContext<'_>, block: &Block<'_>) -> bool {\n             // Problem getting source text. Pretend a comment was found.\n             true\n         }\n-    } else if let Ok(unsafe_line) = source_map.lookup_line(block.span.lo())\n+    }\n+}\n+\n+fn span_in_body_has_safety_comment(cx: &LateContext<'_>, span: Span) -> bool {\n+    let source_map = cx.sess().source_map();\n+    let ctxt = span.ctxt();\n+    if ctxt == SyntaxContext::root()\n         && let Some(body) = cx.enclosing_body\n-        && let Some(body_span) = walk_span_to_context(cx.tcx.hir().body(body).value.span, SyntaxContext::root())\n-        && let Ok(body_line) = source_map.lookup_line(body_span.lo())\n-        && Lrc::ptr_eq(&unsafe_line.sf, &body_line.sf)\n-        && let Some(src) = unsafe_line.sf.src.as_deref()\n     {\n-        // Get the text from the start of function body to the unsafe block.\n-        //     fn foo() { some_stuff; unsafe { stuff }; other_stuff; }\n-        //              ^-------------^\n-        body_line.line < unsafe_line.line && text_has_safety_comment(\n-            src,\n-            &unsafe_line.sf.lines[body_line.line + 1..=unsafe_line.line],\n-            unsafe_line.sf.start_pos.to_usize(),\n-        )\n+        if let Ok(unsafe_line) = source_map.lookup_line(span.lo())\n+            && let Some(body_span) = walk_span_to_context(cx.tcx.hir().body(body).value.span, SyntaxContext::root())\n+            && let Ok(body_line) = source_map.lookup_line(body_span.lo())\n+            && Lrc::ptr_eq(&unsafe_line.sf, &body_line.sf)\n+            && let Some(src) = unsafe_line.sf.src.as_deref()\n+        {\n+            // Get the text from the start of function body to the unsafe block.\n+            //     fn foo() { some_stuff; unsafe { stuff }; other_stuff; }\n+            //              ^-------------^\n+            body_line.line < unsafe_line.line && text_has_safety_comment(\n+                src,\n+                &unsafe_line.sf.lines[body_line.line + 1..=unsafe_line.line],\n+                unsafe_line.sf.start_pos.to_usize(),\n+            )\n+        } else {\n+            // Problem getting source text. Pretend a comment was found.\n+            true\n+        }\n     } else {\n-        // Problem getting source text. Pretend a comment was found.\n-        true\n+        false\n     }\n }\n "}, {"sha": "fd64c60384d6ff4ee9434743a233761b87c31792", "filename": "tests/ui/undocumented_unsafe_blocks.rs", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/8d8588941ea4dfcbd67b4682ef40d7b409df63e6/tests%2Fui%2Fundocumented_unsafe_blocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d8588941ea4dfcbd67b4682ef40d7b409df63e6/tests%2Fui%2Fundocumented_unsafe_blocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fundocumented_unsafe_blocks.rs?ref=8d8588941ea4dfcbd67b4682ef40d7b409df63e6", "patch": "@@ -363,15 +363,22 @@ mod unsafe_impl_smoke_test {\n mod unsafe_impl_from_macro {\n     unsafe trait T {}\n \n-    macro_rules! unsafe_impl {\n+    macro_rules! no_safety_comment {\n         ($t:ty) => {\n             unsafe impl T for $t {}\n         };\n     }\n-    // ok: from macro expanision\n-    unsafe_impl!(());\n-    // ok: from macro expansion\n-    unsafe_impl!(i32);\n+    // error\n+    no_safety_comment!(());\n+\n+    macro_rules! with_safety_comment {\n+        ($t:ty) => {\n+            // SAFETY:\n+            unsafe impl T for $t {}\n+        };\n+    }\n+    // ok\n+    with_safety_comment!((i32));\n }\n \n #[rustfmt::skip]"}, {"sha": "3a1f647b06d84ee34fdd9f637f742acfba70279d", "filename": "tests/ui/undocumented_unsafe_blocks.stderr", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8d8588941ea4dfcbd67b4682ef40d7b409df63e6/tests%2Fui%2Fundocumented_unsafe_blocks.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8d8588941ea4dfcbd67b4682ef40d7b409df63e6/tests%2Fui%2Fundocumented_unsafe_blocks.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fundocumented_unsafe_blocks.stderr?ref=8d8588941ea4dfcbd67b4682ef40d7b409df63e6", "patch": "@@ -164,36 +164,48 @@ LL |         unsafe impl B for (u32) {}\n    = help: consider adding a safety comment on the preceding line\n \n error: unsafe impl missing a safety comment\n-  --> $DIR/undocumented_unsafe_blocks.rs:420:5\n+  --> $DIR/undocumented_unsafe_blocks.rs:368:13\n+   |\n+LL |             unsafe impl T for $t {}\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^\n+...\n+LL |     no_safety_comment!(());\n+   |     ---------------------- in this macro invocation\n+   |\n+   = help: consider adding a safety comment on the preceding line\n+   = note: this error originates in the macro `no_safety_comment` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: unsafe impl missing a safety comment\n+  --> $DIR/undocumented_unsafe_blocks.rs:427:5\n    |\n LL |     unsafe impl NoComment for () {}\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: consider adding a safety comment on the preceding line\n \n error: unsafe impl missing a safety comment\n-  --> $DIR/undocumented_unsafe_blocks.rs:424:19\n+  --> $DIR/undocumented_unsafe_blocks.rs:431:19\n    |\n LL |     /* SAFETY: */ unsafe impl InlineComment for () {}\n    |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: consider adding a safety comment on the preceding line\n \n error: unsafe impl missing a safety comment\n-  --> $DIR/undocumented_unsafe_blocks.rs:428:5\n+  --> $DIR/undocumented_unsafe_blocks.rs:435:5\n    |\n LL |     unsafe impl TrailingComment for () {} // SAFETY:\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: consider adding a safety comment on the preceding line\n \n error: unsafe impl missing a safety comment\n-  --> $DIR/undocumented_unsafe_blocks.rs:433:5\n+  --> $DIR/undocumented_unsafe_blocks.rs:440:5\n    |\n LL |     unsafe impl Interference for () {}\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: consider adding a safety comment on the preceding line\n \n-error: aborting due to 24 previous errors\n+error: aborting due to 25 previous errors\n "}]}