{"sha": "b6338e7792fab06e015cdf3a3d1c30ff9797673e", "node_id": "C_kwDOAAsO6NoAKGI2MzM4ZTc3OTJmYWIwNmUwMTVjZGYzYTNkMWMzMGZmOTc5NzY3M2U", "commit": {"author": {"name": "Will Crichton", "email": "wcrichto@cs.stanford.edu", "date": "2021-06-03T00:21:48Z"}, "committer": {"name": "Will Crichton", "email": "wcrichto@cs.stanford.edu", "date": "2021-10-07T02:44:50Z"}, "message": "Generate example source files with corresponding links\n\nAdd display name\n\nFix remaining merge conflicts\n\nOnly embed code for items containing examples", "tree": {"sha": "42afff8697ab6a138d6cdca247ef78495572d30c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/42afff8697ab6a138d6cdca247ef78495572d30c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b6338e7792fab06e015cdf3a3d1c30ff9797673e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b6338e7792fab06e015cdf3a3d1c30ff9797673e", "html_url": "https://github.com/rust-lang/rust/commit/b6338e7792fab06e015cdf3a3d1c30ff9797673e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b6338e7792fab06e015cdf3a3d1c30ff9797673e/comments", "author": {"login": "willcrichton", "id": 663326, "node_id": "MDQ6VXNlcjY2MzMyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/663326?v=4", "gravatar_id": "", "url": "https://api.github.com/users/willcrichton", "html_url": "https://github.com/willcrichton", "followers_url": "https://api.github.com/users/willcrichton/followers", "following_url": "https://api.github.com/users/willcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/willcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/willcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/willcrichton/subscriptions", "organizations_url": "https://api.github.com/users/willcrichton/orgs", "repos_url": "https://api.github.com/users/willcrichton/repos", "events_url": "https://api.github.com/users/willcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/willcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "willcrichton", "id": 663326, "node_id": "MDQ6VXNlcjY2MzMyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/663326?v=4", "gravatar_id": "", "url": "https://api.github.com/users/willcrichton", "html_url": "https://github.com/willcrichton", "followers_url": "https://api.github.com/users/willcrichton/followers", "following_url": "https://api.github.com/users/willcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/willcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/willcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/willcrichton/subscriptions", "organizations_url": "https://api.github.com/users/willcrichton/orgs", "repos_url": "https://api.github.com/users/willcrichton/repos", "events_url": "https://api.github.com/users/willcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/willcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2855bf039a574865c13c67a43cefbf8cead49c1b", "url": "https://api.github.com/repos/rust-lang/rust/commits/2855bf039a574865c13c67a43cefbf8cead49c1b", "html_url": "https://github.com/rust-lang/rust/commit/2855bf039a574865c13c67a43cefbf8cead49c1b"}], "stats": {"total": 268, "additions": 160, "deletions": 108}, "files": [{"sha": "2f8bae5ded0adfc03bdce445f4b7101f4e515a5f", "filename": "src/librustdoc/config.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b6338e7792fab06e015cdf3a3d1c30ff9797673e/src%2Flibrustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6338e7792fab06e015cdf3a3d1c30ff9797673e/src%2Flibrustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fconfig.rs?ref=b6338e7792fab06e015cdf3a3d1c30ff9797673e", "patch": "@@ -161,12 +161,9 @@ crate struct Options {\n     /// Whether to skip capturing stdout and stderr of tests.\n     crate nocapture: bool,\n \n-    // Options for scraping call sites from examples/ directory\n     /// Path to output file to write JSON of call sites. If this option is Some(..) then\n     /// the compiler will scrape examples and not generate documentation.\n     crate scrape_examples: Option<PathBuf>,\n-    /// Path to the root of the workspace, used to generate workspace-relative file paths.\n-    crate workspace_root: Option<PathBuf>,\n }\n \n impl fmt::Debug for Options {\n@@ -290,7 +287,6 @@ crate struct RenderOptions {\n     /// If `true`, HTML source pages will generate links for items to their definition.\n     crate generate_link_to_definition: bool,\n     crate call_locations: Option<AllCallLocations>,\n-    crate repository_url: Option<String>,\n }\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n@@ -682,9 +678,7 @@ impl Options {\n             return Err(1);\n         }\n \n-        let repository_url = matches.opt_str(\"repository-url\");\n         let scrape_examples = matches.opt_str(\"scrape-examples\").map(PathBuf::from);\n-        let workspace_root = matches.opt_str(\"workspace-root\").map(PathBuf::from);\n         let with_examples = matches.opt_strs(\"with-examples\");\n         let each_call_locations = with_examples\n             .into_iter()\n@@ -777,13 +771,11 @@ impl Options {\n                 emit,\n                 generate_link_to_definition,\n                 call_locations,\n-                repository_url,\n             },\n             crate_name,\n             output_format,\n             json_unused_externs,\n             scrape_examples,\n-            workspace_root,\n         })\n     }\n "}, {"sha": "fd53a3d7bfbc60a71af639562ae670c17f5210ae", "filename": "src/librustdoc/html/render/context.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b6338e7792fab06e015cdf3a3d1c30ff9797673e/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6338e7792fab06e015cdf3a3d1c30ff9797673e/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs?ref=b6338e7792fab06e015cdf3a3d1c30ff9797673e", "patch": "@@ -351,6 +351,7 @@ impl<'tcx> Context<'tcx> {\n         let hiline = span.hi(self.sess()).line;\n         let lines =\n             if loline == hiline { loline.to_string() } else { format!(\"{}-{}\", loline, hiline) };\n+\n         Some(format!(\n             \"{root}src/{krate}/{path}#{lines}\",\n             root = Escape(&root),"}, {"sha": "693a9d7b8a3e30ca23df8bb66f9a27041c459617", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 50, "deletions": 41, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/b6338e7792fab06e015cdf3a3d1c30ff9797673e/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6338e7792fab06e015cdf3a3d1c30ff9797673e/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=b6338e7792fab06e015cdf3a3d1c30ff9797673e", "patch": "@@ -70,7 +70,7 @@ use crate::html::format::{\n };\n use crate::html::markdown::{HeadingOffset, Markdown, MarkdownHtml, MarkdownSummaryLine};\n use crate::html::sources;\n-use crate::scrape_examples::FnCallLocations;\n+use crate::scrape_examples::{CallData, FnCallLocations};\n \n /// A pair of name and its optional document.\n crate type NameDoc = (String, Option<String>);\n@@ -2451,6 +2451,8 @@ fn collect_paths_for_type(first_ty: clean::Type, cache: &Cache) -> Vec<String> {\n     out\n }\n \n+const MAX_FULL_EXAMPLES: usize = 5;\n+\n fn render_call_locations(\n     w: &mut Buffer,\n     cx: &Context<'_>,\n@@ -2463,29 +2465,7 @@ fn render_call_locations(\n         }\n     };\n \n-    let filtered_locations: Vec<_> = call_locations\n-        .iter()\n-        .filter_map(|(file, locs)| {\n-            // FIXME(wcrichto): file I/O should be cached\n-            let mut contents = match fs::read_to_string(&file) {\n-                Ok(contents) => contents,\n-                Err(e) => {\n-                    eprintln!(\"Failed to read file {}\", e);\n-                    return None;\n-                }\n-            };\n-\n-            // Remove the utf-8 BOM if any\n-            if contents.starts_with('\\u{feff}') {\n-                contents.drain(..3);\n-            }\n-\n-            Some((file, contents, locs))\n-        })\n-        .collect();\n-\n-    let n_examples = filtered_locations.len();\n-    if n_examples == 0 {\n+    if call_locations.len() == 0 {\n         return;\n     }\n \n@@ -2499,35 +2479,55 @@ fn render_call_locations(\n         id\n     );\n \n-    let write_example = |w: &mut Buffer, (file, contents, locs): (&String, String, _)| {\n-        let ex_title = match cx.shared.repository_url.as_ref() {\n-            Some(url) => format!(\n-                r#\"<a href=\"{url}/{file}\" target=\"_blank\">{file}</a>\"#,\n-                file = file,\n-                url = url\n-            ),\n-            None => file.clone(),\n-        };\n+    let example_url = |call_data: &CallData| -> String {\n+        format!(\n+            r#\"<a href=\"{root}{url}\" target=\"_blank\">{name}</a>\"#,\n+            root = cx.root_path(),\n+            url = call_data.url,\n+            name = call_data.display_name\n+        )\n+    };\n+\n+    let write_example = |w: &mut Buffer, (path, call_data): (&PathBuf, &CallData)| {\n+        let mut contents =\n+            fs::read_to_string(&path).expect(&format!(\"Failed to read file: {}\", path.display()));\n+\n+        let min_loc =\n+            call_data.locations.iter().min_by_key(|loc| loc.enclosing_item_span.0).unwrap();\n+        let min_byte = min_loc.enclosing_item_span.0;\n+        let min_line = min_loc.enclosing_item_lines.0;\n+        let max_byte =\n+            call_data.locations.iter().map(|loc| loc.enclosing_item_span.1).max().unwrap();\n+        contents = contents[min_byte..max_byte].to_string();\n+\n+        let locations = call_data\n+            .locations\n+            .iter()\n+            .map(|loc| (loc.call_span.0 - min_byte, loc.call_span.1 - min_byte))\n+            .collect::<Vec<_>>();\n+\n         let edition = cx.shared.edition();\n         write!(\n             w,\n             r#\"<div class=\"scraped-example\" data-code=\"{code}\" data-locs=\"{locations}\">\n-           <strong>{title}</strong>\n-           <div class=\"code-wrapper\">\"#,\n+                <strong>{title}</strong>\n+                 <div class=\"code-wrapper\">\"#,\n             code = contents.replace(\"\\\"\", \"&quot;\"),\n-            locations = serde_json::to_string(&locs).unwrap(),\n-            title = ex_title,\n+            locations = serde_json::to_string(&locations).unwrap(),\n+            title = example_url(call_data),\n         );\n         write!(w, r#\"<span class=\"prev\">&pr;</span> <span class=\"next\">&sc;</span>\"#);\n         write!(w, r#\"<span class=\"expand\">&varr;</span>\"#);\n-        sources::print_src(w, &contents, edition);\n+        let file_span = rustc_span::DUMMY_SP;\n+        let root_path = \"\".to_string();\n+        sources::print_src(w, &contents, edition, file_span, cx, &root_path, Some(min_line));\n         write!(w, \"</div></div>\");\n     };\n \n-    let mut it = filtered_locations.into_iter();\n+    let mut it = call_locations.into_iter().peekable();\n     write_example(w, it.next().unwrap());\n \n-    if n_examples > 1 {\n+    if it.peek().is_some() {\n         write!(\n             w,\n             r#\"<details class=\"rustdoc-toggle more-examples-toggle\">\n@@ -2536,7 +2536,16 @@ fn render_call_locations(\n                   </summary>\n                   <div class=\"more-scraped-examples\">\"#\n         );\n-        it.for_each(|ex| write_example(w, ex));\n+        (&mut it).take(MAX_FULL_EXAMPLES).for_each(|ex| write_example(w, ex));\n+\n+        if it.peek().is_some() {\n+            write!(w, \"Additional examples can be found in:<br /><ul>\");\n+            it.for_each(|(_, call_data)| {\n+                write!(w, \"<li>{}</li>\", example_url(call_data));\n+            });\n+            write!(w, \"</ul>\");\n+        }\n+\n         write!(w, \"</div></details>\");\n     }\n "}, {"sha": "6bd335a9b96bbcaf4cfe971e22ce58198b958b42", "filename": "src/librustdoc/html/sources.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b6338e7792fab06e015cdf3a3d1c30ff9797673e/src%2Flibrustdoc%2Fhtml%2Fsources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6338e7792fab06e015cdf3a3d1c30ff9797673e/src%2Flibrustdoc%2Fhtml%2Fsources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fsources.rs?ref=b6338e7792fab06e015cdf3a3d1c30ff9797673e", "patch": "@@ -204,7 +204,15 @@ impl SourceCollector<'_, 'tcx> {\n             &page,\n             \"\",\n             |buf: &mut _| {\n-                print_src(buf, contents, self.cx.shared.edition(), file_span, &self.cx, &root_path)\n+                print_src(\n+                    buf,\n+                    contents,\n+                    self.cx.shared.edition(),\n+                    file_span,\n+                    &self.cx,\n+                    &root_path,\n+                    None,\n+                )\n             },\n             &self.cx.shared.style_files,\n         );\n@@ -250,6 +258,7 @@ crate fn print_src(\n     file_span: rustc_span::Span,\n     context: &Context<'_>,\n     root_path: &str,\n+    offset: Option<usize>,\n ) {\n     let lines = s.lines().count();\n     let mut line_numbers = Buffer::empty_from(buf);\n@@ -260,8 +269,9 @@ crate fn print_src(\n         tmp /= 10;\n     }\n     line_numbers.write_str(\"<pre class=\\\"line-numbers\\\">\");\n+    let offset = offset.unwrap_or(0);\n     for i in 1..=lines {\n-        writeln!(line_numbers, \"<span id=\\\"{0}\\\">{0:1$}</span>\", i, cols);\n+        writeln!(line_numbers, \"<span id=\\\"{0}\\\">{0:1$}</span>\", i + offset, cols);\n     }\n     line_numbers.write_str(\"</pre>\");\n     highlight::render_with_highlighting("}, {"sha": "89a205be023afe03915e28907386d21a6420e6f1", "filename": "src/librustdoc/html/static/css/rustdoc.css", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b6338e7792fab06e015cdf3a3d1c30ff9797673e/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/b6338e7792fab06e015cdf3a3d1c30ff9797673e/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css?ref=b6338e7792fab06e015cdf3a3d1c30ff9797673e", "patch": "@@ -453,7 +453,7 @@ nav.sub {\n \ttext-decoration: underline;\n }\n \n-.rustdoc:not(.source) .example-wrap > pre:not(.line-number) {\n+.rustdoc:not(.source) .example-wrap > pre:not(.line-numbers) {\n \twidth: 100%;\n \toverflow-x: auto;\n }"}, {"sha": "b7407ee409f3453b357e987043a6218f5d169177", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b6338e7792fab06e015cdf3a3d1c30ff9797673e/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6338e7792fab06e015cdf3a3d1c30ff9797673e/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=b6338e7792fab06e015cdf3a3d1c30ff9797673e", "patch": "@@ -620,8 +620,6 @@ fn opts() -> Vec<RustcOptGroup> {\n             )\n         }),\n         unstable(\"scrape-examples\", |o| o.optopt(\"\", \"scrape-examples\", \"\", \"\")),\n-        unstable(\"workspace-root\", |o| o.optopt(\"\", \"workspace-root\", \"\", \"\")),\n-        unstable(\"repository-url\", |o| o.optopt(\"\", \"repository-url\", \"\", \"\")),\n         unstable(\"with-examples\", |o| o.optmulti(\"\", \"with-examples\", \"\", \"\")),\n     ]\n }\n@@ -705,17 +703,16 @@ fn run_renderer<'tcx, T: formats::FormatRenderer<'tcx>>(\n fn main_options(options: config::Options) -> MainResult {\n     let diag = core::new_handler(options.error_format, None, &options.debugging_opts);\n \n-    match (options.should_test, options.markdown_input(), options.scrape_examples.is_some()) {\n-        (_, _, true) => return scrape_examples::run(options),\n-        (true, true, false) => return wrap_return(&diag, markdown::test(options)),\n-        (true, false, false) => return doctest::run(options),\n-        (false, true, false) => {\n+    match (options.should_test, options.markdown_input()) {\n+        (true, true) => return wrap_return(&diag, markdown::test(options)),\n+        (true, false) => return doctest::run(options),\n+        (false, true) => {\n             return wrap_return(\n                 &diag,\n                 markdown::render(&options.input, options.render_options, options.edition),\n             );\n         }\n-        (false, false, false) => {}\n+        (false, false) => {}\n     }\n \n     // need to move these items separately because we lose them by the time the closure is called,\n@@ -737,6 +734,7 @@ fn main_options(options: config::Options) -> MainResult {\n     // FIXME: fix this clone (especially render_options)\n     let manual_passes = options.manual_passes.clone();\n     let render_options = options.render_options.clone();\n+    let scrape_examples = options.scrape_examples.clone();\n     let config = core::create_config(options);\n \n     interface::create_compiler_and_run(config, |compiler| {\n@@ -773,6 +771,10 @@ fn main_options(options: config::Options) -> MainResult {\n                 });\n                 info!(\"finished with rustc\");\n \n+                if let Some(example_path) = scrape_examples {\n+                    return scrape_examples::run(krate, render_opts, cache, tcx, example_path);\n+                }\n+\n                 cache.crate_version = crate_version;\n \n                 if show_coverage {"}, {"sha": "950af8fbb63283b80e12068123d668d0356058cd", "filename": "src/librustdoc/scrape_examples.rs", "status": "modified", "additions": 86, "deletions": 48, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/b6338e7792fab06e015cdf3a3d1c30ff9797673e/src%2Flibrustdoc%2Fscrape_examples.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b6338e7792fab06e015cdf3a3d1c30ff9797673e/src%2Flibrustdoc%2Fscrape_examples.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fscrape_examples.rs?ref=b6338e7792fab06e015cdf3a3d1c30ff9797673e", "patch": "@@ -1,8 +1,12 @@\n //! This module analyzes provided crates to find examples of uses for items in the\n //! current crate being documented.\n \n-use crate::config::Options;\n-use crate::doctest::make_rustc_config;\n+use crate::clean;\n+use crate::config;\n+use crate::formats;\n+use crate::formats::renderer::FormatRenderer;\n+use crate::html::render::Context;\n+\n use rustc_data_structures::fx::FxHashMap;\n use rustc_hir::{\n     self as hir,\n@@ -11,23 +15,33 @@ use rustc_hir::{\n use rustc_interface::interface;\n use rustc_middle::hir::map::Map;\n use rustc_middle::ty::{self, TyCtxt};\n-use rustc_span::def_id::DefId;\n+use rustc_span::{def_id::DefId, FileName};\n+use serde::{Deserialize, Serialize};\n use std::fs;\n+use std::path::PathBuf;\n+\n+#[derive(Serialize, Deserialize, Debug, Clone)]\n+crate struct CallLocation {\n+    crate call_span: (usize, usize),\n+    crate enclosing_item_span: (usize, usize),\n+    crate enclosing_item_lines: (usize, usize),\n+}\n \n+#[derive(Serialize, Deserialize, Debug, Clone)]\n+crate struct CallData {\n+    crate locations: Vec<CallLocation>,\n+    crate url: String,\n+    crate display_name: String,\n+}\n crate type DefIdCallKey = String;\n-crate type FnCallLocations = FxHashMap<String, Vec<(usize, usize)>>;\n+crate type FnCallLocations = FxHashMap<PathBuf, CallData>;\n crate type AllCallLocations = FxHashMap<DefIdCallKey, FnCallLocations>;\n \n /// Visitor for traversing a crate and finding instances of function calls.\n struct FindCalls<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     map: Map<'tcx>,\n-\n-    /// Workspace-relative path to the root of the crate. Used to remember\n-    /// which example a particular call came from.\n-    file_path: String,\n-\n-    /// Data structure to accumulate call sites across all examples.\n+    cx: Context<'tcx>,\n     calls: &'a mut AllCallLocations,\n }\n \n@@ -68,51 +82,75 @@ where\n             }\n         };\n \n+        if span.from_expansion() {\n+            return;\n+        }\n+\n         // Save call site if the function resolves to a concrete definition\n         if let ty::FnDef(def_id, _) = ty.kind() {\n-            let key = def_id_call_key(self.tcx, *def_id);\n-            let entries = self.calls.entry(key).or_insert_with(FxHashMap::default);\n-            entries\n-                .entry(self.file_path.clone())\n-                .or_insert_with(Vec::new)\n-                .push((span.lo().0 as usize, span.hi().0 as usize));\n+            let fn_key = def_id_call_key(self.tcx, *def_id);\n+            let entries = self.calls.entry(fn_key).or_insert_with(FxHashMap::default);\n+            let file = self.tcx.sess.source_map().lookup_char_pos(span.lo()).file;\n+            let file_path = match file.name.clone() {\n+                FileName::Real(real_filename) => real_filename.into_local_path(),\n+                _ => None,\n+            };\n+\n+            let get_pos =\n+                |bytepos: rustc_span::BytePos| file.original_relative_byte_pos(bytepos).0 as usize;\n+            let get_range = |span: rustc_span::Span| (get_pos(span.lo()), get_pos(span.hi()));\n+            let get_line = |bytepos: rustc_span::BytePos| file.lookup_line(bytepos).unwrap();\n+            let get_lines = |span: rustc_span::Span| (get_line(span.lo()), get_line(span.hi()));\n+\n+            if let Some(file_path) = file_path {\n+                let abs_path = fs::canonicalize(file_path.clone()).unwrap();\n+                let cx = &self.cx;\n+                let enclosing_item_span =\n+                    self.tcx.hir().span_with_body(self.tcx.hir().get_parent_item(ex.hir_id));\n+                assert!(enclosing_item_span.contains(span));\n+\n+                let location = CallLocation {\n+                    call_span: get_range(span),\n+                    enclosing_item_span: get_range(enclosing_item_span),\n+                    enclosing_item_lines: get_lines(enclosing_item_span),\n+                };\n+\n+                entries\n+                    .entry(abs_path)\n+                    .or_insert_with(|| {\n+                        let clean_span = crate::clean::types::Span::new(span);\n+                        let url = cx.href_from_span(clean_span).unwrap();\n+                        let display_name = file_path.display().to_string();\n+                        CallData { locations: Vec::new(), url, display_name }\n+                    })\n+                    .locations\n+                    .push(location);\n+            }\n         }\n     }\n }\n \n-crate fn run(options: Options) -> interface::Result<()> {\n+crate fn run(\n+    krate: clean::Crate,\n+    renderopts: config::RenderOptions,\n+    cache: formats::cache::Cache,\n+    tcx: TyCtxt<'tcx>,\n+    example_path: PathBuf,\n+) -> interface::Result<()> {\n     let inner = move || {\n-        let config = make_rustc_config(&options);\n-\n-        // Get input file path as relative to workspace root\n-        let file_path = options\n-            .input\n-            .strip_prefix(options.workspace_root.as_ref().unwrap())\n-            .map_err(|e| format!(\"{}\", e))?;\n-\n-        interface::run_compiler(config, |compiler| {\n-            compiler.enter(|queries| {\n-                let mut global_ctxt = queries.global_ctxt().unwrap().take();\n-                global_ctxt.enter(|tcx| {\n-                    // Run call-finder on all items\n-                    let mut calls = FxHashMap::default();\n-                    let mut finder = FindCalls {\n-                        calls: &mut calls,\n-                        tcx,\n-                        map: tcx.hir(),\n-                        file_path: file_path.display().to_string(),\n-                    };\n-                    tcx.hir().krate().visit_all_item_likes(&mut finder.as_deep_visitor());\n-\n-                    // Save output JSON to provided path\n-                    let calls_json = serde_json::to_string(&calls).map_err(|e| format!(\"{}\", e))?;\n-                    fs::write(options.scrape_examples.as_ref().unwrap(), &calls_json)\n-                        .map_err(|e| format!(\"{}\", e))?;\n-\n-                    Ok(())\n-                })\n-            })\n-        })\n+        // Generates source files for examples\n+        let (cx, _) = Context::init(krate, renderopts, cache, tcx).map_err(|e| format!(\"{}\", e))?;\n+\n+        // Run call-finder on all items\n+        let mut calls = FxHashMap::default();\n+        let mut finder = FindCalls { calls: &mut calls, tcx, map: tcx.hir(), cx };\n+        tcx.hir().krate().visit_all_item_likes(&mut finder.as_deep_visitor());\n+\n+        // Save output JSON to provided path\n+        let calls_json = serde_json::to_string(&calls).map_err(|e| format!(\"{}\", e))?;\n+        fs::write(example_path, &calls_json).map_err(|e| format!(\"{}\", e))?;\n+\n+        Ok(())\n     };\n \n     inner().map_err(|e: String| {"}]}