{"sha": "782a6debe4542788a6c455070e06fb1137941376", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc4MmE2ZGViZTQ1NDI3ODhhNmM0NTUwNzBlMDZmYjExMzc5NDEzNzY=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-03-24T15:41:09Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-03-24T15:41:09Z"}, "message": "Revert changes to creation of fictive constructors for struct variants", "tree": {"sha": "fcff70564bc7c461e88eb2130831c05cdaa4bf07", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fcff70564bc7c461e88eb2130831c05cdaa4bf07"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/782a6debe4542788a6c455070e06fb1137941376", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/782a6debe4542788a6c455070e06fb1137941376", "html_url": "https://github.com/rust-lang/rust/commit/782a6debe4542788a6c455070e06fb1137941376", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/782a6debe4542788a6c455070e06fb1137941376/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2cbc25e6fce9bb594ea78ccfd58ef1b6ea42ea38", "url": "https://api.github.com/repos/rust-lang/rust/commits/2cbc25e6fce9bb594ea78ccfd58ef1b6ea42ea38", "html_url": "https://github.com/rust-lang/rust/commit/2cbc25e6fce9bb594ea78ccfd58ef1b6ea42ea38"}], "stats": {"total": 91, "additions": 29, "deletions": 62}, "files": [{"sha": "32aa75166aec03d9b9c173623c7ea5d380a5fb06", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/782a6debe4542788a6c455070e06fb1137941376/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/782a6debe4542788a6c455070e06fb1137941376/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=782a6debe4542788a6c455070e06fb1137941376", "patch": "@@ -822,14 +822,16 @@ impl<'a, 'tcx> CrateMetadata {\n                                 callback(def::Export { def: ctor_def, vis, ident, span });\n                             }\n                         }\n-                        Def::Variant(..) => {\n-                            if let Some(ctor_def_id) = self.get_ctor_def_id(child_index) {\n-                                let ctor_kind = self.get_ctor_kind(child_index);\n-                                let ctor_def = Def::Ctor(\n-                                    hir::CtorOf::Variant, ctor_def_id, ctor_kind);\n-                                let vis = self.get_visibility(ctor_def_id.index);\n-                                callback(def::Export { def: ctor_def, ident, vis, span });\n-                            }\n+                        Def::Variant(def_id) => {\n+                            // Braced variants, unlike structs, generate unusable names in\n+                            // value namespace, they are reserved for possible future use.\n+                            // It's ok to use the variant's id as a ctor id since an\n+                            // error will be reported on any use of such resolution anyway.\n+                            let ctor_def_id = self.get_ctor_def_id(child_index).unwrap_or(def_id);\n+                            let ctor_kind = self.get_ctor_kind(child_index);\n+                            let ctor_def = Def::Ctor(hir::CtorOf::Variant, ctor_def_id, ctor_kind);\n+                            let vis = self.get_visibility(ctor_def_id.index);\n+                            callback(def::Export { def: ctor_def, ident, vis, span });\n                         }\n                         _ => {}\n                     }"}, {"sha": "0cb6872ce76544f8d586079f6ec65be87a1bfec7", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 13, "deletions": 45, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/782a6debe4542788a6c455070e06fb1137941376/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/782a6debe4542788a6c455070e06fb1137941376/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=782a6debe4542788a6c455070e06fb1137941376", "patch": "@@ -582,31 +582,22 @@ impl<'a> Resolver<'a> {\n                                        vis: ty::Visibility,\n                                        expansion: Mark) {\n         let ident = variant.node.ident;\n-        let def_id = self.definitions.local_def_id(variant.node.id);\n \n         // Define a name in the type namespace.\n+        let def_id = self.definitions.local_def_id(variant.node.id);\n         let def = Def::Variant(def_id);\n         self.define(parent, ident, TypeNS, (def, vis, variant.span, expansion));\n \n         // Define a constructor name in the value namespace.\n         // Braced variants, unlike structs, generate unusable names in\n         // value namespace, they are reserved for possible future use.\n-        if let Some(ctor_node_id) = variant.node.data.ctor_id() {\n-            let ctor_def_id = self.definitions.local_def_id(ctor_node_id);\n-            let ctor_kind = CtorKind::from_ast(&variant.node.data);\n-            let ctor_def = Def::Ctor(hir::CtorOf::Variant, ctor_def_id, ctor_kind);\n-\n-            self.define(parent, ident, ValueNS, (ctor_def, vis, variant.span, expansion));\n-        } else {\n-            // We normally don't have a `Def::Ctor(hir::CtorOf::Variant, ..)` for\n-            // `Struct`-variants, but we must define one for name resolution to succeed. This also\n-            // takes place in `build_reduced_graph_for_external_crate_def`.\n-            let def_id = self.definitions.local_def_id(variant.node.id);\n-            let ctor_kind = CtorKind::from_ast(&variant.node.data);\n-            let ctor_def = Def::Ctor(hir::CtorOf::Variant, def_id, ctor_kind);\n-\n-            self.define(parent, ident, ValueNS, (ctor_def, vis, variant.span, expansion));\n-        }\n+        // It's ok to use the variant's id as a ctor id since an\n+        // error will be reported on any use of such resolution anyway.\n+        let ctor_node_id = variant.node.data.ctor_id().unwrap_or(variant.node.id);\n+        let ctor_def_id = self.definitions.local_def_id(ctor_node_id);\n+        let ctor_kind = CtorKind::from_ast(&variant.node.data);\n+        let ctor_def = Def::Ctor(hir::CtorOf::Variant, ctor_def_id, ctor_kind);\n+        self.define(parent, ident, ValueNS, (ctor_def, vis, variant.span, expansion));\n     }\n \n     /// Constructs the reduced graph for one foreign item.\n@@ -658,27 +649,13 @@ impl<'a> Resolver<'a> {\n                                              span);\n                 self.define(parent, ident, TypeNS, (module, vis, DUMMY_SP, expansion));\n             }\n-            Def::Variant(def_id) => {\n+            Def::Variant(..) | Def::TyAlias(..) | Def::ForeignTy(..) | Def::Existential(..) |\n+            Def::TraitAlias(..) | Def::PrimTy(..) | Def::ToolMod => {\n                 self.define(parent, ident, TypeNS, (def, vis, DUMMY_SP, expansion));\n-\n-                if hir::def::CtorKind::Fictive == self.cstore.ctor_kind_untracked(def_id) {\n-                    // We do not normally generate `Def::Ctor(hir::CtorOf::Variant, ..)` for\n-                    // `Struct`-variants. Therefore, `build_reduced_graph_for_external_crate_def`\n-                    // will not be called to define one. However, name resolution currently expects\n-                    // there to be one, so we generate one here. This is easy to solve for local\n-                    // code, see `build_reduced_graph_for_variant` for this case.\n-                    let ctor_def = Def::Ctor(hir::CtorOf::Variant, def_id,\n-                                             hir::def::CtorKind::Fictive);\n-\n-                    let _ = self.try_define(\n-                        parent, ident, ValueNS,\n-                        (ctor_def, vis, DUMMY_SP, expansion).to_name_binding(self.arenas),\n-                    );\n-                }\n             }\n-            Def::TyAlias(..) | Def::ForeignTy(..) | Def::Existential(..) | Def::TraitAlias(..) |\n-            Def::PrimTy(..) | Def::ToolMod => {\n-                self.define(parent, ident, TypeNS, (def, vis, DUMMY_SP, expansion));\n+            Def::Fn(..) | Def::Static(..) | Def::Const(..) |\n+            Def::Ctor(hir::CtorOf::Variant, ..) => {\n+                self.define(parent, ident, ValueNS, (def, vis, DUMMY_SP, expansion));\n             }\n             Def::Ctor(hir::CtorOf::Struct, def_id, ..) => {\n                 self.define(parent, ident, ValueNS, (def, vis, DUMMY_SP, expansion));\n@@ -689,15 +666,6 @@ impl<'a> Resolver<'a> {\n                     self.struct_constructors.insert(struct_def_id, (def, vis));\n                 }\n             }\n-            Def::Ctor(hir::CtorOf::Variant, ..) => {\n-                let _ = self.try_define(\n-                    parent, ident, ValueNS,\n-                    (def, vis, DUMMY_SP, expansion).to_name_binding(self.arenas),\n-                );\n-            }\n-            Def::Fn(..) | Def::Static(..) | Def::Const(..) => {\n-                self.define(parent, ident, ValueNS, (def, vis, DUMMY_SP, expansion));\n-            }\n             Def::Trait(def_id) => {\n                 let module_kind = ModuleKind::Def(def, ident.name);\n                 let module = self.new_module(parent,"}, {"sha": "26024ece05427c036b709271f11ccbdd68c4beea", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/782a6debe4542788a6c455070e06fb1137941376/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/782a6debe4542788a6c455070e06fb1137941376/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=782a6debe4542788a6c455070e06fb1137941376", "patch": "@@ -417,15 +417,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 if let Some(variant_def) = variant_def {\n                     check_type_alias_enum_variants_enabled(tcx, span);\n \n-                    let def = if let Some(ctor_def_id) = variant_def.ctor_def_id {\n-                        Def::Ctor(hir::CtorOf::Variant, ctor_def_id, variant_def.ctor_kind)\n-                    } else {\n-                        // Normally, there do not exist any `Def::Ctor` for `Struct`-variants but\n-                        // in this case, we can get better error messages as diagnostics will\n-                        // specialize the message around a `CtorKind::Fictive`.\n-                        Def::Ctor(hir::CtorOf::Variant, variant_def.def_id,\n-                                  hir::def::CtorKind::Fictive)\n-                    };\n+                    // Braced variants generate unusable names in value namespace (reserved for\n+                    // possible future use), so variants resolved as associated items may refer to\n+                    // them as well. It's ok to use the variant's id as a ctor id since an\n+                    // error will be reported on any use of such resolution anyway.\n+                    let ctor_def_id = variant_def.ctor_def_id.unwrap_or(variant_def.def_id);\n+                    let def = Def::Ctor(hir::CtorOf::Variant, ctor_def_id, variant_def.ctor_kind);\n \n                     tcx.check_stability(def.def_id(), Some(expr_id), span);\n                     return Ok(def);"}]}