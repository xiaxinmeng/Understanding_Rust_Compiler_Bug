{"sha": "4c66658f2c51df8d7d97c975395cc161b8df2f98", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRjNjY2NThmMmM1MWRmOGQ3ZDk3Yzk3NTM5NWNjMTYxYjhkZjJmOTg=", "commit": {"author": {"name": "Paul Dicker", "email": "pitdicker@gmail.com", "date": "2019-11-04T19:49:47Z"}, "committer": {"name": "Paul Dicker", "email": "pitdicker@gmail.com", "date": "2019-11-05T06:15:35Z"}, "message": "Don't mutate node.next", "tree": {"sha": "6eca93f6ad00b25adb42436e723bc28b62e00bb9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6eca93f6ad00b25adb42436e723bc28b62e00bb9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4c66658f2c51df8d7d97c975395cc161b8df2f98", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4c66658f2c51df8d7d97c975395cc161b8df2f98", "html_url": "https://github.com/rust-lang/rust/commit/4c66658f2c51df8d7d97c975395cc161b8df2f98", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4c66658f2c51df8d7d97c975395cc161b8df2f98/comments", "author": {"login": "pitdicker", "id": 6255050, "node_id": "MDQ6VXNlcjYyNTUwNTA=", "avatar_url": "https://avatars.githubusercontent.com/u/6255050?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pitdicker", "html_url": "https://github.com/pitdicker", "followers_url": "https://api.github.com/users/pitdicker/followers", "following_url": "https://api.github.com/users/pitdicker/following{/other_user}", "gists_url": "https://api.github.com/users/pitdicker/gists{/gist_id}", "starred_url": "https://api.github.com/users/pitdicker/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pitdicker/subscriptions", "organizations_url": "https://api.github.com/users/pitdicker/orgs", "repos_url": "https://api.github.com/users/pitdicker/repos", "events_url": "https://api.github.com/users/pitdicker/events{/privacy}", "received_events_url": "https://api.github.com/users/pitdicker/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pitdicker", "id": 6255050, "node_id": "MDQ6VXNlcjYyNTUwNTA=", "avatar_url": "https://avatars.githubusercontent.com/u/6255050?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pitdicker", "html_url": "https://github.com/pitdicker", "followers_url": "https://api.github.com/users/pitdicker/followers", "following_url": "https://api.github.com/users/pitdicker/following{/other_user}", "gists_url": "https://api.github.com/users/pitdicker/gists{/gist_id}", "starred_url": "https://api.github.com/users/pitdicker/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pitdicker/subscriptions", "organizations_url": "https://api.github.com/users/pitdicker/orgs", "repos_url": "https://api.github.com/users/pitdicker/repos", "events_url": "https://api.github.com/users/pitdicker/events{/privacy}", "received_events_url": "https://api.github.com/users/pitdicker/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3712bb68c4f76161b54dcade7c1497b3ffc32e11", "url": "https://api.github.com/repos/rust-lang/rust/commits/3712bb68c4f76161b54dcade7c1497b3ffc32e11", "html_url": "https://github.com/rust-lang/rust/commit/3712bb68c4f76161b54dcade7c1497b3ffc32e11"}], "stats": {"total": 70, "additions": 34, "deletions": 36}, "files": [{"sha": "252a2d4319f3470f011f2ffb44e871aa6ed07c9c", "filename": "src/libstd/sync/once.rs", "status": "modified", "additions": 34, "deletions": 36, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/4c66658f2c51df8d7d97c975395cc161b8df2f98/src%2Flibstd%2Fsync%2Fonce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c66658f2c51df8d7d97c975395cc161b8df2f98/src%2Flibstd%2Fsync%2Fonce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fonce.rs?ref=4c66658f2c51df8d7d97c975395cc161b8df2f98", "patch": "@@ -87,7 +87,6 @@\n use crate::cell::Cell;\n use crate::fmt;\n use crate::marker;\n-use crate::ptr;\n use crate::sync::atomic::{AtomicUsize, AtomicBool, Ordering};\n use crate::thread::{self, Thread};\n \n@@ -432,48 +431,47 @@ impl Once {\n     }\n }\n \n-fn wait(state_and_queue: &AtomicUsize, current_state: usize) {\n-    // Create the node for our current thread that we are going to try to slot\n-    // in at the head of the linked list.\n-    let mut node = Waiter {\n-        thread: Cell::new(Some(thread::current())),\n-        signaled: AtomicBool::new(false),\n-        next: ptr::null(),\n-    };\n-    let me = &node as *const Waiter as usize;\n-    assert!(me & STATE_MASK == 0); // We assume pointers have 2 free bits that\n-                                   // we can use for state.\n-\n-    // Try to slide in the node at the head of the linked list.\n-    // Run in a loop where we make sure the status is still RUNNING, and that\n-    // another thread did not just replace the head of the linked list.\n-    let mut old_head_and_status = current_state;\n+fn wait(state_and_queue: &AtomicUsize, mut current_state: usize) {\n+    // Note: the following code was carefully written to avoid creating a\n+    // mutable reference to `node` that gets aliased.\n     loop {\n-        if old_head_and_status & STATE_MASK != RUNNING {\n-            return; // No need anymore to enqueue ourselves.\n+        // Don't queue this thread if the status is no longer running,\n+        // otherwise we will not be woken up.\n+        if current_state & STATE_MASK != RUNNING {\n+            return;\n         }\n \n-        node.next = (old_head_and_status & !STATE_MASK) as *const Waiter;\n-        let old = state_and_queue.compare_and_swap(old_head_and_status,\n+        // Create the node for our current thread.\n+        let node = Waiter {\n+            thread: Cell::new(Some(thread::current())),\n+            signaled: AtomicBool::new(false),\n+            next: (current_state & !STATE_MASK) as *const Waiter,\n+        };\n+        let me = &node as *const Waiter as usize;\n+\n+        // Try to slide in the node at the head of the linked list, making sure\n+        // that another thread didn't just replace the head of the linked list.\n+        let old = state_and_queue.compare_and_swap(current_state,\n                                                    me | RUNNING,\n                                                    Ordering::Release);\n-        if old == old_head_and_status {\n-            break; // Success!\n+        if old != current_state {\n+            current_state = old;\n+            continue;\n         }\n-        old_head_and_status = old;\n-    }\n \n-    // We have enqueued ourselves, now lets wait.\n-    // It is important not to return before being signaled, otherwise we would\n-    // drop our `Waiter` node and leave a hole in the linked list (and a\n-    // dangling reference). Guard against spurious wakeups by reparking\n-    // ourselves until we are signaled.\n-    while !node.signaled.load(Ordering::Acquire) {\n-        // If the managing thread happens to signal and unpark us before we can\n-        // park ourselves, the result could be this thread never gets unparked.\n-        // Luckily `park` comes with the guarantee that if it got an `unpark`\n-        // just before on an unparked thread is does not park.\n-        thread::park();\n+        // We have enqueued ourselves, now lets wait.\n+        // It is important not to return before being signaled, otherwise we\n+        // would drop our `Waiter` node and leave a hole in the linked list\n+        // (and a dangling reference). Guard against spurious wakeups by\n+        // reparking ourselves until we are signaled.\n+        while !node.signaled.load(Ordering::Acquire) {\n+            // If the managing thread happens to signal and unpark us before we\n+            // can park ourselves, the result could be this thread never gets\n+            // unparked. Luckily `park` comes with the guarantee that if it got\n+            // an `unpark` just before on an unparked thread is does not park.\n+            thread::park();\n+        }\n+        break;\n     }\n }\n "}]}