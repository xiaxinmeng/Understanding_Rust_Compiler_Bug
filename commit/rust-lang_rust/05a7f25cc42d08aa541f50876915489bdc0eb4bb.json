{"sha": "05a7f25cc42d08aa541f50876915489bdc0eb4bb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA1YTdmMjVjYzQyZDA4YWE1NDFmNTA4NzY5MTU0ODliZGMwZWI0YmI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-02-13T02:32:09Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-02-13T02:32:09Z"}, "message": "Auto merge of #39456 - nagisa:mir-switchint-everywhere, r=nikomatsakis\n\n[MIR] SwitchInt Everywhere\n\nSomething I've been meaning to do for a very long while. This PR essentially gets rid of 3 kinds of conditional branching and only keeps the most general one - `SwitchInt`. Primary benefits are such that dealing with MIR now does not involve dealing with 3 different ways to do conditional control flow. On the other hand, constructing a `SwitchInt` currently requires more code than what previously was necessary to build an equivalent `If` terminator. Something trivially \"fixable\" with some constructor methods somewhere (MIR needs stuff like that badly in general).\n\nSome timings (tl;dr: slightly faster^1 (unexpected), but also uses slightly more memory at peak (expected)):\n\n^1: Not sure if the speed benefits are because of LLVM liking the generated code better or the compiler itself getting compiled better. Either way, its a net benefit. The CORE and SYNTAX timings done for compilation without optimisation.\n\n```\nAFTER:\nBuilding stage1 std artifacts (x86_64-unknown-linux-gnu -> x86_64-unknown-linux-gnu)\n    Finished release [optimized] target(s) in 31.50 secs\n    Finished release [optimized] target(s) in 31.42 secs\nBuilding stage1 compiler artifacts (x86_64-unknown-linux-gnu -> x86_64-unknown-linux-gnu)\n    Finished release [optimized] target(s) in 439.56 secs\n    Finished release [optimized] target(s) in 435.15 secs\n\nCORE: 99% (24.81 real, 0.13 kernel, 24.57 user); 358536k resident\nCORE: 99% (24.56 real, 0.15 kernel, 24.36 user); 359168k resident\nSYNTAX: 99% (49.98 real, 0.48 kernel, 49.42 user); 653416k resident\nSYNTAX: 99% (50.07 real, 0.58 kernel, 49.43 user); 653604k resident\n\nBEFORE:\nBuilding stage1 std artifacts (x86_64-unknown-linux-gnu -> x86_64-unknown-linux-gnu)\n    Finished release [optimized] target(s) in 31.84 secs\nBuilding stage1 compiler artifacts (x86_64-unknown-linux-gnu -> x86_64-unknown-linux-gnu)\n    Finished release [optimized] target(s) in 451.17 secs\n\nCORE: 99% (24.66 real, 0.20 kernel, 24.38 user); 351096k resident\nCORE: 99% (24.36 real, 0.17 kernel, 24.18 user); 352284k resident\nSYNTAX: 99% (52.24 real, 0.56 kernel, 51.66 user); 645544k resident\nSYNTAX: 99% (51.55 real, 0.48 kernel, 50.99 user); 646428k resident\n```\n\ncc @nikomatsakis @eddyb", "tree": {"sha": "60ed2486c674db2267aa679157ee1ea96686c845", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/60ed2486c674db2267aa679157ee1ea96686c845"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/05a7f25cc42d08aa541f50876915489bdc0eb4bb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/05a7f25cc42d08aa541f50876915489bdc0eb4bb", "html_url": "https://github.com/rust-lang/rust/commit/05a7f25cc42d08aa541f50876915489bdc0eb4bb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/05a7f25cc42d08aa541f50876915489bdc0eb4bb/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "956e2bcbaa00c05e051718b1375375915064f1c3", "url": "https://api.github.com/repos/rust-lang/rust/commits/956e2bcbaa00c05e051718b1375375915064f1c3", "html_url": "https://github.com/rust-lang/rust/commit/956e2bcbaa00c05e051718b1375375915064f1c3"}, {"sha": "b663d9d5e85c06ca980e75c545fadc51226ab38c", "url": "https://api.github.com/repos/rust-lang/rust/commits/b663d9d5e85c06ca980e75c545fadc51226ab38c", "html_url": "https://github.com/rust-lang/rust/commit/b663d9d5e85c06ca980e75c545fadc51226ab38c"}], "stats": {"total": 1082, "additions": 531, "deletions": 551}, "files": [{"sha": "11919db479c1a790778811e90c82aa804ca90821", "filename": "src/librustc/middle/const_val.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/05a7f25cc42d08aa541f50876915489bdc0eb4bb/src%2Flibrustc%2Fmiddle%2Fconst_val.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05a7f25cc42d08aa541f50876915489bdc0eb4bb/src%2Flibrustc%2Fmiddle%2Fconst_val.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_val.rs?ref=05a7f25cc42d08aa541f50876915489bdc0eb4bb", "patch": "@@ -14,6 +14,7 @@ use std::rc::Rc;\n use hir::def_id::DefId;\n use rustc_const_math::*;\n use self::ConstVal::*;\n+pub use rustc_const_math::ConstInt;\n \n use std::collections::BTreeMap;\n \n@@ -48,4 +49,14 @@ impl ConstVal {\n             Char(..) => \"char\",\n         }\n     }\n+\n+    pub fn to_const_int(&self) -> Option<ConstInt> {\n+        match *self {\n+            ConstVal::Integral(i) => Some(i),\n+            ConstVal::Bool(true) => Some(ConstInt::Infer(1)),\n+            ConstVal::Bool(false) => Some(ConstInt::Infer(0)),\n+            ConstVal::Char(ch) => Some(ConstInt::U32(ch as u32)),\n+            _ => None\n+        }\n+    }\n }"}, {"sha": "d8212807eb2771af21ad235020cbf64127765a8b", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 33, "deletions": 34, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/05a7f25cc42d08aa541f50876915489bdc0eb4bb/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05a7f25cc42d08aa541f50876915489bdc0eb4bb/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=05a7f25cc42d08aa541f50876915489bdc0eb4bb", "patch": "@@ -453,36 +453,30 @@ pub enum TerminatorKind<'tcx> {\n         target: BasicBlock,\n     },\n \n-    /// jump to branch 0 if this lvalue evaluates to true\n-    If {\n-        cond: Operand<'tcx>,\n-        targets: (BasicBlock, BasicBlock),\n-    },\n-\n-    /// lvalue evaluates to some enum; jump depending on the branch\n-    Switch {\n-        discr: Lvalue<'tcx>,\n-        adt_def: &'tcx AdtDef,\n-        targets: Vec<BasicBlock>,\n-    },\n-\n     /// operand evaluates to an integer; jump depending on its value\n     /// to one of the targets, and otherwise fallback to `otherwise`\n     SwitchInt {\n         /// discriminant value being tested\n-        discr: Lvalue<'tcx>,\n+        discr: Operand<'tcx>,\n \n         /// type of value being tested\n         switch_ty: Ty<'tcx>,\n \n         /// Possible values. The locations to branch to in each case\n         /// are found in the corresponding indices from the `targets` vector.\n-        values: Vec<ConstVal>,\n-\n-        /// Possible branch sites. The length of this vector should be\n-        /// equal to the length of the `values` vector plus 1 -- the\n-        /// extra item is the block to branch to if none of the values\n-        /// fit.\n+        values: Cow<'tcx, [ConstInt]>,\n+\n+        /// Possible branch sites. The last element of this vector is used\n+        /// for the otherwise branch, so values.len() == targets.len() + 1\n+        /// should hold.\n+        // This invariant is quite non-obvious and also could be improved.\n+        // One way to make this invariant is to have something like this instead:\n+        //\n+        // branches: Vec<(ConstInt, BasicBlock)>,\n+        // otherwise: Option<BasicBlock> // exhaustive if None\n+        //\n+        // However we\u2019ve decided to keep this as-is until we figure a case\n+        // where some other approach seems to be strictly better than other.\n         targets: Vec<BasicBlock>,\n     },\n \n@@ -546,12 +540,21 @@ impl<'tcx> Terminator<'tcx> {\n }\n \n impl<'tcx> TerminatorKind<'tcx> {\n+    pub fn if_<'a, 'gcx>(tcx: ty::TyCtxt<'a, 'gcx, 'tcx>, cond: Operand<'tcx>,\n+                         t: BasicBlock, f: BasicBlock) -> TerminatorKind<'tcx> {\n+        static BOOL_SWITCH_FALSE: &'static [ConstInt] = &[ConstInt::Infer(0)];\n+        TerminatorKind::SwitchInt {\n+            discr: cond,\n+            switch_ty: tcx.types.bool,\n+            values: From::from(BOOL_SWITCH_FALSE),\n+            targets: vec![f, t],\n+        }\n+    }\n+\n     pub fn successors(&self) -> Cow<[BasicBlock]> {\n         use self::TerminatorKind::*;\n         match *self {\n             Goto { target: ref b } => slice::ref_slice(b).into_cow(),\n-            If { targets: (b1, b2), .. } => vec![b1, b2].into_cow(),\n-            Switch { targets: ref b, .. } => b[..].into_cow(),\n             SwitchInt { targets: ref b, .. } => b[..].into_cow(),\n             Resume => (&[]).into_cow(),\n             Return => (&[]).into_cow(),\n@@ -580,8 +583,6 @@ impl<'tcx> TerminatorKind<'tcx> {\n         use self::TerminatorKind::*;\n         match *self {\n             Goto { target: ref mut b } => vec![b],\n-            If { targets: (ref mut b1, ref mut b2), .. } => vec![b1, b2],\n-            Switch { targets: ref mut b, .. } => b.iter_mut().collect(),\n             SwitchInt { targets: ref mut b, .. } => b.iter_mut().collect(),\n             Resume => Vec::new(),\n             Return => Vec::new(),\n@@ -659,8 +660,6 @@ impl<'tcx> TerminatorKind<'tcx> {\n         use self::TerminatorKind::*;\n         match *self {\n             Goto { .. } => write!(fmt, \"goto\"),\n-            If { cond: ref lv, .. } => write!(fmt, \"if({:?})\", lv),\n-            Switch { discr: ref lv, .. } => write!(fmt, \"switch({:?})\", lv),\n             SwitchInt { discr: ref lv, .. } => write!(fmt, \"switchInt({:?})\", lv),\n             Return => write!(fmt, \"return\"),\n             Resume => write!(fmt, \"resume\"),\n@@ -710,18 +709,11 @@ impl<'tcx> TerminatorKind<'tcx> {\n         match *self {\n             Return | Resume | Unreachable => vec![],\n             Goto { .. } => vec![\"\".into()],\n-            If { .. } => vec![\"true\".into(), \"false\".into()],\n-            Switch { ref adt_def, .. } => {\n-                adt_def.variants\n-                       .iter()\n-                       .map(|variant| variant.name.to_string().into())\n-                       .collect()\n-            }\n             SwitchInt { ref values, .. } => {\n                 values.iter()\n                       .map(|const_val| {\n                           let mut buf = String::new();\n-                          fmt_const_val(&mut buf, const_val).unwrap();\n+                          fmt_const_val(&mut buf, &ConstVal::Integral(*const_val)).unwrap();\n                           buf.into()\n                       })\n                       .chain(iter::once(String::from(\"otherwise\").into()))\n@@ -997,6 +989,12 @@ pub enum Rvalue<'tcx> {\n \n     UnaryOp(UnOp, Operand<'tcx>),\n \n+    /// Read the discriminant of an ADT.\n+    ///\n+    /// Undefined (i.e. no effort is made to make it defined, but there\u2019s no reason why it cannot\n+    /// be defined to return, say, a 0) if ADT is not an enum.\n+    Discriminant(Lvalue<'tcx>),\n+\n     /// Creates an *uninitialized* Box\n     Box(Ty<'tcx>),\n \n@@ -1111,6 +1109,7 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n                 write!(fmt, \"Checked{:?}({:?}, {:?})\", op, a, b)\n             }\n             UnaryOp(ref op, ref a) => write!(fmt, \"{:?}({:?})\", op, a),\n+            Discriminant(ref lval) => write!(fmt, \"discriminant({:?})\", lval),\n             Box(ref t) => write!(fmt, \"Box({:?})\", t),\n             InlineAsm { ref asm, ref outputs, ref inputs } => {\n                 write!(fmt, \"asm!({:?} : {:?} : {:?})\", asm, outputs, inputs)"}, {"sha": "7b0863b4c42bcebfc777f70794a5935cf6d76888", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 23, "deletions": 12, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/05a7f25cc42d08aa541f50876915489bdc0eb4bb/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05a7f25cc42d08aa541f50876915489bdc0eb4bb/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=05a7f25cc42d08aa541f50876915489bdc0eb4bb", "patch": "@@ -18,6 +18,7 @@ use ty::subst::{Subst, Substs};\n use ty::{self, AdtDef, Ty, TyCtxt};\n use ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n use hir;\n+use ty::util::IntTypeExt;\n \n #[derive(Copy, Clone, Debug)]\n pub enum LvalueTy<'tcx> {\n@@ -135,15 +136,15 @@ impl<'tcx> Lvalue<'tcx> {\n impl<'tcx> Rvalue<'tcx> {\n     pub fn ty<'a, 'gcx>(&self, mir: &Mir<'tcx>, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Option<Ty<'tcx>>\n     {\n-        match self {\n-            &Rvalue::Use(ref operand) => Some(operand.ty(mir, tcx)),\n-            &Rvalue::Repeat(ref operand, ref count) => {\n+        match *self {\n+            Rvalue::Use(ref operand) => Some(operand.ty(mir, tcx)),\n+            Rvalue::Repeat(ref operand, ref count) => {\n                 let op_ty = operand.ty(mir, tcx);\n                 let count = count.value.as_u64(tcx.sess.target.uint_type);\n                 assert_eq!(count as usize as u64, count);\n                 Some(tcx.mk_array(op_ty, count as usize))\n             }\n-            &Rvalue::Ref(reg, bk, ref lv) => {\n+            Rvalue::Ref(reg, bk, ref lv) => {\n                 let lv_ty = lv.ty(mir, tcx).to_ty(tcx);\n                 Some(tcx.mk_ref(reg,\n                     ty::TypeAndMut {\n@@ -152,27 +153,37 @@ impl<'tcx> Rvalue<'tcx> {\n                     }\n                 ))\n             }\n-            &Rvalue::Len(..) => Some(tcx.types.usize),\n-            &Rvalue::Cast(.., ty) => Some(ty),\n-            &Rvalue::BinaryOp(op, ref lhs, ref rhs) => {\n+            Rvalue::Len(..) => Some(tcx.types.usize),\n+            Rvalue::Cast(.., ty) => Some(ty),\n+            Rvalue::BinaryOp(op, ref lhs, ref rhs) => {\n                 let lhs_ty = lhs.ty(mir, tcx);\n                 let rhs_ty = rhs.ty(mir, tcx);\n                 Some(op.ty(tcx, lhs_ty, rhs_ty))\n             }\n-            &Rvalue::CheckedBinaryOp(op, ref lhs, ref rhs) => {\n+            Rvalue::CheckedBinaryOp(op, ref lhs, ref rhs) => {\n                 let lhs_ty = lhs.ty(mir, tcx);\n                 let rhs_ty = rhs.ty(mir, tcx);\n                 let ty = op.ty(tcx, lhs_ty, rhs_ty);\n                 let ty = tcx.intern_tup(&[ty, tcx.types.bool], false);\n                 Some(ty)\n             }\n-            &Rvalue::UnaryOp(_, ref operand) => {\n+            Rvalue::UnaryOp(_, ref operand) => {\n                 Some(operand.ty(mir, tcx))\n             }\n-            &Rvalue::Box(t) => {\n+            Rvalue::Discriminant(ref lval) => {\n+                let ty = lval.ty(mir, tcx).to_ty(tcx);\n+                if let ty::TyAdt(adt_def, _) = ty.sty {\n+                    Some(adt_def.discr_ty.to_ty(tcx))\n+                } else {\n+                    // Undefined behaviour, bug for now; may want to return something for\n+                    // the `discriminant` intrinsic later.\n+                    bug!(\"Rvalue::Discriminant on Lvalue of type {:?}\", ty);\n+                }\n+            }\n+            Rvalue::Box(t) => {\n                 Some(tcx.mk_box(t))\n             }\n-            &Rvalue::Aggregate(ref ak, ref ops) => {\n+            Rvalue::Aggregate(ref ak, ref ops) => {\n                 match *ak {\n                     AggregateKind::Array => {\n                         if let Some(operand) = ops.get(0) {\n@@ -196,7 +207,7 @@ impl<'tcx> Rvalue<'tcx> {\n                     }\n                 }\n             }\n-            &Rvalue::InlineAsm { .. } => None\n+            Rvalue::InlineAsm { .. } => None\n         }\n     }\n }"}, {"sha": "be3c43db7baddefbac8ab0457e2195ac547b23f0", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 19, "deletions": 24, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/05a7f25cc42d08aa541f50876915489bdc0eb4bb/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05a7f25cc42d08aa541f50876915489bdc0eb4bb/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=05a7f25cc42d08aa541f50876915489bdc0eb4bb", "patch": "@@ -14,7 +14,6 @@ use ty::subst::Substs;\n use ty::{ClosureSubsts, Region, Ty};\n use mir::*;\n use rustc_const_math::ConstUsize;\n-use rustc_data_structures::tuple_slice::TupleSlice;\n use rustc_data_structures::indexed_vec::Idx;\n use syntax_pos::Span;\n \n@@ -224,6 +223,12 @@ macro_rules! make_mir_visitor {\n                 self.super_const_val(const_val);\n             }\n \n+            fn visit_const_int(&mut self,\n+                               const_int: &ConstInt,\n+                               _: Location) {\n+                self.super_const_int(const_int);\n+            }\n+\n             fn visit_const_usize(&mut self,\n                                  const_usize: & $($mutability)* ConstUsize,\n                                  _: Location) {\n@@ -363,31 +368,14 @@ macro_rules! make_mir_visitor {\n                         self.visit_branch(block, target);\n                     }\n \n-                    TerminatorKind::If { ref $($mutability)* cond,\n-                                         ref $($mutability)* targets } => {\n-                        self.visit_operand(cond, source_location);\n-                        for &target in targets.as_slice() {\n-                            self.visit_branch(block, target);\n-                        }\n-                    }\n-\n-                    TerminatorKind::Switch { ref $($mutability)* discr,\n-                                             adt_def: _,\n-                                             ref targets } => {\n-                        self.visit_lvalue(discr, LvalueContext::Inspect, source_location);\n-                        for &target in targets {\n-                            self.visit_branch(block, target);\n-                        }\n-                    }\n-\n                     TerminatorKind::SwitchInt { ref $($mutability)* discr,\n                                                 ref $($mutability)* switch_ty,\n-                                                ref $($mutability)* values,\n+                                                ref values,\n                                                 ref targets } => {\n-                        self.visit_lvalue(discr, LvalueContext::Inspect, source_location);\n+                        self.visit_operand(discr, source_location);\n                         self.visit_ty(switch_ty);\n-                        for value in values {\n-                            self.visit_const_val(value, source_location);\n+                        for value in &values[..] {\n+                            self.visit_const_int(value, source_location);\n                         }\n                         for &target in targets {\n                             self.visit_branch(block, target);\n@@ -506,6 +494,10 @@ macro_rules! make_mir_visitor {\n                         self.visit_operand(op, location);\n                     }\n \n+                    Rvalue::Discriminant(ref $($mutability)* lvalue) => {\n+                        self.visit_lvalue(lvalue, LvalueContext::Inspect, location);\n+                    }\n+\n                     Rvalue::Box(ref $($mutability)* ty) => {\n                         self.visit_ty(ty);\n                     }\n@@ -712,10 +704,13 @@ macro_rules! make_mir_visitor {\n                                     _substs: & $($mutability)* ClosureSubsts<'tcx>) {\n             }\n \n-            fn super_const_val(&mut self, _substs: & $($mutability)* ConstVal) {\n+            fn super_const_val(&mut self, _const_val: & $($mutability)* ConstVal) {\n+            }\n+\n+            fn super_const_int(&mut self, _const_int: &ConstInt) {\n             }\n \n-            fn super_const_usize(&mut self, _substs: & $($mutability)* ConstUsize) {\n+            fn super_const_usize(&mut self, _const_usize: & $($mutability)* ConstUsize) {\n             }\n \n             // Convenience methods"}, {"sha": "19bb8a63aa277fe3879c6db734641707166b7d25", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/05a7f25cc42d08aa541f50876915489bdc0eb4bb/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05a7f25cc42d08aa541f50876915489bdc0eb4bb/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=05a7f25cc42d08aa541f50876915489bdc0eb4bb", "patch": "@@ -673,10 +673,12 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn alloc_adt_def(self,\n                          did: DefId,\n                          kind: AdtKind,\n+                         discr_ty: Option<attr::IntType>,\n                          variants: Vec<ty::VariantDef>,\n                          repr: ReprOptions)\n                          -> &'gcx ty::AdtDef {\n-        let def = ty::AdtDef::new(self, did, kind, variants, repr);\n+        let discr_ty = discr_ty.unwrap_or(attr::UnsignedInt(ast::UintTy::U8));\n+        let def = ty::AdtDef::new(self, did, kind, discr_ty, variants, repr);\n         self.global_arenas.adt_def.alloc(def)\n     }\n "}, {"sha": "f429053d8bb1223a782cddd013c95b8bb766baef", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 20, "deletions": 11, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/05a7f25cc42d08aa541f50876915489bdc0eb4bb/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05a7f25cc42d08aa541f50876915489bdc0eb4bb/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=05a7f25cc42d08aa541f50876915489bdc0eb4bb", "patch": "@@ -20,7 +20,6 @@ use ty::{self, Ty, TyCtxt, TypeFoldable, ReprOptions};\n use syntax::ast::{FloatTy, IntTy, UintTy};\n use syntax::attr;\n use syntax_pos::DUMMY_SP;\n-use rustc_const_math::ConstInt;\n \n use std::cmp;\n use std::fmt;\n@@ -1183,21 +1182,15 @@ impl<'a, 'gcx, 'tcx> Layout {\n                                                             i64::min_value(),\n                                                             true);\n                     for v in &def.variants {\n-                        let x = match v.disr_val.erase_type() {\n-                            ConstInt::InferSigned(i) => i as i64,\n-                            ConstInt::Infer(i) => i as u64 as i64,\n-                            _ => bug!()\n-                        };\n+                        let x = v.disr_val as i128 as i64;\n                         if x == 0 { non_zero = false; }\n                         if x < min { min = x; }\n                         if x > max { max = x; }\n                     }\n \n                     // FIXME: should handle i128? signed-value based impl is weird and hard to\n                     // grok.\n-                    let (discr, signed) = Integer::repr_discr(tcx, ty, &def.repr,\n-                                                              min,\n-                                                              max);\n+                    let (discr, signed) = Integer::repr_discr(tcx, ty, &def.repr, min, max);\n                     return success(CEnum {\n                         discr: discr,\n                         signed: signed,\n@@ -1247,7 +1240,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n                 // non-empty body, explicit discriminants should have\n                 // been rejected by a checker before this point.\n                 for (i, v) in def.variants.iter().enumerate() {\n-                    if i as u128 != v.disr_val.to_u128_unchecked() {\n+                    if i as u128 != v.disr_val {\n                         bug!(\"non-C-like enum {} with specified discriminants\",\n                             tcx.item_path_str(def.did));\n                     }\n@@ -1315,7 +1308,6 @@ impl<'a, 'gcx, 'tcx> Layout {\n                 let discr_max = (variants.len() - 1) as i64;\n                 assert!(discr_max >= 0);\n                 let (min_ity, _) = Integer::repr_discr(tcx, ty, &def.repr, 0, discr_max);\n-\n                 let mut align = dl.aggregate_align;\n                 let mut size = Size::from_bytes(0);\n \n@@ -1356,6 +1348,23 @@ impl<'a, 'gcx, 'tcx> Layout {\n                     return Err(LayoutError::SizeOverflow(ty));\n                 }\n \n+                let typeck_ity = Integer::from_attr(dl, def.discr_ty);\n+                if typeck_ity < min_ity {\n+                    // It is a bug if Layout decided on a greater discriminant size than typeck for\n+                    // some reason at this point (based on values discriminant can take on). Mostly\n+                    // because this discriminant will be loaded, and then stored into variable of\n+                    // type calculated by typeck. Consider such case (a bug): typeck decided on\n+                    // byte-sized discriminant, but layout thinks we need a 16-bit to store all\n+                    // discriminant values. That would be a bug, because then, in trans, in order\n+                    // to store this 16-bit discriminant into 8-bit sized temporary some of the\n+                    // space necessary to represent would have to be discarded (or layout is wrong\n+                    // on thinking it needs 16 bits)\n+                    bug!(\"layout decided on a larger discriminant type ({:?}) than typeck ({:?})\",\n+                         min_ity, typeck_ity);\n+                    // However, it is fine to make discr type however large (as an optimisation)\n+                    // after this point \u2013 we\u2019ll just truncate the value we load in trans.\n+                }\n+\n                 // Check to see if we should use a different type for the\n                 // discriminant. We can safely use a type with the same size\n                 // as the alignment of the first field of each variant."}, {"sha": "411e14531fab362c19b3620034a5ea91a5daf1ce", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/05a7f25cc42d08aa541f50876915489bdc0eb4bb/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05a7f25cc42d08aa541f50876915489bdc0eb4bb/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=05a7f25cc42d08aa541f50876915489bdc0eb4bb", "patch": "@@ -45,7 +45,6 @@ use syntax::attr;\n use syntax::symbol::{Symbol, InternedString};\n use syntax_pos::{DUMMY_SP, Span};\n \n-use rustc_const_math::ConstInt;\n use rustc_data_structures::accumulate_vec::IntoIter as AccIntoIter;\n \n use hir;\n@@ -96,7 +95,7 @@ mod flags;\n mod structural_impls;\n mod sty;\n \n-pub type Disr = ConstInt;\n+pub type Disr = u128;\n \n // Data types\n \n@@ -1325,6 +1324,12 @@ pub struct FieldDef {\n /// table.\n pub struct AdtDef {\n     pub did: DefId,\n+    /// Type of the discriminant\n+    ///\n+    /// Note, that this is the type specified in `repr()` or a default type of some sort, and might\n+    /// not match the actual type that layout algorithm decides to use when translating this type\n+    /// into LLVM. That being said, layout algorithm may not use a type larger than specified here.\n+    pub discr_ty: attr::IntType,\n     pub variants: Vec<VariantDef>,\n     destructor: Cell<Option<DefId>>,\n     flags: Cell<AdtFlags>,\n@@ -1387,6 +1392,7 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n     fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n            did: DefId,\n            kind: AdtKind,\n+           discr_ty: attr::IntType,\n            variants: Vec<VariantDef>,\n            repr: ReprOptions) -> Self {\n         let mut flags = AdtFlags::NO_ADT_FLAGS;\n@@ -1410,6 +1416,7 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n         }\n         AdtDef {\n             did: did,\n+            discr_ty: discr_ty,\n             variants: variants,\n             flags: Cell::new(flags),\n             destructor: Cell::new(None),"}, {"sha": "16492de6c3d27fefb456f787c89a8a876628877e", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 8, "deletions": 73, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/05a7f25cc42d08aa541f50876915489bdc0eb4bb/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05a7f25cc42d08aa541f50876915489bdc0eb4bb/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=05a7f25cc42d08aa541f50876915489bdc0eb4bb", "patch": "@@ -23,7 +23,6 @@ use ty::TypeVariants::*;\n use util::nodemap::FxHashMap;\n use middle::lang_items;\n \n-use rustc_const_math::{ConstInt, ConstIsize, ConstUsize};\n use rustc_data_structures::stable_hasher::{StableHasher, StableHasherResult};\n \n use std::cell::RefCell;\n@@ -37,84 +36,20 @@ use syntax_pos::Span;\n use hir;\n \n pub trait IntTypeExt {\n-    fn to_ty<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Ty<'tcx>;\n-    fn disr_incr<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, val: Option<Disr>)\n-                           -> Option<Disr>;\n-    fn assert_ty_matches(&self, val: Disr);\n-    fn initial_discriminant<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Disr;\n+    fn to_ty<'a, 'gcx: 'a+'tcx, 'tcx: 'a>(self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Ty<'tcx>;\n+    fn initial_discriminant<'a, 'tcx>(&self, _: TyCtxt<'a, 'tcx, 'tcx>) -> Disr;\n }\n \n impl IntTypeExt for attr::IntType {\n-    fn to_ty<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Ty<'tcx> {\n-        match *self {\n-            SignedInt(ast::IntTy::I8)      => tcx.types.i8,\n-            SignedInt(ast::IntTy::I16)     => tcx.types.i16,\n-            SignedInt(ast::IntTy::I32)     => tcx.types.i32,\n-            SignedInt(ast::IntTy::I64)     => tcx.types.i64,\n-            SignedInt(ast::IntTy::I128)     => tcx.types.i128,\n-            SignedInt(ast::IntTy::Is)   => tcx.types.isize,\n-            UnsignedInt(ast::UintTy::U8)    => tcx.types.u8,\n-            UnsignedInt(ast::UintTy::U16)   => tcx.types.u16,\n-            UnsignedInt(ast::UintTy::U32)   => tcx.types.u32,\n-            UnsignedInt(ast::UintTy::U64)   => tcx.types.u64,\n-            UnsignedInt(ast::UintTy::U128)   => tcx.types.u128,\n-            UnsignedInt(ast::UintTy::Us) => tcx.types.usize,\n+    fn to_ty<'a, 'gcx: 'a+'tcx, 'tcx: 'a>(self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Ty<'tcx> {\n+        match self {\n+            SignedInt(i) => tcx.mk_mach_int(i),\n+            UnsignedInt(i) => tcx.mk_mach_uint(i),\n         }\n     }\n \n-    fn initial_discriminant<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Disr {\n-        match *self {\n-            SignedInt(ast::IntTy::I8)    => ConstInt::I8(0),\n-            SignedInt(ast::IntTy::I16)   => ConstInt::I16(0),\n-            SignedInt(ast::IntTy::I32)   => ConstInt::I32(0),\n-            SignedInt(ast::IntTy::I64)   => ConstInt::I64(0),\n-            SignedInt(ast::IntTy::I128)   => ConstInt::I128(0),\n-            SignedInt(ast::IntTy::Is) => match tcx.sess.target.int_type {\n-                ast::IntTy::I16 => ConstInt::Isize(ConstIsize::Is16(0)),\n-                ast::IntTy::I32 => ConstInt::Isize(ConstIsize::Is32(0)),\n-                ast::IntTy::I64 => ConstInt::Isize(ConstIsize::Is64(0)),\n-                _ => bug!(),\n-            },\n-            UnsignedInt(ast::UintTy::U8)  => ConstInt::U8(0),\n-            UnsignedInt(ast::UintTy::U16) => ConstInt::U16(0),\n-            UnsignedInt(ast::UintTy::U32) => ConstInt::U32(0),\n-            UnsignedInt(ast::UintTy::U64) => ConstInt::U64(0),\n-            UnsignedInt(ast::UintTy::U128) => ConstInt::U128(0),\n-            UnsignedInt(ast::UintTy::Us) => match tcx.sess.target.uint_type {\n-                ast::UintTy::U16 => ConstInt::Usize(ConstUsize::Us16(0)),\n-                ast::UintTy::U32 => ConstInt::Usize(ConstUsize::Us32(0)),\n-                ast::UintTy::U64 => ConstInt::Usize(ConstUsize::Us64(0)),\n-                _ => bug!(),\n-            },\n-        }\n-    }\n-\n-    fn assert_ty_matches(&self, val: Disr) {\n-        match (*self, val) {\n-            (SignedInt(ast::IntTy::I8), ConstInt::I8(_)) => {},\n-            (SignedInt(ast::IntTy::I16), ConstInt::I16(_)) => {},\n-            (SignedInt(ast::IntTy::I32), ConstInt::I32(_)) => {},\n-            (SignedInt(ast::IntTy::I64), ConstInt::I64(_)) => {},\n-            (SignedInt(ast::IntTy::I128), ConstInt::I128(_)) => {},\n-            (SignedInt(ast::IntTy::Is), ConstInt::Isize(_)) => {},\n-            (UnsignedInt(ast::UintTy::U8), ConstInt::U8(_)) => {},\n-            (UnsignedInt(ast::UintTy::U16), ConstInt::U16(_)) => {},\n-            (UnsignedInt(ast::UintTy::U32), ConstInt::U32(_)) => {},\n-            (UnsignedInt(ast::UintTy::U64), ConstInt::U64(_)) => {},\n-            (UnsignedInt(ast::UintTy::U128), ConstInt::U128(_)) => {},\n-            (UnsignedInt(ast::UintTy::Us), ConstInt::Usize(_)) => {},\n-            _ => bug!(\"disr type mismatch: {:?} vs {:?}\", self, val),\n-        }\n-    }\n-\n-    fn disr_incr<'a, 'tcx>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, val: Option<Disr>)\n-                           -> Option<Disr> {\n-        if let Some(val) = val {\n-            self.assert_ty_matches(val);\n-            (val + ConstInt::Infer(1)).ok()\n-        } else {\n-            Some(self.initial_discriminant(tcx))\n-        }\n+    fn initial_discriminant<'a, 'tcx>(&self, _: TyCtxt<'a, 'tcx, 'tcx>) -> Disr {\n+        0\n     }\n }\n "}, {"sha": "8b246105f61693b147688622d62203ddfa33653b", "filename": "src/librustc_borrowck/borrowck/mir/dataflow/mod.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/05a7f25cc42d08aa541f50876915489bdc0eb4bb/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05a7f25cc42d08aa541f50876915489bdc0eb4bb/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fmod.rs?ref=05a7f25cc42d08aa541f50876915489bdc0eb4bb", "patch": "@@ -454,11 +454,6 @@ impl<'a, 'tcx: 'a, D> DataflowAnalysis<'a, 'tcx, D>\n                 self.propagate_bits_into_entry_set_for(in_out, changed, target);\n                 self.propagate_bits_into_entry_set_for(in_out, changed, unwind);\n             }\n-            mir::TerminatorKind::If { ref targets, .. } => {\n-                self.propagate_bits_into_entry_set_for(in_out, changed, &targets.0);\n-                self.propagate_bits_into_entry_set_for(in_out, changed, &targets.1);\n-            }\n-            mir::TerminatorKind::Switch { ref targets, .. } |\n             mir::TerminatorKind::SwitchInt { ref targets, .. } => {\n                 for target in targets {\n                     self.propagate_bits_into_entry_set_for(in_out, changed, target);"}, {"sha": "5899c9f31d14dc4c4d00c73a2183a37db193b566", "filename": "src/librustc_borrowck/borrowck/mir/elaborate_drops.rs", "status": "modified", "additions": 62, "deletions": 56, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/05a7f25cc42d08aa541f50876915489bdc0eb4bb/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05a7f25cc42d08aa541f50876915489bdc0eb4bb/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs?ref=05a7f25cc42d08aa541f50876915489bdc0eb4bb", "patch": "@@ -17,9 +17,10 @@ use super::{DropFlagState, MoveDataParamEnv};\n use super::patch::MirPatch;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::subst::{Kind, Subst, Substs};\n+use rustc::ty::util::IntTypeExt;\n use rustc::mir::*;\n use rustc::mir::transform::{Pass, MirPass, MirSource};\n-use rustc::middle::const_val::ConstVal;\n+use rustc::middle::const_val::{ConstVal, ConstInt};\n use rustc::middle::lang_items;\n use rustc::util::nodemap::FxHashMap;\n use rustc_data_structures::indexed_set::IdxSetBuf;\n@@ -619,48 +620,11 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n         self.elaborated_drop_block(&inner_c)\n     }\n \n-    fn open_drop_for_variant<'a>(&mut self,\n-                                 c: &DropCtxt<'a, 'tcx>,\n-                                 drop_block: &mut Option<BasicBlock>,\n-                                 adt: &'tcx ty::AdtDef,\n-                                 substs: &'tcx Substs<'tcx>,\n-                                 variant_index: usize)\n-                                 -> BasicBlock\n-    {\n-        let subpath = super::move_path_children_matching(\n-            self.move_data(), c.path, |proj| match proj {\n-                &Projection {\n-                    elem: ProjectionElem::Downcast(_, idx), ..\n-                } => idx == variant_index,\n-                _ => false\n-            });\n-\n-        if let Some(variant_path) = subpath {\n-            let base_lv = c.lvalue.clone().elem(\n-                ProjectionElem::Downcast(adt, variant_index)\n-            );\n-            let fields = self.move_paths_for_fields(\n-                &base_lv,\n-                variant_path,\n-                &adt.variants[variant_index],\n-                substs);\n-            self.drop_ladder(c, fields)\n-        } else {\n-            // variant not found - drop the entire enum\n-            if let None = *drop_block {\n-                *drop_block = Some(self.complete_drop(c, true));\n-            }\n-            return drop_block.unwrap();\n-        }\n-    }\n-\n     fn open_drop_for_adt<'a>(&mut self, c: &DropCtxt<'a, 'tcx>,\n                              adt: &'tcx ty::AdtDef, substs: &'tcx Substs<'tcx>)\n                              -> BasicBlock {\n         debug!(\"open_drop_for_adt({:?}, {:?}, {:?})\", c, adt, substs);\n \n-        let mut drop_block = None;\n-\n         match adt.variants.len() {\n             1 => {\n                 let fields = self.move_paths_for_fields(\n@@ -672,27 +636,71 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n                 self.drop_ladder(c, fields)\n             }\n             _ => {\n-                let variant_drops : Vec<BasicBlock> =\n-                    (0..adt.variants.len()).map(|i| {\n-                        self.open_drop_for_variant(c, &mut drop_block,\n-                                                   adt, substs, i)\n-                    }).collect();\n-\n+                let mut values = Vec::with_capacity(adt.variants.len());\n+                let mut blocks = Vec::with_capacity(adt.variants.len());\n+                let mut otherwise = None;\n+                for (variant_index, variant) in adt.variants.iter().enumerate() {\n+                    let discr = ConstInt::new_inttype(variant.disr_val, adt.discr_ty,\n+                                                      self.tcx.sess.target.uint_type,\n+                                                      self.tcx.sess.target.int_type).unwrap();\n+                    let subpath = super::move_path_children_matching(\n+                        self.move_data(), c.path, |proj| match proj {\n+                            &Projection {\n+                                elem: ProjectionElem::Downcast(_, idx), ..\n+                            } => idx == variant_index,\n+                            _ => false\n+                        });\n+                    if let Some(variant_path) = subpath {\n+                        let base_lv = c.lvalue.clone().elem(\n+                            ProjectionElem::Downcast(adt, variant_index)\n+                        );\n+                        let fields = self.move_paths_for_fields(\n+                            &base_lv,\n+                            variant_path,\n+                            &adt.variants[variant_index],\n+                            substs);\n+                        values.push(discr);\n+                        blocks.push(self.drop_ladder(c, fields));\n+                    } else {\n+                        // variant not found - drop the entire enum\n+                        if let None = otherwise {\n+                            otherwise = Some(self.complete_drop(c, true));\n+                        }\n+                    }\n+                }\n+                if let Some(block) = otherwise {\n+                    blocks.push(block);\n+                } else {\n+                    values.pop();\n+                }\n                 // If there are multiple variants, then if something\n                 // is present within the enum the discriminant, tracked\n                 // by the rest path, must be initialized.\n                 //\n                 // Additionally, we do not want to switch on the\n                 // discriminant after it is free-ed, because that\n                 // way lies only trouble.\n-\n-                let switch_block = self.new_block(\n-                    c, c.is_cleanup, TerminatorKind::Switch {\n-                        discr: c.lvalue.clone(),\n-                        adt_def: adt,\n-                        targets: variant_drops\n-                    });\n-\n+                let discr_ty = adt.discr_ty.to_ty(self.tcx);\n+                let discr = Lvalue::Local(self.patch.new_temp(discr_ty));\n+                let switch_block = self.patch.new_block(BasicBlockData {\n+                    statements: vec![\n+                        Statement {\n+                            source_info: c.source_info,\n+                            kind: StatementKind::Assign(discr.clone(),\n+                                                        Rvalue::Discriminant(c.lvalue.clone()))\n+                        }\n+                    ],\n+                    terminator: Some(Terminator {\n+                        source_info: c.source_info,\n+                        kind: TerminatorKind::SwitchInt {\n+                            discr: Operand::Consume(discr),\n+                            switch_ty: discr_ty,\n+                            values: From::from(values),\n+                            targets: blocks,\n+                        }\n+                    }),\n+                    is_cleanup: c.is_cleanup,\n+                });\n                 self.drop_flag_test_block(c, switch_block)\n             }\n         }\n@@ -813,10 +821,8 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n             (true, false) => on_set,\n             (true, true) => {\n                 let flag = self.drop_flag(c.path).unwrap();\n-                self.new_block(c, is_cleanup, TerminatorKind::If {\n-                    cond: Operand::Consume(flag),\n-                    targets: (on_set, on_unset)\n-                })\n+                let term = TerminatorKind::if_(self.tcx, Operand::Consume(flag), on_set, on_unset);\n+                self.new_block(c, is_cleanup, term)\n             }\n         }\n     }"}, {"sha": "0c7e922c48ab4b98d11a7220ff8f63b45cb45789", "filename": "src/librustc_borrowck/borrowck/mir/gather_moves.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/05a7f25cc42d08aa541f50876915489bdc0eb4bb/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05a7f25cc42d08aa541f50876915489bdc0eb4bb/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs?ref=05a7f25cc42d08aa541f50876915489bdc0eb4bb", "patch": "@@ -435,6 +435,7 @@ impl<'a, 'tcx> MoveDataBuilder<'a, 'tcx> {\n                 }\n             }\n             Rvalue::Ref(..) |\n+            Rvalue::Discriminant(..) |\n             Rvalue::Len(..) |\n             Rvalue::InlineAsm { .. } => {}\n             Rvalue::Box(..) => {\n@@ -463,10 +464,8 @@ impl<'a, 'tcx> MoveDataBuilder<'a, 'tcx> {\n                 self.gather_move(loc, &Lvalue::Local(RETURN_POINTER));\n             }\n \n-            TerminatorKind::If { .. } |\n             TerminatorKind::Assert { .. } |\n-            TerminatorKind::SwitchInt { .. } |\n-            TerminatorKind::Switch { .. } => {\n+            TerminatorKind::SwitchInt { .. } => {\n                 // branching terminators - these don't move anything\n             }\n "}, {"sha": "bc3809db1c63a619086b78b41daceb2d84a80ead", "filename": "src/librustc_const_math/int.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/05a7f25cc42d08aa541f50876915489bdc0eb4bb/src%2Flibrustc_const_math%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05a7f25cc42d08aa541f50876915489bdc0eb4bb/src%2Flibrustc_const_math%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_math%2Fint.rs?ref=05a7f25cc42d08aa541f50876915489bdc0eb4bb", "patch": "@@ -77,6 +77,14 @@ mod ibounds {\n }\n \n impl ConstInt {\n+    pub fn new_inttype(val: u128, ty: IntType, usize_ty: UintTy, isize_ty: IntTy)\n+    -> Option<ConstInt> {\n+        match ty {\n+            IntType::SignedInt(i) => ConstInt::new_signed(val as i128, i, isize_ty),\n+            IntType::UnsignedInt(i) => ConstInt::new_unsigned(val, i, usize_ty),\n+        }\n+    }\n+\n     /// Creates a new unsigned ConstInt with matching type while also checking that overflow does\n     /// not happen.\n     pub fn new_unsigned(val: u128, ty: UintTy, usize_ty: UintTy) -> Option<ConstInt> {"}, {"sha": "ffcd25a4cdd39ab2863054812d614dfa7765cfd9", "filename": "src/librustc_data_structures/bitvec.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/05a7f25cc42d08aa541f50876915489bdc0eb4bb/src%2Flibrustc_data_structures%2Fbitvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05a7f25cc42d08aa541f50876915489bdc0eb4bb/src%2Flibrustc_data_structures%2Fbitvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fbitvec.rs?ref=05a7f25cc42d08aa541f50876915489bdc0eb4bb", "patch": "@@ -30,6 +30,10 @@ impl BitVector {\n         }\n     }\n \n+    pub fn count(&self) -> usize {\n+        self.data.iter().map(|e| e.count_ones() as usize).sum()\n+    }\n+\n     #[inline]\n     pub fn contains(&self, bit: usize) -> bool {\n         let (word, mask) = word_mask(bit);"}, {"sha": "adf8067987e405ed27597fafc2cce581662bacd2", "filename": "src/librustc_llvm/ffi.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/05a7f25cc42d08aa541f50876915489bdc0eb4bb/src%2Flibrustc_llvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05a7f25cc42d08aa541f50876915489bdc0eb4bb/src%2Flibrustc_llvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Fffi.rs?ref=05a7f25cc42d08aa541f50876915489bdc0eb4bb", "patch": "@@ -1084,11 +1084,11 @@ extern \"C\" {\n                                 DestTy: TypeRef,\n                                 Name: *const c_char)\n                                 -> ValueRef;\n-    pub fn LLVMBuildIntCast(B: BuilderRef,\n-                            Val: ValueRef,\n-                            DestTy: TypeRef,\n-                            Name: *const c_char)\n-                            -> ValueRef;\n+    pub fn LLVMRustBuildIntCast(B: BuilderRef,\n+                                Val: ValueRef,\n+                                DestTy: TypeRef,\n+                                IsSized: bool)\n+                                -> ValueRef;\n     pub fn LLVMBuildFPCast(B: BuilderRef,\n                            Val: ValueRef,\n                            DestTy: TypeRef,"}, {"sha": "abc3ffcf86b11d49c35fdb405d7f11079ce06275", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/05a7f25cc42d08aa541f50876915489bdc0eb4bb/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05a7f25cc42d08aa541f50876915489bdc0eb4bb/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=05a7f25cc42d08aa541f50876915489bdc0eb4bb", "patch": "@@ -25,8 +25,6 @@ use rustc::session::Session;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::subst::Substs;\n \n-use rustc_const_math::ConstInt;\n-\n use rustc::mir::Mir;\n \n use std::borrow::Cow;\n@@ -435,7 +433,7 @@ impl<'tcx> EntryKind<'tcx> {\n             EntryKind::Mod(_) => Def::Mod(did),\n             EntryKind::Variant(_) => Def::Variant(did),\n             EntryKind::Trait(_) => Def::Trait(did),\n-            EntryKind::Enum(_) => Def::Enum(did),\n+            EntryKind::Enum(..) => Def::Enum(did),\n             EntryKind::MacroDef(_) => Def::Macro(did),\n \n             EntryKind::ForeignMod |\n@@ -535,7 +533,7 @@ impl<'a, 'tcx> CrateMetadata {\n                     vis: f.visibility.decode(self)\n                 }\n             }).collect(),\n-            disr_val: ConstInt::Infer(data.disr),\n+            disr_val: data.disr,\n             ctor_kind: data.ctor_kind,\n         }, data.struct_ctor)\n     }\n@@ -546,8 +544,14 @@ impl<'a, 'tcx> CrateMetadata {\n                        -> &'tcx ty::AdtDef {\n         let item = self.entry(item_id);\n         let did = self.local_def_id(item_id);\n+        let (kind, ty) = match item.kind {\n+            EntryKind::Enum(dt, _) => (ty::AdtKind::Enum, Some(dt.decode(self))),\n+            EntryKind::Struct(_, _) => (ty::AdtKind::Struct, None),\n+            EntryKind::Union(_, _) => (ty::AdtKind::Union, None),\n+            _ => bug!(\"get_adt_def called on a non-ADT {:?}\", did),\n+        };\n         let mut ctor_index = None;\n-        let variants = if let EntryKind::Enum(_) = item.kind {\n+        let variants = if let ty::AdtKind::Enum = kind {\n             item.children\n                 .decode(self)\n                 .map(|index| {\n@@ -562,13 +566,13 @@ impl<'a, 'tcx> CrateMetadata {\n             vec![variant]\n         };\n         let (kind, repr) = match item.kind {\n-            EntryKind::Enum(repr) => (ty::AdtKind::Enum, repr),\n+            EntryKind::Enum(_, repr) => (ty::AdtKind::Enum, repr),\n             EntryKind::Struct(_, repr) => (ty::AdtKind::Struct, repr),\n             EntryKind::Union(_, repr) => (ty::AdtKind::Union, repr),\n             _ => bug!(\"get_adt_def called on a non-ADT {:?}\", did),\n         };\n \n-        let adt = tcx.alloc_adt_def(did, kind, variants, repr);\n+        let adt = tcx.alloc_adt_def(did, kind, ty, variants, repr);\n         if let Some(ctor_index) = ctor_index {\n             // Make adt definition available through constructor id as well.\n             tcx.adt_defs.borrow_mut().insert(self.local_def_id(ctor_index), adt);"}, {"sha": "0f9491aaf15b4385b2ffde92b21500fcd5342954", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/05a7f25cc42d08aa541f50876915489bdc0eb4bb/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05a7f25cc42d08aa541f50876915489bdc0eb4bb/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=05a7f25cc42d08aa541f50876915489bdc0eb4bb", "patch": "@@ -261,7 +261,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n         let data = VariantData {\n             ctor_kind: variant.ctor_kind,\n-            disr: variant.disr_val.to_u128_unchecked(),\n+            disr: variant.disr_val,\n             struct_ctor: None,\n         };\n \n@@ -388,7 +388,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n         let data = VariantData {\n             ctor_kind: variant.ctor_kind,\n-            disr: variant.disr_val.to_u128_unchecked(),\n+            disr: variant.disr_val,\n             struct_ctor: Some(def_id.index),\n         };\n \n@@ -661,7 +661,8 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             }\n             hir::ItemForeignMod(_) => EntryKind::ForeignMod,\n             hir::ItemTy(..) => EntryKind::Type,\n-            hir::ItemEnum(..) => EntryKind::Enum(get_repr_options(&tcx, def_id)),\n+            hir::ItemEnum(..) => EntryKind::Enum(self.lazy(&tcx.lookup_adt_def(def_id).discr_ty),\n+                                                 get_repr_options(&tcx, def_id)),\n             hir::ItemStruct(ref struct_def, _) => {\n                 let variant = tcx.lookup_adt_def(def_id).struct_variant();\n \n@@ -678,7 +679,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n                 EntryKind::Struct(self.lazy(&VariantData {\n                     ctor_kind: variant.ctor_kind,\n-                    disr: variant.disr_val.to_u128_unchecked(),\n+                    disr: variant.disr_val,\n                     struct_ctor: struct_ctor,\n                 }), repr_options)\n             }\n@@ -688,7 +689,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n                 EntryKind::Union(self.lazy(&VariantData {\n                     ctor_kind: variant.ctor_kind,\n-                    disr: variant.disr_val.to_u128_unchecked(),\n+                    disr: variant.disr_val,\n                     struct_ctor: None,\n                 }), repr_options)\n             }"}, {"sha": "777af02772ec17565a15c677ba691145d182e330", "filename": "src/librustc_metadata/schema.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/05a7f25cc42d08aa541f50876915489bdc0eb4bb/src%2Flibrustc_metadata%2Fschema.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05a7f25cc42d08aa541f50876915489bdc0eb4bb/src%2Flibrustc_metadata%2Fschema.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fschema.rs?ref=05a7f25cc42d08aa541f50876915489bdc0eb4bb", "patch": "@@ -228,7 +228,7 @@ pub enum EntryKind<'tcx> {\n     ForeignMutStatic,\n     ForeignMod,\n     Type,\n-    Enum(ReprOptions),\n+    Enum(Lazy<attr::IntType>, ReprOptions),\n     Field,\n     Variant(Lazy<VariantData>),\n     Struct(Lazy<VariantData>, ReprOptions),"}, {"sha": "35841c2cbdf01f4e8257edc563c80b83715dc488", "filename": "src/librustc_mir/build/expr/into.rs", "status": "modified", "additions": 9, "deletions": 15, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/05a7f25cc42d08aa541f50876915489bdc0eb4bb/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05a7f25cc42d08aa541f50876915489bdc0eb4bb/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs?ref=05a7f25cc42d08aa541f50876915489bdc0eb4bb", "patch": "@@ -69,10 +69,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n                 let mut then_block = this.cfg.start_new_block();\n                 let mut else_block = this.cfg.start_new_block();\n-                this.cfg.terminate(block, source_info, TerminatorKind::If {\n-                    cond: operand,\n-                    targets: (then_block, else_block)\n-                });\n+                let term = TerminatorKind::if_(this.hir.tcx(), operand, then_block, else_block);\n+                this.cfg.terminate(block, source_info, term);\n \n                 unpack!(then_block = this.into(destination, then_block, then_expr));\n                 else_block = if let Some(else_expr) = else_expr {\n@@ -114,14 +112,12 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     LogicalOp::And => (else_block, false_block),\n                     LogicalOp::Or => (true_block, else_block),\n                 };\n-                this.cfg.terminate(block, source_info,\n-                                   TerminatorKind::If { cond: lhs, targets: blocks });\n+                let term = TerminatorKind::if_(this.hir.tcx(), lhs, blocks.0, blocks.1);\n+                this.cfg.terminate(block, source_info, term);\n \n                 let rhs = unpack!(else_block = this.as_operand(else_block, rhs));\n-                this.cfg.terminate(else_block, source_info, TerminatorKind::If {\n-                    cond: rhs,\n-                    targets: (true_block, false_block)\n-                });\n+                let term = TerminatorKind::if_(this.hir.tcx(), rhs, true_block, false_block);\n+                this.cfg.terminate(else_block, source_info, term);\n \n                 this.cfg.push_assign_constant(\n                     true_block, source_info, destination,\n@@ -179,11 +175,9 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                             let cond = unpack!(\n                                 loop_block_end = this.as_operand(loop_block, cond_expr));\n                             body_block = this.cfg.start_new_block();\n-                            this.cfg.terminate(loop_block_end, source_info,\n-                                               TerminatorKind::If {\n-                                                   cond: cond,\n-                                                   targets: (body_block, exit_block)\n-                                               });\n+                            let term = TerminatorKind::if_(this.hir.tcx(), cond,\n+                                                           body_block, exit_block);\n+                            this.cfg.terminate(loop_block_end, source_info, term);\n \n                             // if the test is false, there's no `break` to assign `destination`, so\n                             // we have to do it; this overwrites any `break`-assigned value but it's"}, {"sha": "a28bc5d6ce36db5b99c59224edf870d04a0e8223", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/05a7f25cc42d08aa541f50876915489bdc0eb4bb/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05a7f25cc42d08aa541f50876915489bdc0eb4bb/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=05a7f25cc42d08aa541f50876915489bdc0eb4bb", "patch": "@@ -673,8 +673,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             let cond = unpack!(block = self.as_operand(block, guard));\n             let otherwise = self.cfg.start_new_block();\n             self.cfg.terminate(block, source_info,\n-                               TerminatorKind::If { cond: cond,\n-                                                    targets: (arm_block, otherwise)});\n+                               TerminatorKind::if_(self.hir.tcx(), cond, arm_block, otherwise));\n             Some(otherwise)\n         } else {\n             let source_info = self.source_info(candidate.span);"}, {"sha": "01c0433112bf33aa1edd2929d187bc1564ed9e14", "filename": "src/librustc_mir/build/matches/test.rs", "status": "modified", "additions": 78, "deletions": 74, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/05a7f25cc42d08aa541f50876915489bdc0eb4bb/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05a7f25cc42d08aa541f50876915489bdc0eb4bb/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs?ref=05a7f25cc42d08aa541f50876915489bdc0eb4bb", "patch": "@@ -20,8 +20,9 @@ use build::matches::{Candidate, MatchPair, Test, TestKind};\n use hair::*;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::bitvec::BitVector;\n-use rustc::middle::const_val::ConstVal;\n+use rustc::middle::const_val::{ConstVal, ConstInt};\n use rustc::ty::{self, Ty};\n+use rustc::ty::util::IntTypeExt;\n use rustc::mir::*;\n use rustc::hir::RangeEnd;\n use syntax_pos::Span;\n@@ -182,74 +183,82 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         let source_info = self.source_info(test.span);\n         match test.kind {\n             TestKind::Switch { adt_def, ref variants } => {\n+                // Variants is a BitVec of indexes into adt_def.variants.\n                 let num_enum_variants = self.hir.num_variants(adt_def);\n+                let used_variants = variants.count();\n                 let mut otherwise_block = None;\n-                let target_blocks: Vec<_> = (0..num_enum_variants).map(|i| {\n-                    if variants.contains(i) {\n-                        self.cfg.start_new_block()\n+                let mut target_blocks = Vec::with_capacity(num_enum_variants);\n+                let mut targets = Vec::with_capacity(used_variants + 1);\n+                let mut values = Vec::with_capacity(used_variants);\n+                let tcx = self.hir.tcx();\n+                for (idx, variant) in adt_def.variants.iter().enumerate() {\n+                    target_blocks.place_back() <- if variants.contains(idx) {\n+                        let discr = ConstInt::new_inttype(variant.disr_val, adt_def.discr_ty,\n+                                                          tcx.sess.target.uint_type,\n+                                                          tcx.sess.target.int_type).unwrap();\n+                        values.push(discr);\n+                        *(targets.place_back() <- self.cfg.start_new_block())\n                     } else {\n                         if otherwise_block.is_none() {\n                             otherwise_block = Some(self.cfg.start_new_block());\n                         }\n                         otherwise_block.unwrap()\n-                    }\n-                }).collect();\n-                debug!(\"num_enum_variants: {}, num tested variants: {}, variants: {:?}\",\n-                       num_enum_variants, variants.iter().count(), variants);\n-                self.cfg.terminate(block, source_info, TerminatorKind::Switch {\n-                    discr: lvalue.clone(),\n-                    adt_def: adt_def,\n-                    targets: target_blocks.clone()\n+                    };\n+                }\n+                if let Some(otherwise_block) = otherwise_block {\n+                    targets.push(otherwise_block);\n+                } else {\n+                    values.pop();\n+                }\n+                debug!(\"num_enum_variants: {}, tested variants: {:?}, variants: {:?}\",\n+                       num_enum_variants, values, variants);\n+                let discr_ty = adt_def.discr_ty.to_ty(tcx);\n+                let discr = self.temp(discr_ty);\n+                self.cfg.push_assign(block, source_info, &discr,\n+                                     Rvalue::Discriminant(lvalue.clone()));\n+                assert_eq!(values.len() + 1, targets.len());\n+                self.cfg.terminate(block, source_info, TerminatorKind::SwitchInt {\n+                    discr: Operand::Consume(discr),\n+                    switch_ty: discr_ty,\n+                    values: From::from(values),\n+                    targets: targets\n                 });\n                 target_blocks\n             }\n \n             TestKind::SwitchInt { switch_ty, ref options, indices: _ } => {\n-                let (targets, term) = match switch_ty.sty {\n-                    // If we're matching on boolean we can\n-                    // use the If TerminatorKind instead\n-                    ty::TyBool => {\n-                        assert!(options.len() > 0 && options.len() <= 2);\n-\n-                        let (true_bb, else_bb) =\n-                            (self.cfg.start_new_block(),\n-                             self.cfg.start_new_block());\n-\n-                        let targets = match &options[0] {\n-                            &ConstVal::Bool(true) => vec![true_bb, else_bb],\n-                            &ConstVal::Bool(false) => vec![else_bb, true_bb],\n-                            v => span_bug!(test.span, \"expected boolean value but got {:?}\", v)\n-                        };\n-\n-                        (targets,\n-                         TerminatorKind::If {\n-                             cond: Operand::Consume(lvalue.clone()),\n-                             targets: (true_bb, else_bb)\n-                         })\n-\n-                    }\n-                    _ => {\n-                        // The switch may be inexhaustive so we\n-                        // add a catch all block\n-                        let otherwise = self.cfg.start_new_block();\n-                        let targets: Vec<_> =\n-                            options.iter()\n-                                   .map(|_| self.cfg.start_new_block())\n-                                   .chain(Some(otherwise))\n-                                   .collect();\n-\n-                        (targets.clone(),\n-                         TerminatorKind::SwitchInt {\n-                             discr: lvalue.clone(),\n-                             switch_ty: switch_ty,\n-                             values: options.clone(),\n-                             targets: targets\n-                         })\n-                    }\n+                let (ret, terminator) = if switch_ty.sty == ty::TyBool {\n+                    assert!(options.len() > 0 && options.len() <= 2);\n+                    let (true_bb, false_bb) = (self.cfg.start_new_block(),\n+                                               self.cfg.start_new_block());\n+                    let ret = match &options[0] {\n+                        &ConstVal::Bool(true) => vec![true_bb, false_bb],\n+                        &ConstVal::Bool(false) => vec![false_bb, true_bb],\n+                        v => span_bug!(test.span, \"expected boolean value but got {:?}\", v)\n+                    };\n+                    (ret, TerminatorKind::if_(self.hir.tcx(), Operand::Consume(lvalue.clone()),\n+                                              true_bb, false_bb))\n+                } else {\n+                    // The switch may be inexhaustive so we\n+                    // add a catch all block\n+                    let otherwise = self.cfg.start_new_block();\n+                    let targets: Vec<_> =\n+                        options.iter()\n+                               .map(|_| self.cfg.start_new_block())\n+                               .chain(Some(otherwise))\n+                               .collect();\n+                    let values: Vec<_> = options.iter().map(|v|\n+                        v.to_const_int().expect(\"switching on integral\")\n+                    ).collect();\n+                    (targets.clone(), TerminatorKind::SwitchInt {\n+                        discr: Operand::Consume(lvalue.clone()),\n+                        switch_ty: switch_ty,\n+                        values: From::from(values),\n+                        targets: targets,\n+                    })\n                 };\n-\n-                self.cfg.terminate(block, source_info, term);\n-                targets\n+                self.cfg.terminate(block, source_info, terminator);\n+                ret\n             }\n \n             TestKind::Eq { ref value, mut ty } => {\n@@ -314,11 +323,10 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n                     // check the result\n                     let block = self.cfg.start_new_block();\n-                    self.cfg.terminate(eq_block, source_info, TerminatorKind::If {\n-                        cond: Operand::Consume(eq_result),\n-                        targets: (block, fail),\n-                    });\n-\n+                    self.cfg.terminate(eq_block, source_info,\n+                                       TerminatorKind::if_(self.hir.tcx(),\n+                                                           Operand::Consume(eq_result),\n+                                                           block, fail));\n                     vec![block, fail]\n                 } else {\n                     let block = self.compare(block, fail, test.span, BinOp::Eq, expect, val);\n@@ -360,14 +368,12 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                                                       Operand::Consume(expected)));\n \n                 // branch based on result\n-                let target_blocks: Vec<_> = vec![self.cfg.start_new_block(),\n-                                                 self.cfg.start_new_block()];\n-                self.cfg.terminate(block, source_info, TerminatorKind::If {\n-                    cond: Operand::Consume(result),\n-                    targets: (target_blocks[0], target_blocks[1])\n-                });\n-\n-                target_blocks\n+                let (false_bb, true_bb) = (self.cfg.start_new_block(),\n+                                           self.cfg.start_new_block());\n+                self.cfg.terminate(block, source_info,\n+                                   TerminatorKind::if_(self.hir.tcx(), Operand::Consume(result),\n+                                                       true_bb, false_bb));\n+                vec![true_bb, false_bb]\n             }\n         }\n     }\n@@ -389,11 +395,9 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n         // branch based on result\n         let target_block = self.cfg.start_new_block();\n-        self.cfg.terminate(block, source_info, TerminatorKind::If {\n-            cond: Operand::Consume(result),\n-            targets: (target_block, fail_block)\n-        });\n-\n+        self.cfg.terminate(block, source_info,\n+                           TerminatorKind::if_(self.hir.tcx(), Operand::Consume(result),\n+                                               target_block, fail_block));\n         target_block\n     }\n "}, {"sha": "4ac67cfb2fca10fb935c06b486859fc9b6f4babb", "filename": "src/librustc_mir/hair/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/05a7f25cc42d08aa541f50876915489bdc0eb4bb/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05a7f25cc42d08aa541f50876915489bdc0eb4bb/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fmod.rs?ref=05a7f25cc42d08aa541f50876915489bdc0eb4bb", "patch": "@@ -134,7 +134,8 @@ pub enum ExprKind<'tcx> {\n         op: LogicalOp,\n         lhs: ExprRef<'tcx>,\n         rhs: ExprRef<'tcx>,\n-    },\n+    }, // NOT overloaded!\n+       // LogicalOp is distinct from BinaryOp because of lazy evaluation of the operands.\n     Unary {\n         op: UnOp,\n         arg: ExprRef<'tcx>,"}, {"sha": "9a8fb1099d04bf84a6afa1992fa4c64afb95d471", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/05a7f25cc42d08aa541f50876915489bdc0eb4bb/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05a7f25cc42d08aa541f50876915489bdc0eb4bb/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=05a7f25cc42d08aa541f50876915489bdc0eb4bb", "patch": "@@ -26,6 +26,8 @@ Rust MIR: a lowered representation of Rust. Also: an experiment!\n #![feature(rustc_diagnostic_macros)]\n #![feature(rustc_private)]\n #![feature(staged_api)]\n+#![feature(placement_in_syntax)]\n+#![feature(collection_placement)]\n \n #[macro_use] extern crate log;\n extern crate graphviz as dot;"}, {"sha": "55a26f4b37fe2521ae208ecee36cf8e0ec02aa49", "filename": "src/librustc_mir/transform/no_landing_pads.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/05a7f25cc42d08aa541f50876915489bdc0eb4bb/src%2Flibrustc_mir%2Ftransform%2Fno_landing_pads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05a7f25cc42d08aa541f50876915489bdc0eb4bb/src%2Flibrustc_mir%2Ftransform%2Fno_landing_pads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fno_landing_pads.rs?ref=05a7f25cc42d08aa541f50876915489bdc0eb4bb", "patch": "@@ -28,8 +28,6 @@ impl<'tcx> MutVisitor<'tcx> for NoLandingPads {\n             TerminatorKind::Resume |\n             TerminatorKind::Return |\n             TerminatorKind::Unreachable |\n-            TerminatorKind::If { .. } |\n-            TerminatorKind::Switch { .. } |\n             TerminatorKind::SwitchInt { .. } => {\n                 /* nothing to do */\n             },"}, {"sha": "922521726c6262c2b98897ec7cf5f393cecf10eb", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/05a7f25cc42d08aa541f50876915489bdc0eb4bb/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05a7f25cc42d08aa541f50876915489bdc0eb4bb/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=05a7f25cc42d08aa541f50876915489bdc0eb4bb", "patch": "@@ -394,8 +394,6 @@ impl<'a, 'tcx> Qualifier<'a, 'tcx, 'tcx> {\n                     return Qualif::empty();\n                 }\n \n-                TerminatorKind::If {..} |\n-                TerminatorKind::Switch {..} |\n                 TerminatorKind::SwitchInt {..} |\n                 TerminatorKind::DropAndReplace { .. } |\n                 TerminatorKind::Resume |\n@@ -739,6 +737,14 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                 }\n             }\n \n+            Rvalue::Discriminant(..) => {\n+                // FIXME discriminant\n+                self.add(Qualif::NOT_CONST);\n+                if self.mode != Mode::Fn {\n+                    bug!(\"implement discriminant const qualify\");\n+                }\n+            }\n+\n             Rvalue::Box(_) => {\n                 self.add(Qualif::NOT_CONST);\n                 if self.mode != Mode::Fn {"}, {"sha": "e93a412dc744fcb6ddb4f8ef9a16d957ec4733b6", "filename": "src/librustc_mir/transform/simplify.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/05a7f25cc42d08aa541f50876915489bdc0eb4bb/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05a7f25cc42d08aa541f50876915489bdc0eb4bb/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs?ref=05a7f25cc42d08aa541f50876915489bdc0eb4bb", "patch": "@@ -209,8 +209,6 @@ impl<'a, 'tcx: 'a> CfgSimplifier<'a, 'tcx> {\n     // turn a branch with all successors identical to a goto\n     fn simplify_branch(&mut self, terminator: &mut Terminator<'tcx>) -> bool {\n         match terminator.kind {\n-            TerminatorKind::If { .. } |\n-            TerminatorKind::Switch { .. } |\n             TerminatorKind::SwitchInt { .. } => {},\n             _ => return false\n         };"}, {"sha": "3d5106c4b06f7bd4d7f43ed332e106a28be35625", "filename": "src/librustc_mir/transform/simplify_branches.rs", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/05a7f25cc42d08aa541f50876915489bdc0eb4bb/src%2Flibrustc_mir%2Ftransform%2Fsimplify_branches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05a7f25cc42d08aa541f50876915489bdc0eb4bb/src%2Flibrustc_mir%2Ftransform%2Fsimplify_branches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify_branches.rs?ref=05a7f25cc42d08aa541f50876915489bdc0eb4bb", "patch": "@@ -30,26 +30,30 @@ impl<'l, 'tcx> MirPass<'tcx> for SimplifyBranches<'l> {\n         for block in mir.basic_blocks_mut() {\n             let terminator = block.terminator_mut();\n             terminator.kind = match terminator.kind {\n-                TerminatorKind::If { ref targets, cond: Operand::Constant(Constant {\n-                    literal: Literal::Value {\n-                        value: ConstVal::Bool(cond)\n-                    }, ..\n-                }) } => {\n-                    if cond {\n-                        TerminatorKind::Goto { target: targets.0 }\n+                TerminatorKind::SwitchInt { discr: Operand::Constant(Constant {\n+                    literal: Literal::Value { ref value }, ..\n+                }), ref values, ref targets, .. } => {\n+                    if let Some(ref constint) = value.to_const_int() {\n+                        let (otherwise, targets) = targets.split_last().unwrap();\n+                        let mut ret = TerminatorKind::Goto { target: *otherwise };\n+                        for (v, t) in values.iter().zip(targets.iter()) {\n+                            if v == constint {\n+                                ret = TerminatorKind::Goto { target: *t };\n+                                break;\n+                            }\n+                        }\n+                        ret\n                     } else {\n-                        TerminatorKind::Goto { target: targets.1 }\n+                        continue\n                     }\n-                }\n-\n+                },\n                 TerminatorKind::Assert { target, cond: Operand::Constant(Constant {\n                     literal: Literal::Value {\n                         value: ConstVal::Bool(cond)\n                     }, ..\n                 }), expected, .. } if cond == expected => {\n                     TerminatorKind::Goto { target: target }\n-                }\n-\n+                },\n                 _ => continue\n             };\n         }"}, {"sha": "8ede7aaab5f68c93dc52616a9b9256e5b96418e3", "filename": "src/librustc_mir/transform/type_check.rs", "status": "modified", "additions": 1, "deletions": 29, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/05a7f25cc42d08aa541f50876915489bdc0eb4bb/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05a7f25cc42d08aa541f50876915489bdc0eb4bb/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs?ref=05a7f25cc42d08aa541f50876915489bdc0eb4bb", "patch": "@@ -423,18 +423,8 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                                  lv_ty, rv_ty, terr);\n                 }\n             }\n-\n-            TerminatorKind::If { ref cond, .. } => {\n-                let cond_ty = cond.ty(mir, tcx);\n-                match cond_ty.sty {\n-                    ty::TyBool => {}\n-                    _ => {\n-                        span_mirbug!(self, term, \"bad If ({:?}, not bool\", cond_ty);\n-                    }\n-                }\n-            }\n             TerminatorKind::SwitchInt { ref discr, switch_ty, .. } => {\n-                let discr_ty = discr.ty(mir, tcx).to_ty(tcx);\n+                let discr_ty = discr.ty(mir, tcx);\n                 if let Err(terr) = self.sub_types(discr_ty, switch_ty) {\n                     span_mirbug!(self, term, \"bad SwitchInt ({:?} on {:?}): {:?}\",\n                                  switch_ty, discr_ty, terr);\n@@ -446,19 +436,6 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 }\n                 // FIXME: check the values\n             }\n-            TerminatorKind::Switch { ref discr, adt_def, ref targets } => {\n-                let discr_ty = discr.ty(mir, tcx).to_ty(tcx);\n-                match discr_ty.sty {\n-                    ty::TyAdt(def, _) if def.is_enum() &&\n-                                         def == adt_def &&\n-                                         adt_def.variants.len() == targets.len()\n-                      => {},\n-                    _ => {\n-                        span_mirbug!(self, term, \"bad Switch ({:?} on {:?})\",\n-                                     adt_def, discr_ty);\n-                    }\n-                }\n-            }\n             TerminatorKind::Call { ref func, ref args, ref destination, .. } => {\n                 let func_ty = func.ty(mir, tcx);\n                 debug!(\"check_terminator: call, func_ty={:?}\", func_ty);\n@@ -603,11 +580,6 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         match block.terminator().kind {\n             TerminatorKind::Goto { target } =>\n                 self.assert_iscleanup(mir, block, target, is_cleanup),\n-            TerminatorKind::If { targets: (on_true, on_false), .. } => {\n-                self.assert_iscleanup(mir, block, on_true, is_cleanup);\n-                self.assert_iscleanup(mir, block, on_false, is_cleanup);\n-            }\n-            TerminatorKind::Switch { ref targets, .. } |\n             TerminatorKind::SwitchInt { ref targets, .. } => {\n                 for target in targets {\n                     self.assert_iscleanup(mir, block, *target, is_cleanup);"}, {"sha": "517a4720563343d8f56ec8f97471741c12064e6a", "filename": "src/librustc_passes/mir_stats.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/05a7f25cc42d08aa541f50876915489bdc0eb4bb/src%2Flibrustc_passes%2Fmir_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05a7f25cc42d08aa541f50876915489bdc0eb4bb/src%2Flibrustc_passes%2Fmir_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fmir_stats.rs?ref=05a7f25cc42d08aa541f50876915489bdc0eb4bb", "patch": "@@ -148,8 +148,6 @@ impl<'a, 'tcx> mir_visit::Visitor<'tcx> for StatCollector<'a, 'tcx> {\n         self.record(\"TerminatorKind\", kind);\n         self.record(match *kind {\n             TerminatorKind::Goto { .. } => \"TerminatorKind::Goto\",\n-            TerminatorKind::If { .. } => \"TerminatorKind::If\",\n-            TerminatorKind::Switch { .. } => \"TerminatorKind::Switch\",\n             TerminatorKind::SwitchInt { .. } => \"TerminatorKind::SwitchInt\",\n             TerminatorKind::Resume => \"TerminatorKind::Resume\",\n             TerminatorKind::Return => \"TerminatorKind::Return\",\n@@ -186,6 +184,7 @@ impl<'a, 'tcx> mir_visit::Visitor<'tcx> for StatCollector<'a, 'tcx> {\n             Rvalue::BinaryOp(..) => \"Rvalue::BinaryOp\",\n             Rvalue::CheckedBinaryOp(..) => \"Rvalue::CheckedBinaryOp\",\n             Rvalue::UnaryOp(..) => \"Rvalue::UnaryOp\",\n+            Rvalue::Discriminant(..) => \"Rvalue::Discriminant\",\n             Rvalue::Box(..) => \"Rvalue::Box\",\n             Rvalue::Aggregate(ref kind, ref _operands) => {\n                 // AggregateKind is not distinguished by visit API, so"}, {"sha": "11d3fae823830318937767efd195601fa3f9643b", "filename": "src/librustc_trans/adt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/05a7f25cc42d08aa541f50876915489bdc0eb4bb/src%2Flibrustc_trans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05a7f25cc42d08aa541f50876915489bdc0eb4bb/src%2Flibrustc_trans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fadt.rs?ref=05a7f25cc42d08aa541f50876915489bdc0eb4bb", "patch": "@@ -318,7 +318,7 @@ pub fn trans_get_discr<'a, 'tcx>(\n     };\n     match cast_to {\n         None => val,\n-        Some(llty) => if is_discr_signed(&l) { bcx.sext(val, llty) } else { bcx.zext(val, llty) }\n+        Some(llty) => bcx.intcast(val, llty, is_discr_signed(&l))\n     }\n }\n "}, {"sha": "41c0eaa52a77d1bc1a2f1d6cec13bc84a850a496", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/05a7f25cc42d08aa541f50876915489bdc0eb4bb/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05a7f25cc42d08aa541f50876915489bdc0eb4bb/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=05a7f25cc42d08aa541f50876915489bdc0eb4bb", "patch": "@@ -536,7 +536,7 @@ pub fn call_memcpy<'a, 'tcx>(b: &Builder<'a, 'tcx>,\n     let memcpy = ccx.get_intrinsic(&key);\n     let src_ptr = b.pointercast(src, Type::i8p(ccx));\n     let dst_ptr = b.pointercast(dst, Type::i8p(ccx));\n-    let size = b.intcast(n_bytes, ccx.int_type());\n+    let size = b.intcast(n_bytes, ccx.int_type(), false);\n     let align = C_i32(ccx, align as i32);\n     let volatile = C_bool(ccx, false);\n     b.call(memcpy, &[dst_ptr, src_ptr, size, align, volatile], None);"}, {"sha": "f64e581c1773ee2a81e42a68c55f8526abb06c2b", "filename": "src/librustc_trans/builder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/05a7f25cc42d08aa541f50876915489bdc0eb4bb/src%2Flibrustc_trans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05a7f25cc42d08aa541f50876915489bdc0eb4bb/src%2Flibrustc_trans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbuilder.rs?ref=05a7f25cc42d08aa541f50876915489bdc0eb4bb", "patch": "@@ -780,10 +780,10 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n     }\n \n-    pub fn intcast(&self, val: ValueRef, dest_ty: Type) -> ValueRef {\n+    pub fn intcast(&self, val: ValueRef, dest_ty: Type, is_signed: bool) -> ValueRef {\n         self.count_insn(\"intcast\");\n         unsafe {\n-            llvm::LLVMBuildIntCast(self.llbuilder, val, dest_ty.to_ref(), noname())\n+            llvm::LLVMRustBuildIntCast(self.llbuilder, val, dest_ty.to_ref(), is_signed)\n         }\n     }\n "}, {"sha": "11c0bf852f727ac829d734d6e13db7f0ed7f97cf", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/05a7f25cc42d08aa541f50876915489bdc0eb4bb/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05a7f25cc42d08aa541f50876915489bdc0eb4bb/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=05a7f25cc42d08aa541f50876915489bdc0eb4bb", "patch": "@@ -1476,7 +1476,7 @@ fn prepare_enum_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                     DIB(cx),\n                     name.as_ptr(),\n                     // FIXME: what if enumeration has i128 discriminant?\n-                    v.disr_val.to_u128_unchecked() as u64)\n+                    v.disr_val as u64)\n             }\n         })\n         .collect();"}, {"sha": "f3a62bc85b8d93252c441c43ca62f63e9ab0e24e", "filename": "src/librustc_trans/disr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/05a7f25cc42d08aa541f50876915489bdc0eb4bb/src%2Flibrustc_trans%2Fdisr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05a7f25cc42d08aa541f50876915489bdc0eb4bb/src%2Flibrustc_trans%2Fdisr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdisr.rs?ref=05a7f25cc42d08aa541f50876915489bdc0eb4bb", "patch": "@@ -27,7 +27,7 @@ impl ::std::ops::BitAnd for Disr {\n impl From<::rustc::ty::Disr> for Disr {\n     fn from(i: ::rustc::ty::Disr) -> Disr {\n         // FIXME: what if discr has 128 bit discr?\n-        Disr(i.to_u128_unchecked() as u64)\n+        Disr(i as u64)\n     }\n }\n "}, {"sha": "2c3b479c7dd0f6fb218b873bf05788eb1553c67f", "filename": "src/librustc_trans/mir/analyze.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/05a7f25cc42d08aa541f50876915489bdc0eb4bb/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05a7f25cc42d08aa541f50876915489bdc0eb4bb/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs?ref=05a7f25cc42d08aa541f50876915489bdc0eb4bb", "patch": "@@ -156,10 +156,10 @@ impl<'mir, 'a, 'tcx> Visitor<'tcx> for LocalAnalyzer<'mir, 'a, 'tcx> {\n \n                 LvalueContext::StorageLive |\n                 LvalueContext::StorageDead |\n+                LvalueContext::Inspect |\n                 LvalueContext::Consume => {}\n \n                 LvalueContext::Store |\n-                LvalueContext::Inspect |\n                 LvalueContext::Borrow { .. } |\n                 LvalueContext::Projection(..) => {\n                     self.mark_as_lvalue(index);\n@@ -204,8 +204,6 @@ pub fn cleanup_kinds<'a, 'tcx>(mir: &mir::Mir<'tcx>) -> IndexVec<mir::BasicBlock\n                 TerminatorKind::Resume |\n                 TerminatorKind::Return |\n                 TerminatorKind::Unreachable |\n-                TerminatorKind::If { .. } |\n-                TerminatorKind::Switch { .. } |\n                 TerminatorKind::SwitchInt { .. } => {\n                     /* nothing to do */\n                 }"}, {"sha": "651d0066b12dd3d9f944eb21a4d00e631524bcd0", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 18, "deletions": 54, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/05a7f25cc42d08aa541f50876915489bdc0eb4bb/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05a7f25cc42d08aa541f50876915489bdc0eb4bb/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=05a7f25cc42d08aa541f50876915489bdc0eb4bb", "patch": "@@ -11,25 +11,23 @@\n use llvm::{self, ValueRef, BasicBlockRef};\n use rustc_const_eval::{ErrKind, ConstEvalErr, note_const_eval_err};\n use rustc::middle::lang_items;\n+use rustc::middle::const_val::ConstInt;\n use rustc::ty::{self, layout, TypeFoldable};\n use rustc::mir;\n use abi::{Abi, FnType, ArgType};\n-use adt;\n use base::{self, Lifetime};\n use callee::{Callee, CalleeData, Fn, Intrinsic, NamedTupleConstructor, Virtual};\n use builder::Builder;\n use common::{self, Funclet};\n use common::{C_bool, C_str_slice, C_struct, C_u32, C_undef};\n use consts;\n-use Disr;\n use machine::{llalign_of_min, llbitsize_of_real};\n use meth;\n use type_of::{self, align_of};\n use glue;\n use type_::Type;\n \n use rustc_data_structures::indexed_vec::IndexVec;\n-use rustc_data_structures::fx::FxHashMap;\n use syntax::symbol::Symbol;\n \n use std::cmp;\n@@ -136,62 +134,28 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 funclet_br(self, bcx, target);\n             }\n \n-            mir::TerminatorKind::If { ref cond, targets: (true_bb, false_bb) } => {\n-                let cond = self.trans_operand(&bcx, cond);\n-\n-                let lltrue = llblock(self, true_bb);\n-                let llfalse = llblock(self, false_bb);\n-                bcx.cond_br(cond.immediate(), lltrue, llfalse);\n-            }\n-\n-            mir::TerminatorKind::Switch { ref discr, ref adt_def, ref targets } => {\n-                let discr_lvalue = self.trans_lvalue(&bcx, discr);\n-                let ty = discr_lvalue.ty.to_ty(bcx.tcx());\n-                let discr = adt::trans_get_discr(\n-                    &bcx, ty, discr_lvalue.llval, discr_lvalue.alignment,\n-                    None, true);\n-\n-                let mut bb_hist = FxHashMap();\n-                for target in targets {\n-                    *bb_hist.entry(target).or_insert(0) += 1;\n-                }\n-                let (default_bb, default_blk) = match bb_hist.iter().max_by_key(|&(_, c)| c) {\n-                    // If a single target basic blocks is predominant, promote that to be the\n-                    // default case for the switch instruction to reduce the size of the generated\n-                    // code. This is especially helpful in cases like an if-let on a huge enum.\n-                    // Note: This optimization is only valid for exhaustive matches.\n-                    Some((&&bb, &c)) if c > targets.len() / 2 => {\n-                        (Some(bb), llblock(self, bb))\n+            mir::TerminatorKind::SwitchInt { ref discr, switch_ty, ref values, ref targets } => {\n+                let discr = self.trans_operand(&bcx, discr);\n+                if switch_ty == bcx.tcx().types.bool {\n+                    let lltrue = llblock(self, targets[0]);\n+                    let llfalse = llblock(self, targets[1]);\n+                    if let [ConstInt::Infer(0)] = values[..] {\n+                        bcx.cond_br(discr.immediate(), llfalse, lltrue);\n+                    } else {\n+                        bcx.cond_br(discr.immediate(), lltrue, llfalse);\n                     }\n-                    // We're generating an exhaustive switch, so the else branch\n-                    // can't be hit.  Branching to an unreachable instruction\n-                    // lets LLVM know this\n-                    _ => (None, self.unreachable_block())\n-                };\n-                let switch = bcx.switch(discr, default_blk, targets.len());\n-                assert_eq!(adt_def.variants.len(), targets.len());\n-                for (adt_variant, &target) in adt_def.variants.iter().zip(targets) {\n-                    if default_bb != Some(target) {\n-                        let llbb = llblock(self, target);\n-                        let llval = adt::trans_case(&bcx, ty, Disr::from(adt_variant.disr_val));\n-                        bcx.add_case(switch, llval, llbb)\n+                } else {\n+                    let (otherwise, targets) = targets.split_last().unwrap();\n+                    let switch = bcx.switch(discr.immediate(),\n+                                            llblock(self, *otherwise), values.len());\n+                    for (value, target) in values.iter().zip(targets) {\n+                        let val = Const::from_constint(bcx.ccx, value);\n+                        let llbb = llblock(self, *target);\n+                        bcx.add_case(switch, val.llval, llbb)\n                     }\n                 }\n             }\n \n-            mir::TerminatorKind::SwitchInt { ref discr, switch_ty, ref values, ref targets } => {\n-                let (otherwise, targets) = targets.split_last().unwrap();\n-                let lv = self.trans_lvalue(&bcx, discr);\n-                let discr = bcx.load(lv.llval, lv.alignment.to_align());\n-                let discr = base::to_immediate(&bcx, discr, switch_ty);\n-                let switch = bcx.switch(discr, llblock(self, *otherwise), values.len());\n-                for (value, target) in values.iter().zip(targets) {\n-                    let val = Const::from_constval(bcx.ccx, value.clone(), switch_ty);\n-                    let llbb = llblock(self, *target);\n-                    bcx.add_case(switch, val.llval, llbb)\n-                }\n-            }\n-\n             mir::TerminatorKind::Return => {\n                 let ret = self.fn_ty.ret;\n                 if ret.is_ignore() || ret.is_indirect() {"}, {"sha": "19139301bb0c48449beadcf6faccfa669e895bed", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 28, "deletions": 20, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/05a7f25cc42d08aa541f50876915489bdc0eb4bb/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05a7f25cc42d08aa541f50876915489bdc0eb4bb/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=05a7f25cc42d08aa541f50876915489bdc0eb4bb", "patch": "@@ -61,6 +61,33 @@ impl<'tcx> Const<'tcx> {\n         }\n     }\n \n+    pub fn from_constint<'a>(ccx: &CrateContext<'a, 'tcx>, ci: &ConstInt)\n+    -> Const<'tcx> {\n+        let tcx = ccx.tcx();\n+        let (llval, ty) = match *ci {\n+            I8(v) => (C_integral(Type::i8(ccx), v as u64, true), tcx.types.i8),\n+            I16(v) => (C_integral(Type::i16(ccx), v as u64, true), tcx.types.i16),\n+            I32(v) => (C_integral(Type::i32(ccx), v as u64, true), tcx.types.i32),\n+            I64(v) => (C_integral(Type::i64(ccx), v as u64, true), tcx.types.i64),\n+            I128(v) => (C_big_integral(Type::i128(ccx), v as u128), tcx.types.i128),\n+            Isize(v) => {\n+                let i = v.as_i64(ccx.tcx().sess.target.int_type);\n+                (C_integral(Type::int(ccx), i as u64, true), tcx.types.isize)\n+            },\n+            U8(v) => (C_integral(Type::i8(ccx), v as u64, false), tcx.types.u8),\n+            U16(v) => (C_integral(Type::i16(ccx), v as u64, false), tcx.types.u16),\n+            U32(v) => (C_integral(Type::i32(ccx), v as u64, false), tcx.types.u32),\n+            U64(v) => (C_integral(Type::i64(ccx), v, false), tcx.types.u64),\n+            U128(v) => (C_big_integral(Type::i128(ccx), v), tcx.types.u128),\n+            Usize(v) => {\n+                let u = v.as_u64(ccx.tcx().sess.target.uint_type);\n+                (C_integral(Type::int(ccx), u, false), tcx.types.usize)\n+            },\n+            Infer(_) | InferSigned(_) => bug!(\"MIR must not use `{:?}`\", ci),\n+        };\n+        Const { llval: llval, ty: ty }\n+    }\n+\n     /// Translate ConstVal into a LLVM constant value.\n     pub fn from_constval<'a>(ccx: &CrateContext<'a, 'tcx>,\n                              cv: ConstVal,\n@@ -72,26 +99,7 @@ impl<'tcx> Const<'tcx> {\n             ConstVal::Float(F64(v)) => C_floating_f64(v, llty),\n             ConstVal::Float(FInfer {..}) => bug!(\"MIR must not use `{:?}`\", cv),\n             ConstVal::Bool(v) => C_bool(ccx, v),\n-            ConstVal::Integral(I8(v)) => C_integral(Type::i8(ccx), v as u64, true),\n-            ConstVal::Integral(I16(v)) => C_integral(Type::i16(ccx), v as u64, true),\n-            ConstVal::Integral(I32(v)) => C_integral(Type::i32(ccx), v as u64, true),\n-            ConstVal::Integral(I64(v)) => C_integral(Type::i64(ccx), v as u64, true),\n-            ConstVal::Integral(I128(v)) => C_big_integral(Type::i128(ccx), v as u128),\n-            ConstVal::Integral(Isize(v)) => {\n-                let i = v.as_i64(ccx.tcx().sess.target.int_type);\n-                C_integral(Type::int(ccx), i as u64, true)\n-            },\n-            ConstVal::Integral(U8(v)) => C_integral(Type::i8(ccx), v as u64, false),\n-            ConstVal::Integral(U16(v)) => C_integral(Type::i16(ccx), v as u64, false),\n-            ConstVal::Integral(U32(v)) => C_integral(Type::i32(ccx), v as u64, false),\n-            ConstVal::Integral(U64(v)) => C_integral(Type::i64(ccx), v, false),\n-            ConstVal::Integral(U128(v)) => C_big_integral(Type::i128(ccx), v),\n-            ConstVal::Integral(Usize(v)) => {\n-                let u = v.as_u64(ccx.tcx().sess.target.uint_type);\n-                C_integral(Type::int(ccx), u, false)\n-            },\n-            ConstVal::Integral(Infer(_)) |\n-            ConstVal::Integral(InferSigned(_)) => bug!(\"MIR must not use `{:?}`\", cv),\n+            ConstVal::Integral(ref i) => return Const::from_constint(ccx, i),\n             ConstVal::Str(ref v) => C_str_slice(ccx, v.clone()),\n             ConstVal::ByteStr(ref v) => consts::addr_of(ccx, C_bytes(ccx, v), 1, \"byte_str\"),\n             ConstVal::Struct(_) | ConstVal::Tuple(_) |"}, {"sha": "38ee67796c6de2dcb03ae49def7ed147ae2756bd", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/05a7f25cc42d08aa541f50876915489bdc0eb4bb/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05a7f25cc42d08aa541f50876915489bdc0eb4bb/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=05a7f25cc42d08aa541f50876915489bdc0eb4bb", "patch": "@@ -286,17 +286,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n \n                         let newval = match (r_t_in, r_t_out) {\n                             (CastTy::Int(_), CastTy::Int(_)) => {\n-                                let srcsz = ll_t_in.int_width();\n-                                let dstsz = ll_t_out.int_width();\n-                                if srcsz == dstsz {\n-                                    bcx.bitcast(llval, ll_t_out)\n-                                } else if srcsz > dstsz {\n-                                    bcx.trunc(llval, ll_t_out)\n-                                } else if signed {\n-                                    bcx.sext(llval, ll_t_out)\n-                                } else {\n-                                    bcx.zext(llval, ll_t_out)\n-                                }\n+                                bcx.intcast(llval, ll_t_out, signed)\n                             }\n                             (CastTy::Float, CastTy::Float) => {\n                                 let srcsz = ll_t_in.float_width();\n@@ -433,6 +423,19 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 })\n             }\n \n+            mir::Rvalue::Discriminant(ref lvalue) => {\n+                let discr_lvalue = self.trans_lvalue(&bcx, lvalue);\n+                let enum_ty = discr_lvalue.ty.to_ty(bcx.tcx());\n+                let discr_ty = rvalue.ty(&*self.mir, bcx.tcx()).unwrap();\n+                let discr_type = type_of::immediate_type_of(bcx.ccx, discr_ty);\n+                let discr = adt::trans_get_discr(&bcx, enum_ty, discr_lvalue.llval,\n+                                                  discr_lvalue.alignment, Some(discr_type), true);\n+                (bcx, OperandRef {\n+                    val: OperandValue::Immediate(discr),\n+                    ty: discr_ty\n+                })\n+            }\n+\n             mir::Rvalue::Box(content_ty) => {\n                 let content_ty: Ty<'tcx> = self.monomorphize(&content_ty);\n                 let llty = type_of::type_of(bcx.ccx, content_ty);\n@@ -661,6 +664,7 @@ pub fn rvalue_creates_operand(rvalue: &mir::Rvalue) -> bool {\n         mir::Rvalue::BinaryOp(..) |\n         mir::Rvalue::CheckedBinaryOp(..) |\n         mir::Rvalue::UnaryOp(..) |\n+        mir::Rvalue::Discriminant(..) |\n         mir::Rvalue::Box(..) |\n         mir::Rvalue::Use(..) =>\n             true,"}, {"sha": "217405a81ec2dc7e5b01088fe0592b1aa670cfc6", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 63, "deletions": 59, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/05a7f25cc42d08aa541f50876915489bdc0eb4bb/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05a7f25cc42d08aa541f50876915489bdc0eb4bb/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=05a7f25cc42d08aa541f50876915489bdc0eb4bb", "patch": "@@ -1004,9 +1004,8 @@ fn convert_struct_def<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     let did = ccx.tcx.hir.local_def_id(it.id);\n     // Use separate constructor id for unit/tuple structs and reuse did for braced structs.\n     let ctor_id = if !def.is_struct() { Some(ccx.tcx.hir.local_def_id(def.id())) } else { None };\n-    let variants = vec![convert_struct_variant(ccx, ctor_id.unwrap_or(did), it.name,\n-                                               ConstInt::Infer(0), def)];\n-    let adt = ccx.tcx.alloc_adt_def(did, AdtKind::Struct, variants,\n+    let variants = vec![convert_struct_variant(ccx, ctor_id.unwrap_or(did), it.name, 0, def)];\n+    let adt = ccx.tcx.alloc_adt_def(did, AdtKind::Struct, None, variants,\n         ReprOptions::new(&ccx.tcx, did));\n     if let Some(ctor_id) = ctor_id {\n         // Make adt definition available through constructor id as well.\n@@ -1023,63 +1022,65 @@ fn convert_union_def<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                 -> &'tcx ty::AdtDef\n {\n     let did = ccx.tcx.hir.local_def_id(it.id);\n-    let variants = vec![convert_struct_variant(ccx, did, it.name, ConstInt::Infer(0), def)];\n-\n-    let adt = ccx.tcx.alloc_adt_def(did, AdtKind::Union, variants, ReprOptions::new(&ccx.tcx, did));\n+    let variants = vec![convert_struct_variant(ccx, did, it.name, 0, def)];\n+    let adt = ccx.tcx.alloc_adt_def(did, AdtKind::Union, None, variants,\n+                                    ReprOptions::new(&ccx.tcx, did));\n     ccx.tcx.adt_defs.borrow_mut().insert(did, adt);\n     adt\n }\n \n-    fn evaluate_disr_expr(ccx: &CrateCtxt, repr_ty: attr::IntType, body: hir::BodyId)\n-                          -> Option<ty::Disr> {\n-        let e = &ccx.tcx.hir.body(body).value;\n-        debug!(\"disr expr, checking {}\", ccx.tcx.hir.node_to_pretty_string(e.id));\n-\n-        let ty_hint = repr_ty.to_ty(ccx.tcx);\n-        let print_err = |cv: ConstVal| {\n-            struct_span_err!(ccx.tcx.sess, e.span, E0079, \"mismatched types\")\n-                .note_expected_found(&\"type\", &ty_hint, &format!(\"{}\", cv.description()))\n-                .span_label(e.span, &format!(\"expected '{}' type\", ty_hint))\n-                .emit();\n-        };\n+fn evaluate_disr_expr(ccx: &CrateCtxt, repr_ty: attr::IntType, body: hir::BodyId)\n+                      -> Option<ConstInt> {\n+    let e = &ccx.tcx.hir.body(body).value;\n+    debug!(\"disr expr, checking {}\", ccx.tcx.hir.node_to_pretty_string(e.id));\n+\n+    let ty_hint = repr_ty.to_ty(ccx.tcx);\n+    let print_err = |cv: ConstVal| {\n+        struct_span_err!(ccx.tcx.sess, e.span, E0079, \"mismatched types\")\n+            .note_expected_found(&\"type\", &ty_hint, &format!(\"{}\", cv.description()))\n+            .span_label(e.span, &format!(\"expected '{}' type\", ty_hint))\n+            .emit();\n+    };\n \n-        let hint = UncheckedExprHint(ty_hint);\n-        match ConstContext::new(ccx.tcx, body).eval(e, hint) {\n-            Ok(ConstVal::Integral(i)) => {\n-                // FIXME: eval should return an error if the hint is wrong\n-                match (repr_ty, i) {\n-                    (attr::SignedInt(ast::IntTy::I8), ConstInt::I8(_)) |\n-                    (attr::SignedInt(ast::IntTy::I16), ConstInt::I16(_)) |\n-                    (attr::SignedInt(ast::IntTy::I32), ConstInt::I32(_)) |\n-                    (attr::SignedInt(ast::IntTy::I64), ConstInt::I64(_)) |\n-                    (attr::SignedInt(ast::IntTy::I128), ConstInt::I128(_)) |\n-                    (attr::SignedInt(ast::IntTy::Is), ConstInt::Isize(_)) |\n-                    (attr::UnsignedInt(ast::UintTy::U8), ConstInt::U8(_)) |\n-                    (attr::UnsignedInt(ast::UintTy::U16), ConstInt::U16(_)) |\n-                    (attr::UnsignedInt(ast::UintTy::U32), ConstInt::U32(_)) |\n-                    (attr::UnsignedInt(ast::UintTy::U64), ConstInt::U64(_)) |\n-                    (attr::UnsignedInt(ast::UintTy::U128), ConstInt::U128(_)) |\n-                    (attr::UnsignedInt(ast::UintTy::Us), ConstInt::Usize(_)) => Some(i),\n-                    (_, i) => {\n-                        print_err(ConstVal::Integral(i));\n-                        None\n-                    },\n-                }\n-            },\n-            Ok(cv) => {\n-                print_err(cv);\n-                None\n-            },\n-            // enum variant evaluation happens before the global constant check\n-            // so we need to report the real error\n-            Err(err) => {\n-                let mut diag = report_const_eval_err(\n-                    ccx.tcx, &err, e.span, \"enum discriminant\");\n-                diag.emit();\n-                None\n+    let hint = UncheckedExprHint(ty_hint);\n+    match ConstContext::new(ccx.tcx, body).eval(e, hint) {\n+        Ok(ConstVal::Integral(i)) => {\n+            // FIXME: eval should return an error if the hint does not match the type of the body.\n+            // i.e. eventually the match below would not exist.\n+            match (repr_ty, i) {\n+                (attr::SignedInt(ast::IntTy::I8), ConstInt::I8(_)) |\n+                (attr::SignedInt(ast::IntTy::I16), ConstInt::I16(_)) |\n+                (attr::SignedInt(ast::IntTy::I32), ConstInt::I32(_)) |\n+                (attr::SignedInt(ast::IntTy::I64), ConstInt::I64(_)) |\n+                (attr::SignedInt(ast::IntTy::I128), ConstInt::I128(_)) |\n+                (attr::SignedInt(ast::IntTy::Is), ConstInt::Isize(_)) |\n+                (attr::UnsignedInt(ast::UintTy::U8), ConstInt::U8(_)) |\n+                (attr::UnsignedInt(ast::UintTy::U16), ConstInt::U16(_)) |\n+                (attr::UnsignedInt(ast::UintTy::U32), ConstInt::U32(_)) |\n+                (attr::UnsignedInt(ast::UintTy::U64), ConstInt::U64(_)) |\n+                (attr::UnsignedInt(ast::UintTy::U128), ConstInt::U128(_)) |\n+                (attr::UnsignedInt(ast::UintTy::Us), ConstInt::Usize(_)) =>\n+                    Some(i),\n+                (_, i) => {\n+                    print_err(ConstVal::Integral(i));\n+                    None\n+                },\n             }\n+        },\n+        Ok(cv) => {\n+            print_err(cv);\n+            None\n+        },\n+        // enum variant evaluation happens before the global constant check\n+        // so we need to report the real error\n+        Err(err) => {\n+            let mut diag = report_const_eval_err(\n+                ccx.tcx, &err, e.span, \"enum discriminant\");\n+            diag.emit();\n+            None\n         }\n     }\n+}\n \n fn convert_enum_def<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                               it: &hir::Item,\n@@ -1090,13 +1091,17 @@ fn convert_enum_def<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     let did = tcx.hir.local_def_id(it.id);\n     let repr_hints = tcx.lookup_repr_hints(did);\n     let repr_type = tcx.enum_repr_type(repr_hints.get(0));\n-    let initial = repr_type.initial_discriminant(tcx);\n-    let mut prev_disr = None::<ty::Disr>;\n+    let initial = ConstInt::new_inttype(repr_type.initial_discriminant(tcx), repr_type,\n+                                        tcx.sess.target.uint_type, tcx.sess.target.int_type)\n+        .unwrap();\n+    let mut prev_disr = None::<ConstInt>;\n     let variants = def.variants.iter().map(|v| {\n         let wrapped_disr = prev_disr.map_or(initial, |d| d.wrap_incr());\n         let disr = if let Some(e) = v.node.disr_expr {\n+            // FIXME: i128 discriminants\n             evaluate_disr_expr(ccx, repr_type, e)\n-        } else if let Some(disr) = repr_type.disr_incr(tcx, prev_disr) {\n+        } else if let Some(disr) = prev_disr.map_or(Some(initial),\n+                                                    |v| (v + ConstInt::Infer(1)).ok()) {\n             Some(disr)\n         } else {\n             struct_span_err!(tcx.sess, v.span, E0370,\n@@ -1108,12 +1113,11 @@ fn convert_enum_def<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             None\n         }.unwrap_or(wrapped_disr);\n         prev_disr = Some(disr);\n-\n         let did = tcx.hir.local_def_id(v.node.data.id());\n-        convert_struct_variant(ccx, did, v.node.name, disr, &v.node.data)\n+        convert_struct_variant(ccx, did, v.node.name, disr.to_u128_unchecked(), &v.node.data)\n     }).collect();\n-\n-    let adt = tcx.alloc_adt_def(did, AdtKind::Enum, variants, ReprOptions::new(&ccx.tcx, did));\n+    let adt = tcx.alloc_adt_def(did, AdtKind::Enum, Some(repr_type), variants,\n+                                ReprOptions::new(&ccx.tcx, did));\n     tcx.adt_defs.borrow_mut().insert(did, adt);\n     adt\n }"}, {"sha": "c6847249803e35282b13f1147da033fa069054da", "filename": "src/libserialize/serialize.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/05a7f25cc42d08aa541f50876915489bdc0eb4bb/src%2Flibserialize%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05a7f25cc42d08aa541f50876915489bdc0eb4bb/src%2Flibserialize%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fserialize.rs?ref=05a7f25cc42d08aa541f50876915489bdc0eb4bb", "patch": "@@ -567,6 +567,34 @@ impl<T:Decodable> Decodable for Vec<T> {\n     }\n }\n \n+impl<'a, T:Encodable> Encodable for Cow<'a, [T]>\n+where [T]: ToOwned<Owned = Vec<T>>\n+{\n+    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+        s.emit_seq(self.len(), |s| {\n+            for (i, e) in self.iter().enumerate() {\n+                s.emit_seq_elt(i, |s| e.encode(s))?\n+            }\n+            Ok(())\n+        })\n+    }\n+}\n+\n+impl<T:Decodable+ToOwned> Decodable for Cow<'static, [T]>\n+where [T]: ToOwned<Owned = Vec<T>>\n+{\n+    fn decode<D: Decoder>(d: &mut D) -> Result<Cow<'static, [T]>, D::Error> {\n+        d.read_seq(|d, len| {\n+            let mut v = Vec::with_capacity(len);\n+            for i in 0..len {\n+                v.push(d.read_seq_elt(i, |d| Decodable::decode(d))?);\n+            }\n+            Ok(Cow::Owned(v))\n+        })\n+    }\n+}\n+\n+\n impl<T:Encodable> Encodable for Option<T> {\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_option(|s| {"}, {"sha": "e89f48b4105d388f283bdd2971e5795e2e4a4f07", "filename": "src/rustllvm/RustWrapper.cpp", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/05a7f25cc42d08aa541f50876915489bdc0eb4bb/src%2Frustllvm%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/05a7f25cc42d08aa541f50876915489bdc0eb4bb/src%2Frustllvm%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FRustWrapper.cpp?ref=05a7f25cc42d08aa541f50876915489bdc0eb4bb", "patch": "@@ -1316,6 +1316,12 @@ extern \"C\" LLVMRustVisibility LLVMRustGetVisibility(LLVMValueRef V) {\n   return toRust(LLVMGetVisibility(V));\n }\n \n+// Oh hey, a binding that makes sense for once? (because LLVM\u2019s own do not)\n+extern \"C\" LLVMValueRef LLVMRustBuildIntCast(LLVMBuilderRef B, LLVMValueRef Val,\n+                                             LLVMTypeRef DestTy, bool isSigned) {\n+  return wrap(unwrap(B)->CreateIntCast(unwrap(Val), unwrap(DestTy), isSigned, \"\"));\n+}\n+\n extern \"C\" void LLVMRustSetVisibility(LLVMValueRef V,\n                                       LLVMRustVisibility RustVisibility) {\n   LLVMSetVisibility(V, fromRust(RustVisibility));"}, {"sha": "aa100da60132fbf3631ede317a9186366e37be55", "filename": "src/test/codegen/match.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/05a7f25cc42d08aa541f50876915489bdc0eb4bb/src%2Ftest%2Fcodegen%2Fmatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05a7f25cc42d08aa541f50876915489bdc0eb4bb/src%2Ftest%2Fcodegen%2Fmatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fmatch.rs?ref=05a7f25cc42d08aa541f50876915489bdc0eb4bb", "patch": "@@ -20,9 +20,13 @@ pub enum E {\n // CHECK-LABEL: @exhaustive_match\n #[no_mangle]\n pub fn exhaustive_match(e: E) {\n-// CHECK: switch{{.*}}, label %[[DEFAULT:[a-zA-Z0-9_]+]]\n-// CHECK: [[DEFAULT]]:\n-// CHECK-NEXT: unreachable\n+// CHECK: switch{{.*}}, label %[[OTHERWISE:[a-zA-Z0-9_]+]] [\n+// CHECK-NEXT: i[[TY:[0-9]+]] [[DISCR:[0-9]+]], label %[[TRUE:[a-zA-Z0-9_]+]]\n+// CHECK-NEXT: ]\n+// CHECK: [[TRUE]]:\n+// CHECK-NEXT: br label %[[EXIT:[a-zA-Z0-9_]+]]\n+// CHECK: [[OTHERWISE]]:\n+// CHECK-NEXT: br label %[[EXIT:[a-zA-Z0-9_]+]]\n     match e {\n         E::A => (),\n         E::B => (),"}, {"sha": "e12eff72c7f41f7e6de35ade2c315ed6c3321907", "filename": "src/test/compile-fail/E0081.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/05a7f25cc42d08aa541f50876915489bdc0eb4bb/src%2Ftest%2Fcompile-fail%2FE0081.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05a7f25cc42d08aa541f50876915489bdc0eb4bb/src%2Ftest%2Fcompile-fail%2FE0081.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0081.rs?ref=05a7f25cc42d08aa541f50876915489bdc0eb4bb", "patch": "@@ -9,10 +9,10 @@\n // except according to those terms.\n \n enum Enum {\n-    P = 3, //~ NOTE first use of `3isize`\n+    P = 3, //~ NOTE first use of `3`\n     X = 3,\n-    //~^ ERROR discriminant value `3isize` already exists\n-    //~| NOTE enum already has `3isize`\n+    //~^ ERROR discriminant value `3` already exists\n+    //~| NOTE enum already has `3`\n     Y = 5\n }\n "}, {"sha": "0d5f5fd75eba881378e45d963ba5f95e3521395a", "filename": "src/test/compile-fail/issue-15524.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/05a7f25cc42d08aa541f50876915489bdc0eb4bb/src%2Ftest%2Fcompile-fail%2Fissue-15524.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05a7f25cc42d08aa541f50876915489bdc0eb4bb/src%2Ftest%2Fcompile-fail%2Fissue-15524.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-15524.rs?ref=05a7f25cc42d08aa541f50876915489bdc0eb4bb", "patch": "@@ -12,20 +12,20 @@ const N: isize = 1;\n \n enum Foo {\n     A = 1,\n-    //~^ NOTE first use of `1isize`\n-    //~| NOTE first use of `1isize`\n-    //~| NOTE first use of `1isize`\n+    //~^ NOTE first use of `1`\n+    //~| NOTE first use of `1`\n+    //~| NOTE first use of `1`\n     B = 1,\n-    //~^ ERROR discriminant value `1isize` already exists\n-    //~| NOTE enum already has `1isize`\n+    //~^ ERROR discriminant value `1` already exists\n+    //~| NOTE enum already has `1`\n     C = 0,\n     D,\n-    //~^ ERROR discriminant value `1isize` already exists\n-    //~| NOTE enum already has `1isize`\n+    //~^ ERROR discriminant value `1` already exists\n+    //~| NOTE enum already has `1`\n \n     E = N,\n-    //~^ ERROR discriminant value `1isize` already exists\n-    //~| NOTE enum already has `1isize`\n+    //~^ ERROR discriminant value `1` already exists\n+    //~| NOTE enum already has `1`\n \n }\n "}, {"sha": "0e8971269b0075eda875512642821c54b2fa3b36", "filename": "src/test/mir-opt/simplify_if.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/05a7f25cc42d08aa541f50876915489bdc0eb4bb/src%2Ftest%2Fmir-opt%2Fsimplify_if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05a7f25cc42d08aa541f50876915489bdc0eb4bb/src%2Ftest%2Fmir-opt%2Fsimplify_if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fsimplify_if.rs?ref=05a7f25cc42d08aa541f50876915489bdc0eb4bb", "patch": "@@ -17,7 +17,7 @@ fn main() {\n // END RUST SOURCE\n // START rustc.node4.SimplifyBranches.initial-before.mir\n // bb0: {\n-//     if(const false) -> [true: bb1, false: bb2];\n+//     switchInt(const false) -> [0: bb2, otherwise: bb1];\n // }\n // END rustc.node4.SimplifyBranches.initial-before.mir\n // START rustc.node4.SimplifyBranches.initial-after.mir"}, {"sha": "2231c3c242285e68c30ca4b59521ffbdd99f437e", "filename": "src/test/ui/custom-derive/issue-36935.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/05a7f25cc42d08aa541f50876915489bdc0eb4bb/src%2Ftest%2Fui%2Fcustom-derive%2Fissue-36935.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05a7f25cc42d08aa541f50876915489bdc0eb4bb/src%2Ftest%2Fui%2Fcustom-derive%2Fissue-36935.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcustom-derive%2Fissue-36935.rs?ref=05a7f25cc42d08aa541f50876915489bdc0eb4bb", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n // aux-build:plugin.rs\n+// ignore-stage1\n \n #![feature(proc_macro)]\n "}, {"sha": "46cc7a42b04299a1ffca2ba1a10c2e37d0e4dac1", "filename": "src/test/ui/custom-derive/issue-36935.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/05a7f25cc42d08aa541f50876915489bdc0eb4bb/src%2Ftest%2Fui%2Fcustom-derive%2Fissue-36935.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/05a7f25cc42d08aa541f50876915489bdc0eb4bb/src%2Ftest%2Fui%2Fcustom-derive%2Fissue-36935.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcustom-derive%2Fissue-36935.stderr?ref=05a7f25cc42d08aa541f50876915489bdc0eb4bb", "patch": "@@ -1,7 +1,7 @@\n error: proc-macro derive panicked\n-  --> $DIR/issue-36935.rs:17:15\n+  --> $DIR/issue-36935.rs:18:15\n    |\n-17 | #[derive(Foo, Bar)]\n+18 | #[derive(Foo, Bar)]\n    |               ^^^\n    |\n    = help: message: lolnope"}]}