{"sha": "e7e8e790206a94ae96f7c6af944f789b77c7b93d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU3ZThlNzkwMjA2YTk0YWU5NmY3YzZhZjk0NGY3ODliNzdjN2I5M2Q=", "commit": {"author": {"name": "Andre Bogus", "email": "bogusandre@gmail.com", "date": "2017-09-10T17:32:24Z"}, "committer": {"name": "Andre Bogus", "email": "bogusandre@gmail.com", "date": "2017-09-10T17:32:24Z"}, "message": "suggestion for ptr_arg", "tree": {"sha": "9ada51df28dfab001b9e1a48acd8c5a793227c0f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9ada51df28dfab001b9e1a48acd8c5a793227c0f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e7e8e790206a94ae96f7c6af944f789b77c7b93d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e7e8e790206a94ae96f7c6af944f789b77c7b93d", "html_url": "https://github.com/rust-lang/rust/commit/e7e8e790206a94ae96f7c6af944f789b77c7b93d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e7e8e790206a94ae96f7c6af944f789b77c7b93d/comments", "author": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "committer": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b0b60558c5d3018c73f1069a55e5fa768d6f8705", "url": "https://api.github.com/repos/rust-lang/rust/commits/b0b60558c5d3018c73f1069a55e5fa768d6f8705", "html_url": "https://github.com/rust-lang/rust/commit/b0b60558c5d3018c73f1069a55e5fa768d6f8705"}], "stats": {"total": 51, "additions": 39, "deletions": 12}, "files": [{"sha": "4d119c3a42d5b315f0f94b0326c7336aba26a195", "filename": "clippy_lints/src/ptr.rs", "status": "modified", "additions": 24, "deletions": 6, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/e7e8e790206a94ae96f7c6af944f789b77c7b93d/clippy_lints%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7e8e790206a94ae96f7c6af944f789b77c7b93d/clippy_lints%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fptr.rs?ref=e7e8e790206a94ae96f7c6af944f789b77c7b93d", "patch": "@@ -7,7 +7,8 @@ use rustc::ty;\n use syntax::ast::NodeId;\n use syntax::codemap::Span;\n use syntax_pos::MultiSpan;\n-use utils::{match_qpath, match_type, paths, span_lint, span_lint_and_then};\n+use utils::{match_qpath, match_type, paths, snippet_opt, span_lint, span_lint_and_then,\n+            span_lint_and_sugg, walk_ptrs_hir_ty};\n \n /// **What it does:** This lint checks for function arguments of type `&String`\n /// or `&Vec` unless\n@@ -137,20 +138,37 @@ fn check_fn(cx: &LateContext, decl: &FnDecl, fn_id: NodeId) {\n         ) = ty.sty\n         {\n             if match_type(cx, ty, &paths::VEC) {\n-                span_lint(\n+                let mut ty_snippet = None;\n+                if_let_chain!([\n+                    let TyPath(QPath::Resolved(_, ref path)) = walk_ptrs_hir_ty(arg).node,\n+                    let Some(&PathSegment{ref parameters, ..}) = path.segments.last(),\n+                    parameters.types.len() == 1,\n+                ], {\n+                    ty_snippet = snippet_opt(cx, parameters.types[0].span);\n+                });\n+                //TODO: Suggestion\n+                span_lint_and_then(\n                     cx,\n                     PTR_ARG,\n                     arg.span,\n                     \"writing `&Vec<_>` instead of `&[_]` involves one more reference and cannot be used \\\n-                     with non-Vec-based slices. Consider changing the type to `&[...]`\",\n+                     with non-Vec-based slices.\",\n+                    |db| {\n+                        if let Some(ref snippet) = ty_snippet {\n+                            db.span_suggestion(arg.span,\n+                                               \"change this to\",\n+                                               format!(\"&[{}]\", snippet));\n+                        }\n+                    }\n                 );\n             } else if match_type(cx, ty, &paths::STRING) {\n-                span_lint(\n+                span_lint_and_sugg(\n                     cx,\n                     PTR_ARG,\n                     arg.span,\n-                    \"writing `&String` instead of `&str` involves a new object where a slice will do. \\\n-                     Consider changing the type to `&str`\",\n+                    \"writing `&String` instead of `&str` involves a new object where a slice will do.\",\n+                    \"change this to\",\n+                    \"&str\".to_string()\n                 );\n             }\n         }"}, {"sha": "8e816ffbfa4c6bc7955205739e09f0527c189e72", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e7e8e790206a94ae96f7c6af944f789b77c7b93d/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7e8e790206a94ae96f7c6af944f789b77c7b93d/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=e7e8e790206a94ae96f7c6af944f789b77c7b93d", "patch": "@@ -645,6 +645,15 @@ pub fn multispan_sugg(db: &mut DiagnosticBuilder, help_msg: String, sugg: Vec<(S\n     db.suggestions.push(sugg);\n }\n \n+/// Return the base type for HIR references and pointers.\n+pub fn walk_ptrs_hir_ty(ty: &hir::Ty) -> &hir::Ty {\n+    match ty.node {\n+        TyPtr(ref mut_ty) |\n+        TyRptr(_, ref mut_ty) => walk_ptrs_hir_ty(&mut_ty.ty),\n+        _ => ty\n+    }\n+}\n+\n /// Return the base type for references and raw pointers.\n pub fn walk_ptrs_ty(ty: Ty) -> Ty {\n     match ty.sty {"}, {"sha": "4eafc237a823e33d7b671cfafa18730db8963c22", "filename": "tests/ui/ptr_arg.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e7e8e790206a94ae96f7c6af944f789b77c7b93d/tests%2Fui%2Fptr_arg.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7e8e790206a94ae96f7c6af944f789b77c7b93d/tests%2Fui%2Fptr_arg.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fptr_arg.stderr?ref=e7e8e790206a94ae96f7c6af944f789b77c7b93d", "patch": "@@ -1,22 +1,22 @@\n-error: writing `&Vec<_>` instead of `&[_]` involves one more reference and cannot be used with non-Vec-based slices. Consider changing the type to `&[...]`\n+error: writing `&Vec<_>` instead of `&[_]` involves one more reference and cannot be used with non-Vec-based slices.\n  --> $DIR/ptr_arg.rs:6:14\n   |\n 6 | fn do_vec(x: &Vec<i64>) {\n-  |              ^^^^^^^^^\n+  |              ^^^^^^^^^ help: change this to: `&[i64]`\n   |\n   = note: `-D ptr-arg` implied by `-D warnings`\n \n-error: writing `&String` instead of `&str` involves a new object where a slice will do. Consider changing the type to `&str`\n+error: writing `&String` instead of `&str` involves a new object where a slice will do.\n   --> $DIR/ptr_arg.rs:14:14\n    |\n 14 | fn do_str(x: &String) {\n-   |              ^^^^^^^\n+   |              ^^^^^^^ help: change this to: `&str`\n \n-error: writing `&Vec<_>` instead of `&[_]` involves one more reference and cannot be used with non-Vec-based slices. Consider changing the type to `&[...]`\n+error: writing `&Vec<_>` instead of `&[_]` involves one more reference and cannot be used with non-Vec-based slices.\n   --> $DIR/ptr_arg.rs:27:18\n    |\n 27 |     fn do_vec(x: &Vec<i64>);\n-   |                  ^^^^^^^^^\n+   |                  ^^^^^^^^^ help: change this to: `&[i64]`\n \n error: aborting due to 3 previous errors\n "}]}