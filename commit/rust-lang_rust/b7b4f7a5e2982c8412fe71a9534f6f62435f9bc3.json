{"sha": "b7b4f7a5e2982c8412fe71a9534f6f62435f9bc3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI3YjRmN2E1ZTI5ODJjODQxMmZlNzFhOTUzNGY2ZjYyNDM1ZjliYzM=", "commit": {"author": {"name": "Florian Hahn", "email": "flo@fhahn.com", "date": "2013-10-01T21:53:56Z"}, "committer": {"name": "Florian Hahn", "email": "flo@fhahn.com", "date": "2013-10-05T10:09:30Z"}, "message": "Add code for older crate map versions, bumped crate map version number", "tree": {"sha": "c02274d0eda2a0010a816762da896fba51d33fc8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c02274d0eda2a0010a816762da896fba51d33fc8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b7b4f7a5e2982c8412fe71a9534f6f62435f9bc3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b7b4f7a5e2982c8412fe71a9534f6f62435f9bc3", "html_url": "https://github.com/rust-lang/rust/commit/b7b4f7a5e2982c8412fe71a9534f6f62435f9bc3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b7b4f7a5e2982c8412fe71a9534f6f62435f9bc3/comments", "author": {"login": "fhahn", "id": 450489, "node_id": "MDQ6VXNlcjQ1MDQ4OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/450489?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fhahn", "html_url": "https://github.com/fhahn", "followers_url": "https://api.github.com/users/fhahn/followers", "following_url": "https://api.github.com/users/fhahn/following{/other_user}", "gists_url": "https://api.github.com/users/fhahn/gists{/gist_id}", "starred_url": "https://api.github.com/users/fhahn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fhahn/subscriptions", "organizations_url": "https://api.github.com/users/fhahn/orgs", "repos_url": "https://api.github.com/users/fhahn/repos", "events_url": "https://api.github.com/users/fhahn/events{/privacy}", "received_events_url": "https://api.github.com/users/fhahn/received_events", "type": "User", "site_admin": false}, "committer": {"login": "fhahn", "id": 450489, "node_id": "MDQ6VXNlcjQ1MDQ4OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/450489?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fhahn", "html_url": "https://github.com/fhahn", "followers_url": "https://api.github.com/users/fhahn/followers", "following_url": "https://api.github.com/users/fhahn/following{/other_user}", "gists_url": "https://api.github.com/users/fhahn/gists{/gist_id}", "starred_url": "https://api.github.com/users/fhahn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fhahn/subscriptions", "organizations_url": "https://api.github.com/users/fhahn/orgs", "repos_url": "https://api.github.com/users/fhahn/repos", "events_url": "https://api.github.com/users/fhahn/events{/privacy}", "received_events_url": "https://api.github.com/users/fhahn/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5dd1145c9b5e4ee12d6ef6d5d87bcbe0941b174b", "url": "https://api.github.com/repos/rust-lang/rust/commits/5dd1145c9b5e4ee12d6ef6d5d87bcbe0941b174b", "html_url": "https://github.com/rust-lang/rust/commit/5dd1145c9b5e4ee12d6ef6d5d87bcbe0941b174b"}], "stats": {"total": 211, "additions": 172, "deletions": 39}, "files": [{"sha": "16ac802ee157121419f2a7417b5bda6fd6f96d64", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7b4f7a5e2982c8412fe71a9534f6f62435f9bc3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7b4f7a5e2982c8412fe71a9534f6f62435f9bc3/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=b7b4f7a5e2982c8412fe71a9534f6f62435f9bc3", "patch": "@@ -3008,7 +3008,7 @@ pub fn fill_crate_map(ccx: &mut CrateContext, map: ValueRef) {\n         let (mod_map, mod_count, mod_struct_size) = create_module_map(ccx);\n \n         llvm::LLVMSetInitializer(map, C_struct(\n-            [C_i32(1),\n+            [C_i32(2),\n              C_struct([\n                 p2i(ccx, mod_map),\n                 // byte size of the module map array, an entry consists of two integers"}, {"sha": "ef1bfb1e5e9dca014d9cafca64a29bb20c2c9b52", "filename": "src/libstd/rt/crate_map.rs", "status": "modified", "additions": 171, "deletions": 38, "changes": 209, "blob_url": "https://github.com/rust-lang/rust/blob/b7b4f7a5e2982c8412fe71a9534f6f62435f9bc3/src%2Flibstd%2Frt%2Fcrate_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7b4f7a5e2982c8412fe71a9534f6f62435f9bc3/src%2Flibstd%2Frt%2Fcrate_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fcrate_map.rs?ref=b7b4f7a5e2982c8412fe71a9534f6f62435f9bc3", "patch": "@@ -8,12 +8,19 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[cfg(not(stage0))] use cast::transmute;\n+//#[cfg(not(stage0))] use cast::transmute;\n use container::MutableSet;\n use hashmap::HashSet;\n use option::{Some, None};\n use vec::ImmutableVector;\n \n+/// Imports for old crate map versions\n+use cast::transmute;\n+use libc::c_char;\n+use ptr;\n+use str::raw::from_c_str;\n+use vec;\n+\n // Need to tell the linker on OS X to not barf on undefined symbols\n // and instead look them up at runtime, which we need to resolve\n // the crate_map properly.\n@@ -28,14 +35,27 @@ extern {\n     static CRATE_MAP: CrateMap<'static>;\n }\n \n-pub struct ModEntry<'self> {\n-    name: &'self str,\n+/// structs for old crate map versions\n+pub struct ModEntryV0 {\n+    name: *c_char,\n     log_level: *mut u32\n }\n+pub struct CrateMapV0 {\n+    entries: *ModEntryV0,\n+    children: [*CrateMapV0, ..1]\n+}\n \n-pub struct CrateMapV0<'self> {\n-    entries: &'self [ModEntry<'self>],\n-    children: &'self [&'self CrateMap<'self>]\n+pub struct CrateMapV1 {\n+    version: i32,\n+    entries: *ModEntryV0,\n+    /// a dynamically sized struct, where all pointers to children are listed adjacent\n+    /// to the struct, terminated with NULL\n+    children: [*CrateMapV1, ..1]\n+}\n+\n+pub struct ModEntry<'self> {\n+    name: &'self str,\n+    log_level: *mut u32\n }\n \n pub struct CrateMap<'self> {\n@@ -46,6 +66,8 @@ pub struct CrateMap<'self> {\n     children: &'self [&'self CrateMap<'self>]\n }\n \n+\n+\n #[cfg(not(windows))]\n pub fn get_crate_map() -> &'static CrateMap<'static> {\n     &'static CRATE_MAP\n@@ -71,51 +93,60 @@ pub fn get_crate_map() -> &'static CrateMap<'static> {\n \n fn version(crate_map: &CrateMap) -> i32 {\n     match crate_map.version {\n+        2 => return 2,\n         1 => return 1,\n         _ => return 0\n     }\n }\n \n-#[cfg(not(stage0))]\n-fn get_entries_and_children<'a>(crate_map: &'a CrateMap<'a>) ->\n-                    (&'a [ModEntry<'a>], &'a [&'a CrateMap<'a>]) {\n-    match version(crate_map) {\n-        0 => {\n-            unsafe {\n-                let v0: &'a CrateMapV0<'a> = transmute(crate_map);\n-                return (v0.entries, v0.children);\n-            }\n-        }\n-        1 => return (*crate_map).entries,\n-        _ => fail2!(\"Unknown crate map version!\")\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n fn iter_module_map(mod_entries: &[ModEntry], f: &fn(&ModEntry)) {\n     for entry in mod_entries.iter() {\n         f(entry);\n     }\n }\n \n-#[cfg(not(stage0))]\n+unsafe fn iter_module_map_v0(entries: *ModEntryV0, f: &fn(&ModEntry)) {\n+    let mut curr = entries; \n+    while !(*curr).name.is_null() {\n+        let mod_entry = ModEntry { name: from_c_str((*curr).name), log_level: (*curr).log_level }; \n+        f(&mod_entry);\n+        curr = curr.offset(1);\n+    }\n+}\n+\n fn do_iter_crate_map<'a>(crate_map: &'a CrateMap<'a>, f: &fn(&ModEntry),\n                             visited: &mut HashSet<*CrateMap<'a>>) {\n     if visited.insert(crate_map as *CrateMap) {\n-        let (entries, children) = get_entries_and_children(crate_map);\n-        iter_module_map(entries, |x| f(x));\n-        for child in children.iter() {\n-            do_iter_crate_map(*child, |x| f(x), visited);\n+        match version(crate_map) {\n+            2 => {\n+                let (entries, children) = (crate_map.entries, crate_map.children);\n+                iter_module_map(entries, |x| f(x));\n+                for child in children.iter() {\n+                    do_iter_crate_map(*child, |x| f(x), visited);\n+                }\n+            },\n+            /// code for old crate map versions\n+            1 => unsafe {\n+                let v1: *CrateMapV1 = transmute(crate_map);\n+                iter_module_map_v0((*v1).entries, |x| f(x));\n+                let children = vec::raw::to_ptr((*v1).children);\n+                do ptr::array_each(children) |child| {\n+                    do_iter_crate_map(transmute(child), |x| f(x), visited);\n+                }\n+            },\n+            0 => unsafe {\n+                let v0: *CrateMapV0 = transmute(crate_map);\n+                iter_module_map_v0((*v0).entries, |x| f(x));\n+                let children = vec::raw::to_ptr((*v0).children);\n+                do ptr::array_each(children) |child| {\n+                    do_iter_crate_map(transmute(child), |x| f(x), visited);\n+                }\n+            },\n+            _ => fail2!(\"invalid crate map version\")  \n         }\n     }\n }\n \n-#[cfg(stage0)]\n-/// Iterates recursively over `crate_map` and all child crate maps\n-pub fn iter_crate_map<'a>(crate_map: &'a CrateMap<'a>, f: &fn(&ModEntry)) {\n-}\n-\n-#[cfg(not(stage0))]\n /// Iterates recursively over `crate_map` and all child crate maps\n pub fn iter_crate_map<'a>(crate_map: &'a CrateMap<'a>, f: &fn(&ModEntry)) {\n     // XXX: use random numbers as keys from the OS-level RNG when there is a nice\n@@ -137,13 +168,13 @@ mod tests {\n         ];\n \n         let child_crate = CrateMap {\n-            version: 1,\n+            version: 2,\n             entries: entries,\n             children: []\n         };\n \n         let root_crate = CrateMap {\n-            version: 1,\n+            version: 2,\n             entries: [],\n             children: [&child_crate, &child_crate]\n         };\n@@ -163,7 +194,7 @@ mod tests {\n         let mut level2: u32 = 2;\n         let mut level3: u32 = 3;\n         let child_crate2 = CrateMap {\n-            version: 1,\n+            version: 2,\n             entries: [\n                 ModEntry { name: \"c::m1\", log_level: &mut level2},\n                 ModEntry { name: \"c::m2\", log_level: &mut level3},\n@@ -172,15 +203,15 @@ mod tests {\n         };\n \n         let child_crate1 = CrateMap {\n-            version: 1,\n+            version: 2,\n             entries: [\n                 ModEntry { name: \"t::f1\", log_level: &mut 1},\n             ],\n             children: [&child_crate2]\n         };\n \n         let root_crate = CrateMap {\n-            version: 1,\n+            version: 2,\n             entries: [\n                 ModEntry { name: \"t::f2\", log_level: &mut 0},\n             ],\n@@ -196,4 +227,106 @@ mod tests {\n             assert!(cnt == 4);\n         }\n     }\n+\n+\n+    /// Tests for old crate map versions\n+    #[test]\n+    fn iter_crate_map_duplicates_v1() {\n+        use c_str::ToCStr;\n+        use cast::transmute;\n+        use ptr;\n+        use rt::crate_map::{CrateMapV1, ModEntryV0, iter_crate_map};\n+        use vec;\n+\n+        struct CrateMapT3 {\n+            version: i32,\n+            entries: *ModEntryV0,\n+            children: [*CrateMapV1, ..3]\n+        }\n+\n+        unsafe {\n+            let mod_name1 = \"c::m1\".to_c_str();\n+            let mut level3: u32 = 3;\n+\n+            let entries: ~[ModEntryV0] = ~[\n+                ModEntryV0 { name: mod_name1.with_ref(|buf| buf), log_level: &mut level3},\n+                ModEntryV0 { name: ptr::null(), log_level: ptr::mut_null()}\n+            ];\n+            let child_crate = CrateMapV1 {\n+                version: 1,\n+                entries: vec::raw::to_ptr(entries),\n+                children: [ptr::null()]\n+            };\n+\n+            let root_crate = CrateMapT3 {\n+                version: 1,\n+                entries: vec::raw::to_ptr([ModEntryV0 { name: ptr::null(), log_level: ptr::mut_null()}]),\n+                children: [&child_crate as *CrateMapV1, &child_crate as *CrateMapV1, ptr::null()]\n+            };\n+\n+            let mut cnt = 0;\n+            do iter_crate_map(transmute(&root_crate)) |entry| {\n+                assert!(*(*entry).log_level == 3);\n+                cnt += 1;\n+            }\n+            assert!(cnt == 1);\n+        }\n+    }\n+\n+    #[test]\n+    fn iter_crate_map_follow_children_v1() {\n+        use c_str::ToCStr;\n+        use cast::transmute;\n+        use ptr;\n+        use rt::crate_map::{CrateMapV1, ModEntryV0, iter_crate_map};\n+        use vec;\n+\n+        struct CrateMapT2 {\n+            version: i32,\n+            entries: *ModEntryV0,\n+            children: [*CrateMapV1, ..2]\n+        }\n+\n+        unsafe {\n+            let mod_name1 = \"c::m1\".to_c_str();\n+            let mod_name2 = \"c::m2\".to_c_str();\n+            let mut level2: u32 = 2;\n+            let mut level3: u32 = 3;\n+            let child_crate2 = CrateMapV1 {\n+                version: 1,\n+                entries: vec::raw::to_ptr([\n+                    ModEntryV0 { name: mod_name1.with_ref(|buf| buf), log_level: &mut level2},\n+                    ModEntryV0 { name: mod_name2.with_ref(|buf| buf), log_level: &mut level3},\n+                    ModEntryV0 { name: ptr::null(), log_level: ptr::mut_null()}\n+                ]),\n+                children: [ptr::null()]\n+            };\n+\n+            let child_crate1 = CrateMapT2 {\n+                version: 1,\n+                entries: vec::raw::to_ptr([\n+                    ModEntryV0 { name: \"t::f1\".with_c_str(|buf| buf), log_level: &mut 1},\n+                    ModEntryV0 { name: ptr::null(), log_level: ptr::mut_null()}\n+                ]),\n+                children: [&child_crate2 as *CrateMapV1, ptr::null()]\n+            };\n+\n+            let child_crate1_ptr: *CrateMapV1 = transmute(&child_crate1);\n+            let root_crate = CrateMapT2 {\n+                version: 1,\n+                entries: vec::raw::to_ptr([\n+                    ModEntryV0 { name: \"t::f1\".with_c_str(|buf| buf), log_level: &mut 0},\n+                    ModEntryV0 { name: ptr::null(), log_level: ptr::mut_null()}\n+                ]),\n+                children: [child_crate1_ptr, ptr::null()]\n+            };\n+\n+            let mut cnt = 0;\n+            do iter_crate_map(transmute(&root_crate)) |entry| {\n+                assert!(*(*entry).log_level == cnt);\n+                cnt += 1;\n+            }\n+            assert!(cnt == 4);\n+        }\n+    }\n }"}]}