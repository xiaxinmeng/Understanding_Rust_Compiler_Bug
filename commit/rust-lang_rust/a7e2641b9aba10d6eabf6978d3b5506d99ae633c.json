{"sha": "a7e2641b9aba10d6eabf6978d3b5506d99ae633c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE3ZTI2NDFiOWFiYTEwZDZlYWJmNjk3OGQzYjU1MDZkOTlhZTYzM2M=", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2019-12-31T09:51:58Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2020-03-23T22:07:19Z"}, "message": "Move dep_graph to new crate librustc_query_system.", "tree": {"sha": "afd0f9b19c7798935bbc4474b97b2fd62e760cf5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/afd0f9b19c7798935bbc4474b97b2fd62e760cf5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a7e2641b9aba10d6eabf6978d3b5506d99ae633c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a7e2641b9aba10d6eabf6978d3b5506d99ae633c", "html_url": "https://github.com/rust-lang/rust/commit/a7e2641b9aba10d6eabf6978d3b5506d99ae633c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a7e2641b9aba10d6eabf6978d3b5506d99ae633c/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1edd389cc4c7b5be7a3dd4fe4b986f6017018e54", "url": "https://api.github.com/repos/rust-lang/rust/commits/1edd389cc4c7b5be7a3dd4fe4b986f6017018e54", "html_url": "https://github.com/rust-lang/rust/commit/1edd389cc4c7b5be7a3dd4fe4b986f6017018e54"}], "stats": {"total": 520, "additions": 520, "deletions": 0}, "files": [{"sha": "b9d91cd35a8ddf6ce799b94d488bffc955b2efde", "filename": "src/librustc_query_system/dep_graph/README.md", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a7e2641b9aba10d6eabf6978d3b5506d99ae633c/src%2Flibrustc_query_system%2Fdep_graph%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/a7e2641b9aba10d6eabf6978d3b5506d99ae633c/src%2Flibrustc_query_system%2Fdep_graph%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_query_system%2Fdep_graph%2FREADME.md?ref=a7e2641b9aba10d6eabf6978d3b5506d99ae633c", "previous_filename": "src/librustc/dep_graph/README.md"}, {"sha": "d44c54593a6276319794e872fee07419f1e8cafd", "filename": "src/librustc_query_system/dep_graph/debug.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a7e2641b9aba10d6eabf6978d3b5506d99ae633c/src%2Flibrustc_query_system%2Fdep_graph%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7e2641b9aba10d6eabf6978d3b5506d99ae633c/src%2Flibrustc_query_system%2Fdep_graph%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_query_system%2Fdep_graph%2Fdebug.rs?ref=a7e2641b9aba10d6eabf6978d3b5506d99ae633c", "previous_filename": "src/librustc/dep_graph/debug.rs"}, {"sha": "e3df9d5d04be106727dd783d97e5a3103931a1aa", "filename": "src/librustc_query_system/dep_graph/dep_node.rs", "status": "added", "additions": 520, "deletions": 0, "changes": 520, "blob_url": "https://github.com/rust-lang/rust/blob/a7e2641b9aba10d6eabf6978d3b5506d99ae633c/src%2Flibrustc_query_system%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7e2641b9aba10d6eabf6978d3b5506d99ae633c/src%2Flibrustc_query_system%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_query_system%2Fdep_graph%2Fdep_node.rs?ref=a7e2641b9aba10d6eabf6978d3b5506d99ae633c", "patch": "@@ -0,0 +1,520 @@\n+//! This module defines the `DepNode` type which the compiler uses to represent\n+//! nodes in the dependency graph. A `DepNode` consists of a `DepKind` (which\n+//! specifies the kind of thing it represents, like a piece of HIR, MIR, etc)\n+//! and a `Fingerprint`, a 128 bit hash value the exact meaning of which\n+//! depends on the node's `DepKind`. Together, the kind and the fingerprint\n+//! fully identify a dependency node, even across multiple compilation sessions.\n+//! In other words, the value of the fingerprint does not depend on anything\n+//! that is specific to a given compilation session, like an unpredictable\n+//! interning key (e.g., NodeId, DefId, Symbol) or the numeric value of a\n+//! pointer. The concept behind this could be compared to how git commit hashes\n+//! uniquely identify a given commit and has a few advantages:\n+//!\n+//! * A `DepNode` can simply be serialized to disk and loaded in another session\n+//!   without the need to do any \"rebasing (like we have to do for Spans and\n+//!   NodeIds) or \"retracing\" like we had to do for `DefId` in earlier\n+//!   implementations of the dependency graph.\n+//! * A `Fingerprint` is just a bunch of bits, which allows `DepNode` to\n+//!   implement `Copy`, `Sync`, `Send`, `Freeze`, etc.\n+//! * Since we just have a bit pattern, `DepNode` can be mapped from disk into\n+//!   memory without any post-processing (e.g., \"abomination-style\" pointer\n+//!   reconstruction).\n+//! * Because a `DepNode` is self-contained, we can instantiate `DepNodes` that\n+//!   refer to things that do not exist anymore. In previous implementations\n+//!   `DepNode` contained a `DefId`. A `DepNode` referring to something that\n+//!   had been removed between the previous and the current compilation session\n+//!   could not be instantiated because the current compilation session\n+//!   contained no `DefId` for thing that had been removed.\n+//!\n+//! `DepNode` definition happens in the `define_dep_nodes!()` macro. This macro\n+//! defines the `DepKind` enum and a corresponding `DepConstructor` enum. The\n+//! `DepConstructor` enum links a `DepKind` to the parameters that are needed at\n+//! runtime in order to construct a valid `DepNode` fingerprint.\n+//!\n+//! Because the macro sees what parameters a given `DepKind` requires, it can\n+//! \"infer\" some properties for each kind of `DepNode`:\n+//!\n+//! * Whether a `DepNode` of a given kind has any parameters at all. Some\n+//!   `DepNode`s could represent global concepts with only one value.\n+//! * Whether it is possible, in principle, to reconstruct a query key from a\n+//!   given `DepNode`. Many `DepKind`s only require a single `DefId` parameter,\n+//!   in which case it is possible to map the node's fingerprint back to the\n+//!   `DefId` it was computed from. In other cases, too much information gets\n+//!   lost during fingerprint computation.\n+//!\n+//! The `DepConstructor` enum, together with `DepNode::new()` ensures that only\n+//! valid `DepNode` instances can be constructed. For example, the API does not\n+//! allow for constructing parameterless `DepNode`s with anything other\n+//! than a zeroed out fingerprint. More generally speaking, it relieves the\n+//! user of the `DepNode` API of having to know how to compute the expected\n+//! fingerprint for a given set of node parameters.\n+\n+use crate::hir::map::DefPathHash;\n+use crate::ich::{Fingerprint, StableHashingContext};\n+use crate::mir;\n+use crate::mir::interpret::{GlobalId, LitToConstInput};\n+use crate::traits;\n+use crate::traits::query::{\n+    CanonicalPredicateGoal, CanonicalProjectionGoal, CanonicalTyGoal,\n+    CanonicalTypeOpAscribeUserTypeGoal, CanonicalTypeOpEqGoal, CanonicalTypeOpNormalizeGoal,\n+    CanonicalTypeOpProvePredicateGoal, CanonicalTypeOpSubtypeGoal,\n+};\n+use crate::ty::subst::SubstsRef;\n+use crate::ty::{self, ParamEnvAnd, Ty, TyCtxt};\n+\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n+use rustc_hir::def_id::{CrateNum, DefId, DefIndex, CRATE_DEF_INDEX};\n+use rustc_hir::HirId;\n+use rustc_span::symbol::Symbol;\n+use std::fmt;\n+use std::hash::Hash;\n+\n+// erase!() just makes tokens go away. It's used to specify which macro argument\n+// is repeated (i.e., which sub-expression of the macro we are in) but don't need\n+// to actually use any of the arguments.\n+macro_rules! erase {\n+    ($x:tt) => {{}};\n+}\n+\n+macro_rules! is_anon_attr {\n+    (anon) => {\n+        true\n+    };\n+    ($attr:ident) => {\n+        false\n+    };\n+}\n+\n+macro_rules! is_eval_always_attr {\n+    (eval_always) => {\n+        true\n+    };\n+    ($attr:ident) => {\n+        false\n+    };\n+}\n+\n+macro_rules! contains_anon_attr {\n+    ($($attr:ident $(($($attr_args:tt)*))* ),*) => ({$(is_anon_attr!($attr) | )* false});\n+}\n+\n+macro_rules! contains_eval_always_attr {\n+    ($($attr:ident $(($($attr_args:tt)*))* ),*) => ({$(is_eval_always_attr!($attr) | )* false});\n+}\n+\n+macro_rules! define_dep_nodes {\n+    (<$tcx:tt>\n+    $(\n+        [$($attrs:tt)*]\n+        $variant:ident $(( $tuple_arg_ty:ty $(,)? ))*\n+      ,)*\n+    ) => (\n+        #[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord, Hash,\n+                 RustcEncodable, RustcDecodable)]\n+        #[allow(non_camel_case_types)]\n+        pub enum DepKind {\n+            $($variant),*\n+        }\n+\n+        impl DepKind {\n+            #[allow(unreachable_code)]\n+            pub fn can_reconstruct_query_key<$tcx>(&self) -> bool {\n+                match *self {\n+                    $(\n+                        DepKind :: $variant => {\n+                            if contains_anon_attr!($($attrs)*) {\n+                                return false;\n+                            }\n+\n+                            // tuple args\n+                            $({\n+                                return <$tuple_arg_ty as DepNodeParams>\n+                                    ::CAN_RECONSTRUCT_QUERY_KEY;\n+                            })*\n+\n+                            true\n+                        }\n+                    )*\n+                }\n+            }\n+\n+            pub fn is_anon(&self) -> bool {\n+                match *self {\n+                    $(\n+                        DepKind :: $variant => { contains_anon_attr!($($attrs)*) }\n+                    )*\n+                }\n+            }\n+\n+            pub fn is_eval_always(&self) -> bool {\n+                match *self {\n+                    $(\n+                        DepKind :: $variant => { contains_eval_always_attr!($($attrs)*) }\n+                    )*\n+                }\n+            }\n+\n+            #[allow(unreachable_code)]\n+            pub fn has_params(&self) -> bool {\n+                match *self {\n+                    $(\n+                        DepKind :: $variant => {\n+                            // tuple args\n+                            $({\n+                                erase!($tuple_arg_ty);\n+                                return true;\n+                            })*\n+\n+                            false\n+                        }\n+                    )*\n+                }\n+            }\n+        }\n+\n+        pub struct DepConstructor;\n+\n+        #[allow(non_camel_case_types)]\n+        impl DepConstructor {\n+            $(\n+                #[inline(always)]\n+                #[allow(unreachable_code, non_snake_case)]\n+                pub fn $variant(_tcx: TyCtxt<'_>, $(arg: $tuple_arg_ty)*) -> DepNode {\n+                    // tuple args\n+                    $({\n+                        erase!($tuple_arg_ty);\n+                        let hash = DepNodeParams::to_fingerprint(&arg, _tcx);\n+                        let dep_node = DepNode {\n+                            kind: DepKind::$variant,\n+                            hash\n+                        };\n+\n+                        #[cfg(debug_assertions)]\n+                        {\n+                            if !dep_node.kind.can_reconstruct_query_key() &&\n+                            (_tcx.sess.opts.debugging_opts.incremental_info ||\n+                                _tcx.sess.opts.debugging_opts.query_dep_graph)\n+                            {\n+                                _tcx.dep_graph.register_dep_node_debug_str(dep_node, || {\n+                                    arg.to_debug_str(_tcx)\n+                                });\n+                            }\n+                        }\n+\n+                        return dep_node;\n+                    })*\n+\n+                    DepNode {\n+                        kind: DepKind::$variant,\n+                        hash: Fingerprint::ZERO,\n+                    }\n+                }\n+            )*\n+        }\n+\n+        #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash,\n+                 RustcEncodable, RustcDecodable)]\n+        pub struct DepNode {\n+            pub kind: DepKind,\n+            pub hash: Fingerprint,\n+        }\n+\n+        impl DepNode {\n+            /// Construct a DepNode from the given DepKind and DefPathHash. This\n+            /// method will assert that the given DepKind actually requires a\n+            /// single DefId/DefPathHash parameter.\n+            pub fn from_def_path_hash(def_path_hash: DefPathHash,\n+                                      kind: DepKind)\n+                                      -> DepNode {\n+                debug_assert!(kind.can_reconstruct_query_key() && kind.has_params());\n+                DepNode {\n+                    kind,\n+                    hash: def_path_hash.0,\n+                }\n+            }\n+\n+            /// Creates a new, parameterless DepNode. This method will assert\n+            /// that the DepNode corresponding to the given DepKind actually\n+            /// does not require any parameters.\n+            pub fn new_no_params(kind: DepKind) -> DepNode {\n+                debug_assert!(!kind.has_params());\n+                DepNode {\n+                    kind,\n+                    hash: Fingerprint::ZERO,\n+                }\n+            }\n+\n+            /// Extracts the DefId corresponding to this DepNode. This will work\n+            /// if two conditions are met:\n+            ///\n+            /// 1. The Fingerprint of the DepNode actually is a DefPathHash, and\n+            /// 2. the item that the DefPath refers to exists in the current tcx.\n+            ///\n+            /// Condition (1) is determined by the DepKind variant of the\n+            /// DepNode. Condition (2) might not be fulfilled if a DepNode\n+            /// refers to something from the previous compilation session that\n+            /// has been removed.\n+            pub fn extract_def_id(&self, tcx: TyCtxt<'_>) -> Option<DefId> {\n+                if self.kind.can_reconstruct_query_key() {\n+                    let def_path_hash = DefPathHash(self.hash);\n+                    tcx.def_path_hash_to_def_id.as_ref()?\n+                        .get(&def_path_hash).cloned()\n+                } else {\n+                    None\n+                }\n+            }\n+\n+            /// Used in testing\n+            pub fn from_label_string(label: &str,\n+                                     def_path_hash: DefPathHash)\n+                                     -> Result<DepNode, ()> {\n+                let kind = match label {\n+                    $(\n+                        stringify!($variant) => DepKind::$variant,\n+                    )*\n+                    _ => return Err(()),\n+                };\n+\n+                if !kind.can_reconstruct_query_key() {\n+                    return Err(());\n+                }\n+\n+                if kind.has_params() {\n+                    Ok(DepNode::from_def_path_hash(def_path_hash, kind))\n+                } else {\n+                    Ok(DepNode::new_no_params(kind))\n+                }\n+            }\n+\n+            /// Used in testing\n+            pub fn has_label_string(label: &str) -> bool {\n+                match label {\n+                    $(\n+                        stringify!($variant) => true,\n+                    )*\n+                    _ => false,\n+                }\n+            }\n+        }\n+\n+        /// Contains variant => str representations for constructing\n+        /// DepNode groups for tests.\n+        #[allow(dead_code, non_upper_case_globals)]\n+        pub mod label_strs {\n+           $(\n+                pub const $variant: &str = stringify!($variant);\n+            )*\n+        }\n+    );\n+}\n+\n+impl fmt::Debug for DepNode {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"{:?}\", self.kind)?;\n+\n+        if !self.kind.has_params() && !self.kind.is_anon() {\n+            return Ok(());\n+        }\n+\n+        write!(f, \"(\")?;\n+\n+        crate::ty::tls::with_opt(|opt_tcx| {\n+            if let Some(tcx) = opt_tcx {\n+                if let Some(def_id) = self.extract_def_id(tcx) {\n+                    write!(f, \"{}\", tcx.def_path_debug_str(def_id))?;\n+                } else if let Some(ref s) = tcx.dep_graph.dep_node_debug_str(*self) {\n+                    write!(f, \"{}\", s)?;\n+                } else {\n+                    write!(f, \"{}\", self.hash)?;\n+                }\n+            } else {\n+                write!(f, \"{}\", self.hash)?;\n+            }\n+            Ok(())\n+        })?;\n+\n+        write!(f, \")\")\n+    }\n+}\n+\n+rustc_dep_node_append!([define_dep_nodes!][ <'tcx>\n+    // We use this for most things when incr. comp. is turned off.\n+    [] Null,\n+\n+    // Represents metadata from an extern crate.\n+    [eval_always] CrateMetadata(CrateNum),\n+\n+    [anon] TraitSelect,\n+\n+    [] CompileCodegenUnit(Symbol),\n+]);\n+\n+pub(crate) trait DepNodeParams<'tcx>: fmt::Debug + Sized {\n+    const CAN_RECONSTRUCT_QUERY_KEY: bool;\n+\n+    /// This method turns the parameters of a DepNodeConstructor into an opaque\n+    /// Fingerprint to be used in DepNode.\n+    /// Not all DepNodeParams support being turned into a Fingerprint (they\n+    /// don't need to if the corresponding DepNode is anonymous).\n+    fn to_fingerprint(&self, _: TyCtxt<'tcx>) -> Fingerprint {\n+        panic!(\"Not implemented. Accidentally called on anonymous node?\")\n+    }\n+\n+    fn to_debug_str(&self, _: TyCtxt<'tcx>) -> String {\n+        format!(\"{:?}\", self)\n+    }\n+\n+    /// This method tries to recover the query key from the given `DepNode`,\n+    /// something which is needed when forcing `DepNode`s during red-green\n+    /// evaluation. The query system will only call this method if\n+    /// `CAN_RECONSTRUCT_QUERY_KEY` is `true`.\n+    /// It is always valid to return `None` here, in which case incremental\n+    /// compilation will treat the query as having changed instead of forcing it.\n+    fn recover(tcx: TyCtxt<'tcx>, dep_node: &DepNode) -> Option<Self>;\n+}\n+\n+impl<'tcx, T> DepNodeParams<'tcx> for T\n+where\n+    T: HashStable<StableHashingContext<'tcx>> + fmt::Debug,\n+{\n+    default const CAN_RECONSTRUCT_QUERY_KEY: bool = false;\n+\n+    default fn to_fingerprint(&self, tcx: TyCtxt<'tcx>) -> Fingerprint {\n+        let mut hcx = tcx.create_stable_hashing_context();\n+        let mut hasher = StableHasher::new();\n+\n+        self.hash_stable(&mut hcx, &mut hasher);\n+\n+        hasher.finish()\n+    }\n+\n+    default fn to_debug_str(&self, _: TyCtxt<'tcx>) -> String {\n+        format!(\"{:?}\", *self)\n+    }\n+\n+    default fn recover(_: TyCtxt<'tcx>, _: &DepNode) -> Option<Self> {\n+        None\n+    }\n+}\n+\n+impl<'tcx> DepNodeParams<'tcx> for DefId {\n+    const CAN_RECONSTRUCT_QUERY_KEY: bool = true;\n+\n+    fn to_fingerprint(&self, tcx: TyCtxt<'_>) -> Fingerprint {\n+        tcx.def_path_hash(*self).0\n+    }\n+\n+    fn to_debug_str(&self, tcx: TyCtxt<'tcx>) -> String {\n+        tcx.def_path_str(*self)\n+    }\n+\n+    fn recover(tcx: TyCtxt<'tcx>, dep_node: &DepNode) -> Option<Self> {\n+        dep_node.extract_def_id(tcx)\n+    }\n+}\n+\n+impl<'tcx> DepNodeParams<'tcx> for DefIndex {\n+    const CAN_RECONSTRUCT_QUERY_KEY: bool = true;\n+\n+    fn to_fingerprint(&self, tcx: TyCtxt<'_>) -> Fingerprint {\n+        tcx.hir().definitions().def_path_hash(*self).0\n+    }\n+\n+    fn to_debug_str(&self, tcx: TyCtxt<'tcx>) -> String {\n+        tcx.def_path_str(DefId::local(*self))\n+    }\n+\n+    fn recover(tcx: TyCtxt<'tcx>, dep_node: &DepNode) -> Option<Self> {\n+        dep_node.extract_def_id(tcx).map(|id| id.index)\n+    }\n+}\n+\n+impl<'tcx> DepNodeParams<'tcx> for CrateNum {\n+    const CAN_RECONSTRUCT_QUERY_KEY: bool = true;\n+\n+    fn to_fingerprint(&self, tcx: TyCtxt<'_>) -> Fingerprint {\n+        let def_id = DefId { krate: *self, index: CRATE_DEF_INDEX };\n+        tcx.def_path_hash(def_id).0\n+    }\n+\n+    fn to_debug_str(&self, tcx: TyCtxt<'tcx>) -> String {\n+        tcx.crate_name(*self).to_string()\n+    }\n+\n+    fn recover(tcx: TyCtxt<'tcx>, dep_node: &DepNode) -> Option<Self> {\n+        dep_node.extract_def_id(tcx).map(|id| id.krate)\n+    }\n+}\n+\n+impl<'tcx> DepNodeParams<'tcx> for (DefId, DefId) {\n+    const CAN_RECONSTRUCT_QUERY_KEY: bool = false;\n+\n+    // We actually would not need to specialize the implementation of this\n+    // method but it's faster to combine the hashes than to instantiate a full\n+    // hashing context and stable-hashing state.\n+    fn to_fingerprint(&self, tcx: TyCtxt<'_>) -> Fingerprint {\n+        let (def_id_0, def_id_1) = *self;\n+\n+        let def_path_hash_0 = tcx.def_path_hash(def_id_0);\n+        let def_path_hash_1 = tcx.def_path_hash(def_id_1);\n+\n+        def_path_hash_0.0.combine(def_path_hash_1.0)\n+    }\n+\n+    fn to_debug_str(&self, tcx: TyCtxt<'tcx>) -> String {\n+        let (def_id_0, def_id_1) = *self;\n+\n+        format!(\"({}, {})\", tcx.def_path_debug_str(def_id_0), tcx.def_path_debug_str(def_id_1))\n+    }\n+}\n+\n+impl<'tcx> DepNodeParams<'tcx> for HirId {\n+    const CAN_RECONSTRUCT_QUERY_KEY: bool = false;\n+\n+    // We actually would not need to specialize the implementation of this\n+    // method but it's faster to combine the hashes than to instantiate a full\n+    // hashing context and stable-hashing state.\n+    fn to_fingerprint(&self, tcx: TyCtxt<'_>) -> Fingerprint {\n+        let HirId { owner, local_id } = *self;\n+\n+        let def_path_hash = tcx.def_path_hash(DefId::local(owner));\n+        let local_id = Fingerprint::from_smaller_hash(local_id.as_u32().into());\n+\n+        def_path_hash.0.combine(local_id)\n+    }\n+}\n+\n+/// A \"work product\" corresponds to a `.o` (or other) file that we\n+/// save in between runs. These IDs do not have a `DefId` but rather\n+/// some independent path or string that persists between runs without\n+/// the need to be mapped or unmapped. (This ensures we can serialize\n+/// them even in the absence of a tcx.)\n+#[derive(\n+    Clone,\n+    Copy,\n+    Debug,\n+    PartialEq,\n+    Eq,\n+    PartialOrd,\n+    Ord,\n+    Hash,\n+    RustcEncodable,\n+    RustcDecodable,\n+    HashStable\n+)]\n+pub struct WorkProductId {\n+    hash: Fingerprint,\n+}\n+\n+impl WorkProductId {\n+    pub fn from_cgu_name(cgu_name: &str) -> WorkProductId {\n+        let mut hasher = StableHasher::new();\n+        cgu_name.len().hash(&mut hasher);\n+        cgu_name.hash(&mut hasher);\n+        WorkProductId { hash: hasher.finish() }\n+    }\n+\n+    pub fn from_fingerprint(fingerprint: Fingerprint) -> WorkProductId {\n+        WorkProductId { hash: fingerprint }\n+    }\n+}"}, {"sha": "36edf0f0fc26ad8877453ba54d44a85f9883d7f1", "filename": "src/librustc_query_system/dep_graph/graph.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a7e2641b9aba10d6eabf6978d3b5506d99ae633c/src%2Flibrustc_query_system%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7e2641b9aba10d6eabf6978d3b5506d99ae633c/src%2Flibrustc_query_system%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_query_system%2Fdep_graph%2Fgraph.rs?ref=a7e2641b9aba10d6eabf6978d3b5506d99ae633c", "previous_filename": "src/librustc/dep_graph/graph.rs"}, {"sha": "1fbd90743f402e764212ab57b8cfdca142f4f36b", "filename": "src/librustc_query_system/dep_graph/mod.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a7e2641b9aba10d6eabf6978d3b5506d99ae633c/src%2Flibrustc_query_system%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7e2641b9aba10d6eabf6978d3b5506d99ae633c/src%2Flibrustc_query_system%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_query_system%2Fdep_graph%2Fmod.rs?ref=a7e2641b9aba10d6eabf6978d3b5506d99ae633c", "previous_filename": "src/librustc/dep_graph/mod.rs"}, {"sha": "fbc8f7bc997e095762bc513e49e7e5e5bc469f6c", "filename": "src/librustc_query_system/dep_graph/prev.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a7e2641b9aba10d6eabf6978d3b5506d99ae633c/src%2Flibrustc_query_system%2Fdep_graph%2Fprev.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7e2641b9aba10d6eabf6978d3b5506d99ae633c/src%2Flibrustc_query_system%2Fdep_graph%2Fprev.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_query_system%2Fdep_graph%2Fprev.rs?ref=a7e2641b9aba10d6eabf6978d3b5506d99ae633c", "previous_filename": "src/librustc/dep_graph/prev.rs"}, {"sha": "c71c11ed0ebdf22701758709416e58fee683dfe5", "filename": "src/librustc_query_system/dep_graph/query.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a7e2641b9aba10d6eabf6978d3b5506d99ae633c/src%2Flibrustc_query_system%2Fdep_graph%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7e2641b9aba10d6eabf6978d3b5506d99ae633c/src%2Flibrustc_query_system%2Fdep_graph%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_query_system%2Fdep_graph%2Fquery.rs?ref=a7e2641b9aba10d6eabf6978d3b5506d99ae633c", "previous_filename": "src/librustc/dep_graph/query.rs"}, {"sha": "74e32867cdec166ca93623cb9f673fa4e281a04f", "filename": "src/librustc_query_system/dep_graph/safe.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a7e2641b9aba10d6eabf6978d3b5506d99ae633c/src%2Flibrustc_query_system%2Fdep_graph%2Fsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7e2641b9aba10d6eabf6978d3b5506d99ae633c/src%2Flibrustc_query_system%2Fdep_graph%2Fsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_query_system%2Fdep_graph%2Fsafe.rs?ref=a7e2641b9aba10d6eabf6978d3b5506d99ae633c", "previous_filename": "src/librustc/dep_graph/safe.rs"}, {"sha": "45ef52dbf39c2ef33f61bbcec7b604cc9fbd9737", "filename": "src/librustc_query_system/dep_graph/serialized.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a7e2641b9aba10d6eabf6978d3b5506d99ae633c/src%2Flibrustc_query_system%2Fdep_graph%2Fserialized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7e2641b9aba10d6eabf6978d3b5506d99ae633c/src%2Flibrustc_query_system%2Fdep_graph%2Fserialized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_query_system%2Fdep_graph%2Fserialized.rs?ref=a7e2641b9aba10d6eabf6978d3b5506d99ae633c", "previous_filename": "src/librustc/dep_graph/serialized.rs"}]}