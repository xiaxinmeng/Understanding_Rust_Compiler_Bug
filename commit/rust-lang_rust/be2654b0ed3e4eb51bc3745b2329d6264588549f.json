{"sha": "be2654b0ed3e4eb51bc3745b2329d6264588549f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJlMjY1NGIwZWQzZTRlYjUxYmMzNzQ1YjIzMjlkNjI2NDU4ODU0OWY=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-04-16T20:02:10Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-04-16T20:02:10Z"}, "message": "Decouple project loading from project discovery a bit", "tree": {"sha": "6340818f6ddf3b13360f09431c6208cc98786a21", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6340818f6ddf3b13360f09431c6208cc98786a21"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/be2654b0ed3e4eb51bc3745b2329d6264588549f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/be2654b0ed3e4eb51bc3745b2329d6264588549f", "html_url": "https://github.com/rust-lang/rust/commit/be2654b0ed3e4eb51bc3745b2329d6264588549f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/be2654b0ed3e4eb51bc3745b2329d6264588549f/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cae2498513601c507bb10b15710feb800a24517f", "url": "https://api.github.com/repos/rust-lang/rust/commits/cae2498513601c507bb10b15710feb800a24517f", "html_url": "https://github.com/rust-lang/rust/commit/cae2498513601c507bb10b15710feb800a24517f"}], "stats": {"total": 291, "additions": 163, "deletions": 128}, "files": [{"sha": "df4be94dc4a4c26d5b8fc07b362b67f19bed6831", "filename": "crates/ra_project_model/src/lib.rs", "status": "modified", "additions": 121, "deletions": 100, "changes": 221, "blob_url": "https://github.com/rust-lang/rust/blob/be2654b0ed3e4eb51bc3745b2329d6264588549f/crates%2Fra_project_model%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be2654b0ed3e4eb51bc3745b2329d6264588549f/crates%2Fra_project_model%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_project_model%2Fsrc%2Flib.rs?ref=be2654b0ed3e4eb51bc3745b2329d6264588549f", "patch": "@@ -77,31 +77,131 @@ impl PackageRoot {\n     }\n }\n \n-impl ProjectWorkspace {\n-    pub fn discover(path: &Path, cargo_features: &CargoConfig) -> Result<ProjectWorkspace> {\n-        ProjectWorkspace::discover_with_sysroot(path, true, cargo_features)\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub enum ProjectRoot {\n+    ProjectJson(PathBuf),\n+    CargoToml(PathBuf),\n+}\n+\n+impl ProjectRoot {\n+    pub fn from_manifest_file(path: PathBuf) -> Result<ProjectRoot> {\n+        if path.ends_with(\"rust-project.json\") {\n+            return Ok(ProjectRoot::ProjectJson(path));\n+        }\n+        if path.ends_with(\"Cargo.toml\") {\n+            return Ok(ProjectRoot::CargoToml(path));\n+        }\n+        bail!(\"project root must point to Cargo.toml or rust-project.json: {}\", path.display())\n     }\n \n-    pub fn discover_with_sysroot(\n-        path: &Path,\n-        with_sysroot: bool,\n+    pub fn discover(path: &Path) -> Result<ProjectRoot, CargoTomlNotFoundError> {\n+        if let Some(project_json) = find_rust_project_json(path) {\n+            return Ok(ProjectRoot::ProjectJson(project_json));\n+        }\n+        return find_cargo_toml(path).map(ProjectRoot::CargoToml);\n+\n+        fn find_rust_project_json(path: &Path) -> Option<PathBuf> {\n+            if path.ends_with(\"rust-project.json\") {\n+                return Some(path.to_path_buf());\n+            }\n+\n+            let mut curr = Some(path);\n+            while let Some(path) = curr {\n+                let candidate = path.join(\"rust-project.json\");\n+                if candidate.exists() {\n+                    return Some(candidate);\n+                }\n+                curr = path.parent();\n+            }\n+\n+            None\n+        }\n+\n+        fn find_cargo_toml(path: &Path) -> Result<PathBuf, CargoTomlNotFoundError> {\n+            if path.ends_with(\"Cargo.toml\") {\n+                return Ok(path.to_path_buf());\n+            }\n+\n+            if let Some(p) = find_cargo_toml_in_parent_dir(path) {\n+                return Ok(p);\n+            }\n+\n+            let entities = match read_dir(path) {\n+                Ok(entities) => entities,\n+                Err(e) => {\n+                    return Err(CargoTomlNotFoundError {\n+                        searched_at: path.to_path_buf(),\n+                        reason: format!(\"file system error: {}\", e),\n+                    }\n+                    .into());\n+                }\n+            };\n+\n+            let mut valid_canditates = find_cargo_toml_in_child_dir(entities);\n+            return match valid_canditates.len() {\n+                1 => Ok(valid_canditates.remove(0)),\n+                0 => Err(CargoTomlNotFoundError {\n+                    searched_at: path.to_path_buf(),\n+                    reason: \"no Cargo.toml file found\".to_string(),\n+                }\n+                .into()),\n+                _ => Err(CargoTomlNotFoundError {\n+                    searched_at: path.to_path_buf(),\n+                    reason: format!(\n+                        \"multiple equally valid Cargo.toml files found: {:?}\",\n+                        valid_canditates\n+                    ),\n+                }\n+                .into()),\n+            };\n+        }\n+\n+        fn find_cargo_toml_in_parent_dir(path: &Path) -> Option<PathBuf> {\n+            let mut curr = Some(path);\n+            while let Some(path) = curr {\n+                let candidate = path.join(\"Cargo.toml\");\n+                if candidate.exists() {\n+                    return Some(candidate);\n+                }\n+                curr = path.parent();\n+            }\n+\n+            None\n+        }\n+\n+        fn find_cargo_toml_in_child_dir(entities: ReadDir) -> Vec<PathBuf> {\n+            // Only one level down to avoid cycles the easy way and stop a runaway scan with large projects\n+            let mut valid_canditates = vec![];\n+            for entity in entities.filter_map(Result::ok) {\n+                let candidate = entity.path().join(\"Cargo.toml\");\n+                if candidate.exists() {\n+                    valid_canditates.push(candidate)\n+                }\n+            }\n+            valid_canditates\n+        }\n+    }\n+}\n+\n+impl ProjectWorkspace {\n+    pub fn load(\n+        root: ProjectRoot,\n         cargo_features: &CargoConfig,\n+        with_sysroot: bool,\n     ) -> Result<ProjectWorkspace> {\n-        match find_rust_project_json(path) {\n-            Some(json_path) => {\n-                let file = File::open(&json_path)\n-                    .with_context(|| format!(\"Failed to open json file {}\", json_path.display()))?;\n+        let res = match root {\n+            ProjectRoot::ProjectJson(project_json) => {\n+                let file = File::open(&project_json).with_context(|| {\n+                    format!(\"Failed to open json file {}\", project_json.display())\n+                })?;\n                 let reader = BufReader::new(file);\n-                Ok(ProjectWorkspace::Json {\n+                ProjectWorkspace::Json {\n                     project: from_reader(reader).with_context(|| {\n-                        format!(\"Failed to deserialize json file {}\", json_path.display())\n+                        format!(\"Failed to deserialize json file {}\", project_json.display())\n                     })?,\n-                })\n+                }\n             }\n-            None => {\n-                let cargo_toml = find_cargo_toml(path).with_context(|| {\n-                    format!(\"Failed to find Cargo.toml for path {}\", path.display())\n-                })?;\n+            ProjectRoot::CargoToml(cargo_toml) => {\n                 let cargo = CargoWorkspace::from_cargo_metadata(&cargo_toml, cargo_features)\n                     .with_context(|| {\n                         format!(\n@@ -119,9 +219,11 @@ impl ProjectWorkspace {\n                 } else {\n                     Sysroot::default()\n                 };\n-                Ok(ProjectWorkspace::Cargo { cargo, sysroot })\n+                ProjectWorkspace::Cargo { cargo, sysroot }\n             }\n-        }\n+        };\n+\n+        Ok(res)\n     }\n \n     /// Returns the roots for the current `ProjectWorkspace`\n@@ -469,87 +571,6 @@ impl ProjectWorkspace {\n     }\n }\n \n-fn find_rust_project_json(path: &Path) -> Option<PathBuf> {\n-    if path.ends_with(\"rust-project.json\") {\n-        return Some(path.to_path_buf());\n-    }\n-\n-    let mut curr = Some(path);\n-    while let Some(path) = curr {\n-        let candidate = path.join(\"rust-project.json\");\n-        if candidate.exists() {\n-            return Some(candidate);\n-        }\n-        curr = path.parent();\n-    }\n-\n-    None\n-}\n-\n-fn find_cargo_toml_in_parent_dir(path: &Path) -> Option<PathBuf> {\n-    let mut curr = Some(path);\n-    while let Some(path) = curr {\n-        let candidate = path.join(\"Cargo.toml\");\n-        if candidate.exists() {\n-            return Some(candidate);\n-        }\n-        curr = path.parent();\n-    }\n-\n-    None\n-}\n-\n-fn find_cargo_toml_in_child_dir(entities: ReadDir) -> Vec<PathBuf> {\n-    // Only one level down to avoid cycles the easy way and stop a runaway scan with large projects\n-    let mut valid_canditates = vec![];\n-    for entity in entities.filter_map(Result::ok) {\n-        let candidate = entity.path().join(\"Cargo.toml\");\n-        if candidate.exists() {\n-            valid_canditates.push(candidate)\n-        }\n-    }\n-    valid_canditates\n-}\n-\n-fn find_cargo_toml(path: &Path) -> Result<PathBuf> {\n-    if path.ends_with(\"Cargo.toml\") {\n-        return Ok(path.to_path_buf());\n-    }\n-\n-    if let Some(p) = find_cargo_toml_in_parent_dir(path) {\n-        return Ok(p);\n-    }\n-\n-    let entities = match read_dir(path) {\n-        Ok(entities) => entities,\n-        Err(e) => {\n-            return Err(CargoTomlNotFoundError {\n-                searched_at: path.to_path_buf(),\n-                reason: format!(\"file system error: {}\", e),\n-            }\n-            .into());\n-        }\n-    };\n-\n-    let mut valid_canditates = find_cargo_toml_in_child_dir(entities);\n-    match valid_canditates.len() {\n-        1 => Ok(valid_canditates.remove(0)),\n-        0 => Err(CargoTomlNotFoundError {\n-            searched_at: path.to_path_buf(),\n-            reason: \"no Cargo.toml file found\".to_string(),\n-        }\n-        .into()),\n-        _ => Err(CargoTomlNotFoundError {\n-            searched_at: path.to_path_buf(),\n-            reason: format!(\n-                \"multiple equally valid Cargo.toml files found: {:?}\",\n-                valid_canditates\n-            ),\n-        }\n-        .into()),\n-    }\n-}\n-\n pub fn get_rustc_cfg_options() -> CfgOptions {\n     let mut cfg_options = CfgOptions::default();\n "}, {"sha": "f3f266ee444e00a558f7e8a8445505afd51ba6e1", "filename": "crates/rust-analyzer/src/cli/load_cargo.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/be2654b0ed3e4eb51bc3745b2329d6264588549f/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fload_cargo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be2654b0ed3e4eb51bc3745b2329d6264588549f/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fload_cargo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fload_cargo.rs?ref=be2654b0ed3e4eb51bc3745b2329d6264588549f", "patch": "@@ -8,7 +8,7 @@ use crossbeam_channel::{unbounded, Receiver};\n use ra_db::{ExternSourceId, FileId, SourceRootId};\n use ra_ide::{AnalysisChange, AnalysisHost};\n use ra_project_model::{\n-    get_rustc_cfg_options, CargoConfig, PackageRoot, ProcMacroClient, ProjectWorkspace,\n+    get_rustc_cfg_options, CargoConfig, PackageRoot, ProcMacroClient, ProjectRoot, ProjectWorkspace,\n };\n use ra_vfs::{RootEntry, Vfs, VfsChange, VfsTask, Watch};\n use rustc_hash::{FxHashMap, FxHashSet};\n@@ -27,9 +27,11 @@ pub(crate) fn load_cargo(\n     load_out_dirs_from_check: bool,\n ) -> Result<(AnalysisHost, FxHashMap<SourceRootId, PackageRoot>)> {\n     let root = std::env::current_dir()?.join(root);\n-    let ws = ProjectWorkspace::discover(\n-        root.as_ref(),\n+    let root = ProjectRoot::discover(&root)?;\n+    let ws = ProjectWorkspace::load(\n+        root,\n         &CargoConfig { load_out_dirs_from_check, ..Default::default() },\n+        true,\n     )?;\n \n     let mut extern_dirs = FxHashSet::default();"}, {"sha": "9c345601cb061440e1b2b0d0e470a9ff129e5ead", "filename": "crates/rust-analyzer/src/main_loop.rs", "status": "modified", "additions": 37, "deletions": 25, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/be2654b0ed3e4eb51bc3745b2329d6264588549f/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be2654b0ed3e4eb51bc3745b2329d6264588549f/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fmain_loop.rs?ref=be2654b0ed3e4eb51bc3745b2329d6264588549f", "patch": "@@ -88,37 +88,49 @@ pub fn main_loop(ws_roots: Vec<PathBuf>, config: Config, connection: Connection)\n \n     let mut loop_state = LoopState::default();\n     let mut world_state = {\n-        // FIXME: support dynamic workspace loading.\n         let workspaces = {\n-            let mut loaded_workspaces = Vec::new();\n-            for ws_root in &ws_roots {\n-                let workspace = ra_project_model::ProjectWorkspace::discover_with_sysroot(\n-                    ws_root.as_path(),\n-                    config.with_sysroot,\n-                    &config.cargo,\n-                );\n-                match workspace {\n-                    Ok(workspace) => loaded_workspaces.push(workspace),\n-                    Err(e) => {\n-                        log::error!(\"loading workspace failed: {:?}\", e);\n-\n-                        if let Some(ra_project_model::CargoTomlNotFoundError { .. }) =\n-                            e.downcast_ref()\n-                        {\n-                            if !config.notifications.cargo_toml_not_found {\n-                                continue;\n-                            }\n+            // FIXME: support dynamic workspace loading.\n+            let mut visited = FxHashSet::default();\n+            let project_roots = ws_roots\n+                .iter()\n+                .map(|it| ra_project_model::ProjectRoot::discover(it))\n+                .filter_map(|dir| {\n+                    dir.map_err(|cargo_toml_not_found| {\n+                        log::error!(\"discovering workspace failed: {:?}\", cargo_toml_not_found);\n+\n+                        if config.notifications.cargo_toml_not_found {\n+                            show_message(\n+                                req::MessageType::Error,\n+                                format!(\n+                                    \"rust-analyzer failed to discover workspace: {:?}\",\n+                                    cargo_toml_not_found\n+                                ),\n+                                &connection.sender,\n+                            );\n                         }\n-\n+                    })\n+                    .ok()\n+                })\n+                .filter(|it| visited.insert(it.clone()));\n+\n+            project_roots\n+                .filter_map(|root| {\n+                    ra_project_model::ProjectWorkspace::load(\n+                        root,\n+                        &config.cargo,\n+                        config.with_sysroot,\n+                    )\n+                    .map_err(|err| {\n+                        log::error!(\"failed to load workspace: {:#}\", err);\n                         show_message(\n                             req::MessageType::Error,\n-                            format!(\"rust-analyzer failed to load workspace: {:?}\", e),\n+                            format!(\"rust-analyzer failed to load workspace: {:#}\", err),\n                             &connection.sender,\n                         );\n-                    }\n-                }\n-            }\n-            loaded_workspaces\n+                    })\n+                    .ok()\n+                })\n+                .collect::<Vec<_>>()\n         };\n \n         let globs = config"}]}