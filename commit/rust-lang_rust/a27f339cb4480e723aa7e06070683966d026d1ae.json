{"sha": "a27f339cb4480e723aa7e06070683966d026d1ae", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEyN2YzMzljYjQ0ODBlNzIzYWE3ZTA2MDcwNjgzOTY2ZDAyNmQxYWU=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-08-04T06:29:21Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-08-04T22:11:56Z"}, "message": "std::rt: Don't allow schedulers to exit before handling all messages\n\nEvery time run_sched_once performs a 'scheduling action' it needs to guarantee\nthat it runs at least one more time, so enqueue another run_sched_once callback.\nThe primary reason it needs to do this is because not all async callbacks\nare guaranteed to run, it's only guaranteed that *a* callback will run after\nenqueing one - some may get dropped.\n\nAt the moment this means we wastefully create lots of callbacks to ensure that\nthere will *definitely* be a callback queued up to continue running the scheduler.\nThe logic really needs to be tightened up here.", "tree": {"sha": "69284728b4a806e428443a733a88635b1215e703", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/69284728b4a806e428443a733a88635b1215e703"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a27f339cb4480e723aa7e06070683966d026d1ae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a27f339cb4480e723aa7e06070683966d026d1ae", "html_url": "https://github.com/rust-lang/rust/commit/a27f339cb4480e723aa7e06070683966d026d1ae", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a27f339cb4480e723aa7e06070683966d026d1ae/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f0f7e1b3fcfed8b77516a871ae82a4aa8df07764", "url": "https://api.github.com/repos/rust-lang/rust/commits/f0f7e1b3fcfed8b77516a871ae82a4aa8df07764", "html_url": "https://github.com/rust-lang/rust/commit/f0f7e1b3fcfed8b77516a871ae82a4aa8df07764"}], "stats": {"total": 10, "additions": 10, "deletions": 0}, "files": [{"sha": "a5c8abc2a6c0e2951ff523aa568608279286c32f", "filename": "src/libstd/rt/sched.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a27f339cb4480e723aa7e06070683966d026d1ae/src%2Flibstd%2Frt%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a27f339cb4480e723aa7e06070683966d026d1ae/src%2Flibstd%2Frt%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fsched.rs?ref=a27f339cb4480e723aa7e06070683966d026d1ae", "patch": "@@ -172,6 +172,10 @@ impl Scheduler {\n \n         rtdebug!(\"stopping scheduler %u\", stask.sched.get_ref().sched_id());\n \n+        // Should not have any messages\n+        let message = stask.sched.get_mut_ref().message_queue.pop();\n+        assert!(message.is_none());\n+\n         stask.destroyed = true;\n     }\n \n@@ -336,11 +340,14 @@ impl Scheduler {\n         match this.message_queue.pop() {\n             Some(PinnedTask(task)) => {\n                 let mut task = task;\n+                this.event_loop.callback(Scheduler::run_sched_once);\n                 task.give_home(Sched(this.make_handle()));\n                 this.resume_task_immediately(task);\n                 return None;\n             }\n             Some(TaskFromFriend(task)) => {\n+                this.event_loop.callback(Scheduler::run_sched_once);\n+                rtdebug!(\"got a task from a friend. lovely!\");\n                 return this.sched_schedule_task(task);\n             }\n             Some(Wake) => {\n@@ -395,6 +402,7 @@ impl Scheduler {\n     /// Take a non-homed task we aren't allowed to run here and send\n     /// it to the designated friend scheduler to execute.\n     fn send_to_friend(&mut self, task: ~Task) {\n+        rtdebug!(\"sending a task to friend\");\n         match self.friend_handle {\n             Some(ref mut handle) => {\n                 handle.send(TaskFromFriend(task));\n@@ -426,12 +434,14 @@ impl Scheduler {\n                             Scheduler::send_task_home(task);\n                             return Some(this);\n                         } else {\n+                            this.event_loop.callback(Scheduler::run_sched_once);\n                             task.give_home(Sched(home_handle));\n                             this.resume_task_immediately(task);\n                             return None;\n                         }\n                     }\n                     AnySched if this.run_anything => {\n+                        this.event_loop.callback(Scheduler::run_sched_once);\n                         task.give_home(AnySched);\n                         this.resume_task_immediately(task);\n                         return None;"}]}