{"sha": "11984340bfe93be311eeea9881ae2d1fb8fb0ddb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjExOTg0MzQwYmZlOTNiZTMxMWVlZWE5ODgxYWUyZDFmYjhmYjBkZGI=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-04-20T23:51:56Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-05-31T23:41:25Z"}, "message": "make HR algorithms account for region subtyping\n\nCurrently, we consider region subtyping a failure\nif a skolemized lifetime is relatable to any\nother lifetime in any way at all. But a more precise\nformulation is to say that a skolemized lifetime:\n\n- must not have any *incoming* edges in the region graph\n- only has *outgoing* edges to nodes that are `'static`\n\nTo enforce the latter requirement, we add edges from `'static -> 'x` for\neach lifetime '`x' reachable from a skolemized region.\n\nWe now have to add a new `pop_skolemized` routine to do cleanup.\nWhereas before if there were *any* edges relating to a skolemized\nregion, we would return `Err` and hence rollback the transaction, we now\ntolerate some edges and return `Ok`. Therefore, the `pop_skolemized`\nroutine runs and cleans up those edges.", "tree": {"sha": "5c882ed87fb41ddb4735bb4eb2207e497fd5d8f6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5c882ed87fb41ddb4735bb4eb2207e497fd5d8f6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/11984340bfe93be311eeea9881ae2d1fb8fb0ddb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/11984340bfe93be311eeea9881ae2d1fb8fb0ddb", "html_url": "https://github.com/rust-lang/rust/commit/11984340bfe93be311eeea9881ae2d1fb8fb0ddb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/11984340bfe93be311eeea9881ae2d1fb8fb0ddb/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aecce2ba6eba5fbadb2e5aaf9eb29a30acea086d", "url": "https://api.github.com/repos/rust-lang/rust/commits/aecce2ba6eba5fbadb2e5aaf9eb29a30acea086d", "html_url": "https://github.com/rust-lang/rust/commit/aecce2ba6eba5fbadb2e5aaf9eb29a30acea086d"}], "stats": {"total": 807, "additions": 639, "deletions": 168}, "files": [{"sha": "ed83870ea386c593cced0be322ddc21b5ced96bf", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/11984340bfe93be311eeea9881ae2d1fb8fb0ddb/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11984340bfe93be311eeea9881ae2d1fb8fb0ddb/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=11984340bfe93be311eeea9881ae2d1fb8fb0ddb", "patch": "@@ -1648,4 +1648,5 @@ register_diagnostics! {\n     E0491, // in type `..`, reference has a longer lifetime than the data it...\n     E0495, // cannot infer an appropriate lifetime due to conflicting requirements\n     E0525, // expected a closure that implements `..` but this closure only implements `..`\n+    E0526, // skolemization subtype\n }"}, {"sha": "628fd569d4007f5c46d4cac2d8f539bbaa542273", "filename": "src/librustc/infer/error_reporting.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/11984340bfe93be311eeea9881ae2d1fb8fb0ddb/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11984340bfe93be311eeea9881ae2d1fb8fb0ddb/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting.rs?ref=11984340bfe93be311eeea9881ae2d1fb8fb0ddb", "patch": "@@ -918,6 +918,17 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                     \"\");\n                 err\n             }\n+            infer::SkolemizeSuccessor(span) => {\n+                let mut err =\n+                    struct_span_err!(self.tcx.sess, span, E0526,\n+                                     \"to satisfy higher-ranked bounds, \\\n+                                      a static lifetime is required\");\n+                self.tcx.note_and_explain_region(&mut err,\n+                    \"but the lifetime is only valid for \",\n+                    sub,\n+                    \"\");\n+                err\n+            }\n         }\n     }\n \n@@ -1784,6 +1795,11 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                     \"...so that references are valid when the destructor \\\n                      runs\");\n             }\n+            infer::SkolemizeSuccessor(span) => {\n+                err.span_note(\n+                    span,\n+                    \"...so that higher-ranked bounds are satisfied\");\n+            }\n         }\n     }\n }"}, {"sha": "9ea2a830c9e7510e94642972b0e4ec8855d143d5", "filename": "src/librustc/infer/higher_ranked/mod.rs", "status": "modified", "additions": 153, "deletions": 31, "changes": 184, "blob_url": "https://github.com/rust-lang/rust/blob/11984340bfe93be311eeea9881ae2d1fb8fb0ddb/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11984340bfe93be311eeea9881ae2d1fb8fb0ddb/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=11984340bfe93be311eeea9881ae2d1fb8fb0ddb", "patch": "@@ -11,9 +11,16 @@\n //! Helper routines for higher-ranked things. See the `doc` module at\n //! the end of the file for details.\n \n-use super::{CombinedSnapshot, InferCtxt, HigherRankedType, SkolemizationMap};\n+use super::{CombinedSnapshot,\n+            InferCtxt,\n+            LateBoundRegion,\n+            HigherRankedType,\n+            SubregionOrigin,\n+            SkolemizationMap};\n use super::combine::CombineFields;\n+use super::region_inference::{TaintDirections};\n \n+use infer::error_reporting;\n use ty::{self, TyCtxt, Binder, TypeFoldable};\n use ty::error::TypeError;\n use ty::relate::{Relate, RelateResult, TypeRelation};\n@@ -39,11 +46,13 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n         // Start a snapshot so we can examine \"all bindings that were\n         // created as part of this type comparison\".\n         return self.infcx.commit_if_ok(|snapshot| {\n+            let span = self.trace.origin.span();\n+\n             // First, we instantiate each bound region in the subtype with a fresh\n             // region variable.\n             let (a_prime, _) =\n                 self.infcx.replace_late_bound_regions_with_fresh_var(\n-                    self.trace.origin.span(),\n+                    span,\n                     HigherRankedType,\n                     a);\n \n@@ -60,7 +69,11 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n \n             // Presuming type comparison succeeds, we need to check\n             // that the skolemized regions do not \"leak\".\n-            self.infcx.leak_check(!self.a_is_expected, &skol_map, snapshot)?;\n+            self.infcx.leak_check(!self.a_is_expected, span, &skol_map, snapshot)?;\n+\n+            // We are finished with the skolemized regions now so pop\n+            // them off.\n+            self.infcx.pop_skolemized(skol_map, snapshot);\n \n             debug!(\"higher_ranked_sub: OK result={:?}\", result);\n \n@@ -124,7 +137,7 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n                 return r0;\n             }\n \n-            let tainted = infcx.tainted_regions(snapshot, r0);\n+            let tainted = infcx.tainted_regions(snapshot, r0, TaintDirections::both());\n \n             // Variables created during LUB computation which are\n             // *related* to regions that pre-date the LUB computation\n@@ -219,7 +232,7 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n                 return r0;\n             }\n \n-            let tainted = infcx.tainted_regions(snapshot, r0);\n+            let tainted = infcx.tainted_regions(snapshot, r0, TaintDirections::both());\n \n             let mut a_r = None;\n             let mut b_r = None;\n@@ -341,8 +354,12 @@ fn fold_regions_in<'a, 'gcx, 'tcx, T, F>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n }\n \n impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n-    fn tainted_regions(&self, snapshot: &CombinedSnapshot, r: ty::Region) -> Vec<ty::Region> {\n-        self.region_vars.tainted(&snapshot.region_vars_snapshot, r)\n+    fn tainted_regions(&self,\n+                       snapshot: &CombinedSnapshot,\n+                       r: ty::Region,\n+                       directions: TaintDirections)\n+                       -> FnvHashSet<ty::Region> {\n+        self.region_vars.tainted(&snapshot.region_vars_snapshot, r, directions)\n     }\n \n     fn region_vars_confined_to_snapshot(&self,\n@@ -422,22 +439,27 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         region_vars\n     }\n \n+    /// Replace all regions bound by `binder` with skolemized regions and\n+    /// return a map indicating which bound-region was replaced with what\n+    /// skolemized region. This is the first step of checking subtyping\n+    /// when higher-ranked things are involved.\n+    ///\n+    /// **Important:** you must call this function from within a snapshot.\n+    /// Moreover, before committing the snapshot, you must eventually call\n+    /// either `plug_leaks` or `pop_skolemized` to remove the skolemized\n+    /// regions. If you rollback the snapshot (or are using a probe), then\n+    /// the pop occurs as part of the rollback, so an explicit call is not\n+    /// needed (but is also permitted).\n+    ///\n+    /// See `README.md` for more details.\n     pub fn skolemize_late_bound_regions<T>(&self,\n                                            binder: &ty::Binder<T>,\n                                            snapshot: &CombinedSnapshot)\n                                            -> (T, SkolemizationMap)\n         where T : TypeFoldable<'tcx>\n     {\n-        /*!\n-         * Replace all regions bound by `binder` with skolemized regions and\n-         * return a map indicating which bound-region was replaced with what\n-         * skolemized region. This is the first step of checking subtyping\n-         * when higher-ranked things are involved. See `README.md` for more\n-         * details.\n-         */\n-\n         let (result, map) = self.tcx.replace_late_bound_regions(binder, |br| {\n-            self.region_vars.new_skolemized(br, &snapshot.region_vars_snapshot)\n+            self.region_vars.push_skolemized(br, &snapshot.region_vars_snapshot)\n         });\n \n         debug!(\"skolemize_bound_regions(binder={:?}, result={:?}, map={:?})\",\n@@ -448,27 +470,29 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         (result, map)\n     }\n \n+    /// Searches the region constriants created since `snapshot` was started\n+    /// and checks to determine whether any of the skolemized regions created\n+    /// in `skol_map` would \"escape\" -- meaning that they are related to\n+    /// other regions in some way. If so, the higher-ranked subtyping doesn't\n+    /// hold. See `README.md` for more details.\n     pub fn leak_check(&self,\n                       overly_polymorphic: bool,\n+                      span: Span,\n                       skol_map: &SkolemizationMap,\n                       snapshot: &CombinedSnapshot)\n                       -> RelateResult<'tcx, ()>\n     {\n-        /*!\n-         * Searches the region constriants created since `snapshot` was started\n-         * and checks to determine whether any of the skolemized regions created\n-         * in `skol_map` would \"escape\" -- meaning that they are related to\n-         * other regions in some way. If so, the higher-ranked subtyping doesn't\n-         * hold. See `README.md` for more details.\n-         */\n-\n         debug!(\"leak_check: skol_map={:?}\",\n                skol_map);\n \n         let new_vars = self.region_vars_confined_to_snapshot(snapshot);\n         for (&skol_br, &skol) in skol_map {\n-            let tainted = self.tainted_regions(snapshot, skol);\n-            for &tainted_region in &tainted {\n+            // The inputs to a skolemized variable can only\n+            // be itself or other new variables.\n+            let incoming_taints = self.tainted_regions(snapshot,\n+                                                       skol,\n+                                                       TaintDirections::incoming());\n+            for &tainted_region in &incoming_taints {\n                 // Each skolemized should only be relatable to itself\n                 // or new variables:\n                 match tainted_region {\n@@ -496,6 +520,72 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 }\n             }\n         }\n+\n+        for (_, &skol) in skol_map {\n+            // The outputs from a skolemized variable must all be\n+            // equatable with `'static`.\n+            let outgoing_taints = self.tainted_regions(snapshot,\n+                                                       skol,\n+                                                       TaintDirections::outgoing());\n+            for &tainted_region in &outgoing_taints {\n+                match tainted_region {\n+                    ty::ReVar(vid) if new_vars.contains(&vid) => {\n+                        // There is a path from a skolemized variable\n+                        // to some region variable that doesn't escape\n+                        // this snapshot:\n+                        //\n+                        //    [skol] -> [tainted_region]\n+                        //\n+                        // We can ignore this. The reasoning relies on\n+                        // the fact that the preivous loop\n+                        // completed. There are two possible cases\n+                        // here.\n+                        //\n+                        // - `tainted_region` eventually reaches a\n+                        //   skolemized variable, which *must* be `skol`\n+                        //   (because otherwise we would have already\n+                        //   returned `Err`). In that case,\n+                        //   `tainted_region` could be inferred to `skol`.\n+                        //\n+                        // - `tainted_region` never reaches a\n+                        //   skolemized variable. In that case, we can\n+                        //   safely choose `'static` as an upper bound\n+                        //   incoming edges. This is a conservative\n+                        //   choice -- the LUB might be one of the\n+                        //   incoming skolemized variables, which we\n+                        //   might know by ambient bounds. We can\n+                        //   consider a more clever choice of upper\n+                        //   bound later (modulo some theoretical\n+                        //   breakage).\n+                        //\n+                        // We used to force such `tainted_region` to be\n+                        // `'static`, but that leads to problems when\n+                        // combined with `plug_leaks`. If you have a case\n+                        // where `[skol] -> [tainted_region] -> [skol]`,\n+                        // then `plug_leaks` concludes it should replace\n+                        // `'static` with a late-bound region, which is\n+                        // clearly wrong. (Well, what actually happens is\n+                        // you get assertion failures because it WOULD\n+                        // have to replace 'static with a late-bound\n+                        // region.)\n+                    }\n+                    ty::ReSkolemized(..) => {\n+                        // the only skolemized region we find in the\n+                        // successors of X can be X; if there was another\n+                        // region Y, then X would have been in the preds\n+                        // of Y, and we would have aborted above\n+                        assert_eq!(skol, tainted_region);\n+                    }\n+                    _ => {\n+                        self.region_vars.make_subregion(\n+                            SubregionOrigin::SkolemizeSuccessor(span),\n+                            ty::ReStatic,\n+                            tainted_region);\n+                    }\n+                }\n+            }\n+        }\n+\n         Ok(())\n     }\n \n@@ -533,8 +623,6 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                          value: &T) -> T\n         where T : TypeFoldable<'tcx>\n     {\n-        debug_assert!(self.leak_check(false, &skol_map, snapshot).is_ok());\n-\n         debug!(\"plug_leaks(skol_map={:?}, value={:?})\",\n                skol_map,\n                value);\n@@ -545,9 +633,9 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         // these taint sets are mutually disjoint.\n         let inv_skol_map: FnvHashMap<ty::Region, ty::BoundRegion> =\n             skol_map\n-            .into_iter()\n-            .flat_map(|(skol_br, skol)| {\n-                self.tainted_regions(snapshot, skol)\n+            .iter()\n+            .flat_map(|(&skol_br, &skol)| {\n+                self.tainted_regions(snapshot, skol, TaintDirections::incoming())\n                     .into_iter()\n                     .map(move |tainted_region| (tainted_region, skol_br))\n             })\n@@ -577,6 +665,19 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                     // binders, so this assert is satisfied.\n                     assert!(current_depth > 1);\n \n+                    // since leak-check passed, this skolemized region\n+                    // should only have incoming edges from variables\n+                    // (which ought not to escape the snapshot, but we\n+                    // don't check that) or itself\n+                    assert!(\n+                        match r {\n+                            ty::ReVar(_) => true,\n+                            ty::ReSkolemized(_, ref br1) => br == br1,\n+                            _ => false,\n+                        },\n+                        \"leak-check would have us replace {:?} with {:?}\",\n+                        r, br);\n+\n                     ty::ReLateBound(ty::DebruijnIndex::new(current_depth - 1), br.clone())\n                 }\n             }\n@@ -585,6 +686,27 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         debug!(\"plug_leaks: result={:?}\",\n                result);\n \n+        self.pop_skolemized(skol_map, snapshot);\n+\n+        debug!(\"plug_leaks: result={:?}\", result);\n+\n         result\n     }\n+\n+    /// Pops the skolemized regions found in `skol_map` from the region\n+    /// inference context. Whenever you create skolemized regions via\n+    /// `skolemize_late_bound_regions`, they must be popped before you\n+    /// commit the enclosing snapshot (if you do not commit, e.g. within a\n+    /// probe or as a result of an error, then this is not necessary, as\n+    /// popping happens as part of the rollback).\n+    ///\n+    /// Note: popping also occurs implicitly as part of `leak_check`.\n+    pub fn pop_skolemized(&self,\n+                          skol_map: SkolemizationMap,\n+                          snapshot: &CombinedSnapshot)\n+    {\n+        debug!(\"pop_skolemized({:?})\", skol_map);\n+        let skol_regions: FnvHashSet<_> = skol_map.values().cloned().collect();\n+        self.region_vars.pop_skolemized(&skol_regions, &snapshot.region_vars_snapshot);\n+    }\n }"}, {"sha": "1f1fed7c5e8850a5d0feb8501f9c8ff90dcb3b52", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/11984340bfe93be311eeea9881ae2d1fb8fb0ddb/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11984340bfe93be311eeea9881ae2d1fb8fb0ddb/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=11984340bfe93be311eeea9881ae2d1fb8fb0ddb", "patch": "@@ -340,6 +340,11 @@ pub enum SubregionOrigin<'tcx> {\n \n     // Region constraint arriving from destructor safety\n     SafeDestructor(Span),\n+\n+    // When doing a higher-ranked comparison, this region was a\n+    // successor from a skolemized region, which means that it must be\n+    // `'static` to be sound.\n+    SkolemizeSuccessor(Span),\n }\n \n /// Places that type/region parameters can appear.\n@@ -538,7 +543,7 @@ impl<T> ExpectedFound<T> {\n }\n \n impl<'tcx, T> InferOk<'tcx, T> {\n-    fn unit(self) -> InferOk<'tcx, ()> {\n+    pub fn unit(self) -> InferOk<'tcx, ()> {\n         InferOk { value: (), obligations: self.obligations }\n     }\n }\n@@ -1076,7 +1081,9 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 self.skolemize_late_bound_regions(predicate, snapshot);\n             let origin = TypeOrigin::EquatePredicate(span);\n             let eqty_ok = self.eq_types(false, origin, a, b)?;\n-            self.leak_check(false, &skol_map, snapshot).map(|_| eqty_ok.unit())\n+            self.leak_check(false, span, &skol_map, snapshot)?;\n+            self.pop_skolemized(skol_map, snapshot);\n+            Ok(eqty_ok.unit())\n         })\n     }\n \n@@ -1090,7 +1097,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 self.skolemize_late_bound_regions(predicate, snapshot);\n             let origin = RelateRegionParamBound(span);\n             self.sub_regions(origin, r_b, r_a); // `b : a` ==> `a <= b`\n-            self.leak_check(false, &skol_map, snapshot)\n+            self.leak_check(false, span, &skol_map, snapshot)?;\n+            Ok(self.pop_skolemized(skol_map, snapshot))\n         })\n     }\n \n@@ -1790,6 +1798,7 @@ impl<'tcx> SubregionOrigin<'tcx> {\n             AddrOf(a) => a,\n             AutoBorrow(a) => a,\n             SafeDestructor(a) => a,\n+            SkolemizeSuccessor(a) => a,\n         }\n     }\n }"}, {"sha": "a0198d0734e21641fab881fa41a55fb736eeba4b", "filename": "src/librustc/infer/region_inference/mod.rs", "status": "modified", "additions": 293, "deletions": 110, "changes": 403, "blob_url": "https://github.com/rust-lang/rust/blob/11984340bfe93be311eeea9881ae2d1fb8fb0ddb/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11984340bfe93be311eeea9881ae2d1fb8fb0ddb/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs?ref=11984340bfe93be311eeea9881ae2d1fb8fb0ddb", "patch": "@@ -20,19 +20,19 @@ pub use self::VarValue::*;\n use super::{RegionVariableOrigin, SubregionOrigin, MiscVariable};\n use super::unify_key;\n \n+use rustc_data_structures::fnv::{FnvHashMap, FnvHashSet};\n use rustc_data_structures::graph::{self, Direction, NodeIndex, OUTGOING};\n use rustc_data_structures::unify::{self, UnificationTable};\n use middle::free_region::FreeRegionMap;\n use ty::{self, Ty, TyCtxt};\n use ty::{BoundRegion, Region, RegionVid};\n use ty::{ReEmpty, ReStatic, ReFree, ReEarlyBound};\n use ty::{ReLateBound, ReScope, ReVar, ReSkolemized, BrFresh};\n-use util::common::indenter;\n-use util::nodemap::{FnvHashMap, FnvHashSet};\n \n use std::cell::{Cell, RefCell};\n use std::cmp::Ordering::{self, Less, Greater, Equal};\n use std::fmt;\n+use std::mem;\n use std::u32;\n use syntax::ast;\n \n@@ -108,13 +108,36 @@ pub struct TwoRegions {\n \n #[derive(Copy, Clone, PartialEq)]\n pub enum UndoLogEntry {\n+    /// Pushed when we start a snapshot.\n     OpenSnapshot,\n+\n+    /// Replaces an `OpenSnapshot` when a snapshot is committed, but\n+    /// that snapshot is not the root. If the root snapshot is\n+    /// unrolled, all nested snapshots must be committed.\n     CommitedSnapshot,\n+\n+    /// We added `RegionVid`\n     AddVar(RegionVid),\n+\n+    /// We added the given `constraint`\n     AddConstraint(Constraint),\n+\n+    /// We added the given `verify`\n     AddVerify(usize),\n+\n+    /// We added the given `given`\n     AddGiven(ty::FreeRegion, ty::RegionVid),\n+\n+    /// We added a GLB/LUB \"combinaton variable\"\n     AddCombination(CombineMapType, TwoRegions),\n+\n+    /// During skolemization, we sometimes purge entries from the undo\n+    /// log in a kind of minisnapshot (unlike other snapshots, this\n+    /// purging actually takes place *on success*). In that case, we\n+    /// replace the corresponding entry with `Noop` so as to avoid the\n+    /// need to do a bunch of swapping. (We can't use `swap_remove` as\n+    /// the order of the vector is important.)\n+    Purged,\n }\n \n #[derive(Copy, Clone, PartialEq)]\n@@ -253,6 +276,116 @@ pub struct RegionSnapshot {\n     skolemization_count: u32,\n }\n \n+/// When working with skolemized regions, we often wish to find all of\n+/// the regions that are either reachable from a skolemized region, or\n+/// which can reach a skolemized region, or both. We call such regions\n+/// *tained* regions.  This struct allows you to decide what set of\n+/// tainted regions you want.\n+#[derive(Debug)]\n+pub struct TaintDirections {\n+    incoming: bool,\n+    outgoing: bool,\n+}\n+\n+impl TaintDirections {\n+    pub fn incoming() -> Self {\n+        TaintDirections { incoming: true, outgoing: false }\n+    }\n+\n+    pub fn outgoing() -> Self {\n+        TaintDirections { incoming: false, outgoing: true }\n+    }\n+\n+    pub fn both() -> Self {\n+        TaintDirections { incoming: true, outgoing: true }\n+    }\n+}\n+\n+struct TaintSet {\n+    directions: TaintDirections,\n+    regions: FnvHashSet<ty::Region>\n+}\n+\n+impl TaintSet {\n+    fn new(directions: TaintDirections,\n+           initial_region: ty::Region)\n+           -> Self {\n+        let mut regions = FnvHashSet();\n+        regions.insert(initial_region);\n+        TaintSet { directions: directions, regions: regions }\n+    }\n+\n+    fn fixed_point(&mut self,\n+                   undo_log: &[UndoLogEntry],\n+                   verifys: &[Verify]) {\n+        let mut prev_len = 0;\n+        while prev_len < self.len() {\n+            debug!(\"tainted: prev_len = {:?} new_len = {:?}\",\n+                   prev_len, self.len());\n+\n+            prev_len = self.len();\n+\n+            for undo_entry in undo_log {\n+                match undo_entry {\n+                    &AddConstraint(ConstrainVarSubVar(a, b)) => {\n+                        self.add_edge(ReVar(a), ReVar(b));\n+                    }\n+                    &AddConstraint(ConstrainRegSubVar(a, b)) => {\n+                        self.add_edge(a, ReVar(b));\n+                    }\n+                    &AddConstraint(ConstrainVarSubReg(a, b)) => {\n+                        self.add_edge(ReVar(a), b);\n+                    }\n+                    &AddGiven(a, b) => {\n+                        self.add_edge(ReFree(a), ReVar(b));\n+                    }\n+                    &AddVerify(i) => {\n+                        match verifys[i] {\n+                            VerifyRegSubReg(_, a, b) => {\n+                                self.add_edge(a, b);\n+                            }\n+                            VerifyGenericBound(_, _, a, ref bound) => {\n+                                bound.for_each_region(&mut |b| {\n+                                    self.add_edge(a, b);\n+                                });\n+                            }\n+                        }\n+                    }\n+                    &Purged |\n+                    &AddCombination(..) |\n+                    &AddVar(..) |\n+                    &OpenSnapshot |\n+                    &CommitedSnapshot => {}\n+                }\n+            }\n+        }\n+    }\n+\n+    fn into_set(self) -> FnvHashSet<ty::Region> {\n+        self.regions\n+    }\n+\n+    fn len(&self) -> usize {\n+        self.regions.len()\n+    }\n+\n+    fn add_edge(&mut self,\n+                source: ty::Region,\n+                target: ty::Region) {\n+        if self.directions.incoming {\n+            if self.regions.contains(&target) {\n+                self.regions.insert(source);\n+            }\n+        }\n+\n+        if self.directions.outgoing {\n+            if self.regions.contains(&source) {\n+                self.regions.insert(target);\n+            }\n+        }\n+    }\n+}\n+\n impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n     pub fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>) -> RegionVarBindings<'a, 'gcx, 'tcx> {\n         RegionVarBindings {\n@@ -290,14 +423,17 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n         debug!(\"RegionVarBindings: commit({})\", snapshot.length);\n         assert!(self.undo_log.borrow().len() > snapshot.length);\n         assert!((*self.undo_log.borrow())[snapshot.length] == OpenSnapshot);\n+        assert!(self.skolemization_count.get() == snapshot.skolemization_count,\n+                \"failed to pop skolemized regions: {} now vs {} at start\",\n+                self.skolemization_count.get(),\n+                snapshot.skolemization_count);\n \n         let mut undo_log = self.undo_log.borrow_mut();\n         if snapshot.length == 0 {\n             undo_log.truncate(0);\n         } else {\n             (*undo_log)[snapshot.length] = CommitedSnapshot;\n         }\n-        self.skolemization_count.set(snapshot.skolemization_count);\n         self.unification_table.borrow_mut().commit(snapshot.region_snapshot);\n     }\n \n@@ -307,33 +443,7 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n         assert!(undo_log.len() > snapshot.length);\n         assert!((*undo_log)[snapshot.length] == OpenSnapshot);\n         while undo_log.len() > snapshot.length + 1 {\n-            match undo_log.pop().unwrap() {\n-                OpenSnapshot => {\n-                    bug!(\"Failure to observe stack discipline\");\n-                }\n-                CommitedSnapshot => {}\n-                AddVar(vid) => {\n-                    let mut var_origins = self.var_origins.borrow_mut();\n-                    var_origins.pop().unwrap();\n-                    assert_eq!(var_origins.len(), vid.index as usize);\n-                }\n-                AddConstraint(ref constraint) => {\n-                    self.constraints.borrow_mut().remove(constraint);\n-                }\n-                AddVerify(index) => {\n-                    self.verifys.borrow_mut().pop();\n-                    assert_eq!(self.verifys.borrow().len(), index);\n-                }\n-                AddGiven(sub, sup) => {\n-                    self.givens.borrow_mut().remove(&(sub, sup));\n-                }\n-                AddCombination(Glb, ref regions) => {\n-                    self.glbs.borrow_mut().remove(regions);\n-                }\n-                AddCombination(Lub, ref regions) => {\n-                    self.lubs.borrow_mut().remove(regions);\n-                }\n-            }\n+            self.rollback_undo_entry(undo_log.pop().unwrap());\n         }\n         let c = undo_log.pop().unwrap();\n         assert!(c == OpenSnapshot);\n@@ -342,6 +452,38 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n             .rollback_to(snapshot.region_snapshot);\n     }\n \n+    pub fn rollback_undo_entry(&self, undo_entry: UndoLogEntry) {\n+        match undo_entry {\n+            OpenSnapshot => {\n+                panic!(\"Failure to observe stack discipline\");\n+            }\n+            Purged | CommitedSnapshot => {\n+                // nothing to do here\n+            }\n+            AddVar(vid) => {\n+                let mut var_origins = self.var_origins.borrow_mut();\n+                var_origins.pop().unwrap();\n+                assert_eq!(var_origins.len(), vid.index as usize);\n+            }\n+            AddConstraint(ref constraint) => {\n+                self.constraints.borrow_mut().remove(constraint);\n+            }\n+            AddVerify(index) => {\n+                self.verifys.borrow_mut().pop();\n+                assert_eq!(self.verifys.borrow().len(), index);\n+            }\n+            AddGiven(sub, sup) => {\n+                self.givens.borrow_mut().remove(&(sub, sup));\n+            }\n+            AddCombination(Glb, ref regions) => {\n+                self.glbs.borrow_mut().remove(regions);\n+            }\n+            AddCombination(Lub, ref regions) => {\n+                self.lubs.borrow_mut().remove(regions);\n+            }\n+        }\n+    }\n+\n     pub fn num_vars(&self) -> u32 {\n         let len = self.var_origins.borrow().len();\n         // enforce no overflow\n@@ -366,22 +508,30 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n         return vid;\n     }\n \n+    pub fn var_origin(&self, vid: RegionVid) -> RegionVariableOrigin {\n+        self.var_origins.borrow()[vid.index as usize].clone()\n+    }\n+\n     /// Creates a new skolemized region. Skolemized regions are fresh\n     /// regions used when performing higher-ranked computations. They\n     /// must be used in a very particular way and are never supposed\n     /// to \"escape\" out into error messages or the code at large.\n     ///\n     /// The idea is to always create a snapshot. Skolemized regions\n-    /// can be created in the context of this snapshot, but once the\n-    /// snapshot is committed or rolled back, their numbers will be\n-    /// recycled, so you must be finished with them. See the extensive\n-    /// comments in `higher_ranked.rs` to see how it works (in\n-    /// particular, the subtyping comparison).\n+    /// can be created in the context of this snapshot, but before the\n+    /// snapshot is committed or rolled back, they must be popped\n+    /// (using `pop_skolemized_regions`), so that their numbers can be\n+    /// recycled. Normally you don't have to think about this: you use\n+    /// the APIs in `higher_ranked/mod.rs`, such as\n+    /// `skolemize_late_bound_regions` and `plug_leaks`, which will\n+    /// guide you on this path (ensure that the `SkolemizationMap` is\n+    /// consumed and you are good).  There are also somewhat extensive\n+    /// comments in `higher_ranked/README.md`.\n     ///\n     /// The `snapshot` argument to this function is not really used;\n     /// it's just there to make it explicit which snapshot bounds the\n-    /// skolemized region that results.\n-    pub fn new_skolemized(&self, br: ty::BoundRegion, snapshot: &RegionSnapshot) -> Region {\n+    /// skolemized region that results. It should always be the top-most snapshot.\n+    pub fn push_skolemized(&self, br: ty::BoundRegion, snapshot: &RegionSnapshot) -> Region {\n         assert!(self.in_snapshot());\n         assert!(self.undo_log.borrow()[snapshot.length] == OpenSnapshot);\n \n@@ -390,6 +540,92 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n         ReSkolemized(ty::SkolemizedRegionVid { index: sc }, br)\n     }\n \n+    /// Removes all the edges to/from the skolemized regions that are\n+    /// in `skols`. This is used after a higher-ranked operation\n+    /// completes to remove all trace of the skolemized regions\n+    /// created in that time.\n+    pub fn pop_skolemized(&self,\n+                          skols: &FnvHashSet<ty::Region>,\n+                          snapshot: &RegionSnapshot) {\n+        debug!(\"pop_skolemized_regions(skols={:?})\", skols);\n+\n+        assert!(self.in_snapshot());\n+        assert!(self.undo_log.borrow()[snapshot.length] == OpenSnapshot);\n+        assert!(self.skolemization_count.get() as usize >= skols.len(),\n+                \"popping more skolemized variables than actually exist, \\\n+                 sc now = {}, skols.len = {}\",\n+                self.skolemization_count.get(),\n+                skols.len());\n+\n+        let last_to_pop = self.skolemization_count.get();\n+        let first_to_pop = last_to_pop - (skols.len() as u32);\n+\n+        assert!(first_to_pop >= snapshot.skolemization_count,\n+                \"popping more regions than snapshot contains, \\\n+                 sc now = {}, sc then = {}, skols.len = {}\",\n+                self.skolemization_count.get(),\n+                snapshot.skolemization_count,\n+                skols.len());\n+        debug_assert! {\n+            skols.iter()\n+                 .all(|k| match *k {\n+                     ty::ReSkolemized(index, _) =>\n+                         index.index >= first_to_pop &&\n+                         index.index < last_to_pop,\n+                     _ =>\n+                         false\n+                 }),\n+            \"invalid skolemization keys or keys out of range ({}..{}): {:?}\",\n+            snapshot.skolemization_count,\n+            self.skolemization_count.get(),\n+            skols\n+        }\n+\n+        let mut undo_log = self.undo_log.borrow_mut();\n+\n+        let constraints_to_kill: Vec<usize> =\n+            undo_log.iter()\n+                    .enumerate()\n+                    .rev()\n+                    .filter(|&(_, undo_entry)| kill_constraint(skols, undo_entry))\n+                    .map(|(index, _)| index)\n+                    .collect();\n+\n+        for index in constraints_to_kill {\n+            let undo_entry = mem::replace(&mut undo_log[index], Purged);\n+            self.rollback_undo_entry(undo_entry);\n+        }\n+\n+        self.skolemization_count.set(snapshot.skolemization_count);\n+        return;\n+\n+        fn kill_constraint(skols: &FnvHashSet<ty::Region>,\n+                           undo_entry: &UndoLogEntry)\n+                           -> bool {\n+            match undo_entry {\n+                &AddConstraint(ConstrainVarSubVar(_, _)) =>\n+                    false,\n+                &AddConstraint(ConstrainRegSubVar(a, _)) =>\n+                    skols.contains(&a),\n+                &AddConstraint(ConstrainVarSubReg(_, b)) =>\n+                    skols.contains(&b),\n+                &AddGiven(_, _) =>\n+                    false,\n+                &AddVerify(_) =>\n+                    false,\n+                &AddCombination(_, ref two_regions) =>\n+                    skols.contains(&two_regions.a) ||\n+                    skols.contains(&two_regions.b),\n+                &AddVar(..) |\n+                &OpenSnapshot |\n+                &Purged |\n+                &CommitedSnapshot =>\n+                    false,\n+            }\n+        }\n+\n+    }\n+\n     pub fn new_bound(&self, debruijn: ty::DebruijnIndex) -> Region {\n         // Creates a fresh bound variable for use in GLB computations.\n         // See discussion of GLB computation in the large comment at\n@@ -632,83 +868,30 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n             .collect()\n     }\n \n-    /// Computes all regions that have been related to `r0` in any way since the mark `mark` was\n-    /// made---`r0` itself will be the first entry. This is used when checking whether skolemized\n-    /// regions are being improperly related to other regions.\n-    pub fn tainted(&self, mark: &RegionSnapshot, r0: Region) -> Vec<Region> {\n-        debug!(\"tainted(mark={:?}, r0={:?})\", mark, r0);\n-        let _indenter = indenter();\n+    /// Computes all regions that have been related to `r0` since the\n+    /// mark `mark` was made---`r0` itself will be the first\n+    /// entry. The `directions` parameter controls what kind of\n+    /// relations are considered. For example, one can say that only\n+    /// \"incoming\" edges to `r0` are desired, in which case one will\n+    /// get the set of regions `{r|r <= r0}`. This is used when\n+    /// checking whether skolemized regions are being improperly\n+    /// related to other regions.\n+    pub fn tainted(&self,\n+                   mark: &RegionSnapshot,\n+                   r0: Region,\n+                   directions: TaintDirections)\n+                   -> FnvHashSet<ty::Region> {\n+        debug!(\"tainted(mark={:?}, r0={:?}, directions={:?})\",\n+               mark, r0, directions);\n \n         // `result_set` acts as a worklist: we explore all outgoing\n         // edges and add any new regions we find to result_set.  This\n         // is not a terribly efficient implementation.\n-        let mut result_set = vec![r0];\n-        let mut result_index = 0;\n-        while result_index < result_set.len() {\n-            // nb: can't use usize::range() here because result_set grows\n-            let r = result_set[result_index];\n-            debug!(\"result_index={}, r={:?}\", result_index, r);\n-\n-            for undo_entry in self.undo_log.borrow()[mark.length..].iter() {\n-                match undo_entry {\n-                    &AddConstraint(ConstrainVarSubVar(a, b)) => {\n-                        consider_adding_bidirectional_edges(&mut result_set, r, ReVar(a), ReVar(b));\n-                    }\n-                    &AddConstraint(ConstrainRegSubVar(a, b)) => {\n-                        consider_adding_bidirectional_edges(&mut result_set, r, a, ReVar(b));\n-                    }\n-                    &AddConstraint(ConstrainVarSubReg(a, b)) => {\n-                        consider_adding_bidirectional_edges(&mut result_set, r, ReVar(a), b);\n-                    }\n-                    &AddGiven(a, b) => {\n-                        consider_adding_bidirectional_edges(&mut result_set,\n-                                                            r,\n-                                                            ReFree(a),\n-                                                            ReVar(b));\n-                    }\n-                    &AddVerify(i) => {\n-                        match (*self.verifys.borrow())[i] {\n-                            VerifyRegSubReg(_, a, b) => {\n-                                consider_adding_bidirectional_edges(&mut result_set, r, a, b);\n-                            }\n-                            VerifyGenericBound(_, _, a, ref bound) => {\n-                                bound.for_each_region(&mut |b| {\n-                                    consider_adding_bidirectional_edges(&mut result_set, r, a, b)\n-                                });\n-                            }\n-                        }\n-                    }\n-                    &AddCombination(..) |\n-                    &AddVar(..) |\n-                    &OpenSnapshot |\n-                    &CommitedSnapshot => {}\n-                }\n-            }\n-\n-            result_index += 1;\n-        }\n-\n-        return result_set;\n-\n-        fn consider_adding_bidirectional_edges(result_set: &mut Vec<Region>,\n-                                               r: Region,\n-                                               r1: Region,\n-                                               r2: Region) {\n-            consider_adding_directed_edge(result_set, r, r1, r2);\n-            consider_adding_directed_edge(result_set, r, r2, r1);\n-        }\n-\n-        fn consider_adding_directed_edge(result_set: &mut Vec<Region>,\n-                                         r: Region,\n-                                         r1: Region,\n-                                         r2: Region) {\n-            if r == r1 {\n-                // Clearly, this is potentially inefficient.\n-                if !result_set.iter().any(|x| *x == r2) {\n-                    result_set.push(r2);\n-                }\n-            }\n-        }\n+        let mut taint_set = TaintSet::new(directions, r0);\n+        taint_set.fixed_point(&self.undo_log.borrow()[mark.length..],\n+                              &self.verifys.borrow());\n+        debug!(\"tainted: result={:?}\", taint_set.regions);\n+        return taint_set.into_set();\n     }\n \n     /// This function performs the actual region resolution.  It must be"}, {"sha": "1cfdf73ae8e4a1c56ebe14608b086682cd6c571e", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 16, "deletions": 7, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/11984340bfe93be311eeea9881ae2d1fb8fb0ddb/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11984340bfe93be311eeea9881ae2d1fb8fb0ddb/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=11984340bfe93be311eeea9881ae2d1fb8fb0ddb", "patch": "@@ -182,7 +182,8 @@ pub fn poly_project_and_unify_type<'cx, 'gcx, 'tcx>(\n         let skol_obligation = obligation.with(skol_predicate);\n         match project_and_unify_type(selcx, &skol_obligation) {\n             Ok(result) => {\n-                match infcx.leak_check(false, &skol_map, snapshot) {\n+                let span = obligation.cause.span;\n+                match infcx.leak_check(false, span, &skol_map, snapshot) {\n                     Ok(()) => Ok(infcx.plug_leaks(skol_map, snapshot, &result)),\n                     Err(e) => Err(MismatchedProjectionTypes { err: e }),\n                 }\n@@ -404,7 +405,11 @@ fn opt_normalize_projection_type<'a, 'b, 'gcx, 'tcx>(\n     depth: usize)\n     -> Option<NormalizedTy<'tcx>>\n {\n-    debug!(\"normalize_projection_type(\\\n+    let infcx = selcx.infcx();\n+\n+    let projection_ty = infcx.resolve_type_vars_if_possible(&projection_ty);\n+\n+    debug!(\"opt_normalize_projection_type(\\\n            projection_ty={:?}, \\\n            depth={})\",\n            projection_ty,\n@@ -418,7 +423,8 @@ fn opt_normalize_projection_type<'a, 'b, 'gcx, 'tcx>(\n             // an impl, where-clause etc) and hence we must\n             // re-normalize it\n \n-            debug!(\"normalize_projection_type: projected_ty={:?} depth={} obligations={:?}\",\n+            debug!(\"opt_normalize_projection_type: \\\n+                    projected_ty={:?} depth={} obligations={:?}\",\n                    projected_ty,\n                    depth,\n                    obligations);\n@@ -427,7 +433,8 @@ fn opt_normalize_projection_type<'a, 'b, 'gcx, 'tcx>(\n                 let mut normalizer = AssociatedTypeNormalizer::new(selcx, cause, depth+1);\n                 let normalized_ty = normalizer.fold(&projected_ty);\n \n-                debug!(\"normalize_projection_type: normalized_ty={:?} depth={}\",\n+                debug!(\"opt_normalize_projection_type: \\\n+                        normalized_ty={:?} depth={}\",\n                        normalized_ty,\n                        depth);\n \n@@ -444,19 +451,21 @@ fn opt_normalize_projection_type<'a, 'b, 'gcx, 'tcx>(\n             }\n         }\n         Ok(ProjectedTy::NoProgress(projected_ty)) => {\n-            debug!(\"normalize_projection_type: projected_ty={:?} no progress\",\n+            debug!(\"opt_normalize_projection_type: \\\n+                    projected_ty={:?} no progress\",\n                    projected_ty);\n             Some(Normalized {\n                 value: projected_ty,\n                 obligations: vec!()\n             })\n         }\n         Err(ProjectionTyError::TooManyCandidates) => {\n-            debug!(\"normalize_projection_type: too many candidates\");\n+            debug!(\"opt_normalize_projection_type: \\\n+                    too many candidates\");\n             None\n         }\n         Err(ProjectionTyError::TraitSelectionError(_)) => {\n-            debug!(\"normalize_projection_type: ERROR\");\n+            debug!(\"opt_normalize_projection_type: ERROR\");\n             // if we got an error processing the `T as Trait` part,\n             // just return `ty::err` but add the obligation `T :\n             // Trait`, which when processed will cause the error to be"}, {"sha": "7a20b43b8f2e69a470c67810c95a1be71a48a819", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 24, "deletions": 8, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/11984340bfe93be311eeea9881ae2d1fb8fb0ddb/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11984340bfe93be311eeea9881ae2d1fb8fb0ddb/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=11984340bfe93be311eeea9881ae2d1fb8fb0ddb", "patch": "@@ -46,6 +46,7 @@ use rustc_data_structures::snapshot_vec::{SnapshotVecDelegate, SnapshotVec};\n use std::cell::RefCell;\n use std::fmt;\n use std::marker::PhantomData;\n+use std::mem;\n use std::rc::Rc;\n use syntax::abi::Abi;\n use hir;\n@@ -1237,6 +1238,9 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                                                    skol_trait_predicate.trait_ref.clone(),\n                                                    &skol_map,\n                                                    snapshot);\n+\n+                self.infcx.pop_skolemized(skol_map, snapshot);\n+\n                 assert!(result);\n                 true\n             }\n@@ -1263,7 +1267,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             Err(_) => { return false; }\n         }\n \n-        self.infcx.leak_check(false, skol_map, snapshot).is_ok()\n+        self.infcx.leak_check(false, obligation.cause.span, skol_map, snapshot).is_ok()\n     }\n \n     /// Given an obligation like `<SomeTrait for T>`, search the obligations that the caller\n@@ -1422,9 +1426,16 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             self.tcx(),\n             obligation.predicate.0.trait_ref.self_ty(),\n             |impl_def_id| {\n-                self.probe(|this, snapshot| {\n-                    if let Ok(_) = this.match_impl(impl_def_id, obligation, snapshot) {\n-                        candidates.vec.push(ImplCandidate(impl_def_id));\n+                self.probe(|this, snapshot| { /* [1] */\n+                    match this.match_impl(impl_def_id, obligation, snapshot) {\n+                        Ok(skol_map) => {\n+                            candidates.vec.push(ImplCandidate(impl_def_id));\n+\n+                            // NB: we can safely drop the skol map\n+                            // since we are in a probe [1]\n+                            mem::drop(skol_map);\n+                        }\n+                        Err(_) => { }\n                     }\n                 });\n             }\n@@ -1509,9 +1520,11 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             return;\n         }\n \n-        self.probe(|this, snapshot| {\n-            let (self_ty, _) =\n-                this.infcx().skolemize_late_bound_regions(&obligation.self_ty(), snapshot);\n+        self.probe(|this, _snapshot| {\n+            // the code below doesn't care about regions, and the\n+            // self-ty here doesn't escape this probe, so just erase\n+            // any LBR.\n+            let self_ty = this.tcx().erase_late_bound_regions(&obligation.self_ty());\n             let poly_trait_ref = match self_ty.sty {\n                 ty::TyTrait(ref data) => {\n                     match this.tcx().lang_items.to_builtin_kind(obligation.predicate.def_id()) {\n@@ -2710,7 +2723,10 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             })?;\n         self.inferred_obligations.extend(obligations);\n \n-        if let Err(e) = self.infcx.leak_check(false, &skol_map, snapshot) {\n+        if let Err(e) = self.infcx.leak_check(false,\n+                                              obligation.cause.span,\n+                                              &skol_map,\n+                                              snapshot) {\n             debug!(\"match_impl: failed leak check due to `{}`\", e);\n             return Err(());\n         }"}, {"sha": "a1eb899b3a0648d3d5e634e21d35fc124d0f3140", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/11984340bfe93be311eeea9881ae2d1fb8fb0ddb/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11984340bfe93be311eeea9881ae2d1fb8fb0ddb/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=11984340bfe93be311eeea9881ae2d1fb8fb0ddb", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use middle::free_region::FreeRegionMap;\n-use rustc::infer::{self, InferOk, TypeOrigin};\n+use rustc::infer::{self, InferOk, InferResult, TypeOrigin};\n use rustc::ty;\n use rustc::traits::{self, ProjectionMode};\n use rustc::ty::subst::{self, Subst, Substs, VecPerParamSpace};"}, {"sha": "e3077eb00406feec3f48110a1497587cceb0c41f", "filename": "src/test/compile-fail/hr-subtype.rs", "status": "added", "additions": 116, "deletions": 0, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/11984340bfe93be311eeea9881ae2d1fb8fb0ddb/src%2Ftest%2Fcompile-fail%2Fhr-subtype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11984340bfe93be311eeea9881ae2d1fb8fb0ddb/src%2Ftest%2Fcompile-fail%2Fhr-subtype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fhr-subtype.rs?ref=11984340bfe93be311eeea9881ae2d1fb8fb0ddb", "patch": "@@ -0,0 +1,116 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Targeted tests for the higher-ranked subtyping code.\n+\n+#![feature(rustc_attrs)]\n+#![allow(dead_code)]\n+\n+// revisions: bound_a_vs_bound_a\n+// revisions: bound_a_vs_bound_b\n+// revisions: bound_inv_a_vs_bound_inv_b\n+// revisions: bound_co_a_vs_bound_co_b\n+// revisions: bound_a_vs_free_x\n+// revisions: free_x_vs_free_x\n+// revisions: free_x_vs_free_y\n+// revisions: free_inv_x_vs_free_inv_y\n+// revisions: bound_a_b_vs_bound_a\n+// revisions: bound_co_a_b_vs_bound_co_a\n+// revisions: bound_contra_a_contra_b_ret_co_a\n+// revisions: bound_co_a_co_b_ret_contra_a\n+// revisions: bound_inv_a_b_vs_bound_inv_a\n+// revisions: bound_a_b_ret_a_vs_bound_a_ret_a\n+\n+fn gimme<T>(_: Option<T>) { }\n+\n+struct Inv<'a> { x: *mut &'a u32 }\n+\n+struct Co<'a> { x: fn(&'a u32) }\n+\n+struct Contra<'a> { x: &'a u32 }\n+\n+macro_rules! check {\n+    ($rev:ident: ($t1:ty, $t2:ty)) => {\n+        #[cfg($rev)]\n+        fn subtype<'x,'y:'x,'z:'y>() {\n+            gimme::<$t2>(None::<$t1>);\n+            //[free_inv_x_vs_free_inv_y]~^ ERROR mismatched types\n+        }\n+\n+        #[cfg($rev)]\n+        fn supertype<'x,'y:'x,'z:'y>() {\n+            gimme::<$t1>(None::<$t2>);\n+            //[bound_a_vs_free_x]~^ ERROR mismatched types\n+            //[free_x_vs_free_y]~^^ ERROR mismatched types\n+            //[bound_inv_a_b_vs_bound_inv_a]~^^^ ERROR mismatched types\n+            //[bound_a_b_ret_a_vs_bound_a_ret_a]~^^^^ ERROR mismatched types\n+            //[free_inv_x_vs_free_inv_y]~^^^^^ ERROR mismatched types\n+        }\n+    }\n+}\n+\n+// If both have bound regions, they are equivalent, regardless of\n+// variant.\n+check! { bound_a_vs_bound_a: (for<'a> fn(&'a u32),\n+                              for<'a> fn(&'a u32)) }\n+check! { bound_a_vs_bound_b: (for<'a> fn(&'a u32),\n+                              for<'b> fn(&'b u32)) }\n+check! { bound_inv_a_vs_bound_inv_b: (for<'a> fn(Inv<'a>),\n+                                      for<'b> fn(Inv<'b>)) }\n+check! { bound_co_a_vs_bound_co_b: (for<'a> fn(Co<'a>),\n+                                    for<'b> fn(Co<'b>)) }\n+\n+// Bound is a subtype of free.\n+check! { bound_a_vs_free_x: (for<'a> fn(&'a u32),\n+                             fn(&'x u32)) }\n+\n+// Two free regions are relatable if subtyping holds.\n+check! { free_x_vs_free_x: (fn(&'x u32),\n+                            fn(&'x u32)) }\n+check! { free_x_vs_free_y: (fn(&'x u32),\n+                            fn(&'y u32)) }\n+check! { free_inv_x_vs_free_inv_y: (fn(Inv<'x>),\n+                                    fn(Inv<'y>)) }\n+\n+// Somewhat surprisingly, a fn taking two distinct bound lifetimes and\n+// a fn taking one bound lifetime can be interchangable, but only if\n+// we are co- or contra-variant with respect to both lifetimes.\n+//\n+// The reason is:\n+// - if we are covariant, then 'a and 'b can be set to the call-site\n+//   intersection;\n+// - if we are contravariant, then 'a can be inferred to 'static.\n+check! { bound_a_b_vs_bound_a: (for<'a,'b> fn(&'a u32, &'b u32),\n+                                for<'a>    fn(&'a u32, &'a u32)) }\n+check! { bound_co_a_b_vs_bound_co_a: (for<'a,'b> fn(Co<'a>, Co<'b>),\n+                                      for<'a>    fn(Co<'a>, Co<'a>)) }\n+check! { bound_contra_a_contra_b_ret_co_a: (for<'a,'b> fn(Contra<'a>, Contra<'b>) -> Co<'a>,\n+                                            for<'a>    fn(Contra<'a>, Contra<'a>) -> Co<'a>) }\n+check! { bound_co_a_co_b_ret_contra_a: (for<'a,'b> fn(Co<'a>, Co<'b>) -> Contra<'a>,\n+                                        for<'a>    fn(Co<'a>, Co<'a>) -> Contra<'a>) }\n+\n+// If we make those lifetimes invariant, then the two types are not interchangable.\n+check! { bound_inv_a_b_vs_bound_inv_a: (for<'a,'b> fn(Inv<'a>, Inv<'b>),\n+                                        for<'a>    fn(Inv<'a>, Inv<'a>)) }\n+check! { bound_a_b_ret_a_vs_bound_a_ret_a: (for<'a,'b> fn(&'a u32, &'b u32) -> &'a u32,\n+                                            for<'a>    fn(&'a u32, &'a u32) -> &'a u32) }\n+\n+#[rustc_error]\n+fn main() {\n+//[bound_a_vs_bound_a]~^ ERROR compilation successful\n+//[bound_a_vs_bound_b]~^^ ERROR compilation successful\n+//[bound_inv_a_vs_bound_inv_b]~^^^ ERROR compilation successful\n+//[bound_co_a_vs_bound_co_b]~^^^^ ERROR compilation successful\n+//[free_x_vs_free_x]~^^^^^ ERROR compilation successful\n+//[bound_a_b_vs_bound_a]~^^^^^^ ERROR compilation successful\n+//[bound_co_a_b_vs_bound_co_a]~^^^^^^^ ERROR compilation successful\n+//[bound_contra_a_contra_b_ret_co_a]~^^^^^^^^ ERROR compilation successful\n+//[bound_co_a_co_b_ret_contra_a]~^^^^^^^^^ ERROR compilation successful\n+}"}, {"sha": "989fc5ea954698820c68791ec39735b0e43b32b8", "filename": "src/test/compile-fail/regions-close-over-type-parameter-1.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/11984340bfe93be311eeea9881ae2d1fb8fb0ddb/src%2Ftest%2Fcompile-fail%2Fregions-close-over-type-parameter-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11984340bfe93be311eeea9881ae2d1fb8fb0ddb/src%2Ftest%2Fcompile-fail%2Fregions-close-over-type-parameter-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-close-over-type-parameter-1.rs?ref=11984340bfe93be311eeea9881ae2d1fb8fb0ddb", "patch": "@@ -28,8 +28,7 @@ fn make_object2<'a,A:SomeTrait+'a>(v: A) -> Box<SomeTrait+'a> {\n \n fn make_object3<'a,'b,A:SomeTrait+'a>(v: A) -> Box<SomeTrait+'b> {\n     box v as Box<SomeTrait+'b>\n-        //~^ ERROR the parameter type `A` may not live long enough\n-        //~^^ ERROR the parameter type `A` may not live long enough\n+        //~^ ERROR E0478\n }\n \n fn main() { }"}, {"sha": "eb04514271c7532891401dcbaf8e7e82f9307aa3", "filename": "src/test/run-pass/coherence-subtyping.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/11984340bfe93be311eeea9881ae2d1fb8fb0ddb/src%2Ftest%2Frun-pass%2Fcoherence-subtyping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11984340bfe93be311eeea9881ae2d1fb8fb0ddb/src%2Ftest%2Frun-pass%2Fcoherence-subtyping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcoherence-subtyping.rs?ref=11984340bfe93be311eeea9881ae2d1fb8fb0ddb", "patch": "@@ -15,10 +15,10 @@ trait Contravariant {\n     fn foo(&self) { }\n }\n \n-impl Contravariant for for<'a,'b> fn(&'a u8, &'b u8) {\n+impl Contravariant for for<'a,'b> fn(&'a u8, &'b u8) -> &'a u8 {\n }\n \n-impl Contravariant for for<'a> fn(&'a u8, &'a u8) {\n+impl Contravariant for for<'a> fn(&'a u8, &'a u8) -> &'a u8 {\n }\n \n ///////////////////////////////////////////////////////////////////////////\n@@ -27,10 +27,10 @@ trait Covariant {\n     fn foo(&self) { }\n }\n \n-impl Covariant for for<'a,'b> fn(&'a u8, &'b u8) {\n+impl Covariant for for<'a,'b> fn(&'a u8, &'b u8) -> &'a u8 {\n }\n \n-impl Covariant for for<'a> fn(&'a u8, &'a u8) {\n+impl Covariant for for<'a> fn(&'a u8, &'a u8) -> &'a u8 {\n }\n \n ///////////////////////////////////////////////////////////////////////////\n@@ -39,10 +39,10 @@ trait Invariant {\n     fn foo(&self) { }\n }\n \n-impl Invariant for for<'a,'b> fn(&'a u8, &'b u8) {\n+impl Invariant for for<'a,'b> fn(&'a u8, &'b u8) -> &'a u8 {\n }\n \n-impl Invariant for for<'a> fn(&'a u8, &'a u8) {\n+impl Invariant for for<'a> fn(&'a u8, &'a u8) -> &'a u8 {\n }\n \n fn main() { }"}]}