{"sha": "1d930483247bac3dd7df3470abd5432d198fe755", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFkOTMwNDgzMjQ3YmFjM2RkN2RmMzQ3MGFiZDU0MzJkMTk4ZmU3NTU=", "commit": {"author": {"name": "Gus Wynn", "email": "guswynn@gmail.com", "date": "2020-09-15T16:56:17Z"}, "committer": {"name": "Gus Wynn", "email": "guswynn@gmail.com", "date": "2020-09-16T17:13:11Z"}, "message": "give better suggestion when matching a const range", "tree": {"sha": "205871ca9a92d49cd2ecff824ef663a2982cf568", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/205871ca9a92d49cd2ecff824ef663a2982cf568"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1d930483247bac3dd7df3470abd5432d198fe755", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1d930483247bac3dd7df3470abd5432d198fe755", "html_url": "https://github.com/rust-lang/rust/commit/1d930483247bac3dd7df3470abd5432d198fe755", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1d930483247bac3dd7df3470abd5432d198fe755/comments", "author": {"login": "guswynn", "id": 5404303, "node_id": "MDQ6VXNlcjU0MDQzMDM=", "avatar_url": "https://avatars.githubusercontent.com/u/5404303?v=4", "gravatar_id": "", "url": "https://api.github.com/users/guswynn", "html_url": "https://github.com/guswynn", "followers_url": "https://api.github.com/users/guswynn/followers", "following_url": "https://api.github.com/users/guswynn/following{/other_user}", "gists_url": "https://api.github.com/users/guswynn/gists{/gist_id}", "starred_url": "https://api.github.com/users/guswynn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/guswynn/subscriptions", "organizations_url": "https://api.github.com/users/guswynn/orgs", "repos_url": "https://api.github.com/users/guswynn/repos", "events_url": "https://api.github.com/users/guswynn/events{/privacy}", "received_events_url": "https://api.github.com/users/guswynn/received_events", "type": "User", "site_admin": false}, "committer": {"login": "guswynn", "id": 5404303, "node_id": "MDQ6VXNlcjU0MDQzMDM=", "avatar_url": "https://avatars.githubusercontent.com/u/5404303?v=4", "gravatar_id": "", "url": "https://api.github.com/users/guswynn", "html_url": "https://github.com/guswynn", "followers_url": "https://api.github.com/users/guswynn/followers", "following_url": "https://api.github.com/users/guswynn/following{/other_user}", "gists_url": "https://api.github.com/users/guswynn/gists{/gist_id}", "starred_url": "https://api.github.com/users/guswynn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/guswynn/subscriptions", "organizations_url": "https://api.github.com/users/guswynn/orgs", "repos_url": "https://api.github.com/users/guswynn/repos", "events_url": "https://api.github.com/users/guswynn/events{/privacy}", "received_events_url": "https://api.github.com/users/guswynn/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5fae56971d8487088c0099c82c0a5ce1638b5f62", "url": "https://api.github.com/repos/rust-lang/rust/commits/5fae56971d8487088c0099c82c0a5ce1638b5f62", "html_url": "https://github.com/rust-lang/rust/commit/5fae56971d8487088c0099c82c0a5ce1638b5f62"}], "stats": {"total": 84, "additions": 73, "deletions": 11}, "files": [{"sha": "3b1559dfcf5ef34d1396031c58d080321142215f", "filename": "compiler/rustc_typeck/src/check/pat.rs", "status": "modified", "additions": 44, "deletions": 9, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/1d930483247bac3dd7df3470abd5432d198fe755/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d930483247bac3dd7df3470abd5432d198fe755/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fpat.rs?ref=1d930483247bac3dd7df3470abd5432d198fe755", "patch": "@@ -772,12 +772,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         );\n                     }\n                     _ => {\n-                        let const_def_id = match pat_ty.kind() {\n+                        let (type_def_id, item_def_id) = match pat_ty.kind() {\n                             Adt(def, _) => match res {\n-                                Res::Def(DefKind::Const, _) => Some(def.did),\n-                                _ => None,\n+                                Res::Def(DefKind::Const, def_id) => (Some(def.did), Some(def_id)),\n+                                _ => (None, None),\n                             },\n-                            _ => None,\n+                            _ => (None, None),\n                         };\n \n                         let ranges = &[\n@@ -788,11 +788,46 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             self.tcx.lang_items().range_inclusive_struct(),\n                             self.tcx.lang_items().range_to_inclusive_struct(),\n                         ];\n-                        if const_def_id != None && ranges.contains(&const_def_id) {\n-                            let msg = \"constants only support matching by type, \\\n-                                if you meant to match against a range of values, \\\n-                                consider using a range pattern like `min ..= max` in the match block\";\n-                            e.note(msg);\n+                        if type_def_id != None && ranges.contains(&type_def_id) {\n+                            let generic_message = match item_def_id {\n+                                Some(def_id) => match self.tcx.hir().get_if_local(def_id) {\n+                                    Some(hir::Node::Item(hir::Item {\n+                                        kind: hir::ItemKind::Const(_, body_id),\n+                                        ..\n+                                    })) => match self.tcx.hir().get(body_id.hir_id) {\n+                                        hir::Node::Expr(expr) => {\n+                                            if hir::is_range_literal(expr) {\n+                                                let span = self.tcx.hir().span(body_id.hir_id);\n+                                                if let Ok(snip) =\n+                                                    self.tcx.sess.source_map().span_to_snippet(span)\n+                                                {\n+                                                    e.span_suggestion_verbose(\n+                                                    span,\n+                                                    \"you may want to move the range into the match block\", \n+                                                    snip,\n+                                                    Applicability::MachineApplicable\n+                                                );\n+                                                    false\n+                                                } else {\n+                                                    true\n+                                                }\n+                                            } else {\n+                                                true\n+                                            }\n+                                        }\n+                                        _ => true,\n+                                    },\n+                                    _ => true,\n+                                },\n+                                _ => true,\n+                            };\n+\n+                            if generic_message {\n+                                let msg = \"constants only support matching by type, \\\n+                                    if you meant to match against a range of values, \\\n+                                    consider using a range pattern like `min ..= max` in the match block\";\n+                                e.note(msg);\n+                            }\n                         } else {\n                             let msg = \"introduce a new binding instead\";\n                             let sugg = format!(\"other_{}\", ident.as_str().to_lowercase());"}, {"sha": "d9790d2b56e2895fed4a1ec169ed63fd8bfa07f1", "filename": "src/test/ui/issues/issue-76191.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1d930483247bac3dd7df3470abd5432d198fe755/src%2Ftest%2Fui%2Fissues%2Fissue-76191.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d930483247bac3dd7df3470abd5432d198fe755/src%2Ftest%2Fui%2Fissues%2Fissue-76191.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-76191.rs?ref=1d930483247bac3dd7df3470abd5432d198fe755", "patch": "@@ -2,13 +2,18 @@\n #![allow(non_snake_case)]\n \n use std::ops::RangeInclusive;\n+\n const RANGE: RangeInclusive<i32> = 0..=255;\n \n+const RANGE2: RangeInclusive<i32> = panic!();\n+\n fn main() {\n     let n: i32 = 1;\n     match n {\n         RANGE => {}\n         //~^ ERROR mismatched types\n+        RANGE2 => {}\n+        //~^ ERROR mismatched types\n         _ => {}\n     }\n }"}, {"sha": "61f4be81f43a45d182a7c54ea8056b218a295e25", "filename": "src/test/ui/issues/issue-76191.stderr", "status": "modified", "additions": 24, "deletions": 2, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/1d930483247bac3dd7df3470abd5432d198fe755/src%2Ftest%2Fui%2Fissues%2Fissue-76191.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1d930483247bac3dd7df3470abd5432d198fe755/src%2Ftest%2Fui%2Fissues%2Fissue-76191.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-76191.stderr?ref=1d930483247bac3dd7df3470abd5432d198fe755", "patch": "@@ -1,5 +1,5 @@\n error[E0308]: mismatched types\n-  --> $DIR/issue-76191.rs:10:9\n+  --> $DIR/issue-76191.rs:13:9\n    |\n LL | const RANGE: RangeInclusive<i32> = 0..=255;\n    | ------------------------------------------- constant defined here\n@@ -14,8 +14,30 @@ LL |         RANGE => {}\n    |\n    = note: expected type `i32`\n             found struct `RangeInclusive<i32>`\n+help: you may want to move the range into the match block\n+   |\n+LL | const RANGE: RangeInclusive<i32> = 0..=255;\n+   |                                    ^^^^^^^\n+\n+error[E0308]: mismatched types\n+  --> $DIR/issue-76191.rs:15:9\n+   |\n+LL | const RANGE2: RangeInclusive<i32> = panic!();\n+   | --------------------------------------------- constant defined here\n+...\n+LL |     match n {\n+   |           - this expression has type `i32`\n+...\n+LL |         RANGE2 => {}\n+   |         ^^^^^^\n+   |         |\n+   |         expected `i32`, found struct `RangeInclusive`\n+   |         `RANGE2` is interpreted as a constant, not a new binding\n+   |\n+   = note: expected type `i32`\n+            found struct `RangeInclusive<i32>`\n    = note: constants only support matching by type, if you meant to match against a range of values, consider using a range pattern like `min ..= max` in the match block\n \n-error: aborting due to previous error\n+error: aborting due to 2 previous errors\n \n For more information about this error, try `rustc --explain E0308`."}]}