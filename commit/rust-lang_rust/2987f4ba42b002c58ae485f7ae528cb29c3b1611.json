{"sha": "2987f4ba42b002c58ae485f7ae528cb29c3b1611", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI5ODdmNGJhNDJiMDAyYzU4YWU0ODVmN2FlNTI4Y2IyOWMzYjE2MTE=", "commit": {"author": {"name": "Ellen", "email": "supbscripter@gmail.com", "date": "2021-09-06T01:27:41Z"}, "committer": {"name": "Ellen", "email": "supbscripter@gmail.com", "date": "2021-09-09T00:32:03Z"}, "message": "WIP state", "tree": {"sha": "5e2b41f111b7a18e2fcd5dbc17a15bc8589d6fb7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5e2b41f111b7a18e2fcd5dbc17a15bc8589d6fb7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2987f4ba42b002c58ae485f7ae528cb29c3b1611", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2987f4ba42b002c58ae485f7ae528cb29c3b1611", "html_url": "https://github.com/rust-lang/rust/commit/2987f4ba42b002c58ae485f7ae528cb29c3b1611", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2987f4ba42b002c58ae485f7ae528cb29c3b1611/comments", "author": {"login": "BoxyUwU", "id": 21149742, "node_id": "MDQ6VXNlcjIxMTQ5NzQy", "avatar_url": "https://avatars.githubusercontent.com/u/21149742?v=4", "gravatar_id": "", "url": "https://api.github.com/users/BoxyUwU", "html_url": "https://github.com/BoxyUwU", "followers_url": "https://api.github.com/users/BoxyUwU/followers", "following_url": "https://api.github.com/users/BoxyUwU/following{/other_user}", "gists_url": "https://api.github.com/users/BoxyUwU/gists{/gist_id}", "starred_url": "https://api.github.com/users/BoxyUwU/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/BoxyUwU/subscriptions", "organizations_url": "https://api.github.com/users/BoxyUwU/orgs", "repos_url": "https://api.github.com/users/BoxyUwU/repos", "events_url": "https://api.github.com/users/BoxyUwU/events{/privacy}", "received_events_url": "https://api.github.com/users/BoxyUwU/received_events", "type": "User", "site_admin": false}, "committer": {"login": "BoxyUwU", "id": 21149742, "node_id": "MDQ6VXNlcjIxMTQ5NzQy", "avatar_url": "https://avatars.githubusercontent.com/u/21149742?v=4", "gravatar_id": "", "url": "https://api.github.com/users/BoxyUwU", "html_url": "https://github.com/BoxyUwU", "followers_url": "https://api.github.com/users/BoxyUwU/followers", "following_url": "https://api.github.com/users/BoxyUwU/following{/other_user}", "gists_url": "https://api.github.com/users/BoxyUwU/gists{/gist_id}", "starred_url": "https://api.github.com/users/BoxyUwU/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/BoxyUwU/subscriptions", "organizations_url": "https://api.github.com/users/BoxyUwU/orgs", "repos_url": "https://api.github.com/users/BoxyUwU/repos", "events_url": "https://api.github.com/users/BoxyUwU/events{/privacy}", "received_events_url": "https://api.github.com/users/BoxyUwU/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "97032a6dfacdd3548e4bff98c90a6b3875a14077", "url": "https://api.github.com/repos/rust-lang/rust/commits/97032a6dfacdd3548e4bff98c90a6b3875a14077", "html_url": "https://github.com/rust-lang/rust/commit/97032a6dfacdd3548e4bff98c90a6b3875a14077"}], "stats": {"total": 387, "additions": 160, "deletions": 227}, "files": [{"sha": "e75f084e79e21b26fa56670636a306d693274c34", "filename": "compiler/rustc_middle/src/mir/abstract_const.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2987f4ba42b002c58ae485f7ae528cb29c3b1611/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fabstract_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2987f4ba42b002c58ae485f7ae528cb29c3b1611/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fabstract_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fabstract_const.rs?ref=2987f4ba42b002c58ae485f7ae528cb29c3b1611", "patch": "@@ -17,6 +17,7 @@ pub enum Node<'tcx> {\n     Binop(mir::BinOp, NodeId, NodeId),\n     UnaryOp(mir::UnOp, NodeId),\n     FunctionCall(NodeId, &'tcx [NodeId]),\n+    Block(&'tcx [NodeId], Option<NodeId>),\n     Cast(CastKind, NodeId, Ty<'tcx>),\n }\n "}, {"sha": "390ce59cb489c6abd5f6f59ee8ba8d270a78b0b5", "filename": "compiler/rustc_mir_build/src/build/mod.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2987f4ba42b002c58ae485f7ae528cb29c3b1611/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2987f4ba42b002c58ae485f7ae528cb29c3b1611/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs?ref=2987f4ba42b002c58ae485f7ae528cb29c3b1611", "patch": "@@ -28,6 +28,7 @@ crate fn mir_built<'tcx>(\n     if let Some(def) = def.try_upgrade(tcx) {\n         return tcx.mir_built(def);\n     }\n+    debug!(\"mir_built: def={:?}\", def);\n \n     let mut body = mir_build(tcx, def);\n     if def.const_param_did.is_some() {\n@@ -40,17 +41,20 @@ crate fn mir_built<'tcx>(\n \n /// Construct the MIR for a given `DefId`.\n fn mir_build(tcx: TyCtxt<'_>, def: ty::WithOptConstParam<LocalDefId>) -> Body<'_> {\n+    debug!(\"mir_build: def={:?}\", def);\n     let id = tcx.hir().local_def_id_to_hir_id(def.did);\n     let body_owner_kind = tcx.hir().body_owner_kind(id);\n     let typeck_results = tcx.typeck_opt_const_arg(def);\n \n     // Ensure unsafeck is ran before we steal the THIR.\n     match def {\n         ty::WithOptConstParam { did, const_param_did: Some(const_param_did) } => {\n-            tcx.ensure().thir_check_unsafety_for_const_arg((did, const_param_did))\n+            tcx.ensure().thir_check_unsafety_for_const_arg((did, const_param_did));\n+            tcx.ensure().mir_abstract_const_of_const_arg((did, const_param_did));\n         }\n         ty::WithOptConstParam { did, const_param_did: None } => {\n-            tcx.ensure().thir_check_unsafety(did)\n+            tcx.ensure().thir_check_unsafety(did);\n+            tcx.ensure().mir_abstract_const(did);\n         }\n     }\n "}, {"sha": "70a5a9286b0b3c7cf93951eba51e256f6313a34c", "filename": "compiler/rustc_mir_build/src/thir/cx/expr.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2987f4ba42b002c58ae485f7ae528cb29c3b1611/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2987f4ba42b002c58ae485f7ae528cb29c3b1611/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs?ref=2987f4ba42b002c58ae485f7ae528cb29c3b1611", "patch": "@@ -149,7 +149,9 @@ impl<'tcx> Cx<'tcx> {\n     }\n \n     fn make_mirror_unadjusted(&mut self, expr: &'tcx hir::Expr<'tcx>) -> Expr<'tcx> {\n+        debug!(\"Expr::make_mirror_unadjusted: expr={:?}\", expr);\n         let expr_ty = self.typeck_results().expr_ty(expr);\n+        debug!(\"Expr::make_mirror_unadjusted: expr_ty={:?}\", expr_ty);\n         let temp_lifetime = self.region_scope_tree.temporary_scope(expr.hir_id.local_id);\n \n         let kind = match expr.kind {\n@@ -762,6 +764,7 @@ impl<'tcx> Cx<'tcx> {\n             hir::ExprKind::Err => unreachable!(),\n         };\n \n+        debug!(\"Expr::make_mirror_unadjusted: finish\");\n         Expr { temp_lifetime, ty: expr_ty, span: expr.span, kind }\n     }\n "}, {"sha": "5310efbccd655d2e0ad3569e02ecc64f5c3e7e29", "filename": "compiler/rustc_mir_build/src/thir/cx/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2987f4ba42b002c58ae485f7ae528cb29c3b1611/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2987f4ba42b002c58ae485f7ae528cb29c3b1611/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fmod.rs?ref=2987f4ba42b002c58ae485f7ae528cb29c3b1611", "patch": "@@ -20,6 +20,7 @@ crate fn thir_body<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     owner_def: ty::WithOptConstParam<LocalDefId>,\n ) -> (&'tcx Steal<Thir<'tcx>>, ExprId) {\n+    debug!(\"thir_body: {:?}\", owner_def);\n     let hir = tcx.hir();\n     let body = hir.body(hir.body_owned_by(hir.local_def_id_to_hir_id(owner_def.did)));\n     let mut cx = Cx::new(tcx, owner_def);"}, {"sha": "26e1c3e7b8cf4c0d5fd9d37314345061a41bd948", "filename": "compiler/rustc_privacy/src/lib.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2987f4ba42b002c58ae485f7ae528cb29c3b1611/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2987f4ba42b002c58ae485f7ae528cb29c3b1611/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Flib.rs?ref=2987f4ba42b002c58ae485f7ae528cb29c3b1611", "patch": "@@ -159,9 +159,10 @@ where\n                 self.visit_const(leaf)\n             }\n             ACNode::Cast(_, _, ty) => self.visit_ty(ty),\n-            ACNode::Binop(..) | ACNode::UnaryOp(..) | ACNode::FunctionCall(_, _) => {\n-                ControlFlow::CONTINUE\n-            }\n+            ACNode::Block(_, _)\n+            | ACNode::Binop(..)\n+            | ACNode::UnaryOp(..)\n+            | ACNode::FunctionCall(_, _) => ControlFlow::CONTINUE,\n         })\n     }\n "}, {"sha": "4e11fefdc81f3b17dff6c7257a28129b1cd9055b", "filename": "compiler/rustc_trait_selection/src/traits/const_evaluatable.rs", "status": "modified", "additions": 141, "deletions": 219, "changes": 360, "blob_url": "https://github.com/rust-lang/rust/blob/2987f4ba42b002c58ae485f7ae528cb29c3b1611/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2987f4ba42b002c58ae485f7ae528cb29c3b1611/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs?ref=2987f4ba42b002c58ae485f7ae528cb29c3b1611", "patch": "@@ -8,14 +8,15 @@\n //! In this case we try to build an abstract representation of this constant using\n //! `mir_abstract_const` which can then be checked for structural equality with other\n //! generic constants mentioned in the `caller_bounds` of the current environment.\n+use rustc_data_structures::sync::Lrc;\n use rustc_errors::ErrorReported;\n use rustc_hir::def::DefKind;\n-use rustc_index::bit_set::BitSet;\n use rustc_index::vec::IndexVec;\n use rustc_infer::infer::InferCtxt;\n+use rustc_middle::mir;\n use rustc_middle::mir::abstract_const::{Node, NodeId, NotConstEvaluatable};\n use rustc_middle::mir::interpret::ErrorHandled;\n-use rustc_middle::mir::{self, Rvalue, StatementKind, TerminatorKind};\n+use rustc_middle::thir;\n use rustc_middle::ty::subst::{Subst, SubstsRef};\n use rustc_middle::ty::{self, TyCtxt, TypeFoldable};\n use rustc_session::lint;\n@@ -101,9 +102,10 @@ pub fn is_const_evaluatable<'cx, 'tcx>(\n \n                         ControlFlow::CONTINUE\n                     }\n-                    Node::Binop(_, _, _) | Node::UnaryOp(_, _) | Node::FunctionCall(_, _) => {\n-                        ControlFlow::CONTINUE\n-                    }\n+                    Node::Block(_, _)\n+                    | Node::Binop(_, _, _)\n+                    | Node::UnaryOp(_, _)\n+                    | Node::FunctionCall(_, _) => ControlFlow::CONTINUE,\n                 });\n \n                 match failure_kind {\n@@ -232,26 +234,27 @@ struct WorkNode<'tcx> {\n \n struct AbstractConstBuilder<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n-    body: &'a mir::Body<'tcx>,\n+    body_id: thir::ExprId,\n+    body: Lrc<&'a thir::Thir<'tcx>>,\n     /// The current WIP node tree.\n     ///\n     /// We require all nodes to be used in the final abstract const,\n     /// so we store this here. Note that we also consider nodes as used\n     /// if they are mentioned in an assert, so some used nodes are never\n     /// actually reachable by walking the [`AbstractConst`].\n     nodes: IndexVec<NodeId, WorkNode<'tcx>>,\n-    locals: IndexVec<mir::Local, NodeId>,\n-    /// We only allow field accesses if they access\n-    /// the result of a checked operation.\n-    checked_op_locals: BitSet<mir::Local>,\n }\n \n impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n+    fn root_span(&self) -> Span {\n+        self.body.exprs[self.body_id].span\n+    }\n+\n     fn error(&mut self, span: Option<Span>, msg: &str) -> Result<!, ErrorReported> {\n         self.tcx\n             .sess\n-            .struct_span_err(self.body.span, \"overly complex generic constant\")\n-            .span_label(span.unwrap_or(self.body.span), msg)\n+            .struct_span_err(self.root_span(), \"overly complex generic constant\")\n+            .span_label(span.unwrap_or(self.root_span()), msg)\n             .help(\"consider moving this anonymous constant into a `const` function\")\n             .emit();\n \n@@ -260,28 +263,12 @@ impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n \n     fn new(\n         tcx: TyCtxt<'tcx>,\n-        body: &'a mir::Body<'tcx>,\n+        (body, body_id): (&'a thir::Thir<'tcx>, thir::ExprId),\n     ) -> Result<Option<AbstractConstBuilder<'a, 'tcx>>, ErrorReported> {\n-        let mut builder = AbstractConstBuilder {\n-            tcx,\n-            body,\n-            nodes: IndexVec::new(),\n-            locals: IndexVec::from_elem(NodeId::MAX, &body.local_decls),\n-            checked_op_locals: BitSet::new_empty(body.local_decls.len()),\n-        };\n-\n-        // We don't have to look at concrete constants, as we\n-        // can just evaluate them.\n-        if !body.is_polymorphic {\n-            return Ok(None);\n-        }\n+        let builder =\n+            AbstractConstBuilder { tcx, body_id, body: Lrc::new(body), nodes: IndexVec::new() };\n \n-        // We only allow consts without control flow, so\n-        // we check for cycles here which simplifies the\n-        // rest of this implementation.\n-        if body.is_cfg_cyclic() {\n-            builder.error(None, \"cyclic anonymous constants are forbidden\")?;\n-        }\n+        // FIXME non-constants should return Ok(None)\n \n         Ok(Some(builder))\n     }\n@@ -301,6 +288,10 @@ impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n                 self.nodes[func].used = true;\n                 nodes.iter().for_each(|&n| self.nodes[n].used = true);\n             }\n+            Node::Block(stmts, opt_expr) => {\n+                stmts.iter().for_each(|&id| self.nodes[id].used = true);\n+                opt_expr.map(|e| self.nodes[e].used = true);\n+            }\n             Node::Cast(_, operand, _) => {\n                 self.nodes[operand].used = true;\n             }\n@@ -310,50 +301,6 @@ impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n         self.nodes.push(WorkNode { node, span, used: false })\n     }\n \n-    fn place_to_local(\n-        &mut self,\n-        span: Span,\n-        p: &mir::Place<'tcx>,\n-    ) -> Result<mir::Local, ErrorReported> {\n-        const ZERO_FIELD: mir::Field = mir::Field::from_usize(0);\n-        // Do not allow any projections.\n-        //\n-        // One exception are field accesses on the result of checked operations,\n-        // which are required to support things like `1 + 2`.\n-        if let Some(p) = p.as_local() {\n-            debug_assert!(!self.checked_op_locals.contains(p));\n-            Ok(p)\n-        } else if let &[mir::ProjectionElem::Field(ZERO_FIELD, _)] = p.projection.as_ref() {\n-            // Only allow field accesses if the given local\n-            // contains the result of a checked operation.\n-            if self.checked_op_locals.contains(p.local) {\n-                Ok(p.local)\n-            } else {\n-                self.error(Some(span), \"unsupported projection\")?;\n-            }\n-        } else {\n-            self.error(Some(span), \"unsupported projection\")?;\n-        }\n-    }\n-\n-    fn operand_to_node(\n-        &mut self,\n-        span: Span,\n-        op: &mir::Operand<'tcx>,\n-    ) -> Result<NodeId, ErrorReported> {\n-        debug!(\"operand_to_node: op={:?}\", op);\n-        match op {\n-            mir::Operand::Copy(p) | mir::Operand::Move(p) => {\n-                let local = self.place_to_local(span, p)?;\n-                Ok(self.locals[local])\n-            }\n-            mir::Operand::Constant(ct) => match ct.literal {\n-                mir::ConstantKind::Ty(ct) => Ok(self.add_node(Node::Leaf(ct), span)),\n-                mir::ConstantKind::Val(..) => self.error(Some(span), \"unsupported constant\")?,\n-            },\n-        }\n-    }\n-\n     /// We do not allow all binary operations in abstract consts, so filter disallowed ones.\n     fn check_binop(op: mir::BinOp) -> bool {\n         use mir::BinOp::*;\n@@ -373,148 +320,13 @@ impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n         }\n     }\n \n-    fn build_statement(&mut self, stmt: &mir::Statement<'tcx>) -> Result<(), ErrorReported> {\n-        debug!(\"AbstractConstBuilder: stmt={:?}\", stmt);\n-        let span = stmt.source_info.span;\n-        match stmt.kind {\n-            StatementKind::Assign(box (ref place, ref rvalue)) => {\n-                let local = self.place_to_local(span, place)?;\n-                match *rvalue {\n-                    Rvalue::Use(ref operand) => {\n-                        self.locals[local] = self.operand_to_node(span, operand)?;\n-                        Ok(())\n-                    }\n-                    Rvalue::BinaryOp(op, box (ref lhs, ref rhs)) if Self::check_binop(op) => {\n-                        let lhs = self.operand_to_node(span, lhs)?;\n-                        let rhs = self.operand_to_node(span, rhs)?;\n-                        self.locals[local] = self.add_node(Node::Binop(op, lhs, rhs), span);\n-                        if op.is_checkable() {\n-                            bug!(\"unexpected unchecked checkable binary operation\");\n-                        } else {\n-                            Ok(())\n-                        }\n-                    }\n-                    Rvalue::CheckedBinaryOp(op, box (ref lhs, ref rhs))\n-                        if Self::check_binop(op) =>\n-                    {\n-                        let lhs = self.operand_to_node(span, lhs)?;\n-                        let rhs = self.operand_to_node(span, rhs)?;\n-                        self.locals[local] = self.add_node(Node::Binop(op, lhs, rhs), span);\n-                        self.checked_op_locals.insert(local);\n-                        Ok(())\n-                    }\n-                    Rvalue::UnaryOp(op, ref operand) if Self::check_unop(op) => {\n-                        let operand = self.operand_to_node(span, operand)?;\n-                        self.locals[local] = self.add_node(Node::UnaryOp(op, operand), span);\n-                        Ok(())\n-                    }\n-                    Rvalue::Cast(cast_kind, ref operand, ty) => {\n-                        let operand = self.operand_to_node(span, operand)?;\n-                        self.locals[local] =\n-                            self.add_node(Node::Cast(cast_kind, operand, ty), span);\n-                        Ok(())\n-                    }\n-                    _ => self.error(Some(span), \"unsupported rvalue\")?,\n-                }\n-            }\n-            // These are not actually relevant for us here, so we can ignore them.\n-            StatementKind::AscribeUserType(..)\n-            | StatementKind::StorageLive(_)\n-            | StatementKind::StorageDead(_) => Ok(()),\n-            _ => self.error(Some(stmt.source_info.span), \"unsupported statement\")?,\n-        }\n-    }\n-\n-    /// Possible return values:\n-    ///\n-    /// - `None`: unsupported terminator, stop building\n-    /// - `Some(None)`: supported terminator, finish building\n-    /// - `Some(Some(block))`: support terminator, build `block` next\n-    fn build_terminator(\n-        &mut self,\n-        terminator: &mir::Terminator<'tcx>,\n-    ) -> Result<Option<mir::BasicBlock>, ErrorReported> {\n-        debug!(\"AbstractConstBuilder: terminator={:?}\", terminator);\n-        match terminator.kind {\n-            TerminatorKind::Goto { target } => Ok(Some(target)),\n-            TerminatorKind::Return => Ok(None),\n-            TerminatorKind::Call {\n-                ref func,\n-                ref args,\n-                destination: Some((ref place, target)),\n-                // We do not care about `cleanup` here. Any branch which\n-                // uses `cleanup` will fail const-eval and they therefore\n-                // do not matter when checking for const evaluatability.\n-                //\n-                // Do note that even if `panic::catch_unwind` is made const,\n-                // we still do not have to care about this, as we do not look\n-                // into functions.\n-                cleanup: _,\n-                // Do not allow overloaded operators for now,\n-                // we probably do want to allow this in the future.\n-                //\n-                // This is currently fairly irrelevant as it requires `const Trait`s.\n-                from_hir_call: true,\n-                fn_span,\n-            } => {\n-                let local = self.place_to_local(fn_span, place)?;\n-                let func = self.operand_to_node(fn_span, func)?;\n-                let args = self.tcx.arena.alloc_from_iter(\n-                    args.iter()\n-                        .map(|arg| self.operand_to_node(terminator.source_info.span, arg))\n-                        .collect::<Result<Vec<NodeId>, _>>()?,\n-                );\n-                self.locals[local] = self.add_node(Node::FunctionCall(func, args), fn_span);\n-                Ok(Some(target))\n-            }\n-            TerminatorKind::Assert { ref cond, expected: false, target, .. } => {\n-                let p = match cond {\n-                    mir::Operand::Copy(p) | mir::Operand::Move(p) => p,\n-                    mir::Operand::Constant(_) => bug!(\"unexpected assert\"),\n-                };\n-\n-                const ONE_FIELD: mir::Field = mir::Field::from_usize(1);\n-                debug!(\"proj: {:?}\", p.projection);\n-                if let Some(p) = p.as_local() {\n-                    debug_assert!(!self.checked_op_locals.contains(p));\n-                    // Mark locals directly used in asserts as used.\n-                    //\n-                    // This is needed because division does not use `CheckedBinop` but instead\n-                    // adds an explicit assert for `divisor != 0`.\n-                    self.nodes[self.locals[p]].used = true;\n-                    return Ok(Some(target));\n-                } else if let &[mir::ProjectionElem::Field(ONE_FIELD, _)] = p.projection.as_ref() {\n-                    // Only allow asserts checking the result of a checked operation.\n-                    if self.checked_op_locals.contains(p.local) {\n-                        return Ok(Some(target));\n-                    }\n-                }\n-\n-                self.error(Some(terminator.source_info.span), \"unsupported assertion\")?;\n-            }\n-            _ => self.error(Some(terminator.source_info.span), \"unsupported terminator\")?,\n-        }\n-    }\n-\n-    /// Builds the abstract const by walking the mir from start to finish\n-    /// and bailing out when encountering an unsupported operation.\n+    /// Builds the abstract const by walking the thir and bailing out when\n+    /// encountering an unspported operation.\n     fn build(mut self) -> Result<&'tcx [Node<'tcx>], ErrorReported> {\n-        let mut block = &self.body.basic_blocks()[mir::START_BLOCK];\n-        // We checked for a cyclic cfg above, so this should terminate.\n-        loop {\n-            debug!(\"AbstractConstBuilder: block={:?}\", block);\n-            for stmt in block.statements.iter() {\n-                self.build_statement(stmt)?;\n-            }\n-\n-            if let Some(next) = self.build_terminator(block.terminator())? {\n-                block = &self.body.basic_blocks()[next];\n-            } else {\n-                break;\n-            }\n-        }\n+        debug!(\"Abstractconstbuilder::build: body={:?}\", &*self.body);\n+        let last = self.recurse_build(self.body_id)?;\n+        self.nodes[last].used = true;\n \n-        assert_eq!(self.locals[mir::RETURN_PLACE], self.nodes.last().unwrap());\n         for n in self.nodes.iter() {\n             if let Node::Leaf(ty::Const { val: ty::ConstKind::Unevaluated(ct), ty: _ }) = n.node {\n                 // `AbstractConst`s should not contain any promoteds as they require references which\n@@ -523,13 +335,108 @@ impl<'a, 'tcx> AbstractConstBuilder<'a, 'tcx> {\n             }\n         }\n \n-        self.nodes[self.locals[mir::RETURN_PLACE]].used = true;\n         if let Some(&unused) = self.nodes.iter().find(|n| !n.used) {\n             self.error(Some(unused.span), \"dead code\")?;\n         }\n \n         Ok(self.tcx.arena.alloc_from_iter(self.nodes.into_iter().map(|n| n.node)))\n     }\n+\n+    fn recurse_build(&mut self, node: thir::ExprId) -> Result<NodeId, ErrorReported> {\n+        use thir::ExprKind;\n+        let node = &self.body.clone().exprs[node];\n+        debug!(\"recurse_build: node={:?}\", node);\n+        Ok(match &node.kind {\n+            // I dont know if handling of these 3 is correct\n+            &ExprKind::Scope { value, .. } => self.recurse_build(value)?,\n+            &ExprKind::PlaceTypeAscription { source, .. } |\n+            &ExprKind::ValueTypeAscription { source, .. } => self.recurse_build(source)?,\n+\n+            &ExprKind::Literal { literal, .. }\n+            | &ExprKind::StaticRef { literal, .. } => self.add_node(Node::Leaf(literal), node.span),\n+\n+            // FIXME(generic_const_exprs) handle `from_hir_call` field\n+            ExprKind::Call { fun, args,  .. } => {\n+                let fun = self.recurse_build(*fun)?;\n+\n+                let mut new_args = Vec::<NodeId>::with_capacity(args.len());\n+                for &id in args.iter() {\n+                    new_args.push(self.recurse_build(id)?);\n+                }\n+                let new_args = self.tcx.arena.alloc_slice(&new_args);\n+                self.add_node(Node::FunctionCall(fun, new_args), node.span)\n+            },\n+            &ExprKind::Binary { op, lhs, rhs } if Self::check_binop(op) => {\n+                let lhs = self.recurse_build(lhs)?;\n+                let rhs = self.recurse_build(rhs)?;\n+                self.add_node(Node::Binop(op, lhs, rhs), node.span)\n+            }\n+            &ExprKind::Unary { op, arg } if Self::check_unop(op) => {\n+                let arg = self.recurse_build(arg)?;\n+                self.add_node(Node::UnaryOp(op, arg), node.span)\n+            },\n+            // HACK: without this arm the following doesn't compile:\n+            // ```\n+            // fn foo<const N: usize>(_: [(); N + 1]) {\n+            //     bar::<{ N + 1}>();\n+            // }\n+            // ```\n+            // we ought to properly handle this in `try_unify`\n+            ExprKind::Block { body: thir::Block { stmts: box [], expr: Some(e), .. }} => self.recurse_build(*e)?,\n+            ExprKind::Block { body } => {\n+                let mut stmts = Vec::with_capacity(body.stmts.len());\n+                for &id in body.stmts.iter() {\n+                    match &self.body.stmts[id].kind {\n+                        thir::StmtKind::Let { .. } => return self.error(\n+                                Some(node.span),\n+                                \"let statements are not supported in generic constants\",\n+                            ).map(|never| never),\n+                        thir::StmtKind::Expr { expr, .. } => stmts.push(self.recurse_build(*expr)?),\n+                    }\n+                };\n+                let stmts = self.tcx.arena.alloc_slice(&stmts);\n+                let opt_expr = body.expr.map(|e| self.recurse_build(e)).transpose()?;\n+                self.add_node(Node::Block(stmts, opt_expr), node.span)\n+            }\n+            &ExprKind::Cast { source } => todo!(),\n+            // never can arise even without panic/fail to terminate\n+            &ExprKind::NeverToAny { source } => todo!(),\n+            // i think this is a dummy usage of the expr to allow coercions\n+            &ExprKind::Use { source } => todo!(),\n+\n+            ExprKind::Return { .. }\n+            | ExprKind::Box { .. } // allocations not allowed in constants\n+            | ExprKind::AssignOp { .. }\n+            | ExprKind::AddressOf { .. } // FIXME(generic_const_exprs)\n+            | ExprKind::Borrow { .. } // FIXME(generic_const_exprs)\n+            | ExprKind::Deref { .. } // FIXME(generic_const_exprs)\n+            | ExprKind::Repeat { .. } // FIXME(generic_const_exprs)\n+            | ExprKind::Array { .. } // FIXME(generic_const_exprs)\n+            | ExprKind::Tuple { .. } // FIXME(generic_const_exprs)\n+            | ExprKind::Index { .. } // FIXME(generic_const_exprs)\n+            | ExprKind::Field { .. } // FIXME(generic_const_exprs)\n+            | ExprKind::ConstBlock { .. } // FIXME(generic_const_exprs)\n+            | ExprKind::Adt(_) // FIXME(generic_const_exprs) we *should* permit this but dont currently\n+            | ExprKind::Match { .. }\n+            | ExprKind::VarRef { .. } //\n+            | ExprKind::UpvarRef { .. } // we dont permit let stmts so...\n+            | ExprKind::Closure { .. }\n+            | ExprKind::Let { .. } // let expressions imply control flow\n+            | ExprKind::Loop { .. }\n+            | ExprKind::Assign { .. }\n+            | ExprKind::LogicalOp { .. }\n+            | ExprKind::Unary { .. } //\n+            | ExprKind::Binary { .. } // we handle valid unary/binary ops above \n+            | ExprKind::Break { .. }\n+            | ExprKind::Continue { .. }\n+            | ExprKind::If { .. }\n+            | ExprKind::Pointer { .. } // dont know if this is correct\n+            | ExprKind::ThreadLocalRef(_)\n+            | ExprKind::LlvmInlineAsm { .. }\n+            | ExprKind::InlineAsm { .. }\n+            | ExprKind::Yield { .. } => return self.error(Some(node.span), \"unsupported operation in generic constant\").map(|never| never),\n+        })\n+    }\n }\n \n /// Builds an abstract const, do not use this directly, but use `AbstractConst::new` instead.\n@@ -547,8 +454,17 @@ pub(super) fn mir_abstract_const<'tcx>(\n             DefKind::AnonConst => (),\n             _ => return Ok(None),\n         }\n-        let body = tcx.mir_const(def).borrow();\n-        AbstractConstBuilder::new(tcx, &body)?.map(AbstractConstBuilder::build).transpose()\n+        debug!(\"mir_abstract_const: {:?}\", def);\n+        let body = tcx.thir_body(def);\n+\n+        if body.0.borrow().exprs.is_empty() {\n+            // type error in constant, there is no thir\n+            return Err(ErrorReported);\n+        }\n+\n+        AbstractConstBuilder::new(tcx, (&*body.0.borrow(), body.1))?\n+            .map(AbstractConstBuilder::build)\n+            .transpose()\n     } else {\n         Ok(None)\n     }\n@@ -599,6 +515,12 @@ where\n                 recurse(tcx, ct.subtree(func), f)?;\n                 args.iter().try_for_each(|&arg| recurse(tcx, ct.subtree(arg), f))\n             }\n+            Node::Block(stmts, opt_expr) => {\n+                for id in stmts.iter().copied().chain(opt_expr) {\n+                    recurse(tcx, ct.subtree(id), f)?;\n+                }\n+                ControlFlow::CONTINUE\n+            }\n             Node::Cast(_, operand, _) => recurse(tcx, ct.subtree(operand), f),\n         }\n     }"}, {"sha": "e64cc9e4b8f28b9b047583a3086991679dd428ae", "filename": "compiler/rustc_trait_selection/src/traits/object_safety.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2987f4ba42b002c58ae485f7ae528cb29c3b1611/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2987f4ba42b002c58ae485f7ae528cb29c3b1611/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs?ref=2987f4ba42b002c58ae485f7ae528cb29c3b1611", "patch": "@@ -844,9 +844,10 @@ fn contains_illegal_self_type_reference<'tcx, T: TypeFoldable<'tcx>>(\n                         self.visit_const(leaf)\n                     }\n                     Node::Cast(_, _, ty) => self.visit_ty(ty),\n-                    Node::Binop(..) | Node::UnaryOp(..) | Node::FunctionCall(_, _) => {\n-                        ControlFlow::CONTINUE\n-                    }\n+                    Node::Block(_, _)\n+                    | Node::Binop(..)\n+                    | Node::UnaryOp(..)\n+                    | Node::FunctionCall(_, _) => ControlFlow::CONTINUE,\n                 })\n             } else {\n                 ControlFlow::CONTINUE"}]}