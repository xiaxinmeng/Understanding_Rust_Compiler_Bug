{"sha": "ea5848df4b6150a5d308af643968d54bb510ac03", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVhNTg0OGRmNGI2MTUwYTVkMzA4YWY2NDM5NjhkNTRiYjUxMGFjMDM=", "commit": {"author": {"name": "Yuki Okushi", "email": "huyuumi.dev@gmail.com", "date": "2020-05-29T06:06:53Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-05-29T06:06:53Z"}, "message": "Rollup merge of #71843 - sfackler:cas-loop-cleanup, r=dtolnay\n\nTweak and stabilize AtomicN::fetch_update\n\nThe fetch_update method implements a compare-and-swap loop to update the value in an atomic to an arbitrary value computed by a closure.\n\nI've applied a few tweaks suggested by @mystor in this comment on the tracking issue: https://github.com/rust-lang/rust/issues/48655#issuecomment-496036553. Specifically, the load and store ordering arguments have been swapped to match with the orderings of `compare_exchange`, and the closure has been moved from the first to last argument.\n\nMoving the closure to the last argument is a change away from other methods on the atomic types which place the ordering(s) last, but matches with the broad convention that closure arguments come last in functions. In particular, rustfmt style lays calls with multi-line closures out more cleanly when the closure comes last.", "tree": {"sha": "5c90f9d573530abfa6e6b8fd511009026ef1baf0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5c90f9d573530abfa6e6b8fd511009026ef1baf0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ea5848df4b6150a5d308af643968d54bb510ac03", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJe0KZ9CRBK7hj4Ov3rIwAAdHIIACwsFvSccKo6sTWrD15CjyvW\npsxO9M1tg/iXQVZUQSDvqOAYnZw73wAd6CCikw7GtoJ+qry/UJht+ODSRt40Iz5u\nO0wzYZTf1YKb9hL2H4aYiwVatFvuy+KcetjSheRnyMneyNx65H/evGRbsYk0h2gF\nMgliZVGQrlfDYEJFLaTt643z1jHIV1OBHuBM4jtS7Konet/jQ+/D8G/9g47e26gs\n+JOteEEilRFEG9XmaOHS72b1l20uioW6A1/byILDkdvMLuViTREQvQYbHFXIXhk5\np1u0le9L87OcLzx3mKRSe0i21YzYaTMBor/aJYAe664lHNOj74wGKhSimrwxXCg=\n=YM5e\n-----END PGP SIGNATURE-----\n", "payload": "tree 5c90f9d573530abfa6e6b8fd511009026ef1baf0\nparent a08a03ced7909d2a8d6e6df1005b6acda7f10bf4\nparent 31c820552350e3f686a6f353982f0f31ecbaf4a7\nauthor Yuki Okushi <huyuumi.dev@gmail.com> 1590732413 +0900\ncommitter GitHub <noreply@github.com> 1590732413 +0900\n\nRollup merge of #71843 - sfackler:cas-loop-cleanup, r=dtolnay\n\nTweak and stabilize AtomicN::fetch_update\n\nThe fetch_update method implements a compare-and-swap loop to update the value in an atomic to an arbitrary value computed by a closure.\n\nI've applied a few tweaks suggested by @mystor in this comment on the tracking issue: https://github.com/rust-lang/rust/issues/48655#issuecomment-496036553. Specifically, the load and store ordering arguments have been swapped to match with the orderings of `compare_exchange`, and the closure has been moved from the first to last argument.\n\nMoving the closure to the last argument is a change away from other methods on the atomic types which place the ordering(s) last, but matches with the broad convention that closure arguments come last in functions. In particular, rustfmt style lays calls with multi-line closures out more cleanly when the closure comes last.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ea5848df4b6150a5d308af643968d54bb510ac03", "html_url": "https://github.com/rust-lang/rust/commit/ea5848df4b6150a5d308af643968d54bb510ac03", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ea5848df4b6150a5d308af643968d54bb510ac03/comments", "author": {"login": "JohnTitor", "id": 25030997, "node_id": "MDQ6VXNlcjI1MDMwOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/25030997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JohnTitor", "html_url": "https://github.com/JohnTitor", "followers_url": "https://api.github.com/users/JohnTitor/followers", "following_url": "https://api.github.com/users/JohnTitor/following{/other_user}", "gists_url": "https://api.github.com/users/JohnTitor/gists{/gist_id}", "starred_url": "https://api.github.com/users/JohnTitor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JohnTitor/subscriptions", "organizations_url": "https://api.github.com/users/JohnTitor/orgs", "repos_url": "https://api.github.com/users/JohnTitor/repos", "events_url": "https://api.github.com/users/JohnTitor/events{/privacy}", "received_events_url": "https://api.github.com/users/JohnTitor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a08a03ced7909d2a8d6e6df1005b6acda7f10bf4", "url": "https://api.github.com/repos/rust-lang/rust/commits/a08a03ced7909d2a8d6e6df1005b6acda7f10bf4", "html_url": "https://github.com/rust-lang/rust/commit/a08a03ced7909d2a8d6e6df1005b6acda7f10bf4"}, {"sha": "31c820552350e3f686a6f353982f0f31ecbaf4a7", "url": "https://api.github.com/repos/rust-lang/rust/commits/31c820552350e3f686a6f353982f0f31ecbaf4a7", "html_url": "https://github.com/rust-lang/rust/commit/31c820552350e3f686a6f353982f0f31ecbaf4a7"}], "stats": {"total": 26, "additions": 11, "deletions": 15}, "files": [{"sha": "0e0ebfa1a452f0d957b4ae784d55088a6ea417af", "filename": "src/libcore/sync/atomic.rs", "status": "modified", "additions": 11, "deletions": 15, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/ea5848df4b6150a5d308af643968d54bb510ac03/src%2Flibcore%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea5848df4b6150a5d308af643968d54bb510ac03/src%2Flibcore%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsync%2Fatomic.rs?ref=ea5848df4b6150a5d308af643968d54bb510ac03", "patch": "@@ -1807,13 +1807,12 @@ new value. Returns a `Result` of `Ok(previous_value)` if the function returned `\n \n Note: This may call the function multiple times if the value has been changed from other threads in\n the meantime, as long as the function returns `Some(_)`, but the function will have been applied\n-but once to the stored value.\n+only once to the stored value.\n \n-`fetch_update` takes two [`Ordering`] arguments to describe the memory\n-ordering of this operation. The first describes the required ordering for loads\n-and failed updates while the second describes the required ordering when the\n-operation finally succeeds. Beware that this is different from the two\n-modes in [`compare_exchange`]!\n+`fetch_update` takes two [`Ordering`] arguments to describe the memory ordering of this operation.\n+The first describes the required ordering for when the operation finally succeeds while the second\n+describes the required ordering for loads. These correspond to the success and failure orderings of\n+[`compare_exchange`] respectively.\n \n Using [`Acquire`] as success ordering makes the store part\n of this operation [`Relaxed`], and using [`Release`] makes the final successful load\n@@ -1831,24 +1830,21 @@ and must be equivalent to or weaker than the success ordering.\n # Examples\n \n ```rust\n-#![feature(no_more_cas)]\n \", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n \n let x = \", stringify!($atomic_type), \"::new(7);\n-assert_eq!(x.fetch_update(|_| None, Ordering::SeqCst, Ordering::SeqCst), Err(7));\n-assert_eq!(x.fetch_update(|x| Some(x + 1), Ordering::SeqCst, Ordering::SeqCst), Ok(7));\n-assert_eq!(x.fetch_update(|x| Some(x + 1), Ordering::SeqCst, Ordering::SeqCst), Ok(8));\n+assert_eq!(x.fetch_update(Ordering::SeqCst, Ordering::SeqCst, |_| None), Err(7));\n+assert_eq!(x.fetch_update(Ordering::SeqCst, Ordering::SeqCst, |x| Some(x + 1)), Ok(7));\n+assert_eq!(x.fetch_update(Ordering::SeqCst, Ordering::SeqCst, |x| Some(x + 1)), Ok(8));\n assert_eq!(x.load(Ordering::SeqCst), 9);\n ```\"),\n                 #[inline]\n-                #[unstable(feature = \"no_more_cas\",\n-                       reason = \"no more CAS loops in user code\",\n-                       issue = \"48655\")]\n+                #[stable(feature = \"no_more_cas\", since = \"1.45.0\")]\n                 #[$cfg_cas]\n                 pub fn fetch_update<F>(&self,\n-                                       mut f: F,\n+                                       set_order: Ordering,\n                                        fetch_order: Ordering,\n-                                       set_order: Ordering) -> Result<$int_type, $int_type>\n+                                       mut f: F) -> Result<$int_type, $int_type>\n                 where F: FnMut($int_type) -> Option<$int_type> {\n                     let mut prev = self.load(fetch_order);\n                     while let Some(next) = f(prev) {"}]}