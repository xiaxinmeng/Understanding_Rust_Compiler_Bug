{"sha": "36029878e739f23bb774104cc3250e6f03cf8685", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM2MDI5ODc4ZTczOWYyM2JiNzc0MTA0Y2MzMjUwZTZmMDNjZjg2ODU=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-07-30T03:37:32Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-07-30T03:37:32Z"}, "message": "Rollup merge of #62928 - Centril:recover-parens-around-for-head, r=estebank\n\nSyntax: Recover on `for ( $pat in $expr ) $block`\n\nFixes #62724 by adding some recovery:\n\n```\nerror: unexpected closing `)`\n  --> $DIR/recover-for-loop-parens-around-head.rs:10:23\n   |\nLL |     for ( elem in vec ) {\n   |         --------------^\n   |         |\n   |         opening `(`\n   |         help: remove parenthesis in `for` loop: `elem in vec`\n```\n\nThe last 2 commits are drive-by cleanups.\n\nr? @estebank", "tree": {"sha": "7d17d6037914d7f6e6f7cbe98c3deae061d77115", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7d17d6037914d7f6e6f7cbe98c3deae061d77115"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/36029878e739f23bb774104cc3250e6f03cf8685", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdP7t8CRBK7hj4Ov3rIwAAdHIIABzME4mWOAfa0u5YSaCLKiGZ\nJgo9ouiyosJNFqUVvuap65bDcnGxAWtnNL1VkcjQBS2zmcwUScFhe2RC7VQ/K06G\n+mPpk4QXmdSOR4hunf+8Sg5LOVU7S+GBthDKlRuS79yXs7Vyg0kGUz/yNBbV2dAt\nOLLNBEO4IfHbjI9zSgJPA11iX+wSWJ3cRhFN1RI5a+HWyVeRaeC/EdNy/282pnNJ\nfxubLGEe28IGLzSOJZ6exkOhj5/xsaFU2DHo6zbq9dAepBVwJTAicdUK2TfbEn58\nOR699yqARTtqCbi59eSlyvh6cFP2daRevjhV/WVq3G9rxAWayDepDQS8KOZ26Ro=\n=RqAA\n-----END PGP SIGNATURE-----\n", "payload": "tree 7d17d6037914d7f6e6f7cbe98c3deae061d77115\nparent b5bea2565e565dd014f768921f63d111ebfe27d3\nparent 56b39fba563a7ae5ca39eae80b9e26e9890522cf\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1564457852 +0200\ncommitter GitHub <noreply@github.com> 1564457852 +0200\n\nRollup merge of #62928 - Centril:recover-parens-around-for-head, r=estebank\n\nSyntax: Recover on `for ( $pat in $expr ) $block`\n\nFixes #62724 by adding some recovery:\n\n```\nerror: unexpected closing `)`\n  --> $DIR/recover-for-loop-parens-around-head.rs:10:23\n   |\nLL |     for ( elem in vec ) {\n   |         --------------^\n   |         |\n   |         opening `(`\n   |         help: remove parenthesis in `for` loop: `elem in vec`\n```\n\nThe last 2 commits are drive-by cleanups.\n\nr? @estebank\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/36029878e739f23bb774104cc3250e6f03cf8685", "html_url": "https://github.com/rust-lang/rust/commit/36029878e739f23bb774104cc3250e6f03cf8685", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/36029878e739f23bb774104cc3250e6f03cf8685/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b5bea2565e565dd014f768921f63d111ebfe27d3", "url": "https://api.github.com/repos/rust-lang/rust/commits/b5bea2565e565dd014f768921f63d111ebfe27d3", "html_url": "https://github.com/rust-lang/rust/commit/b5bea2565e565dd014f768921f63d111ebfe27d3"}, {"sha": "56b39fba563a7ae5ca39eae80b9e26e9890522cf", "url": "https://api.github.com/repos/rust-lang/rust/commits/56b39fba563a7ae5ca39eae80b9e26e9890522cf", "html_url": "https://github.com/rust-lang/rust/commit/56b39fba563a7ae5ca39eae80b9e26e9890522cf"}], "stats": {"total": 421, "additions": 259, "deletions": 162}, "files": [{"sha": "9eb6aa303b06bc4fda94e50fb4938449cd89245a", "filename": "src/libsyntax/parse/diagnostics.rs", "status": "modified", "additions": 81, "deletions": 37, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/36029878e739f23bb774104cc3250e6f03cf8685/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36029878e739f23bb774104cc3250e6f03cf8685/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs?ref=36029878e739f23bb774104cc3250e6f03cf8685", "patch": "@@ -14,7 +14,7 @@ use crate::ThinVec;\n use crate::util::parser::AssocOp;\n use errors::{Applicability, DiagnosticBuilder, DiagnosticId};\n use rustc_data_structures::fx::FxHashSet;\n-use syntax_pos::{Span, DUMMY_SP, MultiSpan};\n+use syntax_pos::{Span, DUMMY_SP, MultiSpan, SpanSnippetError};\n use log::{debug, trace};\n use std::mem;\n \n@@ -199,6 +199,10 @@ impl<'a> Parser<'a> {\n         &self.sess.span_diagnostic\n     }\n \n+    crate fn span_to_snippet(&self, span: Span) -> Result<String, SpanSnippetError> {\n+        self.sess.source_map().span_to_snippet(span)\n+    }\n+\n     crate fn expected_ident_found(&self) -> DiagnosticBuilder<'a> {\n         let mut err = self.struct_span_err(\n             self.token.span,\n@@ -549,8 +553,10 @@ impl<'a> Parser<'a> {\n             ExprKind::Binary(op, _, _) if op.node.is_comparison() => {\n                 // respan to include both operators\n                 let op_span = op.span.to(self.token.span);\n-                let mut err = self.diagnostic().struct_span_err(op_span,\n-                    \"chained comparison operators require parentheses\");\n+                let mut err = self.struct_span_err(\n+                    op_span,\n+                    \"chained comparison operators require parentheses\",\n+                );\n                 if op.node == BinOpKind::Lt &&\n                     *outer_op == AssocOp::Less ||  // Include `<` to provide this recommendation\n                     *outer_op == AssocOp::Greater  // even in a case like the following:\n@@ -717,8 +723,6 @@ impl<'a> Parser<'a> {\n         path.span = ty_span.to(self.prev_span);\n \n         let ty_str = self\n-            .sess\n-            .source_map()\n             .span_to_snippet(ty_span)\n             .unwrap_or_else(|_| pprust::ty_to_string(&ty));\n         self.diagnostic()\n@@ -889,7 +893,7 @@ impl<'a> Parser<'a> {\n             err.span_label(await_sp, \"while parsing this incorrect await expression\");\n             err\n         })?;\n-        let expr_str = self.sess.source_map().span_to_snippet(expr.span)\n+        let expr_str = self.span_to_snippet(expr.span)\n             .unwrap_or_else(|_| pprust::expr_to_string(&expr));\n         let suggestion = format!(\"{}.await{}\", expr_str, if is_question { \"?\" } else { \"\" });\n         let sp = lo.to(expr.span);\n@@ -923,6 +927,48 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n+    /// Recover a situation like `for ( $pat in $expr )`\n+    /// and suggest writing `for $pat in $expr` instead.\n+    ///\n+    /// This should be called before parsing the `$block`.\n+    crate fn recover_parens_around_for_head(\n+        &mut self,\n+        pat: P<Pat>,\n+        expr: &Expr,\n+        begin_paren: Option<Span>,\n+    ) -> P<Pat> {\n+        match (&self.token.kind, begin_paren) {\n+            (token::CloseDelim(token::Paren), Some(begin_par_sp)) => {\n+                self.bump();\n+\n+                let pat_str = self\n+                    // Remove the `(` from the span of the pattern:\n+                    .span_to_snippet(pat.span.trim_start(begin_par_sp).unwrap())\n+                    .unwrap_or_else(|_| pprust::pat_to_string(&pat));\n+\n+                self.struct_span_err(self.prev_span, \"unexpected closing `)`\")\n+                    .span_label(begin_par_sp, \"opening `(`\")\n+                    .span_suggestion(\n+                        begin_par_sp.to(self.prev_span),\n+                        \"remove parenthesis in `for` loop\",\n+                        format!(\"{} in {}\", pat_str, pprust::expr_to_string(&expr)),\n+                        // With e.g. `for (x) in y)` this would replace `(x) in y)`\n+                        // with `x) in y)` which is syntactically invalid.\n+                        // However, this is prevented before we get here.\n+                        Applicability::MachineApplicable,\n+                    )\n+                    .emit();\n+\n+                // Unwrap `(pat)` into `pat` to avoid the `unused_parens` lint.\n+                pat.and_then(|pat| match pat.node {\n+                    PatKind::Paren(pat) => pat,\n+                    _ => P(pat),\n+                })\n+            }\n+            _ => pat,\n+        }\n+    }\n+\n     crate fn could_ascription_be_path(&self, node: &ast::ExprKind) -> bool {\n         self.token.is_ident() &&\n             if let ast::ExprKind::Path(..) = node { true } else { false } &&\n@@ -1105,17 +1151,14 @@ impl<'a> Parser<'a> {\n     crate fn check_for_for_in_in_typo(&mut self, in_span: Span) {\n         if self.eat_keyword(kw::In) {\n             // a common typo: `for _ in in bar {}`\n-            let mut err = self.sess.span_diagnostic.struct_span_err(\n-                self.prev_span,\n-                \"expected iterable, found keyword `in`\",\n-            );\n-            err.span_suggestion_short(\n-                in_span.until(self.prev_span),\n-                \"remove the duplicated `in`\",\n-                String::new(),\n-                Applicability::MachineApplicable,\n-            );\n-            err.emit();\n+            self.struct_span_err(self.prev_span, \"expected iterable, found keyword `in`\")\n+                .span_suggestion_short(\n+                    in_span.until(self.prev_span),\n+                    \"remove the duplicated `in`\",\n+                    String::new(),\n+                    Applicability::MachineApplicable,\n+                )\n+                .emit();\n         }\n     }\n \n@@ -1128,12 +1171,12 @@ impl<'a> Parser<'a> {\n \n     crate fn eat_incorrect_doc_comment_for_arg_type(&mut self) {\n         if let token::DocComment(_) = self.token.kind {\n-            let mut err = self.diagnostic().struct_span_err(\n+            self.struct_span_err(\n                 self.token.span,\n                 \"documentation comments cannot be applied to a function parameter's type\",\n-            );\n-            err.span_label(self.token.span, \"doc comments are not allowed here\");\n-            err.emit();\n+            )\n+            .span_label(self.token.span, \"doc comments are not allowed here\")\n+            .emit();\n             self.bump();\n         } else if self.token == token::Pound && self.look_ahead(1, |t| {\n             *t == token::OpenDelim(token::Bracket)\n@@ -1145,12 +1188,12 @@ impl<'a> Parser<'a> {\n             }\n             let sp = lo.to(self.token.span);\n             self.bump();\n-            let mut err = self.diagnostic().struct_span_err(\n+            self.struct_span_err(\n                 sp,\n                 \"attributes cannot be applied to a function parameter's type\",\n-            );\n-            err.span_label(sp, \"attributes are not allowed here\");\n-            err.emit();\n+            )\n+            .span_label(sp, \"attributes are not allowed here\")\n+            .emit();\n         }\n     }\n \n@@ -1206,18 +1249,19 @@ impl<'a> Parser<'a> {\n         self.expect(&token::Colon)?;\n         let ty = self.parse_ty()?;\n \n-        let mut err = self.diagnostic().struct_span_err_with_code(\n-            pat.span,\n-            \"patterns aren't allowed in methods without bodies\",\n-            DiagnosticId::Error(\"E0642\".into()),\n-        );\n-        err.span_suggestion_short(\n-            pat.span,\n-            \"give this argument a name or use an underscore to ignore it\",\n-            \"_\".to_owned(),\n-            Applicability::MachineApplicable,\n-        );\n-        err.emit();\n+        self.diagnostic()\n+            .struct_span_err_with_code(\n+                pat.span,\n+                \"patterns aren't allowed in methods without bodies\",\n+                DiagnosticId::Error(\"E0642\".into()),\n+            )\n+            .span_suggestion_short(\n+                pat.span,\n+                \"give this argument a name or use an underscore to ignore it\",\n+                \"_\".to_owned(),\n+                Applicability::MachineApplicable,\n+            )\n+            .emit();\n \n         // Pretend the pattern is `_`, to avoid duplicate errors from AST validation.\n         let pat = P(Pat {"}, {"sha": "fb5ff7e8f9862f8acf4b982cd4943b1de4307c79", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 136, "deletions": 125, "changes": 261, "blob_url": "https://github.com/rust-lang/rust/blob/36029878e739f23bb774104cc3250e6f03cf8685/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36029878e739f23bb774104cc3250e6f03cf8685/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=36029878e739f23bb774104cc3250e6f03cf8685", "patch": "@@ -2329,19 +2329,19 @@ impl<'a> Parser<'a> {\n             // This is a struct literal, but we don't can't accept them here\n             let expr = self.parse_struct_expr(lo, path.clone(), attrs.clone());\n             if let (Ok(expr), false) = (&expr, struct_allowed) {\n-                let mut err = self.diagnostic().struct_span_err(\n+                self.struct_span_err(\n                     expr.span,\n                     \"struct literals are not allowed here\",\n-                );\n-                err.multipart_suggestion(\n+                )\n+                .multipart_suggestion(\n                     \"surround the struct literal with parentheses\",\n                     vec![\n                         (lo.shrink_to_lo(), \"(\".to_string()),\n                         (expr.span.shrink_to_hi(), \")\".to_string()),\n                     ],\n                     Applicability::MachineApplicable,\n-                );\n-                err.emit();\n+                )\n+                .emit();\n             }\n             return Some(expr);\n         }\n@@ -2370,18 +2370,18 @@ impl<'a> Parser<'a> {\n                     }\n                 }\n                 if self.token == token::Comma {\n-                    let mut err = self.sess.span_diagnostic.mut_span_err(\n+                    self.struct_span_err(\n                         exp_span.to(self.prev_span),\n                         \"cannot use a comma after the base struct\",\n-                    );\n-                    err.span_suggestion_short(\n+                    )\n+                    .span_suggestion_short(\n                         self.token.span,\n                         \"remove this comma\",\n                         String::new(),\n                         Applicability::MachineApplicable\n-                    );\n-                    err.note(\"the base struct must always be the last field\");\n-                    err.emit();\n+                    )\n+                    .note(\"the base struct must always be the last field\")\n+                    .emit();\n                     self.recover_stmt();\n                 }\n                 break;\n@@ -2736,15 +2736,14 @@ impl<'a> Parser<'a> {\n                 let e = self.parse_prefix_expr(None);\n                 let (span, e) = self.interpolated_or_expr_span(e)?;\n                 let span_of_tilde = lo;\n-                let mut err = self.diagnostic()\n-                    .struct_span_err(span_of_tilde, \"`~` cannot be used as a unary operator\");\n-                err.span_suggestion_short(\n-                    span_of_tilde,\n-                    \"use `!` to perform bitwise negation\",\n-                    \"!\".to_owned(),\n-                    Applicability::MachineApplicable\n-                );\n-                err.emit();\n+                self.struct_span_err(span_of_tilde, \"`~` cannot be used as a unary operator\")\n+                    .span_suggestion_short(\n+                        span_of_tilde,\n+                        \"use `!` to perform bitwise negation\",\n+                        \"!\".to_owned(),\n+                        Applicability::MachineApplicable\n+                    )\n+                    .emit();\n                 (lo.to(span), self.mk_unary(UnOp::Not, e))\n             }\n             token::BinOp(token::Minus) => {\n@@ -2792,21 +2791,20 @@ impl<'a> Parser<'a> {\n                 if cannot_continue_expr {\n                     self.bump();\n                     // Emit the error ...\n-                    let mut err = self.diagnostic()\n-                        .struct_span_err(self.token.span,\n-                                         &format!(\"unexpected {} after identifier\",\n-                                                  self.this_token_descr()));\n-                    // span the `not` plus trailing whitespace to avoid\n-                    // trailing whitespace after the `!` in our suggestion\n-                    let to_replace = self.sess.source_map()\n-                        .span_until_non_whitespace(lo.to(self.token.span));\n-                    err.span_suggestion_short(\n-                        to_replace,\n+                    self.struct_span_err(\n+                        self.token.span,\n+                        &format!(\"unexpected {} after identifier\",self.this_token_descr())\n+                    )\n+                    .span_suggestion_short(\n+                        // Span the `not` plus trailing whitespace to avoid\n+                        // trailing whitespace after the `!` in our suggestion\n+                        self.sess.source_map()\n+                            .span_until_non_whitespace(lo.to(self.token.span)),\n                         \"use `!` to perform logical negation\",\n                         \"!\".to_owned(),\n                         Applicability::MachineApplicable\n-                    );\n-                    err.emit();\n+                    )\n+                    .emit();\n                     // \u2014and recover! (just as if we were in the block\n                     // for the `token::Not` arm)\n                     let e = self.parse_prefix_expr(None);\n@@ -2884,7 +2882,7 @@ impl<'a> Parser<'a> {\n                 // We've found an expression that would be parsed as a statement, but the next\n                 // token implies this should be parsed as an expression.\n                 // For example: `if let Some(x) = x { x } else { 0 } / 2`\n-                let mut err = self.sess.span_diagnostic.struct_span_err(self.token.span, &format!(\n+                let mut err = self.struct_span_err(self.token.span, &format!(\n                     \"expected expression, found `{}`\",\n                     pprust::token_to_string(&self.token),\n                 ));\n@@ -3072,28 +3070,29 @@ impl<'a> Parser<'a> {\n                         // in AST and continue parsing.\n                         let msg = format!(\"`<` is interpreted as a start of generic \\\n                                            arguments for `{}`, not a {}\", path, op_noun);\n-                        let mut err =\n-                            self.sess.span_diagnostic.struct_span_err(self.token.span, &msg);\n                         let span_after_type = parser_snapshot_after_type.token.span;\n-                        err.span_label(self.look_ahead(1, |t| t.span).to(span_after_type),\n-                                       \"interpreted as generic arguments\");\n-                        err.span_label(self.token.span, format!(\"not interpreted as {}\", op_noun));\n-\n                         let expr = mk_expr(self, P(Ty {\n                             span: path.span,\n                             node: TyKind::Path(None, path),\n                             id: ast::DUMMY_NODE_ID\n                         }));\n \n-                        let expr_str = self.sess.source_map().span_to_snippet(expr.span)\n-                                                .unwrap_or_else(|_| pprust::expr_to_string(&expr));\n-                        err.span_suggestion(\n-                            expr.span,\n-                            &format!(\"try {} the cast value\", op_verb),\n-                            format!(\"({})\", expr_str),\n-                            Applicability::MachineApplicable\n-                        );\n-                        err.emit();\n+                        let expr_str = self.span_to_snippet(expr.span)\n+                            .unwrap_or_else(|_| pprust::expr_to_string(&expr));\n+\n+                        self.struct_span_err(self.token.span, &msg)\n+                            .span_label(\n+                                self.look_ahead(1, |t| t.span).to(span_after_type),\n+                                \"interpreted as generic arguments\"\n+                            )\n+                            .span_label(self.token.span, format!(\"not interpreted as {}\", op_noun))\n+                            .span_suggestion(\n+                                expr.span,\n+                                &format!(\"try {} the cast value\", op_verb),\n+                                format!(\"({})\", expr_str),\n+                                Applicability::MachineApplicable\n+                            )\n+                            .emit();\n \n                         Ok(expr)\n                     }\n@@ -3276,26 +3275,40 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse a 'for' .. 'in' expression ('for' token already eaten)\n-    fn parse_for_expr(&mut self, opt_label: Option<Label>,\n-                          span_lo: Span,\n-                          mut attrs: ThinVec<Attribute>) -> PResult<'a, P<Expr>> {\n+    fn parse_for_expr(\n+        &mut self,\n+        opt_label: Option<Label>,\n+        span_lo: Span,\n+        mut attrs: ThinVec<Attribute>\n+    ) -> PResult<'a, P<Expr>> {\n         // Parse: `for <src_pat> in <src_expr> <src_loop_block>`\n \n+        // Record whether we are about to parse `for (`.\n+        // This is used below for recovery in case of `for ( $stuff ) $block`\n+        // in which case we will suggest `for $stuff $block`.\n+        let begin_paren = match self.token.kind {\n+            token::OpenDelim(token::Paren) => Some(self.token.span),\n+            _ => None,\n+        };\n+\n         let pat = self.parse_top_level_pat()?;\n         if !self.eat_keyword(kw::In) {\n             let in_span = self.prev_span.between(self.token.span);\n-            let mut err = self.sess.span_diagnostic\n-                .struct_span_err(in_span, \"missing `in` in `for` loop\");\n-            err.span_suggestion_short(\n-                in_span, \"try adding `in` here\", \" in \".into(),\n-                // has been misleading, at least in the past (closed Issue #48492)\n-                Applicability::MaybeIncorrect\n-            );\n-            err.emit();\n+            self.struct_span_err(in_span, \"missing `in` in `for` loop\")\n+                .span_suggestion_short(\n+                    in_span,\n+                    \"try adding `in` here\", \" in \".into(),\n+                    // has been misleading, at least in the past (closed Issue #48492)\n+                    Applicability::MaybeIncorrect\n+                )\n+                .emit();\n         }\n         let in_span = self.prev_span;\n         self.check_for_for_in_in_typo(in_span);\n         let expr = self.parse_expr_res(Restrictions::NO_STRUCT_LITERAL, None)?;\n+\n+        let pat = self.recover_parens_around_for_head(pat, &expr, begin_paren);\n+\n         let (iattrs, loop_block) = self.parse_inner_attrs_and_block()?;\n         attrs.extend(iattrs);\n \n@@ -3522,15 +3535,14 @@ impl<'a> Parser<'a> {\n             pats.push(self.parse_top_level_pat()?);\n \n             if self.token == token::OrOr {\n-                let mut err = self.struct_span_err(self.token.span,\n-                                                   \"unexpected token `||` after pattern\");\n-                err.span_suggestion(\n-                    self.token.span,\n-                    \"use a single `|` to specify multiple patterns\",\n-                    \"|\".to_owned(),\n-                    Applicability::MachineApplicable\n-                );\n-                err.emit();\n+                self.struct_span_err(self.token.span, \"unexpected token `||` after pattern\")\n+                    .span_suggestion(\n+                        self.token.span,\n+                        \"use a single `|` to specify multiple patterns\",\n+                        \"|\".to_owned(),\n+                        Applicability::MachineApplicable\n+                    )\n+                    .emit();\n                 self.bump();\n             } else if self.eat(&token::BinOp(token::Or)) {\n                 // This is a No-op. Continue the loop to parse the next\n@@ -3627,15 +3639,14 @@ impl<'a> Parser<'a> {\n \n                 if self.token == token::DotDotDot { // Issue #46718\n                     // Accept `...` as if it were `..` to avoid further errors\n-                    let mut err = self.struct_span_err(self.token.span,\n-                                                       \"expected field pattern, found `...`\");\n-                    err.span_suggestion(\n-                        self.token.span,\n-                        \"to omit remaining fields, use one fewer `.`\",\n-                        \"..\".to_owned(),\n-                        Applicability::MachineApplicable\n-                    );\n-                    err.emit();\n+                    self.struct_span_err(self.token.span, \"expected field pattern, found `...`\")\n+                        .span_suggestion(\n+                            self.token.span,\n+                            \"to omit remaining fields, use one fewer `.`\",\n+                            \"..\".to_owned(),\n+                            Applicability::MachineApplicable\n+                        )\n+                        .emit();\n                 }\n                 self.bump();  // `..` || `...`\n \n@@ -3788,7 +3799,7 @@ impl<'a> Parser<'a> {\n             let seq_span = pat.span.to(self.prev_span);\n             let mut err = self.struct_span_err(comma_span,\n                                                \"unexpected `,` in pattern\");\n-            if let Ok(seq_snippet) = self.sess.source_map().span_to_snippet(seq_span) {\n+            if let Ok(seq_snippet) = self.span_to_snippet(seq_span) {\n                 err.span_suggestion(\n                     seq_span,\n                     \"try adding parentheses to match on a tuple..\",\n@@ -4137,7 +4148,7 @@ impl<'a> Parser<'a> {\n                     let parser_snapshot_after_type = self.clone();\n                     mem::replace(self, parser_snapshot_before_type);\n \n-                    let snippet = self.sess.source_map().span_to_snippet(pat.span).unwrap();\n+                    let snippet = self.span_to_snippet(pat.span).unwrap();\n                     err.span_label(pat.span, format!(\"while parsing the type for `{}`\", snippet));\n                     (Some((parser_snapshot_after_type, colon_sp, err)), None)\n                 }\n@@ -4557,7 +4568,7 @@ impl<'a> Parser<'a> {\n                     if self.eat(&token::Semi) {\n                         stmt_span = stmt_span.with_hi(self.prev_span.hi());\n                     }\n-                    if let Ok(snippet) = self.sess.source_map().span_to_snippet(stmt_span) {\n+                    if let Ok(snippet) = self.span_to_snippet(stmt_span) {\n                         e.span_suggestion(\n                             stmt_span,\n                             \"try placing this code inside a block\",\n@@ -4730,7 +4741,7 @@ impl<'a> Parser<'a> {\n                             lo.to(self.prev_span),\n                             \"parenthesized lifetime bounds are not supported\"\n                         );\n-                        if let Ok(snippet) = self.sess.source_map().span_to_snippet(inner_span) {\n+                        if let Ok(snippet) = self.span_to_snippet(inner_span) {\n                             err.span_suggestion_short(\n                                 lo.to(self.prev_span),\n                                 \"remove the parentheses\",\n@@ -4788,7 +4799,7 @@ impl<'a> Parser<'a> {\n                 let mut new_bound_list = String::new();\n                 if !bounds.is_empty() {\n                     let mut snippets = bounds.iter().map(|bound| bound.span())\n-                        .map(|span| self.sess.source_map().span_to_snippet(span));\n+                        .map(|span| self.span_to_snippet(span));\n                     while let Some(Ok(snippet)) = snippets.next() {\n                         new_bound_list.push_str(\" + \");\n                         new_bound_list.push_str(&snippet);\n@@ -5853,15 +5864,16 @@ impl<'a> Parser<'a> {\n                 if let token::DocComment(_) = self.token.kind {\n                     if self.look_ahead(1,\n                     |tok| tok == &token::CloseDelim(token::Brace)) {\n-                        let mut err = self.diagnostic().struct_span_err_with_code(\n+                        self.diagnostic().struct_span_err_with_code(\n                             self.token.span,\n                             \"found a documentation comment that doesn't document anything\",\n                             DiagnosticId::Error(\"E0584\".into()),\n-                        );\n-                        err.help(\"doc comments must come before what they document, maybe a \\\n+                        )\n+                        .help(\n+                            \"doc comments must come before what they document, maybe a \\\n                             comment was intended with `//`?\",\n-                        );\n-                        err.emit();\n+                        )\n+                        .emit();\n                         self.bump();\n                         continue;\n                     }\n@@ -6305,12 +6317,15 @@ impl<'a> Parser<'a> {\n                 let sp = path.span;\n                 let help_msg = format!(\"make this visible only to module `{}` with `in`\", path);\n                 self.expect(&token::CloseDelim(token::Paren))?;  // `)`\n-                let mut err = struct_span_err!(self.sess.span_diagnostic, sp, E0704, \"{}\", msg);\n-                err.help(suggestion);\n-                err.span_suggestion(\n-                    sp, &help_msg, format!(\"in {}\", path), Applicability::MachineApplicable\n-                );\n-                err.emit();  // emit diagnostic, but continue with public visibility\n+                struct_span_err!(self.sess.span_diagnostic, sp, E0704, \"{}\", msg)\n+                    .help(suggestion)\n+                    .span_suggestion(\n+                        sp,\n+                        &help_msg,\n+                        format!(\"in {}\", path),\n+                        Applicability::MachineApplicable,\n+                    )\n+                    .emit();  // emit diagnostic, but continue with public visibility\n             }\n         }\n \n@@ -6744,14 +6759,10 @@ impl<'a> Parser<'a> {\n             }\n             ident = Ident::from_str(&fixed_name).with_span_pos(fixed_name_sp);\n \n-            let mut err = self.struct_span_err(fixed_name_sp, error_msg);\n-            err.span_label(fixed_name_sp, \"dash-separated idents are not valid\");\n-            err.multipart_suggestion(\n-                suggestion_msg,\n-                replacement,\n-                Applicability::MachineApplicable,\n-            );\n-            err.emit();\n+            self.struct_span_err(fixed_name_sp, error_msg)\n+                .span_label(fixed_name_sp, \"dash-separated idents are not valid\")\n+                .multipart_suggestion(suggestion_msg, replacement, Applicability::MachineApplicable)\n+                .emit();\n         }\n         Ok(ident)\n     }\n@@ -6906,14 +6917,14 @@ impl<'a> Parser<'a> {\n             if !self.eat(&token::Comma) {\n                 if self.token.is_ident() && !self.token.is_reserved_ident() {\n                     let sp = self.sess.source_map().next_point(self.prev_span);\n-                    let mut err = self.struct_span_err(sp, \"missing comma\");\n-                    err.span_suggestion_short(\n-                        sp,\n-                        \"missing comma\",\n-                        \",\".to_owned(),\n-                        Applicability::MaybeIncorrect,\n-                    );\n-                    err.emit();\n+                    self.struct_span_err(sp, \"missing comma\")\n+                        .span_suggestion_short(\n+                            sp,\n+                            \"missing comma\",\n+                            \",\".to_owned(),\n+                            Applicability::MaybeIncorrect,\n+                        )\n+                        .emit();\n                 } else {\n                     break;\n                 }\n@@ -6952,15 +6963,16 @@ impl<'a> Parser<'a> {\n                     Some(abi) => Ok(Some(abi)),\n                     None => {\n                         let prev_span = self.prev_span;\n-                        let mut err = struct_span_err!(\n+                        struct_span_err!(\n                             self.sess.span_diagnostic,\n                             prev_span,\n                             E0703,\n                             \"invalid ABI: found `{}`\",\n-                            symbol);\n-                        err.span_label(prev_span, \"invalid ABI\");\n-                        err.help(&format!(\"valid ABIs: {}\", abi::all_names().join(\", \")));\n-                        err.emit();\n+                            symbol\n+                        )\n+                        .span_label(prev_span, \"invalid ABI\")\n+                        .help(&format!(\"valid ABIs: {}\", abi::all_names().join(\", \")))\n+                        .emit();\n                         Ok(None)\n                     }\n                 }\n@@ -7130,16 +7142,15 @@ impl<'a> Parser<'a> {\n             // CONST ITEM\n             if self.eat_keyword(kw::Mut) {\n                 let prev_span = self.prev_span;\n-                let mut err = self.diagnostic()\n-                    .struct_span_err(prev_span, \"const globals cannot be mutable\");\n-                err.span_label(prev_span, \"cannot be mutable\");\n-                err.span_suggestion(\n-                    const_span,\n-                    \"you might want to declare a static instead\",\n-                    \"static\".to_owned(),\n-                    Applicability::MaybeIncorrect,\n-                );\n-                err.emit();\n+                self.struct_span_err(prev_span, \"const globals cannot be mutable\")\n+                    .span_label(prev_span, \"cannot be mutable\")\n+                    .span_suggestion(\n+                        const_span,\n+                        \"you might want to declare a static instead\",\n+                        \"static\".to_owned(),\n+                        Applicability::MaybeIncorrect,\n+                    )\n+                    .emit();\n             }\n             let (ident, item_, extra_attrs) = self.parse_item_const(None)?;\n             let prev_span = self.prev_span;\n@@ -7407,7 +7418,7 @@ impl<'a> Parser<'a> {\n                         sp, &suggestion, format!(\" {} \", kw), Applicability::MachineApplicable\n                     );\n                 } else {\n-                    if let Ok(snippet) = self.sess.source_map().span_to_snippet(ident_sp) {\n+                    if let Ok(snippet) = self.span_to_snippet(ident_sp) {\n                         err.span_suggestion(\n                             full_sp,\n                             \"if you meant to call a macro, try\","}, {"sha": "e6c59fcf22dea3a04b8101970db9a995b9a78df8", "filename": "src/test/ui/parser/recover-for-loop-parens-around-head.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/36029878e739f23bb774104cc3250e6f03cf8685/src%2Ftest%2Fui%2Fparser%2Frecover-for-loop-parens-around-head.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36029878e739f23bb774104cc3250e6f03cf8685/src%2Ftest%2Fui%2Fparser%2Frecover-for-loop-parens-around-head.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Frecover-for-loop-parens-around-head.rs?ref=36029878e739f23bb774104cc3250e6f03cf8685", "patch": "@@ -0,0 +1,15 @@\n+// Here we test that the parser is able to recover in a situation like\n+// `for ( $pat in $expr )` since that is familiar syntax in other languages.\n+// Instead we suggest that the user writes `for $pat in $expr`.\n+\n+#![deny(unused)] // Make sure we don't trigger `unused_parens`.\n+\n+fn main() {\n+    let vec = vec![1, 2, 3];\n+\n+    for ( elem in vec ) {\n+        //~^ ERROR expected one of `)`, `,`, or `@`, found `in`\n+        //~| ERROR unexpected closing `)`\n+        const RECOVERY_WITNESS: () = 0; //~ ERROR mismatched types\n+    }\n+}"}, {"sha": "c160e646c28b34821efdebbe8201008a8eaafca1", "filename": "src/test/ui/parser/recover-for-loop-parens-around-head.stderr", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/36029878e739f23bb774104cc3250e6f03cf8685/src%2Ftest%2Fui%2Fparser%2Frecover-for-loop-parens-around-head.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/36029878e739f23bb774104cc3250e6f03cf8685/src%2Ftest%2Fui%2Fparser%2Frecover-for-loop-parens-around-head.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Frecover-for-loop-parens-around-head.stderr?ref=36029878e739f23bb774104cc3250e6f03cf8685", "patch": "@@ -0,0 +1,27 @@\n+error: expected one of `)`, `,`, or `@`, found `in`\n+  --> $DIR/recover-for-loop-parens-around-head.rs:10:16\n+   |\n+LL |     for ( elem in vec ) {\n+   |                ^^ expected one of `)`, `,`, or `@` here\n+\n+error: unexpected closing `)`\n+  --> $DIR/recover-for-loop-parens-around-head.rs:10:23\n+   |\n+LL |     for ( elem in vec ) {\n+   |         --------------^\n+   |         |\n+   |         opening `(`\n+   |         help: remove parenthesis in `for` loop: `elem in vec`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/recover-for-loop-parens-around-head.rs:13:38\n+   |\n+LL |         const RECOVERY_WITNESS: () = 0;\n+   |                                      ^ expected (), found integer\n+   |\n+   = note: expected type `()`\n+              found type `{integer}`\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0308`."}]}