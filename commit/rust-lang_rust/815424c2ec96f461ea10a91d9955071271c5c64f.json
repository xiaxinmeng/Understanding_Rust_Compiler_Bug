{"sha": "815424c2ec96f461ea10a91d9955071271c5c64f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgxNTQyNGMyZWM5NmY0NjFlYTEwYTkxZDk5NTUwNzEyNzFjNWM2NGY=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-08-04T20:44:09Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-08-04T20:44:22Z"}, "message": "Fix pexp parser to do left-associativity, not right. Closes #130.", "tree": {"sha": "84f25ec0a71efc717392364513179db64a0db301", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/84f25ec0a71efc717392364513179db64a0db301"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/815424c2ec96f461ea10a91d9955071271c5c64f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/815424c2ec96f461ea10a91d9955071271c5c64f", "html_url": "https://github.com/rust-lang/rust/commit/815424c2ec96f461ea10a91d9955071271c5c64f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/815424c2ec96f461ea10a91d9955071271c5c64f/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1a8d609e89ed647204b68bfe40e83357644476cb", "url": "https://api.github.com/repos/rust-lang/rust/commits/1a8d609e89ed647204b68bfe40e83357644476cb", "html_url": "https://github.com/rust-lang/rust/commit/1a8d609e89ed647204b68bfe40e83357644476cb"}], "stats": {"total": 127, "additions": 91, "deletions": 36}, "files": [{"sha": "674159896ae11dc02a92cfef5f652f2ab8fdb11a", "filename": "src/Makefile", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/815424c2ec96f461ea10a91d9955071271c5c64f/src%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/815424c2ec96f461ea10a91d9955071271c5c64f/src%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FMakefile?ref=815424c2ec96f461ea10a91d9955071271c5c64f", "patch": "@@ -489,6 +489,7 @@ TEST_XFAILS_LLVM := $(TASK_XFAILS) \\\n                       obj-recursion.rs \\\n                       obj-return-polytypes.rs \\\n                       obj-with-vec.rs \\\n+                      operator-associativity.rs \\\n                       output-slot-variants.rs \\\n                       pred.rs \\\n                       preempt.rs \\"}, {"sha": "fb2d91a05bab89d2bff2ad656318da114d21585c", "filename": "src/boot/fe/pexp.ml", "status": "modified", "additions": 86, "deletions": 36, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/815424c2ec96f461ea10a91d9955071271c5c64f/src%2Fboot%2Ffe%2Fpexp.ml", "raw_url": "https://github.com/rust-lang/rust/raw/815424c2ec96f461ea10a91d9955071271c5c64f/src%2Fboot%2Ffe%2Fpexp.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Ffe%2Fpexp.ml?ref=815424c2ec96f461ea10a91d9955071271c5c64f", "patch": "@@ -718,142 +718,192 @@ and parse_negation_pexp (ps:pstate) : pexp =\n \n (* Binops are all left-associative,                *)\n (* so we factor out some of the parsing code here. *)\n-and binop_rhs\n+and binop_build\n     (ps:pstate)\n     (name:string)\n     (apos:pos)\n-    (lhs:pexp)\n     (rhs_parse_fn:pstate -> pexp)\n+    (lhs:pexp)\n+    (step_fn:pexp -> pexp)\n     (op:Ast.binop)\n     : pexp =\n   bump ps;\n   let rhs = (ctxt (name ^ \" rhs\") rhs_parse_fn ps) in\n   let bpos = lexpos ps in\n-    span ps apos bpos (PEXP_binop (op, lhs, rhs))\n+  let node = span ps apos bpos (PEXP_binop (op, lhs, rhs)) in\n+    step_fn node\n \n \n and parse_factor_pexp (ps:pstate) : pexp =\n   let name = \"factor pexp\" in\n   let apos = lexpos ps in\n   let lhs = ctxt (name ^ \" lhs\") parse_negation_pexp ps in\n+  let build = binop_build ps name apos parse_negation_pexp in\n+  let rec step accum =\n     match peek ps with\n-        STAR    -> binop_rhs ps name apos lhs parse_factor_pexp Ast.BINOP_mul\n-      | SLASH   -> binop_rhs ps name apos lhs parse_factor_pexp Ast.BINOP_div\n-      | PERCENT -> binop_rhs ps name apos lhs parse_factor_pexp Ast.BINOP_mod\n-      | _       -> lhs\n+        STAR    -> build accum step Ast.BINOP_mul\n+      | SLASH   -> build accum step Ast.BINOP_div\n+      | PERCENT -> build accum step Ast.BINOP_mod\n+      | _       -> accum\n+  in\n+    step lhs\n \n \n and parse_term_pexp (ps:pstate) : pexp =\n   let name = \"term pexp\" in\n   let apos = lexpos ps in\n   let lhs = ctxt (name ^ \" lhs\") parse_factor_pexp ps in\n+  let build = binop_build ps name apos parse_factor_pexp in\n+  let rec step accum =\n     match peek ps with\n-        PLUS  -> binop_rhs ps name apos lhs parse_term_pexp Ast.BINOP_add\n-      | MINUS -> binop_rhs ps name apos lhs parse_term_pexp Ast.BINOP_sub\n-      | _     -> lhs\n+        PLUS  -> build accum step Ast.BINOP_add\n+      | MINUS -> build accum step Ast.BINOP_sub\n+      | _     -> accum\n+  in\n+    step lhs\n \n \n and parse_shift_pexp (ps:pstate) : pexp =\n   let name = \"shift pexp\" in\n   let apos = lexpos ps in\n   let lhs = ctxt (name ^ \" lhs\") parse_term_pexp ps in\n+  let build = binop_build ps name apos parse_term_pexp in\n+  let rec step accum =\n     match peek ps with\n-        LSL -> binop_rhs ps name apos lhs parse_shift_pexp Ast.BINOP_lsl\n-      | LSR -> binop_rhs ps name apos lhs parse_shift_pexp Ast.BINOP_lsr\n-      | ASR -> binop_rhs ps name apos lhs parse_shift_pexp Ast.BINOP_asr\n-      | _ -> lhs\n+        LSL -> build accum step Ast.BINOP_lsl\n+      | LSR -> build accum step Ast.BINOP_lsr\n+      | ASR -> build accum step Ast.BINOP_asr\n+      | _   -> accum\n+  in\n+    step lhs\n \n \n and parse_and_pexp (ps:pstate) : pexp =\n   let name = \"and pexp\" in\n   let apos = lexpos ps in\n   let lhs = ctxt (name ^ \" lhs\") parse_shift_pexp ps in\n+  let build = binop_build ps name apos parse_shift_pexp in\n+  let rec step accum =\n     match peek ps with\n-        AND -> binop_rhs ps name apos lhs parse_and_pexp Ast.BINOP_and\n-      | _   -> lhs\n+        AND -> build accum step Ast.BINOP_and\n+      | _   -> accum\n+  in\n+    step lhs\n \n \n and parse_xor_pexp (ps:pstate) : pexp =\n   let name = \"xor pexp\" in\n   let apos = lexpos ps in\n   let lhs = ctxt (name ^ \" lhs\") parse_and_pexp ps in\n+  let build = binop_build ps name apos parse_and_pexp in\n+  let rec step accum =\n     match peek ps with\n-        CARET -> binop_rhs ps name apos lhs parse_xor_pexp Ast.BINOP_xor\n-      | _ -> lhs\n+        CARET -> build accum step Ast.BINOP_xor\n+      | _     -> accum\n+  in\n+    step lhs\n \n \n and parse_or_pexp (ps:pstate) : pexp =\n   let name = \"or pexp\" in\n   let apos = lexpos ps in\n   let lhs = ctxt (name ^ \" lhs\") parse_xor_pexp ps in\n+  let build = binop_build ps name apos parse_xor_pexp in\n+  let rec step accum =\n     match peek ps with\n-        OR -> binop_rhs ps name apos lhs parse_or_pexp Ast.BINOP_or\n-      | _  -> lhs\n+        OR -> build accum step Ast.BINOP_or\n+      | _  -> accum\n+  in\n+    step lhs\n \n \n and parse_relational_pexp (ps:pstate) : pexp =\n   let name = \"relational pexp\" in\n   let apos = lexpos ps in\n   let lhs = ctxt (name ^ \" lhs\") parse_or_pexp ps in\n+  let build = binop_build ps name apos parse_or_pexp in\n+  let rec step accum =\n     match peek ps with\n-        LT -> binop_rhs ps name apos lhs parse_relational_pexp Ast.BINOP_lt\n-      | LE -> binop_rhs ps name apos lhs parse_relational_pexp Ast.BINOP_le\n-      | GE -> binop_rhs ps name apos lhs parse_relational_pexp Ast.BINOP_ge\n-      | GT -> binop_rhs ps name apos lhs parse_relational_pexp Ast.BINOP_gt\n-      | _  -> lhs\n+        LT -> build accum step Ast.BINOP_lt\n+      | LE -> build accum step Ast.BINOP_le\n+      | GE -> build accum step Ast.BINOP_ge\n+      | GT -> build accum step Ast.BINOP_gt\n+      | _  -> accum\n+  in\n+    step lhs\n \n \n and parse_equality_pexp (ps:pstate) : pexp =\n   let name = \"equality pexp\" in\n   let apos = lexpos ps in\n   let lhs = ctxt (name ^ \" lhs\") parse_relational_pexp ps in\n+  let build = binop_build ps name apos parse_relational_pexp in\n+  let rec step accum =\n     match peek ps with\n-        EQEQ -> binop_rhs ps name apos lhs parse_equality_pexp Ast.BINOP_eq\n-      | NE   -> binop_rhs ps name apos lhs parse_equality_pexp Ast.BINOP_ne\n-      | _    -> lhs\n+        EQEQ -> build accum step Ast.BINOP_eq\n+      | NE   -> build accum step Ast.BINOP_ne\n+      | _    -> accum\n+  in\n+    step lhs\n \n \n and parse_andand_pexp (ps:pstate) : pexp =\n   let name = \"andand pexp\" in\n   let apos = lexpos ps in\n   let lhs = ctxt (name ^ \" lhs\") parse_equality_pexp ps in\n+  let rec step accum =\n     match peek ps with\n         ANDAND ->\n           bump ps;\n-          let rhs = parse_andand_pexp ps in\n+          let rhs = parse_equality_pexp ps in\n           let bpos = lexpos ps in\n-            span ps apos bpos (PEXP_lazy_and (lhs, rhs))\n+          let node = span ps apos bpos (PEXP_lazy_and (accum, rhs)) in\n+            step node\n \n-      | _   -> lhs\n+      | _   -> accum\n+  in\n+    step lhs\n \n \n and parse_oror_pexp (ps:pstate) : pexp =\n   let name = \"oror pexp\" in\n   let apos = lexpos ps in\n   let lhs = ctxt (name ^ \" lhs\") parse_andand_pexp ps in\n+  let rec step accum =\n     match peek ps with\n         OROR ->\n           bump ps;\n-          let rhs = parse_oror_pexp ps in\n+          let rhs = parse_andand_pexp ps in\n           let bpos = lexpos ps in\n-            span ps apos bpos (PEXP_lazy_or (lhs, rhs))\n+          let node = span ps apos bpos (PEXP_lazy_or (accum, rhs)) in\n+            step node\n+\n+      | _  -> accum\n+  in\n+    step lhs\n \n-      | _  -> lhs\n \n and parse_as_pexp (ps:pstate) : pexp =\n   let apos = lexpos ps in\n   let pexp = ctxt \"as pexp\" parse_oror_pexp ps in\n+  let rec step accum =\n     match peek ps with\n         AS ->\n           bump ps;\n           let tapos = lexpos ps in\n           let t = parse_ty ps in\n           let bpos = lexpos ps in\n           let t = span ps tapos bpos t in\n+          let node =\n             span ps apos bpos\n-              (PEXP_unop ((Ast.UNOP_cast t), pexp))\n+              (PEXP_unop ((Ast.UNOP_cast t), accum))\n+          in\n+            step node\n+\n+      | _ -> accum\n+  in\n+    step pexp\n \n-      | _       -> pexp\n \n and parse_pexp (ps:pstate) : pexp =\n   parse_as_pexp ps"}, {"sha": "2c028eba627c6ea93ee731fd4b874e041bf8e764", "filename": "src/test/run-pass/operator-associativity.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/815424c2ec96f461ea10a91d9955071271c5c64f/src%2Ftest%2Frun-pass%2Foperator-associativity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/815424c2ec96f461ea10a91d9955071271c5c64f/src%2Ftest%2Frun-pass%2Foperator-associativity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foperator-associativity.rs?ref=815424c2ec96f461ea10a91d9955071271c5c64f", "patch": "@@ -0,0 +1,4 @@\n+// Testcase for issue #130, operator associativity.\n+fn main() -> () {\n+  check ((3 * 5 / 2) == 7);\n+}"}]}