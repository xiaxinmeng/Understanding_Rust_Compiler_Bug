{"sha": "f4008fe94935d05ffb3a48fc5b7149070bb45550", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY0MDA4ZmU5NDkzNWQwNWZmYjNhNDhmYzViNzE0OTA3MGJiNDU1NTA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-02-09T05:57:18Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-02-09T05:57:18Z"}, "message": "Auto merge of #81905 - Dylan-DPC:rollup-mxpz1j7, r=Dylan-DPC\n\nRollup of 11 pull requests\n\nSuccessful merges:\n\n - #72209 (Add checking for no_mangle to unsafe_code lint)\n - #80732 (Allow Trait inheritance with cycles on associated types take 2)\n - #81697 (Add \"every\" as a doc alias for \"all\".)\n - #81826 (Prefer match over combinators to make some Box methods inlineable)\n - #81834 (Resolve typedef in HashMap lldb pretty-printer only if possible)\n - #81841 ([rustbuild] Output rustdoc-json-types docs )\n - #81849 (Expand the docs for ops::ControlFlow a bit)\n - #81876 (parser: Fix panic in 'const impl' recovery)\n - #81882 (:arrow_up: rust-analyzer)\n - #81888 (Fix pretty printer macro_rules with semicolon.)\n - #81896 (Remove outdated comment in windows' mutex.rs)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "fbc9bd43c3b0c1ce5e27a01c0541f7b69a9838fc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fbc9bd43c3b0c1ce5e27a01c0541f7b69a9838fc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f4008fe94935d05ffb3a48fc5b7149070bb45550", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f4008fe94935d05ffb3a48fc5b7149070bb45550", "html_url": "https://github.com/rust-lang/rust/commit/f4008fe94935d05ffb3a48fc5b7149070bb45550", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f4008fe94935d05ffb3a48fc5b7149070bb45550/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "36931ce3d90e1927e8589d973cc8d18103ede460", "url": "https://api.github.com/repos/rust-lang/rust/commits/36931ce3d90e1927e8589d973cc8d18103ede460", "html_url": "https://github.com/rust-lang/rust/commit/36931ce3d90e1927e8589d973cc8d18103ede460"}, {"sha": "d2e204d1586e7ecee99a24657f6cbc1a9ac6561d", "url": "https://api.github.com/repos/rust-lang/rust/commits/d2e204d1586e7ecee99a24657f6cbc1a9ac6561d", "html_url": "https://github.com/rust-lang/rust/commit/d2e204d1586e7ecee99a24657f6cbc1a9ac6561d"}], "stats": {"total": 1101, "additions": 919, "deletions": 182}, "files": [{"sha": "01e234c9be972ed21d931bb435fe523c0c72da9a", "filename": "compiler/rustc_ast_pretty/src/pprust/state.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f4008fe94935d05ffb3a48fc5b7149070bb45550/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4008fe94935d05ffb3a48fc5b7149070bb45550/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs?ref=f4008fe94935d05ffb3a48fc5b7149070bb45550", "patch": "@@ -1311,6 +1311,9 @@ impl<'a> State<'a> {\n                     true,\n                     item.span,\n                 );\n+                if macro_def.body.need_semicolon() {\n+                    self.word(\";\");\n+                }\n             }\n         }\n         self.ann.post(self, AnnNode::Item(item))"}, {"sha": "87684c2715f4ef0541b3793af691a26d51c2d66f", "filename": "compiler/rustc_infer/src/traits/util.rs", "status": "modified", "additions": 40, "deletions": 1, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/f4008fe94935d05ffb3a48fc5b7149070bb45550/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4008fe94935d05ffb3a48fc5b7149070bb45550/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs?ref=f4008fe94935d05ffb3a48fc5b7149070bb45550", "patch": "@@ -1,9 +1,10 @@\n use smallvec::smallvec;\n \n use crate::traits::{Obligation, ObligationCause, PredicateObligation};\n-use rustc_data_structures::fx::FxHashSet;\n+use rustc_data_structures::fx::{FxHashSet, FxIndexSet};\n use rustc_middle::ty::outlives::Component;\n use rustc_middle::ty::{self, ToPredicate, TyCtxt, WithConstness};\n+use rustc_span::symbol::Ident;\n \n pub fn anonymize_predicate<'tcx>(\n     tcx: TyCtxt<'tcx>,\n@@ -282,6 +283,44 @@ pub fn transitive_bounds<'tcx>(\n     elaborate_trait_refs(tcx, bounds).filter_to_traits()\n }\n \n+/// A specialized variant of `elaborate_trait_refs` that only elaborates trait references that may\n+/// define the given associated type `assoc_name`. It uses the\n+/// `super_predicates_that_define_assoc_type` query to avoid enumerating super-predicates that\n+/// aren't related to `assoc_item`.  This is used when resolving types like `Self::Item` or\n+/// `T::Item` and helps to avoid cycle errors (see e.g. #35237).\n+pub fn transitive_bounds_that_define_assoc_type<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    bounds: impl Iterator<Item = ty::PolyTraitRef<'tcx>>,\n+    assoc_name: Ident,\n+) -> impl Iterator<Item = ty::PolyTraitRef<'tcx>> {\n+    let mut stack: Vec<_> = bounds.collect();\n+    let mut visited = FxIndexSet::default();\n+\n+    std::iter::from_fn(move || {\n+        while let Some(trait_ref) = stack.pop() {\n+            let anon_trait_ref = tcx.anonymize_late_bound_regions(trait_ref);\n+            if visited.insert(anon_trait_ref) {\n+                let super_predicates = tcx.super_predicates_that_define_assoc_type((\n+                    trait_ref.def_id(),\n+                    Some(assoc_name),\n+                ));\n+                for (super_predicate, _) in super_predicates.predicates {\n+                    let bound_predicate = super_predicate.kind();\n+                    let subst_predicate = super_predicate\n+                        .subst_supertrait(tcx, &bound_predicate.rebind(trait_ref.skip_binder()));\n+                    if let Some(binder) = subst_predicate.to_opt_poly_trait_ref() {\n+                        stack.push(binder.value);\n+                    }\n+                }\n+\n+                return Some(trait_ref);\n+            }\n+        }\n+\n+        return None;\n+    })\n+}\n+\n ///////////////////////////////////////////////////////////////////////////\n // Other\n ///////////////////////////////////////////////////////////////////////////"}, {"sha": "20f581625dc315cb2ab815d2892d2c6541d2a853", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/f4008fe94935d05ffb3a48fc5b7149070bb45550/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4008fe94935d05ffb3a48fc5b7149070bb45550/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=f4008fe94935d05ffb3a48fc5b7149070bb45550", "patch": "@@ -328,6 +328,18 @@ impl UnsafeCode {\n \n         cx.struct_span_lint(UNSAFE_CODE, span, decorate);\n     }\n+\n+    fn report_overriden_symbol_name(&self, cx: &EarlyContext<'_>, span: Span, msg: &str) {\n+        self.report_unsafe(cx, span, |lint| {\n+            lint.build(msg)\n+                .note(\n+                    \"the linker's behavior with multiple libraries exporting duplicate symbol \\\n+                    names is undefined and Rust cannot provide guarantees when you manually \\\n+                    override them\",\n+                )\n+                .emit();\n+        })\n+    }\n }\n \n impl EarlyLintPass for UnsafeCode {\n@@ -367,6 +379,40 @@ impl EarlyLintPass for UnsafeCode {\n                     lint.build(\"implementation of an `unsafe` trait\").emit()\n                 }),\n \n+            ast::ItemKind::Fn(..) => {\n+                if let Some(attr) = cx.sess().find_by_name(&it.attrs, sym::no_mangle) {\n+                    self.report_overriden_symbol_name(\n+                        cx,\n+                        attr.span,\n+                        \"declaration of a `no_mangle` function\",\n+                    );\n+                }\n+                if let Some(attr) = cx.sess().find_by_name(&it.attrs, sym::export_name) {\n+                    self.report_overriden_symbol_name(\n+                        cx,\n+                        attr.span,\n+                        \"declaration of a function with `export_name`\",\n+                    );\n+                }\n+            }\n+\n+            ast::ItemKind::Static(..) => {\n+                if let Some(attr) = cx.sess().find_by_name(&it.attrs, sym::no_mangle) {\n+                    self.report_overriden_symbol_name(\n+                        cx,\n+                        attr.span,\n+                        \"declaration of a `no_mangle` static\",\n+                    );\n+                }\n+                if let Some(attr) = cx.sess().find_by_name(&it.attrs, sym::export_name) {\n+                    self.report_overriden_symbol_name(\n+                        cx,\n+                        attr.span,\n+                        \"declaration of a static with `export_name`\",\n+                    );\n+                }\n+            }\n+\n             _ => {}\n         }\n     }"}, {"sha": "f0166ec21672b06347f66d0a650bec964eb858cc", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f4008fe94935d05ffb3a48fc5b7149070bb45550/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4008fe94935d05ffb3a48fc5b7149070bb45550/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=f4008fe94935d05ffb3a48fc5b7149070bb45550", "patch": "@@ -442,12 +442,23 @@ rustc_queries! {\n     /// full predicates are available (note that supertraits have\n     /// additional acyclicity requirements).\n     query super_predicates_of(key: DefId) -> ty::GenericPredicates<'tcx> {\n-        desc { |tcx| \"computing the supertraits of `{}`\", tcx.def_path_str(key) }\n+        desc { |tcx| \"computing the super predicates of `{}`\", tcx.def_path_str(key) }\n+    }\n+\n+    /// The `Option<Ident>` is the name of an associated type. If it is `None`, then this query\n+    /// returns the full set of predicates. If `Some<Ident>`, then the query returns only the\n+    /// subset of super-predicates that reference traits that define the given associated type.\n+    /// This is used to avoid cycles in resolving types like `T::Item`.\n+    query super_predicates_that_define_assoc_type(key: (DefId, Option<rustc_span::symbol::Ident>)) -> ty::GenericPredicates<'tcx> {\n+        desc { |tcx| \"computing the super traits of `{}`{}\",\n+            tcx.def_path_str(key.0),\n+            if let Some(assoc_name) = key.1 { format!(\" with associated type name `{}`\", assoc_name) } else { \"\".to_string() },\n+        }\n     }\n \n     /// To avoid cycles within the predicates of a single item we compute\n     /// per-type-parameter predicates for resolving `T::AssocTy`.\n-    query type_param_predicates(key: (DefId, LocalDefId)) -> ty::GenericPredicates<'tcx> {\n+    query type_param_predicates(key: (DefId, LocalDefId, rustc_span::symbol::Ident)) -> ty::GenericPredicates<'tcx> {\n         desc { |tcx| \"computing the bounds for type parameter `{}`\", {\n             let id = tcx.hir().local_def_id_to_hir_id(key.1);\n             tcx.hir().ty_param_name(id)"}, {"sha": "f83056ebe2a4573ce37e325e45ade172de9bfa8d", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 37, "deletions": 1, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/f4008fe94935d05ffb3a48fc5b7149070bb45550/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4008fe94935d05ffb3a48fc5b7149070bb45550/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=f4008fe94935d05ffb3a48fc5b7149070bb45550", "patch": "@@ -52,7 +52,7 @@ use rustc_session::config::{BorrowckMode, CrateType, OutputFilenames};\n use rustc_session::lint::{Level, Lint};\n use rustc_session::Session;\n use rustc_span::source_map::MultiSpan;\n-use rustc_span::symbol::{kw, sym, Symbol};\n+use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{Span, DUMMY_SP};\n use rustc_target::abi::{Layout, TargetDataLayout, VariantIdx};\n use rustc_target::spec::abi;\n@@ -2053,6 +2053,42 @@ impl<'tcx> TyCtxt<'tcx> {\n         self.mk_fn_ptr(sig.map_bound(|sig| ty::FnSig { unsafety: hir::Unsafety::Unsafe, ..sig }))\n     }\n \n+    /// Given the def_id of a Trait `trait_def_id` and the name of an associated item `assoc_name`\n+    /// returns true if the `trait_def_id` defines an associated item of name `assoc_name`.\n+    pub fn trait_may_define_assoc_type(self, trait_def_id: DefId, assoc_name: Ident) -> bool {\n+        self.super_traits_of(trait_def_id).any(|trait_did| {\n+            self.associated_items(trait_did)\n+                .find_by_name_and_kind(self, assoc_name, ty::AssocKind::Type, trait_did)\n+                .is_some()\n+        })\n+    }\n+\n+    /// Computes the def-ids of the transitive super-traits of `trait_def_id`. This (intentionally)\n+    /// does not compute the full elaborated super-predicates but just the set of def-ids. It is used\n+    /// to identify which traits may define a given associated type to help avoid cycle errors.\n+    /// Returns a `DefId` iterator.\n+    fn super_traits_of(self, trait_def_id: DefId) -> impl Iterator<Item = DefId> + 'tcx {\n+        let mut set = FxHashSet::default();\n+        let mut stack = vec![trait_def_id];\n+\n+        set.insert(trait_def_id);\n+\n+        iter::from_fn(move || -> Option<DefId> {\n+            let trait_did = stack.pop()?;\n+            let generic_predicates = self.super_predicates_of(trait_did);\n+\n+            for (predicate, _) in generic_predicates.predicates {\n+                if let ty::PredicateKind::Trait(data, _) = predicate.kind().skip_binder() {\n+                    if set.insert(data.def_id()) {\n+                        stack.push(data.def_id());\n+                    }\n+                }\n+            }\n+\n+            Some(trait_did)\n+        })\n+    }\n+\n     /// Given a closure signature, returns an equivalent fn signature. Detuples\n     /// and so forth -- so e.g., if we have a sig with `Fn<(u32, i32)>` then\n     /// you would get a `fn(u32, i32)`."}, {"sha": "6b4714b1bb8c84d8601d304bd1deecb2566492a5", "filename": "compiler/rustc_middle/src/ty/query/keys.rs", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f4008fe94935d05ffb3a48fc5b7149070bb45550/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fkeys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4008fe94935d05ffb3a48fc5b7149070bb45550/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fkeys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fkeys.rs?ref=f4008fe94935d05ffb3a48fc5b7149070bb45550", "patch": "@@ -7,7 +7,7 @@ use crate::ty::subst::{GenericArg, SubstsRef};\n use crate::ty::{self, Ty, TyCtxt};\n use rustc_hir::def_id::{CrateNum, DefId, LocalDefId, LOCAL_CRATE};\n use rustc_query_system::query::DefaultCacheSelector;\n-use rustc_span::symbol::Symbol;\n+use rustc_span::symbol::{Ident, Symbol};\n use rustc_span::{Span, DUMMY_SP};\n \n /// The `Key` trait controls what types can legally be used as the key\n@@ -160,6 +160,28 @@ impl Key for (LocalDefId, DefId) {\n     }\n }\n \n+impl Key for (DefId, Option<Ident>) {\n+    type CacheSelector = DefaultCacheSelector;\n+\n+    fn query_crate(&self) -> CrateNum {\n+        self.0.krate\n+    }\n+    fn default_span(&self, tcx: TyCtxt<'_>) -> Span {\n+        tcx.def_span(self.0)\n+    }\n+}\n+\n+impl Key for (DefId, LocalDefId, Ident) {\n+    type CacheSelector = DefaultCacheSelector;\n+\n+    fn query_crate(&self) -> CrateNum {\n+        self.0.krate\n+    }\n+    fn default_span(&self, tcx: TyCtxt<'_>) -> Span {\n+        self.1.default_span(tcx)\n+    }\n+}\n+\n impl Key for (CrateNum, DefId) {\n     type CacheSelector = DefaultCacheSelector;\n "}, {"sha": "ee2428624146848b069bc671a26aa102138d3412", "filename": "compiler/rustc_parse/src/parser/item.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f4008fe94935d05ffb3a48fc5b7149070bb45550/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4008fe94935d05ffb3a48fc5b7149070bb45550/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs?ref=f4008fe94935d05ffb3a48fc5b7149070bb45550", "patch": "@@ -1010,9 +1010,18 @@ impl<'a> Parser<'a> {\n     ) -> PResult<'a, ItemInfo> {\n         let impl_span = self.token.span;\n         let mut err = self.expected_ident_found();\n-        let mut impl_info = self.parse_item_impl(attrs, defaultness)?;\n+\n+        // Only try to recover if this is implementing a trait for a type\n+        let mut impl_info = match self.parse_item_impl(attrs, defaultness) {\n+            Ok(impl_info) => impl_info,\n+            Err(mut recovery_error) => {\n+                // Recovery failed, raise the \"expected identifier\" error\n+                recovery_error.cancel();\n+                return Err(err);\n+            }\n+        };\n+\n         match impl_info.1 {\n-            // only try to recover if this is implementing a trait for a type\n             ItemKind::Impl(box ImplKind {\n                 of_trait: Some(ref trai), ref mut constness, ..\n             }) => {\n@@ -1030,6 +1039,7 @@ impl<'a> Parser<'a> {\n             ItemKind::Impl { .. } => return Err(err),\n             _ => unreachable!(),\n         }\n+\n         Ok(impl_info)\n     }\n "}, {"sha": "0a81b6e105dff847dd223a0664b169b51f379af4", "filename": "compiler/rustc_trait_selection/src/traits/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f4008fe94935d05ffb3a48fc5b7149070bb45550/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4008fe94935d05ffb3a48fc5b7149070bb45550/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs?ref=f4008fe94935d05ffb3a48fc5b7149070bb45550", "patch": "@@ -65,7 +65,8 @@ pub use self::util::{\n     get_vtable_index_of_object_method, impl_item_is_final, predicate_for_trait_def, upcast_choices,\n };\n pub use self::util::{\n-    supertrait_def_ids, supertraits, transitive_bounds, SupertraitDefIds, Supertraits,\n+    supertrait_def_ids, supertraits, transitive_bounds, transitive_bounds_that_define_assoc_type,\n+    SupertraitDefIds, Supertraits,\n };\n \n pub use self::chalk_fulfill::FulfillmentContext as ChalkFulfillmentContext;"}, {"sha": "244eba8ad5e02d2758de77542e8172408922463b", "filename": "compiler/rustc_typeck/src/astconv/mod.rs", "status": "modified", "additions": 57, "deletions": 11, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/f4008fe94935d05ffb3a48fc5b7149070bb45550/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4008fe94935d05ffb3a48fc5b7149070bb45550/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs?ref=f4008fe94935d05ffb3a48fc5b7149070bb45550", "patch": "@@ -49,9 +49,10 @@ pub trait AstConv<'tcx> {\n \n     fn default_constness_for_trait_bounds(&self) -> Constness;\n \n-    /// Returns predicates in scope of the form `X: Foo`, where `X` is\n-    /// a type parameter `X` with the given id `def_id`. This is a\n-    /// subset of the full set of predicates.\n+    /// Returns predicates in scope of the form `X: Foo<T>`, where `X`\n+    /// is a type parameter `X` with the given id `def_id` and T\n+    /// matches `assoc_name`. This is a subset of the full set of\n+    /// predicates.\n     ///\n     /// This is used for one specific purpose: resolving \"short-hand\"\n     /// associated type references like `T::Item`. In principle, we\n@@ -60,7 +61,12 @@ pub trait AstConv<'tcx> {\n     /// but this can lead to cycle errors. The problem is that we have\n     /// to do this resolution *in order to create the predicates in\n     /// the first place*. Hence, we have this \"special pass\".\n-    fn get_type_parameter_bounds(&self, span: Span, def_id: DefId) -> ty::GenericPredicates<'tcx>;\n+    fn get_type_parameter_bounds(\n+        &self,\n+        span: Span,\n+        def_id: DefId,\n+        assoc_name: Ident,\n+    ) -> ty::GenericPredicates<'tcx>;\n \n     /// Returns the lifetime to use when a lifetime is omitted (and not elided).\n     fn re_infer(&self, param: Option<&ty::GenericParamDef>, span: Span)\n@@ -792,7 +798,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n     }\n \n     // Returns `true` if a bounds list includes `?Sized`.\n-    pub fn is_unsized(&self, ast_bounds: &[hir::GenericBound<'_>], span: Span) -> bool {\n+    pub fn is_unsized(&self, ast_bounds: &[&hir::GenericBound<'_>], span: Span) -> bool {\n         let tcx = self.tcx();\n \n         // Try to find an unbound in bounds.\n@@ -850,7 +856,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n     fn add_bounds(\n         &self,\n         param_ty: Ty<'tcx>,\n-        ast_bounds: &[hir::GenericBound<'_>],\n+        ast_bounds: &[&hir::GenericBound<'_>],\n         bounds: &mut Bounds<'tcx>,\n     ) {\n         let constness = self.default_constness_for_trait_bounds();\n@@ -865,7 +871,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 hir::GenericBound::Trait(_, hir::TraitBoundModifier::Maybe) => {}\n                 hir::GenericBound::LangItemTrait(lang_item, span, hir_id, args) => self\n                     .instantiate_lang_item_trait_ref(\n-                        lang_item, span, hir_id, args, param_ty, bounds,\n+                        *lang_item, *span, *hir_id, args, param_ty, bounds,\n                     ),\n                 hir::GenericBound::Outlives(ref l) => bounds\n                     .region_bounds\n@@ -896,6 +902,42 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         ast_bounds: &[hir::GenericBound<'_>],\n         sized_by_default: SizedByDefault,\n         span: Span,\n+    ) -> Bounds<'tcx> {\n+        let ast_bounds: Vec<_> = ast_bounds.iter().collect();\n+        self.compute_bounds_inner(param_ty, &ast_bounds, sized_by_default, span)\n+    }\n+\n+    /// Convert the bounds in `ast_bounds` that refer to traits which define an associated type\n+    /// named `assoc_name` into ty::Bounds. Ignore the rest.\n+    pub fn compute_bounds_that_match_assoc_type(\n+        &self,\n+        param_ty: Ty<'tcx>,\n+        ast_bounds: &[hir::GenericBound<'_>],\n+        sized_by_default: SizedByDefault,\n+        span: Span,\n+        assoc_name: Ident,\n+    ) -> Bounds<'tcx> {\n+        let mut result = Vec::new();\n+\n+        for ast_bound in ast_bounds {\n+            if let Some(trait_ref) = ast_bound.trait_ref() {\n+                if let Some(trait_did) = trait_ref.trait_def_id() {\n+                    if self.tcx().trait_may_define_assoc_type(trait_did, assoc_name) {\n+                        result.push(ast_bound);\n+                    }\n+                }\n+            }\n+        }\n+\n+        self.compute_bounds_inner(param_ty, &result, sized_by_default, span)\n+    }\n+\n+    fn compute_bounds_inner(\n+        &self,\n+        param_ty: Ty<'tcx>,\n+        ast_bounds: &[&hir::GenericBound<'_>],\n+        sized_by_default: SizedByDefault,\n+        span: Span,\n     ) -> Bounds<'tcx> {\n         let mut bounds = Bounds::default();\n \n@@ -1098,7 +1140,8 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 // parameter to have a skipped binder.\n                 let param_ty =\n                     tcx.mk_projection(assoc_ty.def_id, projection_ty.skip_binder().substs);\n-                self.add_bounds(param_ty, ast_bounds, bounds);\n+                let ast_bounds: Vec<_> = ast_bounds.iter().collect();\n+                self.add_bounds(param_ty, &ast_bounds, bounds);\n             }\n         }\n         Ok(())\n@@ -1413,21 +1456,24 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             ty_param_def_id, assoc_name, span,\n         );\n \n-        let predicates =\n-            &self.get_type_parameter_bounds(span, ty_param_def_id.to_def_id()).predicates;\n+        let predicates = &self\n+            .get_type_parameter_bounds(span, ty_param_def_id.to_def_id(), assoc_name)\n+            .predicates;\n \n         debug!(\"find_bound_for_assoc_item: predicates={:#?}\", predicates);\n \n         let param_hir_id = tcx.hir().local_def_id_to_hir_id(ty_param_def_id);\n         let param_name = tcx.hir().ty_param_name(param_hir_id);\n         self.one_bound_for_assoc_type(\n             || {\n-                traits::transitive_bounds(\n+                traits::transitive_bounds_that_define_assoc_type(\n                     tcx,\n                     predicates.iter().filter_map(|(p, _)| {\n                         p.to_opt_poly_trait_ref().map(|trait_ref| trait_ref.value)\n                     }),\n+                    assoc_name,\n                 )\n+                .into_iter()\n             },\n             || param_name.to_string(),\n             assoc_name,"}, {"sha": "4da4835f7cfbb065ab561ea414ed95b77e2a5399", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/mod.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f4008fe94935d05ffb3a48fc5b7149070bb45550/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4008fe94935d05ffb3a48fc5b7149070bb45550/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fmod.rs?ref=f4008fe94935d05ffb3a48fc5b7149070bb45550", "patch": "@@ -20,6 +20,7 @@ use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::subst::GenericArgKind;\n use rustc_middle::ty::{self, Const, Ty, TyCtxt};\n use rustc_session::Session;\n+use rustc_span::symbol::Ident;\n use rustc_span::{self, Span};\n use rustc_trait_selection::traits::{ObligationCause, ObligationCauseCode};\n \n@@ -183,7 +184,12 @@ impl<'a, 'tcx> AstConv<'tcx> for FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn get_type_parameter_bounds(&self, _: Span, def_id: DefId) -> ty::GenericPredicates<'tcx> {\n+    fn get_type_parameter_bounds(\n+        &self,\n+        _: Span,\n+        def_id: DefId,\n+        _: Ident,\n+    ) -> ty::GenericPredicates<'tcx> {\n         let tcx = self.tcx;\n         let hir_id = tcx.hir().local_def_id_to_hir_id(def_id.expect_local());\n         let item_id = tcx.hir().ty_param_owner(hir_id);"}, {"sha": "e5045f906df59f714c37924455e38e8b20750d62", "filename": "compiler/rustc_typeck/src/collect.rs", "status": "modified", "additions": 133, "deletions": 52, "changes": 185, "blob_url": "https://github.com/rust-lang/rust/blob/f4008fe94935d05ffb3a48fc5b7149070bb45550/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4008fe94935d05ffb3a48fc5b7149070bb45550/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs?ref=f4008fe94935d05ffb3a48fc5b7149070bb45550", "patch": "@@ -1,3 +1,4 @@\n+// ignore-tidy-filelength\n //! \"Collection\" is the process of determining the type and other external\n //! details of each item in Rust. Collection is specifically concerned\n //! with *inter-procedural* things -- for example, for a function\n@@ -77,6 +78,7 @@ pub fn provide(providers: &mut Providers) {\n         projection_ty_from_predicates,\n         explicit_predicates_of,\n         super_predicates_of,\n+        super_predicates_that_define_assoc_type,\n         trait_explicit_predicates_and_bounds,\n         type_param_predicates,\n         trait_def,\n@@ -308,8 +310,17 @@ impl AstConv<'tcx> for ItemCtxt<'tcx> {\n         }\n     }\n \n-    fn get_type_parameter_bounds(&self, span: Span, def_id: DefId) -> ty::GenericPredicates<'tcx> {\n-        self.tcx.at(span).type_param_predicates((self.item_def_id, def_id.expect_local()))\n+    fn get_type_parameter_bounds(\n+        &self,\n+        span: Span,\n+        def_id: DefId,\n+        assoc_name: Ident,\n+    ) -> ty::GenericPredicates<'tcx> {\n+        self.tcx.at(span).type_param_predicates((\n+            self.item_def_id,\n+            def_id.expect_local(),\n+            assoc_name,\n+        ))\n     }\n \n     fn re_infer(&self, _: Option<&ty::GenericParamDef>, _: Span) -> Option<ty::Region<'tcx>> {\n@@ -490,7 +501,7 @@ fn get_new_lifetime_name<'tcx>(\n /// `X: Foo` where `X` is the type parameter `def_id`.\n fn type_param_predicates(\n     tcx: TyCtxt<'_>,\n-    (item_def_id, def_id): (DefId, LocalDefId),\n+    (item_def_id, def_id, assoc_name): (DefId, LocalDefId, Ident),\n ) -> ty::GenericPredicates<'_> {\n     use rustc_hir::*;\n \n@@ -515,7 +526,7 @@ fn type_param_predicates(\n     let mut result = parent\n         .map(|parent| {\n             let icx = ItemCtxt::new(tcx, parent);\n-            icx.get_type_parameter_bounds(DUMMY_SP, def_id.to_def_id())\n+            icx.get_type_parameter_bounds(DUMMY_SP, def_id.to_def_id(), assoc_name)\n         })\n         .unwrap_or_default();\n     let mut extend = None;\n@@ -558,12 +569,18 @@ fn type_param_predicates(\n \n     let icx = ItemCtxt::new(tcx, item_def_id);\n     let extra_predicates = extend.into_iter().chain(\n-        icx.type_parameter_bounds_in_generics(ast_generics, param_id, ty, OnlySelfBounds(true))\n-            .into_iter()\n-            .filter(|(predicate, _)| match predicate.kind().skip_binder() {\n-                ty::PredicateKind::Trait(data, _) => data.self_ty().is_param(index),\n-                _ => false,\n-            }),\n+        icx.type_parameter_bounds_in_generics(\n+            ast_generics,\n+            param_id,\n+            ty,\n+            OnlySelfBounds(true),\n+            Some(assoc_name),\n+        )\n+        .into_iter()\n+        .filter(|(predicate, _)| match predicate.kind().skip_binder() {\n+            ty::PredicateKind::Trait(data, _) => data.self_ty().is_param(index),\n+            _ => false,\n+        }),\n     );\n     result.predicates =\n         tcx.arena.alloc_from_iter(result.predicates.iter().copied().chain(extra_predicates));\n@@ -581,6 +598,7 @@ impl ItemCtxt<'tcx> {\n         param_id: hir::HirId,\n         ty: Ty<'tcx>,\n         only_self_bounds: OnlySelfBounds,\n+        assoc_name: Option<Ident>,\n     ) -> Vec<(ty::Predicate<'tcx>, Span)> {\n         let constness = self.default_constness_for_trait_bounds();\n         let from_ty_params = ast_generics\n@@ -591,6 +609,10 @@ impl ItemCtxt<'tcx> {\n                 _ => None,\n             })\n             .flat_map(|bounds| bounds.iter())\n+            .filter(|b| match assoc_name {\n+                Some(assoc_name) => self.bound_defines_assoc_item(b, assoc_name),\n+                None => true,\n+            })\n             .flat_map(|b| predicates_from_bound(self, ty, b, constness));\n \n         let from_where_clauses = ast_generics\n@@ -609,12 +631,34 @@ impl ItemCtxt<'tcx> {\n                 } else {\n                     None\n                 };\n-                bp.bounds.iter().filter_map(move |b| bt.map(|bt| (bt, b)))\n+                bp.bounds\n+                    .iter()\n+                    .filter(|b| match assoc_name {\n+                        Some(assoc_name) => self.bound_defines_assoc_item(b, assoc_name),\n+                        None => true,\n+                    })\n+                    .filter_map(move |b| bt.map(|bt| (bt, b)))\n             })\n             .flat_map(|(bt, b)| predicates_from_bound(self, bt, b, constness));\n \n         from_ty_params.chain(from_where_clauses).collect()\n     }\n+\n+    fn bound_defines_assoc_item(&self, b: &hir::GenericBound<'_>, assoc_name: Ident) -> bool {\n+        debug!(\"bound_defines_assoc_item(b={:?}, assoc_name={:?})\", b, assoc_name);\n+\n+        match b {\n+            hir::GenericBound::Trait(poly_trait_ref, _) => {\n+                let trait_ref = &poly_trait_ref.trait_ref;\n+                if let Some(trait_did) = trait_ref.trait_def_id() {\n+                    self.tcx.trait_may_define_assoc_type(trait_did, assoc_name)\n+                } else {\n+                    false\n+                }\n+            }\n+            _ => false,\n+        }\n+    }\n }\n \n /// Tests whether this is the AST for a reference to the type\n@@ -983,54 +1027,91 @@ fn adt_def(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::AdtDef {\n /// the transitive super-predicates are converted.\n fn super_predicates_of(tcx: TyCtxt<'_>, trait_def_id: DefId) -> ty::GenericPredicates<'_> {\n     debug!(\"super_predicates(trait_def_id={:?})\", trait_def_id);\n-    let trait_hir_id = tcx.hir().local_def_id_to_hir_id(trait_def_id.expect_local());\n+    tcx.super_predicates_that_define_assoc_type((trait_def_id, None))\n+}\n \n-    let item = match tcx.hir().get(trait_hir_id) {\n-        Node::Item(item) => item,\n-        _ => bug!(\"trait_node_id {} is not an item\", trait_hir_id),\n-    };\n+/// Ensures that the super-predicates of the trait with a `DefId`\n+/// of `trait_def_id` are converted and stored. This also ensures that\n+/// the transitive super-predicates are converted.\n+fn super_predicates_that_define_assoc_type(\n+    tcx: TyCtxt<'_>,\n+    (trait_def_id, assoc_name): (DefId, Option<Ident>),\n+) -> ty::GenericPredicates<'_> {\n+    debug!(\n+        \"super_predicates_that_define_assoc_type(trait_def_id={:?}, assoc_name={:?})\",\n+        trait_def_id, assoc_name\n+    );\n+    if trait_def_id.is_local() {\n+        debug!(\"super_predicates_that_define_assoc_type: local trait_def_id={:?}\", trait_def_id);\n+        let trait_hir_id = tcx.hir().local_def_id_to_hir_id(trait_def_id.expect_local());\n \n-    let (generics, bounds) = match item.kind {\n-        hir::ItemKind::Trait(.., ref generics, ref supertraits, _) => (generics, supertraits),\n-        hir::ItemKind::TraitAlias(ref generics, ref supertraits) => (generics, supertraits),\n-        _ => span_bug!(item.span, \"super_predicates invoked on non-trait\"),\n-    };\n+        let item = match tcx.hir().get(trait_hir_id) {\n+            Node::Item(item) => item,\n+            _ => bug!(\"trait_node_id {} is not an item\", trait_hir_id),\n+        };\n \n-    let icx = ItemCtxt::new(tcx, trait_def_id);\n-\n-    // Convert the bounds that follow the colon, e.g., `Bar + Zed` in `trait Foo: Bar + Zed`.\n-    let self_param_ty = tcx.types.self_param;\n-    let superbounds1 =\n-        AstConv::compute_bounds(&icx, self_param_ty, bounds, SizedByDefault::No, item.span);\n-\n-    let superbounds1 = superbounds1.predicates(tcx, self_param_ty);\n-\n-    // Convert any explicit superbounds in the where-clause,\n-    // e.g., `trait Foo where Self: Bar`.\n-    // In the case of trait aliases, however, we include all bounds in the where-clause,\n-    // so e.g., `trait Foo = where u32: PartialEq<Self>` would include `u32: PartialEq<Self>`\n-    // as one of its \"superpredicates\".\n-    let is_trait_alias = tcx.is_trait_alias(trait_def_id);\n-    let superbounds2 = icx.type_parameter_bounds_in_generics(\n-        generics,\n-        item.hir_id,\n-        self_param_ty,\n-        OnlySelfBounds(!is_trait_alias),\n-    );\n+        let (generics, bounds) = match item.kind {\n+            hir::ItemKind::Trait(.., ref generics, ref supertraits, _) => (generics, supertraits),\n+            hir::ItemKind::TraitAlias(ref generics, ref supertraits) => (generics, supertraits),\n+            _ => span_bug!(item.span, \"super_predicates invoked on non-trait\"),\n+        };\n+\n+        let icx = ItemCtxt::new(tcx, trait_def_id);\n+\n+        // Convert the bounds that follow the colon, e.g., `Bar + Zed` in `trait Foo: Bar + Zed`.\n+        let self_param_ty = tcx.types.self_param;\n+        let superbounds1 = if let Some(assoc_name) = assoc_name {\n+            AstConv::compute_bounds_that_match_assoc_type(\n+                &icx,\n+                self_param_ty,\n+                &bounds,\n+                SizedByDefault::No,\n+                item.span,\n+                assoc_name,\n+            )\n+        } else {\n+            AstConv::compute_bounds(&icx, self_param_ty, &bounds, SizedByDefault::No, item.span)\n+        };\n \n-    // Combine the two lists to form the complete set of superbounds:\n-    let superbounds = &*tcx.arena.alloc_from_iter(superbounds1.into_iter().chain(superbounds2));\n+        let superbounds1 = superbounds1.predicates(tcx, self_param_ty);\n+\n+        // Convert any explicit superbounds in the where-clause,\n+        // e.g., `trait Foo where Self: Bar`.\n+        // In the case of trait aliases, however, we include all bounds in the where-clause,\n+        // so e.g., `trait Foo = where u32: PartialEq<Self>` would include `u32: PartialEq<Self>`\n+        // as one of its \"superpredicates\".\n+        let is_trait_alias = tcx.is_trait_alias(trait_def_id);\n+        let superbounds2 = icx.type_parameter_bounds_in_generics(\n+            generics,\n+            item.hir_id,\n+            self_param_ty,\n+            OnlySelfBounds(!is_trait_alias),\n+            assoc_name,\n+        );\n \n-    // Now require that immediate supertraits are converted,\n-    // which will, in turn, reach indirect supertraits.\n-    for &(pred, span) in superbounds {\n-        debug!(\"superbound: {:?}\", pred);\n-        if let ty::PredicateKind::Trait(bound, _) = pred.kind().skip_binder() {\n-            tcx.at(span).super_predicates_of(bound.def_id());\n+        // Combine the two lists to form the complete set of superbounds:\n+        let superbounds = &*tcx.arena.alloc_from_iter(superbounds1.into_iter().chain(superbounds2));\n+\n+        // Now require that immediate supertraits are converted,\n+        // which will, in turn, reach indirect supertraits.\n+        if assoc_name.is_none() {\n+            // Now require that immediate supertraits are converted,\n+            // which will, in turn, reach indirect supertraits.\n+            for &(pred, span) in superbounds {\n+                debug!(\"superbound: {:?}\", pred);\n+                if let ty::PredicateKind::Trait(bound, _) = pred.kind().skip_binder() {\n+                    tcx.at(span).super_predicates_of(bound.def_id());\n+                }\n+            }\n         }\n-    }\n \n-    ty::GenericPredicates { parent: None, predicates: superbounds }\n+        ty::GenericPredicates { parent: None, predicates: superbounds }\n+    } else {\n+        // if `assoc_name` is None, then the query should've been redirected to an\n+        // external provider\n+        assert!(assoc_name.is_some());\n+        tcx.super_predicates_of(trait_def_id)\n+    }\n }\n \n fn trait_def(tcx: TyCtxt<'_>, def_id: DefId) -> ty::TraitDef {"}, {"sha": "fe18dc5ed0c69cf85938387ca20154151e549f97", "filename": "compiler/rustc_typeck/src/collect/item_bounds.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f4008fe94935d05ffb3a48fc5b7149070bb45550/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Fitem_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4008fe94935d05ffb3a48fc5b7149070bb45550/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Fitem_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Fitem_bounds.rs?ref=f4008fe94935d05ffb3a48fc5b7149070bb45550", "patch": "@@ -28,7 +28,7 @@ fn associated_type_bounds<'tcx>(\n     let bounds = AstConv::compute_bounds(\n         &ItemCtxt::new(tcx, assoc_item_def_id),\n         item_ty,\n-        bounds,\n+        &bounds,\n         SizedByDefault::Yes,\n         span,\n     );\n@@ -69,7 +69,7 @@ fn opaque_type_bounds<'tcx>(\n         let bounds = AstConv::compute_bounds(\n             &ItemCtxt::new(tcx, opaque_def_id),\n             item_ty,\n-            bounds,\n+            &bounds,\n             SizedByDefault::Yes,\n             span,\n         )"}, {"sha": "e87303749b423376fe514971d1f2efa432017cdc", "filename": "library/alloc/src/boxed.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f4008fe94935d05ffb3a48fc5b7149070bb45550/library%2Falloc%2Fsrc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4008fe94935d05ffb3a48fc5b7149070bb45550/library%2Falloc%2Fsrc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fboxed.rs?ref=f4008fe94935d05ffb3a48fc5b7149070bb45550", "patch": "@@ -390,7 +390,12 @@ impl<T, A: Allocator> Box<T, A> {\n     // #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n     pub fn new_uninit_in(alloc: A) -> Box<mem::MaybeUninit<T>, A> {\n         let layout = Layout::new::<mem::MaybeUninit<T>>();\n-        Box::try_new_uninit_in(alloc).unwrap_or_else(|_| handle_alloc_error(layout))\n+        // NOTE: Prefer match over unwrap_or_else since closure sometimes not inlineable.\n+        // That would make code size bigger.\n+        match Box::try_new_uninit_in(alloc) {\n+            Ok(m) => m,\n+            Err(_) => handle_alloc_error(layout),\n+        }\n     }\n \n     /// Constructs a new box with uninitialized contents in the provided allocator,\n@@ -447,7 +452,12 @@ impl<T, A: Allocator> Box<T, A> {\n     // #[unstable(feature = \"new_uninit\", issue = \"63291\")]\n     pub fn new_zeroed_in(alloc: A) -> Box<mem::MaybeUninit<T>, A> {\n         let layout = Layout::new::<mem::MaybeUninit<T>>();\n-        Box::try_new_zeroed_in(alloc).unwrap_or_else(|_| handle_alloc_error(layout))\n+        // NOTE: Prefer match over unwrap_or_else since closure sometimes not inlineable.\n+        // That would make code size bigger.\n+        match Box::try_new_zeroed_in(alloc) {\n+            Ok(m) => m,\n+            Err(_) => handle_alloc_error(layout),\n+        }\n     }\n \n     /// Constructs a new `Box` with uninitialized contents, with the memory"}, {"sha": "5faa4b825605f06d826a6d9b8099592e5b998447", "filename": "library/core/src/iter/traits/iterator.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f4008fe94935d05ffb3a48fc5b7149070bb45550/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4008fe94935d05ffb3a48fc5b7149070bb45550/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs?ref=f4008fe94935d05ffb3a48fc5b7149070bb45550", "patch": "@@ -2205,6 +2205,7 @@ pub trait Iterator {\n     /// // we can still use `iter`, as there are more elements.\n     /// assert_eq!(iter.next(), Some(&3));\n     /// ```\n+    #[doc(alias = \"every\")]\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn all<F>(&mut self, f: F) -> bool"}, {"sha": "2f78ba8f28e29189697d5c78d375a792d13c3854", "filename": "library/core/src/ops/control_flow.rs", "status": "modified", "additions": 83, "deletions": 3, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/f4008fe94935d05ffb3a48fc5b7149070bb45550/library%2Fcore%2Fsrc%2Fops%2Fcontrol_flow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4008fe94935d05ffb3a48fc5b7149070bb45550/library%2Fcore%2Fsrc%2Fops%2Fcontrol_flow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fops%2Fcontrol_flow.rs?ref=f4008fe94935d05ffb3a48fc5b7149070bb45550", "patch": "@@ -1,13 +1,63 @@\n use crate::ops::Try;\n \n-/// Used to make try_fold closures more like normal loops\n+/// Used to tell an operation whether it should exit early or go on as usual.\n+///\n+/// This is used when exposing things (like graph traversals or visitors) where\n+/// you want the user to be able to choose whether to exit early.\n+/// Having the enum makes it clearer -- no more wondering \"wait, what did `false`\n+/// mean again?\" -- and allows including a value.\n+///\n+/// # Examples\n+///\n+/// Early-exiting from [`Iterator::try_for_each`]:\n+/// ```\n+/// #![feature(control_flow_enum)]\n+/// use std::ops::ControlFlow;\n+///\n+/// let r = (2..100).try_for_each(|x| {\n+///     if 403 % x == 0 {\n+///         return ControlFlow::Break(x)\n+///     }\n+///\n+///     ControlFlow::Continue(())\n+/// });\n+/// assert_eq!(r, ControlFlow::Break(13));\n+/// ```\n+///\n+/// A basic tree traversal:\n+/// ```no_run\n+/// #![feature(control_flow_enum)]\n+/// use std::ops::ControlFlow;\n+///\n+/// pub struct TreeNode<T> {\n+///     value: T,\n+///     left: Option<Box<TreeNode<T>>>,\n+///     right: Option<Box<TreeNode<T>>>,\n+/// }\n+///\n+/// impl<T> TreeNode<T> {\n+///     pub fn traverse_inorder<B>(&self, mut f: impl FnMut(&T) -> ControlFlow<B>) -> ControlFlow<B> {\n+///         if let Some(left) = &self.left {\n+///             left.traverse_inorder(&mut f)?;\n+///         }\n+///         f(&self.value)?;\n+///         if let Some(right) = &self.right {\n+///             right.traverse_inorder(&mut f)?;\n+///         }\n+///         ControlFlow::Continue(())\n+///     }\n+/// }\n+/// ```\n #[unstable(feature = \"control_flow_enum\", reason = \"new API\", issue = \"75744\")]\n #[derive(Debug, Clone, Copy, PartialEq)]\n pub enum ControlFlow<B, C = ()> {\n-    /// Continue in the loop, using the given value for the next iteration\n+    /// Move on to the next phase of the operation as normal.\n     Continue(C),\n-    /// Exit the loop, yielding the given value\n+    /// Exit the operation without running subsequent phases.\n     Break(B),\n+    // Yes, the order of the variants doesn't match the type parameters.\n+    // They're in this order so that `ControlFlow<A, B>` <-> `Result<B, A>`\n+    // is a no-op conversion in the `Try` implementation.\n }\n \n #[unstable(feature = \"control_flow_enum\", reason = \"new API\", issue = \"75744\")]\n@@ -33,13 +83,33 @@ impl<B, C> Try for ControlFlow<B, C> {\n \n impl<B, C> ControlFlow<B, C> {\n     /// Returns `true` if this is a `Break` variant.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(control_flow_enum)]\n+    /// use std::ops::ControlFlow;\n+    ///\n+    /// assert!(ControlFlow::<i32, String>::Break(3).is_break());\n+    /// assert!(!ControlFlow::<String, i32>::Continue(3).is_break());\n+    /// ```\n     #[inline]\n     #[unstable(feature = \"control_flow_enum\", reason = \"new API\", issue = \"75744\")]\n     pub fn is_break(&self) -> bool {\n         matches!(*self, ControlFlow::Break(_))\n     }\n \n     /// Returns `true` if this is a `Continue` variant.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(control_flow_enum)]\n+    /// use std::ops::ControlFlow;\n+    ///\n+    /// assert!(!ControlFlow::<i32, String>::Break(3).is_continue());\n+    /// assert!(ControlFlow::<String, i32>::Continue(3).is_continue());\n+    /// ```\n     #[inline]\n     #[unstable(feature = \"control_flow_enum\", reason = \"new API\", issue = \"75744\")]\n     pub fn is_continue(&self) -> bool {\n@@ -48,6 +118,16 @@ impl<B, C> ControlFlow<B, C> {\n \n     /// Converts the `ControlFlow` into an `Option` which is `Some` if the\n     /// `ControlFlow` was `Break` and `None` otherwise.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(control_flow_enum)]\n+    /// use std::ops::ControlFlow;\n+    ///\n+    /// assert_eq!(ControlFlow::<i32, String>::Break(3).break_value(), Some(3));\n+    /// assert_eq!(ControlFlow::<String, i32>::Continue(3).break_value(), None);\n+    /// ```\n     #[inline]\n     #[unstable(feature = \"control_flow_enum\", reason = \"new API\", issue = \"75744\")]\n     pub fn break_value(self) -> Option<B> {"}, {"sha": "339691b1176944f09cb7ab2e209799a2e3793dec", "filename": "library/core/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f4008fe94935d05ffb3a48fc5b7149070bb45550/library%2Fcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4008fe94935d05ffb3a48fc5b7149070bb45550/library%2Fcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Flib.rs?ref=f4008fe94935d05ffb3a48fc5b7149070bb45550", "patch": "@@ -15,6 +15,7 @@\n #![feature(const_maybe_uninit_assume_init)]\n #![feature(const_ptr_read)]\n #![feature(const_ptr_offset)]\n+#![feature(control_flow_enum)]\n #![feature(core_intrinsics)]\n #![feature(core_private_bignum)]\n #![feature(core_private_diy_float)]"}, {"sha": "aa79dbac8f39dfc27f35c77bc635b4c00566f1b4", "filename": "library/core/tests/ops.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f4008fe94935d05ffb3a48fc5b7149070bb45550/library%2Fcore%2Ftests%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4008fe94935d05ffb3a48fc5b7149070bb45550/library%2Fcore%2Ftests%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fops.rs?ref=f4008fe94935d05ffb3a48fc5b7149070bb45550", "patch": "@@ -1,3 +1,5 @@\n+mod control_flow;\n+\n use core::ops::{Bound, Range, RangeFrom, RangeFull, RangeInclusive, RangeTo, RangeToInclusive};\n use core::ops::{Deref, DerefMut};\n "}, {"sha": "eacfd63a6c48f9a2960f09b9997b3a1345ebe2fd", "filename": "library/core/tests/ops/control_flow.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f4008fe94935d05ffb3a48fc5b7149070bb45550/library%2Fcore%2Ftests%2Fops%2Fcontrol_flow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4008fe94935d05ffb3a48fc5b7149070bb45550/library%2Fcore%2Ftests%2Fops%2Fcontrol_flow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fops%2Fcontrol_flow.rs?ref=f4008fe94935d05ffb3a48fc5b7149070bb45550", "patch": "@@ -0,0 +1,18 @@\n+use core::intrinsics::discriminant_value;\n+use core::ops::ControlFlow;\n+\n+#[test]\n+fn control_flow_discriminants_match_result() {\n+    // This isn't stable surface area, but helps keep `?` cheap between them,\n+    // even if LLVM can't always take advantage of it right now.\n+    // (Sadly Result and Option are inconsistent, so ControlFlow can't match both.)\n+\n+    assert_eq!(\n+        discriminant_value(&ControlFlow::<i32, i32>::Break(3)),\n+        discriminant_value(&Result::<i32, i32>::Err(3)),\n+    );\n+    assert_eq!(\n+        discriminant_value(&ControlFlow::<i32, i32>::Continue(3)),\n+        discriminant_value(&Result::<i32, i32>::Ok(3)),\n+    );\n+}"}, {"sha": "12c5ea741f9ef5f7cd3b474b9529c4e0e63e91e6", "filename": "library/std/src/sys/windows/mutex.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f4008fe94935d05ffb3a48fc5b7149070bb45550/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4008fe94935d05ffb3a48fc5b7149070bb45550/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fmutex.rs?ref=f4008fe94935d05ffb3a48fc5b7149070bb45550", "patch": "@@ -23,8 +23,6 @@ pub struct Mutex {\n }\n \n // Windows SRW Locks are movable (while not borrowed).\n-// ReentrantMutexes (in Inner) are not, but those are stored indirectly through\n-// a Box, so do not move when the Mutex it self is moved.\n pub type MovableMutex = Mutex;\n \n unsafe impl Send for Mutex {}"}, {"sha": "30d690c970507b3efaeb4d984b02f5838aed986a", "filename": "src/bootstrap/doc.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f4008fe94935d05ffb3a48fc5b7149070bb45550/src%2Fbootstrap%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4008fe94935d05ffb3a48fc5b7149070bb45550/src%2Fbootstrap%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdoc.rs?ref=f4008fe94935d05ffb3a48fc5b7149070bb45550", "patch": "@@ -626,6 +626,7 @@ impl Step for Rustdoc {\n         // Only include compiler crates, no dependencies of those, such as `libc`.\n         cargo.arg(\"--no-deps\");\n         cargo.arg(\"-p\").arg(\"rustdoc\");\n+        cargo.arg(\"-p\").arg(\"rustdoc-json-types\");\n \n         cargo.rustdocflag(\"--document-private-items\");\n         cargo.rustdocflag(\"--enable-index-page\");"}, {"sha": "ca2685ca31ffd6290987b6efaf776ed5ecb065b5", "filename": "src/etc/lldb_providers.py", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f4008fe94935d05ffb3a48fc5b7149070bb45550/src%2Fetc%2Flldb_providers.py", "raw_url": "https://github.com/rust-lang/rust/raw/f4008fe94935d05ffb3a48fc5b7149070bb45550/src%2Fetc%2Flldb_providers.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Flldb_providers.py?ref=f4008fe94935d05ffb3a48fc5b7149070bb45550", "patch": "@@ -531,7 +531,9 @@ def update(self):\n         ctrl = table.GetChildMemberWithName(\"ctrl\").GetChildAtIndex(0)\n \n         self.size = table.GetChildMemberWithName(\"items\").GetValueAsUnsigned()\n-        self.pair_type = table.type.template_args[0].GetTypedefedType()\n+        self.pair_type = table.type.template_args[0]\n+        if self.pair_type.IsTypedefType():\n+            self.pair_type = self.pair_type.GetTypedefedType()\n         self.pair_type_size = self.pair_type.GetByteSize()\n \n         self.new_layout = not table.GetChildMemberWithName(\"data\").IsValid()"}, {"sha": "b502e7207d56182a380aa61787137c70c561026f", "filename": "src/test/incremental/cyclic-trait-hierarchy.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f4008fe94935d05ffb3a48fc5b7149070bb45550/src%2Ftest%2Fincremental%2Fcyclic-trait-hierarchy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4008fe94935d05ffb3a48fc5b7149070bb45550/src%2Ftest%2Fincremental%2Fcyclic-trait-hierarchy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fcyclic-trait-hierarchy.rs?ref=f4008fe94935d05ffb3a48fc5b7149070bb45550", "patch": "@@ -3,11 +3,11 @@\n // revisions: rpass1 cfail2\n \n #[cfg(rpass1)]\n-pub trait T2 { }\n+pub trait T2 {}\n #[cfg(cfail2)]\n-pub trait T2: T1 { }\n-//[cfail2]~^ ERROR cycle detected when computing the supertraits of `T2`\n+pub trait T2: T1 {}\n+//[cfail2]~^ ERROR cycle detected when computing the super predicates of `T2`\n \n-pub trait T1: T2 { }\n+pub trait T1: T2 {}\n \n-fn main() { }\n+fn main() {}"}, {"sha": "da223d164f9b09adb685fc41fcda07f6eff8878d", "filename": "src/test/pretty/macro_rules.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f4008fe94935d05ffb3a48fc5b7149070bb45550/src%2Ftest%2Fpretty%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4008fe94935d05ffb3a48fc5b7149070bb45550/src%2Ftest%2Fpretty%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fmacro_rules.rs?ref=f4008fe94935d05ffb3a48fc5b7149070bb45550", "patch": "@@ -0,0 +1,19 @@\n+// pp-exact\n+\n+macro_rules! brace { () => { } ; }\n+\n+macro_rules! bracket[() => { } ;];\n+\n+macro_rules! paren(() => { } ;);\n+\n+macro_rules! matcher_brackets {\n+    (paren) => { } ; (bracket) => { } ; (brace) => { } ;\n+}\n+\n+macro_rules! all_fragments {\n+    ($ b : block, $ e : expr, $ i : ident, $ it : item, $ l : lifetime, $ lit\n+     : literal, $ m : meta, $ p : pat, $ pth : path, $ s : stmt, $ tt : tt, $\n+     ty : ty, $ vis : vis) => { } ;\n+}\n+\n+fn main() { }"}, {"sha": "1b6d6d0ff599f2ae8093f4c5f0276ebc9671cfea", "filename": "src/test/ui/associated-type-bounds/ambiguous-associated-type2.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f4008fe94935d05ffb3a48fc5b7149070bb45550/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fambiguous-associated-type2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4008fe94935d05ffb3a48fc5b7149070bb45550/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fambiguous-associated-type2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fambiguous-associated-type2.rs?ref=f4008fe94935d05ffb3a48fc5b7149070bb45550", "patch": "@@ -0,0 +1,12 @@\n+// ignore-tidy-linelength\n+\n+trait Foo {\n+    type Item;\n+}\n+trait Bar<T> {\n+    type Item;\n+}\n+trait Baz: Foo + Bar<Self::Item> {}\n+//~^ ERROR cycle detected when computing the super traits of `Baz` with associated type name `Item` [E0391]\n+\n+fn main() {}"}, {"sha": "bda1debeac0d6f7b8e4271036c3afb235b3d28ae", "filename": "src/test/ui/associated-type-bounds/ambiguous-associated-type2.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f4008fe94935d05ffb3a48fc5b7149070bb45550/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fambiguous-associated-type2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f4008fe94935d05ffb3a48fc5b7149070bb45550/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fambiguous-associated-type2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fambiguous-associated-type2.stderr?ref=f4008fe94935d05ffb3a48fc5b7149070bb45550", "patch": "@@ -0,0 +1,16 @@\n+error[E0391]: cycle detected when computing the super traits of `Baz` with associated type name `Item`\n+  --> $DIR/ambiguous-associated-type2.rs:9:1\n+   |\n+LL | trait Baz: Foo + Bar<Self::Item> {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: ...which again requires computing the super traits of `Baz` with associated type name `Item`, completing the cycle\n+note: cycle used when computing the super traits of `Baz`\n+  --> $DIR/ambiguous-associated-type2.rs:9:1\n+   |\n+LL | trait Baz: Foo + Bar<Self::Item> {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0391`."}, {"sha": "3eb50ab554735e7b680dfe43d2ef9e5324fb4b1b", "filename": "src/test/ui/associated-type-bounds/associated-item-through-where-clause.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/f4008fe94935d05ffb3a48fc5b7149070bb45550/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fassociated-item-through-where-clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4008fe94935d05ffb3a48fc5b7149070bb45550/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fassociated-item-through-where-clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fassociated-item-through-where-clause.rs?ref=f4008fe94935d05ffb3a48fc5b7149070bb45550", "patch": "@@ -0,0 +1,21 @@\n+// check-pass\n+\n+trait Foo {\n+    type Item;\n+}\n+\n+trait Bar\n+where\n+    Self: Foo,\n+{\n+}\n+\n+#[allow(dead_code)]\n+fn foo<M>(_m: M)\n+where\n+    M: Bar,\n+    M::Item: Send,\n+{\n+}\n+\n+fn main() {}"}, {"sha": "b1e54ec04493b3a3c97ecfab4b9b33ba8eae2103", "filename": "src/test/ui/associated-type-bounds/handle-predicates-that-can-define-assoc-type.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f4008fe94935d05ffb3a48fc5b7149070bb45550/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fhandle-predicates-that-can-define-assoc-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4008fe94935d05ffb3a48fc5b7149070bb45550/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fhandle-predicates-that-can-define-assoc-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fhandle-predicates-that-can-define-assoc-type.rs?ref=f4008fe94935d05ffb3a48fc5b7149070bb45550", "patch": "@@ -0,0 +1,10 @@\n+// check-pass\n+\n+trait Foo<T> {}\n+trait Bar {\n+    type A;\n+    type B;\n+}\n+trait Baz: Bar<B = u32> + Foo<Self::A> {}\n+\n+fn main() {}"}, {"sha": "07d0f8f8769e5f2bd46ed23e24a718b315a8b44f", "filename": "src/test/ui/associated-type-bounds/missing-trait-bound-for-assoc-fails.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f4008fe94935d05ffb3a48fc5b7149070bb45550/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fmissing-trait-bound-for-assoc-fails.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4008fe94935d05ffb3a48fc5b7149070bb45550/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fmissing-trait-bound-for-assoc-fails.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fmissing-trait-bound-for-assoc-fails.rs?ref=f4008fe94935d05ffb3a48fc5b7149070bb45550", "patch": "@@ -0,0 +1,10 @@\n+#[allow(dead_code)]\n+fn foo<M>(_m: M)\n+where\n+    M::Item: Temp,\n+    //~^ ERROR cannot find trait `Temp` in this scope [E0405]\n+    //~| ERROR associated type `Item` not found for `M` [E0220]\n+{\n+}\n+\n+fn main() {}"}, {"sha": "bc2807b03961c0db6f79a3d93f41741272f5ab38", "filename": "src/test/ui/associated-type-bounds/missing-trait-bound-for-assoc-fails.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f4008fe94935d05ffb3a48fc5b7149070bb45550/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fmissing-trait-bound-for-assoc-fails.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f4008fe94935d05ffb3a48fc5b7149070bb45550/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fmissing-trait-bound-for-assoc-fails.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fmissing-trait-bound-for-assoc-fails.stderr?ref=f4008fe94935d05ffb3a48fc5b7149070bb45550", "patch": "@@ -0,0 +1,16 @@\n+error[E0405]: cannot find trait `Temp` in this scope\n+  --> $DIR/missing-trait-bound-for-assoc-fails.rs:4:14\n+   |\n+LL |     M::Item: Temp,\n+   |              ^^^^ not found in this scope\n+\n+error[E0220]: associated type `Item` not found for `M`\n+  --> $DIR/missing-trait-bound-for-assoc-fails.rs:4:8\n+   |\n+LL |     M::Item: Temp,\n+   |        ^^^^ associated type `Item` not found\n+\n+error: aborting due to 2 previous errors\n+\n+Some errors have detailed explanations: E0220, E0405.\n+For more information about an error, try `rustc --explain E0220`."}, {"sha": "c82ec01f4d61db9b99f8a00d3adb039f1618f685", "filename": "src/test/ui/associated-type-bounds/super-trait-referencing-self.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f4008fe94935d05ffb3a48fc5b7149070bb45550/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fsuper-trait-referencing-self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4008fe94935d05ffb3a48fc5b7149070bb45550/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fsuper-trait-referencing-self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fsuper-trait-referencing-self.rs?ref=f4008fe94935d05ffb3a48fc5b7149070bb45550", "patch": "@@ -0,0 +1,12 @@\n+// check-pass\n+trait Foo {\n+    type Bar;\n+}\n+trait Qux: Foo + AsRef<Self::Bar> {}\n+trait Foo2 {}\n+\n+trait Qux2: Foo2 + AsRef<Self::Bar> {\n+    type Bar;\n+}\n+\n+fn main() {}"}, {"sha": "2e97535157fd2ca40ea0aba1f6786e3ccfd86c46", "filename": "src/test/ui/associated-type-bounds/super-trait-referencing.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f4008fe94935d05ffb3a48fc5b7149070bb45550/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fsuper-trait-referencing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4008fe94935d05ffb3a48fc5b7149070bb45550/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fsuper-trait-referencing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fsuper-trait-referencing.rs?ref=f4008fe94935d05ffb3a48fc5b7149070bb45550", "patch": "@@ -0,0 +1,19 @@\n+// check-pass\n+\n+// The goal of this test is to ensure that T: Bar<T::Item>\n+// in the where clause does not cycle\n+\n+trait Foo {\n+    type Item;\n+}\n+\n+trait Bar<T> {}\n+\n+fn baz<T>()\n+where\n+    T: Foo,\n+    T: Bar<T::Item>,\n+{\n+}\n+\n+fn main() {}"}, {"sha": "72a6be9ffc38843a38ebf1346b3ea4aebc978645", "filename": "src/test/ui/associated-type-bounds/super-trait-where-referencing-self.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/f4008fe94935d05ffb3a48fc5b7149070bb45550/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fsuper-trait-where-referencing-self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4008fe94935d05ffb3a48fc5b7149070bb45550/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fsuper-trait-where-referencing-self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fsuper-trait-where-referencing-self.rs?ref=f4008fe94935d05ffb3a48fc5b7149070bb45550", "patch": "@@ -0,0 +1,27 @@\n+// check-pass\n+\n+// Test that we do not get a cycle due to\n+// resolving `Self::Bar` in the where clauses\n+// on a trait definition (in particular, in\n+// a where clause that is defining a superpredicate).\n+\n+trait Foo {\n+    type Bar;\n+}\n+trait Qux\n+where\n+    Self: Foo,\n+    Self: AsRef<Self::Bar>,\n+{\n+}\n+trait Foo2 {}\n+\n+trait Qux2\n+where\n+    Self: Foo2,\n+    Self: AsRef<Self::Bar>,\n+{\n+    type Bar;\n+}\n+\n+fn main() {}"}, {"sha": "a9d6eed810a6b172699e3a85afa15ad79ae35ac0", "filename": "src/test/ui/associated-type-bounds/traits-assoc-anonymized.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/f4008fe94935d05ffb3a48fc5b7149070bb45550/src%2Ftest%2Fui%2Fassociated-type-bounds%2Ftraits-assoc-anonymized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4008fe94935d05ffb3a48fc5b7149070bb45550/src%2Ftest%2Fui%2Fassociated-type-bounds%2Ftraits-assoc-anonymized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Ftraits-assoc-anonymized.rs?ref=f4008fe94935d05ffb3a48fc5b7149070bb45550", "patch": "@@ -0,0 +1,33 @@\n+// check-pass\n+\n+pub struct LookupInternedStorage;\n+\n+impl<Q> QueryStorageOps<Q> for LookupInternedStorage\n+where\n+    Q: Query,\n+    for<'d> Q: QueryDb<'d>,\n+{\n+    fn fmt_index(&self, db: &<Q as QueryDb<'_>>::DynDb) {\n+        <<Q as QueryDb<'_>>::DynDb as HasQueryGroup<Q::Group>>::group_storage(db);\n+    }\n+}\n+\n+pub trait HasQueryGroup<G> {\n+    fn group_storage(&self);\n+}\n+\n+pub trait QueryStorageOps<Q>\n+where\n+    Q: Query,\n+{\n+    fn fmt_index(&self, db: &<Q as QueryDb<'_>>::DynDb);\n+}\n+\n+pub trait QueryDb<'d> {\n+    type DynDb: HasQueryGroup<Self::Group> + 'd;\n+    type Group;\n+}\n+\n+pub trait Query: for<'d> QueryDb<'d> {}\n+\n+fn main() {}"}, {"sha": "ad5c6aed97c2c3ce7fb57c7215a839fc33b49a32", "filename": "src/test/ui/associated-type-bounds/traits-assoc-type-macros.rs", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/f4008fe94935d05ffb3a48fc5b7149070bb45550/src%2Ftest%2Fui%2Fassociated-type-bounds%2Ftraits-assoc-type-macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4008fe94935d05ffb3a48fc5b7149070bb45550/src%2Ftest%2Fui%2Fassociated-type-bounds%2Ftraits-assoc-type-macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Ftraits-assoc-type-macros.rs?ref=f4008fe94935d05ffb3a48fc5b7149070bb45550", "patch": "@@ -0,0 +1,43 @@\n+// check-pass\n+// compile-flags:-Cincremental=tmp/traits-assoc-type-macros\n+\n+// This test case makes sure that we can compile with incremental compilation\n+// enabled when there are macros, traits, inheritance and associated types involved.\n+\n+trait Deserializer {\n+    type Error;\n+}\n+\n+trait Deserialize {\n+    fn deserialize<D>(_: D) -> D::Error\n+    where\n+        D: Deserializer;\n+}\n+\n+macro_rules! impl_deserialize {\n+    ($name:ident) => {\n+        impl Deserialize for $name {\n+            fn deserialize<D>(_: D) -> D::Error\n+            where\n+                D: Deserializer,\n+            {\n+                loop {}\n+            }\n+        }\n+    };\n+}\n+\n+macro_rules! formats {\n+    {\n+        $($name:ident,)*\n+    } => {\n+        $(\n+            pub struct $name;\n+\n+            impl_deserialize!($name);\n+        )*\n+    }\n+}\n+formats! { Foo, Bar, }\n+\n+fn main() {}"}, {"sha": "d3609acfdff63edd44e05599669eeb292e2083d2", "filename": "src/test/ui/cycle-projection-based-on-where-clause.rs", "status": "removed", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/36931ce3d90e1927e8589d973cc8d18103ede460/src%2Ftest%2Fui%2Fcycle-projection-based-on-where-clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/36931ce3d90e1927e8589d973cc8d18103ede460/src%2Ftest%2Fui%2Fcycle-projection-based-on-where-clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcycle-projection-based-on-where-clause.rs?ref=36931ce3d90e1927e8589d973cc8d18103ede460", "patch": "@@ -1,24 +0,0 @@\n-// Example cycle where a bound on `T` uses a shorthand for `T`. This\n-// creates a cycle because we have to know the bounds on `T` to figure\n-// out what trait defines `Item`, but we can't know the bounds on `T`\n-// without knowing how to handle `T::Item`.\n-//\n-// Note that in the future cases like this could perhaps become legal,\n-// if we got more fine-grained about our cycle detection or changed\n-// how we handle `T::Item` resolution.\n-\n-use std::ops::Add;\n-\n-// Preamble.\n-trait Trait { type Item; }\n-\n-struct A<T>\n-    where T : Trait,\n-          T : Add<T::Item>\n-    //~^ ERROR cycle detected\n-{\n-    data: T\n-}\n-\n-fn main() {\n-}"}, {"sha": "2c337cc6bf903bf6edefca9a1716777b93c41716", "filename": "src/test/ui/cycle-projection-based-on-where-clause.stderr", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/36931ce3d90e1927e8589d973cc8d18103ede460/src%2Ftest%2Fui%2Fcycle-projection-based-on-where-clause.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/36931ce3d90e1927e8589d973cc8d18103ede460/src%2Ftest%2Fui%2Fcycle-projection-based-on-where-clause.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcycle-projection-based-on-where-clause.stderr?ref=36931ce3d90e1927e8589d973cc8d18103ede460", "patch": "@@ -1,16 +0,0 @@\n-error[E0391]: cycle detected when computing the bounds for type parameter `T`\n-  --> $DIR/cycle-projection-based-on-where-clause.rs:17:19\n-   |\n-LL |           T : Add<T::Item>\n-   |                   ^^^^^^^\n-   |\n-   = note: ...which again requires computing the bounds for type parameter `T`, completing the cycle\n-note: cycle used when computing explicit predicates of `A`\n-  --> $DIR/cycle-projection-based-on-where-clause.rs:17:19\n-   |\n-LL |           T : Add<T::Item>\n-   |                   ^^^^^^^\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0391`."}, {"sha": "ee54b2fd151d79294e90dd36764709b5340af359", "filename": "src/test/ui/cycle-trait/cycle-trait-supertrait-direct.stderr", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f4008fe94935d05ffb3a48fc5b7149070bb45550/src%2Ftest%2Fui%2Fcycle-trait%2Fcycle-trait-supertrait-direct.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f4008fe94935d05ffb3a48fc5b7149070bb45550/src%2Ftest%2Fui%2Fcycle-trait%2Fcycle-trait-supertrait-direct.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcycle-trait%2Fcycle-trait-supertrait-direct.stderr?ref=f4008fe94935d05ffb3a48fc5b7149070bb45550", "patch": "@@ -1,10 +1,15 @@\n-error[E0391]: cycle detected when computing the supertraits of `Chromosome`\n+error[E0391]: cycle detected when computing the super predicates of `Chromosome`\n+  --> $DIR/cycle-trait-supertrait-direct.rs:3:1\n+   |\n+LL | trait Chromosome: Chromosome {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: ...which requires computing the super traits of `Chromosome`...\n   --> $DIR/cycle-trait-supertrait-direct.rs:3:19\n    |\n LL | trait Chromosome: Chromosome {\n    |                   ^^^^^^^^^^\n-   |\n-   = note: ...which again requires computing the supertraits of `Chromosome`, completing the cycle\n+   = note: ...which again requires computing the super predicates of `Chromosome`, completing the cycle\n note: cycle used when collecting item types in top-level module\n   --> $DIR/cycle-trait-supertrait-direct.rs:3:1\n    |"}, {"sha": "0a2284e0efbcaf595e5ed5af739d7174b32bfbd8", "filename": "src/test/ui/cycle-trait/cycle-trait-supertrait-indirect.stderr", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f4008fe94935d05ffb3a48fc5b7149070bb45550/src%2Ftest%2Fui%2Fcycle-trait%2Fcycle-trait-supertrait-indirect.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f4008fe94935d05ffb3a48fc5b7149070bb45550/src%2Ftest%2Fui%2Fcycle-trait%2Fcycle-trait-supertrait-indirect.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcycle-trait%2Fcycle-trait-supertrait-indirect.stderr?ref=f4008fe94935d05ffb3a48fc5b7149070bb45550", "patch": "@@ -1,16 +1,26 @@\n-error[E0391]: cycle detected when computing the supertraits of `B`\n+error[E0391]: cycle detected when computing the super predicates of `B`\n+  --> $DIR/cycle-trait-supertrait-indirect.rs:7:1\n+   |\n+LL | trait B: C {\n+   | ^^^^^^^^^^\n+   |\n+note: ...which requires computing the super traits of `B`...\n   --> $DIR/cycle-trait-supertrait-indirect.rs:7:10\n    |\n LL | trait B: C {\n    |          ^\n+note: ...which requires computing the super predicates of `C`...\n+  --> $DIR/cycle-trait-supertrait-indirect.rs:11:1\n    |\n-note: ...which requires computing the supertraits of `C`...\n+LL | trait C: B { }\n+   | ^^^^^^^^^^\n+note: ...which requires computing the super traits of `C`...\n   --> $DIR/cycle-trait-supertrait-indirect.rs:11:10\n    |\n LL | trait C: B { }\n    |          ^\n-   = note: ...which again requires computing the supertraits of `B`, completing the cycle\n-note: cycle used when computing the supertraits of `A`\n+   = note: ...which again requires computing the super predicates of `B`, completing the cycle\n+note: cycle used when computing the super traits of `A`\n   --> $DIR/cycle-trait-supertrait-indirect.rs:4:10\n    |\n LL | trait A: B {"}, {"sha": "5f2b98c5237db15c4d1d46699d60e68b7e1fac13", "filename": "src/test/ui/issues/issue-12511.stderr", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f4008fe94935d05ffb3a48fc5b7149070bb45550/src%2Ftest%2Fui%2Fissues%2Fissue-12511.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f4008fe94935d05ffb3a48fc5b7149070bb45550/src%2Ftest%2Fui%2Fissues%2Fissue-12511.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-12511.stderr?ref=f4008fe94935d05ffb3a48fc5b7149070bb45550", "patch": "@@ -1,15 +1,25 @@\n-error[E0391]: cycle detected when computing the supertraits of `T1`\n+error[E0391]: cycle detected when computing the super predicates of `T1`\n+  --> $DIR/issue-12511.rs:1:1\n+   |\n+LL | trait T1 : T2 {\n+   | ^^^^^^^^^^^^^\n+   |\n+note: ...which requires computing the super traits of `T1`...\n   --> $DIR/issue-12511.rs:1:12\n    |\n LL | trait T1 : T2 {\n    |            ^^\n+note: ...which requires computing the super predicates of `T2`...\n+  --> $DIR/issue-12511.rs:5:1\n    |\n-note: ...which requires computing the supertraits of `T2`...\n+LL | trait T2 : T1 {\n+   | ^^^^^^^^^^^^^\n+note: ...which requires computing the super traits of `T2`...\n   --> $DIR/issue-12511.rs:5:12\n    |\n LL | trait T2 : T1 {\n    |            ^^\n-   = note: ...which again requires computing the supertraits of `T1`, completing the cycle\n+   = note: ...which again requires computing the super predicates of `T1`, completing the cycle\n note: cycle used when collecting item types in top-level module\n   --> $DIR/issue-12511.rs:1:1\n    |"}, {"sha": "4aecc7eab46287bfe9ad257c1080edc372e7d9db", "filename": "src/test/ui/issues/issue-20772.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f4008fe94935d05ffb3a48fc5b7149070bb45550/src%2Ftest%2Fui%2Fissues%2Fissue-20772.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f4008fe94935d05ffb3a48fc5b7149070bb45550/src%2Ftest%2Fui%2Fissues%2Fissue-20772.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-20772.stderr?ref=f4008fe94935d05ffb3a48fc5b7149070bb45550", "patch": "@@ -1,13 +1,13 @@\n-error[E0391]: cycle detected when computing the supertraits of `T`\n+error[E0391]: cycle detected when computing the super traits of `T` with associated type name `Item`\n   --> $DIR/issue-20772.rs:1:1\n    |\n LL | / trait T : Iterator<Item=Self::Item>\n LL | |\n LL | | {}\n    | |__^\n    |\n-   = note: ...which again requires computing the supertraits of `T`, completing the cycle\n-note: cycle used when collecting item types in top-level module\n+   = note: ...which again requires computing the super traits of `T` with associated type name `Item`, completing the cycle\n+note: cycle used when computing the super traits of `T`\n   --> $DIR/issue-20772.rs:1:1\n    |\n LL | / trait T : Iterator<Item=Self::Item>"}, {"sha": "ccbe06d9c0d565a20d79ebc43394815692c49c4b", "filename": "src/test/ui/issues/issue-20825.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f4008fe94935d05ffb3a48fc5b7149070bb45550/src%2Ftest%2Fui%2Fissues%2Fissue-20825.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f4008fe94935d05ffb3a48fc5b7149070bb45550/src%2Ftest%2Fui%2Fissues%2Fissue-20825.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-20825.stderr?ref=f4008fe94935d05ffb3a48fc5b7149070bb45550", "patch": "@@ -1,11 +1,11 @@\n-error[E0391]: cycle detected when computing the supertraits of `Processor`\n+error[E0391]: cycle detected when computing the super traits of `Processor` with associated type name `Input`\n   --> $DIR/issue-20825.rs:5:1\n    |\n LL | pub trait Processor: Subscriber<Input = Self::Input> {\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = note: ...which again requires computing the supertraits of `Processor`, completing the cycle\n-note: cycle used when collecting item types in top-level module\n+   = note: ...which again requires computing the super traits of `Processor` with associated type name `Input`, completing the cycle\n+note: cycle used when computing the super traits of `Processor`\n   --> $DIR/issue-20825.rs:5:1\n    |\n LL | pub trait Processor: Subscriber<Input = Self::Input> {"}, {"sha": "4b9b4d6b23da488c0d77d3a08f98ff3022a5d42d", "filename": "src/test/ui/issues/issue-22673.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f4008fe94935d05ffb3a48fc5b7149070bb45550/src%2Ftest%2Fui%2Fissues%2Fissue-22673.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4008fe94935d05ffb3a48fc5b7149070bb45550/src%2Ftest%2Fui%2Fissues%2Fissue-22673.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-22673.rs?ref=f4008fe94935d05ffb3a48fc5b7149070bb45550", "patch": "@@ -1,5 +1,6 @@\n-trait Expr : PartialEq<Self::Item> {\n-    //~^ ERROR: cycle detected\n+// check-pass\n+\n+trait Expr: PartialEq<Self::Item> {\n     type Item;\n }\n "}, {"sha": "9e7e4b218b1c668cdba6e31068cc2af5c05316b2", "filename": "src/test/ui/issues/issue-22673.stderr", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/36931ce3d90e1927e8589d973cc8d18103ede460/src%2Ftest%2Fui%2Fissues%2Fissue-22673.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/36931ce3d90e1927e8589d973cc8d18103ede460/src%2Ftest%2Fui%2Fissues%2Fissue-22673.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-22673.stderr?ref=36931ce3d90e1927e8589d973cc8d18103ede460", "patch": "@@ -1,16 +0,0 @@\n-error[E0391]: cycle detected when computing the supertraits of `Expr`\n-  --> $DIR/issue-22673.rs:1:1\n-   |\n-LL | trait Expr : PartialEq<Self::Item> {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-   = note: ...which again requires computing the supertraits of `Expr`, completing the cycle\n-note: cycle used when collecting item types in top-level module\n-  --> $DIR/issue-22673.rs:1:1\n-   |\n-LL | trait Expr : PartialEq<Self::Item> {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0391`."}, {"sha": "4ac02b51f62fec0e687cab1a9d75eeec6cac2c60", "filename": "src/test/ui/lint/lint-unsafe-code.rs", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f4008fe94935d05ffb3a48fc5b7149070bb45550/src%2Ftest%2Fui%2Flint%2Flint-unsafe-code.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4008fe94935d05ffb3a48fc5b7149070bb45550/src%2Ftest%2Fui%2Flint%2Flint-unsafe-code.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-unsafe-code.rs?ref=f4008fe94935d05ffb3a48fc5b7149070bb45550", "patch": "@@ -12,14 +12,28 @@ mod allowed_unsafe {\n     unsafe fn also_allowed() {}\n     unsafe trait AllowedUnsafe { }\n     unsafe impl AllowedUnsafe for super::Bar {}\n+    #[no_mangle] fn allowed2() {}\n+    #[export_name = \"foo\"] fn allowed3() {}\n }\n \n macro_rules! unsafe_in_macro {\n-    () => {\n+    () => {{\n+        #[no_mangle] fn foo() {} //~ ERROR: declaration of a `no_mangle` function\n+        #[no_mangle] static FOO: u32 = 5; //~ ERROR: declaration of a `no_mangle` static\n+        #[export_name = \"bar\"] fn bar() {}\n+        //~^ ERROR: declaration of a function with `export_name`\n+        #[export_name = \"BAR\"] static BAR: u32 = 5;\n+        //~^ ERROR: declaration of a static with `export_name`\n         unsafe {} //~ ERROR: usage of an `unsafe` block\n-    }\n+    }}\n }\n \n+#[no_mangle] fn foo() {} //~ ERROR: declaration of a `no_mangle` function\n+#[no_mangle] static FOO: u32 = 5; //~ ERROR: declaration of a `no_mangle` static\n+\n+#[export_name = \"bar\"] fn bar() {} //~ ERROR: declaration of a function with `export_name`\n+#[export_name = \"BAR\"] static BAR: u32 = 5; //~ ERROR: declaration of a static with `export_name`\n+\n unsafe fn baz() {} //~ ERROR: declaration of an `unsafe` function\n unsafe trait Foo {} //~ ERROR: declaration of an `unsafe` trait\n unsafe impl Foo for Bar {} //~ ERROR: implementation of an `unsafe` trait"}, {"sha": "a8ef047e517b49569e315cf85ad71023ad179dcd", "filename": "src/test/ui/lint/lint-unsafe-code.stderr", "status": "modified", "additions": 97, "deletions": 18, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/f4008fe94935d05ffb3a48fc5b7149070bb45550/src%2Ftest%2Fui%2Flint%2Flint-unsafe-code.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f4008fe94935d05ffb3a48fc5b7149070bb45550/src%2Ftest%2Fui%2Flint%2Flint-unsafe-code.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-unsafe-code.stderr?ref=f4008fe94935d05ffb3a48fc5b7149070bb45550", "patch": "@@ -1,89 +1,168 @@\n-error: declaration of an `unsafe` function\n-  --> $DIR/lint-unsafe-code.rs:23:1\n+error: declaration of a `no_mangle` function\n+  --> $DIR/lint-unsafe-code.rs:31:1\n    |\n-LL | unsafe fn baz() {}\n-   | ^^^^^^^^^^^^^^^^^^\n+LL | #[no_mangle] fn foo() {}\n+   | ^^^^^^^^^^^^\n    |\n note: the lint level is defined here\n   --> $DIR/lint-unsafe-code.rs:3:9\n    |\n LL | #![deny(unsafe_code)]\n    |         ^^^^^^^^^^^\n+   = note: the linker's behavior with multiple libraries exporting duplicate symbol names is undefined and Rust cannot provide guarantees when you manually override them\n+\n+error: declaration of a `no_mangle` static\n+  --> $DIR/lint-unsafe-code.rs:32:1\n+   |\n+LL | #[no_mangle] static FOO: u32 = 5;\n+   | ^^^^^^^^^^^^\n+   |\n+   = note: the linker's behavior with multiple libraries exporting duplicate symbol names is undefined and Rust cannot provide guarantees when you manually override them\n+\n+error: declaration of a function with `export_name`\n+  --> $DIR/lint-unsafe-code.rs:34:1\n+   |\n+LL | #[export_name = \"bar\"] fn bar() {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: the linker's behavior with multiple libraries exporting duplicate symbol names is undefined and Rust cannot provide guarantees when you manually override them\n+\n+error: declaration of a static with `export_name`\n+  --> $DIR/lint-unsafe-code.rs:35:1\n+   |\n+LL | #[export_name = \"BAR\"] static BAR: u32 = 5;\n+   | ^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: the linker's behavior with multiple libraries exporting duplicate symbol names is undefined and Rust cannot provide guarantees when you manually override them\n+\n+error: declaration of an `unsafe` function\n+  --> $DIR/lint-unsafe-code.rs:37:1\n+   |\n+LL | unsafe fn baz() {}\n+   | ^^^^^^^^^^^^^^^^^^\n \n error: declaration of an `unsafe` trait\n-  --> $DIR/lint-unsafe-code.rs:24:1\n+  --> $DIR/lint-unsafe-code.rs:38:1\n    |\n LL | unsafe trait Foo {}\n    | ^^^^^^^^^^^^^^^^^^^\n \n error: implementation of an `unsafe` trait\n-  --> $DIR/lint-unsafe-code.rs:25:1\n+  --> $DIR/lint-unsafe-code.rs:39:1\n    |\n LL | unsafe impl Foo for Bar {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: declaration of an `unsafe` method\n-  --> $DIR/lint-unsafe-code.rs:28:5\n+  --> $DIR/lint-unsafe-code.rs:42:5\n    |\n LL |     unsafe fn baz(&self);\n    |     ^^^^^^^^^^^^^^^^^^^^^\n \n error: implementation of an `unsafe` method\n-  --> $DIR/lint-unsafe-code.rs:29:5\n+  --> $DIR/lint-unsafe-code.rs:43:5\n    |\n LL |     unsafe fn provided(&self) {}\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: implementation of an `unsafe` method\n-  --> $DIR/lint-unsafe-code.rs:30:5\n+  --> $DIR/lint-unsafe-code.rs:44:5\n    |\n LL |     unsafe fn provided_override(&self) {}\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: implementation of an `unsafe` method\n-  --> $DIR/lint-unsafe-code.rs:34:5\n+  --> $DIR/lint-unsafe-code.rs:48:5\n    |\n LL |     unsafe fn baz(&self) {}\n    |     ^^^^^^^^^^^^^^^^^^^^^^^\n \n error: implementation of an `unsafe` method\n-  --> $DIR/lint-unsafe-code.rs:35:5\n+  --> $DIR/lint-unsafe-code.rs:49:5\n    |\n LL |     unsafe fn provided_override(&self) {}\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: implementation of an `unsafe` method\n-  --> $DIR/lint-unsafe-code.rs:54:5\n+  --> $DIR/lint-unsafe-code.rs:68:5\n    |\n LL |     unsafe fn provided_override(&self) {}\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: implementation of an `unsafe` method\n-  --> $DIR/lint-unsafe-code.rs:65:5\n+  --> $DIR/lint-unsafe-code.rs:79:5\n    |\n LL |     unsafe fn provided(&self) {}\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: implementation of an `unsafe` method\n-  --> $DIR/lint-unsafe-code.rs:71:5\n+  --> $DIR/lint-unsafe-code.rs:85:5\n    |\n LL |     unsafe fn provided(&self) {}\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: implementation of an `unsafe` method\n-  --> $DIR/lint-unsafe-code.rs:75:5\n+  --> $DIR/lint-unsafe-code.rs:89:5\n    |\n LL |     unsafe fn baz(&self) {}\n    |     ^^^^^^^^^^^^^^^^^^^^^^^\n \n error: usage of an `unsafe` block\n-  --> $DIR/lint-unsafe-code.rs:86:5\n+  --> $DIR/lint-unsafe-code.rs:100:5\n    |\n LL |     unsafe {}\n    |     ^^^^^^^^^\n \n+error: declaration of a `no_mangle` function\n+  --> $DIR/lint-unsafe-code.rs:21:9\n+   |\n+LL |         #[no_mangle] fn foo() {}\n+   |         ^^^^^^^^^^^^\n+...\n+LL |     unsafe_in_macro!()\n+   |     ------------------ in this macro invocation\n+   |\n+   = note: the linker's behavior with multiple libraries exporting duplicate symbol names is undefined and Rust cannot provide guarantees when you manually override them\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: declaration of a `no_mangle` static\n+  --> $DIR/lint-unsafe-code.rs:22:9\n+   |\n+LL |         #[no_mangle] static FOO: u32 = 5;\n+   |         ^^^^^^^^^^^^\n+...\n+LL |     unsafe_in_macro!()\n+   |     ------------------ in this macro invocation\n+   |\n+   = note: the linker's behavior with multiple libraries exporting duplicate symbol names is undefined and Rust cannot provide guarantees when you manually override them\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: declaration of a function with `export_name`\n+  --> $DIR/lint-unsafe-code.rs:23:9\n+   |\n+LL |         #[export_name = \"bar\"] fn bar() {}\n+   |         ^^^^^^^^^^^^^^^^^^^^^^\n+...\n+LL |     unsafe_in_macro!()\n+   |     ------------------ in this macro invocation\n+   |\n+   = note: the linker's behavior with multiple libraries exporting duplicate symbol names is undefined and Rust cannot provide guarantees when you manually override them\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: declaration of a static with `export_name`\n+  --> $DIR/lint-unsafe-code.rs:25:9\n+   |\n+LL |         #[export_name = \"BAR\"] static BAR: u32 = 5;\n+   |         ^^^^^^^^^^^^^^^^^^^^^^\n+...\n+LL |     unsafe_in_macro!()\n+   |     ------------------ in this macro invocation\n+   |\n+   = note: the linker's behavior with multiple libraries exporting duplicate symbol names is undefined and Rust cannot provide guarantees when you manually override them\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n error: usage of an `unsafe` block\n-  --> $DIR/lint-unsafe-code.rs:19:9\n+  --> $DIR/lint-unsafe-code.rs:27:9\n    |\n LL |         unsafe {}\n    |         ^^^^^^^^^\n@@ -93,5 +172,5 @@ LL |     unsafe_in_macro!()\n    |\n    = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-error: aborting due to 14 previous errors\n+error: aborting due to 22 previous errors\n "}, {"sha": "ca86788dff79cadc781eaa731a4d2277804df8ac", "filename": "src/test/ui/parser/issue-81806.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f4008fe94935d05ffb3a48fc5b7149070bb45550/src%2Ftest%2Fui%2Fparser%2Fissue-81806.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4008fe94935d05ffb3a48fc5b7149070bb45550/src%2Ftest%2Fui%2Fparser%2Fissue-81806.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-81806.rs?ref=f4008fe94935d05ffb3a48fc5b7149070bb45550", "patch": "@@ -0,0 +1,5 @@\n+trait T { const\n+impl //~ ERROR: expected identifier, found keyword `impl`\n+}\n+\n+fn main() {}"}, {"sha": "b8ada11d922b247765f7d2734c4deb69b7772bef", "filename": "src/test/ui/parser/issue-81806.stderr", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/f4008fe94935d05ffb3a48fc5b7149070bb45550/src%2Ftest%2Fui%2Fparser%2Fissue-81806.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f4008fe94935d05ffb3a48fc5b7149070bb45550/src%2Ftest%2Fui%2Fparser%2Fissue-81806.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-81806.stderr?ref=f4008fe94935d05ffb3a48fc5b7149070bb45550", "patch": "@@ -0,0 +1,17 @@\n+error: expected identifier, found keyword `impl`\n+  --> $DIR/issue-81806.rs:2:1\n+   |\n+LL | trait T { const\n+   |         - while parsing this item list starting here\n+LL | impl\n+   | ^^^^ expected identifier, found keyword\n+LL | }\n+   | - the item list ends here\n+   |\n+help: you can escape reserved keywords to use them as identifiers\n+   |\n+LL | r#impl\n+   | ^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "336909b63a14b801520c6627d90d750babcfe280", "filename": "src/tools/rust-analyzer", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frust-analyzer?ref=f4008fe94935d05ffb3a48fc5b7149070bb45550", "patch": "@@ -1 +1 @@\n-Subproject commit 1a59f75cdaa730c16a694a4294eccf6dfe6fe0ad\n+Subproject commit 336909b63a14b801520c6627d90d750babcfe280"}]}