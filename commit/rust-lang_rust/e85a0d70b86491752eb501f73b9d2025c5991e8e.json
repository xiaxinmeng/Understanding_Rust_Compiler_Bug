{"sha": "e85a0d70b86491752eb501f73b9d2025c5991e8e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU4NWEwZDcwYjg2NDkxNzUyZWI1MDFmNzNiOWQyMDI1YzU5OTFlOGU=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-11-16T10:52:37Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-11-21T09:00:55Z"}, "message": "Use `Symbol` instead of `InternedString` in the AST, HIR, and various other places.", "tree": {"sha": "a88f0e13a62398369117b8d7246c6684be031758", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a88f0e13a62398369117b8d7246c6684be031758"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e85a0d70b86491752eb501f73b9d2025c5991e8e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e85a0d70b86491752eb501f73b9d2025c5991e8e", "html_url": "https://github.com/rust-lang/rust/commit/e85a0d70b86491752eb501f73b9d2025c5991e8e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e85a0d70b86491752eb501f73b9d2025c5991e8e/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0", "url": "https://api.github.com/repos/rust-lang/rust/commits/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0", "html_url": "https://github.com/rust-lang/rust/commit/d2f8fb0a0a9dd98ea9d6a01620f1a21f425236c0"}], "stats": {"total": 852, "additions": 399, "deletions": 453}, "files": [{"sha": "673429b49f79038e2b048ec041a52ad2c1a30c6c", "filename": "src/librustc/hir/map/definitions.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs?ref=e85a0d70b86491752eb501f73b9d2025c5991e8e", "patch": "@@ -115,9 +115,9 @@ impl DefPath {\n     pub fn to_string(&self, tcx: TyCtxt) -> String {\n         let mut s = String::with_capacity(self.data.len() * 16);\n \n-        s.push_str(&tcx.original_crate_name(self.krate));\n+        s.push_str(&tcx.original_crate_name(self.krate).as_str());\n         s.push_str(\"/\");\n-        s.push_str(&tcx.crate_disambiguator(self.krate));\n+        s.push_str(&tcx.crate_disambiguator(self.krate).as_str());\n \n         for component in &self.data {\n             write!(s,\n@@ -137,8 +137,8 @@ impl DefPath {\n     }\n \n     pub fn deterministic_hash_to<H: Hasher>(&self, tcx: TyCtxt, state: &mut H) {\n-        tcx.original_crate_name(self.krate).hash(state);\n-        tcx.crate_disambiguator(self.krate).hash(state);\n+        tcx.original_crate_name(self.krate).as_str().hash(state);\n+        tcx.crate_disambiguator(self.krate).as_str().hash(state);\n         self.data.hash(state);\n     }\n }"}, {"sha": "b5f892f0ff7ace30a831ece6e506eb33fa001a65", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=e85a0d70b86491752eb501f73b9d2025c5991e8e", "patch": "@@ -41,7 +41,7 @@ use syntax::abi::Abi;\n use syntax::ast::{Name, NodeId, DUMMY_NODE_ID, AsmDialect};\n use syntax::ast::{Attribute, Lit, StrStyle, FloatTy, IntTy, UintTy, MetaItem};\n use syntax::ptr::P;\n-use syntax::symbol::{keywords, InternedString};\n+use syntax::symbol::{Symbol, keywords};\n use syntax::tokenstream::TokenTree;\n use syntax::util::ThinVec;\n \n@@ -1163,18 +1163,18 @@ pub enum Ty_ {\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct InlineAsmOutput {\n-    pub constraint: InternedString,\n+    pub constraint: Symbol,\n     pub is_rw: bool,\n     pub is_indirect: bool,\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct InlineAsm {\n-    pub asm: InternedString,\n+    pub asm: Symbol,\n     pub asm_str_style: StrStyle,\n     pub outputs: HirVec<InlineAsmOutput>,\n-    pub inputs: HirVec<InternedString>,\n-    pub clobbers: HirVec<InternedString>,\n+    pub inputs: HirVec<Symbol>,\n+    pub clobbers: HirVec<Symbol>,\n     pub volatile: bool,\n     pub alignstack: bool,\n     pub dialect: AsmDialect,"}, {"sha": "b9d1d7e4efbb986a91e3348c06fa13f760287f14", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=e85a0d70b86491752eb501f73b9d2025c5991e8e", "patch": "@@ -1500,19 +1500,19 @@ impl<'a> State<'a> {\n             hir::ExprInlineAsm(ref a, ref outputs, ref inputs) => {\n                 word(&mut self.s, \"asm!\")?;\n                 self.popen()?;\n-                self.print_string(&a.asm, a.asm_str_style)?;\n+                self.print_string(&a.asm.as_str(), a.asm_str_style)?;\n                 self.word_space(\":\")?;\n \n                 let mut out_idx = 0;\n                 self.commasep(Inconsistent, &a.outputs, |s, out| {\n-                    let mut ch = out.constraint.chars();\n+                    let constraint = out.constraint.as_str();\n+                    let mut ch = constraint.chars();\n                     match ch.next() {\n                         Some('=') if out.is_rw => {\n                             s.print_string(&format!(\"+{}\", ch.as_str()),\n                                            ast::StrStyle::Cooked)?\n                         }\n-                        _ => s.print_string(&out.constraint,\n-                                            ast::StrStyle::Cooked)?,\n+                        _ => s.print_string(&constraint, ast::StrStyle::Cooked)?,\n                     }\n                     s.popen()?;\n                     s.print_expr(&outputs[out_idx])?;\n@@ -1525,7 +1525,7 @@ impl<'a> State<'a> {\n \n                 let mut in_idx = 0;\n                 self.commasep(Inconsistent, &a.inputs, |s, co| {\n-                    s.print_string(&co, ast::StrStyle::Cooked)?;\n+                    s.print_string(&co.as_str(), ast::StrStyle::Cooked)?;\n                     s.popen()?;\n                     s.print_expr(&inputs[in_idx])?;\n                     s.pclose()?;\n@@ -1536,7 +1536,7 @@ impl<'a> State<'a> {\n                 self.word_space(\":\")?;\n \n                 self.commasep(Inconsistent, &a.clobbers, |s, co| {\n-                    s.print_string(&co, ast::StrStyle::Cooked)?;\n+                    s.print_string(&co.as_str(), ast::StrStyle::Cooked)?;\n                     Ok(())\n                 })?;\n "}, {"sha": "168aba774333e99c1cf0af4284efe91f49f9f104", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=e85a0d70b86491752eb501f73b9d2025c5991e8e", "patch": "@@ -39,7 +39,7 @@ use syntax::ast;\n use syntax::attr;\n use syntax::ext::base::SyntaxExtension;\n use syntax::ptr::P;\n-use syntax::symbol::InternedString;\n+use syntax::symbol::Symbol;\n use syntax_pos::Span;\n use rustc_back::target::Target;\n use hir;\n@@ -52,7 +52,7 @@ pub use self::NativeLibraryKind::{NativeStatic, NativeFramework, NativeUnknown};\n \n #[derive(Clone, Debug)]\n pub struct LinkMeta {\n-    pub crate_name: String,\n+    pub crate_name: Symbol,\n     pub crate_hash: Svh,\n }\n \n@@ -92,7 +92,7 @@ pub enum NativeLibraryKind {\n #[derive(Clone, Hash, RustcEncodable, RustcDecodable)]\n pub struct NativeLibrary {\n     pub kind: NativeLibraryKind,\n-    pub name: String,\n+    pub name: Symbol,\n     pub cfg: Option<ast::MetaItem>,\n }\n \n@@ -205,11 +205,11 @@ pub trait CrateStore<'tcx> {\n     fn extern_crate(&self, cnum: CrateNum) -> Option<ExternCrate>;\n     /// The name of the crate as it is referred to in source code of the current\n     /// crate.\n-    fn crate_name(&self, cnum: CrateNum) -> InternedString;\n+    fn crate_name(&self, cnum: CrateNum) -> Symbol;\n     /// The name of the crate as it is stored in the crate's metadata.\n-    fn original_crate_name(&self, cnum: CrateNum) -> InternedString;\n+    fn original_crate_name(&self, cnum: CrateNum) -> Symbol;\n     fn crate_hash(&self, cnum: CrateNum) -> Svh;\n-    fn crate_disambiguator(&self, cnum: CrateNum) -> InternedString;\n+    fn crate_disambiguator(&self, cnum: CrateNum) -> Symbol;\n     fn plugin_registrar_fn(&self, cnum: CrateNum) -> Option<DefId>;\n     fn native_libraries(&self, cnum: CrateNum) -> Vec<NativeLibrary>;\n     fn reachable_ids(&self, cnum: CrateNum) -> Vec<DefId>;\n@@ -375,13 +375,13 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n         bug!(\"panic_strategy\")\n     }\n     fn extern_crate(&self, cnum: CrateNum) -> Option<ExternCrate> { bug!(\"extern_crate\") }\n-    fn crate_name(&self, cnum: CrateNum) -> InternedString { bug!(\"crate_name\") }\n-    fn original_crate_name(&self, cnum: CrateNum) -> InternedString {\n+    fn crate_name(&self, cnum: CrateNum) -> Symbol { bug!(\"crate_name\") }\n+    fn original_crate_name(&self, cnum: CrateNum) -> Symbol {\n         bug!(\"original_crate_name\")\n     }\n     fn crate_hash(&self, cnum: CrateNum) -> Svh { bug!(\"crate_hash\") }\n     fn crate_disambiguator(&self, cnum: CrateNum)\n-                           -> InternedString { bug!(\"crate_disambiguator\") }\n+                           -> Symbol { bug!(\"crate_disambiguator\") }\n     fn plugin_registrar_fn(&self, cnum: CrateNum) -> Option<DefId>\n         { bug!(\"plugin_registrar_fn\") }\n     fn native_libraries(&self, cnum: CrateNum) -> Vec<NativeLibrary>"}, {"sha": "5af9a2f02742effbe3d4a5663a4fd177b654a7ed", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=e85a0d70b86491752eb501f73b9d2025c5991e8e", "patch": "@@ -30,7 +30,7 @@ use middle::weak_lang_items;\n use util::nodemap::FxHashMap;\n \n use syntax::ast;\n-use syntax::symbol::InternedString;\n+use syntax::symbol::Symbol;\n use hir::itemlikevisit::ItemLikeVisitor;\n use hir;\n \n@@ -152,15 +152,15 @@ struct LanguageItemCollector<'a, 'tcx: 'a> {\n impl<'a, 'v, 'tcx> ItemLikeVisitor<'v> for LanguageItemCollector<'a, 'tcx> {\n     fn visit_item(&mut self, item: &hir::Item) {\n         if let Some(value) = extract(&item.attrs) {\n-            let item_index = self.item_refs.get(&value[..]).cloned();\n+            let item_index = self.item_refs.get(&*value.as_str()).cloned();\n \n             if let Some(item_index) = item_index {\n                 self.collect_item(item_index, self.ast_map.local_def_id(item.id))\n             } else {\n                 let span = self.ast_map.span(item.id);\n                 span_err!(self.session, span, E0522,\n                           \"definition of an unknown language item: `{}`.\",\n-                          &value[..]);\n+                          value);\n             }\n         }\n     }\n@@ -243,12 +243,10 @@ impl<'a, 'tcx> LanguageItemCollector<'a, 'tcx> {\n     }\n }\n \n-pub fn extract(attrs: &[ast::Attribute]) -> Option<InternedString> {\n+pub fn extract(attrs: &[ast::Attribute]) -> Option<Symbol> {\n     for attribute in attrs {\n         match attribute.value_str() {\n-            Some(ref value) if attribute.check_name(\"lang\") => {\n-                return Some(value.clone());\n-            }\n+            Some(value) if attribute.check_name(\"lang\") => return Some(value),\n             _ => {}\n         }\n     }"}, {"sha": "7f89461a3f4b6823718ec24788f9f06381747f6d", "filename": "src/librustc/middle/recursion_limit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibrustc%2Fmiddle%2Frecursion_limit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibrustc%2Fmiddle%2Frecursion_limit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Frecursion_limit.rs?ref=e85a0d70b86491752eb501f73b9d2025c5991e8e", "patch": "@@ -25,7 +25,7 @@ pub fn update_recursion_limit(sess: &Session, krate: &ast::Crate) {\n         }\n \n         if let Some(s) = attr.value_str() {\n-            if let Some(n) = s.parse().ok() {\n+            if let Some(n) = s.as_str().parse().ok() {\n                 sess.recursion_limit.set(n);\n                 return;\n             }"}, {"sha": "6b2e3de34f378f8e598ac768727f1476498c47cd", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=e85a0d70b86491752eb501f73b9d2025c5991e8e", "patch": "@@ -21,7 +21,7 @@ use hir::def::Def;\n use hir::def_id::{CrateNum, CRATE_DEF_INDEX, DefId, DefIndex, LOCAL_CRATE};\n use ty::{self, TyCtxt, AdtKind};\n use middle::privacy::AccessLevels;\n-use syntax::symbol::InternedString;\n+use syntax::symbol::Symbol;\n use syntax_pos::{Span, DUMMY_SP};\n use syntax::ast;\n use syntax::ast::{NodeId, Attribute};\n@@ -36,7 +36,6 @@ use hir::pat_util::EnumerateAndAdjustIterator;\n \n use std::mem::replace;\n use std::cmp::Ordering;\n-use std::ops::Deref;\n \n #[derive(RustcEncodable, RustcDecodable, PartialEq, PartialOrd, Clone, Copy, Debug, Eq, Hash)]\n pub enum StabilityLevel {\n@@ -151,10 +150,11 @@ impl<'a, 'tcx: 'a> Annotator<'a, 'tcx> {\n \n                 // Check if deprecated_since < stable_since. If it is,\n                 // this is *almost surely* an accident.\n-                if let (&Some(attr::RustcDeprecation {since: ref dep_since, ..}),\n-                        &attr::Stable {since: ref stab_since}) = (&stab.rustc_depr, &stab.level) {\n+                if let (&Some(attr::RustcDeprecation {since: dep_since, ..}),\n+                        &attr::Stable {since: stab_since}) = (&stab.rustc_depr, &stab.level) {\n                     // Explicit version of iter::order::lt to handle parse errors properly\n-                    for (dep_v, stab_v) in dep_since.split(\".\").zip(stab_since.split(\".\")) {\n+                    for (dep_v, stab_v) in\n+                            dep_since.as_str().split(\".\").zip(stab_since.as_str().split(\".\")) {\n                         if let (Ok(dep_v), Ok(stab_v)) = (dep_v.parse::<u64>(), stab_v.parse()) {\n                             match dep_v.cmp(&stab_v) {\n                                 Ordering::Less => {\n@@ -356,7 +356,7 @@ impl<'a, 'tcx> Index<'tcx> {\n /// features and possibly prints errors. Returns a list of all\n /// features used.\n pub fn check_unstable_api_usage<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>)\n-                                          -> FxHashMap<InternedString, attr::StabilityLevel> {\n+                                          -> FxHashMap<Symbol, attr::StabilityLevel> {\n     let _task = tcx.dep_graph.in_task(DepNode::StabilityCheck);\n     let ref active_lib_features = tcx.sess.features.borrow().declared_lib_features;\n \n@@ -376,8 +376,8 @@ pub fn check_unstable_api_usage<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>)\n \n struct Checker<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    active_features: FxHashSet<InternedString>,\n-    used_features: FxHashMap<InternedString, attr::StabilityLevel>,\n+    active_features: FxHashSet<Symbol>,\n+    used_features: FxHashMap<Symbol, attr::StabilityLevel>,\n     // Within a block where feature gate checking can be skipped.\n     in_skip_block: u32,\n }\n@@ -407,10 +407,10 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n                 if !self.active_features.contains(feature) {\n                     let msg = match *reason {\n                         Some(ref r) => format!(\"use of unstable library feature '{}': {}\",\n-                                               &feature, &r),\n+                                               &feature.as_str(), &r),\n                         None => format!(\"use of unstable library feature '{}'\", &feature)\n                     };\n-                    emit_feature_err(&self.tcx.sess.parse_sess, &feature, span,\n+                    emit_feature_err(&self.tcx.sess.parse_sess, &feature.as_str(), span,\n                                      GateIssue::Library(Some(issue)), &msg);\n                 }\n             }\n@@ -735,18 +735,18 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n /// were expected to be library features), and the list of features used from\n /// libraries, identify activated features that don't exist and error about them.\n pub fn check_unused_or_stable_features(sess: &Session,\n-                                       lib_features_used: &FxHashMap<InternedString,\n+                                       lib_features_used: &FxHashMap<Symbol,\n                                                                      attr::StabilityLevel>) {\n     let ref declared_lib_features = sess.features.borrow().declared_lib_features;\n-    let mut remaining_lib_features: FxHashMap<InternedString, Span>\n+    let mut remaining_lib_features: FxHashMap<Symbol, Span>\n         = declared_lib_features.clone().into_iter().collect();\n \n     fn format_stable_since_msg(version: &str) -> String {\n         format!(\"this feature has been stable since {}. Attribute no longer needed\", version)\n     }\n \n     for &(ref stable_lang_feature, span) in &sess.features.borrow().declared_stable_lang_features {\n-        let version = find_lang_feature_accepted_version(stable_lang_feature.deref())\n+        let version = find_lang_feature_accepted_version(&stable_lang_feature.as_str())\n             .expect(\"unexpectedly couldn't find version feature was stabilized\");\n         sess.add_lint(lint::builtin::STABLE_FEATURES,\n                       ast::CRATE_NODE_ID,\n@@ -761,7 +761,7 @@ pub fn check_unused_or_stable_features(sess: &Session,\n                     sess.add_lint(lint::builtin::STABLE_FEATURES,\n                                   ast::CRATE_NODE_ID,\n                                   span,\n-                                  format_stable_since_msg(version.deref()));\n+                                  format_stable_since_msg(&version.as_str()));\n                 }\n             }\n             None => ( /* used but undeclared, handled during the previous ast visit */ )"}, {"sha": "ec6971d596b14cfa54bd16a13191dc84ab89be4b", "filename": "src/librustc/middle/weak_lang_items.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs?ref=e85a0d70b86491752eb501f73b9d2025c5991e8e", "patch": "@@ -16,7 +16,7 @@ use middle::lang_items;\n \n use rustc_back::PanicStrategy;\n use syntax::ast;\n-use syntax::symbol::InternedString;\n+use syntax::symbol::Symbol;\n use syntax_pos::Span;\n use hir::intravisit::Visitor;\n use hir::intravisit;\n@@ -55,10 +55,10 @@ pub fn check_crate(krate: &hir::Crate,\n     verify(sess, items);\n }\n \n-pub fn link_name(attrs: &[ast::Attribute]) -> Option<InternedString> {\n+pub fn link_name(attrs: &[ast::Attribute]) -> Option<Symbol> {\n     lang_items::extract(attrs).and_then(|name| {\n-        $(if &name[..] == stringify!($name) {\n-            Some(InternedString::new(stringify!($sym)))\n+        $(if name == stringify!($name) {\n+            Some(Symbol::intern(stringify!($sym)))\n         } else)* {\n             None\n         }\n@@ -126,7 +126,7 @@ impl<'a> Context<'a> {\n impl<'a, 'v> Visitor<'v> for Context<'a> {\n     fn visit_foreign_item(&mut self, i: &hir::ForeignItem) {\n         if let Some(lang_item) = lang_items::extract(&i.attrs) {\n-            self.register(&lang_item, i.span);\n+            self.register(&lang_item.as_str(), i.span);\n         }\n         intravisit::walk_foreign_item(self, i)\n     }"}, {"sha": "99c299861e05cb2b5257d452abf6d2d0917abc4b", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 15, "deletions": 17, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=e85a0d70b86491752eb501f73b9d2025c5991e8e", "patch": "@@ -26,7 +26,7 @@ use middle::cstore;\n \n use syntax::ast::{self, IntTy, UintTy};\n use syntax::parse;\n-use syntax::symbol::{Symbol, InternedString};\n+use syntax::symbol::Symbol;\n use syntax::feature_gate::UnstableFeatures;\n \n use errors::{ColorConfig, FatalError, Handler};\n@@ -927,8 +927,6 @@ pub fn default_lib_output() -> CrateType {\n }\n \n pub fn default_configuration(sess: &Session) -> ast::CrateConfig {\n-    use syntax::symbol::intern_and_get_ident as intern;\n-\n     let end = &sess.target.target.target_endian;\n     let arch = &sess.target.target.arch;\n     let wordsz = &sess.target.target.target_pointer_width;\n@@ -938,34 +936,34 @@ pub fn default_configuration(sess: &Session) -> ast::CrateConfig {\n     let max_atomic_width = sess.target.target.max_atomic_width();\n \n     let fam = if let Some(ref fam) = sess.target.target.options.target_family {\n-        intern(fam)\n+        Symbol::intern(fam)\n     } else if sess.target.target.options.is_like_windows {\n-        InternedString::new(\"windows\")\n+        Symbol::intern(\"windows\")\n     } else {\n-        InternedString::new(\"unix\")\n+        Symbol::intern(\"unix\")\n     };\n \n     let mut ret = HashSet::new();\n     // Target bindings.\n-    ret.insert((Symbol::intern(\"target_os\"), Some(intern(os))));\n-    ret.insert((Symbol::intern(\"target_family\"), Some(fam.clone())));\n-    ret.insert((Symbol::intern(\"target_arch\"), Some(intern(arch))));\n-    ret.insert((Symbol::intern(\"target_endian\"), Some(intern(end))));\n-    ret.insert((Symbol::intern(\"target_pointer_width\"), Some(intern(wordsz))));\n-    ret.insert((Symbol::intern(\"target_env\"), Some(intern(env))));\n-    ret.insert((Symbol::intern(\"target_vendor\"), Some(intern(vendor))));\n-    if &fam == \"windows\" || &fam == \"unix\" {\n-        ret.insert((Symbol::intern(&fam), None));\n+    ret.insert((Symbol::intern(\"target_os\"), Some(Symbol::intern(os))));\n+    ret.insert((Symbol::intern(\"target_family\"), Some(fam)));\n+    ret.insert((Symbol::intern(\"target_arch\"), Some(Symbol::intern(arch))));\n+    ret.insert((Symbol::intern(\"target_endian\"), Some(Symbol::intern(end))));\n+    ret.insert((Symbol::intern(\"target_pointer_width\"), Some(Symbol::intern(wordsz))));\n+    ret.insert((Symbol::intern(\"target_env\"), Some(Symbol::intern(env))));\n+    ret.insert((Symbol::intern(\"target_vendor\"), Some(Symbol::intern(vendor))));\n+    if fam == \"windows\" || fam == \"unix\" {\n+        ret.insert((fam, None));\n     }\n     if sess.target.target.options.has_elf_tls {\n         ret.insert((Symbol::intern(\"target_thread_local\"), None));\n     }\n     for &i in &[8, 16, 32, 64, 128] {\n         if i <= max_atomic_width {\n             let s = i.to_string();\n-            ret.insert((Symbol::intern(\"target_has_atomic\"), Some(intern(&s))));\n+            ret.insert((Symbol::intern(\"target_has_atomic\"), Some(Symbol::intern(&s))));\n             if &s == wordsz {\n-                ret.insert((Symbol::intern(\"target_has_atomic\"), Some(intern(\"ptr\"))));\n+                ret.insert((Symbol::intern(\"target_has_atomic\"), Some(Symbol::intern(\"ptr\"))));\n             }\n         }\n     }"}, {"sha": "9577a25b3f83099769a13165d522c3915c287a55", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=e85a0d70b86491752eb501f73b9d2025c5991e8e", "patch": "@@ -28,7 +28,7 @@ use syntax::json::JsonEmitter;\n use syntax::feature_gate;\n use syntax::parse;\n use syntax::parse::ParseSess;\n-use syntax::symbol::{Symbol, InternedString};\n+use syntax::symbol::Symbol;\n use syntax::{ast, codemap};\n use syntax::feature_gate::AttributeType;\n use syntax_pos::{Span, MultiSpan};\n@@ -89,7 +89,7 @@ pub struct Session {\n     // forms a unique global identifier for the crate. It is used to allow\n     // multiple crates with the same name to coexist. See the\n     // trans::back::symbol_names module for more information.\n-    pub crate_disambiguator: RefCell<InternedString>,\n+    pub crate_disambiguator: RefCell<Symbol>,\n     pub features: RefCell<feature_gate::Features>,\n \n     /// The maximum recursion limit for potentially infinitely recursive\n@@ -129,8 +129,8 @@ pub struct PerfStats {\n }\n \n impl Session {\n-    pub fn local_crate_disambiguator(&self) -> InternedString {\n-        self.crate_disambiguator.borrow().clone()\n+    pub fn local_crate_disambiguator(&self) -> Symbol {\n+        *self.crate_disambiguator.borrow()\n     }\n     pub fn struct_span_warn<'a, S: Into<MultiSpan>>(&'a self,\n                                                     sp: S,\n@@ -610,7 +610,7 @@ pub fn build_session_(sopts: config::Options,\n         plugin_attributes: RefCell::new(Vec::new()),\n         crate_types: RefCell::new(Vec::new()),\n         dependency_formats: RefCell::new(FxHashMap()),\n-        crate_disambiguator: RefCell::new(Symbol::intern(\"\").as_str()),\n+        crate_disambiguator: RefCell::new(Symbol::intern(\"\")),\n         features: RefCell::new(feature_gate::Features::new()),\n         recursion_limit: Cell::new(64),\n         next_node_id: Cell::new(NodeId::new(1)),"}, {"sha": "21009711cb18ae61a17cf486142d75a5d6b609f8", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=e85a0d70b86491752eb501f73b9d2025c5991e8e", "patch": "@@ -246,12 +246,13 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 let err_sp = item.meta().span.substitute_dummy(span);\n                 let def = self.tcx.lookup_trait_def(trait_ref.def_id);\n                 let trait_str = def.trait_ref.to_string();\n-                if let Some(ref istring) = item.value_str() {\n+                if let Some(istring) = item.value_str() {\n+                    let istring = &*istring.as_str();\n                     let generic_map = def.generics.types.iter().map(|param| {\n                         (param.name.as_str().to_string(),\n                          trait_ref.substs.type_for_def(param).to_string())\n                     }).collect::<FxHashMap<String, String>>();\n-                    let parser = Parser::new(&istring);\n+                    let parser = Parser::new(istring);\n                     let mut errored = false;\n                     let err: String = parser.filter_map(|p| {\n                         match p {"}, {"sha": "20855c46b68002453844f0b2169ba979b4d242cf", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=e85a0d70b86491752eb501f73b9d2025c5991e8e", "patch": "@@ -49,7 +49,7 @@ use std::rc::Rc;\n use std::iter;\n use syntax::ast::{self, Name, NodeId};\n use syntax::attr;\n-use syntax::symbol::{InternedString, intern_and_get_ident, keywords};\n+use syntax::symbol::{Symbol, keywords};\n \n use hir;\n \n@@ -561,7 +561,7 @@ pub struct GlobalCtxt<'tcx> {\n \n     /// The definite name of the current crate after taking into account\n     /// attributes, commandline parameters, etc.\n-    pub crate_name: InternedString,\n+    pub crate_name: Symbol,\n \n     /// Data layout specification for the current target.\n     pub data_layout: TargetDataLayout,\n@@ -574,7 +574,7 @@ pub struct GlobalCtxt<'tcx> {\n \n     /// Map from function to the `#[derive]` mode that it's defining. Only used\n     /// by `proc-macro` crates.\n-    pub derive_macros: RefCell<NodeMap<InternedString>>,\n+    pub derive_macros: RefCell<NodeMap<Symbol>>,\n }\n \n impl<'tcx> GlobalCtxt<'tcx> {\n@@ -588,23 +588,23 @@ impl<'tcx> GlobalCtxt<'tcx> {\n }\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n-    pub fn crate_name(self, cnum: CrateNum) -> InternedString {\n+    pub fn crate_name(self, cnum: CrateNum) -> Symbol {\n         if cnum == LOCAL_CRATE {\n-            self.crate_name.clone()\n+            self.crate_name\n         } else {\n             self.sess.cstore.crate_name(cnum)\n         }\n     }\n \n-    pub fn original_crate_name(self, cnum: CrateNum) -> InternedString {\n+    pub fn original_crate_name(self, cnum: CrateNum) -> Symbol {\n         if cnum == LOCAL_CRATE {\n             self.crate_name.clone()\n         } else {\n             self.sess.cstore.original_crate_name(cnum)\n         }\n     }\n \n-    pub fn crate_disambiguator(self, cnum: CrateNum) -> InternedString {\n+    pub fn crate_disambiguator(self, cnum: CrateNum) -> Symbol {\n         if cnum == LOCAL_CRATE {\n             self.sess.local_crate_disambiguator()\n         } else {\n@@ -835,7 +835,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             custom_coerce_unsized_kinds: RefCell::new(DefIdMap()),\n             cast_kinds: RefCell::new(NodeMap()),\n             fragment_infos: RefCell::new(DefIdMap()),\n-            crate_name: intern_and_get_ident(crate_name),\n+            crate_name: Symbol::intern(crate_name),\n             data_layout: data_layout,\n             layout_cache: RefCell::new(FxHashMap()),\n             layout_depth: Cell::new(0),"}, {"sha": "b93a8698f603c1196a130ca4e1041b55ea1c7afd", "filename": "src/librustc/ty/item_path.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibrustc%2Fty%2Fitem_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibrustc%2Fty%2Fitem_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fitem_path.rs?ref=e85a0d70b86491752eb501f73b9d2025c5991e8e", "patch": "@@ -94,14 +94,14 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                     if let Some(extern_crate_def_id) = opt_extern_crate {\n                         self.push_item_path(buffer, extern_crate_def_id);\n                     } else {\n-                        buffer.push(&self.crate_name(cnum));\n+                        buffer.push(&self.crate_name(cnum).as_str());\n                     }\n                 }\n             }\n             RootMode::Absolute => {\n                 // In absolute mode, just write the crate name\n                 // unconditionally.\n-                buffer.push(&self.original_crate_name(cnum));\n+                buffer.push(&self.original_crate_name(cnum).as_str());\n             }\n         }\n     }\n@@ -126,7 +126,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                         return true;\n                     }\n                     None => {\n-                        buffer.push(&self.crate_name(cur_def.krate));\n+                        buffer.push(&self.crate_name(cur_def.krate).as_str());\n                         cur_path.iter().rev().map(|segment| buffer.push(&segment.as_str())).count();\n                         return true;\n                     }"}, {"sha": "e94e93158c47a2de9d3f2b8e464fdb10a1c78e82", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=e85a0d70b86491752eb501f73b9d2025c5991e8e", "patch": "@@ -2344,7 +2344,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         if let Some(id) = self.map.as_local_node_id(id) {\n             self.map.name(id)\n         } else if id.index == CRATE_DEF_INDEX {\n-            Symbol::intern(&self.sess.cstore.original_crate_name(id.krate))\n+            self.sess.cstore.original_crate_name(id.krate)\n         } else {\n             let def_key = self.sess.cstore.def_key(id);\n             // The name of a StructCtor is that of its struct parent.\n@@ -2747,7 +2747,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n     /// Looks up the span of `impl_did` if the impl is local; otherwise returns `Err`\n     /// with the name of the crate containing the impl.\n-    pub fn span_of_impl(self, impl_did: DefId) -> Result<Span, InternedString> {\n+    pub fn span_of_impl(self, impl_did: DefId) -> Result<Span, Symbol> {\n         if impl_did.is_local() {\n             let node_id = self.map.as_local_node_id(impl_did).unwrap();\n             Ok(self.map.span(node_id))"}, {"sha": "c265fa97e2957d2b094ad7f7d8e9c59d8b7d0acf", "filename": "src/librustc_const_eval/eval.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibrustc_const_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibrustc_const_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Feval.rs?ref=e85a0d70b86491752eb501f73b9d2025c5991e8e", "patch": "@@ -1221,7 +1221,7 @@ fn lit_to_const<'a, 'tcx>(lit: &ast::LitKind,\n     use syntax::ast::*;\n     use syntax::ast::LitIntType::*;\n     match *lit {\n-        LitKind::Str(ref s, _) => Ok(Str((*s).clone())),\n+        LitKind::Str(ref s, _) => Ok(Str(s.as_str())),\n         LitKind::ByteStr(ref data) => Ok(ByteStr(data.clone())),\n         LitKind::Byte(n) => Ok(Integral(U8(n))),\n         LitKind::Int(n, Signed(ity)) => {\n@@ -1249,15 +1249,15 @@ fn lit_to_const<'a, 'tcx>(lit: &ast::LitKind,\n             infer(Infer(n), tcx, &ty::TyUint(ity)).map(Integral)\n         },\n \n-        LitKind::Float(ref n, fty) => {\n-            parse_float(n, Some(fty)).map(Float)\n+        LitKind::Float(n, fty) => {\n+            parse_float(&n.as_str(), Some(fty)).map(Float)\n         }\n-        LitKind::FloatUnsuffixed(ref n) => {\n+        LitKind::FloatUnsuffixed(n) => {\n             let fty_hint = match ty_hint.map(|t| &t.sty) {\n                 Some(&ty::TyFloat(fty)) => Some(fty),\n                 _ => None\n             };\n-            parse_float(n, fty_hint).map(Float)\n+            parse_float(&n.as_str(), fty_hint).map(Float)\n         }\n         LitKind::Bool(b) => Ok(Bool(b)),\n         LitKind::Char(c) => Ok(Char(c)),"}, {"sha": "f93934f975b9f96996c2d00178ce3e69e17b6ff0", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=e85a0d70b86491752eb501f73b9d2025c5991e8e", "patch": "@@ -561,8 +561,7 @@ pub fn phase_2_configure_and_expand<'a, F>(sess: &Session,\n     *sess.features.borrow_mut() = features;\n \n     *sess.crate_types.borrow_mut() = collect_crate_types(sess, &krate.attrs);\n-    *sess.crate_disambiguator.borrow_mut() =\n-        Symbol::intern(&compute_crate_disambiguator(sess)).as_str();\n+    *sess.crate_disambiguator.borrow_mut() = Symbol::intern(&compute_crate_disambiguator(sess));\n \n     time(time_passes, \"recursion limit\", || {\n         middle::recursion_limit::update_recursion_limit(sess, &krate);\n@@ -1105,7 +1104,7 @@ pub fn phase_6_link_output(sess: &Session,\n                            outputs: &OutputFilenames) {\n     time(sess.time_passes(),\n          \"linking\",\n-         || link::link_binary(sess, trans, outputs, &trans.link.crate_name));\n+         || link::link_binary(sess, trans, outputs, &trans.link.crate_name.as_str()));\n }\n \n fn escape_dep_filename(filename: &str) -> String {"}, {"sha": "876323d599e857bc3f30f867b3c07b36a84daab3", "filename": "src/librustc_driver/target_features.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibrustc_driver%2Ftarget_features.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibrustc_driver%2Ftarget_features.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftarget_features.rs?ref=e85a0d70b86491752eb501f73b9d2025c5991e8e", "patch": "@@ -13,7 +13,7 @@ use llvm::LLVMRustHasFeature;\n use rustc::session::Session;\n use rustc_trans::back::write::create_target_machine;\n use syntax::feature_gate::UnstableFeatures;\n-use syntax::symbol::{Symbol, intern_and_get_ident as intern};\n+use syntax::symbol::Symbol;\n use libc::c_char;\n \n // WARNING: the features must be known to LLVM or the feature\n@@ -44,7 +44,7 @@ pub fn add_configuration(cfg: &mut ast::CrateConfig, sess: &Session) {\n     for feat in whitelist {\n         assert_eq!(feat.chars().last(), Some('\\0'));\n         if unsafe { LLVMRustHasFeature(target_machine, feat.as_ptr() as *const c_char) } {\n-            cfg.insert((tf, Some(intern(&feat[..feat.len() - 1]))));\n+            cfg.insert((tf, Some(Symbol::intern(&feat[..feat.len() - 1]))));\n         }\n     }\n \n@@ -73,6 +73,6 @@ pub fn add_configuration(cfg: &mut ast::CrateConfig, sess: &Session) {\n     }\n \n     if crt_static {\n-        cfg.insert((tf, Some(intern(\"crt-static\"))));\n+        cfg.insert((tf, Some(Symbol::intern(\"crt-static\"))));\n     }\n }"}, {"sha": "250ef061e5109305f9ff50ed1dde0db074685a43", "filename": "src/librustc_incremental/calculate_svh/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs?ref=e85a0d70b86491752eb501f73b9d2025c5991e8e", "patch": "@@ -172,8 +172,8 @@ impl<'a, 'tcx> HashItemsVisitor<'a, 'tcx> {\n \n         let crate_disambiguator = self.tcx.sess.local_crate_disambiguator();\n         \"crate_disambiguator\".hash(&mut crate_state);\n-        crate_disambiguator.len().hash(&mut crate_state);\n-        crate_disambiguator.hash(&mut crate_state);\n+        crate_disambiguator.as_str().len().hash(&mut crate_state);\n+        crate_disambiguator.as_str().hash(&mut crate_state);\n \n         // add each item (in some deterministic order) to the overall\n         // crate hash."}, {"sha": "546feb212243aca2c3d629ae8a7e89345356481d", "filename": "src/librustc_incremental/persist/directory.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibrustc_incremental%2Fpersist%2Fdirectory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibrustc_incremental%2Fpersist%2Fdirectory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirectory.rs?ref=e85a0d70b86491752eb501f73b9d2025c5991e8e", "patch": "@@ -84,8 +84,8 @@ impl DefIdDirectory {\n             assert_eq!(old_info.krate, krate);\n             let old_name: &str = &old_info.name;\n             let old_disambiguator: &str = &old_info.disambiguator;\n-            let new_name: &str = &tcx.crate_name(krate);\n-            let new_disambiguator: &str = &tcx.crate_disambiguator(krate);\n+            let new_name: &str = &tcx.crate_name(krate).as_str();\n+            let new_disambiguator: &str = &tcx.crate_disambiguator(krate).as_str();\n             old_name == new_name && old_disambiguator == new_disambiguator\n         }\n     }\n@@ -99,8 +99,8 @@ impl DefIdDirectory {\n         let new_krates: HashMap<_, _> =\n             once(LOCAL_CRATE)\n             .chain(tcx.sess.cstore.crates())\n-            .map(|krate| (make_key(&tcx.crate_name(krate),\n-                                   &tcx.crate_disambiguator(krate)), krate))\n+            .map(|krate| (make_key(&tcx.crate_name(krate).as_str(),\n+                                   &tcx.crate_disambiguator(krate).as_str()), krate))\n             .collect();\n \n         let ids = self.paths.iter()"}, {"sha": "85c35bf79ce81347a4273e82b83200d94fc301b9", "filename": "src/librustc_incremental/persist/dirty_clean.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs?ref=e85a0d70b86491752eb501f73b9d2025c5991e8e", "patch": "@@ -48,7 +48,6 @@ use rustc::hir::def_id::DefId;\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use syntax::ast::{self, Attribute, NestedMetaItem};\n use rustc_data_structures::fx::{FxHashSet, FxHashMap};\n-use syntax::symbol::Symbol;\n use syntax_pos::Span;\n use rustc::ty::TyCtxt;\n use ich::Fingerprint;\n@@ -286,7 +285,7 @@ fn check_config(tcx: TyCtxt, attr: &ast::Attribute) -> bool {\n \n fn expect_associated_value(tcx: TyCtxt, item: &NestedMetaItem) -> ast::Name {\n     if let Some(value) = item.value_str() {\n-        Symbol::intern(&value)\n+        value\n     } else {\n         let msg = if let Some(name) = item.name() {\n             format!(\"associated value expected for `{}`\", name)"}, {"sha": "26181dbaf50ff243b0501514c03abe059f4d5570", "filename": "src/librustc_incremental/persist/fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibrustc_incremental%2Fpersist%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibrustc_incremental%2Fpersist%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Ffs.rs?ref=e85a0d70b86491752eb501f73b9d2025c5991e8e", "patch": "@@ -604,7 +604,7 @@ fn string_to_timestamp(s: &str) -> Result<SystemTime, ()> {\n }\n \n fn crate_path_tcx(tcx: TyCtxt, cnum: CrateNum) -> PathBuf {\n-    crate_path(tcx.sess, &tcx.crate_name(cnum), &tcx.crate_disambiguator(cnum))\n+    crate_path(tcx.sess, &tcx.crate_name(cnum).as_str(), &tcx.crate_disambiguator(cnum).as_str())\n }\n \n /// Finds the session directory containing the correct metadata hashes file for"}, {"sha": "550b78e5c6e45d16380620d0c24bd48ad9e703c1", "filename": "src/librustc_lint/bad_style.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibrustc_lint%2Fbad_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibrustc_lint%2Fbad_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbad_style.rs?ref=e85a0d70b86491752eb501f73b9d2025c5991e8e", "patch": "@@ -241,8 +241,8 @@ impl LateLintPass for NonSnakeCase {\n             .and_then(|at| at.value_str().map(|s| (at, s)));\n         if let Some(ref name) = cx.tcx.sess.opts.crate_name {\n             self.check_snake_case(cx, \"crate\", name, None);\n-        } else if let Some((attr, ref name)) = attr_crate_name {\n-            self.check_snake_case(cx, \"crate\", name, Some(attr.span));\n+        } else if let Some((attr, name)) = attr_crate_name {\n+            self.check_snake_case(cx, \"crate\", &name.as_str(), Some(attr.span));\n         }\n     }\n "}, {"sha": "d3c5c5e1e65d7f56488018c167bf1a1bb84687ba", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=e85a0d70b86491752eb501f73b9d2025c5991e8e", "patch": "@@ -45,6 +45,7 @@ use std::collections::HashSet;\n use syntax::ast;\n use syntax::attr;\n use syntax::feature_gate::{AttributeGate, AttributeType, Stability, deprecated_attributes};\n+use syntax::symbol::Symbol;\n use syntax_pos::Span;\n \n use rustc::hir::{self, PatKind};\n@@ -633,20 +634,20 @@ impl Deprecated {\n             stability: &Option<&attr::Stability>,\n             deprecation: &Option<stability::DeprecationEntry>) {\n         // Deprecated attributes apply in-crate and cross-crate.\n-        if let Some(&attr::Stability{rustc_depr: Some(attr::RustcDeprecation{ref reason, ..}), ..})\n+        if let Some(&attr::Stability{rustc_depr: Some(attr::RustcDeprecation{reason, ..}), ..})\n                 = *stability {\n-            output(cx, DEPRECATED, span, Some(&reason))\n+            output(cx, DEPRECATED, span, Some(reason))\n         } else if let Some(ref depr_entry) = *deprecation {\n             if let Some(parent_depr) = cx.tcx.lookup_deprecation_entry(self.parent_def(cx)) {\n                 if parent_depr.same_origin(depr_entry) {\n                     return;\n                 }\n             }\n \n-            output(cx, DEPRECATED, span, depr_entry.attr.note.as_ref().map(|x| &**x))\n+            output(cx, DEPRECATED, span, depr_entry.attr.note)\n         }\n \n-        fn output(cx: &LateContext, lint: &'static Lint, span: Span, note: Option<&str>) {\n+        fn output(cx: &LateContext, lint: &'static Lint, span: Span, note: Option<Symbol>) {\n             let msg = if let Some(note) = note {\n                 format!(\"use of deprecated item: {}\", note)\n             } else {"}, {"sha": "8aa5e9e0a9460afb18d08531d44fc44577a0f1f7", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=e85a0d70b86491752eb501f73b9d2025c5991e8e", "patch": "@@ -219,9 +219,9 @@ impl LateLintPass for TypeLimits {\n                     ty::TyFloat(t) => {\n                         let (min, max) = float_ty_range(t);\n                         let lit_val: f64 = match lit.node {\n-                            ast::LitKind::Float(ref v, _) |\n-                            ast::LitKind::FloatUnsuffixed(ref v) => {\n-                                match v.parse() {\n+                            ast::LitKind::Float(v, _) |\n+                            ast::LitKind::FloatUnsuffixed(v) => {\n+                                match v.as_str().parse() {\n                                     Ok(f) => f,\n                                     Err(_) => return,\n                                 }"}, {"sha": "fa452017f0cf1d7fecbdb7a1ddbdc6fcf4ae3e97", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=e85a0d70b86491752eb501f73b9d2025c5991e8e", "patch": "@@ -162,7 +162,7 @@ impl LateLintPass for UnusedResults {\n                     // check for #[must_use=\"...\"]\n                     if let Some(s) = attr.value_str() {\n                         msg.push_str(\": \");\n-                        msg.push_str(&s);\n+                        msg.push_str(&s.as_str());\n                     }\n                     cx.span_lint(UNUSED_MUST_USE, sp, &msg);\n                     return true;"}, {"sha": "79a0d0d0389a978fbc3b6ec7c729cccb71ab5f2f", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 35, "deletions": 38, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=e85a0d70b86491752eb501f73b9d2025c5991e8e", "patch": "@@ -37,7 +37,7 @@ use syntax::abi::Abi;\n use syntax::attr;\n use syntax::ext::base::SyntaxExtension;\n use syntax::feature_gate::{self, GateIssue};\n-use syntax::symbol::{Symbol, InternedString};\n+use syntax::symbol::Symbol;\n use syntax_pos::{Span, DUMMY_SP};\n use log;\n \n@@ -52,7 +52,7 @@ pub struct CrateLoader<'a> {\n     cstore: &'a CStore,\n     next_crate_num: CrateNum,\n     foreign_item_map: FxHashMap<String, Vec<ast::NodeId>>,\n-    local_crate_name: String,\n+    local_crate_name: Symbol,\n }\n \n fn dump_crates(cstore: &CStore) {\n@@ -70,8 +70,8 @@ fn dump_crates(cstore: &CStore) {\n \n #[derive(Debug)]\n struct ExternCrateInfo {\n-    ident: String,\n-    name: String,\n+    ident: Symbol,\n+    name: Symbol,\n     id: ast::NodeId,\n     dep_kind: DepKind,\n }\n@@ -80,7 +80,7 @@ fn register_native_lib(sess: &Session,\n                        cstore: &CStore,\n                        span: Option<Span>,\n                        lib: NativeLibrary) {\n-    if lib.name.is_empty() {\n+    if lib.name.as_str().is_empty() {\n         match span {\n             Some(span) => {\n                 struct_span_err!(sess, span, E0454,\n@@ -147,7 +147,7 @@ impl<'a> CrateLoader<'a> {\n             cstore: cstore,\n             next_crate_num: cstore.next_crate_num(),\n             foreign_item_map: FxHashMap(),\n-            local_crate_name: local_crate_name.to_owned(),\n+            local_crate_name: Symbol::intern(local_crate_name),\n         }\n     }\n \n@@ -160,12 +160,12 @@ impl<'a> CrateLoader<'a> {\n                     Some(name) => {\n                         validate_crate_name(Some(self.sess), &name.as_str(),\n                                             Some(i.span));\n-                        name.to_string()\n+                        name\n                     }\n-                    None => i.ident.to_string(),\n+                    None => i.ident.name,\n                 };\n                 Some(ExternCrateInfo {\n-                    ident: i.ident.to_string(),\n+                    ident: i.ident.name,\n                     name: name,\n                     id: i.id,\n                     dep_kind: if attr::contains_name(&i.attrs, \"no_link\") {\n@@ -179,7 +179,7 @@ impl<'a> CrateLoader<'a> {\n         }\n     }\n \n-    fn existing_match(&self, name: &str, hash: Option<&Svh>, kind: PathKind)\n+    fn existing_match(&self, name: Symbol, hash: Option<&Svh>, kind: PathKind)\n                       -> Option<CrateNum> {\n         let mut ret = None;\n         self.cstore.iter_crate_data(|cnum, data| {\n@@ -201,7 +201,7 @@ impl<'a> CrateLoader<'a> {\n             // `source` stores paths which are normalized which may be different\n             // from the strings on the command line.\n             let source = self.cstore.used_crate_source(cnum);\n-            if let Some(locs) = self.sess.opts.externs.get(name) {\n+            if let Some(locs) = self.sess.opts.externs.get(&*name.as_str()) {\n                 let found = locs.iter().any(|l| {\n                     let l = fs::canonicalize(l).ok();\n                     source.dylib.as_ref().map(|p| &p.0) == l.as_ref() ||\n@@ -233,7 +233,7 @@ impl<'a> CrateLoader<'a> {\n                                   root: &CrateRoot) {\n         // Check for (potential) conflicts with the local crate\n         if self.local_crate_name == root.name &&\n-           self.sess.local_crate_disambiguator() == &root.disambiguator[..] {\n+           self.sess.local_crate_disambiguator() == root.disambiguator {\n             span_fatal!(self.sess, span, E0519,\n                         \"the current crate is indistinguishable from one of its \\\n                          dependencies: it has the same crate-name `{}` and was \\\n@@ -258,8 +258,8 @@ impl<'a> CrateLoader<'a> {\n \n     fn register_crate(&mut self,\n                       root: &Option<CratePaths>,\n-                      ident: &str,\n-                      name: &str,\n+                      ident: Symbol,\n+                      name: Symbol,\n                       span: Span,\n                       lib: Library,\n                       dep_kind: DepKind)\n@@ -290,7 +290,7 @@ impl<'a> CrateLoader<'a> {\n         let cnum_map = self.resolve_crate_deps(root, &crate_root, &metadata, cnum, span, dep_kind);\n \n         let cmeta = Rc::new(cstore::CrateMetadata {\n-            name: name.to_string(),\n+            name: name,\n             extern_crate: Cell::new(None),\n             key_map: metadata.load_key_map(crate_root.index),\n             proc_macros: crate_root.macro_derive_registrar.map(|_| {\n@@ -314,8 +314,8 @@ impl<'a> CrateLoader<'a> {\n \n     fn resolve_crate(&mut self,\n                      root: &Option<CratePaths>,\n-                     ident: &str,\n-                     name: &str,\n+                     ident: Symbol,\n+                     name: Symbol,\n                      hash: Option<&Svh>,\n                      span: Span,\n                      path_kind: PathKind,\n@@ -456,13 +456,12 @@ impl<'a> CrateLoader<'a> {\n         let deps = crate_root.crate_deps.decode(metadata);\n         let map: FxHashMap<_, _> = deps.enumerate().map(|(crate_num, dep)| {\n             debug!(\"resolving dep crate {} hash: `{}`\", dep.name, dep.hash);\n-            let dep_name = &dep.name.as_str();\n             let dep_kind = match dep_kind {\n                 DepKind::MacrosOnly => DepKind::MacrosOnly,\n                 _ => dep.kind,\n             };\n             let (local_cnum, ..) = self.resolve_crate(\n-                root, dep_name, dep_name, Some(&dep.hash), span, PathKind::Dependency, dep_kind,\n+                root, dep.name, dep.name, Some(&dep.hash), span, PathKind::Dependency, dep_kind,\n             );\n             (CrateNum::new(crate_num + 1), local_cnum)\n         }).collect();\n@@ -482,13 +481,11 @@ impl<'a> CrateLoader<'a> {\n         let target_triple = &self.sess.opts.target_triple[..];\n         let is_cross = target_triple != config::host_triple();\n         let mut target_only = false;\n-        let ident = info.ident.clone();\n-        let name = info.name.clone();\n         let mut locate_ctxt = locator::Context {\n             sess: self.sess,\n             span: span,\n-            ident: &ident[..],\n-            crate_name: &name[..],\n+            ident: info.ident,\n+            crate_name: info.name,\n             hash: None,\n             filesearch: self.sess.host_filesearch(PathKind::Crate),\n             target: &self.sess.host,\n@@ -604,8 +601,8 @@ impl<'a> CrateLoader<'a> {\n     pub fn find_plugin_registrar(&mut self, span: Span, name: &str)\n                                  -> Option<(PathBuf, Svh, DefIndex)> {\n         let ekrate = self.read_extension_crate(span, &ExternCrateInfo {\n-             name: name.to_string(),\n-             ident: name.to_string(),\n+             name: Symbol::intern(name),\n+             ident: Symbol::intern(name),\n              id: ast::DUMMY_NODE_ID,\n              dep_kind: DepKind::MacrosOnly,\n         });\n@@ -642,7 +639,7 @@ impl<'a> CrateLoader<'a> {\n         let libs = self.cstore.get_used_libraries();\n         for (foreign_lib, list) in self.foreign_item_map.iter() {\n             let is_static = libs.borrow().iter().any(|lib| {\n-                *foreign_lib == lib.name && lib.kind == cstore::NativeStatic\n+                lib.name == &**foreign_lib && lib.kind == cstore::NativeStatic\n             });\n             if is_static {\n                 for id in list {\n@@ -705,8 +702,8 @@ impl<'a> CrateLoader<'a> {\n         // in terms of everyone has a compatible panic runtime format, that's\n         // performed later as part of the `dependency_format` module.\n         let name = match desired_strategy {\n-            PanicStrategy::Unwind => \"panic_unwind\",\n-            PanicStrategy::Abort => \"panic_abort\",\n+            PanicStrategy::Unwind => Symbol::intern(\"panic_unwind\"),\n+            PanicStrategy::Abort => Symbol::intern(\"panic_abort\"),\n         };\n         info!(\"panic runtime not found -- loading {}\", name);\n \n@@ -788,9 +785,9 @@ impl<'a> CrateLoader<'a> {\n         // * Staticlibs and Rust dylibs use system malloc\n         // * Rust dylibs used as dependencies to rust use jemalloc\n         let name = if need_lib_alloc && !self.sess.opts.cg.prefer_dynamic {\n-            &self.sess.target.target.options.lib_allocation_crate\n+            Symbol::intern(&self.sess.target.target.options.lib_allocation_crate)\n         } else {\n-            &self.sess.target.target.options.exe_allocation_crate\n+            Symbol::intern(&self.sess.target.target.options.exe_allocation_crate)\n         };\n         let dep_kind = DepKind::Implicit;\n         let (cnum, data) =\n@@ -852,8 +849,8 @@ impl<'a> CrateLoader<'a> {\n impl<'a> CrateLoader<'a> {\n     pub fn preprocess(&mut self, krate: &ast::Crate) {\n         for attr in krate.attrs.iter().filter(|m| m.name() == \"link_args\") {\n-            if let Some(ref linkarg) = attr.value_str() {\n-                self.cstore.add_used_link_args(&linkarg);\n+            if let Some(linkarg) = attr.value_str() {\n+                self.cstore.add_used_link_args(&linkarg.as_str());\n             }\n         }\n     }\n@@ -866,7 +863,7 @@ impl<'a> CrateLoader<'a> {\n         // First, add all of the custom #[link_args] attributes\n         for m in i.attrs.iter().filter(|a| a.check_name(\"link_args\")) {\n             if let Some(linkarg) = m.value_str() {\n-                self.cstore.add_used_link_args(&linkarg);\n+                self.cstore.add_used_link_args(&linkarg.as_str());\n             }\n         }\n \n@@ -878,7 +875,7 @@ impl<'a> CrateLoader<'a> {\n             };\n             let kind = items.iter().find(|k| {\n                 k.check_name(\"kind\")\n-            }).and_then(|a| a.value_str());\n+            }).and_then(|a| a.value_str()).map(Symbol::as_str);\n             let kind = match kind.as_ref().map(|s| &s[..]) {\n                 Some(\"static\") => cstore::NativeStatic,\n                 Some(\"dylib\") => cstore::NativeUnknown,\n@@ -900,7 +897,7 @@ impl<'a> CrateLoader<'a> {\n                     struct_span_err!(self.sess, m.span, E0459,\n                                      \"#[link(...)] specified without `name = \\\"foo\\\"`\")\n                         .span_label(m.span, &format!(\"missing `name` argument\")).emit();\n-                    InternedString::new(\"foo\")\n+                    Symbol::intern(\"foo\")\n                 }\n             };\n             let cfg = items.iter().find(|k| {\n@@ -910,7 +907,7 @@ impl<'a> CrateLoader<'a> {\n                 list[0].meta_item().unwrap().clone()\n             });\n             let lib = NativeLibrary {\n-                name: n.to_string(),\n+                name: n,\n                 kind: kind,\n                 cfg: cfg,\n             };\n@@ -941,7 +938,7 @@ impl<'a> middle::cstore::CrateLoader for CrateLoader<'a> {\n \n         for &(ref name, kind) in &self.sess.opts.libs {\n             let lib = NativeLibrary {\n-                name: name.clone(),\n+                name: Symbol::intern(name),\n                 kind: kind,\n                 cfg: None,\n             };\n@@ -959,7 +956,7 @@ impl<'a> middle::cstore::CrateLoader for CrateLoader<'a> {\n \n         let info = self.extract_crate_info(item).unwrap();\n         let (cnum, ..) = self.resolve_crate(\n-            &None, &info.ident, &info.name, None, item.span, PathKind::Crate, info.dep_kind,\n+            &None, info.ident, info.name, None, item.span, PathKind::Crate, info.dep_kind,\n         );\n \n         let def_id = definitions.opt_local_def_id(item.id).unwrap();"}, {"sha": "ce47b936ddc0ebc17db0994fea3e5ff43e8e71e5", "filename": "src/librustc_metadata/cstore.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibrustc_metadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibrustc_metadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore.rs?ref=e85a0d70b86491752eb501f73b9d2025c5991e8e", "patch": "@@ -29,6 +29,7 @@ use std::path::PathBuf;\n use flate::Bytes;\n use syntax::{ast, attr};\n use syntax::ext::base::SyntaxExtension;\n+use syntax::symbol::Symbol;\n use syntax_pos;\n \n pub use rustc::middle::cstore::{NativeLibrary, LinkagePreference};\n@@ -58,7 +59,7 @@ pub struct ImportedFileMap {\n }\n \n pub struct CrateMetadata {\n-    pub name: String,\n+    pub name: Symbol,\n \n     /// Information about the extern crate that caused this crate to\n     /// be loaded. If this is `None`, then the crate was injected\n@@ -213,7 +214,7 @@ impl CStore {\n     }\n \n     pub fn add_used_library(&self, lib: NativeLibrary) {\n-        assert!(!lib.name.is_empty());\n+        assert!(!lib.name.as_str().is_empty());\n         self.used_libraries.borrow_mut().push(lib);\n     }\n \n@@ -249,14 +250,14 @@ impl CStore {\n }\n \n impl CrateMetadata {\n-    pub fn name(&self) -> &str {\n-        &self.root.name\n+    pub fn name(&self) -> Symbol {\n+        self.root.name\n     }\n     pub fn hash(&self) -> Svh {\n         self.root.hash\n     }\n-    pub fn disambiguator(&self) -> &str {\n-        &self.root.disambiguator\n+    pub fn disambiguator(&self) -> Symbol {\n+        self.root.disambiguator\n     }\n \n     pub fn is_staged_api(&self) -> bool {"}, {"sha": "407166203de87b4f12dc263e39a439f21cc6ce5e", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=e85a0d70b86491752eb501f73b9d2025c5991e8e", "patch": "@@ -32,7 +32,7 @@ use std::path::PathBuf;\n use syntax::ast;\n use syntax::attr;\n use syntax::parse::new_parser_from_source_str;\n-use syntax::symbol::{InternedString, intern_and_get_ident};\n+use syntax::symbol::Symbol;\n use syntax_pos::mk_sp;\n use rustc::hir::svh::Svh;\n use rustc_back::target::Target;\n@@ -263,14 +263,14 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         self.get_crate_data(cnum).panic_strategy()\n     }\n \n-    fn crate_name(&self, cnum: CrateNum) -> InternedString\n+    fn crate_name(&self, cnum: CrateNum) -> Symbol\n     {\n-        intern_and_get_ident(&self.get_crate_data(cnum).name[..])\n+        self.get_crate_data(cnum).name\n     }\n \n-    fn original_crate_name(&self, cnum: CrateNum) -> InternedString\n+    fn original_crate_name(&self, cnum: CrateNum) -> Symbol\n     {\n-        intern_and_get_ident(&self.get_crate_data(cnum).name())\n+        self.get_crate_data(cnum).name()\n     }\n \n     fn extern_crate(&self, cnum: CrateNum) -> Option<ExternCrate>\n@@ -283,9 +283,9 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         self.get_crate_hash(cnum)\n     }\n \n-    fn crate_disambiguator(&self, cnum: CrateNum) -> InternedString\n+    fn crate_disambiguator(&self, cnum: CrateNum) -> Symbol\n     {\n-        intern_and_get_ident(&self.get_crate_data(cnum).disambiguator())\n+        self.get_crate_data(cnum).disambiguator()\n     }\n \n     fn plugin_registrar_fn(&self, cnum: CrateNum) -> Option<DefId>"}, {"sha": "2f4b0d5c87b0dc6fb1df552a8df4200897d804d6", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=e85a0d70b86491752eb501f73b9d2025c5991e8e", "patch": "@@ -1119,7 +1119,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         let deps = get_ordered_deps(self.cstore);\n         self.lazy_seq(deps.iter().map(|&(_, ref dep)| {\n             CrateDep {\n-                name: Symbol::intern(dep.name()),\n+                name: dep.name(),\n                 hash: dep.hash(),\n                 kind: dep.dep_kind.get(),\n             }\n@@ -1279,10 +1279,10 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         let is_proc_macro = tcx.sess.crate_types.borrow().contains(&CrateTypeProcMacro);\n         let root = self.lazy(&CrateRoot {\n             rustc_version: rustc_version(),\n-            name: link_meta.crate_name.clone(),\n+            name: link_meta.crate_name,\n             triple: tcx.sess.opts.target_triple.clone(),\n             hash: link_meta.crate_hash,\n-            disambiguator: tcx.sess.local_crate_disambiguator().to_string(),\n+            disambiguator: tcx.sess.local_crate_disambiguator(),\n             panic_strategy: tcx.sess.panic_strategy(),\n             plugin_registrar_fn: tcx.sess\n                 .plugin_registrar_fn"}, {"sha": "f5196f7ea8428470783899cb9a514bb8580cb6f1", "filename": "src/librustc_metadata/locator.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibrustc_metadata%2Flocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibrustc_metadata%2Flocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flocator.rs?ref=e85a0d70b86491752eb501f73b9d2025c5991e8e", "patch": "@@ -227,6 +227,7 @@ use rustc_llvm as llvm;\n use rustc_llvm::{False, ObjectFile, mk_section_iter};\n use rustc_llvm::archive_ro::ArchiveRO;\n use errors::DiagnosticBuilder;\n+use syntax::symbol::Symbol;\n use syntax_pos::Span;\n use rustc_back::target::Target;\n \n@@ -249,8 +250,8 @@ pub struct CrateMismatch {\n pub struct Context<'a> {\n     pub sess: &'a Session,\n     pub span: Span,\n-    pub ident: &'a str,\n-    pub crate_name: &'a str,\n+    pub ident: Symbol,\n+    pub crate_name: Symbol,\n     pub hash: Option<&'a Svh>,\n     // points to either self.sess.target.target or self.sess.host, must match triple\n     pub target: &'a Target,\n@@ -422,7 +423,7 @@ impl<'a> Context<'a> {\n         // must be loaded via -L plus some filtering.\n         if self.hash.is_none() {\n             self.should_match_name = false;\n-            if let Some(s) = self.sess.opts.externs.get(self.crate_name) {\n+            if let Some(s) = self.sess.opts.externs.get(&self.crate_name.as_str()) {\n                 return self.find_commandline_library(s.iter());\n             }\n             self.should_match_name = true;\n@@ -533,7 +534,7 @@ impl<'a> Context<'a> {\n                     if let Some((ref p, _)) = lib.rlib {\n                         err.note(&format!(\"path: {}\", p.display()));\n                     }\n-                    note_crate_name(&mut err, &lib.metadata.get_root().name);\n+                    note_crate_name(&mut err, &lib.metadata.get_root().name.as_str());\n                 }\n                 err.emit();\n                 None"}, {"sha": "e11719dc40f2a83aa1ccfdb2047ec46fbabf0397", "filename": "src/librustc_metadata/schema.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibrustc_metadata%2Fschema.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibrustc_metadata%2Fschema.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fschema.rs?ref=e85a0d70b86491752eb501f73b9d2025c5991e8e", "patch": "@@ -22,6 +22,7 @@ use rustc_back::PanicStrategy;\n \n use rustc_serialize as serialize;\n use syntax::{ast, attr};\n+use syntax::symbol::Symbol;\n use syntax_pos::{self, Span};\n \n use std::marker::PhantomData;\n@@ -163,10 +164,10 @@ pub enum LazyState {\n #[derive(RustcEncodable, RustcDecodable)]\n pub struct CrateRoot {\n     pub rustc_version: String,\n-    pub name: String,\n+    pub name: Symbol,\n     pub triple: String,\n     pub hash: hir::svh::Svh,\n-    pub disambiguator: String,\n+    pub disambiguator: Symbol,\n     pub panic_strategy: PanicStrategy,\n     pub plugin_registrar_fn: Option<DefIndex>,\n     pub macro_derive_registrar: Option<DefIndex>,"}, {"sha": "b981dfef8908ebf69714096191561a5a1ebae60e", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=e85a0d70b86491752eb501f73b9d2025c5991e8e", "patch": "@@ -57,7 +57,7 @@ use syntax::ext::hygiene::{Mark, SyntaxContext};\n use syntax::ast::{self, FloatTy};\n use syntax::ast::{CRATE_NODE_ID, Name, NodeId, Ident, SpannedIdent, IntTy, UintTy};\n use syntax::ext::base::SyntaxExtension;\n-use syntax::symbol::{Symbol, InternedString, keywords};\n+use syntax::symbol::{Symbol, keywords};\n use syntax::util::lev_distance::find_best_match_for_name;\n \n use syntax::visit::{self, FnKind, Visitor};\n@@ -90,7 +90,7 @@ mod resolve_imports;\n \n enum SuggestionType {\n     Macro(String),\n-    Function(InternedString),\n+    Function(Symbol),\n     NotFound,\n }\n \n@@ -2891,7 +2891,7 @@ impl<'a> Resolver<'a> {\n                     .flat_map(|rib| rib.bindings.keys().map(|ident| &ident.name));\n \n         if let Some(found) = find_best_match_for_name(names, name, None) {\n-            if name != found {\n+            if found != name {\n                 return SuggestionType::Function(found);\n             }\n         } SuggestionType::NotFound"}, {"sha": "bd5da588a864d2228f91eccabfc43e4000b9d2aa", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=e85a0d70b86491752eb501f73b9d2025c5991e8e", "patch": "@@ -120,7 +120,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                 }\n             };\n             result.push(CrateData {\n-                name: (&self.tcx.sess.cstore.crate_name(n)[..]).to_owned(),\n+                name: self.tcx.sess.cstore.crate_name(n).to_string(),\n                 number: n.as_u32(),\n                 span: span,\n             });\n@@ -734,11 +734,11 @@ fn docs_for_attrs(attrs: &[Attribute]) -> String {\n \n     for attr in attrs {\n         if attr.name() == doc {\n-            if let Some(ref val) = attr.value_str() {\n+            if let Some(val) = attr.value_str() {\n                 if attr.is_sugared_doc {\n-                    result.push_str(&strip_doc_comment_decoration(val));\n+                    result.push_str(&strip_doc_comment_decoration(&val.as_str()));\n                 } else {\n-                    result.push_str(val);\n+                    result.push_str(&val.as_str());\n                 }\n                 result.push('\\n');\n             }"}, {"sha": "665e12cbe87955e624cfeb2ef7e5b03e297718db", "filename": "src/librustc_trans/asm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibrustc_trans%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibrustc_trans%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fasm.rs?ref=e85a0d70b86491752eb501f73b9d2025c5991e8e", "patch": "@@ -88,7 +88,7 @@ pub fn trans_inline_asm<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         AsmDialect::Intel => llvm::AsmDialect::Intel,\n     };\n \n-    let asm = CString::new(ia.asm.as_bytes()).unwrap();\n+    let asm = CString::new(ia.asm.as_str().as_bytes()).unwrap();\n     let constraint_cstr = CString::new(all_constraints).unwrap();\n     let r = InlineAsmCall(bcx,\n                           asm.as_ptr(),"}, {"sha": "898e65ce391e609dd295dc29971a85cb09075f42", "filename": "src/librustc_trans/assert_module_sources.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibrustc_trans%2Fassert_module_sources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibrustc_trans%2Fassert_module_sources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fassert_module_sources.rs?ref=e85a0d70b86491752eb501f73b9d2025c5991e8e", "patch": "@@ -29,7 +29,6 @@\n \n use rustc::ty::TyCtxt;\n use syntax::ast;\n-use syntax::symbol::Symbol;\n \n use {ModuleSource, ModuleTranslation};\n \n@@ -117,7 +116,7 @@ impl<'a, 'tcx> AssertModuleSource<'a, 'tcx> {\n         for item in attr.meta_item_list().unwrap_or(&[]) {\n             if item.check_name(name) {\n                 if let Some(value) = item.value_str() {\n-                    return Symbol::intern(&value);\n+                    return value;\n                 } else {\n                     self.tcx.sess.span_fatal(\n                         item.span,"}, {"sha": "d0339775a78a1e7f72c09b60a67f100038781aca", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=e85a0d70b86491752eb501f73b9d2025c5991e8e", "patch": "@@ -44,6 +44,7 @@ use std::str;\n use flate;\n use syntax::ast;\n use syntax::attr;\n+use syntax::symbol::Symbol;\n use syntax_pos::Span;\n \n // RLIB LLVM-BYTECODE OBJECT LAYOUT\n@@ -93,8 +94,8 @@ pub fn find_crate_name(sess: Option<&Session>,\n \n     if let Some(sess) = sess {\n         if let Some(ref s) = sess.opts.crate_name {\n-            if let Some((attr, ref name)) = attr_crate_name {\n-                if *s != &name[..] {\n+            if let Some((attr, name)) = attr_crate_name {\n+                if name != &**s {\n                     let msg = format!(\"--crate-name and #[crate_name] are \\\n                                        required to match, but `{}` != `{}`\",\n                                       s, name);\n@@ -130,7 +131,7 @@ pub fn build_link_meta(incremental_hashes_map: &IncrementalHashesMap,\n                        name: &str)\n                        -> LinkMeta {\n     let r = LinkMeta {\n-        crate_name: name.to_owned(),\n+        crate_name: Symbol::intern(name),\n         crate_hash: Svh::new(incremental_hashes_map[&DepNode::Krate].to_smaller_hash()),\n     };\n     info!(\"{:?}\", r);\n@@ -429,7 +430,7 @@ fn link_rlib<'a>(sess: &'a Session,\n             NativeLibraryKind::NativeFramework |\n             NativeLibraryKind::NativeUnknown => continue,\n         }\n-        ab.add_native_library(&lib.name);\n+        ab.add_native_library(&lib.name.as_str());\n     }\n \n     // After adding all files to the archive, we need to update the\n@@ -615,7 +616,7 @@ fn link_staticlib(sess: &Session, objects: &[PathBuf], out_filename: &Path,\n         let skip_object_files = native_libs.iter().any(|lib| {\n             lib.kind == NativeLibraryKind::NativeStatic && !relevant_lib(sess, lib)\n         });\n-        ab.add_rlib(path, &name, sess.lto(), skip_object_files).unwrap();\n+        ab.add_rlib(path, &name.as_str(), sess.lto(), skip_object_files).unwrap();\n \n         all_native_libs.extend(sess.cstore.native_libraries(cnum));\n     });\n@@ -934,15 +935,15 @@ fn add_local_native_libraries(cmd: &mut Linker, sess: &Session) {\n         // don't otherwise explicitly reference them. This can occur for\n         // libraries which are just providing bindings, libraries with generic\n         // functions, etc.\n-        cmd.link_whole_staticlib(&l.name, &search_path);\n+        cmd.link_whole_staticlib(&l.name.as_str(), &search_path);\n     }\n \n     cmd.hint_dynamic();\n \n     for lib in others {\n         match lib.kind {\n-            NativeLibraryKind::NativeUnknown => cmd.link_dylib(&lib.name),\n-            NativeLibraryKind::NativeFramework => cmd.link_framework(&lib.name),\n+            NativeLibraryKind::NativeUnknown => cmd.link_dylib(&lib.name.as_str()),\n+            NativeLibraryKind::NativeFramework => cmd.link_framework(&lib.name.as_str()),\n             NativeLibraryKind::NativeStatic => bug!(),\n         }\n     }\n@@ -1185,8 +1186,8 @@ fn add_upstream_native_libraries(cmd: &mut Linker, sess: &Session) {\n                 continue\n             }\n             match lib.kind {\n-                NativeLibraryKind::NativeUnknown => cmd.link_dylib(&lib.name),\n-                NativeLibraryKind::NativeFramework => cmd.link_framework(&lib.name),\n+                NativeLibraryKind::NativeUnknown => cmd.link_dylib(&lib.name.as_str()),\n+                NativeLibraryKind::NativeFramework => cmd.link_framework(&lib.name.as_str()),\n \n                 // ignore statically included native libraries here as we've\n                 // already included them when we included the rust library"}, {"sha": "ff40cfda5ff7cb7a865622a3f8c6c69431e068c9", "filename": "src/librustc_trans/back/symbol_names.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fsymbol_names.rs?ref=e85a0d70b86491752eb501f73b9d2025c5991e8e", "patch": "@@ -113,7 +113,7 @@ use rustc::hir::map::definitions::{DefPath, DefPathData};\n use rustc::util::common::record_time;\n \n use syntax::attr;\n-use syntax::symbol::{Symbol, InternedString, intern_and_get_ident};\n+use syntax::symbol::{Symbol, InternedString};\n \n fn get_symbol_hash<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n \n@@ -288,7 +288,7 @@ pub fn exported_name_from_type_and_prefix<'a, 'tcx>(scx: &SharedCrateContext<'a,\n         krate: LOCAL_CRATE,\n     };\n     let hash = get_symbol_hash(scx, &empty_def_path, t, None);\n-    let path = [intern_and_get_ident(prefix)];\n+    let path = [Symbol::intern(prefix).as_str()];\n     mangle(path.iter().cloned(), &hash)\n }\n "}, {"sha": "78a676d30337c1e113c440ffc0ad6d1a8cdb8114", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=e85a0d70b86491752eb501f73b9d2025c5991e8e", "patch": "@@ -1128,11 +1128,11 @@ pub fn set_link_section(ccx: &CrateContext,\n                         llval: ValueRef,\n                         attrs: &[ast::Attribute]) {\n     if let Some(sect) = attr::first_attr_value_str_by_name(attrs, \"link_section\") {\n-        if contains_null(&sect) {\n+        if contains_null(&sect.as_str()) {\n             ccx.sess().fatal(&format!(\"Illegal null byte in link_section value: `{}`\", &sect));\n         }\n         unsafe {\n-            let buf = CString::new(sect.as_bytes()).unwrap();\n+            let buf = CString::new(sect.as_str().as_bytes()).unwrap();\n             llvm::LLVMSetSection(llval, buf.as_ptr());\n         }\n     }"}, {"sha": "4186721c122acdd839829c26b40c153f652e950b", "filename": "src/librustc_trans/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibrustc_trans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibrustc_trans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fconsts.rs?ref=e85a0d70b86491752eb501f73b9d2025c5991e8e", "patch": "@@ -123,7 +123,7 @@ pub fn get_static(ccx: &CrateContext, def_id: DefId) -> ValueRef {\n                     // extern \"C\" fn() from being non-null, so we can't just declare a\n                     // static and call it a day. Some linkages (like weak) will make it such\n                     // that the static actually has a null value.\n-                    let linkage = match base::llvm_linkage_by_name(&name) {\n+                    let linkage = match base::llvm_linkage_by_name(&name.as_str()) {\n                         Some(linkage) => linkage,\n                         None => {\n                             ccx.sess().span_fatal(span, \"invalid linkage specified\");"}, {"sha": "6caab4340e731110266878825cfdcf5fd7d002dc", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=e85a0d70b86491752eb501f73b9d2025c5991e8e", "patch": "@@ -808,7 +808,7 @@ pub fn compile_unit_metadata(scc: &SharedCrateContext,\n     };\n \n     fn fallback_path(scc: &SharedCrateContext) -> CString {\n-        CString::new(scc.link_meta().crate_name.clone()).unwrap()\n+        CString::new(scc.link_meta().crate_name.to_string()).unwrap()\n     }\n }\n "}, {"sha": "a0477c9fc1eee2ea93c9759edad86b4d0750e341", "filename": "src/librustc_trans/debuginfo/namespace.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibrustc_trans%2Fdebuginfo%2Fnamespace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibrustc_trans%2Fdebuginfo%2Fnamespace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fnamespace.rs?ref=e85a0d70b86491752eb501f73b9d2025c5991e8e", "patch": "@@ -35,7 +35,7 @@ pub fn mangled_name_of_item(ccx: &CrateContext, def_id: DefId, extra: &str) -> S\n         }\n \n         let name = match def_key.disambiguated_data.data {\n-            DefPathData::CrateRoot => ccx.tcx().crate_name(def_id.krate),\n+            DefPathData::CrateRoot => ccx.tcx().crate_name(def_id.krate).as_str(),\n             data => data.as_interned_str()\n         };\n \n@@ -64,7 +64,7 @@ pub fn item_namespace(ccx: &CrateContext, def_id: DefId) -> DIScope {\n     });\n \n     let namespace_name = match def_key.disambiguated_data.data {\n-        DefPathData::CrateRoot => ccx.tcx().crate_name(def_id.krate),\n+        DefPathData::CrateRoot => ccx.tcx().crate_name(def_id.krate).as_str(),\n         data => data.as_interned_str()\n     };\n "}, {"sha": "fce1ce561055507c42a5d15d04785122232c0090", "filename": "src/librustc_trans/debuginfo/type_names.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs?ref=e85a0d70b86491752eb501f73b9d2025c5991e8e", "patch": "@@ -156,7 +156,7 @@ pub fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                       qualified: bool,\n                       output: &mut String) {\n         if qualified {\n-            output.push_str(&cx.tcx().crate_name(def_id.krate));\n+            output.push_str(&cx.tcx().crate_name(def_id.krate).as_str());\n             for path_element in cx.tcx().def_path(def_id).data {\n                 output.push_str(\"::\");\n                 output.push_str(&path_element.data.as_interned_str());"}, {"sha": "caa88c91d2c4d6bb687c61666cc5d1ffe6512d9c", "filename": "src/librustc_trans/intrinsic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibrustc_trans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibrustc_trans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fintrinsic.rs?ref=e85a0d70b86491752eb501f73b9d2025c5991e8e", "patch": "@@ -30,7 +30,7 @@ use rustc::ty::{self, Ty};\n use Disr;\n use rustc::hir;\n use syntax::ast;\n-use syntax::symbol::intern_and_get_ident;\n+use syntax::symbol::Symbol;\n \n use rustc::session::Session;\n use syntax_pos::{Span, DUMMY_SP};\n@@ -208,7 +208,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         }\n         (_, \"type_name\") => {\n             let tp_ty = substs.type_at(0);\n-            let ty_name = intern_and_get_ident(&tp_ty.to_string());\n+            let ty_name = Symbol::intern(&tp_ty.to_string()).as_str();\n             C_str_slice(ccx, ty_name)\n         }\n         (_, \"type_id\") => {"}, {"sha": "c0000506d24551b07b12192854abcbdaf4b8c70f", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=e85a0d70b86491752eb501f73b9d2025c5991e8e", "patch": "@@ -30,7 +30,7 @@ use glue;\n use type_::Type;\n \n use rustc_data_structures::fx::FxHashMap;\n-use syntax::symbol::intern_and_get_ident;\n+use syntax::symbol::Symbol;\n \n use super::{MirContext, LocalRef};\n use super::analyze::CleanupKind;\n@@ -321,7 +321,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n \n                 // Get the location information.\n                 let loc = bcx.sess().codemap().lookup_char_pos(span.lo);\n-                let filename = intern_and_get_ident(&loc.file.name);\n+                let filename = Symbol::intern(&loc.file.name).as_str();\n                 let filename = C_str_slice(bcx.ccx(), filename);\n                 let line = C_u32(bcx.ccx(), loc.line as u32);\n \n@@ -351,7 +351,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                          const_err)\n                     }\n                     mir::AssertMessage::Math(ref err) => {\n-                        let msg_str = intern_and_get_ident(err.description());\n+                        let msg_str = Symbol::intern(err.description()).as_str();\n                         let msg_str = C_str_slice(bcx.ccx(), msg_str);\n                         let msg_file_line = C_struct(bcx.ccx(),\n                                                      &[msg_str, filename, line],"}, {"sha": "e90140ab2cabf77a126672edfaddd6da358ce1d7", "filename": "src/librustc_trans/partitioning.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibrustc_trans%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibrustc_trans%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fpartitioning.rs?ref=e85a0d70b86491752eb501f73b9d2025c5991e8e", "patch": "@@ -132,7 +132,7 @@ use std::sync::Arc;\n use std::collections::hash_map::DefaultHasher;\n use symbol_map::SymbolMap;\n use syntax::ast::NodeId;\n-use syntax::symbol::{InternedString, intern_and_get_ident};\n+use syntax::symbol::{Symbol, InternedString};\n use trans_item::TransItem;\n use util::nodemap::{FxHashMap, FxHashSet};\n \n@@ -272,7 +272,7 @@ pub fn partition<'a, 'tcx, I>(scx: &SharedCrateContext<'a, 'tcx>,\n     // If the partitioning should produce a fixed count of codegen units, merge\n     // until that count is reached.\n     if let PartitioningStrategy::FixedUnitCount(count) = strategy {\n-        merge_codegen_units(&mut initial_partitioning, count, &tcx.crate_name[..]);\n+        merge_codegen_units(&mut initial_partitioning, count, &tcx.crate_name.as_str());\n \n         debug_dump(scx, \"POST MERGING:\", initial_partitioning.codegen_units.iter());\n     }\n@@ -523,7 +523,7 @@ fn compute_codegen_unit_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let mut mod_path = String::with_capacity(64);\n \n     let def_path = tcx.def_path(def_id);\n-    mod_path.push_str(&tcx.crate_name(def_path.krate));\n+    mod_path.push_str(&tcx.crate_name(def_path.krate).as_str());\n \n     for part in tcx.def_path(def_id)\n                    .data\n@@ -542,14 +542,11 @@ fn compute_codegen_unit_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         mod_path.push_str(\".volatile\");\n     }\n \n-    return intern_and_get_ident(&mod_path[..]);\n+    return Symbol::intern(&mod_path[..]).as_str();\n }\n \n fn numbered_codegen_unit_name(crate_name: &str, index: usize) -> InternedString {\n-    intern_and_get_ident(&format!(\"{}{}{}\",\n-        crate_name,\n-        NUMBERED_CODEGEN_UNIT_MARKER,\n-        index)[..])\n+    Symbol::intern(&format!(\"{}{}{}\", crate_name, NUMBERED_CODEGEN_UNIT_MARKER, index)).as_str()\n }\n \n fn debug_dump<'a, 'b, 'tcx, I>(scx: &SharedCrateContext<'a, 'tcx>,"}, {"sha": "f2d1e375793b3bf08754e9ef77143764cfb1418e", "filename": "src/librustc_trans/trans_item.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibrustc_trans%2Ftrans_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibrustc_trans%2Ftrans_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans_item.rs?ref=e85a0d70b86491752eb501f73b9d2025c5991e8e", "patch": "@@ -285,7 +285,7 @@ impl<'a, 'tcx> TransItem<'tcx> {\n \n         let attributes = tcx.get_attrs(def_id);\n         if let Some(name) = attr::first_attr_value_str_by_name(&attributes, \"linkage\") {\n-            if let Some(linkage) = base::llvm_linkage_by_name(&name) {\n+            if let Some(linkage) = base::llvm_linkage_by_name(&name.as_str()) {\n                 Some(linkage)\n             } else {\n                 let span = tcx.map.span_if_local(def_id);\n@@ -531,7 +531,7 @@ impl<'a, 'tcx> DefPathBasedNames<'a, 'tcx> {\n \n         // some_crate::\n         if !(self.omit_local_crate_name && def_id.is_local()) {\n-            output.push_str(&self.tcx.crate_name(def_path.krate));\n+            output.push_str(&self.tcx.crate_name(def_path.krate).as_str());\n             output.push_str(\"::\");\n         }\n "}, {"sha": "30015c242ba80bd633aaa2ed798c9ca10c8aea25", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=e85a0d70b86491752eb501f73b9d2025c5991e8e", "patch": "@@ -931,7 +931,8 @@ fn check_on_unimplemented<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     if let Some(ref attr) = item.attrs.iter().find(|a| {\n         a.check_name(\"rustc_on_unimplemented\")\n     }) {\n-        if let Some(ref istring) = attr.value_str() {\n+        if let Some(istring) = attr.value_str() {\n+            let istring = istring.as_str();\n             let parser = Parser::new(&istring);\n             let types = &generics.types;\n             for token in parser {\n@@ -3027,7 +3028,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     fn suggest_field_name(variant: ty::VariantDef<'tcx>,\n                           field: &Spanned<ast::Name>,\n                           skip : Vec<InternedString>)\n-                          -> Option<InternedString> {\n+                          -> Option<Symbol> {\n         let name = field.node.as_str();\n         let names = variant.fields.iter().filter_map(|field| {\n             // ignore already set fields and private fields from non-local crates"}, {"sha": "8a238a11281b741f93c0ef337224856e23c1bd83", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=e85a0d70b86491752eb501f73b9d2025c5991e8e", "patch": "@@ -23,7 +23,7 @@ use abi::Abi;\n use ext::hygiene::SyntaxContext;\n use print::pprust;\n use ptr::P;\n-use symbol::{Symbol, keywords, InternedString};\n+use symbol::{Symbol, keywords};\n use tokenstream::{TokenTree};\n \n use std::collections::HashSet;\n@@ -451,7 +451,7 @@ pub struct WhereEqPredicate {\n \n /// The set of MetaItems that define the compilation environment of the crate,\n /// used to drive conditional compilation\n-pub type CrateConfig = HashSet<(Name, Option<InternedString>)>;\n+pub type CrateConfig = HashSet<(Name, Option<Symbol>)>;\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct Crate {\n@@ -1098,7 +1098,7 @@ pub enum LitIntType {\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum LitKind {\n     /// A string literal (`\"foo\"`)\n-    Str(InternedString, StrStyle),\n+    Str(Symbol, StrStyle),\n     /// A byte string (`b\"foo\"`)\n     ByteStr(Rc<Vec<u8>>),\n     /// A byte char (`b'f'`)\n@@ -1108,9 +1108,9 @@ pub enum LitKind {\n     /// An integer literal (`1`)\n     Int(u64, LitIntType),\n     /// A float literal (`1f64` or `1E10f64`)\n-    Float(InternedString, FloatTy),\n+    Float(Symbol, FloatTy),\n     /// A float literal without a suffix (`1.0 or 1.0E10`)\n-    FloatUnsuffixed(InternedString),\n+    FloatUnsuffixed(Symbol),\n     /// A boolean literal\n     Bool(bool),\n }\n@@ -1442,7 +1442,7 @@ pub enum AsmDialect {\n /// E.g. `\"={eax}\"(result)` as in `asm!(\"mov eax, 2\" : \"={eax}\"(result) : : : \"intel\")``\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct InlineAsmOutput {\n-    pub constraint: InternedString,\n+    pub constraint: Symbol,\n     pub expr: P<Expr>,\n     pub is_rw: bool,\n     pub is_indirect: bool,\n@@ -1453,11 +1453,11 @@ pub struct InlineAsmOutput {\n /// E.g. `asm!(\"NOP\");`\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct InlineAsm {\n-    pub asm: InternedString,\n+    pub asm: Symbol,\n     pub asm_str_style: StrStyle,\n     pub outputs: Vec<InlineAsmOutput>,\n-    pub inputs: Vec<(InternedString, P<Expr>)>,\n-    pub clobbers: Vec<InternedString>,\n+    pub inputs: Vec<(Symbol, P<Expr>)>,\n+    pub clobbers: Vec<Symbol>,\n     pub volatile: bool,\n     pub alignstack: bool,\n     pub dialect: AsmDialect,"}, {"sha": "45c120e0b95ca44daa6fc7445707efd986e822f6", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 22, "deletions": 24, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=e85a0d70b86491752eb501f73b9d2025c5991e8e", "patch": "@@ -25,7 +25,7 @@ use feature_gate::{Features, GatedCfg};\n use parse::lexer::comments::{doc_comment_style, strip_doc_comment_decoration};\n use parse::ParseSess;\n use ptr::P;\n-use symbol::{self, Symbol, InternedString};\n+use symbol::Symbol;\n use util::ThinVec;\n \n use std::cell::{RefCell, Cell};\n@@ -140,7 +140,7 @@ impl NestedMetaItem {\n \n     /// Gets the string value if self is a MetaItem and the MetaItem is a\n     /// MetaItemKind::NameValue variant containing a string, otherwise None.\n-    pub fn value_str(&self) -> Option<InternedString> {\n+    pub fn value_str(&self) -> Option<Symbol> {\n         self.meta_item().and_then(|meta_item| meta_item.value_str())\n     }\n \n@@ -195,7 +195,7 @@ impl Attribute {\n \n     pub fn name(&self) -> Name { self.meta().name() }\n \n-    pub fn value_str(&self) -> Option<InternedString> {\n+    pub fn value_str(&self) -> Option<Symbol> {\n         self.meta().value_str()\n     }\n \n@@ -222,7 +222,7 @@ impl MetaItem {\n         self.name\n     }\n \n-    pub fn value_str(&self) -> Option<InternedString> {\n+    pub fn value_str(&self) -> Option<Symbol> {\n         match self.node {\n             MetaItemKind::NameValue(ref v) => {\n                 match v.node {\n@@ -279,8 +279,7 @@ impl Attribute {\n             let comment = self.value_str().unwrap();\n             let meta = mk_name_value_item_str(\n                 Symbol::intern(\"doc\"),\n-                symbol::intern_and_get_ident(&strip_doc_comment_decoration(\n-                        &comment)));\n+                Symbol::intern(&strip_doc_comment_decoration(&comment.as_str())));\n             if self.style == ast::AttrStyle::Outer {\n                 f(&mk_attr_outer(self.id, meta))\n             } else {\n@@ -294,7 +293,7 @@ impl Attribute {\n \n /* Constructors */\n \n-pub fn mk_name_value_item_str(name: Name, value: InternedString) -> MetaItem {\n+pub fn mk_name_value_item_str(name: Name, value: Symbol) -> MetaItem {\n     let value_lit = dummy_spanned(ast::LitKind::Str(value, ast::StrStyle::Cooked));\n     mk_spanned_name_value_item(DUMMY_SP, name, value_lit)\n }\n@@ -383,9 +382,9 @@ pub fn mk_doc_attr_outer(id: AttrId, item: MetaItem, is_sugared_doc: bool) -> At\n     }\n }\n \n-pub fn mk_sugared_doc_attr(id: AttrId, text: InternedString, lo: BytePos, hi: BytePos)\n+pub fn mk_sugared_doc_attr(id: AttrId, text: Symbol, lo: BytePos, hi: BytePos)\n                            -> Attribute {\n-    let style = doc_comment_style(&text);\n+    let style = doc_comment_style(&text.as_str());\n     let lit = spanned(lo, hi, ast::LitKind::Str(text, ast::StrStyle::Cooked));\n     Attribute {\n         id: id,\n@@ -416,14 +415,13 @@ pub fn contains_name(attrs: &[Attribute], name: &str) -> bool {\n     })\n }\n \n-pub fn first_attr_value_str_by_name(attrs: &[Attribute], name: &str)\n-                                 -> Option<InternedString> {\n+pub fn first_attr_value_str_by_name(attrs: &[Attribute], name: &str) -> Option<Symbol> {\n     attrs.iter()\n         .find(|at| at.check_name(name))\n         .and_then(|at| at.value_str())\n }\n \n-pub fn last_meta_item_value_str_by_name(items: &[MetaItem], name: &str) -> Option<InternedString> {\n+pub fn last_meta_item_value_str_by_name(items: &[MetaItem], name: &str) -> Option<Symbol> {\n     items.iter()\n          .rev()\n          .find(|mi| mi.check_name(name))\n@@ -432,12 +430,12 @@ pub fn last_meta_item_value_str_by_name(items: &[MetaItem], name: &str) -> Optio\n \n /* Higher-level applications */\n \n-pub fn find_crate_name(attrs: &[Attribute]) -> Option<InternedString> {\n+pub fn find_crate_name(attrs: &[Attribute]) -> Option<Symbol> {\n     first_attr_value_str_by_name(attrs, \"crate_name\")\n }\n \n /// Find the value of #[export_name=*] attribute and check its validity.\n-pub fn find_export_name_attr(diag: &Handler, attrs: &[Attribute]) -> Option<InternedString> {\n+pub fn find_export_name_attr(diag: &Handler, attrs: &[Attribute]) -> Option<Symbol> {\n     attrs.iter().fold(None, |ia,attr| {\n         if attr.check_name(\"export_name\") {\n             if let s@Some(_) = attr.value_str() {\n@@ -555,28 +553,28 @@ pub fn cfg_matches(cfg: &ast::MetaItem, sess: &ParseSess, features: Option<&Feat\n #[derive(RustcEncodable, RustcDecodable, Clone, Debug, PartialEq, Eq, Hash)]\n pub struct Stability {\n     pub level: StabilityLevel,\n-    pub feature: InternedString,\n+    pub feature: Symbol,\n     pub rustc_depr: Option<RustcDeprecation>,\n }\n \n /// The available stability levels.\n #[derive(RustcEncodable, RustcDecodable, PartialEq, PartialOrd, Clone, Debug, Eq, Hash)]\n pub enum StabilityLevel {\n     // Reason for the current stability level and the relevant rust-lang issue\n-    Unstable { reason: Option<InternedString>, issue: u32 },\n-    Stable { since: InternedString },\n+    Unstable { reason: Option<Symbol>, issue: u32 },\n+    Stable { since: Symbol },\n }\n \n #[derive(RustcEncodable, RustcDecodable, PartialEq, PartialOrd, Clone, Debug, Eq, Hash)]\n pub struct RustcDeprecation {\n-    pub since: InternedString,\n-    pub reason: InternedString,\n+    pub since: Symbol,\n+    pub reason: Symbol,\n }\n \n #[derive(RustcEncodable, RustcDecodable, PartialEq, PartialOrd, Clone, Debug, Eq, Hash)]\n pub struct Deprecation {\n-    pub since: Option<InternedString>,\n-    pub note: Option<InternedString>,\n+    pub since: Option<Symbol>,\n+    pub note: Option<Symbol>,\n }\n \n impl StabilityLevel {\n@@ -602,7 +600,7 @@ fn find_stability_generic<'a, I>(diagnostic: &Handler,\n         mark_used(attr);\n \n         if let Some(metas) = attr.meta_item_list() {\n-            let get = |meta: &MetaItem, item: &mut Option<InternedString>| {\n+            let get = |meta: &MetaItem, item: &mut Option<Symbol>| {\n                 if item.is_some() {\n                     handle_errors(diagnostic, meta.span, AttrError::MultipleItem(meta.name()));\n                     return false\n@@ -693,7 +691,7 @@ fn find_stability_generic<'a, I>(diagnostic: &Handler,\n                                 level: Unstable {\n                                     reason: reason,\n                                     issue: {\n-                                        if let Ok(issue) = issue.parse() {\n+                                        if let Ok(issue) = issue.as_str().parse() {\n                                             issue\n                                         } else {\n                                             span_err!(diagnostic, attr.span(), E0545,\n@@ -804,7 +802,7 @@ fn find_deprecation_generic<'a, I>(diagnostic: &Handler,\n         }\n \n         depr = if let Some(metas) = attr.meta_item_list() {\n-            let get = |meta: &MetaItem, item: &mut Option<InternedString>| {\n+            let get = |meta: &MetaItem, item: &mut Option<Symbol>| {\n                 if item.is_some() {\n                     handle_errors(diagnostic, meta.span, AttrError::MultipleItem(meta.name()));\n                     return false"}, {"sha": "fe5cb87ad59b5c89370490754c45576b6bcad900", "filename": "src/libsyntax/diagnostics/plugin.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs?ref=e85a0d70b86491752eb501f73b9d2025c5991e8e", "patch": "@@ -195,11 +195,11 @@ pub fn expand_build_diagnostic_array<'cx>(ecx: &'cx mut ExtCtxt,\n     let (count, expr) =\n         with_registered_diagnostics(|diagnostics| {\n             let descriptions: Vec<P<ast::Expr>> =\n-                diagnostics.iter().filter_map(|(code, info)| {\n+                diagnostics.iter().filter_map(|(&code, info)| {\n                     info.description.map(|description| {\n                         ecx.expr_tuple(span, vec![\n-                            ecx.expr_str(span, code.as_str()),\n-                            ecx.expr_str(span, description.as_str())\n+                            ecx.expr_str(span, code),\n+                            ecx.expr_str(span, description)\n                         ])\n                     })\n                 }).collect();"}, {"sha": "1dda5e3ba065353206b2415b6b83d9a75936e602", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=e85a0d70b86491752eb501f73b9d2025c5991e8e", "patch": "@@ -21,7 +21,7 @@ use fold::{self, Folder};\n use parse::{self, parser};\n use parse::token;\n use ptr::P;\n-use symbol::{Symbol, InternedString};\n+use symbol::Symbol;\n use util::small_vector::SmallVector;\n \n use std::path::PathBuf;\n@@ -754,7 +754,7 @@ impl<'a> ExtCtxt<'a> {\n /// emitting `err_msg` if `expr` is not a string literal. This does not stop\n /// compilation on error, merely emits a non-fatal error and returns None.\n pub fn expr_to_spanned_string(cx: &mut ExtCtxt, expr: P<ast::Expr>, err_msg: &str)\n-                              -> Option<Spanned<(InternedString, ast::StrStyle)>> {\n+                              -> Option<Spanned<(Symbol, ast::StrStyle)>> {\n     // Update `expr.span`'s expn_id now in case expr is an `include!` macro invocation.\n     let expr = expr.map(|mut expr| {\n         expr.span.expn_id = cx.backtrace();\n@@ -765,7 +765,7 @@ pub fn expr_to_spanned_string(cx: &mut ExtCtxt, expr: P<ast::Expr>, err_msg: &st\n     let expr = cx.expander().fold_expr(expr);\n     match expr.node {\n         ast::ExprKind::Lit(ref l) => match l.node {\n-            ast::LitKind::Str(ref s, style) => return Some(respan(expr.span, (s.clone(), style))),\n+            ast::LitKind::Str(s, style) => return Some(respan(expr.span, (s, style))),\n             _ => cx.span_err(l.span, err_msg)\n         },\n         _ => cx.span_err(expr.span, err_msg)\n@@ -774,7 +774,7 @@ pub fn expr_to_spanned_string(cx: &mut ExtCtxt, expr: P<ast::Expr>, err_msg: &st\n }\n \n pub fn expr_to_string(cx: &mut ExtCtxt, expr: P<ast::Expr>, err_msg: &str)\n-                      -> Option<(InternedString, ast::StrStyle)> {\n+                      -> Option<(Symbol, ast::StrStyle)> {\n     expr_to_spanned_string(cx, expr, err_msg).map(|s| s.node)\n }\n "}, {"sha": "324afc20051d4461d3e29d8c58ad34ae812d6e5d", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=e85a0d70b86491752eb501f73b9d2025c5991e8e", "patch": "@@ -15,7 +15,7 @@ use syntax_pos::{Span, DUMMY_SP, Pos};\n use codemap::{dummy_spanned, respan, Spanned};\n use ext::base::ExtCtxt;\n use ptr::P;\n-use symbol::{intern_and_get_ident, keywords, InternedString};\n+use symbol::{Symbol, keywords};\n \n // Transitional reexports so qquote can find the paths it is looking for\n mod syntax {\n@@ -149,7 +149,7 @@ pub trait AstBuilder {\n     fn expr_vec(&self, sp: Span, exprs: Vec<P<ast::Expr>>) -> P<ast::Expr>;\n     fn expr_vec_ng(&self, sp: Span) -> P<ast::Expr>;\n     fn expr_vec_slice(&self, sp: Span, exprs: Vec<P<ast::Expr>>) -> P<ast::Expr>;\n-    fn expr_str(&self, sp: Span, s: InternedString) -> P<ast::Expr>;\n+    fn expr_str(&self, sp: Span, s: Symbol) -> P<ast::Expr>;\n \n     fn expr_some(&self, sp: Span, expr: P<ast::Expr>) -> P<ast::Expr>;\n     fn expr_none(&self, sp: Span) -> P<ast::Expr>;\n@@ -158,7 +158,7 @@ pub trait AstBuilder {\n \n     fn expr_tuple(&self, sp: Span, exprs: Vec<P<ast::Expr>>) -> P<ast::Expr>;\n \n-    fn expr_fail(&self, span: Span, msg: InternedString) -> P<ast::Expr>;\n+    fn expr_fail(&self, span: Span, msg: Symbol) -> P<ast::Expr>;\n     fn expr_unreachable(&self, span: Span) -> P<ast::Expr>;\n \n     fn expr_ok(&self, span: Span, expr: P<ast::Expr>) -> P<ast::Expr>;\n@@ -755,7 +755,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     fn expr_vec_slice(&self, sp: Span, exprs: Vec<P<ast::Expr>>) -> P<ast::Expr> {\n         self.expr_addr_of(sp, self.expr_vec(sp, exprs))\n     }\n-    fn expr_str(&self, sp: Span, s: InternedString) -> P<ast::Expr> {\n+    fn expr_str(&self, sp: Span, s: Symbol) -> P<ast::Expr> {\n         self.expr_lit(sp, ast::LitKind::Str(s, ast::StrStyle::Cooked))\n     }\n \n@@ -785,9 +785,9 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         self.expr(sp, ast::ExprKind::Tup(exprs))\n     }\n \n-    fn expr_fail(&self, span: Span, msg: InternedString) -> P<ast::Expr> {\n+    fn expr_fail(&self, span: Span, msg: Symbol) -> P<ast::Expr> {\n         let loc = self.codemap().lookup_char_pos(span.lo);\n-        let expr_file = self.expr_str(span, intern_and_get_ident(&loc.file.name));\n+        let expr_file = self.expr_str(span, Symbol::intern(&loc.file.name));\n         let expr_line = self.expr_u32(span, loc.line as u32);\n         let expr_file_line_tuple = self.expr_tuple(span, vec![expr_file, expr_line]);\n         let expr_file_line_ptr = self.expr_addr_of(span, expr_file_line_tuple);\n@@ -800,9 +800,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n     }\n \n     fn expr_unreachable(&self, span: Span) -> P<ast::Expr> {\n-        self.expr_fail(span,\n-                       InternedString::new(\n-                           \"internal error: entered unreachable code\"))\n+        self.expr_fail(span, Symbol::intern(\"internal error: entered unreachable code\"))\n     }\n \n     fn expr_ok(&self, sp: Span, expr: P<ast::Expr>) -> P<ast::Expr> {"}, {"sha": "844fb77e29d79fa70753ef0e2b5c567c1163eeff", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=e85a0d70b86491752eb501f73b9d2025c5991e8e", "patch": "@@ -780,7 +780,7 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n                 if inline_module {\n                     if let Some(path) = attr::first_attr_value_str_by_name(&item.attrs, \"path\") {\n                         self.cx.current_expansion.no_noninline_mod = false;\n-                        module.directory.push(&*path);\n+                        module.directory.push(&*path.as_str());\n                     } else {\n                         module.directory.push(&*item.ident.name.as_str());\n                     }"}, {"sha": "aa777a19a9bcba047fe91ca30f841f19f38be83d", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=e85a0d70b86491752eb501f73b9d2025c5991e8e", "patch": "@@ -33,7 +33,7 @@ pub mod rt {\n     use parse::{self, token, classify};\n     use ptr::P;\n     use std::rc::Rc;\n-    use symbol;\n+    use symbol::Symbol;\n \n     use tokenstream::{self, TokenTree};\n \n@@ -239,8 +239,7 @@ pub mod rt {\n \n     impl ToTokens for str {\n         fn to_tokens(&self, cx: &ExtCtxt) -> Vec<TokenTree> {\n-            let lit = ast::LitKind::Str(\n-                symbol::intern_and_get_ident(self), ast::StrStyle::Cooked);\n+            let lit = ast::LitKind::Str(Symbol::intern(self), ast::StrStyle::Cooked);\n             dummy_spanned(lit).to_tokens(cx)\n         }\n     }\n@@ -538,7 +537,7 @@ fn id_ext(s: &str) -> ast::Ident {\n \n // Lift an ident to the expr that evaluates to that ident.\n fn mk_ident(cx: &ExtCtxt, sp: Span, ident: ast::Ident) -> P<ast::Expr> {\n-    let e_str = cx.expr_str(sp, ident.name.as_str());\n+    let e_str = cx.expr_str(sp, ident.name);\n     cx.expr_method_call(sp,\n                         cx.expr_ident(sp, id_ext(\"ext_cx\")),\n                         id_ext(\"ident_of\"),\n@@ -547,7 +546,7 @@ fn mk_ident(cx: &ExtCtxt, sp: Span, ident: ast::Ident) -> P<ast::Expr> {\n \n // Lift a name to the expr that evaluates to that name\n fn mk_name(cx: &ExtCtxt, sp: Span, ident: ast::Ident) -> P<ast::Expr> {\n-    let e_str = cx.expr_str(sp, ident.name.as_str());\n+    let e_str = cx.expr_str(sp, ident.name);\n     cx.expr_method_call(sp,\n                         cx.expr_ident(sp, id_ext(\"ext_cx\")),\n                         id_ext(\"name_of\"),"}, {"sha": "320d49b64634c9f5c840b7aa3901a38cc8f1e91d", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=e85a0d70b86491752eb501f73b9d2025c5991e8e", "patch": "@@ -17,7 +17,7 @@ use parse::token;\n use parse;\n use print::pprust;\n use ptr::P;\n-use symbol;\n+use symbol::Symbol;\n use tokenstream;\n use util::small_vector::SmallVector;\n \n@@ -61,14 +61,13 @@ pub fn expand_file(cx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenTree])\n \n     let topmost = cx.expansion_cause();\n     let loc = cx.codemap().lookup_char_pos(topmost.lo);\n-    let filename = symbol::intern_and_get_ident(&loc.file.name);\n-    base::MacEager::expr(cx.expr_str(topmost, filename))\n+    base::MacEager::expr(cx.expr_str(topmost, Symbol::intern(&loc.file.name)))\n }\n \n pub fn expand_stringify(cx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenTree])\n                         -> Box<base::MacResult+'static> {\n     let s = pprust::tts_to_string(tts);\n-    base::MacEager::expr(cx.expr_str(sp, symbol::intern_and_get_ident(&s)))\n+    base::MacEager::expr(cx.expr_str(sp, Symbol::intern(&s)))\n }\n \n pub fn expand_mod(cx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenTree])\n@@ -77,7 +76,7 @@ pub fn expand_mod(cx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenTree])\n     let mod_path = &cx.current_expansion.module.mod_path;\n     let string = mod_path.iter().map(|x| x.to_string()).collect::<Vec<String>>().join(\"::\");\n \n-    base::MacEager::expr(cx.expr_str(sp, symbol::intern_and_get_ident(&string)))\n+    base::MacEager::expr(cx.expr_str(sp, Symbol::intern(&string)))\n }\n \n /// include! : parse the given file as an expr\n@@ -142,10 +141,9 @@ pub fn expand_include_str(cx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenT\n             // Add this input file to the code map to make it available as\n             // dependency information\n             let filename = format!(\"{}\", file.display());\n-            let interned = symbol::intern_and_get_ident(&src);\n             cx.codemap().new_filemap_and_lines(&filename, None, &src);\n \n-            base::MacEager::expr(cx.expr_str(sp, interned))\n+            base::MacEager::expr(cx.expr_str(sp, Symbol::intern(&src)))\n         }\n         Err(_) => {\n             cx.span_err(sp,"}, {"sha": "680896e599b664efa80087366eb854e76c68e21d", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=e85a0d70b86491752eb501f73b9d2025c5991e8e", "patch": "@@ -33,7 +33,7 @@ use syntax_pos::Span;\n use errors::{DiagnosticBuilder, Handler};\n use visit::{self, FnKind, Visitor};\n use parse::ParseSess;\n-use symbol::InternedString;\n+use symbol::Symbol;\n \n use std::ascii::AsciiExt;\n use std::env;\n@@ -59,9 +59,9 @@ macro_rules! declare_features {\n         /// A set of features to be used by later passes.\n         pub struct Features {\n             /// #![feature] attrs for stable language features, for error reporting\n-            pub declared_stable_lang_features: Vec<(InternedString, Span)>,\n+            pub declared_stable_lang_features: Vec<(Symbol, Span)>,\n             /// #![feature] attrs for non-language (library) features\n-            pub declared_lib_features: Vec<(InternedString, Span)>,\n+            pub declared_lib_features: Vec<(Symbol, Span)>,\n             $(pub $feature: bool),+\n         }\n \n@@ -1121,9 +1121,8 @@ impl<'a> Visitor for PostExpansionVisitor<'a> {\n     }\n \n     fn visit_foreign_item(&mut self, i: &ast::ForeignItem) {\n-        let links_to_llvm = match attr::first_attr_value_str_by_name(&i.attrs,\n-                                                                     \"link_name\") {\n-            Some(val) => val.starts_with(\"llvm.\"),\n+        let links_to_llvm = match attr::first_attr_value_str_by_name(&i.attrs, \"link_name\") {\n+            Some(val) => val.as_str().starts_with(\"llvm.\"),\n             _ => false\n         };\n         if links_to_llvm {\n@@ -1351,7 +1350,7 @@ pub fn get_features(span_handler: &Handler, krate_attrs: &[ast::Attribute]) -> F\n             Some(list) => {\n                 for mi in list {\n                     let name = if let Some(word) = mi.word() {\n-                        word.name().as_str()\n+                        word.name()\n                     } else {\n                         span_err!(span_handler, mi.span, E0556,\n                                   \"malformed feature, expected just one word\");"}, {"sha": "ded676da3c6761baa0adb4c3cc273836ca375b22", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=e85a0d70b86491752eb501f73b9d2025c5991e8e", "patch": "@@ -48,12 +48,8 @@ impl<'a> Parser<'a> {\n                     just_parsed_doc_comment = false;\n                 }\n                 token::DocComment(s) => {\n-                    let attr = ::attr::mk_sugared_doc_attr(\n-                        attr::mk_attr_id(),\n-                        self.id_to_interned_str(ast::Ident::with_empty_ctxt(s)),\n-                        self.span.lo,\n-                        self.span.hi\n-                    );\n+                    let Span { lo, hi, .. } = self.span;\n+                    let attr = attr::mk_sugared_doc_attr(attr::mk_attr_id(), s, lo, hi);\n                     if attr.style != ast::AttrStyle::Outer {\n                         let mut err = self.fatal(\"expected outer doc comment\");\n                         err.note(\"inner doc comments like this (starting with \\\n@@ -175,8 +171,7 @@ impl<'a> Parser<'a> {\n                 token::DocComment(s) => {\n                     // we need to get the position of this token before we bump.\n                     let Span { lo, hi, .. } = self.span;\n-                    let str = self.id_to_interned_str(ast::Ident::with_empty_ctxt(s));\n-                    let attr = attr::mk_sugared_doc_attr(attr::mk_attr_id(), str, lo, hi);\n+                    let attr = attr::mk_sugared_doc_attr(attr::mk_attr_id(), s, lo, hi);\n                     if attr.style == ast::AttrStyle::Inner {\n                         attrs.push(attr);\n                         self.bump();"}, {"sha": "c811514c3073d3eb9a60ace27bb0c0ae2a764c80", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 22, "deletions": 25, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=e85a0d70b86491752eb501f73b9d2025c5991e8e", "patch": "@@ -18,7 +18,7 @@ use feature_gate::UnstableFeatures;\n use parse::parser::Parser;\n use ptr::P;\n use str::char_at;\n-use symbol::{self, InternedString};\n+use symbol::Symbol;\n use tokenstream;\n \n use std::cell::RefCell;\n@@ -372,13 +372,18 @@ fn looks_like_width_suffix(first_chars: &[char], s: &str) -> bool {\n         s[1..].chars().all(|c| '0' <= c && c <= '9')\n }\n \n-fn filtered_float_lit(data: InternedString, suffix: Option<&str>,\n-                      sd: &Handler, sp: Span) -> ast::LitKind {\n+fn filtered_float_lit(data: Symbol, suffix: Option<Symbol>, sd: &Handler, sp: Span)\n+                      -> ast::LitKind {\n     debug!(\"filtered_float_lit: {}, {:?}\", data, suffix);\n-    match suffix.as_ref().map(|s| &**s) {\n-        Some(\"f32\") => ast::LitKind::Float(data, ast::FloatTy::F32),\n-        Some(\"f64\") => ast::LitKind::Float(data, ast::FloatTy::F64),\n-        Some(suf) => {\n+    let suffix = match suffix {\n+        Some(suffix) => suffix,\n+        None => return ast::LitKind::FloatUnsuffixed(data),\n+    };\n+\n+    match &*suffix.as_str() {\n+        \"f32\" => ast::LitKind::Float(data, ast::FloatTy::F32),\n+        \"f64\" => ast::LitKind::Float(data, ast::FloatTy::F64),\n+        suf => {\n             if suf.len() >= 2 && looks_like_width_suffix(&['f'], suf) {\n                 // if it looks like a width, lets try to be helpful.\n                 sd.struct_span_err(sp, &format!(\"invalid width `{}` for float literal\", &suf[1..]))\n@@ -392,16 +397,13 @@ fn filtered_float_lit(data: InternedString, suffix: Option<&str>,\n \n             ast::LitKind::FloatUnsuffixed(data)\n         }\n-        None => ast::LitKind::FloatUnsuffixed(data)\n     }\n }\n-pub fn float_lit(s: &str, suffix: Option<InternedString>,\n-                 sd: &Handler, sp: Span) -> ast::LitKind {\n+pub fn float_lit(s: &str, suffix: Option<Symbol>, sd: &Handler, sp: Span) -> ast::LitKind {\n     debug!(\"float_lit: {:?}, {:?}\", s, suffix);\n     // FIXME #2252: bounds checking float literals is deferred until trans\n     let s = s.chars().filter(|&c| c != '_').collect::<String>();\n-    let data = symbol::intern_and_get_ident(&s);\n-    filtered_float_lit(data, suffix.as_ref().map(|s| &**s), sd, sp)\n+    filtered_float_lit(Symbol::intern(&s), suffix, sd, sp)\n }\n \n /// Parse a string representing a byte literal into its final form. Similar to `char_lit`\n@@ -496,11 +498,7 @@ pub fn byte_str_lit(lit: &str) -> Rc<Vec<u8>> {\n     Rc::new(res)\n }\n \n-pub fn integer_lit(s: &str,\n-                   suffix: Option<InternedString>,\n-                   sd: &Handler,\n-                   sp: Span)\n-                   -> ast::LitKind {\n+pub fn integer_lit(s: &str, suffix: Option<Symbol>, sd: &Handler, sp: Span) -> ast::LitKind {\n     // s can only be ascii, byte indexing is fine\n \n     let s2 = s.chars().filter(|&c| c != '_').collect::<String>();\n@@ -522,26 +520,25 @@ pub fn integer_lit(s: &str,\n     }\n \n     // 1f64 and 2f32 etc. are valid float literals.\n-    if let Some(ref suf) = suffix {\n-        if looks_like_width_suffix(&['f'], suf) {\n+    if let Some(suf) = suffix {\n+        if looks_like_width_suffix(&['f'], &suf.as_str()) {\n             match base {\n                 16 => sd.span_err(sp, \"hexadecimal float literal is not supported\"),\n                 8 => sd.span_err(sp, \"octal float literal is not supported\"),\n                 2 => sd.span_err(sp, \"binary float literal is not supported\"),\n                 _ => ()\n             }\n-            let ident = symbol::intern_and_get_ident(&s);\n-            return filtered_float_lit(ident, Some(&suf), sd, sp)\n+            return filtered_float_lit(Symbol::intern(&s), Some(suf), sd, sp)\n         }\n     }\n \n     if base != 10 {\n         s = &s[2..];\n     }\n \n-    if let Some(ref suf) = suffix {\n-        if suf.is_empty() { sd.span_bug(sp, \"found empty literal suffix in Some\")}\n-        ty = match &**suf {\n+    if let Some(suf) = suffix {\n+        if suf.as_str().is_empty() { sd.span_bug(sp, \"found empty literal suffix in Some\")}\n+        ty = match &*suf.as_str() {\n             \"isize\" => ast::LitIntType::Signed(ast::IntTy::Is),\n             \"i8\"  => ast::LitIntType::Signed(ast::IntTy::I8),\n             \"i16\" => ast::LitIntType::Signed(ast::IntTy::I16),\n@@ -552,7 +549,7 @@ pub fn integer_lit(s: &str,\n             \"u16\" => ast::LitIntType::Unsigned(ast::UintTy::U16),\n             \"u32\" => ast::LitIntType::Unsigned(ast::UintTy::U32),\n             \"u64\" => ast::LitIntType::Unsigned(ast::UintTy::U64),\n-            _ => {\n+            suf => {\n                 // i<digits> and u<digits> look like widths, so lets\n                 // give an error message along those lines\n                 if looks_like_width_suffix(&['i', 'u'], suf) {"}, {"sha": "be1abf9cc834ab54d08a719cb611940e159f3e55", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 22, "deletions": 42, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=e85a0d70b86491752eb501f73b9d2025c5991e8e", "patch": "@@ -55,7 +55,7 @@ use print::pprust;\n use ptr::P;\n use parse::PResult;\n use tokenstream::{self, Delimited, SequenceRepetition, TokenTree};\n-use symbol::{self, Symbol, keywords, InternedString};\n+use symbol::{Symbol, keywords};\n use util::ThinVec;\n \n use std::collections::HashSet;\n@@ -999,10 +999,6 @@ impl<'a> Parser<'a> {\n         &self.sess.span_diagnostic\n     }\n \n-    pub fn id_to_interned_str(&mut self, id: Ident) -> InternedString {\n-        id.name.as_str()\n-    }\n-\n     /// Is the current token one of the keywords that signals a bare function\n     /// type?\n     pub fn token_is_bare_fn_keyword(&mut self) -> bool {\n@@ -1524,34 +1520,28 @@ impl<'a> Parser<'a> {\n                     // float literals, so all the handling is done\n                     // internally.\n                     token::Integer(s) => {\n-                        (false, parse::integer_lit(&s.as_str(),\n-                                                   suf.as_ref().map(|s| s.as_str()),\n-                                                   &self.sess.span_diagnostic,\n-                                                   self.span))\n+                        let diag = &self.sess.span_diagnostic;\n+                        (false, parse::integer_lit(&s.as_str(), suf, diag, self.span))\n                     }\n                     token::Float(s) => {\n-                        (false, parse::float_lit(&s.as_str(),\n-                                                 suf.as_ref().map(|s| s.as_str()),\n-                                                  &self.sess.span_diagnostic,\n-                                                 self.span))\n+                        let diag = &self.sess.span_diagnostic;\n+                        (false, parse::float_lit(&s.as_str(), suf, diag, self.span))\n                     }\n \n                     token::Str_(s) => {\n-                        (true,\n-                         LitKind::Str(symbol::intern_and_get_ident(&parse::str_lit(&s.as_str())),\n-                                      ast::StrStyle::Cooked))\n+                        let s = Symbol::intern(&parse::str_lit(&s.as_str()));\n+                        (true, LitKind::Str(s, ast::StrStyle::Cooked))\n                     }\n                     token::StrRaw(s, n) => {\n-                        (true,\n-                         LitKind::Str(\n-                            symbol::intern_and_get_ident(&parse::raw_str_lit(&s.as_str())),\n-                            ast::StrStyle::Raw(n)))\n+                        let s = Symbol::intern(&parse::raw_str_lit(&s.as_str()));\n+                        (true, LitKind::Str(s, ast::StrStyle::Raw(n)))\n+                    }\n+                    token::ByteStr(i) => {\n+                        (true, LitKind::ByteStr(parse::byte_str_lit(&i.as_str())))\n+                    }\n+                    token::ByteStrRaw(i, _) => {\n+                        (true, LitKind::ByteStr(Rc::new(i.to_string().into_bytes())))\n                     }\n-                    token::ByteStr(i) =>\n-                        (true, LitKind::ByteStr(parse::byte_str_lit(&i.as_str()))),\n-                    token::ByteStrRaw(i, _) =>\n-                        (true,\n-                         LitKind::ByteStr(Rc::new(i.to_string().into_bytes()))),\n                 };\n \n                 if suffix_illegal {\n@@ -5303,17 +5293,16 @@ impl<'a> Parser<'a> {\n \n     fn push_directory(&mut self, id: Ident, attrs: &[Attribute]) -> Restrictions {\n         if let Some(path) = ::attr::first_attr_value_str_by_name(attrs, \"path\") {\n-            self.directory.push(&*path);\n+            self.directory.push(&*path.as_str());\n             self.restrictions - Restrictions::NO_NONINLINE_MOD\n         } else {\n-            let default_path = self.id_to_interned_str(id);\n-            self.directory.push(&*default_path);\n+            self.directory.push(&*id.name.as_str());\n             self.restrictions\n         }\n     }\n \n     pub fn submod_path_from_attr(attrs: &[ast::Attribute], dir_path: &Path) -> Option<PathBuf> {\n-        ::attr::first_attr_value_str_by_name(attrs, \"path\").map(|d| dir_path.join(&*d))\n+        ::attr::first_attr_value_str_by_name(attrs, \"path\").map(|d| dir_path.join(&*d.as_str()))\n     }\n \n     /// Returns either a path to a module, or .\n@@ -6127,26 +6116,17 @@ impl<'a> Parser<'a> {\n         })\n     }\n \n-    pub fn parse_optional_str(&mut self)\n-                              -> Option<(InternedString,\n-                                         ast::StrStyle,\n-                                         Option<ast::Name>)> {\n+    pub fn parse_optional_str(&mut self) -> Option<(Symbol, ast::StrStyle, Option<ast::Name>)> {\n         let ret = match self.token {\n-            token::Literal(token::Str_(s), suf) => {\n-                let s = self.id_to_interned_str(ast::Ident::with_empty_ctxt(s));\n-                (s, ast::StrStyle::Cooked, suf)\n-            }\n-            token::Literal(token::StrRaw(s, n), suf) => {\n-                let s = self.id_to_interned_str(ast::Ident::with_empty_ctxt(s));\n-                (s, ast::StrStyle::Raw(n), suf)\n-            }\n+            token::Literal(token::Str_(s), suf) => (s, ast::StrStyle::Cooked, suf),\n+            token::Literal(token::StrRaw(s, n), suf) => (s, ast::StrStyle::Raw(n), suf),\n             _ => return None\n         };\n         self.bump();\n         Some(ret)\n     }\n \n-    pub fn parse_str(&mut self) -> PResult<'a, (InternedString, StrStyle)> {\n+    pub fn parse_str(&mut self) -> PResult<'a, (Symbol, StrStyle)> {\n         match self.parse_optional_str() {\n             Some((s, style, suf)) => {\n                 let sp = self.prev_span;"}, {"sha": "544b431e61cce8df59fab9a9edc3a6fb15c093ee", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=e85a0d70b86491752eb501f73b9d2025c5991e8e", "patch": "@@ -630,7 +630,7 @@ pub trait PrintState<'a> {\n             _ => ()\n         }\n         match lit.node {\n-            ast::LitKind::Str(ref st, style) => self.print_string(&st, style),\n+            ast::LitKind::Str(st, style) => self.print_string(&st.as_str(), style),\n             ast::LitKind::Byte(byte) => {\n                 let mut res = String::from(\"b'\");\n                 res.extend(ascii::escape_default(byte).map(|c| c as char));\n@@ -664,7 +664,7 @@ pub trait PrintState<'a> {\n                          &f,\n                          t.ty_to_string()))\n             }\n-            ast::LitKind::FloatUnsuffixed(ref f) => word(self.writer(), &f[..]),\n+            ast::LitKind::FloatUnsuffixed(ref f) => word(self.writer(), &f.as_str()),\n             ast::LitKind::Bool(val) => {\n                 if val { word(self.writer(), \"true\") } else { word(self.writer(), \"false\") }\n             }\n@@ -752,7 +752,7 @@ pub trait PrintState<'a> {\n         }\n         try!(self.maybe_print_comment(attr.span.lo));\n         if attr.is_sugared_doc {\n-            try!(word(self.writer(), &attr.value_str().unwrap()));\n+            try!(word(self.writer(), &attr.value_str().unwrap().as_str()));\n             hardbreak(self.writer())\n         } else {\n             match attr.style {\n@@ -2220,19 +2220,18 @@ impl<'a> State<'a> {\n             ast::ExprKind::InlineAsm(ref a) => {\n                 try!(word(&mut self.s, \"asm!\"));\n                 try!(self.popen());\n-                try!(self.print_string(&a.asm, a.asm_str_style));\n+                try!(self.print_string(&a.asm.as_str(), a.asm_str_style));\n                 try!(self.word_space(\":\"));\n \n-                try!(self.commasep(Inconsistent, &a.outputs,\n-                                   |s, out| {\n-                    let mut ch = out.constraint.chars();\n+                try!(self.commasep(Inconsistent, &a.outputs, |s, out| {\n+                    let constraint = out.constraint.as_str();\n+                    let mut ch = constraint.chars();\n                     match ch.next() {\n                         Some('=') if out.is_rw => {\n                             try!(s.print_string(&format!(\"+{}\", ch.as_str()),\n                                            ast::StrStyle::Cooked))\n                         }\n-                        _ => try!(s.print_string(&out.constraint,\n-                                            ast::StrStyle::Cooked))\n+                        _ => try!(s.print_string(&constraint, ast::StrStyle::Cooked))\n                     }\n                     try!(s.popen());\n                     try!(s.print_expr(&out.expr));\n@@ -2242,9 +2241,8 @@ impl<'a> State<'a> {\n                 try!(space(&mut self.s));\n                 try!(self.word_space(\":\"));\n \n-                try!(self.commasep(Inconsistent, &a.inputs,\n-                                   |s, &(ref co, ref o)| {\n-                    try!(s.print_string(&co, ast::StrStyle::Cooked));\n+                try!(self.commasep(Inconsistent, &a.inputs, |s, &(co, ref o)| {\n+                    try!(s.print_string(&co.as_str(), ast::StrStyle::Cooked));\n                     try!(s.popen());\n                     try!(s.print_expr(&o));\n                     try!(s.pclose());\n@@ -2255,7 +2253,7 @@ impl<'a> State<'a> {\n \n                 try!(self.commasep(Inconsistent, &a.clobbers,\n                                    |s, co| {\n-                    try!(s.print_string(&co, ast::StrStyle::Cooked));\n+                    try!(s.print_string(&co.as_str(), ast::StrStyle::Cooked));\n                     Ok(())\n                 }));\n "}, {"sha": "4095845f8d94943c726550fe8b0101a261433dbd", "filename": "src/libsyntax/symbol.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibsyntax%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibsyntax%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fsymbol.rs?ref=e85a0d70b86491752eb501f73b9d2025c5991e8e", "patch": "@@ -305,13 +305,6 @@ impl Encodable for InternedString {\n     }\n }\n \n-/// Interns and returns the string contents of an identifier, using the\n-/// thread-local interner.\n-#[inline]\n-pub fn intern_and_get_ident(s: &str) -> InternedString {\n-    Symbol::intern(s).as_str()\n-}\n-\n #[cfg(test)]\n mod tests {\n     use super::*;"}, {"sha": "4de3baf7d14fb27aaa240724903e35ecd2ab91a3", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=e85a0d70b86491752eb501f73b9d2025c5991e8e", "patch": "@@ -38,12 +38,12 @@ use parse::{token, ParseSess};\n use print::pprust;\n use ast::{self, Ident};\n use ptr::P;\n-use symbol::{self, Symbol, keywords, InternedString};\n+use symbol::{self, Symbol, keywords};\n use util::small_vector::SmallVector;\n \n enum ShouldPanic {\n     No,\n-    Yes(Option<InternedString>),\n+    Yes(Option<Symbol>),\n }\n \n struct Test {\n@@ -60,7 +60,7 @@ struct TestCtxt<'a> {\n     path: Vec<Ident>,\n     ext_cx: ExtCtxt<'a>,\n     testfns: Vec<Test>,\n-    reexport_test_harness_main: Option<InternedString>,\n+    reexport_test_harness_main: Option<Symbol>,\n     is_test_crate: bool,\n \n     // top-level re-export submodule, filled out after folding is finished\n@@ -267,7 +267,7 @@ fn mk_reexport_mod(cx: &mut TestCtxt,\n \n fn generate_test_harness(sess: &ParseSess,\n                          resolver: &mut Resolver,\n-                         reexport_test_harness_main: Option<InternedString>,\n+                         reexport_test_harness_main: Option<Symbol>,\n                          krate: ast::Crate,\n                          sd: &errors::Handler) -> ast::Crate {\n     // Remove the entry points\n@@ -548,9 +548,9 @@ fn mk_test_module(cx: &mut TestCtxt) -> (P<ast::Item>, Option<P<ast::Item>>) {\n         vis: ast::Visibility::Public,\n         span: DUMMY_SP,\n     })).pop().unwrap();\n-    let reexport = cx.reexport_test_harness_main.as_ref().map(|s| {\n+    let reexport = cx.reexport_test_harness_main.map(|s| {\n         // building `use <ident> = __test::main`\n-        let reexport_ident = Ident::from_str(&s);\n+        let reexport_ident = Ident::with_empty_ctxt(s);\n \n         let use_path =\n             nospan(ast::ViewPathSimple(reexport_ident,\n@@ -618,7 +618,7 @@ fn mk_tests(cx: &TestCtxt) -> P<ast::Item> {\n \n fn is_test_crate(krate: &ast::Crate) -> bool {\n     match attr::find_crate_name(&krate.attrs) {\n-        Some(ref s) if \"test\" == &s[..] => true,\n+        Some(s) if \"test\" == &*s.as_str() => true,\n         _ => false\n     }\n }\n@@ -664,7 +664,7 @@ fn mk_test_desc_and_fn_rec(cx: &TestCtxt, test: &Test) -> P<ast::Expr> {\n \n     // path to the #[test] function: \"foo::bar::baz\"\n     let path_string = path_name_i(&path[..]);\n-    let name_expr = ecx.expr_str(span, symbol::intern_and_get_ident(&path_string[..]));\n+    let name_expr = ecx.expr_str(span, Symbol::intern(&path_string));\n \n     // self::test::StaticTestName($name_expr)\n     let name_expr = ecx.expr_call(span,\n@@ -677,10 +677,10 @@ fn mk_test_desc_and_fn_rec(cx: &TestCtxt, test: &Test) -> P<ast::Expr> {\n     };\n     let fail_expr = match test.should_panic {\n         ShouldPanic::No => ecx.expr_path(should_panic_path(\"No\")),\n-        ShouldPanic::Yes(ref msg) => {\n-            match *msg {\n-                Some(ref msg) => {\n-                    let msg = ecx.expr_str(span, msg.clone());\n+        ShouldPanic::Yes(msg) => {\n+            match msg {\n+                Some(msg) => {\n+                    let msg = ecx.expr_str(span, msg);\n                     let path = should_panic_path(\"YesWithMessage\");\n                     ecx.expr_call(span, ecx.expr_path(path), vec![msg])\n                 }"}, {"sha": "ee0c2f80891c7e63dbc069153b070e868e255de1", "filename": "src/libsyntax/tokenstream.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibsyntax%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibsyntax%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftokenstream.rs?ref=e85a0d70b86491752eb501f73b9d2025c5991e8e", "patch": "@@ -34,7 +34,7 @@ use parse::lexer;\n use parse;\n use parse::token::{self, Token, Lit, Nonterminal};\n use print::pprust;\n-use symbol::{self, Symbol};\n+use symbol::Symbol;\n \n use std::fmt;\n use std::iter::*;\n@@ -296,15 +296,15 @@ impl TokenTree {\n     pub fn maybe_str(&self) -> Option<ast::Lit> {\n         match *self {\n             TokenTree::Token(sp, Token::Literal(Lit::Str_(s), _)) => {\n-                let l = LitKind::Str(symbol::intern_and_get_ident(&parse::str_lit(&s.as_str())),\n+                let l = LitKind::Str(Symbol::intern(&parse::str_lit(&s.as_str())),\n                                      ast::StrStyle::Cooked);\n                 Some(Spanned {\n                     node: l,\n                     span: sp,\n                 })\n             }\n             TokenTree::Token(sp, Token::Literal(Lit::StrRaw(s, n), _)) => {\n-                let l = LitKind::Str(symbol::intern_and_get_ident(&parse::raw_str_lit(&s.as_str())),\n+                let l = LitKind::Str(Symbol::intern(&parse::raw_str_lit(&s.as_str())),\n                                      ast::StrStyle::Raw(n));\n                 Some(Spanned {\n                     node: l,"}, {"sha": "a6fff2d707469ffd2d4d1607dfb658b62b4a1139", "filename": "src/libsyntax/util/lev_distance.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibsyntax%2Futil%2Flev_distance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibsyntax%2Futil%2Flev_distance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Flev_distance.rs?ref=e85a0d70b86491752eb501f73b9d2025c5991e8e", "patch": "@@ -8,9 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use ast::Name;\n use std::cmp;\n-use symbol::InternedString;\n+use symbol::Symbol;\n \n /// To find the Levenshtein distance between two strings\n pub fn lev_distance(a: &str, b: &str) -> usize {\n@@ -48,14 +47,14 @@ pub fn lev_distance(a: &str, b: &str) -> usize {\n /// to one-third of the given word\n pub fn find_best_match_for_name<'a, T>(iter_names: T,\n                                        lookup: &str,\n-                                       dist: Option<usize>) -> Option<InternedString>\n-    where T: Iterator<Item = &'a Name> {\n+                                       dist: Option<usize>) -> Option<Symbol>\n+    where T: Iterator<Item = &'a Symbol> {\n     let max_dist = dist.map_or_else(|| cmp::max(lookup.len(), 3) / 3, |d| d);\n     iter_names\n-    .filter_map(|name| {\n+    .filter_map(|&name| {\n         let dist = lev_distance(lookup, &name.as_str());\n         match dist <= max_dist {    // filter the unwanted cases\n-            true => Some((name.as_str(), dist)),\n+            true => Some((name, dist)),\n             false => None,\n         }\n     })"}, {"sha": "a5e083f926a07ad97184355a2604f2c73ee4726a", "filename": "src/libsyntax_ext/asm.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibsyntax_ext%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibsyntax_ext%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fasm.rs?ref=e85a0d70b86491752eb501f73b9d2025c5991e8e", "patch": "@@ -19,7 +19,7 @@ use syntax::ext::base::*;\n use syntax::feature_gate;\n use syntax::parse::{self, token};\n use syntax::ptr::P;\n-use syntax::symbol::{self, Symbol, InternedString};\n+use syntax::symbol::Symbol;\n use syntax::ast::AsmDialect;\n use syntax_pos::Span;\n use syntax::tokenstream;\n@@ -73,7 +73,7 @@ pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt,\n         })\n         .unwrap_or(tts.len());\n     let mut p = cx.new_parser_from_tts(&tts[first_colon..]);\n-    let mut asm = InternedString::new(\"\");\n+    let mut asm = Symbol::intern(\"\");\n     let mut asm_str_style = None;\n     let mut outputs = Vec::new();\n     let mut inputs = Vec::new();\n@@ -135,11 +135,12 @@ pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt,\n                     // It's the opposite of '=&' which means that the memory\n                     // cannot be shared with any other operand (usually when\n                     // a register is clobbered early.)\n-                    let mut ch = constraint.chars();\n+                    let constraint_str = constraint.as_str();\n+                    let mut ch = constraint_str.chars();\n                     let output = match ch.next() {\n                         Some('=') => None,\n                         Some('+') => {\n-                            Some(symbol::intern_and_get_ident(&format!(\"={}\", ch.as_str())))\n+                            Some(Symbol::intern(&format!(\"={}\", ch.as_str())))\n                         }\n                         _ => {\n                             cx.span_err(span, \"output operand constraint lacks '=' or '+'\");\n@@ -148,9 +149,9 @@ pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt,\n                     };\n \n                     let is_rw = output.is_some();\n-                    let is_indirect = constraint.contains(\"*\");\n+                    let is_indirect = constraint_str.contains(\"*\");\n                     outputs.push(ast::InlineAsmOutput {\n-                        constraint: output.unwrap_or(constraint.clone()),\n+                        constraint: output.unwrap_or(constraint),\n                         expr: out,\n                         is_rw: is_rw,\n                         is_indirect: is_indirect,\n@@ -166,9 +167,9 @@ pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt,\n \n                     let (constraint, _str_style) = panictry!(p.parse_str());\n \n-                    if constraint.starts_with(\"=\") {\n+                    if constraint.as_str().starts_with(\"=\") {\n                         cx.span_err(p.prev_span, \"input operand constraint contains '='\");\n-                    } else if constraint.starts_with(\"+\") {\n+                    } else if constraint.as_str().starts_with(\"+\") {\n                         cx.span_err(p.prev_span, \"input operand constraint contains '+'\");\n                     }\n \n@@ -190,7 +191,7 @@ pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt,\n \n                     if OPTIONS.iter().any(|&opt| s == opt) {\n                         cx.span_warn(p.prev_span, \"expected a clobber, found an option\");\n-                    } else if s.starts_with(\"{\") || s.ends_with(\"}\") {\n+                    } else if s.as_str().starts_with(\"{\") || s.as_str().ends_with(\"}\") {\n                         cx.span_err(p.prev_span, \"clobber should not be surrounded by braces\");\n                     }\n \n@@ -251,7 +252,7 @@ pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt,\n     MacEager::expr(P(ast::Expr {\n         id: ast::DUMMY_NODE_ID,\n         node: ast::ExprKind::InlineAsm(P(ast::InlineAsm {\n-            asm: symbol::intern_and_get_ident(&asm),\n+            asm: asm,\n             asm_str_style: asm_str_style.unwrap(),\n             outputs: outputs,\n             inputs: inputs,"}, {"sha": "bfe18dc4060c929820c2a6c363bf213c84193846", "filename": "src/libsyntax_ext/concat.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibsyntax_ext%2Fconcat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibsyntax_ext%2Fconcat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fconcat.rs?ref=e85a0d70b86491752eb501f73b9d2025c5991e8e", "patch": "@@ -11,7 +11,7 @@\n use syntax::ast;\n use syntax::ext::base;\n use syntax::ext::build::AstBuilder;\n-use syntax::symbol::intern_and_get_ident;\n+use syntax::symbol::Symbol;\n use syntax_pos;\n use syntax::tokenstream;\n \n@@ -33,7 +33,7 @@ pub fn expand_syntax_ext(cx: &mut base::ExtCtxt,\n                     ast::LitKind::Str(ref s, _) |\n                     ast::LitKind::Float(ref s, _) |\n                     ast::LitKind::FloatUnsuffixed(ref s) => {\n-                        accumulator.push_str(&s);\n+                        accumulator.push_str(&s.as_str());\n                     }\n                     ast::LitKind::Char(c) => {\n                         accumulator.push(c);\n@@ -57,5 +57,5 @@ pub fn expand_syntax_ext(cx: &mut base::ExtCtxt,\n             }\n         }\n     }\n-    base::MacEager::expr(cx.expr_str(sp, intern_and_get_ident(&accumulator[..])))\n+    base::MacEager::expr(cx.expr_str(sp, Symbol::intern(&accumulator)))\n }"}, {"sha": "a767716466cb15d13e1902ecccf1fa4a97a73064", "filename": "src/libsyntax_ext/deriving/debug.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs?ref=e85a0d70b86491752eb501f73b9d2025c5991e8e", "patch": "@@ -68,8 +68,7 @@ fn show_substructure(cx: &mut ExtCtxt, span: Span, substr: &Substructure) -> P<E\n \n     // We want to make sure we have the expn_id set so that we can use unstable methods\n     let span = Span { expn_id: cx.backtrace(), ..span };\n-    let name = cx.expr_lit(span,\n-                           ast::LitKind::Str(ident.name.as_str(), ast::StrStyle::Cooked));\n+    let name = cx.expr_lit(span, ast::LitKind::Str(ident.name, ast::StrStyle::Cooked));\n     let builder = Ident::from_str(\"builder\");\n     let builder_expr = cx.expr_ident(span, builder.clone());\n \n@@ -107,7 +106,7 @@ fn show_substructure(cx: &mut ExtCtxt, span: Span, substr: &Substructure) -> P<E\n \n                 for field in fields {\n                     let name = cx.expr_lit(field.span,\n-                                           ast::LitKind::Str(field.name.unwrap().name.as_str(),\n+                                           ast::LitKind::Str(field.name.unwrap().name,\n                                                              ast::StrStyle::Cooked));\n \n                     // Use double indirection to make sure this works for unsized types"}, {"sha": "e2634c60dcaad0cd8f16ab3e824c8a54e8b7ccbb", "filename": "src/libsyntax_ext/deriving/decodable.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibsyntax_ext%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibsyntax_ext%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fdecodable.rs?ref=e85a0d70b86491752eb501f73b9d2025c5991e8e", "patch": "@@ -19,8 +19,7 @@ use syntax::ast::{Expr, MetaItem, Mutability};\n use syntax::ext::base::{Annotatable, ExtCtxt};\n use syntax::ext::build::AstBuilder;\n use syntax::ptr::P;\n-use syntax::symbol::InternedString;\n-use syntax::symbol::intern_and_get_ident;\n+use syntax::symbol::Symbol;\n use syntax_pos::Span;\n \n pub fn expand_deriving_rustc_decodable(cx: &mut ExtCtxt,\n@@ -131,7 +130,7 @@ fn decodable_substructure(cx: &mut ExtCtxt,\n             cx.expr_method_call(trait_span,\n                                 decoder,\n                                 cx.ident_of(\"read_struct\"),\n-                                vec![cx.expr_str(trait_span, substr.type_ident.name.as_str()),\n+                                vec![cx.expr_str(trait_span, substr.type_ident.name),\n                                      cx.expr_usize(trait_span, nfields),\n                                      cx.lambda1(trait_span, result, blkarg)])\n         }\n@@ -143,7 +142,7 @@ fn decodable_substructure(cx: &mut ExtCtxt,\n             let rvariant_arg = cx.ident_of(\"read_enum_variant_arg\");\n \n             for (i, &(ident, v_span, ref parts)) in fields.iter().enumerate() {\n-                variants.push(cx.expr_str(v_span, ident.name.as_str()));\n+                variants.push(cx.expr_str(v_span, ident.name));\n \n                 let path = cx.path(trait_span, vec![substr.type_ident, ident]);\n                 let decoded = decode_static_fields(cx, v_span, path, parts, |cx, span, _, field| {\n@@ -175,7 +174,7 @@ fn decodable_substructure(cx: &mut ExtCtxt,\n             cx.expr_method_call(trait_span,\n                                 decoder,\n                                 cx.ident_of(\"read_enum\"),\n-                                vec![cx.expr_str(trait_span, substr.type_ident.name.as_str()),\n+                                vec![cx.expr_str(trait_span, substr.type_ident.name),\n                                      cx.lambda1(trait_span, result, blkarg)])\n         }\n         _ => cx.bug(\"expected StaticEnum or StaticStruct in derive(Decodable)\"),\n@@ -191,7 +190,7 @@ fn decode_static_fields<F>(cx: &mut ExtCtxt,\n                            fields: &StaticFields,\n                            mut getarg: F)\n                            -> P<Expr>\n-    where F: FnMut(&mut ExtCtxt, Span, InternedString, usize) -> P<Expr>\n+    where F: FnMut(&mut ExtCtxt, Span, Symbol, usize) -> P<Expr>\n {\n     match *fields {\n         Unnamed(ref fields, is_tuple) => {\n@@ -202,7 +201,7 @@ fn decode_static_fields<F>(cx: &mut ExtCtxt,\n                 let fields = fields.iter()\n                     .enumerate()\n                     .map(|(i, &span)| {\n-                        getarg(cx, span, intern_and_get_ident(&format!(\"_field{}\", i)), i)\n+                        getarg(cx, span, Symbol::intern(&format!(\"_field{}\", i)), i)\n                     })\n                     .collect();\n \n@@ -214,7 +213,7 @@ fn decode_static_fields<F>(cx: &mut ExtCtxt,\n             let fields = fields.iter()\n                 .enumerate()\n                 .map(|(i, &(ident, span))| {\n-                    let arg = getarg(cx, span, ident.name.as_str(), i);\n+                    let arg = getarg(cx, span, ident.name, i);\n                     cx.field_imm(span, ident, arg)\n                 })\n                 .collect();"}, {"sha": "092738ab8a03d372333f6272ae608e775cc9d617", "filename": "src/libsyntax_ext/deriving/encodable.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibsyntax_ext%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibsyntax_ext%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fencodable.rs?ref=e85a0d70b86491752eb501f73b9d2025c5991e8e", "patch": "@@ -96,7 +96,7 @@ use syntax::ast::{Expr, ExprKind, MetaItem, Mutability};\n use syntax::ext::base::{Annotatable, ExtCtxt};\n use syntax::ext::build::AstBuilder;\n use syntax::ptr::P;\n-use syntax::symbol::intern_and_get_ident;\n+use syntax::symbol::Symbol;\n use syntax_pos::Span;\n \n pub fn expand_deriving_rustc_encodable(cx: &mut ExtCtxt,\n@@ -192,8 +192,8 @@ fn encodable_substructure(cx: &mut ExtCtxt,\n             let mut stmts = Vec::new();\n             for (i, &FieldInfo { name, ref self_, span, .. }) in fields.iter().enumerate() {\n                 let name = match name {\n-                    Some(id) => id.name.as_str(),\n-                    None => intern_and_get_ident(&format!(\"_field{}\", i)),\n+                    Some(id) => id.name,\n+                    None => Symbol::intern(&format!(\"_field{}\", i)),\n                 };\n                 let self_ref = cx.expr_addr_of(span, self_.clone());\n                 let enc = cx.expr_call(span, fn_path.clone(), vec![self_ref, blkencoder.clone()]);\n@@ -226,7 +226,7 @@ fn encodable_substructure(cx: &mut ExtCtxt,\n             cx.expr_method_call(trait_span,\n                                 encoder,\n                                 cx.ident_of(\"emit_struct\"),\n-                                vec![cx.expr_str(trait_span, substr.type_ident.name.as_str()),\n+                                vec![cx.expr_str(trait_span, substr.type_ident.name),\n                                      cx.expr_usize(trait_span, fields.len()),\n                                      blk])\n         }\n@@ -265,7 +265,7 @@ fn encodable_substructure(cx: &mut ExtCtxt,\n             }\n \n             let blk = cx.lambda_stmts_1(trait_span, stmts, blkarg);\n-            let name = cx.expr_str(trait_span, variant.node.name.name.as_str());\n+            let name = cx.expr_str(trait_span, variant.node.name.name);\n             let call = cx.expr_method_call(trait_span,\n                                            blkencoder,\n                                            cx.ident_of(\"emit_enum_variant\"),\n@@ -277,8 +277,7 @@ fn encodable_substructure(cx: &mut ExtCtxt,\n             let ret = cx.expr_method_call(trait_span,\n                                           encoder,\n                                           cx.ident_of(\"emit_enum\"),\n-                                          vec![cx.expr_str(trait_span,\n-                                                           substr.type_ident.name.as_str()),\n+                                          vec![cx.expr_str(trait_span ,substr.type_ident.name),\n                                                blk]);\n             cx.expr_block(cx.block(trait_span, vec![me, cx.stmt_expr(ret)]))\n         }"}, {"sha": "ecf0a8f377ea3dc3c81f220cc3688020525778bf", "filename": "src/libsyntax_ext/env.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibsyntax_ext%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibsyntax_ext%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fenv.rs?ref=e85a0d70b86491752eb501f73b9d2025c5991e8e", "patch": "@@ -17,7 +17,7 @@ use syntax::ast;\n use syntax::ext::base::*;\n use syntax::ext::base;\n use syntax::ext::build::AstBuilder;\n-use syntax::symbol::intern_and_get_ident;\n+use syntax::symbol::Symbol;\n use syntax_pos::Span;\n use syntax::tokenstream;\n \n@@ -32,7 +32,7 @@ pub fn expand_option_env<'cx>(cx: &'cx mut ExtCtxt,\n         Some(v) => v,\n     };\n \n-    let e = match env::var(&var[..]) {\n+    let e = match env::var(&*var.as_str()) {\n         Err(..) => {\n             cx.expr_path(cx.path_all(sp,\n                                      true,\n@@ -49,7 +49,7 @@ pub fn expand_option_env<'cx>(cx: &'cx mut ExtCtxt,\n         Ok(s) => {\n             cx.expr_call_global(sp,\n                                 cx.std_path(&[\"option\", \"Option\", \"Some\"]),\n-                                vec![cx.expr_str(sp, intern_and_get_ident(&s[..]))])\n+                                vec![cx.expr_str(sp, Symbol::intern(&s))])\n         }\n     };\n     MacEager::expr(e)\n@@ -73,7 +73,7 @@ pub fn expand_env<'cx>(cx: &'cx mut ExtCtxt,\n         Some((v, _style)) => v,\n     };\n     let msg = match exprs.next() {\n-        None => intern_and_get_ident(&format!(\"environment variable `{}` not defined\", var)),\n+        None => Symbol::intern(&format!(\"environment variable `{}` not defined\", var)),\n         Some(second) => {\n             match expr_to_string(cx, second, \"expected string literal\") {\n                 None => return DummyResult::expr(sp),\n@@ -87,12 +87,12 @@ pub fn expand_env<'cx>(cx: &'cx mut ExtCtxt,\n         return DummyResult::expr(sp);\n     }\n \n-    let e = match env::var(&var[..]) {\n+    let e = match env::var(&*var.as_str()) {\n         Err(_) => {\n-            cx.span_err(sp, &msg);\n+            cx.span_err(sp, &msg.as_str());\n             cx.expr_usize(sp, 0)\n         }\n-        Ok(s) => cx.expr_str(sp, intern_and_get_ident(&s)),\n+        Ok(s) => cx.expr_str(sp, Symbol::intern(&s)),\n     };\n     MacEager::expr(e)\n }"}, {"sha": "d2afa08cadaf4efb40b16f32b46996a9078dc06a", "filename": "src/libsyntax_ext/format.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibsyntax_ext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibsyntax_ext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fformat.rs?ref=e85a0d70b86491752eb501f73b9d2025c5991e8e", "patch": "@@ -19,7 +19,7 @@ use syntax::ext::base;\n use syntax::ext::build::AstBuilder;\n use syntax::parse::token;\n use syntax::ptr::P;\n-use syntax::symbol::{self, keywords};\n+use syntax::symbol::{Symbol, keywords};\n use syntax_pos::{Span, DUMMY_SP};\n use syntax::tokenstream;\n \n@@ -370,7 +370,7 @@ impl<'a, 'b> Context<'a, 'b> {\n     /// Translate the accumulated string literals to a literal expression\n     fn trans_literal_string(&mut self) -> P<ast::Expr> {\n         let sp = self.fmtsp;\n-        let s = symbol::intern_and_get_ident(&self.literal);\n+        let s = Symbol::intern(&self.literal);\n         self.literal.clear();\n         self.ecx.expr_str(sp, s)\n     }\n@@ -728,7 +728,8 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt,\n         fmtsp: fmt.span,\n     };\n \n-    let mut parser = parse::Parser::new(&fmt.node.0);\n+    let fmt_str = &*fmt.node.0.as_str();\n+    let mut parser = parse::Parser::new(fmt_str);\n     let mut pieces = vec![];\n \n     loop {\n@@ -809,7 +810,6 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt,\n         // Decide if we want to look for foreign formatting directives.\n         if args_used < args_unused {\n             use super::format_foreign as foreign;\n-            let fmt_str = &fmt.node.0[..];\n \n             // The set of foreign substitutions we've explained.  This prevents spamming the user\n             // with `%d should be written as {}` over and over again."}, {"sha": "bbdbda701ae8eba464d48f88f7a9f6b9e33e8d16", "filename": "src/libsyntax_ext/proc_macro_registrar.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibsyntax_ext%2Fproc_macro_registrar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e85a0d70b86491752eb501f73b9d2025c5991e8e/src%2Flibsyntax_ext%2Fproc_macro_registrar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fproc_macro_registrar.rs?ref=e85a0d70b86491752eb501f73b9d2025c5991e8e", "patch": "@@ -290,10 +290,10 @@ fn mk_registrar(cx: &mut ExtCtxt,\n     let register_custom_derive = Ident::from_str(\"register_custom_derive\");\n     let stmts = custom_derives.iter().map(|cd| {\n         let path = cx.path_global(cd.span, vec![cd.function_name]);\n-        let trait_name = cx.expr_str(cd.span, cd.trait_name.as_str());\n+        let trait_name = cx.expr_str(cd.span, cd.trait_name);\n         let attrs = cx.expr_vec_slice(\n             span,\n-            cd.attrs.iter().map(|s| cx.expr_str(cd.span, s.as_str())).collect::<Vec<_>>()\n+            cd.attrs.iter().map(|&s| cx.expr_str(cd.span, s)).collect::<Vec<_>>()\n         );\n         (path, trait_name, attrs)\n     }).map(|(path, trait_name, attrs)| {"}]}