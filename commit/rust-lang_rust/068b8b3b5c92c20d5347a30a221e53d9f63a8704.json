{"sha": "068b8b3b5c92c20d5347a30a221e53d9f63a8704", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA2OGI4YjNiNWM5MmMyMGQ1MzQ3YTMwYTIyMWU1M2Q5ZjYzYTg3MDQ=", "commit": {"author": {"name": "Nick Cameron", "email": "nrc@ncameron.org", "date": "2017-05-22T00:13:22Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-05-22T00:13:22Z"}, "message": "Merge pull request #1558 from mjkillough/config\n\nAdd a flag to emit which options are used", "tree": {"sha": "4c916a9ee404d97802d271e771babedf7b74da15", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4c916a9ee404d97802d271e771babedf7b74da15"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/068b8b3b5c92c20d5347a30a221e53d9f63a8704", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/068b8b3b5c92c20d5347a30a221e53d9f63a8704", "html_url": "https://github.com/rust-lang/rust/commit/068b8b3b5c92c20d5347a30a221e53d9f63a8704", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/068b8b3b5c92c20d5347a30a221e53d9f63a8704/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fdf950b009cf455c98ee8656f28342cedcc7a40d", "url": "https://api.github.com/repos/rust-lang/rust/commits/fdf950b009cf455c98ee8656f28342cedcc7a40d", "html_url": "https://github.com/rust-lang/rust/commit/fdf950b009cf455c98ee8656f28342cedcc7a40d"}, {"sha": "bce1f309b7b6516cf2a8446f64b9b54f143e6518", "url": "https://api.github.com/repos/rust-lang/rust/commits/bce1f309b7b6516cf2a8446f64b9b54f143e6518", "html_url": "https://github.com/rust-lang/rust/commit/bce1f309b7b6516cf2a8446f64b9b54f143e6518"}], "stats": {"total": 841, "additions": 511, "deletions": 330}, "files": [{"sha": "730cefdca45490bdbc12d1dc01d330d23ee883f0", "filename": "Contributing.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/068b8b3b5c92c20d5347a30a221e53d9f63a8704/Contributing.md", "raw_url": "https://github.com/rust-lang/rust/raw/068b8b3b5c92c20d5347a30a221e53d9f63a8704/Contributing.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Contributing.md?ref=068b8b3b5c92c20d5347a30a221e53d9f63a8704", "patch": "@@ -207,6 +207,6 @@ handling of configuration options is done in [src/config.rs](src/config.rs). Loo\n `create_config!` macro at the end of the file for all the options. The rest of\n the file defines a bunch of enums used for options, and the machinery to produce\n the config struct and parse a config file, etc. Checking an option is done by\n-accessing the correct field on the config struct, e.g., `config.max_width`. Most\n+accessing the correct field on the config struct, e.g., `config.max_width()`. Most\n functions have a `Config`, or one can be accessed via a visitor or context of\n some kind."}, {"sha": "43caa7b81f80114aa7ac7e9b7728f58bf8dfecd5", "filename": "Design.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/068b8b3b5c92c20d5347a30a221e53d9f63a8704/Design.md", "raw_url": "https://github.com/rust-lang/rust/raw/068b8b3b5c92c20d5347a30a221e53d9f63a8704/Design.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Design.md?ref=068b8b3b5c92c20d5347a30a221e53d9f63a8704", "patch": "@@ -150,7 +150,7 @@ for its configuration.\n \n Our visitor keeps track of the desired current indent due to blocks (\n `block_indent`). Each `visit_*` method reformats code according to this indent,\n-`config.comment_width` and `config.max_width`. Most reformatting done in the\n+`config.comment_width()` and `config.max_width()`. Most reformatting done in the\n `visit_*` methods is a bit hackey and is meant to be temporary until it can be\n done properly.\n "}, {"sha": "73c4439ba2965aa2e713b28e0600a20ca04b90ce", "filename": "src/bin/rustfmt.rs", "status": "modified", "additions": 46, "deletions": 8, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/068b8b3b5c92c20d5347a30a221e53d9f63a8704/src%2Fbin%2Frustfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/068b8b3b5c92c20d5347a30a221e53d9f63a8704/src%2Fbin%2Frustfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Frustfmt.rs?ref=068b8b3b5c92c20d5347a30a221e53d9f63a8704", "patch": "@@ -44,13 +44,16 @@ enum Operation {\n     Format {\n         files: Vec<PathBuf>,\n         config_path: Option<PathBuf>,\n+        minimal_config_path: Option<String>,\n     },\n     /// Print the help message.\n     Help,\n     // Print version information\n     Version,\n     /// Print detailed configuration help.\n     ConfigHelp,\n+    /// Output default config to a file\n+    ConfigOutputDefault { path: String },\n     /// No file specified, read from stdin\n     Stdin {\n         input: String,\n@@ -89,11 +92,11 @@ impl CliOptions {\n     }\n \n     fn apply_to(self, config: &mut Config) {\n-        config.skip_children = self.skip_children;\n-        config.verbose = self.verbose;\n-        config.file_lines = self.file_lines;\n+        config.set().skip_children(self.skip_children);\n+        config.set().verbose(self.verbose);\n+        config.set().file_lines(self.file_lines);\n         if let Some(write_mode) = self.write_mode {\n-            config.write_mode = write_mode;\n+            config.set().write_mode(write_mode);\n         }\n     }\n }\n@@ -186,6 +189,14 @@ fn make_opts() -> Options {\n     opts.optflag(\"\",\n                  \"config-help\",\n                  \"show details of rustfmt configuration options\");\n+    opts.optopt(\"\",\n+                \"dump-default-config\",\n+                \"Dumps the default configuration to a file and exits.\",\n+                \"PATH\");\n+    opts.optopt(\"\",\n+                \"dump-minimal-config\",\n+                \"Dumps configuration options that were checked during formatting to a file.\",\n+                \"PATH\");\n     opts.optopt(\"\",\n                 \"config-path\",\n                 \"Recursively searches the given path for the rustfmt.toml config file. If not \\\n@@ -216,18 +227,24 @@ fn execute(opts: &Options) -> FmtResult<Summary> {\n             Config::print_docs();\n             Ok(Summary::new())\n         }\n+        Operation::ConfigOutputDefault { path } => {\n+            let mut file = File::create(path)?;\n+            let toml = Config::default().all_options().to_toml()?;\n+            file.write_all(toml.as_bytes())?;\n+            Ok(Summary::new())\n+        }\n         Operation::Stdin { input, config_path } => {\n             // try to read config from local directory\n             let (mut config, _) = match_cli_path_or_file(config_path,\n                                                          &env::current_dir().unwrap())?;\n \n             // write_mode is always Plain for Stdin.\n-            config.write_mode = WriteMode::Plain;\n+            config.set().write_mode(WriteMode::Plain);\n \n             // parse file_lines\n             if let Some(ref file_lines) = matches.opt_str(\"file-lines\") {\n-                config.file_lines = file_lines.parse()?;\n-                for f in config.file_lines.files() {\n+                config.set().file_lines(file_lines.parse()?);\n+                for f in config.file_lines().files() {\n                     if f != \"stdin\" {\n                         println!(\"Warning: Extra file listed in file_lines option '{}'\", f);\n                     }\n@@ -236,7 +253,11 @@ fn execute(opts: &Options) -> FmtResult<Summary> {\n \n             Ok(run(Input::Text(input), &config))\n         }\n-        Operation::Format { files, config_path } => {\n+        Operation::Format {\n+            files,\n+            config_path,\n+            minimal_config_path,\n+        } => {\n             let options = CliOptions::from_matches(&matches)?;\n \n             for f in options.file_lines.files() {\n@@ -286,6 +307,15 @@ fn execute(opts: &Options) -> FmtResult<Summary> {\n                     error_summary.add(run(Input::File(file), &config));\n                 }\n             }\n+\n+            // If we were given a path via dump-minimal-config, output any options\n+            // that were used during formatting as TOML.\n+            if let Some(path) = minimal_config_path {\n+                let mut file = File::create(path)?;\n+                let toml = config.used_options().to_toml()?;\n+                file.write_all(toml.as_bytes())?;\n+            }\n+\n             Ok(error_summary)\n         }\n     }\n@@ -353,6 +383,10 @@ fn determine_operation(matches: &Matches) -> FmtResult<Operation> {\n         return Ok(Operation::ConfigHelp);\n     }\n \n+    if let Some(path) = matches.opt_str(\"dump-default-config\") {\n+        return Ok(Operation::ConfigOutputDefault { path });\n+    }\n+\n     if matches.opt_present(\"version\") {\n         return Ok(Operation::Version);\n     }\n@@ -383,6 +417,9 @@ fn determine_operation(matches: &Matches) -> FmtResult<Operation> {\n         path @ _ => path,\n     };\n \n+    // If no path is given, we won't output a minimal config.\n+    let minimal_config_path = matches.opt_str(\"dump-minimal-config\");\n+\n     // if no file argument is supplied, read from stdin\n     if matches.free.is_empty() {\n         let mut buffer = String::new();\n@@ -408,5 +445,6 @@ fn determine_operation(matches: &Matches) -> FmtResult<Operation> {\n     Ok(Operation::Format {\n            files: files,\n            config_path: config_path,\n+           minimal_config_path: minimal_config_path,\n        })\n }"}, {"sha": "209c0eb138238fb644813411f00576906bc450ff", "filename": "src/chains.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/068b8b3b5c92c20d5347a30a221e53d9f63a8704/src%2Fchains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/068b8b3b5c92c20d5347a30a221e53d9f63a8704/src%2Fchains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fchains.rs?ref=068b8b3b5c92c20d5347a30a221e53d9f63a8704", "patch": "@@ -114,23 +114,23 @@ pub fn rewrite_chain(expr: &ast::Expr, context: &RewriteContext, shape: Shape) -\n     };\n     let (nested_shape, extend) = if !parent_rewrite_contains_newline && is_continuable(&parent) {\n         let nested_shape = if first_subexpr_is_try {\n-            parent_shape.block_indent(context.config.tab_spaces)\n+            parent_shape.block_indent(context.config.tab_spaces())\n         } else {\n             chain_indent(context, shape.add_offset(parent_rewrite.len()))\n         };\n         (nested_shape,\n-         context.config.chain_indent == IndentStyle::Visual ||\n-         parent_rewrite.len() <= context.config.tab_spaces)\n+         context.config.chain_indent() == IndentStyle::Visual ||\n+         parent_rewrite.len() <= context.config.tab_spaces())\n     } else if is_block_expr(&parent, &parent_rewrite) {\n         // The parent is a block, so align the rest of the chain with the closing\n         // brace.\n         (parent_shape, false)\n     } else if parent_rewrite_contains_newline {\n         (chain_indent(context,\n-                      parent_shape.block_indent(context.config.tab_spaces)),\n+                      parent_shape.block_indent(context.config.tab_spaces())),\n          false)\n     } else {\n-        (shape.block_indent(context.config.tab_spaces), false)\n+        (shape.block_indent(context.config.tab_spaces()), false)\n     };\n \n     let max_width = try_opt!((shape.width + shape.indent.width() + shape.offset)\n@@ -143,14 +143,14 @@ pub fn rewrite_chain(expr: &ast::Expr, context: &RewriteContext, shape: Shape) -\n     };\n     let first_child_shape = if extend {\n         let mut shape = try_opt!(parent_shape.offset_left(last_line_width(&parent_rewrite)));\n-        match context.config.chain_indent {\n+        match context.config.chain_indent() {\n             IndentStyle::Visual => shape,\n             IndentStyle::Block => {\n                 shape.offset = shape\n                     .offset\n-                    .checked_sub(context.config.tab_spaces)\n+                    .checked_sub(context.config.tab_spaces())\n                     .unwrap_or(0);\n-                shape.indent.block_indent += context.config.tab_spaces;\n+                shape.indent.block_indent += context.config.tab_spaces();\n                 shape\n             }\n         }\n@@ -177,7 +177,7 @@ pub fn rewrite_chain(expr: &ast::Expr, context: &RewriteContext, shape: Shape) -\n     let one_line_len = rewrites.iter().fold(0, |a, r| a + first_line_width(r)) +\n                        parent_rewrite.len();\n \n-    let veto_single_line = if one_line_len > context.config.chain_one_line_max {\n+    let veto_single_line = if one_line_len > context.config.chain_one_line_max() {\n         if rewrites.len() > 1 {\n             true\n         } else if rewrites.len() == 1 {\n@@ -186,7 +186,7 @@ pub fn rewrite_chain(expr: &ast::Expr, context: &RewriteContext, shape: Shape) -\n         } else {\n             false\n         }\n-    } else if context.config.take_source_hints && subexpr_list.len() > 1 {\n+    } else if context.config.take_source_hints() && subexpr_list.len() > 1 {\n         // Look at the source code. Unless all chain elements start on the same\n         // line, we won't consider putting them on a single line either.\n         let last_span = context.snippet(mk_sp(subexpr_list[1].span.hi, total_span.hi));\n@@ -215,7 +215,7 @@ pub fn rewrite_chain(expr: &ast::Expr, context: &RewriteContext, shape: Shape) -\n                                                          shape) {\n                         // If the first line of the last method does not fit into a single line\n                         // after the others, allow new lines.\n-                        almost_total + first_line_width(&last[0]) < context.config.max_width\n+                        almost_total + first_line_width(&last[0]) < context.config.max_width()\n                     } else {\n                         false\n                     }\n@@ -243,7 +243,7 @@ pub fn rewrite_chain(expr: &ast::Expr, context: &RewriteContext, shape: Shape) -\n                      parent_rewrite,\n                      first_connector,\n                      join_rewrites(&rewrites, &subexpr_list, &connector)),\n-             context.config.max_width,\n+             context.config.max_width(),\n              shape)\n }\n \n@@ -319,9 +319,9 @@ fn make_subexpr_list(expr: &ast::Expr, context: &RewriteContext) -> (ast::Expr,\n }\n \n fn chain_indent(context: &RewriteContext, shape: Shape) -> Shape {\n-    match context.config.chain_indent {\n+    match context.config.chain_indent() {\n         IndentStyle::Visual => shape.visual_indent(0),\n-        IndentStyle::Block => shape.block_indent(context.config.tab_spaces),\n+        IndentStyle::Block => shape.block_indent(context.config.tab_spaces()),\n     }\n }\n \n@@ -371,7 +371,7 @@ fn pop_expr_chain(expr: &ast::Expr, context: &RewriteContext) -> Option<ast::Exp\n \n fn convert_try(expr: &ast::Expr, context: &RewriteContext) -> ast::Expr {\n     match expr.node {\n-        ast::ExprKind::Mac(ref mac) if context.config.use_try_shorthand => {\n+        ast::ExprKind::Mac(ref mac) if context.config.use_try_shorthand() => {\n             if let Some(subexpr) = convert_try_mac(mac, context) {\n                 subexpr\n             } else {\n@@ -427,7 +427,7 @@ fn rewrite_method_call(method_name: ast::Ident,\n         let type_list: Vec<_> =\n             try_opt!(types.iter().map(|ty| ty.rewrite(context, shape)).collect());\n \n-        let type_str = if context.config.spaces_within_angle_brackets && type_list.len() > 0 {\n+        let type_str = if context.config.spaces_within_angle_brackets() && type_list.len() > 0 {\n             format!(\"::< {} >\", type_list.join(\", \"))\n         } else {\n             format!(\"::<{}>\", type_list.join(\", \"))"}, {"sha": "22fa241677f2b92096871b56efb8f8f733e2d6cf", "filename": "src/comment.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/068b8b3b5c92c20d5347a30a221e53d9f63a8704/src%2Fcomment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/068b8b3b5c92c20d5347a30a221e53d9f63a8704/src%2Fcomment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomment.rs?ref=068b8b3b5c92c20d5347a30a221e53d9f63a8704", "patch": "@@ -38,23 +38,23 @@ pub fn rewrite_comment(orig: &str,\n                        config: &Config)\n                        -> Option<String> {\n     // If there are lines without a starting sigil, we won't format them correctly\n-    // so in that case we won't even re-align (if !config.normalize_comments) and\n+    // so in that case we won't even re-align (if !config.normalize_comments()) and\n     // we should stop now.\n     let num_bare_lines = orig.lines()\n         .map(|line| line.trim())\n         .filter(|l| !(l.starts_with('*') || l.starts_with(\"//\") || l.starts_with(\"/*\")))\n         .count();\n-    if num_bare_lines > 0 && !config.normalize_comments {\n+    if num_bare_lines > 0 && !config.normalize_comments() {\n         return Some(orig.to_owned());\n     }\n \n-    if !config.normalize_comments && !config.wrap_comments {\n+    if !config.normalize_comments() && !config.wrap_comments() {\n         return light_rewrite_comment(orig, shape.indent, config);\n     }\n \n     let (opener, closer, line_start) = if block_style {\n         (\"/* \", \" */\", \" * \")\n-    } else if !config.normalize_comments {\n+    } else if !config.normalize_comments() {\n         if orig.starts_with(\"/**\") && !orig.starts_with(\"/**/\") {\n             (\"/** \", \" **/\", \" ** \")\n         } else if orig.starts_with(\"/*!\") {\n@@ -128,7 +128,7 @@ pub fn rewrite_comment(orig: &str,\n             result.push_str(line_start);\n         }\n \n-        if config.wrap_comments && line.len() > max_chars {\n+        if config.wrap_comments() && line.len() > max_chars {\n             let rewrite = rewrite_string(line, &fmt).unwrap_or(line.to_owned());\n             result.push_str(&rewrite);\n         } else {\n@@ -579,7 +579,7 @@ pub fn recover_comment_removed(new: String,\n     if changed_comment_content(&snippet, &new) {\n         // We missed some comments\n         // Keep previous formatting if it satisfies the constrains\n-        wrap_str(snippet, context.config.max_width, shape)\n+        wrap_str(snippet, context.config.max_width(), shape)\n     } else {\n         Some(new)\n     }\n@@ -731,8 +731,8 @@ mod test {\n     #[cfg_attr(rustfmt, rustfmt_skip)]\n     fn format_comments() {\n         let mut config: ::config::Config = Default::default();\n-        config.wrap_comments = true;\n-        config.normalize_comments = true;\n+        config.set().wrap_comments(true);\n+        config.set().normalize_comments(true);\n \n         let comment = rewrite_comment(\" //test\",\n                                       true,"}, {"sha": "c64d2c0647dbda97509c8b1ada46c4eb5161f75c", "filename": "src/config.rs", "status": "modified", "additions": 101, "deletions": 12, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/068b8b3b5c92c20d5347a30a221e53d9f63a8704/src%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/068b8b3b5c92c20d5347a30a221e53d9f63a8704/src%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconfig.rs?ref=068b8b3b5c92c20d5347a30a221e53d9f63a8704", "patch": "@@ -10,6 +10,8 @@\n \n extern crate toml;\n \n+use std::cell::Cell;\n+\n use file_lines::FileLines;\n use lists::{SeparatorTactic, ListTactic};\n \n@@ -20,7 +22,7 @@ macro_rules! configuration_option_enum{\n             $( $x ),+\n         }\n \n-        impl_enum_decodable!($e, $( $x ),+);\n+        impl_enum_serialize_and_deserialize!($e, $( $x ),+);\n     }\n }\n \n@@ -210,27 +212,66 @@ impl ConfigHelpItem {\n \n macro_rules! create_config {\n     ($($i:ident: $ty:ty, $def:expr, $( $dstring:expr ),+ );+ $(;)*) => (\n-        #[derive(Deserialize, Clone)]\n+        #[derive(Clone)]\n         pub struct Config {\n-            $(pub $i: $ty),+\n+            // For each config item, we store a bool indicating whether it has\n+            // been accessed and the value.\n+            $($i: (Cell<bool>, $ty)),+\n         }\n \n         // Just like the Config struct but with each property wrapped\n         // as Option<T>. This is used to parse a rustfmt.toml that doesn't\n         // specity all properties of `Config`.\n-        // We first parse into `ParsedConfig`, then create a default `Config`\n-        // and overwrite the properties with corresponding values from `ParsedConfig`\n-        #[derive(Deserialize, Clone)]\n-        pub struct ParsedConfig {\n+        // We first parse into `PartialConfig`, then create a default `Config`\n+        // and overwrite the properties with corresponding values from `PartialConfig`.\n+        #[derive(Deserialize, Serialize, Clone)]\n+        pub struct PartialConfig {\n             $(pub $i: Option<$ty>),+\n         }\n \n+        impl PartialConfig {\n+            pub fn to_toml(&self) -> Result<String, String> {\n+                // file_lines can't be specified in TOML\n+                let mut cloned = self.clone();\n+                cloned.file_lines = None;\n+\n+                toml::to_string(&cloned)\n+                    .map_err(|e| format!(\"Could not output config: {}\", e.to_string()))\n+            }\n+        }\n+\n+        // Macro hygiene won't allow us to make `set_$i()` methods on Config\n+        // for each item, so this struct is used to give the API to set values:\n+        // `config.get().option(false)`. It's pretty ugly. Consider replacing\n+        // with `config.set_option(false)` if we ever get a stable/usable\n+        // `concat_idents!()`.\n+        pub struct ConfigSetter<'a>(&'a mut Config);\n+\n+        impl<'a> ConfigSetter<'a> {\n+            $(\n+            pub fn $i(&mut self, value: $ty) {\n+                (self.0).$i.1 = value;\n+            }\n+            )+\n+        }\n+\n         impl Config {\n \n-            fn fill_from_parsed_config(mut self, parsed: ParsedConfig) -> Config {\n+            $(\n+            pub fn $i(&self) -> $ty {\n+                self.$i.0.set(true);\n+                self.$i.1.clone()\n+            }\n+            )+\n+\n+            pub fn set<'a>(&'a mut self) -> ConfigSetter<'a> {\n+                ConfigSetter(self)\n+            }\n+\n+            fn fill_from_parsed_config(mut self, parsed: PartialConfig) -> Config {\n             $(\n                 if let Some(val) = parsed.$i {\n-                    self.$i = val;\n+                    self.$i.1 = val;\n                 }\n             )+\n                 self\n@@ -270,11 +311,32 @@ macro_rules! create_config {\n                 }\n             }\n \n-            pub fn override_value(&mut self, key: &str, val: &str) {\n+            pub fn used_options(&self) -> PartialConfig {\n+                PartialConfig {\n+                    $(\n+                        $i: if self.$i.0.get() {\n+                                Some(self.$i.1.clone())\n+                            } else {\n+                                None\n+                            },\n+                    )+\n+                }\n+            }\n+\n+            pub fn all_options(&self) -> PartialConfig {\n+                PartialConfig {\n+                    $(\n+                        $i: Some(self.$i.1.clone()),\n+                    )+\n+                }\n+            }\n+\n+            pub fn override_value(&mut self, key: &str, val: &str)\n+            {\n                 match key {\n                     $(\n                         stringify!($i) => {\n-                            self.$i = val.parse::<$ty>()\n+                            self.$i.1 = val.parse::<$ty>()\n                                 .expect(&format!(\"Failed to parse override for {} (\\\"{}\\\") as a {}\",\n                                                  stringify!($i),\n                                                  val,\n@@ -319,7 +381,7 @@ macro_rules! create_config {\n             fn default() -> Config {\n                 Config {\n                     $(\n-                        $i: $def,\n+                        $i: (Cell::new(false), $def),\n                     )+\n                 }\n             }\n@@ -424,3 +486,30 @@ create_config! {\n     condense_wildcard_suffixes: bool, false, \"Replace strings of _ wildcards by a single .. in \\\n                                               tuple patterns\"\n }\n+\n+#[cfg(test)]\n+mod test {\n+    use super::Config;\n+\n+    #[test]\n+    fn test_config_set() {\n+        let mut config = Config::default();\n+        config.set().verbose(false);\n+        assert_eq!(config.verbose(), false);\n+        config.set().verbose(true);\n+        assert_eq!(config.verbose(), true);\n+    }\n+\n+    #[test]\n+    fn test_config_used_to_toml() {\n+        let config = Config::default();\n+\n+        let verbose = config.verbose();\n+        let skip_children = config.skip_children();\n+\n+        let used_options = config.used_options();\n+        let toml = used_options.to_toml().unwrap();\n+        assert_eq!(toml,\n+                   format!(\"verbose = {}\\nskip_children = {}\\n\", verbose, skip_children));\n+    }\n+}"}, {"sha": "066c7faa43e0e1393015825195f60db40138440a", "filename": "src/expr.rs", "status": "modified", "additions": 85, "deletions": 68, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/068b8b3b5c92c20d5347a30a221e53d9f63a8704/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/068b8b3b5c92c20d5347a30a221e53d9f63a8704/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=068b8b3b5c92c20d5347a30a221e53d9f63a8704", "patch": "@@ -65,7 +65,11 @@ fn format_expr(expr: &ast::Expr,\n                 ast::LitKind::Str(_, ast::StrStyle::Cooked) => {\n                     rewrite_string_lit(context, l.span, shape)\n                 }\n-                _ => wrap_str(context.snippet(expr.span), context.config.max_width, shape),\n+                _ => {\n+                    wrap_str(context.snippet(expr.span),\n+                             context.config.max_width(),\n+                             shape)\n+                }\n             }\n         }\n         ast::ExprKind::Call(ref callee, ref args) => {\n@@ -146,7 +150,7 @@ fn format_expr(expr: &ast::Expr,\n                 None => String::new(),\n             };\n             wrap_str(format!(\"continue{}\", id_str),\n-                     context.config.max_width,\n+                     context.config.max_width(),\n                      shape)\n         }\n         ast::ExprKind::Break(ref opt_ident, ref opt_expr) => {\n@@ -158,7 +162,9 @@ fn format_expr(expr: &ast::Expr,\n             if let Some(ref expr) = *opt_expr {\n                 rewrite_unary_prefix(context, &format!(\"break{} \", id_str), &**expr, shape)\n             } else {\n-                wrap_str(format!(\"break{}\", id_str), context.config.max_width, shape)\n+                wrap_str(format!(\"break{}\", id_str),\n+                         context.config.max_width(),\n+                         shape)\n             }\n         }\n         ast::ExprKind::Closure(capture, ref fn_decl, ref body, _) => {\n@@ -171,10 +177,15 @@ fn format_expr(expr: &ast::Expr,\n         ast::ExprKind::Mac(ref mac) => {\n             // Failure to rewrite a marco should not imply failure to\n             // rewrite the expression.\n-            rewrite_macro(mac, None, context, shape, MacroPosition::Expression)\n-                .or_else(|| wrap_str(context.snippet(expr.span), context.config.max_width, shape))\n+            rewrite_macro(mac, None, context, shape, MacroPosition::Expression).or_else(|| {\n+                wrap_str(context.snippet(expr.span),\n+                         context.config.max_width(),\n+                         shape)\n+            })\n+        }\n+        ast::ExprKind::Ret(None) => {\n+            wrap_str(\"return\".to_owned(), context.config.max_width(), shape)\n         }\n-        ast::ExprKind::Ret(None) => wrap_str(\"return\".to_owned(), context.config.max_width, shape),\n         ast::ExprKind::Ret(Some(ref expr)) => {\n             rewrite_unary_prefix(context, \"return \", &**expr, shape)\n         }\n@@ -192,7 +203,7 @@ fn format_expr(expr: &ast::Expr,\n             rewrite_index(&**expr, &**index, context, shape)\n         }\n         ast::ExprKind::Repeat(ref expr, ref repeats) => {\n-            let (lbr, rbr) = if context.config.spaces_within_square_brackets {\n+            let (lbr, rbr) = if context.config.spaces_within_square_brackets() {\n                 (\"[ \", \" ]\")\n             } else {\n                 (\"[\", \"]\")\n@@ -207,37 +218,39 @@ fn format_expr(expr: &ast::Expr,\n \n             match (lhs.as_ref().map(|x| &**x), rhs.as_ref().map(|x| &**x)) {\n                 (Some(ref lhs), Some(ref rhs)) => {\n-                    let sp_delim = if context.config.spaces_around_ranges {\n+                    let sp_delim = if context.config.spaces_around_ranges() {\n                         format!(\" {} \", delim)\n                     } else {\n                         delim.into()\n                     };\n                     rewrite_pair(&**lhs, &**rhs, \"\", &sp_delim, \"\", context, shape)\n                 }\n                 (None, Some(ref rhs)) => {\n-                    let sp_delim = if context.config.spaces_around_ranges {\n+                    let sp_delim = if context.config.spaces_around_ranges() {\n                         format!(\"{} \", delim)\n                     } else {\n                         delim.into()\n                     };\n                     rewrite_unary_prefix(context, &sp_delim, &**rhs, shape)\n                 }\n                 (Some(ref lhs), None) => {\n-                    let sp_delim = if context.config.spaces_around_ranges {\n+                    let sp_delim = if context.config.spaces_around_ranges() {\n                         format!(\" {}\", delim)\n                     } else {\n                         delim.into()\n                     };\n                     rewrite_unary_suffix(context, &sp_delim, &**lhs, shape)\n                 }\n-                (None, None) => wrap_str(delim.into(), context.config.max_width, shape),\n+                (None, None) => wrap_str(delim.into(), context.config.max_width(), shape),\n             }\n         }\n         // We do not format these expressions yet, but they should still\n         // satisfy our width restrictions.\n         ast::ExprKind::InPlace(..) |\n         ast::ExprKind::InlineAsm(..) => {\n-            wrap_str(context.snippet(expr.span), context.config.max_width, shape)\n+            wrap_str(context.snippet(expr.span),\n+                     context.config.max_width(),\n+                     shape)\n         }\n     };\n     result.and_then(|res| recover_comment_removed(res, expr.span, context, shape))\n@@ -304,14 +317,14 @@ pub fn rewrite_pair<LHS, RHS>(lhs: &LHS,\n     let infix = infix.trim_right();\n     let lhs_budget = try_opt!(context\n                                   .config\n-                                  .max_width\n+                                  .max_width()\n                                   .checked_sub(shape.used_width() + prefix.len() +\n                                                infix.len()));\n-    let rhs_shape = match context.config.control_style {\n+    let rhs_shape = match context.config.control_style() {\n         Style::Default => {\n             try_opt!(shape.sub_width(suffix.len() + prefix.len())).visual_indent(prefix.len())\n         }\n-        Style::Rfc => try_opt!(shape.block_left(context.config.tab_spaces)),\n+        Style::Rfc => try_opt!(shape.block_left(context.config.tab_spaces())),\n     };\n \n     let rhs_result = try_opt!(rhs.rewrite(context, rhs_shape));\n@@ -336,14 +349,14 @@ pub fn rewrite_array<'a, I>(expr_iter: I,\n                             -> Option<String>\n     where I: Iterator<Item = &'a ast::Expr>\n {\n-    let bracket_size = if context.config.spaces_within_square_brackets {\n+    let bracket_size = if context.config.spaces_within_square_brackets() {\n         2 // \"[ \"\n     } else {\n         1 // \"[\"\n     };\n \n-    let nested_shape = match context.config.array_layout {\n-        IndentStyle::Block => shape.block().block_indent(context.config.tab_spaces),\n+    let nested_shape = match context.config.array_layout() {\n+        IndentStyle::Block => shape.block().block_indent(context.config.tab_spaces()),\n         IndentStyle::Visual => {\n             try_opt!(shape\n                          .visual_indent(bracket_size)\n@@ -362,7 +375,7 @@ pub fn rewrite_array<'a, I>(expr_iter: I,\n             .collect::<Vec<_>>();\n \n     if items.is_empty() {\n-        if context.config.spaces_within_square_brackets {\n+        if context.config.spaces_within_square_brackets() {\n             return Some(\"[ ]\".to_string());\n         } else {\n             return Some(\"[]\".to_string());\n@@ -375,12 +388,13 @@ pub fn rewrite_array<'a, I>(expr_iter: I,\n                                      .fold(Some(false),\n                                            |acc, x| acc.and_then(|y| x.map(|x| x || y))));\n \n-    let tactic = match context.config.array_layout {\n+    let tactic = match context.config.array_layout() {\n         IndentStyle::Block => {\n             // FIXME wrong shape in one-line case\n             match shape.width.checked_sub(2 * bracket_size) {\n                 Some(width) => {\n-                    let tactic = ListTactic::LimitedHorizontalVertical(context.config.array_width);\n+                    let tactic =\n+                        ListTactic::LimitedHorizontalVertical(context.config.array_width());\n                     definitive_tactic(&items, tactic, width)\n                 }\n                 None => DefinitiveListTactic::Vertical,\n@@ -389,7 +403,9 @@ pub fn rewrite_array<'a, I>(expr_iter: I,\n         IndentStyle::Visual => {\n             if has_long_item || items.iter().any(ListItem::is_multiline) {\n                 definitive_tactic(&items,\n-                                  ListTactic::LimitedHorizontalVertical(context.config.array_width),\n+                                  ListTactic::LimitedHorizontalVertical(context\n+                                                                            .config\n+                                                                            .array_width()),\n                                   nested_shape.width)\n             } else {\n                 DefinitiveListTactic::Mixed\n@@ -407,9 +423,9 @@ pub fn rewrite_array<'a, I>(expr_iter: I,\n     };\n     let list_str = try_opt!(write_list(&items, &fmt));\n \n-    let result = if context.config.array_layout == IndentStyle::Visual ||\n+    let result = if context.config.array_layout() == IndentStyle::Visual ||\n                     tactic != DefinitiveListTactic::Vertical {\n-        if context.config.spaces_within_square_brackets && list_str.len() > 0 {\n+        if context.config.spaces_within_square_brackets() && list_str.len() > 0 {\n             format!(\"[ {} ]\", list_str)\n         } else {\n             format!(\"[{}]\", list_str)\n@@ -574,7 +590,7 @@ fn rewrite_closure(capture: ast::CaptureBy,\n         // Start with visual indent, then fall back to block indent if the\n         // closure is large.\n         if let Some(block_str) = block.rewrite(&context, shape) {\n-            let block_threshold = context.config.closure_block_indent_threshold;\n+            let block_threshold = context.config.closure_block_indent_threshold();\n             if block_threshold < 0 || block_str.matches('\\n').count() <= block_threshold as usize {\n                 if let Some(block_str) = block_str.rewrite(context, shape) {\n                     return Some(format!(\"{} {}\", prefix, block_str));\n@@ -878,11 +894,11 @@ impl<'a> Rewrite for ControlFlow<'a> {\n \n         let pat_expr_string = match self.cond {\n             Some(cond) => {\n-                let mut cond_shape = match context.config.control_style {\n+                let mut cond_shape = match context.config.control_style() {\n                     Style::Default => try_opt!(constr_shape.shrink_left(add_offset)),\n                     Style::Rfc => constr_shape,\n                 };\n-                if context.config.control_brace_style != ControlBraceStyle::AlwaysNextLine {\n+                if context.config.control_brace_style() != ControlBraceStyle::AlwaysNextLine {\n                     // 2 = \" {\".len()\n                     cond_shape = try_opt!(cond_shape.sub_width(2));\n                 }\n@@ -897,15 +913,15 @@ impl<'a> Rewrite for ControlFlow<'a> {\n             None => String::new(),\n         };\n \n-        let force_newline_brace = context.config.control_style == Style::Rfc &&\n+        let force_newline_brace = context.config.control_style() == Style::Rfc &&\n                                   pat_expr_string.contains('\\n');\n \n         // Try to format if-else on single line.\n-        if self.allow_single_line && context.config.single_line_if_else_max_width > 0 {\n+        if self.allow_single_line && context.config.single_line_if_else_max_width() > 0 {\n             let trial = self.rewrite_single_line(&pat_expr_string, context, shape.width);\n \n             if trial.is_some() &&\n-               trial.as_ref().unwrap().len() <= context.config.single_line_if_else_max_width {\n+               trial.as_ref().unwrap().len() <= context.config.single_line_if_else_max_width() {\n                 return trial;\n             }\n         }\n@@ -957,7 +973,7 @@ impl<'a> Rewrite for ControlFlow<'a> {\n                             &shape.indent.block_only().to_string(context.config);\n         let block_sep = if self.cond.is_none() && between_kwd_cond_comment.is_some() {\n             \"\"\n-        } else if context.config.control_brace_style == ControlBraceStyle::AlwaysNextLine ||\n+        } else if context.config.control_brace_style() == ControlBraceStyle::AlwaysNextLine ||\n                   force_newline_brace {\n             alt_block_sep.as_str()\n         } else {\n@@ -1034,12 +1050,12 @@ impl<'a> Rewrite for ControlFlow<'a> {\n                                    else_block.span.lo);\n             let after_else_comment = extract_comment(after_else, context, shape);\n \n-            let between_sep = match context.config.control_brace_style {\n+            let between_sep = match context.config.control_brace_style() {\n                 ControlBraceStyle::AlwaysNextLine |\n                 ControlBraceStyle::ClosingNextLine => &*alt_block_sep,\n                 ControlBraceStyle::AlwaysSameLine => \" \",\n             };\n-            let after_sep = match context.config.control_brace_style {\n+            let after_sep = match context.config.control_brace_style() {\n                 ControlBraceStyle::AlwaysNextLine if last_in_chain => &*alt_block_sep,\n                 _ => \" \",\n             };\n@@ -1168,14 +1184,14 @@ fn rewrite_match(context: &RewriteContext,\n     let cond_shape = try_opt!(cond_shape.sub_width(2));\n     let cond_str = try_opt!(cond.rewrite(context, cond_shape));\n     let alt_block_sep = String::from(\"\\n\") + &shape.indent.block_only().to_string(context.config);\n-    let block_sep = match context.config.control_brace_style {\n+    let block_sep = match context.config.control_brace_style() {\n         ControlBraceStyle::AlwaysSameLine => \" \",\n         _ => alt_block_sep.as_str(),\n     };\n     let mut result = format!(\"match {}{}{{\", cond_str, block_sep);\n \n-    let arm_shape = if context.config.indent_match_arms {\n-        shape.block_indent(context.config.tab_spaces)\n+    let arm_shape = if context.config.indent_match_arms() {\n+        shape.block_indent(context.config.tab_spaces())\n     } else {\n         shape.block_indent(0)\n     };\n@@ -1239,7 +1255,7 @@ fn arm_end_pos(arm: &ast::Arm) -> BytePos {\n }\n \n fn arm_comma(config: &Config, body: &ast::Expr) -> &'static str {\n-    if config.match_block_trailing_comma {\n+    if config.match_block_trailing_comma() {\n         \",\"\n     } else if let ast::ExprKind::Block(ref block) = body.node {\n         if let ast::BlockCheckMode::Default = block.rules {\n@@ -1321,7 +1337,7 @@ impl Rewrite for ast::Arm {\n         let body = match body.node {\n             ast::ExprKind::Block(ref block) if !is_unsafe_block(block) &&\n                                                is_simple_block(block, context.codemap) &&\n-                                               context.config.wrap_match_arms => {\n+                                               context.config.wrap_match_arms() => {\n                 if let ast::StmtKind::Expr(ref expr) = block.stmts[0].node {\n                     expr\n                 } else {\n@@ -1354,9 +1370,9 @@ impl Rewrite for ast::Arm {\n             match rewrite {\n                 Some(ref body_str) if (!body_str.contains('\\n') &&\n                                        body_str.len() <= arm_shape.width) ||\n-                                      !context.config.wrap_match_arms ||\n+                                      !context.config.wrap_match_arms() ||\n                                       is_block => {\n-                    let block_sep = match context.config.control_brace_style {\n+                    let block_sep = match context.config.control_brace_style() {\n                         ControlBraceStyle::AlwaysNextLine if is_block => alt_block_sep.as_str(),\n                         _ => \" \",\n                     };\n@@ -1374,16 +1390,16 @@ impl Rewrite for ast::Arm {\n \n         // FIXME: we're doing a second rewrite of the expr; This may not be\n         // necessary.\n-        let body_shape = try_opt!(shape.sub_width(context.config.tab_spaces))\n-            .block_indent(context.config.tab_spaces);\n+        let body_shape = try_opt!(shape.sub_width(context.config.tab_spaces()))\n+            .block_indent(context.config.tab_spaces());\n         let next_line_body = try_opt!(nop_block_collapse(body.rewrite(context, body_shape),\n                                                          body_shape.width));\n         let indent_str = shape\n             .indent\n             .block_indent(context.config)\n             .to_string(context.config);\n-        let (body_prefix, body_suffix) = if context.config.wrap_match_arms {\n-            if context.config.match_block_trailing_comma {\n+        let (body_prefix, body_suffix) = if context.config.wrap_match_arms() {\n+            if context.config.match_block_trailing_comma() {\n                 (\"{\", \"},\")\n             } else {\n                 (\"{\", \"}\")\n@@ -1393,13 +1409,13 @@ impl Rewrite for ast::Arm {\n         };\n \n \n-        let block_sep = match context.config.control_brace_style {\n+        let block_sep = match context.config.control_brace_style() {\n             ControlBraceStyle::AlwaysNextLine => alt_block_sep + body_prefix + \"\\n\",\n             _ if body_prefix.is_empty() => \"\\n\".to_owned(),\n             _ => \" \".to_owned() + body_prefix + \"\\n\",\n         };\n \n-        if context.config.wrap_match_arms {\n+        if context.config.wrap_match_arms() {\n             Some(format!(\"{}{} =>{}{}{}\\n{}{}\",\n                          attr_str.trim_left(),\n                          pats_str,\n@@ -1535,11 +1551,11 @@ fn rewrite_pat_expr(context: &RewriteContext,\n fn rewrite_string_lit(context: &RewriteContext, span: Span, shape: Shape) -> Option<String> {\n     let string_lit = context.snippet(span);\n \n-    if !context.config.format_strings && !context.config.force_format_strings {\n+    if !context.config.format_strings() && !context.config.force_format_strings() {\n         return Some(string_lit);\n     }\n \n-    if !context.config.force_format_strings &&\n+    if !context.config.force_format_strings() &&\n        !string_requires_rewrite(context, span, &string_lit, shape) {\n         return Some(string_lit);\n     }\n@@ -1620,7 +1636,7 @@ fn rewrite_call_inner<R>(context: &RewriteContext,\n         .ok_or(Ordering::Greater)?;\n \n     // 4 = `(  )`, 2 = `()`\n-    let paren_overhead = if context.config.spaces_within_parens {\n+    let paren_overhead = if context.config.spaces_within_parens() {\n         4\n     } else {\n         2\n@@ -1631,8 +1647,8 @@ fn rewrite_call_inner<R>(context: &RewriteContext,\n         .checked_sub(used_width + paren_overhead)\n         .ok_or(Ordering::Greater)?;\n \n-    let nested_shape = match context.config.fn_call_style {\n-            IndentStyle::Block => shape.block().block_left(context.config.tab_spaces),\n+    let nested_shape = match context.config.fn_call_style() {\n+            IndentStyle::Block => shape.block().block_left(context.config.tab_spaces()),\n             // 1 = (\n             IndentStyle::Visual => {\n                 shape\n@@ -1648,9 +1664,9 @@ fn rewrite_call_inner<R>(context: &RewriteContext,\n     let list_str = rewrite_call_args(context, args, span, nested_shape, one_line_width)\n         .ok_or(Ordering::Less)?;\n \n-    let result = if context.config.fn_call_style == IndentStyle::Visual ||\n+    let result = if context.config.fn_call_style() == IndentStyle::Visual ||\n                     (!list_str.contains('\\n') && list_str.chars().last().unwrap_or(' ') != ',') {\n-        if context.config.spaces_within_parens && list_str.len() > 0 {\n+        if context.config.spaces_within_parens() && list_str.len() > 0 {\n             format!(\"{}( {} )\", callee_str, list_str)\n         } else {\n             format!(\"{}({})\", callee_str, list_str)\n@@ -1722,7 +1738,7 @@ fn rewrite_call_args(context: &RewriteContext,\n \n     let tactic =\n         definitive_tactic(&item_vec,\n-                          ListTactic::LimitedHorizontalVertical(context.config.fn_call_width),\n+                          ListTactic::LimitedHorizontalVertical(context.config.fn_call_width()),\n                           one_line_width);\n \n     // Replace the stub with the full overflowing last argument if the rewrite\n@@ -1741,11 +1757,11 @@ fn rewrite_call_args(context: &RewriteContext,\n         tactic: tactic,\n         separator: \",\",\n         trailing_separator: if context.inside_macro ||\n-                               context.config.fn_call_style == IndentStyle::Visual ||\n+                               context.config.fn_call_style() == IndentStyle::Visual ||\n                                arg_count <= 1 {\n             SeparatorTactic::Never\n         } else {\n-            context.config.trailing_comma\n+            context.config.trailing_comma()\n         },\n         shape: one_line_shape,\n         ends_with_newline: false,\n@@ -1756,10 +1772,10 @@ fn rewrite_call_args(context: &RewriteContext,\n         // If arguments do not fit in a single line and do not contain newline,\n         // try to put it on the next line. Try this only when we are in block mode\n         // and not rewriting macro.\n-        Some(ref s) if context.config.fn_call_style == IndentStyle::Block &&\n+        Some(ref s) if context.config.fn_call_style() == IndentStyle::Block &&\n                        !context.inside_macro &&\n                        (!s.contains('\\n') &&\n-                        (s.len() > one_line_width || s.len() > context.config.fn_call_width)) => {\n+                        (s.len() > one_line_width || s.len() > context.config.fn_call_width())) => {\n             fmt.trailing_separator = SeparatorTactic::Vertical;\n             write_list(&item_vec, &fmt)\n         }\n@@ -1775,7 +1791,7 @@ fn rewrite_paren(context: &RewriteContext, subexpr: &ast::Expr, shape: Shape) ->\n     let subexpr_str = subexpr.rewrite(context, sub_shape);\n     debug!(\"rewrite_paren, subexpr_str: `{:?}`\", subexpr_str);\n \n-    subexpr_str.map(|s| if context.config.spaces_within_parens && s.len() > 0 {\n+    subexpr_str.map(|s| if context.config.spaces_within_parens() && s.len() > 0 {\n                         format!(\"( {} )\", s)\n                     } else {\n                         format!(\"({})\", s)\n@@ -1789,7 +1805,7 @@ fn rewrite_index(expr: &ast::Expr,\n                  -> Option<String> {\n     let expr_str = try_opt!(expr.rewrite(context, shape));\n \n-    let (lbr, rbr) = if context.config.spaces_within_square_brackets {\n+    let (lbr, rbr) = if context.config.spaces_within_square_brackets() {\n         (\"[ \", \" ]\")\n     } else {\n         (\"[\", \"]\")\n@@ -1810,7 +1826,7 @@ fn rewrite_index(expr: &ast::Expr,\n     // might be reduced from max_width by something on the right.\n     let budget = try_opt!(context\n                               .config\n-                              .max_width\n+                              .max_width()\n                               .checked_sub(indent.len() + lbr.len() + rbr.len()));\n     let index_str = try_opt!(index.rewrite(context, Shape::legacy(budget, shape.indent)));\n     Some(format!(\"{}\\n{}{}{}{}\", expr_str, indent, lbr, index_str, rbr))\n@@ -1886,9 +1902,10 @@ fn rewrite_struct_lit<'a>(context: &RewriteContext,\n     let fmt = struct_lit_formatting(nested_shape, tactic, context, base.is_some());\n \n     let fields_str = try_opt!(write_list(&item_vec, &fmt));\n-    let fields_str = if context.config.struct_lit_style == IndentStyle::Block &&\n+    let fields_str = if context.config.struct_lit_style() == IndentStyle::Block &&\n                         (fields_str.contains('\\n') ||\n-                         context.config.struct_lit_multiline_style == MultilineStyle::ForceMulti ||\n+                         context.config.struct_lit_multiline_style() ==\n+                         MultilineStyle::ForceMulti ||\n                          fields_str.len() > h_shape.map(|s| s.width).unwrap_or(0)) {\n         format!(\"\\n{}{}\\n{}\",\n                 v_shape.indent.to_string(context.config),\n@@ -1901,13 +1918,13 @@ fn rewrite_struct_lit<'a>(context: &RewriteContext,\n \n     Some(format!(\"{} {{{}}}\", path_str, fields_str))\n \n-    // FIXME if context.config.struct_lit_style == Visual, but we run out\n+    // FIXME if context.config.struct_lit_style() == Visual, but we run out\n     // of space, we should fall back to BlockIndent.\n }\n \n pub fn type_annotation_separator(config: &Config) -> &str {\n-    colon_spaces(config.space_before_type_annotation,\n-                 config.space_after_type_annotation_colon)\n+    colon_spaces(config.space_before_type_annotation(),\n+                 config.space_after_type_annotation_colon())\n }\n \n fn rewrite_field(context: &RewriteContext, field: &ast::Field, shape: Shape) -> Option<String> {\n@@ -1963,7 +1980,7 @@ pub fn rewrite_tuple<'a, I>(context: &RewriteContext,\n             .next()\n             .unwrap()\n             .rewrite(context, nested_shape)\n-            .map(|s| if context.config.spaces_within_parens {\n+            .map(|s| if context.config.spaces_within_parens() {\n                      format!(\"( {}, )\", s)\n                  } else {\n                      format!(\"({},)\", s)\n@@ -1982,7 +1999,7 @@ pub fn rewrite_tuple<'a, I>(context: &RewriteContext,\n                              span.hi - BytePos(1));\n     let list_str = try_opt!(format_item_list(items, nested_shape, context.config));\n \n-    if context.config.spaces_within_parens && list_str.len() > 0 {\n+    if context.config.spaces_within_parens() && list_str.len() > 0 {\n         Some(format!(\"( {} )\", list_str))\n     } else {\n         Some(format!(\"({})\", list_str))"}, {"sha": "1e151a57838b288aca9a6856b47ff7dc14db8bca", "filename": "src/file_lines.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/068b8b3b5c92c20d5347a30a221e53d9f63a8704/src%2Ffile_lines.rs", "raw_url": "https://github.com/rust-lang/rust/raw/068b8b3b5c92c20d5347a30a221e53d9f63a8704/src%2Ffile_lines.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffile_lines.rs?ref=068b8b3b5c92c20d5347a30a221e53d9f63a8704", "patch": "@@ -216,6 +216,16 @@ impl<'de> ::serde::de::Deserialize<'de> for FileLines {\n     }\n }\n \n+// We also want to avoid attempting to serialize a FileLines to toml. The\n+// `Config` struct should ensure this impl is never reached.\n+impl ::serde::ser::Serialize for FileLines {\n+    fn serialize<S>(&self, _: S) -> Result<S::Ok, S::Error>\n+        where S: ::serde::ser::Serializer\n+    {\n+        unreachable!(\"FileLines cannot be serialized. This is a rustfmt bug.\");\n+    }\n+}\n+\n #[cfg(test)]\n mod test {\n     use super::Range;"}, {"sha": "d1486e94e39b77cb15daa7fd8d4f12c5f19482be", "filename": "src/filemap.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/068b8b3b5c92c20d5347a30a221e53d9f63a8704/src%2Ffilemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/068b8b3b5c92c20d5347a30a221e53d9f63a8704/src%2Ffilemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffilemap.rs?ref=068b8b3b5c92c20d5347a30a221e53d9f63a8704", "patch": "@@ -33,11 +33,11 @@ pub fn append_newline(s: &mut StringBuffer) {\n pub fn write_all_files<T>(file_map: &FileMap, out: &mut T, config: &Config) -> Result<(), io::Error>\n     where T: Write\n {\n-    output_header(out, config.write_mode).ok();\n+    output_header(out, config.write_mode()).ok();\n     for &(ref filename, ref text) in file_map {\n         write_file(text, filename, out, config)?;\n     }\n-    output_footer(out, config.write_mode).ok();\n+    output_footer(out, config.write_mode()).ok();\n \n     Ok(())\n }\n@@ -52,14 +52,14 @@ pub fn write_system_newlines<T>(writer: T,\n     // Buffer output, since we're writing a since char at a time.\n     let mut writer = BufWriter::new(writer);\n \n-    let style = if config.newline_style == NewlineStyle::Native {\n+    let style = if config.newline_style() == NewlineStyle::Native {\n         if cfg!(windows) {\n             NewlineStyle::Windows\n         } else {\n             NewlineStyle::Unix\n         }\n     } else {\n-        config.newline_style\n+        config.newline_style()\n     };\n \n     match style {\n@@ -107,7 +107,7 @@ pub fn write_file<T>(text: &StringBuffer,\n         Ok(make_diff(&ori, &fmt, 3))\n     }\n \n-    match config.write_mode {\n+    match config.write_mode() {\n         WriteMode::Replace => {\n             if let Ok((ori, fmt)) = source_and_formatted_text(text, filename, config) {\n                 if fmt != ori {"}, {"sha": "46ce14f47b73942904d943fb0c34d37f980815c0", "filename": "src/imports.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/068b8b3b5c92c20d5347a30a221e53d9f63a8704/src%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/068b8b3b5c92c20d5347a30a221e53d9f63a8704/src%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fimports.rs?ref=068b8b3b5c92c20d5347a30a221e53d9f63a8704", "patch": "@@ -238,7 +238,7 @@ impl<'a> FmtVisitor<'a> {\n         offset.alignment += vis.len() + \"use \".len();\n         // 1 = \";\"\n         match vp.rewrite(&self.get_context(),\n-                         Shape::legacy(self.config.max_width - offset.width() - 1, offset)) {\n+                         Shape::legacy(self.config.max_width() - offset.width() - 1, offset)) {\n             Some(ref s) if s.is_empty() => {\n                 // Format up to last newline\n                 let prev_span = codemap::mk_sp(self.last_pos, source!(self, span).lo);\n@@ -339,7 +339,7 @@ pub fn rewrite_use_list(shape: Shape,\n     let has_self = move_self_to_front(&mut items);\n     let first_index = if has_self { 0 } else { 1 };\n \n-    if context.config.reorder_imported_names {\n+    if context.config.reorder_imported_names() {\n         items[1..].sort_by(|a, b| a.item.cmp(&b.item));\n     }\n "}, {"sha": "953aecb330507675cfe4a1175a9e5d85ee7f7ddc", "filename": "src/items.rs", "status": "modified", "additions": 119, "deletions": 115, "changes": 234, "blob_url": "https://github.com/rust-lang/rust/blob/068b8b3b5c92c20d5347a30a221e53d9f63a8704/src%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/068b8b3b5c92c20d5347a30a221e53d9f63a8704/src%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems.rs?ref=068b8b3b5c92c20d5347a30a221e53d9f63a8704", "patch": "@@ -94,7 +94,7 @@ struct Item<'a> {\n \n impl<'a> Item<'a> {\n     fn from_foreign_mod(fm: &'a ast::ForeignMod, span: Span, config: &Config) -> Item<'a> {\n-        let abi = if fm.abi == abi::Abi::C && !config.force_explicit_abi {\n+        let abi = if fm.abi == abi::Abi::C && !config.force_explicit_abi() {\n             \"extern\".into()\n         } else {\n             format!(\"extern {}\", fm.abi)\n@@ -243,7 +243,7 @@ impl<'a> FmtVisitor<'a> {\n \n         let block_snippet = self.snippet(codemap::mk_sp(block.span.lo, block.span.hi));\n         let has_body = !block_snippet[1..block_snippet.len() - 1].trim().is_empty() ||\n-                       !context.config.fn_empty_single_line;\n+                       !context.config.fn_empty_single_line();\n \n         let (mut result, force_newline_brace) = try_opt!(rewrite_fn_base(&context,\n                                                                          indent,\n@@ -260,7 +260,7 @@ impl<'a> FmtVisitor<'a> {\n                                                                          has_body,\n                                                                          true));\n \n-        if self.config.fn_brace_style != BraceStyle::AlwaysNextLine && !result.contains('\\n') {\n+        if self.config.fn_brace_style() != BraceStyle::AlwaysNextLine && !result.contains('\\n') {\n             newline_brace = false;\n         } else if force_newline_brace {\n             newline_brace = true;\n@@ -319,12 +319,12 @@ impl<'a> FmtVisitor<'a> {\n \n         let codemap = self.get_context().codemap;\n \n-        if self.config.fn_empty_single_line && is_empty_block(block, codemap) &&\n-           self.block_indent.width() + fn_str.len() + 2 <= self.config.max_width {\n+        if self.config.fn_empty_single_line() && is_empty_block(block, codemap) &&\n+           self.block_indent.width() + fn_str.len() + 2 <= self.config.max_width() {\n             return Some(format!(\"{}{{}}\", fn_str));\n         }\n \n-        if self.config.fn_single_line && is_simple_block_stmt(block, codemap) {\n+        if self.config.fn_single_line() && is_simple_block_stmt(block, codemap) {\n             let rewrite = {\n                 if let Some(ref stmt) = block.stmts.first() {\n                     match stmt_expr(stmt) {\n@@ -348,7 +348,7 @@ impl<'a> FmtVisitor<'a> {\n \n             if let Some(res) = rewrite {\n                 let width = self.block_indent.width() + fn_str.len() + res.len() + 4;\n-                if !res.contains('\\n') && width <= self.config.max_width {\n+                if !res.contains('\\n') && width <= self.config.max_width() {\n                     return Some(format!(\"{}{{ {} }}\", fn_str, res));\n                 }\n             }\n@@ -372,7 +372,7 @@ impl<'a> FmtVisitor<'a> {\n                                            generics,\n                                            \"{\",\n                                            \"{\",\n-                                           self.config.item_brace_style,\n+                                           self.config.item_brace_style(),\n                                            enum_def.variants.is_empty(),\n                                            self.block_indent,\n                                            mk_sp(span.lo, body_start))\n@@ -436,7 +436,7 @@ impl<'a> FmtVisitor<'a> {\n         let fmt = ListFormatting {\n             tactic: DefinitiveListTactic::Vertical,\n             separator: \",\",\n-            trailing_separator: self.config.trailing_comma,\n+            trailing_separator: self.config.trailing_comma(),\n             shape: shape,\n             ends_with_newline: true,\n             config: self.config,\n@@ -477,7 +477,7 @@ impl<'a> FmtVisitor<'a> {\n                               None,\n                               field.span,\n                               indent,\n-                              Some(self.config.struct_variant_width))\n+                              Some(self.config.struct_variant_width()))\n             }\n             ast::VariantData::Unit(..) => {\n                 let tag = if let Some(ref expr) = field.node.disr_expr {\n@@ -487,7 +487,7 @@ impl<'a> FmtVisitor<'a> {\n                 };\n \n                 wrap_str(tag,\n-                         self.config.max_width,\n+                         self.config.max_width(),\n                          Shape::indented(indent, self.config))\n             }\n         };\n@@ -517,14 +517,14 @@ pub fn format_impl(context: &RewriteContext, item: &ast::Item, offset: Indent) -\n \n         let where_budget = try_opt!(context\n                                         .config\n-                                        .max_width\n+                                        .max_width()\n                                         .checked_sub(last_line_width(&result)));\n         let where_clause_str = try_opt!(rewrite_where_clause(context,\n                                                              &generics.where_clause,\n-                                                             context.config.item_brace_style,\n+                                                             context.config.item_brace_style(),\n                                                              Shape::legacy(where_budget,\n                                                                            offset.block_only()),\n-                                                             context.config.where_density,\n+                                                             context.config.where_density(),\n                                                              \"{\",\n                                                              false,\n                                                              last_line_width(&ref_and_type) == 1,\n@@ -543,13 +543,13 @@ pub fn format_impl(context: &RewriteContext, item: &ast::Item, offset: Indent) -\n \n         if !where_clause_str.is_empty() && !where_clause_str.contains('\\n') {\n             result.push('\\n');\n-            let width = offset.block_indent + context.config.tab_spaces - 1;\n+            let width = offset.block_indent + context.config.tab_spaces() - 1;\n             let where_indent = Indent::new(0, width);\n             result.push_str(&where_indent.to_string(context.config));\n         }\n         result.push_str(&where_clause_str);\n \n-        match context.config.item_brace_style {\n+        match context.config.item_brace_style() {\n             BraceStyle::AlwaysNextLine => {\n                 result.push('\\n');\n                 result.push_str(&offset.to_string(context.config));\n@@ -612,8 +612,8 @@ fn is_impl_single_line(context: &RewriteContext,\n     let snippet = context.snippet(item.span);\n     let open_pos = try_opt!(snippet.find_uncommented(\"{\")) + 1;\n \n-    Some(context.config.impl_empty_single_line && items.is_empty() &&\n-         result.len() + where_clause_str.len() <= context.config.max_width &&\n+    Some(context.config.impl_empty_single_line() && items.is_empty() &&\n+         result.len() + where_clause_str.len() <= context.config.max_width() &&\n          !contains_comment(&snippet[open_pos..]))\n }\n \n@@ -648,15 +648,15 @@ fn format_impl_ref_and_type(context: &RewriteContext,\n                 result.push_str(\" \");\n             }\n             let used_space = last_line_width(&result);\n-            let budget = try_opt!(context.config.max_width.checked_sub(used_space));\n+            let budget = try_opt!(context.config.max_width().checked_sub(used_space));\n             let indent = offset + used_space;\n             result.push_str(&*try_opt!(trait_ref.rewrite(context, Shape::legacy(budget, indent))));\n \n             if split_at_for {\n                 result.push('\\n');\n \n                 // Add indentation of one additional tab.\n-                let width = offset.block_indent + context.config.tab_spaces;\n+                let width = offset.block_indent + context.config.tab_spaces();\n                 let for_indent = Indent::new(0, width);\n                 result.push_str(&for_indent.to_string(context.config));\n \n@@ -670,15 +670,15 @@ fn format_impl_ref_and_type(context: &RewriteContext,\n         if generics.where_clause.predicates.is_empty() {\n             // If there is no where clause adapt budget for type formatting to take space and curly\n             // brace into account.\n-            match context.config.item_brace_style {\n+            match context.config.item_brace_style() {\n                 BraceStyle::AlwaysNextLine => {}\n                 BraceStyle::PreferSameLine => used_space += 2,\n                 BraceStyle::SameLineWhere => used_space += 2,\n             }\n         }\n \n         // 1 = space before the type.\n-        let budget = try_opt!(context.config.max_width.checked_sub(used_space + 1));\n+        let budget = try_opt!(context.config.max_width().checked_sub(used_space + 1));\n         let indent = offset + result.len() + 1;\n         let self_ty_str = self_ty.rewrite(context, Shape::legacy(budget, indent));\n         if let Some(self_ty_str) = self_ty_str {\n@@ -756,11 +756,11 @@ pub fn format_trait(context: &RewriteContext, item: &ast::Item, offset: Indent)\n         let trait_bound_str =\n             try_opt!(rewrite_trait_bounds(context,\n                                           type_param_bounds,\n-                                          Shape::legacy(context.config.max_width, offset)));\n+                                          Shape::legacy(context.config.max_width(), offset)));\n         // If the trait, generics, and trait bound cannot fit on the same line,\n         // put the trait bounds on an indented new line\n         if offset.width() + last_line_width(&result) + trait_bound_str.len() >\n-           context.config.comment_width {\n+           context.config.comment_width() {\n             result.push('\\n');\n             let trait_indent = offset.block_only().block_indent(context.config);\n             result.push_str(&trait_indent.to_string(context.config));\n@@ -770,10 +770,11 @@ pub fn format_trait(context: &RewriteContext, item: &ast::Item, offset: Indent)\n         let has_body = !trait_items.is_empty();\n \n         let where_density =\n-            if (context.config.where_density == Density::Compressed &&\n-                (!result.contains('\\n') || context.config.fn_args_layout == IndentStyle::Block)) ||\n-               (context.config.fn_args_layout == IndentStyle::Block && result.is_empty()) ||\n-               (context.config.where_density == Density::CompressedIfEmpty && !has_body &&\n+            if (context.config.where_density() == Density::Compressed &&\n+                (!result.contains('\\n') ||\n+                 context.config.fn_args_layout() == IndentStyle::Block)) ||\n+               (context.config.fn_args_layout() == IndentStyle::Block && result.is_empty()) ||\n+               (context.config.where_density() == Density::CompressedIfEmpty && !has_body &&\n                 !result.contains('\\n')) {\n                 Density::Compressed\n             } else {\n@@ -782,11 +783,11 @@ pub fn format_trait(context: &RewriteContext, item: &ast::Item, offset: Indent)\n \n         let where_budget = try_opt!(context\n                                         .config\n-                                        .max_width\n+                                        .max_width()\n                                         .checked_sub(last_line_width(&result)));\n         let where_clause_str = try_opt!(rewrite_where_clause(context,\n                                                              &generics.where_clause,\n-                                                             context.config.item_brace_style,\n+                                                             context.config.item_brace_style(),\n                                                              Shape::legacy(where_budget,\n                                                                            offset.block_only()),\n                                                              where_density,\n@@ -799,15 +800,15 @@ pub fn format_trait(context: &RewriteContext, item: &ast::Item, offset: Indent)\n         // put the where clause on a new line\n         if !where_clause_str.contains('\\n') &&\n            last_line_width(&result) + where_clause_str.len() + offset.width() >\n-           context.config.comment_width {\n+           context.config.comment_width() {\n             result.push('\\n');\n-            let width = offset.block_indent + context.config.tab_spaces - 1;\n+            let width = offset.block_indent + context.config.tab_spaces() - 1;\n             let where_indent = Indent::new(0, width);\n             result.push_str(&where_indent.to_string(context.config));\n         }\n         result.push_str(&where_clause_str);\n \n-        match context.config.item_brace_style {\n+        match context.config.item_brace_style() {\n             BraceStyle::AlwaysNextLine => {\n                 result.push('\\n');\n                 result.push_str(&offset.to_string(context.config));\n@@ -885,13 +886,14 @@ fn format_struct_struct(context: &RewriteContext,\n                                      g,\n                                      \"{\",\n                                      \"{\",\n-                                     context.config.item_brace_style,\n+                                     context.config.item_brace_style(),\n                                      fields.is_empty(),\n                                      offset,\n                                      mk_sp(span.lo, body_lo)))\n         }\n         None => {\n-            if context.config.item_brace_style == BraceStyle::AlwaysNextLine && !fields.is_empty() {\n+            if context.config.item_brace_style() == BraceStyle::AlwaysNextLine &&\n+               !fields.is_empty() {\n                 format!(\"\\n{}{{\", offset.block_only().to_string(context.config))\n             } else {\n                 \" {\".to_owned()\n@@ -920,7 +922,7 @@ fn format_struct_struct(context: &RewriteContext,\n     // 1 = \",\"\n     let item_budget = try_opt!(context\n                                    .config\n-                                   .max_width\n+                                   .max_width()\n                                    .checked_sub(item_indent.width() + 1));\n \n     let items =\n@@ -941,7 +943,7 @@ fn format_struct_struct(context: &RewriteContext,\n                      span.hi)\n                 .collect::<Vec<_>>();\n     // 1 = ,\n-    let budget = context.config.max_width - offset.width() + context.config.tab_spaces - 1;\n+    let budget = context.config.max_width() - offset.width() + context.config.tab_spaces() - 1;\n \n     let tactic = match one_line_width {\n         Some(w) => definitive_tactic(&items, ListTactic::LimitedHorizontalVertical(w), budget),\n@@ -951,7 +953,7 @@ fn format_struct_struct(context: &RewriteContext,\n     let fmt = ListFormatting {\n         tactic: tactic,\n         separator: \",\",\n-        trailing_separator: context.config.trailing_comma,\n+        trailing_separator: context.config.trailing_comma(),\n         shape: Shape::legacy(budget, item_indent),\n         ends_with_newline: true,\n         config: context.config,\n@@ -1000,11 +1002,11 @@ fn format_tuple_struct(context: &RewriteContext,\n \n             let where_budget = try_opt!(context\n                                             .config\n-                                            .max_width\n+                                            .max_width()\n                                             .checked_sub(last_line_width(&result)));\n             try_opt!(rewrite_where_clause(context,\n                                           &generics.where_clause,\n-                                          context.config.item_brace_style,\n+                                          context.config.item_brace_style(),\n                                           Shape::legacy(where_budget, offset.block_only()),\n                                           Density::Compressed,\n                                           \";\",\n@@ -1029,7 +1031,7 @@ fn format_tuple_struct(context: &RewriteContext,\n         }\n         result.push(')');\n     } else {\n-        let (tactic, item_indent) = match context.config.fn_args_layout {\n+        let (tactic, item_indent) = match context.config.fn_args_layout() {\n             IndentStyle::Visual => {\n                 // 1 = `(`\n                 (ListTactic::HorizontalVertical, offset.block_only() + result.len() + 1)\n@@ -1041,7 +1043,7 @@ fn format_tuple_struct(context: &RewriteContext,\n         // 3 = `();`\n         let item_budget = try_opt!(context\n                                        .config\n-                                       .max_width\n+                                       .max_width()\n                                        .checked_sub(item_indent.width() + 3));\n \n         let items =\n@@ -1062,7 +1064,7 @@ fn format_tuple_struct(context: &RewriteContext,\n                          span.hi);\n         let body_budget = try_opt!(context\n                                        .config\n-                                       .max_width\n+                                       .max_width()\n                                        .checked_sub(offset.block_only().width() + result.len() +\n                                                     3));\n         let body = try_opt!(list_helper(items,\n@@ -1071,15 +1073,15 @@ fn format_tuple_struct(context: &RewriteContext,\n                                         context.config,\n                                         tactic));\n \n-        if context.config.fn_args_layout == IndentStyle::Visual || !body.contains('\\n') {\n+        if context.config.fn_args_layout() == IndentStyle::Visual || !body.contains('\\n') {\n             result.push('(');\n-            if context.config.spaces_within_parens && body.len() > 0 {\n+            if context.config.spaces_within_parens() && body.len() > 0 {\n                 result.push(' ');\n             }\n \n             result.push_str(&body);\n \n-            if context.config.spaces_within_parens && body.len() > 0 {\n+            if context.config.spaces_within_parens() && body.len() > 0 {\n                 result.push(' ');\n             }\n             result.push(')');\n@@ -1096,11 +1098,11 @@ fn format_tuple_struct(context: &RewriteContext,\n     if !where_clause_str.is_empty() && !where_clause_str.contains('\\n') &&\n        (result.contains('\\n') ||\n         offset.block_indent + result.len() + where_clause_str.len() + 1 >\n-        context.config.max_width) {\n+        context.config.max_width()) {\n         // We need to put the where clause on a new line, but we didn't\n         // know that earlier, so the where clause will not be indented properly.\n         result.push('\\n');\n-        result.push_str(&(offset.block_only() + (context.config.tab_spaces - 1))\n+        result.push_str(&(offset.block_only() + (context.config.tab_spaces() - 1))\n                             .to_string(context.config));\n     }\n     result.push_str(&where_clause_str);\n@@ -1132,13 +1134,13 @@ pub fn rewrite_type_alias(context: &RewriteContext,\n \n     let where_budget = try_opt!(context\n                                     .config\n-                                    .max_width\n+                                    .max_width()\n                                     .checked_sub(last_line_width(&result)));\n     let where_clause_str = try_opt!(rewrite_where_clause(context,\n                                                          &generics.where_clause,\n-                                                         context.config.item_brace_style,\n+                                                         context.config.item_brace_style(),\n                                                          Shape::legacy(where_budget, indent),\n-                                                         context.config.where_density,\n+                                                         context.config.where_density(),\n                                                          \"=\",\n                                                          true,\n                                                          true,\n@@ -1151,7 +1153,7 @@ pub fn rewrite_type_alias(context: &RewriteContext,\n     // In that case the budget is set to 0 which will make ty.rewrite retry on a new line\n     let budget = context\n         .config\n-        .max_width\n+        .max_width()\n         .checked_sub(indent.width() + line_width + \";\".len())\n         .unwrap_or(0);\n     let type_indent = indent + line_width;\n@@ -1167,7 +1169,7 @@ pub fn rewrite_type_alias(context: &RewriteContext,\n         result.push_str(&type_indent.to_string(context.config));\n         let budget = try_opt!(context\n                                   .config\n-                                  .max_width\n+                                  .max_width()\n                                   .checked_sub(type_indent.width() + \";\".len()));\n         ty.rewrite(context, Shape::legacy(budget, type_indent))\n     }));\n@@ -1177,12 +1179,12 @@ pub fn rewrite_type_alias(context: &RewriteContext,\n }\n \n fn type_annotation_spacing(config: &Config) -> (&str, &str) {\n-    (if config.space_before_type_annotation {\n+    (if config.space_before_type_annotation() {\n          \" \"\n      } else {\n          \"\"\n      },\n-     if config.space_after_type_annotation_colon {\n+     if config.space_after_type_annotation_colon() {\n          \" \"\n      } else {\n          \"\"\n@@ -1193,7 +1195,7 @@ impl Rewrite for ast::StructField {\n     fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n         if contains_skip(&self.attrs) {\n             let span = context.snippet(mk_sp(self.attrs[0].span.lo, self.span.hi));\n-            return wrap_str(span, context.config.max_width, shape);\n+            return wrap_str(span, context.config.max_width(), shape);\n         }\n \n         let name = self.ident;\n@@ -1229,7 +1231,7 @@ impl Rewrite for ast::StructField {\n                 match new_ty {\n                     Some(ref new_ty) if !new_ty.contains('\\n') &&\n                                         new_ty.len() + type_offset.width() <=\n-                                        context.config.max_width => {\n+                                        context.config.max_width() => {\n                         Some(format!(\"{}\\n{}{}\",\n                                      result,\n                                      type_offset.to_string(&context.config),\n@@ -1279,15 +1281,16 @@ pub fn rewrite_static(prefix: &str,\n                          type_annotation_spacing.1);\n     // 2 = \" =\".len()\n     let ty_str = try_opt!(ty.rewrite(context,\n-                                     Shape::legacy(context.config.max_width - offset.block_indent -\n+                                     Shape::legacy(context.config.max_width() -\n+                                                   offset.block_indent -\n                                                    prefix.len() -\n                                                    2,\n                                                    offset.block_only())));\n \n     if let Some(expr) = expr_opt {\n         let lhs = format!(\"{}{} =\", prefix, ty_str);\n         // 1 = ;\n-        let remaining_width = context.config.max_width - offset.block_indent - 1;\n+        let remaining_width = context.config.max_width() - offset.block_indent - 1;\n         rewrite_assign_rhs(context,\n                            lhs,\n                            expr,\n@@ -1307,31 +1310,32 @@ pub fn rewrite_associated_type(ident: ast::Ident,\n                                -> Option<String> {\n     let prefix = format!(\"type {}\", ident);\n \n-    let type_bounds_str = if let Some(ty_param_bounds) = ty_param_bounds_opt {\n-        let joiner = match context.config.type_punctuation_density {\n-            TypeDensity::Compressed => \"+\",\n-            TypeDensity::Wide => \" + \",\n-        };\n-        let bounds: &[_] = ty_param_bounds;\n-        let bound_str = try_opt!(bounds\n-                                     .iter()\n-                                     .map(|ty_bound| {\n-            ty_bound.rewrite(context, Shape::legacy(context.config.max_width, indent))\n-        })\n-                                     .intersperse(Some(joiner.to_string()))\n-                                     .collect::<Option<String>>());\n-        if bounds.len() > 0 {\n-            format!(\": {}\", bound_str)\n+    let type_bounds_str =\n+        if let Some(ty_param_bounds) = ty_param_bounds_opt {\n+            let joiner = match context.config.type_punctuation_density() {\n+                TypeDensity::Compressed => \"+\",\n+                TypeDensity::Wide => \" + \",\n+            };\n+            let bounds: &[_] = ty_param_bounds;\n+            let bound_str = try_opt!(bounds\n+                                         .iter()\n+                                         .map(|ty_bound| {\n+                ty_bound.rewrite(context, Shape::legacy(context.config.max_width(), indent))\n+            })\n+                                         .intersperse(Some(joiner.to_string()))\n+                                         .collect::<Option<String>>());\n+            if bounds.len() > 0 {\n+                format!(\": {}\", bound_str)\n+            } else {\n+                String::new()\n+            }\n         } else {\n             String::new()\n-        }\n-    } else {\n-        String::new()\n-    };\n+        };\n \n     if let Some(ty) = ty_opt {\n         let ty_str = try_opt!(ty.rewrite(context,\n-                                         Shape::legacy(context.config.max_width -\n+                                         Shape::legacy(context.config.max_width() -\n                                                        indent.block_indent -\n                                                        prefix.len() -\n                                                        2,\n@@ -1378,11 +1382,11 @@ impl Rewrite for ast::Arg {\n                                                        Shape::legacy(shape.width, shape.indent)));\n \n             if self.ty.node != ast::TyKind::Infer {\n-                if context.config.space_before_type_annotation {\n+                if context.config.space_before_type_annotation() {\n                     result.push_str(\" \");\n                 }\n                 result.push_str(\":\");\n-                if context.config.space_after_type_annotation_colon {\n+                if context.config.space_after_type_annotation_colon() {\n                     result.push_str(\" \");\n                 }\n                 let max_width = try_opt!(shape.width.checked_sub(result.len()));\n@@ -1534,7 +1538,7 @@ fn rewrite_fn_base(context: &RewriteContext,\n     result.push_str(::utils::format_unsafety(unsafety));\n \n     if abi != abi::Abi::Rust {\n-        result.push_str(&::utils::format_abi(abi, context.config.force_explicit_abi));\n+        result.push_str(&::utils::format_abi(abi, context.config.force_explicit_abi()));\n     }\n \n     // fn foo\n@@ -1562,9 +1566,9 @@ fn rewrite_fn_base(context: &RewriteContext,\n     let (mut one_line_budget, mut multi_line_budget, mut arg_indent) =\n         try_opt!(compute_budgets_for_args(context, &result, indent, ret_str_len, newline_brace));\n \n-    if context.config.fn_args_layout == IndentStyle::Block {\n+    if context.config.fn_args_layout() == IndentStyle::Block {\n         arg_indent = indent.block_indent(context.config);\n-        multi_line_budget = context.config.max_width - arg_indent.width();\n+        multi_line_budget = context.config.max_width() - arg_indent.width();\n     }\n \n     debug!(\"rewrite_fn_base: one_line_budget: {}, multi_line_budget: {}, arg_indent: {:?}\",\n@@ -1576,12 +1580,12 @@ fn rewrite_fn_base(context: &RewriteContext,\n     if one_line_budget == 0 {\n         if snuggle_angle_bracket {\n             result.push_str(\"(\");\n-        } else if context.config.fn_args_paren_newline {\n+        } else if context.config.fn_args_paren_newline() {\n             result.push('\\n');\n             result.push_str(&arg_indent.to_string(context.config));\n             arg_indent = arg_indent + 1; // extra space for `(`\n             result.push('(');\n-            if context.config.spaces_within_parens && fd.inputs.len() > 0 {\n+            if context.config.spaces_within_parens() && fd.inputs.len() > 0 {\n                 result.push(' ')\n             }\n         } else {\n@@ -1590,7 +1594,7 @@ fn rewrite_fn_base(context: &RewriteContext,\n         }\n     } else {\n         result.push('(');\n-        if context.config.spaces_within_parens && fd.inputs.len() > 0 {\n+        if context.config.spaces_within_parens() && fd.inputs.len() > 0 {\n             result.push(' ')\n         }\n     }\n@@ -1620,7 +1624,7 @@ fn rewrite_fn_base(context: &RewriteContext,\n     let multi_line_arg_str = arg_str.contains('\\n') ||\n                              arg_str.chars().last().map_or(false, |c| c == ',');\n \n-    let put_args_in_block = match context.config.fn_args_layout {\n+    let put_args_in_block = match context.config.fn_args_layout() {\n         IndentStyle::Block => multi_line_arg_str || generics_str.contains('\\n'),\n         _ => false,\n     } && !fd.inputs.is_empty();\n@@ -1635,15 +1639,15 @@ fn rewrite_fn_base(context: &RewriteContext,\n         result.push(')');\n     } else {\n         result.push_str(&arg_str);\n-        if context.config.spaces_within_parens && fd.inputs.len() > 0 {\n+        if context.config.spaces_within_parens() && fd.inputs.len() > 0 {\n             result.push(' ')\n         }\n         result.push(')');\n     }\n \n     // Return type.\n     if !ret_str.is_empty() {\n-        let ret_should_indent = match context.config.fn_args_layout {\n+        let ret_should_indent = match context.config.fn_args_layout() {\n             // If our args are block layout then we surely must have space.\n             IndentStyle::Block if put_args_in_block => false,\n             _ => {\n@@ -1659,13 +1663,13 @@ fn rewrite_fn_base(context: &RewriteContext,\n                     sig_length += 2;\n                 }\n \n-                let overlong_sig = sig_length > context.config.max_width;\n+                let overlong_sig = sig_length > context.config.max_width();\n \n                 result.contains('\\n') || multi_line_ret_str || overlong_sig\n             }\n         };\n         let ret_indent = if ret_should_indent {\n-            let indent = match context.config.fn_return_indent {\n+            let indent = match context.config.fn_return_indent() {\n                 ReturnIndent::WithWhereClause => indent + 4,\n                 // Aligning with non-existent args looks silly.\n                 _ if arg_str.is_empty() => {\n@@ -1713,7 +1717,7 @@ fn rewrite_fn_base(context: &RewriteContext,\n         }\n     }\n \n-    let should_compress_where = match context.config.where_density {\n+    let should_compress_where = match context.config.where_density() {\n         Density::Compressed => !result.contains('\\n') || put_args_in_block,\n         Density::CompressedIfEmpty => !has_body && !result.contains('\\n'),\n         _ => false,\n@@ -1722,20 +1726,20 @@ fn rewrite_fn_base(context: &RewriteContext,\n     if where_clause.predicates.len() == 1 && should_compress_where {\n         let budget = try_opt!(context\n                                   .config\n-                                  .max_width\n+                                  .max_width()\n                                   .checked_sub(last_line_width(&result)));\n         if let Some(where_clause_str) =\n             rewrite_where_clause(context,\n                                  where_clause,\n-                                 context.config.fn_brace_style,\n+                                 context.config.fn_brace_style(),\n                                  Shape::legacy(budget, indent),\n                                  Density::Compressed,\n                                  \"{\",\n                                  !has_braces,\n                                  put_args_in_block && ret_str.is_empty(),\n                                  Some(span.hi)) {\n             if !where_clause_str.contains('\\n') {\n-                if last_line_width(&result) + where_clause_str.len() > context.config.max_width {\n+                if last_line_width(&result) + where_clause_str.len() > context.config.max_width() {\n                     result.push('\\n');\n                 }\n \n@@ -1748,7 +1752,7 @@ fn rewrite_fn_base(context: &RewriteContext,\n \n     let where_clause_str = try_opt!(rewrite_where_clause(context,\n                                                          where_clause,\n-                                                         context.config.fn_brace_style,\n+                                                         context.config.fn_brace_style(),\n                                                          Shape::indented(indent, context.config),\n                                                          Density::Tall,\n                                                          \"{\",\n@@ -1858,7 +1862,7 @@ fn rewrite_args(context: &RewriteContext,\n         item.item = Some(arg);\n     }\n \n-    let (indent, trailing_comma, end_with_newline) = match context.config.fn_args_layout {\n+    let (indent, trailing_comma, end_with_newline) = match context.config.fn_args_layout() {\n         IndentStyle::Block if fits_in_one_line => {\n             (indent.block_indent(context.config), SeparatorTactic::Never, true)\n         }\n@@ -1869,7 +1873,7 @@ fn rewrite_args(context: &RewriteContext,\n     };\n \n     let tactic = definitive_tactic(&arg_items,\n-                                   context.config.fn_args_density.to_list_tactic(),\n+                                   context.config.fn_args_density().to_list_tactic(),\n                                    one_line_budget);\n     let budget = match tactic {\n         DefinitiveListTactic::Horizontal => one_line_budget,\n@@ -1918,15 +1922,15 @@ fn compute_budgets_for_args(context: &RewriteContext,\n         }\n         let one_line_budget = context\n             .config\n-            .max_width\n+            .max_width()\n             .checked_sub(used_space)\n             .unwrap_or(0);\n \n         if one_line_budget > 0 {\n             // 4 = \"() {\".len()\n             let multi_line_budget = try_opt!(context\n                                                  .config\n-                                                 .max_width\n+                                                 .max_width()\n                                                  .checked_sub(indent.width() + result.len() +\n                                                               4));\n \n@@ -1937,7 +1941,7 @@ fn compute_budgets_for_args(context: &RewriteContext,\n     // Didn't work. we must force vertical layout and put args on a newline.\n     let new_indent = indent.block_indent(context.config);\n     let used_space = new_indent.width() + 4; // Account for `(` and `)` and possibly ` {`.\n-    let max_space = context.config.max_width;\n+    let max_space = context.config.max_width();\n     if used_space <= max_space {\n         Some((0, max_space - used_space, new_indent))\n     } else {\n@@ -1947,7 +1951,7 @@ fn compute_budgets_for_args(context: &RewriteContext,\n }\n \n fn newline_for_brace(config: &Config, where_clause: &ast::WhereClause) -> bool {\n-    match config.fn_brace_style {\n+    match config.fn_brace_style() {\n         BraceStyle::AlwaysNextLine => true,\n         BraceStyle::SameLineWhere if !where_clause.predicates.is_empty() => true,\n         _ => false,\n@@ -1967,7 +1971,7 @@ fn rewrite_generics(context: &RewriteContext,\n         return Some(String::new());\n     }\n \n-    let offset = match context.config.generics_indent {\n+    let offset = match context.config.generics_indent() {\n         IndentStyle::Block => shape.indent.block_only().block_indent(context.config),\n         // 1 = <\n         IndentStyle::Visual => shape.indent + 1,\n@@ -2006,13 +2010,13 @@ fn rewrite_generics(context: &RewriteContext,\n     let list_str =\n         try_opt!(format_item_list(items, Shape::legacy(h_budget, offset), context.config));\n \n-    let result = if context.config.generics_indent != IndentStyle::Visual &&\n+    let result = if context.config.generics_indent() != IndentStyle::Visual &&\n                     list_str.contains('\\n') {\n         format!(\"<\\n{}{}\\n{}>\",\n                 offset.to_string(context.config),\n                 list_str,\n                 shape.indent.block_only().to_string(context.config))\n-    } else if context.config.spaces_within_angle_brackets {\n+    } else if context.config.spaces_within_angle_brackets() {\n         format!(\"< {} >\", list_str)\n     } else {\n         format!(\"<{}>\", list_str)\n@@ -2029,7 +2033,7 @@ fn rewrite_trait_bounds(context: &RewriteContext,\n     if bounds.is_empty() {\n         return Some(String::new());\n     }\n-    let joiner = match context.config.type_punctuation_density {\n+    let joiner = match context.config.type_punctuation_density() {\n         TypeDensity::Compressed => \"+\",\n         TypeDensity::Wide => \" + \",\n     };\n@@ -2074,7 +2078,7 @@ fn rewrite_where_clause_rfc_style(context: &RewriteContext,\n         \"\\n\".to_owned() + &block_shape.indent.to_string(context.config)\n     };\n \n-    let clause_shape = block_shape.block_indent(context.config.tab_spaces);\n+    let clause_shape = block_shape.block_indent(context.config.tab_spaces());\n     // each clause on one line, trailing comma (except if suppress_comma)\n     let span_start = span_for_where_pred(&where_clause.predicates[0]).lo;\n     // If we don't have the start of the next span, then use the end of the\n@@ -2126,7 +2130,7 @@ fn rewrite_where_clause(context: &RewriteContext,\n         return Some(String::new());\n     }\n \n-    if context.config.where_style == Style::Rfc {\n+    if context.config.where_style() == Style::Rfc {\n         return rewrite_where_clause_rfc_style(context,\n                                               where_clause,\n                                               shape,\n@@ -2136,17 +2140,17 @@ fn rewrite_where_clause(context: &RewriteContext,\n                                               span_end);\n     }\n \n-    let extra_indent = Indent::new(context.config.tab_spaces, 0);\n+    let extra_indent = Indent::new(context.config.tab_spaces(), 0);\n \n-    let offset = match context.config.where_pred_indent {\n+    let offset = match context.config.where_pred_indent() {\n         IndentStyle::Block => shape.indent + extra_indent.block_indent(context.config),\n         // 6 = \"where \".len()\n         IndentStyle::Visual => shape.indent + extra_indent + 6,\n     };\n     // FIXME: if where_pred_indent != Visual, then the budgets below might\n     // be out by a char or two.\n \n-    let budget = context.config.max_width - offset.width();\n+    let budget = context.config.max_width() - offset.width();\n     let span_start = span_for_where_pred(&where_clause.predicates[0]).lo;\n     // If we don't have the start of the next span, then use the end of the\n     // predicates, but that means we miss comments.\n@@ -2164,9 +2168,9 @@ fn rewrite_where_clause(context: &RewriteContext,\n     let item_vec = items.collect::<Vec<_>>();\n     // FIXME: we don't need to collect here if the where_layout isn't\n     // HorizontalVertical.\n-    let tactic = definitive_tactic(&item_vec, context.config.where_layout, budget);\n+    let tactic = definitive_tactic(&item_vec, context.config.where_layout(), budget);\n \n-    let mut comma_tactic = context.config.trailing_comma;\n+    let mut comma_tactic = context.config.trailing_comma();\n     // Kind of a hack because we don't usually have trailing commas in where clauses.\n     if comma_tactic == SeparatorTactic::Vertical || suppress_comma {\n         comma_tactic = SeparatorTactic::Never;\n@@ -2224,7 +2228,7 @@ fn format_generics(context: &RewriteContext,\n     if !generics.where_clause.predicates.is_empty() || result.contains('\\n') {\n         let budget = try_opt!(context\n                                   .config\n-                                  .max_width\n+                                  .max_width()\n                                   .checked_sub(last_line_width(&result)));\n         let where_clause_str =\n             try_opt!(rewrite_where_clause(context,"}, {"sha": "f31f3c0c3eedaddbfdc7f8fab9f44aa8c3c4eb98", "filename": "src/lib.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/068b8b3b5c92c20d5347a30a221e53d9f63a8704/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/068b8b3b5c92c20d5347a30a221e53d9f63a8704/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=068b8b3b5c92c20d5347a30a221e53d9f63a8704", "patch": "@@ -145,12 +145,12 @@ impl Indent {\n     }\n \n     pub fn block_indent(mut self, config: &Config) -> Indent {\n-        self.block_indent += config.tab_spaces;\n+        self.block_indent += config.tab_spaces();\n         self\n     }\n \n     pub fn block_unindent(mut self, config: &Config) -> Indent {\n-        self.block_indent -= config.tab_spaces;\n+        self.block_indent -= config.tab_spaces();\n         self\n     }\n \n@@ -159,8 +159,8 @@ impl Indent {\n     }\n \n     pub fn to_string(&self, config: &Config) -> String {\n-        let (num_tabs, num_spaces) = if config.hard_tabs {\n-            (self.block_indent / config.tab_spaces, self.alignment)\n+        let (num_tabs, num_spaces) = if config.hard_tabs() {\n+            (self.block_indent / config.tab_spaces(), self.alignment)\n         } else {\n             (0, self.width())\n         };\n@@ -248,7 +248,7 @@ impl Shape {\n \n     pub fn indented(indent: Indent, config: &Config) -> Shape {\n         Shape {\n-            width: config.max_width.checked_sub(indent.width()).unwrap_or(0),\n+            width: config.max_width().checked_sub(indent.width()).unwrap_or(0),\n             indent: indent,\n             offset: indent.alignment,\n         }\n@@ -257,7 +257,7 @@ impl Shape {\n     pub fn with_max_width(&self, config: &Config) -> Shape {\n         Shape {\n             width: config\n-                .max_width\n+                .max_width()\n                 .checked_sub(self.indent.width())\n                 .unwrap_or(0),\n             ..*self\n@@ -442,13 +442,13 @@ fn format_ast<F>(krate: &ast::Crate,\n \n     // We always skip children for the \"Plain\" write mode, since there is\n     // nothing to distinguish the nested module contents.\n-    let skip_children = config.skip_children || config.write_mode == config::WriteMode::Plain;\n+    let skip_children = config.skip_children() || config.write_mode() == config::WriteMode::Plain;\n     for (path, module) in modules::list_files(krate, parse_session.codemap()) {\n         if skip_children && path.as_path() != main_file {\n             continue;\n         }\n         let path = path.to_str().unwrap();\n-        if config.verbose {\n+        if config.verbose() {\n             println!(\"Formatting {}\", path);\n         }\n         let mut visitor = FmtVisitor::from_codemap(parse_session, config);\n@@ -473,14 +473,14 @@ fn format_lines(text: &mut StringBuffer, name: &str, config: &Config, report: &m\n     let mut cur_line = 1;\n     let mut newline_count = 0;\n     let mut errors = vec![];\n-    let mut issue_seeker = BadIssueSeeker::new(config.report_todo, config.report_fixme);\n+    let mut issue_seeker = BadIssueSeeker::new(config.report_todo(), config.report_fixme());\n \n     for (c, b) in text.chars() {\n         if c == '\\r' {\n             continue;\n         }\n \n-        let format_line = config.file_lines.contains_line(name, cur_line as usize);\n+        let format_line = config.file_lines().contains_line(name, cur_line as usize);\n \n         if format_line {\n             // Add warnings for bad todos/ fixmes\n@@ -501,10 +501,10 @@ fn format_lines(text: &mut StringBuffer, name: &str, config: &Config, report: &m\n                 }\n \n                 // Check for any line width errors we couldn't correct.\n-                if config.error_on_line_overflow && line_len > config.max_width {\n+                if config.error_on_line_overflow() && line_len > config.max_width() {\n                     errors.push(FormattingError {\n                                     line: cur_line,\n-                                    kind: ErrorKind::LineOverflow(line_len, config.max_width),\n+                                    kind: ErrorKind::LineOverflow(line_len, config.max_width()),\n                                 });\n                 }\n             }\n@@ -577,7 +577,7 @@ pub fn format_input<T: Write>(input: Input,\n                               mut out: Option<&mut T>)\n                               -> Result<(Summary, FileMap, FormatReport), (io::Error, Summary)> {\n     let mut summary = Summary::new();\n-    if config.disable_all_formatting {\n+    if config.disable_all_formatting() {\n         return Ok((summary, FileMap::new(), FormatReport::new()));\n     }\n     let codemap = Rc::new(CodeMap::new());\n@@ -651,10 +651,10 @@ pub enum Input {\n \n pub fn run(input: Input, config: &Config) -> Summary {\n     let mut out = &mut stdout();\n-    output_header(out, config.write_mode).ok();\n+    output_header(out, config.write_mode()).ok();\n     match format_input(input, config, Some(out)) {\n         Ok((summary, _, report)) => {\n-            output_footer(out, config.write_mode).ok();\n+            output_footer(out, config.write_mode()).ok();\n \n             if report.has_warnings() {\n                 msg!(\"{}\", report);\n@@ -708,7 +708,7 @@ mod test {\n     #[test]\n     fn indent_to_string_hard_tabs() {\n         let mut config = Config::default();\n-        config.hard_tabs = true;\n+        config.set().hard_tabs(true);\n         let indent = Indent::new(8, 4);\n \n         // 2 tabs + 4 spaces\n@@ -719,10 +719,10 @@ mod test {\n     fn shape_visual_indent() {\n         let config = Config::default();\n         let indent = Indent::new(4, 8);\n-        let shape = Shape::legacy(config.max_width, indent);\n+        let shape = Shape::legacy(config.max_width(), indent);\n         let shape = shape.visual_indent(20);\n \n-        assert_eq!(config.max_width, shape.width);\n+        assert_eq!(config.max_width(), shape.width);\n         assert_eq!(4, shape.indent.block_indent);\n         assert_eq!(28, shape.indent.alignment);\n         assert_eq!(28, shape.offset);\n@@ -732,10 +732,10 @@ mod test {\n     fn shape_block_indent_without_alignment() {\n         let config = Config::default();\n         let indent = Indent::new(4, 0);\n-        let shape = Shape::legacy(config.max_width, indent);\n+        let shape = Shape::legacy(config.max_width(), indent);\n         let shape = shape.block_indent(20);\n \n-        assert_eq!(config.max_width, shape.width);\n+        assert_eq!(config.max_width(), shape.width);\n         assert_eq!(24, shape.indent.block_indent);\n         assert_eq!(0, shape.indent.alignment);\n         assert_eq!(0, shape.offset);\n@@ -745,10 +745,10 @@ mod test {\n     fn shape_block_indent_with_alignment() {\n         let config = Config::default();\n         let indent = Indent::new(4, 8);\n-        let shape = Shape::legacy(config.max_width, indent);\n+        let shape = Shape::legacy(config.max_width(), indent);\n         let shape = shape.block_indent(20);\n \n-        assert_eq!(config.max_width, shape.width);\n+        assert_eq!(config.max_width(), shape.width);\n         assert_eq!(4, shape.indent.block_indent);\n         assert_eq!(28, shape.indent.alignment);\n         assert_eq!(28, shape.offset);"}, {"sha": "a48f9a382e6a50451b8558a5f3cb09e964f286b6", "filename": "src/lists.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/068b8b3b5c92c20d5347a30a221e53d9f63a8704/src%2Flists.rs", "raw_url": "https://github.com/rust-lang/rust/raw/068b8b3b5c92c20d5347a30a221e53d9f63a8704/src%2Flists.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flists.rs?ref=068b8b3b5c92c20d5347a30a221e53d9f63a8704", "patch": "@@ -35,7 +35,7 @@ pub enum ListTactic {\n     Mixed,\n }\n \n-impl_enum_decodable!(ListTactic, Vertical, Horizontal, HorizontalVertical, Mixed);\n+impl_enum_serialize_and_deserialize!(ListTactic, Vertical, Horizontal, HorizontalVertical, Mixed);\n \n #[derive(Eq, PartialEq, Debug, Copy, Clone)]\n pub enum SeparatorTactic {\n@@ -44,7 +44,7 @@ pub enum SeparatorTactic {\n     Vertical,\n }\n \n-impl_enum_decodable!(SeparatorTactic, Always, Never, Vertical);\n+impl_enum_serialize_and_deserialize!(SeparatorTactic, Always, Never, Vertical);\n \n impl SeparatorTactic {\n     pub fn from_bool(b: bool) -> SeparatorTactic {\n@@ -73,7 +73,7 @@ pub fn format_fn_args<I>(items: I, shape: Shape, config: &Config) -> Option<Stri\n     list_helper(items,\n                 shape,\n                 config,\n-                ListTactic::LimitedHorizontalVertical(config.fn_call_width))\n+                ListTactic::LimitedHorizontalVertical(config.fn_call_width()))\n }\n \n pub fn format_item_list<I>(items: I, shape: Shape, config: &Config) -> Option<String>\n@@ -525,14 +525,14 @@ pub fn struct_lit_shape(shape: Shape,\n                         prefix_width: usize,\n                         suffix_width: usize)\n                         -> Option<(Option<Shape>, Shape)> {\n-    let v_shape = match context.config.struct_lit_style {\n+    let v_shape = match context.config.struct_lit_style() {\n         IndentStyle::Visual => {\n             try_opt!(try_opt!(shape.shrink_left(prefix_width)).sub_width(suffix_width))\n         }\n         IndentStyle::Block => {\n-            let shape = shape.block_indent(context.config.tab_spaces);\n+            let shape = shape.block_indent(context.config.tab_spaces());\n             Shape {\n-                width: try_opt!(context.config.max_width.checked_sub(shape.indent.width())),\n+                width: try_opt!(context.config.max_width().checked_sub(shape.indent.width())),\n                 ..shape\n             }\n         }\n@@ -547,13 +547,14 @@ pub fn struct_lit_tactic(h_shape: Option<Shape>,\n                          items: &[ListItem])\n                          -> DefinitiveListTactic {\n     if let Some(h_shape) = h_shape {\n-        let mut prelim_tactic = match (context.config.struct_lit_style, items.len()) {\n+        let mut prelim_tactic = match (context.config.struct_lit_style(), items.len()) {\n             (IndentStyle::Visual, 1) => ListTactic::HorizontalVertical,\n-            _ => context.config.struct_lit_multiline_style.to_list_tactic(),\n+            _ => context.config.struct_lit_multiline_style().to_list_tactic(),\n         };\n \n         if prelim_tactic == ListTactic::HorizontalVertical && items.len() > 1 {\n-            prelim_tactic = ListTactic::LimitedHorizontalVertical(context.config.struct_lit_width);\n+            prelim_tactic =\n+                ListTactic::LimitedHorizontalVertical(context.config.struct_lit_width());\n         }\n \n         definitive_tactic(items, prelim_tactic, h_shape.width)\n@@ -581,15 +582,15 @@ pub fn struct_lit_formatting<'a>(shape: Shape,\n                                  context: &'a RewriteContext,\n                                  force_no_trailing_comma: bool)\n                                  -> ListFormatting<'a> {\n-    let ends_with_newline = context.config.struct_lit_style != IndentStyle::Visual &&\n+    let ends_with_newline = context.config.struct_lit_style() != IndentStyle::Visual &&\n                             tactic == DefinitiveListTactic::Vertical;\n     ListFormatting {\n         tactic: tactic,\n         separator: \",\",\n         trailing_separator: if force_no_trailing_comma {\n             SeparatorTactic::Never\n         } else {\n-            context.config.trailing_comma\n+            context.config.trailing_comma()\n         },\n         shape: shape,\n         ends_with_newline: ends_with_newline,"}, {"sha": "b5644fb014c5c876dfb0db7be5270c69594d96ee", "filename": "src/macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/068b8b3b5c92c20d5347a30a221e53d9f63a8704/src%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/068b8b3b5c92c20d5347a30a221e53d9f63a8704/src%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmacros.rs?ref=068b8b3b5c92c20d5347a30a221e53d9f63a8704", "patch": "@@ -67,7 +67,7 @@ pub fn rewrite_macro(mac: &ast::Mac,\n                      -> Option<String> {\n     let mut context = &mut context.clone();\n     context.inside_macro = true;\n-    if context.config.use_try_shorthand {\n+    if context.config.use_try_shorthand() {\n         if let Some(expr) = convert_try_mac(mac, context) {\n             return expr.rewrite(context, shape);\n         }"}, {"sha": "2f4dda2a1b4514eb307ac1d30d751eea0dc0b924", "filename": "src/missed_spans.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/068b8b3b5c92c20d5347a30a221e53d9f63a8704/src%2Fmissed_spans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/068b8b3b5c92c20d5347a30a221e53d9f63a8704/src%2Fmissed_spans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmissed_spans.rs?ref=068b8b3b5c92c20d5347a30a221e53d9f63a8704", "patch": "@@ -116,7 +116,7 @@ impl<'a> FmtVisitor<'a> {\n                 .collect()\n         }\n \n-        let replaced = match self.config.write_mode {\n+        let replaced = match self.config.write_mode() {\n             WriteMode::Coverage => replace_chars(old_snippet),\n             _ => old_snippet.to_owned(),\n         };\n@@ -138,7 +138,7 @@ impl<'a> FmtVisitor<'a> {\n \n                 if rewrite_next_comment &&\n                    !self.config\n-                       .file_lines\n+                       .file_lines()\n                        .intersects_range(file_name, cur_line, cur_line + subslice_num_lines) {\n                     rewrite_next_comment = false;\n                 }\n@@ -154,8 +154,8 @@ impl<'a> FmtVisitor<'a> {\n                         self.buffer.push_str(\" \");\n                     }\n \n-                    let comment_width = ::std::cmp::min(self.config.comment_width,\n-                                                        self.config.max_width -\n+                    let comment_width = ::std::cmp::min(self.config.comment_width(),\n+                                                        self.config.max_width() -\n                                                         self.block_indent.width());\n \n                     self.buffer.push_str(&rewrite_comment(subslice,\n@@ -196,7 +196,7 @@ impl<'a> FmtVisitor<'a> {\n                 i += offset;\n \n                 if c == '\\n' {\n-                    if !self.config.file_lines.contains_line(file_name, cur_line) {\n+                    if !self.config.file_lines().contains_line(file_name, cur_line) {\n                         last_wspace = None;\n                     }\n "}, {"sha": "5dc70f6d2d8737b1114a60b7cc9e2b39d3bfd40a", "filename": "src/patterns.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/068b8b3b5c92c20d5347a30a221e53d9f63a8704/src%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/068b8b3b5c92c20d5347a30a221e53d9f63a8704/src%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fpatterns.rs?ref=068b8b3b5c92c20d5347a30a221e53d9f63a8704", "patch": "@@ -50,7 +50,7 @@ impl Rewrite for Pat {\n                 };\n \n                 let result = format!(\"{}{}{}{}\", prefix, mut_infix, id_str, sub_pat);\n-                wrap_str(result, context.config.max_width, shape)\n+                wrap_str(result, context.config.max_width(), shape)\n             }\n             PatKind::Wild => {\n                 if 1 <= shape.width {\n@@ -107,19 +107,21 @@ impl Rewrite for Pat {\n                 let pats = try_opt!(pats);\n \n                 // Unwrap all the sub-strings and join them with commas.\n-                let result = if context.config.spaces_within_square_brackets {\n+                let result = if context.config.spaces_within_square_brackets() {\n                     format!(\"[ {} ]\", pats.join(\", \"))\n                 } else {\n                     format!(\"[{}]\", pats.join(\", \"))\n                 };\n-                wrap_str(result, context.config.max_width, shape)\n+                wrap_str(result, context.config.max_width(), shape)\n             }\n             PatKind::Struct(ref path, ref fields, elipses) => {\n                 rewrite_struct_pat(path, fields, elipses, self.span, context, shape)\n             }\n             // FIXME(#819) format pattern macros.\n             PatKind::Mac(..) => {\n-                wrap_str(context.snippet(self.span), context.config.max_width, shape)\n+                wrap_str(context.snippet(self.span),\n+                         context.config.max_width(),\n+                         shape)\n             }\n         }\n     }\n@@ -186,9 +188,10 @@ fn rewrite_struct_pat(path: &ast::Path,\n     }\n \n \n-    let fields_str = if context.config.struct_lit_style == IndentStyle::Block &&\n+    let fields_str = if context.config.struct_lit_style() == IndentStyle::Block &&\n                         (fields_str.contains('\\n') ||\n-                         context.config.struct_lit_multiline_style == MultilineStyle::ForceMulti ||\n+                         context.config.struct_lit_multiline_style() ==\n+                         MultilineStyle::ForceMulti ||\n                          fields_str.len() > h_shape.map(|s| s.width).unwrap_or(0)) {\n         format!(\"\\n{}{}\\n{}\",\n                 v_shape.indent.to_string(context.config),\n@@ -209,7 +212,7 @@ impl Rewrite for FieldPat {\n             pat\n         } else {\n             wrap_str(format!(\"{}: {}\", self.ident.to_string(), try_opt!(pat)),\n-                     context.config.max_width,\n+                     context.config.max_width(),\n                      shape)\n         }\n     }\n@@ -295,7 +298,7 @@ fn rewrite_tuple_pat(pats: &[ptr::P<ast::Pat>],\n     // Condense wildcard string suffix into a single ..\n     let wildcard_suffix_len = count_wildcard_suffix_len(&items);\n \n-    let list = if context.config.condense_wildcard_suffixes && wildcard_suffix_len >= 2 {\n+    let list = if context.config.condense_wildcard_suffixes() && wildcard_suffix_len >= 2 {\n         let new_item_count = 1 + pats.len() - wildcard_suffix_len;\n         items[new_item_count - 1].item = Some(\"..\".to_owned());\n \n@@ -307,15 +310,15 @@ fn rewrite_tuple_pat(pats: &[ptr::P<ast::Pat>],\n \n     match path_str {\n         Some(path_str) => {\n-            Some(if context.config.spaces_within_parens {\n+            Some(if context.config.spaces_within_parens() {\n                      format!(\"{}( {} )\", path_str, list)\n                  } else {\n                      format!(\"{}({})\", path_str, list)\n                  })\n         }\n         None => {\n             let comma = if add_comma { \",\" } else { \"\" };\n-            Some(if context.config.spaces_within_parens {\n+            Some(if context.config.spaces_within_parens() {\n                      format!(\"( {}{} )\", list, comma)\n                  } else {\n                      format!(\"({}{})\", list, comma)"}, {"sha": "365d205aef100a4187fe1018aa7f3d764a19c043", "filename": "src/string.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/068b8b3b5c92c20d5347a30a221e53d9f63a8704/src%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/068b8b3b5c92c20d5347a30a221e53d9f63a8704/src%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstring.rs?ref=068b8b3b5c92c20d5347a30a221e53d9f63a8704", "patch": "@@ -119,7 +119,7 @@ pub fn rewrite_string<'a>(orig: &str, fmt: &StringFormat<'a>) -> Option<String>\n     }\n \n     result.push_str(fmt.closer);\n-    wrap_str(result, fmt.config.max_width, fmt.shape)\n+    wrap_str(result, fmt.config.max_width(), fmt.shape)\n }\n \n #[cfg(test)]"}, {"sha": "ffa9639005a0b0117d59c0e4b52b42491c50b987", "filename": "src/types.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/068b8b3b5c92c20d5347a30a221e53d9f63a8704/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/068b8b3b5c92c20d5347a30a221e53d9f63a8704/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=068b8b3b5c92c20d5347a30a221e53d9f63a8704", "patch": "@@ -53,7 +53,7 @@ pub fn rewrite_path(context: &RewriteContext,\n \n     if let Some(qself) = qself {\n         result.push('<');\n-        if context.config.spaces_within_angle_brackets {\n+        if context.config.spaces_within_angle_brackets() {\n             result.push_str(\" \")\n         }\n \n@@ -79,7 +79,7 @@ pub fn rewrite_path(context: &RewriteContext,\n                                                     shape));\n         }\n \n-        if context.config.spaces_within_angle_brackets {\n+        if context.config.spaces_within_angle_brackets() {\n             result.push_str(\" \")\n         }\n \n@@ -158,7 +158,7 @@ impl<'a> Rewrite for SegmentParam<'a> {\n             SegmentParam::LifeTime(lt) => lt.rewrite(context, shape),\n             SegmentParam::Type(ty) => ty.rewrite(context, shape),\n             SegmentParam::Binding(binding) => {\n-                let mut result = match context.config.type_punctuation_density {\n+                let mut result = match context.config.type_punctuation_density() {\n                     TypeDensity::Wide => format!(\"{} = \", binding.ident),\n                     TypeDensity::Compressed => format!(\"{}=\", binding.ident),\n                 };\n@@ -236,7 +236,7 @@ fn rewrite_segment(path_context: PathContext,\n                 // Update position of last bracket.\n                 *span_lo = next_span_lo;\n \n-                if context.config.spaces_within_angle_brackets && list_str.len() > 0 {\n+                if context.config.spaces_within_angle_brackets() && list_str.len() > 0 {\n                     format!(\"{}< {} >\", separator, list_str)\n                 } else {\n                     format!(\"{}<{}>\", separator, list_str)\n@@ -337,16 +337,16 @@ fn format_function_type<'a, I>(inputs: I,\n         String::new()\n     };\n \n-    Some(if context.config.spaces_within_parens {\n+    Some(if context.config.spaces_within_parens() {\n              format!(\"( {} ){}{}\", list_str, infix, output)\n          } else {\n              format!(\"({}){}{}\", list_str, infix, output)\n          })\n }\n \n fn type_bound_colon(context: &RewriteContext) -> &'static str {\n-    colon_spaces(context.config.space_before_bound,\n-                 context.config.space_after_bound_colon)\n+    colon_spaces(context.config.space_before_bound(),\n+                 context.config.space_after_bound_colon())\n }\n \n impl Rewrite for ast::WherePredicate {\n@@ -369,7 +369,7 @@ impl Rewrite for ast::WherePredicate {\n                                      .intersperse(Some(\", \".to_string()))\n                                      .collect());\n \n-                    let joiner = match context.config.type_punctuation_density {\n+                    let joiner = match context.config.type_punctuation_density() {\n                         TypeDensity::Compressed => \"+\",\n                         TypeDensity::Wide => \" + \",\n                     };\n@@ -385,7 +385,7 @@ impl Rewrite for ast::WherePredicate {\n                                                     .intersperse(Some(joiner.to_string()))\n                                                     .collect());\n \n-                    if context.config.spaces_within_angle_brackets && lifetime_str.len() > 0 {\n+                    if context.config.spaces_within_angle_brackets() && lifetime_str.len() > 0 {\n                         format!(\"for< {} > {}{}{}\",\n                                 lifetime_str,\n                                 type_str,\n@@ -395,7 +395,7 @@ impl Rewrite for ast::WherePredicate {\n                         format!(\"for<{}> {}{}{}\", lifetime_str, type_str, colon, bounds_str)\n                     }\n                 } else {\n-                    let joiner = match context.config.type_punctuation_density {\n+                    let joiner = match context.config.type_punctuation_density() {\n                         TypeDensity::Compressed => \"+\",\n                         TypeDensity::Wide => \" + \",\n                     };\n@@ -436,7 +436,7 @@ impl Rewrite for ast::WherePredicate {\n             }\n         };\n \n-        wrap_str(result, context.config.max_width, shape)\n+        wrap_str(result, context.config.max_width(), shape)\n     }\n }\n \n@@ -463,12 +463,12 @@ fn rewrite_bounded_lifetime<'b, I>(lt: &ast::Lifetime,\n                                             .map(|b| b.rewrite(context, shape))\n                                             .collect());\n         let colon = type_bound_colon(context);\n-        let joiner = match context.config.type_punctuation_density {\n+        let joiner = match context.config.type_punctuation_density() {\n             TypeDensity::Compressed => \"+\",\n             TypeDensity::Wide => \" + \",\n         };\n         let result = format!(\"{}{}{}\", result, colon, appendix.join(joiner));\n-        wrap_str(result, context.config.max_width, shape)\n+        wrap_str(result, context.config.max_width(), shape)\n     }\n }\n \n@@ -492,19 +492,19 @@ impl Rewrite for ast::TyParamBound {\n impl Rewrite for ast::Lifetime {\n     fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n         wrap_str(pprust::lifetime_to_string(self),\n-                 context.config.max_width,\n+                 context.config.max_width(),\n                  shape)\n     }\n }\n \n impl Rewrite for ast::TyParamBounds {\n     fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n-        let joiner = match context.config.type_punctuation_density {\n+        let joiner = match context.config.type_punctuation_density() {\n             TypeDensity::Compressed => \"+\",\n             TypeDensity::Wide => \" + \",\n         };\n         let strs: Vec<_> = try_opt!(self.iter().map(|b| b.rewrite(context, shape)).collect());\n-        wrap_str(strs.join(joiner), context.config.max_width, shape)\n+        wrap_str(strs.join(joiner), context.config.max_width(), shape)\n     }\n }\n \n@@ -513,14 +513,14 @@ impl Rewrite for ast::TyParam {\n         let mut result = String::with_capacity(128);\n         result.push_str(&self.ident.to_string());\n         if !self.bounds.is_empty() {\n-            if context.config.space_before_bound {\n+            if context.config.space_before_bound() {\n                 result.push_str(\" \");\n             }\n             result.push_str(\":\");\n-            if context.config.space_after_bound_colon {\n+            if context.config.space_after_bound_colon() {\n                 result.push_str(\" \");\n             }\n-            let joiner = match context.config.type_punctuation_density {\n+            let joiner = match context.config.type_punctuation_density() {\n                 TypeDensity::Compressed => \"+\",\n                 TypeDensity::Wide => \" + \",\n             };\n@@ -535,7 +535,7 @@ impl Rewrite for ast::TyParam {\n         }\n         if let Some(ref def) = self.default {\n \n-            let eq_str = match context.config.type_punctuation_density {\n+            let eq_str = match context.config.type_punctuation_density() {\n                 TypeDensity::Compressed => \"=\",\n                 TypeDensity::Wide => \" = \",\n             };\n@@ -546,7 +546,7 @@ impl Rewrite for ast::TyParam {\n             result.push_str(&rewrite);\n         }\n \n-        wrap_str(result, context.config.max_width, shape)\n+        wrap_str(result, context.config.max_width(), shape)\n     }\n }\n \n@@ -567,7 +567,7 @@ impl Rewrite for ast::PolyTraitRef {\n                                                                          shape.indent +\n                                                                          extra_offset)));\n \n-            Some(if context.config.spaces_within_angle_brackets && lifetime_str.len() > 0 {\n+            Some(if context.config.spaces_within_angle_brackets() && lifetime_str.len() > 0 {\n                      format!(\"for< {} > {}\", lifetime_str, path_str)\n                  } else {\n                      format!(\"for<{}> {}\", lifetime_str, path_str)\n@@ -634,20 +634,20 @@ impl Rewrite for ast::Ty {\n             ast::TyKind::Paren(ref ty) => {\n                 let budget = try_opt!(shape.width.checked_sub(2));\n                 ty.rewrite(context, Shape::legacy(budget, shape.indent + 1))\n-                    .map(|ty_str| if context.config.spaces_within_parens {\n+                    .map(|ty_str| if context.config.spaces_within_parens() {\n                              format!(\"( {} )\", ty_str)\n                          } else {\n                              format!(\"({})\", ty_str)\n                          })\n             }\n             ast::TyKind::Slice(ref ty) => {\n-                let budget = if context.config.spaces_within_square_brackets {\n+                let budget = if context.config.spaces_within_square_brackets() {\n                     try_opt!(shape.width.checked_sub(4))\n                 } else {\n                     try_opt!(shape.width.checked_sub(2))\n                 };\n                 ty.rewrite(context, Shape::legacy(budget, shape.indent + 1))\n-                    .map(|ty_str| if context.config.spaces_within_square_brackets {\n+                    .map(|ty_str| if context.config.spaces_within_square_brackets() {\n                              format!(\"[ {} ]\", ty_str)\n                          } else {\n                              format!(\"[{}]\", ty_str)\n@@ -660,7 +660,7 @@ impl Rewrite for ast::Ty {\n                 rewrite_path(context, PathContext::Type, q_self.as_ref(), path, shape)\n             }\n             ast::TyKind::Array(ref ty, ref repeats) => {\n-                let use_spaces = context.config.spaces_within_square_brackets;\n+                let use_spaces = context.config.spaces_within_square_brackets();\n                 let lbr = if use_spaces { \"[ \" } else { \"[\" };\n                 let rbr = if use_spaces { \" ]\" } else { \"]\" };\n                 rewrite_pair(&**ty, &**repeats, lbr, \"; \", rbr, context, shape)\n@@ -712,7 +712,7 @@ fn rewrite_bare_fn(bare_fn: &ast::BareFnTy,\n     result.push_str(::utils::format_unsafety(bare_fn.unsafety));\n \n     if bare_fn.abi != abi::Abi::Rust {\n-        result.push_str(&::utils::format_abi(bare_fn.abi, context.config.force_explicit_abi));\n+        result.push_str(&::utils::format_abi(bare_fn.abi, context.config.force_explicit_abi()));\n     }\n \n     result.push_str(\"fn\");"}, {"sha": "bb9d178b83fcb2d998fd5fedbe02c4acabdd9e32", "filename": "src/utils.rs", "status": "modified", "additions": 22, "deletions": 3, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/068b8b3b5c92c20d5347a30a221e53d9f63a8704/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/068b8b3b5c92c20d5347a30a221e53d9f63a8704/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=068b8b3b5c92c20d5347a30a221e53d9f63a8704", "patch": "@@ -189,10 +189,29 @@ pub fn trim_newlines(input: &str) -> &str {\n     }\n }\n \n-// Macro for deriving implementations of Decodable for enums\n+// Macro for deriving implementations of Serialize/Deserialize for enums\n #[macro_export]\n-macro_rules! impl_enum_decodable {\n+macro_rules! impl_enum_serialize_and_deserialize {\n     ( $e:ident, $( $x:ident ),* ) => {\n+        impl ::serde::ser::Serialize for $e {\n+            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n+                where S: ::serde::ser::Serializer\n+            {\n+                use serde::ser::Error;\n+\n+                // We don't know whether the user of the macro has given us all options.\n+                #[allow(unreachable_patterns)]\n+                match *self {\n+                    $(\n+                        $e::$x => serializer.serialize_str(stringify!($x)),\n+                    )*\n+                    _ => {\n+                        Err(S::Error::custom(format!(\"Cannot serialize {:?}\", self)))\n+                    }\n+                }\n+            }\n+        }\n+\n         impl<'de> ::serde::de::Deserialize<'de> for $e {\n             fn deserialize<D>(d: D) -> Result<Self, D::Error>\n                     where D: ::serde::Deserializer<'de> {\n@@ -312,7 +331,7 @@ pub fn wrap_str<S: AsRef<str>>(s: S, max_width: usize, shape: Shape) -> Option<S\n \n impl Rewrite for String {\n     fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n-        wrap_str(self, context.config.max_width, shape).map(ToOwned::to_owned)\n+        wrap_str(self, context.config.max_width(), shape).map(ToOwned::to_owned)\n     }\n }\n "}, {"sha": "0e6817be4f7020be88dab29bc4c9fe79420818b0", "filename": "src/visitor.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/068b8b3b5c92c20d5347a30a221e53d9f63a8704/src%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/068b8b3b5c92c20d5347a30a221e53d9f63a8704/src%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvisitor.rs?ref=068b8b3b5c92c20d5347a30a221e53d9f63a8704", "patch": "@@ -65,7 +65,7 @@ impl<'a> FmtVisitor<'a> {\n \n         // FIXME(#434): Move this check to somewhere more central, eg Rewrite.\n         if !self.config\n-               .file_lines\n+               .file_lines()\n                .intersects(&self.codemap.lookup_line_range(stmt.span)) {\n             return;\n         }\n@@ -128,10 +128,10 @@ impl<'a> FmtVisitor<'a> {\n     // level.\n     fn close_block(&mut self) {\n         let total_len = self.buffer.len;\n-        let chars_too_many = if self.config.hard_tabs {\n+        let chars_too_many = if self.config.hard_tabs() {\n             1\n         } else {\n-            self.config.tab_spaces\n+            self.config.tab_spaces()\n         };\n         self.buffer.truncate(total_len - chars_too_many);\n         self.buffer.push_str(\"}\");\n@@ -524,8 +524,8 @@ impl<'a> FmtVisitor<'a> {\n             // If the next item is a `use` declaration, then extract it and any subsequent `use`s\n             // to be potentially reordered within `format_imports`. Otherwise, just format the\n             // next item for output.\n-            if self.config.reorder_imports && is_use_item(&*items_left[0]) {\n-                let reorder_imports_in_group = self.config.reorder_imports_in_group;\n+            if self.config.reorder_imports() && is_use_item(&*items_left[0]) {\n+                let reorder_imports_in_group = self.config.reorder_imports_in_group();\n                 let mut last = self.codemap.lookup_line_range(item_bound(&items_left[0]));\n                 let use_item_length = items_left\n                     .iter()\n@@ -625,13 +625,13 @@ impl<'a> Rewrite for [ast::Attribute] {\n                 let multi_line = a_str.starts_with(\"//\") && comment.matches('\\n').count() > 1;\n                 let comment = comment.trim();\n                 if !comment.is_empty() {\n-                    let comment = try_opt!(rewrite_comment(comment,\n-                                                           false,\n-                                                           Shape::legacy(context.config\n-                                                                             .comment_width -\n-                                                                         shape.indent.width(),\n-                                                                         shape.indent),\n-                                                           context.config));\n+                    let comment =\n+                        try_opt!(rewrite_comment(comment,\n+                                                 false,\n+                                                 Shape::legacy(context.config.comment_width() -\n+                                                               shape.indent.width(),\n+                                                               shape.indent),\n+                                                 context.config));\n                     result.push_str(&indent);\n                     result.push_str(&comment);\n                     result.push('\\n');\n@@ -644,7 +644,7 @@ impl<'a> Rewrite for [ast::Attribute] {\n             if a_str.starts_with(\"//\") {\n                 a_str = try_opt!(rewrite_comment(&a_str,\n                                                  false,\n-                                                 Shape::legacy(context.config.comment_width -\n+                                                 Shape::legacy(context.config.comment_width() -\n                                                                shape.indent.width(),\n                                                                shape.indent),\n                                                  context.config));"}, {"sha": "58e44ee538100fc397e24674c6f964991c145335", "filename": "tests/system.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/068b8b3b5c92c20d5347a30a221e53d9f63a8704/tests%2Fsystem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/068b8b3b5c92c20d5347a30a221e53d9f63a8704/tests%2Fsystem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsystem.rs?ref=068b8b3b5c92c20d5347a30a221e53d9f63a8704", "patch": "@@ -229,7 +229,7 @@ fn read_config(filename: &str) -> Config {\n     }\n \n     // Don't generate warnings for to-do items.\n-    config.report_todo = ReportTactic::Never;\n+    config.set().report_todo(ReportTactic::Never);\n \n     config\n }"}]}